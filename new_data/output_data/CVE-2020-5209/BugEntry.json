{"buggy_code": ["$NHDT-Branch: NetHack-3.6 $:$NHDT-Revision: 1.3 $ $NHDT-Date: 1578996303 2020/01/14 10:05:03 $\n\nfixes36.5 contains a terse summary of changes made to 3.6.4 in order to\nproduce 3.6.5 as well as any post-release fixes in binaries.\n\n\nGeneral Fixes and Modified Features\n-----------------------------------\nfix accessing mons[-1] when trying to gate in a non-valid demon\nfix accessing mons[-1] when monster figures out if a tin cures stoning\nhave string_for_opt() return empty_optstr on failure\nensure existing callers of string_for_opt() check return value before using it\nfix potential buffer overflow in add_menu_coloring()\nfix potential buffer overflow in sym_val()\nfix potential buffer overflow in pline(), raw_printf(), and config_error_add()\n\n\nFixes to Post-3.6.4 Problems that Were Exposed Via git Repository\n------------------------------------------------------------------\n\n\nPlatform- and/or Interface-Specific Fixes or Features\n-----------------------------------------------------\nWindows OPTIONS=map_mode:fit_to_screen could cause a game start failure\n\n\nGeneral New Features\n--------------------\nnone\n\n", "/* NetHack 3.6\ttopten.c\t$NHDT-Date: 1450451497 2015/12/18 15:11:37 $  $NHDT-Branch: NetHack-3.6.0 $:$NHDT-Revision: 1.44 $ */\n/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */\n/*-Copyright (c) Robert Patrick Rankin, 2012. */\n/* NetHack may be freely redistributed.  See license for details. */\n\n#include \"hack.h\"\n#include \"dlb.h\"\n#ifdef SHORT_FILENAMES\n#include \"patchlev.h\"\n#else\n#include \"patchlevel.h\"\n#endif\n\n#ifdef VMS\n/* We don't want to rewrite the whole file, because that entails\n   creating a new version which requires that the old one be deletable. */\n#define UPDATE_RECORD_IN_PLACE\n#endif\n\n/*\n * Updating in place can leave junk at the end of the file in some\n * circumstances (if it shrinks and the O.S. doesn't have a straightforward\n * way to truncate it).  The trailing junk is harmless and the code\n * which reads the scores will ignore it.\n */\n#ifdef UPDATE_RECORD_IN_PLACE\nstatic long final_fpos;\n#endif\n\n#define done_stopprint program_state.stopprint\n\n#define newttentry() (struct toptenentry *) alloc(sizeof (struct toptenentry))\n#define dealloc_ttentry(ttent) free((genericptr_t) (ttent))\n#ifndef NAMSZ\n/* Changing NAMSZ can break your existing record/logfile */\n#define NAMSZ 10\n#endif\n#define DTHSZ 100\n#define ROLESZ 3\n\nstruct toptenentry {\n    struct toptenentry *tt_next;\n#ifdef UPDATE_RECORD_IN_PLACE\n    long fpos;\n#endif\n    long points;\n    int deathdnum, deathlev;\n    int maxlvl, hp, maxhp, deaths;\n    int ver_major, ver_minor, patchlevel;\n    long deathdate, birthdate;\n    int uid;\n    char plrole[ROLESZ + 1];\n    char plrace[ROLESZ + 1];\n    char plgend[ROLESZ + 1];\n    char plalign[ROLESZ + 1];\n    char name[NAMSZ + 1];\n    char death[DTHSZ + 1];\n} * tt_head;\n/* size big enough to read in all the string fields at once; includes\n   room for separating space or trailing newline plus string terminator */\n#define SCANBUFSZ (4 * (ROLESZ + 1) + (NAMSZ + 1) + (DTHSZ + 1) + 1)\n\nSTATIC_DCL void FDECL(topten_print, (const char *));\nSTATIC_DCL void FDECL(topten_print_bold, (const char *));\nSTATIC_DCL void NDECL(outheader);\nSTATIC_DCL void FDECL(outentry, (int, struct toptenentry *, BOOLEAN_P));\nSTATIC_DCL void FDECL(discardexcess, (FILE *));\nSTATIC_DCL void FDECL(readentry, (FILE *, struct toptenentry *));\nSTATIC_DCL void FDECL(writeentry, (FILE *, struct toptenentry *));\n#ifdef XLOGFILE\nSTATIC_DCL void FDECL(writexlentry, (FILE *, struct toptenentry *, int));\nSTATIC_DCL long NDECL(encodexlogflags);\nSTATIC_DCL long NDECL(encodeconduct);\nSTATIC_DCL long NDECL(encodeachieve);\n#endif\nSTATIC_DCL void FDECL(free_ttlist, (struct toptenentry *));\nSTATIC_DCL int FDECL(classmon, (char *, BOOLEAN_P));\nSTATIC_DCL int FDECL(score_wanted, (BOOLEAN_P, int, struct toptenentry *, int,\n                                    const char **, int));\n#ifdef NO_SCAN_BRACK\nSTATIC_DCL void FDECL(nsb_mung_line, (char *));\nSTATIC_DCL void FDECL(nsb_unmung_line, (char *));\n#endif\n\nstatic winid toptenwin = WIN_ERR;\n\n/* \"killed by\",&c [\"an\"] 'killer.name' */\nvoid\nformatkiller(buf, siz, how, incl_helpless)\nchar *buf;\nunsigned siz;\nint how;\nboolean incl_helpless;\n{\n    static NEARDATA const char *const killed_by_prefix[] = {\n        /* DIED, CHOKING, POISONING, STARVING, */\n        \"killed by \", \"choked on \", \"poisoned by \", \"died of \",\n        /* DROWNING, BURNING, DISSOLVED, CRUSHING, */\n        \"drowned in \", \"burned by \", \"dissolved in \", \"crushed to death by \",\n        /* STONING, TURNED_SLIME, GENOCIDED, */\n        \"petrified by \", \"turned to slime by \", \"killed by \",\n        /* PANICKED, TRICKED, QUIT, ESCAPED, ASCENDED */\n        \"\", \"\", \"\", \"\", \"\"\n    };\n    unsigned l;\n    char c, *kname = killer.name;\n\n    buf[0] = '\\0'; /* lint suppression */\n    switch (killer.format) {\n    default:\n        impossible(\"bad killer format? (%d)\", killer.format);\n        /*FALLTHRU*/\n    case NO_KILLER_PREFIX:\n        break;\n    case KILLED_BY_AN:\n        kname = an(kname);\n        /*FALLTHRU*/\n    case KILLED_BY:\n        (void) strncat(buf, killed_by_prefix[how], siz - 1);\n        l = strlen(buf);\n        buf += l, siz -= l;\n        break;\n    }\n    /* Copy kname into buf[].\n     * Object names and named fruit have already been sanitized, but\n     * monsters can have \"called 'arbitrary text'\" attached to them,\n     * so make sure that that text can't confuse field splitting when\n     * record, logfile, or xlogfile is re-read at some later point.\n     */\n    while (--siz > 0) {\n        c = *kname++;\n        if (!c)\n            break;\n        else if (c == ',')\n            c = ';';\n        /* 'xlogfile' doesn't really need protection for '=', but\n           fixrecord.awk for corrupted 3.6.0 'record' does (only\n           if using xlogfile rather than logfile to repair record) */\n        else if (c == '=')\n            c = '_';\n        /* tab is not possible due to use of mungspaces() when naming;\n           it would disrupt xlogfile parsing if it were present */\n        else if (c == '\\t')\n            c = ' ';\n        *buf++ = c;\n    }\n    *buf = '\\0';\n\n    if (incl_helpless && multi) {\n        /* X <= siz: 'sizeof \"string\"' includes 1 for '\\0' terminator */\n        if (multi_reason && strlen(multi_reason) + sizeof \", while \" <= siz)\n            Sprintf(buf, \", while %s\", multi_reason);\n        /* either multi_reason wasn't specified or wouldn't fit */\n        else if (sizeof \", while helpless\" <= siz)\n            Strcpy(buf, \", while helpless\");\n        /* else extra death info won't fit, so leave it out */\n    }\n}\n\nSTATIC_OVL void\ntopten_print(x)\nconst char *x;\n{\n    if (toptenwin == WIN_ERR)\n        raw_print(x);\n    else\n        putstr(toptenwin, ATR_NONE, x);\n}\n\nSTATIC_OVL void\ntopten_print_bold(x)\nconst char *x;\n{\n    if (toptenwin == WIN_ERR)\n        raw_print_bold(x);\n    else\n        putstr(toptenwin, ATR_BOLD, x);\n}\n\nint\nobservable_depth(lev)\nd_level *lev;\n{\n#if 0\n    /* if we ever randomize the order of the elemental planes, we\n       must use a constant external representation in the record file */\n    if (In_endgame(lev)) {\n        if (Is_astralevel(lev))\n            return -5;\n        else if (Is_waterlevel(lev))\n            return -4;\n        else if (Is_firelevel(lev))\n            return -3;\n        else if (Is_airlevel(lev))\n            return -2;\n        else if (Is_earthlevel(lev))\n            return -1;\n        else\n            return 0; /* ? */\n    } else\n#endif\n    return depth(lev);\n}\n\n/* throw away characters until current record has been entirely consumed */\nSTATIC_OVL void\ndiscardexcess(rfile)\nFILE *rfile;\n{\n    int c;\n\n    do {\n        c = fgetc(rfile);\n    } while (c != '\\n' && c != EOF);\n}\n\nSTATIC_OVL void\nreadentry(rfile, tt)\nFILE *rfile;\nstruct toptenentry *tt;\n{\n    char inbuf[SCANBUFSZ], s1[SCANBUFSZ], s2[SCANBUFSZ], s3[SCANBUFSZ],\n        s4[SCANBUFSZ], s5[SCANBUFSZ], s6[SCANBUFSZ];\n\n#ifdef NO_SCAN_BRACK /* Version_ Pts DgnLevs_ Hp___ Died__Born id */\n    static const char fmt[] = \"%d %d %d %ld %d %d %d %d %d %d %ld %ld %d%*c\";\n    static const char fmt32[] = \"%c%c %s %s%*c\";\n    static const char fmt33[] = \"%s %s %s %s %s %s%*c\";\n#else\n    static const char fmt[] = \"%d.%d.%d %ld %d %d %d %d %d %d %ld %ld %d \";\n    static const char fmt32[] = \"%c%c %[^,],%[^\\n]%*c\";\n    static const char fmt33[] = \"%s %s %s %s %[^,],%[^\\n]%*c\";\n#endif\n\n#ifdef UPDATE_RECORD_IN_PLACE\n    /* note: input below must read the record's terminating newline */\n    final_fpos = tt->fpos = ftell(rfile);\n#endif\n#define TTFIELDS 13\n    if (fscanf(rfile, fmt, &tt->ver_major, &tt->ver_minor, &tt->patchlevel,\n               &tt->points, &tt->deathdnum, &tt->deathlev, &tt->maxlvl,\n               &tt->hp, &tt->maxhp, &tt->deaths, &tt->deathdate,\n               &tt->birthdate, &tt->uid) != TTFIELDS) {\n#undef TTFIELDS\n        tt->points = 0;\n        discardexcess(rfile);\n    } else {\n        /* load remainder of record into a local buffer;\n           this imposes an implicit length limit of SCANBUFSZ\n           on every string field extracted from the buffer */\n        if (!fgets(inbuf, sizeof inbuf, rfile)) {\n            /* sscanf will fail and tt->points will be set to 0 */\n            *inbuf = '\\0';\n        } else if (!index(inbuf, '\\n')) {\n            Strcpy(&inbuf[sizeof inbuf - 2], \"\\n\");\n            discardexcess(rfile);\n        }\n        /* Check for backwards compatibility */\n        if (tt->ver_major < 3 || (tt->ver_major == 3 && tt->ver_minor < 3)) {\n            int i;\n\n            if (sscanf(inbuf, fmt32, tt->plrole, tt->plgend, s1, s2) == 4) {\n                tt->plrole[1] = tt->plgend[1] = '\\0'; /* read via %c */\n                copynchars(tt->name, s1, (int) (sizeof tt->name) - 1);\n                copynchars(tt->death, s2, (int) (sizeof tt->death) - 1);\n            } else\n                tt->points = 0;\n            tt->plrole[1] = '\\0';\n            if ((i = str2role(tt->plrole)) >= 0)\n                Strcpy(tt->plrole, roles[i].filecode);\n            Strcpy(tt->plrace, \"?\");\n            Strcpy(tt->plgend, (tt->plgend[0] == 'M') ? \"Mal\" : \"Fem\");\n            Strcpy(tt->plalign, \"?\");\n        } else if (sscanf(inbuf, fmt33, s1, s2, s3, s4, s5, s6) == 6) {\n            copynchars(tt->plrole, s1, (int) (sizeof tt->plrole) - 1);\n            copynchars(tt->plrace, s2, (int) (sizeof tt->plrace) - 1);\n            copynchars(tt->plgend, s3, (int) (sizeof tt->plgend) - 1);\n            copynchars(tt->plalign, s4, (int) (sizeof tt->plalign) - 1);\n            copynchars(tt->name, s5, (int) (sizeof tt->name) - 1);\n            copynchars(tt->death, s6, (int) (sizeof tt->death) - 1);\n        } else\n            tt->points = 0;\n#ifdef NO_SCAN_BRACK\n        if (tt->points > 0) {\n            nsb_unmung_line(tt->name);\n            nsb_unmung_line(tt->death);\n        }\n#endif\n    }\n\n    /* check old score entries for Y2K problem and fix whenever found */\n    if (tt->points > 0) {\n        if (tt->birthdate < 19000000L)\n            tt->birthdate += 19000000L;\n        if (tt->deathdate < 19000000L)\n            tt->deathdate += 19000000L;\n    }\n}\n\nSTATIC_OVL void\nwriteentry(rfile, tt)\nFILE *rfile;\nstruct toptenentry *tt;\n{\n    static const char fmt32[] = \"%c%c \";        /* role,gender */\n    static const char fmt33[] = \"%s %s %s %s \"; /* role,race,gndr,algn */\n#ifndef NO_SCAN_BRACK\n    static const char fmt0[] = \"%d.%d.%d %ld %d %d %d %d %d %d %ld %ld %d \";\n    static const char fmtX[] = \"%s,%s\\n\";\n#else /* NO_SCAN_BRACK */\n    static const char fmt0[] = \"%d %d %d %ld %d %d %d %d %d %d %ld %ld %d \";\n    static const char fmtX[] = \"%s %s\\n\";\n\n    nsb_mung_line(tt->name);\n    nsb_mung_line(tt->death);\n#endif\n\n    (void) fprintf(rfile, fmt0, tt->ver_major, tt->ver_minor, tt->patchlevel,\n                   tt->points, tt->deathdnum, tt->deathlev, tt->maxlvl,\n                   tt->hp, tt->maxhp, tt->deaths, tt->deathdate,\n                   tt->birthdate, tt->uid);\n    if (tt->ver_major < 3 || (tt->ver_major == 3 && tt->ver_minor < 3))\n        (void) fprintf(rfile, fmt32, tt->plrole[0], tt->plgend[0]);\n    else\n        (void) fprintf(rfile, fmt33, tt->plrole, tt->plrace, tt->plgend,\n                       tt->plalign);\n    (void) fprintf(rfile, fmtX, onlyspace(tt->name) ? \"_\" : tt->name,\n                   tt->death);\n\n#ifdef NO_SCAN_BRACK\n    nsb_unmung_line(tt->name);\n    nsb_unmung_line(tt->death);\n#endif\n}\n\n#ifdef XLOGFILE\n\n/* as tab is never used in eg. plname or death, no need to mangle those. */\nSTATIC_OVL void\nwritexlentry(rfile, tt, how)\nFILE *rfile;\nstruct toptenentry *tt;\nint how;\n{\n#define Fprintf (void) fprintf\n#define XLOG_SEP '\\t' /* xlogfile field separator. */\n    char buf[BUFSZ], tmpbuf[DTHSZ + 1];\n\n    Sprintf(buf, \"version=%d.%d.%d\", tt->ver_major, tt->ver_minor,\n            tt->patchlevel);\n    Sprintf(eos(buf), \"%cpoints=%ld%cdeathdnum=%d%cdeathlev=%d\", XLOG_SEP,\n            tt->points, XLOG_SEP, tt->deathdnum, XLOG_SEP, tt->deathlev);\n    Sprintf(eos(buf), \"%cmaxlvl=%d%chp=%d%cmaxhp=%d\", XLOG_SEP, tt->maxlvl,\n            XLOG_SEP, tt->hp, XLOG_SEP, tt->maxhp);\n    Sprintf(eos(buf), \"%cdeaths=%d%cdeathdate=%ld%cbirthdate=%ld%cuid=%d\",\n            XLOG_SEP, tt->deaths, XLOG_SEP, tt->deathdate, XLOG_SEP,\n            tt->birthdate, XLOG_SEP, tt->uid);\n    Fprintf(rfile, \"%s\", buf);\n    Sprintf(buf, \"%crole=%s%crace=%s%cgender=%s%calign=%s\", XLOG_SEP,\n            tt->plrole, XLOG_SEP, tt->plrace, XLOG_SEP, tt->plgend, XLOG_SEP,\n            tt->plalign);\n    /* make a copy of death reason that doesn't include \", while helpless\" */\n    formatkiller(tmpbuf, sizeof tmpbuf, how, FALSE);\n    Fprintf(rfile, \"%s%cname=%s%cdeath=%s\",\n            buf, /* (already includes separator) */\n            XLOG_SEP, plname, XLOG_SEP, tmpbuf);\n    if (multi)\n        Fprintf(rfile, \"%cwhile=%s\", XLOG_SEP,\n                multi_reason ? multi_reason : \"helpless\");\n    Fprintf(rfile, \"%cconduct=0x%lx%cturns=%ld%cachieve=0x%lx\", XLOG_SEP,\n            encodeconduct(), XLOG_SEP, moves, XLOG_SEP, encodeachieve());\n    Fprintf(rfile, \"%crealtime=%ld%cstarttime=%ld%cendtime=%ld\", XLOG_SEP,\n            (long) urealtime.realtime, XLOG_SEP,\n            (long) ubirthday, XLOG_SEP, (long) urealtime.finish_time);\n    Fprintf(rfile, \"%cgender0=%s%calign0=%s\", XLOG_SEP,\n            genders[flags.initgend].filecode, XLOG_SEP,\n            aligns[1 - u.ualignbase[A_ORIGINAL]].filecode);\n    Fprintf(rfile, \"%cflags=0x%lx\", XLOG_SEP, encodexlogflags());\n    Fprintf(rfile, \"\\n\");\n#undef XLOG_SEP\n}\n\nSTATIC_OVL long\nencodexlogflags()\n{\n    long e = 0L;\n\n    if (wizard)\n        e |= 1L << 0;\n    if (discover)\n        e |= 1L << 1;\n    if (!u.uroleplay.numbones)\n        e |= 1L << 2;\n\n    return e;\n}\n\nSTATIC_OVL long\nencodeconduct()\n{\n    long e = 0L;\n\n    if (!u.uconduct.food)\n        e |= 1L << 0;\n    if (!u.uconduct.unvegan)\n        e |= 1L << 1;\n    if (!u.uconduct.unvegetarian)\n        e |= 1L << 2;\n    if (!u.uconduct.gnostic)\n        e |= 1L << 3;\n    if (!u.uconduct.weaphit)\n        e |= 1L << 4;\n    if (!u.uconduct.killer)\n        e |= 1L << 5;\n    if (!u.uconduct.literate)\n        e |= 1L << 6;\n    if (!u.uconduct.polypiles)\n        e |= 1L << 7;\n    if (!u.uconduct.polyselfs)\n        e |= 1L << 8;\n    if (!u.uconduct.wishes)\n        e |= 1L << 9;\n    if (!u.uconduct.wisharti)\n        e |= 1L << 10;\n    if (!num_genocides())\n        e |= 1L << 11;\n\n    return e;\n}\n\nSTATIC_OVL long\nencodeachieve()\n{\n    long r = 0L;\n\n    if (u.uachieve.bell)\n        r |= 1L << 0;\n    if (u.uachieve.enter_gehennom)\n        r |= 1L << 1;\n    if (u.uachieve.menorah)\n        r |= 1L << 2;\n    if (u.uachieve.book)\n        r |= 1L << 3;\n    if (u.uevent.invoked)\n        r |= 1L << 4;\n    if (u.uachieve.amulet)\n        r |= 1L << 5;\n    if (In_endgame(&u.uz))\n        r |= 1L << 6;\n    if (Is_astralevel(&u.uz))\n        r |= 1L << 7;\n    if (u.uachieve.ascended)\n        r |= 1L << 8;\n    if (u.uachieve.mines_luckstone)\n        r |= 1L << 9;\n    if (u.uachieve.finish_sokoban)\n        r |= 1L << 10;\n    if (u.uachieve.killed_medusa)\n        r |= 1L << 11;\n    if (u.uroleplay.blind)\n        r |= 1L << 12;\n    if (u.uroleplay.nudist)\n        r |= 1L << 13;\n\n    return r;\n}\n\n#endif /* XLOGFILE */\n\nSTATIC_OVL void\nfree_ttlist(tt)\nstruct toptenentry *tt;\n{\n    struct toptenentry *ttnext;\n\n    while (tt->points > 0) {\n        ttnext = tt->tt_next;\n        dealloc_ttentry(tt);\n        tt = ttnext;\n    }\n    dealloc_ttentry(tt);\n}\n\nvoid\ntopten(how, when)\nint how;\ntime_t when;\n{\n    int uid = getuid();\n    int rank, rank0 = -1, rank1 = 0;\n    int occ_cnt = sysopt.persmax;\n    register struct toptenentry *t0, *tprev;\n    struct toptenentry *t1;\n    FILE *rfile;\n    register int flg = 0;\n    boolean t0_used;\n#ifdef LOGFILE\n    FILE *lfile;\n#endif /* LOGFILE */\n#ifdef XLOGFILE\n    FILE *xlfile;\n#endif /* XLOGFILE */\n\n#ifdef _DCC\n    /* Under DICE 3.0, this crashes the system consistently, apparently due to\n     * corruption of *rfile somewhere.  Until I figure this out, just cut out\n     * topten support entirely - at least then the game exits cleanly.  --AC\n     */\n    return;\n#endif\n\n    /* If we are in the midst of a panic, cut out topten entirely.\n     * topten uses alloc() several times, which will lead to\n     * problems if the panic was the result of an alloc() failure.\n     */\n    if (program_state.panicking)\n        return;\n\n    if (iflags.toptenwin) {\n        toptenwin = create_nhwindow(NHW_TEXT);\n    }\n\n#if defined(UNIX) || defined(VMS) || defined(__EMX__)\n#define HUP if (!program_state.done_hup)\n#else\n#define HUP\n#endif\n\n#ifdef TOS\n    restore_colors(); /* make sure the screen is black on white */\n#endif\n    /* create a new 'topten' entry */\n    t0_used = FALSE;\n    t0 = newttentry();\n    t0->ver_major = VERSION_MAJOR;\n    t0->ver_minor = VERSION_MINOR;\n    t0->patchlevel = PATCHLEVEL;\n    t0->points = u.urexp;\n    t0->deathdnum = u.uz.dnum;\n    /* deepest_lev_reached() is in terms of depth(), and reporting the\n     * deepest level reached in the dungeon death occurred in doesn't\n     * seem right, so we have to report the death level in depth() terms\n     * as well (which also seems reasonable since that's all the player\n     * sees on the screen anyway)\n     */\n    t0->deathlev = observable_depth(&u.uz);\n    t0->maxlvl = deepest_lev_reached(TRUE);\n    t0->hp = u.uhp;\n    t0->maxhp = u.uhpmax;\n    t0->deaths = u.umortality;\n    t0->uid = uid;\n    copynchars(t0->plrole, urole.filecode, ROLESZ);\n    copynchars(t0->plrace, urace.filecode, ROLESZ);\n    copynchars(t0->plgend, genders[flags.female].filecode, ROLESZ);\n    copynchars(t0->plalign, aligns[1 - u.ualign.type].filecode, ROLESZ);\n    copynchars(t0->name, plname, NAMSZ);\n    formatkiller(t0->death, sizeof t0->death, how, TRUE);\n    t0->birthdate = yyyymmdd(ubirthday);\n    t0->deathdate = yyyymmdd(when);\n    t0->tt_next = 0;\n#ifdef UPDATE_RECORD_IN_PLACE\n    t0->fpos = -1L;\n#endif\n\n#ifdef LOGFILE /* used for debugging (who dies of what, where) */\n    if (lock_file(LOGFILE, SCOREPREFIX, 10)) {\n        if (!(lfile = fopen_datafile(LOGFILE, \"a\", SCOREPREFIX))) {\n            HUP raw_print(\"Cannot open log file!\");\n        } else {\n            writeentry(lfile, t0);\n            (void) fclose(lfile);\n        }\n        unlock_file(LOGFILE);\n    }\n#endif /* LOGFILE */\n#ifdef XLOGFILE\n    if (lock_file(XLOGFILE, SCOREPREFIX, 10)) {\n        if (!(xlfile = fopen_datafile(XLOGFILE, \"a\", SCOREPREFIX))) {\n            HUP raw_print(\"Cannot open extended log file!\");\n        } else {\n            writexlentry(xlfile, t0, how);\n            (void) fclose(xlfile);\n        }\n        unlock_file(XLOGFILE);\n    }\n#endif /* XLOGFILE */\n\n    if (wizard || discover) {\n        if (how != PANICKED)\n            HUP {\n                char pbuf[BUFSZ];\n\n                topten_print(\"\");\n                Sprintf(pbuf,\n             \"Since you were in %s mode, the score list will not be checked.\",\n                        wizard ? \"wizard\" : \"discover\");\n                topten_print(pbuf);\n            }\n        goto showwin;\n    }\n\n    if (!lock_file(RECORD, SCOREPREFIX, 60))\n        goto destroywin;\n\n#ifdef UPDATE_RECORD_IN_PLACE\n    rfile = fopen_datafile(RECORD, \"r+\", SCOREPREFIX);\n#else\n    rfile = fopen_datafile(RECORD, \"r\", SCOREPREFIX);\n#endif\n\n    if (!rfile) {\n        HUP raw_print(\"Cannot open record file!\");\n        unlock_file(RECORD);\n        goto destroywin;\n    }\n\n    HUP topten_print(\"\");\n\n    /* assure minimum number of points */\n    if (t0->points < sysopt.pointsmin)\n        t0->points = 0;\n\n    t1 = tt_head = newttentry();\n    tprev = 0;\n    /* rank0: -1 undefined, 0 not_on_list, n n_th on list */\n    for (rank = 1;;) {\n        readentry(rfile, t1);\n        if (t1->points < sysopt.pointsmin)\n            t1->points = 0;\n        if (rank0 < 0 && t1->points < t0->points) {\n            rank0 = rank++;\n            if (tprev == 0)\n                tt_head = t0;\n            else\n                tprev->tt_next = t0;\n            t0->tt_next = t1;\n#ifdef UPDATE_RECORD_IN_PLACE\n            t0->fpos = t1->fpos; /* insert here */\n#endif\n            t0_used = TRUE;\n            occ_cnt--;\n            flg++; /* ask for a rewrite */\n        } else\n            tprev = t1;\n\n        if (t1->points == 0)\n            break;\n        if ((sysopt.pers_is_uid ? t1->uid == t0->uid\n                                : strncmp(t1->name, t0->name, NAMSZ) == 0)\n            && !strncmp(t1->plrole, t0->plrole, ROLESZ) && --occ_cnt <= 0) {\n            if (rank0 < 0) {\n                rank0 = 0;\n                rank1 = rank;\n                HUP {\n                    char pbuf[BUFSZ];\n\n                    Sprintf(pbuf,\n                        \"You didn't beat your previous score of %ld points.\",\n                            t1->points);\n                    topten_print(pbuf);\n                    topten_print(\"\");\n                }\n            }\n            if (occ_cnt < 0) {\n                flg++;\n                continue;\n            }\n        }\n        if (rank <= sysopt.entrymax) {\n            t1->tt_next = newttentry();\n            t1 = t1->tt_next;\n            rank++;\n        }\n        if (rank > sysopt.entrymax) {\n            t1->points = 0;\n            break;\n        }\n    }\n    if (flg) { /* rewrite record file */\n#ifdef UPDATE_RECORD_IN_PLACE\n        (void) fseek(rfile, (t0->fpos >= 0 ? t0->fpos : final_fpos),\n                     SEEK_SET);\n#else\n        (void) fclose(rfile);\n        if (!(rfile = fopen_datafile(RECORD, \"w\", SCOREPREFIX))) {\n            HUP raw_print(\"Cannot write record file\");\n            unlock_file(RECORD);\n            free_ttlist(tt_head);\n            goto destroywin;\n        }\n#endif /* UPDATE_RECORD_IN_PLACE */\n        if (!done_stopprint)\n            if (rank0 > 0) {\n                if (rank0 <= 10) {\n                    topten_print(\"You made the top ten list!\");\n                } else {\n                    char pbuf[BUFSZ];\n\n                    Sprintf(pbuf,\n                            \"You reached the %d%s place on the top %d list.\",\n                            rank0, ordin(rank0), sysopt.entrymax);\n                    topten_print(pbuf);\n                }\n                topten_print(\"\");\n            }\n    }\n    if (rank0 == 0)\n        rank0 = rank1;\n    if (rank0 <= 0)\n        rank0 = rank;\n    if (!done_stopprint)\n        outheader();\n    t1 = tt_head;\n    for (rank = 1; t1->points != 0; rank++, t1 = t1->tt_next) {\n        if (flg\n#ifdef UPDATE_RECORD_IN_PLACE\n            && rank >= rank0\n#endif\n            )\n            writeentry(rfile, t1);\n        if (done_stopprint)\n            continue;\n        if (rank > flags.end_top && (rank < rank0 - flags.end_around\n                                     || rank > rank0 + flags.end_around)\n            && (!flags.end_own\n                || (sysopt.pers_is_uid\n                        ? t1->uid == t0->uid\n                        : strncmp(t1->name, t0->name, NAMSZ) == 0)))\n            continue;\n        if (rank == rank0 - flags.end_around\n            && rank0 > flags.end_top + flags.end_around + 1 && !flags.end_own)\n            topten_print(\"\");\n        if (rank != rank0)\n            outentry(rank, t1, FALSE);\n        else if (!rank1)\n            outentry(rank, t1, TRUE);\n        else {\n            outentry(rank, t1, TRUE);\n            outentry(0, t0, TRUE);\n        }\n    }\n    if (rank0 >= rank)\n        if (!done_stopprint)\n            outentry(0, t0, TRUE);\n#ifdef UPDATE_RECORD_IN_PLACE\n    if (flg) {\n#ifdef TRUNCATE_FILE\n        /* if a reasonable way to truncate a file exists, use it */\n        truncate_file(rfile);\n#else\n        /* use sentinel record rather than relying on truncation */\n        t1->points = 0L; /* terminates file when read back in */\n        t1->ver_major = t1->ver_minor = t1->patchlevel = 0;\n        t1->uid = t1->deathdnum = t1->deathlev = 0;\n        t1->maxlvl = t1->hp = t1->maxhp = t1->deaths = 0;\n        t1->plrole[0] = t1->plrace[0] = t1->plgend[0] = t1->plalign[0] = '-';\n        t1->plrole[1] = t1->plrace[1] = t1->plgend[1] = t1->plalign[1] = 0;\n        t1->birthdate = t1->deathdate = yyyymmdd((time_t) 0L);\n        Strcpy(t1->name, \"@\");\n        Strcpy(t1->death, \"<eod>\\n\");\n        writeentry(rfile, t1);\n        (void) fflush(rfile);\n#endif /* TRUNCATE_FILE */\n    }\n#endif /* UPDATE_RECORD_IN_PLACE */\n    (void) fclose(rfile);\n    unlock_file(RECORD);\n    free_ttlist(tt_head);\n\nshowwin:\n    if (iflags.toptenwin && !done_stopprint)\n        display_nhwindow(toptenwin, 1);\ndestroywin:\n    if (!t0_used)\n        dealloc_ttentry(t0);\n    if (iflags.toptenwin) {\n        destroy_nhwindow(toptenwin);\n        toptenwin = WIN_ERR;\n    }\n}\n\nSTATIC_OVL void\noutheader()\n{\n    char linebuf[BUFSZ];\n    register char *bp;\n\n    Strcpy(linebuf, \" No  Points     Name\");\n    bp = eos(linebuf);\n    while (bp < linebuf + COLNO - 9)\n        *bp++ = ' ';\n    Strcpy(bp, \"Hp [max]\");\n    topten_print(linebuf);\n}\n\n/* so>0: standout line; so=0: ordinary line */\nSTATIC_OVL void\noutentry(rank, t1, so)\nstruct toptenentry *t1;\nint rank;\nboolean so;\n{\n    boolean second_line = TRUE;\n    char linebuf[BUFSZ];\n    char *bp, hpbuf[24], linebuf3[BUFSZ];\n    int hppos, lngr;\n\n    linebuf[0] = '\\0';\n    if (rank)\n        Sprintf(eos(linebuf), \"%3d\", rank);\n    else\n        Strcat(linebuf, \"   \");\n\n    Sprintf(eos(linebuf), \" %10ld  %.10s\", t1->points ? t1->points : u.urexp,\n            t1->name);\n    Sprintf(eos(linebuf), \"-%s\", t1->plrole);\n    if (t1->plrace[0] != '?')\n        Sprintf(eos(linebuf), \"-%s\", t1->plrace);\n    /* Printing of gender and alignment is intentional.  It has been\n     * part of the NetHack Geek Code, and illustrates a proper way to\n     * specify a character from the command line.\n     */\n    Sprintf(eos(linebuf), \"-%s\", t1->plgend);\n    if (t1->plalign[0] != '?')\n        Sprintf(eos(linebuf), \"-%s \", t1->plalign);\n    else\n        Strcat(linebuf, \" \");\n    if (!strncmp(\"escaped\", t1->death, 7)) {\n        Sprintf(eos(linebuf), \"escaped the dungeon %s[max level %d]\",\n                !strncmp(\" (\", t1->death + 7, 2) ? t1->death + 7 + 2 : \"\",\n                t1->maxlvl);\n        /* fixup for closing paren in \"escaped... with...Amulet)[max...\" */\n        if ((bp = index(linebuf, ')')) != 0)\n            *bp = (t1->deathdnum == astral_level.dnum) ? '\\0' : ' ';\n        second_line = FALSE;\n    } else if (!strncmp(\"ascended\", t1->death, 8)) {\n        Sprintf(eos(linebuf), \"ascended to demigod%s-hood\",\n                (t1->plgend[0] == 'F') ? \"dess\" : \"\");\n        second_line = FALSE;\n    } else {\n        if (!strncmp(t1->death, \"quit\", 4)) {\n            Strcat(linebuf, \"quit\");\n            second_line = FALSE;\n        } else if (!strncmp(t1->death, \"died of st\", 10)) {\n            Strcat(linebuf, \"starved to death\");\n            second_line = FALSE;\n        } else if (!strncmp(t1->death, \"choked\", 6)) {\n            Sprintf(eos(linebuf), \"choked on h%s food\",\n                    (t1->plgend[0] == 'F') ? \"er\" : \"is\");\n        } else if (!strncmp(t1->death, \"poisoned\", 8)) {\n            Strcat(linebuf, \"was poisoned\");\n        } else if (!strncmp(t1->death, \"crushed\", 7)) {\n            Strcat(linebuf, \"was crushed to death\");\n        } else if (!strncmp(t1->death, \"petrified by \", 13)) {\n            Strcat(linebuf, \"turned to stone\");\n        } else\n            Strcat(linebuf, \"died\");\n\n        if (t1->deathdnum == astral_level.dnum) {\n            const char *arg, *fmt = \" on the Plane of %s\";\n\n            switch (t1->deathlev) {\n            case -5:\n                fmt = \" on the %s Plane\";\n                arg = \"Astral\";\n                break;\n            case -4:\n                arg = \"Water\";\n                break;\n            case -3:\n                arg = \"Fire\";\n                break;\n            case -2:\n                arg = \"Air\";\n                break;\n            case -1:\n                arg = \"Earth\";\n                break;\n            default:\n                arg = \"Void\";\n                break;\n            }\n            Sprintf(eos(linebuf), fmt, arg);\n        } else {\n            Sprintf(eos(linebuf), \" in %s\", dungeons[t1->deathdnum].dname);\n            if (t1->deathdnum != knox_level.dnum)\n                Sprintf(eos(linebuf), \" on level %d\", t1->deathlev);\n            if (t1->deathlev != t1->maxlvl)\n                Sprintf(eos(linebuf), \" [max %d]\", t1->maxlvl);\n        }\n\n        /* kludge for \"quit while already on Charon's boat\" */\n        if (!strncmp(t1->death, \"quit \", 5))\n            Strcat(linebuf, t1->death + 4);\n    }\n    Strcat(linebuf, \".\");\n\n    /* Quit, starved, ascended, and escaped contain no second line */\n    if (second_line)\n        Sprintf(eos(linebuf), \"  %c%s.\", highc(*(t1->death)), t1->death + 1);\n\n    lngr = (int) strlen(linebuf);\n    if (t1->hp <= 0)\n        hpbuf[0] = '-', hpbuf[1] = '\\0';\n    else\n        Sprintf(hpbuf, \"%d\", t1->hp);\n    /* beginning of hp column after padding (not actually padded yet) */\n    hppos = COLNO - (sizeof(\"  Hp [max]\") - 1); /* sizeof(str) includes \\0 */\n    while (lngr >= hppos) {\n        for (bp = eos(linebuf); !(*bp == ' ' && (bp - linebuf < hppos)); bp--)\n            ;\n        /* special case: word is too long, wrap in the middle */\n        if (linebuf + 15 >= bp)\n            bp = linebuf + hppos - 1;\n        /* special case: if about to wrap in the middle of maximum\n           dungeon depth reached, wrap in front of it instead */\n        if (bp > linebuf + 5 && !strncmp(bp - 5, \" [max\", 5))\n            bp -= 5;\n        if (*bp != ' ')\n            Strcpy(linebuf3, bp);\n        else\n            Strcpy(linebuf3, bp + 1);\n        *bp = 0;\n        if (so) {\n            while (bp < linebuf + (COLNO - 1))\n                *bp++ = ' ';\n            *bp = 0;\n            topten_print_bold(linebuf);\n        } else\n            topten_print(linebuf);\n        Sprintf(linebuf, \"%15s %s\", \"\", linebuf3);\n        lngr = strlen(linebuf);\n    }\n    /* beginning of hp column not including padding */\n    hppos = COLNO - 7 - (int) strlen(hpbuf);\n    bp = eos(linebuf);\n\n    if (bp <= linebuf + hppos) {\n        /* pad any necessary blanks to the hit point entry */\n        while (bp < linebuf + hppos)\n            *bp++ = ' ';\n        Strcpy(bp, hpbuf);\n        Sprintf(eos(bp), \" %s[%d]\",\n                (t1->maxhp < 10) ? \"  \" : (t1->maxhp < 100) ? \" \" : \"\",\n                t1->maxhp);\n    }\n\n    if (so) {\n        bp = eos(linebuf);\n        if (so >= COLNO)\n            so = COLNO - 1;\n        while (bp < linebuf + so)\n            *bp++ = ' ';\n        *bp = 0;\n        topten_print_bold(linebuf);\n    } else\n        topten_print(linebuf);\n}\n\nSTATIC_OVL int\nscore_wanted(current_ver, rank, t1, playerct, players, uid)\nboolean current_ver;\nint rank;\nstruct toptenentry *t1;\nint playerct;\nconst char **players;\nint uid;\n{\n    int i;\n\n    if (current_ver\n        && (t1->ver_major != VERSION_MAJOR || t1->ver_minor != VERSION_MINOR\n            || t1->patchlevel != PATCHLEVEL))\n        return 0;\n\n    if (sysopt.pers_is_uid && !playerct && t1->uid == uid)\n        return 1;\n\n    for (i = 0; i < playerct; i++) {\n        if (players[i][0] == '-' && index(\"pr\", players[i][1])\n            && players[i][2] == 0 && i + 1 < playerct) {\n            const char *arg = players[i + 1];\n            if ((players[i][1] == 'p'\n                 && str2role(arg) == str2role(t1->plrole))\n                || (players[i][1] == 'r'\n                    && str2race(arg) == str2race(t1->plrace)))\n                return 1;\n            i++;\n        } else if (strcmp(players[i], \"all\") == 0\n                   || strncmp(t1->name, players[i], NAMSZ) == 0\n                   || (players[i][0] == '-' && players[i][1] == t1->plrole[0]\n                       && players[i][2] == 0)\n                   || (digit(players[i][0]) && rank <= atoi(players[i])))\n            return 1;\n    }\n    return 0;\n}\n\n/*\n * print selected parts of score list.\n * argc >= 2, with argv[0] untrustworthy (directory names, et al.),\n * and argv[1] starting with \"-s\".\n */\nvoid\nprscore(argc, argv)\nint argc;\nchar **argv;\n{\n    const char **players;\n    int playerct, rank;\n    boolean current_ver = TRUE, init_done = FALSE;\n    register struct toptenentry *t1;\n    FILE *rfile;\n    boolean match_found = FALSE;\n    register int i;\n    char pbuf[BUFSZ];\n    int uid = -1;\n    const char *player0;\n\n    if (argc < 2 || strncmp(argv[1], \"-s\", 2)) {\n        raw_printf(\"prscore: bad arguments (%d)\", argc);\n        return;\n    }\n\n    rfile = fopen_datafile(RECORD, \"r\", SCOREPREFIX);\n    if (!rfile) {\n        raw_print(\"Cannot open record file!\");\n        return;\n    }\n\n#ifdef AMIGA\n    {\n        extern winid amii_rawprwin;\n\n        init_nhwindows(&argc, argv);\n        amii_rawprwin = create_nhwindow(NHW_TEXT);\n    }\n#endif\n\n    /* If the score list isn't after a game, we never went through\n     * initialization. */\n    if (wiz1_level.dlevel == 0) {\n        dlb_init();\n        init_dungeons();\n        init_done = TRUE;\n    }\n\n    if (!argv[1][2]) { /* plain \"-s\" */\n        argc--;\n        argv++;\n    } else\n        argv[1] += 2;\n\n    if (argc > 1 && !strcmp(argv[1], \"-v\")) {\n        current_ver = FALSE;\n        argc--;\n        argv++;\n    }\n\n    if (argc <= 1) {\n        if (sysopt.pers_is_uid) {\n            uid = getuid();\n            playerct = 0;\n            players = (const char **) 0;\n        } else {\n            player0 = plname;\n            if (!*player0)\n#ifdef AMIGA\n                player0 = \"all\"; /* single user system */\n#else\n                player0 = \"hackplayer\";\n#endif\n            playerct = 1;\n            players = &player0;\n        }\n    } else {\n        playerct = --argc;\n        players = (const char **) ++argv;\n    }\n    raw_print(\"\");\n\n    t1 = tt_head = newttentry();\n    for (rank = 1;; rank++) {\n        readentry(rfile, t1);\n        if (t1->points == 0)\n            break;\n        if (!match_found\n            && score_wanted(current_ver, rank, t1, playerct, players, uid))\n            match_found = TRUE;\n        t1->tt_next = newttentry();\n        t1 = t1->tt_next;\n    }\n\n    (void) fclose(rfile);\n    if (init_done) {\n        free_dungeons();\n        dlb_cleanup();\n    }\n\n    if (match_found) {\n        outheader();\n        t1 = tt_head;\n        for (rank = 1; t1->points != 0; rank++, t1 = t1->tt_next) {\n            if (score_wanted(current_ver, rank, t1, playerct, players, uid))\n                (void) outentry(rank, t1, FALSE);\n        }\n    } else {\n        Sprintf(pbuf, \"Cannot find any %sentries for \",\n                current_ver ? \"current \" : \"\");\n        if (playerct < 1)\n            Strcat(pbuf, \"you.\");\n        else {\n            if (playerct > 1)\n                Strcat(pbuf, \"any of \");\n            for (i = 0; i < playerct; i++) {\n                /* stop printing players if there are too many to fit */\n                if (strlen(pbuf) + strlen(players[i]) + 2 >= BUFSZ) {\n                    if (strlen(pbuf) < BUFSZ - 4)\n                        Strcat(pbuf, \"...\");\n                    else\n                        Strcpy(pbuf + strlen(pbuf) - 4, \"...\");\n                    break;\n                }\n                Strcat(pbuf, players[i]);\n                if (i < playerct - 1) {\n                    if (players[i][0] == '-' && index(\"pr\", players[i][1])\n                        && players[i][2] == 0)\n                        Strcat(pbuf, \" \");\n                    else\n                        Strcat(pbuf, \":\");\n                }\n            }\n        }\n        raw_print(pbuf);\n        raw_printf(\"Usage: %s -s [-v] <playertypes> [maxrank] [playernames]\",\n\n                   hname);\n        raw_printf(\"Player types are: [-p role] [-r race]\");\n    }\n    free_ttlist(tt_head);\n#ifdef AMIGA\n    {\n        extern winid amii_rawprwin;\n\n        display_nhwindow(amii_rawprwin, 1);\n        destroy_nhwindow(amii_rawprwin);\n        amii_rawprwin = WIN_ERR;\n    }\n#endif\n}\n\nSTATIC_OVL int\nclassmon(plch, fem)\nchar *plch;\nboolean fem;\n{\n    int i;\n\n    /* Look for this role in the role table */\n    for (i = 0; roles[i].name.m; i++)\n        if (!strncmp(plch, roles[i].filecode, ROLESZ)) {\n            if (fem && roles[i].femalenum != NON_PM)\n                return roles[i].femalenum;\n            else if (roles[i].malenum != NON_PM)\n                return roles[i].malenum;\n            else\n                return PM_HUMAN;\n        }\n    /* this might be from a 3.2.x score for former Elf class */\n    if (!strcmp(plch, \"E\"))\n        return PM_RANGER;\n\n    impossible(\"What weird role is this? (%s)\", plch);\n    return  PM_HUMAN_MUMMY;\n}\n\n/*\n * Get a random player name and class from the high score list,\n */\nstruct toptenentry *\nget_rnd_toptenentry()\n{\n    int rank, i;\n    FILE *rfile;\n    register struct toptenentry *tt;\n    static struct toptenentry tt_buf;\n\n    rfile = fopen_datafile(RECORD, \"r\", SCOREPREFIX);\n    if (!rfile) {\n        impossible(\"Cannot open record file!\");\n        return NULL;\n    }\n\n    tt = &tt_buf;\n    rank = rnd(sysopt.tt_oname_maxrank);\npickentry:\n    for (i = rank; i; i--) {\n        readentry(rfile, tt);\n        if (tt->points == 0)\n            break;\n    }\n\n    if (tt->points == 0) {\n        if (rank > 1) {\n            rank = 1;\n            rewind(rfile);\n            goto pickentry;\n        }\n        tt = NULL;\n    }\n\n    (void) fclose(rfile);\n    return tt;\n}\n\n\n/*\n * Attach random player name and class from high score list\n * to an object (for statues or morgue corpses).\n */\nstruct obj *\ntt_oname(otmp)\nstruct obj *otmp;\n{\n    struct toptenentry *tt;\n    if (!otmp)\n        return (struct obj *) 0;\n\n    tt = get_rnd_toptenentry();\n\n    if (!tt)\n        return (struct obj *) 0;\n\n    set_corpsenm(otmp, classmon(tt->plrole, (tt->plgend[0] == 'F')));\n    otmp = oname(otmp, tt->name);\n\n    return otmp;\n}\n\n#ifdef NO_SCAN_BRACK\n/* Lattice scanf isn't up to reading the scorefile.  What */\n/* follows deals with that; I admit it's ugly. (KL) */\n/* Now generally available (KL) */\nSTATIC_OVL void\nnsb_mung_line(p)\nchar *p;\n{\n    while ((p = index(p, ' ')) != 0)\n        *p = '|';\n}\n\nSTATIC_OVL void\nnsb_unmung_line(p)\nchar *p;\n{\n    while ((p = index(p, '|')) != 0)\n        *p = ' ';\n}\n#endif /* NO_SCAN_BRACK */\n\n/*topten.c*/\n", "/* NetHack 3.6\twindows.c\t$NHDT-Date: 1575245096 2019/12/02 00:04:56 $  $NHDT-Branch: NetHack-3.6 $:$NHDT-Revision: 1.60 $ */\n/* Copyright (c) D. Cohrs, 1993. */\n/* NetHack may be freely redistributed.  See license for details. */\n\n#include \"hack.h\"\n#ifdef TTY_GRAPHICS\n#include \"wintty.h\"\n#endif\n#ifdef CURSES_GRAPHICS\nextern struct window_procs curses_procs;\n#endif\n#ifdef X11_GRAPHICS\n/* Cannot just blindly include winX.h without including all of X11 stuff\n   and must get the order of include files right.  Don't bother. */\nextern struct window_procs X11_procs;\nextern void FDECL(win_X11_init, (int));\n#endif\n#ifdef QT_GRAPHICS\nextern struct window_procs Qt_procs;\n#endif\n#ifdef GEM_GRAPHICS\n#include \"wingem.h\"\n#endif\n#ifdef MAC\nextern struct window_procs mac_procs;\n#endif\n#ifdef BEOS_GRAPHICS\nextern struct window_procs beos_procs;\nextern void FDECL(be_win_init, (int));\nFAIL /* be_win_init doesn't exist? XXX*/\n#endif\n#ifdef AMIGA_INTUITION\nextern struct window_procs amii_procs;\nextern struct window_procs amiv_procs;\nextern void FDECL(ami_wininit_data, (int));\n#endif\n#ifdef WIN32_GRAPHICS\nextern struct window_procs win32_procs;\n#endif\n#ifdef GNOME_GRAPHICS\n#include \"winGnome.h\"\nextern struct window_procs Gnome_procs;\n#endif\n#ifdef MSWIN_GRAPHICS\nextern struct window_procs mswin_procs;\n#endif\n#ifdef WINCHAIN\nextern struct window_procs chainin_procs;\nextern void FDECL(chainin_procs_init, (int));\nextern void *FDECL(chainin_procs_chain, (int, int, void *, void *, void *));\n\nextern struct chain_procs chainout_procs;\nextern void FDECL(chainout_procs_init, (int));\nextern void *FDECL(chainout_procs_chain, (int, int, void *, void *, void *));\n\nextern struct chain_procs trace_procs;\nextern void FDECL(trace_procs_init, (int));\nextern void *FDECL(trace_procs_chain, (int, int, void *, void *, void *));\n#endif\n\nSTATIC_DCL void FDECL(def_raw_print, (const char *s));\nSTATIC_DCL void NDECL(def_wait_synch);\n\n#ifdef DUMPLOG\nSTATIC_DCL winid FDECL(dump_create_nhwindow, (int));\nSTATIC_DCL void FDECL(dump_clear_nhwindow, (winid));\nSTATIC_DCL void FDECL(dump_display_nhwindow, (winid, BOOLEAN_P));\nSTATIC_DCL void FDECL(dump_destroy_nhwindow, (winid));\nSTATIC_DCL void FDECL(dump_start_menu, (winid));\nSTATIC_DCL void FDECL(dump_add_menu, (winid, int, const ANY_P *, CHAR_P,\n                                      CHAR_P, int, const char *, BOOLEAN_P));\nSTATIC_DCL void FDECL(dump_end_menu, (winid, const char *));\nSTATIC_DCL int FDECL(dump_select_menu, (winid, int, MENU_ITEM_P **));\nSTATIC_DCL void FDECL(dump_putstr, (winid, int, const char *));\n#endif /* DUMPLOG */\n\n#ifdef HANGUPHANDLING\nvolatile\n#endif\n    NEARDATA struct window_procs windowprocs;\n\n#ifdef WINCHAIN\n#define CHAINR(x) , x\n#else\n#define CHAINR(x)\n#endif\n\nstatic struct win_choices {\n    struct window_procs *procs;\n    void FDECL((*ini_routine), (int)); /* optional (can be 0) */\n#ifdef WINCHAIN\n    void *FDECL((*chain_routine), (int, int, void *, void *, void *));\n#endif\n} winchoices[] = {\n#ifdef TTY_GRAPHICS\n    { &tty_procs, win_tty_init CHAINR(0) },\n#endif\n#ifdef CURSES_GRAPHICS\n    { &curses_procs, 0 },\n#endif\n#ifdef X11_GRAPHICS\n    { &X11_procs, win_X11_init CHAINR(0) },\n#endif\n#ifdef QT_GRAPHICS\n    { &Qt_procs, 0 CHAINR(0) },\n#endif\n#ifdef GEM_GRAPHICS\n    { &Gem_procs, win_Gem_init CHAINR(0) },\n#endif\n#ifdef MAC\n    { &mac_procs, 0 CHAINR(0) },\n#endif\n#ifdef BEOS_GRAPHICS\n    { &beos_procs, be_win_init CHAINR(0) },\n#endif\n#ifdef AMIGA_INTUITION\n    { &amii_procs,\n      ami_wininit_data CHAINR(0) }, /* Old font version of the game */\n    { &amiv_procs,\n      ami_wininit_data CHAINR(0) }, /* Tile version of the game */\n#endif\n#ifdef WIN32_GRAPHICS\n    { &win32_procs, 0 CHAINR(0) },\n#endif\n#ifdef GNOME_GRAPHICS\n    { &Gnome_procs, 0 CHAINR(0) },\n#endif\n#ifdef MSWIN_GRAPHICS\n    { &mswin_procs, 0 CHAINR(0) },\n#endif\n#ifdef WINCHAIN\n    { &chainin_procs, chainin_procs_init, chainin_procs_chain },\n    { (struct window_procs *) &chainout_procs, chainout_procs_init,\n      chainout_procs_chain },\n\n    { (struct window_procs *) &trace_procs, trace_procs_init,\n      trace_procs_chain },\n#endif\n    { 0, 0 CHAINR(0) } /* must be last */\n};\n\n#ifdef WINCHAIN\nstruct winlink {\n    struct winlink *nextlink;\n    struct win_choices *wincp;\n    void *linkdata;\n};\n/* NB: this chain does not contain the terminal real window system pointer */\n\nstatic struct winlink *chain = 0;\n\nstatic struct winlink *\nwl_new()\n{\n    struct winlink *wl = (struct winlink *) alloc(sizeof *wl);\n\n    wl->nextlink = 0;\n    wl->wincp = 0;\n    wl->linkdata = 0;\n\n    return wl;\n}\n\nstatic void\nwl_addhead(struct winlink *wl)\n{\n    wl->nextlink = chain;\n    chain = wl;\n}\n\nstatic void\nwl_addtail(struct winlink *wl)\n{\n    struct winlink *p = chain;\n\n    if (!chain) {\n        chain = wl;\n        return;\n    }\n    while (p->nextlink) {\n        p = p->nextlink;\n    }\n    p->nextlink = wl;\n    return;\n}\n#endif /* WINCHAIN */\n\nstatic struct win_choices *last_winchoice = 0;\n\nboolean\ngenl_can_suspend_no(VOID_ARGS)\n{\n    return FALSE;\n}\n\nboolean\ngenl_can_suspend_yes(VOID_ARGS)\n{\n    return TRUE;\n}\n\nSTATIC_OVL\nvoid\ndef_raw_print(s)\nconst char *s;\n{\n    puts(s);\n}\n\nSTATIC_OVL\nvoid\ndef_wait_synch(VOID_ARGS)\n{\n    /* Config file error handling routines\n     * call wait_sync() without checking to\n     * see if it actually has a value,\n     * leading to spectacular violations\n     * when you try to execute address zero.\n     * The existence of this allows early\n     * processing to have something to execute\n     * even though it essentially does nothing\n     */\n     return;\n}\n\n#ifdef WINCHAIN\nstatic struct win_choices *\nwin_choices_find(s)\nconst char *s;\n{\n    register int i;\n\n    for (i = 0; winchoices[i].procs; i++) {\n        if (!strcmpi(s, winchoices[i].procs->name)) {\n            return &winchoices[i];\n        }\n    }\n    return (struct win_choices *) 0;\n}\n#endif\n\nvoid\nchoose_windows(s)\nconst char *s;\n{\n    register int i;\n\n    for (i = 0; winchoices[i].procs; i++) {\n        if ('+' == winchoices[i].procs->name[0])\n            continue;\n        if ('-' == winchoices[i].procs->name[0])\n            continue;\n        if (!strcmpi(s, winchoices[i].procs->name)) {\n            windowprocs = *winchoices[i].procs;\n\n            if (last_winchoice && last_winchoice->ini_routine)\n                (*last_winchoice->ini_routine)(WININIT_UNDO);\n            if (winchoices[i].ini_routine)\n                (*winchoices[i].ini_routine)(WININIT);\n            last_winchoice = &winchoices[i];\n            return;\n        }\n    }\n\n    if (!windowprocs.win_raw_print)\n        windowprocs.win_raw_print = def_raw_print;\n    if (!windowprocs.win_wait_synch)\n        /* early config file error processing routines call this */\n        windowprocs.win_wait_synch = def_wait_synch;\n\n    if (!winchoices[0].procs) {\n        raw_printf(\"No window types?\");\n        nh_terminate(EXIT_FAILURE);\n    }\n    if (!winchoices[1].procs) {\n        config_error_add(\n                     \"Window type %s not recognized.  The only choice is: %s\",\n                         s, winchoices[0].procs->name);\n    } else {\n        char buf[BUFSZ];\n        boolean first = TRUE;\n\n        buf[0] = '\\0';\n        for (i = 0; winchoices[i].procs; i++) {\n            if ('+' == winchoices[i].procs->name[0])\n                continue;\n            if ('-' == winchoices[i].procs->name[0])\n                continue;\n            Sprintf(eos(buf), \"%s%s\",\n                    first ? \"\" : \", \", winchoices[i].procs->name);\n            first = FALSE;\n        }\n        config_error_add(\"Window type %s not recognized.  Choices are:  %s\",\n                         s, buf);\n    }\n\n    if (windowprocs.win_raw_print == def_raw_print\n            || WINDOWPORT(\"safe-startup\"))\n        nh_terminate(EXIT_SUCCESS);\n}\n\n#ifdef WINCHAIN\nvoid\naddto_windowchain(s)\nconst char *s;\n{\n    register int i;\n\n    for (i = 0; winchoices[i].procs; i++) {\n        if ('+' != winchoices[i].procs->name[0])\n            continue;\n        if (!strcmpi(s, winchoices[i].procs->name)) {\n            struct winlink *p = wl_new();\n\n            p->wincp = &winchoices[i];\n            wl_addtail(p);\n            /* NB: The ini_routine() will be called during commit. */\n            return;\n        }\n    }\n\n    windowprocs.win_raw_print = def_raw_print;\n\n    raw_printf(\"Window processor %s not recognized.  Choices are:\", s);\n    for (i = 0; winchoices[i].procs; i++) {\n        if ('+' != winchoices[i].procs->name[0])\n            continue;\n        raw_printf(\"        %s\", winchoices[i].procs->name);\n    }\n\n    nh_terminate(EXIT_FAILURE);\n}\n\nvoid\ncommit_windowchain()\n{\n    struct winlink *p;\n    int n;\n    int wincap, wincap2;\n\n    if (!chain)\n        return;\n\n    /* Save wincap* from the real window system - we'll restore it below. */\n    wincap = windowprocs.wincap;\n    wincap2 = windowprocs.wincap2;\n\n    /* add -chainin at head and -chainout at tail */\n    p = wl_new();\n    p->wincp = win_choices_find(\"-chainin\");\n    if (!p->wincp) {\n        raw_printf(\"Can't locate processor '-chainin'\");\n        exit(EXIT_FAILURE);\n    }\n    wl_addhead(p);\n\n    p = wl_new();\n    p->wincp = win_choices_find(\"-chainout\");\n    if (!p->wincp) {\n        raw_printf(\"Can't locate processor '-chainout'\");\n        exit(EXIT_FAILURE);\n    }\n    wl_addtail(p);\n\n    /* Now alloc() init() similar to Objective-C. */\n    for (n = 1, p = chain; p; n++, p = p->nextlink) {\n        p->linkdata = (*p->wincp->chain_routine)(WINCHAIN_ALLOC, n, 0, 0, 0);\n    }\n\n    for (n = 1, p = chain; p; n++, p = p->nextlink) {\n        if (p->nextlink) {\n            (void) (*p->wincp->chain_routine)(WINCHAIN_INIT, n, p->linkdata,\n                                              p->nextlink->wincp->procs,\n                                              p->nextlink->linkdata);\n        } else {\n            (void) (*p->wincp->chain_routine)(WINCHAIN_INIT, n, p->linkdata,\n                                              last_winchoice->procs, 0);\n        }\n    }\n\n    /* Restore the saved wincap* values.  We do it here to give the\n     * ini_routine()s a chance to change or check them. */\n    chain->wincp->procs->wincap = wincap;\n    chain->wincp->procs->wincap2 = wincap2;\n\n    /* Call the init procs.  Do not re-init the terminal real win. */\n    p = chain;\n    while (p->nextlink) {\n        if (p->wincp->ini_routine) {\n            (*p->wincp->ini_routine)(WININIT);\n        }\n        p = p->nextlink;\n    }\n\n    /* Install the chain into window procs very late so ini_routine()s\n     * can raw_print on error. */\n    windowprocs = *chain->wincp->procs;\n\n    p = chain;\n    while (p) {\n        struct winlink *np = p->nextlink;\n        free(p);\n        p = np; /* assignment, not proof */\n    }\n}\n#endif /* WINCHAIN */\n\n/*\n * tty_message_menu() provides a means to get feedback from the\n * --More-- prompt; other interfaces generally don't need that.\n */\n/*ARGSUSED*/\nchar\ngenl_message_menu(let, how, mesg)\nchar let UNUSED;\nint how UNUSED;\nconst char *mesg;\n{\n    pline(\"%s\", mesg);\n    return 0;\n}\n\n/*ARGSUSED*/\nvoid\ngenl_preference_update(pref)\nconst char *pref UNUSED;\n{\n    /* window ports are expected to provide\n       their own preference update routine\n       for the preference capabilities that\n       they support.\n       Just return in this genl one. */\n    return;\n}\n\nchar *\ngenl_getmsghistory(init)\nboolean init UNUSED;\n{\n    /* window ports can provide\n       their own getmsghistory() routine to\n       preserve message history between games.\n       The routine is called repeatedly from\n       the core save routine, and the window\n       port is expected to successively return\n       each message that it wants saved, starting\n       with the oldest message first, finishing\n       with the most recent.\n       Return null pointer when finished.\n     */\n    return (char *) 0;\n}\n\nvoid\ngenl_putmsghistory(msg, is_restoring)\nconst char *msg;\nboolean is_restoring;\n{\n    /* window ports can provide\n       their own putmsghistory() routine to\n       load message history from a saved game.\n       The routine is called repeatedly from\n       the core restore routine, starting with\n       the oldest saved message first, and\n       finishing with the latest.\n       The window port routine is expected to\n       load the message recall buffers in such\n       a way that the ordering is preserved.\n       The window port routine should make no\n       assumptions about how many messages are\n       forthcoming, nor should it assume that\n       another message will follow this one,\n       so it should keep all pointers/indexes\n       intact at the end of each call.\n    */\n\n    /* this doesn't provide for reloading the message window with the\n       previous session's messages upon restore, but it does put the quest\n       message summary lines there by treating them as ordinary messages */\n    if (!is_restoring)\n        pline(\"%s\", msg);\n    return;\n}\n\n#ifdef HANGUPHANDLING\n/*\n * Dummy windowing scheme used to replace current one with no-ops\n * in order to avoid all terminal I/O after hangup/disconnect.\n */\n\nstatic int NDECL(hup_nhgetch);\nstatic char FDECL(hup_yn_function, (const char *, const char *, CHAR_P));\nstatic int FDECL(hup_nh_poskey, (int *, int *, int *));\nstatic void FDECL(hup_getlin, (const char *, char *));\nstatic void FDECL(hup_init_nhwindows, (int *, char **));\nstatic void FDECL(hup_exit_nhwindows, (const char *));\nstatic winid FDECL(hup_create_nhwindow, (int));\nstatic int FDECL(hup_select_menu, (winid, int, MENU_ITEM_P **));\nstatic void FDECL(hup_add_menu, (winid, int, const anything *, CHAR_P, CHAR_P,\n                                 int, const char *, BOOLEAN_P));\nstatic void FDECL(hup_end_menu, (winid, const char *));\nstatic void FDECL(hup_putstr, (winid, int, const char *));\nstatic void FDECL(hup_print_glyph, (winid, XCHAR_P, XCHAR_P, int, int));\nstatic void FDECL(hup_outrip, (winid, int, time_t));\nstatic void FDECL(hup_curs, (winid, int, int));\nstatic void FDECL(hup_display_nhwindow, (winid, BOOLEAN_P));\nstatic void FDECL(hup_display_file, (const char *, BOOLEAN_P));\n#ifdef CLIPPING\nstatic void FDECL(hup_cliparound, (int, int));\n#endif\n#ifdef CHANGE_COLOR\nstatic void FDECL(hup_change_color, (int, long, int));\n#ifdef MAC\nstatic short FDECL(hup_set_font_name, (winid, char *));\n#endif\nstatic char *NDECL(hup_get_color_string);\n#endif /* CHANGE_COLOR */\nstatic void FDECL(hup_status_update, (int, genericptr_t, int, int, int,\n                                      unsigned long *));\n\nstatic int NDECL(hup_int_ndecl);\nstatic void NDECL(hup_void_ndecl);\nstatic void FDECL(hup_void_fdecl_int, (int));\nstatic void FDECL(hup_void_fdecl_winid, (winid));\nstatic void FDECL(hup_void_fdecl_constchar_p, (const char *));\n\nstatic struct window_procs hup_procs = {\n    \"hup\", 0L, 0L,\n    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n    hup_init_nhwindows,\n    hup_void_ndecl,                                    /* player_selection */\n    hup_void_ndecl,                                    /* askname */\n    hup_void_ndecl,                                    /* get_nh_event */\n    hup_exit_nhwindows, hup_void_fdecl_constchar_p,    /* suspend_nhwindows */\n    hup_void_ndecl,                                    /* resume_nhwindows */\n    hup_create_nhwindow, hup_void_fdecl_winid,         /* clear_nhwindow */\n    hup_display_nhwindow, hup_void_fdecl_winid,        /* destroy_nhwindow */\n    hup_curs, hup_putstr, hup_putstr,                  /* putmixed */\n    hup_display_file, hup_void_fdecl_winid,            /* start_menu */\n    hup_add_menu, hup_end_menu, hup_select_menu, genl_message_menu,\n    hup_void_ndecl,                                    /* update_inventory */\n    hup_void_ndecl,                                    /* mark_synch */\n    hup_void_ndecl,                                    /* wait_synch */\n#ifdef CLIPPING\n    hup_cliparound,\n#endif\n#ifdef POSITIONBAR\n    (void FDECL((*), (char *))) hup_void_fdecl_constchar_p,\n                                                      /* update_positionbar */\n#endif\n    hup_print_glyph,\n    hup_void_fdecl_constchar_p,                       /* raw_print */\n    hup_void_fdecl_constchar_p,                       /* raw_print_bold */\n    hup_nhgetch, hup_nh_poskey, hup_void_ndecl,       /* nhbell  */\n    hup_int_ndecl,                                    /* doprev_message */\n    hup_yn_function, hup_getlin, hup_int_ndecl,       /* get_ext_cmd */\n    hup_void_fdecl_int,                               /* number_pad */\n    hup_void_ndecl,                                   /* delay_output  */\n#ifdef CHANGE_COLOR\n    hup_change_color,\n#ifdef MAC\n    hup_void_fdecl_int,                               /* change_background */\n    hup_set_font_name,\n#endif\n    hup_get_color_string,\n#endif /* CHANGE_COLOR */\n    hup_void_ndecl,                                   /* start_screen */\n    hup_void_ndecl,                                   /* end_screen */\n    hup_outrip, genl_preference_update, genl_getmsghistory,\n    genl_putmsghistory,\n    hup_void_ndecl,                                   /* status_init */\n    hup_void_ndecl,                                   /* status_finish */\n    genl_status_enablefield, hup_status_update,\n    genl_can_suspend_no,\n};\n\nstatic void FDECL((*previnterface_exit_nhwindows), (const char *)) = 0;\n\n/* hangup has occurred; switch to no-op user interface */\nvoid\nnhwindows_hangup()\n{\n    char *FDECL((*previnterface_getmsghistory), (BOOLEAN_P)) = 0;\n\n#ifdef ALTMETA\n    /* command processor shouldn't look for 2nd char after seeing ESC */\n    iflags.altmeta = FALSE;\n#endif\n\n    /* don't call exit_nhwindows() directly here; if a hangup occurs\n       while interface code is executing, exit_nhwindows could knock\n       the interface's active data structures out from under itself */\n    if (iflags.window_inited\n        && windowprocs.win_exit_nhwindows != hup_exit_nhwindows)\n        previnterface_exit_nhwindows = windowprocs.win_exit_nhwindows;\n\n    /* also, we have to leave the old interface's getmsghistory()\n       in place because it will be called while saving the game */\n    if (windowprocs.win_getmsghistory != hup_procs.win_getmsghistory)\n        previnterface_getmsghistory = windowprocs.win_getmsghistory;\n\n    windowprocs = hup_procs;\n\n    if (previnterface_getmsghistory)\n        windowprocs.win_getmsghistory = previnterface_getmsghistory;\n}\n\nstatic void\nhup_exit_nhwindows(lastgasp)\nconst char *lastgasp;\n{\n    /* core has called exit_nhwindows(); call the previous interface's\n       shutdown routine now; xxx_exit_nhwindows() needs to call other\n       xxx_ routines directly rather than through windowprocs pointers */\n    if (previnterface_exit_nhwindows) {\n        lastgasp = 0; /* don't want exit routine to attempt extra output */\n        (*previnterface_exit_nhwindows)(lastgasp);\n        previnterface_exit_nhwindows = 0;\n    }\n    iflags.window_inited = 0;\n}\n\nstatic int\nhup_nhgetch(VOID_ARGS)\n{\n    return '\\033'; /* ESC */\n}\n\n/*ARGSUSED*/\nstatic char\nhup_yn_function(prompt, resp, deflt)\nconst char *prompt UNUSED, *resp UNUSED;\nchar deflt;\n{\n    if (!deflt)\n        deflt = '\\033';\n    return deflt;\n}\n\n/*ARGSUSED*/\nstatic int\nhup_nh_poskey(x, y, mod)\nint *x UNUSED, *y UNUSED, *mod UNUSED;\n{\n    return '\\033';\n}\n\n/*ARGSUSED*/\nstatic void\nhup_getlin(prompt, outbuf)\nconst char *prompt UNUSED;\nchar *outbuf;\n{\n    Strcpy(outbuf, \"\\033\");\n}\n\n/*ARGSUSED*/\nstatic void\nhup_init_nhwindows(argc_p, argv)\nint *argc_p UNUSED;\nchar **argv UNUSED;\n{\n    iflags.window_inited = 1;\n}\n\n/*ARGUSED*/\nstatic winid\nhup_create_nhwindow(type)\nint type UNUSED;\n{\n    return WIN_ERR;\n}\n\n/*ARGSUSED*/\nstatic int\nhup_select_menu(window, how, menu_list)\nwinid window UNUSED;\nint how UNUSED;\nstruct mi **menu_list UNUSED;\n{\n    return -1;\n}\n\n/*ARGSUSED*/\nstatic void\nhup_add_menu(window, glyph, identifier, sel, grpsel, attr, txt, preselected)\nwinid window UNUSED;\nint glyph UNUSED, attr UNUSED;\nconst anything *identifier UNUSED;\nchar sel UNUSED, grpsel UNUSED;\nconst char *txt UNUSED;\nboolean preselected UNUSED;\n{\n    return;\n}\n\n/*ARGSUSED*/\nstatic void\nhup_end_menu(window, prompt)\nwinid window UNUSED;\nconst char *prompt UNUSED;\n{\n    return;\n}\n\n/*ARGSUSED*/\nstatic void\nhup_putstr(window, attr, text)\nwinid window UNUSED;\nint attr UNUSED;\nconst char *text UNUSED;\n{\n    return;\n}\n\n/*ARGSUSED*/\nstatic void\nhup_print_glyph(window, x, y, glyph, bkglyph)\nwinid window UNUSED;\nxchar x UNUSED, y UNUSED;\nint glyph UNUSED;\nint bkglyph UNUSED;\n{\n    return;\n}\n\n/*ARGSUSED*/\nstatic void\nhup_outrip(tmpwin, how, when)\nwinid tmpwin UNUSED;\nint how UNUSED;\ntime_t when UNUSED;\n{\n    return;\n}\n\n/*ARGSUSED*/\nstatic void\nhup_curs(window, x, y)\nwinid window UNUSED;\nint x UNUSED, y UNUSED;\n{\n    return;\n}\n\n/*ARGSUSED*/\nstatic void\nhup_display_nhwindow(window, blocking)\nwinid window UNUSED;\nboolean blocking UNUSED;\n{\n    return;\n}\n\n/*ARGSUSED*/\nstatic void\nhup_display_file(fname, complain)\nconst char *fname UNUSED;\nboolean complain UNUSED;\n{\n    return;\n}\n\n#ifdef CLIPPING\n/*ARGSUSED*/\nstatic void\nhup_cliparound(x, y)\nint x UNUSED, y UNUSED;\n{\n    return;\n}\n#endif\n\n#ifdef CHANGE_COLOR\n/*ARGSUSED*/\nstatic void\nhup_change_color(color, rgb, reverse)\nint color, reverse;\nlong rgb;\n{\n    return;\n}\n\n#ifdef MAC\n/*ARGSUSED*/\nstatic short\nhup_set_font_name(window, fontname)\nwinid window;\nchar *fontname;\n{\n    return 0;\n}\n#endif /* MAC */\n\nstatic char *\nhup_get_color_string(VOID_ARGS)\n{\n    return (char *) 0;\n}\n#endif /* CHANGE_COLOR */\n\n/*ARGSUSED*/\nstatic void\nhup_status_update(idx, ptr, chg, pc, color, colormasks)\nint idx UNUSED;\ngenericptr_t ptr UNUSED;\nint chg UNUSED, pc UNUSED, color UNUSED;\nunsigned long *colormasks UNUSED;\n\n{\n    return;\n}\n\n/*\n * Non-specific stubs.\n */\n\nstatic int\nhup_int_ndecl(VOID_ARGS)\n{\n    return -1;\n}\n\nstatic void\nhup_void_ndecl(VOID_ARGS)\n{\n    return;\n}\n\n/*ARGUSED*/\nstatic void\nhup_void_fdecl_int(arg)\nint arg UNUSED;\n{\n    return;\n}\n\n/*ARGUSED*/\nstatic void\nhup_void_fdecl_winid(window)\nwinid window UNUSED;\n{\n    return;\n}\n\n/*ARGUSED*/\nstatic void\nhup_void_fdecl_constchar_p(string)\nconst char *string UNUSED;\n{\n    return;\n}\n\n#endif /* HANGUPHANDLING */\n\n\n/****************************************************************************/\n/* genl backward compat stuff                                               */\n/****************************************************************************/\n\nconst char *status_fieldnm[MAXBLSTATS];\nconst char *status_fieldfmt[MAXBLSTATS];\nchar *status_vals[MAXBLSTATS];\nboolean status_activefields[MAXBLSTATS];\nNEARDATA winid WIN_STATUS;\n\nvoid\ngenl_status_init()\n{\n    int i;\n\n    for (i = 0; i < MAXBLSTATS; ++i) {\n        status_vals[i] = (char *) alloc(MAXCO);\n        *status_vals[i] = '\\0';\n        status_activefields[i] = FALSE;\n        status_fieldfmt[i] = (const char *) 0;\n    }\n    /* Use a window for the genl version; backward port compatibility */\n    WIN_STATUS = create_nhwindow(NHW_STATUS);\n    display_nhwindow(WIN_STATUS, FALSE);\n}\n\nvoid\ngenl_status_finish()\n{\n    /* tear down routine */\n    int i;\n\n    /* free alloc'd memory here */\n    for (i = 0; i < MAXBLSTATS; ++i) {\n        if (status_vals[i])\n            free((genericptr_t) status_vals[i]), status_vals[i] = (char *) 0;\n    }\n}\n\nvoid\ngenl_status_enablefield(fieldidx, nm, fmt, enable)\nint fieldidx;\nconst char *nm;\nconst char *fmt;\nboolean enable;\n{\n    status_fieldfmt[fieldidx] = fmt;\n    status_fieldnm[fieldidx] = nm;\n    status_activefields[fieldidx] = enable;\n}\n\n/* call once for each field, then call with BL_FLUSH to output the result */\nvoid\ngenl_status_update(idx, ptr, chg, percent, color, colormasks)\nint idx;\ngenericptr_t ptr;\nint chg UNUSED, percent UNUSED, color UNUSED;\nunsigned long *colormasks UNUSED;\n{\n    char newbot1[MAXCO], newbot2[MAXCO];\n    long cond, *condptr = (long *) ptr;\n    register int i;\n    unsigned pass, lndelta;\n    enum statusfields idx1, idx2, *fieldlist;\n    char *nb, *text = (char *) ptr;\n\n    static enum statusfields fieldorder[][15] = {\n        /* line one */\n        { BL_TITLE, BL_STR, BL_DX, BL_CO, BL_IN, BL_WI, BL_CH, BL_ALIGN,\n          BL_SCORE, BL_FLUSH, BL_FLUSH, BL_FLUSH, BL_FLUSH, BL_FLUSH,\n          BL_FLUSH },\n        /* line two, default order */\n        { BL_LEVELDESC, BL_GOLD,\n          BL_HP, BL_HPMAX, BL_ENE, BL_ENEMAX, BL_AC,\n          BL_XP, BL_EXP, BL_HD,\n          BL_TIME,\n          BL_HUNGER, BL_CAP, BL_CONDITION,\n          BL_FLUSH },\n        /* move time to the end */\n        { BL_LEVELDESC, BL_GOLD,\n          BL_HP, BL_HPMAX, BL_ENE, BL_ENEMAX, BL_AC,\n          BL_XP, BL_EXP, BL_HD,\n          BL_HUNGER, BL_CAP, BL_CONDITION,\n          BL_TIME, BL_FLUSH },\n        /* move experience and time to the end */\n        { BL_LEVELDESC, BL_GOLD,\n          BL_HP, BL_HPMAX, BL_ENE, BL_ENEMAX, BL_AC,\n          BL_HUNGER, BL_CAP, BL_CONDITION,\n          BL_XP, BL_EXP, BL_HD, BL_TIME, BL_FLUSH },\n        /* move level description plus gold and experience and time to end */\n        { BL_HP, BL_HPMAX, BL_ENE, BL_ENEMAX, BL_AC,\n          BL_HUNGER, BL_CAP, BL_CONDITION,\n          BL_LEVELDESC, BL_GOLD, BL_XP, BL_EXP, BL_HD, BL_TIME, BL_FLUSH },\n    };\n\n    /* in case interface is using genl_status_update() but has not\n       specified WC2_FLUSH_STATUS (status_update() for field values\n       is buffered so final BL_FLUSH is needed to produce output) */\n    windowprocs.wincap2 |= WC2_FLUSH_STATUS;\n\n    if (idx >= 0) {\n        if (!status_activefields[idx])\n            return;\n        switch (idx) {\n        case BL_CONDITION:\n            cond = condptr ? *condptr : 0L;\n            nb = status_vals[idx];\n            *nb = '\\0';\n            if (cond & BL_MASK_STONE)\n                Strcpy(nb = eos(nb), \" Stone\");\n            if (cond & BL_MASK_SLIME)\n                Strcpy(nb = eos(nb), \" Slime\");\n            if (cond & BL_MASK_STRNGL)\n                Strcpy(nb = eos(nb), \" Strngl\");\n            if (cond & BL_MASK_FOODPOIS)\n                Strcpy(nb = eos(nb), \" FoodPois\");\n            if (cond & BL_MASK_TERMILL)\n                Strcpy(nb = eos(nb), \" TermIll\");\n            if (cond & BL_MASK_BLIND)\n                Strcpy(nb = eos(nb), \" Blind\");\n            if (cond & BL_MASK_DEAF)\n                Strcpy(nb = eos(nb), \" Deaf\");\n            if (cond & BL_MASK_STUN)\n                Strcpy(nb = eos(nb), \" Stun\");\n            if (cond & BL_MASK_CONF)\n                Strcpy(nb = eos(nb), \" Conf\");\n            if (cond & BL_MASK_HALLU)\n                Strcpy(nb = eos(nb), \" Hallu\");\n            if (cond & BL_MASK_LEV)\n                Strcpy(nb = eos(nb), \" Lev\");\n            if (cond & BL_MASK_FLY)\n                Strcpy(nb = eos(nb), \" Fly\");\n            if (cond & BL_MASK_RIDE)\n                Strcpy(nb = eos(nb), \" Ride\");\n            break;\n        default:\n            Sprintf(status_vals[idx],\n                    status_fieldfmt[idx] ? status_fieldfmt[idx] : \"%s\",\n                    text ? text : \"\");\n            break;\n        }\n        return; /* processed one field other than BL_FLUSH */\n    } /* (idx >= 0, thus not BL_FLUSH, BL_RESET, BL_CHARACTERISTICS) */\n\n    /* does BL_RESET require any specific code to ensure all fields ? */\n\n    if (!(idx == BL_FLUSH || idx == BL_RESET))\n        return;\n\n    /* We've received BL_FLUSH; time to output the gathered data */\n    nb = newbot1;\n    *nb = '\\0';\n    /* BL_FLUSH is the only pseudo-index value we need to check for\n       in the loop below because it is the only entry used to pad the\n       end of the fieldorder array. We could stop on any\n       negative (illegal) index, but this should be fine */\n    for (i = 0; (idx1 = fieldorder[0][i]) != BL_FLUSH; ++i) {\n        if (status_activefields[idx1])\n            Strcpy(nb = eos(nb), status_vals[idx1]);\n    }\n    /* if '$' is encoded, buffer length of \\GXXXXNNNN is 9 greater than\n       single char; we want to subtract that 9 when checking display length */\n    lndelta = (status_activefields[BL_GOLD]\n               && strstr(status_vals[BL_GOLD], \"\\\\G\")) ? 9 : 0;\n    /* basic bot2 formats groups of second line fields into five buffers,\n       then decides how to order those buffers based on comparing lengths\n       of [sub]sets of them to the width of the map; we have more control\n       here but currently emulate that behavior */\n    for (pass = 1; pass <= 4; pass++) {\n        fieldlist = fieldorder[pass];\n        nb = newbot2;\n        *nb = '\\0';\n        for (i = 0; (idx2 = fieldlist[i]) != BL_FLUSH; ++i) {\n            if (status_activefields[idx2]) {\n                const char *val = status_vals[idx2];\n\n                switch (idx2) {\n                case BL_HP: /* for pass 4, Hp comes first; mungspaces()\n                               will strip the unwanted leading spaces */\n                case BL_XP: case BL_HD:\n                case BL_TIME:\n                    Strcpy(nb = eos(nb), \" \");\n                    break;\n                case BL_LEVELDESC:\n                    /* leveldesc has no leading space, so if we've moved\n                       it past the first position, provide one */\n                    if (i != 0)\n                        Strcpy(nb = eos(nb), \" \");\n                    break;\n                /*\n                 * We want \"  hunger encumbrance conditions\"\n                 *   or    \"  encumbrance conditions\"\n                 *   or    \"  hunger conditions\"\n                 *   or    \"  conditions\"\n                 * 'hunger'      is either \" \" or \" hunger_text\";\n                 * 'encumbrance' is either \" \" or \" encumbrance_text\";\n                 * 'conditions'  is either \"\"  or \" cond1 cond2...\".\n                 */\n                case BL_HUNGER:\n                    /* hunger==\" \" - keep it, end up with \" \";\n                       hunger!=\" \" - insert space and get \"  hunger\" */\n                    if (strcmp(val, \" \"))\n                        Strcpy(nb = eos(nb), \" \");\n                    break;\n                case BL_CAP:\n                    /* cap==\" \" - suppress it, retain \"  hunger\" or \" \";\n                       cap!=\" \" - use it, get \"  hunger cap\" or \"  cap\" */\n                    if (!strcmp(val, \" \"))\n                        ++val;\n                    break;\n                default:\n                    break;\n                }\n                Strcpy(nb = eos(nb), val); /* status_vals[idx2] */\n            } /* status_activefields[idx2] */\n\n            if (idx2 == BL_CONDITION && pass < 4\n                && strlen(newbot2) - lndelta > COLNO)\n                break; /* switch to next order */\n        } /* i */\n\n        if (idx2 == BL_FLUSH) { /* made it past BL_CONDITION */\n            if (pass > 1)\n                mungspaces(newbot2);\n            break;\n        }\n    } /* pass */\n    curs(WIN_STATUS, 1, 0);\n    putstr(WIN_STATUS, 0, newbot1);\n    curs(WIN_STATUS, 1, 1);\n    putmixed(WIN_STATUS, 0, newbot2); /* putmixed() due to GOLD glyph */\n}\n\nSTATIC_VAR struct window_procs dumplog_windowprocs_backup;\nSTATIC_VAR FILE *dumplog_file;\n\n#ifdef DUMPLOG\nSTATIC_VAR time_t dumplog_now;\n\nchar *\ndump_fmtstr(fmt, buf, fullsubs)\nconst char *fmt;\nchar *buf;\nboolean fullsubs; /* True -> full substitution for file name, False ->\n                   * partial substitution for '--showpaths' feedback\n                   * where there's no game in progress when executed */\n{\n    const char *fp = fmt;\n    char *bp = buf;\n    int slen, len = 0;\n    char tmpbuf[BUFSZ];\n    char verbuf[BUFSZ];\n    long uid;\n    time_t now;\n\n    now = dumplog_now;\n    uid = (long) getuid();\n\n    /*\n     * Note: %t and %T assume that time_t is a 'long int' number of\n     * seconds since some epoch value.  That's quite iffy....  The\n     * unit of time might be different and the datum size might be\n     * some variant of 'long long int'.  [Their main purpose is to\n     * construct a unique file name rather than record the date and\n     * time; violating the 'long seconds since base-date' assumption\n     * may or may not interfere with that usage.]\n     */\n\n    while (fp && *fp && len < BUFSZ - 1) {\n        if (*fp == '%') {\n            fp++;\n            switch (*fp) {\n            default:\n                goto finish;\n            case '\\0': /* fallthrough */\n            case '%':  /* literal % */\n                Sprintf(tmpbuf, \"%%\");\n                break;\n            case 't': /* game start, timestamp */\n                if (fullsubs)\n                    Sprintf(tmpbuf, \"%lu\", (unsigned long) ubirthday);\n                else\n                    Strcpy(tmpbuf, \"{game start cookie}\");\n                break;\n            case 'T': /* current time, timestamp */\n                if (fullsubs)\n                    Sprintf(tmpbuf, \"%lu\", (unsigned long) now);\n                else\n                    Strcpy(tmpbuf, \"{current time cookie}\");\n                break;\n            case 'd': /* game start, YYYYMMDDhhmmss */\n                if (fullsubs)\n                    Sprintf(tmpbuf, \"%08ld%06ld\",\n                            yyyymmdd(ubirthday), hhmmss(ubirthday));\n                else\n                    Strcpy(tmpbuf, \"{game start date+time}\");\n                break;\n            case 'D': /* current time, YYYYMMDDhhmmss */\n                if (fullsubs)\n                    Sprintf(tmpbuf, \"%08ld%06ld\", yyyymmdd(now), hhmmss(now));\n                else\n                    Strcpy(tmpbuf, \"{current date+time}\");\n                break;\n            case 'v': /* version, eg. \"3.6.5-0\" */\n                Sprintf(tmpbuf, \"%s\", version_string(verbuf));\n                break;\n            case 'u': /* UID */\n                Sprintf(tmpbuf, \"%ld\", uid);\n                break;\n            case 'n': /* player name */\n                if (fullsubs)\n                    Sprintf(tmpbuf, \"%s\", *plname ? plname : \"unknown\");\n                else\n                    Strcpy(tmpbuf, \"{hero name}\");\n                break;\n            case 'N': /* first character of player name */\n                if (fullsubs)\n                    Sprintf(tmpbuf, \"%c\", *plname ? *plname : 'u');\n                else\n                    Strcpy(tmpbuf, \"{hero initial}\");\n                break;\n            }\n            if (fullsubs) {\n                /* replace potentially troublesome characters (including\n                   <space> even though it might be an acceptable file name\n                   character); user shouldn't be able to get ' ' or '/'\n                   or '\\\\' into plname[] but play things safe */\n                (void) strNsubst(tmpbuf, \" \", \"_\", 0);\n                (void) strNsubst(tmpbuf, \"/\", \"_\", 0);\n                (void) strNsubst(tmpbuf, \"\\\\\", \"_\", 0);\n                /* note: replacements are only done on field substitutions,\n                   not on the template (from sysconf or DUMPLOG_FILE) */\n            }\n\n            slen = (int) strlen(tmpbuf);\n            if (len + slen < BUFSZ - 1) {\n                len += slen;\n                Sprintf(bp, \"%s\", tmpbuf);\n                bp += slen;\n                if (*fp)\n                    fp++;\n            } else\n                break;\n        } else {\n            *bp = *fp;\n            bp++;\n            fp++;\n            len++;\n        }\n    }\n finish:\n    *bp = '\\0';\n    return buf;\n}\n#endif /* DUMPLOG */\n\nvoid\ndump_open_log(now)\ntime_t now;\n{\n#ifdef DUMPLOG\n    char buf[BUFSZ];\n    char *fname;\n\n    dumplog_now = now;\n#ifdef SYSCF\n    if (!sysopt.dumplogfile)\n        return;\n    fname = dump_fmtstr(sysopt.dumplogfile, buf, TRUE);\n#else\n    fname = dump_fmtstr(DUMPLOG_FILE, buf, TRUE);\n#endif\n    dumplog_file = fopen(fname, \"w\");\n    dumplog_windowprocs_backup = windowprocs;\n\n#else /*!DUMPLOG*/\n    nhUse(now);\n#endif /*?DUMPLOG*/\n}\n\nvoid\ndump_close_log()\n{\n    if (dumplog_file) {\n        (void) fclose(dumplog_file);\n        dumplog_file = (FILE *) 0;\n    }\n}\n\nvoid\ndump_forward_putstr(win, attr, str, no_forward)\nwinid win;\nint attr;\nconst char *str;\nint no_forward;\n{\n    if (dumplog_file)\n        fprintf(dumplog_file, \"%s\\n\", str);\n    if (!no_forward)\n        putstr(win, attr, str);\n}\n\n/*ARGSUSED*/\nSTATIC_OVL void\ndump_putstr(win, attr, str)\nwinid win UNUSED;\nint attr UNUSED;\nconst char *str;\n{\n    if (dumplog_file)\n        fprintf(dumplog_file, \"%s\\n\", str);\n}\n\nSTATIC_OVL winid\ndump_create_nhwindow(dummy)\nint dummy;\n{\n    return dummy;\n}\n\n/*ARGUSED*/\nSTATIC_OVL void\ndump_clear_nhwindow(win)\nwinid win UNUSED;\n{\n    return;\n}\n\n/*ARGSUSED*/\nSTATIC_OVL void\ndump_display_nhwindow(win, p)\nwinid win UNUSED;\nboolean p UNUSED;\n{\n    return;\n}\n\n/*ARGUSED*/\nSTATIC_OVL void\ndump_destroy_nhwindow(win)\nwinid win UNUSED;\n{\n    return;\n}\n\n/*ARGUSED*/\nSTATIC_OVL void\ndump_start_menu(win)\nwinid win UNUSED;\n{\n    return;\n}\n\n/*ARGSUSED*/\nSTATIC_OVL void\ndump_add_menu(win, glyph, identifier, ch, gch, attr, str, preselected)\nwinid win UNUSED;\nint glyph;\nconst anything *identifier UNUSED;\nchar ch;\nchar gch UNUSED;\nint attr UNUSED;\nconst char *str;\nboolean preselected UNUSED;\n{\n    if (dumplog_file) {\n        if (glyph == NO_GLYPH)\n            fprintf(dumplog_file, \" %s\\n\", str);\n        else\n            fprintf(dumplog_file, \"  %c - %s\\n\", ch, str);\n    }\n}\n\n/*ARGSUSED*/\nSTATIC_OVL void\ndump_end_menu(win, str)\nwinid win UNUSED;\nconst char *str;\n{\n    if (dumplog_file) {\n        if (str)\n            fprintf(dumplog_file, \"%s\\n\", str);\n        else\n            fputs(\"\\n\", dumplog_file);\n    }\n}\n\nSTATIC_OVL int\ndump_select_menu(win, how, item)\nwinid win UNUSED;\nint how UNUSED;\nmenu_item **item;\n{\n    *item = (menu_item *) 0;\n    return 0;\n}\n\nvoid\ndump_redirect(onoff_flag)\nboolean onoff_flag;\n{\n    if (dumplog_file) {\n        if (onoff_flag) {\n            windowprocs.win_create_nhwindow = dump_create_nhwindow;\n            windowprocs.win_clear_nhwindow = dump_clear_nhwindow;\n            windowprocs.win_display_nhwindow = dump_display_nhwindow;\n            windowprocs.win_destroy_nhwindow = dump_destroy_nhwindow;\n            windowprocs.win_start_menu = dump_start_menu;\n            windowprocs.win_add_menu = dump_add_menu;\n            windowprocs.win_end_menu = dump_end_menu;\n            windowprocs.win_select_menu = dump_select_menu;\n            windowprocs.win_putstr = dump_putstr;\n        } else {\n            windowprocs = dumplog_windowprocs_backup;\n        }\n        iflags.in_dumplog = onoff_flag;\n    } else {\n        iflags.in_dumplog = FALSE;\n    }\n}\n\n#ifdef TTY_GRAPHICS\n#ifdef TEXTCOLOR\n#ifdef TOS\nextern const char *hilites[CLR_MAX];\n#else\nextern NEARDATA char *hilites[CLR_MAX];\n#endif\n#endif\n#endif\n\nint\nhas_color(color)\nint color;\n{\n    return (iflags.use_color && windowprocs.name\n            && (windowprocs.wincap & WC_COLOR) && windowprocs.has_color[color]\n#ifdef TTY_GRAPHICS\n#if defined(TEXTCOLOR) && defined(TERMLIB) && !defined(NO_TERMS)\n             && (hilites[color] != 0)\n#endif\n#endif\n    );\n}\n\n/*windows.c*/\n", "/* NetHack 3.6\tunixmain.c\t$NHDT-Date: 1570408210 2019/10/07 00:30:10 $  $NHDT-Branch: NetHack-3.6 $:$NHDT-Revision: 1.70 $ */\n/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */\n/*-Copyright (c) Robert Patrick Rankin, 2011. */\n/* NetHack may be freely redistributed.  See license for details. */\n\n/* main.c - Unix NetHack */\n\n#include \"hack.h\"\n#include \"dlb.h\"\n\n#include <ctype.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <pwd.h>\n#ifndef O_RDONLY\n#include <fcntl.h>\n#endif\n\n#if !defined(_BULL_SOURCE) && !defined(__sgi) && !defined(_M_UNIX)\n#if !defined(SUNOS4) && !(defined(ULTRIX) && defined(__GNUC__))\n#if defined(POSIX_TYPES) || defined(SVR4) || defined(HPUX)\nextern struct passwd *FDECL(getpwuid, (uid_t));\n#else\nextern struct passwd *FDECL(getpwuid, (int));\n#endif\n#endif\n#endif\nextern struct passwd *FDECL(getpwnam, (const char *));\n#ifdef CHDIR\nstatic void FDECL(chdirx, (const char *, BOOLEAN_P));\n#endif /* CHDIR */\nstatic boolean NDECL(whoami);\nstatic void FDECL(process_options, (int, char **));\n\n#ifdef _M_UNIX\nextern void NDECL(check_sco_console);\nextern void NDECL(init_sco_cons);\n#endif\n#ifdef __linux__\nextern void NDECL(check_linux_console);\nextern void NDECL(init_linux_cons);\n#endif\n\nstatic void NDECL(wd_message);\nstatic boolean wiz_error_flag = FALSE;\nstatic struct passwd *NDECL(get_unix_pw);\n\nint\nmain(argc, argv)\nint argc;\nchar *argv[];\n{\n    register int fd;\n#ifdef CHDIR\n    register char *dir;\n#endif\n    boolean exact_username;\n    boolean resuming = FALSE; /* assume new game */\n    boolean plsel_once = FALSE;\n\n    sys_early_init();\n\n#if defined(__APPLE__)\n    {\n/* special hack to change working directory to a resource fork when\n   running from finder --sam */\n#define MAC_PATH_VALUE \".app/Contents/MacOS/\"\n        char mac_cwd[1024], *mac_exe = argv[0], *mac_tmp;\n        int arg0_len = strlen(mac_exe), mac_tmp_len, mac_lhs_len = 0;\n        getcwd(mac_cwd, 1024);\n        if (mac_exe[0] == '/' && !strcmp(mac_cwd, \"/\")) {\n            if ((mac_exe = strrchr(mac_exe, '/')))\n                mac_exe++;\n            else\n                mac_exe = argv[0];\n            mac_tmp_len = (strlen(mac_exe) * 2) + strlen(MAC_PATH_VALUE);\n            if (mac_tmp_len <= arg0_len) {\n                mac_tmp = malloc(mac_tmp_len + 1);\n                sprintf(mac_tmp, \"%s%s%s\", mac_exe, MAC_PATH_VALUE, mac_exe);\n                if (!strcmp(argv[0] + (arg0_len - mac_tmp_len), mac_tmp)) {\n                    mac_lhs_len =\n                        (arg0_len - mac_tmp_len) + strlen(mac_exe) + 5;\n                    if (mac_lhs_len > mac_tmp_len - 1)\n                        mac_tmp = realloc(mac_tmp, mac_lhs_len);\n                    strncpy(mac_tmp, argv[0], mac_lhs_len);\n                    mac_tmp[mac_lhs_len] = '\\0';\n                    chdir(mac_tmp);\n                }\n                free(mac_tmp);\n            }\n        }\n    }\n#endif\n\n    hname = argv[0];\n    hackpid = getpid();\n    (void) umask(0777 & ~FCMASK);\n\n    choose_windows(DEFAULT_WINDOW_SYS);\n\n#ifdef CHDIR /* otherwise no chdir() */\n    /*\n     * See if we must change directory to the playground.\n     * (Perhaps hack runs suid and playground is inaccessible\n     *  for the player.)\n     * The environment variable HACKDIR is overridden by a\n     *  -d command line option (must be the first option given).\n     */\n    dir = nh_getenv(\"NETHACKDIR\");\n    if (!dir)\n        dir = nh_getenv(\"HACKDIR\");\n\n    if (argc > 1) {\n        if (argcheck(argc, argv, ARG_VERSION) == 2)\n            exit(EXIT_SUCCESS);\n\n        if (argcheck(argc, argv, ARG_SHOWPATHS) == 2) {\n#ifdef CHDIR\n            chdirx((char *) 0, 0);\n#endif\n            iflags.initoptions_noterminate = TRUE;\n            initoptions();\n            iflags.initoptions_noterminate = FALSE;\n            reveal_paths();\n            exit(EXIT_SUCCESS);\n        }\n        if (argcheck(argc, argv, ARG_DEBUG) == 1) {\n            argc--;\n            argv++;\n        }\n        if (argc > 1 && !strncmp(argv[1], \"-d\", 2) && argv[1][2] != 'e') {\n            /* avoid matching \"-dec\" for DECgraphics; since the man page\n             * says -d directory, hope nobody's using -desomething_else\n             */\n            argc--;\n            argv++;\n            dir = argv[0] + 2;\n            if (*dir == '=' || *dir == ':')\n                dir++;\n            if (!*dir && argc > 1) {\n                argc--;\n                argv++;\n                dir = argv[0];\n            }\n            if (!*dir)\n                error(\"Flag -d must be followed by a directory name.\");\n        }\n    }\n#endif /* CHDIR */\n\n    if (argc > 1) {\n        /*\n         * Now we know the directory containing 'record' and\n         * may do a prscore().  Exclude `-style' - it's a Qt option.\n         */\n        if (!strncmp(argv[1], \"-s\", 2) && strncmp(argv[1], \"-style\", 6)) {\n#ifdef CHDIR\n            chdirx(dir, 0);\n#endif\n#ifdef SYSCF\n            initoptions();\n#endif\n#ifdef PANICTRACE\n            ARGV0 = hname; /* save for possible stack trace */\n#ifndef NO_SIGNAL\n            panictrace_setsignals(TRUE);\n#endif\n#endif\n            prscore(argc, argv);\n            /* FIXME: shouldn't this be using nh_terminate() to free\n               up any memory allocated by initoptions() */\n            exit(EXIT_SUCCESS);\n        }\n    } /* argc > 1 */\n\n/*\n * Change directories before we initialize the window system so\n * we can find the tile file.\n */\n#ifdef CHDIR\n    chdirx(dir, 1);\n#endif\n\n#ifdef _M_UNIX\n    check_sco_console();\n#endif\n#ifdef __linux__\n    check_linux_console();\n#endif\n    initoptions();\n#ifdef PANICTRACE\n    ARGV0 = hname; /* save for possible stack trace */\n#ifndef NO_SIGNAL\n    panictrace_setsignals(TRUE);\n#endif\n#endif\n    exact_username = whoami();\n\n    /*\n     * It seems you really want to play.\n     */\n    u.uhp = 1; /* prevent RIP on early quits */\n    program_state.preserve_locks = 1;\n#ifndef NO_SIGNAL\n    sethanguphandler((SIG_RET_TYPE) hangup);\n#endif\n\n    process_options(argc, argv); /* command line options */\n#ifdef WINCHAIN\n    commit_windowchain();\n#endif\n    init_nhwindows(&argc, argv); /* now we can set up window system */\n#ifdef _M_UNIX\n    init_sco_cons();\n#endif\n#ifdef __linux__\n    init_linux_cons();\n#endif\n\n#ifdef DEF_PAGER\n    if (!(catmore = nh_getenv(\"HACKPAGER\"))\n        && !(catmore = nh_getenv(\"PAGER\")))\n        catmore = DEF_PAGER;\n#endif\n#ifdef MAIL\n    getmailstatus();\n#endif\n\n    /* wizard mode access is deferred until here */\n    set_playmode(); /* sets plname to \"wizard\" for wizard mode */\n    if (exact_username) {\n        /*\n         * FIXME: this no longer works, ever since 3.3.0\n         * when plnamesuffix() was changed to find\n         * Name-Role-Race-Gender-Alignment.  It removes\n         * all dashes rather than just the last one,\n         * regardless of whether whatever follows each\n         * dash matches role, race, gender, or alignment.\n         */\n        /* guard against user names with hyphens in them */\n        int len = (int) strlen(plname);\n        /* append the current role, if any, so that last dash is ours */\n        if (++len < (int) sizeof plname)\n            (void) strncat(strcat(plname, \"-\"), pl_character,\n                           sizeof plname - len - 1);\n    }\n    /* strip role,race,&c suffix; calls askname() if plname[] is empty\n       or holds a generic user name like \"player\" or \"games\" */\n    plnamesuffix();\n\n    if (wizard) {\n        /* use character name rather than lock letter for file names */\n        locknum = 0;\n    } else {\n        /* suppress interrupts while processing lock file */\n        (void) signal(SIGQUIT, SIG_IGN);\n        (void) signal(SIGINT, SIG_IGN);\n    }\n\n    dlb_init(); /* must be before newgame() */\n\n    /*\n     * Initialize the vision system.  This must be before mklev() on a\n     * new game or before a level restore on a saved game.\n     */\n    vision_init();\n\n    display_gamewindows();\n\n    /*\n     * First, try to find and restore a save file for specified character.\n     * We'll return here if new game player_selection() renames the hero.\n     */\n attempt_restore:\n\n    /*\n     * getlock() complains and quits if there is already a game\n     * in progress for current character name (when locknum == 0)\n     * or if there are too many active games (when locknum > 0).\n     * When proceeding, it creates an empty <lockname>.0 file to\n     * designate the current game.\n     * getlock() constructs <lockname> based on the character\n     * name (for !locknum) or on first available of alock, block,\n     * clock, &c not currently in use in the playground directory\n     * (for locknum > 0).\n     */\n    if (*plname) {\n        getlock();\n        program_state.preserve_locks = 0; /* after getlock() */\n    }\n\n    if (*plname && (fd = restore_saved_game()) >= 0) {\n        const char *fq_save = fqname(SAVEF, SAVEPREFIX, 1);\n\n        (void) chmod(fq_save, 0); /* disallow parallel restores */\n#ifndef NO_SIGNAL\n        (void) signal(SIGINT, (SIG_RET_TYPE) done1);\n#endif\n#ifdef NEWS\n        if (iflags.news) {\n            display_file(NEWS, FALSE);\n            iflags.news = FALSE; /* in case dorecover() fails */\n        }\n#endif\n        pline(\"Restoring save file...\");\n        mark_synch(); /* flush output */\n        if (dorecover(fd)) {\n            resuming = TRUE; /* not starting new game */\n            wd_message();\n            if (discover || wizard) {\n                /* this seems like a candidate for paranoid_confirmation... */\n                if (yn(\"Do you want to keep the save file?\") == 'n') {\n                    (void) delete_savefile();\n                } else {\n                    (void) chmod(fq_save, FCMASK); /* back to readable */\n                    nh_compress(fq_save);\n                }\n            }\n        }\n    }\n\n    if (!resuming) {\n        boolean neednewlock = (!*plname);\n        /* new game:  start by choosing role, race, etc;\n           player might change the hero's name while doing that,\n           in which case we try to restore under the new name\n           and skip selection this time if that didn't succeed */\n        if (!iflags.renameinprogress || iflags.defer_plname || neednewlock) {\n            if (!plsel_once)\n                player_selection();\n            plsel_once = TRUE;\n            if (neednewlock && *plname)\n                goto attempt_restore;\n            if (iflags.renameinprogress) {\n                /* player has renamed the hero while selecting role;\n                   if locking alphabetically, the existing lock file\n                   can still be used; otherwise, discard current one\n                   and create another for the new character name */\n                if (!locknum) {\n                    delete_levelfile(0); /* remove empty lock file */\n                    getlock();\n                }\n                goto attempt_restore;\n            }\n        }\n        newgame();\n        wd_message();\n    }\n\n    /* moveloop() never returns but isn't flagged NORETURN */\n    moveloop(resuming);\n\n    exit(EXIT_SUCCESS);\n    /*NOTREACHED*/\n    return 0;\n}\n\nstatic void\nprocess_options(argc, argv)\nint argc;\nchar *argv[];\n{\n    int i, l;\n\n    /*\n     * Process options.\n     */\n    while (argc > 1 && argv[1][0] == '-') {\n        argv++;\n        argc--;\n        l = (int) strlen(*argv);\n        /* must supply at least 4 chars to match \"-XXXgraphics\" */\n        if (l < 4)\n            l = 4;\n\n        switch (argv[0][1]) {\n        case 'D':\n        case 'd':\n            if ((argv[0][1] == 'D' && !argv[0][2])\n                || !strcmpi(*argv, \"-debug\")) {\n                wizard = TRUE, discover = FALSE;\n            } else if (!strncmpi(*argv, \"-DECgraphics\", l)) {\n                load_symset(\"DECGraphics\", PRIMARY);\n                switch_symbols(TRUE);\n            } else {\n                raw_printf(\"Unknown option: %s\", *argv);\n            }\n            break;\n        case 'X':\n\n            discover = TRUE, wizard = FALSE;\n            break;\n#ifdef NEWS\n        case 'n':\n            iflags.news = FALSE;\n            break;\n#endif\n        case 'u':\n            if (argv[0][2]) {\n                (void) strncpy(plname, argv[0] + 2, sizeof plname - 1);\n            } else if (argc > 1) {\n                argc--;\n                argv++;\n                (void) strncpy(plname, argv[0], sizeof plname - 1);\n            } else {\n                raw_print(\"Player name expected after -u\");\n            }\n            break;\n        case 'I':\n        case 'i':\n            if (!strncmpi(*argv, \"-IBMgraphics\", l)) {\n                load_symset(\"IBMGraphics\", PRIMARY);\n                load_symset(\"RogueIBM\", ROGUESET);\n                switch_symbols(TRUE);\n            } else {\n                raw_printf(\"Unknown option: %s\", *argv);\n            }\n            break;\n        case 'p': /* profession (role) */\n            if (argv[0][2]) {\n                if ((i = str2role(&argv[0][2])) >= 0)\n                    flags.initrole = i;\n            } else if (argc > 1) {\n                argc--;\n                argv++;\n                if ((i = str2role(argv[0])) >= 0)\n                    flags.initrole = i;\n            }\n            break;\n        case 'r': /* race */\n            if (argv[0][2]) {\n                if ((i = str2race(&argv[0][2])) >= 0)\n                    flags.initrace = i;\n            } else if (argc > 1) {\n                argc--;\n                argv++;\n                if ((i = str2race(argv[0])) >= 0)\n                    flags.initrace = i;\n            }\n            break;\n        case 'w': /* windowtype */\n            config_error_init(FALSE, \"command line\", FALSE);\n            choose_windows(&argv[0][2]);\n            config_error_done();\n            break;\n        case '@':\n            flags.randomall = 1;\n            break;\n        default:\n            if ((i = str2role(&argv[0][1])) >= 0) {\n                flags.initrole = i;\n                break;\n            }\n            /* else raw_printf(\"Unknown option: %s\", *argv); */\n        }\n    }\n\n#ifdef SYSCF\n    if (argc > 1)\n        raw_printf(\"MAXPLAYERS are set in sysconf file.\\n\");\n#else\n    /* XXX This is deprecated in favor of SYSCF with MAXPLAYERS */\n    if (argc > 1)\n        locknum = atoi(argv[1]);\n#endif\n#ifdef MAX_NR_OF_PLAYERS\n    /* limit to compile-time limit */\n    if (!locknum || locknum > MAX_NR_OF_PLAYERS)\n        locknum = MAX_NR_OF_PLAYERS;\n#endif\n#ifdef SYSCF\n    /* let syscf override compile-time limit */\n    if (!locknum || (sysopt.maxplayers && locknum > sysopt.maxplayers))\n        locknum = sysopt.maxplayers;\n#endif\n}\n\n#ifdef CHDIR\nstatic void\nchdirx(dir, wr)\nconst char *dir;\nboolean wr;\n{\n    if (dir /* User specified directory? */\n#ifdef HACKDIR\n        && strcmp(dir, HACKDIR) /* and not the default? */\n#endif\n        ) {\n#ifdef SECURE\n        (void) setgid(getgid());\n        (void) setuid(getuid()); /* Ron Wessels */\n#endif\n    } else {\n        /* non-default data files is a sign that scores may not be\n         * compatible, or perhaps that a binary not fitting this\n         * system's layout is being used.\n         */\n#ifdef VAR_PLAYGROUND\n        int len = strlen(VAR_PLAYGROUND);\n\n        fqn_prefix[SCOREPREFIX] = (char *) alloc(len + 2);\n        Strcpy(fqn_prefix[SCOREPREFIX], VAR_PLAYGROUND);\n        if (fqn_prefix[SCOREPREFIX][len - 1] != '/') {\n            fqn_prefix[SCOREPREFIX][len] = '/';\n            fqn_prefix[SCOREPREFIX][len + 1] = '\\0';\n        }\n#endif\n    }\n\n#ifdef HACKDIR\n    if (dir == (const char *) 0)\n        dir = HACKDIR;\n#endif\n\n    if (dir && chdir(dir) < 0) {\n        perror(dir);\n        error(\"Cannot chdir to %s.\", dir);\n    }\n\n    /* warn the player if we can't write the record file\n     * perhaps we should also test whether . is writable\n     * unfortunately the access system-call is worthless.\n     */\n    if (wr) {\n#ifdef VAR_PLAYGROUND\n        fqn_prefix[LEVELPREFIX] = fqn_prefix[SCOREPREFIX];\n        fqn_prefix[SAVEPREFIX] = fqn_prefix[SCOREPREFIX];\n        fqn_prefix[BONESPREFIX] = fqn_prefix[SCOREPREFIX];\n        fqn_prefix[LOCKPREFIX] = fqn_prefix[SCOREPREFIX];\n        fqn_prefix[TROUBLEPREFIX] = fqn_prefix[SCOREPREFIX];\n#endif\n        check_recordfile(dir);\n    }\n}\n#endif /* CHDIR */\n\n/* returns True iff we set plname[] to username which contains a hyphen */\nstatic boolean\nwhoami()\n{\n    /*\n     * Who am i? Algorithm: 1. Use name as specified in NETHACKOPTIONS\n     *                      2. Use $USER or $LOGNAME    (if 1. fails)\n     *                      3. Use getlogin()           (if 2. fails)\n     * The resulting name is overridden by command line options.\n     * If everything fails, or if the resulting name is some generic\n     * account like \"games\", \"play\", \"player\", \"hack\" then eventually\n     * we'll ask him.\n     * Note that we trust the user here; it is possible to play under\n     * somebody else's name.\n     */\n    if (!*plname) {\n        register const char *s;\n\n        s = nh_getenv(\"USER\");\n        if (!s || !*s)\n            s = nh_getenv(\"LOGNAME\");\n        if (!s || !*s)\n            s = getlogin();\n\n        if (s && *s) {\n            (void) strncpy(plname, s, sizeof plname - 1);\n            if (index(plname, '-'))\n                return TRUE;\n        }\n    }\n    return FALSE;\n}\n\nvoid\nsethanguphandler(handler)\nvoid FDECL((*handler), (int));\n{\n#ifdef SA_RESTART\n    /* don't want reads to restart.  If SA_RESTART is defined, we know\n     * sigaction exists and can be used to ensure reads won't restart.\n     * If it's not defined, assume reads do not restart.  If reads restart\n     * and a signal occurs, the game won't do anything until the read\n     * succeeds (or the stream returns EOF, which might not happen if\n     * reading from, say, a window manager). */\n    struct sigaction sact;\n\n    (void) memset((genericptr_t) &sact, 0, sizeof sact);\n    sact.sa_handler = (SIG_RET_TYPE) handler;\n    (void) sigaction(SIGHUP, &sact, (struct sigaction *) 0);\n#ifdef SIGXCPU\n    (void) sigaction(SIGXCPU, &sact, (struct sigaction *) 0);\n#endif\n#else /* !SA_RESTART */\n    (void) signal(SIGHUP, (SIG_RET_TYPE) handler);\n#ifdef SIGXCPU\n    (void) signal(SIGXCPU, (SIG_RET_TYPE) handler);\n#endif\n#endif /* ?SA_RESTART */\n}\n\n#ifdef PORT_HELP\nvoid\nport_help()\n{\n    /*\n     * Display unix-specific help.   Just show contents of the helpfile\n     * named by PORT_HELP.\n     */\n    display_file(PORT_HELP, TRUE);\n}\n#endif\n\n/* validate wizard mode if player has requested access to it */\nboolean\nauthorize_wizard_mode()\n{\n    struct passwd *pw = get_unix_pw();\n\n    if (pw && sysopt.wizards && sysopt.wizards[0]) {\n        if (check_user_string(sysopt.wizards))\n            return TRUE;\n    }\n    wiz_error_flag = TRUE; /* not being allowed into wizard mode */\n    return FALSE;\n}\n\nstatic void\nwd_message()\n{\n    if (wiz_error_flag) {\n        if (sysopt.wizards && sysopt.wizards[0]) {\n            char *tmp = build_english_list(sysopt.wizards);\n            pline(\"Only user%s %s may access debug (wizard) mode.\",\n                  index(sysopt.wizards, ' ') ? \"s\" : \"\", tmp);\n            free(tmp);\n        } else\n            pline(\"Entering explore/discovery mode instead.\");\n        wizard = 0, discover = 1; /* (paranoia) */\n    } else if (discover)\n        You(\"are in non-scoring explore/discovery mode.\");\n}\n\n/*\n * Add a slash to any name not ending in /. There must\n * be room for the /\n */\nvoid\nappend_slash(name)\nchar *name;\n{\n    char *ptr;\n\n    if (!*name)\n        return;\n    ptr = name + (strlen(name) - 1);\n    if (*ptr != '/') {\n        *++ptr = '/';\n        *++ptr = '\\0';\n    }\n    return;\n}\n\nboolean\ncheck_user_string(optstr)\nchar *optstr;\n{\n    struct passwd *pw;\n    int pwlen;\n    char *eop, *w;\n    char *pwname = 0;\n\n    if (optstr[0] == '*')\n        return TRUE; /* allow any user */\n    if (sysopt.check_plname)\n        pwname = plname;\n    else if ((pw = get_unix_pw()) != 0)\n        pwname = pw->pw_name;\n    if (!pwname || !*pwname)\n        return FALSE;\n    pwlen = (int) strlen(pwname);\n    eop = eos(optstr);\n    w = optstr;\n    while (w + pwlen <= eop) {\n        if (!*w)\n            break;\n        if (isspace(*w)) {\n            w++;\n            continue;\n        }\n        if (!strncmp(w, pwname, pwlen)) {\n            if (!w[pwlen] || isspace(w[pwlen]))\n                return TRUE;\n        }\n        while (*w && !isspace(*w))\n            w++;\n    }\n    return FALSE;\n}\n\nstatic struct passwd *\nget_unix_pw()\n{\n    char *user;\n    unsigned uid;\n    static struct passwd *pw = (struct passwd *) 0;\n\n    if (pw)\n        return pw; /* cache answer */\n\n    uid = (unsigned) getuid();\n    user = getlogin();\n    if (user) {\n        pw = getpwnam(user);\n        if (pw && ((unsigned) pw->pw_uid != uid))\n            pw = 0;\n    }\n    if (pw == 0) {\n        user = nh_getenv(\"USER\");\n        if (user) {\n            pw = getpwnam(user);\n            if (pw && ((unsigned) pw->pw_uid != uid))\n                pw = 0;\n        }\n        if (pw == 0) {\n            pw = getpwuid(uid);\n        }\n    }\n    return pw;\n}\n\nchar *\nget_login_name()\n{\n    static char buf[BUFSZ];\n    struct passwd *pw = get_unix_pw();\n\n    buf[0] = '\\0';\n    if (pw)\n        (void)strcpy(buf, pw->pw_name);\n\n    return buf;\n}\n\n#ifdef __APPLE__\nextern int errno;\n\nvoid\nport_insert_pastebuf(buf)\nchar *buf;\n{\n    /* This should be replaced when there is a Cocoa port. */\n    const char *errfmt;\n    size_t len;\n    FILE *PB = popen(\"/usr/bin/pbcopy\", \"w\");\n\n    if (!PB) {\n        errfmt = \"Unable to start pbcopy (%d)\\n\";\n        goto error;\n    }\n\n    len = strlen(buf);\n    /* Remove the trailing \\n, carefully. */\n    if (buf[len - 1] == '\\n')\n        len--;\n\n    /* XXX Sorry, I'm too lazy to write a loop for output this short. */\n    if (len != fwrite(buf, 1, len, PB)) {\n        errfmt = \"Error sending data to pbcopy (%d)\\n\";\n        goto error;\n    }\n\n    if (pclose(PB) != -1) {\n        return;\n    }\n    errfmt = \"Error finishing pbcopy (%d)\\n\";\n\n error:\n    raw_printf(errfmt, strerror(errno));\n}\n#endif /* __APPLE__ */\n\nunsigned long\nsys_random_seed()\n{\n    unsigned long seed = 0L;\n    unsigned long pid = (unsigned long) getpid();\n    boolean no_seed = TRUE;\n#ifdef DEV_RANDOM\n    FILE *fptr;\n\n    fptr = fopen(DEV_RANDOM, \"r\");\n    if (fptr) {\n        fread(&seed, sizeof (long), 1, fptr);\n        has_strong_rngseed = TRUE;  /* decl.c */\n        no_seed = FALSE;\n        (void) fclose(fptr);\n    } else {\n        /* leaves clue, doesn't exit */\n        paniclog(\"sys_random_seed\", \"falling back to weak seed\");\n    }\n#endif\n    if (no_seed) {\n        seed = (unsigned long) getnow(); /* time((TIME_type) 0) */\n        /* Quick dirty band-aid to prevent PRNG prediction */\n        if (pid) {\n            if (!(pid & 3L))\n                pid -= 1L;\n            seed *= pid;\n        }\n    }\n    return seed;\n}\n\n/*unixmain.c*/\n"], "fixing_code": ["$NHDT-Branch: NetHack-3.6 $:$NHDT-Revision: 1.3 $ $NHDT-Date: 1578996303 2020/01/14 10:05:03 $\n\nfixes36.5 contains a terse summary of changes made to 3.6.4 in order to\nproduce 3.6.5 as well as any post-release fixes in binaries.\n\n\nGeneral Fixes and Modified Features\n-----------------------------------\nfix accessing mons[-1] when trying to gate in a non-valid demon\nfix accessing mons[-1] when monster figures out if a tin cures stoning\nhave string_for_opt() return empty_optstr on failure\nensure existing callers of string_for_opt() check return value before using it\nfix potential buffer overflow in add_menu_coloring()\nfix potential buffer overflow in sym_val()\nfix potential buffer overflow in pline(), raw_printf(), and config_error_add()\n\tvia bad config file values or command line arguments\nfix potential buffer overflow in choose_windows()\n\n\nFixes to Post-3.6.4 Problems that Were Exposed Via git Repository\n------------------------------------------------------------------\n\n\nPlatform- and/or Interface-Specific Fixes or Features\n-----------------------------------------------------\nWindows OPTIONS=map_mode:fit_to_screen could cause a game start failure\n\n\nGeneral New Features\n--------------------\nnone\n\n", "/* NetHack 3.6\ttopten.c\t$NHDT-Date: 1450451497 2015/12/18 15:11:37 $  $NHDT-Branch: NetHack-3.6.0 $:$NHDT-Revision: 1.44 $ */\n/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */\n/*-Copyright (c) Robert Patrick Rankin, 2012. */\n/* NetHack may be freely redistributed.  See license for details. */\n\n#include \"hack.h\"\n#include \"dlb.h\"\n#ifdef SHORT_FILENAMES\n#include \"patchlev.h\"\n#else\n#include \"patchlevel.h\"\n#endif\n\n#ifdef VMS\n/* We don't want to rewrite the whole file, because that entails\n   creating a new version which requires that the old one be deletable. */\n#define UPDATE_RECORD_IN_PLACE\n#endif\n\n/*\n * Updating in place can leave junk at the end of the file in some\n * circumstances (if it shrinks and the O.S. doesn't have a straightforward\n * way to truncate it).  The trailing junk is harmless and the code\n * which reads the scores will ignore it.\n */\n#ifdef UPDATE_RECORD_IN_PLACE\nstatic long final_fpos;\n#endif\n\n#define done_stopprint program_state.stopprint\n\n#define newttentry() (struct toptenentry *) alloc(sizeof (struct toptenentry))\n#define dealloc_ttentry(ttent) free((genericptr_t) (ttent))\n#ifndef NAMSZ\n/* Changing NAMSZ can break your existing record/logfile */\n#define NAMSZ 10\n#endif\n#define DTHSZ 100\n#define ROLESZ 3\n\nstruct toptenentry {\n    struct toptenentry *tt_next;\n#ifdef UPDATE_RECORD_IN_PLACE\n    long fpos;\n#endif\n    long points;\n    int deathdnum, deathlev;\n    int maxlvl, hp, maxhp, deaths;\n    int ver_major, ver_minor, patchlevel;\n    long deathdate, birthdate;\n    int uid;\n    char plrole[ROLESZ + 1];\n    char plrace[ROLESZ + 1];\n    char plgend[ROLESZ + 1];\n    char plalign[ROLESZ + 1];\n    char name[NAMSZ + 1];\n    char death[DTHSZ + 1];\n} * tt_head;\n/* size big enough to read in all the string fields at once; includes\n   room for separating space or trailing newline plus string terminator */\n#define SCANBUFSZ (4 * (ROLESZ + 1) + (NAMSZ + 1) + (DTHSZ + 1) + 1)\n\nSTATIC_DCL void FDECL(topten_print, (const char *));\nSTATIC_DCL void FDECL(topten_print_bold, (const char *));\nSTATIC_DCL void NDECL(outheader);\nSTATIC_DCL void FDECL(outentry, (int, struct toptenentry *, BOOLEAN_P));\nSTATIC_DCL void FDECL(discardexcess, (FILE *));\nSTATIC_DCL void FDECL(readentry, (FILE *, struct toptenentry *));\nSTATIC_DCL void FDECL(writeentry, (FILE *, struct toptenentry *));\n#ifdef XLOGFILE\nSTATIC_DCL void FDECL(writexlentry, (FILE *, struct toptenentry *, int));\nSTATIC_DCL long NDECL(encodexlogflags);\nSTATIC_DCL long NDECL(encodeconduct);\nSTATIC_DCL long NDECL(encodeachieve);\n#endif\nSTATIC_DCL void FDECL(free_ttlist, (struct toptenentry *));\nSTATIC_DCL int FDECL(classmon, (char *, BOOLEAN_P));\nSTATIC_DCL int FDECL(score_wanted, (BOOLEAN_P, int, struct toptenentry *, int,\n                                    const char **, int));\n#ifdef NO_SCAN_BRACK\nSTATIC_DCL void FDECL(nsb_mung_line, (char *));\nSTATIC_DCL void FDECL(nsb_unmung_line, (char *));\n#endif\n\nstatic winid toptenwin = WIN_ERR;\n\n/* \"killed by\",&c [\"an\"] 'killer.name' */\nvoid\nformatkiller(buf, siz, how, incl_helpless)\nchar *buf;\nunsigned siz;\nint how;\nboolean incl_helpless;\n{\n    static NEARDATA const char *const killed_by_prefix[] = {\n        /* DIED, CHOKING, POISONING, STARVING, */\n        \"killed by \", \"choked on \", \"poisoned by \", \"died of \",\n        /* DROWNING, BURNING, DISSOLVED, CRUSHING, */\n        \"drowned in \", \"burned by \", \"dissolved in \", \"crushed to death by \",\n        /* STONING, TURNED_SLIME, GENOCIDED, */\n        \"petrified by \", \"turned to slime by \", \"killed by \",\n        /* PANICKED, TRICKED, QUIT, ESCAPED, ASCENDED */\n        \"\", \"\", \"\", \"\", \"\"\n    };\n    unsigned l;\n    char c, *kname = killer.name;\n\n    buf[0] = '\\0'; /* lint suppression */\n    switch (killer.format) {\n    default:\n        impossible(\"bad killer format? (%d)\", killer.format);\n        /*FALLTHRU*/\n    case NO_KILLER_PREFIX:\n        break;\n    case KILLED_BY_AN:\n        kname = an(kname);\n        /*FALLTHRU*/\n    case KILLED_BY:\n        (void) strncat(buf, killed_by_prefix[how], siz - 1);\n        l = strlen(buf);\n        buf += l, siz -= l;\n        break;\n    }\n    /* Copy kname into buf[].\n     * Object names and named fruit have already been sanitized, but\n     * monsters can have \"called 'arbitrary text'\" attached to them,\n     * so make sure that that text can't confuse field splitting when\n     * record, logfile, or xlogfile is re-read at some later point.\n     */\n    while (--siz > 0) {\n        c = *kname++;\n        if (!c)\n            break;\n        else if (c == ',')\n            c = ';';\n        /* 'xlogfile' doesn't really need protection for '=', but\n           fixrecord.awk for corrupted 3.6.0 'record' does (only\n           if using xlogfile rather than logfile to repair record) */\n        else if (c == '=')\n            c = '_';\n        /* tab is not possible due to use of mungspaces() when naming;\n           it would disrupt xlogfile parsing if it were present */\n        else if (c == '\\t')\n            c = ' ';\n        *buf++ = c;\n    }\n    *buf = '\\0';\n\n    if (incl_helpless && multi) {\n        /* X <= siz: 'sizeof \"string\"' includes 1 for '\\0' terminator */\n        if (multi_reason && strlen(multi_reason) + sizeof \", while \" <= siz)\n            Sprintf(buf, \", while %s\", multi_reason);\n        /* either multi_reason wasn't specified or wouldn't fit */\n        else if (sizeof \", while helpless\" <= siz)\n            Strcpy(buf, \", while helpless\");\n        /* else extra death info won't fit, so leave it out */\n    }\n}\n\nSTATIC_OVL void\ntopten_print(x)\nconst char *x;\n{\n    if (toptenwin == WIN_ERR)\n        raw_print(x);\n    else\n        putstr(toptenwin, ATR_NONE, x);\n}\n\nSTATIC_OVL void\ntopten_print_bold(x)\nconst char *x;\n{\n    if (toptenwin == WIN_ERR)\n        raw_print_bold(x);\n    else\n        putstr(toptenwin, ATR_BOLD, x);\n}\n\nint\nobservable_depth(lev)\nd_level *lev;\n{\n#if 0\n    /* if we ever randomize the order of the elemental planes, we\n       must use a constant external representation in the record file */\n    if (In_endgame(lev)) {\n        if (Is_astralevel(lev))\n            return -5;\n        else if (Is_waterlevel(lev))\n            return -4;\n        else if (Is_firelevel(lev))\n            return -3;\n        else if (Is_airlevel(lev))\n            return -2;\n        else if (Is_earthlevel(lev))\n            return -1;\n        else\n            return 0; /* ? */\n    } else\n#endif\n    return depth(lev);\n}\n\n/* throw away characters until current record has been entirely consumed */\nSTATIC_OVL void\ndiscardexcess(rfile)\nFILE *rfile;\n{\n    int c;\n\n    do {\n        c = fgetc(rfile);\n    } while (c != '\\n' && c != EOF);\n}\n\nSTATIC_OVL void\nreadentry(rfile, tt)\nFILE *rfile;\nstruct toptenentry *tt;\n{\n    char inbuf[SCANBUFSZ], s1[SCANBUFSZ], s2[SCANBUFSZ], s3[SCANBUFSZ],\n        s4[SCANBUFSZ], s5[SCANBUFSZ], s6[SCANBUFSZ];\n\n#ifdef NO_SCAN_BRACK /* Version_ Pts DgnLevs_ Hp___ Died__Born id */\n    static const char fmt[] = \"%d %d %d %ld %d %d %d %d %d %d %ld %ld %d%*c\";\n    static const char fmt32[] = \"%c%c %s %s%*c\";\n    static const char fmt33[] = \"%s %s %s %s %s %s%*c\";\n#else\n    static const char fmt[] = \"%d.%d.%d %ld %d %d %d %d %d %d %ld %ld %d \";\n    static const char fmt32[] = \"%c%c %[^,],%[^\\n]%*c\";\n    static const char fmt33[] = \"%s %s %s %s %[^,],%[^\\n]%*c\";\n#endif\n\n#ifdef UPDATE_RECORD_IN_PLACE\n    /* note: input below must read the record's terminating newline */\n    final_fpos = tt->fpos = ftell(rfile);\n#endif\n#define TTFIELDS 13\n    if (fscanf(rfile, fmt, &tt->ver_major, &tt->ver_minor, &tt->patchlevel,\n               &tt->points, &tt->deathdnum, &tt->deathlev, &tt->maxlvl,\n               &tt->hp, &tt->maxhp, &tt->deaths, &tt->deathdate,\n               &tt->birthdate, &tt->uid) != TTFIELDS) {\n#undef TTFIELDS\n        tt->points = 0;\n        discardexcess(rfile);\n    } else {\n        /* load remainder of record into a local buffer;\n           this imposes an implicit length limit of SCANBUFSZ\n           on every string field extracted from the buffer */\n        if (!fgets(inbuf, sizeof inbuf, rfile)) {\n            /* sscanf will fail and tt->points will be set to 0 */\n            *inbuf = '\\0';\n        } else if (!index(inbuf, '\\n')) {\n            Strcpy(&inbuf[sizeof inbuf - 2], \"\\n\");\n            discardexcess(rfile);\n        }\n        /* Check for backwards compatibility */\n        if (tt->ver_major < 3 || (tt->ver_major == 3 && tt->ver_minor < 3)) {\n            int i;\n\n            if (sscanf(inbuf, fmt32, tt->plrole, tt->plgend, s1, s2) == 4) {\n                tt->plrole[1] = tt->plgend[1] = '\\0'; /* read via %c */\n                copynchars(tt->name, s1, (int) (sizeof tt->name) - 1);\n                copynchars(tt->death, s2, (int) (sizeof tt->death) - 1);\n            } else\n                tt->points = 0;\n            tt->plrole[1] = '\\0';\n            if ((i = str2role(tt->plrole)) >= 0)\n                Strcpy(tt->plrole, roles[i].filecode);\n            Strcpy(tt->plrace, \"?\");\n            Strcpy(tt->plgend, (tt->plgend[0] == 'M') ? \"Mal\" : \"Fem\");\n            Strcpy(tt->plalign, \"?\");\n        } else if (sscanf(inbuf, fmt33, s1, s2, s3, s4, s5, s6) == 6) {\n            copynchars(tt->plrole, s1, (int) (sizeof tt->plrole) - 1);\n            copynchars(tt->plrace, s2, (int) (sizeof tt->plrace) - 1);\n            copynchars(tt->plgend, s3, (int) (sizeof tt->plgend) - 1);\n            copynchars(tt->plalign, s4, (int) (sizeof tt->plalign) - 1);\n            copynchars(tt->name, s5, (int) (sizeof tt->name) - 1);\n            copynchars(tt->death, s6, (int) (sizeof tt->death) - 1);\n        } else\n            tt->points = 0;\n#ifdef NO_SCAN_BRACK\n        if (tt->points > 0) {\n            nsb_unmung_line(tt->name);\n            nsb_unmung_line(tt->death);\n        }\n#endif\n    }\n\n    /* check old score entries for Y2K problem and fix whenever found */\n    if (tt->points > 0) {\n        if (tt->birthdate < 19000000L)\n            tt->birthdate += 19000000L;\n        if (tt->deathdate < 19000000L)\n            tt->deathdate += 19000000L;\n    }\n}\n\nSTATIC_OVL void\nwriteentry(rfile, tt)\nFILE *rfile;\nstruct toptenentry *tt;\n{\n    static const char fmt32[] = \"%c%c \";        /* role,gender */\n    static const char fmt33[] = \"%s %s %s %s \"; /* role,race,gndr,algn */\n#ifndef NO_SCAN_BRACK\n    static const char fmt0[] = \"%d.%d.%d %ld %d %d %d %d %d %d %ld %ld %d \";\n    static const char fmtX[] = \"%s,%s\\n\";\n#else /* NO_SCAN_BRACK */\n    static const char fmt0[] = \"%d %d %d %ld %d %d %d %d %d %d %ld %ld %d \";\n    static const char fmtX[] = \"%s %s\\n\";\n\n    nsb_mung_line(tt->name);\n    nsb_mung_line(tt->death);\n#endif\n\n    (void) fprintf(rfile, fmt0, tt->ver_major, tt->ver_minor, tt->patchlevel,\n                   tt->points, tt->deathdnum, tt->deathlev, tt->maxlvl,\n                   tt->hp, tt->maxhp, tt->deaths, tt->deathdate,\n                   tt->birthdate, tt->uid);\n    if (tt->ver_major < 3 || (tt->ver_major == 3 && tt->ver_minor < 3))\n        (void) fprintf(rfile, fmt32, tt->plrole[0], tt->plgend[0]);\n    else\n        (void) fprintf(rfile, fmt33, tt->plrole, tt->plrace, tt->plgend,\n                       tt->plalign);\n    (void) fprintf(rfile, fmtX, onlyspace(tt->name) ? \"_\" : tt->name,\n                   tt->death);\n\n#ifdef NO_SCAN_BRACK\n    nsb_unmung_line(tt->name);\n    nsb_unmung_line(tt->death);\n#endif\n}\n\n#ifdef XLOGFILE\n\n/* as tab is never used in eg. plname or death, no need to mangle those. */\nSTATIC_OVL void\nwritexlentry(rfile, tt, how)\nFILE *rfile;\nstruct toptenentry *tt;\nint how;\n{\n#define Fprintf (void) fprintf\n#define XLOG_SEP '\\t' /* xlogfile field separator. */\n    char buf[BUFSZ], tmpbuf[DTHSZ + 1];\n\n    Sprintf(buf, \"version=%d.%d.%d\", tt->ver_major, tt->ver_minor,\n            tt->patchlevel);\n    Sprintf(eos(buf), \"%cpoints=%ld%cdeathdnum=%d%cdeathlev=%d\", XLOG_SEP,\n            tt->points, XLOG_SEP, tt->deathdnum, XLOG_SEP, tt->deathlev);\n    Sprintf(eos(buf), \"%cmaxlvl=%d%chp=%d%cmaxhp=%d\", XLOG_SEP, tt->maxlvl,\n            XLOG_SEP, tt->hp, XLOG_SEP, tt->maxhp);\n    Sprintf(eos(buf), \"%cdeaths=%d%cdeathdate=%ld%cbirthdate=%ld%cuid=%d\",\n            XLOG_SEP, tt->deaths, XLOG_SEP, tt->deathdate, XLOG_SEP,\n            tt->birthdate, XLOG_SEP, tt->uid);\n    Fprintf(rfile, \"%s\", buf);\n    Sprintf(buf, \"%crole=%s%crace=%s%cgender=%s%calign=%s\", XLOG_SEP,\n            tt->plrole, XLOG_SEP, tt->plrace, XLOG_SEP, tt->plgend, XLOG_SEP,\n            tt->plalign);\n    /* make a copy of death reason that doesn't include \", while helpless\" */\n    formatkiller(tmpbuf, sizeof tmpbuf, how, FALSE);\n    Fprintf(rfile, \"%s%cname=%s%cdeath=%s\",\n            buf, /* (already includes separator) */\n            XLOG_SEP, plname, XLOG_SEP, tmpbuf);\n    if (multi)\n        Fprintf(rfile, \"%cwhile=%s\", XLOG_SEP,\n                multi_reason ? multi_reason : \"helpless\");\n    Fprintf(rfile, \"%cconduct=0x%lx%cturns=%ld%cachieve=0x%lx\", XLOG_SEP,\n            encodeconduct(), XLOG_SEP, moves, XLOG_SEP, encodeachieve());\n    Fprintf(rfile, \"%crealtime=%ld%cstarttime=%ld%cendtime=%ld\", XLOG_SEP,\n            (long) urealtime.realtime, XLOG_SEP,\n            (long) ubirthday, XLOG_SEP, (long) urealtime.finish_time);\n    Fprintf(rfile, \"%cgender0=%s%calign0=%s\", XLOG_SEP,\n            genders[flags.initgend].filecode, XLOG_SEP,\n            aligns[1 - u.ualignbase[A_ORIGINAL]].filecode);\n    Fprintf(rfile, \"%cflags=0x%lx\", XLOG_SEP, encodexlogflags());\n    Fprintf(rfile, \"\\n\");\n#undef XLOG_SEP\n}\n\nSTATIC_OVL long\nencodexlogflags()\n{\n    long e = 0L;\n\n    if (wizard)\n        e |= 1L << 0;\n    if (discover)\n        e |= 1L << 1;\n    if (!u.uroleplay.numbones)\n        e |= 1L << 2;\n\n    return e;\n}\n\nSTATIC_OVL long\nencodeconduct()\n{\n    long e = 0L;\n\n    if (!u.uconduct.food)\n        e |= 1L << 0;\n    if (!u.uconduct.unvegan)\n        e |= 1L << 1;\n    if (!u.uconduct.unvegetarian)\n        e |= 1L << 2;\n    if (!u.uconduct.gnostic)\n        e |= 1L << 3;\n    if (!u.uconduct.weaphit)\n        e |= 1L << 4;\n    if (!u.uconduct.killer)\n        e |= 1L << 5;\n    if (!u.uconduct.literate)\n        e |= 1L << 6;\n    if (!u.uconduct.polypiles)\n        e |= 1L << 7;\n    if (!u.uconduct.polyselfs)\n        e |= 1L << 8;\n    if (!u.uconduct.wishes)\n        e |= 1L << 9;\n    if (!u.uconduct.wisharti)\n        e |= 1L << 10;\n    if (!num_genocides())\n        e |= 1L << 11;\n\n    return e;\n}\n\nSTATIC_OVL long\nencodeachieve()\n{\n    long r = 0L;\n\n    if (u.uachieve.bell)\n        r |= 1L << 0;\n    if (u.uachieve.enter_gehennom)\n        r |= 1L << 1;\n    if (u.uachieve.menorah)\n        r |= 1L << 2;\n    if (u.uachieve.book)\n        r |= 1L << 3;\n    if (u.uevent.invoked)\n        r |= 1L << 4;\n    if (u.uachieve.amulet)\n        r |= 1L << 5;\n    if (In_endgame(&u.uz))\n        r |= 1L << 6;\n    if (Is_astralevel(&u.uz))\n        r |= 1L << 7;\n    if (u.uachieve.ascended)\n        r |= 1L << 8;\n    if (u.uachieve.mines_luckstone)\n        r |= 1L << 9;\n    if (u.uachieve.finish_sokoban)\n        r |= 1L << 10;\n    if (u.uachieve.killed_medusa)\n        r |= 1L << 11;\n    if (u.uroleplay.blind)\n        r |= 1L << 12;\n    if (u.uroleplay.nudist)\n        r |= 1L << 13;\n\n    return r;\n}\n\n#endif /* XLOGFILE */\n\nSTATIC_OVL void\nfree_ttlist(tt)\nstruct toptenentry *tt;\n{\n    struct toptenentry *ttnext;\n\n    while (tt->points > 0) {\n        ttnext = tt->tt_next;\n        dealloc_ttentry(tt);\n        tt = ttnext;\n    }\n    dealloc_ttentry(tt);\n}\n\nvoid\ntopten(how, when)\nint how;\ntime_t when;\n{\n    int uid = getuid();\n    int rank, rank0 = -1, rank1 = 0;\n    int occ_cnt = sysopt.persmax;\n    register struct toptenentry *t0, *tprev;\n    struct toptenentry *t1;\n    FILE *rfile;\n    register int flg = 0;\n    boolean t0_used;\n#ifdef LOGFILE\n    FILE *lfile;\n#endif /* LOGFILE */\n#ifdef XLOGFILE\n    FILE *xlfile;\n#endif /* XLOGFILE */\n\n#ifdef _DCC\n    /* Under DICE 3.0, this crashes the system consistently, apparently due to\n     * corruption of *rfile somewhere.  Until I figure this out, just cut out\n     * topten support entirely - at least then the game exits cleanly.  --AC\n     */\n    return;\n#endif\n\n    /* If we are in the midst of a panic, cut out topten entirely.\n     * topten uses alloc() several times, which will lead to\n     * problems if the panic was the result of an alloc() failure.\n     */\n    if (program_state.panicking)\n        return;\n\n    if (iflags.toptenwin) {\n        toptenwin = create_nhwindow(NHW_TEXT);\n    }\n\n#if defined(UNIX) || defined(VMS) || defined(__EMX__)\n#define HUP if (!program_state.done_hup)\n#else\n#define HUP\n#endif\n\n#ifdef TOS\n    restore_colors(); /* make sure the screen is black on white */\n#endif\n    /* create a new 'topten' entry */\n    t0_used = FALSE;\n    t0 = newttentry();\n    t0->ver_major = VERSION_MAJOR;\n    t0->ver_minor = VERSION_MINOR;\n    t0->patchlevel = PATCHLEVEL;\n    t0->points = u.urexp;\n    t0->deathdnum = u.uz.dnum;\n    /* deepest_lev_reached() is in terms of depth(), and reporting the\n     * deepest level reached in the dungeon death occurred in doesn't\n     * seem right, so we have to report the death level in depth() terms\n     * as well (which also seems reasonable since that's all the player\n     * sees on the screen anyway)\n     */\n    t0->deathlev = observable_depth(&u.uz);\n    t0->maxlvl = deepest_lev_reached(TRUE);\n    t0->hp = u.uhp;\n    t0->maxhp = u.uhpmax;\n    t0->deaths = u.umortality;\n    t0->uid = uid;\n    copynchars(t0->plrole, urole.filecode, ROLESZ);\n    copynchars(t0->plrace, urace.filecode, ROLESZ);\n    copynchars(t0->plgend, genders[flags.female].filecode, ROLESZ);\n    copynchars(t0->plalign, aligns[1 - u.ualign.type].filecode, ROLESZ);\n    copynchars(t0->name, plname, NAMSZ);\n    formatkiller(t0->death, sizeof t0->death, how, TRUE);\n    t0->birthdate = yyyymmdd(ubirthday);\n    t0->deathdate = yyyymmdd(when);\n    t0->tt_next = 0;\n#ifdef UPDATE_RECORD_IN_PLACE\n    t0->fpos = -1L;\n#endif\n\n#ifdef LOGFILE /* used for debugging (who dies of what, where) */\n    if (lock_file(LOGFILE, SCOREPREFIX, 10)) {\n        if (!(lfile = fopen_datafile(LOGFILE, \"a\", SCOREPREFIX))) {\n            HUP raw_print(\"Cannot open log file!\");\n        } else {\n            writeentry(lfile, t0);\n            (void) fclose(lfile);\n        }\n        unlock_file(LOGFILE);\n    }\n#endif /* LOGFILE */\n#ifdef XLOGFILE\n    if (lock_file(XLOGFILE, SCOREPREFIX, 10)) {\n        if (!(xlfile = fopen_datafile(XLOGFILE, \"a\", SCOREPREFIX))) {\n            HUP raw_print(\"Cannot open extended log file!\");\n        } else {\n            writexlentry(xlfile, t0, how);\n            (void) fclose(xlfile);\n        }\n        unlock_file(XLOGFILE);\n    }\n#endif /* XLOGFILE */\n\n    if (wizard || discover) {\n        if (how != PANICKED)\n            HUP {\n                char pbuf[BUFSZ];\n\n                topten_print(\"\");\n                Sprintf(pbuf,\n             \"Since you were in %s mode, the score list will not be checked.\",\n                        wizard ? \"wizard\" : \"discover\");\n                topten_print(pbuf);\n            }\n        goto showwin;\n    }\n\n    if (!lock_file(RECORD, SCOREPREFIX, 60))\n        goto destroywin;\n\n#ifdef UPDATE_RECORD_IN_PLACE\n    rfile = fopen_datafile(RECORD, \"r+\", SCOREPREFIX);\n#else\n    rfile = fopen_datafile(RECORD, \"r\", SCOREPREFIX);\n#endif\n\n    if (!rfile) {\n        HUP raw_print(\"Cannot open record file!\");\n        unlock_file(RECORD);\n        goto destroywin;\n    }\n\n    HUP topten_print(\"\");\n\n    /* assure minimum number of points */\n    if (t0->points < sysopt.pointsmin)\n        t0->points = 0;\n\n    t1 = tt_head = newttentry();\n    tprev = 0;\n    /* rank0: -1 undefined, 0 not_on_list, n n_th on list */\n    for (rank = 1;;) {\n        readentry(rfile, t1);\n        if (t1->points < sysopt.pointsmin)\n            t1->points = 0;\n        if (rank0 < 0 && t1->points < t0->points) {\n            rank0 = rank++;\n            if (tprev == 0)\n                tt_head = t0;\n            else\n                tprev->tt_next = t0;\n            t0->tt_next = t1;\n#ifdef UPDATE_RECORD_IN_PLACE\n            t0->fpos = t1->fpos; /* insert here */\n#endif\n            t0_used = TRUE;\n            occ_cnt--;\n            flg++; /* ask for a rewrite */\n        } else\n            tprev = t1;\n\n        if (t1->points == 0)\n            break;\n        if ((sysopt.pers_is_uid ? t1->uid == t0->uid\n                                : strncmp(t1->name, t0->name, NAMSZ) == 0)\n            && !strncmp(t1->plrole, t0->plrole, ROLESZ) && --occ_cnt <= 0) {\n            if (rank0 < 0) {\n                rank0 = 0;\n                rank1 = rank;\n                HUP {\n                    char pbuf[BUFSZ];\n\n                    Sprintf(pbuf,\n                        \"You didn't beat your previous score of %ld points.\",\n                            t1->points);\n                    topten_print(pbuf);\n                    topten_print(\"\");\n                }\n            }\n            if (occ_cnt < 0) {\n                flg++;\n                continue;\n            }\n        }\n        if (rank <= sysopt.entrymax) {\n            t1->tt_next = newttentry();\n            t1 = t1->tt_next;\n            rank++;\n        }\n        if (rank > sysopt.entrymax) {\n            t1->points = 0;\n            break;\n        }\n    }\n    if (flg) { /* rewrite record file */\n#ifdef UPDATE_RECORD_IN_PLACE\n        (void) fseek(rfile, (t0->fpos >= 0 ? t0->fpos : final_fpos),\n                     SEEK_SET);\n#else\n        (void) fclose(rfile);\n        if (!(rfile = fopen_datafile(RECORD, \"w\", SCOREPREFIX))) {\n            HUP raw_print(\"Cannot write record file\");\n            unlock_file(RECORD);\n            free_ttlist(tt_head);\n            goto destroywin;\n        }\n#endif /* UPDATE_RECORD_IN_PLACE */\n        if (!done_stopprint)\n            if (rank0 > 0) {\n                if (rank0 <= 10) {\n                    topten_print(\"You made the top ten list!\");\n                } else {\n                    char pbuf[BUFSZ];\n\n                    Sprintf(pbuf,\n                            \"You reached the %d%s place on the top %d list.\",\n                            rank0, ordin(rank0), sysopt.entrymax);\n                    topten_print(pbuf);\n                }\n                topten_print(\"\");\n            }\n    }\n    if (rank0 == 0)\n        rank0 = rank1;\n    if (rank0 <= 0)\n        rank0 = rank;\n    if (!done_stopprint)\n        outheader();\n    t1 = tt_head;\n    for (rank = 1; t1->points != 0; rank++, t1 = t1->tt_next) {\n        if (flg\n#ifdef UPDATE_RECORD_IN_PLACE\n            && rank >= rank0\n#endif\n            )\n            writeentry(rfile, t1);\n        if (done_stopprint)\n            continue;\n        if (rank > flags.end_top && (rank < rank0 - flags.end_around\n                                     || rank > rank0 + flags.end_around)\n            && (!flags.end_own\n                || (sysopt.pers_is_uid\n                        ? t1->uid == t0->uid\n                        : strncmp(t1->name, t0->name, NAMSZ) == 0)))\n            continue;\n        if (rank == rank0 - flags.end_around\n            && rank0 > flags.end_top + flags.end_around + 1 && !flags.end_own)\n            topten_print(\"\");\n        if (rank != rank0)\n            outentry(rank, t1, FALSE);\n        else if (!rank1)\n            outentry(rank, t1, TRUE);\n        else {\n            outentry(rank, t1, TRUE);\n            outentry(0, t0, TRUE);\n        }\n    }\n    if (rank0 >= rank)\n        if (!done_stopprint)\n            outentry(0, t0, TRUE);\n#ifdef UPDATE_RECORD_IN_PLACE\n    if (flg) {\n#ifdef TRUNCATE_FILE\n        /* if a reasonable way to truncate a file exists, use it */\n        truncate_file(rfile);\n#else\n        /* use sentinel record rather than relying on truncation */\n        t1->points = 0L; /* terminates file when read back in */\n        t1->ver_major = t1->ver_minor = t1->patchlevel = 0;\n        t1->uid = t1->deathdnum = t1->deathlev = 0;\n        t1->maxlvl = t1->hp = t1->maxhp = t1->deaths = 0;\n        t1->plrole[0] = t1->plrace[0] = t1->plgend[0] = t1->plalign[0] = '-';\n        t1->plrole[1] = t1->plrace[1] = t1->plgend[1] = t1->plalign[1] = 0;\n        t1->birthdate = t1->deathdate = yyyymmdd((time_t) 0L);\n        Strcpy(t1->name, \"@\");\n        Strcpy(t1->death, \"<eod>\\n\");\n        writeentry(rfile, t1);\n        (void) fflush(rfile);\n#endif /* TRUNCATE_FILE */\n    }\n#endif /* UPDATE_RECORD_IN_PLACE */\n    (void) fclose(rfile);\n    unlock_file(RECORD);\n    free_ttlist(tt_head);\n\nshowwin:\n    if (iflags.toptenwin && !done_stopprint)\n        display_nhwindow(toptenwin, 1);\ndestroywin:\n    if (!t0_used)\n        dealloc_ttentry(t0);\n    if (iflags.toptenwin) {\n        destroy_nhwindow(toptenwin);\n        toptenwin = WIN_ERR;\n    }\n}\n\nSTATIC_OVL void\noutheader()\n{\n    char linebuf[BUFSZ];\n    register char *bp;\n\n    Strcpy(linebuf, \" No  Points     Name\");\n    bp = eos(linebuf);\n    while (bp < linebuf + COLNO - 9)\n        *bp++ = ' ';\n    Strcpy(bp, \"Hp [max]\");\n    topten_print(linebuf);\n}\n\n/* so>0: standout line; so=0: ordinary line */\nSTATIC_OVL void\noutentry(rank, t1, so)\nstruct toptenentry *t1;\nint rank;\nboolean so;\n{\n    boolean second_line = TRUE;\n    char linebuf[BUFSZ];\n    char *bp, hpbuf[24], linebuf3[BUFSZ];\n    int hppos, lngr;\n\n    linebuf[0] = '\\0';\n    if (rank)\n        Sprintf(eos(linebuf), \"%3d\", rank);\n    else\n        Strcat(linebuf, \"   \");\n\n    Sprintf(eos(linebuf), \" %10ld  %.10s\", t1->points ? t1->points : u.urexp,\n            t1->name);\n    Sprintf(eos(linebuf), \"-%s\", t1->plrole);\n    if (t1->plrace[0] != '?')\n        Sprintf(eos(linebuf), \"-%s\", t1->plrace);\n    /* Printing of gender and alignment is intentional.  It has been\n     * part of the NetHack Geek Code, and illustrates a proper way to\n     * specify a character from the command line.\n     */\n    Sprintf(eos(linebuf), \"-%s\", t1->plgend);\n    if (t1->plalign[0] != '?')\n        Sprintf(eos(linebuf), \"-%s \", t1->plalign);\n    else\n        Strcat(linebuf, \" \");\n    if (!strncmp(\"escaped\", t1->death, 7)) {\n        Sprintf(eos(linebuf), \"escaped the dungeon %s[max level %d]\",\n                !strncmp(\" (\", t1->death + 7, 2) ? t1->death + 7 + 2 : \"\",\n                t1->maxlvl);\n        /* fixup for closing paren in \"escaped... with...Amulet)[max...\" */\n        if ((bp = index(linebuf, ')')) != 0)\n            *bp = (t1->deathdnum == astral_level.dnum) ? '\\0' : ' ';\n        second_line = FALSE;\n    } else if (!strncmp(\"ascended\", t1->death, 8)) {\n        Sprintf(eos(linebuf), \"ascended to demigod%s-hood\",\n                (t1->plgend[0] == 'F') ? \"dess\" : \"\");\n        second_line = FALSE;\n    } else {\n        if (!strncmp(t1->death, \"quit\", 4)) {\n            Strcat(linebuf, \"quit\");\n            second_line = FALSE;\n        } else if (!strncmp(t1->death, \"died of st\", 10)) {\n            Strcat(linebuf, \"starved to death\");\n            second_line = FALSE;\n        } else if (!strncmp(t1->death, \"choked\", 6)) {\n            Sprintf(eos(linebuf), \"choked on h%s food\",\n                    (t1->plgend[0] == 'F') ? \"er\" : \"is\");\n        } else if (!strncmp(t1->death, \"poisoned\", 8)) {\n            Strcat(linebuf, \"was poisoned\");\n        } else if (!strncmp(t1->death, \"crushed\", 7)) {\n            Strcat(linebuf, \"was crushed to death\");\n        } else if (!strncmp(t1->death, \"petrified by \", 13)) {\n            Strcat(linebuf, \"turned to stone\");\n        } else\n            Strcat(linebuf, \"died\");\n\n        if (t1->deathdnum == astral_level.dnum) {\n            const char *arg, *fmt = \" on the Plane of %s\";\n\n            switch (t1->deathlev) {\n            case -5:\n                fmt = \" on the %s Plane\";\n                arg = \"Astral\";\n                break;\n            case -4:\n                arg = \"Water\";\n                break;\n            case -3:\n                arg = \"Fire\";\n                break;\n            case -2:\n                arg = \"Air\";\n                break;\n            case -1:\n                arg = \"Earth\";\n                break;\n            default:\n                arg = \"Void\";\n                break;\n            }\n            Sprintf(eos(linebuf), fmt, arg);\n        } else {\n            Sprintf(eos(linebuf), \" in %s\", dungeons[t1->deathdnum].dname);\n            if (t1->deathdnum != knox_level.dnum)\n                Sprintf(eos(linebuf), \" on level %d\", t1->deathlev);\n            if (t1->deathlev != t1->maxlvl)\n                Sprintf(eos(linebuf), \" [max %d]\", t1->maxlvl);\n        }\n\n        /* kludge for \"quit while already on Charon's boat\" */\n        if (!strncmp(t1->death, \"quit \", 5))\n            Strcat(linebuf, t1->death + 4);\n    }\n    Strcat(linebuf, \".\");\n\n    /* Quit, starved, ascended, and escaped contain no second line */\n    if (second_line)\n        Sprintf(eos(linebuf), \"  %c%s.\", highc(*(t1->death)), t1->death + 1);\n\n    lngr = (int) strlen(linebuf);\n    if (t1->hp <= 0)\n        hpbuf[0] = '-', hpbuf[1] = '\\0';\n    else\n        Sprintf(hpbuf, \"%d\", t1->hp);\n    /* beginning of hp column after padding (not actually padded yet) */\n    hppos = COLNO - (sizeof(\"  Hp [max]\") - 1); /* sizeof(str) includes \\0 */\n    while (lngr >= hppos) {\n        for (bp = eos(linebuf); !(*bp == ' ' && (bp - linebuf < hppos)); bp--)\n            ;\n        /* special case: word is too long, wrap in the middle */\n        if (linebuf + 15 >= bp)\n            bp = linebuf + hppos - 1;\n        /* special case: if about to wrap in the middle of maximum\n           dungeon depth reached, wrap in front of it instead */\n        if (bp > linebuf + 5 && !strncmp(bp - 5, \" [max\", 5))\n            bp -= 5;\n        if (*bp != ' ')\n            Strcpy(linebuf3, bp);\n        else\n            Strcpy(linebuf3, bp + 1);\n        *bp = 0;\n        if (so) {\n            while (bp < linebuf + (COLNO - 1))\n                *bp++ = ' ';\n            *bp = 0;\n            topten_print_bold(linebuf);\n        } else\n            topten_print(linebuf);\n        Sprintf(linebuf, \"%15s %s\", \"\", linebuf3);\n        lngr = strlen(linebuf);\n    }\n    /* beginning of hp column not including padding */\n    hppos = COLNO - 7 - (int) strlen(hpbuf);\n    bp = eos(linebuf);\n\n    if (bp <= linebuf + hppos) {\n        /* pad any necessary blanks to the hit point entry */\n        while (bp < linebuf + hppos)\n            *bp++ = ' ';\n        Strcpy(bp, hpbuf);\n        Sprintf(eos(bp), \" %s[%d]\",\n                (t1->maxhp < 10) ? \"  \" : (t1->maxhp < 100) ? \" \" : \"\",\n                t1->maxhp);\n    }\n\n    if (so) {\n        bp = eos(linebuf);\n        if (so >= COLNO)\n            so = COLNO - 1;\n        while (bp < linebuf + so)\n            *bp++ = ' ';\n        *bp = 0;\n        topten_print_bold(linebuf);\n    } else\n        topten_print(linebuf);\n}\n\nSTATIC_OVL int\nscore_wanted(current_ver, rank, t1, playerct, players, uid)\nboolean current_ver;\nint rank;\nstruct toptenentry *t1;\nint playerct;\nconst char **players;\nint uid;\n{\n    int i;\n\n    if (current_ver\n        && (t1->ver_major != VERSION_MAJOR || t1->ver_minor != VERSION_MINOR\n            || t1->patchlevel != PATCHLEVEL))\n        return 0;\n\n    if (sysopt.pers_is_uid && !playerct && t1->uid == uid)\n        return 1;\n\n    for (i = 0; i < playerct; i++) {\n        if (players[i][0] == '-' && index(\"pr\", players[i][1])\n            && players[i][2] == 0 && i + 1 < playerct) {\n            const char *arg = players[i + 1];\n            if ((players[i][1] == 'p'\n                 && str2role(arg) == str2role(t1->plrole))\n                || (players[i][1] == 'r'\n                    && str2race(arg) == str2race(t1->plrace)))\n                return 1;\n            i++;\n        } else if (strcmp(players[i], \"all\") == 0\n                   || strncmp(t1->name, players[i], NAMSZ) == 0\n                   || (players[i][0] == '-' && players[i][1] == t1->plrole[0]\n                       && players[i][2] == 0)\n                   || (digit(players[i][0]) && rank <= atoi(players[i])))\n            return 1;\n    }\n    return 0;\n}\n\n/*\n * print selected parts of score list.\n * argc >= 2, with argv[0] untrustworthy (directory names, et al.),\n * and argv[1] starting with \"-s\".\n * caveat: some shells might allow argv elements to be arbitrarily long.\n */\nvoid\nprscore(argc, argv)\nint argc;\nchar **argv;\n{\n    const char **players;\n    int playerct, rank;\n    boolean current_ver = TRUE, init_done = FALSE;\n    register struct toptenentry *t1;\n    FILE *rfile;\n    boolean match_found = FALSE;\n    register int i;\n    char pbuf[BUFSZ];\n    int uid = -1;\n    const char *player0;\n\n    if (argc < 2 || strncmp(argv[1], \"-s\", 2)) {\n        raw_printf(\"prscore: bad arguments (%d)\", argc);\n        return;\n    }\n\n    rfile = fopen_datafile(RECORD, \"r\", SCOREPREFIX);\n    if (!rfile) {\n        raw_print(\"Cannot open record file!\");\n        return;\n    }\n\n#ifdef AMIGA\n    {\n        extern winid amii_rawprwin;\n\n        init_nhwindows(&argc, argv);\n        amii_rawprwin = create_nhwindow(NHW_TEXT);\n    }\n#endif\n\n    /* If the score list isn't after a game, we never went through\n     * initialization. */\n    if (wiz1_level.dlevel == 0) {\n        dlb_init();\n        init_dungeons();\n        init_done = TRUE;\n    }\n\n    if (!argv[1][2]) { /* plain \"-s\" */\n        argc--;\n        argv++;\n    } else\n        argv[1] += 2;\n\n    if (argc > 1 && !strcmp(argv[1], \"-v\")) {\n        current_ver = FALSE;\n        argc--;\n        argv++;\n    }\n\n    if (argc <= 1) {\n        if (sysopt.pers_is_uid) {\n            uid = getuid();\n            playerct = 0;\n            players = (const char **) 0;\n        } else {\n            player0 = plname;\n            if (!*player0)\n#ifdef AMIGA\n                player0 = \"all\"; /* single user system */\n#else\n                player0 = \"hackplayer\";\n#endif\n            playerct = 1;\n            players = &player0;\n        }\n    } else {\n        playerct = --argc;\n        players = (const char **) ++argv;\n    }\n    raw_print(\"\");\n\n    t1 = tt_head = newttentry();\n    for (rank = 1;; rank++) {\n        readentry(rfile, t1);\n        if (t1->points == 0)\n            break;\n        if (!match_found\n            && score_wanted(current_ver, rank, t1, playerct, players, uid))\n            match_found = TRUE;\n        t1->tt_next = newttentry();\n        t1 = t1->tt_next;\n    }\n\n    (void) fclose(rfile);\n    if (init_done) {\n        free_dungeons();\n        dlb_cleanup();\n    }\n\n    if (match_found) {\n        outheader();\n        t1 = tt_head;\n        for (rank = 1; t1->points != 0; rank++, t1 = t1->tt_next) {\n            if (score_wanted(current_ver, rank, t1, playerct, players, uid))\n                (void) outentry(rank, t1, FALSE);\n        }\n    } else {\n        Sprintf(pbuf, \"Cannot find any %sentries for \",\n                current_ver ? \"current \" : \"\");\n        if (playerct < 1)\n            Strcat(pbuf, \"you.\");\n        else {\n            if (playerct > 1)\n                Strcat(pbuf, \"any of \");\n            for (i = 0; i < playerct; i++) {\n                /* stop printing players if there are too many to fit */\n                if (strlen(pbuf) + strlen(players[i]) + 2 >= BUFSZ) {\n                    if (strlen(pbuf) < BUFSZ - 4)\n                        Strcat(pbuf, \"...\");\n                    else\n                        Strcpy(pbuf + strlen(pbuf) - 4, \"...\");\n                    break;\n                }\n                Strcat(pbuf, players[i]);\n                if (i < playerct - 1) {\n                    if (players[i][0] == '-' && index(\"pr\", players[i][1])\n                        && players[i][2] == 0)\n                        Strcat(pbuf, \" \");\n                    else\n                        Strcat(pbuf, \":\");\n                }\n            }\n        }\n        raw_print(pbuf);\n        raw_printf(\"Usage: %s -s [-v] <playertypes> [maxrank] [playernames]\",\n\n                   hname);\n        raw_printf(\"Player types are: [-p role] [-r race]\");\n    }\n    free_ttlist(tt_head);\n#ifdef AMIGA\n    {\n        extern winid amii_rawprwin;\n\n        display_nhwindow(amii_rawprwin, 1);\n        destroy_nhwindow(amii_rawprwin);\n        amii_rawprwin = WIN_ERR;\n    }\n#endif\n}\n\nSTATIC_OVL int\nclassmon(plch, fem)\nchar *plch;\nboolean fem;\n{\n    int i;\n\n    /* Look for this role in the role table */\n    for (i = 0; roles[i].name.m; i++)\n        if (!strncmp(plch, roles[i].filecode, ROLESZ)) {\n            if (fem && roles[i].femalenum != NON_PM)\n                return roles[i].femalenum;\n            else if (roles[i].malenum != NON_PM)\n                return roles[i].malenum;\n            else\n                return PM_HUMAN;\n        }\n    /* this might be from a 3.2.x score for former Elf class */\n    if (!strcmp(plch, \"E\"))\n        return PM_RANGER;\n\n    impossible(\"What weird role is this? (%s)\", plch);\n    return  PM_HUMAN_MUMMY;\n}\n\n/*\n * Get a random player name and class from the high score list,\n */\nstruct toptenentry *\nget_rnd_toptenentry()\n{\n    int rank, i;\n    FILE *rfile;\n    register struct toptenentry *tt;\n    static struct toptenentry tt_buf;\n\n    rfile = fopen_datafile(RECORD, \"r\", SCOREPREFIX);\n    if (!rfile) {\n        impossible(\"Cannot open record file!\");\n        return NULL;\n    }\n\n    tt = &tt_buf;\n    rank = rnd(sysopt.tt_oname_maxrank);\npickentry:\n    for (i = rank; i; i--) {\n        readentry(rfile, tt);\n        if (tt->points == 0)\n            break;\n    }\n\n    if (tt->points == 0) {\n        if (rank > 1) {\n            rank = 1;\n            rewind(rfile);\n            goto pickentry;\n        }\n        tt = NULL;\n    }\n\n    (void) fclose(rfile);\n    return tt;\n}\n\n\n/*\n * Attach random player name and class from high score list\n * to an object (for statues or morgue corpses).\n */\nstruct obj *\ntt_oname(otmp)\nstruct obj *otmp;\n{\n    struct toptenentry *tt;\n    if (!otmp)\n        return (struct obj *) 0;\n\n    tt = get_rnd_toptenentry();\n\n    if (!tt)\n        return (struct obj *) 0;\n\n    set_corpsenm(otmp, classmon(tt->plrole, (tt->plgend[0] == 'F')));\n    otmp = oname(otmp, tt->name);\n\n    return otmp;\n}\n\n#ifdef NO_SCAN_BRACK\n/* Lattice scanf isn't up to reading the scorefile.  What */\n/* follows deals with that; I admit it's ugly. (KL) */\n/* Now generally available (KL) */\nSTATIC_OVL void\nnsb_mung_line(p)\nchar *p;\n{\n    while ((p = index(p, ' ')) != 0)\n        *p = '|';\n}\n\nSTATIC_OVL void\nnsb_unmung_line(p)\nchar *p;\n{\n    while ((p = index(p, '|')) != 0)\n        *p = ' ';\n}\n#endif /* NO_SCAN_BRACK */\n\n/*topten.c*/\n", "/* NetHack 3.6\twindows.c\t$NHDT-Date: 1575245096 2019/12/02 00:04:56 $  $NHDT-Branch: NetHack-3.6 $:$NHDT-Revision: 1.60 $ */\n/* Copyright (c) D. Cohrs, 1993. */\n/* NetHack may be freely redistributed.  See license for details. */\n\n#include \"hack.h\"\n#ifdef TTY_GRAPHICS\n#include \"wintty.h\"\n#endif\n#ifdef CURSES_GRAPHICS\nextern struct window_procs curses_procs;\n#endif\n#ifdef X11_GRAPHICS\n/* Cannot just blindly include winX.h without including all of X11 stuff\n   and must get the order of include files right.  Don't bother. */\nextern struct window_procs X11_procs;\nextern void FDECL(win_X11_init, (int));\n#endif\n#ifdef QT_GRAPHICS\nextern struct window_procs Qt_procs;\n#endif\n#ifdef GEM_GRAPHICS\n#include \"wingem.h\"\n#endif\n#ifdef MAC\nextern struct window_procs mac_procs;\n#endif\n#ifdef BEOS_GRAPHICS\nextern struct window_procs beos_procs;\nextern void FDECL(be_win_init, (int));\nFAIL /* be_win_init doesn't exist? XXX*/\n#endif\n#ifdef AMIGA_INTUITION\nextern struct window_procs amii_procs;\nextern struct window_procs amiv_procs;\nextern void FDECL(ami_wininit_data, (int));\n#endif\n#ifdef WIN32_GRAPHICS\nextern struct window_procs win32_procs;\n#endif\n#ifdef GNOME_GRAPHICS\n#include \"winGnome.h\"\nextern struct window_procs Gnome_procs;\n#endif\n#ifdef MSWIN_GRAPHICS\nextern struct window_procs mswin_procs;\n#endif\n#ifdef WINCHAIN\nextern struct window_procs chainin_procs;\nextern void FDECL(chainin_procs_init, (int));\nextern void *FDECL(chainin_procs_chain, (int, int, void *, void *, void *));\n\nextern struct chain_procs chainout_procs;\nextern void FDECL(chainout_procs_init, (int));\nextern void *FDECL(chainout_procs_chain, (int, int, void *, void *, void *));\n\nextern struct chain_procs trace_procs;\nextern void FDECL(trace_procs_init, (int));\nextern void *FDECL(trace_procs_chain, (int, int, void *, void *, void *));\n#endif\n\nSTATIC_DCL void FDECL(def_raw_print, (const char *s));\nSTATIC_DCL void NDECL(def_wait_synch);\n\n#ifdef DUMPLOG\nSTATIC_DCL winid FDECL(dump_create_nhwindow, (int));\nSTATIC_DCL void FDECL(dump_clear_nhwindow, (winid));\nSTATIC_DCL void FDECL(dump_display_nhwindow, (winid, BOOLEAN_P));\nSTATIC_DCL void FDECL(dump_destroy_nhwindow, (winid));\nSTATIC_DCL void FDECL(dump_start_menu, (winid));\nSTATIC_DCL void FDECL(dump_add_menu, (winid, int, const ANY_P *, CHAR_P,\n                                      CHAR_P, int, const char *, BOOLEAN_P));\nSTATIC_DCL void FDECL(dump_end_menu, (winid, const char *));\nSTATIC_DCL int FDECL(dump_select_menu, (winid, int, MENU_ITEM_P **));\nSTATIC_DCL void FDECL(dump_putstr, (winid, int, const char *));\n#endif /* DUMPLOG */\n\n#ifdef HANGUPHANDLING\nvolatile\n#endif\n    NEARDATA struct window_procs windowprocs;\n\n#ifdef WINCHAIN\n#define CHAINR(x) , x\n#else\n#define CHAINR(x)\n#endif\n\nstatic struct win_choices {\n    struct window_procs *procs;\n    void FDECL((*ini_routine), (int)); /* optional (can be 0) */\n#ifdef WINCHAIN\n    void *FDECL((*chain_routine), (int, int, void *, void *, void *));\n#endif\n} winchoices[] = {\n#ifdef TTY_GRAPHICS\n    { &tty_procs, win_tty_init CHAINR(0) },\n#endif\n#ifdef CURSES_GRAPHICS\n    { &curses_procs, 0 },\n#endif\n#ifdef X11_GRAPHICS\n    { &X11_procs, win_X11_init CHAINR(0) },\n#endif\n#ifdef QT_GRAPHICS\n    { &Qt_procs, 0 CHAINR(0) },\n#endif\n#ifdef GEM_GRAPHICS\n    { &Gem_procs, win_Gem_init CHAINR(0) },\n#endif\n#ifdef MAC\n    { &mac_procs, 0 CHAINR(0) },\n#endif\n#ifdef BEOS_GRAPHICS\n    { &beos_procs, be_win_init CHAINR(0) },\n#endif\n#ifdef AMIGA_INTUITION\n    { &amii_procs,\n      ami_wininit_data CHAINR(0) }, /* Old font version of the game */\n    { &amiv_procs,\n      ami_wininit_data CHAINR(0) }, /* Tile version of the game */\n#endif\n#ifdef WIN32_GRAPHICS\n    { &win32_procs, 0 CHAINR(0) },\n#endif\n#ifdef GNOME_GRAPHICS\n    { &Gnome_procs, 0 CHAINR(0) },\n#endif\n#ifdef MSWIN_GRAPHICS\n    { &mswin_procs, 0 CHAINR(0) },\n#endif\n#ifdef WINCHAIN\n    { &chainin_procs, chainin_procs_init, chainin_procs_chain },\n    { (struct window_procs *) &chainout_procs, chainout_procs_init,\n      chainout_procs_chain },\n\n    { (struct window_procs *) &trace_procs, trace_procs_init,\n      trace_procs_chain },\n#endif\n    { 0, 0 CHAINR(0) } /* must be last */\n};\n\n#ifdef WINCHAIN\nstruct winlink {\n    struct winlink *nextlink;\n    struct win_choices *wincp;\n    void *linkdata;\n};\n/* NB: this chain does not contain the terminal real window system pointer */\n\nstatic struct winlink *chain = 0;\n\nstatic struct winlink *\nwl_new()\n{\n    struct winlink *wl = (struct winlink *) alloc(sizeof *wl);\n\n    wl->nextlink = 0;\n    wl->wincp = 0;\n    wl->linkdata = 0;\n\n    return wl;\n}\n\nstatic void\nwl_addhead(struct winlink *wl)\n{\n    wl->nextlink = chain;\n    chain = wl;\n}\n\nstatic void\nwl_addtail(struct winlink *wl)\n{\n    struct winlink *p = chain;\n\n    if (!chain) {\n        chain = wl;\n        return;\n    }\n    while (p->nextlink) {\n        p = p->nextlink;\n    }\n    p->nextlink = wl;\n    return;\n}\n#endif /* WINCHAIN */\n\nstatic struct win_choices *last_winchoice = 0;\n\nboolean\ngenl_can_suspend_no(VOID_ARGS)\n{\n    return FALSE;\n}\n\nboolean\ngenl_can_suspend_yes(VOID_ARGS)\n{\n    return TRUE;\n}\n\nSTATIC_OVL\nvoid\ndef_raw_print(s)\nconst char *s;\n{\n    puts(s);\n}\n\nSTATIC_OVL\nvoid\ndef_wait_synch(VOID_ARGS)\n{\n    /* Config file error handling routines\n     * call wait_sync() without checking to\n     * see if it actually has a value,\n     * leading to spectacular violations\n     * when you try to execute address zero.\n     * The existence of this allows early\n     * processing to have something to execute\n     * even though it essentially does nothing\n     */\n     return;\n}\n\n#ifdef WINCHAIN\nstatic struct win_choices *\nwin_choices_find(s)\nconst char *s;\n{\n    register int i;\n\n    for (i = 0; winchoices[i].procs; i++) {\n        if (!strcmpi(s, winchoices[i].procs->name)) {\n            return &winchoices[i];\n        }\n    }\n    return (struct win_choices *) 0;\n}\n#endif\n\nvoid\nchoose_windows(s)\nconst char *s;\n{\n    int i;\n    char *tmps = 0;\n\n    for (i = 0; winchoices[i].procs; i++) {\n        if ('+' == winchoices[i].procs->name[0])\n            continue;\n        if ('-' == winchoices[i].procs->name[0])\n            continue;\n        if (!strcmpi(s, winchoices[i].procs->name)) {\n            windowprocs = *winchoices[i].procs;\n\n            if (last_winchoice && last_winchoice->ini_routine)\n                (*last_winchoice->ini_routine)(WININIT_UNDO);\n            if (winchoices[i].ini_routine)\n                (*winchoices[i].ini_routine)(WININIT);\n            last_winchoice = &winchoices[i];\n            return;\n        }\n    }\n\n    if (!windowprocs.win_raw_print)\n        windowprocs.win_raw_print = def_raw_print;\n    if (!windowprocs.win_wait_synch)\n        /* early config file error processing routines call this */\n        windowprocs.win_wait_synch = def_wait_synch;\n\n    if (!winchoices[0].procs) {\n        raw_printf(\"No window types supported?\");\n        nh_terminate(EXIT_FAILURE);\n    }\n    /* 50: arbitrary, no real window_type names are anywhere near that long;\n       used to prevent potential raw_printf() overflow if user supplies a\n       very long string (on the order of 1200 chars) on the command line\n       (config file options can't get that big; they're truncated at 1023) */\n#define WINDOW_TYPE_MAXLEN 50\n    if (strlen(s) >= WINDOW_TYPE_MAXLEN) {\n        tmps = (char *) alloc(WINDOW_TYPE_MAXLEN);\n        (void) strncpy(tmps, s, WINDOW_TYPE_MAXLEN - 1);\n        tmps[WINDOW_TYPE_MAXLEN - 1] = '\\0';\n        s = tmps;\n    }\n#undef WINDOW_TYPE_MAXLEN\n\n    if (!winchoices[1].procs) {\n        config_error_add(\n                     \"Window type %s not recognized.  The only choice is: %s\",\n                         s, winchoices[0].procs->name);\n    } else {\n        char buf[BUFSZ];\n        boolean first = TRUE;\n\n        buf[0] = '\\0';\n        for (i = 0; winchoices[i].procs; i++) {\n            if ('+' == winchoices[i].procs->name[0])\n                continue;\n            if ('-' == winchoices[i].procs->name[0])\n                continue;\n            Sprintf(eos(buf), \"%s%s\",\n                    first ? \"\" : \", \", winchoices[i].procs->name);\n            first = FALSE;\n        }\n        config_error_add(\"Window type %s not recognized.  Choices are:  %s\",\n                         s, buf);\n    }\n    if (tmps)\n        free((genericptr_t) tmps) /*, tmps = 0*/ ;\n\n    if (windowprocs.win_raw_print == def_raw_print\n            || WINDOWPORT(\"safe-startup\"))\n        nh_terminate(EXIT_SUCCESS);\n}\n\n#ifdef WINCHAIN\nvoid\naddto_windowchain(s)\nconst char *s;\n{\n    register int i;\n\n    for (i = 0; winchoices[i].procs; i++) {\n        if ('+' != winchoices[i].procs->name[0])\n            continue;\n        if (!strcmpi(s, winchoices[i].procs->name)) {\n            struct winlink *p = wl_new();\n\n            p->wincp = &winchoices[i];\n            wl_addtail(p);\n            /* NB: The ini_routine() will be called during commit. */\n            return;\n        }\n    }\n\n    windowprocs.win_raw_print = def_raw_print;\n\n    raw_printf(\"Window processor %s not recognized.  Choices are:\", s);\n    for (i = 0; winchoices[i].procs; i++) {\n        if ('+' != winchoices[i].procs->name[0])\n            continue;\n        raw_printf(\"        %s\", winchoices[i].procs->name);\n    }\n\n    nh_terminate(EXIT_FAILURE);\n}\n\nvoid\ncommit_windowchain()\n{\n    struct winlink *p;\n    int n;\n    int wincap, wincap2;\n\n    if (!chain)\n        return;\n\n    /* Save wincap* from the real window system - we'll restore it below. */\n    wincap = windowprocs.wincap;\n    wincap2 = windowprocs.wincap2;\n\n    /* add -chainin at head and -chainout at tail */\n    p = wl_new();\n    p->wincp = win_choices_find(\"-chainin\");\n    if (!p->wincp) {\n        raw_printf(\"Can't locate processor '-chainin'\");\n        exit(EXIT_FAILURE);\n    }\n    wl_addhead(p);\n\n    p = wl_new();\n    p->wincp = win_choices_find(\"-chainout\");\n    if (!p->wincp) {\n        raw_printf(\"Can't locate processor '-chainout'\");\n        exit(EXIT_FAILURE);\n    }\n    wl_addtail(p);\n\n    /* Now alloc() init() similar to Objective-C. */\n    for (n = 1, p = chain; p; n++, p = p->nextlink) {\n        p->linkdata = (*p->wincp->chain_routine)(WINCHAIN_ALLOC, n, 0, 0, 0);\n    }\n\n    for (n = 1, p = chain; p; n++, p = p->nextlink) {\n        if (p->nextlink) {\n            (void) (*p->wincp->chain_routine)(WINCHAIN_INIT, n, p->linkdata,\n                                              p->nextlink->wincp->procs,\n                                              p->nextlink->linkdata);\n        } else {\n            (void) (*p->wincp->chain_routine)(WINCHAIN_INIT, n, p->linkdata,\n                                              last_winchoice->procs, 0);\n        }\n    }\n\n    /* Restore the saved wincap* values.  We do it here to give the\n     * ini_routine()s a chance to change or check them. */\n    chain->wincp->procs->wincap = wincap;\n    chain->wincp->procs->wincap2 = wincap2;\n\n    /* Call the init procs.  Do not re-init the terminal real win. */\n    p = chain;\n    while (p->nextlink) {\n        if (p->wincp->ini_routine) {\n            (*p->wincp->ini_routine)(WININIT);\n        }\n        p = p->nextlink;\n    }\n\n    /* Install the chain into window procs very late so ini_routine()s\n     * can raw_print on error. */\n    windowprocs = *chain->wincp->procs;\n\n    p = chain;\n    while (p) {\n        struct winlink *np = p->nextlink;\n        free(p);\n        p = np; /* assignment, not proof */\n    }\n}\n#endif /* WINCHAIN */\n\n/*\n * tty_message_menu() provides a means to get feedback from the\n * --More-- prompt; other interfaces generally don't need that.\n */\n/*ARGSUSED*/\nchar\ngenl_message_menu(let, how, mesg)\nchar let UNUSED;\nint how UNUSED;\nconst char *mesg;\n{\n    pline(\"%s\", mesg);\n    return 0;\n}\n\n/*ARGSUSED*/\nvoid\ngenl_preference_update(pref)\nconst char *pref UNUSED;\n{\n    /* window ports are expected to provide\n       their own preference update routine\n       for the preference capabilities that\n       they support.\n       Just return in this genl one. */\n    return;\n}\n\nchar *\ngenl_getmsghistory(init)\nboolean init UNUSED;\n{\n    /* window ports can provide\n       their own getmsghistory() routine to\n       preserve message history between games.\n       The routine is called repeatedly from\n       the core save routine, and the window\n       port is expected to successively return\n       each message that it wants saved, starting\n       with the oldest message first, finishing\n       with the most recent.\n       Return null pointer when finished.\n     */\n    return (char *) 0;\n}\n\nvoid\ngenl_putmsghistory(msg, is_restoring)\nconst char *msg;\nboolean is_restoring;\n{\n    /* window ports can provide\n       their own putmsghistory() routine to\n       load message history from a saved game.\n       The routine is called repeatedly from\n       the core restore routine, starting with\n       the oldest saved message first, and\n       finishing with the latest.\n       The window port routine is expected to\n       load the message recall buffers in such\n       a way that the ordering is preserved.\n       The window port routine should make no\n       assumptions about how many messages are\n       forthcoming, nor should it assume that\n       another message will follow this one,\n       so it should keep all pointers/indexes\n       intact at the end of each call.\n    */\n\n    /* this doesn't provide for reloading the message window with the\n       previous session's messages upon restore, but it does put the quest\n       message summary lines there by treating them as ordinary messages */\n    if (!is_restoring)\n        pline(\"%s\", msg);\n    return;\n}\n\n#ifdef HANGUPHANDLING\n/*\n * Dummy windowing scheme used to replace current one with no-ops\n * in order to avoid all terminal I/O after hangup/disconnect.\n */\n\nstatic int NDECL(hup_nhgetch);\nstatic char FDECL(hup_yn_function, (const char *, const char *, CHAR_P));\nstatic int FDECL(hup_nh_poskey, (int *, int *, int *));\nstatic void FDECL(hup_getlin, (const char *, char *));\nstatic void FDECL(hup_init_nhwindows, (int *, char **));\nstatic void FDECL(hup_exit_nhwindows, (const char *));\nstatic winid FDECL(hup_create_nhwindow, (int));\nstatic int FDECL(hup_select_menu, (winid, int, MENU_ITEM_P **));\nstatic void FDECL(hup_add_menu, (winid, int, const anything *, CHAR_P, CHAR_P,\n                                 int, const char *, BOOLEAN_P));\nstatic void FDECL(hup_end_menu, (winid, const char *));\nstatic void FDECL(hup_putstr, (winid, int, const char *));\nstatic void FDECL(hup_print_glyph, (winid, XCHAR_P, XCHAR_P, int, int));\nstatic void FDECL(hup_outrip, (winid, int, time_t));\nstatic void FDECL(hup_curs, (winid, int, int));\nstatic void FDECL(hup_display_nhwindow, (winid, BOOLEAN_P));\nstatic void FDECL(hup_display_file, (const char *, BOOLEAN_P));\n#ifdef CLIPPING\nstatic void FDECL(hup_cliparound, (int, int));\n#endif\n#ifdef CHANGE_COLOR\nstatic void FDECL(hup_change_color, (int, long, int));\n#ifdef MAC\nstatic short FDECL(hup_set_font_name, (winid, char *));\n#endif\nstatic char *NDECL(hup_get_color_string);\n#endif /* CHANGE_COLOR */\nstatic void FDECL(hup_status_update, (int, genericptr_t, int, int, int,\n                                      unsigned long *));\n\nstatic int NDECL(hup_int_ndecl);\nstatic void NDECL(hup_void_ndecl);\nstatic void FDECL(hup_void_fdecl_int, (int));\nstatic void FDECL(hup_void_fdecl_winid, (winid));\nstatic void FDECL(hup_void_fdecl_constchar_p, (const char *));\n\nstatic struct window_procs hup_procs = {\n    \"hup\", 0L, 0L,\n    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n    hup_init_nhwindows,\n    hup_void_ndecl,                                    /* player_selection */\n    hup_void_ndecl,                                    /* askname */\n    hup_void_ndecl,                                    /* get_nh_event */\n    hup_exit_nhwindows, hup_void_fdecl_constchar_p,    /* suspend_nhwindows */\n    hup_void_ndecl,                                    /* resume_nhwindows */\n    hup_create_nhwindow, hup_void_fdecl_winid,         /* clear_nhwindow */\n    hup_display_nhwindow, hup_void_fdecl_winid,        /* destroy_nhwindow */\n    hup_curs, hup_putstr, hup_putstr,                  /* putmixed */\n    hup_display_file, hup_void_fdecl_winid,            /* start_menu */\n    hup_add_menu, hup_end_menu, hup_select_menu, genl_message_menu,\n    hup_void_ndecl,                                    /* update_inventory */\n    hup_void_ndecl,                                    /* mark_synch */\n    hup_void_ndecl,                                    /* wait_synch */\n#ifdef CLIPPING\n    hup_cliparound,\n#endif\n#ifdef POSITIONBAR\n    (void FDECL((*), (char *))) hup_void_fdecl_constchar_p,\n                                                      /* update_positionbar */\n#endif\n    hup_print_glyph,\n    hup_void_fdecl_constchar_p,                       /* raw_print */\n    hup_void_fdecl_constchar_p,                       /* raw_print_bold */\n    hup_nhgetch, hup_nh_poskey, hup_void_ndecl,       /* nhbell  */\n    hup_int_ndecl,                                    /* doprev_message */\n    hup_yn_function, hup_getlin, hup_int_ndecl,       /* get_ext_cmd */\n    hup_void_fdecl_int,                               /* number_pad */\n    hup_void_ndecl,                                   /* delay_output  */\n#ifdef CHANGE_COLOR\n    hup_change_color,\n#ifdef MAC\n    hup_void_fdecl_int,                               /* change_background */\n    hup_set_font_name,\n#endif\n    hup_get_color_string,\n#endif /* CHANGE_COLOR */\n    hup_void_ndecl,                                   /* start_screen */\n    hup_void_ndecl,                                   /* end_screen */\n    hup_outrip, genl_preference_update, genl_getmsghistory,\n    genl_putmsghistory,\n    hup_void_ndecl,                                   /* status_init */\n    hup_void_ndecl,                                   /* status_finish */\n    genl_status_enablefield, hup_status_update,\n    genl_can_suspend_no,\n};\n\nstatic void FDECL((*previnterface_exit_nhwindows), (const char *)) = 0;\n\n/* hangup has occurred; switch to no-op user interface */\nvoid\nnhwindows_hangup()\n{\n    char *FDECL((*previnterface_getmsghistory), (BOOLEAN_P)) = 0;\n\n#ifdef ALTMETA\n    /* command processor shouldn't look for 2nd char after seeing ESC */\n    iflags.altmeta = FALSE;\n#endif\n\n    /* don't call exit_nhwindows() directly here; if a hangup occurs\n       while interface code is executing, exit_nhwindows could knock\n       the interface's active data structures out from under itself */\n    if (iflags.window_inited\n        && windowprocs.win_exit_nhwindows != hup_exit_nhwindows)\n        previnterface_exit_nhwindows = windowprocs.win_exit_nhwindows;\n\n    /* also, we have to leave the old interface's getmsghistory()\n       in place because it will be called while saving the game */\n    if (windowprocs.win_getmsghistory != hup_procs.win_getmsghistory)\n        previnterface_getmsghistory = windowprocs.win_getmsghistory;\n\n    windowprocs = hup_procs;\n\n    if (previnterface_getmsghistory)\n        windowprocs.win_getmsghistory = previnterface_getmsghistory;\n}\n\nstatic void\nhup_exit_nhwindows(lastgasp)\nconst char *lastgasp;\n{\n    /* core has called exit_nhwindows(); call the previous interface's\n       shutdown routine now; xxx_exit_nhwindows() needs to call other\n       xxx_ routines directly rather than through windowprocs pointers */\n    if (previnterface_exit_nhwindows) {\n        lastgasp = 0; /* don't want exit routine to attempt extra output */\n        (*previnterface_exit_nhwindows)(lastgasp);\n        previnterface_exit_nhwindows = 0;\n    }\n    iflags.window_inited = 0;\n}\n\nstatic int\nhup_nhgetch(VOID_ARGS)\n{\n    return '\\033'; /* ESC */\n}\n\n/*ARGSUSED*/\nstatic char\nhup_yn_function(prompt, resp, deflt)\nconst char *prompt UNUSED, *resp UNUSED;\nchar deflt;\n{\n    if (!deflt)\n        deflt = '\\033';\n    return deflt;\n}\n\n/*ARGSUSED*/\nstatic int\nhup_nh_poskey(x, y, mod)\nint *x UNUSED, *y UNUSED, *mod UNUSED;\n{\n    return '\\033';\n}\n\n/*ARGSUSED*/\nstatic void\nhup_getlin(prompt, outbuf)\nconst char *prompt UNUSED;\nchar *outbuf;\n{\n    Strcpy(outbuf, \"\\033\");\n}\n\n/*ARGSUSED*/\nstatic void\nhup_init_nhwindows(argc_p, argv)\nint *argc_p UNUSED;\nchar **argv UNUSED;\n{\n    iflags.window_inited = 1;\n}\n\n/*ARGUSED*/\nstatic winid\nhup_create_nhwindow(type)\nint type UNUSED;\n{\n    return WIN_ERR;\n}\n\n/*ARGSUSED*/\nstatic int\nhup_select_menu(window, how, menu_list)\nwinid window UNUSED;\nint how UNUSED;\nstruct mi **menu_list UNUSED;\n{\n    return -1;\n}\n\n/*ARGSUSED*/\nstatic void\nhup_add_menu(window, glyph, identifier, sel, grpsel, attr, txt, preselected)\nwinid window UNUSED;\nint glyph UNUSED, attr UNUSED;\nconst anything *identifier UNUSED;\nchar sel UNUSED, grpsel UNUSED;\nconst char *txt UNUSED;\nboolean preselected UNUSED;\n{\n    return;\n}\n\n/*ARGSUSED*/\nstatic void\nhup_end_menu(window, prompt)\nwinid window UNUSED;\nconst char *prompt UNUSED;\n{\n    return;\n}\n\n/*ARGSUSED*/\nstatic void\nhup_putstr(window, attr, text)\nwinid window UNUSED;\nint attr UNUSED;\nconst char *text UNUSED;\n{\n    return;\n}\n\n/*ARGSUSED*/\nstatic void\nhup_print_glyph(window, x, y, glyph, bkglyph)\nwinid window UNUSED;\nxchar x UNUSED, y UNUSED;\nint glyph UNUSED;\nint bkglyph UNUSED;\n{\n    return;\n}\n\n/*ARGSUSED*/\nstatic void\nhup_outrip(tmpwin, how, when)\nwinid tmpwin UNUSED;\nint how UNUSED;\ntime_t when UNUSED;\n{\n    return;\n}\n\n/*ARGSUSED*/\nstatic void\nhup_curs(window, x, y)\nwinid window UNUSED;\nint x UNUSED, y UNUSED;\n{\n    return;\n}\n\n/*ARGSUSED*/\nstatic void\nhup_display_nhwindow(window, blocking)\nwinid window UNUSED;\nboolean blocking UNUSED;\n{\n    return;\n}\n\n/*ARGSUSED*/\nstatic void\nhup_display_file(fname, complain)\nconst char *fname UNUSED;\nboolean complain UNUSED;\n{\n    return;\n}\n\n#ifdef CLIPPING\n/*ARGSUSED*/\nstatic void\nhup_cliparound(x, y)\nint x UNUSED, y UNUSED;\n{\n    return;\n}\n#endif\n\n#ifdef CHANGE_COLOR\n/*ARGSUSED*/\nstatic void\nhup_change_color(color, rgb, reverse)\nint color, reverse;\nlong rgb;\n{\n    return;\n}\n\n#ifdef MAC\n/*ARGSUSED*/\nstatic short\nhup_set_font_name(window, fontname)\nwinid window;\nchar *fontname;\n{\n    return 0;\n}\n#endif /* MAC */\n\nstatic char *\nhup_get_color_string(VOID_ARGS)\n{\n    return (char *) 0;\n}\n#endif /* CHANGE_COLOR */\n\n/*ARGSUSED*/\nstatic void\nhup_status_update(idx, ptr, chg, pc, color, colormasks)\nint idx UNUSED;\ngenericptr_t ptr UNUSED;\nint chg UNUSED, pc UNUSED, color UNUSED;\nunsigned long *colormasks UNUSED;\n\n{\n    return;\n}\n\n/*\n * Non-specific stubs.\n */\n\nstatic int\nhup_int_ndecl(VOID_ARGS)\n{\n    return -1;\n}\n\nstatic void\nhup_void_ndecl(VOID_ARGS)\n{\n    return;\n}\n\n/*ARGUSED*/\nstatic void\nhup_void_fdecl_int(arg)\nint arg UNUSED;\n{\n    return;\n}\n\n/*ARGUSED*/\nstatic void\nhup_void_fdecl_winid(window)\nwinid window UNUSED;\n{\n    return;\n}\n\n/*ARGUSED*/\nstatic void\nhup_void_fdecl_constchar_p(string)\nconst char *string UNUSED;\n{\n    return;\n}\n\n#endif /* HANGUPHANDLING */\n\n\n/****************************************************************************/\n/* genl backward compat stuff                                               */\n/****************************************************************************/\n\nconst char *status_fieldnm[MAXBLSTATS];\nconst char *status_fieldfmt[MAXBLSTATS];\nchar *status_vals[MAXBLSTATS];\nboolean status_activefields[MAXBLSTATS];\nNEARDATA winid WIN_STATUS;\n\nvoid\ngenl_status_init()\n{\n    int i;\n\n    for (i = 0; i < MAXBLSTATS; ++i) {\n        status_vals[i] = (char *) alloc(MAXCO);\n        *status_vals[i] = '\\0';\n        status_activefields[i] = FALSE;\n        status_fieldfmt[i] = (const char *) 0;\n    }\n    /* Use a window for the genl version; backward port compatibility */\n    WIN_STATUS = create_nhwindow(NHW_STATUS);\n    display_nhwindow(WIN_STATUS, FALSE);\n}\n\nvoid\ngenl_status_finish()\n{\n    /* tear down routine */\n    int i;\n\n    /* free alloc'd memory here */\n    for (i = 0; i < MAXBLSTATS; ++i) {\n        if (status_vals[i])\n            free((genericptr_t) status_vals[i]), status_vals[i] = (char *) 0;\n    }\n}\n\nvoid\ngenl_status_enablefield(fieldidx, nm, fmt, enable)\nint fieldidx;\nconst char *nm;\nconst char *fmt;\nboolean enable;\n{\n    status_fieldfmt[fieldidx] = fmt;\n    status_fieldnm[fieldidx] = nm;\n    status_activefields[fieldidx] = enable;\n}\n\n/* call once for each field, then call with BL_FLUSH to output the result */\nvoid\ngenl_status_update(idx, ptr, chg, percent, color, colormasks)\nint idx;\ngenericptr_t ptr;\nint chg UNUSED, percent UNUSED, color UNUSED;\nunsigned long *colormasks UNUSED;\n{\n    char newbot1[MAXCO], newbot2[MAXCO];\n    long cond, *condptr = (long *) ptr;\n    register int i;\n    unsigned pass, lndelta;\n    enum statusfields idx1, idx2, *fieldlist;\n    char *nb, *text = (char *) ptr;\n\n    static enum statusfields fieldorder[][15] = {\n        /* line one */\n        { BL_TITLE, BL_STR, BL_DX, BL_CO, BL_IN, BL_WI, BL_CH, BL_ALIGN,\n          BL_SCORE, BL_FLUSH, BL_FLUSH, BL_FLUSH, BL_FLUSH, BL_FLUSH,\n          BL_FLUSH },\n        /* line two, default order */\n        { BL_LEVELDESC, BL_GOLD,\n          BL_HP, BL_HPMAX, BL_ENE, BL_ENEMAX, BL_AC,\n          BL_XP, BL_EXP, BL_HD,\n          BL_TIME,\n          BL_HUNGER, BL_CAP, BL_CONDITION,\n          BL_FLUSH },\n        /* move time to the end */\n        { BL_LEVELDESC, BL_GOLD,\n          BL_HP, BL_HPMAX, BL_ENE, BL_ENEMAX, BL_AC,\n          BL_XP, BL_EXP, BL_HD,\n          BL_HUNGER, BL_CAP, BL_CONDITION,\n          BL_TIME, BL_FLUSH },\n        /* move experience and time to the end */\n        { BL_LEVELDESC, BL_GOLD,\n          BL_HP, BL_HPMAX, BL_ENE, BL_ENEMAX, BL_AC,\n          BL_HUNGER, BL_CAP, BL_CONDITION,\n          BL_XP, BL_EXP, BL_HD, BL_TIME, BL_FLUSH },\n        /* move level description plus gold and experience and time to end */\n        { BL_HP, BL_HPMAX, BL_ENE, BL_ENEMAX, BL_AC,\n          BL_HUNGER, BL_CAP, BL_CONDITION,\n          BL_LEVELDESC, BL_GOLD, BL_XP, BL_EXP, BL_HD, BL_TIME, BL_FLUSH },\n    };\n\n    /* in case interface is using genl_status_update() but has not\n       specified WC2_FLUSH_STATUS (status_update() for field values\n       is buffered so final BL_FLUSH is needed to produce output) */\n    windowprocs.wincap2 |= WC2_FLUSH_STATUS;\n\n    if (idx >= 0) {\n        if (!status_activefields[idx])\n            return;\n        switch (idx) {\n        case BL_CONDITION:\n            cond = condptr ? *condptr : 0L;\n            nb = status_vals[idx];\n            *nb = '\\0';\n            if (cond & BL_MASK_STONE)\n                Strcpy(nb = eos(nb), \" Stone\");\n            if (cond & BL_MASK_SLIME)\n                Strcpy(nb = eos(nb), \" Slime\");\n            if (cond & BL_MASK_STRNGL)\n                Strcpy(nb = eos(nb), \" Strngl\");\n            if (cond & BL_MASK_FOODPOIS)\n                Strcpy(nb = eos(nb), \" FoodPois\");\n            if (cond & BL_MASK_TERMILL)\n                Strcpy(nb = eos(nb), \" TermIll\");\n            if (cond & BL_MASK_BLIND)\n                Strcpy(nb = eos(nb), \" Blind\");\n            if (cond & BL_MASK_DEAF)\n                Strcpy(nb = eos(nb), \" Deaf\");\n            if (cond & BL_MASK_STUN)\n                Strcpy(nb = eos(nb), \" Stun\");\n            if (cond & BL_MASK_CONF)\n                Strcpy(nb = eos(nb), \" Conf\");\n            if (cond & BL_MASK_HALLU)\n                Strcpy(nb = eos(nb), \" Hallu\");\n            if (cond & BL_MASK_LEV)\n                Strcpy(nb = eos(nb), \" Lev\");\n            if (cond & BL_MASK_FLY)\n                Strcpy(nb = eos(nb), \" Fly\");\n            if (cond & BL_MASK_RIDE)\n                Strcpy(nb = eos(nb), \" Ride\");\n            break;\n        default:\n            Sprintf(status_vals[idx],\n                    status_fieldfmt[idx] ? status_fieldfmt[idx] : \"%s\",\n                    text ? text : \"\");\n            break;\n        }\n        return; /* processed one field other than BL_FLUSH */\n    } /* (idx >= 0, thus not BL_FLUSH, BL_RESET, BL_CHARACTERISTICS) */\n\n    /* does BL_RESET require any specific code to ensure all fields ? */\n\n    if (!(idx == BL_FLUSH || idx == BL_RESET))\n        return;\n\n    /* We've received BL_FLUSH; time to output the gathered data */\n    nb = newbot1;\n    *nb = '\\0';\n    /* BL_FLUSH is the only pseudo-index value we need to check for\n       in the loop below because it is the only entry used to pad the\n       end of the fieldorder array. We could stop on any\n       negative (illegal) index, but this should be fine */\n    for (i = 0; (idx1 = fieldorder[0][i]) != BL_FLUSH; ++i) {\n        if (status_activefields[idx1])\n            Strcpy(nb = eos(nb), status_vals[idx1]);\n    }\n    /* if '$' is encoded, buffer length of \\GXXXXNNNN is 9 greater than\n       single char; we want to subtract that 9 when checking display length */\n    lndelta = (status_activefields[BL_GOLD]\n               && strstr(status_vals[BL_GOLD], \"\\\\G\")) ? 9 : 0;\n    /* basic bot2 formats groups of second line fields into five buffers,\n       then decides how to order those buffers based on comparing lengths\n       of [sub]sets of them to the width of the map; we have more control\n       here but currently emulate that behavior */\n    for (pass = 1; pass <= 4; pass++) {\n        fieldlist = fieldorder[pass];\n        nb = newbot2;\n        *nb = '\\0';\n        for (i = 0; (idx2 = fieldlist[i]) != BL_FLUSH; ++i) {\n            if (status_activefields[idx2]) {\n                const char *val = status_vals[idx2];\n\n                switch (idx2) {\n                case BL_HP: /* for pass 4, Hp comes first; mungspaces()\n                               will strip the unwanted leading spaces */\n                case BL_XP: case BL_HD:\n                case BL_TIME:\n                    Strcpy(nb = eos(nb), \" \");\n                    break;\n                case BL_LEVELDESC:\n                    /* leveldesc has no leading space, so if we've moved\n                       it past the first position, provide one */\n                    if (i != 0)\n                        Strcpy(nb = eos(nb), \" \");\n                    break;\n                /*\n                 * We want \"  hunger encumbrance conditions\"\n                 *   or    \"  encumbrance conditions\"\n                 *   or    \"  hunger conditions\"\n                 *   or    \"  conditions\"\n                 * 'hunger'      is either \" \" or \" hunger_text\";\n                 * 'encumbrance' is either \" \" or \" encumbrance_text\";\n                 * 'conditions'  is either \"\"  or \" cond1 cond2...\".\n                 */\n                case BL_HUNGER:\n                    /* hunger==\" \" - keep it, end up with \" \";\n                       hunger!=\" \" - insert space and get \"  hunger\" */\n                    if (strcmp(val, \" \"))\n                        Strcpy(nb = eos(nb), \" \");\n                    break;\n                case BL_CAP:\n                    /* cap==\" \" - suppress it, retain \"  hunger\" or \" \";\n                       cap!=\" \" - use it, get \"  hunger cap\" or \"  cap\" */\n                    if (!strcmp(val, \" \"))\n                        ++val;\n                    break;\n                default:\n                    break;\n                }\n                Strcpy(nb = eos(nb), val); /* status_vals[idx2] */\n            } /* status_activefields[idx2] */\n\n            if (idx2 == BL_CONDITION && pass < 4\n                && strlen(newbot2) - lndelta > COLNO)\n                break; /* switch to next order */\n        } /* i */\n\n        if (idx2 == BL_FLUSH) { /* made it past BL_CONDITION */\n            if (pass > 1)\n                mungspaces(newbot2);\n            break;\n        }\n    } /* pass */\n    curs(WIN_STATUS, 1, 0);\n    putstr(WIN_STATUS, 0, newbot1);\n    curs(WIN_STATUS, 1, 1);\n    putmixed(WIN_STATUS, 0, newbot2); /* putmixed() due to GOLD glyph */\n}\n\nSTATIC_VAR struct window_procs dumplog_windowprocs_backup;\nSTATIC_VAR FILE *dumplog_file;\n\n#ifdef DUMPLOG\nSTATIC_VAR time_t dumplog_now;\n\nchar *\ndump_fmtstr(fmt, buf, fullsubs)\nconst char *fmt;\nchar *buf;\nboolean fullsubs; /* True -> full substitution for file name, False ->\n                   * partial substitution for '--showpaths' feedback\n                   * where there's no game in progress when executed */\n{\n    const char *fp = fmt;\n    char *bp = buf;\n    int slen, len = 0;\n    char tmpbuf[BUFSZ];\n    char verbuf[BUFSZ];\n    long uid;\n    time_t now;\n\n    now = dumplog_now;\n    uid = (long) getuid();\n\n    /*\n     * Note: %t and %T assume that time_t is a 'long int' number of\n     * seconds since some epoch value.  That's quite iffy....  The\n     * unit of time might be different and the datum size might be\n     * some variant of 'long long int'.  [Their main purpose is to\n     * construct a unique file name rather than record the date and\n     * time; violating the 'long seconds since base-date' assumption\n     * may or may not interfere with that usage.]\n     */\n\n    while (fp && *fp && len < BUFSZ - 1) {\n        if (*fp == '%') {\n            fp++;\n            switch (*fp) {\n            default:\n                goto finish;\n            case '\\0': /* fallthrough */\n            case '%':  /* literal % */\n                Sprintf(tmpbuf, \"%%\");\n                break;\n            case 't': /* game start, timestamp */\n                if (fullsubs)\n                    Sprintf(tmpbuf, \"%lu\", (unsigned long) ubirthday);\n                else\n                    Strcpy(tmpbuf, \"{game start cookie}\");\n                break;\n            case 'T': /* current time, timestamp */\n                if (fullsubs)\n                    Sprintf(tmpbuf, \"%lu\", (unsigned long) now);\n                else\n                    Strcpy(tmpbuf, \"{current time cookie}\");\n                break;\n            case 'd': /* game start, YYYYMMDDhhmmss */\n                if (fullsubs)\n                    Sprintf(tmpbuf, \"%08ld%06ld\",\n                            yyyymmdd(ubirthday), hhmmss(ubirthday));\n                else\n                    Strcpy(tmpbuf, \"{game start date+time}\");\n                break;\n            case 'D': /* current time, YYYYMMDDhhmmss */\n                if (fullsubs)\n                    Sprintf(tmpbuf, \"%08ld%06ld\", yyyymmdd(now), hhmmss(now));\n                else\n                    Strcpy(tmpbuf, \"{current date+time}\");\n                break;\n            case 'v': /* version, eg. \"3.6.5-0\" */\n                Sprintf(tmpbuf, \"%s\", version_string(verbuf));\n                break;\n            case 'u': /* UID */\n                Sprintf(tmpbuf, \"%ld\", uid);\n                break;\n            case 'n': /* player name */\n                if (fullsubs)\n                    Sprintf(tmpbuf, \"%s\", *plname ? plname : \"unknown\");\n                else\n                    Strcpy(tmpbuf, \"{hero name}\");\n                break;\n            case 'N': /* first character of player name */\n                if (fullsubs)\n                    Sprintf(tmpbuf, \"%c\", *plname ? *plname : 'u');\n                else\n                    Strcpy(tmpbuf, \"{hero initial}\");\n                break;\n            }\n            if (fullsubs) {\n                /* replace potentially troublesome characters (including\n                   <space> even though it might be an acceptable file name\n                   character); user shouldn't be able to get ' ' or '/'\n                   or '\\\\' into plname[] but play things safe */\n                (void) strNsubst(tmpbuf, \" \", \"_\", 0);\n                (void) strNsubst(tmpbuf, \"/\", \"_\", 0);\n                (void) strNsubst(tmpbuf, \"\\\\\", \"_\", 0);\n                /* note: replacements are only done on field substitutions,\n                   not on the template (from sysconf or DUMPLOG_FILE) */\n            }\n\n            slen = (int) strlen(tmpbuf);\n            if (len + slen < BUFSZ - 1) {\n                len += slen;\n                Sprintf(bp, \"%s\", tmpbuf);\n                bp += slen;\n                if (*fp)\n                    fp++;\n            } else\n                break;\n        } else {\n            *bp = *fp;\n            bp++;\n            fp++;\n            len++;\n        }\n    }\n finish:\n    *bp = '\\0';\n    return buf;\n}\n#endif /* DUMPLOG */\n\nvoid\ndump_open_log(now)\ntime_t now;\n{\n#ifdef DUMPLOG\n    char buf[BUFSZ];\n    char *fname;\n\n    dumplog_now = now;\n#ifdef SYSCF\n    if (!sysopt.dumplogfile)\n        return;\n    fname = dump_fmtstr(sysopt.dumplogfile, buf, TRUE);\n#else\n    fname = dump_fmtstr(DUMPLOG_FILE, buf, TRUE);\n#endif\n    dumplog_file = fopen(fname, \"w\");\n    dumplog_windowprocs_backup = windowprocs;\n\n#else /*!DUMPLOG*/\n    nhUse(now);\n#endif /*?DUMPLOG*/\n}\n\nvoid\ndump_close_log()\n{\n    if (dumplog_file) {\n        (void) fclose(dumplog_file);\n        dumplog_file = (FILE *) 0;\n    }\n}\n\nvoid\ndump_forward_putstr(win, attr, str, no_forward)\nwinid win;\nint attr;\nconst char *str;\nint no_forward;\n{\n    if (dumplog_file)\n        fprintf(dumplog_file, \"%s\\n\", str);\n    if (!no_forward)\n        putstr(win, attr, str);\n}\n\n/*ARGSUSED*/\nSTATIC_OVL void\ndump_putstr(win, attr, str)\nwinid win UNUSED;\nint attr UNUSED;\nconst char *str;\n{\n    if (dumplog_file)\n        fprintf(dumplog_file, \"%s\\n\", str);\n}\n\nSTATIC_OVL winid\ndump_create_nhwindow(dummy)\nint dummy;\n{\n    return dummy;\n}\n\n/*ARGUSED*/\nSTATIC_OVL void\ndump_clear_nhwindow(win)\nwinid win UNUSED;\n{\n    return;\n}\n\n/*ARGSUSED*/\nSTATIC_OVL void\ndump_display_nhwindow(win, p)\nwinid win UNUSED;\nboolean p UNUSED;\n{\n    return;\n}\n\n/*ARGUSED*/\nSTATIC_OVL void\ndump_destroy_nhwindow(win)\nwinid win UNUSED;\n{\n    return;\n}\n\n/*ARGUSED*/\nSTATIC_OVL void\ndump_start_menu(win)\nwinid win UNUSED;\n{\n    return;\n}\n\n/*ARGSUSED*/\nSTATIC_OVL void\ndump_add_menu(win, glyph, identifier, ch, gch, attr, str, preselected)\nwinid win UNUSED;\nint glyph;\nconst anything *identifier UNUSED;\nchar ch;\nchar gch UNUSED;\nint attr UNUSED;\nconst char *str;\nboolean preselected UNUSED;\n{\n    if (dumplog_file) {\n        if (glyph == NO_GLYPH)\n            fprintf(dumplog_file, \" %s\\n\", str);\n        else\n            fprintf(dumplog_file, \"  %c - %s\\n\", ch, str);\n    }\n}\n\n/*ARGSUSED*/\nSTATIC_OVL void\ndump_end_menu(win, str)\nwinid win UNUSED;\nconst char *str;\n{\n    if (dumplog_file) {\n        if (str)\n            fprintf(dumplog_file, \"%s\\n\", str);\n        else\n            fputs(\"\\n\", dumplog_file);\n    }\n}\n\nSTATIC_OVL int\ndump_select_menu(win, how, item)\nwinid win UNUSED;\nint how UNUSED;\nmenu_item **item;\n{\n    *item = (menu_item *) 0;\n    return 0;\n}\n\nvoid\ndump_redirect(onoff_flag)\nboolean onoff_flag;\n{\n    if (dumplog_file) {\n        if (onoff_flag) {\n            windowprocs.win_create_nhwindow = dump_create_nhwindow;\n            windowprocs.win_clear_nhwindow = dump_clear_nhwindow;\n            windowprocs.win_display_nhwindow = dump_display_nhwindow;\n            windowprocs.win_destroy_nhwindow = dump_destroy_nhwindow;\n            windowprocs.win_start_menu = dump_start_menu;\n            windowprocs.win_add_menu = dump_add_menu;\n            windowprocs.win_end_menu = dump_end_menu;\n            windowprocs.win_select_menu = dump_select_menu;\n            windowprocs.win_putstr = dump_putstr;\n        } else {\n            windowprocs = dumplog_windowprocs_backup;\n        }\n        iflags.in_dumplog = onoff_flag;\n    } else {\n        iflags.in_dumplog = FALSE;\n    }\n}\n\n#ifdef TTY_GRAPHICS\n#ifdef TEXTCOLOR\n#ifdef TOS\nextern const char *hilites[CLR_MAX];\n#else\nextern NEARDATA char *hilites[CLR_MAX];\n#endif\n#endif\n#endif\n\nint\nhas_color(color)\nint color;\n{\n    return (iflags.use_color && windowprocs.name\n            && (windowprocs.wincap & WC_COLOR) && windowprocs.has_color[color]\n#ifdef TTY_GRAPHICS\n#if defined(TEXTCOLOR) && defined(TERMLIB) && !defined(NO_TERMS)\n             && (hilites[color] != 0)\n#endif\n#endif\n    );\n}\n\n/*windows.c*/\n", "/* NetHack 3.6\tunixmain.c\t$NHDT-Date: 1570408210 2019/10/07 00:30:10 $  $NHDT-Branch: NetHack-3.6 $:$NHDT-Revision: 1.70 $ */\n/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */\n/*-Copyright (c) Robert Patrick Rankin, 2011. */\n/* NetHack may be freely redistributed.  See license for details. */\n\n/* main.c - Unix NetHack */\n\n#include \"hack.h\"\n#include \"dlb.h\"\n\n#include <ctype.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <pwd.h>\n#ifndef O_RDONLY\n#include <fcntl.h>\n#endif\n\n#if !defined(_BULL_SOURCE) && !defined(__sgi) && !defined(_M_UNIX)\n#if !defined(SUNOS4) && !(defined(ULTRIX) && defined(__GNUC__))\n#if defined(POSIX_TYPES) || defined(SVR4) || defined(HPUX)\nextern struct passwd *FDECL(getpwuid, (uid_t));\n#else\nextern struct passwd *FDECL(getpwuid, (int));\n#endif\n#endif\n#endif\nextern struct passwd *FDECL(getpwnam, (const char *));\n#ifdef CHDIR\nstatic void FDECL(chdirx, (const char *, BOOLEAN_P));\n#endif /* CHDIR */\nstatic boolean NDECL(whoami);\nstatic void FDECL(process_options, (int, char **));\n\n#ifdef _M_UNIX\nextern void NDECL(check_sco_console);\nextern void NDECL(init_sco_cons);\n#endif\n#ifdef __linux__\nextern void NDECL(check_linux_console);\nextern void NDECL(init_linux_cons);\n#endif\n\nstatic void NDECL(wd_message);\nstatic boolean wiz_error_flag = FALSE;\nstatic struct passwd *NDECL(get_unix_pw);\n\nint\nmain(argc, argv)\nint argc;\nchar *argv[];\n{\n    register int fd;\n#ifdef CHDIR\n    register char *dir;\n#endif\n    boolean exact_username;\n    boolean resuming = FALSE; /* assume new game */\n    boolean plsel_once = FALSE;\n\n    sys_early_init();\n\n#if defined(__APPLE__)\n    {\n/* special hack to change working directory to a resource fork when\n   running from finder --sam */\n#define MAC_PATH_VALUE \".app/Contents/MacOS/\"\n        char mac_cwd[1024], *mac_exe = argv[0], *mac_tmp;\n        int arg0_len = strlen(mac_exe), mac_tmp_len, mac_lhs_len = 0;\n        getcwd(mac_cwd, 1024);\n        if (mac_exe[0] == '/' && !strcmp(mac_cwd, \"/\")) {\n            if ((mac_exe = strrchr(mac_exe, '/')))\n                mac_exe++;\n            else\n                mac_exe = argv[0];\n            mac_tmp_len = (strlen(mac_exe) * 2) + strlen(MAC_PATH_VALUE);\n            if (mac_tmp_len <= arg0_len) {\n                mac_tmp = malloc(mac_tmp_len + 1);\n                sprintf(mac_tmp, \"%s%s%s\", mac_exe, MAC_PATH_VALUE, mac_exe);\n                if (!strcmp(argv[0] + (arg0_len - mac_tmp_len), mac_tmp)) {\n                    mac_lhs_len =\n                        (arg0_len - mac_tmp_len) + strlen(mac_exe) + 5;\n                    if (mac_lhs_len > mac_tmp_len - 1)\n                        mac_tmp = realloc(mac_tmp, mac_lhs_len);\n                    strncpy(mac_tmp, argv[0], mac_lhs_len);\n                    mac_tmp[mac_lhs_len] = '\\0';\n                    chdir(mac_tmp);\n                }\n                free(mac_tmp);\n            }\n        }\n    }\n#endif\n\n    hname = argv[0];\n    hackpid = getpid();\n    (void) umask(0777 & ~FCMASK);\n\n    choose_windows(DEFAULT_WINDOW_SYS);\n\n#ifdef CHDIR /* otherwise no chdir() */\n    /*\n     * See if we must change directory to the playground.\n     * (Perhaps hack runs suid and playground is inaccessible\n     *  for the player.)\n     * The environment variable HACKDIR is overridden by a\n     *  -d command line option (must be the first option given).\n     */\n    dir = nh_getenv(\"NETHACKDIR\");\n    if (!dir)\n        dir = nh_getenv(\"HACKDIR\");\n\n    if (argc > 1) {\n        if (argcheck(argc, argv, ARG_VERSION) == 2)\n            exit(EXIT_SUCCESS);\n\n        if (argcheck(argc, argv, ARG_SHOWPATHS) == 2) {\n#ifdef CHDIR\n            chdirx((char *) 0, 0);\n#endif\n            iflags.initoptions_noterminate = TRUE;\n            initoptions();\n            iflags.initoptions_noterminate = FALSE;\n            reveal_paths();\n            exit(EXIT_SUCCESS);\n        }\n        if (argcheck(argc, argv, ARG_DEBUG) == 1) {\n            argc--;\n            argv++;\n        }\n        if (argc > 1 && !strncmp(argv[1], \"-d\", 2) && argv[1][2] != 'e') {\n            /* avoid matching \"-dec\" for DECgraphics; since the man page\n             * says -d directory, hope nobody's using -desomething_else\n             */\n            argc--;\n            argv++;\n            dir = argv[0] + 2;\n            if (*dir == '=' || *dir == ':')\n                dir++;\n            if (!*dir && argc > 1) {\n                argc--;\n                argv++;\n                dir = argv[0];\n            }\n            if (!*dir)\n                error(\"Flag -d must be followed by a directory name.\");\n        }\n    }\n#endif /* CHDIR */\n\n    if (argc > 1) {\n        /*\n         * Now we know the directory containing 'record' and\n         * may do a prscore().  Exclude `-style' - it's a Qt option.\n         */\n        if (!strncmp(argv[1], \"-s\", 2) && strncmp(argv[1], \"-style\", 6)) {\n#ifdef CHDIR\n            chdirx(dir, 0);\n#endif\n#ifdef SYSCF\n            initoptions();\n#endif\n#ifdef PANICTRACE\n            ARGV0 = hname; /* save for possible stack trace */\n#ifndef NO_SIGNAL\n            panictrace_setsignals(TRUE);\n#endif\n#endif\n            prscore(argc, argv);\n            /* FIXME: shouldn't this be using nh_terminate() to free\n               up any memory allocated by initoptions() */\n            exit(EXIT_SUCCESS);\n        }\n    } /* argc > 1 */\n\n/*\n * Change directories before we initialize the window system so\n * we can find the tile file.\n */\n#ifdef CHDIR\n    chdirx(dir, 1);\n#endif\n\n#ifdef _M_UNIX\n    check_sco_console();\n#endif\n#ifdef __linux__\n    check_linux_console();\n#endif\n    initoptions();\n#ifdef PANICTRACE\n    ARGV0 = hname; /* save for possible stack trace */\n#ifndef NO_SIGNAL\n    panictrace_setsignals(TRUE);\n#endif\n#endif\n    exact_username = whoami();\n\n    /*\n     * It seems you really want to play.\n     */\n    u.uhp = 1; /* prevent RIP on early quits */\n    program_state.preserve_locks = 1;\n#ifndef NO_SIGNAL\n    sethanguphandler((SIG_RET_TYPE) hangup);\n#endif\n\n    process_options(argc, argv); /* command line options */\n#ifdef WINCHAIN\n    commit_windowchain();\n#endif\n    init_nhwindows(&argc, argv); /* now we can set up window system */\n#ifdef _M_UNIX\n    init_sco_cons();\n#endif\n#ifdef __linux__\n    init_linux_cons();\n#endif\n\n#ifdef DEF_PAGER\n    if (!(catmore = nh_getenv(\"HACKPAGER\"))\n        && !(catmore = nh_getenv(\"PAGER\")))\n        catmore = DEF_PAGER;\n#endif\n#ifdef MAIL\n    getmailstatus();\n#endif\n\n    /* wizard mode access is deferred until here */\n    set_playmode(); /* sets plname to \"wizard\" for wizard mode */\n    if (exact_username) {\n        /*\n         * FIXME: this no longer works, ever since 3.3.0\n         * when plnamesuffix() was changed to find\n         * Name-Role-Race-Gender-Alignment.  It removes\n         * all dashes rather than just the last one,\n         * regardless of whether whatever follows each\n         * dash matches role, race, gender, or alignment.\n         */\n        /* guard against user names with hyphens in them */\n        int len = (int) strlen(plname);\n        /* append the current role, if any, so that last dash is ours */\n        if (++len < (int) sizeof plname)\n            (void) strncat(strcat(plname, \"-\"), pl_character,\n                           sizeof plname - len - 1);\n    }\n    /* strip role,race,&c suffix; calls askname() if plname[] is empty\n       or holds a generic user name like \"player\" or \"games\" */\n    plnamesuffix();\n\n    if (wizard) {\n        /* use character name rather than lock letter for file names */\n        locknum = 0;\n    } else {\n        /* suppress interrupts while processing lock file */\n        (void) signal(SIGQUIT, SIG_IGN);\n        (void) signal(SIGINT, SIG_IGN);\n    }\n\n    dlb_init(); /* must be before newgame() */\n\n    /*\n     * Initialize the vision system.  This must be before mklev() on a\n     * new game or before a level restore on a saved game.\n     */\n    vision_init();\n\n    display_gamewindows();\n\n    /*\n     * First, try to find and restore a save file for specified character.\n     * We'll return here if new game player_selection() renames the hero.\n     */\n attempt_restore:\n\n    /*\n     * getlock() complains and quits if there is already a game\n     * in progress for current character name (when locknum == 0)\n     * or if there are too many active games (when locknum > 0).\n     * When proceeding, it creates an empty <lockname>.0 file to\n     * designate the current game.\n     * getlock() constructs <lockname> based on the character\n     * name (for !locknum) or on first available of alock, block,\n     * clock, &c not currently in use in the playground directory\n     * (for locknum > 0).\n     */\n    if (*plname) {\n        getlock();\n        program_state.preserve_locks = 0; /* after getlock() */\n    }\n\n    if (*plname && (fd = restore_saved_game()) >= 0) {\n        const char *fq_save = fqname(SAVEF, SAVEPREFIX, 1);\n\n        (void) chmod(fq_save, 0); /* disallow parallel restores */\n#ifndef NO_SIGNAL\n        (void) signal(SIGINT, (SIG_RET_TYPE) done1);\n#endif\n#ifdef NEWS\n        if (iflags.news) {\n            display_file(NEWS, FALSE);\n            iflags.news = FALSE; /* in case dorecover() fails */\n        }\n#endif\n        pline(\"Restoring save file...\");\n        mark_synch(); /* flush output */\n        if (dorecover(fd)) {\n            resuming = TRUE; /* not starting new game */\n            wd_message();\n            if (discover || wizard) {\n                /* this seems like a candidate for paranoid_confirmation... */\n                if (yn(\"Do you want to keep the save file?\") == 'n') {\n                    (void) delete_savefile();\n                } else {\n                    (void) chmod(fq_save, FCMASK); /* back to readable */\n                    nh_compress(fq_save);\n                }\n            }\n        }\n    }\n\n    if (!resuming) {\n        boolean neednewlock = (!*plname);\n        /* new game:  start by choosing role, race, etc;\n           player might change the hero's name while doing that,\n           in which case we try to restore under the new name\n           and skip selection this time if that didn't succeed */\n        if (!iflags.renameinprogress || iflags.defer_plname || neednewlock) {\n            if (!plsel_once)\n                player_selection();\n            plsel_once = TRUE;\n            if (neednewlock && *plname)\n                goto attempt_restore;\n            if (iflags.renameinprogress) {\n                /* player has renamed the hero while selecting role;\n                   if locking alphabetically, the existing lock file\n                   can still be used; otherwise, discard current one\n                   and create another for the new character name */\n                if (!locknum) {\n                    delete_levelfile(0); /* remove empty lock file */\n                    getlock();\n                }\n                goto attempt_restore;\n            }\n        }\n        newgame();\n        wd_message();\n    }\n\n    /* moveloop() never returns but isn't flagged NORETURN */\n    moveloop(resuming);\n\n    exit(EXIT_SUCCESS);\n    /*NOTREACHED*/\n    return 0;\n}\n\n/* caveat: argv elements might be arbitrary long */\nstatic void\nprocess_options(argc, argv)\nint argc;\nchar *argv[];\n{\n    int i, l;\n\n    /*\n     * Process options.\n     */\n    while (argc > 1 && argv[1][0] == '-') {\n        argv++;\n        argc--;\n        l = (int) strlen(*argv);\n        /* must supply at least 4 chars to match \"-XXXgraphics\" */\n        if (l < 4)\n            l = 4;\n\n        switch (argv[0][1]) {\n        case 'D':\n        case 'd':\n            if ((argv[0][1] == 'D' && !argv[0][2])\n                || !strcmpi(*argv, \"-debug\")) {\n                wizard = TRUE, discover = FALSE;\n            } else if (!strncmpi(*argv, \"-DECgraphics\", l)) {\n                load_symset(\"DECGraphics\", PRIMARY);\n                switch_symbols(TRUE);\n            } else {\n                raw_printf(\"Unknown option: %.60s\", *argv);\n            }\n            break;\n        case 'X':\n            discover = TRUE, wizard = FALSE;\n            break;\n#ifdef NEWS\n        case 'n':\n            iflags.news = FALSE;\n            break;\n#endif\n        case 'u':\n            if (argv[0][2]) {\n                (void) strncpy(plname, argv[0] + 2, sizeof plname - 1);\n            } else if (argc > 1) {\n                argc--;\n                argv++;\n                (void) strncpy(plname, argv[0], sizeof plname - 1);\n            } else {\n                raw_print(\"Player name expected after -u\");\n            }\n            break;\n        case 'I':\n        case 'i':\n            if (!strncmpi(*argv, \"-IBMgraphics\", l)) {\n                load_symset(\"IBMGraphics\", PRIMARY);\n                load_symset(\"RogueIBM\", ROGUESET);\n                switch_symbols(TRUE);\n            } else {\n                raw_printf(\"Unknown option: %.60s\", *argv);\n            }\n            break;\n        case 'p': /* profession (role) */\n            if (argv[0][2]) {\n                if ((i = str2role(&argv[0][2])) >= 0)\n                    flags.initrole = i;\n            } else if (argc > 1) {\n                argc--;\n                argv++;\n                if ((i = str2role(argv[0])) >= 0)\n                    flags.initrole = i;\n            }\n            break;\n        case 'r': /* race */\n            if (argv[0][2]) {\n                if ((i = str2race(&argv[0][2])) >= 0)\n                    flags.initrace = i;\n            } else if (argc > 1) {\n                argc--;\n                argv++;\n                if ((i = str2race(argv[0])) >= 0)\n                    flags.initrace = i;\n            }\n            break;\n        case 'w': /* windowtype */\n            config_error_init(FALSE, \"command line\", FALSE);\n            choose_windows(&argv[0][2]);\n            config_error_done();\n            break;\n        case '@':\n            flags.randomall = 1;\n            break;\n        default:\n            if ((i = str2role(&argv[0][1])) >= 0) {\n                flags.initrole = i;\n                break;\n            }\n            /* else raw_printf(\"Unknown option: %.60s\", *argv); */\n        }\n    }\n\n#ifdef SYSCF\n    if (argc > 1)\n        raw_printf(\"MAXPLAYERS are set in sysconf file.\\n\");\n#else\n    /* XXX This is deprecated in favor of SYSCF with MAXPLAYERS */\n    if (argc > 1)\n        locknum = atoi(argv[1]);\n#endif\n#ifdef MAX_NR_OF_PLAYERS\n    /* limit to compile-time limit */\n    if (!locknum || locknum > MAX_NR_OF_PLAYERS)\n        locknum = MAX_NR_OF_PLAYERS;\n#endif\n#ifdef SYSCF\n    /* let syscf override compile-time limit */\n    if (!locknum || (sysopt.maxplayers && locknum > sysopt.maxplayers))\n        locknum = sysopt.maxplayers;\n#endif\n}\n\n#ifdef CHDIR\nstatic void\nchdirx(dir, wr)\nconst char *dir;\nboolean wr;\n{\n    if (dir /* User specified directory? */\n#ifdef HACKDIR\n        && strcmp(dir, HACKDIR) /* and not the default? */\n#endif\n        ) {\n#ifdef SECURE\n        (void) setgid(getgid());\n        (void) setuid(getuid()); /* Ron Wessels */\n#endif\n    } else {\n        /* non-default data files is a sign that scores may not be\n         * compatible, or perhaps that a binary not fitting this\n         * system's layout is being used.\n         */\n#ifdef VAR_PLAYGROUND\n        int len = strlen(VAR_PLAYGROUND);\n\n        fqn_prefix[SCOREPREFIX] = (char *) alloc(len + 2);\n        Strcpy(fqn_prefix[SCOREPREFIX], VAR_PLAYGROUND);\n        if (fqn_prefix[SCOREPREFIX][len - 1] != '/') {\n            fqn_prefix[SCOREPREFIX][len] = '/';\n            fqn_prefix[SCOREPREFIX][len + 1] = '\\0';\n        }\n#endif\n    }\n\n#ifdef HACKDIR\n    if (dir == (const char *) 0)\n        dir = HACKDIR;\n#endif\n\n    if (dir && chdir(dir) < 0) {\n        perror(dir);\n        error(\"Cannot chdir to %s.\", dir);\n    }\n\n    /* warn the player if we can't write the record file\n     * perhaps we should also test whether . is writable\n     * unfortunately the access system-call is worthless.\n     */\n    if (wr) {\n#ifdef VAR_PLAYGROUND\n        fqn_prefix[LEVELPREFIX] = fqn_prefix[SCOREPREFIX];\n        fqn_prefix[SAVEPREFIX] = fqn_prefix[SCOREPREFIX];\n        fqn_prefix[BONESPREFIX] = fqn_prefix[SCOREPREFIX];\n        fqn_prefix[LOCKPREFIX] = fqn_prefix[SCOREPREFIX];\n        fqn_prefix[TROUBLEPREFIX] = fqn_prefix[SCOREPREFIX];\n#endif\n        check_recordfile(dir);\n    }\n}\n#endif /* CHDIR */\n\n/* returns True iff we set plname[] to username which contains a hyphen */\nstatic boolean\nwhoami()\n{\n    /*\n     * Who am i? Algorithm: 1. Use name as specified in NETHACKOPTIONS\n     *                      2. Use $USER or $LOGNAME    (if 1. fails)\n     *                      3. Use getlogin()           (if 2. fails)\n     * The resulting name is overridden by command line options.\n     * If everything fails, or if the resulting name is some generic\n     * account like \"games\", \"play\", \"player\", \"hack\" then eventually\n     * we'll ask him.\n     * Note that we trust the user here; it is possible to play under\n     * somebody else's name.\n     */\n    if (!*plname) {\n        register const char *s;\n\n        s = nh_getenv(\"USER\");\n        if (!s || !*s)\n            s = nh_getenv(\"LOGNAME\");\n        if (!s || !*s)\n            s = getlogin();\n\n        if (s && *s) {\n            (void) strncpy(plname, s, sizeof plname - 1);\n            if (index(plname, '-'))\n                return TRUE;\n        }\n    }\n    return FALSE;\n}\n\nvoid\nsethanguphandler(handler)\nvoid FDECL((*handler), (int));\n{\n#ifdef SA_RESTART\n    /* don't want reads to restart.  If SA_RESTART is defined, we know\n     * sigaction exists and can be used to ensure reads won't restart.\n     * If it's not defined, assume reads do not restart.  If reads restart\n     * and a signal occurs, the game won't do anything until the read\n     * succeeds (or the stream returns EOF, which might not happen if\n     * reading from, say, a window manager). */\n    struct sigaction sact;\n\n    (void) memset((genericptr_t) &sact, 0, sizeof sact);\n    sact.sa_handler = (SIG_RET_TYPE) handler;\n    (void) sigaction(SIGHUP, &sact, (struct sigaction *) 0);\n#ifdef SIGXCPU\n    (void) sigaction(SIGXCPU, &sact, (struct sigaction *) 0);\n#endif\n#else /* !SA_RESTART */\n    (void) signal(SIGHUP, (SIG_RET_TYPE) handler);\n#ifdef SIGXCPU\n    (void) signal(SIGXCPU, (SIG_RET_TYPE) handler);\n#endif\n#endif /* ?SA_RESTART */\n}\n\n#ifdef PORT_HELP\nvoid\nport_help()\n{\n    /*\n     * Display unix-specific help.   Just show contents of the helpfile\n     * named by PORT_HELP.\n     */\n    display_file(PORT_HELP, TRUE);\n}\n#endif\n\n/* validate wizard mode if player has requested access to it */\nboolean\nauthorize_wizard_mode()\n{\n    struct passwd *pw = get_unix_pw();\n\n    if (pw && sysopt.wizards && sysopt.wizards[0]) {\n        if (check_user_string(sysopt.wizards))\n            return TRUE;\n    }\n    wiz_error_flag = TRUE; /* not being allowed into wizard mode */\n    return FALSE;\n}\n\nstatic void\nwd_message()\n{\n    if (wiz_error_flag) {\n        if (sysopt.wizards && sysopt.wizards[0]) {\n            char *tmp = build_english_list(sysopt.wizards);\n            pline(\"Only user%s %s may access debug (wizard) mode.\",\n                  index(sysopt.wizards, ' ') ? \"s\" : \"\", tmp);\n            free(tmp);\n        } else\n            pline(\"Entering explore/discovery mode instead.\");\n        wizard = 0, discover = 1; /* (paranoia) */\n    } else if (discover)\n        You(\"are in non-scoring explore/discovery mode.\");\n}\n\n/*\n * Add a slash to any name not ending in /. There must\n * be room for the /\n */\nvoid\nappend_slash(name)\nchar *name;\n{\n    char *ptr;\n\n    if (!*name)\n        return;\n    ptr = name + (strlen(name) - 1);\n    if (*ptr != '/') {\n        *++ptr = '/';\n        *++ptr = '\\0';\n    }\n    return;\n}\n\nboolean\ncheck_user_string(optstr)\nchar *optstr;\n{\n    struct passwd *pw;\n    int pwlen;\n    char *eop, *w;\n    char *pwname = 0;\n\n    if (optstr[0] == '*')\n        return TRUE; /* allow any user */\n    if (sysopt.check_plname)\n        pwname = plname;\n    else if ((pw = get_unix_pw()) != 0)\n        pwname = pw->pw_name;\n    if (!pwname || !*pwname)\n        return FALSE;\n    pwlen = (int) strlen(pwname);\n    eop = eos(optstr);\n    w = optstr;\n    while (w + pwlen <= eop) {\n        if (!*w)\n            break;\n        if (isspace(*w)) {\n            w++;\n            continue;\n        }\n        if (!strncmp(w, pwname, pwlen)) {\n            if (!w[pwlen] || isspace(w[pwlen]))\n                return TRUE;\n        }\n        while (*w && !isspace(*w))\n            w++;\n    }\n    return FALSE;\n}\n\nstatic struct passwd *\nget_unix_pw()\n{\n    char *user;\n    unsigned uid;\n    static struct passwd *pw = (struct passwd *) 0;\n\n    if (pw)\n        return pw; /* cache answer */\n\n    uid = (unsigned) getuid();\n    user = getlogin();\n    if (user) {\n        pw = getpwnam(user);\n        if (pw && ((unsigned) pw->pw_uid != uid))\n            pw = 0;\n    }\n    if (pw == 0) {\n        user = nh_getenv(\"USER\");\n        if (user) {\n            pw = getpwnam(user);\n            if (pw && ((unsigned) pw->pw_uid != uid))\n                pw = 0;\n        }\n        if (pw == 0) {\n            pw = getpwuid(uid);\n        }\n    }\n    return pw;\n}\n\nchar *\nget_login_name()\n{\n    static char buf[BUFSZ];\n    struct passwd *pw = get_unix_pw();\n\n    buf[0] = '\\0';\n    if (pw)\n        (void)strcpy(buf, pw->pw_name);\n\n    return buf;\n}\n\n#ifdef __APPLE__\nextern int errno;\n\nvoid\nport_insert_pastebuf(buf)\nchar *buf;\n{\n    /* This should be replaced when there is a Cocoa port. */\n    const char *errfmt;\n    size_t len;\n    FILE *PB = popen(\"/usr/bin/pbcopy\", \"w\");\n\n    if (!PB) {\n        errfmt = \"Unable to start pbcopy (%d)\\n\";\n        goto error;\n    }\n\n    len = strlen(buf);\n    /* Remove the trailing \\n, carefully. */\n    if (buf[len - 1] == '\\n')\n        len--;\n\n    /* XXX Sorry, I'm too lazy to write a loop for output this short. */\n    if (len != fwrite(buf, 1, len, PB)) {\n        errfmt = \"Error sending data to pbcopy (%d)\\n\";\n        goto error;\n    }\n\n    if (pclose(PB) != -1) {\n        return;\n    }\n    errfmt = \"Error finishing pbcopy (%d)\\n\";\n\n error:\n    raw_printf(errfmt, strerror(errno));\n}\n#endif /* __APPLE__ */\n\nunsigned long\nsys_random_seed()\n{\n    unsigned long seed = 0L;\n    unsigned long pid = (unsigned long) getpid();\n    boolean no_seed = TRUE;\n#ifdef DEV_RANDOM\n    FILE *fptr;\n\n    fptr = fopen(DEV_RANDOM, \"r\");\n    if (fptr) {\n        fread(&seed, sizeof (long), 1, fptr);\n        has_strong_rngseed = TRUE;  /* decl.c */\n        no_seed = FALSE;\n        (void) fclose(fptr);\n    } else {\n        /* leaves clue, doesn't exit */\n        paniclog(\"sys_random_seed\", \"falling back to weak seed\");\n    }\n#endif\n    if (no_seed) {\n        seed = (unsigned long) getnow(); /* time((TIME_type) 0) */\n        /* Quick dirty band-aid to prevent PRNG prediction */\n        if (pid) {\n            if (!(pid & 3L))\n                pid -= 1L;\n            seed *= pid;\n        }\n    }\n    return seed;\n}\n\n/*unixmain.c*/\n"], "filenames": ["doc/fixes36.5", "src/topten.c", "src/windows.c", "sys/unix/unixmain.c"], "buggy_code_start_loc": [15, 1002, 246, 357], "buggy_code_end_loc": [15, 1002, 295, 455], "fixing_code_start_loc": [16, 1003, 246, 358], "fixing_code_end_loc": [18, 1004, 312, 455], "type": "CWE-120", "message": "In NetHack before 3.6.5, unknown options starting with -de and -i can cause a buffer overflow resulting in a crash or remote code execution/privilege escalation. This vulnerability affects systems that have NetHack installed suid/sgid and shared systems that allow users to influence command line options. Users should upgrade to NetHack 3.6.5.", "other": {"cve": {"id": "CVE-2020-5209", "sourceIdentifier": "security-advisories@github.com", "published": "2020-01-28T18:15:11.087", "lastModified": "2020-02-03T18:10:47.450", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In NetHack before 3.6.5, unknown options starting with -de and -i can cause a buffer overflow resulting in a crash or remote code execution/privilege escalation. This vulnerability affects systems that have NetHack installed suid/sgid and shared systems that allow users to influence command line options. Users should upgrade to NetHack 3.6.5."}, {"lang": "es", "value": "En NetHack versiones anteriores a 3.6.5, las opciones desconocidas que comienzan con -de y -i pueden causar un desbordamiento del b\u00fafer resultando en un bloqueo o en una ejecuci\u00f3n de c\u00f3digo remota/escalada de privilegios. Esta vulnerabilidad afecta a los sistemas que tienen instalado suid/sgid de NetHack y sistemas compartidos que permiten a usuarios influir en las opciones de l\u00ednea de comandos. Los usuarios deber\u00edan actualizar a NetHack versi\u00f3n 3.6.5."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:R/S:C/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.8, "impactScore": 3.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nethack:nethack:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.6.5", "matchCriteriaId": "9E31D988-1D9F-4AC6-9A4E-C4A96A2287F9"}]}]}], "references": [{"url": "https://github.com/NetHack/NetHack/commit/f3def5c0b999478da2d0a8f0b6a7c370a2065f77", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/NetHack/NetHack/security/advisories/GHSA-fw72-r8xm-45p8", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/NetHack/NetHack/commit/f3def5c0b999478da2d0a8f0b6a7c370a2065f77"}}