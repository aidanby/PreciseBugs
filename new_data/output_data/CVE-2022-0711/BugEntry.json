{"buggy_code": ["/*\n * HTTP protocol analyzer\n *\n * Copyright (C) 2018 HAProxy Technologies, Christopher Faulet <cfaulet@haproxy.com>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n *\n */\n\n#include <haproxy/acl.h>\n#include <haproxy/action-t.h>\n#include <haproxy/api.h>\n#include <haproxy/backend.h>\n#include <haproxy/base64.h>\n#include <haproxy/capture-t.h>\n#include <haproxy/cfgparse.h>\n#include <haproxy/channel.h>\n#include <haproxy/check.h>\n#include <haproxy/connection.h>\n#include <haproxy/errors.h>\n#include <haproxy/filters.h>\n#include <haproxy/http.h>\n#include <haproxy/http_ana.h>\n#include <haproxy/http_htx.h>\n#include <haproxy/htx.h>\n#include <haproxy/log.h>\n#include <haproxy/net_helper.h>\n#include <haproxy/proxy.h>\n#include <haproxy/regex.h>\n#include <haproxy/server-t.h>\n#include <haproxy/stats.h>\n#include <haproxy/stream.h>\n#include <haproxy/stream_interface.h>\n#include <haproxy/trace.h>\n#include <haproxy/uri_auth-t.h>\n#include <haproxy/vars.h>\n\n\n#define TRACE_SOURCE &trace_strm\n\nextern const char *stat_status_codes[];\n\nstruct pool_head *pool_head_requri __read_mostly = NULL;\nstruct pool_head *pool_head_capture __read_mostly = NULL;\n\n\nstatic void http_end_request(struct stream *s);\nstatic void http_end_response(struct stream *s);\n\nstatic void http_capture_headers(struct htx *htx, char **cap, struct cap_hdr *cap_hdr);\nstatic int http_del_hdr_value(char *start, char *end, char **from, char *next);\nstatic size_t http_fmt_req_line(const struct htx_sl *sl, char *str, size_t len);\nstatic void http_debug_stline(const char *dir, struct stream *s, const struct htx_sl *sl);\nstatic void http_debug_hdr(const char *dir, struct stream *s, const struct ist n, const struct ist v);\n\nstatic enum rule_result http_req_get_intercept_rule(struct proxy *px, struct list *def_rules, struct list *rules, struct stream *s);\nstatic enum rule_result http_res_get_intercept_rule(struct proxy *px, struct list *def_rules, struct list *rules, struct stream *s);\n\nstatic void http_manage_client_side_cookies(struct stream *s, struct channel *req);\nstatic void http_manage_server_side_cookies(struct stream *s, struct channel *res);\n\nstatic int http_stats_check_uri(struct stream *s, struct http_txn *txn, struct proxy *backend);\nstatic int http_handle_stats(struct stream *s, struct channel *req);\n\nstatic int http_handle_expect_hdr(struct stream *s, struct htx *htx, struct http_msg *msg);\nstatic int http_reply_100_continue(struct stream *s);\n\n/* This stream analyser waits for a complete HTTP request. It returns 1 if the\n * processing can continue on next analysers, or zero if it either needs more\n * data or wants to immediately abort the request (eg: timeout, error, ...). It\n * is tied to AN_REQ_WAIT_HTTP and may may remove itself from s->req.analysers\n * when it has nothing left to do, and may remove any analyser when it wants to\n * abort.\n */\nint http_wait_for_request(struct stream *s, struct channel *req, int an_bit)\n{\n\n\t/*\n\t * We will analyze a complete HTTP request to check the its syntax.\n\t *\n\t * Once the start line and all headers are received, we may perform a\n\t * capture of the error (if any), and we will set a few fields. We also\n\t * check for monitor-uri, logging and finally headers capture.\n\t */\n\tstruct session *sess = s->sess;\n\tstruct http_txn *txn = s->txn;\n\tstruct http_msg *msg = &txn->req;\n\tstruct htx *htx;\n\tstruct htx_sl *sl;\n\n\tDBG_TRACE_ENTER(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn, msg);\n\n\tif (unlikely(!IS_HTX_STRM(s))) {\n\t\t/* It is only possible when a TCP stream is upgrade to HTTP.\n\t\t * There is a transition period during which there is no\n\t\t * data. The stream is still in raw mode and SF_IGNORE flag is\n\t\t * still set. When this happens, the new mux is responsible to\n\t\t * handle all errors. Thus we may leave immediately.\n\t\t */\n\t\tBUG_ON(!(s->flags & SF_IGNORE) || !c_empty(&s->req));\n\n\t\t/* Don't connect for now */\n\t\tchannel_dont_connect(req);\n\n\t\t/* A SHUTR at this stage means we are performing a \"destructive\"\n\t\t * HTTP upgrade (TCP>H2). In this case, we can leave.\n\t\t */\n\t\tif (req->flags & CF_SHUTR) {\n\t\t\ts->logs.logwait = 0;\n                        s->logs.level = 0;\n\t\t\tchannel_abort(&s->req);\n\t\t\tchannel_abort(&s->res);\n\t\t\treq->analysers &= AN_REQ_FLT_END;\n\t\t\treq->analyse_exp = TICK_ETERNITY;\n\t\t\tDBG_TRACE_LEAVE(STRM_EV_STRM_ANA, s);\n\t\t\treturn 1;\n\t\t}\n\t\tDBG_TRACE_LEAVE(STRM_EV_STRM_ANA, s);\n\t\treturn 0;\n\t}\n\n\thtx = htxbuf(&req->buf);\n\n\t/* Parsing errors are caught here */\n\tif (htx->flags & (HTX_FL_PARSING_ERROR|HTX_FL_PROCESSING_ERROR)) {\n\t\tstream_inc_http_req_ctr(s);\n\t\tproxy_inc_fe_req_ctr(sess->listener, sess->fe);\n\t\tif (htx->flags & HTX_FL_PARSING_ERROR) {\n\t\t\tstream_inc_http_err_ctr(s);\n\t\t\tgoto return_bad_req;\n\t\t}\n\t\telse\n\t\t\tgoto return_int_err;\n\t}\n\n\t/* we're speaking HTTP here, so let's speak HTTP to the client */\n\ts->srv_error = http_return_srv_error;\n\n\tmsg->msg_state = HTTP_MSG_BODY;\n\tstream_inc_http_req_ctr(s);\n\tproxy_inc_fe_req_ctr(sess->listener, sess->fe); /* one more valid request for this FE */\n\n\t/* kill the pending keep-alive timeout */\n\treq->analyse_exp = TICK_ETERNITY;\n\n\tBUG_ON(htx_get_first_type(htx) != HTX_BLK_REQ_SL);\n\tsl = http_get_stline(htx);\n\n\t/* 0: we might have to print this header in debug mode */\n\tif (unlikely((global.mode & MODE_DEBUG) &&\n\t\t     (!(global.mode & MODE_QUIET) || (global.mode & MODE_VERBOSE)))) {\n\t\tint32_t pos;\n\n\t\thttp_debug_stline(\"clireq\", s, sl);\n\n\t\tfor (pos = htx_get_first(htx); pos != -1; pos = htx_get_next(htx, pos)) {\n\t\t\tstruct htx_blk *blk = htx_get_blk(htx, pos);\n\t\t\tenum htx_blk_type type = htx_get_blk_type(blk);\n\n\t\t\tif (type == HTX_BLK_EOH)\n\t\t\t\tbreak;\n\t\t\tif (type != HTX_BLK_HDR)\n\t\t\t\tcontinue;\n\n\t\t\thttp_debug_hdr(\"clihdr\", s,\n\t\t\t\t       htx_get_blk_name(htx, blk),\n\t\t\t\t       htx_get_blk_value(htx, blk));\n\t\t}\n\t}\n\n\t/*\n\t * 1: identify the method and the version. Also set HTTP flags\n\t */\n\ttxn->meth = sl->info.req.meth;\n\tif (sl->flags & HTX_SL_F_VER_11)\n                msg->flags |= HTTP_MSGF_VER_11;\n\tmsg->flags |= HTTP_MSGF_XFER_LEN;\n\tif (sl->flags & HTX_SL_F_CLEN)\n\t\tmsg->flags |= HTTP_MSGF_CNT_LEN;\n\telse if (sl->flags & HTX_SL_F_CHNK)\n\t\tmsg->flags |= HTTP_MSGF_TE_CHNK;\n\tif (sl->flags & HTX_SL_F_BODYLESS)\n\t\tmsg->flags |= HTTP_MSGF_BODYLESS;\n\tif (sl->flags & HTX_SL_F_CONN_UPG)\n\t\tmsg->flags |= HTTP_MSGF_CONN_UPG;\n\n\t/* we can make use of server redirect on GET and HEAD */\n\tif (txn->meth == HTTP_METH_GET || txn->meth == HTTP_METH_HEAD)\n\t\ts->flags |= SF_REDIRECTABLE;\n\telse if (txn->meth == HTTP_METH_OTHER && isteqi(htx_sl_req_meth(sl), ist(\"PRI\"))) {\n\t\t/* PRI is reserved for the HTTP/2 preface */\n\t\tgoto return_bad_req;\n\t}\n\n\t/*\n\t * 2: check if the URI matches the monitor_uri.  We have to do this for\n\t * every request which gets in, because the monitor-uri is defined by\n\t * the frontend. If the monitor-uri starts with a '/', the matching is\n\t * done against the request's path. Otherwise, the request's uri is\n\t * used. It is a workaround to let HTTP/2 health-checks work as\n\t * expected.\n\t */\n\tif (unlikely(sess->fe->monitor_uri_len != 0)) {\n\t\tconst struct ist monitor_uri = ist2(sess->fe->monitor_uri,\n\t\t                                    sess->fe->monitor_uri_len);\n\t\tstruct http_uri_parser parser = http_uri_parser_init(htx_sl_req_uri(sl));\n\n\t\tif ((istptr(monitor_uri)[0] == '/' &&\n\t\t     isteq(http_parse_path(&parser), monitor_uri)) ||\n\t\t    isteq(htx_sl_req_uri(sl), monitor_uri)) {\n\t\t\t/*\n\t\t\t * We have found the monitor URI\n\t\t\t */\n\t\t\tstruct acl_cond *cond;\n\n\t\t\ts->flags |= SF_MONITOR;\n\t\t\t_HA_ATOMIC_INC(&sess->fe->fe_counters.intercepted_req);\n\n\t\t\t/* Check if we want to fail this monitor request or not */\n\t\t\tlist_for_each_entry(cond, &sess->fe->mon_fail_cond, list) {\n\t\t\t\tint ret = acl_exec_cond(cond, sess->fe, sess, s, SMP_OPT_DIR_REQ|SMP_OPT_FINAL);\n\n\t\t\t\tret = acl_pass(ret);\n\t\t\t\tif (cond->pol == ACL_COND_UNLESS)\n\t\t\t\t\tret = !ret;\n\n\t\t\t\tif (ret) {\n\t\t\t\t\t/* we fail this request, let's return 503 service unavail */\n\t\t\t\t\ttxn->status = 503;\n\t\t\t\t\tif (!(s->flags & SF_ERR_MASK))\n\t\t\t\t\t\ts->flags |= SF_ERR_LOCAL; /* we don't want a real error here */\n\t\t\t\t\tgoto return_prx_cond;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* nothing to fail, let's reply normally */\n\t\t\ttxn->status = 200;\n\t\t\tif (!(s->flags & SF_ERR_MASK))\n\t\t\t\ts->flags |= SF_ERR_LOCAL; /* we don't want a real error here */\n\t\t\tgoto return_prx_cond;\n\t\t}\n\t}\n\n\t/*\n\t * 3: Maybe we have to copy the original REQURI for the logs ?\n\t * Note: we cannot log anymore if the request has been\n\t * classified as invalid.\n\t */\n\tif (unlikely(s->logs.logwait & LW_REQ)) {\n\t\t/* we have a complete HTTP request that we must log */\n\t\tif ((txn->uri = pool_alloc(pool_head_requri)) != NULL) {\n\t\t\tsize_t len;\n\n\t\t\tlen = http_fmt_req_line(sl, txn->uri, global.tune.requri_len - 1);\n\t\t\ttxn->uri[len] = 0;\n\n\t\t\tif (!(s->logs.logwait &= ~(LW_REQ|LW_INIT)))\n\t\t\t\ts->do_log(s);\n\t\t} else {\n\t\t\tha_alert(\"HTTP logging : out of memory.\\n\");\n\t\t}\n\t}\n\n\t/* if the frontend has \"option http-use-proxy-header\", we'll check if\n\t * we have what looks like a proxied connection instead of a connection,\n\t * and in this case set the TX_USE_PX_CONN flag to use Proxy-connection.\n\t * Note that this is *not* RFC-compliant, however browsers and proxies\n\t * happen to do that despite being non-standard :-(\n\t * We consider that a request not beginning with either '/' or '*' is\n\t * a proxied connection, which covers both \"scheme://location\" and\n\t * CONNECT ip:port.\n\t */\n\tif ((sess->fe->options2 & PR_O2_USE_PXHDR) &&\n\t    *HTX_SL_REQ_UPTR(sl) != '/' && *HTX_SL_REQ_UPTR(sl) != '*')\n\t\ttxn->flags |= TX_USE_PX_CONN;\n\n\t/* 5: we may need to capture headers */\n\tif (unlikely((s->logs.logwait & LW_REQHDR) && s->req_cap))\n\t\thttp_capture_headers(htx, s->req_cap, sess->fe->req_cap);\n\n\t/* we may have to wait for the request's body */\n\tif (s->be->options & PR_O_WREQ_BODY)\n\t\treq->analysers |= AN_REQ_HTTP_BODY;\n\n\t/*\n\t * RFC7234#4:\n\t *   A cache MUST write through requests with methods\n\t *   that are unsafe (Section 4.2.1 of [RFC7231]) to\n\t *   the origin server; i.e., a cache is not allowed\n\t *   to generate a reply to such a request before\n\t *   having forwarded the request and having received\n\t *   a corresponding response.\n\t *\n\t * RFC7231#4.2.1:\n\t *   Of the request methods defined by this\n\t *   specification, the GET, HEAD, OPTIONS, and TRACE\n\t *   methods are defined to be safe.\n\t */\n\tif (likely(txn->meth == HTTP_METH_GET ||\n\t\t   txn->meth == HTTP_METH_HEAD ||\n\t\t   txn->meth == HTTP_METH_OPTIONS ||\n\t\t   txn->meth == HTTP_METH_TRACE))\n\t\ttxn->flags |= TX_CACHEABLE | TX_CACHE_COOK;\n\n\t/* end of job, return OK */\n\treq->analysers &= ~an_bit;\n\treq->analyse_exp = TICK_ETERNITY;\n\n\tDBG_TRACE_LEAVE(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\treturn 1;\n\n return_int_err:\n\ttxn->status = 500;\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_INTERNAL;\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.internal_errors);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->internal_errors);\n\tgoto return_prx_cond;\n\n return_bad_req:\n\ttxn->status = 400;\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.failed_req);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->failed_req);\n\t/* fall through */\n\n return_prx_cond:\n\thttp_reply_and_close(s, txn->status, http_error_message(s));\n\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_PRXCOND;\n\tif (!(s->flags & SF_FINST_MASK))\n\t\ts->flags |= SF_FINST_R;\n\n\tDBG_TRACE_DEVEL(\"leaving on error\",\n\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA|STRM_EV_HTTP_ERR, s, txn);\n\treturn 0;\n}\n\n\n/* This stream analyser runs all HTTP request processing which is common to\n * frontends and backends, which means blocking ACLs, filters, connection-close,\n * reqadd, stats and redirects. This is performed for the designated proxy.\n * It returns 1 if the processing can continue on next analysers, or zero if it\n * either needs more data or wants to immediately abort the request (eg: deny,\n * error, ...).\n */\nint http_process_req_common(struct stream *s, struct channel *req, int an_bit, struct proxy *px)\n{\n\tstruct list *def_rules, *rules;\n\tstruct session *sess = s->sess;\n\tstruct http_txn *txn = s->txn;\n\tstruct http_msg *msg = &txn->req;\n\tstruct htx *htx;\n\tstruct redirect_rule *rule;\n\tenum rule_result verdict;\n\tstruct connection *conn = objt_conn(sess->origin);\n\n\tDBG_TRACE_ENTER(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn, msg);\n\n\thtx = htxbuf(&req->buf);\n\n\t/* just in case we have some per-backend tracking. Only called the first\n\t * execution of the analyser. */\n\tif (!s->current_rule && !s->current_rule_list)\n\t\tstream_inc_be_http_req_ctr(s);\n\n\tdef_rules = ((px->defpx && (an_bit == AN_REQ_HTTP_PROCESS_FE || px != sess->fe)) ? &px->defpx->http_req_rules : NULL);\n\trules = &px->http_req_rules;\n\n\t/* evaluate http-request rules */\n\tif ((def_rules && !LIST_ISEMPTY(def_rules)) || !LIST_ISEMPTY(rules)) {\n\t\tverdict = http_req_get_intercept_rule(px, def_rules, rules, s);\n\n\t\tswitch (verdict) {\n\t\tcase HTTP_RULE_RES_YIELD: /* some data miss, call the function later. */\n\t\t\tgoto return_prx_yield;\n\n\t\tcase HTTP_RULE_RES_CONT:\n\t\tcase HTTP_RULE_RES_STOP: /* nothing to do */\n\t\t\tbreak;\n\n\t\tcase HTTP_RULE_RES_DENY: /* deny or tarpit */\n\t\t\tif (txn->flags & TX_CLTARPIT)\n\t\t\t\tgoto tarpit;\n\t\t\tgoto deny;\n\n\t\tcase HTTP_RULE_RES_ABRT: /* abort request, response already sent. Eg: auth */\n\t\t\tgoto return_prx_cond;\n\n\t\tcase HTTP_RULE_RES_DONE: /* OK, but terminate request processing (eg: redirect) */\n\t\t\tgoto done;\n\n\t\tcase HTTP_RULE_RES_BADREQ: /* failed with a bad request */\n\t\t\tgoto return_bad_req;\n\n\t\tcase HTTP_RULE_RES_ERROR: /* failed with a bad request */\n\t\t\tgoto return_int_err;\n\t\t}\n\t}\n\n\tif (conn && (conn->flags & CO_FL_EARLY_DATA) &&\n\t    (conn->flags & (CO_FL_EARLY_SSL_HS | CO_FL_SSL_WAIT_HS))) {\n\t\tstruct http_hdr_ctx ctx;\n\n\t\tctx.blk = NULL;\n\t\tif (!http_find_header(htx, ist(\"Early-Data\"), &ctx, 0)) {\n\t\t\tif (unlikely(!http_add_header(htx, ist(\"Early-Data\"), ist(\"1\"))))\n\t\t\t\tgoto return_int_err;\n\t\t}\n\t}\n\n\t/* OK at this stage, we know that the request was accepted according to\n\t * the http-request rules, we can check for the stats. Note that the\n\t * URI is detected *before* the req* rules in order not to be affected\n\t * by a possible reqrep, while they are processed *after* so that a\n\t * reqdeny can still block them. This clearly needs to change in 1.6!\n\t */\n\tif (!s->target && http_stats_check_uri(s, txn, px)) {\n\t\ts->target = &http_stats_applet.obj_type;\n\t\tif (unlikely(!si_register_handler(&s->si[1], objt_applet(s->target)))) {\n\t\t\ts->logs.tv_request = now;\n\t\t\tif (!(s->flags & SF_ERR_MASK))\n\t\t\t\ts->flags |= SF_ERR_RESOURCE;\n\t\t\tgoto return_int_err;\n\t\t}\n\n\t\t/* parse the whole stats request and extract the relevant information */\n\t\thttp_handle_stats(s, req);\n\t\tverdict = http_req_get_intercept_rule(px, NULL, &px->uri_auth->http_req_rules, s);\n\t\t/* not all actions implemented: deny, allow, auth */\n\n\t\tif (verdict == HTTP_RULE_RES_DENY) /* stats http-request deny */\n\t\t\tgoto deny;\n\n\t\tif (verdict == HTTP_RULE_RES_ABRT) /* stats auth / stats http-request auth */\n\t\t\tgoto return_prx_cond;\n\n\t\tif (verdict == HTTP_RULE_RES_BADREQ) /* failed with a bad request */\n\t\t\tgoto return_bad_req;\n\n\t\tif (verdict == HTTP_RULE_RES_ERROR) /* failed with a bad request */\n\t\t\tgoto return_int_err;\n\t}\n\n\t/* Proceed with the applets now. */\n\tif (unlikely(objt_applet(s->target))) {\n\t\tif (sess->fe == s->be) /* report it if the request was intercepted by the frontend */\n\t\t\t_HA_ATOMIC_INC(&sess->fe->fe_counters.intercepted_req);\n\n\t\tif (http_handle_expect_hdr(s, htx, msg) == -1)\n\t\t\tgoto return_int_err;\n\n\t\tif (!(s->flags & SF_ERR_MASK))      // this is not really an error but it is\n\t\t\ts->flags |= SF_ERR_LOCAL;   // to mark that it comes from the proxy\n\t\tif (!(s->flags & SF_FINST_MASK))\n\t\t\ts->flags |= SF_FINST_R;\n\n\t\tif (HAS_FILTERS(s))\n\t\t\treq->analysers |= AN_REQ_FLT_HTTP_HDRS;\n\n\t\t/* enable the minimally required analyzers to handle keep-alive and compression on the HTTP response */\n\t\treq->analysers &= (AN_REQ_HTTP_BODY | AN_REQ_FLT_HTTP_HDRS | AN_REQ_FLT_END);\n\t\treq->analysers &= ~AN_REQ_FLT_XFER_DATA;\n\t\treq->analysers |= AN_REQ_HTTP_XFER_BODY;\n\n\t\treq->flags |= CF_SEND_DONTWAIT;\n\t\ts->flags |= SF_ASSIGNED;\n\t\tgoto done;\n\t}\n\n\t/* check whether we have some ACLs set to redirect this request */\n\tlist_for_each_entry(rule, &px->redirect_rules, list) {\n\t\tif (rule->cond) {\n\t\t\tint ret;\n\n\t\t\tret = acl_exec_cond(rule->cond, px, sess, s, SMP_OPT_DIR_REQ|SMP_OPT_FINAL);\n\t\t\tret = acl_pass(ret);\n\t\t\tif (rule->cond->pol == ACL_COND_UNLESS)\n\t\t\t\tret = !ret;\n\t\t\tif (!ret)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (!http_apply_redirect_rule(rule, s, txn))\n\t\t\tgoto return_int_err;\n\t\tgoto done;\n\t}\n\n\t/* POST requests may be accompanied with an \"Expect: 100-Continue\" header.\n\t * If this happens, then the data will not come immediately, so we must\n\t * send all what we have without waiting. Note that due to the small gain\n\t * in waiting for the body of the request, it's easier to simply put the\n\t * CF_SEND_DONTWAIT flag any time. It's a one-shot flag so it will remove\n\t * itself once used.\n\t */\n\treq->flags |= CF_SEND_DONTWAIT;\n\n done:\t/* done with this analyser, continue with next ones that the calling\n\t * points will have set, if any.\n\t */\n\treq->analyse_exp = TICK_ETERNITY;\n done_without_exp: /* done with this analyser, but don't reset the analyse_exp. */\n\treq->analysers &= ~an_bit;\n\ts->current_rule = s->current_rule_list = NULL;\n\tDBG_TRACE_LEAVE(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\treturn 1;\n\n tarpit:\n\t/* Allow cookie logging\n\t */\n\tif (s->be->cookie_name || sess->fe->capture_name)\n\t\thttp_manage_client_side_cookies(s, req);\n\n\t/* When a connection is tarpitted, we use the tarpit timeout,\n\t * which may be the same as the connect timeout if unspecified.\n\t * If unset, then set it to zero because we really want it to\n\t * eventually expire. We build the tarpit as an analyser.\n\t */\n\tchannel_htx_erase(&s->req, htx);\n\n\t/* wipe the request out so that we can drop the connection early\n\t * if the client closes first.\n\t */\n\tchannel_dont_connect(req);\n\n\treq->analysers &= AN_REQ_FLT_END; /* remove switching rules etc... */\n\treq->analysers |= AN_REQ_HTTP_TARPIT;\n\treq->analyse_exp = tick_add_ifset(now_ms,  s->be->timeout.tarpit);\n\tif (!req->analyse_exp)\n\t\treq->analyse_exp = tick_add(now_ms, 0);\n\tstream_inc_http_err_ctr(s);\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.denied_req);\n\tif (s->flags & SF_BE_ASSIGNED)\n\t\t_HA_ATOMIC_INC(&s->be->be_counters.denied_req);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->denied_req);\n\tgoto done_without_exp;\n\n deny:\t/* this request was blocked (denied) */\n\n\t/* Allow cookie logging\n\t */\n\tif (s->be->cookie_name || sess->fe->capture_name)\n\t\thttp_manage_client_side_cookies(s, req);\n\n\ts->logs.tv_request = now;\n\tstream_inc_http_err_ctr(s);\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.denied_req);\n\tif (s->flags & SF_BE_ASSIGNED)\n\t\t_HA_ATOMIC_INC(&s->be->be_counters.denied_req);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->denied_req);\n\tgoto return_prx_err;\n\n return_int_err:\n\ttxn->status = 500;\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_INTERNAL;\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.internal_errors);\n\tif (s->flags & SF_BE_ASSIGNED)\n\t\t_HA_ATOMIC_INC(&s->be->be_counters.internal_errors);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->internal_errors);\n\tgoto return_prx_err;\n\n return_bad_req:\n\ttxn->status = 400;\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.failed_req);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->failed_req);\n\t/* fall through */\n\n return_prx_err:\n\thttp_reply_and_close(s, txn->status, http_error_message(s));\n\t/* fall through */\n\n return_prx_cond:\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_PRXCOND;\n\tif (!(s->flags & SF_FINST_MASK))\n\t\ts->flags |= SF_FINST_R;\n\n\treq->analysers &= AN_REQ_FLT_END;\n\treq->analyse_exp = TICK_ETERNITY;\n\ts->current_rule = s->current_rule_list = NULL;\n\tDBG_TRACE_DEVEL(\"leaving on error\",\n\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA|STRM_EV_HTTP_ERR, s, txn);\n\treturn 0;\n\n return_prx_yield:\n\tchannel_dont_connect(req);\n\tDBG_TRACE_DEVEL(\"waiting for more data\",\n\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\treturn 0;\n}\n\n/* This function performs all the processing enabled for the current request.\n * It returns 1 if the processing can continue on next analysers, or zero if it\n * needs more data, encounters an error, or wants to immediately abort the\n * request. It relies on buffers flags, and updates s->req.analysers.\n */\nint http_process_request(struct stream *s, struct channel *req, int an_bit)\n{\n\tstruct session *sess = s->sess;\n\tstruct http_txn *txn = s->txn;\n\tstruct htx *htx;\n\tstruct connection *cli_conn = objt_conn(strm_sess(s)->origin);\n\n\tDBG_TRACE_ENTER(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\n\t/*\n\t * Right now, we know that we have processed the entire headers\n\t * and that unwanted requests have been filtered out. We can do\n\t * whatever we want with the remaining request. Also, now we\n\t * may have separate values for ->fe, ->be.\n\t */\n\thtx = htxbuf(&req->buf);\n\n\t/*\n\t * 7: Now we can work with the cookies.\n\t * Note that doing so might move headers in the request, but\n\t * the fields will stay coherent and the URI will not move.\n\t * This should only be performed in the backend.\n\t */\n\tif (s->be->cookie_name || sess->fe->capture_name)\n\t\thttp_manage_client_side_cookies(s, req);\n\n\t/* 8: Generate unique ID if a \"unique-id-format\" is defined.\n\t *\n\t * A unique ID is generated even when it is not sent to ensure that the ID can make use of\n\t * fetches only available in the HTTP request processing stage.\n\t */\n\tif (!LIST_ISEMPTY(&sess->fe->format_unique_id)) {\n\t\tstruct ist unique_id = stream_generate_unique_id(s, &sess->fe->format_unique_id);\n\n\t\tif (!isttest(unique_id)) {\n\t\t\tif (!(s->flags & SF_ERR_MASK))\n\t\t\t\ts->flags |= SF_ERR_RESOURCE;\n\t\t\tgoto return_int_err;\n\t\t}\n\n\t\t/* send unique ID if a \"unique-id-header\" is defined */\n\t\tif (isttest(sess->fe->header_unique_id) &&\n\t\t    unlikely(!http_add_header(htx, sess->fe->header_unique_id, s->unique_id)))\n\t\t\t\tgoto return_int_err;\n\t}\n\n\t/*\n\t * 9: add X-Forwarded-For if either the frontend or the backend\n\t * asks for it.\n\t */\n\tif ((sess->fe->options | s->be->options) & PR_O_FWDFOR) {\n\t\tconst struct sockaddr_storage *src = si_src(&s->si[0]);\n\t\tstruct http_hdr_ctx ctx = { .blk = NULL };\n\t\tstruct ist hdr = ist2(s->be->fwdfor_hdr_len ? s->be->fwdfor_hdr_name : sess->fe->fwdfor_hdr_name,\n\t\t\t\t      s->be->fwdfor_hdr_len ? s->be->fwdfor_hdr_len : sess->fe->fwdfor_hdr_len);\n\n\t\tif (!((sess->fe->options | s->be->options) & PR_O_FF_ALWAYS) &&\n\t\t    http_find_header(htx, hdr, &ctx, 0)) {\n\t\t\t/* The header is set to be added only if none is present\n\t\t\t * and we found it, so don't do anything.\n\t\t\t */\n\t\t}\n\t\telse if (src && src->ss_family == AF_INET) {\n\t\t\t/* Add an X-Forwarded-For header unless the source IP is\n\t\t\t * in the 'except' network range.\n\t\t\t */\n\t\t\tif (ipcmp2net(src, &sess->fe->except_xff_net) &&\n\t\t\t    ipcmp2net(src, &s->be->except_xff_net)) {\n\t\t\t\tunsigned char *pn = (unsigned char *)&((struct sockaddr_in *)src)->sin_addr;\n\n\t\t\t\t/* Note: we rely on the backend to get the header name to be used for\n\t\t\t\t * x-forwarded-for, because the header is really meant for the backends.\n\t\t\t\t * However, if the backend did not specify any option, we have to rely\n\t\t\t\t * on the frontend's header name.\n\t\t\t\t */\n\t\t\t\tchunk_printf(&trash, \"%d.%d.%d.%d\", pn[0], pn[1], pn[2], pn[3]);\n\t\t\t\tif (unlikely(!http_add_header(htx, hdr, ist2(trash.area, trash.data))))\n\t\t\t\t\tgoto return_int_err;\n\t\t\t}\n\t\t}\n\t\telse if (src && src->ss_family == AF_INET6) {\n\t\t\t/* Add an X-Forwarded-For header unless the source IP is\n\t\t\t * in the 'except' network range.\n\t\t\t */\n\t\t\tif (ipcmp2net(src, &sess->fe->except_xff_net) &&\n\t\t\t    ipcmp2net(src, &s->be->except_xff_net)) {\n\t\t\t\tchar pn[INET6_ADDRSTRLEN];\n\n\t\t\t\tinet_ntop(AF_INET6,\n\t\t\t\t\t  (const void *)&((struct sockaddr_in6 *)(src))->sin6_addr,\n\t\t\t\t\t  pn, sizeof(pn));\n\n\t\t\t\t/* Note: we rely on the backend to get the header name to be used for\n\t\t\t\t * x-forwarded-for, because the header is really meant for the backends.\n\t\t\t\t * However, if the backend did not specify any option, we have to rely\n\t\t\t\t * on the frontend's header name.\n\t\t\t\t */\n\t\t\t\tchunk_printf(&trash, \"%s\", pn);\n\t\t\t\tif (unlikely(!http_add_header(htx, hdr, ist2(trash.area, trash.data))))\n\t\t\t\t\tgoto return_int_err;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * 10: add X-Original-To if either the frontend or the backend\n\t * asks for it.\n\t */\n\tif ((sess->fe->options | s->be->options) & PR_O_ORGTO) {\n\t\tconst struct sockaddr_storage *dst = si_dst(&s->si[0]);\n\t\tstruct ist hdr = ist2(s->be->orgto_hdr_len ? s->be->orgto_hdr_name : sess->fe->orgto_hdr_name,\n\t\t\t\t      s->be->orgto_hdr_len ? s->be->orgto_hdr_len  : sess->fe->orgto_hdr_len);\n\n\t\tif (dst && dst->ss_family == AF_INET) {\n\t\t\t/* Add an X-Original-To header unless the destination IP is\n\t\t\t * in the 'except' network range.\n\t\t\t */\n\t\t\tif (ipcmp2net(dst, &sess->fe->except_xot_net) &&\n\t\t\t    ipcmp2net(dst, &s->be->except_xot_net)) {\n\t\t\t\tunsigned char *pn = (unsigned char *)&((struct sockaddr_in *)dst)->sin_addr;\n\n\t\t\t\t/* Note: we rely on the backend to get the header name to be used for\n\t\t\t\t * x-original-to, because the header is really meant for the backends.\n\t\t\t\t * However, if the backend did not specify any option, we have to rely\n\t\t\t\t * on the frontend's header name.\n\t\t\t\t */\n\t\t\t\tchunk_printf(&trash, \"%d.%d.%d.%d\", pn[0], pn[1], pn[2], pn[3]);\n\t\t\t\tif (unlikely(!http_add_header(htx, hdr, ist2(trash.area, trash.data))))\n\t\t\t\t\tgoto return_int_err;\n\t\t\t}\n\t\t}\n\t\telse if (dst && dst->ss_family == AF_INET6) {\n\t\t\t/* Add an X-Original-To header unless the source IP is\n\t\t\t * in the 'except' network range.\n\t\t\t */\n\t\t\tif (ipcmp2net(dst, &sess->fe->except_xot_net) &&\n\t\t\t    ipcmp2net(dst, &s->be->except_xot_net)) {\n\t\t\t\tchar pn[INET6_ADDRSTRLEN];\n\n\t\t\t\tinet_ntop(AF_INET6,\n\t\t\t\t\t  (const void *)&((struct sockaddr_in6 *)dst)->sin6_addr,\n\t\t\t\t\t  pn, sizeof(pn));\n\n\t\t\t\t/* Note: we rely on the backend to get the header name to be used for\n\t\t\t\t * x-forwarded-for, because the header is really meant for the backends.\n\t\t\t\t * However, if the backend did not specify any option, we have to rely\n\t\t\t\t * on the frontend's header name.\n\t\t\t\t */\n\t\t\t\tchunk_printf(&trash, \"%s\", pn);\n\t\t\t\tif (unlikely(!http_add_header(htx, hdr, ist2(trash.area, trash.data))))\n\t\t\t\t\tgoto return_int_err;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Filter the request headers if there are filters attached to the\n\t * stream.\n\t */\n\tif (HAS_FILTERS(s))\n\t\treq->analysers |= AN_REQ_FLT_HTTP_HDRS;\n\n\t/* If we have no server assigned yet and we're balancing on url_param\n\t * with a POST request, we may be interested in checking the body for\n\t * that parameter. This will be done in another analyser.\n\t */\n\tif (!(s->flags & (SF_ASSIGNED|SF_DIRECT)) &&\n\t    s->txn->meth == HTTP_METH_POST &&\n\t    (s->be->lbprm.algo & BE_LB_ALGO) == BE_LB_ALGO_PH) {\n\t\tchannel_dont_connect(req);\n\t\treq->analysers |= AN_REQ_HTTP_BODY;\n\t}\n\n\treq->analysers &= ~AN_REQ_FLT_XFER_DATA;\n\treq->analysers |= AN_REQ_HTTP_XFER_BODY;\n\n\t/* We expect some data from the client. Unless we know for sure\n\t * we already have a full request, we have to re-enable quick-ack\n\t * in case we previously disabled it, otherwise we might cause\n\t * the client to delay further data.\n\t */\n\tif ((sess->listener && (sess->listener->options & LI_O_NOQUICKACK)) && !(htx->flags & HTX_FL_EOM))\n\t\tconn_set_quickack(cli_conn, 1);\n\n\t/*************************************************************\n\t * OK, that's finished for the headers. We have done what we *\n\t * could. Let's switch to the DATA state.                    *\n\t ************************************************************/\n\treq->analyse_exp = TICK_ETERNITY;\n\treq->analysers &= ~an_bit;\n\n\ts->logs.tv_request = now;\n\t/* OK let's go on with the BODY now */\n\tDBG_TRACE_LEAVE(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\treturn 1;\n\n return_int_err:\n\ttxn->status = 500;\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_INTERNAL;\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.internal_errors);\n\tif (s->flags & SF_BE_ASSIGNED)\n\t\t_HA_ATOMIC_INC(&s->be->be_counters.internal_errors);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->internal_errors);\n\n\thttp_reply_and_close(s, txn->status, http_error_message(s));\n\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_PRXCOND;\n\tif (!(s->flags & SF_FINST_MASK))\n\t\ts->flags |= SF_FINST_R;\n\n\tDBG_TRACE_DEVEL(\"leaving on error\",\n\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA|STRM_EV_HTTP_ERR, s, txn);\n\treturn 0;\n}\n\n/* This function is an analyser which processes the HTTP tarpit. It always\n * returns zero, at the beginning because it prevents any other processing\n * from occurring, and at the end because it terminates the request.\n */\nint http_process_tarpit(struct stream *s, struct channel *req, int an_bit)\n{\n\tstruct http_txn *txn = s->txn;\n\n\tDBG_TRACE_ENTER(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn, &txn->req);\n\t/* This connection is being tarpitted. The CLIENT side has\n\t * already set the connect expiration date to the right\n\t * timeout. We just have to check that the client is still\n\t * there and that the timeout has not expired.\n\t */\n\tchannel_dont_connect(req);\n\tif ((req->flags & (CF_SHUTR|CF_READ_ERROR)) == 0 &&\n\t    !tick_is_expired(req->analyse_exp, now_ms)) {\n\t\t/* Be sure to drain all data from the request channel */\n\t\tchannel_htx_erase(req, htxbuf(&req->buf));\n\t\tDBG_TRACE_DEVEL(\"waiting for tarpit timeout expiry\",\n\t\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\t\treturn 0;\n\t}\n\n\n\t/* We will set the queue timer to the time spent, just for\n\t * logging purposes. We fake a 500 server error, so that the\n\t * attacker will not suspect his connection has been tarpitted.\n\t * It will not cause trouble to the logs because we can exclude\n\t * the tarpitted connections by filtering on the 'PT' status flags.\n\t */\n\ts->logs.t_queue = tv_ms_elapsed(&s->logs.tv_accept, &now);\n\n\thttp_reply_and_close(s, txn->status, (!(req->flags & CF_READ_ERROR) ? http_error_message(s) : NULL));\n\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_PRXCOND;\n\tif (!(s->flags & SF_FINST_MASK))\n\t\ts->flags |= SF_FINST_T;\n\n\tDBG_TRACE_LEAVE(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\treturn 0;\n}\n\n/* This function is an analyser which waits for the HTTP request body. It waits\n * for either the buffer to be full, or the full advertised contents to have\n * reached the buffer. It must only be called after the standard HTTP request\n * processing has occurred, because it expects the request to be parsed and will\n * look for the Expect header. It may send a 100-Continue interim response. It\n * takes in input any state starting from HTTP_MSG_BODY and leaves with one of\n * HTTP_MSG_CHK_SIZE, HTTP_MSG_DATA or HTTP_MSG_TRAILERS. It returns zero if it\n * needs to read more data, or 1 once it has completed its analysis.\n */\nint http_wait_for_request_body(struct stream *s, struct channel *req, int an_bit)\n{\n\tstruct session *sess = s->sess;\n\tstruct http_txn *txn = s->txn;\n\tstruct http_msg *msg = &s->txn->req;\n\n\tDBG_TRACE_ENTER(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn, msg);\n\n\n\tswitch (http_wait_for_msg_body(s, req, s->be->timeout.httpreq, 0)) {\n\tcase HTTP_RULE_RES_CONT:\n\t\tgoto http_end;\n\tcase HTTP_RULE_RES_YIELD:\n\t\tgoto missing_data_or_waiting;\n\tcase HTTP_RULE_RES_BADREQ:\n\t\tgoto return_bad_req;\n\tcase HTTP_RULE_RES_ERROR:\n\t\tgoto return_int_err;\n\tcase HTTP_RULE_RES_ABRT:\n\t\tgoto return_prx_cond;\n\tdefault:\n\t\tgoto return_int_err;\n\t}\n\n http_end:\n\t/* The situation will not evolve, so let's give up on the analysis. */\n\ts->logs.tv_request = now;  /* update the request timer to reflect full request */\n\treq->analysers &= ~an_bit;\n\treq->analyse_exp = TICK_ETERNITY;\n\tDBG_TRACE_LEAVE(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\treturn 1;\n\n missing_data_or_waiting:\n\tchannel_dont_connect(req);\n\tDBG_TRACE_DEVEL(\"waiting for more data\",\n\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\treturn 0;\n\n return_int_err:\n\ttxn->status = 500;\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_INTERNAL;\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.internal_errors);\n\tif (s->flags & SF_BE_ASSIGNED)\n\t\t_HA_ATOMIC_INC(&s->be->be_counters.internal_errors);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->internal_errors);\n\tgoto return_prx_err;\n\n return_bad_req: /* let's centralize all bad requests */\n\ttxn->status = 400;\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.failed_req);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->failed_req);\n\t/* fall through */\n\n return_prx_err:\n\thttp_reply_and_close(s, txn->status, http_error_message(s));\n\t/* fall through */\n\n return_prx_cond:\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_PRXCOND;\n\tif (!(s->flags & SF_FINST_MASK))\n\t\ts->flags |= (msg->msg_state < HTTP_MSG_DATA ? SF_FINST_R : SF_FINST_D);\n\n\treq->analysers &= AN_REQ_FLT_END;\n\treq->analyse_exp = TICK_ETERNITY;\n\tDBG_TRACE_DEVEL(\"leaving on error\",\n\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA|STRM_EV_HTTP_ERR, s, txn);\n\treturn 0;\n}\n\n/* This function is an analyser which forwards request body (including chunk\n * sizes if any). It is called as soon as we must forward, even if we forward\n * zero byte. The only situation where it must not be called is when we're in\n * tunnel mode and we want to forward till the close. It's used both to forward\n * remaining data and to resync after end of body. It expects the msg_state to\n * be between MSG_BODY and MSG_DONE (inclusive). It returns zero if it needs to\n * read more data, or 1 once we can go on with next request or end the stream.\n * When in MSG_DATA or MSG_TRAILERS, it will automatically forward chunk_len\n * bytes of pending data + the headers if not already done.\n */\nint http_request_forward_body(struct stream *s, struct channel *req, int an_bit)\n{\n\tstruct session *sess = s->sess;\n\tstruct http_txn *txn = s->txn;\n\tstruct http_msg *msg = &txn->req;\n\tstruct htx *htx;\n\tshort status = 0;\n\tint ret;\n\n\tDBG_TRACE_ENTER(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn, msg);\n\n\thtx = htxbuf(&req->buf);\n\n\tif (htx->flags & HTX_FL_PARSING_ERROR)\n\t\tgoto return_bad_req;\n\tif (htx->flags & HTX_FL_PROCESSING_ERROR)\n\t\tgoto return_int_err;\n\n\tif ((req->flags & (CF_READ_ERROR|CF_READ_TIMEOUT|CF_WRITE_ERROR|CF_WRITE_TIMEOUT)) ||\n\t    ((req->flags & CF_SHUTW) && (req->to_forward || co_data(req)))) {\n\t\t/* Output closed while we were sending data. We must abort and\n\t\t * wake the other side up.\n\t\t *\n\t\t * If we have finished to send the request and the response is\n\t\t * still in progress, don't catch write error on the request\n\t\t * side if it is in fact a read error on the server side.\n\t\t */\n\t\tif (msg->msg_state == HTTP_MSG_DONE && (s->res.flags & CF_READ_ERROR) && s->res.analysers)\n\t\t\treturn 0;\n\n\t\t/* Don't abort yet if we had L7 retries activated and it\n\t\t * was a write error, we may recover.\n\t\t */\n\t\tif (!(req->flags & (CF_READ_ERROR | CF_READ_TIMEOUT)) &&\n\t\t    (s->si[1].flags & SI_FL_L7_RETRY)) {\n\t\t\tDBG_TRACE_DEVEL(\"leaving on L7 retry\",\n\t\t\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA|STRM_EV_HTTP_ERR, s, txn);\n\t\t\treturn 0;\n\t\t}\n\t\tmsg->msg_state = HTTP_MSG_ERROR;\n\t\thttp_end_request(s);\n\t\thttp_end_response(s);\n\t\tDBG_TRACE_DEVEL(\"leaving on error\",\n\t\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA|STRM_EV_HTTP_ERR, s, txn);\n\t\treturn 1;\n\t}\n\n\t/* Note that we don't have to send 100-continue back because we don't\n\t * need the data to complete our job, and it's up to the server to\n\t * decide whether to return 100, 417 or anything else in return of\n\t * an \"Expect: 100-continue\" header.\n\t */\n\tif (msg->msg_state == HTTP_MSG_BODY)\n\t\tmsg->msg_state = HTTP_MSG_DATA;\n\n\t/* in most states, we should abort in case of early close */\n\tchannel_auto_close(req);\n\n\tif (req->to_forward) {\n\t\tif (req->to_forward == CHN_INFINITE_FORWARD) {\n\t\t\tif (req->flags & CF_EOI)\n\t\t\t\tmsg->msg_state = HTTP_MSG_ENDING;\n\t\t}\n\t\telse {\n\t\t\t/* We can't process the buffer's contents yet */\n\t\t\treq->flags |= CF_WAKE_WRITE;\n\t\t\tgoto missing_data_or_waiting;\n\t\t}\n\t}\n\n\tif (msg->msg_state >= HTTP_MSG_ENDING)\n\t\tgoto ending;\n\n\tif (txn->meth == HTTP_METH_CONNECT) {\n\t\tmsg->msg_state = HTTP_MSG_ENDING;\n\t\tgoto ending;\n\t}\n\n\t/* Forward input data. We get it by removing all outgoing data not\n\t * forwarded yet from HTX data size. If there are some data filters, we\n\t * let them decide the amount of data to forward.\n\t */\n\tif (HAS_REQ_DATA_FILTERS(s)) {\n\t\tret  = flt_http_payload(s, msg, htx->data);\n\t\tif (ret < 0)\n\t\t\tgoto return_bad_req;\n\t\tc_adv(req, ret);\n\t}\n\telse {\n\t\tc_adv(req, htx->data - co_data(req));\n\t\tif (msg->flags & HTTP_MSGF_XFER_LEN)\n\t\t\tchannel_htx_forward_forever(req, htx);\n\t}\n\n\tif (htx->data != co_data(req))\n\t\tgoto missing_data_or_waiting;\n\n\t/* Check if the end-of-message is reached and if so, switch the message\n\t * in HTTP_MSG_ENDING state. Then if all data was marked to be\n\t * forwarded, set the state to HTTP_MSG_DONE.\n\t */\n\tif (!(htx->flags & HTX_FL_EOM))\n\t\tgoto missing_data_or_waiting;\n\n\tmsg->msg_state = HTTP_MSG_ENDING;\n\n  ending:\n\treq->flags &= ~CF_EXPECT_MORE; /* no more data are expected */\n\n\t/* other states, ENDING...TUNNEL */\n\tif (msg->msg_state >= HTTP_MSG_DONE)\n\t\tgoto done;\n\n\tif (HAS_REQ_DATA_FILTERS(s)) {\n\t\tret = flt_http_end(s, msg);\n\t\tif (ret <= 0) {\n\t\t\tif (!ret)\n\t\t\t\tgoto missing_data_or_waiting;\n\t\t\tgoto return_bad_req;\n\t\t}\n\t}\n\n\tif (txn->meth == HTTP_METH_CONNECT)\n\t\tmsg->msg_state = HTTP_MSG_TUNNEL;\n\telse {\n\t\tmsg->msg_state = HTTP_MSG_DONE;\n\t\treq->to_forward = 0;\n\t}\n\n  done:\n\t/* we don't want to forward closes on DONE except in tunnel mode. */\n\tif (!(txn->flags & TX_CON_WANT_TUN))\n\t\tchannel_dont_close(req);\n\n\thttp_end_request(s);\n\tif (!(req->analysers & an_bit)) {\n\t\thttp_end_response(s);\n\t\tif (unlikely(msg->msg_state == HTTP_MSG_ERROR)) {\n\t\t\tif (req->flags & CF_SHUTW) {\n\t\t\t\t/* request errors are most likely due to the\n\t\t\t\t * server aborting the transfer. */\n\t\t\t\tgoto return_srv_abort;\n\t\t\t}\n\t\t\tgoto return_bad_req;\n\t\t}\n\t\tDBG_TRACE_LEAVE(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\t\treturn 1;\n\t}\n\n\t/* If \"option abortonclose\" is set on the backend, we want to monitor\n\t * the client's connection and forward any shutdown notification to the\n\t * server, which will decide whether to close or to go on processing the\n\t * request. We only do that in tunnel mode, and not in other modes since\n\t * it can be abused to exhaust source ports. */\n\tif (s->be->options & PR_O_ABRT_CLOSE) {\n\t\tchannel_auto_read(req);\n\t\tif ((req->flags & (CF_SHUTR|CF_READ_NULL)) && !(txn->flags & TX_CON_WANT_TUN))\n\t\t\ts->si[1].flags |= SI_FL_NOLINGER;\n\t\tchannel_auto_close(req);\n\t}\n\telse if (s->txn->meth == HTTP_METH_POST) {\n\t\t/* POST requests may require to read extra CRLF sent by broken\n\t\t * browsers and which could cause an RST to be sent upon close\n\t\t * on some systems (eg: Linux). */\n\t\tchannel_auto_read(req);\n\t}\n\tDBG_TRACE_DEVEL(\"waiting for the end of the HTTP txn\",\n\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\treturn 0;\n\n missing_data_or_waiting:\n\t/* stop waiting for data if the input is closed before the end */\n\tif (msg->msg_state < HTTP_MSG_ENDING && req->flags & CF_SHUTR)\n\t\tgoto return_cli_abort;\n\n waiting:\n\t/* waiting for the last bits to leave the buffer */\n\tif (req->flags & CF_SHUTW)\n\t\tgoto return_srv_abort;\n\n\t/* When TE: chunked is used, we need to get there again to parse remaining\n\t * chunks even if the client has closed, so we don't want to set CF_DONTCLOSE.\n\t * And when content-length is used, we never want to let the possible\n\t * shutdown be forwarded to the other side, as the state machine will\n\t * take care of it once the client responds. It's also important to\n\t * prevent TIME_WAITs from accumulating on the backend side, and for\n\t * HTTP/2 where the last frame comes with a shutdown.\n\t */\n\tif (msg->flags & HTTP_MSGF_XFER_LEN)\n\t\tchannel_dont_close(req);\n\n\t/* We know that more data are expected, but we couldn't send more that\n\t * what we did. So we always set the CF_EXPECT_MORE flag so that the\n\t * system knows it must not set a PUSH on this first part. Interactive\n\t * modes are already handled by the stream sock layer. We must not do\n\t * this in content-length mode because it could present the MSG_MORE\n\t * flag with the last block of forwarded data, which would cause an\n\t * additional delay to be observed by the receiver.\n\t */\n\tif (HAS_REQ_DATA_FILTERS(s))\n\t\treq->flags |= CF_EXPECT_MORE;\n\n\tDBG_TRACE_DEVEL(\"waiting for more data to forward\",\n\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\treturn 0;\n\n  return_cli_abort:\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.cli_aborts);\n\t_HA_ATOMIC_INC(&s->be->be_counters.cli_aborts);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->cli_aborts);\n\tif (objt_server(s->target))\n\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.cli_aborts);\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_CLICL;\n\tstatus = 400;\n\tgoto return_prx_cond;\n\n  return_srv_abort:\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.srv_aborts);\n\t_HA_ATOMIC_INC(&s->be->be_counters.srv_aborts);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->srv_aborts);\n\tif (objt_server(s->target))\n\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.srv_aborts);\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_SRVCL;\n\tstatus = 502;\n\tgoto return_prx_cond;\n\n  return_int_err:\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_INTERNAL;\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.internal_errors);\n\t_HA_ATOMIC_INC(&s->be->be_counters.internal_errors);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->internal_errors);\n\tif (objt_server(s->target))\n\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.internal_errors);\n\tstatus = 500;\n\tgoto return_prx_cond;\n\n  return_bad_req:\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.failed_req);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->failed_req);\n\tstatus = 400;\n\t/* fall through */\n\n  return_prx_cond:\n\tif (txn->status > 0) {\n\t\t/* Note: we don't send any error if some data were already sent */\n\t\thttp_reply_and_close(s, txn->status, NULL);\n\t} else {\n\t\ttxn->status = status;\n\t\thttp_reply_and_close(s, txn->status, http_error_message(s));\n\t}\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_PRXCOND;\n\tif (!(s->flags & SF_FINST_MASK))\n\t\ts->flags |= ((txn->rsp.msg_state < HTTP_MSG_ERROR) ? SF_FINST_H : SF_FINST_D);\n\tDBG_TRACE_DEVEL(\"leaving on error \",\n\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA|STRM_EV_HTTP_ERR, s, txn);\n\treturn 0;\n}\n\n/* Reset the stream and the backend stream_interface to a situation suitable for attemption connection */\n/* Returns 0 if we can attempt to retry, -1 otherwise */\nstatic __inline int do_l7_retry(struct stream *s, struct stream_interface *si)\n{\n\tstruct channel *req, *res;\n\tint co_data;\n\n\tsi->conn_retries--;\n\tif (si->conn_retries < 0)\n\t\treturn -1;\n\n\tif (objt_server(s->target)) {\n\t\tif (s->flags & SF_CURR_SESS) {\n\t\t\ts->flags &= ~SF_CURR_SESS;\n\t\t\t_HA_ATOMIC_DEC(&__objt_server(s->target)->cur_sess);\n\t\t}\n\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.retries);\n\t}\n\t_HA_ATOMIC_INC(&s->be->be_counters.retries);\n\n\treq = &s->req;\n\tres = &s->res;\n\t/* Remove any write error from the request, and read error from the response */\n\treq->flags &= ~(CF_WRITE_ERROR | CF_WRITE_TIMEOUT | CF_SHUTW | CF_SHUTW_NOW);\n\tres->flags &= ~(CF_READ_ERROR | CF_READ_TIMEOUT | CF_SHUTR | CF_EOI | CF_READ_NULL | CF_SHUTR_NOW);\n\tres->analysers &= AN_RES_FLT_END;\n\tsi->flags &= ~(SI_FL_ERR | SI_FL_EXP | SI_FL_RXBLK_SHUT);\n\tsi->err_type = SI_ET_NONE;\n\ts->flags &= ~(SF_ERR_MASK | SF_FINST_MASK);\n\tstream_choose_redispatch(s);\n\tsi->exp = TICK_ETERNITY;\n\tres->rex = TICK_ETERNITY;\n\tres->to_forward = 0;\n\tres->analyse_exp = TICK_ETERNITY;\n\tres->total = 0;\n\tsi_release_endpoint(&s->si[1]);\n\n\tb_free(&req->buf);\n\t/* Swap the L7 buffer with the channel buffer */\n\t/* We know we stored the co_data as b_data, so get it there */\n\tco_data = b_data(&si->l7_buffer);\n\tb_set_data(&si->l7_buffer, b_size(&si->l7_buffer));\n\tb_xfer(&req->buf, &si->l7_buffer, b_data(&si->l7_buffer));\n\tco_set_data(req, co_data);\n\n\tDBG_TRACE_DEVEL(\"perform a L7 retry\", STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, s->txn);\n\n\tb_reset(&res->buf);\n\tco_set_data(res, 0);\n\treturn 0;\n}\n\n/* This stream analyser waits for a complete HTTP response. It returns 1 if the\n * processing can continue on next analysers, or zero if it either needs more\n * data or wants to immediately abort the response (eg: timeout, error, ...). It\n * is tied to AN_RES_WAIT_HTTP and may may remove itself from s->res.analysers\n * when it has nothing left to do, and may remove any analyser when it wants to\n * abort.\n */\nint http_wait_for_response(struct stream *s, struct channel *rep, int an_bit)\n{\n\t/*\n\t * We will analyze a complete HTTP response to check the its syntax.\n\t *\n\t * Once the start line and all headers are received, we may perform a\n\t * capture of the error (if any), and we will set a few fields. We also\n\t * logging and finally headers capture.\n\t */\n\tstruct session *sess = s->sess;\n\tstruct http_txn *txn = s->txn;\n\tstruct http_msg *msg = &txn->rsp;\n\tstruct htx *htx;\n\tstruct stream_interface *si_b = &s->si[1];\n\tstruct connection *srv_conn;\n\tstruct htx_sl *sl;\n\tint n;\n\n\tDBG_TRACE_ENTER(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn, msg);\n\n\thtx = htxbuf(&rep->buf);\n\n\t/* Parsing errors are caught here */\n\tif (htx->flags & HTX_FL_PARSING_ERROR)\n\t\tgoto return_bad_res;\n\tif (htx->flags & HTX_FL_PROCESSING_ERROR)\n\t\tgoto return_int_err;\n\n\t/*\n\t * Now we quickly check if we have found a full valid response.\n\t * If not so, we check the FD and buffer states before leaving.\n\t * A full response is indicated by the fact that we have seen\n\t * the double LF/CRLF, so the state is >= HTTP_MSG_BODY. Invalid\n\t * responses are checked first.\n\t *\n\t * Depending on whether the client is still there or not, we\n\t * may send an error response back or not. Note that normally\n\t * we should only check for HTTP status there, and check I/O\n\t * errors somewhere else.\n\t */\n  next_one:\n\tif (unlikely(htx_is_empty(htx) || htx->first == -1)) {\n\t\t/* 1: have we encountered a read error ? */\n\t\tif (rep->flags & CF_READ_ERROR) {\n\t\t\tstruct connection *conn = NULL;\n\n\t\t\tif (objt_cs(s->si[1].end))\n\t\t\t\tconn = __objt_cs(s->si[1].end)->conn;\n\n\t\t\t/* Perform a L7 retry because server refuses the early data. */\n\t\t\tif ((si_b->flags & SI_FL_L7_RETRY) &&\n\t\t\t    (s->be->retry_type & PR_RE_EARLY_ERROR) &&\n\t\t\t    conn && conn->err_code == CO_ER_SSL_EARLY_FAILED &&\n\t\t\t    do_l7_retry(s, si_b) == 0) {\n\t\t\t\tDBG_TRACE_DEVEL(\"leaving on L7 retry\",\n\t\t\t\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (txn->flags & TX_NOT_FIRST)\n\t\t\t\tgoto abort_keep_alive;\n\n\t\t\t_HA_ATOMIC_INC(&s->be->be_counters.failed_resp);\n\t\t\tif (objt_server(s->target)) {\n\t\t\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.failed_resp);\n\t\t\t\thealth_adjust(__objt_server(s->target), HANA_STATUS_HTTP_READ_ERROR);\n\t\t\t}\n\n\t\t\t/* if the server refused the early data, just send a 425 */\n\t\t\tif (conn && conn->err_code == CO_ER_SSL_EARLY_FAILED)\n\t\t\t\ttxn->status = 425;\n\t\t\telse {\n\t\t\t\ttxn->status = 502;\n\t\t\t\tstream_inc_http_fail_ctr(s);\n\t\t\t}\n\n\t\t\ts->si[1].flags |= SI_FL_NOLINGER;\n\t\t\thttp_reply_and_close(s, txn->status, http_error_message(s));\n\n\t\t\tif (!(s->flags & SF_ERR_MASK))\n\t\t\t\ts->flags |= SF_ERR_SRVCL;\n\t\t\tif (!(s->flags & SF_FINST_MASK))\n\t\t\t\ts->flags |= SF_FINST_H;\n\t\t\tDBG_TRACE_DEVEL(\"leaving on error\",\n\t\t\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA|STRM_EV_HTTP_ERR, s, txn);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* 2: read timeout : return a 504 to the client. */\n\t\telse if (rep->flags & CF_READ_TIMEOUT) {\n\t\t\tif ((si_b->flags & SI_FL_L7_RETRY) &&\n\t\t\t    (s->be->retry_type & PR_RE_TIMEOUT)) {\n\t\t\t\tif (co_data(rep) || do_l7_retry(s, si_b) == 0) {\n\t\t\t\t\tDBG_TRACE_DEVEL(\"leaving on L7 retry\",\n\t\t\t\t\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t_HA_ATOMIC_INC(&s->be->be_counters.failed_resp);\n\t\t\tif (objt_server(s->target)) {\n\t\t\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.failed_resp);\n\t\t\t\thealth_adjust(__objt_server(s->target), HANA_STATUS_HTTP_READ_TIMEOUT);\n\t\t\t}\n\n\t\t\ttxn->status = 504;\n\t\t\tstream_inc_http_fail_ctr(s);\n\t\t\ts->si[1].flags |= SI_FL_NOLINGER;\n\t\t\thttp_reply_and_close(s, txn->status, http_error_message(s));\n\n\t\t\tif (!(s->flags & SF_ERR_MASK))\n\t\t\t\ts->flags |= SF_ERR_SRVTO;\n\t\t\tif (!(s->flags & SF_FINST_MASK))\n\t\t\t\ts->flags |= SF_FINST_H;\n\t\t\tDBG_TRACE_DEVEL(\"leaving on error\",\n\t\t\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA|STRM_EV_HTTP_ERR, s, txn);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* 3: client abort with an abortonclose */\n\t\telse if ((rep->flags & CF_SHUTR) && ((s->req.flags & (CF_SHUTR|CF_SHUTW)) == (CF_SHUTR|CF_SHUTW))) {\n\t\t\t_HA_ATOMIC_INC(&sess->fe->fe_counters.cli_aborts);\n\t\t\t_HA_ATOMIC_INC(&s->be->be_counters.cli_aborts);\n\t\t\tif (sess->listener && sess->listener->counters)\n\t\t\t\t_HA_ATOMIC_INC(&sess->listener->counters->cli_aborts);\n\t\t\tif (objt_server(s->target))\n\t\t\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.cli_aborts);\n\n\t\t\ttxn->status = 400;\n\t\t\thttp_reply_and_close(s, txn->status, http_error_message(s));\n\n\t\t\tif (!(s->flags & SF_ERR_MASK))\n\t\t\t\ts->flags |= SF_ERR_CLICL;\n\t\t\tif (!(s->flags & SF_FINST_MASK))\n\t\t\t\ts->flags |= SF_FINST_H;\n\n\t\t\t/* process_stream() will take care of the error */\n\t\t\tDBG_TRACE_DEVEL(\"leaving on error\",\n\t\t\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA|STRM_EV_HTTP_ERR, s, txn);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* 4: close from server, capture the response if the server has started to respond */\n\t\telse if (rep->flags & CF_SHUTR) {\n\t\t\tif ((si_b->flags & SI_FL_L7_RETRY) &&\n\t\t\t    (s->be->retry_type & PR_RE_DISCONNECTED)) {\n\t\t\t\tif (co_data(rep) || do_l7_retry(s, si_b) == 0) {\n\t\t\t\t\tDBG_TRACE_DEVEL(\"leaving on L7 retry\",\n\t\t\t\t\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (txn->flags & TX_NOT_FIRST)\n\t\t\t\tgoto abort_keep_alive;\n\n\t\t\t_HA_ATOMIC_INC(&s->be->be_counters.failed_resp);\n\t\t\tif (objt_server(s->target)) {\n\t\t\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.failed_resp);\n\t\t\t\thealth_adjust(__objt_server(s->target), HANA_STATUS_HTTP_BROKEN_PIPE);\n\t\t\t}\n\n\t\t\ttxn->status = 502;\n\t\t\tstream_inc_http_fail_ctr(s);\n\t\t\ts->si[1].flags |= SI_FL_NOLINGER;\n\t\t\thttp_reply_and_close(s, txn->status, http_error_message(s));\n\n\t\t\tif (!(s->flags & SF_ERR_MASK))\n\t\t\t\ts->flags |= SF_ERR_SRVCL;\n\t\t\tif (!(s->flags & SF_FINST_MASK))\n\t\t\t\ts->flags |= SF_FINST_H;\n\t\t\tDBG_TRACE_DEVEL(\"leaving on error\",\n\t\t\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA|STRM_EV_HTTP_ERR, s, txn);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* 5: write error to client (we don't send any message then) */\n\t\telse if (rep->flags & CF_WRITE_ERROR) {\n\t\t\tif (txn->flags & TX_NOT_FIRST)\n\t\t\t\tgoto abort_keep_alive;\n\n\t\t\t_HA_ATOMIC_INC(&s->be->be_counters.failed_resp);\n\t\t\tif (objt_server(s->target))\n\t\t\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.failed_resp);\n\t\t\trep->analysers &= AN_RES_FLT_END;\n\n\t\t\tif (!(s->flags & SF_ERR_MASK))\n\t\t\t\ts->flags |= SF_ERR_CLICL;\n\t\t\tif (!(s->flags & SF_FINST_MASK))\n\t\t\t\ts->flags |= SF_FINST_H;\n\n\t\t\t/* process_stream() will take care of the error */\n\t\t\tDBG_TRACE_DEVEL(\"leaving on error\",\n\t\t\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA|STRM_EV_HTTP_ERR, s, txn);\n\t\t\treturn 0;\n\t\t}\n\n\t\tchannel_dont_close(rep);\n\t\trep->flags |= CF_READ_DONTWAIT; /* try to get back here ASAP */\n\t\tDBG_TRACE_DEVEL(\"waiting for more data\",\n\t\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\t\treturn 0;\n\t}\n\n\t/* More interesting part now : we know that we have a complete\n\t * response which at least looks like HTTP. We have an indicator\n\t * of each header's length, so we can parse them quickly.\n\t */\n\tBUG_ON(htx_get_first_type(htx) != HTX_BLK_RES_SL);\n\tsl = http_get_stline(htx);\n\n\t/* Perform a L7 retry because of the status code */\n\tif ((si_b->flags & SI_FL_L7_RETRY) &&\n\t    l7_status_match(s->be, sl->info.res.status) &&\n\t    do_l7_retry(s, si_b) == 0) {\n\t\tDBG_TRACE_DEVEL(\"leaving on L7 retry\", STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\t\treturn 0;\n\t}\n\n\t/* Now, L7 buffer is useless, it can be released */\n\tb_free(&s->si[1].l7_buffer);\n\n\tmsg->msg_state = HTTP_MSG_BODY;\n\n\n\t/* 0: we might have to print this header in debug mode */\n\tif (unlikely((global.mode & MODE_DEBUG) &&\n\t\t     (!(global.mode & MODE_QUIET) || (global.mode & MODE_VERBOSE)))) {\n\t\tint32_t pos;\n\n\t\thttp_debug_stline(\"srvrep\", s, sl);\n\n\t\tfor (pos = htx_get_first(htx); pos != -1; pos = htx_get_next(htx, pos)) {\n\t\t\tstruct htx_blk *blk = htx_get_blk(htx, pos);\n\t\t\tenum htx_blk_type type = htx_get_blk_type(blk);\n\n\t\t\tif (type == HTX_BLK_EOH)\n\t\t\t\tbreak;\n\t\t\tif (type != HTX_BLK_HDR)\n\t\t\t\tcontinue;\n\n\t\t\thttp_debug_hdr(\"srvhdr\", s,\n\t\t\t\t       htx_get_blk_name(htx, blk),\n\t\t\t\t       htx_get_blk_value(htx, blk));\n\t\t}\n\t}\n\n\t/* 1: get the status code and the version. Also set HTTP flags */\n\ttxn->status = sl->info.res.status;\n\tif (sl->flags & HTX_SL_F_VER_11)\n                msg->flags |= HTTP_MSGF_VER_11;\n\tif (sl->flags & HTX_SL_F_XFER_LEN) {\n\t\tmsg->flags |= HTTP_MSGF_XFER_LEN;\n\t\tif (sl->flags & HTX_SL_F_CLEN)\n\t\t\tmsg->flags |= HTTP_MSGF_CNT_LEN;\n\t\telse if (sl->flags & HTX_SL_F_CHNK)\n\t\t\tmsg->flags |= HTTP_MSGF_TE_CHNK;\n\t}\n\tif (sl->flags & HTX_SL_F_BODYLESS)\n\t\tmsg->flags |= HTTP_MSGF_BODYLESS;\n\tif (sl->flags & HTX_SL_F_CONN_UPG)\n\t\tmsg->flags |= HTTP_MSGF_CONN_UPG;\n\n\tn = txn->status / 100;\n\tif (n < 1 || n > 5)\n\t\tn = 0;\n\n\t/* when the client triggers a 4xx from the server, it's most often due\n\t * to a missing object or permission. These events should be tracked\n\t * because if they happen often, it may indicate a brute force or a\n\t * vulnerability scan.\n\t */\n\tif (n == 4)\n\t\tstream_inc_http_err_ctr(s);\n\n\tif (n == 5 && txn->status != 501 && txn->status != 505)\n\t\tstream_inc_http_fail_ctr(s);\n\n\tif (objt_server(s->target)) {\n\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.p.http.rsp[n]);\n\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.p.http.cum_req);\n\t}\n\n\t/* Adjust server's health based on status code. Note: status codes 501\n\t * and 505 are triggered on demand by client request, so we must not\n\t * count them as server failures.\n\t */\n\tif (objt_server(s->target)) {\n\t\tif (txn->status >= 100 && (txn->status < 500 || txn->status == 501 || txn->status == 505))\n\t\t\thealth_adjust(__objt_server(s->target), HANA_STATUS_HTTP_OK);\n\t\telse\n\t\t\thealth_adjust(__objt_server(s->target), HANA_STATUS_HTTP_STS);\n\t}\n\n\t/*\n\t * We may be facing a 100-continue response, or any other informational\n\t * 1xx response which is non-final, in which case this is not the right\n\t * response, and we're waiting for the next one. Let's allow this response\n\t * to go to the client and wait for the next one. There's an exception for\n\t * 101 which is used later in the code to switch protocols.\n\t */\n\tif (txn->status < 200 &&\n\t    (txn->status == 100 || txn->status >= 102)) {\n\t\tFLT_STRM_CB(s, flt_http_reset(s, msg));\n\t\thtx->first = channel_htx_fwd_headers(rep, htx);\n\t\tmsg->msg_state = HTTP_MSG_RPBEFORE;\n\t\tmsg->flags = 0;\n\t\ttxn->status = 0;\n\t\ts->logs.t_data = -1; /* was not a response yet */\n\t\trep->flags |= CF_SEND_DONTWAIT; /* Send ASAP informational messages */\n\t\tgoto next_one;\n\t}\n\n\t/* A 101-switching-protocols must contains a Connection header with the\n\t * \"upgrade\" option and the request too. It means both are agree to\n\t * upgrade. It is not so strict because there is no test on the Upgrade\n\t * header content. But it is probably stronger enough for now.\n\t */\n\tif (txn->status == 101 &&\n\t    (!(txn->req.flags & HTTP_MSGF_CONN_UPG) || !(txn->rsp.flags & HTTP_MSGF_CONN_UPG)))\n\t\tgoto return_bad_res;\n\n\t/*\n\t * 2: check for cacheability.\n\t */\n\n\tswitch (txn->status) {\n\tcase 200:\n\tcase 203:\n\tcase 204:\n\tcase 206:\n\tcase 300:\n\tcase 301:\n\tcase 404:\n\tcase 405:\n\tcase 410:\n\tcase 414:\n\tcase 501:\n\t\tbreak;\n\tdefault:\n\t\t/* RFC7231#6.1:\n\t\t *   Responses with status codes that are defined as\n\t\t *   cacheable by default (e.g., 200, 203, 204, 206,\n\t\t *   300, 301, 404, 405, 410, 414, and 501 in this\n\t\t *   specification) can be reused by a cache with\n\t\t *   heuristic expiration unless otherwise indicated\n\t\t *   by the method definition or explicit cache\n\t\t *   controls [RFC7234]; all other status codes are\n\t\t *   not cacheable by default.\n\t\t */\n\t\ttxn->flags &= ~(TX_CACHEABLE | TX_CACHE_COOK);\n\t\tbreak;\n\t}\n\n\t/*\n\t * 3: we may need to capture headers\n\t */\n\ts->logs.logwait &= ~LW_RESP;\n\tif (unlikely((s->logs.logwait & LW_RSPHDR) && s->res_cap))\n\t\thttp_capture_headers(htx, s->res_cap, sess->fe->rsp_cap);\n\n\t/* Skip parsing if no content length is possible. */\n\tif (unlikely((txn->meth == HTTP_METH_CONNECT && txn->status >= 200 && txn->status < 300) ||\n\t\t     txn->status == 101)) {\n\t\t/* Either we've established an explicit tunnel, or we're\n\t\t * switching the protocol. In both cases, we're very unlikely\n\t\t * to understand the next protocols. We have to switch to tunnel\n\t\t * mode, so that we transfer the request and responses then let\n\t\t * this protocol pass unmodified. When we later implement specific\n\t\t * parsers for such protocols, we'll want to check the Upgrade\n\t\t * header which contains information about that protocol for\n\t\t * responses with status 101 (eg: see RFC2817 about TLS).\n\t\t */\n\t\ttxn->flags |= TX_CON_WANT_TUN;\n\t}\n\n\t/* check for NTML authentication headers in 401 (WWW-Authenticate) and\n\t * 407 (Proxy-Authenticate) responses and set the connection to private\n\t */\n\tsrv_conn = cs_conn(objt_cs(s->si[1].end));\n\tif (srv_conn) {\n\t\tstruct ist hdr;\n\t\tstruct http_hdr_ctx ctx;\n\n\t\tif (txn->status == 401)\n\t\t\thdr = ist(\"WWW-Authenticate\");\n\t\telse if (txn->status == 407)\n\t\t\thdr = ist(\"Proxy-Authenticate\");\n\t\telse\n\t\t\tgoto end;\n\n\t\tctx.blk = NULL;\n\t\twhile (http_find_header(htx, hdr, &ctx, 0)) {\n\t\t\t/* If www-authenticate contains \"Negotiate\", \"Nego2\", or \"NTLM\",\n\t\t\t * possibly followed by blanks and a base64 string, the connection\n\t\t\t * is private. Since it's a mess to deal with, we only check for\n\t\t\t * values starting with \"NTLM\" or \"Nego\". Note that often multiple\n\t\t\t * headers are sent by the server there.\n\t\t\t */\n\t\t\tif ((ctx.value.len >= 4 && strncasecmp(ctx.value.ptr, \"Nego\", 4) == 0) ||\n\t\t\t    (ctx.value.len >= 4 && strncasecmp(ctx.value.ptr, \"NTLM\", 4) == 0)) {\n\t\t\t\tsess->flags |= SESS_FL_PREFER_LAST;\n\t\t\t\tconn_set_owner(srv_conn, sess, NULL);\n\t\t\t\tconn_set_private(srv_conn);\n\t\t\t\t/* If it fail now, the same will be done in mux->detach() callback */\n\t\t\t\tsession_add_conn(srv_conn->owner, srv_conn, srv_conn->target);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n  end:\n\t/* we want to have the response time before we start processing it */\n\ts->logs.t_data = tv_ms_elapsed(&s->logs.tv_accept, &now);\n\n\t/* end of job, return OK */\n\trep->analysers &= ~an_bit;\n\trep->analyse_exp = TICK_ETERNITY;\n\tchannel_auto_close(rep);\n\tDBG_TRACE_LEAVE(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\treturn 1;\n\n return_int_err:\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.internal_errors);\n\t_HA_ATOMIC_INC(&s->be->be_counters.internal_errors);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->internal_errors);\n\tif (objt_server(s->target))\n\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.internal_errors);\n\ttxn->status = 500;\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_INTERNAL;\n\tgoto return_prx_cond;\n\n  return_bad_res:\n\t_HA_ATOMIC_INC(&s->be->be_counters.failed_resp);\n\tif (objt_server(s->target)) {\n\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.failed_resp);\n\t\thealth_adjust(__objt_server(s->target), HANA_STATUS_HTTP_HDRRSP);\n\t}\n\tif ((s->be->retry_type & PR_RE_JUNK_REQUEST) &&\n\t    (si_b->flags & SI_FL_L7_RETRY) &&\n\t    do_l7_retry(s, si_b) == 0) {\n\t\tDBG_TRACE_DEVEL(\"leaving on L7 retry\",\n\t\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\t\treturn 0;\n\t}\n\ttxn->status = 502;\n\tstream_inc_http_fail_ctr(s);\n\t/* fall through */\n\n return_prx_cond:\n\thttp_reply_and_close(s, txn->status, http_error_message(s));\n\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_PRXCOND;\n\tif (!(s->flags & SF_FINST_MASK))\n\t\ts->flags |= SF_FINST_H;\n\n\ts->si[1].flags |= SI_FL_NOLINGER;\n\tDBG_TRACE_DEVEL(\"leaving on error\",\n\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA|STRM_EV_HTTP_ERR, s, txn);\n\treturn 0;\n\n abort_keep_alive:\n\t/* A keep-alive request to the server failed on a network error.\n\t * The client is required to retry. We need to close without returning\n\t * any other information so that the client retries.\n\t */\n\ttxn->status = 0;\n\ts->logs.logwait = 0;\n\ts->logs.level = 0;\n\ts->res.flags &= ~CF_EXPECT_MORE; /* speed up sending a previous response */\n\thttp_reply_and_close(s, txn->status, NULL);\n\tDBG_TRACE_DEVEL(\"leaving by closing K/A connection\",\n\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\treturn 0;\n}\n\n/* This function performs all the processing enabled for the current response.\n * It normally returns 1 unless it wants to break. It relies on buffers flags,\n * and updates s->res.analysers. It might make sense to explode it into several\n * other functions. It works like process_request (see indications above).\n */\nint http_process_res_common(struct stream *s, struct channel *rep, int an_bit, struct proxy *px)\n{\n\tstruct session *sess = s->sess;\n\tstruct http_txn *txn = s->txn;\n\tstruct http_msg *msg = &txn->rsp;\n\tstruct htx *htx;\n\tstruct proxy *cur_proxy;\n\tenum rule_result ret = HTTP_RULE_RES_CONT;\n\n\tif (unlikely(msg->msg_state < HTTP_MSG_BODY))\t/* we need more data */\n\t\treturn 0;\n\n\tDBG_TRACE_ENTER(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn, msg);\n\n\thtx = htxbuf(&rep->buf);\n\n\t/* The stats applet needs to adjust the Connection header but we don't\n\t * apply any filter there.\n\t */\n\tif (unlikely(objt_applet(s->target) == &http_stats_applet)) {\n\t\trep->analysers &= ~an_bit;\n\t\trep->analyse_exp = TICK_ETERNITY;\n\t\tgoto end;\n\t}\n\n\t/*\n\t * We will have to evaluate the filters.\n\t * As opposed to version 1.2, now they will be evaluated in the\n\t * filters order and not in the header order. This means that\n\t * each filter has to be validated among all headers.\n\t *\n\t * Filters are tried with ->be first, then with ->fe if it is\n\t * different from ->be.\n\t *\n\t * Maybe we are in resume condiion. In this case I choose the\n\t * \"struct proxy\" which contains the rule list matching the resume\n\t * pointer. If none of these \"struct proxy\" match, I initialise\n\t * the process with the first one.\n\t *\n\t * In fact, I check only correspondence between the current list\n\t * pointer and the ->fe rule list. If it doesn't match, I initialize\n\t * the loop with the ->be.\n\t */\n\tif (s->current_rule_list == &sess->fe->http_res_rules ||\n\t    (sess->fe->defpx && s->current_rule_list == &sess->fe->defpx->http_res_rules))\n\t\tcur_proxy = sess->fe;\n\telse\n\t\tcur_proxy = s->be;\n\n\twhile (1) {\n\t\t/* evaluate http-response rules */\n\t\tif (ret == HTTP_RULE_RES_CONT || ret == HTTP_RULE_RES_STOP) {\n\t\t\tstruct list *def_rules, *rules;\n\n\t\t\tdef_rules = ((cur_proxy->defpx && (cur_proxy == s->be || cur_proxy->defpx != s->be->defpx)) ? &cur_proxy->defpx->http_res_rules : NULL);\n\t\t\trules = &cur_proxy->http_res_rules;\n\n\t\t\tret = http_res_get_intercept_rule(cur_proxy, def_rules, rules, s);\n\n\t\t\tswitch (ret) {\n\t\t\tcase HTTP_RULE_RES_YIELD: /* some data miss, call the function later. */\n\t\t\t\tgoto return_prx_yield;\n\n\t\t\tcase HTTP_RULE_RES_CONT:\n\t\t\tcase HTTP_RULE_RES_STOP: /* nothing to do */\n\t\t\t\tbreak;\n\n\t\t\tcase HTTP_RULE_RES_DENY: /* deny or tarpit */\n\t\t\t\tgoto deny;\n\n\t\t\tcase HTTP_RULE_RES_ABRT: /* abort request, response already sent */\n\t\t\t\tgoto return_prx_cond;\n\n\t\t\tcase HTTP_RULE_RES_DONE: /* OK, but terminate request processing (eg: redirect) */\n\t\t\t\tgoto done;\n\n\t\t\tcase HTTP_RULE_RES_BADREQ: /* failed with a bad request */\n\t\t\t\tgoto return_bad_res;\n\n\t\t\tcase HTTP_RULE_RES_ERROR: /* failed with a bad request */\n\t\t\t\tgoto return_int_err;\n\t\t\t}\n\n\t\t}\n\n\t\t/* check whether we're already working on the frontend */\n\t\tif (cur_proxy == sess->fe)\n\t\t\tbreak;\n\t\tcur_proxy = sess->fe;\n\t}\n\n\t/* OK that's all we can do for 1xx responses */\n\tif (unlikely(txn->status < 200 && txn->status != 101))\n\t\tgoto end;\n\n\t/*\n\t * Now check for a server cookie.\n\t */\n\tif (s->be->cookie_name || sess->fe->capture_name || (s->be->options & PR_O_CHK_CACHE))\n\t\thttp_manage_server_side_cookies(s, rep);\n\n\t/*\n\t * Check for cache-control or pragma headers if required.\n\t */\n\tif ((s->be->options & PR_O_CHK_CACHE) || (s->be->ck_opts & PR_CK_NOC))\n\t\thttp_check_response_for_cacheability(s, rep);\n\n\t/*\n\t * Add server cookie in the response if needed\n\t */\n\tif (objt_server(s->target) && (s->be->ck_opts & PR_CK_INS) &&\n\t    !((txn->flags & TX_SCK_FOUND) && (s->be->ck_opts & PR_CK_PSV)) &&\n\t    (!(s->flags & SF_DIRECT) ||\n\t     ((s->be->cookie_maxidle || txn->cookie_last_date) &&\n\t      (!txn->cookie_last_date || (txn->cookie_last_date - date.tv_sec) < 0)) ||\n\t     (s->be->cookie_maxlife && !txn->cookie_first_date) ||  // set the first_date\n\t     (!s->be->cookie_maxlife && txn->cookie_first_date)) && // remove the first_date\n\t    (!(s->be->ck_opts & PR_CK_POST) || (txn->meth == HTTP_METH_POST)) &&\n\t    !(s->flags & SF_IGNORE_PRST)) {\n\t\t/* the server is known, it's not the one the client requested, or the\n\t\t * cookie's last seen date needs to be refreshed. We have to\n\t\t * insert a set-cookie here, except if we want to insert only on POST\n\t\t * requests and this one isn't. Note that servers which don't have cookies\n\t\t * (eg: some backup servers) will return a full cookie removal request.\n\t\t */\n\t\tif (!__objt_server(s->target)->cookie) {\n\t\t\tchunk_printf(&trash,\n\t\t\t\t     \"%s=; Expires=Thu, 01-Jan-1970 00:00:01 GMT; path=/\",\n\t\t\t\t     s->be->cookie_name);\n\t\t}\n\t\telse {\n\t\t\tchunk_printf(&trash, \"%s=%s\", s->be->cookie_name, __objt_server(s->target)->cookie);\n\n\t\t\tif (s->be->cookie_maxidle || s->be->cookie_maxlife) {\n\t\t\t\t/* emit last_date, which is mandatory */\n\t\t\t\ttrash.area[trash.data++] = COOKIE_DELIM_DATE;\n\t\t\t\ts30tob64((date.tv_sec+3) >> 2,\n\t\t\t\t\t trash.area + trash.data);\n\t\t\t\ttrash.data += 5;\n\n\t\t\t\tif (s->be->cookie_maxlife) {\n\t\t\t\t\t/* emit first_date, which is either the original one or\n\t\t\t\t\t * the current date.\n\t\t\t\t\t */\n\t\t\t\t\ttrash.area[trash.data++] = COOKIE_DELIM_DATE;\n\t\t\t\t\ts30tob64(txn->cookie_first_date ?\n\t\t\t\t\t\t txn->cookie_first_date >> 2 :\n\t\t\t\t\t\t (date.tv_sec+3) >> 2,\n\t\t\t\t\t\t trash.area + trash.data);\n\t\t\t\t\ttrash.data += 5;\n\t\t\t\t}\n\t\t\t}\n\t\t\tchunk_appendf(&trash, \"; path=/\");\n\t\t}\n\n\t\tif (s->be->cookie_domain)\n\t\t\tchunk_appendf(&trash, \"; domain=%s\", s->be->cookie_domain);\n\n\t\tif (s->be->ck_opts & PR_CK_HTTPONLY)\n\t\t\tchunk_appendf(&trash, \"; HttpOnly\");\n\n\t\tif (s->be->ck_opts & PR_CK_SECURE)\n\t\t\tchunk_appendf(&trash, \"; Secure\");\n\n\t\tif (s->be->cookie_attrs)\n\t\t\tchunk_appendf(&trash, \"; %s\", s->be->cookie_attrs);\n\n\t\tif (unlikely(!http_add_header(htx, ist(\"Set-Cookie\"), ist2(trash.area, trash.data))))\n\t\t\tgoto return_int_err;\n\n\t\ttxn->flags &= ~TX_SCK_MASK;\n\t\tif (__objt_server(s->target)->cookie && (s->flags & SF_DIRECT))\n\t\t\t/* the server did not change, only the date was updated */\n\t\t\ttxn->flags |= TX_SCK_UPDATED;\n\t\telse\n\t\t\ttxn->flags |= TX_SCK_INSERTED;\n\n\t\t/* Here, we will tell an eventual cache on the client side that we don't\n\t\t * want it to cache this reply because HTTP/1.0 caches also cache cookies !\n\t\t * Some caches understand the correct form: 'no-cache=\"set-cookie\"', but\n\t\t * others don't (eg: apache <= 1.3.26). So we use 'private' instead.\n\t\t */\n\t\tif ((s->be->ck_opts & PR_CK_NOC) && (txn->flags & TX_CACHEABLE)) {\n\n\t\t\ttxn->flags &= ~TX_CACHEABLE & ~TX_CACHE_COOK;\n\n\t\t\tif (unlikely(!http_add_header(htx, ist(\"Cache-control\"), ist(\"private\"))))\n\t\t\t\tgoto return_int_err;\n\t\t}\n\t}\n\n\t/*\n\t * Check if result will be cacheable with a cookie.\n\t * We'll block the response if security checks have caught\n\t * nasty things such as a cacheable cookie.\n\t */\n\tif (((txn->flags & (TX_CACHEABLE | TX_CACHE_COOK | TX_SCK_PRESENT)) ==\n\t     (TX_CACHEABLE | TX_CACHE_COOK | TX_SCK_PRESENT)) &&\n\t    (s->be->options & PR_O_CHK_CACHE)) {\n\t\t/* we're in presence of a cacheable response containing\n\t\t * a set-cookie header. We'll block it as requested by\n\t\t * the 'checkcache' option, and send an alert.\n\t\t */\n\t\tha_alert(\"Blocking cacheable cookie in response from instance %s, server %s.\\n\",\n\t\t\t s->be->id, objt_server(s->target) ? __objt_server(s->target)->id : \"<dispatch>\");\n\t\tsend_log(s->be, LOG_ALERT,\n\t\t\t \"Blocking cacheable cookie in response from instance %s, server %s.\\n\",\n\t\t\t s->be->id, objt_server(s->target) ? __objt_server(s->target)->id : \"<dispatch>\");\n\t\tgoto deny;\n\t}\n\n  end:\n\t/*\n\t * Evaluate after-response rules before forwarding the response. rules\n\t * from the backend are evaluated first, then one from the frontend if\n\t * it differs.\n\t */\n\tif (!http_eval_after_res_rules(s))\n\t\tgoto return_int_err;\n\n\t/* Filter the response headers if there are filters attached to the\n\t * stream.\n\t */\n\tif (HAS_FILTERS(s))\n\t\trep->analysers |= AN_RES_FLT_HTTP_HDRS;\n\n\t/* Always enter in the body analyzer */\n\trep->analysers &= ~AN_RES_FLT_XFER_DATA;\n\trep->analysers |= AN_RES_HTTP_XFER_BODY;\n\n\t/* if the user wants to log as soon as possible, without counting\n\t * bytes from the server, then this is the right moment. We have\n\t * to temporarily assign bytes_out to log what we currently have.\n\t */\n\tif (!LIST_ISEMPTY(&sess->fe->logformat) && !(s->logs.logwait & LW_BYTES)) {\n\t\ts->logs.t_close = s->logs.t_data; /* to get a valid end date */\n\t\ts->logs.bytes_out = htx->data;\n\t\ts->do_log(s);\n\t\ts->logs.bytes_out = 0;\n\t}\n\n done:\n\tDBG_TRACE_LEAVE(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\trep->analysers &= ~an_bit;\n\trep->analyse_exp = TICK_ETERNITY;\n\ts->current_rule = s->current_rule_list = NULL;\n\treturn 1;\n\n deny:\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.denied_resp);\n\t_HA_ATOMIC_INC(&s->be->be_counters.denied_resp);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->denied_resp);\n\tif (objt_server(s->target))\n\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.denied_resp);\n\tgoto return_prx_err;\n\n return_int_err:\n\ttxn->status = 500;\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_INTERNAL;\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.internal_errors);\n\t_HA_ATOMIC_INC(&s->be->be_counters.internal_errors);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->internal_errors);\n\tif (objt_server(s->target))\n\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.internal_errors);\n\tgoto return_prx_err;\n\n return_bad_res:\n\ttxn->status = 502;\n\tstream_inc_http_fail_ctr(s);\n\t_HA_ATOMIC_INC(&s->be->be_counters.failed_resp);\n\tif (objt_server(s->target)) {\n\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.failed_resp);\n\t\thealth_adjust(__objt_server(s->target), HANA_STATUS_HTTP_RSP);\n\t}\n\t/* fall through */\n\n return_prx_err:\n\thttp_reply_and_close(s, txn->status, http_error_message(s));\n\t/* fall through */\n\n return_prx_cond:\n\ts->logs.t_data = -1; /* was not a valid response */\n\ts->si[1].flags |= SI_FL_NOLINGER;\n\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_PRXCOND;\n\tif (!(s->flags & SF_FINST_MASK))\n\t\ts->flags |= SF_FINST_H;\n\n\trep->analysers &= AN_RES_FLT_END;\n\ts->req.analysers &= AN_REQ_FLT_END;\n\trep->analyse_exp = TICK_ETERNITY;\n\ts->current_rule = s->current_rule_list = NULL;\n\tDBG_TRACE_DEVEL(\"leaving on error\",\n\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA|STRM_EV_HTTP_ERR, s, txn);\n\treturn 0;\n\n return_prx_yield:\n\tchannel_dont_close(rep);\n\tDBG_TRACE_DEVEL(\"waiting for more data\",\n\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\treturn 0;\n}\n\n/* This function is an analyser which forwards response body (including chunk\n * sizes if any). It is called as soon as we must forward, even if we forward\n * zero byte. The only situation where it must not be called is when we're in\n * tunnel mode and we want to forward till the close. It's used both to forward\n * remaining data and to resync after end of body. It expects the msg_state to\n * be between MSG_BODY and MSG_DONE (inclusive). It returns zero if it needs to\n * read more data, or 1 once we can go on with next request or end the stream.\n *\n * It is capable of compressing response data both in content-length mode and\n * in chunked mode. The state machines follows different flows depending on\n * whether content-length and chunked modes are used, since there are no\n * trailers in content-length :\n *\n *       chk-mode        cl-mode\n *          ,----- BODY -----.\n *         /                  \\\n *        V     size > 0       V    chk-mode\n *  .--> SIZE -------------> DATA -------------> CRLF\n *  |     | size == 0          | last byte         |\n *  |     v      final crlf    v inspected         |\n *  |  TRAILERS -----------> DONE                  |\n *  |                                              |\n *  `----------------------------------------------'\n *\n * Compression only happens in the DATA state, and must be flushed in final\n * states (TRAILERS/DONE) or when leaving on missing data. Normal forwarding\n * is performed at once on final states for all bytes parsed, or when leaving\n * on missing data.\n */\nint http_response_forward_body(struct stream *s, struct channel *res, int an_bit)\n{\n\tstruct session *sess = s->sess;\n\tstruct http_txn *txn = s->txn;\n\tstruct http_msg *msg = &s->txn->rsp;\n\tstruct htx *htx;\n\tint ret;\n\n\tDBG_TRACE_ENTER(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn, msg);\n\n\thtx = htxbuf(&res->buf);\n\n\tif (htx->flags & HTX_FL_PARSING_ERROR)\n\t\tgoto return_bad_res;\n\tif (htx->flags & HTX_FL_PROCESSING_ERROR)\n\t\tgoto return_int_err;\n\n\tif ((res->flags & (CF_READ_ERROR|CF_READ_TIMEOUT|CF_WRITE_ERROR|CF_WRITE_TIMEOUT)) ||\n\t    ((res->flags & CF_SHUTW) && (res->to_forward || co_data(res)))) {\n\t\t/* Output closed while we were sending data. We must abort and\n\t\t * wake the other side up.\n\t\t */\n\t\tmsg->msg_state = HTTP_MSG_ERROR;\n\t\thttp_end_response(s);\n\t\thttp_end_request(s);\n\t\tDBG_TRACE_DEVEL(\"leaving on error\",\n\t\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA|STRM_EV_HTTP_ERR, s, txn);\n\t\treturn 1;\n\t}\n\n\tif (msg->msg_state == HTTP_MSG_BODY)\n\t\tmsg->msg_state = HTTP_MSG_DATA;\n\n\t/* in most states, we should abort in case of early close */\n\tchannel_auto_close(res);\n\n\tif (res->to_forward) {\n\t\tif (res->to_forward == CHN_INFINITE_FORWARD) {\n\t\t\tif (res->flags & CF_EOI)\n\t\t\t\tmsg->msg_state = HTTP_MSG_ENDING;\n\t\t}\n\t\telse {\n\t\t\t/* We can't process the buffer's contents yet */\n\t\t\tres->flags |= CF_WAKE_WRITE;\n\t\t\tgoto missing_data_or_waiting;\n\t\t}\n\t}\n\n\tif (msg->msg_state >= HTTP_MSG_ENDING)\n\t\tgoto ending;\n\n\tif ((txn->meth == HTTP_METH_CONNECT && txn->status >= 200 && txn->status < 300) || txn->status == 101 ||\n\t    (!(msg->flags & HTTP_MSGF_XFER_LEN) && !HAS_RSP_DATA_FILTERS(s))) {\n\t\tmsg->msg_state = HTTP_MSG_ENDING;\n\t\tgoto ending;\n\t}\n\n\t/* Forward input data. We get it by removing all outgoing data not\n\t * forwarded yet from HTX data size. If there are some data filters, we\n\t * let them decide the amount of data to forward.\n\t */\n\tif (HAS_RSP_DATA_FILTERS(s)) {\n\t\tret  = flt_http_payload(s, msg, htx->data);\n\t\tif (ret < 0)\n\t\t\tgoto return_bad_res;\n\t\tc_adv(res, ret);\n\t}\n\telse {\n\t\tc_adv(res, htx->data - co_data(res));\n\t\tif (msg->flags & HTTP_MSGF_XFER_LEN)\n\t\t\tchannel_htx_forward_forever(res, htx);\n\t}\n\n\tif (htx->data != co_data(res))\n\t\tgoto missing_data_or_waiting;\n\n\tif (!(msg->flags & HTTP_MSGF_XFER_LEN) && res->flags & CF_SHUTR) {\n\t\tmsg->msg_state = HTTP_MSG_ENDING;\n\t\tgoto ending;\n\t}\n\n\t/* Check if the end-of-message is reached and if so, switch the message\n\t * in HTTP_MSG_ENDING state. Then if all data was marked to be\n\t * forwarded, set the state to HTTP_MSG_DONE.\n\t */\n\tif (!(htx->flags & HTX_FL_EOM))\n\t\tgoto missing_data_or_waiting;\n\n\tmsg->msg_state = HTTP_MSG_ENDING;\n\n  ending:\n\tres->flags &= ~CF_EXPECT_MORE; /* no more data are expected */\n\n\t/* other states, ENDING...TUNNEL */\n\tif (msg->msg_state >= HTTP_MSG_DONE)\n\t\tgoto done;\n\n\tif (HAS_RSP_DATA_FILTERS(s)) {\n\t\tret = flt_http_end(s, msg);\n\t\tif (ret <= 0) {\n\t\t\tif (!ret)\n\t\t\t\tgoto missing_data_or_waiting;\n\t\t\tgoto return_bad_res;\n\t\t}\n\t}\n\n\tif ((txn->meth == HTTP_METH_CONNECT && txn->status >= 200 && txn->status < 300) || txn->status == 101 ||\n\t    !(msg->flags & HTTP_MSGF_XFER_LEN)) {\n\t\tmsg->msg_state = HTTP_MSG_TUNNEL;\n\t\tgoto ending;\n\t}\n\telse {\n\t\tmsg->msg_state = HTTP_MSG_DONE;\n\t\tres->to_forward = 0;\n\t}\n\n  done:\n\n\tchannel_dont_close(res);\n\n\thttp_end_response(s);\n\tif (!(res->analysers & an_bit)) {\n\t\thttp_end_request(s);\n\t\tif (unlikely(msg->msg_state == HTTP_MSG_ERROR)) {\n\t\t\tif (res->flags & CF_SHUTW) {\n\t\t\t\t/* response errors are most likely due to the\n\t\t\t\t * client aborting the transfer. */\n\t\t\t\tgoto return_cli_abort;\n\t\t\t}\n\t\t\tgoto return_bad_res;\n\t\t}\n\t\tDBG_TRACE_LEAVE(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\t\treturn 1;\n\t}\n\tDBG_TRACE_DEVEL(\"waiting for the end of the HTTP txn\",\n\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\treturn 0;\n\n  missing_data_or_waiting:\n\tif (res->flags & CF_SHUTW)\n\t\tgoto return_cli_abort;\n\n\t/* stop waiting for data if the input is closed before the end. If the\n\t * client side was already closed, it means that the client has aborted,\n\t * so we don't want to count this as a server abort. Otherwise it's a\n\t * server abort.\n\t */\n\tif (msg->msg_state < HTTP_MSG_ENDING && res->flags & CF_SHUTR) {\n\t\tif ((s->req.flags & (CF_SHUTR|CF_SHUTW)) == (CF_SHUTR|CF_SHUTW))\n\t\t\tgoto return_cli_abort;\n\t\t/* If we have some pending data, we continue the processing */\n\t\tif (htx_is_empty(htx))\n\t\t\tgoto return_srv_abort;\n\t}\n\n\t/* When TE: chunked is used, we need to get there again to parse\n\t * remaining chunks even if the server has closed, so we don't want to\n\t * set CF_DONTCLOSE. Similarly when there is a content-leng or if there\n\t * are filters registered on the stream, we don't want to forward a\n\t * close\n\t */\n\tif ((msg->flags & HTTP_MSGF_XFER_LEN) || HAS_RSP_DATA_FILTERS(s))\n\t\tchannel_dont_close(res);\n\n\t/* We know that more data are expected, but we couldn't send more that\n\t * what we did. So we always set the CF_EXPECT_MORE flag so that the\n\t * system knows it must not set a PUSH on this first part. Interactive\n\t * modes are already handled by the stream sock layer. We must not do\n\t * this in content-length mode because it could present the MSG_MORE\n\t * flag with the last block of forwarded data, which would cause an\n\t * additional delay to be observed by the receiver.\n\t */\n\tif (HAS_RSP_DATA_FILTERS(s))\n\t\tres->flags |= CF_EXPECT_MORE;\n\n\t/* the stream handler will take care of timeouts and errors */\n\tDBG_TRACE_DEVEL(\"waiting for more data to forward\",\n\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\treturn 0;\n\n  return_srv_abort:\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.srv_aborts);\n\t_HA_ATOMIC_INC(&s->be->be_counters.srv_aborts);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->srv_aborts);\n\tif (objt_server(s->target))\n\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.srv_aborts);\n\tstream_inc_http_fail_ctr(s);\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_SRVCL;\n\tgoto return_error;\n\n  return_cli_abort:\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.cli_aborts);\n\t_HA_ATOMIC_INC(&s->be->be_counters.cli_aborts);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->cli_aborts);\n\tif (objt_server(s->target))\n\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.cli_aborts);\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_CLICL;\n\tgoto return_error;\n\n  return_int_err:\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.internal_errors);\n\t_HA_ATOMIC_INC(&s->be->be_counters.internal_errors);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->internal_errors);\n\tif (objt_server(s->target))\n\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.internal_errors);\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_INTERNAL;\n\tgoto return_error;\n\n  return_bad_res:\n\t_HA_ATOMIC_INC(&s->be->be_counters.failed_resp);\n\tif (objt_server(s->target)) {\n\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.failed_resp);\n\t\thealth_adjust(__objt_server(s->target), HANA_STATUS_HTTP_RSP);\n\t}\n\tstream_inc_http_fail_ctr(s);\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_SRVCL;\n\t/* fall through */\n\n   return_error:\n\t/* don't send any error message as we're in the body */\n\thttp_reply_and_close(s, txn->status, NULL);\n\tif (!(s->flags & SF_FINST_MASK))\n\t\ts->flags |= SF_FINST_D;\n\tDBG_TRACE_DEVEL(\"leaving on error\",\n\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA|STRM_EV_HTTP_ERR, s, txn);\n\treturn 0;\n}\n\n/* Perform an HTTP redirect based on the information in <rule>. The function\n * returns zero in case of an irrecoverable error such as too large a request\n * to build a valid response, 1 in case of successful redirect (hence the rule\n * is final), or 2 if the rule has to be silently skipped.\n */\nint http_apply_redirect_rule(struct redirect_rule *rule, struct stream *s, struct http_txn *txn)\n{\n\tstruct channel *req = &s->req;\n\tstruct channel *res = &s->res;\n\tstruct htx *htx;\n\tstruct htx_sl *sl;\n\tstruct buffer *chunk;\n\tstruct ist status, reason, location;\n\tunsigned int flags;\n\tint close = 0; /* Try to keep the connection alive byt default */\n\n\tchunk = alloc_trash_chunk();\n\tif (!chunk) {\n\t\tif (!(s->flags & SF_ERR_MASK))\n\t\t\ts->flags |= SF_ERR_RESOURCE;\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * Create the location\n\t */\n\thtx = htxbuf(&req->buf);\n\tswitch(rule->type) {\n\t\tcase REDIRECT_TYPE_SCHEME: {\n\t\t\tstruct http_hdr_ctx ctx;\n\t\t\tstruct ist path, host;\n\t\t\tstruct http_uri_parser parser;\n\n\t\t\thost = ist(\"\");\n\t\t\tctx.blk = NULL;\n\t\t\tif (http_find_header(htx, ist(\"Host\"), &ctx, 0))\n\t\t\t\thost = ctx.value;\n\n\t\t\tsl = http_get_stline(htx);\n\t\t\tparser = http_uri_parser_init(htx_sl_req_uri(sl));\n\t\t\tpath = http_parse_path(&parser);\n\t\t\t/* build message using path */\n\t\t\tif (isttest(path)) {\n\t\t\t\tif (rule->flags & REDIRECT_FLAG_DROP_QS) {\n\t\t\t\t\tint qs = 0;\n\t\t\t\t\twhile (qs < path.len) {\n\t\t\t\t\t\tif (*(path.ptr + qs) == '?') {\n\t\t\t\t\t\t\tpath.len = qs;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqs++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tpath = ist(\"/\");\n\n\t\t\tif (rule->rdr_str) { /* this is an old \"redirect\" rule */\n\t\t\t\t/* add scheme */\n\t\t\t\tif (!chunk_memcat(chunk, rule->rdr_str, rule->rdr_len))\n\t\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* add scheme with executing log format */\n\t\t\t\tchunk->data += build_logline(s, chunk->area + chunk->data,\n\t\t\t\t\t\t\t     chunk->size - chunk->data,\n\t\t\t\t\t\t\t     &rule->rdr_fmt);\n\t\t\t}\n\t\t\t/* add \"://\" + host + path */\n\t\t\tif (!chunk_memcat(chunk, \"://\", 3) ||\n\t\t\t    !chunk_memcat(chunk, host.ptr, host.len) ||\n\t\t\t    !chunk_memcat(chunk, path.ptr, path.len))\n\t\t\t\tgoto fail;\n\n\t\t\t/* append a slash at the end of the location if needed and missing */\n\t\t\tif (chunk->data && chunk->area[chunk->data - 1] != '/' &&\n\t\t\t    (rule->flags & REDIRECT_FLAG_APPEND_SLASH)) {\n\t\t\t\tif (chunk->data + 1 >= chunk->size)\n\t\t\t\t\tgoto fail;\n\t\t\t\tchunk->area[chunk->data++] = '/';\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase REDIRECT_TYPE_PREFIX: {\n\t\t\tstruct ist path;\n\t\t\tstruct http_uri_parser parser;\n\n\t\t\tsl = http_get_stline(htx);\n\t\t\tparser = http_uri_parser_init(htx_sl_req_uri(sl));\n\t\t\tpath = http_parse_path(&parser);\n\t\t\t/* build message using path */\n\t\t\tif (isttest(path)) {\n\t\t\t\tif (rule->flags & REDIRECT_FLAG_DROP_QS) {\n\t\t\t\t\tint qs = 0;\n\t\t\t\t\twhile (qs < path.len) {\n\t\t\t\t\t\tif (*(path.ptr + qs) == '?') {\n\t\t\t\t\t\t\tpath.len = qs;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqs++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tpath = ist(\"/\");\n\n\t\t\tif (rule->rdr_str) { /* this is an old \"redirect\" rule */\n\t\t\t\t/* add prefix. Note that if prefix == \"/\", we don't want to\n\t\t\t\t * add anything, otherwise it makes it hard for the user to\n\t\t\t\t * configure a self-redirection.\n\t\t\t\t */\n\t\t\t\tif (rule->rdr_len != 1 || *rule->rdr_str != '/') {\n\t\t\t\t\tif (!chunk_memcat(chunk, rule->rdr_str, rule->rdr_len))\n\t\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* add prefix with executing log format */\n\t\t\t\tchunk->data += build_logline(s, chunk->area + chunk->data,\n\t\t\t\t\t\t\t     chunk->size - chunk->data,\n\t\t\t\t\t\t\t     &rule->rdr_fmt);\n\t\t\t}\n\n\t\t\t/* add path */\n\t\t\tif (!chunk_memcat(chunk, path.ptr, path.len))\n\t\t\t\tgoto fail;\n\n\t\t\t/* append a slash at the end of the location if needed and missing */\n\t\t\tif (chunk->data && chunk->area[chunk->data - 1] != '/' &&\n\t\t\t    (rule->flags & REDIRECT_FLAG_APPEND_SLASH)) {\n\t\t\t\tif (chunk->data + 1 >= chunk->size)\n\t\t\t\t\tgoto fail;\n\t\t\t\tchunk->area[chunk->data++] = '/';\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase REDIRECT_TYPE_LOCATION:\n\t\tdefault:\n\t\t\tif (rule->rdr_str) { /* this is an old \"redirect\" rule */\n\t\t\t\t/* add location */\n\t\t\t\tif (!chunk_memcat(chunk, rule->rdr_str, rule->rdr_len))\n\t\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* add location with executing log format */\n\t\t\t\tint len = build_logline(s, chunk->area + chunk->data,\n\t\t\t\t                        chunk->size - chunk->data,\n\t\t\t\t                        &rule->rdr_fmt);\n\t\t\t\tif (!len && rule->flags & REDIRECT_FLAG_IGNORE_EMPTY)\n\t\t\t\t\treturn 2;\n\n\t\t\t\tchunk->data += len;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\tlocation = ist2(chunk->area, chunk->data);\n\n\t/*\n\t * Create the 30x response\n\t */\n\tswitch (rule->code) {\n\t\tcase 308:\n\t\t\tstatus = ist(\"308\");\n\t\t\treason = ist(\"Permanent Redirect\");\n\t\t\tbreak;\n\t\tcase 307:\n\t\t\tstatus = ist(\"307\");\n\t\t\treason = ist(\"Temporary Redirect\");\n\t\t\tbreak;\n\t\tcase 303:\n\t\t\tstatus = ist(\"303\");\n\t\t\treason = ist(\"See Other\");\n\t\t\tbreak;\n\t\tcase 301:\n\t\t\tstatus = ist(\"301\");\n\t\t\treason = ist(\"Moved Permanently\");\n\t\t\tbreak;\n\t\tcase 302:\n\t\tdefault:\n\t\t\tstatus = ist(\"302\");\n\t\t\treason = ist(\"Found\");\n\t\t\tbreak;\n\t}\n\n\tif (!(txn->req.flags & HTTP_MSGF_BODYLESS) && txn->req.msg_state != HTTP_MSG_DONE)\n\t\tclose = 1;\n\n\thtx = htx_from_buf(&res->buf);\n\t/* Trim any possible response */\n\tchannel_htx_truncate(&s->res, htx);\n\tflags = (HTX_SL_F_IS_RESP|HTX_SL_F_VER_11|HTX_SL_F_XFER_LEN|HTX_SL_F_BODYLESS);\n\tsl = htx_add_stline(htx, HTX_BLK_RES_SL, flags, ist(\"HTTP/1.1\"), status, reason);\n\tif (!sl)\n\t\tgoto fail;\n\tsl->info.res.status = rule->code;\n\ts->txn->status = rule->code;\n\n\tif (close && !htx_add_header(htx, ist(\"Connection\"), ist(\"close\")))\n\t\tgoto fail;\n\n\tif (!htx_add_header(htx, ist(\"Content-length\"), ist(\"0\")) ||\n\t    !htx_add_header(htx, ist(\"Location\"), location))\n\t\tgoto fail;\n\n\tif (rule->code == 302 || rule->code == 303 || rule->code == 307) {\n\t\tif (!htx_add_header(htx, ist(\"Cache-Control\"), ist(\"no-cache\")))\n\t\t\tgoto fail;\n\t}\n\n\tif (rule->cookie_len) {\n\t\tif (!htx_add_header(htx, ist(\"Set-Cookie\"), ist2(rule->cookie_str, rule->cookie_len)))\n\t\t\tgoto fail;\n\t}\n\n\tif (!htx_add_endof(htx, HTX_BLK_EOH))\n\t\tgoto fail;\n\n\thtx->flags |= HTX_FL_EOM;\n\thtx_to_buf(htx, &res->buf);\n\tif (!http_forward_proxy_resp(s, 1))\n\t\tgoto fail;\n\n\tif (rule->flags & REDIRECT_FLAG_FROM_REQ) {\n\t\t/* let's log the request time */\n\t\ts->logs.tv_request = now;\n\t\treq->analysers &= AN_REQ_FLT_END;\n\n\t\tif (s->sess->fe == s->be) /* report it if the request was intercepted by the frontend */\n\t\t\t_HA_ATOMIC_INC(&s->sess->fe->fe_counters.intercepted_req);\n\t}\n\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_LOCAL;\n\tif (!(s->flags & SF_FINST_MASK))\n\t\ts->flags |= ((rule->flags & REDIRECT_FLAG_FROM_REQ) ? SF_FINST_R : SF_FINST_H);\n\n\tfree_trash_chunk(chunk);\n\treturn 1;\n\n  fail:\n\t/* If an error occurred, remove the incomplete HTTP response from the\n\t * buffer */\n\tchannel_htx_truncate(res, htxbuf(&res->buf));\n\tfree_trash_chunk(chunk);\n\treturn 0;\n}\n\n/* Replace all headers matching the name <name>. The header value is replaced if\n * it matches the regex <re>. <str> is used for the replacement. If <full> is\n * set to 1, the full-line is matched and replaced. Otherwise, comma-separated\n * values are evaluated one by one. It returns 0 on success and -1 on error.\n */\nint http_replace_hdrs(struct stream* s, struct htx *htx, struct ist name,\n\t\t     const char *str, struct my_regex *re, int full)\n{\n\tstruct http_hdr_ctx ctx;\n\tstruct buffer *output = get_trash_chunk();\n\n\tctx.blk = NULL;\n\twhile (http_find_header(htx, name, &ctx, full)) {\n\t\tif (!regex_exec_match2(re, ctx.value.ptr, ctx.value.len, MAX_MATCH, pmatch, 0))\n\t\t\tcontinue;\n\n\t\toutput->data = exp_replace(output->area, output->size, ctx.value.ptr, str, pmatch);\n\t\tif (output->data == -1)\n\t\t\treturn -1;\n\t\tif (!http_replace_header_value(htx, &ctx, ist2(output->area, output->data)))\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/* This function executes one of the set-{method,path,query,uri} actions. It\n * takes the string from the variable 'replace' with length 'len', then modifies\n * the relevant part of the request line accordingly. Then it updates various\n * pointers to the next elements which were moved, and the total buffer length.\n * It finds the action to be performed in p[2], previously filled by function\n * parse_set_req_line(). It returns 0 in case of success, -1 in case of internal\n * error, though this can be revisited when this code is finally exploited.\n *\n * 'action' can be '0' to replace method, '1' to replace path, '2' to replace\n * query string, 3 to replace uri or 4 to replace the path+query.\n *\n * In query string case, the mark question '?' must be set at the start of the\n * string by the caller, event if the replacement query string is empty.\n */\nint http_req_replace_stline(int action, const char *replace, int len,\n\t\t\t    struct proxy *px, struct stream *s)\n{\n\tstruct htx *htx = htxbuf(&s->req.buf);\n\n\tswitch (action) {\n\t\tcase 0: // method\n\t\t\tif (!http_replace_req_meth(htx, ist2(replace, len)))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase 1: // path\n\t\t\tif (!http_replace_req_path(htx, ist2(replace, len), 0))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase 2: // query\n\t\t\tif (!http_replace_req_query(htx, ist2(replace, len)))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase 3: // uri\n\t\t\tif (!http_replace_req_uri(htx, ist2(replace, len)))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase 4: // path + query\n\t\t\tif (!http_replace_req_path(htx, ist2(replace, len), 1))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/* This function replace the HTTP status code and the associated message. The\n * variable <status> contains the new status code. This function never fails. It\n * returns 0 in case of success, -1 in case of internal error.\n */\nint http_res_set_status(unsigned int status, struct ist reason, struct stream *s)\n{\n\tstruct htx *htx = htxbuf(&s->res.buf);\n\tchar *res;\n\n\tchunk_reset(&trash);\n\tres = ultoa_o(status, trash.area, trash.size);\n\ttrash.data = res - trash.area;\n\n\t/* Do we have a custom reason format string? */\n\tif (!isttest(reason)) {\n\t\tconst char *str = http_get_reason(status);\n\t\treason = ist(str);\n\t}\n\n\tif (!http_replace_res_status(htx, ist2(trash.area, trash.data), reason))\n\t\treturn -1;\n\treturn 0;\n}\n\n/* Executes the http-request rules <rules> for stream <s>, proxy <px> and\n * transaction <txn>. Returns the verdict of the first rule that prevents\n * further processing of the request (auth, deny, ...), and defaults to\n * HTTP_RULE_RES_STOP if it executed all rules or stopped on an allow, or\n * HTTP_RULE_RES_CONT if the last rule was reached. It may set the TX_CLTARPIT\n * on txn->flags if it encounters a tarpit rule. If <deny_status> is not NULL\n * and a deny/tarpit rule is matched, it will be filled with this rule's deny\n * status.\n */\nstatic enum rule_result http_req_get_intercept_rule(struct proxy *px, struct list *def_rules,\n\t\t\t\t\t\t    struct list *rules, struct stream *s)\n{\n\tstruct session *sess = strm_sess(s);\n\tstruct http_txn *txn = s->txn;\n\tstruct act_rule *rule;\n\tenum rule_result rule_ret = HTTP_RULE_RES_CONT;\n\tint act_opts = 0;\n\n\t/* If \"the current_rule_list\" match the executed rule list, we are in\n\t * resume condition. If a resume is needed it is always in the action\n\t * and never in the ACL or converters. In this case, we initialise the\n\t * current rule, and go to the action execution point.\n\t */\n\tif (s->current_rule) {\n\t\trule = s->current_rule;\n\t\ts->current_rule = NULL;\n\t\tif (s->current_rule_list == rules || (def_rules && s->current_rule_list == def_rules))\n\t\t\tgoto resume_execution;\n\t}\n\ts->current_rule_list = ((!def_rules || s->current_rule_list == def_rules) ? rules : def_rules);\n\n  restart:\n\t/* start the ruleset evaluation in strict mode */\n\ttxn->req.flags &= ~HTTP_MSGF_SOFT_RW;\n\n\tlist_for_each_entry(rule, s->current_rule_list, list) {\n\t\t/* check optional condition */\n\t\tif (rule->cond) {\n\t\t\tint ret;\n\n\t\t\tret = acl_exec_cond(rule->cond, px, sess, s, SMP_OPT_DIR_REQ|SMP_OPT_FINAL);\n\t\t\tret = acl_pass(ret);\n\n\t\t\tif (rule->cond->pol == ACL_COND_UNLESS)\n\t\t\t\tret = !ret;\n\n\t\t\tif (!ret) /* condition not matched */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tact_opts |= ACT_OPT_FIRST;\n  resume_execution:\n\t\tif (rule->kw->flags & KWF_EXPERIMENTAL)\n\t\t\tmark_tainted(TAINTED_ACTION_EXP_EXECUTED);\n\n\t\t/* Always call the action function if defined */\n\t\tif (rule->action_ptr) {\n\t\t\tif ((s->req.flags & CF_READ_ERROR) ||\n\t\t\t    ((s->req.flags & (CF_SHUTR|CF_READ_NULL)) &&\n\t\t\t     (px->options & PR_O_ABRT_CLOSE)))\n\t\t\t\tact_opts |= ACT_OPT_FINAL;\n\n\t\t\tswitch (rule->action_ptr(rule, px, sess, s, act_opts)) {\n\t\t\t\tcase ACT_RET_CONT:\n\t\t\t\t\tbreak;\n\t\t\t\tcase ACT_RET_STOP:\n\t\t\t\t\trule_ret = HTTP_RULE_RES_STOP;\n\t\t\t\t\tgoto end;\n\t\t\t\tcase ACT_RET_YIELD:\n\t\t\t\t\ts->current_rule = rule;\n\t\t\t\t\trule_ret = HTTP_RULE_RES_YIELD;\n\t\t\t\t\tgoto end;\n\t\t\t\tcase ACT_RET_ERR:\n\t\t\t\t\trule_ret = HTTP_RULE_RES_ERROR;\n\t\t\t\t\tgoto end;\n\t\t\t\tcase ACT_RET_DONE:\n\t\t\t\t\trule_ret = HTTP_RULE_RES_DONE;\n\t\t\t\t\tgoto end;\n\t\t\t\tcase ACT_RET_DENY:\n\t\t\t\t\tif (txn->status == -1)\n\t\t\t\t\t\ttxn->status = 403;\n\t\t\t\t\trule_ret = HTTP_RULE_RES_DENY;\n\t\t\t\t\tgoto end;\n\t\t\t\tcase ACT_RET_ABRT:\n\t\t\t\t\trule_ret = HTTP_RULE_RES_ABRT;\n\t\t\t\t\tgoto end;\n\t\t\t\tcase ACT_RET_INV:\n\t\t\t\t\trule_ret = HTTP_RULE_RES_BADREQ;\n\t\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tcontinue; /* eval the next rule */\n\t\t}\n\n\t\t/* If not action function defined, check for known actions */\n\t\tswitch (rule->action) {\n\t\t\tcase ACT_ACTION_ALLOW:\n\t\t\t\trule_ret = HTTP_RULE_RES_STOP;\n\t\t\t\tgoto end;\n\n\t\t\tcase ACT_ACTION_DENY:\n\t\t\t\ttxn->status = rule->arg.http_reply->status;\n\t\t\t\ttxn->http_reply = rule->arg.http_reply;\n\t\t\t\trule_ret = HTTP_RULE_RES_DENY;\n\t\t\t\tgoto end;\n\n\t\t\tcase ACT_HTTP_REQ_TARPIT:\n\t\t\t\ttxn->flags |= TX_CLTARPIT;\n\t\t\t\ttxn->status = rule->arg.http_reply->status;\n\t\t\t\ttxn->http_reply = rule->arg.http_reply;\n\t\t\t\trule_ret = HTTP_RULE_RES_DENY;\n\t\t\t\tgoto end;\n\n\t\t\tcase ACT_HTTP_REDIR: {\n\t\t\t\tint ret = http_apply_redirect_rule(rule->arg.redir, s, txn);\n\n\t\t\t\tif (ret == 2) // 2 == skip\n\t\t\t\t\tbreak;\n\n\t\t\t\trule_ret = ret ? HTTP_RULE_RES_ABRT : HTTP_RULE_RES_ERROR;\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\t/* other flags exists, but normally, they never be matched. */\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (def_rules && s->current_rule_list == def_rules) {\n\t\ts->current_rule_list = rules;\n\t\tgoto restart;\n\t}\n\n  end:\n\t/* if the ruleset evaluation is finished reset the strict mode */\n\tif (rule_ret != HTTP_RULE_RES_YIELD)\n\t\ttxn->req.flags &= ~HTTP_MSGF_SOFT_RW;\n\n\t/* we reached the end of the rules, nothing to report */\n\treturn rule_ret;\n}\n\n/* Executes the http-response rules <rules> for stream <s> and proxy <px>. It\n * returns one of 5 possible statuses: HTTP_RULE_RES_CONT, HTTP_RULE_RES_STOP,\n * HTTP_RULE_RES_DONE, HTTP_RULE_RES_YIELD, or HTTP_RULE_RES_BADREQ. If *CONT\n * is returned, the process can continue the evaluation of next rule list. If\n * *STOP or *DONE is returned, the process must stop the evaluation. If *BADREQ\n * is returned, it means the operation could not be processed and a server error\n * must be returned. If *YIELD is returned, the caller must call again the\n * function with the same context.\n */\nstatic enum rule_result http_res_get_intercept_rule(struct proxy *px, struct list *def_rules,\n\t\t\t\t\t\t    struct list *rules, struct stream *s)\n{\n\tstruct session *sess = strm_sess(s);\n\tstruct http_txn *txn = s->txn;\n\tstruct act_rule *rule;\n\tenum rule_result rule_ret = HTTP_RULE_RES_CONT;\n\tint act_opts = 0;\n\n\t/* If \"the current_rule_list\" match the executed rule list, we are in\n\t * resume condition. If a resume is needed it is always in the action\n\t * and never in the ACL or converters. In this case, we initialise the\n\t * current rule, and go to the action execution point.\n\t */\n\tif (s->current_rule) {\n\t\trule = s->current_rule;\n\t\ts->current_rule = NULL;\n\t\tif (s->current_rule_list == rules || (def_rules && s->current_rule_list == def_rules))\n\t\t\tgoto resume_execution;\n\t}\n\ts->current_rule_list = ((!def_rules || s->current_rule_list == def_rules) ? rules : def_rules);\n\n  restart:\n\n\t/* start the ruleset evaluation in strict mode */\n\ttxn->rsp.flags &= ~HTTP_MSGF_SOFT_RW;\n\n\tlist_for_each_entry(rule, s->current_rule_list, list) {\n\t\t/* check optional condition */\n\t\tif (rule->cond) {\n\t\t\tint ret;\n\n\t\t\tret = acl_exec_cond(rule->cond, px, sess, s, SMP_OPT_DIR_RES|SMP_OPT_FINAL);\n\t\t\tret = acl_pass(ret);\n\n\t\t\tif (rule->cond->pol == ACL_COND_UNLESS)\n\t\t\t\tret = !ret;\n\n\t\t\tif (!ret) /* condition not matched */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tact_opts |= ACT_OPT_FIRST;\nresume_execution:\n\t\tif (rule->kw->flags & KWF_EXPERIMENTAL)\n\t\t\tmark_tainted(TAINTED_ACTION_EXP_EXECUTED);\n\n\t\t/* Always call the action function if defined */\n\t\tif (rule->action_ptr) {\n\t\t\tif ((s->req.flags & CF_READ_ERROR) ||\n\t\t\t    ((s->req.flags & (CF_SHUTR|CF_READ_NULL)) &&\n\t\t\t     (px->options & PR_O_ABRT_CLOSE)))\n\t\t\t\tact_opts |= ACT_OPT_FINAL;\n\n\t\t\tswitch (rule->action_ptr(rule, px, sess, s, act_opts)) {\n\t\t\t\tcase ACT_RET_CONT:\n\t\t\t\t\tbreak;\n\t\t\t\tcase ACT_RET_STOP:\n\t\t\t\t\trule_ret = HTTP_RULE_RES_STOP;\n\t\t\t\t\tgoto end;\n\t\t\t\tcase ACT_RET_YIELD:\n\t\t\t\t\ts->current_rule = rule;\n\t\t\t\t\trule_ret = HTTP_RULE_RES_YIELD;\n\t\t\t\t\tgoto end;\n\t\t\t\tcase ACT_RET_ERR:\n\t\t\t\t\trule_ret = HTTP_RULE_RES_ERROR;\n\t\t\t\t\tgoto end;\n\t\t\t\tcase ACT_RET_DONE:\n\t\t\t\t\trule_ret = HTTP_RULE_RES_DONE;\n\t\t\t\t\tgoto end;\n\t\t\t\tcase ACT_RET_DENY:\n\t\t\t\t\tif (txn->status == -1)\n\t\t\t\t\t\ttxn->status = 502;\n\t\t\t\t\trule_ret = HTTP_RULE_RES_DENY;\n\t\t\t\t\tgoto end;\n\t\t\t\tcase ACT_RET_ABRT:\n\t\t\t\t\trule_ret = HTTP_RULE_RES_ABRT;\n\t\t\t\t\tgoto end;\n\t\t\t\tcase ACT_RET_INV:\n\t\t\t\t\trule_ret = HTTP_RULE_RES_BADREQ;\n\t\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tcontinue; /* eval the next rule */\n\t\t}\n\n\t\t/* If not action function defined, check for known actions */\n\t\tswitch (rule->action) {\n\t\t\tcase ACT_ACTION_ALLOW:\n\t\t\t\trule_ret = HTTP_RULE_RES_STOP; /* \"allow\" rules are OK */\n\t\t\t\tgoto end;\n\n\t\t\tcase ACT_ACTION_DENY:\n\t\t\t\ttxn->status = rule->arg.http_reply->status;\n\t\t\t\ttxn->http_reply = rule->arg.http_reply;\n\t\t\t\trule_ret = HTTP_RULE_RES_DENY;\n\t\t\t\tgoto end;\n\n\t\t\tcase ACT_HTTP_REDIR: {\n\t\t\t\tint ret = http_apply_redirect_rule(rule->arg.redir, s, txn);\n\n\t\t\t\tif (ret == 2) // 2 == skip\n\t\t\t\t\tbreak;\n\n\t\t\t\trule_ret = ret ? HTTP_RULE_RES_ABRT : HTTP_RULE_RES_ERROR;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\t/* other flags exists, but normally, they never be matched. */\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (def_rules && s->current_rule_list == def_rules) {\n\t\ts->current_rule_list = rules;\n\t\tgoto restart;\n\t}\n\n  end:\n\t/* if the ruleset evaluation is finished reset the strict mode */\n\tif (rule_ret != HTTP_RULE_RES_YIELD)\n\t\ttxn->rsp.flags &= ~HTTP_MSGF_SOFT_RW;\n\n\t/* we reached the end of the rules, nothing to report */\n\treturn rule_ret;\n}\n\n/* Executes backend and frontend http-after-response rules for the stream <s>,\n * in that order. it return 1 on success and 0 on error. It is the caller\n * responsibility to catch error or ignore it. If it catches it, this function\n * may be called a second time, for the internal error.\n */\nint http_eval_after_res_rules(struct stream *s)\n{\n\tstruct list *def_rules, *rules;\n\tstruct session *sess = s->sess;\n\tenum rule_result ret = HTTP_RULE_RES_CONT;\n\n\t/* Eval after-response ruleset only if the reply is not const */\n\tif (s->txn->flags & TX_CONST_REPLY)\n\t\tgoto end;\n\n\t/* prune the request variables if not already done and swap to the response variables. */\n\tif (s->vars_reqres.scope != SCOPE_RES) {\n\t\tif (!LIST_ISEMPTY(&s->vars_reqres.head))\n\t\t\tvars_prune(&s->vars_reqres, s->sess, s);\n\t\tvars_init_head(&s->vars_reqres, SCOPE_RES);\n\t}\n\n\tdef_rules = (s->be->defpx ? &s->be->defpx->http_after_res_rules : NULL);\n\trules = &s->be->http_after_res_rules;\n\n\tret = http_res_get_intercept_rule(s->be, def_rules, rules, s);\n\tif ((ret == HTTP_RULE_RES_CONT || ret == HTTP_RULE_RES_STOP) && sess->fe != s->be) {\n\t\tdef_rules = ((sess->fe->defpx && sess->fe->defpx != s->be->defpx) ? &sess->fe->defpx->http_after_res_rules : NULL);\n\t\trules = &sess->fe->http_after_res_rules;\n\t\tret = http_res_get_intercept_rule(sess->fe, def_rules, rules, s);\n\t}\n\n  end:\n\t/* All other codes than CONTINUE, STOP or DONE are forbidden */\n\treturn (ret == HTTP_RULE_RES_CONT || ret == HTTP_RULE_RES_STOP || ret == HTTP_RULE_RES_DONE);\n}\n\n/*\n * Manage client-side cookie. It can impact performance by about 2% so it is\n * desirable to call it only when needed. This code is quite complex because\n * of the multiple very crappy and ambiguous syntaxes we have to support. it\n * highly recommended not to touch this part without a good reason !\n */\nstatic void http_manage_client_side_cookies(struct stream *s, struct channel *req)\n{\n\tstruct session *sess = s->sess;\n\tstruct http_txn *txn = s->txn;\n\tstruct htx *htx;\n\tstruct http_hdr_ctx ctx;\n\tchar *hdr_beg, *hdr_end, *del_from;\n\tchar *prev, *att_beg, *att_end, *equal, *val_beg, *val_end, *next;\n\tint preserve_hdr;\n\n\thtx = htxbuf(&req->buf);\n\tctx.blk = NULL;\n\twhile (http_find_header(htx, ist(\"Cookie\"), &ctx, 1)) {\n\t\tint is_first = 1;\n\t\tdel_from = NULL;  /* nothing to be deleted */\n\t\tpreserve_hdr = 0; /* assume we may kill the whole header */\n\n\t\t/* Now look for cookies. Conforming to RFC2109, we have to support\n\t\t * attributes whose name begin with a '$', and associate them with\n\t\t * the right cookie, if we want to delete this cookie.\n\t\t * So there are 3 cases for each cookie read :\n\t\t * 1) it's a special attribute, beginning with a '$' : ignore it.\n\t\t * 2) it's a server id cookie that we *MAY* want to delete : save\n\t\t *    some pointers on it (last semi-colon, beginning of cookie...)\n\t\t * 3) it's an application cookie : we *MAY* have to delete a previous\n\t\t *    \"special\" cookie.\n\t\t * At the end of loop, if a \"special\" cookie remains, we may have to\n\t\t * remove it. If no application cookie persists in the header, we\n\t\t * *MUST* delete it.\n\t\t *\n\t\t * Note: RFC2965 is unclear about the processing of spaces around\n\t\t * the equal sign in the ATTR=VALUE form. A careful inspection of\n\t\t * the RFC explicitly allows spaces before it, and not within the\n\t\t * tokens (attrs or values). An inspection of RFC2109 allows that\n\t\t * too but section 10.1.3 lets one think that spaces may be allowed\n\t\t * after the equal sign too, resulting in some (rare) buggy\n\t\t * implementations trying to do that. So let's do what servers do.\n\t\t * Latest ietf draft forbids spaces all around. Also, earlier RFCs\n\t\t * allowed quoted strings in values, with any possible character\n\t\t * after a backslash, including control chars and delimiters, which\n\t\t * causes parsing to become ambiguous. Browsers also allow spaces\n\t\t * within values even without quotes.\n\t\t *\n\t\t * We have to keep multiple pointers in order to support cookie\n\t\t * removal at the beginning, middle or end of header without\n\t\t * corrupting the header. All of these headers are valid :\n\t\t *\n\t\t * hdr_beg                                               hdr_end\n\t\t * |                                                        |\n\t\t * v                                                        |\n\t\t * NAME1=VALUE1;NAME2=VALUE2;NAME3=VALUE3                   |\n\t\t * NAME1=VALUE1;NAME2_ONLY ;NAME3=VALUE3                    v\n\t\t *      NAME1  =  VALUE 1  ; NAME2 = VALUE2 ; NAME3 = VALUE3\n\t\t * |    |    | |  |      | |\n\t\t * |    |    | |  |      | |\n\t\t * |    |    | |  |      | +--> next\n\t\t * |    |    | |  |      +----> val_end\n\t\t * |    |    | |  +-----------> val_beg\n\t\t * |    |    | +--------------> equal\n\t\t * |    |    +----------------> att_end\n\t\t * |    +---------------------> att_beg\n\t\t * +--------------------------> prev\n\t\t *\n\t\t */\n\t\thdr_beg = ctx.value.ptr;\n\t\thdr_end = hdr_beg + ctx.value.len;\n\t\tfor (prev = hdr_beg; prev < hdr_end; prev = next) {\n\t\t\t/* Iterate through all cookies on this line */\n\n\t\t\t/* find att_beg */\n\t\t\tatt_beg = prev;\n\t\t\tif (!is_first)\n\t\t\t\tatt_beg++;\n\t\t\tis_first = 0;\n\n\t\t\twhile (att_beg < hdr_end && HTTP_IS_SPHT(*att_beg))\n\t\t\t\tatt_beg++;\n\n\t\t\t/* find att_end : this is the first character after the last non\n\t\t\t * space before the equal. It may be equal to hdr_end.\n\t\t\t */\n\t\t\tequal = att_end = att_beg;\n\t\t\twhile (equal < hdr_end) {\n\t\t\t\tif (*equal == '=' || *equal == ',' || *equal == ';')\n\t\t\t\t\tbreak;\n\t\t\t\tif (HTTP_IS_SPHT(*equal++))\n\t\t\t\t\tcontinue;\n\t\t\t\tatt_end = equal;\n\t\t\t}\n\n\t\t\t/* here, <equal> points to '=', a delimiter or the end. <att_end>\n\t\t\t * is between <att_beg> and <equal>, both may be identical.\n\t\t\t */\n\t\t\t/* look for end of cookie if there is an equal sign */\n\t\t\tif (equal < hdr_end && *equal == '=') {\n\t\t\t\t/* look for the beginning of the value */\n\t\t\t\tval_beg = equal + 1;\n\t\t\t\twhile (val_beg < hdr_end && HTTP_IS_SPHT(*val_beg))\n\t\t\t\t\tval_beg++;\n\n\t\t\t\t/* find the end of the value, respecting quotes */\n\t\t\t\tnext = http_find_cookie_value_end(val_beg, hdr_end);\n\n\t\t\t\t/* make val_end point to the first white space or delimiter after the value */\n\t\t\t\tval_end = next;\n\t\t\t\twhile (val_end > val_beg && HTTP_IS_SPHT(*(val_end - 1)))\n\t\t\t\t\tval_end--;\n\t\t\t}\n\t\t\telse\n\t\t\t\tval_beg = val_end = next = equal;\n\n\t\t\t/* We have nothing to do with attributes beginning with\n\t\t\t * '$'. However, they will automatically be removed if a\n\t\t\t * header before them is removed, since they're supposed\n\t\t\t * to be linked together.\n\t\t\t */\n\t\t\tif (*att_beg == '$')\n\t\t\t\tcontinue;\n\n\t\t\t/* Ignore cookies with no equal sign */\n\t\t\tif (equal == next) {\n\t\t\t\t/* This is not our cookie, so we must preserve it. But if we already\n\t\t\t\t * scheduled another cookie for removal, we cannot remove the\n\t\t\t\t * complete header, but we can remove the previous block itself.\n\t\t\t\t */\n\t\t\t\tpreserve_hdr = 1;\n\t\t\t\tif (del_from != NULL) {\n\t\t\t\t\tint delta = http_del_hdr_value(hdr_beg, hdr_end, &del_from, prev);\n\t\t\t\t\tval_end  += delta;\n\t\t\t\t\tnext     += delta;\n\t\t\t\t\thdr_end  += delta;\n\t\t\t\t\tprev     = del_from;\n\t\t\t\t\tdel_from = NULL;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* if there are spaces around the equal sign, we need to\n\t\t\t * strip them otherwise we'll get trouble for cookie captures,\n\t\t\t * or even for rewrites. Since this happens extremely rarely,\n\t\t\t * it does not hurt performance.\n\t\t\t */\n\t\t\tif (unlikely(att_end != equal || val_beg > equal + 1)) {\n\t\t\t\tint stripped_before = 0;\n\t\t\t\tint stripped_after = 0;\n\n\t\t\t\tif (att_end != equal) {\n\t\t\t\t\tmemmove(att_end, equal, hdr_end - equal);\n\t\t\t\t\tstripped_before = (att_end - equal);\n\t\t\t\t\tequal   += stripped_before;\n\t\t\t\t\tval_beg += stripped_before;\n\t\t\t\t}\n\n\t\t\t\tif (val_beg > equal + 1) {\n\t\t\t\t\tmemmove(equal + 1, val_beg, hdr_end + stripped_before - val_beg);\n\t\t\t\t\tstripped_after = (equal + 1) - val_beg;\n\t\t\t\t\tval_beg += stripped_after;\n\t\t\t\t\tstripped_before += stripped_after;\n\t\t\t\t}\n\n\t\t\t\tval_end      += stripped_before;\n\t\t\t\tnext         += stripped_before;\n\t\t\t\thdr_end      += stripped_before;\n\t\t\t}\n\t\t\t/* now everything is as on the diagram above */\n\n\t\t\t/* First, let's see if we want to capture this cookie. We check\n\t\t\t * that we don't already have a client side cookie, because we\n\t\t\t * can only capture one. Also as an optimisation, we ignore\n\t\t\t * cookies shorter than the declared name.\n\t\t\t */\n\t\t\tif (sess->fe->capture_name != NULL && txn->cli_cookie == NULL &&\n\t\t\t    (val_end - att_beg >= sess->fe->capture_namelen) &&\n\t\t\t    memcmp(att_beg, sess->fe->capture_name, sess->fe->capture_namelen) == 0) {\n\t\t\t\tint log_len = val_end - att_beg;\n\n\t\t\t\tif ((txn->cli_cookie = pool_alloc(pool_head_capture)) == NULL) {\n\t\t\t\t\tha_alert(\"HTTP logging : out of memory.\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tif (log_len > sess->fe->capture_len)\n\t\t\t\t\t\tlog_len = sess->fe->capture_len;\n\t\t\t\t\tmemcpy(txn->cli_cookie, att_beg, log_len);\n\t\t\t\t\ttxn->cli_cookie[log_len] = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Persistence cookies in passive, rewrite or insert mode have the\n\t\t\t * following form :\n\t\t\t *\n\t\t\t *    Cookie: NAME=SRV[|<lastseen>[|<firstseen>]]\n\t\t\t *\n\t\t\t * For cookies in prefix mode, the form is :\n\t\t\t *\n\t\t\t *    Cookie: NAME=SRV~VALUE\n\t\t\t */\n\t\t\tif ((att_end - att_beg == s->be->cookie_len) && (s->be->cookie_name != NULL) &&\n\t\t\t    (memcmp(att_beg, s->be->cookie_name, att_end - att_beg) == 0)) {\n\t\t\t\tstruct server *srv = s->be->srv;\n\t\t\t\tchar *delim;\n\n\t\t\t\t/* if we're in cookie prefix mode, we'll search the delimiter so that we\n\t\t\t\t * have the server ID between val_beg and delim, and the original cookie between\n\t\t\t\t * delim+1 and val_end. Otherwise, delim==val_end :\n\t\t\t\t *\n\t\t\t\t * hdr_beg\n\t\t\t\t * |\n\t\t\t\t * v\n\t\t\t\t * NAME=SRV;          # in all but prefix modes\n\t\t\t\t * NAME=SRV~OPAQUE ;  # in prefix mode\n\t\t\t\t * ||   ||  |      |+-> next\n\t\t\t\t * ||   ||  |      +--> val_end\n\t\t\t\t * ||   ||  +---------> delim\n\t\t\t\t * ||   |+------------> val_beg\n\t\t\t\t * ||   +-------------> att_end = equal\n\t\t\t\t * |+-----------------> att_beg\n\t\t\t\t * +------------------> prev\n\t\t\t\t *\n\t\t\t\t */\n\t\t\t\tif (s->be->ck_opts & PR_CK_PFX) {\n\t\t\t\t\tfor (delim = val_beg; delim < val_end; delim++)\n\t\t\t\t\t\tif (*delim == COOKIE_DELIM)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar *vbar1;\n\t\t\t\t\tdelim = val_end;\n\t\t\t\t\t/* Now check if the cookie contains a date field, which would\n\t\t\t\t\t * appear after a vertical bar ('|') just after the server name\n\t\t\t\t\t * and before the delimiter.\n\t\t\t\t\t */\n\t\t\t\t\tvbar1 = memchr(val_beg, COOKIE_DELIM_DATE, val_end - val_beg);\n\t\t\t\t\tif (vbar1) {\n\t\t\t\t\t\t/* OK, so left of the bar is the server's cookie and\n\t\t\t\t\t\t * right is the last seen date. It is a base64 encoded\n\t\t\t\t\t\t * 30-bit value representing the UNIX date since the\n\t\t\t\t\t\t * epoch in 4-second quantities.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tint val;\n\t\t\t\t\t\tdelim = vbar1++;\n\t\t\t\t\t\tif (val_end - vbar1 >= 5) {\n\t\t\t\t\t\t\tval = b64tos30(vbar1);\n\t\t\t\t\t\t\tif (val > 0)\n\t\t\t\t\t\t\t\ttxn->cookie_last_date = val << 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* look for a second vertical bar */\n\t\t\t\t\t\tvbar1 = memchr(vbar1, COOKIE_DELIM_DATE, val_end - vbar1);\n\t\t\t\t\t\tif (vbar1 && (val_end - vbar1 > 5)) {\n\t\t\t\t\t\t\tval = b64tos30(vbar1 + 1);\n\t\t\t\t\t\t\tif (val > 0)\n\t\t\t\t\t\t\t\ttxn->cookie_first_date = val << 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* if the cookie has an expiration date and the proxy wants to check\n\t\t\t\t * it, then we do that now. We first check if the cookie is too old,\n\t\t\t\t * then only if it has expired. We detect strict overflow because the\n\t\t\t\t * time resolution here is not great (4 seconds). Cookies with dates\n\t\t\t\t * in the future are ignored if their offset is beyond one day. This\n\t\t\t\t * allows an admin to fix timezone issues without expiring everyone\n\t\t\t\t * and at the same time avoids keeping unwanted side effects for too\n\t\t\t\t * long.\n\t\t\t\t */\n\t\t\t\tif (txn->cookie_first_date && s->be->cookie_maxlife &&\n\t\t\t\t    (((signed)(date.tv_sec - txn->cookie_first_date) > (signed)s->be->cookie_maxlife) ||\n\t\t\t\t     ((signed)(txn->cookie_first_date - date.tv_sec) > 86400))) {\n\t\t\t\t\ttxn->flags &= ~TX_CK_MASK;\n\t\t\t\t\ttxn->flags |= TX_CK_OLD;\n\t\t\t\t\tdelim = val_beg; // let's pretend we have not found the cookie\n\t\t\t\t\ttxn->cookie_first_date = 0;\n\t\t\t\t\ttxn->cookie_last_date = 0;\n\t\t\t\t}\n\t\t\t\telse if (txn->cookie_last_date && s->be->cookie_maxidle &&\n\t\t\t\t\t (((signed)(date.tv_sec - txn->cookie_last_date) > (signed)s->be->cookie_maxidle) ||\n\t\t\t\t\t  ((signed)(txn->cookie_last_date - date.tv_sec) > 86400))) {\n\t\t\t\t\ttxn->flags &= ~TX_CK_MASK;\n\t\t\t\t\ttxn->flags |= TX_CK_EXPIRED;\n\t\t\t\t\tdelim = val_beg; // let's pretend we have not found the cookie\n\t\t\t\t\ttxn->cookie_first_date = 0;\n\t\t\t\t\ttxn->cookie_last_date = 0;\n\t\t\t\t}\n\n\t\t\t\t/* Here, we'll look for the first running server which supports the cookie.\n\t\t\t\t * This allows to share a same cookie between several servers, for example\n\t\t\t\t * to dedicate backup servers to specific servers only.\n\t\t\t\t * However, to prevent clients from sticking to cookie-less backup server\n\t\t\t\t * when they have incidentely learned an empty cookie, we simply ignore\n\t\t\t\t * empty cookies and mark them as invalid.\n\t\t\t\t * The same behaviour is applied when persistence must be ignored.\n\t\t\t\t */\n\t\t\t\tif ((delim == val_beg) || (s->flags & (SF_IGNORE_PRST | SF_ASSIGNED)))\n\t\t\t\t\tsrv = NULL;\n\n\t\t\t\twhile (srv) {\n\t\t\t\t\tif (srv->cookie && (srv->cklen == delim - val_beg) &&\n\t\t\t\t\t    !memcmp(val_beg, srv->cookie, delim - val_beg)) {\n\t\t\t\t\t\tif ((srv->cur_state != SRV_ST_STOPPED) ||\n\t\t\t\t\t\t    (s->be->options & PR_O_PERSIST) ||\n\t\t\t\t\t\t    (s->flags & SF_FORCE_PRST)) {\n\t\t\t\t\t\t\t/* we found the server and we can use it */\n\t\t\t\t\t\t\ttxn->flags &= ~TX_CK_MASK;\n\t\t\t\t\t\t\ttxn->flags |= (srv->cur_state != SRV_ST_STOPPED) ? TX_CK_VALID : TX_CK_DOWN;\n\t\t\t\t\t\t\ts->flags |= SF_DIRECT | SF_ASSIGNED;\n\t\t\t\t\t\t\ts->target = &srv->obj_type;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* we found a server, but it's down,\n\t\t\t\t\t\t\t * mark it as such and go on in case\n\t\t\t\t\t\t\t * another one is available.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\ttxn->flags &= ~TX_CK_MASK;\n\t\t\t\t\t\t\ttxn->flags |= TX_CK_DOWN;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsrv = srv->next;\n\t\t\t\t}\n\n\t\t\t\tif (!srv && !(txn->flags & (TX_CK_DOWN|TX_CK_EXPIRED|TX_CK_OLD))) {\n\t\t\t\t\t/* no server matched this cookie or we deliberately skipped it */\n\t\t\t\t\ttxn->flags &= ~TX_CK_MASK;\n\t\t\t\t\tif ((s->flags & (SF_IGNORE_PRST | SF_ASSIGNED)))\n\t\t\t\t\t\ttxn->flags |= TX_CK_UNUSED;\n\t\t\t\t\telse\n\t\t\t\t\t\ttxn->flags |= TX_CK_INVALID;\n\t\t\t\t}\n\n\t\t\t\t/* depending on the cookie mode, we may have to either :\n\t\t\t\t * - delete the complete cookie if we're in insert+indirect mode, so that\n\t\t\t\t *   the server never sees it ;\n\t\t\t\t * - remove the server id from the cookie value, and tag the cookie as an\n\t\t\t\t *   application cookie so that it does not get accidentally removed later,\n\t\t\t\t *   if we're in cookie prefix mode\n\t\t\t\t */\n\t\t\t\tif ((s->be->ck_opts & PR_CK_PFX) && (delim != val_end)) {\n\t\t\t\t\tint delta; /* negative */\n\n\t\t\t\t\tmemmove(val_beg, delim + 1, hdr_end - (delim + 1));\n\t\t\t\t\tdelta = val_beg - (delim + 1);\n\t\t\t\t\tval_end  += delta;\n\t\t\t\t\tnext     += delta;\n\t\t\t\t\thdr_end  += delta;\n\t\t\t\t\tdel_from = NULL;\n\t\t\t\t\tpreserve_hdr = 1; /* we want to keep this cookie */\n\t\t\t\t}\n\t\t\t\telse if (del_from == NULL &&\n\t\t\t\t\t (s->be->ck_opts & (PR_CK_INS | PR_CK_IND)) == (PR_CK_INS | PR_CK_IND)) {\n\t\t\t\t\tdel_from = prev;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* This is not our cookie, so we must preserve it. But if we already\n\t\t\t\t * scheduled another cookie for removal, we cannot remove the\n\t\t\t\t * complete header, but we can remove the previous block itself.\n\t\t\t\t */\n\t\t\t\tpreserve_hdr = 1;\n\n\t\t\t\tif (del_from != NULL) {\n\t\t\t\t\tint delta = http_del_hdr_value(hdr_beg, hdr_end, &del_from, prev);\n\t\t\t\t\tif (att_beg >= del_from)\n\t\t\t\t\t\tatt_beg += delta;\n\t\t\t\t\tif (att_end >= del_from)\n\t\t\t\t\t\tatt_end += delta;\n\t\t\t\t\tval_beg  += delta;\n\t\t\t\t\tval_end  += delta;\n\t\t\t\t\tnext     += delta;\n\t\t\t\t\thdr_end  += delta;\n\t\t\t\t\tprev     = del_from;\n\t\t\t\t\tdel_from = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} /* for each cookie */\n\n\n\t\t/* There are no more cookies on this line.\n\t\t * We may still have one (or several) marked for deletion at the\n\t\t * end of the line. We must do this now in two ways :\n\t\t *  - if some cookies must be preserved, we only delete from the\n\t\t *    mark to the end of line ;\n\t\t *  - if nothing needs to be preserved, simply delete the whole header\n\t\t */\n\t\tif (del_from) {\n\t\t\thdr_end = (preserve_hdr ? del_from : hdr_beg);\n\t\t}\n\t\tif ((hdr_end - hdr_beg) != ctx.value.len) {\n\t\t\tif (hdr_beg != hdr_end)\n\t\t\t\thtx_change_blk_value_len(htx, ctx.blk, hdr_end - hdr_beg);\n\t\t\telse\n\t\t\t\thttp_remove_header(htx, &ctx);\n\t\t}\n\t} /* for each \"Cookie header */\n}\n\n/*\n * Manage server-side cookies. It can impact performance by about 2% so it is\n * desirable to call it only when needed. This function is also used when we\n * just need to know if there is a cookie (eg: for check-cache).\n */\nstatic void http_manage_server_side_cookies(struct stream *s, struct channel *res)\n{\n\tstruct session *sess = s->sess;\n\tstruct http_txn *txn = s->txn;\n\tstruct htx *htx;\n\tstruct http_hdr_ctx ctx;\n\tstruct server *srv;\n\tchar *hdr_beg, *hdr_end;\n\tchar *prev, *att_beg, *att_end, *equal, *val_beg, *val_end, *next;\n\tint is_cookie2 = 0;\n\n\thtx = htxbuf(&res->buf);\n\n\tctx.blk = NULL;\n\twhile (1) {\n\t\tint is_first = 1;\n\n\t\tif (!http_find_header(htx, ist(\"Set-Cookie\"), &ctx, 1)) {\n\t\t\tif (!http_find_header(htx, ist(\"Set-Cookie2\"), &ctx, 1))\n\t\t\t\tbreak;\n\t\t\tis_cookie2 = 1;\n\t\t}\n\n\t\t/* OK, right now we know we have a Set-Cookie* at hdr_beg, and\n\t\t * <prev> points to the colon.\n\t\t */\n\t\ttxn->flags |= TX_SCK_PRESENT;\n\n\t\t/* Maybe we only wanted to see if there was a Set-Cookie (eg:\n\t\t * check-cache is enabled) and we are not interested in checking\n\t\t * them. Warning, the cookie capture is declared in the frontend.\n\t\t */\n\t\tif (s->be->cookie_name == NULL && sess->fe->capture_name == NULL)\n\t\t\tbreak;\n\n\t\t/* OK so now we know we have to process this response cookie.\n\t\t * The format of the Set-Cookie header is slightly different\n\t\t * from the format of the Cookie header in that it does not\n\t\t * support the comma as a cookie delimiter (thus the header\n\t\t * cannot be folded) because the Expires attribute described in\n\t\t * the original Netscape's spec may contain an unquoted date\n\t\t * with a comma inside. We have to live with this because\n\t\t * many browsers don't support Max-Age and some browsers don't\n\t\t * support quoted strings. However the Set-Cookie2 header is\n\t\t * clean.\n\t\t *\n\t\t * We have to keep multiple pointers in order to support cookie\n\t\t * removal at the beginning, middle or end of header without\n\t\t * corrupting the header (in case of set-cookie2). A special\n\t\t * pointer, <scav> points to the beginning of the set-cookie-av\n\t\t * fields after the first semi-colon. The <next> pointer points\n\t\t * either to the end of line (set-cookie) or next unquoted comma\n\t\t * (set-cookie2). All of these headers are valid :\n\t\t *\n\t\t * hdr_beg                                                  hdr_end\n\t\t * |                                                           |\n\t\t * v                                                           |\n\t\t * NAME1  =  VALUE 1  ; Secure; Path=\"/\"                       |\n\t\t * NAME=VALUE; Secure; Expires=Thu, 01-Jan-1970 00:00:01 GMT   v\n\t\t * NAME = VALUE ; Secure; Expires=Thu, 01-Jan-1970 00:00:01 GMT\n\t\t * NAME1 = VALUE 1 ; Max-Age=0, NAME2=VALUE2; Discard\n\t\t * | |   | | |     | |          |\n\t\t * | |   | | |     | |          +-> next\n\t\t * | |   | | |     | +------------> scav\n\t\t * | |   | | |     +--------------> val_end\n\t\t * | |   | | +--------------------> val_beg\n\t\t * | |   | +----------------------> equal\n\t\t * | |   +------------------------> att_end\n\t\t * | +----------------------------> att_beg\n\t\t * +------------------------------> prev\n\t\t * -------------------------------> hdr_beg\n\t\t */\n\t\thdr_beg = ctx.value.ptr;\n\t\thdr_end = hdr_beg + ctx.value.len;\n\t\tfor (prev = hdr_beg; prev < hdr_end; prev = next) {\n\n\t\t\t/* Iterate through all cookies on this line */\n\n\t\t\t/* find att_beg */\n\t\t\tatt_beg = prev;\n\t\t\tif (!is_first)\n\t\t\t\tatt_beg++;\n\t\t\tis_first = 0;\n\n\t\t\twhile (att_beg < hdr_end && HTTP_IS_SPHT(*att_beg))\n\t\t\t\tatt_beg++;\n\n\t\t\t/* find att_end : this is the first character after the last non\n\t\t\t * space before the equal. It may be equal to hdr_end.\n\t\t\t */\n\t\t\tequal = att_end = att_beg;\n\n\t\t\twhile (equal < hdr_end) {\n\t\t\t\tif (*equal == '=' || *equal == ';' || (is_cookie2 && *equal == ','))\n\t\t\t\t\tbreak;\n\t\t\t\tif (HTTP_IS_SPHT(*equal++))\n\t\t\t\t\tcontinue;\n\t\t\t\tatt_end = equal;\n\t\t\t}\n\n\t\t\t/* here, <equal> points to '=', a delimiter or the end. <att_end>\n\t\t\t * is between <att_beg> and <equal>, both may be identical.\n\t\t\t */\n\n\t\t\t/* look for end of cookie if there is an equal sign */\n\t\t\tif (equal < hdr_end && *equal == '=') {\n\t\t\t\t/* look for the beginning of the value */\n\t\t\t\tval_beg = equal + 1;\n\t\t\t\twhile (val_beg < hdr_end && HTTP_IS_SPHT(*val_beg))\n\t\t\t\t\tval_beg++;\n\n\t\t\t\t/* find the end of the value, respecting quotes */\n\t\t\t\tnext = http_find_cookie_value_end(val_beg, hdr_end);\n\n\t\t\t\t/* make val_end point to the first white space or delimiter after the value */\n\t\t\t\tval_end = next;\n\t\t\t\twhile (val_end > val_beg && HTTP_IS_SPHT(*(val_end - 1)))\n\t\t\t\t\tval_end--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* <equal> points to next comma, semi-colon or EOL */\n\t\t\t\tval_beg = val_end = next = equal;\n\t\t\t}\n\n\t\t\tif (next < hdr_end) {\n\t\t\t\t/* Set-Cookie2 supports multiple cookies, and <next> points to\n\t\t\t\t * a colon or semi-colon before the end. So skip all attr-value\n\t\t\t\t * pairs and look for the next comma. For Set-Cookie, since\n\t\t\t\t * commas are permitted in values, skip to the end.\n\t\t\t\t */\n\t\t\t\tif (is_cookie2)\n\t\t\t\t\tnext = http_find_hdr_value_end(next, hdr_end);\n\t\t\t\telse\n\t\t\t\t\tnext = hdr_end;\n\t\t\t}\n\n\t\t\t/* Now everything is as on the diagram above */\n\n\t\t\t/* Ignore cookies with no equal sign */\n\t\t\tif (equal == val_end)\n\t\t\t\tcontinue;\n\n\t\t\t/* If there are spaces around the equal sign, we need to\n\t\t\t * strip them otherwise we'll get trouble for cookie captures,\n\t\t\t * or even for rewrites. Since this happens extremely rarely,\n\t\t\t * it does not hurt performance.\n\t\t\t */\n\t\t\tif (unlikely(att_end != equal || val_beg > equal + 1)) {\n\t\t\t\tint stripped_before = 0;\n\t\t\t\tint stripped_after = 0;\n\n\t\t\t\tif (att_end != equal) {\n\t\t\t\t\tmemmove(att_end, equal, hdr_end - equal);\n\t\t\t\t\tstripped_before = (att_end - equal);\n\t\t\t\t\tequal   += stripped_before;\n\t\t\t\t\tval_beg += stripped_before;\n\t\t\t\t}\n\n\t\t\t\tif (val_beg > equal + 1) {\n\t\t\t\t\tmemmove(equal + 1, val_beg, hdr_end + stripped_before - val_beg);\n\t\t\t\t\tstripped_after = (equal + 1) - val_beg;\n\t\t\t\t\tval_beg += stripped_after;\n\t\t\t\t\tstripped_before += stripped_after;\n\t\t\t\t}\n\n\t\t\t\tval_end      += stripped_before;\n\t\t\t\tnext         += stripped_before;\n\t\t\t\thdr_end      += stripped_before;\n\n\t\t\t\thtx_change_blk_value_len(htx, ctx.blk, hdr_end - hdr_beg);\n\t\t\t\tctx.value.len = hdr_end - hdr_beg;\n\t\t\t}\n\n\t\t\t/* First, let's see if we want to capture this cookie. We check\n\t\t\t * that we don't already have a server side cookie, because we\n\t\t\t * can only capture one. Also as an optimisation, we ignore\n\t\t\t * cookies shorter than the declared name.\n\t\t\t */\n\t\t\tif (sess->fe->capture_name != NULL &&\n\t\t\t    txn->srv_cookie == NULL &&\n\t\t\t    (val_end - att_beg >= sess->fe->capture_namelen) &&\n\t\t\t    memcmp(att_beg, sess->fe->capture_name, sess->fe->capture_namelen) == 0) {\n\t\t\t\tint log_len = val_end - att_beg;\n\t\t\t\tif ((txn->srv_cookie = pool_alloc(pool_head_capture)) == NULL) {\n\t\t\t\t\tha_alert(\"HTTP logging : out of memory.\\n\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (log_len > sess->fe->capture_len)\n\t\t\t\t\t\tlog_len = sess->fe->capture_len;\n\t\t\t\t\tmemcpy(txn->srv_cookie, att_beg, log_len);\n\t\t\t\t\ttxn->srv_cookie[log_len] = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsrv = objt_server(s->target);\n\t\t\t/* now check if we need to process it for persistence */\n\t\t\tif (!(s->flags & SF_IGNORE_PRST) &&\n\t\t\t    (att_end - att_beg == s->be->cookie_len) && (s->be->cookie_name != NULL) &&\n\t\t\t    (memcmp(att_beg, s->be->cookie_name, att_end - att_beg) == 0)) {\n\t\t\t\t/* assume passive cookie by default */\n\t\t\t\ttxn->flags &= ~TX_SCK_MASK;\n\t\t\t\ttxn->flags |= TX_SCK_FOUND;\n\n\t\t\t\t/* If the cookie is in insert mode on a known server, we'll delete\n\t\t\t\t * this occurrence because we'll insert another one later.\n\t\t\t\t * We'll delete it too if the \"indirect\" option is set and we're in\n\t\t\t\t * a direct access.\n\t\t\t\t */\n\t\t\t\tif (s->be->ck_opts & PR_CK_PSV) {\n\t\t\t\t\t/* The \"preserve\" flag was set, we don't want to touch the\n\t\t\t\t\t * server's cookie.\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t\telse if ((srv && (s->be->ck_opts & PR_CK_INS)) ||\n\t\t\t\t    ((s->flags & SF_DIRECT) && (s->be->ck_opts & PR_CK_IND))) {\n\t\t\t\t\t/* this cookie must be deleted */\n\t\t\t\t\tif (prev == hdr_beg && next == hdr_end) {\n\t\t\t\t\t\t/* whole header */\n\t\t\t\t\t\thttp_remove_header(htx, &ctx);\n\t\t\t\t\t\t/* note: while both invalid now, <next> and <hdr_end>\n\t\t\t\t\t\t * are still equal, so the for() will stop as expected.\n\t\t\t\t\t\t */\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* just remove the value */\n\t\t\t\t\t\tint delta = http_del_hdr_value(hdr_beg, hdr_end, &prev, next);\n\t\t\t\t\t\tnext      = prev;\n\t\t\t\t\t\thdr_end  += delta;\n\t\t\t\t\t}\n\t\t\t\t\ttxn->flags &= ~TX_SCK_MASK;\n\t\t\t\t\ttxn->flags |= TX_SCK_DELETED;\n\t\t\t\t\t/* and go on with next cookie */\n\t\t\t\t}\n\t\t\t\telse if (srv && srv->cookie && (s->be->ck_opts & PR_CK_RW)) {\n\t\t\t\t\t/* replace bytes val_beg->val_end with the cookie name associated\n\t\t\t\t\t * with this server since we know it.\n\t\t\t\t\t */\n\t\t\t\t\tint sliding, delta;\n\n\t\t\t\t\tctx.value = ist2(val_beg, val_end - val_beg);\n\t\t\t\t        ctx.lws_before = ctx.lws_after = 0;\n\t\t\t\t\thttp_replace_header_value(htx, &ctx, ist2(srv->cookie, srv->cklen));\n\t\t\t\t\tdelta     = srv->cklen - (val_end - val_beg);\n\t\t\t\t\tsliding   = (ctx.value.ptr - val_beg);\n\t\t\t\t\thdr_beg  += sliding;\n\t\t\t\t\tval_beg  += sliding;\n\t\t\t\t\tnext     += sliding + delta;\n\t\t\t\t\thdr_end  += sliding + delta;\n\n\t\t\t\t\ttxn->flags &= ~TX_SCK_MASK;\n\t\t\t\t\ttxn->flags |= TX_SCK_REPLACED;\n\t\t\t\t}\n\t\t\t\telse if (srv && srv->cookie && (s->be->ck_opts & PR_CK_PFX)) {\n\t\t\t\t\t/* insert the cookie name associated with this server\n\t\t\t\t\t * before existing cookie, and insert a delimiter between them..\n\t\t\t\t\t */\n\t\t\t\t\tint sliding, delta;\n\t\t\t\t\tctx.value = ist2(val_beg, 0);\n\t\t\t\t        ctx.lws_before = ctx.lws_after = 0;\n\t\t\t\t\thttp_replace_header_value(htx, &ctx, ist2(srv->cookie, srv->cklen + 1));\n\t\t\t\t\tdelta     = srv->cklen + 1;\n\t\t\t\t\tsliding   = (ctx.value.ptr - val_beg);\n\t\t\t\t\thdr_beg  += sliding;\n\t\t\t\t\tval_beg  += sliding;\n\t\t\t\t\tnext     += sliding + delta;\n\t\t\t\t\thdr_end  += sliding + delta;\n\n\t\t\t\t\tval_beg[srv->cklen] = COOKIE_DELIM;\n\t\t\t\t\ttxn->flags &= ~TX_SCK_MASK;\n\t\t\t\t\ttxn->flags |= TX_SCK_REPLACED;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* that's done for this cookie, check the next one on the same\n\t\t\t * line when next != hdr_end (only if is_cookie2).\n\t\t\t */\n\t\t}\n\t}\n}\n\n/*\n * Parses the Cache-Control and Pragma request header fields to determine if\n * the request may be served from the cache and/or if it is cacheable. Updates\n * s->txn->flags.\n */\nvoid http_check_request_for_cacheability(struct stream *s, struct channel *req)\n{\n\tstruct http_txn *txn = s->txn;\n\tstruct htx *htx;\n\tstruct http_hdr_ctx ctx = { .blk = NULL };\n\tint pragma_found, cc_found;\n\n\tif ((txn->flags & (TX_CACHEABLE|TX_CACHE_IGNORE)) == TX_CACHE_IGNORE)\n\t\treturn; /* nothing more to do here */\n\n\thtx = htxbuf(&req->buf);\n\tpragma_found = cc_found = 0;\n\n\t/* Check \"pragma\" header for HTTP/1.0 compatibility. */\n\tif (http_find_header(htx, ist(\"pragma\"), &ctx, 1)) {\n\t\tif (isteqi(ctx.value, ist(\"no-cache\"))) {\n\t\t\tpragma_found = 1;\n\t\t}\n\t}\n\n\tctx.blk = NULL;\n\t/* Don't use the cache and don't try to store if we found the\n\t * Authorization header */\n\tif (http_find_header(htx, ist(\"authorization\"), &ctx, 1)) {\n\t\ttxn->flags &= ~TX_CACHEABLE & ~TX_CACHE_COOK;\n\t\ttxn->flags |= TX_CACHE_IGNORE;\n\t}\n\n\n\t/* Look for \"cache-control\" header and iterate over all the values\n\t * until we find one that specifies that caching is possible or not. */\n\tctx.blk = NULL;\n\twhile (http_find_header(htx, ist(\"cache-control\"), &ctx, 0)) {\n\t\tcc_found = 1;\n\t\t/* We don't check the values after max-age, max-stale nor min-fresh,\n\t\t * we simply don't use the cache when they're specified. */\n\t\tif (istmatchi(ctx.value, ist(\"max-age\")) ||\n\t\t    istmatchi(ctx.value, ist(\"no-cache\")) ||\n\t\t    istmatchi(ctx.value, ist(\"max-stale\")) ||\n\t\t    istmatchi(ctx.value, ist(\"min-fresh\"))) {\n\t\t\ttxn->flags |= TX_CACHE_IGNORE;\n\t\t\tcontinue;\n\t\t}\n\t\tif (istmatchi(ctx.value, ist(\"no-store\"))) {\n\t\t\ttxn->flags &= ~TX_CACHEABLE & ~TX_CACHE_COOK;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\t/* RFC7234#5.4:\n\t *   When the Cache-Control header field is also present and\n\t *   understood in a request, Pragma is ignored.\n\t *   When the Cache-Control header field is not present in a\n\t *   request, caches MUST consider the no-cache request\n\t *   pragma-directive as having the same effect as if\n\t *   \"Cache-Control: no-cache\" were present.\n\t */\n\tif (!cc_found && pragma_found)\n\t\ttxn->flags |= TX_CACHE_IGNORE;\n}\n\n/*\n * Check if response is cacheable or not. Updates s->txn->flags.\n */\nvoid http_check_response_for_cacheability(struct stream *s, struct channel *res)\n{\n\tstruct http_txn *txn = s->txn;\n\tstruct http_hdr_ctx ctx = { .blk = NULL };\n\tstruct htx *htx;\n\tint has_freshness_info = 0;\n\tint has_validator = 0;\n\n\tif (txn->status < 200) {\n\t\t/* do not try to cache interim responses! */\n\t\ttxn->flags &= ~TX_CACHEABLE & ~TX_CACHE_COOK;\n\t\treturn;\n\t}\n\n\thtx = htxbuf(&res->buf);\n\t/* Check \"pragma\" header for HTTP/1.0 compatibility. */\n\tif (http_find_header(htx, ist(\"pragma\"), &ctx, 1)) {\n\t\tif (isteqi(ctx.value, ist(\"no-cache\"))) {\n\t\t\ttxn->flags &= ~TX_CACHEABLE & ~TX_CACHE_COOK;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Look for \"cache-control\" header and iterate over all the values\n\t * until we find one that specifies that caching is possible or not. */\n\tctx.blk = NULL;\n\twhile (http_find_header(htx, ist(\"cache-control\"), &ctx, 0)) {\n\t\tif (isteqi(ctx.value, ist(\"public\"))) {\n\t\t\ttxn->flags |= TX_CACHEABLE | TX_CACHE_COOK;\n\t\t\tcontinue;\n\t\t}\n\t\tif (isteqi(ctx.value, ist(\"private\")) ||\n\t\t    isteqi(ctx.value, ist(\"no-cache\")) ||\n\t\t    isteqi(ctx.value, ist(\"no-store\")) ||\n\t\t    isteqi(ctx.value, ist(\"max-age=0\")) ||\n\t\t    isteqi(ctx.value, ist(\"s-maxage=0\"))) {\n\t\t\ttxn->flags &= ~TX_CACHEABLE & ~TX_CACHE_COOK;\n\t\t\tcontinue;\n\t\t}\n\t\t/* We might have a no-cache=\"set-cookie\" form. */\n\t\tif (istmatchi(ctx.value, ist(\"no-cache=\\\"set-cookie\"))) {\n\t\t\ttxn->flags &= ~TX_CACHE_COOK;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (istmatchi(ctx.value, ist(\"s-maxage\")) ||\n\t\t    istmatchi(ctx.value, ist(\"max-age\"))) {\n\t\t\thas_freshness_info = 1;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\t/* If no freshness information could be found in Cache-Control values,\n\t * look for an Expires header. */\n\tif (!has_freshness_info) {\n\t\tctx.blk = NULL;\n\t\thas_freshness_info = http_find_header(htx, ist(\"expires\"), &ctx, 0);\n\t}\n\n\t/* If no freshness information could be found in Cache-Control or Expires\n\t * values, look for an explicit validator. */\n\tif (!has_freshness_info) {\n\t\tctx.blk = NULL;\n\t\thas_validator = 1;\n\t\tif (!http_find_header(htx, ist(\"etag\"), &ctx, 0)) {\n\t\t\tctx.blk = NULL;\n\t\t\tif (!http_find_header(htx, ist(\"last-modified\"), &ctx, 0))\n\t\t\t\thas_validator = 0;\n\t\t}\n\t}\n\n\t/* We won't store an entry that has neither a cache validator nor an\n\t * explicit expiration time, as suggested in RFC 7234#3. */\n\tif (!has_freshness_info && !has_validator)\n\t\ttxn->flags |= TX_CACHE_IGNORE;\n}\n\n/*\n * In a GET, HEAD or POST request, check if the requested URI matches the stats uri\n * for the current backend.\n *\n * It is assumed that the request is either a HEAD, GET, or POST and that the\n * uri_auth field is valid.\n *\n * Returns 1 if stats should be provided, otherwise 0.\n */\nstatic int http_stats_check_uri(struct stream *s, struct http_txn *txn, struct proxy *backend)\n{\n\tstruct uri_auth *uri_auth = backend->uri_auth;\n\tstruct htx *htx;\n\tstruct htx_sl *sl;\n\tstruct ist uri;\n\n\tif (!uri_auth)\n\t\treturn 0;\n\n\tif (txn->meth != HTTP_METH_GET && txn->meth != HTTP_METH_HEAD && txn->meth != HTTP_METH_POST)\n\t\treturn 0;\n\n\thtx = htxbuf(&s->req.buf);\n\tsl = http_get_stline(htx);\n\turi = htx_sl_req_uri(sl);\n\tif (*uri_auth->uri_prefix == '/') {\n\t\tstruct http_uri_parser parser = http_uri_parser_init(uri);\n\t\turi = http_parse_path(&parser);\n\t}\n\n\t/* check URI size */\n\tif (uri_auth->uri_len > uri.len)\n\t\treturn 0;\n\n\tif (memcmp(uri.ptr, uri_auth->uri_prefix, uri_auth->uri_len) != 0)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n/* This function prepares an applet to handle the stats. It can deal with the\n * \"100-continue\" expectation, check that admin rules are met for POST requests,\n * and program a response message if something was unexpected. It cannot fail\n * and always relies on the stats applet to complete the job. It does not touch\n * analysers nor counters, which are left to the caller. It does not touch\n * s->target which is supposed to already point to the stats applet. The caller\n * is expected to have already assigned an appctx to the stream.\n */\nstatic int http_handle_stats(struct stream *s, struct channel *req)\n{\n\tstruct stats_admin_rule *stats_admin_rule;\n\tstruct stream_interface *si = &s->si[1];\n\tstruct session *sess = s->sess;\n\tstruct http_txn *txn = s->txn;\n\tstruct http_msg *msg = &txn->req;\n\tstruct uri_auth *uri_auth = s->be->uri_auth;\n\tconst char *h, *lookup, *end;\n\tstruct appctx *appctx;\n\tstruct htx *htx;\n\tstruct htx_sl *sl;\n\n\tappctx = si_appctx(si);\n\tmemset(&appctx->ctx.stats, 0, sizeof(appctx->ctx.stats));\n\tappctx->st1 = appctx->st2 = 0;\n\tappctx->ctx.stats.st_code = STAT_STATUS_INIT;\n\tappctx->ctx.stats.flags |= uri_auth->flags;\n\tappctx->ctx.stats.flags |= STAT_FMT_HTML; /* assume HTML mode by default */\n\tif ((msg->flags & HTTP_MSGF_VER_11) && (txn->meth != HTTP_METH_HEAD))\n\t\tappctx->ctx.stats.flags |= STAT_CHUNKED;\n\n\thtx = htxbuf(&req->buf);\n\tsl = http_get_stline(htx);\n\tlookup = HTX_SL_REQ_UPTR(sl) + uri_auth->uri_len;\n\tend = HTX_SL_REQ_UPTR(sl) + HTX_SL_REQ_ULEN(sl);\n\n\tfor (h = lookup; h <= end - 3; h++) {\n\t\tif (memcmp(h, \";up\", 3) == 0) {\n\t\t\tappctx->ctx.stats.flags |= STAT_HIDE_DOWN;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (h = lookup; h <= end - 9; h++) {\n\t\tif (memcmp(h, \";no-maint\", 9) == 0) {\n\t\t\tappctx->ctx.stats.flags |= STAT_HIDE_MAINT;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (uri_auth->refresh) {\n\t\tfor (h = lookup; h <= end - 10; h++) {\n\t\t\tif (memcmp(h, \";norefresh\", 10) == 0) {\n\t\t\t\tappctx->ctx.stats.flags |= STAT_NO_REFRESH;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (h = lookup; h <= end - 4; h++) {\n\t\tif (memcmp(h, \";csv\", 4) == 0) {\n\t\t\tappctx->ctx.stats.flags &= ~(STAT_FMT_MASK|STAT_JSON_SCHM);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (h = lookup; h <= end - 6; h++) {\n\t\tif (memcmp(h, \";typed\", 6) == 0) {\n\t\t\tappctx->ctx.stats.flags &= ~(STAT_FMT_MASK|STAT_JSON_SCHM);\n\t\t\tappctx->ctx.stats.flags |= STAT_FMT_TYPED;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (h = lookup; h <= end - 5; h++) {\n\t\tif (memcmp(h, \";json\", 5) == 0) {\n\t\t\tappctx->ctx.stats.flags &= ~(STAT_FMT_MASK|STAT_JSON_SCHM);\n\t\t\tappctx->ctx.stats.flags |= STAT_FMT_JSON;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (h = lookup; h <= end - 12; h++) {\n\t\tif (memcmp(h, \";json-schema\", 12) == 0) {\n\t\t\tappctx->ctx.stats.flags &= ~STAT_FMT_MASK;\n\t\t\tappctx->ctx.stats.flags |= STAT_JSON_SCHM;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (h = lookup; h <= end - 8; h++) {\n\t\tif (memcmp(h, \";st=\", 4) == 0) {\n\t\t\tint i;\n\t\t\th += 4;\n\t\t\tappctx->ctx.stats.st_code = STAT_STATUS_UNKN;\n\t\t\tfor (i = STAT_STATUS_INIT + 1; i < STAT_STATUS_SIZE; i++) {\n\t\t\t\tif (strncmp(stat_status_codes[i], h, 4) == 0) {\n\t\t\t\t\tappctx->ctx.stats.st_code = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tappctx->ctx.stats.scope_str = 0;\n\tappctx->ctx.stats.scope_len = 0;\n\tfor (h = lookup; h <= end - 8; h++) {\n\t\tif (memcmp(h, STAT_SCOPE_INPUT_NAME \"=\", strlen(STAT_SCOPE_INPUT_NAME) + 1) == 0) {\n\t\t\tint itx = 0;\n\t\t\tconst char *h2;\n\t\t\tchar scope_txt[STAT_SCOPE_TXT_MAXLEN + 1];\n\t\t\tconst char *err;\n\n\t\t\th += strlen(STAT_SCOPE_INPUT_NAME) + 1;\n\t\t\th2 = h;\n\t\t\tappctx->ctx.stats.scope_str = h2 - HTX_SL_REQ_UPTR(sl);\n\t\t\twhile (h < end) {\n\t\t\t\tif (*h == ';' || *h == '&' || *h == ' ')\n\t\t\t\t\tbreak;\n\t\t\t\titx++;\n\t\t\t\th++;\n\t\t\t}\n\n\t\t\tif (itx > STAT_SCOPE_TXT_MAXLEN)\n\t\t\t\titx = STAT_SCOPE_TXT_MAXLEN;\n\t\t\tappctx->ctx.stats.scope_len = itx;\n\n\t\t\t/* scope_txt = search query, appctx->ctx.stats.scope_len is always <= STAT_SCOPE_TXT_MAXLEN */\n\t\t\tmemcpy(scope_txt, h2, itx);\n\t\t\tscope_txt[itx] = '\\0';\n\t\t\terr = invalid_char(scope_txt);\n\t\t\tif (err) {\n\t\t\t\t/* bad char in search text => clear scope */\n\t\t\t\tappctx->ctx.stats.scope_str = 0;\n\t\t\t\tappctx->ctx.stats.scope_len = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* now check whether we have some admin rules for this request */\n\tlist_for_each_entry(stats_admin_rule, &uri_auth->admin_rules, list) {\n\t\tint ret = 1;\n\n\t\tif (stats_admin_rule->cond) {\n\t\t\tret = acl_exec_cond(stats_admin_rule->cond, s->be, sess, s, SMP_OPT_DIR_REQ|SMP_OPT_FINAL);\n\t\t\tret = acl_pass(ret);\n\t\t\tif (stats_admin_rule->cond->pol == ACL_COND_UNLESS)\n\t\t\t\tret = !ret;\n\t\t}\n\n\t\tif (ret) {\n\t\t\t/* no rule, or the rule matches */\n\t\t\tappctx->ctx.stats.flags |= STAT_ADMIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (txn->meth == HTTP_METH_GET || txn->meth == HTTP_METH_HEAD)\n\t\tappctx->st0 = STAT_HTTP_HEAD;\n\telse if (txn->meth == HTTP_METH_POST) {\n\t\tif (appctx->ctx.stats.flags & STAT_ADMIN) {\n\t\t\tappctx->st0 = STAT_HTTP_POST;\n\t\t\tif (msg->msg_state < HTTP_MSG_DATA)\n\t\t\t\treq->analysers |= AN_REQ_HTTP_BODY;\n\t\t}\n\t\telse {\n\t\t\t/* POST without admin level */\n\t\t\tappctx->ctx.stats.flags &= ~STAT_CHUNKED;\n\t\t\tappctx->ctx.stats.st_code = STAT_STATUS_DENY;\n\t\t\tappctx->st0 = STAT_HTTP_LAST;\n\t\t}\n\t}\n\telse {\n\t\t/* Unsupported method */\n\t\tappctx->ctx.stats.flags &= ~STAT_CHUNKED;\n\t\tappctx->ctx.stats.st_code = STAT_STATUS_IVAL;\n\t\tappctx->st0 = STAT_HTTP_LAST;\n\t}\n\n\ts->task->nice = -32; /* small boost for HTTP statistics */\n\treturn 1;\n}\n\n/* This function waits for the message payload at most <time> milliseconds (may\n * be set to TICK_ETERNITY). It stops to wait if at least <bytes> bytes of the\n * payload are received (0 means no limit). It returns HTTP_RULE_* depending on\n * the result:\n *\n *   - HTTP_RULE_RES_CONT when  conditions are met to stop waiting\n *   - HTTP_RULE_RES_YIELD to wait for more data\n *   - HTTP_RULE_RES_ABRT when a timeout occurred.\n *   - HTTP_RULE_RES_BADREQ if a parsing error is raised by lower level\n *   - HTTP_RULE_RES_ERROR if an internal error occurred\n *\n * If a timeout occurred, this function is responsible to emit the right response\n * to the client, depending on the channel (408 on request side, 504 on response\n * side). All other errors must be handled by the caller.\n */\nenum rule_result http_wait_for_msg_body(struct stream *s, struct channel *chn,\n\t\t\t\t\tunsigned int time, unsigned int bytes)\n{\n\tstruct session *sess = s->sess;\n\tstruct http_txn *txn = s->txn;\n\tstruct http_msg *msg = ((chn->flags & CF_ISRESP) ? &txn->rsp : &txn->req);\n\tstruct htx *htx;\n\tenum rule_result ret = HTTP_RULE_RES_CONT;\n\n\thtx = htxbuf(&chn->buf);\n\n\tif (htx->flags & HTX_FL_PARSING_ERROR) {\n\t\tret = HTTP_RULE_RES_BADREQ;\n\t\tgoto end;\n\t}\n\tif (htx->flags & HTX_FL_PROCESSING_ERROR) {\n\t\tret = HTTP_RULE_RES_ERROR;\n\t\tgoto end;\n\t}\n\n\t/* Do nothing for bodyless and CONNECT requests */\n\tif (txn->meth == HTTP_METH_CONNECT || (msg->flags & HTTP_MSGF_BODYLESS))\n\t\tgoto end;\n\n\tif (!(chn->flags & CF_ISRESP) && msg->msg_state < HTTP_MSG_DATA) {\n\t\tif (http_handle_expect_hdr(s, htx, msg) == -1) {\n\t\t\tret = HTTP_RULE_RES_ERROR;\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tmsg->msg_state = HTTP_MSG_DATA;\n\n\t/* Now we're in HTTP_MSG_DATA. We just need to know if all data have\n\t * been received or if the buffer is full.\n\t */\n\tif ((htx->flags & HTX_FL_EOM) ||\n\t    htx_get_tail_type(htx) > HTX_BLK_DATA ||\n\t    channel_htx_full(chn, htx, global.tune.maxrewrite) ||\n\t    si_rx_blocked_room(chn_prod(chn)))\n\t\tgoto end;\n\n\tif (bytes) {\n\t\tstruct htx_blk *blk;\n\t\tunsigned int len = 0;\n\n\t\tfor (blk = htx_get_first_blk(htx); blk; blk = htx_get_next_blk(htx, blk)) {\n\t\t\tif (htx_get_blk_type(blk) != HTX_BLK_DATA)\n\t\t\t\tcontinue;\n\t\t\tlen += htx_get_blksz(blk);\n\t\t\tif (len >= bytes)\n\t\t\t\tgoto end;\n\t\t}\n\t}\n\n\tif ((chn->flags & CF_READ_TIMEOUT) || tick_is_expired(chn->analyse_exp, now_ms)) {\n\t\tif (!(chn->flags & CF_ISRESP))\n\t\t\tgoto abort_req;\n\t\tgoto abort_res;\n\t}\n\n\t/* we get here if we need to wait for more data */\n\tif (!(chn->flags & (CF_SHUTR | CF_READ_ERROR))) {\n\t\tif (!tick_isset(chn->analyse_exp))\n\t\t\tchn->analyse_exp = tick_add_ifset(now_ms, time);\n\t\tret = HTTP_RULE_RES_YIELD;\n\t}\n\n  end:\n\treturn ret;\n\n  abort_req:\n\ttxn->status = 408;\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_CLITO;\n\tif (!(s->flags & SF_FINST_MASK))\n\t\ts->flags |= SF_FINST_D;\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.failed_req);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->failed_req);\n\thttp_reply_and_close(s, txn->status, http_error_message(s));\n\tret = HTTP_RULE_RES_ABRT;\n\tgoto end;\n\n  abort_res:\n\ttxn->status = 504;\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_SRVTO;\n\tif (!(s->flags & SF_FINST_MASK))\n\t\ts->flags |= SF_FINST_D;\n\tstream_inc_http_fail_ctr(s);\n\thttp_reply_and_close(s, txn->status, http_error_message(s));\n\tret = HTTP_RULE_RES_ABRT;\n\tgoto end;\n}\n\nvoid http_perform_server_redirect(struct stream *s, struct stream_interface *si)\n{\n\tstruct channel *req = &s->req;\n\tstruct channel *res = &s->res;\n\tstruct server *srv;\n\tstruct htx *htx;\n\tstruct htx_sl *sl;\n\tstruct ist path, location;\n\tunsigned int flags;\n\tstruct http_uri_parser parser;\n\n\t/*\n\t * Create the location\n\t */\n\tchunk_reset(&trash);\n\n\t/* 1: add the server's prefix */\n\t/* special prefix \"/\" means don't change URL */\n\tsrv = __objt_server(s->target);\n\tif (srv->rdr_len != 1 || *srv->rdr_pfx != '/') {\n\t\tif (!chunk_memcat(&trash, srv->rdr_pfx, srv->rdr_len))\n\t\t\treturn;\n\t}\n\n\t/* 2: add the request Path */\n\thtx = htxbuf(&req->buf);\n\tsl = http_get_stline(htx);\n\tparser = http_uri_parser_init(htx_sl_req_uri(sl));\n\tpath = http_parse_path(&parser);\n\tif (!isttest(path))\n\t\treturn;\n\n\tif (!chunk_memcat(&trash, path.ptr, path.len))\n\t\treturn;\n\tlocation = ist2(trash.area, trash.data);\n\n\t/*\n\t * Create the 302 respone\n\t */\n\thtx = htx_from_buf(&res->buf);\n\tflags = (HTX_SL_F_IS_RESP|HTX_SL_F_VER_11|HTX_SL_F_XFER_LEN|HTX_SL_F_BODYLESS);\n\tsl = htx_add_stline(htx, HTX_BLK_RES_SL, flags,\n\t\t\t    ist(\"HTTP/1.1\"), ist(\"302\"), ist(\"Found\"));\n\tif (!sl)\n\t\tgoto fail;\n\tsl->info.res.status = 302;\n\ts->txn->status = 302;\n\n        if (!htx_add_header(htx, ist(\"Cache-Control\"), ist(\"no-cache\")) ||\n\t    !htx_add_header(htx, ist(\"Connection\"), ist(\"close\")) ||\n\t    !htx_add_header(htx, ist(\"Content-length\"), ist(\"0\")) ||\n\t    !htx_add_header(htx, ist(\"Location\"), location))\n\t\tgoto fail;\n\n\tif (!htx_add_endof(htx, HTX_BLK_EOH))\n\t\tgoto fail;\n\n\thtx->flags |= HTX_FL_EOM;\n\thtx_to_buf(htx, &res->buf);\n\tif (!http_forward_proxy_resp(s, 1))\n\t\tgoto fail;\n\n\t/* return without error. */\n\tsi_shutr(si);\n\tsi_shutw(si);\n\tsi->err_type = SI_ET_NONE;\n\tsi->state    = SI_ST_CLO;\n\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_LOCAL;\n\tif (!(s->flags & SF_FINST_MASK))\n\t\ts->flags |= SF_FINST_C;\n\n\t/* FIXME: we should increase a counter of redirects per server and per backend. */\n\tsrv_inc_sess_ctr(srv);\n\tsrv_set_sess_last(srv);\n\treturn;\n\n  fail:\n\t/* If an error occurred, remove the incomplete HTTP response from the\n\t * buffer */\n\tchannel_htx_truncate(res, htx);\n}\n\n/* This function terminates the request because it was completely analyzed or\n * because an error was triggered during the body forwarding.\n */\nstatic void http_end_request(struct stream *s)\n{\n\tstruct channel *chn = &s->req;\n\tstruct http_txn *txn = s->txn;\n\n\tDBG_TRACE_ENTER(STRM_EV_HTTP_ANA, s, txn);\n\n\tif (unlikely(txn->req.msg_state == HTTP_MSG_ERROR ||\n\t\t     txn->rsp.msg_state == HTTP_MSG_ERROR)) {\n\t\tchannel_abort(chn);\n\t\tchannel_htx_truncate(chn, htxbuf(&chn->buf));\n\t\tgoto end;\n\t}\n\n\tif (unlikely(txn->req.msg_state < HTTP_MSG_DONE)) {\n\t\tDBG_TRACE_DEVEL(\"waiting end of the request\", STRM_EV_HTTP_ANA, s, txn);\n\t\treturn;\n\t}\n\n\tif (txn->req.msg_state == HTTP_MSG_DONE) {\n\t\t/* No need to read anymore, the request was completely parsed.\n\t\t * We can shut the read side unless we want to abort_on_close,\n\t\t * or we have a POST request. The issue with POST requests is\n\t\t * that some browsers still send a CRLF after the request, and\n\t\t * this CRLF must be read so that it does not remain in the kernel\n\t\t * buffers, otherwise a close could cause an RST on some systems\n\t\t * (eg: Linux).\n\t\t */\n\t\tif (!(s->be->options & PR_O_ABRT_CLOSE) && txn->meth != HTTP_METH_POST)\n\t\t\tchannel_dont_read(chn);\n\n\t\t/* if the server closes the connection, we want to immediately react\n\t\t * and close the socket to save packets and syscalls.\n\t\t */\n\t\ts->si[1].flags |= SI_FL_NOHALF;\n\n\t\t/* In any case we've finished parsing the request so we must\n\t\t * disable Nagle when sending data because 1) we're not going\n\t\t * to shut this side, and 2) the server is waiting for us to\n\t\t * send pending data.\n\t\t */\n\t\tchn->flags |= CF_NEVER_WAIT;\n\n\t\tif (txn->rsp.msg_state < HTTP_MSG_DONE) {\n\t\t\t/* The server has not finished to respond, so we\n\t\t\t * don't want to move in order not to upset it.\n\t\t\t */\n\t\t\tDBG_TRACE_DEVEL(\"waiting end of the response\", STRM_EV_HTTP_ANA, s, txn);\n\t\t\treturn;\n\t\t}\n\n\t\t/* When we get here, it means that both the request and the\n\t\t * response have finished receiving. Depending on the connection\n\t\t * mode, we'll have to wait for the last bytes to leave in either\n\t\t * direction, and sometimes for a close to be effective.\n\t\t */\n\t\tif (txn->flags & TX_CON_WANT_TUN) {\n\t\t\t/* Tunnel mode will not have any analyser so it needs to\n\t\t\t * poll for reads.\n\t\t\t */\n\t\t\tchannel_auto_read(chn);\n\t\t\tif (b_data(&chn->buf)) {\n\t\t\t\tDBG_TRACE_DEVEL(\"waiting to flush the request\", STRM_EV_HTTP_ANA, s, txn);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttxn->req.msg_state = HTTP_MSG_TUNNEL;\n\t\t}\n\t\telse {\n\t\t\t/* we're not expecting any new data to come for this\n\t\t\t * transaction, so we can close it.\n\t\t\t *\n\t\t\t *  However, there is an exception if the response\n\t\t\t *  length is undefined. In this case, we need to wait\n\t\t\t *  the close from the server. The response will be\n\t\t\t *  switched in TUNNEL mode until the end.\n\t\t\t */\n\t\t\tif (!(txn->rsp.flags & HTTP_MSGF_XFER_LEN) &&\n\t\t\t    txn->rsp.msg_state != HTTP_MSG_CLOSED)\n\t\t\t\tgoto check_channel_flags;\n\n\t\t\tif (!(chn->flags & (CF_SHUTW|CF_SHUTW_NOW))) {\n\t\t\t\tchannel_shutr_now(chn);\n\t\t\t\tchannel_shutw_now(chn);\n\t\t\t}\n\t\t}\n\t\tgoto check_channel_flags;\n\t}\n\n\tif (txn->req.msg_state == HTTP_MSG_CLOSING) {\n\t  http_msg_closing:\n\t\t/* nothing else to forward, just waiting for the output buffer\n\t\t * to be empty and for the shutw_now to take effect.\n\t\t */\n\t\tif (channel_is_empty(chn)) {\n\t\t\ttxn->req.msg_state = HTTP_MSG_CLOSED;\n\t\t\tgoto http_msg_closed;\n\t\t}\n\t\telse if (chn->flags & CF_SHUTW) {\n\t\t\ttxn->req.msg_state = HTTP_MSG_ERROR;\n\t\t\tgoto end;\n\t\t}\n\t\tDBG_TRACE_LEAVE(STRM_EV_HTTP_ANA, s, txn);\n\t\treturn;\n\t}\n\n\tif (txn->req.msg_state == HTTP_MSG_CLOSED) {\n\t  http_msg_closed:\n\t\t/* if we don't know whether the server will close, we need to hard close */\n\t\tif (txn->rsp.flags & HTTP_MSGF_XFER_LEN)\n\t\t\ts->si[1].flags |= SI_FL_NOLINGER;  /* we want to close ASAP */\n\t\t/* see above in MSG_DONE why we only do this in these states */\n\t\tif (!(s->be->options & PR_O_ABRT_CLOSE))\n\t\t\tchannel_dont_read(chn);\n\t\tgoto end;\n\t}\n\n  check_channel_flags:\n\t/* Here, we are in HTTP_MSG_DONE or HTTP_MSG_TUNNEL */\n\tif (chn->flags & (CF_SHUTW|CF_SHUTW_NOW)) {\n\t\t/* if we've just closed an output, let's switch */\n\t\ttxn->req.msg_state = HTTP_MSG_CLOSING;\n\t\tgoto http_msg_closing;\n\t}\n\n  end:\n\tchn->analysers &= AN_REQ_FLT_END;\n\tif (txn->req.msg_state == HTTP_MSG_TUNNEL) {\n\t\tchn->flags |= CF_NEVER_WAIT;\n\t\tif (HAS_REQ_DATA_FILTERS(s))\n\t\t\tchn->analysers |= AN_REQ_FLT_XFER_DATA;\n\t}\n\tchannel_auto_close(chn);\n\tchannel_auto_read(chn);\n\tDBG_TRACE_LEAVE(STRM_EV_HTTP_ANA, s, txn);\n}\n\n\n/* This function terminates the response because it was completely analyzed or\n * because an error was triggered during the body forwarding.\n */\nstatic void http_end_response(struct stream *s)\n{\n\tstruct channel *chn = &s->res;\n\tstruct http_txn *txn = s->txn;\n\n\tDBG_TRACE_ENTER(STRM_EV_HTTP_ANA, s, txn);\n\n\tif (unlikely(txn->req.msg_state == HTTP_MSG_ERROR ||\n\t\t     txn->rsp.msg_state == HTTP_MSG_ERROR)) {\n\t\tchannel_htx_truncate(&s->req, htxbuf(&s->req.buf));\n\t\tchannel_abort(&s->req);\n\t\tgoto end;\n\t}\n\n\tif (unlikely(txn->rsp.msg_state < HTTP_MSG_DONE)) {\n\t\tDBG_TRACE_DEVEL(\"waiting end of the response\", STRM_EV_HTTP_ANA, s, txn);\n\t\treturn;\n\t}\n\n\tif (txn->rsp.msg_state == HTTP_MSG_DONE) {\n\t\t/* In theory, we don't need to read anymore, but we must\n\t\t * still monitor the server connection for a possible close\n\t\t * while the request is being uploaded, so we don't disable\n\t\t * reading.\n\t\t */\n\t\t/* channel_dont_read(chn); */\n\n\t\tif (txn->req.msg_state < HTTP_MSG_DONE) {\n\t\t\t/* The client seems to still be sending data, probably\n\t\t\t * because we got an error response during an upload.\n\t\t\t * We have the choice of either breaking the connection\n\t\t\t * or letting it pass through. Let's do the later.\n\t\t\t */\n\t\t\tDBG_TRACE_DEVEL(\"waiting end of the request\", STRM_EV_HTTP_ANA, s, txn);\n\t\t\treturn;\n\t\t}\n\n\t\t/* When we get here, it means that both the request and the\n\t\t * response have finished receiving. Depending on the connection\n\t\t * mode, we'll have to wait for the last bytes to leave in either\n\t\t * direction, and sometimes for a close to be effective.\n\t\t */\n\t\tif (txn->flags & TX_CON_WANT_TUN) {\n\t\t\tchannel_auto_read(chn);\n\t\t\tif (b_data(&chn->buf)) {\n\t\t\t\tDBG_TRACE_DEVEL(\"waiting to flush the respone\", STRM_EV_HTTP_ANA, s, txn);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttxn->rsp.msg_state = HTTP_MSG_TUNNEL;\n\t\t}\n\t\telse {\n\t\t\t/* we're not expecting any new data to come for this\n\t\t\t * transaction, so we can close it.\n\t\t\t */\n\t\t\tif (!(chn->flags & (CF_SHUTW|CF_SHUTW_NOW))) {\n\t\t\t\tchannel_shutr_now(chn);\n\t\t\t\tchannel_shutw_now(chn);\n\t\t\t}\n\t\t}\n\t\tgoto check_channel_flags;\n\t}\n\n\tif (txn->rsp.msg_state == HTTP_MSG_CLOSING) {\n\t  http_msg_closing:\n\t\t/* nothing else to forward, just waiting for the output buffer\n\t\t * to be empty and for the shutw_now to take effect.\n\t\t */\n\t\tif (channel_is_empty(chn)) {\n\t\t\ttxn->rsp.msg_state = HTTP_MSG_CLOSED;\n\t\t\tgoto http_msg_closed;\n\t\t}\n\t\telse if (chn->flags & CF_SHUTW) {\n\t\t\ttxn->rsp.msg_state = HTTP_MSG_ERROR;\n\t\t\t_HA_ATOMIC_INC(&strm_sess(s)->fe->fe_counters.cli_aborts);\n\t\t\t_HA_ATOMIC_INC(&s->be->be_counters.cli_aborts);\n\t\t\tif (strm_sess(s)->listener && strm_sess(s)->listener->counters)\n\t\t\t\t_HA_ATOMIC_INC(&strm_sess(s)->listener->counters->cli_aborts);\n\t\t\tif (objt_server(s->target))\n\t\t\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.cli_aborts);\n\t\t\tgoto end;\n\t\t}\n\t\tDBG_TRACE_LEAVE(STRM_EV_HTTP_ANA, s, txn);\n\t\treturn;\n\t}\n\n\tif (txn->rsp.msg_state == HTTP_MSG_CLOSED) {\n\t  http_msg_closed:\n\t\t/* drop any pending data */\n\t\tchannel_htx_truncate(&s->req, htxbuf(&s->req.buf));\n\t\tchannel_abort(&s->req);\n\t\tgoto end;\n\t}\n\n  check_channel_flags:\n\t/* Here, we are in HTTP_MSG_DONE or HTTP_MSG_TUNNEL */\n\tif (chn->flags & (CF_SHUTW|CF_SHUTW_NOW)) {\n\t\t/* if we've just closed an output, let's switch */\n\t\ttxn->rsp.msg_state = HTTP_MSG_CLOSING;\n\t\tgoto http_msg_closing;\n\t}\n\n  end:\n\tchn->analysers &= AN_RES_FLT_END;\n\tif (txn->rsp.msg_state == HTTP_MSG_TUNNEL) {\n\t\tchn->flags |= CF_NEVER_WAIT;\n\t\tif (HAS_RSP_DATA_FILTERS(s))\n\t\t\tchn->analysers |= AN_RES_FLT_XFER_DATA;\n\t}\n\tchannel_auto_close(chn);\n\tchannel_auto_read(chn);\n\tDBG_TRACE_LEAVE(STRM_EV_HTTP_ANA, s, txn);\n}\n\n/* Forward a response generated by HAProxy (error/redirect/return). This\n * function forwards all pending incoming data. If <final> is set to 0, nothing\n * more is performed. It is used for 1xx informational messages. Otherwise, the\n * transaction is terminated and the request is emptied. On success 1 is\n * returned. If an error occurred, 0 is returned. If it fails, this function\n * only exits. It is the caller responsibility to do the cleanup.\n */\nint http_forward_proxy_resp(struct stream *s, int final)\n{\n\tstruct channel *req = &s->req;\n\tstruct channel *res = &s->res;\n\tstruct htx *htx = htxbuf(&res->buf);\n\tsize_t data;\n\n\tif (final) {\n\t\thtx->flags |= HTX_FL_PROXY_RESP;\n\n\t\tif (!htx_is_empty(htx) && !http_eval_after_res_rules(s))\n\t\t\treturn 0;\n\n\t\tif (s->txn->meth == HTTP_METH_HEAD)\n\t\t\thtx_skip_msg_payload(htx);\n\n\t\tchannel_auto_read(req);\n\t\tchannel_abort(req);\n\t\tchannel_auto_close(req);\n\t\tchannel_htx_erase(req, htxbuf(&req->buf));\n\n\t\tres->wex = tick_add_ifset(now_ms, res->wto);\n\t\tchannel_auto_read(res);\n\t\tchannel_auto_close(res);\n\t\tchannel_shutr_now(res);\n\t\tres->flags |= CF_EOI; /* The response is terminated, add EOI */\n\t\thtxbuf(&res->buf)->flags |= HTX_FL_EOM; /* no more data are expected */\n\t}\n\telse {\n\t\t/* Send ASAP informational messages. Rely on CF_EOI for final\n\t\t * response.\n\t\t */\n\t\tres->flags |= CF_SEND_DONTWAIT;\n\t}\n\n\tdata = htx->data - co_data(res);\n\tc_adv(res, data);\n\thtx->first = -1;\n\tres->total += data;\n\treturn 1;\n}\n\nvoid http_server_error(struct stream *s, struct stream_interface *si, int err,\n\t\t       int finst, struct http_reply *msg)\n{\n\thttp_reply_and_close(s, s->txn->status, msg);\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= err;\n\tif (!(s->flags & SF_FINST_MASK))\n\t\ts->flags |= finst;\n}\n\nvoid http_reply_and_close(struct stream *s, short status, struct http_reply *msg)\n{\n\tif (!msg) {\n\t\tchannel_htx_truncate(&s->res, htxbuf(&s->res.buf));\n\t\tgoto end;\n\t}\n\n\tif (http_reply_message(s, msg) == -1) {\n\t\t/* On error, return a 500 error message, but don't rewrite it if\n\t\t * it is already an internal error. If it was already a \"const\"\n\t\t * 500 error, just fail.\n\t\t */\n\t\tif (s->txn->status == 500) {\n\t\t\tif (s->txn->flags & TX_CONST_REPLY)\n\t\t\t\tgoto end;\n\t\t\ts->txn->flags |= TX_CONST_REPLY;\n\t\t}\n\t\ts->txn->status = 500;\n\t\ts->txn->http_reply = NULL;\n\t\treturn http_reply_and_close(s, s->txn->status, http_error_message(s));\n\t}\n\nend:\n\ts->res.wex = tick_add_ifset(now_ms, s->res.wto);\n\n\t/* At this staged, HTTP analysis is finished */\n\ts->req.analysers &= AN_REQ_FLT_END;\n\ts->req.analyse_exp = TICK_ETERNITY;\n\n\ts->res.analysers &= AN_RES_FLT_END;\n\ts->res.analyse_exp = TICK_ETERNITY;\n\n\tchannel_auto_read(&s->req);\n\tchannel_abort(&s->req);\n\tchannel_auto_close(&s->req);\n\tchannel_htx_erase(&s->req, htxbuf(&s->req.buf));\n\tchannel_auto_read(&s->res);\n\tchannel_auto_close(&s->res);\n\tchannel_shutr_now(&s->res);\n}\n\nstruct http_reply *http_error_message(struct stream *s)\n{\n\tconst int msgnum = http_get_status_idx(s->txn->status);\n\n\tif (s->txn->http_reply)\n\t\treturn s->txn->http_reply;\n\telse if (s->be->replies[msgnum])\n\t\treturn s->be->replies[msgnum];\n\telse if (strm_fe(s)->replies[msgnum])\n\t\treturn strm_fe(s)->replies[msgnum];\n\telse\n\t\treturn &http_err_replies[msgnum];\n}\n\n/* Produces an HTX message from an http reply. Depending on the http reply type,\n * a, errorfile, an raw file or a log-format string is used. On success, it\n * returns 0. If an error occurs -1 is returned. If it fails, this function only\n * exits. It is the caller responsibility to do the cleanup.\n */\nint http_reply_to_htx(struct stream *s, struct htx *htx, struct http_reply *reply)\n{\n\tstruct buffer *errmsg;\n\tstruct htx_sl *sl;\n\tstruct buffer *body = NULL;\n\tconst char *status, *reason, *clen, *ctype;\n\tunsigned int slflags;\n\tint ret = 0;\n\n\t/*\n\t * - HTTP_REPLY_ERRFILES unexpected here. handled as no payload if so\n\t *\n\t * - HTTP_REPLY_INDIRECT: switch on another reply if defined or handled\n\t *   as no payload if NULL. the TXN status code is set with the status\n\t *   of the original reply.\n\t */\n\n\tif (reply->type == HTTP_REPLY_INDIRECT) {\n\t\tif (reply->body.reply)\n\t\t\treply = reply->body.reply;\n\t}\n\tif (reply->type == HTTP_REPLY_ERRMSG && !reply->body.errmsg)  {\n\t\t/* get default error message */\n\t\tif (reply == s->txn->http_reply)\n\t\t\ts->txn->http_reply = NULL;\n\t\treply = http_error_message(s);\n\t\tif (reply->type == HTTP_REPLY_INDIRECT) {\n\t\t\tif (reply->body.reply)\n\t\t\t\treply = reply->body.reply;\n\t\t}\n\t}\n\n\tif (reply->type == HTTP_REPLY_ERRMSG) {\n\t\t/* implicit or explicit error message*/\n\t\terrmsg = reply->body.errmsg;\n\t\tif (errmsg && !b_is_null(errmsg)) {\n\t\t\tif (!htx_copy_msg(htx, errmsg))\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\telse {\n\t\t/* no payload, file or log-format string */\n\t\tif (reply->type == HTTP_REPLY_RAW) {\n\t\t\t/* file */\n\t\t\tbody = &reply->body.obj;\n\t\t}\n\t\telse if (reply->type == HTTP_REPLY_LOGFMT) {\n\t\t\t/* log-format string */\n\t\t\tbody = alloc_trash_chunk();\n\t\t\tif (!body)\n\t\t\t\tgoto fail_alloc;\n\t\t\tbody->data = build_logline(s, body->area, body->size, &reply->body.fmt);\n\t\t}\n\t\t/* else no payload */\n\n\t\tstatus = ultoa(reply->status);\n\t\treason = http_get_reason(reply->status);\n\t\tslflags = (HTX_SL_F_IS_RESP|HTX_SL_F_VER_11|HTX_SL_F_XFER_LEN|HTX_SL_F_CLEN);\n\t\tif (!body || !b_data(body))\n\t\t\tslflags |= HTX_SL_F_BODYLESS;\n\t\tsl = htx_add_stline(htx, HTX_BLK_RES_SL, slflags, ist(\"HTTP/1.1\"), ist(status), ist(reason));\n\t\tif (!sl)\n\t\t\tgoto fail;\n\t\tsl->info.res.status = reply->status;\n\n\t\tclen = (body ? ultoa(b_data(body)) : \"0\");\n\t\tctype = reply->ctype;\n\n\t\tif (!LIST_ISEMPTY(&reply->hdrs)) {\n\t\t\tstruct http_reply_hdr *hdr;\n\t\t\tstruct buffer *value = alloc_trash_chunk();\n\n\t\t\tif (!value)\n\t\t\t\tgoto fail;\n\n\t\t\tlist_for_each_entry(hdr, &reply->hdrs, list) {\n\t\t\t\tchunk_reset(value);\n\t\t\t\tvalue->data = build_logline(s, value->area, value->size, &hdr->value);\n\t\t\t\tif (b_data(value) && !htx_add_header(htx, hdr->name, ist2(b_head(value), b_data(value)))) {\n\t\t\t\t\tfree_trash_chunk(value);\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t\tchunk_reset(value);\n\t\t\t}\n\t\t\tfree_trash_chunk(value);\n\t\t}\n\n\t\tif (!htx_add_header(htx, ist(\"content-length\"), ist(clen)) ||\n\t\t    (body && b_data(body) && ctype && !htx_add_header(htx, ist(\"content-type\"), ist(ctype))) ||\n\t\t    !htx_add_endof(htx, HTX_BLK_EOH) ||\n\t\t    (body && b_data(body) && !htx_add_data_atonce(htx, ist2(b_head(body), b_data(body)))))\n\t\t\tgoto fail;\n\n\t\thtx->flags |= HTX_FL_EOM;\n\t}\n\n  leave:\n\tif (reply->type == HTTP_REPLY_LOGFMT)\n\t\tfree_trash_chunk(body);\n\treturn ret;\n\n  fail_alloc:\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_RESOURCE;\n\t/* fall through */\n  fail:\n\tret = -1;\n\tgoto leave;\n}\n\n/* Send an http reply to the client. On success, it returns 0. If an error\n * occurs -1 is returned and the response channel is truncated, removing this\n * way the faulty reply. This function may fail when the reply is formatted\n * (http_reply_to_htx) or when the reply is forwarded\n * (http_forward_proxy_resp). On the last case, it is because a\n * http-after-response rule fails.\n */\nint http_reply_message(struct stream *s, struct http_reply *reply)\n{\n\tstruct channel *res = &s->res;\n\tstruct htx *htx = htx_from_buf(&res->buf);\n\n\tif (s->txn->status == -1)\n\t\ts->txn->status = reply->status;\n\tchannel_htx_truncate(res, htx);\n\n\tif (http_reply_to_htx(s, htx, reply) == -1)\n\t\tgoto fail;\n\n\thtx_to_buf(htx, &s->res.buf);\n\tif (!http_forward_proxy_resp(s, 1))\n\t\tgoto fail;\n\treturn 0;\n\n  fail:\n\tchannel_htx_truncate(res, htx);\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_PRXCOND;\n\treturn -1;\n}\n\n/* Return the error message corresponding to si->err_type. It is assumed\n * that the server side is closed. Note that err_type is actually a\n * bitmask, where almost only aborts may be cumulated with other\n * values. We consider that aborted operations are more important\n * than timeouts or errors due to the fact that nobody else in the\n * logs might explain incomplete retries. All others should avoid\n * being cumulated. It should normally not be possible to have multiple\n * aborts at once, but just in case, the first one in sequence is reported.\n * Note that connection errors appearing on the second request of a keep-alive\n * connection are not reported since this allows the client to retry.\n */\nvoid http_return_srv_error(struct stream *s, struct stream_interface *si)\n{\n\tint err_type = si->err_type;\n\n\t/* set s->txn->status for http_error_message(s) */\n\tif (err_type & SI_ET_QUEUE_ABRT) {\n\t\ts->txn->status = -1;\n\t\thttp_server_error(s, si, SF_ERR_CLICL, SF_FINST_Q, NULL);\n\t}\n\telse if (err_type & SI_ET_CONN_ABRT) {\n\t\ts->txn->status = -1;\n\t\thttp_server_error(s, si, SF_ERR_CLICL, SF_FINST_C, NULL);\n\t}\n\telse if (err_type & SI_ET_QUEUE_TO) {\n\t\ts->txn->status = 503;\n\t\thttp_server_error(s, si, SF_ERR_SRVTO, SF_FINST_Q,\n\t\t\t\t  http_error_message(s));\n\t}\n\telse if (err_type & SI_ET_QUEUE_ERR) {\n\t\ts->txn->status = 503;\n\t\thttp_server_error(s, si, SF_ERR_SRVCL, SF_FINST_Q,\n\t\t\t\t  http_error_message(s));\n\t}\n\telse if (err_type & SI_ET_CONN_TO) {\n\t\ts->txn->status = 503;\n\t\thttp_server_error(s, si, SF_ERR_SRVTO, SF_FINST_C,\n\t\t\t\t  (s->txn->flags & TX_NOT_FIRST) ? NULL :\n\t\t\t\t  http_error_message(s));\n\t}\n\telse if (err_type & SI_ET_CONN_ERR) {\n\t\ts->txn->status = 503;\n\t\thttp_server_error(s, si, SF_ERR_SRVCL, SF_FINST_C,\n\t\t\t\t  (s->flags & SF_SRV_REUSED) ? NULL :\n\t\t\t\t  http_error_message(s));\n\t}\n\telse if (err_type & SI_ET_CONN_RES) {\n\t\ts->txn->status = 503;\n\t\thttp_server_error(s, si, SF_ERR_RESOURCE, SF_FINST_C,\n\t\t\t\t  (s->txn->flags & TX_NOT_FIRST) ? NULL :\n\t\t\t\t  http_error_message(s));\n\t}\n\telse { /* SI_ET_CONN_OTHER and others */\n\t\ts->txn->status = 500;\n\t\thttp_server_error(s, si, SF_ERR_INTERNAL, SF_FINST_C,\n\t\t\t\t  http_error_message(s));\n\t}\n}\n\n\n/* Handle Expect: 100-continue for HTTP/1.1 messages if necessary. It returns 0\n * on success and -1 on error.\n */\nstatic int http_handle_expect_hdr(struct stream *s, struct htx *htx, struct http_msg *msg)\n{\n\t/* If we have HTTP/1.1 message with a body and Expect: 100-continue,\n\t * then we must send an HTTP/1.1 100 Continue intermediate response.\n\t */\n\tif (msg->msg_state == HTTP_MSG_BODY && (msg->flags & HTTP_MSGF_VER_11) &&\n\t    (msg->flags & (HTTP_MSGF_CNT_LEN|HTTP_MSGF_TE_CHNK))) {\n\t\tstruct ist hdr = { .ptr = \"Expect\", .len = 6 };\n\t\tstruct http_hdr_ctx ctx;\n\n\t\tctx.blk = NULL;\n\t\t/* Expect is allowed in 1.1, look for it */\n\t\tif (http_find_header(htx, hdr, &ctx, 0) &&\n\t\t    unlikely(isteqi(ctx.value, ist2(\"100-continue\", 12)))) {\n\t\t\tif (http_reply_100_continue(s) == -1)\n\t\t\t\treturn -1;\n\t\t\thttp_remove_header(htx, &ctx);\n\t\t}\n\t}\n\treturn 0;\n}\n\n/* Send a 100-Continue response to the client. It returns 0 on success and -1\n * on error. The response channel is updated accordingly.\n */\nstatic int http_reply_100_continue(struct stream *s)\n{\n\tstruct channel *res = &s->res;\n\tstruct htx *htx = htx_from_buf(&res->buf);\n\tstruct htx_sl *sl;\n\tunsigned int flags = (HTX_SL_F_IS_RESP|HTX_SL_F_VER_11|\n\t\t\t      HTX_SL_F_XFER_LEN|HTX_SL_F_BODYLESS);\n\n\tsl = htx_add_stline(htx, HTX_BLK_RES_SL, flags,\n\t\t\t    ist(\"HTTP/1.1\"), ist(\"100\"), ist(\"Continue\"));\n\tif (!sl)\n\t\tgoto fail;\n\tsl->info.res.status = 100;\n\n\tif (!htx_add_endof(htx, HTX_BLK_EOH))\n\t\tgoto fail;\n\n\tif (!http_forward_proxy_resp(s, 0))\n\t\tgoto fail;\n\treturn 0;\n\n  fail:\n\t/* If an error occurred, remove the incomplete HTTP response from the\n\t * buffer */\n\tchannel_htx_truncate(res, htx);\n\treturn -1;\n}\n\n\n/*\n * Capture headers from message <htx> according to header list <cap_hdr>, and\n * fill the <cap> pointers appropriately.\n */\nstatic void http_capture_headers(struct htx *htx, char **cap, struct cap_hdr *cap_hdr)\n{\n\tstruct cap_hdr *h;\n\tint32_t pos;\n\n\tfor (pos = htx_get_first(htx); pos != -1; pos = htx_get_next(htx, pos)) {\n\t\tstruct htx_blk *blk = htx_get_blk(htx, pos);\n\t\tenum htx_blk_type type = htx_get_blk_type(blk);\n\t\tstruct ist n, v;\n\n\t\tif (type == HTX_BLK_EOH)\n\t\t\tbreak;\n\t\tif (type != HTX_BLK_HDR)\n\t\t\tcontinue;\n\n\t\tn = htx_get_blk_name(htx, blk);\n\n\t\tfor (h = cap_hdr; h; h = h->next) {\n\t\t\tif (h->namelen && (h->namelen == n.len) &&\n\t\t\t    (strncasecmp(n.ptr, h->name, h->namelen) == 0)) {\n\t\t\t\tif (cap[h->index] == NULL)\n\t\t\t\t\tcap[h->index] =\n\t\t\t\t\t\tpool_alloc(h->pool);\n\n\t\t\t\tif (cap[h->index] == NULL) {\n\t\t\t\t\tha_alert(\"HTTP capture : out of memory.\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tv = htx_get_blk_value(htx, blk);\n\t\t\t\tv = isttrim(v, h->len);\n\n\t\t\t\tmemcpy(cap[h->index], v.ptr, v.len);\n\t\t\t\tcap[h->index][v.len]=0;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* Delete a value in a header between delimiters <from> and <next>. The header\n * itself is delimited by <start> and <end> pointers. The number of characters\n * displaced is returned, and the pointer to the first delimiter is updated if\n * required. The function tries as much as possible to respect the following\n * principles :\n * - replace <from> delimiter by the <next> one unless <from> points to <start>,\n *   in which case <next> is simply removed\n * - set exactly one space character after the new first delimiter, unless there\n *   are not enough characters in the block being moved to do so.\n * - remove unneeded spaces before the previous delimiter and after the new\n *   one.\n *\n * It is the caller's responsibility to ensure that :\n *   - <from> points to a valid delimiter or <start> ;\n *   - <next> points to a valid delimiter or <end> ;\n *   - there are non-space chars before <from>.\n */\nstatic int http_del_hdr_value(char *start, char *end, char **from, char *next)\n{\n\tchar *prev = *from;\n\n\tif (prev == start) {\n\t\t/* We're removing the first value. eat the semicolon, if <next>\n\t\t * is lower than <end> */\n\t\tif (next < end)\n\t\t\tnext++;\n\n\t\twhile (next < end && HTTP_IS_SPHT(*next))\n\t\t\tnext++;\n\t}\n\telse {\n\t\t/* Remove useless spaces before the old delimiter. */\n\t\twhile (HTTP_IS_SPHT(*(prev-1)))\n\t\t\tprev--;\n\t\t*from = prev;\n\n\t\t/* copy the delimiter and if possible a space if we're\n\t\t * not at the end of the line.\n\t\t */\n\t\tif (next < end) {\n\t\t\t*prev++ = *next++;\n\t\t\tif (prev + 1 < next)\n\t\t\t\t*prev++ = ' ';\n\t\t\twhile (next < end && HTTP_IS_SPHT(*next))\n\t\t\t\tnext++;\n\t\t}\n\t}\n\tmemmove(prev, next, end - next);\n\treturn (prev - next);\n}\n\n\n/* Formats the start line of the request (without CRLF) and puts it in <str> and\n * return the written length. The line can be truncated if it exceeds <len>.\n */\nstatic size_t http_fmt_req_line(const struct htx_sl *sl, char *str, size_t len)\n{\n\tstruct ist dst = ist2(str, 0);\n\n\tif (istcat(&dst, htx_sl_req_meth(sl), len) == -1)\n\t\tgoto end;\n\tif (dst.len + 1 > len)\n\t\tgoto end;\n\tdst.ptr[dst.len++] = ' ';\n\n\tif (istcat(&dst, htx_sl_req_uri(sl), len) == -1)\n\t\tgoto end;\n\tif (dst.len + 1 > len)\n\t\tgoto end;\n\tdst.ptr[dst.len++] = ' ';\n\n\tistcat(&dst, htx_sl_req_vsn(sl), len);\n  end:\n\treturn dst.len;\n}\n\n/*\n * Print a debug line with a start line.\n */\nstatic void http_debug_stline(const char *dir, struct stream *s, const struct htx_sl *sl)\n{\n        struct session *sess = strm_sess(s);\n        int max;\n\n        chunk_printf(&trash, \"%08x:%s.%s[%04x:%04x]: \", s->uniq_id, s->be->id,\n                     dir,\n                     objt_conn(sess->origin) ? (unsigned short)__objt_conn(sess->origin)->handle.fd : -1,\n                     objt_cs(s->si[1].end) ? (unsigned short)__objt_cs(s->si[1].end)->conn->handle.fd : -1);\n\n        max = HTX_SL_P1_LEN(sl);\n        UBOUND(max, trash.size - trash.data - 3);\n        chunk_memcat(&trash, HTX_SL_P1_PTR(sl), max);\n        trash.area[trash.data++] = ' ';\n\n        max = HTX_SL_P2_LEN(sl);\n        UBOUND(max, trash.size - trash.data - 2);\n        chunk_memcat(&trash, HTX_SL_P2_PTR(sl), max);\n        trash.area[trash.data++] = ' ';\n\n        max = HTX_SL_P3_LEN(sl);\n        UBOUND(max, trash.size - trash.data - 1);\n        chunk_memcat(&trash, HTX_SL_P3_PTR(sl), max);\n        trash.area[trash.data++] = '\\n';\n\n        DISGUISE(write(1, trash.area, trash.data));\n}\n\n/*\n * Print a debug line with a header.\n */\nstatic void http_debug_hdr(const char *dir, struct stream *s, const struct ist n, const struct ist v)\n{\n        struct session *sess = strm_sess(s);\n        int max;\n\n        chunk_printf(&trash, \"%08x:%s.%s[%04x:%04x]: \", s->uniq_id, s->be->id,\n                     dir,\n                     objt_conn(sess->origin) ? (unsigned short)__objt_conn(sess->origin)->handle.fd : -1,\n                     objt_cs(s->si[1].end) ? (unsigned short)__objt_cs(s->si[1].end)->conn->handle.fd : -1);\n\n        max = n.len;\n        UBOUND(max, trash.size - trash.data - 3);\n        chunk_memcat(&trash, n.ptr, max);\n        trash.area[trash.data++] = ':';\n        trash.area[trash.data++] = ' ';\n\n        max = v.len;\n        UBOUND(max, trash.size - trash.data - 1);\n        chunk_memcat(&trash, v.ptr, max);\n        trash.area[trash.data++] = '\\n';\n\n        DISGUISE(write(1, trash.area, trash.data));\n}\n\n/* Allocate a new HTTP transaction for stream <s> unless there is one already.\n * In case of allocation failure, everything allocated is freed and NULL is\n * returned. Otherwise the new transaction is assigned to the stream and\n * returned.\n */\nstruct http_txn *http_alloc_txn(struct stream *s)\n{\n\tstruct http_txn *txn = s->txn;\n\n\tif (txn)\n\t\treturn txn;\n\n\ttxn = pool_alloc(pool_head_http_txn);\n\tif (!txn)\n\t\treturn txn;\n\n\ts->txn = txn;\n\treturn txn;\n}\n\nvoid http_txn_reset_req(struct http_txn *txn)\n{\n\ttxn->req.flags = 0;\n\ttxn->req.msg_state = HTTP_MSG_RQBEFORE; /* at the very beginning of the request */\n}\n\nvoid http_txn_reset_res(struct http_txn *txn)\n{\n\ttxn->rsp.flags = 0;\n\ttxn->rsp.msg_state = HTTP_MSG_RPBEFORE; /* at the very beginning of the response */\n}\n\n/*\n * Create and initialize a new HTTP transaction for stream <s>. This should be\n * used before processing any new request. It returns the transaction or NLULL\n * on error.\n */\nstruct http_txn *http_create_txn(struct stream *s)\n{\n\tstruct http_txn *txn;\n\tstruct conn_stream *cs = objt_cs(s->si[0].end);\n\n\ttxn = pool_alloc(pool_head_http_txn);\n\tif (!txn)\n\t\treturn NULL;\n\ts->txn = txn;\n\n\ttxn->flags = ((cs && cs->flags & CS_FL_NOT_FIRST) ? TX_NOT_FIRST : 0);\n\ttxn->status = -1;\n\ttxn->http_reply = NULL;\n\twrite_u32(txn->cache_hash, 0);\n\n\ttxn->cookie_first_date = 0;\n\ttxn->cookie_last_date = 0;\n\n\ttxn->srv_cookie = NULL;\n\ttxn->cli_cookie = NULL;\n\ttxn->uri = NULL;\n\n\thttp_txn_reset_req(txn);\n\thttp_txn_reset_res(txn);\n\n\ttxn->req.chn = &s->req;\n\ttxn->rsp.chn = &s->res;\n\n\ttxn->auth.method = HTTP_AUTH_UNKNOWN;\n\n\tvars_init_head(&s->vars_txn,    SCOPE_TXN);\n\tvars_init_head(&s->vars_reqres, SCOPE_REQ);\n\n\treturn txn;\n}\n\n/* to be used at the end of a transaction */\nvoid http_destroy_txn(struct stream *s)\n{\n\tstruct http_txn *txn = s->txn;\n\n\t/* these ones will have been dynamically allocated */\n\tpool_free(pool_head_requri, txn->uri);\n\tpool_free(pool_head_capture, txn->cli_cookie);\n\tpool_free(pool_head_capture, txn->srv_cookie);\n\tpool_free(pool_head_uniqueid, s->unique_id.ptr);\n\n\ts->unique_id = IST_NULL;\n\ttxn->uri = NULL;\n\ttxn->srv_cookie = NULL;\n\ttxn->cli_cookie = NULL;\n\n\tif (!LIST_ISEMPTY(&s->vars_txn.head))\n\t\tvars_prune(&s->vars_txn, s->sess, s);\n\tif (!LIST_ISEMPTY(&s->vars_reqres.head))\n\t\tvars_prune(&s->vars_reqres, s->sess, s);\n\n\tpool_free(pool_head_http_txn, txn);\n\ts->txn = NULL;\n}\n\n\nDECLARE_POOL(pool_head_http_txn, \"http_txn\", sizeof(struct http_txn));\n\n__attribute__((constructor))\nstatic void __http_protocol_init(void)\n{\n}\n\n\n/*\n * Local variables:\n *  c-indent-level: 8\n *  c-basic-offset: 8\n * End:\n */\n"], "fixing_code": ["/*\n * HTTP protocol analyzer\n *\n * Copyright (C) 2018 HAProxy Technologies, Christopher Faulet <cfaulet@haproxy.com>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n *\n */\n\n#include <haproxy/acl.h>\n#include <haproxy/action-t.h>\n#include <haproxy/api.h>\n#include <haproxy/backend.h>\n#include <haproxy/base64.h>\n#include <haproxy/capture-t.h>\n#include <haproxy/cfgparse.h>\n#include <haproxy/channel.h>\n#include <haproxy/check.h>\n#include <haproxy/connection.h>\n#include <haproxy/errors.h>\n#include <haproxy/filters.h>\n#include <haproxy/http.h>\n#include <haproxy/http_ana.h>\n#include <haproxy/http_htx.h>\n#include <haproxy/htx.h>\n#include <haproxy/log.h>\n#include <haproxy/net_helper.h>\n#include <haproxy/proxy.h>\n#include <haproxy/regex.h>\n#include <haproxy/server-t.h>\n#include <haproxy/stats.h>\n#include <haproxy/stream.h>\n#include <haproxy/stream_interface.h>\n#include <haproxy/trace.h>\n#include <haproxy/uri_auth-t.h>\n#include <haproxy/vars.h>\n\n\n#define TRACE_SOURCE &trace_strm\n\nextern const char *stat_status_codes[];\n\nstruct pool_head *pool_head_requri __read_mostly = NULL;\nstruct pool_head *pool_head_capture __read_mostly = NULL;\n\n\nstatic void http_end_request(struct stream *s);\nstatic void http_end_response(struct stream *s);\n\nstatic void http_capture_headers(struct htx *htx, char **cap, struct cap_hdr *cap_hdr);\nstatic int http_del_hdr_value(char *start, char *end, char **from, char *next);\nstatic size_t http_fmt_req_line(const struct htx_sl *sl, char *str, size_t len);\nstatic void http_debug_stline(const char *dir, struct stream *s, const struct htx_sl *sl);\nstatic void http_debug_hdr(const char *dir, struct stream *s, const struct ist n, const struct ist v);\n\nstatic enum rule_result http_req_get_intercept_rule(struct proxy *px, struct list *def_rules, struct list *rules, struct stream *s);\nstatic enum rule_result http_res_get_intercept_rule(struct proxy *px, struct list *def_rules, struct list *rules, struct stream *s);\n\nstatic void http_manage_client_side_cookies(struct stream *s, struct channel *req);\nstatic void http_manage_server_side_cookies(struct stream *s, struct channel *res);\n\nstatic int http_stats_check_uri(struct stream *s, struct http_txn *txn, struct proxy *backend);\nstatic int http_handle_stats(struct stream *s, struct channel *req);\n\nstatic int http_handle_expect_hdr(struct stream *s, struct htx *htx, struct http_msg *msg);\nstatic int http_reply_100_continue(struct stream *s);\n\n/* This stream analyser waits for a complete HTTP request. It returns 1 if the\n * processing can continue on next analysers, or zero if it either needs more\n * data or wants to immediately abort the request (eg: timeout, error, ...). It\n * is tied to AN_REQ_WAIT_HTTP and may may remove itself from s->req.analysers\n * when it has nothing left to do, and may remove any analyser when it wants to\n * abort.\n */\nint http_wait_for_request(struct stream *s, struct channel *req, int an_bit)\n{\n\n\t/*\n\t * We will analyze a complete HTTP request to check the its syntax.\n\t *\n\t * Once the start line and all headers are received, we may perform a\n\t * capture of the error (if any), and we will set a few fields. We also\n\t * check for monitor-uri, logging and finally headers capture.\n\t */\n\tstruct session *sess = s->sess;\n\tstruct http_txn *txn = s->txn;\n\tstruct http_msg *msg = &txn->req;\n\tstruct htx *htx;\n\tstruct htx_sl *sl;\n\n\tDBG_TRACE_ENTER(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn, msg);\n\n\tif (unlikely(!IS_HTX_STRM(s))) {\n\t\t/* It is only possible when a TCP stream is upgrade to HTTP.\n\t\t * There is a transition period during which there is no\n\t\t * data. The stream is still in raw mode and SF_IGNORE flag is\n\t\t * still set. When this happens, the new mux is responsible to\n\t\t * handle all errors. Thus we may leave immediately.\n\t\t */\n\t\tBUG_ON(!(s->flags & SF_IGNORE) || !c_empty(&s->req));\n\n\t\t/* Don't connect for now */\n\t\tchannel_dont_connect(req);\n\n\t\t/* A SHUTR at this stage means we are performing a \"destructive\"\n\t\t * HTTP upgrade (TCP>H2). In this case, we can leave.\n\t\t */\n\t\tif (req->flags & CF_SHUTR) {\n\t\t\ts->logs.logwait = 0;\n                        s->logs.level = 0;\n\t\t\tchannel_abort(&s->req);\n\t\t\tchannel_abort(&s->res);\n\t\t\treq->analysers &= AN_REQ_FLT_END;\n\t\t\treq->analyse_exp = TICK_ETERNITY;\n\t\t\tDBG_TRACE_LEAVE(STRM_EV_STRM_ANA, s);\n\t\t\treturn 1;\n\t\t}\n\t\tDBG_TRACE_LEAVE(STRM_EV_STRM_ANA, s);\n\t\treturn 0;\n\t}\n\n\thtx = htxbuf(&req->buf);\n\n\t/* Parsing errors are caught here */\n\tif (htx->flags & (HTX_FL_PARSING_ERROR|HTX_FL_PROCESSING_ERROR)) {\n\t\tstream_inc_http_req_ctr(s);\n\t\tproxy_inc_fe_req_ctr(sess->listener, sess->fe);\n\t\tif (htx->flags & HTX_FL_PARSING_ERROR) {\n\t\t\tstream_inc_http_err_ctr(s);\n\t\t\tgoto return_bad_req;\n\t\t}\n\t\telse\n\t\t\tgoto return_int_err;\n\t}\n\n\t/* we're speaking HTTP here, so let's speak HTTP to the client */\n\ts->srv_error = http_return_srv_error;\n\n\tmsg->msg_state = HTTP_MSG_BODY;\n\tstream_inc_http_req_ctr(s);\n\tproxy_inc_fe_req_ctr(sess->listener, sess->fe); /* one more valid request for this FE */\n\n\t/* kill the pending keep-alive timeout */\n\treq->analyse_exp = TICK_ETERNITY;\n\n\tBUG_ON(htx_get_first_type(htx) != HTX_BLK_REQ_SL);\n\tsl = http_get_stline(htx);\n\n\t/* 0: we might have to print this header in debug mode */\n\tif (unlikely((global.mode & MODE_DEBUG) &&\n\t\t     (!(global.mode & MODE_QUIET) || (global.mode & MODE_VERBOSE)))) {\n\t\tint32_t pos;\n\n\t\thttp_debug_stline(\"clireq\", s, sl);\n\n\t\tfor (pos = htx_get_first(htx); pos != -1; pos = htx_get_next(htx, pos)) {\n\t\t\tstruct htx_blk *blk = htx_get_blk(htx, pos);\n\t\t\tenum htx_blk_type type = htx_get_blk_type(blk);\n\n\t\t\tif (type == HTX_BLK_EOH)\n\t\t\t\tbreak;\n\t\t\tif (type != HTX_BLK_HDR)\n\t\t\t\tcontinue;\n\n\t\t\thttp_debug_hdr(\"clihdr\", s,\n\t\t\t\t       htx_get_blk_name(htx, blk),\n\t\t\t\t       htx_get_blk_value(htx, blk));\n\t\t}\n\t}\n\n\t/*\n\t * 1: identify the method and the version. Also set HTTP flags\n\t */\n\ttxn->meth = sl->info.req.meth;\n\tif (sl->flags & HTX_SL_F_VER_11)\n                msg->flags |= HTTP_MSGF_VER_11;\n\tmsg->flags |= HTTP_MSGF_XFER_LEN;\n\tif (sl->flags & HTX_SL_F_CLEN)\n\t\tmsg->flags |= HTTP_MSGF_CNT_LEN;\n\telse if (sl->flags & HTX_SL_F_CHNK)\n\t\tmsg->flags |= HTTP_MSGF_TE_CHNK;\n\tif (sl->flags & HTX_SL_F_BODYLESS)\n\t\tmsg->flags |= HTTP_MSGF_BODYLESS;\n\tif (sl->flags & HTX_SL_F_CONN_UPG)\n\t\tmsg->flags |= HTTP_MSGF_CONN_UPG;\n\n\t/* we can make use of server redirect on GET and HEAD */\n\tif (txn->meth == HTTP_METH_GET || txn->meth == HTTP_METH_HEAD)\n\t\ts->flags |= SF_REDIRECTABLE;\n\telse if (txn->meth == HTTP_METH_OTHER && isteqi(htx_sl_req_meth(sl), ist(\"PRI\"))) {\n\t\t/* PRI is reserved for the HTTP/2 preface */\n\t\tgoto return_bad_req;\n\t}\n\n\t/*\n\t * 2: check if the URI matches the monitor_uri.  We have to do this for\n\t * every request which gets in, because the monitor-uri is defined by\n\t * the frontend. If the monitor-uri starts with a '/', the matching is\n\t * done against the request's path. Otherwise, the request's uri is\n\t * used. It is a workaround to let HTTP/2 health-checks work as\n\t * expected.\n\t */\n\tif (unlikely(sess->fe->monitor_uri_len != 0)) {\n\t\tconst struct ist monitor_uri = ist2(sess->fe->monitor_uri,\n\t\t                                    sess->fe->monitor_uri_len);\n\t\tstruct http_uri_parser parser = http_uri_parser_init(htx_sl_req_uri(sl));\n\n\t\tif ((istptr(monitor_uri)[0] == '/' &&\n\t\t     isteq(http_parse_path(&parser), monitor_uri)) ||\n\t\t    isteq(htx_sl_req_uri(sl), monitor_uri)) {\n\t\t\t/*\n\t\t\t * We have found the monitor URI\n\t\t\t */\n\t\t\tstruct acl_cond *cond;\n\n\t\t\ts->flags |= SF_MONITOR;\n\t\t\t_HA_ATOMIC_INC(&sess->fe->fe_counters.intercepted_req);\n\n\t\t\t/* Check if we want to fail this monitor request or not */\n\t\t\tlist_for_each_entry(cond, &sess->fe->mon_fail_cond, list) {\n\t\t\t\tint ret = acl_exec_cond(cond, sess->fe, sess, s, SMP_OPT_DIR_REQ|SMP_OPT_FINAL);\n\n\t\t\t\tret = acl_pass(ret);\n\t\t\t\tif (cond->pol == ACL_COND_UNLESS)\n\t\t\t\t\tret = !ret;\n\n\t\t\t\tif (ret) {\n\t\t\t\t\t/* we fail this request, let's return 503 service unavail */\n\t\t\t\t\ttxn->status = 503;\n\t\t\t\t\tif (!(s->flags & SF_ERR_MASK))\n\t\t\t\t\t\ts->flags |= SF_ERR_LOCAL; /* we don't want a real error here */\n\t\t\t\t\tgoto return_prx_cond;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* nothing to fail, let's reply normally */\n\t\t\ttxn->status = 200;\n\t\t\tif (!(s->flags & SF_ERR_MASK))\n\t\t\t\ts->flags |= SF_ERR_LOCAL; /* we don't want a real error here */\n\t\t\tgoto return_prx_cond;\n\t\t}\n\t}\n\n\t/*\n\t * 3: Maybe we have to copy the original REQURI for the logs ?\n\t * Note: we cannot log anymore if the request has been\n\t * classified as invalid.\n\t */\n\tif (unlikely(s->logs.logwait & LW_REQ)) {\n\t\t/* we have a complete HTTP request that we must log */\n\t\tif ((txn->uri = pool_alloc(pool_head_requri)) != NULL) {\n\t\t\tsize_t len;\n\n\t\t\tlen = http_fmt_req_line(sl, txn->uri, global.tune.requri_len - 1);\n\t\t\ttxn->uri[len] = 0;\n\n\t\t\tif (!(s->logs.logwait &= ~(LW_REQ|LW_INIT)))\n\t\t\t\ts->do_log(s);\n\t\t} else {\n\t\t\tha_alert(\"HTTP logging : out of memory.\\n\");\n\t\t}\n\t}\n\n\t/* if the frontend has \"option http-use-proxy-header\", we'll check if\n\t * we have what looks like a proxied connection instead of a connection,\n\t * and in this case set the TX_USE_PX_CONN flag to use Proxy-connection.\n\t * Note that this is *not* RFC-compliant, however browsers and proxies\n\t * happen to do that despite being non-standard :-(\n\t * We consider that a request not beginning with either '/' or '*' is\n\t * a proxied connection, which covers both \"scheme://location\" and\n\t * CONNECT ip:port.\n\t */\n\tif ((sess->fe->options2 & PR_O2_USE_PXHDR) &&\n\t    *HTX_SL_REQ_UPTR(sl) != '/' && *HTX_SL_REQ_UPTR(sl) != '*')\n\t\ttxn->flags |= TX_USE_PX_CONN;\n\n\t/* 5: we may need to capture headers */\n\tif (unlikely((s->logs.logwait & LW_REQHDR) && s->req_cap))\n\t\thttp_capture_headers(htx, s->req_cap, sess->fe->req_cap);\n\n\t/* we may have to wait for the request's body */\n\tif (s->be->options & PR_O_WREQ_BODY)\n\t\treq->analysers |= AN_REQ_HTTP_BODY;\n\n\t/*\n\t * RFC7234#4:\n\t *   A cache MUST write through requests with methods\n\t *   that are unsafe (Section 4.2.1 of [RFC7231]) to\n\t *   the origin server; i.e., a cache is not allowed\n\t *   to generate a reply to such a request before\n\t *   having forwarded the request and having received\n\t *   a corresponding response.\n\t *\n\t * RFC7231#4.2.1:\n\t *   Of the request methods defined by this\n\t *   specification, the GET, HEAD, OPTIONS, and TRACE\n\t *   methods are defined to be safe.\n\t */\n\tif (likely(txn->meth == HTTP_METH_GET ||\n\t\t   txn->meth == HTTP_METH_HEAD ||\n\t\t   txn->meth == HTTP_METH_OPTIONS ||\n\t\t   txn->meth == HTTP_METH_TRACE))\n\t\ttxn->flags |= TX_CACHEABLE | TX_CACHE_COOK;\n\n\t/* end of job, return OK */\n\treq->analysers &= ~an_bit;\n\treq->analyse_exp = TICK_ETERNITY;\n\n\tDBG_TRACE_LEAVE(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\treturn 1;\n\n return_int_err:\n\ttxn->status = 500;\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_INTERNAL;\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.internal_errors);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->internal_errors);\n\tgoto return_prx_cond;\n\n return_bad_req:\n\ttxn->status = 400;\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.failed_req);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->failed_req);\n\t/* fall through */\n\n return_prx_cond:\n\thttp_reply_and_close(s, txn->status, http_error_message(s));\n\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_PRXCOND;\n\tif (!(s->flags & SF_FINST_MASK))\n\t\ts->flags |= SF_FINST_R;\n\n\tDBG_TRACE_DEVEL(\"leaving on error\",\n\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA|STRM_EV_HTTP_ERR, s, txn);\n\treturn 0;\n}\n\n\n/* This stream analyser runs all HTTP request processing which is common to\n * frontends and backends, which means blocking ACLs, filters, connection-close,\n * reqadd, stats and redirects. This is performed for the designated proxy.\n * It returns 1 if the processing can continue on next analysers, or zero if it\n * either needs more data or wants to immediately abort the request (eg: deny,\n * error, ...).\n */\nint http_process_req_common(struct stream *s, struct channel *req, int an_bit, struct proxy *px)\n{\n\tstruct list *def_rules, *rules;\n\tstruct session *sess = s->sess;\n\tstruct http_txn *txn = s->txn;\n\tstruct http_msg *msg = &txn->req;\n\tstruct htx *htx;\n\tstruct redirect_rule *rule;\n\tenum rule_result verdict;\n\tstruct connection *conn = objt_conn(sess->origin);\n\n\tDBG_TRACE_ENTER(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn, msg);\n\n\thtx = htxbuf(&req->buf);\n\n\t/* just in case we have some per-backend tracking. Only called the first\n\t * execution of the analyser. */\n\tif (!s->current_rule && !s->current_rule_list)\n\t\tstream_inc_be_http_req_ctr(s);\n\n\tdef_rules = ((px->defpx && (an_bit == AN_REQ_HTTP_PROCESS_FE || px != sess->fe)) ? &px->defpx->http_req_rules : NULL);\n\trules = &px->http_req_rules;\n\n\t/* evaluate http-request rules */\n\tif ((def_rules && !LIST_ISEMPTY(def_rules)) || !LIST_ISEMPTY(rules)) {\n\t\tverdict = http_req_get_intercept_rule(px, def_rules, rules, s);\n\n\t\tswitch (verdict) {\n\t\tcase HTTP_RULE_RES_YIELD: /* some data miss, call the function later. */\n\t\t\tgoto return_prx_yield;\n\n\t\tcase HTTP_RULE_RES_CONT:\n\t\tcase HTTP_RULE_RES_STOP: /* nothing to do */\n\t\t\tbreak;\n\n\t\tcase HTTP_RULE_RES_DENY: /* deny or tarpit */\n\t\t\tif (txn->flags & TX_CLTARPIT)\n\t\t\t\tgoto tarpit;\n\t\t\tgoto deny;\n\n\t\tcase HTTP_RULE_RES_ABRT: /* abort request, response already sent. Eg: auth */\n\t\t\tgoto return_prx_cond;\n\n\t\tcase HTTP_RULE_RES_DONE: /* OK, but terminate request processing (eg: redirect) */\n\t\t\tgoto done;\n\n\t\tcase HTTP_RULE_RES_BADREQ: /* failed with a bad request */\n\t\t\tgoto return_bad_req;\n\n\t\tcase HTTP_RULE_RES_ERROR: /* failed with a bad request */\n\t\t\tgoto return_int_err;\n\t\t}\n\t}\n\n\tif (conn && (conn->flags & CO_FL_EARLY_DATA) &&\n\t    (conn->flags & (CO_FL_EARLY_SSL_HS | CO_FL_SSL_WAIT_HS))) {\n\t\tstruct http_hdr_ctx ctx;\n\n\t\tctx.blk = NULL;\n\t\tif (!http_find_header(htx, ist(\"Early-Data\"), &ctx, 0)) {\n\t\t\tif (unlikely(!http_add_header(htx, ist(\"Early-Data\"), ist(\"1\"))))\n\t\t\t\tgoto return_int_err;\n\t\t}\n\t}\n\n\t/* OK at this stage, we know that the request was accepted according to\n\t * the http-request rules, we can check for the stats. Note that the\n\t * URI is detected *before* the req* rules in order not to be affected\n\t * by a possible reqrep, while they are processed *after* so that a\n\t * reqdeny can still block them. This clearly needs to change in 1.6!\n\t */\n\tif (!s->target && http_stats_check_uri(s, txn, px)) {\n\t\ts->target = &http_stats_applet.obj_type;\n\t\tif (unlikely(!si_register_handler(&s->si[1], objt_applet(s->target)))) {\n\t\t\ts->logs.tv_request = now;\n\t\t\tif (!(s->flags & SF_ERR_MASK))\n\t\t\t\ts->flags |= SF_ERR_RESOURCE;\n\t\t\tgoto return_int_err;\n\t\t}\n\n\t\t/* parse the whole stats request and extract the relevant information */\n\t\thttp_handle_stats(s, req);\n\t\tverdict = http_req_get_intercept_rule(px, NULL, &px->uri_auth->http_req_rules, s);\n\t\t/* not all actions implemented: deny, allow, auth */\n\n\t\tif (verdict == HTTP_RULE_RES_DENY) /* stats http-request deny */\n\t\t\tgoto deny;\n\n\t\tif (verdict == HTTP_RULE_RES_ABRT) /* stats auth / stats http-request auth */\n\t\t\tgoto return_prx_cond;\n\n\t\tif (verdict == HTTP_RULE_RES_BADREQ) /* failed with a bad request */\n\t\t\tgoto return_bad_req;\n\n\t\tif (verdict == HTTP_RULE_RES_ERROR) /* failed with a bad request */\n\t\t\tgoto return_int_err;\n\t}\n\n\t/* Proceed with the applets now. */\n\tif (unlikely(objt_applet(s->target))) {\n\t\tif (sess->fe == s->be) /* report it if the request was intercepted by the frontend */\n\t\t\t_HA_ATOMIC_INC(&sess->fe->fe_counters.intercepted_req);\n\n\t\tif (http_handle_expect_hdr(s, htx, msg) == -1)\n\t\t\tgoto return_int_err;\n\n\t\tif (!(s->flags & SF_ERR_MASK))      // this is not really an error but it is\n\t\t\ts->flags |= SF_ERR_LOCAL;   // to mark that it comes from the proxy\n\t\tif (!(s->flags & SF_FINST_MASK))\n\t\t\ts->flags |= SF_FINST_R;\n\n\t\tif (HAS_FILTERS(s))\n\t\t\treq->analysers |= AN_REQ_FLT_HTTP_HDRS;\n\n\t\t/* enable the minimally required analyzers to handle keep-alive and compression on the HTTP response */\n\t\treq->analysers &= (AN_REQ_HTTP_BODY | AN_REQ_FLT_HTTP_HDRS | AN_REQ_FLT_END);\n\t\treq->analysers &= ~AN_REQ_FLT_XFER_DATA;\n\t\treq->analysers |= AN_REQ_HTTP_XFER_BODY;\n\n\t\treq->flags |= CF_SEND_DONTWAIT;\n\t\ts->flags |= SF_ASSIGNED;\n\t\tgoto done;\n\t}\n\n\t/* check whether we have some ACLs set to redirect this request */\n\tlist_for_each_entry(rule, &px->redirect_rules, list) {\n\t\tif (rule->cond) {\n\t\t\tint ret;\n\n\t\t\tret = acl_exec_cond(rule->cond, px, sess, s, SMP_OPT_DIR_REQ|SMP_OPT_FINAL);\n\t\t\tret = acl_pass(ret);\n\t\t\tif (rule->cond->pol == ACL_COND_UNLESS)\n\t\t\t\tret = !ret;\n\t\t\tif (!ret)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (!http_apply_redirect_rule(rule, s, txn))\n\t\t\tgoto return_int_err;\n\t\tgoto done;\n\t}\n\n\t/* POST requests may be accompanied with an \"Expect: 100-Continue\" header.\n\t * If this happens, then the data will not come immediately, so we must\n\t * send all what we have without waiting. Note that due to the small gain\n\t * in waiting for the body of the request, it's easier to simply put the\n\t * CF_SEND_DONTWAIT flag any time. It's a one-shot flag so it will remove\n\t * itself once used.\n\t */\n\treq->flags |= CF_SEND_DONTWAIT;\n\n done:\t/* done with this analyser, continue with next ones that the calling\n\t * points will have set, if any.\n\t */\n\treq->analyse_exp = TICK_ETERNITY;\n done_without_exp: /* done with this analyser, but don't reset the analyse_exp. */\n\treq->analysers &= ~an_bit;\n\ts->current_rule = s->current_rule_list = NULL;\n\tDBG_TRACE_LEAVE(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\treturn 1;\n\n tarpit:\n\t/* Allow cookie logging\n\t */\n\tif (s->be->cookie_name || sess->fe->capture_name)\n\t\thttp_manage_client_side_cookies(s, req);\n\n\t/* When a connection is tarpitted, we use the tarpit timeout,\n\t * which may be the same as the connect timeout if unspecified.\n\t * If unset, then set it to zero because we really want it to\n\t * eventually expire. We build the tarpit as an analyser.\n\t */\n\tchannel_htx_erase(&s->req, htx);\n\n\t/* wipe the request out so that we can drop the connection early\n\t * if the client closes first.\n\t */\n\tchannel_dont_connect(req);\n\n\treq->analysers &= AN_REQ_FLT_END; /* remove switching rules etc... */\n\treq->analysers |= AN_REQ_HTTP_TARPIT;\n\treq->analyse_exp = tick_add_ifset(now_ms,  s->be->timeout.tarpit);\n\tif (!req->analyse_exp)\n\t\treq->analyse_exp = tick_add(now_ms, 0);\n\tstream_inc_http_err_ctr(s);\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.denied_req);\n\tif (s->flags & SF_BE_ASSIGNED)\n\t\t_HA_ATOMIC_INC(&s->be->be_counters.denied_req);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->denied_req);\n\tgoto done_without_exp;\n\n deny:\t/* this request was blocked (denied) */\n\n\t/* Allow cookie logging\n\t */\n\tif (s->be->cookie_name || sess->fe->capture_name)\n\t\thttp_manage_client_side_cookies(s, req);\n\n\ts->logs.tv_request = now;\n\tstream_inc_http_err_ctr(s);\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.denied_req);\n\tif (s->flags & SF_BE_ASSIGNED)\n\t\t_HA_ATOMIC_INC(&s->be->be_counters.denied_req);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->denied_req);\n\tgoto return_prx_err;\n\n return_int_err:\n\ttxn->status = 500;\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_INTERNAL;\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.internal_errors);\n\tif (s->flags & SF_BE_ASSIGNED)\n\t\t_HA_ATOMIC_INC(&s->be->be_counters.internal_errors);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->internal_errors);\n\tgoto return_prx_err;\n\n return_bad_req:\n\ttxn->status = 400;\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.failed_req);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->failed_req);\n\t/* fall through */\n\n return_prx_err:\n\thttp_reply_and_close(s, txn->status, http_error_message(s));\n\t/* fall through */\n\n return_prx_cond:\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_PRXCOND;\n\tif (!(s->flags & SF_FINST_MASK))\n\t\ts->flags |= SF_FINST_R;\n\n\treq->analysers &= AN_REQ_FLT_END;\n\treq->analyse_exp = TICK_ETERNITY;\n\ts->current_rule = s->current_rule_list = NULL;\n\tDBG_TRACE_DEVEL(\"leaving on error\",\n\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA|STRM_EV_HTTP_ERR, s, txn);\n\treturn 0;\n\n return_prx_yield:\n\tchannel_dont_connect(req);\n\tDBG_TRACE_DEVEL(\"waiting for more data\",\n\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\treturn 0;\n}\n\n/* This function performs all the processing enabled for the current request.\n * It returns 1 if the processing can continue on next analysers, or zero if it\n * needs more data, encounters an error, or wants to immediately abort the\n * request. It relies on buffers flags, and updates s->req.analysers.\n */\nint http_process_request(struct stream *s, struct channel *req, int an_bit)\n{\n\tstruct session *sess = s->sess;\n\tstruct http_txn *txn = s->txn;\n\tstruct htx *htx;\n\tstruct connection *cli_conn = objt_conn(strm_sess(s)->origin);\n\n\tDBG_TRACE_ENTER(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\n\t/*\n\t * Right now, we know that we have processed the entire headers\n\t * and that unwanted requests have been filtered out. We can do\n\t * whatever we want with the remaining request. Also, now we\n\t * may have separate values for ->fe, ->be.\n\t */\n\thtx = htxbuf(&req->buf);\n\n\t/*\n\t * 7: Now we can work with the cookies.\n\t * Note that doing so might move headers in the request, but\n\t * the fields will stay coherent and the URI will not move.\n\t * This should only be performed in the backend.\n\t */\n\tif (s->be->cookie_name || sess->fe->capture_name)\n\t\thttp_manage_client_side_cookies(s, req);\n\n\t/* 8: Generate unique ID if a \"unique-id-format\" is defined.\n\t *\n\t * A unique ID is generated even when it is not sent to ensure that the ID can make use of\n\t * fetches only available in the HTTP request processing stage.\n\t */\n\tif (!LIST_ISEMPTY(&sess->fe->format_unique_id)) {\n\t\tstruct ist unique_id = stream_generate_unique_id(s, &sess->fe->format_unique_id);\n\n\t\tif (!isttest(unique_id)) {\n\t\t\tif (!(s->flags & SF_ERR_MASK))\n\t\t\t\ts->flags |= SF_ERR_RESOURCE;\n\t\t\tgoto return_int_err;\n\t\t}\n\n\t\t/* send unique ID if a \"unique-id-header\" is defined */\n\t\tif (isttest(sess->fe->header_unique_id) &&\n\t\t    unlikely(!http_add_header(htx, sess->fe->header_unique_id, s->unique_id)))\n\t\t\t\tgoto return_int_err;\n\t}\n\n\t/*\n\t * 9: add X-Forwarded-For if either the frontend or the backend\n\t * asks for it.\n\t */\n\tif ((sess->fe->options | s->be->options) & PR_O_FWDFOR) {\n\t\tconst struct sockaddr_storage *src = si_src(&s->si[0]);\n\t\tstruct http_hdr_ctx ctx = { .blk = NULL };\n\t\tstruct ist hdr = ist2(s->be->fwdfor_hdr_len ? s->be->fwdfor_hdr_name : sess->fe->fwdfor_hdr_name,\n\t\t\t\t      s->be->fwdfor_hdr_len ? s->be->fwdfor_hdr_len : sess->fe->fwdfor_hdr_len);\n\n\t\tif (!((sess->fe->options | s->be->options) & PR_O_FF_ALWAYS) &&\n\t\t    http_find_header(htx, hdr, &ctx, 0)) {\n\t\t\t/* The header is set to be added only if none is present\n\t\t\t * and we found it, so don't do anything.\n\t\t\t */\n\t\t}\n\t\telse if (src && src->ss_family == AF_INET) {\n\t\t\t/* Add an X-Forwarded-For header unless the source IP is\n\t\t\t * in the 'except' network range.\n\t\t\t */\n\t\t\tif (ipcmp2net(src, &sess->fe->except_xff_net) &&\n\t\t\t    ipcmp2net(src, &s->be->except_xff_net)) {\n\t\t\t\tunsigned char *pn = (unsigned char *)&((struct sockaddr_in *)src)->sin_addr;\n\n\t\t\t\t/* Note: we rely on the backend to get the header name to be used for\n\t\t\t\t * x-forwarded-for, because the header is really meant for the backends.\n\t\t\t\t * However, if the backend did not specify any option, we have to rely\n\t\t\t\t * on the frontend's header name.\n\t\t\t\t */\n\t\t\t\tchunk_printf(&trash, \"%d.%d.%d.%d\", pn[0], pn[1], pn[2], pn[3]);\n\t\t\t\tif (unlikely(!http_add_header(htx, hdr, ist2(trash.area, trash.data))))\n\t\t\t\t\tgoto return_int_err;\n\t\t\t}\n\t\t}\n\t\telse if (src && src->ss_family == AF_INET6) {\n\t\t\t/* Add an X-Forwarded-For header unless the source IP is\n\t\t\t * in the 'except' network range.\n\t\t\t */\n\t\t\tif (ipcmp2net(src, &sess->fe->except_xff_net) &&\n\t\t\t    ipcmp2net(src, &s->be->except_xff_net)) {\n\t\t\t\tchar pn[INET6_ADDRSTRLEN];\n\n\t\t\t\tinet_ntop(AF_INET6,\n\t\t\t\t\t  (const void *)&((struct sockaddr_in6 *)(src))->sin6_addr,\n\t\t\t\t\t  pn, sizeof(pn));\n\n\t\t\t\t/* Note: we rely on the backend to get the header name to be used for\n\t\t\t\t * x-forwarded-for, because the header is really meant for the backends.\n\t\t\t\t * However, if the backend did not specify any option, we have to rely\n\t\t\t\t * on the frontend's header name.\n\t\t\t\t */\n\t\t\t\tchunk_printf(&trash, \"%s\", pn);\n\t\t\t\tif (unlikely(!http_add_header(htx, hdr, ist2(trash.area, trash.data))))\n\t\t\t\t\tgoto return_int_err;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * 10: add X-Original-To if either the frontend or the backend\n\t * asks for it.\n\t */\n\tif ((sess->fe->options | s->be->options) & PR_O_ORGTO) {\n\t\tconst struct sockaddr_storage *dst = si_dst(&s->si[0]);\n\t\tstruct ist hdr = ist2(s->be->orgto_hdr_len ? s->be->orgto_hdr_name : sess->fe->orgto_hdr_name,\n\t\t\t\t      s->be->orgto_hdr_len ? s->be->orgto_hdr_len  : sess->fe->orgto_hdr_len);\n\n\t\tif (dst && dst->ss_family == AF_INET) {\n\t\t\t/* Add an X-Original-To header unless the destination IP is\n\t\t\t * in the 'except' network range.\n\t\t\t */\n\t\t\tif (ipcmp2net(dst, &sess->fe->except_xot_net) &&\n\t\t\t    ipcmp2net(dst, &s->be->except_xot_net)) {\n\t\t\t\tunsigned char *pn = (unsigned char *)&((struct sockaddr_in *)dst)->sin_addr;\n\n\t\t\t\t/* Note: we rely on the backend to get the header name to be used for\n\t\t\t\t * x-original-to, because the header is really meant for the backends.\n\t\t\t\t * However, if the backend did not specify any option, we have to rely\n\t\t\t\t * on the frontend's header name.\n\t\t\t\t */\n\t\t\t\tchunk_printf(&trash, \"%d.%d.%d.%d\", pn[0], pn[1], pn[2], pn[3]);\n\t\t\t\tif (unlikely(!http_add_header(htx, hdr, ist2(trash.area, trash.data))))\n\t\t\t\t\tgoto return_int_err;\n\t\t\t}\n\t\t}\n\t\telse if (dst && dst->ss_family == AF_INET6) {\n\t\t\t/* Add an X-Original-To header unless the source IP is\n\t\t\t * in the 'except' network range.\n\t\t\t */\n\t\t\tif (ipcmp2net(dst, &sess->fe->except_xot_net) &&\n\t\t\t    ipcmp2net(dst, &s->be->except_xot_net)) {\n\t\t\t\tchar pn[INET6_ADDRSTRLEN];\n\n\t\t\t\tinet_ntop(AF_INET6,\n\t\t\t\t\t  (const void *)&((struct sockaddr_in6 *)dst)->sin6_addr,\n\t\t\t\t\t  pn, sizeof(pn));\n\n\t\t\t\t/* Note: we rely on the backend to get the header name to be used for\n\t\t\t\t * x-forwarded-for, because the header is really meant for the backends.\n\t\t\t\t * However, if the backend did not specify any option, we have to rely\n\t\t\t\t * on the frontend's header name.\n\t\t\t\t */\n\t\t\t\tchunk_printf(&trash, \"%s\", pn);\n\t\t\t\tif (unlikely(!http_add_header(htx, hdr, ist2(trash.area, trash.data))))\n\t\t\t\t\tgoto return_int_err;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Filter the request headers if there are filters attached to the\n\t * stream.\n\t */\n\tif (HAS_FILTERS(s))\n\t\treq->analysers |= AN_REQ_FLT_HTTP_HDRS;\n\n\t/* If we have no server assigned yet and we're balancing on url_param\n\t * with a POST request, we may be interested in checking the body for\n\t * that parameter. This will be done in another analyser.\n\t */\n\tif (!(s->flags & (SF_ASSIGNED|SF_DIRECT)) &&\n\t    s->txn->meth == HTTP_METH_POST &&\n\t    (s->be->lbprm.algo & BE_LB_ALGO) == BE_LB_ALGO_PH) {\n\t\tchannel_dont_connect(req);\n\t\treq->analysers |= AN_REQ_HTTP_BODY;\n\t}\n\n\treq->analysers &= ~AN_REQ_FLT_XFER_DATA;\n\treq->analysers |= AN_REQ_HTTP_XFER_BODY;\n\n\t/* We expect some data from the client. Unless we know for sure\n\t * we already have a full request, we have to re-enable quick-ack\n\t * in case we previously disabled it, otherwise we might cause\n\t * the client to delay further data.\n\t */\n\tif ((sess->listener && (sess->listener->options & LI_O_NOQUICKACK)) && !(htx->flags & HTX_FL_EOM))\n\t\tconn_set_quickack(cli_conn, 1);\n\n\t/*************************************************************\n\t * OK, that's finished for the headers. We have done what we *\n\t * could. Let's switch to the DATA state.                    *\n\t ************************************************************/\n\treq->analyse_exp = TICK_ETERNITY;\n\treq->analysers &= ~an_bit;\n\n\ts->logs.tv_request = now;\n\t/* OK let's go on with the BODY now */\n\tDBG_TRACE_LEAVE(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\treturn 1;\n\n return_int_err:\n\ttxn->status = 500;\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_INTERNAL;\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.internal_errors);\n\tif (s->flags & SF_BE_ASSIGNED)\n\t\t_HA_ATOMIC_INC(&s->be->be_counters.internal_errors);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->internal_errors);\n\n\thttp_reply_and_close(s, txn->status, http_error_message(s));\n\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_PRXCOND;\n\tif (!(s->flags & SF_FINST_MASK))\n\t\ts->flags |= SF_FINST_R;\n\n\tDBG_TRACE_DEVEL(\"leaving on error\",\n\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA|STRM_EV_HTTP_ERR, s, txn);\n\treturn 0;\n}\n\n/* This function is an analyser which processes the HTTP tarpit. It always\n * returns zero, at the beginning because it prevents any other processing\n * from occurring, and at the end because it terminates the request.\n */\nint http_process_tarpit(struct stream *s, struct channel *req, int an_bit)\n{\n\tstruct http_txn *txn = s->txn;\n\n\tDBG_TRACE_ENTER(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn, &txn->req);\n\t/* This connection is being tarpitted. The CLIENT side has\n\t * already set the connect expiration date to the right\n\t * timeout. We just have to check that the client is still\n\t * there and that the timeout has not expired.\n\t */\n\tchannel_dont_connect(req);\n\tif ((req->flags & (CF_SHUTR|CF_READ_ERROR)) == 0 &&\n\t    !tick_is_expired(req->analyse_exp, now_ms)) {\n\t\t/* Be sure to drain all data from the request channel */\n\t\tchannel_htx_erase(req, htxbuf(&req->buf));\n\t\tDBG_TRACE_DEVEL(\"waiting for tarpit timeout expiry\",\n\t\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\t\treturn 0;\n\t}\n\n\n\t/* We will set the queue timer to the time spent, just for\n\t * logging purposes. We fake a 500 server error, so that the\n\t * attacker will not suspect his connection has been tarpitted.\n\t * It will not cause trouble to the logs because we can exclude\n\t * the tarpitted connections by filtering on the 'PT' status flags.\n\t */\n\ts->logs.t_queue = tv_ms_elapsed(&s->logs.tv_accept, &now);\n\n\thttp_reply_and_close(s, txn->status, (!(req->flags & CF_READ_ERROR) ? http_error_message(s) : NULL));\n\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_PRXCOND;\n\tif (!(s->flags & SF_FINST_MASK))\n\t\ts->flags |= SF_FINST_T;\n\n\tDBG_TRACE_LEAVE(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\treturn 0;\n}\n\n/* This function is an analyser which waits for the HTTP request body. It waits\n * for either the buffer to be full, or the full advertised contents to have\n * reached the buffer. It must only be called after the standard HTTP request\n * processing has occurred, because it expects the request to be parsed and will\n * look for the Expect header. It may send a 100-Continue interim response. It\n * takes in input any state starting from HTTP_MSG_BODY and leaves with one of\n * HTTP_MSG_CHK_SIZE, HTTP_MSG_DATA or HTTP_MSG_TRAILERS. It returns zero if it\n * needs to read more data, or 1 once it has completed its analysis.\n */\nint http_wait_for_request_body(struct stream *s, struct channel *req, int an_bit)\n{\n\tstruct session *sess = s->sess;\n\tstruct http_txn *txn = s->txn;\n\tstruct http_msg *msg = &s->txn->req;\n\n\tDBG_TRACE_ENTER(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn, msg);\n\n\n\tswitch (http_wait_for_msg_body(s, req, s->be->timeout.httpreq, 0)) {\n\tcase HTTP_RULE_RES_CONT:\n\t\tgoto http_end;\n\tcase HTTP_RULE_RES_YIELD:\n\t\tgoto missing_data_or_waiting;\n\tcase HTTP_RULE_RES_BADREQ:\n\t\tgoto return_bad_req;\n\tcase HTTP_RULE_RES_ERROR:\n\t\tgoto return_int_err;\n\tcase HTTP_RULE_RES_ABRT:\n\t\tgoto return_prx_cond;\n\tdefault:\n\t\tgoto return_int_err;\n\t}\n\n http_end:\n\t/* The situation will not evolve, so let's give up on the analysis. */\n\ts->logs.tv_request = now;  /* update the request timer to reflect full request */\n\treq->analysers &= ~an_bit;\n\treq->analyse_exp = TICK_ETERNITY;\n\tDBG_TRACE_LEAVE(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\treturn 1;\n\n missing_data_or_waiting:\n\tchannel_dont_connect(req);\n\tDBG_TRACE_DEVEL(\"waiting for more data\",\n\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\treturn 0;\n\n return_int_err:\n\ttxn->status = 500;\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_INTERNAL;\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.internal_errors);\n\tif (s->flags & SF_BE_ASSIGNED)\n\t\t_HA_ATOMIC_INC(&s->be->be_counters.internal_errors);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->internal_errors);\n\tgoto return_prx_err;\n\n return_bad_req: /* let's centralize all bad requests */\n\ttxn->status = 400;\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.failed_req);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->failed_req);\n\t/* fall through */\n\n return_prx_err:\n\thttp_reply_and_close(s, txn->status, http_error_message(s));\n\t/* fall through */\n\n return_prx_cond:\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_PRXCOND;\n\tif (!(s->flags & SF_FINST_MASK))\n\t\ts->flags |= (msg->msg_state < HTTP_MSG_DATA ? SF_FINST_R : SF_FINST_D);\n\n\treq->analysers &= AN_REQ_FLT_END;\n\treq->analyse_exp = TICK_ETERNITY;\n\tDBG_TRACE_DEVEL(\"leaving on error\",\n\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA|STRM_EV_HTTP_ERR, s, txn);\n\treturn 0;\n}\n\n/* This function is an analyser which forwards request body (including chunk\n * sizes if any). It is called as soon as we must forward, even if we forward\n * zero byte. The only situation where it must not be called is when we're in\n * tunnel mode and we want to forward till the close. It's used both to forward\n * remaining data and to resync after end of body. It expects the msg_state to\n * be between MSG_BODY and MSG_DONE (inclusive). It returns zero if it needs to\n * read more data, or 1 once we can go on with next request or end the stream.\n * When in MSG_DATA or MSG_TRAILERS, it will automatically forward chunk_len\n * bytes of pending data + the headers if not already done.\n */\nint http_request_forward_body(struct stream *s, struct channel *req, int an_bit)\n{\n\tstruct session *sess = s->sess;\n\tstruct http_txn *txn = s->txn;\n\tstruct http_msg *msg = &txn->req;\n\tstruct htx *htx;\n\tshort status = 0;\n\tint ret;\n\n\tDBG_TRACE_ENTER(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn, msg);\n\n\thtx = htxbuf(&req->buf);\n\n\tif (htx->flags & HTX_FL_PARSING_ERROR)\n\t\tgoto return_bad_req;\n\tif (htx->flags & HTX_FL_PROCESSING_ERROR)\n\t\tgoto return_int_err;\n\n\tif ((req->flags & (CF_READ_ERROR|CF_READ_TIMEOUT|CF_WRITE_ERROR|CF_WRITE_TIMEOUT)) ||\n\t    ((req->flags & CF_SHUTW) && (req->to_forward || co_data(req)))) {\n\t\t/* Output closed while we were sending data. We must abort and\n\t\t * wake the other side up.\n\t\t *\n\t\t * If we have finished to send the request and the response is\n\t\t * still in progress, don't catch write error on the request\n\t\t * side if it is in fact a read error on the server side.\n\t\t */\n\t\tif (msg->msg_state == HTTP_MSG_DONE && (s->res.flags & CF_READ_ERROR) && s->res.analysers)\n\t\t\treturn 0;\n\n\t\t/* Don't abort yet if we had L7 retries activated and it\n\t\t * was a write error, we may recover.\n\t\t */\n\t\tif (!(req->flags & (CF_READ_ERROR | CF_READ_TIMEOUT)) &&\n\t\t    (s->si[1].flags & SI_FL_L7_RETRY)) {\n\t\t\tDBG_TRACE_DEVEL(\"leaving on L7 retry\",\n\t\t\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA|STRM_EV_HTTP_ERR, s, txn);\n\t\t\treturn 0;\n\t\t}\n\t\tmsg->msg_state = HTTP_MSG_ERROR;\n\t\thttp_end_request(s);\n\t\thttp_end_response(s);\n\t\tDBG_TRACE_DEVEL(\"leaving on error\",\n\t\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA|STRM_EV_HTTP_ERR, s, txn);\n\t\treturn 1;\n\t}\n\n\t/* Note that we don't have to send 100-continue back because we don't\n\t * need the data to complete our job, and it's up to the server to\n\t * decide whether to return 100, 417 or anything else in return of\n\t * an \"Expect: 100-continue\" header.\n\t */\n\tif (msg->msg_state == HTTP_MSG_BODY)\n\t\tmsg->msg_state = HTTP_MSG_DATA;\n\n\t/* in most states, we should abort in case of early close */\n\tchannel_auto_close(req);\n\n\tif (req->to_forward) {\n\t\tif (req->to_forward == CHN_INFINITE_FORWARD) {\n\t\t\tif (req->flags & CF_EOI)\n\t\t\t\tmsg->msg_state = HTTP_MSG_ENDING;\n\t\t}\n\t\telse {\n\t\t\t/* We can't process the buffer's contents yet */\n\t\t\treq->flags |= CF_WAKE_WRITE;\n\t\t\tgoto missing_data_or_waiting;\n\t\t}\n\t}\n\n\tif (msg->msg_state >= HTTP_MSG_ENDING)\n\t\tgoto ending;\n\n\tif (txn->meth == HTTP_METH_CONNECT) {\n\t\tmsg->msg_state = HTTP_MSG_ENDING;\n\t\tgoto ending;\n\t}\n\n\t/* Forward input data. We get it by removing all outgoing data not\n\t * forwarded yet from HTX data size. If there are some data filters, we\n\t * let them decide the amount of data to forward.\n\t */\n\tif (HAS_REQ_DATA_FILTERS(s)) {\n\t\tret  = flt_http_payload(s, msg, htx->data);\n\t\tif (ret < 0)\n\t\t\tgoto return_bad_req;\n\t\tc_adv(req, ret);\n\t}\n\telse {\n\t\tc_adv(req, htx->data - co_data(req));\n\t\tif (msg->flags & HTTP_MSGF_XFER_LEN)\n\t\t\tchannel_htx_forward_forever(req, htx);\n\t}\n\n\tif (htx->data != co_data(req))\n\t\tgoto missing_data_or_waiting;\n\n\t/* Check if the end-of-message is reached and if so, switch the message\n\t * in HTTP_MSG_ENDING state. Then if all data was marked to be\n\t * forwarded, set the state to HTTP_MSG_DONE.\n\t */\n\tif (!(htx->flags & HTX_FL_EOM))\n\t\tgoto missing_data_or_waiting;\n\n\tmsg->msg_state = HTTP_MSG_ENDING;\n\n  ending:\n\treq->flags &= ~CF_EXPECT_MORE; /* no more data are expected */\n\n\t/* other states, ENDING...TUNNEL */\n\tif (msg->msg_state >= HTTP_MSG_DONE)\n\t\tgoto done;\n\n\tif (HAS_REQ_DATA_FILTERS(s)) {\n\t\tret = flt_http_end(s, msg);\n\t\tif (ret <= 0) {\n\t\t\tif (!ret)\n\t\t\t\tgoto missing_data_or_waiting;\n\t\t\tgoto return_bad_req;\n\t\t}\n\t}\n\n\tif (txn->meth == HTTP_METH_CONNECT)\n\t\tmsg->msg_state = HTTP_MSG_TUNNEL;\n\telse {\n\t\tmsg->msg_state = HTTP_MSG_DONE;\n\t\treq->to_forward = 0;\n\t}\n\n  done:\n\t/* we don't want to forward closes on DONE except in tunnel mode. */\n\tif (!(txn->flags & TX_CON_WANT_TUN))\n\t\tchannel_dont_close(req);\n\n\thttp_end_request(s);\n\tif (!(req->analysers & an_bit)) {\n\t\thttp_end_response(s);\n\t\tif (unlikely(msg->msg_state == HTTP_MSG_ERROR)) {\n\t\t\tif (req->flags & CF_SHUTW) {\n\t\t\t\t/* request errors are most likely due to the\n\t\t\t\t * server aborting the transfer. */\n\t\t\t\tgoto return_srv_abort;\n\t\t\t}\n\t\t\tgoto return_bad_req;\n\t\t}\n\t\tDBG_TRACE_LEAVE(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\t\treturn 1;\n\t}\n\n\t/* If \"option abortonclose\" is set on the backend, we want to monitor\n\t * the client's connection and forward any shutdown notification to the\n\t * server, which will decide whether to close or to go on processing the\n\t * request. We only do that in tunnel mode, and not in other modes since\n\t * it can be abused to exhaust source ports. */\n\tif (s->be->options & PR_O_ABRT_CLOSE) {\n\t\tchannel_auto_read(req);\n\t\tif ((req->flags & (CF_SHUTR|CF_READ_NULL)) && !(txn->flags & TX_CON_WANT_TUN))\n\t\t\ts->si[1].flags |= SI_FL_NOLINGER;\n\t\tchannel_auto_close(req);\n\t}\n\telse if (s->txn->meth == HTTP_METH_POST) {\n\t\t/* POST requests may require to read extra CRLF sent by broken\n\t\t * browsers and which could cause an RST to be sent upon close\n\t\t * on some systems (eg: Linux). */\n\t\tchannel_auto_read(req);\n\t}\n\tDBG_TRACE_DEVEL(\"waiting for the end of the HTTP txn\",\n\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\treturn 0;\n\n missing_data_or_waiting:\n\t/* stop waiting for data if the input is closed before the end */\n\tif (msg->msg_state < HTTP_MSG_ENDING && req->flags & CF_SHUTR)\n\t\tgoto return_cli_abort;\n\n waiting:\n\t/* waiting for the last bits to leave the buffer */\n\tif (req->flags & CF_SHUTW)\n\t\tgoto return_srv_abort;\n\n\t/* When TE: chunked is used, we need to get there again to parse remaining\n\t * chunks even if the client has closed, so we don't want to set CF_DONTCLOSE.\n\t * And when content-length is used, we never want to let the possible\n\t * shutdown be forwarded to the other side, as the state machine will\n\t * take care of it once the client responds. It's also important to\n\t * prevent TIME_WAITs from accumulating on the backend side, and for\n\t * HTTP/2 where the last frame comes with a shutdown.\n\t */\n\tif (msg->flags & HTTP_MSGF_XFER_LEN)\n\t\tchannel_dont_close(req);\n\n\t/* We know that more data are expected, but we couldn't send more that\n\t * what we did. So we always set the CF_EXPECT_MORE flag so that the\n\t * system knows it must not set a PUSH on this first part. Interactive\n\t * modes are already handled by the stream sock layer. We must not do\n\t * this in content-length mode because it could present the MSG_MORE\n\t * flag with the last block of forwarded data, which would cause an\n\t * additional delay to be observed by the receiver.\n\t */\n\tif (HAS_REQ_DATA_FILTERS(s))\n\t\treq->flags |= CF_EXPECT_MORE;\n\n\tDBG_TRACE_DEVEL(\"waiting for more data to forward\",\n\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\treturn 0;\n\n  return_cli_abort:\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.cli_aborts);\n\t_HA_ATOMIC_INC(&s->be->be_counters.cli_aborts);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->cli_aborts);\n\tif (objt_server(s->target))\n\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.cli_aborts);\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_CLICL;\n\tstatus = 400;\n\tgoto return_prx_cond;\n\n  return_srv_abort:\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.srv_aborts);\n\t_HA_ATOMIC_INC(&s->be->be_counters.srv_aborts);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->srv_aborts);\n\tif (objt_server(s->target))\n\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.srv_aborts);\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_SRVCL;\n\tstatus = 502;\n\tgoto return_prx_cond;\n\n  return_int_err:\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_INTERNAL;\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.internal_errors);\n\t_HA_ATOMIC_INC(&s->be->be_counters.internal_errors);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->internal_errors);\n\tif (objt_server(s->target))\n\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.internal_errors);\n\tstatus = 500;\n\tgoto return_prx_cond;\n\n  return_bad_req:\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.failed_req);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->failed_req);\n\tstatus = 400;\n\t/* fall through */\n\n  return_prx_cond:\n\tif (txn->status > 0) {\n\t\t/* Note: we don't send any error if some data were already sent */\n\t\thttp_reply_and_close(s, txn->status, NULL);\n\t} else {\n\t\ttxn->status = status;\n\t\thttp_reply_and_close(s, txn->status, http_error_message(s));\n\t}\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_PRXCOND;\n\tif (!(s->flags & SF_FINST_MASK))\n\t\ts->flags |= ((txn->rsp.msg_state < HTTP_MSG_ERROR) ? SF_FINST_H : SF_FINST_D);\n\tDBG_TRACE_DEVEL(\"leaving on error \",\n\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA|STRM_EV_HTTP_ERR, s, txn);\n\treturn 0;\n}\n\n/* Reset the stream and the backend stream_interface to a situation suitable for attemption connection */\n/* Returns 0 if we can attempt to retry, -1 otherwise */\nstatic __inline int do_l7_retry(struct stream *s, struct stream_interface *si)\n{\n\tstruct channel *req, *res;\n\tint co_data;\n\n\tsi->conn_retries--;\n\tif (si->conn_retries < 0)\n\t\treturn -1;\n\n\tif (objt_server(s->target)) {\n\t\tif (s->flags & SF_CURR_SESS) {\n\t\t\ts->flags &= ~SF_CURR_SESS;\n\t\t\t_HA_ATOMIC_DEC(&__objt_server(s->target)->cur_sess);\n\t\t}\n\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.retries);\n\t}\n\t_HA_ATOMIC_INC(&s->be->be_counters.retries);\n\n\treq = &s->req;\n\tres = &s->res;\n\t/* Remove any write error from the request, and read error from the response */\n\treq->flags &= ~(CF_WRITE_ERROR | CF_WRITE_TIMEOUT | CF_SHUTW | CF_SHUTW_NOW);\n\tres->flags &= ~(CF_READ_ERROR | CF_READ_TIMEOUT | CF_SHUTR | CF_EOI | CF_READ_NULL | CF_SHUTR_NOW);\n\tres->analysers &= AN_RES_FLT_END;\n\tsi->flags &= ~(SI_FL_ERR | SI_FL_EXP | SI_FL_RXBLK_SHUT);\n\tsi->err_type = SI_ET_NONE;\n\ts->flags &= ~(SF_ERR_MASK | SF_FINST_MASK);\n\tstream_choose_redispatch(s);\n\tsi->exp = TICK_ETERNITY;\n\tres->rex = TICK_ETERNITY;\n\tres->to_forward = 0;\n\tres->analyse_exp = TICK_ETERNITY;\n\tres->total = 0;\n\tsi_release_endpoint(&s->si[1]);\n\n\tb_free(&req->buf);\n\t/* Swap the L7 buffer with the channel buffer */\n\t/* We know we stored the co_data as b_data, so get it there */\n\tco_data = b_data(&si->l7_buffer);\n\tb_set_data(&si->l7_buffer, b_size(&si->l7_buffer));\n\tb_xfer(&req->buf, &si->l7_buffer, b_data(&si->l7_buffer));\n\tco_set_data(req, co_data);\n\n\tDBG_TRACE_DEVEL(\"perform a L7 retry\", STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, s->txn);\n\n\tb_reset(&res->buf);\n\tco_set_data(res, 0);\n\treturn 0;\n}\n\n/* This stream analyser waits for a complete HTTP response. It returns 1 if the\n * processing can continue on next analysers, or zero if it either needs more\n * data or wants to immediately abort the response (eg: timeout, error, ...). It\n * is tied to AN_RES_WAIT_HTTP and may may remove itself from s->res.analysers\n * when it has nothing left to do, and may remove any analyser when it wants to\n * abort.\n */\nint http_wait_for_response(struct stream *s, struct channel *rep, int an_bit)\n{\n\t/*\n\t * We will analyze a complete HTTP response to check the its syntax.\n\t *\n\t * Once the start line and all headers are received, we may perform a\n\t * capture of the error (if any), and we will set a few fields. We also\n\t * logging and finally headers capture.\n\t */\n\tstruct session *sess = s->sess;\n\tstruct http_txn *txn = s->txn;\n\tstruct http_msg *msg = &txn->rsp;\n\tstruct htx *htx;\n\tstruct stream_interface *si_b = &s->si[1];\n\tstruct connection *srv_conn;\n\tstruct htx_sl *sl;\n\tint n;\n\n\tDBG_TRACE_ENTER(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn, msg);\n\n\thtx = htxbuf(&rep->buf);\n\n\t/* Parsing errors are caught here */\n\tif (htx->flags & HTX_FL_PARSING_ERROR)\n\t\tgoto return_bad_res;\n\tif (htx->flags & HTX_FL_PROCESSING_ERROR)\n\t\tgoto return_int_err;\n\n\t/*\n\t * Now we quickly check if we have found a full valid response.\n\t * If not so, we check the FD and buffer states before leaving.\n\t * A full response is indicated by the fact that we have seen\n\t * the double LF/CRLF, so the state is >= HTTP_MSG_BODY. Invalid\n\t * responses are checked first.\n\t *\n\t * Depending on whether the client is still there or not, we\n\t * may send an error response back or not. Note that normally\n\t * we should only check for HTTP status there, and check I/O\n\t * errors somewhere else.\n\t */\n  next_one:\n\tif (unlikely(htx_is_empty(htx) || htx->first == -1)) {\n\t\t/* 1: have we encountered a read error ? */\n\t\tif (rep->flags & CF_READ_ERROR) {\n\t\t\tstruct connection *conn = NULL;\n\n\t\t\tif (objt_cs(s->si[1].end))\n\t\t\t\tconn = __objt_cs(s->si[1].end)->conn;\n\n\t\t\t/* Perform a L7 retry because server refuses the early data. */\n\t\t\tif ((si_b->flags & SI_FL_L7_RETRY) &&\n\t\t\t    (s->be->retry_type & PR_RE_EARLY_ERROR) &&\n\t\t\t    conn && conn->err_code == CO_ER_SSL_EARLY_FAILED &&\n\t\t\t    do_l7_retry(s, si_b) == 0) {\n\t\t\t\tDBG_TRACE_DEVEL(\"leaving on L7 retry\",\n\t\t\t\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (txn->flags & TX_NOT_FIRST)\n\t\t\t\tgoto abort_keep_alive;\n\n\t\t\t_HA_ATOMIC_INC(&s->be->be_counters.failed_resp);\n\t\t\tif (objt_server(s->target)) {\n\t\t\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.failed_resp);\n\t\t\t\thealth_adjust(__objt_server(s->target), HANA_STATUS_HTTP_READ_ERROR);\n\t\t\t}\n\n\t\t\t/* if the server refused the early data, just send a 425 */\n\t\t\tif (conn && conn->err_code == CO_ER_SSL_EARLY_FAILED)\n\t\t\t\ttxn->status = 425;\n\t\t\telse {\n\t\t\t\ttxn->status = 502;\n\t\t\t\tstream_inc_http_fail_ctr(s);\n\t\t\t}\n\n\t\t\ts->si[1].flags |= SI_FL_NOLINGER;\n\t\t\thttp_reply_and_close(s, txn->status, http_error_message(s));\n\n\t\t\tif (!(s->flags & SF_ERR_MASK))\n\t\t\t\ts->flags |= SF_ERR_SRVCL;\n\t\t\tif (!(s->flags & SF_FINST_MASK))\n\t\t\t\ts->flags |= SF_FINST_H;\n\t\t\tDBG_TRACE_DEVEL(\"leaving on error\",\n\t\t\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA|STRM_EV_HTTP_ERR, s, txn);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* 2: read timeout : return a 504 to the client. */\n\t\telse if (rep->flags & CF_READ_TIMEOUT) {\n\t\t\tif ((si_b->flags & SI_FL_L7_RETRY) &&\n\t\t\t    (s->be->retry_type & PR_RE_TIMEOUT)) {\n\t\t\t\tif (co_data(rep) || do_l7_retry(s, si_b) == 0) {\n\t\t\t\t\tDBG_TRACE_DEVEL(\"leaving on L7 retry\",\n\t\t\t\t\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t_HA_ATOMIC_INC(&s->be->be_counters.failed_resp);\n\t\t\tif (objt_server(s->target)) {\n\t\t\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.failed_resp);\n\t\t\t\thealth_adjust(__objt_server(s->target), HANA_STATUS_HTTP_READ_TIMEOUT);\n\t\t\t}\n\n\t\t\ttxn->status = 504;\n\t\t\tstream_inc_http_fail_ctr(s);\n\t\t\ts->si[1].flags |= SI_FL_NOLINGER;\n\t\t\thttp_reply_and_close(s, txn->status, http_error_message(s));\n\n\t\t\tif (!(s->flags & SF_ERR_MASK))\n\t\t\t\ts->flags |= SF_ERR_SRVTO;\n\t\t\tif (!(s->flags & SF_FINST_MASK))\n\t\t\t\ts->flags |= SF_FINST_H;\n\t\t\tDBG_TRACE_DEVEL(\"leaving on error\",\n\t\t\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA|STRM_EV_HTTP_ERR, s, txn);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* 3: client abort with an abortonclose */\n\t\telse if ((rep->flags & CF_SHUTR) && ((s->req.flags & (CF_SHUTR|CF_SHUTW)) == (CF_SHUTR|CF_SHUTW))) {\n\t\t\t_HA_ATOMIC_INC(&sess->fe->fe_counters.cli_aborts);\n\t\t\t_HA_ATOMIC_INC(&s->be->be_counters.cli_aborts);\n\t\t\tif (sess->listener && sess->listener->counters)\n\t\t\t\t_HA_ATOMIC_INC(&sess->listener->counters->cli_aborts);\n\t\t\tif (objt_server(s->target))\n\t\t\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.cli_aborts);\n\n\t\t\ttxn->status = 400;\n\t\t\thttp_reply_and_close(s, txn->status, http_error_message(s));\n\n\t\t\tif (!(s->flags & SF_ERR_MASK))\n\t\t\t\ts->flags |= SF_ERR_CLICL;\n\t\t\tif (!(s->flags & SF_FINST_MASK))\n\t\t\t\ts->flags |= SF_FINST_H;\n\n\t\t\t/* process_stream() will take care of the error */\n\t\t\tDBG_TRACE_DEVEL(\"leaving on error\",\n\t\t\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA|STRM_EV_HTTP_ERR, s, txn);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* 4: close from server, capture the response if the server has started to respond */\n\t\telse if (rep->flags & CF_SHUTR) {\n\t\t\tif ((si_b->flags & SI_FL_L7_RETRY) &&\n\t\t\t    (s->be->retry_type & PR_RE_DISCONNECTED)) {\n\t\t\t\tif (co_data(rep) || do_l7_retry(s, si_b) == 0) {\n\t\t\t\t\tDBG_TRACE_DEVEL(\"leaving on L7 retry\",\n\t\t\t\t\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (txn->flags & TX_NOT_FIRST)\n\t\t\t\tgoto abort_keep_alive;\n\n\t\t\t_HA_ATOMIC_INC(&s->be->be_counters.failed_resp);\n\t\t\tif (objt_server(s->target)) {\n\t\t\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.failed_resp);\n\t\t\t\thealth_adjust(__objt_server(s->target), HANA_STATUS_HTTP_BROKEN_PIPE);\n\t\t\t}\n\n\t\t\ttxn->status = 502;\n\t\t\tstream_inc_http_fail_ctr(s);\n\t\t\ts->si[1].flags |= SI_FL_NOLINGER;\n\t\t\thttp_reply_and_close(s, txn->status, http_error_message(s));\n\n\t\t\tif (!(s->flags & SF_ERR_MASK))\n\t\t\t\ts->flags |= SF_ERR_SRVCL;\n\t\t\tif (!(s->flags & SF_FINST_MASK))\n\t\t\t\ts->flags |= SF_FINST_H;\n\t\t\tDBG_TRACE_DEVEL(\"leaving on error\",\n\t\t\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA|STRM_EV_HTTP_ERR, s, txn);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* 5: write error to client (we don't send any message then) */\n\t\telse if (rep->flags & CF_WRITE_ERROR) {\n\t\t\tif (txn->flags & TX_NOT_FIRST)\n\t\t\t\tgoto abort_keep_alive;\n\n\t\t\t_HA_ATOMIC_INC(&s->be->be_counters.failed_resp);\n\t\t\tif (objt_server(s->target))\n\t\t\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.failed_resp);\n\t\t\trep->analysers &= AN_RES_FLT_END;\n\n\t\t\tif (!(s->flags & SF_ERR_MASK))\n\t\t\t\ts->flags |= SF_ERR_CLICL;\n\t\t\tif (!(s->flags & SF_FINST_MASK))\n\t\t\t\ts->flags |= SF_FINST_H;\n\n\t\t\t/* process_stream() will take care of the error */\n\t\t\tDBG_TRACE_DEVEL(\"leaving on error\",\n\t\t\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA|STRM_EV_HTTP_ERR, s, txn);\n\t\t\treturn 0;\n\t\t}\n\n\t\tchannel_dont_close(rep);\n\t\trep->flags |= CF_READ_DONTWAIT; /* try to get back here ASAP */\n\t\tDBG_TRACE_DEVEL(\"waiting for more data\",\n\t\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\t\treturn 0;\n\t}\n\n\t/* More interesting part now : we know that we have a complete\n\t * response which at least looks like HTTP. We have an indicator\n\t * of each header's length, so we can parse them quickly.\n\t */\n\tBUG_ON(htx_get_first_type(htx) != HTX_BLK_RES_SL);\n\tsl = http_get_stline(htx);\n\n\t/* Perform a L7 retry because of the status code */\n\tif ((si_b->flags & SI_FL_L7_RETRY) &&\n\t    l7_status_match(s->be, sl->info.res.status) &&\n\t    do_l7_retry(s, si_b) == 0) {\n\t\tDBG_TRACE_DEVEL(\"leaving on L7 retry\", STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\t\treturn 0;\n\t}\n\n\t/* Now, L7 buffer is useless, it can be released */\n\tb_free(&s->si[1].l7_buffer);\n\n\tmsg->msg_state = HTTP_MSG_BODY;\n\n\n\t/* 0: we might have to print this header in debug mode */\n\tif (unlikely((global.mode & MODE_DEBUG) &&\n\t\t     (!(global.mode & MODE_QUIET) || (global.mode & MODE_VERBOSE)))) {\n\t\tint32_t pos;\n\n\t\thttp_debug_stline(\"srvrep\", s, sl);\n\n\t\tfor (pos = htx_get_first(htx); pos != -1; pos = htx_get_next(htx, pos)) {\n\t\t\tstruct htx_blk *blk = htx_get_blk(htx, pos);\n\t\t\tenum htx_blk_type type = htx_get_blk_type(blk);\n\n\t\t\tif (type == HTX_BLK_EOH)\n\t\t\t\tbreak;\n\t\t\tif (type != HTX_BLK_HDR)\n\t\t\t\tcontinue;\n\n\t\t\thttp_debug_hdr(\"srvhdr\", s,\n\t\t\t\t       htx_get_blk_name(htx, blk),\n\t\t\t\t       htx_get_blk_value(htx, blk));\n\t\t}\n\t}\n\n\t/* 1: get the status code and the version. Also set HTTP flags */\n\ttxn->status = sl->info.res.status;\n\tif (sl->flags & HTX_SL_F_VER_11)\n                msg->flags |= HTTP_MSGF_VER_11;\n\tif (sl->flags & HTX_SL_F_XFER_LEN) {\n\t\tmsg->flags |= HTTP_MSGF_XFER_LEN;\n\t\tif (sl->flags & HTX_SL_F_CLEN)\n\t\t\tmsg->flags |= HTTP_MSGF_CNT_LEN;\n\t\telse if (sl->flags & HTX_SL_F_CHNK)\n\t\t\tmsg->flags |= HTTP_MSGF_TE_CHNK;\n\t}\n\tif (sl->flags & HTX_SL_F_BODYLESS)\n\t\tmsg->flags |= HTTP_MSGF_BODYLESS;\n\tif (sl->flags & HTX_SL_F_CONN_UPG)\n\t\tmsg->flags |= HTTP_MSGF_CONN_UPG;\n\n\tn = txn->status / 100;\n\tif (n < 1 || n > 5)\n\t\tn = 0;\n\n\t/* when the client triggers a 4xx from the server, it's most often due\n\t * to a missing object or permission. These events should be tracked\n\t * because if they happen often, it may indicate a brute force or a\n\t * vulnerability scan.\n\t */\n\tif (n == 4)\n\t\tstream_inc_http_err_ctr(s);\n\n\tif (n == 5 && txn->status != 501 && txn->status != 505)\n\t\tstream_inc_http_fail_ctr(s);\n\n\tif (objt_server(s->target)) {\n\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.p.http.rsp[n]);\n\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.p.http.cum_req);\n\t}\n\n\t/* Adjust server's health based on status code. Note: status codes 501\n\t * and 505 are triggered on demand by client request, so we must not\n\t * count them as server failures.\n\t */\n\tif (objt_server(s->target)) {\n\t\tif (txn->status >= 100 && (txn->status < 500 || txn->status == 501 || txn->status == 505))\n\t\t\thealth_adjust(__objt_server(s->target), HANA_STATUS_HTTP_OK);\n\t\telse\n\t\t\thealth_adjust(__objt_server(s->target), HANA_STATUS_HTTP_STS);\n\t}\n\n\t/*\n\t * We may be facing a 100-continue response, or any other informational\n\t * 1xx response which is non-final, in which case this is not the right\n\t * response, and we're waiting for the next one. Let's allow this response\n\t * to go to the client and wait for the next one. There's an exception for\n\t * 101 which is used later in the code to switch protocols.\n\t */\n\tif (txn->status < 200 &&\n\t    (txn->status == 100 || txn->status >= 102)) {\n\t\tFLT_STRM_CB(s, flt_http_reset(s, msg));\n\t\thtx->first = channel_htx_fwd_headers(rep, htx);\n\t\tmsg->msg_state = HTTP_MSG_RPBEFORE;\n\t\tmsg->flags = 0;\n\t\ttxn->status = 0;\n\t\ts->logs.t_data = -1; /* was not a response yet */\n\t\trep->flags |= CF_SEND_DONTWAIT; /* Send ASAP informational messages */\n\t\tgoto next_one;\n\t}\n\n\t/* A 101-switching-protocols must contains a Connection header with the\n\t * \"upgrade\" option and the request too. It means both are agree to\n\t * upgrade. It is not so strict because there is no test on the Upgrade\n\t * header content. But it is probably stronger enough for now.\n\t */\n\tif (txn->status == 101 &&\n\t    (!(txn->req.flags & HTTP_MSGF_CONN_UPG) || !(txn->rsp.flags & HTTP_MSGF_CONN_UPG)))\n\t\tgoto return_bad_res;\n\n\t/*\n\t * 2: check for cacheability.\n\t */\n\n\tswitch (txn->status) {\n\tcase 200:\n\tcase 203:\n\tcase 204:\n\tcase 206:\n\tcase 300:\n\tcase 301:\n\tcase 404:\n\tcase 405:\n\tcase 410:\n\tcase 414:\n\tcase 501:\n\t\tbreak;\n\tdefault:\n\t\t/* RFC7231#6.1:\n\t\t *   Responses with status codes that are defined as\n\t\t *   cacheable by default (e.g., 200, 203, 204, 206,\n\t\t *   300, 301, 404, 405, 410, 414, and 501 in this\n\t\t *   specification) can be reused by a cache with\n\t\t *   heuristic expiration unless otherwise indicated\n\t\t *   by the method definition or explicit cache\n\t\t *   controls [RFC7234]; all other status codes are\n\t\t *   not cacheable by default.\n\t\t */\n\t\ttxn->flags &= ~(TX_CACHEABLE | TX_CACHE_COOK);\n\t\tbreak;\n\t}\n\n\t/*\n\t * 3: we may need to capture headers\n\t */\n\ts->logs.logwait &= ~LW_RESP;\n\tif (unlikely((s->logs.logwait & LW_RSPHDR) && s->res_cap))\n\t\thttp_capture_headers(htx, s->res_cap, sess->fe->rsp_cap);\n\n\t/* Skip parsing if no content length is possible. */\n\tif (unlikely((txn->meth == HTTP_METH_CONNECT && txn->status >= 200 && txn->status < 300) ||\n\t\t     txn->status == 101)) {\n\t\t/* Either we've established an explicit tunnel, or we're\n\t\t * switching the protocol. In both cases, we're very unlikely\n\t\t * to understand the next protocols. We have to switch to tunnel\n\t\t * mode, so that we transfer the request and responses then let\n\t\t * this protocol pass unmodified. When we later implement specific\n\t\t * parsers for such protocols, we'll want to check the Upgrade\n\t\t * header which contains information about that protocol for\n\t\t * responses with status 101 (eg: see RFC2817 about TLS).\n\t\t */\n\t\ttxn->flags |= TX_CON_WANT_TUN;\n\t}\n\n\t/* check for NTML authentication headers in 401 (WWW-Authenticate) and\n\t * 407 (Proxy-Authenticate) responses and set the connection to private\n\t */\n\tsrv_conn = cs_conn(objt_cs(s->si[1].end));\n\tif (srv_conn) {\n\t\tstruct ist hdr;\n\t\tstruct http_hdr_ctx ctx;\n\n\t\tif (txn->status == 401)\n\t\t\thdr = ist(\"WWW-Authenticate\");\n\t\telse if (txn->status == 407)\n\t\t\thdr = ist(\"Proxy-Authenticate\");\n\t\telse\n\t\t\tgoto end;\n\n\t\tctx.blk = NULL;\n\t\twhile (http_find_header(htx, hdr, &ctx, 0)) {\n\t\t\t/* If www-authenticate contains \"Negotiate\", \"Nego2\", or \"NTLM\",\n\t\t\t * possibly followed by blanks and a base64 string, the connection\n\t\t\t * is private. Since it's a mess to deal with, we only check for\n\t\t\t * values starting with \"NTLM\" or \"Nego\". Note that often multiple\n\t\t\t * headers are sent by the server there.\n\t\t\t */\n\t\t\tif ((ctx.value.len >= 4 && strncasecmp(ctx.value.ptr, \"Nego\", 4) == 0) ||\n\t\t\t    (ctx.value.len >= 4 && strncasecmp(ctx.value.ptr, \"NTLM\", 4) == 0)) {\n\t\t\t\tsess->flags |= SESS_FL_PREFER_LAST;\n\t\t\t\tconn_set_owner(srv_conn, sess, NULL);\n\t\t\t\tconn_set_private(srv_conn);\n\t\t\t\t/* If it fail now, the same will be done in mux->detach() callback */\n\t\t\t\tsession_add_conn(srv_conn->owner, srv_conn, srv_conn->target);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n  end:\n\t/* we want to have the response time before we start processing it */\n\ts->logs.t_data = tv_ms_elapsed(&s->logs.tv_accept, &now);\n\n\t/* end of job, return OK */\n\trep->analysers &= ~an_bit;\n\trep->analyse_exp = TICK_ETERNITY;\n\tchannel_auto_close(rep);\n\tDBG_TRACE_LEAVE(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\treturn 1;\n\n return_int_err:\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.internal_errors);\n\t_HA_ATOMIC_INC(&s->be->be_counters.internal_errors);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->internal_errors);\n\tif (objt_server(s->target))\n\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.internal_errors);\n\ttxn->status = 500;\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_INTERNAL;\n\tgoto return_prx_cond;\n\n  return_bad_res:\n\t_HA_ATOMIC_INC(&s->be->be_counters.failed_resp);\n\tif (objt_server(s->target)) {\n\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.failed_resp);\n\t\thealth_adjust(__objt_server(s->target), HANA_STATUS_HTTP_HDRRSP);\n\t}\n\tif ((s->be->retry_type & PR_RE_JUNK_REQUEST) &&\n\t    (si_b->flags & SI_FL_L7_RETRY) &&\n\t    do_l7_retry(s, si_b) == 0) {\n\t\tDBG_TRACE_DEVEL(\"leaving on L7 retry\",\n\t\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\t\treturn 0;\n\t}\n\ttxn->status = 502;\n\tstream_inc_http_fail_ctr(s);\n\t/* fall through */\n\n return_prx_cond:\n\thttp_reply_and_close(s, txn->status, http_error_message(s));\n\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_PRXCOND;\n\tif (!(s->flags & SF_FINST_MASK))\n\t\ts->flags |= SF_FINST_H;\n\n\ts->si[1].flags |= SI_FL_NOLINGER;\n\tDBG_TRACE_DEVEL(\"leaving on error\",\n\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA|STRM_EV_HTTP_ERR, s, txn);\n\treturn 0;\n\n abort_keep_alive:\n\t/* A keep-alive request to the server failed on a network error.\n\t * The client is required to retry. We need to close without returning\n\t * any other information so that the client retries.\n\t */\n\ttxn->status = 0;\n\ts->logs.logwait = 0;\n\ts->logs.level = 0;\n\ts->res.flags &= ~CF_EXPECT_MORE; /* speed up sending a previous response */\n\thttp_reply_and_close(s, txn->status, NULL);\n\tDBG_TRACE_DEVEL(\"leaving by closing K/A connection\",\n\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\treturn 0;\n}\n\n/* This function performs all the processing enabled for the current response.\n * It normally returns 1 unless it wants to break. It relies on buffers flags,\n * and updates s->res.analysers. It might make sense to explode it into several\n * other functions. It works like process_request (see indications above).\n */\nint http_process_res_common(struct stream *s, struct channel *rep, int an_bit, struct proxy *px)\n{\n\tstruct session *sess = s->sess;\n\tstruct http_txn *txn = s->txn;\n\tstruct http_msg *msg = &txn->rsp;\n\tstruct htx *htx;\n\tstruct proxy *cur_proxy;\n\tenum rule_result ret = HTTP_RULE_RES_CONT;\n\n\tif (unlikely(msg->msg_state < HTTP_MSG_BODY))\t/* we need more data */\n\t\treturn 0;\n\n\tDBG_TRACE_ENTER(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn, msg);\n\n\thtx = htxbuf(&rep->buf);\n\n\t/* The stats applet needs to adjust the Connection header but we don't\n\t * apply any filter there.\n\t */\n\tif (unlikely(objt_applet(s->target) == &http_stats_applet)) {\n\t\trep->analysers &= ~an_bit;\n\t\trep->analyse_exp = TICK_ETERNITY;\n\t\tgoto end;\n\t}\n\n\t/*\n\t * We will have to evaluate the filters.\n\t * As opposed to version 1.2, now they will be evaluated in the\n\t * filters order and not in the header order. This means that\n\t * each filter has to be validated among all headers.\n\t *\n\t * Filters are tried with ->be first, then with ->fe if it is\n\t * different from ->be.\n\t *\n\t * Maybe we are in resume condiion. In this case I choose the\n\t * \"struct proxy\" which contains the rule list matching the resume\n\t * pointer. If none of these \"struct proxy\" match, I initialise\n\t * the process with the first one.\n\t *\n\t * In fact, I check only correspondence between the current list\n\t * pointer and the ->fe rule list. If it doesn't match, I initialize\n\t * the loop with the ->be.\n\t */\n\tif (s->current_rule_list == &sess->fe->http_res_rules ||\n\t    (sess->fe->defpx && s->current_rule_list == &sess->fe->defpx->http_res_rules))\n\t\tcur_proxy = sess->fe;\n\telse\n\t\tcur_proxy = s->be;\n\n\twhile (1) {\n\t\t/* evaluate http-response rules */\n\t\tif (ret == HTTP_RULE_RES_CONT || ret == HTTP_RULE_RES_STOP) {\n\t\t\tstruct list *def_rules, *rules;\n\n\t\t\tdef_rules = ((cur_proxy->defpx && (cur_proxy == s->be || cur_proxy->defpx != s->be->defpx)) ? &cur_proxy->defpx->http_res_rules : NULL);\n\t\t\trules = &cur_proxy->http_res_rules;\n\n\t\t\tret = http_res_get_intercept_rule(cur_proxy, def_rules, rules, s);\n\n\t\t\tswitch (ret) {\n\t\t\tcase HTTP_RULE_RES_YIELD: /* some data miss, call the function later. */\n\t\t\t\tgoto return_prx_yield;\n\n\t\t\tcase HTTP_RULE_RES_CONT:\n\t\t\tcase HTTP_RULE_RES_STOP: /* nothing to do */\n\t\t\t\tbreak;\n\n\t\t\tcase HTTP_RULE_RES_DENY: /* deny or tarpit */\n\t\t\t\tgoto deny;\n\n\t\t\tcase HTTP_RULE_RES_ABRT: /* abort request, response already sent */\n\t\t\t\tgoto return_prx_cond;\n\n\t\t\tcase HTTP_RULE_RES_DONE: /* OK, but terminate request processing (eg: redirect) */\n\t\t\t\tgoto done;\n\n\t\t\tcase HTTP_RULE_RES_BADREQ: /* failed with a bad request */\n\t\t\t\tgoto return_bad_res;\n\n\t\t\tcase HTTP_RULE_RES_ERROR: /* failed with a bad request */\n\t\t\t\tgoto return_int_err;\n\t\t\t}\n\n\t\t}\n\n\t\t/* check whether we're already working on the frontend */\n\t\tif (cur_proxy == sess->fe)\n\t\t\tbreak;\n\t\tcur_proxy = sess->fe;\n\t}\n\n\t/* OK that's all we can do for 1xx responses */\n\tif (unlikely(txn->status < 200 && txn->status != 101))\n\t\tgoto end;\n\n\t/*\n\t * Now check for a server cookie.\n\t */\n\tif (s->be->cookie_name || sess->fe->capture_name || (s->be->options & PR_O_CHK_CACHE))\n\t\thttp_manage_server_side_cookies(s, rep);\n\n\t/*\n\t * Check for cache-control or pragma headers if required.\n\t */\n\tif ((s->be->options & PR_O_CHK_CACHE) || (s->be->ck_opts & PR_CK_NOC))\n\t\thttp_check_response_for_cacheability(s, rep);\n\n\t/*\n\t * Add server cookie in the response if needed\n\t */\n\tif (objt_server(s->target) && (s->be->ck_opts & PR_CK_INS) &&\n\t    !((txn->flags & TX_SCK_FOUND) && (s->be->ck_opts & PR_CK_PSV)) &&\n\t    (!(s->flags & SF_DIRECT) ||\n\t     ((s->be->cookie_maxidle || txn->cookie_last_date) &&\n\t      (!txn->cookie_last_date || (txn->cookie_last_date - date.tv_sec) < 0)) ||\n\t     (s->be->cookie_maxlife && !txn->cookie_first_date) ||  // set the first_date\n\t     (!s->be->cookie_maxlife && txn->cookie_first_date)) && // remove the first_date\n\t    (!(s->be->ck_opts & PR_CK_POST) || (txn->meth == HTTP_METH_POST)) &&\n\t    !(s->flags & SF_IGNORE_PRST)) {\n\t\t/* the server is known, it's not the one the client requested, or the\n\t\t * cookie's last seen date needs to be refreshed. We have to\n\t\t * insert a set-cookie here, except if we want to insert only on POST\n\t\t * requests and this one isn't. Note that servers which don't have cookies\n\t\t * (eg: some backup servers) will return a full cookie removal request.\n\t\t */\n\t\tif (!__objt_server(s->target)->cookie) {\n\t\t\tchunk_printf(&trash,\n\t\t\t\t     \"%s=; Expires=Thu, 01-Jan-1970 00:00:01 GMT; path=/\",\n\t\t\t\t     s->be->cookie_name);\n\t\t}\n\t\telse {\n\t\t\tchunk_printf(&trash, \"%s=%s\", s->be->cookie_name, __objt_server(s->target)->cookie);\n\n\t\t\tif (s->be->cookie_maxidle || s->be->cookie_maxlife) {\n\t\t\t\t/* emit last_date, which is mandatory */\n\t\t\t\ttrash.area[trash.data++] = COOKIE_DELIM_DATE;\n\t\t\t\ts30tob64((date.tv_sec+3) >> 2,\n\t\t\t\t\t trash.area + trash.data);\n\t\t\t\ttrash.data += 5;\n\n\t\t\t\tif (s->be->cookie_maxlife) {\n\t\t\t\t\t/* emit first_date, which is either the original one or\n\t\t\t\t\t * the current date.\n\t\t\t\t\t */\n\t\t\t\t\ttrash.area[trash.data++] = COOKIE_DELIM_DATE;\n\t\t\t\t\ts30tob64(txn->cookie_first_date ?\n\t\t\t\t\t\t txn->cookie_first_date >> 2 :\n\t\t\t\t\t\t (date.tv_sec+3) >> 2,\n\t\t\t\t\t\t trash.area + trash.data);\n\t\t\t\t\ttrash.data += 5;\n\t\t\t\t}\n\t\t\t}\n\t\t\tchunk_appendf(&trash, \"; path=/\");\n\t\t}\n\n\t\tif (s->be->cookie_domain)\n\t\t\tchunk_appendf(&trash, \"; domain=%s\", s->be->cookie_domain);\n\n\t\tif (s->be->ck_opts & PR_CK_HTTPONLY)\n\t\t\tchunk_appendf(&trash, \"; HttpOnly\");\n\n\t\tif (s->be->ck_opts & PR_CK_SECURE)\n\t\t\tchunk_appendf(&trash, \"; Secure\");\n\n\t\tif (s->be->cookie_attrs)\n\t\t\tchunk_appendf(&trash, \"; %s\", s->be->cookie_attrs);\n\n\t\tif (unlikely(!http_add_header(htx, ist(\"Set-Cookie\"), ist2(trash.area, trash.data))))\n\t\t\tgoto return_int_err;\n\n\t\ttxn->flags &= ~TX_SCK_MASK;\n\t\tif (__objt_server(s->target)->cookie && (s->flags & SF_DIRECT))\n\t\t\t/* the server did not change, only the date was updated */\n\t\t\ttxn->flags |= TX_SCK_UPDATED;\n\t\telse\n\t\t\ttxn->flags |= TX_SCK_INSERTED;\n\n\t\t/* Here, we will tell an eventual cache on the client side that we don't\n\t\t * want it to cache this reply because HTTP/1.0 caches also cache cookies !\n\t\t * Some caches understand the correct form: 'no-cache=\"set-cookie\"', but\n\t\t * others don't (eg: apache <= 1.3.26). So we use 'private' instead.\n\t\t */\n\t\tif ((s->be->ck_opts & PR_CK_NOC) && (txn->flags & TX_CACHEABLE)) {\n\n\t\t\ttxn->flags &= ~TX_CACHEABLE & ~TX_CACHE_COOK;\n\n\t\t\tif (unlikely(!http_add_header(htx, ist(\"Cache-control\"), ist(\"private\"))))\n\t\t\t\tgoto return_int_err;\n\t\t}\n\t}\n\n\t/*\n\t * Check if result will be cacheable with a cookie.\n\t * We'll block the response if security checks have caught\n\t * nasty things such as a cacheable cookie.\n\t */\n\tif (((txn->flags & (TX_CACHEABLE | TX_CACHE_COOK | TX_SCK_PRESENT)) ==\n\t     (TX_CACHEABLE | TX_CACHE_COOK | TX_SCK_PRESENT)) &&\n\t    (s->be->options & PR_O_CHK_CACHE)) {\n\t\t/* we're in presence of a cacheable response containing\n\t\t * a set-cookie header. We'll block it as requested by\n\t\t * the 'checkcache' option, and send an alert.\n\t\t */\n\t\tha_alert(\"Blocking cacheable cookie in response from instance %s, server %s.\\n\",\n\t\t\t s->be->id, objt_server(s->target) ? __objt_server(s->target)->id : \"<dispatch>\");\n\t\tsend_log(s->be, LOG_ALERT,\n\t\t\t \"Blocking cacheable cookie in response from instance %s, server %s.\\n\",\n\t\t\t s->be->id, objt_server(s->target) ? __objt_server(s->target)->id : \"<dispatch>\");\n\t\tgoto deny;\n\t}\n\n  end:\n\t/*\n\t * Evaluate after-response rules before forwarding the response. rules\n\t * from the backend are evaluated first, then one from the frontend if\n\t * it differs.\n\t */\n\tif (!http_eval_after_res_rules(s))\n\t\tgoto return_int_err;\n\n\t/* Filter the response headers if there are filters attached to the\n\t * stream.\n\t */\n\tif (HAS_FILTERS(s))\n\t\trep->analysers |= AN_RES_FLT_HTTP_HDRS;\n\n\t/* Always enter in the body analyzer */\n\trep->analysers &= ~AN_RES_FLT_XFER_DATA;\n\trep->analysers |= AN_RES_HTTP_XFER_BODY;\n\n\t/* if the user wants to log as soon as possible, without counting\n\t * bytes from the server, then this is the right moment. We have\n\t * to temporarily assign bytes_out to log what we currently have.\n\t */\n\tif (!LIST_ISEMPTY(&sess->fe->logformat) && !(s->logs.logwait & LW_BYTES)) {\n\t\ts->logs.t_close = s->logs.t_data; /* to get a valid end date */\n\t\ts->logs.bytes_out = htx->data;\n\t\ts->do_log(s);\n\t\ts->logs.bytes_out = 0;\n\t}\n\n done:\n\tDBG_TRACE_LEAVE(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\trep->analysers &= ~an_bit;\n\trep->analyse_exp = TICK_ETERNITY;\n\ts->current_rule = s->current_rule_list = NULL;\n\treturn 1;\n\n deny:\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.denied_resp);\n\t_HA_ATOMIC_INC(&s->be->be_counters.denied_resp);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->denied_resp);\n\tif (objt_server(s->target))\n\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.denied_resp);\n\tgoto return_prx_err;\n\n return_int_err:\n\ttxn->status = 500;\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_INTERNAL;\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.internal_errors);\n\t_HA_ATOMIC_INC(&s->be->be_counters.internal_errors);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->internal_errors);\n\tif (objt_server(s->target))\n\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.internal_errors);\n\tgoto return_prx_err;\n\n return_bad_res:\n\ttxn->status = 502;\n\tstream_inc_http_fail_ctr(s);\n\t_HA_ATOMIC_INC(&s->be->be_counters.failed_resp);\n\tif (objt_server(s->target)) {\n\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.failed_resp);\n\t\thealth_adjust(__objt_server(s->target), HANA_STATUS_HTTP_RSP);\n\t}\n\t/* fall through */\n\n return_prx_err:\n\thttp_reply_and_close(s, txn->status, http_error_message(s));\n\t/* fall through */\n\n return_prx_cond:\n\ts->logs.t_data = -1; /* was not a valid response */\n\ts->si[1].flags |= SI_FL_NOLINGER;\n\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_PRXCOND;\n\tif (!(s->flags & SF_FINST_MASK))\n\t\ts->flags |= SF_FINST_H;\n\n\trep->analysers &= AN_RES_FLT_END;\n\ts->req.analysers &= AN_REQ_FLT_END;\n\trep->analyse_exp = TICK_ETERNITY;\n\ts->current_rule = s->current_rule_list = NULL;\n\tDBG_TRACE_DEVEL(\"leaving on error\",\n\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA|STRM_EV_HTTP_ERR, s, txn);\n\treturn 0;\n\n return_prx_yield:\n\tchannel_dont_close(rep);\n\tDBG_TRACE_DEVEL(\"waiting for more data\",\n\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\treturn 0;\n}\n\n/* This function is an analyser which forwards response body (including chunk\n * sizes if any). It is called as soon as we must forward, even if we forward\n * zero byte. The only situation where it must not be called is when we're in\n * tunnel mode and we want to forward till the close. It's used both to forward\n * remaining data and to resync after end of body. It expects the msg_state to\n * be between MSG_BODY and MSG_DONE (inclusive). It returns zero if it needs to\n * read more data, or 1 once we can go on with next request or end the stream.\n *\n * It is capable of compressing response data both in content-length mode and\n * in chunked mode. The state machines follows different flows depending on\n * whether content-length and chunked modes are used, since there are no\n * trailers in content-length :\n *\n *       chk-mode        cl-mode\n *          ,----- BODY -----.\n *         /                  \\\n *        V     size > 0       V    chk-mode\n *  .--> SIZE -------------> DATA -------------> CRLF\n *  |     | size == 0          | last byte         |\n *  |     v      final crlf    v inspected         |\n *  |  TRAILERS -----------> DONE                  |\n *  |                                              |\n *  `----------------------------------------------'\n *\n * Compression only happens in the DATA state, and must be flushed in final\n * states (TRAILERS/DONE) or when leaving on missing data. Normal forwarding\n * is performed at once on final states for all bytes parsed, or when leaving\n * on missing data.\n */\nint http_response_forward_body(struct stream *s, struct channel *res, int an_bit)\n{\n\tstruct session *sess = s->sess;\n\tstruct http_txn *txn = s->txn;\n\tstruct http_msg *msg = &s->txn->rsp;\n\tstruct htx *htx;\n\tint ret;\n\n\tDBG_TRACE_ENTER(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn, msg);\n\n\thtx = htxbuf(&res->buf);\n\n\tif (htx->flags & HTX_FL_PARSING_ERROR)\n\t\tgoto return_bad_res;\n\tif (htx->flags & HTX_FL_PROCESSING_ERROR)\n\t\tgoto return_int_err;\n\n\tif ((res->flags & (CF_READ_ERROR|CF_READ_TIMEOUT|CF_WRITE_ERROR|CF_WRITE_TIMEOUT)) ||\n\t    ((res->flags & CF_SHUTW) && (res->to_forward || co_data(res)))) {\n\t\t/* Output closed while we were sending data. We must abort and\n\t\t * wake the other side up.\n\t\t */\n\t\tmsg->msg_state = HTTP_MSG_ERROR;\n\t\thttp_end_response(s);\n\t\thttp_end_request(s);\n\t\tDBG_TRACE_DEVEL(\"leaving on error\",\n\t\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA|STRM_EV_HTTP_ERR, s, txn);\n\t\treturn 1;\n\t}\n\n\tif (msg->msg_state == HTTP_MSG_BODY)\n\t\tmsg->msg_state = HTTP_MSG_DATA;\n\n\t/* in most states, we should abort in case of early close */\n\tchannel_auto_close(res);\n\n\tif (res->to_forward) {\n\t\tif (res->to_forward == CHN_INFINITE_FORWARD) {\n\t\t\tif (res->flags & CF_EOI)\n\t\t\t\tmsg->msg_state = HTTP_MSG_ENDING;\n\t\t}\n\t\telse {\n\t\t\t/* We can't process the buffer's contents yet */\n\t\t\tres->flags |= CF_WAKE_WRITE;\n\t\t\tgoto missing_data_or_waiting;\n\t\t}\n\t}\n\n\tif (msg->msg_state >= HTTP_MSG_ENDING)\n\t\tgoto ending;\n\n\tif ((txn->meth == HTTP_METH_CONNECT && txn->status >= 200 && txn->status < 300) || txn->status == 101 ||\n\t    (!(msg->flags & HTTP_MSGF_XFER_LEN) && !HAS_RSP_DATA_FILTERS(s))) {\n\t\tmsg->msg_state = HTTP_MSG_ENDING;\n\t\tgoto ending;\n\t}\n\n\t/* Forward input data. We get it by removing all outgoing data not\n\t * forwarded yet from HTX data size. If there are some data filters, we\n\t * let them decide the amount of data to forward.\n\t */\n\tif (HAS_RSP_DATA_FILTERS(s)) {\n\t\tret  = flt_http_payload(s, msg, htx->data);\n\t\tif (ret < 0)\n\t\t\tgoto return_bad_res;\n\t\tc_adv(res, ret);\n\t}\n\telse {\n\t\tc_adv(res, htx->data - co_data(res));\n\t\tif (msg->flags & HTTP_MSGF_XFER_LEN)\n\t\t\tchannel_htx_forward_forever(res, htx);\n\t}\n\n\tif (htx->data != co_data(res))\n\t\tgoto missing_data_or_waiting;\n\n\tif (!(msg->flags & HTTP_MSGF_XFER_LEN) && res->flags & CF_SHUTR) {\n\t\tmsg->msg_state = HTTP_MSG_ENDING;\n\t\tgoto ending;\n\t}\n\n\t/* Check if the end-of-message is reached and if so, switch the message\n\t * in HTTP_MSG_ENDING state. Then if all data was marked to be\n\t * forwarded, set the state to HTTP_MSG_DONE.\n\t */\n\tif (!(htx->flags & HTX_FL_EOM))\n\t\tgoto missing_data_or_waiting;\n\n\tmsg->msg_state = HTTP_MSG_ENDING;\n\n  ending:\n\tres->flags &= ~CF_EXPECT_MORE; /* no more data are expected */\n\n\t/* other states, ENDING...TUNNEL */\n\tif (msg->msg_state >= HTTP_MSG_DONE)\n\t\tgoto done;\n\n\tif (HAS_RSP_DATA_FILTERS(s)) {\n\t\tret = flt_http_end(s, msg);\n\t\tif (ret <= 0) {\n\t\t\tif (!ret)\n\t\t\t\tgoto missing_data_or_waiting;\n\t\t\tgoto return_bad_res;\n\t\t}\n\t}\n\n\tif ((txn->meth == HTTP_METH_CONNECT && txn->status >= 200 && txn->status < 300) || txn->status == 101 ||\n\t    !(msg->flags & HTTP_MSGF_XFER_LEN)) {\n\t\tmsg->msg_state = HTTP_MSG_TUNNEL;\n\t\tgoto ending;\n\t}\n\telse {\n\t\tmsg->msg_state = HTTP_MSG_DONE;\n\t\tres->to_forward = 0;\n\t}\n\n  done:\n\n\tchannel_dont_close(res);\n\n\thttp_end_response(s);\n\tif (!(res->analysers & an_bit)) {\n\t\thttp_end_request(s);\n\t\tif (unlikely(msg->msg_state == HTTP_MSG_ERROR)) {\n\t\t\tif (res->flags & CF_SHUTW) {\n\t\t\t\t/* response errors are most likely due to the\n\t\t\t\t * client aborting the transfer. */\n\t\t\t\tgoto return_cli_abort;\n\t\t\t}\n\t\t\tgoto return_bad_res;\n\t\t}\n\t\tDBG_TRACE_LEAVE(STRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\t\treturn 1;\n\t}\n\tDBG_TRACE_DEVEL(\"waiting for the end of the HTTP txn\",\n\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\treturn 0;\n\n  missing_data_or_waiting:\n\tif (res->flags & CF_SHUTW)\n\t\tgoto return_cli_abort;\n\n\t/* stop waiting for data if the input is closed before the end. If the\n\t * client side was already closed, it means that the client has aborted,\n\t * so we don't want to count this as a server abort. Otherwise it's a\n\t * server abort.\n\t */\n\tif (msg->msg_state < HTTP_MSG_ENDING && res->flags & CF_SHUTR) {\n\t\tif ((s->req.flags & (CF_SHUTR|CF_SHUTW)) == (CF_SHUTR|CF_SHUTW))\n\t\t\tgoto return_cli_abort;\n\t\t/* If we have some pending data, we continue the processing */\n\t\tif (htx_is_empty(htx))\n\t\t\tgoto return_srv_abort;\n\t}\n\n\t/* When TE: chunked is used, we need to get there again to parse\n\t * remaining chunks even if the server has closed, so we don't want to\n\t * set CF_DONTCLOSE. Similarly when there is a content-leng or if there\n\t * are filters registered on the stream, we don't want to forward a\n\t * close\n\t */\n\tif ((msg->flags & HTTP_MSGF_XFER_LEN) || HAS_RSP_DATA_FILTERS(s))\n\t\tchannel_dont_close(res);\n\n\t/* We know that more data are expected, but we couldn't send more that\n\t * what we did. So we always set the CF_EXPECT_MORE flag so that the\n\t * system knows it must not set a PUSH on this first part. Interactive\n\t * modes are already handled by the stream sock layer. We must not do\n\t * this in content-length mode because it could present the MSG_MORE\n\t * flag with the last block of forwarded data, which would cause an\n\t * additional delay to be observed by the receiver.\n\t */\n\tif (HAS_RSP_DATA_FILTERS(s))\n\t\tres->flags |= CF_EXPECT_MORE;\n\n\t/* the stream handler will take care of timeouts and errors */\n\tDBG_TRACE_DEVEL(\"waiting for more data to forward\",\n\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA, s, txn);\n\treturn 0;\n\n  return_srv_abort:\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.srv_aborts);\n\t_HA_ATOMIC_INC(&s->be->be_counters.srv_aborts);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->srv_aborts);\n\tif (objt_server(s->target))\n\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.srv_aborts);\n\tstream_inc_http_fail_ctr(s);\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_SRVCL;\n\tgoto return_error;\n\n  return_cli_abort:\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.cli_aborts);\n\t_HA_ATOMIC_INC(&s->be->be_counters.cli_aborts);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->cli_aborts);\n\tif (objt_server(s->target))\n\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.cli_aborts);\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_CLICL;\n\tgoto return_error;\n\n  return_int_err:\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.internal_errors);\n\t_HA_ATOMIC_INC(&s->be->be_counters.internal_errors);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->internal_errors);\n\tif (objt_server(s->target))\n\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.internal_errors);\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_INTERNAL;\n\tgoto return_error;\n\n  return_bad_res:\n\t_HA_ATOMIC_INC(&s->be->be_counters.failed_resp);\n\tif (objt_server(s->target)) {\n\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.failed_resp);\n\t\thealth_adjust(__objt_server(s->target), HANA_STATUS_HTTP_RSP);\n\t}\n\tstream_inc_http_fail_ctr(s);\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_SRVCL;\n\t/* fall through */\n\n   return_error:\n\t/* don't send any error message as we're in the body */\n\thttp_reply_and_close(s, txn->status, NULL);\n\tif (!(s->flags & SF_FINST_MASK))\n\t\ts->flags |= SF_FINST_D;\n\tDBG_TRACE_DEVEL(\"leaving on error\",\n\t\t\tSTRM_EV_STRM_ANA|STRM_EV_HTTP_ANA|STRM_EV_HTTP_ERR, s, txn);\n\treturn 0;\n}\n\n/* Perform an HTTP redirect based on the information in <rule>. The function\n * returns zero in case of an irrecoverable error such as too large a request\n * to build a valid response, 1 in case of successful redirect (hence the rule\n * is final), or 2 if the rule has to be silently skipped.\n */\nint http_apply_redirect_rule(struct redirect_rule *rule, struct stream *s, struct http_txn *txn)\n{\n\tstruct channel *req = &s->req;\n\tstruct channel *res = &s->res;\n\tstruct htx *htx;\n\tstruct htx_sl *sl;\n\tstruct buffer *chunk;\n\tstruct ist status, reason, location;\n\tunsigned int flags;\n\tint close = 0; /* Try to keep the connection alive byt default */\n\n\tchunk = alloc_trash_chunk();\n\tif (!chunk) {\n\t\tif (!(s->flags & SF_ERR_MASK))\n\t\t\ts->flags |= SF_ERR_RESOURCE;\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * Create the location\n\t */\n\thtx = htxbuf(&req->buf);\n\tswitch(rule->type) {\n\t\tcase REDIRECT_TYPE_SCHEME: {\n\t\t\tstruct http_hdr_ctx ctx;\n\t\t\tstruct ist path, host;\n\t\t\tstruct http_uri_parser parser;\n\n\t\t\thost = ist(\"\");\n\t\t\tctx.blk = NULL;\n\t\t\tif (http_find_header(htx, ist(\"Host\"), &ctx, 0))\n\t\t\t\thost = ctx.value;\n\n\t\t\tsl = http_get_stline(htx);\n\t\t\tparser = http_uri_parser_init(htx_sl_req_uri(sl));\n\t\t\tpath = http_parse_path(&parser);\n\t\t\t/* build message using path */\n\t\t\tif (isttest(path)) {\n\t\t\t\tif (rule->flags & REDIRECT_FLAG_DROP_QS) {\n\t\t\t\t\tint qs = 0;\n\t\t\t\t\twhile (qs < path.len) {\n\t\t\t\t\t\tif (*(path.ptr + qs) == '?') {\n\t\t\t\t\t\t\tpath.len = qs;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqs++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tpath = ist(\"/\");\n\n\t\t\tif (rule->rdr_str) { /* this is an old \"redirect\" rule */\n\t\t\t\t/* add scheme */\n\t\t\t\tif (!chunk_memcat(chunk, rule->rdr_str, rule->rdr_len))\n\t\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* add scheme with executing log format */\n\t\t\t\tchunk->data += build_logline(s, chunk->area + chunk->data,\n\t\t\t\t\t\t\t     chunk->size - chunk->data,\n\t\t\t\t\t\t\t     &rule->rdr_fmt);\n\t\t\t}\n\t\t\t/* add \"://\" + host + path */\n\t\t\tif (!chunk_memcat(chunk, \"://\", 3) ||\n\t\t\t    !chunk_memcat(chunk, host.ptr, host.len) ||\n\t\t\t    !chunk_memcat(chunk, path.ptr, path.len))\n\t\t\t\tgoto fail;\n\n\t\t\t/* append a slash at the end of the location if needed and missing */\n\t\t\tif (chunk->data && chunk->area[chunk->data - 1] != '/' &&\n\t\t\t    (rule->flags & REDIRECT_FLAG_APPEND_SLASH)) {\n\t\t\t\tif (chunk->data + 1 >= chunk->size)\n\t\t\t\t\tgoto fail;\n\t\t\t\tchunk->area[chunk->data++] = '/';\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase REDIRECT_TYPE_PREFIX: {\n\t\t\tstruct ist path;\n\t\t\tstruct http_uri_parser parser;\n\n\t\t\tsl = http_get_stline(htx);\n\t\t\tparser = http_uri_parser_init(htx_sl_req_uri(sl));\n\t\t\tpath = http_parse_path(&parser);\n\t\t\t/* build message using path */\n\t\t\tif (isttest(path)) {\n\t\t\t\tif (rule->flags & REDIRECT_FLAG_DROP_QS) {\n\t\t\t\t\tint qs = 0;\n\t\t\t\t\twhile (qs < path.len) {\n\t\t\t\t\t\tif (*(path.ptr + qs) == '?') {\n\t\t\t\t\t\t\tpath.len = qs;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqs++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tpath = ist(\"/\");\n\n\t\t\tif (rule->rdr_str) { /* this is an old \"redirect\" rule */\n\t\t\t\t/* add prefix. Note that if prefix == \"/\", we don't want to\n\t\t\t\t * add anything, otherwise it makes it hard for the user to\n\t\t\t\t * configure a self-redirection.\n\t\t\t\t */\n\t\t\t\tif (rule->rdr_len != 1 || *rule->rdr_str != '/') {\n\t\t\t\t\tif (!chunk_memcat(chunk, rule->rdr_str, rule->rdr_len))\n\t\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* add prefix with executing log format */\n\t\t\t\tchunk->data += build_logline(s, chunk->area + chunk->data,\n\t\t\t\t\t\t\t     chunk->size - chunk->data,\n\t\t\t\t\t\t\t     &rule->rdr_fmt);\n\t\t\t}\n\n\t\t\t/* add path */\n\t\t\tif (!chunk_memcat(chunk, path.ptr, path.len))\n\t\t\t\tgoto fail;\n\n\t\t\t/* append a slash at the end of the location if needed and missing */\n\t\t\tif (chunk->data && chunk->area[chunk->data - 1] != '/' &&\n\t\t\t    (rule->flags & REDIRECT_FLAG_APPEND_SLASH)) {\n\t\t\t\tif (chunk->data + 1 >= chunk->size)\n\t\t\t\t\tgoto fail;\n\t\t\t\tchunk->area[chunk->data++] = '/';\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase REDIRECT_TYPE_LOCATION:\n\t\tdefault:\n\t\t\tif (rule->rdr_str) { /* this is an old \"redirect\" rule */\n\t\t\t\t/* add location */\n\t\t\t\tif (!chunk_memcat(chunk, rule->rdr_str, rule->rdr_len))\n\t\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* add location with executing log format */\n\t\t\t\tint len = build_logline(s, chunk->area + chunk->data,\n\t\t\t\t                        chunk->size - chunk->data,\n\t\t\t\t                        &rule->rdr_fmt);\n\t\t\t\tif (!len && rule->flags & REDIRECT_FLAG_IGNORE_EMPTY)\n\t\t\t\t\treturn 2;\n\n\t\t\t\tchunk->data += len;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\tlocation = ist2(chunk->area, chunk->data);\n\n\t/*\n\t * Create the 30x response\n\t */\n\tswitch (rule->code) {\n\t\tcase 308:\n\t\t\tstatus = ist(\"308\");\n\t\t\treason = ist(\"Permanent Redirect\");\n\t\t\tbreak;\n\t\tcase 307:\n\t\t\tstatus = ist(\"307\");\n\t\t\treason = ist(\"Temporary Redirect\");\n\t\t\tbreak;\n\t\tcase 303:\n\t\t\tstatus = ist(\"303\");\n\t\t\treason = ist(\"See Other\");\n\t\t\tbreak;\n\t\tcase 301:\n\t\t\tstatus = ist(\"301\");\n\t\t\treason = ist(\"Moved Permanently\");\n\t\t\tbreak;\n\t\tcase 302:\n\t\tdefault:\n\t\t\tstatus = ist(\"302\");\n\t\t\treason = ist(\"Found\");\n\t\t\tbreak;\n\t}\n\n\tif (!(txn->req.flags & HTTP_MSGF_BODYLESS) && txn->req.msg_state != HTTP_MSG_DONE)\n\t\tclose = 1;\n\n\thtx = htx_from_buf(&res->buf);\n\t/* Trim any possible response */\n\tchannel_htx_truncate(&s->res, htx);\n\tflags = (HTX_SL_F_IS_RESP|HTX_SL_F_VER_11|HTX_SL_F_XFER_LEN|HTX_SL_F_BODYLESS);\n\tsl = htx_add_stline(htx, HTX_BLK_RES_SL, flags, ist(\"HTTP/1.1\"), status, reason);\n\tif (!sl)\n\t\tgoto fail;\n\tsl->info.res.status = rule->code;\n\ts->txn->status = rule->code;\n\n\tif (close && !htx_add_header(htx, ist(\"Connection\"), ist(\"close\")))\n\t\tgoto fail;\n\n\tif (!htx_add_header(htx, ist(\"Content-length\"), ist(\"0\")) ||\n\t    !htx_add_header(htx, ist(\"Location\"), location))\n\t\tgoto fail;\n\n\tif (rule->code == 302 || rule->code == 303 || rule->code == 307) {\n\t\tif (!htx_add_header(htx, ist(\"Cache-Control\"), ist(\"no-cache\")))\n\t\t\tgoto fail;\n\t}\n\n\tif (rule->cookie_len) {\n\t\tif (!htx_add_header(htx, ist(\"Set-Cookie\"), ist2(rule->cookie_str, rule->cookie_len)))\n\t\t\tgoto fail;\n\t}\n\n\tif (!htx_add_endof(htx, HTX_BLK_EOH))\n\t\tgoto fail;\n\n\thtx->flags |= HTX_FL_EOM;\n\thtx_to_buf(htx, &res->buf);\n\tif (!http_forward_proxy_resp(s, 1))\n\t\tgoto fail;\n\n\tif (rule->flags & REDIRECT_FLAG_FROM_REQ) {\n\t\t/* let's log the request time */\n\t\ts->logs.tv_request = now;\n\t\treq->analysers &= AN_REQ_FLT_END;\n\n\t\tif (s->sess->fe == s->be) /* report it if the request was intercepted by the frontend */\n\t\t\t_HA_ATOMIC_INC(&s->sess->fe->fe_counters.intercepted_req);\n\t}\n\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_LOCAL;\n\tif (!(s->flags & SF_FINST_MASK))\n\t\ts->flags |= ((rule->flags & REDIRECT_FLAG_FROM_REQ) ? SF_FINST_R : SF_FINST_H);\n\n\tfree_trash_chunk(chunk);\n\treturn 1;\n\n  fail:\n\t/* If an error occurred, remove the incomplete HTTP response from the\n\t * buffer */\n\tchannel_htx_truncate(res, htxbuf(&res->buf));\n\tfree_trash_chunk(chunk);\n\treturn 0;\n}\n\n/* Replace all headers matching the name <name>. The header value is replaced if\n * it matches the regex <re>. <str> is used for the replacement. If <full> is\n * set to 1, the full-line is matched and replaced. Otherwise, comma-separated\n * values are evaluated one by one. It returns 0 on success and -1 on error.\n */\nint http_replace_hdrs(struct stream* s, struct htx *htx, struct ist name,\n\t\t     const char *str, struct my_regex *re, int full)\n{\n\tstruct http_hdr_ctx ctx;\n\tstruct buffer *output = get_trash_chunk();\n\n\tctx.blk = NULL;\n\twhile (http_find_header(htx, name, &ctx, full)) {\n\t\tif (!regex_exec_match2(re, ctx.value.ptr, ctx.value.len, MAX_MATCH, pmatch, 0))\n\t\t\tcontinue;\n\n\t\toutput->data = exp_replace(output->area, output->size, ctx.value.ptr, str, pmatch);\n\t\tif (output->data == -1)\n\t\t\treturn -1;\n\t\tif (!http_replace_header_value(htx, &ctx, ist2(output->area, output->data)))\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/* This function executes one of the set-{method,path,query,uri} actions. It\n * takes the string from the variable 'replace' with length 'len', then modifies\n * the relevant part of the request line accordingly. Then it updates various\n * pointers to the next elements which were moved, and the total buffer length.\n * It finds the action to be performed in p[2], previously filled by function\n * parse_set_req_line(). It returns 0 in case of success, -1 in case of internal\n * error, though this can be revisited when this code is finally exploited.\n *\n * 'action' can be '0' to replace method, '1' to replace path, '2' to replace\n * query string, 3 to replace uri or 4 to replace the path+query.\n *\n * In query string case, the mark question '?' must be set at the start of the\n * string by the caller, event if the replacement query string is empty.\n */\nint http_req_replace_stline(int action, const char *replace, int len,\n\t\t\t    struct proxy *px, struct stream *s)\n{\n\tstruct htx *htx = htxbuf(&s->req.buf);\n\n\tswitch (action) {\n\t\tcase 0: // method\n\t\t\tif (!http_replace_req_meth(htx, ist2(replace, len)))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase 1: // path\n\t\t\tif (!http_replace_req_path(htx, ist2(replace, len), 0))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase 2: // query\n\t\t\tif (!http_replace_req_query(htx, ist2(replace, len)))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase 3: // uri\n\t\t\tif (!http_replace_req_uri(htx, ist2(replace, len)))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase 4: // path + query\n\t\t\tif (!http_replace_req_path(htx, ist2(replace, len), 1))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/* This function replace the HTTP status code and the associated message. The\n * variable <status> contains the new status code. This function never fails. It\n * returns 0 in case of success, -1 in case of internal error.\n */\nint http_res_set_status(unsigned int status, struct ist reason, struct stream *s)\n{\n\tstruct htx *htx = htxbuf(&s->res.buf);\n\tchar *res;\n\n\tchunk_reset(&trash);\n\tres = ultoa_o(status, trash.area, trash.size);\n\ttrash.data = res - trash.area;\n\n\t/* Do we have a custom reason format string? */\n\tif (!isttest(reason)) {\n\t\tconst char *str = http_get_reason(status);\n\t\treason = ist(str);\n\t}\n\n\tif (!http_replace_res_status(htx, ist2(trash.area, trash.data), reason))\n\t\treturn -1;\n\treturn 0;\n}\n\n/* Executes the http-request rules <rules> for stream <s>, proxy <px> and\n * transaction <txn>. Returns the verdict of the first rule that prevents\n * further processing of the request (auth, deny, ...), and defaults to\n * HTTP_RULE_RES_STOP if it executed all rules or stopped on an allow, or\n * HTTP_RULE_RES_CONT if the last rule was reached. It may set the TX_CLTARPIT\n * on txn->flags if it encounters a tarpit rule. If <deny_status> is not NULL\n * and a deny/tarpit rule is matched, it will be filled with this rule's deny\n * status.\n */\nstatic enum rule_result http_req_get_intercept_rule(struct proxy *px, struct list *def_rules,\n\t\t\t\t\t\t    struct list *rules, struct stream *s)\n{\n\tstruct session *sess = strm_sess(s);\n\tstruct http_txn *txn = s->txn;\n\tstruct act_rule *rule;\n\tenum rule_result rule_ret = HTTP_RULE_RES_CONT;\n\tint act_opts = 0;\n\n\t/* If \"the current_rule_list\" match the executed rule list, we are in\n\t * resume condition. If a resume is needed it is always in the action\n\t * and never in the ACL or converters. In this case, we initialise the\n\t * current rule, and go to the action execution point.\n\t */\n\tif (s->current_rule) {\n\t\trule = s->current_rule;\n\t\ts->current_rule = NULL;\n\t\tif (s->current_rule_list == rules || (def_rules && s->current_rule_list == def_rules))\n\t\t\tgoto resume_execution;\n\t}\n\ts->current_rule_list = ((!def_rules || s->current_rule_list == def_rules) ? rules : def_rules);\n\n  restart:\n\t/* start the ruleset evaluation in strict mode */\n\ttxn->req.flags &= ~HTTP_MSGF_SOFT_RW;\n\n\tlist_for_each_entry(rule, s->current_rule_list, list) {\n\t\t/* check optional condition */\n\t\tif (rule->cond) {\n\t\t\tint ret;\n\n\t\t\tret = acl_exec_cond(rule->cond, px, sess, s, SMP_OPT_DIR_REQ|SMP_OPT_FINAL);\n\t\t\tret = acl_pass(ret);\n\n\t\t\tif (rule->cond->pol == ACL_COND_UNLESS)\n\t\t\t\tret = !ret;\n\n\t\t\tif (!ret) /* condition not matched */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tact_opts |= ACT_OPT_FIRST;\n  resume_execution:\n\t\tif (rule->kw->flags & KWF_EXPERIMENTAL)\n\t\t\tmark_tainted(TAINTED_ACTION_EXP_EXECUTED);\n\n\t\t/* Always call the action function if defined */\n\t\tif (rule->action_ptr) {\n\t\t\tif ((s->req.flags & CF_READ_ERROR) ||\n\t\t\t    ((s->req.flags & (CF_SHUTR|CF_READ_NULL)) &&\n\t\t\t     (px->options & PR_O_ABRT_CLOSE)))\n\t\t\t\tact_opts |= ACT_OPT_FINAL;\n\n\t\t\tswitch (rule->action_ptr(rule, px, sess, s, act_opts)) {\n\t\t\t\tcase ACT_RET_CONT:\n\t\t\t\t\tbreak;\n\t\t\t\tcase ACT_RET_STOP:\n\t\t\t\t\trule_ret = HTTP_RULE_RES_STOP;\n\t\t\t\t\tgoto end;\n\t\t\t\tcase ACT_RET_YIELD:\n\t\t\t\t\ts->current_rule = rule;\n\t\t\t\t\trule_ret = HTTP_RULE_RES_YIELD;\n\t\t\t\t\tgoto end;\n\t\t\t\tcase ACT_RET_ERR:\n\t\t\t\t\trule_ret = HTTP_RULE_RES_ERROR;\n\t\t\t\t\tgoto end;\n\t\t\t\tcase ACT_RET_DONE:\n\t\t\t\t\trule_ret = HTTP_RULE_RES_DONE;\n\t\t\t\t\tgoto end;\n\t\t\t\tcase ACT_RET_DENY:\n\t\t\t\t\tif (txn->status == -1)\n\t\t\t\t\t\ttxn->status = 403;\n\t\t\t\t\trule_ret = HTTP_RULE_RES_DENY;\n\t\t\t\t\tgoto end;\n\t\t\t\tcase ACT_RET_ABRT:\n\t\t\t\t\trule_ret = HTTP_RULE_RES_ABRT;\n\t\t\t\t\tgoto end;\n\t\t\t\tcase ACT_RET_INV:\n\t\t\t\t\trule_ret = HTTP_RULE_RES_BADREQ;\n\t\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tcontinue; /* eval the next rule */\n\t\t}\n\n\t\t/* If not action function defined, check for known actions */\n\t\tswitch (rule->action) {\n\t\t\tcase ACT_ACTION_ALLOW:\n\t\t\t\trule_ret = HTTP_RULE_RES_STOP;\n\t\t\t\tgoto end;\n\n\t\t\tcase ACT_ACTION_DENY:\n\t\t\t\ttxn->status = rule->arg.http_reply->status;\n\t\t\t\ttxn->http_reply = rule->arg.http_reply;\n\t\t\t\trule_ret = HTTP_RULE_RES_DENY;\n\t\t\t\tgoto end;\n\n\t\t\tcase ACT_HTTP_REQ_TARPIT:\n\t\t\t\ttxn->flags |= TX_CLTARPIT;\n\t\t\t\ttxn->status = rule->arg.http_reply->status;\n\t\t\t\ttxn->http_reply = rule->arg.http_reply;\n\t\t\t\trule_ret = HTTP_RULE_RES_DENY;\n\t\t\t\tgoto end;\n\n\t\t\tcase ACT_HTTP_REDIR: {\n\t\t\t\tint ret = http_apply_redirect_rule(rule->arg.redir, s, txn);\n\n\t\t\t\tif (ret == 2) // 2 == skip\n\t\t\t\t\tbreak;\n\n\t\t\t\trule_ret = ret ? HTTP_RULE_RES_ABRT : HTTP_RULE_RES_ERROR;\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\t/* other flags exists, but normally, they never be matched. */\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (def_rules && s->current_rule_list == def_rules) {\n\t\ts->current_rule_list = rules;\n\t\tgoto restart;\n\t}\n\n  end:\n\t/* if the ruleset evaluation is finished reset the strict mode */\n\tif (rule_ret != HTTP_RULE_RES_YIELD)\n\t\ttxn->req.flags &= ~HTTP_MSGF_SOFT_RW;\n\n\t/* we reached the end of the rules, nothing to report */\n\treturn rule_ret;\n}\n\n/* Executes the http-response rules <rules> for stream <s> and proxy <px>. It\n * returns one of 5 possible statuses: HTTP_RULE_RES_CONT, HTTP_RULE_RES_STOP,\n * HTTP_RULE_RES_DONE, HTTP_RULE_RES_YIELD, or HTTP_RULE_RES_BADREQ. If *CONT\n * is returned, the process can continue the evaluation of next rule list. If\n * *STOP or *DONE is returned, the process must stop the evaluation. If *BADREQ\n * is returned, it means the operation could not be processed and a server error\n * must be returned. If *YIELD is returned, the caller must call again the\n * function with the same context.\n */\nstatic enum rule_result http_res_get_intercept_rule(struct proxy *px, struct list *def_rules,\n\t\t\t\t\t\t    struct list *rules, struct stream *s)\n{\n\tstruct session *sess = strm_sess(s);\n\tstruct http_txn *txn = s->txn;\n\tstruct act_rule *rule;\n\tenum rule_result rule_ret = HTTP_RULE_RES_CONT;\n\tint act_opts = 0;\n\n\t/* If \"the current_rule_list\" match the executed rule list, we are in\n\t * resume condition. If a resume is needed it is always in the action\n\t * and never in the ACL or converters. In this case, we initialise the\n\t * current rule, and go to the action execution point.\n\t */\n\tif (s->current_rule) {\n\t\trule = s->current_rule;\n\t\ts->current_rule = NULL;\n\t\tif (s->current_rule_list == rules || (def_rules && s->current_rule_list == def_rules))\n\t\t\tgoto resume_execution;\n\t}\n\ts->current_rule_list = ((!def_rules || s->current_rule_list == def_rules) ? rules : def_rules);\n\n  restart:\n\n\t/* start the ruleset evaluation in strict mode */\n\ttxn->rsp.flags &= ~HTTP_MSGF_SOFT_RW;\n\n\tlist_for_each_entry(rule, s->current_rule_list, list) {\n\t\t/* check optional condition */\n\t\tif (rule->cond) {\n\t\t\tint ret;\n\n\t\t\tret = acl_exec_cond(rule->cond, px, sess, s, SMP_OPT_DIR_RES|SMP_OPT_FINAL);\n\t\t\tret = acl_pass(ret);\n\n\t\t\tif (rule->cond->pol == ACL_COND_UNLESS)\n\t\t\t\tret = !ret;\n\n\t\t\tif (!ret) /* condition not matched */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tact_opts |= ACT_OPT_FIRST;\nresume_execution:\n\t\tif (rule->kw->flags & KWF_EXPERIMENTAL)\n\t\t\tmark_tainted(TAINTED_ACTION_EXP_EXECUTED);\n\n\t\t/* Always call the action function if defined */\n\t\tif (rule->action_ptr) {\n\t\t\tif ((s->req.flags & CF_READ_ERROR) ||\n\t\t\t    ((s->req.flags & (CF_SHUTR|CF_READ_NULL)) &&\n\t\t\t     (px->options & PR_O_ABRT_CLOSE)))\n\t\t\t\tact_opts |= ACT_OPT_FINAL;\n\n\t\t\tswitch (rule->action_ptr(rule, px, sess, s, act_opts)) {\n\t\t\t\tcase ACT_RET_CONT:\n\t\t\t\t\tbreak;\n\t\t\t\tcase ACT_RET_STOP:\n\t\t\t\t\trule_ret = HTTP_RULE_RES_STOP;\n\t\t\t\t\tgoto end;\n\t\t\t\tcase ACT_RET_YIELD:\n\t\t\t\t\ts->current_rule = rule;\n\t\t\t\t\trule_ret = HTTP_RULE_RES_YIELD;\n\t\t\t\t\tgoto end;\n\t\t\t\tcase ACT_RET_ERR:\n\t\t\t\t\trule_ret = HTTP_RULE_RES_ERROR;\n\t\t\t\t\tgoto end;\n\t\t\t\tcase ACT_RET_DONE:\n\t\t\t\t\trule_ret = HTTP_RULE_RES_DONE;\n\t\t\t\t\tgoto end;\n\t\t\t\tcase ACT_RET_DENY:\n\t\t\t\t\tif (txn->status == -1)\n\t\t\t\t\t\ttxn->status = 502;\n\t\t\t\t\trule_ret = HTTP_RULE_RES_DENY;\n\t\t\t\t\tgoto end;\n\t\t\t\tcase ACT_RET_ABRT:\n\t\t\t\t\trule_ret = HTTP_RULE_RES_ABRT;\n\t\t\t\t\tgoto end;\n\t\t\t\tcase ACT_RET_INV:\n\t\t\t\t\trule_ret = HTTP_RULE_RES_BADREQ;\n\t\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tcontinue; /* eval the next rule */\n\t\t}\n\n\t\t/* If not action function defined, check for known actions */\n\t\tswitch (rule->action) {\n\t\t\tcase ACT_ACTION_ALLOW:\n\t\t\t\trule_ret = HTTP_RULE_RES_STOP; /* \"allow\" rules are OK */\n\t\t\t\tgoto end;\n\n\t\t\tcase ACT_ACTION_DENY:\n\t\t\t\ttxn->status = rule->arg.http_reply->status;\n\t\t\t\ttxn->http_reply = rule->arg.http_reply;\n\t\t\t\trule_ret = HTTP_RULE_RES_DENY;\n\t\t\t\tgoto end;\n\n\t\t\tcase ACT_HTTP_REDIR: {\n\t\t\t\tint ret = http_apply_redirect_rule(rule->arg.redir, s, txn);\n\n\t\t\t\tif (ret == 2) // 2 == skip\n\t\t\t\t\tbreak;\n\n\t\t\t\trule_ret = ret ? HTTP_RULE_RES_ABRT : HTTP_RULE_RES_ERROR;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\t/* other flags exists, but normally, they never be matched. */\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (def_rules && s->current_rule_list == def_rules) {\n\t\ts->current_rule_list = rules;\n\t\tgoto restart;\n\t}\n\n  end:\n\t/* if the ruleset evaluation is finished reset the strict mode */\n\tif (rule_ret != HTTP_RULE_RES_YIELD)\n\t\ttxn->rsp.flags &= ~HTTP_MSGF_SOFT_RW;\n\n\t/* we reached the end of the rules, nothing to report */\n\treturn rule_ret;\n}\n\n/* Executes backend and frontend http-after-response rules for the stream <s>,\n * in that order. it return 1 on success and 0 on error. It is the caller\n * responsibility to catch error or ignore it. If it catches it, this function\n * may be called a second time, for the internal error.\n */\nint http_eval_after_res_rules(struct stream *s)\n{\n\tstruct list *def_rules, *rules;\n\tstruct session *sess = s->sess;\n\tenum rule_result ret = HTTP_RULE_RES_CONT;\n\n\t/* Eval after-response ruleset only if the reply is not const */\n\tif (s->txn->flags & TX_CONST_REPLY)\n\t\tgoto end;\n\n\t/* prune the request variables if not already done and swap to the response variables. */\n\tif (s->vars_reqres.scope != SCOPE_RES) {\n\t\tif (!LIST_ISEMPTY(&s->vars_reqres.head))\n\t\t\tvars_prune(&s->vars_reqres, s->sess, s);\n\t\tvars_init_head(&s->vars_reqres, SCOPE_RES);\n\t}\n\n\tdef_rules = (s->be->defpx ? &s->be->defpx->http_after_res_rules : NULL);\n\trules = &s->be->http_after_res_rules;\n\n\tret = http_res_get_intercept_rule(s->be, def_rules, rules, s);\n\tif ((ret == HTTP_RULE_RES_CONT || ret == HTTP_RULE_RES_STOP) && sess->fe != s->be) {\n\t\tdef_rules = ((sess->fe->defpx && sess->fe->defpx != s->be->defpx) ? &sess->fe->defpx->http_after_res_rules : NULL);\n\t\trules = &sess->fe->http_after_res_rules;\n\t\tret = http_res_get_intercept_rule(sess->fe, def_rules, rules, s);\n\t}\n\n  end:\n\t/* All other codes than CONTINUE, STOP or DONE are forbidden */\n\treturn (ret == HTTP_RULE_RES_CONT || ret == HTTP_RULE_RES_STOP || ret == HTTP_RULE_RES_DONE);\n}\n\n/*\n * Manage client-side cookie. It can impact performance by about 2% so it is\n * desirable to call it only when needed. This code is quite complex because\n * of the multiple very crappy and ambiguous syntaxes we have to support. it\n * highly recommended not to touch this part without a good reason !\n */\nstatic void http_manage_client_side_cookies(struct stream *s, struct channel *req)\n{\n\tstruct session *sess = s->sess;\n\tstruct http_txn *txn = s->txn;\n\tstruct htx *htx;\n\tstruct http_hdr_ctx ctx;\n\tchar *hdr_beg, *hdr_end, *del_from;\n\tchar *prev, *att_beg, *att_end, *equal, *val_beg, *val_end, *next;\n\tint preserve_hdr;\n\n\thtx = htxbuf(&req->buf);\n\tctx.blk = NULL;\n\twhile (http_find_header(htx, ist(\"Cookie\"), &ctx, 1)) {\n\t\tint is_first = 1;\n\t\tdel_from = NULL;  /* nothing to be deleted */\n\t\tpreserve_hdr = 0; /* assume we may kill the whole header */\n\n\t\t/* Now look for cookies. Conforming to RFC2109, we have to support\n\t\t * attributes whose name begin with a '$', and associate them with\n\t\t * the right cookie, if we want to delete this cookie.\n\t\t * So there are 3 cases for each cookie read :\n\t\t * 1) it's a special attribute, beginning with a '$' : ignore it.\n\t\t * 2) it's a server id cookie that we *MAY* want to delete : save\n\t\t *    some pointers on it (last semi-colon, beginning of cookie...)\n\t\t * 3) it's an application cookie : we *MAY* have to delete a previous\n\t\t *    \"special\" cookie.\n\t\t * At the end of loop, if a \"special\" cookie remains, we may have to\n\t\t * remove it. If no application cookie persists in the header, we\n\t\t * *MUST* delete it.\n\t\t *\n\t\t * Note: RFC2965 is unclear about the processing of spaces around\n\t\t * the equal sign in the ATTR=VALUE form. A careful inspection of\n\t\t * the RFC explicitly allows spaces before it, and not within the\n\t\t * tokens (attrs or values). An inspection of RFC2109 allows that\n\t\t * too but section 10.1.3 lets one think that spaces may be allowed\n\t\t * after the equal sign too, resulting in some (rare) buggy\n\t\t * implementations trying to do that. So let's do what servers do.\n\t\t * Latest ietf draft forbids spaces all around. Also, earlier RFCs\n\t\t * allowed quoted strings in values, with any possible character\n\t\t * after a backslash, including control chars and delimiters, which\n\t\t * causes parsing to become ambiguous. Browsers also allow spaces\n\t\t * within values even without quotes.\n\t\t *\n\t\t * We have to keep multiple pointers in order to support cookie\n\t\t * removal at the beginning, middle or end of header without\n\t\t * corrupting the header. All of these headers are valid :\n\t\t *\n\t\t * hdr_beg                                               hdr_end\n\t\t * |                                                        |\n\t\t * v                                                        |\n\t\t * NAME1=VALUE1;NAME2=VALUE2;NAME3=VALUE3                   |\n\t\t * NAME1=VALUE1;NAME2_ONLY ;NAME3=VALUE3                    v\n\t\t *      NAME1  =  VALUE 1  ; NAME2 = VALUE2 ; NAME3 = VALUE3\n\t\t * |    |    | |  |      | |\n\t\t * |    |    | |  |      | |\n\t\t * |    |    | |  |      | +--> next\n\t\t * |    |    | |  |      +----> val_end\n\t\t * |    |    | |  +-----------> val_beg\n\t\t * |    |    | +--------------> equal\n\t\t * |    |    +----------------> att_end\n\t\t * |    +---------------------> att_beg\n\t\t * +--------------------------> prev\n\t\t *\n\t\t */\n\t\thdr_beg = ctx.value.ptr;\n\t\thdr_end = hdr_beg + ctx.value.len;\n\t\tfor (prev = hdr_beg; prev < hdr_end; prev = next) {\n\t\t\t/* Iterate through all cookies on this line */\n\n\t\t\t/* find att_beg */\n\t\t\tatt_beg = prev;\n\t\t\tif (!is_first)\n\t\t\t\tatt_beg++;\n\t\t\tis_first = 0;\n\n\t\t\twhile (att_beg < hdr_end && HTTP_IS_SPHT(*att_beg))\n\t\t\t\tatt_beg++;\n\n\t\t\t/* find att_end : this is the first character after the last non\n\t\t\t * space before the equal. It may be equal to hdr_end.\n\t\t\t */\n\t\t\tequal = att_end = att_beg;\n\t\t\twhile (equal < hdr_end) {\n\t\t\t\tif (*equal == '=' || *equal == ',' || *equal == ';')\n\t\t\t\t\tbreak;\n\t\t\t\tif (HTTP_IS_SPHT(*equal++))\n\t\t\t\t\tcontinue;\n\t\t\t\tatt_end = equal;\n\t\t\t}\n\n\t\t\t/* here, <equal> points to '=', a delimiter or the end. <att_end>\n\t\t\t * is between <att_beg> and <equal>, both may be identical.\n\t\t\t */\n\t\t\t/* look for end of cookie if there is an equal sign */\n\t\t\tif (equal < hdr_end && *equal == '=') {\n\t\t\t\t/* look for the beginning of the value */\n\t\t\t\tval_beg = equal + 1;\n\t\t\t\twhile (val_beg < hdr_end && HTTP_IS_SPHT(*val_beg))\n\t\t\t\t\tval_beg++;\n\n\t\t\t\t/* find the end of the value, respecting quotes */\n\t\t\t\tnext = http_find_cookie_value_end(val_beg, hdr_end);\n\n\t\t\t\t/* make val_end point to the first white space or delimiter after the value */\n\t\t\t\tval_end = next;\n\t\t\t\twhile (val_end > val_beg && HTTP_IS_SPHT(*(val_end - 1)))\n\t\t\t\t\tval_end--;\n\t\t\t}\n\t\t\telse\n\t\t\t\tval_beg = val_end = next = equal;\n\n\t\t\t/* We have nothing to do with attributes beginning with\n\t\t\t * '$'. However, they will automatically be removed if a\n\t\t\t * header before them is removed, since they're supposed\n\t\t\t * to be linked together.\n\t\t\t */\n\t\t\tif (*att_beg == '$')\n\t\t\t\tcontinue;\n\n\t\t\t/* Ignore cookies with no equal sign */\n\t\t\tif (equal == next) {\n\t\t\t\t/* This is not our cookie, so we must preserve it. But if we already\n\t\t\t\t * scheduled another cookie for removal, we cannot remove the\n\t\t\t\t * complete header, but we can remove the previous block itself.\n\t\t\t\t */\n\t\t\t\tpreserve_hdr = 1;\n\t\t\t\tif (del_from != NULL) {\n\t\t\t\t\tint delta = http_del_hdr_value(hdr_beg, hdr_end, &del_from, prev);\n\t\t\t\t\tval_end  += delta;\n\t\t\t\t\tnext     += delta;\n\t\t\t\t\thdr_end  += delta;\n\t\t\t\t\tprev     = del_from;\n\t\t\t\t\tdel_from = NULL;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* if there are spaces around the equal sign, we need to\n\t\t\t * strip them otherwise we'll get trouble for cookie captures,\n\t\t\t * or even for rewrites. Since this happens extremely rarely,\n\t\t\t * it does not hurt performance.\n\t\t\t */\n\t\t\tif (unlikely(att_end != equal || val_beg > equal + 1)) {\n\t\t\t\tint stripped_before = 0;\n\t\t\t\tint stripped_after = 0;\n\n\t\t\t\tif (att_end != equal) {\n\t\t\t\t\tmemmove(att_end, equal, hdr_end - equal);\n\t\t\t\t\tstripped_before = (att_end - equal);\n\t\t\t\t\tequal   += stripped_before;\n\t\t\t\t\tval_beg += stripped_before;\n\t\t\t\t}\n\n\t\t\t\tif (val_beg > equal + 1) {\n\t\t\t\t\tmemmove(equal + 1, val_beg, hdr_end + stripped_before - val_beg);\n\t\t\t\t\tstripped_after = (equal + 1) - val_beg;\n\t\t\t\t\tval_beg += stripped_after;\n\t\t\t\t\tstripped_before += stripped_after;\n\t\t\t\t}\n\n\t\t\t\tval_end      += stripped_before;\n\t\t\t\tnext         += stripped_before;\n\t\t\t\thdr_end      += stripped_before;\n\t\t\t}\n\t\t\t/* now everything is as on the diagram above */\n\n\t\t\t/* First, let's see if we want to capture this cookie. We check\n\t\t\t * that we don't already have a client side cookie, because we\n\t\t\t * can only capture one. Also as an optimisation, we ignore\n\t\t\t * cookies shorter than the declared name.\n\t\t\t */\n\t\t\tif (sess->fe->capture_name != NULL && txn->cli_cookie == NULL &&\n\t\t\t    (val_end - att_beg >= sess->fe->capture_namelen) &&\n\t\t\t    memcmp(att_beg, sess->fe->capture_name, sess->fe->capture_namelen) == 0) {\n\t\t\t\tint log_len = val_end - att_beg;\n\n\t\t\t\tif ((txn->cli_cookie = pool_alloc(pool_head_capture)) == NULL) {\n\t\t\t\t\tha_alert(\"HTTP logging : out of memory.\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tif (log_len > sess->fe->capture_len)\n\t\t\t\t\t\tlog_len = sess->fe->capture_len;\n\t\t\t\t\tmemcpy(txn->cli_cookie, att_beg, log_len);\n\t\t\t\t\ttxn->cli_cookie[log_len] = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Persistence cookies in passive, rewrite or insert mode have the\n\t\t\t * following form :\n\t\t\t *\n\t\t\t *    Cookie: NAME=SRV[|<lastseen>[|<firstseen>]]\n\t\t\t *\n\t\t\t * For cookies in prefix mode, the form is :\n\t\t\t *\n\t\t\t *    Cookie: NAME=SRV~VALUE\n\t\t\t */\n\t\t\tif ((att_end - att_beg == s->be->cookie_len) && (s->be->cookie_name != NULL) &&\n\t\t\t    (memcmp(att_beg, s->be->cookie_name, att_end - att_beg) == 0)) {\n\t\t\t\tstruct server *srv = s->be->srv;\n\t\t\t\tchar *delim;\n\n\t\t\t\t/* if we're in cookie prefix mode, we'll search the delimiter so that we\n\t\t\t\t * have the server ID between val_beg and delim, and the original cookie between\n\t\t\t\t * delim+1 and val_end. Otherwise, delim==val_end :\n\t\t\t\t *\n\t\t\t\t * hdr_beg\n\t\t\t\t * |\n\t\t\t\t * v\n\t\t\t\t * NAME=SRV;          # in all but prefix modes\n\t\t\t\t * NAME=SRV~OPAQUE ;  # in prefix mode\n\t\t\t\t * ||   ||  |      |+-> next\n\t\t\t\t * ||   ||  |      +--> val_end\n\t\t\t\t * ||   ||  +---------> delim\n\t\t\t\t * ||   |+------------> val_beg\n\t\t\t\t * ||   +-------------> att_end = equal\n\t\t\t\t * |+-----------------> att_beg\n\t\t\t\t * +------------------> prev\n\t\t\t\t *\n\t\t\t\t */\n\t\t\t\tif (s->be->ck_opts & PR_CK_PFX) {\n\t\t\t\t\tfor (delim = val_beg; delim < val_end; delim++)\n\t\t\t\t\t\tif (*delim == COOKIE_DELIM)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar *vbar1;\n\t\t\t\t\tdelim = val_end;\n\t\t\t\t\t/* Now check if the cookie contains a date field, which would\n\t\t\t\t\t * appear after a vertical bar ('|') just after the server name\n\t\t\t\t\t * and before the delimiter.\n\t\t\t\t\t */\n\t\t\t\t\tvbar1 = memchr(val_beg, COOKIE_DELIM_DATE, val_end - val_beg);\n\t\t\t\t\tif (vbar1) {\n\t\t\t\t\t\t/* OK, so left of the bar is the server's cookie and\n\t\t\t\t\t\t * right is the last seen date. It is a base64 encoded\n\t\t\t\t\t\t * 30-bit value representing the UNIX date since the\n\t\t\t\t\t\t * epoch in 4-second quantities.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tint val;\n\t\t\t\t\t\tdelim = vbar1++;\n\t\t\t\t\t\tif (val_end - vbar1 >= 5) {\n\t\t\t\t\t\t\tval = b64tos30(vbar1);\n\t\t\t\t\t\t\tif (val > 0)\n\t\t\t\t\t\t\t\ttxn->cookie_last_date = val << 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* look for a second vertical bar */\n\t\t\t\t\t\tvbar1 = memchr(vbar1, COOKIE_DELIM_DATE, val_end - vbar1);\n\t\t\t\t\t\tif (vbar1 && (val_end - vbar1 > 5)) {\n\t\t\t\t\t\t\tval = b64tos30(vbar1 + 1);\n\t\t\t\t\t\t\tif (val > 0)\n\t\t\t\t\t\t\t\ttxn->cookie_first_date = val << 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* if the cookie has an expiration date and the proxy wants to check\n\t\t\t\t * it, then we do that now. We first check if the cookie is too old,\n\t\t\t\t * then only if it has expired. We detect strict overflow because the\n\t\t\t\t * time resolution here is not great (4 seconds). Cookies with dates\n\t\t\t\t * in the future are ignored if their offset is beyond one day. This\n\t\t\t\t * allows an admin to fix timezone issues without expiring everyone\n\t\t\t\t * and at the same time avoids keeping unwanted side effects for too\n\t\t\t\t * long.\n\t\t\t\t */\n\t\t\t\tif (txn->cookie_first_date && s->be->cookie_maxlife &&\n\t\t\t\t    (((signed)(date.tv_sec - txn->cookie_first_date) > (signed)s->be->cookie_maxlife) ||\n\t\t\t\t     ((signed)(txn->cookie_first_date - date.tv_sec) > 86400))) {\n\t\t\t\t\ttxn->flags &= ~TX_CK_MASK;\n\t\t\t\t\ttxn->flags |= TX_CK_OLD;\n\t\t\t\t\tdelim = val_beg; // let's pretend we have not found the cookie\n\t\t\t\t\ttxn->cookie_first_date = 0;\n\t\t\t\t\ttxn->cookie_last_date = 0;\n\t\t\t\t}\n\t\t\t\telse if (txn->cookie_last_date && s->be->cookie_maxidle &&\n\t\t\t\t\t (((signed)(date.tv_sec - txn->cookie_last_date) > (signed)s->be->cookie_maxidle) ||\n\t\t\t\t\t  ((signed)(txn->cookie_last_date - date.tv_sec) > 86400))) {\n\t\t\t\t\ttxn->flags &= ~TX_CK_MASK;\n\t\t\t\t\ttxn->flags |= TX_CK_EXPIRED;\n\t\t\t\t\tdelim = val_beg; // let's pretend we have not found the cookie\n\t\t\t\t\ttxn->cookie_first_date = 0;\n\t\t\t\t\ttxn->cookie_last_date = 0;\n\t\t\t\t}\n\n\t\t\t\t/* Here, we'll look for the first running server which supports the cookie.\n\t\t\t\t * This allows to share a same cookie between several servers, for example\n\t\t\t\t * to dedicate backup servers to specific servers only.\n\t\t\t\t * However, to prevent clients from sticking to cookie-less backup server\n\t\t\t\t * when they have incidentely learned an empty cookie, we simply ignore\n\t\t\t\t * empty cookies and mark them as invalid.\n\t\t\t\t * The same behaviour is applied when persistence must be ignored.\n\t\t\t\t */\n\t\t\t\tif ((delim == val_beg) || (s->flags & (SF_IGNORE_PRST | SF_ASSIGNED)))\n\t\t\t\t\tsrv = NULL;\n\n\t\t\t\twhile (srv) {\n\t\t\t\t\tif (srv->cookie && (srv->cklen == delim - val_beg) &&\n\t\t\t\t\t    !memcmp(val_beg, srv->cookie, delim - val_beg)) {\n\t\t\t\t\t\tif ((srv->cur_state != SRV_ST_STOPPED) ||\n\t\t\t\t\t\t    (s->be->options & PR_O_PERSIST) ||\n\t\t\t\t\t\t    (s->flags & SF_FORCE_PRST)) {\n\t\t\t\t\t\t\t/* we found the server and we can use it */\n\t\t\t\t\t\t\ttxn->flags &= ~TX_CK_MASK;\n\t\t\t\t\t\t\ttxn->flags |= (srv->cur_state != SRV_ST_STOPPED) ? TX_CK_VALID : TX_CK_DOWN;\n\t\t\t\t\t\t\ts->flags |= SF_DIRECT | SF_ASSIGNED;\n\t\t\t\t\t\t\ts->target = &srv->obj_type;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* we found a server, but it's down,\n\t\t\t\t\t\t\t * mark it as such and go on in case\n\t\t\t\t\t\t\t * another one is available.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\ttxn->flags &= ~TX_CK_MASK;\n\t\t\t\t\t\t\ttxn->flags |= TX_CK_DOWN;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsrv = srv->next;\n\t\t\t\t}\n\n\t\t\t\tif (!srv && !(txn->flags & (TX_CK_DOWN|TX_CK_EXPIRED|TX_CK_OLD))) {\n\t\t\t\t\t/* no server matched this cookie or we deliberately skipped it */\n\t\t\t\t\ttxn->flags &= ~TX_CK_MASK;\n\t\t\t\t\tif ((s->flags & (SF_IGNORE_PRST | SF_ASSIGNED)))\n\t\t\t\t\t\ttxn->flags |= TX_CK_UNUSED;\n\t\t\t\t\telse\n\t\t\t\t\t\ttxn->flags |= TX_CK_INVALID;\n\t\t\t\t}\n\n\t\t\t\t/* depending on the cookie mode, we may have to either :\n\t\t\t\t * - delete the complete cookie if we're in insert+indirect mode, so that\n\t\t\t\t *   the server never sees it ;\n\t\t\t\t * - remove the server id from the cookie value, and tag the cookie as an\n\t\t\t\t *   application cookie so that it does not get accidentally removed later,\n\t\t\t\t *   if we're in cookie prefix mode\n\t\t\t\t */\n\t\t\t\tif ((s->be->ck_opts & PR_CK_PFX) && (delim != val_end)) {\n\t\t\t\t\tint delta; /* negative */\n\n\t\t\t\t\tmemmove(val_beg, delim + 1, hdr_end - (delim + 1));\n\t\t\t\t\tdelta = val_beg - (delim + 1);\n\t\t\t\t\tval_end  += delta;\n\t\t\t\t\tnext     += delta;\n\t\t\t\t\thdr_end  += delta;\n\t\t\t\t\tdel_from = NULL;\n\t\t\t\t\tpreserve_hdr = 1; /* we want to keep this cookie */\n\t\t\t\t}\n\t\t\t\telse if (del_from == NULL &&\n\t\t\t\t\t (s->be->ck_opts & (PR_CK_INS | PR_CK_IND)) == (PR_CK_INS | PR_CK_IND)) {\n\t\t\t\t\tdel_from = prev;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* This is not our cookie, so we must preserve it. But if we already\n\t\t\t\t * scheduled another cookie for removal, we cannot remove the\n\t\t\t\t * complete header, but we can remove the previous block itself.\n\t\t\t\t */\n\t\t\t\tpreserve_hdr = 1;\n\n\t\t\t\tif (del_from != NULL) {\n\t\t\t\t\tint delta = http_del_hdr_value(hdr_beg, hdr_end, &del_from, prev);\n\t\t\t\t\tif (att_beg >= del_from)\n\t\t\t\t\t\tatt_beg += delta;\n\t\t\t\t\tif (att_end >= del_from)\n\t\t\t\t\t\tatt_end += delta;\n\t\t\t\t\tval_beg  += delta;\n\t\t\t\t\tval_end  += delta;\n\t\t\t\t\tnext     += delta;\n\t\t\t\t\thdr_end  += delta;\n\t\t\t\t\tprev     = del_from;\n\t\t\t\t\tdel_from = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} /* for each cookie */\n\n\n\t\t/* There are no more cookies on this line.\n\t\t * We may still have one (or several) marked for deletion at the\n\t\t * end of the line. We must do this now in two ways :\n\t\t *  - if some cookies must be preserved, we only delete from the\n\t\t *    mark to the end of line ;\n\t\t *  - if nothing needs to be preserved, simply delete the whole header\n\t\t */\n\t\tif (del_from) {\n\t\t\thdr_end = (preserve_hdr ? del_from : hdr_beg);\n\t\t}\n\t\tif ((hdr_end - hdr_beg) != ctx.value.len) {\n\t\t\tif (hdr_beg != hdr_end)\n\t\t\t\thtx_change_blk_value_len(htx, ctx.blk, hdr_end - hdr_beg);\n\t\t\telse\n\t\t\t\thttp_remove_header(htx, &ctx);\n\t\t}\n\t} /* for each \"Cookie header */\n}\n\n/*\n * Manage server-side cookies. It can impact performance by about 2% so it is\n * desirable to call it only when needed. This function is also used when we\n * just need to know if there is a cookie (eg: for check-cache).\n */\nstatic void http_manage_server_side_cookies(struct stream *s, struct channel *res)\n{\n\tstruct session *sess = s->sess;\n\tstruct http_txn *txn = s->txn;\n\tstruct htx *htx;\n\tstruct http_hdr_ctx ctx;\n\tstruct server *srv;\n\tchar *hdr_beg, *hdr_end;\n\tchar *prev, *att_beg, *att_end, *equal, *val_beg, *val_end, *next;\n\tint is_cookie2 = 0;\n\n\thtx = htxbuf(&res->buf);\n\n\tctx.blk = NULL;\n\twhile (1) {\n\t\tint is_first = 1;\n\n\t\tif (is_cookie2 || !http_find_header(htx, ist(\"Set-Cookie\"), &ctx, 1)) {\n\t\t\tif (!http_find_header(htx, ist(\"Set-Cookie2\"), &ctx, 1))\n\t\t\t\tbreak;\n\t\t\tis_cookie2 = 1;\n\t\t}\n\n\t\t/* OK, right now we know we have a Set-Cookie* at hdr_beg, and\n\t\t * <prev> points to the colon.\n\t\t */\n\t\ttxn->flags |= TX_SCK_PRESENT;\n\n\t\t/* Maybe we only wanted to see if there was a Set-Cookie (eg:\n\t\t * check-cache is enabled) and we are not interested in checking\n\t\t * them. Warning, the cookie capture is declared in the frontend.\n\t\t */\n\t\tif (s->be->cookie_name == NULL && sess->fe->capture_name == NULL)\n\t\t\tbreak;\n\n\t\t/* OK so now we know we have to process this response cookie.\n\t\t * The format of the Set-Cookie header is slightly different\n\t\t * from the format of the Cookie header in that it does not\n\t\t * support the comma as a cookie delimiter (thus the header\n\t\t * cannot be folded) because the Expires attribute described in\n\t\t * the original Netscape's spec may contain an unquoted date\n\t\t * with a comma inside. We have to live with this because\n\t\t * many browsers don't support Max-Age and some browsers don't\n\t\t * support quoted strings. However the Set-Cookie2 header is\n\t\t * clean.\n\t\t *\n\t\t * We have to keep multiple pointers in order to support cookie\n\t\t * removal at the beginning, middle or end of header without\n\t\t * corrupting the header (in case of set-cookie2). A special\n\t\t * pointer, <scav> points to the beginning of the set-cookie-av\n\t\t * fields after the first semi-colon. The <next> pointer points\n\t\t * either to the end of line (set-cookie) or next unquoted comma\n\t\t * (set-cookie2). All of these headers are valid :\n\t\t *\n\t\t * hdr_beg                                                  hdr_end\n\t\t * |                                                           |\n\t\t * v                                                           |\n\t\t * NAME1  =  VALUE 1  ; Secure; Path=\"/\"                       |\n\t\t * NAME=VALUE; Secure; Expires=Thu, 01-Jan-1970 00:00:01 GMT   v\n\t\t * NAME = VALUE ; Secure; Expires=Thu, 01-Jan-1970 00:00:01 GMT\n\t\t * NAME1 = VALUE 1 ; Max-Age=0, NAME2=VALUE2; Discard\n\t\t * | |   | | |     | |          |\n\t\t * | |   | | |     | |          +-> next\n\t\t * | |   | | |     | +------------> scav\n\t\t * | |   | | |     +--------------> val_end\n\t\t * | |   | | +--------------------> val_beg\n\t\t * | |   | +----------------------> equal\n\t\t * | |   +------------------------> att_end\n\t\t * | +----------------------------> att_beg\n\t\t * +------------------------------> prev\n\t\t * -------------------------------> hdr_beg\n\t\t */\n\t\thdr_beg = ctx.value.ptr;\n\t\thdr_end = hdr_beg + ctx.value.len;\n\t\tfor (prev = hdr_beg; prev < hdr_end; prev = next) {\n\n\t\t\t/* Iterate through all cookies on this line */\n\n\t\t\t/* find att_beg */\n\t\t\tatt_beg = prev;\n\t\t\tif (!is_first)\n\t\t\t\tatt_beg++;\n\t\t\tis_first = 0;\n\n\t\t\twhile (att_beg < hdr_end && HTTP_IS_SPHT(*att_beg))\n\t\t\t\tatt_beg++;\n\n\t\t\t/* find att_end : this is the first character after the last non\n\t\t\t * space before the equal. It may be equal to hdr_end.\n\t\t\t */\n\t\t\tequal = att_end = att_beg;\n\n\t\t\twhile (equal < hdr_end) {\n\t\t\t\tif (*equal == '=' || *equal == ';' || (is_cookie2 && *equal == ','))\n\t\t\t\t\tbreak;\n\t\t\t\tif (HTTP_IS_SPHT(*equal++))\n\t\t\t\t\tcontinue;\n\t\t\t\tatt_end = equal;\n\t\t\t}\n\n\t\t\t/* here, <equal> points to '=', a delimiter or the end. <att_end>\n\t\t\t * is between <att_beg> and <equal>, both may be identical.\n\t\t\t */\n\n\t\t\t/* look for end of cookie if there is an equal sign */\n\t\t\tif (equal < hdr_end && *equal == '=') {\n\t\t\t\t/* look for the beginning of the value */\n\t\t\t\tval_beg = equal + 1;\n\t\t\t\twhile (val_beg < hdr_end && HTTP_IS_SPHT(*val_beg))\n\t\t\t\t\tval_beg++;\n\n\t\t\t\t/* find the end of the value, respecting quotes */\n\t\t\t\tnext = http_find_cookie_value_end(val_beg, hdr_end);\n\n\t\t\t\t/* make val_end point to the first white space or delimiter after the value */\n\t\t\t\tval_end = next;\n\t\t\t\twhile (val_end > val_beg && HTTP_IS_SPHT(*(val_end - 1)))\n\t\t\t\t\tval_end--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* <equal> points to next comma, semi-colon or EOL */\n\t\t\t\tval_beg = val_end = next = equal;\n\t\t\t}\n\n\t\t\tif (next < hdr_end) {\n\t\t\t\t/* Set-Cookie2 supports multiple cookies, and <next> points to\n\t\t\t\t * a colon or semi-colon before the end. So skip all attr-value\n\t\t\t\t * pairs and look for the next comma. For Set-Cookie, since\n\t\t\t\t * commas are permitted in values, skip to the end.\n\t\t\t\t */\n\t\t\t\tif (is_cookie2)\n\t\t\t\t\tnext = http_find_hdr_value_end(next, hdr_end);\n\t\t\t\telse\n\t\t\t\t\tnext = hdr_end;\n\t\t\t}\n\n\t\t\t/* Now everything is as on the diagram above */\n\n\t\t\t/* Ignore cookies with no equal sign */\n\t\t\tif (equal == val_end)\n\t\t\t\tcontinue;\n\n\t\t\t/* If there are spaces around the equal sign, we need to\n\t\t\t * strip them otherwise we'll get trouble for cookie captures,\n\t\t\t * or even for rewrites. Since this happens extremely rarely,\n\t\t\t * it does not hurt performance.\n\t\t\t */\n\t\t\tif (unlikely(att_end != equal || val_beg > equal + 1)) {\n\t\t\t\tint stripped_before = 0;\n\t\t\t\tint stripped_after = 0;\n\n\t\t\t\tif (att_end != equal) {\n\t\t\t\t\tmemmove(att_end, equal, hdr_end - equal);\n\t\t\t\t\tstripped_before = (att_end - equal);\n\t\t\t\t\tequal   += stripped_before;\n\t\t\t\t\tval_beg += stripped_before;\n\t\t\t\t}\n\n\t\t\t\tif (val_beg > equal + 1) {\n\t\t\t\t\tmemmove(equal + 1, val_beg, hdr_end + stripped_before - val_beg);\n\t\t\t\t\tstripped_after = (equal + 1) - val_beg;\n\t\t\t\t\tval_beg += stripped_after;\n\t\t\t\t\tstripped_before += stripped_after;\n\t\t\t\t}\n\n\t\t\t\tval_end      += stripped_before;\n\t\t\t\tnext         += stripped_before;\n\t\t\t\thdr_end      += stripped_before;\n\n\t\t\t\thtx_change_blk_value_len(htx, ctx.blk, hdr_end - hdr_beg);\n\t\t\t\tctx.value.len = hdr_end - hdr_beg;\n\t\t\t}\n\n\t\t\t/* First, let's see if we want to capture this cookie. We check\n\t\t\t * that we don't already have a server side cookie, because we\n\t\t\t * can only capture one. Also as an optimisation, we ignore\n\t\t\t * cookies shorter than the declared name.\n\t\t\t */\n\t\t\tif (sess->fe->capture_name != NULL &&\n\t\t\t    txn->srv_cookie == NULL &&\n\t\t\t    (val_end - att_beg >= sess->fe->capture_namelen) &&\n\t\t\t    memcmp(att_beg, sess->fe->capture_name, sess->fe->capture_namelen) == 0) {\n\t\t\t\tint log_len = val_end - att_beg;\n\t\t\t\tif ((txn->srv_cookie = pool_alloc(pool_head_capture)) == NULL) {\n\t\t\t\t\tha_alert(\"HTTP logging : out of memory.\\n\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (log_len > sess->fe->capture_len)\n\t\t\t\t\t\tlog_len = sess->fe->capture_len;\n\t\t\t\t\tmemcpy(txn->srv_cookie, att_beg, log_len);\n\t\t\t\t\ttxn->srv_cookie[log_len] = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsrv = objt_server(s->target);\n\t\t\t/* now check if we need to process it for persistence */\n\t\t\tif (!(s->flags & SF_IGNORE_PRST) &&\n\t\t\t    (att_end - att_beg == s->be->cookie_len) && (s->be->cookie_name != NULL) &&\n\t\t\t    (memcmp(att_beg, s->be->cookie_name, att_end - att_beg) == 0)) {\n\t\t\t\t/* assume passive cookie by default */\n\t\t\t\ttxn->flags &= ~TX_SCK_MASK;\n\t\t\t\ttxn->flags |= TX_SCK_FOUND;\n\n\t\t\t\t/* If the cookie is in insert mode on a known server, we'll delete\n\t\t\t\t * this occurrence because we'll insert another one later.\n\t\t\t\t * We'll delete it too if the \"indirect\" option is set and we're in\n\t\t\t\t * a direct access.\n\t\t\t\t */\n\t\t\t\tif (s->be->ck_opts & PR_CK_PSV) {\n\t\t\t\t\t/* The \"preserve\" flag was set, we don't want to touch the\n\t\t\t\t\t * server's cookie.\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t\telse if ((srv && (s->be->ck_opts & PR_CK_INS)) ||\n\t\t\t\t    ((s->flags & SF_DIRECT) && (s->be->ck_opts & PR_CK_IND))) {\n\t\t\t\t\t/* this cookie must be deleted */\n\t\t\t\t\tif (prev == hdr_beg && next == hdr_end) {\n\t\t\t\t\t\t/* whole header */\n\t\t\t\t\t\thttp_remove_header(htx, &ctx);\n\t\t\t\t\t\t/* note: while both invalid now, <next> and <hdr_end>\n\t\t\t\t\t\t * are still equal, so the for() will stop as expected.\n\t\t\t\t\t\t */\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* just remove the value */\n\t\t\t\t\t\tint delta = http_del_hdr_value(hdr_beg, hdr_end, &prev, next);\n\t\t\t\t\t\tnext      = prev;\n\t\t\t\t\t\thdr_end  += delta;\n\t\t\t\t\t}\n\t\t\t\t\ttxn->flags &= ~TX_SCK_MASK;\n\t\t\t\t\ttxn->flags |= TX_SCK_DELETED;\n\t\t\t\t\t/* and go on with next cookie */\n\t\t\t\t}\n\t\t\t\telse if (srv && srv->cookie && (s->be->ck_opts & PR_CK_RW)) {\n\t\t\t\t\t/* replace bytes val_beg->val_end with the cookie name associated\n\t\t\t\t\t * with this server since we know it.\n\t\t\t\t\t */\n\t\t\t\t\tint sliding, delta;\n\n\t\t\t\t\tctx.value = ist2(val_beg, val_end - val_beg);\n\t\t\t\t        ctx.lws_before = ctx.lws_after = 0;\n\t\t\t\t\thttp_replace_header_value(htx, &ctx, ist2(srv->cookie, srv->cklen));\n\t\t\t\t\tdelta     = srv->cklen - (val_end - val_beg);\n\t\t\t\t\tsliding   = (ctx.value.ptr - val_beg);\n\t\t\t\t\thdr_beg  += sliding;\n\t\t\t\t\tval_beg  += sliding;\n\t\t\t\t\tnext     += sliding + delta;\n\t\t\t\t\thdr_end  += sliding + delta;\n\n\t\t\t\t\ttxn->flags &= ~TX_SCK_MASK;\n\t\t\t\t\ttxn->flags |= TX_SCK_REPLACED;\n\t\t\t\t}\n\t\t\t\telse if (srv && srv->cookie && (s->be->ck_opts & PR_CK_PFX)) {\n\t\t\t\t\t/* insert the cookie name associated with this server\n\t\t\t\t\t * before existing cookie, and insert a delimiter between them..\n\t\t\t\t\t */\n\t\t\t\t\tint sliding, delta;\n\t\t\t\t\tctx.value = ist2(val_beg, 0);\n\t\t\t\t        ctx.lws_before = ctx.lws_after = 0;\n\t\t\t\t\thttp_replace_header_value(htx, &ctx, ist2(srv->cookie, srv->cklen + 1));\n\t\t\t\t\tdelta     = srv->cklen + 1;\n\t\t\t\t\tsliding   = (ctx.value.ptr - val_beg);\n\t\t\t\t\thdr_beg  += sliding;\n\t\t\t\t\tval_beg  += sliding;\n\t\t\t\t\tnext     += sliding + delta;\n\t\t\t\t\thdr_end  += sliding + delta;\n\n\t\t\t\t\tval_beg[srv->cklen] = COOKIE_DELIM;\n\t\t\t\t\ttxn->flags &= ~TX_SCK_MASK;\n\t\t\t\t\ttxn->flags |= TX_SCK_REPLACED;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* that's done for this cookie, check the next one on the same\n\t\t\t * line when next != hdr_end (only if is_cookie2).\n\t\t\t */\n\t\t}\n\t}\n}\n\n/*\n * Parses the Cache-Control and Pragma request header fields to determine if\n * the request may be served from the cache and/or if it is cacheable. Updates\n * s->txn->flags.\n */\nvoid http_check_request_for_cacheability(struct stream *s, struct channel *req)\n{\n\tstruct http_txn *txn = s->txn;\n\tstruct htx *htx;\n\tstruct http_hdr_ctx ctx = { .blk = NULL };\n\tint pragma_found, cc_found;\n\n\tif ((txn->flags & (TX_CACHEABLE|TX_CACHE_IGNORE)) == TX_CACHE_IGNORE)\n\t\treturn; /* nothing more to do here */\n\n\thtx = htxbuf(&req->buf);\n\tpragma_found = cc_found = 0;\n\n\t/* Check \"pragma\" header for HTTP/1.0 compatibility. */\n\tif (http_find_header(htx, ist(\"pragma\"), &ctx, 1)) {\n\t\tif (isteqi(ctx.value, ist(\"no-cache\"))) {\n\t\t\tpragma_found = 1;\n\t\t}\n\t}\n\n\tctx.blk = NULL;\n\t/* Don't use the cache and don't try to store if we found the\n\t * Authorization header */\n\tif (http_find_header(htx, ist(\"authorization\"), &ctx, 1)) {\n\t\ttxn->flags &= ~TX_CACHEABLE & ~TX_CACHE_COOK;\n\t\ttxn->flags |= TX_CACHE_IGNORE;\n\t}\n\n\n\t/* Look for \"cache-control\" header and iterate over all the values\n\t * until we find one that specifies that caching is possible or not. */\n\tctx.blk = NULL;\n\twhile (http_find_header(htx, ist(\"cache-control\"), &ctx, 0)) {\n\t\tcc_found = 1;\n\t\t/* We don't check the values after max-age, max-stale nor min-fresh,\n\t\t * we simply don't use the cache when they're specified. */\n\t\tif (istmatchi(ctx.value, ist(\"max-age\")) ||\n\t\t    istmatchi(ctx.value, ist(\"no-cache\")) ||\n\t\t    istmatchi(ctx.value, ist(\"max-stale\")) ||\n\t\t    istmatchi(ctx.value, ist(\"min-fresh\"))) {\n\t\t\ttxn->flags |= TX_CACHE_IGNORE;\n\t\t\tcontinue;\n\t\t}\n\t\tif (istmatchi(ctx.value, ist(\"no-store\"))) {\n\t\t\ttxn->flags &= ~TX_CACHEABLE & ~TX_CACHE_COOK;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\t/* RFC7234#5.4:\n\t *   When the Cache-Control header field is also present and\n\t *   understood in a request, Pragma is ignored.\n\t *   When the Cache-Control header field is not present in a\n\t *   request, caches MUST consider the no-cache request\n\t *   pragma-directive as having the same effect as if\n\t *   \"Cache-Control: no-cache\" were present.\n\t */\n\tif (!cc_found && pragma_found)\n\t\ttxn->flags |= TX_CACHE_IGNORE;\n}\n\n/*\n * Check if response is cacheable or not. Updates s->txn->flags.\n */\nvoid http_check_response_for_cacheability(struct stream *s, struct channel *res)\n{\n\tstruct http_txn *txn = s->txn;\n\tstruct http_hdr_ctx ctx = { .blk = NULL };\n\tstruct htx *htx;\n\tint has_freshness_info = 0;\n\tint has_validator = 0;\n\n\tif (txn->status < 200) {\n\t\t/* do not try to cache interim responses! */\n\t\ttxn->flags &= ~TX_CACHEABLE & ~TX_CACHE_COOK;\n\t\treturn;\n\t}\n\n\thtx = htxbuf(&res->buf);\n\t/* Check \"pragma\" header for HTTP/1.0 compatibility. */\n\tif (http_find_header(htx, ist(\"pragma\"), &ctx, 1)) {\n\t\tif (isteqi(ctx.value, ist(\"no-cache\"))) {\n\t\t\ttxn->flags &= ~TX_CACHEABLE & ~TX_CACHE_COOK;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Look for \"cache-control\" header and iterate over all the values\n\t * until we find one that specifies that caching is possible or not. */\n\tctx.blk = NULL;\n\twhile (http_find_header(htx, ist(\"cache-control\"), &ctx, 0)) {\n\t\tif (isteqi(ctx.value, ist(\"public\"))) {\n\t\t\ttxn->flags |= TX_CACHEABLE | TX_CACHE_COOK;\n\t\t\tcontinue;\n\t\t}\n\t\tif (isteqi(ctx.value, ist(\"private\")) ||\n\t\t    isteqi(ctx.value, ist(\"no-cache\")) ||\n\t\t    isteqi(ctx.value, ist(\"no-store\")) ||\n\t\t    isteqi(ctx.value, ist(\"max-age=0\")) ||\n\t\t    isteqi(ctx.value, ist(\"s-maxage=0\"))) {\n\t\t\ttxn->flags &= ~TX_CACHEABLE & ~TX_CACHE_COOK;\n\t\t\tcontinue;\n\t\t}\n\t\t/* We might have a no-cache=\"set-cookie\" form. */\n\t\tif (istmatchi(ctx.value, ist(\"no-cache=\\\"set-cookie\"))) {\n\t\t\ttxn->flags &= ~TX_CACHE_COOK;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (istmatchi(ctx.value, ist(\"s-maxage\")) ||\n\t\t    istmatchi(ctx.value, ist(\"max-age\"))) {\n\t\t\thas_freshness_info = 1;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\t/* If no freshness information could be found in Cache-Control values,\n\t * look for an Expires header. */\n\tif (!has_freshness_info) {\n\t\tctx.blk = NULL;\n\t\thas_freshness_info = http_find_header(htx, ist(\"expires\"), &ctx, 0);\n\t}\n\n\t/* If no freshness information could be found in Cache-Control or Expires\n\t * values, look for an explicit validator. */\n\tif (!has_freshness_info) {\n\t\tctx.blk = NULL;\n\t\thas_validator = 1;\n\t\tif (!http_find_header(htx, ist(\"etag\"), &ctx, 0)) {\n\t\t\tctx.blk = NULL;\n\t\t\tif (!http_find_header(htx, ist(\"last-modified\"), &ctx, 0))\n\t\t\t\thas_validator = 0;\n\t\t}\n\t}\n\n\t/* We won't store an entry that has neither a cache validator nor an\n\t * explicit expiration time, as suggested in RFC 7234#3. */\n\tif (!has_freshness_info && !has_validator)\n\t\ttxn->flags |= TX_CACHE_IGNORE;\n}\n\n/*\n * In a GET, HEAD or POST request, check if the requested URI matches the stats uri\n * for the current backend.\n *\n * It is assumed that the request is either a HEAD, GET, or POST and that the\n * uri_auth field is valid.\n *\n * Returns 1 if stats should be provided, otherwise 0.\n */\nstatic int http_stats_check_uri(struct stream *s, struct http_txn *txn, struct proxy *backend)\n{\n\tstruct uri_auth *uri_auth = backend->uri_auth;\n\tstruct htx *htx;\n\tstruct htx_sl *sl;\n\tstruct ist uri;\n\n\tif (!uri_auth)\n\t\treturn 0;\n\n\tif (txn->meth != HTTP_METH_GET && txn->meth != HTTP_METH_HEAD && txn->meth != HTTP_METH_POST)\n\t\treturn 0;\n\n\thtx = htxbuf(&s->req.buf);\n\tsl = http_get_stline(htx);\n\turi = htx_sl_req_uri(sl);\n\tif (*uri_auth->uri_prefix == '/') {\n\t\tstruct http_uri_parser parser = http_uri_parser_init(uri);\n\t\turi = http_parse_path(&parser);\n\t}\n\n\t/* check URI size */\n\tif (uri_auth->uri_len > uri.len)\n\t\treturn 0;\n\n\tif (memcmp(uri.ptr, uri_auth->uri_prefix, uri_auth->uri_len) != 0)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n/* This function prepares an applet to handle the stats. It can deal with the\n * \"100-continue\" expectation, check that admin rules are met for POST requests,\n * and program a response message if something was unexpected. It cannot fail\n * and always relies on the stats applet to complete the job. It does not touch\n * analysers nor counters, which are left to the caller. It does not touch\n * s->target which is supposed to already point to the stats applet. The caller\n * is expected to have already assigned an appctx to the stream.\n */\nstatic int http_handle_stats(struct stream *s, struct channel *req)\n{\n\tstruct stats_admin_rule *stats_admin_rule;\n\tstruct stream_interface *si = &s->si[1];\n\tstruct session *sess = s->sess;\n\tstruct http_txn *txn = s->txn;\n\tstruct http_msg *msg = &txn->req;\n\tstruct uri_auth *uri_auth = s->be->uri_auth;\n\tconst char *h, *lookup, *end;\n\tstruct appctx *appctx;\n\tstruct htx *htx;\n\tstruct htx_sl *sl;\n\n\tappctx = si_appctx(si);\n\tmemset(&appctx->ctx.stats, 0, sizeof(appctx->ctx.stats));\n\tappctx->st1 = appctx->st2 = 0;\n\tappctx->ctx.stats.st_code = STAT_STATUS_INIT;\n\tappctx->ctx.stats.flags |= uri_auth->flags;\n\tappctx->ctx.stats.flags |= STAT_FMT_HTML; /* assume HTML mode by default */\n\tif ((msg->flags & HTTP_MSGF_VER_11) && (txn->meth != HTTP_METH_HEAD))\n\t\tappctx->ctx.stats.flags |= STAT_CHUNKED;\n\n\thtx = htxbuf(&req->buf);\n\tsl = http_get_stline(htx);\n\tlookup = HTX_SL_REQ_UPTR(sl) + uri_auth->uri_len;\n\tend = HTX_SL_REQ_UPTR(sl) + HTX_SL_REQ_ULEN(sl);\n\n\tfor (h = lookup; h <= end - 3; h++) {\n\t\tif (memcmp(h, \";up\", 3) == 0) {\n\t\t\tappctx->ctx.stats.flags |= STAT_HIDE_DOWN;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (h = lookup; h <= end - 9; h++) {\n\t\tif (memcmp(h, \";no-maint\", 9) == 0) {\n\t\t\tappctx->ctx.stats.flags |= STAT_HIDE_MAINT;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (uri_auth->refresh) {\n\t\tfor (h = lookup; h <= end - 10; h++) {\n\t\t\tif (memcmp(h, \";norefresh\", 10) == 0) {\n\t\t\t\tappctx->ctx.stats.flags |= STAT_NO_REFRESH;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (h = lookup; h <= end - 4; h++) {\n\t\tif (memcmp(h, \";csv\", 4) == 0) {\n\t\t\tappctx->ctx.stats.flags &= ~(STAT_FMT_MASK|STAT_JSON_SCHM);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (h = lookup; h <= end - 6; h++) {\n\t\tif (memcmp(h, \";typed\", 6) == 0) {\n\t\t\tappctx->ctx.stats.flags &= ~(STAT_FMT_MASK|STAT_JSON_SCHM);\n\t\t\tappctx->ctx.stats.flags |= STAT_FMT_TYPED;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (h = lookup; h <= end - 5; h++) {\n\t\tif (memcmp(h, \";json\", 5) == 0) {\n\t\t\tappctx->ctx.stats.flags &= ~(STAT_FMT_MASK|STAT_JSON_SCHM);\n\t\t\tappctx->ctx.stats.flags |= STAT_FMT_JSON;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (h = lookup; h <= end - 12; h++) {\n\t\tif (memcmp(h, \";json-schema\", 12) == 0) {\n\t\t\tappctx->ctx.stats.flags &= ~STAT_FMT_MASK;\n\t\t\tappctx->ctx.stats.flags |= STAT_JSON_SCHM;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (h = lookup; h <= end - 8; h++) {\n\t\tif (memcmp(h, \";st=\", 4) == 0) {\n\t\t\tint i;\n\t\t\th += 4;\n\t\t\tappctx->ctx.stats.st_code = STAT_STATUS_UNKN;\n\t\t\tfor (i = STAT_STATUS_INIT + 1; i < STAT_STATUS_SIZE; i++) {\n\t\t\t\tif (strncmp(stat_status_codes[i], h, 4) == 0) {\n\t\t\t\t\tappctx->ctx.stats.st_code = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tappctx->ctx.stats.scope_str = 0;\n\tappctx->ctx.stats.scope_len = 0;\n\tfor (h = lookup; h <= end - 8; h++) {\n\t\tif (memcmp(h, STAT_SCOPE_INPUT_NAME \"=\", strlen(STAT_SCOPE_INPUT_NAME) + 1) == 0) {\n\t\t\tint itx = 0;\n\t\t\tconst char *h2;\n\t\t\tchar scope_txt[STAT_SCOPE_TXT_MAXLEN + 1];\n\t\t\tconst char *err;\n\n\t\t\th += strlen(STAT_SCOPE_INPUT_NAME) + 1;\n\t\t\th2 = h;\n\t\t\tappctx->ctx.stats.scope_str = h2 - HTX_SL_REQ_UPTR(sl);\n\t\t\twhile (h < end) {\n\t\t\t\tif (*h == ';' || *h == '&' || *h == ' ')\n\t\t\t\t\tbreak;\n\t\t\t\titx++;\n\t\t\t\th++;\n\t\t\t}\n\n\t\t\tif (itx > STAT_SCOPE_TXT_MAXLEN)\n\t\t\t\titx = STAT_SCOPE_TXT_MAXLEN;\n\t\t\tappctx->ctx.stats.scope_len = itx;\n\n\t\t\t/* scope_txt = search query, appctx->ctx.stats.scope_len is always <= STAT_SCOPE_TXT_MAXLEN */\n\t\t\tmemcpy(scope_txt, h2, itx);\n\t\t\tscope_txt[itx] = '\\0';\n\t\t\terr = invalid_char(scope_txt);\n\t\t\tif (err) {\n\t\t\t\t/* bad char in search text => clear scope */\n\t\t\t\tappctx->ctx.stats.scope_str = 0;\n\t\t\t\tappctx->ctx.stats.scope_len = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* now check whether we have some admin rules for this request */\n\tlist_for_each_entry(stats_admin_rule, &uri_auth->admin_rules, list) {\n\t\tint ret = 1;\n\n\t\tif (stats_admin_rule->cond) {\n\t\t\tret = acl_exec_cond(stats_admin_rule->cond, s->be, sess, s, SMP_OPT_DIR_REQ|SMP_OPT_FINAL);\n\t\t\tret = acl_pass(ret);\n\t\t\tif (stats_admin_rule->cond->pol == ACL_COND_UNLESS)\n\t\t\t\tret = !ret;\n\t\t}\n\n\t\tif (ret) {\n\t\t\t/* no rule, or the rule matches */\n\t\t\tappctx->ctx.stats.flags |= STAT_ADMIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (txn->meth == HTTP_METH_GET || txn->meth == HTTP_METH_HEAD)\n\t\tappctx->st0 = STAT_HTTP_HEAD;\n\telse if (txn->meth == HTTP_METH_POST) {\n\t\tif (appctx->ctx.stats.flags & STAT_ADMIN) {\n\t\t\tappctx->st0 = STAT_HTTP_POST;\n\t\t\tif (msg->msg_state < HTTP_MSG_DATA)\n\t\t\t\treq->analysers |= AN_REQ_HTTP_BODY;\n\t\t}\n\t\telse {\n\t\t\t/* POST without admin level */\n\t\t\tappctx->ctx.stats.flags &= ~STAT_CHUNKED;\n\t\t\tappctx->ctx.stats.st_code = STAT_STATUS_DENY;\n\t\t\tappctx->st0 = STAT_HTTP_LAST;\n\t\t}\n\t}\n\telse {\n\t\t/* Unsupported method */\n\t\tappctx->ctx.stats.flags &= ~STAT_CHUNKED;\n\t\tappctx->ctx.stats.st_code = STAT_STATUS_IVAL;\n\t\tappctx->st0 = STAT_HTTP_LAST;\n\t}\n\n\ts->task->nice = -32; /* small boost for HTTP statistics */\n\treturn 1;\n}\n\n/* This function waits for the message payload at most <time> milliseconds (may\n * be set to TICK_ETERNITY). It stops to wait if at least <bytes> bytes of the\n * payload are received (0 means no limit). It returns HTTP_RULE_* depending on\n * the result:\n *\n *   - HTTP_RULE_RES_CONT when  conditions are met to stop waiting\n *   - HTTP_RULE_RES_YIELD to wait for more data\n *   - HTTP_RULE_RES_ABRT when a timeout occurred.\n *   - HTTP_RULE_RES_BADREQ if a parsing error is raised by lower level\n *   - HTTP_RULE_RES_ERROR if an internal error occurred\n *\n * If a timeout occurred, this function is responsible to emit the right response\n * to the client, depending on the channel (408 on request side, 504 on response\n * side). All other errors must be handled by the caller.\n */\nenum rule_result http_wait_for_msg_body(struct stream *s, struct channel *chn,\n\t\t\t\t\tunsigned int time, unsigned int bytes)\n{\n\tstruct session *sess = s->sess;\n\tstruct http_txn *txn = s->txn;\n\tstruct http_msg *msg = ((chn->flags & CF_ISRESP) ? &txn->rsp : &txn->req);\n\tstruct htx *htx;\n\tenum rule_result ret = HTTP_RULE_RES_CONT;\n\n\thtx = htxbuf(&chn->buf);\n\n\tif (htx->flags & HTX_FL_PARSING_ERROR) {\n\t\tret = HTTP_RULE_RES_BADREQ;\n\t\tgoto end;\n\t}\n\tif (htx->flags & HTX_FL_PROCESSING_ERROR) {\n\t\tret = HTTP_RULE_RES_ERROR;\n\t\tgoto end;\n\t}\n\n\t/* Do nothing for bodyless and CONNECT requests */\n\tif (txn->meth == HTTP_METH_CONNECT || (msg->flags & HTTP_MSGF_BODYLESS))\n\t\tgoto end;\n\n\tif (!(chn->flags & CF_ISRESP) && msg->msg_state < HTTP_MSG_DATA) {\n\t\tif (http_handle_expect_hdr(s, htx, msg) == -1) {\n\t\t\tret = HTTP_RULE_RES_ERROR;\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tmsg->msg_state = HTTP_MSG_DATA;\n\n\t/* Now we're in HTTP_MSG_DATA. We just need to know if all data have\n\t * been received or if the buffer is full.\n\t */\n\tif ((htx->flags & HTX_FL_EOM) ||\n\t    htx_get_tail_type(htx) > HTX_BLK_DATA ||\n\t    channel_htx_full(chn, htx, global.tune.maxrewrite) ||\n\t    si_rx_blocked_room(chn_prod(chn)))\n\t\tgoto end;\n\n\tif (bytes) {\n\t\tstruct htx_blk *blk;\n\t\tunsigned int len = 0;\n\n\t\tfor (blk = htx_get_first_blk(htx); blk; blk = htx_get_next_blk(htx, blk)) {\n\t\t\tif (htx_get_blk_type(blk) != HTX_BLK_DATA)\n\t\t\t\tcontinue;\n\t\t\tlen += htx_get_blksz(blk);\n\t\t\tif (len >= bytes)\n\t\t\t\tgoto end;\n\t\t}\n\t}\n\n\tif ((chn->flags & CF_READ_TIMEOUT) || tick_is_expired(chn->analyse_exp, now_ms)) {\n\t\tif (!(chn->flags & CF_ISRESP))\n\t\t\tgoto abort_req;\n\t\tgoto abort_res;\n\t}\n\n\t/* we get here if we need to wait for more data */\n\tif (!(chn->flags & (CF_SHUTR | CF_READ_ERROR))) {\n\t\tif (!tick_isset(chn->analyse_exp))\n\t\t\tchn->analyse_exp = tick_add_ifset(now_ms, time);\n\t\tret = HTTP_RULE_RES_YIELD;\n\t}\n\n  end:\n\treturn ret;\n\n  abort_req:\n\ttxn->status = 408;\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_CLITO;\n\tif (!(s->flags & SF_FINST_MASK))\n\t\ts->flags |= SF_FINST_D;\n\t_HA_ATOMIC_INC(&sess->fe->fe_counters.failed_req);\n\tif (sess->listener && sess->listener->counters)\n\t\t_HA_ATOMIC_INC(&sess->listener->counters->failed_req);\n\thttp_reply_and_close(s, txn->status, http_error_message(s));\n\tret = HTTP_RULE_RES_ABRT;\n\tgoto end;\n\n  abort_res:\n\ttxn->status = 504;\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_SRVTO;\n\tif (!(s->flags & SF_FINST_MASK))\n\t\ts->flags |= SF_FINST_D;\n\tstream_inc_http_fail_ctr(s);\n\thttp_reply_and_close(s, txn->status, http_error_message(s));\n\tret = HTTP_RULE_RES_ABRT;\n\tgoto end;\n}\n\nvoid http_perform_server_redirect(struct stream *s, struct stream_interface *si)\n{\n\tstruct channel *req = &s->req;\n\tstruct channel *res = &s->res;\n\tstruct server *srv;\n\tstruct htx *htx;\n\tstruct htx_sl *sl;\n\tstruct ist path, location;\n\tunsigned int flags;\n\tstruct http_uri_parser parser;\n\n\t/*\n\t * Create the location\n\t */\n\tchunk_reset(&trash);\n\n\t/* 1: add the server's prefix */\n\t/* special prefix \"/\" means don't change URL */\n\tsrv = __objt_server(s->target);\n\tif (srv->rdr_len != 1 || *srv->rdr_pfx != '/') {\n\t\tif (!chunk_memcat(&trash, srv->rdr_pfx, srv->rdr_len))\n\t\t\treturn;\n\t}\n\n\t/* 2: add the request Path */\n\thtx = htxbuf(&req->buf);\n\tsl = http_get_stline(htx);\n\tparser = http_uri_parser_init(htx_sl_req_uri(sl));\n\tpath = http_parse_path(&parser);\n\tif (!isttest(path))\n\t\treturn;\n\n\tif (!chunk_memcat(&trash, path.ptr, path.len))\n\t\treturn;\n\tlocation = ist2(trash.area, trash.data);\n\n\t/*\n\t * Create the 302 respone\n\t */\n\thtx = htx_from_buf(&res->buf);\n\tflags = (HTX_SL_F_IS_RESP|HTX_SL_F_VER_11|HTX_SL_F_XFER_LEN|HTX_SL_F_BODYLESS);\n\tsl = htx_add_stline(htx, HTX_BLK_RES_SL, flags,\n\t\t\t    ist(\"HTTP/1.1\"), ist(\"302\"), ist(\"Found\"));\n\tif (!sl)\n\t\tgoto fail;\n\tsl->info.res.status = 302;\n\ts->txn->status = 302;\n\n        if (!htx_add_header(htx, ist(\"Cache-Control\"), ist(\"no-cache\")) ||\n\t    !htx_add_header(htx, ist(\"Connection\"), ist(\"close\")) ||\n\t    !htx_add_header(htx, ist(\"Content-length\"), ist(\"0\")) ||\n\t    !htx_add_header(htx, ist(\"Location\"), location))\n\t\tgoto fail;\n\n\tif (!htx_add_endof(htx, HTX_BLK_EOH))\n\t\tgoto fail;\n\n\thtx->flags |= HTX_FL_EOM;\n\thtx_to_buf(htx, &res->buf);\n\tif (!http_forward_proxy_resp(s, 1))\n\t\tgoto fail;\n\n\t/* return without error. */\n\tsi_shutr(si);\n\tsi_shutw(si);\n\tsi->err_type = SI_ET_NONE;\n\tsi->state    = SI_ST_CLO;\n\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_LOCAL;\n\tif (!(s->flags & SF_FINST_MASK))\n\t\ts->flags |= SF_FINST_C;\n\n\t/* FIXME: we should increase a counter of redirects per server and per backend. */\n\tsrv_inc_sess_ctr(srv);\n\tsrv_set_sess_last(srv);\n\treturn;\n\n  fail:\n\t/* If an error occurred, remove the incomplete HTTP response from the\n\t * buffer */\n\tchannel_htx_truncate(res, htx);\n}\n\n/* This function terminates the request because it was completely analyzed or\n * because an error was triggered during the body forwarding.\n */\nstatic void http_end_request(struct stream *s)\n{\n\tstruct channel *chn = &s->req;\n\tstruct http_txn *txn = s->txn;\n\n\tDBG_TRACE_ENTER(STRM_EV_HTTP_ANA, s, txn);\n\n\tif (unlikely(txn->req.msg_state == HTTP_MSG_ERROR ||\n\t\t     txn->rsp.msg_state == HTTP_MSG_ERROR)) {\n\t\tchannel_abort(chn);\n\t\tchannel_htx_truncate(chn, htxbuf(&chn->buf));\n\t\tgoto end;\n\t}\n\n\tif (unlikely(txn->req.msg_state < HTTP_MSG_DONE)) {\n\t\tDBG_TRACE_DEVEL(\"waiting end of the request\", STRM_EV_HTTP_ANA, s, txn);\n\t\treturn;\n\t}\n\n\tif (txn->req.msg_state == HTTP_MSG_DONE) {\n\t\t/* No need to read anymore, the request was completely parsed.\n\t\t * We can shut the read side unless we want to abort_on_close,\n\t\t * or we have a POST request. The issue with POST requests is\n\t\t * that some browsers still send a CRLF after the request, and\n\t\t * this CRLF must be read so that it does not remain in the kernel\n\t\t * buffers, otherwise a close could cause an RST on some systems\n\t\t * (eg: Linux).\n\t\t */\n\t\tif (!(s->be->options & PR_O_ABRT_CLOSE) && txn->meth != HTTP_METH_POST)\n\t\t\tchannel_dont_read(chn);\n\n\t\t/* if the server closes the connection, we want to immediately react\n\t\t * and close the socket to save packets and syscalls.\n\t\t */\n\t\ts->si[1].flags |= SI_FL_NOHALF;\n\n\t\t/* In any case we've finished parsing the request so we must\n\t\t * disable Nagle when sending data because 1) we're not going\n\t\t * to shut this side, and 2) the server is waiting for us to\n\t\t * send pending data.\n\t\t */\n\t\tchn->flags |= CF_NEVER_WAIT;\n\n\t\tif (txn->rsp.msg_state < HTTP_MSG_DONE) {\n\t\t\t/* The server has not finished to respond, so we\n\t\t\t * don't want to move in order not to upset it.\n\t\t\t */\n\t\t\tDBG_TRACE_DEVEL(\"waiting end of the response\", STRM_EV_HTTP_ANA, s, txn);\n\t\t\treturn;\n\t\t}\n\n\t\t/* When we get here, it means that both the request and the\n\t\t * response have finished receiving. Depending on the connection\n\t\t * mode, we'll have to wait for the last bytes to leave in either\n\t\t * direction, and sometimes for a close to be effective.\n\t\t */\n\t\tif (txn->flags & TX_CON_WANT_TUN) {\n\t\t\t/* Tunnel mode will not have any analyser so it needs to\n\t\t\t * poll for reads.\n\t\t\t */\n\t\t\tchannel_auto_read(chn);\n\t\t\tif (b_data(&chn->buf)) {\n\t\t\t\tDBG_TRACE_DEVEL(\"waiting to flush the request\", STRM_EV_HTTP_ANA, s, txn);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttxn->req.msg_state = HTTP_MSG_TUNNEL;\n\t\t}\n\t\telse {\n\t\t\t/* we're not expecting any new data to come for this\n\t\t\t * transaction, so we can close it.\n\t\t\t *\n\t\t\t *  However, there is an exception if the response\n\t\t\t *  length is undefined. In this case, we need to wait\n\t\t\t *  the close from the server. The response will be\n\t\t\t *  switched in TUNNEL mode until the end.\n\t\t\t */\n\t\t\tif (!(txn->rsp.flags & HTTP_MSGF_XFER_LEN) &&\n\t\t\t    txn->rsp.msg_state != HTTP_MSG_CLOSED)\n\t\t\t\tgoto check_channel_flags;\n\n\t\t\tif (!(chn->flags & (CF_SHUTW|CF_SHUTW_NOW))) {\n\t\t\t\tchannel_shutr_now(chn);\n\t\t\t\tchannel_shutw_now(chn);\n\t\t\t}\n\t\t}\n\t\tgoto check_channel_flags;\n\t}\n\n\tif (txn->req.msg_state == HTTP_MSG_CLOSING) {\n\t  http_msg_closing:\n\t\t/* nothing else to forward, just waiting for the output buffer\n\t\t * to be empty and for the shutw_now to take effect.\n\t\t */\n\t\tif (channel_is_empty(chn)) {\n\t\t\ttxn->req.msg_state = HTTP_MSG_CLOSED;\n\t\t\tgoto http_msg_closed;\n\t\t}\n\t\telse if (chn->flags & CF_SHUTW) {\n\t\t\ttxn->req.msg_state = HTTP_MSG_ERROR;\n\t\t\tgoto end;\n\t\t}\n\t\tDBG_TRACE_LEAVE(STRM_EV_HTTP_ANA, s, txn);\n\t\treturn;\n\t}\n\n\tif (txn->req.msg_state == HTTP_MSG_CLOSED) {\n\t  http_msg_closed:\n\t\t/* if we don't know whether the server will close, we need to hard close */\n\t\tif (txn->rsp.flags & HTTP_MSGF_XFER_LEN)\n\t\t\ts->si[1].flags |= SI_FL_NOLINGER;  /* we want to close ASAP */\n\t\t/* see above in MSG_DONE why we only do this in these states */\n\t\tif (!(s->be->options & PR_O_ABRT_CLOSE))\n\t\t\tchannel_dont_read(chn);\n\t\tgoto end;\n\t}\n\n  check_channel_flags:\n\t/* Here, we are in HTTP_MSG_DONE or HTTP_MSG_TUNNEL */\n\tif (chn->flags & (CF_SHUTW|CF_SHUTW_NOW)) {\n\t\t/* if we've just closed an output, let's switch */\n\t\ttxn->req.msg_state = HTTP_MSG_CLOSING;\n\t\tgoto http_msg_closing;\n\t}\n\n  end:\n\tchn->analysers &= AN_REQ_FLT_END;\n\tif (txn->req.msg_state == HTTP_MSG_TUNNEL) {\n\t\tchn->flags |= CF_NEVER_WAIT;\n\t\tif (HAS_REQ_DATA_FILTERS(s))\n\t\t\tchn->analysers |= AN_REQ_FLT_XFER_DATA;\n\t}\n\tchannel_auto_close(chn);\n\tchannel_auto_read(chn);\n\tDBG_TRACE_LEAVE(STRM_EV_HTTP_ANA, s, txn);\n}\n\n\n/* This function terminates the response because it was completely analyzed or\n * because an error was triggered during the body forwarding.\n */\nstatic void http_end_response(struct stream *s)\n{\n\tstruct channel *chn = &s->res;\n\tstruct http_txn *txn = s->txn;\n\n\tDBG_TRACE_ENTER(STRM_EV_HTTP_ANA, s, txn);\n\n\tif (unlikely(txn->req.msg_state == HTTP_MSG_ERROR ||\n\t\t     txn->rsp.msg_state == HTTP_MSG_ERROR)) {\n\t\tchannel_htx_truncate(&s->req, htxbuf(&s->req.buf));\n\t\tchannel_abort(&s->req);\n\t\tgoto end;\n\t}\n\n\tif (unlikely(txn->rsp.msg_state < HTTP_MSG_DONE)) {\n\t\tDBG_TRACE_DEVEL(\"waiting end of the response\", STRM_EV_HTTP_ANA, s, txn);\n\t\treturn;\n\t}\n\n\tif (txn->rsp.msg_state == HTTP_MSG_DONE) {\n\t\t/* In theory, we don't need to read anymore, but we must\n\t\t * still monitor the server connection for a possible close\n\t\t * while the request is being uploaded, so we don't disable\n\t\t * reading.\n\t\t */\n\t\t/* channel_dont_read(chn); */\n\n\t\tif (txn->req.msg_state < HTTP_MSG_DONE) {\n\t\t\t/* The client seems to still be sending data, probably\n\t\t\t * because we got an error response during an upload.\n\t\t\t * We have the choice of either breaking the connection\n\t\t\t * or letting it pass through. Let's do the later.\n\t\t\t */\n\t\t\tDBG_TRACE_DEVEL(\"waiting end of the request\", STRM_EV_HTTP_ANA, s, txn);\n\t\t\treturn;\n\t\t}\n\n\t\t/* When we get here, it means that both the request and the\n\t\t * response have finished receiving. Depending on the connection\n\t\t * mode, we'll have to wait for the last bytes to leave in either\n\t\t * direction, and sometimes for a close to be effective.\n\t\t */\n\t\tif (txn->flags & TX_CON_WANT_TUN) {\n\t\t\tchannel_auto_read(chn);\n\t\t\tif (b_data(&chn->buf)) {\n\t\t\t\tDBG_TRACE_DEVEL(\"waiting to flush the respone\", STRM_EV_HTTP_ANA, s, txn);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttxn->rsp.msg_state = HTTP_MSG_TUNNEL;\n\t\t}\n\t\telse {\n\t\t\t/* we're not expecting any new data to come for this\n\t\t\t * transaction, so we can close it.\n\t\t\t */\n\t\t\tif (!(chn->flags & (CF_SHUTW|CF_SHUTW_NOW))) {\n\t\t\t\tchannel_shutr_now(chn);\n\t\t\t\tchannel_shutw_now(chn);\n\t\t\t}\n\t\t}\n\t\tgoto check_channel_flags;\n\t}\n\n\tif (txn->rsp.msg_state == HTTP_MSG_CLOSING) {\n\t  http_msg_closing:\n\t\t/* nothing else to forward, just waiting for the output buffer\n\t\t * to be empty and for the shutw_now to take effect.\n\t\t */\n\t\tif (channel_is_empty(chn)) {\n\t\t\ttxn->rsp.msg_state = HTTP_MSG_CLOSED;\n\t\t\tgoto http_msg_closed;\n\t\t}\n\t\telse if (chn->flags & CF_SHUTW) {\n\t\t\ttxn->rsp.msg_state = HTTP_MSG_ERROR;\n\t\t\t_HA_ATOMIC_INC(&strm_sess(s)->fe->fe_counters.cli_aborts);\n\t\t\t_HA_ATOMIC_INC(&s->be->be_counters.cli_aborts);\n\t\t\tif (strm_sess(s)->listener && strm_sess(s)->listener->counters)\n\t\t\t\t_HA_ATOMIC_INC(&strm_sess(s)->listener->counters->cli_aborts);\n\t\t\tif (objt_server(s->target))\n\t\t\t\t_HA_ATOMIC_INC(&__objt_server(s->target)->counters.cli_aborts);\n\t\t\tgoto end;\n\t\t}\n\t\tDBG_TRACE_LEAVE(STRM_EV_HTTP_ANA, s, txn);\n\t\treturn;\n\t}\n\n\tif (txn->rsp.msg_state == HTTP_MSG_CLOSED) {\n\t  http_msg_closed:\n\t\t/* drop any pending data */\n\t\tchannel_htx_truncate(&s->req, htxbuf(&s->req.buf));\n\t\tchannel_abort(&s->req);\n\t\tgoto end;\n\t}\n\n  check_channel_flags:\n\t/* Here, we are in HTTP_MSG_DONE or HTTP_MSG_TUNNEL */\n\tif (chn->flags & (CF_SHUTW|CF_SHUTW_NOW)) {\n\t\t/* if we've just closed an output, let's switch */\n\t\ttxn->rsp.msg_state = HTTP_MSG_CLOSING;\n\t\tgoto http_msg_closing;\n\t}\n\n  end:\n\tchn->analysers &= AN_RES_FLT_END;\n\tif (txn->rsp.msg_state == HTTP_MSG_TUNNEL) {\n\t\tchn->flags |= CF_NEVER_WAIT;\n\t\tif (HAS_RSP_DATA_FILTERS(s))\n\t\t\tchn->analysers |= AN_RES_FLT_XFER_DATA;\n\t}\n\tchannel_auto_close(chn);\n\tchannel_auto_read(chn);\n\tDBG_TRACE_LEAVE(STRM_EV_HTTP_ANA, s, txn);\n}\n\n/* Forward a response generated by HAProxy (error/redirect/return). This\n * function forwards all pending incoming data. If <final> is set to 0, nothing\n * more is performed. It is used for 1xx informational messages. Otherwise, the\n * transaction is terminated and the request is emptied. On success 1 is\n * returned. If an error occurred, 0 is returned. If it fails, this function\n * only exits. It is the caller responsibility to do the cleanup.\n */\nint http_forward_proxy_resp(struct stream *s, int final)\n{\n\tstruct channel *req = &s->req;\n\tstruct channel *res = &s->res;\n\tstruct htx *htx = htxbuf(&res->buf);\n\tsize_t data;\n\n\tif (final) {\n\t\thtx->flags |= HTX_FL_PROXY_RESP;\n\n\t\tif (!htx_is_empty(htx) && !http_eval_after_res_rules(s))\n\t\t\treturn 0;\n\n\t\tif (s->txn->meth == HTTP_METH_HEAD)\n\t\t\thtx_skip_msg_payload(htx);\n\n\t\tchannel_auto_read(req);\n\t\tchannel_abort(req);\n\t\tchannel_auto_close(req);\n\t\tchannel_htx_erase(req, htxbuf(&req->buf));\n\n\t\tres->wex = tick_add_ifset(now_ms, res->wto);\n\t\tchannel_auto_read(res);\n\t\tchannel_auto_close(res);\n\t\tchannel_shutr_now(res);\n\t\tres->flags |= CF_EOI; /* The response is terminated, add EOI */\n\t\thtxbuf(&res->buf)->flags |= HTX_FL_EOM; /* no more data are expected */\n\t}\n\telse {\n\t\t/* Send ASAP informational messages. Rely on CF_EOI for final\n\t\t * response.\n\t\t */\n\t\tres->flags |= CF_SEND_DONTWAIT;\n\t}\n\n\tdata = htx->data - co_data(res);\n\tc_adv(res, data);\n\thtx->first = -1;\n\tres->total += data;\n\treturn 1;\n}\n\nvoid http_server_error(struct stream *s, struct stream_interface *si, int err,\n\t\t       int finst, struct http_reply *msg)\n{\n\thttp_reply_and_close(s, s->txn->status, msg);\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= err;\n\tif (!(s->flags & SF_FINST_MASK))\n\t\ts->flags |= finst;\n}\n\nvoid http_reply_and_close(struct stream *s, short status, struct http_reply *msg)\n{\n\tif (!msg) {\n\t\tchannel_htx_truncate(&s->res, htxbuf(&s->res.buf));\n\t\tgoto end;\n\t}\n\n\tif (http_reply_message(s, msg) == -1) {\n\t\t/* On error, return a 500 error message, but don't rewrite it if\n\t\t * it is already an internal error. If it was already a \"const\"\n\t\t * 500 error, just fail.\n\t\t */\n\t\tif (s->txn->status == 500) {\n\t\t\tif (s->txn->flags & TX_CONST_REPLY)\n\t\t\t\tgoto end;\n\t\t\ts->txn->flags |= TX_CONST_REPLY;\n\t\t}\n\t\ts->txn->status = 500;\n\t\ts->txn->http_reply = NULL;\n\t\treturn http_reply_and_close(s, s->txn->status, http_error_message(s));\n\t}\n\nend:\n\ts->res.wex = tick_add_ifset(now_ms, s->res.wto);\n\n\t/* At this staged, HTTP analysis is finished */\n\ts->req.analysers &= AN_REQ_FLT_END;\n\ts->req.analyse_exp = TICK_ETERNITY;\n\n\ts->res.analysers &= AN_RES_FLT_END;\n\ts->res.analyse_exp = TICK_ETERNITY;\n\n\tchannel_auto_read(&s->req);\n\tchannel_abort(&s->req);\n\tchannel_auto_close(&s->req);\n\tchannel_htx_erase(&s->req, htxbuf(&s->req.buf));\n\tchannel_auto_read(&s->res);\n\tchannel_auto_close(&s->res);\n\tchannel_shutr_now(&s->res);\n}\n\nstruct http_reply *http_error_message(struct stream *s)\n{\n\tconst int msgnum = http_get_status_idx(s->txn->status);\n\n\tif (s->txn->http_reply)\n\t\treturn s->txn->http_reply;\n\telse if (s->be->replies[msgnum])\n\t\treturn s->be->replies[msgnum];\n\telse if (strm_fe(s)->replies[msgnum])\n\t\treturn strm_fe(s)->replies[msgnum];\n\telse\n\t\treturn &http_err_replies[msgnum];\n}\n\n/* Produces an HTX message from an http reply. Depending on the http reply type,\n * a, errorfile, an raw file or a log-format string is used. On success, it\n * returns 0. If an error occurs -1 is returned. If it fails, this function only\n * exits. It is the caller responsibility to do the cleanup.\n */\nint http_reply_to_htx(struct stream *s, struct htx *htx, struct http_reply *reply)\n{\n\tstruct buffer *errmsg;\n\tstruct htx_sl *sl;\n\tstruct buffer *body = NULL;\n\tconst char *status, *reason, *clen, *ctype;\n\tunsigned int slflags;\n\tint ret = 0;\n\n\t/*\n\t * - HTTP_REPLY_ERRFILES unexpected here. handled as no payload if so\n\t *\n\t * - HTTP_REPLY_INDIRECT: switch on another reply if defined or handled\n\t *   as no payload if NULL. the TXN status code is set with the status\n\t *   of the original reply.\n\t */\n\n\tif (reply->type == HTTP_REPLY_INDIRECT) {\n\t\tif (reply->body.reply)\n\t\t\treply = reply->body.reply;\n\t}\n\tif (reply->type == HTTP_REPLY_ERRMSG && !reply->body.errmsg)  {\n\t\t/* get default error message */\n\t\tif (reply == s->txn->http_reply)\n\t\t\ts->txn->http_reply = NULL;\n\t\treply = http_error_message(s);\n\t\tif (reply->type == HTTP_REPLY_INDIRECT) {\n\t\t\tif (reply->body.reply)\n\t\t\t\treply = reply->body.reply;\n\t\t}\n\t}\n\n\tif (reply->type == HTTP_REPLY_ERRMSG) {\n\t\t/* implicit or explicit error message*/\n\t\terrmsg = reply->body.errmsg;\n\t\tif (errmsg && !b_is_null(errmsg)) {\n\t\t\tif (!htx_copy_msg(htx, errmsg))\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\telse {\n\t\t/* no payload, file or log-format string */\n\t\tif (reply->type == HTTP_REPLY_RAW) {\n\t\t\t/* file */\n\t\t\tbody = &reply->body.obj;\n\t\t}\n\t\telse if (reply->type == HTTP_REPLY_LOGFMT) {\n\t\t\t/* log-format string */\n\t\t\tbody = alloc_trash_chunk();\n\t\t\tif (!body)\n\t\t\t\tgoto fail_alloc;\n\t\t\tbody->data = build_logline(s, body->area, body->size, &reply->body.fmt);\n\t\t}\n\t\t/* else no payload */\n\n\t\tstatus = ultoa(reply->status);\n\t\treason = http_get_reason(reply->status);\n\t\tslflags = (HTX_SL_F_IS_RESP|HTX_SL_F_VER_11|HTX_SL_F_XFER_LEN|HTX_SL_F_CLEN);\n\t\tif (!body || !b_data(body))\n\t\t\tslflags |= HTX_SL_F_BODYLESS;\n\t\tsl = htx_add_stline(htx, HTX_BLK_RES_SL, slflags, ist(\"HTTP/1.1\"), ist(status), ist(reason));\n\t\tif (!sl)\n\t\t\tgoto fail;\n\t\tsl->info.res.status = reply->status;\n\n\t\tclen = (body ? ultoa(b_data(body)) : \"0\");\n\t\tctype = reply->ctype;\n\n\t\tif (!LIST_ISEMPTY(&reply->hdrs)) {\n\t\t\tstruct http_reply_hdr *hdr;\n\t\t\tstruct buffer *value = alloc_trash_chunk();\n\n\t\t\tif (!value)\n\t\t\t\tgoto fail;\n\n\t\t\tlist_for_each_entry(hdr, &reply->hdrs, list) {\n\t\t\t\tchunk_reset(value);\n\t\t\t\tvalue->data = build_logline(s, value->area, value->size, &hdr->value);\n\t\t\t\tif (b_data(value) && !htx_add_header(htx, hdr->name, ist2(b_head(value), b_data(value)))) {\n\t\t\t\t\tfree_trash_chunk(value);\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t\tchunk_reset(value);\n\t\t\t}\n\t\t\tfree_trash_chunk(value);\n\t\t}\n\n\t\tif (!htx_add_header(htx, ist(\"content-length\"), ist(clen)) ||\n\t\t    (body && b_data(body) && ctype && !htx_add_header(htx, ist(\"content-type\"), ist(ctype))) ||\n\t\t    !htx_add_endof(htx, HTX_BLK_EOH) ||\n\t\t    (body && b_data(body) && !htx_add_data_atonce(htx, ist2(b_head(body), b_data(body)))))\n\t\t\tgoto fail;\n\n\t\thtx->flags |= HTX_FL_EOM;\n\t}\n\n  leave:\n\tif (reply->type == HTTP_REPLY_LOGFMT)\n\t\tfree_trash_chunk(body);\n\treturn ret;\n\n  fail_alloc:\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_RESOURCE;\n\t/* fall through */\n  fail:\n\tret = -1;\n\tgoto leave;\n}\n\n/* Send an http reply to the client. On success, it returns 0. If an error\n * occurs -1 is returned and the response channel is truncated, removing this\n * way the faulty reply. This function may fail when the reply is formatted\n * (http_reply_to_htx) or when the reply is forwarded\n * (http_forward_proxy_resp). On the last case, it is because a\n * http-after-response rule fails.\n */\nint http_reply_message(struct stream *s, struct http_reply *reply)\n{\n\tstruct channel *res = &s->res;\n\tstruct htx *htx = htx_from_buf(&res->buf);\n\n\tif (s->txn->status == -1)\n\t\ts->txn->status = reply->status;\n\tchannel_htx_truncate(res, htx);\n\n\tif (http_reply_to_htx(s, htx, reply) == -1)\n\t\tgoto fail;\n\n\thtx_to_buf(htx, &s->res.buf);\n\tif (!http_forward_proxy_resp(s, 1))\n\t\tgoto fail;\n\treturn 0;\n\n  fail:\n\tchannel_htx_truncate(res, htx);\n\tif (!(s->flags & SF_ERR_MASK))\n\t\ts->flags |= SF_ERR_PRXCOND;\n\treturn -1;\n}\n\n/* Return the error message corresponding to si->err_type. It is assumed\n * that the server side is closed. Note that err_type is actually a\n * bitmask, where almost only aborts may be cumulated with other\n * values. We consider that aborted operations are more important\n * than timeouts or errors due to the fact that nobody else in the\n * logs might explain incomplete retries. All others should avoid\n * being cumulated. It should normally not be possible to have multiple\n * aborts at once, but just in case, the first one in sequence is reported.\n * Note that connection errors appearing on the second request of a keep-alive\n * connection are not reported since this allows the client to retry.\n */\nvoid http_return_srv_error(struct stream *s, struct stream_interface *si)\n{\n\tint err_type = si->err_type;\n\n\t/* set s->txn->status for http_error_message(s) */\n\tif (err_type & SI_ET_QUEUE_ABRT) {\n\t\ts->txn->status = -1;\n\t\thttp_server_error(s, si, SF_ERR_CLICL, SF_FINST_Q, NULL);\n\t}\n\telse if (err_type & SI_ET_CONN_ABRT) {\n\t\ts->txn->status = -1;\n\t\thttp_server_error(s, si, SF_ERR_CLICL, SF_FINST_C, NULL);\n\t}\n\telse if (err_type & SI_ET_QUEUE_TO) {\n\t\ts->txn->status = 503;\n\t\thttp_server_error(s, si, SF_ERR_SRVTO, SF_FINST_Q,\n\t\t\t\t  http_error_message(s));\n\t}\n\telse if (err_type & SI_ET_QUEUE_ERR) {\n\t\ts->txn->status = 503;\n\t\thttp_server_error(s, si, SF_ERR_SRVCL, SF_FINST_Q,\n\t\t\t\t  http_error_message(s));\n\t}\n\telse if (err_type & SI_ET_CONN_TO) {\n\t\ts->txn->status = 503;\n\t\thttp_server_error(s, si, SF_ERR_SRVTO, SF_FINST_C,\n\t\t\t\t  (s->txn->flags & TX_NOT_FIRST) ? NULL :\n\t\t\t\t  http_error_message(s));\n\t}\n\telse if (err_type & SI_ET_CONN_ERR) {\n\t\ts->txn->status = 503;\n\t\thttp_server_error(s, si, SF_ERR_SRVCL, SF_FINST_C,\n\t\t\t\t  (s->flags & SF_SRV_REUSED) ? NULL :\n\t\t\t\t  http_error_message(s));\n\t}\n\telse if (err_type & SI_ET_CONN_RES) {\n\t\ts->txn->status = 503;\n\t\thttp_server_error(s, si, SF_ERR_RESOURCE, SF_FINST_C,\n\t\t\t\t  (s->txn->flags & TX_NOT_FIRST) ? NULL :\n\t\t\t\t  http_error_message(s));\n\t}\n\telse { /* SI_ET_CONN_OTHER and others */\n\t\ts->txn->status = 500;\n\t\thttp_server_error(s, si, SF_ERR_INTERNAL, SF_FINST_C,\n\t\t\t\t  http_error_message(s));\n\t}\n}\n\n\n/* Handle Expect: 100-continue for HTTP/1.1 messages if necessary. It returns 0\n * on success and -1 on error.\n */\nstatic int http_handle_expect_hdr(struct stream *s, struct htx *htx, struct http_msg *msg)\n{\n\t/* If we have HTTP/1.1 message with a body and Expect: 100-continue,\n\t * then we must send an HTTP/1.1 100 Continue intermediate response.\n\t */\n\tif (msg->msg_state == HTTP_MSG_BODY && (msg->flags & HTTP_MSGF_VER_11) &&\n\t    (msg->flags & (HTTP_MSGF_CNT_LEN|HTTP_MSGF_TE_CHNK))) {\n\t\tstruct ist hdr = { .ptr = \"Expect\", .len = 6 };\n\t\tstruct http_hdr_ctx ctx;\n\n\t\tctx.blk = NULL;\n\t\t/* Expect is allowed in 1.1, look for it */\n\t\tif (http_find_header(htx, hdr, &ctx, 0) &&\n\t\t    unlikely(isteqi(ctx.value, ist2(\"100-continue\", 12)))) {\n\t\t\tif (http_reply_100_continue(s) == -1)\n\t\t\t\treturn -1;\n\t\t\thttp_remove_header(htx, &ctx);\n\t\t}\n\t}\n\treturn 0;\n}\n\n/* Send a 100-Continue response to the client. It returns 0 on success and -1\n * on error. The response channel is updated accordingly.\n */\nstatic int http_reply_100_continue(struct stream *s)\n{\n\tstruct channel *res = &s->res;\n\tstruct htx *htx = htx_from_buf(&res->buf);\n\tstruct htx_sl *sl;\n\tunsigned int flags = (HTX_SL_F_IS_RESP|HTX_SL_F_VER_11|\n\t\t\t      HTX_SL_F_XFER_LEN|HTX_SL_F_BODYLESS);\n\n\tsl = htx_add_stline(htx, HTX_BLK_RES_SL, flags,\n\t\t\t    ist(\"HTTP/1.1\"), ist(\"100\"), ist(\"Continue\"));\n\tif (!sl)\n\t\tgoto fail;\n\tsl->info.res.status = 100;\n\n\tif (!htx_add_endof(htx, HTX_BLK_EOH))\n\t\tgoto fail;\n\n\tif (!http_forward_proxy_resp(s, 0))\n\t\tgoto fail;\n\treturn 0;\n\n  fail:\n\t/* If an error occurred, remove the incomplete HTTP response from the\n\t * buffer */\n\tchannel_htx_truncate(res, htx);\n\treturn -1;\n}\n\n\n/*\n * Capture headers from message <htx> according to header list <cap_hdr>, and\n * fill the <cap> pointers appropriately.\n */\nstatic void http_capture_headers(struct htx *htx, char **cap, struct cap_hdr *cap_hdr)\n{\n\tstruct cap_hdr *h;\n\tint32_t pos;\n\n\tfor (pos = htx_get_first(htx); pos != -1; pos = htx_get_next(htx, pos)) {\n\t\tstruct htx_blk *blk = htx_get_blk(htx, pos);\n\t\tenum htx_blk_type type = htx_get_blk_type(blk);\n\t\tstruct ist n, v;\n\n\t\tif (type == HTX_BLK_EOH)\n\t\t\tbreak;\n\t\tif (type != HTX_BLK_HDR)\n\t\t\tcontinue;\n\n\t\tn = htx_get_blk_name(htx, blk);\n\n\t\tfor (h = cap_hdr; h; h = h->next) {\n\t\t\tif (h->namelen && (h->namelen == n.len) &&\n\t\t\t    (strncasecmp(n.ptr, h->name, h->namelen) == 0)) {\n\t\t\t\tif (cap[h->index] == NULL)\n\t\t\t\t\tcap[h->index] =\n\t\t\t\t\t\tpool_alloc(h->pool);\n\n\t\t\t\tif (cap[h->index] == NULL) {\n\t\t\t\t\tha_alert(\"HTTP capture : out of memory.\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tv = htx_get_blk_value(htx, blk);\n\t\t\t\tv = isttrim(v, h->len);\n\n\t\t\t\tmemcpy(cap[h->index], v.ptr, v.len);\n\t\t\t\tcap[h->index][v.len]=0;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* Delete a value in a header between delimiters <from> and <next>. The header\n * itself is delimited by <start> and <end> pointers. The number of characters\n * displaced is returned, and the pointer to the first delimiter is updated if\n * required. The function tries as much as possible to respect the following\n * principles :\n * - replace <from> delimiter by the <next> one unless <from> points to <start>,\n *   in which case <next> is simply removed\n * - set exactly one space character after the new first delimiter, unless there\n *   are not enough characters in the block being moved to do so.\n * - remove unneeded spaces before the previous delimiter and after the new\n *   one.\n *\n * It is the caller's responsibility to ensure that :\n *   - <from> points to a valid delimiter or <start> ;\n *   - <next> points to a valid delimiter or <end> ;\n *   - there are non-space chars before <from>.\n */\nstatic int http_del_hdr_value(char *start, char *end, char **from, char *next)\n{\n\tchar *prev = *from;\n\n\tif (prev == start) {\n\t\t/* We're removing the first value. eat the semicolon, if <next>\n\t\t * is lower than <end> */\n\t\tif (next < end)\n\t\t\tnext++;\n\n\t\twhile (next < end && HTTP_IS_SPHT(*next))\n\t\t\tnext++;\n\t}\n\telse {\n\t\t/* Remove useless spaces before the old delimiter. */\n\t\twhile (HTTP_IS_SPHT(*(prev-1)))\n\t\t\tprev--;\n\t\t*from = prev;\n\n\t\t/* copy the delimiter and if possible a space if we're\n\t\t * not at the end of the line.\n\t\t */\n\t\tif (next < end) {\n\t\t\t*prev++ = *next++;\n\t\t\tif (prev + 1 < next)\n\t\t\t\t*prev++ = ' ';\n\t\t\twhile (next < end && HTTP_IS_SPHT(*next))\n\t\t\t\tnext++;\n\t\t}\n\t}\n\tmemmove(prev, next, end - next);\n\treturn (prev - next);\n}\n\n\n/* Formats the start line of the request (without CRLF) and puts it in <str> and\n * return the written length. The line can be truncated if it exceeds <len>.\n */\nstatic size_t http_fmt_req_line(const struct htx_sl *sl, char *str, size_t len)\n{\n\tstruct ist dst = ist2(str, 0);\n\n\tif (istcat(&dst, htx_sl_req_meth(sl), len) == -1)\n\t\tgoto end;\n\tif (dst.len + 1 > len)\n\t\tgoto end;\n\tdst.ptr[dst.len++] = ' ';\n\n\tif (istcat(&dst, htx_sl_req_uri(sl), len) == -1)\n\t\tgoto end;\n\tif (dst.len + 1 > len)\n\t\tgoto end;\n\tdst.ptr[dst.len++] = ' ';\n\n\tistcat(&dst, htx_sl_req_vsn(sl), len);\n  end:\n\treturn dst.len;\n}\n\n/*\n * Print a debug line with a start line.\n */\nstatic void http_debug_stline(const char *dir, struct stream *s, const struct htx_sl *sl)\n{\n        struct session *sess = strm_sess(s);\n        int max;\n\n        chunk_printf(&trash, \"%08x:%s.%s[%04x:%04x]: \", s->uniq_id, s->be->id,\n                     dir,\n                     objt_conn(sess->origin) ? (unsigned short)__objt_conn(sess->origin)->handle.fd : -1,\n                     objt_cs(s->si[1].end) ? (unsigned short)__objt_cs(s->si[1].end)->conn->handle.fd : -1);\n\n        max = HTX_SL_P1_LEN(sl);\n        UBOUND(max, trash.size - trash.data - 3);\n        chunk_memcat(&trash, HTX_SL_P1_PTR(sl), max);\n        trash.area[trash.data++] = ' ';\n\n        max = HTX_SL_P2_LEN(sl);\n        UBOUND(max, trash.size - trash.data - 2);\n        chunk_memcat(&trash, HTX_SL_P2_PTR(sl), max);\n        trash.area[trash.data++] = ' ';\n\n        max = HTX_SL_P3_LEN(sl);\n        UBOUND(max, trash.size - trash.data - 1);\n        chunk_memcat(&trash, HTX_SL_P3_PTR(sl), max);\n        trash.area[trash.data++] = '\\n';\n\n        DISGUISE(write(1, trash.area, trash.data));\n}\n\n/*\n * Print a debug line with a header.\n */\nstatic void http_debug_hdr(const char *dir, struct stream *s, const struct ist n, const struct ist v)\n{\n        struct session *sess = strm_sess(s);\n        int max;\n\n        chunk_printf(&trash, \"%08x:%s.%s[%04x:%04x]: \", s->uniq_id, s->be->id,\n                     dir,\n                     objt_conn(sess->origin) ? (unsigned short)__objt_conn(sess->origin)->handle.fd : -1,\n                     objt_cs(s->si[1].end) ? (unsigned short)__objt_cs(s->si[1].end)->conn->handle.fd : -1);\n\n        max = n.len;\n        UBOUND(max, trash.size - trash.data - 3);\n        chunk_memcat(&trash, n.ptr, max);\n        trash.area[trash.data++] = ':';\n        trash.area[trash.data++] = ' ';\n\n        max = v.len;\n        UBOUND(max, trash.size - trash.data - 1);\n        chunk_memcat(&trash, v.ptr, max);\n        trash.area[trash.data++] = '\\n';\n\n        DISGUISE(write(1, trash.area, trash.data));\n}\n\n/* Allocate a new HTTP transaction for stream <s> unless there is one already.\n * In case of allocation failure, everything allocated is freed and NULL is\n * returned. Otherwise the new transaction is assigned to the stream and\n * returned.\n */\nstruct http_txn *http_alloc_txn(struct stream *s)\n{\n\tstruct http_txn *txn = s->txn;\n\n\tif (txn)\n\t\treturn txn;\n\n\ttxn = pool_alloc(pool_head_http_txn);\n\tif (!txn)\n\t\treturn txn;\n\n\ts->txn = txn;\n\treturn txn;\n}\n\nvoid http_txn_reset_req(struct http_txn *txn)\n{\n\ttxn->req.flags = 0;\n\ttxn->req.msg_state = HTTP_MSG_RQBEFORE; /* at the very beginning of the request */\n}\n\nvoid http_txn_reset_res(struct http_txn *txn)\n{\n\ttxn->rsp.flags = 0;\n\ttxn->rsp.msg_state = HTTP_MSG_RPBEFORE; /* at the very beginning of the response */\n}\n\n/*\n * Create and initialize a new HTTP transaction for stream <s>. This should be\n * used before processing any new request. It returns the transaction or NLULL\n * on error.\n */\nstruct http_txn *http_create_txn(struct stream *s)\n{\n\tstruct http_txn *txn;\n\tstruct conn_stream *cs = objt_cs(s->si[0].end);\n\n\ttxn = pool_alloc(pool_head_http_txn);\n\tif (!txn)\n\t\treturn NULL;\n\ts->txn = txn;\n\n\ttxn->flags = ((cs && cs->flags & CS_FL_NOT_FIRST) ? TX_NOT_FIRST : 0);\n\ttxn->status = -1;\n\ttxn->http_reply = NULL;\n\twrite_u32(txn->cache_hash, 0);\n\n\ttxn->cookie_first_date = 0;\n\ttxn->cookie_last_date = 0;\n\n\ttxn->srv_cookie = NULL;\n\ttxn->cli_cookie = NULL;\n\ttxn->uri = NULL;\n\n\thttp_txn_reset_req(txn);\n\thttp_txn_reset_res(txn);\n\n\ttxn->req.chn = &s->req;\n\ttxn->rsp.chn = &s->res;\n\n\ttxn->auth.method = HTTP_AUTH_UNKNOWN;\n\n\tvars_init_head(&s->vars_txn,    SCOPE_TXN);\n\tvars_init_head(&s->vars_reqres, SCOPE_REQ);\n\n\treturn txn;\n}\n\n/* to be used at the end of a transaction */\nvoid http_destroy_txn(struct stream *s)\n{\n\tstruct http_txn *txn = s->txn;\n\n\t/* these ones will have been dynamically allocated */\n\tpool_free(pool_head_requri, txn->uri);\n\tpool_free(pool_head_capture, txn->cli_cookie);\n\tpool_free(pool_head_capture, txn->srv_cookie);\n\tpool_free(pool_head_uniqueid, s->unique_id.ptr);\n\n\ts->unique_id = IST_NULL;\n\ttxn->uri = NULL;\n\ttxn->srv_cookie = NULL;\n\ttxn->cli_cookie = NULL;\n\n\tif (!LIST_ISEMPTY(&s->vars_txn.head))\n\t\tvars_prune(&s->vars_txn, s->sess, s);\n\tif (!LIST_ISEMPTY(&s->vars_reqres.head))\n\t\tvars_prune(&s->vars_reqres, s->sess, s);\n\n\tpool_free(pool_head_http_txn, txn);\n\ts->txn = NULL;\n}\n\n\nDECLARE_POOL(pool_head_http_txn, \"http_txn\", sizeof(struct http_txn));\n\n__attribute__((constructor))\nstatic void __http_protocol_init(void)\n{\n}\n\n\n/*\n * Local variables:\n *  c-indent-level: 8\n *  c-basic-offset: 8\n * End:\n */\n"], "filenames": ["src/http_ana.c"], "buggy_code_start_loc": [3421], "buggy_code_end_loc": [3422], "fixing_code_start_loc": [3421], "fixing_code_end_loc": [3422], "type": "CWE-835", "message": "A flaw was found in the way HAProxy processed HTTP responses containing the \"Set-Cookie2\" header. This flaw could allow an attacker to send crafted HTTP response packets which lead to an infinite loop, eventually resulting in a denial of service condition. The highest threat from this vulnerability is availability.", "other": {"cve": {"id": "CVE-2022-0711", "sourceIdentifier": "secalert@redhat.com", "published": "2022-03-02T22:15:08.313", "lastModified": "2022-07-21T12:30:58.467", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A flaw was found in the way HAProxy processed HTTP responses containing the \"Set-Cookie2\" header. This flaw could allow an attacker to send crafted HTTP response packets which lead to an infinite loop, eventually resulting in a denial of service condition. The highest threat from this vulnerability is availability."}, {"lang": "es", "value": "Se ha encontrado un fallo en la forma en que HAProxy procesa las respuestas HTTP que contienen el encabezado \"Set-Cookie2\". Este fallo podr\u00eda permitir a un atacante enviar paquetes de respuesta HTTP dise\u00f1ados que conllevaran a un bucle infinito, resultando eventualmente en una situaci\u00f3n de denegaci\u00f3n de servicio. La mayor amenaza de esta vulnerabilidad es la disponibilidad"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:haproxy:haproxy:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.2.0", "versionEndExcluding": "2.5.2", "matchCriteriaId": "B8577E63-0409-4892-9700-609CB8822C00"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift_container_platform:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "932D137F-528B-4526-9A89-CD59FA1AB0FE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:software_collections:-:*:*:*:*:*:*:*", "matchCriteriaId": "749804DA-4B27-492A-9ABA-6BB562A6B3AC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/cve-2022-0711", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/haproxy/haproxy/commit/bfb15ab34ead85f64cd6da0e9fb418c9cd14cee8", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5102", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.mail-archive.com/haproxy@formilux.org/msg41833.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/haproxy/haproxy/commit/bfb15ab34ead85f64cd6da0e9fb418c9cd14cee8"}}