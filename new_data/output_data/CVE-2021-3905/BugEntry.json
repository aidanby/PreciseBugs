{"buggy_code": ["/*\n * Copyright (c) 2019 Nicira, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <config.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <netinet/in.h>\n#include <netinet/ip6.h>\n#include <netinet/icmp6.h>\n#include <string.h>\n\n#include \"coverage.h\"\n#include \"csum.h\"\n#include \"ipf.h\"\n#include \"latch.h\"\n#include \"openvswitch/hmap.h\"\n#include \"openvswitch/poll-loop.h\"\n#include \"openvswitch/vlog.h\"\n#include \"ovs-atomic.h\"\n#include \"packets.h\"\n#include \"util.h\"\n\nVLOG_DEFINE_THIS_MODULE(ipf);\nCOVERAGE_DEFINE(ipf_stuck_frag_list_purged);\nCOVERAGE_DEFINE(ipf_l3csum_err);\n\nenum {\n    IPV4_PACKET_MAX_HDR_SIZE = 60,\n    IPV4_PACKET_MAX_SIZE = 65535,\n    IPV6_PACKET_MAX_DATA = 65535,\n};\n\nenum ipf_list_state {\n    IPF_LIST_STATE_UNUSED,\n    IPF_LIST_STATE_REASS_FAIL,\n    IPF_LIST_STATE_OTHER_SEEN,\n    IPF_LIST_STATE_FIRST_SEEN,\n    IPF_LIST_STATE_LAST_SEEN,\n    IPF_LIST_STATE_FIRST_LAST_SEEN,\n    IPF_LIST_STATE_COMPLETED,\n    IPF_LIST_STATE_NUM,\n};\n\nstatic char *ipf_state_name[IPF_LIST_STATE_NUM] =\n    {\"unused\", \"reassemble fail\", \"other frag\", \"first frag\", \"last frag\",\n     \"first/last frag\", \"complete\"};\n\nenum ipf_list_type {\n    IPF_FRAG_COMPLETED_LIST,\n    IPF_FRAG_EXPIRY_LIST,\n};\n\nenum {\n    IPF_INVALID_IDX = -1,\n    IPF_V4_FRAG_SIZE_LBOUND = 400,\n    IPF_V4_FRAG_SIZE_MIN_DEF = 1200,\n    IPF_V6_FRAG_SIZE_LBOUND = 400, /* Useful for testing. */\n    IPF_V6_FRAG_SIZE_MIN_DEF = 1280,\n    IPF_MAX_FRAGS_DEFAULT = 1000,\n    IPF_NFRAG_UBOUND = 5000,\n};\n\nenum ipf_counter_type {\n    IPF_NFRAGS_ACCEPTED,\n    IPF_NFRAGS_COMPL_SENT,\n    IPF_NFRAGS_EXPD_SENT,\n    IPF_NFRAGS_TOO_SMALL,\n    IPF_NFRAGS_OVERLAP,\n    IPF_NFRAGS_PURGED,\n    IPF_NFRAGS_NUM_CNTS,\n};\n\nunion ipf_addr {\n    ovs_be32 ipv4;\n    struct in6_addr ipv6;\n};\n\n/* Represents a single fragment; part of a list of fragments. */\nstruct ipf_frag {\n    struct dp_packet *pkt;\n    uint16_t start_data_byte;\n    uint16_t end_data_byte;\n};\n\n/* The key for a collection of fragments potentially making up an unfragmented\n * packet. */\nstruct ipf_list_key {\n    /* ipf_list_key_hash() requires 'src_addr' and 'dst_addr' to be the first\n     * two members. */\n    union ipf_addr src_addr;\n    union ipf_addr dst_addr;\n    uint32_t recirc_id;\n    ovs_be32 ip_id;   /* V6 is 32 bits. */\n    ovs_be16 dl_type;\n    uint16_t zone;\n    uint8_t nw_proto;\n};\n\n/* A collection of fragments potentially making up an unfragmented packet. */\nstruct ipf_list {\n    struct hmap_node node;         /* In struct ipf's 'frag_lists'. */\n    struct ovs_list list_node;     /* In struct ipf's 'frag_exp_list' or\n                                    * 'frag_complete_list'. */\n    struct ipf_frag *frag_list;    /* List of fragments for this list. */\n    struct ipf_list_key key;       /* The key for the fragemnt list. */\n    struct dp_packet *reass_execute_ctx; /* Reassembled packet. */\n    long long expiration;          /* In milliseconds. */\n    int last_sent_idx;             /* Last sent fragment idx. */\n    int last_inuse_idx;            /* Last inuse fragment idx. */\n    int size;                      /* Fragment list size. */\n    uint8_t state;                 /* Frag list state; see ipf_list_state. */\n};\n\n/* Represents a reassambled packet which typically is passed through\n * conntrack. */\nstruct reassembled_pkt {\n    struct ovs_list rp_list_node;  /* In struct ipf's\n                                    * 'reassembled_pkt_list'. */\n    struct dp_packet *pkt;\n    struct ipf_list *list;\n};\n\nstruct ipf {\n    /* The clean thread is used to clean up fragments in the 'ipf'\n     * module if packet batches are not longer be sent through its user. */\n    pthread_t ipf_clean_thread;\n    struct latch ipf_clean_thread_exit;\n\n    int max_v4_frag_list_size;\n\n    struct ovs_mutex ipf_lock; /* Protects all of the following. */\n    /* These contain 'struct ipf_list's. */\n    struct hmap frag_lists OVS_GUARDED;\n    struct ovs_list frag_exp_list OVS_GUARDED;\n    struct ovs_list frag_complete_list OVS_GUARDED;\n    /* Contains 'struct reassembled_pkt's. */\n    struct ovs_list reassembled_pkt_list OVS_GUARDED;\n\n    /* Used to allow disabling fragmentation reassembly. */\n    atomic_bool ifp_v4_enabled;\n    atomic_bool ifp_v6_enabled;\n\n    /* Will be clamped above 400 bytes; the value chosen should handle\n     * alg control packets of interest that use string encoding of mutable\n     * IP fields; meaning, the control packets should not be fragmented. */\n    atomic_uint min_v4_frag_size;\n    atomic_uint min_v6_frag_size;\n\n    /* Configurable maximum allowable fragments in process. */\n    atomic_uint nfrag_max;\n\n    /* Number of fragments in process. */\n    atomic_count nfrag;\n\n    atomic_uint64_t n4frag_cnt[IPF_NFRAGS_NUM_CNTS];\n    atomic_uint64_t n6frag_cnt[IPF_NFRAGS_NUM_CNTS];\n};\n\nstatic void\nipf_print_reass_packet(const char *es, const void *pkt)\n{\n    static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(10, 10);\n    if (!VLOG_DROP_WARN(&rl)) {\n        struct ds ds = DS_EMPTY_INITIALIZER;\n        ds_put_hex_dump(&ds, pkt, 128, 0, false);\n        VLOG_WARN(\"%s\\n%s\", es, ds_cstr(&ds));\n        ds_destroy(&ds);\n    }\n}\n\nstatic void\nipf_count(struct ipf *ipf, bool v6, enum ipf_counter_type cntr)\n{\n    atomic_count_inc64(v6 ? &ipf->n6frag_cnt[cntr] : &ipf->n4frag_cnt[cntr]);\n}\n\nstatic bool\nipf_get_v4_enabled(struct ipf *ipf)\n{\n    bool ifp_v4_enabled_;\n    atomic_read_relaxed(&ipf->ifp_v4_enabled, &ifp_v4_enabled_);\n    return ifp_v4_enabled_;\n}\n\nstatic bool\nipf_get_v6_enabled(struct ipf *ipf)\n{\n    bool ifp_v6_enabled_;\n    atomic_read_relaxed(&ipf->ifp_v6_enabled, &ifp_v6_enabled_);\n    return ifp_v6_enabled_;\n}\n\nstatic bool\nipf_get_enabled(struct ipf *ipf)\n{\n    return ipf_get_v4_enabled(ipf) || ipf_get_v6_enabled(ipf);\n}\n\nstatic uint32_t\nipf_addr_hash_add(uint32_t hash, const union ipf_addr *addr)\n{\n    BUILD_ASSERT_DECL(sizeof *addr % 4 == 0);\n    return hash_add_bytes32(hash, (const uint32_t *) addr, sizeof *addr);\n}\n\n/* Adds a list of fragments to the list tracking expiry of yet to be\n * completed reassembled packets, hence subject to expirty. */\nstatic void\nipf_expiry_list_add(struct ovs_list *frag_exp_list, struct ipf_list *ipf_list,\n                    long long now)\n   /* OVS_REQUIRES(ipf->ipf_lock) */\n{\n    enum {\n        IPF_FRAG_LIST_TIMEOUT = 15000,\n    };\n\n    ipf_list->expiration = now + IPF_FRAG_LIST_TIMEOUT;\n    ovs_list_push_back(frag_exp_list, &ipf_list->list_node);\n}\n\n/* Adds a list of fragments to the list of completed packets, which will be\n * subsequently transmitted. */\nstatic void\nipf_completed_list_add(struct ovs_list *frag_complete_list,\n                       struct ipf_list *ipf_list)\n    /* OVS_REQUIRES(ipf_lock) */\n{\n    ovs_list_push_back(frag_complete_list, &ipf_list->list_node);\n}\n\n/* Adds a reassmebled packet to the list of reassembled packets, awaiting some\n * processing, such as being sent through conntrack. */\nstatic void\nipf_reassembled_list_add(struct ovs_list *reassembled_pkt_list,\n                         struct reassembled_pkt *rp)\n    /* OVS_REQUIRES(ipf_lock) */\n{\n    ovs_list_push_back(reassembled_pkt_list, &rp->rp_list_node);\n}\n\n/* Removed a frag list from tracking datastructures and frees list heap\n * memory. */\nstatic void\nipf_list_clean(struct hmap *frag_lists,\n               struct ipf_list *ipf_list)\n    /* OVS_REQUIRES(ipf_lock) */\n{\n    ovs_list_remove(&ipf_list->list_node);\n    hmap_remove(frag_lists, &ipf_list->node);\n    free(ipf_list->frag_list);\n    free(ipf_list);\n}\n\n/* Removed a frag list sitting on the expiry list from tracking\n * datastructures and frees list heap memory. */\nstatic void\nipf_expiry_list_clean(struct hmap *frag_lists,\n                      struct ipf_list *ipf_list)\n    /* OVS_REQUIRES(ipf_lock) */\n{\n    ipf_list_clean(frag_lists, ipf_list);\n}\n\n/* Removed a frag list sitting on the completed list from tracking\n * datastructures and frees list heap memory. */\nstatic void\nipf_completed_list_clean(struct hmap *frag_lists,\n                         struct ipf_list *ipf_list)\n    /* OVS_REQUIRES(ipf_lock) */\n{\n    ipf_list_clean(frag_lists, ipf_list);\n}\n\nstatic void\nipf_expiry_list_remove(struct ipf_list *ipf_list)\n    /* OVS_REQUIRES(ipf_lock) */\n{\n    ovs_list_remove(&ipf_list->list_node);\n}\n\nstatic void\nipf_reassembled_list_remove(struct reassembled_pkt *rp)\n    /* OVS_REQUIRES(ipf_lock) */\n{\n    ovs_list_remove(&rp->rp_list_node);\n}\n\n/* Symmetric */\nstatic uint32_t\nipf_list_key_hash(const struct ipf_list_key *key, uint32_t basis)\n{\n    uint32_t hsrc, hdst, hash;\n    hsrc = hdst = basis;\n    hsrc = ipf_addr_hash_add(hsrc, &key->src_addr);\n    hdst = ipf_addr_hash_add(hdst, &key->dst_addr);\n    hash = hsrc ^ hdst;\n\n    /* Hash the rest of the key. */\n    return hash_words((uint32_t *) (&key->dst_addr + 1),\n                      (uint32_t *) (key + 1) -\n                      (uint32_t *) (&key->dst_addr + 1),\n                      hash);\n}\n\nstatic bool\nipf_is_first_v4_frag(const struct dp_packet *pkt)\n{\n    const struct ip_header *l3 = dp_packet_l3(pkt);\n    if (!(l3->ip_frag_off & htons(IP_FRAG_OFF_MASK)) &&\n        l3->ip_frag_off & htons(IP_MORE_FRAGMENTS)) {\n        return true;\n    }\n    return false;\n}\n\nstatic bool\nipf_is_last_v4_frag(const struct dp_packet *pkt)\n{\n    const struct ip_header *l3 = dp_packet_l3(pkt);\n    if (l3->ip_frag_off & htons(IP_FRAG_OFF_MASK) &&\n        !(l3->ip_frag_off & htons(IP_MORE_FRAGMENTS))) {\n        return true;\n    }\n    return false;\n}\n\nstatic bool\nipf_is_v6_frag(ovs_be16 ip6f_offlg)\n{\n    if (ip6f_offlg & (IP6F_OFF_MASK | IP6F_MORE_FRAG)) {\n        return true;\n    }\n    return false;\n}\n\nstatic bool\nipf_is_first_v6_frag(ovs_be16 ip6f_offlg)\n{\n    if (!(ip6f_offlg & IP6F_OFF_MASK) &&\n        ip6f_offlg & IP6F_MORE_FRAG) {\n        return true;\n    }\n    return false;\n}\n\nstatic bool\nipf_is_last_v6_frag(ovs_be16 ip6f_offlg)\n{\n    if ((ip6f_offlg & IP6F_OFF_MASK) &&\n        !(ip6f_offlg & IP6F_MORE_FRAG)) {\n        return true;\n    }\n    return false;\n}\n\n/* Checks for a completed packet collection of fragments. */\nstatic bool\nipf_list_complete(const struct ipf_list *ipf_list)\n    /* OVS_REQUIRES(ipf_lock) */\n{\n    for (int i = 1; i <= ipf_list->last_inuse_idx; i++) {\n        if (ipf_list->frag_list[i - 1].end_data_byte + 1\n            != ipf_list->frag_list[i].start_data_byte) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/* Runs O(n) for a sorted or almost sorted list. */\nstatic void\nipf_sort(struct ipf_frag *frag_list, size_t last_idx)\n    /* OVS_REQUIRES(ipf_lock) */\n{\n    for (int li = 1; li <= last_idx; li++) {\n        struct ipf_frag ipf_frag = frag_list[li];\n        int ci = li - 1;\n        while (ci >= 0 &&\n               frag_list[ci].start_data_byte > ipf_frag.start_data_byte) {\n            frag_list[ci + 1] = frag_list[ci];\n            ci--;\n        }\n        frag_list[ci + 1] = ipf_frag;\n    }\n}\n\n/* Called on a sorted complete list of v4 fragments to reassemble them into\n * a single packet that can be processed, such as passing through conntrack.\n */\nstatic struct dp_packet *\nipf_reassemble_v4_frags(struct ipf_list *ipf_list)\n    /* OVS_REQUIRES(ipf_lock) */\n{\n    struct ipf_frag *frag_list = ipf_list->frag_list;\n    struct dp_packet *pkt = dp_packet_clone(frag_list[0].pkt);\n    dp_packet_set_size(pkt, dp_packet_size(pkt) - dp_packet_l2_pad_size(pkt));\n    struct ip_header *l3 = dp_packet_l3(pkt);\n    int len = ntohs(l3->ip_tot_len);\n\n    int rest_len = frag_list[ipf_list->last_inuse_idx].end_data_byte -\n                   frag_list[1].start_data_byte + 1;\n\n    if (len + rest_len > IPV4_PACKET_MAX_SIZE) {\n        ipf_print_reass_packet(\n            \"Unsupported big reassembled v4 packet; v4 hdr:\", l3);\n        dp_packet_delete(pkt);\n        return NULL;\n    }\n\n    dp_packet_prealloc_tailroom(pkt, rest_len);\n\n    for (int i = 1; i <= ipf_list->last_inuse_idx; i++) {\n        size_t add_len = frag_list[i].end_data_byte -\n                         frag_list[i].start_data_byte + 1;\n        const char *l4 = dp_packet_l4(frag_list[i].pkt);\n        dp_packet_put(pkt, l4, add_len);\n    }\n\n    len += rest_len;\n    l3 = dp_packet_l3(pkt);\n    ovs_be16 new_ip_frag_off = l3->ip_frag_off & ~htons(IP_MORE_FRAGMENTS);\n    if (!dp_packet_hwol_is_ipv4(pkt)) {\n        l3->ip_csum = recalc_csum16(l3->ip_csum, l3->ip_frag_off,\n                                    new_ip_frag_off);\n        l3->ip_csum = recalc_csum16(l3->ip_csum, l3->ip_tot_len, htons(len));\n    }\n    l3->ip_tot_len = htons(len);\n    l3->ip_frag_off = new_ip_frag_off;\n    dp_packet_set_l2_pad_size(pkt, 0);\n\n    return pkt;\n}\n\n/* Called on a sorted complete list of v6 fragments to reassemble them into\n * a single packet that can be processed, such as passing through conntrack.\n */\nstatic struct dp_packet *\nipf_reassemble_v6_frags(struct ipf_list *ipf_list)\n    /* OVS_REQUIRES(ipf_lock) */\n{\n    struct ipf_frag *frag_list = ipf_list->frag_list;\n    struct dp_packet *pkt = dp_packet_clone(frag_list[0].pkt);\n    dp_packet_set_size(pkt, dp_packet_size(pkt) - dp_packet_l2_pad_size(pkt));\n    struct  ovs_16aligned_ip6_hdr *l3 = dp_packet_l3(pkt);\n    int pl = ntohs(l3->ip6_plen) - sizeof(struct ovs_16aligned_ip6_frag);\n\n    int rest_len = frag_list[ipf_list->last_inuse_idx].end_data_byte -\n                   frag_list[1].start_data_byte + 1;\n\n    if (pl + rest_len > IPV6_PACKET_MAX_DATA) {\n        ipf_print_reass_packet(\n             \"Unsupported big reassembled v6 packet; v6 hdr:\", l3);\n        dp_packet_delete(pkt);\n        return NULL;\n    }\n\n    dp_packet_prealloc_tailroom(pkt, rest_len);\n\n    for (int i = 1; i <= ipf_list->last_inuse_idx; i++) {\n        size_t add_len = frag_list[i].end_data_byte -\n                          frag_list[i].start_data_byte + 1;\n        const char *l4 = dp_packet_l4(frag_list[i].pkt);\n        dp_packet_put(pkt, l4, add_len);\n    }\n\n    pl += rest_len;\n    l3 = dp_packet_l3(pkt);\n\n    uint8_t nw_proto = l3->ip6_nxt;\n    uint8_t nw_frag = 0;\n    const void *data = l3 + 1;\n    size_t datasize = pl;\n\n    const struct ovs_16aligned_ip6_frag *frag_hdr = NULL;\n    if (!parse_ipv6_ext_hdrs(&data, &datasize, &nw_proto, &nw_frag, &frag_hdr)\n        || !nw_frag || !frag_hdr) {\n\n        ipf_print_reass_packet(\"Unparsed reassembled v6 packet; v6 hdr:\", l3);\n        dp_packet_delete(pkt);\n        return NULL;\n    }\n\n    struct ovs_16aligned_ip6_frag *fh =\n        CONST_CAST(struct ovs_16aligned_ip6_frag *, frag_hdr);\n    fh->ip6f_offlg = 0;\n    l3->ip6_plen = htons(pl);\n    l3->ip6_ctlun.ip6_un1.ip6_un1_nxt = nw_proto;\n    dp_packet_set_l2_pad_size(pkt, 0);\n    return pkt;\n}\n\n/* Called when a frag list state transitions to another state. This is\n * triggered by new fragment for the list being received.*/\nstatic void\nipf_list_state_transition(struct ipf *ipf, struct ipf_list *ipf_list,\n                          bool ff, bool lf, bool v6)\n    OVS_REQUIRES(ipf->ipf_lock)\n{\n    enum ipf_list_state curr_state = ipf_list->state;\n    enum ipf_list_state next_state;\n    switch (curr_state) {\n    case IPF_LIST_STATE_UNUSED:\n    case IPF_LIST_STATE_OTHER_SEEN:\n        if (ff) {\n            next_state = IPF_LIST_STATE_FIRST_SEEN;\n        } else if (lf) {\n            next_state = IPF_LIST_STATE_LAST_SEEN;\n        } else {\n            next_state = IPF_LIST_STATE_OTHER_SEEN;\n        }\n        break;\n    case IPF_LIST_STATE_FIRST_SEEN:\n        if (lf) {\n            next_state = IPF_LIST_STATE_FIRST_LAST_SEEN;\n        } else {\n            next_state = IPF_LIST_STATE_FIRST_SEEN;\n        }\n        break;\n    case IPF_LIST_STATE_LAST_SEEN:\n        if (ff) {\n            next_state = IPF_LIST_STATE_FIRST_LAST_SEEN;\n        } else {\n            next_state = IPF_LIST_STATE_LAST_SEEN;\n        }\n        break;\n    case IPF_LIST_STATE_FIRST_LAST_SEEN:\n        next_state = IPF_LIST_STATE_FIRST_LAST_SEEN;\n        break;\n    case IPF_LIST_STATE_COMPLETED:\n    case IPF_LIST_STATE_REASS_FAIL:\n    case IPF_LIST_STATE_NUM:\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    if (next_state == IPF_LIST_STATE_FIRST_LAST_SEEN) {\n        ipf_sort(ipf_list->frag_list, ipf_list->last_inuse_idx);\n        if (ipf_list_complete(ipf_list)) {\n            struct dp_packet *reass_pkt = v6\n                ? ipf_reassemble_v6_frags(ipf_list)\n                : ipf_reassemble_v4_frags(ipf_list);\n            if (reass_pkt) {\n                struct reassembled_pkt *rp = xzalloc(sizeof *rp);\n                rp->pkt = reass_pkt;\n                rp->list = ipf_list;\n                ipf_reassembled_list_add(&ipf->reassembled_pkt_list, rp);\n                ipf_expiry_list_remove(ipf_list);\n                next_state = IPF_LIST_STATE_COMPLETED;\n            } else {\n                next_state = IPF_LIST_STATE_REASS_FAIL;\n            }\n        }\n    }\n    ipf_list->state = next_state;\n}\n\n/* Some sanity checks are redundant, but prudent, in case code paths for\n * fragments change in future. The processing cost for fragments is not\n * important. */\nstatic bool\nipf_is_valid_v4_frag(struct ipf *ipf, struct dp_packet *pkt)\n{\n    if (OVS_UNLIKELY(dp_packet_ip_checksum_bad(pkt))) {\n        COVERAGE_INC(ipf_l3csum_err);\n        goto invalid_pkt;\n    }\n\n    const struct eth_header *l2 = dp_packet_eth(pkt);\n    const struct ip_header *l3 = dp_packet_l3(pkt);\n\n    if (OVS_UNLIKELY(!l2 || !l3)) {\n        goto invalid_pkt;\n    }\n\n    size_t l3_size = dp_packet_l3_size(pkt);\n    if (OVS_UNLIKELY(l3_size < IP_HEADER_LEN)) {\n        goto invalid_pkt;\n    }\n\n    if (!IP_IS_FRAGMENT(l3->ip_frag_off)) {\n        return false;\n    }\n\n    uint16_t ip_tot_len = ntohs(l3->ip_tot_len);\n    if (OVS_UNLIKELY(ip_tot_len != l3_size)) {\n        goto invalid_pkt;\n    }\n\n    size_t ip_hdr_len = IP_IHL(l3->ip_ihl_ver) * 4;\n    if (OVS_UNLIKELY(ip_hdr_len < IP_HEADER_LEN)) {\n        goto invalid_pkt;\n    }\n    if (OVS_UNLIKELY(l3_size < ip_hdr_len)) {\n        goto invalid_pkt;\n    }\n\n    if (OVS_UNLIKELY(!dp_packet_ip_checksum_valid(pkt)\n                     && !dp_packet_hwol_is_ipv4(pkt)\n                     && csum(l3, ip_hdr_len) != 0)) {\n        COVERAGE_INC(ipf_l3csum_err);\n        goto invalid_pkt;\n    }\n\n    uint32_t min_v4_frag_size_;\n    atomic_read_relaxed(&ipf->min_v4_frag_size, &min_v4_frag_size_);\n    bool lf = ipf_is_last_v4_frag(pkt);\n    if (OVS_UNLIKELY(!lf && dp_packet_l3_size(pkt) < min_v4_frag_size_)) {\n        ipf_count(ipf, false, IPF_NFRAGS_TOO_SMALL);\n        goto invalid_pkt;\n    }\n    return true;\n\ninvalid_pkt:\n    pkt->md.ct_state = CS_INVALID;\n    return false;\n}\n\nstatic bool\nipf_v4_key_extract(struct dp_packet *pkt, ovs_be16 dl_type, uint16_t zone,\n                   struct ipf_list_key *key, uint16_t *start_data_byte,\n                   uint16_t *end_data_byte, bool *ff, bool *lf)\n{\n    const struct ip_header *l3 = dp_packet_l3(pkt);\n    uint16_t ip_tot_len = ntohs(l3->ip_tot_len);\n    size_t ip_hdr_len = IP_IHL(l3->ip_ihl_ver) * 4;\n\n    *start_data_byte = ntohs(l3->ip_frag_off & htons(IP_FRAG_OFF_MASK)) * 8;\n    *end_data_byte = *start_data_byte + ip_tot_len - ip_hdr_len - 1;\n    *ff = ipf_is_first_v4_frag(pkt);\n    *lf = ipf_is_last_v4_frag(pkt);\n    memset(key, 0, sizeof *key);\n    key->ip_id = be16_to_be32(l3->ip_id);\n    key->dl_type = dl_type;\n    key->src_addr.ipv4 = get_16aligned_be32(&l3->ip_src);\n    key->dst_addr.ipv4 = get_16aligned_be32(&l3->ip_dst);\n    key->nw_proto = l3->ip_proto;\n    key->zone = zone;\n    key->recirc_id = pkt->md.recirc_id;\n    return true;\n}\n\n/* Some sanity checks are redundant, but prudent, in case code paths for\n * fragments change in future. The processing cost for fragments is not\n * important. */\nstatic bool\nipf_is_valid_v6_frag(struct ipf *ipf, struct dp_packet *pkt)\n{\n    const struct eth_header *l2 = dp_packet_eth(pkt);\n    const struct  ovs_16aligned_ip6_hdr *l3 = dp_packet_l3(pkt);\n    const char *l4 = dp_packet_l4(pkt);\n\n    if (OVS_UNLIKELY(!l2 || !l3 || !l4)) {\n        goto invalid_pkt;\n    }\n\n    size_t l3_size = dp_packet_l3_size(pkt);\n    size_t l3_hdr_size = sizeof *l3;\n\n    if (OVS_UNLIKELY(l3_size < l3_hdr_size)) {\n        goto invalid_pkt;\n    }\n\n    uint8_t nw_frag = 0;\n    uint8_t nw_proto = l3->ip6_nxt;\n    const void *data = l3 + 1;\n    size_t datasize = l3_size - l3_hdr_size;\n    const struct ovs_16aligned_ip6_frag *frag_hdr = NULL;\n    if (!parse_ipv6_ext_hdrs(&data, &datasize, &nw_proto, &nw_frag,\n                             &frag_hdr) || !nw_frag || !frag_hdr) {\n        return false;\n    }\n\n    int pl = ntohs(l3->ip6_plen);\n    if (OVS_UNLIKELY(pl + l3_hdr_size != l3_size)) {\n        goto invalid_pkt;\n    }\n\n    ovs_be16 ip6f_offlg = frag_hdr->ip6f_offlg;\n    if (OVS_UNLIKELY(!ipf_is_v6_frag(ip6f_offlg))) {\n        return false;\n    }\n\n    uint32_t min_v6_frag_size_;\n    atomic_read_relaxed(&ipf->min_v6_frag_size, &min_v6_frag_size_);\n    bool lf = ipf_is_last_v6_frag(ip6f_offlg);\n\n    if (OVS_UNLIKELY(!lf && dp_packet_l3_size(pkt) < min_v6_frag_size_)) {\n        ipf_count(ipf, true, IPF_NFRAGS_TOO_SMALL);\n        goto invalid_pkt;\n    }\n\n    return true;\n\ninvalid_pkt:\n    pkt->md.ct_state = CS_INVALID;\n    return false;\n\n}\n\nstatic void\nipf_v6_key_extract(struct dp_packet *pkt, ovs_be16 dl_type, uint16_t zone,\n                   struct ipf_list_key *key, uint16_t *start_data_byte,\n                   uint16_t *end_data_byte, bool *ff, bool *lf)\n{\n    const struct ovs_16aligned_ip6_hdr *l3 = dp_packet_l3(pkt);\n    uint8_t nw_frag = 0;\n    uint8_t nw_proto = l3->ip6_nxt;\n    const void *data = l3 + 1;\n    size_t datasize = dp_packet_l3_size(pkt) - sizeof *l3;\n    const struct ovs_16aligned_ip6_frag *frag_hdr = NULL;\n\n    parse_ipv6_ext_hdrs(&data, &datasize, &nw_proto, &nw_frag, &frag_hdr);\n    ovs_assert(nw_frag && frag_hdr);\n    ovs_be16 ip6f_offlg = frag_hdr->ip6f_offlg;\n    *start_data_byte = ntohs(ip6f_offlg & IP6F_OFF_MASK) +\n        sizeof (struct ovs_16aligned_ip6_frag);\n    *end_data_byte = *start_data_byte + dp_packet_l4_size(pkt) - 1;\n    *ff = ipf_is_first_v6_frag(ip6f_offlg);\n    *lf = ipf_is_last_v6_frag(ip6f_offlg);\n    memset(key, 0, sizeof *key);\n    key->ip_id = get_16aligned_be32(&frag_hdr->ip6f_ident);\n    key->dl_type = dl_type;\n    memcpy(&key->src_addr.ipv6, &l3->ip6_src, sizeof key->src_addr.ipv6);\n    /* We are not supporting parsing of the routing header to use as the\n     * dst address part of the key. */\n    memcpy(&key->dst_addr.ipv6, &l3->ip6_dst, sizeof key->dst_addr.ipv6);\n    key->nw_proto = 0;   /* Not used for key for V6. */\n    key->zone = zone;\n    key->recirc_id = pkt->md.recirc_id;\n}\n\nstatic bool\nipf_list_key_eq(const struct ipf_list_key *key1,\n                const struct ipf_list_key *key2)\n    /* OVS_REQUIRES(ipf_lock) */\n{\n    if (!memcmp(&key1->src_addr, &key2->src_addr, sizeof key1->src_addr) &&\n        !memcmp(&key1->dst_addr, &key2->dst_addr, sizeof key1->dst_addr) &&\n        key1->dl_type == key2->dl_type &&\n        key1->ip_id == key2->ip_id &&\n        key1->zone == key2->zone &&\n        key1->nw_proto == key2->nw_proto &&\n        key1->recirc_id == key2->recirc_id) {\n        return true;\n    }\n    return false;\n}\n\nstatic struct ipf_list *\nipf_list_key_lookup(struct ipf *ipf, const struct ipf_list_key *key,\n                    uint32_t hash)\n    OVS_REQUIRES(ipf->ipf_lock)\n{\n    struct ipf_list *ipf_list;\n    HMAP_FOR_EACH_WITH_HASH (ipf_list, node, hash, &ipf->frag_lists) {\n        if (ipf_list_key_eq(&ipf_list->key, key)) {\n            return ipf_list;\n        }\n    }\n    return NULL;\n}\n\nstatic bool\nipf_is_frag_duped(const struct ipf_frag *frag_list, int last_inuse_idx,\n                  size_t start_data_byte, size_t end_data_byte)\n    /* OVS_REQUIRES(ipf_lock) */\n{\n    for (int i = 0; i <= last_inuse_idx; i++) {\n        if ((start_data_byte >= frag_list[i].start_data_byte &&\n            start_data_byte <= frag_list[i].end_data_byte) ||\n            (end_data_byte >= frag_list[i].start_data_byte &&\n             end_data_byte <= frag_list[i].end_data_byte)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/* Adds a fragment to a list of fragments, if the fragment is not a\n * duplicate. If the fragment is a duplicate, that fragment is marked\n * invalid to avoid the work that conntrack would do to mark the fragment\n * as invalid, which it will in all cases. */\nstatic bool\nipf_process_frag(struct ipf *ipf, struct ipf_list *ipf_list,\n                 struct dp_packet *pkt, uint16_t start_data_byte,\n                 uint16_t end_data_byte, bool ff, bool lf, bool v6)\n    OVS_REQUIRES(ipf->ipf_lock)\n{\n    bool duped_frag = ipf_is_frag_duped(ipf_list->frag_list,\n        ipf_list->last_inuse_idx, start_data_byte, end_data_byte);\n    int last_inuse_idx = ipf_list->last_inuse_idx;\n\n    if (!duped_frag) {\n        if (last_inuse_idx < ipf_list->size - 1) {\n            /* In the case of dpdk, it would be unfortunate if we had\n             * to create a clone fragment outside the dpdk mp due to the\n             * mempool size being too limited. We will otherwise need to\n             * recommend not setting the mempool number of buffers too low\n             * and also clamp the number of fragments. */\n            struct ipf_frag *frag = &ipf_list->frag_list[last_inuse_idx + 1];\n            frag->pkt = dp_packet_clone(pkt);\n            frag->start_data_byte = start_data_byte;\n            frag->end_data_byte = end_data_byte;\n            ipf_list->last_inuse_idx++;\n            atomic_count_inc(&ipf->nfrag);\n            ipf_count(ipf, v6, IPF_NFRAGS_ACCEPTED);\n            ipf_list_state_transition(ipf, ipf_list, ff, lf, v6);\n        } else {\n            OVS_NOT_REACHED();\n        }\n    } else {\n        ipf_count(ipf, v6, IPF_NFRAGS_OVERLAP);\n        pkt->md.ct_state = CS_INVALID;\n        return false;\n    }\n    return true;\n}\n\nstatic void\nipf_list_init(struct ipf_list *ipf_list, struct ipf_list_key *key,\n              int max_frag_list_size)\n{\n    ipf_list->key = *key;\n    ipf_list->last_inuse_idx = IPF_INVALID_IDX;\n    ipf_list->last_sent_idx = IPF_INVALID_IDX;\n    ipf_list->reass_execute_ctx = NULL;\n    ipf_list->state = IPF_LIST_STATE_UNUSED;\n    ipf_list->size = max_frag_list_size;\n    ipf_list->frag_list\n        = xzalloc(ipf_list->size * sizeof *ipf_list->frag_list);\n}\n\n/* Generates a fragment list key from a well formed fragment and either starts\n * a new fragment list or increases the size of the existing fragment list,\n * while checking if the maximum supported fragements are supported or the\n * list size is impossibly big. Calls 'ipf_process_frag()' to add a fragment\n * to a list of fragemnts. */\nstatic bool\nipf_handle_frag(struct ipf *ipf, struct dp_packet *pkt, ovs_be16 dl_type,\n                uint16_t zone, long long now, uint32_t hash_basis)\n    OVS_REQUIRES(ipf->ipf_lock)\n{\n    struct ipf_list_key key;\n    /* Initialize 4 variables for some versions of GCC. */\n    uint16_t start_data_byte = 0;\n    uint16_t end_data_byte = 0;\n    bool ff = false;\n    bool lf = false;\n    bool v6 = dl_type == htons(ETH_TYPE_IPV6);\n\n    if (v6 && ipf_get_v6_enabled(ipf)) {\n        ipf_v6_key_extract(pkt, dl_type, zone, &key, &start_data_byte,\n                           &end_data_byte, &ff, &lf);\n    } else if (!v6 && ipf_get_v4_enabled(ipf)) {\n        ipf_v4_key_extract(pkt, dl_type, zone, &key, &start_data_byte,\n                           &end_data_byte, &ff, &lf);\n    } else {\n        return false;\n    }\n\n    unsigned int nfrag_max;\n    atomic_read_relaxed(&ipf->nfrag_max, &nfrag_max);\n    if (atomic_count_get(&ipf->nfrag) >= nfrag_max) {\n        return false;\n    }\n\n    uint32_t hash = ipf_list_key_hash(&key, hash_basis);\n    struct ipf_list *ipf_list = ipf_list_key_lookup(ipf, &key, hash);\n    enum {\n        IPF_FRAG_LIST_MIN_INCREMENT = 4,\n        IPF_IPV6_MAX_FRAG_LIST_SIZE = 65535,\n    };\n\n    int max_frag_list_size;\n    if (v6) {\n        /* Because the calculation with extension headers is variable,\n         * we don't calculate a hard maximum fragment list size upfront.  The\n         * fragment list size is practically limited by the code, however. */\n        max_frag_list_size = IPF_IPV6_MAX_FRAG_LIST_SIZE;\n    } else {\n        max_frag_list_size = ipf->max_v4_frag_list_size;\n    }\n\n    if (!ipf_list) {\n        ipf_list = xmalloc(sizeof *ipf_list);\n        ipf_list_init(ipf_list, &key,\n                      MIN(max_frag_list_size, IPF_FRAG_LIST_MIN_INCREMENT));\n        hmap_insert(&ipf->frag_lists, &ipf_list->node, hash);\n        ipf_expiry_list_add(&ipf->frag_exp_list, ipf_list, now);\n    } else if (ipf_list->state == IPF_LIST_STATE_REASS_FAIL ||\n               ipf_list->state == IPF_LIST_STATE_COMPLETED) {\n        /* Bail out as early as possible. */\n        return false;\n    } else if (ipf_list->last_inuse_idx + 1 >= ipf_list->size) {\n        int increment = MIN(IPF_FRAG_LIST_MIN_INCREMENT,\n                            max_frag_list_size - ipf_list->size);\n        /* Enforce limit. */\n        if (increment > 0) {\n            ipf_list->frag_list =\n                xrealloc(ipf_list->frag_list, (ipf_list->size + increment) *\n                  sizeof *ipf_list->frag_list);\n            ipf_list->size += increment;\n        } else {\n            return false;\n        }\n    }\n\n    return ipf_process_frag(ipf, ipf_list, pkt, start_data_byte,\n                            end_data_byte, ff, lf, v6);\n}\n\n/* Filters out fragments from a batch of fragments and adjust the batch. */\nstatic void\nipf_extract_frags_from_batch(struct ipf *ipf, struct dp_packet_batch *pb,\n                             ovs_be16 dl_type, uint16_t zone, long long now,\n                             uint32_t hash_basis)\n{\n    const size_t pb_cnt = dp_packet_batch_size(pb);\n    int pb_idx; /* Index in a packet batch. */\n    struct dp_packet *pkt;\n\n    DP_PACKET_BATCH_REFILL_FOR_EACH (pb_idx, pb_cnt, pkt, pb) {\n        if (OVS_UNLIKELY((dl_type == htons(ETH_TYPE_IP) &&\n                          ipf_is_valid_v4_frag(ipf, pkt))\n                          ||\n                          (dl_type == htons(ETH_TYPE_IPV6) &&\n                          ipf_is_valid_v6_frag(ipf, pkt)))) {\n\n            ovs_mutex_lock(&ipf->ipf_lock);\n            if (!ipf_handle_frag(ipf, pkt, dl_type, zone, now, hash_basis)) {\n                dp_packet_batch_refill(pb, pkt, pb_idx);\n            }\n            ovs_mutex_unlock(&ipf->ipf_lock);\n        } else {\n            dp_packet_batch_refill(pb, pkt, pb_idx);\n        }\n    }\n}\n\n/* In case of DPDK, a memory source check is done, as DPDK memory pool\n * management has trouble dealing with multiple source types.  The\n * check_source paramater is used to indicate when this check is needed. */\nstatic bool\nipf_dp_packet_batch_add(struct dp_packet_batch *pb , struct dp_packet *pkt,\n                        bool check_source OVS_UNUSED)\n{\n#ifdef DPDK_NETDEV\n    if ((dp_packet_batch_is_full(pb)) ||\n        /* DPDK cannot handle multiple sources in a batch. */\n        (check_source && !dp_packet_batch_is_empty(pb)\n         && pb->packets[0]->source != pkt->source)) {\n#else\n    if (dp_packet_batch_is_full(pb)) {\n#endif\n        return false;\n    }\n\n    dp_packet_batch_add(pb, pkt);\n    return true;\n}\n\n/* This would be used in rare cases where a list cannot be sent. One rare\n * reason known right now is a mempool source check, which exists due to DPDK\n * support, where packets are no longer being received on any port with a\n * source matching the fragment.  Another reason is a race where all\n * conntrack rules are unconfigured when some fragments are yet to be\n * flushed.\n *\n * Returns true if the list was purged. */\nstatic bool\nipf_purge_list_check(struct ipf *ipf, struct ipf_list *ipf_list,\n                     long long now)\n    OVS_REQUIRES(ipf->ipf_lock)\n{\n    enum {\n        IPF_FRAG_LIST_PURGE_TIME_ADJ = 10000\n    };\n\n    if (now < ipf_list->expiration + IPF_FRAG_LIST_PURGE_TIME_ADJ) {\n        return false;\n    }\n\n    while (ipf_list->last_sent_idx < ipf_list->last_inuse_idx) {\n        struct dp_packet * pkt\n            = ipf_list->frag_list[ipf_list->last_sent_idx + 1].pkt;\n        dp_packet_delete(pkt);\n        atomic_count_dec(&ipf->nfrag);\n        COVERAGE_INC(ipf_stuck_frag_list_purged);\n        ipf_count(ipf, ipf_list->key.dl_type == htons(ETH_TYPE_IPV6),\n                  IPF_NFRAGS_PURGED);\n        ipf_list->last_sent_idx++;\n    }\n\n    return true;\n}\n\n/* Does the packet batch management and common accounting work associated\n * with 'ipf_send_completed_frags()' and 'ipf_send_expired_frags()'. */\nstatic bool\nipf_send_frags_in_list(struct ipf *ipf, struct ipf_list *ipf_list,\n                       struct dp_packet_batch *pb,\n                       enum ipf_list_type list_type, bool v6, long long now)\n    OVS_REQUIRES(ipf->ipf_lock)\n{\n    if (ipf_purge_list_check(ipf, ipf_list, now)) {\n        return true;\n    }\n\n    while (ipf_list->last_sent_idx < ipf_list->last_inuse_idx) {\n        struct dp_packet *pkt\n            = ipf_list->frag_list[ipf_list->last_sent_idx + 1].pkt;\n        if (ipf_dp_packet_batch_add(pb, pkt, true)) {\n            ipf_list->last_sent_idx++;\n            atomic_count_dec(&ipf->nfrag);\n\n            if (list_type == IPF_FRAG_COMPLETED_LIST) {\n                ipf_count(ipf, v6, IPF_NFRAGS_COMPL_SENT);\n            } else {\n                ipf_count(ipf, v6, IPF_NFRAGS_EXPD_SENT);\n                pkt->md.ct_state = CS_INVALID;\n            }\n\n            if (ipf_list->last_sent_idx == ipf_list->last_inuse_idx) {\n                return true;\n            }\n        } else {\n            return false;\n        }\n    }\n    OVS_NOT_REACHED();\n}\n\n/* Adds fragments associated with a completed fragment list to a packet batch\n * to be processed by the calling application, typically conntrack. Also\n * cleans up the list context when it is empty.*/\nstatic void\nipf_send_completed_frags(struct ipf *ipf, struct dp_packet_batch *pb,\n                         long long now, bool v6)\n{\n    if (ovs_list_is_empty(&ipf->frag_complete_list)) {\n        return;\n    }\n\n    ovs_mutex_lock(&ipf->ipf_lock);\n    struct ipf_list *ipf_list, *next;\n\n    LIST_FOR_EACH_SAFE (ipf_list, next, list_node, &ipf->frag_complete_list) {\n        if (ipf_send_frags_in_list(ipf, ipf_list, pb, IPF_FRAG_COMPLETED_LIST,\n                                   v6, now)) {\n            ipf_completed_list_clean(&ipf->frag_lists, ipf_list);\n        } else {\n            break;\n        }\n    }\n\n    ovs_mutex_unlock(&ipf->ipf_lock);\n}\n\n/* Conservatively adds fragments associated with a expired fragment list to\n * a packet batch to be processed by the calling application, typically\n * conntrack. Also cleans up the list context when it is empty.*/\nstatic void\nipf_send_expired_frags(struct ipf *ipf, struct dp_packet_batch *pb,\n                       long long now, bool v6)\n{\n    enum {\n        /* Very conservative, due to DOS probability. */\n        IPF_FRAG_LIST_MAX_EXPIRED = 1,\n    };\n\n\n    if (ovs_list_is_empty(&ipf->frag_exp_list)) {\n        return;\n    }\n\n    ovs_mutex_lock(&ipf->ipf_lock);\n    struct ipf_list *ipf_list, *next;\n    size_t lists_removed = 0;\n\n    LIST_FOR_EACH_SAFE (ipf_list, next, list_node, &ipf->frag_exp_list) {\n        if (now <= ipf_list->expiration ||\n            lists_removed >= IPF_FRAG_LIST_MAX_EXPIRED) {\n            break;\n        }\n\n        if (ipf_send_frags_in_list(ipf, ipf_list, pb, IPF_FRAG_EXPIRY_LIST,\n                                   v6, now)) {\n            ipf_expiry_list_clean(&ipf->frag_lists, ipf_list);\n            lists_removed++;\n        } else {\n            break;\n        }\n    }\n\n    ovs_mutex_unlock(&ipf->ipf_lock);\n}\n\n/* Adds a reassmebled packet to a packet batch to be processed by the caller.\n */\nstatic void\nipf_execute_reass_pkts(struct ipf *ipf, struct dp_packet_batch *pb)\n{\n    if (ovs_list_is_empty(&ipf->reassembled_pkt_list)) {\n        return;\n    }\n\n    ovs_mutex_lock(&ipf->ipf_lock);\n    struct reassembled_pkt *rp, *next;\n\n    LIST_FOR_EACH_SAFE (rp, next, rp_list_node, &ipf->reassembled_pkt_list) {\n        if (!rp->list->reass_execute_ctx &&\n            ipf_dp_packet_batch_add(pb, rp->pkt, false)) {\n            rp->list->reass_execute_ctx = rp->pkt;\n        }\n    }\n\n    ovs_mutex_unlock(&ipf->ipf_lock);\n}\n\n/* Checks for reassembled packets post processing by conntrack and edits the\n * fragments if needed based on what conntrack decided. */\nstatic void\nipf_post_execute_reass_pkts(struct ipf *ipf,\n                            struct dp_packet_batch *pb, bool v6)\n{\n    if (ovs_list_is_empty(&ipf->reassembled_pkt_list)) {\n        return;\n    }\n\n    ovs_mutex_lock(&ipf->ipf_lock);\n    struct reassembled_pkt *rp, *next;\n\n    LIST_FOR_EACH_SAFE (rp, next, rp_list_node, &ipf->reassembled_pkt_list) {\n        const size_t pb_cnt = dp_packet_batch_size(pb);\n        int pb_idx;\n        struct dp_packet *pkt;\n        /* Inner batch loop is constant time since batch size is <=\n         * NETDEV_MAX_BURST. */\n        DP_PACKET_BATCH_REFILL_FOR_EACH (pb_idx, pb_cnt, pkt, pb) {\n            if (rp && pkt == rp->list->reass_execute_ctx) {\n                const struct ipf_frag *frag_0 = &rp->list->frag_list[0];\n                void *l4_frag = dp_packet_l4(frag_0->pkt);\n                void *l4_reass = dp_packet_l4(pkt);\n                memcpy(l4_frag, l4_reass, dp_packet_l4_size(frag_0->pkt));\n\n                for (int i = 0; i <= rp->list->last_inuse_idx; i++) {\n                    const struct ipf_frag *frag_i = &rp->list->frag_list[i];\n\n                    frag_i->pkt->md.ct_label = pkt->md.ct_label;\n                    frag_i->pkt->md.ct_mark = pkt->md.ct_mark;\n                    frag_i->pkt->md.ct_state = pkt->md.ct_state;\n                    frag_i->pkt->md.ct_zone = pkt->md.ct_zone;\n                    frag_i->pkt->md.ct_orig_tuple_ipv6 =\n                        pkt->md.ct_orig_tuple_ipv6;\n                    if (pkt->md.ct_orig_tuple_ipv6) {\n                        frag_i->pkt->md.ct_orig_tuple.ipv6 =\n                            pkt->md.ct_orig_tuple.ipv6;\n                    } else {\n                        frag_i->pkt->md.ct_orig_tuple.ipv4 =\n                            pkt->md.ct_orig_tuple.ipv4;\n                    }\n                    if (v6) {\n                        struct ovs_16aligned_ip6_hdr *l3_frag\n                            = dp_packet_l3(frag_i->pkt);\n                        struct ovs_16aligned_ip6_hdr *l3_reass\n                            = dp_packet_l3(pkt);\n                        l3_frag->ip6_src = l3_reass->ip6_src;\n                        l3_frag->ip6_dst = l3_reass->ip6_dst;\n                    } else {\n                        struct ip_header *l3_frag = dp_packet_l3(frag_i->pkt);\n                        struct ip_header *l3_reass = dp_packet_l3(pkt);\n                        if (!dp_packet_hwol_is_ipv4(frag_i->pkt)) {\n                            ovs_be32 reass_ip =\n                                get_16aligned_be32(&l3_reass->ip_src);\n                            ovs_be32 frag_ip =\n                                get_16aligned_be32(&l3_frag->ip_src);\n\n                            l3_frag->ip_csum = recalc_csum32(l3_frag->ip_csum,\n                                                             frag_ip,\n                                                             reass_ip);\n                            reass_ip = get_16aligned_be32(&l3_reass->ip_dst);\n                            frag_ip = get_16aligned_be32(&l3_frag->ip_dst);\n                            l3_frag->ip_csum = recalc_csum32(l3_frag->ip_csum,\n                                                             frag_ip,\n                                                             reass_ip);\n                        }\n\n                        l3_frag->ip_src = l3_reass->ip_src;\n                        l3_frag->ip_dst = l3_reass->ip_dst;\n                    }\n                }\n\n                ipf_completed_list_add(&ipf->frag_complete_list, rp->list);\n                ipf_reassembled_list_remove(rp);\n                dp_packet_delete(rp->pkt);\n                free(rp);\n                rp = NULL;\n            } else {\n                dp_packet_batch_refill(pb, pkt, pb_idx);\n            }\n        }\n    }\n\n    ovs_mutex_unlock(&ipf->ipf_lock);\n}\n\n/* Extracts any fragments from the batch and reassembles them when a\n * complete packet is received.  Completed packets are attempted to\n * be added to the batch to be sent through conntrack. */\nvoid\nipf_preprocess_conntrack(struct ipf *ipf, struct dp_packet_batch *pb,\n                         long long now, ovs_be16 dl_type, uint16_t zone,\n                         uint32_t hash_basis)\n{\n    if (ipf_get_enabled(ipf)) {\n        ipf_extract_frags_from_batch(ipf, pb, dl_type, zone, now, hash_basis);\n    }\n\n    if (ipf_get_enabled(ipf) || atomic_count_get(&ipf->nfrag)) {\n        ipf_execute_reass_pkts(ipf, pb);\n    }\n}\n\n/* Updates fragments based on the processing of the reassembled packet sent\n * through conntrack and adds these fragments to any batches seen.  Expired\n * fragments are marked as invalid and also added to the batches seen\n * with low priority.  Reassembled packets are freed. */\nvoid\nipf_postprocess_conntrack(struct ipf *ipf, struct dp_packet_batch *pb,\n                          long long now, ovs_be16 dl_type)\n{\n    if (ipf_get_enabled(ipf) || atomic_count_get(&ipf->nfrag)) {\n        bool v6 = dl_type == htons(ETH_TYPE_IPV6);\n        ipf_post_execute_reass_pkts(ipf, pb, v6);\n        ipf_send_completed_frags(ipf, pb, now, v6);\n        ipf_send_expired_frags(ipf, pb, now, v6);\n    }\n}\n\nstatic void *\nipf_clean_thread_main(void *f)\n{\n    struct ipf *ipf = f;\n\n    enum {\n        IPF_FRAG_LIST_CLEAN_TIMEOUT = 60000,\n    };\n\n    while (!latch_is_set(&ipf->ipf_clean_thread_exit)) {\n\n        long long now = time_msec();\n\n        if (!ovs_list_is_empty(&ipf->frag_exp_list) ||\n            !ovs_list_is_empty(&ipf->frag_complete_list)) {\n\n            ovs_mutex_lock(&ipf->ipf_lock);\n\n            struct ipf_list *ipf_list, *next;\n            LIST_FOR_EACH_SAFE (ipf_list, next, list_node,\n                                &ipf->frag_exp_list) {\n                if (ipf_purge_list_check(ipf, ipf_list, now)) {\n                    ipf_expiry_list_clean(&ipf->frag_lists, ipf_list);\n                }\n            }\n\n            LIST_FOR_EACH_SAFE (ipf_list, next, list_node,\n                                &ipf->frag_complete_list) {\n                if (ipf_purge_list_check(ipf, ipf_list, now)) {\n                    ipf_completed_list_clean(&ipf->frag_lists, ipf_list);\n                }\n            }\n\n            ovs_mutex_unlock(&ipf->ipf_lock);\n        }\n\n        poll_timer_wait_until(now + IPF_FRAG_LIST_CLEAN_TIMEOUT);\n        latch_wait(&ipf->ipf_clean_thread_exit);\n        poll_block();\n    }\n\n    return NULL;\n}\n\nstruct ipf *\nipf_init(void)\n{\n    struct ipf *ipf = xzalloc(sizeof *ipf);\n\n    ovs_mutex_init_adaptive(&ipf->ipf_lock);\n    ovs_mutex_lock(&ipf->ipf_lock);\n    hmap_init(&ipf->frag_lists);\n    ovs_list_init(&ipf->frag_exp_list);\n    ovs_list_init(&ipf->frag_complete_list);\n    ovs_list_init(&ipf->reassembled_pkt_list);\n    atomic_init(&ipf->min_v4_frag_size, IPF_V4_FRAG_SIZE_MIN_DEF);\n    atomic_init(&ipf->min_v6_frag_size, IPF_V6_FRAG_SIZE_MIN_DEF);\n    ipf->max_v4_frag_list_size = DIV_ROUND_UP(\n        IPV4_PACKET_MAX_SIZE - IPV4_PACKET_MAX_HDR_SIZE,\n        ipf->min_v4_frag_size - IPV4_PACKET_MAX_HDR_SIZE);\n    ovs_mutex_unlock(&ipf->ipf_lock);\n    atomic_count_init(&ipf->nfrag, 0);\n    for (size_t i = 0; i < IPF_NFRAGS_NUM_CNTS; i++) {\n        atomic_init(&ipf->n4frag_cnt[i], 0);\n        atomic_init(&ipf->n6frag_cnt[i], 0);\n    }\n    atomic_init(&ipf->nfrag_max, IPF_MAX_FRAGS_DEFAULT);\n    atomic_init(&ipf->ifp_v4_enabled, true);\n    atomic_init(&ipf->ifp_v6_enabled, true);\n    latch_init(&ipf->ipf_clean_thread_exit);\n    ipf->ipf_clean_thread = ovs_thread_create(\"ipf_clean\",\n                                         ipf_clean_thread_main, ipf);\n\n    return ipf;\n}\n\nvoid\nipf_destroy(struct ipf *ipf)\n{\n    ovs_mutex_lock(&ipf->ipf_lock);\n    latch_set(&ipf->ipf_clean_thread_exit);\n    pthread_join(ipf->ipf_clean_thread, NULL);\n    latch_destroy(&ipf->ipf_clean_thread_exit);\n\n    struct ipf_list *ipf_list;\n    HMAP_FOR_EACH_POP (ipf_list, node, &ipf->frag_lists) {\n        while (ipf_list->last_sent_idx < ipf_list->last_inuse_idx) {\n            struct dp_packet *pkt\n                = ipf_list->frag_list[ipf_list->last_sent_idx + 1].pkt;\n            dp_packet_delete(pkt);\n            atomic_count_dec(&ipf->nfrag);\n            ipf_list->last_sent_idx++;\n        }\n        free(ipf_list->frag_list);\n        free(ipf_list);\n    }\n\n    if (atomic_count_get(&ipf->nfrag)) {\n        VLOG_WARN(\"ipf destroy with non-zero fragment count. \");\n    }\n\n    struct reassembled_pkt *rp;\n    LIST_FOR_EACH_POP (rp, rp_list_node, &ipf->reassembled_pkt_list) {\n        dp_packet_delete(rp->pkt);\n        free(rp);\n    }\n\n    hmap_destroy(&ipf->frag_lists);\n    ovs_list_poison(&ipf->frag_exp_list);\n    ovs_list_poison(&ipf->frag_complete_list);\n    ovs_list_poison(&ipf->reassembled_pkt_list);\n    ovs_mutex_unlock(&ipf->ipf_lock);\n    ovs_mutex_destroy(&ipf->ipf_lock);\n    free(ipf);\n}\n\nint\nipf_set_enabled(struct ipf *ipf, bool v6, bool enable)\n{\n    atomic_store_relaxed(v6 ? &ipf->ifp_v6_enabled : &ipf->ifp_v4_enabled,\n                         enable);\n    return 0;\n}\n\nint\nipf_set_min_frag(struct ipf *ipf, bool v6, uint32_t value)\n{\n    /* If the user specifies an unreasonably large number, fragmentation\n     * will not work well but it will not blow up. */\n    if (value < (v6 ? IPF_V6_FRAG_SIZE_LBOUND :  IPF_V4_FRAG_SIZE_LBOUND)) {\n        return 1;\n    }\n\n    ovs_mutex_lock(&ipf->ipf_lock);\n    if (v6) {\n        atomic_store_relaxed(&ipf->min_v6_frag_size, value);\n    } else {\n        atomic_store_relaxed(&ipf->min_v4_frag_size, value);\n        ipf->max_v4_frag_list_size = DIV_ROUND_UP(\n            IPV4_PACKET_MAX_SIZE - IPV4_PACKET_MAX_HDR_SIZE,\n            ipf->min_v4_frag_size - IPV4_PACKET_MAX_HDR_SIZE);\n    }\n    ovs_mutex_unlock(&ipf->ipf_lock);\n    return 0;\n}\n\nint\nipf_set_max_nfrags(struct ipf *ipf, uint32_t value)\n{\n    if (value > IPF_NFRAG_UBOUND) {\n        return 1;\n    }\n    atomic_store_relaxed(&ipf->nfrag_max, value);\n    return 0;\n}\n\nint\nipf_get_status(struct ipf *ipf, struct ipf_status *ipf_status)\n{\n    ipf_status->nfrag = atomic_count_get(&ipf->nfrag);\n    atomic_read_relaxed(&ipf->nfrag_max, &ipf_status->nfrag_max);\n\n    atomic_read_relaxed(&ipf->ifp_v4_enabled, &ipf_status->v4.enabled);\n    atomic_read_relaxed(&ipf->min_v4_frag_size,\n                        &ipf_status->v4.min_frag_size);\n    atomic_read_relaxed(&ipf->n4frag_cnt[IPF_NFRAGS_ACCEPTED],\n                        &ipf_status->v4.nfrag_accepted);\n    atomic_read_relaxed(&ipf->n4frag_cnt[IPF_NFRAGS_COMPL_SENT],\n                        &ipf_status->v4.nfrag_completed_sent);\n    atomic_read_relaxed(&ipf->n4frag_cnt[IPF_NFRAGS_EXPD_SENT],\n                        &ipf_status->v4.nfrag_expired_sent);\n    atomic_read_relaxed(&ipf->n4frag_cnt[IPF_NFRAGS_TOO_SMALL],\n                        &ipf_status->v4.nfrag_too_small);\n    atomic_read_relaxed(&ipf->n4frag_cnt[IPF_NFRAGS_OVERLAP],\n                        &ipf_status->v4.nfrag_overlap);\n    atomic_read_relaxed(&ipf->n4frag_cnt[IPF_NFRAGS_PURGED],\n                        &ipf_status->v4.nfrag_purged);\n\n    atomic_read_relaxed(&ipf->ifp_v6_enabled, &ipf_status->v6.enabled);\n    atomic_read_relaxed(&ipf->min_v6_frag_size,\n                        &ipf_status->v6.min_frag_size);\n    atomic_read_relaxed(&ipf->n6frag_cnt[IPF_NFRAGS_ACCEPTED],\n                        &ipf_status->v6.nfrag_accepted);\n    atomic_read_relaxed(&ipf->n6frag_cnt[IPF_NFRAGS_COMPL_SENT],\n                        &ipf_status->v6.nfrag_completed_sent);\n    atomic_read_relaxed(&ipf->n6frag_cnt[IPF_NFRAGS_EXPD_SENT],\n                        &ipf_status->v6.nfrag_expired_sent);\n    atomic_read_relaxed(&ipf->n6frag_cnt[IPF_NFRAGS_TOO_SMALL],\n                        &ipf_status->v6.nfrag_too_small);\n    atomic_read_relaxed(&ipf->n6frag_cnt[IPF_NFRAGS_OVERLAP],\n                        &ipf_status->v6.nfrag_overlap);\n    atomic_read_relaxed(&ipf->n6frag_cnt[IPF_NFRAGS_PURGED],\n                        &ipf_status->v6.nfrag_purged);\n    return 0;\n}\n\nstruct ipf_dump_ctx {\n    struct hmap_position bucket_pos;\n};\n\n/* Allocates an 'ipf_dump_ctx' to keep track of an hmap position. The\n * caller must call ipf_dump_done() when dumping is finished. */\nint\nipf_dump_start(struct ipf_dump_ctx **ipf_dump_ctx)\n{\n    *ipf_dump_ctx = xzalloc(sizeof **ipf_dump_ctx);\n    return 0;\n}\n\n/* Creates a string representation of the state of an 'ipf_list' and puts\n * it in 'ds'. */\nstatic void\nipf_dump_create(const struct ipf_list *ipf_list, struct ds *ds)\n{\n    ds_put_cstr(ds, \"(\");\n    if (ipf_list->key.dl_type == htons(ETH_TYPE_IP)) {\n        ds_put_format(ds, \"src=\"IP_FMT\",dst=\"IP_FMT\",\",\n                      IP_ARGS(ipf_list->key.src_addr.ipv4),\n                      IP_ARGS(ipf_list->key.dst_addr.ipv4));\n    } else {\n        ds_put_cstr(ds, \"src=\");\n        ipv6_format_addr(&ipf_list->key.src_addr.ipv6, ds);\n        ds_put_cstr(ds, \",dst=\");\n        ipv6_format_addr(&ipf_list->key.dst_addr.ipv6, ds);\n        ds_put_cstr(ds, \",\");\n    }\n\n    ds_put_format(ds, \"recirc_id=%u,ip_id=%u,dl_type=0x%x,zone=%u,nw_proto=%u\",\n                  ipf_list->key.recirc_id, ntohl(ipf_list->key.ip_id),\n                  ntohs(ipf_list->key.dl_type), ipf_list->key.zone,\n                  ipf_list->key.nw_proto);\n\n    ds_put_format(ds, \",num_fragments=%u,state=%s\",\n                  ipf_list->last_inuse_idx + 1,\n                  ipf_state_name[ipf_list->state]);\n\n    ds_put_cstr(ds, \")\");\n}\n\n/* Finds the next ipf list starting from 'ipf_dump_ctx->bucket_pos' and uses\n * ipf_dump_create() to create a string representation of the state of an\n * ipf list, to which 'dump' is pointed to.  Returns EOF when there are no\n * more ipf lists. */\nint\nipf_dump_next(struct ipf *ipf, struct ipf_dump_ctx *ipf_dump_ctx, char **dump)\n{\n    ovs_mutex_lock(&ipf->ipf_lock);\n\n    struct hmap_node *node = hmap_at_position(&ipf->frag_lists,\n                                              &ipf_dump_ctx->bucket_pos);\n    if (!node) {\n        ovs_mutex_unlock(&ipf->ipf_lock);\n        return EOF;\n    } else {\n        struct ipf_list *ipf_list_;\n        INIT_CONTAINER(ipf_list_, node, node);\n        struct ipf_list ipf_list = *ipf_list_;\n        ovs_mutex_unlock(&ipf->ipf_lock);\n        struct ds ds = DS_EMPTY_INITIALIZER;\n        ipf_dump_create(&ipf_list, &ds);\n        *dump = ds_steal_cstr(&ds);\n        return 0;\n    }\n}\n\n/* Frees 'ipf_dump_ctx' allocated by ipf_dump_start(). */\nint\nipf_dump_done(struct ipf_dump_ctx *ipf_dump_ctx)\n{\n    free(ipf_dump_ctx);\n    return 0;\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2019 Nicira, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <config.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <netinet/in.h>\n#include <netinet/ip6.h>\n#include <netinet/icmp6.h>\n#include <string.h>\n\n#include \"coverage.h\"\n#include \"csum.h\"\n#include \"ipf.h\"\n#include \"latch.h\"\n#include \"openvswitch/hmap.h\"\n#include \"openvswitch/poll-loop.h\"\n#include \"openvswitch/vlog.h\"\n#include \"ovs-atomic.h\"\n#include \"packets.h\"\n#include \"util.h\"\n\nVLOG_DEFINE_THIS_MODULE(ipf);\nCOVERAGE_DEFINE(ipf_stuck_frag_list_purged);\nCOVERAGE_DEFINE(ipf_l3csum_err);\n\nenum {\n    IPV4_PACKET_MAX_HDR_SIZE = 60,\n    IPV4_PACKET_MAX_SIZE = 65535,\n    IPV6_PACKET_MAX_DATA = 65535,\n};\n\nenum ipf_list_state {\n    IPF_LIST_STATE_UNUSED,\n    IPF_LIST_STATE_REASS_FAIL,\n    IPF_LIST_STATE_OTHER_SEEN,\n    IPF_LIST_STATE_FIRST_SEEN,\n    IPF_LIST_STATE_LAST_SEEN,\n    IPF_LIST_STATE_FIRST_LAST_SEEN,\n    IPF_LIST_STATE_COMPLETED,\n    IPF_LIST_STATE_NUM,\n};\n\nstatic char *ipf_state_name[IPF_LIST_STATE_NUM] =\n    {\"unused\", \"reassemble fail\", \"other frag\", \"first frag\", \"last frag\",\n     \"first/last frag\", \"complete\"};\n\nenum ipf_list_type {\n    IPF_FRAG_COMPLETED_LIST,\n    IPF_FRAG_EXPIRY_LIST,\n};\n\nenum {\n    IPF_INVALID_IDX = -1,\n    IPF_V4_FRAG_SIZE_LBOUND = 400,\n    IPF_V4_FRAG_SIZE_MIN_DEF = 1200,\n    IPF_V6_FRAG_SIZE_LBOUND = 400, /* Useful for testing. */\n    IPF_V6_FRAG_SIZE_MIN_DEF = 1280,\n    IPF_MAX_FRAGS_DEFAULT = 1000,\n    IPF_NFRAG_UBOUND = 5000,\n};\n\nenum ipf_counter_type {\n    IPF_NFRAGS_ACCEPTED,\n    IPF_NFRAGS_COMPL_SENT,\n    IPF_NFRAGS_EXPD_SENT,\n    IPF_NFRAGS_TOO_SMALL,\n    IPF_NFRAGS_OVERLAP,\n    IPF_NFRAGS_PURGED,\n    IPF_NFRAGS_NUM_CNTS,\n};\n\nunion ipf_addr {\n    ovs_be32 ipv4;\n    struct in6_addr ipv6;\n};\n\n/* Represents a single fragment; part of a list of fragments. */\nstruct ipf_frag {\n    struct dp_packet *pkt;\n    uint16_t start_data_byte;\n    uint16_t end_data_byte;\n};\n\n/* The key for a collection of fragments potentially making up an unfragmented\n * packet. */\nstruct ipf_list_key {\n    /* ipf_list_key_hash() requires 'src_addr' and 'dst_addr' to be the first\n     * two members. */\n    union ipf_addr src_addr;\n    union ipf_addr dst_addr;\n    uint32_t recirc_id;\n    ovs_be32 ip_id;   /* V6 is 32 bits. */\n    ovs_be16 dl_type;\n    uint16_t zone;\n    uint8_t nw_proto;\n};\n\n/* A collection of fragments potentially making up an unfragmented packet. */\nstruct ipf_list {\n    struct hmap_node node;         /* In struct ipf's 'frag_lists'. */\n    struct ovs_list list_node;     /* In struct ipf's 'frag_exp_list' or\n                                    * 'frag_complete_list'. */\n    struct ipf_frag *frag_list;    /* List of fragments for this list. */\n    struct ipf_list_key key;       /* The key for the fragemnt list. */\n    struct dp_packet *reass_execute_ctx; /* Reassembled packet. */\n    long long expiration;          /* In milliseconds. */\n    int last_sent_idx;             /* Last sent fragment idx. */\n    int last_inuse_idx;            /* Last inuse fragment idx. */\n    int size;                      /* Fragment list size. */\n    uint8_t state;                 /* Frag list state; see ipf_list_state. */\n};\n\n/* Represents a reassambled packet which typically is passed through\n * conntrack. */\nstruct reassembled_pkt {\n    struct ovs_list rp_list_node;  /* In struct ipf's\n                                    * 'reassembled_pkt_list'. */\n    struct dp_packet *pkt;\n    struct ipf_list *list;\n};\n\nstruct ipf {\n    /* The clean thread is used to clean up fragments in the 'ipf'\n     * module if packet batches are not longer be sent through its user. */\n    pthread_t ipf_clean_thread;\n    struct latch ipf_clean_thread_exit;\n\n    int max_v4_frag_list_size;\n\n    struct ovs_mutex ipf_lock; /* Protects all of the following. */\n    /* These contain 'struct ipf_list's. */\n    struct hmap frag_lists OVS_GUARDED;\n    struct ovs_list frag_exp_list OVS_GUARDED;\n    struct ovs_list frag_complete_list OVS_GUARDED;\n    /* Contains 'struct reassembled_pkt's. */\n    struct ovs_list reassembled_pkt_list OVS_GUARDED;\n\n    /* Used to allow disabling fragmentation reassembly. */\n    atomic_bool ifp_v4_enabled;\n    atomic_bool ifp_v6_enabled;\n\n    /* Will be clamped above 400 bytes; the value chosen should handle\n     * alg control packets of interest that use string encoding of mutable\n     * IP fields; meaning, the control packets should not be fragmented. */\n    atomic_uint min_v4_frag_size;\n    atomic_uint min_v6_frag_size;\n\n    /* Configurable maximum allowable fragments in process. */\n    atomic_uint nfrag_max;\n\n    /* Number of fragments in process. */\n    atomic_count nfrag;\n\n    atomic_uint64_t n4frag_cnt[IPF_NFRAGS_NUM_CNTS];\n    atomic_uint64_t n6frag_cnt[IPF_NFRAGS_NUM_CNTS];\n};\n\nstatic void\nipf_print_reass_packet(const char *es, const void *pkt)\n{\n    static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(10, 10);\n    if (!VLOG_DROP_WARN(&rl)) {\n        struct ds ds = DS_EMPTY_INITIALIZER;\n        ds_put_hex_dump(&ds, pkt, 128, 0, false);\n        VLOG_WARN(\"%s\\n%s\", es, ds_cstr(&ds));\n        ds_destroy(&ds);\n    }\n}\n\nstatic void\nipf_count(struct ipf *ipf, bool v6, enum ipf_counter_type cntr)\n{\n    atomic_count_inc64(v6 ? &ipf->n6frag_cnt[cntr] : &ipf->n4frag_cnt[cntr]);\n}\n\nstatic bool\nipf_get_v4_enabled(struct ipf *ipf)\n{\n    bool ifp_v4_enabled_;\n    atomic_read_relaxed(&ipf->ifp_v4_enabled, &ifp_v4_enabled_);\n    return ifp_v4_enabled_;\n}\n\nstatic bool\nipf_get_v6_enabled(struct ipf *ipf)\n{\n    bool ifp_v6_enabled_;\n    atomic_read_relaxed(&ipf->ifp_v6_enabled, &ifp_v6_enabled_);\n    return ifp_v6_enabled_;\n}\n\nstatic bool\nipf_get_enabled(struct ipf *ipf)\n{\n    return ipf_get_v4_enabled(ipf) || ipf_get_v6_enabled(ipf);\n}\n\nstatic uint32_t\nipf_addr_hash_add(uint32_t hash, const union ipf_addr *addr)\n{\n    BUILD_ASSERT_DECL(sizeof *addr % 4 == 0);\n    return hash_add_bytes32(hash, (const uint32_t *) addr, sizeof *addr);\n}\n\n/* Adds a list of fragments to the list tracking expiry of yet to be\n * completed reassembled packets, hence subject to expirty. */\nstatic void\nipf_expiry_list_add(struct ovs_list *frag_exp_list, struct ipf_list *ipf_list,\n                    long long now)\n   /* OVS_REQUIRES(ipf->ipf_lock) */\n{\n    enum {\n        IPF_FRAG_LIST_TIMEOUT = 15000,\n    };\n\n    ipf_list->expiration = now + IPF_FRAG_LIST_TIMEOUT;\n    ovs_list_push_back(frag_exp_list, &ipf_list->list_node);\n}\n\n/* Adds a list of fragments to the list of completed packets, which will be\n * subsequently transmitted. */\nstatic void\nipf_completed_list_add(struct ovs_list *frag_complete_list,\n                       struct ipf_list *ipf_list)\n    /* OVS_REQUIRES(ipf_lock) */\n{\n    ovs_list_push_back(frag_complete_list, &ipf_list->list_node);\n}\n\n/* Adds a reassmebled packet to the list of reassembled packets, awaiting some\n * processing, such as being sent through conntrack. */\nstatic void\nipf_reassembled_list_add(struct ovs_list *reassembled_pkt_list,\n                         struct reassembled_pkt *rp)\n    /* OVS_REQUIRES(ipf_lock) */\n{\n    ovs_list_push_back(reassembled_pkt_list, &rp->rp_list_node);\n}\n\n/* Removed a frag list from tracking datastructures and frees list heap\n * memory. */\nstatic void\nipf_list_clean(struct hmap *frag_lists,\n               struct ipf_list *ipf_list)\n    /* OVS_REQUIRES(ipf_lock) */\n{\n    ovs_list_remove(&ipf_list->list_node);\n    hmap_remove(frag_lists, &ipf_list->node);\n    free(ipf_list->frag_list);\n    free(ipf_list);\n}\n\n/* Removed a frag list sitting on the expiry list from tracking\n * datastructures and frees list heap memory. */\nstatic void\nipf_expiry_list_clean(struct hmap *frag_lists,\n                      struct ipf_list *ipf_list)\n    /* OVS_REQUIRES(ipf_lock) */\n{\n    ipf_list_clean(frag_lists, ipf_list);\n}\n\n/* Removed a frag list sitting on the completed list from tracking\n * datastructures and frees list heap memory. */\nstatic void\nipf_completed_list_clean(struct hmap *frag_lists,\n                         struct ipf_list *ipf_list)\n    /* OVS_REQUIRES(ipf_lock) */\n{\n    ipf_list_clean(frag_lists, ipf_list);\n}\n\nstatic void\nipf_expiry_list_remove(struct ipf_list *ipf_list)\n    /* OVS_REQUIRES(ipf_lock) */\n{\n    ovs_list_remove(&ipf_list->list_node);\n}\n\nstatic void\nipf_reassembled_list_remove(struct reassembled_pkt *rp)\n    /* OVS_REQUIRES(ipf_lock) */\n{\n    ovs_list_remove(&rp->rp_list_node);\n}\n\n/* Symmetric */\nstatic uint32_t\nipf_list_key_hash(const struct ipf_list_key *key, uint32_t basis)\n{\n    uint32_t hsrc, hdst, hash;\n    hsrc = hdst = basis;\n    hsrc = ipf_addr_hash_add(hsrc, &key->src_addr);\n    hdst = ipf_addr_hash_add(hdst, &key->dst_addr);\n    hash = hsrc ^ hdst;\n\n    /* Hash the rest of the key. */\n    return hash_words((uint32_t *) (&key->dst_addr + 1),\n                      (uint32_t *) (key + 1) -\n                      (uint32_t *) (&key->dst_addr + 1),\n                      hash);\n}\n\nstatic bool\nipf_is_first_v4_frag(const struct dp_packet *pkt)\n{\n    const struct ip_header *l3 = dp_packet_l3(pkt);\n    if (!(l3->ip_frag_off & htons(IP_FRAG_OFF_MASK)) &&\n        l3->ip_frag_off & htons(IP_MORE_FRAGMENTS)) {\n        return true;\n    }\n    return false;\n}\n\nstatic bool\nipf_is_last_v4_frag(const struct dp_packet *pkt)\n{\n    const struct ip_header *l3 = dp_packet_l3(pkt);\n    if (l3->ip_frag_off & htons(IP_FRAG_OFF_MASK) &&\n        !(l3->ip_frag_off & htons(IP_MORE_FRAGMENTS))) {\n        return true;\n    }\n    return false;\n}\n\nstatic bool\nipf_is_v6_frag(ovs_be16 ip6f_offlg)\n{\n    if (ip6f_offlg & (IP6F_OFF_MASK | IP6F_MORE_FRAG)) {\n        return true;\n    }\n    return false;\n}\n\nstatic bool\nipf_is_first_v6_frag(ovs_be16 ip6f_offlg)\n{\n    if (!(ip6f_offlg & IP6F_OFF_MASK) &&\n        ip6f_offlg & IP6F_MORE_FRAG) {\n        return true;\n    }\n    return false;\n}\n\nstatic bool\nipf_is_last_v6_frag(ovs_be16 ip6f_offlg)\n{\n    if ((ip6f_offlg & IP6F_OFF_MASK) &&\n        !(ip6f_offlg & IP6F_MORE_FRAG)) {\n        return true;\n    }\n    return false;\n}\n\n/* Checks for a completed packet collection of fragments. */\nstatic bool\nipf_list_complete(const struct ipf_list *ipf_list)\n    /* OVS_REQUIRES(ipf_lock) */\n{\n    for (int i = 1; i <= ipf_list->last_inuse_idx; i++) {\n        if (ipf_list->frag_list[i - 1].end_data_byte + 1\n            != ipf_list->frag_list[i].start_data_byte) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/* Runs O(n) for a sorted or almost sorted list. */\nstatic void\nipf_sort(struct ipf_frag *frag_list, size_t last_idx)\n    /* OVS_REQUIRES(ipf_lock) */\n{\n    for (int li = 1; li <= last_idx; li++) {\n        struct ipf_frag ipf_frag = frag_list[li];\n        int ci = li - 1;\n        while (ci >= 0 &&\n               frag_list[ci].start_data_byte > ipf_frag.start_data_byte) {\n            frag_list[ci + 1] = frag_list[ci];\n            ci--;\n        }\n        frag_list[ci + 1] = ipf_frag;\n    }\n}\n\n/* Called on a sorted complete list of v4 fragments to reassemble them into\n * a single packet that can be processed, such as passing through conntrack.\n */\nstatic struct dp_packet *\nipf_reassemble_v4_frags(struct ipf_list *ipf_list)\n    /* OVS_REQUIRES(ipf_lock) */\n{\n    struct ipf_frag *frag_list = ipf_list->frag_list;\n    struct dp_packet *pkt = dp_packet_clone(frag_list[0].pkt);\n    dp_packet_set_size(pkt, dp_packet_size(pkt) - dp_packet_l2_pad_size(pkt));\n    struct ip_header *l3 = dp_packet_l3(pkt);\n    int len = ntohs(l3->ip_tot_len);\n\n    int rest_len = frag_list[ipf_list->last_inuse_idx].end_data_byte -\n                   frag_list[1].start_data_byte + 1;\n\n    if (len + rest_len > IPV4_PACKET_MAX_SIZE) {\n        ipf_print_reass_packet(\n            \"Unsupported big reassembled v4 packet; v4 hdr:\", l3);\n        dp_packet_delete(pkt);\n        return NULL;\n    }\n\n    dp_packet_prealloc_tailroom(pkt, rest_len);\n\n    for (int i = 1; i <= ipf_list->last_inuse_idx; i++) {\n        size_t add_len = frag_list[i].end_data_byte -\n                         frag_list[i].start_data_byte + 1;\n        const char *l4 = dp_packet_l4(frag_list[i].pkt);\n        dp_packet_put(pkt, l4, add_len);\n    }\n\n    len += rest_len;\n    l3 = dp_packet_l3(pkt);\n    ovs_be16 new_ip_frag_off = l3->ip_frag_off & ~htons(IP_MORE_FRAGMENTS);\n    if (!dp_packet_hwol_is_ipv4(pkt)) {\n        l3->ip_csum = recalc_csum16(l3->ip_csum, l3->ip_frag_off,\n                                    new_ip_frag_off);\n        l3->ip_csum = recalc_csum16(l3->ip_csum, l3->ip_tot_len, htons(len));\n    }\n    l3->ip_tot_len = htons(len);\n    l3->ip_frag_off = new_ip_frag_off;\n    dp_packet_set_l2_pad_size(pkt, 0);\n\n    return pkt;\n}\n\n/* Called on a sorted complete list of v6 fragments to reassemble them into\n * a single packet that can be processed, such as passing through conntrack.\n */\nstatic struct dp_packet *\nipf_reassemble_v6_frags(struct ipf_list *ipf_list)\n    /* OVS_REQUIRES(ipf_lock) */\n{\n    struct ipf_frag *frag_list = ipf_list->frag_list;\n    struct dp_packet *pkt = dp_packet_clone(frag_list[0].pkt);\n    dp_packet_set_size(pkt, dp_packet_size(pkt) - dp_packet_l2_pad_size(pkt));\n    struct  ovs_16aligned_ip6_hdr *l3 = dp_packet_l3(pkt);\n    int pl = ntohs(l3->ip6_plen) - sizeof(struct ovs_16aligned_ip6_frag);\n\n    int rest_len = frag_list[ipf_list->last_inuse_idx].end_data_byte -\n                   frag_list[1].start_data_byte + 1;\n\n    if (pl + rest_len > IPV6_PACKET_MAX_DATA) {\n        ipf_print_reass_packet(\n             \"Unsupported big reassembled v6 packet; v6 hdr:\", l3);\n        dp_packet_delete(pkt);\n        return NULL;\n    }\n\n    dp_packet_prealloc_tailroom(pkt, rest_len);\n\n    for (int i = 1; i <= ipf_list->last_inuse_idx; i++) {\n        size_t add_len = frag_list[i].end_data_byte -\n                          frag_list[i].start_data_byte + 1;\n        const char *l4 = dp_packet_l4(frag_list[i].pkt);\n        dp_packet_put(pkt, l4, add_len);\n    }\n\n    pl += rest_len;\n    l3 = dp_packet_l3(pkt);\n\n    uint8_t nw_proto = l3->ip6_nxt;\n    uint8_t nw_frag = 0;\n    const void *data = l3 + 1;\n    size_t datasize = pl;\n\n    const struct ovs_16aligned_ip6_frag *frag_hdr = NULL;\n    if (!parse_ipv6_ext_hdrs(&data, &datasize, &nw_proto, &nw_frag, &frag_hdr)\n        || !nw_frag || !frag_hdr) {\n\n        ipf_print_reass_packet(\"Unparsed reassembled v6 packet; v6 hdr:\", l3);\n        dp_packet_delete(pkt);\n        return NULL;\n    }\n\n    struct ovs_16aligned_ip6_frag *fh =\n        CONST_CAST(struct ovs_16aligned_ip6_frag *, frag_hdr);\n    fh->ip6f_offlg = 0;\n    l3->ip6_plen = htons(pl);\n    l3->ip6_ctlun.ip6_un1.ip6_un1_nxt = nw_proto;\n    dp_packet_set_l2_pad_size(pkt, 0);\n    return pkt;\n}\n\n/* Called when a frag list state transitions to another state. This is\n * triggered by new fragment for the list being received.*/\nstatic void\nipf_list_state_transition(struct ipf *ipf, struct ipf_list *ipf_list,\n                          bool ff, bool lf, bool v6)\n    OVS_REQUIRES(ipf->ipf_lock)\n{\n    enum ipf_list_state curr_state = ipf_list->state;\n    enum ipf_list_state next_state;\n    switch (curr_state) {\n    case IPF_LIST_STATE_UNUSED:\n    case IPF_LIST_STATE_OTHER_SEEN:\n        if (ff) {\n            next_state = IPF_LIST_STATE_FIRST_SEEN;\n        } else if (lf) {\n            next_state = IPF_LIST_STATE_LAST_SEEN;\n        } else {\n            next_state = IPF_LIST_STATE_OTHER_SEEN;\n        }\n        break;\n    case IPF_LIST_STATE_FIRST_SEEN:\n        if (lf) {\n            next_state = IPF_LIST_STATE_FIRST_LAST_SEEN;\n        } else {\n            next_state = IPF_LIST_STATE_FIRST_SEEN;\n        }\n        break;\n    case IPF_LIST_STATE_LAST_SEEN:\n        if (ff) {\n            next_state = IPF_LIST_STATE_FIRST_LAST_SEEN;\n        } else {\n            next_state = IPF_LIST_STATE_LAST_SEEN;\n        }\n        break;\n    case IPF_LIST_STATE_FIRST_LAST_SEEN:\n        next_state = IPF_LIST_STATE_FIRST_LAST_SEEN;\n        break;\n    case IPF_LIST_STATE_COMPLETED:\n    case IPF_LIST_STATE_REASS_FAIL:\n    case IPF_LIST_STATE_NUM:\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    if (next_state == IPF_LIST_STATE_FIRST_LAST_SEEN) {\n        ipf_sort(ipf_list->frag_list, ipf_list->last_inuse_idx);\n        if (ipf_list_complete(ipf_list)) {\n            struct dp_packet *reass_pkt = v6\n                ? ipf_reassemble_v6_frags(ipf_list)\n                : ipf_reassemble_v4_frags(ipf_list);\n            if (reass_pkt) {\n                struct reassembled_pkt *rp = xzalloc(sizeof *rp);\n                rp->pkt = reass_pkt;\n                rp->list = ipf_list;\n                ipf_reassembled_list_add(&ipf->reassembled_pkt_list, rp);\n                ipf_expiry_list_remove(ipf_list);\n                next_state = IPF_LIST_STATE_COMPLETED;\n            } else {\n                next_state = IPF_LIST_STATE_REASS_FAIL;\n            }\n        }\n    }\n    ipf_list->state = next_state;\n}\n\n/* Some sanity checks are redundant, but prudent, in case code paths for\n * fragments change in future. The processing cost for fragments is not\n * important. */\nstatic bool\nipf_is_valid_v4_frag(struct ipf *ipf, struct dp_packet *pkt)\n{\n    if (OVS_UNLIKELY(dp_packet_ip_checksum_bad(pkt))) {\n        COVERAGE_INC(ipf_l3csum_err);\n        goto invalid_pkt;\n    }\n\n    const struct eth_header *l2 = dp_packet_eth(pkt);\n    const struct ip_header *l3 = dp_packet_l3(pkt);\n\n    if (OVS_UNLIKELY(!l2 || !l3)) {\n        goto invalid_pkt;\n    }\n\n    size_t l3_size = dp_packet_l3_size(pkt);\n    if (OVS_UNLIKELY(l3_size < IP_HEADER_LEN)) {\n        goto invalid_pkt;\n    }\n\n    if (!IP_IS_FRAGMENT(l3->ip_frag_off)) {\n        return false;\n    }\n\n    uint16_t ip_tot_len = ntohs(l3->ip_tot_len);\n    if (OVS_UNLIKELY(ip_tot_len != l3_size)) {\n        goto invalid_pkt;\n    }\n\n    size_t ip_hdr_len = IP_IHL(l3->ip_ihl_ver) * 4;\n    if (OVS_UNLIKELY(ip_hdr_len < IP_HEADER_LEN)) {\n        goto invalid_pkt;\n    }\n    if (OVS_UNLIKELY(l3_size < ip_hdr_len)) {\n        goto invalid_pkt;\n    }\n\n    if (OVS_UNLIKELY(!dp_packet_ip_checksum_valid(pkt)\n                     && !dp_packet_hwol_is_ipv4(pkt)\n                     && csum(l3, ip_hdr_len) != 0)) {\n        COVERAGE_INC(ipf_l3csum_err);\n        goto invalid_pkt;\n    }\n\n    uint32_t min_v4_frag_size_;\n    atomic_read_relaxed(&ipf->min_v4_frag_size, &min_v4_frag_size_);\n    bool lf = ipf_is_last_v4_frag(pkt);\n    if (OVS_UNLIKELY(!lf && dp_packet_l3_size(pkt) < min_v4_frag_size_)) {\n        ipf_count(ipf, false, IPF_NFRAGS_TOO_SMALL);\n        goto invalid_pkt;\n    }\n    return true;\n\ninvalid_pkt:\n    pkt->md.ct_state = CS_INVALID;\n    return false;\n}\n\nstatic bool\nipf_v4_key_extract(struct dp_packet *pkt, ovs_be16 dl_type, uint16_t zone,\n                   struct ipf_list_key *key, uint16_t *start_data_byte,\n                   uint16_t *end_data_byte, bool *ff, bool *lf)\n{\n    const struct ip_header *l3 = dp_packet_l3(pkt);\n    uint16_t ip_tot_len = ntohs(l3->ip_tot_len);\n    size_t ip_hdr_len = IP_IHL(l3->ip_ihl_ver) * 4;\n\n    *start_data_byte = ntohs(l3->ip_frag_off & htons(IP_FRAG_OFF_MASK)) * 8;\n    *end_data_byte = *start_data_byte + ip_tot_len - ip_hdr_len - 1;\n    *ff = ipf_is_first_v4_frag(pkt);\n    *lf = ipf_is_last_v4_frag(pkt);\n    memset(key, 0, sizeof *key);\n    key->ip_id = be16_to_be32(l3->ip_id);\n    key->dl_type = dl_type;\n    key->src_addr.ipv4 = get_16aligned_be32(&l3->ip_src);\n    key->dst_addr.ipv4 = get_16aligned_be32(&l3->ip_dst);\n    key->nw_proto = l3->ip_proto;\n    key->zone = zone;\n    key->recirc_id = pkt->md.recirc_id;\n    return true;\n}\n\n/* Some sanity checks are redundant, but prudent, in case code paths for\n * fragments change in future. The processing cost for fragments is not\n * important. */\nstatic bool\nipf_is_valid_v6_frag(struct ipf *ipf, struct dp_packet *pkt)\n{\n    const struct eth_header *l2 = dp_packet_eth(pkt);\n    const struct  ovs_16aligned_ip6_hdr *l3 = dp_packet_l3(pkt);\n    const char *l4 = dp_packet_l4(pkt);\n\n    if (OVS_UNLIKELY(!l2 || !l3 || !l4)) {\n        goto invalid_pkt;\n    }\n\n    size_t l3_size = dp_packet_l3_size(pkt);\n    size_t l3_hdr_size = sizeof *l3;\n\n    if (OVS_UNLIKELY(l3_size < l3_hdr_size)) {\n        goto invalid_pkt;\n    }\n\n    uint8_t nw_frag = 0;\n    uint8_t nw_proto = l3->ip6_nxt;\n    const void *data = l3 + 1;\n    size_t datasize = l3_size - l3_hdr_size;\n    const struct ovs_16aligned_ip6_frag *frag_hdr = NULL;\n    if (!parse_ipv6_ext_hdrs(&data, &datasize, &nw_proto, &nw_frag,\n                             &frag_hdr) || !nw_frag || !frag_hdr) {\n        return false;\n    }\n\n    int pl = ntohs(l3->ip6_plen);\n    if (OVS_UNLIKELY(pl + l3_hdr_size != l3_size)) {\n        goto invalid_pkt;\n    }\n\n    ovs_be16 ip6f_offlg = frag_hdr->ip6f_offlg;\n    if (OVS_UNLIKELY(!ipf_is_v6_frag(ip6f_offlg))) {\n        return false;\n    }\n\n    uint32_t min_v6_frag_size_;\n    atomic_read_relaxed(&ipf->min_v6_frag_size, &min_v6_frag_size_);\n    bool lf = ipf_is_last_v6_frag(ip6f_offlg);\n\n    if (OVS_UNLIKELY(!lf && dp_packet_l3_size(pkt) < min_v6_frag_size_)) {\n        ipf_count(ipf, true, IPF_NFRAGS_TOO_SMALL);\n        goto invalid_pkt;\n    }\n\n    return true;\n\ninvalid_pkt:\n    pkt->md.ct_state = CS_INVALID;\n    return false;\n\n}\n\nstatic void\nipf_v6_key_extract(struct dp_packet *pkt, ovs_be16 dl_type, uint16_t zone,\n                   struct ipf_list_key *key, uint16_t *start_data_byte,\n                   uint16_t *end_data_byte, bool *ff, bool *lf)\n{\n    const struct ovs_16aligned_ip6_hdr *l3 = dp_packet_l3(pkt);\n    uint8_t nw_frag = 0;\n    uint8_t nw_proto = l3->ip6_nxt;\n    const void *data = l3 + 1;\n    size_t datasize = dp_packet_l3_size(pkt) - sizeof *l3;\n    const struct ovs_16aligned_ip6_frag *frag_hdr = NULL;\n\n    parse_ipv6_ext_hdrs(&data, &datasize, &nw_proto, &nw_frag, &frag_hdr);\n    ovs_assert(nw_frag && frag_hdr);\n    ovs_be16 ip6f_offlg = frag_hdr->ip6f_offlg;\n    *start_data_byte = ntohs(ip6f_offlg & IP6F_OFF_MASK) +\n        sizeof (struct ovs_16aligned_ip6_frag);\n    *end_data_byte = *start_data_byte + dp_packet_l4_size(pkt) - 1;\n    *ff = ipf_is_first_v6_frag(ip6f_offlg);\n    *lf = ipf_is_last_v6_frag(ip6f_offlg);\n    memset(key, 0, sizeof *key);\n    key->ip_id = get_16aligned_be32(&frag_hdr->ip6f_ident);\n    key->dl_type = dl_type;\n    memcpy(&key->src_addr.ipv6, &l3->ip6_src, sizeof key->src_addr.ipv6);\n    /* We are not supporting parsing of the routing header to use as the\n     * dst address part of the key. */\n    memcpy(&key->dst_addr.ipv6, &l3->ip6_dst, sizeof key->dst_addr.ipv6);\n    key->nw_proto = 0;   /* Not used for key for V6. */\n    key->zone = zone;\n    key->recirc_id = pkt->md.recirc_id;\n}\n\nstatic bool\nipf_list_key_eq(const struct ipf_list_key *key1,\n                const struct ipf_list_key *key2)\n    /* OVS_REQUIRES(ipf_lock) */\n{\n    if (!memcmp(&key1->src_addr, &key2->src_addr, sizeof key1->src_addr) &&\n        !memcmp(&key1->dst_addr, &key2->dst_addr, sizeof key1->dst_addr) &&\n        key1->dl_type == key2->dl_type &&\n        key1->ip_id == key2->ip_id &&\n        key1->zone == key2->zone &&\n        key1->nw_proto == key2->nw_proto &&\n        key1->recirc_id == key2->recirc_id) {\n        return true;\n    }\n    return false;\n}\n\nstatic struct ipf_list *\nipf_list_key_lookup(struct ipf *ipf, const struct ipf_list_key *key,\n                    uint32_t hash)\n    OVS_REQUIRES(ipf->ipf_lock)\n{\n    struct ipf_list *ipf_list;\n    HMAP_FOR_EACH_WITH_HASH (ipf_list, node, hash, &ipf->frag_lists) {\n        if (ipf_list_key_eq(&ipf_list->key, key)) {\n            return ipf_list;\n        }\n    }\n    return NULL;\n}\n\nstatic bool\nipf_is_frag_duped(const struct ipf_frag *frag_list, int last_inuse_idx,\n                  size_t start_data_byte, size_t end_data_byte)\n    /* OVS_REQUIRES(ipf_lock) */\n{\n    for (int i = 0; i <= last_inuse_idx; i++) {\n        if ((start_data_byte >= frag_list[i].start_data_byte &&\n            start_data_byte <= frag_list[i].end_data_byte) ||\n            (end_data_byte >= frag_list[i].start_data_byte &&\n             end_data_byte <= frag_list[i].end_data_byte)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/* Adds a fragment to a list of fragments, if the fragment is not a\n * duplicate. If the fragment is a duplicate, that fragment is marked\n * invalid to avoid the work that conntrack would do to mark the fragment\n * as invalid, which it will in all cases. */\nstatic bool\nipf_process_frag(struct ipf *ipf, struct ipf_list *ipf_list,\n                 struct dp_packet *pkt, uint16_t start_data_byte,\n                 uint16_t end_data_byte, bool ff, bool lf, bool v6)\n    OVS_REQUIRES(ipf->ipf_lock)\n{\n    bool duped_frag = ipf_is_frag_duped(ipf_list->frag_list,\n        ipf_list->last_inuse_idx, start_data_byte, end_data_byte);\n    int last_inuse_idx = ipf_list->last_inuse_idx;\n\n    if (!duped_frag) {\n        if (last_inuse_idx < ipf_list->size - 1) {\n            /* In the case of dpdk, it would be unfortunate if we had\n             * to create a clone fragment outside the dpdk mp due to the\n             * mempool size being too limited. We will otherwise need to\n             * recommend not setting the mempool number of buffers too low\n             * and also clamp the number of fragments. */\n            struct ipf_frag *frag = &ipf_list->frag_list[last_inuse_idx + 1];\n            frag->pkt = dp_packet_clone(pkt);\n            frag->start_data_byte = start_data_byte;\n            frag->end_data_byte = end_data_byte;\n            ipf_list->last_inuse_idx++;\n            atomic_count_inc(&ipf->nfrag);\n            ipf_count(ipf, v6, IPF_NFRAGS_ACCEPTED);\n            ipf_list_state_transition(ipf, ipf_list, ff, lf, v6);\n        } else {\n            OVS_NOT_REACHED();\n        }\n    } else {\n        ipf_count(ipf, v6, IPF_NFRAGS_OVERLAP);\n        pkt->md.ct_state = CS_INVALID;\n        return false;\n    }\n    return true;\n}\n\nstatic void\nipf_list_init(struct ipf_list *ipf_list, struct ipf_list_key *key,\n              int max_frag_list_size)\n{\n    ipf_list->key = *key;\n    ipf_list->last_inuse_idx = IPF_INVALID_IDX;\n    ipf_list->last_sent_idx = IPF_INVALID_IDX;\n    ipf_list->reass_execute_ctx = NULL;\n    ipf_list->state = IPF_LIST_STATE_UNUSED;\n    ipf_list->size = max_frag_list_size;\n    ipf_list->frag_list\n        = xzalloc(ipf_list->size * sizeof *ipf_list->frag_list);\n}\n\n/* Generates a fragment list key from a well formed fragment and either starts\n * a new fragment list or increases the size of the existing fragment list,\n * while checking if the maximum supported fragements are supported or the\n * list size is impossibly big. Calls 'ipf_process_frag()' to add a fragment\n * to a list of fragemnts. */\nstatic bool\nipf_handle_frag(struct ipf *ipf, struct dp_packet *pkt, ovs_be16 dl_type,\n                uint16_t zone, long long now, uint32_t hash_basis)\n    OVS_REQUIRES(ipf->ipf_lock)\n{\n    struct ipf_list_key key;\n    /* Initialize 4 variables for some versions of GCC. */\n    uint16_t start_data_byte = 0;\n    uint16_t end_data_byte = 0;\n    bool ff = false;\n    bool lf = false;\n    bool v6 = dl_type == htons(ETH_TYPE_IPV6);\n\n    if (v6 && ipf_get_v6_enabled(ipf)) {\n        ipf_v6_key_extract(pkt, dl_type, zone, &key, &start_data_byte,\n                           &end_data_byte, &ff, &lf);\n    } else if (!v6 && ipf_get_v4_enabled(ipf)) {\n        ipf_v4_key_extract(pkt, dl_type, zone, &key, &start_data_byte,\n                           &end_data_byte, &ff, &lf);\n    } else {\n        return false;\n    }\n\n    unsigned int nfrag_max;\n    atomic_read_relaxed(&ipf->nfrag_max, &nfrag_max);\n    if (atomic_count_get(&ipf->nfrag) >= nfrag_max) {\n        return false;\n    }\n\n    uint32_t hash = ipf_list_key_hash(&key, hash_basis);\n    struct ipf_list *ipf_list = ipf_list_key_lookup(ipf, &key, hash);\n    enum {\n        IPF_FRAG_LIST_MIN_INCREMENT = 4,\n        IPF_IPV6_MAX_FRAG_LIST_SIZE = 65535,\n    };\n\n    int max_frag_list_size;\n    if (v6) {\n        /* Because the calculation with extension headers is variable,\n         * we don't calculate a hard maximum fragment list size upfront.  The\n         * fragment list size is practically limited by the code, however. */\n        max_frag_list_size = IPF_IPV6_MAX_FRAG_LIST_SIZE;\n    } else {\n        max_frag_list_size = ipf->max_v4_frag_list_size;\n    }\n\n    if (!ipf_list) {\n        ipf_list = xmalloc(sizeof *ipf_list);\n        ipf_list_init(ipf_list, &key,\n                      MIN(max_frag_list_size, IPF_FRAG_LIST_MIN_INCREMENT));\n        hmap_insert(&ipf->frag_lists, &ipf_list->node, hash);\n        ipf_expiry_list_add(&ipf->frag_exp_list, ipf_list, now);\n    } else if (ipf_list->state == IPF_LIST_STATE_REASS_FAIL ||\n               ipf_list->state == IPF_LIST_STATE_COMPLETED) {\n        /* Bail out as early as possible. */\n        return false;\n    } else if (ipf_list->last_inuse_idx + 1 >= ipf_list->size) {\n        int increment = MIN(IPF_FRAG_LIST_MIN_INCREMENT,\n                            max_frag_list_size - ipf_list->size);\n        /* Enforce limit. */\n        if (increment > 0) {\n            ipf_list->frag_list =\n                xrealloc(ipf_list->frag_list, (ipf_list->size + increment) *\n                  sizeof *ipf_list->frag_list);\n            ipf_list->size += increment;\n        } else {\n            return false;\n        }\n    }\n\n    return ipf_process_frag(ipf, ipf_list, pkt, start_data_byte,\n                            end_data_byte, ff, lf, v6);\n}\n\n/* Filters out fragments from a batch of fragments and adjust the batch. */\nstatic void\nipf_extract_frags_from_batch(struct ipf *ipf, struct dp_packet_batch *pb,\n                             ovs_be16 dl_type, uint16_t zone, long long now,\n                             uint32_t hash_basis)\n{\n    const size_t pb_cnt = dp_packet_batch_size(pb);\n    int pb_idx; /* Index in a packet batch. */\n    struct dp_packet *pkt;\n\n    DP_PACKET_BATCH_REFILL_FOR_EACH (pb_idx, pb_cnt, pkt, pb) {\n        if (OVS_UNLIKELY((dl_type == htons(ETH_TYPE_IP) &&\n                          ipf_is_valid_v4_frag(ipf, pkt))\n                          ||\n                          (dl_type == htons(ETH_TYPE_IPV6) &&\n                          ipf_is_valid_v6_frag(ipf, pkt)))) {\n\n            ovs_mutex_lock(&ipf->ipf_lock);\n            if (!ipf_handle_frag(ipf, pkt, dl_type, zone, now, hash_basis)) {\n                dp_packet_batch_refill(pb, pkt, pb_idx);\n            } else {\n                dp_packet_delete(pkt);\n            }\n            ovs_mutex_unlock(&ipf->ipf_lock);\n        } else {\n            dp_packet_batch_refill(pb, pkt, pb_idx);\n        }\n    }\n}\n\n/* In case of DPDK, a memory source check is done, as DPDK memory pool\n * management has trouble dealing with multiple source types.  The\n * check_source paramater is used to indicate when this check is needed. */\nstatic bool\nipf_dp_packet_batch_add(struct dp_packet_batch *pb , struct dp_packet *pkt,\n                        bool check_source OVS_UNUSED)\n{\n#ifdef DPDK_NETDEV\n    if ((dp_packet_batch_is_full(pb)) ||\n        /* DPDK cannot handle multiple sources in a batch. */\n        (check_source && !dp_packet_batch_is_empty(pb)\n         && pb->packets[0]->source != pkt->source)) {\n#else\n    if (dp_packet_batch_is_full(pb)) {\n#endif\n        return false;\n    }\n\n    dp_packet_batch_add(pb, pkt);\n    return true;\n}\n\n/* This would be used in rare cases where a list cannot be sent. One rare\n * reason known right now is a mempool source check, which exists due to DPDK\n * support, where packets are no longer being received on any port with a\n * source matching the fragment.  Another reason is a race where all\n * conntrack rules are unconfigured when some fragments are yet to be\n * flushed.\n *\n * Returns true if the list was purged. */\nstatic bool\nipf_purge_list_check(struct ipf *ipf, struct ipf_list *ipf_list,\n                     long long now)\n    OVS_REQUIRES(ipf->ipf_lock)\n{\n    enum {\n        IPF_FRAG_LIST_PURGE_TIME_ADJ = 10000\n    };\n\n    if (now < ipf_list->expiration + IPF_FRAG_LIST_PURGE_TIME_ADJ) {\n        return false;\n    }\n\n    while (ipf_list->last_sent_idx < ipf_list->last_inuse_idx) {\n        struct dp_packet * pkt\n            = ipf_list->frag_list[ipf_list->last_sent_idx + 1].pkt;\n        dp_packet_delete(pkt);\n        atomic_count_dec(&ipf->nfrag);\n        COVERAGE_INC(ipf_stuck_frag_list_purged);\n        ipf_count(ipf, ipf_list->key.dl_type == htons(ETH_TYPE_IPV6),\n                  IPF_NFRAGS_PURGED);\n        ipf_list->last_sent_idx++;\n    }\n\n    return true;\n}\n\n/* Does the packet batch management and common accounting work associated\n * with 'ipf_send_completed_frags()' and 'ipf_send_expired_frags()'. */\nstatic bool\nipf_send_frags_in_list(struct ipf *ipf, struct ipf_list *ipf_list,\n                       struct dp_packet_batch *pb,\n                       enum ipf_list_type list_type, bool v6, long long now)\n    OVS_REQUIRES(ipf->ipf_lock)\n{\n    if (ipf_purge_list_check(ipf, ipf_list, now)) {\n        return true;\n    }\n\n    while (ipf_list->last_sent_idx < ipf_list->last_inuse_idx) {\n        struct dp_packet *pkt\n            = ipf_list->frag_list[ipf_list->last_sent_idx + 1].pkt;\n        if (ipf_dp_packet_batch_add(pb, pkt, true)) {\n            ipf_list->last_sent_idx++;\n            atomic_count_dec(&ipf->nfrag);\n\n            if (list_type == IPF_FRAG_COMPLETED_LIST) {\n                ipf_count(ipf, v6, IPF_NFRAGS_COMPL_SENT);\n            } else {\n                ipf_count(ipf, v6, IPF_NFRAGS_EXPD_SENT);\n                pkt->md.ct_state = CS_INVALID;\n            }\n\n            if (ipf_list->last_sent_idx == ipf_list->last_inuse_idx) {\n                return true;\n            }\n        } else {\n            return false;\n        }\n    }\n    OVS_NOT_REACHED();\n}\n\n/* Adds fragments associated with a completed fragment list to a packet batch\n * to be processed by the calling application, typically conntrack. Also\n * cleans up the list context when it is empty.*/\nstatic void\nipf_send_completed_frags(struct ipf *ipf, struct dp_packet_batch *pb,\n                         long long now, bool v6)\n{\n    if (ovs_list_is_empty(&ipf->frag_complete_list)) {\n        return;\n    }\n\n    ovs_mutex_lock(&ipf->ipf_lock);\n    struct ipf_list *ipf_list, *next;\n\n    LIST_FOR_EACH_SAFE (ipf_list, next, list_node, &ipf->frag_complete_list) {\n        if (ipf_send_frags_in_list(ipf, ipf_list, pb, IPF_FRAG_COMPLETED_LIST,\n                                   v6, now)) {\n            ipf_completed_list_clean(&ipf->frag_lists, ipf_list);\n        } else {\n            break;\n        }\n    }\n\n    ovs_mutex_unlock(&ipf->ipf_lock);\n}\n\n/* Conservatively adds fragments associated with a expired fragment list to\n * a packet batch to be processed by the calling application, typically\n * conntrack. Also cleans up the list context when it is empty.*/\nstatic void\nipf_send_expired_frags(struct ipf *ipf, struct dp_packet_batch *pb,\n                       long long now, bool v6)\n{\n    enum {\n        /* Very conservative, due to DOS probability. */\n        IPF_FRAG_LIST_MAX_EXPIRED = 1,\n    };\n\n\n    if (ovs_list_is_empty(&ipf->frag_exp_list)) {\n        return;\n    }\n\n    ovs_mutex_lock(&ipf->ipf_lock);\n    struct ipf_list *ipf_list, *next;\n    size_t lists_removed = 0;\n\n    LIST_FOR_EACH_SAFE (ipf_list, next, list_node, &ipf->frag_exp_list) {\n        if (now <= ipf_list->expiration ||\n            lists_removed >= IPF_FRAG_LIST_MAX_EXPIRED) {\n            break;\n        }\n\n        if (ipf_send_frags_in_list(ipf, ipf_list, pb, IPF_FRAG_EXPIRY_LIST,\n                                   v6, now)) {\n            ipf_expiry_list_clean(&ipf->frag_lists, ipf_list);\n            lists_removed++;\n        } else {\n            break;\n        }\n    }\n\n    ovs_mutex_unlock(&ipf->ipf_lock);\n}\n\n/* Adds a reassmebled packet to a packet batch to be processed by the caller.\n */\nstatic void\nipf_execute_reass_pkts(struct ipf *ipf, struct dp_packet_batch *pb)\n{\n    if (ovs_list_is_empty(&ipf->reassembled_pkt_list)) {\n        return;\n    }\n\n    ovs_mutex_lock(&ipf->ipf_lock);\n    struct reassembled_pkt *rp, *next;\n\n    LIST_FOR_EACH_SAFE (rp, next, rp_list_node, &ipf->reassembled_pkt_list) {\n        if (!rp->list->reass_execute_ctx &&\n            ipf_dp_packet_batch_add(pb, rp->pkt, false)) {\n            rp->list->reass_execute_ctx = rp->pkt;\n        }\n    }\n\n    ovs_mutex_unlock(&ipf->ipf_lock);\n}\n\n/* Checks for reassembled packets post processing by conntrack and edits the\n * fragments if needed based on what conntrack decided. */\nstatic void\nipf_post_execute_reass_pkts(struct ipf *ipf,\n                            struct dp_packet_batch *pb, bool v6)\n{\n    if (ovs_list_is_empty(&ipf->reassembled_pkt_list)) {\n        return;\n    }\n\n    ovs_mutex_lock(&ipf->ipf_lock);\n    struct reassembled_pkt *rp, *next;\n\n    LIST_FOR_EACH_SAFE (rp, next, rp_list_node, &ipf->reassembled_pkt_list) {\n        const size_t pb_cnt = dp_packet_batch_size(pb);\n        int pb_idx;\n        struct dp_packet *pkt;\n        /* Inner batch loop is constant time since batch size is <=\n         * NETDEV_MAX_BURST. */\n        DP_PACKET_BATCH_REFILL_FOR_EACH (pb_idx, pb_cnt, pkt, pb) {\n            if (rp && pkt == rp->list->reass_execute_ctx) {\n                const struct ipf_frag *frag_0 = &rp->list->frag_list[0];\n                void *l4_frag = dp_packet_l4(frag_0->pkt);\n                void *l4_reass = dp_packet_l4(pkt);\n                memcpy(l4_frag, l4_reass, dp_packet_l4_size(frag_0->pkt));\n\n                for (int i = 0; i <= rp->list->last_inuse_idx; i++) {\n                    const struct ipf_frag *frag_i = &rp->list->frag_list[i];\n\n                    frag_i->pkt->md.ct_label = pkt->md.ct_label;\n                    frag_i->pkt->md.ct_mark = pkt->md.ct_mark;\n                    frag_i->pkt->md.ct_state = pkt->md.ct_state;\n                    frag_i->pkt->md.ct_zone = pkt->md.ct_zone;\n                    frag_i->pkt->md.ct_orig_tuple_ipv6 =\n                        pkt->md.ct_orig_tuple_ipv6;\n                    if (pkt->md.ct_orig_tuple_ipv6) {\n                        frag_i->pkt->md.ct_orig_tuple.ipv6 =\n                            pkt->md.ct_orig_tuple.ipv6;\n                    } else {\n                        frag_i->pkt->md.ct_orig_tuple.ipv4 =\n                            pkt->md.ct_orig_tuple.ipv4;\n                    }\n                    if (v6) {\n                        struct ovs_16aligned_ip6_hdr *l3_frag\n                            = dp_packet_l3(frag_i->pkt);\n                        struct ovs_16aligned_ip6_hdr *l3_reass\n                            = dp_packet_l3(pkt);\n                        l3_frag->ip6_src = l3_reass->ip6_src;\n                        l3_frag->ip6_dst = l3_reass->ip6_dst;\n                    } else {\n                        struct ip_header *l3_frag = dp_packet_l3(frag_i->pkt);\n                        struct ip_header *l3_reass = dp_packet_l3(pkt);\n                        if (!dp_packet_hwol_is_ipv4(frag_i->pkt)) {\n                            ovs_be32 reass_ip =\n                                get_16aligned_be32(&l3_reass->ip_src);\n                            ovs_be32 frag_ip =\n                                get_16aligned_be32(&l3_frag->ip_src);\n\n                            l3_frag->ip_csum = recalc_csum32(l3_frag->ip_csum,\n                                                             frag_ip,\n                                                             reass_ip);\n                            reass_ip = get_16aligned_be32(&l3_reass->ip_dst);\n                            frag_ip = get_16aligned_be32(&l3_frag->ip_dst);\n                            l3_frag->ip_csum = recalc_csum32(l3_frag->ip_csum,\n                                                             frag_ip,\n                                                             reass_ip);\n                        }\n\n                        l3_frag->ip_src = l3_reass->ip_src;\n                        l3_frag->ip_dst = l3_reass->ip_dst;\n                    }\n                }\n\n                ipf_completed_list_add(&ipf->frag_complete_list, rp->list);\n                ipf_reassembled_list_remove(rp);\n                dp_packet_delete(rp->pkt);\n                free(rp);\n                rp = NULL;\n            } else {\n                dp_packet_batch_refill(pb, pkt, pb_idx);\n            }\n        }\n    }\n\n    ovs_mutex_unlock(&ipf->ipf_lock);\n}\n\n/* Extracts any fragments from the batch and reassembles them when a\n * complete packet is received.  Completed packets are attempted to\n * be added to the batch to be sent through conntrack. */\nvoid\nipf_preprocess_conntrack(struct ipf *ipf, struct dp_packet_batch *pb,\n                         long long now, ovs_be16 dl_type, uint16_t zone,\n                         uint32_t hash_basis)\n{\n    if (ipf_get_enabled(ipf)) {\n        ipf_extract_frags_from_batch(ipf, pb, dl_type, zone, now, hash_basis);\n    }\n\n    if (ipf_get_enabled(ipf) || atomic_count_get(&ipf->nfrag)) {\n        ipf_execute_reass_pkts(ipf, pb);\n    }\n}\n\n/* Updates fragments based on the processing of the reassembled packet sent\n * through conntrack and adds these fragments to any batches seen.  Expired\n * fragments are marked as invalid and also added to the batches seen\n * with low priority.  Reassembled packets are freed. */\nvoid\nipf_postprocess_conntrack(struct ipf *ipf, struct dp_packet_batch *pb,\n                          long long now, ovs_be16 dl_type)\n{\n    if (ipf_get_enabled(ipf) || atomic_count_get(&ipf->nfrag)) {\n        bool v6 = dl_type == htons(ETH_TYPE_IPV6);\n        ipf_post_execute_reass_pkts(ipf, pb, v6);\n        ipf_send_completed_frags(ipf, pb, now, v6);\n        ipf_send_expired_frags(ipf, pb, now, v6);\n    }\n}\n\nstatic void *\nipf_clean_thread_main(void *f)\n{\n    struct ipf *ipf = f;\n\n    enum {\n        IPF_FRAG_LIST_CLEAN_TIMEOUT = 60000,\n    };\n\n    while (!latch_is_set(&ipf->ipf_clean_thread_exit)) {\n\n        long long now = time_msec();\n\n        if (!ovs_list_is_empty(&ipf->frag_exp_list) ||\n            !ovs_list_is_empty(&ipf->frag_complete_list)) {\n\n            ovs_mutex_lock(&ipf->ipf_lock);\n\n            struct ipf_list *ipf_list, *next;\n            LIST_FOR_EACH_SAFE (ipf_list, next, list_node,\n                                &ipf->frag_exp_list) {\n                if (ipf_purge_list_check(ipf, ipf_list, now)) {\n                    ipf_expiry_list_clean(&ipf->frag_lists, ipf_list);\n                }\n            }\n\n            LIST_FOR_EACH_SAFE (ipf_list, next, list_node,\n                                &ipf->frag_complete_list) {\n                if (ipf_purge_list_check(ipf, ipf_list, now)) {\n                    ipf_completed_list_clean(&ipf->frag_lists, ipf_list);\n                }\n            }\n\n            ovs_mutex_unlock(&ipf->ipf_lock);\n        }\n\n        poll_timer_wait_until(now + IPF_FRAG_LIST_CLEAN_TIMEOUT);\n        latch_wait(&ipf->ipf_clean_thread_exit);\n        poll_block();\n    }\n\n    return NULL;\n}\n\nstruct ipf *\nipf_init(void)\n{\n    struct ipf *ipf = xzalloc(sizeof *ipf);\n\n    ovs_mutex_init_adaptive(&ipf->ipf_lock);\n    ovs_mutex_lock(&ipf->ipf_lock);\n    hmap_init(&ipf->frag_lists);\n    ovs_list_init(&ipf->frag_exp_list);\n    ovs_list_init(&ipf->frag_complete_list);\n    ovs_list_init(&ipf->reassembled_pkt_list);\n    atomic_init(&ipf->min_v4_frag_size, IPF_V4_FRAG_SIZE_MIN_DEF);\n    atomic_init(&ipf->min_v6_frag_size, IPF_V6_FRAG_SIZE_MIN_DEF);\n    ipf->max_v4_frag_list_size = DIV_ROUND_UP(\n        IPV4_PACKET_MAX_SIZE - IPV4_PACKET_MAX_HDR_SIZE,\n        ipf->min_v4_frag_size - IPV4_PACKET_MAX_HDR_SIZE);\n    ovs_mutex_unlock(&ipf->ipf_lock);\n    atomic_count_init(&ipf->nfrag, 0);\n    for (size_t i = 0; i < IPF_NFRAGS_NUM_CNTS; i++) {\n        atomic_init(&ipf->n4frag_cnt[i], 0);\n        atomic_init(&ipf->n6frag_cnt[i], 0);\n    }\n    atomic_init(&ipf->nfrag_max, IPF_MAX_FRAGS_DEFAULT);\n    atomic_init(&ipf->ifp_v4_enabled, true);\n    atomic_init(&ipf->ifp_v6_enabled, true);\n    latch_init(&ipf->ipf_clean_thread_exit);\n    ipf->ipf_clean_thread = ovs_thread_create(\"ipf_clean\",\n                                         ipf_clean_thread_main, ipf);\n\n    return ipf;\n}\n\nvoid\nipf_destroy(struct ipf *ipf)\n{\n    ovs_mutex_lock(&ipf->ipf_lock);\n    latch_set(&ipf->ipf_clean_thread_exit);\n    pthread_join(ipf->ipf_clean_thread, NULL);\n    latch_destroy(&ipf->ipf_clean_thread_exit);\n\n    struct ipf_list *ipf_list;\n    HMAP_FOR_EACH_POP (ipf_list, node, &ipf->frag_lists) {\n        while (ipf_list->last_sent_idx < ipf_list->last_inuse_idx) {\n            struct dp_packet *pkt\n                = ipf_list->frag_list[ipf_list->last_sent_idx + 1].pkt;\n            dp_packet_delete(pkt);\n            atomic_count_dec(&ipf->nfrag);\n            ipf_list->last_sent_idx++;\n        }\n        free(ipf_list->frag_list);\n        free(ipf_list);\n    }\n\n    if (atomic_count_get(&ipf->nfrag)) {\n        VLOG_WARN(\"ipf destroy with non-zero fragment count. \");\n    }\n\n    struct reassembled_pkt *rp;\n    LIST_FOR_EACH_POP (rp, rp_list_node, &ipf->reassembled_pkt_list) {\n        dp_packet_delete(rp->pkt);\n        free(rp);\n    }\n\n    hmap_destroy(&ipf->frag_lists);\n    ovs_list_poison(&ipf->frag_exp_list);\n    ovs_list_poison(&ipf->frag_complete_list);\n    ovs_list_poison(&ipf->reassembled_pkt_list);\n    ovs_mutex_unlock(&ipf->ipf_lock);\n    ovs_mutex_destroy(&ipf->ipf_lock);\n    free(ipf);\n}\n\nint\nipf_set_enabled(struct ipf *ipf, bool v6, bool enable)\n{\n    atomic_store_relaxed(v6 ? &ipf->ifp_v6_enabled : &ipf->ifp_v4_enabled,\n                         enable);\n    return 0;\n}\n\nint\nipf_set_min_frag(struct ipf *ipf, bool v6, uint32_t value)\n{\n    /* If the user specifies an unreasonably large number, fragmentation\n     * will not work well but it will not blow up. */\n    if (value < (v6 ? IPF_V6_FRAG_SIZE_LBOUND :  IPF_V4_FRAG_SIZE_LBOUND)) {\n        return 1;\n    }\n\n    ovs_mutex_lock(&ipf->ipf_lock);\n    if (v6) {\n        atomic_store_relaxed(&ipf->min_v6_frag_size, value);\n    } else {\n        atomic_store_relaxed(&ipf->min_v4_frag_size, value);\n        ipf->max_v4_frag_list_size = DIV_ROUND_UP(\n            IPV4_PACKET_MAX_SIZE - IPV4_PACKET_MAX_HDR_SIZE,\n            ipf->min_v4_frag_size - IPV4_PACKET_MAX_HDR_SIZE);\n    }\n    ovs_mutex_unlock(&ipf->ipf_lock);\n    return 0;\n}\n\nint\nipf_set_max_nfrags(struct ipf *ipf, uint32_t value)\n{\n    if (value > IPF_NFRAG_UBOUND) {\n        return 1;\n    }\n    atomic_store_relaxed(&ipf->nfrag_max, value);\n    return 0;\n}\n\nint\nipf_get_status(struct ipf *ipf, struct ipf_status *ipf_status)\n{\n    ipf_status->nfrag = atomic_count_get(&ipf->nfrag);\n    atomic_read_relaxed(&ipf->nfrag_max, &ipf_status->nfrag_max);\n\n    atomic_read_relaxed(&ipf->ifp_v4_enabled, &ipf_status->v4.enabled);\n    atomic_read_relaxed(&ipf->min_v4_frag_size,\n                        &ipf_status->v4.min_frag_size);\n    atomic_read_relaxed(&ipf->n4frag_cnt[IPF_NFRAGS_ACCEPTED],\n                        &ipf_status->v4.nfrag_accepted);\n    atomic_read_relaxed(&ipf->n4frag_cnt[IPF_NFRAGS_COMPL_SENT],\n                        &ipf_status->v4.nfrag_completed_sent);\n    atomic_read_relaxed(&ipf->n4frag_cnt[IPF_NFRAGS_EXPD_SENT],\n                        &ipf_status->v4.nfrag_expired_sent);\n    atomic_read_relaxed(&ipf->n4frag_cnt[IPF_NFRAGS_TOO_SMALL],\n                        &ipf_status->v4.nfrag_too_small);\n    atomic_read_relaxed(&ipf->n4frag_cnt[IPF_NFRAGS_OVERLAP],\n                        &ipf_status->v4.nfrag_overlap);\n    atomic_read_relaxed(&ipf->n4frag_cnt[IPF_NFRAGS_PURGED],\n                        &ipf_status->v4.nfrag_purged);\n\n    atomic_read_relaxed(&ipf->ifp_v6_enabled, &ipf_status->v6.enabled);\n    atomic_read_relaxed(&ipf->min_v6_frag_size,\n                        &ipf_status->v6.min_frag_size);\n    atomic_read_relaxed(&ipf->n6frag_cnt[IPF_NFRAGS_ACCEPTED],\n                        &ipf_status->v6.nfrag_accepted);\n    atomic_read_relaxed(&ipf->n6frag_cnt[IPF_NFRAGS_COMPL_SENT],\n                        &ipf_status->v6.nfrag_completed_sent);\n    atomic_read_relaxed(&ipf->n6frag_cnt[IPF_NFRAGS_EXPD_SENT],\n                        &ipf_status->v6.nfrag_expired_sent);\n    atomic_read_relaxed(&ipf->n6frag_cnt[IPF_NFRAGS_TOO_SMALL],\n                        &ipf_status->v6.nfrag_too_small);\n    atomic_read_relaxed(&ipf->n6frag_cnt[IPF_NFRAGS_OVERLAP],\n                        &ipf_status->v6.nfrag_overlap);\n    atomic_read_relaxed(&ipf->n6frag_cnt[IPF_NFRAGS_PURGED],\n                        &ipf_status->v6.nfrag_purged);\n    return 0;\n}\n\nstruct ipf_dump_ctx {\n    struct hmap_position bucket_pos;\n};\n\n/* Allocates an 'ipf_dump_ctx' to keep track of an hmap position. The\n * caller must call ipf_dump_done() when dumping is finished. */\nint\nipf_dump_start(struct ipf_dump_ctx **ipf_dump_ctx)\n{\n    *ipf_dump_ctx = xzalloc(sizeof **ipf_dump_ctx);\n    return 0;\n}\n\n/* Creates a string representation of the state of an 'ipf_list' and puts\n * it in 'ds'. */\nstatic void\nipf_dump_create(const struct ipf_list *ipf_list, struct ds *ds)\n{\n    ds_put_cstr(ds, \"(\");\n    if (ipf_list->key.dl_type == htons(ETH_TYPE_IP)) {\n        ds_put_format(ds, \"src=\"IP_FMT\",dst=\"IP_FMT\",\",\n                      IP_ARGS(ipf_list->key.src_addr.ipv4),\n                      IP_ARGS(ipf_list->key.dst_addr.ipv4));\n    } else {\n        ds_put_cstr(ds, \"src=\");\n        ipv6_format_addr(&ipf_list->key.src_addr.ipv6, ds);\n        ds_put_cstr(ds, \",dst=\");\n        ipv6_format_addr(&ipf_list->key.dst_addr.ipv6, ds);\n        ds_put_cstr(ds, \",\");\n    }\n\n    ds_put_format(ds, \"recirc_id=%u,ip_id=%u,dl_type=0x%x,zone=%u,nw_proto=%u\",\n                  ipf_list->key.recirc_id, ntohl(ipf_list->key.ip_id),\n                  ntohs(ipf_list->key.dl_type), ipf_list->key.zone,\n                  ipf_list->key.nw_proto);\n\n    ds_put_format(ds, \",num_fragments=%u,state=%s\",\n                  ipf_list->last_inuse_idx + 1,\n                  ipf_state_name[ipf_list->state]);\n\n    ds_put_cstr(ds, \")\");\n}\n\n/* Finds the next ipf list starting from 'ipf_dump_ctx->bucket_pos' and uses\n * ipf_dump_create() to create a string representation of the state of an\n * ipf list, to which 'dump' is pointed to.  Returns EOF when there are no\n * more ipf lists. */\nint\nipf_dump_next(struct ipf *ipf, struct ipf_dump_ctx *ipf_dump_ctx, char **dump)\n{\n    ovs_mutex_lock(&ipf->ipf_lock);\n\n    struct hmap_node *node = hmap_at_position(&ipf->frag_lists,\n                                              &ipf_dump_ctx->bucket_pos);\n    if (!node) {\n        ovs_mutex_unlock(&ipf->ipf_lock);\n        return EOF;\n    } else {\n        struct ipf_list *ipf_list_;\n        INIT_CONTAINER(ipf_list_, node, node);\n        struct ipf_list ipf_list = *ipf_list_;\n        ovs_mutex_unlock(&ipf->ipf_lock);\n        struct ds ds = DS_EMPTY_INITIALIZER;\n        ipf_dump_create(&ipf_list, &ds);\n        *dump = ds_steal_cstr(&ds);\n        return 0;\n    }\n}\n\n/* Frees 'ipf_dump_ctx' allocated by ipf_dump_start(). */\nint\nipf_dump_done(struct ipf_dump_ctx *ipf_dump_ctx)\n{\n    free(ipf_dump_ctx);\n    return 0;\n}\n"], "filenames": ["lib/ipf.c"], "buggy_code_start_loc": [945], "buggy_code_end_loc": [945], "fixing_code_start_loc": [946], "fixing_code_end_loc": [948], "type": "CWE-401", "message": "A memory leak was found in Open vSwitch (OVS) during userspace IP fragmentation processing. An attacker could use this flaw to potentially exhaust available memory by keeping sending packet fragments.", "other": {"cve": {"id": "CVE-2021-3905", "sourceIdentifier": "secalert@redhat.com", "published": "2022-08-23T16:15:10.177", "lastModified": "2022-08-27T02:01:53.313", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A memory leak was found in Open vSwitch (OVS) during userspace IP fragmentation processing. An attacker could use this flaw to potentially exhaust available memory by keeping sending packet fragments."}, {"lang": "es", "value": "Se ha encontrado una p\u00e9rdida de memoria en Open vSwitch (OVS) durante el procesamiento de la fragmentaci\u00f3n IP en el espacio de usuario. Un atacante podr\u00eda usar este fallo para agotar potencialmente la memoria disponible al seguir enviando fragmentos de paquetes."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openvswitch:openvswitch:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.17.0", "matchCriteriaId": "59369EE4-B970-4222-AA4E-276928B1016B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:enterprise_linux_fast_datapath:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "559A4609-EC7E-40CD-9165-5DA68CBCEE9B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:enterprise_linux_fast_datapath:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "BAE5723C-165D-4427-A8DF-82662A2E7A9F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:21.10:*:*:*:*:*:*:*", "matchCriteriaId": "AAE4D2D0-CEEB-416F-8BC5-A7987DF56190"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2021-3905", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2019692", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/openvswitch/ovs-issues/issues/226", "source": "secalert@redhat.com", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/openvswitch/ovs/commit/803ed12e31b0377c37d7aa8c94b3b92f2081e349", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://ubuntu.com/security/CVE-2021-3905", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openvswitch/ovs/commit/803ed12e31b0377c37d7aa8c94b3b92f2081e349"}}