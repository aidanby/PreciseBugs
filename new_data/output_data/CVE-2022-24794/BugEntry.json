{"buggy_code": ["const cb = require('cb');\nconst url = require('url');\nconst urlJoin = require('url-join');\nconst { TokenSet } = require('openid-client');\nconst clone = require('clone');\nconst { strict: assert } = require('assert');\n\nconst debug = require('./debug')('context');\nconst { get: getClient } = require('./client');\nconst { encodeState } = require('../lib/hooks/getLoginState');\nconst { cancelSilentLogin } = require('../middleware/attemptSilentLogin');\nconst weakRef = require('./weakCache');\n\nfunction isExpired() {\n  return tokenSet.call(this).expired();\n}\n\nasync function refresh({ tokenEndpointParams } = {}) {\n  let { config, req } = weakRef(this);\n  const client = await getClient(config);\n  const oldTokenSet = tokenSet.call(this);\n\n  let extras;\n  if (config.tokenEndpointParams || tokenEndpointParams) {\n    extras = {\n      exchangeBody: { ...config.tokenEndpointParams, ...tokenEndpointParams },\n    };\n  }\n\n  const newTokenSet = await client.refresh(oldTokenSet, extras);\n\n  // Update the session\n  const session = req[config.session.name];\n  Object.assign(session, {\n    id_token: newTokenSet.id_token,\n    access_token: newTokenSet.access_token,\n    // If no new refresh token assume the current refresh token is valid.\n    refresh_token: newTokenSet.refresh_token || oldTokenSet.refresh_token,\n    token_type: newTokenSet.token_type,\n    expires_at: newTokenSet.expires_at,\n  });\n\n  // Delete the old token set\n  const cachedTokenSet = weakRef(session);\n  delete cachedTokenSet.value;\n\n  return this.accessToken;\n}\n\nfunction tokenSet() {\n  const contextCache = weakRef(this);\n  const session = contextCache.req[contextCache.config.session.name];\n\n  if (!session || !('id_token' in session)) {\n    return undefined;\n  }\n\n  const cachedTokenSet = weakRef(session);\n\n  if (!('value' in cachedTokenSet)) {\n    const {\n      id_token,\n      access_token,\n      refresh_token,\n      token_type,\n      expires_at,\n    } = session;\n    cachedTokenSet.value = new TokenSet({\n      id_token,\n      access_token,\n      refresh_token,\n      token_type,\n      expires_at,\n    });\n  }\n\n  return cachedTokenSet.value;\n}\n\nclass RequestContext {\n  constructor(config, req, res, next) {\n    Object.assign(weakRef(this), { config, req, res, next });\n  }\n\n  isAuthenticated() {\n    return !!this.idTokenClaims;\n  }\n\n  get idToken() {\n    try {\n      return tokenSet.call(this).id_token;\n    } catch (err) {\n      return undefined;\n    }\n  }\n\n  get refreshToken() {\n    try {\n      return tokenSet.call(this).refresh_token;\n    } catch (err) {\n      return undefined;\n    }\n  }\n\n  get accessToken() {\n    try {\n      const { access_token, token_type, expires_in } = tokenSet.call(this);\n\n      if (!access_token || !token_type || typeof expires_in !== 'number') {\n        return undefined;\n      }\n\n      return {\n        access_token,\n        token_type,\n        expires_in,\n        isExpired: isExpired.bind(this),\n        refresh: refresh.bind(this),\n      };\n    } catch (err) {\n      return undefined;\n    }\n  }\n\n  get idTokenClaims() {\n    try {\n      return clone(tokenSet.call(this).claims());\n    } catch (err) {\n      return undefined;\n    }\n  }\n\n  get user() {\n    try {\n      const {\n        config: { identityClaimFilter },\n      } = weakRef(this);\n      const { idTokenClaims } = this;\n      const user = clone(idTokenClaims);\n      identityClaimFilter.forEach((claim) => {\n        delete user[claim];\n      });\n      return user;\n    } catch (err) {\n      return undefined;\n    }\n  }\n\n  async fetchUserInfo() {\n    const { config } = weakRef(this);\n\n    const client = await getClient(config);\n    return client.userinfo(tokenSet.call(this));\n  }\n}\n\nclass ResponseContext {\n  constructor(config, req, res, next, transient) {\n    Object.assign(weakRef(this), { config, req, res, next, transient });\n  }\n\n  get errorOnRequiredAuth() {\n    return weakRef(this).config.errorOnRequiredAuth;\n  }\n\n  getRedirectUri() {\n    const { config } = weakRef(this);\n    return urlJoin(config.baseURL, config.routes.callback);\n  }\n\n  silentLogin(options = {}) {\n    return this.login({\n      ...options,\n      silent: true,\n      authorizationParams: { ...options.authorizationParams, prompt: 'none' },\n    });\n  }\n\n  async login(options = {}) {\n    let { config, req, res, next, transient } = weakRef(this);\n    next = cb(next).once();\n    const client = await getClient(config);\n\n    // Set default returnTo value, allow passed-in options to override or use originalUrl on GET\n    let returnTo = config.baseURL;\n    if (options.returnTo) {\n      returnTo = options.returnTo;\n      debug('req.oidc.login() called with returnTo: %s', returnTo);\n    } else if (req.method === 'GET' && req.originalUrl) {\n      returnTo = req.originalUrl;\n      debug('req.oidc.login() without returnTo, using: %s', returnTo);\n    }\n\n    options = {\n      authorizationParams: {},\n      returnTo,\n      ...options,\n    };\n\n    // Ensure a redirect_uri, merge in configuration options, then passed-in options.\n    options.authorizationParams = {\n      redirect_uri: this.getRedirectUri(),\n      ...config.authorizationParams,\n      ...options.authorizationParams,\n    };\n\n    const stateValue = await config.getLoginState(req, options);\n    if (typeof stateValue !== 'object') {\n      next(new Error('Custom state value must be an object.'));\n    }\n    stateValue.nonce = transient.generateNonce();\n    if (options.silent) {\n      stateValue.attemptingSilentLogin = true;\n    }\n\n    const usePKCE = options.authorizationParams.response_type.includes('code');\n    if (usePKCE) {\n      debug(\n        'response_type includes code, the authorization request will use PKCE'\n      );\n      stateValue.code_verifier = transient.generateCodeVerifier();\n    }\n\n    try {\n      const validResponseTypes = ['id_token', 'code id_token', 'code'];\n      assert(\n        validResponseTypes.includes(options.authorizationParams.response_type),\n        `response_type should be one of ${validResponseTypes.join(', ')}`\n      );\n      assert(\n        /\\bopenid\\b/.test(options.authorizationParams.scope),\n        'scope should contain \"openid\"'\n      );\n\n      const authVerification = {\n        nonce: transient.generateNonce(),\n        state: encodeState(stateValue),\n        ...(options.authorizationParams.max_age\n          ? {\n              max_age: options.authorizationParams.max_age,\n            }\n          : undefined),\n      };\n      const authParams = {\n        ...options.authorizationParams,\n        ...authVerification,\n      };\n\n      if (usePKCE) {\n        authVerification.code_verifier = transient.generateNonce();\n\n        authParams.code_challenge_method = 'S256';\n        authParams.code_challenge = transient.calculateCodeChallenge(\n          authVerification.code_verifier\n        );\n      }\n\n      transient.store('auth_verification', req, res, {\n        sameSite:\n          options.authorizationParams.response_mode === 'form_post'\n            ? 'None'\n            : config.transactionCookie.sameSite,\n        value: JSON.stringify(authVerification),\n      });\n\n      const authorizationUrl = client.authorizationUrl(authParams);\n      debug('redirecting to %s', authorizationUrl);\n      res.redirect(authorizationUrl);\n    } catch (err) {\n      next(err);\n    }\n  }\n\n  async logout(params = {}) {\n    let { config, req, res, next } = weakRef(this);\n    next = cb(next).once();\n    const client = await getClient(config);\n\n    let returnURL = params.returnTo || config.routes.postLogoutRedirect;\n    debug('req.oidc.logout() with return url: %s', returnURL);\n\n    if (url.parse(returnURL).host === null) {\n      returnURL = urlJoin(config.baseURL, returnURL);\n    }\n\n    cancelSilentLogin(req, res);\n\n    if (!req.oidc.isAuthenticated()) {\n      debug('end-user already logged out, redirecting to %s', returnURL);\n      return res.redirect(returnURL);\n    }\n\n    const { idToken: id_token_hint } = req.oidc;\n    req[config.session.name] = undefined;\n\n    if (!config.idpLogout) {\n      debug('performing a local only logout, redirecting to %s', returnURL);\n      return res.redirect(returnURL);\n    }\n\n    try {\n      returnURL = client.endSessionUrl({\n        ...config.logoutParams,\n        ...params.logoutParams,\n        post_logout_redirect_uri: returnURL,\n        id_token_hint,\n      });\n    } catch (err) {\n      return next(err);\n    }\n\n    debug('logging out of identity provider, redirecting to %s', returnURL);\n    res.redirect(returnURL);\n  }\n}\n\nmodule.exports = { RequestContext, ResponseContext };\n", "const { assert } = require('chai');\nconst sinon = require('sinon');\nconst { create: createServer } = require('./fixture/server');\nconst { makeIdToken } = require('./fixture/cert');\nconst {\n  auth,\n  requiresAuth,\n  claimEquals,\n  claimIncludes,\n  claimCheck,\n} = require('./..');\nconst request = require('request-promise-native').defaults({\n  simple: false,\n  resolveWithFullResponse: true,\n  followRedirect: false,\n});\n\nconst baseUrl = 'http://localhost:3000';\n\nconst defaultConfig = {\n  secret: '__test_session_secret__',\n  clientID: '__test_client_id__',\n  baseURL: 'http://example.org',\n  issuerBaseURL: 'https://op.example.com',\n};\n\nconst login = async (claims) => {\n  const jar = request.jar();\n  await request.post('/session', {\n    baseUrl,\n    jar,\n    json: {\n      id_token: makeIdToken(claims),\n    },\n  });\n  return jar;\n};\n\ndescribe('requiresAuth', () => {\n  let server;\n\n  afterEach(async () => {\n    if (server) {\n      server.close();\n    }\n  });\n\n  it('should allow logged in users to visit a protected route', async () => {\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n      }),\n      requiresAuth()\n    );\n    const jar = await login();\n    const response = await request({ baseUrl, jar, url: '/protected' });\n\n    assert.equal(response.statusCode, 200);\n  });\n\n  it('should ask anonymous user to login when visiting a protected route', async () => {\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n      }),\n      requiresAuth()\n    );\n    const response = await request({ baseUrl, url: '/protected' });\n    const state = new URL(response.headers.location).searchParams.get('state');\n    const decoded = Buffer.from(state, 'base64');\n    const parsed = JSON.parse(decoded);\n\n    assert.equal(response.statusCode, 302);\n    assert.include(response.headers.location, 'https://op.example.com');\n    assert.equal(parsed.returnTo, '/protected');\n  });\n\n  it(\"should 401 for anonymous users who don't accept html\", async () => {\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n      }),\n      requiresAuth()\n    );\n    const response = await request({ baseUrl, url: '/protected', json: true });\n    assert.equal(response.statusCode, 401);\n  });\n\n  it('should return 401 when anonymous user visits a protected route', async () => {\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n        errorOnRequiredAuth: true,\n      }),\n      requiresAuth()\n    );\n    const response = await request({ baseUrl, url: '/protected' });\n\n    assert.equal(response.statusCode, 401);\n  });\n\n  it(\"should throw when there's no auth middleware\", async () => {\n    server = await createServer(null, requiresAuth());\n    const {\n      body: { err },\n    } = await request({ baseUrl, url: '/protected', json: true });\n    assert.equal(\n      err.message,\n      'req.oidc is not found, did you include the auth middleware?'\n    );\n  });\n\n  it('should allow logged in users with the right claim', async () => {\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n        errorOnRequiredAuth: true,\n      }),\n      claimEquals('foo', 'bar')\n    );\n    const jar = await login({ foo: 'bar' });\n    const response = await request({ baseUrl, jar, url: '/protected' });\n\n    assert.equal(response.statusCode, 200);\n  });\n\n  it(\"should return 401 when logged in user doesn't have the right value for claim\", async () => {\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n        errorOnRequiredAuth: true,\n      }),\n      claimEquals('foo', 'bar')\n    );\n    const jar = await login({ foo: 'baz' });\n    const response = await request({ baseUrl, jar, url: '/protected' });\n\n    assert.equal(response.statusCode, 401);\n  });\n\n  it(\"should return 401 when logged in user doesn't have the claim\", async () => {\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n        errorOnRequiredAuth: true,\n      }),\n      claimEquals('baz', 'bar')\n    );\n    const jar = await login({ foo: 'bar' });\n    const response = await request({ baseUrl, jar, url: '/protected' });\n\n    assert.equal(response.statusCode, 401);\n  });\n\n  it(\"should return 401 when anonymous user doesn't have the right claim\", async () => {\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n        errorOnRequiredAuth: true,\n      }),\n      claimEquals('foo', 'bar')\n    );\n    const response = await request({ baseUrl, url: '/protected' });\n\n    assert.equal(response.statusCode, 401);\n  });\n\n  it('should throw when claim is not a string', () => {\n    assert.throws(\n      () => claimEquals(true, 'bar'),\n      TypeError,\n      '\"claim\" must be a string'\n    );\n  });\n\n  it('should throw when claim value is a non primitive', () => {\n    assert.throws(\n      () => claimEquals('foo', { bar: 1 }),\n      TypeError,\n      '\"expected\" must be a string, number, boolean or null'\n    );\n  });\n\n  it('should allow logged in users with all of the requested claims', async () => {\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n        errorOnRequiredAuth: true,\n      }),\n      claimIncludes('foo', 'bar', 'baz')\n    );\n    const jar = await login({ foo: ['baz', 'bar'] });\n    const response = await request({ baseUrl, jar, url: '/protected' });\n\n    assert.equal(response.statusCode, 200);\n  });\n\n  it('should return 401 for logged with some of the requested claims', async () => {\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n        errorOnRequiredAuth: true,\n      }),\n      claimIncludes('foo', 'bar', 'baz', 'qux')\n    );\n    const jar = await login({ foo: 'baz bar' });\n    const response = await request({ baseUrl, jar, url: '/protected' });\n\n    assert.equal(response.statusCode, 401);\n  });\n\n  it('should accept claim values as a space separated list', async () => {\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n        errorOnRequiredAuth: true,\n      }),\n      claimIncludes('foo', 'bar', 'baz')\n    );\n    const jar = await login({ foo: 'baz bar' });\n    const response = await request({ baseUrl, jar, url: '/protected' });\n\n    assert.equal(response.statusCode, 200);\n  });\n\n  it(\"should not accept claim values that aren't a string or array\", async () => {\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n        errorOnRequiredAuth: true,\n      }),\n      claimIncludes('foo', 'bar', 'baz')\n    );\n    const jar = await login({ foo: { bar: 'baz' } });\n    const response = await request({ baseUrl, jar, url: '/protected' });\n\n    assert.equal(response.statusCode, 401);\n  });\n\n  it('should throw when claim value for checking many claims is a non primitive', () => {\n    assert.throws(\n      () => claimIncludes(false, 'bar'),\n      TypeError,\n      '\"claim\" must be a string'\n    );\n  });\n\n  it(\"should return 401 when checking multiple claims and the user doesn't have the claim\", async () => {\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n        errorOnRequiredAuth: true,\n      }),\n      claimIncludes('foo', 'bar', 'baz')\n    );\n    const jar = await login({ bar: 'bar baz' });\n    const response = await request({ baseUrl, jar, url: '/protected' });\n\n    assert.equal(response.statusCode, 401);\n  });\n\n  it('should return 401 when checking many claims with anonymous user', async () => {\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n        errorOnRequiredAuth: true,\n      }),\n      claimIncludes('foo', 'bar', 'baz')\n    );\n    const response = await request({ baseUrl, url: '/protected' });\n\n    assert.equal(response.statusCode, 401);\n  });\n\n  it(\"should throw when custom claim check doesn't get a function\", async () => {\n    assert.throws(\n      () => claimCheck(null),\n      TypeError,\n      '\"claimCheck\" expects a function'\n    );\n  });\n\n  it('should allow user when custom claim check returns truthy', async () => {\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n        errorOnRequiredAuth: true,\n      }),\n      claimCheck(() => true)\n    );\n    const jar = await login();\n    const response = await request({ baseUrl, jar, url: '/protected' });\n\n    assert.equal(response.statusCode, 200);\n  });\n\n  it('should not allow user when custom claim check returns falsey', async () => {\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n        errorOnRequiredAuth: true,\n      }),\n      claimCheck(() => false)\n    );\n    const jar = await login();\n    const response = await request({ baseUrl, jar, url: '/protected' });\n\n    assert.equal(response.statusCode, 401);\n  });\n\n  it('should make the token claims available to custom check', async () => {\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n        errorOnRequiredAuth: true,\n      }),\n      claimCheck((req, claims) => claims.foo === 'some_claim')\n    );\n    const jar = await login({ foo: 'some_claim' });\n    const response = await request({ baseUrl, jar, url: '/protected' });\n\n    assert.equal(response.statusCode, 200);\n  });\n\n  it('should not allow anonymous users to check custom claims', async () => {\n    const checkSpy = sinon.spy();\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n        errorOnRequiredAuth: true,\n      }),\n      claimCheck(checkSpy)\n    );\n    const response = await request({ baseUrl, url: '/protected' });\n\n    assert.equal(response.statusCode, 401);\n    sinon.assert.notCalled(checkSpy);\n  });\n});\n"], "fixing_code": ["const cb = require('cb');\nconst url = require('url');\nconst urlJoin = require('url-join');\nconst { TokenSet } = require('openid-client');\nconst clone = require('clone');\nconst { strict: assert } = require('assert');\n\nconst debug = require('./debug')('context');\nconst { get: getClient } = require('./client');\nconst { encodeState } = require('../lib/hooks/getLoginState');\nconst { cancelSilentLogin } = require('../middleware/attemptSilentLogin');\nconst weakRef = require('./weakCache');\n\nfunction isExpired() {\n  return tokenSet.call(this).expired();\n}\n\nasync function refresh({ tokenEndpointParams } = {}) {\n  let { config, req } = weakRef(this);\n  const client = await getClient(config);\n  const oldTokenSet = tokenSet.call(this);\n\n  let extras;\n  if (config.tokenEndpointParams || tokenEndpointParams) {\n    extras = {\n      exchangeBody: { ...config.tokenEndpointParams, ...tokenEndpointParams },\n    };\n  }\n\n  const newTokenSet = await client.refresh(oldTokenSet, extras);\n\n  // Update the session\n  const session = req[config.session.name];\n  Object.assign(session, {\n    id_token: newTokenSet.id_token,\n    access_token: newTokenSet.access_token,\n    // If no new refresh token assume the current refresh token is valid.\n    refresh_token: newTokenSet.refresh_token || oldTokenSet.refresh_token,\n    token_type: newTokenSet.token_type,\n    expires_at: newTokenSet.expires_at,\n  });\n\n  // Delete the old token set\n  const cachedTokenSet = weakRef(session);\n  delete cachedTokenSet.value;\n\n  return this.accessToken;\n}\n\nfunction tokenSet() {\n  const contextCache = weakRef(this);\n  const session = contextCache.req[contextCache.config.session.name];\n\n  if (!session || !('id_token' in session)) {\n    return undefined;\n  }\n\n  const cachedTokenSet = weakRef(session);\n\n  if (!('value' in cachedTokenSet)) {\n    const {\n      id_token,\n      access_token,\n      refresh_token,\n      token_type,\n      expires_at,\n    } = session;\n    cachedTokenSet.value = new TokenSet({\n      id_token,\n      access_token,\n      refresh_token,\n      token_type,\n      expires_at,\n    });\n  }\n\n  return cachedTokenSet.value;\n}\n\nclass RequestContext {\n  constructor(config, req, res, next) {\n    Object.assign(weakRef(this), { config, req, res, next });\n  }\n\n  isAuthenticated() {\n    return !!this.idTokenClaims;\n  }\n\n  get idToken() {\n    try {\n      return tokenSet.call(this).id_token;\n    } catch (err) {\n      return undefined;\n    }\n  }\n\n  get refreshToken() {\n    try {\n      return tokenSet.call(this).refresh_token;\n    } catch (err) {\n      return undefined;\n    }\n  }\n\n  get accessToken() {\n    try {\n      const { access_token, token_type, expires_in } = tokenSet.call(this);\n\n      if (!access_token || !token_type || typeof expires_in !== 'number') {\n        return undefined;\n      }\n\n      return {\n        access_token,\n        token_type,\n        expires_in,\n        isExpired: isExpired.bind(this),\n        refresh: refresh.bind(this),\n      };\n    } catch (err) {\n      return undefined;\n    }\n  }\n\n  get idTokenClaims() {\n    try {\n      return clone(tokenSet.call(this).claims());\n    } catch (err) {\n      return undefined;\n    }\n  }\n\n  get user() {\n    try {\n      const {\n        config: { identityClaimFilter },\n      } = weakRef(this);\n      const { idTokenClaims } = this;\n      const user = clone(idTokenClaims);\n      identityClaimFilter.forEach((claim) => {\n        delete user[claim];\n      });\n      return user;\n    } catch (err) {\n      return undefined;\n    }\n  }\n\n  async fetchUserInfo() {\n    const { config } = weakRef(this);\n\n    const client = await getClient(config);\n    return client.userinfo(tokenSet.call(this));\n  }\n}\n\nclass ResponseContext {\n  constructor(config, req, res, next, transient) {\n    Object.assign(weakRef(this), { config, req, res, next, transient });\n  }\n\n  get errorOnRequiredAuth() {\n    return weakRef(this).config.errorOnRequiredAuth;\n  }\n\n  getRedirectUri() {\n    const { config } = weakRef(this);\n    return urlJoin(config.baseURL, config.routes.callback);\n  }\n\n  silentLogin(options = {}) {\n    return this.login({\n      ...options,\n      silent: true,\n      authorizationParams: { ...options.authorizationParams, prompt: 'none' },\n    });\n  }\n\n  async login(options = {}) {\n    let { config, req, res, next, transient } = weakRef(this);\n    next = cb(next).once();\n    const client = await getClient(config);\n\n    // Set default returnTo value, allow passed-in options to override or use originalUrl on GET\n    let returnTo = config.baseURL;\n    if (options.returnTo) {\n      returnTo = options.returnTo;\n      debug('req.oidc.login() called with returnTo: %s', returnTo);\n    } else if (req.method === 'GET' && req.originalUrl) {\n      // Collapse any leading slashes to a single slash to prevent Open Redirects\n      returnTo = req.originalUrl.replace(/^\\/+/, '/');\n      debug('req.oidc.login() without returnTo, using: %s', returnTo);\n    }\n\n    options = {\n      authorizationParams: {},\n      returnTo,\n      ...options,\n    };\n\n    // Ensure a redirect_uri, merge in configuration options, then passed-in options.\n    options.authorizationParams = {\n      redirect_uri: this.getRedirectUri(),\n      ...config.authorizationParams,\n      ...options.authorizationParams,\n    };\n\n    const stateValue = await config.getLoginState(req, options);\n    if (typeof stateValue !== 'object') {\n      next(new Error('Custom state value must be an object.'));\n    }\n    stateValue.nonce = transient.generateNonce();\n    if (options.silent) {\n      stateValue.attemptingSilentLogin = true;\n    }\n\n    const usePKCE = options.authorizationParams.response_type.includes('code');\n    if (usePKCE) {\n      debug(\n        'response_type includes code, the authorization request will use PKCE'\n      );\n      stateValue.code_verifier = transient.generateCodeVerifier();\n    }\n\n    try {\n      const validResponseTypes = ['id_token', 'code id_token', 'code'];\n      assert(\n        validResponseTypes.includes(options.authorizationParams.response_type),\n        `response_type should be one of ${validResponseTypes.join(', ')}`\n      );\n      assert(\n        /\\bopenid\\b/.test(options.authorizationParams.scope),\n        'scope should contain \"openid\"'\n      );\n\n      const authVerification = {\n        nonce: transient.generateNonce(),\n        state: encodeState(stateValue),\n        ...(options.authorizationParams.max_age\n          ? {\n              max_age: options.authorizationParams.max_age,\n            }\n          : undefined),\n      };\n      const authParams = {\n        ...options.authorizationParams,\n        ...authVerification,\n      };\n\n      if (usePKCE) {\n        authVerification.code_verifier = transient.generateNonce();\n\n        authParams.code_challenge_method = 'S256';\n        authParams.code_challenge = transient.calculateCodeChallenge(\n          authVerification.code_verifier\n        );\n      }\n\n      transient.store('auth_verification', req, res, {\n        sameSite:\n          options.authorizationParams.response_mode === 'form_post'\n            ? 'None'\n            : config.transactionCookie.sameSite,\n        value: JSON.stringify(authVerification),\n      });\n\n      const authorizationUrl = client.authorizationUrl(authParams);\n      debug('redirecting to %s', authorizationUrl);\n      res.redirect(authorizationUrl);\n    } catch (err) {\n      next(err);\n    }\n  }\n\n  async logout(params = {}) {\n    let { config, req, res, next } = weakRef(this);\n    next = cb(next).once();\n    const client = await getClient(config);\n\n    let returnURL = params.returnTo || config.routes.postLogoutRedirect;\n    debug('req.oidc.logout() with return url: %s', returnURL);\n\n    if (url.parse(returnURL).host === null) {\n      returnURL = urlJoin(config.baseURL, returnURL);\n    }\n\n    cancelSilentLogin(req, res);\n\n    if (!req.oidc.isAuthenticated()) {\n      debug('end-user already logged out, redirecting to %s', returnURL);\n      return res.redirect(returnURL);\n    }\n\n    const { idToken: id_token_hint } = req.oidc;\n    req[config.session.name] = undefined;\n\n    if (!config.idpLogout) {\n      debug('performing a local only logout, redirecting to %s', returnURL);\n      return res.redirect(returnURL);\n    }\n\n    try {\n      returnURL = client.endSessionUrl({\n        ...config.logoutParams,\n        ...params.logoutParams,\n        post_logout_redirect_uri: returnURL,\n        id_token_hint,\n      });\n    } catch (err) {\n      return next(err);\n    }\n\n    debug('logging out of identity provider, redirecting to %s', returnURL);\n    res.redirect(returnURL);\n  }\n}\n\nmodule.exports = { RequestContext, ResponseContext };\n", "const { assert } = require('chai');\nconst sinon = require('sinon');\nconst { create: createServer } = require('./fixture/server');\nconst { makeIdToken } = require('./fixture/cert');\nconst {\n  auth,\n  requiresAuth,\n  claimEquals,\n  claimIncludes,\n  claimCheck,\n} = require('./..');\nconst request = require('request-promise-native').defaults({\n  simple: false,\n  resolveWithFullResponse: true,\n  followRedirect: false,\n});\n\nconst baseUrl = 'http://localhost:3000';\n\nconst defaultConfig = {\n  secret: '__test_session_secret__',\n  clientID: '__test_client_id__',\n  baseURL: 'http://example.org',\n  issuerBaseURL: 'https://op.example.com',\n};\n\nconst login = async (claims) => {\n  const jar = request.jar();\n  await request.post('/session', {\n    baseUrl,\n    jar,\n    json: {\n      id_token: makeIdToken(claims),\n    },\n  });\n  return jar;\n};\n\ndescribe('requiresAuth', () => {\n  let server;\n\n  afterEach(async () => {\n    if (server) {\n      server.close();\n    }\n  });\n\n  it('should allow logged in users to visit a protected route', async () => {\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n      }),\n      requiresAuth()\n    );\n    const jar = await login();\n    const response = await request({ baseUrl, jar, url: '/protected' });\n\n    assert.equal(response.statusCode, 200);\n  });\n\n  it('should ask anonymous user to login when visiting a protected route', async () => {\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n      }),\n      requiresAuth()\n    );\n    const response = await request({ baseUrl, url: '/protected' });\n    const state = new URL(response.headers.location).searchParams.get('state');\n    const decoded = Buffer.from(state, 'base64');\n    const parsed = JSON.parse(decoded);\n\n    assert.equal(response.statusCode, 302);\n    assert.include(response.headers.location, 'https://op.example.com');\n    assert.equal(parsed.returnTo, '/protected');\n  });\n\n  it(\"should 401 for anonymous users who don't accept html\", async () => {\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n      }),\n      requiresAuth()\n    );\n    const response = await request({ baseUrl, url: '/protected', json: true });\n    assert.equal(response.statusCode, 401);\n  });\n\n  it('should return 401 when anonymous user visits a protected route', async () => {\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n        errorOnRequiredAuth: true,\n      }),\n      requiresAuth()\n    );\n    const response = await request({ baseUrl, url: '/protected' });\n\n    assert.equal(response.statusCode, 401);\n  });\n\n  it(\"should throw when there's no auth middleware\", async () => {\n    server = await createServer(null, requiresAuth());\n    const {\n      body: { err },\n    } = await request({ baseUrl, url: '/protected', json: true });\n    assert.equal(\n      err.message,\n      'req.oidc is not found, did you include the auth middleware?'\n    );\n  });\n\n  it('should allow logged in users with the right claim', async () => {\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n        errorOnRequiredAuth: true,\n      }),\n      claimEquals('foo', 'bar')\n    );\n    const jar = await login({ foo: 'bar' });\n    const response = await request({ baseUrl, jar, url: '/protected' });\n\n    assert.equal(response.statusCode, 200);\n  });\n\n  it(\"should return 401 when logged in user doesn't have the right value for claim\", async () => {\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n        errorOnRequiredAuth: true,\n      }),\n      claimEquals('foo', 'bar')\n    );\n    const jar = await login({ foo: 'baz' });\n    const response = await request({ baseUrl, jar, url: '/protected' });\n\n    assert.equal(response.statusCode, 401);\n  });\n\n  it(\"should return 401 when logged in user doesn't have the claim\", async () => {\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n        errorOnRequiredAuth: true,\n      }),\n      claimEquals('baz', 'bar')\n    );\n    const jar = await login({ foo: 'bar' });\n    const response = await request({ baseUrl, jar, url: '/protected' });\n\n    assert.equal(response.statusCode, 401);\n  });\n\n  it(\"should return 401 when anonymous user doesn't have the right claim\", async () => {\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n        errorOnRequiredAuth: true,\n      }),\n      claimEquals('foo', 'bar')\n    );\n    const response = await request({ baseUrl, url: '/protected' });\n\n    assert.equal(response.statusCode, 401);\n  });\n\n  it('should throw when claim is not a string', () => {\n    assert.throws(\n      () => claimEquals(true, 'bar'),\n      TypeError,\n      '\"claim\" must be a string'\n    );\n  });\n\n  it('should throw when claim value is a non primitive', () => {\n    assert.throws(\n      () => claimEquals('foo', { bar: 1 }),\n      TypeError,\n      '\"expected\" must be a string, number, boolean or null'\n    );\n  });\n\n  it('should allow logged in users with all of the requested claims', async () => {\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n        errorOnRequiredAuth: true,\n      }),\n      claimIncludes('foo', 'bar', 'baz')\n    );\n    const jar = await login({ foo: ['baz', 'bar'] });\n    const response = await request({ baseUrl, jar, url: '/protected' });\n\n    assert.equal(response.statusCode, 200);\n  });\n\n  it('should return 401 for logged with some of the requested claims', async () => {\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n        errorOnRequiredAuth: true,\n      }),\n      claimIncludes('foo', 'bar', 'baz', 'qux')\n    );\n    const jar = await login({ foo: 'baz bar' });\n    const response = await request({ baseUrl, jar, url: '/protected' });\n\n    assert.equal(response.statusCode, 401);\n  });\n\n  it('should accept claim values as a space separated list', async () => {\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n        errorOnRequiredAuth: true,\n      }),\n      claimIncludes('foo', 'bar', 'baz')\n    );\n    const jar = await login({ foo: 'baz bar' });\n    const response = await request({ baseUrl, jar, url: '/protected' });\n\n    assert.equal(response.statusCode, 200);\n  });\n\n  it(\"should not accept claim values that aren't a string or array\", async () => {\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n        errorOnRequiredAuth: true,\n      }),\n      claimIncludes('foo', 'bar', 'baz')\n    );\n    const jar = await login({ foo: { bar: 'baz' } });\n    const response = await request({ baseUrl, jar, url: '/protected' });\n\n    assert.equal(response.statusCode, 401);\n  });\n\n  it('should throw when claim value for checking many claims is a non primitive', () => {\n    assert.throws(\n      () => claimIncludes(false, 'bar'),\n      TypeError,\n      '\"claim\" must be a string'\n    );\n  });\n\n  it(\"should return 401 when checking multiple claims and the user doesn't have the claim\", async () => {\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n        errorOnRequiredAuth: true,\n      }),\n      claimIncludes('foo', 'bar', 'baz')\n    );\n    const jar = await login({ bar: 'bar baz' });\n    const response = await request({ baseUrl, jar, url: '/protected' });\n\n    assert.equal(response.statusCode, 401);\n  });\n\n  it('should return 401 when checking many claims with anonymous user', async () => {\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n        errorOnRequiredAuth: true,\n      }),\n      claimIncludes('foo', 'bar', 'baz')\n    );\n    const response = await request({ baseUrl, url: '/protected' });\n\n    assert.equal(response.statusCode, 401);\n  });\n\n  it(\"should throw when custom claim check doesn't get a function\", async () => {\n    assert.throws(\n      () => claimCheck(null),\n      TypeError,\n      '\"claimCheck\" expects a function'\n    );\n  });\n\n  it('should allow user when custom claim check returns truthy', async () => {\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n        errorOnRequiredAuth: true,\n      }),\n      claimCheck(() => true)\n    );\n    const jar = await login();\n    const response = await request({ baseUrl, jar, url: '/protected' });\n\n    assert.equal(response.statusCode, 200);\n  });\n\n  it('should not allow user when custom claim check returns falsey', async () => {\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n        errorOnRequiredAuth: true,\n      }),\n      claimCheck(() => false)\n    );\n    const jar = await login();\n    const response = await request({ baseUrl, jar, url: '/protected' });\n\n    assert.equal(response.statusCode, 401);\n  });\n\n  it('should make the token claims available to custom check', async () => {\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n        errorOnRequiredAuth: true,\n      }),\n      claimCheck((req, claims) => claims.foo === 'some_claim')\n    );\n    const jar = await login({ foo: 'some_claim' });\n    const response = await request({ baseUrl, jar, url: '/protected' });\n\n    assert.equal(response.statusCode, 200);\n  });\n\n  it('should not allow anonymous users to check custom claims', async () => {\n    const checkSpy = sinon.spy();\n    server = await createServer(\n      auth({\n        ...defaultConfig,\n        authRequired: false,\n        errorOnRequiredAuth: true,\n      }),\n      claimCheck(checkSpy)\n    );\n    const response = await request({ baseUrl, url: '/protected' });\n\n    assert.equal(response.statusCode, 401);\n    sinon.assert.notCalled(checkSpy);\n  });\n\n  it('should collapse leading slashes on returnTo', async () => {\n    server = await createServer(auth(defaultConfig));\n    const payloads = ['//google.com', '///google.com', '//google.com'];\n    for (const payload of payloads) {\n      const response = await request({ url: `${baseUrl}${payload}` });\n      const state = new URL(response.headers.location).searchParams.get(\n        'state'\n      );\n      const decoded = Buffer.from(state, 'base64');\n      const parsed = JSON.parse(decoded);\n\n      assert.equal(response.statusCode, 302);\n      assert.include(response.headers.location, 'https://op.example.com');\n      assert.equal(parsed.returnTo, '/google.com');\n    }\n  });\n});\n"], "filenames": ["lib/context.js", "test/requiresAuth.tests.js"], "buggy_code_start_loc": [190, 356], "buggy_code_end_loc": [191, 356], "fixing_code_start_loc": [190, 357], "fixing_code_end_loc": [192, 374], "type": "CWE-601", "message": "Express OpenID Connect is an Express JS middleware implementing sign on for Express web apps using OpenID Connect. Users of the `requiresAuth` middleware, either directly or through the default `authRequired` option, are vulnerable to an Open Redirect when the middleware is applied to a catch all route. If all routes under `example.com` are protected with the `requiresAuth` middleware, a visit to `http://example.com//google.com` will be redirected to `google.com` after login because the original url reported by the Express framework is not properly sanitized. This vulnerability affects versions prior to 2.7.2. Users are advised to upgrade. There are no known workarounds.", "other": {"cve": {"id": "CVE-2022-24794", "sourceIdentifier": "security-advisories@github.com", "published": "2022-03-31T23:15:08.127", "lastModified": "2022-04-08T16:37:53.533", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Express OpenID Connect is an Express JS middleware implementing sign on for Express web apps using OpenID Connect. Users of the `requiresAuth` middleware, either directly or through the default `authRequired` option, are vulnerable to an Open Redirect when the middleware is applied to a catch all route. If all routes under `example.com` are protected with the `requiresAuth` middleware, a visit to `http://example.com//google.com` will be redirected to `google.com` after login because the original url reported by the Express framework is not properly sanitized. This vulnerability affects versions prior to 2.7.2. Users are advised to upgrade. There are no known workarounds."}, {"lang": "es", "value": "Express OpenID Connect es un middleware de Express JS que implementa el inicio de sesi\u00f3n para las aplicaciones web de Express usando OpenID Connect. Los usuarios del middleware \"requiresAuth\", ya sea directamente o mediante la opci\u00f3n por defecto \"authRequired\", son vulnerables a un Redireccionamiento Abierto cuando el middleware es aplicado a una ruta catch all. Si todas las rutas bajo \"example.com\" est\u00e1n protegidas con el middleware \"requiresAuth\", una visita a \"http://example.com//google.com\" ser\u00e1 redirigida a \"google.com\" despu\u00e9s del inicio de sesi\u00f3n porque la url original reportada por el framework Express no est\u00e1 correctamente saneada. Esta vulnerabilidad afecta a versiones anteriores a 2.7.2. Es recomendado a usuarios actualizar. No se presentan medidas de mitigaci\u00f3n conocidas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-601"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:auth0:express_openid_connect:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "2.7.2", "matchCriteriaId": "EC2BC02B-3BF5-49E3-AB1D-460B94CB12DE"}]}]}], "references": [{"url": "https://github.com/auth0/express-openid-connect/commit/0947b92164a2c5f661ebcc183d37e7f21de719ad", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/auth0/express-openid-connect/security/advisories/GHSA-7p99-3798-f85c", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/auth0/express-openid-connect/commit/0947b92164a2c5f661ebcc183d37e7f21de719ad"}}