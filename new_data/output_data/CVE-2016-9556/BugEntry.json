{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            SSSSS   GGGG  IIIII                              %\n%                            SS     G        I                                %\n%                             SSS   G  GG    I                                %\n%                               SS  G   G    I                                %\n%                            SSSSS   GGG   IIIII                              %\n%                                                                             %\n%                                                                             %\n%                      Read/Write Irix RGB Image Format                       %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n\f\n/*\n  Typedef declaractions.\n*/\ntypedef struct _SGIInfo\n{\n  unsigned short\n    magic;\n\n  unsigned char\n    storage,\n    bytes_per_pixel;\n\n  unsigned short\n    dimension,\n    columns,\n    rows,\n    depth;\n\n  size_t\n    minimum_value,\n    maximum_value,\n    sans;\n\n  char\n    name[80];\n\n  size_t\n    pixel_format;\n\n  unsigned char\n    filler[404];\n} SGIInfo;\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteSGIImage(const ImageInfo *,Image *,ExceptionInfo *);\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s S G I                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsSGI() returns MagickTrue if the image format type, identified by the\n%  magick string, is SGI.\n%\n%  The format of the IsSGI method is:\n%\n%      MagickBooleanType IsSGI(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsSGI(const unsigned char *magick,const size_t length)\n{\n  if (length < 2)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\001\\332\",2) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d S G I I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadSGIImage() reads a SGI RGB image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadSGIImage method is:\n%\n%      Image *ReadSGIImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic MagickBooleanType SGIDecode(const size_t bytes_per_pixel,\n  ssize_t number_packets,unsigned char *packets,ssize_t number_pixels,\n  unsigned char *pixels)\n{\n  register unsigned char\n    *p,\n    *q;\n\n  size_t\n    pixel;\n\n  ssize_t\n    count;\n\n  p=packets;\n  q=pixels;\n  if (bytes_per_pixel == 2)\n    {\n      for ( ; number_pixels > 0; )\n      {\n        if (number_packets-- == 0)\n          return(MagickFalse);\n        pixel=(size_t) (*p++) << 8;\n        pixel|=(*p++);\n        count=(ssize_t) (pixel & 0x7f);\n        if (count == 0)\n          break;\n        if (count > (ssize_t) number_pixels)\n          return(MagickFalse);\n        number_pixels-=count;\n        if ((pixel & 0x80) != 0)\n          for ( ; count != 0; count--)\n          {\n            if (number_packets-- == 0)\n              return(MagickFalse);\n            *q=(*p++);\n            *(q+1)=(*p++);\n            q+=8;\n          }\n        else\n          {\n            if (number_packets-- == 0)\n              return(MagickFalse);\n            pixel=(size_t) (*p++) << 8;\n            pixel|=(*p++);\n            for ( ; count != 0; count--)\n            {\n              *q=(unsigned char) (pixel >> 8);\n              *(q+1)=(unsigned char) pixel;\n              q+=8;\n            }\n          }\n      }\n      return(MagickTrue);\n    }\n  for ( ; number_pixels > 0; )\n  {\n    if (number_packets-- == 0)\n      return(MagickFalse);\n    pixel=(size_t) (*p++);\n    count=(ssize_t) (pixel & 0x7f);\n    if (count == 0)\n      break;\n    if (count > (ssize_t) number_pixels)\n      return(MagickFalse);\n    number_pixels-=count;\n    if ((pixel & 0x80) != 0)\n      for ( ; count != 0; count--)\n      {\n        if (number_packets-- == 0)\n          return(MagickFalse);\n        *q=(*p++);\n        q+=4;\n      }\n    else\n      {\n        if (number_packets-- == 0)\n          return(MagickFalse);\n        pixel=(size_t) (*p++);\n        for ( ; count != 0; count--)\n        {\n          *q=(unsigned char) pixel;\n          q+=4;\n        }\n      }\n  }\n  return(MagickTrue);\n}\n\nstatic Image *ReadSGIImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *pixel_info;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  SGIInfo\n    iris_info;\n\n  size_t\n    bytes_per_pixel,\n    quantum;\n\n  ssize_t\n    count,\n    y,\n    z;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read SGI raster header.\n  */\n  iris_info.magic=ReadBlobMSBShort(image);\n  do\n  {\n    /*\n      Verify SGI identifier.\n    */\n    if (iris_info.magic != 0x01DA)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.storage=(unsigned char) ReadBlobByte(image);\n    switch (iris_info.storage)\n    {\n      case 0x00: image->compression=NoCompression; break;\n      case 0x01: image->compression=RLECompression; break;\n      default:\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n    iris_info.bytes_per_pixel=(unsigned char) ReadBlobByte(image);\n    if ((iris_info.bytes_per_pixel == 0) || (iris_info.bytes_per_pixel > 2))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.dimension=ReadBlobMSBShort(image);\n    iris_info.columns=ReadBlobMSBShort(image);\n    iris_info.rows=ReadBlobMSBShort(image);\n    iris_info.depth=ReadBlobMSBShort(image);\n    if ((iris_info.depth == 0) || (iris_info.depth > 4))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.minimum_value=ReadBlobMSBLong(image);\n    iris_info.maximum_value=ReadBlobMSBLong(image);\n    iris_info.sans=ReadBlobMSBLong(image);\n    count=ReadBlob(image,sizeof(iris_info.name),(unsigned char *)\n      iris_info.name);\n    if ((size_t) count != sizeof(iris_info.name))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.name[sizeof(iris_info.name)-1]='\\0';\n    if (*iris_info.name != '\\0')\n      (void) SetImageProperty(image,\"label\",iris_info.name,exception);\n    iris_info.pixel_format=ReadBlobMSBLong(image);\n    if (iris_info.pixel_format != 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    count=ReadBlob(image,sizeof(iris_info.filler),iris_info.filler);\n    if ((size_t) count != sizeof(iris_info.filler))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    image->columns=iris_info.columns;\n    image->rows=iris_info.rows;\n    image->depth=(size_t) MagickMin(iris_info.depth,MAGICKCORE_QUANTUM_DEPTH);\n    if (iris_info.pixel_format == 0)\n      image->depth=(size_t) MagickMin((size_t) 8*iris_info.bytes_per_pixel,\n        MAGICKCORE_QUANTUM_DEPTH);\n    if (iris_info.depth < 3)\n      {\n        image->storage_class=PseudoClass;\n        image->colors=(size_t) (iris_info.bytes_per_pixel > 1 ? 65535 : 256);\n      }\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    /*\n      Allocate SGI pixels.\n    */\n    bytes_per_pixel=(size_t) iris_info.bytes_per_pixel;\n    number_pixels=(MagickSizeType) iris_info.columns*iris_info.rows;\n    if ((4*bytes_per_pixel*number_pixels) != ((MagickSizeType) (size_t)\n        (4*bytes_per_pixel*number_pixels)))\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixel_info=AcquireVirtualMemory(iris_info.columns,iris_info.rows*4*\n      bytes_per_pixel*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    if ((int) iris_info.storage != 0x01)\n      {\n        unsigned char\n          *scanline;\n\n        /*\n          Read standard image format.\n        */\n        scanline=(unsigned char *) AcquireQuantumMemory(iris_info.columns,\n          bytes_per_pixel*sizeof(*scanline));\n        if (scanline == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        for (z=0; z < (ssize_t) iris_info.depth; z++)\n        {\n          p=pixels+bytes_per_pixel*z;\n          for (y=0; y < (ssize_t) iris_info.rows; y++)\n          {\n            count=ReadBlob(image,bytes_per_pixel*iris_info.columns,scanline);\n            if (EOFBlob(image) != MagickFalse)\n              break;\n            if (bytes_per_pixel == 2)\n              for (x=0; x < (ssize_t) iris_info.columns; x++)\n              {\n                *p=scanline[2*x];\n                *(p+1)=scanline[2*x+1];\n                p+=8;\n              }\n            else\n              for (x=0; x < (ssize_t) iris_info.columns; x++)\n              {\n                *p=scanline[x];\n                p+=4;\n              }\n          }\n        }\n        scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n      }\n    else\n      {\n        MemoryInfo\n          *packet_info;\n\n        size_t\n          *runlength;\n\n        ssize_t\n          offset,\n          *offsets;\n\n        unsigned char\n          *packets;\n\n        unsigned int\n          data_order;\n\n        /*\n          Read runlength-encoded image format.\n        */\n        offsets=(ssize_t *) AcquireQuantumMemory((size_t) iris_info.rows,\n          iris_info.depth*sizeof(*offsets));\n        runlength=(size_t *) AcquireQuantumMemory(iris_info.rows,\n          iris_info.depth*sizeof(*runlength));\n        packet_info=AcquireVirtualMemory((size_t) iris_info.columns+10UL,4UL*\n          sizeof(*packets));\n        if ((offsets == (ssize_t *) NULL) ||\n            (runlength == (size_t *) NULL) ||\n            (packet_info == (MemoryInfo *) NULL))\n          {\n            if (offsets == (ssize_t *) NULL)\n              offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n            if (runlength == (size_t *) NULL)\n              runlength=(size_t *) RelinquishMagickMemory(runlength);\n            if (packet_info == (MemoryInfo *) NULL)\n              packet_info=RelinquishVirtualMemory(packet_info);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        packets=(unsigned char *) GetVirtualMemoryBlob(packet_info);\n        for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)\n          offsets[i]=(ssize_t) ReadBlobMSBSignedLong(image);\n        for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)\n        {\n          runlength[i]=ReadBlobMSBLong(image);\n          if (runlength[i] > (4*(size_t) iris_info.columns+10))\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n        /*\n          Check data order.\n        */\n        offset=0;\n        data_order=0;\n        for (y=0; ((y < (ssize_t) iris_info.rows) && (data_order == 0)); y++)\n          for (z=0; ((z < (ssize_t) iris_info.depth) && (data_order == 0)); z++)\n          {\n            if (offsets[y+z*iris_info.rows] < offset)\n              data_order=1;\n            offset=offsets[y+z*iris_info.rows];\n          }\n        offset=(ssize_t) TellBlob(image);\n        if (data_order == 1)\n          {\n            for (z=0; z < (ssize_t) iris_info.depth; z++)\n            {\n              p=pixels;\n              for (y=0; y < (ssize_t) iris_info.rows; y++)\n              {\n                if (offset != offsets[y+z*iris_info.rows])\n                  {\n                    offset=offsets[y+z*iris_info.rows];\n                    offset=(ssize_t) SeekBlob(image,(MagickOffsetType) offset,\n                      SEEK_SET);\n                  }\n                count=ReadBlob(image,(size_t) runlength[y+z*iris_info.rows],\n                  packets);\n                if (EOFBlob(image) != MagickFalse)\n                  break;\n                offset+=(ssize_t) runlength[y+z*iris_info.rows];\n                status=SGIDecode(bytes_per_pixel,(ssize_t)\n                  (runlength[y+z*iris_info.rows]/bytes_per_pixel),packets,\n                  (ssize_t) iris_info.columns,p+bytes_per_pixel*z);\n                if (status == MagickFalse)\n                  ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n                p+=(iris_info.columns*4*bytes_per_pixel);\n              }\n            }\n          }\n        else\n          {\n            MagickOffsetType\n              position;\n\n            position=TellBlob(image);\n            p=pixels;\n            for (y=0; y < (ssize_t) iris_info.rows; y++)\n            {\n              for (z=0; z < (ssize_t) iris_info.depth; z++)\n              {\n                if (offset != offsets[y+z*iris_info.rows])\n                  {\n                    offset=offsets[y+z*iris_info.rows];\n                    offset=(ssize_t) SeekBlob(image,(MagickOffsetType) offset,\n                      SEEK_SET);\n                  }\n                count=ReadBlob(image,(size_t) runlength[y+z*iris_info.rows],\n                  packets);\n                if (EOFBlob(image) != MagickFalse)\n                  break;\n                offset+=(ssize_t) runlength[y+z*iris_info.rows];\n                status=SGIDecode(bytes_per_pixel,(ssize_t)\n                  (runlength[y+z*iris_info.rows]/bytes_per_pixel),packets,\n                  (ssize_t) iris_info.columns,p+bytes_per_pixel*z);\n                if (status == MagickFalse)\n                  ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              }\n              p+=(iris_info.columns*4*bytes_per_pixel);\n            }\n            offset=(ssize_t) SeekBlob(image,position,SEEK_SET);\n          }\n        packet_info=RelinquishVirtualMemory(packet_info);\n        runlength=(size_t *) RelinquishMagickMemory(runlength);\n        offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n      }\n    /*\n      Initialize image structure.\n    */\n    image->alpha_trait=iris_info.depth == 4 ? BlendPixelTrait :\n      UndefinedPixelTrait;\n    image->columns=iris_info.columns;\n    image->rows=iris_info.rows;\n    /*\n      Convert SGI raster image to pixel packets.\n    */\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Convert SGI image to DirectClass pixel packets.\n        */\n        if (bytes_per_pixel == 2)\n          {\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=pixels+(image->rows-y-1)*8*image->columns;\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelRed(image,ScaleShortToQuantum((unsigned short)\n                  ((*(p+0) << 8) | (*(p+1)))),q);\n                SetPixelGreen(image,ScaleShortToQuantum((unsigned short)\n                  ((*(p+2) << 8) | (*(p+3)))),q);\n                SetPixelBlue(image,ScaleShortToQuantum((unsigned short)\n                  ((*(p+4) << 8) | (*(p+5)))),q);\n                SetPixelAlpha(image,OpaqueAlpha,q);\n                if (image->alpha_trait != UndefinedPixelTrait)\n                  SetPixelAlpha(image,ScaleShortToQuantum((unsigned short)\n                    ((*(p+6) << 8) | (*(p+7)))),q);\n                p+=8;\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=pixels+(image->rows-y-1)*4*image->columns;\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(image,ScaleCharToQuantum(*p),q);\n              SetPixelGreen(image,ScaleCharToQuantum(*(p+1)),q);\n              SetPixelBlue(image,ScaleCharToQuantum(*(p+2)),q);\n              SetPixelAlpha(image,OpaqueAlpha,q);\n              if (image->alpha_trait != UndefinedPixelTrait)\n                SetPixelAlpha(image,ScaleCharToQuantum(*(p+3)),q);\n              p+=4;\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n      }\n    else\n      {\n        /*\n          Create grayscale map.\n        */\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Convert SGI image to PseudoClass pixel packets.\n        */\n        if (bytes_per_pixel == 2)\n          {\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=pixels+(image->rows-y-1)*8*image->columns;\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                quantum=(*p << 8);\n                quantum|=(*(p+1));\n                SetPixelIndex(image,(Quantum) quantum,q);\n                p+=8;\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=pixels+(image->rows-y-1)*4*image->columns;\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelIndex(image,*p,q);\n              p+=4;\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        (void) SyncImage(image,exception);\n      }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    iris_info.magic=ReadBlobMSBShort(image);\n    if (iris_info.magic == 0x01DA)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (iris_info.magic == 0x01DA);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r S G I I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterSGIImage() adds properties for the SGI image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterSGIImage method is:\n%\n%      size_t RegisterSGIImage(void)\n%\n*/\nModuleExport size_t RegisterSGIImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"SGI\",\"SGI\",\"Irix RGB image\");\n  entry->decoder=(DecodeImageHandler *) ReadSGIImage;\n  entry->encoder=(EncodeImageHandler *) WriteSGIImage;\n  entry->magick=(IsImageFormatHandler *) IsSGI;\n  entry->flags|=CoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r S G I I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterSGIImage() removes format registrations made by the\n%  SGI module from the list of supported formats.\n%\n%  The format of the UnregisterSGIImage method is:\n%\n%      UnregisterSGIImage(void)\n%\n*/\nModuleExport void UnregisterSGIImage(void)\n{\n  (void) UnregisterMagickInfo(\"SGI\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e S G I I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteSGIImage() writes an image in SGI RGB encoded image format.\n%\n%  The format of the WriteSGIImage method is:\n%\n%      MagickBooleanType WriteSGIImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic size_t SGIEncode(unsigned char *pixels,size_t length,\n  unsigned char *packets)\n{\n  short\n    runlength;\n\n  register unsigned char\n    *p,\n    *q;\n\n  unsigned char\n    *limit,\n    *mark;\n\n  p=pixels;\n  limit=p+length*4;\n  q=packets;\n  while (p < limit)\n  {\n    mark=p;\n    p+=8;\n    while ((p < limit) && ((*(p-8) != *(p-4)) || (*(p-4) != *p)))\n      p+=4;\n    p-=8;\n    length=(size_t) (p-mark) >> 2;\n    while (length != 0)\n    {\n      runlength=(short) (length > 126 ? 126 : length);\n      length-=runlength;\n      *q++=(unsigned char) (0x80 | runlength);\n      for ( ; runlength > 0; runlength--)\n      {\n        *q++=(*mark);\n        mark+=4;\n      }\n    }\n    mark=p;\n    p+=4;\n    while ((p < limit) && (*p == *mark))\n      p+=4;\n    length=(size_t) (p-mark) >> 2;\n    while (length != 0)\n    {\n      runlength=(short) (length > 126 ? 126 : length);\n      length-=runlength;\n      *q++=(unsigned char) runlength;\n      *q++=(*mark);\n    }\n  }\n  *q++='\\0';\n  return((size_t) (q-packets));\n}\n\nstatic MagickBooleanType WriteSGIImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  CompressionType\n    compression;\n\n  const char\n    *value;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *pixel_info;\n\n  SGIInfo\n    iris_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  ssize_t\n    y,\n    z;\n\n  unsigned char\n    *pixels,\n    *packets;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if ((image->columns > 65535UL) || (image->rows > 65535UL))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  scene=0;\n  do\n  {\n    /*\n      Initialize SGI raster file header.\n    */\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    (void) ResetMagickMemory(&iris_info,0,sizeof(iris_info));\n    iris_info.magic=0x01DA;\n    compression=image->compression;\n    if (image_info->compression != UndefinedCompression)\n      compression=image_info->compression;\n    if (image->depth > 8)\n      compression=NoCompression;\n    if (compression == NoCompression)\n      iris_info.storage=(unsigned char) 0x00;\n    else\n      iris_info.storage=(unsigned char) 0x01;\n    iris_info.bytes_per_pixel=(unsigned char) (image->depth > 8 ? 2 : 1);\n    iris_info.dimension=3;\n    iris_info.columns=(unsigned short) image->columns;\n    iris_info.rows=(unsigned short) image->rows;\n    if (image->alpha_trait != UndefinedPixelTrait)\n      iris_info.depth=4;\n    else\n      {\n        if ((image_info->type != TrueColorType) &&\n            (SetImageGray(image,exception) != MagickFalse))\n          {\n            iris_info.dimension=2;\n            iris_info.depth=1;\n          }\n        else\n          iris_info.depth=3;\n      }\n    iris_info.minimum_value=0;\n    iris_info.maximum_value=(size_t) (image->depth <= 8 ?\n      1UL*ScaleQuantumToChar(QuantumRange) :\n      1UL*ScaleQuantumToShort(QuantumRange));\n    /*\n      Write SGI header.\n    */\n    (void) WriteBlobMSBShort(image,iris_info.magic);\n    (void) WriteBlobByte(image,iris_info.storage);\n    (void) WriteBlobByte(image,iris_info.bytes_per_pixel);\n    (void) WriteBlobMSBShort(image,iris_info.dimension);\n    (void) WriteBlobMSBShort(image,iris_info.columns);\n    (void) WriteBlobMSBShort(image,iris_info.rows);\n    (void) WriteBlobMSBShort(image,iris_info.depth);\n    (void) WriteBlobMSBLong(image,(unsigned int) iris_info.minimum_value);\n    (void) WriteBlobMSBLong(image,(unsigned int) iris_info.maximum_value);\n    (void) WriteBlobMSBLong(image,(unsigned int) iris_info.sans);\n    value=GetImageProperty(image,\"label\",exception);\n    if (value != (const char *) NULL)\n      (void) CopyMagickString(iris_info.name,value,sizeof(iris_info.name));\n    (void) WriteBlob(image,sizeof(iris_info.name),(unsigned char *)\n      iris_info.name);\n    (void) WriteBlobMSBLong(image,(unsigned int) iris_info.pixel_format);\n    (void) WriteBlob(image,sizeof(iris_info.filler),iris_info.filler);\n    /*\n      Allocate SGI pixels.\n    */\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    if ((4*iris_info.bytes_per_pixel*number_pixels) !=\n        ((MagickSizeType) (size_t) (4*iris_info.bytes_per_pixel*number_pixels)))\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixel_info=AcquireVirtualMemory((size_t) number_pixels,4*\n      iris_info.bytes_per_pixel*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    /*\n      Convert image pixels to uncompressed SGI pixels.\n    */\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n      if (p == (const Quantum *) NULL)\n        break;\n      if (image->depth <= 8)\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          register unsigned char\n            *q;\n\n          q=(unsigned char *) pixels;\n          q+=((iris_info.rows-1)-y)*(4*iris_info.columns)+4*x;\n          *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n          *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n          *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n          *q++=ScaleQuantumToChar(GetPixelAlpha(image,p));\n          p+=GetPixelChannels(image);\n        }\n      else\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          register unsigned short\n            *q;\n\n          q=(unsigned short *) pixels;\n          q+=((iris_info.rows-1)-y)*(4*iris_info.columns)+4*x;\n          *q++=ScaleQuantumToShort(GetPixelRed(image,p));\n          *q++=ScaleQuantumToShort(GetPixelGreen(image,p));\n          *q++=ScaleQuantumToShort(GetPixelBlue(image,p));\n          *q++=ScaleQuantumToShort(GetPixelAlpha(image,p));\n          p+=GetPixelChannels(image);\n        }\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    switch (compression)\n    {\n      case NoCompression:\n      {\n        /*\n          Write uncompressed SGI pixels.\n        */\n        for (z=0; z < (ssize_t) iris_info.depth; z++)\n        {\n          for (y=0; y < (ssize_t) iris_info.rows; y++)\n          {\n            if (image->depth <= 8)\n              for (x=0; x < (ssize_t) iris_info.columns; x++)\n              {\n                register unsigned char\n                  *q;\n\n                q=(unsigned char *) pixels;\n                q+=y*(4*iris_info.columns)+4*x+z;\n                (void) WriteBlobByte(image,*q);\n              }\n            else\n              for (x=0; x < (ssize_t) iris_info.columns; x++)\n              {\n                register unsigned short\n                  *q;\n\n                q=(unsigned short *) pixels;\n                q+=y*(4*iris_info.columns)+4*x+z;\n                (void) WriteBlobMSBShort(image,*q);\n              }\n          }\n        }\n        break;\n      }\n      default:\n      {\n        MemoryInfo\n          *packet_info;\n\n        size_t\n          length,\n          number_packets,\n          *runlength;\n\n        ssize_t\n          offset,\n          *offsets;\n\n        /*\n          Convert SGI uncompressed pixels.\n        */\n        offsets=(ssize_t *) AcquireQuantumMemory(iris_info.rows,\n          iris_info.depth*sizeof(*offsets));\n        runlength=(size_t *) AcquireQuantumMemory(iris_info.rows,\n          iris_info.depth*sizeof(*runlength));\n        packet_info=AcquireVirtualMemory((2*(size_t) iris_info.columns+10)*\n          image->rows,4*sizeof(*packets));\n        if ((offsets == (ssize_t *) NULL) ||\n            (runlength == (size_t *) NULL) ||\n            (packet_info == (MemoryInfo *) NULL))\n          {\n            if (offsets != (ssize_t *) NULL)\n              offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n            if (runlength != (size_t *) NULL)\n              runlength=(size_t *) RelinquishMagickMemory(runlength);\n            if (packet_info != (MemoryInfo *) NULL)\n              packet_info=RelinquishVirtualMemory(packet_info);\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        packets=(unsigned char *) GetVirtualMemoryBlob(packet_info);\n        offset=512+4*2*((ssize_t) iris_info.rows*iris_info.depth);\n        number_packets=0;\n        q=pixels;\n        for (y=0; y < (ssize_t) iris_info.rows; y++)\n        {\n          for (z=0; z < (ssize_t) iris_info.depth; z++)\n          {\n            length=SGIEncode(q+z,(size_t) iris_info.columns,packets+\n              number_packets);\n            number_packets+=length;\n            offsets[y+z*iris_info.rows]=offset;\n            runlength[y+z*iris_info.rows]=(size_t) length;\n            offset+=(ssize_t) length;\n          }\n          q+=(iris_info.columns*4);\n        }\n        /*\n          Write out line start and length tables and runlength-encoded pixels.\n        */\n        for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)\n          (void) WriteBlobMSBLong(image,(unsigned int) offsets[i]);\n        for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)\n          (void) WriteBlobMSBLong(image,(unsigned int) runlength[i]);\n        (void) WriteBlob(image,number_packets,packets);\n        /*\n          Relinquish resources.\n        */\n        offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n        runlength=(size_t *) RelinquishMagickMemory(runlength);\n        packet_info=RelinquishVirtualMemory(packet_info);\n        break;\n      }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            SSSSS   GGGG  IIIII                              %\n%                            SS     G        I                                %\n%                             SSS   G  GG    I                                %\n%                               SS  G   G    I                                %\n%                            SSSSS   GGG   IIIII                              %\n%                                                                             %\n%                                                                             %\n%                      Read/Write Irix RGB Image Format                       %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n\f\n/*\n  Typedef declaractions.\n*/\ntypedef struct _SGIInfo\n{\n  unsigned short\n    magic;\n\n  unsigned char\n    storage,\n    bytes_per_pixel;\n\n  unsigned short\n    dimension,\n    columns,\n    rows,\n    depth;\n\n  size_t\n    minimum_value,\n    maximum_value,\n    sans;\n\n  char\n    name[80];\n\n  size_t\n    pixel_format;\n\n  unsigned char\n    filler[404];\n} SGIInfo;\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteSGIImage(const ImageInfo *,Image *,ExceptionInfo *);\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s S G I                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsSGI() returns MagickTrue if the image format type, identified by the\n%  magick string, is SGI.\n%\n%  The format of the IsSGI method is:\n%\n%      MagickBooleanType IsSGI(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsSGI(const unsigned char *magick,const size_t length)\n{\n  if (length < 2)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\001\\332\",2) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d S G I I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadSGIImage() reads a SGI RGB image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadSGIImage method is:\n%\n%      Image *ReadSGIImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic MagickBooleanType SGIDecode(const size_t bytes_per_pixel,\n  ssize_t number_packets,unsigned char *packets,ssize_t number_pixels,\n  unsigned char *pixels)\n{\n  register unsigned char\n    *p,\n    *q;\n\n  size_t\n    pixel;\n\n  ssize_t\n    count;\n\n  p=packets;\n  q=pixels;\n  if (bytes_per_pixel == 2)\n    {\n      for ( ; number_pixels > 0; )\n      {\n        if (number_packets-- == 0)\n          return(MagickFalse);\n        pixel=(size_t) (*p++) << 8;\n        pixel|=(*p++);\n        count=(ssize_t) (pixel & 0x7f);\n        if (count == 0)\n          break;\n        if (count > (ssize_t) number_pixels)\n          return(MagickFalse);\n        number_pixels-=count;\n        if ((pixel & 0x80) != 0)\n          for ( ; count != 0; count--)\n          {\n            if (number_packets-- == 0)\n              return(MagickFalse);\n            *q=(*p++);\n            *(q+1)=(*p++);\n            q+=8;\n          }\n        else\n          {\n            if (number_packets-- == 0)\n              return(MagickFalse);\n            pixel=(size_t) (*p++) << 8;\n            pixel|=(*p++);\n            for ( ; count != 0; count--)\n            {\n              *q=(unsigned char) (pixel >> 8);\n              *(q+1)=(unsigned char) pixel;\n              q+=8;\n            }\n          }\n      }\n      return(MagickTrue);\n    }\n  for ( ; number_pixels > 0; )\n  {\n    if (number_packets-- == 0)\n      return(MagickFalse);\n    pixel=(size_t) (*p++);\n    count=(ssize_t) (pixel & 0x7f);\n    if (count == 0)\n      break;\n    if (count > (ssize_t) number_pixels)\n      return(MagickFalse);\n    number_pixels-=count;\n    if ((pixel & 0x80) != 0)\n      for ( ; count != 0; count--)\n      {\n        if (number_packets-- == 0)\n          return(MagickFalse);\n        *q=(*p++);\n        q+=4;\n      }\n    else\n      {\n        if (number_packets-- == 0)\n          return(MagickFalse);\n        pixel=(size_t) (*p++);\n        for ( ; count != 0; count--)\n        {\n          *q=(unsigned char) pixel;\n          q+=4;\n        }\n      }\n  }\n  return(MagickTrue);\n}\n\nstatic Image *ReadSGIImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *pixel_info;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  SGIInfo\n    iris_info;\n\n  size_t\n    bytes_per_pixel,\n    quantum;\n\n  ssize_t\n    count,\n    y,\n    z;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read SGI raster header.\n  */\n  iris_info.magic=ReadBlobMSBShort(image);\n  do\n  {\n    /*\n      Verify SGI identifier.\n    */\n    if (iris_info.magic != 0x01DA)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.storage=(unsigned char) ReadBlobByte(image);\n    switch (iris_info.storage)\n    {\n      case 0x00: image->compression=NoCompression; break;\n      case 0x01: image->compression=RLECompression; break;\n      default:\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n    iris_info.bytes_per_pixel=(unsigned char) ReadBlobByte(image);\n    if ((iris_info.bytes_per_pixel == 0) || (iris_info.bytes_per_pixel > 2))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.dimension=ReadBlobMSBShort(image);\n    if ((iris_info.dimension == 0) || (iris_info.dimension > 3)) \n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.columns=ReadBlobMSBShort(image);\n    iris_info.rows=ReadBlobMSBShort(image);\n    iris_info.depth=ReadBlobMSBShort(image);\n    if ((iris_info.depth == 0) || (iris_info.depth > 4))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.minimum_value=ReadBlobMSBLong(image);\n    iris_info.maximum_value=ReadBlobMSBLong(image);\n    iris_info.sans=ReadBlobMSBLong(image);\n    count=ReadBlob(image,sizeof(iris_info.name),(unsigned char *)\n      iris_info.name);\n    if ((size_t) count != sizeof(iris_info.name))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.name[sizeof(iris_info.name)-1]='\\0';\n    if (*iris_info.name != '\\0')\n      (void) SetImageProperty(image,\"label\",iris_info.name,exception);\n    iris_info.pixel_format=ReadBlobMSBLong(image);\n    if (iris_info.pixel_format != 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    count=ReadBlob(image,sizeof(iris_info.filler),iris_info.filler);\n    if ((size_t) count != sizeof(iris_info.filler))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    image->columns=iris_info.columns;\n    image->rows=iris_info.rows;\n    image->depth=(size_t) MagickMin(iris_info.depth,MAGICKCORE_QUANTUM_DEPTH);\n    if (iris_info.pixel_format == 0)\n      image->depth=(size_t) MagickMin((size_t) 8*iris_info.bytes_per_pixel,\n        MAGICKCORE_QUANTUM_DEPTH);\n    if (iris_info.depth < 3)\n      {\n        image->storage_class=PseudoClass;\n        image->colors=(size_t) (iris_info.bytes_per_pixel > 1 ? 65535 : 256);\n      }\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    /*\n      Allocate SGI pixels.\n    */\n    bytes_per_pixel=(size_t) iris_info.bytes_per_pixel;\n    number_pixels=(MagickSizeType) iris_info.columns*iris_info.rows;\n    if ((4*bytes_per_pixel*number_pixels) != ((MagickSizeType) (size_t)\n        (4*bytes_per_pixel*number_pixels)))\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixel_info=AcquireVirtualMemory(iris_info.columns,iris_info.rows*4*\n      bytes_per_pixel*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    if ((int) iris_info.storage != 0x01)\n      {\n        unsigned char\n          *scanline;\n\n        /*\n          Read standard image format.\n        */\n        scanline=(unsigned char *) AcquireQuantumMemory(iris_info.columns,\n          bytes_per_pixel*sizeof(*scanline));\n        if (scanline == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        for (z=0; z < (ssize_t) iris_info.depth; z++)\n        {\n          p=pixels+bytes_per_pixel*z;\n          for (y=0; y < (ssize_t) iris_info.rows; y++)\n          {\n            count=ReadBlob(image,bytes_per_pixel*iris_info.columns,scanline);\n            if (EOFBlob(image) != MagickFalse)\n              break;\n            if (bytes_per_pixel == 2)\n              for (x=0; x < (ssize_t) iris_info.columns; x++)\n              {\n                *p=scanline[2*x];\n                *(p+1)=scanline[2*x+1];\n                p+=8;\n              }\n            else\n              for (x=0; x < (ssize_t) iris_info.columns; x++)\n              {\n                *p=scanline[x];\n                p+=4;\n              }\n          }\n        }\n        scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n      }\n    else\n      {\n        MemoryInfo\n          *packet_info;\n\n        size_t\n          *runlength;\n\n        ssize_t\n          offset,\n          *offsets;\n\n        unsigned char\n          *packets;\n\n        unsigned int\n          data_order;\n\n        /*\n          Read runlength-encoded image format.\n        */\n        offsets=(ssize_t *) AcquireQuantumMemory((size_t) iris_info.rows,\n          iris_info.depth*sizeof(*offsets));\n        runlength=(size_t *) AcquireQuantumMemory(iris_info.rows,\n          iris_info.depth*sizeof(*runlength));\n        packet_info=AcquireVirtualMemory((size_t) iris_info.columns+10UL,4UL*\n          sizeof(*packets));\n        if ((offsets == (ssize_t *) NULL) ||\n            (runlength == (size_t *) NULL) ||\n            (packet_info == (MemoryInfo *) NULL))\n          {\n            if (offsets == (ssize_t *) NULL)\n              offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n            if (runlength == (size_t *) NULL)\n              runlength=(size_t *) RelinquishMagickMemory(runlength);\n            if (packet_info == (MemoryInfo *) NULL)\n              packet_info=RelinquishVirtualMemory(packet_info);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        packets=(unsigned char *) GetVirtualMemoryBlob(packet_info);\n        for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)\n          offsets[i]=(ssize_t) ReadBlobMSBSignedLong(image);\n        for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)\n        {\n          runlength[i]=ReadBlobMSBLong(image);\n          if (runlength[i] > (4*(size_t) iris_info.columns+10))\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n        /*\n          Check data order.\n        */\n        offset=0;\n        data_order=0;\n        for (y=0; ((y < (ssize_t) iris_info.rows) && (data_order == 0)); y++)\n          for (z=0; ((z < (ssize_t) iris_info.depth) && (data_order == 0)); z++)\n          {\n            if (offsets[y+z*iris_info.rows] < offset)\n              data_order=1;\n            offset=offsets[y+z*iris_info.rows];\n          }\n        offset=(ssize_t) TellBlob(image);\n        if (data_order == 1)\n          {\n            for (z=0; z < (ssize_t) iris_info.depth; z++)\n            {\n              p=pixels;\n              for (y=0; y < (ssize_t) iris_info.rows; y++)\n              {\n                if (offset != offsets[y+z*iris_info.rows])\n                  {\n                    offset=offsets[y+z*iris_info.rows];\n                    offset=(ssize_t) SeekBlob(image,(MagickOffsetType) offset,\n                      SEEK_SET);\n                  }\n                count=ReadBlob(image,(size_t) runlength[y+z*iris_info.rows],\n                  packets);\n                if (EOFBlob(image) != MagickFalse)\n                  break;\n                offset+=(ssize_t) runlength[y+z*iris_info.rows];\n                status=SGIDecode(bytes_per_pixel,(ssize_t)\n                  (runlength[y+z*iris_info.rows]/bytes_per_pixel),packets,\n                  (ssize_t) iris_info.columns,p+bytes_per_pixel*z);\n                if (status == MagickFalse)\n                  ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n                p+=(iris_info.columns*4*bytes_per_pixel);\n              }\n            }\n          }\n        else\n          {\n            MagickOffsetType\n              position;\n\n            position=TellBlob(image);\n            p=pixels;\n            for (y=0; y < (ssize_t) iris_info.rows; y++)\n            {\n              for (z=0; z < (ssize_t) iris_info.depth; z++)\n              {\n                if (offset != offsets[y+z*iris_info.rows])\n                  {\n                    offset=offsets[y+z*iris_info.rows];\n                    offset=(ssize_t) SeekBlob(image,(MagickOffsetType) offset,\n                      SEEK_SET);\n                  }\n                count=ReadBlob(image,(size_t) runlength[y+z*iris_info.rows],\n                  packets);\n                if (EOFBlob(image) != MagickFalse)\n                  break;\n                offset+=(ssize_t) runlength[y+z*iris_info.rows];\n                status=SGIDecode(bytes_per_pixel,(ssize_t)\n                  (runlength[y+z*iris_info.rows]/bytes_per_pixel),packets,\n                  (ssize_t) iris_info.columns,p+bytes_per_pixel*z);\n                if (status == MagickFalse)\n                  ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              }\n              p+=(iris_info.columns*4*bytes_per_pixel);\n            }\n            offset=(ssize_t) SeekBlob(image,position,SEEK_SET);\n          }\n        packet_info=RelinquishVirtualMemory(packet_info);\n        runlength=(size_t *) RelinquishMagickMemory(runlength);\n        offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n      }\n    /*\n      Initialize image structure.\n    */\n    image->alpha_trait=iris_info.depth == 4 ? BlendPixelTrait :\n      UndefinedPixelTrait;\n    image->columns=iris_info.columns;\n    image->rows=iris_info.rows;\n    /*\n      Convert SGI raster image to pixel packets.\n    */\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Convert SGI image to DirectClass pixel packets.\n        */\n        if (bytes_per_pixel == 2)\n          {\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=pixels+(image->rows-y-1)*8*image->columns;\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelRed(image,ScaleShortToQuantum((unsigned short)\n                  ((*(p+0) << 8) | (*(p+1)))),q);\n                SetPixelGreen(image,ScaleShortToQuantum((unsigned short)\n                  ((*(p+2) << 8) | (*(p+3)))),q);\n                SetPixelBlue(image,ScaleShortToQuantum((unsigned short)\n                  ((*(p+4) << 8) | (*(p+5)))),q);\n                SetPixelAlpha(image,OpaqueAlpha,q);\n                if (image->alpha_trait != UndefinedPixelTrait)\n                  SetPixelAlpha(image,ScaleShortToQuantum((unsigned short)\n                    ((*(p+6) << 8) | (*(p+7)))),q);\n                p+=8;\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=pixels+(image->rows-y-1)*4*image->columns;\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(image,ScaleCharToQuantum(*p),q);\n              SetPixelGreen(image,ScaleCharToQuantum(*(p+1)),q);\n              SetPixelBlue(image,ScaleCharToQuantum(*(p+2)),q);\n              SetPixelAlpha(image,OpaqueAlpha,q);\n              if (image->alpha_trait != UndefinedPixelTrait)\n                SetPixelAlpha(image,ScaleCharToQuantum(*(p+3)),q);\n              p+=4;\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n      }\n    else\n      {\n        /*\n          Create grayscale map.\n        */\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Convert SGI image to PseudoClass pixel packets.\n        */\n        if (bytes_per_pixel == 2)\n          {\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=pixels+(image->rows-y-1)*8*image->columns;\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                quantum=(*p << 8);\n                quantum|=(*(p+1));\n                SetPixelIndex(image,(Quantum) quantum,q);\n                p+=8;\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=pixels+(image->rows-y-1)*4*image->columns;\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelIndex(image,*p,q);\n              p+=4;\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        (void) SyncImage(image,exception);\n      }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    iris_info.magic=ReadBlobMSBShort(image);\n    if (iris_info.magic == 0x01DA)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (iris_info.magic == 0x01DA);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r S G I I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterSGIImage() adds properties for the SGI image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterSGIImage method is:\n%\n%      size_t RegisterSGIImage(void)\n%\n*/\nModuleExport size_t RegisterSGIImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"SGI\",\"SGI\",\"Irix RGB image\");\n  entry->decoder=(DecodeImageHandler *) ReadSGIImage;\n  entry->encoder=(EncodeImageHandler *) WriteSGIImage;\n  entry->magick=(IsImageFormatHandler *) IsSGI;\n  entry->flags|=CoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r S G I I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterSGIImage() removes format registrations made by the\n%  SGI module from the list of supported formats.\n%\n%  The format of the UnregisterSGIImage method is:\n%\n%      UnregisterSGIImage(void)\n%\n*/\nModuleExport void UnregisterSGIImage(void)\n{\n  (void) UnregisterMagickInfo(\"SGI\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e S G I I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteSGIImage() writes an image in SGI RGB encoded image format.\n%\n%  The format of the WriteSGIImage method is:\n%\n%      MagickBooleanType WriteSGIImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic size_t SGIEncode(unsigned char *pixels,size_t length,\n  unsigned char *packets)\n{\n  short\n    runlength;\n\n  register unsigned char\n    *p,\n    *q;\n\n  unsigned char\n    *limit,\n    *mark;\n\n  p=pixels;\n  limit=p+length*4;\n  q=packets;\n  while (p < limit)\n  {\n    mark=p;\n    p+=8;\n    while ((p < limit) && ((*(p-8) != *(p-4)) || (*(p-4) != *p)))\n      p+=4;\n    p-=8;\n    length=(size_t) (p-mark) >> 2;\n    while (length != 0)\n    {\n      runlength=(short) (length > 126 ? 126 : length);\n      length-=runlength;\n      *q++=(unsigned char) (0x80 | runlength);\n      for ( ; runlength > 0; runlength--)\n      {\n        *q++=(*mark);\n        mark+=4;\n      }\n    }\n    mark=p;\n    p+=4;\n    while ((p < limit) && (*p == *mark))\n      p+=4;\n    length=(size_t) (p-mark) >> 2;\n    while (length != 0)\n    {\n      runlength=(short) (length > 126 ? 126 : length);\n      length-=runlength;\n      *q++=(unsigned char) runlength;\n      *q++=(*mark);\n    }\n  }\n  *q++='\\0';\n  return((size_t) (q-packets));\n}\n\nstatic MagickBooleanType WriteSGIImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  CompressionType\n    compression;\n\n  const char\n    *value;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *pixel_info;\n\n  SGIInfo\n    iris_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  ssize_t\n    y,\n    z;\n\n  unsigned char\n    *pixels,\n    *packets;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if ((image->columns > 65535UL) || (image->rows > 65535UL))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  scene=0;\n  do\n  {\n    /*\n      Initialize SGI raster file header.\n    */\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    (void) ResetMagickMemory(&iris_info,0,sizeof(iris_info));\n    iris_info.magic=0x01DA;\n    compression=image->compression;\n    if (image_info->compression != UndefinedCompression)\n      compression=image_info->compression;\n    if (image->depth > 8)\n      compression=NoCompression;\n    if (compression == NoCompression)\n      iris_info.storage=(unsigned char) 0x00;\n    else\n      iris_info.storage=(unsigned char) 0x01;\n    iris_info.bytes_per_pixel=(unsigned char) (image->depth > 8 ? 2 : 1);\n    iris_info.dimension=3;\n    iris_info.columns=(unsigned short) image->columns;\n    iris_info.rows=(unsigned short) image->rows;\n    if (image->alpha_trait != UndefinedPixelTrait)\n      iris_info.depth=4;\n    else\n      {\n        if ((image_info->type != TrueColorType) &&\n            (SetImageGray(image,exception) != MagickFalse))\n          {\n            iris_info.dimension=2;\n            iris_info.depth=1;\n          }\n        else\n          iris_info.depth=3;\n      }\n    iris_info.minimum_value=0;\n    iris_info.maximum_value=(size_t) (image->depth <= 8 ?\n      1UL*ScaleQuantumToChar(QuantumRange) :\n      1UL*ScaleQuantumToShort(QuantumRange));\n    /*\n      Write SGI header.\n    */\n    (void) WriteBlobMSBShort(image,iris_info.magic);\n    (void) WriteBlobByte(image,iris_info.storage);\n    (void) WriteBlobByte(image,iris_info.bytes_per_pixel);\n    (void) WriteBlobMSBShort(image,iris_info.dimension);\n    (void) WriteBlobMSBShort(image,iris_info.columns);\n    (void) WriteBlobMSBShort(image,iris_info.rows);\n    (void) WriteBlobMSBShort(image,iris_info.depth);\n    (void) WriteBlobMSBLong(image,(unsigned int) iris_info.minimum_value);\n    (void) WriteBlobMSBLong(image,(unsigned int) iris_info.maximum_value);\n    (void) WriteBlobMSBLong(image,(unsigned int) iris_info.sans);\n    value=GetImageProperty(image,\"label\",exception);\n    if (value != (const char *) NULL)\n      (void) CopyMagickString(iris_info.name,value,sizeof(iris_info.name));\n    (void) WriteBlob(image,sizeof(iris_info.name),(unsigned char *)\n      iris_info.name);\n    (void) WriteBlobMSBLong(image,(unsigned int) iris_info.pixel_format);\n    (void) WriteBlob(image,sizeof(iris_info.filler),iris_info.filler);\n    /*\n      Allocate SGI pixels.\n    */\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    if ((4*iris_info.bytes_per_pixel*number_pixels) !=\n        ((MagickSizeType) (size_t) (4*iris_info.bytes_per_pixel*number_pixels)))\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixel_info=AcquireVirtualMemory((size_t) number_pixels,4*\n      iris_info.bytes_per_pixel*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    /*\n      Convert image pixels to uncompressed SGI pixels.\n    */\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n      if (p == (const Quantum *) NULL)\n        break;\n      if (image->depth <= 8)\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          register unsigned char\n            *q;\n\n          q=(unsigned char *) pixels;\n          q+=((iris_info.rows-1)-y)*(4*iris_info.columns)+4*x;\n          *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n          *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n          *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n          *q++=ScaleQuantumToChar(GetPixelAlpha(image,p));\n          p+=GetPixelChannels(image);\n        }\n      else\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          register unsigned short\n            *q;\n\n          q=(unsigned short *) pixels;\n          q+=((iris_info.rows-1)-y)*(4*iris_info.columns)+4*x;\n          *q++=ScaleQuantumToShort(GetPixelRed(image,p));\n          *q++=ScaleQuantumToShort(GetPixelGreen(image,p));\n          *q++=ScaleQuantumToShort(GetPixelBlue(image,p));\n          *q++=ScaleQuantumToShort(GetPixelAlpha(image,p));\n          p+=GetPixelChannels(image);\n        }\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    switch (compression)\n    {\n      case NoCompression:\n      {\n        /*\n          Write uncompressed SGI pixels.\n        */\n        for (z=0; z < (ssize_t) iris_info.depth; z++)\n        {\n          for (y=0; y < (ssize_t) iris_info.rows; y++)\n          {\n            if (image->depth <= 8)\n              for (x=0; x < (ssize_t) iris_info.columns; x++)\n              {\n                register unsigned char\n                  *q;\n\n                q=(unsigned char *) pixels;\n                q+=y*(4*iris_info.columns)+4*x+z;\n                (void) WriteBlobByte(image,*q);\n              }\n            else\n              for (x=0; x < (ssize_t) iris_info.columns; x++)\n              {\n                register unsigned short\n                  *q;\n\n                q=(unsigned short *) pixels;\n                q+=y*(4*iris_info.columns)+4*x+z;\n                (void) WriteBlobMSBShort(image,*q);\n              }\n          }\n        }\n        break;\n      }\n      default:\n      {\n        MemoryInfo\n          *packet_info;\n\n        size_t\n          length,\n          number_packets,\n          *runlength;\n\n        ssize_t\n          offset,\n          *offsets;\n\n        /*\n          Convert SGI uncompressed pixels.\n        */\n        offsets=(ssize_t *) AcquireQuantumMemory(iris_info.rows,\n          iris_info.depth*sizeof(*offsets));\n        runlength=(size_t *) AcquireQuantumMemory(iris_info.rows,\n          iris_info.depth*sizeof(*runlength));\n        packet_info=AcquireVirtualMemory((2*(size_t) iris_info.columns+10)*\n          image->rows,4*sizeof(*packets));\n        if ((offsets == (ssize_t *) NULL) ||\n            (runlength == (size_t *) NULL) ||\n            (packet_info == (MemoryInfo *) NULL))\n          {\n            if (offsets != (ssize_t *) NULL)\n              offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n            if (runlength != (size_t *) NULL)\n              runlength=(size_t *) RelinquishMagickMemory(runlength);\n            if (packet_info != (MemoryInfo *) NULL)\n              packet_info=RelinquishVirtualMemory(packet_info);\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        packets=(unsigned char *) GetVirtualMemoryBlob(packet_info);\n        offset=512+4*2*((ssize_t) iris_info.rows*iris_info.depth);\n        number_packets=0;\n        q=pixels;\n        for (y=0; y < (ssize_t) iris_info.rows; y++)\n        {\n          for (z=0; z < (ssize_t) iris_info.depth; z++)\n          {\n            length=SGIEncode(q+z,(size_t) iris_info.columns,packets+\n              number_packets);\n            number_packets+=length;\n            offsets[y+z*iris_info.rows]=offset;\n            runlength[y+z*iris_info.rows]=(size_t) length;\n            offset+=(ssize_t) length;\n          }\n          q+=(iris_info.columns*4);\n        }\n        /*\n          Write out line start and length tables and runlength-encoded pixels.\n        */\n        for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)\n          (void) WriteBlobMSBLong(image,(unsigned int) offsets[i]);\n        for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)\n          (void) WriteBlobMSBLong(image,(unsigned int) runlength[i]);\n        (void) WriteBlob(image,number_packets,packets);\n        /*\n          Relinquish resources.\n        */\n        offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n        runlength=(size_t *) RelinquishMagickMemory(runlength);\n        packet_info=RelinquishVirtualMemory(packet_info);\n        break;\n      }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "filenames": ["coders/sgi.c"], "buggy_code_start_loc": [338], "buggy_code_end_loc": [338], "fixing_code_start_loc": [339], "fixing_code_end_loc": [341], "type": "CWE-119", "message": "The IsPixelGray function in MagickCore/pixel-accessor.h in ImageMagick 7.0.3-8 allows remote attackers to cause a denial of service (out-of-bounds heap read) via a crafted image file.", "other": {"cve": {"id": "CVE-2016-9556", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-23T18:59:01.100", "lastModified": "2017-03-24T15:09:17.690", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The IsPixelGray function in MagickCore/pixel-accessor.h in ImageMagick 7.0.3-8 allows remote attackers to cause a denial of service (out-of-bounds heap read) via a crafted image file."}, {"lang": "es", "value": "La funci\u00f3n IsPixelGray en MagickCore/pixel-accessor.h en ImageMagick 7.0.3-8 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (lectura de memoria din\u00e1mica fuera de l\u00edmites) a trav\u00e9s de un archivo de imagen manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-8:*:*:*:*:*:*:*", "matchCriteriaId": "B48F5327-CA20-4756-A06F-B30B660E8DA7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse_project:leap:42.1:*:*:*:*:*:*:*", "matchCriteriaId": "CF605E46-ADCE-45B3-BBBA-E593D3CEE2A6"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-updates/2016-12/msg00040.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2016/dsa-3726", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/11/23/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/12/01/4", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/12/02/12", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/94492", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://blogs.gentoo.org/ago/2016/11/19/imagemagick-heap-based-buffer-overflow-in-ispixelgray-pixel-accessor-h", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1398198", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/ce98a7acbcfca7f0a178f4b1e7b957e419e0cc99", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/ce98a7acbcfca7f0a178f4b1e7b957e419e0cc99"}}