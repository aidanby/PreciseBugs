{"buggy_code": ["2018-xx-xx -- x.x.x\n\n  * Fixed: Out-of-bounds write in uriComposeQuery* and uriComposeQueryEx*\n      Thanks to Google Autofuzz team for the report!\n  * Fixed: Fix off-by-one in uriComposeQueryCharsRequired* and ...Ex*\n      Reported space requirements were 1 byte bigger than necessary\n  * TODO BUMP SONAME\n\n2018-08-18 -- 0.8.6\n\n  * Fixed: Bad/NULL .hostText.afterLast when parsing certain rather pathologic\n      but well-formed URIs with empty host (e.g. \"//:%aa@\") (GitHub #15)\n      Thanks to Kurt Schwehr for the report!\n  * Fixed: Fix uriRemoveBaseUri for case where scheme, host name,\n      IPvFuture address or path segments of the source address were\n      string prefixes of the related counterpart in the base URI.\n      Thanks to Yang Yu for the patch! (GitHub #19, #20)\n  * Fixed: Make UriStringToUnixFilename and UriStringToWindowsFilename\n      support minimal representation a la RFC 8089, e.g. file:/bin/bash\n      (compare to file:///bin/bash with three slashes) (GitHub #12, #14)\n      Thanks to Zane van Iperen for the report!\n  * Fixed: Documentation typos (GitHub #10, #11)\n      Thanks to Graham Percival!\n  * Improved: Made API docs of uriRemoveBaseUri more clear\n      (related to GitHub #19)\n  * Soname: 1:22:0\n\n2018-02-07 -- 0.8.5\n\n  * Changed: The uriparser project has moved from SourceForge to GitHub:\n      Code + issue tracker: https://github.com/uriparser/uriparser\n      New website: https://uriparser.github.io/\n      Please update any links of yours, accordingly. Thank you!\n  * Fixed: Memleak in out-of-memory clean-up code\n      of URI normalization, related to SF.net bug #28.\n      Thanks to Chris Hills for the report!\n  * Fixed: Fix compilation of uriparse(1) on FreeBSD\n      Thanks to Ed Schouten for the patch!\n  * Fixed: Fix C90 compilation errors\n      Thanks to Joel Cunningham for the patches!\n  * Fixed: Space requirements documented for uriWindowsFilenameToUriStringA\n      given URI \"file://server1/file1.txt\" (SF.net bug #31)\n      Thanks to threedyd for the report!\n  * Fixed: Compiler warnings\n      Thanks to Joel Cunningham for the patches!\n  * Fixed: Stop exporting internal function RemoveBaseUriImpl\n      Thanks to Joel Cunningham for the report!\n  * Fixed: API documentation front page no longer empty with Doxygen 1.8.13\n  * Fixed: \"make -C doc install\" fixed for lack of .map files\n  * Improved: Communicate that absolutePath is always URI_FALSE for URIs\n      with a host in uriparse CLI tool output and Uri.h header\n      (GitHub #2, SF.net #30)\n  * Soname: 1:21:0\n\n2015-10-12 -- 0.8.4\n\n  * Fixed: Stack overflow on parsing malformed IPv6 addresses with\n      more than eigtht quads.  Thanks to Alexander Klink for the report!\n  * Soname: 1:20:0\n\n2015-10-04 -- 0.8.3\n\n  * Fixed: uriCompareRange reported NULL pointer and range of\n      length zero as equal, by mistake.\n      Thanks to Robert Kausch and his Coverity report.\n  * Fixed: Use-after-free in out-of-memory code of uriMakeOwner.\n      Thanks to Chris Hills and his Klocwork-based report (SF.net bug #28)\n  * Soname: 1:19:0\n\n2015-04-27 -- 0.8.2\n\n  * Fixed: Broken conversion from/to Windows network shares (SF.net bug #21)\n      Thanks to Adam Gross and Dmitry Repkin!\n  * Fixed: Limit uriCompareRange return values to -1/0/1 (SF.net bug #24)\n      As a side effect, this fixes the test suite for AArch64.\n      Thanks to Marcin Juszkiewicz for the patch!\n  * Fixed: MinGW Makefile:\n      LIB_DIR fixed from ../../lib leftover to ../../src (SF.net bug #27)\n      Thanks to Dmytro Zagashev for the report!\n  * Fixed: Add missing NULL checks to UriStringToFilename (SF.net bug #25)\n      Thanks to Jerome Custodio for the report!\n  * Changed: Leave inlining decisions to GCC\n  * Soname: 1:18:0\n\n2014-10-20 -- 0.8.1\n\n  * Fixed: Sync URI_VER_* preprocessor defines (were at 0.7.6, SF.net bug #23)\n  * Fixed: Bug in internal function that may flip uriEqualsUri results around\n  * Added: Function uriAddBaseUriEx allowing to resolve URIs with\n      a scheme identical to that of the base URI to resolve against\n      as if the URI to resolve had no scheme specified, when flag\n      URI_RESOLVE_IDENTICAL_SCHEME_COMPAT is specified\n      (SF.net feature request #4)\n  * Soname: 1:17:0\n\n2014-07-12 -- 0.8.0.1\n\n  * Fixed: ISO C90 warnings (SF.net bug #20)\n  * Changed: No longer ship RFC documents (to make things easier for Debian)\n  * Soname: 1:16:0\n\n2013-12-20 -- 0.8.0\n\n  * Fixed: Resolution of relative URI \"/\" broken\n      Thanks to Mo McRoberts for the patch!\n  * Fixed: uriAddBaseUri produced uriUri objects with both host\n      and the absolutePath flag set (while the absolutePath flag\n      should only be true for URI objects without a host) when\n      resolving absolute URIs like \"/\" or \"/foo/bar\".\n      Now the absolutePath flag is set to URI_FALSE and an empty\n      segment is added as necessary\n  * Fixed: .errorCode could end up unset, previously\n      Thanks to Radu Hociung for the patch!  (SF.net bug #16)\n  * Fixed: Resolve use of non-POSIX \"sed -r\" used when building\n     documentation  (SF.net bug #18)\n     Thanks to Ryan Schmidt for reporting!\n  * Fixed: Build DLL with -no-undefined on Windows\n      Thanks to Michel Zou for the patch!  (SF.net bug #19)\n  * Added: Command line tool \"uriparse\"\n      Thanks to Radu Hociung for coding!  (SF.net feature request #3)\n  * Soname: 1:15:0\n\n2013-08-24 -- 0.7.9\n\n  * Fixed: Error position ended up as NULL for some syntax errors.\n      Thanks to Daniel Solano G\u00f3mez for the patch!  (SF.net bug #14)\n  * Soname: 1:14:0\n\n2013-05-13 -- 0.7.8\n\n  * Fixed: Fix dissection of query string \"q=hello&x=&y=\" (SF.net bug #12)\n      Thanks to Marc Novakowski for reporting!\n  * Soname: 1:13:0\n\n2012-04-05 -- 0.7.7\n\n  * Fixed: Fix rejection of some valid characters for userinfo\n      section, e.g. \"http://%2Fuser:%2F21@host/\" (SF.net bug #11)\n  * Fixed: Fix rejection of valid double colon in userinfo\n      section, e.g. \"http://::@host/\"\n  * Soname: 1:12:0\n\n2012-01-20 -- 0.7.6\n\n  * Fixed: Qt Compressed Help file was not installed\n  * Fixed: Shadow/VPATH build doc generation\n  * Fixed: Compile error from Doxygen when configuring with\n      neither --enable-doc nor --disable-doc\n  * Fixed: Code documentation errors\n      Thanks to Valentin Haenel for the patch!\n  * Fixed: Fix include path in pkg-config, i.e. remove\n      \"/uriparser\" suffix as uriparser's headers are meant to\n      be included by statements like #include <uriparser/....> .\n      Thanks to Philip de Nier for reporting!\n  * Fixed: Compilation in context of Eclipse + Cygwin + wchar_t\n      (SF.net bug #10)\n      Thanks to Gary Mazzaferro for reporting!\n  * Fixed: Selection of supported character widths at build\n      time: <char *> or <wchar_t *> or both\n  * Added: configure parameters to disable either character\n      widths: --disable-char, --disable-wchar_t\n  * Soname: 1:11:0\n\n2009-03-04 -- 0.7.5\n\n  * Added: pkg-config file\n  * Fixed: File Doxyfile.in was missing from release archives\n      Thanks to Rakesh Pandit for reporting!\n  * Fixed: Doc generation troubles\n  * Changed: No longer shipping bundled libcpptest\n  * Changed: New dependencies:\n      - libcpptest 1.1.0 or later\n      - pkg-config\n      The libcpptest dependency can be disabled through\n      configuring with --disable-test, which excludes the\n      test suite from compilation.\n  * Soname: 1:10:0\n\n2008-12-23 -- 0.7.4\n\n  * Fixed: Null pointer de-referencing when dissecting query\n      strings starting with \"&\" right after \"?\" (SF.net bug #7).\n      Thanks to Harvey Vrsalovic for reporting!\n  * Fixed: Memory leak in uriFreeQueryList function (SF.net bug #6)\n      Thanks to Daniel Chapiesky for reporting!\n  * Fixed: Memory leak in uriNormalizeSyntax(Ex) functions (SF.net bug #6)\n      Thanks to Daniel Chapiesky for reporting!\n  * Improved: Nested configure hacks resolved\n  * Soname: 1:9:0\n\n2008-11-08 -- 0.7.3\n\n  * Fixed: Missing NULL check in parsing routines\n      Thanks to Sezai Tekin for reporting!\n  * Fixed: uriparser now builds on Cygwin\n  * Fixed: Now shipping gnulib's config.guess from HEAD\n      which is suitable for Haiku (SF.net bug #5)\n  * Changed: swprintf requirement resolved\n  * Changed: Build system changes:\n      - configure option --enable-doc added\n      - configure.in renamed to configure.ac\n      - some Autotools files moved to build-aux directory\n  * Added: Qt Assistant documentation output:\n      - Qt Compressed Help (.qch) at <doc/uriparser-doc-*.qch>\n      - Qt Help Project (.qhp) at <doc/html/index.qhp>\n      Generation requires Doxygen 1.5.7.1-20081103 or later.\n  * Soname: 1:8:0\n\n2008-09-01 -- 0.7.2\n\n  * Fixed: Bad cleanup logic in functions\n      - uriAddBaseUri(..)\n      - uriRemoveBaseUri(..)\n      Previously you needed to call uriFreeUriMembers on return code\n      URI_ERROR_MALLOC and only then. So that's why these functions now\n      take cleanup off your shoulders. An extra call to uriFreeUriMembers\n      from your side is still needed in case of success.\n  * Soname: 1:7:0\n\n2008-04-27 -- 0.7.1\n\n  * Fixed: Bogus syntax error when parsing URIs with port-like\n      passwords, e.g. \"http://user:21@host/\" (SF.net bug #1)\n      Thanks to Friedrich Delgado Friedrichs for reporting!\n  * Fixed: Parser did not handle trailing slashes correctly in some cases,\n      which also made the structures produced from parsing \"http://e.com/\"\n      and \"http://e.com\" indistinguishable. (SF.net bug #2)\n      Thanks to Edward Z. Yang for reporting!\n\n2008-04-04 -- 0.7.0\n\n  * Added: Dissection and composition of query strings\n  * Added: Documentation improvements\n      (in|out|inout indicators, addition of \\since and \\see)\n  * Changed: Code::Blocks project files updated from file format\n      version 1.4 to 1.6, which is produced by Code::Blocks 8.02\n  * Added: Code::Blocks workspace file\n  * Soname: 1:5:0\n\n2008-02-25 -- 0.6.4\n\n  * Added: Syntax-based normalization can now handle relative URIs,\n      e.g. \"../../a/b/.././c\" is normalized to \"../../a/c\"\n  * Fixed: Normalization code could free foreign memory\n  * Fixed: Normalization processed the path segment even when asked not to\n  * Added: MinGW Makefile and related readme\n      Thanks to Michael Anthony Puls II!\n  * Fixed: Documentation bug not requiring enough memory for the output\n      buffer when converting a relative file URI back to a filename\n  * Soname: 1:4:0\n\n2008-02-11 -- 0.6.3\n\n  * Fixed: Two major crash bugs in normalization code\n      Thanks to Adrian Manrique for the patch!\n  * Added: Brief usage tutorial\n  * Soname: 1:3:0\n\n2008-02-08 -- 0.6.2\n\n  * Fixed: Freeing a normalized URI like \"http://test?\"\n      caused a crash. Thanks to Adrian Manrique for reporting!\n  * Fixed: Filename <--> URI string conversion helpers can\n      now handle relative URIs and filenames\n  * Soname: 1:2:0\n\n2007-12-23 -- 0.6.1\n\n  * Fixed: Percent-encodings in hostnames were not repaired during normalization.\n      Thanks to Adrian Manrique for reporting!\n  * Fixed: Percent-encodings were fixed after dot removal not before during\n      normalization.\n      Thanks to Adrian Manrique for reporting!\n  * Fixed: Include path order bug\n      Thanks to Ed Schouten for reporting this!\n  * Fixed: Shadow builds now possible\n      Thanks to Adeodato Sim\u00f3 for the patch!\n  * Added: Version guards for Autoconf/Automake\n      Thanks to Martin Michlmayr for reporting!\n  * Soname: 1:1:0\n\n2007-09-17 -- 0.6.0\n\n  * Fixed: Proper soname updates from now on, starting at 1:0:0\n  * Removed: Visual Studio 2003 project files\n\n2007-09-13 -- 0.5.2\n\n  * Added: RemoveBaseUri function to create URI references\n  * Added: Unix/Windows filename <--> URI string conversion helpers\n  * Added: EscapeEx function to escape text blocks without zero termination\n  * Fixed: Bug in ToString for URIs with scheme, path, but no host (e.g. \"f:/.//g\")\n  * Fixed: AddBase now resolves \".//g\" with base \"f:/a\" to \"f:/.//g\" instead of\n      \"f://g\" which would result in \"g\" becoming the authority part when parsing\n      a recomposition (ToString) of that URI structure. This is a whole in RFC 3986,\n      see http://lists.w3.org/Archives/Public/uri/2007Aug/0003.html for details.\n\n2007-08-09 -- 0.5.1\n\n  * Fixed: Empty host bug (URIs like \"///g\")\n  * Fixed: Relative URIs are no longer touched by normalization\n  * Fixed: MergePath failed for empty paths\n  * Fixed: Bug with \".\" segments in AddBase\n      All of the above revealed by test cases from 4Suite (http://4suite.org/)\n\n2007-07-28 -- 0.5.0\n\n  * Added: Syntax-based normalization\n  * Added: Percent-encoding function Escape\n  * Improved: Malloc/NULL checks added\n  * Added: New function UnescapeInPlaceEx can also decode '+' to ' '\n      and convert line breaks\n  * Added: Exact space computation for ToString, see ToStringCharsRequired\n  * Added: --enable-sizedown for saving space and slower code\n  * Fixed: Two internal functions were exposed in the API by mistake:\n      uriPushToStack and uriStackToOctet\n  * Added: Visual Studio 2005 project files\n  * Removed: Legacy code (removal was announced for 0.5.0)\n\n2007-07-06 -- 0.4.1\n\n  * Fixed: ToString did not work for IPv4 and IPv6 hosts\n\n2007-07-03 -- 0.4.0\n\n  * Added: References resolution (think relative to absolute)\n  * Added: Naive URI equality check\n  * Added: URIs can now be converted back to strings\n  * Fixed: The first path segment of a relative URI was eaten\n      (functions ParseSegmentNz and ParseMustBeSegmentNzNc)\n  * Fixed: uri->scheme.first was not reset in some cases\n      (function ParseMustBeSegmentNzNc)\n  * Improved: Test suite now built on \"make check\", not before\n  * Fixed: Test suite always returned 0 (success)\n\n2007-04-23 -- 0.3.4\n\n  * Added: Shared library support (moved to libtool)\n\n2007-04-03 -- 0.3.3\n\n  * Fixed: Now unix EOLs constantly\n  * Fixed: Added forgotten files to release package\n\n2007-03-31 -- 0.3.2\n\n  * Fixed: Now compiles on FreeBSD\n\n2007-03-28 -- 0.3.1\n\n  * Fixed: Now compiles on Mac OS X\n\n2007-03-26 -- 0.3.0\n\n  * Added: New API, old marked deprecated\n  * Added: Unicode support (think wchar_t)\n  * Added: Doxygen code documentation\n  * Added: Test suite using CppTest\n  * Changed: Library code is now licensed under the new BSD license.\n      The test suite code is licensed under LGPL.\n\n2006-12-08 -- 0.2.1\n", "/*\n * uriparser - RFC 3986 URI parsing library\n *\n * Copyright (C) 2007, Weijia Song <songweijia@gmail.com>\n * Copyright (C) 2007, Sebastian Pipping <sebastian@pipping.org>\n * All rights reserved.\n *\n * Redistribution  and use in source and binary forms, with or without\n * modification,  are permitted provided that the following conditions\n * are met:\n *\n *     * Redistributions   of  source  code  must  retain  the   above\n *       copyright  notice, this list of conditions and the  following\n *       disclaimer.\n *\n *     * Redistributions  in  binary  form must  reproduce  the  above\n *       copyright  notice, this list of conditions and the  following\n *       disclaimer   in  the  documentation  and/or  other  materials\n *       provided with the distribution.\n *\n *     * Neither  the name of the <ORGANIZATION> nor the names of  its\n *       contributors  may  be  used to endorse  or  promote  products\n *       derived  from  this software without specific  prior  written\n *       permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS  IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT  NOT\n * LIMITED  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS\n * FOR  A  PARTICULAR  PURPOSE ARE DISCLAIMED. IN NO EVENT  SHALL  THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL,    SPECIAL,   EXEMPLARY,   OR   CONSEQUENTIAL   DAMAGES\n * (INCLUDING,  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT  LIABILITY,  OR  TORT (INCLUDING  NEGLIGENCE  OR  OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* What encodings are enabled? */\n#include <uriparser/UriDefsConfig.h>\n#if (!defined(URI_PASS_ANSI) && !defined(URI_PASS_UNICODE))\n/* Include SELF twice */\n# ifdef URI_ENABLE_ANSI\n#  define URI_PASS_ANSI 1\n#  include \"UriQuery.c\"\n#  undef URI_PASS_ANSI\n# endif\n# ifdef URI_ENABLE_UNICODE\n#  define URI_PASS_UNICODE 1\n#  include \"UriQuery.c\"\n#  undef URI_PASS_UNICODE\n# endif\n#else\n# ifdef URI_PASS_ANSI\n#  include <uriparser/UriDefsAnsi.h>\n# else\n#  include <uriparser/UriDefsUnicode.h>\n#  include <wchar.h>\n# endif\n\n\n\n#ifndef URI_DOXYGEN\n# include <uriparser/Uri.h>\n# include \"UriCommon.h\"\n#endif\n\n\n\nstatic int URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,\n\t\tconst URI_TYPE(QueryList) * queryList,\n\t\tint maxChars, int * charsWritten, int * charsRequired,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks);\n\nstatic UriBool URI_FUNC(AppendQueryItem)(URI_TYPE(QueryList) ** prevNext,\n\t\tint * itemCount, const URI_CHAR * keyFirst, const URI_CHAR * keyAfter,\n\t\tconst URI_CHAR * valueFirst, const URI_CHAR * valueAfter,\n\t\tUriBool plusToSpace, UriBreakConversion breakConversion);\n\n\n\nint URI_FUNC(ComposeQueryCharsRequired)(const URI_TYPE(QueryList) * queryList,\n\t\tint * charsRequired) {\n\tconst UriBool spaceToPlus = URI_TRUE;\n\tconst UriBool normalizeBreaks = URI_TRUE;\n\n\treturn URI_FUNC(ComposeQueryCharsRequiredEx)(queryList, charsRequired,\n\t\t\tspaceToPlus, normalizeBreaks);\n}\n\n\n\nint URI_FUNC(ComposeQueryCharsRequiredEx)(const URI_TYPE(QueryList) * queryList,\n\t\tint * charsRequired, UriBool spaceToPlus, UriBool normalizeBreaks) {\n\tif ((queryList == NULL) || (charsRequired == NULL)) {\n\t\treturn URI_ERROR_NULL;\n\t}\n\n\treturn URI_FUNC(ComposeQueryEngine)(NULL, queryList, 0, NULL,\n\t\t\tcharsRequired, spaceToPlus, normalizeBreaks);\n}\n\n\n\nint URI_FUNC(ComposeQuery)(URI_CHAR * dest,\n\t\t\t\t\t\t   const URI_TYPE(QueryList) * queryList, int maxChars, int * charsWritten) {\n\tconst UriBool spaceToPlus = URI_TRUE;\n\tconst UriBool normalizeBreaks = URI_TRUE;\n\n\treturn URI_FUNC(ComposeQueryEx)(dest, queryList, maxChars, charsWritten,\n\t\t\tspaceToPlus, normalizeBreaks);\n}\n\n\n\nint URI_FUNC(ComposeQueryEx)(URI_CHAR * dest,\n\t\tconst URI_TYPE(QueryList) * queryList, int maxChars, int * charsWritten,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks) {\n\tif ((dest == NULL) || (queryList == NULL)) {\n\t\treturn URI_ERROR_NULL;\n\t}\n\n\tif (maxChars < 1) {\n\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t}\n\n\treturn URI_FUNC(ComposeQueryEngine)(dest, queryList, maxChars,\n\t\t\tcharsWritten, NULL, spaceToPlus, normalizeBreaks);\n}\n\n\n\nint URI_FUNC(ComposeQueryMalloc)(URI_CHAR ** dest,\n\t\tconst URI_TYPE(QueryList) * queryList) {\n\tconst UriBool spaceToPlus = URI_TRUE;\n\tconst UriBool normalizeBreaks = URI_TRUE;\n\n\treturn URI_FUNC(ComposeQueryMallocEx)(dest, queryList,\n\t\t\tspaceToPlus, normalizeBreaks);\n}\n\n\n\nint URI_FUNC(ComposeQueryMallocEx)(URI_CHAR ** dest,\n\t\tconst URI_TYPE(QueryList) * queryList,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks) {\n\tint charsRequired;\n\tint res;\n\tURI_CHAR * queryString;\n\n\tif (dest == NULL) {\n\t\treturn URI_ERROR_NULL;\n\t}\n\n\t/* Calculate space */\n\tres = URI_FUNC(ComposeQueryCharsRequiredEx)(queryList, &charsRequired,\n\t\t\tspaceToPlus, normalizeBreaks);\n\tif (res != URI_SUCCESS) {\n\t\treturn res;\n\t}\n\tcharsRequired++;\n\n\t/* Allocate space */\n\tqueryString = malloc(charsRequired * sizeof(URI_CHAR));\n\tif (queryString == NULL) {\n\t\treturn URI_ERROR_MALLOC;\n\t}\n\n\t/* Put query in */\n\tres = URI_FUNC(ComposeQueryEx)(queryString, queryList, charsRequired,\n\t\t\tNULL, spaceToPlus, normalizeBreaks);\n\tif (res != URI_SUCCESS) {\n\t\tfree(queryString);\n\t\treturn res;\n\t}\n\n\t*dest = queryString;\n\treturn URI_SUCCESS;\n}\n\n\n\nint URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,\n\t\tconst URI_TYPE(QueryList) * queryList,\n\t\tint maxChars, int * charsWritten, int * charsRequired,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks) {\n\tUriBool firstItem = URI_TRUE;\n\tint ampersandLen = 0;  /* increased to 1 from second item on */\n\tURI_CHAR * write = dest;\n\n\t/* Subtract terminator */\n\tif (dest == NULL) {\n\t\t*charsRequired = 0;\n\t} else {\n\t\tmaxChars--;\n\t}\n\n\twhile (queryList != NULL) {\n\t\tconst URI_CHAR * const key = queryList->key;\n\t\tconst URI_CHAR * const value = queryList->value;\n\t\tconst int worstCase = (normalizeBreaks == URI_TRUE ? 6 : 3);\n\t\tconst int keyLen = (key == NULL) ? 0 : (int)URI_STRLEN(key);\n\t\tconst int keyRequiredChars = worstCase * keyLen;\n\t\tconst int valueLen = (value == NULL) ? 0 : (int)URI_STRLEN(value);\n\t\tconst int valueRequiredChars = worstCase * valueLen;\n\n\t\tif (dest == NULL) {\n\t\t\t(*charsRequired) += ampersandLen + keyRequiredChars + ((value == NULL)\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: 1 + valueRequiredChars);\n\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((write - dest) + ampersandLen + keyRequiredChars > maxChars) {\n\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t}\n\n\t\t\t/* Copy key */\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t} else {\n\t\t\t\twrite[0] = _UT('&');\n\t\t\t\twrite++;\n\t\t\t}\n\t\t\twrite = URI_FUNC(EscapeEx)(key, key + keyLen,\n\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\n\t\t\tif (value != NULL) {\n\t\t\t\tif ((write - dest) + 1 + valueRequiredChars > maxChars) {\n\t\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t\t}\n\n\t\t\t\t/* Copy value */\n\t\t\t\twrite[0] = _UT('=');\n\t\t\t\twrite++;\n\t\t\t\twrite = URI_FUNC(EscapeEx)(value, value + valueLen,\n\t\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\t}\n\t\t}\n\n\t\tqueryList = queryList->next;\n\t}\n\n\tif (dest != NULL) {\n\t\twrite[0] = _UT('\\0');\n\t\tif (charsWritten != NULL) {\n\t\t\t*charsWritten = (int)(write - dest) + 1; /* .. for terminator */\n\t\t}\n\t}\n\n\treturn URI_SUCCESS;\n}\n\n\n\nUriBool URI_FUNC(AppendQueryItem)(URI_TYPE(QueryList) ** prevNext,\n\t\tint * itemCount, const URI_CHAR * keyFirst, const URI_CHAR * keyAfter,\n\t\tconst URI_CHAR * valueFirst, const URI_CHAR * valueAfter,\n\t\tUriBool plusToSpace, UriBreakConversion breakConversion) {\n\tconst int keyLen = (int)(keyAfter - keyFirst);\n\tconst int valueLen = (int)(valueAfter - valueFirst);\n\tURI_CHAR * key;\n\tURI_CHAR * value;\n\n\tif ((prevNext == NULL) || (itemCount == NULL)\n\t\t\t|| (keyFirst == NULL) || (keyAfter == NULL)\n\t\t\t|| (keyFirst > keyAfter) || (valueFirst > valueAfter)\n\t\t\t|| ((keyFirst == keyAfter)\n\t\t\t\t&& (valueFirst == NULL) && (valueAfter == NULL))) {\n\t\treturn URI_TRUE;\n\t}\n\n\t/* Append new empty item */\n\t*prevNext = malloc(1 * sizeof(URI_TYPE(QueryList)));\n\tif (*prevNext == NULL) {\n\t\treturn URI_FALSE; /* Raises malloc error */\n\t}\n\t(*prevNext)->next = NULL;\n\n\n\t/* Fill key */\n\tkey = malloc((keyLen + 1) * sizeof(URI_CHAR));\n\tif (key == NULL) {\n\t\tfree(*prevNext);\n\t\t*prevNext = NULL;\n\t\treturn URI_FALSE; /* Raises malloc error */\n\t}\n\n\tkey[keyLen] = _UT('\\0');\n\tif (keyLen > 0) {\n\t\t/* Copy 1:1 */\n\t\tmemcpy(key, keyFirst, keyLen * sizeof(URI_CHAR));\n\n\t\t/* Unescape */\n\t\tURI_FUNC(UnescapeInPlaceEx)(key, plusToSpace, breakConversion);\n\t}\n\t(*prevNext)->key = key;\n\n\n\t/* Fill value */\n\tif (valueFirst != NULL) {\n\t\tvalue = malloc((valueLen + 1) * sizeof(URI_CHAR));\n\t\tif (value == NULL) {\n\t\t\tfree(key);\n\t\t\tfree(*prevNext);\n\t\t\t*prevNext = NULL;\n\t\t\treturn URI_FALSE; /* Raises malloc error */\n\t\t}\n\n\t\tvalue[valueLen] = _UT('\\0');\n\t\tif (valueLen > 0) {\n\t\t\t/* Copy 1:1 */\n\t\t\tmemcpy(value, valueFirst, valueLen * sizeof(URI_CHAR));\n\n\t\t\t/* Unescape */\n\t\t\tURI_FUNC(UnescapeInPlaceEx)(value, plusToSpace, breakConversion);\n\t\t}\n\t\t(*prevNext)->value = value;\n\t} else {\n\t\tvalue = NULL;\n\t}\n\t(*prevNext)->value = value;\n\n\t(*itemCount)++;\n\treturn URI_TRUE;\n}\n\n\n\nvoid URI_FUNC(FreeQueryList)(URI_TYPE(QueryList) * queryList) {\n\twhile (queryList != NULL) {\n\t\tURI_TYPE(QueryList) * nextBackup = queryList->next;\n\t\tfree((URI_CHAR *)queryList->key); /* const cast */\n\t\tfree((URI_CHAR *)queryList->value); /* const cast */\n\t\tfree(queryList);\n\t\tqueryList = nextBackup;\n\t}\n}\n\n\n\nint URI_FUNC(DissectQueryMalloc)(URI_TYPE(QueryList) ** dest, int * itemCount,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast) {\n\tconst UriBool plusToSpace = URI_TRUE;\n\tconst UriBreakConversion breakConversion = URI_BR_DONT_TOUCH;\n\n\treturn URI_FUNC(DissectQueryMallocEx)(dest, itemCount, first, afterLast,\n\t\t\tplusToSpace, breakConversion);\n}\n\n\n\nint URI_FUNC(DissectQueryMallocEx)(URI_TYPE(QueryList) ** dest, int * itemCount,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriBool plusToSpace, UriBreakConversion breakConversion) {\n\tconst URI_CHAR * walk = first;\n\tconst URI_CHAR * keyFirst = first;\n\tconst URI_CHAR * keyAfter = NULL;\n\tconst URI_CHAR * valueFirst = NULL;\n\tconst URI_CHAR * valueAfter = NULL;\n\tURI_TYPE(QueryList) ** prevNext = dest;\n\tint nullCounter;\n\tint * itemsAppended = (itemCount == NULL) ? &nullCounter : itemCount;\n\n\tif ((dest == NULL) || (first == NULL) || (afterLast == NULL)) {\n\t\treturn URI_ERROR_NULL;\n\t}\n\n\tif (first > afterLast) {\n\t\treturn URI_ERROR_RANGE_INVALID;\n\t}\n\n\t*dest = NULL;\n\t*itemsAppended = 0;\n\n\t/* Parse query string */\n\tfor (; walk < afterLast; walk++) {\n\t\tswitch (*walk) {\n\t\tcase _UT('&'):\n\t\t\tif (valueFirst != NULL) {\n\t\t\t\tvalueAfter = walk;\n\t\t\t} else {\n\t\t\t\tkeyAfter = walk;\n\t\t\t}\n\n\t\t\tif (URI_FUNC(AppendQueryItem)(prevNext, itemsAppended,\n\t\t\t\t\tkeyFirst, keyAfter, valueFirst, valueAfter,\n\t\t\t\t\tplusToSpace, breakConversion)\n\t\t\t\t\t== URI_FALSE) {\n\t\t\t\t/* Free list we built */\n\t\t\t\t*itemsAppended = 0;\n\t\t\t\tURI_FUNC(FreeQueryList)(*dest);\n\t\t\t\treturn URI_ERROR_MALLOC;\n\t\t\t}\n\n\t\t\t/* Make future items children of the current */\n\t\t\tif ((prevNext != NULL) && (*prevNext != NULL)) {\n\t\t\t\tprevNext = &((*prevNext)->next);\n\t\t\t}\n\n\t\t\tif (walk + 1 < afterLast) {\n\t\t\t\tkeyFirst = walk + 1;\n\t\t\t} else {\n\t\t\t\tkeyFirst = NULL;\n\t\t\t}\n\t\t\tkeyAfter = NULL;\n\t\t\tvalueFirst = NULL;\n\t\t\tvalueAfter = NULL;\n\t\t\tbreak;\n\n\t\tcase _UT('='):\n\t\t\t/* NOTE: WE treat the first '=' as a separator, */\n\t\t\t/*       all following go into the value part   */\n\t\t\tif (keyAfter == NULL) {\n\t\t\t\tkeyAfter = walk;\n\t\t\t\tif (walk + 1 <= afterLast) {\n\t\t\t\t\tvalueFirst = walk + 1;\n\t\t\t\t\tvalueAfter = walk + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (valueFirst != NULL) {\n\t\t/* Must be key/value pair */\n\t\tvalueAfter = walk;\n\t} else {\n\t\t/* Must be key only */\n\t\tkeyAfter = walk;\n\t}\n\n\tif (URI_FUNC(AppendQueryItem)(prevNext, itemsAppended, keyFirst, keyAfter,\n\t\t\tvalueFirst, valueAfter, plusToSpace, breakConversion)\n\t\t\t== URI_FALSE) {\n\t\t/* Free list we built */\n\t\t*itemsAppended = 0;\n\t\tURI_FUNC(FreeQueryList)(*dest);\n\t\treturn URI_ERROR_MALLOC;\n\t}\n\n\treturn URI_SUCCESS;\n}\n\n\n\n#endif\n"], "fixing_code": ["2018-xx-xx -- x.x.x\n\n  * Fixed: Out-of-bounds write in uriComposeQuery* and uriComposeQueryEx*\n      Thanks to Google Autofuzz team for the report!\n  * Fixed: Fix off-by-one in uriComposeQueryCharsRequired* and ...Ex*\n      Reported space requirements were 1 byte bigger than necessary\n  * Fixed: Detect integer overflow in uriComposeQuery* and uriComposeQueryEx*\n      Thanks to Google Autofuzz team for the report!\n  * TODO BUMP SONAME\n\n2018-08-18 -- 0.8.6\n\n  * Fixed: Bad/NULL .hostText.afterLast when parsing certain rather pathologic\n      but well-formed URIs with empty host (e.g. \"//:%aa@\") (GitHub #15)\n      Thanks to Kurt Schwehr for the report!\n  * Fixed: Fix uriRemoveBaseUri for case where scheme, host name,\n      IPvFuture address or path segments of the source address were\n      string prefixes of the related counterpart in the base URI.\n      Thanks to Yang Yu for the patch! (GitHub #19, #20)\n  * Fixed: Make UriStringToUnixFilename and UriStringToWindowsFilename\n      support minimal representation a la RFC 8089, e.g. file:/bin/bash\n      (compare to file:///bin/bash with three slashes) (GitHub #12, #14)\n      Thanks to Zane van Iperen for the report!\n  * Fixed: Documentation typos (GitHub #10, #11)\n      Thanks to Graham Percival!\n  * Improved: Made API docs of uriRemoveBaseUri more clear\n      (related to GitHub #19)\n  * Soname: 1:22:0\n\n2018-02-07 -- 0.8.5\n\n  * Changed: The uriparser project has moved from SourceForge to GitHub:\n      Code + issue tracker: https://github.com/uriparser/uriparser\n      New website: https://uriparser.github.io/\n      Please update any links of yours, accordingly. Thank you!\n  * Fixed: Memleak in out-of-memory clean-up code\n      of URI normalization, related to SF.net bug #28.\n      Thanks to Chris Hills for the report!\n  * Fixed: Fix compilation of uriparse(1) on FreeBSD\n      Thanks to Ed Schouten for the patch!\n  * Fixed: Fix C90 compilation errors\n      Thanks to Joel Cunningham for the patches!\n  * Fixed: Space requirements documented for uriWindowsFilenameToUriStringA\n      given URI \"file://server1/file1.txt\" (SF.net bug #31)\n      Thanks to threedyd for the report!\n  * Fixed: Compiler warnings\n      Thanks to Joel Cunningham for the patches!\n  * Fixed: Stop exporting internal function RemoveBaseUriImpl\n      Thanks to Joel Cunningham for the report!\n  * Fixed: API documentation front page no longer empty with Doxygen 1.8.13\n  * Fixed: \"make -C doc install\" fixed for lack of .map files\n  * Improved: Communicate that absolutePath is always URI_FALSE for URIs\n      with a host in uriparse CLI tool output and Uri.h header\n      (GitHub #2, SF.net #30)\n  * Soname: 1:21:0\n\n2015-10-12 -- 0.8.4\n\n  * Fixed: Stack overflow on parsing malformed IPv6 addresses with\n      more than eigtht quads.  Thanks to Alexander Klink for the report!\n  * Soname: 1:20:0\n\n2015-10-04 -- 0.8.3\n\n  * Fixed: uriCompareRange reported NULL pointer and range of\n      length zero as equal, by mistake.\n      Thanks to Robert Kausch and his Coverity report.\n  * Fixed: Use-after-free in out-of-memory code of uriMakeOwner.\n      Thanks to Chris Hills and his Klocwork-based report (SF.net bug #28)\n  * Soname: 1:19:0\n\n2015-04-27 -- 0.8.2\n\n  * Fixed: Broken conversion from/to Windows network shares (SF.net bug #21)\n      Thanks to Adam Gross and Dmitry Repkin!\n  * Fixed: Limit uriCompareRange return values to -1/0/1 (SF.net bug #24)\n      As a side effect, this fixes the test suite for AArch64.\n      Thanks to Marcin Juszkiewicz for the patch!\n  * Fixed: MinGW Makefile:\n      LIB_DIR fixed from ../../lib leftover to ../../src (SF.net bug #27)\n      Thanks to Dmytro Zagashev for the report!\n  * Fixed: Add missing NULL checks to UriStringToFilename (SF.net bug #25)\n      Thanks to Jerome Custodio for the report!\n  * Changed: Leave inlining decisions to GCC\n  * Soname: 1:18:0\n\n2014-10-20 -- 0.8.1\n\n  * Fixed: Sync URI_VER_* preprocessor defines (were at 0.7.6, SF.net bug #23)\n  * Fixed: Bug in internal function that may flip uriEqualsUri results around\n  * Added: Function uriAddBaseUriEx allowing to resolve URIs with\n      a scheme identical to that of the base URI to resolve against\n      as if the URI to resolve had no scheme specified, when flag\n      URI_RESOLVE_IDENTICAL_SCHEME_COMPAT is specified\n      (SF.net feature request #4)\n  * Soname: 1:17:0\n\n2014-07-12 -- 0.8.0.1\n\n  * Fixed: ISO C90 warnings (SF.net bug #20)\n  * Changed: No longer ship RFC documents (to make things easier for Debian)\n  * Soname: 1:16:0\n\n2013-12-20 -- 0.8.0\n\n  * Fixed: Resolution of relative URI \"/\" broken\n      Thanks to Mo McRoberts for the patch!\n  * Fixed: uriAddBaseUri produced uriUri objects with both host\n      and the absolutePath flag set (while the absolutePath flag\n      should only be true for URI objects without a host) when\n      resolving absolute URIs like \"/\" or \"/foo/bar\".\n      Now the absolutePath flag is set to URI_FALSE and an empty\n      segment is added as necessary\n  * Fixed: .errorCode could end up unset, previously\n      Thanks to Radu Hociung for the patch!  (SF.net bug #16)\n  * Fixed: Resolve use of non-POSIX \"sed -r\" used when building\n     documentation  (SF.net bug #18)\n     Thanks to Ryan Schmidt for reporting!\n  * Fixed: Build DLL with -no-undefined on Windows\n      Thanks to Michel Zou for the patch!  (SF.net bug #19)\n  * Added: Command line tool \"uriparse\"\n      Thanks to Radu Hociung for coding!  (SF.net feature request #3)\n  * Soname: 1:15:0\n\n2013-08-24 -- 0.7.9\n\n  * Fixed: Error position ended up as NULL for some syntax errors.\n      Thanks to Daniel Solano G\u00f3mez for the patch!  (SF.net bug #14)\n  * Soname: 1:14:0\n\n2013-05-13 -- 0.7.8\n\n  * Fixed: Fix dissection of query string \"q=hello&x=&y=\" (SF.net bug #12)\n      Thanks to Marc Novakowski for reporting!\n  * Soname: 1:13:0\n\n2012-04-05 -- 0.7.7\n\n  * Fixed: Fix rejection of some valid characters for userinfo\n      section, e.g. \"http://%2Fuser:%2F21@host/\" (SF.net bug #11)\n  * Fixed: Fix rejection of valid double colon in userinfo\n      section, e.g. \"http://::@host/\"\n  * Soname: 1:12:0\n\n2012-01-20 -- 0.7.6\n\n  * Fixed: Qt Compressed Help file was not installed\n  * Fixed: Shadow/VPATH build doc generation\n  * Fixed: Compile error from Doxygen when configuring with\n      neither --enable-doc nor --disable-doc\n  * Fixed: Code documentation errors\n      Thanks to Valentin Haenel for the patch!\n  * Fixed: Fix include path in pkg-config, i.e. remove\n      \"/uriparser\" suffix as uriparser's headers are meant to\n      be included by statements like #include <uriparser/....> .\n      Thanks to Philip de Nier for reporting!\n  * Fixed: Compilation in context of Eclipse + Cygwin + wchar_t\n      (SF.net bug #10)\n      Thanks to Gary Mazzaferro for reporting!\n  * Fixed: Selection of supported character widths at build\n      time: <char *> or <wchar_t *> or both\n  * Added: configure parameters to disable either character\n      widths: --disable-char, --disable-wchar_t\n  * Soname: 1:11:0\n\n2009-03-04 -- 0.7.5\n\n  * Added: pkg-config file\n  * Fixed: File Doxyfile.in was missing from release archives\n      Thanks to Rakesh Pandit for reporting!\n  * Fixed: Doc generation troubles\n  * Changed: No longer shipping bundled libcpptest\n  * Changed: New dependencies:\n      - libcpptest 1.1.0 or later\n      - pkg-config\n      The libcpptest dependency can be disabled through\n      configuring with --disable-test, which excludes the\n      test suite from compilation.\n  * Soname: 1:10:0\n\n2008-12-23 -- 0.7.4\n\n  * Fixed: Null pointer de-referencing when dissecting query\n      strings starting with \"&\" right after \"?\" (SF.net bug #7).\n      Thanks to Harvey Vrsalovic for reporting!\n  * Fixed: Memory leak in uriFreeQueryList function (SF.net bug #6)\n      Thanks to Daniel Chapiesky for reporting!\n  * Fixed: Memory leak in uriNormalizeSyntax(Ex) functions (SF.net bug #6)\n      Thanks to Daniel Chapiesky for reporting!\n  * Improved: Nested configure hacks resolved\n  * Soname: 1:9:0\n\n2008-11-08 -- 0.7.3\n\n  * Fixed: Missing NULL check in parsing routines\n      Thanks to Sezai Tekin for reporting!\n  * Fixed: uriparser now builds on Cygwin\n  * Fixed: Now shipping gnulib's config.guess from HEAD\n      which is suitable for Haiku (SF.net bug #5)\n  * Changed: swprintf requirement resolved\n  * Changed: Build system changes:\n      - configure option --enable-doc added\n      - configure.in renamed to configure.ac\n      - some Autotools files moved to build-aux directory\n  * Added: Qt Assistant documentation output:\n      - Qt Compressed Help (.qch) at <doc/uriparser-doc-*.qch>\n      - Qt Help Project (.qhp) at <doc/html/index.qhp>\n      Generation requires Doxygen 1.5.7.1-20081103 or later.\n  * Soname: 1:8:0\n\n2008-09-01 -- 0.7.2\n\n  * Fixed: Bad cleanup logic in functions\n      - uriAddBaseUri(..)\n      - uriRemoveBaseUri(..)\n      Previously you needed to call uriFreeUriMembers on return code\n      URI_ERROR_MALLOC and only then. So that's why these functions now\n      take cleanup off your shoulders. An extra call to uriFreeUriMembers\n      from your side is still needed in case of success.\n  * Soname: 1:7:0\n\n2008-04-27 -- 0.7.1\n\n  * Fixed: Bogus syntax error when parsing URIs with port-like\n      passwords, e.g. \"http://user:21@host/\" (SF.net bug #1)\n      Thanks to Friedrich Delgado Friedrichs for reporting!\n  * Fixed: Parser did not handle trailing slashes correctly in some cases,\n      which also made the structures produced from parsing \"http://e.com/\"\n      and \"http://e.com\" indistinguishable. (SF.net bug #2)\n      Thanks to Edward Z. Yang for reporting!\n\n2008-04-04 -- 0.7.0\n\n  * Added: Dissection and composition of query strings\n  * Added: Documentation improvements\n      (in|out|inout indicators, addition of \\since and \\see)\n  * Changed: Code::Blocks project files updated from file format\n      version 1.4 to 1.6, which is produced by Code::Blocks 8.02\n  * Added: Code::Blocks workspace file\n  * Soname: 1:5:0\n\n2008-02-25 -- 0.6.4\n\n  * Added: Syntax-based normalization can now handle relative URIs,\n      e.g. \"../../a/b/.././c\" is normalized to \"../../a/c\"\n  * Fixed: Normalization code could free foreign memory\n  * Fixed: Normalization processed the path segment even when asked not to\n  * Added: MinGW Makefile and related readme\n      Thanks to Michael Anthony Puls II!\n  * Fixed: Documentation bug not requiring enough memory for the output\n      buffer when converting a relative file URI back to a filename\n  * Soname: 1:4:0\n\n2008-02-11 -- 0.6.3\n\n  * Fixed: Two major crash bugs in normalization code\n      Thanks to Adrian Manrique for the patch!\n  * Added: Brief usage tutorial\n  * Soname: 1:3:0\n\n2008-02-08 -- 0.6.2\n\n  * Fixed: Freeing a normalized URI like \"http://test?\"\n      caused a crash. Thanks to Adrian Manrique for reporting!\n  * Fixed: Filename <--> URI string conversion helpers can\n      now handle relative URIs and filenames\n  * Soname: 1:2:0\n\n2007-12-23 -- 0.6.1\n\n  * Fixed: Percent-encodings in hostnames were not repaired during normalization.\n      Thanks to Adrian Manrique for reporting!\n  * Fixed: Percent-encodings were fixed after dot removal not before during\n      normalization.\n      Thanks to Adrian Manrique for reporting!\n  * Fixed: Include path order bug\n      Thanks to Ed Schouten for reporting this!\n  * Fixed: Shadow builds now possible\n      Thanks to Adeodato Sim\u00f3 for the patch!\n  * Added: Version guards for Autoconf/Automake\n      Thanks to Martin Michlmayr for reporting!\n  * Soname: 1:1:0\n\n2007-09-17 -- 0.6.0\n\n  * Fixed: Proper soname updates from now on, starting at 1:0:0\n  * Removed: Visual Studio 2003 project files\n\n2007-09-13 -- 0.5.2\n\n  * Added: RemoveBaseUri function to create URI references\n  * Added: Unix/Windows filename <--> URI string conversion helpers\n  * Added: EscapeEx function to escape text blocks without zero termination\n  * Fixed: Bug in ToString for URIs with scheme, path, but no host (e.g. \"f:/.//g\")\n  * Fixed: AddBase now resolves \".//g\" with base \"f:/a\" to \"f:/.//g\" instead of\n      \"f://g\" which would result in \"g\" becoming the authority part when parsing\n      a recomposition (ToString) of that URI structure. This is a whole in RFC 3986,\n      see http://lists.w3.org/Archives/Public/uri/2007Aug/0003.html for details.\n\n2007-08-09 -- 0.5.1\n\n  * Fixed: Empty host bug (URIs like \"///g\")\n  * Fixed: Relative URIs are no longer touched by normalization\n  * Fixed: MergePath failed for empty paths\n  * Fixed: Bug with \".\" segments in AddBase\n      All of the above revealed by test cases from 4Suite (http://4suite.org/)\n\n2007-07-28 -- 0.5.0\n\n  * Added: Syntax-based normalization\n  * Added: Percent-encoding function Escape\n  * Improved: Malloc/NULL checks added\n  * Added: New function UnescapeInPlaceEx can also decode '+' to ' '\n      and convert line breaks\n  * Added: Exact space computation for ToString, see ToStringCharsRequired\n  * Added: --enable-sizedown for saving space and slower code\n  * Fixed: Two internal functions were exposed in the API by mistake:\n      uriPushToStack and uriStackToOctet\n  * Added: Visual Studio 2005 project files\n  * Removed: Legacy code (removal was announced for 0.5.0)\n\n2007-07-06 -- 0.4.1\n\n  * Fixed: ToString did not work for IPv4 and IPv6 hosts\n\n2007-07-03 -- 0.4.0\n\n  * Added: References resolution (think relative to absolute)\n  * Added: Naive URI equality check\n  * Added: URIs can now be converted back to strings\n  * Fixed: The first path segment of a relative URI was eaten\n      (functions ParseSegmentNz and ParseMustBeSegmentNzNc)\n  * Fixed: uri->scheme.first was not reset in some cases\n      (function ParseMustBeSegmentNzNc)\n  * Improved: Test suite now built on \"make check\", not before\n  * Fixed: Test suite always returned 0 (success)\n\n2007-04-23 -- 0.3.4\n\n  * Added: Shared library support (moved to libtool)\n\n2007-04-03 -- 0.3.3\n\n  * Fixed: Now unix EOLs constantly\n  * Fixed: Added forgotten files to release package\n\n2007-03-31 -- 0.3.2\n\n  * Fixed: Now compiles on FreeBSD\n\n2007-03-28 -- 0.3.1\n\n  * Fixed: Now compiles on Mac OS X\n\n2007-03-26 -- 0.3.0\n\n  * Added: New API, old marked deprecated\n  * Added: Unicode support (think wchar_t)\n  * Added: Doxygen code documentation\n  * Added: Test suite using CppTest\n  * Changed: Library code is now licensed under the new BSD license.\n      The test suite code is licensed under LGPL.\n\n2006-12-08 -- 0.2.1\n", "/*\n * uriparser - RFC 3986 URI parsing library\n *\n * Copyright (C) 2007, Weijia Song <songweijia@gmail.com>\n * Copyright (C) 2007, Sebastian Pipping <sebastian@pipping.org>\n * All rights reserved.\n *\n * Redistribution  and use in source and binary forms, with or without\n * modification,  are permitted provided that the following conditions\n * are met:\n *\n *     * Redistributions   of  source  code  must  retain  the   above\n *       copyright  notice, this list of conditions and the  following\n *       disclaimer.\n *\n *     * Redistributions  in  binary  form must  reproduce  the  above\n *       copyright  notice, this list of conditions and the  following\n *       disclaimer   in  the  documentation  and/or  other  materials\n *       provided with the distribution.\n *\n *     * Neither  the name of the <ORGANIZATION> nor the names of  its\n *       contributors  may  be  used to endorse  or  promote  products\n *       derived  from  this software without specific  prior  written\n *       permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS  IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT  NOT\n * LIMITED  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS\n * FOR  A  PARTICULAR  PURPOSE ARE DISCLAIMED. IN NO EVENT  SHALL  THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL,    SPECIAL,   EXEMPLARY,   OR   CONSEQUENTIAL   DAMAGES\n * (INCLUDING,  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT  LIABILITY,  OR  TORT (INCLUDING  NEGLIGENCE  OR  OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* What encodings are enabled? */\n#include <uriparser/UriDefsConfig.h>\n#if (!defined(URI_PASS_ANSI) && !defined(URI_PASS_UNICODE))\n/* Include SELF twice */\n# ifdef URI_ENABLE_ANSI\n#  define URI_PASS_ANSI 1\n#  include \"UriQuery.c\"\n#  undef URI_PASS_ANSI\n# endif\n# ifdef URI_ENABLE_UNICODE\n#  define URI_PASS_UNICODE 1\n#  include \"UriQuery.c\"\n#  undef URI_PASS_UNICODE\n# endif\n#else\n# ifdef URI_PASS_ANSI\n#  include <uriparser/UriDefsAnsi.h>\n# else\n#  include <uriparser/UriDefsUnicode.h>\n#  include <wchar.h>\n# endif\n\n\n\n#ifndef URI_DOXYGEN\n# include <uriparser/Uri.h>\n# include \"UriCommon.h\"\n#endif\n\n\n\n#include <limits.h>\n\n\n\nstatic int URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,\n\t\tconst URI_TYPE(QueryList) * queryList,\n\t\tint maxChars, int * charsWritten, int * charsRequired,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks);\n\nstatic UriBool URI_FUNC(AppendQueryItem)(URI_TYPE(QueryList) ** prevNext,\n\t\tint * itemCount, const URI_CHAR * keyFirst, const URI_CHAR * keyAfter,\n\t\tconst URI_CHAR * valueFirst, const URI_CHAR * valueAfter,\n\t\tUriBool plusToSpace, UriBreakConversion breakConversion);\n\n\n\nint URI_FUNC(ComposeQueryCharsRequired)(const URI_TYPE(QueryList) * queryList,\n\t\tint * charsRequired) {\n\tconst UriBool spaceToPlus = URI_TRUE;\n\tconst UriBool normalizeBreaks = URI_TRUE;\n\n\treturn URI_FUNC(ComposeQueryCharsRequiredEx)(queryList, charsRequired,\n\t\t\tspaceToPlus, normalizeBreaks);\n}\n\n\n\nint URI_FUNC(ComposeQueryCharsRequiredEx)(const URI_TYPE(QueryList) * queryList,\n\t\tint * charsRequired, UriBool spaceToPlus, UriBool normalizeBreaks) {\n\tif ((queryList == NULL) || (charsRequired == NULL)) {\n\t\treturn URI_ERROR_NULL;\n\t}\n\n\treturn URI_FUNC(ComposeQueryEngine)(NULL, queryList, 0, NULL,\n\t\t\tcharsRequired, spaceToPlus, normalizeBreaks);\n}\n\n\n\nint URI_FUNC(ComposeQuery)(URI_CHAR * dest,\n\t\t\t\t\t\t   const URI_TYPE(QueryList) * queryList, int maxChars, int * charsWritten) {\n\tconst UriBool spaceToPlus = URI_TRUE;\n\tconst UriBool normalizeBreaks = URI_TRUE;\n\n\treturn URI_FUNC(ComposeQueryEx)(dest, queryList, maxChars, charsWritten,\n\t\t\tspaceToPlus, normalizeBreaks);\n}\n\n\n\nint URI_FUNC(ComposeQueryEx)(URI_CHAR * dest,\n\t\tconst URI_TYPE(QueryList) * queryList, int maxChars, int * charsWritten,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks) {\n\tif ((dest == NULL) || (queryList == NULL)) {\n\t\treturn URI_ERROR_NULL;\n\t}\n\n\tif (maxChars < 1) {\n\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t}\n\n\treturn URI_FUNC(ComposeQueryEngine)(dest, queryList, maxChars,\n\t\t\tcharsWritten, NULL, spaceToPlus, normalizeBreaks);\n}\n\n\n\nint URI_FUNC(ComposeQueryMalloc)(URI_CHAR ** dest,\n\t\tconst URI_TYPE(QueryList) * queryList) {\n\tconst UriBool spaceToPlus = URI_TRUE;\n\tconst UriBool normalizeBreaks = URI_TRUE;\n\n\treturn URI_FUNC(ComposeQueryMallocEx)(dest, queryList,\n\t\t\tspaceToPlus, normalizeBreaks);\n}\n\n\n\nint URI_FUNC(ComposeQueryMallocEx)(URI_CHAR ** dest,\n\t\tconst URI_TYPE(QueryList) * queryList,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks) {\n\tint charsRequired;\n\tint res;\n\tURI_CHAR * queryString;\n\n\tif (dest == NULL) {\n\t\treturn URI_ERROR_NULL;\n\t}\n\n\t/* Calculate space */\n\tres = URI_FUNC(ComposeQueryCharsRequiredEx)(queryList, &charsRequired,\n\t\t\tspaceToPlus, normalizeBreaks);\n\tif (res != URI_SUCCESS) {\n\t\treturn res;\n\t}\n\tcharsRequired++;\n\n\t/* Allocate space */\n\tqueryString = malloc(charsRequired * sizeof(URI_CHAR));\n\tif (queryString == NULL) {\n\t\treturn URI_ERROR_MALLOC;\n\t}\n\n\t/* Put query in */\n\tres = URI_FUNC(ComposeQueryEx)(queryString, queryList, charsRequired,\n\t\t\tNULL, spaceToPlus, normalizeBreaks);\n\tif (res != URI_SUCCESS) {\n\t\tfree(queryString);\n\t\treturn res;\n\t}\n\n\t*dest = queryString;\n\treturn URI_SUCCESS;\n}\n\n\n\nint URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,\n\t\tconst URI_TYPE(QueryList) * queryList,\n\t\tint maxChars, int * charsWritten, int * charsRequired,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks) {\n\tUriBool firstItem = URI_TRUE;\n\tint ampersandLen = 0;  /* increased to 1 from second item on */\n\tURI_CHAR * write = dest;\n\n\t/* Subtract terminator */\n\tif (dest == NULL) {\n\t\t*charsRequired = 0;\n\t} else {\n\t\tmaxChars--;\n\t}\n\n\twhile (queryList != NULL) {\n\t\tconst URI_CHAR * const key = queryList->key;\n\t\tconst URI_CHAR * const value = queryList->value;\n\t\tconst int worstCase = (normalizeBreaks == URI_TRUE ? 6 : 3);\n\t\tconst int keyLen = (key == NULL) ? 0 : (int)URI_STRLEN(key);\n\t\tint keyRequiredChars;\n\t\tconst int valueLen = (value == NULL) ? 0 : (int)URI_STRLEN(value);\n\t\tint valueRequiredChars;\n\n\t\tif ((keyLen >= INT_MAX / worstCase) || (valueLen >= INT_MAX / worstCase)) {\n\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t}\n\t\tkeyRequiredChars = worstCase * keyLen;\n\t\tvalueRequiredChars = worstCase * valueLen;\n\n\t\tif (dest == NULL) {\n\t\t\t(*charsRequired) += ampersandLen + keyRequiredChars + ((value == NULL)\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: 1 + valueRequiredChars);\n\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((write - dest) + ampersandLen + keyRequiredChars > maxChars) {\n\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t}\n\n\t\t\t/* Copy key */\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t} else {\n\t\t\t\twrite[0] = _UT('&');\n\t\t\t\twrite++;\n\t\t\t}\n\t\t\twrite = URI_FUNC(EscapeEx)(key, key + keyLen,\n\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\n\t\t\tif (value != NULL) {\n\t\t\t\tif ((write - dest) + 1 + valueRequiredChars > maxChars) {\n\t\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t\t}\n\n\t\t\t\t/* Copy value */\n\t\t\t\twrite[0] = _UT('=');\n\t\t\t\twrite++;\n\t\t\t\twrite = URI_FUNC(EscapeEx)(value, value + valueLen,\n\t\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\t}\n\t\t}\n\n\t\tqueryList = queryList->next;\n\t}\n\n\tif (dest != NULL) {\n\t\twrite[0] = _UT('\\0');\n\t\tif (charsWritten != NULL) {\n\t\t\t*charsWritten = (int)(write - dest) + 1; /* .. for terminator */\n\t\t}\n\t}\n\n\treturn URI_SUCCESS;\n}\n\n\n\nUriBool URI_FUNC(AppendQueryItem)(URI_TYPE(QueryList) ** prevNext,\n\t\tint * itemCount, const URI_CHAR * keyFirst, const URI_CHAR * keyAfter,\n\t\tconst URI_CHAR * valueFirst, const URI_CHAR * valueAfter,\n\t\tUriBool plusToSpace, UriBreakConversion breakConversion) {\n\tconst int keyLen = (int)(keyAfter - keyFirst);\n\tconst int valueLen = (int)(valueAfter - valueFirst);\n\tURI_CHAR * key;\n\tURI_CHAR * value;\n\n\tif ((prevNext == NULL) || (itemCount == NULL)\n\t\t\t|| (keyFirst == NULL) || (keyAfter == NULL)\n\t\t\t|| (keyFirst > keyAfter) || (valueFirst > valueAfter)\n\t\t\t|| ((keyFirst == keyAfter)\n\t\t\t\t&& (valueFirst == NULL) && (valueAfter == NULL))) {\n\t\treturn URI_TRUE;\n\t}\n\n\t/* Append new empty item */\n\t*prevNext = malloc(1 * sizeof(URI_TYPE(QueryList)));\n\tif (*prevNext == NULL) {\n\t\treturn URI_FALSE; /* Raises malloc error */\n\t}\n\t(*prevNext)->next = NULL;\n\n\n\t/* Fill key */\n\tkey = malloc((keyLen + 1) * sizeof(URI_CHAR));\n\tif (key == NULL) {\n\t\tfree(*prevNext);\n\t\t*prevNext = NULL;\n\t\treturn URI_FALSE; /* Raises malloc error */\n\t}\n\n\tkey[keyLen] = _UT('\\0');\n\tif (keyLen > 0) {\n\t\t/* Copy 1:1 */\n\t\tmemcpy(key, keyFirst, keyLen * sizeof(URI_CHAR));\n\n\t\t/* Unescape */\n\t\tURI_FUNC(UnescapeInPlaceEx)(key, plusToSpace, breakConversion);\n\t}\n\t(*prevNext)->key = key;\n\n\n\t/* Fill value */\n\tif (valueFirst != NULL) {\n\t\tvalue = malloc((valueLen + 1) * sizeof(URI_CHAR));\n\t\tif (value == NULL) {\n\t\t\tfree(key);\n\t\t\tfree(*prevNext);\n\t\t\t*prevNext = NULL;\n\t\t\treturn URI_FALSE; /* Raises malloc error */\n\t\t}\n\n\t\tvalue[valueLen] = _UT('\\0');\n\t\tif (valueLen > 0) {\n\t\t\t/* Copy 1:1 */\n\t\t\tmemcpy(value, valueFirst, valueLen * sizeof(URI_CHAR));\n\n\t\t\t/* Unescape */\n\t\t\tURI_FUNC(UnescapeInPlaceEx)(value, plusToSpace, breakConversion);\n\t\t}\n\t\t(*prevNext)->value = value;\n\t} else {\n\t\tvalue = NULL;\n\t}\n\t(*prevNext)->value = value;\n\n\t(*itemCount)++;\n\treturn URI_TRUE;\n}\n\n\n\nvoid URI_FUNC(FreeQueryList)(URI_TYPE(QueryList) * queryList) {\n\twhile (queryList != NULL) {\n\t\tURI_TYPE(QueryList) * nextBackup = queryList->next;\n\t\tfree((URI_CHAR *)queryList->key); /* const cast */\n\t\tfree((URI_CHAR *)queryList->value); /* const cast */\n\t\tfree(queryList);\n\t\tqueryList = nextBackup;\n\t}\n}\n\n\n\nint URI_FUNC(DissectQueryMalloc)(URI_TYPE(QueryList) ** dest, int * itemCount,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast) {\n\tconst UriBool plusToSpace = URI_TRUE;\n\tconst UriBreakConversion breakConversion = URI_BR_DONT_TOUCH;\n\n\treturn URI_FUNC(DissectQueryMallocEx)(dest, itemCount, first, afterLast,\n\t\t\tplusToSpace, breakConversion);\n}\n\n\n\nint URI_FUNC(DissectQueryMallocEx)(URI_TYPE(QueryList) ** dest, int * itemCount,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriBool plusToSpace, UriBreakConversion breakConversion) {\n\tconst URI_CHAR * walk = first;\n\tconst URI_CHAR * keyFirst = first;\n\tconst URI_CHAR * keyAfter = NULL;\n\tconst URI_CHAR * valueFirst = NULL;\n\tconst URI_CHAR * valueAfter = NULL;\n\tURI_TYPE(QueryList) ** prevNext = dest;\n\tint nullCounter;\n\tint * itemsAppended = (itemCount == NULL) ? &nullCounter : itemCount;\n\n\tif ((dest == NULL) || (first == NULL) || (afterLast == NULL)) {\n\t\treturn URI_ERROR_NULL;\n\t}\n\n\tif (first > afterLast) {\n\t\treturn URI_ERROR_RANGE_INVALID;\n\t}\n\n\t*dest = NULL;\n\t*itemsAppended = 0;\n\n\t/* Parse query string */\n\tfor (; walk < afterLast; walk++) {\n\t\tswitch (*walk) {\n\t\tcase _UT('&'):\n\t\t\tif (valueFirst != NULL) {\n\t\t\t\tvalueAfter = walk;\n\t\t\t} else {\n\t\t\t\tkeyAfter = walk;\n\t\t\t}\n\n\t\t\tif (URI_FUNC(AppendQueryItem)(prevNext, itemsAppended,\n\t\t\t\t\tkeyFirst, keyAfter, valueFirst, valueAfter,\n\t\t\t\t\tplusToSpace, breakConversion)\n\t\t\t\t\t== URI_FALSE) {\n\t\t\t\t/* Free list we built */\n\t\t\t\t*itemsAppended = 0;\n\t\t\t\tURI_FUNC(FreeQueryList)(*dest);\n\t\t\t\treturn URI_ERROR_MALLOC;\n\t\t\t}\n\n\t\t\t/* Make future items children of the current */\n\t\t\tif ((prevNext != NULL) && (*prevNext != NULL)) {\n\t\t\t\tprevNext = &((*prevNext)->next);\n\t\t\t}\n\n\t\t\tif (walk + 1 < afterLast) {\n\t\t\t\tkeyFirst = walk + 1;\n\t\t\t} else {\n\t\t\t\tkeyFirst = NULL;\n\t\t\t}\n\t\t\tkeyAfter = NULL;\n\t\t\tvalueFirst = NULL;\n\t\t\tvalueAfter = NULL;\n\t\t\tbreak;\n\n\t\tcase _UT('='):\n\t\t\t/* NOTE: WE treat the first '=' as a separator, */\n\t\t\t/*       all following go into the value part   */\n\t\t\tif (keyAfter == NULL) {\n\t\t\t\tkeyAfter = walk;\n\t\t\t\tif (walk + 1 <= afterLast) {\n\t\t\t\t\tvalueFirst = walk + 1;\n\t\t\t\t\tvalueAfter = walk + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (valueFirst != NULL) {\n\t\t/* Must be key/value pair */\n\t\tvalueAfter = walk;\n\t} else {\n\t\t/* Must be key only */\n\t\tkeyAfter = walk;\n\t}\n\n\tif (URI_FUNC(AppendQueryItem)(prevNext, itemsAppended, keyFirst, keyAfter,\n\t\t\tvalueFirst, valueAfter, plusToSpace, breakConversion)\n\t\t\t== URI_FALSE) {\n\t\t/* Free list we built */\n\t\t*itemsAppended = 0;\n\t\tURI_FUNC(FreeQueryList)(*dest);\n\t\treturn URI_ERROR_MALLOC;\n\t}\n\n\treturn URI_SUCCESS;\n}\n\n\n\n#endif\n"], "filenames": ["ChangeLog", "src/UriQuery.c"], "buggy_code_start_loc": [6, 70], "buggy_code_end_loc": [6, 207], "fixing_code_start_loc": [7, 71], "fixing_code_end_loc": [9, 217], "type": "CWE-190", "message": "An issue was discovered in uriparser before 0.9.0. UriQuery.c allows an integer overflow via a uriComposeQuery* or uriComposeQueryEx* function because of an unchecked multiplication.", "other": {"cve": {"id": "CVE-2018-19199", "sourceIdentifier": "cve@mitre.org", "published": "2018-11-12T15:29:00.287", "lastModified": "2019-08-06T17:15:33.773", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in uriparser before 0.9.0. UriQuery.c allows an integer overflow via a uriComposeQuery* or uriComposeQueryEx* function because of an unchecked multiplication."}, {"lang": "es", "value": "Se ha descubierto un problema en versiones anteriores a la 0.9.0 de uriparser. UriQuery.c permite un desbordamiento de enteros mediante las funciones uriComposeQuery* o uriComposeQueryEx* debido a una multiplicaci\u00f3n sin comprobar."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:uriparser_project:uriparser:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.9.0", "matchCriteriaId": "2CDFDF1E-3FB8-4A74-875F-5F4857CE03E7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2019:2280", "source": "cve@mitre.org"}, {"url": "https://github.com/uriparser/uriparser/blob/uriparser-0.9.0/ChangeLog", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/uriparser/uriparser/commit/f76275d4a91b28d687250525d3a0c5509bbd666f", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/11/msg00019.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/uriparser/uriparser/commit/f76275d4a91b28d687250525d3a0c5509bbd666f"}}