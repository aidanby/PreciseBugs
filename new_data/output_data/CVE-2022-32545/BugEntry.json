{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            PPPP   SSSSS  DDDD                               %\n%                            P   P  SS     D   D                              %\n%                            PPPP    SSS   D   D                              %\n%                            P         SS  D   D                              %\n%                            P      SSSSS  DDDD                               %\n%                                                                             %\n%                                                                             %\n%                   Read/Write Adobe Photoshop Image Format                   %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                              Leonard Rosenthol                              %\n%                                 July 1992                                   %\n%                                Dirk Lemstra                                 %\n%                                December 2013                                %\n%                                                                             %\n%                                                                             %\n%  Copyright @ 1999 ImageMagick Studio LLC, a non-profit organization         %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n% Photoshop spec @ https://www.adobe.com/devnet-apps/photoshop/fileformatashtml\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/pixel-private.h\"\n#include \"MagickCore/policy.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/registry.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"coders/coders-private.h\"\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n#include <zlib.h>\n#endif\n#include \"psd-private.h\"\n\n/*\n  Define declaractions.\n*/\n#define MaxPSDChannels  56\n#define PSDQuantum(x) (((ssize_t) (x)+1) & -2)\n\f\n/*\n  Enumerated declaractions.\n*/\ntypedef enum\n{\n  Raw = 0,\n  RLE = 1,\n  ZipWithoutPrediction = 2,\n  ZipWithPrediction = 3\n} PSDCompressionType;\n\ntypedef enum\n{\n  BitmapMode = 0,\n  GrayscaleMode = 1,\n  IndexedMode = 2,\n  RGBMode = 3,\n  CMYKMode = 4,\n  MultichannelMode = 7,\n  DuotoneMode = 8,\n  LabMode = 9\n} PSDImageType;\n\f\n/*\n  Typedef declaractions.\n*/\ntypedef struct _ChannelInfo\n{\n  MagickBooleanType\n    supported;\n\n  PixelChannel\n    channel;\n\n  size_t\n    size;\n} ChannelInfo;\n\ntypedef struct _MaskInfo\n{\n  Image\n    *image;\n\n  RectangleInfo\n    page;\n\n  unsigned char\n    background,\n    flags;\n} MaskInfo;\n\ntypedef struct _LayerInfo\n{\n  ChannelInfo\n    channel_info[MaxPSDChannels];\n\n  char\n    blendkey[4];\n\n  Image\n    *image;\n\n  MaskInfo\n    mask;\n\n  Quantum\n    opacity;\n\n  RectangleInfo\n    page;\n\n  size_t\n    offset_x,\n    offset_y;\n\n  unsigned char\n    clipping,\n    flags,\n    name[257],\n    visible;\n\n  unsigned short\n    channels;\n\n  StringInfo\n    *info;\n} LayerInfo;\n\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WritePSDImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s P S D                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsPSD()() returns MagickTrue if the image format type, identified by the\n%  magick string, is PSD.\n%\n%  The format of the IsPSD method is:\n%\n%      MagickBooleanType IsPSD(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsPSD(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (LocaleNCompare((const char *) magick,\"8BPS\",4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d P S D I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadPSDImage() reads an Adobe Photoshop image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadPSDImage method is:\n%\n%      Image *ReadPSDImage(image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic const char *CompositeOperatorToPSDBlendMode(Image *image)\n{\n  switch (image->compose)\n  {\n    case ColorBurnCompositeOp:\n      return(image->endian == LSBEndian ? \"vidi\" : \"idiv\");\n    case ColorDodgeCompositeOp:\n      return(image->endian == LSBEndian ? \" vid\" : \"div \");\n    case ColorizeCompositeOp:\n      return(image->endian == LSBEndian ? \"rloc\" : \"colr\");\n    case DarkenCompositeOp:\n      return(image->endian == LSBEndian ? \"krad\" : \"dark\");\n    case DifferenceCompositeOp:\n      return(image->endian == LSBEndian ? \"ffid\" : \"diff\");\n    case DissolveCompositeOp:\n      return(image->endian == LSBEndian ? \"ssid\" : \"diss\");\n    case ExclusionCompositeOp:\n      return(image->endian == LSBEndian ? \"dums\" : \"smud\");\n    case HardLightCompositeOp:\n      return(image->endian == LSBEndian ? \"tiLh\" : \"hLit\");\n    case HardMixCompositeOp:\n      return(image->endian == LSBEndian ? \"xiMh\" : \"hMix\");\n    case HueCompositeOp:\n      return(image->endian == LSBEndian ? \" euh\" : \"hue \");\n    case LightenCompositeOp:\n      return(image->endian == LSBEndian ? \"etil\" : \"lite\");\n    case LinearBurnCompositeOp:\n      return(image->endian == LSBEndian ? \"nrbl\" : \"lbrn\");\n    case LinearDodgeCompositeOp:\n      return(image->endian == LSBEndian ? \"gddl\" : \"lddg\");\n    case LinearLightCompositeOp:\n      return(image->endian == LSBEndian ? \"tiLl\" : \"lLit\");\n    case LuminizeCompositeOp:\n      return(image->endian == LSBEndian ? \" mul\" : \"lum \");\n    case MultiplyCompositeOp:\n      return(image->endian == LSBEndian ? \" lum\" : \"mul \");\n    case OverlayCompositeOp:\n      return(image->endian == LSBEndian ? \"revo\" : \"over\");\n    case PinLightCompositeOp:\n      return(image->endian == LSBEndian ? \"tiLp\" : \"pLit\");\n    case SaturateCompositeOp:\n      return(image->endian == LSBEndian ? \" tas\" : \"sat \");\n    case ScreenCompositeOp:\n      return(image->endian == LSBEndian ? \"nrcs\" : \"scrn\");\n    case SoftLightCompositeOp:\n      return(image->endian == LSBEndian ? \"tiLs\" : \"sLit\");\n    case VividLightCompositeOp:\n      return(image->endian == LSBEndian ? \"tiLv\" : \"vLit\");\n    case OverCompositeOp:\n    default:\n      return(image->endian == LSBEndian ? \"mron\" : \"norm\");\n  }\n}\n\n/*\n  For some reason Photoshop seems to blend semi-transparent pixels with white.\n  This method reverts the blending. This can be disabled by setting the\n  option 'psd:alpha-unblend' to off.\n*/\nstatic MagickBooleanType CorrectPSDAlphaBlend(const ImageInfo *image_info,\n  Image *image,ExceptionInfo* exception)\n{\n  const char\n    *option;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  if ((image->alpha_trait != BlendPixelTrait) ||\n      (image->colorspace != sRGBColorspace))\n    return(MagickTrue);\n  option=GetImageOption(image_info,\"psd:alpha-unblend\");\n  if (IsStringFalse(option) != MagickFalse)\n    return(MagickTrue);\n  status=MagickTrue;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n#pragma omp parallel for schedule(static) shared(status) \\\n  magick_number_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    Quantum\n      *magick_restrict q;\n\n    ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        gamma;\n\n      ssize_t\n        i;\n\n      gamma=QuantumScale*GetPixelAlpha(image, q);\n      if (gamma != 0.0 && gamma != 1.0)\n        {\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            PixelChannel channel = GetPixelChannelChannel(image,i);\n            if (channel != AlphaPixelChannel)\n              q[i]=ClampToQuantum((q[i]-((1.0-gamma)*QuantumRange))/gamma);\n          }\n        }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n\n  return(status);\n}\n\nstatic inline CompressionType ConvertPSDCompression(\n  PSDCompressionType compression)\n{\n  switch (compression)\n  {\n    case RLE:\n      return RLECompression;\n    case ZipWithPrediction:\n    case ZipWithoutPrediction:\n      return ZipCompression;\n    default:\n      return NoCompression;\n  }\n}\n\nstatic MagickBooleanType ApplyPSDLayerOpacity(Image *image,Quantum opacity,\n  MagickBooleanType revert,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  applying layer opacity %.20g\", (double) opacity);\n  if (opacity == OpaqueAlpha)\n    return(MagickTrue);\n  if (image->alpha_trait != BlendPixelTrait)\n    (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n  status=MagickTrue;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n#pragma omp parallel for schedule(static) shared(status) \\\n  magick_number_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    Quantum\n      *magick_restrict q;\n\n    ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (revert == MagickFalse)\n        SetPixelAlpha(image,ClampToQuantum(QuantumScale*\n          GetPixelAlpha(image,q)*opacity),q);\n      else if (opacity > 0)\n        SetPixelAlpha(image,ClampToQuantum((double) QuantumRange*\n          GetPixelAlpha(image,q)/(MagickRealType) opacity),q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n\n  return(status);\n}\n\nstatic MagickBooleanType ApplyPSDOpacityMask(Image *image,const Image *mask,\n  Quantum background,MagickBooleanType revert,ExceptionInfo *exception)\n{\n  Image\n    *complete_mask;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    color;\n\n  ssize_t\n    y;\n\n  if (image->alpha_trait == UndefinedPixelTrait)\n    return(MagickTrue);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  applying opacity mask\");\n  complete_mask=CloneImage(image,0,0,MagickTrue,exception);\n  if (complete_mask == (Image *) NULL)\n    return(MagickFalse);\n  complete_mask->alpha_trait=BlendPixelTrait;\n  GetPixelInfo(complete_mask,&color);\n  color.red=(MagickRealType) background;\n  (void) SetImageColor(complete_mask,&color,exception);\n  status=CompositeImage(complete_mask,mask,OverCompositeOp,MagickTrue,\n    mask->page.x-image->page.x,mask->page.y-image->page.y,exception);\n  if (status == MagickFalse)\n    {\n      complete_mask=DestroyImage(complete_mask);\n      return(status);\n    }\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n#pragma omp parallel for schedule(static) shared(status) \\\n  magick_number_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    Quantum\n      *magick_restrict q;\n\n    Quantum\n      *p;\n\n    ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    p=GetAuthenticPixels(complete_mask,0,y,complete_mask->columns,1,exception);\n    if ((q == (Quantum *) NULL) || (p == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      MagickRealType\n        alpha,\n        intensity;\n\n      alpha=(MagickRealType) GetPixelAlpha(image,q);\n      intensity=GetPixelIntensity(complete_mask,p);\n      if (revert == MagickFalse)\n        SetPixelAlpha(image,ClampToQuantum(intensity*(QuantumScale*alpha)),q);\n      else if (intensity > 0)\n        SetPixelAlpha(image,ClampToQuantum((alpha/intensity)*QuantumRange),q);\n      q+=GetPixelChannels(image);\n      p+=GetPixelChannels(complete_mask);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  complete_mask=DestroyImage(complete_mask);\n  return(status);\n}\n\nstatic void PreservePSDOpacityMask(Image *image,LayerInfo* layer_info,\n  ExceptionInfo *exception)\n{\n  char\n    *key;\n\n  RandomInfo\n    *random_info;\n\n  StringInfo\n    *key_info;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  preserving opacity mask\");\n  random_info=AcquireRandomInfo();\n  key_info=GetRandomKey(random_info,2+1);\n  key=(char *) GetStringInfoDatum(key_info);\n  key[8]=(char) layer_info->mask.background;\n  key[9]='\\0';\n  layer_info->mask.image->page.x+=layer_info->page.x;\n  layer_info->mask.image->page.y+=layer_info->page.y;\n  (void) SetImageRegistry(ImageRegistryType,(const char *) key,\n    layer_info->mask.image,exception);\n  (void) SetImageArtifact(layer_info->image,\"psd:opacity-mask\",\n    (const char *) key);\n  key_info=DestroyStringInfo(key_info);\n  random_info=DestroyRandomInfo(random_info);\n}\n\nstatic ssize_t DecodePSDPixels(const size_t number_compact_pixels,\n  const unsigned char *compact_pixels,const ssize_t depth,\n  const size_t number_pixels,unsigned char *pixels)\n{\n#define CheckNumberCompactPixels \\\n  if (packets == 0) \\\n    return(i); \\\n  packets--\n\n#define CheckNumberPixels(count) \\\n  if (((ssize_t) i + count) > (ssize_t) number_pixels) \\\n    return(i); \\\n  i+=count\n\n  int\n    pixel;\n\n  ssize_t\n    i,\n    j;\n\n  size_t\n    length;\n\n  ssize_t\n    packets;\n\n  packets=(ssize_t) number_compact_pixels;\n  for (i=0; (packets > 1) && (i < (ssize_t) number_pixels); )\n  {\n    packets--;\n    length=(size_t) (*compact_pixels++);\n    if (length == 128)\n      continue;\n    if (length > 128)\n      {\n        length=256-length+1;\n        CheckNumberCompactPixels;\n        pixel=(*compact_pixels++);\n        for (j=0; j < (ssize_t) length; j++)\n        {\n          switch (depth)\n          {\n            case 1:\n            {\n              CheckNumberPixels(8);\n              *pixels++=(pixel >> 7) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 6) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 5) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 4) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 3) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 2) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 1) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 0) & 0x01 ? 0U : 255U;\n              break;\n            }\n            case 2:\n            {\n              CheckNumberPixels(4);\n              *pixels++=(unsigned char) ((pixel >> 6) & 0x03);\n              *pixels++=(unsigned char) ((pixel >> 4) & 0x03);\n              *pixels++=(unsigned char) ((pixel >> 2) & 0x03);\n              *pixels++=(unsigned char) ((pixel & 0x03) & 0x03);\n              break;\n            }\n            case 4:\n            {\n              CheckNumberPixels(2);\n              *pixels++=(unsigned char) ((pixel >> 4) & 0xff);\n              *pixels++=(unsigned char) ((pixel & 0x0f) & 0xff);\n              break;\n            }\n            default:\n            {\n              CheckNumberPixels(1);\n              *pixels++=(unsigned char) pixel;\n              break;\n            }\n          }\n        }\n        continue;\n      }\n    length++;\n    for (j=0; j < (ssize_t) length; j++)\n    {\n      CheckNumberCompactPixels;\n      switch (depth)\n      {\n        case 1:\n        {\n          CheckNumberPixels(8);\n          *pixels++=(*compact_pixels >> 7) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 6) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 5) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 4) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 3) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 2) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 1) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 0) & 0x01 ? 0U : 255U;\n          break;\n        }\n        case 2:\n        {\n          CheckNumberPixels(4);\n          *pixels++=(*compact_pixels >> 6) & 0x03;\n          *pixels++=(*compact_pixels >> 4) & 0x03;\n          *pixels++=(*compact_pixels >> 2) & 0x03;\n          *pixels++=(*compact_pixels & 0x03) & 0x03;\n          break;\n        }\n        case 4:\n        {\n          CheckNumberPixels(2);\n          *pixels++=(*compact_pixels >> 4) & 0xff;\n          *pixels++=(*compact_pixels & 0x0f) & 0xff;\n          break;\n        }\n        default:\n        {\n          CheckNumberPixels(1);\n          *pixels++=(*compact_pixels);\n          break;\n        }\n      }\n      compact_pixels++;\n    }\n  }\n  return(i);\n}\n\nstatic inline LayerInfo *DestroyLayerInfo(LayerInfo *layer_info,\n  const ssize_t number_layers)\n{\n  ssize_t\n    i;\n\n  for (i=0; i<number_layers; i++)\n  {\n    if (layer_info[i].image != (Image *) NULL)\n      layer_info[i].image=DestroyImage(layer_info[i].image);\n    if (layer_info[i].mask.image != (Image *) NULL)\n      layer_info[i].mask.image=DestroyImage(layer_info[i].mask.image);\n    if (layer_info[i].info != (StringInfo *) NULL)\n      layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n  }\n\n  return (LayerInfo *) RelinquishMagickMemory(layer_info);\n}\n\nstatic inline size_t GetPSDPacketSize(const Image *image)\n{\n  if (image->storage_class == PseudoClass)\n    {\n      if (image->colors > 256)\n        return(2);\n    }\n  if (image->depth > 16)\n    return(4);\n  if (image->depth > 8)\n    return(2);\n\n  return(1);\n}\n\nstatic inline MagickSizeType GetPSDSize(const PSDInfo *psd_info,Image *image)\n{\n  if (psd_info->version == 1)\n    return((MagickSizeType) ReadBlobLong(image));\n  return((MagickSizeType) ReadBlobLongLong(image));\n}\n\nstatic inline size_t GetPSDRowSize(Image *image)\n{\n  if (image->depth == 1)\n    return(((image->columns+7)/8)*GetPSDPacketSize(image));\n  else\n    return(image->columns*GetPSDPacketSize(image));\n}\n\nstatic const char *ModeToString(PSDImageType type)\n{\n  switch (type)\n  {\n    case BitmapMode: return \"Bitmap\";\n    case GrayscaleMode: return \"Grayscale\";\n    case IndexedMode: return \"Indexed\";\n    case RGBMode: return \"RGB\";\n    case CMYKMode:  return \"CMYK\";\n    case MultichannelMode: return \"Multichannel\";\n    case DuotoneMode: return \"Duotone\";\n    case LabMode: return \"L*A*B\";\n    default: return \"unknown\";\n  }\n}\n\nstatic MagickBooleanType NegateCMYK(Image *image,ExceptionInfo *exception)\n{\n  ChannelType\n    channel_mask;\n\n  MagickBooleanType\n    status;\n\n  channel_mask=SetImageChannelMask(image,(ChannelType)(AllChannels &~\n    AlphaChannel));\n  status=NegateImage(image,MagickFalse,exception);\n  (void) SetImageChannelMask(image,channel_mask);\n  return(status);\n}\n\nstatic StringInfo *ParseImageResourceBlocks(PSDInfo *psd_info,Image *image,\n  const unsigned char *blocks,size_t length)\n{\n  const unsigned char\n    *p;\n\n  ssize_t\n    offset;\n\n  StringInfo\n    *profile;\n\n  unsigned char\n    name_length;\n\n  unsigned int\n    count;\n\n  unsigned short\n    id,\n    short_sans;\n\n  if (length < 16)\n    return((StringInfo *) NULL);\n  profile=BlobToStringInfo((const unsigned char *) NULL,length);\n  SetStringInfoDatum(profile,blocks);\n  SetStringInfoName(profile,\"8bim\");\n  for (p=blocks; (p >= blocks) && (p < (blocks+length-7)); )\n  {\n    if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      break;\n    p+=4;\n    p=PushShortPixel(MSBEndian,p,&id);\n    p=PushCharPixel(p,&name_length);\n    if ((name_length % 2) == 0)\n      name_length++;\n    p+=name_length;\n    if (p > (blocks+length-4))\n      break;\n    p=PushLongPixel(MSBEndian,p,&count);\n    offset=(ssize_t) count;\n    if (((p+offset) < blocks) || ((p+offset) > (blocks+length)))\n      break;\n    switch (id)\n    {\n      case 0x03ed:\n      {\n        unsigned short\n          resolution;\n\n        /*\n          Resolution info.\n        */\n        if (offset < 16)\n          break;\n        p=PushShortPixel(MSBEndian,p,&resolution);\n        image->resolution.x=(double) resolution;\n        (void) FormatImageProperty(image,\"tiff:XResolution\",\"%*g\",\n          GetMagickPrecision(),image->resolution.x);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        p=PushShortPixel(MSBEndian,p,&resolution);\n        image->resolution.y=(double) resolution;\n        (void) FormatImageProperty(image,\"tiff:YResolution\",\"%*g\",\n          GetMagickPrecision(),image->resolution.y);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        image->units=PixelsPerInchResolution;\n        break;\n      }\n      case 0x0421:\n      {\n        if ((offset > 4) && (*(p+4) == 0))\n          psd_info->has_merged_image=MagickFalse;\n        p+=offset;\n        break;\n      }\n      default:\n      {\n        p+=offset;\n        break;\n      }\n    }\n    if ((offset & 0x01) != 0)\n      p++;\n  }\n  return(profile);\n}\n\nstatic CompositeOperator PSDBlendModeToCompositeOperator(const char *mode)\n{\n  if (mode == (const char *) NULL)\n    return(OverCompositeOp);\n  if (LocaleNCompare(mode,\"norm\",4) == 0)\n    return(OverCompositeOp);\n  if (LocaleNCompare(mode,\"mul \",4) == 0)\n    return(MultiplyCompositeOp);\n  if (LocaleNCompare(mode,\"diss\",4) == 0)\n    return(DissolveCompositeOp);\n  if (LocaleNCompare(mode,\"diff\",4) == 0)\n    return(DifferenceCompositeOp);\n  if (LocaleNCompare(mode,\"dark\",4) == 0)\n    return(DarkenCompositeOp);\n  if (LocaleNCompare(mode,\"lite\",4) == 0)\n    return(LightenCompositeOp);\n  if (LocaleNCompare(mode,\"hue \",4) == 0)\n    return(HueCompositeOp);\n  if (LocaleNCompare(mode,\"sat \",4) == 0)\n    return(SaturateCompositeOp);\n  if (LocaleNCompare(mode,\"colr\",4) == 0)\n    return(ColorizeCompositeOp);\n  if (LocaleNCompare(mode,\"lum \",4) == 0)\n    return(LuminizeCompositeOp);\n  if (LocaleNCompare(mode,\"scrn\",4) == 0)\n    return(ScreenCompositeOp);\n  if (LocaleNCompare(mode,\"over\",4) == 0)\n    return(OverlayCompositeOp);\n  if (LocaleNCompare(mode,\"hLit\",4) == 0)\n    return(HardLightCompositeOp);\n  if (LocaleNCompare(mode,\"sLit\",4) == 0)\n    return(SoftLightCompositeOp);\n  if (LocaleNCompare(mode,\"smud\",4) == 0)\n    return(ExclusionCompositeOp);\n  if (LocaleNCompare(mode,\"div \",4) == 0)\n    return(ColorDodgeCompositeOp);\n  if (LocaleNCompare(mode,\"idiv\",4) == 0)\n    return(ColorBurnCompositeOp);\n  if (LocaleNCompare(mode,\"lbrn\",4) == 0)\n    return(LinearBurnCompositeOp);\n  if (LocaleNCompare(mode,\"lddg\",4) == 0)\n    return(LinearDodgeCompositeOp);\n  if (LocaleNCompare(mode,\"lLit\",4) == 0)\n    return(LinearLightCompositeOp);\n  if (LocaleNCompare(mode,\"vLit\",4) == 0)\n    return(VividLightCompositeOp);\n  if (LocaleNCompare(mode,\"pLit\",4) == 0)\n    return(PinLightCompositeOp);\n  if (LocaleNCompare(mode,\"hMix\",4) == 0)\n    return(HardMixCompositeOp);\n  return(OverCompositeOp);\n}\n\nstatic inline ssize_t ReadPSDString(Image *image,char *p,const size_t length)\n{\n  ssize_t\n    count;\n\n  count=ReadBlob(image,length,(unsigned char *) p);\n  if ((count == (ssize_t) length) && (image->endian != MSBEndian))\n    {\n      char\n        *q;\n\n      q=p+length;\n      for(--q; p < q; ++p, --q)\n      {\n        *p = *p ^ *q,\n        *q = *p ^ *q,\n        *p = *p ^ *q;\n      }\n    }\n  return(count);\n}\n\nstatic inline void SetPSDPixel(Image *image,const PixelChannel channel,\n  const size_t packet_size,const Quantum pixel,Quantum *q,\n  ExceptionInfo *exception)\n{\n  if (image->storage_class == PseudoClass)\n    {\n      PixelInfo\n        *color;\n\n      ssize_t\n        index;\n\n      if (channel == GrayPixelChannel)\n        {\n          index=(ssize_t) pixel;\n          if (packet_size == 1)\n            index=(ssize_t) ScaleQuantumToChar((Quantum) index);\n          index=ConstrainColormapIndex(image,index,exception);\n          SetPixelIndex(image,(Quantum) index,q);\n        }\n      else\n        {\n          index=(ssize_t) GetPixelIndex(image,q);\n          index=ConstrainColormapIndex(image,index,exception);\n        }\n      color=image->colormap+index;\n      if (channel == AlphaPixelChannel)\n        color->alpha=(MagickRealType) pixel;\n      SetPixelViaPixelInfo(image,color,q);\n    }\n  else\n    SetPixelChannel(image,channel,pixel,q);\n}\n\nstatic MagickBooleanType ReadPSDChannelPixels(Image *image,const ssize_t row,\n  const PixelChannel channel,const unsigned char *pixels,\n  ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n\n  const unsigned char\n    *p;\n\n  Quantum\n    *q;\n\n  ssize_t\n    x;\n\n  size_t\n    packet_size;\n\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (Quantum *) NULL)\n    return MagickFalse;\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      if (packet_size == 2)\n        {\n          unsigned short\n            nibble;\n\n          p=PushShortPixel(MSBEndian,p,&nibble);\n          pixel=ScaleShortToQuantum(nibble);\n        }\n      else\n        {\n          MagickFloatType\n            nibble;\n\n          p=PushFloatPixel(MSBEndian,p,&nibble);\n          pixel=ClampToQuantum(((MagickRealType) QuantumRange)*nibble);\n        }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channel,packet_size,pixel,q,exception);\n        q+=GetPixelChannels(image);\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n\n        number_bits=(ssize_t) image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit = 0; bit < (ssize_t) number_bits; bit++)\n        {\n          SetPSDPixel(image,channel,packet_size,(((unsigned char) pixel)\n            & (0x01 << (7-bit))) != 0 ? 0 : QuantumRange,q,exception);\n          q+=GetPixelChannels(image);\n          x++;\n        }\n        if (x != (ssize_t) image->columns)\n          x--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}\n\nstatic MagickBooleanType ReadPSDChannelRaw(Image *image,const PixelChannel channel,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  size_t\n    row_size;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"      layer data is RAW\");\n\n  row_size=GetPSDRowSize(image);\n  pixels=(unsigned char *) AcquireQuantumMemory(row_size,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  (void) memset(pixels,0,row_size*sizeof(*pixels));\n\n  status=MagickTrue;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    status=MagickFalse;\n\n    count=ReadBlob(image,row_size,pixels);\n    if (count != (ssize_t) row_size)\n      break;\n\n    status=ReadPSDChannelPixels(image,y,channel,pixels,exception);\n    if (status == MagickFalse)\n      break;\n  }\n\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  return(status);\n}\n\nstatic inline MagickOffsetType *ReadPSDRLESizes(Image *image,\n  const PSDInfo *psd_info,const size_t size)\n{\n  MagickOffsetType\n    *sizes;\n\n  ssize_t\n    y;\n\n  sizes=(MagickOffsetType *) AcquireQuantumMemory(size,sizeof(*sizes));\n  if(sizes != (MagickOffsetType *) NULL)\n    {\n      for (y=0; y < (ssize_t) size; y++)\n      {\n        if (psd_info->version == 1)\n          sizes[y]=(MagickOffsetType) ReadBlobShort(image);\n        else\n          sizes[y]=(MagickOffsetType) ReadBlobLong(image);\n      }\n    }\n  return sizes;\n}\n\nstatic MagickBooleanType ReadPSDChannelRLE(Image *image,\n  const PixelChannel channel,MagickOffsetType *sizes,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  size_t\n    length,\n    row_size;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *compact_pixels,\n    *pixels;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"      layer data is RLE compressed\");\n\n  row_size=GetPSDRowSize(image);\n  pixels=(unsigned char *) AcquireQuantumMemory(row_size,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n\n  length=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n    if ((MagickOffsetType) length < sizes[y])\n      length=(size_t) sizes[y];\n\n  if (length > (row_size+2048)) /* arbitrary number */\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowBinaryException(ResourceLimitError,\"InvalidLength\",image->filename);\n    }\n\n  compact_pixels=(unsigned char *) AcquireQuantumMemory(length,sizeof(*pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n\n  (void) memset(compact_pixels,0,length*sizeof(*compact_pixels));\n\n  status=MagickTrue;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    status=MagickFalse;\n\n    count=ReadBlob(image,(size_t) sizes[y],compact_pixels);\n    if (count != (ssize_t) sizes[y])\n      break;\n\n    count=DecodePSDPixels((size_t) sizes[y],compact_pixels,\n      (ssize_t) (image->depth == 1 ? 123456 : image->depth),row_size,pixels);\n    if (count != (ssize_t) row_size)\n      break;\n\n    status=ReadPSDChannelPixels(image,y,channel,pixels,exception);\n    if (status == MagickFalse)\n      break;\n  }\n\n  compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  return(status);\n}\n\n#ifdef MAGICKCORE_ZLIB_DELEGATE\nstatic void Unpredict8Bit(const Image *image,unsigned char *pixels,\n  const size_t count,const size_t row_size)\n{\n  unsigned char\n    *p;\n\n  size_t\n    length,\n    remaining;\n\n  p=pixels;\n  remaining=count;\n  while (remaining > 0)\n  {\n    length=image->columns;\n    while (--length)\n    {\n      *(p+1)+=*p;\n      p++;\n    }\n    p++;\n    remaining-=row_size;\n  }\n}\n\nstatic void Unpredict16Bit(const Image *image,unsigned char *pixels,\n  const size_t count,const size_t row_size)\n{\n  unsigned char\n    *p;\n\n  size_t\n    length,\n    remaining;\n\n  p=pixels;\n  remaining=count;\n  while (remaining > 0)\n  {\n    length=image->columns;\n    while (--length)\n    {\n      p[2]+=p[0]+((p[1]+p[3]) >> 8);\n      p[3]+=p[1];\n      p+=2;\n    }\n    p+=2;\n    remaining-=row_size;\n  }\n}\n\nstatic void Unpredict32Bit(const Image *image,unsigned char *pixels,\n  unsigned char *output_pixels,const size_t row_size)\n{\n  unsigned char\n    *p,\n    *q;\n\n  ssize_t\n    y;\n\n  size_t\n    offset1,\n    offset2,\n    offset3,\n    remaining;\n\n  unsigned char\n    *start;\n\n  offset1=image->columns;\n  offset2=2*offset1;\n  offset3=3*offset1;\n  p=pixels;\n  q=output_pixels;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    start=p;\n    remaining=row_size;\n    while (--remaining)\n    {\n      *(p+1)+=*p;\n      p++;\n    }\n\n    p=start;\n    remaining=image->columns;\n    while (remaining--)\n    {\n      *(q++)=*p;\n      *(q++)=*(p+offset1);\n      *(q++)=*(p+offset2);\n      *(q++)=*(p+offset3);\n\n      p++;\n    }\n    p=start+row_size;\n  }\n}\n\nstatic MagickBooleanType ReadPSDChannelZip(Image *image,\n  const PixelChannel channel,const PSDCompressionType compression,\n  const size_t compact_size,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  unsigned char\n    *p;\n\n  size_t\n    count,\n    packet_size,\n    row_size;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *compact_pixels,\n    *pixels;\n\n  z_stream\n    stream;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"      layer data is ZIP compressed\");\n\n  if ((MagickSizeType) compact_size > GetBlobSize(image))\n    ThrowBinaryException(CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  compact_pixels=(unsigned char *) AcquireQuantumMemory(compact_size,\n    sizeof(*compact_pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n\n  packet_size=GetPSDPacketSize(image);\n  row_size=image->columns*packet_size;\n  count=image->rows*row_size;\n\n  pixels=(unsigned char *) AcquireQuantumMemory(count,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    {\n      compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  if (ReadBlob(image,compact_size,compact_pixels) != (ssize_t) compact_size)\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n      ThrowBinaryException(CorruptImageError,\"UnexpectedEndOfFile\",\n        image->filename);\n    }\n\n  memset(&stream,0,sizeof(stream));\n  stream.data_type=Z_BINARY;\n  stream.next_in=(Bytef *)compact_pixels;\n  stream.avail_in=(uInt) compact_size;\n  stream.next_out=(Bytef *)pixels;\n  stream.avail_out=(uInt) count;\n\n  if (inflateInit(&stream) == Z_OK)\n    {\n      int\n        ret;\n\n      while (stream.avail_out > 0)\n      {\n        ret=inflate(&stream,Z_SYNC_FLUSH);\n        if ((ret != Z_OK) && (ret != Z_STREAM_END))\n          {\n            (void) inflateEnd(&stream);\n            compact_pixels=(unsigned char *) RelinquishMagickMemory(\n              compact_pixels);\n            pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n            return(MagickFalse);\n          }\n        if (ret == Z_STREAM_END)\n          break;\n      }\n      (void) inflateEnd(&stream);\n    }\n\n  if (compression == ZipWithPrediction)\n    {\n      if (packet_size == 1)\n        Unpredict8Bit(image,pixels,count,row_size);\n      else if (packet_size == 2)\n        Unpredict16Bit(image,pixels,count,row_size);\n      else if (packet_size == 4)\n      {\n        unsigned char\n          *output_pixels;\n\n        output_pixels=(unsigned char *) AcquireQuantumMemory(count,\n          sizeof(*output_pixels));\n        if (pixels == (unsigned char *) NULL)\n          {\n            compact_pixels=(unsigned char *) RelinquishMagickMemory(\n              compact_pixels);\n            pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n            ThrowBinaryException(ResourceLimitError,\n              \"MemoryAllocationFailed\",image->filename);\n          }\n        Unpredict32Bit(image,pixels,output_pixels,row_size);\n        pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n        pixels=output_pixels;\n      }\n    }\n\n  status=MagickTrue;\n  p=pixels;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    status=ReadPSDChannelPixels(image,y,channel,p,exception);\n    if (status == MagickFalse)\n      break;\n\n    p+=row_size;\n  }\n\n  compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  return(status);\n}\n#endif\n\nstatic MagickBooleanType ReadPSDChannel(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,LayerInfo* layer_info,\n  const size_t channel_index,const PSDCompressionType compression,\n  ExceptionInfo *exception)\n{\n  Image\n    *channel_image,\n    *mask;\n\n  MagickOffsetType\n    end_offset,\n    offset;\n\n  MagickBooleanType\n    status;\n\n  PixelChannel\n    channel;\n\n  end_offset=(MagickOffsetType) layer_info->channel_info[channel_index].size-2;\n  if (layer_info->channel_info[channel_index].supported == MagickFalse)\n    {\n      (void) SeekBlob(image,end_offset,SEEK_CUR);\n      return(MagickTrue);\n    }\n  channel_image=image;\n  channel=layer_info->channel_info[channel_index].channel;\n  mask=(Image *) NULL;\n  if (channel == ReadMaskPixelChannel)\n    {\n      const char\n        *option;\n\n      /*\n        Ignore mask that is not a user supplied layer mask, if the mask is\n        disabled or if the flags have unsupported values.\n      */\n      option=GetImageOption(image_info,\"psd:preserve-opacity-mask\");\n      if ((layer_info->mask.flags > 2) || ((layer_info->mask.flags & 0x02) &&\n           (IsStringTrue(option) == MagickFalse)) ||\n           (layer_info->mask.page.width < 1) ||\n           (layer_info->mask.page.height < 1))\n        {\n          (void) SeekBlob(image,end_offset,SEEK_CUR);\n          return(MagickTrue);\n        }\n      mask=CloneImage(image,layer_info->mask.page.width,\n        layer_info->mask.page.height,MagickFalse,exception);\n      if (mask != (Image *) NULL)\n        {\n          (void) ResetImagePixels(mask,exception);\n          (void) SetImageType(mask,GrayscaleType,exception);\n          channel_image=mask;\n          channel=GrayPixelChannel;\n        }\n    }\n\n  offset=TellBlob(image);\n  status=MagickFalse;\n  switch(compression)\n  {\n    case Raw:\n      status=ReadPSDChannelRaw(channel_image,channel,exception);\n      break;\n    case RLE:\n      {\n        MagickOffsetType\n          *sizes;\n\n        sizes=ReadPSDRLESizes(channel_image,psd_info,channel_image->rows);\n        if (sizes == (MagickOffsetType *) NULL)\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        status=ReadPSDChannelRLE(channel_image,channel,sizes,exception);\n        sizes=(MagickOffsetType *) RelinquishMagickMemory(sizes);\n      }\n      break;\n    case ZipWithPrediction:\n    case ZipWithoutPrediction:\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n      status=ReadPSDChannelZip(channel_image,channel,compression,\n        (const size_t) end_offset,exception);\n#else\n      (void) ThrowMagickException(exception,GetMagickModule(),\n          MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\n            \"'%s' (ZLIB)\",image->filename);\n#endif\n      break;\n    default:\n      (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,\n        \"CompressionNotSupported\",\"'%.20g'\",(double) compression);\n      break;\n  }\n\n  (void) SeekBlob(image,offset+end_offset,SEEK_SET);\n  if (status == MagickFalse)\n    {\n      if (mask != (Image *) NULL)\n        (void) DestroyImage(mask);\n      ThrowBinaryException(CoderError,\"UnableToDecompressImage\",\n        image->filename);\n    }\n  if (mask != (Image *) NULL)\n    {\n      if (layer_info->mask.image != (Image *) NULL)\n        layer_info->mask.image=DestroyImage(layer_info->mask.image);\n      layer_info->mask.image=mask;\n    }\n  return(status);\n}\n\nstatic MagickBooleanType GetPixelChannelFromPsdIndex(const PSDInfo *psd_info,\n  ssize_t index,PixelChannel *channel)\n{\n  *channel=RedPixelChannel;\n  switch (psd_info->mode)\n  {\n    case BitmapMode:\n    case IndexedMode:\n    case GrayscaleMode:\n    {\n      if (index == 1)\n        index=-1;\n      else if (index > 1)\n        index=StartMetaPixelChannel+index-2;\n      break;\n    }\n    case LabMode:\n    case MultichannelMode:\n    case RGBMode:\n    {\n      if (index == 3)\n        index=-1;\n      else if (index > 3)\n        index=StartMetaPixelChannel+index-4;\n      break;\n    }\n    case CMYKMode:\n    {\n      if (index == 4)\n        index=-1;\n      else if (index > 4)\n        index=StartMetaPixelChannel+index-5;\n      break;\n    }\n  }\n  if ((index < -2) || (index >= MaxPixelChannels))\n    return(MagickFalse);\n  if (index == -1)\n    *channel=AlphaPixelChannel;\n  else if (index == -2)\n    *channel=ReadMaskPixelChannel;\n  else\n    *channel=(PixelChannel) index;\n  return(MagickTrue);\n}\n\nstatic void SetPsdMetaChannels(Image *image,const PSDInfo *psd_info,\n  const unsigned short channels,ExceptionInfo *exception)\n{\n  ssize_t\n    number_meta_channels;\n\n  number_meta_channels=(ssize_t) channels-psd_info->min_channels;\n  if (image->alpha_trait == BlendPixelTrait)\n    number_meta_channels--;\n  if (number_meta_channels > 0)\n    (void) SetPixelMetaChannels(image,(size_t) number_meta_channels,exception);\n}\n\nstatic MagickBooleanType ReadPSDLayer(Image *image,const ImageInfo *image_info,\n  const PSDInfo *psd_info,LayerInfo* layer_info,ExceptionInfo *exception)\n{\n  char\n    message[MagickPathExtent];\n\n  MagickBooleanType\n    status;\n\n  PSDCompressionType\n    compression;\n\n  ssize_t\n    j;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    setting up new layer image\");\n  if (psd_info->mode != IndexedMode)\n    (void) SetImageBackgroundColor(layer_info->image,exception);\n  layer_info->image->compose=PSDBlendModeToCompositeOperator(\n    layer_info->blendkey);\n  if (layer_info->visible == MagickFalse)\n    layer_info->image->compose=NoCompositeOp;\n  /*\n    Set up some hidden attributes for folks that need them.\n  */\n  (void) FormatLocaleString(message,MagickPathExtent,\"%.20g\",\n    (double) layer_info->page.x);\n  (void) SetImageArtifact(layer_info->image,\"psd:layer.x\",message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"%.20g\",\n    (double) layer_info->page.y);\n  (void) SetImageArtifact(layer_info->image,\"psd:layer.y\",message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"%.20g\",(double)\n    layer_info->opacity);\n  (void) SetImageArtifact(layer_info->image,\"psd:layer.opacity\",message);\n  (void) SetImageProperty(layer_info->image,\"label\",(char *) layer_info->name,\n    exception);\n\n  SetPsdMetaChannels(layer_info->image,psd_info,layer_info->channels,exception);\n  status=MagickTrue;\n  for (j=0; j < (ssize_t) layer_info->channels; j++)\n  {\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    reading data for channel %.20g\",(double) j);\n\n    compression=(PSDCompressionType) ReadBlobShort(layer_info->image);\n    layer_info->image->compression=ConvertPSDCompression(compression);\n\n    status=ReadPSDChannel(layer_info->image,image_info,psd_info,layer_info,\n      (size_t) j,compression,exception);\n\n    if (status == MagickFalse)\n      break;\n  }\n\n  if (status != MagickFalse)\n    status=ApplyPSDLayerOpacity(layer_info->image,layer_info->opacity,\n      MagickFalse,exception);\n\n  if ((status != MagickFalse) &&\n      (layer_info->image->colorspace == CMYKColorspace))\n    status=NegateCMYK(layer_info->image,exception);\n\n  if ((status != MagickFalse) && (layer_info->mask.image != (Image *) NULL))\n    {\n      const char\n        *option;\n\n      layer_info->mask.image->page.x=layer_info->mask.page.x;\n      layer_info->mask.image->page.y=layer_info->mask.page.y;\n      /* Do not composite the mask when it is disabled */\n      if ((layer_info->mask.flags & 0x02) == 0x02)\n        layer_info->mask.image->compose=NoCompositeOp;\n      else\n        status=ApplyPSDOpacityMask(layer_info->image,layer_info->mask.image,\n          layer_info->mask.background == 0 ? 0 : QuantumRange,MagickFalse,\n          exception);\n      option=GetImageOption(image_info,\"psd:preserve-opacity-mask\");\n      if (IsStringTrue(option) != MagickFalse)\n        PreservePSDOpacityMask(image,layer_info,exception);\n      layer_info->mask.image=DestroyImage(layer_info->mask.image);\n    }\n\n  return(status);\n}\n\nstatic MagickBooleanType CheckPSDChannels(const Image *image,\n  const PSDInfo *psd_info,LayerInfo *layer_info)\n{\n  int\n    channel_type;\n\n  size_t\n    blob_size;\n\n  ssize_t\n    i;\n\n  if (layer_info->channels < psd_info->min_channels)\n    return(MagickFalse);\n  channel_type=RedChannel;\n  if (psd_info->min_channels >= 3)\n    channel_type|=(GreenChannel | BlueChannel);\n  if (psd_info->min_channels >= 4)\n    channel_type|=BlackChannel;\n  blob_size=(size_t) GetBlobSize(image);\n  for (i=0; i < (ssize_t) layer_info->channels; i++)\n  {\n    PixelChannel\n      channel;\n\n    if (layer_info->channel_info[i].size >= blob_size)\n      return(MagickFalse);\n    if (layer_info->channel_info[i].supported == MagickFalse)\n      continue;\n    channel=layer_info->channel_info[i].channel;\n    if ((i == 0) && (psd_info->mode == IndexedMode) &&\n        (channel != RedPixelChannel))\n      return(MagickFalse);\n    if (channel == AlphaPixelChannel)\n      {\n        channel_type|=AlphaChannel;\n        continue;\n      }\n    if (channel == RedPixelChannel)\n      channel_type&=~RedChannel;\n    else if (channel == GreenPixelChannel)\n      channel_type&=~GreenChannel;\n    else if (channel == BluePixelChannel)\n      channel_type&=~BlueChannel;\n    else if (channel == BlackPixelChannel)\n      channel_type&=~BlackChannel;\n  }\n  if (channel_type == 0)\n    return(MagickTrue);\n  if ((channel_type == AlphaChannel) &&\n      (layer_info->channels >= psd_info->min_channels + 1))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic void AttachPSDLayers(Image *image,LayerInfo *layer_info,\n  ssize_t number_layers)\n{\n  ssize_t\n    i;\n\n  ssize_t\n    j;\n\n  for (i=0; i < number_layers; i++)\n  {\n    if (layer_info[i].image == (Image *) NULL)\n      {\n        for (j=i; j < number_layers - 1; j++)\n          layer_info[j] = layer_info[j+1];\n        number_layers--;\n        i--;\n      }\n  }\n  if (number_layers == 0)\n    {\n      layer_info=(LayerInfo *) RelinquishMagickMemory(layer_info);\n      return;\n    }\n  for (i=0; i < number_layers; i++)\n  {\n    if (i > 0)\n      layer_info[i].image->previous=layer_info[i-1].image;\n    if (i < (number_layers-1))\n      layer_info[i].image->next=layer_info[i+1].image;\n    layer_info[i].image->page=layer_info[i].page;\n  }\n  image->next=layer_info[0].image;\n  layer_info[0].image->previous=image;\n  layer_info=(LayerInfo *) RelinquishMagickMemory(layer_info);\n}\n\nstatic inline MagickBooleanType PSDSkipImage(const PSDInfo *psd_info,\n  const ImageInfo *image_info,const size_t index)\n{\n  if (psd_info->has_merged_image == MagickFalse)\n    return(MagickFalse);\n  if (image_info->number_scenes == 0)\n    return(MagickFalse);\n  if (index < image_info->scene)\n    return(MagickTrue);\n  if (index > image_info->scene+image_info->number_scenes-1)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic void CheckMergedImageAlpha(const PSDInfo *psd_info,Image *image)\n{\n  /*\n    The number of layers cannot be used to determine if the merged image\n    contains an alpha channel. So we enable it when we think we should.\n  */\n  if (((psd_info->mode == GrayscaleMode) && (psd_info->channels > 1)) ||\n      ((psd_info->mode == RGBMode) && (psd_info->channels > 3)) ||\n      ((psd_info->mode == CMYKMode) && (psd_info->channels > 4)))\n    image->alpha_trait=BlendPixelTrait;\n}\n\nstatic void ParseAdditionalInfo(LayerInfo *layer_info)\n{\n  char\n    key[5];\n\n  size_t\n    remaining_length;\n\n  unsigned char\n    *p;\n\n  unsigned int\n    size;\n\n  p=GetStringInfoDatum(layer_info->info);\n  remaining_length=GetStringInfoLength(layer_info->info);\n  while (remaining_length >= 12)\n  {\n    /* skip over signature */\n    p+=4;\n    key[0]=(char) (*p++);\n    key[1]=(char) (*p++);\n    key[2]=(char) (*p++);\n    key[3]=(char) (*p++);\n    key[4]='\\0';\n    size=(unsigned int) (*p++) << 24;\n    size|=(unsigned int) (*p++) << 16;\n    size|=(unsigned int) (*p++) << 8;\n    size|=(unsigned int) (*p++);\n    size=size & 0xffffffff;\n    remaining_length-=12;\n    if ((size_t) size > remaining_length)\n      break;\n    if (LocaleNCompare(key,\"luni\",sizeof(key)) == 0)\n      {\n        unsigned char\n          *name;\n\n        unsigned int\n          length;\n\n        length=(unsigned int) (*p++) << 24;\n        length|=(unsigned int) (*p++) << 16;\n        length|=(unsigned int) (*p++) << 8;\n        length|=(unsigned int) (*p++);\n        if (length * 2 > size - 4)\n          break;\n        if (sizeof(layer_info->name) <= length)\n          break;\n        name=layer_info->name;\n        while (length > 0)\n        {\n          /* Only ASCII strings are supported */\n          if (*p++ != '\\0')\n            break;\n          *name++=*p++;\n          length--;\n        }\n        if (length == 0)\n          *name='\\0';\n        break;\n      }\n    else\n      p+=size;\n    remaining_length-=(size_t) size;\n  }\n}\n\nstatic MagickSizeType GetLayerInfoSize(const PSDInfo *psd_info,Image *image)\n{\n  char\n    type[4];\n\n  MagickSizeType\n    size;\n\n  ssize_t\n    count;\n\n  size=GetPSDSize(psd_info,image);\n  if (size != 0)\n    return(size);\n  (void) ReadBlobLong(image);\n  count=ReadPSDString(image,type,4);\n  if ((count != 4) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n    return(0);\n  count=ReadPSDString(image,type,4);\n  if ((count == 4) && ((LocaleNCompare(type,\"Mt16\",4) == 0) ||\n      (LocaleNCompare(type,\"Mt32\",4) == 0) ||\n      (LocaleNCompare(type,\"Mtrn\",4) == 0)))\n    {\n      size=GetPSDSize(psd_info,image);\n      if (size != 0)\n        return(0);\n      image->alpha_trait=BlendPixelTrait;\n      count=ReadPSDString(image,type,4);\n      if ((count != 4) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n        return(0);\n      count=ReadPSDString(image,type,4);\n    }\n  if ((count == 4) && ((LocaleNCompare(type,\"Lr16\",4) == 0) ||\n      (LocaleNCompare(type,\"Lr32\",4) == 0)))\n    size=GetPSDSize(psd_info,image);\n  return(size);\n}\n\nstatic MagickBooleanType ReadPSDLayersInternal(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,\n  const MagickBooleanType skip_layers,ExceptionInfo *exception)\n{\n  char\n    type[4];\n\n  LayerInfo\n    *layer_info;\n\n  MagickSizeType\n    size;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    count,\n    index,\n    i,\n    j,\n    number_layers;\n\n  size=GetLayerInfoSize(psd_info,image);\n  if (size == 0)\n    {\n      CheckMergedImageAlpha(psd_info,image);\n      return(MagickTrue);\n    }\n\n  layer_info=(LayerInfo *) NULL;\n  number_layers=(ssize_t) ReadBlobSignedShort(image);\n\n  if (number_layers < 0)\n    {\n      /*\n        The first alpha channel in the merged result contains the\n        transparency data for the merged result.\n      */\n      number_layers=MagickAbsoluteValue(number_layers);\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  negative layer count corrected for\");\n      image->alpha_trait=BlendPixelTrait;\n    }\n\n  /*\n    We only need to know if the image has an alpha channel\n  */\n  if (skip_layers != MagickFalse)\n    return(MagickTrue);\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  image contains %.20g layers\",(double) number_layers);\n\n  if (number_layers == 0)\n    ThrowBinaryException(CorruptImageError,\"InvalidNumberOfLayers\",\n      image->filename);\n\n  layer_info=(LayerInfo *) AcquireQuantumMemory((size_t) number_layers,\n    sizeof(*layer_info));\n  if (layer_info == (LayerInfo *) NULL)\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  allocation of LayerInfo failed\");\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  (void) memset(layer_info,0,(size_t) number_layers*sizeof(*layer_info));\n\n  for (i=0; i < number_layers; i++)\n  {\n    ssize_t\n      top,\n      left,\n      bottom,\n      right;\n\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  reading layer #%.20g\",(double) i+1);\n    top=(ssize_t) ReadBlobSignedLong(image);\n    left=(ssize_t) ReadBlobSignedLong(image);\n    bottom=(ssize_t) ReadBlobSignedLong(image);\n    right=(ssize_t) ReadBlobSignedLong(image);\n    if ((right < left) || (bottom < top))\n      {\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n        ThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\n          image->filename);\n      }\n    layer_info[i].page.y=top;\n    layer_info[i].page.x=left;\n    layer_info[i].page.width=(size_t) (right-left);\n    layer_info[i].page.height=(size_t) (bottom-top);\n    layer_info[i].channels=ReadBlobShort(image);\n    if (layer_info[i].channels > MaxPSDChannels)\n      {\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n        ThrowBinaryException(CorruptImageError,\"MaximumChannelsExceeded\",\n          image->filename);\n      }\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g\",\n        (double) layer_info[i].page.x,(double) layer_info[i].page.y,\n        (double) layer_info[i].page.height,(double)\n        layer_info[i].page.width,(double) layer_info[i].channels);\n    for (j=0; j < (ssize_t) layer_info[i].channels; j++)\n    {\n      layer_info[i].channel_info[j].supported=GetPixelChannelFromPsdIndex(\n        psd_info,(ssize_t) ReadBlobSignedShort(image),\n        &layer_info[i].channel_info[j].channel);\n      layer_info[i].channel_info[j].size=(size_t) GetPSDSize(psd_info,\n        image);\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    channel[%.20g]: type=%.20g, size=%.20g\",(double) j,\n          (double) layer_info[i].channel_info[j].channel,\n          (double) layer_info[i].channel_info[j].size);\n    }\n    if (CheckPSDChannels(image,psd_info,&layer_info[i]) == MagickFalse)\n      {\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n        ThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\n          image->filename);\n      }\n    count=ReadPSDString(image,type,4);\n    if ((count != 4) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  layer type was %.4s instead of 8BIM\", type);\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n        ThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\n          image->filename);\n      }\n    count=ReadPSDString(image,layer_info[i].blendkey,4);\n    if (count != 4)\n      {\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n        ThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\n          image->filename);\n      }\n    layer_info[i].opacity=(Quantum) ScaleCharToQuantum((unsigned char)\n      ReadBlobByte(image));\n    layer_info[i].clipping=(unsigned char) ReadBlobByte(image);\n    layer_info[i].flags=(unsigned char) ReadBlobByte(image);\n    layer_info[i].visible=!(layer_info[i].flags & 0x02);\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s\",\n        layer_info[i].blendkey,(double) layer_info[i].opacity,\n        layer_info[i].clipping ? \"true\" : \"false\",layer_info[i].flags,\n        layer_info[i].visible ? \"true\" : \"false\");\n    (void) ReadBlobByte(image);  /* filler */\n\n    size=ReadBlobLong(image);\n    if (size != 0)\n      {\n        MagickSizeType\n          combined_length,\n          length;\n\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    layer contains additional info\");\n        length=ReadBlobLong(image);\n        combined_length=length+4;\n        if (length != 0)\n          {\n            /*\n              Layer mask info.\n            */\n            layer_info[i].mask.page.y=(ssize_t) ReadBlobSignedLong(image);\n            layer_info[i].mask.page.x=(ssize_t) ReadBlobSignedLong(image);\n            layer_info[i].mask.page.height=(size_t)\n              (ReadBlobSignedLong(image)-layer_info[i].mask.page.y);\n            layer_info[i].mask.page.width=(size_t) (\n              ReadBlobSignedLong(image)-layer_info[i].mask.page.x);\n            layer_info[i].mask.background=(unsigned char) ReadBlobByte(\n              image);\n            layer_info[i].mask.flags=(unsigned char) ReadBlobByte(image);\n            if (!(layer_info[i].mask.flags & 0x01))\n              {\n                layer_info[i].mask.page.y=layer_info[i].mask.page.y-\n                  layer_info[i].page.y;\n                layer_info[i].mask.page.x=layer_info[i].mask.page.x-\n                  layer_info[i].page.x;\n              }\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g\",\n                (double) layer_info[i].mask.page.x,(double)\n                layer_info[i].mask.page.y,(double)\n                layer_info[i].mask.page.width,(double)\n                layer_info[i].mask.page.height,(double) ((MagickOffsetType)\n                length)-18);\n            /*\n              Skip over the rest of the layer mask information.\n            */\n            if (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)\n              {\n                layer_info=DestroyLayerInfo(layer_info,number_layers);\n                ThrowBinaryException(CorruptImageError,\n                  \"UnexpectedEndOfFile\",image->filename);\n              }\n          }\n        length=ReadBlobLong(image);\n        combined_length+=length+4;\n        if (length != 0)\n          {\n            /*\n              Layer blending ranges info.\n            */\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      layer blending ranges: length=%.20g\",(double)\n                ((MagickOffsetType) length));\n            if (DiscardBlobBytes(image,length) == MagickFalse)\n              {\n                layer_info=DestroyLayerInfo(layer_info,number_layers);\n                ThrowBinaryException(CorruptImageError,\n                  \"UnexpectedEndOfFile\",image->filename);\n              }\n          }\n        /*\n          Layer name.\n        */\n        length=(MagickSizeType) (unsigned char) ReadBlobByte(image);\n        combined_length+=length+1;\n        if (length > 0)\n          (void) ReadBlob(image,(size_t) length++,layer_info[i].name);\n        layer_info[i].name[length]='\\0';\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"      layer name: %s\",layer_info[i].name);\n        if ((length % 4) != 0)\n          {\n            length=4-(length % 4);\n            combined_length+=length;\n            /* Skip over the padding of the layer name */\n            if (DiscardBlobBytes(image,length) == MagickFalse)\n              {\n                layer_info=DestroyLayerInfo(layer_info,number_layers);\n                ThrowBinaryException(CorruptImageError,\n                  \"UnexpectedEndOfFile\",image->filename);\n              }\n          }\n        length=(MagickSizeType) size-combined_length;\n        if (length > 0)\n          {\n            unsigned char\n              *info;\n\n            if (length > GetBlobSize(image))\n              {\n                layer_info=DestroyLayerInfo(layer_info,number_layers);\n                ThrowBinaryException(CorruptImageError,\n                  \"InsufficientImageDataInFile\",image->filename);\n              }\n            layer_info[i].info=AcquireStringInfo((const size_t) length);\n            info=GetStringInfoDatum(layer_info[i].info);\n            (void) ReadBlob(image,(const size_t) length,info);\n            ParseAdditionalInfo(&layer_info[i]);\n          }\n      }\n  }\n\n  for (i=0; i < number_layers; i++)\n  {\n    if ((layer_info[i].page.width == 0) || (layer_info[i].page.height == 0))\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"      layer data is empty\");\n        if (layer_info[i].info != (StringInfo *) NULL)\n          layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n        continue;\n      }\n\n    /*\n      Allocate layered image.\n    */\n    layer_info[i].image=CloneImage(image,layer_info[i].page.width,\n      layer_info[i].page.height,MagickFalse,exception);\n    if (layer_info[i].image == (Image *) NULL)\n      {\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  allocation of image for layer %.20g failed\",(double) i);\n        ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n          image->filename);\n      }\n    for (j=0; j < (ssize_t) layer_info[i].channels; j++)\n    {\n      if (layer_info[i].channel_info[j].channel == AlphaPixelChannel)\n        {\n          layer_info[i].image->alpha_trait=BlendPixelTrait;\n          break;\n        }\n    }\n    if (layer_info[i].info != (StringInfo *) NULL)\n      {\n        (void) SetImageProfile(layer_info[i].image,\"psd:additional-info\",\n          layer_info[i].info,exception);\n        layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n      }\n  }\n  if (image_info->ping != MagickFalse)\n    {\n      AttachPSDLayers(image,layer_info,number_layers);\n      return(MagickTrue);\n    }\n  status=MagickTrue;\n  index=0;\n  for (i=0; i < number_layers; i++)\n  {\n    if ((layer_info[i].image == (Image *) NULL) ||\n        (PSDSkipImage(psd_info, image_info,++index) != MagickFalse))\n      {\n        for (j=0; j < (ssize_t) layer_info[i].channels; j++)\n        {\n          if (DiscardBlobBytes(image,(MagickSizeType)\n              layer_info[i].channel_info[j].size) == MagickFalse)\n            {\n              layer_info=DestroyLayerInfo(layer_info,number_layers);\n              ThrowBinaryException(CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n            }\n        }\n        continue;\n      }\n\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  reading data for layer %.20g\",(double) i);\n\n    status=ReadPSDLayer(image,image_info,psd_info,&layer_info[i],\n      exception);\n    if (status == MagickFalse)\n      break;\n\n    status=SetImageProgress(image,LoadImagesTag,(MagickOffsetType) i,\n      (MagickSizeType) number_layers);\n    if (status == MagickFalse)\n      break;\n  }\n\n  if (status != MagickFalse)\n    AttachPSDLayers(image,layer_info,number_layers);\n  else\n    layer_info=DestroyLayerInfo(layer_info,number_layers);\n\n  return(status);\n}\n\nModuleExport MagickBooleanType ReadPSDLayers(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  status=IsRightsAuthorized(CoderPolicyDomain,ReadPolicyRights,\"PSD\");\n  if (status == MagickFalse)\n    return(MagickTrue);\n  return(ReadPSDLayersInternal(image,image_info,psd_info,MagickFalse,\n    exception));\n}\n\nstatic MagickBooleanType ReadPSDMergedImage(const ImageInfo *image_info,\n  Image *image,const PSDInfo *psd_info,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    *sizes;\n\n  MagickBooleanType\n    status;\n\n  PSDCompressionType\n    compression;\n\n  ssize_t\n    i;\n\n  if ((image_info->number_scenes != 0) && (image_info->scene != 0))\n    return(MagickTrue);\n  compression=(PSDCompressionType) ReadBlobMSBShort(image);\n  image->compression=ConvertPSDCompression(compression);\n\n  if (compression != Raw && compression != RLE)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        TypeWarning,\"CompressionNotSupported\",\"'%.20g'\",(double) compression);\n      return(MagickFalse);\n    }\n\n  sizes=(MagickOffsetType *) NULL;\n  if (compression == RLE)\n    {\n      sizes=ReadPSDRLESizes(image,psd_info,image->rows*psd_info->channels);\n      if (sizes == (MagickOffsetType *) NULL)\n        ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n          image->filename);\n    }\n\n  SetPsdMetaChannels(image,psd_info,psd_info->channels,exception);\n  status=MagickTrue;\n  for (i=0; i < (ssize_t) psd_info->channels; i++)\n  {\n    PixelChannel\n      channel;\n\n    status=GetPixelChannelFromPsdIndex(psd_info,i,&channel);\n    if (status == MagickFalse)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageError,\"MaximumChannelsExceeded\",\"'%.20g'\",(double) i);\n        break;\n      }\n\n    if (compression == RLE)\n      status=ReadPSDChannelRLE(image,channel,sizes+(i*image->rows),exception);\n    else\n      status=ReadPSDChannelRaw(image,channel,exception);\n\n    if (status != MagickFalse)\n      status=SetImageProgress(image,LoadImagesTag,(MagickOffsetType) i,\n        psd_info->channels);\n\n    if (status == MagickFalse)\n      break;\n  }\n\n  if ((status != MagickFalse) && (image->colorspace == CMYKColorspace))\n    status=NegateCMYK(image,exception);\n\n  if (status != MagickFalse)\n    status=CorrectPSDAlphaBlend(image_info,image,exception);\n\n  sizes=(MagickOffsetType *) RelinquishMagickMemory(sizes);\n\n  return(status);\n}\n\nstatic Image *ReadPSDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    skip_layers;\n\n  MagickOffsetType\n    offset;\n\n  MagickSizeType\n    length;\n\n  MagickBooleanType\n    status;\n\n  PSDInfo\n    psd_info;\n\n  ssize_t\n    i;\n\n  size_t\n    image_list_length;\n\n  ssize_t\n    count;\n\n  StringInfo\n    *profile;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read image header.\n  */\n  image->endian=MSBEndian;\n  count=ReadBlob(image,4,(unsigned char *) psd_info.signature);\n  psd_info.version=ReadBlobMSBShort(image);\n  if ((count != 4) || (LocaleNCompare(psd_info.signature,\"8BPS\",4) != 0) ||\n      ((psd_info.version != 1) && (psd_info.version != 2)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  (void) ReadBlob(image,6,psd_info.reserved);\n  psd_info.channels=ReadBlobMSBShort(image);\n  if (psd_info.channels < 1)\n    ThrowReaderException(CorruptImageError,\"MissingImageChannel\");\n  if (psd_info.channels > MaxPSDChannels)\n    ThrowReaderException(CorruptImageError,\"MaximumChannelsExceeded\");\n  psd_info.rows=ReadBlobMSBLong(image);\n  psd_info.columns=ReadBlobMSBLong(image);\n  if ((psd_info.version == 1) && ((psd_info.rows > 30000) ||\n      (psd_info.columns > 30000)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  psd_info.depth=ReadBlobMSBShort(image);\n  if ((psd_info.depth != 1) && (psd_info.depth != 8) &&\n      (psd_info.depth != 16) && (psd_info.depth != 32))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  psd_info.mode=ReadBlobMSBShort(image);\n  if ((psd_info.mode == IndexedMode) && (psd_info.channels > 3))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Image is %.20g x %.20g with channels=%.20g, depth=%.20g, mode=%s\",\n      (double) psd_info.columns,(double) psd_info.rows,(double)\n      psd_info.channels,(double) psd_info.depth,ModeToString((PSDImageType)\n      psd_info.mode));\n  if (EOFBlob(image) != MagickFalse)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Initialize image.\n  */\n  image->depth=psd_info.depth;\n  image->columns=psd_info.columns;\n  image->rows=psd_info.rows;\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  status=ResetImagePixels(image,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  psd_info.min_channels=3;\n  switch (psd_info.mode)\n  {\n    case LabMode:\n    {\n      (void) SetImageColorspace(image,LabColorspace,exception);\n      break;\n    }\n    case CMYKMode:\n    {\n      psd_info.min_channels=4;\n      (void) SetImageColorspace(image,CMYKColorspace,exception);\n      break;\n    }\n    case BitmapMode:\n    case GrayscaleMode:\n    case DuotoneMode:\n    {\n      if (psd_info.depth != 32)\n        {\n          status=AcquireImageColormap(image,MagickMin((size_t)\n            (psd_info.depth < 16 ? 256 : 65536), MaxColormapSize),exception);\n          if (status == MagickFalse)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Image colormap allocated\");\n        }\n      psd_info.min_channels=1;\n      (void) SetImageColorspace(image,GRAYColorspace,exception);\n      break;\n    }\n    case IndexedMode:\n    {\n      psd_info.min_channels=1;\n      break;\n    }\n    case MultichannelMode:\n    {\n      if ((psd_info.channels > 0) && (psd_info.channels < 3))\n        {\n          psd_info.min_channels=psd_info.channels;\n          (void) SetImageColorspace(image,GRAYColorspace,exception);\n        }\n      break;\n    }\n  }\n  if (psd_info.channels < psd_info.min_channels)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Read PSD raster colormap only present for indexed and duotone images.\n  */\n  length=ReadBlobMSBLong(image);\n  if ((psd_info.mode == IndexedMode) && (length < 3))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (length != 0)\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  reading colormap\");\n      if ((psd_info.mode == DuotoneMode) || (psd_info.depth == 32))\n        {\n          /*\n            Duotone image data;  the format of this data is undocumented.\n            32 bits per pixel;  the colormap is ignored.\n          */\n          (void) SeekBlob(image,(const MagickOffsetType) length,SEEK_CUR);\n        }\n      else\n        {\n          size_t\n            number_colors;\n\n          /*\n            Read PSD raster colormap.\n          */\n          number_colors=(size_t) length/3;\n          if (number_colors > 65536)\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          if (AcquireImageColormap(image,number_colors,exception) == MagickFalse)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].red=(MagickRealType) ScaleCharToQuantum(\n              (unsigned char) ReadBlobByte(image));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].green=(MagickRealType) ScaleCharToQuantum(\n              (unsigned char) ReadBlobByte(image));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum(\n              (unsigned char) ReadBlobByte(image));\n          image->alpha_trait=UndefinedPixelTrait;\n        }\n    }\n  if ((image->depth == 1) && (image->storage_class != PseudoClass))\n    ThrowReaderException(CorruptImageError, \"ImproperImageHeader\");\n  psd_info.has_merged_image=MagickTrue;\n  profile=(StringInfo *) NULL;\n  length=ReadBlobMSBLong(image);\n  if (length != 0)\n    {\n      unsigned char\n        *blocks;\n\n      /*\n        Image resources block.\n      */\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  reading image resource blocks - %.20g bytes\",(double)\n          ((MagickOffsetType) length));\n      if (length > GetBlobSize(image))\n        ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n      blocks=(unsigned char *) AcquireQuantumMemory((size_t) length,\n        sizeof(*blocks));\n      if (blocks == (unsigned char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      count=ReadBlob(image,(size_t) length,blocks);\n      if ((count != (ssize_t) length) || (length < 4) ||\n          (LocaleNCompare((char *) blocks,\"8BIM\",4) != 0))\n        {\n          blocks=(unsigned char *) RelinquishMagickMemory(blocks);\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n      profile=ParseImageResourceBlocks(&psd_info,image,blocks,(size_t) length);\n      blocks=(unsigned char *) RelinquishMagickMemory(blocks);\n    }\n  /*\n    Layer and mask block.\n  */\n  length=GetPSDSize(&psd_info,image);\n  if (length == 8)\n    {\n      length=ReadBlobMSBLong(image);\n      length=ReadBlobMSBLong(image);\n    }\n  offset=TellBlob(image);\n  skip_layers=MagickFalse;\n  if ((image_info->number_scenes == 1) && (image_info->scene == 0) &&\n      (psd_info.has_merged_image != MagickFalse))\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  read composite only\");\n      skip_layers=MagickTrue;\n    }\n  if (length == 0)\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  image has no layers\");\n    }\n  else\n    {\n      if (ReadPSDLayersInternal(image,image_info,&psd_info,skip_layers,\n            exception) != MagickTrue)\n        {\n          if (profile != (StringInfo *) NULL)\n            profile=DestroyStringInfo(profile);\n          (void) CloseBlob(image);\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n\n      /*\n         Skip the rest of the layer and mask information.\n      */\n      (void) SeekBlob(image,offset+length,SEEK_SET);\n    }\n  /*\n    If we are only \"pinging\" the image, then we're done - so return.\n  */\n  if (EOFBlob(image) != MagickFalse)\n    {\n      if (profile != (StringInfo *) NULL)\n        profile=DestroyStringInfo(profile);\n      ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    }\n  if (image_info->ping != MagickFalse)\n    {\n      if (profile != (StringInfo *) NULL)\n        profile=DestroyStringInfo(profile);\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  /*\n    Read the precombined layer, present for PSD < 4 compatibility.\n  */\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  reading the precombined layer\");\n  image_list_length=GetImageListLength(image);\n  if ((psd_info.has_merged_image != MagickFalse) || (image_list_length == 1))\n    psd_info.has_merged_image=(MagickBooleanType) ReadPSDMergedImage(\n      image_info,image,&psd_info,exception);\n  if ((psd_info.has_merged_image == MagickFalse) && (image_list_length == 1) &&\n      (length != 0))\n    {\n      (void) SeekBlob(image,offset,SEEK_SET);\n      status=ReadPSDLayersInternal(image,image_info,&psd_info,MagickFalse,\n        exception);\n      if (status != MagickTrue)\n        {\n          if (profile != (StringInfo *) NULL)\n            profile=DestroyStringInfo(profile);\n          (void) CloseBlob(image);\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n      image_list_length=GetImageListLength(image);\n    }\n  if (psd_info.has_merged_image == MagickFalse)\n    {\n      Image\n        *merged;\n\n      if (image_list_length == 1)\n        {\n          if (profile != (StringInfo *) NULL)\n            profile=DestroyStringInfo(profile);\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        }\n      image->background_color.alpha=(MagickRealType) TransparentAlpha;\n      image->background_color.alpha_trait=BlendPixelTrait;\n      (void) SetImageBackgroundColor(image,exception);\n      merged=MergeImageLayers(image,FlattenLayer,exception);\n      if (merged == (Image *) NULL)\n        {\n          (void) CloseBlob(image);\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n      ReplaceImageInList(&image,merged);\n    }\n  if (profile != (StringInfo *) NULL)\n    {\n      const char\n        *option;\n\n      Image\n        *next;\n\n      MagickBooleanType\n        replicate_profile;\n\n      option=GetImageOption(image_info,\"psd:replicate-profile\");\n      replicate_profile=IsStringTrue(option);\n      i=0;\n      next=image;\n      while (next != (Image *) NULL)\n      {\n        if (PSDSkipImage(&psd_info,image_info,i++) == MagickFalse)\n          {\n            (void) SetImageProfile(next,GetStringInfoName(profile),profile,\n              exception);\n            if (replicate_profile == MagickFalse)\n              break;\n          }\n        next=next->next;\n      }\n      profile=DestroyStringInfo(profile);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r P S D I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterPSDImage() adds properties for the PSD image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterPSDImage method is:\n%\n%      size_t RegisterPSDImage(void)\n%\n*/\nModuleExport size_t RegisterPSDImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"PSD\",\"PSB\",\"Adobe Large Document Format\");\n  entry->decoder=(DecodeImageHandler *) ReadPSDImage;\n  entry->encoder=(EncodeImageHandler *) WritePSDImage;\n  entry->magick=(IsImageFormatHandler *) IsPSD;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PSD\",\"PSD\",\"Adobe Photoshop bitmap\");\n  entry->decoder=(DecodeImageHandler *) ReadPSDImage;\n  entry->encoder=(EncodeImageHandler *) WritePSDImage;\n  entry->magick=(IsImageFormatHandler *) IsPSD;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r P S D I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterPSDImage() removes format registrations made by the\n%  PSD module from the list of supported formats.\n%\n%  The format of the UnregisterPSDImage method is:\n%\n%      UnregisterPSDImage(void)\n%\n*/\nModuleExport void UnregisterPSDImage(void)\n{\n  (void) UnregisterMagickInfo(\"PSB\");\n  (void) UnregisterMagickInfo(\"PSD\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P S D I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePSDImage() writes an image in the Adobe Photoshop encoded image format.\n%\n%  The format of the WritePSDImage method is:\n%\n%      MagickBooleanType WritePSDImage(const ImageInfo *image_info,Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline ssize_t SetPSDOffset(const PSDInfo *psd_info,Image *image,\n  const size_t offset)\n{\n  if (psd_info->version == 1)\n    return(WriteBlobMSBShort(image,(unsigned short) offset));\n  return(WriteBlobMSBLong(image,(unsigned int) offset));\n}\n\nstatic inline ssize_t WritePSDOffset(const PSDInfo *psd_info,Image *image,\n  const MagickSizeType size,const MagickOffsetType offset)\n{\n  MagickOffsetType\n    current_offset;\n\n  ssize_t\n    result;\n\n  current_offset=TellBlob(image);\n  (void) SeekBlob(image,offset,SEEK_SET);\n  if (psd_info->version == 1)\n    result=WriteBlobMSBShort(image,(unsigned short) size);\n  else\n    result=WriteBlobMSBLong(image,(unsigned int) size);\n  (void) SeekBlob(image,current_offset,SEEK_SET);\n  return(result);\n}\n\nstatic inline ssize_t SetPSDSize(const PSDInfo *psd_info,Image *image,\n  const MagickSizeType size)\n{\n  if (psd_info->version == 1)\n    return(WriteBlobLong(image,(unsigned int) size));\n  return(WriteBlobLongLong(image,size));\n}\n\nstatic inline ssize_t WritePSDSize(const PSDInfo *psd_info,Image *image,\n  const MagickSizeType size,const MagickOffsetType offset)\n{\n  MagickOffsetType\n    current_offset;\n\n  ssize_t\n    result;\n\n  current_offset=TellBlob(image);\n  (void) SeekBlob(image,offset,SEEK_SET);\n  result=SetPSDSize(psd_info,image,size);\n  (void) SeekBlob(image,current_offset,SEEK_SET);\n  return(result);\n}\n\nstatic size_t PSDPackbitsEncodeImage(Image *image,const size_t length,\n  const unsigned char *pixels,unsigned char *compact_pixels,\n  ExceptionInfo *exception)\n{\n  int\n    count;\n\n  ssize_t\n    i,\n    j;\n\n  unsigned char\n    *q;\n\n  unsigned char\n    *packbits;\n\n  /*\n    Compress pixels with Packbits encoding.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(pixels != (unsigned char *) NULL);\n  assert(compact_pixels != (unsigned char *) NULL);\n  packbits=(unsigned char *) AcquireQuantumMemory(128UL,sizeof(*packbits));\n  if (packbits == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  q=compact_pixels;\n  for (i=(ssize_t) length; i != 0; )\n  {\n    switch (i)\n    {\n      case 1:\n      {\n        i--;\n        *q++=(unsigned char) 0;\n        *q++=(*pixels);\n        break;\n      }\n      case 2:\n      {\n        i-=2;\n        *q++=(unsigned char) 1;\n        *q++=(*pixels);\n        *q++=pixels[1];\n        break;\n      }\n      case 3:\n      {\n        i-=3;\n        if ((*pixels == *(pixels+1)) && (*(pixels+1) == *(pixels+2)))\n          {\n            *q++=(unsigned char) ((256-3)+1);\n            *q++=(*pixels);\n            break;\n          }\n        *q++=(unsigned char) 2;\n        *q++=(*pixels);\n        *q++=pixels[1];\n        *q++=pixels[2];\n        break;\n      }\n      default:\n      {\n        if ((*pixels == *(pixels+1)) && (*(pixels+1) == *(pixels+2)))\n          {\n            /*\n              Packed run.\n            */\n            count=3;\n            while (((ssize_t) count < i) && (*pixels == *(pixels+count)))\n            {\n              count++;\n              if (count >= 127)\n                break;\n            }\n            i-=count;\n            *q++=(unsigned char) ((256-count)+1);\n            *q++=(*pixels);\n            pixels+=count;\n            break;\n          }\n        /*\n          Literal run.\n        */\n        count=0;\n        while ((*(pixels+count) != *(pixels+count+1)) ||\n               (*(pixels+count+1) != *(pixels+count+2)))\n        {\n          packbits[count+1]=pixels[count];\n          count++;\n          if (((ssize_t) count >= (i-3)) || (count >= 127))\n            break;\n        }\n        i-=count;\n        *packbits=(unsigned char) (count-1);\n        for (j=0; j <= (ssize_t) count; j++)\n          *q++=packbits[j];\n        pixels+=count;\n        break;\n      }\n    }\n  }\n  *q++=(unsigned char) 128;  /* EOD marker */\n  packbits=(unsigned char *) RelinquishMagickMemory(packbits);\n  return((size_t) (q-compact_pixels));\n}\n\nstatic size_t WriteCompressionStart(const PSDInfo *psd_info,Image *image,\n  const Image *next_image,const CompressionType compression,\n  const ssize_t channels)\n{\n  size_t\n    length;\n\n  ssize_t\n    i,\n    y;\n\n  if (compression == RLECompression)\n    {\n      length=(size_t) WriteBlobShort(image,RLE);\n      for (i=0; i < channels; i++)\n        for (y=0; y < (ssize_t) next_image->rows; y++)\n          length+=SetPSDOffset(psd_info,image,0);\n    }\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n  else if (compression == ZipCompression)\n    length=(size_t) WriteBlobShort(image,ZipWithoutPrediction);\n#endif\n  else\n    length=(size_t) WriteBlobShort(image,Raw);\n  return(length);\n}\n\nstatic size_t WritePSDChannel(const PSDInfo *psd_info,\n  const ImageInfo *image_info,Image *image,Image *next_image,\n  const QuantumType quantum_type, unsigned char *compact_pixels,\n  MagickOffsetType size_offset,const MagickBooleanType separate,\n  const CompressionType compression,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    monochrome;\n\n  QuantumInfo\n    *quantum_info;\n\n  const Quantum\n    *p;\n\n  ssize_t\n    i;\n\n  size_t\n    count,\n    length;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pixels;\n\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n\n  int\n    flush,\n    level;\n\n  unsigned char\n    *compressed_pixels;\n\n  z_stream\n    stream;\n\n  compressed_pixels=(unsigned char *) NULL;\n  flush=Z_NO_FLUSH;\n#endif\n  count=0;\n  if (separate != MagickFalse)\n    {\n      size_offset=TellBlob(image)+2;\n      count+=WriteCompressionStart(psd_info,image,next_image,compression,1);\n    }\n  if (next_image->depth > 8)\n    next_image->depth=16;\n  monochrome=IsImageMonochrome(image) && (image->depth == 1) ?\n    MagickTrue : MagickFalse;\n  quantum_info=AcquireQuantumInfo(image_info,next_image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    return(0);\n  pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n  if (compression == ZipCompression)\n    {\n      compressed_pixels=(unsigned char *) AcquireQuantumMemory(\n        MagickMinBufferExtent,sizeof(*compressed_pixels));\n      if (compressed_pixels == (unsigned char *) NULL)\n        {\n          quantum_info=DestroyQuantumInfo(quantum_info);\n          return(0);\n        }\n      memset(&stream,0,sizeof(stream));\n      stream.data_type=Z_BINARY;\n      level=Z_DEFAULT_COMPRESSION;\n      if ((image_info->quality > 0 && image_info->quality < 10))\n        level=(int) image_info->quality;\n      if (deflateInit(&stream,level) != Z_OK)\n        {\n          quantum_info=DestroyQuantumInfo(quantum_info);\n          compressed_pixels=(unsigned char *) RelinquishMagickMemory(\n            compressed_pixels);\n          return(0);\n        }\n    }\n#endif\n  for (y=0; y < (ssize_t) next_image->rows; y++)\n  {\n    p=GetVirtualPixels(next_image,0,y,next_image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    length=ExportQuantumPixels(next_image,(CacheView *) NULL,quantum_info,\n      quantum_type,pixels,exception);\n    if (monochrome != MagickFalse)\n      for (i=0; i < (ssize_t) length; i++)\n        pixels[i]=(~pixels[i]);\n    if (compression == RLECompression)\n      {\n        length=PSDPackbitsEncodeImage(image,length,pixels,compact_pixels,\n          exception);\n        count+=WriteBlob(image,length,compact_pixels);\n        size_offset+=WritePSDOffset(psd_info,image,length,size_offset);\n      }\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n    else if (compression == ZipCompression)\n      {\n        stream.avail_in=(uInt) length;\n        stream.next_in=(Bytef *) pixels;\n        if (y == (ssize_t) next_image->rows-1)\n          flush=Z_FINISH;\n        do {\n            stream.avail_out=(uInt) MagickMinBufferExtent;\n            stream.next_out=(Bytef *) compressed_pixels;\n            if (deflate(&stream,flush) == Z_STREAM_ERROR)\n              break;\n            length=(size_t) MagickMinBufferExtent-stream.avail_out;\n            if (length > 0)\n              count+=WriteBlob(image,length,compressed_pixels);\n        } while (stream.avail_out == 0);\n      }\n#endif\n    else\n      count+=WriteBlob(image,length,pixels);\n  }\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n  if (compression == ZipCompression)\n    {\n      (void) deflateEnd(&stream);\n      compressed_pixels=(unsigned char *) RelinquishMagickMemory(\n        compressed_pixels);\n    }\n#endif\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  return(count);\n}\n\nstatic unsigned char *AcquireCompactPixels(const Image *image,\n  ExceptionInfo *exception)\n{\n  size_t\n    packet_size;\n\n  unsigned char\n    *compact_pixels;\n\n  packet_size=image->depth > 8UL ? 2UL : 1UL;\n  compact_pixels=(unsigned char *) AcquireQuantumMemory((9*\n    image->columns)+1,packet_size*sizeof(*compact_pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n    }\n  return(compact_pixels);\n}\n\nstatic size_t WritePSDChannels(const PSDInfo *psd_info,\n  const ImageInfo *image_info,Image *image,Image *next_image,\n  MagickOffsetType size_offset,const MagickBooleanType separate,\n  ExceptionInfo *exception)\n{\n  CompressionType\n    compression;\n\n  Image\n    *mask;\n\n  MagickOffsetType\n    rows_offset;\n\n  size_t\n    channels,\n    count,\n    length,\n    offset_length;\n\n  unsigned char\n    *compact_pixels;\n\n  count=0;\n  offset_length=0;\n  rows_offset=0;\n  compact_pixels=(unsigned char *) NULL;\n  compression=next_image->compression;\n  if (image_info->compression != UndefinedCompression)\n    compression=image_info->compression;\n  if (compression == RLECompression)\n    {\n      compact_pixels=AcquireCompactPixels(next_image,exception);\n      if (compact_pixels == (unsigned char *) NULL)\n        return(0);\n    }\n  channels=1;\n  if (separate == MagickFalse)\n    {\n      if ((next_image->storage_class != PseudoClass) ||\n          (IsImageGray(next_image) != MagickFalse))\n        {\n          if (IsImageGray(next_image) == MagickFalse)\n            channels=(size_t) (next_image->colorspace == CMYKColorspace ? 4 :\n              3);\n          if (next_image->alpha_trait != UndefinedPixelTrait)\n            channels++;\n        }\n      rows_offset=TellBlob(image)+2;\n      count+=WriteCompressionStart(psd_info,image,next_image,compression,\n        (ssize_t) channels);\n      offset_length=(next_image->rows*(psd_info->version == 1 ? 2 : 4));\n    }\n  size_offset+=2;\n  if ((next_image->storage_class == PseudoClass) &&\n      (IsImageGray(next_image) == MagickFalse))\n    {\n      length=WritePSDChannel(psd_info,image_info,image,next_image,\n        IndexQuantum,compact_pixels,rows_offset,separate,compression,\n        exception);\n      if (separate != MagickFalse)\n        size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n      else\n        rows_offset+=offset_length;\n      count+=length;\n    }\n  else\n    {\n      if (IsImageGray(next_image) != MagickFalse)\n        {\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            GrayQuantum,compact_pixels,rows_offset,separate,compression,\n            exception);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n        }\n      else\n        {\n          if (next_image->colorspace == CMYKColorspace)\n            (void) NegateCMYK(next_image,exception);\n\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            RedQuantum,compact_pixels,rows_offset,separate,compression,\n            exception);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            GreenQuantum,compact_pixels,rows_offset,separate,compression,\n            exception);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            BlueQuantum,compact_pixels,rows_offset,separate,compression,\n            exception);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n\n          if (next_image->colorspace == CMYKColorspace)\n            {\n              length=WritePSDChannel(psd_info,image_info,image,next_image,\n                BlackQuantum,compact_pixels,rows_offset,separate,compression,\n                exception);\n              if (separate != MagickFalse)\n                size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n              else\n                rows_offset+=offset_length;\n              count+=length;\n            }\n        }\n      if (next_image->alpha_trait != UndefinedPixelTrait)\n        {\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            AlphaQuantum,compact_pixels,rows_offset,separate,compression,\n            exception);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n        }\n    }\n  compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n  if (next_image->colorspace == CMYKColorspace)\n    (void) NegateCMYK(next_image,exception);\n  if (separate != MagickFalse)\n    {\n      const char\n        *property;\n\n      property=GetImageArtifact(next_image,\"psd:opacity-mask\");\n      if (property != (const char *) NULL)\n        {\n          mask=(Image *) GetImageRegistry(ImageRegistryType,property,\n            exception);\n          if (mask != (Image *) NULL)\n            {\n              if (compression == RLECompression)\n                {\n                  compact_pixels=AcquireCompactPixels(mask,exception);\n                  if (compact_pixels == (unsigned char *) NULL)\n                    return(0);\n                }\n              length=WritePSDChannel(psd_info,image_info,image,mask,\n                RedQuantum,compact_pixels,rows_offset,MagickTrue,compression,\n                exception);\n              (void) WritePSDSize(psd_info,image,length,size_offset);\n              count+=length;\n              compact_pixels=(unsigned char *) RelinquishMagickMemory(\n                compact_pixels);\n            }\n        }\n    }\n  return(count);\n}\n\nstatic size_t WritePascalString(Image *image,const char *value,size_t padding)\n{\n  size_t\n    count,\n    length;\n\n  ssize_t\n    i;\n\n  /*\n    Max length is 255.\n  */\n  count=0;\n  length=(strlen(value) > 255UL ) ? 255UL : strlen(value);\n  if (length ==  0)\n    count+=WriteBlobByte(image,0);\n  else\n    {\n      count+=WriteBlobByte(image,(unsigned char) length);\n      count+=WriteBlob(image,length,(const unsigned char *) value);\n    }\n  length++;\n  if ((length % padding) == 0)\n    return(count);\n  for (i=0; i < (ssize_t) (padding-(length % padding)); i++)\n    count+=WriteBlobByte(image,0);\n  return(count);\n}\n\nstatic void WriteResolutionResourceBlock(Image *image)\n{\n  double\n    x_resolution,\n    y_resolution;\n\n  unsigned short\n    units;\n\n  if (image->units == PixelsPerCentimeterResolution)\n    {\n      x_resolution=2.54*65536.0*image->resolution.x+0.5;\n      y_resolution=2.54*65536.0*image->resolution.y+0.5;\n      units=2;\n    }\n  else\n    {\n      x_resolution=65536.0*image->resolution.x+0.5;\n      y_resolution=65536.0*image->resolution.y+0.5;\n      units=1;\n    }\n  (void) WriteBlob(image,4,(const unsigned char *) \"8BIM\");\n  (void) WriteBlobMSBShort(image,0x03ED);\n  (void) WriteBlobMSBShort(image,0);\n  (void) WriteBlobMSBLong(image,16); /* resource size */\n  (void) WriteBlobMSBLong(image,(unsigned int) (x_resolution+0.5));\n  (void) WriteBlobMSBShort(image,units); /* horizontal resolution unit */\n  (void) WriteBlobMSBShort(image,units); /* width unit */\n  (void) WriteBlobMSBLong(image,(unsigned int) (y_resolution+0.5));\n  (void) WriteBlobMSBShort(image,units); /* vertical resolution unit */\n  (void) WriteBlobMSBShort(image,units); /* height unit */\n}\n\nstatic inline size_t WriteChannelSize(const PSDInfo *psd_info,Image *image,\n  const signed short channel)\n{\n  size_t\n    count;\n\n  count=(size_t) WriteBlobShort(image,(const unsigned short) channel);\n  count+=SetPSDSize(psd_info,image,0);\n  return(count);\n}\n\nstatic void RemoveICCProfileFromResourceBlock(StringInfo *bim_profile)\n{\n  const unsigned char\n    *p;\n\n  size_t\n    length;\n\n  unsigned char\n    *datum;\n\n  unsigned int\n    count,\n    long_sans;\n\n  unsigned short\n    id,\n    short_sans;\n\n  length=GetStringInfoLength(bim_profile);\n  if (length < 16)\n    return;\n  datum=GetStringInfoDatum(bim_profile);\n  for (p=datum; (p >= datum) && (p < (datum+length-16)); )\n  {\n    unsigned char\n      *q;\n\n    q=(unsigned char *) p;\n    if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      break;\n    p=PushLongPixel(MSBEndian,p,&long_sans);\n    p=PushShortPixel(MSBEndian,p,&id);\n    p=PushShortPixel(MSBEndian,p,&short_sans);\n    p=PushLongPixel(MSBEndian,p,&count);\n    if (id == 0x0000040f)\n      {\n        ssize_t\n          quantum;\n\n        quantum=PSDQuantum(count)+12;\n        if ((quantum >= 12) && (quantum < (ssize_t) length))\n          {\n            if ((q+quantum < (datum+length-16)))\n              (void) memmove(q,q+quantum,length-quantum-(q-datum));\n            SetStringInfoLength(bim_profile,length-quantum);\n          }\n        break;\n      }\n    p+=count;\n    if ((count & 0x01) != 0)\n      p++;\n  }\n}\n\nstatic void RemoveResolutionFromResourceBlock(StringInfo *bim_profile)\n{\n  const unsigned char\n    *p;\n\n  size_t\n    length;\n\n  unsigned char\n    *datum;\n\n  unsigned int\n    count,\n    long_sans;\n\n  unsigned short\n    id,\n    short_sans;\n\n  length=GetStringInfoLength(bim_profile);\n  if (length < 16)\n    return;\n  datum=GetStringInfoDatum(bim_profile);\n  for (p=datum; (p >= datum) && (p < (datum+length-16)); )\n  {\n    unsigned char\n      *q;\n\n    ssize_t\n      cnt;\n\n    q=(unsigned char *) p;\n    if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      return;\n    p=PushLongPixel(MSBEndian,p,&long_sans);\n    p=PushShortPixel(MSBEndian,p,&id);\n    p=PushShortPixel(MSBEndian,p,&short_sans);\n    p=PushLongPixel(MSBEndian,p,&count);\n    cnt=PSDQuantum(count);\n    if (cnt < 0)\n      return;\n    if ((id == 0x000003ed) && (cnt < (ssize_t) (length-12)) &&\n        ((ssize_t) length-(cnt+12)-(q-datum)) > 0)\n      {\n        (void) memmove(q,q+cnt+12,length-(cnt+12)-(q-datum));\n        SetStringInfoLength(bim_profile,length-(cnt+12));\n        break;\n      }\n    p+=count;\n    if ((count & 0x01) != 0)\n      p++;\n  }\n}\n\nstatic const StringInfo *GetAdditionalInformation(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n#define PSDKeySize 5\n#define PSDAllowedLength 36\n\n  char\n    key[PSDKeySize];\n\n  /* Whitelist of keys from: https://www.adobe.com/devnet-apps/photoshop/fileformatashtml/ */\n  const char\n    allowed[PSDAllowedLength][PSDKeySize] = {\n      \"blnc\", \"blwh\", \"brit\", \"brst\", \"clbl\", \"clrL\", \"curv\", \"expA\", \"FMsk\",\n      \"GdFl\", \"grdm\", \"hue \", \"hue2\", \"infx\", \"knko\", \"lclr\", \"levl\", \"lnsr\",\n      \"lfx2\", \"luni\", \"lrFX\", \"lspf\", \"lyid\", \"lyvr\", \"mixr\", \"nvrt\", \"phfl\",\n      \"post\", \"PtFl\", \"selc\", \"shpa\", \"sn2P\", \"SoCo\", \"thrs\", \"tsly\", \"vibA\"\n    },\n    *option;\n\n  const StringInfo\n    *info;\n\n  MagickBooleanType\n    found;\n\n  size_t\n    i;\n\n  size_t\n    remaining_length,\n    length;\n\n  StringInfo\n    *profile;\n\n  unsigned char\n    *p;\n\n  unsigned int\n    size;\n\n  info=GetImageProfile(image,\"psd:additional-info\");\n  if (info == (const StringInfo *) NULL)\n    return((const StringInfo *) NULL);\n  option=GetImageOption(image_info,\"psd:additional-info\");\n  if (LocaleCompare(option,\"all\") == 0)\n    return(info);\n  if (LocaleCompare(option,\"selective\") != 0)\n    {\n      profile=RemoveImageProfile(image,\"psd:additional-info\");\n      return(DestroyStringInfo(profile));\n    }\n  length=GetStringInfoLength(info);\n  p=GetStringInfoDatum(info);\n  remaining_length=length;\n  length=0;\n  while (remaining_length >= 12)\n  {\n    /* skip over signature */\n    p+=4;\n    key[0]=(char) (*p++);\n    key[1]=(char) (*p++);\n    key[2]=(char) (*p++);\n    key[3]=(char) (*p++);\n    key[4]='\\0';\n    size=(unsigned int) (*p++) << 24;\n    size|=(unsigned int) (*p++) << 16;\n    size|=(unsigned int) (*p++) << 8;\n    size|=(unsigned int) (*p++);\n    size=size & 0xffffffff;\n    remaining_length-=12;\n    if ((size_t) size > remaining_length)\n      return((const StringInfo *) NULL);\n    found=MagickFalse;\n    for (i=0; i < PSDAllowedLength; i++)\n    {\n      if (LocaleNCompare(key,allowed[i],PSDKeySize) != 0)\n        continue;\n\n      found=MagickTrue;\n      break;\n    }\n    remaining_length-=(size_t) size;\n    if (found == MagickFalse)\n      {\n        if (remaining_length > 0)\n          p=(unsigned char *) memmove(p-12,p+size,remaining_length);\n        continue;\n      }\n    length+=(size_t) size+12;\n    p+=size;\n  }\n  profile=RemoveImageProfile(image,\"psd:additional-info\");\n  if (length == 0)\n    return(DestroyStringInfo(profile));\n  SetStringInfoLength(profile,(const size_t) length);\n  (void) SetImageProfile(image,\"psd:additional-info\",info,exception);\n  return(profile);\n}\n\nstatic MagickBooleanType WritePSDLayersInternal(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,size_t *layers_size,\n  ExceptionInfo *exception)\n{\n  char\n    layer_name[MagickPathExtent];\n\n  const char\n    *property;\n\n  const StringInfo\n    *info;\n\n  Image\n    *base_image,\n    *next_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    *layer_size_offsets,\n    size_offset;\n\n  ssize_t\n    i;\n\n  size_t\n    layer_count,\n    layer_index,\n    length,\n    name_length,\n    rounded_size,\n    size;\n\n  status=MagickTrue;\n  base_image=GetNextImageInList(image);\n  if (base_image == (Image *) NULL)\n    base_image=image;\n  size=0;\n  size_offset=TellBlob(image);\n  (void) SetPSDSize(psd_info,image,0);\n  layer_count=0;\n  for (next_image=base_image; next_image != NULL; )\n  {\n    layer_count++;\n    next_image=GetNextImageInList(next_image);\n  }\n  if (image->alpha_trait != UndefinedPixelTrait)\n    size+=WriteBlobShort(image,-(unsigned short) layer_count);\n  else\n    size+=WriteBlobShort(image,(unsigned short) layer_count);\n  layer_size_offsets=(MagickOffsetType *) AcquireQuantumMemory(\n    (size_t) layer_count,sizeof(MagickOffsetType));\n  if (layer_size_offsets == (MagickOffsetType *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  layer_index=0;\n  for (next_image=base_image; next_image != NULL; )\n  {\n    Image\n      *mask;\n\n    unsigned char\n      default_color;\n\n    unsigned short\n      channels,\n      total_channels;\n\n    mask=(Image *) NULL;\n    property=GetImageArtifact(next_image,\"psd:opacity-mask\");\n    default_color=0;\n    if (property != (const char *) NULL)\n      {\n        mask=(Image *) GetImageRegistry(ImageRegistryType,property,exception);\n        default_color=(unsigned char) (strlen(property) == 9 ? 255 : 0);\n      }\n    size+=WriteBlobSignedLong(image,(signed int) next_image->page.y);\n    size+=WriteBlobSignedLong(image,(signed int) next_image->page.x);\n    size+=WriteBlobSignedLong(image,(signed int) (next_image->page.y+\n      next_image->rows));\n    size+=WriteBlobSignedLong(image,(signed int) (next_image->page.x+\n      next_image->columns));\n    channels=1;\n    if ((next_image->storage_class != PseudoClass) &&\n        (IsImageGray(next_image) == MagickFalse))\n      channels=(unsigned short) (next_image->colorspace == CMYKColorspace ? 4 :\n        3);\n    total_channels=channels;\n    if (next_image->alpha_trait != UndefinedPixelTrait)\n      total_channels++;\n    if (mask != (Image *) NULL)\n      total_channels++;\n    size+=WriteBlobShort(image,total_channels);\n    layer_size_offsets[layer_index++]=TellBlob(image);\n    for (i=0; i < (ssize_t) channels; i++)\n      size+=WriteChannelSize(psd_info,image,(signed short) i);\n    if (next_image->alpha_trait != UndefinedPixelTrait)\n      size+=WriteChannelSize(psd_info,image,-1);\n    if (mask != (Image *) NULL)\n      size+=WriteChannelSize(psd_info,image,-2);\n    size+=WriteBlobString(image,image->endian == LSBEndian ? \"MIB8\" :\"8BIM\");\n    size+=WriteBlobString(image,CompositeOperatorToPSDBlendMode(next_image));\n    property=GetImageArtifact(next_image,\"psd:layer.opacity\");\n    if (property != (const char *) NULL)\n      {\n        Quantum\n          opacity;\n\n        opacity=(Quantum) StringToInteger(property);\n        size+=WriteBlobByte(image,ScaleQuantumToChar(opacity));\n        (void) ApplyPSDLayerOpacity(next_image,opacity,MagickTrue,exception);\n      }\n    else\n      size+=WriteBlobByte(image,255);\n    size+=WriteBlobByte(image,0);\n    size+=WriteBlobByte(image,(const unsigned char)\n      (next_image->compose == NoCompositeOp ? 1 << 0x02 : 1)); /* layer properties - visible, etc. */\n    size+=WriteBlobByte(image,0);\n    info=GetAdditionalInformation(image_info,next_image,exception);\n    property=(const char *) GetImageProperty(next_image,\"label\",exception);\n    if (property == (const char *) NULL)\n      {\n        (void) FormatLocaleString(layer_name,MagickPathExtent,\"L%.20g\",\n          (double) layer_index);\n        property=layer_name;\n      }\n    name_length=strlen(property)+1;\n    if ((name_length % 4) != 0)\n      name_length+=(4-(name_length % 4));\n    if (info != (const StringInfo *) NULL)\n      name_length+=GetStringInfoLength(info);\n    name_length+=8;\n    if (mask != (Image *) NULL)\n      name_length+=20;\n    size+=WriteBlobLong(image,(unsigned int) name_length);\n    if (mask == (Image *) NULL)\n      size+=WriteBlobLong(image,0);\n    else\n      {\n        if (mask->compose != NoCompositeOp)\n          (void) ApplyPSDOpacityMask(next_image,mask,ScaleCharToQuantum(\n            default_color),MagickTrue,exception);\n        mask->page.y+=image->page.y;\n        mask->page.x+=image->page.x;\n        size+=WriteBlobLong(image,20);\n        size+=WriteBlobSignedLong(image,(const signed int) mask->page.y);\n        size+=WriteBlobSignedLong(image,(const signed int) mask->page.x);\n        size+=WriteBlobSignedLong(image,(const signed int) (mask->rows+\n          mask->page.y));\n        size+=WriteBlobSignedLong(image,(const signed int) (mask->columns+\n          mask->page.x));\n        size+=WriteBlobByte(image,default_color);\n        size+=WriteBlobByte(image,(const unsigned char)\n          (mask->compose == NoCompositeOp ? 2 : 0));\n        size+=WriteBlobMSBShort(image,0);\n      }\n    size+=WriteBlobLong(image,0);\n    size+=WritePascalString(image,property,4);\n    if (info != (const StringInfo *) NULL)\n      size+=WriteBlob(image,GetStringInfoLength(info),\n        GetStringInfoDatum(info));\n    next_image=GetNextImageInList(next_image);\n  }\n  /*\n    Now the image data!\n  */\n  next_image=base_image;\n  layer_index=0;\n  while (next_image != NULL)\n  {\n    length=WritePSDChannels(psd_info,image_info,image,next_image,\n      layer_size_offsets[layer_index++],MagickTrue,exception);\n    if (length == 0)\n      {\n        status=MagickFalse;\n        break;\n      }\n    size+=length;\n    next_image=GetNextImageInList(next_image);\n  }\n  /*\n    Write the total size\n  */\n  if (layers_size != (size_t*) NULL)\n    *layers_size=size;\n  if ((size/2) != ((size+1)/2))\n    rounded_size=size+1;\n  else\n    rounded_size=size;\n  (void) WritePSDSize(psd_info,image,rounded_size,size_offset);\n  layer_size_offsets=(MagickOffsetType *) RelinquishMagickMemory(\n    layer_size_offsets);\n  /*\n    Remove the opacity mask from the registry\n  */\n  next_image=base_image;\n  while (next_image != (Image *) NULL)\n  {\n    property=GetImageArtifact(next_image,\"psd:opacity-mask\");\n    if (property != (const char *) NULL)\n      (void) DeleteImageRegistry(property);\n    next_image=GetNextImageInList(next_image);\n  }\n  return(status);\n}\n\nModuleExport MagickBooleanType WritePSDLayers(Image * image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  status=IsRightsAuthorized(CoderPolicyDomain,WritePolicyRights,\"PSD\");\n  if (status == MagickFalse)\n    return(MagickTrue);\n  return WritePSDLayersInternal(image,image_info,psd_info,(size_t*) NULL,\n    exception);\n}\n\nstatic MagickBooleanType WritePSDImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  const StringInfo\n    *icc_profile;\n\n  MagickBooleanType\n    status;\n\n  PSDInfo\n    psd_info;\n\n  ssize_t\n    i;\n\n  size_t\n    length,\n    num_channels;\n\n  StringInfo\n    *bim_profile;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  psd_info.version=1;\n  if ((LocaleCompare(image_info->magick,\"PSB\") == 0) ||\n      (image->columns > 30000) || (image->rows > 30000))\n    psd_info.version=2;\n  (void) WriteBlob(image,4,(const unsigned char *) \"8BPS\");\n  (void) WriteBlobMSBShort(image,psd_info.version);  /* version */\n  for (i=1; i <= 6; i++)\n    (void) WriteBlobByte(image, 0);  /* 6 bytes of reserved */\n  if ((GetImageProfile(image,\"icc\") == (StringInfo *) NULL) &&\n      (SetImageGray(image,exception) != MagickFalse))\n    num_channels=(image->alpha_trait != UndefinedPixelTrait ? 2UL : 1UL);\n  else\n    if ((image_info->type != TrueColorType) &&\n        (image_info->type != TrueColorAlphaType) &&\n        (image->storage_class == PseudoClass))\n      num_channels=(image->alpha_trait != UndefinedPixelTrait ? 2UL : 1UL);\n    else\n      {\n        if (image->storage_class == PseudoClass)\n          (void) SetImageStorageClass(image,DirectClass,exception);\n        if (image->colorspace != CMYKColorspace)\n          num_channels=(image->alpha_trait != UndefinedPixelTrait ? 4UL : 3UL);\n        else\n          num_channels=(image->alpha_trait != UndefinedPixelTrait ? 5UL : 4UL);\n      }\n  (void) WriteBlobMSBShort(image,(unsigned short) num_channels);\n  (void) WriteBlobMSBLong(image,(unsigned int) image->rows);\n  (void) WriteBlobMSBLong(image,(unsigned int) image->columns);\n  if (IsImageGray(image) != MagickFalse)\n    {\n      MagickBooleanType\n        monochrome;\n\n      /*\n        Write depth & mode.\n      */\n      monochrome=IsImageMonochrome(image) && (image->depth == 1) ?\n        MagickTrue : MagickFalse;\n      (void) WriteBlobMSBShort(image,(unsigned short)\n        (monochrome != MagickFalse ? 1 : image->depth > 8 ? 16 : 8));\n      (void) WriteBlobMSBShort(image,(unsigned short)\n        (monochrome != MagickFalse ? BitmapMode : GrayscaleMode));\n    }\n  else\n    {\n      (void) WriteBlobMSBShort(image,(unsigned short) (image->storage_class ==\n        PseudoClass ? 8 : image->depth > 8 ? 16 : 8));\n\n      if (((image_info->colorspace != UndefinedColorspace) ||\n           (image->colorspace != CMYKColorspace)) &&\n          (image_info->colorspace != CMYKColorspace))\n        {\n          (void) TransformImageColorspace(image,sRGBColorspace,exception);\n          (void) WriteBlobMSBShort(image,(unsigned short)\n            (image->storage_class == PseudoClass ? IndexedMode : RGBMode));\n        }\n      else\n        {\n          if (image->colorspace != CMYKColorspace)\n            (void) TransformImageColorspace(image,CMYKColorspace,exception);\n          (void) WriteBlobMSBShort(image,CMYKMode);\n        }\n    }\n  if ((IsImageGray(image) != MagickFalse) ||\n      (image->storage_class == DirectClass) || (image->colors > 256))\n    (void) WriteBlobMSBLong(image,0);\n  else\n    {\n      /*\n        Write PSD raster colormap.\n      */\n      (void) WriteBlobMSBLong(image,768);\n      for (i=0; i < (ssize_t) image->colors; i++)\n        (void) WriteBlobByte(image,ScaleQuantumToChar(ClampToQuantum(\n          image->colormap[i].red)));\n      for ( ; i < 256; i++)\n        (void) WriteBlobByte(image,0);\n      for (i=0; i < (ssize_t) image->colors; i++)\n        (void) WriteBlobByte(image,ScaleQuantumToChar(ClampToQuantum(\n          image->colormap[i].green)));\n      for ( ; i < 256; i++)\n        (void) WriteBlobByte(image,0);\n      for (i=0; i < (ssize_t) image->colors; i++)\n        (void) WriteBlobByte(image,ScaleQuantumToChar(ClampToQuantum(\n          image->colormap[i].blue)));\n      for ( ; i < 256; i++)\n        (void) WriteBlobByte(image,0);\n    }\n  /*\n    Image resource block.\n  */\n  length=28; /* 0x03EB */\n  bim_profile=(StringInfo *) GetImageProfile(image,\"8bim\");\n  icc_profile=GetImageProfile(image,\"icc\");\n  if (bim_profile != (StringInfo *) NULL)\n    {\n      bim_profile=CloneStringInfo(bim_profile);\n      if (icc_profile != (StringInfo *) NULL)\n        RemoveICCProfileFromResourceBlock(bim_profile);\n      RemoveResolutionFromResourceBlock(bim_profile);\n      length+=PSDQuantum(GetStringInfoLength(bim_profile));\n    }\n  if (icc_profile != (const StringInfo *) NULL)\n    length+=PSDQuantum(GetStringInfoLength(icc_profile))+12;\n  (void) WriteBlobMSBLong(image,(unsigned int) length);\n  WriteResolutionResourceBlock(image);\n  if (bim_profile != (StringInfo *) NULL)\n    {\n      (void) WriteBlob(image,GetStringInfoLength(bim_profile),\n        GetStringInfoDatum(bim_profile));\n      bim_profile=DestroyStringInfo(bim_profile);\n    }\n  if (icc_profile != (StringInfo *) NULL)\n    {\n      (void) WriteBlob(image,4,(const unsigned char *) \"8BIM\");\n      (void) WriteBlobMSBShort(image,0x0000040F);\n      (void) WriteBlobMSBShort(image,0);\n      (void) WriteBlobMSBLong(image,(unsigned int) GetStringInfoLength(\n        icc_profile));\n      (void) WriteBlob(image,GetStringInfoLength(icc_profile),\n        GetStringInfoDatum(icc_profile));\n      if ((ssize_t) GetStringInfoLength(icc_profile) != PSDQuantum(GetStringInfoLength(icc_profile)))\n        (void) WriteBlobByte(image,0);\n    }\n  if (status != MagickFalse)\n    {\n      const char\n        *option;\n\n      CompressionType\n        compression;\n\n      MagickOffsetType\n        size_offset;\n\n      size_t\n        size;\n\n      size_offset=TellBlob(image);\n      (void) SetPSDSize(&psd_info,image,0);\n      option=GetImageOption(image_info,\"psd:write-layers\");\n      if (IsStringFalse(option) != MagickTrue)\n        {\n          status=WritePSDLayersInternal(image,image_info,&psd_info,&size,\n            exception);\n          (void) WritePSDSize(&psd_info,image,size+\n            (psd_info.version == 1 ? 8 : 12),size_offset);\n          (void) WriteBlobMSBLong(image,0);  /* user mask data */\n        }\n      /*\n        Write composite image.\n      */\n      compression=image->compression;\n      if (image_info->compression != UndefinedCompression)\n        image->compression=image_info->compression;\n      if (image->compression == ZipCompression)\n        image->compression=RLECompression;\n      if (WritePSDChannels(&psd_info,image_info,image,image,0,MagickFalse,\n          exception) == 0)\n        status=MagickFalse;\n      image->compression=compression;\n    }\n  (void) CloseBlob(image);\n  return(status);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            PPPP   SSSSS  DDDD                               %\n%                            P   P  SS     D   D                              %\n%                            PPPP    SSS   D   D                              %\n%                            P         SS  D   D                              %\n%                            P      SSSSS  DDDD                               %\n%                                                                             %\n%                                                                             %\n%                   Read/Write Adobe Photoshop Image Format                   %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                              Leonard Rosenthol                              %\n%                                 July 1992                                   %\n%                                Dirk Lemstra                                 %\n%                                December 2013                                %\n%                                                                             %\n%                                                                             %\n%  Copyright @ 1999 ImageMagick Studio LLC, a non-profit organization         %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n% Photoshop spec @ https://www.adobe.com/devnet-apps/photoshop/fileformatashtml\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/pixel-private.h\"\n#include \"MagickCore/policy.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/registry.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"coders/coders-private.h\"\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n#include <zlib.h>\n#endif\n#include \"psd-private.h\"\n\n/*\n  Define declaractions.\n*/\n#define MaxPSDChannels  56\n#define PSDQuantum(x) (((ssize_t) (x)+1) & -2)\n\f\n/*\n  Enumerated declaractions.\n*/\ntypedef enum\n{\n  Raw = 0,\n  RLE = 1,\n  ZipWithoutPrediction = 2,\n  ZipWithPrediction = 3\n} PSDCompressionType;\n\ntypedef enum\n{\n  BitmapMode = 0,\n  GrayscaleMode = 1,\n  IndexedMode = 2,\n  RGBMode = 3,\n  CMYKMode = 4,\n  MultichannelMode = 7,\n  DuotoneMode = 8,\n  LabMode = 9\n} PSDImageType;\n\f\n/*\n  Typedef declaractions.\n*/\ntypedef struct _ChannelInfo\n{\n  MagickBooleanType\n    supported;\n\n  PixelChannel\n    channel;\n\n  size_t\n    size;\n} ChannelInfo;\n\ntypedef struct _MaskInfo\n{\n  Image\n    *image;\n\n  RectangleInfo\n    page;\n\n  unsigned char\n    background,\n    flags;\n} MaskInfo;\n\ntypedef struct _LayerInfo\n{\n  ChannelInfo\n    channel_info[MaxPSDChannels];\n\n  char\n    blendkey[4];\n\n  Image\n    *image;\n\n  MaskInfo\n    mask;\n\n  Quantum\n    opacity;\n\n  RectangleInfo\n    page;\n\n  size_t\n    offset_x,\n    offset_y;\n\n  unsigned char\n    clipping,\n    flags,\n    name[257],\n    visible;\n\n  unsigned short\n    channels;\n\n  StringInfo\n    *info;\n} LayerInfo;\n\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WritePSDImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s P S D                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsPSD()() returns MagickTrue if the image format type, identified by the\n%  magick string, is PSD.\n%\n%  The format of the IsPSD method is:\n%\n%      MagickBooleanType IsPSD(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsPSD(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (LocaleNCompare((const char *) magick,\"8BPS\",4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d P S D I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadPSDImage() reads an Adobe Photoshop image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadPSDImage method is:\n%\n%      Image *ReadPSDImage(image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic const char *CompositeOperatorToPSDBlendMode(Image *image)\n{\n  switch (image->compose)\n  {\n    case ColorBurnCompositeOp:\n      return(image->endian == LSBEndian ? \"vidi\" : \"idiv\");\n    case ColorDodgeCompositeOp:\n      return(image->endian == LSBEndian ? \" vid\" : \"div \");\n    case ColorizeCompositeOp:\n      return(image->endian == LSBEndian ? \"rloc\" : \"colr\");\n    case DarkenCompositeOp:\n      return(image->endian == LSBEndian ? \"krad\" : \"dark\");\n    case DifferenceCompositeOp:\n      return(image->endian == LSBEndian ? \"ffid\" : \"diff\");\n    case DissolveCompositeOp:\n      return(image->endian == LSBEndian ? \"ssid\" : \"diss\");\n    case ExclusionCompositeOp:\n      return(image->endian == LSBEndian ? \"dums\" : \"smud\");\n    case HardLightCompositeOp:\n      return(image->endian == LSBEndian ? \"tiLh\" : \"hLit\");\n    case HardMixCompositeOp:\n      return(image->endian == LSBEndian ? \"xiMh\" : \"hMix\");\n    case HueCompositeOp:\n      return(image->endian == LSBEndian ? \" euh\" : \"hue \");\n    case LightenCompositeOp:\n      return(image->endian == LSBEndian ? \"etil\" : \"lite\");\n    case LinearBurnCompositeOp:\n      return(image->endian == LSBEndian ? \"nrbl\" : \"lbrn\");\n    case LinearDodgeCompositeOp:\n      return(image->endian == LSBEndian ? \"gddl\" : \"lddg\");\n    case LinearLightCompositeOp:\n      return(image->endian == LSBEndian ? \"tiLl\" : \"lLit\");\n    case LuminizeCompositeOp:\n      return(image->endian == LSBEndian ? \" mul\" : \"lum \");\n    case MultiplyCompositeOp:\n      return(image->endian == LSBEndian ? \" lum\" : \"mul \");\n    case OverlayCompositeOp:\n      return(image->endian == LSBEndian ? \"revo\" : \"over\");\n    case PinLightCompositeOp:\n      return(image->endian == LSBEndian ? \"tiLp\" : \"pLit\");\n    case SaturateCompositeOp:\n      return(image->endian == LSBEndian ? \" tas\" : \"sat \");\n    case ScreenCompositeOp:\n      return(image->endian == LSBEndian ? \"nrcs\" : \"scrn\");\n    case SoftLightCompositeOp:\n      return(image->endian == LSBEndian ? \"tiLs\" : \"sLit\");\n    case VividLightCompositeOp:\n      return(image->endian == LSBEndian ? \"tiLv\" : \"vLit\");\n    case OverCompositeOp:\n    default:\n      return(image->endian == LSBEndian ? \"mron\" : \"norm\");\n  }\n}\n\n/*\n  For some reason Photoshop seems to blend semi-transparent pixels with white.\n  This method reverts the blending. This can be disabled by setting the\n  option 'psd:alpha-unblend' to off.\n*/\nstatic MagickBooleanType CorrectPSDAlphaBlend(const ImageInfo *image_info,\n  Image *image,ExceptionInfo* exception)\n{\n  const char\n    *option;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  if ((image->alpha_trait != BlendPixelTrait) ||\n      (image->colorspace != sRGBColorspace))\n    return(MagickTrue);\n  option=GetImageOption(image_info,\"psd:alpha-unblend\");\n  if (IsStringFalse(option) != MagickFalse)\n    return(MagickTrue);\n  status=MagickTrue;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n#pragma omp parallel for schedule(static) shared(status) \\\n  magick_number_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    Quantum\n      *magick_restrict q;\n\n    ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        gamma;\n\n      ssize_t\n        i;\n\n      gamma=QuantumScale*GetPixelAlpha(image, q);\n      if (gamma != 0.0 && gamma != 1.0)\n        {\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            PixelChannel channel = GetPixelChannelChannel(image,i);\n            if (channel != AlphaPixelChannel)\n              q[i]=ClampToQuantum((q[i]-((1.0-gamma)*QuantumRange))/gamma);\n          }\n        }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n\n  return(status);\n}\n\nstatic inline CompressionType ConvertPSDCompression(\n  PSDCompressionType compression)\n{\n  switch (compression)\n  {\n    case RLE:\n      return RLECompression;\n    case ZipWithPrediction:\n    case ZipWithoutPrediction:\n      return ZipCompression;\n    default:\n      return NoCompression;\n  }\n}\n\nstatic MagickBooleanType ApplyPSDLayerOpacity(Image *image,Quantum opacity,\n  MagickBooleanType revert,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  applying layer opacity %.20g\", (double) opacity);\n  if (opacity == OpaqueAlpha)\n    return(MagickTrue);\n  if (image->alpha_trait != BlendPixelTrait)\n    (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n  status=MagickTrue;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n#pragma omp parallel for schedule(static) shared(status) \\\n  magick_number_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    Quantum\n      *magick_restrict q;\n\n    ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (revert == MagickFalse)\n        SetPixelAlpha(image,ClampToQuantum(QuantumScale*\n          GetPixelAlpha(image,q)*opacity),q);\n      else if (opacity > 0)\n        SetPixelAlpha(image,ClampToQuantum((double) QuantumRange*\n          GetPixelAlpha(image,q)/(MagickRealType) opacity),q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n\n  return(status);\n}\n\nstatic MagickBooleanType ApplyPSDOpacityMask(Image *image,const Image *mask,\n  Quantum background,MagickBooleanType revert,ExceptionInfo *exception)\n{\n  Image\n    *complete_mask;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    color;\n\n  ssize_t\n    y;\n\n  if (image->alpha_trait == UndefinedPixelTrait)\n    return(MagickTrue);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  applying opacity mask\");\n  complete_mask=CloneImage(image,0,0,MagickTrue,exception);\n  if (complete_mask == (Image *) NULL)\n    return(MagickFalse);\n  complete_mask->alpha_trait=BlendPixelTrait;\n  GetPixelInfo(complete_mask,&color);\n  color.red=(MagickRealType) background;\n  (void) SetImageColor(complete_mask,&color,exception);\n  status=CompositeImage(complete_mask,mask,OverCompositeOp,MagickTrue,\n    mask->page.x-image->page.x,mask->page.y-image->page.y,exception);\n  if (status == MagickFalse)\n    {\n      complete_mask=DestroyImage(complete_mask);\n      return(status);\n    }\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n#pragma omp parallel for schedule(static) shared(status) \\\n  magick_number_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    Quantum\n      *magick_restrict q;\n\n    Quantum\n      *p;\n\n    ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    p=GetAuthenticPixels(complete_mask,0,y,complete_mask->columns,1,exception);\n    if ((q == (Quantum *) NULL) || (p == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      MagickRealType\n        alpha,\n        intensity;\n\n      alpha=(MagickRealType) GetPixelAlpha(image,q);\n      intensity=GetPixelIntensity(complete_mask,p);\n      if (revert == MagickFalse)\n        SetPixelAlpha(image,ClampToQuantum(intensity*(QuantumScale*alpha)),q);\n      else if (intensity > 0)\n        SetPixelAlpha(image,ClampToQuantum((alpha/intensity)*QuantumRange),q);\n      q+=GetPixelChannels(image);\n      p+=GetPixelChannels(complete_mask);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  complete_mask=DestroyImage(complete_mask);\n  return(status);\n}\n\nstatic void PreservePSDOpacityMask(Image *image,LayerInfo* layer_info,\n  ExceptionInfo *exception)\n{\n  char\n    *key;\n\n  RandomInfo\n    *random_info;\n\n  StringInfo\n    *key_info;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  preserving opacity mask\");\n  random_info=AcquireRandomInfo();\n  key_info=GetRandomKey(random_info,2+1);\n  key=(char *) GetStringInfoDatum(key_info);\n  key[8]=(char) layer_info->mask.background;\n  key[9]='\\0';\n  layer_info->mask.image->page.x+=layer_info->page.x;\n  layer_info->mask.image->page.y+=layer_info->page.y;\n  (void) SetImageRegistry(ImageRegistryType,(const char *) key,\n    layer_info->mask.image,exception);\n  (void) SetImageArtifact(layer_info->image,\"psd:opacity-mask\",\n    (const char *) key);\n  key_info=DestroyStringInfo(key_info);\n  random_info=DestroyRandomInfo(random_info);\n}\n\nstatic ssize_t DecodePSDPixels(const size_t number_compact_pixels,\n  const unsigned char *compact_pixels,const ssize_t depth,\n  const size_t number_pixels,unsigned char *pixels)\n{\n#define CheckNumberCompactPixels \\\n  if (packets == 0) \\\n    return(i); \\\n  packets--\n\n#define CheckNumberPixels(count) \\\n  if (((ssize_t) i + count) > (ssize_t) number_pixels) \\\n    return(i); \\\n  i+=count\n\n  int\n    pixel;\n\n  ssize_t\n    i,\n    j;\n\n  size_t\n    length;\n\n  ssize_t\n    packets;\n\n  packets=(ssize_t) number_compact_pixels;\n  for (i=0; (packets > 1) && (i < (ssize_t) number_pixels); )\n  {\n    packets--;\n    length=(size_t) (*compact_pixels++);\n    if (length == 128)\n      continue;\n    if (length > 128)\n      {\n        length=256-length+1;\n        CheckNumberCompactPixels;\n        pixel=(*compact_pixels++);\n        for (j=0; j < (ssize_t) length; j++)\n        {\n          switch (depth)\n          {\n            case 1:\n            {\n              CheckNumberPixels(8);\n              *pixels++=(pixel >> 7) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 6) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 5) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 4) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 3) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 2) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 1) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 0) & 0x01 ? 0U : 255U;\n              break;\n            }\n            case 2:\n            {\n              CheckNumberPixels(4);\n              *pixels++=(unsigned char) ((pixel >> 6) & 0x03);\n              *pixels++=(unsigned char) ((pixel >> 4) & 0x03);\n              *pixels++=(unsigned char) ((pixel >> 2) & 0x03);\n              *pixels++=(unsigned char) ((pixel & 0x03) & 0x03);\n              break;\n            }\n            case 4:\n            {\n              CheckNumberPixels(2);\n              *pixels++=(unsigned char) ((pixel >> 4) & 0xff);\n              *pixels++=(unsigned char) ((pixel & 0x0f) & 0xff);\n              break;\n            }\n            default:\n            {\n              CheckNumberPixels(1);\n              *pixels++=(unsigned char) pixel;\n              break;\n            }\n          }\n        }\n        continue;\n      }\n    length++;\n    for (j=0; j < (ssize_t) length; j++)\n    {\n      CheckNumberCompactPixels;\n      switch (depth)\n      {\n        case 1:\n        {\n          CheckNumberPixels(8);\n          *pixels++=(*compact_pixels >> 7) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 6) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 5) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 4) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 3) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 2) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 1) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 0) & 0x01 ? 0U : 255U;\n          break;\n        }\n        case 2:\n        {\n          CheckNumberPixels(4);\n          *pixels++=(*compact_pixels >> 6) & 0x03;\n          *pixels++=(*compact_pixels >> 4) & 0x03;\n          *pixels++=(*compact_pixels >> 2) & 0x03;\n          *pixels++=(*compact_pixels & 0x03) & 0x03;\n          break;\n        }\n        case 4:\n        {\n          CheckNumberPixels(2);\n          *pixels++=(*compact_pixels >> 4) & 0xff;\n          *pixels++=(*compact_pixels & 0x0f) & 0xff;\n          break;\n        }\n        default:\n        {\n          CheckNumberPixels(1);\n          *pixels++=(*compact_pixels);\n          break;\n        }\n      }\n      compact_pixels++;\n    }\n  }\n  return(i);\n}\n\nstatic inline LayerInfo *DestroyLayerInfo(LayerInfo *layer_info,\n  const ssize_t number_layers)\n{\n  ssize_t\n    i;\n\n  for (i=0; i<number_layers; i++)\n  {\n    if (layer_info[i].image != (Image *) NULL)\n      layer_info[i].image=DestroyImage(layer_info[i].image);\n    if (layer_info[i].mask.image != (Image *) NULL)\n      layer_info[i].mask.image=DestroyImage(layer_info[i].mask.image);\n    if (layer_info[i].info != (StringInfo *) NULL)\n      layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n  }\n\n  return (LayerInfo *) RelinquishMagickMemory(layer_info);\n}\n\nstatic inline size_t GetPSDPacketSize(const Image *image)\n{\n  if (image->storage_class == PseudoClass)\n    {\n      if (image->colors > 256)\n        return(2);\n    }\n  if (image->depth > 16)\n    return(4);\n  if (image->depth > 8)\n    return(2);\n\n  return(1);\n}\n\nstatic inline MagickSizeType GetPSDSize(const PSDInfo *psd_info,Image *image)\n{\n  if (psd_info->version == 1)\n    return((MagickSizeType) ReadBlobLong(image));\n  return((MagickSizeType) ReadBlobLongLong(image));\n}\n\nstatic inline size_t GetPSDRowSize(Image *image)\n{\n  if (image->depth == 1)\n    return(((image->columns+7)/8)*GetPSDPacketSize(image));\n  else\n    return(image->columns*GetPSDPacketSize(image));\n}\n\nstatic const char *ModeToString(PSDImageType type)\n{\n  switch (type)\n  {\n    case BitmapMode: return \"Bitmap\";\n    case GrayscaleMode: return \"Grayscale\";\n    case IndexedMode: return \"Indexed\";\n    case RGBMode: return \"RGB\";\n    case CMYKMode:  return \"CMYK\";\n    case MultichannelMode: return \"Multichannel\";\n    case DuotoneMode: return \"Duotone\";\n    case LabMode: return \"L*A*B\";\n    default: return \"unknown\";\n  }\n}\n\nstatic MagickBooleanType NegateCMYK(Image *image,ExceptionInfo *exception)\n{\n  ChannelType\n    channel_mask;\n\n  MagickBooleanType\n    status;\n\n  channel_mask=SetImageChannelMask(image,(ChannelType)(AllChannels &~\n    AlphaChannel));\n  status=NegateImage(image,MagickFalse,exception);\n  (void) SetImageChannelMask(image,channel_mask);\n  return(status);\n}\n\nstatic StringInfo *ParseImageResourceBlocks(PSDInfo *psd_info,Image *image,\n  const unsigned char *blocks,size_t length)\n{\n  const unsigned char\n    *p;\n\n  ssize_t\n    offset;\n\n  StringInfo\n    *profile;\n\n  unsigned char\n    name_length;\n\n  unsigned int\n    count;\n\n  unsigned short\n    id,\n    short_sans;\n\n  if (length < 16)\n    return((StringInfo *) NULL);\n  profile=BlobToStringInfo((const unsigned char *) NULL,length);\n  SetStringInfoDatum(profile,blocks);\n  SetStringInfoName(profile,\"8bim\");\n  for (p=blocks; (p >= blocks) && (p < (blocks+length-7)); )\n  {\n    if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      break;\n    p+=4;\n    p=PushShortPixel(MSBEndian,p,&id);\n    p=PushCharPixel(p,&name_length);\n    if ((name_length % 2) == 0)\n      name_length++;\n    p+=name_length;\n    if (p > (blocks+length-4))\n      break;\n    p=PushLongPixel(MSBEndian,p,&count);\n    offset=(ssize_t) count;\n    if (((p+offset) < blocks) || ((p+offset) > (blocks+length)))\n      break;\n    switch (id)\n    {\n      case 0x03ed:\n      {\n        unsigned short\n          resolution;\n\n        /*\n          Resolution info.\n        */\n        if (offset < 16)\n          break;\n        p=PushShortPixel(MSBEndian,p,&resolution);\n        image->resolution.x=(double) resolution;\n        (void) FormatImageProperty(image,\"tiff:XResolution\",\"%*g\",\n          GetMagickPrecision(),image->resolution.x);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        p=PushShortPixel(MSBEndian,p,&resolution);\n        image->resolution.y=(double) resolution;\n        (void) FormatImageProperty(image,\"tiff:YResolution\",\"%*g\",\n          GetMagickPrecision(),image->resolution.y);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        image->units=PixelsPerInchResolution;\n        break;\n      }\n      case 0x0421:\n      {\n        if ((offset > 4) && (*(p+4) == 0))\n          psd_info->has_merged_image=MagickFalse;\n        p+=offset;\n        break;\n      }\n      default:\n      {\n        p+=offset;\n        break;\n      }\n    }\n    if ((offset & 0x01) != 0)\n      p++;\n  }\n  return(profile);\n}\n\nstatic CompositeOperator PSDBlendModeToCompositeOperator(const char *mode)\n{\n  if (mode == (const char *) NULL)\n    return(OverCompositeOp);\n  if (LocaleNCompare(mode,\"norm\",4) == 0)\n    return(OverCompositeOp);\n  if (LocaleNCompare(mode,\"mul \",4) == 0)\n    return(MultiplyCompositeOp);\n  if (LocaleNCompare(mode,\"diss\",4) == 0)\n    return(DissolveCompositeOp);\n  if (LocaleNCompare(mode,\"diff\",4) == 0)\n    return(DifferenceCompositeOp);\n  if (LocaleNCompare(mode,\"dark\",4) == 0)\n    return(DarkenCompositeOp);\n  if (LocaleNCompare(mode,\"lite\",4) == 0)\n    return(LightenCompositeOp);\n  if (LocaleNCompare(mode,\"hue \",4) == 0)\n    return(HueCompositeOp);\n  if (LocaleNCompare(mode,\"sat \",4) == 0)\n    return(SaturateCompositeOp);\n  if (LocaleNCompare(mode,\"colr\",4) == 0)\n    return(ColorizeCompositeOp);\n  if (LocaleNCompare(mode,\"lum \",4) == 0)\n    return(LuminizeCompositeOp);\n  if (LocaleNCompare(mode,\"scrn\",4) == 0)\n    return(ScreenCompositeOp);\n  if (LocaleNCompare(mode,\"over\",4) == 0)\n    return(OverlayCompositeOp);\n  if (LocaleNCompare(mode,\"hLit\",4) == 0)\n    return(HardLightCompositeOp);\n  if (LocaleNCompare(mode,\"sLit\",4) == 0)\n    return(SoftLightCompositeOp);\n  if (LocaleNCompare(mode,\"smud\",4) == 0)\n    return(ExclusionCompositeOp);\n  if (LocaleNCompare(mode,\"div \",4) == 0)\n    return(ColorDodgeCompositeOp);\n  if (LocaleNCompare(mode,\"idiv\",4) == 0)\n    return(ColorBurnCompositeOp);\n  if (LocaleNCompare(mode,\"lbrn\",4) == 0)\n    return(LinearBurnCompositeOp);\n  if (LocaleNCompare(mode,\"lddg\",4) == 0)\n    return(LinearDodgeCompositeOp);\n  if (LocaleNCompare(mode,\"lLit\",4) == 0)\n    return(LinearLightCompositeOp);\n  if (LocaleNCompare(mode,\"vLit\",4) == 0)\n    return(VividLightCompositeOp);\n  if (LocaleNCompare(mode,\"pLit\",4) == 0)\n    return(PinLightCompositeOp);\n  if (LocaleNCompare(mode,\"hMix\",4) == 0)\n    return(HardMixCompositeOp);\n  return(OverCompositeOp);\n}\n\nstatic inline ssize_t ReadPSDString(Image *image,char *p,const size_t length)\n{\n  ssize_t\n    count;\n\n  count=ReadBlob(image,length,(unsigned char *) p);\n  if ((count == (ssize_t) length) && (image->endian != MSBEndian))\n    {\n      char\n        *q;\n\n      q=p+length;\n      for(--q; p < q; ++p, --q)\n      {\n        *p = *p ^ *q,\n        *q = *p ^ *q,\n        *p = *p ^ *q;\n      }\n    }\n  return(count);\n}\n\nstatic inline void SetPSDPixel(Image *image,const PixelChannel channel,\n  const size_t packet_size,const Quantum pixel,Quantum *q,\n  ExceptionInfo *exception)\n{\n  if (image->storage_class == PseudoClass)\n    {\n      PixelInfo\n        *color;\n\n      ssize_t\n        index;\n\n      if (channel == GrayPixelChannel)\n        {\n          index=(ssize_t) pixel;\n          if (packet_size == 1)\n            index=(ssize_t) ScaleQuantumToChar((Quantum) index);\n          index=ConstrainColormapIndex(image,index,exception);\n          SetPixelIndex(image,(Quantum) index,q);\n        }\n      else\n        {\n          index=(ssize_t) GetPixelIndex(image,q);\n          index=ConstrainColormapIndex(image,index,exception);\n        }\n      color=image->colormap+index;\n      if (channel == AlphaPixelChannel)\n        color->alpha=(MagickRealType) pixel;\n      SetPixelViaPixelInfo(image,color,q);\n    }\n  else\n    SetPixelChannel(image,channel,pixel,q);\n}\n\nstatic MagickBooleanType ReadPSDChannelPixels(Image *image,const ssize_t row,\n  const PixelChannel channel,const unsigned char *pixels,\n  ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n\n  const unsigned char\n    *p;\n\n  Quantum\n    *q;\n\n  ssize_t\n    x;\n\n  size_t\n    packet_size;\n\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (Quantum *) NULL)\n    return MagickFalse;\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      if (packet_size == 2)\n        {\n          unsigned short\n            nibble;\n\n          p=PushShortPixel(MSBEndian,p,&nibble);\n          pixel=ScaleShortToQuantum(nibble);\n        }\n      else\n        {\n          MagickFloatType\n            nibble;\n\n          p=PushFloatPixel(MSBEndian,p,&nibble);\n          pixel=ClampToQuantum(((MagickRealType) QuantumRange)*nibble);\n        }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channel,packet_size,pixel,q,exception);\n        q+=GetPixelChannels(image);\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n\n        number_bits=(ssize_t) image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit = 0; bit < (ssize_t) number_bits; bit++)\n        {\n          SetPSDPixel(image,channel,packet_size,(((unsigned char)((ssize_t)pixel))\n            & (0x01 << (7-bit))) != 0 ? 0 : QuantumRange,q,exception);\n          q+=GetPixelChannels(image);\n          x++;\n        }\n        if (x != (ssize_t) image->columns)\n          x--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}\n\nstatic MagickBooleanType ReadPSDChannelRaw(Image *image,const PixelChannel channel,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  size_t\n    row_size;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"      layer data is RAW\");\n\n  row_size=GetPSDRowSize(image);\n  pixels=(unsigned char *) AcquireQuantumMemory(row_size,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  (void) memset(pixels,0,row_size*sizeof(*pixels));\n\n  status=MagickTrue;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    status=MagickFalse;\n\n    count=ReadBlob(image,row_size,pixels);\n    if (count != (ssize_t) row_size)\n      break;\n\n    status=ReadPSDChannelPixels(image,y,channel,pixels,exception);\n    if (status == MagickFalse)\n      break;\n  }\n\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  return(status);\n}\n\nstatic inline MagickOffsetType *ReadPSDRLESizes(Image *image,\n  const PSDInfo *psd_info,const size_t size)\n{\n  MagickOffsetType\n    *sizes;\n\n  ssize_t\n    y;\n\n  sizes=(MagickOffsetType *) AcquireQuantumMemory(size,sizeof(*sizes));\n  if(sizes != (MagickOffsetType *) NULL)\n    {\n      for (y=0; y < (ssize_t) size; y++)\n      {\n        if (psd_info->version == 1)\n          sizes[y]=(MagickOffsetType) ReadBlobShort(image);\n        else\n          sizes[y]=(MagickOffsetType) ReadBlobLong(image);\n      }\n    }\n  return sizes;\n}\n\nstatic MagickBooleanType ReadPSDChannelRLE(Image *image,\n  const PixelChannel channel,MagickOffsetType *sizes,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  size_t\n    length,\n    row_size;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *compact_pixels,\n    *pixels;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"      layer data is RLE compressed\");\n\n  row_size=GetPSDRowSize(image);\n  pixels=(unsigned char *) AcquireQuantumMemory(row_size,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n\n  length=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n    if ((MagickOffsetType) length < sizes[y])\n      length=(size_t) sizes[y];\n\n  if (length > (row_size+2048)) /* arbitrary number */\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowBinaryException(ResourceLimitError,\"InvalidLength\",image->filename);\n    }\n\n  compact_pixels=(unsigned char *) AcquireQuantumMemory(length,sizeof(*pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n\n  (void) memset(compact_pixels,0,length*sizeof(*compact_pixels));\n\n  status=MagickTrue;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    status=MagickFalse;\n\n    count=ReadBlob(image,(size_t) sizes[y],compact_pixels);\n    if (count != (ssize_t) sizes[y])\n      break;\n\n    count=DecodePSDPixels((size_t) sizes[y],compact_pixels,\n      (ssize_t) (image->depth == 1 ? 123456 : image->depth),row_size,pixels);\n    if (count != (ssize_t) row_size)\n      break;\n\n    status=ReadPSDChannelPixels(image,y,channel,pixels,exception);\n    if (status == MagickFalse)\n      break;\n  }\n\n  compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  return(status);\n}\n\n#ifdef MAGICKCORE_ZLIB_DELEGATE\nstatic void Unpredict8Bit(const Image *image,unsigned char *pixels,\n  const size_t count,const size_t row_size)\n{\n  unsigned char\n    *p;\n\n  size_t\n    length,\n    remaining;\n\n  p=pixels;\n  remaining=count;\n  while (remaining > 0)\n  {\n    length=image->columns;\n    while (--length)\n    {\n      *(p+1)+=*p;\n      p++;\n    }\n    p++;\n    remaining-=row_size;\n  }\n}\n\nstatic void Unpredict16Bit(const Image *image,unsigned char *pixels,\n  const size_t count,const size_t row_size)\n{\n  unsigned char\n    *p;\n\n  size_t\n    length,\n    remaining;\n\n  p=pixels;\n  remaining=count;\n  while (remaining > 0)\n  {\n    length=image->columns;\n    while (--length)\n    {\n      p[2]+=p[0]+((p[1]+p[3]) >> 8);\n      p[3]+=p[1];\n      p+=2;\n    }\n    p+=2;\n    remaining-=row_size;\n  }\n}\n\nstatic void Unpredict32Bit(const Image *image,unsigned char *pixels,\n  unsigned char *output_pixels,const size_t row_size)\n{\n  unsigned char\n    *p,\n    *q;\n\n  ssize_t\n    y;\n\n  size_t\n    offset1,\n    offset2,\n    offset3,\n    remaining;\n\n  unsigned char\n    *start;\n\n  offset1=image->columns;\n  offset2=2*offset1;\n  offset3=3*offset1;\n  p=pixels;\n  q=output_pixels;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    start=p;\n    remaining=row_size;\n    while (--remaining)\n    {\n      *(p+1)+=*p;\n      p++;\n    }\n\n    p=start;\n    remaining=image->columns;\n    while (remaining--)\n    {\n      *(q++)=*p;\n      *(q++)=*(p+offset1);\n      *(q++)=*(p+offset2);\n      *(q++)=*(p+offset3);\n\n      p++;\n    }\n    p=start+row_size;\n  }\n}\n\nstatic MagickBooleanType ReadPSDChannelZip(Image *image,\n  const PixelChannel channel,const PSDCompressionType compression,\n  const size_t compact_size,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  unsigned char\n    *p;\n\n  size_t\n    count,\n    packet_size,\n    row_size;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *compact_pixels,\n    *pixels;\n\n  z_stream\n    stream;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"      layer data is ZIP compressed\");\n\n  if ((MagickSizeType) compact_size > GetBlobSize(image))\n    ThrowBinaryException(CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  compact_pixels=(unsigned char *) AcquireQuantumMemory(compact_size,\n    sizeof(*compact_pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n\n  packet_size=GetPSDPacketSize(image);\n  row_size=image->columns*packet_size;\n  count=image->rows*row_size;\n\n  pixels=(unsigned char *) AcquireQuantumMemory(count,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    {\n      compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  if (ReadBlob(image,compact_size,compact_pixels) != (ssize_t) compact_size)\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n      ThrowBinaryException(CorruptImageError,\"UnexpectedEndOfFile\",\n        image->filename);\n    }\n\n  memset(&stream,0,sizeof(stream));\n  stream.data_type=Z_BINARY;\n  stream.next_in=(Bytef *)compact_pixels;\n  stream.avail_in=(uInt) compact_size;\n  stream.next_out=(Bytef *)pixels;\n  stream.avail_out=(uInt) count;\n\n  if (inflateInit(&stream) == Z_OK)\n    {\n      int\n        ret;\n\n      while (stream.avail_out > 0)\n      {\n        ret=inflate(&stream,Z_SYNC_FLUSH);\n        if ((ret != Z_OK) && (ret != Z_STREAM_END))\n          {\n            (void) inflateEnd(&stream);\n            compact_pixels=(unsigned char *) RelinquishMagickMemory(\n              compact_pixels);\n            pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n            return(MagickFalse);\n          }\n        if (ret == Z_STREAM_END)\n          break;\n      }\n      (void) inflateEnd(&stream);\n    }\n\n  if (compression == ZipWithPrediction)\n    {\n      if (packet_size == 1)\n        Unpredict8Bit(image,pixels,count,row_size);\n      else if (packet_size == 2)\n        Unpredict16Bit(image,pixels,count,row_size);\n      else if (packet_size == 4)\n      {\n        unsigned char\n          *output_pixels;\n\n        output_pixels=(unsigned char *) AcquireQuantumMemory(count,\n          sizeof(*output_pixels));\n        if (pixels == (unsigned char *) NULL)\n          {\n            compact_pixels=(unsigned char *) RelinquishMagickMemory(\n              compact_pixels);\n            pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n            ThrowBinaryException(ResourceLimitError,\n              \"MemoryAllocationFailed\",image->filename);\n          }\n        Unpredict32Bit(image,pixels,output_pixels,row_size);\n        pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n        pixels=output_pixels;\n      }\n    }\n\n  status=MagickTrue;\n  p=pixels;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    status=ReadPSDChannelPixels(image,y,channel,p,exception);\n    if (status == MagickFalse)\n      break;\n\n    p+=row_size;\n  }\n\n  compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  return(status);\n}\n#endif\n\nstatic MagickBooleanType ReadPSDChannel(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,LayerInfo* layer_info,\n  const size_t channel_index,const PSDCompressionType compression,\n  ExceptionInfo *exception)\n{\n  Image\n    *channel_image,\n    *mask;\n\n  MagickOffsetType\n    end_offset,\n    offset;\n\n  MagickBooleanType\n    status;\n\n  PixelChannel\n    channel;\n\n  end_offset=(MagickOffsetType) layer_info->channel_info[channel_index].size-2;\n  if (layer_info->channel_info[channel_index].supported == MagickFalse)\n    {\n      (void) SeekBlob(image,end_offset,SEEK_CUR);\n      return(MagickTrue);\n    }\n  channel_image=image;\n  channel=layer_info->channel_info[channel_index].channel;\n  mask=(Image *) NULL;\n  if (channel == ReadMaskPixelChannel)\n    {\n      const char\n        *option;\n\n      /*\n        Ignore mask that is not a user supplied layer mask, if the mask is\n        disabled or if the flags have unsupported values.\n      */\n      option=GetImageOption(image_info,\"psd:preserve-opacity-mask\");\n      if ((layer_info->mask.flags > 2) || ((layer_info->mask.flags & 0x02) &&\n           (IsStringTrue(option) == MagickFalse)) ||\n           (layer_info->mask.page.width < 1) ||\n           (layer_info->mask.page.height < 1))\n        {\n          (void) SeekBlob(image,end_offset,SEEK_CUR);\n          return(MagickTrue);\n        }\n      mask=CloneImage(image,layer_info->mask.page.width,\n        layer_info->mask.page.height,MagickFalse,exception);\n      if (mask != (Image *) NULL)\n        {\n          (void) ResetImagePixels(mask,exception);\n          (void) SetImageType(mask,GrayscaleType,exception);\n          channel_image=mask;\n          channel=GrayPixelChannel;\n        }\n    }\n\n  offset=TellBlob(image);\n  status=MagickFalse;\n  switch(compression)\n  {\n    case Raw:\n      status=ReadPSDChannelRaw(channel_image,channel,exception);\n      break;\n    case RLE:\n      {\n        MagickOffsetType\n          *sizes;\n\n        sizes=ReadPSDRLESizes(channel_image,psd_info,channel_image->rows);\n        if (sizes == (MagickOffsetType *) NULL)\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        status=ReadPSDChannelRLE(channel_image,channel,sizes,exception);\n        sizes=(MagickOffsetType *) RelinquishMagickMemory(sizes);\n      }\n      break;\n    case ZipWithPrediction:\n    case ZipWithoutPrediction:\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n      status=ReadPSDChannelZip(channel_image,channel,compression,\n        (const size_t) end_offset,exception);\n#else\n      (void) ThrowMagickException(exception,GetMagickModule(),\n          MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\n            \"'%s' (ZLIB)\",image->filename);\n#endif\n      break;\n    default:\n      (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,\n        \"CompressionNotSupported\",\"'%.20g'\",(double) compression);\n      break;\n  }\n\n  (void) SeekBlob(image,offset+end_offset,SEEK_SET);\n  if (status == MagickFalse)\n    {\n      if (mask != (Image *) NULL)\n        (void) DestroyImage(mask);\n      ThrowBinaryException(CoderError,\"UnableToDecompressImage\",\n        image->filename);\n    }\n  if (mask != (Image *) NULL)\n    {\n      if (layer_info->mask.image != (Image *) NULL)\n        layer_info->mask.image=DestroyImage(layer_info->mask.image);\n      layer_info->mask.image=mask;\n    }\n  return(status);\n}\n\nstatic MagickBooleanType GetPixelChannelFromPsdIndex(const PSDInfo *psd_info,\n  ssize_t index,PixelChannel *channel)\n{\n  *channel=RedPixelChannel;\n  switch (psd_info->mode)\n  {\n    case BitmapMode:\n    case IndexedMode:\n    case GrayscaleMode:\n    {\n      if (index == 1)\n        index=-1;\n      else if (index > 1)\n        index=StartMetaPixelChannel+index-2;\n      break;\n    }\n    case LabMode:\n    case MultichannelMode:\n    case RGBMode:\n    {\n      if (index == 3)\n        index=-1;\n      else if (index > 3)\n        index=StartMetaPixelChannel+index-4;\n      break;\n    }\n    case CMYKMode:\n    {\n      if (index == 4)\n        index=-1;\n      else if (index > 4)\n        index=StartMetaPixelChannel+index-5;\n      break;\n    }\n  }\n  if ((index < -2) || (index >= MaxPixelChannels))\n    return(MagickFalse);\n  if (index == -1)\n    *channel=AlphaPixelChannel;\n  else if (index == -2)\n    *channel=ReadMaskPixelChannel;\n  else\n    *channel=(PixelChannel) index;\n  return(MagickTrue);\n}\n\nstatic void SetPsdMetaChannels(Image *image,const PSDInfo *psd_info,\n  const unsigned short channels,ExceptionInfo *exception)\n{\n  ssize_t\n    number_meta_channels;\n\n  number_meta_channels=(ssize_t) channels-psd_info->min_channels;\n  if (image->alpha_trait == BlendPixelTrait)\n    number_meta_channels--;\n  if (number_meta_channels > 0)\n    (void) SetPixelMetaChannels(image,(size_t) number_meta_channels,exception);\n}\n\nstatic MagickBooleanType ReadPSDLayer(Image *image,const ImageInfo *image_info,\n  const PSDInfo *psd_info,LayerInfo* layer_info,ExceptionInfo *exception)\n{\n  char\n    message[MagickPathExtent];\n\n  MagickBooleanType\n    status;\n\n  PSDCompressionType\n    compression;\n\n  ssize_t\n    j;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    setting up new layer image\");\n  if (psd_info->mode != IndexedMode)\n    (void) SetImageBackgroundColor(layer_info->image,exception);\n  layer_info->image->compose=PSDBlendModeToCompositeOperator(\n    layer_info->blendkey);\n  if (layer_info->visible == MagickFalse)\n    layer_info->image->compose=NoCompositeOp;\n  /*\n    Set up some hidden attributes for folks that need them.\n  */\n  (void) FormatLocaleString(message,MagickPathExtent,\"%.20g\",\n    (double) layer_info->page.x);\n  (void) SetImageArtifact(layer_info->image,\"psd:layer.x\",message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"%.20g\",\n    (double) layer_info->page.y);\n  (void) SetImageArtifact(layer_info->image,\"psd:layer.y\",message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"%.20g\",(double)\n    layer_info->opacity);\n  (void) SetImageArtifact(layer_info->image,\"psd:layer.opacity\",message);\n  (void) SetImageProperty(layer_info->image,\"label\",(char *) layer_info->name,\n    exception);\n\n  SetPsdMetaChannels(layer_info->image,psd_info,layer_info->channels,exception);\n  status=MagickTrue;\n  for (j=0; j < (ssize_t) layer_info->channels; j++)\n  {\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    reading data for channel %.20g\",(double) j);\n\n    compression=(PSDCompressionType) ReadBlobShort(layer_info->image);\n    layer_info->image->compression=ConvertPSDCompression(compression);\n\n    status=ReadPSDChannel(layer_info->image,image_info,psd_info,layer_info,\n      (size_t) j,compression,exception);\n\n    if (status == MagickFalse)\n      break;\n  }\n\n  if (status != MagickFalse)\n    status=ApplyPSDLayerOpacity(layer_info->image,layer_info->opacity,\n      MagickFalse,exception);\n\n  if ((status != MagickFalse) &&\n      (layer_info->image->colorspace == CMYKColorspace))\n    status=NegateCMYK(layer_info->image,exception);\n\n  if ((status != MagickFalse) && (layer_info->mask.image != (Image *) NULL))\n    {\n      const char\n        *option;\n\n      layer_info->mask.image->page.x=layer_info->mask.page.x;\n      layer_info->mask.image->page.y=layer_info->mask.page.y;\n      /* Do not composite the mask when it is disabled */\n      if ((layer_info->mask.flags & 0x02) == 0x02)\n        layer_info->mask.image->compose=NoCompositeOp;\n      else\n        status=ApplyPSDOpacityMask(layer_info->image,layer_info->mask.image,\n          layer_info->mask.background == 0 ? 0 : QuantumRange,MagickFalse,\n          exception);\n      option=GetImageOption(image_info,\"psd:preserve-opacity-mask\");\n      if (IsStringTrue(option) != MagickFalse)\n        PreservePSDOpacityMask(image,layer_info,exception);\n      layer_info->mask.image=DestroyImage(layer_info->mask.image);\n    }\n\n  return(status);\n}\n\nstatic MagickBooleanType CheckPSDChannels(const Image *image,\n  const PSDInfo *psd_info,LayerInfo *layer_info)\n{\n  int\n    channel_type;\n\n  size_t\n    blob_size;\n\n  ssize_t\n    i;\n\n  if (layer_info->channels < psd_info->min_channels)\n    return(MagickFalse);\n  channel_type=RedChannel;\n  if (psd_info->min_channels >= 3)\n    channel_type|=(GreenChannel | BlueChannel);\n  if (psd_info->min_channels >= 4)\n    channel_type|=BlackChannel;\n  blob_size=(size_t) GetBlobSize(image);\n  for (i=0; i < (ssize_t) layer_info->channels; i++)\n  {\n    PixelChannel\n      channel;\n\n    if (layer_info->channel_info[i].size >= blob_size)\n      return(MagickFalse);\n    if (layer_info->channel_info[i].supported == MagickFalse)\n      continue;\n    channel=layer_info->channel_info[i].channel;\n    if ((i == 0) && (psd_info->mode == IndexedMode) &&\n        (channel != RedPixelChannel))\n      return(MagickFalse);\n    if (channel == AlphaPixelChannel)\n      {\n        channel_type|=AlphaChannel;\n        continue;\n      }\n    if (channel == RedPixelChannel)\n      channel_type&=~RedChannel;\n    else if (channel == GreenPixelChannel)\n      channel_type&=~GreenChannel;\n    else if (channel == BluePixelChannel)\n      channel_type&=~BlueChannel;\n    else if (channel == BlackPixelChannel)\n      channel_type&=~BlackChannel;\n  }\n  if (channel_type == 0)\n    return(MagickTrue);\n  if ((channel_type == AlphaChannel) &&\n      (layer_info->channels >= psd_info->min_channels + 1))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic void AttachPSDLayers(Image *image,LayerInfo *layer_info,\n  ssize_t number_layers)\n{\n  ssize_t\n    i;\n\n  ssize_t\n    j;\n\n  for (i=0; i < number_layers; i++)\n  {\n    if (layer_info[i].image == (Image *) NULL)\n      {\n        for (j=i; j < number_layers - 1; j++)\n          layer_info[j] = layer_info[j+1];\n        number_layers--;\n        i--;\n      }\n  }\n  if (number_layers == 0)\n    {\n      layer_info=(LayerInfo *) RelinquishMagickMemory(layer_info);\n      return;\n    }\n  for (i=0; i < number_layers; i++)\n  {\n    if (i > 0)\n      layer_info[i].image->previous=layer_info[i-1].image;\n    if (i < (number_layers-1))\n      layer_info[i].image->next=layer_info[i+1].image;\n    layer_info[i].image->page=layer_info[i].page;\n  }\n  image->next=layer_info[0].image;\n  layer_info[0].image->previous=image;\n  layer_info=(LayerInfo *) RelinquishMagickMemory(layer_info);\n}\n\nstatic inline MagickBooleanType PSDSkipImage(const PSDInfo *psd_info,\n  const ImageInfo *image_info,const size_t index)\n{\n  if (psd_info->has_merged_image == MagickFalse)\n    return(MagickFalse);\n  if (image_info->number_scenes == 0)\n    return(MagickFalse);\n  if (index < image_info->scene)\n    return(MagickTrue);\n  if (index > image_info->scene+image_info->number_scenes-1)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic void CheckMergedImageAlpha(const PSDInfo *psd_info,Image *image)\n{\n  /*\n    The number of layers cannot be used to determine if the merged image\n    contains an alpha channel. So we enable it when we think we should.\n  */\n  if (((psd_info->mode == GrayscaleMode) && (psd_info->channels > 1)) ||\n      ((psd_info->mode == RGBMode) && (psd_info->channels > 3)) ||\n      ((psd_info->mode == CMYKMode) && (psd_info->channels > 4)))\n    image->alpha_trait=BlendPixelTrait;\n}\n\nstatic void ParseAdditionalInfo(LayerInfo *layer_info)\n{\n  char\n    key[5];\n\n  size_t\n    remaining_length;\n\n  unsigned char\n    *p;\n\n  unsigned int\n    size;\n\n  p=GetStringInfoDatum(layer_info->info);\n  remaining_length=GetStringInfoLength(layer_info->info);\n  while (remaining_length >= 12)\n  {\n    /* skip over signature */\n    p+=4;\n    key[0]=(char) (*p++);\n    key[1]=(char) (*p++);\n    key[2]=(char) (*p++);\n    key[3]=(char) (*p++);\n    key[4]='\\0';\n    size=(unsigned int) (*p++) << 24;\n    size|=(unsigned int) (*p++) << 16;\n    size|=(unsigned int) (*p++) << 8;\n    size|=(unsigned int) (*p++);\n    size=size & 0xffffffff;\n    remaining_length-=12;\n    if ((size_t) size > remaining_length)\n      break;\n    if (LocaleNCompare(key,\"luni\",sizeof(key)) == 0)\n      {\n        unsigned char\n          *name;\n\n        unsigned int\n          length;\n\n        length=(unsigned int) (*p++) << 24;\n        length|=(unsigned int) (*p++) << 16;\n        length|=(unsigned int) (*p++) << 8;\n        length|=(unsigned int) (*p++);\n        if (length * 2 > size - 4)\n          break;\n        if (sizeof(layer_info->name) <= length)\n          break;\n        name=layer_info->name;\n        while (length > 0)\n        {\n          /* Only ASCII strings are supported */\n          if (*p++ != '\\0')\n            break;\n          *name++=*p++;\n          length--;\n        }\n        if (length == 0)\n          *name='\\0';\n        break;\n      }\n    else\n      p+=size;\n    remaining_length-=(size_t) size;\n  }\n}\n\nstatic MagickSizeType GetLayerInfoSize(const PSDInfo *psd_info,Image *image)\n{\n  char\n    type[4];\n\n  MagickSizeType\n    size;\n\n  ssize_t\n    count;\n\n  size=GetPSDSize(psd_info,image);\n  if (size != 0)\n    return(size);\n  (void) ReadBlobLong(image);\n  count=ReadPSDString(image,type,4);\n  if ((count != 4) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n    return(0);\n  count=ReadPSDString(image,type,4);\n  if ((count == 4) && ((LocaleNCompare(type,\"Mt16\",4) == 0) ||\n      (LocaleNCompare(type,\"Mt32\",4) == 0) ||\n      (LocaleNCompare(type,\"Mtrn\",4) == 0)))\n    {\n      size=GetPSDSize(psd_info,image);\n      if (size != 0)\n        return(0);\n      image->alpha_trait=BlendPixelTrait;\n      count=ReadPSDString(image,type,4);\n      if ((count != 4) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n        return(0);\n      count=ReadPSDString(image,type,4);\n    }\n  if ((count == 4) && ((LocaleNCompare(type,\"Lr16\",4) == 0) ||\n      (LocaleNCompare(type,\"Lr32\",4) == 0)))\n    size=GetPSDSize(psd_info,image);\n  return(size);\n}\n\nstatic MagickBooleanType ReadPSDLayersInternal(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,\n  const MagickBooleanType skip_layers,ExceptionInfo *exception)\n{\n  char\n    type[4];\n\n  LayerInfo\n    *layer_info;\n\n  MagickSizeType\n    size;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    count,\n    index,\n    i,\n    j,\n    number_layers;\n\n  size=GetLayerInfoSize(psd_info,image);\n  if (size == 0)\n    {\n      CheckMergedImageAlpha(psd_info,image);\n      return(MagickTrue);\n    }\n\n  layer_info=(LayerInfo *) NULL;\n  number_layers=(ssize_t) ReadBlobSignedShort(image);\n\n  if (number_layers < 0)\n    {\n      /*\n        The first alpha channel in the merged result contains the\n        transparency data for the merged result.\n      */\n      number_layers=MagickAbsoluteValue(number_layers);\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  negative layer count corrected for\");\n      image->alpha_trait=BlendPixelTrait;\n    }\n\n  /*\n    We only need to know if the image has an alpha channel\n  */\n  if (skip_layers != MagickFalse)\n    return(MagickTrue);\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  image contains %.20g layers\",(double) number_layers);\n\n  if (number_layers == 0)\n    ThrowBinaryException(CorruptImageError,\"InvalidNumberOfLayers\",\n      image->filename);\n\n  layer_info=(LayerInfo *) AcquireQuantumMemory((size_t) number_layers,\n    sizeof(*layer_info));\n  if (layer_info == (LayerInfo *) NULL)\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  allocation of LayerInfo failed\");\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  (void) memset(layer_info,0,(size_t) number_layers*sizeof(*layer_info));\n\n  for (i=0; i < number_layers; i++)\n  {\n    ssize_t\n      top,\n      left,\n      bottom,\n      right;\n\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  reading layer #%.20g\",(double) i+1);\n    top=(ssize_t) ReadBlobSignedLong(image);\n    left=(ssize_t) ReadBlobSignedLong(image);\n    bottom=(ssize_t) ReadBlobSignedLong(image);\n    right=(ssize_t) ReadBlobSignedLong(image);\n    if ((right < left) || (bottom < top))\n      {\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n        ThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\n          image->filename);\n      }\n    layer_info[i].page.y=top;\n    layer_info[i].page.x=left;\n    layer_info[i].page.width=(size_t) (right-left);\n    layer_info[i].page.height=(size_t) (bottom-top);\n    layer_info[i].channels=ReadBlobShort(image);\n    if (layer_info[i].channels > MaxPSDChannels)\n      {\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n        ThrowBinaryException(CorruptImageError,\"MaximumChannelsExceeded\",\n          image->filename);\n      }\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g\",\n        (double) layer_info[i].page.x,(double) layer_info[i].page.y,\n        (double) layer_info[i].page.height,(double)\n        layer_info[i].page.width,(double) layer_info[i].channels);\n    for (j=0; j < (ssize_t) layer_info[i].channels; j++)\n    {\n      layer_info[i].channel_info[j].supported=GetPixelChannelFromPsdIndex(\n        psd_info,(ssize_t) ReadBlobSignedShort(image),\n        &layer_info[i].channel_info[j].channel);\n      layer_info[i].channel_info[j].size=(size_t) GetPSDSize(psd_info,\n        image);\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    channel[%.20g]: type=%.20g, size=%.20g\",(double) j,\n          (double) layer_info[i].channel_info[j].channel,\n          (double) layer_info[i].channel_info[j].size);\n    }\n    if (CheckPSDChannels(image,psd_info,&layer_info[i]) == MagickFalse)\n      {\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n        ThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\n          image->filename);\n      }\n    count=ReadPSDString(image,type,4);\n    if ((count != 4) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  layer type was %.4s instead of 8BIM\", type);\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n        ThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\n          image->filename);\n      }\n    count=ReadPSDString(image,layer_info[i].blendkey,4);\n    if (count != 4)\n      {\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n        ThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\n          image->filename);\n      }\n    layer_info[i].opacity=(Quantum) ScaleCharToQuantum((unsigned char)\n      ReadBlobByte(image));\n    layer_info[i].clipping=(unsigned char) ReadBlobByte(image);\n    layer_info[i].flags=(unsigned char) ReadBlobByte(image);\n    layer_info[i].visible=!(layer_info[i].flags & 0x02);\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s\",\n        layer_info[i].blendkey,(double) layer_info[i].opacity,\n        layer_info[i].clipping ? \"true\" : \"false\",layer_info[i].flags,\n        layer_info[i].visible ? \"true\" : \"false\");\n    (void) ReadBlobByte(image);  /* filler */\n\n    size=ReadBlobLong(image);\n    if (size != 0)\n      {\n        MagickSizeType\n          combined_length,\n          length;\n\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    layer contains additional info\");\n        length=ReadBlobLong(image);\n        combined_length=length+4;\n        if (length != 0)\n          {\n            /*\n              Layer mask info.\n            */\n            layer_info[i].mask.page.y=(ssize_t) ReadBlobSignedLong(image);\n            layer_info[i].mask.page.x=(ssize_t) ReadBlobSignedLong(image);\n            layer_info[i].mask.page.height=(size_t)\n              (ReadBlobSignedLong(image)-layer_info[i].mask.page.y);\n            layer_info[i].mask.page.width=(size_t) (\n              ReadBlobSignedLong(image)-layer_info[i].mask.page.x);\n            layer_info[i].mask.background=(unsigned char) ReadBlobByte(\n              image);\n            layer_info[i].mask.flags=(unsigned char) ReadBlobByte(image);\n            if (!(layer_info[i].mask.flags & 0x01))\n              {\n                layer_info[i].mask.page.y=layer_info[i].mask.page.y-\n                  layer_info[i].page.y;\n                layer_info[i].mask.page.x=layer_info[i].mask.page.x-\n                  layer_info[i].page.x;\n              }\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g\",\n                (double) layer_info[i].mask.page.x,(double)\n                layer_info[i].mask.page.y,(double)\n                layer_info[i].mask.page.width,(double)\n                layer_info[i].mask.page.height,(double) ((MagickOffsetType)\n                length)-18);\n            /*\n              Skip over the rest of the layer mask information.\n            */\n            if (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)\n              {\n                layer_info=DestroyLayerInfo(layer_info,number_layers);\n                ThrowBinaryException(CorruptImageError,\n                  \"UnexpectedEndOfFile\",image->filename);\n              }\n          }\n        length=ReadBlobLong(image);\n        combined_length+=length+4;\n        if (length != 0)\n          {\n            /*\n              Layer blending ranges info.\n            */\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      layer blending ranges: length=%.20g\",(double)\n                ((MagickOffsetType) length));\n            if (DiscardBlobBytes(image,length) == MagickFalse)\n              {\n                layer_info=DestroyLayerInfo(layer_info,number_layers);\n                ThrowBinaryException(CorruptImageError,\n                  \"UnexpectedEndOfFile\",image->filename);\n              }\n          }\n        /*\n          Layer name.\n        */\n        length=(MagickSizeType) (unsigned char) ReadBlobByte(image);\n        combined_length+=length+1;\n        if (length > 0)\n          (void) ReadBlob(image,(size_t) length++,layer_info[i].name);\n        layer_info[i].name[length]='\\0';\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"      layer name: %s\",layer_info[i].name);\n        if ((length % 4) != 0)\n          {\n            length=4-(length % 4);\n            combined_length+=length;\n            /* Skip over the padding of the layer name */\n            if (DiscardBlobBytes(image,length) == MagickFalse)\n              {\n                layer_info=DestroyLayerInfo(layer_info,number_layers);\n                ThrowBinaryException(CorruptImageError,\n                  \"UnexpectedEndOfFile\",image->filename);\n              }\n          }\n        length=(MagickSizeType) size-combined_length;\n        if (length > 0)\n          {\n            unsigned char\n              *info;\n\n            if (length > GetBlobSize(image))\n              {\n                layer_info=DestroyLayerInfo(layer_info,number_layers);\n                ThrowBinaryException(CorruptImageError,\n                  \"InsufficientImageDataInFile\",image->filename);\n              }\n            layer_info[i].info=AcquireStringInfo((const size_t) length);\n            info=GetStringInfoDatum(layer_info[i].info);\n            (void) ReadBlob(image,(const size_t) length,info);\n            ParseAdditionalInfo(&layer_info[i]);\n          }\n      }\n  }\n\n  for (i=0; i < number_layers; i++)\n  {\n    if ((layer_info[i].page.width == 0) || (layer_info[i].page.height == 0))\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"      layer data is empty\");\n        if (layer_info[i].info != (StringInfo *) NULL)\n          layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n        continue;\n      }\n\n    /*\n      Allocate layered image.\n    */\n    layer_info[i].image=CloneImage(image,layer_info[i].page.width,\n      layer_info[i].page.height,MagickFalse,exception);\n    if (layer_info[i].image == (Image *) NULL)\n      {\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  allocation of image for layer %.20g failed\",(double) i);\n        ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n          image->filename);\n      }\n    for (j=0; j < (ssize_t) layer_info[i].channels; j++)\n    {\n      if (layer_info[i].channel_info[j].channel == AlphaPixelChannel)\n        {\n          layer_info[i].image->alpha_trait=BlendPixelTrait;\n          break;\n        }\n    }\n    if (layer_info[i].info != (StringInfo *) NULL)\n      {\n        (void) SetImageProfile(layer_info[i].image,\"psd:additional-info\",\n          layer_info[i].info,exception);\n        layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n      }\n  }\n  if (image_info->ping != MagickFalse)\n    {\n      AttachPSDLayers(image,layer_info,number_layers);\n      return(MagickTrue);\n    }\n  status=MagickTrue;\n  index=0;\n  for (i=0; i < number_layers; i++)\n  {\n    if ((layer_info[i].image == (Image *) NULL) ||\n        (PSDSkipImage(psd_info, image_info,++index) != MagickFalse))\n      {\n        for (j=0; j < (ssize_t) layer_info[i].channels; j++)\n        {\n          if (DiscardBlobBytes(image,(MagickSizeType)\n              layer_info[i].channel_info[j].size) == MagickFalse)\n            {\n              layer_info=DestroyLayerInfo(layer_info,number_layers);\n              ThrowBinaryException(CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n            }\n        }\n        continue;\n      }\n\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  reading data for layer %.20g\",(double) i);\n\n    status=ReadPSDLayer(image,image_info,psd_info,&layer_info[i],\n      exception);\n    if (status == MagickFalse)\n      break;\n\n    status=SetImageProgress(image,LoadImagesTag,(MagickOffsetType) i,\n      (MagickSizeType) number_layers);\n    if (status == MagickFalse)\n      break;\n  }\n\n  if (status != MagickFalse)\n    AttachPSDLayers(image,layer_info,number_layers);\n  else\n    layer_info=DestroyLayerInfo(layer_info,number_layers);\n\n  return(status);\n}\n\nModuleExport MagickBooleanType ReadPSDLayers(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  status=IsRightsAuthorized(CoderPolicyDomain,ReadPolicyRights,\"PSD\");\n  if (status == MagickFalse)\n    return(MagickTrue);\n  return(ReadPSDLayersInternal(image,image_info,psd_info,MagickFalse,\n    exception));\n}\n\nstatic MagickBooleanType ReadPSDMergedImage(const ImageInfo *image_info,\n  Image *image,const PSDInfo *psd_info,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    *sizes;\n\n  MagickBooleanType\n    status;\n\n  PSDCompressionType\n    compression;\n\n  ssize_t\n    i;\n\n  if ((image_info->number_scenes != 0) && (image_info->scene != 0))\n    return(MagickTrue);\n  compression=(PSDCompressionType) ReadBlobMSBShort(image);\n  image->compression=ConvertPSDCompression(compression);\n\n  if (compression != Raw && compression != RLE)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        TypeWarning,\"CompressionNotSupported\",\"'%.20g'\",(double) compression);\n      return(MagickFalse);\n    }\n\n  sizes=(MagickOffsetType *) NULL;\n  if (compression == RLE)\n    {\n      sizes=ReadPSDRLESizes(image,psd_info,image->rows*psd_info->channels);\n      if (sizes == (MagickOffsetType *) NULL)\n        ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n          image->filename);\n    }\n\n  SetPsdMetaChannels(image,psd_info,psd_info->channels,exception);\n  status=MagickTrue;\n  for (i=0; i < (ssize_t) psd_info->channels; i++)\n  {\n    PixelChannel\n      channel;\n\n    status=GetPixelChannelFromPsdIndex(psd_info,i,&channel);\n    if (status == MagickFalse)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageError,\"MaximumChannelsExceeded\",\"'%.20g'\",(double) i);\n        break;\n      }\n\n    if (compression == RLE)\n      status=ReadPSDChannelRLE(image,channel,sizes+(i*image->rows),exception);\n    else\n      status=ReadPSDChannelRaw(image,channel,exception);\n\n    if (status != MagickFalse)\n      status=SetImageProgress(image,LoadImagesTag,(MagickOffsetType) i,\n        psd_info->channels);\n\n    if (status == MagickFalse)\n      break;\n  }\n\n  if ((status != MagickFalse) && (image->colorspace == CMYKColorspace))\n    status=NegateCMYK(image,exception);\n\n  if (status != MagickFalse)\n    status=CorrectPSDAlphaBlend(image_info,image,exception);\n\n  sizes=(MagickOffsetType *) RelinquishMagickMemory(sizes);\n\n  return(status);\n}\n\nstatic Image *ReadPSDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    skip_layers;\n\n  MagickOffsetType\n    offset;\n\n  MagickSizeType\n    length;\n\n  MagickBooleanType\n    status;\n\n  PSDInfo\n    psd_info;\n\n  ssize_t\n    i;\n\n  size_t\n    image_list_length;\n\n  ssize_t\n    count;\n\n  StringInfo\n    *profile;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read image header.\n  */\n  image->endian=MSBEndian;\n  count=ReadBlob(image,4,(unsigned char *) psd_info.signature);\n  psd_info.version=ReadBlobMSBShort(image);\n  if ((count != 4) || (LocaleNCompare(psd_info.signature,\"8BPS\",4) != 0) ||\n      ((psd_info.version != 1) && (psd_info.version != 2)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  (void) ReadBlob(image,6,psd_info.reserved);\n  psd_info.channels=ReadBlobMSBShort(image);\n  if (psd_info.channels < 1)\n    ThrowReaderException(CorruptImageError,\"MissingImageChannel\");\n  if (psd_info.channels > MaxPSDChannels)\n    ThrowReaderException(CorruptImageError,\"MaximumChannelsExceeded\");\n  psd_info.rows=ReadBlobMSBLong(image);\n  psd_info.columns=ReadBlobMSBLong(image);\n  if ((psd_info.version == 1) && ((psd_info.rows > 30000) ||\n      (psd_info.columns > 30000)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  psd_info.depth=ReadBlobMSBShort(image);\n  if ((psd_info.depth != 1) && (psd_info.depth != 8) &&\n      (psd_info.depth != 16) && (psd_info.depth != 32))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  psd_info.mode=ReadBlobMSBShort(image);\n  if ((psd_info.mode == IndexedMode) && (psd_info.channels > 3))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Image is %.20g x %.20g with channels=%.20g, depth=%.20g, mode=%s\",\n      (double) psd_info.columns,(double) psd_info.rows,(double)\n      psd_info.channels,(double) psd_info.depth,ModeToString((PSDImageType)\n      psd_info.mode));\n  if (EOFBlob(image) != MagickFalse)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Initialize image.\n  */\n  image->depth=psd_info.depth;\n  image->columns=psd_info.columns;\n  image->rows=psd_info.rows;\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  status=ResetImagePixels(image,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  psd_info.min_channels=3;\n  switch (psd_info.mode)\n  {\n    case LabMode:\n    {\n      (void) SetImageColorspace(image,LabColorspace,exception);\n      break;\n    }\n    case CMYKMode:\n    {\n      psd_info.min_channels=4;\n      (void) SetImageColorspace(image,CMYKColorspace,exception);\n      break;\n    }\n    case BitmapMode:\n    case GrayscaleMode:\n    case DuotoneMode:\n    {\n      if (psd_info.depth != 32)\n        {\n          status=AcquireImageColormap(image,MagickMin((size_t)\n            (psd_info.depth < 16 ? 256 : 65536), MaxColormapSize),exception);\n          if (status == MagickFalse)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Image colormap allocated\");\n        }\n      psd_info.min_channels=1;\n      (void) SetImageColorspace(image,GRAYColorspace,exception);\n      break;\n    }\n    case IndexedMode:\n    {\n      psd_info.min_channels=1;\n      break;\n    }\n    case MultichannelMode:\n    {\n      if ((psd_info.channels > 0) && (psd_info.channels < 3))\n        {\n          psd_info.min_channels=psd_info.channels;\n          (void) SetImageColorspace(image,GRAYColorspace,exception);\n        }\n      break;\n    }\n  }\n  if (psd_info.channels < psd_info.min_channels)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Read PSD raster colormap only present for indexed and duotone images.\n  */\n  length=ReadBlobMSBLong(image);\n  if ((psd_info.mode == IndexedMode) && (length < 3))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (length != 0)\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  reading colormap\");\n      if ((psd_info.mode == DuotoneMode) || (psd_info.depth == 32))\n        {\n          /*\n            Duotone image data;  the format of this data is undocumented.\n            32 bits per pixel;  the colormap is ignored.\n          */\n          (void) SeekBlob(image,(const MagickOffsetType) length,SEEK_CUR);\n        }\n      else\n        {\n          size_t\n            number_colors;\n\n          /*\n            Read PSD raster colormap.\n          */\n          number_colors=(size_t) length/3;\n          if (number_colors > 65536)\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          if (AcquireImageColormap(image,number_colors,exception) == MagickFalse)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].red=(MagickRealType) ScaleCharToQuantum(\n              (unsigned char) ReadBlobByte(image));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].green=(MagickRealType) ScaleCharToQuantum(\n              (unsigned char) ReadBlobByte(image));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum(\n              (unsigned char) ReadBlobByte(image));\n          image->alpha_trait=UndefinedPixelTrait;\n        }\n    }\n  if ((image->depth == 1) && (image->storage_class != PseudoClass))\n    ThrowReaderException(CorruptImageError, \"ImproperImageHeader\");\n  psd_info.has_merged_image=MagickTrue;\n  profile=(StringInfo *) NULL;\n  length=ReadBlobMSBLong(image);\n  if (length != 0)\n    {\n      unsigned char\n        *blocks;\n\n      /*\n        Image resources block.\n      */\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  reading image resource blocks - %.20g bytes\",(double)\n          ((MagickOffsetType) length));\n      if (length > GetBlobSize(image))\n        ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n      blocks=(unsigned char *) AcquireQuantumMemory((size_t) length,\n        sizeof(*blocks));\n      if (blocks == (unsigned char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      count=ReadBlob(image,(size_t) length,blocks);\n      if ((count != (ssize_t) length) || (length < 4) ||\n          (LocaleNCompare((char *) blocks,\"8BIM\",4) != 0))\n        {\n          blocks=(unsigned char *) RelinquishMagickMemory(blocks);\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n      profile=ParseImageResourceBlocks(&psd_info,image,blocks,(size_t) length);\n      blocks=(unsigned char *) RelinquishMagickMemory(blocks);\n    }\n  /*\n    Layer and mask block.\n  */\n  length=GetPSDSize(&psd_info,image);\n  if (length == 8)\n    {\n      length=ReadBlobMSBLong(image);\n      length=ReadBlobMSBLong(image);\n    }\n  offset=TellBlob(image);\n  skip_layers=MagickFalse;\n  if ((image_info->number_scenes == 1) && (image_info->scene == 0) &&\n      (psd_info.has_merged_image != MagickFalse))\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  read composite only\");\n      skip_layers=MagickTrue;\n    }\n  if (length == 0)\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  image has no layers\");\n    }\n  else\n    {\n      if (ReadPSDLayersInternal(image,image_info,&psd_info,skip_layers,\n            exception) != MagickTrue)\n        {\n          if (profile != (StringInfo *) NULL)\n            profile=DestroyStringInfo(profile);\n          (void) CloseBlob(image);\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n\n      /*\n         Skip the rest of the layer and mask information.\n      */\n      (void) SeekBlob(image,offset+length,SEEK_SET);\n    }\n  /*\n    If we are only \"pinging\" the image, then we're done - so return.\n  */\n  if (EOFBlob(image) != MagickFalse)\n    {\n      if (profile != (StringInfo *) NULL)\n        profile=DestroyStringInfo(profile);\n      ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    }\n  if (image_info->ping != MagickFalse)\n    {\n      if (profile != (StringInfo *) NULL)\n        profile=DestroyStringInfo(profile);\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  /*\n    Read the precombined layer, present for PSD < 4 compatibility.\n  */\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  reading the precombined layer\");\n  image_list_length=GetImageListLength(image);\n  if ((psd_info.has_merged_image != MagickFalse) || (image_list_length == 1))\n    psd_info.has_merged_image=(MagickBooleanType) ReadPSDMergedImage(\n      image_info,image,&psd_info,exception);\n  if ((psd_info.has_merged_image == MagickFalse) && (image_list_length == 1) &&\n      (length != 0))\n    {\n      (void) SeekBlob(image,offset,SEEK_SET);\n      status=ReadPSDLayersInternal(image,image_info,&psd_info,MagickFalse,\n        exception);\n      if (status != MagickTrue)\n        {\n          if (profile != (StringInfo *) NULL)\n            profile=DestroyStringInfo(profile);\n          (void) CloseBlob(image);\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n      image_list_length=GetImageListLength(image);\n    }\n  if (psd_info.has_merged_image == MagickFalse)\n    {\n      Image\n        *merged;\n\n      if (image_list_length == 1)\n        {\n          if (profile != (StringInfo *) NULL)\n            profile=DestroyStringInfo(profile);\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        }\n      image->background_color.alpha=(MagickRealType) TransparentAlpha;\n      image->background_color.alpha_trait=BlendPixelTrait;\n      (void) SetImageBackgroundColor(image,exception);\n      merged=MergeImageLayers(image,FlattenLayer,exception);\n      if (merged == (Image *) NULL)\n        {\n          (void) CloseBlob(image);\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n      ReplaceImageInList(&image,merged);\n    }\n  if (profile != (StringInfo *) NULL)\n    {\n      const char\n        *option;\n\n      Image\n        *next;\n\n      MagickBooleanType\n        replicate_profile;\n\n      option=GetImageOption(image_info,\"psd:replicate-profile\");\n      replicate_profile=IsStringTrue(option);\n      i=0;\n      next=image;\n      while (next != (Image *) NULL)\n      {\n        if (PSDSkipImage(&psd_info,image_info,i++) == MagickFalse)\n          {\n            (void) SetImageProfile(next,GetStringInfoName(profile),profile,\n              exception);\n            if (replicate_profile == MagickFalse)\n              break;\n          }\n        next=next->next;\n      }\n      profile=DestroyStringInfo(profile);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r P S D I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterPSDImage() adds properties for the PSD image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterPSDImage method is:\n%\n%      size_t RegisterPSDImage(void)\n%\n*/\nModuleExport size_t RegisterPSDImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"PSD\",\"PSB\",\"Adobe Large Document Format\");\n  entry->decoder=(DecodeImageHandler *) ReadPSDImage;\n  entry->encoder=(EncodeImageHandler *) WritePSDImage;\n  entry->magick=(IsImageFormatHandler *) IsPSD;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PSD\",\"PSD\",\"Adobe Photoshop bitmap\");\n  entry->decoder=(DecodeImageHandler *) ReadPSDImage;\n  entry->encoder=(EncodeImageHandler *) WritePSDImage;\n  entry->magick=(IsImageFormatHandler *) IsPSD;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r P S D I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterPSDImage() removes format registrations made by the\n%  PSD module from the list of supported formats.\n%\n%  The format of the UnregisterPSDImage method is:\n%\n%      UnregisterPSDImage(void)\n%\n*/\nModuleExport void UnregisterPSDImage(void)\n{\n  (void) UnregisterMagickInfo(\"PSB\");\n  (void) UnregisterMagickInfo(\"PSD\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P S D I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePSDImage() writes an image in the Adobe Photoshop encoded image format.\n%\n%  The format of the WritePSDImage method is:\n%\n%      MagickBooleanType WritePSDImage(const ImageInfo *image_info,Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline ssize_t SetPSDOffset(const PSDInfo *psd_info,Image *image,\n  const size_t offset)\n{\n  if (psd_info->version == 1)\n    return(WriteBlobMSBShort(image,(unsigned short) offset));\n  return(WriteBlobMSBLong(image,(unsigned int) offset));\n}\n\nstatic inline ssize_t WritePSDOffset(const PSDInfo *psd_info,Image *image,\n  const MagickSizeType size,const MagickOffsetType offset)\n{\n  MagickOffsetType\n    current_offset;\n\n  ssize_t\n    result;\n\n  current_offset=TellBlob(image);\n  (void) SeekBlob(image,offset,SEEK_SET);\n  if (psd_info->version == 1)\n    result=WriteBlobMSBShort(image,(unsigned short) size);\n  else\n    result=WriteBlobMSBLong(image,(unsigned int) size);\n  (void) SeekBlob(image,current_offset,SEEK_SET);\n  return(result);\n}\n\nstatic inline ssize_t SetPSDSize(const PSDInfo *psd_info,Image *image,\n  const MagickSizeType size)\n{\n  if (psd_info->version == 1)\n    return(WriteBlobLong(image,(unsigned int) size));\n  return(WriteBlobLongLong(image,size));\n}\n\nstatic inline ssize_t WritePSDSize(const PSDInfo *psd_info,Image *image,\n  const MagickSizeType size,const MagickOffsetType offset)\n{\n  MagickOffsetType\n    current_offset;\n\n  ssize_t\n    result;\n\n  current_offset=TellBlob(image);\n  (void) SeekBlob(image,offset,SEEK_SET);\n  result=SetPSDSize(psd_info,image,size);\n  (void) SeekBlob(image,current_offset,SEEK_SET);\n  return(result);\n}\n\nstatic size_t PSDPackbitsEncodeImage(Image *image,const size_t length,\n  const unsigned char *pixels,unsigned char *compact_pixels,\n  ExceptionInfo *exception)\n{\n  int\n    count;\n\n  ssize_t\n    i,\n    j;\n\n  unsigned char\n    *q;\n\n  unsigned char\n    *packbits;\n\n  /*\n    Compress pixels with Packbits encoding.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(pixels != (unsigned char *) NULL);\n  assert(compact_pixels != (unsigned char *) NULL);\n  packbits=(unsigned char *) AcquireQuantumMemory(128UL,sizeof(*packbits));\n  if (packbits == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  q=compact_pixels;\n  for (i=(ssize_t) length; i != 0; )\n  {\n    switch (i)\n    {\n      case 1:\n      {\n        i--;\n        *q++=(unsigned char) 0;\n        *q++=(*pixels);\n        break;\n      }\n      case 2:\n      {\n        i-=2;\n        *q++=(unsigned char) 1;\n        *q++=(*pixels);\n        *q++=pixels[1];\n        break;\n      }\n      case 3:\n      {\n        i-=3;\n        if ((*pixels == *(pixels+1)) && (*(pixels+1) == *(pixels+2)))\n          {\n            *q++=(unsigned char) ((256-3)+1);\n            *q++=(*pixels);\n            break;\n          }\n        *q++=(unsigned char) 2;\n        *q++=(*pixels);\n        *q++=pixels[1];\n        *q++=pixels[2];\n        break;\n      }\n      default:\n      {\n        if ((*pixels == *(pixels+1)) && (*(pixels+1) == *(pixels+2)))\n          {\n            /*\n              Packed run.\n            */\n            count=3;\n            while (((ssize_t) count < i) && (*pixels == *(pixels+count)))\n            {\n              count++;\n              if (count >= 127)\n                break;\n            }\n            i-=count;\n            *q++=(unsigned char) ((256-count)+1);\n            *q++=(*pixels);\n            pixels+=count;\n            break;\n          }\n        /*\n          Literal run.\n        */\n        count=0;\n        while ((*(pixels+count) != *(pixels+count+1)) ||\n               (*(pixels+count+1) != *(pixels+count+2)))\n        {\n          packbits[count+1]=pixels[count];\n          count++;\n          if (((ssize_t) count >= (i-3)) || (count >= 127))\n            break;\n        }\n        i-=count;\n        *packbits=(unsigned char) (count-1);\n        for (j=0; j <= (ssize_t) count; j++)\n          *q++=packbits[j];\n        pixels+=count;\n        break;\n      }\n    }\n  }\n  *q++=(unsigned char) 128;  /* EOD marker */\n  packbits=(unsigned char *) RelinquishMagickMemory(packbits);\n  return((size_t) (q-compact_pixels));\n}\n\nstatic size_t WriteCompressionStart(const PSDInfo *psd_info,Image *image,\n  const Image *next_image,const CompressionType compression,\n  const ssize_t channels)\n{\n  size_t\n    length;\n\n  ssize_t\n    i,\n    y;\n\n  if (compression == RLECompression)\n    {\n      length=(size_t) WriteBlobShort(image,RLE);\n      for (i=0; i < channels; i++)\n        for (y=0; y < (ssize_t) next_image->rows; y++)\n          length+=SetPSDOffset(psd_info,image,0);\n    }\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n  else if (compression == ZipCompression)\n    length=(size_t) WriteBlobShort(image,ZipWithoutPrediction);\n#endif\n  else\n    length=(size_t) WriteBlobShort(image,Raw);\n  return(length);\n}\n\nstatic size_t WritePSDChannel(const PSDInfo *psd_info,\n  const ImageInfo *image_info,Image *image,Image *next_image,\n  const QuantumType quantum_type, unsigned char *compact_pixels,\n  MagickOffsetType size_offset,const MagickBooleanType separate,\n  const CompressionType compression,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    monochrome;\n\n  QuantumInfo\n    *quantum_info;\n\n  const Quantum\n    *p;\n\n  ssize_t\n    i;\n\n  size_t\n    count,\n    length;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pixels;\n\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n\n  int\n    flush,\n    level;\n\n  unsigned char\n    *compressed_pixels;\n\n  z_stream\n    stream;\n\n  compressed_pixels=(unsigned char *) NULL;\n  flush=Z_NO_FLUSH;\n#endif\n  count=0;\n  if (separate != MagickFalse)\n    {\n      size_offset=TellBlob(image)+2;\n      count+=WriteCompressionStart(psd_info,image,next_image,compression,1);\n    }\n  if (next_image->depth > 8)\n    next_image->depth=16;\n  monochrome=IsImageMonochrome(image) && (image->depth == 1) ?\n    MagickTrue : MagickFalse;\n  quantum_info=AcquireQuantumInfo(image_info,next_image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    return(0);\n  pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n  if (compression == ZipCompression)\n    {\n      compressed_pixels=(unsigned char *) AcquireQuantumMemory(\n        MagickMinBufferExtent,sizeof(*compressed_pixels));\n      if (compressed_pixels == (unsigned char *) NULL)\n        {\n          quantum_info=DestroyQuantumInfo(quantum_info);\n          return(0);\n        }\n      memset(&stream,0,sizeof(stream));\n      stream.data_type=Z_BINARY;\n      level=Z_DEFAULT_COMPRESSION;\n      if ((image_info->quality > 0 && image_info->quality < 10))\n        level=(int) image_info->quality;\n      if (deflateInit(&stream,level) != Z_OK)\n        {\n          quantum_info=DestroyQuantumInfo(quantum_info);\n          compressed_pixels=(unsigned char *) RelinquishMagickMemory(\n            compressed_pixels);\n          return(0);\n        }\n    }\n#endif\n  for (y=0; y < (ssize_t) next_image->rows; y++)\n  {\n    p=GetVirtualPixels(next_image,0,y,next_image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    length=ExportQuantumPixels(next_image,(CacheView *) NULL,quantum_info,\n      quantum_type,pixels,exception);\n    if (monochrome != MagickFalse)\n      for (i=0; i < (ssize_t) length; i++)\n        pixels[i]=(~pixels[i]);\n    if (compression == RLECompression)\n      {\n        length=PSDPackbitsEncodeImage(image,length,pixels,compact_pixels,\n          exception);\n        count+=WriteBlob(image,length,compact_pixels);\n        size_offset+=WritePSDOffset(psd_info,image,length,size_offset);\n      }\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n    else if (compression == ZipCompression)\n      {\n        stream.avail_in=(uInt) length;\n        stream.next_in=(Bytef *) pixels;\n        if (y == (ssize_t) next_image->rows-1)\n          flush=Z_FINISH;\n        do {\n            stream.avail_out=(uInt) MagickMinBufferExtent;\n            stream.next_out=(Bytef *) compressed_pixels;\n            if (deflate(&stream,flush) == Z_STREAM_ERROR)\n              break;\n            length=(size_t) MagickMinBufferExtent-stream.avail_out;\n            if (length > 0)\n              count+=WriteBlob(image,length,compressed_pixels);\n        } while (stream.avail_out == 0);\n      }\n#endif\n    else\n      count+=WriteBlob(image,length,pixels);\n  }\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n  if (compression == ZipCompression)\n    {\n      (void) deflateEnd(&stream);\n      compressed_pixels=(unsigned char *) RelinquishMagickMemory(\n        compressed_pixels);\n    }\n#endif\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  return(count);\n}\n\nstatic unsigned char *AcquireCompactPixels(const Image *image,\n  ExceptionInfo *exception)\n{\n  size_t\n    packet_size;\n\n  unsigned char\n    *compact_pixels;\n\n  packet_size=image->depth > 8UL ? 2UL : 1UL;\n  compact_pixels=(unsigned char *) AcquireQuantumMemory((9*\n    image->columns)+1,packet_size*sizeof(*compact_pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n    }\n  return(compact_pixels);\n}\n\nstatic size_t WritePSDChannels(const PSDInfo *psd_info,\n  const ImageInfo *image_info,Image *image,Image *next_image,\n  MagickOffsetType size_offset,const MagickBooleanType separate,\n  ExceptionInfo *exception)\n{\n  CompressionType\n    compression;\n\n  Image\n    *mask;\n\n  MagickOffsetType\n    rows_offset;\n\n  size_t\n    channels,\n    count,\n    length,\n    offset_length;\n\n  unsigned char\n    *compact_pixels;\n\n  count=0;\n  offset_length=0;\n  rows_offset=0;\n  compact_pixels=(unsigned char *) NULL;\n  compression=next_image->compression;\n  if (image_info->compression != UndefinedCompression)\n    compression=image_info->compression;\n  if (compression == RLECompression)\n    {\n      compact_pixels=AcquireCompactPixels(next_image,exception);\n      if (compact_pixels == (unsigned char *) NULL)\n        return(0);\n    }\n  channels=1;\n  if (separate == MagickFalse)\n    {\n      if ((next_image->storage_class != PseudoClass) ||\n          (IsImageGray(next_image) != MagickFalse))\n        {\n          if (IsImageGray(next_image) == MagickFalse)\n            channels=(size_t) (next_image->colorspace == CMYKColorspace ? 4 :\n              3);\n          if (next_image->alpha_trait != UndefinedPixelTrait)\n            channels++;\n        }\n      rows_offset=TellBlob(image)+2;\n      count+=WriteCompressionStart(psd_info,image,next_image,compression,\n        (ssize_t) channels);\n      offset_length=(next_image->rows*(psd_info->version == 1 ? 2 : 4));\n    }\n  size_offset+=2;\n  if ((next_image->storage_class == PseudoClass) &&\n      (IsImageGray(next_image) == MagickFalse))\n    {\n      length=WritePSDChannel(psd_info,image_info,image,next_image,\n        IndexQuantum,compact_pixels,rows_offset,separate,compression,\n        exception);\n      if (separate != MagickFalse)\n        size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n      else\n        rows_offset+=offset_length;\n      count+=length;\n    }\n  else\n    {\n      if (IsImageGray(next_image) != MagickFalse)\n        {\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            GrayQuantum,compact_pixels,rows_offset,separate,compression,\n            exception);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n        }\n      else\n        {\n          if (next_image->colorspace == CMYKColorspace)\n            (void) NegateCMYK(next_image,exception);\n\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            RedQuantum,compact_pixels,rows_offset,separate,compression,\n            exception);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            GreenQuantum,compact_pixels,rows_offset,separate,compression,\n            exception);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            BlueQuantum,compact_pixels,rows_offset,separate,compression,\n            exception);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n\n          if (next_image->colorspace == CMYKColorspace)\n            {\n              length=WritePSDChannel(psd_info,image_info,image,next_image,\n                BlackQuantum,compact_pixels,rows_offset,separate,compression,\n                exception);\n              if (separate != MagickFalse)\n                size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n              else\n                rows_offset+=offset_length;\n              count+=length;\n            }\n        }\n      if (next_image->alpha_trait != UndefinedPixelTrait)\n        {\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            AlphaQuantum,compact_pixels,rows_offset,separate,compression,\n            exception);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n        }\n    }\n  compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n  if (next_image->colorspace == CMYKColorspace)\n    (void) NegateCMYK(next_image,exception);\n  if (separate != MagickFalse)\n    {\n      const char\n        *property;\n\n      property=GetImageArtifact(next_image,\"psd:opacity-mask\");\n      if (property != (const char *) NULL)\n        {\n          mask=(Image *) GetImageRegistry(ImageRegistryType,property,\n            exception);\n          if (mask != (Image *) NULL)\n            {\n              if (compression == RLECompression)\n                {\n                  compact_pixels=AcquireCompactPixels(mask,exception);\n                  if (compact_pixels == (unsigned char *) NULL)\n                    return(0);\n                }\n              length=WritePSDChannel(psd_info,image_info,image,mask,\n                RedQuantum,compact_pixels,rows_offset,MagickTrue,compression,\n                exception);\n              (void) WritePSDSize(psd_info,image,length,size_offset);\n              count+=length;\n              compact_pixels=(unsigned char *) RelinquishMagickMemory(\n                compact_pixels);\n            }\n        }\n    }\n  return(count);\n}\n\nstatic size_t WritePascalString(Image *image,const char *value,size_t padding)\n{\n  size_t\n    count,\n    length;\n\n  ssize_t\n    i;\n\n  /*\n    Max length is 255.\n  */\n  count=0;\n  length=(strlen(value) > 255UL ) ? 255UL : strlen(value);\n  if (length ==  0)\n    count+=WriteBlobByte(image,0);\n  else\n    {\n      count+=WriteBlobByte(image,(unsigned char) length);\n      count+=WriteBlob(image,length,(const unsigned char *) value);\n    }\n  length++;\n  if ((length % padding) == 0)\n    return(count);\n  for (i=0; i < (ssize_t) (padding-(length % padding)); i++)\n    count+=WriteBlobByte(image,0);\n  return(count);\n}\n\nstatic void WriteResolutionResourceBlock(Image *image)\n{\n  double\n    x_resolution,\n    y_resolution;\n\n  unsigned short\n    units;\n\n  if (image->units == PixelsPerCentimeterResolution)\n    {\n      x_resolution=2.54*65536.0*image->resolution.x+0.5;\n      y_resolution=2.54*65536.0*image->resolution.y+0.5;\n      units=2;\n    }\n  else\n    {\n      x_resolution=65536.0*image->resolution.x+0.5;\n      y_resolution=65536.0*image->resolution.y+0.5;\n      units=1;\n    }\n  (void) WriteBlob(image,4,(const unsigned char *) \"8BIM\");\n  (void) WriteBlobMSBShort(image,0x03ED);\n  (void) WriteBlobMSBShort(image,0);\n  (void) WriteBlobMSBLong(image,16); /* resource size */\n  (void) WriteBlobMSBLong(image,(unsigned int) (x_resolution+0.5));\n  (void) WriteBlobMSBShort(image,units); /* horizontal resolution unit */\n  (void) WriteBlobMSBShort(image,units); /* width unit */\n  (void) WriteBlobMSBLong(image,(unsigned int) (y_resolution+0.5));\n  (void) WriteBlobMSBShort(image,units); /* vertical resolution unit */\n  (void) WriteBlobMSBShort(image,units); /* height unit */\n}\n\nstatic inline size_t WriteChannelSize(const PSDInfo *psd_info,Image *image,\n  const signed short channel)\n{\n  size_t\n    count;\n\n  count=(size_t) WriteBlobShort(image,(const unsigned short) channel);\n  count+=SetPSDSize(psd_info,image,0);\n  return(count);\n}\n\nstatic void RemoveICCProfileFromResourceBlock(StringInfo *bim_profile)\n{\n  const unsigned char\n    *p;\n\n  size_t\n    length;\n\n  unsigned char\n    *datum;\n\n  unsigned int\n    count,\n    long_sans;\n\n  unsigned short\n    id,\n    short_sans;\n\n  length=GetStringInfoLength(bim_profile);\n  if (length < 16)\n    return;\n  datum=GetStringInfoDatum(bim_profile);\n  for (p=datum; (p >= datum) && (p < (datum+length-16)); )\n  {\n    unsigned char\n      *q;\n\n    q=(unsigned char *) p;\n    if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      break;\n    p=PushLongPixel(MSBEndian,p,&long_sans);\n    p=PushShortPixel(MSBEndian,p,&id);\n    p=PushShortPixel(MSBEndian,p,&short_sans);\n    p=PushLongPixel(MSBEndian,p,&count);\n    if (id == 0x0000040f)\n      {\n        ssize_t\n          quantum;\n\n        quantum=PSDQuantum(count)+12;\n        if ((quantum >= 12) && (quantum < (ssize_t) length))\n          {\n            if ((q+quantum < (datum+length-16)))\n              (void) memmove(q,q+quantum,length-quantum-(q-datum));\n            SetStringInfoLength(bim_profile,length-quantum);\n          }\n        break;\n      }\n    p+=count;\n    if ((count & 0x01) != 0)\n      p++;\n  }\n}\n\nstatic void RemoveResolutionFromResourceBlock(StringInfo *bim_profile)\n{\n  const unsigned char\n    *p;\n\n  size_t\n    length;\n\n  unsigned char\n    *datum;\n\n  unsigned int\n    count,\n    long_sans;\n\n  unsigned short\n    id,\n    short_sans;\n\n  length=GetStringInfoLength(bim_profile);\n  if (length < 16)\n    return;\n  datum=GetStringInfoDatum(bim_profile);\n  for (p=datum; (p >= datum) && (p < (datum+length-16)); )\n  {\n    unsigned char\n      *q;\n\n    ssize_t\n      cnt;\n\n    q=(unsigned char *) p;\n    if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      return;\n    p=PushLongPixel(MSBEndian,p,&long_sans);\n    p=PushShortPixel(MSBEndian,p,&id);\n    p=PushShortPixel(MSBEndian,p,&short_sans);\n    p=PushLongPixel(MSBEndian,p,&count);\n    cnt=PSDQuantum(count);\n    if (cnt < 0)\n      return;\n    if ((id == 0x000003ed) && (cnt < (ssize_t) (length-12)) &&\n        ((ssize_t) length-(cnt+12)-(q-datum)) > 0)\n      {\n        (void) memmove(q,q+cnt+12,length-(cnt+12)-(q-datum));\n        SetStringInfoLength(bim_profile,length-(cnt+12));\n        break;\n      }\n    p+=count;\n    if ((count & 0x01) != 0)\n      p++;\n  }\n}\n\nstatic const StringInfo *GetAdditionalInformation(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n#define PSDKeySize 5\n#define PSDAllowedLength 36\n\n  char\n    key[PSDKeySize];\n\n  /* Whitelist of keys from: https://www.adobe.com/devnet-apps/photoshop/fileformatashtml/ */\n  const char\n    allowed[PSDAllowedLength][PSDKeySize] = {\n      \"blnc\", \"blwh\", \"brit\", \"brst\", \"clbl\", \"clrL\", \"curv\", \"expA\", \"FMsk\",\n      \"GdFl\", \"grdm\", \"hue \", \"hue2\", \"infx\", \"knko\", \"lclr\", \"levl\", \"lnsr\",\n      \"lfx2\", \"luni\", \"lrFX\", \"lspf\", \"lyid\", \"lyvr\", \"mixr\", \"nvrt\", \"phfl\",\n      \"post\", \"PtFl\", \"selc\", \"shpa\", \"sn2P\", \"SoCo\", \"thrs\", \"tsly\", \"vibA\"\n    },\n    *option;\n\n  const StringInfo\n    *info;\n\n  MagickBooleanType\n    found;\n\n  size_t\n    i;\n\n  size_t\n    remaining_length,\n    length;\n\n  StringInfo\n    *profile;\n\n  unsigned char\n    *p;\n\n  unsigned int\n    size;\n\n  info=GetImageProfile(image,\"psd:additional-info\");\n  if (info == (const StringInfo *) NULL)\n    return((const StringInfo *) NULL);\n  option=GetImageOption(image_info,\"psd:additional-info\");\n  if (LocaleCompare(option,\"all\") == 0)\n    return(info);\n  if (LocaleCompare(option,\"selective\") != 0)\n    {\n      profile=RemoveImageProfile(image,\"psd:additional-info\");\n      return(DestroyStringInfo(profile));\n    }\n  length=GetStringInfoLength(info);\n  p=GetStringInfoDatum(info);\n  remaining_length=length;\n  length=0;\n  while (remaining_length >= 12)\n  {\n    /* skip over signature */\n    p+=4;\n    key[0]=(char) (*p++);\n    key[1]=(char) (*p++);\n    key[2]=(char) (*p++);\n    key[3]=(char) (*p++);\n    key[4]='\\0';\n    size=(unsigned int) (*p++) << 24;\n    size|=(unsigned int) (*p++) << 16;\n    size|=(unsigned int) (*p++) << 8;\n    size|=(unsigned int) (*p++);\n    size=size & 0xffffffff;\n    remaining_length-=12;\n    if ((size_t) size > remaining_length)\n      return((const StringInfo *) NULL);\n    found=MagickFalse;\n    for (i=0; i < PSDAllowedLength; i++)\n    {\n      if (LocaleNCompare(key,allowed[i],PSDKeySize) != 0)\n        continue;\n\n      found=MagickTrue;\n      break;\n    }\n    remaining_length-=(size_t) size;\n    if (found == MagickFalse)\n      {\n        if (remaining_length > 0)\n          p=(unsigned char *) memmove(p-12,p+size,remaining_length);\n        continue;\n      }\n    length+=(size_t) size+12;\n    p+=size;\n  }\n  profile=RemoveImageProfile(image,\"psd:additional-info\");\n  if (length == 0)\n    return(DestroyStringInfo(profile));\n  SetStringInfoLength(profile,(const size_t) length);\n  (void) SetImageProfile(image,\"psd:additional-info\",info,exception);\n  return(profile);\n}\n\nstatic MagickBooleanType WritePSDLayersInternal(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,size_t *layers_size,\n  ExceptionInfo *exception)\n{\n  char\n    layer_name[MagickPathExtent];\n\n  const char\n    *property;\n\n  const StringInfo\n    *info;\n\n  Image\n    *base_image,\n    *next_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    *layer_size_offsets,\n    size_offset;\n\n  ssize_t\n    i;\n\n  size_t\n    layer_count,\n    layer_index,\n    length,\n    name_length,\n    rounded_size,\n    size;\n\n  status=MagickTrue;\n  base_image=GetNextImageInList(image);\n  if (base_image == (Image *) NULL)\n    base_image=image;\n  size=0;\n  size_offset=TellBlob(image);\n  (void) SetPSDSize(psd_info,image,0);\n  layer_count=0;\n  for (next_image=base_image; next_image != NULL; )\n  {\n    layer_count++;\n    next_image=GetNextImageInList(next_image);\n  }\n  if (image->alpha_trait != UndefinedPixelTrait)\n    size+=WriteBlobShort(image,-(unsigned short) layer_count);\n  else\n    size+=WriteBlobShort(image,(unsigned short) layer_count);\n  layer_size_offsets=(MagickOffsetType *) AcquireQuantumMemory(\n    (size_t) layer_count,sizeof(MagickOffsetType));\n  if (layer_size_offsets == (MagickOffsetType *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  layer_index=0;\n  for (next_image=base_image; next_image != NULL; )\n  {\n    Image\n      *mask;\n\n    unsigned char\n      default_color;\n\n    unsigned short\n      channels,\n      total_channels;\n\n    mask=(Image *) NULL;\n    property=GetImageArtifact(next_image,\"psd:opacity-mask\");\n    default_color=0;\n    if (property != (const char *) NULL)\n      {\n        mask=(Image *) GetImageRegistry(ImageRegistryType,property,exception);\n        default_color=(unsigned char) (strlen(property) == 9 ? 255 : 0);\n      }\n    size+=WriteBlobSignedLong(image,(signed int) next_image->page.y);\n    size+=WriteBlobSignedLong(image,(signed int) next_image->page.x);\n    size+=WriteBlobSignedLong(image,(signed int) (next_image->page.y+\n      next_image->rows));\n    size+=WriteBlobSignedLong(image,(signed int) (next_image->page.x+\n      next_image->columns));\n    channels=1;\n    if ((next_image->storage_class != PseudoClass) &&\n        (IsImageGray(next_image) == MagickFalse))\n      channels=(unsigned short) (next_image->colorspace == CMYKColorspace ? 4 :\n        3);\n    total_channels=channels;\n    if (next_image->alpha_trait != UndefinedPixelTrait)\n      total_channels++;\n    if (mask != (Image *) NULL)\n      total_channels++;\n    size+=WriteBlobShort(image,total_channels);\n    layer_size_offsets[layer_index++]=TellBlob(image);\n    for (i=0; i < (ssize_t) channels; i++)\n      size+=WriteChannelSize(psd_info,image,(signed short) i);\n    if (next_image->alpha_trait != UndefinedPixelTrait)\n      size+=WriteChannelSize(psd_info,image,-1);\n    if (mask != (Image *) NULL)\n      size+=WriteChannelSize(psd_info,image,-2);\n    size+=WriteBlobString(image,image->endian == LSBEndian ? \"MIB8\" :\"8BIM\");\n    size+=WriteBlobString(image,CompositeOperatorToPSDBlendMode(next_image));\n    property=GetImageArtifact(next_image,\"psd:layer.opacity\");\n    if (property != (const char *) NULL)\n      {\n        Quantum\n          opacity;\n\n        opacity=(Quantum) StringToInteger(property);\n        size+=WriteBlobByte(image,ScaleQuantumToChar(opacity));\n        (void) ApplyPSDLayerOpacity(next_image,opacity,MagickTrue,exception);\n      }\n    else\n      size+=WriteBlobByte(image,255);\n    size+=WriteBlobByte(image,0);\n    size+=WriteBlobByte(image,(const unsigned char)\n      (next_image->compose == NoCompositeOp ? 1 << 0x02 : 1)); /* layer properties - visible, etc. */\n    size+=WriteBlobByte(image,0);\n    info=GetAdditionalInformation(image_info,next_image,exception);\n    property=(const char *) GetImageProperty(next_image,\"label\",exception);\n    if (property == (const char *) NULL)\n      {\n        (void) FormatLocaleString(layer_name,MagickPathExtent,\"L%.20g\",\n          (double) layer_index);\n        property=layer_name;\n      }\n    name_length=strlen(property)+1;\n    if ((name_length % 4) != 0)\n      name_length+=(4-(name_length % 4));\n    if (info != (const StringInfo *) NULL)\n      name_length+=GetStringInfoLength(info);\n    name_length+=8;\n    if (mask != (Image *) NULL)\n      name_length+=20;\n    size+=WriteBlobLong(image,(unsigned int) name_length);\n    if (mask == (Image *) NULL)\n      size+=WriteBlobLong(image,0);\n    else\n      {\n        if (mask->compose != NoCompositeOp)\n          (void) ApplyPSDOpacityMask(next_image,mask,ScaleCharToQuantum(\n            default_color),MagickTrue,exception);\n        mask->page.y+=image->page.y;\n        mask->page.x+=image->page.x;\n        size+=WriteBlobLong(image,20);\n        size+=WriteBlobSignedLong(image,(const signed int) mask->page.y);\n        size+=WriteBlobSignedLong(image,(const signed int) mask->page.x);\n        size+=WriteBlobSignedLong(image,(const signed int) (mask->rows+\n          mask->page.y));\n        size+=WriteBlobSignedLong(image,(const signed int) (mask->columns+\n          mask->page.x));\n        size+=WriteBlobByte(image,default_color);\n        size+=WriteBlobByte(image,(const unsigned char)\n          (mask->compose == NoCompositeOp ? 2 : 0));\n        size+=WriteBlobMSBShort(image,0);\n      }\n    size+=WriteBlobLong(image,0);\n    size+=WritePascalString(image,property,4);\n    if (info != (const StringInfo *) NULL)\n      size+=WriteBlob(image,GetStringInfoLength(info),\n        GetStringInfoDatum(info));\n    next_image=GetNextImageInList(next_image);\n  }\n  /*\n    Now the image data!\n  */\n  next_image=base_image;\n  layer_index=0;\n  while (next_image != NULL)\n  {\n    length=WritePSDChannels(psd_info,image_info,image,next_image,\n      layer_size_offsets[layer_index++],MagickTrue,exception);\n    if (length == 0)\n      {\n        status=MagickFalse;\n        break;\n      }\n    size+=length;\n    next_image=GetNextImageInList(next_image);\n  }\n  /*\n    Write the total size\n  */\n  if (layers_size != (size_t*) NULL)\n    *layers_size=size;\n  if ((size/2) != ((size+1)/2))\n    rounded_size=size+1;\n  else\n    rounded_size=size;\n  (void) WritePSDSize(psd_info,image,rounded_size,size_offset);\n  layer_size_offsets=(MagickOffsetType *) RelinquishMagickMemory(\n    layer_size_offsets);\n  /*\n    Remove the opacity mask from the registry\n  */\n  next_image=base_image;\n  while (next_image != (Image *) NULL)\n  {\n    property=GetImageArtifact(next_image,\"psd:opacity-mask\");\n    if (property != (const char *) NULL)\n      (void) DeleteImageRegistry(property);\n    next_image=GetNextImageInList(next_image);\n  }\n  return(status);\n}\n\nModuleExport MagickBooleanType WritePSDLayers(Image * image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  status=IsRightsAuthorized(CoderPolicyDomain,WritePolicyRights,\"PSD\");\n  if (status == MagickFalse)\n    return(MagickTrue);\n  return WritePSDLayersInternal(image,image_info,psd_info,(size_t*) NULL,\n    exception);\n}\n\nstatic MagickBooleanType WritePSDImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  const StringInfo\n    *icc_profile;\n\n  MagickBooleanType\n    status;\n\n  PSDInfo\n    psd_info;\n\n  ssize_t\n    i;\n\n  size_t\n    length,\n    num_channels;\n\n  StringInfo\n    *bim_profile;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  psd_info.version=1;\n  if ((LocaleCompare(image_info->magick,\"PSB\") == 0) ||\n      (image->columns > 30000) || (image->rows > 30000))\n    psd_info.version=2;\n  (void) WriteBlob(image,4,(const unsigned char *) \"8BPS\");\n  (void) WriteBlobMSBShort(image,psd_info.version);  /* version */\n  for (i=1; i <= 6; i++)\n    (void) WriteBlobByte(image, 0);  /* 6 bytes of reserved */\n  if ((GetImageProfile(image,\"icc\") == (StringInfo *) NULL) &&\n      (SetImageGray(image,exception) != MagickFalse))\n    num_channels=(image->alpha_trait != UndefinedPixelTrait ? 2UL : 1UL);\n  else\n    if ((image_info->type != TrueColorType) &&\n        (image_info->type != TrueColorAlphaType) &&\n        (image->storage_class == PseudoClass))\n      num_channels=(image->alpha_trait != UndefinedPixelTrait ? 2UL : 1UL);\n    else\n      {\n        if (image->storage_class == PseudoClass)\n          (void) SetImageStorageClass(image,DirectClass,exception);\n        if (image->colorspace != CMYKColorspace)\n          num_channels=(image->alpha_trait != UndefinedPixelTrait ? 4UL : 3UL);\n        else\n          num_channels=(image->alpha_trait != UndefinedPixelTrait ? 5UL : 4UL);\n      }\n  (void) WriteBlobMSBShort(image,(unsigned short) num_channels);\n  (void) WriteBlobMSBLong(image,(unsigned int) image->rows);\n  (void) WriteBlobMSBLong(image,(unsigned int) image->columns);\n  if (IsImageGray(image) != MagickFalse)\n    {\n      MagickBooleanType\n        monochrome;\n\n      /*\n        Write depth & mode.\n      */\n      monochrome=IsImageMonochrome(image) && (image->depth == 1) ?\n        MagickTrue : MagickFalse;\n      (void) WriteBlobMSBShort(image,(unsigned short)\n        (monochrome != MagickFalse ? 1 : image->depth > 8 ? 16 : 8));\n      (void) WriteBlobMSBShort(image,(unsigned short)\n        (monochrome != MagickFalse ? BitmapMode : GrayscaleMode));\n    }\n  else\n    {\n      (void) WriteBlobMSBShort(image,(unsigned short) (image->storage_class ==\n        PseudoClass ? 8 : image->depth > 8 ? 16 : 8));\n\n      if (((image_info->colorspace != UndefinedColorspace) ||\n           (image->colorspace != CMYKColorspace)) &&\n          (image_info->colorspace != CMYKColorspace))\n        {\n          (void) TransformImageColorspace(image,sRGBColorspace,exception);\n          (void) WriteBlobMSBShort(image,(unsigned short)\n            (image->storage_class == PseudoClass ? IndexedMode : RGBMode));\n        }\n      else\n        {\n          if (image->colorspace != CMYKColorspace)\n            (void) TransformImageColorspace(image,CMYKColorspace,exception);\n          (void) WriteBlobMSBShort(image,CMYKMode);\n        }\n    }\n  if ((IsImageGray(image) != MagickFalse) ||\n      (image->storage_class == DirectClass) || (image->colors > 256))\n    (void) WriteBlobMSBLong(image,0);\n  else\n    {\n      /*\n        Write PSD raster colormap.\n      */\n      (void) WriteBlobMSBLong(image,768);\n      for (i=0; i < (ssize_t) image->colors; i++)\n        (void) WriteBlobByte(image,ScaleQuantumToChar(ClampToQuantum(\n          image->colormap[i].red)));\n      for ( ; i < 256; i++)\n        (void) WriteBlobByte(image,0);\n      for (i=0; i < (ssize_t) image->colors; i++)\n        (void) WriteBlobByte(image,ScaleQuantumToChar(ClampToQuantum(\n          image->colormap[i].green)));\n      for ( ; i < 256; i++)\n        (void) WriteBlobByte(image,0);\n      for (i=0; i < (ssize_t) image->colors; i++)\n        (void) WriteBlobByte(image,ScaleQuantumToChar(ClampToQuantum(\n          image->colormap[i].blue)));\n      for ( ; i < 256; i++)\n        (void) WriteBlobByte(image,0);\n    }\n  /*\n    Image resource block.\n  */\n  length=28; /* 0x03EB */\n  bim_profile=(StringInfo *) GetImageProfile(image,\"8bim\");\n  icc_profile=GetImageProfile(image,\"icc\");\n  if (bim_profile != (StringInfo *) NULL)\n    {\n      bim_profile=CloneStringInfo(bim_profile);\n      if (icc_profile != (StringInfo *) NULL)\n        RemoveICCProfileFromResourceBlock(bim_profile);\n      RemoveResolutionFromResourceBlock(bim_profile);\n      length+=PSDQuantum(GetStringInfoLength(bim_profile));\n    }\n  if (icc_profile != (const StringInfo *) NULL)\n    length+=PSDQuantum(GetStringInfoLength(icc_profile))+12;\n  (void) WriteBlobMSBLong(image,(unsigned int) length);\n  WriteResolutionResourceBlock(image);\n  if (bim_profile != (StringInfo *) NULL)\n    {\n      (void) WriteBlob(image,GetStringInfoLength(bim_profile),\n        GetStringInfoDatum(bim_profile));\n      bim_profile=DestroyStringInfo(bim_profile);\n    }\n  if (icc_profile != (StringInfo *) NULL)\n    {\n      (void) WriteBlob(image,4,(const unsigned char *) \"8BIM\");\n      (void) WriteBlobMSBShort(image,0x0000040F);\n      (void) WriteBlobMSBShort(image,0);\n      (void) WriteBlobMSBLong(image,(unsigned int) GetStringInfoLength(\n        icc_profile));\n      (void) WriteBlob(image,GetStringInfoLength(icc_profile),\n        GetStringInfoDatum(icc_profile));\n      if ((ssize_t) GetStringInfoLength(icc_profile) != PSDQuantum(GetStringInfoLength(icc_profile)))\n        (void) WriteBlobByte(image,0);\n    }\n  if (status != MagickFalse)\n    {\n      const char\n        *option;\n\n      CompressionType\n        compression;\n\n      MagickOffsetType\n        size_offset;\n\n      size_t\n        size;\n\n      size_offset=TellBlob(image);\n      (void) SetPSDSize(&psd_info,image,0);\n      option=GetImageOption(image_info,\"psd:write-layers\");\n      if (IsStringFalse(option) != MagickTrue)\n        {\n          status=WritePSDLayersInternal(image,image_info,&psd_info,&size,\n            exception);\n          (void) WritePSDSize(&psd_info,image,size+\n            (psd_info.version == 1 ? 8 : 12),size_offset);\n          (void) WriteBlobMSBLong(image,0);  /* user mask data */\n        }\n      /*\n        Write composite image.\n      */\n      compression=image->compression;\n      if (image_info->compression != UndefinedCompression)\n        image->compression=image_info->compression;\n      if (image->compression == ZipCompression)\n        image->compression=RLECompression;\n      if (WritePSDChannels(&psd_info,image_info,image,image,0,MagickFalse,\n          exception) == 0)\n        status=MagickFalse;\n      image->compression=compression;\n    }\n  (void) CloseBlob(image);\n  return(status);\n}\n"], "filenames": ["coders/psd.c"], "buggy_code_start_loc": [1030], "buggy_code_end_loc": [1031], "fixing_code_start_loc": [1030], "fixing_code_end_loc": [1031], "type": "CWE-190", "message": "A vulnerability was found in ImageMagick, causing an outside the range of representable values of type 'unsigned char' at coders/psd.c, when crafted or untrusted input is processed. This leads to a negative impact to application availability or other problems related to undefined behavior.", "other": {"cve": {"id": "CVE-2022-32545", "sourceIdentifier": "secalert@redhat.com", "published": "2022-06-16T18:15:10.873", "lastModified": "2023-05-22T02:15:11.247", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A vulnerability was found in ImageMagick, causing an outside the range of representable values of type 'unsigned char' at coders/psd.c, when crafted or untrusted input is processed. This leads to a negative impact to application availability or other problems related to undefined behavior."}, {"lang": "es", "value": "Se ha encontrado una vulnerabilidad en ImageMagick, que causa un fallo fuera del rango de valores representables del tipo \"unsigned char\" en el archivo coders/psd.c, cuando se procesa una entrada dise\u00f1ada o no confiable. Esto conlleva a un impacto negativo en la disponibilidad de la aplicaci\u00f3n u otros problemas relacionados con el comportamiento no definido"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.9.12-43", "matchCriteriaId": "3AFC7A4D-C722-4132-931A-FD310019F685"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.1.0", "versionEndExcluding": "7.1.0-28", "matchCriteriaId": "CF10ECD1-E700-4BEF-9A72-B5B542FE7CA0"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fedoraproject:extra_packages_for_enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "BB176AC3-3CDA-4DDA-9089-C67B2F73AA62"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2091811", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/9c9a84cec4ab28ee0b57c2b9266d6fbe68183512", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick6/commit/450949ed017f009b399c937cf362f0058eacc5fa", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/05/msg00020.html", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/9c9a84cec4ab28ee0b57c2b9266d6fbe68183512"}}