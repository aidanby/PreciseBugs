{"buggy_code": ["# -*- coding: utf-8 -*-\n#\n# Copyright (C) 2020-2021 CERN.\n# Copyright (C) 2020 Northwestern University.\n#\n# Invenio-Drafts-Resources is free software; you can redistribute it and/or\n# modify it under the terms of the MIT License; see LICENSE file for more\n# details.\n\n\"\"\"Primary service for working with records and drafts.\"\"\"\n\nfrom elasticsearch_dsl.query import Q\nfrom invenio_db import db\nfrom invenio_records_resources.services import LinksTemplate\nfrom invenio_records_resources.services import \\\n    RecordService as RecordServiceBase\nfrom invenio_records_resources.services import ServiceSchemaWrapper\nfrom invenio_records_resources.services.uow import RecordCommitOp, \\\n    RecordDeleteOp, RecordIndexOp, unit_of_work\nfrom sqlalchemy.orm.exc import NoResultFound\n\n\nclass RecordService(RecordServiceBase):\n    \"\"\"Record and draft service interface.\n\n    This service provides an interface to business logic for published and\n    draft records.\n    \"\"\"\n\n    def __init__(self, config, files_service=None, draft_files_service=None):\n        \"\"\"Constructor for RecordService.\"\"\"\n        super().__init__(config)\n        self._files = files_service\n        self._draft_files = draft_files_service\n\n    #\n    # Subservices\n    #\n    @property\n    def files(self):\n        \"\"\"Record files service.\"\"\"\n        return self._files\n\n    @property\n    def draft_files(self):\n        \"\"\"Draft files service.\"\"\"\n        return self._draft_files\n\n    #\n    # Properties\n    #\n    @property\n    def schema_parent(self):\n        \"\"\"Schema for parent records.\"\"\"\n        return ServiceSchemaWrapper(self, schema=self.config.schema_parent)\n\n    @property\n    def draft_cls(self):\n        \"\"\"Factory for creating a record class.\"\"\"\n        return self.config.draft_cls\n\n    # High-level API\n    # Inherits record search, read, create, delete and update\n\n    def update(self, *args, **kwargs):\n        \"\"\"Do not use.\"\"\"\n        raise NotImplementedError(\"Records should be updated via their draft.\")\n\n    def search_drafts(self, identity, params=None, es_preference=None,\n                      **kwargs):\n        \"\"\"Search for drafts records matching the querystring.\"\"\"\n        self.require_permission(identity, 'search_drafts')\n\n        # Prepare and execute the search\n        params = params or {}\n\n        search_result = self._search(\n            'search_drafts',\n            identity,\n            params,\n            es_preference,\n            record_cls=self.draft_cls,\n            search_opts=self.config.search_drafts,\n            # `has_draft` systemfield is not defined here. This is not ideal\n            # but it helps avoid overriding the method. See how is used in\n            # https://github.com/inveniosoftware/invenio-rdm-records\n            extra_filter=Q('term', has_draft=False),\n            permission_action='read_draft',\n            **kwargs\n        ).execute()\n\n        return self.result_list(\n            self,\n            identity,\n            search_result,\n            params,\n            links_tpl=LinksTemplate(self.config.links_search_drafts, context={\n                \"args\": params\n            }),\n            links_item_tpl=self.links_item_tpl,\n        )\n\n    def search_versions(self, id_, identity, params=None, es_preference=None,\n                        **kwargs):\n        \"\"\"Search for record's versions.\"\"\"\n        try:\n            record = self.record_cls.pid.resolve(id_, registered_only=False)\n        except NoResultFound:\n            record = self.draft_cls.pid.resolve(id_, registered_only=False)\n\n        self.require_permission(identity, \"read\", record=record)\n\n        # Prepare and execute the search\n        params = params or {}\n\n        search_result = self._search(\n            'search_versions',\n            identity,\n            params,\n            es_preference,\n            record_cls=self.record_cls,\n            search_opts=self.config.search_versions,\n            extra_filter=Q(\n                'term', **{'parent.id': str(record.parent.pid.pid_value)}),\n            permission_action='read',\n            **kwargs\n        ).execute()\n\n        return self.result_list(\n            self,\n            identity,\n            search_result,\n            params,\n            links_tpl=LinksTemplate(\n                self.config.links_search_versions,\n                context={\"id\": id_, \"args\": params}\n            ),\n            links_item_tpl=self.links_item_tpl,\n        )\n\n    def read_draft(self, id_, identity):\n        \"\"\"Retrieve a draft.\"\"\"\n        # Resolve and require permission\n        draft = self.draft_cls.pid.resolve(id_, registered_only=False)\n        self.require_permission(identity, \"read_draft\", record=draft)\n\n        # Run components\n        for component in self.components:\n            if hasattr(component, 'read_draft'):\n                component.read_draft(identity, draft=draft)\n\n        return self.result_item(\n            self, identity, draft, links_tpl=self.links_item_tpl)\n\n    def read_latest(self, id_, identity):\n        \"\"\"Retrieve latest record.\"\"\"\n        # Resolve and require permission\n        record = self.record_cls.pid.resolve(id_)\n\n        # Retrieve latest if record is not\n        if not record.versions.is_latest:\n            record = self.record_cls.get_record(record.versions.latest_id)\n\n        self.require_permission(identity, \"read\", record=record)\n\n        return self.result_item(\n            self, identity, record, links_tpl=self.links_item_tpl)\n\n    @unit_of_work()\n    def update_draft(self, id_, identity, data, revision_id=None, uow=None):\n        \"\"\"Replace a draft.\"\"\"\n        draft = self.draft_cls.pid.resolve(id_, registered_only=False)\n\n        self.check_revision_id(draft, revision_id)\n\n        # Permissions\n        self.require_permission(identity, \"update_draft\", record=draft)\n\n        # Load data with service schema\n        data, errors = self.schema.load(\n            data,\n            context=dict(\n                identity=identity,\n                pid=draft.pid,\n                record=draft,\n            ),\n            # Saving a draft only saves valid metadata and reports\n            # (doesn't raise) errors\n            raise_errors=False\n        )\n\n        # Run components\n        self.run_components(\n            'update_draft', identity, record=draft, data=data,\n            errors=errors, uow=uow\n        )\n\n        # Commit and index\n        uow.register(RecordCommitOp(draft, indexer=self.indexer))\n\n        return self.result_item(\n            self,\n            identity,\n            draft,\n            links_tpl=self.links_item_tpl,\n            errors=errors\n        )\n\n    @unit_of_work()\n    def create(self, identity, data, uow=None):\n        \"\"\"Create a draft for a new record.\n\n        It does NOT eagerly create the associated record.\n        \"\"\"\n        res = self._create(\n           self.draft_cls,\n           identity,\n           data,\n           raise_errors=False,\n           uow=uow,\n        )\n        uow.register(RecordCommitOp(res._record.parent))\n        return res\n\n    @unit_of_work()\n    def edit(self, id_, identity, uow=None):\n        \"\"\"Create a new revision or a draft for an existing record.\n\n        :param id_: record PID value.\n        \"\"\"\n        # Draft exists - return it\n        try:\n            draft = self.draft_cls.pid.resolve(id_, registered_only=False)\n            self.require_permission(identity, \"edit\", record=draft)\n            return self.result_item(\n                self, identity, draft, links_tpl=self.links_item_tpl)\n        except NoResultFound:\n            pass\n\n        # Draft does not exists - so get the main record we want to edit and\n        # create a draft from it\n        record = self.record_cls.pid.resolve(id_)\n        self.require_permission(identity, \"edit\", record=record)\n        draft = self.draft_cls.edit(record)\n\n        # Run components\n        self.run_components(\n            \"edit\", identity, draft=draft, record=record, uow=uow)\n\n        uow.register(RecordCommitOp(draft, indexer=self.indexer))\n\n        # Reindex the record to trigger update of computed values in the\n        # available dumpers of the record.\n        uow.register(RecordIndexOp(record, indexer=self.indexer))\n\n        return self.result_item(\n            self, identity, draft, links_tpl=self.links_item_tpl)\n\n    @unit_of_work()\n    def publish(self, id_, identity, uow=None):\n        \"\"\"Publish a draft.\n\n        Idea:\n            - Get the draft from the data layer (draft is not passed in)\n            - Validate it more strictly than when it was originally saved\n              (drafts can be incomplete but only complete drafts can be turned\n              into records)\n            - Create or update associated (published) record with data\n        \"\"\"\n        self.require_permission(identity, \"publish\")\n\n        # Get the draft\n        draft = self.draft_cls.pid.resolve(id_, registered_only=False)\n\n        # Validate the draft strictly - since a draft can be saved with errors\n        # we do a strict validation here to make sure only valid drafts can be\n        # published.\n        self._validate_draft(identity, draft)\n\n        # Create the record from the draft\n        latest_id = draft.versions.latest_id\n        record = self.record_cls.publish(draft)\n\n        # Run components\n        self.run_components(\n            'publish', identity, draft=draft, record=record, uow=uow)\n\n        # Commit and index\n        uow.register(RecordCommitOp(record, indexer=self.indexer))\n        uow.register(RecordDeleteOp(draft, force=False, indexer=self.indexer))\n\n        if latest_id:\n            self._reindex_latest(latest_id, uow=uow)\n\n        return self.result_item(\n            self, identity, record, links_tpl=self.links_item_tpl)\n\n    @unit_of_work()\n    def new_version(self, id_, identity, uow=None):\n        \"\"\"Create a new version of a record.\"\"\"\n        # Get the a record - i.e. you can only create a new version in case\n        # at least one published record already exists.\n        record = self.record_cls.pid.resolve(id_)\n\n        # Check permissions\n        self.require_permission(identity, \"new_version\", record=record)\n\n        # Draft for new version already exists? if so return it\n        if record.versions.next_draft_id:\n            next_draft = self.draft_cls.get_record(\n                record.versions.next_draft_id)\n            return self.result_item(\n                self, identity, next_draft, links_tpl=self.links_item_tpl)\n\n        # Draft for new version does not exists, so create it\n        next_draft = self.draft_cls.new_version(record)\n\n        # Get the latest published record if it's not the current one.\n        if not record.versions.is_latest:\n            record = self.record_cls.get_record(record.versions.latest_id)\n\n        # Run components\n        self.run_components(\n            'new_version', identity, draft=next_draft, record=record, uow=uow)\n\n        # Commit and index\n        uow.register(RecordCommitOp(next_draft, indexer=self.indexer))\n\n        self._reindex_latest(\n            next_draft.versions.latest_id, record=record, uow=uow)\n\n        return self.result_item(\n            self, identity, next_draft, links_tpl=self.links_item_tpl)\n\n    @unit_of_work()\n    def delete_draft(self, id_, identity, revision_id=None, uow=None):\n        \"\"\"Delete a record from database and search indexes.\"\"\"\n        draft = self.draft_cls.pid.resolve(id_, registered_only=False)\n        latest_id = draft.versions.latest_id\n\n        self.check_revision_id(draft, revision_id)\n\n        # Permissions\n        self.require_permission(identity, \"delete_draft\", record=draft)\n\n        # Get published record if exists\n        try:\n            record = self.record_cls.get_record(draft.id)\n        except NoResultFound:\n            record = None\n\n        # We soft-delete a draft when a published record exists, in order to\n        # keep the version_id counter around for optimistic concurrency\n        # control (both for ES indexing and for REST API clients)\n        force = False if record else True\n\n        # Run components\n        self.run_components(\n            'delete_draft', identity, draft=draft, record=record,\n            force=force, uow=uow\n        )\n\n        # Note, the parent record deletion logic is implemented in the\n        # ParentField and will automatically take care of deleting the parent\n        # record in case this is the only draft that exists for the parent.\n        # We refresh the index because users are usually redirected to a\n        # search result immediately after, and we don't want the users to see\n        # their just deleted draft.\n        uow.register(RecordDeleteOp(\n            draft, indexer=self.indexer, force=force, index_refresh=True))\n\n        if force:\n            # Case 1: We deleted a new draft (without a published record) or a\n            # new version draft (without a published).\n            # In this case, we reindex the latest published record/draft\n            self._reindex_latest(latest_id, refresh=True, uow=uow)\n        else:\n            # Case 2: We deleted a draft for a published record.\n            # In this case we reindex just the published record to trigger and\n            # update of computed values.\n            uow.register(RecordIndexOp(\n                record, indexer=self.indexer, index_refresh=True))\n\n        return True\n\n    @unit_of_work()\n    def import_files(self, id_, identity, uow=None):\n        \"\"\"Import files from previous record version.\"\"\"\n        if self.draft_files is None:\n            raise RuntimeError(\"Files support is not enabled.\")\n\n        # Read draft\n        draft = self.draft_cls.pid.resolve(id_, registered_only=False)\n        self.require_permission(identity, \"draft_create_files\", record=draft)\n\n        # Retrieve latest record\n        record = self.record_cls.get_record(draft.versions.latest_id)\n        self.require_permission(identity, \"read_files\", record=record)\n\n        # Run components\n        self.run_components(\n            'import_files', identity, draft=draft, record=record, uow=uow)\n\n        # Commit and index\n        uow.register(RecordCommitOp(draft, indexer=self.indexer))\n\n        return self.draft_files.file_result_list(\n            self.draft_files,\n            identity,\n            results=draft.files.values(),\n            record=draft,\n            links_tpl=self.draft_files.file_links_list_tpl(id_),\n            links_item_tpl=self.draft_files.file_links_item_tpl(id_),\n        )\n\n    def rebuild_index(self, identity):\n        \"\"\"Reindex all records and drafts.\n\n        Note: Skips (soft) deleted records and drafts.\n        \"\"\"\n        ret_val = super().rebuild_index(identity)\n\n        for draft_meta in self.draft_cls.model_cls.query.all():\n            draft = self.draft_cls(draft_meta.data, model=draft_meta)\n            if not draft.is_deleted:\n                self.indexer.index(draft)\n\n        return ret_val\n\n    def validate_draft(self, identity, id_):\n        \"\"\"Validate a draft.\"\"\"\n        draft = self.draft_cls.pid.resolve(id_, registered_only=False)\n        self._validate_draft(identity, draft)\n\n    def _validate_draft(self, identity, draft):\n        \"\"\"Validate a draft.\n\n        This method is internal because it works with a data access layer\n        draft, and thus should not be called from outside the service.\n        \"\"\"\n        # Convert to draft into service layer draft result item (a record\n        # projection for the given identity). This way we can load and validate\n        # the data with the service schema.\n        draft_item = self.result_item(self, identity, draft)\n        # Validate the data - will raise ValidationError if not valid.\n        self.schema.load(\n            data=draft_item.data,\n            context=dict(\n                identity=identity,\n                pid=draft.pid,\n                record=draft,\n            ),\n            raise_errors=True  # this is the default, but might as well be\n                               # explicit\n        )\n\n    @unit_of_work()\n    def _reindex_latest(self, latest_id, record=None, draft=None,\n                        refresh=False, uow=None):\n        \"\"\"Reindex the latest published record and draft.\n\n        This triggers and update of computed values in the index, such as\n        \"is_latest\".\n\n        This method is internal because it works with a data access layer\n        record/draft, and thus should not be called from outside the service.\n        \"\"\"\n        # We only have a draft, no latest to index\n        if not latest_id:\n            return\n\n        # Note, the record may not be the latest published record, and we only\n        # want to index the latest published.\n        if record is None or latest_id != record.id:\n            record = self.record_cls.get_record(latest_id)\n        uow.register(\n            RecordIndexOp(record, indexer=self.indexer, index_refresh=refresh))\n\n        # Note, a draft may or may not exists for a published record (depending\n        # on if it's being edited).\n        try:\n            draft = self.draft_cls.get_record(latest_id)\n            uow.register(RecordIndexOp(\n                draft, indexer=self.indexer, index_refresh=refresh))\n        except NoResultFound:\n            pass\n\n    def _get_record_and_parent_by_id(self, id_):\n        \"\"\"Resolve the record and its parent, by the given ID.\n\n        If the ID belongs to a parent record, no child record will be\n        resolved.\n        \"\"\"\n        record = self.record_cls.pid.resolve(id_, registered_only=False)\n        parent = record.parent\n\n        return record, parent\n\n    def _get_draft_and_parent_by_id(self, id_):\n        \"\"\"Resolve the draft and its parent, by the given ID.\"\"\"\n        draft = self.draft_cls.pid.resolve(id_, registered_only=False)\n        parent = draft.parent\n\n        return draft, parent\n\n    @unit_of_work()\n    def _index_related_records(self, record, parent, uow=None):\n        \"\"\"Index all records that are related to the specified ones.\"\"\"\n        siblings = self.record_cls.get_records_by_parent(\n            parent or record.parent\n        )\n\n        # TODO only index the current record immediately;\n        #      all siblings should be sent to a high-priority celery task\n        #      instead (requires bulk indexing to work)\n        for sibling in siblings:\n            uow.register(RecordIndexOp(sibling, indexer=self.indexer))\n\n    @unit_of_work()\n    def cleanup_drafts(self, timedelta, uow=None):\n        \"\"\"Hard delete of soft deleted drafts.\n\n        :param int timedelta: timedelta that should pass since\n            the last update of the draft in order to be hard deleted.\n        \"\"\"\n        self.draft_cls.cleanup_drafts(timedelta)\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n#\n# Copyright (C) 2020-2021 CERN.\n# Copyright (C) 2020 Northwestern University.\n#\n# Invenio-Drafts-Resources is free software; you can redistribute it and/or\n# modify it under the terms of the MIT License; see LICENSE file for more\n# details.\n\n\"\"\"Primary service for working with records and drafts.\"\"\"\n\nfrom elasticsearch_dsl.query import Q\nfrom invenio_db import db\nfrom invenio_records_resources.services import LinksTemplate\nfrom invenio_records_resources.services import \\\n    RecordService as RecordServiceBase\nfrom invenio_records_resources.services import ServiceSchemaWrapper\nfrom invenio_records_resources.services.uow import RecordCommitOp, \\\n    RecordDeleteOp, RecordIndexOp, unit_of_work\nfrom sqlalchemy.orm.exc import NoResultFound\n\n\nclass RecordService(RecordServiceBase):\n    \"\"\"Record and draft service interface.\n\n    This service provides an interface to business logic for published and\n    draft records.\n    \"\"\"\n\n    def __init__(self, config, files_service=None, draft_files_service=None):\n        \"\"\"Constructor for RecordService.\"\"\"\n        super().__init__(config)\n        self._files = files_service\n        self._draft_files = draft_files_service\n\n    #\n    # Subservices\n    #\n    @property\n    def files(self):\n        \"\"\"Record files service.\"\"\"\n        return self._files\n\n    @property\n    def draft_files(self):\n        \"\"\"Draft files service.\"\"\"\n        return self._draft_files\n\n    #\n    # Properties\n    #\n    @property\n    def schema_parent(self):\n        \"\"\"Schema for parent records.\"\"\"\n        return ServiceSchemaWrapper(self, schema=self.config.schema_parent)\n\n    @property\n    def draft_cls(self):\n        \"\"\"Factory for creating a record class.\"\"\"\n        return self.config.draft_cls\n\n    # High-level API\n    # Inherits record search, read, create, delete and update\n\n    def update(self, *args, **kwargs):\n        \"\"\"Do not use.\"\"\"\n        raise NotImplementedError(\"Records should be updated via their draft.\")\n\n    def search_drafts(self, identity, params=None, es_preference=None,\n                      **kwargs):\n        \"\"\"Search for drafts records matching the querystring.\"\"\"\n        self.require_permission(identity, 'search_drafts')\n\n        # Prepare and execute the search\n        params = params or {}\n\n        search_result = self._search(\n            'search_drafts',\n            identity,\n            params,\n            es_preference,\n            record_cls=self.draft_cls,\n            search_opts=self.config.search_drafts,\n            # `has_draft` systemfield is not defined here. This is not ideal\n            # but it helps avoid overriding the method. See how is used in\n            # https://github.com/inveniosoftware/invenio-rdm-records\n            extra_filter=Q('term', has_draft=False),\n            permission_action='read_draft',\n            **kwargs\n        ).execute()\n\n        return self.result_list(\n            self,\n            identity,\n            search_result,\n            params,\n            links_tpl=LinksTemplate(self.config.links_search_drafts, context={\n                \"args\": params\n            }),\n            links_item_tpl=self.links_item_tpl,\n        )\n\n    def search_versions(self, id_, identity, params=None, es_preference=None,\n                        **kwargs):\n        \"\"\"Search for record's versions.\"\"\"\n        try:\n            record = self.record_cls.pid.resolve(id_, registered_only=False)\n        except NoResultFound:\n            record = self.draft_cls.pid.resolve(id_, registered_only=False)\n\n        self.require_permission(identity, \"read\", record=record)\n\n        # Prepare and execute the search\n        params = params or {}\n\n        search_result = self._search(\n            'search_versions',\n            identity,\n            params,\n            es_preference,\n            record_cls=self.record_cls,\n            search_opts=self.config.search_versions,\n            extra_filter=Q(\n                'term', **{'parent.id': str(record.parent.pid.pid_value)}),\n            permission_action='read',\n            **kwargs\n        ).execute()\n\n        return self.result_list(\n            self,\n            identity,\n            search_result,\n            params,\n            links_tpl=LinksTemplate(\n                self.config.links_search_versions,\n                context={\"id\": id_, \"args\": params}\n            ),\n            links_item_tpl=self.links_item_tpl,\n        )\n\n    def read_draft(self, id_, identity):\n        \"\"\"Retrieve a draft.\"\"\"\n        # Resolve and require permission\n        draft = self.draft_cls.pid.resolve(id_, registered_only=False)\n        self.require_permission(identity, \"read_draft\", record=draft)\n\n        # Run components\n        for component in self.components:\n            if hasattr(component, 'read_draft'):\n                component.read_draft(identity, draft=draft)\n\n        return self.result_item(\n            self, identity, draft, links_tpl=self.links_item_tpl)\n\n    def read_latest(self, id_, identity):\n        \"\"\"Retrieve latest record.\"\"\"\n        # Resolve and require permission\n        record = self.record_cls.pid.resolve(id_)\n\n        # Retrieve latest if record is not\n        if not record.versions.is_latest:\n            record = self.record_cls.get_record(record.versions.latest_id)\n\n        self.require_permission(identity, \"read\", record=record)\n\n        return self.result_item(\n            self, identity, record, links_tpl=self.links_item_tpl)\n\n    @unit_of_work()\n    def update_draft(self, id_, identity, data, revision_id=None, uow=None):\n        \"\"\"Replace a draft.\"\"\"\n        draft = self.draft_cls.pid.resolve(id_, registered_only=False)\n\n        self.check_revision_id(draft, revision_id)\n\n        # Permissions\n        self.require_permission(identity, \"update_draft\", record=draft)\n\n        # Load data with service schema\n        data, errors = self.schema.load(\n            data,\n            context=dict(\n                identity=identity,\n                pid=draft.pid,\n                record=draft,\n            ),\n            # Saving a draft only saves valid metadata and reports\n            # (doesn't raise) errors\n            raise_errors=False\n        )\n\n        # Run components\n        self.run_components(\n            'update_draft', identity, record=draft, data=data,\n            errors=errors, uow=uow\n        )\n\n        # Commit and index\n        uow.register(RecordCommitOp(draft, indexer=self.indexer))\n\n        return self.result_item(\n            self,\n            identity,\n            draft,\n            links_tpl=self.links_item_tpl,\n            errors=errors\n        )\n\n    @unit_of_work()\n    def create(self, identity, data, uow=None):\n        \"\"\"Create a draft for a new record.\n\n        It does NOT eagerly create the associated record.\n        \"\"\"\n        res = self._create(\n           self.draft_cls,\n           identity,\n           data,\n           raise_errors=False,\n           uow=uow,\n        )\n        uow.register(RecordCommitOp(res._record.parent))\n        return res\n\n    @unit_of_work()\n    def edit(self, id_, identity, uow=None):\n        \"\"\"Create a new revision or a draft for an existing record.\n\n        :param id_: record PID value.\n        \"\"\"\n        # Draft exists - return it\n        try:\n            draft = self.draft_cls.pid.resolve(id_, registered_only=False)\n            self.require_permission(identity, \"edit\", record=draft)\n            return self.result_item(\n                self, identity, draft, links_tpl=self.links_item_tpl)\n        except NoResultFound:\n            pass\n\n        # Draft does not exists - so get the main record we want to edit and\n        # create a draft from it\n        record = self.record_cls.pid.resolve(id_)\n        self.require_permission(identity, \"edit\", record=record)\n        draft = self.draft_cls.edit(record)\n\n        # Run components\n        self.run_components(\n            \"edit\", identity, draft=draft, record=record, uow=uow)\n\n        uow.register(RecordCommitOp(draft, indexer=self.indexer))\n\n        # Reindex the record to trigger update of computed values in the\n        # available dumpers of the record.\n        uow.register(RecordIndexOp(record, indexer=self.indexer))\n\n        return self.result_item(\n            self, identity, draft, links_tpl=self.links_item_tpl)\n\n    @unit_of_work()\n    def publish(self, id_, identity, uow=None):\n        \"\"\"Publish a draft.\n\n        Idea:\n            - Get the draft from the data layer (draft is not passed in)\n            - Validate it more strictly than when it was originally saved\n              (drafts can be incomplete but only complete drafts can be turned\n              into records)\n            - Create or update associated (published) record with data\n        \"\"\"\n        # Get the draft\n        draft = self.draft_cls.pid.resolve(id_, registered_only=False)\n        self.require_permission(identity, \"publish\", record=draft)\n\n        # Validate the draft strictly - since a draft can be saved with errors\n        # we do a strict validation here to make sure only valid drafts can be\n        # published.\n        self._validate_draft(identity, draft)\n\n        # Create the record from the draft\n        latest_id = draft.versions.latest_id\n        record = self.record_cls.publish(draft)\n\n        # Run components\n        self.run_components(\n            'publish', identity, draft=draft, record=record, uow=uow)\n\n        # Commit and index\n        uow.register(RecordCommitOp(record, indexer=self.indexer))\n        uow.register(RecordDeleteOp(draft, force=False, indexer=self.indexer))\n\n        if latest_id:\n            self._reindex_latest(latest_id, uow=uow)\n\n        return self.result_item(\n            self, identity, record, links_tpl=self.links_item_tpl)\n\n    @unit_of_work()\n    def new_version(self, id_, identity, uow=None):\n        \"\"\"Create a new version of a record.\"\"\"\n        # Get the a record - i.e. you can only create a new version in case\n        # at least one published record already exists.\n        record = self.record_cls.pid.resolve(id_)\n\n        # Check permissions\n        self.require_permission(identity, \"new_version\", record=record)\n\n        # Draft for new version already exists? if so return it\n        if record.versions.next_draft_id:\n            next_draft = self.draft_cls.get_record(\n                record.versions.next_draft_id)\n            return self.result_item(\n                self, identity, next_draft, links_tpl=self.links_item_tpl)\n\n        # Draft for new version does not exists, so create it\n        next_draft = self.draft_cls.new_version(record)\n\n        # Get the latest published record if it's not the current one.\n        if not record.versions.is_latest:\n            record = self.record_cls.get_record(record.versions.latest_id)\n\n        # Run components\n        self.run_components(\n            'new_version', identity, draft=next_draft, record=record, uow=uow)\n\n        # Commit and index\n        uow.register(RecordCommitOp(next_draft, indexer=self.indexer))\n\n        self._reindex_latest(\n            next_draft.versions.latest_id, record=record, uow=uow)\n\n        return self.result_item(\n            self, identity, next_draft, links_tpl=self.links_item_tpl)\n\n    @unit_of_work()\n    def delete_draft(self, id_, identity, revision_id=None, uow=None):\n        \"\"\"Delete a record from database and search indexes.\"\"\"\n        draft = self.draft_cls.pid.resolve(id_, registered_only=False)\n        latest_id = draft.versions.latest_id\n\n        self.check_revision_id(draft, revision_id)\n\n        # Permissions\n        self.require_permission(identity, \"delete_draft\", record=draft)\n\n        # Get published record if exists\n        try:\n            record = self.record_cls.get_record(draft.id)\n        except NoResultFound:\n            record = None\n\n        # We soft-delete a draft when a published record exists, in order to\n        # keep the version_id counter around for optimistic concurrency\n        # control (both for ES indexing and for REST API clients)\n        force = False if record else True\n\n        # Run components\n        self.run_components(\n            'delete_draft', identity, draft=draft, record=record,\n            force=force, uow=uow\n        )\n\n        # Note, the parent record deletion logic is implemented in the\n        # ParentField and will automatically take care of deleting the parent\n        # record in case this is the only draft that exists for the parent.\n        # We refresh the index because users are usually redirected to a\n        # search result immediately after, and we don't want the users to see\n        # their just deleted draft.\n        uow.register(RecordDeleteOp(\n            draft, indexer=self.indexer, force=force, index_refresh=True))\n\n        if force:\n            # Case 1: We deleted a new draft (without a published record) or a\n            # new version draft (without a published).\n            # In this case, we reindex the latest published record/draft\n            self._reindex_latest(latest_id, refresh=True, uow=uow)\n        else:\n            # Case 2: We deleted a draft for a published record.\n            # In this case we reindex just the published record to trigger and\n            # update of computed values.\n            uow.register(RecordIndexOp(\n                record, indexer=self.indexer, index_refresh=True))\n\n        return True\n\n    @unit_of_work()\n    def import_files(self, id_, identity, uow=None):\n        \"\"\"Import files from previous record version.\"\"\"\n        if self.draft_files is None:\n            raise RuntimeError(\"Files support is not enabled.\")\n\n        # Read draft\n        draft = self.draft_cls.pid.resolve(id_, registered_only=False)\n        self.require_permission(identity, \"draft_create_files\", record=draft)\n\n        # Retrieve latest record\n        record = self.record_cls.get_record(draft.versions.latest_id)\n        self.require_permission(identity, \"read_files\", record=record)\n\n        # Run components\n        self.run_components(\n            'import_files', identity, draft=draft, record=record, uow=uow)\n\n        # Commit and index\n        uow.register(RecordCommitOp(draft, indexer=self.indexer))\n\n        return self.draft_files.file_result_list(\n            self.draft_files,\n            identity,\n            results=draft.files.values(),\n            record=draft,\n            links_tpl=self.draft_files.file_links_list_tpl(id_),\n            links_item_tpl=self.draft_files.file_links_item_tpl(id_),\n        )\n\n    def rebuild_index(self, identity):\n        \"\"\"Reindex all records and drafts.\n\n        Note: Skips (soft) deleted records and drafts.\n        \"\"\"\n        ret_val = super().rebuild_index(identity)\n\n        for draft_meta in self.draft_cls.model_cls.query.all():\n            draft = self.draft_cls(draft_meta.data, model=draft_meta)\n            if not draft.is_deleted:\n                self.indexer.index(draft)\n\n        return ret_val\n\n    def validate_draft(self, identity, id_):\n        \"\"\"Validate a draft.\"\"\"\n        draft = self.draft_cls.pid.resolve(id_, registered_only=False)\n        self._validate_draft(identity, draft)\n\n    def _validate_draft(self, identity, draft):\n        \"\"\"Validate a draft.\n\n        This method is internal because it works with a data access layer\n        draft, and thus should not be called from outside the service.\n        \"\"\"\n        # Convert to draft into service layer draft result item (a record\n        # projection for the given identity). This way we can load and validate\n        # the data with the service schema.\n        draft_item = self.result_item(self, identity, draft)\n        # Validate the data - will raise ValidationError if not valid.\n        self.schema.load(\n            data=draft_item.data,\n            context=dict(\n                identity=identity,\n                pid=draft.pid,\n                record=draft,\n            ),\n            raise_errors=True  # this is the default, but might as well be\n                               # explicit\n        )\n\n    @unit_of_work()\n    def _reindex_latest(self, latest_id, record=None, draft=None,\n                        refresh=False, uow=None):\n        \"\"\"Reindex the latest published record and draft.\n\n        This triggers and update of computed values in the index, such as\n        \"is_latest\".\n\n        This method is internal because it works with a data access layer\n        record/draft, and thus should not be called from outside the service.\n        \"\"\"\n        # We only have a draft, no latest to index\n        if not latest_id:\n            return\n\n        # Note, the record may not be the latest published record, and we only\n        # want to index the latest published.\n        if record is None or latest_id != record.id:\n            record = self.record_cls.get_record(latest_id)\n        uow.register(\n            RecordIndexOp(record, indexer=self.indexer, index_refresh=refresh))\n\n        # Note, a draft may or may not exists for a published record (depending\n        # on if it's being edited).\n        try:\n            draft = self.draft_cls.get_record(latest_id)\n            uow.register(RecordIndexOp(\n                draft, indexer=self.indexer, index_refresh=refresh))\n        except NoResultFound:\n            pass\n\n    def _get_record_and_parent_by_id(self, id_):\n        \"\"\"Resolve the record and its parent, by the given ID.\n\n        If the ID belongs to a parent record, no child record will be\n        resolved.\n        \"\"\"\n        record = self.record_cls.pid.resolve(id_, registered_only=False)\n        parent = record.parent\n\n        return record, parent\n\n    def _get_draft_and_parent_by_id(self, id_):\n        \"\"\"Resolve the draft and its parent, by the given ID.\"\"\"\n        draft = self.draft_cls.pid.resolve(id_, registered_only=False)\n        parent = draft.parent\n\n        return draft, parent\n\n    @unit_of_work()\n    def _index_related_records(self, record, parent, uow=None):\n        \"\"\"Index all records that are related to the specified ones.\"\"\"\n        siblings = self.record_cls.get_records_by_parent(\n            parent or record.parent\n        )\n\n        # TODO only index the current record immediately;\n        #      all siblings should be sent to a high-priority celery task\n        #      instead (requires bulk indexing to work)\n        for sibling in siblings:\n            uow.register(RecordIndexOp(sibling, indexer=self.indexer))\n\n    @unit_of_work()\n    def cleanup_drafts(self, timedelta, uow=None):\n        \"\"\"Hard delete of soft deleted drafts.\n\n        :param int timedelta: timedelta that should pass since\n            the last update of the draft in order to be hard deleted.\n        \"\"\"\n        self.draft_cls.cleanup_drafts(timedelta)\n"], "filenames": ["invenio_drafts_resources/services/records/service.py"], "buggy_code_start_loc": [270], "buggy_code_end_loc": [273], "fixing_code_start_loc": [269], "fixing_code_end_loc": [273], "type": "CWE-863", "message": "Invenio-Drafts-Resources is a submission/deposit module for Invenio, a software framework for research data management. Invenio-Drafts-Resources prior to versions 0.13.7 and 0.14.6 does not properly check permissions when a record is published. The vulnerability is exploitable in a default installation of InvenioRDM. An authenticated a user is able via REST API calls to publish draft records of other users if they know the record identifier and the draft validates (e.g. all require fields filled out). An attacker is not able to modify the data in the record, and thus e.g. *cannot* change a record from restricted to public. The problem is patched in Invenio-Drafts-Resources v0.13.7 and 0.14.6, which is part of InvenioRDM v6.0.1 and InvenioRDM v7.0 respectively.", "other": {"cve": {"id": "CVE-2021-43781", "sourceIdentifier": "security-advisories@github.com", "published": "2021-12-06T18:15:08.180", "lastModified": "2022-07-25T10:38:29.543", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Invenio-Drafts-Resources is a submission/deposit module for Invenio, a software framework for research data management. Invenio-Drafts-Resources prior to versions 0.13.7 and 0.14.6 does not properly check permissions when a record is published. The vulnerability is exploitable in a default installation of InvenioRDM. An authenticated a user is able via REST API calls to publish draft records of other users if they know the record identifier and the draft validates (e.g. all require fields filled out). An attacker is not able to modify the data in the record, and thus e.g. *cannot* change a record from restricted to public. The problem is patched in Invenio-Drafts-Resources v0.13.7 and 0.14.6, which is part of InvenioRDM v6.0.1 and InvenioRDM v7.0 respectively."}, {"lang": "es", "value": "Invenio-Drafts-Resources es un m\u00f3dulo de env\u00edo/dep\u00f3sito para Invenio, un marco de software para la administraci\u00f3n de datos de investigaci\u00f3n. Invenio-Drafts-Resources anterior a versiones 0.13.7 y 0.14.6, no comprueba correctamente los permisos cuando es publicado un registro. La vulnerabilidad es explotable en una instalaci\u00f3n por defecto de InvenioRDM. Un usuario autenticado es capaz, por medio de llamadas a la API REST, de publicar borradores de registros de otros usuarios si conoce el identificador del registro y el borrador es comprobado (por ejemplo, si se rellenan todos los campos obligatorios). Un atacante no puede modificar los datos del registro y, por tanto, no puede cambiar un registro de restringido a p\u00fablico. El problema est\u00e1 parcheado en Invenio-Drafts-Resources versiones v0.13.7 y 0.14.6, que forman parte de InvenioRDM versi\u00f3n v6.0.1 e InvenioRDM versi\u00f3n v7.0 respectivamente"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.1, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-862"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:inveniosoftware:invenio-drafts-resources:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.13.7", "matchCriteriaId": "0E1B55C1-EEE3-41EE-A577-BC1C5978DDC1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:inveniosoftware:invenio-drafts-resources:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.14.0", "versionEndExcluding": "0.14.6", "matchCriteriaId": "449A4BE1-E21B-4EF3-9DBB-0A21090B6887"}]}]}], "references": [{"url": "https://github.com/inveniosoftware/invenio-drafts-resources/commit/039b0cff1ad4b952000f4d8c3a93f347108b6626", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/inveniosoftware/invenio-drafts-resources/security/advisories/GHSA-xr38-w74q-r8jv", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/inveniosoftware/invenio-drafts-resources/commit/039b0cff1ad4b952000f4d8c3a93f347108b6626"}}