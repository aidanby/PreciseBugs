{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#ifndef _GF_ISOMEDIA_DEV_H_\n#define _GF_ISOMEDIA_DEV_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <gpac/isomedia.h>\n\n\nenum\n{\n\t//internal code type for unknown boxes\n\tGF_ISOM_BOX_TYPE_UNKNOWN = GF_4CC( 'U', 'N', 'K', 'N' ),\n\n\tGF_ISOM_BOX_TYPE_CO64\t= GF_4CC( 'c', 'o', '6', '4' ),\n\tGF_ISOM_BOX_TYPE_STCO\t= GF_4CC( 's', 't', 'c', 'o' ),\n\tGF_ISOM_BOX_TYPE_CTTS\t= GF_4CC( 'c', 't', 't', 's' ),\n\tGF_ISOM_BOX_TYPE_CPRT\t= GF_4CC( 'c', 'p', 'r', 't' ),\n\tGF_ISOM_BOX_TYPE_KIND\t= GF_4CC( 'k', 'i', 'n', 'd' ),\n\tGF_ISOM_BOX_TYPE_CHPL\t= GF_4CC( 'c', 'h', 'p', 'l' ),\n\tGF_ISOM_BOX_TYPE_URL\t= GF_4CC( 'u', 'r', 'l', ' ' ),\n\tGF_ISOM_BOX_TYPE_URN\t= GF_4CC( 'u', 'r', 'n', ' ' ),\n\tGF_ISOM_BOX_TYPE_DINF\t= GF_4CC( 'd', 'i', 'n', 'f' ),\n\tGF_ISOM_BOX_TYPE_DREF\t= GF_4CC( 'd', 'r', 'e', 'f' ),\n\tGF_ISOM_BOX_TYPE_STDP\t= GF_4CC( 's', 't', 'd', 'p' ),\n\tGF_ISOM_BOX_TYPE_EDTS\t= GF_4CC( 'e', 'd', 't', 's' ),\n\tGF_ISOM_BOX_TYPE_ELST\t= GF_4CC( 'e', 'l', 's', 't' ),\n\tGF_ISOM_BOX_TYPE_UUID\t= GF_4CC( 'u', 'u', 'i', 'd' ),\n\tGF_ISOM_BOX_TYPE_FREE\t= GF_4CC( 'f', 'r', 'e', 'e' ),\n\tGF_ISOM_BOX_TYPE_HDLR\t= GF_4CC( 'h', 'd', 'l', 'r' ),\n\tGF_ISOM_BOX_TYPE_GMHD\t= GF_4CC( 'g', 'm', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_HMHD\t= GF_4CC( 'h', 'm', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_HINT\t= GF_4CC( 'h', 'i', 'n', 't' ),\n\tGF_ISOM_BOX_TYPE_MDIA\t= GF_4CC( 'm', 'd', 'i', 'a' ),\n\tGF_ISOM_BOX_TYPE_ELNG\t= GF_4CC( 'e', 'l', 'n', 'g' ),\n\tGF_ISOM_BOX_TYPE_MDAT\t= GF_4CC( 'm', 'd', 'a', 't' ),\n\tGF_ISOM_BOX_TYPE_IDAT\t= GF_4CC( 'i', 'd', 'a', 't' ),\n\tGF_ISOM_BOX_TYPE_MDHD\t= GF_4CC( 'm', 'd', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_MINF\t= GF_4CC( 'm', 'i', 'n', 'f' ),\n\tGF_ISOM_BOX_TYPE_MOOV\t= GF_4CC( 'm', 'o', 'o', 'v' ),\n\tGF_ISOM_BOX_TYPE_MVHD\t= GF_4CC( 'm', 'v', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_STSD\t= GF_4CC( 's', 't', 's', 'd' ),\n\tGF_ISOM_BOX_TYPE_STSZ\t= GF_4CC( 's', 't', 's', 'z' ),\n\tGF_ISOM_BOX_TYPE_STZ2\t= GF_4CC( 's', 't', 'z', '2' ),\n\tGF_ISOM_BOX_TYPE_STBL\t= GF_4CC( 's', 't', 'b', 'l' ),\n\tGF_ISOM_BOX_TYPE_STSC\t= GF_4CC( 's', 't', 's', 'c' ),\n\tGF_ISOM_BOX_TYPE_STSH\t= GF_4CC( 's', 't', 's', 'h' ),\n\tGF_ISOM_BOX_TYPE_SKIP\t= GF_4CC( 's', 'k', 'i', 'p' ),\n\tGF_ISOM_BOX_TYPE_SMHD\t= GF_4CC( 's', 'm', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_STSS\t= GF_4CC( 's', 't', 's', 's' ),\n\tGF_ISOM_BOX_TYPE_STTS\t= GF_4CC( 's', 't', 't', 's' ),\n\tGF_ISOM_BOX_TYPE_TRAK\t= GF_4CC( 't', 'r', 'a', 'k' ),\n\tGF_ISOM_BOX_TYPE_TKHD\t= GF_4CC( 't', 'k', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_TREF\t= GF_4CC( 't', 'r', 'e', 'f' ),\n\tGF_ISOM_BOX_TYPE_STRK\t= GF_4CC( 's', 't', 'r', 'k' ),\n\tGF_ISOM_BOX_TYPE_STRI\t= GF_4CC( 's', 't', 'r', 'i' ),\n\tGF_ISOM_BOX_TYPE_STRD\t= GF_4CC( 's', 't', 'r', 'd' ),\n\tGF_ISOM_BOX_TYPE_STSG\t= GF_4CC( 's', 't', 's', 'g' ),\n\n\tGF_ISOM_BOX_TYPE_UDTA\t= GF_4CC( 'u', 'd', 't', 'a' ),\n\tGF_ISOM_BOX_TYPE_VMHD\t= GF_4CC( 'v', 'm', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_FTYP\t= GF_4CC( 'f', 't', 'y', 'p' ),\n\tGF_ISOM_BOX_TYPE_OTYP\t= GF_4CC( 'o', 't', 'y', 'p' ),\n\tGF_ISOM_BOX_TYPE_PADB\t= GF_4CC( 'p', 'a', 'd', 'b' ),\n\tGF_ISOM_BOX_TYPE_PDIN\t= GF_4CC( 'p', 'd', 'i', 'n' ),\n\tGF_ISOM_BOX_TYPE_SDTP\t= GF_4CC( 's', 'd', 't', 'p' ),\n\tGF_ISOM_BOX_TYPE_CSLG\t= GF_4CC( 'c', 's', 'l', 'g' ),\n\n\tGF_ISOM_BOX_TYPE_SBGP\t= GF_4CC( 's', 'b', 'g', 'p' ),\n\tGF_ISOM_BOX_TYPE_SGPD\t= GF_4CC( 's', 'g', 'p', 'd' ),\n\tGF_ISOM_BOX_TYPE_SAIZ\t= GF_4CC( 's', 'a', 'i', 'z' ),\n\tGF_ISOM_BOX_TYPE_SAIO\t= GF_4CC( 's', 'a', 'i', 'o' ),\n\tGF_ISOM_BOX_TYPE_MFRA\t= GF_4CC( 'm', 'f', 'r', 'a' ),\n\tGF_ISOM_BOX_TYPE_MFRO\t= GF_4CC( 'm', 'f', 'r', 'o' ),\n\tGF_ISOM_BOX_TYPE_TFRA\t= GF_4CC( 't', 'f', 'r', 'a' ),\n\tGF_ISOM_BOX_TYPE_CSGP\t= GF_4CC( 'c', 's', 'g', 'p'),\n\n\tGF_ISOM_BOX_TYPE_TENC\t= GF_4CC( 't', 'e', 'n', 'c' ),\n\n\t//track group\n\tGF_ISOM_BOX_TYPE_TRGR\t= GF_4CC( 't', 'r', 'g', 'r' ),\n\t//track group types\n\tGF_ISOM_BOX_TYPE_TRGT\t= GF_4CC( 't', 'r', 'g', 't' ),\n\tGF_ISOM_BOX_TYPE_MSRC\t= GF_4CC( 'm', 's', 'r', 'c' ),\n\tGF_ISOM_BOX_TYPE_CSTG\t= GF_4CC( 'c', 's', 't', 'g' ),\n\tGF_ISOM_BOX_TYPE_STER\t= GF_4CC( 's', 't', 'e', 'r' ),\n\n\t/*Adobe's protection boxes*/\n\tGF_ISOM_BOX_TYPE_ADKM\t= GF_4CC( 'a', 'd', 'k', 'm' ),\n\tGF_ISOM_BOX_TYPE_AHDR\t= GF_4CC( 'a', 'h', 'd', 'r' ),\n\tGF_ISOM_BOX_TYPE_ADAF\t= GF_4CC( 'a', 'd', 'a', 'f' ),\n\tGF_ISOM_BOX_TYPE_APRM\t= GF_4CC( 'a', 'p', 'r', 'm' ),\n\tGF_ISOM_BOX_TYPE_AEIB\t= GF_4CC( 'a', 'e', 'i', 'b' ),\n\tGF_ISOM_BOX_TYPE_AKEY\t= GF_4CC( 'a', 'k', 'e', 'y' ),\n\tGF_ISOM_BOX_TYPE_FLXS\t= GF_4CC( 'f', 'l', 'x', 's' ),\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t/*Movie Fragments*/\n\tGF_ISOM_BOX_TYPE_MVEX\t= GF_4CC( 'm', 'v', 'e', 'x' ),\n\tGF_ISOM_BOX_TYPE_MEHD\t= GF_4CC( 'm', 'e', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_TREX\t= GF_4CC( 't', 'r', 'e', 'x' ),\n\tGF_ISOM_BOX_TYPE_TREP\t= GF_4CC( 't', 'r', 'e', 'p' ),\n\tGF_ISOM_BOX_TYPE_MOOF\t= GF_4CC( 'm', 'o', 'o', 'f' ),\n\tGF_ISOM_BOX_TYPE_MFHD\t= GF_4CC( 'm', 'f', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_TRAF\t= GF_4CC( 't', 'r', 'a', 'f' ),\n\tGF_ISOM_BOX_TYPE_TFHD\t= GF_4CC( 't', 'f', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_TRUN\t= GF_4CC( 't', 'r', 'u', 'n' ),\n#ifdef GF_ENABLE_CTRN\n\tGF_ISOM_BOX_TYPE_CTRN\t= GF_4CC( 'c', 't', 'r', 'n' ),\n#endif\n\n#endif\n\n\n\t/*MP4 extensions*/\n\tGF_ISOM_BOX_TYPE_DPND\t= GF_4CC( 'd', 'p', 'n', 'd' ),\n\tGF_ISOM_BOX_TYPE_IODS\t= GF_4CC( 'i', 'o', 'd', 's' ),\n\tGF_ISOM_BOX_TYPE_ESDS\t= GF_4CC( 'e', 's', 'd', 's' ),\n\tGF_ISOM_BOX_TYPE_MPOD\t= GF_4CC( 'm', 'p', 'o', 'd' ),\n\tGF_ISOM_BOX_TYPE_SYNC\t= GF_4CC( 's', 'y', 'n', 'c' ),\n\tGF_ISOM_BOX_TYPE_IPIR\t= GF_4CC( 'i', 'p', 'i', 'r' ),\n\n\tGF_ISOM_BOX_TYPE_NMHD\t= GF_4CC( 'n', 'm', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_STHD\t= GF_4CC( 's', 't', 'h', 'd' ),\n\t/*reseved\n\tGF_ISOM_BOX_TYPE_SDHD\t= GF_4CC( 's', 'd', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_ODHD\t= GF_4CC( 'o', 'd', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_CRHD\t= GF_4CC( 'c', 'r', 'h', 'd' ),\n\t*/\n\tGF_ISOM_BOX_TYPE_MP4S\t= GF_4CC( 'm', 'p', '4', 's' ),\n\tGF_ISOM_BOX_TYPE_MP4A\t= GF_4CC( 'm', 'p', '4', 'a' ),\n\tGF_ISOM_BOX_TYPE_MP4V\t= GF_4CC( 'm', 'p', '4', 'v' ),\n\n\n\t/*AVC / H264 extension*/\n\tGF_ISOM_BOX_TYPE_AVCC\t= GF_4CC( 'a', 'v', 'c', 'C' ),\n\tGF_ISOM_BOX_TYPE_BTRT\t= GF_4CC( 'b', 't', 'r', 't' ),\n\tGF_ISOM_BOX_TYPE_M4DS\t= GF_4CC( 'm', '4', 'd', 's' ),\n\tGF_ISOM_BOX_TYPE_PASP\t= GF_4CC( 'p', 'a', 's', 'p' ),\n\tGF_ISOM_BOX_TYPE_CLAP\t= GF_4CC( 'c', 'l', 'a', 'p' ),\n\tGF_ISOM_BOX_TYPE_AVC1\t= GF_4CC( 'a', 'v', 'c', '1' ),\n\tGF_ISOM_BOX_TYPE_AVC2\t= GF_4CC( 'a', 'v', 'c', '2' ),\n\tGF_ISOM_BOX_TYPE_AVC3\t= GF_4CC( 'a', 'v', 'c', '3' ),\n\tGF_ISOM_BOX_TYPE_AVC4\t= GF_4CC( 'a', 'v', 'c', '4' ),\n\tGF_ISOM_BOX_TYPE_SVCC\t= GF_4CC( 's', 'v', 'c', 'C' ),\n\tGF_ISOM_BOX_TYPE_SVC1\t= GF_4CC( 's', 'v', 'c', '1' ),\n\tGF_ISOM_BOX_TYPE_SVC2\t= GF_4CC( 's', 'v', 'c', '2' ),\n\tGF_ISOM_BOX_TYPE_MVCC\t= GF_4CC( 'm', 'v', 'c', 'C' ),\n\tGF_ISOM_BOX_TYPE_MVC1\t= GF_4CC( 'm', 'v', 'c', '1' ),\n\tGF_ISOM_BOX_TYPE_MVC2\t= GF_4CC( 'm', 'v', 'c', '2' ),\n\tGF_ISOM_BOX_TYPE_MHC1\t= GF_4CC( 'm', 'h', 'c', '1' ),\n\tGF_ISOM_BOX_TYPE_MHV1\t= GF_4CC( 'm', 'h', 'v', '1' ),\n\n\tGF_ISOM_BOX_TYPE_HVCC\t= GF_4CC( 'h', 'v', 'c', 'C' ),\n\tGF_ISOM_BOX_TYPE_HVC1\t= GF_4CC( 'h', 'v', 'c', '1' ),\n\tGF_ISOM_BOX_TYPE_HEV1\t= GF_4CC( 'h', 'e', 'v', '1' ),\n\tGF_ISOM_BOX_TYPE_HVT1\t= GF_4CC( 'h', 'v', 't', '1' ),\n\tGF_ISOM_BOX_TYPE_MVCI\t= GF_4CC( 'm', 'v', 'c', 'i' ),\n\tGF_ISOM_BOX_TYPE_MVCG\t= GF_4CC( 'm', 'v', 'c', 'g' ),\n\tGF_ISOM_BOX_TYPE_VWID\t= GF_4CC( 'v', 'w', 'i', 'd' ),\n\n\tGF_ISOM_BOX_TYPE_HVC2\t= GF_4CC( 'h', 'v', 'c', '2' ),\n\tGF_ISOM_BOX_TYPE_HEV2\t= GF_4CC( 'h', 'e', 'v', '2' ),\n\tGF_ISOM_BOX_TYPE_LHV1\t= GF_4CC( 'l', 'h', 'v', '1' ),\n\tGF_ISOM_BOX_TYPE_LHE1\t= GF_4CC( 'l', 'h', 'e', '1' ),\n\tGF_ISOM_BOX_TYPE_LHT1\t= GF_4CC( 'l', 'h', 't', '1' ),\n\n\tGF_ISOM_BOX_TYPE_LHVC\t= GF_4CC( 'l', 'h', 'v', 'C' ),\n\n\tGF_ISOM_BOX_TYPE_VVC1\t= GF_4CC( 'v', 'v', 'c', '1' ),\n\tGF_ISOM_BOX_TYPE_VVI1\t= GF_4CC( 'v', 'v', 'i', '1' ),\n\tGF_ISOM_BOX_TYPE_VVCC\t= GF_4CC( 'v', 'v', 'c', 'C' ),\n\n\tGF_ISOM_BOX_TYPE_AV1C = GF_4CC('a', 'v', '1', 'C'),\n\tGF_ISOM_BOX_TYPE_AV01 = GF_4CC('a', 'v', '0', '1'),\n\n\t/*WebM*/\n\tGF_ISOM_BOX_TYPE_VPCC = GF_4CC('v', 'p', 'c', 'C'),\n\tGF_ISOM_BOX_TYPE_VP08 = GF_4CC('v', 'p', '0', '8'),\n\tGF_ISOM_BOX_TYPE_VP09 = GF_4CC('v', 'p', '0', '9'),\n\tGF_ISOM_BOX_TYPE_SMDM = GF_4CC('S', 'm', 'D', 'm'),\n\tGF_ISOM_BOX_TYPE_COLL = GF_4CC('C', 'o', 'L', 'L'),\n\n\t/*Opus*/\n\tGF_ISOM_BOX_TYPE_OPUS = GF_4CC('O', 'p', 'u', 's'),\n\tGF_ISOM_BOX_TYPE_DOPS = GF_4CC('d', 'O', 'p', 's'),\n\n\t/*LASeR extension*/\n\tGF_ISOM_BOX_TYPE_LSRC\t= GF_4CC( 'l', 's', 'r', 'C' ),\n\tGF_ISOM_BOX_TYPE_LSR1\t= GF_4CC( 'l', 's', 'r', '1' ),\n\n\t/*3GPP extensions*/\n\tGF_ISOM_BOX_TYPE_DAMR\t= GF_4CC( 'd', 'a', 'm', 'r' ),\n\tGF_ISOM_BOX_TYPE_D263\t= GF_4CC( 'd', '2', '6', '3' ),\n\tGF_ISOM_BOX_TYPE_DEVC\t= GF_4CC( 'd', 'e', 'v', 'c' ),\n\tGF_ISOM_BOX_TYPE_DQCP\t= GF_4CC( 'd', 'q', 'c', 'p' ),\n\tGF_ISOM_BOX_TYPE_DSMV\t= GF_4CC( 'd', 's', 'm', 'v' ),\n\tGF_ISOM_BOX_TYPE_TSEL\t= GF_4CC( 't', 's', 'e', 'l' ),\n\n\t/* 3GPP Adaptive Streaming extensions */\n\tGF_ISOM_BOX_TYPE_STYP\t= GF_4CC( 's', 't', 'y', 'p' ),\n\tGF_ISOM_BOX_TYPE_TFDT\t= GF_4CC( 't', 'f', 'd', 't' ),\n\tGF_ISOM_BOX_TYPE_SIDX\t= GF_4CC( 's', 'i', 'd', 'x' ),\n\tGF_ISOM_BOX_TYPE_SSIX\t= GF_4CC( 's', 's', 'i', 'x' ),\n\tGF_ISOM_BOX_TYPE_LEVA   = GF_4CC( 'l', 'e', 'v', 'a' ),\n\tGF_ISOM_BOX_TYPE_PCRB\t= GF_4CC( 'p', 'c', 'r', 'b' ),\n\tGF_ISOM_BOX_TYPE_EMSG\t= GF_4CC( 'e', 'm', 's', 'g' ),\n\n\t/*3GPP text / MPEG-4 StreamingText*/\n\tGF_ISOM_BOX_TYPE_FTAB\t= GF_4CC( 'f', 't', 'a', 'b' ),\n\tGF_ISOM_BOX_TYPE_TX3G\t= GF_4CC( 't', 'x', '3', 'g' ),\n\tGF_ISOM_BOX_TYPE_STYL\t= GF_4CC( 's', 't', 'y', 'l' ),\n\tGF_ISOM_BOX_TYPE_HLIT\t= GF_4CC( 'h', 'l', 'i', 't' ),\n\tGF_ISOM_BOX_TYPE_HCLR\t= GF_4CC( 'h', 'c', 'l', 'r' ),\n\tGF_ISOM_BOX_TYPE_KROK\t= GF_4CC( 'k', 'r', 'o', 'k' ),\n\tGF_ISOM_BOX_TYPE_DLAY\t= GF_4CC( 'd', 'l', 'a', 'y' ),\n\tGF_ISOM_BOX_TYPE_HREF\t= GF_4CC( 'h', 'r', 'e', 'f' ),\n\tGF_ISOM_BOX_TYPE_TBOX\t= GF_4CC( 't', 'b', 'o', 'x' ),\n\tGF_ISOM_BOX_TYPE_BLNK\t= GF_4CC( 'b', 'l', 'n', 'k' ),\n\tGF_ISOM_BOX_TYPE_TWRP\t= GF_4CC( 't', 'w', 'r', 'p' ),\n\n\t/* ISO Base Media File Format Extensions for MPEG-21 */\n\tGF_ISOM_BOX_TYPE_META\t= GF_4CC( 'm', 'e', 't', 'a' ),\n\tGF_ISOM_BOX_TYPE_XML\t= GF_4CC( 'x', 'm', 'l', ' ' ),\n\tGF_ISOM_BOX_TYPE_BXML\t= GF_4CC( 'b', 'x', 'm', 'l' ),\n\tGF_ISOM_BOX_TYPE_ILOC\t= GF_4CC( 'i', 'l', 'o', 'c' ),\n\tGF_ISOM_BOX_TYPE_PITM\t= GF_4CC( 'p', 'i', 't', 'm' ),\n\tGF_ISOM_BOX_TYPE_IPRO\t= GF_4CC( 'i', 'p', 'r', 'o' ),\n\tGF_ISOM_BOX_TYPE_INFE\t= GF_4CC( 'i', 'n', 'f', 'e' ),\n\tGF_ISOM_BOX_TYPE_IINF\t= GF_4CC( 'i', 'i', 'n', 'f' ),\n\tGF_ISOM_BOX_TYPE_IREF\t= GF_4CC( 'i', 'r', 'e', 'f' ),\n\tGF_ISOM_BOX_TYPE_ENCA\t= GF_4CC( 'e', 'n', 'c', 'a' ),\n\tGF_ISOM_BOX_TYPE_ENCV\t= GF_4CC( 'e', 'n', 'c', 'v' ),\n\tGF_ISOM_BOX_TYPE_RESV\t= GF_4CC( 'r', 'e', 's', 'v' ),\n\tGF_ISOM_BOX_TYPE_ENCT\t= GF_4CC( 'e', 'n', 'c', 't' ),\n\tGF_ISOM_BOX_TYPE_ENCS\t= GF_4CC( 'e', 'n', 'c', 's' ),\n\tGF_ISOM_BOX_TYPE_ENCF\t= GF_4CC( 'e', 'n', 'c', 'f' ),\n\tGF_ISOM_BOX_TYPE_ENCM\t= GF_4CC( 'e', 'n', 'c', 'm' ),\n\tGF_ISOM_BOX_TYPE_SINF\t= GF_4CC( 's', 'i', 'n', 'f' ),\n\tGF_ISOM_BOX_TYPE_RINF\t= GF_4CC( 'r', 'i', 'n', 'f' ),\n\tGF_ISOM_BOX_TYPE_FRMA\t= GF_4CC( 'f', 'r', 'm', 'a' ),\n\tGF_ISOM_BOX_TYPE_SCHM\t= GF_4CC( 's', 'c', 'h', 'm' ),\n\tGF_ISOM_BOX_TYPE_SCHI\t= GF_4CC( 's', 'c', 'h', 'i' ),\n\n\tGF_ISOM_BOX_TYPE_STVI\t= GF_4CC( 's', 't', 'v', 'i' ),\n\n\n\tGF_ISOM_BOX_TYPE_METX\t= GF_4CC( 'm', 'e', 't', 'x' ),\n\tGF_ISOM_BOX_TYPE_METT\t= GF_4CC( 'm', 'e', 't', 't' ),\n\n\t/* ISMA 1.0 Encryption and Authentication V 1.0 */\n\tGF_ISOM_BOX_TYPE_IKMS\t= GF_4CC( 'i', 'K', 'M', 'S' ),\n\tGF_ISOM_BOX_TYPE_ISFM\t= GF_4CC( 'i', 'S', 'F', 'M' ),\n\tGF_ISOM_BOX_TYPE_ISLT\t= GF_4CC( 'i', 'S', 'L', 'T' ),\n\n\t/* Hinting boxes */\n\tGF_ISOM_BOX_TYPE_RTP_STSD\t= GF_4CC( 'r', 't', 'p', ' ' ),\n\tGF_ISOM_BOX_TYPE_SRTP_STSD\t= GF_4CC( 's', 'r', 't', 'p' ),\n\tGF_ISOM_BOX_TYPE_FDP_STSD\t= GF_4CC( 'f', 'd', 'p', ' ' ),\n\tGF_ISOM_BOX_TYPE_RRTP_STSD\t= GF_4CC( 'r', 'r', 't', 'p' ),\n\tGF_ISOM_BOX_TYPE_RTCP_STSD\t= GF_4CC( 'r', 't', 'c', 'p' ),\n\tGF_ISOM_BOX_TYPE_HNTI\t= GF_4CC( 'h', 'n', 't', 'i' ),\n\tGF_ISOM_BOX_TYPE_RTP\t= GF_4CC( 'r', 't', 'p', ' ' ),\n\tGF_ISOM_BOX_TYPE_SDP\t= GF_4CC( 's', 'd', 'p', ' ' ),\n\tGF_ISOM_BOX_TYPE_HINF\t= GF_4CC( 'h', 'i', 'n', 'f' ),\n\tGF_ISOM_BOX_TYPE_NAME\t= GF_4CC( 'n', 'a', 'm', 'e' ),\n\tGF_ISOM_BOX_TYPE_TRPY\t= GF_4CC( 't', 'r', 'p', 'y' ),\n\tGF_ISOM_BOX_TYPE_NUMP\t= GF_4CC( 'n', 'u', 'm', 'p' ),\n\tGF_ISOM_BOX_TYPE_TOTL\t= GF_4CC( 't', 'o', 't', 'l' ),\n\tGF_ISOM_BOX_TYPE_NPCK\t= GF_4CC( 'n', 'p', 'c', 'k' ),\n\tGF_ISOM_BOX_TYPE_TPYL\t= GF_4CC( 't', 'p', 'y', 'l' ),\n\tGF_ISOM_BOX_TYPE_TPAY\t= GF_4CC( 't', 'p', 'a', 'y' ),\n\tGF_ISOM_BOX_TYPE_MAXR\t= GF_4CC( 'm', 'a', 'x', 'r' ),\n\tGF_ISOM_BOX_TYPE_DMED\t= GF_4CC( 'd', 'm', 'e', 'd' ),\n\tGF_ISOM_BOX_TYPE_DIMM\t= GF_4CC( 'd', 'i', 'm', 'm' ),\n\tGF_ISOM_BOX_TYPE_DREP\t= GF_4CC( 'd', 'r', 'e', 'p' ),\n\tGF_ISOM_BOX_TYPE_TMIN\t= GF_4CC( 't', 'm', 'i', 'n' ),\n\tGF_ISOM_BOX_TYPE_TMAX\t= GF_4CC( 't', 'm', 'a', 'x' ),\n\tGF_ISOM_BOX_TYPE_PMAX\t= GF_4CC( 'p', 'm', 'a', 'x' ),\n\tGF_ISOM_BOX_TYPE_DMAX\t= GF_4CC( 'd', 'm', 'a', 'x' ),\n\tGF_ISOM_BOX_TYPE_PAYT\t= GF_4CC( 'p', 'a', 'y', 't' ),\n\tGF_ISOM_BOX_TYPE_RELY\t= GF_4CC( 'r', 'e', 'l', 'y' ),\n\tGF_ISOM_BOX_TYPE_TIMS\t= GF_4CC( 't', 'i', 'm', 's' ),\n\tGF_ISOM_BOX_TYPE_TSRO\t= GF_4CC( 't', 's', 'r', 'o' ),\n\tGF_ISOM_BOX_TYPE_SNRO\t= GF_4CC( 's', 'n', 'r', 'o' ),\n\tGF_ISOM_BOX_TYPE_RTPO\t= GF_4CC( 'r', 't', 'p', 'o' ),\n\tGF_ISOM_BOX_TYPE_TSSY\t= GF_4CC( 't', 's', 's', 'y' ),\n\tGF_ISOM_BOX_TYPE_RSSR\t= GF_4CC( 'r', 's', 's', 'r' ),\n\tGF_ISOM_BOX_TYPE_SRPP\t= GF_4CC( 's', 'r', 'p', 'p' ),\n\n\t//FEC boxes\n\tGF_ISOM_BOX_TYPE_FIIN\t= GF_4CC( 'f', 'i', 'i', 'n' ),\n\tGF_ISOM_BOX_TYPE_PAEN\t= GF_4CC( 'p', 'a', 'e', 'n' ),\n\tGF_ISOM_BOX_TYPE_FPAR\t= GF_4CC( 'f', 'p', 'a', 'r' ),\n\tGF_ISOM_BOX_TYPE_FECR\t= GF_4CC( 'f', 'e', 'c', 'r' ),\n\tGF_ISOM_BOX_TYPE_SEGR\t= GF_4CC( 's', 'e', 'g', 'r' ),\n\tGF_ISOM_BOX_TYPE_GITN\t= GF_4CC( 'g', 'i', 't', 'n' ),\n\tGF_ISOM_BOX_TYPE_FIRE\t= GF_4CC( 'f', 'i', 'r', 'e' ),\n\tGF_ISOM_BOX_TYPE_FDSA\t= GF_4CC( 'f', 'd', 's', 'a' ),\n\tGF_ISOM_BOX_TYPE_FDPA\t= GF_4CC( 'f', 'd', 'p', 'a' ),\n\tGF_ISOM_BOX_TYPE_EXTR\t= GF_4CC( 'e', 'x', 't', 'r' ),\n\n\t/*internal type for track and item references*/\n\tGF_ISOM_BOX_TYPE_REFT\t= GF_4CC( 'R', 'E', 'F', 'T' ),\n\tGF_ISOM_BOX_TYPE_REFI\t= GF_4CC( 'R', 'E', 'F', 'I'),\n\tGF_ISOM_BOX_TYPE_GRPT\t= GF_4CC( 'G', 'R', 'P', 'T'),\n\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n\t/* Adobe extensions */\n\tGF_ISOM_BOX_TYPE_ABST\t= GF_4CC( 'a', 'b', 's', 't' ),\n\tGF_ISOM_BOX_TYPE_AFRA\t= GF_4CC( 'a', 'f', 'r', 'a' ),\n\tGF_ISOM_BOX_TYPE_ASRT\t= GF_4CC( 'a', 's', 'r', 't' ),\n\tGF_ISOM_BOX_TYPE_AFRT\t= GF_4CC( 'a', 'f', 'r', 't' ),\n#endif\n\n\t/* Apple extensions */\n\n\tGF_ISOM_BOX_TYPE_ILST\t= GF_4CC( 'i', 'l', 's', 't' ),\n\tGF_ISOM_BOX_TYPE_iTunesSpecificInfo\t= GF_4CC( '-', '-', '-', '-' ),\n\tGF_ISOM_BOX_TYPE_DATA\t= GF_4CC( 'd', 'a', 't', 'a' ),\n\n\tGF_ISOM_HANDLER_TYPE_MDIR\t= GF_4CC( 'm', 'd', 'i', 'r' ),\n\tGF_ISOM_BOX_TYPE_CHAP\t= GF_4CC( 'c', 'h', 'a', 'p' ),\n\tGF_ISOM_BOX_TYPE_TEXT\t= GF_4CC( 't', 'e', 'x', 't' ),\n\n\t/*OMA (P)DCF boxes*/\n\tGF_ISOM_BOX_TYPE_OHDR\t= GF_4CC( 'o', 'h', 'd', 'r' ),\n\tGF_ISOM_BOX_TYPE_GRPI\t= GF_4CC( 'g', 'r', 'p', 'i' ),\n\tGF_ISOM_BOX_TYPE_MDRI\t= GF_4CC( 'm', 'd', 'r', 'i' ),\n\tGF_ISOM_BOX_TYPE_ODTT\t= GF_4CC( 'o', 'd', 't', 't' ),\n\tGF_ISOM_BOX_TYPE_ODRB\t= GF_4CC( 'o', 'd', 'r', 'b' ),\n\tGF_ISOM_BOX_TYPE_ODKM\t= GF_4CC( 'o', 'd', 'k', 'm' ),\n\tGF_ISOM_BOX_TYPE_ODAF\t= GF_4CC( 'o', 'd', 'a', 'f' ),\n\n\t/*3GPP DIMS */\n\tGF_ISOM_BOX_TYPE_DIMS\t= GF_4CC( 'd', 'i', 'm', 's' ),\n\tGF_ISOM_BOX_TYPE_DIMC\t= GF_4CC( 'd', 'i', 'm', 'C' ),\n\tGF_ISOM_BOX_TYPE_DIST\t= GF_4CC( 'd', 'i', 'S', 'T' ),\n\n\n\tGF_ISOM_BOX_TYPE_AC3\t= GF_4CC( 'a', 'c', '-', '3' ),\n\tGF_ISOM_BOX_TYPE_DAC3\t= GF_4CC( 'd', 'a', 'c', '3' ),\n\tGF_ISOM_BOX_TYPE_EC3\t= GF_4CC( 'e', 'c', '-', '3' ),\n\tGF_ISOM_BOX_TYPE_DEC3\t= GF_4CC( 'd', 'e', 'c', '3' ),\n\tGF_ISOM_BOX_TYPE_DVCC\t= GF_4CC( 'd', 'v', 'c', 'C' ),\n\tGF_ISOM_BOX_TYPE_DVHE\t= GF_4CC( 'd', 'v', 'h', 'e' ),\n\tGF_ISOM_BOX_TYPE_MLPA\t= GF_4CC( 'm', 'l', 'p', 'a' ),\n\tGF_ISOM_BOX_TYPE_DMLP\t= GF_4CC( 'd', 'm', 'l', 'p' ),\n\n\tGF_ISOM_BOX_TYPE_SUBS\t= GF_4CC( 's', 'u', 'b', 's' ),\n\n\tGF_ISOM_BOX_TYPE_RVCC\t= GF_4CC( 'r', 'v', 'c', 'c' ),\n\n\tGF_ISOM_BOX_TYPE_VTTC_CONFIG\t= GF_4CC( 'v', 't', 't', 'C' ),\n\tGF_ISOM_BOX_TYPE_VTCC_CUE\t= GF_4CC( 'v', 't', 't', 'c' ),\n\tGF_ISOM_BOX_TYPE_VTTE\t= GF_4CC( 'v', 't', 't', 'e' ),\n\tGF_ISOM_BOX_TYPE_VTTA\t= GF_4CC( 'v', 't', 't', 'a' ),\n\tGF_ISOM_BOX_TYPE_CTIM\t= GF_4CC( 'c', 't', 'i', 'm' ),\n\tGF_ISOM_BOX_TYPE_IDEN\t= GF_4CC( 'i', 'd', 'e', 'n' ),\n\tGF_ISOM_BOX_TYPE_STTG\t= GF_4CC( 's', 't', 't', 'g' ),\n\tGF_ISOM_BOX_TYPE_PAYL\t= GF_4CC( 'p', 'a', 'y', 'l' ),\n\tGF_ISOM_BOX_TYPE_WVTT\t= GF_4CC( 'w', 'v', 't', 't' ),\n\n\tGF_ISOM_BOX_TYPE_STPP\t= GF_4CC( 's', 't', 'p', 'p' ),\n\tGF_ISOM_BOX_TYPE_SBTT\t= GF_4CC( 's', 'b', 't', 't' ),\n\n\tGF_ISOM_BOX_TYPE_STXT\t= GF_4CC( 's', 't', 'x', 't' ),\n\tGF_ISOM_BOX_TYPE_TXTC\t= GF_4CC( 't', 'x', 't', 'C' ),\n\tGF_ISOM_BOX_TYPE_MIME\t= GF_4CC( 'm', 'i', 'm', 'e' ),\n\n\tGF_ISOM_BOX_TYPE_PRFT   = GF_4CC( 'p', 'r', 'f', 't' ),\n\n\t/* Image File Format Boxes */\n\tGF_ISOM_BOX_TYPE_ISPE   = GF_4CC( 'i', 's', 'p', 'e' ),\n\tGF_ISOM_BOX_TYPE_COLR   = GF_4CC( 'c', 'o', 'l', 'r' ),\n\tGF_ISOM_BOX_TYPE_PIXI   = GF_4CC( 'p', 'i', 'x', 'i' ),\n\tGF_ISOM_BOX_TYPE_RLOC   = GF_4CC( 'r', 'l', 'o', 'c' ),\n\tGF_ISOM_BOX_TYPE_IROT   = GF_4CC( 'i', 'r', 'o', 't' ),\n\tGF_ISOM_BOX_TYPE_IMIR   = GF_4CC( 'i', 'm', 'i', 'r' ),\n\tGF_ISOM_BOX_TYPE_IPCO   = GF_4CC( 'i', 'p', 'c', 'o' ),\n\tGF_ISOM_BOX_TYPE_IPRP   = GF_4CC( 'i', 'p', 'r', 'p' ),\n\tGF_ISOM_BOX_TYPE_IPMA   = GF_4CC( 'i', 'p', 'm', 'a' ),\n\tGF_ISOM_BOX_TYPE_GRPL   = GF_4CC( 'g', 'r', 'p', 'l'),\n\tGF_ISOM_BOX_TYPE_CCST\t= GF_4CC( 'c', 'c', 's', 't' ),\n\tGF_ISOM_BOX_TYPE_AUXC\t= GF_4CC( 'a', 'u', 'x', 'C' ),\n\tGF_ISOM_BOX_TYPE_AUXI\t= GF_4CC( 'a', 'u', 'x', 'i' ),\n\tGF_ISOM_BOX_TYPE_OINF\t= GF_4CC( 'o', 'i', 'n', 'f' ),\n\tGF_ISOM_BOX_TYPE_TOLS\t= GF_4CC( 't', 'o', 'l', 's' ),\n\tGF_ISOM_BOX_TYPE_IENC\t= GF_4CC( 'i', 'e', 'n', 'c' ),\n\tGF_ISOM_BOX_TYPE_IAUX \t= GF_4CC('i', 'a', 'u', 'x'),\n\n\t/* MIAF Boxes */\n\tGF_ISOM_BOX_TYPE_CLLI\t= GF_4CC('c', 'l', 'l', 'i'),\n\tGF_ISOM_BOX_TYPE_MDCV\t= GF_4CC('m', 'd', 'c', 'v'),\n\n\tGF_ISOM_BOX_TYPE_ALTR\t= GF_4CC( 'a', 'l', 't', 'r' ),\n\n\t/*ALL INTERNAL BOXES - NEVER WRITTEN TO FILE!!*/\n\n\t/*generic handlers*/\n\tGF_ISOM_BOX_TYPE_GNRM\t= GF_4CC( 'G', 'N', 'R', 'M' ),\n\tGF_ISOM_BOX_TYPE_GNRV\t= GF_4CC( 'G', 'N', 'R', 'V' ),\n\tGF_ISOM_BOX_TYPE_GNRA\t= GF_4CC( 'G', 'N', 'R', 'A' ),\n\t/*base constructor of all hint formats (currently only RTP uses it)*/\n\tGF_ISOM_BOX_TYPE_GHNT\t= GF_4CC( 'g', 'h', 'n', 't' ),\n\t/*for compatibility with old files hinted for DSS - needs special parsing*/\n\tGF_ISOM_BOX_TYPE_VOID\t= GF_4CC( 'V', 'O', 'I', 'D' ),\n\n\t/*MS Smooth - these are actually UUID boxes*/\n\tGF_ISOM_BOX_UUID_PSSH\t= GF_4CC( 'P', 'S', 'S', 'H' ),\n\tGF_ISOM_BOX_UUID_MSSM   = GF_4CC( 'M', 'S', 'S', 'M' ), /*Stream Manifest box*/\n\tGF_ISOM_BOX_UUID_TENC\t= GF_4CC( 'T', 'E', 'N', 'C' ),\n\tGF_ISOM_BOX_UUID_TFRF\t= GF_4CC( 'T', 'F', 'R', 'F' ),\n\tGF_ISOM_BOX_UUID_TFXD\t= GF_4CC( 'T', 'F', 'X', 'D' ),\n\n\tGF_ISOM_BOX_TYPE_MP3\t= GF_4CC( '.', 'm', 'p', '3' ),\n\n\tGF_ISOM_BOX_TYPE_TRIK\t= GF_4CC( 't', 'r', 'i', 'k' ),\n\tGF_ISOM_BOX_TYPE_BLOC\t= GF_4CC( 'b', 'l', 'o', 'c' ),\n\tGF_ISOM_BOX_TYPE_AINF\t= GF_4CC( 'a', 'i', 'n', 'f' ),\n\n\t/*JPEG2000*/\n\tGF_ISOM_BOX_TYPE_MJP2\t= GF_4CC('m','j','p','2'),\n\tGF_ISOM_BOX_TYPE_IHDR\t= GF_4CC('i','h','d','r'),\n\tGF_ISOM_BOX_TYPE_JP  \t= GF_4CC('j','P',' ',' '),\n\tGF_ISOM_BOX_TYPE_JP2H\t= GF_4CC('j','p','2','h'),\n\tGF_ISOM_BOX_TYPE_JP2K\t= GF_4CC('j','p','2','k'),\n\n\tGF_ISOM_BOX_TYPE_JPEG\t= GF_4CC('j','p','e','g'),\n\tGF_ISOM_BOX_TYPE_PNG \t= GF_4CC('p','n','g',' '),\n\n\t/* apple QT box */\n\tGF_QT_BOX_TYPE_ALIS = GF_4CC('a','l','i','s'),\n\tGF_QT_BOX_TYPE_LOAD = GF_4CC('l','o','a','d'),\n\tGF_QT_BOX_TYPE_WIDE = GF_4CC('w','i','d','e'),\n\tGF_QT_BOX_TYPE_GMIN\t= GF_4CC( 'g', 'm', 'i', 'n' ),\n\tGF_QT_BOX_TYPE_TAPT\t= GF_4CC( 't', 'a', 'p', 't' ),\n\tGF_QT_BOX_TYPE_CLEF\t= GF_4CC( 'c', 'l', 'e', 'f' ),\n\tGF_QT_BOX_TYPE_PROF\t= GF_4CC( 'p', 'r', 'o', 'f' ),\n\tGF_QT_BOX_TYPE_ENOF\t= GF_4CC( 'e', 'n', 'o', 'f' ),\n\tGF_QT_BOX_TYPE_WAVE = GF_4CC('w','a','v','e'),\n\tGF_QT_BOX_TYPE_CHAN = GF_4CC('c','h','a','n'),\n\tGF_QT_BOX_TYPE_TERMINATOR \t= 0,\n\tGF_QT_BOX_TYPE_ENDA = GF_4CC('e','n','d','a'),\n\tGF_QT_BOX_TYPE_FRMA = GF_4CC('f','r','m','a'),\n\tGF_QT_BOX_TYPE_TMCD = GF_4CC('t','m','c','d'),\n\tGF_QT_BOX_TYPE_NAME = GF_4CC('n','a','m','e'),\n\tGF_QT_BOX_TYPE_TCMI = GF_4CC('t','c','m','i'),\n\tGF_QT_BOX_TYPE_FIEL = GF_4CC('f','i','e','l'),\n\tGF_QT_BOX_TYPE_GAMA = GF_4CC('g','a','m','a'),\n\tGF_QT_BOX_TYPE_CHRM = GF_4CC('c','h','r','m'),\n\n\t/* from drm_sample.c */\n\tGF_ISOM_BOX_TYPE_264B \t= GF_4CC('2','6','4','b'),\n\tGF_ISOM_BOX_TYPE_265B \t= GF_4CC('2','6','5','b'),\n\n\t/*MPEG-H 3D audio*/\n\tGF_ISOM_BOX_TYPE_MHA1 \t= GF_4CC('m','h','a','1'),\n\tGF_ISOM_BOX_TYPE_MHA2 \t= GF_4CC('m','h','a','2'),\n\tGF_ISOM_BOX_TYPE_MHM1 \t= GF_4CC('m','h','m','1'),\n\tGF_ISOM_BOX_TYPE_MHM2 \t= GF_4CC('m','h','m','2'),\n\tGF_ISOM_BOX_TYPE_MHAC \t= GF_4CC('m','h','a','C'),\n\tGF_ISOM_BOX_TYPE_MHAP \t= GF_4CC('m','h','a','P'),\n\n\tGF_ISOM_BOX_TYPE_IPCM \t= GF_4CC('i','p','c','m'),\n\tGF_ISOM_BOX_TYPE_FPCM \t= GF_4CC('f','p','c','m'),\n\tGF_ISOM_BOX_TYPE_PCMC \t= GF_4CC('p','c','m','C'),\n\n\tGF_ISOM_BOX_TYPE_CHNL \t= GF_4CC('c','h','n','l'),\n\n\tGF_ISOM_BOX_TYPE_AUXV \t= GF_4CC('A','U','X','V'),\n\n\tGF_ISOM_BOX_TYPE_FLAC\t= GF_4CC( 'f', 'L', 'a', 'C' ),\n\tGF_ISOM_BOX_TYPE_DFLA\t= GF_4CC( 'd', 'f', 'L', 'a' ),\n\n\t//internal only\n\tGF_QT_SUBTYPE_RAW_AUD \t= GF_4CC('Q','T','R','A'),\n\tGF_QT_SUBTYPE_RAW_VID \t= GF_4CC('Q','T','R','V'),\n\n\tGF_ISOM_BOX_TYPE_XTRA\t= GF_4CC( 'X', 't', 'r', 'a' ),\n\n\tGF_ISOM_BOX_TYPE_ST3D\t= GF_4CC( 's', 't', '3', 'd' ),\n\tGF_ISOM_BOX_TYPE_SV3D\t= GF_4CC( 's', 'v', '3', 'd' ),\n\tGF_ISOM_BOX_TYPE_SVHD\t= GF_4CC( 's', 'v', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_PROJ\t= GF_4CC( 'p', 'r', 'o', 'j' ),\n\tGF_ISOM_BOX_TYPE_PRHD\t= GF_4CC( 'p', 'r', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_CBMP\t= GF_4CC( 'c', 'b', 'm', 'p' ),\n\tGF_ISOM_BOX_TYPE_EQUI\t= GF_4CC( 'e', 'q', 'u', 'i' ),\n\tGF_ISOM_BOX_TYPE_MSHP\t= GF_4CC( 'm', 's', 'h', 'p' ),\n\tGF_ISOM_BOX_TYPE_MESH\t= GF_4CC( 'm', 'e', 's', 'h' ),\n};\n\nenum\n{\n\tGF_ISOM_SAMPLE_ENTRY_UNKN = 0,\n\tGF_ISOM_SAMPLE_ENTRY_VIDEO = GF_4CC('v','i','d','e'),\n\tGF_ISOM_SAMPLE_ENTRY_AUDIO = GF_4CC('a','u','d','i'),\n\tGF_ISOM_SAMPLE_ENTRY_MP4S = GF_4CC('m','p','4','s')\n\n};\n\n\n/* bitstream cookies used by isobmff lib*/\n#define GF_ISOM_BS_COOKIE_NO_LOGS\t\t1\n#define GF_ISOM_BS_COOKIE_VISUAL_TRACK\t(1<<1)\n#define GF_ISOM_BS_COOKIE_QT_CONV\t\t(1<<2)\n#define GF_ISOM_BS_COOKIE_CLONE_TRACK\t(1<<3)\n\n\n#ifndef GPAC_DISABLE_ISOM\n\n\n#if defined(GPAC_DISABLE_ISOM_FRAGMENTS) && !defined(GPAC_DISABLE_ISOM_ADOBE)\n#define GPAC_DISABLE_ISOM_ADOBE\n#endif\n\n//internal flags (up to 16)\n//if flag is set, position checking of child boxes is ignored\n#define GF_ISOM_ORDER_FREEZE 1\n#define GF_ISOM_BOX_COMPRESSED 2\n\n\t/*the default size is 64, cause we need to handle large boxes...\n\n\tthe child_boxes container is by default NOT created. When parsing a box and sub-boxes are detected, the list is created.\n\tThis list is destroyed before calling the final box destructor\n\tThis list is automatically taken into account during size() and write() functions, and\n\tgf_isom_box_write shall not be called in XXXX_box_write on any box registered with the child list\n\n\tthe full box version field is moved in the base box since we also need some internal flags, as u16 to\n\talso be used for audio and video sample entries version field\n\t*/\n#define GF_ISOM_BOX\t\t\t\\\n\tu32 type;\t\t\t\t\\\n\tu64 size;\t\t\t\t\\\n\tconst struct box_registry_entry *registry;\\\n\tGF_List *child_boxes; \t\\\n\tu16 internal_flags;\t\t\\\n\tu16 version;\t\t\t\t\\\n\n#define GF_ISOM_FULL_BOX\t\t\\\n\tGF_ISOM_BOX\t\t\t\\\n\tu32 flags;\t\t\t\\\n\n#define GF_ISOM_UUID_BOX\t\\\n\tGF_ISOM_BOX\t\t\t\\\n\tu8 uuid[16];\t\t\\\n\tu32 internal_4cc;\t\t\\\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n} GF_Box;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n} GF_FullBox;\n\ntypedef struct\n{\n\tGF_ISOM_UUID_BOX\n} GF_UUIDBox;\n\n\n#define ISOM_DECL_BOX_ALLOC(__TYPE, __4cc)\t__TYPE *tmp; \\\n\tGF_SAFEALLOC(tmp, __TYPE);\t\\\n\tif (tmp==NULL) return NULL;\t\\\n\ttmp->type = __4cc;\n\n#define ISOM_DECREASE_SIZE(__ptr, bytes)\tif (__ptr->size < (bytes) ) {\\\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isom] not enough bytes in box %s: %d left, reading %d (file %s, line %d)\\n\", gf_4cc_to_str(__ptr->type), (u32) __ptr->size, (bytes), __FILE__, __LINE__ )); \\\n\t\t\treturn GF_ISOM_INVALID_FILE; \\\n\t\t}\\\n\t\t__ptr->size -= bytes; \\\n\n\n#define ISOM_DECREASE_SIZE_NO_ERR(__ptr, bytes)\tif (__ptr->size < (bytes) ) {\\\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isom] not enough bytes in box %s: %d left, reading %d (file %s, line %d), skipping box\\n\", gf_4cc_to_str(__ptr->type), (u32) __ptr->size, (bytes), __FILE__, __LINE__ )); \\\n\t\t\treturn GF_OK; \\\n\t\t}\\\n\t\t__ptr->size -= bytes; \\\n\n\n/*constructor*/\nGF_Box *gf_isom_box_new(u32 boxType);\n//some boxes may have different syntax based on container. Use this constructor for this case\nGF_Box *gf_isom_box_new_ex(u32 boxType, u32 parentType, Bool skip_logs, Bool is_root_box);\n\nGF_Err gf_isom_box_write(GF_Box *ptr, GF_BitStream *bs);\nGF_Err gf_isom_box_read(GF_Box *ptr, GF_BitStream *bs);\nvoid gf_isom_box_del(GF_Box *ptr);\nGF_Err gf_isom_box_size(GF_Box *ptr);\n\nGF_Err gf_isom_clone_box(GF_Box *src, GF_Box **dst);\n\nGF_Err gf_isom_box_parse(GF_Box **outBox, GF_BitStream *bs);\nGF_Err gf_isom_box_array_read(GF_Box *s, GF_BitStream *bs);\nGF_Err gf_isom_box_array_read_ex(GF_Box *parent, GF_BitStream *bs, u32 parent_type);\n\nGF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type, Bool is_root_box);\n\n//writes box header - shall be called at the beginning of each xxxx_Write function\n//this function is not factorized in order to let box serializer modify box type before writing\nGF_Err gf_isom_box_write_header(GF_Box *ptr, GF_BitStream *bs);\n\n//writes box header then version+flags\nGF_Err gf_isom_full_box_write(GF_Box *s, GF_BitStream *bs);\n\nvoid gf_isom_box_array_reset(GF_List *boxlist);\nvoid gf_isom_box_array_del(GF_List *child_boxes);\nGF_Err gf_isom_box_array_write(GF_Box *parent, GF_List *list, GF_BitStream *bs);\nGF_Err gf_isom_box_array_size(GF_Box *parent, GF_List *list);\n\nvoid gf_isom_check_position(GF_Box *s, GF_Box *child, u32 *pos);\nvoid gf_isom_check_position_list(GF_Box *s, GF_List *childlist, u32 *pos);\n\nBool gf_box_valid_in_parent(GF_Box *a, const char *parent_4cc);\n\nvoid gf_isom_box_array_del_parent(GF_List **child_boxes, GF_List *boxlist);\nvoid gf_isom_box_array_reset_parent(GF_List **child_boxes, GF_List *boxlist);\n\nvoid gf_isom_box_freeze_order(GF_Box *box);\n\n#define BOX_FIELD_ASSIGN(_field, _box_cast) \\\n\tif (is_rem) {\\\n\t\tptr->_field = NULL;\\\n\t\treturn GF_OK;\\\n\t} else {\\\n\t\tif (ptr->_field) ERROR_ON_DUPLICATED_BOX(a, ptr)\\\n\t\tptr->_field = (_box_cast *)a;\\\n\t}\n\n#define BOX_FIELD_LIST_ASSIGN(_field) \\\n\tif (is_rem) {\\\n\t\tgf_list_del_item(ptr->_field, a);\\\n\t} else {\\\n\t\tif (!ptr->_field) ptr->_field = gf_list_new();\\\n\t\tGF_Err _e = gf_list_add(ptr->_field, a);\\\n\t\tif (_e) return _e;\\\n\t}\n\n\nvoid gf_isom_box_remove_from_parent(GF_Box *parent_box, GF_Box *box);\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\t/*note: the data is NEVER loaded to the mdat in this lib*/\n\tu64 dataSize;\n\t/* store the file offset when parsing to access the raw data */\n\tu64 bsOffset;\n\tu8 *data;\n} GF_MediaDataBox;\n\ntypedef struct\n{\n  u64 time;\n  u64 moof_offset;\n  u32 traf_number;\n  u32 trun_number;\n  u32 sample_number;\n} GF_RandomAccessEntry;\n\ntypedef struct\n{\n  GF_ISOM_FULL_BOX\n  GF_ISOTrackID track_id;\n  u8 traf_bits;\n  u8 trun_bits;\n  u8 sample_bits;\n  u32 nb_entries;\n  GF_RandomAccessEntry *entries;\n} GF_TrackFragmentRandomAccessBox;\n\ntypedef struct\n{\n  GF_ISOM_FULL_BOX\n\tu32 container_size;\n} GF_MovieFragmentRandomAccessOffsetBox;\n\ntypedef struct\n{\n  GF_ISOM_BOX\n  GF_List* tfra_list;\n  GF_MovieFragmentRandomAccessOffsetBox *mfro;\n} GF_MovieFragmentRandomAccessBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu8 *data;\n\tu32 dataSize;\n\tu32 original_4cc;\n} GF_UnknownBox;\n\ntypedef struct\n{\n\tGF_ISOM_UUID_BOX\n\tu8 *data;\n\tu32 dataSize;\n} GF_UnknownUUIDBox;\n\nu32 gf_isom_solve_uuid_box(u8 *UUID);\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu64 creationTime;\n\tu64 modificationTime;\n\tu32 timeScale;\n\tu64 duration;\n\tu64 original_duration;\n\tGF_ISOTrackID nextTrackID;\n\tu32 preferredRate;\n\tu16 preferredVolume;\n\tchar reserved[10];\n\tu32 matrixA;\n\tu32 matrixB;\n\tu32 matrixU;\n\tu32 matrixC;\n\tu32 matrixD;\n\tu32 matrixV;\n\tu32 matrixW;\n\tu32 matrixX;\n\tu32 matrixY;\n\tu32 previewTime;\n\tu32 previewDuration;\n\tu32 posterTime;\n\tu32 selectionTime;\n\tu32 selectionDuration;\n\tu32 currentTime;\n} GF_MovieHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_Descriptor *descriptor;\n} GF_ObjectDescriptorBox;\n\n/*used for entry list*/\ntypedef struct\n{\n\tu64 segmentDuration;\n\ts64 mediaTime;\n\tu32 mediaRate;\n\tBool was_empty_dur;\n} GF_EdtsEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *entryList;\n} GF_EditListBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_EditListBox *editList;\n} GF_EditBox;\n\n\n/*used to classify boxes in the UserData GF_Box*/\ntypedef struct\n{\n\tu32 boxType;\n\tu8 uuid[16];\n\tGF_List *boxes;\n} GF_UserDataMap;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_List *recordList;\n} GF_UserDataBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_MovieHeaderBox *mvhd;\n\tGF_ObjectDescriptorBox *iods;\n\tGF_UserDataBox *udta;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tstruct __tag_mvex_box *mvex;\n#endif\n\t/*meta box if any*/\n\tstruct __tag_meta_box *meta;\n\t/*track boxes*/\n\tGF_List *trackList;\n\n\tGF_ISOFile *mov;\n\n\tBool mvex_after_traks;\n\t//for compressed mov, stores the difference between compressed and uncompressed payload\n\ts32 compressed_diff;\n\t//for compressed mov, indicates the file offset of the moov box start\n\tu64 file_offset;\n\n} GF_MovieBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu64 creationTime;\n\tu64 modificationTime;\n\tGF_ISOTrackID trackID;\n\tu32 reserved1;\n\tu64 duration;\n\tu32 reserved2[2];\n\tu16 layer;\n\tu16 alternate_group;\n\tu16 volume;\n\tu16 reserved3;\n\ts32 matrix[9];\n\tu32 width, height;\n\tu64 initial_duration;\n} GF_TrackHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n} GF_TrackReferenceBox;\n\n\ntypedef struct {\n\tGF_ISOM_BOX\n\tGF_List *groups;\n} GF_TrackGroupBox;\n\ntypedef struct {\n\tGF_ISOM_FULL_BOX\n\tu32 group_type;\n\tu32 track_group_id;\n} GF_TrackGroupTypeBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_UserDataBox *udta;\n\tGF_TrackHeaderBox *Header;\n\tstruct __tag_media_box *Media;\n\tGF_EditBox *editBox;\n\tGF_TrackReferenceBox *References;\n\t/*meta box if any*/\n\tstruct __tag_meta_box *meta;\n\tGF_TrackGroupBox *groups;\n\n\tGF_Box *Aperture;\n\t\n\tGF_MovieBox *moov;\n\t/*private for media padding*/\n\tu32 padding_bytes;\n\t/*private for editing*/\n\tBool is_unpacked;\n\t/*private for checking dependency*/\n\tu32 originalFile;\n\tu32 originalID;\n\n\t//not sure about piff (not supposed to be stored in moov), but senc is in track according to CENC\n\tstruct __sample_encryption_box *sample_encryption;\n\n\t/*private for SVC/MVC extractors resolution*/\n\tGF_ISONaluExtractMode extractor_mode;\n\tBool has_base_layer;\n\tu32 pack_num_samples;\n\n\tu64 magic;\n\tu32 index;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tu64 first_dts_chunk;\n\tu32 nb_samples_in_cache;\n\tu32 chunk_stsd_idx;\n\tu32 chunk_cache_size;\n\tGF_BitStream *chunk_cache;\n#endif\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tu64 dts_at_seg_start;\n\tu32 sample_count_at_seg_start;\n\tBool first_traf_merged;\n\tBool present_in_scalable_segment;\n\tu32 current_traf_stsd_idx;\n\n\tu64 last_tfxd_value;\n\tstruct __traf_mss_timeref_box *tfrf;\n\tu64 dts_at_next_seg_start;\n#endif\n} GF_TrackBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu64 creationTime;\n\tu64 modificationTime;\n\tu32 timeScale;\n\tu64 duration, original_duration;\n\tchar packedLanguage[4];\n\tu16 reserved;\n} GF_MediaHeaderBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 reserved1;\n\tu32 handlerType;\n\tu8 reserved2[12];\n\tchar *nameUTF8;\n\tBool store_counted_string;\n} GF_HandlerBox;\n\ntypedef struct __tag_media_box\n{\n\tGF_ISOM_BOX\n\tGF_TrackBox *mediaTrack;\n\tGF_MediaHeaderBox *mediaHeader;\n\tGF_HandlerBox *handler;\n\tstruct __tag_media_info_box *information;\n\tu64 BytesMissing;\n\n\t//all the following are only used for NALU-based tracks\n\t//NALU reader\n\tGF_BitStream *nalu_parser;\n\n\tGF_BitStream *nalu_out_bs;\n\tGF_BitStream *nalu_ps_bs;\n\tu8 *in_sample_buffer;\n\tu32 in_sample_buffer_alloc;\n\tu8 *tmp_nal_copy_buffer;\n\tu32 tmp_nal_copy_buffer_alloc;\n\n\tGF_ISOSample *extracted_samp;\n\tGF_BitStream *extracted_bs;\n\n} GF_MediaBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tchar *extended_language;\n} GF_ExtendedLanguageBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu64 reserved;\n} GF_VideoMediaHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\n\tu16 graphics_mode;\n\tu16 op_color_red;\n\tu16 op_color_green;\n\tu16 op_color_blue;\n\tu16 balance;\n\tu16 reserved;\n} GF_GenericMediaHeaderInfoBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu16 balance;\n\tu16 reserved;\n} GF_SoundMediaHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\t/*this is used for us INTERNALLY*/\n\tu32 subType;\n\tu32 maxPDUSize;\n\tu32 avgPDUSize;\n\tu32 maxBitrate;\n\tu32 avgBitrate;\n\tu32 slidingAverageBitrate;\n} GF_HintMediaHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n} GF_MPEGMediaHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n} GF_SubtitleMediaHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n} GF_ODMediaHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n} GF_OCRMediaHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n} GF_SceneMediaHeaderBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\n\tu32 width;\n\tu32 height;\n} GF_ApertureBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n} GF_DataReferenceBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_DataReferenceBox *dref;\n} GF_DataInformationBox;\n\n#define GF_ISOM_DATAENTRY_FIELDS\t\\\n\tchar *location;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_ISOM_DATAENTRY_FIELDS\n} GF_DataEntryBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_ISOM_DATAENTRY_FIELDS\n} GF_DataEntryURLBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_ISOM_DATAENTRY_FIELDS\n} GF_DataEntryAliasBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_ISOM_DATAENTRY_FIELDS\n\tchar *nameURN;\n} GF_DataEntryURNBox;\n\ntypedef struct\n{\n\tu32 sampleCount;\n\tu32 sampleDelta;\n} GF_SttsEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_SttsEntry *entries;\n\tu32 nb_entries, alloc_size;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t/*cache for WRITE*/\n\tu32 w_currentSampleNum;\n\tu64 w_LastDTS;\n#endif\n\t/*cache for READ*/\n\tu32 r_FirstSampleInEntry;\n\tu32 r_currentEntryIndex;\n\tu64 r_CurrentDTS;\n\n\t//stats for read\n\tu32 max_ts_delta;\n} GF_TimeToSampleBox;\n\n\n/*TO CHECK - it could be reasonnable to only use 16bits for both count and offset*/\ntypedef struct\n{\n\tu32 sampleCount;\n\ts32 decodingOffset;\n} GF_DttsEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_DttsEntry *entries;\n\tu32 nb_entries, alloc_size;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tu32 w_LastSampleNumber;\n\t/*force one sample per entry*/\n\tBool unpack_mode;\n#endif\n\t/*Cache for read*/\n\tu32 r_currentEntryIndex;\n\tu32 r_FirstSampleInEntry;\n\n\t//stats for read\n\ts32 max_ts_delta;\n} GF_CompositionOffsetBox;\n\n\n#define GF_ISOM_SAMPLE_ENTRY_FIELDS\t\t\\\n\tGF_ISOM_UUID_BOX\t\t\t\t\t\\\n\tu16 dataReferenceIndex;\t\t\t\t\\\n\tchar reserved[ 6 ];\t\t\t\t\t\\\n\tu32 internal_type;\t\t\t\t\t\\\n\n/*base sample entry box - used by some generic media sample descriptions of QT*/\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\n} GF_SampleEntryBox;\n\nvoid gf_isom_sample_entry_init(GF_SampleEntryBox *ptr);\nvoid gf_isom_sample_entry_predestroy(GF_SampleEntryBox *ptr);\nGF_Err gf_isom_base_sample_entry_read(GF_SampleEntryBox *ptr, GF_BitStream *bs);\n\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\n\t/*box type as specified in the file (not this box's type!!)*/\n\tu32 EntryType;\n\n\tu8 *data;\n\tu32 data_size;\n} GF_GenericSampleEntryBox;\n\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\n\n\tu32 flags;\n\tu32 timescale;\n\tu32 frame_duration;\n\tu8 frames_per_counter_tick;\n} GF_TimeCodeSampleEntryBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\n    u16 text_font;\n    u16 text_face;\n    u16 text_size;\n    u16 text_color_red, text_color_green, text_color_blue;\n    u16 back_color_red, back_color_green, back_color_blue;\n    char *font;\n} GF_TimeCodeMediaInformationBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\n    u8 field_count;\n    u8 field_order;\n} GF_FieldInfoBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n    u32 gama;\n} GF_GamaInfoBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n    u16 chroma;\n} GF_ChromaInfoBox;\n\ntypedef struct\n{\n    u32 label;\n    u32 flags;\n    Float coordinates[3];\n} GF_AudioChannelDescription;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\n    u32 layout_tag;\n    u32 bitmap;\n    u32 num_audio_description;\n    GF_AudioChannelDescription *audio_descs;\n    u8 *ext_data;\n    u32 ext_data_size;\n} GF_ChannelLayoutInfoBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\n    u32 preload_start_time;\n    u32 preload_duration;\n    u32 preload_flags;\n    u32 default_hints;\n} GF_TrackLoadBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\n\tGF_AudioChannelLayout layout;\n} GF_ChannelLayoutBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_ESD *desc;\n} GF_ESDBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 bufferSizeDB;\n\tu32 maxBitrate;\n\tu32 avgBitrate;\n} GF_BitRateBox;\n\nGF_BitRateBox *gf_isom_sample_entry_get_bitrate(GF_SampleEntryBox *ent, Bool create);\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_List *descriptors;\n} GF_MPEG4ExtensionDescriptorsBox;\n\n/*for most MPEG4 media */\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\n\tGF_ESDBox *esd;\n\t/*used for hinting when extracting the OD stream...*/\n\tGF_SLConfig *slc;\n} GF_MPEGSampleEntryBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu8 *hdr;\n\tu32 hdr_size;\n} GF_LASERConfigurationBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\n\n\tGF_LASERConfigurationBox *lsr_config;\n\tGF_MPEG4ExtensionDescriptorsBox *descr;\n\n\t/*used for hinting when extracting the OD stream...*/\n\tGF_SLConfig *slc;\n} GF_LASeRSampleEntryBox;\n\n/*rewrites avcC based on the given esd - this destroys the esd*/\nGF_Err LSR_UpdateESD(GF_LASeRSampleEntryBox *lsr, GF_ESD *esd);\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 hSpacing;\n\tu32 vSpacing;\n} GF_PixelAspectRatioBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 cleanApertureWidthN;\n\tu32 cleanApertureWidthD;\n\tu32 cleanApertureHeightN;\n\tu32 cleanApertureHeightD;\n\tu32 horizOffN;\n\tu32 horizOffD;\n\tu32 vertOffN;\n\tu32 vertOffD;\n} GF_CleanApertureBox;\n\n\ntypedef struct __ContentLightLevel {\n\tGF_ISOM_BOX\n\tGF_ContentLightLevelInfo clli;\n} GF_ContentLightLevelBox;\n\ntypedef struct ___MasteringDisplayColourVolume {\n\tGF_ISOM_BOX\n\tGF_MasteringDisplayColourVolumeInfo mdcv;\n} GF_MasteringDisplayColourVolumeBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tBool all_ref_pics_intra;\n\tBool intra_pred_used;\n\tu32 max_ref_per_pic;\n\tu32 reserved;\n} GF_CodingConstraintsBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tchar *aux_track_type;\n} GF_AuxiliaryTypeInfoBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu16 predefined_rvc_config;\n\tu32 rvc_meta_idx;\n} GF_RVCConfigurationBox;\n\n\ntypedef struct {\n\tGF_ISOM_BOX\n\tBool is_jp2;\n\n\tu32 colour_type;\n\tu16 colour_primaries;\n\tu16 transfer_characteristics;\n\tu16 matrix_coefficients;\n\tBool full_range_flag;\n\tu8 *opaque;\n\tu32 opaque_size;\n\n\tu8 method, precedence, approx;\n} GF_ColourInformationBox;\n\n\n//do NOT extend this structure with boxes, children boxes shall go into the other_box field of the parent\n#define GF_ISOM_VISUAL_SAMPLE_ENTRY\t\t\\\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\t\t\t\\\n\tu16 revision;\t\t\t\t\t\t\\\n\tu32 vendor;\t\t\t\t\t\t\t\\\n\tu32 temporal_quality;\t\t\t\t\\\n\tu32 spatial_quality;\t\t\t\t\\\n\tu16 Width, Height;\t\t\t\t\t\\\n\tu32 horiz_res, vert_res;\t\t\t\\\n\tu32 entry_data_size;\t\t\t\t\\\n\tu16 frames_per_sample;\t\t\t\t\\\n\tchar compressor_name[33];\t\t\t\\\n\tu16 bit_depth;\t\t\t\t\t\t\\\n\ts16 color_table_index;\t\t\t\t\\\n\tstruct __tag_protect_box *rinf; \t\\\n\ntypedef struct\n{\n\tGF_ISOM_VISUAL_SAMPLE_ENTRY\n} GF_VisualSampleEntryBox;\n\nvoid gf_isom_video_sample_entry_init(GF_VisualSampleEntryBox *ent);\nGF_Err gf_isom_video_sample_entry_read(GF_VisualSampleEntryBox *ptr, GF_BitStream *bs);\n#ifndef GPAC_DISABLE_ISOM_WRITE\nvoid gf_isom_video_sample_entry_write(GF_VisualSampleEntryBox *ent, GF_BitStream *bs);\nvoid gf_isom_video_sample_entry_size(GF_VisualSampleEntryBox *ent);\n#endif\n\nvoid gf_isom_sample_entry_predestroy(GF_SampleEntryBox *ptr);\n\n\nGF_Box *gf_isom_box_find_child(GF_List *parent_child_list, u32 code);\nvoid gf_isom_box_del_parent(GF_List **parent_child_list, GF_Box*b);\nGF_Box *gf_isom_box_new_parent(GF_List **parent_child_list, u32 code);\nBool gf_isom_box_check_unique(GF_List *children, GF_Box *a);\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_AVCConfig *config;\n} GF_AVCConfigurationBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_HEVCConfig *config;\n} GF_HEVCConfigurationBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_VVCConfig *config;\n} GF_VVCConfigurationBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_AV1Config *config;\n} GF_AV1ConfigurationBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_VPConfig *config;\n} GF_VPConfigurationBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu16 primaryRChromaticity_x;\n\tu16 primaryRChromaticity_y;\n\tu16 primaryGChromaticity_x;\n\tu16 primaryGChromaticity_y;\n\tu16 primaryBChromaticity_x;\n\tu16 primaryBChromaticity_y;\n\tu16 whitePointChromaticity_x;\n\tu16 whitePointChromaticity_y;\n\tu32 luminanceMax;\n\tu32 luminanceMin;\n} GF_SMPTE2086MasteringDisplayMetadataBox;\n\ntypedef struct {\n\tGF_ISOM_FULL_BOX\n\t\tu16 maxCLL;\n\tu16 maxFALL;\n} GF_VPContentLightLevelBox;\n\ntypedef struct {\n\tGF_ISOM_BOX\n\tGF_DOVIDecoderConfigurationRecord DOVIConfig;\n} GF_DOVIConfigurationBox;\n\n/*typedef struct { //extends Box('hvcE')\n\tGF_ISOM_BOX\n\tGF_HEVCConfig HEVCConfig;\n} GF_DolbyVisionELHEVCConfigurationBox;*/\n\ntypedef struct { //extends HEVCSampleEntry('dvhe')\n\tGF_DOVIConfigurationBox config;\n\t//TODO: GF_DolbyVisionELHEVCConfigurationBox ELConfig; // optional\n} GF_DolbyVisionHEVCSampleEntry;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_3GPConfig cfg;\n} GF_3GPPConfigBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\n\tu32 width, height;\n\tu16 nb_comp;\n\tu8 bpc, Comp, UnkC, IPR;\n} GF_J2KImageHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_J2KImageHeaderBox *ihdr;\n\tGF_ColourInformationBox *colr;\n} GF_J2KHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_VISUAL_SAMPLE_ENTRY\n\tGF_ESDBox *esd;\n\t/*used for Publishing*/\n\tGF_SLConfig *slc;\n\n\t/*avc extensions - we merged with regular 'mp4v' box to handle isma E&A signaling of AVC*/\n\tGF_AVCConfigurationBox *avc_config;\n\tGF_AVCConfigurationBox *svc_config;\n\tGF_AVCConfigurationBox *mvc_config;\n\t/*hevc extension*/\n\tGF_HEVCConfigurationBox *hevc_config;\n\tGF_HEVCConfigurationBox *lhvc_config;\n\t/*vvc extension*/\n\tGF_VVCConfigurationBox *vvc_config;\n\t/*av1 extension*/\n\tGF_AV1ConfigurationBox *av1_config;\n\t/*vp8-9 extension*/\n\tGF_VPConfigurationBox *vp_config;\n\t/*jp2k extension*/\n\tGF_J2KHeaderBox *jp2h;\n\t/*dolbyvision extension*/\n\tGF_DOVIConfigurationBox *dovi_config;\n\n\t/*internally emulated esd*/\n\tGF_ESD *emul_esd;\n\n\t//3GPP\n\tGF_3GPPConfigBox *cfg_3gpp;\n\n\t/*iPod's hack*/\n\tGF_UnknownUUIDBox *ipod_ext;\n\n} GF_MPEGVisualSampleEntryBox;\n\nstatic const u8 GF_ISOM_IPOD_EXT[][16] = { { 0x6B, 0x68, 0x40, 0xF2, 0x5F, 0x24, 0x4F, 0xC5, 0xBA, 0x39, 0xA5, 0x1B, 0xCF, 0x03, 0x23, 0xF3} };\n\nBool gf_isom_is_nalu_based_entry(GF_MediaBox *mdia, GF_SampleEntryBox *_entry);\nGF_Err gf_isom_nalu_sample_rewrite(GF_MediaBox *mdia, GF_ISOSample *sample, u32 sampleNumber, GF_MPEGVisualSampleEntryBox *entry);\n\n/*this is the default visual sdst (to handle unknown media)*/\ntypedef struct\n{\n\tGF_ISOM_VISUAL_SAMPLE_ENTRY\n\t/*box type as specified in the file (not this box's type!!)*/\n\tu32 EntryType;\n\t/*opaque description data (ESDS in MP4, SMI in SVQ3, ...)*/\n\tu8 *data;\n\tu32 data_size;\n} GF_GenericVisualSampleEntryBox;\n\nenum\n{\n\tGF_ISOM_AUDIO_QTFF_NONE = 0,\n\t//sample entry is QTFF and data in extensions() is NOT valid (conversion done by libisomedia)\n\tGF_ISOM_AUDIO_QTFF_ON_NOEXT,\n\t//sample entry is QTFF and data in extensions() is valid (import from QT)\n\tGF_ISOM_AUDIO_QTFF_ON_EXT_VALID,\n\tGF_ISOM_AUDIO_QTFF_CONVERT_FLAG = 1<<16\n};\n\n#define GF_ISOM_AUDIO_SAMPLE_ENTRY\t\\\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\t\t\\\n\tu16 revision;\t\t\t\t\t\\\n\tu32 vendor;\t\t\t\t\t\t\\\n\tu16 channel_count;\t\t\t\t\\\n\tu16 bitspersample;\t\t\t\t\\\n\tu16 compression_id;\t\t\t\t\\\n\tu16 packet_size;\t\t\t\t\\\n\tu32 qtff_mode;\t\t\t\t\t\\\n\tu16 samplerate_hi;\t\t\t\t\\\n\tu16 samplerate_lo;\t\t\t\t\\\n\tu8 extensions[36];\t\t\t\t\\\n\n\ntypedef struct\n{\n\tGF_ISOM_AUDIO_SAMPLE_ENTRY\n} GF_AudioSampleEntryBox;\n\nvoid gf_isom_audio_sample_entry_init(GF_AudioSampleEntryBox *ptr);\nGF_Err gf_isom_audio_sample_entry_read(GF_AudioSampleEntryBox *ptr, GF_BitStream *bs);\n#ifndef GPAC_DISABLE_ISOM_WRITE\nvoid gf_isom_audio_sample_entry_write(GF_AudioSampleEntryBox *ptr, GF_BitStream *bs);\nvoid gf_isom_audio_sample_entry_size(GF_AudioSampleEntryBox *ptr);\n#endif\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_AC3Config cfg;\n} GF_AC3ConfigBox;\n\n\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 format_info;\n\tu16 peak_data_rate;\n} GF_TrueHDConfigBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu8 *data;\n\tu32 dataSize;\n} GF_FLACConfigBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu8 stereo_type;\n} GF_Stereo3DBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tchar *string;\n} GF_SphericalVideoInfoBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\ts32 yaw;\n\ts32 pitch;\n\ts32 roll;\n} GF_ProjectionHeaderBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\t//cube map\n\tu32 layout;\n\ts32 padding;\n\t//EQR\n\tu32 bounds_top, bounds_bottom, bounds_left, bounds_right;\n\t//mesh\n\tu32 crc;\n\ts32 encoding_4cc;\n\n} GF_ProjectionTypeBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\n\t/*OpusSpecificBox*/\n\t/*u8 version;              //1, field included in base box structure */\n\tu8 OutputChannelCount;   //same value as the *Output Channel Count* field in the identification header defined in Ogg Opus [3]\n\tu16 PreSkip;             //The value of the PreSkip field shall be at least 80 milliseconds' worth of PCM samples even when removing any number of Opus samples which may or may not contain the priming samples. The PreSkip field is not used for discarding the priming samples at the whole playback at all since it is informative only, and that task falls on the Edit List Box.\n\tu32 InputSampleRate;     //The InputSampleRate field shall be set to the same value as the *Input Sample Rate* field in the identification header defined in Ogg Opus\n\ts16 OutputGain;          //The OutputGain field shall be set to the same value as the *Output Gain* field in the identification header define in Ogg Opus [3]. Note that the value is stored as 8.8 fixed-point.\n\tu8 ChannelMappingFamily; //The ChannelMappingFamily field shall be set to the same value as the *Channel Mapping Family* field in the identification header defined in Ogg Opus [3]. Note that the value 255 may be used for an alternative to map channels by ISO Base Media native mapping. The details are described in 4.5.1.\n\n\tu8 StreamCount; // The StreamCount field shall be set to the same value as the *Stream Count* field in the identification header defined in Ogg Opus [3].\n\tu8 CoupledCount; // The CoupledCount field shall be set to the same value as the *Coupled Count* field in the identification header defined in Ogg Opus [3].\n\tu8 ChannelMapping[255]; // The ChannelMapping field shall be set to the same octet string as *Channel Mapping* field in the identi- fication header defined in Ogg Opus [3].\n\n\t/*for internal box use only*/\n//\tint channels;\n} GF_OpusSpecificBox;\n\nGF_Err gf_isom_opus_config_new(GF_ISOFile *the_file, u32 trackNumber, GF_OpusSpecificBox *cfg, char *URLname, char *URNname, u32 *outDescriptionIndex);\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu8 configuration_version;\n\tu8 mha_pl_indication;\n\tu8 reference_channel_layout;\n\tu16 mha_config_size;\n\tchar *mha_config;\n} GF_MHAConfigBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu8 num_profiles;\n\tu8 *compat_profiles;\n} GF_MHACompatibleProfilesBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu8 format_flags;\n\tu8 PCM_sample_size;\n} GF_PCMConfigBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_AUDIO_SAMPLE_ENTRY\n\t//for MPEG4 audio\n\tGF_ESDBox *esd;\n\tGF_SLConfig *slc;\n\t//for 3GPP audio\n\tGF_3GPPConfigBox *cfg_3gpp;\n\n\t//for AC3/EC3 audio\n\tGF_AC3ConfigBox *cfg_ac3;\n\n\t//for AC3/EC3 audio\n\tGF_TrueHDConfigBox *cfg_mlp;\n\n\t//for Opus\n\tGF_OpusSpecificBox *cfg_opus;\n\n\t//for MPEG-H audio\n\tGF_MHAConfigBox *cfg_mha;\n\n\t//for FLAC\n\tGF_FLACConfigBox *cfg_flac;\n\n} GF_MPEGAudioSampleEntryBox;\n\n/*this is the default visual sdst (to handle unknown media)*/\ntypedef struct\n{\n\tGF_ISOM_AUDIO_SAMPLE_ENTRY\n\t/*box type as specified in the file (not this box's type!!)*/\n\tu32 EntryType;\n\t/*opaque description data (ESDS in MP4, ...)*/\n\tu8 *data;\n\tu32 data_size;\n} GF_GenericAudioSampleEntryBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu8 profile;\n\tu8 level;\n\tu8 pathComponents;\n\tBool fullRequestHost;\n\tBool streamType;\n\tu8 containsRedundant;\n\tchar *textEncoding;\n\tchar *contentEncoding;\n} GF_DIMSSceneConfigBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tchar *content_script_types;\n} GF_DIMSScriptTypesBox;\n\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\n\tGF_DIMSSceneConfigBox *config;\n\tGF_DIMSScriptTypesBox *scripts;\n} GF_DIMSSampleEntryBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tchar *config;\n} GF_TextConfigBox;\n\n/*base metadata sample entry box for METT, METX, SBTT, STXT and STPP*/\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\n\tchar *content_encoding;\t//optional\n\tchar *mime_type; //for anything except metx\n\tchar *xml_namespace;\t//for metx and sttp only\n\tchar *xml_schema_loc;\t// for metx and sttp only\n\tGF_TextConfigBox *config; //optional for anything except metx and sttp\n} GF_MetaDataSampleEntryBox;\n\n\ntypedef struct\n{\n\tu8 entry_type;\n\tunion {\n\t\tu32 trackID;\n\t\tu32 output_view_id;\n\t\tu32 start_view_id;\n\t};\n\tunion {\n\t\tu16 tierID;\n\t\tu16 view_count;\n\t};\n} MVCIEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 multiview_group_id;\n\tu16 num_entries;\n\tMVCIEntry *entries;\n} GF_MultiviewGroupBox;\n\ntypedef struct\n{\n\tu8 dep_comp_idc;\n\tu16 ref_view_id;\n} ViewIDRefViewEntry;\n\ntypedef struct\n{\n\tu16 view_id;\n\tu16 view_order_index;\n\tu8 texture_in_stream;\n\tu8 texture_in_track;\n\tu8 depth_in_stream;\n\tu8 depth_in_track;\n\tu8 base_view_type;\n\tu16 num_ref_views;\n\tViewIDRefViewEntry *view_refs;\n} ViewIDEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu8 min_temporal_id;\n\tu8 max_temporal_id;\n\tu16 num_views;\n\tViewIDEntry *views;\n} GF_ViewIdentifierBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n} GF_SampleDescriptionBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\t/*if this is the compact version, sample size is actually fieldSize*/\n\tu32 sampleSize;\n\tu32 sampleCount;\n\tu32 alloc_size;\n\tu32 *sizes;\n\t//stats for read\n\tu32 max_size;\n\tu64 total_size;\n\tu32 total_samples;\n} GF_SampleSizeBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 nb_entries;\n\tu32 alloc_size;\n\tu32 *offsets;\n} GF_ChunkOffsetBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 nb_entries;\n\tu32 alloc_size;\n\tu64 *offsets;\n} GF_ChunkLargeOffsetBox;\n\ntypedef struct\n{\n\tu32 firstChunk;\n\tu32 nextChunk;\n\tu32 samplesPerChunk;\n\tu32 sampleDescriptionIndex;\n\tu8 isEdited;\n} GF_StscEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_StscEntry *entries;\n\tu32 alloc_size, nb_entries;\n\n\t/*0-based cache for READ. In WRITE mode, we always have 1 sample per chunk so no need for a cache*/\n\tu32 currentIndex;\n\t/*first sample number in this chunk*/\n\tu32 firstSampleInCurrentChunk;\n\tu32 currentChunk;\n\tu32 ghostNumber;\n\n\tu32 w_lastSampleNumber;\n\tu32 w_lastChunkNumber;\n} GF_SampleToChunkBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 alloc_size, nb_entries;\n\tu32 *sampleNumbers;\n\t/*cache for READ mode (in write we realloc no matter what)*/\n\tu32 r_LastSyncSample;\n\t/*0-based index in the array*/\n\tu32 r_LastSampleIndex;\n} GF_SyncSampleBox;\n\ntypedef struct\n{\n\tu32 shadowedSampleNumber;\n\ts32 syncSampleNumber;\n} GF_StshEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *entries;\n\t/*Cache for read mode*/\n\tu32 r_LastEntryIndex;\n\tu32 r_LastFoundSample;\n} GF_ShadowSyncBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 nb_entries;\n\tu16 *priorities;\n} GF_DegradationPriorityBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 SampleCount;\n\tu8 *padbits;\n} GF_PaddingBitsBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 sampleCount, sample_alloc;\n\t/*each dep type is packed on 1 byte*/\n\tu8 *sample_info;\n} GF_SampleDependencyTypeBox;\n\n\ntypedef struct\n{\n\tu32 subsample_size;\n\tu8 subsample_priority;\n\tu8 discardable;\n\tu32 reserved;\n} GF_SubSampleEntry;\n\ntypedef struct\n{\n\tu32 sample_delta;\n\tGF_List *SubSamples;\n} GF_SubSampleInfoEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *Samples;\n} GF_SubSampleInformationBox;\n\nBool gf_isom_get_subsample_types(GF_ISOFile *movie, u32 track, u32 subs_index, u32 *flags);\nu32  gf_isom_sample_get_subsample_entry(GF_ISOFile *movie, u32 track, u32 sampleNumber, u32 entry_index, GF_SubSampleInfoEntry **sub_sample);\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err gf_isom_add_subsample_info(GF_SubSampleInformationBox *sub_samples, u32 sampleNumber, u32 subSampleSize, u8 priority, u32 reserved, Bool discardable);\n#endif\n\n/* Use to relate the composition and decoding timeline when signed composition is used*/\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\n\ts32 compositionToDTSShift;\n\ts32 leastDecodeToDisplayDelta;\n\ts32 greatestDecodeToDisplayDelta;\n\ts32 compositionStartTime;\n\ts32 compositionEndTime;\n} GF_CompositionToDecodeBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\n\tu32 aux_info_type;\n\tu32 aux_info_type_parameter;\n\n\tu8 default_sample_info_size;\n\tu32 sample_count, sample_alloc;\n\tu8 *sample_info_size;\n\n\tu32 cached_sample_num;\n\tu32 cached_prev_size;\n} GF_SampleAuxiliaryInfoSizeBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\n\tu32 aux_info_type;\n\tu32 aux_info_type_parameter;\n\n\tu8 default_sample_info_size;\n\tu32 entry_count;  //1 or stco / trun count\n\tu32 entry_alloc;\n\tu64 *offsets;\n\n\tu64 offset_first_offset_field;\n\n\tu32 total_size;\n\tu8 *cached_data;\n} GF_SampleAuxiliaryInfoOffsetBox;\n\ntypedef struct\n{\n\tu32 sample_num;\n\tu8 *moof_template;\n\tu32 moof_template_size;\n\tu64 seg_start_plus_one;\n\tu64 sidx_start;\n\tu64 sidx_end;\n\tu64 moof_start;\n\tu64 mdat_end;\n} GF_TrafMapEntry;\n\ntypedef struct\n{\n\tu32 nb_entries, nb_alloc;\n\tGF_TrafMapEntry *frag_starts;\n} GF_TrafToSampleMap;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_TimeToSampleBox *TimeToSample;\n\tGF_CompositionOffsetBox *CompositionOffset;\n\tGF_CompositionToDecodeBox *CompositionToDecode;\n\tGF_SyncSampleBox *SyncSample;\n\tGF_SampleDescriptionBox *SampleDescription;\n\tGF_SampleSizeBox *SampleSize;\n\tGF_SampleToChunkBox *SampleToChunk;\n\t/*untyped, to handle 32 bits and 64 bits chunkOffsets*/\n\tGF_Box *ChunkOffset;\n\tGF_ShadowSyncBox *ShadowSync;\n\tGF_DegradationPriorityBox *DegradationPriority;\n\tGF_PaddingBitsBox *PaddingBits;\n\tGF_SampleDependencyTypeBox *SampleDep;\n\n\tGF_TrafToSampleMap *traf_map;\n\n\tGF_List *sub_samples;\n\n\tGF_List *sampleGroups;\n\tGF_List *compactSampleGroups;\n\tGF_List *sampleGroupsDescription;\n\tu32 nb_sgpd_in_stbl;\n\tu32 nb_stbl_boxes;\n\n\tGF_List *sai_sizes;\n\tGF_List *sai_offsets;\n\n\tu32 MaxSamplePerChunk, MaxChunkSize;\n\tu16 groupID;\n\tu16 trackPriority;\n\tu32 currentEntryIndex;\n\n\tBool no_sync_found;\n\n\tu32 r_last_chunk_num, r_last_sample_num, r_last_offset_in_chunk;\n\tu8 patch_piff_psec;\n} GF_SampleTableBox;\n\nGF_Err stbl_AppendTrafMap(GF_SampleTableBox *stbl, Bool is_seg_start, u64 seg_start_offset, u64 frag_start_offset, u8 *moof_template, u32 moof_template_size, u64 sidx_start, u64 sidx_end);\n\ntypedef struct __tag_media_info_box\n{\n\tGF_ISOM_BOX\n\tGF_DataInformationBox *dataInformation;\n\tGF_SampleTableBox *sampleTable;\n\tGF_Box *InfoHeader;\n\tstruct __tag_data_map *scalableDataHandler;\n\tstruct __tag_data_map *dataHandler;\n\tu32 dataEntryIndex;\n} GF_MediaInformationBox;\n\nGF_Err stbl_SetDependencyType(GF_SampleTableBox *stbl, u32 sampleNumber, u32 isLeading, u32 dependsOn, u32 dependedOn, u32 redundant);\nGF_Err stbl_AppendDependencyType(GF_SampleTableBox *stbl, u32 isLeading, u32 dependsOn, u32 dependedOn, u32 redundant);\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu8 *data;\n\tu32 dataSize;\n\tu32 original_4cc;\n} GF_FreeSpaceBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n} GF_WideBox; /*Apple*/\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tchar packedLanguageCode[4];\n\tchar *notice;\n} GF_CopyrightBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tchar *schemeURI;\n\tchar *value;\n} GF_KindBox;\n\n\ntypedef struct\n{\n\tchar *name;\n\tu64 start_time;\n} GF_ChapterEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *list;\n} GF_ChapterListBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 reference_type;\n\tu32 trackIDCount;\n\tGF_ISOTrackID *trackIDs;\n} GF_TrackReferenceTypeBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 grouping_type;\n\tu32 group_id;\n\tu32 entity_id_count;\n\tu32 *entity_ids;\n} GF_EntityToGroupTypeBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 majorBrand;\n\tu32 minorVersion;\n\tu32 altCount;\n\tu32 *altBrand;\n} GF_FileTypeBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 *rates;\n\tu32 *times;\n\tu32 count;\n} GF_ProgressiveDownloadBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 switch_group;\n\tu32 alternate_group;\n\tGF_ISOTrackID sub_track_id;\n\tu64 attribute_count;\n\tu32 *attribute_list;\n} GF_SubTrackInformationBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 grouping_type;\n\tu16 nb_groups;\n\tu32 *group_description_index;\n} GF_SubTrackSampleGroupBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_SubTrackInformationBox *info;\n\tGF_Box *strd;\n} GF_SubTrackBox;\n\n/*\n\t3GPP streaming text boxes\n*/\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 entry_count;\n\tGF_FontRecord *fonts;\n} GF_FontTableBox;\n\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\t\t\t\t\\\n\tu32 displayFlags;\n\ts8 horizontal_justification;\n\ts8 vertical_justification;\n\t/*ARGB*/\n\tu32 back_color;\n\tGF_BoxRecord default_box;\n\tGF_StyleRecord\tdefault_style;\n\tGF_FontTableBox *font_table;\n} GF_Tx3gSampleEntryBox;\n\n/*Apple specific*/\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\t\t\t\t\\\n\tu32 displayFlags;\n\tu32 textJustification;\n\tchar background_color[6], foreground_color[6];\n\tGF_BoxRecord default_box;\n\tu16 fontNumber;\n\tu16 fontFace;\n\tchar reserved1[8];\n\tu8 reserved2;\n\tu16 reserved3;\n\tchar *textName; /*font name*/\n} GF_TextSampleEntryBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 entry_count;\n\tGF_StyleRecord *styles;\n} GF_TextStyleBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu16 startcharoffset;\n\tu16 endcharoffset;\n} GF_TextHighlightBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\t/*ARGB*/\n\tu32 hil_color;\n} GF_TextHighlightColorBox;\n\ntypedef struct\n{\n\tu32 highlight_endtime;\n\tu16 start_charoffset;\n\tu16 end_charoffset;\n} KaraokeRecord;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 highlight_starttime;\n\tu16 nb_entries;\n\tKaraokeRecord *records;\n} GF_TextKaraokeBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 scroll_delay;\n} GF_TextScrollDelayBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu16 startcharoffset;\n\tu16 endcharoffset;\n\tchar *URL;\n\tchar *URL_hint;\n} GF_TextHyperTextBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_BoxRecord box;\n} GF_TextBoxBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu16 startcharoffset;\n\tu16 endcharoffset;\n} GF_TextBlinkBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu8 wrap_flag;\n} GF_TextWrapBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 switchGroup;\n\tu32 *attributeList;\n\tu32 attributeListCount;\n} GF_TrackSelectionBox;\n\n/*\n\tMPEG-21 extensions\n*/\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tchar *xml;\n} GF_XMLBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 data_length;\n\tu8 *data;\n} GF_BinaryXMLBox;\n\n\ntypedef struct\n{\n\tu16 item_ID;\n\tu16 construction_method;\n\tu16 data_reference_index;\n\tu64 base_offset;\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t/*for storage only*/\n\tu64 original_base_offset;\n#endif\n\tGF_List *extent_entries;\n} GF_ItemLocationEntry;\n\nvoid iloc_entry_del(GF_ItemLocationEntry *location);\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu8 offset_size;\n\tu8 length_size;\n\tu8 base_offset_size;\n\tu8 index_size;\n\tGF_List *location_entries;\n} GF_ItemLocationBox;\n\ntypedef\tstruct\n{\n\tGF_ISOM_FULL_BOX\n\tu16 item_ID;\n} GF_PrimaryItemBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *protection_information;\n} GF_ItemProtectionBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu16 item_ID;\n\tu16 item_protection_index;\n\tu32 item_type;\n\t/*zero-terminated strings*/\n\tchar *item_name;\n\tchar *content_type;\n\tchar *content_encoding;\n\t// needed to actually read the resource file, but not written in the MP21 file.\n\tchar *full_path;\n\t// if not 0, full_path is actually the data to write.\n\tu32 data_len;\n\n\tu32 tk_id, sample_num;\n} GF_ItemInfoEntryBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *item_infos;\n} GF_ItemInfoBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 reference_type;\n\tu32 from_item_id;\n\tu32 reference_count;\n\tu32 *to_item_IDs;\n} GF_ItemReferenceTypeBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *references;\n} GF_ItemReferenceBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 data_format;\n} GF_OriginalFormatBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 scheme_type;\n\tu32 scheme_version;\n\tchar *URI;\n} GF_SchemeTypeBox;\n\n/*ISMACryp specific*/\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\t/*zero-terminated string*/\n\tchar *URI;\n} GF_ISMAKMSBox;\n\n/*ISMACryp specific*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu64 salt;\n} GF_ISMACrypSaltBox;\n\n/*ISMACryp specific*/\ntypedef struct __isma_format_box\n{\n\tGF_ISOM_FULL_BOX\n\tu8 selective_encryption;\n\tu8 key_indicator_length;\n\tu8 IV_length;\n} GF_ISMASampleFormatBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_ISMAKMSBox *ikms;\n\tGF_ISMASampleFormatBox *isfm;\n\tGF_ISMACrypSaltBox *islt;\n\tstruct __oma_kms_box *odkm;\n\tstruct __cenc_tenc_box *tenc;\n\tstruct __piff_tenc_box *piff_tenc;\n\tstruct __adobe_drm_key_management_system_box *adkm;\n} GF_SchemeInformationBox;\n\ntypedef struct __tag_protect_box\n{\n\tGF_ISOM_BOX\n\tGF_OriginalFormatBox *original_format;\n\tGF_SchemeTypeBox *scheme_type;\n\tGF_SchemeInformationBox *info;\n} GF_ProtectionSchemeInfoBox;\ntypedef struct __tag_protect_box GF_RestrictedSchemeInfoBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *descriptors;\n} GF_IPMPInfoBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_IPMP_ToolList *ipmp_tools;\n\tGF_List *descriptors;\n} GF_IPMPControlBox;\n\ntypedef struct {\n\tGF_ISOM_BOX\n} GF_ItemPropertyContainerBox;\n\ntypedef struct {\n\tGF_ISOM_BOX\n\tGF_ItemPropertyContainerBox *property_container;\n\tstruct __item_association_box *property_association;\n} GF_ItemPropertiesBox;\n\ntypedef struct {\n\tGF_ISOM_BOX\n} GF_GroupListBox;\n\ntypedef struct __tag_meta_box\n{\n\tGF_ISOM_FULL_BOX\n\tGF_HandlerBox *handler;\n\tGF_PrimaryItemBox *primary_resource;\n\tGF_DataInformationBox *file_locations;\n\tGF_ItemLocationBox *item_locations;\n\tGF_ItemProtectionBox *protections;\n\tGF_ItemInfoBox *item_infos;\n\tGF_IPMPControlBox *IPMP_control;\n\tGF_ItemPropertiesBox *item_props;\n\tGF_ItemReferenceBox *item_refs;\n\tGF_GroupListBox *groups_list;\n\n\tBool use_item_sample_sharing;\n} GF_MetaBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\n\tu32 single_view_allowed;\n\tu32 stereo_scheme;\n\tu32 sit_len;\n\tchar *stereo_indication_type;\n} GF_StereoVideoBox;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\n/*V2 boxes - Movie Fragments*/\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu64 fragment_duration;\n} GF_MovieExtendsHeaderBox;\n\n\ntypedef struct __tag_mvex_box\n{\n\tGF_ISOM_BOX\n\tGF_List *TrackExList;\n\tGF_List *TrackExPropList;\n\tGF_MovieExtendsHeaderBox *mehd;\n\tGF_ISOFile *mov;\n} GF_MovieExtendsBox;\n\n/*the TrackExtends contains default values for the track fragments*/\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_ISOTrackID trackID;\n\tu32 def_sample_desc_index;\n\tu32 def_sample_duration;\n\tu32 def_sample_size;\n\tu32 def_sample_flags;\n\tGF_TrackBox *track;\n\n\tBool cannot_use_default;\n\tGF_ISOTrackID inherit_from_traf_id;\n\t\n\tGF_TrackFragmentRandomAccessBox *tfra;\n} GF_TrackExtendsBox;\n\n/*the TrackExtends contains default values for the track fragments*/\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_ISOTrackID trackID;\n} GF_TrackExtensionPropertiesBox;\n\n/*indicates the seq num of this fragment*/\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 sequence_number;\n} GF_MovieFragmentHeaderBox;\n\n/*MovieFragment is a container IN THE FILE, contains 1 fragment*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_MovieFragmentHeaderBox *mfhd;\n\tGF_List *TrackList;\n\tGF_List *PSSHs;\n\tGF_ISOFile *mov;\n\t/*offset in the file of moof or mdat (whichever comes first) for this fragment*/\n\tu64 fragment_offset;\n\tu32 mdat_size;\n\tu8 *mdat;\n\t//when moof box was a compressed moof box, indicates the difference between the uncompressed size and the compressed size\n\ts32 compressed_diff;\n\n\t//temp storage of prft box\n\tGF_ISOTrackID reference_track_ID;\n\tu64 ntp, timestamp;\n} GF_MovieFragmentBox;\n\n\n/*FLAGS for TRAF*/\nenum\n{\n\tGF_ISOM_TRAF_BASE_OFFSET\t=\t0x01,\n\tGF_ISOM_TRAF_SAMPLE_DESC\t=\t0x02,\n\tGF_ISOM_TRAF_SAMPLE_DUR\t=\t0x08,\n\tGF_ISOM_TRAF_SAMPLE_SIZE\t=\t0x10,\n\tGF_ISOM_TRAF_SAMPLE_FLAGS\t=\t0x20,\n\tGF_ISOM_TRAF_DUR_EMPTY\t=\t0x10000,\n\tGF_ISOM_MOOF_BASE_OFFSET\t=\t0x20000,\n};\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_ISOTrackID trackID;\n\t/* all the following are optional fields */\n\tu64 base_data_offset;\n\tu32 sample_desc_index;\n\tu32 def_sample_duration;\n\tu32 def_sample_size;\n\tu32 def_sample_flags;\n\tu32 EmptyDuration;\n} GF_TrackFragmentHeaderBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu64 baseMediaDecodeTime;\n} GF_TFBaseMediaDecodeTimeBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_TrackFragmentHeaderBox *tfhd;\n\tGF_List *TrackRuns;\n\t/*keep a pointer to default flags*/\n\tGF_TrackExtendsBox *trex;\n\tGF_SampleDependencyTypeBox *sdtp;\n\n//\tGF_SubSampleInformationBox *subs;\n\tGF_List *sub_samples;\n\n\tGF_List *sampleGroups;\n\tGF_List *compactSampleGroups;\n\tGF_List *sampleGroupsDescription;\n\n\tGF_List *sai_sizes;\n\tGF_List *sai_offsets;\n\n\t//can be senc or PIFF psec\n\tstruct __sample_encryption_box *sample_encryption;\n\tstruct __traf_mss_timeext_box *tfxd; /*similar to PRFT but for Smooth Streaming*/\n\tstruct __traf_mss_timeref_box *tfrf;\n\n\t/*when data caching is on*/\n\tu32 DataCache;\n\tGF_TFBaseMediaDecodeTimeBox *tfdt;\n\n\tu64 moof_start_in_bs;\n#ifdef GF_ENABLE_CTRN\n\tBool use_ctrn;\n\tBool use_inherit;\n#endif\n\n\tu32 interleave_id;\n\tu8 merge_sample_interleave;\n\tu8 use_sample_interleave;\n\tu8 force_new_trun;\n\tu8 IFrameSwitching;\n\tu8 use_sdtp;\n\tu8 truns_first;\n\tu8 truns_v1;\n\tu8 large_tfdt;\n} GF_TrackFragmentBox;\n\nGF_TrackFragmentBox *gf_isom_get_traf(GF_ISOFile *mov, GF_ISOTrackID TrackID);\n\n/*FLAGS for TRUN : specify what is written in the SampleTable of TRUN*/\nenum\n{\n\t/*common to both trun and ctrn*/\n\tGF_ISOM_TRUN_DATA_OFFSET\t= 0x01,\n\t/*trun flags*/\n\tGF_ISOM_TRUN_FIRST_FLAG\t\t= 0x04,\n\tGF_ISOM_TRUN_DURATION\t\t= 0x100,\n\tGF_ISOM_TRUN_SIZE\t\t\t= 0x200,\n\tGF_ISOM_TRUN_FLAGS\t\t\t= 0x400,\n\tGF_ISOM_TRUN_CTS_OFFSET\t\t= 0x800,\n\n#ifdef GF_ENABLE_CTRN\n\t/*compact trun flags (not all of them, field indices are stored in trun box)*/\n\tGF_ISOM_CTRN_FIRST_SAMPLE = 1<<1, //0x00000002\n\tGF_ISOM_CTRN_DATAOFFSET_16 = 1<<2, //0x00000004\n\tGF_ISOM_CTRN_CTSO_MULTIPLIER = 1<<3, //0x00000008\n\n\tGF_ISOM_CTRN_INHERIT_CTSO = 1<<4,\n\tGF_ISOM_CTRN_INHERIT_FLAGS = 1<<5,\n\tGF_ISOM_CTRN_INHERIT_SIZE = 1<<6,\n\tGF_ISOM_CTRN_INHERIT_DUR = 1<<7\n#endif\n\n};\n\ntypedef struct\n{\n\tu32 Duration;\n\tu32 size;\n\tu32 flags;\n\ts32 CTS_Offset;\n\n\t/*internal*/\n\tu32 SAP_type;\n\tu64 dts;\n\tu32 nb_pack;\n} GF_TrunEntry;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 sample_count;\n\t/*the following are optional fields */\n\t/* unsigned for version 0 */\n\ts32 data_offset;\n\n\tu32 nb_samples, sample_alloc;\n\t/*can be empty*/\n\tGF_TrunEntry *samples;\n\n\t/*only for trun, ignored for ctrn*/\n\tu32 first_sample_flags;\n\n\t/*in write mode with data caching*/\n\tGF_BitStream *cache;\n\n#ifdef GF_ENABLE_CTRN\n\t/*the remaining is internal for compact trun*/\n\t/*use compact mode*/\n\tBool use_ctrn;\n\t/*we store the ctrn box flags here rather than in flags and swap when writing/dumping. This avoids overwriting the flags\n\tset by the fragment writer*/\n\tu32 ctrn_flags;\n\t/*set to default sample duration when writing, parsed from box otherwise. If 0, not used*/\n\tu32 ctso_multiplier;\n\tu8 ctrn_first_dur, ctrn_first_size, ctrn_first_sample_flags, ctrn_first_ctts;\n\tu8 ctrn_dur, ctrn_size, ctrn_sample_flags, ctrn_ctts;\n\t/*use inherit in write mode- in the current version, only size will be set and all other fields inherited*/\n\tBool use_inherit;\n#endif\n\n\tu32 interleave_id;\n\tu32 first_sample_idx;\n\tu32 *sample_order;\n} GF_TrackFragmentRunBox;\n\n#ifdef GF_ENABLE_CTRN\nu32 gf_isom_ctrn_field_size_bits(u32 field_idx);\n#endif\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\n/*RTP Hint Track Sample Entry*/\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\n\tu16 HintTrackVersion;\n\tu16 LastCompatibleVersion;\n\tu32 MaxPacketSize;\n//\tGF_List *HintDataTable;\n\t/*this is where we store the current RTP sample in read/write mode*/\n\tstruct __tag_hint_sample *hint_sample;\n\t/*current hint sample in read mode, 1-based (0 is reset)*/\n\tu32 cur_sample;\n\tu32 pck_sn, ts_offset, ssrc;\n\tGF_TrackReferenceTypeBox *hint_ref;\n\n\t//for FEC\n\tu16 partition_entry_ID, FEC_overhead;\n} GF_HintSampleEntryBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 subType;\n\tchar *sdpText;\n} GF_RTPBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tchar *sdpText;\n} GF_SDPBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\ts32 timeOffset;\n} GF_RTPOBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\t/*contains GF_SDPBox if in track, GF_RTPBox if in movie*/\n\tGF_Box *SDP;\n} GF_HintTrackInfoBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu8 reserved;\n\tu8 preferred;\n\tu8 required;\n} GF_RelyHintBox;\n\n/***********************************************************\n\t\t\tdata entry tables for RTP\n***********************************************************/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 timeScale;\n} GF_TSHintEntryBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 TimeOffset;\n} GF_TimeOffHintEntryBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 SeqOffset;\n} GF_SeqOffHintEntryBox;\n\n\n\n/***********************************************************\n\t\t\thint track information boxes for RTP\n***********************************************************/\n\n/*Total number of bytes that will be sent, including 12-byte RTP headers, but not including any network headers*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu64 nbBytes;\n} GF_TRPYBox;\n\n/*32-bits version of trpy used in Darwin*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 nbBytes;\n} GF_TOTLBox;\n\n/*Total number of network packets that will be sent*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu64 nbPackets;\n} GF_NUMPBox;\n\n/*32-bits version of nump used in Darwin*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 nbPackets;\n} GF_NPCKBox;\n\n\n/*Total number of bytes that will be sent, not including 12-byte RTP headers*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu64 nbBytes;\n} GF_NTYLBox;\n\n/*32-bits version of tpyl used in Darwin*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 nbBytes;\n} GF_TPAYBox;\n\n/*Maximum data rate in bits per second.*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 granularity;\n\tu32 maxDataRate;\n} GF_MAXRBox;\n\n\n/*Total number of bytes from the media track to be sent*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu64 nbBytes;\n} GF_DMEDBox;\n\n/*Number of bytes of immediate data to be sent*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu64 nbBytes;\n} GF_DIMMBox;\n\n\n/*Number of bytes of repeated data to be sent*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu64 nbBytes;\n} GF_DREPBox;\n\n/*Smallest relative transmission time, in milliseconds. signed integer for smoothing*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\ts32 minTime;\n} GF_TMINBox;\n\n/*Largest relative transmission time, in milliseconds.*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\ts32 maxTime;\n} GF_TMAXBox;\n\n/*Largest packet, in bytes, including 12-byte RTP header*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 maxSize;\n} GF_PMAXBox;\n\n/*Longest packet duration, in milliseconds*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 maxDur;\n} GF_DMAXBox;\n\n/*32-bit payload type number, followed by rtpmap payload string */\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 payloadCode;\n\tchar *payloadString;\n} GF_PAYTBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tchar *string;\n} GF_NameBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n} GF_HintInfoBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu8 timestamp_sync;\n} GF_TimeStampSynchronyBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 ssrc;\n} GF_ReceivedSsrcBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 encryption_algorithm_rtp;\n\tu32 encryption_algorithm_rtcp;\n\tu32 integrity_algorithm_rtp;\n\tu32 integrity_algorithm_rtcp;\n\n\tGF_SchemeTypeBox *scheme_type;\n\tGF_SchemeInformationBox *info;\n} GF_SRTPProcessBox;\n\n/*Apple extension*/\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 reserved;\n\tu8 *data;\n\tu32 dataSize;\n\tBool qt_style;\n} GF_DataBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_DataBox *data;\n} GF_ListItemBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n} GF_ItemListBox;\n\n/*DECE*/\ntypedef struct\n{\n\tu8 pic_type;\n\tu8 dependency_level;\n} GF_TrickPlayBoxEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 entry_count;\n\tGF_TrickPlayBoxEntry *entries;\n} GF_TrickPlayBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu8  baseLocation[256];\n\tu8 basePurlLocation[256];\n} GF_BaseLocationBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 profile_version;\n\tchar *APID;\n} GF_AssetInformationBox;\n\n/*OMA (P)DCF extensions*/\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu8 EncryptionMethod;\n\tu8 PaddingScheme;\n\tu64 PlaintextLength;\n\tchar *ContentID;\n\tchar *RightsIssuerURL;\n\tchar *TextualHeaders;\n\tu32 TextualHeadersLen;\n} GF_OMADRMCommonHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu8 GKEncryptionMethod;\n\tchar *GroupID;\n\tu16 GKLength;\n\tchar *GroupKey;\n} GF_OMADRMGroupIDBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n} GF_OMADRMMutableInformationBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tchar TransactionID[16];\n} GF_OMADRMTransactionTrackingBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu8 *oma_ro;\n\tu32 oma_ro_size;\n} GF_OMADRMRightsObjectBox;\n\n/*identical*/\ntypedef struct __isma_format_box GF_OMADRMAUFormatBox;\n\ntypedef struct __oma_kms_box\n{\n\tGF_ISOM_FULL_BOX\n\tGF_OMADRMCommonHeaderBox *hdr;\n\tGF_OMADRMAUFormatBox *fmt;\n} GF_OMADRMKMSBox;\n\ntypedef struct\n{\n\tBool reference_type;\n\tu32 reference_size;\n\tu32 subsegment_duration;\n\tBool starts_with_SAP;\n\tu32 SAP_type;\n\tu32 SAP_delta_time;\n} GF_SIDXReference;\n\ntypedef struct __sidx_box\n{\n\tGF_ISOM_FULL_BOX\n\n\tu32 reference_ID;\n\tu32 timescale;\n\tu64 earliest_presentation_time;\n\tu64 first_offset;\n\tu32 nb_refs;\n\tGF_SIDXReference *refs;\n\t//for trace only\n\ts32 compressed_diff;\n} GF_SegmentIndexBox;\n\nGF_Err gf_isom_set_fragment_template(GF_ISOFile *movie, u8 *tpl_data, u32 tpl_size, Bool *has_tfdt, GF_SegmentIndexBox **out_sidx);\n\ntypedef struct\n{\n\tu8 level;\n\tu32 range_size;\n} GF_SubsegmentRangeInfo;\n\ntypedef struct\n{\n\tu32 range_count;\n\tGF_SubsegmentRangeInfo *ranges;\n} GF_SubsegmentInfo;\n\ntypedef struct __ssix_box\n{\n\tGF_ISOM_FULL_BOX\n\n\tu32 subsegment_count, subsegment_alloc;\n\tGF_SubsegmentInfo *subsegments;\n\t//for trace only\n\ts32 compressed_diff;\n} GF_SubsegmentIndexBox;\n\ntypedef struct\n{\n\tGF_ISOTrackID track_id;\n\tBool padding_flag;\n\tu8 type;\n\tu32 grouping_type;\n\tu32 grouping_type_parameter;\n\tGF_ISOTrackID sub_track_id;\n} GF_LevelAssignment;\n\ntypedef struct __leva_box\n{\n\tGF_ISOM_FULL_BOX\n\n\tu32 level_count;\n\tGF_LevelAssignment *levels;\n} GF_LevelAssignmentBox;\n\ntypedef struct __pcrInfo_box\n{\n\tGF_ISOM_BOX\n\tu32\tsubsegment_count;\n\tu64 *pcr_values;\n} GF_PcrInfoBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tchar *scheme_id_uri;\n\tchar *value;\n\tu32 timescale;\n\tu64 presentation_time_delta;\n\tu32 event_duration;\n\tu32 event_id;\n\tu8 *message_data;\n\tu32 message_data_size;\n} GF_EventMessageBox;\n\n\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n\n/*Adobe specific boxes*/\ntypedef struct\n{\n\tu64 time;\n\tu64 offset;\n} GF_AfraEntry;\n\ntypedef struct\n{\n\tu64 time;\n\tu32 segment;\n\tu32 fragment;\n\tu64 afra_offset;\n\tu64 offset_from_afra;\n} GF_GlobalAfraEntry;\n\ntypedef struct __adobe_frag_random_access_box\n{\n\tGF_ISOM_FULL_BOX\n\tBool long_ids;\n\tBool long_offsets;\n\tBool global_entries;\n\tu8 reserved;\n\tu32 time_scale;\n\tu32 entry_count;\n\tGF_List *local_access_entries;\n\tu32 global_entry_count;\n\tGF_List *global_access_entries;\n} GF_AdobeFragRandomAccessBox;\n\ntypedef struct __adobe_bootstrap_info_box\n{\n\tGF_ISOM_FULL_BOX\n\tu32 bootstrapinfo_version;\n\tu8 profile;\n\tBool live;\n\tBool update;\n\tu8 reserved;\n\tu32 time_scale;\n\tu64 current_media_time;\n\tu64 smpte_time_code_offset;\n\tchar *movie_identifier;\n\tu8 server_entry_count;\n\tGF_List *server_entry_table;\n\tu8 quality_entry_count;\n\tGF_List *quality_entry_table;\n\tchar *drm_data;\n\tchar *meta_data;\n\t//entries in these two lists are NOT registered with the box child_boxes because of the in-between 8 bits !!\n\tu8 segment_run_table_count;\n\tGF_List *segment_run_table_entries;\n\tu8 fragment_run_table_count;\n\tGF_List *fragment_run_table_entries;\n} GF_AdobeBootstrapInfoBox;\n\ntypedef struct\n{\n\tu32 first_segment;\n\tu32 fragment_per_segment;\n} GF_AdobeSegmentRunEntry;\n\ntypedef struct __adobe_segment_run_table_box\n{\n\tGF_ISOM_FULL_BOX\n\tu8 quality_entry_count;\n\tGF_List *quality_segment_url_modifiers;\n\tu32 segment_run_entry_count;\n\tGF_List *segment_run_entry_table;\n} GF_AdobeSegmentRunTableBox;\n\ntypedef struct\n{\n\tu32 first_fragment;\n\tu64 first_fragment_timestamp;\n\tu32 fragment_duration;\n\tu8 discontinuity_indicator;\n} GF_AdobeFragmentRunEntry;\n\ntypedef struct __adobe_fragment_run_table_box\n{\n\tGF_ISOM_FULL_BOX\n\tu32 timescale;\n\tu8 quality_entry_count;\n\tGF_List *quality_segment_url_modifiers;\n\tu32 fragment_run_entry_count;\n\tGF_List *fragment_run_entry_table;\n} GF_AdobeFragmentRunTableBox;\n\n#endif /*GPAC_DISABLE_ISOM_ADOBE*/\n\n\n/***********************************************************\n\t\t\tSample Groups\n***********************************************************/\ntypedef struct\n{\n\tu32 sample_count;\n\tu32 group_description_index;\n} GF_SampleGroupEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 grouping_type;\n\tu32 grouping_type_parameter;\n\n\tu32 entry_count;\n\tGF_SampleGroupEntry *sample_entries;\n\n} GF_SampleGroupBox;\n\ntypedef struct\n{\n\tu32 length;\n\tu32 sample_count;\n\tu32 *sample_group_description_indices;\n} GF_CompactSampleGroupPattern;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 grouping_type;\n\tu32 grouping_type_parameter;\n\n\tu32 pattern_count;\n\tGF_CompactSampleGroupPattern *patterns;\n} GF_CompactSampleGroupBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 grouping_type;\n\tu32 default_length;\n\n\tu32 default_description_index;\n\tGF_List *group_descriptions;\n} GF_SampleGroupDescriptionBox;\n\n/*default entry */\ntypedef struct\n{\n\tu32 length;\n\tu8 *data;\n} GF_DefaultSampleGroupDescriptionEntry;\n\n/*VisualRandomAccessEntry - 'rap ' type*/\ntypedef struct\n{\n\tu8 num_leading_samples_known;\n\tu8 num_leading_samples;\n} GF_VisualRandomAccessEntry;\n\n/*RollRecoveryEntry - 'roll' and prol type*/\ntypedef struct\n{\n\ts16 roll_distance;\n} GF_RollRecoveryEntry;\n\n/*TemporalLevelEntry - 'tele' type*/\ntypedef struct\n{\n\tBool level_independently_decodable;\n} GF_TemporalLevelEntry;\n\n/*SAPEntry - 'sap ' type*/\ntypedef struct\n{\n\tBool dependent_flag;\n\tu8 SAP_type;\n} GF_SAPEntry;\n\n/*SAPEntry - 'sync' type*/\ntypedef struct\n{\n\tu8 NALU_type;\n} GF_SYNCEntry;\n\n/*Operating Points Information - 'oinf' type*/\ntypedef struct\n{\n\tu16 scalability_mask;\n\tGF_List* profile_tier_levels;\n\tGF_List* operating_points;\n\tGF_List* dependency_layers;\n} GF_OperatingPointsInformation;\n\nGF_OperatingPointsInformation *gf_isom_oinf_new_entry();\nvoid gf_isom_oinf_del_entry(void *entry);\nGF_Err gf_isom_oinf_read_entry(void *entry, GF_BitStream *bs);\nGF_Err gf_isom_oinf_write_entry(void *entry, GF_BitStream *bs);\nu32 gf_isom_oinf_size_entry(void *entry);\nBool gf_isom_get_oinf_info(GF_ISOFile *file, u32 trackNumber, GF_OperatingPointsInformation **ptr);\n\n\n/*Operating Points Information - 'oinf' type*/\ntypedef struct\n{\n\tu8 layer_id;\n\tu8 min_TemporalId;\n\tu8 max_TemporalId;\n\tu8 sub_layer_presence_flags;\n} LHVCLayerInfoItem;\n\ntypedef struct\n{\n\tGF_List* num_layers_in_track;\n} GF_LHVCLayerInformation;\n\nGF_LHVCLayerInformation *gf_isom_linf_new_entry();\nvoid gf_isom_linf_del_entry(void *entry);\nGF_Err gf_isom_linf_read_entry(void *entry, GF_BitStream *bs);\nGF_Err gf_isom_linf_write_entry(void *entry, GF_BitStream *bs);\nu32 gf_isom_linf_size_entry(void *entry);\nBool gf_isom_get_linf_info(GF_ISOFile *file, u32 trackNumber, GF_LHVCLayerInformation **ptr);\n\n\n#define MAX_LHEVC_LAYERS\t64\n\ntypedef struct\n{\n\tu8 general_profile_space, general_tier_flag, general_profile_idc, general_level_idc;\n\tu32 general_profile_compatibility_flags;\n\tu64 general_constraint_indicator_flags;\n} LHEVC_ProfileTierLevel;\n\ntypedef struct\n{\n\tu8 ptl_idx;\n\tu8 layer_id;\n\tBool is_outputlayer, is_alternate_outputlayer;\n} LHEVC_LayerInfo;\n\ntypedef struct\n{\n\tu16 output_layer_set_idx;\n\tu8 max_temporal_id;\n\tu8 layer_count;\n\tLHEVC_LayerInfo layers_info[MAX_LHEVC_LAYERS];\n\tu16 minPicWidth, minPicHeight, maxPicWidth, maxPicHeight;\n\tu8 maxChromaFormat, maxBitDepth;\n\tBool frame_rate_info_flag, bit_rate_info_flag;\n\tu16 avgFrameRate;\n\tu8 constantFrameRate;\n\tu32 maxBitRate, avgBitRate;\n} LHEVC_OperatingPoint;\n\n\ntypedef struct\n{\n\tu8 dependent_layerID;\n\tu8 num_layers_dependent_on;\n\tu8 dependent_on_layerID[MAX_LHEVC_LAYERS];\n\tu8 dimension_identifier[16];\n} LHEVC_DependentLayer;\n\n\n\n/*\n\t\tCENC stuff\n*/\n\n/*CENCSampleEncryptionGroupEntry - 'seig' type*/\ntypedef struct\n{\n\tu8 crypt_byte_block, skip_byte_block;\n\tu8 IsProtected;\n\tu8 *key_info;\n\tu32 key_info_size;\n} GF_CENCSampleEncryptionGroupEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\n\tbin128 SystemID;\n\tu32 KID_count;\n\tbin128 *KIDs;\n\tu32 private_data_size;\n\tu8 *private_data;\n} GF_ProtectionSystemHeaderBox;\n\ntypedef struct __cenc_tenc_box\n{\n\tGF_ISOM_FULL_BOX\n\n\tu8 crypt_byte_block, skip_byte_block;\n\tu8 isProtected;\n\n\t//single key\n\tu8 key_info[37];\n} GF_TrackEncryptionBox;\n\ntypedef struct __piff_tenc_box\n{\n\tGF_ISOM_UUID_BOX\n\t/*u8 version; field in included in base box version */\n\tu32 flags;\n\n\tu32 AlgorithmID;\n\tu8 key_info[20];\n} GF_PIFFTrackEncryptionBox;\n\ntypedef struct\n{\n\tGF_ISOM_UUID_BOX\n\t/*u8 version; field in included in base box version */\n\tu32 flags;\n\n\tbin128 SystemID;\n\tu32 private_data_size;\n\tu8 *private_data;\n} GF_PIFFProtectionSystemHeaderBox;\n\n\ntypedef struct __sample_encryption_box\n{\n\tGF_ISOM_UUID_BOX\n\t/*u8 version; field in included in base box version */\n\tu32 flags;\n\n\t//0: regular senc, 1: PIFF PSEC, 2: MS senc with version 1 (not compatible with ISOBMFF senc v1)\n\tu32 piff_type;\n\n\tGF_List *samp_aux_info; /*GF_CENCSampleAuxInfo*/\n\tu64 bs_offset;\n\tBool load_needed;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t/*pointer to container traf*/\n\tGF_TrackFragmentBox *traf;\n#endif\n\t/*pointer to associated saio*/\n\tGF_SampleAuxiliaryInfoSizeBox *cenc_saiz;\n\tGF_SampleAuxiliaryInfoOffsetBox *cenc_saio;\n\n\n\tu32 AlgorithmID;\n\tu8 IV_size;\n\tbin128 KID;\n\n} GF_SampleEncryptionBox;\n\ntypedef struct __traf_mss_timeext_box\n{\n\tGF_ISOM_UUID_BOX\n\t/*u8 version; field in included in base box version */\n\tu32 flags;\n\n\tu64 absolute_time_in_track_timescale;\n\tu64 fragment_duration_in_track_timescale;\n} GF_MSSTimeExtBox;\n\ntypedef struct\n{\n\tu64 absolute_time_in_track_timescale;\n\tu64 fragment_duration_in_track_timescale;\n} GF_MSSTimeEntry;\n\ntypedef struct __traf_mss_timeref_box\n{\n\tGF_ISOM_UUID_BOX\n\t/*u8 version; field in included in base box version */\n\tu32 flags;\n\n\tu32 frags_count;\n\tGF_MSSTimeEntry *frags;\n\n} GF_MSSTimeRefBox;\n\n\n\nGF_SampleEncryptionBox *gf_isom_create_piff_psec_box(u8 version, u32 flags, u32 AlgorithmID, u8 IV_size, bin128 KID);\nGF_SampleEncryptionBox * gf_isom_create_samp_enc_box(u8 version, u32 flags);\n\nvoid gf_isom_cenc_get_default_info_internal(GF_TrackBox *trak, u32 sampleDescriptionIndex, u32 *container_type, Bool *default_IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size);\n\n\nGF_Err gf_isom_get_sample_cenc_info_internal(GF_TrackBox *trak,\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_TrackFragmentBox *traf,\n#else\n\tvoid *traf,\n#endif\n\tGF_SampleEncryptionBox *senc, u32 sample_number, Bool *IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size);\n\n\nGF_Err senc_Parse(GF_BitStream *bs, GF_TrackBox *trak,\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_TrackFragmentBox *traf,\n#else\n\tvoid *traf,\n#endif\n\tGF_SampleEncryptionBox *ptr);\n\n\n/*\n\tBoxes for Adobe's protection scheme\n*/\ntypedef struct __adobe_enc_info_box\n{\n\tGF_ISOM_FULL_BOX\n\tchar *enc_algo; /*spec: The encryption algorithm shall be 'AES-CBC'*/\n\tu8 key_length;\n} GF_AdobeEncryptionInfoBox;\n\ntypedef struct __adobe_flash_access_params_box\n{\n\tGF_ISOM_BOX\n\tu8 *metadata; /*base-64 encoded metadata used by the DRM client to retrieve decrypted key*/\n} GF_AdobeFlashAccessParamsBox;\n\ntypedef struct __adobe_key_info_box\n{\n\tGF_ISOM_FULL_BOX\n\tGF_AdobeFlashAccessParamsBox * params; /*spec: APSParamsBox will no longer be produced by conformaing applications*/\n} GF_AdobeKeyInfoBox;\n\ntypedef struct __adobe_std_enc_params_box\n{\n\tGF_ISOM_FULL_BOX\n\tGF_AdobeEncryptionInfoBox *enc_info;\n\tGF_AdobeKeyInfoBox *key_info;\n} GF_AdobeStdEncryptionParamsBox;\n\ntypedef struct __adobe_drm_header_box\n{\n\tGF_ISOM_FULL_BOX\n\tGF_AdobeStdEncryptionParamsBox *std_enc_params;\n\t//AdobeSignatureBox *signature; /*AdobeSignatureBox is not described*/\n} GF_AdobeDRMHeaderBox;\n\n\ntypedef struct __adobe_drm_au_format_box\n{\n\tGF_ISOM_FULL_BOX\n\tu8 selective_enc;\n\tu8 IV_length;\n} GF_AdobeDRMAUFormatBox;\n\ntypedef struct __adobe_drm_key_management_system_box\n{\n\tGF_ISOM_FULL_BOX\n\tGF_AdobeDRMHeaderBox *header;\n\tGF_AdobeDRMAUFormatBox *au_format;\n} GF_AdobeDRMKeyManagementSystemBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_ISOTrackID refTrackID;\n\tu64 ntp, timestamp;\n} GF_ProducerReferenceTimeBox;\n\n/* Image File Format Structures */\ntypedef struct {\n\tGF_ISOM_FULL_BOX\n\tu32 image_width;\n\tu32 image_height;\n} GF_ImageSpatialExtentsPropertyBox;\n\ntypedef struct {\n\tGF_ISOM_FULL_BOX\n\tu8 num_channels;\n\tu8 *bits_per_channel;\n} GF_PixelInformationPropertyBox;\n\ntypedef struct {\n\tGF_ISOM_FULL_BOX\n\tu32 horizontal_offset;\n\tu32 vertical_offset;\n} GF_RelativeLocationPropertyBox;\n\ntypedef struct {\n\tGF_ISOM_BOX\n\tu8 angle;\n} GF_ImageRotationBox;\n\ntypedef struct {\n\tGF_ISOM_BOX\n\tu8 axis;\n} GF_ImageMirrorBox;\n\ntypedef struct\n{\n\tu8 essential;\n\tu32 index;\n} GF_ItemPropertyAssociationSlot;\n\ntypedef struct {\n\tu32 item_id;\n\tGF_ItemPropertyAssociationSlot *associations;\n\tu32 nb_associations;\n} GF_ItemPropertyAssociationEntry;\n\ntypedef struct __item_association_box {\n\tGF_ISOM_FULL_BOX\n\tGF_List *entries;\n} GF_ItemPropertyAssociationBox;\n\n\ntypedef struct {\n\tGF_ISOM_FULL_BOX\n\tchar *aux_urn;\n\tu32 data_size;\n\tu8 *data;\n} GF_AuxiliaryTypePropertyBox;\n\ntypedef struct {\n\tGF_ISOM_FULL_BOX\n\tu8 skip_byte_block, crypt_byte_block;\n\tu8 *key_info;\n\tu32 key_info_size;\n} GF_ItemEncryptionPropertyBox;\n\n\ntypedef struct {\n\tGF_ISOM_FULL_BOX\n\tu32 aux_info_type;\n\tu32 aux_info_parameter;\n} GF_AuxiliaryInfoPropertyBox;\n\ntypedef struct {\n\tGF_ISOM_FULL_BOX\n\n\tGF_OperatingPointsInformation *oinf;\n} GF_OINFPropertyBox;\n\n\ntypedef struct {\n\tGF_ISOM_FULL_BOX\n\n\tu16 target_ols_index;\n} GF_TargetOLSPropertyBox;\n\n/*flute hint track boxes*/\ntypedef struct\n{\n\tu16 block_count;\n\tu32 block_size;\n} FilePartitionEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 itemID;\n\tu16 packet_payload_size;\n\tu8 FEC_encoding_ID;\n\tu16 FEC_instance_ID;\n\tu16 max_source_block_length;\n\tu16 encoding_symbol_length;\n\tu16 max_number_of_encoding_symbols;\n\tchar *scheme_specific_info;\n\tu32 nb_entries;\n\tFilePartitionEntry *entries;\n} FilePartitionBox;\n\ntypedef struct\n{\n\tu32 item_id;\n\tu32 symbol_count;\n} FECReservoirEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 nb_entries;\n\tFECReservoirEntry *entries;\n} FECReservoirBox;\n\ntypedef struct\n{\n\tu32 nb_groups;\n\tu32 *group_ids;\n\tu32 nb_channels;\n\tu32 *channels;\n} SessionGroupEntry;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu16 num_session_groups;\n\tSessionGroupEntry *session_groups;\n} FDSessionGroupBox;\n\ntypedef struct\n{\n\tu32 group_id;\n\tchar *name;\n} GroupIdNameEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu16 nb_entries;\n\tGroupIdNameEntry *entries;\n} GroupIdToNameBox;\n\n\ntypedef struct\n{\n\tu32 item_id;\n\tu32 symbol_count;\n} FileReservoirEntry;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 nb_entries;\n\tFileReservoirEntry *entries;\n} FileReservoirBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tFilePartitionBox *blocks_and_symbols;\n\tFECReservoirBox *FEC_symbol_locations;\n\tFileReservoirBox *File_symbol_locations;\n} FDPartitionEntryBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *partition_entries;\n\tFDSessionGroupBox *session_info;\n\tGroupIdToNameBox *group_id_to_name;\n} FDItemInformationBox;\n\n\n\ntypedef struct\n{\n\tchar *name;\n\tu32 flags;\n\tu16 prop_type;\n\n\tu32 prop_size;\n\tu8 *prop_value; //most of the time, utf16 with trailing \\0\\0\n} GF_XtraTag;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\n\tGF_List *tags;\n} GF_XtraBox;\n\n\n/*\n\t\tData Map (media storage) stuff\n*/\n\n/*regular file IO*/\n#define GF_ISOM_DATA_FILE         0x01\n/*External file object. Needs implementation*/\n#define GF_ISOM_DATA_FILE_EXTERN  0x03\n/*regular memory IO*/\n#define GF_ISOM_DATA_MEM          0x04\n\n/*Data Map modes*/\nenum\n{\n\t/*read mode*/\n\tGF_ISOM_DATA_MAP_READ = 1,\n\t/*write mode*/\n\tGF_ISOM_DATA_MAP_WRITE = 2,\n\t/*the following modes are just ways of signaling extended functionalities\n\tedit mode, to make sure the file is here, set to GF_ISOM_DATA_MAP_READ afterwards*/\n\tGF_ISOM_DATA_MAP_EDIT = 3,\n\t/*read-only access to the movie file: we create a file mapping object\n\tmode is set to GF_ISOM_DATA_MAP_READ afterwards*/\n\tGF_ISOM_DATA_MAP_READ_ONLY = 4,\n\t/*write-only access at the end of the movie - only used for movie fragments concatenation*/\n\tGF_ISOM_DATA_MAP_CAT = 5,\n};\n\n/*this is the DataHandler structure each data handler has its own bitstream*/\n#define GF_ISOM_BASE_DATA_HANDLER\t\\\n\tu8\ttype;\t\t\\\n\tu64\tcurPos;\t\t\\\n\tu8\tmode;\t\t\\\n\tGF_BitStream *bs;\\\n\tu64 last_read_offset;\\\n\tchar *szName;\n\ntypedef struct __tag_data_map\n{\n\tGF_ISOM_BASE_DATA_HANDLER\n} GF_DataMap;\n\ntypedef struct\n{\n\tGF_ISOM_BASE_DATA_HANDLER\n\tFILE *stream;\n\tBool is_stdout;\n\tBool last_acces_was_read;\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tchar *temp_file;\n#endif\n\tGF_Blob *blob;\n} GF_FileDataMap;\n\n/*file mapping handler. used if supported, only on read mode for complete files  (not in file download)*/\ntypedef struct\n{\n\tGF_ISOM_BASE_DATA_HANDLER\n\tchar *name;\n\tu64 file_size;\n\tu8 *byte_map;\n\tu64 byte_pos;\n} GF_FileMappingDataMap;\n\nGF_Err gf_isom_datamap_new(const char *location, const char *parentPath, u8 mode, GF_DataMap **outDataMap);\nvoid gf_isom_datamap_del(GF_DataMap *ptr);\nGF_Err gf_isom_datamap_open(GF_MediaBox *minf, u32 dataRefIndex, u8 Edit);\nvoid gf_isom_datamap_close(GF_MediaInformationBox *minf);\nu32 gf_isom_datamap_get_data(GF_DataMap *map, u8 *buffer, u32 bufferLength, u64 Offset);\n\n/*File-based data map*/\nGF_DataMap *gf_isom_fdm_new(const char *sPath, u8 mode);\nvoid gf_isom_fdm_del(GF_FileDataMap *ptr);\nu32 gf_isom_fdm_get_data(GF_FileDataMap *ptr, u8 *buffer, u32 bufferLength, u64 fileOffset);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_DataMap *gf_isom_fdm_new_temp(const char *sTempPath);\n#endif\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nu64 gf_isom_datamap_get_offset(GF_DataMap *map);\nGF_Err gf_isom_datamap_add_data(GF_DataMap *ptr, u8 *data, u32 dataSize);\n#endif\n\nvoid gf_isom_datamap_flush(GF_DataMap *map);\n\n/*\n\t\tMovie stuff\n*/\n\n\n/*time def for MP4/QT/MJ2K files*/\n#define GF_ISOM_MAC_TIME_OFFSET 2082844800\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n#define GF_ISOM_FORMAT_FRAG_FLAGS(pad, sync, deg) ( ( (pad) << 17) | ( ( !(sync) ) << 16) | (deg) );\n#define GF_ISOM_GET_FRAG_PAD(flag) ( (flag) >> 17) & 0x7\n#define GF_ISOM_GET_FRAG_SYNC(flag) ( ! ( ( (flag) >> 16) & 0x1))\n#define GF_ISOM_GET_FRAG_DEG(flag)\t(flag) & 0x7FFF\n\n#define GF_ISOM_GET_FRAG_LEAD(flag) ( (flag) >> 26) & 0x3\n#define GF_ISOM_GET_FRAG_DEPENDS(flag) ( (flag) >> 24) & 0x3\n#define GF_ISOM_GET_FRAG_DEPENDED(flag) ( (flag) >> 22) & 0x3\n#define GF_ISOM_GET_FRAG_REDUNDANT(flag) ( (flag) >> 20) & 0x3\n\n#define GF_ISOM_GET_FRAG_DEPEND_FLAGS(lead, depends, depended, redundant) ( (lead<<26) | (depends<<24) | (depended<<22) | (redundant<<20) )\n#define GF_ISOM_RESET_FRAG_DEPEND_FLAGS(flags) flags = flags & 0xFFFFF\n\nGF_TrackExtendsBox *GetTrex(GF_MovieBox *moov, GF_ISOTrackID TrackID);\n#endif\n\nenum\n{\n\tGF_ISOM_FRAG_WRITE_READY\t=\t0x01,\n\tGF_ISOM_FRAG_READ_DEBUG\t\t=\t0x02,\n};\n\n\n/*this is our movie object*/\nstruct __tag_isom {\n\t/*the last fatal error*/\n\tGF_Err LastError;\n\t/*the original filename*/\n\tchar *fileName;\n\t/*the original file in read/edit, and also used in fragments mode\n\tonce the first moov has been written\n\tNota: this API doesn't allow fragments BEFORE the MOOV in order\n\tto make easily parsable files (note there could be some data (mdat) before\n\tthe moov*/\n\tGF_DataMap *movieFileMap;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t/*the final file name*/\n\tchar *finalName;\n\t/*the file where we store edited samples (for READ_WRITE and WRITE mode only)*/\n\tGF_DataMap *editFileMap;\n\t/*the interleaving time for dummy mode (in movie TimeScale)*/\n\tu32 interleavingTime;\n\tGF_ISOTrackID last_created_track_id;\n#endif\n\n\tGF_ISOOpenMode openMode;\n\tu8 storageMode;\n\t/*if true 3GPP text streams are read as MPEG-4 StreamingText*/\n\tu8 convert_streaming_text;\n\tu8 is_jp2;\n\tu8 force_co64;\n\tu64 next_flush_chunk_time;\n\tBool keep_utc;\n\t/*main boxes for fast access*/\n\t/*moov*/\n\tGF_MovieBox *moov;\n\t/*our MDAT box (one and only one when we store the file)*/\n\tGF_MediaDataBox *mdat;\n\t/*file brand (since v2, NULL means mp4 v1)*/\n\tGF_FileTypeBox *brand;\n\t/*original file type box if any*/\n\tGF_Box *otyp;\n\n\t/*progressive download info*/\n\tGF_ProgressiveDownloadBox *pdin;\n\t/*meta box if any*/\n\tGF_MetaBox *meta;\n\n\ts64 read_byte_offset;\n\tu64 bytes_removed;\n\n\tBool disable_odf_translate;\n\n\tGF_ISOCompressMode compress_mode;\n\tu32 compress_flags;\n\n\tvoid (*progress_cbk)(void *udta, u64 nb_done, u64 nb_total);\n\tvoid *progress_cbk_udta;\n\n\tu32 FragmentsFlags;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 NextMoofNumber;\n\t/*active fragment*/\n\tGF_MovieFragmentBox *moof;\n\t/*in WRITE mode, this is the current MDAT where data is written*/\n\t/*in READ mode this is the last valid file position before a gf_isom_box_read failed*/\n\tu64 current_top_box_start;\n\tu64 segment_start;\n\n\tGF_List *moof_list;\n\tBool use_segments, moof_first, append_segment, styp_written, force_moof_base_offset;\n\n\t/*used when building single-indexed self initializing media segments*/\n\tGF_SegmentIndexBox *root_sidx;\n\tu64 root_sidx_offset;\n\tu32 root_sidx_index;\n\tBool dyn_root_sidx;\n\tGF_SubsegmentIndexBox *root_ssix;\n\n\tBool is_index_segment;\n\n\tGF_BitStream *segment_bs;\n\t/* 0: no moof found yet, 1: 1 moof found, 2: next moof found */\n\tBool single_moof_mode;\n\tu32 single_moof_state;\n\n\tBool sample_groups_in_traf;\n\tBool force_sidx_v1;\n\n\t/* optional mfra box used in write mode */\n\tGF_MovieFragmentRandomAccessBox *mfra;\n\n\tBool store_traf_map;\n\tBool signal_frag_bounds;\n\tu64 sidx_start_offset, sidx_end_offset;\n\tu64 styp_start_offset;\n\tu64 mdat_end_offset;\n\tGF_Box *seg_ssix, *seg_styp;\n\n\tu32 sidx_pts_store_alloc, sidx_pts_store_count;\n\tu64 *sidx_pts_store, *sidx_pts_next_store;\n\n\tGF_SegmentIndexBox *main_sidx;\n\tu64 main_sidx_end_pos;\n\n#endif\n\tGF_ProducerReferenceTimeBox *last_producer_ref_time;\n\n\t/*this contains ALL the root boxes excepts fragments*/\n\tGF_List *TopBoxes;\n\n\t/*default track for sync of MPEG4 streams - this is the first accessed stream without OCR info - only set in READ mode*/\n\ts32 es_id_default_sync;\n\n\tBool is_smooth;\n\n\tGF_Err (*on_block_out)(void *usr_data, u8 *block, u32 block_size);\n\tGF_Err (*on_block_patch)(void *usr_data, u8 *block, u32 block_size, u64 block_offset, Bool is_insert);\n\tvoid *on_block_out_usr_data;\n\tu32 on_block_out_block_size;\n\n\t//in block disptach mode we don't have the full file, keep the position\n\tu64 fragmented_file_pos;\n\tu8 *block_buffer;\n\tu32 block_buffer_size;\n\n\tu32 nb_box_init_seg;\n\n\tBool no_inplace_rewrite;\n\tu32 padding;\n\tu64 original_moov_offset, original_meta_offset, first_data_toplevel_offset, first_data_toplevel_size;\n};\n\n/*time function*/\nu64 gf_isom_get_mp4time();\n/*set the last error of the file. if file is NULL, set the static error (used for IO errors*/\nvoid gf_isom_set_last_error(GF_ISOFile *the_file, GF_Err error);\nGF_Err gf_isom_parse_movie_boxes(GF_ISOFile *mov, u32 *boxType, u64 *bytesMissing, Bool progressive_mode);\nGF_ISOFile *gf_isom_new_movie();\n/*Movie and Track access functions*/\nGF_TrackBox *gf_isom_get_track_from_file(GF_ISOFile *the_file, u32 trackNumber);\nGF_TrackBox *gf_isom_get_track(GF_MovieBox *moov, u32 trackNumber);\nGF_TrackBox *gf_isom_get_track_from_id(GF_MovieBox *moov, GF_ISOTrackID trackID);\nGF_TrackBox *gf_isom_get_track_from_original_id(GF_MovieBox *moov, u32 originalID, u32 originalFile);\nu32 gf_isom_get_tracknum_from_id(GF_MovieBox *moov, GF_ISOTrackID trackID);\n/*open a movie*/\nGF_ISOFile *gf_isom_open_file(const char *fileName, GF_ISOOpenMode OpenMode, const char *tmp_dir);\n/*close and delete a movie*/\nvoid gf_isom_delete_movie(GF_ISOFile *mov);\nvoid gf_isom_meta_restore_items_ref(GF_ISOFile *file, GF_MetaBox *meta);\n\nGF_MetaBox *gf_isom_get_meta(GF_ISOFile *file, Bool root_meta, u32 track_num);\n\n/*StreamDescription reconstruction Functions*/\nGF_Err GetESD(GF_MovieBox *moov, GF_ISOTrackID trackID, u32 StreamDescIndex, GF_ESD **outESD);\nGF_Err GetESDForTime(GF_MovieBox *moov, GF_ISOTrackID trackID, u64 CTS, GF_ESD **outESD);\nGF_Err Media_GetSampleDesc(GF_MediaBox *mdia, u32 SampleDescIndex, GF_SampleEntryBox **out_entry, u32 *dataRefIndex);\nGF_Err Media_GetSampleDescIndex(GF_MediaBox *mdia, u64 DTS, u32 *sampleDescIndex);\n/*get esd for given sample desc -\n\t@true_desc_only: if true doesn't emulate desc and returns native ESD,\n\t\t\t\totherwise emulates if needed/possible (TimedText) and return a hard copy of the desc\n*/\nGF_Err Media_GetESD(GF_MediaBox *mdia, u32 sampleDescIndex, GF_ESD **esd, Bool true_desc_only);\nBool Track_IsMPEG4Stream(u32 HandlerType);\nBool IsMP4Description(u32 entryType);\n/*Find a reference of a given type*/\nGF_Err Track_FindRef(GF_TrackBox *trak, u32 ReferenceType, GF_TrackReferenceTypeBox **dpnd);\n/*Time and sample*/\nGF_Err GetMediaTime(GF_TrackBox *trak, Bool force_non_empty, u64 movieTime, u64 *MediaTime, s64 *SegmentStartTime, s64 *MediaOffset, u8 *useEdit, u64 *next_edit_start_plus_one);\nGF_Err Media_GetSample(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample **samp, u32 *sampleDescriptionIndex, Bool no_data, u64 *out_offset);\nGF_Err Media_CheckDataEntry(GF_MediaBox *mdia, u32 dataEntryIndex);\nGF_Err Media_FindSyncSample(GF_SampleTableBox *stbl, u32 searchFromTime, u32 *sampleNumber, u8 mode);\nGF_Err Media_RewriteODFrame(GF_MediaBox *mdia, GF_ISOSample *sample);\nGF_Err Media_FindDataRef(GF_DataReferenceBox *dref, char *URLname, char *URNname, u32 *dataRefIndex);\nBool Media_IsSelfContained(GF_MediaBox *mdia, u32 StreamDescIndex);\n\ntypedef enum\n{\n\tISOM_DREF_MIXED = 0,\n\tISOM_DREF_SELF,\n\tISOM_DREF_EXT,\n} GF_ISOMDataRefAllType;\nGF_ISOMDataRefAllType Media_SelfContainedType(GF_MediaBox *mdia);\n\nGF_TrackBox *GetTrackbyID(GF_MovieBox *moov, GF_ISOTrackID TrackID);\n\n/*check the TimeToSample for the given time and return the Sample number\nif the entry is not found, return the closest sampleNumber in prevSampleNumber and 0 in sampleNumber\nif the DTS required is after all DTSs in the list, set prevSampleNumber and SampleNumber to 0\nuseCTS specifies that we're looking for a composition time\n*/\nGF_Err stbl_findEntryForTime(GF_SampleTableBox *stbl, u64 DTS, u8 useCTS, u32 *sampleNumber, u32 *prevSampleNumber);\n/*Reading of the sample tables*/\nGF_Err stbl_GetSampleSize(GF_SampleSizeBox *stsz, u32 SampleNumber, u32 *Size);\nGF_Err stbl_GetSampleCTS(GF_CompositionOffsetBox *ctts, u32 SampleNumber, s32 *CTSoffset);\nGF_Err stbl_GetSampleDTS(GF_TimeToSampleBox *stts, u32 SampleNumber, u64 *DTS);\nGF_Err stbl_GetSampleDTS_and_Duration(GF_TimeToSampleBox *stts, u32 SampleNumber, u64 *DTS, u32 *duration);\n\n/*find a RAP or set the prev / next RAPs if vars are passed*/\nGF_Err stbl_GetSampleRAP(GF_SyncSampleBox *stss, u32 SampleNumber, GF_ISOSAPType *IsRAP, u32 *prevRAP, u32 *nextRAP);\n/*same as above but only look for open-gop RAPs and GDR (roll)*/\nGF_Err stbl_SearchSAPs(GF_SampleTableBox *stbl, u32 SampleNumber, GF_ISOSAPType *IsRAP, u32 *prevRAP, u32 *nextRAP);\nGF_Err stbl_GetSampleInfos(GF_SampleTableBox *stbl, u32 sampleNumber, u64 *offset, u32 *chunkNumber, u32 *descIndex, GF_StscEntry **scsc_entry);\nGF_Err stbl_GetSampleShadow(GF_ShadowSyncBox *stsh, u32 *sampleNumber, u32 *syncNum);\nGF_Err stbl_GetPaddingBits(GF_PaddingBitsBox *padb, u32 SampleNumber, u8 *PadBits);\nGF_Err stbl_GetSampleDepType(GF_SampleDependencyTypeBox *stbl, u32 SampleNumber, u32 *isLeading, u32 *dependsOn, u32 *dependedOn, u32 *redundant);\n\n\n/*unpack sample2chunk and chunk offset so that we have 1 sample per chunk (edition mode only)*/\nGF_Err stbl_UnpackOffsets(GF_SampleTableBox *stbl);\nGF_Err stbl_unpackCTS(GF_SampleTableBox *stbl);\nGF_Err SetTrackDuration(GF_TrackBox *trak);\nGF_Err Media_SetDuration(GF_TrackBox *trak);\n\n/*rewrites 3GP samples desc as MPEG-4 ESD*/\nGF_Err gf_isom_get_ttxt_esd(GF_MediaBox *mdia, GF_ESD **out_esd);\n/*inserts TTU header - only used when conversion to StreamingText is on*/\nGF_Err gf_isom_rewrite_text_sample(GF_ISOSample *samp, u32 sampleDescriptionIndex, u32 sample_dur);\n\nGF_UserDataMap *udta_getEntry(GF_UserDataBox *ptr, u32 box_type, bin128 *uuid);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err FlushCaptureMode(GF_ISOFile *movie);\nGF_Err CanAccessMovie(GF_ISOFile *movie, GF_ISOOpenMode Mode);\nGF_ISOFile *gf_isom_create_movie(const char *fileName, GF_ISOOpenMode OpenMode, const char *tmp_dir);\nGF_Err gf_isom_insert_moov(GF_ISOFile *file);\n\nGF_Err WriteToFile(GF_ISOFile *movie, Bool for_fragments);\nGF_Err Track_SetStreamDescriptor(GF_TrackBox *trak, u32 StreamDescriptionIndex, u32 DataReferenceIndex, GF_ESD *esd, u32 *outStreamIndex);\nu8 RequestTrack(GF_MovieBox *moov, GF_ISOTrackID TrackID);\n/*Track-Media setup*/\nGF_Err NewMedia(GF_MediaBox **mdia, u32 MediaType, u32 TimeScale);\nGF_Err Media_ParseODFrame(GF_MediaBox *mdia, const GF_ISOSample *sample, GF_ISOSample **od_samp);\nGF_Err Media_AddSample(GF_MediaBox *mdia, u64 data_offset, const GF_ISOSample *sample, u32 StreamDescIndex, u32 syncShadowNumber);\nGF_Err Media_CreateDataRef(GF_ISOFile *file, GF_DataReferenceBox *dref, char *URLname, char *URNname, u32 *dataRefIndex);\nGF_Err Media_SetDrefURL(GF_DataEntryURLBox *dref_entry, const char *origName, const char *finalName);\n\n/*update a media sample. ONLY in edit mode*/\nGF_Err Media_UpdateSample(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample *sample, Bool data_only);\nGF_Err Media_UpdateSampleReference(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample *sample, u64 data_offset);\n/*addition in the sample tables*/\nGF_Err stbl_AddDTS(GF_SampleTableBox *stbl, u64 DTS, u32 *sampleNumber, u32 LastAUDefDuration, u32 nb_pack_samples);\nGF_Err stbl_AddCTS(GF_SampleTableBox *stbl, u32 sampleNumber, s32 CTSoffset);\nGF_Err stbl_AddSize(GF_SampleSizeBox *stsz, u32 sampleNumber, u32 size, u32 nb_pack_samples);\nGF_Err stbl_AddRAP(GF_SyncSampleBox *stss, u32 sampleNumber);\nGF_Err stbl_AddShadow(GF_ShadowSyncBox *stsh, u32 sampleNumber, u32 shadowNumber);\nGF_Err stbl_AddChunkOffset(GF_MediaBox *mdia, u32 sampleNumber, u32 StreamDescIndex, u64 offset, u32 nb_pack_samples);\n/*NB - no add for padding, this is done only through SetPaddingBits*/\n\nGF_Err stbl_AddSampleFragment(GF_SampleTableBox *stbl, u32 sampleNumber, u16 size);\n\n/*update of the sample table\nall these functions are called in edit and we always have 1 sample per chunk*/\nGF_Err stbl_SetChunkOffset(GF_MediaBox *mdia, u32 sampleNumber, u64 offset);\nGF_Err stbl_SetSampleCTS(GF_SampleTableBox *stbl, u32 sampleNumber, s32 offset);\nGF_Err stbl_SetSampleSize(GF_SampleSizeBox *stsz, u32 SampleNumber, u32 size);\nGF_Err stbl_SetSampleRAP(GF_SyncSampleBox *stss, u32 SampleNumber, u8 isRAP);\nGF_Err stbl_SetSyncShadow(GF_ShadowSyncBox *stsh, u32 sampleNumber, u32 syncSample);\nGF_Err stbl_SetPaddingBits(GF_SampleTableBox *stbl, u32 SampleNumber, u8 bits);\n/*for adding fragmented samples*/\nGF_Err stbl_SampleSizeAppend(GF_SampleSizeBox *stsz, u32 data_size);\n/*writing of the final chunk info in edit mode*/\nGF_Err stbl_SetChunkAndOffset(GF_SampleTableBox *stbl, u32 sampleNumber, u32 StreamDescIndex, GF_SampleToChunkBox *the_stsc, GF_Box **the_stco, u64 data_offset, Bool forceNewChunk, u32 nb_samp);\n/*EDIT LIST functions*/\nGF_EdtsEntry *CreateEditEntry(u64 EditDuration, u64 MediaTime, u8 EditMode);\n\nGF_Err stbl_SetRedundant(GF_SampleTableBox *stbl, u32 sampleNumber);\nGF_Err stbl_AddRedundant(GF_SampleTableBox *stbl, u32 sampleNumber);\n\n/*REMOVE functions*/\nGF_Err stbl_RemoveDTS(GF_SampleTableBox *stbl, u32 sampleNumber, u32 nb_samples, u32 LastAUDefDuration);\nGF_Err stbl_RemoveCTS(GF_SampleTableBox *stbl, u32 sampleNumber, u32 nb_samples);\nGF_Err stbl_RemoveSize(GF_SampleTableBox *stbl, u32 sampleNumber, u32 nb_samples);\nGF_Err stbl_RemoveChunk(GF_SampleTableBox *stbl, u32 sampleNumber, u32 nb_samples);\nGF_Err stbl_RemoveRAP(GF_SampleTableBox *stbl, u32 sampleNumber);\nGF_Err stbl_RemoveShadow(GF_SampleTableBox *stbl, u32 sampleNumber);\nGF_Err stbl_RemovePaddingBits(GF_SampleTableBox *stbl, u32 SampleNumber);\nGF_Err stbl_RemoveRedundant(GF_SampleTableBox *stbl, u32 SampleNumber, u32 nb_samples);\nGF_Err stbl_RemoveSubSample(GF_SampleTableBox *stbl, u32 SampleNumber);\nGF_Err stbl_RemoveSampleGroup(GF_SampleTableBox *stbl, u32 SampleNumber);\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\nGF_Err gf_isom_close_fragments(GF_ISOFile *movie);\n#endif\n\nGF_Err gf_isom_flush_sidx(GF_ISOFile *movie, u32 sidx_max_size, Bool force_v1);\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nBool gf_isom_is_identical_sgpd(void *ptr1, void *ptr2, u32 grouping_type);\n\nGF_DefaultSampleGroupDescriptionEntry * gf_isom_get_sample_group_info_entry(GF_ISOFile *the_file, GF_TrackBox *trak, u32 grouping_type, u32 sample_description_index, u32 *default_index, GF_SampleGroupDescriptionBox **out_sgdp);\n\nGF_Err GetNextMediaTime(GF_TrackBox *trak, u64 movieTime, u64 *OutMovieTime);\nGF_Err GetPrevMediaTime(GF_TrackBox *trak, u64 movieTime, u64 *OutMovieTime);\n\nBool IsHintTrack(GF_TrackBox *trak);\nBool CheckHintFormat(GF_TrackBox *trak, u32 HintType);\nu32 GetHintFormat(GF_TrackBox *trak);\n\n/*locate a box by its type or UUID*/\nGF_ItemListBox *gf_ismo_locate_box(GF_List *list, u32 boxType, bin128 UUID);\n\nGF_Err moov_on_child_box(GF_Box *ptr, GF_Box *a, Bool is_rem);\nGF_Err trak_on_child_box(GF_Box *ptr, GF_Box *a, Bool is_rem);\nGF_Err mvex_on_child_box(GF_Box *ptr, GF_Box *a, Bool is_rem);\nGF_Err stsd_on_child_box(GF_Box *ptr, GF_Box *a, Bool is_rem);\nGF_Err hnti_on_child_box(GF_Box *hnti, GF_Box *a, Bool is_rem);\nGF_Err udta_on_child_box(GF_Box *ptr, GF_Box *a, Bool is_rem);\nGF_Err edts_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem);\nGF_Err stdp_box_read(GF_Box *s, GF_BitStream *bs);\nGF_Err stbl_on_child_box(GF_Box *ptr, GF_Box *a, Bool is_rem);\nGF_Err sdtp_box_read(GF_Box *s, GF_BitStream *bs);\nGF_Err dinf_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem);\nGF_Err minf_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem);\nGF_Err mdia_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem);\nGF_Err traf_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem);\n\n/*rewrites avcC based on the given esd - this destroys the esd*/\nGF_Err AVC_HEVC_UpdateESD(GF_MPEGVisualSampleEntryBox *avc, GF_ESD *esd);\nvoid AVC_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *avc, GF_MediaBox *mdia);\nvoid AVC_RewriteESDescriptor(GF_MPEGVisualSampleEntryBox *avc);\nvoid HEVC_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *hevc, GF_MediaBox *mdia);\nvoid HEVC_RewriteESDescriptor(GF_MPEGVisualSampleEntryBox *hevc);\nvoid VP9_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *vp9, GF_MediaBox *mdia);\nvoid VP9_RewriteESDescriptor(GF_MPEGVisualSampleEntryBox *vp9);\nvoid AV1_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *av1, GF_MediaBox *mdia);\nvoid AV1_RewriteESDescriptor(GF_MPEGVisualSampleEntryBox *av1);\nGF_Err reftype_AddRefTrack(GF_TrackReferenceTypeBox *ref, GF_ISOTrackID trackID, u16 *outRefIndex);\nBool gf_isom_cenc_has_saiz_saio_track(GF_SampleTableBox *stbl, u32 scheme_type);\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nBool gf_isom_cenc_has_saiz_saio_traf(GF_TrackFragmentBox *traf, u32 scheme_type);\nvoid gf_isom_cenc_set_saiz_saio(GF_SampleEncryptionBox *senc, GF_SampleTableBox *stbl, GF_TrackFragmentBox  *traf, u32 len, Bool saio_32bits, Bool use_mkey);\n#endif\nGF_Err gf_isom_cenc_merge_saiz_saio(GF_SampleEncryptionBox *senc, GF_SampleTableBox *stbl, u64 offset, u32 len);\n\nvoid gf_isom_parse_trif_info(const u8 *data, u32 size, u32 *id, u32 *independent, Bool *full_picture, u32 *x, u32 *y, u32 *w, u32 *h);\n\nBool gf_isom_is_encrypted_entry(u32 entryType);\n\n//too export in constants\nBool gf_cenc_validate_key_info(const u8 *key_info, u32 key_info_size);\n\n\n/*! CENC auxiliary info*/\ntypedef struct __cenc_sample_aux_info\n{\n\tu8 *cenc_data;\n\tu32 cenc_data_size;\n \t/*! flag set if sample is clear - it MUST NOT be written to file*/\n\tu8 isNotProtected;\n\n\t/*! key info, for dump only (not valid otherwise)*/\n\tconst u8 *key_info;\n\tu32 key_info_size;\n} GF_CENCSampleAuxInfo;\n\n\n/*! destroys a CENC sample auxiliary structure\n\\param samp_aux_info the target auxiliary buffer\n*/\nvoid gf_isom_cenc_samp_aux_info_del(GF_CENCSampleAuxInfo *samp_aux_info);\n\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\n/*\n\t\tHinting stuff\n*/\n\n/*****************************************************\n\t\tRTP Data Entries\n*****************************************************/\n\ntypedef struct\n{\n\tu8 sender_current_time_present;\n\tu8 expected_residual_time_present;\n\tu8 session_close_bit;\n\tu8 object_close_bit;\n\tu16 transport_object_identifier;\n} GF_LCTheaderTemplate;\n\ntypedef struct\n{\n\tu8 header_extension_type;\n\tu8 content[3];\n\tu32 data_length;\n\tu8 *data;\n} GF_LCTheaderExtension;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\n\tGF_LCTheaderTemplate info;\n\tu16 header_ext_count;\n\tGF_LCTheaderExtension *headers;\n\n\tGF_List *constructors;\n} GF_FDpacketBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\n\tu8 FEC_encoding_ID;\n\tu16 FEC_instance_ID;\n\tu16 source_block_number;\n\tu16 encoding_symbol_ID;\n} GF_FECInformationBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\t//not registered with child list !!\n\tGF_FECInformationBox *feci;\n\tu32 data_length;\n\tu8 *data;\n} GF_ExtraDataBox;\n\n\n#define GF_ISMO_BASE_DTE_ENTRY\t\\\n\tu8 source;\n\ntypedef struct\n{\n\tGF_ISMO_BASE_DTE_ENTRY\n} GF_GenericDTE;\n\ntypedef struct\n{\n\tGF_ISMO_BASE_DTE_ENTRY\n} GF_EmptyDTE;\n\ntypedef struct\n{\n\tGF_ISMO_BASE_DTE_ENTRY\n\tu8 dataLength;\n\tchar data[14];\n} GF_ImmediateDTE;\n\ntypedef struct\n{\n\tGF_ISMO_BASE_DTE_ENTRY\n\ts8 trackRefIndex;\n\tu32 sampleNumber;\n\tu16 dataLength;\n\tu32 byteOffset;\n\tu16 bytesPerComp;\n\tu16 samplesPerComp;\n} GF_SampleDTE;\n\ntypedef struct\n{\n\tGF_ISMO_BASE_DTE_ENTRY\n\ts8 trackRefIndex;\n\tu32 streamDescIndex;\n\tu16 dataLength;\n\tu32 byteOffset;\n\tu32 reserved;\n} GF_StreamDescDTE;\n\nGF_GenericDTE *NewDTE(u8 type);\nvoid DelDTE(GF_GenericDTE *dte);\nGF_Err ReadDTE(GF_GenericDTE *dte, GF_BitStream *bs);\nGF_Err WriteDTE(GF_GenericDTE *dte, GF_BitStream *bs);\nGF_Err OffsetDTE(GF_GenericDTE *dte, u32 offset, u32 HintSampleNumber);\n\n/*****************************************************\n\t\tRTP Sample\n*****************************************************/\n\n/*data cache when reading*/\ntypedef struct __tag_hint_data_cache\n{\n\tGF_ISOSample *samp;\n\tGF_TrackBox *trak;\n\tu32 sample_num;\n} GF_HintDataCache;\n\ntypedef struct __tag_hint_sample\n{\n\t//for samples deriving from box\n\tGF_ISOM_BOX\n\n\t/*contains 4cc of hint track sample entry*/\n\tu32 hint_subtype;\n\tu16 packetCount;\n\tu16 reserved;\n\tGF_List *packetTable;\n\tu8 *AdditionalData;\n\tu32 dataLength;\n\t/*used internally for hinting*/\n\tu64 TransmissionTime;\n\t/*for read only, used to store samples fetched while building packets*/\n\tGF_List *sample_cache;\n\n\t//for dump\n\tGF_ISOTrackID trackID;\n\tu32 sampleNumber;\n\n\tGF_ExtraDataBox *extra_data;\n} GF_HintSample;\n\nGF_HintSample *gf_isom_hint_sample_new(u32 ProtocolType);\nvoid gf_isom_hint_sample_del(GF_HintSample *ptr);\nGF_Err gf_isom_hint_sample_read(GF_HintSample *ptr, GF_BitStream *bs, u32 sampleSize);\nGF_Err gf_isom_hint_sample_write(GF_HintSample *ptr, GF_BitStream *bs);\nu32 gf_isom_hint_sample_size(GF_HintSample *ptr);\n\n\n/*****************************************************\n\t\tHint Packets (generic packet for future protocol support)\n*****************************************************/\n#define GF_ISOM_BASE_PACKET\t\t\t\\\n\tu32 hint_subtype, sampleNumber;\t\\\n\tGF_ISOTrackID trackID;\\\n\ts32 relativeTransTime;\n\n\ntypedef struct\n{\n\tGF_ISOM_BASE_PACKET\n} GF_HintPacket;\n\nGF_HintPacket *gf_isom_hint_pck_new(u32 HintType);\nvoid gf_isom_hint_pck_del(GF_HintPacket *ptr);\nGF_Err gf_isom_hint_pck_read(GF_HintPacket *ptr, GF_BitStream *bs);\nGF_Err gf_isom_hint_pck_write(GF_HintPacket *ptr, GF_BitStream *bs);\nu32 gf_isom_hint_pck_size(GF_HintPacket *ptr);\nGF_Err gf_isom_hint_pck_offset(GF_HintPacket *ptr, u32 offset, u32 HintSampleNumber);\nGF_Err gf_isom_hint_pck_add_dte(GF_HintPacket *ptr, GF_GenericDTE *dte, u8 AtBegin);\n/*get the size of the packet AS RECONSTRUCTED BY THE SERVER (without CSRC)*/\nu32 gf_isom_hint_pck_length(GF_HintPacket *ptr);\n\n/*the RTP packet*/\ntypedef struct\n{\n\tGF_ISOM_BASE_PACKET\n\n\t/*RTP Header*/\n\tu8 P_bit;\n\tu8 X_bit;\n\tu8 M_bit;\n\t/*on 7 bits */\n\tu8 payloadType;\n\tu16 SequenceNumber;\n\t/*Hinting flags*/\n\tu8 B_bit;\n\tu8 R_bit;\n\t/*ExtraInfos TLVs - not really used */\n\tGF_List *TLV;\n\t/*DataTable - contains the DTEs...*/\n\tGF_List *DataTable;\n} GF_RTPPacket;\n\nGF_RTPPacket *gf_isom_hint_rtp_new();\nvoid gf_isom_hint_rtp_del(GF_RTPPacket *ptr);\nGF_Err gf_isom_hint_rtp_read(GF_RTPPacket *ptr, GF_BitStream *bs);\nGF_Err gf_isom_hint_rtp_write(GF_RTPPacket *ptr, GF_BitStream *bs);\nu32 gf_isom_hint_rtp_size(GF_RTPPacket *ptr);\nGF_Err gf_isom_hint_rtp_offset(GF_RTPPacket *ptr, u32 offset, u32 HintSampleNumber);\nu32 gf_isom_hint_rtp_length(GF_RTPPacket *ptr);\n\n\n/*the RTP packet*/\ntypedef struct\n{\n\tGF_ISOM_BASE_PACKET\n\n\t//RTCP report\n\tu8 Version, Padding, Count, PayloadType;\n\tu32 length;\n\tu8 *data;\n} GF_RTCPPacket;\n\nGF_RTCPPacket *gf_isom_hint_rtcp_new();\nvoid gf_isom_hint_rtcp_del(GF_RTCPPacket *ptr);\nGF_Err gf_isom_hint_rtcp_read(GF_RTCPPacket *ptr, GF_BitStream *bs);\nGF_Err gf_isom_hint_rtcp_write(GF_RTCPPacket *ptr, GF_BitStream *bs);\nu32 gf_isom_hint_rtcp_size(GF_RTCPPacket *ptr);\nu32 gf_isom_hint_rtcp_length(GF_RTCPPacket *ptr);\n\n\n#endif\n\n\nstruct _3gpp_text_sample\n{\n\tchar *text;\n\tu32 len;\n\n\tGF_TextStyleBox *styles;\n\t/*at most one of these*/\n\tGF_TextHighlightColorBox *highlight_color;\n\tGF_TextScrollDelayBox *scroll_delay;\n\tGF_TextBoxBox *box;\n\tGF_TextWrapBox *wrap;\n\n\tGF_List *others;\n\tGF_TextKaraokeBox *cur_karaoke;\n};\n\nGF_TextSample *gf_isom_parse_text_sample(GF_BitStream *bs);\n\nstruct _generic_subtitle_sample\n{\n\tchar *text;\n\tu32 len;\n};\nGF_GenericSubtitleSample *gf_isom_parse_generic_subtitle_sample(GF_BitStream *bs);\nGF_GenericSubtitleSample *gf_isom_parse_generic_subtitle_sample_from_data(u8 *data, u32 dataLength);\n\n\n/*do not throw fatal errors if boxes are duplicated, just warn and remove extra ones*/\n#define ERROR_ON_DUPLICATED_BOX(__abox, __parent) {\t\\\n\t\tchar __ptype[GF_4CC_MSIZE];\\\n\t\tstrcpy(__ptype, gf_4cc_to_str(__parent->type) );\\\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] extra box %s found in %s, deleting\\n\", gf_4cc_to_str(__abox->type), __ptype)); \\\n\t\tgf_isom_box_del_parent(& (__parent->child_boxes), __abox);\\\n\t\treturn GF_OK;\\\n\t}\n\n\n#ifndef GPAC_DISABLE_VTT\n\nGF_ISOSample *gf_isom_webvtt_to_sample(void *samp);\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tchar *string;\n} GF_StringBox;\n\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\n\tGF_StringBox *config;\n} GF_WebVTTSampleEntryBox;\n\nGF_WebVTTSampleEntryBox *gf_webvtt_isom_get_description(GF_ISOFile *movie, u32 trackNumber, u32 descriptionIndex);\n\n#endif /* GPAC_DISABLE_VTT */\n\n//exported for sgpd comparison in traf merge\nvoid sgpd_write_entry(u32 grouping_type, void *entry, GF_BitStream *bs);\nBool gf_isom_box_equal(GF_Box *a, GF_Box *b);\nGF_Box *gf_isom_clone_config_box(GF_Box *box);\n\nGF_Err gf_isom_box_dump(void *ptr, FILE * trace);\nGF_Err gf_isom_box_array_dump(GF_List *list, FILE * trace);\n\nvoid gf_isom_registry_disable(u32 boxCode, Bool disable);\n\n/*Apple extensions*/\nGF_Box *gf_isom_get_meta_extensions(GF_ISOFile *mov, Bool for_xtra);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Box *gf_isom_create_meta_extensions(GF_ISOFile *mov, Bool for_xtra);\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n#ifndef GPAC_DISABLE_ISOM_DUMP\nGF_Err gf_isom_box_dump_ex(void *ptr, FILE * trace, u32 box_4cc);\nGF_Err gf_isom_box_dump_start(GF_Box *a, const char *name, FILE * trace);\nvoid gf_isom_box_dump_done(const char *name, GF_Box *ptr, FILE *trace);\nBool gf_isom_box_is_file_level(GF_Box *s);\n#endif\n\nGF_Box *boxstring_new_with_data(u32 type, const char *string, GF_List **parent);\n\nGF_Err gf_isom_read_null_terminated_string(GF_Box *s, GF_BitStream *bs, u64 size, char **out_str);\n\nGF_Err MergeTrack(GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_MovieFragmentBox *moof, u64 moof_offset, s32 compresed_diff, u64 *cumulated_offset, Bool is_first_merge);\n\n\n#endif //GPAC_DISABLE_ISOM\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif //_GF_ISOMEDIA_DEV_H_\n\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthor: Romain Bouqueau, Jean Le Feuvre\n *\t\t\tCopyright (c) Romain Bouqueau 2012- Telecom Paris 2019-\n *\t\t\t\tAll rights reserved\n *\n *          Note: this development was kindly sponsorized by Vizion'R (http://vizionr.com)\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n\n#ifndef GPAC_DISABLE_ISOM\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid abst_box_del(GF_Box *s)\n{\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->movie_identifier)\n\t\tgf_free(ptr->movie_identifier);\n\tif (ptr->drm_data)\n\t\tgf_free(ptr->drm_data);\n\tif (ptr->meta_data)\n\t\tgf_free(ptr->meta_data);\n\n\twhile (gf_list_count(ptr->server_entry_table)) {\n\t\tgf_free(gf_list_get(ptr->server_entry_table, 0));\n\t\tgf_list_rem(ptr->server_entry_table, 0);\n\t}\n\tgf_list_del(ptr->server_entry_table);\n\n\twhile (gf_list_count(ptr->quality_entry_table)) {\n\t\tgf_free(gf_list_get(ptr->quality_entry_table, 0));\n\t\tgf_list_rem(ptr->quality_entry_table, 0);\n\t}\n\tgf_list_del(ptr->quality_entry_table);\n\n\n\twhile (gf_list_count(ptr->segment_run_table_entries)) {\n\t\tgf_isom_box_del((GF_Box *)gf_list_get(ptr->segment_run_table_entries, 0));\n\t\tgf_list_rem(ptr->segment_run_table_entries, 0);\n\t}\n\tgf_list_del(ptr->segment_run_table_entries);\n\n\twhile (gf_list_count(ptr->fragment_run_table_entries)) {\n\t\tgf_isom_box_del((GF_Box *)gf_list_get(ptr->fragment_run_table_entries, 0));\n\t\tgf_list_rem(ptr->fragment_run_table_entries, 0);\n\t}\n\tgf_list_del(ptr->fragment_run_table_entries);\n\n\tgf_free(ptr);\n}\n\nGF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\tint i;\n\tu32 tmp_strsize;\n\tchar *tmp_str;\n\tBool zfound=GF_FALSE;\n\tGF_Err e;\n\n\tISOM_DECREASE_SIZE(ptr, 25)\n\tptr->bootstrapinfo_version = gf_bs_read_u32(bs);\n\tptr->profile = gf_bs_read_int(bs, 2);\n\tptr->live = gf_bs_read_int(bs, 1);\n\tptr->update = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 4);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\tptr->current_media_time = gf_bs_read_u64(bs);\n\tptr->smpte_time_code_offset = gf_bs_read_u64(bs);\n\n\ti=0;\n\tif (ptr->size<8) return GF_ISOM_INVALID_FILE;\n\ttmp_strsize =(u32)ptr->size;\n\ttmp_str = gf_malloc(sizeof(char)*tmp_strsize);\n\tif (!tmp_str) return GF_OUT_OF_MEM;\n\tmemset(tmp_str, 0, sizeof(char)*tmp_strsize);\n\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i]) {\n\t\t\tzfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!zfound)\n\t\treturn GF_ISOM_INVALID_FILE;\n\tif (i) {\n\t\tptr->movie_identifier = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->server_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->server_entry_count; i++) {\n\t\tint j=0;\n\t\tzfound = GF_FALSE;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j]) {\n\t\t\t\tzfound = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\tif (!zfound)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\tzfound = GF_FALSE;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j]) {\n\t\t\t\tzfound = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\n\t\tif (!zfound)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\tzfound = GF_FALSE;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i]) {\n\t\t\tzfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!zfound)\n\t\treturn GF_ISOM_INVALID_FILE;\n\tif (i) {\n\t\tptr->drm_data = gf_strdup(tmp_str);\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\tzfound = GF_FALSE;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i]) {\n\t\t\tzfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!zfound)\n\t\treturn GF_ISOM_INVALID_FILE;\n\tif (i) {\n\t\tptr->meta_data = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->segment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\tGF_AdobeSegmentRunTableBox *asrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&asrt, bs);\n\t\tif (e) {\n\t\t\tif (asrt) gf_isom_box_del((GF_Box*)asrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_add(ptr->segment_run_table_entries, asrt);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->fragment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\tGF_AdobeFragmentRunTableBox *afrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&afrt, bs);\n\t\tif (e) {\n\t\t\tif (afrt) gf_isom_box_del((GF_Box*)afrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_add(ptr->fragment_run_table_entries, afrt);\n\t}\n\n\tgf_free(tmp_str);\n\n\treturn GF_OK;\n}\n\nGF_Box *abst_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AdobeBootstrapInfoBox, GF_ISOM_BOX_TYPE_ABST);\n\ttmp->server_entry_table = gf_list_new();\n\ttmp->quality_entry_table = gf_list_new();\n\ttmp->segment_run_table_entries = gf_list_new();\n\ttmp->fragment_run_table_entries = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err abst_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tunsigned int i;\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->bootstrapinfo_version);\n\tgf_bs_write_int(bs, ptr->profile, 2);\n\tgf_bs_write_int(bs, ptr->live, 1);\n\tgf_bs_write_int(bs, ptr->update, 1);\n\tgf_bs_write_int(bs, ptr->reserved, 4);\n\tgf_bs_write_u32(bs, ptr->time_scale);\n\tgf_bs_write_u64(bs, ptr->current_media_time);\n\tgf_bs_write_u64(bs, ptr->smpte_time_code_offset);\n\tif (ptr->movie_identifier)\n\t\tgf_bs_write_data(bs, ptr->movie_identifier, (u32)strlen(ptr->movie_identifier) + 1);\n\telse\n\t\tgf_bs_write_u8(bs, 0);\n\n\tgf_bs_write_u8(bs, ptr->server_entry_count);\n\tfor (i=0; i<ptr->server_entry_count; i++) {\n\t\tchar *str = (char*)gf_list_get(ptr->server_entry_table, i);\n\t\tgf_bs_write_data(bs, str, (u32)strlen(str) + 1);\n\t}\n\n\tgf_bs_write_u8(bs, ptr->quality_entry_count);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tchar *str = (char*)gf_list_get(ptr->quality_entry_table, i);\n\t\tgf_bs_write_data(bs, str, (u32)strlen(str) + 1);\n\t}\n\n\tif (ptr->drm_data)\n\t\tgf_bs_write_data(bs, ptr->drm_data, (u32)strlen(ptr->drm_data) + 1);\n\telse\n\t\tgf_bs_write_u8(bs, 0);\n\n\tif (ptr->meta_data)\n\t\tgf_bs_write_data(bs, ptr->meta_data, (u32)strlen(ptr->meta_data) + 1);\n\telse\n\t\tgf_bs_write_u8(bs, 0);\n\n\tgf_bs_write_u8(bs, ptr->segment_run_table_count);\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\te = gf_isom_box_write((GF_Box *)gf_list_get(ptr->segment_run_table_entries, i), bs);\n\t\tif (e) return e;\n\t}\n\n\tgf_bs_write_u8(bs, ptr->fragment_run_table_count);\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\te = gf_isom_box_write((GF_Box *)gf_list_get(ptr->fragment_run_table_entries, i), bs);\n\t\tif (e) return e;\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Err abst_box_size(GF_Box *s)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\n\ts->size += 25\n\t           + (ptr->movie_identifier ? (strlen(ptr->movie_identifier) + 1) : 1)\n\t           + 1;\n\n\tfor (i=0; i<ptr->server_entry_count; i++)\n\t\ts->size += strlen(gf_list_get(ptr->server_entry_table, i)) + 1;\n\n\ts->size += 1;\n\n\tfor (i=0; i<ptr->quality_entry_count; i++)\n\t\ts->size += strlen(gf_list_get(ptr->quality_entry_table, i)) + 1;\n\n\ts->size += (ptr->drm_data ? (strlen(ptr->drm_data) + 1) : 1)\n\t           + (ptr->meta_data ? (strlen(ptr->meta_data) + 1) : 1)\n\t           + 1;\n\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\tGF_Box *box = (GF_Box *)gf_list_get(ptr->segment_run_table_entries, i);\n\t\te = gf_isom_box_size(box);\n\t\tif (e) return e;\n\t\ts->size += box->size;\n\t}\n\n\ts->size += 1;\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\tGF_Box *box = (GF_Box *)gf_list_get(ptr->fragment_run_table_entries, i);\n\t\te = gf_isom_box_size(box);\n\t\tif (e) return e;\n\t\ts->size += box->size;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid afra_box_del(GF_Box *s)\n{\n\tGF_AdobeFragRandomAccessBox *ptr = (GF_AdobeFragRandomAccessBox *)s;\n\tif (ptr == NULL) return;\n\n\twhile (gf_list_count(ptr->local_access_entries)) {\n\t\tgf_free(gf_list_get(ptr->local_access_entries, 0));\n\t\tgf_list_rem(ptr->local_access_entries, 0);\n\t}\n\tgf_list_del(ptr->local_access_entries);\n\n\twhile (gf_list_count(ptr->global_access_entries)) {\n\t\tgf_free(gf_list_get(ptr->global_access_entries, 0));\n\t\tgf_list_rem(ptr->global_access_entries, 0);\n\t}\n\tgf_list_del(ptr->global_access_entries);\n\n\tgf_free(ptr);\n}\n\nGF_Err afra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tunsigned int i;\n\tGF_AdobeFragRandomAccessBox *ptr = (GF_AdobeFragRandomAccessBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 9)\n\tptr->long_ids = gf_bs_read_int(bs, 1);\n\tptr->long_offsets = gf_bs_read_int(bs, 1);\n\tptr->global_entries = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 5);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\n\tptr->entry_count = gf_bs_read_u32(bs);\n\tif (ptr->size < ptr->entry_count * (ptr->long_offsets ? 16 : 12))\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tGF_AfraEntry *ae = gf_malloc(sizeof(GF_AfraEntry));\n\t\tif (!ae) return GF_OUT_OF_MEM;\n\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tae->time = gf_bs_read_u64(bs);\n\t\tif (ptr->long_offsets) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\tae->offset = gf_bs_read_u64(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\tae->offset = gf_bs_read_u32(bs);\n\t\t}\n\n\t\tgf_list_insert(ptr->local_access_entries, ae, i);\n\t}\n\n\tif (ptr->global_entries) {\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\tptr->global_entry_count = gf_bs_read_u32(bs);\n\t\tfor (i=0; i<ptr->global_entry_count; i++) {\n\t\t\tGF_GlobalAfraEntry *ae = gf_malloc(sizeof(GF_GlobalAfraEntry));\n\t\t\tif (!ae) return GF_OUT_OF_MEM;\n\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\tae->time = gf_bs_read_u64(bs);\n\t\t\tif (ptr->long_ids) {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\t\tae->segment = gf_bs_read_u32(bs);\n\t\t\t\tae->fragment = gf_bs_read_u32(bs);\n\t\t\t} else {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\t\tae->segment = gf_bs_read_u16(bs);\n\t\t\t\tae->fragment = gf_bs_read_u16(bs);\n\t\t\t}\n\t\t\tif (ptr->long_offsets) {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 16)\n\t\t\t\tae->afra_offset = gf_bs_read_u64(bs);\n\t\t\t\tae->offset_from_afra = gf_bs_read_u64(bs);\n\t\t\t} else {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\t\tae->afra_offset = gf_bs_read_u32(bs);\n\t\t\t\tae->offset_from_afra = gf_bs_read_u32(bs);\n\t\t\t}\n\n\t\t\tgf_list_insert(ptr->global_access_entries, ae, i);\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Box *afra_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AdobeFragRandomAccessBox, GF_ISOM_BOX_TYPE_AFRA);\n\ttmp->local_access_entries = gf_list_new();\n\ttmp->global_access_entries = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err afra_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tunsigned int i;\n\tGF_AdobeFragRandomAccessBox *ptr = (GF_AdobeFragRandomAccessBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, ptr->long_ids, 1);\n\tgf_bs_write_int(bs, ptr->long_offsets, 1);\n\tgf_bs_write_int(bs, ptr->global_entries, 1);\n\tgf_bs_write_int(bs, 0, 5);\n\tgf_bs_write_u32(bs, ptr->time_scale);\n\n\tgf_bs_write_u32(bs, ptr->entry_count);\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tGF_AfraEntry *ae = (GF_AfraEntry *)gf_list_get(ptr->local_access_entries, i);\n\t\tgf_bs_write_u64(bs, ae->time);\n\t\tif (ptr->long_offsets)\n\t\t\tgf_bs_write_u64(bs, ae->offset);\n\t\telse\n\t\t\tgf_bs_write_u32(bs, (u32)ae->offset);\n\t}\n\n\tif (ptr->global_entries) {\n\t\tgf_bs_write_u32(bs, ptr->global_entry_count);\n\t\tfor (i=0; i<ptr->global_entry_count; i++) {\n\t\t\tGF_GlobalAfraEntry *gae = (GF_GlobalAfraEntry *)gf_list_get(ptr->global_access_entries, i);\n\t\t\tgf_bs_write_u64(bs, gae->time);\n\t\t\tif (ptr->long_ids) {\n\t\t\t\tgf_bs_write_u32(bs, gae->segment);\n\t\t\t\tgf_bs_write_u32(bs, gae->fragment);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u16(bs, (u16)gae->segment);\n\t\t\t\tgf_bs_write_u16(bs, (u16)gae->fragment);\n\t\t\t}\n\t\t\tif (ptr->long_offsets) {\n\t\t\t\tgf_bs_write_u64(bs, gae->afra_offset);\n\t\t\t\tgf_bs_write_u64(bs, gae->offset_from_afra);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u32(bs, (u32)gae->afra_offset);\n\t\t\t\tgf_bs_write_u32(bs, (u32)gae->offset_from_afra);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\n\nGF_Err afra_box_size(GF_Box *s)\n{\n\tGF_AdobeFragRandomAccessBox *ptr = (GF_AdobeFragRandomAccessBox *)s;\n\n\ts->size += 9\n\t           + ptr->entry_count * (ptr->long_offsets ? 16 : 12)\n\t           + (ptr->global_entries ? 4 + ptr->global_entry_count * (4 + (ptr->long_offsets ? 16 : 8) + (ptr->long_ids ? 8 : 4)) : 0);\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid asrt_box_del(GF_Box *s)\n{\n\tGF_AdobeSegmentRunTableBox *ptr = (GF_AdobeSegmentRunTableBox *)s;\n\tif (ptr == NULL) return;\n\n\twhile (gf_list_count(ptr->quality_segment_url_modifiers)) {\n\t\tgf_free(gf_list_get(ptr->quality_segment_url_modifiers, 0));\n\t\tgf_list_rem(ptr->quality_segment_url_modifiers, 0);\n\t}\n\tgf_list_del(ptr->quality_segment_url_modifiers);\n\n\twhile (gf_list_count(ptr->segment_run_entry_table)) {\n\t\tgf_free(gf_list_get(ptr->segment_run_entry_table, 0));\n\t\tgf_list_rem(ptr->segment_run_entry_table, 0);\n\t}\n\tgf_list_del(ptr->segment_run_entry_table);\n\n\tgf_free(ptr);\n}\n\nGF_Err asrt_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tunsigned int i;\n\tGF_AdobeSegmentRunTableBox *ptr = (GF_AdobeSegmentRunTableBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tif (ptr->size < ptr->quality_entry_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\tu32 tmp_strsize=(u32)ptr->size;\n\t\tchar *tmp_str = (char*) gf_malloc(tmp_strsize);\n\t\tif (!tmp_str) return GF_OUT_OF_MEM;\n\t\twhile (tmp_strsize) {\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\tISOM_DECREASE_SIZE(ptr, j)\n\t\tgf_list_insert(ptr->quality_segment_url_modifiers, tmp_str, i);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->segment_run_entry_count = gf_bs_read_u32(bs);\n\tif (ptr->size < ptr->segment_run_entry_count*8)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tfor (i=0; i<ptr->segment_run_entry_count; i++) {\n\t\tGF_AdobeSegmentRunEntry *sre = gf_malloc(sizeof(GF_AdobeSegmentRunEntry));\n\t\tif (!sre) return GF_OUT_OF_MEM;\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tsre->first_segment = gf_bs_read_u32(bs);\n\t\tsre->fragment_per_segment = gf_bs_read_u32(bs);\n\t\tgf_list_insert(ptr->segment_run_entry_table, sre, i);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Box *asrt_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AdobeSegmentRunTableBox, GF_ISOM_BOX_TYPE_ASRT);\n\ttmp->quality_segment_url_modifiers = gf_list_new();\n\ttmp->segment_run_entry_table = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err asrt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tunsigned int i;\n\tGF_AdobeSegmentRunTableBox *ptr = (GF_AdobeSegmentRunTableBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->quality_entry_count);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tchar *str = (char*)gf_list_get(ptr->quality_segment_url_modifiers, i);\n\t\tgf_bs_write_data(bs, str, (u32)strlen(str) + 1);\n\t}\n\n\tgf_bs_write_u32(bs, ptr->segment_run_entry_count);\n\tfor (i=0; i<ptr->segment_run_entry_count; i++) {\n\t\tGF_AdobeSegmentRunEntry *sre = (GF_AdobeSegmentRunEntry *)gf_list_get(ptr->segment_run_entry_table, i);\n\t\tgf_bs_write_u32(bs, sre->first_segment);\n\t\tgf_bs_write_u32(bs, sre->fragment_per_segment);\n\t}\n\n\treturn GF_OK;\n}\n\n\nGF_Err asrt_box_size(GF_Box *s)\n{\n\tint i;\n\tGF_AdobeSegmentRunTableBox *ptr = (GF_AdobeSegmentRunTableBox *)s;\n\n\ts->size += 5;\n\n\tfor (i=0; i<ptr->quality_entry_count; i++)\n\t\ts->size += strlen(gf_list_get(ptr->quality_segment_url_modifiers, i)) + 1;\n\n\ts->size += ptr->segment_run_entry_count * sizeof(GF_AdobeSegmentRunEntry);\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid afrt_box_del(GF_Box *s)\n{\n\tGF_AdobeFragmentRunTableBox *ptr = (GF_AdobeFragmentRunTableBox *)s;\n\tif (ptr == NULL) return;\n\n\twhile (gf_list_count(ptr->quality_segment_url_modifiers)) {\n\t\tgf_free(gf_list_get(ptr->quality_segment_url_modifiers, 0));\n\t\tgf_list_rem(ptr->quality_segment_url_modifiers, 0);\n\t}\n\tgf_list_del(ptr->quality_segment_url_modifiers);\n\n\twhile (gf_list_count(ptr->fragment_run_entry_table)) {\n\t\tgf_free(gf_list_get(ptr->fragment_run_entry_table, 0));\n\t\tgf_list_rem(ptr->fragment_run_entry_table, 0);\n\t}\n\tgf_list_del(ptr->fragment_run_entry_table);\n\n\tgf_free(ptr);\n}\n\nGF_Err afrt_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tunsigned int i;\n\tGF_AdobeFragmentRunTableBox *ptr = (GF_AdobeFragmentRunTableBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 5)\n\tptr->timescale = gf_bs_read_u32(bs);\n\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tif (ptr->size < ptr->quality_entry_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\tu32 tmp_strsize=(u32)ptr->size-8;\n\t\tchar *tmp_str = (char*) gf_malloc(tmp_strsize);\n\t\tif (!tmp_str) return GF_OUT_OF_MEM;\n\t\twhile (tmp_strsize) {\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\tISOM_DECREASE_SIZE(ptr, j)\n\t\tgf_list_insert(ptr->quality_segment_url_modifiers, tmp_str, i);\n\t}\n\n\tptr->fragment_run_entry_count = gf_bs_read_u32(bs);\n\tif (ptr->size < ptr->fragment_run_entry_count*16)\n\t\treturn GF_ISOM_INVALID_FILE;\n\tfor (i=0; i<ptr->fragment_run_entry_count; i++) {\n\t\tGF_AdobeFragmentRunEntry *fre = gf_malloc(sizeof(GF_AdobeFragmentRunEntry));\n\t\tif (!fre) return GF_ISOM_INVALID_FILE;\n\t\tISOM_DECREASE_SIZE(ptr, 16)\n\t\tfre->first_fragment = gf_bs_read_u32(bs);\n\t\tfre->first_fragment_timestamp = gf_bs_read_u64(bs);\n\t\tfre->fragment_duration = gf_bs_read_u32(bs);\n\t\tif (!fre->fragment_duration) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\t\tfre->discontinuity_indicator = gf_bs_read_u8(bs);\n\t\t}\n\t\tgf_list_insert(ptr->fragment_run_entry_table, fre, i);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Box *afrt_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AdobeFragmentRunTableBox, GF_ISOM_BOX_TYPE_AFRT);\n\ttmp->quality_segment_url_modifiers = gf_list_new();\n\ttmp->fragment_run_entry_table = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err afrt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tunsigned int i;\n\tGF_AdobeFragmentRunTableBox *ptr = (GF_AdobeFragmentRunTableBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->timescale);\n\tgf_bs_write_u8(bs, ptr->quality_entry_count);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tchar *str = (char*)gf_list_get(ptr->quality_segment_url_modifiers, i);\n\t\tgf_bs_write_data(bs, str, (u32)strlen(str) + 1);\n\t}\n\n\tgf_bs_write_u32(bs, ptr->fragment_run_entry_count);\n\tfor (i=0; i<ptr->fragment_run_entry_count; i++) {\n\t\tGF_AdobeFragmentRunEntry *fre = (GF_AdobeFragmentRunEntry *)gf_list_get(ptr->fragment_run_entry_table, i);\n\t\tgf_bs_write_u32(bs, fre->first_fragment);\n\t\tgf_bs_write_u64(bs, fre->first_fragment_timestamp);\n\t\tgf_bs_write_u32(bs, fre->fragment_duration);\n\t\tif (!fre->fragment_duration)\n\t\t\tgf_bs_write_u8(bs, fre->discontinuity_indicator);\n\t}\n\n\treturn GF_OK;\n}\n\n\nGF_Err afrt_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_AdobeFragmentRunTableBox *ptr = (GF_AdobeFragmentRunTableBox *)s;\n\n\ts->size += 5;\n\n\tfor (i=0; i<ptr->quality_entry_count; i++)\n\t\ts->size += strlen(gf_list_get(ptr->quality_segment_url_modifiers, i)) + 1;\n\n\ts->size += 4;\n\n\tfor (i=0; i<ptr->fragment_run_entry_count; i++) {\n\t\tGF_AdobeFragmentRunEntry *fre = (GF_AdobeFragmentRunEntry *)gf_list_get(ptr->fragment_run_entry_table, i);\n\t\tif (fre->fragment_duration)\n\t\t\ts->size += 16;\n\t\telse\n\t\t\ts->size += 17;\n\t}\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n#endif /*GPAC_DISABLE_ISOM*/\n\n#endif /*GPAC_DISABLE_ISOM_ADOBE*/\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#ifndef _GF_ISOMEDIA_DEV_H_\n#define _GF_ISOMEDIA_DEV_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <gpac/isomedia.h>\n\n\nenum\n{\n\t//internal code type for unknown boxes\n\tGF_ISOM_BOX_TYPE_UNKNOWN = GF_4CC( 'U', 'N', 'K', 'N' ),\n\n\tGF_ISOM_BOX_TYPE_CO64\t= GF_4CC( 'c', 'o', '6', '4' ),\n\tGF_ISOM_BOX_TYPE_STCO\t= GF_4CC( 's', 't', 'c', 'o' ),\n\tGF_ISOM_BOX_TYPE_CTTS\t= GF_4CC( 'c', 't', 't', 's' ),\n\tGF_ISOM_BOX_TYPE_CPRT\t= GF_4CC( 'c', 'p', 'r', 't' ),\n\tGF_ISOM_BOX_TYPE_KIND\t= GF_4CC( 'k', 'i', 'n', 'd' ),\n\tGF_ISOM_BOX_TYPE_CHPL\t= GF_4CC( 'c', 'h', 'p', 'l' ),\n\tGF_ISOM_BOX_TYPE_URL\t= GF_4CC( 'u', 'r', 'l', ' ' ),\n\tGF_ISOM_BOX_TYPE_URN\t= GF_4CC( 'u', 'r', 'n', ' ' ),\n\tGF_ISOM_BOX_TYPE_DINF\t= GF_4CC( 'd', 'i', 'n', 'f' ),\n\tGF_ISOM_BOX_TYPE_DREF\t= GF_4CC( 'd', 'r', 'e', 'f' ),\n\tGF_ISOM_BOX_TYPE_STDP\t= GF_4CC( 's', 't', 'd', 'p' ),\n\tGF_ISOM_BOX_TYPE_EDTS\t= GF_4CC( 'e', 'd', 't', 's' ),\n\tGF_ISOM_BOX_TYPE_ELST\t= GF_4CC( 'e', 'l', 's', 't' ),\n\tGF_ISOM_BOX_TYPE_UUID\t= GF_4CC( 'u', 'u', 'i', 'd' ),\n\tGF_ISOM_BOX_TYPE_FREE\t= GF_4CC( 'f', 'r', 'e', 'e' ),\n\tGF_ISOM_BOX_TYPE_HDLR\t= GF_4CC( 'h', 'd', 'l', 'r' ),\n\tGF_ISOM_BOX_TYPE_GMHD\t= GF_4CC( 'g', 'm', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_HMHD\t= GF_4CC( 'h', 'm', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_HINT\t= GF_4CC( 'h', 'i', 'n', 't' ),\n\tGF_ISOM_BOX_TYPE_MDIA\t= GF_4CC( 'm', 'd', 'i', 'a' ),\n\tGF_ISOM_BOX_TYPE_ELNG\t= GF_4CC( 'e', 'l', 'n', 'g' ),\n\tGF_ISOM_BOX_TYPE_MDAT\t= GF_4CC( 'm', 'd', 'a', 't' ),\n\tGF_ISOM_BOX_TYPE_IDAT\t= GF_4CC( 'i', 'd', 'a', 't' ),\n\tGF_ISOM_BOX_TYPE_MDHD\t= GF_4CC( 'm', 'd', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_MINF\t= GF_4CC( 'm', 'i', 'n', 'f' ),\n\tGF_ISOM_BOX_TYPE_MOOV\t= GF_4CC( 'm', 'o', 'o', 'v' ),\n\tGF_ISOM_BOX_TYPE_MVHD\t= GF_4CC( 'm', 'v', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_STSD\t= GF_4CC( 's', 't', 's', 'd' ),\n\tGF_ISOM_BOX_TYPE_STSZ\t= GF_4CC( 's', 't', 's', 'z' ),\n\tGF_ISOM_BOX_TYPE_STZ2\t= GF_4CC( 's', 't', 'z', '2' ),\n\tGF_ISOM_BOX_TYPE_STBL\t= GF_4CC( 's', 't', 'b', 'l' ),\n\tGF_ISOM_BOX_TYPE_STSC\t= GF_4CC( 's', 't', 's', 'c' ),\n\tGF_ISOM_BOX_TYPE_STSH\t= GF_4CC( 's', 't', 's', 'h' ),\n\tGF_ISOM_BOX_TYPE_SKIP\t= GF_4CC( 's', 'k', 'i', 'p' ),\n\tGF_ISOM_BOX_TYPE_SMHD\t= GF_4CC( 's', 'm', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_STSS\t= GF_4CC( 's', 't', 's', 's' ),\n\tGF_ISOM_BOX_TYPE_STTS\t= GF_4CC( 's', 't', 't', 's' ),\n\tGF_ISOM_BOX_TYPE_TRAK\t= GF_4CC( 't', 'r', 'a', 'k' ),\n\tGF_ISOM_BOX_TYPE_TKHD\t= GF_4CC( 't', 'k', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_TREF\t= GF_4CC( 't', 'r', 'e', 'f' ),\n\tGF_ISOM_BOX_TYPE_STRK\t= GF_4CC( 's', 't', 'r', 'k' ),\n\tGF_ISOM_BOX_TYPE_STRI\t= GF_4CC( 's', 't', 'r', 'i' ),\n\tGF_ISOM_BOX_TYPE_STRD\t= GF_4CC( 's', 't', 'r', 'd' ),\n\tGF_ISOM_BOX_TYPE_STSG\t= GF_4CC( 's', 't', 's', 'g' ),\n\n\tGF_ISOM_BOX_TYPE_UDTA\t= GF_4CC( 'u', 'd', 't', 'a' ),\n\tGF_ISOM_BOX_TYPE_VMHD\t= GF_4CC( 'v', 'm', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_FTYP\t= GF_4CC( 'f', 't', 'y', 'p' ),\n\tGF_ISOM_BOX_TYPE_OTYP\t= GF_4CC( 'o', 't', 'y', 'p' ),\n\tGF_ISOM_BOX_TYPE_PADB\t= GF_4CC( 'p', 'a', 'd', 'b' ),\n\tGF_ISOM_BOX_TYPE_PDIN\t= GF_4CC( 'p', 'd', 'i', 'n' ),\n\tGF_ISOM_BOX_TYPE_SDTP\t= GF_4CC( 's', 'd', 't', 'p' ),\n\tGF_ISOM_BOX_TYPE_CSLG\t= GF_4CC( 'c', 's', 'l', 'g' ),\n\n\tGF_ISOM_BOX_TYPE_SBGP\t= GF_4CC( 's', 'b', 'g', 'p' ),\n\tGF_ISOM_BOX_TYPE_SGPD\t= GF_4CC( 's', 'g', 'p', 'd' ),\n\tGF_ISOM_BOX_TYPE_SAIZ\t= GF_4CC( 's', 'a', 'i', 'z' ),\n\tGF_ISOM_BOX_TYPE_SAIO\t= GF_4CC( 's', 'a', 'i', 'o' ),\n\tGF_ISOM_BOX_TYPE_MFRA\t= GF_4CC( 'm', 'f', 'r', 'a' ),\n\tGF_ISOM_BOX_TYPE_MFRO\t= GF_4CC( 'm', 'f', 'r', 'o' ),\n\tGF_ISOM_BOX_TYPE_TFRA\t= GF_4CC( 't', 'f', 'r', 'a' ),\n\tGF_ISOM_BOX_TYPE_CSGP\t= GF_4CC( 'c', 's', 'g', 'p'),\n\n\tGF_ISOM_BOX_TYPE_TENC\t= GF_4CC( 't', 'e', 'n', 'c' ),\n\n\t//track group\n\tGF_ISOM_BOX_TYPE_TRGR\t= GF_4CC( 't', 'r', 'g', 'r' ),\n\t//track group types\n\tGF_ISOM_BOX_TYPE_TRGT\t= GF_4CC( 't', 'r', 'g', 't' ),\n\tGF_ISOM_BOX_TYPE_MSRC\t= GF_4CC( 'm', 's', 'r', 'c' ),\n\tGF_ISOM_BOX_TYPE_CSTG\t= GF_4CC( 'c', 's', 't', 'g' ),\n\tGF_ISOM_BOX_TYPE_STER\t= GF_4CC( 's', 't', 'e', 'r' ),\n\n\t/*Adobe's protection boxes*/\n\tGF_ISOM_BOX_TYPE_ADKM\t= GF_4CC( 'a', 'd', 'k', 'm' ),\n\tGF_ISOM_BOX_TYPE_AHDR\t= GF_4CC( 'a', 'h', 'd', 'r' ),\n\tGF_ISOM_BOX_TYPE_ADAF\t= GF_4CC( 'a', 'd', 'a', 'f' ),\n\tGF_ISOM_BOX_TYPE_APRM\t= GF_4CC( 'a', 'p', 'r', 'm' ),\n\tGF_ISOM_BOX_TYPE_AEIB\t= GF_4CC( 'a', 'e', 'i', 'b' ),\n\tGF_ISOM_BOX_TYPE_AKEY\t= GF_4CC( 'a', 'k', 'e', 'y' ),\n\tGF_ISOM_BOX_TYPE_FLXS\t= GF_4CC( 'f', 'l', 'x', 's' ),\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t/*Movie Fragments*/\n\tGF_ISOM_BOX_TYPE_MVEX\t= GF_4CC( 'm', 'v', 'e', 'x' ),\n\tGF_ISOM_BOX_TYPE_MEHD\t= GF_4CC( 'm', 'e', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_TREX\t= GF_4CC( 't', 'r', 'e', 'x' ),\n\tGF_ISOM_BOX_TYPE_TREP\t= GF_4CC( 't', 'r', 'e', 'p' ),\n\tGF_ISOM_BOX_TYPE_MOOF\t= GF_4CC( 'm', 'o', 'o', 'f' ),\n\tGF_ISOM_BOX_TYPE_MFHD\t= GF_4CC( 'm', 'f', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_TRAF\t= GF_4CC( 't', 'r', 'a', 'f' ),\n\tGF_ISOM_BOX_TYPE_TFHD\t= GF_4CC( 't', 'f', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_TRUN\t= GF_4CC( 't', 'r', 'u', 'n' ),\n#ifdef GF_ENABLE_CTRN\n\tGF_ISOM_BOX_TYPE_CTRN\t= GF_4CC( 'c', 't', 'r', 'n' ),\n#endif\n\n#endif\n\n\n\t/*MP4 extensions*/\n\tGF_ISOM_BOX_TYPE_DPND\t= GF_4CC( 'd', 'p', 'n', 'd' ),\n\tGF_ISOM_BOX_TYPE_IODS\t= GF_4CC( 'i', 'o', 'd', 's' ),\n\tGF_ISOM_BOX_TYPE_ESDS\t= GF_4CC( 'e', 's', 'd', 's' ),\n\tGF_ISOM_BOX_TYPE_MPOD\t= GF_4CC( 'm', 'p', 'o', 'd' ),\n\tGF_ISOM_BOX_TYPE_SYNC\t= GF_4CC( 's', 'y', 'n', 'c' ),\n\tGF_ISOM_BOX_TYPE_IPIR\t= GF_4CC( 'i', 'p', 'i', 'r' ),\n\n\tGF_ISOM_BOX_TYPE_NMHD\t= GF_4CC( 'n', 'm', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_STHD\t= GF_4CC( 's', 't', 'h', 'd' ),\n\t/*reseved\n\tGF_ISOM_BOX_TYPE_SDHD\t= GF_4CC( 's', 'd', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_ODHD\t= GF_4CC( 'o', 'd', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_CRHD\t= GF_4CC( 'c', 'r', 'h', 'd' ),\n\t*/\n\tGF_ISOM_BOX_TYPE_MP4S\t= GF_4CC( 'm', 'p', '4', 's' ),\n\tGF_ISOM_BOX_TYPE_MP4A\t= GF_4CC( 'm', 'p', '4', 'a' ),\n\tGF_ISOM_BOX_TYPE_MP4V\t= GF_4CC( 'm', 'p', '4', 'v' ),\n\n\n\t/*AVC / H264 extension*/\n\tGF_ISOM_BOX_TYPE_AVCC\t= GF_4CC( 'a', 'v', 'c', 'C' ),\n\tGF_ISOM_BOX_TYPE_BTRT\t= GF_4CC( 'b', 't', 'r', 't' ),\n\tGF_ISOM_BOX_TYPE_M4DS\t= GF_4CC( 'm', '4', 'd', 's' ),\n\tGF_ISOM_BOX_TYPE_PASP\t= GF_4CC( 'p', 'a', 's', 'p' ),\n\tGF_ISOM_BOX_TYPE_CLAP\t= GF_4CC( 'c', 'l', 'a', 'p' ),\n\tGF_ISOM_BOX_TYPE_AVC1\t= GF_4CC( 'a', 'v', 'c', '1' ),\n\tGF_ISOM_BOX_TYPE_AVC2\t= GF_4CC( 'a', 'v', 'c', '2' ),\n\tGF_ISOM_BOX_TYPE_AVC3\t= GF_4CC( 'a', 'v', 'c', '3' ),\n\tGF_ISOM_BOX_TYPE_AVC4\t= GF_4CC( 'a', 'v', 'c', '4' ),\n\tGF_ISOM_BOX_TYPE_SVCC\t= GF_4CC( 's', 'v', 'c', 'C' ),\n\tGF_ISOM_BOX_TYPE_SVC1\t= GF_4CC( 's', 'v', 'c', '1' ),\n\tGF_ISOM_BOX_TYPE_SVC2\t= GF_4CC( 's', 'v', 'c', '2' ),\n\tGF_ISOM_BOX_TYPE_MVCC\t= GF_4CC( 'm', 'v', 'c', 'C' ),\n\tGF_ISOM_BOX_TYPE_MVC1\t= GF_4CC( 'm', 'v', 'c', '1' ),\n\tGF_ISOM_BOX_TYPE_MVC2\t= GF_4CC( 'm', 'v', 'c', '2' ),\n\tGF_ISOM_BOX_TYPE_MHC1\t= GF_4CC( 'm', 'h', 'c', '1' ),\n\tGF_ISOM_BOX_TYPE_MHV1\t= GF_4CC( 'm', 'h', 'v', '1' ),\n\n\tGF_ISOM_BOX_TYPE_HVCC\t= GF_4CC( 'h', 'v', 'c', 'C' ),\n\tGF_ISOM_BOX_TYPE_HVC1\t= GF_4CC( 'h', 'v', 'c', '1' ),\n\tGF_ISOM_BOX_TYPE_HEV1\t= GF_4CC( 'h', 'e', 'v', '1' ),\n\tGF_ISOM_BOX_TYPE_HVT1\t= GF_4CC( 'h', 'v', 't', '1' ),\n\tGF_ISOM_BOX_TYPE_MVCI\t= GF_4CC( 'm', 'v', 'c', 'i' ),\n\tGF_ISOM_BOX_TYPE_MVCG\t= GF_4CC( 'm', 'v', 'c', 'g' ),\n\tGF_ISOM_BOX_TYPE_VWID\t= GF_4CC( 'v', 'w', 'i', 'd' ),\n\n\tGF_ISOM_BOX_TYPE_HVC2\t= GF_4CC( 'h', 'v', 'c', '2' ),\n\tGF_ISOM_BOX_TYPE_HEV2\t= GF_4CC( 'h', 'e', 'v', '2' ),\n\tGF_ISOM_BOX_TYPE_LHV1\t= GF_4CC( 'l', 'h', 'v', '1' ),\n\tGF_ISOM_BOX_TYPE_LHE1\t= GF_4CC( 'l', 'h', 'e', '1' ),\n\tGF_ISOM_BOX_TYPE_LHT1\t= GF_4CC( 'l', 'h', 't', '1' ),\n\n\tGF_ISOM_BOX_TYPE_LHVC\t= GF_4CC( 'l', 'h', 'v', 'C' ),\n\n\tGF_ISOM_BOX_TYPE_VVC1\t= GF_4CC( 'v', 'v', 'c', '1' ),\n\tGF_ISOM_BOX_TYPE_VVI1\t= GF_4CC( 'v', 'v', 'i', '1' ),\n\tGF_ISOM_BOX_TYPE_VVCC\t= GF_4CC( 'v', 'v', 'c', 'C' ),\n\n\tGF_ISOM_BOX_TYPE_AV1C = GF_4CC('a', 'v', '1', 'C'),\n\tGF_ISOM_BOX_TYPE_AV01 = GF_4CC('a', 'v', '0', '1'),\n\n\t/*WebM*/\n\tGF_ISOM_BOX_TYPE_VPCC = GF_4CC('v', 'p', 'c', 'C'),\n\tGF_ISOM_BOX_TYPE_VP08 = GF_4CC('v', 'p', '0', '8'),\n\tGF_ISOM_BOX_TYPE_VP09 = GF_4CC('v', 'p', '0', '9'),\n\tGF_ISOM_BOX_TYPE_SMDM = GF_4CC('S', 'm', 'D', 'm'),\n\tGF_ISOM_BOX_TYPE_COLL = GF_4CC('C', 'o', 'L', 'L'),\n\n\t/*Opus*/\n\tGF_ISOM_BOX_TYPE_OPUS = GF_4CC('O', 'p', 'u', 's'),\n\tGF_ISOM_BOX_TYPE_DOPS = GF_4CC('d', 'O', 'p', 's'),\n\n\t/*LASeR extension*/\n\tGF_ISOM_BOX_TYPE_LSRC\t= GF_4CC( 'l', 's', 'r', 'C' ),\n\tGF_ISOM_BOX_TYPE_LSR1\t= GF_4CC( 'l', 's', 'r', '1' ),\n\n\t/*3GPP extensions*/\n\tGF_ISOM_BOX_TYPE_DAMR\t= GF_4CC( 'd', 'a', 'm', 'r' ),\n\tGF_ISOM_BOX_TYPE_D263\t= GF_4CC( 'd', '2', '6', '3' ),\n\tGF_ISOM_BOX_TYPE_DEVC\t= GF_4CC( 'd', 'e', 'v', 'c' ),\n\tGF_ISOM_BOX_TYPE_DQCP\t= GF_4CC( 'd', 'q', 'c', 'p' ),\n\tGF_ISOM_BOX_TYPE_DSMV\t= GF_4CC( 'd', 's', 'm', 'v' ),\n\tGF_ISOM_BOX_TYPE_TSEL\t= GF_4CC( 't', 's', 'e', 'l' ),\n\n\t/* 3GPP Adaptive Streaming extensions */\n\tGF_ISOM_BOX_TYPE_STYP\t= GF_4CC( 's', 't', 'y', 'p' ),\n\tGF_ISOM_BOX_TYPE_TFDT\t= GF_4CC( 't', 'f', 'd', 't' ),\n\tGF_ISOM_BOX_TYPE_SIDX\t= GF_4CC( 's', 'i', 'd', 'x' ),\n\tGF_ISOM_BOX_TYPE_SSIX\t= GF_4CC( 's', 's', 'i', 'x' ),\n\tGF_ISOM_BOX_TYPE_LEVA   = GF_4CC( 'l', 'e', 'v', 'a' ),\n\tGF_ISOM_BOX_TYPE_PCRB\t= GF_4CC( 'p', 'c', 'r', 'b' ),\n\tGF_ISOM_BOX_TYPE_EMSG\t= GF_4CC( 'e', 'm', 's', 'g' ),\n\n\t/*3GPP text / MPEG-4 StreamingText*/\n\tGF_ISOM_BOX_TYPE_FTAB\t= GF_4CC( 'f', 't', 'a', 'b' ),\n\tGF_ISOM_BOX_TYPE_TX3G\t= GF_4CC( 't', 'x', '3', 'g' ),\n\tGF_ISOM_BOX_TYPE_STYL\t= GF_4CC( 's', 't', 'y', 'l' ),\n\tGF_ISOM_BOX_TYPE_HLIT\t= GF_4CC( 'h', 'l', 'i', 't' ),\n\tGF_ISOM_BOX_TYPE_HCLR\t= GF_4CC( 'h', 'c', 'l', 'r' ),\n\tGF_ISOM_BOX_TYPE_KROK\t= GF_4CC( 'k', 'r', 'o', 'k' ),\n\tGF_ISOM_BOX_TYPE_DLAY\t= GF_4CC( 'd', 'l', 'a', 'y' ),\n\tGF_ISOM_BOX_TYPE_HREF\t= GF_4CC( 'h', 'r', 'e', 'f' ),\n\tGF_ISOM_BOX_TYPE_TBOX\t= GF_4CC( 't', 'b', 'o', 'x' ),\n\tGF_ISOM_BOX_TYPE_BLNK\t= GF_4CC( 'b', 'l', 'n', 'k' ),\n\tGF_ISOM_BOX_TYPE_TWRP\t= GF_4CC( 't', 'w', 'r', 'p' ),\n\n\t/* ISO Base Media File Format Extensions for MPEG-21 */\n\tGF_ISOM_BOX_TYPE_META\t= GF_4CC( 'm', 'e', 't', 'a' ),\n\tGF_ISOM_BOX_TYPE_XML\t= GF_4CC( 'x', 'm', 'l', ' ' ),\n\tGF_ISOM_BOX_TYPE_BXML\t= GF_4CC( 'b', 'x', 'm', 'l' ),\n\tGF_ISOM_BOX_TYPE_ILOC\t= GF_4CC( 'i', 'l', 'o', 'c' ),\n\tGF_ISOM_BOX_TYPE_PITM\t= GF_4CC( 'p', 'i', 't', 'm' ),\n\tGF_ISOM_BOX_TYPE_IPRO\t= GF_4CC( 'i', 'p', 'r', 'o' ),\n\tGF_ISOM_BOX_TYPE_INFE\t= GF_4CC( 'i', 'n', 'f', 'e' ),\n\tGF_ISOM_BOX_TYPE_IINF\t= GF_4CC( 'i', 'i', 'n', 'f' ),\n\tGF_ISOM_BOX_TYPE_IREF\t= GF_4CC( 'i', 'r', 'e', 'f' ),\n\tGF_ISOM_BOX_TYPE_ENCA\t= GF_4CC( 'e', 'n', 'c', 'a' ),\n\tGF_ISOM_BOX_TYPE_ENCV\t= GF_4CC( 'e', 'n', 'c', 'v' ),\n\tGF_ISOM_BOX_TYPE_RESV\t= GF_4CC( 'r', 'e', 's', 'v' ),\n\tGF_ISOM_BOX_TYPE_ENCT\t= GF_4CC( 'e', 'n', 'c', 't' ),\n\tGF_ISOM_BOX_TYPE_ENCS\t= GF_4CC( 'e', 'n', 'c', 's' ),\n\tGF_ISOM_BOX_TYPE_ENCF\t= GF_4CC( 'e', 'n', 'c', 'f' ),\n\tGF_ISOM_BOX_TYPE_ENCM\t= GF_4CC( 'e', 'n', 'c', 'm' ),\n\tGF_ISOM_BOX_TYPE_SINF\t= GF_4CC( 's', 'i', 'n', 'f' ),\n\tGF_ISOM_BOX_TYPE_RINF\t= GF_4CC( 'r', 'i', 'n', 'f' ),\n\tGF_ISOM_BOX_TYPE_FRMA\t= GF_4CC( 'f', 'r', 'm', 'a' ),\n\tGF_ISOM_BOX_TYPE_SCHM\t= GF_4CC( 's', 'c', 'h', 'm' ),\n\tGF_ISOM_BOX_TYPE_SCHI\t= GF_4CC( 's', 'c', 'h', 'i' ),\n\n\tGF_ISOM_BOX_TYPE_STVI\t= GF_4CC( 's', 't', 'v', 'i' ),\n\n\n\tGF_ISOM_BOX_TYPE_METX\t= GF_4CC( 'm', 'e', 't', 'x' ),\n\tGF_ISOM_BOX_TYPE_METT\t= GF_4CC( 'm', 'e', 't', 't' ),\n\n\t/* ISMA 1.0 Encryption and Authentication V 1.0 */\n\tGF_ISOM_BOX_TYPE_IKMS\t= GF_4CC( 'i', 'K', 'M', 'S' ),\n\tGF_ISOM_BOX_TYPE_ISFM\t= GF_4CC( 'i', 'S', 'F', 'M' ),\n\tGF_ISOM_BOX_TYPE_ISLT\t= GF_4CC( 'i', 'S', 'L', 'T' ),\n\n\t/* Hinting boxes */\n\tGF_ISOM_BOX_TYPE_RTP_STSD\t= GF_4CC( 'r', 't', 'p', ' ' ),\n\tGF_ISOM_BOX_TYPE_SRTP_STSD\t= GF_4CC( 's', 'r', 't', 'p' ),\n\tGF_ISOM_BOX_TYPE_FDP_STSD\t= GF_4CC( 'f', 'd', 'p', ' ' ),\n\tGF_ISOM_BOX_TYPE_RRTP_STSD\t= GF_4CC( 'r', 'r', 't', 'p' ),\n\tGF_ISOM_BOX_TYPE_RTCP_STSD\t= GF_4CC( 'r', 't', 'c', 'p' ),\n\tGF_ISOM_BOX_TYPE_HNTI\t= GF_4CC( 'h', 'n', 't', 'i' ),\n\tGF_ISOM_BOX_TYPE_RTP\t= GF_4CC( 'r', 't', 'p', ' ' ),\n\tGF_ISOM_BOX_TYPE_SDP\t= GF_4CC( 's', 'd', 'p', ' ' ),\n\tGF_ISOM_BOX_TYPE_HINF\t= GF_4CC( 'h', 'i', 'n', 'f' ),\n\tGF_ISOM_BOX_TYPE_NAME\t= GF_4CC( 'n', 'a', 'm', 'e' ),\n\tGF_ISOM_BOX_TYPE_TRPY\t= GF_4CC( 't', 'r', 'p', 'y' ),\n\tGF_ISOM_BOX_TYPE_NUMP\t= GF_4CC( 'n', 'u', 'm', 'p' ),\n\tGF_ISOM_BOX_TYPE_TOTL\t= GF_4CC( 't', 'o', 't', 'l' ),\n\tGF_ISOM_BOX_TYPE_NPCK\t= GF_4CC( 'n', 'p', 'c', 'k' ),\n\tGF_ISOM_BOX_TYPE_TPYL\t= GF_4CC( 't', 'p', 'y', 'l' ),\n\tGF_ISOM_BOX_TYPE_TPAY\t= GF_4CC( 't', 'p', 'a', 'y' ),\n\tGF_ISOM_BOX_TYPE_MAXR\t= GF_4CC( 'm', 'a', 'x', 'r' ),\n\tGF_ISOM_BOX_TYPE_DMED\t= GF_4CC( 'd', 'm', 'e', 'd' ),\n\tGF_ISOM_BOX_TYPE_DIMM\t= GF_4CC( 'd', 'i', 'm', 'm' ),\n\tGF_ISOM_BOX_TYPE_DREP\t= GF_4CC( 'd', 'r', 'e', 'p' ),\n\tGF_ISOM_BOX_TYPE_TMIN\t= GF_4CC( 't', 'm', 'i', 'n' ),\n\tGF_ISOM_BOX_TYPE_TMAX\t= GF_4CC( 't', 'm', 'a', 'x' ),\n\tGF_ISOM_BOX_TYPE_PMAX\t= GF_4CC( 'p', 'm', 'a', 'x' ),\n\tGF_ISOM_BOX_TYPE_DMAX\t= GF_4CC( 'd', 'm', 'a', 'x' ),\n\tGF_ISOM_BOX_TYPE_PAYT\t= GF_4CC( 'p', 'a', 'y', 't' ),\n\tGF_ISOM_BOX_TYPE_RELY\t= GF_4CC( 'r', 'e', 'l', 'y' ),\n\tGF_ISOM_BOX_TYPE_TIMS\t= GF_4CC( 't', 'i', 'm', 's' ),\n\tGF_ISOM_BOX_TYPE_TSRO\t= GF_4CC( 't', 's', 'r', 'o' ),\n\tGF_ISOM_BOX_TYPE_SNRO\t= GF_4CC( 's', 'n', 'r', 'o' ),\n\tGF_ISOM_BOX_TYPE_RTPO\t= GF_4CC( 'r', 't', 'p', 'o' ),\n\tGF_ISOM_BOX_TYPE_TSSY\t= GF_4CC( 't', 's', 's', 'y' ),\n\tGF_ISOM_BOX_TYPE_RSSR\t= GF_4CC( 'r', 's', 's', 'r' ),\n\tGF_ISOM_BOX_TYPE_SRPP\t= GF_4CC( 's', 'r', 'p', 'p' ),\n\n\t//FEC boxes\n\tGF_ISOM_BOX_TYPE_FIIN\t= GF_4CC( 'f', 'i', 'i', 'n' ),\n\tGF_ISOM_BOX_TYPE_PAEN\t= GF_4CC( 'p', 'a', 'e', 'n' ),\n\tGF_ISOM_BOX_TYPE_FPAR\t= GF_4CC( 'f', 'p', 'a', 'r' ),\n\tGF_ISOM_BOX_TYPE_FECR\t= GF_4CC( 'f', 'e', 'c', 'r' ),\n\tGF_ISOM_BOX_TYPE_SEGR\t= GF_4CC( 's', 'e', 'g', 'r' ),\n\tGF_ISOM_BOX_TYPE_GITN\t= GF_4CC( 'g', 'i', 't', 'n' ),\n\tGF_ISOM_BOX_TYPE_FIRE\t= GF_4CC( 'f', 'i', 'r', 'e' ),\n\tGF_ISOM_BOX_TYPE_FDSA\t= GF_4CC( 'f', 'd', 's', 'a' ),\n\tGF_ISOM_BOX_TYPE_FDPA\t= GF_4CC( 'f', 'd', 'p', 'a' ),\n\tGF_ISOM_BOX_TYPE_EXTR\t= GF_4CC( 'e', 'x', 't', 'r' ),\n\n\t/*internal type for track and item references*/\n\tGF_ISOM_BOX_TYPE_REFT\t= GF_4CC( 'R', 'E', 'F', 'T' ),\n\tGF_ISOM_BOX_TYPE_REFI\t= GF_4CC( 'R', 'E', 'F', 'I'),\n\tGF_ISOM_BOX_TYPE_GRPT\t= GF_4CC( 'G', 'R', 'P', 'T'),\n\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n\t/* Adobe extensions */\n\tGF_ISOM_BOX_TYPE_ABST\t= GF_4CC( 'a', 'b', 's', 't' ),\n\tGF_ISOM_BOX_TYPE_AFRA\t= GF_4CC( 'a', 'f', 'r', 'a' ),\n\tGF_ISOM_BOX_TYPE_ASRT\t= GF_4CC( 'a', 's', 'r', 't' ),\n\tGF_ISOM_BOX_TYPE_AFRT\t= GF_4CC( 'a', 'f', 'r', 't' ),\n#endif\n\n\t/* Apple extensions */\n\n\tGF_ISOM_BOX_TYPE_ILST\t= GF_4CC( 'i', 'l', 's', 't' ),\n\tGF_ISOM_BOX_TYPE_iTunesSpecificInfo\t= GF_4CC( '-', '-', '-', '-' ),\n\tGF_ISOM_BOX_TYPE_DATA\t= GF_4CC( 'd', 'a', 't', 'a' ),\n\n\tGF_ISOM_HANDLER_TYPE_MDIR\t= GF_4CC( 'm', 'd', 'i', 'r' ),\n\tGF_ISOM_BOX_TYPE_CHAP\t= GF_4CC( 'c', 'h', 'a', 'p' ),\n\tGF_ISOM_BOX_TYPE_TEXT\t= GF_4CC( 't', 'e', 'x', 't' ),\n\n\t/*OMA (P)DCF boxes*/\n\tGF_ISOM_BOX_TYPE_OHDR\t= GF_4CC( 'o', 'h', 'd', 'r' ),\n\tGF_ISOM_BOX_TYPE_GRPI\t= GF_4CC( 'g', 'r', 'p', 'i' ),\n\tGF_ISOM_BOX_TYPE_MDRI\t= GF_4CC( 'm', 'd', 'r', 'i' ),\n\tGF_ISOM_BOX_TYPE_ODTT\t= GF_4CC( 'o', 'd', 't', 't' ),\n\tGF_ISOM_BOX_TYPE_ODRB\t= GF_4CC( 'o', 'd', 'r', 'b' ),\n\tGF_ISOM_BOX_TYPE_ODKM\t= GF_4CC( 'o', 'd', 'k', 'm' ),\n\tGF_ISOM_BOX_TYPE_ODAF\t= GF_4CC( 'o', 'd', 'a', 'f' ),\n\n\t/*3GPP DIMS */\n\tGF_ISOM_BOX_TYPE_DIMS\t= GF_4CC( 'd', 'i', 'm', 's' ),\n\tGF_ISOM_BOX_TYPE_DIMC\t= GF_4CC( 'd', 'i', 'm', 'C' ),\n\tGF_ISOM_BOX_TYPE_DIST\t= GF_4CC( 'd', 'i', 'S', 'T' ),\n\n\n\tGF_ISOM_BOX_TYPE_AC3\t= GF_4CC( 'a', 'c', '-', '3' ),\n\tGF_ISOM_BOX_TYPE_DAC3\t= GF_4CC( 'd', 'a', 'c', '3' ),\n\tGF_ISOM_BOX_TYPE_EC3\t= GF_4CC( 'e', 'c', '-', '3' ),\n\tGF_ISOM_BOX_TYPE_DEC3\t= GF_4CC( 'd', 'e', 'c', '3' ),\n\tGF_ISOM_BOX_TYPE_DVCC\t= GF_4CC( 'd', 'v', 'c', 'C' ),\n\tGF_ISOM_BOX_TYPE_DVHE\t= GF_4CC( 'd', 'v', 'h', 'e' ),\n\tGF_ISOM_BOX_TYPE_MLPA\t= GF_4CC( 'm', 'l', 'p', 'a' ),\n\tGF_ISOM_BOX_TYPE_DMLP\t= GF_4CC( 'd', 'm', 'l', 'p' ),\n\n\tGF_ISOM_BOX_TYPE_SUBS\t= GF_4CC( 's', 'u', 'b', 's' ),\n\n\tGF_ISOM_BOX_TYPE_RVCC\t= GF_4CC( 'r', 'v', 'c', 'c' ),\n\n\tGF_ISOM_BOX_TYPE_VTTC_CONFIG\t= GF_4CC( 'v', 't', 't', 'C' ),\n\tGF_ISOM_BOX_TYPE_VTCC_CUE\t= GF_4CC( 'v', 't', 't', 'c' ),\n\tGF_ISOM_BOX_TYPE_VTTE\t= GF_4CC( 'v', 't', 't', 'e' ),\n\tGF_ISOM_BOX_TYPE_VTTA\t= GF_4CC( 'v', 't', 't', 'a' ),\n\tGF_ISOM_BOX_TYPE_CTIM\t= GF_4CC( 'c', 't', 'i', 'm' ),\n\tGF_ISOM_BOX_TYPE_IDEN\t= GF_4CC( 'i', 'd', 'e', 'n' ),\n\tGF_ISOM_BOX_TYPE_STTG\t= GF_4CC( 's', 't', 't', 'g' ),\n\tGF_ISOM_BOX_TYPE_PAYL\t= GF_4CC( 'p', 'a', 'y', 'l' ),\n\tGF_ISOM_BOX_TYPE_WVTT\t= GF_4CC( 'w', 'v', 't', 't' ),\n\n\tGF_ISOM_BOX_TYPE_STPP\t= GF_4CC( 's', 't', 'p', 'p' ),\n\tGF_ISOM_BOX_TYPE_SBTT\t= GF_4CC( 's', 'b', 't', 't' ),\n\n\tGF_ISOM_BOX_TYPE_STXT\t= GF_4CC( 's', 't', 'x', 't' ),\n\tGF_ISOM_BOX_TYPE_TXTC\t= GF_4CC( 't', 'x', 't', 'C' ),\n\tGF_ISOM_BOX_TYPE_MIME\t= GF_4CC( 'm', 'i', 'm', 'e' ),\n\n\tGF_ISOM_BOX_TYPE_PRFT   = GF_4CC( 'p', 'r', 'f', 't' ),\n\n\t/* Image File Format Boxes */\n\tGF_ISOM_BOX_TYPE_ISPE   = GF_4CC( 'i', 's', 'p', 'e' ),\n\tGF_ISOM_BOX_TYPE_COLR   = GF_4CC( 'c', 'o', 'l', 'r' ),\n\tGF_ISOM_BOX_TYPE_PIXI   = GF_4CC( 'p', 'i', 'x', 'i' ),\n\tGF_ISOM_BOX_TYPE_RLOC   = GF_4CC( 'r', 'l', 'o', 'c' ),\n\tGF_ISOM_BOX_TYPE_IROT   = GF_4CC( 'i', 'r', 'o', 't' ),\n\tGF_ISOM_BOX_TYPE_IMIR   = GF_4CC( 'i', 'm', 'i', 'r' ),\n\tGF_ISOM_BOX_TYPE_IPCO   = GF_4CC( 'i', 'p', 'c', 'o' ),\n\tGF_ISOM_BOX_TYPE_IPRP   = GF_4CC( 'i', 'p', 'r', 'p' ),\n\tGF_ISOM_BOX_TYPE_IPMA   = GF_4CC( 'i', 'p', 'm', 'a' ),\n\tGF_ISOM_BOX_TYPE_GRPL   = GF_4CC( 'g', 'r', 'p', 'l'),\n\tGF_ISOM_BOX_TYPE_CCST\t= GF_4CC( 'c', 'c', 's', 't' ),\n\tGF_ISOM_BOX_TYPE_AUXC\t= GF_4CC( 'a', 'u', 'x', 'C' ),\n\tGF_ISOM_BOX_TYPE_AUXI\t= GF_4CC( 'a', 'u', 'x', 'i' ),\n\tGF_ISOM_BOX_TYPE_OINF\t= GF_4CC( 'o', 'i', 'n', 'f' ),\n\tGF_ISOM_BOX_TYPE_TOLS\t= GF_4CC( 't', 'o', 'l', 's' ),\n\tGF_ISOM_BOX_TYPE_IENC\t= GF_4CC( 'i', 'e', 'n', 'c' ),\n\tGF_ISOM_BOX_TYPE_IAUX \t= GF_4CC('i', 'a', 'u', 'x'),\n\n\t/* MIAF Boxes */\n\tGF_ISOM_BOX_TYPE_CLLI\t= GF_4CC('c', 'l', 'l', 'i'),\n\tGF_ISOM_BOX_TYPE_MDCV\t= GF_4CC('m', 'd', 'c', 'v'),\n\n\tGF_ISOM_BOX_TYPE_ALTR\t= GF_4CC( 'a', 'l', 't', 'r' ),\n\n\t/*ALL INTERNAL BOXES - NEVER WRITTEN TO FILE!!*/\n\n\t/*generic handlers*/\n\tGF_ISOM_BOX_TYPE_GNRM\t= GF_4CC( 'G', 'N', 'R', 'M' ),\n\tGF_ISOM_BOX_TYPE_GNRV\t= GF_4CC( 'G', 'N', 'R', 'V' ),\n\tGF_ISOM_BOX_TYPE_GNRA\t= GF_4CC( 'G', 'N', 'R', 'A' ),\n\t/*base constructor of all hint formats (currently only RTP uses it)*/\n\tGF_ISOM_BOX_TYPE_GHNT\t= GF_4CC( 'g', 'h', 'n', 't' ),\n\t/*for compatibility with old files hinted for DSS - needs special parsing*/\n\tGF_ISOM_BOX_TYPE_VOID\t= GF_4CC( 'V', 'O', 'I', 'D' ),\n\n\t/*MS Smooth - these are actually UUID boxes*/\n\tGF_ISOM_BOX_UUID_PSSH\t= GF_4CC( 'P', 'S', 'S', 'H' ),\n\tGF_ISOM_BOX_UUID_MSSM   = GF_4CC( 'M', 'S', 'S', 'M' ), /*Stream Manifest box*/\n\tGF_ISOM_BOX_UUID_TENC\t= GF_4CC( 'T', 'E', 'N', 'C' ),\n\tGF_ISOM_BOX_UUID_TFRF\t= GF_4CC( 'T', 'F', 'R', 'F' ),\n\tGF_ISOM_BOX_UUID_TFXD\t= GF_4CC( 'T', 'F', 'X', 'D' ),\n\n\tGF_ISOM_BOX_TYPE_MP3\t= GF_4CC( '.', 'm', 'p', '3' ),\n\n\tGF_ISOM_BOX_TYPE_TRIK\t= GF_4CC( 't', 'r', 'i', 'k' ),\n\tGF_ISOM_BOX_TYPE_BLOC\t= GF_4CC( 'b', 'l', 'o', 'c' ),\n\tGF_ISOM_BOX_TYPE_AINF\t= GF_4CC( 'a', 'i', 'n', 'f' ),\n\n\t/*JPEG2000*/\n\tGF_ISOM_BOX_TYPE_MJP2\t= GF_4CC('m','j','p','2'),\n\tGF_ISOM_BOX_TYPE_IHDR\t= GF_4CC('i','h','d','r'),\n\tGF_ISOM_BOX_TYPE_JP  \t= GF_4CC('j','P',' ',' '),\n\tGF_ISOM_BOX_TYPE_JP2H\t= GF_4CC('j','p','2','h'),\n\tGF_ISOM_BOX_TYPE_JP2K\t= GF_4CC('j','p','2','k'),\n\n\tGF_ISOM_BOX_TYPE_JPEG\t= GF_4CC('j','p','e','g'),\n\tGF_ISOM_BOX_TYPE_PNG \t= GF_4CC('p','n','g',' '),\n\n\t/* apple QT box */\n\tGF_QT_BOX_TYPE_ALIS = GF_4CC('a','l','i','s'),\n\tGF_QT_BOX_TYPE_LOAD = GF_4CC('l','o','a','d'),\n\tGF_QT_BOX_TYPE_WIDE = GF_4CC('w','i','d','e'),\n\tGF_QT_BOX_TYPE_GMIN\t= GF_4CC( 'g', 'm', 'i', 'n' ),\n\tGF_QT_BOX_TYPE_TAPT\t= GF_4CC( 't', 'a', 'p', 't' ),\n\tGF_QT_BOX_TYPE_CLEF\t= GF_4CC( 'c', 'l', 'e', 'f' ),\n\tGF_QT_BOX_TYPE_PROF\t= GF_4CC( 'p', 'r', 'o', 'f' ),\n\tGF_QT_BOX_TYPE_ENOF\t= GF_4CC( 'e', 'n', 'o', 'f' ),\n\tGF_QT_BOX_TYPE_WAVE = GF_4CC('w','a','v','e'),\n\tGF_QT_BOX_TYPE_CHAN = GF_4CC('c','h','a','n'),\n\tGF_QT_BOX_TYPE_TERMINATOR \t= 0,\n\tGF_QT_BOX_TYPE_ENDA = GF_4CC('e','n','d','a'),\n\tGF_QT_BOX_TYPE_FRMA = GF_4CC('f','r','m','a'),\n\tGF_QT_BOX_TYPE_TMCD = GF_4CC('t','m','c','d'),\n\tGF_QT_BOX_TYPE_NAME = GF_4CC('n','a','m','e'),\n\tGF_QT_BOX_TYPE_TCMI = GF_4CC('t','c','m','i'),\n\tGF_QT_BOX_TYPE_FIEL = GF_4CC('f','i','e','l'),\n\tGF_QT_BOX_TYPE_GAMA = GF_4CC('g','a','m','a'),\n\tGF_QT_BOX_TYPE_CHRM = GF_4CC('c','h','r','m'),\n\n\t/* from drm_sample.c */\n\tGF_ISOM_BOX_TYPE_264B \t= GF_4CC('2','6','4','b'),\n\tGF_ISOM_BOX_TYPE_265B \t= GF_4CC('2','6','5','b'),\n\n\t/*MPEG-H 3D audio*/\n\tGF_ISOM_BOX_TYPE_MHA1 \t= GF_4CC('m','h','a','1'),\n\tGF_ISOM_BOX_TYPE_MHA2 \t= GF_4CC('m','h','a','2'),\n\tGF_ISOM_BOX_TYPE_MHM1 \t= GF_4CC('m','h','m','1'),\n\tGF_ISOM_BOX_TYPE_MHM2 \t= GF_4CC('m','h','m','2'),\n\tGF_ISOM_BOX_TYPE_MHAC \t= GF_4CC('m','h','a','C'),\n\tGF_ISOM_BOX_TYPE_MHAP \t= GF_4CC('m','h','a','P'),\n\n\tGF_ISOM_BOX_TYPE_IPCM \t= GF_4CC('i','p','c','m'),\n\tGF_ISOM_BOX_TYPE_FPCM \t= GF_4CC('f','p','c','m'),\n\tGF_ISOM_BOX_TYPE_PCMC \t= GF_4CC('p','c','m','C'),\n\n\tGF_ISOM_BOX_TYPE_CHNL \t= GF_4CC('c','h','n','l'),\n\n\tGF_ISOM_BOX_TYPE_AUXV \t= GF_4CC('A','U','X','V'),\n\n\tGF_ISOM_BOX_TYPE_FLAC\t= GF_4CC( 'f', 'L', 'a', 'C' ),\n\tGF_ISOM_BOX_TYPE_DFLA\t= GF_4CC( 'd', 'f', 'L', 'a' ),\n\n\t//internal only\n\tGF_QT_SUBTYPE_RAW_AUD \t= GF_4CC('Q','T','R','A'),\n\tGF_QT_SUBTYPE_RAW_VID \t= GF_4CC('Q','T','R','V'),\n\n\tGF_ISOM_BOX_TYPE_XTRA\t= GF_4CC( 'X', 't', 'r', 'a' ),\n\n\tGF_ISOM_BOX_TYPE_ST3D\t= GF_4CC( 's', 't', '3', 'd' ),\n\tGF_ISOM_BOX_TYPE_SV3D\t= GF_4CC( 's', 'v', '3', 'd' ),\n\tGF_ISOM_BOX_TYPE_SVHD\t= GF_4CC( 's', 'v', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_PROJ\t= GF_4CC( 'p', 'r', 'o', 'j' ),\n\tGF_ISOM_BOX_TYPE_PRHD\t= GF_4CC( 'p', 'r', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_CBMP\t= GF_4CC( 'c', 'b', 'm', 'p' ),\n\tGF_ISOM_BOX_TYPE_EQUI\t= GF_4CC( 'e', 'q', 'u', 'i' ),\n\tGF_ISOM_BOX_TYPE_MSHP\t= GF_4CC( 'm', 's', 'h', 'p' ),\n\tGF_ISOM_BOX_TYPE_MESH\t= GF_4CC( 'm', 'e', 's', 'h' ),\n};\n\nenum\n{\n\tGF_ISOM_SAMPLE_ENTRY_UNKN = 0,\n\tGF_ISOM_SAMPLE_ENTRY_VIDEO = GF_4CC('v','i','d','e'),\n\tGF_ISOM_SAMPLE_ENTRY_AUDIO = GF_4CC('a','u','d','i'),\n\tGF_ISOM_SAMPLE_ENTRY_MP4S = GF_4CC('m','p','4','s')\n\n};\n\n\n/* bitstream cookies used by isobmff lib*/\n#define GF_ISOM_BS_COOKIE_NO_LOGS\t\t1\n#define GF_ISOM_BS_COOKIE_VISUAL_TRACK\t(1<<1)\n#define GF_ISOM_BS_COOKIE_QT_CONV\t\t(1<<2)\n#define GF_ISOM_BS_COOKIE_CLONE_TRACK\t(1<<3)\n\n\n#ifndef GPAC_DISABLE_ISOM\n\n\n#if defined(GPAC_DISABLE_ISOM_FRAGMENTS) && !defined(GPAC_DISABLE_ISOM_ADOBE)\n#define GPAC_DISABLE_ISOM_ADOBE\n#endif\n\n//internal flags (up to 16)\n//if flag is set, position checking of child boxes is ignored\n#define GF_ISOM_ORDER_FREEZE 1\n#define GF_ISOM_BOX_COMPRESSED 2\n\n\t/*the default size is 64, cause we need to handle large boxes...\n\n\tthe child_boxes container is by default NOT created. When parsing a box and sub-boxes are detected, the list is created.\n\tThis list is destroyed before calling the final box destructor\n\tThis list is automatically taken into account during size() and write() functions, and\n\tgf_isom_box_write shall not be called in XXXX_box_write on any box registered with the child list\n\n\tthe full box version field is moved in the base box since we also need some internal flags, as u16 to\n\talso be used for audio and video sample entries version field\n\t*/\n#define GF_ISOM_BOX\t\t\t\\\n\tu32 type;\t\t\t\t\\\n\tu64 size;\t\t\t\t\\\n\tconst struct box_registry_entry *registry;\\\n\tGF_List *child_boxes; \t\\\n\tu16 internal_flags;\t\t\\\n\tu16 version;\t\t\t\t\\\n\n#define GF_ISOM_FULL_BOX\t\t\\\n\tGF_ISOM_BOX\t\t\t\\\n\tu32 flags;\t\t\t\\\n\n#define GF_ISOM_UUID_BOX\t\\\n\tGF_ISOM_BOX\t\t\t\\\n\tu8 uuid[16];\t\t\\\n\tu32 internal_4cc;\t\t\\\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n} GF_Box;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n} GF_FullBox;\n\ntypedef struct\n{\n\tGF_ISOM_UUID_BOX\n} GF_UUIDBox;\n\n\n#define ISOM_DECL_BOX_ALLOC(__TYPE, __4cc)\t__TYPE *tmp; \\\n\tGF_SAFEALLOC(tmp, __TYPE);\t\\\n\tif (tmp==NULL) return NULL;\t\\\n\ttmp->type = __4cc;\n\n#define ISOM_DECREASE_SIZE(__ptr, bytes)\tif (__ptr->size < (bytes) ) {\\\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isom] not enough bytes in box %s: %d left, reading %d (file %s, line %d)\\n\", gf_4cc_to_str(__ptr->type), (u32) __ptr->size, (bytes), __FILE__, __LINE__ )); \\\n\t\t\treturn GF_ISOM_INVALID_FILE; \\\n\t\t}\\\n\t\t__ptr->size -= bytes; \\\n\n#define ISOM_DECREASE_SIZE_GOTO_EXIT(__ptr, bytes)\tif (__ptr->size < (bytes) ) {\\\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isom] not enough bytes in box %s: %d left, reading %d (file %s, line %d)\\n\", gf_4cc_to_str(__ptr->type), (u32) __ptr->size, (bytes), __FILE__, __LINE__ )); \\\n\t\t\te = GF_ISOM_INVALID_FILE; \\\n\t\t\tgoto exit;\\\n\t\t}\\\n\t\t__ptr->size -= bytes; \\\n\n\n#define ISOM_DECREASE_SIZE_NO_ERR(__ptr, bytes)\tif (__ptr->size < (bytes) ) {\\\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isom] not enough bytes in box %s: %d left, reading %d (file %s, line %d), skipping box\\n\", gf_4cc_to_str(__ptr->type), (u32) __ptr->size, (bytes), __FILE__, __LINE__ )); \\\n\t\t\treturn GF_OK; \\\n\t\t}\\\n\t\t__ptr->size -= bytes; \\\n\n\n/*constructor*/\nGF_Box *gf_isom_box_new(u32 boxType);\n//some boxes may have different syntax based on container. Use this constructor for this case\nGF_Box *gf_isom_box_new_ex(u32 boxType, u32 parentType, Bool skip_logs, Bool is_root_box);\n\nGF_Err gf_isom_box_write(GF_Box *ptr, GF_BitStream *bs);\nGF_Err gf_isom_box_read(GF_Box *ptr, GF_BitStream *bs);\nvoid gf_isom_box_del(GF_Box *ptr);\nGF_Err gf_isom_box_size(GF_Box *ptr);\n\nGF_Err gf_isom_clone_box(GF_Box *src, GF_Box **dst);\n\nGF_Err gf_isom_box_parse(GF_Box **outBox, GF_BitStream *bs);\nGF_Err gf_isom_box_array_read(GF_Box *s, GF_BitStream *bs);\nGF_Err gf_isom_box_array_read_ex(GF_Box *parent, GF_BitStream *bs, u32 parent_type);\n\nGF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type, Bool is_root_box);\n\n//writes box header - shall be called at the beginning of each xxxx_Write function\n//this function is not factorized in order to let box serializer modify box type before writing\nGF_Err gf_isom_box_write_header(GF_Box *ptr, GF_BitStream *bs);\n\n//writes box header then version+flags\nGF_Err gf_isom_full_box_write(GF_Box *s, GF_BitStream *bs);\n\nvoid gf_isom_box_array_reset(GF_List *boxlist);\nvoid gf_isom_box_array_del(GF_List *child_boxes);\nGF_Err gf_isom_box_array_write(GF_Box *parent, GF_List *list, GF_BitStream *bs);\nGF_Err gf_isom_box_array_size(GF_Box *parent, GF_List *list);\n\nvoid gf_isom_check_position(GF_Box *s, GF_Box *child, u32 *pos);\nvoid gf_isom_check_position_list(GF_Box *s, GF_List *childlist, u32 *pos);\n\nBool gf_box_valid_in_parent(GF_Box *a, const char *parent_4cc);\n\nvoid gf_isom_box_array_del_parent(GF_List **child_boxes, GF_List *boxlist);\nvoid gf_isom_box_array_reset_parent(GF_List **child_boxes, GF_List *boxlist);\n\nvoid gf_isom_box_freeze_order(GF_Box *box);\n\n#define BOX_FIELD_ASSIGN(_field, _box_cast) \\\n\tif (is_rem) {\\\n\t\tptr->_field = NULL;\\\n\t\treturn GF_OK;\\\n\t} else {\\\n\t\tif (ptr->_field) ERROR_ON_DUPLICATED_BOX(a, ptr)\\\n\t\tptr->_field = (_box_cast *)a;\\\n\t}\n\n#define BOX_FIELD_LIST_ASSIGN(_field) \\\n\tif (is_rem) {\\\n\t\tgf_list_del_item(ptr->_field, a);\\\n\t} else {\\\n\t\tif (!ptr->_field) ptr->_field = gf_list_new();\\\n\t\tGF_Err _e = gf_list_add(ptr->_field, a);\\\n\t\tif (_e) return _e;\\\n\t}\n\n\nvoid gf_isom_box_remove_from_parent(GF_Box *parent_box, GF_Box *box);\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\t/*note: the data is NEVER loaded to the mdat in this lib*/\n\tu64 dataSize;\n\t/* store the file offset when parsing to access the raw data */\n\tu64 bsOffset;\n\tu8 *data;\n} GF_MediaDataBox;\n\ntypedef struct\n{\n  u64 time;\n  u64 moof_offset;\n  u32 traf_number;\n  u32 trun_number;\n  u32 sample_number;\n} GF_RandomAccessEntry;\n\ntypedef struct\n{\n  GF_ISOM_FULL_BOX\n  GF_ISOTrackID track_id;\n  u8 traf_bits;\n  u8 trun_bits;\n  u8 sample_bits;\n  u32 nb_entries;\n  GF_RandomAccessEntry *entries;\n} GF_TrackFragmentRandomAccessBox;\n\ntypedef struct\n{\n  GF_ISOM_FULL_BOX\n\tu32 container_size;\n} GF_MovieFragmentRandomAccessOffsetBox;\n\ntypedef struct\n{\n  GF_ISOM_BOX\n  GF_List* tfra_list;\n  GF_MovieFragmentRandomAccessOffsetBox *mfro;\n} GF_MovieFragmentRandomAccessBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu8 *data;\n\tu32 dataSize;\n\tu32 original_4cc;\n} GF_UnknownBox;\n\ntypedef struct\n{\n\tGF_ISOM_UUID_BOX\n\tu8 *data;\n\tu32 dataSize;\n} GF_UnknownUUIDBox;\n\nu32 gf_isom_solve_uuid_box(u8 *UUID);\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu64 creationTime;\n\tu64 modificationTime;\n\tu32 timeScale;\n\tu64 duration;\n\tu64 original_duration;\n\tGF_ISOTrackID nextTrackID;\n\tu32 preferredRate;\n\tu16 preferredVolume;\n\tchar reserved[10];\n\tu32 matrixA;\n\tu32 matrixB;\n\tu32 matrixU;\n\tu32 matrixC;\n\tu32 matrixD;\n\tu32 matrixV;\n\tu32 matrixW;\n\tu32 matrixX;\n\tu32 matrixY;\n\tu32 previewTime;\n\tu32 previewDuration;\n\tu32 posterTime;\n\tu32 selectionTime;\n\tu32 selectionDuration;\n\tu32 currentTime;\n} GF_MovieHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_Descriptor *descriptor;\n} GF_ObjectDescriptorBox;\n\n/*used for entry list*/\ntypedef struct\n{\n\tu64 segmentDuration;\n\ts64 mediaTime;\n\tu32 mediaRate;\n\tBool was_empty_dur;\n} GF_EdtsEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *entryList;\n} GF_EditListBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_EditListBox *editList;\n} GF_EditBox;\n\n\n/*used to classify boxes in the UserData GF_Box*/\ntypedef struct\n{\n\tu32 boxType;\n\tu8 uuid[16];\n\tGF_List *boxes;\n} GF_UserDataMap;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_List *recordList;\n} GF_UserDataBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_MovieHeaderBox *mvhd;\n\tGF_ObjectDescriptorBox *iods;\n\tGF_UserDataBox *udta;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tstruct __tag_mvex_box *mvex;\n#endif\n\t/*meta box if any*/\n\tstruct __tag_meta_box *meta;\n\t/*track boxes*/\n\tGF_List *trackList;\n\n\tGF_ISOFile *mov;\n\n\tBool mvex_after_traks;\n\t//for compressed mov, stores the difference between compressed and uncompressed payload\n\ts32 compressed_diff;\n\t//for compressed mov, indicates the file offset of the moov box start\n\tu64 file_offset;\n\n} GF_MovieBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu64 creationTime;\n\tu64 modificationTime;\n\tGF_ISOTrackID trackID;\n\tu32 reserved1;\n\tu64 duration;\n\tu32 reserved2[2];\n\tu16 layer;\n\tu16 alternate_group;\n\tu16 volume;\n\tu16 reserved3;\n\ts32 matrix[9];\n\tu32 width, height;\n\tu64 initial_duration;\n} GF_TrackHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n} GF_TrackReferenceBox;\n\n\ntypedef struct {\n\tGF_ISOM_BOX\n\tGF_List *groups;\n} GF_TrackGroupBox;\n\ntypedef struct {\n\tGF_ISOM_FULL_BOX\n\tu32 group_type;\n\tu32 track_group_id;\n} GF_TrackGroupTypeBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_UserDataBox *udta;\n\tGF_TrackHeaderBox *Header;\n\tstruct __tag_media_box *Media;\n\tGF_EditBox *editBox;\n\tGF_TrackReferenceBox *References;\n\t/*meta box if any*/\n\tstruct __tag_meta_box *meta;\n\tGF_TrackGroupBox *groups;\n\n\tGF_Box *Aperture;\n\t\n\tGF_MovieBox *moov;\n\t/*private for media padding*/\n\tu32 padding_bytes;\n\t/*private for editing*/\n\tBool is_unpacked;\n\t/*private for checking dependency*/\n\tu32 originalFile;\n\tu32 originalID;\n\n\t//not sure about piff (not supposed to be stored in moov), but senc is in track according to CENC\n\tstruct __sample_encryption_box *sample_encryption;\n\n\t/*private for SVC/MVC extractors resolution*/\n\tGF_ISONaluExtractMode extractor_mode;\n\tBool has_base_layer;\n\tu32 pack_num_samples;\n\n\tu64 magic;\n\tu32 index;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tu64 first_dts_chunk;\n\tu32 nb_samples_in_cache;\n\tu32 chunk_stsd_idx;\n\tu32 chunk_cache_size;\n\tGF_BitStream *chunk_cache;\n#endif\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tu64 dts_at_seg_start;\n\tu32 sample_count_at_seg_start;\n\tBool first_traf_merged;\n\tBool present_in_scalable_segment;\n\tu32 current_traf_stsd_idx;\n\n\tu64 last_tfxd_value;\n\tstruct __traf_mss_timeref_box *tfrf;\n\tu64 dts_at_next_seg_start;\n#endif\n} GF_TrackBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu64 creationTime;\n\tu64 modificationTime;\n\tu32 timeScale;\n\tu64 duration, original_duration;\n\tchar packedLanguage[4];\n\tu16 reserved;\n} GF_MediaHeaderBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 reserved1;\n\tu32 handlerType;\n\tu8 reserved2[12];\n\tchar *nameUTF8;\n\tBool store_counted_string;\n} GF_HandlerBox;\n\ntypedef struct __tag_media_box\n{\n\tGF_ISOM_BOX\n\tGF_TrackBox *mediaTrack;\n\tGF_MediaHeaderBox *mediaHeader;\n\tGF_HandlerBox *handler;\n\tstruct __tag_media_info_box *information;\n\tu64 BytesMissing;\n\n\t//all the following are only used for NALU-based tracks\n\t//NALU reader\n\tGF_BitStream *nalu_parser;\n\n\tGF_BitStream *nalu_out_bs;\n\tGF_BitStream *nalu_ps_bs;\n\tu8 *in_sample_buffer;\n\tu32 in_sample_buffer_alloc;\n\tu8 *tmp_nal_copy_buffer;\n\tu32 tmp_nal_copy_buffer_alloc;\n\n\tGF_ISOSample *extracted_samp;\n\tGF_BitStream *extracted_bs;\n\n} GF_MediaBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tchar *extended_language;\n} GF_ExtendedLanguageBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu64 reserved;\n} GF_VideoMediaHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\n\tu16 graphics_mode;\n\tu16 op_color_red;\n\tu16 op_color_green;\n\tu16 op_color_blue;\n\tu16 balance;\n\tu16 reserved;\n} GF_GenericMediaHeaderInfoBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu16 balance;\n\tu16 reserved;\n} GF_SoundMediaHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\t/*this is used for us INTERNALLY*/\n\tu32 subType;\n\tu32 maxPDUSize;\n\tu32 avgPDUSize;\n\tu32 maxBitrate;\n\tu32 avgBitrate;\n\tu32 slidingAverageBitrate;\n} GF_HintMediaHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n} GF_MPEGMediaHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n} GF_SubtitleMediaHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n} GF_ODMediaHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n} GF_OCRMediaHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n} GF_SceneMediaHeaderBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\n\tu32 width;\n\tu32 height;\n} GF_ApertureBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n} GF_DataReferenceBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_DataReferenceBox *dref;\n} GF_DataInformationBox;\n\n#define GF_ISOM_DATAENTRY_FIELDS\t\\\n\tchar *location;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_ISOM_DATAENTRY_FIELDS\n} GF_DataEntryBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_ISOM_DATAENTRY_FIELDS\n} GF_DataEntryURLBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_ISOM_DATAENTRY_FIELDS\n} GF_DataEntryAliasBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_ISOM_DATAENTRY_FIELDS\n\tchar *nameURN;\n} GF_DataEntryURNBox;\n\ntypedef struct\n{\n\tu32 sampleCount;\n\tu32 sampleDelta;\n} GF_SttsEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_SttsEntry *entries;\n\tu32 nb_entries, alloc_size;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t/*cache for WRITE*/\n\tu32 w_currentSampleNum;\n\tu64 w_LastDTS;\n#endif\n\t/*cache for READ*/\n\tu32 r_FirstSampleInEntry;\n\tu32 r_currentEntryIndex;\n\tu64 r_CurrentDTS;\n\n\t//stats for read\n\tu32 max_ts_delta;\n} GF_TimeToSampleBox;\n\n\n/*TO CHECK - it could be reasonnable to only use 16bits for both count and offset*/\ntypedef struct\n{\n\tu32 sampleCount;\n\ts32 decodingOffset;\n} GF_DttsEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_DttsEntry *entries;\n\tu32 nb_entries, alloc_size;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tu32 w_LastSampleNumber;\n\t/*force one sample per entry*/\n\tBool unpack_mode;\n#endif\n\t/*Cache for read*/\n\tu32 r_currentEntryIndex;\n\tu32 r_FirstSampleInEntry;\n\n\t//stats for read\n\ts32 max_ts_delta;\n} GF_CompositionOffsetBox;\n\n\n#define GF_ISOM_SAMPLE_ENTRY_FIELDS\t\t\\\n\tGF_ISOM_UUID_BOX\t\t\t\t\t\\\n\tu16 dataReferenceIndex;\t\t\t\t\\\n\tchar reserved[ 6 ];\t\t\t\t\t\\\n\tu32 internal_type;\t\t\t\t\t\\\n\n/*base sample entry box - used by some generic media sample descriptions of QT*/\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\n} GF_SampleEntryBox;\n\nvoid gf_isom_sample_entry_init(GF_SampleEntryBox *ptr);\nvoid gf_isom_sample_entry_predestroy(GF_SampleEntryBox *ptr);\nGF_Err gf_isom_base_sample_entry_read(GF_SampleEntryBox *ptr, GF_BitStream *bs);\n\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\n\t/*box type as specified in the file (not this box's type!!)*/\n\tu32 EntryType;\n\n\tu8 *data;\n\tu32 data_size;\n} GF_GenericSampleEntryBox;\n\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\n\n\tu32 flags;\n\tu32 timescale;\n\tu32 frame_duration;\n\tu8 frames_per_counter_tick;\n} GF_TimeCodeSampleEntryBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\n    u16 text_font;\n    u16 text_face;\n    u16 text_size;\n    u16 text_color_red, text_color_green, text_color_blue;\n    u16 back_color_red, back_color_green, back_color_blue;\n    char *font;\n} GF_TimeCodeMediaInformationBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\n    u8 field_count;\n    u8 field_order;\n} GF_FieldInfoBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n    u32 gama;\n} GF_GamaInfoBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n    u16 chroma;\n} GF_ChromaInfoBox;\n\ntypedef struct\n{\n    u32 label;\n    u32 flags;\n    Float coordinates[3];\n} GF_AudioChannelDescription;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\n    u32 layout_tag;\n    u32 bitmap;\n    u32 num_audio_description;\n    GF_AudioChannelDescription *audio_descs;\n    u8 *ext_data;\n    u32 ext_data_size;\n} GF_ChannelLayoutInfoBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\n    u32 preload_start_time;\n    u32 preload_duration;\n    u32 preload_flags;\n    u32 default_hints;\n} GF_TrackLoadBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\n\tGF_AudioChannelLayout layout;\n} GF_ChannelLayoutBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_ESD *desc;\n} GF_ESDBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 bufferSizeDB;\n\tu32 maxBitrate;\n\tu32 avgBitrate;\n} GF_BitRateBox;\n\nGF_BitRateBox *gf_isom_sample_entry_get_bitrate(GF_SampleEntryBox *ent, Bool create);\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_List *descriptors;\n} GF_MPEG4ExtensionDescriptorsBox;\n\n/*for most MPEG4 media */\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\n\tGF_ESDBox *esd;\n\t/*used for hinting when extracting the OD stream...*/\n\tGF_SLConfig *slc;\n} GF_MPEGSampleEntryBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu8 *hdr;\n\tu32 hdr_size;\n} GF_LASERConfigurationBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\n\n\tGF_LASERConfigurationBox *lsr_config;\n\tGF_MPEG4ExtensionDescriptorsBox *descr;\n\n\t/*used for hinting when extracting the OD stream...*/\n\tGF_SLConfig *slc;\n} GF_LASeRSampleEntryBox;\n\n/*rewrites avcC based on the given esd - this destroys the esd*/\nGF_Err LSR_UpdateESD(GF_LASeRSampleEntryBox *lsr, GF_ESD *esd);\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 hSpacing;\n\tu32 vSpacing;\n} GF_PixelAspectRatioBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 cleanApertureWidthN;\n\tu32 cleanApertureWidthD;\n\tu32 cleanApertureHeightN;\n\tu32 cleanApertureHeightD;\n\tu32 horizOffN;\n\tu32 horizOffD;\n\tu32 vertOffN;\n\tu32 vertOffD;\n} GF_CleanApertureBox;\n\n\ntypedef struct __ContentLightLevel {\n\tGF_ISOM_BOX\n\tGF_ContentLightLevelInfo clli;\n} GF_ContentLightLevelBox;\n\ntypedef struct ___MasteringDisplayColourVolume {\n\tGF_ISOM_BOX\n\tGF_MasteringDisplayColourVolumeInfo mdcv;\n} GF_MasteringDisplayColourVolumeBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tBool all_ref_pics_intra;\n\tBool intra_pred_used;\n\tu32 max_ref_per_pic;\n\tu32 reserved;\n} GF_CodingConstraintsBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tchar *aux_track_type;\n} GF_AuxiliaryTypeInfoBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu16 predefined_rvc_config;\n\tu32 rvc_meta_idx;\n} GF_RVCConfigurationBox;\n\n\ntypedef struct {\n\tGF_ISOM_BOX\n\tBool is_jp2;\n\n\tu32 colour_type;\n\tu16 colour_primaries;\n\tu16 transfer_characteristics;\n\tu16 matrix_coefficients;\n\tBool full_range_flag;\n\tu8 *opaque;\n\tu32 opaque_size;\n\n\tu8 method, precedence, approx;\n} GF_ColourInformationBox;\n\n\n//do NOT extend this structure with boxes, children boxes shall go into the other_box field of the parent\n#define GF_ISOM_VISUAL_SAMPLE_ENTRY\t\t\\\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\t\t\t\\\n\tu16 revision;\t\t\t\t\t\t\\\n\tu32 vendor;\t\t\t\t\t\t\t\\\n\tu32 temporal_quality;\t\t\t\t\\\n\tu32 spatial_quality;\t\t\t\t\\\n\tu16 Width, Height;\t\t\t\t\t\\\n\tu32 horiz_res, vert_res;\t\t\t\\\n\tu32 entry_data_size;\t\t\t\t\\\n\tu16 frames_per_sample;\t\t\t\t\\\n\tchar compressor_name[33];\t\t\t\\\n\tu16 bit_depth;\t\t\t\t\t\t\\\n\ts16 color_table_index;\t\t\t\t\\\n\tstruct __tag_protect_box *rinf; \t\\\n\ntypedef struct\n{\n\tGF_ISOM_VISUAL_SAMPLE_ENTRY\n} GF_VisualSampleEntryBox;\n\nvoid gf_isom_video_sample_entry_init(GF_VisualSampleEntryBox *ent);\nGF_Err gf_isom_video_sample_entry_read(GF_VisualSampleEntryBox *ptr, GF_BitStream *bs);\n#ifndef GPAC_DISABLE_ISOM_WRITE\nvoid gf_isom_video_sample_entry_write(GF_VisualSampleEntryBox *ent, GF_BitStream *bs);\nvoid gf_isom_video_sample_entry_size(GF_VisualSampleEntryBox *ent);\n#endif\n\nvoid gf_isom_sample_entry_predestroy(GF_SampleEntryBox *ptr);\n\n\nGF_Box *gf_isom_box_find_child(GF_List *parent_child_list, u32 code);\nvoid gf_isom_box_del_parent(GF_List **parent_child_list, GF_Box*b);\nGF_Box *gf_isom_box_new_parent(GF_List **parent_child_list, u32 code);\nBool gf_isom_box_check_unique(GF_List *children, GF_Box *a);\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_AVCConfig *config;\n} GF_AVCConfigurationBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_HEVCConfig *config;\n} GF_HEVCConfigurationBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_VVCConfig *config;\n} GF_VVCConfigurationBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_AV1Config *config;\n} GF_AV1ConfigurationBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_VPConfig *config;\n} GF_VPConfigurationBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu16 primaryRChromaticity_x;\n\tu16 primaryRChromaticity_y;\n\tu16 primaryGChromaticity_x;\n\tu16 primaryGChromaticity_y;\n\tu16 primaryBChromaticity_x;\n\tu16 primaryBChromaticity_y;\n\tu16 whitePointChromaticity_x;\n\tu16 whitePointChromaticity_y;\n\tu32 luminanceMax;\n\tu32 luminanceMin;\n} GF_SMPTE2086MasteringDisplayMetadataBox;\n\ntypedef struct {\n\tGF_ISOM_FULL_BOX\n\t\tu16 maxCLL;\n\tu16 maxFALL;\n} GF_VPContentLightLevelBox;\n\ntypedef struct {\n\tGF_ISOM_BOX\n\tGF_DOVIDecoderConfigurationRecord DOVIConfig;\n} GF_DOVIConfigurationBox;\n\n/*typedef struct { //extends Box('hvcE')\n\tGF_ISOM_BOX\n\tGF_HEVCConfig HEVCConfig;\n} GF_DolbyVisionELHEVCConfigurationBox;*/\n\ntypedef struct { //extends HEVCSampleEntry('dvhe')\n\tGF_DOVIConfigurationBox config;\n\t//TODO: GF_DolbyVisionELHEVCConfigurationBox ELConfig; // optional\n} GF_DolbyVisionHEVCSampleEntry;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_3GPConfig cfg;\n} GF_3GPPConfigBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\n\tu32 width, height;\n\tu16 nb_comp;\n\tu8 bpc, Comp, UnkC, IPR;\n} GF_J2KImageHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_J2KImageHeaderBox *ihdr;\n\tGF_ColourInformationBox *colr;\n} GF_J2KHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_VISUAL_SAMPLE_ENTRY\n\tGF_ESDBox *esd;\n\t/*used for Publishing*/\n\tGF_SLConfig *slc;\n\n\t/*avc extensions - we merged with regular 'mp4v' box to handle isma E&A signaling of AVC*/\n\tGF_AVCConfigurationBox *avc_config;\n\tGF_AVCConfigurationBox *svc_config;\n\tGF_AVCConfigurationBox *mvc_config;\n\t/*hevc extension*/\n\tGF_HEVCConfigurationBox *hevc_config;\n\tGF_HEVCConfigurationBox *lhvc_config;\n\t/*vvc extension*/\n\tGF_VVCConfigurationBox *vvc_config;\n\t/*av1 extension*/\n\tGF_AV1ConfigurationBox *av1_config;\n\t/*vp8-9 extension*/\n\tGF_VPConfigurationBox *vp_config;\n\t/*jp2k extension*/\n\tGF_J2KHeaderBox *jp2h;\n\t/*dolbyvision extension*/\n\tGF_DOVIConfigurationBox *dovi_config;\n\n\t/*internally emulated esd*/\n\tGF_ESD *emul_esd;\n\n\t//3GPP\n\tGF_3GPPConfigBox *cfg_3gpp;\n\n\t/*iPod's hack*/\n\tGF_UnknownUUIDBox *ipod_ext;\n\n} GF_MPEGVisualSampleEntryBox;\n\nstatic const u8 GF_ISOM_IPOD_EXT[][16] = { { 0x6B, 0x68, 0x40, 0xF2, 0x5F, 0x24, 0x4F, 0xC5, 0xBA, 0x39, 0xA5, 0x1B, 0xCF, 0x03, 0x23, 0xF3} };\n\nBool gf_isom_is_nalu_based_entry(GF_MediaBox *mdia, GF_SampleEntryBox *_entry);\nGF_Err gf_isom_nalu_sample_rewrite(GF_MediaBox *mdia, GF_ISOSample *sample, u32 sampleNumber, GF_MPEGVisualSampleEntryBox *entry);\n\n/*this is the default visual sdst (to handle unknown media)*/\ntypedef struct\n{\n\tGF_ISOM_VISUAL_SAMPLE_ENTRY\n\t/*box type as specified in the file (not this box's type!!)*/\n\tu32 EntryType;\n\t/*opaque description data (ESDS in MP4, SMI in SVQ3, ...)*/\n\tu8 *data;\n\tu32 data_size;\n} GF_GenericVisualSampleEntryBox;\n\nenum\n{\n\tGF_ISOM_AUDIO_QTFF_NONE = 0,\n\t//sample entry is QTFF and data in extensions() is NOT valid (conversion done by libisomedia)\n\tGF_ISOM_AUDIO_QTFF_ON_NOEXT,\n\t//sample entry is QTFF and data in extensions() is valid (import from QT)\n\tGF_ISOM_AUDIO_QTFF_ON_EXT_VALID,\n\tGF_ISOM_AUDIO_QTFF_CONVERT_FLAG = 1<<16\n};\n\n#define GF_ISOM_AUDIO_SAMPLE_ENTRY\t\\\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\t\t\\\n\tu16 revision;\t\t\t\t\t\\\n\tu32 vendor;\t\t\t\t\t\t\\\n\tu16 channel_count;\t\t\t\t\\\n\tu16 bitspersample;\t\t\t\t\\\n\tu16 compression_id;\t\t\t\t\\\n\tu16 packet_size;\t\t\t\t\\\n\tu32 qtff_mode;\t\t\t\t\t\\\n\tu16 samplerate_hi;\t\t\t\t\\\n\tu16 samplerate_lo;\t\t\t\t\\\n\tu8 extensions[36];\t\t\t\t\\\n\n\ntypedef struct\n{\n\tGF_ISOM_AUDIO_SAMPLE_ENTRY\n} GF_AudioSampleEntryBox;\n\nvoid gf_isom_audio_sample_entry_init(GF_AudioSampleEntryBox *ptr);\nGF_Err gf_isom_audio_sample_entry_read(GF_AudioSampleEntryBox *ptr, GF_BitStream *bs);\n#ifndef GPAC_DISABLE_ISOM_WRITE\nvoid gf_isom_audio_sample_entry_write(GF_AudioSampleEntryBox *ptr, GF_BitStream *bs);\nvoid gf_isom_audio_sample_entry_size(GF_AudioSampleEntryBox *ptr);\n#endif\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_AC3Config cfg;\n} GF_AC3ConfigBox;\n\n\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 format_info;\n\tu16 peak_data_rate;\n} GF_TrueHDConfigBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu8 *data;\n\tu32 dataSize;\n} GF_FLACConfigBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu8 stereo_type;\n} GF_Stereo3DBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tchar *string;\n} GF_SphericalVideoInfoBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\ts32 yaw;\n\ts32 pitch;\n\ts32 roll;\n} GF_ProjectionHeaderBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\t//cube map\n\tu32 layout;\n\ts32 padding;\n\t//EQR\n\tu32 bounds_top, bounds_bottom, bounds_left, bounds_right;\n\t//mesh\n\tu32 crc;\n\ts32 encoding_4cc;\n\n} GF_ProjectionTypeBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\n\t/*OpusSpecificBox*/\n\t/*u8 version;              //1, field included in base box structure */\n\tu8 OutputChannelCount;   //same value as the *Output Channel Count* field in the identification header defined in Ogg Opus [3]\n\tu16 PreSkip;             //The value of the PreSkip field shall be at least 80 milliseconds' worth of PCM samples even when removing any number of Opus samples which may or may not contain the priming samples. The PreSkip field is not used for discarding the priming samples at the whole playback at all since it is informative only, and that task falls on the Edit List Box.\n\tu32 InputSampleRate;     //The InputSampleRate field shall be set to the same value as the *Input Sample Rate* field in the identification header defined in Ogg Opus\n\ts16 OutputGain;          //The OutputGain field shall be set to the same value as the *Output Gain* field in the identification header define in Ogg Opus [3]. Note that the value is stored as 8.8 fixed-point.\n\tu8 ChannelMappingFamily; //The ChannelMappingFamily field shall be set to the same value as the *Channel Mapping Family* field in the identification header defined in Ogg Opus [3]. Note that the value 255 may be used for an alternative to map channels by ISO Base Media native mapping. The details are described in 4.5.1.\n\n\tu8 StreamCount; // The StreamCount field shall be set to the same value as the *Stream Count* field in the identification header defined in Ogg Opus [3].\n\tu8 CoupledCount; // The CoupledCount field shall be set to the same value as the *Coupled Count* field in the identification header defined in Ogg Opus [3].\n\tu8 ChannelMapping[255]; // The ChannelMapping field shall be set to the same octet string as *Channel Mapping* field in the identi- fication header defined in Ogg Opus [3].\n\n\t/*for internal box use only*/\n//\tint channels;\n} GF_OpusSpecificBox;\n\nGF_Err gf_isom_opus_config_new(GF_ISOFile *the_file, u32 trackNumber, GF_OpusSpecificBox *cfg, char *URLname, char *URNname, u32 *outDescriptionIndex);\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu8 configuration_version;\n\tu8 mha_pl_indication;\n\tu8 reference_channel_layout;\n\tu16 mha_config_size;\n\tchar *mha_config;\n} GF_MHAConfigBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu8 num_profiles;\n\tu8 *compat_profiles;\n} GF_MHACompatibleProfilesBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu8 format_flags;\n\tu8 PCM_sample_size;\n} GF_PCMConfigBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_AUDIO_SAMPLE_ENTRY\n\t//for MPEG4 audio\n\tGF_ESDBox *esd;\n\tGF_SLConfig *slc;\n\t//for 3GPP audio\n\tGF_3GPPConfigBox *cfg_3gpp;\n\n\t//for AC3/EC3 audio\n\tGF_AC3ConfigBox *cfg_ac3;\n\n\t//for AC3/EC3 audio\n\tGF_TrueHDConfigBox *cfg_mlp;\n\n\t//for Opus\n\tGF_OpusSpecificBox *cfg_opus;\n\n\t//for MPEG-H audio\n\tGF_MHAConfigBox *cfg_mha;\n\n\t//for FLAC\n\tGF_FLACConfigBox *cfg_flac;\n\n} GF_MPEGAudioSampleEntryBox;\n\n/*this is the default visual sdst (to handle unknown media)*/\ntypedef struct\n{\n\tGF_ISOM_AUDIO_SAMPLE_ENTRY\n\t/*box type as specified in the file (not this box's type!!)*/\n\tu32 EntryType;\n\t/*opaque description data (ESDS in MP4, ...)*/\n\tu8 *data;\n\tu32 data_size;\n} GF_GenericAudioSampleEntryBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu8 profile;\n\tu8 level;\n\tu8 pathComponents;\n\tBool fullRequestHost;\n\tBool streamType;\n\tu8 containsRedundant;\n\tchar *textEncoding;\n\tchar *contentEncoding;\n} GF_DIMSSceneConfigBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tchar *content_script_types;\n} GF_DIMSScriptTypesBox;\n\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\n\tGF_DIMSSceneConfigBox *config;\n\tGF_DIMSScriptTypesBox *scripts;\n} GF_DIMSSampleEntryBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tchar *config;\n} GF_TextConfigBox;\n\n/*base metadata sample entry box for METT, METX, SBTT, STXT and STPP*/\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\n\tchar *content_encoding;\t//optional\n\tchar *mime_type; //for anything except metx\n\tchar *xml_namespace;\t//for metx and sttp only\n\tchar *xml_schema_loc;\t// for metx and sttp only\n\tGF_TextConfigBox *config; //optional for anything except metx and sttp\n} GF_MetaDataSampleEntryBox;\n\n\ntypedef struct\n{\n\tu8 entry_type;\n\tunion {\n\t\tu32 trackID;\n\t\tu32 output_view_id;\n\t\tu32 start_view_id;\n\t};\n\tunion {\n\t\tu16 tierID;\n\t\tu16 view_count;\n\t};\n} MVCIEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 multiview_group_id;\n\tu16 num_entries;\n\tMVCIEntry *entries;\n} GF_MultiviewGroupBox;\n\ntypedef struct\n{\n\tu8 dep_comp_idc;\n\tu16 ref_view_id;\n} ViewIDRefViewEntry;\n\ntypedef struct\n{\n\tu16 view_id;\n\tu16 view_order_index;\n\tu8 texture_in_stream;\n\tu8 texture_in_track;\n\tu8 depth_in_stream;\n\tu8 depth_in_track;\n\tu8 base_view_type;\n\tu16 num_ref_views;\n\tViewIDRefViewEntry *view_refs;\n} ViewIDEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu8 min_temporal_id;\n\tu8 max_temporal_id;\n\tu16 num_views;\n\tViewIDEntry *views;\n} GF_ViewIdentifierBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n} GF_SampleDescriptionBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\t/*if this is the compact version, sample size is actually fieldSize*/\n\tu32 sampleSize;\n\tu32 sampleCount;\n\tu32 alloc_size;\n\tu32 *sizes;\n\t//stats for read\n\tu32 max_size;\n\tu64 total_size;\n\tu32 total_samples;\n} GF_SampleSizeBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 nb_entries;\n\tu32 alloc_size;\n\tu32 *offsets;\n} GF_ChunkOffsetBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 nb_entries;\n\tu32 alloc_size;\n\tu64 *offsets;\n} GF_ChunkLargeOffsetBox;\n\ntypedef struct\n{\n\tu32 firstChunk;\n\tu32 nextChunk;\n\tu32 samplesPerChunk;\n\tu32 sampleDescriptionIndex;\n\tu8 isEdited;\n} GF_StscEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_StscEntry *entries;\n\tu32 alloc_size, nb_entries;\n\n\t/*0-based cache for READ. In WRITE mode, we always have 1 sample per chunk so no need for a cache*/\n\tu32 currentIndex;\n\t/*first sample number in this chunk*/\n\tu32 firstSampleInCurrentChunk;\n\tu32 currentChunk;\n\tu32 ghostNumber;\n\n\tu32 w_lastSampleNumber;\n\tu32 w_lastChunkNumber;\n} GF_SampleToChunkBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 alloc_size, nb_entries;\n\tu32 *sampleNumbers;\n\t/*cache for READ mode (in write we realloc no matter what)*/\n\tu32 r_LastSyncSample;\n\t/*0-based index in the array*/\n\tu32 r_LastSampleIndex;\n} GF_SyncSampleBox;\n\ntypedef struct\n{\n\tu32 shadowedSampleNumber;\n\ts32 syncSampleNumber;\n} GF_StshEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *entries;\n\t/*Cache for read mode*/\n\tu32 r_LastEntryIndex;\n\tu32 r_LastFoundSample;\n} GF_ShadowSyncBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 nb_entries;\n\tu16 *priorities;\n} GF_DegradationPriorityBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 SampleCount;\n\tu8 *padbits;\n} GF_PaddingBitsBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 sampleCount, sample_alloc;\n\t/*each dep type is packed on 1 byte*/\n\tu8 *sample_info;\n} GF_SampleDependencyTypeBox;\n\n\ntypedef struct\n{\n\tu32 subsample_size;\n\tu8 subsample_priority;\n\tu8 discardable;\n\tu32 reserved;\n} GF_SubSampleEntry;\n\ntypedef struct\n{\n\tu32 sample_delta;\n\tGF_List *SubSamples;\n} GF_SubSampleInfoEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *Samples;\n} GF_SubSampleInformationBox;\n\nBool gf_isom_get_subsample_types(GF_ISOFile *movie, u32 track, u32 subs_index, u32 *flags);\nu32  gf_isom_sample_get_subsample_entry(GF_ISOFile *movie, u32 track, u32 sampleNumber, u32 entry_index, GF_SubSampleInfoEntry **sub_sample);\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err gf_isom_add_subsample_info(GF_SubSampleInformationBox *sub_samples, u32 sampleNumber, u32 subSampleSize, u8 priority, u32 reserved, Bool discardable);\n#endif\n\n/* Use to relate the composition and decoding timeline when signed composition is used*/\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\n\ts32 compositionToDTSShift;\n\ts32 leastDecodeToDisplayDelta;\n\ts32 greatestDecodeToDisplayDelta;\n\ts32 compositionStartTime;\n\ts32 compositionEndTime;\n} GF_CompositionToDecodeBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\n\tu32 aux_info_type;\n\tu32 aux_info_type_parameter;\n\n\tu8 default_sample_info_size;\n\tu32 sample_count, sample_alloc;\n\tu8 *sample_info_size;\n\n\tu32 cached_sample_num;\n\tu32 cached_prev_size;\n} GF_SampleAuxiliaryInfoSizeBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\n\tu32 aux_info_type;\n\tu32 aux_info_type_parameter;\n\n\tu8 default_sample_info_size;\n\tu32 entry_count;  //1 or stco / trun count\n\tu32 entry_alloc;\n\tu64 *offsets;\n\n\tu64 offset_first_offset_field;\n\n\tu32 total_size;\n\tu8 *cached_data;\n} GF_SampleAuxiliaryInfoOffsetBox;\n\ntypedef struct\n{\n\tu32 sample_num;\n\tu8 *moof_template;\n\tu32 moof_template_size;\n\tu64 seg_start_plus_one;\n\tu64 sidx_start;\n\tu64 sidx_end;\n\tu64 moof_start;\n\tu64 mdat_end;\n} GF_TrafMapEntry;\n\ntypedef struct\n{\n\tu32 nb_entries, nb_alloc;\n\tGF_TrafMapEntry *frag_starts;\n} GF_TrafToSampleMap;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_TimeToSampleBox *TimeToSample;\n\tGF_CompositionOffsetBox *CompositionOffset;\n\tGF_CompositionToDecodeBox *CompositionToDecode;\n\tGF_SyncSampleBox *SyncSample;\n\tGF_SampleDescriptionBox *SampleDescription;\n\tGF_SampleSizeBox *SampleSize;\n\tGF_SampleToChunkBox *SampleToChunk;\n\t/*untyped, to handle 32 bits and 64 bits chunkOffsets*/\n\tGF_Box *ChunkOffset;\n\tGF_ShadowSyncBox *ShadowSync;\n\tGF_DegradationPriorityBox *DegradationPriority;\n\tGF_PaddingBitsBox *PaddingBits;\n\tGF_SampleDependencyTypeBox *SampleDep;\n\n\tGF_TrafToSampleMap *traf_map;\n\n\tGF_List *sub_samples;\n\n\tGF_List *sampleGroups;\n\tGF_List *compactSampleGroups;\n\tGF_List *sampleGroupsDescription;\n\tu32 nb_sgpd_in_stbl;\n\tu32 nb_stbl_boxes;\n\n\tGF_List *sai_sizes;\n\tGF_List *sai_offsets;\n\n\tu32 MaxSamplePerChunk, MaxChunkSize;\n\tu16 groupID;\n\tu16 trackPriority;\n\tu32 currentEntryIndex;\n\n\tBool no_sync_found;\n\n\tu32 r_last_chunk_num, r_last_sample_num, r_last_offset_in_chunk;\n\tu8 patch_piff_psec;\n} GF_SampleTableBox;\n\nGF_Err stbl_AppendTrafMap(GF_SampleTableBox *stbl, Bool is_seg_start, u64 seg_start_offset, u64 frag_start_offset, u8 *moof_template, u32 moof_template_size, u64 sidx_start, u64 sidx_end);\n\ntypedef struct __tag_media_info_box\n{\n\tGF_ISOM_BOX\n\tGF_DataInformationBox *dataInformation;\n\tGF_SampleTableBox *sampleTable;\n\tGF_Box *InfoHeader;\n\tstruct __tag_data_map *scalableDataHandler;\n\tstruct __tag_data_map *dataHandler;\n\tu32 dataEntryIndex;\n} GF_MediaInformationBox;\n\nGF_Err stbl_SetDependencyType(GF_SampleTableBox *stbl, u32 sampleNumber, u32 isLeading, u32 dependsOn, u32 dependedOn, u32 redundant);\nGF_Err stbl_AppendDependencyType(GF_SampleTableBox *stbl, u32 isLeading, u32 dependsOn, u32 dependedOn, u32 redundant);\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu8 *data;\n\tu32 dataSize;\n\tu32 original_4cc;\n} GF_FreeSpaceBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n} GF_WideBox; /*Apple*/\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tchar packedLanguageCode[4];\n\tchar *notice;\n} GF_CopyrightBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tchar *schemeURI;\n\tchar *value;\n} GF_KindBox;\n\n\ntypedef struct\n{\n\tchar *name;\n\tu64 start_time;\n} GF_ChapterEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *list;\n} GF_ChapterListBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 reference_type;\n\tu32 trackIDCount;\n\tGF_ISOTrackID *trackIDs;\n} GF_TrackReferenceTypeBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 grouping_type;\n\tu32 group_id;\n\tu32 entity_id_count;\n\tu32 *entity_ids;\n} GF_EntityToGroupTypeBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 majorBrand;\n\tu32 minorVersion;\n\tu32 altCount;\n\tu32 *altBrand;\n} GF_FileTypeBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 *rates;\n\tu32 *times;\n\tu32 count;\n} GF_ProgressiveDownloadBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 switch_group;\n\tu32 alternate_group;\n\tGF_ISOTrackID sub_track_id;\n\tu64 attribute_count;\n\tu32 *attribute_list;\n} GF_SubTrackInformationBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 grouping_type;\n\tu16 nb_groups;\n\tu32 *group_description_index;\n} GF_SubTrackSampleGroupBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_SubTrackInformationBox *info;\n\tGF_Box *strd;\n} GF_SubTrackBox;\n\n/*\n\t3GPP streaming text boxes\n*/\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 entry_count;\n\tGF_FontRecord *fonts;\n} GF_FontTableBox;\n\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\t\t\t\t\\\n\tu32 displayFlags;\n\ts8 horizontal_justification;\n\ts8 vertical_justification;\n\t/*ARGB*/\n\tu32 back_color;\n\tGF_BoxRecord default_box;\n\tGF_StyleRecord\tdefault_style;\n\tGF_FontTableBox *font_table;\n} GF_Tx3gSampleEntryBox;\n\n/*Apple specific*/\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\t\t\t\t\\\n\tu32 displayFlags;\n\tu32 textJustification;\n\tchar background_color[6], foreground_color[6];\n\tGF_BoxRecord default_box;\n\tu16 fontNumber;\n\tu16 fontFace;\n\tchar reserved1[8];\n\tu8 reserved2;\n\tu16 reserved3;\n\tchar *textName; /*font name*/\n} GF_TextSampleEntryBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 entry_count;\n\tGF_StyleRecord *styles;\n} GF_TextStyleBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu16 startcharoffset;\n\tu16 endcharoffset;\n} GF_TextHighlightBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\t/*ARGB*/\n\tu32 hil_color;\n} GF_TextHighlightColorBox;\n\ntypedef struct\n{\n\tu32 highlight_endtime;\n\tu16 start_charoffset;\n\tu16 end_charoffset;\n} KaraokeRecord;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 highlight_starttime;\n\tu16 nb_entries;\n\tKaraokeRecord *records;\n} GF_TextKaraokeBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 scroll_delay;\n} GF_TextScrollDelayBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu16 startcharoffset;\n\tu16 endcharoffset;\n\tchar *URL;\n\tchar *URL_hint;\n} GF_TextHyperTextBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_BoxRecord box;\n} GF_TextBoxBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu16 startcharoffset;\n\tu16 endcharoffset;\n} GF_TextBlinkBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu8 wrap_flag;\n} GF_TextWrapBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 switchGroup;\n\tu32 *attributeList;\n\tu32 attributeListCount;\n} GF_TrackSelectionBox;\n\n/*\n\tMPEG-21 extensions\n*/\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tchar *xml;\n} GF_XMLBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 data_length;\n\tu8 *data;\n} GF_BinaryXMLBox;\n\n\ntypedef struct\n{\n\tu16 item_ID;\n\tu16 construction_method;\n\tu16 data_reference_index;\n\tu64 base_offset;\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t/*for storage only*/\n\tu64 original_base_offset;\n#endif\n\tGF_List *extent_entries;\n} GF_ItemLocationEntry;\n\nvoid iloc_entry_del(GF_ItemLocationEntry *location);\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu8 offset_size;\n\tu8 length_size;\n\tu8 base_offset_size;\n\tu8 index_size;\n\tGF_List *location_entries;\n} GF_ItemLocationBox;\n\ntypedef\tstruct\n{\n\tGF_ISOM_FULL_BOX\n\tu16 item_ID;\n} GF_PrimaryItemBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *protection_information;\n} GF_ItemProtectionBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu16 item_ID;\n\tu16 item_protection_index;\n\tu32 item_type;\n\t/*zero-terminated strings*/\n\tchar *item_name;\n\tchar *content_type;\n\tchar *content_encoding;\n\t// needed to actually read the resource file, but not written in the MP21 file.\n\tchar *full_path;\n\t// if not 0, full_path is actually the data to write.\n\tu32 data_len;\n\n\tu32 tk_id, sample_num;\n} GF_ItemInfoEntryBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *item_infos;\n} GF_ItemInfoBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 reference_type;\n\tu32 from_item_id;\n\tu32 reference_count;\n\tu32 *to_item_IDs;\n} GF_ItemReferenceTypeBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *references;\n} GF_ItemReferenceBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 data_format;\n} GF_OriginalFormatBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 scheme_type;\n\tu32 scheme_version;\n\tchar *URI;\n} GF_SchemeTypeBox;\n\n/*ISMACryp specific*/\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\t/*zero-terminated string*/\n\tchar *URI;\n} GF_ISMAKMSBox;\n\n/*ISMACryp specific*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu64 salt;\n} GF_ISMACrypSaltBox;\n\n/*ISMACryp specific*/\ntypedef struct __isma_format_box\n{\n\tGF_ISOM_FULL_BOX\n\tu8 selective_encryption;\n\tu8 key_indicator_length;\n\tu8 IV_length;\n} GF_ISMASampleFormatBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_ISMAKMSBox *ikms;\n\tGF_ISMASampleFormatBox *isfm;\n\tGF_ISMACrypSaltBox *islt;\n\tstruct __oma_kms_box *odkm;\n\tstruct __cenc_tenc_box *tenc;\n\tstruct __piff_tenc_box *piff_tenc;\n\tstruct __adobe_drm_key_management_system_box *adkm;\n} GF_SchemeInformationBox;\n\ntypedef struct __tag_protect_box\n{\n\tGF_ISOM_BOX\n\tGF_OriginalFormatBox *original_format;\n\tGF_SchemeTypeBox *scheme_type;\n\tGF_SchemeInformationBox *info;\n} GF_ProtectionSchemeInfoBox;\ntypedef struct __tag_protect_box GF_RestrictedSchemeInfoBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *descriptors;\n} GF_IPMPInfoBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_IPMP_ToolList *ipmp_tools;\n\tGF_List *descriptors;\n} GF_IPMPControlBox;\n\ntypedef struct {\n\tGF_ISOM_BOX\n} GF_ItemPropertyContainerBox;\n\ntypedef struct {\n\tGF_ISOM_BOX\n\tGF_ItemPropertyContainerBox *property_container;\n\tstruct __item_association_box *property_association;\n} GF_ItemPropertiesBox;\n\ntypedef struct {\n\tGF_ISOM_BOX\n} GF_GroupListBox;\n\ntypedef struct __tag_meta_box\n{\n\tGF_ISOM_FULL_BOX\n\tGF_HandlerBox *handler;\n\tGF_PrimaryItemBox *primary_resource;\n\tGF_DataInformationBox *file_locations;\n\tGF_ItemLocationBox *item_locations;\n\tGF_ItemProtectionBox *protections;\n\tGF_ItemInfoBox *item_infos;\n\tGF_IPMPControlBox *IPMP_control;\n\tGF_ItemPropertiesBox *item_props;\n\tGF_ItemReferenceBox *item_refs;\n\tGF_GroupListBox *groups_list;\n\n\tBool use_item_sample_sharing;\n} GF_MetaBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\n\tu32 single_view_allowed;\n\tu32 stereo_scheme;\n\tu32 sit_len;\n\tchar *stereo_indication_type;\n} GF_StereoVideoBox;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\n/*V2 boxes - Movie Fragments*/\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu64 fragment_duration;\n} GF_MovieExtendsHeaderBox;\n\n\ntypedef struct __tag_mvex_box\n{\n\tGF_ISOM_BOX\n\tGF_List *TrackExList;\n\tGF_List *TrackExPropList;\n\tGF_MovieExtendsHeaderBox *mehd;\n\tGF_ISOFile *mov;\n} GF_MovieExtendsBox;\n\n/*the TrackExtends contains default values for the track fragments*/\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_ISOTrackID trackID;\n\tu32 def_sample_desc_index;\n\tu32 def_sample_duration;\n\tu32 def_sample_size;\n\tu32 def_sample_flags;\n\tGF_TrackBox *track;\n\n\tBool cannot_use_default;\n\tGF_ISOTrackID inherit_from_traf_id;\n\t\n\tGF_TrackFragmentRandomAccessBox *tfra;\n} GF_TrackExtendsBox;\n\n/*the TrackExtends contains default values for the track fragments*/\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_ISOTrackID trackID;\n} GF_TrackExtensionPropertiesBox;\n\n/*indicates the seq num of this fragment*/\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 sequence_number;\n} GF_MovieFragmentHeaderBox;\n\n/*MovieFragment is a container IN THE FILE, contains 1 fragment*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_MovieFragmentHeaderBox *mfhd;\n\tGF_List *TrackList;\n\tGF_List *PSSHs;\n\tGF_ISOFile *mov;\n\t/*offset in the file of moof or mdat (whichever comes first) for this fragment*/\n\tu64 fragment_offset;\n\tu32 mdat_size;\n\tu8 *mdat;\n\t//when moof box was a compressed moof box, indicates the difference between the uncompressed size and the compressed size\n\ts32 compressed_diff;\n\n\t//temp storage of prft box\n\tGF_ISOTrackID reference_track_ID;\n\tu64 ntp, timestamp;\n} GF_MovieFragmentBox;\n\n\n/*FLAGS for TRAF*/\nenum\n{\n\tGF_ISOM_TRAF_BASE_OFFSET\t=\t0x01,\n\tGF_ISOM_TRAF_SAMPLE_DESC\t=\t0x02,\n\tGF_ISOM_TRAF_SAMPLE_DUR\t=\t0x08,\n\tGF_ISOM_TRAF_SAMPLE_SIZE\t=\t0x10,\n\tGF_ISOM_TRAF_SAMPLE_FLAGS\t=\t0x20,\n\tGF_ISOM_TRAF_DUR_EMPTY\t=\t0x10000,\n\tGF_ISOM_MOOF_BASE_OFFSET\t=\t0x20000,\n};\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_ISOTrackID trackID;\n\t/* all the following are optional fields */\n\tu64 base_data_offset;\n\tu32 sample_desc_index;\n\tu32 def_sample_duration;\n\tu32 def_sample_size;\n\tu32 def_sample_flags;\n\tu32 EmptyDuration;\n} GF_TrackFragmentHeaderBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu64 baseMediaDecodeTime;\n} GF_TFBaseMediaDecodeTimeBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_TrackFragmentHeaderBox *tfhd;\n\tGF_List *TrackRuns;\n\t/*keep a pointer to default flags*/\n\tGF_TrackExtendsBox *trex;\n\tGF_SampleDependencyTypeBox *sdtp;\n\n//\tGF_SubSampleInformationBox *subs;\n\tGF_List *sub_samples;\n\n\tGF_List *sampleGroups;\n\tGF_List *compactSampleGroups;\n\tGF_List *sampleGroupsDescription;\n\n\tGF_List *sai_sizes;\n\tGF_List *sai_offsets;\n\n\t//can be senc or PIFF psec\n\tstruct __sample_encryption_box *sample_encryption;\n\tstruct __traf_mss_timeext_box *tfxd; /*similar to PRFT but for Smooth Streaming*/\n\tstruct __traf_mss_timeref_box *tfrf;\n\n\t/*when data caching is on*/\n\tu32 DataCache;\n\tGF_TFBaseMediaDecodeTimeBox *tfdt;\n\n\tu64 moof_start_in_bs;\n#ifdef GF_ENABLE_CTRN\n\tBool use_ctrn;\n\tBool use_inherit;\n#endif\n\n\tu32 interleave_id;\n\tu8 merge_sample_interleave;\n\tu8 use_sample_interleave;\n\tu8 force_new_trun;\n\tu8 IFrameSwitching;\n\tu8 use_sdtp;\n\tu8 truns_first;\n\tu8 truns_v1;\n\tu8 large_tfdt;\n} GF_TrackFragmentBox;\n\nGF_TrackFragmentBox *gf_isom_get_traf(GF_ISOFile *mov, GF_ISOTrackID TrackID);\n\n/*FLAGS for TRUN : specify what is written in the SampleTable of TRUN*/\nenum\n{\n\t/*common to both trun and ctrn*/\n\tGF_ISOM_TRUN_DATA_OFFSET\t= 0x01,\n\t/*trun flags*/\n\tGF_ISOM_TRUN_FIRST_FLAG\t\t= 0x04,\n\tGF_ISOM_TRUN_DURATION\t\t= 0x100,\n\tGF_ISOM_TRUN_SIZE\t\t\t= 0x200,\n\tGF_ISOM_TRUN_FLAGS\t\t\t= 0x400,\n\tGF_ISOM_TRUN_CTS_OFFSET\t\t= 0x800,\n\n#ifdef GF_ENABLE_CTRN\n\t/*compact trun flags (not all of them, field indices are stored in trun box)*/\n\tGF_ISOM_CTRN_FIRST_SAMPLE = 1<<1, //0x00000002\n\tGF_ISOM_CTRN_DATAOFFSET_16 = 1<<2, //0x00000004\n\tGF_ISOM_CTRN_CTSO_MULTIPLIER = 1<<3, //0x00000008\n\n\tGF_ISOM_CTRN_INHERIT_CTSO = 1<<4,\n\tGF_ISOM_CTRN_INHERIT_FLAGS = 1<<5,\n\tGF_ISOM_CTRN_INHERIT_SIZE = 1<<6,\n\tGF_ISOM_CTRN_INHERIT_DUR = 1<<7\n#endif\n\n};\n\ntypedef struct\n{\n\tu32 Duration;\n\tu32 size;\n\tu32 flags;\n\ts32 CTS_Offset;\n\n\t/*internal*/\n\tu32 SAP_type;\n\tu64 dts;\n\tu32 nb_pack;\n} GF_TrunEntry;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 sample_count;\n\t/*the following are optional fields */\n\t/* unsigned for version 0 */\n\ts32 data_offset;\n\n\tu32 nb_samples, sample_alloc;\n\t/*can be empty*/\n\tGF_TrunEntry *samples;\n\n\t/*only for trun, ignored for ctrn*/\n\tu32 first_sample_flags;\n\n\t/*in write mode with data caching*/\n\tGF_BitStream *cache;\n\n#ifdef GF_ENABLE_CTRN\n\t/*the remaining is internal for compact trun*/\n\t/*use compact mode*/\n\tBool use_ctrn;\n\t/*we store the ctrn box flags here rather than in flags and swap when writing/dumping. This avoids overwriting the flags\n\tset by the fragment writer*/\n\tu32 ctrn_flags;\n\t/*set to default sample duration when writing, parsed from box otherwise. If 0, not used*/\n\tu32 ctso_multiplier;\n\tu8 ctrn_first_dur, ctrn_first_size, ctrn_first_sample_flags, ctrn_first_ctts;\n\tu8 ctrn_dur, ctrn_size, ctrn_sample_flags, ctrn_ctts;\n\t/*use inherit in write mode- in the current version, only size will be set and all other fields inherited*/\n\tBool use_inherit;\n#endif\n\n\tu32 interleave_id;\n\tu32 first_sample_idx;\n\tu32 *sample_order;\n} GF_TrackFragmentRunBox;\n\n#ifdef GF_ENABLE_CTRN\nu32 gf_isom_ctrn_field_size_bits(u32 field_idx);\n#endif\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\n/*RTP Hint Track Sample Entry*/\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\n\tu16 HintTrackVersion;\n\tu16 LastCompatibleVersion;\n\tu32 MaxPacketSize;\n//\tGF_List *HintDataTable;\n\t/*this is where we store the current RTP sample in read/write mode*/\n\tstruct __tag_hint_sample *hint_sample;\n\t/*current hint sample in read mode, 1-based (0 is reset)*/\n\tu32 cur_sample;\n\tu32 pck_sn, ts_offset, ssrc;\n\tGF_TrackReferenceTypeBox *hint_ref;\n\n\t//for FEC\n\tu16 partition_entry_ID, FEC_overhead;\n} GF_HintSampleEntryBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 subType;\n\tchar *sdpText;\n} GF_RTPBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tchar *sdpText;\n} GF_SDPBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\ts32 timeOffset;\n} GF_RTPOBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\t/*contains GF_SDPBox if in track, GF_RTPBox if in movie*/\n\tGF_Box *SDP;\n} GF_HintTrackInfoBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu8 reserved;\n\tu8 preferred;\n\tu8 required;\n} GF_RelyHintBox;\n\n/***********************************************************\n\t\t\tdata entry tables for RTP\n***********************************************************/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 timeScale;\n} GF_TSHintEntryBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 TimeOffset;\n} GF_TimeOffHintEntryBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 SeqOffset;\n} GF_SeqOffHintEntryBox;\n\n\n\n/***********************************************************\n\t\t\thint track information boxes for RTP\n***********************************************************/\n\n/*Total number of bytes that will be sent, including 12-byte RTP headers, but not including any network headers*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu64 nbBytes;\n} GF_TRPYBox;\n\n/*32-bits version of trpy used in Darwin*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 nbBytes;\n} GF_TOTLBox;\n\n/*Total number of network packets that will be sent*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu64 nbPackets;\n} GF_NUMPBox;\n\n/*32-bits version of nump used in Darwin*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 nbPackets;\n} GF_NPCKBox;\n\n\n/*Total number of bytes that will be sent, not including 12-byte RTP headers*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu64 nbBytes;\n} GF_NTYLBox;\n\n/*32-bits version of tpyl used in Darwin*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 nbBytes;\n} GF_TPAYBox;\n\n/*Maximum data rate in bits per second.*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 granularity;\n\tu32 maxDataRate;\n} GF_MAXRBox;\n\n\n/*Total number of bytes from the media track to be sent*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu64 nbBytes;\n} GF_DMEDBox;\n\n/*Number of bytes of immediate data to be sent*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu64 nbBytes;\n} GF_DIMMBox;\n\n\n/*Number of bytes of repeated data to be sent*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu64 nbBytes;\n} GF_DREPBox;\n\n/*Smallest relative transmission time, in milliseconds. signed integer for smoothing*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\ts32 minTime;\n} GF_TMINBox;\n\n/*Largest relative transmission time, in milliseconds.*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\ts32 maxTime;\n} GF_TMAXBox;\n\n/*Largest packet, in bytes, including 12-byte RTP header*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 maxSize;\n} GF_PMAXBox;\n\n/*Longest packet duration, in milliseconds*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 maxDur;\n} GF_DMAXBox;\n\n/*32-bit payload type number, followed by rtpmap payload string */\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 payloadCode;\n\tchar *payloadString;\n} GF_PAYTBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tchar *string;\n} GF_NameBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n} GF_HintInfoBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu8 timestamp_sync;\n} GF_TimeStampSynchronyBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 ssrc;\n} GF_ReceivedSsrcBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 encryption_algorithm_rtp;\n\tu32 encryption_algorithm_rtcp;\n\tu32 integrity_algorithm_rtp;\n\tu32 integrity_algorithm_rtcp;\n\n\tGF_SchemeTypeBox *scheme_type;\n\tGF_SchemeInformationBox *info;\n} GF_SRTPProcessBox;\n\n/*Apple extension*/\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 reserved;\n\tu8 *data;\n\tu32 dataSize;\n\tBool qt_style;\n} GF_DataBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_DataBox *data;\n} GF_ListItemBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n} GF_ItemListBox;\n\n/*DECE*/\ntypedef struct\n{\n\tu8 pic_type;\n\tu8 dependency_level;\n} GF_TrickPlayBoxEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 entry_count;\n\tGF_TrickPlayBoxEntry *entries;\n} GF_TrickPlayBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu8  baseLocation[256];\n\tu8 basePurlLocation[256];\n} GF_BaseLocationBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 profile_version;\n\tchar *APID;\n} GF_AssetInformationBox;\n\n/*OMA (P)DCF extensions*/\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu8 EncryptionMethod;\n\tu8 PaddingScheme;\n\tu64 PlaintextLength;\n\tchar *ContentID;\n\tchar *RightsIssuerURL;\n\tchar *TextualHeaders;\n\tu32 TextualHeadersLen;\n} GF_OMADRMCommonHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu8 GKEncryptionMethod;\n\tchar *GroupID;\n\tu16 GKLength;\n\tchar *GroupKey;\n} GF_OMADRMGroupIDBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n} GF_OMADRMMutableInformationBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tchar TransactionID[16];\n} GF_OMADRMTransactionTrackingBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu8 *oma_ro;\n\tu32 oma_ro_size;\n} GF_OMADRMRightsObjectBox;\n\n/*identical*/\ntypedef struct __isma_format_box GF_OMADRMAUFormatBox;\n\ntypedef struct __oma_kms_box\n{\n\tGF_ISOM_FULL_BOX\n\tGF_OMADRMCommonHeaderBox *hdr;\n\tGF_OMADRMAUFormatBox *fmt;\n} GF_OMADRMKMSBox;\n\ntypedef struct\n{\n\tBool reference_type;\n\tu32 reference_size;\n\tu32 subsegment_duration;\n\tBool starts_with_SAP;\n\tu32 SAP_type;\n\tu32 SAP_delta_time;\n} GF_SIDXReference;\n\ntypedef struct __sidx_box\n{\n\tGF_ISOM_FULL_BOX\n\n\tu32 reference_ID;\n\tu32 timescale;\n\tu64 earliest_presentation_time;\n\tu64 first_offset;\n\tu32 nb_refs;\n\tGF_SIDXReference *refs;\n\t//for trace only\n\ts32 compressed_diff;\n} GF_SegmentIndexBox;\n\nGF_Err gf_isom_set_fragment_template(GF_ISOFile *movie, u8 *tpl_data, u32 tpl_size, Bool *has_tfdt, GF_SegmentIndexBox **out_sidx);\n\ntypedef struct\n{\n\tu8 level;\n\tu32 range_size;\n} GF_SubsegmentRangeInfo;\n\ntypedef struct\n{\n\tu32 range_count;\n\tGF_SubsegmentRangeInfo *ranges;\n} GF_SubsegmentInfo;\n\ntypedef struct __ssix_box\n{\n\tGF_ISOM_FULL_BOX\n\n\tu32 subsegment_count, subsegment_alloc;\n\tGF_SubsegmentInfo *subsegments;\n\t//for trace only\n\ts32 compressed_diff;\n} GF_SubsegmentIndexBox;\n\ntypedef struct\n{\n\tGF_ISOTrackID track_id;\n\tBool padding_flag;\n\tu8 type;\n\tu32 grouping_type;\n\tu32 grouping_type_parameter;\n\tGF_ISOTrackID sub_track_id;\n} GF_LevelAssignment;\n\ntypedef struct __leva_box\n{\n\tGF_ISOM_FULL_BOX\n\n\tu32 level_count;\n\tGF_LevelAssignment *levels;\n} GF_LevelAssignmentBox;\n\ntypedef struct __pcrInfo_box\n{\n\tGF_ISOM_BOX\n\tu32\tsubsegment_count;\n\tu64 *pcr_values;\n} GF_PcrInfoBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tchar *scheme_id_uri;\n\tchar *value;\n\tu32 timescale;\n\tu64 presentation_time_delta;\n\tu32 event_duration;\n\tu32 event_id;\n\tu8 *message_data;\n\tu32 message_data_size;\n} GF_EventMessageBox;\n\n\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n\n/*Adobe specific boxes*/\ntypedef struct\n{\n\tu64 time;\n\tu64 offset;\n} GF_AfraEntry;\n\ntypedef struct\n{\n\tu64 time;\n\tu32 segment;\n\tu32 fragment;\n\tu64 afra_offset;\n\tu64 offset_from_afra;\n} GF_GlobalAfraEntry;\n\ntypedef struct __adobe_frag_random_access_box\n{\n\tGF_ISOM_FULL_BOX\n\tBool long_ids;\n\tBool long_offsets;\n\tBool global_entries;\n\tu8 reserved;\n\tu32 time_scale;\n\tu32 entry_count;\n\tGF_List *local_access_entries;\n\tu32 global_entry_count;\n\tGF_List *global_access_entries;\n} GF_AdobeFragRandomAccessBox;\n\ntypedef struct __adobe_bootstrap_info_box\n{\n\tGF_ISOM_FULL_BOX\n\tu32 bootstrapinfo_version;\n\tu8 profile;\n\tBool live;\n\tBool update;\n\tu8 reserved;\n\tu32 time_scale;\n\tu64 current_media_time;\n\tu64 smpte_time_code_offset;\n\tchar *movie_identifier;\n\tu8 server_entry_count;\n\tGF_List *server_entry_table;\n\tu8 quality_entry_count;\n\tGF_List *quality_entry_table;\n\tchar *drm_data;\n\tchar *meta_data;\n\t//entries in these two lists are NOT registered with the box child_boxes because of the in-between 8 bits !!\n\tu8 segment_run_table_count;\n\tGF_List *segment_run_table_entries;\n\tu8 fragment_run_table_count;\n\tGF_List *fragment_run_table_entries;\n} GF_AdobeBootstrapInfoBox;\n\ntypedef struct\n{\n\tu32 first_segment;\n\tu32 fragment_per_segment;\n} GF_AdobeSegmentRunEntry;\n\ntypedef struct __adobe_segment_run_table_box\n{\n\tGF_ISOM_FULL_BOX\n\tu8 quality_entry_count;\n\tGF_List *quality_segment_url_modifiers;\n\tu32 segment_run_entry_count;\n\tGF_List *segment_run_entry_table;\n} GF_AdobeSegmentRunTableBox;\n\ntypedef struct\n{\n\tu32 first_fragment;\n\tu64 first_fragment_timestamp;\n\tu32 fragment_duration;\n\tu8 discontinuity_indicator;\n} GF_AdobeFragmentRunEntry;\n\ntypedef struct __adobe_fragment_run_table_box\n{\n\tGF_ISOM_FULL_BOX\n\tu32 timescale;\n\tu8 quality_entry_count;\n\tGF_List *quality_segment_url_modifiers;\n\tu32 fragment_run_entry_count;\n\tGF_List *fragment_run_entry_table;\n} GF_AdobeFragmentRunTableBox;\n\n#endif /*GPAC_DISABLE_ISOM_ADOBE*/\n\n\n/***********************************************************\n\t\t\tSample Groups\n***********************************************************/\ntypedef struct\n{\n\tu32 sample_count;\n\tu32 group_description_index;\n} GF_SampleGroupEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 grouping_type;\n\tu32 grouping_type_parameter;\n\n\tu32 entry_count;\n\tGF_SampleGroupEntry *sample_entries;\n\n} GF_SampleGroupBox;\n\ntypedef struct\n{\n\tu32 length;\n\tu32 sample_count;\n\tu32 *sample_group_description_indices;\n} GF_CompactSampleGroupPattern;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 grouping_type;\n\tu32 grouping_type_parameter;\n\n\tu32 pattern_count;\n\tGF_CompactSampleGroupPattern *patterns;\n} GF_CompactSampleGroupBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 grouping_type;\n\tu32 default_length;\n\n\tu32 default_description_index;\n\tGF_List *group_descriptions;\n} GF_SampleGroupDescriptionBox;\n\n/*default entry */\ntypedef struct\n{\n\tu32 length;\n\tu8 *data;\n} GF_DefaultSampleGroupDescriptionEntry;\n\n/*VisualRandomAccessEntry - 'rap ' type*/\ntypedef struct\n{\n\tu8 num_leading_samples_known;\n\tu8 num_leading_samples;\n} GF_VisualRandomAccessEntry;\n\n/*RollRecoveryEntry - 'roll' and prol type*/\ntypedef struct\n{\n\ts16 roll_distance;\n} GF_RollRecoveryEntry;\n\n/*TemporalLevelEntry - 'tele' type*/\ntypedef struct\n{\n\tBool level_independently_decodable;\n} GF_TemporalLevelEntry;\n\n/*SAPEntry - 'sap ' type*/\ntypedef struct\n{\n\tBool dependent_flag;\n\tu8 SAP_type;\n} GF_SAPEntry;\n\n/*SAPEntry - 'sync' type*/\ntypedef struct\n{\n\tu8 NALU_type;\n} GF_SYNCEntry;\n\n/*Operating Points Information - 'oinf' type*/\ntypedef struct\n{\n\tu16 scalability_mask;\n\tGF_List* profile_tier_levels;\n\tGF_List* operating_points;\n\tGF_List* dependency_layers;\n} GF_OperatingPointsInformation;\n\nGF_OperatingPointsInformation *gf_isom_oinf_new_entry();\nvoid gf_isom_oinf_del_entry(void *entry);\nGF_Err gf_isom_oinf_read_entry(void *entry, GF_BitStream *bs);\nGF_Err gf_isom_oinf_write_entry(void *entry, GF_BitStream *bs);\nu32 gf_isom_oinf_size_entry(void *entry);\nBool gf_isom_get_oinf_info(GF_ISOFile *file, u32 trackNumber, GF_OperatingPointsInformation **ptr);\n\n\n/*Operating Points Information - 'oinf' type*/\ntypedef struct\n{\n\tu8 layer_id;\n\tu8 min_TemporalId;\n\tu8 max_TemporalId;\n\tu8 sub_layer_presence_flags;\n} LHVCLayerInfoItem;\n\ntypedef struct\n{\n\tGF_List* num_layers_in_track;\n} GF_LHVCLayerInformation;\n\nGF_LHVCLayerInformation *gf_isom_linf_new_entry();\nvoid gf_isom_linf_del_entry(void *entry);\nGF_Err gf_isom_linf_read_entry(void *entry, GF_BitStream *bs);\nGF_Err gf_isom_linf_write_entry(void *entry, GF_BitStream *bs);\nu32 gf_isom_linf_size_entry(void *entry);\nBool gf_isom_get_linf_info(GF_ISOFile *file, u32 trackNumber, GF_LHVCLayerInformation **ptr);\n\n\n#define MAX_LHEVC_LAYERS\t64\n\ntypedef struct\n{\n\tu8 general_profile_space, general_tier_flag, general_profile_idc, general_level_idc;\n\tu32 general_profile_compatibility_flags;\n\tu64 general_constraint_indicator_flags;\n} LHEVC_ProfileTierLevel;\n\ntypedef struct\n{\n\tu8 ptl_idx;\n\tu8 layer_id;\n\tBool is_outputlayer, is_alternate_outputlayer;\n} LHEVC_LayerInfo;\n\ntypedef struct\n{\n\tu16 output_layer_set_idx;\n\tu8 max_temporal_id;\n\tu8 layer_count;\n\tLHEVC_LayerInfo layers_info[MAX_LHEVC_LAYERS];\n\tu16 minPicWidth, minPicHeight, maxPicWidth, maxPicHeight;\n\tu8 maxChromaFormat, maxBitDepth;\n\tBool frame_rate_info_flag, bit_rate_info_flag;\n\tu16 avgFrameRate;\n\tu8 constantFrameRate;\n\tu32 maxBitRate, avgBitRate;\n} LHEVC_OperatingPoint;\n\n\ntypedef struct\n{\n\tu8 dependent_layerID;\n\tu8 num_layers_dependent_on;\n\tu8 dependent_on_layerID[MAX_LHEVC_LAYERS];\n\tu8 dimension_identifier[16];\n} LHEVC_DependentLayer;\n\n\n\n/*\n\t\tCENC stuff\n*/\n\n/*CENCSampleEncryptionGroupEntry - 'seig' type*/\ntypedef struct\n{\n\tu8 crypt_byte_block, skip_byte_block;\n\tu8 IsProtected;\n\tu8 *key_info;\n\tu32 key_info_size;\n} GF_CENCSampleEncryptionGroupEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\n\tbin128 SystemID;\n\tu32 KID_count;\n\tbin128 *KIDs;\n\tu32 private_data_size;\n\tu8 *private_data;\n} GF_ProtectionSystemHeaderBox;\n\ntypedef struct __cenc_tenc_box\n{\n\tGF_ISOM_FULL_BOX\n\n\tu8 crypt_byte_block, skip_byte_block;\n\tu8 isProtected;\n\n\t//single key\n\tu8 key_info[37];\n} GF_TrackEncryptionBox;\n\ntypedef struct __piff_tenc_box\n{\n\tGF_ISOM_UUID_BOX\n\t/*u8 version; field in included in base box version */\n\tu32 flags;\n\n\tu32 AlgorithmID;\n\tu8 key_info[20];\n} GF_PIFFTrackEncryptionBox;\n\ntypedef struct\n{\n\tGF_ISOM_UUID_BOX\n\t/*u8 version; field in included in base box version */\n\tu32 flags;\n\n\tbin128 SystemID;\n\tu32 private_data_size;\n\tu8 *private_data;\n} GF_PIFFProtectionSystemHeaderBox;\n\n\ntypedef struct __sample_encryption_box\n{\n\tGF_ISOM_UUID_BOX\n\t/*u8 version; field in included in base box version */\n\tu32 flags;\n\n\t//0: regular senc, 1: PIFF PSEC, 2: MS senc with version 1 (not compatible with ISOBMFF senc v1)\n\tu32 piff_type;\n\n\tGF_List *samp_aux_info; /*GF_CENCSampleAuxInfo*/\n\tu64 bs_offset;\n\tBool load_needed;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t/*pointer to container traf*/\n\tGF_TrackFragmentBox *traf;\n#endif\n\t/*pointer to associated saio*/\n\tGF_SampleAuxiliaryInfoSizeBox *cenc_saiz;\n\tGF_SampleAuxiliaryInfoOffsetBox *cenc_saio;\n\n\n\tu32 AlgorithmID;\n\tu8 IV_size;\n\tbin128 KID;\n\n} GF_SampleEncryptionBox;\n\ntypedef struct __traf_mss_timeext_box\n{\n\tGF_ISOM_UUID_BOX\n\t/*u8 version; field in included in base box version */\n\tu32 flags;\n\n\tu64 absolute_time_in_track_timescale;\n\tu64 fragment_duration_in_track_timescale;\n} GF_MSSTimeExtBox;\n\ntypedef struct\n{\n\tu64 absolute_time_in_track_timescale;\n\tu64 fragment_duration_in_track_timescale;\n} GF_MSSTimeEntry;\n\ntypedef struct __traf_mss_timeref_box\n{\n\tGF_ISOM_UUID_BOX\n\t/*u8 version; field in included in base box version */\n\tu32 flags;\n\n\tu32 frags_count;\n\tGF_MSSTimeEntry *frags;\n\n} GF_MSSTimeRefBox;\n\n\n\nGF_SampleEncryptionBox *gf_isom_create_piff_psec_box(u8 version, u32 flags, u32 AlgorithmID, u8 IV_size, bin128 KID);\nGF_SampleEncryptionBox * gf_isom_create_samp_enc_box(u8 version, u32 flags);\n\nvoid gf_isom_cenc_get_default_info_internal(GF_TrackBox *trak, u32 sampleDescriptionIndex, u32 *container_type, Bool *default_IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size);\n\n\nGF_Err gf_isom_get_sample_cenc_info_internal(GF_TrackBox *trak,\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_TrackFragmentBox *traf,\n#else\n\tvoid *traf,\n#endif\n\tGF_SampleEncryptionBox *senc, u32 sample_number, Bool *IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size);\n\n\nGF_Err senc_Parse(GF_BitStream *bs, GF_TrackBox *trak,\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_TrackFragmentBox *traf,\n#else\n\tvoid *traf,\n#endif\n\tGF_SampleEncryptionBox *ptr);\n\n\n/*\n\tBoxes for Adobe's protection scheme\n*/\ntypedef struct __adobe_enc_info_box\n{\n\tGF_ISOM_FULL_BOX\n\tchar *enc_algo; /*spec: The encryption algorithm shall be 'AES-CBC'*/\n\tu8 key_length;\n} GF_AdobeEncryptionInfoBox;\n\ntypedef struct __adobe_flash_access_params_box\n{\n\tGF_ISOM_BOX\n\tu8 *metadata; /*base-64 encoded metadata used by the DRM client to retrieve decrypted key*/\n} GF_AdobeFlashAccessParamsBox;\n\ntypedef struct __adobe_key_info_box\n{\n\tGF_ISOM_FULL_BOX\n\tGF_AdobeFlashAccessParamsBox * params; /*spec: APSParamsBox will no longer be produced by conformaing applications*/\n} GF_AdobeKeyInfoBox;\n\ntypedef struct __adobe_std_enc_params_box\n{\n\tGF_ISOM_FULL_BOX\n\tGF_AdobeEncryptionInfoBox *enc_info;\n\tGF_AdobeKeyInfoBox *key_info;\n} GF_AdobeStdEncryptionParamsBox;\n\ntypedef struct __adobe_drm_header_box\n{\n\tGF_ISOM_FULL_BOX\n\tGF_AdobeStdEncryptionParamsBox *std_enc_params;\n\t//AdobeSignatureBox *signature; /*AdobeSignatureBox is not described*/\n} GF_AdobeDRMHeaderBox;\n\n\ntypedef struct __adobe_drm_au_format_box\n{\n\tGF_ISOM_FULL_BOX\n\tu8 selective_enc;\n\tu8 IV_length;\n} GF_AdobeDRMAUFormatBox;\n\ntypedef struct __adobe_drm_key_management_system_box\n{\n\tGF_ISOM_FULL_BOX\n\tGF_AdobeDRMHeaderBox *header;\n\tGF_AdobeDRMAUFormatBox *au_format;\n} GF_AdobeDRMKeyManagementSystemBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_ISOTrackID refTrackID;\n\tu64 ntp, timestamp;\n} GF_ProducerReferenceTimeBox;\n\n/* Image File Format Structures */\ntypedef struct {\n\tGF_ISOM_FULL_BOX\n\tu32 image_width;\n\tu32 image_height;\n} GF_ImageSpatialExtentsPropertyBox;\n\ntypedef struct {\n\tGF_ISOM_FULL_BOX\n\tu8 num_channels;\n\tu8 *bits_per_channel;\n} GF_PixelInformationPropertyBox;\n\ntypedef struct {\n\tGF_ISOM_FULL_BOX\n\tu32 horizontal_offset;\n\tu32 vertical_offset;\n} GF_RelativeLocationPropertyBox;\n\ntypedef struct {\n\tGF_ISOM_BOX\n\tu8 angle;\n} GF_ImageRotationBox;\n\ntypedef struct {\n\tGF_ISOM_BOX\n\tu8 axis;\n} GF_ImageMirrorBox;\n\ntypedef struct\n{\n\tu8 essential;\n\tu32 index;\n} GF_ItemPropertyAssociationSlot;\n\ntypedef struct {\n\tu32 item_id;\n\tGF_ItemPropertyAssociationSlot *associations;\n\tu32 nb_associations;\n} GF_ItemPropertyAssociationEntry;\n\ntypedef struct __item_association_box {\n\tGF_ISOM_FULL_BOX\n\tGF_List *entries;\n} GF_ItemPropertyAssociationBox;\n\n\ntypedef struct {\n\tGF_ISOM_FULL_BOX\n\tchar *aux_urn;\n\tu32 data_size;\n\tu8 *data;\n} GF_AuxiliaryTypePropertyBox;\n\ntypedef struct {\n\tGF_ISOM_FULL_BOX\n\tu8 skip_byte_block, crypt_byte_block;\n\tu8 *key_info;\n\tu32 key_info_size;\n} GF_ItemEncryptionPropertyBox;\n\n\ntypedef struct {\n\tGF_ISOM_FULL_BOX\n\tu32 aux_info_type;\n\tu32 aux_info_parameter;\n} GF_AuxiliaryInfoPropertyBox;\n\ntypedef struct {\n\tGF_ISOM_FULL_BOX\n\n\tGF_OperatingPointsInformation *oinf;\n} GF_OINFPropertyBox;\n\n\ntypedef struct {\n\tGF_ISOM_FULL_BOX\n\n\tu16 target_ols_index;\n} GF_TargetOLSPropertyBox;\n\n/*flute hint track boxes*/\ntypedef struct\n{\n\tu16 block_count;\n\tu32 block_size;\n} FilePartitionEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 itemID;\n\tu16 packet_payload_size;\n\tu8 FEC_encoding_ID;\n\tu16 FEC_instance_ID;\n\tu16 max_source_block_length;\n\tu16 encoding_symbol_length;\n\tu16 max_number_of_encoding_symbols;\n\tchar *scheme_specific_info;\n\tu32 nb_entries;\n\tFilePartitionEntry *entries;\n} FilePartitionBox;\n\ntypedef struct\n{\n\tu32 item_id;\n\tu32 symbol_count;\n} FECReservoirEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 nb_entries;\n\tFECReservoirEntry *entries;\n} FECReservoirBox;\n\ntypedef struct\n{\n\tu32 nb_groups;\n\tu32 *group_ids;\n\tu32 nb_channels;\n\tu32 *channels;\n} SessionGroupEntry;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu16 num_session_groups;\n\tSessionGroupEntry *session_groups;\n} FDSessionGroupBox;\n\ntypedef struct\n{\n\tu32 group_id;\n\tchar *name;\n} GroupIdNameEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu16 nb_entries;\n\tGroupIdNameEntry *entries;\n} GroupIdToNameBox;\n\n\ntypedef struct\n{\n\tu32 item_id;\n\tu32 symbol_count;\n} FileReservoirEntry;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 nb_entries;\n\tFileReservoirEntry *entries;\n} FileReservoirBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tFilePartitionBox *blocks_and_symbols;\n\tFECReservoirBox *FEC_symbol_locations;\n\tFileReservoirBox *File_symbol_locations;\n} FDPartitionEntryBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *partition_entries;\n\tFDSessionGroupBox *session_info;\n\tGroupIdToNameBox *group_id_to_name;\n} FDItemInformationBox;\n\n\n\ntypedef struct\n{\n\tchar *name;\n\tu32 flags;\n\tu16 prop_type;\n\n\tu32 prop_size;\n\tu8 *prop_value; //most of the time, utf16 with trailing \\0\\0\n} GF_XtraTag;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\n\tGF_List *tags;\n} GF_XtraBox;\n\n\n/*\n\t\tData Map (media storage) stuff\n*/\n\n/*regular file IO*/\n#define GF_ISOM_DATA_FILE         0x01\n/*External file object. Needs implementation*/\n#define GF_ISOM_DATA_FILE_EXTERN  0x03\n/*regular memory IO*/\n#define GF_ISOM_DATA_MEM          0x04\n\n/*Data Map modes*/\nenum\n{\n\t/*read mode*/\n\tGF_ISOM_DATA_MAP_READ = 1,\n\t/*write mode*/\n\tGF_ISOM_DATA_MAP_WRITE = 2,\n\t/*the following modes are just ways of signaling extended functionalities\n\tedit mode, to make sure the file is here, set to GF_ISOM_DATA_MAP_READ afterwards*/\n\tGF_ISOM_DATA_MAP_EDIT = 3,\n\t/*read-only access to the movie file: we create a file mapping object\n\tmode is set to GF_ISOM_DATA_MAP_READ afterwards*/\n\tGF_ISOM_DATA_MAP_READ_ONLY = 4,\n\t/*write-only access at the end of the movie - only used for movie fragments concatenation*/\n\tGF_ISOM_DATA_MAP_CAT = 5,\n};\n\n/*this is the DataHandler structure each data handler has its own bitstream*/\n#define GF_ISOM_BASE_DATA_HANDLER\t\\\n\tu8\ttype;\t\t\\\n\tu64\tcurPos;\t\t\\\n\tu8\tmode;\t\t\\\n\tGF_BitStream *bs;\\\n\tu64 last_read_offset;\\\n\tchar *szName;\n\ntypedef struct __tag_data_map\n{\n\tGF_ISOM_BASE_DATA_HANDLER\n} GF_DataMap;\n\ntypedef struct\n{\n\tGF_ISOM_BASE_DATA_HANDLER\n\tFILE *stream;\n\tBool is_stdout;\n\tBool last_acces_was_read;\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tchar *temp_file;\n#endif\n\tGF_Blob *blob;\n} GF_FileDataMap;\n\n/*file mapping handler. used if supported, only on read mode for complete files  (not in file download)*/\ntypedef struct\n{\n\tGF_ISOM_BASE_DATA_HANDLER\n\tchar *name;\n\tu64 file_size;\n\tu8 *byte_map;\n\tu64 byte_pos;\n} GF_FileMappingDataMap;\n\nGF_Err gf_isom_datamap_new(const char *location, const char *parentPath, u8 mode, GF_DataMap **outDataMap);\nvoid gf_isom_datamap_del(GF_DataMap *ptr);\nGF_Err gf_isom_datamap_open(GF_MediaBox *minf, u32 dataRefIndex, u8 Edit);\nvoid gf_isom_datamap_close(GF_MediaInformationBox *minf);\nu32 gf_isom_datamap_get_data(GF_DataMap *map, u8 *buffer, u32 bufferLength, u64 Offset);\n\n/*File-based data map*/\nGF_DataMap *gf_isom_fdm_new(const char *sPath, u8 mode);\nvoid gf_isom_fdm_del(GF_FileDataMap *ptr);\nu32 gf_isom_fdm_get_data(GF_FileDataMap *ptr, u8 *buffer, u32 bufferLength, u64 fileOffset);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_DataMap *gf_isom_fdm_new_temp(const char *sTempPath);\n#endif\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nu64 gf_isom_datamap_get_offset(GF_DataMap *map);\nGF_Err gf_isom_datamap_add_data(GF_DataMap *ptr, u8 *data, u32 dataSize);\n#endif\n\nvoid gf_isom_datamap_flush(GF_DataMap *map);\n\n/*\n\t\tMovie stuff\n*/\n\n\n/*time def for MP4/QT/MJ2K files*/\n#define GF_ISOM_MAC_TIME_OFFSET 2082844800\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n#define GF_ISOM_FORMAT_FRAG_FLAGS(pad, sync, deg) ( ( (pad) << 17) | ( ( !(sync) ) << 16) | (deg) );\n#define GF_ISOM_GET_FRAG_PAD(flag) ( (flag) >> 17) & 0x7\n#define GF_ISOM_GET_FRAG_SYNC(flag) ( ! ( ( (flag) >> 16) & 0x1))\n#define GF_ISOM_GET_FRAG_DEG(flag)\t(flag) & 0x7FFF\n\n#define GF_ISOM_GET_FRAG_LEAD(flag) ( (flag) >> 26) & 0x3\n#define GF_ISOM_GET_FRAG_DEPENDS(flag) ( (flag) >> 24) & 0x3\n#define GF_ISOM_GET_FRAG_DEPENDED(flag) ( (flag) >> 22) & 0x3\n#define GF_ISOM_GET_FRAG_REDUNDANT(flag) ( (flag) >> 20) & 0x3\n\n#define GF_ISOM_GET_FRAG_DEPEND_FLAGS(lead, depends, depended, redundant) ( (lead<<26) | (depends<<24) | (depended<<22) | (redundant<<20) )\n#define GF_ISOM_RESET_FRAG_DEPEND_FLAGS(flags) flags = flags & 0xFFFFF\n\nGF_TrackExtendsBox *GetTrex(GF_MovieBox *moov, GF_ISOTrackID TrackID);\n#endif\n\nenum\n{\n\tGF_ISOM_FRAG_WRITE_READY\t=\t0x01,\n\tGF_ISOM_FRAG_READ_DEBUG\t\t=\t0x02,\n};\n\n\n/*this is our movie object*/\nstruct __tag_isom {\n\t/*the last fatal error*/\n\tGF_Err LastError;\n\t/*the original filename*/\n\tchar *fileName;\n\t/*the original file in read/edit, and also used in fragments mode\n\tonce the first moov has been written\n\tNota: this API doesn't allow fragments BEFORE the MOOV in order\n\tto make easily parsable files (note there could be some data (mdat) before\n\tthe moov*/\n\tGF_DataMap *movieFileMap;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t/*the final file name*/\n\tchar *finalName;\n\t/*the file where we store edited samples (for READ_WRITE and WRITE mode only)*/\n\tGF_DataMap *editFileMap;\n\t/*the interleaving time for dummy mode (in movie TimeScale)*/\n\tu32 interleavingTime;\n\tGF_ISOTrackID last_created_track_id;\n#endif\n\n\tGF_ISOOpenMode openMode;\n\tu8 storageMode;\n\t/*if true 3GPP text streams are read as MPEG-4 StreamingText*/\n\tu8 convert_streaming_text;\n\tu8 is_jp2;\n\tu8 force_co64;\n\tu64 next_flush_chunk_time;\n\tBool keep_utc;\n\t/*main boxes for fast access*/\n\t/*moov*/\n\tGF_MovieBox *moov;\n\t/*our MDAT box (one and only one when we store the file)*/\n\tGF_MediaDataBox *mdat;\n\t/*file brand (since v2, NULL means mp4 v1)*/\n\tGF_FileTypeBox *brand;\n\t/*original file type box if any*/\n\tGF_Box *otyp;\n\n\t/*progressive download info*/\n\tGF_ProgressiveDownloadBox *pdin;\n\t/*meta box if any*/\n\tGF_MetaBox *meta;\n\n\ts64 read_byte_offset;\n\tu64 bytes_removed;\n\n\tBool disable_odf_translate;\n\n\tGF_ISOCompressMode compress_mode;\n\tu32 compress_flags;\n\n\tvoid (*progress_cbk)(void *udta, u64 nb_done, u64 nb_total);\n\tvoid *progress_cbk_udta;\n\n\tu32 FragmentsFlags;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 NextMoofNumber;\n\t/*active fragment*/\n\tGF_MovieFragmentBox *moof;\n\t/*in WRITE mode, this is the current MDAT where data is written*/\n\t/*in READ mode this is the last valid file position before a gf_isom_box_read failed*/\n\tu64 current_top_box_start;\n\tu64 segment_start;\n\n\tGF_List *moof_list;\n\tBool use_segments, moof_first, append_segment, styp_written, force_moof_base_offset;\n\n\t/*used when building single-indexed self initializing media segments*/\n\tGF_SegmentIndexBox *root_sidx;\n\tu64 root_sidx_offset;\n\tu32 root_sidx_index;\n\tBool dyn_root_sidx;\n\tGF_SubsegmentIndexBox *root_ssix;\n\n\tBool is_index_segment;\n\n\tGF_BitStream *segment_bs;\n\t/* 0: no moof found yet, 1: 1 moof found, 2: next moof found */\n\tBool single_moof_mode;\n\tu32 single_moof_state;\n\n\tBool sample_groups_in_traf;\n\tBool force_sidx_v1;\n\n\t/* optional mfra box used in write mode */\n\tGF_MovieFragmentRandomAccessBox *mfra;\n\n\tBool store_traf_map;\n\tBool signal_frag_bounds;\n\tu64 sidx_start_offset, sidx_end_offset;\n\tu64 styp_start_offset;\n\tu64 mdat_end_offset;\n\tGF_Box *seg_ssix, *seg_styp;\n\n\tu32 sidx_pts_store_alloc, sidx_pts_store_count;\n\tu64 *sidx_pts_store, *sidx_pts_next_store;\n\n\tGF_SegmentIndexBox *main_sidx;\n\tu64 main_sidx_end_pos;\n\n#endif\n\tGF_ProducerReferenceTimeBox *last_producer_ref_time;\n\n\t/*this contains ALL the root boxes excepts fragments*/\n\tGF_List *TopBoxes;\n\n\t/*default track for sync of MPEG4 streams - this is the first accessed stream without OCR info - only set in READ mode*/\n\ts32 es_id_default_sync;\n\n\tBool is_smooth;\n\n\tGF_Err (*on_block_out)(void *usr_data, u8 *block, u32 block_size);\n\tGF_Err (*on_block_patch)(void *usr_data, u8 *block, u32 block_size, u64 block_offset, Bool is_insert);\n\tvoid *on_block_out_usr_data;\n\tu32 on_block_out_block_size;\n\n\t//in block disptach mode we don't have the full file, keep the position\n\tu64 fragmented_file_pos;\n\tu8 *block_buffer;\n\tu32 block_buffer_size;\n\n\tu32 nb_box_init_seg;\n\n\tBool no_inplace_rewrite;\n\tu32 padding;\n\tu64 original_moov_offset, original_meta_offset, first_data_toplevel_offset, first_data_toplevel_size;\n};\n\n/*time function*/\nu64 gf_isom_get_mp4time();\n/*set the last error of the file. if file is NULL, set the static error (used for IO errors*/\nvoid gf_isom_set_last_error(GF_ISOFile *the_file, GF_Err error);\nGF_Err gf_isom_parse_movie_boxes(GF_ISOFile *mov, u32 *boxType, u64 *bytesMissing, Bool progressive_mode);\nGF_ISOFile *gf_isom_new_movie();\n/*Movie and Track access functions*/\nGF_TrackBox *gf_isom_get_track_from_file(GF_ISOFile *the_file, u32 trackNumber);\nGF_TrackBox *gf_isom_get_track(GF_MovieBox *moov, u32 trackNumber);\nGF_TrackBox *gf_isom_get_track_from_id(GF_MovieBox *moov, GF_ISOTrackID trackID);\nGF_TrackBox *gf_isom_get_track_from_original_id(GF_MovieBox *moov, u32 originalID, u32 originalFile);\nu32 gf_isom_get_tracknum_from_id(GF_MovieBox *moov, GF_ISOTrackID trackID);\n/*open a movie*/\nGF_ISOFile *gf_isom_open_file(const char *fileName, GF_ISOOpenMode OpenMode, const char *tmp_dir);\n/*close and delete a movie*/\nvoid gf_isom_delete_movie(GF_ISOFile *mov);\nvoid gf_isom_meta_restore_items_ref(GF_ISOFile *file, GF_MetaBox *meta);\n\nGF_MetaBox *gf_isom_get_meta(GF_ISOFile *file, Bool root_meta, u32 track_num);\n\n/*StreamDescription reconstruction Functions*/\nGF_Err GetESD(GF_MovieBox *moov, GF_ISOTrackID trackID, u32 StreamDescIndex, GF_ESD **outESD);\nGF_Err GetESDForTime(GF_MovieBox *moov, GF_ISOTrackID trackID, u64 CTS, GF_ESD **outESD);\nGF_Err Media_GetSampleDesc(GF_MediaBox *mdia, u32 SampleDescIndex, GF_SampleEntryBox **out_entry, u32 *dataRefIndex);\nGF_Err Media_GetSampleDescIndex(GF_MediaBox *mdia, u64 DTS, u32 *sampleDescIndex);\n/*get esd for given sample desc -\n\t@true_desc_only: if true doesn't emulate desc and returns native ESD,\n\t\t\t\totherwise emulates if needed/possible (TimedText) and return a hard copy of the desc\n*/\nGF_Err Media_GetESD(GF_MediaBox *mdia, u32 sampleDescIndex, GF_ESD **esd, Bool true_desc_only);\nBool Track_IsMPEG4Stream(u32 HandlerType);\nBool IsMP4Description(u32 entryType);\n/*Find a reference of a given type*/\nGF_Err Track_FindRef(GF_TrackBox *trak, u32 ReferenceType, GF_TrackReferenceTypeBox **dpnd);\n/*Time and sample*/\nGF_Err GetMediaTime(GF_TrackBox *trak, Bool force_non_empty, u64 movieTime, u64 *MediaTime, s64 *SegmentStartTime, s64 *MediaOffset, u8 *useEdit, u64 *next_edit_start_plus_one);\nGF_Err Media_GetSample(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample **samp, u32 *sampleDescriptionIndex, Bool no_data, u64 *out_offset);\nGF_Err Media_CheckDataEntry(GF_MediaBox *mdia, u32 dataEntryIndex);\nGF_Err Media_FindSyncSample(GF_SampleTableBox *stbl, u32 searchFromTime, u32 *sampleNumber, u8 mode);\nGF_Err Media_RewriteODFrame(GF_MediaBox *mdia, GF_ISOSample *sample);\nGF_Err Media_FindDataRef(GF_DataReferenceBox *dref, char *URLname, char *URNname, u32 *dataRefIndex);\nBool Media_IsSelfContained(GF_MediaBox *mdia, u32 StreamDescIndex);\n\ntypedef enum\n{\n\tISOM_DREF_MIXED = 0,\n\tISOM_DREF_SELF,\n\tISOM_DREF_EXT,\n} GF_ISOMDataRefAllType;\nGF_ISOMDataRefAllType Media_SelfContainedType(GF_MediaBox *mdia);\n\nGF_TrackBox *GetTrackbyID(GF_MovieBox *moov, GF_ISOTrackID TrackID);\n\n/*check the TimeToSample for the given time and return the Sample number\nif the entry is not found, return the closest sampleNumber in prevSampleNumber and 0 in sampleNumber\nif the DTS required is after all DTSs in the list, set prevSampleNumber and SampleNumber to 0\nuseCTS specifies that we're looking for a composition time\n*/\nGF_Err stbl_findEntryForTime(GF_SampleTableBox *stbl, u64 DTS, u8 useCTS, u32 *sampleNumber, u32 *prevSampleNumber);\n/*Reading of the sample tables*/\nGF_Err stbl_GetSampleSize(GF_SampleSizeBox *stsz, u32 SampleNumber, u32 *Size);\nGF_Err stbl_GetSampleCTS(GF_CompositionOffsetBox *ctts, u32 SampleNumber, s32 *CTSoffset);\nGF_Err stbl_GetSampleDTS(GF_TimeToSampleBox *stts, u32 SampleNumber, u64 *DTS);\nGF_Err stbl_GetSampleDTS_and_Duration(GF_TimeToSampleBox *stts, u32 SampleNumber, u64 *DTS, u32 *duration);\n\n/*find a RAP or set the prev / next RAPs if vars are passed*/\nGF_Err stbl_GetSampleRAP(GF_SyncSampleBox *stss, u32 SampleNumber, GF_ISOSAPType *IsRAP, u32 *prevRAP, u32 *nextRAP);\n/*same as above but only look for open-gop RAPs and GDR (roll)*/\nGF_Err stbl_SearchSAPs(GF_SampleTableBox *stbl, u32 SampleNumber, GF_ISOSAPType *IsRAP, u32 *prevRAP, u32 *nextRAP);\nGF_Err stbl_GetSampleInfos(GF_SampleTableBox *stbl, u32 sampleNumber, u64 *offset, u32 *chunkNumber, u32 *descIndex, GF_StscEntry **scsc_entry);\nGF_Err stbl_GetSampleShadow(GF_ShadowSyncBox *stsh, u32 *sampleNumber, u32 *syncNum);\nGF_Err stbl_GetPaddingBits(GF_PaddingBitsBox *padb, u32 SampleNumber, u8 *PadBits);\nGF_Err stbl_GetSampleDepType(GF_SampleDependencyTypeBox *stbl, u32 SampleNumber, u32 *isLeading, u32 *dependsOn, u32 *dependedOn, u32 *redundant);\n\n\n/*unpack sample2chunk and chunk offset so that we have 1 sample per chunk (edition mode only)*/\nGF_Err stbl_UnpackOffsets(GF_SampleTableBox *stbl);\nGF_Err stbl_unpackCTS(GF_SampleTableBox *stbl);\nGF_Err SetTrackDuration(GF_TrackBox *trak);\nGF_Err Media_SetDuration(GF_TrackBox *trak);\n\n/*rewrites 3GP samples desc as MPEG-4 ESD*/\nGF_Err gf_isom_get_ttxt_esd(GF_MediaBox *mdia, GF_ESD **out_esd);\n/*inserts TTU header - only used when conversion to StreamingText is on*/\nGF_Err gf_isom_rewrite_text_sample(GF_ISOSample *samp, u32 sampleDescriptionIndex, u32 sample_dur);\n\nGF_UserDataMap *udta_getEntry(GF_UserDataBox *ptr, u32 box_type, bin128 *uuid);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err FlushCaptureMode(GF_ISOFile *movie);\nGF_Err CanAccessMovie(GF_ISOFile *movie, GF_ISOOpenMode Mode);\nGF_ISOFile *gf_isom_create_movie(const char *fileName, GF_ISOOpenMode OpenMode, const char *tmp_dir);\nGF_Err gf_isom_insert_moov(GF_ISOFile *file);\n\nGF_Err WriteToFile(GF_ISOFile *movie, Bool for_fragments);\nGF_Err Track_SetStreamDescriptor(GF_TrackBox *trak, u32 StreamDescriptionIndex, u32 DataReferenceIndex, GF_ESD *esd, u32 *outStreamIndex);\nu8 RequestTrack(GF_MovieBox *moov, GF_ISOTrackID TrackID);\n/*Track-Media setup*/\nGF_Err NewMedia(GF_MediaBox **mdia, u32 MediaType, u32 TimeScale);\nGF_Err Media_ParseODFrame(GF_MediaBox *mdia, const GF_ISOSample *sample, GF_ISOSample **od_samp);\nGF_Err Media_AddSample(GF_MediaBox *mdia, u64 data_offset, const GF_ISOSample *sample, u32 StreamDescIndex, u32 syncShadowNumber);\nGF_Err Media_CreateDataRef(GF_ISOFile *file, GF_DataReferenceBox *dref, char *URLname, char *URNname, u32 *dataRefIndex);\nGF_Err Media_SetDrefURL(GF_DataEntryURLBox *dref_entry, const char *origName, const char *finalName);\n\n/*update a media sample. ONLY in edit mode*/\nGF_Err Media_UpdateSample(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample *sample, Bool data_only);\nGF_Err Media_UpdateSampleReference(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample *sample, u64 data_offset);\n/*addition in the sample tables*/\nGF_Err stbl_AddDTS(GF_SampleTableBox *stbl, u64 DTS, u32 *sampleNumber, u32 LastAUDefDuration, u32 nb_pack_samples);\nGF_Err stbl_AddCTS(GF_SampleTableBox *stbl, u32 sampleNumber, s32 CTSoffset);\nGF_Err stbl_AddSize(GF_SampleSizeBox *stsz, u32 sampleNumber, u32 size, u32 nb_pack_samples);\nGF_Err stbl_AddRAP(GF_SyncSampleBox *stss, u32 sampleNumber);\nGF_Err stbl_AddShadow(GF_ShadowSyncBox *stsh, u32 sampleNumber, u32 shadowNumber);\nGF_Err stbl_AddChunkOffset(GF_MediaBox *mdia, u32 sampleNumber, u32 StreamDescIndex, u64 offset, u32 nb_pack_samples);\n/*NB - no add for padding, this is done only through SetPaddingBits*/\n\nGF_Err stbl_AddSampleFragment(GF_SampleTableBox *stbl, u32 sampleNumber, u16 size);\n\n/*update of the sample table\nall these functions are called in edit and we always have 1 sample per chunk*/\nGF_Err stbl_SetChunkOffset(GF_MediaBox *mdia, u32 sampleNumber, u64 offset);\nGF_Err stbl_SetSampleCTS(GF_SampleTableBox *stbl, u32 sampleNumber, s32 offset);\nGF_Err stbl_SetSampleSize(GF_SampleSizeBox *stsz, u32 SampleNumber, u32 size);\nGF_Err stbl_SetSampleRAP(GF_SyncSampleBox *stss, u32 SampleNumber, u8 isRAP);\nGF_Err stbl_SetSyncShadow(GF_ShadowSyncBox *stsh, u32 sampleNumber, u32 syncSample);\nGF_Err stbl_SetPaddingBits(GF_SampleTableBox *stbl, u32 SampleNumber, u8 bits);\n/*for adding fragmented samples*/\nGF_Err stbl_SampleSizeAppend(GF_SampleSizeBox *stsz, u32 data_size);\n/*writing of the final chunk info in edit mode*/\nGF_Err stbl_SetChunkAndOffset(GF_SampleTableBox *stbl, u32 sampleNumber, u32 StreamDescIndex, GF_SampleToChunkBox *the_stsc, GF_Box **the_stco, u64 data_offset, Bool forceNewChunk, u32 nb_samp);\n/*EDIT LIST functions*/\nGF_EdtsEntry *CreateEditEntry(u64 EditDuration, u64 MediaTime, u8 EditMode);\n\nGF_Err stbl_SetRedundant(GF_SampleTableBox *stbl, u32 sampleNumber);\nGF_Err stbl_AddRedundant(GF_SampleTableBox *stbl, u32 sampleNumber);\n\n/*REMOVE functions*/\nGF_Err stbl_RemoveDTS(GF_SampleTableBox *stbl, u32 sampleNumber, u32 nb_samples, u32 LastAUDefDuration);\nGF_Err stbl_RemoveCTS(GF_SampleTableBox *stbl, u32 sampleNumber, u32 nb_samples);\nGF_Err stbl_RemoveSize(GF_SampleTableBox *stbl, u32 sampleNumber, u32 nb_samples);\nGF_Err stbl_RemoveChunk(GF_SampleTableBox *stbl, u32 sampleNumber, u32 nb_samples);\nGF_Err stbl_RemoveRAP(GF_SampleTableBox *stbl, u32 sampleNumber);\nGF_Err stbl_RemoveShadow(GF_SampleTableBox *stbl, u32 sampleNumber);\nGF_Err stbl_RemovePaddingBits(GF_SampleTableBox *stbl, u32 SampleNumber);\nGF_Err stbl_RemoveRedundant(GF_SampleTableBox *stbl, u32 SampleNumber, u32 nb_samples);\nGF_Err stbl_RemoveSubSample(GF_SampleTableBox *stbl, u32 SampleNumber);\nGF_Err stbl_RemoveSampleGroup(GF_SampleTableBox *stbl, u32 SampleNumber);\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\nGF_Err gf_isom_close_fragments(GF_ISOFile *movie);\n#endif\n\nGF_Err gf_isom_flush_sidx(GF_ISOFile *movie, u32 sidx_max_size, Bool force_v1);\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nBool gf_isom_is_identical_sgpd(void *ptr1, void *ptr2, u32 grouping_type);\n\nGF_DefaultSampleGroupDescriptionEntry * gf_isom_get_sample_group_info_entry(GF_ISOFile *the_file, GF_TrackBox *trak, u32 grouping_type, u32 sample_description_index, u32 *default_index, GF_SampleGroupDescriptionBox **out_sgdp);\n\nGF_Err GetNextMediaTime(GF_TrackBox *trak, u64 movieTime, u64 *OutMovieTime);\nGF_Err GetPrevMediaTime(GF_TrackBox *trak, u64 movieTime, u64 *OutMovieTime);\n\nBool IsHintTrack(GF_TrackBox *trak);\nBool CheckHintFormat(GF_TrackBox *trak, u32 HintType);\nu32 GetHintFormat(GF_TrackBox *trak);\n\n/*locate a box by its type or UUID*/\nGF_ItemListBox *gf_ismo_locate_box(GF_List *list, u32 boxType, bin128 UUID);\n\nGF_Err moov_on_child_box(GF_Box *ptr, GF_Box *a, Bool is_rem);\nGF_Err trak_on_child_box(GF_Box *ptr, GF_Box *a, Bool is_rem);\nGF_Err mvex_on_child_box(GF_Box *ptr, GF_Box *a, Bool is_rem);\nGF_Err stsd_on_child_box(GF_Box *ptr, GF_Box *a, Bool is_rem);\nGF_Err hnti_on_child_box(GF_Box *hnti, GF_Box *a, Bool is_rem);\nGF_Err udta_on_child_box(GF_Box *ptr, GF_Box *a, Bool is_rem);\nGF_Err edts_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem);\nGF_Err stdp_box_read(GF_Box *s, GF_BitStream *bs);\nGF_Err stbl_on_child_box(GF_Box *ptr, GF_Box *a, Bool is_rem);\nGF_Err sdtp_box_read(GF_Box *s, GF_BitStream *bs);\nGF_Err dinf_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem);\nGF_Err minf_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem);\nGF_Err mdia_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem);\nGF_Err traf_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem);\n\n/*rewrites avcC based on the given esd - this destroys the esd*/\nGF_Err AVC_HEVC_UpdateESD(GF_MPEGVisualSampleEntryBox *avc, GF_ESD *esd);\nvoid AVC_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *avc, GF_MediaBox *mdia);\nvoid AVC_RewriteESDescriptor(GF_MPEGVisualSampleEntryBox *avc);\nvoid HEVC_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *hevc, GF_MediaBox *mdia);\nvoid HEVC_RewriteESDescriptor(GF_MPEGVisualSampleEntryBox *hevc);\nvoid VP9_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *vp9, GF_MediaBox *mdia);\nvoid VP9_RewriteESDescriptor(GF_MPEGVisualSampleEntryBox *vp9);\nvoid AV1_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *av1, GF_MediaBox *mdia);\nvoid AV1_RewriteESDescriptor(GF_MPEGVisualSampleEntryBox *av1);\nGF_Err reftype_AddRefTrack(GF_TrackReferenceTypeBox *ref, GF_ISOTrackID trackID, u16 *outRefIndex);\nBool gf_isom_cenc_has_saiz_saio_track(GF_SampleTableBox *stbl, u32 scheme_type);\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nBool gf_isom_cenc_has_saiz_saio_traf(GF_TrackFragmentBox *traf, u32 scheme_type);\nvoid gf_isom_cenc_set_saiz_saio(GF_SampleEncryptionBox *senc, GF_SampleTableBox *stbl, GF_TrackFragmentBox  *traf, u32 len, Bool saio_32bits, Bool use_mkey);\n#endif\nGF_Err gf_isom_cenc_merge_saiz_saio(GF_SampleEncryptionBox *senc, GF_SampleTableBox *stbl, u64 offset, u32 len);\n\nvoid gf_isom_parse_trif_info(const u8 *data, u32 size, u32 *id, u32 *independent, Bool *full_picture, u32 *x, u32 *y, u32 *w, u32 *h);\n\nBool gf_isom_is_encrypted_entry(u32 entryType);\n\n//too export in constants\nBool gf_cenc_validate_key_info(const u8 *key_info, u32 key_info_size);\n\n\n/*! CENC auxiliary info*/\ntypedef struct __cenc_sample_aux_info\n{\n\tu8 *cenc_data;\n\tu32 cenc_data_size;\n \t/*! flag set if sample is clear - it MUST NOT be written to file*/\n\tu8 isNotProtected;\n\n\t/*! key info, for dump only (not valid otherwise)*/\n\tconst u8 *key_info;\n\tu32 key_info_size;\n} GF_CENCSampleAuxInfo;\n\n\n/*! destroys a CENC sample auxiliary structure\n\\param samp_aux_info the target auxiliary buffer\n*/\nvoid gf_isom_cenc_samp_aux_info_del(GF_CENCSampleAuxInfo *samp_aux_info);\n\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\n/*\n\t\tHinting stuff\n*/\n\n/*****************************************************\n\t\tRTP Data Entries\n*****************************************************/\n\ntypedef struct\n{\n\tu8 sender_current_time_present;\n\tu8 expected_residual_time_present;\n\tu8 session_close_bit;\n\tu8 object_close_bit;\n\tu16 transport_object_identifier;\n} GF_LCTheaderTemplate;\n\ntypedef struct\n{\n\tu8 header_extension_type;\n\tu8 content[3];\n\tu32 data_length;\n\tu8 *data;\n} GF_LCTheaderExtension;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\n\tGF_LCTheaderTemplate info;\n\tu16 header_ext_count;\n\tGF_LCTheaderExtension *headers;\n\n\tGF_List *constructors;\n} GF_FDpacketBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\n\tu8 FEC_encoding_ID;\n\tu16 FEC_instance_ID;\n\tu16 source_block_number;\n\tu16 encoding_symbol_ID;\n} GF_FECInformationBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\t//not registered with child list !!\n\tGF_FECInformationBox *feci;\n\tu32 data_length;\n\tu8 *data;\n} GF_ExtraDataBox;\n\n\n#define GF_ISMO_BASE_DTE_ENTRY\t\\\n\tu8 source;\n\ntypedef struct\n{\n\tGF_ISMO_BASE_DTE_ENTRY\n} GF_GenericDTE;\n\ntypedef struct\n{\n\tGF_ISMO_BASE_DTE_ENTRY\n} GF_EmptyDTE;\n\ntypedef struct\n{\n\tGF_ISMO_BASE_DTE_ENTRY\n\tu8 dataLength;\n\tchar data[14];\n} GF_ImmediateDTE;\n\ntypedef struct\n{\n\tGF_ISMO_BASE_DTE_ENTRY\n\ts8 trackRefIndex;\n\tu32 sampleNumber;\n\tu16 dataLength;\n\tu32 byteOffset;\n\tu16 bytesPerComp;\n\tu16 samplesPerComp;\n} GF_SampleDTE;\n\ntypedef struct\n{\n\tGF_ISMO_BASE_DTE_ENTRY\n\ts8 trackRefIndex;\n\tu32 streamDescIndex;\n\tu16 dataLength;\n\tu32 byteOffset;\n\tu32 reserved;\n} GF_StreamDescDTE;\n\nGF_GenericDTE *NewDTE(u8 type);\nvoid DelDTE(GF_GenericDTE *dte);\nGF_Err ReadDTE(GF_GenericDTE *dte, GF_BitStream *bs);\nGF_Err WriteDTE(GF_GenericDTE *dte, GF_BitStream *bs);\nGF_Err OffsetDTE(GF_GenericDTE *dte, u32 offset, u32 HintSampleNumber);\n\n/*****************************************************\n\t\tRTP Sample\n*****************************************************/\n\n/*data cache when reading*/\ntypedef struct __tag_hint_data_cache\n{\n\tGF_ISOSample *samp;\n\tGF_TrackBox *trak;\n\tu32 sample_num;\n} GF_HintDataCache;\n\ntypedef struct __tag_hint_sample\n{\n\t//for samples deriving from box\n\tGF_ISOM_BOX\n\n\t/*contains 4cc of hint track sample entry*/\n\tu32 hint_subtype;\n\tu16 packetCount;\n\tu16 reserved;\n\tGF_List *packetTable;\n\tu8 *AdditionalData;\n\tu32 dataLength;\n\t/*used internally for hinting*/\n\tu64 TransmissionTime;\n\t/*for read only, used to store samples fetched while building packets*/\n\tGF_List *sample_cache;\n\n\t//for dump\n\tGF_ISOTrackID trackID;\n\tu32 sampleNumber;\n\n\tGF_ExtraDataBox *extra_data;\n} GF_HintSample;\n\nGF_HintSample *gf_isom_hint_sample_new(u32 ProtocolType);\nvoid gf_isom_hint_sample_del(GF_HintSample *ptr);\nGF_Err gf_isom_hint_sample_read(GF_HintSample *ptr, GF_BitStream *bs, u32 sampleSize);\nGF_Err gf_isom_hint_sample_write(GF_HintSample *ptr, GF_BitStream *bs);\nu32 gf_isom_hint_sample_size(GF_HintSample *ptr);\n\n\n/*****************************************************\n\t\tHint Packets (generic packet for future protocol support)\n*****************************************************/\n#define GF_ISOM_BASE_PACKET\t\t\t\\\n\tu32 hint_subtype, sampleNumber;\t\\\n\tGF_ISOTrackID trackID;\\\n\ts32 relativeTransTime;\n\n\ntypedef struct\n{\n\tGF_ISOM_BASE_PACKET\n} GF_HintPacket;\n\nGF_HintPacket *gf_isom_hint_pck_new(u32 HintType);\nvoid gf_isom_hint_pck_del(GF_HintPacket *ptr);\nGF_Err gf_isom_hint_pck_read(GF_HintPacket *ptr, GF_BitStream *bs);\nGF_Err gf_isom_hint_pck_write(GF_HintPacket *ptr, GF_BitStream *bs);\nu32 gf_isom_hint_pck_size(GF_HintPacket *ptr);\nGF_Err gf_isom_hint_pck_offset(GF_HintPacket *ptr, u32 offset, u32 HintSampleNumber);\nGF_Err gf_isom_hint_pck_add_dte(GF_HintPacket *ptr, GF_GenericDTE *dte, u8 AtBegin);\n/*get the size of the packet AS RECONSTRUCTED BY THE SERVER (without CSRC)*/\nu32 gf_isom_hint_pck_length(GF_HintPacket *ptr);\n\n/*the RTP packet*/\ntypedef struct\n{\n\tGF_ISOM_BASE_PACKET\n\n\t/*RTP Header*/\n\tu8 P_bit;\n\tu8 X_bit;\n\tu8 M_bit;\n\t/*on 7 bits */\n\tu8 payloadType;\n\tu16 SequenceNumber;\n\t/*Hinting flags*/\n\tu8 B_bit;\n\tu8 R_bit;\n\t/*ExtraInfos TLVs - not really used */\n\tGF_List *TLV;\n\t/*DataTable - contains the DTEs...*/\n\tGF_List *DataTable;\n} GF_RTPPacket;\n\nGF_RTPPacket *gf_isom_hint_rtp_new();\nvoid gf_isom_hint_rtp_del(GF_RTPPacket *ptr);\nGF_Err gf_isom_hint_rtp_read(GF_RTPPacket *ptr, GF_BitStream *bs);\nGF_Err gf_isom_hint_rtp_write(GF_RTPPacket *ptr, GF_BitStream *bs);\nu32 gf_isom_hint_rtp_size(GF_RTPPacket *ptr);\nGF_Err gf_isom_hint_rtp_offset(GF_RTPPacket *ptr, u32 offset, u32 HintSampleNumber);\nu32 gf_isom_hint_rtp_length(GF_RTPPacket *ptr);\n\n\n/*the RTP packet*/\ntypedef struct\n{\n\tGF_ISOM_BASE_PACKET\n\n\t//RTCP report\n\tu8 Version, Padding, Count, PayloadType;\n\tu32 length;\n\tu8 *data;\n} GF_RTCPPacket;\n\nGF_RTCPPacket *gf_isom_hint_rtcp_new();\nvoid gf_isom_hint_rtcp_del(GF_RTCPPacket *ptr);\nGF_Err gf_isom_hint_rtcp_read(GF_RTCPPacket *ptr, GF_BitStream *bs);\nGF_Err gf_isom_hint_rtcp_write(GF_RTCPPacket *ptr, GF_BitStream *bs);\nu32 gf_isom_hint_rtcp_size(GF_RTCPPacket *ptr);\nu32 gf_isom_hint_rtcp_length(GF_RTCPPacket *ptr);\n\n\n#endif\n\n\nstruct _3gpp_text_sample\n{\n\tchar *text;\n\tu32 len;\n\n\tGF_TextStyleBox *styles;\n\t/*at most one of these*/\n\tGF_TextHighlightColorBox *highlight_color;\n\tGF_TextScrollDelayBox *scroll_delay;\n\tGF_TextBoxBox *box;\n\tGF_TextWrapBox *wrap;\n\n\tGF_List *others;\n\tGF_TextKaraokeBox *cur_karaoke;\n};\n\nGF_TextSample *gf_isom_parse_text_sample(GF_BitStream *bs);\n\nstruct _generic_subtitle_sample\n{\n\tchar *text;\n\tu32 len;\n};\nGF_GenericSubtitleSample *gf_isom_parse_generic_subtitle_sample(GF_BitStream *bs);\nGF_GenericSubtitleSample *gf_isom_parse_generic_subtitle_sample_from_data(u8 *data, u32 dataLength);\n\n\n/*do not throw fatal errors if boxes are duplicated, just warn and remove extra ones*/\n#define ERROR_ON_DUPLICATED_BOX(__abox, __parent) {\t\\\n\t\tchar __ptype[GF_4CC_MSIZE];\\\n\t\tstrcpy(__ptype, gf_4cc_to_str(__parent->type) );\\\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] extra box %s found in %s, deleting\\n\", gf_4cc_to_str(__abox->type), __ptype)); \\\n\t\tgf_isom_box_del_parent(& (__parent->child_boxes), __abox);\\\n\t\treturn GF_OK;\\\n\t}\n\n\n#ifndef GPAC_DISABLE_VTT\n\nGF_ISOSample *gf_isom_webvtt_to_sample(void *samp);\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tchar *string;\n} GF_StringBox;\n\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\n\tGF_StringBox *config;\n} GF_WebVTTSampleEntryBox;\n\nGF_WebVTTSampleEntryBox *gf_webvtt_isom_get_description(GF_ISOFile *movie, u32 trackNumber, u32 descriptionIndex);\n\n#endif /* GPAC_DISABLE_VTT */\n\n//exported for sgpd comparison in traf merge\nvoid sgpd_write_entry(u32 grouping_type, void *entry, GF_BitStream *bs);\nBool gf_isom_box_equal(GF_Box *a, GF_Box *b);\nGF_Box *gf_isom_clone_config_box(GF_Box *box);\n\nGF_Err gf_isom_box_dump(void *ptr, FILE * trace);\nGF_Err gf_isom_box_array_dump(GF_List *list, FILE * trace);\n\nvoid gf_isom_registry_disable(u32 boxCode, Bool disable);\n\n/*Apple extensions*/\nGF_Box *gf_isom_get_meta_extensions(GF_ISOFile *mov, Bool for_xtra);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Box *gf_isom_create_meta_extensions(GF_ISOFile *mov, Bool for_xtra);\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n#ifndef GPAC_DISABLE_ISOM_DUMP\nGF_Err gf_isom_box_dump_ex(void *ptr, FILE * trace, u32 box_4cc);\nGF_Err gf_isom_box_dump_start(GF_Box *a, const char *name, FILE * trace);\nvoid gf_isom_box_dump_done(const char *name, GF_Box *ptr, FILE *trace);\nBool gf_isom_box_is_file_level(GF_Box *s);\n#endif\n\nGF_Box *boxstring_new_with_data(u32 type, const char *string, GF_List **parent);\n\nGF_Err gf_isom_read_null_terminated_string(GF_Box *s, GF_BitStream *bs, u64 size, char **out_str);\n\nGF_Err MergeTrack(GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_MovieFragmentBox *moof, u64 moof_offset, s32 compresed_diff, u64 *cumulated_offset, Bool is_first_merge);\n\n\n#endif //GPAC_DISABLE_ISOM\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif //_GF_ISOMEDIA_DEV_H_\n\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthor: Romain Bouqueau, Jean Le Feuvre\n *\t\t\tCopyright (c) Romain Bouqueau 2012- Telecom Paris 2019-\n *\t\t\t\tAll rights reserved\n *\n *          Note: this development was kindly sponsorized by Vizion'R (http://vizionr.com)\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n\n#ifndef GPAC_DISABLE_ISOM\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid abst_box_del(GF_Box *s)\n{\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->movie_identifier)\n\t\tgf_free(ptr->movie_identifier);\n\tif (ptr->drm_data)\n\t\tgf_free(ptr->drm_data);\n\tif (ptr->meta_data)\n\t\tgf_free(ptr->meta_data);\n\n\twhile (gf_list_count(ptr->server_entry_table)) {\n\t\tgf_free(gf_list_get(ptr->server_entry_table, 0));\n\t\tgf_list_rem(ptr->server_entry_table, 0);\n\t}\n\tgf_list_del(ptr->server_entry_table);\n\n\twhile (gf_list_count(ptr->quality_entry_table)) {\n\t\tgf_free(gf_list_get(ptr->quality_entry_table, 0));\n\t\tgf_list_rem(ptr->quality_entry_table, 0);\n\t}\n\tgf_list_del(ptr->quality_entry_table);\n\n\n\twhile (gf_list_count(ptr->segment_run_table_entries)) {\n\t\tgf_isom_box_del((GF_Box *)gf_list_get(ptr->segment_run_table_entries, 0));\n\t\tgf_list_rem(ptr->segment_run_table_entries, 0);\n\t}\n\tgf_list_del(ptr->segment_run_table_entries);\n\n\twhile (gf_list_count(ptr->fragment_run_table_entries)) {\n\t\tgf_isom_box_del((GF_Box *)gf_list_get(ptr->fragment_run_table_entries, 0));\n\t\tgf_list_rem(ptr->fragment_run_table_entries, 0);\n\t}\n\tgf_list_del(ptr->fragment_run_table_entries);\n\n\tgf_free(ptr);\n}\n\nGF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\tint i;\n\tu32 tmp_strsize;\n\tchar *tmp_str;\n\tBool zfound=GF_FALSE;\n\tGF_Err e = GF_OK;\n\n\tISOM_DECREASE_SIZE(ptr, 25)\n\tptr->bootstrapinfo_version = gf_bs_read_u32(bs);\n\tptr->profile = gf_bs_read_int(bs, 2);\n\tptr->live = gf_bs_read_int(bs, 1);\n\tptr->update = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 4);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\tptr->current_media_time = gf_bs_read_u64(bs);\n\tptr->smpte_time_code_offset = gf_bs_read_u64(bs);\n\n\ti=0;\n\tif (ptr->size<8) return GF_ISOM_INVALID_FILE;\n\ttmp_strsize =(u32)ptr->size;\n\ttmp_str = gf_malloc(sizeof(char)*tmp_strsize);\n\tif (!tmp_str) return GF_OUT_OF_MEM;\n\tmemset(tmp_str, 0, sizeof(char)*tmp_strsize);\n\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i]) {\n\t\t\tzfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!zfound) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\tif (i) {\n\t\tptr->movie_identifier = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\tptr->server_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->server_entry_count; i++) {\n\t\tint j=0;\n\t\tzfound = GF_FALSE;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j]) {\n\t\t\t\tzfound = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\tif (!zfound) {\n\t\t\te = GF_ISOM_INVALID_FILE;\n\t\t\tgoto exit;\n\t\t}\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\tif (ptr->server_entry_count != gf_list_count(ptr->server_entry_table)) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\tzfound = GF_FALSE;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j]) {\n\t\t\t\tzfound = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\n\t\tif (!zfound) {\n\t\t\te = GF_ISOM_INVALID_FILE;\n\t\t\tgoto exit;\n\t\t}\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\tif (ptr->quality_entry_count != gf_list_count(ptr->quality_entry_table)) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\tzfound = GF_FALSE;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i]) {\n\t\t\tzfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!zfound) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n\tif (i) {\n\t\tptr->drm_data = gf_strdup(tmp_str);\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\tzfound = GF_FALSE;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i]) {\n\t\t\tzfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!zfound) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n\tif (i) {\n\t\tptr->meta_data = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\tptr->segment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\tGF_AdobeSegmentRunTableBox *asrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&asrt, bs);\n\t\tif (e) {\n\t\t\tif (asrt) gf_isom_box_del((GF_Box*)asrt);\n\t\t\tgoto exit;\n\t\t}\n\t\tgf_list_add(ptr->segment_run_table_entries, asrt);\n\t}\n\tif (ptr->segment_run_table_count != gf_list_count(ptr->segment_run_table_entries)) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\tptr->fragment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\tGF_AdobeFragmentRunTableBox *afrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&afrt, bs);\n\t\tif (e) {\n\t\t\tif (afrt) gf_isom_box_del((GF_Box*)afrt);\n\t\t\tgoto exit;\n\t\t}\n\t\tgf_list_add(ptr->fragment_run_table_entries, afrt);\n\t}\n\tif (ptr->fragment_run_table_count != gf_list_count(ptr->fragment_run_table_entries)) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\nexit:\n\tgf_free(tmp_str);\n\treturn e;\n}\n\nGF_Box *abst_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AdobeBootstrapInfoBox, GF_ISOM_BOX_TYPE_ABST);\n\ttmp->server_entry_table = gf_list_new();\n\ttmp->quality_entry_table = gf_list_new();\n\ttmp->segment_run_table_entries = gf_list_new();\n\ttmp->fragment_run_table_entries = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err abst_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tunsigned int i;\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->bootstrapinfo_version);\n\tgf_bs_write_int(bs, ptr->profile, 2);\n\tgf_bs_write_int(bs, ptr->live, 1);\n\tgf_bs_write_int(bs, ptr->update, 1);\n\tgf_bs_write_int(bs, ptr->reserved, 4);\n\tgf_bs_write_u32(bs, ptr->time_scale);\n\tgf_bs_write_u64(bs, ptr->current_media_time);\n\tgf_bs_write_u64(bs, ptr->smpte_time_code_offset);\n\tif (ptr->movie_identifier)\n\t\tgf_bs_write_data(bs, ptr->movie_identifier, (u32)strlen(ptr->movie_identifier) + 1);\n\telse\n\t\tgf_bs_write_u8(bs, 0);\n\n\tgf_bs_write_u8(bs, ptr->server_entry_count);\n\tfor (i=0; i<ptr->server_entry_count; i++) {\n\t\tchar *str = (char*)gf_list_get(ptr->server_entry_table, i);\n\t\tgf_bs_write_data(bs, str, (u32)strlen(str) + 1);\n\t}\n\n\tgf_bs_write_u8(bs, ptr->quality_entry_count);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tchar *str = (char*)gf_list_get(ptr->quality_entry_table, i);\n\t\tgf_bs_write_data(bs, str, (u32)strlen(str) + 1);\n\t}\n\n\tif (ptr->drm_data)\n\t\tgf_bs_write_data(bs, ptr->drm_data, (u32)strlen(ptr->drm_data) + 1);\n\telse\n\t\tgf_bs_write_u8(bs, 0);\n\n\tif (ptr->meta_data)\n\t\tgf_bs_write_data(bs, ptr->meta_data, (u32)strlen(ptr->meta_data) + 1);\n\telse\n\t\tgf_bs_write_u8(bs, 0);\n\n\tgf_bs_write_u8(bs, ptr->segment_run_table_count);\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\te = gf_isom_box_write((GF_Box *)gf_list_get(ptr->segment_run_table_entries, i), bs);\n\t\tif (e) return e;\n\t}\n\n\tgf_bs_write_u8(bs, ptr->fragment_run_table_count);\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\te = gf_isom_box_write((GF_Box *)gf_list_get(ptr->fragment_run_table_entries, i), bs);\n\t\tif (e) return e;\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Err abst_box_size(GF_Box *s)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\n\ts->size += 25\n\t           + (ptr->movie_identifier ? (strlen(ptr->movie_identifier) + 1) : 1)\n\t           + 1;\n\n\tfor (i=0; i<ptr->server_entry_count; i++)\n\t\ts->size += strlen(gf_list_get(ptr->server_entry_table, i)) + 1;\n\n\ts->size += 1;\n\n\tfor (i=0; i<ptr->quality_entry_count; i++)\n\t\ts->size += strlen(gf_list_get(ptr->quality_entry_table, i)) + 1;\n\n\ts->size += (ptr->drm_data ? (strlen(ptr->drm_data) + 1) : 1)\n\t           + (ptr->meta_data ? (strlen(ptr->meta_data) + 1) : 1)\n\t           + 1;\n\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\tGF_Box *box = (GF_Box *)gf_list_get(ptr->segment_run_table_entries, i);\n\t\te = gf_isom_box_size(box);\n\t\tif (e) return e;\n\t\ts->size += box->size;\n\t}\n\n\ts->size += 1;\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\tGF_Box *box = (GF_Box *)gf_list_get(ptr->fragment_run_table_entries, i);\n\t\te = gf_isom_box_size(box);\n\t\tif (e) return e;\n\t\ts->size += box->size;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid afra_box_del(GF_Box *s)\n{\n\tGF_AdobeFragRandomAccessBox *ptr = (GF_AdobeFragRandomAccessBox *)s;\n\tif (ptr == NULL) return;\n\n\twhile (gf_list_count(ptr->local_access_entries)) {\n\t\tgf_free(gf_list_get(ptr->local_access_entries, 0));\n\t\tgf_list_rem(ptr->local_access_entries, 0);\n\t}\n\tgf_list_del(ptr->local_access_entries);\n\n\twhile (gf_list_count(ptr->global_access_entries)) {\n\t\tgf_free(gf_list_get(ptr->global_access_entries, 0));\n\t\tgf_list_rem(ptr->global_access_entries, 0);\n\t}\n\tgf_list_del(ptr->global_access_entries);\n\n\tgf_free(ptr);\n}\n\nGF_Err afra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tunsigned int i;\n\tGF_AdobeFragRandomAccessBox *ptr = (GF_AdobeFragRandomAccessBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 9)\n\tptr->long_ids = gf_bs_read_int(bs, 1);\n\tptr->long_offsets = gf_bs_read_int(bs, 1);\n\tptr->global_entries = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 5);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\n\tptr->entry_count = gf_bs_read_u32(bs);\n\tif (ptr->size < ptr->entry_count * (ptr->long_offsets ? 16 : 12))\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tGF_AfraEntry *ae = gf_malloc(sizeof(GF_AfraEntry));\n\t\tif (!ae) return GF_OUT_OF_MEM;\n\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tae->time = gf_bs_read_u64(bs);\n\t\tif (ptr->long_offsets) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\tae->offset = gf_bs_read_u64(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\tae->offset = gf_bs_read_u32(bs);\n\t\t}\n\n\t\tgf_list_insert(ptr->local_access_entries, ae, i);\n\t}\n\n\tif (ptr->global_entries) {\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\tptr->global_entry_count = gf_bs_read_u32(bs);\n\t\tfor (i=0; i<ptr->global_entry_count; i++) {\n\t\t\tGF_GlobalAfraEntry *ae = gf_malloc(sizeof(GF_GlobalAfraEntry));\n\t\t\tif (!ae) return GF_OUT_OF_MEM;\n\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\tae->time = gf_bs_read_u64(bs);\n\t\t\tif (ptr->long_ids) {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\t\tae->segment = gf_bs_read_u32(bs);\n\t\t\t\tae->fragment = gf_bs_read_u32(bs);\n\t\t\t} else {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\t\tae->segment = gf_bs_read_u16(bs);\n\t\t\t\tae->fragment = gf_bs_read_u16(bs);\n\t\t\t}\n\t\t\tif (ptr->long_offsets) {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 16)\n\t\t\t\tae->afra_offset = gf_bs_read_u64(bs);\n\t\t\t\tae->offset_from_afra = gf_bs_read_u64(bs);\n\t\t\t} else {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\t\tae->afra_offset = gf_bs_read_u32(bs);\n\t\t\t\tae->offset_from_afra = gf_bs_read_u32(bs);\n\t\t\t}\n\n\t\t\tgf_list_insert(ptr->global_access_entries, ae, i);\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Box *afra_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AdobeFragRandomAccessBox, GF_ISOM_BOX_TYPE_AFRA);\n\ttmp->local_access_entries = gf_list_new();\n\ttmp->global_access_entries = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err afra_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tunsigned int i;\n\tGF_AdobeFragRandomAccessBox *ptr = (GF_AdobeFragRandomAccessBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, ptr->long_ids, 1);\n\tgf_bs_write_int(bs, ptr->long_offsets, 1);\n\tgf_bs_write_int(bs, ptr->global_entries, 1);\n\tgf_bs_write_int(bs, 0, 5);\n\tgf_bs_write_u32(bs, ptr->time_scale);\n\n\tgf_bs_write_u32(bs, ptr->entry_count);\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tGF_AfraEntry *ae = (GF_AfraEntry *)gf_list_get(ptr->local_access_entries, i);\n\t\tgf_bs_write_u64(bs, ae->time);\n\t\tif (ptr->long_offsets)\n\t\t\tgf_bs_write_u64(bs, ae->offset);\n\t\telse\n\t\t\tgf_bs_write_u32(bs, (u32)ae->offset);\n\t}\n\n\tif (ptr->global_entries) {\n\t\tgf_bs_write_u32(bs, ptr->global_entry_count);\n\t\tfor (i=0; i<ptr->global_entry_count; i++) {\n\t\t\tGF_GlobalAfraEntry *gae = (GF_GlobalAfraEntry *)gf_list_get(ptr->global_access_entries, i);\n\t\t\tgf_bs_write_u64(bs, gae->time);\n\t\t\tif (ptr->long_ids) {\n\t\t\t\tgf_bs_write_u32(bs, gae->segment);\n\t\t\t\tgf_bs_write_u32(bs, gae->fragment);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u16(bs, (u16)gae->segment);\n\t\t\t\tgf_bs_write_u16(bs, (u16)gae->fragment);\n\t\t\t}\n\t\t\tif (ptr->long_offsets) {\n\t\t\t\tgf_bs_write_u64(bs, gae->afra_offset);\n\t\t\t\tgf_bs_write_u64(bs, gae->offset_from_afra);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u32(bs, (u32)gae->afra_offset);\n\t\t\t\tgf_bs_write_u32(bs, (u32)gae->offset_from_afra);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\n\nGF_Err afra_box_size(GF_Box *s)\n{\n\tGF_AdobeFragRandomAccessBox *ptr = (GF_AdobeFragRandomAccessBox *)s;\n\n\ts->size += 9\n\t           + ptr->entry_count * (ptr->long_offsets ? 16 : 12)\n\t           + (ptr->global_entries ? 4 + ptr->global_entry_count * (4 + (ptr->long_offsets ? 16 : 8) + (ptr->long_ids ? 8 : 4)) : 0);\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid asrt_box_del(GF_Box *s)\n{\n\tGF_AdobeSegmentRunTableBox *ptr = (GF_AdobeSegmentRunTableBox *)s;\n\tif (ptr == NULL) return;\n\n\twhile (gf_list_count(ptr->quality_segment_url_modifiers)) {\n\t\tgf_free(gf_list_get(ptr->quality_segment_url_modifiers, 0));\n\t\tgf_list_rem(ptr->quality_segment_url_modifiers, 0);\n\t}\n\tgf_list_del(ptr->quality_segment_url_modifiers);\n\n\twhile (gf_list_count(ptr->segment_run_entry_table)) {\n\t\tgf_free(gf_list_get(ptr->segment_run_entry_table, 0));\n\t\tgf_list_rem(ptr->segment_run_entry_table, 0);\n\t}\n\tgf_list_del(ptr->segment_run_entry_table);\n\n\tgf_free(ptr);\n}\n\nGF_Err asrt_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tunsigned int i;\n\tGF_AdobeSegmentRunTableBox *ptr = (GF_AdobeSegmentRunTableBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tif (ptr->size < ptr->quality_entry_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\tu32 tmp_strsize=(u32)ptr->size;\n\t\tchar *tmp_str = (char*) gf_malloc(tmp_strsize);\n\t\tif (!tmp_str) return GF_OUT_OF_MEM;\n\t\twhile (tmp_strsize) {\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\tISOM_DECREASE_SIZE(ptr, j)\n\t\tgf_list_insert(ptr->quality_segment_url_modifiers, tmp_str, i);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->segment_run_entry_count = gf_bs_read_u32(bs);\n\tif (ptr->size < ptr->segment_run_entry_count*8)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tfor (i=0; i<ptr->segment_run_entry_count; i++) {\n\t\tGF_AdobeSegmentRunEntry *sre = gf_malloc(sizeof(GF_AdobeSegmentRunEntry));\n\t\tif (!sre) return GF_OUT_OF_MEM;\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tsre->first_segment = gf_bs_read_u32(bs);\n\t\tsre->fragment_per_segment = gf_bs_read_u32(bs);\n\t\tgf_list_insert(ptr->segment_run_entry_table, sre, i);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Box *asrt_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AdobeSegmentRunTableBox, GF_ISOM_BOX_TYPE_ASRT);\n\ttmp->quality_segment_url_modifiers = gf_list_new();\n\ttmp->segment_run_entry_table = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err asrt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tunsigned int i;\n\tGF_AdobeSegmentRunTableBox *ptr = (GF_AdobeSegmentRunTableBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->quality_entry_count);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tchar *str = (char*)gf_list_get(ptr->quality_segment_url_modifiers, i);\n\t\tgf_bs_write_data(bs, str, (u32)strlen(str) + 1);\n\t}\n\n\tgf_bs_write_u32(bs, ptr->segment_run_entry_count);\n\tfor (i=0; i<ptr->segment_run_entry_count; i++) {\n\t\tGF_AdobeSegmentRunEntry *sre = (GF_AdobeSegmentRunEntry *)gf_list_get(ptr->segment_run_entry_table, i);\n\t\tgf_bs_write_u32(bs, sre->first_segment);\n\t\tgf_bs_write_u32(bs, sre->fragment_per_segment);\n\t}\n\n\treturn GF_OK;\n}\n\n\nGF_Err asrt_box_size(GF_Box *s)\n{\n\tint i;\n\tGF_AdobeSegmentRunTableBox *ptr = (GF_AdobeSegmentRunTableBox *)s;\n\n\ts->size += 5;\n\n\tfor (i=0; i<ptr->quality_entry_count; i++)\n\t\ts->size += strlen(gf_list_get(ptr->quality_segment_url_modifiers, i)) + 1;\n\n\ts->size += ptr->segment_run_entry_count * sizeof(GF_AdobeSegmentRunEntry);\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid afrt_box_del(GF_Box *s)\n{\n\tGF_AdobeFragmentRunTableBox *ptr = (GF_AdobeFragmentRunTableBox *)s;\n\tif (ptr == NULL) return;\n\n\twhile (gf_list_count(ptr->quality_segment_url_modifiers)) {\n\t\tgf_free(gf_list_get(ptr->quality_segment_url_modifiers, 0));\n\t\tgf_list_rem(ptr->quality_segment_url_modifiers, 0);\n\t}\n\tgf_list_del(ptr->quality_segment_url_modifiers);\n\n\twhile (gf_list_count(ptr->fragment_run_entry_table)) {\n\t\tgf_free(gf_list_get(ptr->fragment_run_entry_table, 0));\n\t\tgf_list_rem(ptr->fragment_run_entry_table, 0);\n\t}\n\tgf_list_del(ptr->fragment_run_entry_table);\n\n\tgf_free(ptr);\n}\n\nGF_Err afrt_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tunsigned int i;\n\tGF_AdobeFragmentRunTableBox *ptr = (GF_AdobeFragmentRunTableBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 5)\n\tptr->timescale = gf_bs_read_u32(bs);\n\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tif (ptr->size < ptr->quality_entry_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\tu32 tmp_strsize=(u32)ptr->size-8;\n\t\tchar *tmp_str = (char*) gf_malloc(tmp_strsize);\n\t\tif (!tmp_str) return GF_OUT_OF_MEM;\n\t\twhile (tmp_strsize) {\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\tISOM_DECREASE_SIZE(ptr, j)\n\t\tgf_list_insert(ptr->quality_segment_url_modifiers, tmp_str, i);\n\t}\n\n\tptr->fragment_run_entry_count = gf_bs_read_u32(bs);\n\tif (ptr->size < ptr->fragment_run_entry_count*16)\n\t\treturn GF_ISOM_INVALID_FILE;\n\tfor (i=0; i<ptr->fragment_run_entry_count; i++) {\n\t\tGF_AdobeFragmentRunEntry *fre = gf_malloc(sizeof(GF_AdobeFragmentRunEntry));\n\t\tif (!fre) return GF_ISOM_INVALID_FILE;\n\t\tISOM_DECREASE_SIZE(ptr, 16)\n\t\tfre->first_fragment = gf_bs_read_u32(bs);\n\t\tfre->first_fragment_timestamp = gf_bs_read_u64(bs);\n\t\tfre->fragment_duration = gf_bs_read_u32(bs);\n\t\tif (!fre->fragment_duration) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\t\tfre->discontinuity_indicator = gf_bs_read_u8(bs);\n\t\t}\n\t\tgf_list_insert(ptr->fragment_run_entry_table, fre, i);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Box *afrt_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AdobeFragmentRunTableBox, GF_ISOM_BOX_TYPE_AFRT);\n\ttmp->quality_segment_url_modifiers = gf_list_new();\n\ttmp->fragment_run_entry_table = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err afrt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tunsigned int i;\n\tGF_AdobeFragmentRunTableBox *ptr = (GF_AdobeFragmentRunTableBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->timescale);\n\tgf_bs_write_u8(bs, ptr->quality_entry_count);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tchar *str = (char*)gf_list_get(ptr->quality_segment_url_modifiers, i);\n\t\tgf_bs_write_data(bs, str, (u32)strlen(str) + 1);\n\t}\n\n\tgf_bs_write_u32(bs, ptr->fragment_run_entry_count);\n\tfor (i=0; i<ptr->fragment_run_entry_count; i++) {\n\t\tGF_AdobeFragmentRunEntry *fre = (GF_AdobeFragmentRunEntry *)gf_list_get(ptr->fragment_run_entry_table, i);\n\t\tgf_bs_write_u32(bs, fre->first_fragment);\n\t\tgf_bs_write_u64(bs, fre->first_fragment_timestamp);\n\t\tgf_bs_write_u32(bs, fre->fragment_duration);\n\t\tif (!fre->fragment_duration)\n\t\t\tgf_bs_write_u8(bs, fre->discontinuity_indicator);\n\t}\n\n\treturn GF_OK;\n}\n\n\nGF_Err afrt_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_AdobeFragmentRunTableBox *ptr = (GF_AdobeFragmentRunTableBox *)s;\n\n\ts->size += 5;\n\n\tfor (i=0; i<ptr->quality_entry_count; i++)\n\t\ts->size += strlen(gf_list_get(ptr->quality_segment_url_modifiers, i)) + 1;\n\n\ts->size += 4;\n\n\tfor (i=0; i<ptr->fragment_run_entry_count; i++) {\n\t\tGF_AdobeFragmentRunEntry *fre = (GF_AdobeFragmentRunEntry *)gf_list_get(ptr->fragment_run_entry_table, i);\n\t\tif (fre->fragment_duration)\n\t\t\ts->size += 16;\n\t\telse\n\t\t\ts->size += 17;\n\t}\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n#endif /*GPAC_DISABLE_ISOM*/\n\n#endif /*GPAC_DISABLE_ISOM_ADOBE*/\n"], "filenames": ["include/gpac/internal/isomedia_dev.h", "src/isomedia/box_code_adobe.c"], "buggy_code_start_loc": [601, 83], "buggy_code_end_loc": [601, 232], "fixing_code_start_loc": [602, 83], "fixing_code_end_loc": [609, 258], "type": "CWE-476", "message": "The abst_box_size function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command.", "other": {"cve": {"id": "CVE-2021-32132", "sourceIdentifier": "cve@mitre.org", "published": "2021-09-13T15:15:24.477", "lastModified": "2021-09-22T18:56:08.960", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The abst_box_size function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command."}, {"lang": "es", "value": "La funci\u00f3n abst_box_size en GPAC versi\u00f3n 1.0.1, permite a atacantes causar una denegaci\u00f3n de servicio (desreferencia de puntero NULL) por medio de un archivo dise\u00f1ado en el comando MP4Box"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "82DD2D40-0A05-48FD-940D-32B4D8B51AB3"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/e74be5976a6fee059c638050a237893f7e9a3b23", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/1753", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/e74be5976a6fee059c638050a237893f7e9a3b23"}}