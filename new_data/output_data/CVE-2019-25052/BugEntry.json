{"buggy_code": ["// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (c) 2014, STMicroelectronics International N.V.\n */\n\n#include <assert.h>\n#include <compiler.h>\n#include <crypto/crypto.h>\n#include <kernel/tee_ta_manager.h>\n#include <mm/tee_mmu.h>\n#include <stdlib_ext.h>\n#include <string_ext.h>\n#include <string.h>\n#include <sys/queue.h>\n#include <tee_api_types.h>\n#include <tee/tee_cryp_utl.h>\n#include <tee/tee_obj.h>\n#include <tee/tee_svc_cryp.h>\n#include <tee/tee_svc.h>\n#include <trace.h>\n#include <utee_defines.h>\n#include <util.h>\n#include <tee_api_defines_extensions.h>\n#if defined(CFG_CRYPTO_HKDF)\n#include <tee/tee_cryp_hkdf.h>\n#endif\n#if defined(CFG_CRYPTO_CONCAT_KDF)\n#include <tee/tee_cryp_concat_kdf.h>\n#endif\n#if defined(CFG_CRYPTO_PBKDF2)\n#include <tee/tee_cryp_pbkdf2.h>\n#endif\n\ntypedef void (*tee_cryp_ctx_finalize_func_t) (void *ctx, uint32_t algo);\nstruct tee_cryp_state {\n\tTAILQ_ENTRY(tee_cryp_state) link;\n\tuint32_t algo;\n\tuint32_t mode;\n\tvaddr_t key1;\n\tvaddr_t key2;\n\tvoid *ctx;\n\ttee_cryp_ctx_finalize_func_t ctx_finalize;\n};\n\nstruct tee_cryp_obj_secret {\n\tuint32_t key_size;\n\tuint32_t alloc_size;\n\n\t/*\n\t * Pseudo code visualize layout of structure\n\t * Next follows data, such as:\n\t *\tuint8_t data[alloc_size]\n\t * key_size must never exceed alloc_size\n\t */\n};\n\n#define TEE_TYPE_ATTR_OPTIONAL       0x0\n#define TEE_TYPE_ATTR_REQUIRED       0x1\n#define TEE_TYPE_ATTR_OPTIONAL_GROUP 0x2\n#define TEE_TYPE_ATTR_SIZE_INDICATOR 0x4\n#define TEE_TYPE_ATTR_GEN_KEY_OPT    0x8\n#define TEE_TYPE_ATTR_GEN_KEY_REQ    0x10\n\n    /* Handle storing of generic secret keys of varying lengths */\n#define ATTR_OPS_INDEX_SECRET     0\n    /* Convert to/from big-endian byte array and provider-specific bignum */\n#define ATTR_OPS_INDEX_BIGNUM     1\n    /* Convert to/from value attribute depending on direction */\n#define ATTR_OPS_INDEX_VALUE      2\n\nstruct tee_cryp_obj_type_attrs {\n\tuint32_t attr_id;\n\tuint16_t flags;\n\tuint16_t ops_index;\n\tuint16_t raw_offs;\n\tuint16_t raw_size;\n};\n\n#define RAW_DATA(_x, _y)\t\\\n\t.raw_offs = offsetof(_x, _y), .raw_size = MEMBER_SIZE(_x, _y)\n\nstatic const struct tee_cryp_obj_type_attrs\n\ttee_cryp_obj_secret_value_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_SECRET_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_SECRET,\n\t.raw_offs = 0,\n\t.raw_size = 0\n\t},\n};\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_rsa_pub_key_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_RSA_MODULUS,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_public_key, n)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_PUBLIC_EXPONENT,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_public_key, e)\n\t},\n};\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_rsa_keypair_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_RSA_MODULUS,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, n)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_PUBLIC_EXPONENT,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, e)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_PRIVATE_EXPONENT,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, d)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_PRIME1,\n\t.flags = TEE_TYPE_ATTR_OPTIONAL_GROUP,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, p)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_PRIME2,\n\t.flags = TEE_TYPE_ATTR_OPTIONAL_GROUP,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, q)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_EXPONENT1,\n\t.flags = TEE_TYPE_ATTR_OPTIONAL_GROUP,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, dp)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_EXPONENT2,\n\t.flags = TEE_TYPE_ATTR_OPTIONAL_GROUP,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, dq)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_COEFFICIENT,\n\t.flags = TEE_TYPE_ATTR_OPTIONAL_GROUP,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, qp)\n\t},\n};\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_dsa_pub_key_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_DSA_PRIME,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_public_key, p)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DSA_SUBPRIME,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_public_key, q)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DSA_BASE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_public_key, g)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DSA_PUBLIC_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_public_key, y)\n\t},\n};\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_dsa_keypair_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_DSA_PRIME,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_GEN_KEY_REQ,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_keypair, p)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DSA_SUBPRIME,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR |\n\t\t TEE_TYPE_ATTR_GEN_KEY_REQ,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_keypair, q)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DSA_BASE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_GEN_KEY_REQ,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_keypair, g)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DSA_PRIVATE_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_keypair, x)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DSA_PUBLIC_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_keypair, y)\n\t},\n};\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_dh_keypair_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_DH_PRIME,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR |\n\t\t TEE_TYPE_ATTR_GEN_KEY_REQ,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dh_keypair, p)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DH_BASE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_GEN_KEY_REQ,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dh_keypair, g)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DH_PUBLIC_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dh_keypair, y)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DH_PRIVATE_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dh_keypair, x)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DH_SUBPRIME,\n\t.flags = TEE_TYPE_ATTR_OPTIONAL_GROUP |\t TEE_TYPE_ATTR_GEN_KEY_OPT,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dh_keypair, q)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DH_X_BITS,\n\t.flags = TEE_TYPE_ATTR_GEN_KEY_OPT,\n\t.ops_index = ATTR_OPS_INDEX_VALUE,\n\tRAW_DATA(struct dh_keypair, xbits)\n\t},\n};\n\n#if defined(CFG_CRYPTO_HKDF)\nstatic const struct tee_cryp_obj_type_attrs\n\ttee_cryp_obj_hkdf_ikm_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_HKDF_IKM,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_SECRET,\n\t.raw_offs = 0,\n\t.raw_size = 0\n\t},\n};\n#endif\n\n#if defined(CFG_CRYPTO_CONCAT_KDF)\nstatic const struct tee_cryp_obj_type_attrs\n\ttee_cryp_obj_concat_kdf_z_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_CONCAT_KDF_Z,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_SECRET,\n\t.raw_offs = 0,\n\t.raw_size = 0\n\t},\n};\n#endif\n\n#if defined(CFG_CRYPTO_PBKDF2)\nstatic const struct tee_cryp_obj_type_attrs\n\ttee_cryp_obj_pbkdf2_passwd_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_PBKDF2_PASSWORD,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_SECRET,\n\t.raw_offs = 0,\n\t.raw_size = 0\n\t},\n};\n#endif\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_ecc_pub_key_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_ECC_PUBLIC_VALUE_X,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct ecc_public_key, x)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_ECC_PUBLIC_VALUE_Y,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct ecc_public_key, y)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_ECC_CURVE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_VALUE,\n\tRAW_DATA(struct ecc_public_key, curve)\n\t},\n};\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_ecc_keypair_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_ECC_PRIVATE_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct ecc_keypair, d)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_ECC_PUBLIC_VALUE_X,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct ecc_keypair, x)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_ECC_PUBLIC_VALUE_Y,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct ecc_keypair, y)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_ECC_CURVE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_VALUE,\n\tRAW_DATA(struct ecc_keypair, curve)\n\t},\n};\n\nstruct tee_cryp_obj_type_props {\n\tTEE_ObjectType obj_type;\n\tuint16_t min_size;\t/* may not be smaller than this */\n\tuint16_t max_size;\t/* may not be larger than this */\n\tuint16_t alloc_size;\t/* this many bytes are allocated to hold data */\n\tuint8_t quanta;\t\t/* may only be an multiple of this */\n\n\tuint8_t num_type_attrs;\n\tconst struct tee_cryp_obj_type_attrs *type_attrs;\n};\n\n#define PROP(obj_type, quanta, min_size, max_size, alloc_size, type_attrs) \\\n\t\t{ (obj_type), (min_size), (max_size), (alloc_size), (quanta), \\\n\t\t  ARRAY_SIZE(type_attrs), (type_attrs) }\n\nstatic const struct tee_cryp_obj_type_props tee_cryp_obj_props[] = {\n\tPROP(TEE_TYPE_AES, 64, 128, 256,\t/* valid sizes 128, 192, 256 */\n\t\t256 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_DES, 56, 56, 56,\n\t\t/*\n\t\t* Valid size 56 without parity, note that we still allocate\n\t\t* for 64 bits since the key is supplied with parity.\n\t\t*/\n\t\t64 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_DES3, 56, 112, 168,\n\t\t/*\n\t\t* Valid sizes 112, 168 without parity, note that we still\n\t\t* allocate for with space for the parity since the key is\n\t\t* supplied with parity.\n\t\t*/\n\t\t192 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_MD5, 8, 64, 512,\n\t\t512 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_SHA1, 8, 80, 512,\n\t\t512 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_SHA224, 8, 112, 512,\n\t\t512 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_SHA256, 8, 192, 1024,\n\t\t1024 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_SHA384, 8, 256, 1024,\n\t\t1024 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_SHA512, 8, 256, 1024,\n\t\t1024 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_GENERIC_SECRET, 8, 0, 4096,\n\t\t4096 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n#if defined(CFG_CRYPTO_HKDF)\n\tPROP(TEE_TYPE_HKDF_IKM, 8, 0, 4096,\n\t\t4096 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_hkdf_ikm_attrs),\n#endif\n#if defined(CFG_CRYPTO_CONCAT_KDF)\n\tPROP(TEE_TYPE_CONCAT_KDF_Z, 8, 0, 4096,\n\t\t4096 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_concat_kdf_z_attrs),\n#endif\n#if defined(CFG_CRYPTO_PBKDF2)\n\tPROP(TEE_TYPE_PBKDF2_PASSWORD, 8, 0, 4096,\n\t\t4096 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_pbkdf2_passwd_attrs),\n#endif\n\tPROP(TEE_TYPE_RSA_PUBLIC_KEY, 1, 256, CFG_CORE_BIGNUM_MAX_BITS,\n\t\tsizeof(struct rsa_public_key),\n\t\ttee_cryp_obj_rsa_pub_key_attrs),\n\n\tPROP(TEE_TYPE_RSA_KEYPAIR, 1, 256, CFG_CORE_BIGNUM_MAX_BITS,\n\t\tsizeof(struct rsa_keypair),\n\t\ttee_cryp_obj_rsa_keypair_attrs),\n\n\tPROP(TEE_TYPE_DSA_PUBLIC_KEY, 64, 512, 3072,\n\t\tsizeof(struct dsa_public_key),\n\t\ttee_cryp_obj_dsa_pub_key_attrs),\n\n\tPROP(TEE_TYPE_DSA_KEYPAIR, 64, 512, 3072,\n\t\tsizeof(struct dsa_keypair),\n\t\ttee_cryp_obj_dsa_keypair_attrs),\n\n\tPROP(TEE_TYPE_DH_KEYPAIR, 1, 256, 2048,\n\t\tsizeof(struct dh_keypair),\n\t\ttee_cryp_obj_dh_keypair_attrs),\n\n\tPROP(TEE_TYPE_ECDSA_PUBLIC_KEY, 1, 192, 521,\n\t\tsizeof(struct ecc_public_key),\n\t\ttee_cryp_obj_ecc_pub_key_attrs),\n\n\tPROP(TEE_TYPE_ECDSA_KEYPAIR, 1, 192, 521,\n\t\tsizeof(struct ecc_keypair),\n\t\ttee_cryp_obj_ecc_keypair_attrs),\n\n\tPROP(TEE_TYPE_ECDH_PUBLIC_KEY, 1, 192, 521,\n\t\tsizeof(struct ecc_public_key),\n\t\ttee_cryp_obj_ecc_pub_key_attrs),\n\n\tPROP(TEE_TYPE_ECDH_KEYPAIR, 1, 192, 521,\n\t\tsizeof(struct ecc_keypair),\n\t\ttee_cryp_obj_ecc_keypair_attrs),\n};\n\nstruct attr_ops {\n\tTEE_Result (*from_user)(void *attr, const void *buffer, size_t size);\n\tTEE_Result (*to_user)(void *attr, struct tee_ta_session *sess,\n\t\t\t      void *buffer, uint64_t *size);\n\tTEE_Result (*to_binary)(void *attr, void *data, size_t data_len,\n\t\t\t    size_t *offs);\n\tbool (*from_binary)(void *attr, const void *data, size_t data_len,\n\t\t\t    size_t *offs);\n\tTEE_Result (*from_obj)(void *attr, void *src_attr);\n\tvoid (*free)(void *attr);\n\tvoid (*clear)(void *attr);\n};\n\nstatic TEE_Result op_u32_to_binary_helper(uint32_t v, uint8_t *data,\n\t\t\t\t    size_t data_len, size_t *offs)\n{\n\tuint32_t field;\n\tsize_t next_offs;\n\n\tif (ADD_OVERFLOW(*offs, sizeof(field), &next_offs))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tif (data && next_offs <= data_len) {\n\t\tfield = TEE_U32_TO_BIG_ENDIAN(v);\n\t\tmemcpy(data + *offs, &field, sizeof(field));\n\t}\n\t(*offs) = next_offs;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic bool op_u32_from_binary_helper(uint32_t *v, const uint8_t *data,\n\t\t\t\t      size_t data_len, size_t *offs)\n{\n\tuint32_t field;\n\n\tif (!data || (*offs + sizeof(field)) > data_len)\n\t\treturn false;\n\n\tmemcpy(&field, data + *offs, sizeof(field));\n\t*v = TEE_U32_FROM_BIG_ENDIAN(field);\n\t(*offs) += sizeof(field);\n\treturn true;\n}\n\nstatic TEE_Result op_attr_secret_value_from_user(void *attr, const void *buffer,\n\t\t\t\t\t\t size_t size)\n{\n\tstruct tee_cryp_obj_secret *key = attr;\n\n\t/* Data size has to fit in allocated buffer */\n\tif (size > key->alloc_size)\n\t\treturn TEE_ERROR_SECURITY;\n\tmemcpy(key + 1, buffer, size);\n\tkey->key_size = size;\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result op_attr_secret_value_to_user(void *attr,\n\t\t\tstruct tee_ta_session *sess __unused,\n\t\t\tvoid *buffer, uint64_t *size)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_obj_secret *key = attr;\n\tuint64_t s;\n\tuint64_t key_size;\n\n\tres = tee_svc_copy_from_user(&s, size, sizeof(s));\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tkey_size = key->key_size;\n\tres = tee_svc_copy_to_user(size, &key_size, sizeof(key_size));\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (s < key->key_size || !buffer)\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\n\treturn tee_svc_copy_to_user(buffer, key + 1, key->key_size);\n}\n\nstatic TEE_Result op_attr_secret_value_to_binary(void *attr, void *data,\n\t\t\t\t\t   size_t data_len, size_t *offs)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_obj_secret *key = attr;\n\tsize_t next_offs;\n\n\tres = op_u32_to_binary_helper(key->key_size, data, data_len, offs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (ADD_OVERFLOW(*offs, key->key_size, &next_offs))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tif (data && next_offs <= data_len)\n\t\tmemcpy((uint8_t *)data + *offs, key + 1, key->key_size);\n\t(*offs) = next_offs;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic bool op_attr_secret_value_from_binary(void *attr, const void *data,\n\t\t\t\t\t     size_t data_len, size_t *offs)\n{\n\tstruct tee_cryp_obj_secret *key = attr;\n\tuint32_t s;\n\n\tif (!op_u32_from_binary_helper(&s, data, data_len, offs))\n\t\treturn false;\n\n\tif ((*offs + s) > data_len)\n\t\treturn false;\n\n\t/* Data size has to fit in allocated buffer */\n\tif (s > key->alloc_size)\n\t\treturn false;\n\tkey->key_size = s;\n\tmemcpy(key + 1, (const uint8_t *)data + *offs, s);\n\t(*offs) += s;\n\treturn true;\n}\n\n\nstatic TEE_Result op_attr_secret_value_from_obj(void *attr, void *src_attr)\n{\n\tstruct tee_cryp_obj_secret *key = attr;\n\tstruct tee_cryp_obj_secret *src_key = src_attr;\n\n\tif (src_key->key_size > key->alloc_size)\n\t\treturn TEE_ERROR_BAD_STATE;\n\tmemcpy(key + 1, src_key + 1, src_key->key_size);\n\tkey->key_size = src_key->key_size;\n\treturn TEE_SUCCESS;\n}\n\nstatic void op_attr_secret_value_clear(void *attr)\n{\n\tstruct tee_cryp_obj_secret *key = attr;\n\n\tkey->key_size = 0;\n\tmemset(key + 1, 0, key->alloc_size);\n}\n\nstatic TEE_Result op_attr_bignum_from_user(void *attr, const void *buffer,\n\t\t\t\t\t   size_t size)\n{\n\tstruct bignum **bn = attr;\n\n\treturn crypto_bignum_bin2bn(buffer, size, *bn);\n}\n\nstatic TEE_Result op_attr_bignum_to_user(void *attr,\n\t\t\t\t\t struct tee_ta_session *sess,\n\t\t\t\t\t void *buffer, uint64_t *size)\n{\n\tTEE_Result res;\n\tstruct bignum **bn = attr;\n\tuint64_t req_size;\n\tuint64_t s;\n\n\tres = tee_svc_copy_from_user(&s, size, sizeof(s));\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\treq_size = crypto_bignum_num_bytes(*bn);\n\tres = tee_svc_copy_to_user(size, &req_size, sizeof(req_size));\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (!req_size)\n\t\treturn TEE_SUCCESS;\n\tif (s < req_size || !buffer)\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\n\t/* Check we can access data using supplied user mode pointer */\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)buffer, req_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\t/*\n\t* Write the bignum (wich raw data points to) into an array of\n\t* bytes (stored in buffer)\n\t*/\n\tcrypto_bignum_bn2bin(*bn, buffer);\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result op_attr_bignum_to_binary(void *attr, void *data,\n\t\t\t\t\t   size_t data_len, size_t *offs)\n{\n\tTEE_Result res;\n\tstruct bignum **bn = attr;\n\tuint32_t n = crypto_bignum_num_bytes(*bn);\n\tsize_t next_offs;\n\n\tres = op_u32_to_binary_helper(n, data, data_len, offs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (ADD_OVERFLOW(*offs, n, &next_offs))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tif (data && next_offs <= data_len)\n\t\tcrypto_bignum_bn2bin(*bn, (uint8_t *)data + *offs);\n\t(*offs) = next_offs;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic bool op_attr_bignum_from_binary(void *attr, const void *data,\n\t\t\t\t       size_t data_len, size_t *offs)\n{\n\tstruct bignum **bn = attr;\n\tuint32_t n;\n\n\tif (!op_u32_from_binary_helper(&n, data, data_len, offs))\n\t\treturn false;\n\n\tif ((*offs + n) > data_len)\n\t\treturn false;\n\tif (crypto_bignum_bin2bn((const uint8_t *)data + *offs, n, *bn))\n\t\treturn false;\n\t(*offs) += n;\n\treturn true;\n}\n\nstatic TEE_Result op_attr_bignum_from_obj(void *attr, void *src_attr)\n{\n\tstruct bignum **bn = attr;\n\tstruct bignum **src_bn = src_attr;\n\n\tcrypto_bignum_copy(*bn, *src_bn);\n\treturn TEE_SUCCESS;\n}\n\nstatic void op_attr_bignum_clear(void *attr)\n{\n\tstruct bignum **bn = attr;\n\n\tcrypto_bignum_clear(*bn);\n}\n\nstatic void op_attr_bignum_free(void *attr)\n{\n\tstruct bignum **bn = attr;\n\n\tcrypto_bignum_free(*bn);\n\t*bn = NULL;\n}\n\nstatic TEE_Result op_attr_value_from_user(void *attr, const void *buffer,\n\t\t\t\t\t  size_t size)\n{\n\tuint32_t *v = attr;\n\n\tif (size != sizeof(uint32_t) * 2)\n\t\treturn TEE_ERROR_GENERIC; /* \"can't happen */\n\n\t/* Note that only the first value is copied */\n\tmemcpy(v, buffer, sizeof(uint32_t));\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result op_attr_value_to_user(void *attr,\n\t\t\t\t\tstruct tee_ta_session *sess __unused,\n\t\t\t\t\tvoid *buffer, uint64_t *size)\n{\n\tTEE_Result res;\n\tuint32_t *v = attr;\n\tuint64_t s;\n\tuint32_t value[2] = { *v };\n\tuint64_t req_size = sizeof(value);\n\n\tres = tee_svc_copy_from_user(&s, size, sizeof(s));\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (s < req_size || !buffer)\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\n\treturn tee_svc_copy_to_user(buffer, value, req_size);\n}\n\nstatic TEE_Result op_attr_value_to_binary(void *attr, void *data,\n\t\t\t\t\t  size_t data_len, size_t *offs)\n{\n\tuint32_t *v = attr;\n\n\treturn op_u32_to_binary_helper(*v, data, data_len, offs);\n}\n\nstatic bool op_attr_value_from_binary(void *attr, const void *data,\n\t\t\t\t      size_t data_len, size_t *offs)\n{\n\tuint32_t *v = attr;\n\n\treturn op_u32_from_binary_helper(v, data, data_len, offs);\n}\n\nstatic TEE_Result op_attr_value_from_obj(void *attr, void *src_attr)\n{\n\tuint32_t *v = attr;\n\tuint32_t *src_v = src_attr;\n\n\t*v = *src_v;\n\treturn TEE_SUCCESS;\n}\n\nstatic void op_attr_value_clear(void *attr)\n{\n\tuint32_t *v = attr;\n\n\t*v = 0;\n}\n\nstatic const struct attr_ops attr_ops[] = {\n\t[ATTR_OPS_INDEX_SECRET] = {\n\t\t.from_user = op_attr_secret_value_from_user,\n\t\t.to_user = op_attr_secret_value_to_user,\n\t\t.to_binary = op_attr_secret_value_to_binary,\n\t\t.from_binary = op_attr_secret_value_from_binary,\n\t\t.from_obj = op_attr_secret_value_from_obj,\n\t\t.free = op_attr_secret_value_clear, /* not a typo */\n\t\t.clear = op_attr_secret_value_clear,\n\t},\n\t[ATTR_OPS_INDEX_BIGNUM] = {\n\t\t.from_user = op_attr_bignum_from_user,\n\t\t.to_user = op_attr_bignum_to_user,\n\t\t.to_binary = op_attr_bignum_to_binary,\n\t\t.from_binary = op_attr_bignum_from_binary,\n\t\t.from_obj = op_attr_bignum_from_obj,\n\t\t.free = op_attr_bignum_free,\n\t\t.clear = op_attr_bignum_clear,\n\t},\n\t[ATTR_OPS_INDEX_VALUE] = {\n\t\t.from_user = op_attr_value_from_user,\n\t\t.to_user = op_attr_value_to_user,\n\t\t.to_binary = op_attr_value_to_binary,\n\t\t.from_binary = op_attr_value_from_binary,\n\t\t.from_obj = op_attr_value_from_obj,\n\t\t.free = op_attr_value_clear, /* not a typo */\n\t\t.clear = op_attr_value_clear,\n\t},\n};\n\nstatic TEE_Result get_user_u64_as_size_t(size_t *dst, uint64_t *src)\n{\n\tuint64_t d = 0;\n\tTEE_Result res = tee_svc_copy_from_user(&d, src, sizeof(d));\n\n\t/*\n\t * On 32-bit systems a size_t can't hold a uint64_t so we need to\n\t * check that the value isn't too large.\n\t */\n\tif (!res && ADD_OVERFLOW(0, d, dst))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\treturn res;\n}\n\nstatic TEE_Result put_user_u64(uint64_t *dst, size_t value)\n{\n\tuint64_t v = value;\n\n\treturn tee_svc_copy_to_user(dst, &v, sizeof(v));\n}\n\nTEE_Result syscall_cryp_obj_get_info(unsigned long obj, TEE_ObjectInfo *info)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\tgoto exit;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\tgoto exit;\n\n\tres = tee_svc_copy_to_user(info, &o->info, sizeof(o->info));\n\nexit:\n\treturn res;\n}\n\nTEE_Result syscall_cryp_obj_restrict_usage(unsigned long obj,\n\t\t\tunsigned long usage)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\tgoto exit;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\tgoto exit;\n\n\to->info.objectUsage &= usage;\n\nexit:\n\treturn res;\n}\n\nstatic int tee_svc_cryp_obj_find_type_attr_idx(\n\t\tuint32_t attr_id,\n\t\tconst struct tee_cryp_obj_type_props *type_props)\n{\n\tsize_t n;\n\n\tfor (n = 0; n < type_props->num_type_attrs; n++) {\n\t\tif (attr_id == type_props->type_attrs[n].attr_id)\n\t\t\treturn n;\n\t}\n\treturn -1;\n}\n\nstatic const struct tee_cryp_obj_type_props *tee_svc_find_type_props(\n\t\tTEE_ObjectType obj_type)\n{\n\tsize_t n;\n\n\tfor (n = 0; n < ARRAY_SIZE(tee_cryp_obj_props); n++) {\n\t\tif (tee_cryp_obj_props[n].obj_type == obj_type)\n\t\t\treturn tee_cryp_obj_props + n;\n\t}\n\n\treturn NULL;\n}\n\n/* Set an attribute on an object */\nstatic void set_attribute(struct tee_obj *o,\n\t\t\t  const struct tee_cryp_obj_type_props *props,\n\t\t\t  uint32_t attr)\n{\n\tint idx = tee_svc_cryp_obj_find_type_attr_idx(attr, props);\n\n\tif (idx < 0)\n\t\treturn;\n\to->have_attrs |= BIT(idx);\n}\n\n/* Get an attribute on an object */\nstatic uint32_t get_attribute(const struct tee_obj *o,\n\t\t\t      const struct tee_cryp_obj_type_props *props,\n\t\t\t      uint32_t attr)\n{\n\tint idx = tee_svc_cryp_obj_find_type_attr_idx(attr, props);\n\n\tif (idx < 0)\n\t\treturn 0;\n\treturn o->have_attrs & BIT(idx);\n}\n\nTEE_Result syscall_cryp_obj_get_attr(unsigned long obj, unsigned long attr_id,\n\t\t\tvoid *buffer, uint64_t *size)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tint idx;\n\tconst struct attr_ops *ops;\n\tvoid *attr;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\t/* Check that the object is initialized */\n\tif (!(o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/* Check that getting the attribute is allowed */\n\tif (!(attr_id & TEE_ATTR_BIT_PROTECTED) &&\n\t    !(o->info.objectUsage & TEE_USAGE_EXTRACTABLE))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props) {\n\t\t/* Unknown object type, \"can't happen\" */\n\t\treturn TEE_ERROR_BAD_STATE;\n\t}\n\n\tidx = tee_svc_cryp_obj_find_type_attr_idx(attr_id, type_props);\n\tif ((idx < 0) || ((o->have_attrs & (1 << idx)) == 0))\n\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\tops = attr_ops + type_props->type_attrs[idx].ops_index;\n\tattr = (uint8_t *)o->attr + type_props->type_attrs[idx].raw_offs;\n\treturn ops->to_user(attr, sess, buffer, size);\n}\n\nvoid tee_obj_attr_free(struct tee_obj *o)\n{\n\tconst struct tee_cryp_obj_type_props *tp;\n\tsize_t n;\n\n\tif (!o->attr)\n\t\treturn;\n\ttp = tee_svc_find_type_props(o->info.objectType);\n\tif (!tp)\n\t\treturn;\n\n\tfor (n = 0; n < tp->num_type_attrs; n++) {\n\t\tconst struct tee_cryp_obj_type_attrs *ta = tp->type_attrs + n;\n\n\t\tattr_ops[ta->ops_index].free((uint8_t *)o->attr + ta->raw_offs);\n\t}\n}\n\nvoid tee_obj_attr_clear(struct tee_obj *o)\n{\n\tconst struct tee_cryp_obj_type_props *tp;\n\tsize_t n;\n\n\tif (!o->attr)\n\t\treturn;\n\ttp = tee_svc_find_type_props(o->info.objectType);\n\tif (!tp)\n\t\treturn;\n\n\tfor (n = 0; n < tp->num_type_attrs; n++) {\n\t\tconst struct tee_cryp_obj_type_attrs *ta = tp->type_attrs + n;\n\n\t\tattr_ops[ta->ops_index].clear((uint8_t *)o->attr +\n\t\t\t\t\t      ta->raw_offs);\n\t}\n}\n\nTEE_Result tee_obj_attr_to_binary(struct tee_obj *o, void *data,\n\t\t\t\t  size_t *data_len)\n{\n\tconst struct tee_cryp_obj_type_props *tp;\n\tsize_t n;\n\tsize_t offs = 0;\n\tsize_t len = data ? *data_len : 0;\n\tTEE_Result res;\n\n\tif (o->info.objectType == TEE_TYPE_DATA) {\n\t\t*data_len = 0;\n\t\treturn TEE_SUCCESS; /* pure data object */\n\t}\n\tif (!o->attr)\n\t\treturn TEE_ERROR_BAD_STATE;\n\ttp = tee_svc_find_type_props(o->info.objectType);\n\tif (!tp)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tfor (n = 0; n < tp->num_type_attrs; n++) {\n\t\tconst struct tee_cryp_obj_type_attrs *ta = tp->type_attrs + n;\n\t\tvoid *attr = (uint8_t *)o->attr + ta->raw_offs;\n\n\t\tres = attr_ops[ta->ops_index].to_binary(attr, data, len, &offs);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\t*data_len = offs;\n\tif (data && offs > len)\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result tee_obj_attr_from_binary(struct tee_obj *o, const void *data,\n\t\t\t\t    size_t data_len)\n{\n\tconst struct tee_cryp_obj_type_props *tp;\n\tsize_t n;\n\tsize_t offs = 0;\n\n\tif (o->info.objectType == TEE_TYPE_DATA)\n\t\treturn TEE_SUCCESS; /* pure data object */\n\tif (!o->attr)\n\t\treturn TEE_ERROR_BAD_STATE;\n\ttp = tee_svc_find_type_props(o->info.objectType);\n\tif (!tp)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tfor (n = 0; n < tp->num_type_attrs; n++) {\n\t\tconst struct tee_cryp_obj_type_attrs *ta = tp->type_attrs + n;\n\t\tvoid *attr = (uint8_t *)o->attr + ta->raw_offs;\n\n\t\tif (!attr_ops[ta->ops_index].from_binary(attr, data, data_len,\n\t\t\t\t\t\t\t &offs))\n\t\t\treturn TEE_ERROR_CORRUPT_OBJECT;\n\t}\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result tee_obj_attr_copy_from(struct tee_obj *o, const struct tee_obj *src)\n{\n\tTEE_Result res;\n\tconst struct tee_cryp_obj_type_props *tp;\n\tconst struct tee_cryp_obj_type_attrs *ta;\n\tsize_t n;\n\tuint32_t have_attrs = 0;\n\tvoid *attr;\n\tvoid *src_attr;\n\n\tif (o->info.objectType == TEE_TYPE_DATA)\n\t\treturn TEE_SUCCESS; /* pure data object */\n\tif (!o->attr)\n\t\treturn TEE_ERROR_BAD_STATE;\n\ttp = tee_svc_find_type_props(o->info.objectType);\n\tif (!tp)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tif (o->info.objectType == src->info.objectType) {\n\t\thave_attrs = src->have_attrs;\n\t\tfor (n = 0; n < tp->num_type_attrs; n++) {\n\t\t\tta = tp->type_attrs + n;\n\t\t\tattr = (uint8_t *)o->attr + ta->raw_offs;\n\t\t\tsrc_attr = (uint8_t *)src->attr + ta->raw_offs;\n\t\t\tres = attr_ops[ta->ops_index].from_obj(attr, src_attr);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t}\n\t} else {\n\t\tconst struct tee_cryp_obj_type_props *tp_src;\n\t\tint idx;\n\n\t\tif (o->info.objectType == TEE_TYPE_RSA_PUBLIC_KEY) {\n\t\t\tif (src->info.objectType != TEE_TYPE_RSA_KEYPAIR)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t} else if (o->info.objectType == TEE_TYPE_DSA_PUBLIC_KEY) {\n\t\t\tif (src->info.objectType != TEE_TYPE_DSA_KEYPAIR)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t} else if (o->info.objectType == TEE_TYPE_ECDSA_PUBLIC_KEY) {\n\t\t\tif (src->info.objectType != TEE_TYPE_ECDSA_KEYPAIR)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t} else if (o->info.objectType == TEE_TYPE_ECDH_PUBLIC_KEY) {\n\t\t\tif (src->info.objectType != TEE_TYPE_ECDH_KEYPAIR)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\n\t\ttp_src = tee_svc_find_type_props(src->info.objectType);\n\t\tif (!tp_src)\n\t\t\treturn TEE_ERROR_BAD_STATE;\n\n\t\thave_attrs = BIT32(tp->num_type_attrs) - 1;\n\t\tfor (n = 0; n < tp->num_type_attrs; n++) {\n\t\t\tta = tp->type_attrs + n;\n\n\t\t\tidx = tee_svc_cryp_obj_find_type_attr_idx(ta->attr_id,\n\t\t\t\t\t\t\t\t  tp_src);\n\t\t\tif (idx < 0)\n\t\t\t\treturn TEE_ERROR_BAD_STATE;\n\n\t\t\tattr = (uint8_t *)o->attr + ta->raw_offs;\n\t\t\tsrc_attr = (uint8_t *)src->attr +\n\t\t\t\t   tp_src->type_attrs[idx].raw_offs;\n\t\t\tres = attr_ops[ta->ops_index].from_obj(attr, src_attr);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t}\n\t}\n\n\to->have_attrs = have_attrs;\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result tee_obj_set_type(struct tee_obj *o, uint32_t obj_type,\n\t\t\t    size_t max_key_size)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\n\t/* Can only set type for newly allocated objs */\n\tif (o->attr)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/*\n\t * Verify that maxKeySize is supported and find out how\n\t * much should be allocated.\n\t */\n\n\tif (obj_type == TEE_TYPE_DATA) {\n\t\tif (max_key_size)\n\t\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\t} else {\n\t\t/* Find description of object */\n\t\ttype_props = tee_svc_find_type_props(obj_type);\n\t\tif (!type_props)\n\t\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t\t/* Check that maxKeySize follows restrictions */\n\t\tif (max_key_size % type_props->quanta != 0)\n\t\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\t\tif (max_key_size < type_props->min_size)\n\t\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\t\tif (max_key_size > type_props->max_size)\n\t\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t\to->attr = calloc(1, type_props->alloc_size);\n\t\tif (!o->attr)\n\t\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\t}\n\n\t/* If we have a key structure, pre-allocate the bignums inside */\n\tswitch (obj_type) {\n\tcase TEE_TYPE_RSA_PUBLIC_KEY:\n\t\tres = crypto_acipher_alloc_rsa_public_key(o->attr,\n\t\t\t\t\t\t\t  max_key_size);\n\t\tbreak;\n\tcase TEE_TYPE_RSA_KEYPAIR:\n\t\tres = crypto_acipher_alloc_rsa_keypair(o->attr, max_key_size);\n\t\tbreak;\n\tcase TEE_TYPE_DSA_PUBLIC_KEY:\n\t\tres = crypto_acipher_alloc_dsa_public_key(o->attr,\n\t\t\t\t\t\t\t  max_key_size);\n\t\tbreak;\n\tcase TEE_TYPE_DSA_KEYPAIR:\n\t\tres = crypto_acipher_alloc_dsa_keypair(o->attr, max_key_size);\n\t\tbreak;\n\tcase TEE_TYPE_DH_KEYPAIR:\n\t\tres = crypto_acipher_alloc_dh_keypair(o->attr, max_key_size);\n\t\tbreak;\n\tcase TEE_TYPE_ECDSA_PUBLIC_KEY:\n\tcase TEE_TYPE_ECDH_PUBLIC_KEY:\n\t\tres = crypto_acipher_alloc_ecc_public_key(o->attr,\n\t\t\t\t\t\t\t  max_key_size);\n\t\tbreak;\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\t\tres = crypto_acipher_alloc_ecc_keypair(o->attr, max_key_size);\n\t\tbreak;\n\tdefault:\n\t\tif (obj_type != TEE_TYPE_DATA) {\n\t\t\tstruct tee_cryp_obj_secret *key = o->attr;\n\n\t\t\tkey->alloc_size = type_props->alloc_size -\n\t\t\t\t\t  sizeof(*key);\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\to->info.objectType = obj_type;\n\to->info.maxKeySize = max_key_size;\n\to->info.objectUsage = TEE_USAGE_DEFAULT;\n\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result syscall_cryp_obj_alloc(unsigned long obj_type,\n\t\t\tunsigned long max_key_size, uint32_t *obj)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\n\tif (obj_type == TEE_TYPE_DATA)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\to = tee_obj_alloc();\n\tif (!o)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\n\tres = tee_obj_set_type(o, obj_type, max_key_size);\n\tif (res != TEE_SUCCESS) {\n\t\ttee_obj_free(o);\n\t\treturn res;\n\t}\n\n\ttee_obj_add(to_user_ta_ctx(sess->ctx), o);\n\n\tres = tee_svc_copy_kaddr_to_uref(obj, o);\n\tif (res != TEE_SUCCESS)\n\t\ttee_obj_close(to_user_ta_ctx(sess->ctx), o);\n\treturn res;\n}\n\nTEE_Result syscall_cryp_obj_close(unsigned long obj)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/*\n\t * If it's busy it's used by an operation, a client should never have\n\t * this handle.\n\t */\n\tif (o->busy)\n\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\ttee_obj_close(to_user_ta_ctx(sess->ctx), o);\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result syscall_cryp_obj_reset(unsigned long obj)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) == 0) {\n\t\ttee_obj_attr_clear(o);\n\t\to->info.keySize = 0;\n\t\to->info.objectUsage = TEE_USAGE_DEFAULT;\n\t} else {\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\t/* the object is no more initialized */\n\to->info.handleFlags &= ~TEE_HANDLE_FLAG_INITIALIZED;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result copy_in_attrs(struct user_ta_ctx *utc,\n\t\t\tconst struct utee_attribute *usr_attrs,\n\t\t\tuint32_t attr_count, TEE_Attribute *attrs)\n{\n\tTEE_Result res;\n\tuint32_t n;\n\tsize_t size = 0;\n\n\tif (MUL_OVERFLOW(sizeof(struct utee_attribute), attr_count, &size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tres = tee_mmu_check_access_rights(utc,\n\t\t\tTEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t(uaddr_t)usr_attrs, size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tfor (n = 0; n < attr_count; n++) {\n\t\tattrs[n].attributeID = usr_attrs[n].attribute_id;\n\t\tif (attrs[n].attributeID & TEE_ATTR_BIT_VALUE) {\n\t\t\tattrs[n].content.value.a = usr_attrs[n].a;\n\t\t\tattrs[n].content.value.b = usr_attrs[n].b;\n\t\t} else {\n\t\t\tuintptr_t buf = usr_attrs[n].a;\n\t\t\tsize_t len = usr_attrs[n].b;\n\n\t\t\tres = tee_mmu_check_access_rights(utc,\n\t\t\t\tTEE_MEMORY_ACCESS_READ |\n\t\t\t\tTEE_MEMORY_ACCESS_ANY_OWNER, buf, len);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tattrs[n].content.ref.buffer = (void *)buf;\n\t\t\tattrs[n].content.ref.length = len;\n\t\t}\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\nenum attr_usage {\n\tATTR_USAGE_POPULATE,\n\tATTR_USAGE_GENERATE_KEY\n};\n\nstatic TEE_Result tee_svc_cryp_check_attr(enum attr_usage usage,\n\t\t\t\t\t  const struct tee_cryp_obj_type_props\n\t\t\t\t\t\t*type_props,\n\t\t\t\t\t  const TEE_Attribute *attrs,\n\t\t\t\t\t  uint32_t attr_count)\n{\n\tuint32_t required_flag;\n\tuint32_t opt_flag;\n\tbool all_opt_needed;\n\tuint32_t req_attrs = 0;\n\tuint32_t opt_grp_attrs = 0;\n\tuint32_t attrs_found = 0;\n\tsize_t n;\n\tuint32_t bit;\n\tuint32_t flags;\n\tint idx;\n\n\tif (usage == ATTR_USAGE_POPULATE) {\n\t\trequired_flag = TEE_TYPE_ATTR_REQUIRED;\n\t\topt_flag = TEE_TYPE_ATTR_OPTIONAL_GROUP;\n\t\tall_opt_needed = true;\n\t} else {\n\t\trequired_flag = TEE_TYPE_ATTR_GEN_KEY_REQ;\n\t\topt_flag = TEE_TYPE_ATTR_GEN_KEY_OPT;\n\t\tall_opt_needed = false;\n\t}\n\n\t/*\n\t * First find out which attributes are required and which belong to\n\t * the optional group\n\t */\n\tfor (n = 0; n < type_props->num_type_attrs; n++) {\n\t\tbit = 1 << n;\n\t\tflags = type_props->type_attrs[n].flags;\n\n\t\tif (flags & required_flag)\n\t\t\treq_attrs |= bit;\n\t\telse if (flags & opt_flag)\n\t\t\topt_grp_attrs |= bit;\n\t}\n\n\t/*\n\t * Verify that all required attributes are in place and\n\t * that the same attribute isn't repeated.\n\t */\n\tfor (n = 0; n < attr_count; n++) {\n\t\tidx = tee_svc_cryp_obj_find_type_attr_idx(\n\t\t\t\t\t\t\tattrs[n].attributeID,\n\t\t\t\t\t\t\ttype_props);\n\n\t\t/* attribute not defined in current object type */\n\t\tif (idx < 0)\n\t\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\t\tbit = 1 << idx;\n\n\t\t/* attribute not repeated */\n\t\tif ((attrs_found & bit) != 0)\n\t\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\t\tattrs_found |= bit;\n\t}\n\t/* Required attribute missing */\n\tif ((attrs_found & req_attrs) != req_attrs)\n\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\t/*\n\t * If the flag says that \"if one of the optional attributes are included\n\t * all of them has to be included\" this must be checked.\n\t */\n\tif (all_opt_needed && (attrs_found & opt_grp_attrs) != 0 &&\n\t    (attrs_found & opt_grp_attrs) != opt_grp_attrs)\n\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result get_ec_key_size(uint32_t curve, size_t *key_size)\n{\n\tswitch (curve) {\n\tcase TEE_ECC_CURVE_NIST_P192:\n\t\t*key_size = 192;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P224:\n\t\t*key_size = 224;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P256:\n\t\t*key_size = 256;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P384:\n\t\t*key_size = 384;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P521:\n\t\t*key_size = 521;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result tee_svc_cryp_obj_populate_type(\n\t\tstruct tee_obj *o,\n\t\tconst struct tee_cryp_obj_type_props *type_props,\n\t\tconst TEE_Attribute *attrs,\n\t\tuint32_t attr_count)\n{\n\tTEE_Result res;\n\tuint32_t have_attrs = 0;\n\tsize_t obj_size = 0;\n\tsize_t n;\n\tint idx;\n\tconst struct attr_ops *ops;\n\tvoid *attr;\n\n\tfor (n = 0; n < attr_count; n++) {\n\t\tidx = tee_svc_cryp_obj_find_type_attr_idx(\n\t\t\t\t\t\t\tattrs[n].attributeID,\n\t\t\t\t\t\t\ttype_props);\n\t\t/* attribute not defined in current object type */\n\t\tif (idx < 0)\n\t\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\t\thave_attrs |= BIT32(idx);\n\t\tops = attr_ops + type_props->type_attrs[idx].ops_index;\n\t\tattr = (uint8_t *)o->attr +\n\t\t       type_props->type_attrs[idx].raw_offs;\n\t\tif (attrs[n].attributeID & TEE_ATTR_BIT_VALUE)\n\t\t\tres = ops->from_user(attr, &attrs[n].content.value,\n\t\t\t\t\t     sizeof(attrs[n].content.value));\n\t\telse\n\t\t\tres = ops->from_user(attr, attrs[n].content.ref.buffer,\n\t\t\t\t\t     attrs[n].content.ref.length);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\t/*\n\t\t * First attr_idx signifies the attribute that gives the size\n\t\t * of the object\n\t\t */\n\t\tif (type_props->type_attrs[idx].flags &\n\t\t    TEE_TYPE_ATTR_SIZE_INDICATOR) {\n\t\t\t/*\n\t\t\t * For ECDSA/ECDH we need to translate curve into\n\t\t\t * object size\n\t\t\t */\n\t\t\tif (attrs[n].attributeID == TEE_ATTR_ECC_CURVE) {\n\t\t\t\tres = get_ec_key_size(attrs[n].content.value.a,\n\t\t\t\t\t\t      &obj_size);\n\t\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\t\treturn res;\n\t\t\t} else {\n\t\t\t\tobj_size += (attrs[n].content.ref.length * 8);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * We have to do it like this because the parity bits aren't counted\n\t * when telling the size of the key in bits.\n\t */\n\tif (o->info.objectType == TEE_TYPE_DES ||\n\t    o->info.objectType == TEE_TYPE_DES3)\n\t\tobj_size -= obj_size / 8; /* Exclude parity in size of key */\n\n\to->have_attrs = have_attrs;\n\to->info.keySize = obj_size;\n\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result syscall_cryp_obj_populate(unsigned long obj,\n\t\t\tstruct utee_attribute *usr_attrs,\n\t\t\tunsigned long attr_count)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tTEE_Attribute *attrs = NULL;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Must be a transient object */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/* Must not be initialized already */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tsize_t alloc_size = 0;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), attr_count, &alloc_size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tattrs = malloc(alloc_size);\n\tif (!attrs)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\n\tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_attrs, attr_count,\n\t\t\t    attrs);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_POPULATE, type_props,\n\t\t\t\t      attrs, attr_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_obj_populate_type(o, type_props, attrs, attr_count);\n\tif (res == TEE_SUCCESS)\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\nout:\n\tfree_wipe(attrs);\n\treturn res;\n}\n\nTEE_Result syscall_cryp_obj_copy(unsigned long dst, unsigned long src)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *dst_o;\n\tstruct tee_obj *src_o;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(dst), &dst_o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(src), &src_o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif ((src_o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tif ((dst_o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tif ((dst_o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tres = tee_obj_attr_copy_from(dst_o, src_o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tdst_o->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\tdst_o->info.keySize = src_o->info.keySize;\n\tdst_o->info.objectUsage = src_o->info.objectUsage;\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result tee_svc_obj_generate_key_rsa(\n\tstruct tee_obj *o, const struct tee_cryp_obj_type_props *type_props,\n\tuint32_t key_size,\n\tconst TEE_Attribute *params, uint32_t param_count)\n{\n\tTEE_Result res;\n\tstruct rsa_keypair *key = o->attr;\n\tuint32_t e = TEE_U32_TO_BIG_ENDIAN(65537);\n\n\t/* Copy the present attributes into the obj before starting */\n\tres = tee_svc_cryp_obj_populate_type(o, type_props, params,\n\t\t\t\t\t     param_count);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (!get_attribute(o, type_props, TEE_ATTR_RSA_PUBLIC_EXPONENT))\n\t\tcrypto_bignum_bin2bn((const uint8_t *)&e, sizeof(e), key->e);\n\tres = crypto_acipher_gen_rsa_key(key, key_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Set bits for all known attributes for this object type */\n\to->have_attrs = (1 << type_props->num_type_attrs) - 1;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result tee_svc_obj_generate_key_dsa(\n\tstruct tee_obj *o, const struct tee_cryp_obj_type_props *type_props,\n\tuint32_t key_size)\n{\n\tTEE_Result res;\n\n\tres = crypto_acipher_gen_dsa_key(o->attr, key_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Set bits for all known attributes for this object type */\n\to->have_attrs = (1 << type_props->num_type_attrs) - 1;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result tee_svc_obj_generate_key_dh(\n\tstruct tee_obj *o, const struct tee_cryp_obj_type_props *type_props,\n\tuint32_t key_size __unused,\n\tconst TEE_Attribute *params, uint32_t param_count)\n{\n\tTEE_Result res;\n\tstruct dh_keypair *tee_dh_key;\n\tstruct bignum *dh_q = NULL;\n\tuint32_t dh_xbits = 0;\n\n\t/* Copy the present attributes into the obj before starting */\n\tres = tee_svc_cryp_obj_populate_type(o, type_props, params,\n\t\t\t\t\t     param_count);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\ttee_dh_key = (struct dh_keypair *)o->attr;\n\n\tif (get_attribute(o, type_props, TEE_ATTR_DH_SUBPRIME))\n\t\tdh_q = tee_dh_key->q;\n\tif (get_attribute(o, type_props, TEE_ATTR_DH_X_BITS))\n\t\tdh_xbits = tee_dh_key->xbits;\n\tres = crypto_acipher_gen_dh_key(tee_dh_key, dh_q, dh_xbits);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Set bits for the generated public and private key */\n\tset_attribute(o, type_props, TEE_ATTR_DH_PUBLIC_VALUE);\n\tset_attribute(o, type_props, TEE_ATTR_DH_PRIVATE_VALUE);\n\tset_attribute(o, type_props, TEE_ATTR_DH_X_BITS);\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result tee_svc_obj_generate_key_ecc(\n\tstruct tee_obj *o, const struct tee_cryp_obj_type_props *type_props,\n\tuint32_t key_size __unused,\n\tconst TEE_Attribute *params, uint32_t param_count)\n{\n\tTEE_Result res;\n\tstruct ecc_keypair *tee_ecc_key;\n\n\t/* Copy the present attributes into the obj before starting */\n\tres = tee_svc_cryp_obj_populate_type(o, type_props, params,\n\t\t\t\t\t     param_count);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\ttee_ecc_key = (struct ecc_keypair *)o->attr;\n\n\tres = crypto_acipher_gen_ecc_key(tee_ecc_key);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Set bits for the generated public and private key */\n\tset_attribute(o, type_props, TEE_ATTR_ECC_PRIVATE_VALUE);\n\tset_attribute(o, type_props, TEE_ATTR_ECC_PUBLIC_VALUE_X);\n\tset_attribute(o, type_props, TEE_ATTR_ECC_PUBLIC_VALUE_Y);\n\tset_attribute(o, type_props, TEE_ATTR_ECC_CURVE);\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result syscall_obj_generate_key(unsigned long obj, unsigned long key_size,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tunsigned long param_count)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key;\n\tsize_t byte_size;\n\tTEE_Attribute *params = NULL;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Must be a transient object */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Must not be initialized already */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Find description of object */\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t/* Check that maxKeySize follows restrictions */\n\tif (key_size % type_props->quanta != 0)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size < type_props->min_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size > type_props->max_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\tsize_t alloc_size = 0;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), param_count, &alloc_size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tparams = malloc(alloc_size);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_params, param_count,\n\t\t\t    params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_GENERATE_KEY, type_props,\n\t\t\t\t      params, param_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tswitch (o->info.objectType) {\n\tcase TEE_TYPE_AES:\n\tcase TEE_TYPE_DES:\n\tcase TEE_TYPE_DES3:\n\tcase TEE_TYPE_HMAC_MD5:\n\tcase TEE_TYPE_HMAC_SHA1:\n\tcase TEE_TYPE_HMAC_SHA224:\n\tcase TEE_TYPE_HMAC_SHA256:\n\tcase TEE_TYPE_HMAC_SHA384:\n\tcase TEE_TYPE_HMAC_SHA512:\n\tcase TEE_TYPE_GENERIC_SECRET:\n\t\tbyte_size = key_size / 8;\n\n\t\t/*\n\t\t * We have to do it like this because the parity bits aren't\n\t\t * counted when telling the size of the key in bits.\n\t\t */\n\t\tif (o->info.objectType == TEE_TYPE_DES ||\n\t\t    o->info.objectType == TEE_TYPE_DES3) {\n\t\t\tbyte_size = (key_size + key_size / 7) / 8;\n\t\t}\n\n\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\tif (byte_size > key->alloc_size) {\n\t\t\tres = TEE_ERROR_EXCESS_DATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = crypto_rng_read((void *)(key + 1), byte_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tkey->key_size = byte_size;\n\n\t\t/* Set bits for all known attributes for this object type */\n\t\to->have_attrs = (1 << type_props->num_type_attrs) - 1;\n\n\t\tbreak;\n\n\tcase TEE_TYPE_RSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_rsa(o, type_props, key_size,\n\t\t\t\t\t\t   params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dsa(o, type_props, key_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dh(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_ecc(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_BAD_FORMAT;\n\t}\n\nout:\n\tfree_wipe(params);\n\tif (res == TEE_SUCCESS) {\n\t\to->info.keySize = key_size;\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t}\n\treturn res;\n}\n\nstatic TEE_Result tee_svc_cryp_get_state(struct tee_ta_session *sess,\n\t\t\t\t\t uint32_t state_id,\n\t\t\t\t\t struct tee_cryp_state **state)\n{\n\tstruct tee_cryp_state *s;\n\tstruct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);\n\n\tTAILQ_FOREACH(s, &utc->cryp_states, link) {\n\t\tif (state_id == (vaddr_t)s) {\n\t\t\t*state = s;\n\t\t\treturn TEE_SUCCESS;\n\t\t}\n\t}\n\treturn TEE_ERROR_BAD_PARAMETERS;\n}\n\nstatic void cryp_state_free(struct user_ta_ctx *utc, struct tee_cryp_state *cs)\n{\n\tstruct tee_obj *o;\n\n\tif (tee_obj_get(utc, cs->key1, &o) == TEE_SUCCESS)\n\t\ttee_obj_close(utc, o);\n\tif (tee_obj_get(utc, cs->key2, &o) == TEE_SUCCESS)\n\t\ttee_obj_close(utc, o);\n\n\tTAILQ_REMOVE(&utc->cryp_states, cs, link);\n\tif (cs->ctx_finalize != NULL)\n\t\tcs->ctx_finalize(cs->ctx, cs->algo);\n\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_CIPHER:\n\t\tcrypto_cipher_free_ctx(cs->ctx, cs->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_AE:\n\t\tcrypto_authenc_free_ctx(cs->ctx, cs->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_DIGEST:\n\t\tcrypto_hash_free_ctx(cs->ctx, cs->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tcrypto_mac_free_ctx(cs->ctx, cs->algo);\n\t\tbreak;\n\tdefault:\n\t\tassert(!cs->ctx);\n\t}\n\n\tfree(cs);\n}\n\nstatic TEE_Result tee_svc_cryp_check_key_type(const struct tee_obj *o,\n\t\t\t\t\t      uint32_t algo,\n\t\t\t\t\t      TEE_OperationMode mode)\n{\n\tuint32_t req_key_type;\n\tuint32_t req_key_type2 = 0;\n\n\tswitch (TEE_ALG_GET_MAIN_ALG(algo)) {\n\tcase TEE_MAIN_ALGO_MD5:\n\t\treq_key_type = TEE_TYPE_HMAC_MD5;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SHA1:\n\t\treq_key_type = TEE_TYPE_HMAC_SHA1;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SHA224:\n\t\treq_key_type = TEE_TYPE_HMAC_SHA224;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SHA256:\n\t\treq_key_type = TEE_TYPE_HMAC_SHA256;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SHA384:\n\t\treq_key_type = TEE_TYPE_HMAC_SHA384;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SHA512:\n\t\treq_key_type = TEE_TYPE_HMAC_SHA512;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_AES:\n\t\treq_key_type = TEE_TYPE_AES;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_DES:\n\t\treq_key_type = TEE_TYPE_DES;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_DES3:\n\t\treq_key_type = TEE_TYPE_DES3;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_RSA:\n\t\treq_key_type = TEE_TYPE_RSA_KEYPAIR;\n\t\tif (mode == TEE_MODE_ENCRYPT || mode == TEE_MODE_VERIFY)\n\t\t\treq_key_type2 = TEE_TYPE_RSA_PUBLIC_KEY;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_DSA:\n\t\treq_key_type = TEE_TYPE_DSA_KEYPAIR;\n\t\tif (mode == TEE_MODE_ENCRYPT || mode == TEE_MODE_VERIFY)\n\t\t\treq_key_type2 = TEE_TYPE_DSA_PUBLIC_KEY;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_DH:\n\t\treq_key_type = TEE_TYPE_DH_KEYPAIR;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_ECDSA:\n\t\treq_key_type = TEE_TYPE_ECDSA_KEYPAIR;\n\t\tif (mode == TEE_MODE_VERIFY)\n\t\t\treq_key_type2 = TEE_TYPE_ECDSA_PUBLIC_KEY;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_ECDH:\n\t\treq_key_type = TEE_TYPE_ECDH_KEYPAIR;\n\t\tbreak;\n#if defined(CFG_CRYPTO_HKDF)\n\tcase TEE_MAIN_ALGO_HKDF:\n\t\treq_key_type = TEE_TYPE_HKDF_IKM;\n\t\tbreak;\n#endif\n#if defined(CFG_CRYPTO_CONCAT_KDF)\n\tcase TEE_MAIN_ALGO_CONCAT_KDF:\n\t\treq_key_type = TEE_TYPE_CONCAT_KDF_Z;\n\t\tbreak;\n#endif\n#if defined(CFG_CRYPTO_PBKDF2)\n\tcase TEE_MAIN_ALGO_PBKDF2:\n\t\treq_key_type = TEE_TYPE_PBKDF2_PASSWORD;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\tif (req_key_type != o->info.objectType &&\n\t    req_key_type2 != o->info.objectType)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result syscall_cryp_state_alloc(unsigned long algo, unsigned long mode,\n\t\t\tunsigned long key1, unsigned long key2,\n\t\t\tuint32_t *state)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o1 = NULL;\n\tstruct tee_obj *o2 = NULL;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tif (key1 != 0) {\n\t\tres = tee_obj_get(utc, tee_svc_uref_to_vaddr(key1), &o1);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (o1->busy)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tres = tee_svc_cryp_check_key_type(o1, algo, mode);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\tif (key2 != 0) {\n\t\tres = tee_obj_get(utc, tee_svc_uref_to_vaddr(key2), &o2);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (o2->busy)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tres = tee_svc_cryp_check_key_type(o2, algo, mode);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tcs = calloc(1, sizeof(struct tee_cryp_state));\n\tif (!cs)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tTAILQ_INSERT_TAIL(&utc->cryp_states, cs, link);\n\tcs->algo = algo;\n\tcs->mode = mode;\n\n\tswitch (TEE_ALG_GET_CLASS(algo)) {\n\tcase TEE_OPERATION_EXTENSION:\n#ifdef CFG_CRYPTO_RSASSA_NA1\n\t\tif (algo == TEE_ALG_RSASSA_PKCS1_V1_5)\n\t\t\tgoto rsassa_na1;\n#endif\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tbreak;\n\tcase TEE_OPERATION_CIPHER:\n\t\tif ((algo == TEE_ALG_AES_XTS && (key1 == 0 || key2 == 0)) ||\n\t\t    (algo != TEE_ALG_AES_XTS && (key1 == 0 || key2 != 0))) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_cipher_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_AE:\n\t\tif (key1 == 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_authenc_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tif (key1 == 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_mac_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_DIGEST:\n\t\tif (key1 != 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_hash_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_ASYMMETRIC_CIPHER:\n\tcase TEE_OPERATION_ASYMMETRIC_SIGNATURE:\nrsassa_na1: __maybe_unused\n\t\tif (key1 == 0 || key2 != 0)\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tcase TEE_OPERATION_KEY_DERIVATION:\n\t\tif (key1 == 0 || key2 != 0)\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tdefault:\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tbreak;\n\t}\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_copy_kaddr_to_uref(state, cs);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\t/* Register keys */\n\tif (o1 != NULL) {\n\t\to1->busy = true;\n\t\tcs->key1 = (vaddr_t)o1;\n\t}\n\tif (o2 != NULL) {\n\t\to2->busy = true;\n\t\tcs->key2 = (vaddr_t)o2;\n\t}\n\nout:\n\tif (res != TEE_SUCCESS)\n\t\tcryp_state_free(utc, cs);\n\treturn res;\n}\n\nTEE_Result syscall_cryp_state_copy(unsigned long dst, unsigned long src)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs_dst;\n\tstruct tee_cryp_state *cs_src;\n\tstruct tee_ta_session *sess;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(dst), &cs_dst);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(src), &cs_src);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (cs_dst->algo != cs_src->algo || cs_dst->mode != cs_src->mode)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tswitch (TEE_ALG_GET_CLASS(cs_src->algo)) {\n\tcase TEE_OPERATION_CIPHER:\n\t\tcrypto_cipher_copy_state(cs_dst->ctx, cs_src->ctx,\n\t\t\t\t\t cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_AE:\n\t\tcrypto_authenc_copy_state(cs_dst->ctx, cs_src->ctx,\n\t\t\t\t\t  cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_DIGEST:\n\t\tcrypto_hash_copy_state(cs_dst->ctx, cs_src->ctx, cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tcrypto_mac_copy_state(cs_dst->ctx, cs_src->ctx, cs_src->algo);\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_STATE;\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\nvoid tee_svc_cryp_free_states(struct user_ta_ctx *utc)\n{\n\tstruct tee_cryp_state_head *states = &utc->cryp_states;\n\n\twhile (!TAILQ_EMPTY(states))\n\t\tcryp_state_free(utc, TAILQ_FIRST(states));\n}\n\nTEE_Result syscall_cryp_state_free(unsigned long state)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tcryp_state_free(to_user_ta_ctx(sess->ctx), cs);\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result syscall_hash_init(unsigned long state,\n\t\t\t     const void *iv __maybe_unused,\n\t\t\t     size_t iv_len __maybe_unused)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = crypto_hash_init(cs->ctx, cs->algo);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\t{\n\t\t\tstruct tee_obj *o;\n\t\t\tstruct tee_cryp_obj_secret *key;\n\n\t\t\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  cs->key1, &o);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tif ((o->info.handleFlags &\n\t\t\t     TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\t\tres = crypto_mac_init(cs->ctx, cs->algo,\n\t\t\t\t\t      (void *)(key + 1), key->key_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result syscall_hash_update(unsigned long state, const void *chunk,\n\t\t\tsize_t chunk_size)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\n\t/* No data, but size provided isn't valid parameters. */\n\tif (!chunk && chunk_size)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/* Zero length hash is valid, but nothing we need to do. */\n\tif (!chunk_size)\n\t\treturn TEE_SUCCESS;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)chunk, chunk_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = crypto_hash_update(cs->ctx, cs->algo, chunk, chunk_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tres = crypto_mac_update(cs->ctx, cs->algo, chunk, chunk_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result syscall_hash_final(unsigned long state, const void *chunk,\n\t\t\tsize_t chunk_size, void *hash, uint64_t *hash_len)\n{\n\tTEE_Result res, res2;\n\tsize_t hash_size;\n\tsize_t hlen = 0;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\n\t/* No data, but size provided isn't valid parameters. */\n\tif (!chunk && chunk_size)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)chunk, chunk_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = get_user_u64_as_size_t(&hlen, hash_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)hash, hlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = tee_hash_get_digest_size(cs->algo, &hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (hlen < hash_size) {\n\t\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (chunk_size) {\n\t\t\tres = crypto_hash_update(cs->ctx, cs->algo, chunk,\n\t\t\t\t\t\t chunk_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t}\n\n\t\tres = crypto_hash_final(cs->ctx, cs->algo, hash, hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\n\tcase TEE_OPERATION_MAC:\n\t\tres = tee_mac_get_digest_size(cs->algo, &hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (hlen < hash_size) {\n\t\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (chunk_size) {\n\t\t\tres = crypto_mac_update(cs->ctx, cs->algo, chunk,\n\t\t\t\t\t\tchunk_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t}\n\n\t\tres = crypto_mac_final(cs->ctx, cs->algo, hash, hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\nout:\n\tres2 = put_user_u64(hash_len, hash_size);\n\tif (res2 != TEE_SUCCESS)\n\t\treturn res2;\n\treturn res;\n}\n\nTEE_Result syscall_cipher_init(unsigned long state, const void *iv,\n\t\t\tsize_t iv_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key1;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_CIPHER)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = tee_mmu_check_access_rights(utc,\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t) iv, iv_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(utc, cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tkey1 = o->attr;\n\n\tif (tee_obj_get(utc, cs->key2, &o) == TEE_SUCCESS) {\n\t\tstruct tee_cryp_obj_secret *key2 = o->attr;\n\n\t\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t\tres = crypto_cipher_init(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t (uint8_t *)(key1 + 1), key1->key_size,\n\t\t\t\t\t (uint8_t *)(key2 + 1), key2->key_size,\n\t\t\t\t\t iv, iv_len);\n\t} else {\n\t\tres = crypto_cipher_init(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t (uint8_t *)(key1 + 1), key1->key_size,\n\t\t\t\t\t NULL, 0, iv, iv_len);\n\t}\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tcs->ctx_finalize = crypto_cipher_final;\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result tee_svc_cipher_update_helper(unsigned long state,\n\t\t\tbool last_block, const void *src, size_t src_len,\n\t\t\tvoid *dst, uint64_t *dst_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tsize_t dlen = 0;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)src, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (!dst_len) {\n\t\tdlen = 0;\n\t} else {\n\t\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t\t  (uaddr_t)dst, dlen);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tif (src_len > 0) {\n\t\t/* Permit src_len == 0 to finalize the operation */\n\t\tres = tee_do_cipher_update(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t   last_block, src, src_len, dst);\n\t}\n\n\tif (last_block && cs->ctx_finalize != NULL) {\n\t\tcs->ctx_finalize(cs->ctx, cs->algo);\n\t\tcs->ctx_finalize = NULL;\n\t}\n\nout:\n\tif ((res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) &&\n\t    dst_len != NULL) {\n\t\tTEE_Result res2;\n\n\t\tres2 = put_user_u64(dst_len, src_len);\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\tres = res2;\n\t}\n\n\treturn res;\n}\n\nTEE_Result syscall_cipher_update(unsigned long state, const void *src,\n\t\t\tsize_t src_len, void *dst, uint64_t *dst_len)\n{\n\treturn tee_svc_cipher_update_helper(state, false /* last_block */,\n\t\t\t\t\t    src, src_len, dst, dst_len);\n}\n\nTEE_Result syscall_cipher_final(unsigned long state, const void *src,\n\t\t\tsize_t src_len, void *dst, uint64_t *dst_len)\n{\n\treturn tee_svc_cipher_update_helper(state, true /* last_block */,\n\t\t\t\t\t    src, src_len, dst, dst_len);\n}\n\n#if defined(CFG_CRYPTO_HKDF)\nstatic TEE_Result get_hkdf_params(const TEE_Attribute *params,\n\t\t\t\t  uint32_t param_count,\n\t\t\t\t  void **salt, size_t *salt_len, void **info,\n\t\t\t\t  size_t *info_len, size_t *okm_len)\n{\n\tsize_t n;\n\tenum { SALT = 0x1, LENGTH = 0x2, INFO = 0x4 };\n\tuint8_t found = 0;\n\n\t*salt = *info = NULL;\n\t*salt_len = *info_len = *okm_len = 0;\n\n\tfor (n = 0; n < param_count; n++) {\n\t\tswitch (params[n].attributeID) {\n\t\tcase TEE_ATTR_HKDF_SALT:\n\t\t\tif (!(found & SALT)) {\n\t\t\t\t*salt = params[n].content.ref.buffer;\n\t\t\t\t*salt_len = params[n].content.ref.length;\n\t\t\t\tfound |= SALT;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TEE_ATTR_HKDF_OKM_LENGTH:\n\t\t\tif (!(found & LENGTH)) {\n\t\t\t\t*okm_len = params[n].content.value.a;\n\t\t\t\tfound |= LENGTH;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TEE_ATTR_HKDF_INFO:\n\t\t\tif (!(found & INFO)) {\n\t\t\t\t*info = params[n].content.ref.buffer;\n\t\t\t\t*info_len = params[n].content.ref.length;\n\t\t\t\tfound |= INFO;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Unexpected attribute */\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\n\t}\n\n\tif (!(found & LENGTH))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\treturn TEE_SUCCESS;\n}\n#endif\n\n#if defined(CFG_CRYPTO_CONCAT_KDF)\nstatic TEE_Result get_concat_kdf_params(const TEE_Attribute *params,\n\t\t\t\t\tuint32_t param_count,\n\t\t\t\t\tvoid **other_info,\n\t\t\t\t\tsize_t *other_info_len,\n\t\t\t\t\tsize_t *derived_key_len)\n{\n\tsize_t n;\n\tenum { LENGTH = 0x1, INFO = 0x2 };\n\tuint8_t found = 0;\n\n\t*other_info = NULL;\n\t*other_info_len = *derived_key_len = 0;\n\n\tfor (n = 0; n < param_count; n++) {\n\t\tswitch (params[n].attributeID) {\n\t\tcase TEE_ATTR_CONCAT_KDF_OTHER_INFO:\n\t\t\tif (!(found & INFO)) {\n\t\t\t\t*other_info = params[n].content.ref.buffer;\n\t\t\t\t*other_info_len = params[n].content.ref.length;\n\t\t\t\tfound |= INFO;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TEE_ATTR_CONCAT_KDF_DKM_LENGTH:\n\t\t\tif (!(found & LENGTH)) {\n\t\t\t\t*derived_key_len = params[n].content.value.a;\n\t\t\t\tfound |= LENGTH;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Unexpected attribute */\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\t}\n\n\tif (!(found & LENGTH))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\treturn TEE_SUCCESS;\n}\n#endif\n\n#if defined(CFG_CRYPTO_PBKDF2)\nstatic TEE_Result get_pbkdf2_params(const TEE_Attribute *params,\n\t\t\t\t   uint32_t param_count, void **salt,\n\t\t\t\t   size_t *salt_len, size_t *derived_key_len,\n\t\t\t\t   size_t *iteration_count)\n{\n\tsize_t n;\n\tenum { SALT = 0x1, LENGTH = 0x2, COUNT = 0x4 };\n\tuint8_t found = 0;\n\n\t*salt = NULL;\n\t*salt_len = *derived_key_len = *iteration_count = 0;\n\n\tfor (n = 0; n < param_count; n++) {\n\t\tswitch (params[n].attributeID) {\n\t\tcase TEE_ATTR_PBKDF2_SALT:\n\t\t\tif (!(found & SALT)) {\n\t\t\t\t*salt = params[n].content.ref.buffer;\n\t\t\t\t*salt_len = params[n].content.ref.length;\n\t\t\t\tfound |= SALT;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TEE_ATTR_PBKDF2_DKM_LENGTH:\n\t\t\tif (!(found & LENGTH)) {\n\t\t\t\t*derived_key_len = params[n].content.value.a;\n\t\t\t\tfound |= LENGTH;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TEE_ATTR_PBKDF2_ITERATION_COUNT:\n\t\t\tif (!(found & COUNT)) {\n\t\t\t\t*iteration_count = params[n].content.value.a;\n\t\t\t\tfound |= COUNT;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Unexpected attribute */\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\t}\n\n\tif ((found & (LENGTH|COUNT)) != (LENGTH|COUNT))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\treturn TEE_SUCCESS;\n}\n#endif\n\nTEE_Result syscall_cryp_derive_key(unsigned long state,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tunsigned long param_count, unsigned long derived_key)\n{\n\tTEE_Result res = TEE_ERROR_NOT_SUPPORTED;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *ko;\n\tstruct tee_obj *so;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_cryp_obj_secret *sk;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tTEE_Attribute *params = NULL;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tsize_t alloc_size = 0;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), param_count, &alloc_size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tparams = malloc(alloc_size);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(utc, usr_params, param_count, params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\t/* Get key set in operation */\n\tres = tee_obj_get(utc, cs->key1, &ko);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_obj_get(utc, tee_svc_uref_to_vaddr(derived_key), &so);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\t/* Find information needed about the object to initialize */\n\tsk = so->attr;\n\n\t/* Find description of object */\n\ttype_props = tee_svc_find_type_props(so->info.objectType);\n\tif (!type_props) {\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tgoto out;\n\t}\n\n\tif (cs->algo == TEE_ALG_DH_DERIVE_SHARED_SECRET) {\n\t\tstruct bignum *pub;\n\t\tstruct bignum *ss;\n\n\t\tif (param_count != 1 ||\n\t\t    params[0].attributeID != TEE_ATTR_DH_PUBLIC_VALUE) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsize_t bin_size = params[0].content.ref.length;\n\n\t\tif (MUL_OVERFLOW(bin_size, 8, &alloc_size)) {\n\t\t\tres = TEE_ERROR_OVERFLOW;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpub = crypto_bignum_allocate(alloc_size);\n\t\tss = crypto_bignum_allocate(alloc_size);\n\t\tif (pub && ss) {\n\t\t\tcrypto_bignum_bin2bn(params[0].content.ref.buffer,\n\t\t\t\t\t     bin_size, pub);\n\t\t\tres = crypto_acipher_dh_shared_secret(ko->attr,\n\t\t\t\t\t\t\t      pub, ss);\n\t\t\tif (res == TEE_SUCCESS) {\n\t\t\t\tsk->key_size = crypto_bignum_num_bytes(ss);\n\t\t\t\tcrypto_bignum_bn2bin(ss, (uint8_t *)(sk + 1));\n\t\t\t\tso->info.handleFlags |=\n\t\t\t\t\t\tTEE_HANDLE_FLAG_INITIALIZED;\n\t\t\t\tset_attribute(so, type_props,\n\t\t\t\t\t      TEE_ATTR_SECRET_VALUE);\n\t\t\t}\n\t\t} else {\n\t\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\t}\n\t\tcrypto_bignum_free(pub);\n\t\tcrypto_bignum_free(ss);\n\t} else if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_ECDH) {\n\t\tstruct ecc_public_key key_public;\n\t\tuint8_t *pt_secret;\n\t\tunsigned long pt_secret_len;\n\n\t\tif (param_count != 2 ||\n\t\t    params[0].attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_X ||\n\t\t    params[1].attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_Y) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (cs->algo) {\n\t\tcase TEE_ALG_ECDH_P192:\n\t\t\talloc_size = 192;\n\t\t\tbreak;\n\t\tcase TEE_ALG_ECDH_P224:\n\t\t\talloc_size = 224;\n\t\t\tbreak;\n\t\tcase TEE_ALG_ECDH_P256:\n\t\t\talloc_size = 256;\n\t\t\tbreak;\n\t\tcase TEE_ALG_ECDH_P384:\n\t\t\talloc_size = 384;\n\t\t\tbreak;\n\t\tcase TEE_ALG_ECDH_P521:\n\t\t\talloc_size = 521;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tres = TEE_ERROR_NOT_IMPLEMENTED;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Create the public key */\n\t\tres = crypto_acipher_alloc_ecc_public_key(&key_public,\n\t\t\t\t\t\t\t  alloc_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tkey_public.curve = ((struct ecc_keypair *)ko->attr)->curve;\n\t\tcrypto_bignum_bin2bn(params[0].content.ref.buffer,\n\t\t\t\t     params[0].content.ref.length,\n\t\t\t\t     key_public.x);\n\t\tcrypto_bignum_bin2bn(params[1].content.ref.buffer,\n\t\t\t\t     params[1].content.ref.length,\n\t\t\t\t     key_public.y);\n\n\t\tpt_secret = (uint8_t *)(sk + 1);\n\t\tpt_secret_len = sk->alloc_size;\n\t\tres = crypto_acipher_ecc_shared_secret(ko->attr, &key_public,\n\t\t\t\t\t\t       pt_secret,\n\t\t\t\t\t\t       &pt_secret_len);\n\n\t\tif (res == TEE_SUCCESS) {\n\t\t\tsk->key_size = pt_secret_len;\n\t\t\tso->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t\t\tset_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);\n\t\t}\n\n\t\t/* free the public key */\n\t\tcrypto_acipher_free_ecc_public_key(&key_public);\n\t}\n#if defined(CFG_CRYPTO_HKDF)\n\telse if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_HKDF) {\n\t\tvoid *salt, *info;\n\t\tsize_t salt_len, info_len, okm_len;\n\t\tuint32_t hash_id = TEE_ALG_GET_DIGEST_HASH(cs->algo);\n\t\tstruct tee_cryp_obj_secret *ik = ko->attr;\n\t\tconst uint8_t *ikm = (const uint8_t *)(ik + 1);\n\n\t\tres = get_hkdf_params(params, param_count, &salt, &salt_len,\n\t\t\t\t      &info, &info_len, &okm_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\t/* Requested size must fit into the output object's buffer */\n\t\tif (okm_len > ik->alloc_size) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = tee_cryp_hkdf(hash_id, ikm, ik->key_size, salt, salt_len,\n\t\t\t\t    info, info_len, (uint8_t *)(sk + 1),\n\t\t\t\t    okm_len);\n\t\tif (res == TEE_SUCCESS) {\n\t\t\tsk->key_size = okm_len;\n\t\t\tso->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t\t\tset_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);\n\t\t}\n\t}\n#endif\n#if defined(CFG_CRYPTO_CONCAT_KDF)\n\telse if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_CONCAT_KDF) {\n\t\tvoid *info;\n\t\tsize_t info_len, derived_key_len;\n\t\tuint32_t hash_id = TEE_ALG_GET_DIGEST_HASH(cs->algo);\n\t\tstruct tee_cryp_obj_secret *ss = ko->attr;\n\t\tconst uint8_t *shared_secret = (const uint8_t *)(ss + 1);\n\n\t\tres = get_concat_kdf_params(params, param_count, &info,\n\t\t\t\t\t    &info_len, &derived_key_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\t/* Requested size must fit into the output object's buffer */\n\t\tif (derived_key_len > ss->alloc_size) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = tee_cryp_concat_kdf(hash_id, shared_secret, ss->key_size,\n\t\t\t\t\t  info, info_len, (uint8_t *)(sk + 1),\n\t\t\t\t\t  derived_key_len);\n\t\tif (res == TEE_SUCCESS) {\n\t\t\tsk->key_size = derived_key_len;\n\t\t\tso->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t\t\tset_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);\n\t\t}\n\t}\n#endif\n#if defined(CFG_CRYPTO_PBKDF2)\n\telse if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_PBKDF2) {\n\t\tvoid *salt;\n\t\tsize_t salt_len, iteration_count, derived_key_len;\n\t\tuint32_t hash_id = TEE_ALG_GET_DIGEST_HASH(cs->algo);\n\t\tstruct tee_cryp_obj_secret *ss = ko->attr;\n\t\tconst uint8_t *password = (const uint8_t *)(ss + 1);\n\n\t\tres = get_pbkdf2_params(params, param_count, &salt, &salt_len,\n\t\t\t\t\t&derived_key_len, &iteration_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\t/* Requested size must fit into the output object's buffer */\n\t\tif (derived_key_len > ss->alloc_size) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = tee_cryp_pbkdf2(hash_id, password, ss->key_size, salt,\n\t\t\t\t      salt_len, iteration_count,\n\t\t\t\t      (uint8_t *)(sk + 1), derived_key_len);\n\t\tif (res == TEE_SUCCESS) {\n\t\t\tsk->key_size = derived_key_len;\n\t\t\tso->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t\t\tset_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);\n\t\t}\n\t}\n#endif\n\telse\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\nout:\n\tfree_wipe(params);\n\treturn res;\n}\n\nTEE_Result syscall_cryp_random_number_generate(void *buf, size_t blen)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)buf, blen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = crypto_rng_read(buf, blen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\treturn res;\n}\n\nTEE_Result syscall_authenc_init(unsigned long state, const void *nonce,\n\t\t\tsize_t nonce_len, size_t tag_len,\n\t\t\tsize_t aad_len, size_t payload_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)nonce, nonce_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx), cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tkey = o->attr;\n\tres = crypto_authenc_init(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t  (uint8_t *)(key + 1), key->key_size,\n\t\t\t\t  nonce, nonce_len, tag_len, aad_len,\n\t\t\t\t  payload_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tcs->ctx_finalize = (tee_cryp_ctx_finalize_func_t)crypto_authenc_final;\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result syscall_authenc_update_aad(unsigned long state,\n\t\t\tconst void *aad_data, size_t aad_data_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t) aad_data,\n\t\t\t\t\t  aad_data_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = crypto_authenc_update_aad(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\taad_data, aad_data_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result syscall_authenc_update_payload(unsigned long state,\n\t\t\tconst void *src_data, size_t src_len, void *dst_data,\n\t\t\tuint64_t *dst_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tsize_t dlen = 0;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t) src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)dst_data, dlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tres = crypto_authenc_update_payload(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t    src_data, src_len, dst_data,\n\t\t\t\t\t    &dlen);\nout:\n\tif (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {\n\t\tTEE_Result res2 = put_user_u64(dst_len, dlen);\n\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\tres = res2;\n\t}\n\n\treturn res;\n}\n\nTEE_Result syscall_authenc_enc_final(unsigned long state,\n\t\t\tconst void *src_data, size_t src_len, void *dst_data,\n\t\t\tuint64_t *dst_len, void *tag, uint64_t *tag_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tsize_t dlen = 0;\n\tsize_t tlen = 0;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->mode != TEE_MODE_ENCRYPT)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (!dst_len) {\n\t\tdlen = 0;\n\t} else {\n\t\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t\t  (uaddr_t)dst_data, dlen);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tres = get_user_u64_as_size_t(&tlen, tag_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)tag, tlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = crypto_authenc_enc_final(cs->ctx, cs->algo, src_data,\n\t\t\t\t       src_len, dst_data, &dlen, tag, &tlen);\n\nout:\n\tif (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {\n\t\tTEE_Result res2;\n\n\t\tif (dst_len != NULL) {\n\t\t\tres2 = put_user_u64(dst_len, dlen);\n\t\t\tif (res2 != TEE_SUCCESS)\n\t\t\t\treturn res2;\n\t\t}\n\n\t\tres2 = put_user_u64(tag_len, tlen);\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\treturn res2;\n\t}\n\n\treturn res;\n}\n\nTEE_Result syscall_authenc_dec_final(unsigned long state,\n\t\t\tconst void *src_data, size_t src_len, void *dst_data,\n\t\t\tuint64_t *dst_len, const void *tag, size_t tag_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tsize_t dlen = 0;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->mode != TEE_MODE_DECRYPT)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (!dst_len) {\n\t\tdlen = 0;\n\t} else {\n\t\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t\t  (uaddr_t)dst_data, dlen);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)tag, tag_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = crypto_authenc_dec_final(cs->ctx, cs->algo, src_data, src_len,\n\t\t\t\t       dst_data, &dlen, tag, tag_len);\n\nout:\n\tif ((res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) &&\n\t    dst_len != NULL) {\n\t\tTEE_Result res2 = put_user_u64(dst_len, dlen);\n\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\treturn res2;\n\t}\n\n\treturn res;\n}\n\nstatic int pkcs1_get_salt_len(const TEE_Attribute *params, uint32_t num_params,\n\t\t\t      size_t default_len)\n{\n\tsize_t n;\n\n\tassert(default_len < INT_MAX);\n\n\tfor (n = 0; n < num_params; n++) {\n\t\tif (params[n].attributeID == TEE_ATTR_RSA_PSS_SALT_LENGTH) {\n\t\t\tif (params[n].content.value.a < INT_MAX)\n\t\t\t\treturn params[n].content.value.a;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * If salt length isn't provided use the default value which is\n\t * the length of the digest.\n\t */\n\treturn default_len;\n}\n\nTEE_Result syscall_asymm_operate(unsigned long state,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tsize_t num_params, const void *src_data, size_t src_len,\n\t\t\tvoid *dst_data, uint64_t *dst_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tsize_t dlen;\n\tstruct tee_obj *o;\n\tvoid *label = NULL;\n\tsize_t label_len = 0;\n\tsize_t n;\n\tint salt_len;\n\tTEE_Attribute *params = NULL;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(\n\t\tutc,\n\t\tTEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t(uaddr_t) src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(\n\t\tutc,\n\t\tTEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_WRITE |\n\t\t\tTEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t(uaddr_t) dst_data, dlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tsize_t alloc_size = 0;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), num_params, &alloc_size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tparams = malloc(alloc_size);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(utc, usr_params, num_params, params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_obj_get(utc, cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0) {\n\t\tres = TEE_ERROR_GENERIC;\n\t\tgoto out;\n\t}\n\n\tswitch (cs->algo) {\n\tcase TEE_ALG_RSA_NOPAD:\n\t\tif (cs->mode == TEE_MODE_ENCRYPT) {\n\t\t\tres = crypto_acipher_rsanopad_encrypt(o->attr, src_data,\n\t\t\t\t\t\t\t      src_len, dst_data,\n\t\t\t\t\t\t\t      &dlen);\n\t\t} else if (cs->mode == TEE_MODE_DECRYPT) {\n\t\t\tres = crypto_acipher_rsanopad_decrypt(o->attr, src_data,\n\t\t\t\t\t\t\t      src_len, dst_data,\n\t\t\t\t\t\t\t      &dlen);\n\t\t} else {\n\t\t\t/*\n\t\t\t * We will panic because \"the mode is not compatible\n\t\t\t * with the function\"\n\t\t\t */\n\t\t\tres = TEE_ERROR_GENERIC;\n\t\t}\n\t\tbreak;\n\n\tcase TEE_ALG_RSAES_PKCS1_V1_5:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512:\n\t\tfor (n = 0; n < num_params; n++) {\n\t\t\tif (params[n].attributeID == TEE_ATTR_RSA_OAEP_LABEL) {\n\t\t\t\tlabel = params[n].content.ref.buffer;\n\t\t\t\tlabel_len = params[n].content.ref.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (cs->mode == TEE_MODE_ENCRYPT) {\n\t\t\tres = crypto_acipher_rsaes_encrypt(cs->algo, o->attr,\n\t\t\t\t\t\t\t   label, label_len,\n\t\t\t\t\t\t\t   src_data, src_len,\n\t\t\t\t\t\t\t   dst_data, &dlen);\n\t\t} else if (cs->mode == TEE_MODE_DECRYPT) {\n\t\t\tres = crypto_acipher_rsaes_decrypt(\n\t\t\t\t\tcs->algo, o->attr, label, label_len,\n\t\t\t\t\tsrc_data, src_len, dst_data, &dlen);\n\t\t} else {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\t\tbreak;\n\n#if defined(CFG_CRYPTO_RSASSA_NA1)\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5:\n#endif\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_MD5:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA512:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512:\n\t\tif (cs->mode != TEE_MODE_SIGN) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tbreak;\n\t\t}\n\t\tsalt_len = pkcs1_get_salt_len(params, num_params, src_len);\n\t\tres = crypto_acipher_rsassa_sign(cs->algo, o->attr, salt_len,\n\t\t\t\t\t\t src_data, src_len, dst_data,\n\t\t\t\t\t\t &dlen);\n\t\tbreak;\n\n\tcase TEE_ALG_DSA_SHA1:\n\tcase TEE_ALG_DSA_SHA224:\n\tcase TEE_ALG_DSA_SHA256:\n\t\tres = crypto_acipher_dsa_sign(cs->algo, o->attr, src_data,\n\t\t\t\t\t      src_len, dst_data, &dlen);\n\t\tbreak;\n\tcase TEE_ALG_ECDSA_P192:\n\tcase TEE_ALG_ECDSA_P224:\n\tcase TEE_ALG_ECDSA_P256:\n\tcase TEE_ALG_ECDSA_P384:\n\tcase TEE_ALG_ECDSA_P521:\n\t\tres = crypto_acipher_ecc_sign(cs->algo, o->attr, src_data,\n\t\t\t\t\t      src_len, dst_data, &dlen);\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\t}\n\nout:\n\tfree_wipe(params);\n\n\tif (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {\n\t\tTEE_Result res2 = put_user_u64(dst_len, dlen);\n\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\treturn res2;\n\t}\n\n\treturn res;\n}\n\nTEE_Result syscall_asymm_verify(unsigned long state,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tsize_t num_params, const void *data, size_t data_len,\n\t\t\tconst void *sig, size_t sig_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tsize_t hash_size;\n\tint salt_len = 0;\n\tTEE_Attribute *params = NULL;\n\tuint32_t hash_algo;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->mode != TEE_MODE_VERIFY)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tres = tee_mmu_check_access_rights(utc,\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)data, data_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(utc,\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)sig, sig_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tsize_t alloc_size = 0;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), num_params, &alloc_size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tparams = malloc(alloc_size);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(utc, usr_params, num_params, params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_obj_get(utc, cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\tswitch (TEE_ALG_GET_MAIN_ALG(cs->algo)) {\n\tcase TEE_MAIN_ALGO_RSA:\n\t\tif (cs->algo != TEE_ALG_RSASSA_PKCS1_V1_5) {\n\t\t\thash_algo = TEE_DIGEST_HASH_TO_ALGO(cs->algo);\n\t\t\tres = tee_hash_get_digest_size(hash_algo, &hash_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t\tif (data_len != hash_size) {\n\t\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsalt_len = pkcs1_get_salt_len(params, num_params,\n\t\t\t\t\t\t      hash_size);\n\t\t}\n\t\tres = crypto_acipher_rsassa_verify(cs->algo, o->attr, salt_len,\n\t\t\t\t\t\t   data, data_len, sig,\n\t\t\t\t\t\t   sig_len);\n\t\tbreak;\n\n\tcase TEE_MAIN_ALGO_DSA:\n\t\thash_algo = TEE_DIGEST_HASH_TO_ALGO(cs->algo);\n\t\tres = tee_hash_get_digest_size(hash_algo, &hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tbreak;\n\t\t/*\n\t\t * Depending on the DSA algorithm (NIST), the digital signature\n\t\t * output size may be truncated to the size of a key pair\n\t\t * (Q prime size). Q prime size must be less or equal than the\n\t\t * hash output length of the hash algorithm involved.\n\t\t */\n\t\tif (data_len > hash_size) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tbreak;\n\t\t}\n\t\tres = crypto_acipher_dsa_verify(cs->algo, o->attr, data,\n\t\t\t\t\t\tdata_len, sig, sig_len);\n\t\tbreak;\n\n\tcase TEE_MAIN_ALGO_ECDSA:\n\t\tres = crypto_acipher_ecc_verify(cs->algo, o->attr, data,\n\t\t\t\t\t\tdata_len, sig, sig_len);\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t}\n\nout:\n\tfree_wipe(params);\n\treturn res;\n}\n"], "fixing_code": ["// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (c) 2014, STMicroelectronics International N.V.\n */\n\n#include <assert.h>\n#include <compiler.h>\n#include <crypto/crypto.h>\n#include <kernel/tee_ta_manager.h>\n#include <mm/tee_mmu.h>\n#include <stdlib_ext.h>\n#include <string_ext.h>\n#include <string.h>\n#include <sys/queue.h>\n#include <tee_api_types.h>\n#include <tee/tee_cryp_utl.h>\n#include <tee/tee_obj.h>\n#include <tee/tee_svc_cryp.h>\n#include <tee/tee_svc.h>\n#include <trace.h>\n#include <utee_defines.h>\n#include <util.h>\n#include <tee_api_defines_extensions.h>\n#if defined(CFG_CRYPTO_HKDF)\n#include <tee/tee_cryp_hkdf.h>\n#endif\n#if defined(CFG_CRYPTO_CONCAT_KDF)\n#include <tee/tee_cryp_concat_kdf.h>\n#endif\n#if defined(CFG_CRYPTO_PBKDF2)\n#include <tee/tee_cryp_pbkdf2.h>\n#endif\n\nenum cryp_state {\n\tCRYP_STATE_INITIALIZED = 0,\n\tCRYP_STATE_UNINITIALIZED\n};\n\ntypedef void (*tee_cryp_ctx_finalize_func_t) (void *ctx, uint32_t algo);\nstruct tee_cryp_state {\n\tTAILQ_ENTRY(tee_cryp_state) link;\n\tuint32_t algo;\n\tuint32_t mode;\n\tvaddr_t key1;\n\tvaddr_t key2;\n\tvoid *ctx;\n\ttee_cryp_ctx_finalize_func_t ctx_finalize;\n\tenum cryp_state state;\n};\n\nstruct tee_cryp_obj_secret {\n\tuint32_t key_size;\n\tuint32_t alloc_size;\n\n\t/*\n\t * Pseudo code visualize layout of structure\n\t * Next follows data, such as:\n\t *\tuint8_t data[alloc_size]\n\t * key_size must never exceed alloc_size\n\t */\n};\n\n#define TEE_TYPE_ATTR_OPTIONAL       0x0\n#define TEE_TYPE_ATTR_REQUIRED       0x1\n#define TEE_TYPE_ATTR_OPTIONAL_GROUP 0x2\n#define TEE_TYPE_ATTR_SIZE_INDICATOR 0x4\n#define TEE_TYPE_ATTR_GEN_KEY_OPT    0x8\n#define TEE_TYPE_ATTR_GEN_KEY_REQ    0x10\n\n    /* Handle storing of generic secret keys of varying lengths */\n#define ATTR_OPS_INDEX_SECRET     0\n    /* Convert to/from big-endian byte array and provider-specific bignum */\n#define ATTR_OPS_INDEX_BIGNUM     1\n    /* Convert to/from value attribute depending on direction */\n#define ATTR_OPS_INDEX_VALUE      2\n\nstruct tee_cryp_obj_type_attrs {\n\tuint32_t attr_id;\n\tuint16_t flags;\n\tuint16_t ops_index;\n\tuint16_t raw_offs;\n\tuint16_t raw_size;\n};\n\n#define RAW_DATA(_x, _y)\t\\\n\t.raw_offs = offsetof(_x, _y), .raw_size = MEMBER_SIZE(_x, _y)\n\nstatic const struct tee_cryp_obj_type_attrs\n\ttee_cryp_obj_secret_value_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_SECRET_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_SECRET,\n\t.raw_offs = 0,\n\t.raw_size = 0\n\t},\n};\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_rsa_pub_key_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_RSA_MODULUS,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_public_key, n)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_PUBLIC_EXPONENT,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_public_key, e)\n\t},\n};\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_rsa_keypair_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_RSA_MODULUS,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, n)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_PUBLIC_EXPONENT,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, e)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_PRIVATE_EXPONENT,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, d)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_PRIME1,\n\t.flags = TEE_TYPE_ATTR_OPTIONAL_GROUP,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, p)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_PRIME2,\n\t.flags = TEE_TYPE_ATTR_OPTIONAL_GROUP,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, q)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_EXPONENT1,\n\t.flags = TEE_TYPE_ATTR_OPTIONAL_GROUP,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, dp)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_EXPONENT2,\n\t.flags = TEE_TYPE_ATTR_OPTIONAL_GROUP,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, dq)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_COEFFICIENT,\n\t.flags = TEE_TYPE_ATTR_OPTIONAL_GROUP,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, qp)\n\t},\n};\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_dsa_pub_key_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_DSA_PRIME,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_public_key, p)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DSA_SUBPRIME,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_public_key, q)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DSA_BASE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_public_key, g)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DSA_PUBLIC_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_public_key, y)\n\t},\n};\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_dsa_keypair_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_DSA_PRIME,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_GEN_KEY_REQ,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_keypair, p)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DSA_SUBPRIME,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR |\n\t\t TEE_TYPE_ATTR_GEN_KEY_REQ,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_keypair, q)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DSA_BASE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_GEN_KEY_REQ,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_keypair, g)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DSA_PRIVATE_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_keypair, x)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DSA_PUBLIC_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_keypair, y)\n\t},\n};\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_dh_keypair_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_DH_PRIME,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR |\n\t\t TEE_TYPE_ATTR_GEN_KEY_REQ,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dh_keypair, p)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DH_BASE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_GEN_KEY_REQ,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dh_keypair, g)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DH_PUBLIC_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dh_keypair, y)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DH_PRIVATE_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dh_keypair, x)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DH_SUBPRIME,\n\t.flags = TEE_TYPE_ATTR_OPTIONAL_GROUP |\t TEE_TYPE_ATTR_GEN_KEY_OPT,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dh_keypair, q)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DH_X_BITS,\n\t.flags = TEE_TYPE_ATTR_GEN_KEY_OPT,\n\t.ops_index = ATTR_OPS_INDEX_VALUE,\n\tRAW_DATA(struct dh_keypair, xbits)\n\t},\n};\n\n#if defined(CFG_CRYPTO_HKDF)\nstatic const struct tee_cryp_obj_type_attrs\n\ttee_cryp_obj_hkdf_ikm_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_HKDF_IKM,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_SECRET,\n\t.raw_offs = 0,\n\t.raw_size = 0\n\t},\n};\n#endif\n\n#if defined(CFG_CRYPTO_CONCAT_KDF)\nstatic const struct tee_cryp_obj_type_attrs\n\ttee_cryp_obj_concat_kdf_z_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_CONCAT_KDF_Z,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_SECRET,\n\t.raw_offs = 0,\n\t.raw_size = 0\n\t},\n};\n#endif\n\n#if defined(CFG_CRYPTO_PBKDF2)\nstatic const struct tee_cryp_obj_type_attrs\n\ttee_cryp_obj_pbkdf2_passwd_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_PBKDF2_PASSWORD,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_SECRET,\n\t.raw_offs = 0,\n\t.raw_size = 0\n\t},\n};\n#endif\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_ecc_pub_key_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_ECC_PUBLIC_VALUE_X,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct ecc_public_key, x)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_ECC_PUBLIC_VALUE_Y,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct ecc_public_key, y)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_ECC_CURVE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_VALUE,\n\tRAW_DATA(struct ecc_public_key, curve)\n\t},\n};\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_ecc_keypair_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_ECC_PRIVATE_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct ecc_keypair, d)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_ECC_PUBLIC_VALUE_X,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct ecc_keypair, x)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_ECC_PUBLIC_VALUE_Y,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct ecc_keypair, y)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_ECC_CURVE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_VALUE,\n\tRAW_DATA(struct ecc_keypair, curve)\n\t},\n};\n\nstruct tee_cryp_obj_type_props {\n\tTEE_ObjectType obj_type;\n\tuint16_t min_size;\t/* may not be smaller than this */\n\tuint16_t max_size;\t/* may not be larger than this */\n\tuint16_t alloc_size;\t/* this many bytes are allocated to hold data */\n\tuint8_t quanta;\t\t/* may only be an multiple of this */\n\n\tuint8_t num_type_attrs;\n\tconst struct tee_cryp_obj_type_attrs *type_attrs;\n};\n\n#define PROP(obj_type, quanta, min_size, max_size, alloc_size, type_attrs) \\\n\t\t{ (obj_type), (min_size), (max_size), (alloc_size), (quanta), \\\n\t\t  ARRAY_SIZE(type_attrs), (type_attrs) }\n\nstatic const struct tee_cryp_obj_type_props tee_cryp_obj_props[] = {\n\tPROP(TEE_TYPE_AES, 64, 128, 256,\t/* valid sizes 128, 192, 256 */\n\t\t256 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_DES, 56, 56, 56,\n\t\t/*\n\t\t* Valid size 56 without parity, note that we still allocate\n\t\t* for 64 bits since the key is supplied with parity.\n\t\t*/\n\t\t64 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_DES3, 56, 112, 168,\n\t\t/*\n\t\t* Valid sizes 112, 168 without parity, note that we still\n\t\t* allocate for with space for the parity since the key is\n\t\t* supplied with parity.\n\t\t*/\n\t\t192 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_MD5, 8, 64, 512,\n\t\t512 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_SHA1, 8, 80, 512,\n\t\t512 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_SHA224, 8, 112, 512,\n\t\t512 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_SHA256, 8, 192, 1024,\n\t\t1024 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_SHA384, 8, 256, 1024,\n\t\t1024 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_SHA512, 8, 256, 1024,\n\t\t1024 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_GENERIC_SECRET, 8, 0, 4096,\n\t\t4096 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n#if defined(CFG_CRYPTO_HKDF)\n\tPROP(TEE_TYPE_HKDF_IKM, 8, 0, 4096,\n\t\t4096 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_hkdf_ikm_attrs),\n#endif\n#if defined(CFG_CRYPTO_CONCAT_KDF)\n\tPROP(TEE_TYPE_CONCAT_KDF_Z, 8, 0, 4096,\n\t\t4096 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_concat_kdf_z_attrs),\n#endif\n#if defined(CFG_CRYPTO_PBKDF2)\n\tPROP(TEE_TYPE_PBKDF2_PASSWORD, 8, 0, 4096,\n\t\t4096 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_pbkdf2_passwd_attrs),\n#endif\n\tPROP(TEE_TYPE_RSA_PUBLIC_KEY, 1, 256, CFG_CORE_BIGNUM_MAX_BITS,\n\t\tsizeof(struct rsa_public_key),\n\t\ttee_cryp_obj_rsa_pub_key_attrs),\n\n\tPROP(TEE_TYPE_RSA_KEYPAIR, 1, 256, CFG_CORE_BIGNUM_MAX_BITS,\n\t\tsizeof(struct rsa_keypair),\n\t\ttee_cryp_obj_rsa_keypair_attrs),\n\n\tPROP(TEE_TYPE_DSA_PUBLIC_KEY, 64, 512, 3072,\n\t\tsizeof(struct dsa_public_key),\n\t\ttee_cryp_obj_dsa_pub_key_attrs),\n\n\tPROP(TEE_TYPE_DSA_KEYPAIR, 64, 512, 3072,\n\t\tsizeof(struct dsa_keypair),\n\t\ttee_cryp_obj_dsa_keypair_attrs),\n\n\tPROP(TEE_TYPE_DH_KEYPAIR, 1, 256, 2048,\n\t\tsizeof(struct dh_keypair),\n\t\ttee_cryp_obj_dh_keypair_attrs),\n\n\tPROP(TEE_TYPE_ECDSA_PUBLIC_KEY, 1, 192, 521,\n\t\tsizeof(struct ecc_public_key),\n\t\ttee_cryp_obj_ecc_pub_key_attrs),\n\n\tPROP(TEE_TYPE_ECDSA_KEYPAIR, 1, 192, 521,\n\t\tsizeof(struct ecc_keypair),\n\t\ttee_cryp_obj_ecc_keypair_attrs),\n\n\tPROP(TEE_TYPE_ECDH_PUBLIC_KEY, 1, 192, 521,\n\t\tsizeof(struct ecc_public_key),\n\t\ttee_cryp_obj_ecc_pub_key_attrs),\n\n\tPROP(TEE_TYPE_ECDH_KEYPAIR, 1, 192, 521,\n\t\tsizeof(struct ecc_keypair),\n\t\ttee_cryp_obj_ecc_keypair_attrs),\n};\n\nstruct attr_ops {\n\tTEE_Result (*from_user)(void *attr, const void *buffer, size_t size);\n\tTEE_Result (*to_user)(void *attr, struct tee_ta_session *sess,\n\t\t\t      void *buffer, uint64_t *size);\n\tTEE_Result (*to_binary)(void *attr, void *data, size_t data_len,\n\t\t\t    size_t *offs);\n\tbool (*from_binary)(void *attr, const void *data, size_t data_len,\n\t\t\t    size_t *offs);\n\tTEE_Result (*from_obj)(void *attr, void *src_attr);\n\tvoid (*free)(void *attr);\n\tvoid (*clear)(void *attr);\n};\n\nstatic TEE_Result op_u32_to_binary_helper(uint32_t v, uint8_t *data,\n\t\t\t\t    size_t data_len, size_t *offs)\n{\n\tuint32_t field;\n\tsize_t next_offs;\n\n\tif (ADD_OVERFLOW(*offs, sizeof(field), &next_offs))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tif (data && next_offs <= data_len) {\n\t\tfield = TEE_U32_TO_BIG_ENDIAN(v);\n\t\tmemcpy(data + *offs, &field, sizeof(field));\n\t}\n\t(*offs) = next_offs;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic bool op_u32_from_binary_helper(uint32_t *v, const uint8_t *data,\n\t\t\t\t      size_t data_len, size_t *offs)\n{\n\tuint32_t field;\n\n\tif (!data || (*offs + sizeof(field)) > data_len)\n\t\treturn false;\n\n\tmemcpy(&field, data + *offs, sizeof(field));\n\t*v = TEE_U32_FROM_BIG_ENDIAN(field);\n\t(*offs) += sizeof(field);\n\treturn true;\n}\n\nstatic TEE_Result op_attr_secret_value_from_user(void *attr, const void *buffer,\n\t\t\t\t\t\t size_t size)\n{\n\tstruct tee_cryp_obj_secret *key = attr;\n\n\t/* Data size has to fit in allocated buffer */\n\tif (size > key->alloc_size)\n\t\treturn TEE_ERROR_SECURITY;\n\tmemcpy(key + 1, buffer, size);\n\tkey->key_size = size;\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result op_attr_secret_value_to_user(void *attr,\n\t\t\tstruct tee_ta_session *sess __unused,\n\t\t\tvoid *buffer, uint64_t *size)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_obj_secret *key = attr;\n\tuint64_t s;\n\tuint64_t key_size;\n\n\tres = tee_svc_copy_from_user(&s, size, sizeof(s));\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tkey_size = key->key_size;\n\tres = tee_svc_copy_to_user(size, &key_size, sizeof(key_size));\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (s < key->key_size || !buffer)\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\n\treturn tee_svc_copy_to_user(buffer, key + 1, key->key_size);\n}\n\nstatic TEE_Result op_attr_secret_value_to_binary(void *attr, void *data,\n\t\t\t\t\t   size_t data_len, size_t *offs)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_obj_secret *key = attr;\n\tsize_t next_offs;\n\n\tres = op_u32_to_binary_helper(key->key_size, data, data_len, offs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (ADD_OVERFLOW(*offs, key->key_size, &next_offs))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tif (data && next_offs <= data_len)\n\t\tmemcpy((uint8_t *)data + *offs, key + 1, key->key_size);\n\t(*offs) = next_offs;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic bool op_attr_secret_value_from_binary(void *attr, const void *data,\n\t\t\t\t\t     size_t data_len, size_t *offs)\n{\n\tstruct tee_cryp_obj_secret *key = attr;\n\tuint32_t s;\n\n\tif (!op_u32_from_binary_helper(&s, data, data_len, offs))\n\t\treturn false;\n\n\tif ((*offs + s) > data_len)\n\t\treturn false;\n\n\t/* Data size has to fit in allocated buffer */\n\tif (s > key->alloc_size)\n\t\treturn false;\n\tkey->key_size = s;\n\tmemcpy(key + 1, (const uint8_t *)data + *offs, s);\n\t(*offs) += s;\n\treturn true;\n}\n\n\nstatic TEE_Result op_attr_secret_value_from_obj(void *attr, void *src_attr)\n{\n\tstruct tee_cryp_obj_secret *key = attr;\n\tstruct tee_cryp_obj_secret *src_key = src_attr;\n\n\tif (src_key->key_size > key->alloc_size)\n\t\treturn TEE_ERROR_BAD_STATE;\n\tmemcpy(key + 1, src_key + 1, src_key->key_size);\n\tkey->key_size = src_key->key_size;\n\treturn TEE_SUCCESS;\n}\n\nstatic void op_attr_secret_value_clear(void *attr)\n{\n\tstruct tee_cryp_obj_secret *key = attr;\n\n\tkey->key_size = 0;\n\tmemset(key + 1, 0, key->alloc_size);\n}\n\nstatic TEE_Result op_attr_bignum_from_user(void *attr, const void *buffer,\n\t\t\t\t\t   size_t size)\n{\n\tstruct bignum **bn = attr;\n\n\treturn crypto_bignum_bin2bn(buffer, size, *bn);\n}\n\nstatic TEE_Result op_attr_bignum_to_user(void *attr,\n\t\t\t\t\t struct tee_ta_session *sess,\n\t\t\t\t\t void *buffer, uint64_t *size)\n{\n\tTEE_Result res;\n\tstruct bignum **bn = attr;\n\tuint64_t req_size;\n\tuint64_t s;\n\n\tres = tee_svc_copy_from_user(&s, size, sizeof(s));\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\treq_size = crypto_bignum_num_bytes(*bn);\n\tres = tee_svc_copy_to_user(size, &req_size, sizeof(req_size));\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (!req_size)\n\t\treturn TEE_SUCCESS;\n\tif (s < req_size || !buffer)\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\n\t/* Check we can access data using supplied user mode pointer */\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)buffer, req_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\t/*\n\t* Write the bignum (wich raw data points to) into an array of\n\t* bytes (stored in buffer)\n\t*/\n\tcrypto_bignum_bn2bin(*bn, buffer);\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result op_attr_bignum_to_binary(void *attr, void *data,\n\t\t\t\t\t   size_t data_len, size_t *offs)\n{\n\tTEE_Result res;\n\tstruct bignum **bn = attr;\n\tuint32_t n = crypto_bignum_num_bytes(*bn);\n\tsize_t next_offs;\n\n\tres = op_u32_to_binary_helper(n, data, data_len, offs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (ADD_OVERFLOW(*offs, n, &next_offs))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tif (data && next_offs <= data_len)\n\t\tcrypto_bignum_bn2bin(*bn, (uint8_t *)data + *offs);\n\t(*offs) = next_offs;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic bool op_attr_bignum_from_binary(void *attr, const void *data,\n\t\t\t\t       size_t data_len, size_t *offs)\n{\n\tstruct bignum **bn = attr;\n\tuint32_t n;\n\n\tif (!op_u32_from_binary_helper(&n, data, data_len, offs))\n\t\treturn false;\n\n\tif ((*offs + n) > data_len)\n\t\treturn false;\n\tif (crypto_bignum_bin2bn((const uint8_t *)data + *offs, n, *bn))\n\t\treturn false;\n\t(*offs) += n;\n\treturn true;\n}\n\nstatic TEE_Result op_attr_bignum_from_obj(void *attr, void *src_attr)\n{\n\tstruct bignum **bn = attr;\n\tstruct bignum **src_bn = src_attr;\n\n\tcrypto_bignum_copy(*bn, *src_bn);\n\treturn TEE_SUCCESS;\n}\n\nstatic void op_attr_bignum_clear(void *attr)\n{\n\tstruct bignum **bn = attr;\n\n\tcrypto_bignum_clear(*bn);\n}\n\nstatic void op_attr_bignum_free(void *attr)\n{\n\tstruct bignum **bn = attr;\n\n\tcrypto_bignum_free(*bn);\n\t*bn = NULL;\n}\n\nstatic TEE_Result op_attr_value_from_user(void *attr, const void *buffer,\n\t\t\t\t\t  size_t size)\n{\n\tuint32_t *v = attr;\n\n\tif (size != sizeof(uint32_t) * 2)\n\t\treturn TEE_ERROR_GENERIC; /* \"can't happen */\n\n\t/* Note that only the first value is copied */\n\tmemcpy(v, buffer, sizeof(uint32_t));\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result op_attr_value_to_user(void *attr,\n\t\t\t\t\tstruct tee_ta_session *sess __unused,\n\t\t\t\t\tvoid *buffer, uint64_t *size)\n{\n\tTEE_Result res;\n\tuint32_t *v = attr;\n\tuint64_t s;\n\tuint32_t value[2] = { *v };\n\tuint64_t req_size = sizeof(value);\n\n\tres = tee_svc_copy_from_user(&s, size, sizeof(s));\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (s < req_size || !buffer)\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\n\treturn tee_svc_copy_to_user(buffer, value, req_size);\n}\n\nstatic TEE_Result op_attr_value_to_binary(void *attr, void *data,\n\t\t\t\t\t  size_t data_len, size_t *offs)\n{\n\tuint32_t *v = attr;\n\n\treturn op_u32_to_binary_helper(*v, data, data_len, offs);\n}\n\nstatic bool op_attr_value_from_binary(void *attr, const void *data,\n\t\t\t\t      size_t data_len, size_t *offs)\n{\n\tuint32_t *v = attr;\n\n\treturn op_u32_from_binary_helper(v, data, data_len, offs);\n}\n\nstatic TEE_Result op_attr_value_from_obj(void *attr, void *src_attr)\n{\n\tuint32_t *v = attr;\n\tuint32_t *src_v = src_attr;\n\n\t*v = *src_v;\n\treturn TEE_SUCCESS;\n}\n\nstatic void op_attr_value_clear(void *attr)\n{\n\tuint32_t *v = attr;\n\n\t*v = 0;\n}\n\nstatic const struct attr_ops attr_ops[] = {\n\t[ATTR_OPS_INDEX_SECRET] = {\n\t\t.from_user = op_attr_secret_value_from_user,\n\t\t.to_user = op_attr_secret_value_to_user,\n\t\t.to_binary = op_attr_secret_value_to_binary,\n\t\t.from_binary = op_attr_secret_value_from_binary,\n\t\t.from_obj = op_attr_secret_value_from_obj,\n\t\t.free = op_attr_secret_value_clear, /* not a typo */\n\t\t.clear = op_attr_secret_value_clear,\n\t},\n\t[ATTR_OPS_INDEX_BIGNUM] = {\n\t\t.from_user = op_attr_bignum_from_user,\n\t\t.to_user = op_attr_bignum_to_user,\n\t\t.to_binary = op_attr_bignum_to_binary,\n\t\t.from_binary = op_attr_bignum_from_binary,\n\t\t.from_obj = op_attr_bignum_from_obj,\n\t\t.free = op_attr_bignum_free,\n\t\t.clear = op_attr_bignum_clear,\n\t},\n\t[ATTR_OPS_INDEX_VALUE] = {\n\t\t.from_user = op_attr_value_from_user,\n\t\t.to_user = op_attr_value_to_user,\n\t\t.to_binary = op_attr_value_to_binary,\n\t\t.from_binary = op_attr_value_from_binary,\n\t\t.from_obj = op_attr_value_from_obj,\n\t\t.free = op_attr_value_clear, /* not a typo */\n\t\t.clear = op_attr_value_clear,\n\t},\n};\n\nstatic TEE_Result get_user_u64_as_size_t(size_t *dst, uint64_t *src)\n{\n\tuint64_t d = 0;\n\tTEE_Result res = tee_svc_copy_from_user(&d, src, sizeof(d));\n\n\t/*\n\t * On 32-bit systems a size_t can't hold a uint64_t so we need to\n\t * check that the value isn't too large.\n\t */\n\tif (!res && ADD_OVERFLOW(0, d, dst))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\treturn res;\n}\n\nstatic TEE_Result put_user_u64(uint64_t *dst, size_t value)\n{\n\tuint64_t v = value;\n\n\treturn tee_svc_copy_to_user(dst, &v, sizeof(v));\n}\n\nTEE_Result syscall_cryp_obj_get_info(unsigned long obj, TEE_ObjectInfo *info)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\tgoto exit;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\tgoto exit;\n\n\tres = tee_svc_copy_to_user(info, &o->info, sizeof(o->info));\n\nexit:\n\treturn res;\n}\n\nTEE_Result syscall_cryp_obj_restrict_usage(unsigned long obj,\n\t\t\tunsigned long usage)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\tgoto exit;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\tgoto exit;\n\n\to->info.objectUsage &= usage;\n\nexit:\n\treturn res;\n}\n\nstatic int tee_svc_cryp_obj_find_type_attr_idx(\n\t\tuint32_t attr_id,\n\t\tconst struct tee_cryp_obj_type_props *type_props)\n{\n\tsize_t n;\n\n\tfor (n = 0; n < type_props->num_type_attrs; n++) {\n\t\tif (attr_id == type_props->type_attrs[n].attr_id)\n\t\t\treturn n;\n\t}\n\treturn -1;\n}\n\nstatic const struct tee_cryp_obj_type_props *tee_svc_find_type_props(\n\t\tTEE_ObjectType obj_type)\n{\n\tsize_t n;\n\n\tfor (n = 0; n < ARRAY_SIZE(tee_cryp_obj_props); n++) {\n\t\tif (tee_cryp_obj_props[n].obj_type == obj_type)\n\t\t\treturn tee_cryp_obj_props + n;\n\t}\n\n\treturn NULL;\n}\n\n/* Set an attribute on an object */\nstatic void set_attribute(struct tee_obj *o,\n\t\t\t  const struct tee_cryp_obj_type_props *props,\n\t\t\t  uint32_t attr)\n{\n\tint idx = tee_svc_cryp_obj_find_type_attr_idx(attr, props);\n\n\tif (idx < 0)\n\t\treturn;\n\to->have_attrs |= BIT(idx);\n}\n\n/* Get an attribute on an object */\nstatic uint32_t get_attribute(const struct tee_obj *o,\n\t\t\t      const struct tee_cryp_obj_type_props *props,\n\t\t\t      uint32_t attr)\n{\n\tint idx = tee_svc_cryp_obj_find_type_attr_idx(attr, props);\n\n\tif (idx < 0)\n\t\treturn 0;\n\treturn o->have_attrs & BIT(idx);\n}\n\nTEE_Result syscall_cryp_obj_get_attr(unsigned long obj, unsigned long attr_id,\n\t\t\tvoid *buffer, uint64_t *size)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tint idx;\n\tconst struct attr_ops *ops;\n\tvoid *attr;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\t/* Check that the object is initialized */\n\tif (!(o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/* Check that getting the attribute is allowed */\n\tif (!(attr_id & TEE_ATTR_BIT_PROTECTED) &&\n\t    !(o->info.objectUsage & TEE_USAGE_EXTRACTABLE))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props) {\n\t\t/* Unknown object type, \"can't happen\" */\n\t\treturn TEE_ERROR_BAD_STATE;\n\t}\n\n\tidx = tee_svc_cryp_obj_find_type_attr_idx(attr_id, type_props);\n\tif ((idx < 0) || ((o->have_attrs & (1 << idx)) == 0))\n\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\tops = attr_ops + type_props->type_attrs[idx].ops_index;\n\tattr = (uint8_t *)o->attr + type_props->type_attrs[idx].raw_offs;\n\treturn ops->to_user(attr, sess, buffer, size);\n}\n\nvoid tee_obj_attr_free(struct tee_obj *o)\n{\n\tconst struct tee_cryp_obj_type_props *tp;\n\tsize_t n;\n\n\tif (!o->attr)\n\t\treturn;\n\ttp = tee_svc_find_type_props(o->info.objectType);\n\tif (!tp)\n\t\treturn;\n\n\tfor (n = 0; n < tp->num_type_attrs; n++) {\n\t\tconst struct tee_cryp_obj_type_attrs *ta = tp->type_attrs + n;\n\n\t\tattr_ops[ta->ops_index].free((uint8_t *)o->attr + ta->raw_offs);\n\t}\n}\n\nvoid tee_obj_attr_clear(struct tee_obj *o)\n{\n\tconst struct tee_cryp_obj_type_props *tp;\n\tsize_t n;\n\n\tif (!o->attr)\n\t\treturn;\n\ttp = tee_svc_find_type_props(o->info.objectType);\n\tif (!tp)\n\t\treturn;\n\n\tfor (n = 0; n < tp->num_type_attrs; n++) {\n\t\tconst struct tee_cryp_obj_type_attrs *ta = tp->type_attrs + n;\n\n\t\tattr_ops[ta->ops_index].clear((uint8_t *)o->attr +\n\t\t\t\t\t      ta->raw_offs);\n\t}\n}\n\nTEE_Result tee_obj_attr_to_binary(struct tee_obj *o, void *data,\n\t\t\t\t  size_t *data_len)\n{\n\tconst struct tee_cryp_obj_type_props *tp;\n\tsize_t n;\n\tsize_t offs = 0;\n\tsize_t len = data ? *data_len : 0;\n\tTEE_Result res;\n\n\tif (o->info.objectType == TEE_TYPE_DATA) {\n\t\t*data_len = 0;\n\t\treturn TEE_SUCCESS; /* pure data object */\n\t}\n\tif (!o->attr)\n\t\treturn TEE_ERROR_BAD_STATE;\n\ttp = tee_svc_find_type_props(o->info.objectType);\n\tif (!tp)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tfor (n = 0; n < tp->num_type_attrs; n++) {\n\t\tconst struct tee_cryp_obj_type_attrs *ta = tp->type_attrs + n;\n\t\tvoid *attr = (uint8_t *)o->attr + ta->raw_offs;\n\n\t\tres = attr_ops[ta->ops_index].to_binary(attr, data, len, &offs);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\t*data_len = offs;\n\tif (data && offs > len)\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result tee_obj_attr_from_binary(struct tee_obj *o, const void *data,\n\t\t\t\t    size_t data_len)\n{\n\tconst struct tee_cryp_obj_type_props *tp;\n\tsize_t n;\n\tsize_t offs = 0;\n\n\tif (o->info.objectType == TEE_TYPE_DATA)\n\t\treturn TEE_SUCCESS; /* pure data object */\n\tif (!o->attr)\n\t\treturn TEE_ERROR_BAD_STATE;\n\ttp = tee_svc_find_type_props(o->info.objectType);\n\tif (!tp)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tfor (n = 0; n < tp->num_type_attrs; n++) {\n\t\tconst struct tee_cryp_obj_type_attrs *ta = tp->type_attrs + n;\n\t\tvoid *attr = (uint8_t *)o->attr + ta->raw_offs;\n\n\t\tif (!attr_ops[ta->ops_index].from_binary(attr, data, data_len,\n\t\t\t\t\t\t\t &offs))\n\t\t\treturn TEE_ERROR_CORRUPT_OBJECT;\n\t}\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result tee_obj_attr_copy_from(struct tee_obj *o, const struct tee_obj *src)\n{\n\tTEE_Result res;\n\tconst struct tee_cryp_obj_type_props *tp;\n\tconst struct tee_cryp_obj_type_attrs *ta;\n\tsize_t n;\n\tuint32_t have_attrs = 0;\n\tvoid *attr;\n\tvoid *src_attr;\n\n\tif (o->info.objectType == TEE_TYPE_DATA)\n\t\treturn TEE_SUCCESS; /* pure data object */\n\tif (!o->attr)\n\t\treturn TEE_ERROR_BAD_STATE;\n\ttp = tee_svc_find_type_props(o->info.objectType);\n\tif (!tp)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tif (o->info.objectType == src->info.objectType) {\n\t\thave_attrs = src->have_attrs;\n\t\tfor (n = 0; n < tp->num_type_attrs; n++) {\n\t\t\tta = tp->type_attrs + n;\n\t\t\tattr = (uint8_t *)o->attr + ta->raw_offs;\n\t\t\tsrc_attr = (uint8_t *)src->attr + ta->raw_offs;\n\t\t\tres = attr_ops[ta->ops_index].from_obj(attr, src_attr);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t}\n\t} else {\n\t\tconst struct tee_cryp_obj_type_props *tp_src;\n\t\tint idx;\n\n\t\tif (o->info.objectType == TEE_TYPE_RSA_PUBLIC_KEY) {\n\t\t\tif (src->info.objectType != TEE_TYPE_RSA_KEYPAIR)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t} else if (o->info.objectType == TEE_TYPE_DSA_PUBLIC_KEY) {\n\t\t\tif (src->info.objectType != TEE_TYPE_DSA_KEYPAIR)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t} else if (o->info.objectType == TEE_TYPE_ECDSA_PUBLIC_KEY) {\n\t\t\tif (src->info.objectType != TEE_TYPE_ECDSA_KEYPAIR)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t} else if (o->info.objectType == TEE_TYPE_ECDH_PUBLIC_KEY) {\n\t\t\tif (src->info.objectType != TEE_TYPE_ECDH_KEYPAIR)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\n\t\ttp_src = tee_svc_find_type_props(src->info.objectType);\n\t\tif (!tp_src)\n\t\t\treturn TEE_ERROR_BAD_STATE;\n\n\t\thave_attrs = BIT32(tp->num_type_attrs) - 1;\n\t\tfor (n = 0; n < tp->num_type_attrs; n++) {\n\t\t\tta = tp->type_attrs + n;\n\n\t\t\tidx = tee_svc_cryp_obj_find_type_attr_idx(ta->attr_id,\n\t\t\t\t\t\t\t\t  tp_src);\n\t\t\tif (idx < 0)\n\t\t\t\treturn TEE_ERROR_BAD_STATE;\n\n\t\t\tattr = (uint8_t *)o->attr + ta->raw_offs;\n\t\t\tsrc_attr = (uint8_t *)src->attr +\n\t\t\t\t   tp_src->type_attrs[idx].raw_offs;\n\t\t\tres = attr_ops[ta->ops_index].from_obj(attr, src_attr);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t}\n\t}\n\n\to->have_attrs = have_attrs;\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result tee_obj_set_type(struct tee_obj *o, uint32_t obj_type,\n\t\t\t    size_t max_key_size)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\n\t/* Can only set type for newly allocated objs */\n\tif (o->attr)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/*\n\t * Verify that maxKeySize is supported and find out how\n\t * much should be allocated.\n\t */\n\n\tif (obj_type == TEE_TYPE_DATA) {\n\t\tif (max_key_size)\n\t\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\t} else {\n\t\t/* Find description of object */\n\t\ttype_props = tee_svc_find_type_props(obj_type);\n\t\tif (!type_props)\n\t\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t\t/* Check that maxKeySize follows restrictions */\n\t\tif (max_key_size % type_props->quanta != 0)\n\t\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\t\tif (max_key_size < type_props->min_size)\n\t\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\t\tif (max_key_size > type_props->max_size)\n\t\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t\to->attr = calloc(1, type_props->alloc_size);\n\t\tif (!o->attr)\n\t\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\t}\n\n\t/* If we have a key structure, pre-allocate the bignums inside */\n\tswitch (obj_type) {\n\tcase TEE_TYPE_RSA_PUBLIC_KEY:\n\t\tres = crypto_acipher_alloc_rsa_public_key(o->attr,\n\t\t\t\t\t\t\t  max_key_size);\n\t\tbreak;\n\tcase TEE_TYPE_RSA_KEYPAIR:\n\t\tres = crypto_acipher_alloc_rsa_keypair(o->attr, max_key_size);\n\t\tbreak;\n\tcase TEE_TYPE_DSA_PUBLIC_KEY:\n\t\tres = crypto_acipher_alloc_dsa_public_key(o->attr,\n\t\t\t\t\t\t\t  max_key_size);\n\t\tbreak;\n\tcase TEE_TYPE_DSA_KEYPAIR:\n\t\tres = crypto_acipher_alloc_dsa_keypair(o->attr, max_key_size);\n\t\tbreak;\n\tcase TEE_TYPE_DH_KEYPAIR:\n\t\tres = crypto_acipher_alloc_dh_keypair(o->attr, max_key_size);\n\t\tbreak;\n\tcase TEE_TYPE_ECDSA_PUBLIC_KEY:\n\tcase TEE_TYPE_ECDH_PUBLIC_KEY:\n\t\tres = crypto_acipher_alloc_ecc_public_key(o->attr,\n\t\t\t\t\t\t\t  max_key_size);\n\t\tbreak;\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\t\tres = crypto_acipher_alloc_ecc_keypair(o->attr, max_key_size);\n\t\tbreak;\n\tdefault:\n\t\tif (obj_type != TEE_TYPE_DATA) {\n\t\t\tstruct tee_cryp_obj_secret *key = o->attr;\n\n\t\t\tkey->alloc_size = type_props->alloc_size -\n\t\t\t\t\t  sizeof(*key);\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\to->info.objectType = obj_type;\n\to->info.maxKeySize = max_key_size;\n\to->info.objectUsage = TEE_USAGE_DEFAULT;\n\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result syscall_cryp_obj_alloc(unsigned long obj_type,\n\t\t\tunsigned long max_key_size, uint32_t *obj)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\n\tif (obj_type == TEE_TYPE_DATA)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\to = tee_obj_alloc();\n\tif (!o)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\n\tres = tee_obj_set_type(o, obj_type, max_key_size);\n\tif (res != TEE_SUCCESS) {\n\t\ttee_obj_free(o);\n\t\treturn res;\n\t}\n\n\ttee_obj_add(to_user_ta_ctx(sess->ctx), o);\n\n\tres = tee_svc_copy_kaddr_to_uref(obj, o);\n\tif (res != TEE_SUCCESS)\n\t\ttee_obj_close(to_user_ta_ctx(sess->ctx), o);\n\treturn res;\n}\n\nTEE_Result syscall_cryp_obj_close(unsigned long obj)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/*\n\t * If it's busy it's used by an operation, a client should never have\n\t * this handle.\n\t */\n\tif (o->busy)\n\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\ttee_obj_close(to_user_ta_ctx(sess->ctx), o);\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result syscall_cryp_obj_reset(unsigned long obj)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) == 0) {\n\t\ttee_obj_attr_clear(o);\n\t\to->info.keySize = 0;\n\t\to->info.objectUsage = TEE_USAGE_DEFAULT;\n\t} else {\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\t/* the object is no more initialized */\n\to->info.handleFlags &= ~TEE_HANDLE_FLAG_INITIALIZED;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result copy_in_attrs(struct user_ta_ctx *utc,\n\t\t\tconst struct utee_attribute *usr_attrs,\n\t\t\tuint32_t attr_count, TEE_Attribute *attrs)\n{\n\tTEE_Result res;\n\tuint32_t n;\n\tsize_t size = 0;\n\n\tif (MUL_OVERFLOW(sizeof(struct utee_attribute), attr_count, &size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tres = tee_mmu_check_access_rights(utc,\n\t\t\tTEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t(uaddr_t)usr_attrs, size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tfor (n = 0; n < attr_count; n++) {\n\t\tattrs[n].attributeID = usr_attrs[n].attribute_id;\n\t\tif (attrs[n].attributeID & TEE_ATTR_BIT_VALUE) {\n\t\t\tattrs[n].content.value.a = usr_attrs[n].a;\n\t\t\tattrs[n].content.value.b = usr_attrs[n].b;\n\t\t} else {\n\t\t\tuintptr_t buf = usr_attrs[n].a;\n\t\t\tsize_t len = usr_attrs[n].b;\n\n\t\t\tres = tee_mmu_check_access_rights(utc,\n\t\t\t\tTEE_MEMORY_ACCESS_READ |\n\t\t\t\tTEE_MEMORY_ACCESS_ANY_OWNER, buf, len);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tattrs[n].content.ref.buffer = (void *)buf;\n\t\t\tattrs[n].content.ref.length = len;\n\t\t}\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\nenum attr_usage {\n\tATTR_USAGE_POPULATE,\n\tATTR_USAGE_GENERATE_KEY\n};\n\nstatic TEE_Result tee_svc_cryp_check_attr(enum attr_usage usage,\n\t\t\t\t\t  const struct tee_cryp_obj_type_props\n\t\t\t\t\t\t*type_props,\n\t\t\t\t\t  const TEE_Attribute *attrs,\n\t\t\t\t\t  uint32_t attr_count)\n{\n\tuint32_t required_flag;\n\tuint32_t opt_flag;\n\tbool all_opt_needed;\n\tuint32_t req_attrs = 0;\n\tuint32_t opt_grp_attrs = 0;\n\tuint32_t attrs_found = 0;\n\tsize_t n;\n\tuint32_t bit;\n\tuint32_t flags;\n\tint idx;\n\n\tif (usage == ATTR_USAGE_POPULATE) {\n\t\trequired_flag = TEE_TYPE_ATTR_REQUIRED;\n\t\topt_flag = TEE_TYPE_ATTR_OPTIONAL_GROUP;\n\t\tall_opt_needed = true;\n\t} else {\n\t\trequired_flag = TEE_TYPE_ATTR_GEN_KEY_REQ;\n\t\topt_flag = TEE_TYPE_ATTR_GEN_KEY_OPT;\n\t\tall_opt_needed = false;\n\t}\n\n\t/*\n\t * First find out which attributes are required and which belong to\n\t * the optional group\n\t */\n\tfor (n = 0; n < type_props->num_type_attrs; n++) {\n\t\tbit = 1 << n;\n\t\tflags = type_props->type_attrs[n].flags;\n\n\t\tif (flags & required_flag)\n\t\t\treq_attrs |= bit;\n\t\telse if (flags & opt_flag)\n\t\t\topt_grp_attrs |= bit;\n\t}\n\n\t/*\n\t * Verify that all required attributes are in place and\n\t * that the same attribute isn't repeated.\n\t */\n\tfor (n = 0; n < attr_count; n++) {\n\t\tidx = tee_svc_cryp_obj_find_type_attr_idx(\n\t\t\t\t\t\t\tattrs[n].attributeID,\n\t\t\t\t\t\t\ttype_props);\n\n\t\t/* attribute not defined in current object type */\n\t\tif (idx < 0)\n\t\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\t\tbit = 1 << idx;\n\n\t\t/* attribute not repeated */\n\t\tif ((attrs_found & bit) != 0)\n\t\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\t\tattrs_found |= bit;\n\t}\n\t/* Required attribute missing */\n\tif ((attrs_found & req_attrs) != req_attrs)\n\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\t/*\n\t * If the flag says that \"if one of the optional attributes are included\n\t * all of them has to be included\" this must be checked.\n\t */\n\tif (all_opt_needed && (attrs_found & opt_grp_attrs) != 0 &&\n\t    (attrs_found & opt_grp_attrs) != opt_grp_attrs)\n\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result get_ec_key_size(uint32_t curve, size_t *key_size)\n{\n\tswitch (curve) {\n\tcase TEE_ECC_CURVE_NIST_P192:\n\t\t*key_size = 192;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P224:\n\t\t*key_size = 224;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P256:\n\t\t*key_size = 256;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P384:\n\t\t*key_size = 384;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P521:\n\t\t*key_size = 521;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result tee_svc_cryp_obj_populate_type(\n\t\tstruct tee_obj *o,\n\t\tconst struct tee_cryp_obj_type_props *type_props,\n\t\tconst TEE_Attribute *attrs,\n\t\tuint32_t attr_count)\n{\n\tTEE_Result res;\n\tuint32_t have_attrs = 0;\n\tsize_t obj_size = 0;\n\tsize_t n;\n\tint idx;\n\tconst struct attr_ops *ops;\n\tvoid *attr;\n\n\tfor (n = 0; n < attr_count; n++) {\n\t\tidx = tee_svc_cryp_obj_find_type_attr_idx(\n\t\t\t\t\t\t\tattrs[n].attributeID,\n\t\t\t\t\t\t\ttype_props);\n\t\t/* attribute not defined in current object type */\n\t\tif (idx < 0)\n\t\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\t\thave_attrs |= BIT32(idx);\n\t\tops = attr_ops + type_props->type_attrs[idx].ops_index;\n\t\tattr = (uint8_t *)o->attr +\n\t\t       type_props->type_attrs[idx].raw_offs;\n\t\tif (attrs[n].attributeID & TEE_ATTR_BIT_VALUE)\n\t\t\tres = ops->from_user(attr, &attrs[n].content.value,\n\t\t\t\t\t     sizeof(attrs[n].content.value));\n\t\telse\n\t\t\tres = ops->from_user(attr, attrs[n].content.ref.buffer,\n\t\t\t\t\t     attrs[n].content.ref.length);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\t/*\n\t\t * First attr_idx signifies the attribute that gives the size\n\t\t * of the object\n\t\t */\n\t\tif (type_props->type_attrs[idx].flags &\n\t\t    TEE_TYPE_ATTR_SIZE_INDICATOR) {\n\t\t\t/*\n\t\t\t * For ECDSA/ECDH we need to translate curve into\n\t\t\t * object size\n\t\t\t */\n\t\t\tif (attrs[n].attributeID == TEE_ATTR_ECC_CURVE) {\n\t\t\t\tres = get_ec_key_size(attrs[n].content.value.a,\n\t\t\t\t\t\t      &obj_size);\n\t\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\t\treturn res;\n\t\t\t} else {\n\t\t\t\tobj_size += (attrs[n].content.ref.length * 8);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * We have to do it like this because the parity bits aren't counted\n\t * when telling the size of the key in bits.\n\t */\n\tif (o->info.objectType == TEE_TYPE_DES ||\n\t    o->info.objectType == TEE_TYPE_DES3)\n\t\tobj_size -= obj_size / 8; /* Exclude parity in size of key */\n\n\to->have_attrs = have_attrs;\n\to->info.keySize = obj_size;\n\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result syscall_cryp_obj_populate(unsigned long obj,\n\t\t\tstruct utee_attribute *usr_attrs,\n\t\t\tunsigned long attr_count)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tTEE_Attribute *attrs = NULL;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Must be a transient object */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/* Must not be initialized already */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tsize_t alloc_size = 0;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), attr_count, &alloc_size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tattrs = malloc(alloc_size);\n\tif (!attrs)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\n\tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_attrs, attr_count,\n\t\t\t    attrs);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_POPULATE, type_props,\n\t\t\t\t      attrs, attr_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_obj_populate_type(o, type_props, attrs, attr_count);\n\tif (res == TEE_SUCCESS)\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\nout:\n\tfree_wipe(attrs);\n\treturn res;\n}\n\nTEE_Result syscall_cryp_obj_copy(unsigned long dst, unsigned long src)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *dst_o;\n\tstruct tee_obj *src_o;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(dst), &dst_o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(src), &src_o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif ((src_o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tif ((dst_o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tif ((dst_o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tres = tee_obj_attr_copy_from(dst_o, src_o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tdst_o->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\tdst_o->info.keySize = src_o->info.keySize;\n\tdst_o->info.objectUsage = src_o->info.objectUsage;\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result tee_svc_obj_generate_key_rsa(\n\tstruct tee_obj *o, const struct tee_cryp_obj_type_props *type_props,\n\tuint32_t key_size,\n\tconst TEE_Attribute *params, uint32_t param_count)\n{\n\tTEE_Result res;\n\tstruct rsa_keypair *key = o->attr;\n\tuint32_t e = TEE_U32_TO_BIG_ENDIAN(65537);\n\n\t/* Copy the present attributes into the obj before starting */\n\tres = tee_svc_cryp_obj_populate_type(o, type_props, params,\n\t\t\t\t\t     param_count);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (!get_attribute(o, type_props, TEE_ATTR_RSA_PUBLIC_EXPONENT))\n\t\tcrypto_bignum_bin2bn((const uint8_t *)&e, sizeof(e), key->e);\n\tres = crypto_acipher_gen_rsa_key(key, key_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Set bits for all known attributes for this object type */\n\to->have_attrs = (1 << type_props->num_type_attrs) - 1;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result tee_svc_obj_generate_key_dsa(\n\tstruct tee_obj *o, const struct tee_cryp_obj_type_props *type_props,\n\tuint32_t key_size)\n{\n\tTEE_Result res;\n\n\tres = crypto_acipher_gen_dsa_key(o->attr, key_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Set bits for all known attributes for this object type */\n\to->have_attrs = (1 << type_props->num_type_attrs) - 1;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result tee_svc_obj_generate_key_dh(\n\tstruct tee_obj *o, const struct tee_cryp_obj_type_props *type_props,\n\tuint32_t key_size __unused,\n\tconst TEE_Attribute *params, uint32_t param_count)\n{\n\tTEE_Result res;\n\tstruct dh_keypair *tee_dh_key;\n\tstruct bignum *dh_q = NULL;\n\tuint32_t dh_xbits = 0;\n\n\t/* Copy the present attributes into the obj before starting */\n\tres = tee_svc_cryp_obj_populate_type(o, type_props, params,\n\t\t\t\t\t     param_count);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\ttee_dh_key = (struct dh_keypair *)o->attr;\n\n\tif (get_attribute(o, type_props, TEE_ATTR_DH_SUBPRIME))\n\t\tdh_q = tee_dh_key->q;\n\tif (get_attribute(o, type_props, TEE_ATTR_DH_X_BITS))\n\t\tdh_xbits = tee_dh_key->xbits;\n\tres = crypto_acipher_gen_dh_key(tee_dh_key, dh_q, dh_xbits);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Set bits for the generated public and private key */\n\tset_attribute(o, type_props, TEE_ATTR_DH_PUBLIC_VALUE);\n\tset_attribute(o, type_props, TEE_ATTR_DH_PRIVATE_VALUE);\n\tset_attribute(o, type_props, TEE_ATTR_DH_X_BITS);\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result tee_svc_obj_generate_key_ecc(\n\tstruct tee_obj *o, const struct tee_cryp_obj_type_props *type_props,\n\tuint32_t key_size __unused,\n\tconst TEE_Attribute *params, uint32_t param_count)\n{\n\tTEE_Result res;\n\tstruct ecc_keypair *tee_ecc_key;\n\n\t/* Copy the present attributes into the obj before starting */\n\tres = tee_svc_cryp_obj_populate_type(o, type_props, params,\n\t\t\t\t\t     param_count);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\ttee_ecc_key = (struct ecc_keypair *)o->attr;\n\n\tres = crypto_acipher_gen_ecc_key(tee_ecc_key);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Set bits for the generated public and private key */\n\tset_attribute(o, type_props, TEE_ATTR_ECC_PRIVATE_VALUE);\n\tset_attribute(o, type_props, TEE_ATTR_ECC_PUBLIC_VALUE_X);\n\tset_attribute(o, type_props, TEE_ATTR_ECC_PUBLIC_VALUE_Y);\n\tset_attribute(o, type_props, TEE_ATTR_ECC_CURVE);\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result syscall_obj_generate_key(unsigned long obj, unsigned long key_size,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tunsigned long param_count)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key;\n\tsize_t byte_size;\n\tTEE_Attribute *params = NULL;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Must be a transient object */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Must not be initialized already */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Find description of object */\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t/* Check that maxKeySize follows restrictions */\n\tif (key_size % type_props->quanta != 0)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size < type_props->min_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size > type_props->max_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\tsize_t alloc_size = 0;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), param_count, &alloc_size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tparams = malloc(alloc_size);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_params, param_count,\n\t\t\t    params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_GENERATE_KEY, type_props,\n\t\t\t\t      params, param_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tswitch (o->info.objectType) {\n\tcase TEE_TYPE_AES:\n\tcase TEE_TYPE_DES:\n\tcase TEE_TYPE_DES3:\n\tcase TEE_TYPE_HMAC_MD5:\n\tcase TEE_TYPE_HMAC_SHA1:\n\tcase TEE_TYPE_HMAC_SHA224:\n\tcase TEE_TYPE_HMAC_SHA256:\n\tcase TEE_TYPE_HMAC_SHA384:\n\tcase TEE_TYPE_HMAC_SHA512:\n\tcase TEE_TYPE_GENERIC_SECRET:\n\t\tbyte_size = key_size / 8;\n\n\t\t/*\n\t\t * We have to do it like this because the parity bits aren't\n\t\t * counted when telling the size of the key in bits.\n\t\t */\n\t\tif (o->info.objectType == TEE_TYPE_DES ||\n\t\t    o->info.objectType == TEE_TYPE_DES3) {\n\t\t\tbyte_size = (key_size + key_size / 7) / 8;\n\t\t}\n\n\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\tif (byte_size > key->alloc_size) {\n\t\t\tres = TEE_ERROR_EXCESS_DATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = crypto_rng_read((void *)(key + 1), byte_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tkey->key_size = byte_size;\n\n\t\t/* Set bits for all known attributes for this object type */\n\t\to->have_attrs = (1 << type_props->num_type_attrs) - 1;\n\n\t\tbreak;\n\n\tcase TEE_TYPE_RSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_rsa(o, type_props, key_size,\n\t\t\t\t\t\t   params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dsa(o, type_props, key_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dh(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_ecc(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_BAD_FORMAT;\n\t}\n\nout:\n\tfree_wipe(params);\n\tif (res == TEE_SUCCESS) {\n\t\to->info.keySize = key_size;\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t}\n\treturn res;\n}\n\nstatic TEE_Result tee_svc_cryp_get_state(struct tee_ta_session *sess,\n\t\t\t\t\t uint32_t state_id,\n\t\t\t\t\t struct tee_cryp_state **state)\n{\n\tstruct tee_cryp_state *s;\n\tstruct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);\n\n\tTAILQ_FOREACH(s, &utc->cryp_states, link) {\n\t\tif (state_id == (vaddr_t)s) {\n\t\t\t*state = s;\n\t\t\treturn TEE_SUCCESS;\n\t\t}\n\t}\n\treturn TEE_ERROR_BAD_PARAMETERS;\n}\n\nstatic void cryp_state_free(struct user_ta_ctx *utc, struct tee_cryp_state *cs)\n{\n\tstruct tee_obj *o;\n\n\tif (tee_obj_get(utc, cs->key1, &o) == TEE_SUCCESS)\n\t\ttee_obj_close(utc, o);\n\tif (tee_obj_get(utc, cs->key2, &o) == TEE_SUCCESS)\n\t\ttee_obj_close(utc, o);\n\n\tTAILQ_REMOVE(&utc->cryp_states, cs, link);\n\tif (cs->ctx_finalize != NULL)\n\t\tcs->ctx_finalize(cs->ctx, cs->algo);\n\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_CIPHER:\n\t\tcrypto_cipher_free_ctx(cs->ctx, cs->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_AE:\n\t\tcrypto_authenc_free_ctx(cs->ctx, cs->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_DIGEST:\n\t\tcrypto_hash_free_ctx(cs->ctx, cs->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tcrypto_mac_free_ctx(cs->ctx, cs->algo);\n\t\tbreak;\n\tdefault:\n\t\tassert(!cs->ctx);\n\t}\n\n\tfree(cs);\n}\n\nstatic TEE_Result tee_svc_cryp_check_key_type(const struct tee_obj *o,\n\t\t\t\t\t      uint32_t algo,\n\t\t\t\t\t      TEE_OperationMode mode)\n{\n\tuint32_t req_key_type;\n\tuint32_t req_key_type2 = 0;\n\n\tswitch (TEE_ALG_GET_MAIN_ALG(algo)) {\n\tcase TEE_MAIN_ALGO_MD5:\n\t\treq_key_type = TEE_TYPE_HMAC_MD5;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SHA1:\n\t\treq_key_type = TEE_TYPE_HMAC_SHA1;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SHA224:\n\t\treq_key_type = TEE_TYPE_HMAC_SHA224;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SHA256:\n\t\treq_key_type = TEE_TYPE_HMAC_SHA256;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SHA384:\n\t\treq_key_type = TEE_TYPE_HMAC_SHA384;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SHA512:\n\t\treq_key_type = TEE_TYPE_HMAC_SHA512;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_AES:\n\t\treq_key_type = TEE_TYPE_AES;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_DES:\n\t\treq_key_type = TEE_TYPE_DES;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_DES3:\n\t\treq_key_type = TEE_TYPE_DES3;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_RSA:\n\t\treq_key_type = TEE_TYPE_RSA_KEYPAIR;\n\t\tif (mode == TEE_MODE_ENCRYPT || mode == TEE_MODE_VERIFY)\n\t\t\treq_key_type2 = TEE_TYPE_RSA_PUBLIC_KEY;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_DSA:\n\t\treq_key_type = TEE_TYPE_DSA_KEYPAIR;\n\t\tif (mode == TEE_MODE_ENCRYPT || mode == TEE_MODE_VERIFY)\n\t\t\treq_key_type2 = TEE_TYPE_DSA_PUBLIC_KEY;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_DH:\n\t\treq_key_type = TEE_TYPE_DH_KEYPAIR;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_ECDSA:\n\t\treq_key_type = TEE_TYPE_ECDSA_KEYPAIR;\n\t\tif (mode == TEE_MODE_VERIFY)\n\t\t\treq_key_type2 = TEE_TYPE_ECDSA_PUBLIC_KEY;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_ECDH:\n\t\treq_key_type = TEE_TYPE_ECDH_KEYPAIR;\n\t\tbreak;\n#if defined(CFG_CRYPTO_HKDF)\n\tcase TEE_MAIN_ALGO_HKDF:\n\t\treq_key_type = TEE_TYPE_HKDF_IKM;\n\t\tbreak;\n#endif\n#if defined(CFG_CRYPTO_CONCAT_KDF)\n\tcase TEE_MAIN_ALGO_CONCAT_KDF:\n\t\treq_key_type = TEE_TYPE_CONCAT_KDF_Z;\n\t\tbreak;\n#endif\n#if defined(CFG_CRYPTO_PBKDF2)\n\tcase TEE_MAIN_ALGO_PBKDF2:\n\t\treq_key_type = TEE_TYPE_PBKDF2_PASSWORD;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\tif (req_key_type != o->info.objectType &&\n\t    req_key_type2 != o->info.objectType)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result syscall_cryp_state_alloc(unsigned long algo, unsigned long mode,\n\t\t\tunsigned long key1, unsigned long key2,\n\t\t\tuint32_t *state)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o1 = NULL;\n\tstruct tee_obj *o2 = NULL;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tif (key1 != 0) {\n\t\tres = tee_obj_get(utc, tee_svc_uref_to_vaddr(key1), &o1);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (o1->busy)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tres = tee_svc_cryp_check_key_type(o1, algo, mode);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\tif (key2 != 0) {\n\t\tres = tee_obj_get(utc, tee_svc_uref_to_vaddr(key2), &o2);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (o2->busy)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tres = tee_svc_cryp_check_key_type(o2, algo, mode);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tcs = calloc(1, sizeof(struct tee_cryp_state));\n\tif (!cs)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tTAILQ_INSERT_TAIL(&utc->cryp_states, cs, link);\n\tcs->algo = algo;\n\tcs->mode = mode;\n\tcs->state = CRYP_STATE_UNINITIALIZED;\n\n\tswitch (TEE_ALG_GET_CLASS(algo)) {\n\tcase TEE_OPERATION_EXTENSION:\n#ifdef CFG_CRYPTO_RSASSA_NA1\n\t\tif (algo == TEE_ALG_RSASSA_PKCS1_V1_5)\n\t\t\tgoto rsassa_na1;\n#endif\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tbreak;\n\tcase TEE_OPERATION_CIPHER:\n\t\tif ((algo == TEE_ALG_AES_XTS && (key1 == 0 || key2 == 0)) ||\n\t\t    (algo != TEE_ALG_AES_XTS && (key1 == 0 || key2 != 0))) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_cipher_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_AE:\n\t\tif (key1 == 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_authenc_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tif (key1 == 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_mac_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_DIGEST:\n\t\tif (key1 != 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_hash_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_ASYMMETRIC_CIPHER:\n\tcase TEE_OPERATION_ASYMMETRIC_SIGNATURE:\nrsassa_na1: __maybe_unused\n\t\tif (key1 == 0 || key2 != 0)\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tcase TEE_OPERATION_KEY_DERIVATION:\n\t\tif (key1 == 0 || key2 != 0)\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tdefault:\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tbreak;\n\t}\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_copy_kaddr_to_uref(state, cs);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\t/* Register keys */\n\tif (o1 != NULL) {\n\t\to1->busy = true;\n\t\tcs->key1 = (vaddr_t)o1;\n\t}\n\tif (o2 != NULL) {\n\t\to2->busy = true;\n\t\tcs->key2 = (vaddr_t)o2;\n\t}\n\nout:\n\tif (res != TEE_SUCCESS)\n\t\tcryp_state_free(utc, cs);\n\treturn res;\n}\n\nTEE_Result syscall_cryp_state_copy(unsigned long dst, unsigned long src)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs_dst;\n\tstruct tee_cryp_state *cs_src;\n\tstruct tee_ta_session *sess;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(dst), &cs_dst);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(src), &cs_src);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (cs_dst->algo != cs_src->algo || cs_dst->mode != cs_src->mode)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tswitch (TEE_ALG_GET_CLASS(cs_src->algo)) {\n\tcase TEE_OPERATION_CIPHER:\n\t\tcrypto_cipher_copy_state(cs_dst->ctx, cs_src->ctx,\n\t\t\t\t\t cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_AE:\n\t\tcrypto_authenc_copy_state(cs_dst->ctx, cs_src->ctx,\n\t\t\t\t\t  cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_DIGEST:\n\t\tcrypto_hash_copy_state(cs_dst->ctx, cs_src->ctx, cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tcrypto_mac_copy_state(cs_dst->ctx, cs_src->ctx, cs_src->algo);\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_STATE;\n\t}\n\n\tcs_dst->state = cs_src->state;\n\n\treturn TEE_SUCCESS;\n}\n\nvoid tee_svc_cryp_free_states(struct user_ta_ctx *utc)\n{\n\tstruct tee_cryp_state_head *states = &utc->cryp_states;\n\n\twhile (!TAILQ_EMPTY(states))\n\t\tcryp_state_free(utc, TAILQ_FIRST(states));\n}\n\nTEE_Result syscall_cryp_state_free(unsigned long state)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tcryp_state_free(to_user_ta_ctx(sess->ctx), cs);\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result syscall_hash_init(unsigned long state,\n\t\t\t     const void *iv __maybe_unused,\n\t\t\t     size_t iv_len __maybe_unused)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = crypto_hash_init(cs->ctx, cs->algo);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\t{\n\t\t\tstruct tee_obj *o;\n\t\t\tstruct tee_cryp_obj_secret *key;\n\n\t\t\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  cs->key1, &o);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tif ((o->info.handleFlags &\n\t\t\t     TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\t\tres = crypto_mac_init(cs->ctx, cs->algo,\n\t\t\t\t\t      (void *)(key + 1), key->key_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\tcs->state = CRYP_STATE_INITIALIZED;\n\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result syscall_hash_update(unsigned long state, const void *chunk,\n\t\t\tsize_t chunk_size)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\n\t/* No data, but size provided isn't valid parameters. */\n\tif (!chunk && chunk_size)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/* Zero length hash is valid, but nothing we need to do. */\n\tif (!chunk_size)\n\t\treturn TEE_SUCCESS;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)chunk, chunk_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = crypto_hash_update(cs->ctx, cs->algo, chunk, chunk_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tres = crypto_mac_update(cs->ctx, cs->algo, chunk, chunk_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result syscall_hash_final(unsigned long state, const void *chunk,\n\t\t\tsize_t chunk_size, void *hash, uint64_t *hash_len)\n{\n\tTEE_Result res, res2;\n\tsize_t hash_size;\n\tsize_t hlen = 0;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\n\t/* No data, but size provided isn't valid parameters. */\n\tif (!chunk && chunk_size)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)chunk, chunk_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = get_user_u64_as_size_t(&hlen, hash_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)hash, hlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = tee_hash_get_digest_size(cs->algo, &hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (hlen < hash_size) {\n\t\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (chunk_size) {\n\t\t\tres = crypto_hash_update(cs->ctx, cs->algo, chunk,\n\t\t\t\t\t\t chunk_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t}\n\n\t\tres = crypto_hash_final(cs->ctx, cs->algo, hash, hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\n\tcase TEE_OPERATION_MAC:\n\t\tres = tee_mac_get_digest_size(cs->algo, &hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (hlen < hash_size) {\n\t\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (chunk_size) {\n\t\t\tres = crypto_mac_update(cs->ctx, cs->algo, chunk,\n\t\t\t\t\t\tchunk_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t}\n\n\t\tres = crypto_mac_final(cs->ctx, cs->algo, hash, hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\nout:\n\tres2 = put_user_u64(hash_len, hash_size);\n\tif (res2 != TEE_SUCCESS)\n\t\treturn res2;\n\treturn res;\n}\n\nTEE_Result syscall_cipher_init(unsigned long state, const void *iv,\n\t\t\tsize_t iv_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key1;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_CIPHER)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = tee_mmu_check_access_rights(utc,\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t) iv, iv_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(utc, cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tkey1 = o->attr;\n\n\tif (tee_obj_get(utc, cs->key2, &o) == TEE_SUCCESS) {\n\t\tstruct tee_cryp_obj_secret *key2 = o->attr;\n\n\t\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t\tres = crypto_cipher_init(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t (uint8_t *)(key1 + 1), key1->key_size,\n\t\t\t\t\t (uint8_t *)(key2 + 1), key2->key_size,\n\t\t\t\t\t iv, iv_len);\n\t} else {\n\t\tres = crypto_cipher_init(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t (uint8_t *)(key1 + 1), key1->key_size,\n\t\t\t\t\t NULL, 0, iv, iv_len);\n\t}\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tcs->ctx_finalize = crypto_cipher_final;\n\tcs->state = CRYP_STATE_INITIALIZED;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result tee_svc_cipher_update_helper(unsigned long state,\n\t\t\tbool last_block, const void *src, size_t src_len,\n\t\t\tvoid *dst, uint64_t *dst_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tsize_t dlen = 0;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)src, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (!dst_len) {\n\t\tdlen = 0;\n\t} else {\n\t\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t\t  (uaddr_t)dst, dlen);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tif (src_len > 0) {\n\t\t/* Permit src_len == 0 to finalize the operation */\n\t\tres = tee_do_cipher_update(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t   last_block, src, src_len, dst);\n\t}\n\n\tif (last_block && cs->ctx_finalize != NULL) {\n\t\tcs->ctx_finalize(cs->ctx, cs->algo);\n\t\tcs->ctx_finalize = NULL;\n\t}\n\nout:\n\tif ((res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) &&\n\t    dst_len != NULL) {\n\t\tTEE_Result res2;\n\n\t\tres2 = put_user_u64(dst_len, src_len);\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\tres = res2;\n\t}\n\n\treturn res;\n}\n\nTEE_Result syscall_cipher_update(unsigned long state, const void *src,\n\t\t\tsize_t src_len, void *dst, uint64_t *dst_len)\n{\n\treturn tee_svc_cipher_update_helper(state, false /* last_block */,\n\t\t\t\t\t    src, src_len, dst, dst_len);\n}\n\nTEE_Result syscall_cipher_final(unsigned long state, const void *src,\n\t\t\tsize_t src_len, void *dst, uint64_t *dst_len)\n{\n\treturn tee_svc_cipher_update_helper(state, true /* last_block */,\n\t\t\t\t\t    src, src_len, dst, dst_len);\n}\n\n#if defined(CFG_CRYPTO_HKDF)\nstatic TEE_Result get_hkdf_params(const TEE_Attribute *params,\n\t\t\t\t  uint32_t param_count,\n\t\t\t\t  void **salt, size_t *salt_len, void **info,\n\t\t\t\t  size_t *info_len, size_t *okm_len)\n{\n\tsize_t n;\n\tenum { SALT = 0x1, LENGTH = 0x2, INFO = 0x4 };\n\tuint8_t found = 0;\n\n\t*salt = *info = NULL;\n\t*salt_len = *info_len = *okm_len = 0;\n\n\tfor (n = 0; n < param_count; n++) {\n\t\tswitch (params[n].attributeID) {\n\t\tcase TEE_ATTR_HKDF_SALT:\n\t\t\tif (!(found & SALT)) {\n\t\t\t\t*salt = params[n].content.ref.buffer;\n\t\t\t\t*salt_len = params[n].content.ref.length;\n\t\t\t\tfound |= SALT;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TEE_ATTR_HKDF_OKM_LENGTH:\n\t\t\tif (!(found & LENGTH)) {\n\t\t\t\t*okm_len = params[n].content.value.a;\n\t\t\t\tfound |= LENGTH;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TEE_ATTR_HKDF_INFO:\n\t\t\tif (!(found & INFO)) {\n\t\t\t\t*info = params[n].content.ref.buffer;\n\t\t\t\t*info_len = params[n].content.ref.length;\n\t\t\t\tfound |= INFO;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Unexpected attribute */\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\n\t}\n\n\tif (!(found & LENGTH))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\treturn TEE_SUCCESS;\n}\n#endif\n\n#if defined(CFG_CRYPTO_CONCAT_KDF)\nstatic TEE_Result get_concat_kdf_params(const TEE_Attribute *params,\n\t\t\t\t\tuint32_t param_count,\n\t\t\t\t\tvoid **other_info,\n\t\t\t\t\tsize_t *other_info_len,\n\t\t\t\t\tsize_t *derived_key_len)\n{\n\tsize_t n;\n\tenum { LENGTH = 0x1, INFO = 0x2 };\n\tuint8_t found = 0;\n\n\t*other_info = NULL;\n\t*other_info_len = *derived_key_len = 0;\n\n\tfor (n = 0; n < param_count; n++) {\n\t\tswitch (params[n].attributeID) {\n\t\tcase TEE_ATTR_CONCAT_KDF_OTHER_INFO:\n\t\t\tif (!(found & INFO)) {\n\t\t\t\t*other_info = params[n].content.ref.buffer;\n\t\t\t\t*other_info_len = params[n].content.ref.length;\n\t\t\t\tfound |= INFO;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TEE_ATTR_CONCAT_KDF_DKM_LENGTH:\n\t\t\tif (!(found & LENGTH)) {\n\t\t\t\t*derived_key_len = params[n].content.value.a;\n\t\t\t\tfound |= LENGTH;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Unexpected attribute */\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\t}\n\n\tif (!(found & LENGTH))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\treturn TEE_SUCCESS;\n}\n#endif\n\n#if defined(CFG_CRYPTO_PBKDF2)\nstatic TEE_Result get_pbkdf2_params(const TEE_Attribute *params,\n\t\t\t\t   uint32_t param_count, void **salt,\n\t\t\t\t   size_t *salt_len, size_t *derived_key_len,\n\t\t\t\t   size_t *iteration_count)\n{\n\tsize_t n;\n\tenum { SALT = 0x1, LENGTH = 0x2, COUNT = 0x4 };\n\tuint8_t found = 0;\n\n\t*salt = NULL;\n\t*salt_len = *derived_key_len = *iteration_count = 0;\n\n\tfor (n = 0; n < param_count; n++) {\n\t\tswitch (params[n].attributeID) {\n\t\tcase TEE_ATTR_PBKDF2_SALT:\n\t\t\tif (!(found & SALT)) {\n\t\t\t\t*salt = params[n].content.ref.buffer;\n\t\t\t\t*salt_len = params[n].content.ref.length;\n\t\t\t\tfound |= SALT;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TEE_ATTR_PBKDF2_DKM_LENGTH:\n\t\t\tif (!(found & LENGTH)) {\n\t\t\t\t*derived_key_len = params[n].content.value.a;\n\t\t\t\tfound |= LENGTH;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TEE_ATTR_PBKDF2_ITERATION_COUNT:\n\t\t\tif (!(found & COUNT)) {\n\t\t\t\t*iteration_count = params[n].content.value.a;\n\t\t\t\tfound |= COUNT;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Unexpected attribute */\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\t}\n\n\tif ((found & (LENGTH|COUNT)) != (LENGTH|COUNT))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\treturn TEE_SUCCESS;\n}\n#endif\n\nTEE_Result syscall_cryp_derive_key(unsigned long state,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tunsigned long param_count, unsigned long derived_key)\n{\n\tTEE_Result res = TEE_ERROR_NOT_SUPPORTED;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *ko;\n\tstruct tee_obj *so;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_cryp_obj_secret *sk;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tTEE_Attribute *params = NULL;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tsize_t alloc_size = 0;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), param_count, &alloc_size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tparams = malloc(alloc_size);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(utc, usr_params, param_count, params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\t/* Get key set in operation */\n\tres = tee_obj_get(utc, cs->key1, &ko);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_obj_get(utc, tee_svc_uref_to_vaddr(derived_key), &so);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\t/* Find information needed about the object to initialize */\n\tsk = so->attr;\n\n\t/* Find description of object */\n\ttype_props = tee_svc_find_type_props(so->info.objectType);\n\tif (!type_props) {\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tgoto out;\n\t}\n\n\tif (cs->algo == TEE_ALG_DH_DERIVE_SHARED_SECRET) {\n\t\tstruct bignum *pub;\n\t\tstruct bignum *ss;\n\n\t\tif (param_count != 1 ||\n\t\t    params[0].attributeID != TEE_ATTR_DH_PUBLIC_VALUE) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsize_t bin_size = params[0].content.ref.length;\n\n\t\tif (MUL_OVERFLOW(bin_size, 8, &alloc_size)) {\n\t\t\tres = TEE_ERROR_OVERFLOW;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpub = crypto_bignum_allocate(alloc_size);\n\t\tss = crypto_bignum_allocate(alloc_size);\n\t\tif (pub && ss) {\n\t\t\tcrypto_bignum_bin2bn(params[0].content.ref.buffer,\n\t\t\t\t\t     bin_size, pub);\n\t\t\tres = crypto_acipher_dh_shared_secret(ko->attr,\n\t\t\t\t\t\t\t      pub, ss);\n\t\t\tif (res == TEE_SUCCESS) {\n\t\t\t\tsk->key_size = crypto_bignum_num_bytes(ss);\n\t\t\t\tcrypto_bignum_bn2bin(ss, (uint8_t *)(sk + 1));\n\t\t\t\tso->info.handleFlags |=\n\t\t\t\t\t\tTEE_HANDLE_FLAG_INITIALIZED;\n\t\t\t\tset_attribute(so, type_props,\n\t\t\t\t\t      TEE_ATTR_SECRET_VALUE);\n\t\t\t}\n\t\t} else {\n\t\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\t}\n\t\tcrypto_bignum_free(pub);\n\t\tcrypto_bignum_free(ss);\n\t} else if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_ECDH) {\n\t\tstruct ecc_public_key key_public;\n\t\tuint8_t *pt_secret;\n\t\tunsigned long pt_secret_len;\n\n\t\tif (param_count != 2 ||\n\t\t    params[0].attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_X ||\n\t\t    params[1].attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_Y) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (cs->algo) {\n\t\tcase TEE_ALG_ECDH_P192:\n\t\t\talloc_size = 192;\n\t\t\tbreak;\n\t\tcase TEE_ALG_ECDH_P224:\n\t\t\talloc_size = 224;\n\t\t\tbreak;\n\t\tcase TEE_ALG_ECDH_P256:\n\t\t\talloc_size = 256;\n\t\t\tbreak;\n\t\tcase TEE_ALG_ECDH_P384:\n\t\t\talloc_size = 384;\n\t\t\tbreak;\n\t\tcase TEE_ALG_ECDH_P521:\n\t\t\talloc_size = 521;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tres = TEE_ERROR_NOT_IMPLEMENTED;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Create the public key */\n\t\tres = crypto_acipher_alloc_ecc_public_key(&key_public,\n\t\t\t\t\t\t\t  alloc_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tkey_public.curve = ((struct ecc_keypair *)ko->attr)->curve;\n\t\tcrypto_bignum_bin2bn(params[0].content.ref.buffer,\n\t\t\t\t     params[0].content.ref.length,\n\t\t\t\t     key_public.x);\n\t\tcrypto_bignum_bin2bn(params[1].content.ref.buffer,\n\t\t\t\t     params[1].content.ref.length,\n\t\t\t\t     key_public.y);\n\n\t\tpt_secret = (uint8_t *)(sk + 1);\n\t\tpt_secret_len = sk->alloc_size;\n\t\tres = crypto_acipher_ecc_shared_secret(ko->attr, &key_public,\n\t\t\t\t\t\t       pt_secret,\n\t\t\t\t\t\t       &pt_secret_len);\n\n\t\tif (res == TEE_SUCCESS) {\n\t\t\tsk->key_size = pt_secret_len;\n\t\t\tso->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t\t\tset_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);\n\t\t}\n\n\t\t/* free the public key */\n\t\tcrypto_acipher_free_ecc_public_key(&key_public);\n\t}\n#if defined(CFG_CRYPTO_HKDF)\n\telse if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_HKDF) {\n\t\tvoid *salt, *info;\n\t\tsize_t salt_len, info_len, okm_len;\n\t\tuint32_t hash_id = TEE_ALG_GET_DIGEST_HASH(cs->algo);\n\t\tstruct tee_cryp_obj_secret *ik = ko->attr;\n\t\tconst uint8_t *ikm = (const uint8_t *)(ik + 1);\n\n\t\tres = get_hkdf_params(params, param_count, &salt, &salt_len,\n\t\t\t\t      &info, &info_len, &okm_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\t/* Requested size must fit into the output object's buffer */\n\t\tif (okm_len > ik->alloc_size) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = tee_cryp_hkdf(hash_id, ikm, ik->key_size, salt, salt_len,\n\t\t\t\t    info, info_len, (uint8_t *)(sk + 1),\n\t\t\t\t    okm_len);\n\t\tif (res == TEE_SUCCESS) {\n\t\t\tsk->key_size = okm_len;\n\t\t\tso->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t\t\tset_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);\n\t\t}\n\t}\n#endif\n#if defined(CFG_CRYPTO_CONCAT_KDF)\n\telse if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_CONCAT_KDF) {\n\t\tvoid *info;\n\t\tsize_t info_len, derived_key_len;\n\t\tuint32_t hash_id = TEE_ALG_GET_DIGEST_HASH(cs->algo);\n\t\tstruct tee_cryp_obj_secret *ss = ko->attr;\n\t\tconst uint8_t *shared_secret = (const uint8_t *)(ss + 1);\n\n\t\tres = get_concat_kdf_params(params, param_count, &info,\n\t\t\t\t\t    &info_len, &derived_key_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\t/* Requested size must fit into the output object's buffer */\n\t\tif (derived_key_len > ss->alloc_size) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = tee_cryp_concat_kdf(hash_id, shared_secret, ss->key_size,\n\t\t\t\t\t  info, info_len, (uint8_t *)(sk + 1),\n\t\t\t\t\t  derived_key_len);\n\t\tif (res == TEE_SUCCESS) {\n\t\t\tsk->key_size = derived_key_len;\n\t\t\tso->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t\t\tset_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);\n\t\t}\n\t}\n#endif\n#if defined(CFG_CRYPTO_PBKDF2)\n\telse if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_PBKDF2) {\n\t\tvoid *salt;\n\t\tsize_t salt_len, iteration_count, derived_key_len;\n\t\tuint32_t hash_id = TEE_ALG_GET_DIGEST_HASH(cs->algo);\n\t\tstruct tee_cryp_obj_secret *ss = ko->attr;\n\t\tconst uint8_t *password = (const uint8_t *)(ss + 1);\n\n\t\tres = get_pbkdf2_params(params, param_count, &salt, &salt_len,\n\t\t\t\t\t&derived_key_len, &iteration_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\t/* Requested size must fit into the output object's buffer */\n\t\tif (derived_key_len > ss->alloc_size) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = tee_cryp_pbkdf2(hash_id, password, ss->key_size, salt,\n\t\t\t\t      salt_len, iteration_count,\n\t\t\t\t      (uint8_t *)(sk + 1), derived_key_len);\n\t\tif (res == TEE_SUCCESS) {\n\t\t\tsk->key_size = derived_key_len;\n\t\t\tso->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t\t\tset_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);\n\t\t}\n\t}\n#endif\n\telse\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\nout:\n\tfree_wipe(params);\n\treturn res;\n}\n\nTEE_Result syscall_cryp_random_number_generate(void *buf, size_t blen)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)buf, blen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = crypto_rng_read(buf, blen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\treturn res;\n}\n\nTEE_Result syscall_authenc_init(unsigned long state, const void *nonce,\n\t\t\tsize_t nonce_len, size_t tag_len,\n\t\t\tsize_t aad_len, size_t payload_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)nonce, nonce_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx), cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tkey = o->attr;\n\tres = crypto_authenc_init(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t  (uint8_t *)(key + 1), key->key_size,\n\t\t\t\t  nonce, nonce_len, tag_len, aad_len,\n\t\t\t\t  payload_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tcs->ctx_finalize = (tee_cryp_ctx_finalize_func_t)crypto_authenc_final;\n\tcs->state = CRYP_STATE_INITIALIZED;\n\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result syscall_authenc_update_aad(unsigned long state,\n\t\t\tconst void *aad_data, size_t aad_data_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t) aad_data,\n\t\t\t\t\t  aad_data_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = crypto_authenc_update_aad(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\taad_data, aad_data_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result syscall_authenc_update_payload(unsigned long state,\n\t\t\tconst void *src_data, size_t src_len, void *dst_data,\n\t\t\tuint64_t *dst_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tsize_t dlen = 0;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t) src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)dst_data, dlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tres = crypto_authenc_update_payload(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t    src_data, src_len, dst_data,\n\t\t\t\t\t    &dlen);\nout:\n\tif (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {\n\t\tTEE_Result res2 = put_user_u64(dst_len, dlen);\n\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\tres = res2;\n\t}\n\n\treturn res;\n}\n\nTEE_Result syscall_authenc_enc_final(unsigned long state,\n\t\t\tconst void *src_data, size_t src_len, void *dst_data,\n\t\t\tuint64_t *dst_len, void *tag, uint64_t *tag_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tsize_t dlen = 0;\n\tsize_t tlen = 0;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tif (cs->mode != TEE_MODE_ENCRYPT)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (!dst_len) {\n\t\tdlen = 0;\n\t} else {\n\t\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t\t  (uaddr_t)dst_data, dlen);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tres = get_user_u64_as_size_t(&tlen, tag_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)tag, tlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = crypto_authenc_enc_final(cs->ctx, cs->algo, src_data,\n\t\t\t\t       src_len, dst_data, &dlen, tag, &tlen);\n\nout:\n\tif (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {\n\t\tTEE_Result res2;\n\n\t\tif (dst_len != NULL) {\n\t\t\tres2 = put_user_u64(dst_len, dlen);\n\t\t\tif (res2 != TEE_SUCCESS)\n\t\t\t\treturn res2;\n\t\t}\n\n\t\tres2 = put_user_u64(tag_len, tlen);\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\treturn res2;\n\t}\n\n\treturn res;\n}\n\nTEE_Result syscall_authenc_dec_final(unsigned long state,\n\t\t\tconst void *src_data, size_t src_len, void *dst_data,\n\t\t\tuint64_t *dst_len, const void *tag, size_t tag_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tsize_t dlen = 0;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tif (cs->mode != TEE_MODE_DECRYPT)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (!dst_len) {\n\t\tdlen = 0;\n\t} else {\n\t\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t\t  (uaddr_t)dst_data, dlen);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)tag, tag_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = crypto_authenc_dec_final(cs->ctx, cs->algo, src_data, src_len,\n\t\t\t\t       dst_data, &dlen, tag, tag_len);\n\nout:\n\tif ((res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) &&\n\t    dst_len != NULL) {\n\t\tTEE_Result res2 = put_user_u64(dst_len, dlen);\n\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\treturn res2;\n\t}\n\n\treturn res;\n}\n\nstatic int pkcs1_get_salt_len(const TEE_Attribute *params, uint32_t num_params,\n\t\t\t      size_t default_len)\n{\n\tsize_t n;\n\n\tassert(default_len < INT_MAX);\n\n\tfor (n = 0; n < num_params; n++) {\n\t\tif (params[n].attributeID == TEE_ATTR_RSA_PSS_SALT_LENGTH) {\n\t\t\tif (params[n].content.value.a < INT_MAX)\n\t\t\t\treturn params[n].content.value.a;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * If salt length isn't provided use the default value which is\n\t * the length of the digest.\n\t */\n\treturn default_len;\n}\n\nTEE_Result syscall_asymm_operate(unsigned long state,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tsize_t num_params, const void *src_data, size_t src_len,\n\t\t\tvoid *dst_data, uint64_t *dst_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tsize_t dlen;\n\tstruct tee_obj *o;\n\tvoid *label = NULL;\n\tsize_t label_len = 0;\n\tsize_t n;\n\tint salt_len;\n\tTEE_Attribute *params = NULL;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(\n\t\tutc,\n\t\tTEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t(uaddr_t) src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(\n\t\tutc,\n\t\tTEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_WRITE |\n\t\t\tTEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t(uaddr_t) dst_data, dlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tsize_t alloc_size = 0;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), num_params, &alloc_size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tparams = malloc(alloc_size);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(utc, usr_params, num_params, params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_obj_get(utc, cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0) {\n\t\tres = TEE_ERROR_GENERIC;\n\t\tgoto out;\n\t}\n\n\tswitch (cs->algo) {\n\tcase TEE_ALG_RSA_NOPAD:\n\t\tif (cs->mode == TEE_MODE_ENCRYPT) {\n\t\t\tres = crypto_acipher_rsanopad_encrypt(o->attr, src_data,\n\t\t\t\t\t\t\t      src_len, dst_data,\n\t\t\t\t\t\t\t      &dlen);\n\t\t} else if (cs->mode == TEE_MODE_DECRYPT) {\n\t\t\tres = crypto_acipher_rsanopad_decrypt(o->attr, src_data,\n\t\t\t\t\t\t\t      src_len, dst_data,\n\t\t\t\t\t\t\t      &dlen);\n\t\t} else {\n\t\t\t/*\n\t\t\t * We will panic because \"the mode is not compatible\n\t\t\t * with the function\"\n\t\t\t */\n\t\t\tres = TEE_ERROR_GENERIC;\n\t\t}\n\t\tbreak;\n\n\tcase TEE_ALG_RSAES_PKCS1_V1_5:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512:\n\t\tfor (n = 0; n < num_params; n++) {\n\t\t\tif (params[n].attributeID == TEE_ATTR_RSA_OAEP_LABEL) {\n\t\t\t\tlabel = params[n].content.ref.buffer;\n\t\t\t\tlabel_len = params[n].content.ref.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (cs->mode == TEE_MODE_ENCRYPT) {\n\t\t\tres = crypto_acipher_rsaes_encrypt(cs->algo, o->attr,\n\t\t\t\t\t\t\t   label, label_len,\n\t\t\t\t\t\t\t   src_data, src_len,\n\t\t\t\t\t\t\t   dst_data, &dlen);\n\t\t} else if (cs->mode == TEE_MODE_DECRYPT) {\n\t\t\tres = crypto_acipher_rsaes_decrypt(\n\t\t\t\t\tcs->algo, o->attr, label, label_len,\n\t\t\t\t\tsrc_data, src_len, dst_data, &dlen);\n\t\t} else {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\t\tbreak;\n\n#if defined(CFG_CRYPTO_RSASSA_NA1)\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5:\n#endif\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_MD5:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA512:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512:\n\t\tif (cs->mode != TEE_MODE_SIGN) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tbreak;\n\t\t}\n\t\tsalt_len = pkcs1_get_salt_len(params, num_params, src_len);\n\t\tres = crypto_acipher_rsassa_sign(cs->algo, o->attr, salt_len,\n\t\t\t\t\t\t src_data, src_len, dst_data,\n\t\t\t\t\t\t &dlen);\n\t\tbreak;\n\n\tcase TEE_ALG_DSA_SHA1:\n\tcase TEE_ALG_DSA_SHA224:\n\tcase TEE_ALG_DSA_SHA256:\n\t\tres = crypto_acipher_dsa_sign(cs->algo, o->attr, src_data,\n\t\t\t\t\t      src_len, dst_data, &dlen);\n\t\tbreak;\n\tcase TEE_ALG_ECDSA_P192:\n\tcase TEE_ALG_ECDSA_P224:\n\tcase TEE_ALG_ECDSA_P256:\n\tcase TEE_ALG_ECDSA_P384:\n\tcase TEE_ALG_ECDSA_P521:\n\t\tres = crypto_acipher_ecc_sign(cs->algo, o->attr, src_data,\n\t\t\t\t\t      src_len, dst_data, &dlen);\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\t}\n\nout:\n\tfree_wipe(params);\n\n\tif (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {\n\t\tTEE_Result res2 = put_user_u64(dst_len, dlen);\n\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\treturn res2;\n\t}\n\n\treturn res;\n}\n\nTEE_Result syscall_asymm_verify(unsigned long state,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tsize_t num_params, const void *data, size_t data_len,\n\t\t\tconst void *sig, size_t sig_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tsize_t hash_size;\n\tint salt_len = 0;\n\tTEE_Attribute *params = NULL;\n\tuint32_t hash_algo;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->mode != TEE_MODE_VERIFY)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tres = tee_mmu_check_access_rights(utc,\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)data, data_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(utc,\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)sig, sig_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tsize_t alloc_size = 0;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), num_params, &alloc_size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tparams = malloc(alloc_size);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(utc, usr_params, num_params, params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_obj_get(utc, cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\tswitch (TEE_ALG_GET_MAIN_ALG(cs->algo)) {\n\tcase TEE_MAIN_ALGO_RSA:\n\t\tif (cs->algo != TEE_ALG_RSASSA_PKCS1_V1_5) {\n\t\t\thash_algo = TEE_DIGEST_HASH_TO_ALGO(cs->algo);\n\t\t\tres = tee_hash_get_digest_size(hash_algo, &hash_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t\tif (data_len != hash_size) {\n\t\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsalt_len = pkcs1_get_salt_len(params, num_params,\n\t\t\t\t\t\t      hash_size);\n\t\t}\n\t\tres = crypto_acipher_rsassa_verify(cs->algo, o->attr, salt_len,\n\t\t\t\t\t\t   data, data_len, sig,\n\t\t\t\t\t\t   sig_len);\n\t\tbreak;\n\n\tcase TEE_MAIN_ALGO_DSA:\n\t\thash_algo = TEE_DIGEST_HASH_TO_ALGO(cs->algo);\n\t\tres = tee_hash_get_digest_size(hash_algo, &hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tbreak;\n\t\t/*\n\t\t * Depending on the DSA algorithm (NIST), the digital signature\n\t\t * output size may be truncated to the size of a key pair\n\t\t * (Q prime size). Q prime size must be less or equal than the\n\t\t * hash output length of the hash algorithm involved.\n\t\t */\n\t\tif (data_len > hash_size) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tbreak;\n\t\t}\n\t\tres = crypto_acipher_dsa_verify(cs->algo, o->attr, data,\n\t\t\t\t\t\tdata_len, sig, sig_len);\n\t\tbreak;\n\n\tcase TEE_MAIN_ALGO_ECDSA:\n\t\tres = crypto_acipher_ecc_verify(cs->algo, o->attr, data,\n\t\t\t\t\t\tdata_len, sig, sig_len);\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t}\n\nout:\n\tfree_wipe(params);\n\treturn res;\n}\n"], "filenames": ["core/tee/tee_svc_cryp.c"], "buggy_code_start_loc": [33], "buggy_code_end_loc": [3185], "fixing_code_start_loc": [34], "fixing_code_end_loc": [3222], "type": "CWE-327", "message": "In Linaro OP-TEE before 3.7.0, by using inconsistent or malformed data, it is possible to call update and final cryptographic functions directly, causing a crash that could leak sensitive information.", "other": {"cve": {"id": "CVE-2019-25052", "sourceIdentifier": "cve@mitre.org", "published": "2021-08-11T15:15:07.187", "lastModified": "2021-08-19T18:16:00.863", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Linaro OP-TEE before 3.7.0, by using inconsistent or malformed data, it is possible to call update and final cryptographic functions directly, causing a crash that could leak sensitive information."}, {"lang": "es", "value": "En Linaro OP-TEE versiones anteriores a 3.7.0, al usar datos inconsistentes o malformados, es posible llamar a funciones criptogr\u00e1ficas de actualizaci\u00f3n y finalizaci\u00f3n directamente, causando un bloqueo que podr\u00eda filtrar informaci\u00f3n confidencial"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-327"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linaro:op-tee:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.7.0", "matchCriteriaId": "CD08B871-A65B-4AF1-9EF6-318E65B4F7BB"}]}]}], "references": [{"url": "https://github.com/OP-TEE/optee_os/commit/34a08bec755670ea0490cb53bbc68058cafc69b6", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/OP-TEE/optee_os/security/advisories/GHSA-pgwr-qmgh-vhmf", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/OP-TEE/optee_os/commit/34a08bec755670ea0490cb53bbc68058cafc69b6"}}