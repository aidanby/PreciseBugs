{"buggy_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Graphical Objects\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2016 Armin Novak <armin.novak@thincast.com>\n * Copyright 2016 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n\n#include <freerdp/log.h>\n#include <freerdp/gdi/dc.h>\n#include <freerdp/gdi/shape.h>\n#include <freerdp/gdi/region.h>\n#include <freerdp/gdi/bitmap.h>\n\n#include \"clipping.h\"\n#include \"drawing.h\"\n#include \"brush.h\"\n#include \"graphics.h\"\n\n#define TAG FREERDP_TAG(\"gdi\")\n/* Bitmap Class */\n\nHGDI_BITMAP gdi_create_bitmap(rdpGdi* gdi, UINT32 nWidth, UINT32 nHeight,\n                              UINT32 SrcFormat, BYTE* data)\n{\n\tUINT32 nSrcStep;\n\tUINT32 nDstStep;\n\tBYTE* pSrcData;\n\tBYTE* pDstData;\n\tHGDI_BITMAP bitmap;\n\n\tif (!gdi)\n\t\treturn NULL;\n\n\tnDstStep = nWidth * GetBytesPerPixel(gdi->dstFormat);\n\tpDstData = _aligned_malloc(nHeight * nDstStep, 16);\n\n\tif (!pDstData)\n\t\treturn NULL;\n\n\tpSrcData = data;\n\tnSrcStep = nWidth * GetBytesPerPixel(SrcFormat);\n\n\tif (!freerdp_image_copy(pDstData, gdi->dstFormat, nDstStep, 0, 0,\n\t                        nWidth, nHeight, pSrcData, SrcFormat, nSrcStep, 0, 0,\n\t                        &gdi->palette, FREERDP_FLIP_NONE))\n\t{\n\t\t_aligned_free(pDstData);\n\t\treturn NULL;\n\t}\n\n\tbitmap = gdi_CreateBitmap(nWidth, nHeight, gdi->dstFormat, pDstData);\n\treturn bitmap;\n}\n\nstatic BOOL gdi_Bitmap_New(rdpContext* context, rdpBitmap* bitmap)\n{\n\tgdiBitmap* gdi_bitmap;\n\trdpGdi* gdi = context->gdi;\n\tgdi_bitmap = (gdiBitmap*) bitmap;\n\tgdi_bitmap->hdc = gdi_CreateCompatibleDC(gdi->hdc);\n\n\tif (!gdi_bitmap->hdc)\n\t\treturn FALSE;\n\n\tif (!bitmap->data)\n\t\tgdi_bitmap->bitmap = gdi_CreateCompatibleBitmap(\n\t\t                         gdi->hdc, bitmap->width,\n\t\t                         bitmap->height);\n\telse\n\t{\n\t\tUINT32 format = bitmap->format;\n\t\tgdi_bitmap->bitmap = gdi_create_bitmap(gdi, bitmap->width,\n\t\t                                       bitmap->height,\n\t\t                                       format, bitmap->data);\n\t}\n\n\tif (!gdi_bitmap->bitmap)\n\t{\n\t\tgdi_DeleteDC(gdi_bitmap->hdc);\n\t\treturn FALSE;\n\t}\n\n\tgdi_bitmap->hdc->format = gdi_bitmap->bitmap->format;\n\tgdi_SelectObject(gdi_bitmap->hdc, (HGDIOBJECT) gdi_bitmap->bitmap);\n\tgdi_bitmap->org_bitmap = NULL;\n\treturn TRUE;\n}\n\nstatic void gdi_Bitmap_Free(rdpContext* context, rdpBitmap* bitmap)\n{\n\tgdiBitmap* gdi_bitmap = (gdiBitmap*) bitmap;\n\n\tif (gdi_bitmap)\n\t{\n\t\tif (gdi_bitmap->hdc)\n\t\t\tgdi_SelectObject(gdi_bitmap->hdc, (HGDIOBJECT) gdi_bitmap->org_bitmap);\n\n\t\tgdi_DeleteObject((HGDIOBJECT) gdi_bitmap->bitmap);\n\t\tgdi_DeleteDC(gdi_bitmap->hdc);\n\t\t_aligned_free(bitmap->data);\n\t}\n\n\tfree(bitmap);\n}\n\nstatic BOOL gdi_Bitmap_Paint(rdpContext* context, rdpBitmap* bitmap)\n{\n\tgdiBitmap* gdi_bitmap = (gdiBitmap*) bitmap;\n\tUINT32 width = bitmap->right - bitmap->left + 1;\n\tUINT32 height = bitmap->bottom - bitmap->top + 1;\n\treturn gdi_BitBlt(context->gdi->primary->hdc,\n\t                  bitmap->left, bitmap->top,\n\t                  width, height, gdi_bitmap->hdc,\n\t                  0, 0, GDI_SRCCOPY, &context->gdi->palette);\n}\n\nstatic BOOL gdi_Bitmap_Decompress(rdpContext* context, rdpBitmap* bitmap,\n                                  const BYTE* pSrcData, UINT32 DstWidth, UINT32 DstHeight,\n                                  UINT32 bpp, UINT32 length, BOOL compressed,\n                                  UINT32 codecId)\n{\n\tUINT32 SrcSize = length;\n\trdpGdi* gdi = context->gdi;\n\tbitmap->compressed = FALSE;\n\tbitmap->format = gdi->dstFormat;\n\tbitmap->length = DstWidth * DstHeight * GetBytesPerPixel(bitmap->format);\n\tbitmap->data = (BYTE*) _aligned_malloc(bitmap->length, 16);\n\n\tif (!bitmap->data)\n\t\treturn FALSE;\n\n\tif (compressed)\n\t{\n\t\tif (bpp < 32)\n\t\t{\n\t\t\tif (!interleaved_decompress(context->codecs->interleaved,\n\t\t\t                            pSrcData, SrcSize,\n\t\t\t                            DstWidth, DstHeight,\n\t\t\t                            bpp,\n\t\t\t                            bitmap->data, bitmap->format,\n\t\t\t                            0, 0, 0, DstWidth, DstHeight,\n\t\t\t                            &gdi->palette))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!planar_decompress(context->codecs->planar, pSrcData, SrcSize,\n\t\t\t                       DstWidth, DstHeight,\n\t\t\t                       bitmap->data, bitmap->format, 0, 0, 0,\n\t\t\t                       DstWidth, DstHeight, TRUE))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tconst UINT32 SrcFormat = gdi_get_pixel_format(bpp);\n\t\tconst size_t sbpp = GetBytesPerPixel(SrcFormat);\n\t\tconst size_t dbpp = GetBytesPerPixel(bitmap->format);\n\n\t\tif ((sbpp == 0) || (dbpp == 0))\n\t\t\treturn FALSE;\n\t\telse\n\t\t{\n\t\t\tconst size_t dstSize = SrcSize * dbpp / sbpp;\n\n\t\t\tif (dstSize  < bitmap->length)\n\t\t\t\treturn FALSE;\n\t\t}\n\n\t\tif (!freerdp_image_copy(bitmap->data, bitmap->format, 0, 0, 0,\n\t\t                        DstWidth, DstHeight, pSrcData, SrcFormat,\n\t\t                        0, 0, 0, &gdi->palette, FREERDP_FLIP_VERTICAL))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL gdi_Bitmap_SetSurface(rdpContext* context, rdpBitmap* bitmap,\n                                  BOOL primary)\n{\n\trdpGdi* gdi;\n\n\tif (!context)\n\t\treturn FALSE;\n\n\tgdi = context->gdi;\n\n\tif (!gdi)\n\t\treturn FALSE;\n\n\tif (primary)\n\t\tgdi->drawing = gdi->primary;\n\telse\n\t\tgdi->drawing = (gdiBitmap*) bitmap;\n\n\treturn TRUE;\n}\n\n/* Glyph Class */\nstatic BOOL gdi_Glyph_New(rdpContext* context, const rdpGlyph* glyph)\n{\n\tBYTE* data;\n\tgdiGlyph* gdi_glyph;\n\n\tif (!context || !glyph)\n\t\treturn FALSE;\n\n\tgdi_glyph = (gdiGlyph*) glyph;\n\tgdi_glyph->hdc = gdi_GetDC();\n\n\tif (!gdi_glyph->hdc)\n\t\treturn FALSE;\n\n\tgdi_glyph->hdc->format = PIXEL_FORMAT_MONO;\n\tdata = freerdp_glyph_convert(glyph->cx, glyph->cy, glyph->aj);\n\n\tif (!data)\n\t{\n\t\tgdi_DeleteDC(gdi_glyph->hdc);\n\t\treturn FALSE;\n\t}\n\n\tgdi_glyph->bitmap = gdi_CreateBitmap(glyph->cx, glyph->cy, PIXEL_FORMAT_MONO,\n\t                                     data);\n\n\tif (!gdi_glyph->bitmap)\n\t{\n\t\tgdi_DeleteDC(gdi_glyph->hdc);\n\t\t_aligned_free(data);\n\t\treturn FALSE;\n\t}\n\n\tgdi_SelectObject(gdi_glyph->hdc, (HGDIOBJECT) gdi_glyph->bitmap);\n\tgdi_glyph->org_bitmap = NULL;\n\treturn TRUE;\n}\n\nstatic void gdi_Glyph_Free(rdpContext* context, rdpGlyph* glyph)\n{\n\tgdiGlyph* gdi_glyph;\n\tgdi_glyph = (gdiGlyph*) glyph;\n\n\tif (gdi_glyph)\n\t{\n\t\tgdi_SelectObject(gdi_glyph->hdc, (HGDIOBJECT) gdi_glyph->org_bitmap);\n\t\tgdi_DeleteObject((HGDIOBJECT) gdi_glyph->bitmap);\n\t\tgdi_DeleteDC(gdi_glyph->hdc);\n\t\tfree(glyph->aj);\n\t\tfree(glyph);\n\t}\n}\n\nstatic BOOL gdi_Glyph_Draw(rdpContext* context, const rdpGlyph* glyph, INT32 x,\n                           INT32 y, INT32 w, INT32 h, INT32 sx, INT32 sy, BOOL fOpRedundant)\n{\n\tgdiGlyph* gdi_glyph;\n\trdpGdi* gdi;\n\tHGDI_BRUSH brush;\n\tBOOL rc = FALSE;\n\n\tif (!context || !glyph)\n\t\treturn FALSE;\n\n\tgdi = context->gdi;\n\tgdi_glyph = (gdiGlyph*) glyph;\n\n\tif (!fOpRedundant && 0)\n\t{\n\t\tGDI_RECT rect = { 0 };\n\n\t\tif (x > 0)\n\t\t\trect.left = x;\n\n\t\tif (y > 0)\n\t\t\trect.top = y;\n\n\t\tif (x + w > 0)\n\t\t\trect.right = x + w - 1;\n\n\t\tif (y + h > 0)\n\t\t\trect.bottom = y + h - 1;\n\n\t\tif ((rect.left < rect.right) && (rect.top < rect.bottom))\n\t\t{\n\t\t\tbrush = gdi_CreateSolidBrush(gdi->drawing->hdc->bkColor);\n\n\t\t\tif (!brush)\n\t\t\t\treturn FALSE;\n\n\t\t\tgdi_FillRect(gdi->drawing->hdc, &rect, brush);\n\t\t\tgdi_DeleteObject((HGDIOBJECT)brush);\n\t\t}\n\t}\n\n\tbrush = gdi_CreateSolidBrush(gdi->drawing->hdc->textColor);\n\n\tif (!brush)\n\t\treturn FALSE;\n\n\tgdi_SelectObject(gdi->drawing->hdc, (HGDIOBJECT)brush);\n\trc = gdi_BitBlt(gdi->drawing->hdc, x, y, w, h, gdi_glyph->hdc, sx, sy,\n\t                GDI_GLYPH_ORDER, &context->gdi->palette);\n\tgdi_DeleteObject((HGDIOBJECT)brush);\n\treturn rc;\n}\n\nstatic BOOL gdi_Glyph_SetBounds(rdpContext* context, INT32 x, INT32 y, INT32 width, INT32 height)\n{\n\trdpGdi* gdi;\n\n\tif (!context || !context->gdi)\n\t\treturn FALSE;\n\n\tgdi = context->gdi;\n\n\tif (!gdi->drawing || !gdi->drawing->hdc)\n\t\treturn FALSE;\n\n\treturn gdi_SetClipRgn(gdi->drawing->hdc, x, y, width, height);\n}\n\nstatic BOOL gdi_Glyph_BeginDraw(rdpContext* context, INT32 x, INT32 y,\n                                INT32 width, INT32 height, UINT32 bgcolor,\n                                UINT32 fgcolor, BOOL fOpRedundant)\n{\n\trdpGdi* gdi;\n\n\tif (!context || !context->gdi)\n\t\treturn FALSE;\n\n\tgdi = context->gdi;\n\n\tif (!gdi->drawing || !gdi->drawing->hdc)\n\t\treturn FALSE;\n\n\tif (!fOpRedundant)\n\t{\n\t\tif (!gdi_decode_color(gdi, bgcolor, &bgcolor, NULL))\n\t\t\treturn FALSE;\n\n\t\tif (!gdi_decode_color(gdi, fgcolor, &fgcolor, NULL))\n\t\t\treturn FALSE;\n\n\t\tgdi_SetClipRgn(gdi->drawing->hdc, x, y, width, height);\n\t\tgdi_SetTextColor(gdi->drawing->hdc, bgcolor);\n\t\tgdi_SetBkColor(gdi->drawing->hdc, fgcolor);\n\n\t\tif (1)\n\t\t{\n\t\t\tGDI_RECT rect = { 0 };\n\t\t\tHGDI_BRUSH brush = gdi_CreateSolidBrush(fgcolor);\n\n\t\t\tif (!brush)\n\t\t\t\treturn FALSE;\n\n\t\t\tif (x > 0)\n\t\t\t\trect.left = x;\n\n\t\t\tif (y > 0)\n\t\t\t\trect.top = y;\n\n\t\t\trect.right = x + width - 1;\n\t\t\trect.bottom = y + height - 1;\n\n\t\t\tif ((x + width > rect.left) && (y + height > rect.top))\n\t\t\t\tgdi_FillRect(gdi->drawing->hdc, &rect, brush);\n\n\t\t\tgdi_DeleteObject((HGDIOBJECT)brush);\n\t\t}\n\n\t\treturn gdi_SetNullClipRgn(gdi->drawing->hdc);\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL gdi_Glyph_EndDraw(rdpContext* context, INT32 x, INT32 y,\n                              INT32 width, INT32 height, UINT32 bgcolor, UINT32 fgcolor)\n{\n\trdpGdi* gdi;\n\n\tif (!context || !context->gdi)\n\t\treturn FALSE;\n\n\tgdi = context->gdi;\n\n\tif (!gdi->drawing || !gdi->drawing->hdc)\n\t\treturn FALSE;\n\n\tgdi_SetNullClipRgn(gdi->drawing->hdc);\n\treturn TRUE;\n}\n\n/* Graphics Module */\nBOOL gdi_register_graphics(rdpGraphics* graphics)\n{\n\trdpBitmap bitmap;\n\trdpGlyph glyph;\n\tbitmap.size = sizeof(gdiBitmap);\n\tbitmap.New = gdi_Bitmap_New;\n\tbitmap.Free = gdi_Bitmap_Free;\n\tbitmap.Paint = gdi_Bitmap_Paint;\n\tbitmap.Decompress = gdi_Bitmap_Decompress;\n\tbitmap.SetSurface = gdi_Bitmap_SetSurface;\n\tgraphics_register_bitmap(graphics, &bitmap);\n\tglyph.size = sizeof(gdiGlyph);\n\tglyph.New = gdi_Glyph_New;\n\tglyph.Free = gdi_Glyph_Free;\n\tglyph.Draw = gdi_Glyph_Draw;\n\tglyph.BeginDraw = gdi_Glyph_BeginDraw;\n\tglyph.EndDraw = gdi_Glyph_EndDraw;\n\tglyph.SetBounds = gdi_Glyph_SetBounds;\n\tgraphics_register_glyph(graphics, &glyph);\n\treturn TRUE;\n}\n"], "fixing_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Graphical Objects\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2016 Armin Novak <armin.novak@thincast.com>\n * Copyright 2016 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n\n#include <freerdp/log.h>\n#include <freerdp/gdi/dc.h>\n#include <freerdp/gdi/shape.h>\n#include <freerdp/gdi/region.h>\n#include <freerdp/gdi/bitmap.h>\n\n#include \"clipping.h\"\n#include \"drawing.h\"\n#include \"brush.h\"\n#include \"graphics.h\"\n\n#define TAG FREERDP_TAG(\"gdi\")\n/* Bitmap Class */\n\nHGDI_BITMAP gdi_create_bitmap(rdpGdi* gdi, UINT32 nWidth, UINT32 nHeight,\n                              UINT32 SrcFormat, BYTE* data)\n{\n\tUINT32 nSrcStep;\n\tUINT32 nDstStep;\n\tBYTE* pSrcData;\n\tBYTE* pDstData;\n\tHGDI_BITMAP bitmap;\n\n\tif (!gdi)\n\t\treturn NULL;\n\n\tnDstStep = nWidth * GetBytesPerPixel(gdi->dstFormat);\n\tpDstData = _aligned_malloc(nHeight * nDstStep, 16);\n\n\tif (!pDstData)\n\t\treturn NULL;\n\n\tpSrcData = data;\n\tnSrcStep = nWidth * GetBytesPerPixel(SrcFormat);\n\n\tif (!freerdp_image_copy(pDstData, gdi->dstFormat, nDstStep, 0, 0,\n\t                        nWidth, nHeight, pSrcData, SrcFormat, nSrcStep, 0, 0,\n\t                        &gdi->palette, FREERDP_FLIP_NONE))\n\t{\n\t\t_aligned_free(pDstData);\n\t\treturn NULL;\n\t}\n\n\tbitmap = gdi_CreateBitmap(nWidth, nHeight, gdi->dstFormat, pDstData);\n\treturn bitmap;\n}\n\nstatic BOOL gdi_Bitmap_New(rdpContext* context, rdpBitmap* bitmap)\n{\n\tgdiBitmap* gdi_bitmap;\n\trdpGdi* gdi = context->gdi;\n\tgdi_bitmap = (gdiBitmap*) bitmap;\n\tgdi_bitmap->hdc = gdi_CreateCompatibleDC(gdi->hdc);\n\n\tif (!gdi_bitmap->hdc)\n\t\treturn FALSE;\n\n\tif (!bitmap->data)\n\t\tgdi_bitmap->bitmap = gdi_CreateCompatibleBitmap(\n\t\t                         gdi->hdc, bitmap->width,\n\t\t                         bitmap->height);\n\telse\n\t{\n\t\tUINT32 format = bitmap->format;\n\t\tgdi_bitmap->bitmap = gdi_create_bitmap(gdi, bitmap->width,\n\t\t                                       bitmap->height,\n\t\t                                       format, bitmap->data);\n\t}\n\n\tif (!gdi_bitmap->bitmap)\n\t{\n\t\tgdi_DeleteDC(gdi_bitmap->hdc);\n\t\treturn FALSE;\n\t}\n\n\tgdi_bitmap->hdc->format = gdi_bitmap->bitmap->format;\n\tgdi_SelectObject(gdi_bitmap->hdc, (HGDIOBJECT) gdi_bitmap->bitmap);\n\tgdi_bitmap->org_bitmap = NULL;\n\treturn TRUE;\n}\n\nstatic void gdi_Bitmap_Free(rdpContext* context, rdpBitmap* bitmap)\n{\n\tgdiBitmap* gdi_bitmap = (gdiBitmap*) bitmap;\n\n\tif (gdi_bitmap)\n\t{\n\t\tif (gdi_bitmap->hdc)\n\t\t\tgdi_SelectObject(gdi_bitmap->hdc, (HGDIOBJECT) gdi_bitmap->org_bitmap);\n\n\t\tgdi_DeleteObject((HGDIOBJECT) gdi_bitmap->bitmap);\n\t\tgdi_DeleteDC(gdi_bitmap->hdc);\n\t\t_aligned_free(bitmap->data);\n\t}\n\n\tfree(bitmap);\n}\n\nstatic BOOL gdi_Bitmap_Paint(rdpContext* context, rdpBitmap* bitmap)\n{\n\tgdiBitmap* gdi_bitmap = (gdiBitmap*) bitmap;\n\tUINT32 width = bitmap->right - bitmap->left + 1;\n\tUINT32 height = bitmap->bottom - bitmap->top + 1;\n\treturn gdi_BitBlt(context->gdi->primary->hdc,\n\t                  bitmap->left, bitmap->top,\n\t                  width, height, gdi_bitmap->hdc,\n\t                  0, 0, GDI_SRCCOPY, &context->gdi->palette);\n}\n\nstatic BOOL gdi_Bitmap_Decompress(rdpContext* context, rdpBitmap* bitmap,\n                                  const BYTE* pSrcData, UINT32 DstWidth, UINT32 DstHeight,\n                                  UINT32 bpp, UINT32 length, BOOL compressed,\n                                  UINT32 codecId)\n{\n\tUINT32 SrcSize = length;\n\trdpGdi* gdi = context->gdi;\n\tUINT32 size = DstWidth * DstHeight;\n\tbitmap->compressed = FALSE;\n\tbitmap->format = gdi->dstFormat;\n\n\tif ((GetBytesPerPixel(bitmap->format) == 0) ||\n\t    (DstWidth == 0) || (DstHeight == 0) || (DstWidth > UINT32_MAX / DstHeight) ||\n\t    (size > (UINT32_MAX / GetBytesPerPixel(bitmap->format))))\n\t\treturn FALSE;\n\n\tsize *= GetBytesPerPixel(bitmap->format);\n\tbitmap->length = size;\n\tbitmap->data = (BYTE*) _aligned_malloc(bitmap->length, 16);\n\n\tif (!bitmap->data)\n\t\treturn FALSE;\n\n\tif (compressed)\n\t{\n\t\tif (bpp < 32)\n\t\t{\n\t\t\tif (!interleaved_decompress(context->codecs->interleaved,\n\t\t\t                            pSrcData, SrcSize,\n\t\t\t                            DstWidth, DstHeight,\n\t\t\t                            bpp,\n\t\t\t                            bitmap->data, bitmap->format,\n\t\t\t                            0, 0, 0, DstWidth, DstHeight,\n\t\t\t                            &gdi->palette))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!planar_decompress(context->codecs->planar, pSrcData, SrcSize,\n\t\t\t                       DstWidth, DstHeight,\n\t\t\t                       bitmap->data, bitmap->format, 0, 0, 0,\n\t\t\t                       DstWidth, DstHeight, TRUE))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tconst UINT32 SrcFormat = gdi_get_pixel_format(bpp);\n\t\tconst size_t sbpp = GetBytesPerPixel(SrcFormat);\n\t\tconst size_t dbpp = GetBytesPerPixel(bitmap->format);\n\n\t\tif ((sbpp == 0) || (dbpp == 0))\n\t\t\treturn FALSE;\n\t\telse\n\t\t{\n\t\t\tconst size_t dstSize = SrcSize * dbpp / sbpp;\n\n\t\t\tif (dstSize  < bitmap->length)\n\t\t\t\treturn FALSE;\n\t\t}\n\n\t\tif (!freerdp_image_copy(bitmap->data, bitmap->format, 0, 0, 0,\n\t\t                        DstWidth, DstHeight, pSrcData, SrcFormat,\n\t\t                        0, 0, 0, &gdi->palette, FREERDP_FLIP_VERTICAL))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL gdi_Bitmap_SetSurface(rdpContext* context, rdpBitmap* bitmap,\n                                  BOOL primary)\n{\n\trdpGdi* gdi;\n\n\tif (!context)\n\t\treturn FALSE;\n\n\tgdi = context->gdi;\n\n\tif (!gdi)\n\t\treturn FALSE;\n\n\tif (primary)\n\t\tgdi->drawing = gdi->primary;\n\telse\n\t\tgdi->drawing = (gdiBitmap*) bitmap;\n\n\treturn TRUE;\n}\n\n/* Glyph Class */\nstatic BOOL gdi_Glyph_New(rdpContext* context, const rdpGlyph* glyph)\n{\n\tBYTE* data;\n\tgdiGlyph* gdi_glyph;\n\n\tif (!context || !glyph)\n\t\treturn FALSE;\n\n\tgdi_glyph = (gdiGlyph*) glyph;\n\tgdi_glyph->hdc = gdi_GetDC();\n\n\tif (!gdi_glyph->hdc)\n\t\treturn FALSE;\n\n\tgdi_glyph->hdc->format = PIXEL_FORMAT_MONO;\n\tdata = freerdp_glyph_convert(glyph->cx, glyph->cy, glyph->aj);\n\n\tif (!data)\n\t{\n\t\tgdi_DeleteDC(gdi_glyph->hdc);\n\t\treturn FALSE;\n\t}\n\n\tgdi_glyph->bitmap = gdi_CreateBitmap(glyph->cx, glyph->cy, PIXEL_FORMAT_MONO,\n\t                                     data);\n\n\tif (!gdi_glyph->bitmap)\n\t{\n\t\tgdi_DeleteDC(gdi_glyph->hdc);\n\t\t_aligned_free(data);\n\t\treturn FALSE;\n\t}\n\n\tgdi_SelectObject(gdi_glyph->hdc, (HGDIOBJECT) gdi_glyph->bitmap);\n\tgdi_glyph->org_bitmap = NULL;\n\treturn TRUE;\n}\n\nstatic void gdi_Glyph_Free(rdpContext* context, rdpGlyph* glyph)\n{\n\tgdiGlyph* gdi_glyph;\n\tgdi_glyph = (gdiGlyph*) glyph;\n\n\tif (gdi_glyph)\n\t{\n\t\tgdi_SelectObject(gdi_glyph->hdc, (HGDIOBJECT) gdi_glyph->org_bitmap);\n\t\tgdi_DeleteObject((HGDIOBJECT) gdi_glyph->bitmap);\n\t\tgdi_DeleteDC(gdi_glyph->hdc);\n\t\tfree(glyph->aj);\n\t\tfree(glyph);\n\t}\n}\n\nstatic BOOL gdi_Glyph_Draw(rdpContext* context, const rdpGlyph* glyph, INT32 x,\n                           INT32 y, INT32 w, INT32 h, INT32 sx, INT32 sy, BOOL fOpRedundant)\n{\n\tgdiGlyph* gdi_glyph;\n\trdpGdi* gdi;\n\tHGDI_BRUSH brush;\n\tBOOL rc = FALSE;\n\n\tif (!context || !glyph)\n\t\treturn FALSE;\n\n\tgdi = context->gdi;\n\tgdi_glyph = (gdiGlyph*) glyph;\n\n\tif (!fOpRedundant && 0)\n\t{\n\t\tGDI_RECT rect = { 0 };\n\n\t\tif (x > 0)\n\t\t\trect.left = x;\n\n\t\tif (y > 0)\n\t\t\trect.top = y;\n\n\t\tif (x + w > 0)\n\t\t\trect.right = x + w - 1;\n\n\t\tif (y + h > 0)\n\t\t\trect.bottom = y + h - 1;\n\n\t\tif ((rect.left < rect.right) && (rect.top < rect.bottom))\n\t\t{\n\t\t\tbrush = gdi_CreateSolidBrush(gdi->drawing->hdc->bkColor);\n\n\t\t\tif (!brush)\n\t\t\t\treturn FALSE;\n\n\t\t\tgdi_FillRect(gdi->drawing->hdc, &rect, brush);\n\t\t\tgdi_DeleteObject((HGDIOBJECT)brush);\n\t\t}\n\t}\n\n\tbrush = gdi_CreateSolidBrush(gdi->drawing->hdc->textColor);\n\n\tif (!brush)\n\t\treturn FALSE;\n\n\tgdi_SelectObject(gdi->drawing->hdc, (HGDIOBJECT)brush);\n\trc = gdi_BitBlt(gdi->drawing->hdc, x, y, w, h, gdi_glyph->hdc, sx, sy,\n\t                GDI_GLYPH_ORDER, &context->gdi->palette);\n\tgdi_DeleteObject((HGDIOBJECT)brush);\n\treturn rc;\n}\n\nstatic BOOL gdi_Glyph_SetBounds(rdpContext* context, INT32 x, INT32 y, INT32 width, INT32 height)\n{\n\trdpGdi* gdi;\n\n\tif (!context || !context->gdi)\n\t\treturn FALSE;\n\n\tgdi = context->gdi;\n\n\tif (!gdi->drawing || !gdi->drawing->hdc)\n\t\treturn FALSE;\n\n\treturn gdi_SetClipRgn(gdi->drawing->hdc, x, y, width, height);\n}\n\nstatic BOOL gdi_Glyph_BeginDraw(rdpContext* context, INT32 x, INT32 y,\n                                INT32 width, INT32 height, UINT32 bgcolor,\n                                UINT32 fgcolor, BOOL fOpRedundant)\n{\n\trdpGdi* gdi;\n\n\tif (!context || !context->gdi)\n\t\treturn FALSE;\n\n\tgdi = context->gdi;\n\n\tif (!gdi->drawing || !gdi->drawing->hdc)\n\t\treturn FALSE;\n\n\tif (!fOpRedundant)\n\t{\n\t\tif (!gdi_decode_color(gdi, bgcolor, &bgcolor, NULL))\n\t\t\treturn FALSE;\n\n\t\tif (!gdi_decode_color(gdi, fgcolor, &fgcolor, NULL))\n\t\t\treturn FALSE;\n\n\t\tgdi_SetClipRgn(gdi->drawing->hdc, x, y, width, height);\n\t\tgdi_SetTextColor(gdi->drawing->hdc, bgcolor);\n\t\tgdi_SetBkColor(gdi->drawing->hdc, fgcolor);\n\n\t\tif (1)\n\t\t{\n\t\t\tGDI_RECT rect = { 0 };\n\t\t\tHGDI_BRUSH brush = gdi_CreateSolidBrush(fgcolor);\n\n\t\t\tif (!brush)\n\t\t\t\treturn FALSE;\n\n\t\t\tif (x > 0)\n\t\t\t\trect.left = x;\n\n\t\t\tif (y > 0)\n\t\t\t\trect.top = y;\n\n\t\t\trect.right = x + width - 1;\n\t\t\trect.bottom = y + height - 1;\n\n\t\t\tif ((x + width > rect.left) && (y + height > rect.top))\n\t\t\t\tgdi_FillRect(gdi->drawing->hdc, &rect, brush);\n\n\t\t\tgdi_DeleteObject((HGDIOBJECT)brush);\n\t\t}\n\n\t\treturn gdi_SetNullClipRgn(gdi->drawing->hdc);\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL gdi_Glyph_EndDraw(rdpContext* context, INT32 x, INT32 y,\n                              INT32 width, INT32 height, UINT32 bgcolor, UINT32 fgcolor)\n{\n\trdpGdi* gdi;\n\n\tif (!context || !context->gdi)\n\t\treturn FALSE;\n\n\tgdi = context->gdi;\n\n\tif (!gdi->drawing || !gdi->drawing->hdc)\n\t\treturn FALSE;\n\n\tgdi_SetNullClipRgn(gdi->drawing->hdc);\n\treturn TRUE;\n}\n\n/* Graphics Module */\nBOOL gdi_register_graphics(rdpGraphics* graphics)\n{\n\trdpBitmap bitmap;\n\trdpGlyph glyph;\n\tbitmap.size = sizeof(gdiBitmap);\n\tbitmap.New = gdi_Bitmap_New;\n\tbitmap.Free = gdi_Bitmap_Free;\n\tbitmap.Paint = gdi_Bitmap_Paint;\n\tbitmap.Decompress = gdi_Bitmap_Decompress;\n\tbitmap.SetSurface = gdi_Bitmap_SetSurface;\n\tgraphics_register_bitmap(graphics, &bitmap);\n\tglyph.size = sizeof(gdiGlyph);\n\tglyph.New = gdi_Glyph_New;\n\tglyph.Free = gdi_Glyph_Free;\n\tglyph.Draw = gdi_Glyph_Draw;\n\tglyph.BeginDraw = gdi_Glyph_BeginDraw;\n\tglyph.EndDraw = gdi_Glyph_EndDraw;\n\tglyph.SetBounds = gdi_Glyph_SetBounds;\n\tgraphics_register_glyph(graphics, &glyph);\n\treturn TRUE;\n}\n"], "filenames": ["libfreerdp/gdi/graphics.c"], "buggy_code_start_loc": [143], "buggy_code_end_loc": [147], "fixing_code_start_loc": [144], "fixing_code_end_loc": [155], "type": "CWE-190", "message": "FreeRDP prior to version 2.0.0-rc4 contains an Integer Overflow that leads to a Heap-Based Buffer Overflow in function gdi_Bitmap_Decompress() and results in a memory corruption and probably even a remote code execution.", "other": {"cve": {"id": "CVE-2018-8787", "sourceIdentifier": "cve@checkpoint.com", "published": "2018-11-29T18:29:00.943", "lastModified": "2020-09-29T02:01:55.530", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "FreeRDP prior to version 2.0.0-rc4 contains an Integer Overflow that leads to a Heap-Based Buffer Overflow in function gdi_Bitmap_Decompress() and results in a memory corruption and probably even a remote code execution."}, {"lang": "es", "value": "FreeRDP en versiones anteriores a la 2.0.0-rc4 contiene un desbordamiento de enteros que conduce a un desbordamiento de b\u00fafer basado en memoria din\u00e1mica (heap) en la funci\u00f3n gdi_Bitmap_Decompress() y que resulta en una corrupci\u00f3n de memoria y, probablemente, incluso en la ejecuci\u00f3n remota de c\u00f3digo."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}, {"lang": "en", "value": "CWE-787"}]}, {"source": "cve@checkpoint.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-680"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.2.0", "matchCriteriaId": "FB13905B-B0E9-443E-B150-9D64E20DC464"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:2.0.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "F226993C-3AB8-4F86-8591-40CAAC8DD73E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:2.0.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "985D90BF-3B2B-4A3C-B698-DBCB0241B95B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:2.0.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "7C4656D2-EEC4-4871-BA0F-76F760526B1B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "5BF3C7A5-9117-42C7-BEA1-4AA378A582EF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B353CE99-D57C-465B-AAB0-73EF581127D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B76AA310-FEC7-497F-AF04-C3EC1E76C4CC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/106938", "source": "cve@checkpoint.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:0697", "source": "cve@checkpoint.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/commit/09b9d4f1994a674c4ec85b4947aa656eda1aed8a", "source": "cve@checkpoint.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/02/msg00015.html", "source": "cve@checkpoint.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://research.checkpoint.com/reverse-rdp-attack-code-execution-on-rdp-clients/", "source": "cve@checkpoint.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3845-1/", "source": "cve@checkpoint.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3845-2/", "source": "cve@checkpoint.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FreeRDP/FreeRDP/commit/09b9d4f1994a674c4ec85b4947aa656eda1aed8a"}}