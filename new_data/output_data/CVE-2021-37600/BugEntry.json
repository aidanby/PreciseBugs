{"buggy_code": ["#include <inttypes.h>\n\n#include \"c.h\"\n#include \"nls.h\"\n#include \"xalloc.h\"\n#include \"path.h\"\n#include \"pathnames.h\"\n#include \"ipcutils.h\"\n#include \"strutils.h\"\n\n#ifndef SEMVMX\n# define SEMVMX  32767\t/* <= 32767 semaphore maximum value */\n#endif\n#ifndef SHMMIN\n# define SHMMIN 1\t/* min shared segment size in bytes */\n#endif\n\n\nint ipc_msg_get_limits(struct ipc_limits *lim)\n{\n\tif (access(_PATH_PROC_IPC_MSGMNI, F_OK) == 0 &&\n\t    access(_PATH_PROC_IPC_MSGMNB, F_OK) == 0 &&\n\t    access(_PATH_PROC_IPC_MSGMAX, F_OK) == 0) {\n\n\t\tif (ul_path_read_s32(NULL, &lim->msgmni, _PATH_PROC_IPC_MSGMNI) != 0)\n\t\t\treturn 1;\n\t\tif (ul_path_read_s32(NULL, &lim->msgmnb, _PATH_PROC_IPC_MSGMNB) != 0)\n\t\t\treturn 1;\n\t\tif (ul_path_read_u64(NULL, &lim->msgmax, _PATH_PROC_IPC_MSGMAX) != 0)\n\t\t\treturn 1;\n\t} else {\n\t\tstruct msginfo msginfo;\n\n\t\tif (msgctl(0, IPC_INFO, (struct msqid_ds *) &msginfo) < 0)\n\t\t\treturn 1;\n\t\tlim->msgmni = msginfo.msgmni;\n\t\tlim->msgmnb = msginfo.msgmnb;\n\t\tlim->msgmax = msginfo.msgmax;\n\t}\n\n\treturn 0;\n}\n\nint ipc_sem_get_limits(struct ipc_limits *lim)\n{\n\tFILE *f;\n\tint rc = 0;\n\n\tlim->semvmx = SEMVMX;\n\n\tf = fopen(_PATH_PROC_IPC_SEM, \"r\");\n\tif (f) {\n\t\trc = fscanf(f, \"%d\\t%d\\t%d\\t%d\",\n\t\t       &lim->semmsl, &lim->semmns, &lim->semopm, &lim->semmni);\n\t\tfclose(f);\n\t}\n\n\tif (rc != 4) {\n\t\tstruct seminfo seminfo = { .semmni = 0 };\n\t\tunion semun arg = { .array = (ushort *) &seminfo };\n\n\t\tif (semctl(0, 0, IPC_INFO, arg) < 0)\n\t\t\treturn 1;\n\t\tlim->semmni = seminfo.semmni;\n\t\tlim->semmsl = seminfo.semmsl;\n\t\tlim->semmns = seminfo.semmns;\n\t\tlim->semopm = seminfo.semopm;\n\t}\n\n\treturn 0;\n}\n\nint ipc_shm_get_limits(struct ipc_limits *lim)\n{\n\tlim->shmmin = SHMMIN;\n\n\tif (access(_PATH_PROC_IPC_SHMALL, F_OK) == 0 &&\n\t    access(_PATH_PROC_IPC_SHMMAX, F_OK) == 0 &&\n\t    access(_PATH_PROC_IPC_SHMMNI, F_OK) == 0) {\n\n\t\tul_path_read_u64(NULL, &lim->shmall, _PATH_PROC_IPC_SHMALL);\n\t\tul_path_read_u64(NULL, &lim->shmmax, _PATH_PROC_IPC_SHMMAX);\n\t\tul_path_read_u64(NULL, &lim->shmmni, _PATH_PROC_IPC_SHMMNI);\n\n\t} else {\n\t\tstruct shminfo *shminfo;\n\t\tstruct shmid_ds shmbuf;\n\n\t\tif (shmctl(0, IPC_INFO, &shmbuf) < 0)\n\t\t\treturn 1;\n\t\tshminfo = (struct shminfo *) &shmbuf;\n\t\tlim->shmmni = shminfo->shmmni;\n\t\tlim->shmall = shminfo->shmall;\n\t\tlim->shmmax = shminfo->shmmax;\n\t}\n\n\treturn 0;\n}\n\nint ipc_shm_get_info(int id, struct shm_data **shmds)\n{\n\tFILE *f;\n\tint i = 0, maxid, j;\n\tchar buf[BUFSIZ];\n\tstruct shm_data *p;\n\tstruct shmid_ds dummy;\n\n\tp = *shmds = xcalloc(1, sizeof(struct shm_data));\n\tp->next = NULL;\n\n\tf = fopen(_PATH_PROC_SYSV_SHM, \"r\");\n\tif (!f)\n\t\tgoto shm_fallback;\n\n\twhile (fgetc(f) != '\\n');\t\t/* skip header */\n\n\twhile (fgets(buf, sizeof(buf), f) != NULL) {\n\t\t/* scan for the first 14-16 columns (e.g. Linux 2.6.32 has 14) */\n\t\tp->shm_rss = 0xdead;\n\t\tp->shm_swp = 0xdead;\n\t\tif (sscanf(buf,\n\t\t\t  \"%d %d  %o %\"SCNu64 \" %u %u  \"\n\t\t\t  \"%\"SCNu64 \" %u %u %u %u %\"SCNi64 \" %\"SCNi64 \" %\"SCNi64\n\t\t\t  \" %\"SCNu64 \" %\"SCNu64 \"\\n\",\n\t\t\t   &p->shm_perm.key,\n\t\t\t   &p->shm_perm.id,\n\t\t\t   &p->shm_perm.mode,\n\t\t\t   &p->shm_segsz,\n\t\t\t   &p->shm_cprid,\n\t\t\t   &p->shm_lprid,\n\t\t\t   &p->shm_nattch,\n\t\t\t   &p->shm_perm.uid,\n\t\t\t   &p->shm_perm.gid,\n\t\t\t   &p->shm_perm.cuid,\n\t\t\t   &p->shm_perm.cgid,\n\t\t\t   &p->shm_atim,\n\t\t\t   &p->shm_dtim,\n\t\t\t   &p->shm_ctim,\n\t\t\t   &p->shm_rss,\n\t\t\t   &p->shm_swp) < 14)\n\t\t\tcontinue; /* invalid line, skipped */\n\n\t\tif (id > -1) {\n\t\t\t/* ID specified */\n\t\t\tif (id == p->shm_perm.id) {\n\t\t\t\ti = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tp->next = xcalloc(1, sizeof(struct shm_data));\n\t\tp = p->next;\n\t\tp->next = NULL;\n\t\ti++;\n\t}\n\n\tif (i == 0)\n\t\tfree(*shmds);\n\tfclose(f);\n\treturn i;\n\n\t/* Fallback; /proc or /sys file(s) missing. */\nshm_fallback:\n\tmaxid = shmctl(0, SHM_INFO, &dummy);\n\n\tfor (j = 0; j <= maxid; j++) {\n\t\tint shmid;\n\t\tstruct shmid_ds shmseg;\n\t\tstruct ipc_perm *ipcp = &shmseg.shm_perm;\n\n\t\tshmid = shmctl(j, SHM_STAT, &shmseg);\n\t\tif (shmid < 0 || (id > -1 && shmid != id)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\ti++;\n\t\tp->shm_perm.key = ipcp->KEY;\n\t\tp->shm_perm.id = shmid;\n\t\tp->shm_perm.mode = ipcp->mode;\n\t\tp->shm_segsz = shmseg.shm_segsz;\n\t\tp->shm_cprid = shmseg.shm_cpid;\n\t\tp->shm_lprid = shmseg.shm_lpid;\n\t\tp->shm_nattch = shmseg.shm_nattch;\n\t\tp->shm_perm.uid = ipcp->uid;\n\t\tp->shm_perm.gid = ipcp->gid;\n\t\tp->shm_perm.cuid = ipcp->cuid;\n\t\tp->shm_perm.cgid = ipcp->cuid;\n\t\tp->shm_atim = shmseg.shm_atime;\n\t\tp->shm_dtim = shmseg.shm_dtime;\n\t\tp->shm_ctim = shmseg.shm_ctime;\n\t\tp->shm_rss = 0xdead;\n\t\tp->shm_swp = 0xdead;\n\n\t\tif (id < 0) {\n\t\t\tp->next = xcalloc(1, sizeof(struct shm_data));\n\t\t\tp = p->next;\n\t\t\tp->next = NULL;\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\tif (i == 0)\n\t\tfree(*shmds);\n\treturn i;\n}\n\nvoid ipc_shm_free_info(struct shm_data *shmds)\n{\n\twhile (shmds) {\n\t\tstruct shm_data *next = shmds->next;\n\t\tfree(shmds);\n\t\tshmds = next;\n\t}\n}\n\nstatic void get_sem_elements(struct sem_data *p)\n{\n\tsize_t i;\n\n\tif (!p || !p->sem_nsems || p->sem_perm.id < 0)\n\t\treturn;\n\n\tp->elements = xcalloc(p->sem_nsems, sizeof(struct sem_elem));\n\n\tfor (i = 0; i < p->sem_nsems; i++) {\n\t\tstruct sem_elem *e = &p->elements[i];\n\t\tunion semun arg = { .val = 0 };\n\n\t\te->semval = semctl(p->sem_perm.id, i, GETVAL, arg);\n\t\tif (e->semval < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETVAL)\");\n\n\t\te->ncount = semctl(p->sem_perm.id, i, GETNCNT, arg);\n\t\tif (e->ncount < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETNCNT)\");\n\n\t\te->zcount = semctl(p->sem_perm.id, i, GETZCNT, arg);\n\t\tif (e->zcount < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETZCNT)\");\n\n\t\te->pid = semctl(p->sem_perm.id, i, GETPID, arg);\n\t\tif (e->pid < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETPID)\");\n\t}\n}\n\nint ipc_sem_get_info(int id, struct sem_data **semds)\n{\n\tFILE *f;\n\tint i = 0, maxid, j;\n\tstruct sem_data *p;\n\tstruct seminfo dummy;\n\tunion semun arg;\n\n\tp = *semds = xcalloc(1, sizeof(struct sem_data));\n\tp->next = NULL;\n\n\tf = fopen(_PATH_PROC_SYSV_SEM, \"r\");\n\tif (!f)\n\t\tgoto sem_fallback;\n\n\twhile (fgetc(f) != '\\n') ;\t/* skip header */\n\n\twhile (feof(f) == 0) {\n\t\tif (fscanf(f,\n\t\t\t   \"%d %d  %o %\" SCNu64 \" %u %u %u %u %\"\n\t\t\t    SCNi64 \" %\" SCNi64 \"\\n\",\n\t\t\t   &p->sem_perm.key,\n\t\t\t   &p->sem_perm.id,\n\t\t\t   &p->sem_perm.mode,\n\t\t\t   &p->sem_nsems,\n\t\t\t   &p->sem_perm.uid,\n\t\t\t   &p->sem_perm.gid,\n\t\t\t   &p->sem_perm.cuid,\n\t\t\t   &p->sem_perm.cgid,\n\t\t\t   &p->sem_otime,\n\t\t\t   &p->sem_ctime) != 10)\n\t\t\tcontinue;\n\n\t\tif (id > -1) {\n\t\t\t/* ID specified */\n\t\t\tif (id == p->sem_perm.id) {\n\t\t\t\tget_sem_elements(p);\n\t\t\t\ti = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tp->next = xcalloc(1, sizeof(struct sem_data));\n\t\tp = p->next;\n\t\tp->next = NULL;\n\t\ti++;\n\t}\n\n\tif (i == 0)\n\t\tfree(*semds);\n\tfclose(f);\n\treturn i;\n\n\t/* Fallback; /proc or /sys file(s) missing. */\nsem_fallback:\n\targ.array = (ushort *) (void *)&dummy;\n\tmaxid = semctl(0, 0, SEM_INFO, arg);\n\n\tfor (j = 0; j <= maxid; j++) {\n\t\tint semid;\n\t\tstruct semid_ds semseg;\n\t\tstruct ipc_perm *ipcp = &semseg.sem_perm;\n\t\targ.buf = (struct semid_ds *)&semseg;\n\n\t\tsemid = semctl(j, 0, SEM_STAT, arg);\n\t\tif (semid < 0 || (id > -1 && semid != id)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\ti++;\n\t\tp->sem_perm.key = ipcp->KEY;\n\t\tp->sem_perm.id = semid;\n\t\tp->sem_perm.mode = ipcp->mode;\n\t\tp->sem_nsems = semseg.sem_nsems;\n\t\tp->sem_perm.uid = ipcp->uid;\n\t\tp->sem_perm.gid = ipcp->gid;\n\t\tp->sem_perm.cuid = ipcp->cuid;\n\t\tp->sem_perm.cgid = ipcp->cuid;\n\t\tp->sem_otime = semseg.sem_otime;\n\t\tp->sem_ctime = semseg.sem_ctime;\n\n\t\tif (id < 0) {\n\t\t\tp->next = xcalloc(1, sizeof(struct sem_data));\n\t\t\tp = p->next;\n\t\t\tp->next = NULL;\n\t\t\ti++;\n\t\t} else {\n\t\t\tget_sem_elements(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == 0)\n\t\tfree(*semds);\n\treturn i;\n}\n\nvoid ipc_sem_free_info(struct sem_data *semds)\n{\n\twhile (semds) {\n\t\tstruct sem_data *next = semds->next;\n\t\tfree(semds->elements);\n\t\tfree(semds);\n\t\tsemds = next;\n\t}\n}\n\nint ipc_msg_get_info(int id, struct msg_data **msgds)\n{\n\tFILE *f;\n\tint i = 0, maxid, j;\n\tstruct msg_data *p;\n\tstruct msqid_ds dummy;\n\tstruct msqid_ds msgseg;\n\n\tp = *msgds = xcalloc(1, sizeof(struct msg_data));\n\tp->next = NULL;\n\n\tf = fopen(_PATH_PROC_SYSV_MSG, \"r\");\n\tif (!f)\n\t\tgoto msg_fallback;\n\n\twhile (fgetc(f) != '\\n') ;\t/* skip header */\n\n\twhile (feof(f) == 0) {\n\t\tif (fscanf(f,\n\t\t\t   \"%d %d  %o  %\" SCNu64 \" %\" SCNu64\n\t\t\t   \" %u %u %u %u %u %u %\" SCNi64 \" %\" SCNi64 \" %\" SCNi64 \"\\n\",\n\t\t\t   &p->msg_perm.key,\n\t\t\t   &p->msg_perm.id,\n\t\t\t   &p->msg_perm.mode,\n\t\t\t   &p->q_cbytes,\n\t\t\t   &p->q_qnum,\n\t\t\t   &p->q_lspid,\n\t\t\t   &p->q_lrpid,\n\t\t\t   &p->msg_perm.uid,\n\t\t\t   &p->msg_perm.gid,\n\t\t\t   &p->msg_perm.cuid,\n\t\t\t   &p->msg_perm.cgid,\n\t\t\t   &p->q_stime,\n\t\t\t   &p->q_rtime,\n\t\t\t   &p->q_ctime) != 14)\n\t\t\tcontinue;\n\n\t\tif (id > -1) {\n\t\t\t/* ID specified */\n\t\t\tif (id == p->msg_perm.id) {\n\t\t\t\tif (msgctl(id, IPC_STAT, &msgseg) != -1)\n\t\t\t\t\tp->q_qbytes = msgseg.msg_qbytes;\n\t\t\t\ti = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tp->next = xcalloc(1, sizeof(struct msg_data));\n\t\tp = p->next;\n\t\tp->next = NULL;\n\t\ti++;\n\t}\n\n\tif (i == 0)\n\t\tfree(*msgds);\n\tfclose(f);\n\treturn i;\n\n\t/* Fallback; /proc or /sys file(s) missing. */\nmsg_fallback:\n\tmaxid = msgctl(0, MSG_INFO, &dummy);\n\n\tfor (j = 0; j <= maxid; j++) {\n\t\tint msgid;\n\t\tstruct ipc_perm *ipcp = &msgseg.msg_perm;\n\n\t\tmsgid = msgctl(j, MSG_STAT, &msgseg);\n\t\tif (msgid < 0 || (id > -1 && msgid != id)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\ti++;\n\t\tp->msg_perm.key = ipcp->KEY;\n\t\tp->msg_perm.id = msgid;\n\t\tp->msg_perm.mode = ipcp->mode;\n\t\tp->q_cbytes = msgseg.msg_cbytes;\n\t\tp->q_qnum = msgseg.msg_qnum;\n\t\tp->q_lspid = msgseg.msg_lspid;\n\t\tp->q_lrpid = msgseg.msg_lrpid;\n\t\tp->msg_perm.uid = ipcp->uid;\n\t\tp->msg_perm.gid = ipcp->gid;\n\t\tp->msg_perm.cuid = ipcp->cuid;\n\t\tp->msg_perm.cgid = ipcp->cgid;\n\t\tp->q_stime = msgseg.msg_stime;\n\t\tp->q_rtime = msgseg.msg_rtime;\n\t\tp->q_ctime = msgseg.msg_ctime;\n\t\tp->q_qbytes = msgseg.msg_qbytes;\n\n\t\tif (id < 0) {\n\t\t\tp->next = xcalloc(1, sizeof(struct msg_data));\n\t\t\tp = p->next;\n\t\t\tp->next = NULL;\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\tif (i == 0)\n\t\tfree(*msgds);\n\treturn i;\n}\n\nvoid ipc_msg_free_info(struct msg_data *msgds)\n{\n\twhile (msgds) {\n\t\tstruct msg_data *next = msgds->next;\n\t\tfree(msgds);\n\t\tmsgds = next;\n\t}\n}\n\nvoid ipc_print_perms(FILE *f, struct ipc_stat *is)\n{\n\tstruct passwd *pw;\n\tstruct group *gr;\n\n\tfprintf(f, \"%-10d %-10o\", is->id, is->mode & 0777);\n\n\tif ((pw = getpwuid(is->cuid)))\n\t\tfprintf(f, \" %-10s\", pw->pw_name);\n\telse\n\t\tfprintf(f, \" %-10u\", is->cuid);\n\n\tif ((gr = getgrgid(is->cgid)))\n\t\tfprintf(f, \" %-10s\", gr->gr_name);\n\telse\n\t\tfprintf(f, \" %-10u\", is->cgid);\n\n\tif ((pw = getpwuid(is->uid)))\n\t\tfprintf(f, \" %-10s\", pw->pw_name);\n\telse\n\t\tfprintf(f, \" %-10u\", is->uid);\n\n\tif ((gr = getgrgid(is->gid)))\n\t\tfprintf(f, \" %-10s\\n\", gr->gr_name);\n\telse\n\t\tfprintf(f, \" %-10u\\n\", is->gid);\n}\n\nvoid ipc_print_size(int unit, char *msg, uint64_t size, const char *end,\n\t\t    int width)\n{\n\tchar format[32];\n\n\tif (!msg)\n\t\t/* NULL */ ;\n\telse if (msg[strlen(msg) - 1] == '=')\n\t\tprintf(\"%s\", msg);\n\telse if (unit == IPC_UNIT_BYTES)\n\t\tprintf(_(\"%s (bytes) = \"), msg);\n\telse if (unit == IPC_UNIT_KB)\n\t\tprintf(_(\"%s (kbytes) = \"), msg);\n\telse\n\t\tprintf(\"%s = \", msg);\n\n\tswitch (unit) {\n\tcase IPC_UNIT_DEFAULT:\n\tcase IPC_UNIT_BYTES:\n\t\tsprintf(format, \"%%%dju\", width);\n\t\tprintf(format, size);\n\t\tbreak;\n\tcase IPC_UNIT_KB:\n\t\tsprintf(format, \"%%%dju\", width);\n\t\tprintf(format, size / 1024);\n\t\tbreak;\n\tcase IPC_UNIT_HUMAN:\n\t{\n\t\tchar *tmp;\n\t\tsprintf(format, \"%%%ds\", width);\n\t\tprintf(format, (tmp = size_to_human_string(SIZE_SUFFIX_1LETTER, size)));\n\t\tfree(tmp);\n\t\tbreak;\n\t}\n\tdefault:\n\t\t/* impossible occurred */\n\t\tabort();\n\t}\n\n\tif (end)\n\t\tprintf(\"%s\", end);\n}\n"], "fixing_code": ["#include <inttypes.h>\n\n#include \"c.h\"\n#include \"nls.h\"\n#include \"xalloc.h\"\n#include \"path.h\"\n#include \"pathnames.h\"\n#include \"ipcutils.h\"\n#include \"strutils.h\"\n\n#ifndef SEMVMX\n# define SEMVMX  32767\t/* <= 32767 semaphore maximum value */\n#endif\n#ifndef SHMMIN\n# define SHMMIN 1\t/* min shared segment size in bytes */\n#endif\n\n\nint ipc_msg_get_limits(struct ipc_limits *lim)\n{\n\tif (access(_PATH_PROC_IPC_MSGMNI, F_OK) == 0 &&\n\t    access(_PATH_PROC_IPC_MSGMNB, F_OK) == 0 &&\n\t    access(_PATH_PROC_IPC_MSGMAX, F_OK) == 0) {\n\n\t\tif (ul_path_read_s32(NULL, &lim->msgmni, _PATH_PROC_IPC_MSGMNI) != 0)\n\t\t\treturn 1;\n\t\tif (ul_path_read_s32(NULL, &lim->msgmnb, _PATH_PROC_IPC_MSGMNB) != 0)\n\t\t\treturn 1;\n\t\tif (ul_path_read_u64(NULL, &lim->msgmax, _PATH_PROC_IPC_MSGMAX) != 0)\n\t\t\treturn 1;\n\t} else {\n\t\tstruct msginfo msginfo;\n\n\t\tif (msgctl(0, IPC_INFO, (struct msqid_ds *) &msginfo) < 0)\n\t\t\treturn 1;\n\t\tlim->msgmni = msginfo.msgmni;\n\t\tlim->msgmnb = msginfo.msgmnb;\n\t\tlim->msgmax = msginfo.msgmax;\n\t}\n\n\treturn 0;\n}\n\nint ipc_sem_get_limits(struct ipc_limits *lim)\n{\n\tFILE *f;\n\tint rc = 0;\n\n\tlim->semvmx = SEMVMX;\n\n\tf = fopen(_PATH_PROC_IPC_SEM, \"r\");\n\tif (f) {\n\t\trc = fscanf(f, \"%d\\t%d\\t%d\\t%d\",\n\t\t       &lim->semmsl, &lim->semmns, &lim->semopm, &lim->semmni);\n\t\tfclose(f);\n\t}\n\n\tif (rc != 4) {\n\t\tstruct seminfo seminfo = { .semmni = 0 };\n\t\tunion semun arg = { .array = (ushort *) &seminfo };\n\n\t\tif (semctl(0, 0, IPC_INFO, arg) < 0)\n\t\t\treturn 1;\n\t\tlim->semmni = seminfo.semmni;\n\t\tlim->semmsl = seminfo.semmsl;\n\t\tlim->semmns = seminfo.semmns;\n\t\tlim->semopm = seminfo.semopm;\n\t}\n\n\treturn 0;\n}\n\nint ipc_shm_get_limits(struct ipc_limits *lim)\n{\n\tlim->shmmin = SHMMIN;\n\n\tif (access(_PATH_PROC_IPC_SHMALL, F_OK) == 0 &&\n\t    access(_PATH_PROC_IPC_SHMMAX, F_OK) == 0 &&\n\t    access(_PATH_PROC_IPC_SHMMNI, F_OK) == 0) {\n\n\t\tul_path_read_u64(NULL, &lim->shmall, _PATH_PROC_IPC_SHMALL);\n\t\tul_path_read_u64(NULL, &lim->shmmax, _PATH_PROC_IPC_SHMMAX);\n\t\tul_path_read_u64(NULL, &lim->shmmni, _PATH_PROC_IPC_SHMMNI);\n\n\t} else {\n\t\tstruct shminfo *shminfo;\n\t\tstruct shmid_ds shmbuf;\n\n\t\tif (shmctl(0, IPC_INFO, &shmbuf) < 0)\n\t\t\treturn 1;\n\t\tshminfo = (struct shminfo *) &shmbuf;\n\t\tlim->shmmni = shminfo->shmmni;\n\t\tlim->shmall = shminfo->shmall;\n\t\tlim->shmmax = shminfo->shmmax;\n\t}\n\n\treturn 0;\n}\n\nint ipc_shm_get_info(int id, struct shm_data **shmds)\n{\n\tFILE *f;\n\tint i = 0, maxid, j;\n\tchar buf[BUFSIZ];\n\tstruct shm_data *p;\n\tstruct shmid_ds dummy;\n\n\tp = *shmds = xcalloc(1, sizeof(struct shm_data));\n\tp->next = NULL;\n\n\tf = fopen(_PATH_PROC_SYSV_SHM, \"r\");\n\tif (!f)\n\t\tgoto shm_fallback;\n\n\twhile (fgetc(f) != '\\n');\t\t/* skip header */\n\n\twhile (fgets(buf, sizeof(buf), f) != NULL) {\n\t\t/* scan for the first 14-16 columns (e.g. Linux 2.6.32 has 14) */\n\t\tp->shm_rss = 0xdead;\n\t\tp->shm_swp = 0xdead;\n\t\tif (sscanf(buf,\n\t\t\t  \"%d %d  %o %\"SCNu64 \" %u %u  \"\n\t\t\t  \"%\"SCNu64 \" %u %u %u %u %\"SCNi64 \" %\"SCNi64 \" %\"SCNi64\n\t\t\t  \" %\"SCNu64 \" %\"SCNu64 \"\\n\",\n\t\t\t   &p->shm_perm.key,\n\t\t\t   &p->shm_perm.id,\n\t\t\t   &p->shm_perm.mode,\n\t\t\t   &p->shm_segsz,\n\t\t\t   &p->shm_cprid,\n\t\t\t   &p->shm_lprid,\n\t\t\t   &p->shm_nattch,\n\t\t\t   &p->shm_perm.uid,\n\t\t\t   &p->shm_perm.gid,\n\t\t\t   &p->shm_perm.cuid,\n\t\t\t   &p->shm_perm.cgid,\n\t\t\t   &p->shm_atim,\n\t\t\t   &p->shm_dtim,\n\t\t\t   &p->shm_ctim,\n\t\t\t   &p->shm_rss,\n\t\t\t   &p->shm_swp) < 14)\n\t\t\tcontinue; /* invalid line, skipped */\n\n\t\tif (id > -1) {\n\t\t\t/* ID specified */\n\t\t\tif (id == p->shm_perm.id) {\n\t\t\t\ti = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tp->next = xcalloc(1, sizeof(struct shm_data));\n\t\tp = p->next;\n\t\tp->next = NULL;\n\t\ti++;\n\t}\n\n\tif (i == 0)\n\t\tfree(*shmds);\n\tfclose(f);\n\treturn i;\n\n\t/* Fallback; /proc or /sys file(s) missing. */\nshm_fallback:\n\tmaxid = shmctl(0, SHM_INFO, &dummy);\n\n\tfor (j = 0; j <= maxid; j++) {\n\t\tint shmid;\n\t\tstruct shmid_ds shmseg;\n\t\tstruct ipc_perm *ipcp = &shmseg.shm_perm;\n\n\t\tshmid = shmctl(j, SHM_STAT, &shmseg);\n\t\tif (shmid < 0 || (id > -1 && shmid != id)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\ti++;\n\t\tp->shm_perm.key = ipcp->KEY;\n\t\tp->shm_perm.id = shmid;\n\t\tp->shm_perm.mode = ipcp->mode;\n\t\tp->shm_segsz = shmseg.shm_segsz;\n\t\tp->shm_cprid = shmseg.shm_cpid;\n\t\tp->shm_lprid = shmseg.shm_lpid;\n\t\tp->shm_nattch = shmseg.shm_nattch;\n\t\tp->shm_perm.uid = ipcp->uid;\n\t\tp->shm_perm.gid = ipcp->gid;\n\t\tp->shm_perm.cuid = ipcp->cuid;\n\t\tp->shm_perm.cgid = ipcp->cuid;\n\t\tp->shm_atim = shmseg.shm_atime;\n\t\tp->shm_dtim = shmseg.shm_dtime;\n\t\tp->shm_ctim = shmseg.shm_ctime;\n\t\tp->shm_rss = 0xdead;\n\t\tp->shm_swp = 0xdead;\n\n\t\tif (id < 0) {\n\t\t\tp->next = xcalloc(1, sizeof(struct shm_data));\n\t\t\tp = p->next;\n\t\t\tp->next = NULL;\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\tif (i == 0)\n\t\tfree(*shmds);\n\treturn i;\n}\n\nvoid ipc_shm_free_info(struct shm_data *shmds)\n{\n\twhile (shmds) {\n\t\tstruct shm_data *next = shmds->next;\n\t\tfree(shmds);\n\t\tshmds = next;\n\t}\n}\n\nstatic void get_sem_elements(struct sem_data *p)\n{\n\tsize_t i;\n\n\tif (!p || !p->sem_nsems || p->sem_nsems > SIZE_MAX || p->sem_perm.id < 0)\n\t\treturn;\n\n\tp->elements = xcalloc(p->sem_nsems, sizeof(struct sem_elem));\n\n\tfor (i = 0; i < p->sem_nsems; i++) {\n\t\tstruct sem_elem *e = &p->elements[i];\n\t\tunion semun arg = { .val = 0 };\n\n\t\te->semval = semctl(p->sem_perm.id, i, GETVAL, arg);\n\t\tif (e->semval < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETVAL)\");\n\n\t\te->ncount = semctl(p->sem_perm.id, i, GETNCNT, arg);\n\t\tif (e->ncount < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETNCNT)\");\n\n\t\te->zcount = semctl(p->sem_perm.id, i, GETZCNT, arg);\n\t\tif (e->zcount < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETZCNT)\");\n\n\t\te->pid = semctl(p->sem_perm.id, i, GETPID, arg);\n\t\tif (e->pid < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETPID)\");\n\t}\n}\n\nint ipc_sem_get_info(int id, struct sem_data **semds)\n{\n\tFILE *f;\n\tint i = 0, maxid, j;\n\tstruct sem_data *p;\n\tstruct seminfo dummy;\n\tunion semun arg;\n\n\tp = *semds = xcalloc(1, sizeof(struct sem_data));\n\tp->next = NULL;\n\n\tf = fopen(_PATH_PROC_SYSV_SEM, \"r\");\n\tif (!f)\n\t\tgoto sem_fallback;\n\n\twhile (fgetc(f) != '\\n') ;\t/* skip header */\n\n\twhile (feof(f) == 0) {\n\t\tif (fscanf(f,\n\t\t\t   \"%d %d  %o %\" SCNu64 \" %u %u %u %u %\"\n\t\t\t    SCNi64 \" %\" SCNi64 \"\\n\",\n\t\t\t   &p->sem_perm.key,\n\t\t\t   &p->sem_perm.id,\n\t\t\t   &p->sem_perm.mode,\n\t\t\t   &p->sem_nsems,\n\t\t\t   &p->sem_perm.uid,\n\t\t\t   &p->sem_perm.gid,\n\t\t\t   &p->sem_perm.cuid,\n\t\t\t   &p->sem_perm.cgid,\n\t\t\t   &p->sem_otime,\n\t\t\t   &p->sem_ctime) != 10)\n\t\t\tcontinue;\n\n\t\tif (id > -1) {\n\t\t\t/* ID specified */\n\t\t\tif (id == p->sem_perm.id) {\n\t\t\t\tget_sem_elements(p);\n\t\t\t\ti = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tp->next = xcalloc(1, sizeof(struct sem_data));\n\t\tp = p->next;\n\t\tp->next = NULL;\n\t\ti++;\n\t}\n\n\tif (i == 0)\n\t\tfree(*semds);\n\tfclose(f);\n\treturn i;\n\n\t/* Fallback; /proc or /sys file(s) missing. */\nsem_fallback:\n\targ.array = (ushort *) (void *)&dummy;\n\tmaxid = semctl(0, 0, SEM_INFO, arg);\n\n\tfor (j = 0; j <= maxid; j++) {\n\t\tint semid;\n\t\tstruct semid_ds semseg;\n\t\tstruct ipc_perm *ipcp = &semseg.sem_perm;\n\t\targ.buf = (struct semid_ds *)&semseg;\n\n\t\tsemid = semctl(j, 0, SEM_STAT, arg);\n\t\tif (semid < 0 || (id > -1 && semid != id)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\ti++;\n\t\tp->sem_perm.key = ipcp->KEY;\n\t\tp->sem_perm.id = semid;\n\t\tp->sem_perm.mode = ipcp->mode;\n\t\tp->sem_nsems = semseg.sem_nsems;\n\t\tp->sem_perm.uid = ipcp->uid;\n\t\tp->sem_perm.gid = ipcp->gid;\n\t\tp->sem_perm.cuid = ipcp->cuid;\n\t\tp->sem_perm.cgid = ipcp->cuid;\n\t\tp->sem_otime = semseg.sem_otime;\n\t\tp->sem_ctime = semseg.sem_ctime;\n\n\t\tif (id < 0) {\n\t\t\tp->next = xcalloc(1, sizeof(struct sem_data));\n\t\t\tp = p->next;\n\t\t\tp->next = NULL;\n\t\t\ti++;\n\t\t} else {\n\t\t\tget_sem_elements(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == 0)\n\t\tfree(*semds);\n\treturn i;\n}\n\nvoid ipc_sem_free_info(struct sem_data *semds)\n{\n\twhile (semds) {\n\t\tstruct sem_data *next = semds->next;\n\t\tfree(semds->elements);\n\t\tfree(semds);\n\t\tsemds = next;\n\t}\n}\n\nint ipc_msg_get_info(int id, struct msg_data **msgds)\n{\n\tFILE *f;\n\tint i = 0, maxid, j;\n\tstruct msg_data *p;\n\tstruct msqid_ds dummy;\n\tstruct msqid_ds msgseg;\n\n\tp = *msgds = xcalloc(1, sizeof(struct msg_data));\n\tp->next = NULL;\n\n\tf = fopen(_PATH_PROC_SYSV_MSG, \"r\");\n\tif (!f)\n\t\tgoto msg_fallback;\n\n\twhile (fgetc(f) != '\\n') ;\t/* skip header */\n\n\twhile (feof(f) == 0) {\n\t\tif (fscanf(f,\n\t\t\t   \"%d %d  %o  %\" SCNu64 \" %\" SCNu64\n\t\t\t   \" %u %u %u %u %u %u %\" SCNi64 \" %\" SCNi64 \" %\" SCNi64 \"\\n\",\n\t\t\t   &p->msg_perm.key,\n\t\t\t   &p->msg_perm.id,\n\t\t\t   &p->msg_perm.mode,\n\t\t\t   &p->q_cbytes,\n\t\t\t   &p->q_qnum,\n\t\t\t   &p->q_lspid,\n\t\t\t   &p->q_lrpid,\n\t\t\t   &p->msg_perm.uid,\n\t\t\t   &p->msg_perm.gid,\n\t\t\t   &p->msg_perm.cuid,\n\t\t\t   &p->msg_perm.cgid,\n\t\t\t   &p->q_stime,\n\t\t\t   &p->q_rtime,\n\t\t\t   &p->q_ctime) != 14)\n\t\t\tcontinue;\n\n\t\tif (id > -1) {\n\t\t\t/* ID specified */\n\t\t\tif (id == p->msg_perm.id) {\n\t\t\t\tif (msgctl(id, IPC_STAT, &msgseg) != -1)\n\t\t\t\t\tp->q_qbytes = msgseg.msg_qbytes;\n\t\t\t\ti = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tp->next = xcalloc(1, sizeof(struct msg_data));\n\t\tp = p->next;\n\t\tp->next = NULL;\n\t\ti++;\n\t}\n\n\tif (i == 0)\n\t\tfree(*msgds);\n\tfclose(f);\n\treturn i;\n\n\t/* Fallback; /proc or /sys file(s) missing. */\nmsg_fallback:\n\tmaxid = msgctl(0, MSG_INFO, &dummy);\n\n\tfor (j = 0; j <= maxid; j++) {\n\t\tint msgid;\n\t\tstruct ipc_perm *ipcp = &msgseg.msg_perm;\n\n\t\tmsgid = msgctl(j, MSG_STAT, &msgseg);\n\t\tif (msgid < 0 || (id > -1 && msgid != id)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\ti++;\n\t\tp->msg_perm.key = ipcp->KEY;\n\t\tp->msg_perm.id = msgid;\n\t\tp->msg_perm.mode = ipcp->mode;\n\t\tp->q_cbytes = msgseg.msg_cbytes;\n\t\tp->q_qnum = msgseg.msg_qnum;\n\t\tp->q_lspid = msgseg.msg_lspid;\n\t\tp->q_lrpid = msgseg.msg_lrpid;\n\t\tp->msg_perm.uid = ipcp->uid;\n\t\tp->msg_perm.gid = ipcp->gid;\n\t\tp->msg_perm.cuid = ipcp->cuid;\n\t\tp->msg_perm.cgid = ipcp->cgid;\n\t\tp->q_stime = msgseg.msg_stime;\n\t\tp->q_rtime = msgseg.msg_rtime;\n\t\tp->q_ctime = msgseg.msg_ctime;\n\t\tp->q_qbytes = msgseg.msg_qbytes;\n\n\t\tif (id < 0) {\n\t\t\tp->next = xcalloc(1, sizeof(struct msg_data));\n\t\t\tp = p->next;\n\t\t\tp->next = NULL;\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\tif (i == 0)\n\t\tfree(*msgds);\n\treturn i;\n}\n\nvoid ipc_msg_free_info(struct msg_data *msgds)\n{\n\twhile (msgds) {\n\t\tstruct msg_data *next = msgds->next;\n\t\tfree(msgds);\n\t\tmsgds = next;\n\t}\n}\n\nvoid ipc_print_perms(FILE *f, struct ipc_stat *is)\n{\n\tstruct passwd *pw;\n\tstruct group *gr;\n\n\tfprintf(f, \"%-10d %-10o\", is->id, is->mode & 0777);\n\n\tif ((pw = getpwuid(is->cuid)))\n\t\tfprintf(f, \" %-10s\", pw->pw_name);\n\telse\n\t\tfprintf(f, \" %-10u\", is->cuid);\n\n\tif ((gr = getgrgid(is->cgid)))\n\t\tfprintf(f, \" %-10s\", gr->gr_name);\n\telse\n\t\tfprintf(f, \" %-10u\", is->cgid);\n\n\tif ((pw = getpwuid(is->uid)))\n\t\tfprintf(f, \" %-10s\", pw->pw_name);\n\telse\n\t\tfprintf(f, \" %-10u\", is->uid);\n\n\tif ((gr = getgrgid(is->gid)))\n\t\tfprintf(f, \" %-10s\\n\", gr->gr_name);\n\telse\n\t\tfprintf(f, \" %-10u\\n\", is->gid);\n}\n\nvoid ipc_print_size(int unit, char *msg, uint64_t size, const char *end,\n\t\t    int width)\n{\n\tchar format[32];\n\n\tif (!msg)\n\t\t/* NULL */ ;\n\telse if (msg[strlen(msg) - 1] == '=')\n\t\tprintf(\"%s\", msg);\n\telse if (unit == IPC_UNIT_BYTES)\n\t\tprintf(_(\"%s (bytes) = \"), msg);\n\telse if (unit == IPC_UNIT_KB)\n\t\tprintf(_(\"%s (kbytes) = \"), msg);\n\telse\n\t\tprintf(\"%s = \", msg);\n\n\tswitch (unit) {\n\tcase IPC_UNIT_DEFAULT:\n\tcase IPC_UNIT_BYTES:\n\t\tsprintf(format, \"%%%dju\", width);\n\t\tprintf(format, size);\n\t\tbreak;\n\tcase IPC_UNIT_KB:\n\t\tsprintf(format, \"%%%dju\", width);\n\t\tprintf(format, size / 1024);\n\t\tbreak;\n\tcase IPC_UNIT_HUMAN:\n\t{\n\t\tchar *tmp;\n\t\tsprintf(format, \"%%%ds\", width);\n\t\tprintf(format, (tmp = size_to_human_string(SIZE_SUFFIX_1LETTER, size)));\n\t\tfree(tmp);\n\t\tbreak;\n\t}\n\tdefault:\n\t\t/* impossible occurred */\n\t\tabort();\n\t}\n\n\tif (end)\n\t\tprintf(\"%s\", end);\n}\n"], "filenames": ["sys-utils/ipcutils.c"], "buggy_code_start_loc": [221], "buggy_code_end_loc": [222], "fixing_code_start_loc": [221], "fixing_code_end_loc": [222], "type": "CWE-190", "message": "** DISPUTED ** An integer overflow in util-linux through 2.37.1 can potentially cause a buffer overflow if an attacker were able to use system resources in a way that leads to a large number in the /proc/sysvipc/sem file. NOTE: this is unexploitable in GNU C Library environments, and possibly in all realistic environments.", "other": {"cve": {"id": "CVE-2021-37600", "sourceIdentifier": "cve@mitre.org", "published": "2021-07-30T14:15:18.737", "lastModified": "2021-10-18T12:18:32.367", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "** DISPUTED ** An integer overflow in util-linux through 2.37.1 can potentially cause a buffer overflow if an attacker were able to use system resources in a way that leads to a large number in the /proc/sysvipc/sem file. NOTE: this is unexploitable in GNU C Library environments, and possibly in all realistic environments."}, {"lang": "es", "value": "** EN DISPUTA ** Un desbordamiento de enteros en util-linux hasta la versi\u00f3n 2.37.1 puede potencialmente causar un desbordamiento de b\u00fafer si un atacante fuera capaz de utilizar los recursos del sistema de una manera que lleve a un n\u00famero grande en el archivo /proc/sysvipc/sem. NOTA: esto es inexplotable en entornos de GNU C Library, y posiblemente en todos los entornos realistas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:H/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 1.2}, "baseSeverity": "LOW", "exploitabilityScore": 1.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:kernel:util-linux:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.37.1", "matchCriteriaId": "332D3DCC-3B7E-466E-844E-F2014DC27B45"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:ontap_select_deploy_administration_utility:-:*:*:*:*:*:*:*", "matchCriteriaId": "E7CF3019-975D-40BB-A8A4-894E62BD3797"}]}]}], "references": [{"url": "https://github.com/karelzak/util-linux/commit/1c9143d0c1f979c3daf10e1c37b5b1e916c22a1c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/karelzak/util-linux/issues/1395", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20210902-0002/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/karelzak/util-linux/commit/1c9143d0c1f979c3daf10e1c37b5b1e916c22a1c"}}