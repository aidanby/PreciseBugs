{"buggy_code": ["\"use strict\";\nvar fs = require('fs');\nvar path = require('path');\nvar async = require('async');\nvar child_process = require('child_process');\n\nvar fsPath = {\n  _win32: process.platform === 'win32',\n  _supportExecSync: function () {\n    if (!child_process.execSync) {\n      throw new Error('your node.js version is to low(<0.11.12).')\n    }\n    return this;\n  },\n  mkdir: function (dist, callback) {\n    var dirs = [];\n    dist = path.resolve(dist);\n    dist.split(/[\\\\\\/]/).reduce(function (first, second) {\n      var _path = path.join(first || '/', second);\n      dirs.push(_path);\n      return _path;\n    });\n    async.eachSeries(dirs, function (_path, callback) {\n      fs.exists(_path, function (exists) {\n        if (exists) {\n          callback(null);\n        } else {\n          fs.mkdir(_path, function (err) {\n            callback(!err || err.code === 'EEXIST' ? null : err);\n          });\n        }\n      });\n    }, function (err) {\n      callback && callback(err);\n    });\n  },\n  mkdirSync: function (dist) {\n    dist = path.resolve(dist);\n    if (!fs.existsSync(dist)) {\n      fsPath.mkdirSync(path.dirname(dist));\n      fs.mkdirSync(dist);\n    }\n  },\n  copy: function (from, dist, callback) {\n    var that = this,\n      cmd = '';\n    dist = path.resolve(dist);\n    fs.lstat(from, function (err, stats) {\n      if (err) {\n        callback(err);\n      } else {\n        if (stats.isDirectory()) {\n          that.mkdir(dist, function (err) {\n            if (err) {\n              callback(err);\n            } else {\n              if (that._win32) {\n                cmd = 'echo d|xcopy /s /e /y \"' + path.join(from, '*') + '\" \"' + dist + '\"';\n              } else {\n                cmd = 'cp -f -R -p ' + path.join(from, '*').replace(/ /g, '\\\\ ') + ' ' + dist.replace(/ /g, '\\\\ ');\n              }\n              child_process.exec(cmd, function (error, stdout, stderr) {\n                callback && callback(error);\n              });\n            }\n          });\n        } else if (stats.isFile()) {\n          if (that._win32) {\n            cmd = 'echo f|xcopy /y \"' + from + '\" \"' + dist + '\"';\n          } else {\n            cmd = 'cp -f -p ' + from.replace(/ /g, '\\\\ ') + ' ' + dist.replace(/ /g, '\\\\ ');\n          }\n          child_process.exec(cmd, function (error, stdout, stderr) {\n            callback && callback(error);\n          });\n        } else {\n          callback && callback(null);\n        }\n      }\n    });\n  },\n  copySync: function (from, dist) {\n    this._supportExecSync();\n    try {\n      var cmd = '';\n      var stats = fs.lstatSync(from);\n      dist = path.resolve(dist);\n      if (stats.isDirectory()) {\n        if (this._win32) {\n          // windows\n          cmd = 'echo da|xcopy /s /e \"' + path.join(from, '*') + '\" \"' + dist + '\"';\n        } else {\n          // linux or mac\n          cmd = 'cp -f -R -p ' + path.join(from, '*').replace(/ /g, '\\\\ ') + ' ' + dist.replace(/ /g, '\\\\ ');\n        }\n      } else if (stats.isFile()) {\n        if (this._win32) {\n          // windows\n          cmd = 'echo fa|xcopy \"' + from + '\" \"' + dist + '\"';\n        } else {\n          // linux or mac\n          cmd = 'cp -f -p ' + from.replace(/ /g, '\\\\ ') + ' ' + dist.replace(/ /g, '\\\\ ');\n        }\n      }\n      cmd && child_process.execSync(cmd);\n    } catch (e) {}\n  },\n  remove: function (from, callback) {\n    var that = this,\n      cmd = '';\n    fs.lstat(from, function (err, stats) {\n      if (err) {\n        callback(err);\n      } else {\n        if (that._win32) {\n          // windows\n          if (stats.isDirectory()) {\n            cmd = 'rd /s /q \"' + from + '\"';\n          } else if (stats.isFile()) {\n            cmd = 'del /f \"' + from + '\"';\n          }\n        } else {\n          // linux or mac\n          cmd = 'rm -rf ' + from.replace(/ /g, '\\\\ ');\n        }\n        if (cmd) {\n          child_process.exec(cmd, function (error, stdout, stderr) {\n            callback && callback(error);\n          });\n        } else {\n          callback && callback(null);\n        }\n      }\n    });\n  },\n  removeSync: function (from) {\n    this._supportExecSync();\n    try {\n      var cmd = '';\n      var stats = fs.lstatSync(from);\n      if (this._win32) {\n        // windows\n        if (stats.isDirectory()) {\n          cmd = 'rd /s /q \"' + from + '\"';\n        } else if (stats.isFile()) {\n          cmd = 'del /f \"' + from + '\"';\n        }\n      } else {\n        // linux or mac\n        cmd = 'rm -rf \"' + from + '\"';\n      }\n      cmd && child_process.execSync(cmd);\n    } catch (e) {}\n  },\n  find: function (from, filter, callback) {\n    var filelist = {\n      dirs: [],\n      files: []\n    };\n    if (arguments.length < 3) {\n      callback = filter;\n      filter = null;\n    }\n    fs.readdir(from, function (err, files) {\n      if (err) {\n        callback && callback(err);\n      } else {\n        async.each(files, function (file, callback) {\n          var filepath = path.join(from, file);\n          fs.lstat(filepath, function (err, stats) {\n            if (err) {\n              callback(err);\n            } else {\n              if (stats.isDirectory()) {\n                if (!filter || filter(filepath, 'directory', file)) {\n                  filelist.dirs.indexOf(filepath) === -1 && filelist.dirs.push(filepath);\n                  fsPath.find(filepath, filter, function (err, files) {\n                    if (err) {\n                      callback && callback(err);\n                    } else {\n                      files.dirs.forEach(function (_dir) {\n                        filelist.dirs.indexOf(_dir) === -1 && filelist.dirs.push(_dir);\n                      });\n                      filelist.files = filelist.files.concat(files.files);\n                      callback && callback(null);\n                    }\n                  });\n                } else {\n                  callback && callback(null);\n                }\n              } else if (stats.isFile()) {\n                if (!filter || filter(filepath, 'file', file)) {\n                  filelist.files.push(filepath);\n                }\n                callback && callback(null);\n              } else {\n                callback && callback(null);\n              }\n            }\n          });\n        }, function (err) {\n          if (err) {\n            callback && callback(err);\n          } else {\n            callback && callback(null, filelist);\n          }\n        });\n      }\n    });\n  },\n  findSync: function (from, filter) {\n    var filelist = {\n      dirs: [],\n      files: []\n    };\n    fs.readdirSync(from).forEach(function (file) {\n      var filepath = path.join(from, file);\n      var stats = fs.lstatSync(filepath);\n      if (stats.isDirectory()) {\n        if (!filter || filter(filepath, 'directory', file)) {\n          filelist.dirs.indexOf(filepath) === -1 && filelist.dirs.push(filepath);\n          var files = fsPath.findSync(filepath, filter);\n          files.dirs.forEach(function (_dir) {\n            filelist.dirs.indexOf(_dir) === -1 && filelist.dirs.push(_dir);\n          });\n          filelist.files = filelist.files.concat(files.files);\n        }\n      } else if (stats.isFile()) {\n        if (!filter || filter(filepath, 'file', file)) {\n          filelist.files.push(filepath);\n        }\n      }\n    });\n    return filelist;\n  },\n  writeFile: function (dist, content, encoding, callback) {\n    dist = path.resolve(dist);\n    if (typeof encoding === 'function') {\n      callback = encoding;\n      encoding = 'utf-8';\n    }\n    fsPath.mkdir(path.dirname(dist), function (err) {\n      if (err) {\n        callback(err);\n      } else {\n        fs.writeFile(dist, content, {\n          encoding: encoding\n        }, callback);\n      }\n    });\n  },\n  writeFileSync: function (dist, content, encoding) {\n    dist = path.resolve(dist);\n    if (typeof encoding === 'function') {\n      callback = encoding;\n      encoding = 'utf-8';\n    }\n    fsPath.mkdirSync(path.dirname(dist));\n    fs.writeFileSync(dist, content, {\n      encoding: encoding\n    });\n  }\n};\nmodule.exports = fsPath;", "{\n  \"name\": \"fs-path\",\n  \"version\": \"0.0.24\",\n  \"main\": \"lib/index.js\",\n  \"author\": {\n    \"name\": \"pillys\",\n    \"email\": \"pillys@163.com\",\n    \"url\": \"http://www.qque.com\"\n  },\n  \"keywords\": [\n    \"fs-path\",\n    \"file\",\n    \"directory\"\n  ],\n  \"repository\": {\n    \"url\": \"https://github.com/pillys/fs-path\",\n    \"type\": \"git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/pillys/fs-path/issues\"\n  },\n  \"homepage\": \"https://github.com/pillys/fs-path\",\n  \"dependencies\": {\n    \"async\": \"~0.9.0\"\n  },\n  \"description\": \"file and directory op libs, find, findSync, mkdir, mkdirSync, copy, copySync, remove, removeSync, writeFile, writeFileSync\",\n  \"readmeFilename\": \"README.md\",\n  \"license\": \"MIT\"\n}"], "fixing_code": ["\"use strict\";\nvar fs = require('fs');\nvar path = require('path');\nvar async = require('async');\nvar child_process = require('child_process');\nconst shellescape = require('shell-escape')\n\nvar fsPath = {\n  _win32: process.platform === 'win32',\n  _supportExecSync: function () {\n    if (!child_process.execSync) {\n      throw new Error('your node.js version is to low(<0.11.12).')\n    }\n    return this;\n  },\n  mkdir: function (dist, callback) {\n    var dirs = [];\n    dist = path.resolve(dist);\n    dist.split(/[\\\\\\/]/).reduce(function (first, second) {\n      var _path = path.join(first || '/', second);\n      dirs.push(_path);\n      return _path;\n    });\n    async.eachSeries(dirs, function (_path, callback) {\n      fs.exists(_path, function (exists) {\n        if (exists) {\n          callback(null);\n        } else {\n          fs.mkdir(_path, function (err) {\n            callback(!err || err.code === 'EEXIST' ? null : err);\n          });\n        }\n      });\n    }, function (err) {\n      callback && callback(err);\n    });\n  },\n  mkdirSync: function (dist) {\n    dist = path.resolve(dist);\n    if (!fs.existsSync(dist)) {\n      fsPath.mkdirSync(path.dirname(dist));\n      fs.mkdirSync(dist);\n    }\n  },\n  copy: function (from, dist, callback) {\n    var that = this,\n      cmd = '';\n    dist = path.resolve(dist);\n    fs.lstat(from, function (err, stats) {\n      if (err) {\n        callback(err);\n      } else {\n        if (stats.isDirectory()) {\n          that.mkdir(dist, function (err) {\n            if (err) {\n              callback(err);\n            } else {\n              if (that._win32) {\n                cmd = 'echo d|xcopy /s /e /y ' + shellescape([path.join(from, '*')]) + ' ' + shellescape([dist]);\n              } else {\n                cmd = 'cp -f -R -p ' + shellescape([path.join(from, '*')]) + ' ' + shellescape([dist]);\n              }\n              child_process.exec(cmd, function (error, stdout, stderr) {\n                callback && callback(error);\n              });\n            }\n          });\n        } else if (stats.isFile()) {\n          if (that._win32) {\n            cmd = 'echo f|xcopy /y ' + shellescape([from]) + ' ' + shellescape([dist]);\n          } else {\n            cmd = 'cp -f -p ' + shellescape([from]) + ' ' + shellescape([dist]);\n          }\n          child_process.exec(cmd, function (error, stdout, stderr) {\n            callback && callback(error);\n          });\n        } else {\n          callback && callback(null);\n        }\n      }\n    });\n  },\n  copySync: function (from, dist) {\n    this._supportExecSync();\n    try {\n      var cmd = '';\n      var stats = fs.lstatSync(from);\n      dist = path.resolve(dist);\n      if (stats.isDirectory()) {\n        if (this._win32) {\n          // windows\n          cmd = 'echo da|xcopy /s /e ' + shellescape([path.join(from, '*')]) + ' ' + shellescape([dist]);\n        } else {\n          // linux or mac\n          cmd = 'cp -f -R -p ' + shellescape([path.join(from, '*')]) + ' ' + shellescape([dist]);\n        }\n      } else if (stats.isFile()) {\n        if (this._win32) {\n          // windows\n          cmd = 'echo fa|xcopy ' + shellescape([from]) + ' ' + shellescape([dist]);\n        } else {\n          // linux or mac\n          cmd = 'cp -f -p ' + shellescape([from]) + ' ' + shellescape([dist]);\n        }\n      }\n      cmd && child_process.execSync(cmd);\n    } catch (e) {}\n  },\n  remove: function (from, callback) {\n    var that = this,\n      cmd = '';\n    fs.lstat(from, function (err, stats) {\n      if (err) {\n        callback(err);\n      } else {\n        if (that._win32) {\n          // windows\n          if (stats.isDirectory()) {\n            cmd = 'rd /s /q ' + shellescape([from]);\n          } else if (stats.isFile()) {\n            cmd = 'del /f ' + shellescape([from]);\n          }\n        } else {\n          // linux or mac\n          cmd = 'rm -rf ' + shellescape([from]);\n        }\n        if (cmd) {\n          child_process.exec(cmd, function (error, stdout, stderr) {\n            callback && callback(error);\n          });\n        } else {\n          callback && callback(null);\n        }\n      }\n    });\n  },\n  removeSync: function (from) {\n    this._supportExecSync();\n    try {\n      var cmd = '';\n      var stats = fs.lstatSync(from);\n      if (this._win32) {\n        // windows\n        if (stats.isDirectory()) {\n          cmd = 'rd /s /q ' + shellescape([from]);\n        } else if (stats.isFile()) {\n          cmd = 'del /f ' + shellescape([from]);\n        }\n      } else {\n        // linux or mac\n        cmd = 'rm -rf ' + shellescape([from]);\n      }\n      cmd && child_process.execSync(cmd);\n    } catch (e) {}\n  },\n  find: function (from, filter, callback) {\n    var filelist = {\n      dirs: [],\n      files: []\n    };\n    if (arguments.length < 3) {\n      callback = filter;\n      filter = null;\n    }\n    fs.readdir(from, function (err, files) {\n      if (err) {\n        callback && callback(err);\n      } else {\n        async.each(files, function (file, callback) {\n          var filepath = path.join(from, file);\n          fs.lstat(filepath, function (err, stats) {\n            if (err) {\n              callback(err);\n            } else {\n              if (stats.isDirectory()) {\n                if (!filter || filter(filepath, 'directory', file)) {\n                  filelist.dirs.indexOf(filepath) === -1 && filelist.dirs.push(filepath);\n                  fsPath.find(filepath, filter, function (err, files) {\n                    if (err) {\n                      callback && callback(err);\n                    } else {\n                      files.dirs.forEach(function (_dir) {\n                        filelist.dirs.indexOf(_dir) === -1 && filelist.dirs.push(_dir);\n                      });\n                      filelist.files = filelist.files.concat(files.files);\n                      callback && callback(null);\n                    }\n                  });\n                } else {\n                  callback && callback(null);\n                }\n              } else if (stats.isFile()) {\n                if (!filter || filter(filepath, 'file', file)) {\n                  filelist.files.push(filepath);\n                }\n                callback && callback(null);\n              } else {\n                callback && callback(null);\n              }\n            }\n          });\n        }, function (err) {\n          if (err) {\n            callback && callback(err);\n          } else {\n            callback && callback(null, filelist);\n          }\n        });\n      }\n    });\n  },\n  findSync: function (from, filter) {\n    var filelist = {\n      dirs: [],\n      files: []\n    };\n    fs.readdirSync(from).forEach(function (file) {\n      var filepath = path.join(from, file);\n      var stats = fs.lstatSync(filepath);\n      if (stats.isDirectory()) {\n        if (!filter || filter(filepath, 'directory', file)) {\n          filelist.dirs.indexOf(filepath) === -1 && filelist.dirs.push(filepath);\n          var files = fsPath.findSync(filepath, filter);\n          files.dirs.forEach(function (_dir) {\n            filelist.dirs.indexOf(_dir) === -1 && filelist.dirs.push(_dir);\n          });\n          filelist.files = filelist.files.concat(files.files);\n        }\n      } else if (stats.isFile()) {\n        if (!filter || filter(filepath, 'file', file)) {\n          filelist.files.push(filepath);\n        }\n      }\n    });\n    return filelist;\n  },\n  writeFile: function (dist, content, encoding, callback) {\n    dist = path.resolve(dist);\n    if (typeof encoding === 'function') {\n      callback = encoding;\n      encoding = 'utf-8';\n    }\n    fsPath.mkdir(path.dirname(dist), function (err) {\n      if (err) {\n        callback(err);\n      } else {\n        fs.writeFile(dist, content, {\n          encoding: encoding\n        }, callback);\n      }\n    });\n  },\n  writeFileSync: function (dist, content, encoding) {\n    dist = path.resolve(dist);\n    if (typeof encoding === 'function') {\n      callback = encoding;\n      encoding = 'utf-8';\n    }\n    fsPath.mkdirSync(path.dirname(dist));\n    fs.writeFileSync(dist, content, {\n      encoding: encoding\n    });\n  }\n};\nmodule.exports = fsPath;\n", "{\n  \"name\": \"fs-path\",\n  \"version\": \"0.0.24\",\n  \"main\": \"lib/index.js\",\n  \"author\": {\n    \"name\": \"pillys\",\n    \"email\": \"pillys@163.com\",\n    \"url\": \"http://www.qque.com\"\n  },\n  \"keywords\": [\n    \"fs-path\",\n    \"file\",\n    \"directory\"\n  ],\n  \"repository\": {\n    \"url\": \"https://github.com/pillys/fs-path\",\n    \"type\": \"git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/pillys/fs-path/issues\"\n  },\n  \"homepage\": \"https://github.com/pillys/fs-path\",\n  \"dependencies\": {\n    \"async\": \"~0.9.0\",\n    \"shell-escape\": \"^0.2.0\"\n  },\n  \"description\": \"file and directory op libs, find, findSync, mkdir, mkdirSync, copy, copySync, remove, removeSync, writeFile, writeFileSync\",\n  \"readmeFilename\": \"README.md\",\n  \"license\": \"MIT\"\n}\n"], "filenames": ["lib/index.js", "package.json"], "buggy_code_start_loc": [5, 24], "buggy_code_end_loc": [265, 30], "fixing_code_start_loc": [6, 24], "fixing_code_end_loc": [266, 31], "type": "CWE-77", "message": "fs-path node module before 0.0.25 is vulnerable to command injection by way of user-supplied inputs via the `copy`, `copySync`, `remove`, and `removeSync` methods.", "other": {"cve": {"id": "CVE-2020-8298", "sourceIdentifier": "support@hackerone.com", "published": "2021-03-04T20:15:13.800", "lastModified": "2021-03-09T15:20:38.090", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "fs-path node module before 0.0.25 is vulnerable to command injection by way of user-supplied inputs via the `copy`, `copySync`, `remove`, and `removeSync` methods."}, {"lang": "es", "value": "El m\u00f3dulo de nodo fs-path versi\u00f3n anterior a 0.0.25, es vulnerable a la inyecci\u00f3n de comandos mediante entradas suministradas por el usuario por medio de los m\u00e9todos \"copy\", \"copySync\", \"remove\" y \"removeSync\""}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 10.0}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-77"}]}, {"source": "support@hackerone.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-77"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fs-path_project:fs-path:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "0.0.25", "matchCriteriaId": "69704BDB-9054-47C1-8B9F-07835DEC40FF"}]}]}], "references": [{"url": "https://github.com/pillys/fs-path/commit/88ff5ee51046bb2c5d5e9c5afe6819b032092ce7", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pillys/fs-path/pull/6", "source": "support@hackerone.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://hackerone.com/reports/324491", "source": "support@hackerone.com", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pillys/fs-path/commit/88ff5ee51046bb2c5d5e9c5afe6819b032092ce7"}}