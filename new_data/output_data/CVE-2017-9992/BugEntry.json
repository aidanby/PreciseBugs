{"buggy_code": ["/*\n * Chronomaster DFA Video Decoder\n * Copyright (c) 2011 Konstantin Shishkov\n * based on work by Vladimir \"VAG\" Gneushev\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include <inttypes.h>\n\n#include \"avcodec.h\"\n#include \"bytestream.h\"\n#include \"internal.h\"\n\n#include \"libavutil/avassert.h\"\n#include \"libavutil/imgutils.h\"\n#include \"libavutil/mem.h\"\n\ntypedef struct DfaContext {\n    uint32_t pal[256];\n    uint8_t *frame_buf;\n} DfaContext;\n\nstatic av_cold int dfa_decode_init(AVCodecContext *avctx)\n{\n    DfaContext *s = avctx->priv_data;\n\n    avctx->pix_fmt = AV_PIX_FMT_PAL8;\n\n    if (!avctx->width || !avctx->height)\n        return AVERROR_INVALIDDATA;\n\n    av_assert0(av_image_check_size(avctx->width, avctx->height, 0, avctx) >= 0);\n\n    s->frame_buf = av_mallocz(avctx->width * avctx->height);\n    if (!s->frame_buf)\n        return AVERROR(ENOMEM);\n\n    return 0;\n}\n\nstatic int decode_copy(GetByteContext *gb, uint8_t *frame, int width, int height)\n{\n    const int size = width * height;\n\n    if (bytestream2_get_buffer(gb, frame, size) != size)\n        return AVERROR_INVALIDDATA;\n    return 0;\n}\n\nstatic int decode_tsw1(GetByteContext *gb, uint8_t *frame, int width, int height)\n{\n    const uint8_t *frame_start = frame;\n    const uint8_t *frame_end   = frame + width * height;\n    int mask = 0x10000, bitbuf = 0;\n    int v, count, segments;\n    unsigned offset;\n\n    segments = bytestream2_get_le32(gb);\n    offset   = bytestream2_get_le32(gb);\n    if (segments == 0 && offset == frame_end - frame)\n        return 0; // skip frame\n    if (frame_end - frame <= offset)\n        return AVERROR_INVALIDDATA;\n    frame += offset;\n    while (segments--) {\n        if (bytestream2_get_bytes_left(gb) < 2)\n            return AVERROR_INVALIDDATA;\n        if (mask == 0x10000) {\n            bitbuf = bytestream2_get_le16u(gb);\n            mask = 1;\n        }\n        if (frame_end - frame < 2)\n            return AVERROR_INVALIDDATA;\n        if (bitbuf & mask) {\n            v = bytestream2_get_le16(gb);\n            offset = (v & 0x1FFF) << 1;\n            count = ((v >> 13) + 2) << 1;\n            if (frame - frame_start < offset || frame_end - frame < count)\n                return AVERROR_INVALIDDATA;\n            av_memcpy_backptr(frame, offset, count);\n            frame += count;\n        } else {\n            *frame++ = bytestream2_get_byte(gb);\n            *frame++ = bytestream2_get_byte(gb);\n        }\n        mask <<= 1;\n    }\n\n    return 0;\n}\n\nstatic int decode_dsw1(GetByteContext *gb, uint8_t *frame, int width, int height)\n{\n    const uint8_t *frame_start = frame;\n    const uint8_t *frame_end   = frame + width * height;\n    int mask = 0x10000, bitbuf = 0;\n    int v, offset, count, segments;\n\n    segments = bytestream2_get_le16(gb);\n    while (segments--) {\n        if (bytestream2_get_bytes_left(gb) < 2)\n            return AVERROR_INVALIDDATA;\n        if (mask == 0x10000) {\n            bitbuf = bytestream2_get_le16u(gb);\n            mask = 1;\n        }\n        if (frame_end - frame < 2)\n            return AVERROR_INVALIDDATA;\n        if (bitbuf & mask) {\n            v = bytestream2_get_le16(gb);\n            offset = (v & 0x1FFF) << 1;\n            count = ((v >> 13) + 2) << 1;\n            if (frame - frame_start < offset || frame_end - frame < count)\n                return AVERROR_INVALIDDATA;\n            av_memcpy_backptr(frame, offset, count);\n            frame += count;\n        } else if (bitbuf & (mask << 1)) {\n            frame += bytestream2_get_le16(gb);\n        } else {\n            *frame++ = bytestream2_get_byte(gb);\n            *frame++ = bytestream2_get_byte(gb);\n        }\n        mask <<= 2;\n    }\n\n    return 0;\n}\n\nstatic int decode_dds1(GetByteContext *gb, uint8_t *frame, int width, int height)\n{\n    const uint8_t *frame_start = frame;\n    const uint8_t *frame_end   = frame + width * height;\n    int mask = 0x10000, bitbuf = 0;\n    int i, v, offset, count, segments;\n\n    segments = bytestream2_get_le16(gb);\n    while (segments--) {\n        if (bytestream2_get_bytes_left(gb) < 2)\n            return AVERROR_INVALIDDATA;\n        if (mask == 0x10000) {\n            bitbuf = bytestream2_get_le16u(gb);\n            mask = 1;\n        }\n\n        if (bitbuf & mask) {\n            v = bytestream2_get_le16(gb);\n            offset = (v & 0x1FFF) << 2;\n            count = ((v >> 13) + 2) << 1;\n            if (frame - frame_start < offset || frame_end - frame < count*2 + width)\n                return AVERROR_INVALIDDATA;\n            for (i = 0; i < count; i++) {\n                frame[0] = frame[1] =\n                frame[width] = frame[width + 1] = frame[-offset];\n\n                frame += 2;\n            }\n        } else if (bitbuf & (mask << 1)) {\n            v = bytestream2_get_le16(gb)*2;\n            if (frame - frame_end < v)\n                return AVERROR_INVALIDDATA;\n            frame += v;\n        } else {\n            if (frame_end - frame < width + 3)\n                return AVERROR_INVALIDDATA;\n            frame[0] = frame[1] =\n            frame[width] = frame[width + 1] =  bytestream2_get_byte(gb);\n            frame += 2;\n            frame[0] = frame[1] =\n            frame[width] = frame[width + 1] =  bytestream2_get_byte(gb);\n            frame += 2;\n        }\n        mask <<= 2;\n    }\n\n    return 0;\n}\n\nstatic int decode_bdlt(GetByteContext *gb, uint8_t *frame, int width, int height)\n{\n    uint8_t *line_ptr;\n    int count, lines, segments;\n\n    count = bytestream2_get_le16(gb);\n    if (count >= height)\n        return AVERROR_INVALIDDATA;\n    frame += width * count;\n    lines = bytestream2_get_le16(gb);\n    if (count + lines > height)\n        return AVERROR_INVALIDDATA;\n\n    while (lines--) {\n        if (bytestream2_get_bytes_left(gb) < 1)\n            return AVERROR_INVALIDDATA;\n        line_ptr = frame;\n        frame += width;\n        segments = bytestream2_get_byteu(gb);\n        while (segments--) {\n            if (frame - line_ptr <= bytestream2_peek_byte(gb))\n                return AVERROR_INVALIDDATA;\n            line_ptr += bytestream2_get_byte(gb);\n            count = (int8_t)bytestream2_get_byte(gb);\n            if (count >= 0) {\n                if (frame - line_ptr < count)\n                    return AVERROR_INVALIDDATA;\n                if (bytestream2_get_buffer(gb, line_ptr, count) != count)\n                    return AVERROR_INVALIDDATA;\n            } else {\n                count = -count;\n                if (frame - line_ptr < count)\n                    return AVERROR_INVALIDDATA;\n                memset(line_ptr, bytestream2_get_byte(gb), count);\n            }\n            line_ptr += count;\n        }\n    }\n\n    return 0;\n}\n\nstatic int decode_wdlt(GetByteContext *gb, uint8_t *frame, int width, int height)\n{\n    const uint8_t *frame_end   = frame + width * height;\n    uint8_t *line_ptr;\n    int count, i, v, lines, segments;\n    int y = 0;\n\n    lines = bytestream2_get_le16(gb);\n    if (lines > height)\n        return AVERROR_INVALIDDATA;\n\n    while (lines--) {\n        if (bytestream2_get_bytes_left(gb) < 2)\n            return AVERROR_INVALIDDATA;\n        segments = bytestream2_get_le16u(gb);\n        while ((segments & 0xC000) == 0xC000) {\n            unsigned skip_lines = -(int16_t)segments;\n            unsigned delta = -((int16_t)segments * width);\n            if (frame_end - frame <= delta || y + lines + skip_lines > height)\n                return AVERROR_INVALIDDATA;\n            frame    += delta;\n            y        += skip_lines;\n            segments = bytestream2_get_le16(gb);\n        }\n\n        if (frame_end <= frame)\n            return AVERROR_INVALIDDATA;\n        if (segments & 0x8000) {\n            frame[width - 1] = segments & 0xFF;\n            segments = bytestream2_get_le16(gb);\n        }\n        line_ptr = frame;\n        if (frame_end - frame < width)\n            return AVERROR_INVALIDDATA;\n        frame += width;\n        y++;\n        while (segments--) {\n            if (frame - line_ptr <= bytestream2_peek_byte(gb))\n                return AVERROR_INVALIDDATA;\n            line_ptr += bytestream2_get_byte(gb);\n            count = (int8_t)bytestream2_get_byte(gb);\n            if (count >= 0) {\n                if (frame - line_ptr < count * 2)\n                    return AVERROR_INVALIDDATA;\n                if (bytestream2_get_buffer(gb, line_ptr, count * 2) != count * 2)\n                    return AVERROR_INVALIDDATA;\n                line_ptr += count * 2;\n            } else {\n                count = -count;\n                if (frame - line_ptr < count * 2)\n                    return AVERROR_INVALIDDATA;\n                v = bytestream2_get_le16(gb);\n                for (i = 0; i < count; i++)\n                    bytestream_put_le16(&line_ptr, v);\n            }\n        }\n    }\n\n    return 0;\n}\n\nstatic int decode_tdlt(GetByteContext *gb, uint8_t *frame, int width, int height)\n{\n    const uint8_t *frame_end = frame + width * height;\n    uint32_t segments = bytestream2_get_le32(gb);\n    int skip, copy;\n\n    while (segments--) {\n        if (bytestream2_get_bytes_left(gb) < 2)\n            return AVERROR_INVALIDDATA;\n        copy = bytestream2_get_byteu(gb) * 2;\n        skip = bytestream2_get_byteu(gb) * 2;\n        if (frame_end - frame < copy + skip ||\n            bytestream2_get_bytes_left(gb) < copy)\n            return AVERROR_INVALIDDATA;\n        frame += skip;\n        bytestream2_get_buffer(gb, frame, copy);\n        frame += copy;\n    }\n\n    return 0;\n}\n\nstatic int decode_blck(GetByteContext *gb, uint8_t *frame, int width, int height)\n{\n    memset(frame, 0, width * height);\n    return 0;\n}\n\n\ntypedef int (*chunk_decoder)(GetByteContext *gb, uint8_t *frame, int width, int height);\n\nstatic const chunk_decoder decoder[8] = {\n    decode_copy, decode_tsw1, decode_bdlt, decode_wdlt,\n    decode_tdlt, decode_dsw1, decode_blck, decode_dds1,\n};\n\nstatic const char* chunk_name[8] = {\n    \"COPY\", \"TSW1\", \"BDLT\", \"WDLT\", \"TDLT\", \"DSW1\", \"BLCK\", \"DDS1\"\n};\n\nstatic int dfa_decode_frame(AVCodecContext *avctx,\n                            void *data, int *got_frame,\n                            AVPacket *avpkt)\n{\n    AVFrame *frame = data;\n    DfaContext *s = avctx->priv_data;\n    GetByteContext gb;\n    const uint8_t *buf = avpkt->data;\n    uint32_t chunk_type, chunk_size;\n    uint8_t *dst;\n    int ret;\n    int i, pal_elems;\n    int version = avctx->extradata_size==2 ? AV_RL16(avctx->extradata) : 0;\n\n    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)\n        return ret;\n\n    bytestream2_init(&gb, avpkt->data, avpkt->size);\n    while (bytestream2_get_bytes_left(&gb) > 0) {\n        bytestream2_skip(&gb, 4);\n        chunk_size = bytestream2_get_le32(&gb);\n        chunk_type = bytestream2_get_le32(&gb);\n        if (!chunk_type)\n            break;\n        if (chunk_type == 1) {\n            pal_elems = FFMIN(chunk_size / 3, 256);\n            for (i = 0; i < pal_elems; i++) {\n                s->pal[i] = bytestream2_get_be24(&gb) << 2;\n                s->pal[i] |= 0xFFU << 24 | (s->pal[i] >> 6) & 0x30303;\n            }\n            frame->palette_has_changed = 1;\n        } else if (chunk_type <= 9) {\n            if (decoder[chunk_type - 2](&gb, s->frame_buf, avctx->width, avctx->height)) {\n                av_log(avctx, AV_LOG_ERROR, \"Error decoding %s chunk\\n\",\n                       chunk_name[chunk_type - 2]);\n                return AVERROR_INVALIDDATA;\n            }\n        } else {\n            av_log(avctx, AV_LOG_WARNING,\n                   \"Ignoring unknown chunk type %\"PRIu32\"\\n\",\n                   chunk_type);\n        }\n        buf += chunk_size;\n    }\n\n    buf = s->frame_buf;\n    dst = frame->data[0];\n    for (i = 0; i < avctx->height; i++) {\n        if(version == 0x100) {\n            int j;\n            for(j = 0; j < avctx->width; j++) {\n                dst[j] = buf[ (i&3)*(avctx->width /4) + (j/4) +\n                             ((j&3)*(avctx->height/4) + (i/4))*avctx->width];\n            }\n        } else {\n            memcpy(dst, buf, avctx->width);\n            buf += avctx->width;\n        }\n        dst += frame->linesize[0];\n    }\n    memcpy(frame->data[1], s->pal, sizeof(s->pal));\n\n    *got_frame = 1;\n\n    return avpkt->size;\n}\n\nstatic av_cold int dfa_decode_end(AVCodecContext *avctx)\n{\n    DfaContext *s = avctx->priv_data;\n\n    av_freep(&s->frame_buf);\n\n    return 0;\n}\n\nAVCodec ff_dfa_decoder = {\n    .name           = \"dfa\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Chronomaster DFA\"),\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_DFA,\n    .priv_data_size = sizeof(DfaContext),\n    .init           = dfa_decode_init,\n    .close          = dfa_decode_end,\n    .decode         = dfa_decode_frame,\n    .capabilities   = AV_CODEC_CAP_DR1,\n};\n"], "fixing_code": ["/*\n * Chronomaster DFA Video Decoder\n * Copyright (c) 2011 Konstantin Shishkov\n * based on work by Vladimir \"VAG\" Gneushev\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include <inttypes.h>\n\n#include \"avcodec.h\"\n#include \"bytestream.h\"\n#include \"internal.h\"\n\n#include \"libavutil/avassert.h\"\n#include \"libavutil/imgutils.h\"\n#include \"libavutil/mem.h\"\n\ntypedef struct DfaContext {\n    uint32_t pal[256];\n    uint8_t *frame_buf;\n} DfaContext;\n\nstatic av_cold int dfa_decode_init(AVCodecContext *avctx)\n{\n    DfaContext *s = avctx->priv_data;\n\n    avctx->pix_fmt = AV_PIX_FMT_PAL8;\n\n    if (!avctx->width || !avctx->height)\n        return AVERROR_INVALIDDATA;\n\n    av_assert0(av_image_check_size(avctx->width, avctx->height, 0, avctx) >= 0);\n\n    s->frame_buf = av_mallocz(avctx->width * avctx->height);\n    if (!s->frame_buf)\n        return AVERROR(ENOMEM);\n\n    return 0;\n}\n\nstatic int decode_copy(GetByteContext *gb, uint8_t *frame, int width, int height)\n{\n    const int size = width * height;\n\n    if (bytestream2_get_buffer(gb, frame, size) != size)\n        return AVERROR_INVALIDDATA;\n    return 0;\n}\n\nstatic int decode_tsw1(GetByteContext *gb, uint8_t *frame, int width, int height)\n{\n    const uint8_t *frame_start = frame;\n    const uint8_t *frame_end   = frame + width * height;\n    int mask = 0x10000, bitbuf = 0;\n    int v, count, segments;\n    unsigned offset;\n\n    segments = bytestream2_get_le32(gb);\n    offset   = bytestream2_get_le32(gb);\n    if (segments == 0 && offset == frame_end - frame)\n        return 0; // skip frame\n    if (frame_end - frame <= offset)\n        return AVERROR_INVALIDDATA;\n    frame += offset;\n    while (segments--) {\n        if (bytestream2_get_bytes_left(gb) < 2)\n            return AVERROR_INVALIDDATA;\n        if (mask == 0x10000) {\n            bitbuf = bytestream2_get_le16u(gb);\n            mask = 1;\n        }\n        if (frame_end - frame < 2)\n            return AVERROR_INVALIDDATA;\n        if (bitbuf & mask) {\n            v = bytestream2_get_le16(gb);\n            offset = (v & 0x1FFF) << 1;\n            count = ((v >> 13) + 2) << 1;\n            if (frame - frame_start < offset || frame_end - frame < count)\n                return AVERROR_INVALIDDATA;\n            av_memcpy_backptr(frame, offset, count);\n            frame += count;\n        } else {\n            *frame++ = bytestream2_get_byte(gb);\n            *frame++ = bytestream2_get_byte(gb);\n        }\n        mask <<= 1;\n    }\n\n    return 0;\n}\n\nstatic int decode_dsw1(GetByteContext *gb, uint8_t *frame, int width, int height)\n{\n    const uint8_t *frame_start = frame;\n    const uint8_t *frame_end   = frame + width * height;\n    int mask = 0x10000, bitbuf = 0;\n    int v, offset, count, segments;\n\n    segments = bytestream2_get_le16(gb);\n    while (segments--) {\n        if (bytestream2_get_bytes_left(gb) < 2)\n            return AVERROR_INVALIDDATA;\n        if (mask == 0x10000) {\n            bitbuf = bytestream2_get_le16u(gb);\n            mask = 1;\n        }\n        if (frame_end - frame < 2)\n            return AVERROR_INVALIDDATA;\n        if (bitbuf & mask) {\n            v = bytestream2_get_le16(gb);\n            offset = (v & 0x1FFF) << 1;\n            count = ((v >> 13) + 2) << 1;\n            if (frame - frame_start < offset || frame_end - frame < count)\n                return AVERROR_INVALIDDATA;\n            av_memcpy_backptr(frame, offset, count);\n            frame += count;\n        } else if (bitbuf & (mask << 1)) {\n            frame += bytestream2_get_le16(gb);\n        } else {\n            *frame++ = bytestream2_get_byte(gb);\n            *frame++ = bytestream2_get_byte(gb);\n        }\n        mask <<= 2;\n    }\n\n    return 0;\n}\n\nstatic int decode_dds1(GetByteContext *gb, uint8_t *frame, int width, int height)\n{\n    const uint8_t *frame_start = frame;\n    const uint8_t *frame_end   = frame + width * height;\n    int mask = 0x10000, bitbuf = 0;\n    int i, v, offset, count, segments;\n\n    segments = bytestream2_get_le16(gb);\n    while (segments--) {\n        if (bytestream2_get_bytes_left(gb) < 2)\n            return AVERROR_INVALIDDATA;\n        if (mask == 0x10000) {\n            bitbuf = bytestream2_get_le16u(gb);\n            mask = 1;\n        }\n\n        if (bitbuf & mask) {\n            v = bytestream2_get_le16(gb);\n            offset = (v & 0x1FFF) << 2;\n            count = ((v >> 13) + 2) << 1;\n            if (frame - frame_start < offset || frame_end - frame < count*2 + width)\n                return AVERROR_INVALIDDATA;\n            for (i = 0; i < count; i++) {\n                frame[0] = frame[1] =\n                frame[width] = frame[width + 1] = frame[-offset];\n\n                frame += 2;\n            }\n        } else if (bitbuf & (mask << 1)) {\n            v = bytestream2_get_le16(gb)*2;\n            if (frame - frame_end < v)\n                return AVERROR_INVALIDDATA;\n            frame += v;\n        } else {\n            if (frame_end - frame < width + 4)\n                return AVERROR_INVALIDDATA;\n            frame[0] = frame[1] =\n            frame[width] = frame[width + 1] =  bytestream2_get_byte(gb);\n            frame += 2;\n            frame[0] = frame[1] =\n            frame[width] = frame[width + 1] =  bytestream2_get_byte(gb);\n            frame += 2;\n        }\n        mask <<= 2;\n    }\n\n    return 0;\n}\n\nstatic int decode_bdlt(GetByteContext *gb, uint8_t *frame, int width, int height)\n{\n    uint8_t *line_ptr;\n    int count, lines, segments;\n\n    count = bytestream2_get_le16(gb);\n    if (count >= height)\n        return AVERROR_INVALIDDATA;\n    frame += width * count;\n    lines = bytestream2_get_le16(gb);\n    if (count + lines > height)\n        return AVERROR_INVALIDDATA;\n\n    while (lines--) {\n        if (bytestream2_get_bytes_left(gb) < 1)\n            return AVERROR_INVALIDDATA;\n        line_ptr = frame;\n        frame += width;\n        segments = bytestream2_get_byteu(gb);\n        while (segments--) {\n            if (frame - line_ptr <= bytestream2_peek_byte(gb))\n                return AVERROR_INVALIDDATA;\n            line_ptr += bytestream2_get_byte(gb);\n            count = (int8_t)bytestream2_get_byte(gb);\n            if (count >= 0) {\n                if (frame - line_ptr < count)\n                    return AVERROR_INVALIDDATA;\n                if (bytestream2_get_buffer(gb, line_ptr, count) != count)\n                    return AVERROR_INVALIDDATA;\n            } else {\n                count = -count;\n                if (frame - line_ptr < count)\n                    return AVERROR_INVALIDDATA;\n                memset(line_ptr, bytestream2_get_byte(gb), count);\n            }\n            line_ptr += count;\n        }\n    }\n\n    return 0;\n}\n\nstatic int decode_wdlt(GetByteContext *gb, uint8_t *frame, int width, int height)\n{\n    const uint8_t *frame_end   = frame + width * height;\n    uint8_t *line_ptr;\n    int count, i, v, lines, segments;\n    int y = 0;\n\n    lines = bytestream2_get_le16(gb);\n    if (lines > height)\n        return AVERROR_INVALIDDATA;\n\n    while (lines--) {\n        if (bytestream2_get_bytes_left(gb) < 2)\n            return AVERROR_INVALIDDATA;\n        segments = bytestream2_get_le16u(gb);\n        while ((segments & 0xC000) == 0xC000) {\n            unsigned skip_lines = -(int16_t)segments;\n            unsigned delta = -((int16_t)segments * width);\n            if (frame_end - frame <= delta || y + lines + skip_lines > height)\n                return AVERROR_INVALIDDATA;\n            frame    += delta;\n            y        += skip_lines;\n            segments = bytestream2_get_le16(gb);\n        }\n\n        if (frame_end <= frame)\n            return AVERROR_INVALIDDATA;\n        if (segments & 0x8000) {\n            frame[width - 1] = segments & 0xFF;\n            segments = bytestream2_get_le16(gb);\n        }\n        line_ptr = frame;\n        if (frame_end - frame < width)\n            return AVERROR_INVALIDDATA;\n        frame += width;\n        y++;\n        while (segments--) {\n            if (frame - line_ptr <= bytestream2_peek_byte(gb))\n                return AVERROR_INVALIDDATA;\n            line_ptr += bytestream2_get_byte(gb);\n            count = (int8_t)bytestream2_get_byte(gb);\n            if (count >= 0) {\n                if (frame - line_ptr < count * 2)\n                    return AVERROR_INVALIDDATA;\n                if (bytestream2_get_buffer(gb, line_ptr, count * 2) != count * 2)\n                    return AVERROR_INVALIDDATA;\n                line_ptr += count * 2;\n            } else {\n                count = -count;\n                if (frame - line_ptr < count * 2)\n                    return AVERROR_INVALIDDATA;\n                v = bytestream2_get_le16(gb);\n                for (i = 0; i < count; i++)\n                    bytestream_put_le16(&line_ptr, v);\n            }\n        }\n    }\n\n    return 0;\n}\n\nstatic int decode_tdlt(GetByteContext *gb, uint8_t *frame, int width, int height)\n{\n    const uint8_t *frame_end = frame + width * height;\n    uint32_t segments = bytestream2_get_le32(gb);\n    int skip, copy;\n\n    while (segments--) {\n        if (bytestream2_get_bytes_left(gb) < 2)\n            return AVERROR_INVALIDDATA;\n        copy = bytestream2_get_byteu(gb) * 2;\n        skip = bytestream2_get_byteu(gb) * 2;\n        if (frame_end - frame < copy + skip ||\n            bytestream2_get_bytes_left(gb) < copy)\n            return AVERROR_INVALIDDATA;\n        frame += skip;\n        bytestream2_get_buffer(gb, frame, copy);\n        frame += copy;\n    }\n\n    return 0;\n}\n\nstatic int decode_blck(GetByteContext *gb, uint8_t *frame, int width, int height)\n{\n    memset(frame, 0, width * height);\n    return 0;\n}\n\n\ntypedef int (*chunk_decoder)(GetByteContext *gb, uint8_t *frame, int width, int height);\n\nstatic const chunk_decoder decoder[8] = {\n    decode_copy, decode_tsw1, decode_bdlt, decode_wdlt,\n    decode_tdlt, decode_dsw1, decode_blck, decode_dds1,\n};\n\nstatic const char* chunk_name[8] = {\n    \"COPY\", \"TSW1\", \"BDLT\", \"WDLT\", \"TDLT\", \"DSW1\", \"BLCK\", \"DDS1\"\n};\n\nstatic int dfa_decode_frame(AVCodecContext *avctx,\n                            void *data, int *got_frame,\n                            AVPacket *avpkt)\n{\n    AVFrame *frame = data;\n    DfaContext *s = avctx->priv_data;\n    GetByteContext gb;\n    const uint8_t *buf = avpkt->data;\n    uint32_t chunk_type, chunk_size;\n    uint8_t *dst;\n    int ret;\n    int i, pal_elems;\n    int version = avctx->extradata_size==2 ? AV_RL16(avctx->extradata) : 0;\n\n    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)\n        return ret;\n\n    bytestream2_init(&gb, avpkt->data, avpkt->size);\n    while (bytestream2_get_bytes_left(&gb) > 0) {\n        bytestream2_skip(&gb, 4);\n        chunk_size = bytestream2_get_le32(&gb);\n        chunk_type = bytestream2_get_le32(&gb);\n        if (!chunk_type)\n            break;\n        if (chunk_type == 1) {\n            pal_elems = FFMIN(chunk_size / 3, 256);\n            for (i = 0; i < pal_elems; i++) {\n                s->pal[i] = bytestream2_get_be24(&gb) << 2;\n                s->pal[i] |= 0xFFU << 24 | (s->pal[i] >> 6) & 0x30303;\n            }\n            frame->palette_has_changed = 1;\n        } else if (chunk_type <= 9) {\n            if (decoder[chunk_type - 2](&gb, s->frame_buf, avctx->width, avctx->height)) {\n                av_log(avctx, AV_LOG_ERROR, \"Error decoding %s chunk\\n\",\n                       chunk_name[chunk_type - 2]);\n                return AVERROR_INVALIDDATA;\n            }\n        } else {\n            av_log(avctx, AV_LOG_WARNING,\n                   \"Ignoring unknown chunk type %\"PRIu32\"\\n\",\n                   chunk_type);\n        }\n        buf += chunk_size;\n    }\n\n    buf = s->frame_buf;\n    dst = frame->data[0];\n    for (i = 0; i < avctx->height; i++) {\n        if(version == 0x100) {\n            int j;\n            for(j = 0; j < avctx->width; j++) {\n                dst[j] = buf[ (i&3)*(avctx->width /4) + (j/4) +\n                             ((j&3)*(avctx->height/4) + (i/4))*avctx->width];\n            }\n        } else {\n            memcpy(dst, buf, avctx->width);\n            buf += avctx->width;\n        }\n        dst += frame->linesize[0];\n    }\n    memcpy(frame->data[1], s->pal, sizeof(s->pal));\n\n    *got_frame = 1;\n\n    return avpkt->size;\n}\n\nstatic av_cold int dfa_decode_end(AVCodecContext *avctx)\n{\n    DfaContext *s = avctx->priv_data;\n\n    av_freep(&s->frame_buf);\n\n    return 0;\n}\n\nAVCodec ff_dfa_decoder = {\n    .name           = \"dfa\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Chronomaster DFA\"),\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_DFA,\n    .priv_data_size = sizeof(DfaContext),\n    .init           = dfa_decode_init,\n    .close          = dfa_decode_end,\n    .decode         = dfa_decode_frame,\n    .capabilities   = AV_CODEC_CAP_DR1,\n};\n"], "filenames": ["libavcodec/dfa.c"], "buggy_code_start_loc": [178], "buggy_code_end_loc": [179], "fixing_code_start_loc": [178], "fixing_code_end_loc": [179], "type": "CWE-119", "message": "Heap-based buffer overflow in the decode_dds1 function in libavcodec/dfa.c in FFmpeg before 2.8.12, 3.0.x before 3.0.8, 3.1.x before 3.1.8, 3.2.x before 3.2.5, and 3.3.x before 3.3.1 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted file.", "other": {"cve": {"id": "CVE-2017-9992", "sourceIdentifier": "cve@mitre.org", "published": "2017-06-28T06:29:00.487", "lastModified": "2019-03-20T18:18:14.037", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Heap-based buffer overflow in the decode_dds1 function in libavcodec/dfa.c in FFmpeg before 2.8.12, 3.0.x before 3.0.8, 3.1.x before 3.1.8, 3.2.x before 3.2.5, and 3.3.x before 3.3.1 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted file."}, {"lang": "es", "value": "Buffer overflow en la memoria din\u00e1mica -heap- en la funci\u00f3n decode_dds1 en el archivo libavcodec/dfa.c en Ffmpeg en sus versiones anteriores a la 2.8.12, 3.0.x en sus versiones anteriores a la 3.0.8, 3.1.x en sus versiones anteriores a la 3.1.8, 3.2.x en sus versiones anteriores a la 3.2.5 y 3.3.x en sus versiones anteriores a la 3.3.1 permite a un atacante remoto provocar una denegaci\u00f3n de servicio (ca\u00edda de la aplicaci\u00f3n) o otro posible impacto no especificado mediante la manipulaci\u00f3n del archivo."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.8.12", "matchCriteriaId": "941B47E5-FDBB-437A-8A4D-A9788019E5EC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0", "versionEndExcluding": "3.0.8", "matchCriteriaId": "23E6910A-C467-44FD-B9CA-3D6049AFB1BF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.1", "versionEndExcluding": "3.1.8", "matchCriteriaId": "58FFC631-648C-44BE-9EE5-CF3210E632C0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.2", "versionEndExcluding": "3.2.5", "matchCriteriaId": "248F96A2-0FAF-4737-8011-3ACAC8115829"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.3", "versionEndExcluding": "3.3.1", "matchCriteriaId": "F0E75E33-237A-43F9-9193-002687E3470D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-4012", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/99319", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=1345", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/f52fbf4f3ed02a7d872d8a102006f29b4421f360", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/f52fbf4f3ed02a7d872d8a102006f29b4421f360"}}