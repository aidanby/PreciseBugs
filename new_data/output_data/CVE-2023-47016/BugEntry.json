{"buggy_code": ["/* radare2 - LGPL - Copyright 2019-2023 - mrmacete */\n\n#include <r_types.h>\n#include <r_util.h>\n#include <r_lib.h>\n#include <r_bin.h>\n#include <r_core.h>\n#include <r_syscall.h>\n\n#define R_BIN_MACH064 1\n#include \"../format/mach0/mach0.h\"\n\n#include \"../format/xnu/r_cf_dict.h\"\n#include \"../format/xnu/mig_index.h\"\n#include \"../format/mach0/mach064_is_kernelcache.c\"\n\ntypedef bool (*ROnRebaseFunc) (ut64 offset, ut64 decorated_addr, void *user_data);\n\ntypedef struct _RKernelCacheObj {\n\tRBuffer *cache_buf;\n\tRCFValueDict *prelink_info;\n\tut64 pa2va_exec;\n\tut64 pa2va_data;\n\tstruct _RKextIndex *kexts;\n\tstruct MACH0_(obj_t) *mach0;\n\tstruct _RRebaseInfo *rebase_info;\n\tint (*original_io_read)(RIO *io, RIODesc *fd, ut8 *buf, int count);\n\tbool rebase_info_populated;\n\tbool rebasing_buffer;\n\tbool kexts_initialized;\n\tut8 *internal_buffer;\n\tint internal_buffer_size;\n} RKernelCacheObj;\n\ntypedef struct _RFileRange {\n\tut64 offset;\n\tut64 size;\n} RFileRange;\n\ntypedef struct _RPrelinkRange {\n\tRFileRange range;\n\tut64 pa2va_exec;\n\tut64 pa2va_data;\n} RPrelinkRange;\n\ntypedef struct _RStubsInfo {\n\tRFileRange got;\n\tRFileRange stubs;\n\tut64 got_addr;\n} RStubsInfo;\n\ntypedef struct _RKext {\n\tRFileRange range;\n\tRFileRange text_range;\n\tchar *name;\n\tut64 mod_info;\n\tut64 vaddr;\n\tstruct MACH0_(obj_t) *mach0;\n\tbool own_name;\n\tut64 pa2va_exec;\n\tut64 pa2va_data;\n} RKext;\n\ntypedef struct _RKextIndex {\n\tut64 length;\n\tRKext **entries;\n} RKextIndex;\n\ntypedef struct _RRebaseInfo {\n\tRFileRange *ranges;\n\tut64 n_ranges;\n\tut64 multiplier;\n\tut64 kernel_base;\n} RRebaseInfo;\n\ntypedef struct _RRebaseCtx {\n\tut64 off, eob;\n\tut8 *buf;\n\tint count;\n\tRKernelCacheObj *obj;\n} RRebaseCtx;\n\ntypedef struct _RParsedPointer {\n\tut64 address;\n} RParsedPointer;\n\ntypedef struct _RKmodInfo {\n\tchar name[0x41];\n\tut64 start;\n} RKmodInfo;\n\n#define KEXT_SHORT_NAME_FROM_SECTION(io_section) ({\\\n\tchar *result = NULL;\\\n\tchar *clone = strdup (io_section->name);\\\n\tchar *cursor = strstr (clone, \"__\");\\\n\tif (cursor) {\\\n\t\tcursor--;\\\n\t\t*cursor = 0;\\\n\t\tcursor--;\\\n\t\tcursor = strrchr (cursor, '.');\\\n\t\tif (cursor) {\\\n\t\t\t*cursor = 0;\\\n\t\t\tcursor = strrchr (cursor, '.');\\\n\t\t\tif (cursor) {\\\n\t\t\t\tresult = strdup (cursor + 1);\\\n\t\t\t\tR_FREE (clone);\\\n\t\t\t}\\\n\t\t}\\\n\t}\\\n\tresult ? result : clone;\\\n})\n\n#define KEXT_INFER_VSIZE(index, i)\\\n\t((i+1 < index->length) ? index->entries[i+1]->vaddr - index->entries[i]->vaddr : UT64_MAX)\n\n#define KEXT_INFER_PSIZE(index, i)\\\n\t((i+1 < index->length) ? index->entries[i+1]->range.offset - index->entries[i]->range.offset : UT64_MAX)\n\n#define R_K_CONSTRUCTOR_TO_ENTRY 0\n#define R_K_CONSTRUCTOR_TO_SYMBOL 1\n\n#define K_PPTR(p) p_ptr (p, obj)\n#define K_RPTR(buf) r_ptr (buf, obj)\n\n#define IS_PTR_AUTH(x) ((x & (1ULL << 63)) != 0)\n#define IS_PTR_BIND(x) ((x & (1ULL << 62)) != 0)\n\nstatic ut64 p_ptr(ut64 decorated_addr, RKernelCacheObj *obj);\nstatic ut64 r_ptr(ut8 *buf, RKernelCacheObj *obj);\n\nstatic RRebaseInfo *r_rebase_info_new_from_mach0(RBuffer *cache_buf, struct MACH0_(obj_t) *mach0);\nstatic void r_rebase_info_free(RRebaseInfo *info);\nstatic void r_rebase_info_populate(RRebaseInfo *info, RKernelCacheObj *obj);\nstatic ut64 iterate_rebase_list(RBuffer *cache_buf, ut64 multiplier, ut64 start_offset, ROnRebaseFunc func, void *user_data);\nstatic ut64 r_rebase_offset_to_paddr(RKernelCacheObj *obj, const RVector *sections, ut64 offset);\nstatic void swizzle_io_read(RKernelCacheObj *obj, RIO *io);\nstatic int kernelcache_io_read(RIO *io, RIODesc *fd, ut8 *buf, int count);\nstatic void rebase_buffer(RKernelCacheObj *obj, ut64 off, RIODesc *fd, ut8 *buf, int count);\nstatic void rebase_buffer_fixup(RKernelCacheObj *kobj, ut64 off, RIODesc *fd, ut8 *buf, int count);\n\nstatic RPrelinkRange *get_prelink_info_range_from_mach0(struct MACH0_(obj_t) *mach0);\nstatic RList *filter_kexts(RKernelCacheObj *obj, RBinFile *bf);\nstatic RList *carve_kexts(RKernelCacheObj *obj, RBinFile *bf);\nstatic RList *kexts_from_load_commands(RKernelCacheObj *obj, RBinFile *bf);\n\nstatic void sections_from_mach0(RList *ret, struct MACH0_(obj_t) *mach0, RBinFile *bf, ut64 paddr, char *prefix, RKernelCacheObj *obj);\nstatic void handle_data_sections(RBinSection *sect);\nstatic void symbols_from_mach0(RList *ret, struct MACH0_(obj_t) *mach0, RBinFile *bf, ut64 paddr, int ordinal);\nstatic RList *resolve_syscalls(RKernelCacheObj *obj, ut64 enosys_addr);\nstatic RList *resolve_mig_subsystem(RKernelCacheObj *obj);\nstatic void symbols_from_stubs(RList *ret, HtPP *kernel_syms_by_addr, RKernelCacheObj *obj, RBinFile *bf, RKext *kext, int ordinal);\nstatic RStubsInfo *get_stubs_info(struct MACH0_(obj_t) *mach0, ut64 paddr, RKernelCacheObj *obj);\nstatic int prot2perm(int x);\n\nstatic void r_kext_free(RKext *kext);\nstatic void r_kext_fill_text_range(RKext *kext);\nstatic int kexts_sort_vaddr_func(const void *a, const void *b);\nstatic struct MACH0_(obj_t) *create_kext_mach0(RKernelCacheObj *obj, RKext *kext, RBinFile *bf);\nstatic struct MACH0_(obj_t) *create_kext_shared_mach0(RKernelCacheObj *obj, RKext *kext, RBinFile *bf);\n\n#define r_kext_index_foreach(index, i, item)\\\n\tif (index) for (i = 0; i < index->length && (item = index->entries[i], 1); i++)\n\nstatic RKextIndex *r_kext_index_new(RList *kexts);\nstatic void r_kext_index_free(RKextIndex *index);\nstatic RKext *r_kext_index_vget(RKextIndex *index, ut64 vaddr);\n\nstatic void process_kmod_init_term(RKernelCacheObj *obj, RKext *kext, RList *ret, ut64 **inits, ut64 **terms);\nstatic void create_initterm_syms(RKext *kext, RList *ret, int type, ut64 *pointers);\nstatic void process_constructors(RKernelCacheObj *obj, struct MACH0_(obj_t) *mach0, RList *ret, ut64 paddr, bool is_first, int mode, const char *prefix);\nstatic RBinAddr *newEntry(ut64 haddr, ut64 vaddr, int type);\nstatic void ensure_kexts_initialized(RKernelCacheObj *obj, RBinFile *bf);\n\nstatic void r_kernel_cache_free(RKernelCacheObj *obj);\n\nstatic R_TH_LOCAL RList *pending_bin_files = NULL;\n\nstatic bool load(RBinFile *bf, RBuffer *buf, ut64 loadaddr) {\n\tRBuffer *fbuf = r_buf_ref (buf);\n\tstruct MACH0_(opts_t) opts;\n\tMACH0_(opts_set_default) (&opts, bf);\n\tstruct MACH0_(obj_t) *main_mach0 = MACH0_(new_buf) (fbuf, &opts);\n\tif (!main_mach0) {\n\t\treturn false;\n\t}\n\n\tRRebaseInfo *rebase_info = r_rebase_info_new_from_mach0 (fbuf, main_mach0);\n\n\tRPrelinkRange *prelink_range = get_prelink_info_range_from_mach0 (main_mach0);\n\tif (!prelink_range) {\n\t\tgoto beach;\n\t}\n\n\tRKernelCacheObj *obj = R_NEW0 (RKernelCacheObj);\n\tif (!obj) {\n\t\tR_FREE (prelink_range);\n\t\tgoto beach;\n\t}\n\n\tconst bool is_modern = main_mach0->hdr.filetype == MH_FILESET ||\n\t\t(main_mach0->hdr.cputype == CPU_TYPE_ARM64 && main_mach0->hdr.cpusubtype == 0xc0000002);\n\n\tRCFValueDict *prelink_info = NULL;\n\tif (!is_modern && prelink_range->range.size) {\n\t\tprelink_info = r_cf_value_dict_parse (fbuf, prelink_range->range.offset,\n\t\t\t\tprelink_range->range.size, R_CF_OPTION_SKIP_NSDATA | R_CF_OPTION_SUPPORT_IDREF);\n\t\tif (!prelink_info) {\n\t\t\tR_FREE (prelink_range);\n\t\t\tR_FREE (obj);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\n\tif (!pending_bin_files) {\n\t\tpending_bin_files = r_list_new ();\n\t\tif (!pending_bin_files) {\n\t\t\tR_FREE (prelink_range);\n\t\t\tR_FREE (obj);\n\t\t\tR_FREE (prelink_info);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\n\tobj->mach0 = main_mach0;\n\tobj->rebase_info = rebase_info;\n\tobj->prelink_info = prelink_info;\n\tobj->cache_buf = fbuf;\n\tobj->pa2va_exec = prelink_range->pa2va_exec;\n\tobj->pa2va_data = prelink_range->pa2va_data;\n\tR_FREE (prelink_range);\n\tbf->bo->bin_obj = obj;\n\tr_list_push (pending_bin_files, bf);\n\n\tif (rebase_info || main_mach0->chained_starts) {\n\t\tRIO *io = bf->rbin->iob.io;\n\t\tswizzle_io_read (obj, io);\n\t}\n\n\treturn true;\n\nbeach:\n\tr_buf_free (fbuf);\n\tMACH0_(mach0_free) (main_mach0);\n\treturn false;\n}\n\nstatic void r_ptr_undecorate(RParsedPointer *ptr, ut64 decorated_addr, RKernelCacheObj *obj) {\n\t/*\n\t * Logic taken from:\n\t * https://github.com/Synacktiv/kernelcache-laundering/blob/master/ios12_kernel_cache_helper.py\n\t */\n\n\tif ((decorated_addr & 0x4000000000000000LL) == 0 && obj->rebase_info) {\n\t\tif (decorated_addr & 0x8000000000000000LL) {\n\t\t\tptr->address = obj->rebase_info->kernel_base + (decorated_addr & 0xFFFFFFFFLL);\n\t\t} else {\n\t\t\tptr->address = ((decorated_addr << 13) & 0xFF00000000000000LL) | (decorated_addr & 0x7ffffffffffLL);\n\t\t\tif (decorated_addr & 0x40000000000LL) {\n\t\t\t\tptr->address |= 0xfffc0000000000LL;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tptr->address = decorated_addr;\n\t}\n}\n\nstatic void ensure_kexts_initialized(RKernelCacheObj *obj, RBinFile *bf) {\n\tif (obj->kexts_initialized) {\n\t\treturn;\n\t}\n\tobj->kexts_initialized = true;\n\n\tRList *kexts = NULL;\n\n\tif (obj->prelink_info) {\n\t\tkexts = filter_kexts (obj, bf);\n\t}\n\n\tif (kexts && !r_list_length (kexts)) {\n\t\tr_list_free (kexts);\n\t\tkexts = NULL;\n\t}\n\n\tif (!kexts) {\n\t\tkexts = kexts_from_load_commands (obj, bf);\n\t}\n\n\tif (kexts && !r_list_length (kexts)) {\n\t\tr_list_free (kexts);\n\t\tkexts = NULL;\n\t}\n\n\tif (!kexts) {\n\t\tkexts = carve_kexts (obj, bf);\n\t}\n\n\tobj->kexts = r_kext_index_new (kexts);\n\n\tif (kexts) {\n\t\tkexts->free = NULL;\n\t\tr_list_free (kexts);\n\t}\n}\n\nstatic RPrelinkRange *get_prelink_info_range_from_mach0(struct MACH0_(obj_t) *mach0) {\n\tconst RVector *sections = MACH0_(load_sections) (mach0);\n\tif (!sections) {\n\t\treturn NULL;\n\t}\n\n\tRPrelinkRange *prelink_range = R_NEW0 (RPrelinkRange);\n\tif (!prelink_range) {\n\t\treturn NULL;\n\t}\n\n\tint incomplete = 3;\n\tstruct section_t *section;\n\tr_vector_foreach (sections, section) {\n\t\tif (strstr (section->name, \"__PRELINK_INFO.__info\")) {\n\t\t\tprelink_range->range.offset = section->paddr;\n\t\t\tprelink_range->range.size = section->size;\n\t\t\tif (!--incomplete) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (strstr (section->name, \"__PRELINK_TEXT.__text\")) {\n\t\t\tprelink_range->pa2va_exec = section->vaddr - section->paddr;\n\t\t\tif (!--incomplete) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (strstr (section->name, \"__PRELINK_DATA.__data\")) {\n\t\t\tprelink_range->pa2va_data = section->vaddr - section->paddr;\n\t\t\tif (!--incomplete) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (incomplete == 1 && !prelink_range->pa2va_data) {\n\t\tstruct MACH0_(segment_command) *seg;\n\t\tint nsegs = R_MIN (mach0->nsegs, 128);\n\t\tsize_t i;\n\t\tfor (i = 0; i < nsegs; i++) {\n\t\t\tseg = &mach0->segs[i];\n\t\t\tif (!strcmp (seg->segname, \"__DATA\")) {\n\t\t\t\tprelink_range->pa2va_data = seg->vmaddr - seg->fileoff;\n\t\t\t\tincomplete--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (incomplete) {\n\t\tR_FREE (prelink_range);\n\t}\n\n\treturn prelink_range;\n}\n\nstatic RList *filter_kexts(RKernelCacheObj *obj, RBinFile *bf) {\n\tRCFValueArray *kext_array = NULL;\n\tRListIter *iter;\n\tRCFKeyValue *item;\n\tr_list_foreach (obj->prelink_info->pairs, iter, item) {\n\t\tif (!strcmp (item->key, \"_PrelinkInfoDictionary\")) {\n\t\t\tkext_array = (RCFValueArray*) item->value;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!kext_array) {\n\t\treturn NULL;\n\t}\n\n\tRList *kexts = r_list_newf ((RListFree) &r_kext_free);\n\tif (!kexts) {\n\t\treturn NULL;\n\t}\n\n\tbool is_sorted = true;\n\tRKext *prev_kext = NULL;\n\tRCFValueDict *kext_item;\n\tr_list_foreach (kext_array->values, iter, kext_item) {\n\t\tRKext *kext = R_NEW0 (RKext);\n\t\tif (!kext) {\n\t\t\tR_FREE (kexts);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tint kext_incomplete = 5;\n\t\tRListIter *internal_iter;\n\t\tr_list_foreach (kext_item->pairs, internal_iter, item) {\n\t\t\tif (!strcmp (item->key, \"CFBundlePackageType\")) {\n\t\t\t\tif (item->value->type != R_CF_STRING) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tRCFValueString *type = (RCFValueString*) item->value;\n\t\t\t\tif (strcmp (type->value, \"KEXT\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tkext_incomplete--;\n\t\t\t}\n\n\t\t\tif (!strcmp (item->key, \"_PrelinkExecutableLoadAddr\")) {\n\t\t\t\tif (item->value->type == R_CF_INTEGER) {\n\t\t\t\t\tkext_incomplete--;\n\t\t\t\t\tkext->vaddr = ((RCFValueInteger*) item->value)->value;\n\t\t\t\t\tkext->range.offset = kext->vaddr - obj->pa2va_exec;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!strcmp (item->key, \"_PrelinkExecutableSize\")) {\n\t\t\t\tkext_incomplete--;\n\t\t\t\tif (item->value->type == R_CF_INTEGER) {\n\t\t\t\t\tkext->range.size = ((RCFValueInteger*) item->value)->value;\n\t\t\t\t} else {\n\t\t\t\t\tkext->range.size = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!strcmp (item->key, \"_PrelinkKmodInfo\")) {\n\t\t\t\tif (item->value->type == R_CF_INTEGER) {\n\t\t\t\t\tkext_incomplete--;\n\t\t\t\t\tkext->mod_info = ((RCFValueInteger*) item->value)->value;\n\t\t\t\t\tkext->mod_info -= obj->pa2va_data;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!strcmp (item->key, \"CFBundleIdentifier\")) {\n\t\t\t\tif (item->value->type == R_CF_STRING) {\n\t\t\t\t\tkext_incomplete--;\n\t\t\t\t\tkext->name = ((RCFValueString*) item->value)->value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (kext_incomplete) {\n\t\t\tr_kext_free (kext);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (prev_kext && kext->vaddr < prev_kext->vaddr) {\n\t\t\tis_sorted = false;\n\t\t}\n\t\tprev_kext = kext;\n\n\t\tkext->mach0 = create_kext_mach0 (obj, kext, bf);\n\t\tif (!kext->mach0) {\n\t\t\tr_kext_free (kext);\n\t\t\tcontinue;\n\t\t}\n\n\t\tr_kext_fill_text_range (kext);\n\n\t\tr_list_push (kexts, kext);\n\t}\n\n\tif (!is_sorted) {\n\t\tR_LOG_DEBUG (\"Sorting KEXTs\");\n\t\tr_list_sort (kexts, kexts_sort_vaddr_func);\n\t}\n\treturn kexts;\n}\n\nstatic ut64 p_ptr(ut64 decorated_addr, RKernelCacheObj *obj) {\n\tRParsedPointer ptr;\n\tr_ptr_undecorate (&ptr, decorated_addr, obj);\n\treturn ptr.address;\n}\n\nstatic ut64 r_ptr(ut8 *buf, RKernelCacheObj *obj) {\n\tut64 decorated_addr = r_read_le64 (buf);\n\treturn K_PPTR (decorated_addr);\n}\n\nstatic RList *carve_kexts(RKernelCacheObj *obj, RBinFile *bf) {\n\tconst RVector *sections = MACH0_(load_sections) (obj->mach0);\n\tif (!sections) {\n\t\treturn NULL;\n\t}\n\n\tut64 pa2va_exec = 0;\n\tut64 pa2va_data = 0;\n\tut64 kmod_start = 0, kmod_end = 0;\n\tut64 kmod_info = 0, kmod_info_end = 0;\n\tint incomplete = 4;\n\tRKmodInfo *all_infos = NULL;\n\n\tstruct section_t *section;\n\tr_vector_foreach (sections, section) {\n\t\tif (incomplete == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (strstr (section->name, \"__TEXT_EXEC.__text\")) {\n\t\t\tpa2va_exec = section->vaddr - section->paddr;\n\t\t\tincomplete--;\n\t\t}\n\t\tif (strstr (section->name, \"__DATA.__data\")) {\n\t\t\tpa2va_data = section->vaddr - section->paddr;\n\t\t\tincomplete--;\n\t\t}\n\t\tif (strstr (section->name, \"__PRELINK_INFO.__kmod_start\")) {\n\t\t\tkmod_start = section->paddr;\n\t\t\tkmod_end = kmod_start + section->size;\n\t\t\tincomplete--;\n\t\t}\n\t\tif (strstr (section->name, \"__PRELINK_INFO.__kmod_info\")) {\n\t\t\tkmod_info = section->paddr;\n\t\t\tkmod_info_end = kmod_info + section->size;\n\t\t\tincomplete--;\n\t\t}\n\t}\n\n\tif (incomplete) {\n\t\treturn NULL;\n\t}\n\n\tRList *kexts = r_list_newf ((RListFree) &r_kext_free);\n\tif (!kexts) {\n\t\treturn NULL;\n\t}\n\n\tint n_kmod_info = (kmod_info_end - kmod_info) / 8;\n\tif (n_kmod_info == 0) {\n\t\tgoto beach;\n\t}\n\n\tall_infos = R_NEWS0 (RKmodInfo, n_kmod_info);\n\tif (!all_infos) {\n\t\tgoto beach;\n\t}\n\n\tut8 bytes[8];\n\tint j = 0;\n\tfor (; j < n_kmod_info; j++) {\n\t\tut64 entry_offset = j * 8 + kmod_info;\n\n\t\tif (r_buf_read_at (obj->cache_buf, entry_offset, bytes, 8) < 8) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tut64 kmod_info_paddr = K_RPTR (bytes) - pa2va_data;\n\n\t\tut64 field_name = kmod_info_paddr + 0x10;\n\t\tut64 field_start = kmod_info_paddr + 0xb4;\n\n\t\tif (r_buf_read_at (obj->cache_buf, field_start, bytes, 8) < 8) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tall_infos[j].start = K_RPTR (bytes);\n\n\t\tif (r_buf_read_at (obj->cache_buf, field_name, (ut8 *) all_infos[j].name, 0x40) < 0x40) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tall_infos[j].name[0x40] = 0;\n\t}\n\n\tut64 cursor = kmod_start;\n\tfor (; cursor < kmod_end; cursor += 8) {\n\t\tut8 bytes[8];\n\t\tif (r_buf_read_at (obj->cache_buf, cursor, bytes, 8) < 8) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tRKext *kext = R_NEW0 (RKext);\n\t\tif (!kext) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tkext->vaddr = K_RPTR (bytes);\n\t\tkext->range.offset = kext->vaddr - pa2va_exec;\n\n\t\tkext->mach0 = create_kext_mach0 (obj, kext, bf);\n\t\tif (!kext->mach0) {\n\t\t\tr_kext_free (kext);\n\t\t\tcontinue;\n\t\t}\n\n\t\tr_kext_fill_text_range (kext);\n\t\tkext->vaddr = K_PPTR (kext->vaddr);\n\t\tkext->pa2va_exec = pa2va_exec;\n\t\tkext->pa2va_data = pa2va_data;\n\n\t\tut64 text_start = kext->vaddr;\n\t\tut64 text_end = text_start + kext->text_range.size;\n\n\t\tif (text_start == text_end) {\n\t\t\tr_kext_free (kext);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 0; j < n_kmod_info; j++) {\n\t\t\tif (text_start > all_infos[j].start || all_infos[j].start >= text_end) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tkext->name = strdup (all_infos[j].name);\n\t\t\tkext->own_name = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!kext->name) {\n\t\t\tr_kext_free (kext);\n\t\t\tcontinue;\n\t\t}\n\n\t\tr_list_push (kexts, kext);\n\t}\n\n\tR_FREE (all_infos);\n\treturn kexts;\n\nbeach:\n\tr_list_free (kexts);\n\tR_FREE (all_infos);\n\treturn NULL;\n}\n\nstatic RList *kexts_from_load_commands(RKernelCacheObj *obj, RBinFile *bf) {\n\tRList *kexts = r_list_newf ((RListFree) &r_kext_free);\n\tif (!kexts) {\n\t\treturn NULL;\n\t}\n\n\tut32 i, ncmds = r_buf_read_le32_at (obj->cache_buf, 16);\n\tut64 length = r_buf_size (obj->cache_buf);\n\n\tut32 cursor = sizeof (struct MACH0_(mach_header));\n\tfor (i = 0; i < ncmds && cursor < length; i++) {\n\t\tut32 cmdtype = r_buf_read_le32_at (obj->cache_buf, cursor);\n\t\tut32 cmdsize = r_buf_read_le32_at (obj->cache_buf, cursor + 4);\n\t\tif (!cmdsize || cmdsize + cursor < cursor) {\n\t\t\tbreak;\n\t\t}\n\t\tif (cmdtype != LC_KEXT) {\n\t\t\tcursor += cmdsize;\n\t\t\tcontinue;\n\t\t}\n\n\t\tut64 vaddr = r_buf_read_le64_at (obj->cache_buf, cursor + 8);\n\t\tut64 paddr = r_buf_read_le64_at (obj->cache_buf, cursor + 16);\n\t\tst32 padded_name_length = (st32)cmdsize - 32;\n\t\tif (padded_name_length <= 0 || cmdsize - 32 + cursor >= length) {\n\t\t\tcursor += cmdsize;\n\t\t\tcontinue;\n\t\t}\n\n\t\tchar *padded_name = calloc (1, padded_name_length);\n\t\tif (!padded_name) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (r_buf_read_at (obj->cache_buf, cursor + 32, (ut8 *)padded_name, padded_name_length)\n\t\t\t\t!= padded_name_length) {\n\t\t\tfree (padded_name);\n\t\t\tgoto early;\n\t\t}\n\n\t\tRKext *kext = R_NEW0 (RKext);\n\t\tif (!kext) {\n\t\t\tfree (padded_name);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tkext->vaddr = vaddr;\n\t\tkext->range.offset = paddr;\n\n\t\tkext->mach0 = create_kext_shared_mach0 (obj, kext, bf);\n\t\tif (!kext->mach0) {\n\t\t\tfree (padded_name);\n\t\t\tr_kext_free (kext);\n\t\t\tcursor += cmdsize;\n\t\t\tcontinue;\n\t\t}\n\n\t\tr_kext_fill_text_range (kext);\n\t\tkext->vaddr = K_PPTR (kext->vaddr);\n\t\tkext->pa2va_exec = obj->pa2va_exec;\n\t\tkext->pa2va_data = obj->pa2va_data;\n\t\tkext->name = strdup (padded_name);\n\t\tkext->own_name = true;\n\t\tfree (padded_name);\n\t\tr_list_push (kexts, kext);\n\n\t\tcursor += cmdsize;\n\t}\nearly:\n\treturn kexts;\nbeach:\n\tr_list_free (kexts);\n\treturn NULL;\n}\n\nstatic void r_kext_free(RKext *kext) {\n\tif (!kext) {\n\t\treturn;\n\t}\n\n\tif (kext->mach0) {\n\t\tMACH0_(mach0_free) (kext->mach0);\n\t\tkext->mach0 = NULL;\n\t}\n\n\tif (kext->own_name && kext->name) {\n\t\tR_FREE (kext->name);\n\t\tkext->name = NULL;\n\t}\n\n\tR_FREE (kext);\n}\n\nstatic void r_kext_fill_text_range(RKext *kext) {\n\tconst RVector *sections = MACH0_(load_sections) (kext->mach0);\n\tif (!sections) {\n\t\treturn;\n\t}\n\n\tstruct section_t *section;\n\tr_vector_foreach (sections, section) {\n\t\tif (strstr (section->name, \"__TEXT_EXEC.__text\")) {\n\t\t\tkext->text_range.offset = section->paddr;\n\t\t\tkext->text_range.size = section->size;\n\t\t\tkext->vaddr = section->vaddr;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int kexts_sort_vaddr_func(const void *a, const void *b) {\n\tRKext *A = (RKext *) a;\n\tRKext *B = (RKext *) b;\n\tint vaddr_compare = A->vaddr - B->vaddr;\n\tif (vaddr_compare == 0) {\n\t\treturn A->text_range.size - B->text_range.size;\n\t}\n\treturn vaddr_compare;\n}\n\nstatic RKextIndex *r_kext_index_new(RList *kexts) {\n\tif (!kexts) {\n\t\treturn NULL;\n\t}\n\n\tint length = r_list_length (kexts);\n\tif (!length) {\n\t\treturn NULL;\n\t}\n\n\tRKextIndex *index = R_NEW0 (RKextIndex);\n\tif (!index) {\n\t\treturn NULL;\n\t}\n\tindex->entries = calloc (length, sizeof (RKext*));\n\tif (!index->entries) {\n\t\tR_FREE (index);\n\t\treturn NULL;\n\t}\n\n\tRListIter *iter;\n\tRKext *kext;\n\tint i = 0;\n\tr_list_foreach (kexts, iter, kext) {\n\t\tindex->entries[i++] = kext;\n\t}\n\tindex->length = i;\n\n\treturn index;\n}\n\nstatic void r_kext_index_free(RKextIndex *index) {\n\tif (!index) {\n\t\treturn;\n\t}\n\n\tint i = 0;\n\tRKext *kext;\n\tr_kext_index_foreach (index, i, kext) {\n\t\tr_kext_free (kext);\n\t\tindex->entries[i] = NULL;\n\t}\n\n\tindex->length = 0;\n\tR_FREE (index);\n}\n\nstatic RKext *r_kext_index_vget(RKextIndex *index, ut64 vaddr) {\n\tint imid;\n\tint imin = 0;\n\tint imax = index->length - 1;\n\n\twhile (imin < imax) {\n\t\timid = (imin + imax) / 2;\n\t\tRKext *entry = index->entries[imid];\n\t\tif ((entry->vaddr + entry->text_range.size) <= vaddr || (entry->vaddr == vaddr && entry->text_range.size == 0)) {\n\t\t\timin = imid + 1;\n\t\t} else {\n\t\t\timax = imid;\n\t\t}\n\t}\n\n\tRKext *minEntry = index->entries[imin];\n\tif ((imax == imin) && (minEntry->vaddr <= vaddr) && ((minEntry->vaddr + minEntry->text_range.size) > vaddr)) {\n\t\treturn minEntry;\n\t}\n\treturn NULL;\n}\n\nstatic struct MACH0_(obj_t) *create_kext_mach0(RKernelCacheObj *obj, RKext *kext, RBinFile *bf) {\n\tRBuffer *buf = r_buf_new_slice (obj->cache_buf, kext->range.offset, r_buf_size (obj->cache_buf) - kext->range.offset);\n\tstruct MACH0_(opts_t) opts;\n\tMACH0_(opts_set_default) (&opts, bf);\n\topts.verbose = true;\n\topts.header_at = 0;\n\tstruct MACH0_(obj_t) *mach0 = MACH0_(new_buf) (buf, &opts);\n\tr_buf_free (buf);\n\treturn mach0;\n}\n\nstatic struct MACH0_(obj_t) *create_kext_shared_mach0(RKernelCacheObj *obj, RKext *kext, RBinFile *bf) {\n\tRBuffer *buf = r_buf_ref (obj->cache_buf);\n\tstruct MACH0_(opts_t) opts;\n\tMACH0_(opts_set_default) (&opts, bf);\n\topts.verbose = false;\n\topts.header_at = kext->range.offset;\n\tstruct MACH0_(obj_t) *mach0 = MACH0_(new_buf) (buf, &opts);\n\t// RESULTS IN UAF we should ref and unref instead r_buf_free (buf);\n\treturn mach0;\n}\n\nstatic RList *entries(RBinFile *bf) {\n\tRList *ret;\n\tRBinObject *obj = bf ? bf->bo : NULL;\n\n\tif (!obj || !obj->bin_obj || !(ret = r_list_newf (free))) {\n\t\treturn NULL;\n\t}\n\n\tRKernelCacheObj *kobj = (RKernelCacheObj*) obj->bin_obj;\n\tut64 entry_vaddr = kobj->mach0->entry;\n\tif (kobj->pa2va_exec <= entry_vaddr) {\n\t\tut64 entry_paddr = entry_vaddr - kobj->pa2va_exec;\n\t\tRBinAddr *ba = newEntry (entry_paddr, entry_vaddr, 0);\n\t\tif (ba) {\n\t\t\tr_list_append (ret, ba);\n\t\t}\n\t}\n\n\tprocess_constructors (kobj, kobj->mach0, ret, 0, true, R_K_CONSTRUCTOR_TO_ENTRY, NULL);\n\n\treturn ret;\n}\n\nstatic void process_kmod_init_term(RKernelCacheObj *obj, RKext *kext, RList *ret, ut64 **inits, ut64 **terms) {\n\tif (!*inits || !*terms) {\n\t\tconst RVector *sections = MACH0_(load_sections) (obj->mach0);\n\t\tif (!sections) {\n\t\t\treturn;\n\t\t}\n\n\t\tstruct section_t *section;\n\t\tr_vector_foreach (sections, section) {\n\t\t\tif (section->size == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tut64 start_paddr = 0;\n\t\t\tut64 *target = NULL;\n\t\t\tint n_ptrs = 0;\n\n\t\t\tif (!*inits && strstr (section->name, \"__kmod_init\")) {\n\t\t\t\tint n_inits = section->size / 8;\n\t\t\t\tif (n_inits <= 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*inits = R_NEWS0 (ut64, n_inits + 1);\n\t\t\t\ttarget = *inits;\n\t\t\t\tn_ptrs = n_inits;\n\t\t\t}\n\t\t\tif (!*terms && strstr (section->name, \"__kmod_term\")) {\n\t\t\t\tint n_terms = section->size / 8;\n\t\t\t\tif (n_terms <= 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*terms = R_NEWS0 (ut64, n_terms + 1);\n\t\t\t\ttarget = *terms;\n\t\t\t\tn_ptrs = n_terms;\n\t\t\t}\n\t\t\tif (!target || !n_ptrs) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstart_paddr = section->paddr;\n\t\t\tint j = 0;\n\t\t\tut8 bytes[8];\n\t\t\tfor (; j < n_ptrs; j++) {\n\t\t\t\tif (r_buf_read_at (obj->cache_buf, start_paddr + j * 8, bytes, 8) < 8) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttarget[j] = K_RPTR (bytes);\n\t\t\t}\n\t\t\ttarget[j] = 0;\n\t\t}\n\t}\n\n\tif (*inits) {\n\t\tcreate_initterm_syms (kext, ret, R_BIN_ENTRY_TYPE_INIT, *inits);\n\t}\n\tif (*terms) {\n\t\tcreate_initterm_syms (kext, ret, R_BIN_ENTRY_TYPE_FINI, *terms);\n\t}\n}\n\n/*\n * com.apple.driver.AppleMesaSEPDriver.3.__TEXT_EXEC.__text\n *                       |\n *                       |\n * AppleMesaSEPDriver <--+\n */\nstatic const char *kext_short_name(RKext *kext) {\n\tconst char *sn = strrchr (kext->name, '.');\n\treturn sn ? sn + 1 : kext->name;\n}\n\nstatic void create_initterm_syms(RKext *kext, RList *ret, int type, ut64 *pointers) {\n\tint i = 0;\n\tint count = 0;\n\tfor (; pointers[i]; i++) {\n\t\tut64 func_vaddr = pointers[i];\n\t\tut64 text_start = kext->vaddr;\n\t\tut64 text_end = text_start + kext->text_range.size;\n\n\t\tif (text_start == text_end) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (text_start > func_vaddr || func_vaddr >= text_end) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\tif (!sym) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsym->name = r_str_newf (\"%s.%s.%d\", kext_short_name (kext), (type == R_BIN_ENTRY_TYPE_INIT) ? \"init\" : \"fini\", count++);\n\t\tsym->vaddr = func_vaddr;\n\t\tsym->paddr = func_vaddr - kext->pa2va_exec;\n\t\tsym->size = 0;\n\t\tsym->forwarder = \"NONE\";\n\t\tsym->bind = \"GLOBAL\";\n\t\tsym->type = \"FUNC\";\n\n\t\tr_list_append (ret, sym);\n\t}\n}\n\nstatic void process_constructors(RKernelCacheObj *obj, struct MACH0_(obj_t) *mach0, RList *ret, ut64 paddr, bool is_first, int mode, const char *prefix) {\n\tconst RVector *sections = MACH0_(load_sections) (mach0);\n\tif (!sections) {\n\t\treturn;\n\t}\n\tint type;\n\tstruct section_t *section;\n\tr_vector_foreach (sections, section) {\n\t\tif (section->size == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strstr (section->name, \"_mod_fini_func\") || strstr (section->name, \"_mod_term_func\")) {\n\t\t\ttype  = R_BIN_ENTRY_TYPE_FINI;\n\t\t} else if (strstr (section->name, \"_mod_init_func\")) {\n\t\t\ttype  = is_first ? 0 : R_BIN_ENTRY_TYPE_INIT;\n\t\t\tis_first = false;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\tut8 *buf = calloc (section->size, 1);\n\t\tif (!buf) {\n\t\t\tbreak;\n\t\t}\n\t\tif (r_buf_read_at (obj->cache_buf, section->paddr + paddr, buf, section->size) < section->size) {\n\t\t\tfree (buf);\n\t\t\tbreak;\n\t\t}\n\t\tint j;\n\t\tint count = 0;\n\t\tfor (j = 0; j < section->size; j += 8) {\n\t\t\tut64 addr64 = K_RPTR (buf + j);\n\t\t\tut64 paddr64 = section->paddr + paddr + j;\n\t\t\tif (mode == R_K_CONSTRUCTOR_TO_ENTRY) {\n\t\t\t\tRBinAddr *ba = newEntry (paddr64, addr64, type);\n\t\t\t\tr_list_append (ret, ba);\n\t\t\t} else if (mode == R_K_CONSTRUCTOR_TO_SYMBOL) {\n\t\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\t\tif (!sym) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tsym->name = r_str_newf (\"%s.%s.%d\", prefix, (type == R_BIN_ENTRY_TYPE_INIT) ? \"init\" : \"fini\", count++);\n\t\t\t\tsym->vaddr = addr64;\n\t\t\t\tsym->paddr = paddr64;\n\t\t\t\tsym->size = 0;\n\t\t\t\tsym->forwarder = \"NONE\";\n\t\t\t\tsym->bind = \"GLOBAL\";\n\t\t\t\tsym->type = \"FUNC\";\n\n\t\t\t\tr_list_append (ret, sym);\n\t\t\t}\n\t\t}\n\t\tfree (buf);\n\t}\n}\n\nstatic RBinAddr *newEntry(ut64 haddr, ut64 vaddr, int type) {\n\tRBinAddr *ptr = R_NEW0 (RBinAddr);\n\tif (ptr) {\n\t\tptr->paddr = haddr;\n\t\tptr->vaddr = vaddr;\n\t\tptr->hpaddr = haddr;\n\t\tptr->bits = 64;\n\t\tptr->type = type;\n\t}\n\treturn ptr;\n}\n\nstatic bool check(RBinFile *bf, RBuffer *b) {\n\tif (r_buf_size (b) > 4) {\n\t\tut8 buf[4];\n\t\tr_buf_read_at (b, 0, buf, sizeof (buf));\n\t\tif (!memcmp (buf, \"\\xcf\\xfa\\xed\\xfe\", 4)) {\n\t\t\treturn is_kernelcache_buffer (b);\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic RList *sections(RBinFile *bf) {\n\tRList *ret = NULL;\n\tRBinObject *obj = bf ? bf->bo : NULL;\n\n\tif (!obj || !obj->bin_obj || !(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\n\tRKernelCacheObj *kobj = (RKernelCacheObj*) obj->bin_obj;\n\tensure_kexts_initialized (kobj, bf);\n\n\tint iter;\n\tRKext *kext;\n\tr_kext_index_foreach (kobj->kexts, iter, kext) {\n\t\tut8 magicbytes[4];\n\n\t\tr_buf_read_at (kobj->cache_buf, kext->range.offset, magicbytes, 4);\n\t\tint magic = r_read_le32 (magicbytes);\n\t\tswitch (magic) {\n\t\tcase MH_MAGIC_64:\n\t\t\tsections_from_mach0 (ret, kext->mach0, bf, kext->range.offset, kext->name, kobj);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\teprintf (\"Unknown sub-bin\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsections_from_mach0 (ret, kobj->mach0, bf, 0, NULL, kobj);\n\n\tstruct MACH0_(segment_command) *seg;\n\tint nsegs = R_MIN (kobj->mach0->nsegs, 128);\n\tint i;\n\tfor (i = 0; i < nsegs; i++) {\n\t\tchar segname[17];\n\t\tRBinSection *ptr = R_NEW0 (RBinSection);\n\t\tif (!ptr) {\n\t\t\tbreak;\n\t\t}\n\n\t\tseg = &kobj->mach0->segs[i];\n\t\tr_str_ncpy (segname, seg->segname, 17);\n\t\tr_str_filter (segname, -1);\n\t\tptr->name = r_str_newf (\"%d.%s\", i, segname);\n\t\tptr->size = seg->vmsize;\n\t\tptr->vsize = seg->vmsize;\n\t\tptr->paddr = seg->fileoff + bf->bo->boffset;\n\t\tptr->vaddr = seg->vmaddr;\n\t\tptr->add = true;\n\t\tptr->is_segment = true;\n\t\tif (!ptr->vaddr) {\n\t\t\tptr->vaddr = ptr->paddr;\n\t\t}\n\t\tptr->perm = prot2perm (seg->initprot);\n\t\tr_list_append (ret, ptr);\n\t}\n\n\treturn ret;\n}\n\nstatic int prot2perm(int x) {\n\tint r = 0;\n\tif (x&1) r |= 4;\n\tif (x&2) r |= 2;\n\tif (x&4) r |= 1;\n\treturn r;\n}\n\nstatic void sections_from_mach0(RList *ret, struct MACH0_(obj_t) *mach0, RBinFile *bf, ut64 paddr, char *prefix, RKernelCacheObj *obj) {\n\tconst RVector *sections = MACH0_(load_sections) (mach0);\n\tif (!sections) {\n\t\treturn;\n\t}\n\n\tstruct section_t *section;\n\tr_vector_foreach (sections, section) {\n\t\tRBinSection *ptr;\n\t\tif (!(ptr = R_NEW0 (RBinSection))) {\n\t\t\tbreak;\n\t\t}\n\t\tif (prefix) {\n\t\t\tptr->name = r_str_newf (\"%s.%s\", prefix, (char*)section->name);\n\t\t} else {\n\t\t\tptr->name = r_str_newf (\"%s\", (char*)section->name);\n\t\t}\n\t\tif (strstr (ptr->name, \"la_symbol_ptr\")) {\n\t\t\tint len = section->size / 8;\n\t\t\tptr->format = r_str_newf (\"Cd %d[%d]\", 8, len);\n\t\t}\n\t\thandle_data_sections (ptr);\n\t\tptr->size = section->size;\n\t\tptr->vsize = section->vsize;\n\t\tptr->paddr = section->paddr + bf->bo->boffset + paddr;\n\t\tptr->vaddr = K_PPTR (section->vaddr) + 0x1c;\n\t\tif (!ptr->vaddr) {\n\t\t\tptr->vaddr = ptr->paddr;\n\t\t}\n\t\tptr->perm = section->perm;\n\t\tif (!ptr->perm && strstr (section->name, \"__TEXT_EXEC.__text\")) {\n\t\t\tptr->perm = 1 | 4;\n\t\t}\n\t\tr_list_append (ret, ptr);\n\t}\n}\n\nstatic void handle_data_sections(RBinSection *sect) {\n\tif (strstr (sect->name, \"_cstring\")) {\n\t\tsect->is_data = true;\n\t} else if (strstr (sect->name, \"_os_log\")) {\n\t\tsect->is_data = true;\n\t} else if (strstr (sect->name, \"_objc_methname\")) {\n\t\tsect->is_data = true;\n\t} else if (strstr (sect->name, \"_objc_classname\")) {\n\t\tsect->is_data = true;\n\t} else if (strstr (sect->name, \"_objc_methtype\")) {\n\t\tsect->is_data = true;\n\t}\n}\n\nstatic RList *symbols(RBinFile *bf) {\n\tRList *ret = r_list_newf (r_bin_symbol_free);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\n\tRKernelCacheObj *obj = (RKernelCacheObj*) bf->bo->bin_obj;\n\n\tsymbols_from_mach0 (ret, obj->mach0, bf, 0, 0);\n\n\tHtPP *kernel_syms_by_addr = sdb_ht_new ();\n\tif (!kernel_syms_by_addr) {\n\t\tr_list_free (ret);\n\t\treturn NULL;\n\t}\n\n\tRListIter *iter;\n\tRBinSymbol *sym;\n\tut64 enosys_addr = 0;\n\tr_list_foreach (ret, iter, sym) {\n\t\tr_strf_var (key, 64, \"%\"PFMT64x, sym->vaddr);\n\t\tsdb_ht_insert (kernel_syms_by_addr, key, sym->dname ? sym->dname : sym->name);\n\t\tif (!enosys_addr && strstr (sym->name, \"enosys\")) {\n\t\t\tenosys_addr = sym->vaddr;\n\t\t}\n\t}\n\n\tRList *syscalls = resolve_syscalls (obj, enosys_addr);\n\tif (syscalls) {\n\t\tr_list_foreach (syscalls, iter, sym) {\n\t\t\tr_strf_var (key, 32, \"%\"PFMT64x, sym->vaddr);\n\t\t\tsdb_ht_insert (kernel_syms_by_addr, key, sym->name);\n\t\t\tr_list_append (ret, sym);\n\t\t}\n\t\tsyscalls->free = NULL;\n\t\tr_list_free (syscalls);\n\t}\n\n\tRList *subsystem = resolve_mig_subsystem (obj);\n\tif (subsystem) {\n\t\tr_list_foreach (subsystem, iter, sym) {\n\t\t\tr_strf_var (key, 64, \"%\"PFMT64x, sym->vaddr);\n\t\t\tsdb_ht_insert (kernel_syms_by_addr, key, sym->name);\n\t\t\tr_list_append (ret, sym);\n\t\t}\n\t\tsubsystem->free = NULL;\n\t\tr_list_free (subsystem);\n\t}\n\n\tensure_kexts_initialized (obj, bf);\n\n\tRKext *kext;\n\tint kiter;\n\tut64 *inits = NULL;\n\tut64 *terms = NULL;\n\tr_kext_index_foreach (obj->kexts, kiter, kext) {\n\t\tut8 magicbytes[4];\n\t\tr_buf_read_at (obj->cache_buf, kext->range.offset, magicbytes, 4);\n\t\tint magic = r_read_le32 (magicbytes);\n\t\tswitch (magic) {\n\t\tcase MH_MAGIC_64:\n\t\t\tsymbols_from_mach0 (ret, kext->mach0, bf, kext->range.offset, r_list_length (ret));\n\t\t\tsymbols_from_stubs (ret, kernel_syms_by_addr, obj, bf, kext, r_list_length (ret));\n\t\t\tprocess_constructors (obj, kext->mach0, ret, kext->range.offset, false, R_K_CONSTRUCTOR_TO_SYMBOL, kext_short_name (kext));\n\t\t\tprocess_kmod_init_term (obj, kext, ret, &inits, &terms);\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\teprintf (\"Unknown sub-bin\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tR_FREE (inits);\n\tR_FREE (terms);\n\n\tsdb_ht_free (kernel_syms_by_addr);\n\n\treturn ret;\n}\n\nstatic void symbols_from_mach0(RList *ret, struct MACH0_(obj_t) *mo, RBinFile *bf, ut64 paddr, int ordinal) {\n\tif (!MACH0_(load_symbols) (mo)) {\n\t\treturn;\n\t}\n\tRVecRBinSymbol *symbols = mo->symbols_vec;\n\n\tint i = 0;\n\tRBinSymbol *sym;\n\tR_VEC_FOREACH (symbols, sym) {\n\t\tRBinSymbol *ret_sym = R_NEW0 (RBinSymbol);\n\t\tif (!sym) {\n\t\t\tbreak;\n\t\t}\n\n\t\tret_sym->name = strdup (sym->name);\n\t\tif (ret_sym->name[0] == '_') {\n\t\t\tif (sym->dname) {\n\t\t\t\tret_sym->dname = strdup (sym->dname);\n\t\t\t}\n\t\t\tif (sym->classname) {\n\t\t\t\tret_sym->classname = strdup (sym->classname);\n\t\t\t}\n\t\t}\n\t\tret_sym->vaddr = sym->vaddr;\n\t\tret_sym->paddr = sym->paddr + paddr;\n\t\tret_sym->forwarder = \"NONE\";\n\t\tret_sym->bind = sym->bind;\n\t\tret_sym->type = R_BIN_TYPE_FUNC_STR;\n\t\tret_sym->size = sym->size;\n\t\tret_sym->ordinal = i;\n\t\tr_list_append (ret, ret_sym);\n\t\ti++;\n\t}\n}\n\n#define IS_KERNEL_ADDR(x) ((x & 0xfffffff000000000L) == 0xfffffff000000000L)\n\ntypedef struct _r_sysent {\n\tut64 sy_call;\n\tut64 sy_arg_munge32;\n\tst32 sy_return_type;\n\tst16 sy_narg;\n\tut16 sy_arg_bytes;\n} RSysEnt;\n\nstatic RList *resolve_syscalls(RKernelCacheObj *obj, ut64 enosys_addr) {\n\tconst RVector *sections = MACH0_(load_sections) (obj->mach0);\n\tif (!sections) {\n\t\treturn NULL;\n\t}\n\n\tRList *syscalls = NULL;\n\tRSyscall *syscall = NULL;\n\tut8 *data_const = NULL;\n\tut64 data_const_offset = 0, data_const_size = 0, data_const_vaddr = 0;\n\tstruct section_t *section;\n\tr_vector_foreach (sections, section) {\n\t\tif (strstr (section->name, \"__DATA_CONST.__const\")) {\n\t\t\tdata_const_offset = section->paddr;\n\t\t\tdata_const_size = section->size;\n\t\t\tdata_const_vaddr = K_PPTR (section->vaddr);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!data_const_offset || !data_const_size || !data_const_vaddr) {\n\t\tgoto beach;\n\t}\n\n\tdata_const = malloc (data_const_size);\n\tif (!data_const) {\n\t\tgoto beach;\n\t}\n\tif (r_buf_read_at (obj->cache_buf, data_const_offset, data_const, data_const_size) < data_const_size) {\n\t\tgoto beach;\n\t}\n\n\tut8 *cursor = data_const;\n\tut8 *end = data_const + data_const_size;\n\twhile (cursor < end) {\n\t\tut64 test = r_read_le64 (cursor);\n\t\tif (test == enosys_addr) {\n\t\t\tbreak;\n\t\t}\n\t\tcursor += 8;\n\t}\n\n\tif (cursor >= end) {\n\t\tgoto beach;\n\t}\n\n\tcursor -= 24;\n\twhile (cursor >= data_const) {\n\t\tut64 addr = r_read_le64 (cursor);\n\t\tut64 x = r_read_le64 (cursor + 8);\n\t\tut64 y = r_read_le64 (cursor + 16);\n\n\t\tif (IS_KERNEL_ADDR (addr) &&\n\t\t\t(x == 0 || IS_KERNEL_ADDR (x)) &&\n\t\t\t(y != 0 && !IS_KERNEL_ADDR (y))) {\n\t\t\tcursor -= 24;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcursor += 24;\n\t\tbreak;\n\t}\n\n\tif (cursor < data_const) {\n\t\tgoto beach;\n\t}\n\n\tsyscalls = r_list_newf (r_bin_symbol_free);\n\tif (!syscalls) {\n\t\tgoto beach;\n\t}\n\n\tsyscall = r_syscall_new ();\n\tif (!syscall) {\n\t\tgoto beach;\n\t}\n\tr_syscall_setup (syscall, \"arm\", 64, NULL, \"ios\");\n\tif (!syscall->db) {\n\t\tr_syscall_free (syscall);\n\t\tgoto beach;\n\t}\n\n\tut64 sysent_vaddr = cursor - data_const + data_const_vaddr;\n\n\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\tif (!sym) {\n\t\tgoto beach;\n\t}\n\n\tsym->name = r_str_newf (\"sysent\");\n\tsym->vaddr = sysent_vaddr;\n\tsym->paddr = cursor - data_const + data_const_offset;\n\tsym->size = 0;\n\tsym->forwarder = \"NONE\";\n\tsym->bind = \"GLOBAL\";\n\tsym->type = \"OBJECT\";\n\tr_list_append (syscalls, sym);\n\n\tint i = 1;\n\tcursor += 24;\n\tint num_syscalls = sdb_count (syscall->db);\n\twhile (cursor < end && i < num_syscalls) {\n\t\tut64 addr = r_read_le64 (cursor);\n\t\tRSyscallItem *item = r_syscall_get (syscall, i, 0x80);\n\t\tif (item && item->name) {\n\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\tif (!sym) {\n\t\t\t\tr_syscall_item_free (item);\n\t\t\t\tgoto beach;\n\t\t\t}\n\n\t\t\tsym->name = r_str_newf (\"syscall.%d.%s\", i, item->name);\n\t\t\tsym->vaddr = addr;\n\t\t\tsym->paddr = addr;\n\t\t\tsym->size = 0;\n\t\t\tsym->forwarder = \"NONE\";\n\t\t\tsym->bind = \"GLOBAL\";\n\t\t\tsym->type = \"FUNC\";\n\t\t\tr_list_append (syscalls, sym);\n\t\t}\n\t\tr_syscall_item_free (item);\n\t\tcursor += 24;\n\t\ti++;\n\t}\n\n\tr_syscall_free (syscall);\n\tR_FREE (data_const);\n\treturn syscalls;\n\nbeach:\n\tr_syscall_free (syscall);\n\tif (syscalls) {\n\t\tr_list_free (syscalls);\n\t}\n\tR_FREE (data_const);\n\treturn NULL;\n}\n\n#define K_MIG_SUBSYSTEM_SIZE (4 * 8)\n#define K_MIG_ROUTINE_SIZE (5 * 8)\n#define K_MIG_MAX_ROUTINES 100\n\nstatic HtPP *mig_hash_new(void) {\n\tHtPP *hash = sdb_ht_new ();\n\tif (!hash) {\n\t\treturn NULL;\n\t}\n\n\tint i;\n\tfor (i = 0; i < R_MIG_INDEX_LEN; i += 2) {\n\t\tconst char *num = mig_index[i];\n\t\tconst char *name = mig_index[i+1];\n\t\tsdb_ht_insert (hash, num, name);\n\t}\n\n\treturn hash;\n}\n\nstatic RList *resolve_mig_subsystem(RKernelCacheObj *obj) {\n\tconst RVector *sections = MACH0_(load_sections) (obj->mach0);\n\tif (!sections) {\n\t\treturn NULL;\n\t}\n\n\tHtPP *mig_hash = NULL;\n\tRList *subsystem = NULL;\n\tut8 *data_const = NULL;\n\tut64 data_const_offset = 0, data_const_size = 0, data_const_vaddr = 0;\n\tut64 text_exec_offset = 0, text_exec_size = 0, text_exec_vaddr = 0;\n\tint incomplete = 2;\n\n\tstruct section_t *section;\n\tr_vector_foreach (sections, section) {\n\t\tif (strstr (section->name, \"__DATA_CONST.__const\")) {\n\t\t\tdata_const_offset = section->paddr;\n\t\t\tdata_const_size = section->size;\n\t\t\tdata_const_vaddr = K_PPTR (section->vaddr);\n\t\t\tincomplete--;\n\t\t}\n\t\tif (strstr (section->name, \"__TEXT_EXEC.__text\")) {\n\t\t\ttext_exec_offset = section->paddr;\n\t\t\ttext_exec_size = section->size;\n\t\t\ttext_exec_vaddr = K_PPTR (section->vaddr);\n\t\t\tincomplete--;\n\t\t}\n\t}\n\tif (incomplete) {\n\t\treturn NULL;\n\t}\n\n\tif (!data_const_offset || !data_const_size || !data_const_vaddr ||\n\t\t!text_exec_offset || !text_exec_size || !text_exec_vaddr) {\n\t\tgoto beach;\n\t}\n\n\tdata_const = malloc (data_const_size);\n\tif (!data_const) {\n\t\tgoto beach;\n\t}\n\tif (r_buf_read_at (obj->cache_buf, data_const_offset, data_const, data_const_size) < data_const_size) {\n\t\tgoto beach;\n\t}\n\n\tsubsystem = r_list_newf (r_bin_symbol_free);\n\tif (!subsystem) {\n\t\tgoto beach;\n\t}\n\n\tmig_hash = mig_hash_new ();\n\tif (!mig_hash) {\n\t\tgoto beach;\n\t}\n\n\tut8 *cursor = data_const;\n\tut8 *end = data_const + data_const_size;\n\twhile (cursor < end) {\n\t\tut64 subs_p = K_PPTR (r_read_le64 (cursor));\n\t\tif (subs_p < text_exec_vaddr || subs_p >= text_exec_vaddr + text_exec_size) {\n\t\t\tcursor += 8;\n\t\t\tcontinue;\n\t\t}\n\t\tut32 subs_min_idx = r_read_le32 (cursor + 8);\n\t\tut32 subs_max_idx = r_read_le32 (cursor + 12);\n\t\tif (subs_min_idx >= subs_max_idx || (subs_max_idx - subs_min_idx) > K_MIG_MAX_ROUTINES) {\n\t\t\tcursor += 16;\n\t\t\tcontinue;\n\t\t}\n\n\t\tut32 n_routines = (subs_max_idx - subs_min_idx);\n\t\tut64 *routines = (ut64 *) calloc (n_routines, sizeof (ut64));\n\t\tif (!routines) {\n\t\t\tgoto beach;\n\t\t}\n\t\tut8 *array_cursor = cursor + K_MIG_SUBSYSTEM_SIZE;\n\t\tut8 *end_array = array_cursor + n_routines * K_MIG_ROUTINE_SIZE;\n\t\tbool is_consistent = true;\n\t\tint idx = 0;\n\t\twhile (array_cursor < end_array) {\n\t\t\tut64 should_be_null = r_read_le64 (array_cursor);\n\t\t\tif (should_be_null != 0) {\n\t\t\t\tis_consistent = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tut64 routine_p = K_PPTR (r_read_le64 (array_cursor + 8));\n\t\t\tif (routine_p != 0 && (routine_p < text_exec_vaddr || routine_p >= text_exec_vaddr + text_exec_size)) {\n\t\t\t\tis_consistent = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\troutines[idx++] = routine_p;\n\t\t\tarray_cursor += K_MIG_ROUTINE_SIZE;\n\t\t}\n\n\t\tif (is_consistent) {\n\t\t\tfor (idx = 0; idx < n_routines; idx++) {\n\t\t\t\tut64 routine_p = routines[idx];\n\t\t\t\tif (!routine_p) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\t\tif (!sym) {\n\t\t\t\t\tR_FREE (routines);\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\n\t\t\t\tint num = idx + subs_min_idx;\n\t\t\t\tbool found = false;\n\t\t\t\tr_strf_var (key, 32, \"%d\", num);\n\t\t\t\tconst char *name = sdb_ht_find (mig_hash, key, &found);\n\t\t\t\tif (found && name && *name) {\n\t\t\t\t\tsym->name = r_str_newf (\"mig.%d.%s\", num, name);\n\t\t\t\t} else {\n\t\t\t\t\tsym->name = r_str_newf (\"mig.%d\", num);\n\t\t\t\t}\n\n\t\t\t\tsym->vaddr = routine_p;\n\t\t\t\tsym->paddr = sym->vaddr - text_exec_vaddr + text_exec_offset;\n\t\t\t\tsym->size = 0;\n\t\t\t\tsym->forwarder = \"NONE\";\n\t\t\t\tsym->bind = \"GLOBAL\";\n\t\t\t\tsym->type = \"OBJECT\";\n\t\t\t\tr_list_append (subsystem, sym);\n\t\t\t}\n\n\t\t\tcursor += K_MIG_SUBSYSTEM_SIZE + n_routines * K_MIG_ROUTINE_SIZE;\n\t\t} else {\n\t\t\tcursor += 8;\n\t\t}\n\n\t\tR_FREE (routines);\n\t}\n\n\tsdb_ht_free (mig_hash);\n\tR_FREE (data_const);\n\treturn subsystem;\n\nbeach:\n\tif (subsystem) {\n\t\tr_list_free (subsystem);\n\t}\n\tif (mig_hash) {\n\t\tsdb_ht_free (mig_hash);\n\t}\n\tR_FREE (data_const);\n\treturn NULL;\n}\n\nstatic ut64 extract_addr_from_code(ut8 *arm64_code, ut64 vaddr) {\n\tut64 addr = vaddr & ~0xfff;\n\n\tut64 adrp = r_read_le32 (arm64_code);\n\tut64 adrp_offset = ((adrp & 0x60000000) >> 29) | ((adrp & 0xffffe0) >> 3);\n\taddr += adrp_offset << 12;\n\n\tut64 ldr = r_read_le32 (arm64_code + 4);\n\taddr += ((ldr & 0x3ffc00) >> 10) << ((ldr & 0xc0000000) >> 30);\n\n\treturn addr;\n}\n\nstatic void symbols_from_stubs(RList *ret, HtPP *kernel_syms_by_addr, RKernelCacheObj *obj, RBinFile *bf, RKext *kext, int ordinal) {\n\tRStubsInfo *stubs_info = get_stubs_info(kext->mach0, kext->range.offset, obj);\n\tif (!stubs_info) {\n\t\treturn;\n\t}\n\tut64 stubs_cursor = stubs_info->stubs.offset;\n\tut64 stubs_end = stubs_cursor + stubs_info->stubs.size;\n\n\tfor (; stubs_cursor < stubs_end; stubs_cursor += 12) {\n\t\tut8 arm64_code[8];\n\t\tif (r_buf_read_at (obj->cache_buf, stubs_cursor, arm64_code, 8) < 8) {\n\t\t\tbreak;\n\t\t}\n\n\t\tut64 vaddr = stubs_cursor + obj->pa2va_exec;\n\t\tut64 addr_in_got = extract_addr_from_code (arm64_code, vaddr);\n\n\t\tbool found = false;\n\t\tint level = 3;\n\n\t\tut64 target_addr = UT64_MAX;\n\n\t\twhile (!found && level-- > 0) {\n\t\t\tut64 offset_in_got = addr_in_got - obj->pa2va_exec;\n\t\t\tut64 addr;\n\t\t\tif (r_buf_read_at (obj->cache_buf, offset_in_got, (ut8*) &addr, 8) < 8) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (level == 2) {\n\t\t\t\ttarget_addr = addr;\n\t\t\t}\n\n\t\t\tr_strf_var (key, 32, \"%\"PFMT64x, addr);\n\t\t\tconst char *name = sdb_ht_find (kernel_syms_by_addr, key, &found);\n\n\t\t\tif (found) {\n\t\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\t\tif (!sym) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsym->name = r_str_newf (\"stub.%s\", name);\n\t\t\t\tsym->vaddr = vaddr;\n\t\t\t\tsym->paddr = stubs_cursor;\n\t\t\t\tsym->size = 12;\n\t\t\t\tsym->forwarder = \"NONE\";\n\t\t\t\tsym->bind = \"LOCAL\";\n\t\t\t\tsym->type = \"FUNC\";\n\t\t\t\tsym->ordinal = ordinal ++;\n\t\t\t\tr_list_append (ret, sym);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\taddr_in_got = addr;\n\t\t}\n\n\t\tif (found || target_addr == UT64_MAX) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tensure_kexts_initialized (obj, bf);\n\t\tRKext *remote_kext = r_kext_index_vget (obj->kexts, target_addr);\n\t\tif (!remote_kext) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tRBinSymbol *remote_sym = R_NEW0 (RBinSymbol);\n\t\tif (!remote_sym) {\n\t\t\tbreak;\n\t\t}\n\n\t\tremote_sym->name = r_str_newf (\"exp.%s.0x%\"PFMT64x, kext_short_name (remote_kext), target_addr);\n\t\tremote_sym->vaddr = target_addr;\n\t\tremote_sym->paddr = target_addr - obj->pa2va_exec;\n\t\tremote_sym->size = 0;\n\t\tremote_sym->forwarder = \"NONE\";\n\t\tremote_sym->bind = \"GLOBAL\";\n\t\tremote_sym->type = \"FUNC\";\n\t\tremote_sym->ordinal = ordinal ++;\n\t\tr_list_append (ret, remote_sym);\n\n\t\tRBinSymbol *local_sym = R_NEW0 (RBinSymbol);\n\t\tif (!local_sym) {\n\t\t\tbreak;\n\t\t}\n\n\t\tlocal_sym->name = r_str_newf (\"stub.%s.0x%\"PFMT64x, kext_short_name (remote_kext), target_addr);\n\t\tlocal_sym->vaddr = vaddr;\n\t\tlocal_sym->paddr = stubs_cursor;\n\t\tlocal_sym->size = 12;\n\t\tlocal_sym->forwarder = \"NONE\";\n\t\tlocal_sym->bind = \"GLOBAL\";\n\t\tlocal_sym->type = \"FUNC\";\n\t\tlocal_sym->ordinal = ordinal ++;\n\t\tr_list_append (ret, local_sym);\n\t}\n\n\tR_FREE (stubs_info);\n}\n\nstatic RStubsInfo *get_stubs_info(struct MACH0_(obj_t) *mach0, ut64 paddr, RKernelCacheObj *obj) {\n\tconst RVector *sections = MACH0_(load_sections) (mach0);\n\tif (!sections) {\n\t\treturn NULL;\n\t}\n\n\tRStubsInfo *stubs_info = R_NEW0 (RStubsInfo);\n\tif (!stubs_info) {\n\t\treturn NULL;\n\t}\n\n\tint incomplete = 2;\n\tstruct section_t *section;\n\tr_vector_foreach (sections, section) {\n\t\tif (strstr (section->name, \"__DATA_CONST.__got\")) {\n\t\t\tstubs_info->got.offset = section->paddr + paddr;\n\t\t\tstubs_info->got.size = section->size;\n\t\t\tstubs_info->got_addr = K_PPTR (section->vaddr);\n\t\t\tif (!--incomplete) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (strstr (section->name, \"__TEXT_EXEC.__stubs\")) {\n\t\t\tstubs_info->stubs.offset = section->paddr + paddr;\n\t\t\tstubs_info->stubs.size = section->size;\n\t\t\tif (!--incomplete) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (incomplete) {\n\t\tR_FREE (stubs_info);\n\t}\n\n\treturn stubs_info;\n}\n\nstatic RBinInfo *info(RBinFile *bf) {\n\tbool big_endian = 0;\n\tRBinInfo *ret = R_NEW0 (RBinInfo);\n\tif (ret) {\n\t\tret->file = strdup (bf->file);\n\t\tret->bclass = strdup (\"kernelcache\");\n\t\tret->rclass = strdup (\"ios\");\n\t\tret->os = strdup (\"iOS\");\n\t\tret->arch = strdup (\"arm\"); // XXX\n\t\tret->machine = strdup (ret->arch);\n\t\tret->subsystem = strdup (\"xnu\");\n\t\tret->type = strdup (\"kernel-cache\");\n\t\tret->bits = 64;\n\t\tret->has_va = true;\n\t\tret->big_endian = big_endian;\n\t\tret->dbg_info = 0;\n\t}\n\treturn ret;\n}\n\nstatic ut64 baddr(RBinFile *bf) {\n\tif (!bf || !bf->bo || !bf->bo->bin_obj) {\n\t\treturn 0; // 8LL; // w t f\n\t}\n\tRKernelCacheObj *obj = (RKernelCacheObj*) bf->bo->bin_obj;\n\treturn MACH0_(get_baddr)(obj->mach0);\n}\n\nstatic void destroy(RBinFile *bf) {\n\tr_kernel_cache_free ((RKernelCacheObj*) bf->bo->bin_obj);\n}\n\nstatic void r_kernel_cache_free(RKernelCacheObj *obj) {\n\tif (!obj) {\n\t\treturn;\n\t}\n\n\tif (obj->mach0) {\n\t\tMACH0_(mach0_free) (obj->mach0);\n\t\tobj->mach0 = NULL;\n\t\tobj->cache_buf = NULL;\n\t}\n\n\tif (obj->cache_buf) {\n\t\tr_buf_free (obj->cache_buf);\n\t\tobj->cache_buf = NULL;\n\t}\n\n\tif (obj->prelink_info) {\n\t\tr_cf_value_dict_free (obj->prelink_info);\n\t\tobj->prelink_info = NULL;\n\t}\n\n\tif (obj->kexts) {\n\t\tr_kext_index_free (obj->kexts);\n\t\tobj->kexts = NULL;\n\t}\n\n\tif (obj->rebase_info) {\n\t\tr_rebase_info_free (obj->rebase_info);\n\t\tobj->rebase_info = NULL;\n\t}\n\n\tR_FREE (obj);\n}\n\nstatic RRebaseInfo *r_rebase_info_new_from_mach0(RBuffer *cache_buf, struct MACH0_(obj_t) *mach0) {\n\tconst RVector *sections = MACH0_(load_sections) (mach0);\n\tif (!sections) {\n\t\treturn NULL;\n\t}\n\n\tut64 starts_offset = 0, starts_size = 0;\n\n\tstruct section_t *section;\n\tr_vector_foreach (sections, section) {\n\t\tif (strstr (section->name, \"__TEXT.__thread_starts\")) {\n\t\t\tstarts_offset = section->paddr;\n\t\t\tstarts_size = section->size;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tut64 kernel_base = 0;\n\n\tstruct MACH0_(segment_command) *seg;\n\tint nsegs = R_MIN (mach0->nsegs, 128);\n\tint i;\n\tfor (i = 0; i < nsegs; i++) {\n\t\tchar segname[17];\n\t\tseg = &mach0->segs[i];\n\t\tr_str_ncpy (segname, seg->segname, 17);\n\t\tif (!strncmp (segname, \"__TEXT\", 6) && segname[6] == '\\0') {\n\t\t\tkernel_base = seg->vmaddr;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (starts_offset == 0 || starts_size == 0 || kernel_base == 0) {\n\t\treturn NULL;\n\t}\n\n\tint n_starts = starts_size / 4;\n\tif (n_starts <= 1) {\n\t\treturn NULL;\n\t}\n\tRFileRange *rebase_ranges = R_NEWS0 (RFileRange, n_starts - 1);\n\tif (!rebase_ranges) {\n\t\treturn NULL;\n\t}\n\n\tut64 multiplier = 4;\n\tfor (i = 0; i != n_starts; i++) {\n\t\tut8 bytes[4];\n\t\tif (r_buf_read_at (cache_buf, starts_offset + i * 4, bytes, 4) < 4) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (i == 0) {\n\t\t\tmultiplier += 4 * (r_read_le32 (bytes) & 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\trebase_ranges[i - 1].offset = r_read_le32 (bytes);\n\t\trebase_ranges[i - 1].size = UT64_MAX;\n\t}\n\tif (i == n_starts) {\n\t\tRRebaseInfo *rebase_info = R_NEW0 (RRebaseInfo);\n\t\tif (rebase_info) {\n\t\t\trebase_info->ranges = rebase_ranges;\n\t\t\trebase_info->n_ranges = n_starts - 1;\n\t\t\trebase_info->multiplier = multiplier;\n\t\t\trebase_info->kernel_base = kernel_base;\n\t\t\treturn rebase_info;\n\t\t}\n\t}\n\tR_FREE (rebase_ranges);\n\treturn NULL;\n}\n\nstatic void r_rebase_info_free(RRebaseInfo *info) {\n\tif (info) {\n\t\tfree (info->ranges);\n\t\tfree (info);\n\t}\n}\n\nstatic void r_rebase_info_populate(RRebaseInfo *info, RKernelCacheObj *obj) {\n\tconst RVector *sections = NULL;\n\tint i = 0;\n\n\tif (obj->rebase_info_populated) {\n\t\treturn;\n\t}\n\tobj->rebase_info_populated = true;\n\n\tfor (; i < info->n_ranges; i++) {\n\t\tif (info->ranges[i].size != UT64_MAX) {\n\t\t\treturn;\n\t\t} else if (sections == NULL) {\n\t\t\tsections = MACH0_(load_sections) (obj->mach0);\n\t\t\tif (!sections) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tinfo->ranges[i].offset = r_rebase_offset_to_paddr (obj, sections, info->ranges[i].offset);\n\t\tut64 end = iterate_rebase_list (obj->cache_buf, info->multiplier, info->ranges[i].offset, NULL, NULL);\n\t\tif (end != UT64_MAX) {\n\t\t\tinfo->ranges[i].size = end - info->ranges[i].offset + 8;\n\t\t} else {\n\t\t\tinfo->ranges[i].size = 0;\n\t\t}\n\t}\n}\n\nstatic ut64 r_rebase_offset_to_paddr(RKernelCacheObj *obj, const RVector *sections, ut64 offset) {\n\tut64 vaddr = obj->rebase_info->kernel_base + offset;\n\tstruct section_t *section;\n\tr_vector_foreach (sections, section) {\n\t\tif (section->vaddr <= vaddr && vaddr < (section->vaddr + section->vsize)) {\n\t\t\treturn section->paddr + (vaddr - section->vaddr);\n\t\t}\n\t}\n\treturn offset;\n}\n\nstatic ut64 iterate_rebase_list(RBuffer *cache_buf, ut64 multiplier, ut64 start_offset, ROnRebaseFunc func, void *user_data) {\n\tut8 bytes[8];\n\tut64 cursor = start_offset;\n\n\twhile (true) {\n\t\tif (r_buf_read_at (cache_buf, cursor, bytes, 8) < 8) {\n\t\t\treturn UT64_MAX;\n\t\t}\n\n\t\tut64 decorated_addr = r_read_le64 (bytes);\n\n\t\tif (func) {\n\t\t\tbool carry_on = func (cursor, decorated_addr, user_data);\n\t\t\tif (!carry_on) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tut64 delta = ((decorated_addr >> 51) & 0x7ff) * multiplier;\n\t\tif (delta == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tcursor += delta;\n\t}\n\n\treturn cursor;\n}\n\nstatic void swizzle_io_read(RKernelCacheObj *obj, RIO *io) {\n\tr_return_if_fail (io && io->desc && io->desc->plugin);\n\tRIOPlugin *plugin = io->desc->plugin;\n\tobj->original_io_read = plugin->read;\n\tplugin->read = &kernelcache_io_read;\n}\n\nstatic int kernelcache_io_read(RIO *io, RIODesc *fd, ut8 *buf, int count) {\n\tr_return_val_if_fail (io, -1);\n\tRCore *core = (RCore*) io->coreb.core;\n\n\tif (!fd || !core || !core->bin || !core->bin->binfiles) {\n\t\treturn -1;\n\t}\n\n\tRKernelCacheObj *cache = NULL;\n\tRListIter *iter;\n\tRBinFile *bf;\n\tr_list_foreach (core->bin->binfiles, iter, bf) {\n\t\tif (bf->fd == fd->fd && bf->bo && bf->bo->bin_obj) {\n\t\t\tcache = bf->bo->bin_obj;\n\t\t\tif (pending_bin_files) {\n\t\t\t\tRListIter *to_remove = r_list_contains (pending_bin_files, bf);\n\t\t\t\tif (to_remove) {\n\t\t\t\t\tr_list_delete (pending_bin_files, to_remove);\n\t\t\t\t\tif (r_list_empty (pending_bin_files)) {\n\t\t\t\t\t\tr_list_free (pending_bin_files);\n\t\t\t\t\t\tpending_bin_files = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!cache) {\n\t\tr_list_foreach (pending_bin_files, iter, bf) {\n\t\t\tif (bf->fd == fd->fd && bf->bo) {\n\t\t\t\tcache = bf->bo->bin_obj;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!cache || !cache->original_io_read || cache->rebasing_buffer) {\n\t\tif (cache) {\n\t\t\tif ((!cache->rebasing_buffer && fd->plugin->read == &kernelcache_io_read) ||\n\t\t\t\t\t(cache->rebasing_buffer && !cache->original_io_read)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (cache->rebasing_buffer) {\n\t\t\t\treturn cache->original_io_read (io, fd, buf, count);\n\t\t\t}\n\t\t}\n\t\tif (fd->plugin->read == kernelcache_io_read) {\n\t\t\tif (core->bin->verbose) {\n\t\t\t\teprintf (\"Avoid recursive reads\\n\");\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\treturn fd->plugin->read (io, fd, buf, count);\n\t}\n\n\tif (cache->rebase_info) {\n\t\tr_rebase_info_populate (cache->rebase_info, cache);\n\t}\n\tif (!cache->original_io_read) {\n\t\treturn -1;\n\t}\n\n\t// move into\n\tif (count > cache->internal_buffer_size) {\n\t\tif (cache->internal_buffer) {\n\t\t\tR_FREE (cache->internal_buffer);\n\t\t}\n\t\tcache->internal_buffer_size = R_MAX (count, 8);\n\t\tcache->internal_buffer = (ut8 *) calloc (1, cache->internal_buffer_size);\n\t\tif (!cache->internal_buffer) {\n\t\t\tcache->internal_buffer_size = 0;\n\t\t\treturn -1;\n\t\t}\n\t}\n\tut64 io_off = io->off;\n\tint result = cache->original_io_read (io, fd, cache->internal_buffer, count);\n\tif (result == count) {\n\t\tif (cache->mach0->chained_starts) {\n\t\t\trebase_buffer_fixup (cache, io_off, fd, cache->internal_buffer, count);\n\t\t} else if (cache->rebase_info) {\n\t\t\trebase_buffer (cache, io_off, fd, cache->internal_buffer, count);\n\t\t}\n\t\tmemcpy (buf, cache->internal_buffer, result);\n\t}\n\n\treturn result;\n}\n\nstatic bool on_rebase_pointer(ut64 offset, ut64 decorated_addr, RRebaseCtx *ctx) {\n\tif (offset < ctx->off) {\n\t\treturn true;\n\t}\n\tif (offset >= ctx->eob) {\n\t\treturn false;\n\t}\n\tut64 in_buf = offset - ctx->off;\n\tif (in_buf >= ctx->count || (in_buf + 8) > ctx->count) {\n\t\treturn false;\n\t}\n\n\tRParsedPointer ptr;\n\tr_ptr_undecorate (&ptr, decorated_addr, ctx->obj);\n\n\tr_write_le64 (&ctx->buf[in_buf], ptr.address);\n\n\treturn true;\n}\n\nstatic void rebase_buffer(RKernelCacheObj *obj, ut64 off, RIODesc *fd, ut8 *buf, int count) {\n\tif (obj->rebasing_buffer || !buf) {\n\t\treturn;\n\t}\n\tobj->rebasing_buffer = true;\n\n\tut64 eob = off + count;\n\tint i = 0;\n\tRRebaseCtx ctx;\n\n\tctx.off = off;\n\tctx.eob = eob;\n\tctx.buf = buf;\n\tctx.count = count;\n\tctx.obj = obj;\n\n\tfor (; i < obj->rebase_info->n_ranges; i++) {\n\t\tut64 start = obj->rebase_info->ranges[i].offset;\n\t\tut64 end = start + obj->rebase_info->ranges[i].size;\n\t\tif (end >= off && start <= eob) {\n\t\t\titerate_rebase_list (obj->cache_buf, obj->rebase_info->multiplier, start,\n\t\t\t\t(ROnRebaseFunc) on_rebase_pointer, &ctx);\n\t\t}\n\t}\n\n\tobj->rebasing_buffer = false;\n}\n\nstatic void rebase_buffer_fixup(RKernelCacheObj *kobj, ut64 off, RIODesc *fd, ut8 *buf, int count) {\n\tif (kobj->rebasing_buffer) {\n\t\treturn;\n\t}\n\tkobj->rebasing_buffer = true;\n\tstruct MACH0_(obj_t) *obj = kobj->mach0;\n\tut64 eob = off + count;\n\tsize_t i = 0;\n\tfor (; i < obj->segs_count; i++) {\n\t\tif (!obj->chained_starts[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tut64 page_size = obj->chained_starts[i]->page_size;\n\t\tut64 start = obj->segs[i].fileoff;\n\t\tut64 end = start + obj->segs[i].filesize;\n\t\tif (end >= off && start <= eob) {\n\t\t\tut64 page_idx = (R_MAX (start, off) - start) / page_size;\n\t\t\tut64 page_end_idx = (R_MIN (eob, end) - start) / page_size;\n\t\t\tfor (; page_idx <= page_end_idx; page_idx++) {\n\t\t\t\tif (page_idx >= obj->chained_starts[i]->page_count) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tut16 page_start = obj->chained_starts[i]->page_start[page_idx];\n\t\t\t\tif (page_start == DYLD_CHAINED_PTR_START_NONE) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tut64 cursor = start + page_idx * page_size + page_start;\n\t\t\t\twhile (cursor < eob && cursor < end) {\n\t\t\t\t\tut8 tmp[8];\n\t\t\t\t\tif (r_buf_read_at (obj->b, cursor, tmp, 8) != 8) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tut64 raw_ptr = r_read_le64 (tmp);\n\t\t\t\t\tut64 ptr_value = raw_ptr;\n\t\t\t\t\tut64 delta = 0;\n\t\t\t\t\tut64 stride = 8;\n\t\t\t\t\tif (obj->chained_starts[i]->pointer_format == DYLD_CHAINED_PTR_ARM64E) {\n\t\t\t\t\t\tbool is_auth = IS_PTR_AUTH (raw_ptr);\n\t\t\t\t\t\tbool is_bind = IS_PTR_BIND (raw_ptr);\n\t\t\t\t\t\tif (is_auth && is_bind) {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_bind *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_bind *) &raw_ptr;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t} else if (!is_auth && is_bind) {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_bind *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_bind *) &raw_ptr;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t} else if (is_auth && !is_bind) {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_rebase *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tptr_value = p->target + obj->baddr;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_rebase *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tptr_value = ((ut64)p->high8 << 56) | p->target;\n\t\t\t\t\t\t\tptr_value += obj->baddr;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (obj->chained_starts[i]->pointer_format == DYLD_CHAINED_PTR_64_KERNEL_CACHE ||\n\t\t\t\t\t\t\tobj->chained_starts[i]->pointer_format == DYLD_CHAINED_PTR_ARM64E_KERNEL) {\n\t\t\t\t\t\tbool is_auth = IS_PTR_AUTH (raw_ptr);\n\t\t\t\t\t\tstride = 4;\n\t\t\t\t\t\tif (is_auth) {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_cache_auth_rebase *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_cache_auth_rebase *) &raw_ptr;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tptr_value = p->target + obj->baddr;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_cache_rebase *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_cache_rebase *) &raw_ptr;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tptr_value = ((ut64)p->high8 << 56) | p->target;\n\t\t\t\t\t\t\tptr_value += obj->baddr;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\teprintf (\"Unsupported pointer format: %u\\n\", obj->chained_starts[i]->pointer_format);\n\t\t\t\t\t}\n\t\t\t\t\tut64 in_buf = cursor - off;\n\t\t\t\t\tif (cursor >= off && cursor <= eob - 8) {\n\t\t\t\t\t\tr_write_le64 (&buf[in_buf], ptr_value);\n\t\t\t\t\t}\n\t\t\t\t\tcursor += delta * stride;\n\t\t\t\t\tif (!delta) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tkobj->rebasing_buffer = false;\n}\n\nRBinPlugin r_bin_plugin_xnu_kernelcache = {\n\t.meta = {\n\t\t.name = \"kernelcache\",\n\t\t.desc = \"kernelcache bin plugin\",\n\t\t.license = \"LGPL3\",\n\t},\n\t.destroy = &destroy,\n\t.load = &load,\n\t.entries = &entries,\n\t.baddr = &baddr,\n\t.symbols = &symbols,\n\t.sections = &sections,\n\t.check = &check,\n\t.info = &info\n};\n\n#ifndef R2_PLUGIN_INCORE\nRLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_BIN,\n\t.data = &r_bin_plugin_kernelcache,\n\t.version = R2_VERSION\n};\n#endif\n"], "fixing_code": ["/* radare2 - LGPL - Copyright 2019-2023 - mrmacete */\n\n#include <r_types.h>\n#include <r_util.h>\n#include <r_lib.h>\n#include <r_bin.h>\n#include <r_core.h>\n#include <r_syscall.h>\n\n#define R_BIN_MACH064 1\n#include \"../format/mach0/mach0.h\"\n\n#include \"../format/xnu/r_cf_dict.h\"\n#include \"../format/xnu/mig_index.h\"\n#include \"../format/mach0/mach064_is_kernelcache.c\"\n\ntypedef bool (*ROnRebaseFunc) (ut64 offset, ut64 decorated_addr, void *user_data);\n\ntypedef struct _RKernelCacheObj {\n\tRBuffer *cache_buf;\n\tRCFValueDict *prelink_info;\n\tut64 pa2va_exec;\n\tut64 pa2va_data;\n\tstruct _RKextIndex *kexts;\n\tstruct MACH0_(obj_t) *mach0;\n\tstruct _RRebaseInfo *rebase_info;\n\tint (*original_io_read)(RIO *io, RIODesc *fd, ut8 *buf, int count);\n\tbool rebase_info_populated;\n\tbool rebasing_buffer;\n\tbool kexts_initialized;\n\tut8 *internal_buffer;\n\tint internal_buffer_size;\n} RKernelCacheObj;\n\ntypedef struct _RFileRange {\n\tut64 offset;\n\tut64 size;\n} RFileRange;\n\ntypedef struct _RPrelinkRange {\n\tRFileRange range;\n\tut64 pa2va_exec;\n\tut64 pa2va_data;\n} RPrelinkRange;\n\ntypedef struct _RStubsInfo {\n\tRFileRange got;\n\tRFileRange stubs;\n\tut64 got_addr;\n} RStubsInfo;\n\ntypedef struct _RKext {\n\tRFileRange range;\n\tRFileRange text_range;\n\tchar *name;\n\tut64 mod_info;\n\tut64 vaddr;\n\tstruct MACH0_(obj_t) *mach0;\n\tbool own_name;\n\tut64 pa2va_exec;\n\tut64 pa2va_data;\n} RKext;\n\ntypedef struct _RKextIndex {\n\tut64 length;\n\tRKext **entries;\n} RKextIndex;\n\ntypedef struct _RRebaseInfo {\n\tRFileRange *ranges;\n\tut64 n_ranges;\n\tut64 multiplier;\n\tut64 kernel_base;\n} RRebaseInfo;\n\ntypedef struct _RRebaseCtx {\n\tut64 off, eob;\n\tut8 *buf;\n\tint count;\n\tRKernelCacheObj *obj;\n} RRebaseCtx;\n\ntypedef struct _RParsedPointer {\n\tut64 address;\n} RParsedPointer;\n\ntypedef struct _RKmodInfo {\n\tchar name[0x41];\n\tut64 start;\n} RKmodInfo;\n\n#define KEXT_SHORT_NAME_FROM_SECTION(io_section) ({\\\n\tchar *result = NULL;\\\n\tchar *clone = strdup (io_section->name);\\\n\tchar *cursor = strstr (clone, \"__\");\\\n\tif (cursor) {\\\n\t\tcursor--;\\\n\t\t*cursor = 0;\\\n\t\tcursor--;\\\n\t\tcursor = strrchr (cursor, '.');\\\n\t\tif (cursor) {\\\n\t\t\t*cursor = 0;\\\n\t\t\tcursor = strrchr (cursor, '.');\\\n\t\t\tif (cursor) {\\\n\t\t\t\tresult = strdup (cursor + 1);\\\n\t\t\t\tR_FREE (clone);\\\n\t\t\t}\\\n\t\t}\\\n\t}\\\n\tresult ? result : clone;\\\n})\n\n#define KEXT_INFER_VSIZE(index, i)\\\n\t((i+1 < index->length) ? index->entries[i+1]->vaddr - index->entries[i]->vaddr : UT64_MAX)\n\n#define KEXT_INFER_PSIZE(index, i)\\\n\t((i+1 < index->length) ? index->entries[i+1]->range.offset - index->entries[i]->range.offset : UT64_MAX)\n\n#define R_K_CONSTRUCTOR_TO_ENTRY 0\n#define R_K_CONSTRUCTOR_TO_SYMBOL 1\n\n#define K_PPTR(p) p_ptr (p, obj)\n#define K_RPTR(buf) r_ptr (buf, obj)\n\n#define IS_PTR_AUTH(x) ((x & (1ULL << 63)) != 0)\n#define IS_PTR_BIND(x) ((x & (1ULL << 62)) != 0)\n\nstatic ut64 p_ptr(ut64 decorated_addr, RKernelCacheObj *obj);\nstatic ut64 r_ptr(ut8 *buf, RKernelCacheObj *obj);\n\nstatic RRebaseInfo *r_rebase_info_new_from_mach0(RBuffer *cache_buf, struct MACH0_(obj_t) *mach0);\nstatic void r_rebase_info_free(RRebaseInfo *info);\nstatic void r_rebase_info_populate(RRebaseInfo *info, RKernelCacheObj *obj);\nstatic ut64 iterate_rebase_list(RBuffer *cache_buf, ut64 multiplier, ut64 start_offset, ROnRebaseFunc func, void *user_data);\nstatic ut64 r_rebase_offset_to_paddr(RKernelCacheObj *obj, const RVector *sections, ut64 offset);\nstatic void swizzle_io_read(RKernelCacheObj *obj, RIO *io);\nstatic int kernelcache_io_read(RIO *io, RIODesc *fd, ut8 *buf, int count);\nstatic void rebase_buffer(RKernelCacheObj *obj, ut64 off, RIODesc *fd, ut8 *buf, int count);\nstatic void rebase_buffer_fixup(RKernelCacheObj *kobj, ut64 off, RIODesc *fd, ut8 *buf, int count);\n\nstatic RPrelinkRange *get_prelink_info_range_from_mach0(struct MACH0_(obj_t) *mach0);\nstatic RList *filter_kexts(RKernelCacheObj *obj, RBinFile *bf);\nstatic RList *carve_kexts(RKernelCacheObj *obj, RBinFile *bf);\nstatic RList *kexts_from_load_commands(RKernelCacheObj *obj, RBinFile *bf);\n\nstatic void sections_from_mach0(RList *ret, struct MACH0_(obj_t) *mach0, RBinFile *bf, ut64 paddr, char *prefix, RKernelCacheObj *obj);\nstatic void handle_data_sections(RBinSection *sect);\nstatic void symbols_from_mach0(RList *ret, struct MACH0_(obj_t) *mach0, RBinFile *bf, ut64 paddr, int ordinal);\nstatic RList *resolve_syscalls(RKernelCacheObj *obj, ut64 enosys_addr);\nstatic RList *resolve_mig_subsystem(RKernelCacheObj *obj);\nstatic void symbols_from_stubs(RList *ret, HtPP *kernel_syms_by_addr, RKernelCacheObj *obj, RBinFile *bf, RKext *kext, int ordinal);\nstatic RStubsInfo *get_stubs_info(struct MACH0_(obj_t) *mach0, ut64 paddr, RKernelCacheObj *obj);\nstatic int prot2perm(int x);\n\nstatic void r_kext_free(RKext *kext);\nstatic void r_kext_fill_text_range(RKext *kext);\nstatic int kexts_sort_vaddr_func(const void *a, const void *b);\nstatic struct MACH0_(obj_t) *create_kext_mach0(RKernelCacheObj *obj, RKext *kext, RBinFile *bf);\nstatic struct MACH0_(obj_t) *create_kext_shared_mach0(RKernelCacheObj *obj, RKext *kext, RBinFile *bf);\n\n#define r_kext_index_foreach(index, i, item)\\\n\tif (index) for (i = 0; i < index->length && (item = index->entries[i], 1); i++)\n\nstatic RKextIndex *r_kext_index_new(RList *kexts);\nstatic void r_kext_index_free(RKextIndex *index);\nstatic RKext *r_kext_index_vget(RKextIndex *index, ut64 vaddr);\n\nstatic void process_kmod_init_term(RKernelCacheObj *obj, RKext *kext, RList *ret, ut64 **inits, ut64 **terms);\nstatic void create_initterm_syms(RKext *kext, RList *ret, int type, ut64 *pointers);\nstatic void process_constructors(RKernelCacheObj *obj, struct MACH0_(obj_t) *mach0, RList *ret, ut64 paddr, bool is_first, int mode, const char *prefix);\nstatic RBinAddr *newEntry(ut64 haddr, ut64 vaddr, int type);\nstatic void ensure_kexts_initialized(RKernelCacheObj *obj, RBinFile *bf);\n\nstatic void r_kernel_cache_free(RKernelCacheObj *obj);\n\nstatic R_TH_LOCAL RList *pending_bin_files = NULL;\n\nstatic bool load(RBinFile *bf, RBuffer *buf, ut64 loadaddr) {\n\tRBuffer *fbuf = r_buf_ref (buf);\n\tstruct MACH0_(opts_t) opts;\n\tMACH0_(opts_set_default) (&opts, bf);\n\tstruct MACH0_(obj_t) *main_mach0 = MACH0_(new_buf) (fbuf, &opts);\n\tif (!main_mach0) {\n\t\treturn false;\n\t}\n\n\tRRebaseInfo *rebase_info = r_rebase_info_new_from_mach0 (fbuf, main_mach0);\n\n\tRPrelinkRange *prelink_range = get_prelink_info_range_from_mach0 (main_mach0);\n\tif (!prelink_range) {\n\t\tgoto beach;\n\t}\n\n\tRKernelCacheObj *obj = R_NEW0 (RKernelCacheObj);\n\tif (!obj) {\n\t\tR_FREE (prelink_range);\n\t\tgoto beach;\n\t}\n\n\tconst bool is_modern = main_mach0->hdr.filetype == MH_FILESET ||\n\t\t(main_mach0->hdr.cputype == CPU_TYPE_ARM64 && main_mach0->hdr.cpusubtype == 0xc0000002);\n\n\tRCFValueDict *prelink_info = NULL;\n\tif (!is_modern && prelink_range->range.size) {\n\t\tprelink_info = r_cf_value_dict_parse (fbuf, prelink_range->range.offset,\n\t\t\t\tprelink_range->range.size, R_CF_OPTION_SKIP_NSDATA | R_CF_OPTION_SUPPORT_IDREF);\n\t\tif (!prelink_info) {\n\t\t\tR_FREE (prelink_range);\n\t\t\tR_FREE (obj);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\n\tif (!pending_bin_files) {\n\t\tpending_bin_files = r_list_new ();\n\t\tif (!pending_bin_files) {\n\t\t\tR_FREE (prelink_range);\n\t\t\tR_FREE (obj);\n\t\t\tR_FREE (prelink_info);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\n\tobj->mach0 = main_mach0;\n\tobj->rebase_info = rebase_info;\n\tobj->prelink_info = prelink_info;\n\tobj->cache_buf = fbuf;\n\tobj->pa2va_exec = prelink_range->pa2va_exec;\n\tobj->pa2va_data = prelink_range->pa2va_data;\n\tR_FREE (prelink_range);\n\tbf->bo->bin_obj = obj;\n\tr_list_push (pending_bin_files, bf);\n\n\tif (rebase_info || main_mach0->chained_starts) {\n\t\tRIO *io = bf->rbin->iob.io;\n\t\tswizzle_io_read (obj, io);\n\t}\n\n\treturn true;\n\nbeach:\n\tr_buf_free (fbuf);\n\tMACH0_(mach0_free) (main_mach0);\n\treturn false;\n}\n\nstatic void r_ptr_undecorate(RParsedPointer *ptr, ut64 decorated_addr, RKernelCacheObj *obj) {\n\t/*\n\t * Logic taken from:\n\t * https://github.com/Synacktiv/kernelcache-laundering/blob/master/ios12_kernel_cache_helper.py\n\t */\n\n\tif ((decorated_addr & 0x4000000000000000LL) == 0 && obj->rebase_info) {\n\t\tif (decorated_addr & 0x8000000000000000LL) {\n\t\t\tptr->address = obj->rebase_info->kernel_base + (decorated_addr & 0xFFFFFFFFLL);\n\t\t} else {\n\t\t\tptr->address = ((decorated_addr << 13) & 0xFF00000000000000LL) | (decorated_addr & 0x7ffffffffffLL);\n\t\t\tif (decorated_addr & 0x40000000000LL) {\n\t\t\t\tptr->address |= 0xfffc0000000000LL;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tptr->address = decorated_addr;\n\t}\n}\n\nstatic void ensure_kexts_initialized(RKernelCacheObj *obj, RBinFile *bf) {\n\tif (obj->kexts_initialized) {\n\t\treturn;\n\t}\n\tobj->kexts_initialized = true;\n\n\tRList *kexts = NULL;\n\n\tif (obj->prelink_info) {\n\t\tkexts = filter_kexts (obj, bf);\n\t}\n\n\tif (kexts && !r_list_length (kexts)) {\n\t\tr_list_free (kexts);\n\t\tkexts = NULL;\n\t}\n\n\tif (!kexts) {\n\t\tkexts = kexts_from_load_commands (obj, bf);\n\t}\n\n\tif (kexts && !r_list_length (kexts)) {\n\t\tr_list_free (kexts);\n\t\tkexts = NULL;\n\t}\n\n\tif (!kexts) {\n\t\tkexts = carve_kexts (obj, bf);\n\t}\n\n\tobj->kexts = r_kext_index_new (kexts);\n\n\tif (kexts) {\n\t\tkexts->free = NULL;\n\t\tr_list_free (kexts);\n\t}\n}\n\nstatic RPrelinkRange *get_prelink_info_range_from_mach0(struct MACH0_(obj_t) *mach0) {\n\tconst RVector *sections = MACH0_(load_sections) (mach0);\n\tif (!sections) {\n\t\treturn NULL;\n\t}\n\n\tRPrelinkRange *prelink_range = R_NEW0 (RPrelinkRange);\n\tif (!prelink_range) {\n\t\treturn NULL;\n\t}\n\n\tint incomplete = 3;\n\tstruct section_t *section;\n\tr_vector_foreach (sections, section) {\n\t\tif (strstr (section->name, \"__PRELINK_INFO.__info\")) {\n\t\t\tprelink_range->range.offset = section->paddr;\n\t\t\tprelink_range->range.size = section->size;\n\t\t\tif (!--incomplete) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (strstr (section->name, \"__PRELINK_TEXT.__text\")) {\n\t\t\tprelink_range->pa2va_exec = section->vaddr - section->paddr;\n\t\t\tif (!--incomplete) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (strstr (section->name, \"__PRELINK_DATA.__data\")) {\n\t\t\tprelink_range->pa2va_data = section->vaddr - section->paddr;\n\t\t\tif (!--incomplete) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (incomplete == 1 && !prelink_range->pa2va_data) {\n\t\tstruct MACH0_(segment_command) *seg;\n\t\tint nsegs = R_MIN (mach0->nsegs, 128);\n\t\tsize_t i;\n\t\tfor (i = 0; i < nsegs; i++) {\n\t\t\tseg = &mach0->segs[i];\n\t\t\tif (!strcmp (seg->segname, \"__DATA\")) {\n\t\t\t\tprelink_range->pa2va_data = seg->vmaddr - seg->fileoff;\n\t\t\t\tincomplete--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (incomplete) {\n\t\tR_FREE (prelink_range);\n\t}\n\n\treturn prelink_range;\n}\n\nstatic RList *filter_kexts(RKernelCacheObj *obj, RBinFile *bf) {\n\tRCFValueArray *kext_array = NULL;\n\tRListIter *iter;\n\tRCFKeyValue *item;\n\tr_list_foreach (obj->prelink_info->pairs, iter, item) {\n\t\tif (!strcmp (item->key, \"_PrelinkInfoDictionary\")) {\n\t\t\tkext_array = (RCFValueArray*) item->value;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!kext_array) {\n\t\treturn NULL;\n\t}\n\n\tRList *kexts = r_list_newf ((RListFree) &r_kext_free);\n\tif (!kexts) {\n\t\treturn NULL;\n\t}\n\n\tbool is_sorted = true;\n\tRKext *prev_kext = NULL;\n\tRCFValueDict *kext_item;\n\tr_list_foreach (kext_array->values, iter, kext_item) {\n\t\tRKext *kext = R_NEW0 (RKext);\n\t\tif (!kext) {\n\t\t\tR_FREE (kexts);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tint kext_incomplete = 5;\n\t\tRListIter *internal_iter;\n\t\tr_list_foreach (kext_item->pairs, internal_iter, item) {\n\t\t\tif (!strcmp (item->key, \"CFBundlePackageType\")) {\n\t\t\t\tif (item->value->type != R_CF_STRING) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tRCFValueString *type = (RCFValueString*) item->value;\n\t\t\t\tif (strcmp (type->value, \"KEXT\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tkext_incomplete--;\n\t\t\t}\n\n\t\t\tif (!strcmp (item->key, \"_PrelinkExecutableLoadAddr\")) {\n\t\t\t\tif (item->value->type == R_CF_INTEGER) {\n\t\t\t\t\tkext_incomplete--;\n\t\t\t\t\tkext->vaddr = ((RCFValueInteger*) item->value)->value;\n\t\t\t\t\tkext->range.offset = kext->vaddr - obj->pa2va_exec;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!strcmp (item->key, \"_PrelinkExecutableSize\")) {\n\t\t\t\tkext_incomplete--;\n\t\t\t\tif (item->value->type == R_CF_INTEGER) {\n\t\t\t\t\tkext->range.size = ((RCFValueInteger*) item->value)->value;\n\t\t\t\t} else {\n\t\t\t\t\tkext->range.size = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!strcmp (item->key, \"_PrelinkKmodInfo\")) {\n\t\t\t\tif (item->value->type == R_CF_INTEGER) {\n\t\t\t\t\tkext_incomplete--;\n\t\t\t\t\tkext->mod_info = ((RCFValueInteger*) item->value)->value;\n\t\t\t\t\tkext->mod_info -= obj->pa2va_data;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!strcmp (item->key, \"CFBundleIdentifier\")) {\n\t\t\t\tif (item->value->type == R_CF_STRING) {\n\t\t\t\t\tkext_incomplete--;\n\t\t\t\t\tkext->name = ((RCFValueString*) item->value)->value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (kext_incomplete) {\n\t\t\tr_kext_free (kext);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (prev_kext && kext->vaddr < prev_kext->vaddr) {\n\t\t\tis_sorted = false;\n\t\t}\n\t\tprev_kext = kext;\n\n\t\tkext->mach0 = create_kext_mach0 (obj, kext, bf);\n\t\tif (!kext->mach0) {\n\t\t\tr_kext_free (kext);\n\t\t\tcontinue;\n\t\t}\n\n\t\tr_kext_fill_text_range (kext);\n\n\t\tr_list_push (kexts, kext);\n\t}\n\n\tif (!is_sorted) {\n\t\tR_LOG_DEBUG (\"Sorting KEXTs\");\n\t\tr_list_sort (kexts, kexts_sort_vaddr_func);\n\t}\n\treturn kexts;\n}\n\nstatic ut64 p_ptr(ut64 decorated_addr, RKernelCacheObj *obj) {\n\tRParsedPointer ptr;\n\tr_ptr_undecorate (&ptr, decorated_addr, obj);\n\treturn ptr.address;\n}\n\nstatic ut64 r_ptr(ut8 *buf, RKernelCacheObj *obj) {\n\tut64 decorated_addr = r_read_le64 (buf);\n\treturn K_PPTR (decorated_addr);\n}\n\nstatic RList *carve_kexts(RKernelCacheObj *obj, RBinFile *bf) {\n\tconst RVector *sections = MACH0_(load_sections) (obj->mach0);\n\tif (!sections) {\n\t\treturn NULL;\n\t}\n\n\tut64 pa2va_exec = 0;\n\tut64 pa2va_data = 0;\n\tut64 kmod_start = 0, kmod_end = 0;\n\tut64 kmod_info = 0, kmod_info_end = 0;\n\tint incomplete = 4;\n\tRKmodInfo *all_infos = NULL;\n\n\tstruct section_t *section;\n\tr_vector_foreach (sections, section) {\n\t\tif (incomplete == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (strstr (section->name, \"__TEXT_EXEC.__text\")) {\n\t\t\tpa2va_exec = section->vaddr - section->paddr;\n\t\t\tincomplete--;\n\t\t}\n\t\tif (strstr (section->name, \"__DATA.__data\")) {\n\t\t\tpa2va_data = section->vaddr - section->paddr;\n\t\t\tincomplete--;\n\t\t}\n\t\tif (strstr (section->name, \"__PRELINK_INFO.__kmod_start\")) {\n\t\t\tkmod_start = section->paddr;\n\t\t\tkmod_end = kmod_start + section->size;\n\t\t\tincomplete--;\n\t\t}\n\t\tif (strstr (section->name, \"__PRELINK_INFO.__kmod_info\")) {\n\t\t\tkmod_info = section->paddr;\n\t\t\tkmod_info_end = kmod_info + section->size;\n\t\t\tincomplete--;\n\t\t}\n\t}\n\n\tif (incomplete) {\n\t\treturn NULL;\n\t}\n\n\tRList *kexts = r_list_newf ((RListFree) &r_kext_free);\n\tif (!kexts) {\n\t\treturn NULL;\n\t}\n\n\tint n_kmod_info = (kmod_info_end - kmod_info) / 8;\n\tif (n_kmod_info == 0) {\n\t\tgoto beach;\n\t}\n\n\tall_infos = R_NEWS0 (RKmodInfo, n_kmod_info);\n\tif (!all_infos) {\n\t\tgoto beach;\n\t}\n\n\tut8 bytes[8];\n\tint j = 0;\n\tfor (; j < n_kmod_info; j++) {\n\t\tut64 entry_offset = j * 8 + kmod_info;\n\n\t\tif (r_buf_read_at (obj->cache_buf, entry_offset, bytes, 8) < 8) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tut64 kmod_info_paddr = K_RPTR (bytes) - pa2va_data;\n\n\t\tut64 field_name = kmod_info_paddr + 0x10;\n\t\tut64 field_start = kmod_info_paddr + 0xb4;\n\n\t\tif (r_buf_read_at (obj->cache_buf, field_start, bytes, 8) < 8) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tall_infos[j].start = K_RPTR (bytes);\n\n\t\tif (r_buf_read_at (obj->cache_buf, field_name, (ut8 *) all_infos[j].name, 0x40) < 0x40) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tall_infos[j].name[0x40] = 0;\n\t}\n\n\tut64 cursor = kmod_start;\n\tfor (; cursor < kmod_end; cursor += 8) {\n\t\tut8 bytes[8];\n\t\tif (r_buf_read_at (obj->cache_buf, cursor, bytes, 8) < 8) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tRKext *kext = R_NEW0 (RKext);\n\t\tif (!kext) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tkext->vaddr = K_RPTR (bytes);\n\t\tkext->range.offset = kext->vaddr - pa2va_exec;\n\n\t\tkext->mach0 = create_kext_mach0 (obj, kext, bf);\n\t\tif (!kext->mach0) {\n\t\t\tr_kext_free (kext);\n\t\t\tcontinue;\n\t\t}\n\n\t\tr_kext_fill_text_range (kext);\n\t\tkext->vaddr = K_PPTR (kext->vaddr);\n\t\tkext->pa2va_exec = pa2va_exec;\n\t\tkext->pa2va_data = pa2va_data;\n\n\t\tut64 text_start = kext->vaddr;\n\t\tut64 text_end = text_start + kext->text_range.size;\n\n\t\tif (text_start == text_end) {\n\t\t\tr_kext_free (kext);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 0; j < n_kmod_info; j++) {\n\t\t\tif (text_start > all_infos[j].start || all_infos[j].start >= text_end) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tkext->name = strdup (all_infos[j].name);\n\t\t\tkext->own_name = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!kext->name) {\n\t\t\tr_kext_free (kext);\n\t\t\tcontinue;\n\t\t}\n\n\t\tr_list_push (kexts, kext);\n\t}\n\n\tR_FREE (all_infos);\n\treturn kexts;\n\nbeach:\n\tr_list_free (kexts);\n\tR_FREE (all_infos);\n\treturn NULL;\n}\n\nstatic RList *kexts_from_load_commands(RKernelCacheObj *obj, RBinFile *bf) {\n\tRList *kexts = r_list_newf ((RListFree) &r_kext_free);\n\tif (!kexts) {\n\t\treturn NULL;\n\t}\n\n\tut32 i, ncmds = r_buf_read_le32_at (obj->cache_buf, 16);\n\tut64 length = r_buf_size (obj->cache_buf);\n\n\tut32 cursor = sizeof (struct MACH0_(mach_header));\n\tfor (i = 0; i < ncmds && cursor < length; i++) {\n\t\tut32 cmdtype = r_buf_read_le32_at (obj->cache_buf, cursor);\n\t\tut32 cmdsize = r_buf_read_le32_at (obj->cache_buf, cursor + 4);\n\t\tif (!cmdsize || cmdsize + cursor < cursor) {\n\t\t\tbreak;\n\t\t}\n\t\tif (cmdtype != LC_KEXT) {\n\t\t\tcursor += cmdsize;\n\t\t\tcontinue;\n\t\t}\n\n\t\tut64 vaddr = r_buf_read_le64_at (obj->cache_buf, cursor + 8);\n\t\tut64 paddr = r_buf_read_le64_at (obj->cache_buf, cursor + 16);\n\t\tst32 padded_name_length = (st32)cmdsize - 32;\n\t\tif (padded_name_length <= 0 || cmdsize - 32 + cursor >= length) {\n\t\t\tcursor += cmdsize;\n\t\t\tcontinue;\n\t\t}\n\n\t\tchar *padded_name = calloc (1, padded_name_length);\n\t\tif (!padded_name) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (r_buf_read_at (obj->cache_buf, cursor + 32, (ut8 *)padded_name, padded_name_length)\n\t\t\t\t!= padded_name_length) {\n\t\t\tfree (padded_name);\n\t\t\tgoto early;\n\t\t}\n\n\t\tRKext *kext = R_NEW0 (RKext);\n\t\tif (!kext) {\n\t\t\tfree (padded_name);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tkext->vaddr = vaddr;\n\t\tkext->range.offset = paddr;\n\n\t\tkext->mach0 = create_kext_shared_mach0 (obj, kext, bf);\n\t\tif (!kext->mach0) {\n\t\t\tfree (padded_name);\n\t\t\tr_kext_free (kext);\n\t\t\tcursor += cmdsize;\n\t\t\tcontinue;\n\t\t}\n\n\t\tr_kext_fill_text_range (kext);\n\t\tkext->vaddr = K_PPTR (kext->vaddr);\n\t\tkext->pa2va_exec = obj->pa2va_exec;\n\t\tkext->pa2va_data = obj->pa2va_data;\n\t\tkext->name = strdup (padded_name);\n\t\tkext->own_name = true;\n\t\tfree (padded_name);\n\t\tr_list_push (kexts, kext);\n\n\t\tcursor += cmdsize;\n\t}\nearly:\n\treturn kexts;\nbeach:\n\tr_list_free (kexts);\n\treturn NULL;\n}\n\nstatic void r_kext_free(RKext *kext) {\n\tif (!kext) {\n\t\treturn;\n\t}\n\n\tif (kext->mach0) {\n\t\tMACH0_(mach0_free) (kext->mach0);\n\t\tkext->mach0 = NULL;\n\t}\n\n\tif (kext->own_name && kext->name) {\n\t\tR_FREE (kext->name);\n\t\tkext->name = NULL;\n\t}\n\n\tR_FREE (kext);\n}\n\nstatic void r_kext_fill_text_range(RKext *kext) {\n\tconst RVector *sections = MACH0_(load_sections) (kext->mach0);\n\tif (!sections) {\n\t\treturn;\n\t}\n\n\tstruct section_t *section;\n\tr_vector_foreach (sections, section) {\n\t\tif (strstr (section->name, \"__TEXT_EXEC.__text\")) {\n\t\t\tkext->text_range.offset = section->paddr;\n\t\t\tkext->text_range.size = section->size;\n\t\t\tkext->vaddr = section->vaddr;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int kexts_sort_vaddr_func(const void *a, const void *b) {\n\tRKext *A = (RKext *) a;\n\tRKext *B = (RKext *) b;\n\tint vaddr_compare = A->vaddr - B->vaddr;\n\tif (vaddr_compare == 0) {\n\t\treturn A->text_range.size - B->text_range.size;\n\t}\n\treturn vaddr_compare;\n}\n\nstatic RKextIndex *r_kext_index_new(RList *kexts) {\n\tif (!kexts) {\n\t\treturn NULL;\n\t}\n\n\tint length = r_list_length (kexts);\n\tif (!length) {\n\t\treturn NULL;\n\t}\n\n\tRKextIndex *index = R_NEW0 (RKextIndex);\n\tif (!index) {\n\t\treturn NULL;\n\t}\n\tindex->entries = calloc (length, sizeof (RKext*));\n\tif (!index->entries) {\n\t\tR_FREE (index);\n\t\treturn NULL;\n\t}\n\n\tRListIter *iter;\n\tRKext *kext;\n\tint i = 0;\n\tr_list_foreach (kexts, iter, kext) {\n\t\tindex->entries[i++] = kext;\n\t}\n\tindex->length = i;\n\n\treturn index;\n}\n\nstatic void r_kext_index_free(RKextIndex *index) {\n\tif (!index) {\n\t\treturn;\n\t}\n\n\tint i = 0;\n\tRKext *kext;\n\tr_kext_index_foreach (index, i, kext) {\n\t\tr_kext_free (kext);\n\t\tindex->entries[i] = NULL;\n\t}\n\n\tindex->length = 0;\n\tR_FREE (index);\n}\n\nstatic RKext *r_kext_index_vget(RKextIndex *index, ut64 vaddr) {\n\tint imid;\n\tint imin = 0;\n\tint imax = index->length - 1;\n\n\twhile (imin < imax) {\n\t\timid = (imin + imax) / 2;\n\t\tRKext *entry = index->entries[imid];\n\t\tif ((entry->vaddr + entry->text_range.size) <= vaddr || (entry->vaddr == vaddr && entry->text_range.size == 0)) {\n\t\t\timin = imid + 1;\n\t\t} else {\n\t\t\timax = imid;\n\t\t}\n\t}\n\n\tRKext *minEntry = index->entries[imin];\n\tif ((imax == imin) && (minEntry->vaddr <= vaddr) && ((minEntry->vaddr + minEntry->text_range.size) > vaddr)) {\n\t\treturn minEntry;\n\t}\n\treturn NULL;\n}\n\nstatic struct MACH0_(obj_t) *create_kext_mach0(RKernelCacheObj *obj, RKext *kext, RBinFile *bf) {\n\tRBuffer *buf = r_buf_new_slice (obj->cache_buf, kext->range.offset, r_buf_size (obj->cache_buf) - kext->range.offset);\n\tstruct MACH0_(opts_t) opts;\n\tMACH0_(opts_set_default) (&opts, bf);\n\topts.verbose = true;\n\topts.header_at = 0;\n\tstruct MACH0_(obj_t) *mach0 = MACH0_(new_buf) (buf, &opts);\n\tr_buf_free (buf);\n\treturn mach0;\n}\n\nstatic struct MACH0_(obj_t) *create_kext_shared_mach0(RKernelCacheObj *obj, RKext *kext, RBinFile *bf) {\n\tRBuffer *buf = r_buf_ref (obj->cache_buf);\n\tstruct MACH0_(opts_t) opts;\n\tMACH0_(opts_set_default) (&opts, bf);\n\topts.verbose = false;\n\topts.header_at = kext->range.offset;\n\tstruct MACH0_(obj_t) *mach0 = MACH0_(new_buf) (buf, &opts);\n\t// RESULTS IN UAF we should ref and unref instead r_buf_free (buf);\n\treturn mach0;\n}\n\nstatic RList *entries(RBinFile *bf) {\n\tRList *ret;\n\tRBinObject *obj = bf ? bf->bo : NULL;\n\n\tif (!obj || !obj->bin_obj || !(ret = r_list_newf (free))) {\n\t\treturn NULL;\n\t}\n\n\tRKernelCacheObj *kobj = (RKernelCacheObj*) obj->bin_obj;\n\tut64 entry_vaddr = kobj->mach0->entry;\n\tif (kobj->pa2va_exec <= entry_vaddr) {\n\t\tut64 entry_paddr = entry_vaddr - kobj->pa2va_exec;\n\t\tRBinAddr *ba = newEntry (entry_paddr, entry_vaddr, 0);\n\t\tif (ba) {\n\t\t\tr_list_append (ret, ba);\n\t\t}\n\t}\n\n\tprocess_constructors (kobj, kobj->mach0, ret, 0, true, R_K_CONSTRUCTOR_TO_ENTRY, NULL);\n\n\treturn ret;\n}\n\nstatic void process_kmod_init_term(RKernelCacheObj *obj, RKext *kext, RList *ret, ut64 **inits, ut64 **terms) {\n\tif (!*inits || !*terms) {\n\t\tconst RVector *sections = MACH0_(load_sections) (obj->mach0);\n\t\tif (!sections) {\n\t\t\treturn;\n\t\t}\n\n\t\tstruct section_t *section;\n\t\tr_vector_foreach (sections, section) {\n\t\t\tif (section->size == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tut64 start_paddr = 0;\n\t\t\tut64 *target = NULL;\n\t\t\tint n_ptrs = 0;\n\n\t\t\tif (!*inits && strstr (section->name, \"__kmod_init\")) {\n\t\t\t\tint n_inits = section->size / 8;\n\t\t\t\tif (n_inits <= 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*inits = R_NEWS0 (ut64, n_inits + 1);\n\t\t\t\ttarget = *inits;\n\t\t\t\tn_ptrs = n_inits;\n\t\t\t}\n\t\t\tif (!*terms && strstr (section->name, \"__kmod_term\")) {\n\t\t\t\tint n_terms = section->size / 8;\n\t\t\t\tif (n_terms <= 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*terms = R_NEWS0 (ut64, n_terms + 1);\n\t\t\t\ttarget = *terms;\n\t\t\t\tn_ptrs = n_terms;\n\t\t\t}\n\t\t\tif (!target || !n_ptrs) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstart_paddr = section->paddr;\n\t\t\tint j = 0;\n\t\t\tut8 bytes[8];\n\t\t\tfor (; j < n_ptrs; j++) {\n\t\t\t\tif (r_buf_read_at (obj->cache_buf, start_paddr + j * 8, bytes, 8) < 8) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttarget[j] = K_RPTR (bytes);\n\t\t\t}\n\t\t\ttarget[j] = 0;\n\t\t}\n\t}\n\n\tif (*inits) {\n\t\tcreate_initterm_syms (kext, ret, R_BIN_ENTRY_TYPE_INIT, *inits);\n\t}\n\tif (*terms) {\n\t\tcreate_initterm_syms (kext, ret, R_BIN_ENTRY_TYPE_FINI, *terms);\n\t}\n}\n\n/*\n * com.apple.driver.AppleMesaSEPDriver.3.__TEXT_EXEC.__text\n *                       |\n *                       |\n * AppleMesaSEPDriver <--+\n */\nstatic const char *kext_short_name(RKext *kext) {\n\tconst char *sn = strrchr (kext->name, '.');\n\treturn sn ? sn + 1 : kext->name;\n}\n\nstatic void create_initterm_syms(RKext *kext, RList *ret, int type, ut64 *pointers) {\n\tint i = 0;\n\tint count = 0;\n\tfor (; pointers[i]; i++) {\n\t\tut64 func_vaddr = pointers[i];\n\t\tut64 text_start = kext->vaddr;\n\t\tut64 text_end = text_start + kext->text_range.size;\n\n\t\tif (text_start == text_end) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (text_start > func_vaddr || func_vaddr >= text_end) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\tif (!sym) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsym->name = r_str_newf (\"%s.%s.%d\", kext_short_name (kext), (type == R_BIN_ENTRY_TYPE_INIT) ? \"init\" : \"fini\", count++);\n\t\tsym->vaddr = func_vaddr;\n\t\tsym->paddr = func_vaddr - kext->pa2va_exec;\n\t\tsym->size = 0;\n\t\tsym->forwarder = \"NONE\";\n\t\tsym->bind = \"GLOBAL\";\n\t\tsym->type = \"FUNC\";\n\n\t\tr_list_append (ret, sym);\n\t}\n}\n\nstatic void process_constructors(RKernelCacheObj *obj, struct MACH0_(obj_t) *mach0, RList *ret, ut64 paddr, bool is_first, int mode, const char *prefix) {\n\tconst RVector *sections = MACH0_(load_sections) (mach0);\n\tif (!sections) {\n\t\treturn;\n\t}\n\tint type;\n\tstruct section_t *section;\n\tr_vector_foreach (sections, section) {\n\t\tif (section->size == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strstr (section->name, \"_mod_fini_func\") || strstr (section->name, \"_mod_term_func\")) {\n\t\t\ttype  = R_BIN_ENTRY_TYPE_FINI;\n\t\t} else if (strstr (section->name, \"_mod_init_func\")) {\n\t\t\ttype  = is_first ? 0 : R_BIN_ENTRY_TYPE_INIT;\n\t\t\tis_first = false;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\tut8 *buf = calloc (section->size, 1);\n\t\tif (!buf) {\n\t\t\tbreak;\n\t\t}\n\t\tif (r_buf_read_at (obj->cache_buf, section->paddr + paddr, buf, section->size) < section->size) {\n\t\t\tfree (buf);\n\t\t\tbreak;\n\t\t}\n\t\tint j;\n\t\tint count = 0;\n\t\tfor (j = 0; j + 7 < section->size; j += 8) {\n\t\t\tut64 addr64 = K_RPTR (buf + j);\n\t\t\tut64 paddr64 = section->paddr + paddr + j;\n\t\t\tif (mode == R_K_CONSTRUCTOR_TO_ENTRY) {\n\t\t\t\tRBinAddr *ba = newEntry (paddr64, addr64, type);\n\t\t\t\tr_list_append (ret, ba);\n\t\t\t} else if (mode == R_K_CONSTRUCTOR_TO_SYMBOL) {\n\t\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\t\tif (!sym) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tsym->name = r_str_newf (\"%s.%s.%d\", prefix, (type == R_BIN_ENTRY_TYPE_INIT) ? \"init\" : \"fini\", count++);\n\t\t\t\tsym->vaddr = addr64;\n\t\t\t\tsym->paddr = paddr64;\n\t\t\t\tsym->size = 0;\n\t\t\t\tsym->forwarder = \"NONE\";\n\t\t\t\tsym->bind = \"GLOBAL\";\n\t\t\t\tsym->type = \"FUNC\";\n\n\t\t\t\tr_list_append (ret, sym);\n\t\t\t}\n\t\t}\n\t\tfree (buf);\n\t}\n}\n\nstatic RBinAddr *newEntry(ut64 haddr, ut64 vaddr, int type) {\n\tRBinAddr *ptr = R_NEW0 (RBinAddr);\n\tif (ptr) {\n\t\tptr->paddr = haddr;\n\t\tptr->vaddr = vaddr;\n\t\tptr->hpaddr = haddr;\n\t\tptr->bits = 64;\n\t\tptr->type = type;\n\t}\n\treturn ptr;\n}\n\nstatic bool check(RBinFile *bf, RBuffer *b) {\n\tif (r_buf_size (b) > 4) {\n\t\tut8 buf[4];\n\t\tr_buf_read_at (b, 0, buf, sizeof (buf));\n\t\tif (!memcmp (buf, \"\\xcf\\xfa\\xed\\xfe\", 4)) {\n\t\t\treturn is_kernelcache_buffer (b);\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic RList *sections(RBinFile *bf) {\n\tRList *ret = NULL;\n\tRBinObject *obj = bf ? bf->bo : NULL;\n\n\tif (!obj || !obj->bin_obj || !(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\n\tRKernelCacheObj *kobj = (RKernelCacheObj*) obj->bin_obj;\n\tensure_kexts_initialized (kobj, bf);\n\n\tint iter;\n\tRKext *kext;\n\tr_kext_index_foreach (kobj->kexts, iter, kext) {\n\t\tut8 magicbytes[4];\n\n\t\tr_buf_read_at (kobj->cache_buf, kext->range.offset, magicbytes, 4);\n\t\tint magic = r_read_le32 (magicbytes);\n\t\tswitch (magic) {\n\t\tcase MH_MAGIC_64:\n\t\t\tsections_from_mach0 (ret, kext->mach0, bf, kext->range.offset, kext->name, kobj);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\teprintf (\"Unknown sub-bin\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsections_from_mach0 (ret, kobj->mach0, bf, 0, NULL, kobj);\n\n\tstruct MACH0_(segment_command) *seg;\n\tint nsegs = R_MIN (kobj->mach0->nsegs, 128);\n\tint i;\n\tfor (i = 0; i < nsegs; i++) {\n\t\tchar segname[17];\n\t\tRBinSection *ptr = R_NEW0 (RBinSection);\n\t\tif (!ptr) {\n\t\t\tbreak;\n\t\t}\n\n\t\tseg = &kobj->mach0->segs[i];\n\t\tr_str_ncpy (segname, seg->segname, 17);\n\t\tr_str_filter (segname, -1);\n\t\tptr->name = r_str_newf (\"%d.%s\", i, segname);\n\t\tptr->size = seg->vmsize;\n\t\tptr->vsize = seg->vmsize;\n\t\tptr->paddr = seg->fileoff + bf->bo->boffset;\n\t\tptr->vaddr = seg->vmaddr;\n\t\tptr->add = true;\n\t\tptr->is_segment = true;\n\t\tif (!ptr->vaddr) {\n\t\t\tptr->vaddr = ptr->paddr;\n\t\t}\n\t\tptr->perm = prot2perm (seg->initprot);\n\t\tr_list_append (ret, ptr);\n\t}\n\n\treturn ret;\n}\n\nstatic int prot2perm(int x) {\n\tint r = 0;\n\tif (x&1) r |= 4;\n\tif (x&2) r |= 2;\n\tif (x&4) r |= 1;\n\treturn r;\n}\n\nstatic void sections_from_mach0(RList *ret, struct MACH0_(obj_t) *mach0, RBinFile *bf, ut64 paddr, char *prefix, RKernelCacheObj *obj) {\n\tconst RVector *sections = MACH0_(load_sections) (mach0);\n\tif (!sections) {\n\t\treturn;\n\t}\n\n\tstruct section_t *section;\n\tr_vector_foreach (sections, section) {\n\t\tRBinSection *ptr;\n\t\tif (!(ptr = R_NEW0 (RBinSection))) {\n\t\t\tbreak;\n\t\t}\n\t\tif (prefix) {\n\t\t\tptr->name = r_str_newf (\"%s.%s\", prefix, (char*)section->name);\n\t\t} else {\n\t\t\tptr->name = r_str_newf (\"%s\", (char*)section->name);\n\t\t}\n\t\tif (strstr (ptr->name, \"la_symbol_ptr\")) {\n\t\t\tint len = section->size / 8;\n\t\t\tptr->format = r_str_newf (\"Cd %d[%d]\", 8, len);\n\t\t}\n\t\thandle_data_sections (ptr);\n\t\tptr->size = section->size;\n\t\tptr->vsize = section->vsize;\n\t\tptr->paddr = section->paddr + bf->bo->boffset + paddr;\n\t\tptr->vaddr = K_PPTR (section->vaddr) + 0x1c;\n\t\tif (!ptr->vaddr) {\n\t\t\tptr->vaddr = ptr->paddr;\n\t\t}\n\t\tptr->perm = section->perm;\n\t\tif (!ptr->perm && strstr (section->name, \"__TEXT_EXEC.__text\")) {\n\t\t\tptr->perm = 1 | 4;\n\t\t}\n\t\tr_list_append (ret, ptr);\n\t}\n}\n\nstatic void handle_data_sections(RBinSection *sect) {\n\tif (strstr (sect->name, \"_cstring\")) {\n\t\tsect->is_data = true;\n\t} else if (strstr (sect->name, \"_os_log\")) {\n\t\tsect->is_data = true;\n\t} else if (strstr (sect->name, \"_objc_methname\")) {\n\t\tsect->is_data = true;\n\t} else if (strstr (sect->name, \"_objc_classname\")) {\n\t\tsect->is_data = true;\n\t} else if (strstr (sect->name, \"_objc_methtype\")) {\n\t\tsect->is_data = true;\n\t}\n}\n\nstatic RList *symbols(RBinFile *bf) {\n\tRList *ret = r_list_newf (r_bin_symbol_free);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\n\tRKernelCacheObj *obj = (RKernelCacheObj*) bf->bo->bin_obj;\n\n\tsymbols_from_mach0 (ret, obj->mach0, bf, 0, 0);\n\n\tHtPP *kernel_syms_by_addr = sdb_ht_new ();\n\tif (!kernel_syms_by_addr) {\n\t\tr_list_free (ret);\n\t\treturn NULL;\n\t}\n\n\tRListIter *iter;\n\tRBinSymbol *sym;\n\tut64 enosys_addr = 0;\n\tr_list_foreach (ret, iter, sym) {\n\t\tr_strf_var (key, 64, \"%\"PFMT64x, sym->vaddr);\n\t\tsdb_ht_insert (kernel_syms_by_addr, key, sym->dname ? sym->dname : sym->name);\n\t\tif (!enosys_addr && strstr (sym->name, \"enosys\")) {\n\t\t\tenosys_addr = sym->vaddr;\n\t\t}\n\t}\n\n\tRList *syscalls = resolve_syscalls (obj, enosys_addr);\n\tif (syscalls) {\n\t\tr_list_foreach (syscalls, iter, sym) {\n\t\t\tr_strf_var (key, 32, \"%\"PFMT64x, sym->vaddr);\n\t\t\tsdb_ht_insert (kernel_syms_by_addr, key, sym->name);\n\t\t\tr_list_append (ret, sym);\n\t\t}\n\t\tsyscalls->free = NULL;\n\t\tr_list_free (syscalls);\n\t}\n\n\tRList *subsystem = resolve_mig_subsystem (obj);\n\tif (subsystem) {\n\t\tr_list_foreach (subsystem, iter, sym) {\n\t\t\tr_strf_var (key, 64, \"%\"PFMT64x, sym->vaddr);\n\t\t\tsdb_ht_insert (kernel_syms_by_addr, key, sym->name);\n\t\t\tr_list_append (ret, sym);\n\t\t}\n\t\tsubsystem->free = NULL;\n\t\tr_list_free (subsystem);\n\t}\n\n\tensure_kexts_initialized (obj, bf);\n\n\tRKext *kext;\n\tint kiter;\n\tut64 *inits = NULL;\n\tut64 *terms = NULL;\n\tr_kext_index_foreach (obj->kexts, kiter, kext) {\n\t\tut8 magicbytes[4];\n\t\tr_buf_read_at (obj->cache_buf, kext->range.offset, magicbytes, 4);\n\t\tint magic = r_read_le32 (magicbytes);\n\t\tswitch (magic) {\n\t\tcase MH_MAGIC_64:\n\t\t\tsymbols_from_mach0 (ret, kext->mach0, bf, kext->range.offset, r_list_length (ret));\n\t\t\tsymbols_from_stubs (ret, kernel_syms_by_addr, obj, bf, kext, r_list_length (ret));\n\t\t\tprocess_constructors (obj, kext->mach0, ret, kext->range.offset, false, R_K_CONSTRUCTOR_TO_SYMBOL, kext_short_name (kext));\n\t\t\tprocess_kmod_init_term (obj, kext, ret, &inits, &terms);\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\teprintf (\"Unknown sub-bin\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tR_FREE (inits);\n\tR_FREE (terms);\n\n\tsdb_ht_free (kernel_syms_by_addr);\n\n\treturn ret;\n}\n\nstatic void symbols_from_mach0(RList *ret, struct MACH0_(obj_t) *mo, RBinFile *bf, ut64 paddr, int ordinal) {\n\tif (!MACH0_(load_symbols) (mo)) {\n\t\treturn;\n\t}\n\tRVecRBinSymbol *symbols = mo->symbols_vec;\n\n\tint i = 0;\n\tRBinSymbol *sym;\n\tR_VEC_FOREACH (symbols, sym) {\n\t\tRBinSymbol *ret_sym = R_NEW0 (RBinSymbol);\n\t\tif (!sym) {\n\t\t\tbreak;\n\t\t}\n\n\t\tret_sym->name = strdup (sym->name);\n\t\tif (ret_sym->name[0] == '_') {\n\t\t\tif (sym->dname) {\n\t\t\t\tret_sym->dname = strdup (sym->dname);\n\t\t\t}\n\t\t\tif (sym->classname) {\n\t\t\t\tret_sym->classname = strdup (sym->classname);\n\t\t\t}\n\t\t}\n\t\tret_sym->vaddr = sym->vaddr;\n\t\tret_sym->paddr = sym->paddr + paddr;\n\t\tret_sym->forwarder = \"NONE\";\n\t\tret_sym->bind = sym->bind;\n\t\tret_sym->type = R_BIN_TYPE_FUNC_STR;\n\t\tret_sym->size = sym->size;\n\t\tret_sym->ordinal = i;\n\t\tr_list_append (ret, ret_sym);\n\t\ti++;\n\t}\n}\n\n#define IS_KERNEL_ADDR(x) ((x & 0xfffffff000000000L) == 0xfffffff000000000L)\n\ntypedef struct _r_sysent {\n\tut64 sy_call;\n\tut64 sy_arg_munge32;\n\tst32 sy_return_type;\n\tst16 sy_narg;\n\tut16 sy_arg_bytes;\n} RSysEnt;\n\nstatic RList *resolve_syscalls(RKernelCacheObj *obj, ut64 enosys_addr) {\n\tconst RVector *sections = MACH0_(load_sections) (obj->mach0);\n\tif (!sections) {\n\t\treturn NULL;\n\t}\n\n\tRList *syscalls = NULL;\n\tRSyscall *syscall = NULL;\n\tut8 *data_const = NULL;\n\tut64 data_const_offset = 0, data_const_size = 0, data_const_vaddr = 0;\n\tstruct section_t *section;\n\tr_vector_foreach (sections, section) {\n\t\tif (strstr (section->name, \"__DATA_CONST.__const\")) {\n\t\t\tdata_const_offset = section->paddr;\n\t\t\tdata_const_size = section->size;\n\t\t\tdata_const_vaddr = K_PPTR (section->vaddr);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!data_const_offset || !data_const_size || !data_const_vaddr) {\n\t\tgoto beach;\n\t}\n\n\tdata_const = malloc (data_const_size);\n\tif (!data_const) {\n\t\tgoto beach;\n\t}\n\tif (r_buf_read_at (obj->cache_buf, data_const_offset, data_const, data_const_size) < data_const_size) {\n\t\tgoto beach;\n\t}\n\n\tut8 *cursor = data_const;\n\tut8 *end = data_const + data_const_size;\n\twhile (cursor < end) {\n\t\tut64 test = r_read_le64 (cursor);\n\t\tif (test == enosys_addr) {\n\t\t\tbreak;\n\t\t}\n\t\tcursor += 8;\n\t}\n\n\tif (cursor >= end) {\n\t\tgoto beach;\n\t}\n\n\tcursor -= 24;\n\twhile (cursor >= data_const) {\n\t\tut64 addr = r_read_le64 (cursor);\n\t\tut64 x = r_read_le64 (cursor + 8);\n\t\tut64 y = r_read_le64 (cursor + 16);\n\n\t\tif (IS_KERNEL_ADDR (addr) &&\n\t\t\t(x == 0 || IS_KERNEL_ADDR (x)) &&\n\t\t\t(y != 0 && !IS_KERNEL_ADDR (y))) {\n\t\t\tcursor -= 24;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcursor += 24;\n\t\tbreak;\n\t}\n\n\tif (cursor < data_const) {\n\t\tgoto beach;\n\t}\n\n\tsyscalls = r_list_newf (r_bin_symbol_free);\n\tif (!syscalls) {\n\t\tgoto beach;\n\t}\n\n\tsyscall = r_syscall_new ();\n\tif (!syscall) {\n\t\tgoto beach;\n\t}\n\tr_syscall_setup (syscall, \"arm\", 64, NULL, \"ios\");\n\tif (!syscall->db) {\n\t\tr_syscall_free (syscall);\n\t\tgoto beach;\n\t}\n\n\tut64 sysent_vaddr = cursor - data_const + data_const_vaddr;\n\n\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\tif (!sym) {\n\t\tgoto beach;\n\t}\n\n\tsym->name = r_str_newf (\"sysent\");\n\tsym->vaddr = sysent_vaddr;\n\tsym->paddr = cursor - data_const + data_const_offset;\n\tsym->size = 0;\n\tsym->forwarder = \"NONE\";\n\tsym->bind = \"GLOBAL\";\n\tsym->type = \"OBJECT\";\n\tr_list_append (syscalls, sym);\n\n\tint i = 1;\n\tcursor += 24;\n\tint num_syscalls = sdb_count (syscall->db);\n\twhile (cursor < end && i < num_syscalls) {\n\t\tut64 addr = r_read_le64 (cursor);\n\t\tRSyscallItem *item = r_syscall_get (syscall, i, 0x80);\n\t\tif (item && item->name) {\n\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\tif (!sym) {\n\t\t\t\tr_syscall_item_free (item);\n\t\t\t\tgoto beach;\n\t\t\t}\n\n\t\t\tsym->name = r_str_newf (\"syscall.%d.%s\", i, item->name);\n\t\t\tsym->vaddr = addr;\n\t\t\tsym->paddr = addr;\n\t\t\tsym->size = 0;\n\t\t\tsym->forwarder = \"NONE\";\n\t\t\tsym->bind = \"GLOBAL\";\n\t\t\tsym->type = \"FUNC\";\n\t\t\tr_list_append (syscalls, sym);\n\t\t}\n\t\tr_syscall_item_free (item);\n\t\tcursor += 24;\n\t\ti++;\n\t}\n\n\tr_syscall_free (syscall);\n\tR_FREE (data_const);\n\treturn syscalls;\n\nbeach:\n\tr_syscall_free (syscall);\n\tif (syscalls) {\n\t\tr_list_free (syscalls);\n\t}\n\tR_FREE (data_const);\n\treturn NULL;\n}\n\n#define K_MIG_SUBSYSTEM_SIZE (4 * 8)\n#define K_MIG_ROUTINE_SIZE (5 * 8)\n#define K_MIG_MAX_ROUTINES 100\n\nstatic HtPP *mig_hash_new(void) {\n\tHtPP *hash = sdb_ht_new ();\n\tif (!hash) {\n\t\treturn NULL;\n\t}\n\n\tint i;\n\tfor (i = 0; i < R_MIG_INDEX_LEN; i += 2) {\n\t\tconst char *num = mig_index[i];\n\t\tconst char *name = mig_index[i+1];\n\t\tsdb_ht_insert (hash, num, name);\n\t}\n\n\treturn hash;\n}\n\nstatic RList *resolve_mig_subsystem(RKernelCacheObj *obj) {\n\tconst RVector *sections = MACH0_(load_sections) (obj->mach0);\n\tif (!sections) {\n\t\treturn NULL;\n\t}\n\n\tHtPP *mig_hash = NULL;\n\tRList *subsystem = NULL;\n\tut8 *data_const = NULL;\n\tut64 data_const_offset = 0, data_const_size = 0, data_const_vaddr = 0;\n\tut64 text_exec_offset = 0, text_exec_size = 0, text_exec_vaddr = 0;\n\tint incomplete = 2;\n\n\tstruct section_t *section;\n\tr_vector_foreach (sections, section) {\n\t\tif (strstr (section->name, \"__DATA_CONST.__const\")) {\n\t\t\tdata_const_offset = section->paddr;\n\t\t\tdata_const_size = section->size;\n\t\t\tdata_const_vaddr = K_PPTR (section->vaddr);\n\t\t\tincomplete--;\n\t\t}\n\t\tif (strstr (section->name, \"__TEXT_EXEC.__text\")) {\n\t\t\ttext_exec_offset = section->paddr;\n\t\t\ttext_exec_size = section->size;\n\t\t\ttext_exec_vaddr = K_PPTR (section->vaddr);\n\t\t\tincomplete--;\n\t\t}\n\t}\n\tif (incomplete) {\n\t\treturn NULL;\n\t}\n\n\tif (!data_const_offset || !data_const_size || !data_const_vaddr ||\n\t\t!text_exec_offset || !text_exec_size || !text_exec_vaddr) {\n\t\tgoto beach;\n\t}\n\n\tdata_const = malloc (data_const_size);\n\tif (!data_const) {\n\t\tgoto beach;\n\t}\n\tif (r_buf_read_at (obj->cache_buf, data_const_offset, data_const, data_const_size) < data_const_size) {\n\t\tgoto beach;\n\t}\n\n\tsubsystem = r_list_newf (r_bin_symbol_free);\n\tif (!subsystem) {\n\t\tgoto beach;\n\t}\n\n\tmig_hash = mig_hash_new ();\n\tif (!mig_hash) {\n\t\tgoto beach;\n\t}\n\n\tut8 *cursor = data_const;\n\tut8 *end = data_const + data_const_size;\n\twhile (cursor < end) {\n\t\tut64 subs_p = K_PPTR (r_read_le64 (cursor));\n\t\tif (subs_p < text_exec_vaddr || subs_p >= text_exec_vaddr + text_exec_size) {\n\t\t\tcursor += 8;\n\t\t\tcontinue;\n\t\t}\n\t\tut32 subs_min_idx = r_read_le32 (cursor + 8);\n\t\tut32 subs_max_idx = r_read_le32 (cursor + 12);\n\t\tif (subs_min_idx >= subs_max_idx || (subs_max_idx - subs_min_idx) > K_MIG_MAX_ROUTINES) {\n\t\t\tcursor += 16;\n\t\t\tcontinue;\n\t\t}\n\n\t\tut32 n_routines = (subs_max_idx - subs_min_idx);\n\t\tut64 *routines = (ut64 *) calloc (n_routines, sizeof (ut64));\n\t\tif (!routines) {\n\t\t\tgoto beach;\n\t\t}\n\t\tut8 *array_cursor = cursor + K_MIG_SUBSYSTEM_SIZE;\n\t\tut8 *end_array = array_cursor + n_routines * K_MIG_ROUTINE_SIZE;\n\t\tbool is_consistent = true;\n\t\tint idx = 0;\n\t\twhile (array_cursor < end_array) {\n\t\t\tut64 should_be_null = r_read_le64 (array_cursor);\n\t\t\tif (should_be_null != 0) {\n\t\t\t\tis_consistent = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tut64 routine_p = K_PPTR (r_read_le64 (array_cursor + 8));\n\t\t\tif (routine_p != 0 && (routine_p < text_exec_vaddr || routine_p >= text_exec_vaddr + text_exec_size)) {\n\t\t\t\tis_consistent = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\troutines[idx++] = routine_p;\n\t\t\tarray_cursor += K_MIG_ROUTINE_SIZE;\n\t\t}\n\n\t\tif (is_consistent) {\n\t\t\tfor (idx = 0; idx < n_routines; idx++) {\n\t\t\t\tut64 routine_p = routines[idx];\n\t\t\t\tif (!routine_p) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\t\tif (!sym) {\n\t\t\t\t\tR_FREE (routines);\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\n\t\t\t\tint num = idx + subs_min_idx;\n\t\t\t\tbool found = false;\n\t\t\t\tr_strf_var (key, 32, \"%d\", num);\n\t\t\t\tconst char *name = sdb_ht_find (mig_hash, key, &found);\n\t\t\t\tif (found && name && *name) {\n\t\t\t\t\tsym->name = r_str_newf (\"mig.%d.%s\", num, name);\n\t\t\t\t} else {\n\t\t\t\t\tsym->name = r_str_newf (\"mig.%d\", num);\n\t\t\t\t}\n\n\t\t\t\tsym->vaddr = routine_p;\n\t\t\t\tsym->paddr = sym->vaddr - text_exec_vaddr + text_exec_offset;\n\t\t\t\tsym->size = 0;\n\t\t\t\tsym->forwarder = \"NONE\";\n\t\t\t\tsym->bind = \"GLOBAL\";\n\t\t\t\tsym->type = \"OBJECT\";\n\t\t\t\tr_list_append (subsystem, sym);\n\t\t\t}\n\n\t\t\tcursor += K_MIG_SUBSYSTEM_SIZE + n_routines * K_MIG_ROUTINE_SIZE;\n\t\t} else {\n\t\t\tcursor += 8;\n\t\t}\n\n\t\tR_FREE (routines);\n\t}\n\n\tsdb_ht_free (mig_hash);\n\tR_FREE (data_const);\n\treturn subsystem;\n\nbeach:\n\tif (subsystem) {\n\t\tr_list_free (subsystem);\n\t}\n\tif (mig_hash) {\n\t\tsdb_ht_free (mig_hash);\n\t}\n\tR_FREE (data_const);\n\treturn NULL;\n}\n\nstatic ut64 extract_addr_from_code(ut8 *arm64_code, ut64 vaddr) {\n\tut64 addr = vaddr & ~0xfff;\n\n\tut64 adrp = r_read_le32 (arm64_code);\n\tut64 adrp_offset = ((adrp & 0x60000000) >> 29) | ((adrp & 0xffffe0) >> 3);\n\taddr += adrp_offset << 12;\n\n\tut64 ldr = r_read_le32 (arm64_code + 4);\n\taddr += ((ldr & 0x3ffc00) >> 10) << ((ldr & 0xc0000000) >> 30);\n\n\treturn addr;\n}\n\nstatic void symbols_from_stubs(RList *ret, HtPP *kernel_syms_by_addr, RKernelCacheObj *obj, RBinFile *bf, RKext *kext, int ordinal) {\n\tRStubsInfo *stubs_info = get_stubs_info(kext->mach0, kext->range.offset, obj);\n\tif (!stubs_info) {\n\t\treturn;\n\t}\n\tut64 stubs_cursor = stubs_info->stubs.offset;\n\tut64 stubs_end = stubs_cursor + stubs_info->stubs.size;\n\n\tfor (; stubs_cursor < stubs_end; stubs_cursor += 12) {\n\t\tut8 arm64_code[8];\n\t\tif (r_buf_read_at (obj->cache_buf, stubs_cursor, arm64_code, 8) < 8) {\n\t\t\tbreak;\n\t\t}\n\n\t\tut64 vaddr = stubs_cursor + obj->pa2va_exec;\n\t\tut64 addr_in_got = extract_addr_from_code (arm64_code, vaddr);\n\n\t\tbool found = false;\n\t\tint level = 3;\n\n\t\tut64 target_addr = UT64_MAX;\n\n\t\twhile (!found && level-- > 0) {\n\t\t\tut64 offset_in_got = addr_in_got - obj->pa2va_exec;\n\t\t\tut64 addr;\n\t\t\tif (r_buf_read_at (obj->cache_buf, offset_in_got, (ut8*) &addr, 8) < 8) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (level == 2) {\n\t\t\t\ttarget_addr = addr;\n\t\t\t}\n\n\t\t\tr_strf_var (key, 32, \"%\"PFMT64x, addr);\n\t\t\tconst char *name = sdb_ht_find (kernel_syms_by_addr, key, &found);\n\n\t\t\tif (found) {\n\t\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\t\tif (!sym) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsym->name = r_str_newf (\"stub.%s\", name);\n\t\t\t\tsym->vaddr = vaddr;\n\t\t\t\tsym->paddr = stubs_cursor;\n\t\t\t\tsym->size = 12;\n\t\t\t\tsym->forwarder = \"NONE\";\n\t\t\t\tsym->bind = \"LOCAL\";\n\t\t\t\tsym->type = \"FUNC\";\n\t\t\t\tsym->ordinal = ordinal ++;\n\t\t\t\tr_list_append (ret, sym);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\taddr_in_got = addr;\n\t\t}\n\n\t\tif (found || target_addr == UT64_MAX) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tensure_kexts_initialized (obj, bf);\n\t\tRKext *remote_kext = r_kext_index_vget (obj->kexts, target_addr);\n\t\tif (!remote_kext) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tRBinSymbol *remote_sym = R_NEW0 (RBinSymbol);\n\t\tif (!remote_sym) {\n\t\t\tbreak;\n\t\t}\n\n\t\tremote_sym->name = r_str_newf (\"exp.%s.0x%\"PFMT64x, kext_short_name (remote_kext), target_addr);\n\t\tremote_sym->vaddr = target_addr;\n\t\tremote_sym->paddr = target_addr - obj->pa2va_exec;\n\t\tremote_sym->size = 0;\n\t\tremote_sym->forwarder = \"NONE\";\n\t\tremote_sym->bind = \"GLOBAL\";\n\t\tremote_sym->type = \"FUNC\";\n\t\tremote_sym->ordinal = ordinal ++;\n\t\tr_list_append (ret, remote_sym);\n\n\t\tRBinSymbol *local_sym = R_NEW0 (RBinSymbol);\n\t\tif (!local_sym) {\n\t\t\tbreak;\n\t\t}\n\n\t\tlocal_sym->name = r_str_newf (\"stub.%s.0x%\"PFMT64x, kext_short_name (remote_kext), target_addr);\n\t\tlocal_sym->vaddr = vaddr;\n\t\tlocal_sym->paddr = stubs_cursor;\n\t\tlocal_sym->size = 12;\n\t\tlocal_sym->forwarder = \"NONE\";\n\t\tlocal_sym->bind = \"GLOBAL\";\n\t\tlocal_sym->type = \"FUNC\";\n\t\tlocal_sym->ordinal = ordinal ++;\n\t\tr_list_append (ret, local_sym);\n\t}\n\n\tR_FREE (stubs_info);\n}\n\nstatic RStubsInfo *get_stubs_info(struct MACH0_(obj_t) *mach0, ut64 paddr, RKernelCacheObj *obj) {\n\tconst RVector *sections = MACH0_(load_sections) (mach0);\n\tif (!sections) {\n\t\treturn NULL;\n\t}\n\n\tRStubsInfo *stubs_info = R_NEW0 (RStubsInfo);\n\tif (!stubs_info) {\n\t\treturn NULL;\n\t}\n\n\tint incomplete = 2;\n\tstruct section_t *section;\n\tr_vector_foreach (sections, section) {\n\t\tif (strstr (section->name, \"__DATA_CONST.__got\")) {\n\t\t\tstubs_info->got.offset = section->paddr + paddr;\n\t\t\tstubs_info->got.size = section->size;\n\t\t\tstubs_info->got_addr = K_PPTR (section->vaddr);\n\t\t\tif (!--incomplete) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (strstr (section->name, \"__TEXT_EXEC.__stubs\")) {\n\t\t\tstubs_info->stubs.offset = section->paddr + paddr;\n\t\t\tstubs_info->stubs.size = section->size;\n\t\t\tif (!--incomplete) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (incomplete) {\n\t\tR_FREE (stubs_info);\n\t}\n\n\treturn stubs_info;\n}\n\nstatic RBinInfo *info(RBinFile *bf) {\n\tbool big_endian = 0;\n\tRBinInfo *ret = R_NEW0 (RBinInfo);\n\tif (ret) {\n\t\tret->file = strdup (bf->file);\n\t\tret->bclass = strdup (\"kernelcache\");\n\t\tret->rclass = strdup (\"ios\");\n\t\tret->os = strdup (\"iOS\");\n\t\tret->arch = strdup (\"arm\"); // XXX\n\t\tret->machine = strdup (ret->arch);\n\t\tret->subsystem = strdup (\"xnu\");\n\t\tret->type = strdup (\"kernel-cache\");\n\t\tret->bits = 64;\n\t\tret->has_va = true;\n\t\tret->big_endian = big_endian;\n\t\tret->dbg_info = 0;\n\t}\n\treturn ret;\n}\n\nstatic ut64 baddr(RBinFile *bf) {\n\tif (!bf || !bf->bo || !bf->bo->bin_obj) {\n\t\treturn 0; // 8LL; // w t f\n\t}\n\tRKernelCacheObj *obj = (RKernelCacheObj*) bf->bo->bin_obj;\n\treturn MACH0_(get_baddr)(obj->mach0);\n}\n\nstatic void destroy(RBinFile *bf) {\n\tr_kernel_cache_free ((RKernelCacheObj*) bf->bo->bin_obj);\n}\n\nstatic void r_kernel_cache_free(RKernelCacheObj *obj) {\n\tif (!obj) {\n\t\treturn;\n\t}\n\n\tif (obj->mach0) {\n\t\tMACH0_(mach0_free) (obj->mach0);\n\t\tobj->mach0 = NULL;\n\t\tobj->cache_buf = NULL;\n\t}\n\n\tif (obj->cache_buf) {\n\t\tr_buf_free (obj->cache_buf);\n\t\tobj->cache_buf = NULL;\n\t}\n\n\tif (obj->prelink_info) {\n\t\tr_cf_value_dict_free (obj->prelink_info);\n\t\tobj->prelink_info = NULL;\n\t}\n\n\tif (obj->kexts) {\n\t\tr_kext_index_free (obj->kexts);\n\t\tobj->kexts = NULL;\n\t}\n\n\tif (obj->rebase_info) {\n\t\tr_rebase_info_free (obj->rebase_info);\n\t\tobj->rebase_info = NULL;\n\t}\n\n\tR_FREE (obj);\n}\n\nstatic RRebaseInfo *r_rebase_info_new_from_mach0(RBuffer *cache_buf, struct MACH0_(obj_t) *mach0) {\n\tconst RVector *sections = MACH0_(load_sections) (mach0);\n\tif (!sections) {\n\t\treturn NULL;\n\t}\n\n\tut64 starts_offset = 0, starts_size = 0;\n\n\tstruct section_t *section;\n\tr_vector_foreach (sections, section) {\n\t\tif (strstr (section->name, \"__TEXT.__thread_starts\")) {\n\t\t\tstarts_offset = section->paddr;\n\t\t\tstarts_size = section->size;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tut64 kernel_base = 0;\n\n\tstruct MACH0_(segment_command) *seg;\n\tint nsegs = R_MIN (mach0->nsegs, 128);\n\tint i;\n\tfor (i = 0; i < nsegs; i++) {\n\t\tchar segname[17];\n\t\tseg = &mach0->segs[i];\n\t\tr_str_ncpy (segname, seg->segname, 17);\n\t\tif (!strncmp (segname, \"__TEXT\", 6) && segname[6] == '\\0') {\n\t\t\tkernel_base = seg->vmaddr;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (starts_offset == 0 || starts_size == 0 || kernel_base == 0) {\n\t\treturn NULL;\n\t}\n\n\tint n_starts = starts_size / 4;\n\tif (n_starts <= 1) {\n\t\treturn NULL;\n\t}\n\tRFileRange *rebase_ranges = R_NEWS0 (RFileRange, n_starts - 1);\n\tif (!rebase_ranges) {\n\t\treturn NULL;\n\t}\n\n\tut64 multiplier = 4;\n\tfor (i = 0; i != n_starts; i++) {\n\t\tut8 bytes[4];\n\t\tif (r_buf_read_at (cache_buf, starts_offset + i * 4, bytes, 4) < 4) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (i == 0) {\n\t\t\tmultiplier += 4 * (r_read_le32 (bytes) & 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\trebase_ranges[i - 1].offset = r_read_le32 (bytes);\n\t\trebase_ranges[i - 1].size = UT64_MAX;\n\t}\n\tif (i == n_starts) {\n\t\tRRebaseInfo *rebase_info = R_NEW0 (RRebaseInfo);\n\t\tif (rebase_info) {\n\t\t\trebase_info->ranges = rebase_ranges;\n\t\t\trebase_info->n_ranges = n_starts - 1;\n\t\t\trebase_info->multiplier = multiplier;\n\t\t\trebase_info->kernel_base = kernel_base;\n\t\t\treturn rebase_info;\n\t\t}\n\t}\n\tR_FREE (rebase_ranges);\n\treturn NULL;\n}\n\nstatic void r_rebase_info_free(RRebaseInfo *info) {\n\tif (info) {\n\t\tfree (info->ranges);\n\t\tfree (info);\n\t}\n}\n\nstatic void r_rebase_info_populate(RRebaseInfo *info, RKernelCacheObj *obj) {\n\tconst RVector *sections = NULL;\n\tint i = 0;\n\n\tif (obj->rebase_info_populated) {\n\t\treturn;\n\t}\n\tobj->rebase_info_populated = true;\n\n\tfor (; i < info->n_ranges; i++) {\n\t\tif (info->ranges[i].size != UT64_MAX) {\n\t\t\treturn;\n\t\t} else if (sections == NULL) {\n\t\t\tsections = MACH0_(load_sections) (obj->mach0);\n\t\t\tif (!sections) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tinfo->ranges[i].offset = r_rebase_offset_to_paddr (obj, sections, info->ranges[i].offset);\n\t\tut64 end = iterate_rebase_list (obj->cache_buf, info->multiplier, info->ranges[i].offset, NULL, NULL);\n\t\tif (end != UT64_MAX) {\n\t\t\tinfo->ranges[i].size = end - info->ranges[i].offset + 8;\n\t\t} else {\n\t\t\tinfo->ranges[i].size = 0;\n\t\t}\n\t}\n}\n\nstatic ut64 r_rebase_offset_to_paddr(RKernelCacheObj *obj, const RVector *sections, ut64 offset) {\n\tut64 vaddr = obj->rebase_info->kernel_base + offset;\n\tstruct section_t *section;\n\tr_vector_foreach (sections, section) {\n\t\tif (section->vaddr <= vaddr && vaddr < (section->vaddr + section->vsize)) {\n\t\t\treturn section->paddr + (vaddr - section->vaddr);\n\t\t}\n\t}\n\treturn offset;\n}\n\nstatic ut64 iterate_rebase_list(RBuffer *cache_buf, ut64 multiplier, ut64 start_offset, ROnRebaseFunc func, void *user_data) {\n\tut8 bytes[8];\n\tut64 cursor = start_offset;\n\n\twhile (true) {\n\t\tif (r_buf_read_at (cache_buf, cursor, bytes, 8) < 8) {\n\t\t\treturn UT64_MAX;\n\t\t}\n\n\t\tut64 decorated_addr = r_read_le64 (bytes);\n\n\t\tif (func) {\n\t\t\tbool carry_on = func (cursor, decorated_addr, user_data);\n\t\t\tif (!carry_on) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tut64 delta = ((decorated_addr >> 51) & 0x7ff) * multiplier;\n\t\tif (delta == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tcursor += delta;\n\t}\n\n\treturn cursor;\n}\n\nstatic void swizzle_io_read(RKernelCacheObj *obj, RIO *io) {\n\tr_return_if_fail (io && io->desc && io->desc->plugin);\n\tRIOPlugin *plugin = io->desc->plugin;\n\tobj->original_io_read = plugin->read;\n\tplugin->read = &kernelcache_io_read;\n}\n\nstatic int kernelcache_io_read(RIO *io, RIODesc *fd, ut8 *buf, int count) {\n\tr_return_val_if_fail (io, -1);\n\tRCore *core = (RCore*) io->coreb.core;\n\n\tif (!fd || !core || !core->bin || !core->bin->binfiles) {\n\t\treturn -1;\n\t}\n\n\tRKernelCacheObj *cache = NULL;\n\tRListIter *iter;\n\tRBinFile *bf;\n\tr_list_foreach (core->bin->binfiles, iter, bf) {\n\t\tif (bf->fd == fd->fd && bf->bo && bf->bo->bin_obj) {\n\t\t\tcache = bf->bo->bin_obj;\n\t\t\tif (pending_bin_files) {\n\t\t\t\tRListIter *to_remove = r_list_contains (pending_bin_files, bf);\n\t\t\t\tif (to_remove) {\n\t\t\t\t\tr_list_delete (pending_bin_files, to_remove);\n\t\t\t\t\tif (r_list_empty (pending_bin_files)) {\n\t\t\t\t\t\tr_list_free (pending_bin_files);\n\t\t\t\t\t\tpending_bin_files = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!cache) {\n\t\tr_list_foreach (pending_bin_files, iter, bf) {\n\t\t\tif (bf->fd == fd->fd && bf->bo) {\n\t\t\t\tcache = bf->bo->bin_obj;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!cache || !cache->original_io_read || cache->rebasing_buffer) {\n\t\tif (cache) {\n\t\t\tif ((!cache->rebasing_buffer && fd->plugin->read == &kernelcache_io_read) ||\n\t\t\t\t\t(cache->rebasing_buffer && !cache->original_io_read)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (cache->rebasing_buffer) {\n\t\t\t\treturn cache->original_io_read (io, fd, buf, count);\n\t\t\t}\n\t\t}\n\t\tif (fd->plugin->read == kernelcache_io_read) {\n\t\t\tif (core->bin->verbose) {\n\t\t\t\teprintf (\"Avoid recursive reads\\n\");\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\treturn fd->plugin->read (io, fd, buf, count);\n\t}\n\n\tif (cache->rebase_info) {\n\t\tr_rebase_info_populate (cache->rebase_info, cache);\n\t}\n\tif (!cache->original_io_read) {\n\t\treturn -1;\n\t}\n\n\t// move into\n\tif (count > cache->internal_buffer_size) {\n\t\tif (cache->internal_buffer) {\n\t\t\tR_FREE (cache->internal_buffer);\n\t\t}\n\t\tcache->internal_buffer_size = R_MAX (count, 8);\n\t\tcache->internal_buffer = (ut8 *) calloc (1, cache->internal_buffer_size);\n\t\tif (!cache->internal_buffer) {\n\t\t\tcache->internal_buffer_size = 0;\n\t\t\treturn -1;\n\t\t}\n\t}\n\tut64 io_off = io->off;\n\tint result = cache->original_io_read (io, fd, cache->internal_buffer, count);\n\tif (result == count) {\n\t\tif (cache->mach0->chained_starts) {\n\t\t\trebase_buffer_fixup (cache, io_off, fd, cache->internal_buffer, count);\n\t\t} else if (cache->rebase_info) {\n\t\t\trebase_buffer (cache, io_off, fd, cache->internal_buffer, count);\n\t\t}\n\t\tmemcpy (buf, cache->internal_buffer, result);\n\t}\n\n\treturn result;\n}\n\nstatic bool on_rebase_pointer(ut64 offset, ut64 decorated_addr, RRebaseCtx *ctx) {\n\tif (offset < ctx->off) {\n\t\treturn true;\n\t}\n\tif (offset >= ctx->eob) {\n\t\treturn false;\n\t}\n\tut64 in_buf = offset - ctx->off;\n\tif (in_buf >= ctx->count || (in_buf + 8) > ctx->count) {\n\t\treturn false;\n\t}\n\n\tRParsedPointer ptr;\n\tr_ptr_undecorate (&ptr, decorated_addr, ctx->obj);\n\n\tr_write_le64 (&ctx->buf[in_buf], ptr.address);\n\n\treturn true;\n}\n\nstatic void rebase_buffer(RKernelCacheObj *obj, ut64 off, RIODesc *fd, ut8 *buf, int count) {\n\tif (obj->rebasing_buffer || !buf) {\n\t\treturn;\n\t}\n\tobj->rebasing_buffer = true;\n\n\tut64 eob = off + count;\n\tint i = 0;\n\tRRebaseCtx ctx;\n\n\tctx.off = off;\n\tctx.eob = eob;\n\tctx.buf = buf;\n\tctx.count = count;\n\tctx.obj = obj;\n\n\tfor (; i < obj->rebase_info->n_ranges; i++) {\n\t\tut64 start = obj->rebase_info->ranges[i].offset;\n\t\tut64 end = start + obj->rebase_info->ranges[i].size;\n\t\tif (end >= off && start <= eob) {\n\t\t\titerate_rebase_list (obj->cache_buf, obj->rebase_info->multiplier, start,\n\t\t\t\t(ROnRebaseFunc) on_rebase_pointer, &ctx);\n\t\t}\n\t}\n\n\tobj->rebasing_buffer = false;\n}\n\nstatic void rebase_buffer_fixup(RKernelCacheObj *kobj, ut64 off, RIODesc *fd, ut8 *buf, int count) {\n\tif (kobj->rebasing_buffer) {\n\t\treturn;\n\t}\n\tkobj->rebasing_buffer = true;\n\tstruct MACH0_(obj_t) *obj = kobj->mach0;\n\tut64 eob = off + count;\n\tsize_t i = 0;\n\tfor (; i < obj->segs_count; i++) {\n\t\tif (!obj->chained_starts[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tut64 page_size = obj->chained_starts[i]->page_size;\n\t\tut64 start = obj->segs[i].fileoff;\n\t\tut64 end = start + obj->segs[i].filesize;\n\t\tif (end >= off && start <= eob) {\n\t\t\tut64 page_idx = (R_MAX (start, off) - start) / page_size;\n\t\t\tut64 page_end_idx = (R_MIN (eob, end) - start) / page_size;\n\t\t\tfor (; page_idx <= page_end_idx; page_idx++) {\n\t\t\t\tif (page_idx >= obj->chained_starts[i]->page_count) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tut16 page_start = obj->chained_starts[i]->page_start[page_idx];\n\t\t\t\tif (page_start == DYLD_CHAINED_PTR_START_NONE) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tut64 cursor = start + page_idx * page_size + page_start;\n\t\t\t\twhile (cursor < eob && cursor < end) {\n\t\t\t\t\tut8 tmp[8];\n\t\t\t\t\tif (r_buf_read_at (obj->b, cursor, tmp, 8) != 8) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tut64 raw_ptr = r_read_le64 (tmp);\n\t\t\t\t\tut64 ptr_value = raw_ptr;\n\t\t\t\t\tut64 delta = 0;\n\t\t\t\t\tut64 stride = 8;\n\t\t\t\t\tif (obj->chained_starts[i]->pointer_format == DYLD_CHAINED_PTR_ARM64E) {\n\t\t\t\t\t\tbool is_auth = IS_PTR_AUTH (raw_ptr);\n\t\t\t\t\t\tbool is_bind = IS_PTR_BIND (raw_ptr);\n\t\t\t\t\t\tif (is_auth && is_bind) {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_bind *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_bind *) &raw_ptr;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t} else if (!is_auth && is_bind) {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_bind *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_bind *) &raw_ptr;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t} else if (is_auth && !is_bind) {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_rebase *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tptr_value = p->target + obj->baddr;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_rebase *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tptr_value = ((ut64)p->high8 << 56) | p->target;\n\t\t\t\t\t\t\tptr_value += obj->baddr;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (obj->chained_starts[i]->pointer_format == DYLD_CHAINED_PTR_64_KERNEL_CACHE ||\n\t\t\t\t\t\t\tobj->chained_starts[i]->pointer_format == DYLD_CHAINED_PTR_ARM64E_KERNEL) {\n\t\t\t\t\t\tbool is_auth = IS_PTR_AUTH (raw_ptr);\n\t\t\t\t\t\tstride = 4;\n\t\t\t\t\t\tif (is_auth) {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_cache_auth_rebase *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_cache_auth_rebase *) &raw_ptr;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tptr_value = p->target + obj->baddr;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_cache_rebase *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_cache_rebase *) &raw_ptr;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tptr_value = ((ut64)p->high8 << 56) | p->target;\n\t\t\t\t\t\t\tptr_value += obj->baddr;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\teprintf (\"Unsupported pointer format: %u\\n\", obj->chained_starts[i]->pointer_format);\n\t\t\t\t\t}\n\t\t\t\t\tut64 in_buf = cursor - off;\n\t\t\t\t\tif (cursor >= off && cursor <= eob - 8) {\n\t\t\t\t\t\tr_write_le64 (&buf[in_buf], ptr_value);\n\t\t\t\t\t}\n\t\t\t\t\tcursor += delta * stride;\n\t\t\t\t\tif (!delta) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tkobj->rebasing_buffer = false;\n}\n\nRBinPlugin r_bin_plugin_xnu_kernelcache = {\n\t.meta = {\n\t\t.name = \"kernelcache\",\n\t\t.desc = \"kernelcache bin plugin\",\n\t\t.license = \"LGPL3\",\n\t},\n\t.destroy = &destroy,\n\t.load = &load,\n\t.entries = &entries,\n\t.baddr = &baddr,\n\t.symbols = &symbols,\n\t.sections = &sections,\n\t.check = &check,\n\t.info = &info\n};\n\n#ifndef R2_PLUGIN_INCORE\nRLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_BIN,\n\t.data = &r_bin_plugin_kernelcache,\n\t.version = R2_VERSION\n};\n#endif\n"], "filenames": ["libr/bin/p/bin_xnu_kernelcache.c"], "buggy_code_start_loc": [991], "buggy_code_end_loc": [992], "fixing_code_start_loc": [991], "fixing_code_end_loc": [992], "type": "CWE-787", "message": "radare2 5.8.9 has an out-of-bounds read in r_bin_object_set_items in libr/bin/bobj.c, causing a crash in r_read_le32 in libr/include/r_endian.h.", "other": {"cve": {"id": "CVE-2023-47016", "sourceIdentifier": "cve@mitre.org", "published": "2023-11-22T07:15:07.530", "lastModified": "2023-11-29T18:03:48.853", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "radare2 5.8.9 has an out-of-bounds read in r_bin_object_set_items in libr/bin/bobj.c, causing a crash in r_read_le32 in libr/include/r_endian.h."}, {"lang": "es", "value": "radare2 5.8.9 tiene una lectura fuera de los l\u00edmites en r_bin_object_set_items en libr/bin/bobj.c, lo que provoca un bloqueo en r_read_le32 en libr/include/r_endian.h."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.9.0", "matchCriteriaId": "0E042C08-7911-4974-A2A6-95F0EFD10809"}]}]}], "references": [{"url": "https://gist.github.com/gandalf4a/65705be4f84269cb7cd725a1d4ab2ffa", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/radareorg/radare2/commit/40c9f50e127be80b9d816bce2ab2ee790831aefd", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/radareorg/radare2/issues/22349", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/40c9f50e127be80b9d816bce2ab2ee790831aefd"}}