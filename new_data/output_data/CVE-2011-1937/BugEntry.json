{"buggy_code": ["=head1 user-lib.pl\n\nFunctions for Unix user and group management.\n\n foreign_require(\"useradmin\", \"user-lib.pl\");\n @users = useradmin::list_users();\n @groups = useradmin::list_groups();\n ($joe) = grep { $_->{'user'} eq 'joe' } @users;\n if ($joe) {\n   $joe->{'pass'} = useradmin::encrypt_password('smeg');\n   useradmin::making_changes()\n   useradmin::modify_user($joe, $joe);\n   useradmin::made_changes()\n }\n\n=cut\n\nBEGIN { push(@INC, \"..\"); };\nuse WebminCore;\n&init_config();\nif ($gconfig{'os_type'} =~ /-linux$/) {\n\tdo \"linux-lib.pl\";\n\t}\nelse {\n\tdo \"$gconfig{'os_type'}-lib.pl\";\n\t}\ndo \"md5-lib.pl\";\n%access = &get_module_acl();\n\n@random_password_chars = ( 'a' .. 'z', 'A' .. 'Z', '0' .. '9' );\n$disable_string = $config{'lock_prepend'} eq \"\" ? \"!\" : $config{'lock_prepend'};\n\n# Search types\n$match_modes = [ [ 0, $text{'index_equals'} ], [ 4, $text{'index_contains'} ],\n\t\t [ 1, $text{'index_matches'} ], [ 2, $text{'index_nequals'} ],\n\t\t [ 5, $text{'index_ncontains'} ], [ 3, $text{'index_nmatches'}],\n\t\t [ 6, $text{'index_lower'} ], [ 7, $text{'index_higher'} ] ];\n\n=head2 password_file(file)\n\nReturns true if some file looks like a valid Unix password file\n\n=cut\nsub password_file\n{\nif (!$_[0]) { return 0; }\nelsif (&open_readfile(SHTEST, $_[0])) {\n\tlocal($line);\n\t$line = <SHTEST>;\n\tclose(SHTEST);\n\treturn $line =~ /^\\S+:\\S*:/;\n\t}\nelse { return 0; }\n}\n\n=head2 list_users\n\nReturns an array of hash references, each containing info about one user. Each\nhash will always contain the keys :\n\n=item user - The Unix username.\n\n=item pass - Encrypted password, perhaps using MD5 or DES.\n\n=item uid - User's ID.\n\n=item gid - User's primary group's ID.\n\n=item real - Real name for the user. May also contain office phone, home phone and office location, comma-separated.\n\n=item home - User's home directory.\n\n=item shell - Shell command to run when the user logs in.\n\nIn addition, if the system supports shadow passwords it may also have the keys :\n\n=item change - Days since 1970 the password was last changed.\n\n=item min - Days before password may be changed.\n\n=item max - Days after which password must be changed.\n\n=item warn - Days before password is to expire that user is warned.\n\n=item inactive - Days after password expires that account is disabled.\n\n=item expire - Days since Jan 1, 1970 that account is disabled.\n\nOr if it supports FreeBSD master.passwd info, it will also have keys :\n\n=item class - User's login class.\n\n=item change - Unix time at which the password was last changed.\n\n=item expire - Unix time at which the password will expire.\n\n=cut\nsub list_users\n{\nreturn @list_users_cache if (scalar(@list_users_cache));\n\n# read the password file\nlocal (@rv, $_, %idx, $lnum, @pw, $p, $i, $j);\nlocal $pft = &passfiles_type();\nif ($pft == 1) {\n\t# read the master.passwd file only\n\t$lnum = 0;\n\t&open_readfile(PASSWD, $config{'master_file'});\n\twhile(<PASSWD>) {\n\t\ts/\\r|\\n//g;\n\t\tif (/\\S/ && !/^[#\\+\\-]/) {\n\t\t\t@pw = split(/:/, $_, -1);\n\t\t\tpush(@rv, { 'user' => $pw[0],\t'pass' => $pw[1],\n\t\t\t\t    'uid' => $pw[2],\t'gid' => $pw[3],\n\t\t\t\t    'class' => $pw[4],\t'change' => $pw[5],\n\t\t\t\t    'expire' => $pw[6],\t'real' => $pw[7],\n\t\t\t\t    'home' => $pw[8],\t'shell' => $pw[9],\n\t\t\t\t    'line' => $lnum,\t'num' => scalar(@rv) });\n\t\t\t}\n\t\t$lnum++;\n\t\t}\n\tclose(PASSWD);\n\t}\nelsif ($pft == 6) {\n\t# Read netinfo dump\n\t&open_execute_command(PASSWD, \"nidump passwd '$netinfo_domain'\", 1);\n\twhile(<PASSWD>) {\n\t\ts/\\r|\\n//g;\n\t\tif (/\\S/ && !/^[#\\+\\-]/) {\n\t\t\t@pw = split(/:/, $_, -1);\n\t\t\tpush(@rv, { 'user' => $pw[0],\t'pass' => $pw[1],\n\t\t\t\t    'uid' => $pw[2],\t'gid' => $pw[3],\n\t\t\t\t    'class' => $pw[4],\t'change' => $pw[5],\n\t\t\t\t    'expire' => $pw[6],\t'real' => $pw[7],\n\t\t\t\t    'home' => $pw[8],\t'shell' => $pw[9],\n\t\t\t\t    'num' => scalar(@rv) });\n\t\t\t}\n\t\t}\n\tclose(PASSWD);\n\t}\nelsif ($pft == 7) {\n\t# Read directory services dump of users\n\t&open_execute_command(PASSWD,\n\t\t\"dscl '$netinfo_domain' readall /Users\", 1);\n\tlocal $user;\n\tlocal $ls = $config{'lock_string'};\n\twhile(<PASSWD>) {\n\t\ts/\\r|\\n//g;\n\t\tif ($_ eq \"-\") {\n\t\t\t# End of the current user\n\t\t\t$user = undef;\n\t\t\t}\n\t\telsif (/^(\\S+):\\s*(.*)$/) {\n\t\t\t# Value for a user\n\t\t\tif (!$user) {\n\t\t\t\t$user = { 'num' => scalar(@rv) };\n\t\t\t\tpush(@rv, $user);\n\t\t\t\t}\n\t\t\tlocal ($n, $v) = ($1, $2);\n\t\t\tif ($n ne 'RealName' && $v eq '') {\n\t\t\t\t# Multi-line value\n\t\t\t\t$v = <PASSWD>;\n\t\t\t\t$v =~ s/^ //;\n\t\t\t\t}\n\t\t\tlocal $p = $user_properties_map{$n};\n\t\t\tif ($p) {\n\t\t\t\t# Some OSX users have two names, like _foo foo\n\t\t\t\t$v =~ s/\\s.*$// if ($p eq 'user');\n\t\t\t\t$user->{$p} = $v;\n\t\t\t\t}\n\t\t\telsif ($n eq \"GeneratedUID\") {\n\t\t\t\t# Given the UID, we can get the password hash\n\t\t\t\t$user->{'pass'} = &get_macos_password_hash($v);\n\t\t\t\t$user->{'uuid'} = $v;\n\t\t\t\tif (substr($user->{'pass'}, 0,\n\t\t\t\t\t   length($ls)) eq $ls) {\n\t\t\t\t\t# Account locked\n\t\t\t\t\t$user->{'pass'} = $ls;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tclose(PASSWD);\n\t}\nelse {\n\t# start by reading /etc/passwd\n\t$lnum = 0;\n\t&open_readfile(PASSWD, $config{'passwd_file'});\n\twhile(<PASSWD>) {\n\t\ts/\\r|\\n//g;\n\t\tif (/\\S/ && !/^[#\\+\\-]/) {\n\t\t\t@pw = split(/:/, $_, -1);\n\t\t\tpush(@rv, { 'user' => $pw[0],\t'pass' => $pw[1],\n\t\t\t\t    'uid' => $pw[2],\t'gid' => $pw[3],\n\t\t\t\t    'real' => $pw[4],\t'home' => $pw[5],\n\t\t\t\t    'shell' => $pw[6],\t'line' => $lnum,\n\t\t\t\t    'num' => scalar(@rv) });\n\t\t\t$idx{$pw[0]} = $rv[$#rv];\n\t\t\t}\n\t\t$lnum++;\n\t\t}\n\tclose(PASSWD);\n\tif ($pft == 2 || $pft == 5) {\n\t\t# read the shadow file data\n\t\t$lnum = 0;\n\t\t&open_readfile(SHADOW, $config{'shadow_file'});\n\t\twhile(<SHADOW>) {\n\t\t\ts/\\r|\\n//g;\n\t\t\tif (/\\S/ && !/^[#\\+\\-]/) {\n\t\t\t\t@pw = split(/:/, $_, -1);\n\t\t\t\t$p = $idx{$pw[0]};\n\t\t\t\t$p->{'pass'} = $pw[1];\n\t\t\t\t$p->{'change'} = $pw[2] < 0 ? \"\" : $pw[2];\n\t\t\t\t$p->{'min'} = $pw[3] < 0 ? \"\" : $pw[3];\n\t\t\t\t$p->{'max'} = $pw[4] < 0 ? \"\" : $pw[4];\n\t\t\t\t$p->{'warn'} = $pw[5] < 0 ? \"\" : $pw[5];\n\t\t\t\t$p->{'inactive'} = $pw[6] < 0 ? \"\" : $pw[6];\n\t\t\t\t$p->{'expire'} = $pw[7] < 0 ? \"\" : $pw[7];\n\t\t\t\t$p->{'sline'} = $lnum;\n\t\t\t\t}\n\t\t\t$lnum++;\n\t\t\t}\n\t\tclose(SHADOW);\n\t\tfor($i=0; $i<@rv; $i++) {\n\t\t\tif (!defined($rv[$i]->{'sline'})) {\n\t\t\t\t# not in shadow!\n\t\t\t\tfor($j=$i; $j<@rv; $j++) { $rv[$j]->{'num'}--; }\n\t\t\t\tsplice(@rv, $i--, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telsif ($pft == 4) {\n\t\t# read the AIX security passwd file\n\t\tlocal $lastuser;\n\t\tlocal $lnum = 0;\n\t\t&open_readfile(SECURITY, $config{'shadow_file'});\n\t\twhile(<SECURITY>) {\n\t\t\ts/\\s*$//;\n\t\t\tif (/^\\s*(\\S+):/) {\n\t\t\t\t$lastuser = $idx{$1};\n\t\t\t\t$lastuser->{'sline'} = $lnum;\n\t\t\t\t}\n\t\t\telsif (/^\\s*([^=\\s]+)\\s*=\\s*(.*)/) {\n\t\t\t\tif ($1 eq 'password') {\n\t\t\t\t\t$lastuser->{'pass'} = $2;\n\t\t\t\t\t}\n\t\t\t\telsif ($1 eq 'lastupdate') {\n\t\t\t\t\t$lastuser->{'change'} = $2;\n\t\t\t\t\t}\n\t\t\t\telsif ($1 eq 'flags') {\n\t\t\t\t\tmap { $lastuser->{lc($_)}++ }\n\t\t\t\t\t    split(/[,\\s]+/, $2);\n\t\t\t\t\t}\n\t\t\t\t$lastuser->{'seline'} = $lnum;\n\t\t\t\t}\n\t\t\t$lnum++;\n\t\t\t}\n\t\tclose(SECURITY);\n\n\t\t# read the AIX security user file\n\t\t&open_readfile(USER, $config{'aix_user_file'});\n\t\twhile(<USER>) {\n\t\t\ts/\\s*$//;\n\t\t\tif (/^\\s*(\\S+):/) {\n\t\t\t\t$lastuser = $idx{$1};\n\t\t\t\t}\n\t\t\telsif (/^\\s*([^=\\s]+)\\s*=\\s*(.*)/) {\n\t\t\t\tif ($1 eq 'expires') {\n\t\t\t\t\t$lastuser->{'expire'} = $2;\n\t\t\t\t\t}\n\t\t\t\telsif ($1 eq 'minage') {\n\t\t\t\t\t$lastuser->{'min'} = $2;\n\t\t\t\t\t}\n\t\t\t\telsif ($1 eq 'maxage') {\n\t\t\t\t\t$lastuser->{'max'} = $2;\n\t\t\t\t\t}\n\t\t\t\telsif ($1 eq 'pwdwarntime') {\n\t\t\t\t\t$lastuser->{'warn'} = $2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tclose(USER);\n\t\t}\n\t}\n@list_users_cache = @rv;\nreturn @rv;\n}\n\n=head2 create_user(&details)\n\nCreates a new user with the given details, supplied in a hash ref. This must\nbe in the same format as returned by list_users, and must contain at a minimum\nthe user, uid, gid, pass, shell, home and real keys.\n\n=cut\nsub create_user\n{\nlocal $lref;\nlocal $pft = &passfiles_type();\nif ($pft == 1) {\n\t# just need to add to master.passwd\n\t$lref = &read_file_lines($config{'master_file'});\n\t$_[0]->{'line'} = &nis_index($lref);\n\tsplice(@$lref, $_[0]->{'line'}, 0,\n\t       \"$_[0]->{'user'}:$_[0]->{'pass'}:$_[0]->{'uid'}:\".\n\t       \"$_[0]->{'gid'}:$_[0]->{'class'}:$_[0]->{'change'}:\".\n\t       \"$_[0]->{'expire'}:$_[0]->{'real'}:$_[0]->{'home'}:\".\n\t       \"$_[0]->{'shell'}\");\n\tif (scalar(@list_users_cache)) {\n\t\tmap { $_->{'line'}++ if ($_->{'line'} >= $_[0]->{'line'}) }\n\t\t    @list_users_cache;\n\t\t}\n\t}\nelsif ($pft == 3) {\n\t# Just invoke the useradd command\n\t&system_logged(\"useradd -u $_[0]->{'uid'} -g $_[0]->{'gid'} -c \\\"$_[0]->{'real'}\\\" -d $_[0]->{'home'} -s $_[0]->{'shell'} $_[0]->{'user'}\");\n\t# And set the password\n\t&system_logged(\"echo \".quotemeta($_[0]->{'pass'}).\n\t\t       \" | /usr/lib/scoadmin/account/password.tcl \".\n\t\t       \"$_[0]->{'user'} >/dev/null 2>&1\");\n\t}\nelsif ($pft == 6) {\n\t# Use the niutil command\n\t&system_logged(\"niutil -create '$netinfo_domain' '/users/$_[0]->{'user'}'\");\n\t&set_netinfo($_[0]);\n\t}\nelsif ($pft == 7) {\n\t# Add to directory services\n\t&execute_dscl_command(\"create\", \"/Users/$_[0]->{'user'}\");\n\tlocal $out = &execute_dscl_command(\"read\", \"/Users/$_[0]->{'user'}\");\n\tif ($out =~ /GeneratedUID:\\s+(\\S+)/) {\n\t\t$_[0]->{'uuid'} = $1;\n\t\t}\n\t&set_user_dirinfo($_[0]);\n\t}\nelse {\n\t# add to /etc/passwd\n\t$lref = &read_file_lines($config{'passwd_file'});\n\t$_[0]->{'line'} = &nis_index($lref);\n\tif (scalar(@list_users_cache)) {\n\t\tmap { $_->{'line'}++ if ($_->{'line'} >= $_[0]->{'line'}) }\n\t\t    @list_users_cache;\n\t\t}\n\tsplice(@$lref, $_[0]->{'line'}, 0,\n\t       \"$_[0]->{'user'}:\".\n\t       ($pft == 2 || $pft == 5 ? \"x\" : $pft == 4 ? \"!\" :\n\t\t\t$_[0]->{'pass'}).\n\t       \":$_[0]->{'uid'}:$_[0]->{'gid'}:$_[0]->{'real'}:\".\n\t       \"$_[0]->{'home'}:$_[0]->{'shell'}\");\n\tif ($pft == 2 || $pft == 5) {\n\t\t# Find correct place to insert in shadow file\n\t\t$lref = &read_file_lines($config{'shadow_file'});\n\t\t$_[0]->{'sline'} = &nis_index($lref);\n\t\tif (scalar(@list_users_cache)) {\n\t\t\tmap { $_->{'sline'}++\n\t\t\t      if ($_->{'sline'} >= $_[0]->{'sline'}) }\n\t\t\t    @list_users_cache;\n\t\t\t}\n\t\t}\n\tif ($pft == 2) {\n\t\t# add to shadow as well..\n\t\tsplice(@$lref, $_[0]->{'sline'}, 0,\n\t\t       \"$_[0]->{'user'}:$_[0]->{'pass'}:$_[0]->{'change'}:\".\n\t\t       \"$_[0]->{'min'}:$_[0]->{'max'}:$_[0]->{'warn'}:\".\n\t\t       \"$_[0]->{'inactive'}:$_[0]->{'expire'}:\");\n\t\t}\n\telsif ($pft == 5) {\n\t\t# add to SCO shadow file\n\t\tsplice(@$lref, $_[0]->{'sline'}, 0,\n\t       \t    \"$_[0]->{'user'}:$_[0]->{'pass'}:$_[0]->{'change'}:\".\n\t\t    \"$_[0]->{'min'}:$_[0]->{'max'}\");\n\t\t}\n\telsif ($pft == 4) {\n\t\t# add to AIX security passwd file as well..\n\t\tlocal @flags;\n\t\tpush(@flags, 'ADMIN') if ($_[0]->{'admin'});\n\t\tpush(@flags, 'ADMCHG') if ($_[0]->{'admchg'});\n\t\tpush(@flags, 'NOCHECK') if ($_[0]->{'nocheck'});\n\t\t$lref = &read_file_lines($config{'shadow_file'});\n\t\tpush(@$lref, \"\", \"$_[0]->{'user'}:\",\n\t\t\t     \"\\tpassword = $_[0]->{'pass'}\",\n\t\t\t     \"\\tlastupdate = $_[0]->{'change'}\",\n\t\t\t     \"\\tflags = \".join(\",\", @flags));\n\t\t\n\t\t# add to AIX security user file as well..\n\t\t$lref = &read_file_lines($config{'aix_user_file'});\n\t\tif ($_[0]->{'expire'} || $_[0]->{'min'} ||\n\t\t    $_[0]->{'max'} || $_[0]->{'warn'} ) {\n\t\t\tpush(@$lref, \"$_[0]->{'user'}:\");\n\t\t\tpush(@$lref, \"\\texpires = $_[0]->{'expire'}\")\n\t\t\t\tif ($_[0]->{'expire'});\n\t\t\tpush(@$lref, \"\\tminage = $_[0]->{'min'}\")\n\t\t\t\tif ($_[0]->{'min'});\n\t\t\tpush(@$lref, \"\\tmaxage = $_[0]->{'max'}\")\n\t\t\t\tif ($_[0]->{'max'});\n\t\t\tpush(@$lref, \"\\tpwdwarntime = $_[0]->{'warn'}\")\n\t\t\t\tif ($_[0]->{'warn'});\n\t\t\tpush(@$lref, \"\");\n\t\t\t}\n\t\t}\n\t}\n&flush_file_lines() if (!$batch_mode);\npush(@list_users_cache, $_[0]) if (scalar(@list_users_cache));\n&refresh_nscd() if (!$batch_mode);\n}\n\n=head2 modify_user(&old, &details)\n\nUpdate an existing Unix user with new details. The user to change must be\nin &old, and the new values are in &details. These can be references to the\nsame hash if you like.\n\n=cut\nsub modify_user\n{\n$_[0] || &error(\"Missing parameter to modify_user\");\nlocal(@passwd, @shadow, $lref);\nlocal $pft = &passfiles_type();\nif ($pft == 1) {\n\t# just need to update master.passwd\n\t$_[0]->{'line'} =~ /^\\d+$/ || &error(\"Missing user line to modify\");\n\t$lref = &read_file_lines($config{'master_file'});\n\t$lref->[$_[0]->{'line'}] = \n\t      \"$_[1]->{'user'}:$_[1]->{'pass'}:$_[1]->{'uid'}:\".\n\t      \"$_[1]->{'gid'}:$_[1]->{'class'}:$_[1]->{'change'}:\".\n\t      \"$_[1]->{'expire'}:$_[1]->{'real'}:$_[1]->{'home'}:\".\n\t      \"$_[1]->{'shell'}\";\n\t}\nelsif ($pft == 3) {\n\t# Just use the usermod command\n\t&system_logged(\"usermod -u $_[1]->{'uid'} -g $_[1]->{'gid'} -c \\\"$_[1]->{'real'}\\\" -d $_[1]->{'home'} -s $_[1]->{'shell'} $_[1]->{'user'}\");\n\t&system_logged(\"echo \".quotemeta($_[1]->{'pass'}).\" | /usr/lib/scoadmin/account/password.tcl $_[1]->{'user'}\");\n\t}\nelsif ($pft == 6) {\n\t# Just use the niutil command to update\n\tif ($_[0]->{'user'} && $_[0]->{'user'} ne $_[1]->{'user'}) {\n\t\t# Need to delete and re-create!\n\t\t&system_logged(\"niutil -destroy '$netinfo_domain' '/users/$_[0]->{'user'}'\");\n\t\t&system_logged(\"niutil -create '$netinfo_domain' '/users/$_[1]->{'user'}'\");\n\t\t}\n\t&set_netinfo($_[1]);\n\t}\nelsif ($pft == 7) {\n\t# Call directory services to update the user\n\tif ($_[0]->{'user'} && $_[0]->{'user'} ne $_[1]->{'user'}) {\n\t\t# Need to rename\n\t\t&execute_dscl_command(\"change\", \"/Users/$_[0]->{'user'}\",\n\t\t\t      \"RecordName\", $_[0]->{'user'}, $_[1]->{'user'});\n\t\t}\n\t$_[1]->{'uuid'} = $_[0]->{'uuid'};\n\t&set_user_dirinfo($_[1]);\n\t}\nelse {\n\t# update /etc/passwd\n\t$lref = &read_file_lines($config{'passwd_file'});\n\t$_[0]->{'line'} =~ /^\\d+$/ || &error(\"Missing user line to modify\");\n\t$lref->[$_[0]->{'line'}] =\n\t\t\"$_[1]->{'user'}:\".\n\t\t($pft == 2 || $pft == 5 ? \"x\" : $pft == 4 ? \"!\" :\n\t\t $_[1]->{'pass'}).\n\t\t\":$_[1]->{'uid'}:$_[1]->{'gid'}:$_[1]->{'real'}:\".\n\t\t\"$_[1]->{'home'}:$_[1]->{'shell'}\";\n\tif ($pft == 2) {\n\t\t# update shadow file as well..\n\t\t$_[0]->{'sline'} =~ /^\\d+$/ ||\n\t\t\t&error(\"Missing user line to modify\");\n\t\t$lref = &read_file_lines($config{'shadow_file'});\n\t\t$lref->[$_[0]->{'sline'}] =\n\t\t\t\"$_[1]->{'user'}:$_[1]->{'pass'}:$_[1]->{'change'}:\".\n\t\t\t\"$_[1]->{'min'}:$_[1]->{'max'}:$_[1]->{'warn'}:\".\n\t\t\t\"$_[1]->{'inactive'}:$_[1]->{'expire'}:\";\n\t\t}\n\telsif ($pft == 5) {\n\t\t# update SCO shadow\n\t\t$_[0]->{'sline'} =~ /^\\d+$/ ||\n\t\t\t&error(\"Missing user line to modify\");\n\t\t$lref = &read_file_lines($config{'shadow_file'});\n\t\t$lref->[$_[0]->{'sline'}] =\n\t\t   \"$_[1]->{'user'}:$_[1]->{'pass'}:$_[1]->{'change'}:\".\n\t\t   \"$_[1]->{'min'}:$_[1]->{'max'}\";\n\t\t}\n\telsif ($pft == 4) {\n\t\t# update AIX shadow passwd file as well..\n\t\tif (defined($_[0]->{'sline'})) {\n\t\t\tlocal @flags;\n\t\t\tpush(@flags, 'ADMIN') if ($_[1]->{'admin'});\n\t\t\tpush(@flags, 'ADMCHG') if ($_[1]->{'admchg'});\n\t\t\tpush(@flags, 'NOCHECK') if ($_[1]->{'nocheck'});\n\t\t\tlocal $lref = &read_file_lines($config{'shadow_file'});\n\t\t\tsplice(@$lref, $_[0]->{'sline'},\n\t\t\t     $_[0]->{'seline'} - $_[0]->{'sline'} + 1,\n\t\t\t     \"$_[1]->{'user'}:\", \"\\tpassword = $_[1]->{'pass'}\",\n\t\t\t     \"\\tlastupdate = $_[1]->{'change'}\",\n\t\t\t     \"\\tflags = \".join(\",\", @flags));\n\t\t\t&flush_file_lines();\t# have to flush on AIX\n\t\t\t}\n\n\t\t# update AIX security user file as well..\n\t\t# use chuser command because it's easier than working\n\t\t# with the complexity issues of the file.\n\t\t&system_logged(\"chuser expires=$_[1]->{'expire'} minage=$_[1]->{'min'} maxage=$_[1]->{'max'} pwdwarntime=$_[1]->{'warn'} $_[1]->{'user'}\");\n\t\t}\n\t}\nif ($_[0] ne $_[1] && &indexof($_[0], @list_users_cache) != -1) {\n\t# Update old object in cache\n\t$_[1]->{'line'} = $_[0]->{'line'} if (defined($_[0]->{'line'}));\n\t$_[1]->{'uuid'} = $_[0]->{'uuid'} if (defined($_[0]->{'uuid'}));\n\t$_[1]->{'sline'} = $_[0]->{'sline'} if (defined($_[0]->{'sline'}));\n\t$_[1]->{'seline'} = $_[0]->{'seline'} if (defined($_[0]->{'seline'}));\n\t%{$_[0]} = %{$_[1]};\n\t}\nif (!$batch_mode) {\n\t&flush_file_lines();\n\t&refresh_nscd();\n\t}\n}\n\n=head2 delete_user(&details)\n\nDelete an existing user. The &details hash must be user information as\nreturned by list_users.\n\n=cut\nsub delete_user\n{\nlocal $lref;\n$_[0] || &error(\"Missing parameter to delete_user\");\nlocal $pft = &passfiles_type();\nif ($pft == 1) {\n\t# Delete from BSD master.passwd file\n\t$_[0]->{'line'} =~ /^\\d+$/ || &error(\"Missing user line to delete\");\n\t$lref = &read_file_lines($config{'master_file'});\n\tsplice(@$lref, $_[0]->{'line'}, 1);\n\tmap { $_->{'line'}-- if ($_->{'line'} > $_[0]->{'line'}) }\n\t    @list_users_cache;\n\t}\nelsif ($pft == 3) {\n\t# Just invoke the userdel command\n\t&system_logged(\"userdel -n0 $_[0]->{'user'}\");\n\t}\nelsif ($pft == 4) {\n\t# Just invoke the rmuser command\n\t&system_logged(\"rmuser -p $_[0]->{'user'}\");\n\t}\nelsif ($pft == 6) {\n\t# Just delete with the niutil command\n\t&system_logged(\"niutil -destroy '$netinfo_domain' '/users/$_[0]->{'user'}'\");\n\t}\nelsif ($pft == 7) {\n\t# Delete from directory services\n\t&execute_dscl_command(\"delete\", \"/Users/$_[0]->{'user'}\");\n\t}\nelse {\n\t# XXX doesn't delete from AIX file!\n\t$_[0]->{'line'} =~ /^\\d+$/ || &error(\"Missing user line to delete\");\n\t$lref = &read_file_lines($config{'passwd_file'});\n\tsplice(@$lref, $_[0]->{'line'}, 1);\n\tmap { $_->{'line'}-- if ($_->{'line'} > $_[0]->{'line'}) }\n\t    @list_users_cache;\n\tif ($pft == 2 || $pft == 5) {\n\t\tif (defined($_[0]->{'sline'})) {\n\t\t\t$lref = &read_file_lines($config{'shadow_file'});\n\t\t\tsplice(@$lref, $_[0]->{'sline'}, 1);\n\t\t\tmap { $_->{'sline'}--\n\t\t\t\tif ($_->{'sline'} > $_[0]->{'sline'}) }\n\t\t\t    @list_users_cache;\n\t\t\t}\n\t\t}\n\t}\n@list_users_cache = grep { $_->{'user'} ne $_[0]->{'user'} } @list_users_cache\n\tif (scalar(@list_users_cache));\nif (!$batch_mode) {\n\t&flush_file_lines();\n\t&refresh_nscd();\n\t}\n}\n\n=head2 list_groups\n\nReturns a list of all the local groups as an array of hashes. Each will\ncontain the keys :\n\n=item group - The group name.\n\n=item pass - Rarely-used encrypted password, in DES or MD5 format.\n\n=item gid - Unix ID for the group.\n\n=item members - A comma-separated list of secondary group members.\n\n=cut\nsub list_groups\n{\nreturn @list_groups_cache if (scalar(@list_groups_cache));\n\nlocal(@rv, $lnum, $_, %idx, $g, $i, $j, @gr);\n$lnum = 0;\nlocal $gft = &groupfiles_type();\nif ($gft == 5) {\n\t# Get groups from netinfo\n\t&open_execute_command(GROUP, \"nidump group '$netinfo_domain'\", 1);\n\twhile(<GROUP>) {\n\t\ts/\\r|\\n//g;\n\t\tif (/\\S/ && !/^[#\\+\\-]/) {\n\t\t\t@gr = split(/:/, $_, -1);\n\t\t\tpush(@rv, { 'group' => $gr[0],\t'pass' => $gr[1],\n\t\t\t\t    'gid' => $gr[2],\n\t\t\t\t    'members' => join(\",\",split(/\\s+/,$gr[3])),\n\t\t\t\t    'num' => scalar(@rv) });\n\t\t\t}\n\t\t}\n\tclose(GROUP);\n\t}\nelsif ($gft == 7) {\n\t# Read directory services dump of groups\n\t&open_execute_command(PASSWD,\n\t\t\"dscl '$netinfo_domain' readall /Groups\", 1);\n\tlocal $group;\n\twhile(<PASSWD>) {\n\t\ts/\\r|\\n//g;\n\t\tif ($_ eq \"-\") {\n\t\t\t# End of the current group\n\t\t\t$group = undef;\n\t\t\t}\n\t\telsif (/^(\\S+):\\s*(.*)$/) {\n\t\t\t# Value for a group\n\t\t\tif (!$group) {\n\t\t\t\t$group = { 'num' => scalar(@rv) };\n\t\t\t\tpush(@rv, $group);\n\t\t\t\t}\n\t\t\tlocal ($n, $v) = ($1, $2);\n\t\t\tif ($n ne 'GroupMembership' && $v eq '') {\n\t\t\t\t# Multi-line value\n\t\t\t\t$v = <PASSWD>;\n\t\t\t\t$v =~ s/^ //;\n\t\t\t\t}\n\t\t\tlocal $p = $group_properties_map{$n};\n\t\t\tif ($p) {\n\t\t\t\t# Convert spaces in members list to ,\n\t\t\t\t$v =~ s/ /,/g if ($p eq 'members');\n\t\t\t\t# Some OSX groups have two names, like _foo foo\n\t\t\t\t$v =~ s/\\s.*$// if ($p eq 'group');\n\t\t\t\t$group->{$p} = $v;\n\t\t\t\t}\n\t\t\telsif ($n eq \"GeneratedUID\") {\n\t\t\t\t# Given the UUID, we can get the password hash\n\t\t\t\t$group->{'pass'} = &get_macos_password_hash($v);\n\t\t\t\t$group->{'uuid'} = $v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tclose(PASSWD);\n\t}\nelse {\n\t# Read the standard group file\n\t&open_readfile(GROUP, $config{'group_file'});\n\twhile(<GROUP>) {\n\t\ts/\\r|\\n//g;\n\t\tif (/\\S/ && !/^[#\\+\\-]/) {\n\t\t\t@gr = split(/:/, $_, -1);\n\t\t\tpush(@rv, { 'group' => $gr[0],\t'pass' => $gr[1],\n\t\t\t\t    'gid' => $gr[2],\t'members' => $gr[3],\n\t\t\t\t    'line' => $lnum,\t'num' => scalar(@rv) });\n\t\t\t$idx{$gr[0]} = $rv[$#rv];\n\t\t\t}\n\t\t$lnum++;\n\t\t}\n\tclose(GROUP);\n\t}\nif ($gft == 2) {\n\t# read the gshadow file data\n\t$lnum = 0;\n\t&open_readfile(SHADOW, $config{'gshadow_file'});\n\twhile(<SHADOW>) {\n\t\ts/\\r|\\n//g;\n\t\tif (/\\S/ && !/^[#\\+\\-]/) {\n\t\t\t@gr = split(/:/, $_, -1);\n\t\t\t$g = $idx{$gr[0]};\n\t\t\t$g->{'pass'} = $gr[1];\n\t\t\t$g->{'sline'} = $lnum;\n\t\t\t}\n\t\t$lnum++;\n\t\t}\n\tclose(SHADOW);\n\t#for($i=0; $i<@rv; $i++) {\n\t#\tif (!defined($rv[$i]->{'sline'})) {\n\t#\t\t# not in shadow!\n\t#\t\tfor($j=$i; $j<@rv; $j++) { $rv[$j]->{'num'}--; }\n\t#\t\tsplice(@rv, $i--, 1);\n\t#\t\t}\n\t#\t}\n\t}\nelsif ($gft == 4) {\n\t# read the AIX group data\n\tlocal $lastgroup;\n\tlocal $lnum = 0;\n\t&open_readfile(SECURITY, $config{'gshadow_file'});\n\twhile(<SECURITY>) {\n\t\ts/\\s*$//;\n\t\tif (/^\\s*(\\S+):/) {\n\t\t\t$lastgroup = $idx{$1};\n\t\t\t$lastgroup->{'sline'} = $lnum;\n\t\t\t$lastgroup->{'seline'} = $lnum;\n\t\t\t}\n\t\telsif (/^\\s*([^=\\s]+)\\s*=\\s*(.*)/) {\n\t\t\t$lastgroup->{'seline'} = $lnum;\n\t\t\t}\n\t\t$lnum++;\n\t\t}\n\tclose(SECURITY);\n\t}\n@list_groups_cache = @rv;\nreturn @rv;\n}\n\n=head2 create_group(&details)\n\nCreate a new Unix group based on the given hash. Required keys are\ngid - Unix group ID\ngroup - Group name\npass - Encrypted password\nmembers - Comma-separated list of members\n\n=cut\nsub create_group\n{\nlocal $gft = &groupfiles_type();\nif ($gft == 5) {\n\t# Use niutil command\n\t&system_logged(\"niutil -create '$netinfo_domain' '/groups/$_[0]->{'group'}'\");\n\t&set_group_netinfo($_[0]);\n\t}\nelsif ($gft == 7) {\n\t# Use the dscl directory services command\n\t&execute_dscl_command(\"create\", \"/Groups/$_[0]->{'group'}\");\n\t&set_group_dirinfo($_[0]);\n\t}\nelse {\n\t# Update group file(s)\n\tlocal $lref;\n\t$lref = &read_file_lines($config{'group_file'});\n\t$_[0]->{'line'} = &nis_index($lref);\n\tif (scalar(@list_groups_cache)) {\n\t\tmap { $_->{'line'}++ if ($_->{'line'} >= $_[0]->{'line'}) }\n\t\t    @list_groups_cache;\n\t\t}\n\tsplice(@$lref, $_[0]->{'line'}, 0,\n\t       \"$_[0]->{'group'}:\".\n\t       (&groupfiles_type() == 2 ? \"x\" : $_[0]->{'pass'}).\n\t       \":$_[0]->{'gid'}:$_[0]->{'members'}\");\n\tif ($gft == 2) {\n\t\t$lref = &read_file_lines($config{'gshadow_file'});\n\t\t$_[0]->{'sline'} = &nis_index($lref);\n\t\tif (scalar(@list_groups_cache)) {\n\t\t\tmap { $_->{'sline'}++\n\t\t\t      if ($_->{'sline'} >= $_[0]->{'sline'}) }\n\t\t\t    @list_groups_cache;\n\t\t\t}\n\t\tsplice(@$lref, $_[0]->{'sline'}, 0,\n\t\t       \"$_[0]->{'group'}:$_[0]->{'pass'}::$_[0]->{'members'}\");\n\t\t}\n\telsif ($gft == 4) {\n\t\t$lref = &read_file_lines($config{'gshadow_file'});\n\t\t$_[0]->{'sline'} = scalar(@$lref);\n\t\tpush(@$lref, \"\", \"$_[0]->{'group'}:\", \"\\tadmin = false\");\n\t\t}\n\t&flush_file_lines();\n\t}\n&refresh_nscd();\npush(@list_groups_cache, $_[0]) if (scalar(@list_groups_cache));\n}\n\n=head2 modify_group(&old, &details)\n\nUpdate an existing Unix group specified in old based on the given details hash. \nThese can both be references to the same hash if you like. The hash must be\nin the same format as returned by list_groups.\n\n=cut\nsub modify_group\n{\n$_[0] || &error(\"Missing parameter to modify_group\");\nlocal $gft = &groupfiles_type();\nif ($gft == 5) {\n\t# Call niutil to update the group\n\tif ($_[0]->{'group'} && $_[0]->{'group'} ne $_[1]->{'group'}) {\n\t\t# Need to delete and re-create!\n\t\t&system_logged(\"niutil -destroy '$netinfo_domain' '/groups/$_[0]->{'group'}'\");\n\t\t&system_logged(\"niutil -create '$netinfo_domain' '/groups/$_[1]->{'group'}'\");\n\t\t}\n\t&set_group_netinfo($_[1]);\n\t}\nelsif ($gft == 7) {\n\t# Call dscl to update the group\n\tif ($_[0]->{'group'} && $_[0]->{'group'} ne $_[1]->{'group'}) {\n\t\t# Need to rename\n\t\t&execute_dscl_command(\"change\", \"/Groups/$_[0]->{'group'}\",\n\t\t\t      \"RecordName\", $_[0]->{'group'}, $_[1]->{'group'});\n\t\t}\n\t$_[1]->{'uuid'} = $_[0]->{'uuid'};\n\t&set_group_dirinfo($_[1]);\n\t}\nelse {\n\t# Update in files\n\tlocal $gs = (&groupfiles_type() == 2 && $_[0]->{'sline'} ne '');\n\t&replace_file_line($config{'group_file'}, $_[0]->{'line'},\n\t\t   \"$_[1]->{'group'}:\".($gs ? \"x\" : $_[1]->{'pass'}).\n\t\t   \":$_[1]->{'gid'}:$_[1]->{'members'}\\n\");\n\tif ($gs) {\n\t\t&replace_file_line($config{'gshadow_file'}, $_[0]->{'sline'},\n\t\t\t\t   \"$_[1]->{'group'}:$_[1]->{'pass'}::$_[1]->{'members'}\\n\");\n\t\t}\n\telsif (&groupfiles_type() == 4) {\n\t\t&replace_file_line($config{'gshadow_file'},\n\t\t\t\t   $_[0]->{'sline'},\n\t\t\t\t   \"$_[1]->{'group'}:\\n\");\n\t\t}\n\t}\nif ($_[0] ne $_[1] && &indexof($_[0], @list_groups_cache) != -1) {\n\t$_[1]->{'line'} = $_[0]->{'line'} if (defined($_[0]->{'line'}));\n\t$_[1]->{'sline'} = $_[0]->{'sline'} if (defined($_[0]->{'sline'}));\n\t$_[1]->{'uuid'} = $_[0]->{'uuid'} if (defined($_[0]->{'uuid'}));\n\t%{$_[0]} = %{$_[1]};\n\t}\n&refresh_nscd();\n}\n\n=head2 delete_group(&details)\n\nDelete an existing Unix group, whose details are in the hash ref supplied.\n\n=cut\nsub delete_group\n{\n$_[0] || &error(\"Missing parameter to delete_group\");\nlocal $gft = &groupfiles_type();\nif ($gft == 5) {\n\t# Call niutil to delete\n\t&system_logged(\"niutil -destroy '$netinfo_domain' '/groups/$_[0]->{'group'}'\");\n\t}\nelsif ($gft == 7) {\n\t# Delete from directory services\n\t&execute_dscl_command(\"delete\", \"/Groups/$_[0]->{'group'}\");\n\t}\nelse {\n\t# Remove from group file(s)\n\t&replace_file_line($config{'group_file'}, $_[0]->{'line'});\n\tmap { $_->{'line'}-- if ($_->{'line'} > $_[0]->{'line'}) }\n\t    @list_groups_cache;\n\tif ($gft == 2 && $_[0]->{'sline'} ne '') {\n\t\t&replace_file_line($config{'gshadow_file'}, $_[0]->{'sline'});\n\t\tmap { $_->{'sline'}-- if ($_->{'sline'} > $_[0]->{'sline'}) }\n\t\t    @list_groups_cache;\n\t\t}\n\telsif ($gft == 4) {\n\t\tlocal $lref = &read_file_lines($config{'gshadow_file'});\n\t\tsplice(@$lref, $_[0]->{'sline'},\n\t\t       $_[0]->{'seline'} - $_[0]->{'sline'} + 1);\n\t\t&flush_file_lines();\n\t\t}\n\t}\n@list_groups_cache = grep { $_ ne $_[0] } @list_groups_cache\n\tif (scalar(@list_groups_cache));\n&refresh_nscd();\n}\n\n\n=head2 recursive_change(dir, olduid, oldgid, newuid, newgid)\n\nChange the UID or GID of a directory and all files in it, if they match the\ngiven old UID and/or GID. If either of the old IDs are -1, then they are\nignored for match purposes.\n\n=cut\nsub recursive_change\n{\nlocal(@list, $f, @stbuf);\nlocal $real = &translate_filename($_[0]);\n(@stbuf = stat($real)) || return;\n(-l $real) && return;\nif (($_[1] < 0 || $_[1] == $stbuf[4]) &&\n    ($_[2] < 0 || $_[2] == $stbuf[5])) {\n\t# Found match..\n\t&set_ownership_permissions(\n\t\t$_[3] < 0 ? $stbuf[4] : $_[3],\n\t      \t$_[4] < 0 ? $stbuf[5] : $_[4], undef, $_[0]);\n\t}\nif (-d $real) {\n\topendir(DIR, $real);\n\t@list = readdir(DIR);\n\tclosedir(DIR);\n\tforeach $f (@list) {\n\t\tif ($f eq \".\" || $f eq \"..\") { next; }\n\t\t&recursive_change(\"$_[0]/$f\", $_[1], $_[2], $_[3], $_[4]);\n\t\t}\n\t}\n}\n\n=head2 making_changes\n\nMust be called before changes are made to the password or group file.\n\n=cut\nsub making_changes\n{\nif ($config{'pre_command'} =~ /\\S/) {\n\tlocal $out = &backquote_logged(\"($config{'pre_command'}) 2>&1 </dev/null\");\n\treturn $? ? $out : undef;\n\t}\nreturn undef;\n}\n\n=head2 made_changes\n\nMust be called after the password or group file has been changed, to run the\npost-changes command.\n\n=cut\nsub made_changes\n{\nif ($config{'post_command'} =~ /\\S/) {\n\tlocal $out = &backquote_logged(\"($config{'post_command'}) 2>&1 </dev/null\");\n\treturn $? ? $out : undef;\n\t}\nreturn undef;\n}\n\n=head2 other_modules(function, arg, ...)\n\nCall some function in the useradmin_update.pl file in other modules. Should be\ncalled after creating, deleting or modifying a user.\n\n=cut\nsub other_modules\n{\nreturn if (&is_readonly_mode());\t# don't even try other modules\nlocal($m, %minfo);\nlocal $func = shift(@_);\nforeach $m (&get_all_module_infos()) {\n\tlocal $mdir = &module_root_directory($m->{'dir'});\n\tif (&check_os_support($m) &&\n\t    -r \"$mdir/useradmin_update.pl\") {\n\t\t&foreign_require($m->{'dir'}, \"useradmin_update.pl\");\n\t\tlocal $pkg = $m->{'dir'};\n\t\t$pkg =~ s/[^A-Za-z0-9]/_/g;\n\t\tlocal $fullfunc = \"${pkg}::${func}\";\n\t\tif (defined(&$fullfunc)) {\n\t\t\t&foreign_call($m->{'dir'}, $func, @_);\n\t\t\t}\n\t\t}\n\t}\n}\n\n=head2 can_edit_user(&acl, &user)\n\nReturns 1 if the given user hash can be edited by a Webmin user whose access\ncontrol permissions for this module are in the acl parameter.\n\n=cut\nsub can_edit_user\n{\nlocal $m = $_[0]->{'uedit_mode'};\nlocal %u;\nif ($m == 0) { return 1; }\nelsif ($m == 1) { return 0; }\nelsif ($m == 2 || $m == 3 || $m == 5) {\n\tmap { $u{$_}++ } &split_quoted_string($_[0]->{'uedit'});\n\tif ($m == 5 && $_[0]->{'uedit_sec'}) {\n\t\t# Check secondary groups too\n\t\treturn 1 if ($u{$_[1]->{'gid'}});\n\t\tforeach $g (&list_groups()) {\n\t\t\tlocal @m = split(/,/, $g->{'members'});\n\t\t\treturn 1 if ($u{$g->{'gid'}} &&\n\t\t\t\t     &indexof($_[1]->{'user'}, @m) >= 0);\n\t\t\t}\n\t\treturn 0;\n\t\t}\n\telse {\n\t\treturn $m == 2 ? $u{$_[1]->{'user'}} :\n\t\t       $m == 3 ? !$u{$_[1]->{'user'}} :\n\t\t\t\t $u{$_[1]->{'gid'}};\n\t\t}\n\t}\nelsif ($m == 4) {\n\treturn (!$_[0]->{'uedit'} || $_[1]->{'uid'} >= $_[0]->{'uedit'}) &&\n\t       (!$_[0]->{'uedit2'} || $_[1]->{'uid'} <= $_[0]->{'uedit2'});\n\t}\nelsif ($m == 6) {\n\treturn $_[1]->{'user'} eq $remote_user;\n\t}\nelsif ($m == 7) {\n\treturn $_[1]->{'user'} =~ /$_[0]->{'uedit_re'}/;\n\t}\nreturn 0;\n}\n\n=head2 can_edit_group(&acl, &group)\n\nReturns 1 if the given group hash can be edited by a Webmin user whose access\ncontrol permissions for this module are in the acl parameter.\n\n=cut\nsub can_edit_group\n{\nlocal $m = $_[0]->{'gedit_mode'};\nlocal %g;\nif ($m == 0) { return 1; }\nelsif ($m == 1) { return 0; }\nelsif ($m == 2 || $m == 3) {\n\tmap { $g{$_}++ } &split_quoted_string($_[0]->{'gedit'});\n\treturn $m == 2 ? $g{$_[1]->{'group'}}\n\t\t       : !$g{$_[1]->{'group'}};\n\t}\nelse { return (!$_[0]->{'gedit'} || $_[1]->{'gid'} >= $_[0]->{'gedit'}) &&\n\t      (!$_[0]->{'gedit2'} || $_[1]->{'gid'} <= $_[0]->{'gedit2'}); }\n}\n\n=head2 nis_index(&lines)\n\nInternal function to return the line number on which NIS includes start\nin a password or group file.\n\n=cut\nsub nis_index\n{\nlocal $i;\nfor($i=0; $i<@{$_[0]}; $i++) {\n\tlast if ($_[0]->[$i] =~ /^[\\+\\-]/);\n\t}\nreturn $i;\n}\n\n=head2 get_skel_directory(&user, groupname)\n\nReturns the skeleton files directory for some user. The groupname parameter\nmust be the name of his primary group.\n\n=cut\nsub get_skel_directory\n{\nlocal ($user, $groupname) = @_;\nlocal $uf = $config{'user_files'};\nlocal $shell = $user->{'shell'};\n$shell =~ s/^(.*)\\///g;\nif ($groupname ne '') {\n\t$uf =~ s/\\$group/$groupname/g;\n\t}\n$uf =~ s/\\$gid/$user->{'gid'}/g;\n$uf =~ s/\\$shell/$shell/g;\nreturn $uf;\n}\n\n=head2 copy_skel_files(source, dest, uid, gid)\n\nCopies skeleton files from some source directory (such as /etc/skel) to a \ndestination directory, typically a new user's home. The uid and gid are the\nIDs of the new user, which determines file ownership.\n\n=cut\nsub copy_skel_files\n{\nlocal ($f, $df);\nlocal @rv;\nforeach $f (split(/\\s+/, $_[0])) {\n\tif (-d $f) {\n\t\t# copy all files in a directory\n\t\topendir(DIR, $f);\n\t\tforeach $df (readdir(DIR)) {\n\t\t\tif ($df eq \".\" || $df eq \"..\") { next; }\n\t\t\tpush(@rv, &copy_file(\"$f/$df\", $_[1], $_[2], $_[3]));\n\t\t\t}\n\t\tclosedir(DIR);\n\t\t}\n\telsif (-r $f) {\n\t\t# copy just one file\n\t\tpush(@rv, &copy_file($f, $_[1], $_[2], $_[3]));\n\t\t}\n\t}\nreturn @rv;\n}\n\n=head2 copy_file(file, destdir, uid, gid)\n\nCopy a file or directory and chown it, preserving symlinks and special files.\nMainly for internal use by copy_skel_files.\n\n=cut\nsub copy_file\n{\nlocal($base, $subs);\n$_[0] =~ /\\/([^\\/]+)$/; $base = $1;\nif ($config{\"files_remap_$base\"}) {\n\t$base = $config{\"files_remap_$base\"};\n\t}\n$subs = $config{'files_remove'};\n$base =~ s/$subs//g if ($subs);\nlocal ($opts, $nochown);\nlocal @rv = ( \"$_[1]/$base\" );\nif (-b $_[0] || -c $_[0]) {\n\t# Looks like a device file .. re-create it\n\tlocal @st = stat($_[0]);\n\tlocal $maj = int($st[6] / 256);\n\tlocal $min = $st[6] % 256;\n\tlocal $typ = ($st[2] & 00170000) == 0020000 ? 'c' : 'b';\n\t&system_logged(\"mknod \".quotemeta(\"$_[1]/$base\").\" $typ $maj $min\");\n\t&set_ownership_permissions($_[2], $_[3], undef, \"$_[1]/$base\");\n\t$nochown++;\n\t}\nelsif (-l $_[0] && !$config{'copy_symlinks'}) {\n\t# A symlink .. re-create it\n\tlocal $l = readlink($_[0]);\n\t&system_logged(\"ln -s \".quotemeta($l).\" \".quotemeta(\"$_[1]/$base\").\" >/dev/null 2>/dev/null\");\n\t$opts = \"-h\";\n\t}\nelsif (-d $_[0]) {\n\t# A directory .. copy it recursively\n\t&system_logged(\"cp -Rp \".quotemeta($_[0]).\" \".quotemeta(\"$_[1]/$base\").\" >/dev/null 2>/dev/null\");\n\tlocal $glob = \"$_[1]/$base/*\";\n\twhile(1) {\n\t\tlocal @g = glob($glob);\n\t\tif (@g && -r $g[0]) {\n\t\t\tpush(@rv, @g);\n\t\t\t$glob .= \"/*\";\n\t\t\t}\n\t\telse {\n\t\t\tlast;\n\t\t\t}\n\t\t}\n\t}\nelse {\n\t# Just a normal file .. copy it\n\tlocal @st = stat(&translate_filename($_[0]));\n\t&system_logged(\"cp \".quotemeta($_[0]).\" \".quotemeta(\"$_[1]/$base\").\" >/dev/null 2>/dev/null\");\n\t&set_ownership_permissions($_[2], $_[3], $st[2], \"$_[1]/$base\");\n\t$nochown++;\n\t}\n&system_logged(\"chown $opts -R $_[2]:$_[3] \".quotemeta(\"$_[1]/$base\").\n\t       \" >/dev/null 2>/dev/null\") if (!$nochown);\nreturn @rv;\n}\n\n=head2 lock_user_files\n\nLock all password, shadow and group files. Should be called before performing\nany user or group operations.\n\n=cut\nsub lock_user_files\n{\n&lock_file($config{'passwd_file'});\n&lock_file($config{'group_file'});\n&lock_file($config{'shadow_file'});\n&lock_file($config{'gshadow_file'});\n&lock_file($config{'master_file'});\n}\n\n=head2 unlock_user_files\n\nUnlock all password, shadow and group files. Should be called after all user\nor group operations are complete.\n\n=cut\nsub unlock_user_files\n{\n&unlock_file($config{'passwd_file'});\n&unlock_file($config{'group_file'});\n&unlock_file($config{'shadow_file'});\n&unlock_file($config{'gshadow_file'});\n&unlock_file($config{'master_file'});\n}\n\n=head2 my_setpwent\n\nThe same as Perl's setpwent function, but may read from /etc/passwd directly.\n\n=cut\nsub my_setpwent\n{\nif ($config{'from_files'}) {\n\t@setpwent_cache = &list_users();\n\t$setpwent_pos = 0;\n\t}\nelse { return setpwent(); }\n}\n\n=head2 my_getpwent\n\nThe same as Perl's getpwent function, but may read from /etc/passwd directly.\n\n=cut\nsub my_getpwent\n{\nif ($config{'from_files'}) {\n\tmy_setpwent() if (!@setpwent_cache);\n\tif ($setpwent_pos >= @setpwent_cache) {\n\t\treturn wantarray ? () : undef;\n\t\t}\n\telse {\n\t\treturn &pw_user_rv($setpwent_cache[$setpwent_pos++],\n\t\t\t\t   wantarray, 'user');\n\t\t}\n\t}\nelse { return getpwent(); }\n}\n\n=head2 my_endpwent\n\nShould be called when you are done with my_setpwent and my_getpwent.\n\n=cut\nsub my_endpwent\n{\nif ($config{'from_files'}) {\n\tundef(@setpwent_cache);\n\t}\nelsif ($gconfig{'os_type'} eq 'hpux') {\n\t# On hpux, endpwent() can crash perl!\n\treturn 0;\n\t}\nelse { return endpwent(); }\n}\n\n=head2 my_getpwnam(username)\n\nLooks up a user by name, like the getpwnam Perl function, but may read \n/etc/passwd directly.\n\n=cut\nsub my_getpwnam\n{\nif ($config{'from_files'}) {\n\tlocal $u;\n\tforeach $u (&list_users()) {\n\t\treturn &pw_user_rv($u, wantarray, 'uid')\n\t\t\tif ($u->{'user'} eq $_[0]);\n\t\t}\n\treturn wantarray ? () : undef;\n\t}\nelse { return getpwnam($_[0]); }\n}\n\n=head2 my_getpwuid(uid)\n\nLooks up a user by ID, like the getpwnam Perl function, but may read \n/etc/passwd directly.\n\n=cut\nsub my_getpwuid\n{\nif ($config{'from_files'}) {\n\tforeach $u (&list_users()) {\n\t\treturn &pw_user_rv($u, wantarray, 'user')\n\t\t\tif ($u->{'uid'} eq $_[0]);\n\t\t}\n\treturn wantarray ? () : undef;\n\t}\nelse { return getpwuid($_[0]); }\n}\n\n=head2 pw_user_rv(&user, want-array, username-field)\n\nInternal function to convert a user hash reference into a list in the format\nreturn by the getpw* family of functions.\n\n=cut\nsub pw_user_rv\n{\nreturn $_[1] ? ( $_[0]->{'user'}, $_[0]->{'pass'}, $_[0]->{'uid'},\n\t\t $_[0]->{'gid'}, undef, undef, $_[0]->{'real'},\n\t\t $_[0]->{'home'}, $_[0]->{'shell'}, undef ) : $_[0]->{$_[2]};\n}\n\n=head2 my_setgrent\n\nThe same as Perl's setgrent function, but may read from /etc/group directly.\n\n=cut\nsub my_setgrent\n{\nif ($config{'from_files'}) {\n\t@setgrent_cache = &list_groups();\n\t$setgrent_pos = 0;\n\t}\nelse { return setgrent(); }\n}\n\n=head2 my_getgrent\n\nThe same as Perl's getgrent function, but may read from /etc/group directly.\n\n=cut\nsub my_getgrent\n{\nif ($config{'from_files'}) {\n\tmy_setgrent() if (!@setgrent_cache);\n\tif ($setgrent_pos >= @setgrent_cache) {\n\t\treturn ();\n\t\t}\n\telse {\n\t\treturn &gr_group_rv($setgrent_cache[$setgrent_pos++],\n\t\t\t\t    wantarray, 'group');\n\t\t}\n\t}\nelse { return getgrent(); }\n}\n\n=head2 my_endgrent\n\nShould be called when you are done with my_setgrent and my_getgrent.\n\n=cut\nsub my_endgrent\n{\nif ($config{'from_files'}) {\n\tundef(@setgrent_cache);\n\t}\nelsif ($gconfig{'os_type'} eq 'hpux') {\n\t# On hpux, endpwent() can crash perl!\n\treturn 0;\n\t}\nelse { return endgrent(); }\n}\n\n=head2 my_getgrnam(group)\n\nLooks up a group by name, like the Perl getgrnam function.\n\n=cut\nsub my_getgrnam\n{\nif ($config{'from_files'}) {\n\tlocal $g;\n\tforeach $g (&list_groups()) {\n\t\treturn &gr_group_rv($g, wantarray, 'gid')\n\t\t\tif ($g->{'group'} eq $_[0]);\n\t\t}\n\treturn wantarray ? () : undef;\n\t}\nelse { return getgrnam($_[0]); }\n}\n\n=head2 my_getgrgid(gid)\n\nLooks up a group by GID, like the Perl getgrgid function.\n\n=cut\nsub my_getgrgid\n{\nif ($config{'from_files'}) {\n\tforeach $g (&list_groups()) {\n\t\treturn &gr_group_rv($g, wantarray, 'group')\n\t\t\tif ($g->{'gid'} eq $_[0]);\n\t\t}\n\treturn wantarray ? () : undef;\n\t}\nelse { return getgrgid($_[0]); }\n}\n\nsub gr_group_rv\n{\nreturn $_[1] ? ( $_[0]->{'group'}, $_[0]->{'pass'}, $_[0]->{'gid'},\n\t\t $_[0]->{'members'} ) : $_[0]->{$_[2]};\n}\n\n=head2 auto_home_dir(base, username, groupname)\n\nReturns an automatically generated home directory, and creates needed\nparent dirs. The parameters are :\n\n=item base - Base directory, like /home.\n\n=item username - The user's login name.\n\n=item groupname - The user's primary group name.\n\n=cut\nsub auto_home_dir\n{\nlocal $pfx = $_[0] eq \"/\" ? \"/\" : $_[0].\"/\";\nif ($config{'home_style'} == 0) {\n\treturn $pfx.$_[1];\n\t}\nelsif ($config{'home_style'} == 1) {\n\t&mkdir_if_needed($pfx.substr($_[1], 0, 1));\n\treturn $pfx.substr($_[1], 0, 1).\"/\".$_[1];\n\t}\nelsif ($config{'home_style'} == 2) {\n\t&mkdir_if_needed($pfx.substr($_[1], 0, 1));\n\t&mkdir_if_needed($pfx.substr($_[1], 0, 1).\"/\".\n\t\t\t substr($_[1], 0, 2));\n\treturn $pfx.substr($_[1], 0, 1).\"/\".\n\t       substr($_[1], 0, 2).\"/\".$_[1];\n\t}\nelsif ($config{'home_style'} == 3) {\n\t&mkdir_if_needed($pfx.substr($_[1], 0, 1));\n\t&mkdir_if_needed($pfx.substr($_[1], 0, 1).\"/\".\n\t\t\t substr($_[1], 1, 1));\n\treturn $pfx.substr($_[1], 0, 1).\"/\".\n\t       substr($_[1], 1, 1).\"/\".$_[1];\n\t}\nelsif ($config{'home_style'} == 4) {\n\treturn $_[0];\n\t}\nelsif ($config{'home_style'} == 5) {\n\treturn $pfx.$_[2].\"/\".$_[1];\n\t}\n}\n\nsub mkdir_if_needed\n{\n-d $_[0] || &make_dir($_[0], 0755);\n}\n\n=head2 set_netinfo(&user)\n\nUpdate a NetInfo user based on a Webmin user hash. Mainly for internal use.\n\n=cut\nsub set_netinfo\n{\nlocal %u = %{$_[0]};\n&system_logged(\"niutil -createprop '$netinfo_domain' '/users/$u{'user'}' passwd '$u{'pass'}'\");\n&system_logged(\"niutil -createprop '$netinfo_domain' '/users/$u{'user'}' uid '$u{'uid'}'\");\n&system_logged(\"niutil -createprop '$netinfo_domain' '/users/$u{'user'}' gid '$u{'gid'}'\");\n&system_logged(\"niutil -createprop '$netinfo_domain' '/users/$u{'user'}' class '$u{'class'}'\");\n&system_logged(\"niutil -createprop '$netinfo_domain' '/users/$u{'user'}' change '$u{'change'}'\");\n&system_logged(\"niutil -createprop '$netinfo_domain' '/users/$u{'user'}' expire '$u{'expire'}'\");\n&system_logged(\"niutil -createprop '$netinfo_domain' '/users/$u{'user'}' realname '$u{'real'}'\");\n&system_logged(\"niutil -createprop '$netinfo_domain' '/users/$u{'user'}' home '$u{'home'}'\");\n&system_logged(\"niutil -createprop '$netinfo_domain' '/users/$u{'user'}' shell '$u{'shell'}'\");\n}\n\n=head2 set_group_netinfo(&group)\n\nUpdate a NetInfo group based on a Webmin group hash. Mainly for internal use.\n\n=cut\nsub set_group_netinfo\n{\nlocal %g = %{$_[0]};\nlocal $mems = join(\" \", map { \"'$_'\" } split(/,/, $g{'members'}));\n&system_logged(\"niutil -createprop '$netinfo_domain' '/groups/$g{'group'}' gid '$g{'gid'}'\");\n&system_logged(\"niutil -createprop '$netinfo_domain' '/groups/$g{'group'}' passwd '$g{'pass'}'\");\n&system_logged(\"niutil -createprop '$netinfo_domain' '/groups/$g{'group'}' users $mems\");\n}\n\n=head2 set_user_dirinfo(&user)\n\nUpdate a user in OSX directive services based on a Webmin user hash.\nMainly for internal use.\n\n=cut\nsub set_user_dirinfo\n{\nlocal %u = %{$_[0]};\nforeach my $k (keys %user_properties_map) {\n\tlocal $v = $u{$user_properties_map{$k}};\n\tif (defined($v)) {\n\t\t&execute_dscl_command(\"create\", \"/Users/$u{'user'}\", $k, $v);\n\t\t}\n\t}\nif ($u{'passmode'} == 3 && defined($u{'plainpass'}) ||\n    $u{'passmode'} == 0) {\n\t# A new plain password was given - use it\n\t&execute_dscl_command(\"passwd\", \"/Users/$u{'user'}\", $u{'plainpass'});\n\tif ($user->{'uuid'}) {\n\t\t$user->{'pass'} = &get_macos_password_hash($user->{'uuid'});\n\t\t}\n\t}\nelsif ($u{'passmode'} == 4) {\n\t# Explicitly not changed, so do nothing\n\t}\nelsif ($u{'passmode'} == 1 || $u{'pass'} eq $config{'lock_string'}) {\n\t# Account locked - set hash to match\n\t&set_macos_password_hash($u{'uuid'}, $u{'pass'});\n\t}\nelse {\n\t# Has the hash changed?\n\tlocal $oldpass = &get_macos_password_hash($u{'uuid'});\n\tif (defined($oldpass) && $u{'pass'} ne $oldpass) {\n\t\t# Yes .. so set it\n\t\t&set_macos_password_hash($u{'uuid'}, $u{'pass'});\n\t\t}\n\t}\n}\n\n=head2 set_group_dirinfo(&group)\n\nUpdate a group in OSX directive services based on a Webmin group hash.\nMainly for internal use.\n\n=cut\nsub set_group_dirinfo\n{\nlocal %g = %{$_[0]};\n$g{'members'} =~ s/,/ /g;\nforeach my $k (keys %group_properties_map) {\n\tlocal $v = $g{$group_properties_map{$k}};\n\tif (defined($v)) {\n\t\t&execute_dscl_command(\"create\", \"/Groups/$g{'group'}\", $k, $v);\n\t\t}\n\t}\n}\n\n=head2 check_password_restrictions(pass, username)\n\nReturns an error message if the given password fails length and other\nchecks, or undef if it is OK.\n\n=cut\nsub check_password_restrictions\n{\nreturn &text('usave_epasswd_min', $config{'passwd_min'})\n\tif (length($_[0]) < $config{'passwd_min'});\nlocal $re = $config{'passwd_re'};\nreturn &text('usave_epasswd_re', $re)\n\tif ($re && !eval { $_[0] =~ /^$re$/ });\nif ($config{'passwd_same'}) {\n\treturn &text('usave_epasswd_same') if ($_[0] =~ /\\Q$_[1]\\E/i);\n\t}\nif ($config{'passwd_dict'} && $_[0] =~ /^[A-Za-z\\'\\-]+$/ &&\n    (&has_command(\"ispell\") || &has_command(\"spell\"))) {\n\t# Call spell or ispell to check for dictionary words\n\tlocal $temp = &transname();\n\topen(TEMP, \">$temp\");\n\tprint TEMP $_[0],\"\\n\";\n\tclose(TEMP);\n\tif (&has_command(\"ispell\")) {\n\t\topen(SPELL, \"ispell -a <$temp |\");\n\t\twhile(<SPELL>) {\n\t\t\tif (/^(#|\\&|\\?)/) {\n\t\t\t\t$unknown++;\n\t\t\t\t}\n\t\t\t}\n\t\tclose(SPELL);\n\t\t}\n\telse {\n\t\topen(SPELL, \"spell <$temp |\");\n\t\tlocal $line = <SPELL>;\n\t\t$unknown++ if ($line);\n\t\tclose(SPELL);\n\t\t}\n\tunlink($temp);\n\treturn &text('usave_epasswd_dict') if (!$unknown);\n\t}\nif ($config{'passwd_prog'}) {\n\tlocal $out;\n\tif ($config{'passwd_progmode'} == 0) {\n\t\t# Run external validation program with user and password as args\n\t\tlocal $qu = quotemeta($_[1]);\n\t\tlocal $qp = quotemeta($_[0]);\n\t\t$out = &backquote_command(\n\t\t\t\"$config{'passwd_prog'} $qu $qp 2>&1 </dev/null\");\n\t\t}\n\telse {\n\t\t# Run program with password as input on stdin\n\t\tlocal $temp = &transname();\n\t\t&open_tempfile(TEMP, \">$temp\", 0, 1);\n\t\t&print_tempfile(TEMP, $_[1],\"\\n\");\n\t\t&print_tempfile(TEMP, $_[0],\"\\n\");\n\t\t&close_tempfile(TEMP);\n\t\t$out = &backquote_command(\"$config{'passwd_prog'} <$temp 2>&1\");\n\t\t}\n\tif ($?) {\n\t\treturn $out;\n\t\t}\n\t}\nreturn undef;\n}\n\n=head2 check_username_restrictions(username)\n\nReturns an error message if a username fails some restriction, or undef if\nit is OK.\n\n=cut\nsub check_username_restrictions\n{\nif ($config{'max_length'} && length($_[0]) > $config{'max_length'}) {\n\treturn &text('usave_elength', $config{'max_length'});\n\t}\nlocal $re = $config{'username_re'};\nreturn &text('usave_ere', $re)\n\tif ($re && !eval { $_[0] =~ /^$re$/ });\nreturn undef;\n}\n\n=head2 can_use_group(&acl, group)\n\nReturns 1 if some group can be used as a primary or secondary, 0 if not.\n\n=cut\nsub can_use_group\n{\nreturn 1 if ($_[0]->{'ugroups'} eq '*');\nlocal @sp = &split_quoted_string($_[0]->{'ugroups'});\nif ($_[0]->{'uedit_gmode'} == 3) {\n\treturn &indexof($_[1], @sp) < 0;\n\t}\nelsif ($_[0]->{'uedit_gmode'} == 4) {\n\tlocal @ginfo = &my_getgrnam($_[1]);\n\treturn (!$_[0]->{'ugroups'} || $ginfo[2] >= $_[0]->{'ugroups'}) &&\n\t       (!$_[0]->{'ugroups2'} || $ginfo[2] <= $_[0]->{'ugroups2'});\n\t}\nelse {\n\treturn &indexof($_[1], @sp) >= 0;\n\t}\n}\n\n=head2 refresh_nscd\n\nSends a HUP signal to the nscd process, so that any caches are reloaded.\n\n=cut\nsub refresh_nscd\n{\nreturn if ($nscd_not_running);\nif (!&find_byname(\"nscd\")) {\n\t$nscd_not_running++;\n\t}\nelsif ($config{'nscd_restart'}) {\n\t# Run the specified command\n\t&system_logged(\"$config{'nscd_restart'} >/dev/null 2>&1 </dev/null\");\n\t}\nelsif (&has_command(\"nscd\")) {\n\t# Use nscd -i to reload\n\t&system_logged(\"nscd -i group >/dev/null 2>&1 </dev/null\");\n\t&system_logged(\"nscd -i passwd >/dev/null 2>&1 </dev/null\");\n\t}\nelse {\n\t# Send HUP signal\n\tlocal $rv = &kill_byname_logged(\"nscd\", \"HUP\");\n\tif (!$rv) {\n\t\t$nscd_not_running++;\n\t\t}\n\t}\nsleep(1);\t# Give ncsd time to react\n}\n\n=head2 set_user_envs(&user, action, [plainpass], [secondaries], [&olduser], [oldplainpass])\n\nSets up the USERADMIN_ environment variables for a user update of some kind,\nprior to calling making_changes or made_changes. The parameters are :\n\n=item user - User details hash reference, in the same format as returned by list_users.\n\n=item action - Must be one of CREATE_USER, MODIFY_USER or DELETE_USER.\n\n=item plainpass - The user's un-encrypted password, if available.\n\n=item secondaries - An array reference of secondary group names the user is a member of.\n\n=item olduser - When modifying a user, the hash reference of it's old details.\n\n=item oldplainpass - When modifying a user, it's old un-encrypted password, if available.\n\n=cut\nsub set_user_envs\n{\nlocal ($user, $action, $plainpass, $secs, $olduser, $oldpass) = @_;\n&clear_envs();\n$ENV{'USERADMIN_USER'} = $user->{'user'};\n$ENV{'USERADMIN_UID'} = $user->{'uid'};\n$ENV{'USERADMIN_REAL'} = $user->{'real'};\n$ENV{'USERADMIN_SHELL'} = $user->{'shell'};\n$ENV{'USERADMIN_HOME'} = $user->{'home'};\n$ENV{'USERADMIN_GID'} = $user->{'gid'};\nlocal $group = &my_getgrgid($user->{'gid'});\nif ($group) {\n\t$ENV{'USERADMIN_GROUP'} = $group;\n\t}\n$ENV{'USERADMIN_PASS'} = $plainpass if (defined($plainpass));\n$ENV{'USERADMIN_SECONDARY'} = join(\",\", @{$secs}) if (defined($secs));\n$ENV{'USERADMIN_ACTION'} = $action;\n$ENV{'USERADMIN_SOURCE'} = $main::module_name;\nif ($olduser) {\n\t$ENV{'USERADMIN_OLD_USER'} = $user->{'user'};\n\t$ENV{'USERADMIN_OLD_UID'} = $user->{'uid'};\n\t$ENV{'USERADMIN_OLD_REAL'} = $user->{'real'};\n\t$ENV{'USERADMIN_OLD_SHELL'} = $user->{'shell'};\n\t$ENV{'USERADMIN_OLD_HOME'} = $user->{'home'};\n\t$ENV{'USERADMIN_OLD_GID'} = $user->{'gid'};\n\t$ENV{'USERADMIN_OLD_PASS'} = $oldpass if (defined($oldpass));\n\t}\n}\n\n=head2 set_group_envs(&group, action, [&oldgroup])\n\nSets up the USERADMIN_ environment variables for a group update of some kind,\nprior to calling making_changes or made_changes. The parameters are :\n\n=item group - Group details hash reference, in the same format as returned by list_groups.\n\n=item action - Must be one of CREATE_GROUP, MODIFY_GROUP or DELETE_GROUP.\n\n=item oldgroup - When modifying a group, the hash reference of it's old details.\n\n=cut\nsub set_group_envs\n{\nlocal ($group, $action, $oldgroup) = @_;\n&clear_envs();\n$ENV{'USERADMIN_GROUP'} = $group->{'group'};\n$ENV{'USERADMIN_GID'} = $group->{'gid'};\n$ENV{'USERADMIN_MEMBERS'} = $group->{'members'};\n$ENV{'USERADMIN_ACTION'} = $action;\n$ENV{'USERADMIN_SOURCE'} = $main::module_name;\nif ($oldgroup) {\n\t$ENV{'USERADMIN_OLD_GROUP'} = $oldgroup->{'group'};\n\t$ENV{'USERADMIN_OLD_GID'} = $oldgroup->{'gid'};\n\t$ENV{'USERADMIN_OLD_MEMBERS'} = $oldgroup->{'members'};\n\t}\n}\n\n=head2 clear_envs\n\nRemoves all variables set by set_user_envs and set_group_envs.\n\n=cut\nsub clear_envs\n{\nlocal $e;\nforeach $e (keys %ENV) {\n\tdelete($ENV{$e}) if ($e =~ /^USERADMIN_/);\n\t}\n}\n\n=head2 encrypt_password(password, [salt])\n\nEncrypts a password using the encryption format configured for this system.\nIf the salt parameter is given, it will be used for hashing the password -\nthis is typically an already encrypted password, that you want to compare with\nthe result of this function to check that passwords match. If missing, a salt\nwill be randomly generated.\n\n=cut\nsub encrypt_password\n{\nlocal ($pass, $salt) = @_;\nlocal $format = 0;\nif ($gconfig{'os_type'} eq 'macos' && &passfiles_type() == 7) {\n\t# New OSX directory service uses SHA1 for passwords!\n\t$salt ||= chr(int(rand(26))+65).chr(int(rand(26))+65). \n\t\t  chr(int(rand(26))+65).chr(int(rand(26))+65);\n\tif (&check_sha1()) {\n\t\t# Use Digest::SHA1 perl module\n\t\treturn &encrypt_sha1_hash($pass, $salt);\n\t\t}\n\telsif (&has_command(\"openssl\")) {\n\t\t# Use openssl command\n\t\tlocal $temp = &transname();\n\t\t&open_execute_command(OPENSSL, \"openssl dgst -sha1 >$temp\", 0);\n\t\tprint OPENSSL $salt,$pass;\n\t\tclose(OPENSSL);\n\t\tlocal $rv = &read_file_contents($temp);\n\t\t&unlink_file($temp);\n\t\t$rv =~ s/\\r|\\n//g;\n\t\treturn $rv;\n\t\t}\n\telse {\n\t\t&error(\"Either the Digest::SHA1 Perl module or openssl command is needed to hash passwords\");\n\t\t}\n\t}\nelsif ($config{'md5'} == 2) {\n\t# Always use MD5\n\t$format = 1;\n\t}\nelsif ($config{'md5'} == 3) {\n\t# Always use blowfish\n\t$format = 2;\n\t}\nelsif ($config{'md5'} == 4) {\n\t# Always use SHA512\n\t$format = 3;\n\t}\nelsif ($config{'md5'} == 1 && !$config{'skip_md5'}) {\n\t# Up to system\n\t$format = &use_md5() if (defined(&use_md5));\n\t}\n\nif ($no_encrypt_password) {\n\t# Some operating systems don't do any encryption!\n\treturn $pass;\n\t}\nelsif ($format == 1) {\n\t# MD5 encryption is selected .. use it if possible\n\tlocal $err = &check_md5();\n\tif ($err) {\n\t\t&error(&text('usave_edigestmd5',\n\t\t    \"/config.cgi?$module_name\",\n\t\t    \"/cpan/download.cgi?source=3&cpan=$err\", $err));\n\t\t}\n\treturn &encrypt_md5($pass, $salt);\n\t}\nelsif ($format == 2) {\n\t# Blowfish is selected .. use it if possible\n\tlocal $err = &check_blowfish();\n\tif ($err) {\n\t\t&error(&text('usave_edigestblowfish',\n\t\t    \"/config.cgi?$module_name\",\n\t\t    \"/cpan/download.cgi?source=3&cpan=$err\", $err));\n\t\t}\n\treturn &encrypt_blowfish($pass, $salt);\n\t}\nelsif ($format == 3) {\n\t# SHA512 is selected .. use it\n\tlocal $err = &check_sha512();\n\tif ($err) {\n\t\t&error($text{'usave_edigestsha512'});\n\t\t}\n\treturn &encrypt_sha512($pass, $salt);\n\t}\nelse {\n\t# Just do old-style crypt() DES encryption\n\tif ($salt !~ /^[a-z0-9]{2}/i) {\n\t\t# Un-usable non-DES salt\n\t\t$salt = undef;\n\t\t}\n\t$salt ||= chr(int(rand(26))+65) . chr(int(rand(26))+65);\n\treturn &unix_crypt($pass, $salt);\n\t}\n}\n\n=head2 build_user_used([&uid-hash], [&shell-list], [&username-hash])\n\nFills in hashes with used UIDs, shells and usernames, based on existing users.\nUseful for allocating a new UID, with code like :\n\n  my %used;\n  useradmin::build_user_used(\\%used);\n  $newuid = useradmin::allocate_uid(\\%used);\n\n=cut\nsub build_user_used\n{\n&my_setpwent();\nlocal @u;\nwhile(@u = &my_getpwent()) {\n\t$_[0]->{$u[2]}++ if ($_[0]);\n\tpush(@{$_[1]}, $u[8]) if ($_[1] && $u[8]);\n\t$_[2]->{$u[0]}++ if ($_[2]);\n\t}\n&my_endpwent();\nlocal $u;\nforeach $u (&list_users()) {\n\t$_[0]->{$u->{'uid'}}++ if ($_[0]);\n\tpush(@{$_[1]}, $u->{'shell'}) if ($_[1] && $u->{'shell'});\n\t$_[2]->{$u->{'user'}}++ if ($_[2]);\n\t}\n}\n\n=head2 build_group_used([&gid-hash], [&groupname-hash])\n\nFills in hashes with used GIDs and group names, based on existing groups.\nUseful for allocating a new GID, with code like :\n\n  my %used;\n  useradmin::build_group_used(\\%used);\n  $newgid = useradmin::allocate_gid(\\%used);\n\n=cut\nsub build_group_used\n{\n&my_setgrent();\nlocal @g;\nwhile(@g = &my_getgrent()) {\n\t$_[0]->{$g[2]}++ if ($_[0]);\n\t$_[1]->{$g[0]}++ if ($_[1]);\n\t}\n&my_endgrent();\nlocal $g;\nforeach $g (&list_groups()) {\n\t$_[0]->{$g->{'gid'}}++ if ($_[0]);\n\t$_[1]->{$g->{'group'}}++ if ($_[1]);\n\t}\n}\n\n=head2 allocate_uid(&uids-used)\n\nGiven a hash reference whose keys are UIDs already in use, returns a free UID\nsuitable for a new user.\n\n=cut\nsub allocate_uid\n{\nlocal $rv = int($config{'base_uid'} > $access{'lowuid'} ?\n\t\t$config{'base_uid'} : $access{'lowuid'});\nwhile($_[0]->{$rv}) {\n\t$rv++;\n\t}\nreturn $rv;\n}\n\n=head2 allocate_gid(&gids-used)\n\nGiven a hash reference whose keys are GIDs already in use, returns a free GID\nsuitable for a new group.\n\n=cut\nsub allocate_gid\n{\nlocal $rv = int($config{'base_gid'} > $access{'lowgid'} ?\n\t\t$config{'base_gid'} : $access{'lowgid'});\nwhile($_[0]->{$rv}) {\n\t$rv++;\n\t}\nreturn $rv;\n}\n\n=head2 list_allowed_users(&access, &allusers)\n\nReturns a list of users to whom access is allowed. The parameters are :\n\n=item access - A hash reference of Webmin user permissions, such as returned by get_module_acl.\n\n=item allusers - List of all users to filter down.\n\n=cut\nsub list_allowed_users\n{\nlocal %access = %{$_[0]};\nlocal @ulist = @{$_[1]};\nif ($access{'uedit_mode'} == 1) {\n\t@ulist = ();\n\t}\nelsif ($access{'uedit_mode'} == 2) {\n\tlocal %canu;\n\tmap { $canu{$_}++ } &split_quoted_string($access{'uedit'});\n\t@ulist = grep { $canu{$_->{'user'}} } @ulist;\n\t}\nelsif ($access{'uedit_mode'} == 3) {\n\tlocal %cannotu;\n\tmap { $cannotu{$_}++ } &split_quoted_string($access{'uedit'});\n\t@ulist = grep { !$cannotu{$_->{'user'}} } @ulist;\n\t}\nelsif ($access{'uedit_mode'} == 4) {\n\t@ulist = grep {\n\t\t(!$access{'uedit'} || $_->{'uid'} >= $access{'uedit'}) &&\n\t\t(!$access{'uedit2'} || $_->{'uid'} <= $access{'uedit2'})\n\t\t\t} @ulist;\n\t}\nelsif ($access{'uedit_mode'} == 5) {\n\tlocal %cangid;\n\tmap { $cangid{$_}++ } &split_quoted_string($access{'uedit'});\n\tif ($access{'uedit_sec'}) {\n\t\t# Match secondary groups too\n\t\tlocal @glist = &list_groups();\n\t\tlocal (@ucan, $g);\n\t\tforeach $g (@glist) {\n\t\t\tpush(@ucan, split(/,/, $g->{'members'}))\n\t\t\t\tif ($cangid{$g->{'gid'}});\n\t\t\t}\n\t\t@ulist = grep { $cangid{$_->{'gid'}} ||\n\t\t\t\t&indexof($_->{'user'}, @ucan) >= 0 } @ulist;\n\t\t}\n\telse {\n\t\t@ulist = grep { $cangid{$_->{'gid'}} } @ulist;\n\t\t}\n\t}\nelsif ($access{'uedit_mode'} == 6) {\n\t@ulist = grep { $_->{'user'} eq $remote_user } @ulist;\n\t}\nelsif ($access{'uedit_mode'} == 7) {\n\t@ulist = grep { $_->{'user'} =~ /$access{'uedit_re'}/ } @ulist;\n\t}\nelsif ($access{'uedit_mode'} == 8) {\n\t@ulist = grep {\n\t\t(!$access{'uedit'} || $_->{'gid'} >= $access{'uedit'}) &&\n\t\t(!$access{'uedit2'} || $_->{'gid'} <= $access{'uedit2'})\n\t\t\t} @ulist;\n\t}\nif ($access{'view'}) {\n\t# Include non-editable users in results\n\tlocal @rv = @{$_[1]};\n\tlocal $u;\n\tforeach $u (@rv) {\n\t\tif (&indexof($u, @ulist) < 0) {\n\t\t\t$u->{'noedit'} = 1;\n\t\t\t}\n\t\t}\n\treturn @rv;\n\t}\nelse {\n\treturn @ulist;\n\t}\n}\n\n=head2 list_allowed_groups(&access, &allgroups)\n\nReturns a list of groups to whom access is allowed. The parameters are :\n\n=item access - A hash reference of Webmin user permissions, such as returned by get_module_acl.\n\n=item allgroups - List of all Unix groups to filter down.\n\n=cut\nsub list_allowed_groups\n{\nlocal %access = %{$_[0]};\nlocal @glist = @{$_[1]};\nif ($access{'gedit_mode'} == 1) {\n\t@glist = ();\n\t}\nelsif ($access{'gedit_mode'} == 2) {\n\tlocal %cang;\n\tmap { $cang{$_}++ } &split_quoted_string($access{'gedit'});\n\t@glist = grep { $cang{$_->{'group'}} } @glist;\n\t}\nelsif ($access{'gedit_mode'} == 3) {\n\tlocal %cannotg;\n\tmap { $cannotg{$_}++ } &split_quoted_string($access{'gedit'});\n\t@glist = grep { !$cannotg{$_->{'group'}} } @glist;\n\t}\nelsif ($access{'gedit_mode'} == 4) {\n\t@glist = grep {\n\t\t(!$access{'gedit'} || $_->{'gid'} >= $access{'gedit'}) &&\n\t\t(!$access{'gedit2'} || $_->{'gid'} <= $access{'gedit2'})\n\t\t\t} @glist;\n\t}\nif ($access{'view'}) {\n\t# Include non-editable groups in results\n\tlocal @rv = @{$_[1]};\n\tlocal $g;\n\tforeach $g (@rv) {\n\t\tif (&indexof($g, @glist) < 0) {\n\t\t\t$g->{'noedit'} = 1;\n\t\t\t}\n\t\t}\n\treturn @rv;\n\t}\nelse {\n\treturn @glist;\n\t}\n}\n\n=head2 batch_start\n\nTells the create/modify/delete functions to only update files in memory,\nnot on disk.\n\n=cut\nsub batch_start\n{\n$batch_mode = 1;\n}\n\n=head2 batch_end\n\nFlushes any user file changes\n\n=cut\nsub batch_end\n{\n$batch_mode = 0;\n&flush_file_lines();\n&refresh_nscd();\n}\n\n#################################################################\n\nsub mkuid\n{\n#################################################################\n#### \n#### Assumptions:\n#### \n#### This subroutine assumes the usernames are standardized\n#### using the format of 7 characters with 3 letters followed\n#### by 4 digits, or 4 letters followed by 3 digits.  If\n#### uppercase letters are used in the username, they will be\n#### converted to lowercase and this subroutine will generate\n#### a UID number identical to the usernames lowercase\n#### equivalent. \n#### \n#### 3 letters, 4 digits   Lowest possible UID (aaa0000) =   1,000,000\n#### 3 letters, 4 digits Hightest possible UID (zzz9999) = 176,759,999\n#### \n#### 4 letters, 3 digits   Lowest possible UID (aaaa000) = 176,760,000\n#### 4 letters, 3 digits Hightest possible UID (zzzz999) = 633,735,999\n#### \n#################################################################\n    my ${num_let} = 0;\n    foreach (split(//,$_[0])) {\n      ++${num_let} if ( m/[a-z]/i );\n    }\n    if ( length($_[0]) ne 7 ) {\n        print \"ERROR: Number of characters in username $_[0] is not equal to 7\\n\";\n        return -1;\n    }\n    if ( ${num_let} ne 3 && ${num_let} ne 4 ) {\n        print \"ERROR: Number of letters in username $_[0] is not equal to 3 or 4\\n\";\n        return -1;\n    }\n    my ${mkuid_type} = 10 ** ( 7 - ${num_let} );\n    my ${lowlimit} = 1000000;\n    my %letters;\n    my ${icnt} = -1;\n    my ${lowuid};\n    ${lowuid} = ( 26 ** ( ${num_let} - 1 ) * ${lowlimit}/100 ) + ${lowlimit};\n    ${lowuid} = ${lowlimit} if ( ${num_let} eq 3 );\n    my ${base} = 26;\n\n#################################################################\n#### \n#### Establish an associative array containing all the\n#### letters of the alphabet and assign a numeric value\n#### to each letter from 1 - 26.\n#### \n#################################################################\n    $letters{'a'} = ++${icnt};\n    $letters{'b'} = ++${icnt};\n    $letters{'c'} = ++${icnt};\n    $letters{'d'} = ++${icnt};\n    $letters{'e'} = ++${icnt};\n    $letters{'f'} = ++${icnt};\n    $letters{'g'} = ++${icnt};\n    $letters{'h'} = ++${icnt};\n    $letters{'i'} = ++${icnt};\n    $letters{'j'} = ++${icnt};\n    $letters{'k'} = ++${icnt};\n    $letters{'l'} = ++${icnt};\n    $letters{'m'} = ++${icnt};\n    $letters{'n'} = ++${icnt};\n    $letters{'o'} = ++${icnt};\n    $letters{'p'} = ++${icnt};\n    $letters{'q'} = ++${icnt};\n    $letters{'r'} = ++${icnt};\n    $letters{'s'} = ++${icnt};\n    $letters{'t'} = ++${icnt};\n    $letters{'u'} = ++${icnt};\n    $letters{'v'} = ++${icnt};\n    $letters{'w'} = ++${icnt};\n    $letters{'x'} = ++${icnt};\n    $letters{'y'} = ++${icnt};\n    $letters{'z'} = ++${icnt};\n\n#################################################################\n#### \n#### Initialize variables to be use while calculating the UID\n#### number associated with the login name.\n#### \n#### nvalue is used to store numeric characters that occurs\n####     in the login name\n#### ecnt is used to keep track of the base 26 exponent for \n####     each letter character that occurs in the login name\n#### subtot is the sum of the calculated value for each\n####     character position in the login name\n#### mult is the total of the 26 ** ecnt at each iteration of \n####     the loop\n#### \n#################################################################\n    my ${kstring} = '';\n    my ${nvalue} = '';\n    my ${lvalue} = 0;\n    my ${ecnt} = 0;\n    my ${subtot} = 0;\n    my ${tot} = 0;\n    my ${mult} = 0;\n#################################################################\n#### \n#### each character position of the login name is split out\n#### and used as an iteration of the foreach loop\n#### \n#################################################################\n\n    foreach (split(//,$_[0])) {\n\n#################################################################\n#### \n#### If the current character of the login name is a letter,\n#### convert it to lower case, and obtain it's numeric value\n#### from the associative array of letters, otherwise, if the\n#### current character is a number, append the number to the\n#### end of a buffer and save it for later processing.\n#### \n#################################################################\n      if ( m/[a-z]/i ) {\n        $kstring = \"\\L${_}\";\n        ${lvalue} = ${letters{${kstring}}};\n      } else {\n        ${lvalue} = 0;\n        ${nvalue} = \"${nvalue}${_}\";\n      }\n#################################################################\n#### Calculate the multiplier for a base 26 calculation using\n#### each iteration through the foreach loop as an increment\n#### of the exponent.  The base 26 exponent starting at 0.\n#################################################################\n\n      ${mult} = ${base} ** ${ecnt};\n\n#################################################################\n#### \n#### Multiply the numeric value of the current character by\n#### the multiplier and add this result to a running subtotal\n#### of all characters of the login name.\n#### \n#################################################################\n      ${subtot} = ${subtot} + ( ${lvalue} * ${mult} );\n\n#################################################################\n#### \n#### Increment the base 26 exponent by one before iterating for\n#### the next character of the login name.\n#### \n#################################################################\n      ++${ecnt}\n    }\n\n#################################################################\n#### \n#### After all characters of the login name have be processed,\n#### multiply the result by 1,000.  This is done because the \n#### username standard is 3 letters followed by 4 digits.  So\n#### each 3 letter combination can have 1,000 possible combinations.\n#### Then add the numeric values saved and any value to use\n#### as the lowest UID number allowed through this calculated method.\n#### \n#################################################################\n\n    ${tot} = ( ${subtot} * ${mkuid_type} ) + int(${nvalue}) + ${lowuid};\n\n#################################################################\n#### \n#### Return the calculated UID number as the result of this\n#### subroutine.\n#### \n#################################################################\n\n    return ${tot};\n}\n################################################################\nsub berkeley_cksum {\n    my($crc) = my($len) = 0;\n    my($buf,$num,$i);\n    my($buflen) = 4096; # buffer is \"4k\", you can up it if you want...\n\n    $buf = $_[0];\n    $num = length($buf);\n\n    $len += $num;\n    foreach ( unpack(\"C*\", $buf) ) {\n        $crc |= 0x10000 if ( $crc & 1 ); # get ready for rotating the 1 below\n        $crc = (($crc>>1)+$_) & 0xffff; # keep to 16-bit\n    }\n    return sprintf(\"%lu\",${crc});;\n}\n\n=head2 users_table(&users, [form], [no-last], [no-boxes], [&otherlinks], [&rightlinks])\n\nPrints a table listing full user details, with checkboxes and buttons to\ndelete or disable multiple at once.\n\n=cut\nsub users_table\n{\nlocal ($users, $formno, $nolast, $noboxes, $links, $rightlinks) = @_;\n\nlocal (@ginfo, %gidgrp);\n&my_setgrent();\nwhile(@ginfo = &my_getgrent()) {\n\t$gidgrp{$ginfo[2]} = $ginfo[0];\n\t}\n&my_endgrent();\n\n# Work out if any users can be edited\nlocal $anyedit;\nforeach my $u (@$users) {\n\tif (!$u->{'noedit'}) {\n\t\t$anyedit = 1;\n\t\tlast;\n\t\t}\n\t}\n$anyedit = 0 if ($noboxes);\nlocal $lshow = !$nolast && $config{'last_show'};\n\nlocal $buttons;\n$buttons .= &ui_submit($text{'index_mass'}, \"delete\") if ($access{'udelete'});\n$buttons .= &ui_submit($text{'index_mass2'}, \"disable\");\n$buttons .= &ui_submit($text{'index_mass3'}, \"enable\");\n$buttons .= \"<br>\" if ($buttons);\nlocal @linksrow;\nif ($anyedit) {\n\tprint &ui_form_start(\"mass_delete_user.cgi\", \"post\");\n\tpush(@linksrow, &select_all_link(\"d\", $_[1]),\n\t\t\t&select_invert_link(\"d\", $_[1]));\n\t}\npush(@linksrow, @$links);\nlocal @grid = ( &ui_links_row(\\@linksrow), &ui_links_row($rightlinks) );\nprint &ui_grid_table(\\@grid, 2, 100, [ \"align=left\", \"align=right\" ]);\n\nlocal @tds = $anyedit ? ( \"width=5\" ) : ( );\npush(@tds, \"width=15%\", \"width=10%\");\nprint &ui_columns_start([\n\t$anyedit ? ( \"\" ) : ( ),\n\t$text{'user'},\n\t$text{'uid'},\n\t$text{'gid'},\n\t$text{'real'},\n\t$text{'home'},\n\t$text{'shell'},\n\t$lshow ? ( $text{'lastlogin'} ) : ( )\n\t], 100, 0, \\@tds);\nlocal %llogin;\nif ($lshow) {\n\tlocal $l;\n\tforeach $l (&list_last_logins()) {\n\t\t$llogin{$l->[0]} ||= $l->[3];\n\t\t}\n\t}\nlocal $u;\nforeach $u (@$users) {\n\t$u->{'real'} =~ s/,.*$// if ($config{'extra_real'} ||\n\t\t\t\t     $u->{'real'} =~ /,$/);\n\tlocal @cols;\n\tpush(@cols, \"\") if ($anyedit && $u->{'noedit'});\n\tpush(@cols, &user_link($u));\n\tpush(@cols, $u->{'uid'});\n\tpush(@cols, $gidgrp{$u->{'gid'}}||$u->{'gid'});\n\tpush(@cols, $u->{'real'});\n\tpush(@cols, $u->{'home'});\n\tpush(@cols, $u->{'shell'});\n\tpush(@cols, $llogin{$u->{'user'}}) if ($lshow);\n\tif ($u->{'noedit'}) {\n\t\tprint &ui_columns_row(\\@cols, \\@tds);\n\t\t}\n\telse {\n\t\tprint &ui_checked_columns_row(\\@cols, \\@tds, \"d\", $u->{'user'});\n\t\t}\n\t}\nprint &ui_columns_end();\nprint &ui_links_row(\\@linksrow);\nif ($anyedit) {\n\tprint $buttons;\n\tprint &ui_form_end();\n\t}\n}\n\n=head2 groups_table(&groups, [form], [no-buttons], [&otherlinks], [&rightlinks])\n\nPrints a table of groups, possibly with checkboxes and a delete button\n\n=cut\nsub groups_table\n{\nlocal ($groups, $formno, $noboxes, $links, $rightlinks) = @_;\n\n# Work out if any groups can be edited or have descriptions\nlocal $anyedit;\nlocal $anydesc;\nforeach my $g (@$groups) {\n\tif (!$g->{'noedit'}) {\n\t\t$anyedit = 1;\n\t\t}\n\tif ($g->{'desc'}) {\n\t\t$anydesc = 1;\n\t\t}\n\t}\n$anyedit = 0 if ($noboxes);\n\nlocal @linksrow;\nif ($anyedit && $access{'gdelete'}) {\n\tprint &ui_form_start(\"mass_delete_group.cgi\", \"post\");\n\tpush(@linksrow, &select_all_link(\"gd\", $formno),\n\t\t\t&select_invert_link(\"gd\", $formno) );\n\t}\npush(@linksrow, @$links);\nlocal @grid = ( &ui_links_row(\\@linksrow), &ui_links_row($rightlinks) );\nprint &ui_grid_table(\\@grid, 2, 100, [ \"align=left\", \"align=right\" ]);\n\nlocal @tds = $anyedit ? ( \"width=5\" ) : ( );\npush(@tds, \"width=15%\", \"width=10%\");\nprint &ui_columns_start([\n\t$anyedit ? ( \"\" ) : ( ),\n\t$text{'gedit_group'},\n\t$text{'gedit_gid'},\n\t$anydesc ? ( $text{'gedit_desc'} ) : ( ),\n\t$text{'gedit_members'} ], 100, 0, \\@tds);\nlocal $g;\nforeach $g (@$groups) {\n\tlocal $members = join(\" \", split(/,/, $g->{'members'}));\n\tlocal @cols;\n\tif ($anyedit && ($g->{'noedit'} || !$access{'gdelete'})) {\n\t\t# Need an explicity blank first column\n\t\tpush(@cols, \"\");\n\t\t}\n\tpush(@cols, &group_link($g));\n\tpush(@cols, $g->{'gid'});\n\tif ($anydesc) {\n\t\tpush(@cols, $g->{'desc'});\n\t\t}\n\tpush(@cols, &html_escape($members));\n\tif ($g->{'noedit'} || !$access{'gdelete'}) {\n\t\tprint &ui_columns_row(\\@cols, \\@tds);\n\t\t}\n\telse {\n\t\tprint &ui_checked_columns_row(\\@cols, \\@tds, \"gd\",\n\t\t\t\t\t      $g->{'group'});\n\t\t}\n\t}\nprint &ui_columns_end();\nprint &ui_links_row(\\@linksrow);\nif ($anyedit && $access{'gdelete'}) {\n\tprint &ui_submit($text{'index_gmass'}, \"delete\"),\"<br>\\n\";\n\tprint &ui_form_end();\n\t}\n}\n\n=head2 date_input(day, month, year, prefix)\n\nReturns HTML for selecting a date\n\n=cut\nsub date_input\n{\nlocal ($d, $m, $y, $prefix) = @_;\nlocal $rv;\n$rv .= &ui_textbox($prefix.\"d\", $d, 3).\"/\";\n$rv .= &ui_select($prefix.\"m\", $m,\n\t\t[ map { [ $_, $text{\"smonth_\".$_} ] } (1..12) ]).\"/\";\n$rv .= &ui_textbox($prefix.\"y\", $y, 5);\n$rv .= &date_chooser_button($prefix.\"d\", $prefix.\"m\", $prefix.\"y\");\nreturn $rv;\n}\n\n=head2 list_last_logins([user], [max])\n\nReturns a list of array references, each containing the details of a login.\n\n=cut\nsub list_last_logins\n{\nlocal @rv;\n&open_last_command(LAST, $_[0]);\nwhile(@last = &read_last_line(LAST)) {\n\tpush(@rv, [ @last ]);\n\tif ($_[1] && scalar(@rv) >= $_[1]) {\n\t\tlast;\t# reached max\n\t\t}\n\t}\nclose(LAST);\nreturn @rv;\n}\n\n=head2 user_link(&user)\n\nReturns a link to a user editing form. Mainly for internal use.\n\n=cut\nsub user_link\n{\nif ($_[0]->{'pass'} =~ /^\\Q$disable_string\\E/) {\n\t$dis = \"<i>\".&html_escape($_[0]->{'user'}).\"</i>\";\n\t}\nelse {\n\t$dis = &html_escape($_[0]->{'user'});\n\t}\nif ($_[0]->{'noedit'}) {\n\treturn $dis;\n\t}\nelsif ($_[0]->{'dn'}) {\n\treturn \"<a href='edit_user.cgi?dn=\".&urlize($_[0]->{'dn'}).\"'>\".\n\t       \"$dis</a>\";\n\t}\nelse {\n\treturn \"<a href='edit_user.cgi?num=$_[0]->{'num'}'>\".\n\t       \"$dis</a>\";\n\t}\n}\n\n=head2 group_link(&group)\n\nReturns a link to a group editing form. Mainly for internal use.\n\n=cut\nsub group_link\n{\nif ($_[0]->{'noedit'}) {\n\treturn &html_escape($_[0]->{'group'});\n\t}\nelsif ($_[0]->{'dn'}) {\n\treturn \"<a href='edit_group.cgi?dn=\".&urlize($_[0]->{'dn'}).\"'>\".\n\t       &html_escape($_[0]->{'group'}).\"</a>\";\n\t}\nelse {\n\treturn \"<a href='edit_group.cgi?num=$_[0]->{'num'}'>\".\n\t       &html_escape($_[0]->{'group'}).\"</a>\";\n\t}\n}\n\n=head2 sort_users(&users, mode)\n\nSorts a list of users according to the user's preference for this module,\nand returns the results.\n\n=cut\nsub sort_users\n{\nlocal ($users, $mode) = @_;\nlocal @ulist = @$users;\nif ($mode == 1) {\n\t@ulist = sort { $a->{'user'} cmp $b->{'user'} } @ulist;\n\t}\nelsif ($mode == 2) {\n\t@ulist = sort { lc($a->{'real'}) cmp lc($b->{'real'}) } @ulist;\n\t}\nelsif ($mode == 3) {\n\t@ulist = sort { @wa = split(/\\s+/, $a->{'real'});\n\t\t\t@wb = split(/\\s+/, $b->{'real'});\n\t\t\tlc($wa[@wa-1]) cmp lc($wb[@wb-1]) } @ulist;\n\t}\nelsif ($mode == 4) {\n\t@ulist = sort { $a->{'shell'} cmp $b->{'shell'} } @ulist;\n\t}\nelsif ($mode == 5) {\n\t@ulist = sort { $a->{'uid'} <=> $b->{'uid'} } @ulist;\n\t}\nelsif ($mode == 6) {\n\t@ulist = sort { $a->{'home'} cmp $b->{'home'} } @ulist;\n\t}\nreturn @ulist;\n}\n\n=head2 sort_groups(&groups, mode)\n\nSorts a list of groups according to the user's preference for this module,\nand returns the results.\n\n=cut\nsub sort_groups\n{\nlocal ($groups, $mode) = @_;\nlocal @glist = @$groups;\nif ($mode == 5) {\n\t@glist = sort { $a->{'gid'} <=> $b->{'gid'} } @glist;\n\t}\nelsif ($mode == 1) {\n\t@glist = sort { $a->{'group'} cmp $b->{'group'} } @glist;\n\t}\nreturn @glist;\n}\n\n=head2 create_home_directory(&user, [real-dir])\n\nCreates and chmod's the home directory for a user, or calls error on failure.\n\n=cut\nsub create_home_directory\n{\nlocal ($user, $home) = @_;\n$home ||= $user->{'home'};\n&lock_file($home);\n&make_dir($home, oct($config{'homedir_perms'}), 1) ||\n\t&error(&text('usave_emkdir', $!));\n&set_ownership_permissions($user->{'uid'}, $user->{'gid'},\n\t\t\t   oct($config{'homedir_perms'}), $home) ||\n\t&error(&text('usave_echmod', $!));\nif ($config{'selinux_con'} && &is_selinux_enabled() && &has_command(\"chcon\")) {\n\t&system_logged(\"chcon \".quotemeta($config{'selinux_con'}).\n\t\t       \" \".quotemeta($home).\" >/dev/null 2>&1\");\n\t}\n&unlock_file($home);\n}\n\n=head2 delete_home_directory(&user)\n\nDeletes some users home directory.\n\n=cut\nsub delete_home_directory\n{\nlocal ($user) = @_;\nif ($user->{'home'} && -d $user->{'home'}) {\n\tlocal $realhome = &resolve_links($user->{'home'});\n\tlocal $qhome = quotemeta($realhome);\n\tif ($config{'delete_only'}) {\n\t\t&system_logged(\"find $qhome ! -type d -user $user->{'uid'} | xargs rm -f >/dev/null 2>&1\");\n\t\t&system_logged(\"find $qhome -type d -user $user->{'uid'} | xargs rmdir >/dev/null 2>&1\");\n\t\t&unlink_file($realhome);\n\t\t}\n\telse {\n\t\t&system_logged(\"rm -rf $qhome >/dev/null 2>&1\");\n\t\t}\n\tunlink($user->{'home'});\t# in case of links\n\t}\n}\n\n=head2 supports_temporary_disable\n\nReturns 1 if temporary locking of passwords (with an ! at the start of the\nhash) is supported on this OS.\n\n=cut\nsub supports_temporary_disable\n{\nreturn &passfiles_type() != 7;    # Not on OSX, which has a fixed-size hash\n}\n\n=head2 change_all_home_groups(old-gid, new-gid, &members)\n\nChange the GID on all files in the home directories of users whose GID is the\nold GID.\n\n=cut\nsub change_all_home_groups\n{\nlocal ($oldgid, $gid, $mems) = @_;\n&my_setpwent();\nwhile(my @uinfo = &my_getpwent()) {\n\tif ($uinfo[3] == $oldgid || &indexof($uinfo[0], @$mems) >= 0) {\n\t\t&recursive_change($uinfo[7], -1, $oldgid, -1, $gid);\n\t\t}\n\t}\n&my_endpwent();\n}\n\n=head2 generate_random_password()\n\nReturns a randomly generated 15 character password\n\n=cut\nsub generate_random_password\n{\n&seed_random();\nmy $rv;\nforeach (1 .. 15) {\n\t$rv .= $random_password_chars[rand(scalar(@random_password_chars))];\n\t}\nreturn $rv;\n}\n\n1;\n"], "fixing_code": ["=head1 user-lib.pl\n\nFunctions for Unix user and group management.\n\n foreign_require(\"useradmin\", \"user-lib.pl\");\n @users = useradmin::list_users();\n @groups = useradmin::list_groups();\n ($joe) = grep { $_->{'user'} eq 'joe' } @users;\n if ($joe) {\n   $joe->{'pass'} = useradmin::encrypt_password('smeg');\n   useradmin::making_changes()\n   useradmin::modify_user($joe, $joe);\n   useradmin::made_changes()\n }\n\n=cut\n\nBEGIN { push(@INC, \"..\"); };\nuse WebminCore;\n&init_config();\nif ($gconfig{'os_type'} =~ /-linux$/) {\n\tdo \"linux-lib.pl\";\n\t}\nelse {\n\tdo \"$gconfig{'os_type'}-lib.pl\";\n\t}\ndo \"md5-lib.pl\";\n%access = &get_module_acl();\n\n@random_password_chars = ( 'a' .. 'z', 'A' .. 'Z', '0' .. '9' );\n$disable_string = $config{'lock_prepend'} eq \"\" ? \"!\" : $config{'lock_prepend'};\n\n# Search types\n$match_modes = [ [ 0, $text{'index_equals'} ], [ 4, $text{'index_contains'} ],\n\t\t [ 1, $text{'index_matches'} ], [ 2, $text{'index_nequals'} ],\n\t\t [ 5, $text{'index_ncontains'} ], [ 3, $text{'index_nmatches'}],\n\t\t [ 6, $text{'index_lower'} ], [ 7, $text{'index_higher'} ] ];\n\n=head2 password_file(file)\n\nReturns true if some file looks like a valid Unix password file\n\n=cut\nsub password_file\n{\nif (!$_[0]) { return 0; }\nelsif (&open_readfile(SHTEST, $_[0])) {\n\tlocal($line);\n\t$line = <SHTEST>;\n\tclose(SHTEST);\n\treturn $line =~ /^\\S+:\\S*:/;\n\t}\nelse { return 0; }\n}\n\n=head2 list_users\n\nReturns an array of hash references, each containing info about one user. Each\nhash will always contain the keys :\n\n=item user - The Unix username.\n\n=item pass - Encrypted password, perhaps using MD5 or DES.\n\n=item uid - User's ID.\n\n=item gid - User's primary group's ID.\n\n=item real - Real name for the user. May also contain office phone, home phone and office location, comma-separated.\n\n=item home - User's home directory.\n\n=item shell - Shell command to run when the user logs in.\n\nIn addition, if the system supports shadow passwords it may also have the keys :\n\n=item change - Days since 1970 the password was last changed.\n\n=item min - Days before password may be changed.\n\n=item max - Days after which password must be changed.\n\n=item warn - Days before password is to expire that user is warned.\n\n=item inactive - Days after password expires that account is disabled.\n\n=item expire - Days since Jan 1, 1970 that account is disabled.\n\nOr if it supports FreeBSD master.passwd info, it will also have keys :\n\n=item class - User's login class.\n\n=item change - Unix time at which the password was last changed.\n\n=item expire - Unix time at which the password will expire.\n\n=cut\nsub list_users\n{\nreturn @list_users_cache if (scalar(@list_users_cache));\n\n# read the password file\nlocal (@rv, $_, %idx, $lnum, @pw, $p, $i, $j);\nlocal $pft = &passfiles_type();\nif ($pft == 1) {\n\t# read the master.passwd file only\n\t$lnum = 0;\n\t&open_readfile(PASSWD, $config{'master_file'});\n\twhile(<PASSWD>) {\n\t\ts/\\r|\\n//g;\n\t\tif (/\\S/ && !/^[#\\+\\-]/) {\n\t\t\t@pw = split(/:/, $_, -1);\n\t\t\tpush(@rv, { 'user' => $pw[0],\t'pass' => $pw[1],\n\t\t\t\t    'uid' => $pw[2],\t'gid' => $pw[3],\n\t\t\t\t    'class' => $pw[4],\t'change' => $pw[5],\n\t\t\t\t    'expire' => $pw[6],\t'real' => $pw[7],\n\t\t\t\t    'home' => $pw[8],\t'shell' => $pw[9],\n\t\t\t\t    'line' => $lnum,\t'num' => scalar(@rv) });\n\t\t\t}\n\t\t$lnum++;\n\t\t}\n\tclose(PASSWD);\n\t}\nelsif ($pft == 6) {\n\t# Read netinfo dump\n\t&open_execute_command(PASSWD, \"nidump passwd '$netinfo_domain'\", 1);\n\twhile(<PASSWD>) {\n\t\ts/\\r|\\n//g;\n\t\tif (/\\S/ && !/^[#\\+\\-]/) {\n\t\t\t@pw = split(/:/, $_, -1);\n\t\t\tpush(@rv, { 'user' => $pw[0],\t'pass' => $pw[1],\n\t\t\t\t    'uid' => $pw[2],\t'gid' => $pw[3],\n\t\t\t\t    'class' => $pw[4],\t'change' => $pw[5],\n\t\t\t\t    'expire' => $pw[6],\t'real' => $pw[7],\n\t\t\t\t    'home' => $pw[8],\t'shell' => $pw[9],\n\t\t\t\t    'num' => scalar(@rv) });\n\t\t\t}\n\t\t}\n\tclose(PASSWD);\n\t}\nelsif ($pft == 7) {\n\t# Read directory services dump of users\n\t&open_execute_command(PASSWD,\n\t\t\"dscl '$netinfo_domain' readall /Users\", 1);\n\tlocal $user;\n\tlocal $ls = $config{'lock_string'};\n\twhile(<PASSWD>) {\n\t\ts/\\r|\\n//g;\n\t\tif ($_ eq \"-\") {\n\t\t\t# End of the current user\n\t\t\t$user = undef;\n\t\t\t}\n\t\telsif (/^(\\S+):\\s*(.*)$/) {\n\t\t\t# Value for a user\n\t\t\tif (!$user) {\n\t\t\t\t$user = { 'num' => scalar(@rv) };\n\t\t\t\tpush(@rv, $user);\n\t\t\t\t}\n\t\t\tlocal ($n, $v) = ($1, $2);\n\t\t\tif ($n ne 'RealName' && $v eq '') {\n\t\t\t\t# Multi-line value\n\t\t\t\t$v = <PASSWD>;\n\t\t\t\t$v =~ s/^ //;\n\t\t\t\t}\n\t\t\tlocal $p = $user_properties_map{$n};\n\t\t\tif ($p) {\n\t\t\t\t# Some OSX users have two names, like _foo foo\n\t\t\t\t$v =~ s/\\s.*$// if ($p eq 'user');\n\t\t\t\t$user->{$p} = $v;\n\t\t\t\t}\n\t\t\telsif ($n eq \"GeneratedUID\") {\n\t\t\t\t# Given the UID, we can get the password hash\n\t\t\t\t$user->{'pass'} = &get_macos_password_hash($v);\n\t\t\t\t$user->{'uuid'} = $v;\n\t\t\t\tif (substr($user->{'pass'}, 0,\n\t\t\t\t\t   length($ls)) eq $ls) {\n\t\t\t\t\t# Account locked\n\t\t\t\t\t$user->{'pass'} = $ls;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tclose(PASSWD);\n\t}\nelse {\n\t# start by reading /etc/passwd\n\t$lnum = 0;\n\t&open_readfile(PASSWD, $config{'passwd_file'});\n\twhile(<PASSWD>) {\n\t\ts/\\r|\\n//g;\n\t\tif (/\\S/ && !/^[#\\+\\-]/) {\n\t\t\t@pw = split(/:/, $_, -1);\n\t\t\tpush(@rv, { 'user' => $pw[0],\t'pass' => $pw[1],\n\t\t\t\t    'uid' => $pw[2],\t'gid' => $pw[3],\n\t\t\t\t    'real' => $pw[4],\t'home' => $pw[5],\n\t\t\t\t    'shell' => $pw[6],\t'line' => $lnum,\n\t\t\t\t    'num' => scalar(@rv) });\n\t\t\t$idx{$pw[0]} = $rv[$#rv];\n\t\t\t}\n\t\t$lnum++;\n\t\t}\n\tclose(PASSWD);\n\tif ($pft == 2 || $pft == 5) {\n\t\t# read the shadow file data\n\t\t$lnum = 0;\n\t\t&open_readfile(SHADOW, $config{'shadow_file'});\n\t\twhile(<SHADOW>) {\n\t\t\ts/\\r|\\n//g;\n\t\t\tif (/\\S/ && !/^[#\\+\\-]/) {\n\t\t\t\t@pw = split(/:/, $_, -1);\n\t\t\t\t$p = $idx{$pw[0]};\n\t\t\t\t$p->{'pass'} = $pw[1];\n\t\t\t\t$p->{'change'} = $pw[2] < 0 ? \"\" : $pw[2];\n\t\t\t\t$p->{'min'} = $pw[3] < 0 ? \"\" : $pw[3];\n\t\t\t\t$p->{'max'} = $pw[4] < 0 ? \"\" : $pw[4];\n\t\t\t\t$p->{'warn'} = $pw[5] < 0 ? \"\" : $pw[5];\n\t\t\t\t$p->{'inactive'} = $pw[6] < 0 ? \"\" : $pw[6];\n\t\t\t\t$p->{'expire'} = $pw[7] < 0 ? \"\" : $pw[7];\n\t\t\t\t$p->{'sline'} = $lnum;\n\t\t\t\t}\n\t\t\t$lnum++;\n\t\t\t}\n\t\tclose(SHADOW);\n\t\tfor($i=0; $i<@rv; $i++) {\n\t\t\tif (!defined($rv[$i]->{'sline'})) {\n\t\t\t\t# not in shadow!\n\t\t\t\tfor($j=$i; $j<@rv; $j++) { $rv[$j]->{'num'}--; }\n\t\t\t\tsplice(@rv, $i--, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telsif ($pft == 4) {\n\t\t# read the AIX security passwd file\n\t\tlocal $lastuser;\n\t\tlocal $lnum = 0;\n\t\t&open_readfile(SECURITY, $config{'shadow_file'});\n\t\twhile(<SECURITY>) {\n\t\t\ts/\\s*$//;\n\t\t\tif (/^\\s*(\\S+):/) {\n\t\t\t\t$lastuser = $idx{$1};\n\t\t\t\t$lastuser->{'sline'} = $lnum;\n\t\t\t\t}\n\t\t\telsif (/^\\s*([^=\\s]+)\\s*=\\s*(.*)/) {\n\t\t\t\tif ($1 eq 'password') {\n\t\t\t\t\t$lastuser->{'pass'} = $2;\n\t\t\t\t\t}\n\t\t\t\telsif ($1 eq 'lastupdate') {\n\t\t\t\t\t$lastuser->{'change'} = $2;\n\t\t\t\t\t}\n\t\t\t\telsif ($1 eq 'flags') {\n\t\t\t\t\tmap { $lastuser->{lc($_)}++ }\n\t\t\t\t\t    split(/[,\\s]+/, $2);\n\t\t\t\t\t}\n\t\t\t\t$lastuser->{'seline'} = $lnum;\n\t\t\t\t}\n\t\t\t$lnum++;\n\t\t\t}\n\t\tclose(SECURITY);\n\n\t\t# read the AIX security user file\n\t\t&open_readfile(USER, $config{'aix_user_file'});\n\t\twhile(<USER>) {\n\t\t\ts/\\s*$//;\n\t\t\tif (/^\\s*(\\S+):/) {\n\t\t\t\t$lastuser = $idx{$1};\n\t\t\t\t}\n\t\t\telsif (/^\\s*([^=\\s]+)\\s*=\\s*(.*)/) {\n\t\t\t\tif ($1 eq 'expires') {\n\t\t\t\t\t$lastuser->{'expire'} = $2;\n\t\t\t\t\t}\n\t\t\t\telsif ($1 eq 'minage') {\n\t\t\t\t\t$lastuser->{'min'} = $2;\n\t\t\t\t\t}\n\t\t\t\telsif ($1 eq 'maxage') {\n\t\t\t\t\t$lastuser->{'max'} = $2;\n\t\t\t\t\t}\n\t\t\t\telsif ($1 eq 'pwdwarntime') {\n\t\t\t\t\t$lastuser->{'warn'} = $2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tclose(USER);\n\t\t}\n\t}\n@list_users_cache = @rv;\nreturn @rv;\n}\n\n=head2 create_user(&details)\n\nCreates a new user with the given details, supplied in a hash ref. This must\nbe in the same format as returned by list_users, and must contain at a minimum\nthe user, uid, gid, pass, shell, home and real keys.\n\n=cut\nsub create_user\n{\nlocal $lref;\nlocal $pft = &passfiles_type();\nif ($pft == 1) {\n\t# just need to add to master.passwd\n\t$lref = &read_file_lines($config{'master_file'});\n\t$_[0]->{'line'} = &nis_index($lref);\n\tsplice(@$lref, $_[0]->{'line'}, 0,\n\t       \"$_[0]->{'user'}:$_[0]->{'pass'}:$_[0]->{'uid'}:\".\n\t       \"$_[0]->{'gid'}:$_[0]->{'class'}:$_[0]->{'change'}:\".\n\t       \"$_[0]->{'expire'}:$_[0]->{'real'}:$_[0]->{'home'}:\".\n\t       \"$_[0]->{'shell'}\");\n\tif (scalar(@list_users_cache)) {\n\t\tmap { $_->{'line'}++ if ($_->{'line'} >= $_[0]->{'line'}) }\n\t\t    @list_users_cache;\n\t\t}\n\t}\nelsif ($pft == 3) {\n\t# Just invoke the useradd command\n\t&system_logged(\"useradd -u $_[0]->{'uid'} -g $_[0]->{'gid'} -c \\\"$_[0]->{'real'}\\\" -d $_[0]->{'home'} -s $_[0]->{'shell'} $_[0]->{'user'}\");\n\t# And set the password\n\t&system_logged(\"echo \".quotemeta($_[0]->{'pass'}).\n\t\t       \" | /usr/lib/scoadmin/account/password.tcl \".\n\t\t       \"$_[0]->{'user'} >/dev/null 2>&1\");\n\t}\nelsif ($pft == 6) {\n\t# Use the niutil command\n\t&system_logged(\"niutil -create '$netinfo_domain' '/users/$_[0]->{'user'}'\");\n\t&set_netinfo($_[0]);\n\t}\nelsif ($pft == 7) {\n\t# Add to directory services\n\t&execute_dscl_command(\"create\", \"/Users/$_[0]->{'user'}\");\n\tlocal $out = &execute_dscl_command(\"read\", \"/Users/$_[0]->{'user'}\");\n\tif ($out =~ /GeneratedUID:\\s+(\\S+)/) {\n\t\t$_[0]->{'uuid'} = $1;\n\t\t}\n\t&set_user_dirinfo($_[0]);\n\t}\nelse {\n\t# add to /etc/passwd\n\t$lref = &read_file_lines($config{'passwd_file'});\n\t$_[0]->{'line'} = &nis_index($lref);\n\tif (scalar(@list_users_cache)) {\n\t\tmap { $_->{'line'}++ if ($_->{'line'} >= $_[0]->{'line'}) }\n\t\t    @list_users_cache;\n\t\t}\n\tsplice(@$lref, $_[0]->{'line'}, 0,\n\t       \"$_[0]->{'user'}:\".\n\t       ($pft == 2 || $pft == 5 ? \"x\" : $pft == 4 ? \"!\" :\n\t\t\t$_[0]->{'pass'}).\n\t       \":$_[0]->{'uid'}:$_[0]->{'gid'}:$_[0]->{'real'}:\".\n\t       \"$_[0]->{'home'}:$_[0]->{'shell'}\");\n\tif ($pft == 2 || $pft == 5) {\n\t\t# Find correct place to insert in shadow file\n\t\t$lref = &read_file_lines($config{'shadow_file'});\n\t\t$_[0]->{'sline'} = &nis_index($lref);\n\t\tif (scalar(@list_users_cache)) {\n\t\t\tmap { $_->{'sline'}++\n\t\t\t      if ($_->{'sline'} >= $_[0]->{'sline'}) }\n\t\t\t    @list_users_cache;\n\t\t\t}\n\t\t}\n\tif ($pft == 2) {\n\t\t# add to shadow as well..\n\t\tsplice(@$lref, $_[0]->{'sline'}, 0,\n\t\t       \"$_[0]->{'user'}:$_[0]->{'pass'}:$_[0]->{'change'}:\".\n\t\t       \"$_[0]->{'min'}:$_[0]->{'max'}:$_[0]->{'warn'}:\".\n\t\t       \"$_[0]->{'inactive'}:$_[0]->{'expire'}:\");\n\t\t}\n\telsif ($pft == 5) {\n\t\t# add to SCO shadow file\n\t\tsplice(@$lref, $_[0]->{'sline'}, 0,\n\t       \t    \"$_[0]->{'user'}:$_[0]->{'pass'}:$_[0]->{'change'}:\".\n\t\t    \"$_[0]->{'min'}:$_[0]->{'max'}\");\n\t\t}\n\telsif ($pft == 4) {\n\t\t# add to AIX security passwd file as well..\n\t\tlocal @flags;\n\t\tpush(@flags, 'ADMIN') if ($_[0]->{'admin'});\n\t\tpush(@flags, 'ADMCHG') if ($_[0]->{'admchg'});\n\t\tpush(@flags, 'NOCHECK') if ($_[0]->{'nocheck'});\n\t\t$lref = &read_file_lines($config{'shadow_file'});\n\t\tpush(@$lref, \"\", \"$_[0]->{'user'}:\",\n\t\t\t     \"\\tpassword = $_[0]->{'pass'}\",\n\t\t\t     \"\\tlastupdate = $_[0]->{'change'}\",\n\t\t\t     \"\\tflags = \".join(\",\", @flags));\n\t\t\n\t\t# add to AIX security user file as well..\n\t\t$lref = &read_file_lines($config{'aix_user_file'});\n\t\tif ($_[0]->{'expire'} || $_[0]->{'min'} ||\n\t\t    $_[0]->{'max'} || $_[0]->{'warn'} ) {\n\t\t\tpush(@$lref, \"$_[0]->{'user'}:\");\n\t\t\tpush(@$lref, \"\\texpires = $_[0]->{'expire'}\")\n\t\t\t\tif ($_[0]->{'expire'});\n\t\t\tpush(@$lref, \"\\tminage = $_[0]->{'min'}\")\n\t\t\t\tif ($_[0]->{'min'});\n\t\t\tpush(@$lref, \"\\tmaxage = $_[0]->{'max'}\")\n\t\t\t\tif ($_[0]->{'max'});\n\t\t\tpush(@$lref, \"\\tpwdwarntime = $_[0]->{'warn'}\")\n\t\t\t\tif ($_[0]->{'warn'});\n\t\t\tpush(@$lref, \"\");\n\t\t\t}\n\t\t}\n\t}\n&flush_file_lines() if (!$batch_mode);\npush(@list_users_cache, $_[0]) if (scalar(@list_users_cache));\n&refresh_nscd() if (!$batch_mode);\n}\n\n=head2 modify_user(&old, &details)\n\nUpdate an existing Unix user with new details. The user to change must be\nin &old, and the new values are in &details. These can be references to the\nsame hash if you like.\n\n=cut\nsub modify_user\n{\n$_[0] || &error(\"Missing parameter to modify_user\");\nlocal(@passwd, @shadow, $lref);\nlocal $pft = &passfiles_type();\nif ($pft == 1) {\n\t# just need to update master.passwd\n\t$_[0]->{'line'} =~ /^\\d+$/ || &error(\"Missing user line to modify\");\n\t$lref = &read_file_lines($config{'master_file'});\n\t$lref->[$_[0]->{'line'}] = \n\t      \"$_[1]->{'user'}:$_[1]->{'pass'}:$_[1]->{'uid'}:\".\n\t      \"$_[1]->{'gid'}:$_[1]->{'class'}:$_[1]->{'change'}:\".\n\t      \"$_[1]->{'expire'}:$_[1]->{'real'}:$_[1]->{'home'}:\".\n\t      \"$_[1]->{'shell'}\";\n\t}\nelsif ($pft == 3) {\n\t# Just use the usermod command\n\t&system_logged(\"usermod -u $_[1]->{'uid'} -g $_[1]->{'gid'} -c \\\"$_[1]->{'real'}\\\" -d $_[1]->{'home'} -s $_[1]->{'shell'} $_[1]->{'user'}\");\n\t&system_logged(\"echo \".quotemeta($_[1]->{'pass'}).\" | /usr/lib/scoadmin/account/password.tcl $_[1]->{'user'}\");\n\t}\nelsif ($pft == 6) {\n\t# Just use the niutil command to update\n\tif ($_[0]->{'user'} && $_[0]->{'user'} ne $_[1]->{'user'}) {\n\t\t# Need to delete and re-create!\n\t\t&system_logged(\"niutil -destroy '$netinfo_domain' '/users/$_[0]->{'user'}'\");\n\t\t&system_logged(\"niutil -create '$netinfo_domain' '/users/$_[1]->{'user'}'\");\n\t\t}\n\t&set_netinfo($_[1]);\n\t}\nelsif ($pft == 7) {\n\t# Call directory services to update the user\n\tif ($_[0]->{'user'} && $_[0]->{'user'} ne $_[1]->{'user'}) {\n\t\t# Need to rename\n\t\t&execute_dscl_command(\"change\", \"/Users/$_[0]->{'user'}\",\n\t\t\t      \"RecordName\", $_[0]->{'user'}, $_[1]->{'user'});\n\t\t}\n\t$_[1]->{'uuid'} = $_[0]->{'uuid'};\n\t&set_user_dirinfo($_[1]);\n\t}\nelse {\n\t# update /etc/passwd\n\t$lref = &read_file_lines($config{'passwd_file'});\n\t$_[0]->{'line'} =~ /^\\d+$/ || &error(\"Missing user line to modify\");\n\t$lref->[$_[0]->{'line'}] =\n\t\t\"$_[1]->{'user'}:\".\n\t\t($pft == 2 || $pft == 5 ? \"x\" : $pft == 4 ? \"!\" :\n\t\t $_[1]->{'pass'}).\n\t\t\":$_[1]->{'uid'}:$_[1]->{'gid'}:$_[1]->{'real'}:\".\n\t\t\"$_[1]->{'home'}:$_[1]->{'shell'}\";\n\tif ($pft == 2) {\n\t\t# update shadow file as well..\n\t\t$_[0]->{'sline'} =~ /^\\d+$/ ||\n\t\t\t&error(\"Missing user line to modify\");\n\t\t$lref = &read_file_lines($config{'shadow_file'});\n\t\t$lref->[$_[0]->{'sline'}] =\n\t\t\t\"$_[1]->{'user'}:$_[1]->{'pass'}:$_[1]->{'change'}:\".\n\t\t\t\"$_[1]->{'min'}:$_[1]->{'max'}:$_[1]->{'warn'}:\".\n\t\t\t\"$_[1]->{'inactive'}:$_[1]->{'expire'}:\";\n\t\t}\n\telsif ($pft == 5) {\n\t\t# update SCO shadow\n\t\t$_[0]->{'sline'} =~ /^\\d+$/ ||\n\t\t\t&error(\"Missing user line to modify\");\n\t\t$lref = &read_file_lines($config{'shadow_file'});\n\t\t$lref->[$_[0]->{'sline'}] =\n\t\t   \"$_[1]->{'user'}:$_[1]->{'pass'}:$_[1]->{'change'}:\".\n\t\t   \"$_[1]->{'min'}:$_[1]->{'max'}\";\n\t\t}\n\telsif ($pft == 4) {\n\t\t# update AIX shadow passwd file as well..\n\t\tif (defined($_[0]->{'sline'})) {\n\t\t\tlocal @flags;\n\t\t\tpush(@flags, 'ADMIN') if ($_[1]->{'admin'});\n\t\t\tpush(@flags, 'ADMCHG') if ($_[1]->{'admchg'});\n\t\t\tpush(@flags, 'NOCHECK') if ($_[1]->{'nocheck'});\n\t\t\tlocal $lref = &read_file_lines($config{'shadow_file'});\n\t\t\tsplice(@$lref, $_[0]->{'sline'},\n\t\t\t     $_[0]->{'seline'} - $_[0]->{'sline'} + 1,\n\t\t\t     \"$_[1]->{'user'}:\", \"\\tpassword = $_[1]->{'pass'}\",\n\t\t\t     \"\\tlastupdate = $_[1]->{'change'}\",\n\t\t\t     \"\\tflags = \".join(\",\", @flags));\n\t\t\t&flush_file_lines();\t# have to flush on AIX\n\t\t\t}\n\n\t\t# update AIX security user file as well..\n\t\t# use chuser command because it's easier than working\n\t\t# with the complexity issues of the file.\n\t\t&system_logged(\"chuser expires=$_[1]->{'expire'} minage=$_[1]->{'min'} maxage=$_[1]->{'max'} pwdwarntime=$_[1]->{'warn'} $_[1]->{'user'}\");\n\t\t}\n\t}\nif ($_[0] ne $_[1] && &indexof($_[0], @list_users_cache) != -1) {\n\t# Update old object in cache\n\t$_[1]->{'line'} = $_[0]->{'line'} if (defined($_[0]->{'line'}));\n\t$_[1]->{'uuid'} = $_[0]->{'uuid'} if (defined($_[0]->{'uuid'}));\n\t$_[1]->{'sline'} = $_[0]->{'sline'} if (defined($_[0]->{'sline'}));\n\t$_[1]->{'seline'} = $_[0]->{'seline'} if (defined($_[0]->{'seline'}));\n\t%{$_[0]} = %{$_[1]};\n\t}\nif (!$batch_mode) {\n\t&flush_file_lines();\n\t&refresh_nscd();\n\t}\n}\n\n=head2 delete_user(&details)\n\nDelete an existing user. The &details hash must be user information as\nreturned by list_users.\n\n=cut\nsub delete_user\n{\nlocal $lref;\n$_[0] || &error(\"Missing parameter to delete_user\");\nlocal $pft = &passfiles_type();\nif ($pft == 1) {\n\t# Delete from BSD master.passwd file\n\t$_[0]->{'line'} =~ /^\\d+$/ || &error(\"Missing user line to delete\");\n\t$lref = &read_file_lines($config{'master_file'});\n\tsplice(@$lref, $_[0]->{'line'}, 1);\n\tmap { $_->{'line'}-- if ($_->{'line'} > $_[0]->{'line'}) }\n\t    @list_users_cache;\n\t}\nelsif ($pft == 3) {\n\t# Just invoke the userdel command\n\t&system_logged(\"userdel -n0 $_[0]->{'user'}\");\n\t}\nelsif ($pft == 4) {\n\t# Just invoke the rmuser command\n\t&system_logged(\"rmuser -p $_[0]->{'user'}\");\n\t}\nelsif ($pft == 6) {\n\t# Just delete with the niutil command\n\t&system_logged(\"niutil -destroy '$netinfo_domain' '/users/$_[0]->{'user'}'\");\n\t}\nelsif ($pft == 7) {\n\t# Delete from directory services\n\t&execute_dscl_command(\"delete\", \"/Users/$_[0]->{'user'}\");\n\t}\nelse {\n\t# XXX doesn't delete from AIX file!\n\t$_[0]->{'line'} =~ /^\\d+$/ || &error(\"Missing user line to delete\");\n\t$lref = &read_file_lines($config{'passwd_file'});\n\tsplice(@$lref, $_[0]->{'line'}, 1);\n\tmap { $_->{'line'}-- if ($_->{'line'} > $_[0]->{'line'}) }\n\t    @list_users_cache;\n\tif ($pft == 2 || $pft == 5) {\n\t\tif (defined($_[0]->{'sline'})) {\n\t\t\t$lref = &read_file_lines($config{'shadow_file'});\n\t\t\tsplice(@$lref, $_[0]->{'sline'}, 1);\n\t\t\tmap { $_->{'sline'}--\n\t\t\t\tif ($_->{'sline'} > $_[0]->{'sline'}) }\n\t\t\t    @list_users_cache;\n\t\t\t}\n\t\t}\n\t}\n@list_users_cache = grep { $_->{'user'} ne $_[0]->{'user'} } @list_users_cache\n\tif (scalar(@list_users_cache));\nif (!$batch_mode) {\n\t&flush_file_lines();\n\t&refresh_nscd();\n\t}\n}\n\n=head2 list_groups\n\nReturns a list of all the local groups as an array of hashes. Each will\ncontain the keys :\n\n=item group - The group name.\n\n=item pass - Rarely-used encrypted password, in DES or MD5 format.\n\n=item gid - Unix ID for the group.\n\n=item members - A comma-separated list of secondary group members.\n\n=cut\nsub list_groups\n{\nreturn @list_groups_cache if (scalar(@list_groups_cache));\n\nlocal(@rv, $lnum, $_, %idx, $g, $i, $j, @gr);\n$lnum = 0;\nlocal $gft = &groupfiles_type();\nif ($gft == 5) {\n\t# Get groups from netinfo\n\t&open_execute_command(GROUP, \"nidump group '$netinfo_domain'\", 1);\n\twhile(<GROUP>) {\n\t\ts/\\r|\\n//g;\n\t\tif (/\\S/ && !/^[#\\+\\-]/) {\n\t\t\t@gr = split(/:/, $_, -1);\n\t\t\tpush(@rv, { 'group' => $gr[0],\t'pass' => $gr[1],\n\t\t\t\t    'gid' => $gr[2],\n\t\t\t\t    'members' => join(\",\",split(/\\s+/,$gr[3])),\n\t\t\t\t    'num' => scalar(@rv) });\n\t\t\t}\n\t\t}\n\tclose(GROUP);\n\t}\nelsif ($gft == 7) {\n\t# Read directory services dump of groups\n\t&open_execute_command(PASSWD,\n\t\t\"dscl '$netinfo_domain' readall /Groups\", 1);\n\tlocal $group;\n\twhile(<PASSWD>) {\n\t\ts/\\r|\\n//g;\n\t\tif ($_ eq \"-\") {\n\t\t\t# End of the current group\n\t\t\t$group = undef;\n\t\t\t}\n\t\telsif (/^(\\S+):\\s*(.*)$/) {\n\t\t\t# Value for a group\n\t\t\tif (!$group) {\n\t\t\t\t$group = { 'num' => scalar(@rv) };\n\t\t\t\tpush(@rv, $group);\n\t\t\t\t}\n\t\t\tlocal ($n, $v) = ($1, $2);\n\t\t\tif ($n ne 'GroupMembership' && $v eq '') {\n\t\t\t\t# Multi-line value\n\t\t\t\t$v = <PASSWD>;\n\t\t\t\t$v =~ s/^ //;\n\t\t\t\t}\n\t\t\tlocal $p = $group_properties_map{$n};\n\t\t\tif ($p) {\n\t\t\t\t# Convert spaces in members list to ,\n\t\t\t\t$v =~ s/ /,/g if ($p eq 'members');\n\t\t\t\t# Some OSX groups have two names, like _foo foo\n\t\t\t\t$v =~ s/\\s.*$// if ($p eq 'group');\n\t\t\t\t$group->{$p} = $v;\n\t\t\t\t}\n\t\t\telsif ($n eq \"GeneratedUID\") {\n\t\t\t\t# Given the UUID, we can get the password hash\n\t\t\t\t$group->{'pass'} = &get_macos_password_hash($v);\n\t\t\t\t$group->{'uuid'} = $v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tclose(PASSWD);\n\t}\nelse {\n\t# Read the standard group file\n\t&open_readfile(GROUP, $config{'group_file'});\n\twhile(<GROUP>) {\n\t\ts/\\r|\\n//g;\n\t\tif (/\\S/ && !/^[#\\+\\-]/) {\n\t\t\t@gr = split(/:/, $_, -1);\n\t\t\tpush(@rv, { 'group' => $gr[0],\t'pass' => $gr[1],\n\t\t\t\t    'gid' => $gr[2],\t'members' => $gr[3],\n\t\t\t\t    'line' => $lnum,\t'num' => scalar(@rv) });\n\t\t\t$idx{$gr[0]} = $rv[$#rv];\n\t\t\t}\n\t\t$lnum++;\n\t\t}\n\tclose(GROUP);\n\t}\nif ($gft == 2) {\n\t# read the gshadow file data\n\t$lnum = 0;\n\t&open_readfile(SHADOW, $config{'gshadow_file'});\n\twhile(<SHADOW>) {\n\t\ts/\\r|\\n//g;\n\t\tif (/\\S/ && !/^[#\\+\\-]/) {\n\t\t\t@gr = split(/:/, $_, -1);\n\t\t\t$g = $idx{$gr[0]};\n\t\t\t$g->{'pass'} = $gr[1];\n\t\t\t$g->{'sline'} = $lnum;\n\t\t\t}\n\t\t$lnum++;\n\t\t}\n\tclose(SHADOW);\n\t#for($i=0; $i<@rv; $i++) {\n\t#\tif (!defined($rv[$i]->{'sline'})) {\n\t#\t\t# not in shadow!\n\t#\t\tfor($j=$i; $j<@rv; $j++) { $rv[$j]->{'num'}--; }\n\t#\t\tsplice(@rv, $i--, 1);\n\t#\t\t}\n\t#\t}\n\t}\nelsif ($gft == 4) {\n\t# read the AIX group data\n\tlocal $lastgroup;\n\tlocal $lnum = 0;\n\t&open_readfile(SECURITY, $config{'gshadow_file'});\n\twhile(<SECURITY>) {\n\t\ts/\\s*$//;\n\t\tif (/^\\s*(\\S+):/) {\n\t\t\t$lastgroup = $idx{$1};\n\t\t\t$lastgroup->{'sline'} = $lnum;\n\t\t\t$lastgroup->{'seline'} = $lnum;\n\t\t\t}\n\t\telsif (/^\\s*([^=\\s]+)\\s*=\\s*(.*)/) {\n\t\t\t$lastgroup->{'seline'} = $lnum;\n\t\t\t}\n\t\t$lnum++;\n\t\t}\n\tclose(SECURITY);\n\t}\n@list_groups_cache = @rv;\nreturn @rv;\n}\n\n=head2 create_group(&details)\n\nCreate a new Unix group based on the given hash. Required keys are\ngid - Unix group ID\ngroup - Group name\npass - Encrypted password\nmembers - Comma-separated list of members\n\n=cut\nsub create_group\n{\nlocal $gft = &groupfiles_type();\nif ($gft == 5) {\n\t# Use niutil command\n\t&system_logged(\"niutil -create '$netinfo_domain' '/groups/$_[0]->{'group'}'\");\n\t&set_group_netinfo($_[0]);\n\t}\nelsif ($gft == 7) {\n\t# Use the dscl directory services command\n\t&execute_dscl_command(\"create\", \"/Groups/$_[0]->{'group'}\");\n\t&set_group_dirinfo($_[0]);\n\t}\nelse {\n\t# Update group file(s)\n\tlocal $lref;\n\t$lref = &read_file_lines($config{'group_file'});\n\t$_[0]->{'line'} = &nis_index($lref);\n\tif (scalar(@list_groups_cache)) {\n\t\tmap { $_->{'line'}++ if ($_->{'line'} >= $_[0]->{'line'}) }\n\t\t    @list_groups_cache;\n\t\t}\n\tsplice(@$lref, $_[0]->{'line'}, 0,\n\t       \"$_[0]->{'group'}:\".\n\t       (&groupfiles_type() == 2 ? \"x\" : $_[0]->{'pass'}).\n\t       \":$_[0]->{'gid'}:$_[0]->{'members'}\");\n\tif ($gft == 2) {\n\t\t$lref = &read_file_lines($config{'gshadow_file'});\n\t\t$_[0]->{'sline'} = &nis_index($lref);\n\t\tif (scalar(@list_groups_cache)) {\n\t\t\tmap { $_->{'sline'}++\n\t\t\t      if ($_->{'sline'} >= $_[0]->{'sline'}) }\n\t\t\t    @list_groups_cache;\n\t\t\t}\n\t\tsplice(@$lref, $_[0]->{'sline'}, 0,\n\t\t       \"$_[0]->{'group'}:$_[0]->{'pass'}::$_[0]->{'members'}\");\n\t\t}\n\telsif ($gft == 4) {\n\t\t$lref = &read_file_lines($config{'gshadow_file'});\n\t\t$_[0]->{'sline'} = scalar(@$lref);\n\t\tpush(@$lref, \"\", \"$_[0]->{'group'}:\", \"\\tadmin = false\");\n\t\t}\n\t&flush_file_lines();\n\t}\n&refresh_nscd();\npush(@list_groups_cache, $_[0]) if (scalar(@list_groups_cache));\n}\n\n=head2 modify_group(&old, &details)\n\nUpdate an existing Unix group specified in old based on the given details hash. \nThese can both be references to the same hash if you like. The hash must be\nin the same format as returned by list_groups.\n\n=cut\nsub modify_group\n{\n$_[0] || &error(\"Missing parameter to modify_group\");\nlocal $gft = &groupfiles_type();\nif ($gft == 5) {\n\t# Call niutil to update the group\n\tif ($_[0]->{'group'} && $_[0]->{'group'} ne $_[1]->{'group'}) {\n\t\t# Need to delete and re-create!\n\t\t&system_logged(\"niutil -destroy '$netinfo_domain' '/groups/$_[0]->{'group'}'\");\n\t\t&system_logged(\"niutil -create '$netinfo_domain' '/groups/$_[1]->{'group'}'\");\n\t\t}\n\t&set_group_netinfo($_[1]);\n\t}\nelsif ($gft == 7) {\n\t# Call dscl to update the group\n\tif ($_[0]->{'group'} && $_[0]->{'group'} ne $_[1]->{'group'}) {\n\t\t# Need to rename\n\t\t&execute_dscl_command(\"change\", \"/Groups/$_[0]->{'group'}\",\n\t\t\t      \"RecordName\", $_[0]->{'group'}, $_[1]->{'group'});\n\t\t}\n\t$_[1]->{'uuid'} = $_[0]->{'uuid'};\n\t&set_group_dirinfo($_[1]);\n\t}\nelse {\n\t# Update in files\n\tlocal $gs = (&groupfiles_type() == 2 && $_[0]->{'sline'} ne '');\n\t&replace_file_line($config{'group_file'}, $_[0]->{'line'},\n\t\t   \"$_[1]->{'group'}:\".($gs ? \"x\" : $_[1]->{'pass'}).\n\t\t   \":$_[1]->{'gid'}:$_[1]->{'members'}\\n\");\n\tif ($gs) {\n\t\t&replace_file_line($config{'gshadow_file'}, $_[0]->{'sline'},\n\t\t\t\t   \"$_[1]->{'group'}:$_[1]->{'pass'}::$_[1]->{'members'}\\n\");\n\t\t}\n\telsif (&groupfiles_type() == 4) {\n\t\t&replace_file_line($config{'gshadow_file'},\n\t\t\t\t   $_[0]->{'sline'},\n\t\t\t\t   \"$_[1]->{'group'}:\\n\");\n\t\t}\n\t}\nif ($_[0] ne $_[1] && &indexof($_[0], @list_groups_cache) != -1) {\n\t$_[1]->{'line'} = $_[0]->{'line'} if (defined($_[0]->{'line'}));\n\t$_[1]->{'sline'} = $_[0]->{'sline'} if (defined($_[0]->{'sline'}));\n\t$_[1]->{'uuid'} = $_[0]->{'uuid'} if (defined($_[0]->{'uuid'}));\n\t%{$_[0]} = %{$_[1]};\n\t}\n&refresh_nscd();\n}\n\n=head2 delete_group(&details)\n\nDelete an existing Unix group, whose details are in the hash ref supplied.\n\n=cut\nsub delete_group\n{\n$_[0] || &error(\"Missing parameter to delete_group\");\nlocal $gft = &groupfiles_type();\nif ($gft == 5) {\n\t# Call niutil to delete\n\t&system_logged(\"niutil -destroy '$netinfo_domain' '/groups/$_[0]->{'group'}'\");\n\t}\nelsif ($gft == 7) {\n\t# Delete from directory services\n\t&execute_dscl_command(\"delete\", \"/Groups/$_[0]->{'group'}\");\n\t}\nelse {\n\t# Remove from group file(s)\n\t&replace_file_line($config{'group_file'}, $_[0]->{'line'});\n\tmap { $_->{'line'}-- if ($_->{'line'} > $_[0]->{'line'}) }\n\t    @list_groups_cache;\n\tif ($gft == 2 && $_[0]->{'sline'} ne '') {\n\t\t&replace_file_line($config{'gshadow_file'}, $_[0]->{'sline'});\n\t\tmap { $_->{'sline'}-- if ($_->{'sline'} > $_[0]->{'sline'}) }\n\t\t    @list_groups_cache;\n\t\t}\n\telsif ($gft == 4) {\n\t\tlocal $lref = &read_file_lines($config{'gshadow_file'});\n\t\tsplice(@$lref, $_[0]->{'sline'},\n\t\t       $_[0]->{'seline'} - $_[0]->{'sline'} + 1);\n\t\t&flush_file_lines();\n\t\t}\n\t}\n@list_groups_cache = grep { $_ ne $_[0] } @list_groups_cache\n\tif (scalar(@list_groups_cache));\n&refresh_nscd();\n}\n\n\n=head2 recursive_change(dir, olduid, oldgid, newuid, newgid)\n\nChange the UID or GID of a directory and all files in it, if they match the\ngiven old UID and/or GID. If either of the old IDs are -1, then they are\nignored for match purposes.\n\n=cut\nsub recursive_change\n{\nlocal(@list, $f, @stbuf);\nlocal $real = &translate_filename($_[0]);\n(@stbuf = stat($real)) || return;\n(-l $real) && return;\nif (($_[1] < 0 || $_[1] == $stbuf[4]) &&\n    ($_[2] < 0 || $_[2] == $stbuf[5])) {\n\t# Found match..\n\t&set_ownership_permissions(\n\t\t$_[3] < 0 ? $stbuf[4] : $_[3],\n\t      \t$_[4] < 0 ? $stbuf[5] : $_[4], undef, $_[0]);\n\t}\nif (-d $real) {\n\topendir(DIR, $real);\n\t@list = readdir(DIR);\n\tclosedir(DIR);\n\tforeach $f (@list) {\n\t\tif ($f eq \".\" || $f eq \"..\") { next; }\n\t\t&recursive_change(\"$_[0]/$f\", $_[1], $_[2], $_[3], $_[4]);\n\t\t}\n\t}\n}\n\n=head2 making_changes\n\nMust be called before changes are made to the password or group file.\n\n=cut\nsub making_changes\n{\nif ($config{'pre_command'} =~ /\\S/) {\n\tlocal $out = &backquote_logged(\"($config{'pre_command'}) 2>&1 </dev/null\");\n\treturn $? ? $out : undef;\n\t}\nreturn undef;\n}\n\n=head2 made_changes\n\nMust be called after the password or group file has been changed, to run the\npost-changes command.\n\n=cut\nsub made_changes\n{\nif ($config{'post_command'} =~ /\\S/) {\n\tlocal $out = &backquote_logged(\"($config{'post_command'}) 2>&1 </dev/null\");\n\treturn $? ? $out : undef;\n\t}\nreturn undef;\n}\n\n=head2 other_modules(function, arg, ...)\n\nCall some function in the useradmin_update.pl file in other modules. Should be\ncalled after creating, deleting or modifying a user.\n\n=cut\nsub other_modules\n{\nreturn if (&is_readonly_mode());\t# don't even try other modules\nlocal($m, %minfo);\nlocal $func = shift(@_);\nforeach $m (&get_all_module_infos()) {\n\tlocal $mdir = &module_root_directory($m->{'dir'});\n\tif (&check_os_support($m) &&\n\t    -r \"$mdir/useradmin_update.pl\") {\n\t\t&foreign_require($m->{'dir'}, \"useradmin_update.pl\");\n\t\tlocal $pkg = $m->{'dir'};\n\t\t$pkg =~ s/[^A-Za-z0-9]/_/g;\n\t\tlocal $fullfunc = \"${pkg}::${func}\";\n\t\tif (defined(&$fullfunc)) {\n\t\t\t&foreign_call($m->{'dir'}, $func, @_);\n\t\t\t}\n\t\t}\n\t}\n}\n\n=head2 can_edit_user(&acl, &user)\n\nReturns 1 if the given user hash can be edited by a Webmin user whose access\ncontrol permissions for this module are in the acl parameter.\n\n=cut\nsub can_edit_user\n{\nlocal $m = $_[0]->{'uedit_mode'};\nlocal %u;\nif ($m == 0) { return 1; }\nelsif ($m == 1) { return 0; }\nelsif ($m == 2 || $m == 3 || $m == 5) {\n\tmap { $u{$_}++ } &split_quoted_string($_[0]->{'uedit'});\n\tif ($m == 5 && $_[0]->{'uedit_sec'}) {\n\t\t# Check secondary groups too\n\t\treturn 1 if ($u{$_[1]->{'gid'}});\n\t\tforeach $g (&list_groups()) {\n\t\t\tlocal @m = split(/,/, $g->{'members'});\n\t\t\treturn 1 if ($u{$g->{'gid'}} &&\n\t\t\t\t     &indexof($_[1]->{'user'}, @m) >= 0);\n\t\t\t}\n\t\treturn 0;\n\t\t}\n\telse {\n\t\treturn $m == 2 ? $u{$_[1]->{'user'}} :\n\t\t       $m == 3 ? !$u{$_[1]->{'user'}} :\n\t\t\t\t $u{$_[1]->{'gid'}};\n\t\t}\n\t}\nelsif ($m == 4) {\n\treturn (!$_[0]->{'uedit'} || $_[1]->{'uid'} >= $_[0]->{'uedit'}) &&\n\t       (!$_[0]->{'uedit2'} || $_[1]->{'uid'} <= $_[0]->{'uedit2'});\n\t}\nelsif ($m == 6) {\n\treturn $_[1]->{'user'} eq $remote_user;\n\t}\nelsif ($m == 7) {\n\treturn $_[1]->{'user'} =~ /$_[0]->{'uedit_re'}/;\n\t}\nreturn 0;\n}\n\n=head2 can_edit_group(&acl, &group)\n\nReturns 1 if the given group hash can be edited by a Webmin user whose access\ncontrol permissions for this module are in the acl parameter.\n\n=cut\nsub can_edit_group\n{\nlocal $m = $_[0]->{'gedit_mode'};\nlocal %g;\nif ($m == 0) { return 1; }\nelsif ($m == 1) { return 0; }\nelsif ($m == 2 || $m == 3) {\n\tmap { $g{$_}++ } &split_quoted_string($_[0]->{'gedit'});\n\treturn $m == 2 ? $g{$_[1]->{'group'}}\n\t\t       : !$g{$_[1]->{'group'}};\n\t}\nelse { return (!$_[0]->{'gedit'} || $_[1]->{'gid'} >= $_[0]->{'gedit'}) &&\n\t      (!$_[0]->{'gedit2'} || $_[1]->{'gid'} <= $_[0]->{'gedit2'}); }\n}\n\n=head2 nis_index(&lines)\n\nInternal function to return the line number on which NIS includes start\nin a password or group file.\n\n=cut\nsub nis_index\n{\nlocal $i;\nfor($i=0; $i<@{$_[0]}; $i++) {\n\tlast if ($_[0]->[$i] =~ /^[\\+\\-]/);\n\t}\nreturn $i;\n}\n\n=head2 get_skel_directory(&user, groupname)\n\nReturns the skeleton files directory for some user. The groupname parameter\nmust be the name of his primary group.\n\n=cut\nsub get_skel_directory\n{\nlocal ($user, $groupname) = @_;\nlocal $uf = $config{'user_files'};\nlocal $shell = $user->{'shell'};\n$shell =~ s/^(.*)\\///g;\nif ($groupname ne '') {\n\t$uf =~ s/\\$group/$groupname/g;\n\t}\n$uf =~ s/\\$gid/$user->{'gid'}/g;\n$uf =~ s/\\$shell/$shell/g;\nreturn $uf;\n}\n\n=head2 copy_skel_files(source, dest, uid, gid)\n\nCopies skeleton files from some source directory (such as /etc/skel) to a \ndestination directory, typically a new user's home. The uid and gid are the\nIDs of the new user, which determines file ownership.\n\n=cut\nsub copy_skel_files\n{\nlocal ($f, $df);\nlocal @rv;\nforeach $f (split(/\\s+/, $_[0])) {\n\tif (-d $f) {\n\t\t# copy all files in a directory\n\t\topendir(DIR, $f);\n\t\tforeach $df (readdir(DIR)) {\n\t\t\tif ($df eq \".\" || $df eq \"..\") { next; }\n\t\t\tpush(@rv, &copy_file(\"$f/$df\", $_[1], $_[2], $_[3]));\n\t\t\t}\n\t\tclosedir(DIR);\n\t\t}\n\telsif (-r $f) {\n\t\t# copy just one file\n\t\tpush(@rv, &copy_file($f, $_[1], $_[2], $_[3]));\n\t\t}\n\t}\nreturn @rv;\n}\n\n=head2 copy_file(file, destdir, uid, gid)\n\nCopy a file or directory and chown it, preserving symlinks and special files.\nMainly for internal use by copy_skel_files.\n\n=cut\nsub copy_file\n{\nlocal($base, $subs);\n$_[0] =~ /\\/([^\\/]+)$/; $base = $1;\nif ($config{\"files_remap_$base\"}) {\n\t$base = $config{\"files_remap_$base\"};\n\t}\n$subs = $config{'files_remove'};\n$base =~ s/$subs//g if ($subs);\nlocal ($opts, $nochown);\nlocal @rv = ( \"$_[1]/$base\" );\nif (-b $_[0] || -c $_[0]) {\n\t# Looks like a device file .. re-create it\n\tlocal @st = stat($_[0]);\n\tlocal $maj = int($st[6] / 256);\n\tlocal $min = $st[6] % 256;\n\tlocal $typ = ($st[2] & 00170000) == 0020000 ? 'c' : 'b';\n\t&system_logged(\"mknod \".quotemeta(\"$_[1]/$base\").\" $typ $maj $min\");\n\t&set_ownership_permissions($_[2], $_[3], undef, \"$_[1]/$base\");\n\t$nochown++;\n\t}\nelsif (-l $_[0] && !$config{'copy_symlinks'}) {\n\t# A symlink .. re-create it\n\tlocal $l = readlink($_[0]);\n\t&system_logged(\"ln -s \".quotemeta($l).\" \".quotemeta(\"$_[1]/$base\").\" >/dev/null 2>/dev/null\");\n\t$opts = \"-h\";\n\t}\nelsif (-d $_[0]) {\n\t# A directory .. copy it recursively\n\t&system_logged(\"cp -Rp \".quotemeta($_[0]).\" \".quotemeta(\"$_[1]/$base\").\" >/dev/null 2>/dev/null\");\n\tlocal $glob = \"$_[1]/$base/*\";\n\twhile(1) {\n\t\tlocal @g = glob($glob);\n\t\tif (@g && -r $g[0]) {\n\t\t\tpush(@rv, @g);\n\t\t\t$glob .= \"/*\";\n\t\t\t}\n\t\telse {\n\t\t\tlast;\n\t\t\t}\n\t\t}\n\t}\nelse {\n\t# Just a normal file .. copy it\n\tlocal @st = stat(&translate_filename($_[0]));\n\t&system_logged(\"cp \".quotemeta($_[0]).\" \".quotemeta(\"$_[1]/$base\").\" >/dev/null 2>/dev/null\");\n\t&set_ownership_permissions($_[2], $_[3], $st[2], \"$_[1]/$base\");\n\t$nochown++;\n\t}\n&system_logged(\"chown $opts -R $_[2]:$_[3] \".quotemeta(\"$_[1]/$base\").\n\t       \" >/dev/null 2>/dev/null\") if (!$nochown);\nreturn @rv;\n}\n\n=head2 lock_user_files\n\nLock all password, shadow and group files. Should be called before performing\nany user or group operations.\n\n=cut\nsub lock_user_files\n{\n&lock_file($config{'passwd_file'});\n&lock_file($config{'group_file'});\n&lock_file($config{'shadow_file'});\n&lock_file($config{'gshadow_file'});\n&lock_file($config{'master_file'});\n}\n\n=head2 unlock_user_files\n\nUnlock all password, shadow and group files. Should be called after all user\nor group operations are complete.\n\n=cut\nsub unlock_user_files\n{\n&unlock_file($config{'passwd_file'});\n&unlock_file($config{'group_file'});\n&unlock_file($config{'shadow_file'});\n&unlock_file($config{'gshadow_file'});\n&unlock_file($config{'master_file'});\n}\n\n=head2 my_setpwent\n\nThe same as Perl's setpwent function, but may read from /etc/passwd directly.\n\n=cut\nsub my_setpwent\n{\nif ($config{'from_files'}) {\n\t@setpwent_cache = &list_users();\n\t$setpwent_pos = 0;\n\t}\nelse { return setpwent(); }\n}\n\n=head2 my_getpwent\n\nThe same as Perl's getpwent function, but may read from /etc/passwd directly.\n\n=cut\nsub my_getpwent\n{\nif ($config{'from_files'}) {\n\tmy_setpwent() if (!@setpwent_cache);\n\tif ($setpwent_pos >= @setpwent_cache) {\n\t\treturn wantarray ? () : undef;\n\t\t}\n\telse {\n\t\treturn &pw_user_rv($setpwent_cache[$setpwent_pos++],\n\t\t\t\t   wantarray, 'user');\n\t\t}\n\t}\nelse { return getpwent(); }\n}\n\n=head2 my_endpwent\n\nShould be called when you are done with my_setpwent and my_getpwent.\n\n=cut\nsub my_endpwent\n{\nif ($config{'from_files'}) {\n\tundef(@setpwent_cache);\n\t}\nelsif ($gconfig{'os_type'} eq 'hpux') {\n\t# On hpux, endpwent() can crash perl!\n\treturn 0;\n\t}\nelse { return endpwent(); }\n}\n\n=head2 my_getpwnam(username)\n\nLooks up a user by name, like the getpwnam Perl function, but may read \n/etc/passwd directly.\n\n=cut\nsub my_getpwnam\n{\nif ($config{'from_files'}) {\n\tlocal $u;\n\tforeach $u (&list_users()) {\n\t\treturn &pw_user_rv($u, wantarray, 'uid')\n\t\t\tif ($u->{'user'} eq $_[0]);\n\t\t}\n\treturn wantarray ? () : undef;\n\t}\nelse { return getpwnam($_[0]); }\n}\n\n=head2 my_getpwuid(uid)\n\nLooks up a user by ID, like the getpwnam Perl function, but may read \n/etc/passwd directly.\n\n=cut\nsub my_getpwuid\n{\nif ($config{'from_files'}) {\n\tforeach $u (&list_users()) {\n\t\treturn &pw_user_rv($u, wantarray, 'user')\n\t\t\tif ($u->{'uid'} eq $_[0]);\n\t\t}\n\treturn wantarray ? () : undef;\n\t}\nelse { return getpwuid($_[0]); }\n}\n\n=head2 pw_user_rv(&user, want-array, username-field)\n\nInternal function to convert a user hash reference into a list in the format\nreturn by the getpw* family of functions.\n\n=cut\nsub pw_user_rv\n{\nreturn $_[1] ? ( $_[0]->{'user'}, $_[0]->{'pass'}, $_[0]->{'uid'},\n\t\t $_[0]->{'gid'}, undef, undef, $_[0]->{'real'},\n\t\t $_[0]->{'home'}, $_[0]->{'shell'}, undef ) : $_[0]->{$_[2]};\n}\n\n=head2 my_setgrent\n\nThe same as Perl's setgrent function, but may read from /etc/group directly.\n\n=cut\nsub my_setgrent\n{\nif ($config{'from_files'}) {\n\t@setgrent_cache = &list_groups();\n\t$setgrent_pos = 0;\n\t}\nelse { return setgrent(); }\n}\n\n=head2 my_getgrent\n\nThe same as Perl's getgrent function, but may read from /etc/group directly.\n\n=cut\nsub my_getgrent\n{\nif ($config{'from_files'}) {\n\tmy_setgrent() if (!@setgrent_cache);\n\tif ($setgrent_pos >= @setgrent_cache) {\n\t\treturn ();\n\t\t}\n\telse {\n\t\treturn &gr_group_rv($setgrent_cache[$setgrent_pos++],\n\t\t\t\t    wantarray, 'group');\n\t\t}\n\t}\nelse { return getgrent(); }\n}\n\n=head2 my_endgrent\n\nShould be called when you are done with my_setgrent and my_getgrent.\n\n=cut\nsub my_endgrent\n{\nif ($config{'from_files'}) {\n\tundef(@setgrent_cache);\n\t}\nelsif ($gconfig{'os_type'} eq 'hpux') {\n\t# On hpux, endpwent() can crash perl!\n\treturn 0;\n\t}\nelse { return endgrent(); }\n}\n\n=head2 my_getgrnam(group)\n\nLooks up a group by name, like the Perl getgrnam function.\n\n=cut\nsub my_getgrnam\n{\nif ($config{'from_files'}) {\n\tlocal $g;\n\tforeach $g (&list_groups()) {\n\t\treturn &gr_group_rv($g, wantarray, 'gid')\n\t\t\tif ($g->{'group'} eq $_[0]);\n\t\t}\n\treturn wantarray ? () : undef;\n\t}\nelse { return getgrnam($_[0]); }\n}\n\n=head2 my_getgrgid(gid)\n\nLooks up a group by GID, like the Perl getgrgid function.\n\n=cut\nsub my_getgrgid\n{\nif ($config{'from_files'}) {\n\tforeach $g (&list_groups()) {\n\t\treturn &gr_group_rv($g, wantarray, 'group')\n\t\t\tif ($g->{'gid'} eq $_[0]);\n\t\t}\n\treturn wantarray ? () : undef;\n\t}\nelse { return getgrgid($_[0]); }\n}\n\nsub gr_group_rv\n{\nreturn $_[1] ? ( $_[0]->{'group'}, $_[0]->{'pass'}, $_[0]->{'gid'},\n\t\t $_[0]->{'members'} ) : $_[0]->{$_[2]};\n}\n\n=head2 auto_home_dir(base, username, groupname)\n\nReturns an automatically generated home directory, and creates needed\nparent dirs. The parameters are :\n\n=item base - Base directory, like /home.\n\n=item username - The user's login name.\n\n=item groupname - The user's primary group name.\n\n=cut\nsub auto_home_dir\n{\nlocal $pfx = $_[0] eq \"/\" ? \"/\" : $_[0].\"/\";\nif ($config{'home_style'} == 0) {\n\treturn $pfx.$_[1];\n\t}\nelsif ($config{'home_style'} == 1) {\n\t&mkdir_if_needed($pfx.substr($_[1], 0, 1));\n\treturn $pfx.substr($_[1], 0, 1).\"/\".$_[1];\n\t}\nelsif ($config{'home_style'} == 2) {\n\t&mkdir_if_needed($pfx.substr($_[1], 0, 1));\n\t&mkdir_if_needed($pfx.substr($_[1], 0, 1).\"/\".\n\t\t\t substr($_[1], 0, 2));\n\treturn $pfx.substr($_[1], 0, 1).\"/\".\n\t       substr($_[1], 0, 2).\"/\".$_[1];\n\t}\nelsif ($config{'home_style'} == 3) {\n\t&mkdir_if_needed($pfx.substr($_[1], 0, 1));\n\t&mkdir_if_needed($pfx.substr($_[1], 0, 1).\"/\".\n\t\t\t substr($_[1], 1, 1));\n\treturn $pfx.substr($_[1], 0, 1).\"/\".\n\t       substr($_[1], 1, 1).\"/\".$_[1];\n\t}\nelsif ($config{'home_style'} == 4) {\n\treturn $_[0];\n\t}\nelsif ($config{'home_style'} == 5) {\n\treturn $pfx.$_[2].\"/\".$_[1];\n\t}\n}\n\nsub mkdir_if_needed\n{\n-d $_[0] || &make_dir($_[0], 0755);\n}\n\n=head2 set_netinfo(&user)\n\nUpdate a NetInfo user based on a Webmin user hash. Mainly for internal use.\n\n=cut\nsub set_netinfo\n{\nlocal %u = %{$_[0]};\n&system_logged(\"niutil -createprop '$netinfo_domain' '/users/$u{'user'}' passwd '$u{'pass'}'\");\n&system_logged(\"niutil -createprop '$netinfo_domain' '/users/$u{'user'}' uid '$u{'uid'}'\");\n&system_logged(\"niutil -createprop '$netinfo_domain' '/users/$u{'user'}' gid '$u{'gid'}'\");\n&system_logged(\"niutil -createprop '$netinfo_domain' '/users/$u{'user'}' class '$u{'class'}'\");\n&system_logged(\"niutil -createprop '$netinfo_domain' '/users/$u{'user'}' change '$u{'change'}'\");\n&system_logged(\"niutil -createprop '$netinfo_domain' '/users/$u{'user'}' expire '$u{'expire'}'\");\n&system_logged(\"niutil -createprop '$netinfo_domain' '/users/$u{'user'}' realname '$u{'real'}'\");\n&system_logged(\"niutil -createprop '$netinfo_domain' '/users/$u{'user'}' home '$u{'home'}'\");\n&system_logged(\"niutil -createprop '$netinfo_domain' '/users/$u{'user'}' shell '$u{'shell'}'\");\n}\n\n=head2 set_group_netinfo(&group)\n\nUpdate a NetInfo group based on a Webmin group hash. Mainly for internal use.\n\n=cut\nsub set_group_netinfo\n{\nlocal %g = %{$_[0]};\nlocal $mems = join(\" \", map { \"'$_'\" } split(/,/, $g{'members'}));\n&system_logged(\"niutil -createprop '$netinfo_domain' '/groups/$g{'group'}' gid '$g{'gid'}'\");\n&system_logged(\"niutil -createprop '$netinfo_domain' '/groups/$g{'group'}' passwd '$g{'pass'}'\");\n&system_logged(\"niutil -createprop '$netinfo_domain' '/groups/$g{'group'}' users $mems\");\n}\n\n=head2 set_user_dirinfo(&user)\n\nUpdate a user in OSX directive services based on a Webmin user hash.\nMainly for internal use.\n\n=cut\nsub set_user_dirinfo\n{\nlocal %u = %{$_[0]};\nforeach my $k (keys %user_properties_map) {\n\tlocal $v = $u{$user_properties_map{$k}};\n\tif (defined($v)) {\n\t\t&execute_dscl_command(\"create\", \"/Users/$u{'user'}\", $k, $v);\n\t\t}\n\t}\nif ($u{'passmode'} == 3 && defined($u{'plainpass'}) ||\n    $u{'passmode'} == 0) {\n\t# A new plain password was given - use it\n\t&execute_dscl_command(\"passwd\", \"/Users/$u{'user'}\", $u{'plainpass'});\n\tif ($user->{'uuid'}) {\n\t\t$user->{'pass'} = &get_macos_password_hash($user->{'uuid'});\n\t\t}\n\t}\nelsif ($u{'passmode'} == 4) {\n\t# Explicitly not changed, so do nothing\n\t}\nelsif ($u{'passmode'} == 1 || $u{'pass'} eq $config{'lock_string'}) {\n\t# Account locked - set hash to match\n\t&set_macos_password_hash($u{'uuid'}, $u{'pass'});\n\t}\nelse {\n\t# Has the hash changed?\n\tlocal $oldpass = &get_macos_password_hash($u{'uuid'});\n\tif (defined($oldpass) && $u{'pass'} ne $oldpass) {\n\t\t# Yes .. so set it\n\t\t&set_macos_password_hash($u{'uuid'}, $u{'pass'});\n\t\t}\n\t}\n}\n\n=head2 set_group_dirinfo(&group)\n\nUpdate a group in OSX directive services based on a Webmin group hash.\nMainly for internal use.\n\n=cut\nsub set_group_dirinfo\n{\nlocal %g = %{$_[0]};\n$g{'members'} =~ s/,/ /g;\nforeach my $k (keys %group_properties_map) {\n\tlocal $v = $g{$group_properties_map{$k}};\n\tif (defined($v)) {\n\t\t&execute_dscl_command(\"create\", \"/Groups/$g{'group'}\", $k, $v);\n\t\t}\n\t}\n}\n\n=head2 check_password_restrictions(pass, username)\n\nReturns an error message if the given password fails length and other\nchecks, or undef if it is OK.\n\n=cut\nsub check_password_restrictions\n{\nreturn &text('usave_epasswd_min', $config{'passwd_min'})\n\tif (length($_[0]) < $config{'passwd_min'});\nlocal $re = $config{'passwd_re'};\nreturn &text('usave_epasswd_re', $re)\n\tif ($re && !eval { $_[0] =~ /^$re$/ });\nif ($config{'passwd_same'}) {\n\treturn &text('usave_epasswd_same') if ($_[0] =~ /\\Q$_[1]\\E/i);\n\t}\nif ($config{'passwd_dict'} && $_[0] =~ /^[A-Za-z\\'\\-]+$/ &&\n    (&has_command(\"ispell\") || &has_command(\"spell\"))) {\n\t# Call spell or ispell to check for dictionary words\n\tlocal $temp = &transname();\n\topen(TEMP, \">$temp\");\n\tprint TEMP $_[0],\"\\n\";\n\tclose(TEMP);\n\tif (&has_command(\"ispell\")) {\n\t\topen(SPELL, \"ispell -a <$temp |\");\n\t\twhile(<SPELL>) {\n\t\t\tif (/^(#|\\&|\\?)/) {\n\t\t\t\t$unknown++;\n\t\t\t\t}\n\t\t\t}\n\t\tclose(SPELL);\n\t\t}\n\telse {\n\t\topen(SPELL, \"spell <$temp |\");\n\t\tlocal $line = <SPELL>;\n\t\t$unknown++ if ($line);\n\t\tclose(SPELL);\n\t\t}\n\tunlink($temp);\n\treturn &text('usave_epasswd_dict') if (!$unknown);\n\t}\nif ($config{'passwd_prog'}) {\n\tlocal $out;\n\tif ($config{'passwd_progmode'} == 0) {\n\t\t# Run external validation program with user and password as args\n\t\tlocal $qu = quotemeta($_[1]);\n\t\tlocal $qp = quotemeta($_[0]);\n\t\t$out = &backquote_command(\n\t\t\t\"$config{'passwd_prog'} $qu $qp 2>&1 </dev/null\");\n\t\t}\n\telse {\n\t\t# Run program with password as input on stdin\n\t\tlocal $temp = &transname();\n\t\t&open_tempfile(TEMP, \">$temp\", 0, 1);\n\t\t&print_tempfile(TEMP, $_[1],\"\\n\");\n\t\t&print_tempfile(TEMP, $_[0],\"\\n\");\n\t\t&close_tempfile(TEMP);\n\t\t$out = &backquote_command(\"$config{'passwd_prog'} <$temp 2>&1\");\n\t\t}\n\tif ($?) {\n\t\treturn $out;\n\t\t}\n\t}\nreturn undef;\n}\n\n=head2 check_username_restrictions(username)\n\nReturns an error message if a username fails some restriction, or undef if\nit is OK.\n\n=cut\nsub check_username_restrictions\n{\nif ($config{'max_length'} && length($_[0]) > $config{'max_length'}) {\n\treturn &text('usave_elength', $config{'max_length'});\n\t}\nlocal $re = $config{'username_re'};\nreturn &text('usave_ere', $re)\n\tif ($re && !eval { $_[0] =~ /^$re$/ });\nreturn undef;\n}\n\n=head2 can_use_group(&acl, group)\n\nReturns 1 if some group can be used as a primary or secondary, 0 if not.\n\n=cut\nsub can_use_group\n{\nreturn 1 if ($_[0]->{'ugroups'} eq '*');\nlocal @sp = &split_quoted_string($_[0]->{'ugroups'});\nif ($_[0]->{'uedit_gmode'} == 3) {\n\treturn &indexof($_[1], @sp) < 0;\n\t}\nelsif ($_[0]->{'uedit_gmode'} == 4) {\n\tlocal @ginfo = &my_getgrnam($_[1]);\n\treturn (!$_[0]->{'ugroups'} || $ginfo[2] >= $_[0]->{'ugroups'}) &&\n\t       (!$_[0]->{'ugroups2'} || $ginfo[2] <= $_[0]->{'ugroups2'});\n\t}\nelse {\n\treturn &indexof($_[1], @sp) >= 0;\n\t}\n}\n\n=head2 refresh_nscd\n\nSends a HUP signal to the nscd process, so that any caches are reloaded.\n\n=cut\nsub refresh_nscd\n{\nreturn if ($nscd_not_running);\nif (!&find_byname(\"nscd\")) {\n\t$nscd_not_running++;\n\t}\nelsif ($config{'nscd_restart'}) {\n\t# Run the specified command\n\t&system_logged(\"$config{'nscd_restart'} >/dev/null 2>&1 </dev/null\");\n\t}\nelsif (&has_command(\"nscd\")) {\n\t# Use nscd -i to reload\n\t&system_logged(\"nscd -i group >/dev/null 2>&1 </dev/null\");\n\t&system_logged(\"nscd -i passwd >/dev/null 2>&1 </dev/null\");\n\t}\nelse {\n\t# Send HUP signal\n\tlocal $rv = &kill_byname_logged(\"nscd\", \"HUP\");\n\tif (!$rv) {\n\t\t$nscd_not_running++;\n\t\t}\n\t}\nsleep(1);\t# Give ncsd time to react\n}\n\n=head2 set_user_envs(&user, action, [plainpass], [secondaries], [&olduser], [oldplainpass])\n\nSets up the USERADMIN_ environment variables for a user update of some kind,\nprior to calling making_changes or made_changes. The parameters are :\n\n=item user - User details hash reference, in the same format as returned by list_users.\n\n=item action - Must be one of CREATE_USER, MODIFY_USER or DELETE_USER.\n\n=item plainpass - The user's un-encrypted password, if available.\n\n=item secondaries - An array reference of secondary group names the user is a member of.\n\n=item olduser - When modifying a user, the hash reference of it's old details.\n\n=item oldplainpass - When modifying a user, it's old un-encrypted password, if available.\n\n=cut\nsub set_user_envs\n{\nlocal ($user, $action, $plainpass, $secs, $olduser, $oldpass) = @_;\n&clear_envs();\n$ENV{'USERADMIN_USER'} = $user->{'user'};\n$ENV{'USERADMIN_UID'} = $user->{'uid'};\n$ENV{'USERADMIN_REAL'} = $user->{'real'};\n$ENV{'USERADMIN_SHELL'} = $user->{'shell'};\n$ENV{'USERADMIN_HOME'} = $user->{'home'};\n$ENV{'USERADMIN_GID'} = $user->{'gid'};\nlocal $group = &my_getgrgid($user->{'gid'});\nif ($group) {\n\t$ENV{'USERADMIN_GROUP'} = $group;\n\t}\n$ENV{'USERADMIN_PASS'} = $plainpass if (defined($plainpass));\n$ENV{'USERADMIN_SECONDARY'} = join(\",\", @{$secs}) if (defined($secs));\n$ENV{'USERADMIN_ACTION'} = $action;\n$ENV{'USERADMIN_SOURCE'} = $main::module_name;\nif ($olduser) {\n\t$ENV{'USERADMIN_OLD_USER'} = $user->{'user'};\n\t$ENV{'USERADMIN_OLD_UID'} = $user->{'uid'};\n\t$ENV{'USERADMIN_OLD_REAL'} = $user->{'real'};\n\t$ENV{'USERADMIN_OLD_SHELL'} = $user->{'shell'};\n\t$ENV{'USERADMIN_OLD_HOME'} = $user->{'home'};\n\t$ENV{'USERADMIN_OLD_GID'} = $user->{'gid'};\n\t$ENV{'USERADMIN_OLD_PASS'} = $oldpass if (defined($oldpass));\n\t}\n}\n\n=head2 set_group_envs(&group, action, [&oldgroup])\n\nSets up the USERADMIN_ environment variables for a group update of some kind,\nprior to calling making_changes or made_changes. The parameters are :\n\n=item group - Group details hash reference, in the same format as returned by list_groups.\n\n=item action - Must be one of CREATE_GROUP, MODIFY_GROUP or DELETE_GROUP.\n\n=item oldgroup - When modifying a group, the hash reference of it's old details.\n\n=cut\nsub set_group_envs\n{\nlocal ($group, $action, $oldgroup) = @_;\n&clear_envs();\n$ENV{'USERADMIN_GROUP'} = $group->{'group'};\n$ENV{'USERADMIN_GID'} = $group->{'gid'};\n$ENV{'USERADMIN_MEMBERS'} = $group->{'members'};\n$ENV{'USERADMIN_ACTION'} = $action;\n$ENV{'USERADMIN_SOURCE'} = $main::module_name;\nif ($oldgroup) {\n\t$ENV{'USERADMIN_OLD_GROUP'} = $oldgroup->{'group'};\n\t$ENV{'USERADMIN_OLD_GID'} = $oldgroup->{'gid'};\n\t$ENV{'USERADMIN_OLD_MEMBERS'} = $oldgroup->{'members'};\n\t}\n}\n\n=head2 clear_envs\n\nRemoves all variables set by set_user_envs and set_group_envs.\n\n=cut\nsub clear_envs\n{\nlocal $e;\nforeach $e (keys %ENV) {\n\tdelete($ENV{$e}) if ($e =~ /^USERADMIN_/);\n\t}\n}\n\n=head2 encrypt_password(password, [salt])\n\nEncrypts a password using the encryption format configured for this system.\nIf the salt parameter is given, it will be used for hashing the password -\nthis is typically an already encrypted password, that you want to compare with\nthe result of this function to check that passwords match. If missing, a salt\nwill be randomly generated.\n\n=cut\nsub encrypt_password\n{\nlocal ($pass, $salt) = @_;\nlocal $format = 0;\nif ($gconfig{'os_type'} eq 'macos' && &passfiles_type() == 7) {\n\t# New OSX directory service uses SHA1 for passwords!\n\t$salt ||= chr(int(rand(26))+65).chr(int(rand(26))+65). \n\t\t  chr(int(rand(26))+65).chr(int(rand(26))+65);\n\tif (&check_sha1()) {\n\t\t# Use Digest::SHA1 perl module\n\t\treturn &encrypt_sha1_hash($pass, $salt);\n\t\t}\n\telsif (&has_command(\"openssl\")) {\n\t\t# Use openssl command\n\t\tlocal $temp = &transname();\n\t\t&open_execute_command(OPENSSL, \"openssl dgst -sha1 >$temp\", 0);\n\t\tprint OPENSSL $salt,$pass;\n\t\tclose(OPENSSL);\n\t\tlocal $rv = &read_file_contents($temp);\n\t\t&unlink_file($temp);\n\t\t$rv =~ s/\\r|\\n//g;\n\t\treturn $rv;\n\t\t}\n\telse {\n\t\t&error(\"Either the Digest::SHA1 Perl module or openssl command is needed to hash passwords\");\n\t\t}\n\t}\nelsif ($config{'md5'} == 2) {\n\t# Always use MD5\n\t$format = 1;\n\t}\nelsif ($config{'md5'} == 3) {\n\t# Always use blowfish\n\t$format = 2;\n\t}\nelsif ($config{'md5'} == 4) {\n\t# Always use SHA512\n\t$format = 3;\n\t}\nelsif ($config{'md5'} == 1 && !$config{'skip_md5'}) {\n\t# Up to system\n\t$format = &use_md5() if (defined(&use_md5));\n\t}\n\nif ($no_encrypt_password) {\n\t# Some operating systems don't do any encryption!\n\treturn $pass;\n\t}\nelsif ($format == 1) {\n\t# MD5 encryption is selected .. use it if possible\n\tlocal $err = &check_md5();\n\tif ($err) {\n\t\t&error(&text('usave_edigestmd5',\n\t\t    \"/config.cgi?$module_name\",\n\t\t    \"/cpan/download.cgi?source=3&cpan=$err\", $err));\n\t\t}\n\treturn &encrypt_md5($pass, $salt);\n\t}\nelsif ($format == 2) {\n\t# Blowfish is selected .. use it if possible\n\tlocal $err = &check_blowfish();\n\tif ($err) {\n\t\t&error(&text('usave_edigestblowfish',\n\t\t    \"/config.cgi?$module_name\",\n\t\t    \"/cpan/download.cgi?source=3&cpan=$err\", $err));\n\t\t}\n\treturn &encrypt_blowfish($pass, $salt);\n\t}\nelsif ($format == 3) {\n\t# SHA512 is selected .. use it\n\tlocal $err = &check_sha512();\n\tif ($err) {\n\t\t&error($text{'usave_edigestsha512'});\n\t\t}\n\treturn &encrypt_sha512($pass, $salt);\n\t}\nelse {\n\t# Just do old-style crypt() DES encryption\n\tif ($salt !~ /^[a-z0-9]{2}/i) {\n\t\t# Un-usable non-DES salt\n\t\t$salt = undef;\n\t\t}\n\t$salt ||= chr(int(rand(26))+65) . chr(int(rand(26))+65);\n\treturn &unix_crypt($pass, $salt);\n\t}\n}\n\n=head2 build_user_used([&uid-hash], [&shell-list], [&username-hash])\n\nFills in hashes with used UIDs, shells and usernames, based on existing users.\nUseful for allocating a new UID, with code like :\n\n  my %used;\n  useradmin::build_user_used(\\%used);\n  $newuid = useradmin::allocate_uid(\\%used);\n\n=cut\nsub build_user_used\n{\n&my_setpwent();\nlocal @u;\nwhile(@u = &my_getpwent()) {\n\t$_[0]->{$u[2]}++ if ($_[0]);\n\tpush(@{$_[1]}, $u[8]) if ($_[1] && $u[8]);\n\t$_[2]->{$u[0]}++ if ($_[2]);\n\t}\n&my_endpwent();\nlocal $u;\nforeach $u (&list_users()) {\n\t$_[0]->{$u->{'uid'}}++ if ($_[0]);\n\tpush(@{$_[1]}, $u->{'shell'}) if ($_[1] && $u->{'shell'});\n\t$_[2]->{$u->{'user'}}++ if ($_[2]);\n\t}\n}\n\n=head2 build_group_used([&gid-hash], [&groupname-hash])\n\nFills in hashes with used GIDs and group names, based on existing groups.\nUseful for allocating a new GID, with code like :\n\n  my %used;\n  useradmin::build_group_used(\\%used);\n  $newgid = useradmin::allocate_gid(\\%used);\n\n=cut\nsub build_group_used\n{\n&my_setgrent();\nlocal @g;\nwhile(@g = &my_getgrent()) {\n\t$_[0]->{$g[2]}++ if ($_[0]);\n\t$_[1]->{$g[0]}++ if ($_[1]);\n\t}\n&my_endgrent();\nlocal $g;\nforeach $g (&list_groups()) {\n\t$_[0]->{$g->{'gid'}}++ if ($_[0]);\n\t$_[1]->{$g->{'group'}}++ if ($_[1]);\n\t}\n}\n\n=head2 allocate_uid(&uids-used)\n\nGiven a hash reference whose keys are UIDs already in use, returns a free UID\nsuitable for a new user.\n\n=cut\nsub allocate_uid\n{\nlocal $rv = int($config{'base_uid'} > $access{'lowuid'} ?\n\t\t$config{'base_uid'} : $access{'lowuid'});\nwhile($_[0]->{$rv}) {\n\t$rv++;\n\t}\nreturn $rv;\n}\n\n=head2 allocate_gid(&gids-used)\n\nGiven a hash reference whose keys are GIDs already in use, returns a free GID\nsuitable for a new group.\n\n=cut\nsub allocate_gid\n{\nlocal $rv = int($config{'base_gid'} > $access{'lowgid'} ?\n\t\t$config{'base_gid'} : $access{'lowgid'});\nwhile($_[0]->{$rv}) {\n\t$rv++;\n\t}\nreturn $rv;\n}\n\n=head2 list_allowed_users(&access, &allusers)\n\nReturns a list of users to whom access is allowed. The parameters are :\n\n=item access - A hash reference of Webmin user permissions, such as returned by get_module_acl.\n\n=item allusers - List of all users to filter down.\n\n=cut\nsub list_allowed_users\n{\nlocal %access = %{$_[0]};\nlocal @ulist = @{$_[1]};\nif ($access{'uedit_mode'} == 1) {\n\t@ulist = ();\n\t}\nelsif ($access{'uedit_mode'} == 2) {\n\tlocal %canu;\n\tmap { $canu{$_}++ } &split_quoted_string($access{'uedit'});\n\t@ulist = grep { $canu{$_->{'user'}} } @ulist;\n\t}\nelsif ($access{'uedit_mode'} == 3) {\n\tlocal %cannotu;\n\tmap { $cannotu{$_}++ } &split_quoted_string($access{'uedit'});\n\t@ulist = grep { !$cannotu{$_->{'user'}} } @ulist;\n\t}\nelsif ($access{'uedit_mode'} == 4) {\n\t@ulist = grep {\n\t\t(!$access{'uedit'} || $_->{'uid'} >= $access{'uedit'}) &&\n\t\t(!$access{'uedit2'} || $_->{'uid'} <= $access{'uedit2'})\n\t\t\t} @ulist;\n\t}\nelsif ($access{'uedit_mode'} == 5) {\n\tlocal %cangid;\n\tmap { $cangid{$_}++ } &split_quoted_string($access{'uedit'});\n\tif ($access{'uedit_sec'}) {\n\t\t# Match secondary groups too\n\t\tlocal @glist = &list_groups();\n\t\tlocal (@ucan, $g);\n\t\tforeach $g (@glist) {\n\t\t\tpush(@ucan, split(/,/, $g->{'members'}))\n\t\t\t\tif ($cangid{$g->{'gid'}});\n\t\t\t}\n\t\t@ulist = grep { $cangid{$_->{'gid'}} ||\n\t\t\t\t&indexof($_->{'user'}, @ucan) >= 0 } @ulist;\n\t\t}\n\telse {\n\t\t@ulist = grep { $cangid{$_->{'gid'}} } @ulist;\n\t\t}\n\t}\nelsif ($access{'uedit_mode'} == 6) {\n\t@ulist = grep { $_->{'user'} eq $remote_user } @ulist;\n\t}\nelsif ($access{'uedit_mode'} == 7) {\n\t@ulist = grep { $_->{'user'} =~ /$access{'uedit_re'}/ } @ulist;\n\t}\nelsif ($access{'uedit_mode'} == 8) {\n\t@ulist = grep {\n\t\t(!$access{'uedit'} || $_->{'gid'} >= $access{'uedit'}) &&\n\t\t(!$access{'uedit2'} || $_->{'gid'} <= $access{'uedit2'})\n\t\t\t} @ulist;\n\t}\nif ($access{'view'}) {\n\t# Include non-editable users in results\n\tlocal @rv = @{$_[1]};\n\tlocal $u;\n\tforeach $u (@rv) {\n\t\tif (&indexof($u, @ulist) < 0) {\n\t\t\t$u->{'noedit'} = 1;\n\t\t\t}\n\t\t}\n\treturn @rv;\n\t}\nelse {\n\treturn @ulist;\n\t}\n}\n\n=head2 list_allowed_groups(&access, &allgroups)\n\nReturns a list of groups to whom access is allowed. The parameters are :\n\n=item access - A hash reference of Webmin user permissions, such as returned by get_module_acl.\n\n=item allgroups - List of all Unix groups to filter down.\n\n=cut\nsub list_allowed_groups\n{\nlocal %access = %{$_[0]};\nlocal @glist = @{$_[1]};\nif ($access{'gedit_mode'} == 1) {\n\t@glist = ();\n\t}\nelsif ($access{'gedit_mode'} == 2) {\n\tlocal %cang;\n\tmap { $cang{$_}++ } &split_quoted_string($access{'gedit'});\n\t@glist = grep { $cang{$_->{'group'}} } @glist;\n\t}\nelsif ($access{'gedit_mode'} == 3) {\n\tlocal %cannotg;\n\tmap { $cannotg{$_}++ } &split_quoted_string($access{'gedit'});\n\t@glist = grep { !$cannotg{$_->{'group'}} } @glist;\n\t}\nelsif ($access{'gedit_mode'} == 4) {\n\t@glist = grep {\n\t\t(!$access{'gedit'} || $_->{'gid'} >= $access{'gedit'}) &&\n\t\t(!$access{'gedit2'} || $_->{'gid'} <= $access{'gedit2'})\n\t\t\t} @glist;\n\t}\nif ($access{'view'}) {\n\t# Include non-editable groups in results\n\tlocal @rv = @{$_[1]};\n\tlocal $g;\n\tforeach $g (@rv) {\n\t\tif (&indexof($g, @glist) < 0) {\n\t\t\t$g->{'noedit'} = 1;\n\t\t\t}\n\t\t}\n\treturn @rv;\n\t}\nelse {\n\treturn @glist;\n\t}\n}\n\n=head2 batch_start\n\nTells the create/modify/delete functions to only update files in memory,\nnot on disk.\n\n=cut\nsub batch_start\n{\n$batch_mode = 1;\n}\n\n=head2 batch_end\n\nFlushes any user file changes\n\n=cut\nsub batch_end\n{\n$batch_mode = 0;\n&flush_file_lines();\n&refresh_nscd();\n}\n\n#################################################################\n\nsub mkuid\n{\n#################################################################\n#### \n#### Assumptions:\n#### \n#### This subroutine assumes the usernames are standardized\n#### using the format of 7 characters with 3 letters followed\n#### by 4 digits, or 4 letters followed by 3 digits.  If\n#### uppercase letters are used in the username, they will be\n#### converted to lowercase and this subroutine will generate\n#### a UID number identical to the usernames lowercase\n#### equivalent. \n#### \n#### 3 letters, 4 digits   Lowest possible UID (aaa0000) =   1,000,000\n#### 3 letters, 4 digits Hightest possible UID (zzz9999) = 176,759,999\n#### \n#### 4 letters, 3 digits   Lowest possible UID (aaaa000) = 176,760,000\n#### 4 letters, 3 digits Hightest possible UID (zzzz999) = 633,735,999\n#### \n#################################################################\n    my ${num_let} = 0;\n    foreach (split(//,$_[0])) {\n      ++${num_let} if ( m/[a-z]/i );\n    }\n    if ( length($_[0]) ne 7 ) {\n        print \"ERROR: Number of characters in username $_[0] is not equal to 7\\n\";\n        return -1;\n    }\n    if ( ${num_let} ne 3 && ${num_let} ne 4 ) {\n        print \"ERROR: Number of letters in username $_[0] is not equal to 3 or 4\\n\";\n        return -1;\n    }\n    my ${mkuid_type} = 10 ** ( 7 - ${num_let} );\n    my ${lowlimit} = 1000000;\n    my %letters;\n    my ${icnt} = -1;\n    my ${lowuid};\n    ${lowuid} = ( 26 ** ( ${num_let} - 1 ) * ${lowlimit}/100 ) + ${lowlimit};\n    ${lowuid} = ${lowlimit} if ( ${num_let} eq 3 );\n    my ${base} = 26;\n\n#################################################################\n#### \n#### Establish an associative array containing all the\n#### letters of the alphabet and assign a numeric value\n#### to each letter from 1 - 26.\n#### \n#################################################################\n    $letters{'a'} = ++${icnt};\n    $letters{'b'} = ++${icnt};\n    $letters{'c'} = ++${icnt};\n    $letters{'d'} = ++${icnt};\n    $letters{'e'} = ++${icnt};\n    $letters{'f'} = ++${icnt};\n    $letters{'g'} = ++${icnt};\n    $letters{'h'} = ++${icnt};\n    $letters{'i'} = ++${icnt};\n    $letters{'j'} = ++${icnt};\n    $letters{'k'} = ++${icnt};\n    $letters{'l'} = ++${icnt};\n    $letters{'m'} = ++${icnt};\n    $letters{'n'} = ++${icnt};\n    $letters{'o'} = ++${icnt};\n    $letters{'p'} = ++${icnt};\n    $letters{'q'} = ++${icnt};\n    $letters{'r'} = ++${icnt};\n    $letters{'s'} = ++${icnt};\n    $letters{'t'} = ++${icnt};\n    $letters{'u'} = ++${icnt};\n    $letters{'v'} = ++${icnt};\n    $letters{'w'} = ++${icnt};\n    $letters{'x'} = ++${icnt};\n    $letters{'y'} = ++${icnt};\n    $letters{'z'} = ++${icnt};\n\n#################################################################\n#### \n#### Initialize variables to be use while calculating the UID\n#### number associated with the login name.\n#### \n#### nvalue is used to store numeric characters that occurs\n####     in the login name\n#### ecnt is used to keep track of the base 26 exponent for \n####     each letter character that occurs in the login name\n#### subtot is the sum of the calculated value for each\n####     character position in the login name\n#### mult is the total of the 26 ** ecnt at each iteration of \n####     the loop\n#### \n#################################################################\n    my ${kstring} = '';\n    my ${nvalue} = '';\n    my ${lvalue} = 0;\n    my ${ecnt} = 0;\n    my ${subtot} = 0;\n    my ${tot} = 0;\n    my ${mult} = 0;\n#################################################################\n#### \n#### each character position of the login name is split out\n#### and used as an iteration of the foreach loop\n#### \n#################################################################\n\n    foreach (split(//,$_[0])) {\n\n#################################################################\n#### \n#### If the current character of the login name is a letter,\n#### convert it to lower case, and obtain it's numeric value\n#### from the associative array of letters, otherwise, if the\n#### current character is a number, append the number to the\n#### end of a buffer and save it for later processing.\n#### \n#################################################################\n      if ( m/[a-z]/i ) {\n        $kstring = \"\\L${_}\";\n        ${lvalue} = ${letters{${kstring}}};\n      } else {\n        ${lvalue} = 0;\n        ${nvalue} = \"${nvalue}${_}\";\n      }\n#################################################################\n#### Calculate the multiplier for a base 26 calculation using\n#### each iteration through the foreach loop as an increment\n#### of the exponent.  The base 26 exponent starting at 0.\n#################################################################\n\n      ${mult} = ${base} ** ${ecnt};\n\n#################################################################\n#### \n#### Multiply the numeric value of the current character by\n#### the multiplier and add this result to a running subtotal\n#### of all characters of the login name.\n#### \n#################################################################\n      ${subtot} = ${subtot} + ( ${lvalue} * ${mult} );\n\n#################################################################\n#### \n#### Increment the base 26 exponent by one before iterating for\n#### the next character of the login name.\n#### \n#################################################################\n      ++${ecnt}\n    }\n\n#################################################################\n#### \n#### After all characters of the login name have be processed,\n#### multiply the result by 1,000.  This is done because the \n#### username standard is 3 letters followed by 4 digits.  So\n#### each 3 letter combination can have 1,000 possible combinations.\n#### Then add the numeric values saved and any value to use\n#### as the lowest UID number allowed through this calculated method.\n#### \n#################################################################\n\n    ${tot} = ( ${subtot} * ${mkuid_type} ) + int(${nvalue}) + ${lowuid};\n\n#################################################################\n#### \n#### Return the calculated UID number as the result of this\n#### subroutine.\n#### \n#################################################################\n\n    return ${tot};\n}\n################################################################\nsub berkeley_cksum {\n    my($crc) = my($len) = 0;\n    my($buf,$num,$i);\n    my($buflen) = 4096; # buffer is \"4k\", you can up it if you want...\n\n    $buf = $_[0];\n    $num = length($buf);\n\n    $len += $num;\n    foreach ( unpack(\"C*\", $buf) ) {\n        $crc |= 0x10000 if ( $crc & 1 ); # get ready for rotating the 1 below\n        $crc = (($crc>>1)+$_) & 0xffff; # keep to 16-bit\n    }\n    return sprintf(\"%lu\",${crc});;\n}\n\n=head2 users_table(&users, [form], [no-last], [no-boxes], [&otherlinks], [&rightlinks])\n\nPrints a table listing full user details, with checkboxes and buttons to\ndelete or disable multiple at once.\n\n=cut\nsub users_table\n{\nlocal ($users, $formno, $nolast, $noboxes, $links, $rightlinks) = @_;\n\nlocal (@ginfo, %gidgrp);\n&my_setgrent();\nwhile(@ginfo = &my_getgrent()) {\n\t$gidgrp{$ginfo[2]} = $ginfo[0];\n\t}\n&my_endgrent();\n\n# Work out if any users can be edited\nlocal $anyedit;\nforeach my $u (@$users) {\n\tif (!$u->{'noedit'}) {\n\t\t$anyedit = 1;\n\t\tlast;\n\t\t}\n\t}\n$anyedit = 0 if ($noboxes);\nlocal $lshow = !$nolast && $config{'last_show'};\n\nlocal $buttons;\n$buttons .= &ui_submit($text{'index_mass'}, \"delete\") if ($access{'udelete'});\n$buttons .= &ui_submit($text{'index_mass2'}, \"disable\");\n$buttons .= &ui_submit($text{'index_mass3'}, \"enable\");\n$buttons .= \"<br>\" if ($buttons);\nlocal @linksrow;\nif ($anyedit) {\n\tprint &ui_form_start(\"mass_delete_user.cgi\", \"post\");\n\tpush(@linksrow, &select_all_link(\"d\", $_[1]),\n\t\t\t&select_invert_link(\"d\", $_[1]));\n\t}\npush(@linksrow, @$links);\nlocal @grid = ( &ui_links_row(\\@linksrow), &ui_links_row($rightlinks) );\nprint &ui_grid_table(\\@grid, 2, 100, [ \"align=left\", \"align=right\" ]);\n\nlocal @tds = $anyedit ? ( \"width=5\" ) : ( );\npush(@tds, \"width=15%\", \"width=10%\");\nprint &ui_columns_start([\n\t$anyedit ? ( \"\" ) : ( ),\n\t$text{'user'},\n\t$text{'uid'},\n\t$text{'gid'},\n\t$text{'real'},\n\t$text{'home'},\n\t$text{'shell'},\n\t$lshow ? ( $text{'lastlogin'} ) : ( )\n\t], 100, 0, \\@tds);\nlocal %llogin;\nif ($lshow) {\n\tlocal $l;\n\tforeach $l (&list_last_logins()) {\n\t\t$llogin{$l->[0]} ||= $l->[3];\n\t\t}\n\t}\nlocal $u;\nforeach $u (@$users) {\n\t$u->{'real'} =~ s/,.*$// if ($config{'extra_real'} ||\n\t\t\t\t     $u->{'real'} =~ /,$/);\n\tlocal @cols;\n\tpush(@cols, \"\") if ($anyedit && $u->{'noedit'});\n\tpush(@cols, &user_link($u));\n\tpush(@cols, $u->{'uid'});\n\tpush(@cols, $gidgrp{$u->{'gid'}} || $u->{'gid'});\n\tpush(@cols, &html_escape($u->{'real'}));\n\tpush(@cols, &html_escape($u->{'home'}));\n\tpush(@cols, &html_escape($u->{'shell'}));\n\tpush(@cols, &html_escape($llogin{$u->{'user'}})) if ($lshow);\n\tif ($u->{'noedit'}) {\n\t\tprint &ui_columns_row(\\@cols, \\@tds);\n\t\t}\n\telse {\n\t\tprint &ui_checked_columns_row(\\@cols, \\@tds, \"d\", $u->{'user'});\n\t\t}\n\t}\nprint &ui_columns_end();\nprint &ui_links_row(\\@linksrow);\nif ($anyedit) {\n\tprint $buttons;\n\tprint &ui_form_end();\n\t}\n}\n\n=head2 groups_table(&groups, [form], [no-buttons], [&otherlinks], [&rightlinks])\n\nPrints a table of groups, possibly with checkboxes and a delete button\n\n=cut\nsub groups_table\n{\nlocal ($groups, $formno, $noboxes, $links, $rightlinks) = @_;\n\n# Work out if any groups can be edited or have descriptions\nlocal $anyedit;\nlocal $anydesc;\nforeach my $g (@$groups) {\n\tif (!$g->{'noedit'}) {\n\t\t$anyedit = 1;\n\t\t}\n\tif ($g->{'desc'}) {\n\t\t$anydesc = 1;\n\t\t}\n\t}\n$anyedit = 0 if ($noboxes);\n\nlocal @linksrow;\nif ($anyedit && $access{'gdelete'}) {\n\tprint &ui_form_start(\"mass_delete_group.cgi\", \"post\");\n\tpush(@linksrow, &select_all_link(\"gd\", $formno),\n\t\t\t&select_invert_link(\"gd\", $formno) );\n\t}\npush(@linksrow, @$links);\nlocal @grid = ( &ui_links_row(\\@linksrow), &ui_links_row($rightlinks) );\nprint &ui_grid_table(\\@grid, 2, 100, [ \"align=left\", \"align=right\" ]);\n\nlocal @tds = $anyedit ? ( \"width=5\" ) : ( );\npush(@tds, \"width=15%\", \"width=10%\");\nprint &ui_columns_start([\n\t$anyedit ? ( \"\" ) : ( ),\n\t$text{'gedit_group'},\n\t$text{'gedit_gid'},\n\t$anydesc ? ( $text{'gedit_desc'} ) : ( ),\n\t$text{'gedit_members'} ], 100, 0, \\@tds);\nlocal $g;\nforeach $g (@$groups) {\n\tlocal $members = join(\" \", split(/,/, $g->{'members'}));\n\tlocal @cols;\n\tif ($anyedit && ($g->{'noedit'} || !$access{'gdelete'})) {\n\t\t# Need an explicity blank first column\n\t\tpush(@cols, \"\");\n\t\t}\n\tpush(@cols, &group_link($g));\n\tpush(@cols, $g->{'gid'});\n\tif ($anydesc) {\n\t\tpush(@cols, &html_escape($g->{'desc'}));\n\t\t}\n\tpush(@cols, &html_escape($members));\n\tif ($g->{'noedit'} || !$access{'gdelete'}) {\n\t\tprint &ui_columns_row(\\@cols, \\@tds);\n\t\t}\n\telse {\n\t\tprint &ui_checked_columns_row(\\@cols, \\@tds, \"gd\",\n\t\t\t\t\t      $g->{'group'});\n\t\t}\n\t}\nprint &ui_columns_end();\nprint &ui_links_row(\\@linksrow);\nif ($anyedit && $access{'gdelete'}) {\n\tprint &ui_submit($text{'index_gmass'}, \"delete\"),\"<br>\\n\";\n\tprint &ui_form_end();\n\t}\n}\n\n=head2 date_input(day, month, year, prefix)\n\nReturns HTML for selecting a date\n\n=cut\nsub date_input\n{\nlocal ($d, $m, $y, $prefix) = @_;\nlocal $rv;\n$rv .= &ui_textbox($prefix.\"d\", $d, 3).\"/\";\n$rv .= &ui_select($prefix.\"m\", $m,\n\t\t[ map { [ $_, $text{\"smonth_\".$_} ] } (1..12) ]).\"/\";\n$rv .= &ui_textbox($prefix.\"y\", $y, 5);\n$rv .= &date_chooser_button($prefix.\"d\", $prefix.\"m\", $prefix.\"y\");\nreturn $rv;\n}\n\n=head2 list_last_logins([user], [max])\n\nReturns a list of array references, each containing the details of a login.\n\n=cut\nsub list_last_logins\n{\nlocal @rv;\n&open_last_command(LAST, $_[0]);\nwhile(@last = &read_last_line(LAST)) {\n\tpush(@rv, [ @last ]);\n\tif ($_[1] && scalar(@rv) >= $_[1]) {\n\t\tlast;\t# reached max\n\t\t}\n\t}\nclose(LAST);\nreturn @rv;\n}\n\n=head2 user_link(&user)\n\nReturns a link to a user editing form. Mainly for internal use.\n\n=cut\nsub user_link\n{\nif ($_[0]->{'pass'} =~ /^\\Q$disable_string\\E/) {\n\t$dis = \"<i>\".&html_escape($_[0]->{'user'}).\"</i>\";\n\t}\nelse {\n\t$dis = &html_escape($_[0]->{'user'});\n\t}\nif ($_[0]->{'noedit'}) {\n\treturn $dis;\n\t}\nelsif ($_[0]->{'dn'}) {\n\treturn \"<a href='edit_user.cgi?dn=\".&urlize($_[0]->{'dn'}).\"'>\".\n\t       \"$dis</a>\";\n\t}\nelse {\n\treturn \"<a href='edit_user.cgi?num=$_[0]->{'num'}'>\".\n\t       \"$dis</a>\";\n\t}\n}\n\n=head2 group_link(&group)\n\nReturns a link to a group editing form. Mainly for internal use.\n\n=cut\nsub group_link\n{\nif ($_[0]->{'noedit'}) {\n\treturn &html_escape($_[0]->{'group'});\n\t}\nelsif ($_[0]->{'dn'}) {\n\treturn \"<a href='edit_group.cgi?dn=\".&urlize($_[0]->{'dn'}).\"'>\".\n\t       &html_escape($_[0]->{'group'}).\"</a>\";\n\t}\nelse {\n\treturn \"<a href='edit_group.cgi?num=$_[0]->{'num'}'>\".\n\t       &html_escape($_[0]->{'group'}).\"</a>\";\n\t}\n}\n\n=head2 sort_users(&users, mode)\n\nSorts a list of users according to the user's preference for this module,\nand returns the results.\n\n=cut\nsub sort_users\n{\nlocal ($users, $mode) = @_;\nlocal @ulist = @$users;\nif ($mode == 1) {\n\t@ulist = sort { $a->{'user'} cmp $b->{'user'} } @ulist;\n\t}\nelsif ($mode == 2) {\n\t@ulist = sort { lc($a->{'real'}) cmp lc($b->{'real'}) } @ulist;\n\t}\nelsif ($mode == 3) {\n\t@ulist = sort { @wa = split(/\\s+/, $a->{'real'});\n\t\t\t@wb = split(/\\s+/, $b->{'real'});\n\t\t\tlc($wa[@wa-1]) cmp lc($wb[@wb-1]) } @ulist;\n\t}\nelsif ($mode == 4) {\n\t@ulist = sort { $a->{'shell'} cmp $b->{'shell'} } @ulist;\n\t}\nelsif ($mode == 5) {\n\t@ulist = sort { $a->{'uid'} <=> $b->{'uid'} } @ulist;\n\t}\nelsif ($mode == 6) {\n\t@ulist = sort { $a->{'home'} cmp $b->{'home'} } @ulist;\n\t}\nreturn @ulist;\n}\n\n=head2 sort_groups(&groups, mode)\n\nSorts a list of groups according to the user's preference for this module,\nand returns the results.\n\n=cut\nsub sort_groups\n{\nlocal ($groups, $mode) = @_;\nlocal @glist = @$groups;\nif ($mode == 5) {\n\t@glist = sort { $a->{'gid'} <=> $b->{'gid'} } @glist;\n\t}\nelsif ($mode == 1) {\n\t@glist = sort { $a->{'group'} cmp $b->{'group'} } @glist;\n\t}\nreturn @glist;\n}\n\n=head2 create_home_directory(&user, [real-dir])\n\nCreates and chmod's the home directory for a user, or calls error on failure.\n\n=cut\nsub create_home_directory\n{\nlocal ($user, $home) = @_;\n$home ||= $user->{'home'};\n&lock_file($home);\n&make_dir($home, oct($config{'homedir_perms'}), 1) ||\n\t&error(&text('usave_emkdir', $!));\n&set_ownership_permissions($user->{'uid'}, $user->{'gid'},\n\t\t\t   oct($config{'homedir_perms'}), $home) ||\n\t&error(&text('usave_echmod', $!));\nif ($config{'selinux_con'} && &is_selinux_enabled() && &has_command(\"chcon\")) {\n\t&system_logged(\"chcon \".quotemeta($config{'selinux_con'}).\n\t\t       \" \".quotemeta($home).\" >/dev/null 2>&1\");\n\t}\n&unlock_file($home);\n}\n\n=head2 delete_home_directory(&user)\n\nDeletes some users home directory.\n\n=cut\nsub delete_home_directory\n{\nlocal ($user) = @_;\nif ($user->{'home'} && -d $user->{'home'}) {\n\tlocal $realhome = &resolve_links($user->{'home'});\n\tlocal $qhome = quotemeta($realhome);\n\tif ($config{'delete_only'}) {\n\t\t&system_logged(\"find $qhome ! -type d -user $user->{'uid'} | xargs rm -f >/dev/null 2>&1\");\n\t\t&system_logged(\"find $qhome -type d -user $user->{'uid'} | xargs rmdir >/dev/null 2>&1\");\n\t\t&unlink_file($realhome);\n\t\t}\n\telse {\n\t\t&system_logged(\"rm -rf $qhome >/dev/null 2>&1\");\n\t\t}\n\tunlink($user->{'home'});\t# in case of links\n\t}\n}\n\n=head2 supports_temporary_disable\n\nReturns 1 if temporary locking of passwords (with an ! at the start of the\nhash) is supported on this OS.\n\n=cut\nsub supports_temporary_disable\n{\nreturn &passfiles_type() != 7;    # Not on OSX, which has a fixed-size hash\n}\n\n=head2 change_all_home_groups(old-gid, new-gid, &members)\n\nChange the GID on all files in the home directories of users whose GID is the\nold GID.\n\n=cut\nsub change_all_home_groups\n{\nlocal ($oldgid, $gid, $mems) = @_;\n&my_setpwent();\nwhile(my @uinfo = &my_getpwent()) {\n\tif ($uinfo[3] == $oldgid || &indexof($uinfo[0], @$mems) >= 0) {\n\t\t&recursive_change($uinfo[7], -1, $oldgid, -1, $gid);\n\t\t}\n\t}\n&my_endpwent();\n}\n\n=head2 generate_random_password()\n\nReturns a randomly generated 15 character password\n\n=cut\nsub generate_random_password\n{\n&seed_random();\nmy $rv;\nforeach (1 .. 15) {\n\t$rv .= $random_password_chars[rand(scalar(@random_password_chars))];\n\t}\nreturn $rv;\n}\n\n1;\n"], "filenames": ["useradmin/user-lib.pl"], "buggy_code_start_loc": [2319], "buggy_code_end_loc": [2391], "fixing_code_start_loc": [2319], "fixing_code_end_loc": [2391], "type": "CWE-79", "message": "Cross-site scripting (XSS) vulnerability in Webmin 1.540 and earlier allows local users to inject arbitrary web script or HTML via a chfn command that changes the real (aka Full Name) field, related to useradmin/index.cgi and useradmin/user-lib.pl.", "other": {"cve": {"id": "CVE-2011-1937", "sourceIdentifier": "secalert@redhat.com", "published": "2011-05-31T20:55:05.173", "lastModified": "2011-09-22T03:31:09.443", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Cross-site scripting (XSS) vulnerability in Webmin 1.540 and earlier allows local users to inject arbitrary web script or HTML via a chfn command that changes the real (aka Full Name) field, related to useradmin/index.cgi and useradmin/user-lib.pl."}, {"lang": "es", "value": "Vulnerabilidad de secuencias de comandos en sitios cruzados (XSS) en Webmin 1.540 y versiones anteriores permite a usuarios remotos inyectar codigo de script web o c\u00f3digo HTML de su elecci\u00f3n a trav\u00e9s de un comando chfn que modifica el campo real (Full Name). Relacionado con useradmin/index.cgi y useradmin/user-lib.pl."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.540", "matchCriteriaId": "99196F59-548C-40FD-9EA7-6200901120E6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:0.75:*:*:*:*:*:*:*", "matchCriteriaId": "180192C4-DDF9-4278-A213-24A91137D4FA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:0.76:*:*:*:*:*:*:*", "matchCriteriaId": "F05CF0BA-0606-42E5-A631-D302FF1D59F0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:0.77:*:*:*:*:*:*:*", "matchCriteriaId": "6A79B7B3-708A-42E4-B4EF-7746F6292DB5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:0.78:*:*:*:*:*:*:*", "matchCriteriaId": "E2F06BC0-0418-4A1C-BD4A-B7429A6CEA39"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:0.79:*:*:*:*:*:*:*", "matchCriteriaId": "1817FDA9-31F4-4D4A-A867-386D2F1CDB1C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:0.80:*:*:*:*:*:*:*", "matchCriteriaId": "23522A64-FD03-4C5B-9A8A-5E7CDDC65CEE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:0.81:*:*:*:*:*:*:*", "matchCriteriaId": "192B0ED0-5967-4169-A644-1DAB8D4BF981"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:0.82:*:*:*:*:*:*:*", "matchCriteriaId": "E2B5EE2D-9105-4BD5-B298-34DFB332A728"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:0.83:*:*:*:*:*:*:*", "matchCriteriaId": "DFD94AA9-CABA-4FC8-8367-D5D9D8B4F623"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:0.84:*:*:*:*:*:*:*", "matchCriteriaId": "35B136CA-47BF-46DE-885A-9E74EBDE5306"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:0.85:*:*:*:*:*:*:*", "matchCriteriaId": "E9A3F522-6E6D-446C-8694-7AE91F19F1C7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:0.86:*:*:*:*:*:*:*", "matchCriteriaId": "B9B426CD-5105-4EDE-8ED5-991C6B712DF4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:0.87:*:*:*:*:*:*:*", "matchCriteriaId": "FE21BBCF-6F4B-4EEA-B80B-2AE46B6FB2ED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:0.88:*:*:*:*:*:*:*", "matchCriteriaId": "DBB86BC7-4A99-4C5B-9460-CDDA7C4E4041"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:0.91:*:*:*:*:*:*:*", "matchCriteriaId": "0B0813F3-1886-481E-8822-4BD199C4934F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:0.92:*:*:*:*:*:*:*", "matchCriteriaId": "6D25A7CA-ED9D-4562-8965-D4906D1BE5FA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:0.93:*:*:*:*:*:*:*", "matchCriteriaId": "C1F2D028-F2F9-4CE0-A24B-7DB44D488D4E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:0.94:*:*:*:*:*:*:*", "matchCriteriaId": "82EE7A9B-5688-4933-95B9-476873D44A65"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:0.950:*:*:*:*:*:*:*", "matchCriteriaId": "08068E84-9EE5-4742-B70A-567CD4199604"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:0.960:*:*:*:*:*:*:*", "matchCriteriaId": "5C6D5F6A-B34F-4134-959F-C31FC84EBCF9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:0.970:*:*:*:*:*:*:*", "matchCriteriaId": "DB4FEC51-DD03-418D-8E55-CEE696BE2D74"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:0.980:*:*:*:*:*:*:*", "matchCriteriaId": "4B9F8F43-F9EC-4BC0-BDF6-EC3EDF5A71F4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:0.990:*:*:*:*:*:*:*", "matchCriteriaId": "DB6865E9-F244-4019-AA4C-3DB1655A6AA0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.000:*:*:*:*:*:*:*", "matchCriteriaId": "17054066-DE7F-4BE7-A2DA-9426DE6B7D3E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.010:*:*:*:*:*:*:*", "matchCriteriaId": "8C04909C-17D9-46FF-BCCF-45F2531A1B6A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.020:*:*:*:*:*:*:*", "matchCriteriaId": "4B12A859-CFE1-46B7-B607-AF5BB6F5A081"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.030:*:*:*:*:*:*:*", "matchCriteriaId": "860599C2-ED30-454A-8ABA-D62F6019D1E1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.040:*:*:*:*:*:*:*", "matchCriteriaId": "92F68614-84A3-4CB8-9481-9D3D089FF3E4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.050:*:*:*:*:*:*:*", "matchCriteriaId": "E1539E34-B384-4882-953E-896971C1E8AE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.060:*:*:*:*:*:*:*", "matchCriteriaId": "784B61DA-2890-4B4C-9D07-258A2C183132"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.070:*:*:*:*:*:*:*", "matchCriteriaId": "8E91A2F5-2C56-4D5E-BBC7-F48BF458C264"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.080:*:*:*:*:*:*:*", "matchCriteriaId": "6CE691D3-3A39-4B95-BD15-562D8A80BAE9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.090:*:*:*:*:*:*:*", "matchCriteriaId": "DE8E9AF8-6660-45F7-BF4A-B9C71CED7A68"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.100:*:*:*:*:*:*:*", "matchCriteriaId": "84063206-CEF4-4829-A74A-55C767923D5A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.110:*:*:*:*:*:*:*", "matchCriteriaId": "D885CB6A-06E9-416C-93D2-9C5A9931CF56"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.121:*:*:*:*:*:*:*", "matchCriteriaId": "97FE2F9D-C573-44BB-A542-8512FD27D130"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.130:*:*:*:*:*:*:*", "matchCriteriaId": "8209350C-BD76-43E2-9E81-CECD03A214B9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.140:*:*:*:*:*:*:*", "matchCriteriaId": "86FB60E8-8A87-4838-8144-1FCFB8C382FC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.150:*:*:*:*:*:*:*", "matchCriteriaId": "A98A70E1-A1BD-45A6-A409-97B7FAA07E5D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.160:*:*:*:*:*:*:*", "matchCriteriaId": "09CB193D-3D6B-4680-8490-6FAA714C45A4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.170:*:*:*:*:*:*:*", "matchCriteriaId": "471E5FDB-0C34-4D3A-BACC-1EADE1ADCE83"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.180:*:*:*:*:*:*:*", "matchCriteriaId": "F97EC65B-0E6A-4F25-B7DC-1C1297173684"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.190:*:*:*:*:*:*:*", "matchCriteriaId": "4390E10A-027E-423E-ABE3-86099074B4AF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.200:*:*:*:*:*:*:*", "matchCriteriaId": "B44FF660-7348-4F60-BE4D-1815C095C88A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.210:*:*:*:*:*:*:*", "matchCriteriaId": "7350164E-520E-4BA0-8C51-19EE7D1E5FA2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.220:*:*:*:*:*:*:*", "matchCriteriaId": "7B2E5B42-C492-4F59-B250-C40095CF2582"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.230:*:*:*:*:*:*:*", "matchCriteriaId": "D4155856-F5A3-4125-952E-82E93DDDE088"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.240:*:*:*:*:*:*:*", "matchCriteriaId": "EB0BE82F-EC96-428E-871B-1332045EE9C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.250:*:*:*:*:*:*:*", "matchCriteriaId": "B80E81F6-2A96-4014-8045-FC0C1B4CEB1C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.260:*:*:*:*:*:*:*", "matchCriteriaId": "D38FB71E-4663-48EC-8164-105AF85AEB51"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.270:*:*:*:*:*:*:*", "matchCriteriaId": "A95386F4-123A-407A-A735-F12FD9711BEC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.280:*:*:*:*:*:*:*", "matchCriteriaId": "030A8C8C-D60D-467D-80CE-B2B00572F05F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.290:*:*:*:*:*:*:*", "matchCriteriaId": "1CE7F5BF-2B5D-44B4-8865-90E58771239C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.300:*:*:*:*:*:*:*", "matchCriteriaId": "41462964-E5BA-4182-ABF4-54ECD5D97DAB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.310:*:*:*:*:*:*:*", "matchCriteriaId": "85AAE04F-4530-454A-AC2C-2581197EAD0B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.320:*:*:*:*:*:*:*", "matchCriteriaId": "2F2634CD-846C-4343-B50F-21AD7380212B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.330:*:*:*:*:*:*:*", "matchCriteriaId": "60489FB9-5D98-4611-8FBE-7F6A901BBFA1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.340:*:*:*:*:*:*:*", "matchCriteriaId": "85A8F9EA-7A8D-4BA9-9732-DE93388800A3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.350:*:*:*:*:*:*:*", "matchCriteriaId": "4D4C622D-6ED7-4F11-A43B-FE00B088CEAE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.360:*:*:*:*:*:*:*", "matchCriteriaId": "080FCFDE-557E-4D35-8701-96AC28381ADF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.370:*:*:*:*:*:*:*", "matchCriteriaId": "E948F223-D365-4D5B-9C2B-FB064F8DC00B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.380:*:*:*:*:*:*:*", "matchCriteriaId": "DF07B559-9FEE-40FF-AA85-0018998F7E22"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.390:*:*:*:*:*:*:*", "matchCriteriaId": "2B767E9C-D321-4972-BF7A-B5E62956D6CD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.400:*:*:*:*:*:*:*", "matchCriteriaId": "F97A0281-1C70-4476-9441-400C83AB39E6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.410:*:*:*:*:*:*:*", "matchCriteriaId": "46563F83-035B-49AF-94B4-909CE53945D3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.420:*:*:*:*:*:*:*", "matchCriteriaId": "75736565-8B44-48C2-92AE-AF4B19A5C18D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.430:*:*:*:*:*:*:*", "matchCriteriaId": "0A50E69D-EE5A-4DC7-A884-F6B10E677E4B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.440:*:*:*:*:*:*:*", "matchCriteriaId": "19FCDACE-0BB2-4891-94BE-5E8F1BB72386"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.441:*:*:*:*:*:*:*", "matchCriteriaId": "4462604D-A3FE-4DA4-A401-59AA433686A3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.450:*:*:*:*:*:*:*", "matchCriteriaId": "6EE2A989-3136-4B0F-AA9C-4C002532FCB3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.460:*:*:*:*:*:*:*", "matchCriteriaId": "FF407748-7342-487E-86B9-038361C09B45"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.470:*:*:*:*:*:*:*", "matchCriteriaId": "C4F2FAD3-E922-4E17-95EC-E6D2F1BC9778"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.480:*:*:*:*:*:*:*", "matchCriteriaId": "B0D66B84-678C-4568-8543-319A9C4D4116"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.490:*:*:*:*:*:*:*", "matchCriteriaId": "0C548C2A-18F0-43F0-A98B-B730E33B0A87"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.500:*:*:*:*:*:*:*", "matchCriteriaId": "8CD4CB9A-2C24-4548-8204-D936927F8362"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.510:*:*:*:*:*:*:*", "matchCriteriaId": "1582111F-8C80-41C9-84D5-8C2BAD1511C3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.520:*:*:*:*:*:*:*", "matchCriteriaId": "97A98749-3256-4027-8AF0-F9756AA96CA8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:1.530:*:*:*:*:*:*:*", "matchCriteriaId": "5A7B281C-00C6-405A-AC41-0C29E29AB412"}]}]}], "references": [{"url": "http://javierb.com.ar/2011/04/24/xss-webmin-1-540/", "source": "secalert@redhat.com", "tags": ["Exploit"]}, {"url": "http://openwall.com/lists/oss-security/2011/05/22/1", "source": "secalert@redhat.com"}, {"url": "http://openwall.com/lists/oss-security/2011/05/24/7", "source": "secalert@redhat.com", "tags": ["Exploit"]}, {"url": "http://securityreason.com/securityalert/8264", "source": "secalert@redhat.com"}, {"url": "http://securitytracker.com/id?1025438", "source": "secalert@redhat.com", "tags": ["Exploit"]}, {"url": "http://www.mandriva.com/security/advisories?name=MDVSA-2011:109", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/archive/1/517658", "source": "secalert@redhat.com", "tags": ["Exploit"]}, {"url": "http://www.securityfocus.com/bid/47558", "source": "secalert@redhat.com"}, {"url": "http://www.youtube.com/watch?v=CUO7JLIGUf0", "source": "secalert@redhat.com", "tags": ["Exploit"]}, {"url": "https://github.com/webmin/webmin/commit/46e3d3ad195dcdc1af1795c96b6e0dc778fb6881", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/webmin/webmin/commit/46e3d3ad195dcdc1af1795c96b6e0dc778fb6881"}}