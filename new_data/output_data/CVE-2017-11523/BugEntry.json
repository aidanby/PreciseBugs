{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            TTTTT  X   X  TTTTT                              %\n%                              T     X X     T                                %\n%                              T      X      T                                %\n%                              T     X X     T                                %\n%                              T    X   X    T                                %\n%                                                                             %\n%                                                                             %\n%                      Render Text Onto A Canvas Image.                       %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/annotate.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteTXTImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s T X T                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsTXT() returns MagickTrue if the image format type, identified by the magick\n%  string, is TXT.\n%\n%  The format of the IsTXT method is:\n%\n%      MagickBooleanType IsTXT(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsTXT(const unsigned char *magick,const size_t length)\n{\n#define MagickID  \"# ImageMagick pixel enumeration:\"\n\n  char\n    colorspace[MagickPathExtent];\n\n  ssize_t\n    count;\n\n  unsigned long\n    columns,\n    depth,\n    rows;\n\n  if (length < 40)\n    return(MagickFalse);\n  if (LocaleNCompare((const char *) magick,MagickID,strlen(MagickID)) != 0)\n    return(MagickFalse);\n  count=(ssize_t) sscanf((const char *) magick+32,\"%lu,%lu,%lu,%s\",&columns,\n    &rows,&depth,colorspace);\n  if (count != 4)\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d T E X T I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadTEXTImage() reads a text file and returns it as an image.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadTEXTImage method is:\n%\n%      Image *ReadTEXTImage(const ImageInfo *image_info,Image *image,\n%        char *text,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image: the image.\n%\n%    o text: the text storage buffer.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadTEXTImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent],\n    geometry[MagickPathExtent],\n    *p,\n    text[MagickPathExtent];\n\n  DrawInfo\n    *draw_info;\n\n  Image\n    *image,\n    *texture;\n\n  MagickBooleanType\n    status;\n\n  PointInfo\n    delta;\n\n  RectangleInfo\n    page;\n\n  ssize_t\n    offset;\n\n  TypeMetric\n    metrics;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) ResetMagickMemory(text,0,sizeof(text));\n  (void) ReadBlobString(image,text);\n  /*\n    Set the page geometry.\n  */\n  delta.x=DefaultResolution;\n  delta.y=DefaultResolution;\n  if ((image->resolution.x == 0.0) || (image->resolution.y == 0.0))\n    {\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  page.width=612;\n  page.height=792;\n  page.x=43;\n  page.y=43;\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  /*\n    Initialize Image structure.\n  */\n  image->columns=(size_t) floor((((double) page.width*image->resolution.x)/\n    delta.x)+0.5);\n  image->rows=(size_t) floor((((double) page.height*image->resolution.y)/\n    delta.y)+0.5);\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  image->page.x=0;\n  image->page.y=0;\n  texture=(Image *) NULL;\n  if (image_info->texture != (char *) NULL)\n    {\n      ImageInfo\n        *read_info;\n\n      read_info=CloneImageInfo(image_info);\n      SetImageInfoBlob(read_info,(void *) NULL,0);\n      (void) CopyMagickString(read_info->filename,image_info->texture,\n        MagickPathExtent);\n      texture=ReadImage(read_info,exception);\n      read_info=DestroyImageInfo(read_info);\n    }\n  /*\n    Annotate the text image.\n  */\n  (void) SetImageBackgroundColor(image,exception);\n  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  (void) CloneString(&draw_info->text,image_info->filename);\n  (void) FormatLocaleString(geometry,MagickPathExtent,\"%gx%g%+g%+g\",(double)\n    image->columns,(double) image->rows,(double) page.x,(double) page.y);\n  (void) CloneString(&draw_info->geometry,geometry);\n  status=GetTypeMetrics(image,draw_info,&metrics,exception);\n  if (status == MagickFalse)\n    ThrowReaderException(TypeError,\"UnableToGetTypeMetrics\");\n  page.y=(ssize_t) ceil((double) page.y+metrics.ascent-0.5);\n  (void) FormatLocaleString(geometry,MagickPathExtent,\"%gx%g%+g%+g\",(double)\n    image->columns,(double) image->rows,(double) page.x,(double) page.y);\n  (void) CloneString(&draw_info->geometry,geometry);\n  (void) CopyMagickString(filename,image_info->filename,MagickPathExtent);\n  if (*draw_info->text != '\\0')\n    *draw_info->text='\\0';\n  p=text;\n  for (offset=2*page.y; p != (char *) NULL; )\n  {\n    /*\n      Annotate image with text.\n    */\n    (void) ConcatenateString(&draw_info->text,text);\n    (void) ConcatenateString(&draw_info->text,\"\\n\");\n    offset+=(ssize_t) (metrics.ascent-metrics.descent);\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) offset,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n    p=ReadBlobString(image,text);\n    if ((offset < (ssize_t) image->rows) && (p != (char *) NULL))\n      continue;\n    if (texture != (Image *) NULL)\n      {\n        MagickProgressMonitor\n          progress_monitor;\n\n        progress_monitor=SetImageProgressMonitor(image,\n          (MagickProgressMonitor) NULL,image->client_data);\n        (void) TextureImage(image,texture,exception);\n        (void) SetImageProgressMonitor(image,progress_monitor,\n          image->client_data);\n      }\n    (void) AnnotateImage(image,draw_info,exception);\n    if (p == (char *) NULL)\n      break;\n    /*\n      Page is full-- allocate next image structure.\n    */\n    *draw_info->text='\\0';\n    offset=2*page.y;\n    AcquireNextImage(image_info,image,exception);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n    image->next->columns=image->columns;\n    image->next->rows=image->rows;\n    image=SyncNextImageInList(image);\n    (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n    (void) SetImageBackgroundColor(image,exception);\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      GetBlobSize(image));\n    if (status == MagickFalse)\n      break;\n  }\n  if (texture != (Image *) NULL)\n    {\n      MagickProgressMonitor\n        progress_monitor;\n\n      progress_monitor=SetImageProgressMonitor(image,\n        (MagickProgressMonitor) NULL,image->client_data);\n      (void) TextureImage(image,texture,exception);\n      (void) SetImageProgressMonitor(image,progress_monitor,image->client_data);\n    }\n  (void) AnnotateImage(image,draw_info,exception);\n  if (texture != (Image *) NULL)\n    texture=DestroyImage(texture);\n  draw_info=DestroyDrawInfo(draw_info);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d T X T I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadTXTImage() reads a text file and returns it as an image.  It allocates\n%  the memory necessary for the new Image structure and returns a pointer to\n%  the new image.\n%\n%  The format of the ReadTXTImage method is:\n%\n%      Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    colorspace[MagickPathExtent],\n    text[MagickPathExtent];\n\n  Image\n    *image;\n\n  long\n    x_offset,\n    y_offset;\n\n  PixelInfo\n    pixel;\n\n  MagickBooleanType\n    status;\n\n  QuantumAny\n    range;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    count,\n    type,\n    y;\n\n  unsigned long\n    depth,\n    height,\n    max_value,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) ResetMagickMemory(text,0,sizeof(text));\n  (void) ReadBlobString(image,text);\n  if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) != 0)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    width=0;\n    height=0;\n    max_value=0;\n    *colorspace='\\0';\n    count=(ssize_t) sscanf(text+32,\"%lu,%lu,%lu,%s\",&width,&height,&max_value,\n      colorspace);\n    if ((count != 4) || (width == 0) || (height == 0) || (max_value == 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    image->columns=width;\n    image->rows=height;\n    for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++) ;\n    image->depth=depth;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    LocaleLower(colorspace);\n    i=(ssize_t) strlen(colorspace)-1;\n    image->alpha_trait=UndefinedPixelTrait;\n    if ((i > 0) && (colorspace[i] == 'a'))\n      {\n        colorspace[i]='\\0';\n        image->alpha_trait=BlendPixelTrait;\n      }\n    type=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);\n    if (type < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    (void) SetImageBackgroundColor(image,exception);\n    (void) SetImageColorspace(image,(ColorspaceType) type,exception);\n    GetPixelInfo(image,&pixel);\n    range=GetQuantumRange(image->depth);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      double\n        alpha,\n        black,\n        blue,\n        green,\n        red;\n\n      red=0.0;\n      green=0.0;\n      blue=0.0;\n      black=0.0;\n      alpha=0.0;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        if (ReadBlobString(image,text) == (char *) NULL)\n          break;\n        switch (image->colorspace)\n        {\n          case GRAYColorspace:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\"%ld,%ld: (%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&alpha);\n                green=red;\n                blue=red;\n                break;\n              }\n            count=(ssize_t) sscanf(text,\"%ld,%ld: (%lf%*[%,]\",&x_offset,\n              &y_offset,&red);\n            green=red;\n            blue=red;\n            break;       \n          }\n          case CMYKColorspace:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\n                  \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&black,&alpha);\n                break;\n              }\n            count=(ssize_t) sscanf(text,\n              \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,\n              &y_offset,&red,&green,&blue,&black);\n            break;\n          }\n          default:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\n                  \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&alpha);\n                break;\n              }\n            count=(ssize_t) sscanf(text,\n              \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,\n              &y_offset,&red,&green,&blue);\n            break;       \n          }\n        }\n        if (strchr(text,'%') != (char *) NULL)\n          {\n            red*=0.01*range;\n            green*=0.01*range;\n            blue*=0.01*range;\n            black*=0.01*range;\n            alpha*=0.01*range;\n          }\n        if (image->colorspace == LabColorspace)\n          {\n            green+=(range+1)/2.0;\n            blue+=(range+1)/2.0;\n          }\n        pixel.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (red+0.5),\n          range);\n        pixel.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (green+0.5),\n          range);\n        pixel.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (blue+0.5),\n          range);\n        pixel.black=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (black+0.5),\n          range);\n        pixel.alpha=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (alpha+0.5),\n          range);\n        q=GetAuthenticPixels(image,(ssize_t) x_offset,(ssize_t) y_offset,1,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          continue;\n        SetPixelViaPixelInfo(image,&pixel,q);\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n    }\n    (void) ReadBlobString(image,text);\n    if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r T X T I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterTXTImage() adds attributes for the TXT image format to the\n%  list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterTXTImage method is:\n%\n%      size_t RegisterTXTImage(void)\n%\n*/\nModuleExport size_t RegisterTXTImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"TXT\",\"SPARSE-COLOR\",\"Sparse Color\");\n  entry->encoder=(EncodeImageHandler *) WriteTXTImage;\n  entry->flags|=CoderRawSupportFlag;\n  entry->flags|=CoderEndianSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TXT\",\"TEXT\",\"Text\");\n  entry->decoder=(DecodeImageHandler *) ReadTEXTImage;\n  entry->format_type=ImplicitFormatType;\n  entry->flags|=CoderRawSupportFlag;\n  entry->flags|=CoderEndianSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TXT\",\"TXT\",\"Text\");\n  entry->decoder=(DecodeImageHandler *) ReadTXTImage;\n  entry->encoder=(EncodeImageHandler *) WriteTXTImage;\n  entry->magick=(IsImageFormatHandler *) IsTXT;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r T X T I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterTXTImage() removes format registrations made by the\n%  TXT module from the list of supported format.\n%\n%  The format of the UnregisterTXTImage method is:\n%\n%      UnregisterTXTImage(void)\n%\n*/\nModuleExport void UnregisterTXTImage(void)\n{\n  (void) UnregisterMagickInfo(\"SPARSE-COLOR\");\n  (void) UnregisterMagickInfo(\"TEXT\");\n  (void) UnregisterMagickInfo(\"TXT\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e T X T I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteTXTImage writes the pixel values as text numbers.\n%\n%  The format of the WriteTXTImage method is:\n%\n%      MagickBooleanType WriteTXTImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteTXTImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    buffer[MagickPathExtent],\n    colorspace[MagickPathExtent],\n    tuple[MagickPathExtent];\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  PixelInfo\n    pixel;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    y;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  scene=0;\n  do\n  {\n    ComplianceType\n      compliance;\n\n    const char\n      *value;\n\n    (void) CopyMagickString(colorspace,CommandOptionToMnemonic(\n      MagickColorspaceOptions,(ssize_t) image->colorspace),MagickPathExtent);\n    LocaleLower(colorspace);\n    image->depth=GetImageQuantumDepth(image,MagickTrue);\n    if (image->alpha_trait != UndefinedPixelTrait)\n      (void) ConcatenateMagickString(colorspace,\"a\",MagickPathExtent);\n    compliance=NoCompliance;\n    value=GetImageOption(image_info,\"txt:compliance\");\n    if (value != (char *) NULL)\n      compliance=(ComplianceType) ParseCommandOption(MagickComplianceOptions,\n        MagickFalse,value);\n    if (LocaleCompare(image_info->magick,\"SPARSE-COLOR\") != 0)\n      {\n        size_t\n          depth;\n\n        depth=compliance == SVGCompliance ? image->depth :\n          MAGICKCORE_QUANTUM_DEPTH;\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"# ImageMagick pixel enumeration: %.20g,%.20g,%.20g,%s\\n\",(double)\n          image->columns,(double) image->rows,(double) ((MagickOffsetType)\n          GetQuantumRange(depth)),colorspace);\n        (void) WriteBlobString(image,buffer);\n      }\n    GetPixelInfo(image,&pixel);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n      if (p == (const Quantum *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        GetPixelInfoPixel(image,p,&pixel);\n        if (pixel.colorspace == LabColorspace)\n          {\n            pixel.green-=(QuantumRange+1)/2.0;\n            pixel.blue-=(QuantumRange+1)/2.0;\n          }\n        if (LocaleCompare(image_info->magick,\"SPARSE-COLOR\") == 0)\n          {\n            /*\n              Sparse-color format.\n            */\n            if (GetPixelAlpha(image,p) == (Quantum) OpaqueAlpha)\n              {\n                GetColorTuple(&pixel,MagickFalse,tuple);\n                (void) FormatLocaleString(buffer,MagickPathExtent,\n                  \"%.20g,%.20g,\",(double) x,(double) y);\n                (void) WriteBlobString(image,buffer);\n                (void) WriteBlobString(image,tuple);\n                (void) WriteBlobString(image,\" \");\n              }\n            p+=GetPixelChannels(image);\n            continue;\n          }\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g,%.20g: \",\n          (double) x,(double) y);\n        (void) WriteBlobString(image,buffer);\n        (void) CopyMagickString(tuple,\"(\",MagickPathExtent);\n        if (pixel.colorspace == GRAYColorspace)\n          ConcatenateColorComponent(&pixel,GrayPixelChannel,compliance,tuple);\n        else\n          {\n            ConcatenateColorComponent(&pixel,RedPixelChannel,compliance,tuple);\n            (void) ConcatenateMagickString(tuple,\",\",MagickPathExtent);\n            ConcatenateColorComponent(&pixel,GreenPixelChannel,compliance,\n              tuple);\n            (void) ConcatenateMagickString(tuple,\",\",MagickPathExtent);\n            ConcatenateColorComponent(&pixel,BluePixelChannel,compliance,tuple);\n          }\n        if (pixel.colorspace == CMYKColorspace)\n          {\n            (void) ConcatenateMagickString(tuple,\",\",MagickPathExtent);\n            ConcatenateColorComponent(&pixel,BlackPixelChannel,compliance,\n              tuple);\n          }\n        if (pixel.alpha_trait != UndefinedPixelTrait)\n          {\n            (void) ConcatenateMagickString(tuple,\",\",MagickPathExtent);\n            ConcatenateColorComponent(&pixel,AlphaPixelChannel,compliance,\n              tuple);\n          }\n        (void) ConcatenateMagickString(tuple,\")\",MagickPathExtent);\n        (void) WriteBlobString(image,tuple);\n        (void) WriteBlobString(image,\"  \");\n        GetColorTuple(&pixel,MagickTrue,tuple);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%s\",tuple);\n        (void) WriteBlobString(image,buffer);\n        (void) WriteBlobString(image,\"  \");\n        (void) QueryColorname(image,&pixel,SVGCompliance,tuple,exception);\n        (void) WriteBlobString(image,tuple);\n        (void) WriteBlobString(image,\"\\n\");\n        p+=GetPixelChannels(image);\n      }\n      status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n        image->rows);\n      if (status == MagickFalse)\n        break;\n    }\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            TTTTT  X   X  TTTTT                              %\n%                              T     X X     T                                %\n%                              T      X      T                                %\n%                              T     X X     T                                %\n%                              T    X   X    T                                %\n%                                                                             %\n%                                                                             %\n%                      Render Text Onto A Canvas Image.                       %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/annotate.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteTXTImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s T X T                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsTXT() returns MagickTrue if the image format type, identified by the magick\n%  string, is TXT.\n%\n%  The format of the IsTXT method is:\n%\n%      MagickBooleanType IsTXT(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsTXT(const unsigned char *magick,const size_t length)\n{\n#define MagickID  \"# ImageMagick pixel enumeration:\"\n\n  char\n    colorspace[MagickPathExtent];\n\n  ssize_t\n    count;\n\n  unsigned long\n    columns,\n    depth,\n    rows;\n\n  if (length < 40)\n    return(MagickFalse);\n  if (LocaleNCompare((const char *) magick,MagickID,strlen(MagickID)) != 0)\n    return(MagickFalse);\n  count=(ssize_t) sscanf((const char *) magick+32,\"%lu,%lu,%lu,%s\",&columns,\n    &rows,&depth,colorspace);\n  if (count != 4)\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d T E X T I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadTEXTImage() reads a text file and returns it as an image.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadTEXTImage method is:\n%\n%      Image *ReadTEXTImage(const ImageInfo *image_info,Image *image,\n%        char *text,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image: the image.\n%\n%    o text: the text storage buffer.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadTEXTImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent],\n    geometry[MagickPathExtent],\n    *p,\n    text[MagickPathExtent];\n\n  DrawInfo\n    *draw_info;\n\n  Image\n    *image,\n    *texture;\n\n  MagickBooleanType\n    status;\n\n  PointInfo\n    delta;\n\n  RectangleInfo\n    page;\n\n  ssize_t\n    offset;\n\n  TypeMetric\n    metrics;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) ResetMagickMemory(text,0,sizeof(text));\n  (void) ReadBlobString(image,text);\n  /*\n    Set the page geometry.\n  */\n  delta.x=DefaultResolution;\n  delta.y=DefaultResolution;\n  if ((image->resolution.x == 0.0) || (image->resolution.y == 0.0))\n    {\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  page.width=612;\n  page.height=792;\n  page.x=43;\n  page.y=43;\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  /*\n    Initialize Image structure.\n  */\n  image->columns=(size_t) floor((((double) page.width*image->resolution.x)/\n    delta.x)+0.5);\n  image->rows=(size_t) floor((((double) page.height*image->resolution.y)/\n    delta.y)+0.5);\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  image->page.x=0;\n  image->page.y=0;\n  texture=(Image *) NULL;\n  if (image_info->texture != (char *) NULL)\n    {\n      ImageInfo\n        *read_info;\n\n      read_info=CloneImageInfo(image_info);\n      SetImageInfoBlob(read_info,(void *) NULL,0);\n      (void) CopyMagickString(read_info->filename,image_info->texture,\n        MagickPathExtent);\n      texture=ReadImage(read_info,exception);\n      read_info=DestroyImageInfo(read_info);\n    }\n  /*\n    Annotate the text image.\n  */\n  (void) SetImageBackgroundColor(image,exception);\n  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  (void) CloneString(&draw_info->text,image_info->filename);\n  (void) FormatLocaleString(geometry,MagickPathExtent,\"%gx%g%+g%+g\",(double)\n    image->columns,(double) image->rows,(double) page.x,(double) page.y);\n  (void) CloneString(&draw_info->geometry,geometry);\n  status=GetTypeMetrics(image,draw_info,&metrics,exception);\n  if (status == MagickFalse)\n    ThrowReaderException(TypeError,\"UnableToGetTypeMetrics\");\n  page.y=(ssize_t) ceil((double) page.y+metrics.ascent-0.5);\n  (void) FormatLocaleString(geometry,MagickPathExtent,\"%gx%g%+g%+g\",(double)\n    image->columns,(double) image->rows,(double) page.x,(double) page.y);\n  (void) CloneString(&draw_info->geometry,geometry);\n  (void) CopyMagickString(filename,image_info->filename,MagickPathExtent);\n  if (*draw_info->text != '\\0')\n    *draw_info->text='\\0';\n  p=text;\n  for (offset=2*page.y; p != (char *) NULL; )\n  {\n    /*\n      Annotate image with text.\n    */\n    (void) ConcatenateString(&draw_info->text,text);\n    (void) ConcatenateString(&draw_info->text,\"\\n\");\n    offset+=(ssize_t) (metrics.ascent-metrics.descent);\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) offset,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n    p=ReadBlobString(image,text);\n    if ((offset < (ssize_t) image->rows) && (p != (char *) NULL))\n      continue;\n    if (texture != (Image *) NULL)\n      {\n        MagickProgressMonitor\n          progress_monitor;\n\n        progress_monitor=SetImageProgressMonitor(image,\n          (MagickProgressMonitor) NULL,image->client_data);\n        (void) TextureImage(image,texture,exception);\n        (void) SetImageProgressMonitor(image,progress_monitor,\n          image->client_data);\n      }\n    (void) AnnotateImage(image,draw_info,exception);\n    if (p == (char *) NULL)\n      break;\n    /*\n      Page is full-- allocate next image structure.\n    */\n    *draw_info->text='\\0';\n    offset=2*page.y;\n    AcquireNextImage(image_info,image,exception);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n    image->next->columns=image->columns;\n    image->next->rows=image->rows;\n    image=SyncNextImageInList(image);\n    (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n    (void) SetImageBackgroundColor(image,exception);\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      GetBlobSize(image));\n    if (status == MagickFalse)\n      break;\n  }\n  if (texture != (Image *) NULL)\n    {\n      MagickProgressMonitor\n        progress_monitor;\n\n      progress_monitor=SetImageProgressMonitor(image,\n        (MagickProgressMonitor) NULL,image->client_data);\n      (void) TextureImage(image,texture,exception);\n      (void) SetImageProgressMonitor(image,progress_monitor,image->client_data);\n    }\n  (void) AnnotateImage(image,draw_info,exception);\n  if (texture != (Image *) NULL)\n    texture=DestroyImage(texture);\n  draw_info=DestroyDrawInfo(draw_info);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d T X T I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadTXTImage() reads a text file and returns it as an image.  It allocates\n%  the memory necessary for the new Image structure and returns a pointer to\n%  the new image.\n%\n%  The format of the ReadTXTImage method is:\n%\n%      Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    colorspace[MagickPathExtent],\n    text[MagickPathExtent];\n\n  Image\n    *image;\n\n  long\n    x_offset,\n    y_offset;\n\n  PixelInfo\n    pixel;\n\n  MagickBooleanType\n    status;\n\n  QuantumAny\n    range;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    count,\n    type,\n    y;\n\n  unsigned long\n    depth,\n    height,\n    max_value,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) ResetMagickMemory(text,0,sizeof(text));\n  (void) ReadBlobString(image,text);\n  if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) != 0)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    width=0;\n    height=0;\n    max_value=0;\n    *colorspace='\\0';\n    count=(ssize_t) sscanf(text+32,\"%lu,%lu,%lu,%s\",&width,&height,&max_value,\n      colorspace);\n    if ((count != 4) || (width == 0) || (height == 0) || (max_value == 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    image->columns=width;\n    image->rows=height;\n    for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++) ;\n    image->depth=depth;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    LocaleLower(colorspace);\n    i=(ssize_t) strlen(colorspace)-1;\n    image->alpha_trait=UndefinedPixelTrait;\n    if ((i > 0) && (colorspace[i] == 'a'))\n      {\n        colorspace[i]='\\0';\n        image->alpha_trait=BlendPixelTrait;\n      }\n    type=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);\n    if (type < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    (void) SetImageBackgroundColor(image,exception);\n    (void) SetImageColorspace(image,(ColorspaceType) type,exception);\n    GetPixelInfo(image,&pixel);\n    range=GetQuantumRange(image->depth);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      double\n        alpha,\n        black,\n        blue,\n        green,\n        red;\n\n      red=0.0;\n      green=0.0;\n      blue=0.0;\n      black=0.0;\n      alpha=0.0;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        if (ReadBlobString(image,text) == (char *) NULL)\n          break;\n        switch (image->colorspace)\n        {\n          case GRAYColorspace:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\"%ld,%ld: (%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&alpha);\n                green=red;\n                blue=red;\n                break;\n              }\n            count=(ssize_t) sscanf(text,\"%ld,%ld: (%lf%*[%,]\",&x_offset,\n              &y_offset,&red);\n            green=red;\n            blue=red;\n            break;       \n          }\n          case CMYKColorspace:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\n                  \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&black,&alpha);\n                break;\n              }\n            count=(ssize_t) sscanf(text,\n              \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,\n              &y_offset,&red,&green,&blue,&black);\n            break;\n          }\n          default:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\n                  \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&alpha);\n                break;\n              }\n            count=(ssize_t) sscanf(text,\n              \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,\n              &y_offset,&red,&green,&blue);\n            break;       \n          }\n        }\n        if (strchr(text,'%') != (char *) NULL)\n          {\n            red*=0.01*range;\n            green*=0.01*range;\n            blue*=0.01*range;\n            black*=0.01*range;\n            alpha*=0.01*range;\n          }\n        if (image->colorspace == LabColorspace)\n          {\n            green+=(range+1)/2.0;\n            blue+=(range+1)/2.0;\n          }\n        pixel.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (red+0.5),\n          range);\n        pixel.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (green+0.5),\n          range);\n        pixel.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (blue+0.5),\n          range);\n        pixel.black=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (black+0.5),\n          range);\n        pixel.alpha=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (alpha+0.5),\n          range);\n        q=GetAuthenticPixels(image,(ssize_t) x_offset,(ssize_t) y_offset,1,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          continue;\n        SetPixelViaPixelInfo(image,&pixel,q);\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n    }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    (void) ReadBlobString(image,text);\n    if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r T X T I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterTXTImage() adds attributes for the TXT image format to the\n%  list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterTXTImage method is:\n%\n%      size_t RegisterTXTImage(void)\n%\n*/\nModuleExport size_t RegisterTXTImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"TXT\",\"SPARSE-COLOR\",\"Sparse Color\");\n  entry->encoder=(EncodeImageHandler *) WriteTXTImage;\n  entry->flags|=CoderRawSupportFlag;\n  entry->flags|=CoderEndianSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TXT\",\"TEXT\",\"Text\");\n  entry->decoder=(DecodeImageHandler *) ReadTEXTImage;\n  entry->format_type=ImplicitFormatType;\n  entry->flags|=CoderRawSupportFlag;\n  entry->flags|=CoderEndianSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TXT\",\"TXT\",\"Text\");\n  entry->decoder=(DecodeImageHandler *) ReadTXTImage;\n  entry->encoder=(EncodeImageHandler *) WriteTXTImage;\n  entry->magick=(IsImageFormatHandler *) IsTXT;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r T X T I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterTXTImage() removes format registrations made by the\n%  TXT module from the list of supported format.\n%\n%  The format of the UnregisterTXTImage method is:\n%\n%      UnregisterTXTImage(void)\n%\n*/\nModuleExport void UnregisterTXTImage(void)\n{\n  (void) UnregisterMagickInfo(\"SPARSE-COLOR\");\n  (void) UnregisterMagickInfo(\"TEXT\");\n  (void) UnregisterMagickInfo(\"TXT\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e T X T I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteTXTImage writes the pixel values as text numbers.\n%\n%  The format of the WriteTXTImage method is:\n%\n%      MagickBooleanType WriteTXTImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteTXTImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    buffer[MagickPathExtent],\n    colorspace[MagickPathExtent],\n    tuple[MagickPathExtent];\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  PixelInfo\n    pixel;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    y;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  scene=0;\n  do\n  {\n    ComplianceType\n      compliance;\n\n    const char\n      *value;\n\n    (void) CopyMagickString(colorspace,CommandOptionToMnemonic(\n      MagickColorspaceOptions,(ssize_t) image->colorspace),MagickPathExtent);\n    LocaleLower(colorspace);\n    image->depth=GetImageQuantumDepth(image,MagickTrue);\n    if (image->alpha_trait != UndefinedPixelTrait)\n      (void) ConcatenateMagickString(colorspace,\"a\",MagickPathExtent);\n    compliance=NoCompliance;\n    value=GetImageOption(image_info,\"txt:compliance\");\n    if (value != (char *) NULL)\n      compliance=(ComplianceType) ParseCommandOption(MagickComplianceOptions,\n        MagickFalse,value);\n    if (LocaleCompare(image_info->magick,\"SPARSE-COLOR\") != 0)\n      {\n        size_t\n          depth;\n\n        depth=compliance == SVGCompliance ? image->depth :\n          MAGICKCORE_QUANTUM_DEPTH;\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"# ImageMagick pixel enumeration: %.20g,%.20g,%.20g,%s\\n\",(double)\n          image->columns,(double) image->rows,(double) ((MagickOffsetType)\n          GetQuantumRange(depth)),colorspace);\n        (void) WriteBlobString(image,buffer);\n      }\n    GetPixelInfo(image,&pixel);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n      if (p == (const Quantum *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        GetPixelInfoPixel(image,p,&pixel);\n        if (pixel.colorspace == LabColorspace)\n          {\n            pixel.green-=(QuantumRange+1)/2.0;\n            pixel.blue-=(QuantumRange+1)/2.0;\n          }\n        if (LocaleCompare(image_info->magick,\"SPARSE-COLOR\") == 0)\n          {\n            /*\n              Sparse-color format.\n            */\n            if (GetPixelAlpha(image,p) == (Quantum) OpaqueAlpha)\n              {\n                GetColorTuple(&pixel,MagickFalse,tuple);\n                (void) FormatLocaleString(buffer,MagickPathExtent,\n                  \"%.20g,%.20g,\",(double) x,(double) y);\n                (void) WriteBlobString(image,buffer);\n                (void) WriteBlobString(image,tuple);\n                (void) WriteBlobString(image,\" \");\n              }\n            p+=GetPixelChannels(image);\n            continue;\n          }\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g,%.20g: \",\n          (double) x,(double) y);\n        (void) WriteBlobString(image,buffer);\n        (void) CopyMagickString(tuple,\"(\",MagickPathExtent);\n        if (pixel.colorspace == GRAYColorspace)\n          ConcatenateColorComponent(&pixel,GrayPixelChannel,compliance,tuple);\n        else\n          {\n            ConcatenateColorComponent(&pixel,RedPixelChannel,compliance,tuple);\n            (void) ConcatenateMagickString(tuple,\",\",MagickPathExtent);\n            ConcatenateColorComponent(&pixel,GreenPixelChannel,compliance,\n              tuple);\n            (void) ConcatenateMagickString(tuple,\",\",MagickPathExtent);\n            ConcatenateColorComponent(&pixel,BluePixelChannel,compliance,tuple);\n          }\n        if (pixel.colorspace == CMYKColorspace)\n          {\n            (void) ConcatenateMagickString(tuple,\",\",MagickPathExtent);\n            ConcatenateColorComponent(&pixel,BlackPixelChannel,compliance,\n              tuple);\n          }\n        if (pixel.alpha_trait != UndefinedPixelTrait)\n          {\n            (void) ConcatenateMagickString(tuple,\",\",MagickPathExtent);\n            ConcatenateColorComponent(&pixel,AlphaPixelChannel,compliance,\n              tuple);\n          }\n        (void) ConcatenateMagickString(tuple,\")\",MagickPathExtent);\n        (void) WriteBlobString(image,tuple);\n        (void) WriteBlobString(image,\"  \");\n        GetColorTuple(&pixel,MagickTrue,tuple);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%s\",tuple);\n        (void) WriteBlobString(image,buffer);\n        (void) WriteBlobString(image,\"  \");\n        (void) QueryColorname(image,&pixel,SVGCompliance,tuple,exception);\n        (void) WriteBlobString(image,tuple);\n        (void) WriteBlobString(image,\"\\n\");\n        p+=GetPixelChannels(image);\n      }\n      status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n        image->rows);\n      if (status == MagickFalse)\n        break;\n    }\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "filenames": ["coders/txt.c"], "buggy_code_start_loc": [570], "buggy_code_end_loc": [570], "fixing_code_start_loc": [571], "fixing_code_end_loc": [577], "type": "CWE-835", "message": "The ReadTXTImage function in coders/txt.c in ImageMagick through 6.9.9-0 and 7.x through 7.0.6-1 allows remote attackers to cause a denial of service (infinite loop) via a crafted file, because the end-of-file condition is not considered.", "other": {"cve": {"id": "CVE-2017-11523", "sourceIdentifier": "cve@mitre.org", "published": "2017-07-22T21:29:00.227", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The ReadTXTImage function in coders/txt.c in ImageMagick through 6.9.9-0 and 7.x through 7.0.6-1 allows remote attackers to cause a denial of service (infinite loop) via a crafted file, because the end-of-file condition is not considered."}, {"lang": "es", "value": "La funci\u00f3n ReadTXTImage en el archivo coders/txt.c en ImageMagick hasta la versi\u00f3n 6.9.9-0 y versi\u00f3n 7.x hasta 7.0.6-1, permite a los atacantes remotos generar una Denegaci\u00f3n de Servicio (infinite loop) mediante un archivo creado, porque la condici\u00f3n end-of-file no es considerada ."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.1}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.9.9-0", "matchCriteriaId": "FD50817F-6EB7-477D-B5D9-A7E1B10E5FF6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.0-0:*:*:*:*:*:*:*", "matchCriteriaId": "3B7CCC6B-C66E-48E2-BA1E-CBF6421B4FEB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-0:*:*:*:*:*:*:*", "matchCriteriaId": "693C9F8F-A8C1-4D06-8F31-E085E16E701C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-1:*:*:*:*:*:*:*", "matchCriteriaId": "6D3D3DFC-8459-41BA-BF3E-AE84E48FCEE7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-2:*:*:*:*:*:*:*", "matchCriteriaId": "A3E12EB4-B8F6-43A3-847D-DBC96AE10905"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-3:*:*:*:*:*:*:*", "matchCriteriaId": "30539421-5872-4C2E-94AE-8A2B05C952C0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-4:*:*:*:*:*:*:*", "matchCriteriaId": "1A5B7537-8563-409D-82DE-EB07107D3C04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-5:*:*:*:*:*:*:*", "matchCriteriaId": "FA648D3C-A464-4F54-8B5E-E8431531FBB5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-6:*:*:*:*:*:*:*", "matchCriteriaId": "D6666BB0-B211-490F-884C-BE410CD19DAF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-7:*:*:*:*:*:*:*", "matchCriteriaId": "5FF2582D-1513-448B-8B61-9C4844B08324"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-8:*:*:*:*:*:*:*", "matchCriteriaId": "E57E6BA4-A727-4CF5-B15F-76632D02617A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-9:*:*:*:*:*:*:*", "matchCriteriaId": "C721BC6F-61DD-4ED1-8024-2946C494AEC4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-10:*:*:*:*:*:*:*", "matchCriteriaId": "CD319D32-FE7A-456D-AFEE-DC9F0D98652C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-0:*:*:*:*:*:*:*", "matchCriteriaId": "09CDF263-38F5-469F-984B-9D9A223159B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-1:*:*:*:*:*:*:*", "matchCriteriaId": "243FF3C1-D676-4D5F-A90C-3017DCBBE73A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-2:*:*:*:*:*:*:*", "matchCriteriaId": "1B8BDDE6-6B38-442B-83A4-FAADBAE1C792"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-3:*:*:*:*:*:*:*", "matchCriteriaId": "4DCD89B9-6A69-41DE-BE38-5E9193828279"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-4:*:*:*:*:*:*:*", "matchCriteriaId": "139BC277-8E00-4700-8B47-6D3A3CB38B04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-5:*:*:*:*:*:*:*", "matchCriteriaId": "D0FA2E18-6F7B-49D6-B60C-38851398F9B7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-6:*:*:*:*:*:*:*", "matchCriteriaId": "7B7F510A-A439-47A3-AF31-4BF7F74D58A5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-7:*:*:*:*:*:*:*", "matchCriteriaId": "A91B94E3-33BB-46B6-A1AE-EAA9906605CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-8:*:*:*:*:*:*:*", "matchCriteriaId": "F5B3DE17-08A8-457D-9AEB-BD6E04376B34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-9:*:*:*:*:*:*:*", "matchCriteriaId": "98AD438E-28B7-4491-B58F-55FDE7F67CFD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-10:*:*:*:*:*:*:*", "matchCriteriaId": "7E033A09-4F2F-4957-A9A8-5C9E7D90A1CA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-0:*:*:*:*:*:*:*", "matchCriteriaId": "BB9B68E7-0E40-437A-A71B-0C078FE76FD8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-1:*:*:*:*:*:*:*", "matchCriteriaId": "948D5778-AD2A-4293-AE39-A406D75F5678"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-2:*:*:*:*:*:*:*", "matchCriteriaId": "D391DECE-2408-4A8F-ACE6-F18028C422A3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-3:*:*:*:*:*:*:*", "matchCriteriaId": "CC773CB4-0E7B-4D73-AB9C-D7CC98C38BD7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-4:*:*:*:*:*:*:*", "matchCriteriaId": "24A0C584-9DA3-48B0-B152-67B9E0239876"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-5:*:*:*:*:*:*:*", "matchCriteriaId": "E42943C5-CC66-4E88-9085-1BD39937C09B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-6:*:*:*:*:*:*:*", "matchCriteriaId": "E396985D-BE6A-4F4C-B294-FE69724534EF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-7:*:*:*:*:*:*:*", "matchCriteriaId": "D1D84944-322C-4B5D-9B1C-587301747A34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-8:*:*:*:*:*:*:*", "matchCriteriaId": "B48F5327-CA20-4756-A06F-B30B660E8DA7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-9:*:*:*:*:*:*:*", "matchCriteriaId": "84C11EC2-C798-4C3B-8E00-9C70C3499B33"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-10:*:*:*:*:*:*:*", "matchCriteriaId": "D30A3BD6-5903-42D6-A1E3-C6D2FE468A1E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-0:*:*:*:*:*:*:*", "matchCriteriaId": "441F9FAE-11FA-4976-8BB3-4A3A79B57663"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-1:*:*:*:*:*:*:*", "matchCriteriaId": "F4389D4A-8AD4-421E-AD4D-6761F45B7F6B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-2:*:*:*:*:*:*:*", "matchCriteriaId": "1620AF57-49AF-4487-80A1-07627F50F817"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-3:*:*:*:*:*:*:*", "matchCriteriaId": "DF373D13-0AB1-4518-AFFE-D09A5F56E992"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-4:*:*:*:*:*:*:*", "matchCriteriaId": "86483865-BFC3-4845-80DE-A6AC632A92A2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-5:*:*:*:*:*:*:*", "matchCriteriaId": "2A147E12-E5D4-400E-9432-BB5BCF2352CE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-6:*:*:*:*:*:*:*", "matchCriteriaId": "B1F2BF9D-9821-424E-8F06-BFB637C103A7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-7:*:*:*:*:*:*:*", "matchCriteriaId": "26D7231D-442B-4E7C-BCB2-EE8D787FD46D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-8:*:*:*:*:*:*:*", "matchCriteriaId": "749B8733-47B0-4F63-874D-62DF323CD045"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-9:*:*:*:*:*:*:*", "matchCriteriaId": "AD9D1C91-B67A-430B-AB24-DCC7DAF69D7C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-10:*:*:*:*:*:*:*", "matchCriteriaId": "0C5BE761-44E8-4614-BBD4-3FA7148156B0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.5-0:*:*:*:*:*:*:*", "matchCriteriaId": "79AA4723-3637-4FA7-AE60-9CEE7C535A13"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.5-1:*:*:*:*:*:*:*", "matchCriteriaId": "2D1F577A-316C-4ECE-91CB-4C15F12CC63B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.5-4:*:*:*:*:*:*:*", "matchCriteriaId": "68F19A0F-29E9-40A5-B6BB-23C20343CDBE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.5-5:*:*:*:*:*:*:*", "matchCriteriaId": "72A65A02-CD63-4DDD-AFCC-FE6988F85E13"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.5-6:*:*:*:*:*:*:*", "matchCriteriaId": "25690796-E494-4D28-BB4F-AAF40D596AC7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.5-7:*:*:*:*:*:*:*", "matchCriteriaId": "A2C0242E-0292-4DF7-A3FC-BE96DA95E7D4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.5-8:*:*:*:*:*:*:*", "matchCriteriaId": "9F853E8E-1ED2-4BDA-BE60-BBE1F658695B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.6-1:*:*:*:*:*:*:*", "matchCriteriaId": "72A6252A-35A7-4D74-AF0E-0A7B4B12B146"}]}]}], "references": [{"url": "https://bugs.debian.org/869210", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/83e0f8ffd7eeb7661b0ff83257da23d24ca7f078", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/a8f9c2aabed37cd6a728532d1aed13ae0f3dfd78", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/591", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/05/msg00015.html", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2017/dsa-4019", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/83e0f8ffd7eeb7661b0ff83257da23d24ca7f078"}}