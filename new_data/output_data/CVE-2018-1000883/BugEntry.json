{"buggy_code": ["alias Plug.Conn.Unfetched\n\ndefmodule Plug.Conn do\n  @moduledoc \"\"\"\n  The Plug connection.\n\n  This module defines a `Plug.Conn` struct and the main functions\n  for working with Plug connections.\n\n  Note request headers are normalized to lowercase and response\n  headers are expected to have lower-case keys.\n\n  ## Request fields\n\n  These fields contain request information:\n\n    * `host` - the requested host as a binary, example: `\"www.example.com\"`\n    * `method` - the request method as a binary, example: `\"GET\"`\n    * `path_info` - the path split into segments, example: `[\"hello\", \"world\"]`\n    * `script_name` - the initial portion of the URL's path that corresponds to the application\n      routing, as segments, example: [\"sub\",\"app\"].\n    * `request_path` - the requested path, example: `/trailing/and//double//slashes/`\n    * `port` - the requested port as an integer, example: `80`\n    * `peer` - the actual TCP peer that connected, example: `{{127, 0, 0, 1}, 12345}`. Often this\n      is not the actual IP and port of the client, but rather of a load-balancer or request-router.\n    * `remote_ip` - the IP of the client, example: `{151, 236, 219, 228}`. This field is meant to\n      be overwritten by plugs that understand e.g. the `X-Forwarded-For` header or HAProxy's PROXY\n      protocol. It defaults to peer's IP.\n    * `req_headers` - the request headers as a list, example: `[{\"content-type\", \"text/plain\"}]`.\n      Note all headers will be downcased.\n    * `scheme` - the request scheme as an atom, example: `:http`\n    * `query_string` - the request query string as a binary, example: `\"foo=bar\"`\n\n  ## Fetchable fields\n\n  The request information in these fields is not populated until it is fetched\n  using the associated `fetch_` function. For example, the `cookies` field uses\n  `fetch_cookies/2`.\n\n  If you access these fields before fetching them, they will be returned as\n  `Plug.Conn.Unfetched` structs.\n\n    * `cookies`- the request cookies with the response cookies\n    * `body_params` - the request body params, populated through a `Plug.Parsers` parser.\n    * `query_params` - the request query params, populated through `fetch_query_params/2`\n    * `path_params` - the request path params, populated by routers such as `Plug.Router`\n    * `params` - the request params, the result of merging the `:body_params` and `:query_params`\n       with `:path_params`\n    * `req_cookies` - the request cookies (without the response ones)\n\n  ## Response fields\n\n  These fields contain response information:\n\n    * `resp_body` - the response body, by default is an empty string. It is set\n      to nil after the response is set, except for test connections.\n    * `resp_charset` - the response charset, defaults to \"utf-8\"\n    * `resp_cookies` - the response cookies with their name and options\n    * `resp_headers` - the response headers as a list of tuples, by default `cache-control`\n      is set to `\"max-age=0, private, must-revalidate\"`. Note, response headers\n      are expected to have lower-case keys.\n    * `status` - the response status\n\n  Furthermore, the `before_send` field stores callbacks that are invoked\n  before the connection is sent. Callbacks are invoked in the reverse order\n  they are registered (callbacks registered first are invoked last) in order\n  to reproduce a pipeline ordering.\n\n  ## Connection fields\n\n    * `assigns` - shared user data as a map\n    * `owner` - the Elixir process that owns the connection\n    * `halted` - the boolean status on whether the pipeline was halted\n    * `secret_key_base` - a secret key used to verify and encrypt cookies.\n      the field must be set manually whenever one of those features are used.\n      This data must be kept in the connection and never used directly, always\n      use `Plug.Crypto.KeyGenerator.generate/3` to derive keys from it\n    * `state` - the connection state\n\n  The connection state is used to track the connection lifecycle. It starts\n  as `:unset` but is changed to `:set` (via `Plug.Conn.resp/3`) or `:file`\n  (when invoked via `Plug.Conn.send_file/3`). Its final result is\n  `:sent` or `:chunked` depending on the response model.\n\n  ## Private fields\n\n  These fields are reserved for libraries/framework usage.\n\n    * `adapter` - holds the adapter information in a tuple\n    * `private` - shared library data as a map\n\n  ## Protocols\n\n  `Plug.Conn` implements both the Collectable and Inspect protocols\n  out of the box. The inspect protocol provides a nice representation\n  of the connection while the collectable protocol allows developers\n  to easily chunk data. For example:\n\n      # Send the chunked response headers\n      conn = send_chunked(conn, 200)\n\n      # Pipe the given list into a connection\n      # Each item is emitted as a chunk\n      Enum.into(~w(each chunk as a word), conn)\n\n  ## Custom status codes\n\n  Plug allows status codes to be overridden or added in order to allow new codes\n  not directly specified by Plug or its adapters. Adding or overriding a status\n  code is done through the Mix configuration of the `:plug` application. For\n  example, to override the existing 404 reason phrase for the 404 status code\n  (\"Not Found\" by default) and add a new 451 status code, the following config\n  can be specified:\n\n      config :plug, :statuses, %{\n        404 => \"Actually This Was Found\",\n        451 => \"Unavailable For Legal Reasons\"\n      }\n\n  As this configuration is Plug specific, Plug will need to be recompiled for\n  the changes to take place: this will not happen automatically as dependencies\n  are not automatically recompiled when their configuration changes. To recompile\n  Plug:\n\n      mix deps.clean --build plug\n\n  The atoms that can be used in place of the status code in many functions are\n  inflected from the reason phrase of the status code. With the above\n  configuration, the following will all work:\n\n      put_status(conn, :not_found)                     # 404\n      put_status(conn, :actually_this_was_found)       # 404\n      put_status(conn, :unavailable_for_legal_reasons) # 451\n\n  Even though 404 has been overridden, the `:not_found` atom can still be used\n  to set the status to 404 as well as the new atom `:actually_this_was_found`\n  inflected from the reason phrase \"Actually This Was Found\".\n  \"\"\"\n\n  @type adapter         :: {module, term}\n  @type assigns         :: %{atom => any}\n  @type before_send     :: [(t -> t)]\n  @type body            :: iodata\n  @type cookies         :: %{binary => binary}\n  @type halted          :: boolean\n  @type headers         :: [{binary, binary}]\n  @type host            :: binary\n  @type int_status      :: non_neg_integer | nil\n  @type owner           :: pid\n  @type method          :: binary\n  @type param           :: binary | %{binary => param} | [param]\n  @type params          :: %{binary => param}\n  @type peer            :: {:inet.ip_address, :inet.port_number}\n  @type port_number     :: :inet.port_number\n  @type query_string    :: String.t\n  @type resp_cookies    :: %{binary => %{}}\n  @type scheme          :: :http | :https\n  @type secret_key_base :: binary | nil\n  @type segments        :: [binary]\n  @type state           :: :unset | :set | :file | :chunked | :sent\n  @type status          :: atom | int_status\n\n  @type t :: %__MODULE__{\n              adapter:         adapter,\n              assigns:         assigns,\n              before_send:     before_send,\n              body_params:     params | Unfetched.t,\n              cookies:         cookies | Unfetched.t,\n              host:            host,\n              method:          method,\n              owner:           owner,\n              params:          params | Unfetched.t,\n              path_info:       segments,\n              path_params:     params,\n              port:            :inet.port_number,\n              private:         assigns,\n              query_params:    params | Unfetched.t,\n              query_string:    query_string,\n              peer:            peer,\n              remote_ip:       :inet.ip_address,\n              req_cookies:     cookies | Unfetched.t,\n              req_headers:     headers,\n              request_path:    binary,\n              resp_body:       body | nil,\n              resp_cookies:    resp_cookies,\n              resp_headers:    headers,\n              scheme:          scheme,\n              script_name:     segments,\n              secret_key_base: secret_key_base,\n              state:           state,\n              status:          int_status}\n\n  defstruct adapter:         {Plug.Conn, nil},\n            assigns:         %{},\n            before_send:     [],\n            body_params:     %Unfetched{aspect: :body_params},\n            cookies:         %Unfetched{aspect: :cookies},\n            halted:          false,\n            host:            \"www.example.com\",\n            method:          \"GET\",\n            owner:           nil,\n            params:          %Unfetched{aspect: :params},\n            path_params:     %{},\n            path_info:       [],\n            port:            0,\n            private:         %{},\n            query_params:    %Unfetched{aspect: :query_params},\n            query_string:    \"\",\n            peer:            nil,\n            remote_ip:       nil,\n            req_cookies:     %Unfetched{aspect: :cookies},\n            req_headers:     [],\n            request_path:    \"\",\n            resp_body:       nil,\n            resp_cookies:    %{},\n            resp_headers:    [{\"cache-control\", \"max-age=0, private, must-revalidate\"}],\n            scheme:          :http,\n            script_name:     [],\n            secret_key_base: nil,\n            state:           :unset,\n            status:          nil\n\n  defmodule NotSentError do\n    defexception message: \"a response was neither set nor sent from the connection\"\n\n    @moduledoc \"\"\"\n    Error raised when no response is sent in a request\n    \"\"\"\n  end\n\n  defmodule AlreadySentError do\n    defexception message: \"the response was already sent\"\n\n    @moduledoc \"\"\"\n    Error raised when trying to modify or send an already sent response\n    \"\"\"\n  end\n\n  defmodule CookieOverflowError do\n    defexception message: \"cookie exceeds maximum size of 4096 bytes\"\n\n    @moduledoc \"\"\"\n    Error raised when the cookie exceeds the maximum size of 4096 bytes.\n    \"\"\"\n  end\n\n  defmodule InvalidHeaderError do\n    defexception message: \"header is invalid\"\n\n    @moduledoc ~S\"\"\"\n    Error raised when trying to send a header that has errors, for example:\n\n      * the header key contains uppercase chars\n      * the header value contains newlines \\n\n    \"\"\"\n  end\n\n  defmodule InvalidQueryError do\n    @moduledoc \"\"\"\n    Raised when the request string is malformed, for example:\n\n      * the query has bad utf-8 encoding\n      * the query fails to www-form decode\n    \"\"\"\n\n    defexception message: \"query string is invalid\", plug_status: 400\n  end\n\n  alias Plug.Conn\n  @already_sent {:plug_conn, :sent}\n  @unsent [:unset, :set]\n\n  @doc \"\"\"\n  Assigns a value to a key in the connection\n\n  ## Examples\n\n      iex> conn.assigns[:hello]\n      nil\n      iex> conn = assign(conn, :hello, :world)\n      iex> conn.assigns[:hello]\n      :world\n\n  \"\"\"\n  @spec assign(t, atom, term) :: t\n  def assign(%Conn{assigns: assigns} = conn, key, value) when is_atom(key) do\n    %{conn | assigns: Map.put(assigns, key, value)}\n  end\n\n  @doc \"\"\"\n  Starts a task to assign a value to a key in the connection.\n\n  `await_assign/2` can be used to wait for the async task to complete and\n  retrieve the resulting value.\n\n  Behind the scenes, it uses `Task.async/1`.\n\n  ## Examples\n\n      iex> conn.assigns[:hello]\n      nil\n      iex> conn = async_assign(conn, :hello, fn -> :world end)\n      iex> conn.assigns[:hello]\n      %Task{...}\n\n  \"\"\"\n  @spec async_assign(t, atom, (() -> term)) :: t\n  def async_assign(%Conn{} = conn, key, fun) when is_atom(key) and is_function(fun, 0) do\n    assign(conn, key, Task.async(fun))\n  end\n\n  @doc \"\"\"\n  Awaits the completion of an async assign.\n\n  Returns a connection with the value resulting from the async assignment placed\n  under `key` in the `:assigns` field.\n\n  Behind the scenes, it uses `Task.await/2`.\n\n  ## Examples\n\n      iex> conn.assigns[:hello]\n      nil\n      iex> conn = async_assign(conn, :hello, fn -> :world end)\n      iex> conn = await_assign(conn, :hello) # blocks until `conn.assigns[:hello]` is available\n      iex> conn.assigns[:hello]\n      :world\n\n  \"\"\"\n  @spec await_assign(t, atom, timeout) :: t\n  def await_assign(%Conn{} = conn, key, timeout \\\\ 5000) when is_atom(key) do\n    task = Map.fetch!(conn.assigns, key)\n    assign(conn, key, Task.await(task, timeout))\n  end\n\n  @doc \"\"\"\n  Assigns a new **private** key and value in the connection.\n\n  This storage is meant to be used by libraries and frameworks to avoid writing\n  to the user storage (the `:assigns` field). It is recommended for\n  libraries/frameworks to prefix the keys with the library name.\n\n  For example, if some plug needs to store a `:hello` key, it\n  should do so as `:plug_hello`:\n\n      iex> conn.private[:plug_hello]\n      nil\n      iex> conn = put_private(conn, :plug_hello, :world)\n      iex> conn.private[:plug_hello]\n      :world\n\n  \"\"\"\n  @spec put_private(t, atom, term) :: t\n  def put_private(%Conn{private: private} = conn, key, value) when is_atom(key) do\n    %{conn | private: Map.put(private, key, value)}\n  end\n\n  @doc \"\"\"\n  Stores the given status code in the connection.\n\n  The status code can be `nil`, an integer or an atom. The list of allowed\n  atoms is available in `Plug.Conn.Status`.\n\n  Raises a `Plug.Conn.AlreadySentError` if the connection has already been\n  `:sent`.\n  \"\"\"\n  @spec put_status(t, status) :: t\n  def put_status(%Conn{state: :sent}, _status),\n    do: raise AlreadySentError\n  def put_status(%Conn{} = conn, nil),\n    do: %{conn | status: nil}\n  def put_status(%Conn{} = conn, status),\n    do: %{conn | status: Plug.Conn.Status.code(status)}\n\n  @doc \"\"\"\n  Sends a response to the client.\n\n  It expects the connection state to be `:set`, otherwise raises an\n  `ArgumentError` for `:unset` connections or a `Plug.Conn.AlreadySentError` for\n  already `:sent` connections.\n\n  At the end sets the connection state to `:sent`.\n  \"\"\"\n  @spec send_resp(t) :: t | no_return\n  def send_resp(conn)\n\n  def send_resp(%Conn{state: :unset}) do\n    raise ArgumentError, \"cannot send a response that was not set\"\n  end\n\n  def send_resp(%Conn{adapter: {adapter, payload}, state: :set, owner: owner} = conn) do\n    conn = run_before_send(conn, :set)\n    {:ok, body, payload} = adapter.send_resp(payload, conn.status, conn.resp_headers, conn.resp_body)\n    send owner, @already_sent\n    %{conn | adapter: {adapter, payload}, resp_body: body, state: :sent}\n  end\n\n  def send_resp(%Conn{}) do\n    raise AlreadySentError\n  end\n\n  @doc \"\"\"\n  Sends a file as the response body with the given `status`\n  and optionally starting at the given offset until the given length.\n\n  If available, the file is sent directly over the socket using\n  the operating system `sendfile` operation.\n\n  It expects a connection that has not been `:sent` yet and sets its\n  state to `:sent` afterwards. Otherwise raises `Plug.Conn.AlreadySentError`.\n\n  ## Examples\n\n      Plug.Conn.send_file(conn, 200, \"README.md\")\n\n  \"\"\"\n  @spec send_file(t, status, filename :: binary, offset ::integer, length :: integer | :all) :: t | no_return\n  def send_file(conn, status, file, offset \\\\ 0, length  \\\\ :all)\n\n  def send_file(%Conn{state: state}, status, _file, _offset, _length)\n      when not state in @unsent do\n    _ = Plug.Conn.Status.code(status)\n    raise AlreadySentError\n  end\n\n  def send_file(%Conn{adapter: {adapter, payload}, owner: owner} = conn, status, file, offset, length) when is_binary(file) do\n    if file =~ \"\\0\" do\n      raise ArgumentError, \"cannot send_file/5 with null byte\"\n    end\n\n    conn = run_before_send(%{conn | status: Plug.Conn.Status.code(status), resp_body: nil}, :file)\n    {:ok, body, payload} = adapter.send_file(payload, conn.status, conn.resp_headers, file, offset, length)\n    send owner, @already_sent\n    %{conn | adapter: {adapter, payload}, state: :sent, resp_body: body}\n  end\n\n  @doc \"\"\"\n  Sends the response headers as a chunked response.\n\n  It expects a connection that has not been `:sent` yet and sets its\n  state to `:chunked` afterwards. Otherwise raises `Plug.Conn.AlreadySentError`.\n  \"\"\"\n  @spec send_chunked(t, status) :: t | no_return\n  def send_chunked(%Conn{state: state}, status)\n      when not state in @unsent do\n    _ = Plug.Conn.Status.code(status)\n    raise AlreadySentError\n  end\n\n  def send_chunked(%Conn{adapter: {adapter, payload}, owner: owner} = conn, status) do\n    conn = run_before_send(%{conn | status: Plug.Conn.Status.code(status), resp_body: nil}, :chunked)\n    {:ok, body, payload} = adapter.send_chunked(payload, conn.status, conn.resp_headers)\n    send owner, @already_sent\n    %{conn | adapter: {adapter, payload}, resp_body: body}\n  end\n\n  @doc \"\"\"\n  Sends a chunk as part of a chunked response.\n\n  It expects a connection with state `:chunked` as set by\n  `send_chunked/2`. It returns `{:ok, conn}` in case of success,\n  otherwise `{:error, reason}`.\n  \"\"\"\n  @spec chunk(t, body) :: {:ok, t} | {:error, term} | no_return\n  def chunk(%Conn{state: :chunked} = conn, \"\"), do: {:ok, conn}\n  def chunk(%Conn{adapter: {adapter, payload}, state: :chunked} = conn, chunk) do\n    case adapter.chunk(payload, chunk) do\n      :ok                  -> {:ok, conn}\n      {:ok, body, payload} -> {:ok, %{conn | resp_body: body, adapter: {adapter, payload}}}\n      {:error, _} = error  -> error\n    end\n  end\n\n  def chunk(%Conn{}, chunk) when is_binary(chunk) or is_list(chunk) do\n    raise ArgumentError, \"chunk/2 expects a chunked response. Please ensure \" <>\n                         \"you have called send_chunked/2 before you send a chunk\"\n  end\n\n  @doc \"\"\"\n  Sends a response with the given status and body.\n\n  See `send_resp/1` for more information.\n  \"\"\"\n  @spec send_resp(t, status, body) :: t | no_return\n  def send_resp(%Conn{} = conn, status, body) do\n    conn |> resp(status, body) |> send_resp()\n  end\n\n  @doc \"\"\"\n  Sets the response to the given `status` and `body`.\n\n  It sets the connection state to `:set` (if not already `:set`)\n  and raises `Plug.Conn.AlreadySentError` if it was already `:sent`.\n  \"\"\"\n  @spec resp(t, status, body) :: t\n  def resp(%Conn{state: state}, status, _body)\n      when not state in @unsent do\n    _ = Plug.Conn.Status.code(status)\n    raise AlreadySentError\n  end\n\n  def resp(%Conn{}, _status, nil) do\n    raise ArgumentError, \"response body cannot be set to nil\"\n  end\n\n  def resp(%Conn{} = conn, status, body)\n      when is_binary(body) or is_list(body) do\n    %{conn | status: Plug.Conn.Status.code(status), resp_body: body, state: :set}\n  end\n\n  @doc \"\"\"\n  Returns the values of the request header specified by `key`.\n  \"\"\"\n  @spec get_req_header(t, binary) :: [binary]\n  def get_req_header(%Conn{req_headers: headers}, key) when is_binary(key) do\n    for {k, v} <- headers, k == key, do: v\n  end\n\n  @doc \"\"\"\n  Adds a new request header (`key`) if not present, otherwise replaces the\n  previous value of that header with `value`.\n\n  It is recommended for header keys to be in lower-case, to avoid sending\n  duplicate keys in a request. As a convenience, this is validated during\n  testing which raises a `Plug.Conn.InvalidHeaderError` if the header key\n  is not lowercase.\n\n  Raises a `Plug.Conn.AlreadySentError` if the connection has already been\n  `:sent`.\n  \"\"\"\n  @spec put_req_header(t, binary, binary) :: t\n  def put_req_header(%Conn{state: :sent}, _key, _value) do\n    raise AlreadySentError\n  end\n\n  def put_req_header(%Conn{adapter: adapter, req_headers: headers} = conn, key, value) when\n      is_binary(key) and is_binary(value) do\n    validate_header_key!(adapter, key)\n    %{conn | req_headers: List.keystore(headers, key, 0, {key, value})}\n  end\n\n  @doc \"\"\"\n  Deletes a request header if present.\n\n  Raises a `Plug.Conn.AlreadySentError` if the connection has already been\n  `:sent`.\n  \"\"\"\n  @spec delete_req_header(t, binary) :: t\n  def delete_req_header(%Conn{state: :sent}, _key) do\n    raise AlreadySentError\n  end\n\n  def delete_req_header(%Conn{req_headers: headers} = conn, key) when\n      is_binary(key) do\n    %{conn | req_headers: List.keydelete(headers, key, 0)}\n  end\n\n  @doc \"\"\"\n  Updates a request header if present, otherwise it sets it to an initial\n  value.\n\n  Raises a `Plug.Conn.AlreadySentError` if the connection has already been\n  `:sent`.\n  \"\"\"\n  @spec update_req_header(t, binary, binary, (binary -> binary)) :: t\n  def update_req_header(%Conn{state: :sent}, _key, _initial, _fun) do\n    raise AlreadySentError\n  end\n\n  def update_req_header(%Conn{} = conn, key, initial, fun) when\n      is_binary(key) and is_binary(initial) and is_function(fun, 1) do\n    case get_req_header(conn, key) do\n      []          -> put_req_header(conn, key, initial)\n      [current|_] -> put_req_header(conn, key, fun.(current))\n    end\n  end\n\n  @doc \"\"\"\n  Returns the values of the response header specified by `key`.\n\n  ## Examples\n\n      iex> conn = %{conn | resp_headers: [{\"content-type\", \"text/plain\"}]}\n      iex> get_resp_header(conn, \"content-type\")\n      [\"text/plain\"]\n\n  \"\"\"\n  @spec get_resp_header(t, binary) :: [binary]\n  def get_resp_header(%Conn{resp_headers: headers}, key) when is_binary(key) do\n    for {k, v} <- headers, k == key, do: v\n  end\n\n  @doc ~S\"\"\"\n  Adds a new response header (`key`) if not present, otherwise replaces the\n  previous value of that header with `value`.\n\n  It is recommended for header keys to be in lower-case, to avoid sending\n  duplicate keys in a request. As a convenience, this is validated during\n  testing which raises a `Plug.Conn.InvalidHeaderError` if the header key\n  is not lowercase.\n\n  Raises a `Plug.Conn.AlreadySentError` if the connection has already been\n  `:sent`.\n\n  Raises a `Plug.Conn.InvalidHeaderError` if the header value contains control\n  feed (\\r) or newline (\\n) characters.\n  \"\"\"\n  @spec put_resp_header(t, binary, binary) :: t\n  def put_resp_header(%Conn{state: :sent}, _key, _value) do\n    raise AlreadySentError\n  end\n\n  def put_resp_header(%Conn{adapter: adapter, resp_headers: headers} = conn, key, value) when\n      is_binary(key) and is_binary(value) do\n    validate_header_key!(adapter, key)\n    validate_header_value!(value)\n    %{conn | resp_headers: List.keystore(headers, key, 0, {key, value})}\n  end\n\n  @doc \"\"\"\n  Merges a series of response headers into the connection.\n  \"\"\"\n  @spec merge_resp_headers(t, Enum.t) :: t\n  def merge_resp_headers(%Conn{state: :sent}, _headers) do\n    raise AlreadySentError\n  end\n\n  def merge_resp_headers(conn, headers) when headers == %{} do\n    conn\n  end\n\n  def merge_resp_headers(%Conn{resp_headers: current} = conn, headers) do\n    headers =\n      Enum.reduce headers, current, fn\n        {key, value}, acc when is_binary(key) and is_binary(value) ->\n          List.keystore(acc, key, 0, {key, value})\n      end\n    %{conn | resp_headers: headers}\n  end\n\n  @doc \"\"\"\n  Deletes a response header if present.\n\n  Raises a `Plug.Conn.AlreadySentError` if the connection has already been\n  `:sent`.\n  \"\"\"\n  @spec delete_resp_header(t, binary) :: t\n  def delete_resp_header(%Conn{state: :sent}, _key) do\n    raise AlreadySentError\n  end\n\n  def delete_resp_header(%Conn{resp_headers: headers} = conn, key) when\n      is_binary(key) do\n    %{conn | resp_headers: List.keydelete(headers, key, 0)}\n  end\n\n  @doc \"\"\"\n  Updates a response header if present, otherwise it sets it to an initial\n  value.\n\n  Raises a `Plug.Conn.AlreadySentError` if the connection has already been\n  `:sent`.\n  \"\"\"\n  @spec update_resp_header(t, binary, binary, (binary -> binary)) :: t\n  def update_resp_header(%Conn{state: :sent}, _key, _initial, _fun) do\n    raise AlreadySentError\n  end\n\n  def update_resp_header(%Conn{} = conn, key, initial, fun) when\n      is_binary(key) and is_binary(initial) and is_function(fun, 1) do\n    case get_resp_header(conn, key) do\n      []          -> put_resp_header(conn, key, initial)\n      [current|_] -> put_resp_header(conn, key, fun.(current))\n    end\n  end\n\n  @doc \"\"\"\n  Sets the value of the `\"content-type\"` response header taking into account the\n  `charset`.\n  \"\"\"\n  @spec put_resp_content_type(t, binary, binary | nil) :: t\n  def put_resp_content_type(conn, content_type, charset \\\\ \"utf-8\")\n\n  def put_resp_content_type(conn, content_type, nil) when is_binary(content_type) do\n    put_resp_header(conn, \"content-type\", content_type)\n  end\n\n  def put_resp_content_type(conn, content_type, charset) when\n      is_binary(content_type) and is_binary(charset) do\n    put_resp_header(conn, \"content-type\", \"#{content_type}; charset=#{charset}\")\n  end\n\n  @doc \"\"\"\n  Fetches query parameters from the query string.\n\n  This function does not fetch parameters from the body. To fetch\n  parameters from the body, use the `Plug.Parsers` plug.\n  \"\"\"\n  @spec fetch_query_params(t, Keyword.t) :: t\n  def fetch_query_params(conn, opts \\\\ [])\n\n  def fetch_query_params(%Conn{query_params: %Unfetched{}, params: params,\n                               query_string: query_string} = conn, _opts) do\n    Plug.Conn.Utils.validate_utf8!(query_string, InvalidQueryError, \"query string\")\n    query_params = Plug.Conn.Query.decode(query_string)\n\n    case params do\n      %Unfetched{} -> %{conn | query_params: query_params, params: query_params}\n      %{}          -> %{conn | query_params: query_params, params: Map.merge(query_params, params)}\n    end\n  end\n\n  def fetch_query_params(%Conn{} = conn, _opts) do\n    conn\n  end\n\n  @doc \"\"\"\n  Reads the request body.\n\n  This function reads a chunk of the request body up to a given `:length`. If\n  there is more data to be read, then `{:more, partial_body, conn}` is\n  returned. Otherwise `{:ok, body, conn}` is returned. In case of an error\n  reading the socket, `{:error, reason}` is returned as per `:gen_tcp.recv/2`.\n\n  In order to, for instance, support slower clients you can tune the\n  `:read_length` and `:read_timeout` options. These specify how much time should\n  be allowed to pass for each read from the underlying socket.\n\n  Because the request body can be of any size, reading the body will only\n  work once, as Plug will not cache the result of these operations. If you\n  need to access the body multiple times, it is your responsibility to store\n  it. Finally keep in mind some plugs like `Plug.Parsers` may read the body,\n  so the body may be unavailable after being accessed by such plugs.\n\n  This function is able to handle both chunked and identity transfer-encoding\n  by default.\n\n  ## Options\n\n  * `:length` - sets the maximum number of bytes to read from the body for each\n    chunk, defaults to 8_000_000 bytes\n  * `:read_length` - sets the amount of bytes to read at one time from the\n    underlying socket to fill the chunk, defaults to 1_000_000 bytes\n  * `:read_timeout` - sets the timeout for each socket read, defaults to\n    15_000 ms\n\n  The values above are not meant to be exact. For example, setting the\n  length to 8_000_000 may end up reading some hundred bytes more from\n  the socket until we halt.\n\n  ## Examples\n\n      {:ok, body, conn} = Plug.Conn.read_body(conn, length: 1_000_000)\n\n  \"\"\"\n  @spec read_body(t, Keyword.t) :: {:ok, binary, t} |\n                                   {:more, binary, t} |\n                                   {:error, term}\n  def read_body(%Conn{adapter: {adapter, state}} = conn, opts \\\\ []) do\n    case adapter.read_req_body(state, opts) do\n      {:ok, data, state} ->\n        {:ok, data, %{conn | adapter: {adapter, state}}}\n      {:more, data, state} ->\n        {:more, data, %{conn | adapter: {adapter, state}}}\n      {:error, reason} ->\n        {:error, reason}\n    end\n  end\n\n  @doc \"\"\"\n  Fetches cookies from the request headers.\n  \"\"\"\n  @spec fetch_cookies(t, Keyword.t) :: t\n  def fetch_cookies(conn, opts \\\\ [])\n\n  def fetch_cookies(%Conn{req_cookies: %Unfetched{},\n                          resp_cookies: resp_cookies,\n                          req_headers: req_headers} = conn, _opts) do\n    req_cookies =\n      for {\"cookie\", cookie} <- req_headers,\n          kv <- Plug.Conn.Cookies.decode(cookie),\n          into: %{},\n          do: kv\n\n    cookies = Enum.reduce(resp_cookies, req_cookies, fn\n      {key, opts}, acc ->\n        if value = Map.get(opts, :value) do\n          Map.put(acc, key, value)\n        else\n          Map.delete(acc, key)\n        end\n    end)\n\n    %{conn | req_cookies: req_cookies, cookies: cookies}\n  end\n\n  def fetch_cookies(%Conn{} = conn, _opts) do\n    conn\n  end\n\n  @doc \"\"\"\n  Puts a response cookie.\n\n  The cookie value is not automatically escaped. Therefore, if you\n  want to store values with comma, quotes, etc, you need to explicitly\n  escape them or use a function such as `Base.encode64` when writing\n  and `Base.decode64` when reading the cookie.\n\n  ## Options\n\n    * `:domain` - the domain the cookie applies to\n    * `:max_age` - the cookie max-age, in seconds. Providing a value for this\n      option will set both the _max-age_ and _expires_ cookie attributes\n    * `:path` - the path the cookie applies to\n    * `:http_only` - when false, the cookie is accessible beyond http\n    * `:secure` - if the cookie must be sent only over https. Defaults\n      to true when the connection is https\n    * `:extra` - string to append to cookie. Use this to take advantage of\n      non-standard cookie attributes.\n\n  \"\"\"\n  @spec put_resp_cookie(t, binary, binary, Keyword.t) :: t\n  def put_resp_cookie(%Conn{resp_cookies: resp_cookies, scheme: scheme} = conn, key, value, opts \\\\ []) when\n      is_binary(key) and is_binary(value) and is_list(opts) do\n    cookie = [{:value, value}|opts] |> :maps.from_list() |> maybe_secure_cookie(scheme)\n    resp_cookies = Map.put(resp_cookies, key, cookie)\n    update_cookies(%{conn | resp_cookies: resp_cookies}, &Map.put(&1, key, value))\n  end\n\n  defp maybe_secure_cookie(cookie, :https), do: Map.put_new(cookie, :secure, true)\n  defp maybe_secure_cookie(cookie, _),      do: cookie\n\n  @epoch {{1970, 1, 1}, {0, 0, 0}}\n\n  @doc \"\"\"\n  Deletes a response cookie.\n\n  Deleting a cookie requires the same options as to when the cookie was put.\n  Check `put_resp_cookie/4` for more information.\n  \"\"\"\n  @spec delete_resp_cookie(t, binary, Keyword.t) :: t\n  def delete_resp_cookie(%Conn{resp_cookies: resp_cookies} = conn, key, opts \\\\ []) when\n      is_binary(key) and is_list(opts) do\n    opts = [universal_time: @epoch, max_age: 0] ++ opts\n    resp_cookies = Map.put(resp_cookies, key, :maps.from_list(opts))\n    update_cookies(%{conn | resp_cookies: resp_cookies}, &Map.delete(&1, key))\n  end\n\n  @doc \"\"\"\n  Fetches the session from the session store. Will also fetch cookies.\n  \"\"\"\n  @spec fetch_session(t, Keyword.t) :: t\n  def fetch_session(conn, opts \\\\ [])\n\n  def fetch_session(%Conn{private: private} = conn, _opts) do\n    case Map.fetch(private, :plug_session_fetch) do\n      {:ok, :done} -> conn\n      {:ok, fun} -> conn |> fetch_cookies |> fun.()\n      :error -> raise ArgumentError, \"cannot fetch session without a configured session plug\"\n    end\n  end\n\n  @doc \"\"\"\n  Puts the specified `value` in the session for the given `key`.\n\n  The key can be a string or an atom, where atoms are\n  automatically converted to strings. Can only be invoked\n  on unsent `conn`s. Will raise otherwise.\n  \"\"\"\n  @spec put_session(t, String.t | atom, any) :: t\n  def put_session(%Conn{state: state}, _key, _value) when not state in @unsent,\n    do: raise AlreadySentError\n  def put_session(conn, key, value) do\n    put_session(conn, &Map.put(&1, session_key(key), value))\n  end\n\n  @doc \"\"\"\n  Returns session value for the given `key`.\n\n  The key can be a string or an atom, where atoms are\n  automatically converted to strings.\n  \"\"\"\n  @spec get_session(t, String.t | atom) :: any\n  def get_session(conn, key) do\n    conn |> get_session |> Map.get(session_key(key))\n  end\n\n  @doc \"\"\"\n  Deletes the session for the given `key`.\n\n  The key can be a string or an atom, where atoms are\n  automatically converted to strings.\n  \"\"\"\n  @spec delete_session(t, String.t | atom) :: t\n  def delete_session(%Conn{state: state}, _key) when not state in @unsent,\n    do: raise AlreadySentError\n  def delete_session(conn, key) do\n    put_session(conn, &Map.delete(&1, session_key(key)))\n  end\n\n  @doc \"\"\"\n  Clears the entire session.\n\n  This function removes every key from the session, clearing the session.\n\n  Note that, even if `clear_session/1` is used, the session is still sent to the\n  client. If the session should be effectively *dropped*, `configure_session/2`\n  should be used with the `:drop` option set to `true`.\n  \"\"\"\n  @spec clear_session(t) :: t\n  def clear_session(conn) do\n    put_session(conn, fn(_existing) -> Map.new end)\n  end\n\n  @doc \"\"\"\n  Configures the session.\n\n  ## Options\n\n    * `:renew` - generates a new session id for the cookie\n    * `:drop` - drops the session, a session cookie will not be included in the\n      response\n    * `:ignore` - ignores all changes made to the session in this request cycle\n\n  \"\"\"\n  @spec configure_session(t, Keyword.t) :: t\n  def configure_session(%Conn{state: state}, _opts) when not state in @unsent,\n    do: raise AlreadySentError\n  def configure_session(conn, opts) do\n    # Ensure the session is available.\n    _ = get_session(conn)\n\n    cond do\n      opts[:renew]  -> put_private(conn, :plug_session_info, :renew)\n      opts[:drop]   -> put_private(conn, :plug_session_info, :drop)\n      opts[:ignore] -> put_private(conn, :plug_session_info, :ignore)\n      true          -> conn\n    end\n  end\n\n  @doc \"\"\"\n  Registers a callback to be invoked before the response is sent.\n\n  Callbacks are invoked in the reverse order they are defined (callbacks\n  defined first are invoked last).\n  \"\"\"\n  @spec register_before_send(t, (t -> t)) :: t\n  def register_before_send(%Conn{state: state}, _callback)\n      when not state in @unsent do\n    raise AlreadySentError\n  end\n\n  def register_before_send(%Conn{before_send: before_send} = conn, callback)\n      when is_function(callback, 1) do\n    %{conn | before_send: [callback|before_send]}\n  end\n\n  @doc \"\"\"\n  Halts the Plug pipeline by preventing further plugs downstream from being\n  invoked. See the docs for `Plug.Builder` for more information on halting a\n  plug pipeline.\n  \"\"\"\n  @spec halt(t) :: t\n  def halt(%Conn{} = conn) do\n    %{conn | halted: true}\n  end\n\n  ## Helpers\n\n  defp run_before_send(%Conn{before_send: before_send} = conn, new) do\n    conn = Enum.reduce before_send, %{conn | state: new}, &(&1.(&2))\n    if conn.state != new do\n      raise ArgumentError, \"cannot send/change response from run_before_send callback\"\n    end\n    %{conn | resp_headers: merge_headers(conn.resp_headers, conn.resp_cookies)}\n  end\n\n  defp merge_headers(headers, cookies) do\n    Enum.reduce(cookies, headers, fn {key, opts}, acc ->\n      value =\n        key\n        |> Plug.Conn.Cookies.encode(opts)\n        |> verify_cookie!(key)\n      [{\"set-cookie\", value}|acc]\n    end)\n  end\n\n  defp verify_cookie!(cookie, key) when byte_size(cookie) > 4096 do\n    raise Plug.Conn.CookieOverflowError,\n          \"cookie named #{inspect key} exceeds maximum size of 4096 bytes\"\n  end\n  defp verify_cookie!(cookie, _key) do\n    cookie\n  end\n\n  defp update_cookies(%Conn{state: :sent}, _fun),\n    do: raise AlreadySentError\n  defp update_cookies(%Conn{cookies: %Unfetched{}} = conn, _fun),\n    do: conn\n  defp update_cookies(%Conn{cookies: cookies} = conn, fun),\n    do: %{conn | cookies: fun.(cookies)}\n\n  defp session_key(binary) when is_binary(binary), do: binary\n  defp session_key(atom) when is_atom(atom), do: Atom.to_string(atom)\n\n  defp get_session(%Conn{private: private}) do\n    if session = Map.get(private, :plug_session) do\n      session\n    else\n      raise ArgumentError, \"session not fetched, call fetch_session/2\"\n    end\n  end\n\n  defp put_session(conn, fun) do\n    private = conn.private\n              |> Map.put(:plug_session, fun.(get_session(conn)))\n              |> Map.put_new(:plug_session_info, :write)\n\n    %{conn | private: private}\n  end\n\n  defp validate_header_key!({Plug.Adapters.Test.Conn, _}, key) do\n    unless valid_header_key?(key) do\n      raise InvalidHeaderError, \"header key is not lowercase: \" <> inspect(key)\n    end\n  end\n\n  defp validate_header_key!(_adapter, _key) do\n    :ok\n  end\n\n  # Any string containing an UPPERCASE char is not valid.\n  defp valid_header_key?(<<h, _::binary>>) when h in ?A..?Z, do: false\n  defp valid_header_key?(<<_, t::binary>>), do: valid_header_key?(t)\n  defp valid_header_key?(<<>>), do: true\n  defp valid_header_key?(_), do: false\n\n  defp validate_header_value!(value) do\n    case :binary.match(value, [\"\\n\", \"\\r\"]) do\n      {_, _}   -> raise InvalidHeaderError, \"header value contains control feed (\\\\r) or newline (\\\\n): \" <> inspect(value)\n      :nomatch -> :ok\n    end\n  end\nend\n\ndefimpl Inspect, for: Plug.Conn do\n  def inspect(conn, opts) do\n    conn =\n      if opts.limit == :infinity do\n        conn\n      else\n        update_in conn.adapter, fn {adapter, _data} -> {adapter, :...} end\n      end\n\n    Inspect.Any.inspect(conn, opts)\n  end\nend\n\ndefimpl Collectable, for: Plug.Conn do\n  def into(conn) do\n    {conn, fn\n      conn, {:cont, x} ->\n        {:ok, conn} = Plug.Conn.chunk(conn, x)\n        conn\n      conn, _ ->\n        conn\n    end}\n  end\nend\n", "defmodule Plug.ConnTest do\n  use ExUnit.Case, async: true\n  use Plug.Test\n\n  alias Plug.Conn\n  alias Plug.ProcessStore\n\n  test \"test adapter builds on connection\" do\n    conn = Plug.Adapters.Test.Conn.conn(%Plug.Conn{private: %{hello: :world}}, :post, \"/hello\", nil)\n    assert conn.method == \"POST\"\n    assert conn.path_info == [\"hello\"]\n    assert conn.private.hello == :world\n  end\n\n  test \"test adapter stores body in process before sending\" do\n    # The order of the lines below matters since we are testing if sent_body/1\n    # is returning the correct body even if they have the same owner process\n    conn = send_resp(conn(:get, \"/foo\"), 200, \"HELLO\")\n    another_conn = send_resp(conn(:get, \"/foo\"), 404, \"TEST\")\n\n    {status, _headers, body} = sent_resp(another_conn)\n    assert status == 404\n    assert body == \"TEST\"\n\n    {status, _headers, body} = sent_resp(conn)\n    assert status == 200\n    assert body == \"HELLO\"\n  end\n\n  test \"twice sending a response\" do\n    conn = conn(:get, \"/foo\")\n    send_resp(conn, 204, \"\")\n    send_resp(conn, 200, \"HELLO\")\n\n    assert_raise RuntimeError, ~r/sent more than once/, fn ->\n      sent_resp(conn)\n    end\n  end\n\n  test \"inspect/2\" do\n    assert inspect(conn(:get, \"/\")) =~ \"{Plug.Adapters.Test.Conn, :...}\"\n    refute inspect(conn(:get, \"/\"), limit: :infinity) =~ \"{Plug.Adapters.Test.Conn, :...}\"\n  end\n\n  test \"assign/3\" do\n    conn = conn(:get, \"/\")\n    assert conn.assigns[:hello] == nil\n    conn = assign(conn, :hello, :world)\n    assert conn.assigns[:hello] == :world\n  end\n\n  test \"async_assign/3 and await_assign/3\" do\n    conn = conn(:get, \"/\")\n    assert conn.assigns[:hello] == nil\n    conn = async_assign(conn, :hello, fn -> :world end)\n    conn = await_assign(conn, :hello)\n    assert conn.assigns[:hello] == :world\n  end\n\n  test \"put_status/2\" do\n    conn = conn(:get, \"/\")\n    assert put_status(conn, nil).status == nil\n    assert put_status(conn, 200).status == 200\n    assert put_status(conn, :ok).status == 200\n  end\n\n  test \"put_status/2 raises when the connection had already been sent\" do\n    conn = send_resp(conn(:get, \"/\"), 200, \"foo\")\n\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      put_status(conn, 200)\n    end\n\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      put_status(conn, nil)\n    end\n  end\n\n  test \"put_private/3\" do\n    conn = conn(:get, \"/\")\n    assert conn.private[:hello] == nil\n    conn = put_private(conn, :hello, :world)\n    assert conn.private[:hello] == :world\n  end\n\n  test \"scheme, host and port fields\" do\n    conn = conn(:get, \"/\")\n    assert conn.scheme == :http\n    assert conn.host == \"www.example.com\"\n    assert conn.port == 80\n\n    conn = conn(:get, \"https://127.0.0.1/\")\n    assert conn.scheme == :https\n    assert conn.host == \"127.0.0.1\"\n    assert conn.port == 443\n\n    conn = conn(:get, \"//example.com:8080/\")\n    assert conn.scheme == :http\n    assert conn.host == \"example.com\"\n    assert conn.port == 8080\n  end\n\n  test \"peer and remote_ip fields\" do\n    conn = conn(:get, \"/\")\n    assert conn.peer == {{127, 0, 0, 1}, 111_317}\n    assert conn.remote_ip == {127, 0, 0, 1}\n  end\n\n  test \"path_info\" do\n    assert conn(:get, \"/foo/bar\").path_info == ~w(foo bar)s\n    assert conn(:get, \"/foo/bar/\").path_info == ~w(foo bar)s\n    assert conn(:get, \"/foo//bar\").path_info == ~w(foo bar)s\n  end\n\n  test \"query_string\" do\n    assert conn(:get, \"/\").query_string == \"\"\n    assert conn(:get, \"/foo?barbat\").query_string == \"barbat\"\n    assert conn(:get, \"/foo/bar?bar=bat\").query_string == \"bar=bat\"\n  end\n\n  test \"request_path\" do\n    assert conn(:get, \"/\").request_path == \"/\"\n    assert conn(:get, \"/foo?barbat\").request_path == \"/foo\"\n    assert conn(:get, \"/foo/bar?bar=bat\").request_path == \"/foo/bar\"\n    assert conn(:get, \"/foo/bar/?bar=bat\").request_path == \"/foo/bar/\"\n    assert conn(:get, \"/foo//bar\").request_path == \"/foo//bar\"\n    assert conn(:get, \"/foo//bar//\").request_path == \"/foo//bar//\"\n  end\n\n  test \"status, resp_headers and resp_body\" do\n    conn = conn(:get, \"/foo\")\n    assert conn.status == nil\n    assert conn.resp_headers == [{\"cache-control\", \"max-age=0, private, must-revalidate\"}]\n    assert conn.resp_body == nil\n  end\n\n  test \"resp/3\" do\n    conn = conn(:get, \"/foo\")\n    assert conn.state == :unset\n    conn = resp(conn, 200, \"HELLO\")\n    assert conn.state == :set\n    assert conn.status == 200\n    assert conn.resp_body == \"HELLO\"\n\n    conn = resp(conn, :not_found, \"WORLD\")\n    assert conn.state == :set\n    assert conn.status == 404\n    assert conn.resp_body == \"WORLD\"\n  end\n\n  test \"resp/3 raises when connection was already sent\" do\n    conn = send_resp(conn(:head, \"/foo\"), 200, \"HELLO\")\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      resp(conn, 200, \"OTHER\")\n    end\n  end\n\n  test \"resp/3 raises when body is nil\" do\n    conn = conn(:head, \"/foo\")\n    assert_raise ArgumentError, fn ->\n      resp(conn, 200, nil)\n    end\n  end\n\n  test \"send_resp/3\" do\n    conn = conn(:get, \"/foo\")\n    assert conn.state == :unset\n    assert conn.resp_body == nil\n    conn = send_resp(conn, 200, \"HELLO\")\n    assert conn.status == 200\n    assert conn.resp_body == \"HELLO\"\n    assert conn.state == :sent\n  end\n\n  test \"send_resp/3 sends owner a message\" do\n    refute_received {:plug_conn, :sent}\n    send_resp(conn(:get, \"/foo\"), 200, \"HELLO\")\n    assert_received {:plug_conn, :sent}\n    resp(conn(:get, \"/foo\"), 200, \"HELLO\")\n    refute_received {:plug_conn, :sent}\n  end\n\n  test \"send_resp/3 does not send on head\" do\n    conn = send_resp(conn(:head, \"/foo\"), 200, \"HELLO\")\n    assert conn.resp_body == \"\"\n  end\n\n  test \"send_resp/3 raises when connection was already sent\" do\n    conn = send_resp(conn(:head, \"/foo\"), 200, \"HELLO\")\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      send_resp(conn, 200, \"OTHER\")\n    end\n  end\n\n  test \"send_resp/3 allows for iolist in the resp body\" do\n    refute_received {:plug_conn, :sent}\n    conn = send_resp(conn(:get, \"/foo\"), 200, [\"this \", [\"is\", \" nested\"]])\n    assert_received {:plug_conn, :sent}\n    assert conn.resp_body == \"this is nested\"\n  end\n\n  test \"send_resp/3 runs before_send callbacks\" do\n    conn = conn(:get, \"/foo\")\n           |> register_before_send(&put_resp_header(&1, \"x-body\", &1.resp_body))\n           |> register_before_send(&put_resp_header(&1, \"x-body\", \"default\"))\n           |> send_resp(200, \"body\")\n\n    assert get_resp_header(conn, \"x-body\") == [\"body\"]\n  end\n\n  test \"send_resp/3 uses the before_send status and body\" do\n    conn = conn(:get, \"/foo\")\n           |> register_before_send(&resp(&1, 200, \"new body\"))\n           |> send_resp(204, \"\")\n\n    assert conn.status == 200\n    assert conn.resp_body == \"new body\"\n  end\n\n  test \"send_resp/3 uses the before_send cookies\" do\n    conn = conn(:get, \"/foo\")\n           |> register_before_send(&put_resp_cookie(&1, \"hello\", \"world\"))\n           |> send_resp(200, \"\")\n\n    assert conn.resp_cookies[\"hello\"] == %{value: \"world\"}\n  end\n\n  test \"send_resp/1 raises if the connection was unset\" do\n    conn = conn(:get, \"/goo\")\n    assert_raise ArgumentError, fn ->\n      send_resp(conn)\n    end\n  end\n\n  test \"send_resp/1 raises if the connection was already sent\" do\n    conn = send_resp(conn(:get, \"/boo\") , 200, \"ok\")\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      send_resp(conn)\n    end\n  end\n\n  test \"send_file/3\" do\n    conn = send_file(conn(:get, \"/foo\"), 200, __ENV__.file)\n    assert conn.status == 200\n    assert conn.resp_body =~ \"send_file/3\"\n    assert conn.state == :sent\n  end\n\n  test \"send_file/3 raises on null-byte\" do\n    assert_raise ArgumentError, fn ->\n      send_file(conn(:get, \"/foo\"), 200, \"foo.md\\0.html\")\n    end\n  end\n\n  test \"send_file/3 sends self a message\" do\n    refute_received {:plug_conn, :sent}\n    send_file(conn(:get, \"/foo\"), 200, __ENV__.file)\n    assert_received {:plug_conn, :sent}\n  end\n\n  test \"send_file/3 does not send on head\" do\n    conn = send_file(conn(:head, \"/foo\"), 200, __ENV__.file)\n    assert conn.resp_body == \"\"\n  end\n\n  test \"send_file/3 raises when connection was already sent\" do\n    conn = send_file(conn(:head, \"/foo\"), 200, __ENV__.file)\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      send_file(conn, 200, __ENV__.file)\n    end\n  end\n\n  test \"send_file/3 runs before_send callbacks\" do\n    conn = conn(:get, \"/foo\")\n           |> register_before_send(&put_resp_header(&1, \"x-body\", &1.resp_body || \"FILE\"))\n           |> send_file(200, __ENV__.file)\n\n    assert get_resp_header(conn, \"x-body\") == [\"FILE\"]\n  end\n\n  test \"send_file/5 limits on offset\" do\n    %File.Stat{type: :regular, size: size} = File.stat!(__ENV__.file)\n    :rand.seed(:exs64)\n    offset = round(:rand.uniform() * size)\n    conn = send_file(conn(:get, \"/foo\"), 206, __ENV__.file, offset)\n    assert conn.status == 206\n    assert conn.state == :sent\n    assert byte_size(conn.resp_body) == (size - offset)\n  end\n\n  test \"send_file/5 limits on offset and length\" do\n    %File.Stat{type: :regular, size: size} = File.stat!(__ENV__.file)\n    :rand.seed(:exs64)\n    offset = round(:rand.uniform() * size)\n    length = round((size - offset) * 0.25)\n    conn = send_file(conn(:get, \"/foo\"), 206, __ENV__.file, offset, length)\n    assert conn.status == 206\n    assert conn.state == :sent\n    assert byte_size(conn.resp_body) == length\n  end\n\n  test \"send_chunked/3\" do\n    conn = send_chunked(conn(:get, \"/foo\"), 200)\n    assert conn.status == 200\n    assert conn.resp_body == \"\"\n    {:ok, conn} = chunk(conn, \"HELLO\\n\")\n    assert conn.resp_body == \"HELLO\\n\"\n    {:ok, conn} = chunk(conn, [\"WORLD\", [\"\\n\"]])\n    assert conn.resp_body == \"HELLO\\nWORLD\\n\"\n  end\n\n  test \"send_chunked/3 with collectable\" do\n    conn = send_chunked(conn(:get, \"/foo\"), 200)\n    conn = Enum.into(~w(hello world), conn)\n    assert conn.resp_body == \"helloworld\"\n  end\n\n  test \"send_chunked/3 sends self a message\" do\n    refute_received {:plug_conn, :sent}\n    send_chunked(conn(:get, \"/foo\"), 200)\n    assert_received {:plug_conn, :sent}\n  end\n\n  test \"send_chunked/3 does not send on head\" do\n    {:ok, conn} = conn(:head, \"/foo\") |> send_chunked(200) |> chunk(\"HELLO\")\n    assert conn.resp_body == \"\"\n  end\n\n  test \"send_chunked/3 raises when connection was already sent\" do\n    conn = send_chunked(conn(:head, \"/foo\"), 200)\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      send_chunked(conn, 200)\n    end\n  end\n\n  test \"send_chunked/3 runs before_send callbacks\" do\n    conn = conn(:get, \"/foo\")\n           |> register_before_send(&put_resp_header(&1, \"x-body\", &1.resp_body || \"CHUNK\"))\n           |> send_chunked(200)\n\n    assert get_resp_header(conn, \"x-body\") == [\"CHUNK\"]\n  end\n\n  test \"chunk/2 raises if send_chunked/3 hasn't been called yet\" do\n    conn = conn(:get, \"/\")\n    assert_raise ArgumentError, fn ->\n      chunk(conn, \"foobar\")\n    end\n  end\n\n  test \"put_resp_header/3\" do\n    conn1 = put_resp_header(conn(:head, \"/foo\"), \"x-foo\", \"bar\")\n    assert get_resp_header(conn1, \"x-foo\") == [\"bar\"]\n    conn2 = put_resp_header(conn1, \"x-foo\", \"baz\")\n    assert get_resp_header(conn2, \"x-foo\") == [\"baz\"]\n    assert length(conn1.resp_headers) ==\n           length(conn2.resp_headers)\n  end\n\n  test \"put_resp_header/3 raises when the conn was already been sent\" do\n    conn = send_resp(conn(:get, \"/foo\"), 200, \"ok\")\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      put_resp_header(conn, \"x-foo\", \"bar\")\n    end\n  end\n\n  test \"put_resp_header/3 raises when invalid header key given\" do\n    conn = conn(:get, \"/foo\")\n    assert_raise Plug.Conn.InvalidHeaderError, ~S[header key is not lowercase: \"X-Foo\"], fn ->\n      put_resp_header(conn, \"X-Foo\", \"bar\")\n    end\n  end\n\n  test \"put_resp_header/3 raises when invalid header value given\" do\n    assert_raise Plug.Conn.InvalidHeaderError, ~S[header value contains control feed (\\r) or newline (\\n): \"value\\rBAR\"], fn ->\n      put_resp_header(conn(:get, \"foo\"), \"x-sample\", \"value\\rBAR\")\n    end\n\n    assert_raise Plug.Conn.InvalidHeaderError, ~S[header value contains control feed (\\r) or newline (\\n): \"value\\n\\nBAR\"], fn ->\n      put_resp_header(conn(:get, \"foo\"), \"x-sample\", \"value\\n\\nBAR\")\n    end\n  end\n\n  test \"merge_resp_headers/3\" do\n    conn1 = merge_resp_headers(conn(:head, \"/foo\"), %{\"x-foo\" => \"bar\", \"x-bar\" => \"baz\"})\n    assert get_resp_header(conn1, \"x-foo\") == [\"bar\"]\n    assert get_resp_header(conn1, \"x-bar\") == [\"baz\"]\n    conn2 = merge_resp_headers(conn1, %{\"x-foo\" => \"new\"})\n    assert get_resp_header(conn2, \"x-foo\") == [\"new\"]\n    assert get_resp_header(conn2, \"x-bar\") == [\"baz\"]\n    assert length(conn1.resp_headers) ==\n           length(conn2.resp_headers)\n  end\n\n  test \"delete_resp_header/2\" do\n    conn = put_resp_header(conn(:head, \"/foo\"), \"x-foo\", \"bar\")\n    assert get_resp_header(conn, \"x-foo\") == [\"bar\"]\n    conn = delete_resp_header(conn, \"x-foo\")\n    assert get_resp_header(conn, \"x-foo\") == []\n  end\n\n  test \"delete_resp_header/2 raises when the conn was already been sent\" do\n    conn = send_resp(conn(:head, \"/foo\"), 200, \"ok\")\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      delete_resp_header(conn, \"x-foo\")\n    end\n  end\n\n  test \"update_resp_header/4\" do\n    conn1 = put_resp_header(conn(:head, \"/foo\"), \"x-foo\", \"bar\")\n    conn2 = update_resp_header(conn1, \"x-foo\", \"bong\", &(&1 <> \", baz\"))\n    assert get_resp_header(conn2, \"x-foo\") == [\"bar, baz\"]\n    assert length(conn1.resp_headers) == length(conn2.resp_headers)\n\n    conn1 = conn(:head, \"/foo\")\n    conn2 = update_resp_header(conn1, \"x-foo\", \"bong\", &(&1 <> \", baz\"))\n    assert get_resp_header(conn2, \"x-foo\") == [\"bong\"]\n\n    conn1 = %{conn(:head, \"/foo\") | resp_headers:\n      [{\"x-foo\", \"foo\"}, {\"x-foo\", \"bar\"}]}\n    conn2 = update_resp_header(conn1, \"x-foo\", \"in\", &String.upcase/1)\n    assert get_resp_header(conn2, \"x-foo\") == [\"FOO\", \"bar\"]\n  end\n\n  test \"update_resp_header/4 raises when the conn was already been sent\" do\n    conn = send_resp(conn(:head, \"/foo\"), 200, \"ok\")\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      update_resp_header(conn, \"x-foo\", \"init\", &(&1))\n    end\n  end\n\n  test \"put_resp_content_type/3\" do\n    conn = conn(:head, \"/foo\")\n\n    assert {\"content-type\", \"text/html; charset=utf-8\"} in\n           put_resp_content_type(conn, \"text/html\").resp_headers\n\n    assert {\"content-type\", \"text/html; charset=iso\"} in\n           put_resp_content_type(conn, \"text/html\", \"iso\").resp_headers\n\n    assert {\"content-type\", \"text/html\"} in\n           put_resp_content_type(conn, \"text/html\", nil).resp_headers\n  end\n\n  test \"resp/3 and send_resp/1\" do\n    conn = resp(conn(:get, \"/foo\"), 200, \"HELLO\")\n    assert conn.status == 200\n    assert conn.resp_body == \"HELLO\"\n\n    conn = send_resp(conn)\n    assert conn.status == 200\n    assert conn.resp_body == \"HELLO\"\n  end\n\n  test \"get_req_header/2, put_req_header/3 and delete_req_header/2\" do\n    conn = conn(:get, \"/\")\n    assert get_req_header(conn, \"foo\") == []\n\n    conn = put_req_header(conn, \"foo\", \"bar\")\n    assert get_req_header(conn, \"foo\") == [\"bar\"]\n\n    conn = put_req_header(conn, \"foo\", \"baz\")\n    assert get_req_header(conn, \"foo\") == [\"baz\"]\n\n    conn = delete_req_header(conn, \"foo\")\n    assert get_req_header(conn, \"foo\") == []\n  end\n\n  test \"put_req_header/3\" do\n    conn1 = put_req_header(conn(:head, \"/foo\"), \"x-foo\", \"bar\")\n    assert get_req_header(conn1, \"x-foo\") == [\"bar\"]\n    conn2 = put_req_header(conn1, \"x-foo\", \"baz\")\n    assert get_req_header(conn2, \"x-foo\") == [\"baz\"]\n    assert length(conn1.req_headers) ==\n           length(conn2.req_headers)\n  end\n\n  test \"put_req_header/3 raises when the conn was already been sent\" do\n    conn = send_resp(conn(:get, \"/foo\"), 200, \"ok\")\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      put_req_header(conn, \"x-foo\", \"bar\")\n    end\n  end\n\n  test \"put_req_header/3 raises when invalid header key given\" do\n    conn = conn(:get, \"/foo\")\n    assert_raise Plug.Conn.InvalidHeaderError, ~S[header key is not lowercase: \"X-Foo\"], fn ->\n      put_req_header(conn, \"X-Foo\", \"bar\")\n    end\n  end\n\n  test \"delete_req_header/2\" do\n    conn = put_req_header(conn(:head, \"/foo\"), \"x-foo\", \"bar\")\n    assert get_req_header(conn, \"x-foo\") == [\"bar\"]\n    conn = delete_req_header(conn, \"x-foo\")\n    assert get_req_header(conn, \"x-foo\") == []\n  end\n\n  test \"delete_req_header/2 raises when the conn was already been sent\" do\n    conn = send_resp(conn(:head, \"/foo\"), 200, \"ok\")\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      delete_req_header(conn, \"x-foo\")\n    end\n  end\n\n  test \"update_req_header/4\" do\n    conn1 = put_req_header(conn(:head, \"/foo\"), \"x-foo\", \"bar\")\n    conn2 = update_req_header(conn1, \"x-foo\", \"bong\", &(&1 <> \", baz\"))\n    assert get_req_header(conn2, \"x-foo\") == [\"bar, baz\"]\n    assert length(conn1.req_headers) == length(conn2.req_headers)\n\n    conn1 = conn(:head, \"/foo\")\n    conn2 = update_req_header(conn1, \"x-foo\", \"bong\", &(&1 <> \", baz\"))\n    assert get_req_header(conn2, \"x-foo\") == [\"bong\"]\n\n    conn1 = %{conn(:head, \"/foo\") | req_headers:\n      [{\"x-foo\", \"foo\"}, {\"x-foo\", \"bar\"}]}\n    conn2 = update_req_header(conn1, \"x-foo\", \"in\", &String.upcase/1)\n    assert get_req_header(conn2, \"x-foo\") == [\"FOO\", \"bar\"]\n  end\n\n  test \"update_req_header/4 raises when the conn was already been sent\" do\n    conn = send_resp(conn(:head, \"/foo\"), 200, \"ok\")\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      update_req_header(conn, \"x-foo\", \"init\", &(&1))\n    end\n  end\n\n  test \"read_body/1\" do\n    body = :binary.copy(\"abcdefghij\", 1000)\n    conn = put_req_header(conn(:post, \"/foo\", body), \"content-type\", \"text/plain\")\n    assert {:ok, ^body, conn} = read_body(conn)\n    assert {:ok, \"\", _} = read_body(conn)\n  end\n\n  test \"read_body/2 partial retrieval\" do\n    body = :binary.copy(\"abcdefghij\", 100)\n    conn = put_req_header(conn(:post, \"/foo\", body), \"content-type\", \"text/plain\")\n    assert {:more, _, _} = read_body(conn, length: 100)\n  end\n\n  test \"query_params/1 and fetch_query_params/1\" do\n    conn = conn(:get, \"/foo?a=b&c=d\")\n    assert conn.query_params == %Plug.Conn.Unfetched{aspect: :query_params}\n    conn = fetch_query_params(conn)\n    assert conn.query_params == %{\"a\" => \"b\", \"c\" => \"d\"}\n\n    conn = fetch_query_params(conn(:get, \"/foo\"), []) # Pluggable\n    assert conn.query_params == %{}\n  end\n\n  test \"query_params/1, params/1 and fetch_query_params/1\" do\n    conn = conn(:get, \"/foo?a=b&c=d\")\n    assert conn.params == %Plug.Conn.Unfetched{aspect: :params}\n    conn = fetch_query_params(conn)\n    assert conn.params == %{\"a\" => \"b\", \"c\" => \"d\"}\n\n    conn = conn(:get, \"/foo?a=b&c=d\")\n    conn = put_in conn.params, %{\"a\" => \"z\"}\n    conn = fetch_query_params(conn)\n    assert conn.params == %{\"a\" => \"z\", \"c\" => \"d\"}\n  end\n\n  test \"fetch_query_params/1 with invalid utf-8\" do\n    conn = conn(:get, \"/foo?a=\" <> <<139>>)\n    assert_raise Plug.Conn.InvalidQueryError,\n                 \"invalid UTF-8 on query string, got byte 139\", fn ->\n      fetch_query_params(conn)\n    end\n  end\n\n  test \"req_cookies/1 && fetch_cookies/1\" do\n    conn = put_req_header(conn(:get, \"/\"), \"cookie\", \"foo=bar; baz=bat\")\n    assert conn.req_cookies == %Plug.Conn.Unfetched{aspect: :cookies}\n    conn = fetch_cookies(conn)\n    assert conn.req_cookies == %{\"foo\" => \"bar\", \"baz\" => \"bat\"}\n\n    conn = fetch_cookies(conn(:get, \"/foo\"), []) # Pluggable\n    assert conn.req_cookies == %{}\n  end\n\n  test \"put_resp_cookie/4 and delete_resp_cookie/3\" do\n    conn = send_resp(conn(:get, \"/\"), 200, \"ok\")\n    assert get_resp_header(conn, \"set-cookie\") == []\n\n    conn = conn(:get, \"/\") |> put_resp_cookie(\"foo\", \"baz\", path: \"/baz\") |> send_resp(200, \"ok\")\n    assert conn.resp_cookies[\"foo\"] ==\n           %{value: \"baz\", path: \"/baz\"}\n    assert get_resp_header(conn, \"set-cookie\") ==\n           [\"foo=baz; path=/baz; HttpOnly\"]\n\n    conn = conn(:get, \"/\") |> put_resp_cookie(\"foo\", \"baz\") |>\n           delete_resp_cookie(\"foo\", path: \"/baz\") |> send_resp(200, \"ok\")\n    assert conn.resp_cookies[\"foo\"] ==\n           %{max_age: 0, universal_time: {{1970, 1, 1}, {0, 0, 0}}, path: \"/baz\"}\n    assert get_resp_header(conn, \"set-cookie\") ==\n           [\"foo=; path=/baz; expires=Thu, 01 Jan 1970 00:00:00 GMT; max-age=0; HttpOnly\"]\n  end\n\n  test \"put_resp_cookie/4 raises when over 4096 bytes\" do\n    assert_raise Plug.Conn.CookieOverflowError, fn ->\n      conn(:get, \"/\")\n      |> put_resp_cookie(\"foo\", String.duplicate(\"a\", 4095))\n      |> send_resp(200, \"OK\")\n    end\n  end\n\n  test \"put_resp_cookie/4 is secure on https\" do\n    conn = conn(:get, \"https://example.com/\")\n           |> put_resp_cookie(\"foo\", \"baz\", path: \"/baz\")\n           |> send_resp(200, \"ok\")\n    assert conn.resp_cookies[\"foo\"] ==\n           %{value: \"baz\", path: \"/baz\", secure: true}\n\n    conn = conn(:get, \"https://example.com/\")\n           |> put_resp_cookie(\"foo\", \"baz\", path: \"/baz\", secure: false)\n           |> send_resp(200, \"ok\")\n    assert conn.resp_cookies[\"foo\"] ==\n           %{value: \"baz\", path: \"/baz\", secure: false}\n  end\n\n  test \"put_req_cookie/3 and delete_req_cookie/2\" do\n    conn = conn(:get, \"/\")\n    assert get_req_header(conn, \"cookie\") == []\n\n    conn = put_req_cookie(conn, \"foo\", \"bar\")\n    assert get_req_header(conn, \"cookie\") == [\"foo=bar\"]\n\n    conn = delete_req_cookie(conn, \"foo\")\n    assert get_req_header(conn, \"cookie\") == []\n\n    conn = conn |> put_req_cookie(\"foo\", \"bar\") |> put_req_cookie(\"baz\", \"bat\") |> fetch_cookies\n    assert conn.req_cookies[\"foo\"] == \"bar\"\n    assert conn.req_cookies[\"baz\"] == \"bat\"\n\n    assert_raise ArgumentError, fn ->\n      put_req_cookie(conn, \"foo\", \"bar\")\n    end\n  end\n\n  test \"put_resp_cookie/4 and delete_resp_cookie/3 raise when the connection was already sent\" do\n    conn = send_resp(conn(:get, \"/foo\"), 200, \"ok\")\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      put_resp_cookie(conn, \"foo\", \"bar\")\n    end\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      delete_resp_cookie(conn, \"foo\")\n    end\n  end\n\n  test \"recycle_cookies/2\" do\n    conn = conn(:get, \"/foo\", a: \"b\", c: [%{d: \"e\"}, \"f\"])\n           |> put_req_cookie(\"req_cookie\", \"req_cookie\")\n           |> put_req_cookie(\"del_cookie\", \"del_cookie\")\n           |> put_req_cookie(\"over_cookie\", \"pre_cookie\")\n           |> put_resp_cookie(\"over_cookie\", \"pos_cookie\")\n           |> put_resp_cookie(\"resp_cookie\", \"resp_cookie\")\n           |> delete_resp_cookie(\"del_cookie\")\n\n    conn = conn(:get, \"/\") |> recycle_cookies(conn) |> fetch_cookies()\n    assert conn.cookies == %{\"req_cookie\"  => \"req_cookie\",\n                             \"over_cookie\" => \"pos_cookie\",\n                             \"resp_cookie\" => \"resp_cookie\"}\n  end\n\n  test \"cookies/1 loaded early\" do\n    conn = put_req_cookie(conn(:get, \"/\"), \"foo\", \"bar\")\n    assert conn.cookies == %Plug.Conn.Unfetched{aspect: :cookies}\n\n    conn = fetch_cookies(conn)\n    assert conn.cookies[\"foo\"] == \"bar\"\n\n    conn = put_resp_cookie(conn, \"bar\", \"baz\")\n    assert conn.cookies[\"bar\"] == \"baz\"\n\n    conn = put_resp_cookie(conn, \"foo\", \"baz\")\n    assert conn.cookies[\"foo\"] == \"baz\"\n\n    conn = delete_resp_cookie(conn, \"foo\")\n    refute conn.cookies[\"foo\"]\n  end\n\n  test \"cookies/1 loaded late\" do\n    conn = conn(:get, \"/\") |> put_req_cookie(\"foo\", \"bar\") |> put_req_cookie(\"bar\", \"baz\")\n    assert conn.cookies == %Plug.Conn.Unfetched{aspect: :cookies}\n\n    conn = conn |> put_resp_cookie(\"foo\", \"baz\") |> put_resp_cookie(\"baz\", \"bat\") |>\n           delete_resp_cookie(\"bar\") |> fetch_cookies\n\n    assert conn.cookies[\"foo\"] == \"baz\"\n    assert conn.cookies[\"baz\"] == \"bat\"\n    refute conn.cookies[\"bar\"]\n  end\n\n  test \"fetch_session/2 returns the same conn on subsequent calls\" do\n    opts = Plug.Session.init(store: ProcessStore, key: \"foobar\")\n    conn = conn(:get, \"/\") |> Plug.Session.call(opts) |> fetch_session()\n\n    assert fetch_session(conn) == conn\n  end\n\n  test \"session not fetched\" do\n    conn = conn(:get, \"/\")\n\n    assert_raise ArgumentError, \"session not fetched, call fetch_session/2\", fn ->\n      get_session(conn, :foo)\n    end\n\n    assert_raise ArgumentError, \"cannot fetch session without a configured session plug\", fn ->\n      fetch_session(conn)\n    end\n\n    opts = Plug.Session.init(store: ProcessStore, key: \"foobar\")\n    conn = Plug.Session.call(conn, opts)\n\n    assert_raise ArgumentError, \"session not fetched, call fetch_session/2\", fn ->\n      get_session(conn, :foo)\n    end\n\n    conn = fetch_session(conn, []) # Pluggable\n    get_session(conn, :foo)\n  end\n\n  test \"get and put session\" do\n    opts = Plug.Session.init(store: ProcessStore, key: \"foobar\")\n    conn = conn(:get, \"/\") |> Plug.Session.call(opts) |> fetch_session()\n\n    conn = put_session(conn, \"foo\", :bar)\n    conn = put_session(conn, :key, 42)\n\n    assert conn.private[:plug_session_info] == :write\n\n    assert get_session(conn, :foo) == :bar\n    assert get_session(conn, :key) == 42\n    assert get_session(conn, :unknown) == nil\n    assert get_session(conn, \"foo\") == :bar\n    assert get_session(conn, \"key\") == 42\n    assert get_session(conn, \"unknown\") == nil\n\n    conn = %{conn|state: :sent}\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      put_session(conn, :key, 42)\n    end\n\n    conn = %{conn|state: :file}\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      put_session(conn, :key, 42)\n    end\n\n    conn = %{conn|state: :chunked}\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      put_session(conn, :key, 42)\n    end\n  end\n\n  test \"configure_session/2\" do\n    opts = Plug.Session.init(store: ProcessStore, key: \"foobar\")\n    conn = conn(:get, \"/\") |> Plug.Session.call(opts) |> fetch_session()\n\n    conn = configure_session(conn, drop: false, renew: false)\n    assert conn.private[:plug_session_info] == nil\n\n    conn = configure_session(conn, drop: true)\n    assert conn.private[:plug_session_info] == :drop\n\n    conn = configure_session(conn, renew: true)\n    assert conn.private[:plug_session_info] == :renew\n\n    conn = put_session(conn, \"foo\", \"bar\")\n    assert conn.private[:plug_session_info] == :renew\n\n    conn = %{conn|state: :sent}\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      configure_session(conn, renew: true)\n    end\n\n    conn = %{conn|state: :file}\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      configure_session(conn, renew: true)\n    end\n\n    conn = %{conn|state: :chunked}\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      configure_session(conn, renew: true)\n    end\n  end\n\n  test \"configure_session/2 fails when there is no session\" do\n    conn = conn(:get, \"/\")\n    assert_raise ArgumentError, fn ->\n      configure_session(conn, drop: true)\n    end\n  end\n\n  test \"delete_session/2\" do\n    opts = Plug.Session.init(store: ProcessStore, key: \"foobar\")\n    conn = conn(:get, \"/\") |> Plug.Session.call(opts) |> fetch_session()\n\n    conn = conn\n            |> put_session(\"foo\", \"bar\")\n            |> put_session(\"baz\", \"boom\")\n            |> delete_session(\"baz\")\n\n    assert get_session(conn, \"foo\") == \"bar\"\n    assert get_session(conn, \"baz\") == nil\n\n    conn = %{conn|state: :sent}\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      delete_session(conn, \"baz\")\n    end\n\n    conn = %{conn|state: :file}\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      delete_session(conn, \"baz\")\n    end\n\n    conn = %{conn|state: :chunked}\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      delete_session(conn, \"baz\")\n    end\n  end\n\n  test \"clear_session/1\" do\n    opts = Plug.Session.init(store: ProcessStore, key: \"foobar\")\n    conn = conn(:get, \"/\") |> Plug.Session.call(opts) |> fetch_session()\n\n    conn = conn\n            |> put_session(\"foo\", \"bar\")\n            |> put_session(\"baz\", \"boom\")\n            |> clear_session\n\n    assert get_session(conn, \"foo\") == nil\n    assert get_session(conn, \"baz\") == nil\n  end\n\n  test \"halt/1 updates halted to true\" do\n    conn = %Conn{}\n    assert conn.halted == false\n    conn = halt(conn)\n    assert conn.halted == true\n  end\n\n  test \"register_before_send/2 raises when a response has already been sent\" do\n    conn = send_resp(conn(:get, \"/\"), 200, \"ok\")\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      register_before_send(conn, fn(_) -> nil end)\n    end\n  end\n\n  test \"does not delegate to connections' adapter's chunk/2 when called with emtpy chunk\" do\n    defmodule RaisesOnEmptyChunkAdapter do\n      defdelegate send_chunked(state, status, headers), to: Plug.Adapters.Test.Conn\n\n      def chunk(_payload, \"\"), do: raise \"the empty chunk was unexpectedly sent\"\n      def chunk(payload, chunk), do: Plug.Adapters.Test.Conn.chunk(payload, chunk)\n    end\n\n    conn = %Conn{\n      adapter: {RaisesOnEmptyChunkAdapter, %{chunks: \"\"}},\n      owner: self(),\n      state: :unset\n    }\n    conn = Plug.Conn.send_chunked(conn, 200)\n\n    assert {:ok, conn} == Plug.Conn.chunk(conn, \"\")\n  end\nend\n"], "fixing_code": ["alias Plug.Conn.Unfetched\n\ndefmodule Plug.Conn do\n  @moduledoc \"\"\"\n  The Plug connection.\n\n  This module defines a `Plug.Conn` struct and the main functions\n  for working with Plug connections.\n\n  Note request headers are normalized to lowercase and response\n  headers are expected to have lower-case keys.\n\n  ## Request fields\n\n  These fields contain request information:\n\n    * `host` - the requested host as a binary, example: `\"www.example.com\"`\n    * `method` - the request method as a binary, example: `\"GET\"`\n    * `path_info` - the path split into segments, example: `[\"hello\", \"world\"]`\n    * `script_name` - the initial portion of the URL's path that corresponds to the application\n      routing, as segments, example: [\"sub\",\"app\"].\n    * `request_path` - the requested path, example: `/trailing/and//double//slashes/`\n    * `port` - the requested port as an integer, example: `80`\n    * `peer` - the actual TCP peer that connected, example: `{{127, 0, 0, 1}, 12345}`. Often this\n      is not the actual IP and port of the client, but rather of a load-balancer or request-router.\n    * `remote_ip` - the IP of the client, example: `{151, 236, 219, 228}`. This field is meant to\n      be overwritten by plugs that understand e.g. the `X-Forwarded-For` header or HAProxy's PROXY\n      protocol. It defaults to peer's IP.\n    * `req_headers` - the request headers as a list, example: `[{\"content-type\", \"text/plain\"}]`.\n      Note all headers will be downcased.\n    * `scheme` - the request scheme as an atom, example: `:http`\n    * `query_string` - the request query string as a binary, example: `\"foo=bar\"`\n\n  ## Fetchable fields\n\n  The request information in these fields is not populated until it is fetched\n  using the associated `fetch_` function. For example, the `cookies` field uses\n  `fetch_cookies/2`.\n\n  If you access these fields before fetching them, they will be returned as\n  `Plug.Conn.Unfetched` structs.\n\n    * `cookies`- the request cookies with the response cookies\n    * `body_params` - the request body params, populated through a `Plug.Parsers` parser.\n    * `query_params` - the request query params, populated through `fetch_query_params/2`\n    * `path_params` - the request path params, populated by routers such as `Plug.Router`\n    * `params` - the request params, the result of merging the `:body_params` and `:query_params`\n       with `:path_params`\n    * `req_cookies` - the request cookies (without the response ones)\n\n  ## Response fields\n\n  These fields contain response information:\n\n    * `resp_body` - the response body, by default is an empty string. It is set\n      to nil after the response is set, except for test connections.\n    * `resp_charset` - the response charset, defaults to \"utf-8\"\n    * `resp_cookies` - the response cookies with their name and options\n    * `resp_headers` - the response headers as a list of tuples, by default `cache-control`\n      is set to `\"max-age=0, private, must-revalidate\"`. Note, response headers\n      are expected to have lower-case keys.\n    * `status` - the response status\n\n  Furthermore, the `before_send` field stores callbacks that are invoked\n  before the connection is sent. Callbacks are invoked in the reverse order\n  they are registered (callbacks registered first are invoked last) in order\n  to reproduce a pipeline ordering.\n\n  ## Connection fields\n\n    * `assigns` - shared user data as a map\n    * `owner` - the Elixir process that owns the connection\n    * `halted` - the boolean status on whether the pipeline was halted\n    * `secret_key_base` - a secret key used to verify and encrypt cookies.\n      the field must be set manually whenever one of those features are used.\n      This data must be kept in the connection and never used directly, always\n      use `Plug.Crypto.KeyGenerator.generate/3` to derive keys from it\n    * `state` - the connection state\n\n  The connection state is used to track the connection lifecycle. It starts\n  as `:unset` but is changed to `:set` (via `Plug.Conn.resp/3`) or `:file`\n  (when invoked via `Plug.Conn.send_file/3`). Its final result is\n  `:sent` or `:chunked` depending on the response model.\n\n  ## Private fields\n\n  These fields are reserved for libraries/framework usage.\n\n    * `adapter` - holds the adapter information in a tuple\n    * `private` - shared library data as a map\n\n  ## Protocols\n\n  `Plug.Conn` implements both the Collectable and Inspect protocols\n  out of the box. The inspect protocol provides a nice representation\n  of the connection while the collectable protocol allows developers\n  to easily chunk data. For example:\n\n      # Send the chunked response headers\n      conn = send_chunked(conn, 200)\n\n      # Pipe the given list into a connection\n      # Each item is emitted as a chunk\n      Enum.into(~w(each chunk as a word), conn)\n\n  ## Custom status codes\n\n  Plug allows status codes to be overridden or added in order to allow new codes\n  not directly specified by Plug or its adapters. Adding or overriding a status\n  code is done through the Mix configuration of the `:plug` application. For\n  example, to override the existing 404 reason phrase for the 404 status code\n  (\"Not Found\" by default) and add a new 451 status code, the following config\n  can be specified:\n\n      config :plug, :statuses, %{\n        404 => \"Actually This Was Found\",\n        451 => \"Unavailable For Legal Reasons\"\n      }\n\n  As this configuration is Plug specific, Plug will need to be recompiled for\n  the changes to take place: this will not happen automatically as dependencies\n  are not automatically recompiled when their configuration changes. To recompile\n  Plug:\n\n      mix deps.clean --build plug\n\n  The atoms that can be used in place of the status code in many functions are\n  inflected from the reason phrase of the status code. With the above\n  configuration, the following will all work:\n\n      put_status(conn, :not_found)                     # 404\n      put_status(conn, :actually_this_was_found)       # 404\n      put_status(conn, :unavailable_for_legal_reasons) # 451\n\n  Even though 404 has been overridden, the `:not_found` atom can still be used\n  to set the status to 404 as well as the new atom `:actually_this_was_found`\n  inflected from the reason phrase \"Actually This Was Found\".\n  \"\"\"\n\n  @type adapter         :: {module, term}\n  @type assigns         :: %{atom => any}\n  @type before_send     :: [(t -> t)]\n  @type body            :: iodata\n  @type cookies         :: %{binary => binary}\n  @type halted          :: boolean\n  @type headers         :: [{binary, binary}]\n  @type host            :: binary\n  @type int_status      :: non_neg_integer | nil\n  @type owner           :: pid\n  @type method          :: binary\n  @type param           :: binary | %{binary => param} | [param]\n  @type params          :: %{binary => param}\n  @type peer            :: {:inet.ip_address, :inet.port_number}\n  @type port_number     :: :inet.port_number\n  @type query_string    :: String.t\n  @type resp_cookies    :: %{binary => %{}}\n  @type scheme          :: :http | :https\n  @type secret_key_base :: binary | nil\n  @type segments        :: [binary]\n  @type state           :: :unset | :set | :file | :chunked | :sent\n  @type status          :: atom | int_status\n\n  @type t :: %__MODULE__{\n              adapter:         adapter,\n              assigns:         assigns,\n              before_send:     before_send,\n              body_params:     params | Unfetched.t,\n              cookies:         cookies | Unfetched.t,\n              host:            host,\n              method:          method,\n              owner:           owner,\n              params:          params | Unfetched.t,\n              path_info:       segments,\n              path_params:     params,\n              port:            :inet.port_number,\n              private:         assigns,\n              query_params:    params | Unfetched.t,\n              query_string:    query_string,\n              peer:            peer,\n              remote_ip:       :inet.ip_address,\n              req_cookies:     cookies | Unfetched.t,\n              req_headers:     headers,\n              request_path:    binary,\n              resp_body:       body | nil,\n              resp_cookies:    resp_cookies,\n              resp_headers:    headers,\n              scheme:          scheme,\n              script_name:     segments,\n              secret_key_base: secret_key_base,\n              state:           state,\n              status:          int_status}\n\n  defstruct adapter:         {Plug.Conn, nil},\n            assigns:         %{},\n            before_send:     [],\n            body_params:     %Unfetched{aspect: :body_params},\n            cookies:         %Unfetched{aspect: :cookies},\n            halted:          false,\n            host:            \"www.example.com\",\n            method:          \"GET\",\n            owner:           nil,\n            params:          %Unfetched{aspect: :params},\n            path_params:     %{},\n            path_info:       [],\n            port:            0,\n            private:         %{},\n            query_params:    %Unfetched{aspect: :query_params},\n            query_string:    \"\",\n            peer:            nil,\n            remote_ip:       nil,\n            req_cookies:     %Unfetched{aspect: :cookies},\n            req_headers:     [],\n            request_path:    \"\",\n            resp_body:       nil,\n            resp_cookies:    %{},\n            resp_headers:    [{\"cache-control\", \"max-age=0, private, must-revalidate\"}],\n            scheme:          :http,\n            script_name:     [],\n            secret_key_base: nil,\n            state:           :unset,\n            status:          nil\n\n  defmodule NotSentError do\n    defexception message: \"a response was neither set nor sent from the connection\"\n\n    @moduledoc \"\"\"\n    Error raised when no response is sent in a request\n    \"\"\"\n  end\n\n  defmodule AlreadySentError do\n    defexception message: \"the response was already sent\"\n\n    @moduledoc \"\"\"\n    Error raised when trying to modify or send an already sent response\n    \"\"\"\n  end\n\n  defmodule CookieOverflowError do\n    defexception message: \"cookie exceeds maximum size of 4096 bytes\"\n\n    @moduledoc \"\"\"\n    Error raised when the cookie exceeds the maximum size of 4096 bytes.\n    \"\"\"\n  end\n\n  defmodule InvalidHeaderError do\n    defexception message: \"header is invalid\"\n\n    @moduledoc ~S\"\"\"\n    Error raised when trying to send a header that has errors, for example:\n\n      * the header key contains uppercase chars\n      * the header value contains newlines \\n\n    \"\"\"\n  end\n\n  defmodule InvalidQueryError do\n    @moduledoc \"\"\"\n    Raised when the request string is malformed, for example:\n\n      * the query has bad utf-8 encoding\n      * the query fails to www-form decode\n    \"\"\"\n\n    defexception message: \"query string is invalid\", plug_status: 400\n  end\n\n  alias Plug.Conn\n  @already_sent {:plug_conn, :sent}\n  @unsent [:unset, :set]\n\n  @doc \"\"\"\n  Assigns a value to a key in the connection\n\n  ## Examples\n\n      iex> conn.assigns[:hello]\n      nil\n      iex> conn = assign(conn, :hello, :world)\n      iex> conn.assigns[:hello]\n      :world\n\n  \"\"\"\n  @spec assign(t, atom, term) :: t\n  def assign(%Conn{assigns: assigns} = conn, key, value) when is_atom(key) do\n    %{conn | assigns: Map.put(assigns, key, value)}\n  end\n\n  @doc \"\"\"\n  Starts a task to assign a value to a key in the connection.\n\n  `await_assign/2` can be used to wait for the async task to complete and\n  retrieve the resulting value.\n\n  Behind the scenes, it uses `Task.async/1`.\n\n  ## Examples\n\n      iex> conn.assigns[:hello]\n      nil\n      iex> conn = async_assign(conn, :hello, fn -> :world end)\n      iex> conn.assigns[:hello]\n      %Task{...}\n\n  \"\"\"\n  @spec async_assign(t, atom, (() -> term)) :: t\n  def async_assign(%Conn{} = conn, key, fun) when is_atom(key) and is_function(fun, 0) do\n    assign(conn, key, Task.async(fun))\n  end\n\n  @doc \"\"\"\n  Awaits the completion of an async assign.\n\n  Returns a connection with the value resulting from the async assignment placed\n  under `key` in the `:assigns` field.\n\n  Behind the scenes, it uses `Task.await/2`.\n\n  ## Examples\n\n      iex> conn.assigns[:hello]\n      nil\n      iex> conn = async_assign(conn, :hello, fn -> :world end)\n      iex> conn = await_assign(conn, :hello) # blocks until `conn.assigns[:hello]` is available\n      iex> conn.assigns[:hello]\n      :world\n\n  \"\"\"\n  @spec await_assign(t, atom, timeout) :: t\n  def await_assign(%Conn{} = conn, key, timeout \\\\ 5000) when is_atom(key) do\n    task = Map.fetch!(conn.assigns, key)\n    assign(conn, key, Task.await(task, timeout))\n  end\n\n  @doc \"\"\"\n  Assigns a new **private** key and value in the connection.\n\n  This storage is meant to be used by libraries and frameworks to avoid writing\n  to the user storage (the `:assigns` field). It is recommended for\n  libraries/frameworks to prefix the keys with the library name.\n\n  For example, if some plug needs to store a `:hello` key, it\n  should do so as `:plug_hello`:\n\n      iex> conn.private[:plug_hello]\n      nil\n      iex> conn = put_private(conn, :plug_hello, :world)\n      iex> conn.private[:plug_hello]\n      :world\n\n  \"\"\"\n  @spec put_private(t, atom, term) :: t\n  def put_private(%Conn{private: private} = conn, key, value) when is_atom(key) do\n    %{conn | private: Map.put(private, key, value)}\n  end\n\n  @doc \"\"\"\n  Stores the given status code in the connection.\n\n  The status code can be `nil`, an integer or an atom. The list of allowed\n  atoms is available in `Plug.Conn.Status`.\n\n  Raises a `Plug.Conn.AlreadySentError` if the connection has already been\n  `:sent`.\n  \"\"\"\n  @spec put_status(t, status) :: t\n  def put_status(%Conn{state: :sent}, _status),\n    do: raise AlreadySentError\n  def put_status(%Conn{} = conn, nil),\n    do: %{conn | status: nil}\n  def put_status(%Conn{} = conn, status),\n    do: %{conn | status: Plug.Conn.Status.code(status)}\n\n  @doc \"\"\"\n  Sends a response to the client.\n\n  It expects the connection state to be `:set`, otherwise raises an\n  `ArgumentError` for `:unset` connections or a `Plug.Conn.AlreadySentError` for\n  already `:sent` connections.\n\n  At the end sets the connection state to `:sent`.\n  \"\"\"\n  @spec send_resp(t) :: t | no_return\n  def send_resp(conn)\n\n  def send_resp(%Conn{state: :unset}) do\n    raise ArgumentError, \"cannot send a response that was not set\"\n  end\n\n  def send_resp(%Conn{adapter: {adapter, payload}, state: :set, owner: owner} = conn) do\n    conn = run_before_send(conn, :set)\n    {:ok, body, payload} = adapter.send_resp(payload, conn.status, conn.resp_headers, conn.resp_body)\n    send owner, @already_sent\n    %{conn | adapter: {adapter, payload}, resp_body: body, state: :sent}\n  end\n\n  def send_resp(%Conn{}) do\n    raise AlreadySentError\n  end\n\n  @doc \"\"\"\n  Sends a file as the response body with the given `status`\n  and optionally starting at the given offset until the given length.\n\n  If available, the file is sent directly over the socket using\n  the operating system `sendfile` operation.\n\n  It expects a connection that has not been `:sent` yet and sets its\n  state to `:sent` afterwards. Otherwise raises `Plug.Conn.AlreadySentError`.\n\n  ## Examples\n\n      Plug.Conn.send_file(conn, 200, \"README.md\")\n\n  \"\"\"\n  @spec send_file(t, status, filename :: binary, offset ::integer, length :: integer | :all) :: t | no_return\n  def send_file(conn, status, file, offset \\\\ 0, length  \\\\ :all)\n\n  def send_file(%Conn{state: state}, status, _file, _offset, _length)\n      when not state in @unsent do\n    _ = Plug.Conn.Status.code(status)\n    raise AlreadySentError\n  end\n\n  def send_file(%Conn{adapter: {adapter, payload}, owner: owner} = conn, status, file, offset, length) when is_binary(file) do\n    if file =~ \"\\0\" do\n      raise ArgumentError, \"cannot send_file/5 with null byte\"\n    end\n\n    conn = run_before_send(%{conn | status: Plug.Conn.Status.code(status), resp_body: nil}, :file)\n    {:ok, body, payload} = adapter.send_file(payload, conn.status, conn.resp_headers, file, offset, length)\n    send owner, @already_sent\n    %{conn | adapter: {adapter, payload}, state: :sent, resp_body: body}\n  end\n\n  @doc \"\"\"\n  Sends the response headers as a chunked response.\n\n  It expects a connection that has not been `:sent` yet and sets its\n  state to `:chunked` afterwards. Otherwise raises `Plug.Conn.AlreadySentError`.\n  \"\"\"\n  @spec send_chunked(t, status) :: t | no_return\n  def send_chunked(%Conn{state: state}, status)\n      when not state in @unsent do\n    _ = Plug.Conn.Status.code(status)\n    raise AlreadySentError\n  end\n\n  def send_chunked(%Conn{adapter: {adapter, payload}, owner: owner} = conn, status) do\n    conn = run_before_send(%{conn | status: Plug.Conn.Status.code(status), resp_body: nil}, :chunked)\n    {:ok, body, payload} = adapter.send_chunked(payload, conn.status, conn.resp_headers)\n    send owner, @already_sent\n    %{conn | adapter: {adapter, payload}, resp_body: body}\n  end\n\n  @doc \"\"\"\n  Sends a chunk as part of a chunked response.\n\n  It expects a connection with state `:chunked` as set by\n  `send_chunked/2`. It returns `{:ok, conn}` in case of success,\n  otherwise `{:error, reason}`.\n  \"\"\"\n  @spec chunk(t, body) :: {:ok, t} | {:error, term} | no_return\n  def chunk(%Conn{state: :chunked} = conn, \"\"), do: {:ok, conn}\n  def chunk(%Conn{adapter: {adapter, payload}, state: :chunked} = conn, chunk) do\n    case adapter.chunk(payload, chunk) do\n      :ok                  -> {:ok, conn}\n      {:ok, body, payload} -> {:ok, %{conn | resp_body: body, adapter: {adapter, payload}}}\n      {:error, _} = error  -> error\n    end\n  end\n\n  def chunk(%Conn{}, chunk) when is_binary(chunk) or is_list(chunk) do\n    raise ArgumentError, \"chunk/2 expects a chunked response. Please ensure \" <>\n                         \"you have called send_chunked/2 before you send a chunk\"\n  end\n\n  @doc \"\"\"\n  Sends a response with the given status and body.\n\n  See `send_resp/1` for more information.\n  \"\"\"\n  @spec send_resp(t, status, body) :: t | no_return\n  def send_resp(%Conn{} = conn, status, body) do\n    conn |> resp(status, body) |> send_resp()\n  end\n\n  @doc \"\"\"\n  Sets the response to the given `status` and `body`.\n\n  It sets the connection state to `:set` (if not already `:set`)\n  and raises `Plug.Conn.AlreadySentError` if it was already `:sent`.\n  \"\"\"\n  @spec resp(t, status, body) :: t\n  def resp(%Conn{state: state}, status, _body)\n      when not state in @unsent do\n    _ = Plug.Conn.Status.code(status)\n    raise AlreadySentError\n  end\n\n  def resp(%Conn{}, _status, nil) do\n    raise ArgumentError, \"response body cannot be set to nil\"\n  end\n\n  def resp(%Conn{} = conn, status, body)\n      when is_binary(body) or is_list(body) do\n    %{conn | status: Plug.Conn.Status.code(status), resp_body: body, state: :set}\n  end\n\n  @doc \"\"\"\n  Returns the values of the request header specified by `key`.\n  \"\"\"\n  @spec get_req_header(t, binary) :: [binary]\n  def get_req_header(%Conn{req_headers: headers}, key) when is_binary(key) do\n    for {k, v} <- headers, k == key, do: v\n  end\n\n  @doc \"\"\"\n  Adds a new request header (`key`) if not present, otherwise replaces the\n  previous value of that header with `value`.\n\n  It is recommended for header keys to be in lower-case, to avoid sending\n  duplicate keys in a request. As a convenience, this is validated during\n  testing which raises a `Plug.Conn.InvalidHeaderError` if the header key\n  is not lowercase.\n\n  Raises a `Plug.Conn.AlreadySentError` if the connection has already been\n  `:sent`.\n  \"\"\"\n  @spec put_req_header(t, binary, binary) :: t\n  def put_req_header(%Conn{state: :sent}, _key, _value) do\n    raise AlreadySentError\n  end\n\n  def put_req_header(%Conn{adapter: adapter, req_headers: headers} = conn, key, value) when\n      is_binary(key) and is_binary(value) do\n    validate_header_key!(adapter, key)\n    %{conn | req_headers: List.keystore(headers, key, 0, {key, value})}\n  end\n\n  @doc \"\"\"\n  Deletes a request header if present.\n\n  Raises a `Plug.Conn.AlreadySentError` if the connection has already been\n  `:sent`.\n  \"\"\"\n  @spec delete_req_header(t, binary) :: t\n  def delete_req_header(%Conn{state: :sent}, _key) do\n    raise AlreadySentError\n  end\n\n  def delete_req_header(%Conn{req_headers: headers} = conn, key) when\n      is_binary(key) do\n    %{conn | req_headers: List.keydelete(headers, key, 0)}\n  end\n\n  @doc \"\"\"\n  Updates a request header if present, otherwise it sets it to an initial\n  value.\n\n  Raises a `Plug.Conn.AlreadySentError` if the connection has already been\n  `:sent`.\n  \"\"\"\n  @spec update_req_header(t, binary, binary, (binary -> binary)) :: t\n  def update_req_header(%Conn{state: :sent}, _key, _initial, _fun) do\n    raise AlreadySentError\n  end\n\n  def update_req_header(%Conn{} = conn, key, initial, fun) when\n      is_binary(key) and is_binary(initial) and is_function(fun, 1) do\n    case get_req_header(conn, key) do\n      []          -> put_req_header(conn, key, initial)\n      [current|_] -> put_req_header(conn, key, fun.(current))\n    end\n  end\n\n  @doc \"\"\"\n  Returns the values of the response header specified by `key`.\n\n  ## Examples\n\n      iex> conn = %{conn | resp_headers: [{\"content-type\", \"text/plain\"}]}\n      iex> get_resp_header(conn, \"content-type\")\n      [\"text/plain\"]\n\n  \"\"\"\n  @spec get_resp_header(t, binary) :: [binary]\n  def get_resp_header(%Conn{resp_headers: headers}, key) when is_binary(key) do\n    for {k, v} <- headers, k == key, do: v\n  end\n\n  @doc ~S\"\"\"\n  Adds a new response header (`key`) if not present, otherwise replaces the\n  previous value of that header with `value`.\n\n  It is recommended for header keys to be in lower-case, to avoid sending\n  duplicate keys in a request. As a convenience, this is validated during\n  testing which raises a `Plug.Conn.InvalidHeaderError` if the header key\n  is not lowercase.\n\n  Raises a `Plug.Conn.AlreadySentError` if the connection has already been\n  `:sent`.\n\n  Raises a `Plug.Conn.InvalidHeaderError` if the header value contains control\n  feed (\\r) or newline (\\n) characters.\n  \"\"\"\n  @spec put_resp_header(t, binary, binary) :: t\n  def put_resp_header(%Conn{state: :sent}, _key, _value) do\n    raise AlreadySentError\n  end\n\n  def put_resp_header(%Conn{adapter: adapter, resp_headers: headers} = conn, key, value) when\n      is_binary(key) and is_binary(value) do\n    validate_header_key!(adapter, key)\n    validate_header_value!(value)\n    %{conn | resp_headers: List.keystore(headers, key, 0, {key, value})}\n  end\n\n  @doc \"\"\"\n  Merges a series of response headers into the connection.\n  \"\"\"\n  @spec merge_resp_headers(t, Enum.t) :: t\n  def merge_resp_headers(%Conn{state: :sent}, _headers) do\n    raise AlreadySentError\n  end\n\n  def merge_resp_headers(conn, headers) when headers == %{} do\n    conn\n  end\n\n  def merge_resp_headers(%Conn{resp_headers: current} = conn, headers) do\n    headers =\n      Enum.reduce headers, current, fn\n        {key, value}, acc when is_binary(key) and is_binary(value) ->\n          List.keystore(acc, key, 0, {key, value})\n      end\n    %{conn | resp_headers: headers}\n  end\n\n  @doc \"\"\"\n  Deletes a response header if present.\n\n  Raises a `Plug.Conn.AlreadySentError` if the connection has already been\n  `:sent`.\n  \"\"\"\n  @spec delete_resp_header(t, binary) :: t\n  def delete_resp_header(%Conn{state: :sent}, _key) do\n    raise AlreadySentError\n  end\n\n  def delete_resp_header(%Conn{resp_headers: headers} = conn, key) when\n      is_binary(key) do\n    %{conn | resp_headers: List.keydelete(headers, key, 0)}\n  end\n\n  @doc \"\"\"\n  Updates a response header if present, otherwise it sets it to an initial\n  value.\n\n  Raises a `Plug.Conn.AlreadySentError` if the connection has already been\n  `:sent`.\n  \"\"\"\n  @spec update_resp_header(t, binary, binary, (binary -> binary)) :: t\n  def update_resp_header(%Conn{state: :sent}, _key, _initial, _fun) do\n    raise AlreadySentError\n  end\n\n  def update_resp_header(%Conn{} = conn, key, initial, fun) when\n      is_binary(key) and is_binary(initial) and is_function(fun, 1) do\n    case get_resp_header(conn, key) do\n      []          -> put_resp_header(conn, key, initial)\n      [current|_] -> put_resp_header(conn, key, fun.(current))\n    end\n  end\n\n  @doc \"\"\"\n  Sets the value of the `\"content-type\"` response header taking into account the\n  `charset`.\n  \"\"\"\n  @spec put_resp_content_type(t, binary, binary | nil) :: t\n  def put_resp_content_type(conn, content_type, charset \\\\ \"utf-8\")\n\n  def put_resp_content_type(conn, content_type, nil) when is_binary(content_type) do\n    put_resp_header(conn, \"content-type\", content_type)\n  end\n\n  def put_resp_content_type(conn, content_type, charset) when\n      is_binary(content_type) and is_binary(charset) do\n    put_resp_header(conn, \"content-type\", \"#{content_type}; charset=#{charset}\")\n  end\n\n  @doc \"\"\"\n  Fetches query parameters from the query string.\n\n  This function does not fetch parameters from the body. To fetch\n  parameters from the body, use the `Plug.Parsers` plug.\n  \"\"\"\n  @spec fetch_query_params(t, Keyword.t) :: t\n  def fetch_query_params(conn, opts \\\\ [])\n\n  def fetch_query_params(%Conn{query_params: %Unfetched{}, params: params,\n                               query_string: query_string} = conn, _opts) do\n    Plug.Conn.Utils.validate_utf8!(query_string, InvalidQueryError, \"query string\")\n    query_params = Plug.Conn.Query.decode(query_string)\n\n    case params do\n      %Unfetched{} -> %{conn | query_params: query_params, params: query_params}\n      %{}          -> %{conn | query_params: query_params, params: Map.merge(query_params, params)}\n    end\n  end\n\n  def fetch_query_params(%Conn{} = conn, _opts) do\n    conn\n  end\n\n  @doc \"\"\"\n  Reads the request body.\n\n  This function reads a chunk of the request body up to a given `:length`. If\n  there is more data to be read, then `{:more, partial_body, conn}` is\n  returned. Otherwise `{:ok, body, conn}` is returned. In case of an error\n  reading the socket, `{:error, reason}` is returned as per `:gen_tcp.recv/2`.\n\n  In order to, for instance, support slower clients you can tune the\n  `:read_length` and `:read_timeout` options. These specify how much time should\n  be allowed to pass for each read from the underlying socket.\n\n  Because the request body can be of any size, reading the body will only\n  work once, as Plug will not cache the result of these operations. If you\n  need to access the body multiple times, it is your responsibility to store\n  it. Finally keep in mind some plugs like `Plug.Parsers` may read the body,\n  so the body may be unavailable after being accessed by such plugs.\n\n  This function is able to handle both chunked and identity transfer-encoding\n  by default.\n\n  ## Options\n\n  * `:length` - sets the maximum number of bytes to read from the body for each\n    chunk, defaults to 8_000_000 bytes\n  * `:read_length` - sets the amount of bytes to read at one time from the\n    underlying socket to fill the chunk, defaults to 1_000_000 bytes\n  * `:read_timeout` - sets the timeout for each socket read, defaults to\n    15_000 ms\n\n  The values above are not meant to be exact. For example, setting the\n  length to 8_000_000 may end up reading some hundred bytes more from\n  the socket until we halt.\n\n  ## Examples\n\n      {:ok, body, conn} = Plug.Conn.read_body(conn, length: 1_000_000)\n\n  \"\"\"\n  @spec read_body(t, Keyword.t) :: {:ok, binary, t} |\n                                   {:more, binary, t} |\n                                   {:error, term}\n  def read_body(%Conn{adapter: {adapter, state}} = conn, opts \\\\ []) do\n    case adapter.read_req_body(state, opts) do\n      {:ok, data, state} ->\n        {:ok, data, %{conn | adapter: {adapter, state}}}\n      {:more, data, state} ->\n        {:more, data, %{conn | adapter: {adapter, state}}}\n      {:error, reason} ->\n        {:error, reason}\n    end\n  end\n\n  @doc \"\"\"\n  Fetches cookies from the request headers.\n  \"\"\"\n  @spec fetch_cookies(t, Keyword.t) :: t\n  def fetch_cookies(conn, opts \\\\ [])\n\n  def fetch_cookies(%Conn{req_cookies: %Unfetched{},\n                          resp_cookies: resp_cookies,\n                          req_headers: req_headers} = conn, _opts) do\n    req_cookies =\n      for {\"cookie\", cookie} <- req_headers,\n          kv <- Plug.Conn.Cookies.decode(cookie),\n          into: %{},\n          do: kv\n\n    cookies = Enum.reduce(resp_cookies, req_cookies, fn\n      {key, opts}, acc ->\n        if value = Map.get(opts, :value) do\n          Map.put(acc, key, value)\n        else\n          Map.delete(acc, key)\n        end\n    end)\n\n    %{conn | req_cookies: req_cookies, cookies: cookies}\n  end\n\n  def fetch_cookies(%Conn{} = conn, _opts) do\n    conn\n  end\n\n  @doc \"\"\"\n  Puts a response cookie.\n\n  The cookie value is not automatically escaped. Therefore, if you\n  want to store values with comma, quotes, etc, you need to explicitly\n  escape them or use a function such as `Base.encode64` when writing\n  and `Base.decode64` when reading the cookie.\n\n  ## Options\n\n    * `:domain` - the domain the cookie applies to\n    * `:max_age` - the cookie max-age, in seconds. Providing a value for this\n      option will set both the _max-age_ and _expires_ cookie attributes\n    * `:path` - the path the cookie applies to\n    * `:http_only` - when false, the cookie is accessible beyond http\n    * `:secure` - if the cookie must be sent only over https. Defaults\n      to true when the connection is https\n    * `:extra` - string to append to cookie. Use this to take advantage of\n      non-standard cookie attributes.\n\n  \"\"\"\n  @spec put_resp_cookie(t, binary, binary, Keyword.t) :: t\n  def put_resp_cookie(%Conn{resp_cookies: resp_cookies, scheme: scheme} = conn, key, value, opts \\\\ []) when\n      is_binary(key) and is_binary(value) and is_list(opts) do\n    cookie = [{:value, value}|opts] |> :maps.from_list() |> maybe_secure_cookie(scheme)\n    resp_cookies = Map.put(resp_cookies, key, cookie)\n    update_cookies(%{conn | resp_cookies: resp_cookies}, &Map.put(&1, key, value))\n  end\n\n  defp maybe_secure_cookie(cookie, :https), do: Map.put_new(cookie, :secure, true)\n  defp maybe_secure_cookie(cookie, _),      do: cookie\n\n  @epoch {{1970, 1, 1}, {0, 0, 0}}\n\n  @doc \"\"\"\n  Deletes a response cookie.\n\n  Deleting a cookie requires the same options as to when the cookie was put.\n  Check `put_resp_cookie/4` for more information.\n  \"\"\"\n  @spec delete_resp_cookie(t, binary, Keyword.t) :: t\n  def delete_resp_cookie(%Conn{resp_cookies: resp_cookies} = conn, key, opts \\\\ []) when\n      is_binary(key) and is_list(opts) do\n    opts = [universal_time: @epoch, max_age: 0] ++ opts\n    resp_cookies = Map.put(resp_cookies, key, :maps.from_list(opts))\n    update_cookies(%{conn | resp_cookies: resp_cookies}, &Map.delete(&1, key))\n  end\n\n  @doc \"\"\"\n  Fetches the session from the session store. Will also fetch cookies.\n  \"\"\"\n  @spec fetch_session(t, Keyword.t) :: t\n  def fetch_session(conn, opts \\\\ [])\n\n  def fetch_session(%Conn{private: private} = conn, _opts) do\n    case Map.fetch(private, :plug_session_fetch) do\n      {:ok, :done} -> conn\n      {:ok, fun} -> conn |> fetch_cookies |> fun.()\n      :error -> raise ArgumentError, \"cannot fetch session without a configured session plug\"\n    end\n  end\n\n  @doc \"\"\"\n  Puts the specified `value` in the session for the given `key`.\n\n  The key can be a string or an atom, where atoms are\n  automatically converted to strings. Can only be invoked\n  on unsent `conn`s. Will raise otherwise.\n  \"\"\"\n  @spec put_session(t, String.t | atom, any) :: t\n  def put_session(%Conn{state: state}, _key, _value) when not state in @unsent,\n    do: raise AlreadySentError\n  def put_session(conn, key, value) do\n    put_session(conn, &Map.put(&1, session_key(key), value))\n  end\n\n  @doc \"\"\"\n  Returns session value for the given `key`.\n\n  The key can be a string or an atom, where atoms are\n  automatically converted to strings.\n  \"\"\"\n  @spec get_session(t, String.t | atom) :: any\n  def get_session(conn, key) do\n    conn |> get_session |> Map.get(session_key(key))\n  end\n\n  @doc \"\"\"\n  Deletes the session for the given `key`.\n\n  The key can be a string or an atom, where atoms are\n  automatically converted to strings.\n  \"\"\"\n  @spec delete_session(t, String.t | atom) :: t\n  def delete_session(%Conn{state: state}, _key) when not state in @unsent,\n    do: raise AlreadySentError\n  def delete_session(conn, key) do\n    put_session(conn, &Map.delete(&1, session_key(key)))\n  end\n\n  @doc \"\"\"\n  Clears the entire session.\n\n  This function removes every key from the session, clearing the session.\n\n  Note that, even if `clear_session/1` is used, the session is still sent to the\n  client. If the session should be effectively *dropped*, `configure_session/2`\n  should be used with the `:drop` option set to `true`.\n  \"\"\"\n  @spec clear_session(t) :: t\n  def clear_session(conn) do\n    put_session(conn, fn(_existing) -> Map.new end)\n  end\n\n  @doc \"\"\"\n  Configures the session.\n\n  ## Options\n\n    * `:renew` - generates a new session id for the cookie\n    * `:drop` - drops the session, a session cookie will not be included in the\n      response\n    * `:ignore` - ignores all changes made to the session in this request cycle\n\n  \"\"\"\n  @spec configure_session(t, Keyword.t) :: t\n  def configure_session(%Conn{state: state}, _opts) when not state in @unsent,\n    do: raise AlreadySentError\n  def configure_session(conn, opts) do\n    # Ensure the session is available.\n    _ = get_session(conn)\n\n    cond do\n      opts[:renew]  -> put_private(conn, :plug_session_info, :renew)\n      opts[:drop]   -> put_private(conn, :plug_session_info, :drop)\n      opts[:ignore] -> put_private(conn, :plug_session_info, :ignore)\n      true          -> conn\n    end\n  end\n\n  @doc \"\"\"\n  Registers a callback to be invoked before the response is sent.\n\n  Callbacks are invoked in the reverse order they are defined (callbacks\n  defined first are invoked last).\n  \"\"\"\n  @spec register_before_send(t, (t -> t)) :: t\n  def register_before_send(%Conn{state: state}, _callback)\n      when not state in @unsent do\n    raise AlreadySentError\n  end\n\n  def register_before_send(%Conn{before_send: before_send} = conn, callback)\n      when is_function(callback, 1) do\n    %{conn | before_send: [callback|before_send]}\n  end\n\n  @doc \"\"\"\n  Halts the Plug pipeline by preventing further plugs downstream from being\n  invoked. See the docs for `Plug.Builder` for more information on halting a\n  plug pipeline.\n  \"\"\"\n  @spec halt(t) :: t\n  def halt(%Conn{} = conn) do\n    %{conn | halted: true}\n  end\n\n  ## Helpers\n\n  defp run_before_send(%Conn{before_send: before_send} = conn, new) do\n    conn = Enum.reduce before_send, %{conn | state: new}, &(&1.(&2))\n    if conn.state != new do\n      raise ArgumentError, \"cannot send/change response from run_before_send callback\"\n    end\n    %{conn | resp_headers: merge_headers(conn.resp_headers, conn.resp_cookies)}\n  end\n\n  defp merge_headers(headers, cookies) do\n    Enum.reduce(cookies, headers, fn {key, opts}, acc ->\n      value =\n        key\n        |> Plug.Conn.Cookies.encode(opts)\n        |> verify_cookie!(key)\n      [{\"set-cookie\", value}|acc]\n    end)\n  end\n\n  defp verify_cookie!(cookie, key) when byte_size(cookie) > 4096 do\n    raise Plug.Conn.CookieOverflowError,\n          \"cookie named #{inspect key} exceeds maximum size of 4096 bytes\"\n  end\n  defp verify_cookie!(cookie, _key) do\n    validate_header_value!(cookie)\n    cookie\n  end\n\n  defp update_cookies(%Conn{state: :sent}, _fun),\n    do: raise AlreadySentError\n  defp update_cookies(%Conn{cookies: %Unfetched{}} = conn, _fun),\n    do: conn\n  defp update_cookies(%Conn{cookies: cookies} = conn, fun),\n    do: %{conn | cookies: fun.(cookies)}\n\n  defp session_key(binary) when is_binary(binary), do: binary\n  defp session_key(atom) when is_atom(atom), do: Atom.to_string(atom)\n\n  defp get_session(%Conn{private: private}) do\n    if session = Map.get(private, :plug_session) do\n      session\n    else\n      raise ArgumentError, \"session not fetched, call fetch_session/2\"\n    end\n  end\n\n  defp put_session(conn, fun) do\n    private = conn.private\n              |> Map.put(:plug_session, fun.(get_session(conn)))\n              |> Map.put_new(:plug_session_info, :write)\n\n    %{conn | private: private}\n  end\n\n  defp validate_header_key!({Plug.Adapters.Test.Conn, _}, key) do\n    unless valid_header_key?(key) do\n      raise InvalidHeaderError, \"header key is not lowercase: \" <> inspect(key)\n    end\n  end\n\n  defp validate_header_key!(_adapter, _key) do\n    :ok\n  end\n\n  # Any string containing an UPPERCASE char is not valid.\n  defp valid_header_key?(<<h, _::binary>>) when h in ?A..?Z, do: false\n  defp valid_header_key?(<<_, t::binary>>), do: valid_header_key?(t)\n  defp valid_header_key?(<<>>), do: true\n  defp valid_header_key?(_), do: false\n\n  defp validate_header_value!(value) do\n    case :binary.match(value, [\"\\n\", \"\\r\"]) do\n      {_, _}   -> raise InvalidHeaderError, \"header value contains control feed (\\\\r) or newline (\\\\n): \" <> inspect(value)\n      :nomatch -> :ok\n    end\n  end\nend\n\ndefimpl Inspect, for: Plug.Conn do\n  def inspect(conn, opts) do\n    conn =\n      if opts.limit == :infinity do\n        conn\n      else\n        update_in conn.adapter, fn {adapter, _data} -> {adapter, :...} end\n      end\n\n    Inspect.Any.inspect(conn, opts)\n  end\nend\n\ndefimpl Collectable, for: Plug.Conn do\n  def into(conn) do\n    {conn, fn\n      conn, {:cont, x} ->\n        {:ok, conn} = Plug.Conn.chunk(conn, x)\n        conn\n      conn, _ ->\n        conn\n    end}\n  end\nend\n", "defmodule Plug.ConnTest do\n  use ExUnit.Case, async: true\n  use Plug.Test\n\n  alias Plug.Conn\n  alias Plug.ProcessStore\n\n  test \"test adapter builds on connection\" do\n    conn = Plug.Adapters.Test.Conn.conn(%Plug.Conn{private: %{hello: :world}}, :post, \"/hello\", nil)\n    assert conn.method == \"POST\"\n    assert conn.path_info == [\"hello\"]\n    assert conn.private.hello == :world\n  end\n\n  test \"test adapter stores body in process before sending\" do\n    # The order of the lines below matters since we are testing if sent_body/1\n    # is returning the correct body even if they have the same owner process\n    conn = send_resp(conn(:get, \"/foo\"), 200, \"HELLO\")\n    another_conn = send_resp(conn(:get, \"/foo\"), 404, \"TEST\")\n\n    {status, _headers, body} = sent_resp(another_conn)\n    assert status == 404\n    assert body == \"TEST\"\n\n    {status, _headers, body} = sent_resp(conn)\n    assert status == 200\n    assert body == \"HELLO\"\n  end\n\n  test \"twice sending a response\" do\n    conn = conn(:get, \"/foo\")\n    send_resp(conn, 204, \"\")\n    send_resp(conn, 200, \"HELLO\")\n\n    assert_raise RuntimeError, ~r/sent more than once/, fn ->\n      sent_resp(conn)\n    end\n  end\n\n  test \"inspect/2\" do\n    assert inspect(conn(:get, \"/\")) =~ \"{Plug.Adapters.Test.Conn, :...}\"\n    refute inspect(conn(:get, \"/\"), limit: :infinity) =~ \"{Plug.Adapters.Test.Conn, :...}\"\n  end\n\n  test \"assign/3\" do\n    conn = conn(:get, \"/\")\n    assert conn.assigns[:hello] == nil\n    conn = assign(conn, :hello, :world)\n    assert conn.assigns[:hello] == :world\n  end\n\n  test \"async_assign/3 and await_assign/3\" do\n    conn = conn(:get, \"/\")\n    assert conn.assigns[:hello] == nil\n    conn = async_assign(conn, :hello, fn -> :world end)\n    conn = await_assign(conn, :hello)\n    assert conn.assigns[:hello] == :world\n  end\n\n  test \"put_status/2\" do\n    conn = conn(:get, \"/\")\n    assert put_status(conn, nil).status == nil\n    assert put_status(conn, 200).status == 200\n    assert put_status(conn, :ok).status == 200\n  end\n\n  test \"put_status/2 raises when the connection had already been sent\" do\n    conn = send_resp(conn(:get, \"/\"), 200, \"foo\")\n\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      put_status(conn, 200)\n    end\n\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      put_status(conn, nil)\n    end\n  end\n\n  test \"put_private/3\" do\n    conn = conn(:get, \"/\")\n    assert conn.private[:hello] == nil\n    conn = put_private(conn, :hello, :world)\n    assert conn.private[:hello] == :world\n  end\n\n  test \"scheme, host and port fields\" do\n    conn = conn(:get, \"/\")\n    assert conn.scheme == :http\n    assert conn.host == \"www.example.com\"\n    assert conn.port == 80\n\n    conn = conn(:get, \"https://127.0.0.1/\")\n    assert conn.scheme == :https\n    assert conn.host == \"127.0.0.1\"\n    assert conn.port == 443\n\n    conn = conn(:get, \"//example.com:8080/\")\n    assert conn.scheme == :http\n    assert conn.host == \"example.com\"\n    assert conn.port == 8080\n  end\n\n  test \"peer and remote_ip fields\" do\n    conn = conn(:get, \"/\")\n    assert conn.peer == {{127, 0, 0, 1}, 111_317}\n    assert conn.remote_ip == {127, 0, 0, 1}\n  end\n\n  test \"path_info\" do\n    assert conn(:get, \"/foo/bar\").path_info == ~w(foo bar)s\n    assert conn(:get, \"/foo/bar/\").path_info == ~w(foo bar)s\n    assert conn(:get, \"/foo//bar\").path_info == ~w(foo bar)s\n  end\n\n  test \"query_string\" do\n    assert conn(:get, \"/\").query_string == \"\"\n    assert conn(:get, \"/foo?barbat\").query_string == \"barbat\"\n    assert conn(:get, \"/foo/bar?bar=bat\").query_string == \"bar=bat\"\n  end\n\n  test \"request_path\" do\n    assert conn(:get, \"/\").request_path == \"/\"\n    assert conn(:get, \"/foo?barbat\").request_path == \"/foo\"\n    assert conn(:get, \"/foo/bar?bar=bat\").request_path == \"/foo/bar\"\n    assert conn(:get, \"/foo/bar/?bar=bat\").request_path == \"/foo/bar/\"\n    assert conn(:get, \"/foo//bar\").request_path == \"/foo//bar\"\n    assert conn(:get, \"/foo//bar//\").request_path == \"/foo//bar//\"\n  end\n\n  test \"status, resp_headers and resp_body\" do\n    conn = conn(:get, \"/foo\")\n    assert conn.status == nil\n    assert conn.resp_headers == [{\"cache-control\", \"max-age=0, private, must-revalidate\"}]\n    assert conn.resp_body == nil\n  end\n\n  test \"resp/3\" do\n    conn = conn(:get, \"/foo\")\n    assert conn.state == :unset\n    conn = resp(conn, 200, \"HELLO\")\n    assert conn.state == :set\n    assert conn.status == 200\n    assert conn.resp_body == \"HELLO\"\n\n    conn = resp(conn, :not_found, \"WORLD\")\n    assert conn.state == :set\n    assert conn.status == 404\n    assert conn.resp_body == \"WORLD\"\n  end\n\n  test \"resp/3 raises when connection was already sent\" do\n    conn = send_resp(conn(:head, \"/foo\"), 200, \"HELLO\")\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      resp(conn, 200, \"OTHER\")\n    end\n  end\n\n  test \"resp/3 raises when body is nil\" do\n    conn = conn(:head, \"/foo\")\n    assert_raise ArgumentError, fn ->\n      resp(conn, 200, nil)\n    end\n  end\n\n  test \"send_resp/3\" do\n    conn = conn(:get, \"/foo\")\n    assert conn.state == :unset\n    assert conn.resp_body == nil\n    conn = send_resp(conn, 200, \"HELLO\")\n    assert conn.status == 200\n    assert conn.resp_body == \"HELLO\"\n    assert conn.state == :sent\n  end\n\n  test \"send_resp/3 sends owner a message\" do\n    refute_received {:plug_conn, :sent}\n    send_resp(conn(:get, \"/foo\"), 200, \"HELLO\")\n    assert_received {:plug_conn, :sent}\n    resp(conn(:get, \"/foo\"), 200, \"HELLO\")\n    refute_received {:plug_conn, :sent}\n  end\n\n  test \"send_resp/3 does not send on head\" do\n    conn = send_resp(conn(:head, \"/foo\"), 200, \"HELLO\")\n    assert conn.resp_body == \"\"\n  end\n\n  test \"send_resp/3 raises when connection was already sent\" do\n    conn = send_resp(conn(:head, \"/foo\"), 200, \"HELLO\")\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      send_resp(conn, 200, \"OTHER\")\n    end\n  end\n\n  test \"send_resp/3 allows for iolist in the resp body\" do\n    refute_received {:plug_conn, :sent}\n    conn = send_resp(conn(:get, \"/foo\"), 200, [\"this \", [\"is\", \" nested\"]])\n    assert_received {:plug_conn, :sent}\n    assert conn.resp_body == \"this is nested\"\n  end\n\n  test \"send_resp/3 runs before_send callbacks\" do\n    conn = conn(:get, \"/foo\")\n           |> register_before_send(&put_resp_header(&1, \"x-body\", &1.resp_body))\n           |> register_before_send(&put_resp_header(&1, \"x-body\", \"default\"))\n           |> send_resp(200, \"body\")\n\n    assert get_resp_header(conn, \"x-body\") == [\"body\"]\n  end\n\n  test \"send_resp/3 uses the before_send status and body\" do\n    conn = conn(:get, \"/foo\")\n           |> register_before_send(&resp(&1, 200, \"new body\"))\n           |> send_resp(204, \"\")\n\n    assert conn.status == 200\n    assert conn.resp_body == \"new body\"\n  end\n\n  test \"send_resp/3 uses the before_send cookies\" do\n    conn = conn(:get, \"/foo\")\n           |> register_before_send(&put_resp_cookie(&1, \"hello\", \"world\"))\n           |> send_resp(200, \"\")\n\n    assert conn.resp_cookies[\"hello\"] == %{value: \"world\"}\n  end\n\n  test \"send_resp/1 raises if the connection was unset\" do\n    conn = conn(:get, \"/goo\")\n    assert_raise ArgumentError, fn ->\n      send_resp(conn)\n    end\n  end\n\n  test \"send_resp/1 raises if the connection was already sent\" do\n    conn = send_resp(conn(:get, \"/boo\") , 200, \"ok\")\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      send_resp(conn)\n    end\n  end\n\n  test \"send_file/3\" do\n    conn = send_file(conn(:get, \"/foo\"), 200, __ENV__.file)\n    assert conn.status == 200\n    assert conn.resp_body =~ \"send_file/3\"\n    assert conn.state == :sent\n  end\n\n  test \"send_file/3 raises on null-byte\" do\n    assert_raise ArgumentError, fn ->\n      send_file(conn(:get, \"/foo\"), 200, \"foo.md\\0.html\")\n    end\n  end\n\n  test \"send_file/3 sends self a message\" do\n    refute_received {:plug_conn, :sent}\n    send_file(conn(:get, \"/foo\"), 200, __ENV__.file)\n    assert_received {:plug_conn, :sent}\n  end\n\n  test \"send_file/3 does not send on head\" do\n    conn = send_file(conn(:head, \"/foo\"), 200, __ENV__.file)\n    assert conn.resp_body == \"\"\n  end\n\n  test \"send_file/3 raises when connection was already sent\" do\n    conn = send_file(conn(:head, \"/foo\"), 200, __ENV__.file)\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      send_file(conn, 200, __ENV__.file)\n    end\n  end\n\n  test \"send_file/3 runs before_send callbacks\" do\n    conn = conn(:get, \"/foo\")\n           |> register_before_send(&put_resp_header(&1, \"x-body\", &1.resp_body || \"FILE\"))\n           |> send_file(200, __ENV__.file)\n\n    assert get_resp_header(conn, \"x-body\") == [\"FILE\"]\n  end\n\n  test \"send_file/5 limits on offset\" do\n    %File.Stat{type: :regular, size: size} = File.stat!(__ENV__.file)\n    :rand.seed(:exs64)\n    offset = round(:rand.uniform() * size)\n    conn = send_file(conn(:get, \"/foo\"), 206, __ENV__.file, offset)\n    assert conn.status == 206\n    assert conn.state == :sent\n    assert byte_size(conn.resp_body) == (size - offset)\n  end\n\n  test \"send_file/5 limits on offset and length\" do\n    %File.Stat{type: :regular, size: size} = File.stat!(__ENV__.file)\n    :rand.seed(:exs64)\n    offset = round(:rand.uniform() * size)\n    length = round((size - offset) * 0.25)\n    conn = send_file(conn(:get, \"/foo\"), 206, __ENV__.file, offset, length)\n    assert conn.status == 206\n    assert conn.state == :sent\n    assert byte_size(conn.resp_body) == length\n  end\n\n  test \"send_chunked/3\" do\n    conn = send_chunked(conn(:get, \"/foo\"), 200)\n    assert conn.status == 200\n    assert conn.resp_body == \"\"\n    {:ok, conn} = chunk(conn, \"HELLO\\n\")\n    assert conn.resp_body == \"HELLO\\n\"\n    {:ok, conn} = chunk(conn, [\"WORLD\", [\"\\n\"]])\n    assert conn.resp_body == \"HELLO\\nWORLD\\n\"\n  end\n\n  test \"send_chunked/3 with collectable\" do\n    conn = send_chunked(conn(:get, \"/foo\"), 200)\n    conn = Enum.into(~w(hello world), conn)\n    assert conn.resp_body == \"helloworld\"\n  end\n\n  test \"send_chunked/3 sends self a message\" do\n    refute_received {:plug_conn, :sent}\n    send_chunked(conn(:get, \"/foo\"), 200)\n    assert_received {:plug_conn, :sent}\n  end\n\n  test \"send_chunked/3 does not send on head\" do\n    {:ok, conn} = conn(:head, \"/foo\") |> send_chunked(200) |> chunk(\"HELLO\")\n    assert conn.resp_body == \"\"\n  end\n\n  test \"send_chunked/3 raises when connection was already sent\" do\n    conn = send_chunked(conn(:head, \"/foo\"), 200)\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      send_chunked(conn, 200)\n    end\n  end\n\n  test \"send_chunked/3 runs before_send callbacks\" do\n    conn = conn(:get, \"/foo\")\n           |> register_before_send(&put_resp_header(&1, \"x-body\", &1.resp_body || \"CHUNK\"))\n           |> send_chunked(200)\n\n    assert get_resp_header(conn, \"x-body\") == [\"CHUNK\"]\n  end\n\n  test \"chunk/2 raises if send_chunked/3 hasn't been called yet\" do\n    conn = conn(:get, \"/\")\n    assert_raise ArgumentError, fn ->\n      chunk(conn, \"foobar\")\n    end\n  end\n\n  test \"put_resp_header/3\" do\n    conn1 = put_resp_header(conn(:head, \"/foo\"), \"x-foo\", \"bar\")\n    assert get_resp_header(conn1, \"x-foo\") == [\"bar\"]\n    conn2 = put_resp_header(conn1, \"x-foo\", \"baz\")\n    assert get_resp_header(conn2, \"x-foo\") == [\"baz\"]\n    assert length(conn1.resp_headers) ==\n           length(conn2.resp_headers)\n  end\n\n  test \"put_resp_header/3 raises when the conn was already been sent\" do\n    conn = send_resp(conn(:get, \"/foo\"), 200, \"ok\")\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      put_resp_header(conn, \"x-foo\", \"bar\")\n    end\n  end\n\n  test \"put_resp_header/3 raises when invalid header key given\" do\n    conn = conn(:get, \"/foo\")\n    assert_raise Plug.Conn.InvalidHeaderError, ~S[header key is not lowercase: \"X-Foo\"], fn ->\n      put_resp_header(conn, \"X-Foo\", \"bar\")\n    end\n  end\n\n  test \"put_resp_header/3 raises when invalid header value given\" do\n    assert_raise Plug.Conn.InvalidHeaderError, ~S[header value contains control feed (\\r) or newline (\\n): \"value\\rBAR\"], fn ->\n      put_resp_header(conn(:get, \"foo\"), \"x-sample\", \"value\\rBAR\")\n    end\n\n    assert_raise Plug.Conn.InvalidHeaderError, ~S[header value contains control feed (\\r) or newline (\\n): \"value\\n\\nBAR\"], fn ->\n      put_resp_header(conn(:get, \"foo\"), \"x-sample\", \"value\\n\\nBAR\")\n    end\n  end\n\n  test \"merge_resp_headers/3\" do\n    conn1 = merge_resp_headers(conn(:head, \"/foo\"), %{\"x-foo\" => \"bar\", \"x-bar\" => \"baz\"})\n    assert get_resp_header(conn1, \"x-foo\") == [\"bar\"]\n    assert get_resp_header(conn1, \"x-bar\") == [\"baz\"]\n    conn2 = merge_resp_headers(conn1, %{\"x-foo\" => \"new\"})\n    assert get_resp_header(conn2, \"x-foo\") == [\"new\"]\n    assert get_resp_header(conn2, \"x-bar\") == [\"baz\"]\n    assert length(conn1.resp_headers) ==\n           length(conn2.resp_headers)\n  end\n\n  test \"delete_resp_header/2\" do\n    conn = put_resp_header(conn(:head, \"/foo\"), \"x-foo\", \"bar\")\n    assert get_resp_header(conn, \"x-foo\") == [\"bar\"]\n    conn = delete_resp_header(conn, \"x-foo\")\n    assert get_resp_header(conn, \"x-foo\") == []\n  end\n\n  test \"delete_resp_header/2 raises when the conn was already been sent\" do\n    conn = send_resp(conn(:head, \"/foo\"), 200, \"ok\")\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      delete_resp_header(conn, \"x-foo\")\n    end\n  end\n\n  test \"update_resp_header/4\" do\n    conn1 = put_resp_header(conn(:head, \"/foo\"), \"x-foo\", \"bar\")\n    conn2 = update_resp_header(conn1, \"x-foo\", \"bong\", &(&1 <> \", baz\"))\n    assert get_resp_header(conn2, \"x-foo\") == [\"bar, baz\"]\n    assert length(conn1.resp_headers) == length(conn2.resp_headers)\n\n    conn1 = conn(:head, \"/foo\")\n    conn2 = update_resp_header(conn1, \"x-foo\", \"bong\", &(&1 <> \", baz\"))\n    assert get_resp_header(conn2, \"x-foo\") == [\"bong\"]\n\n    conn1 = %{conn(:head, \"/foo\") | resp_headers:\n      [{\"x-foo\", \"foo\"}, {\"x-foo\", \"bar\"}]}\n    conn2 = update_resp_header(conn1, \"x-foo\", \"in\", &String.upcase/1)\n    assert get_resp_header(conn2, \"x-foo\") == [\"FOO\", \"bar\"]\n  end\n\n  test \"update_resp_header/4 raises when the conn was already been sent\" do\n    conn = send_resp(conn(:head, \"/foo\"), 200, \"ok\")\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      update_resp_header(conn, \"x-foo\", \"init\", &(&1))\n    end\n  end\n\n  test \"put_resp_content_type/3\" do\n    conn = conn(:head, \"/foo\")\n\n    assert {\"content-type\", \"text/html; charset=utf-8\"} in\n           put_resp_content_type(conn, \"text/html\").resp_headers\n\n    assert {\"content-type\", \"text/html; charset=iso\"} in\n           put_resp_content_type(conn, \"text/html\", \"iso\").resp_headers\n\n    assert {\"content-type\", \"text/html\"} in\n           put_resp_content_type(conn, \"text/html\", nil).resp_headers\n  end\n\n  test \"resp/3 and send_resp/1\" do\n    conn = resp(conn(:get, \"/foo\"), 200, \"HELLO\")\n    assert conn.status == 200\n    assert conn.resp_body == \"HELLO\"\n\n    conn = send_resp(conn)\n    assert conn.status == 200\n    assert conn.resp_body == \"HELLO\"\n  end\n\n  test \"get_req_header/2, put_req_header/3 and delete_req_header/2\" do\n    conn = conn(:get, \"/\")\n    assert get_req_header(conn, \"foo\") == []\n\n    conn = put_req_header(conn, \"foo\", \"bar\")\n    assert get_req_header(conn, \"foo\") == [\"bar\"]\n\n    conn = put_req_header(conn, \"foo\", \"baz\")\n    assert get_req_header(conn, \"foo\") == [\"baz\"]\n\n    conn = delete_req_header(conn, \"foo\")\n    assert get_req_header(conn, \"foo\") == []\n  end\n\n  test \"put_req_header/3\" do\n    conn1 = put_req_header(conn(:head, \"/foo\"), \"x-foo\", \"bar\")\n    assert get_req_header(conn1, \"x-foo\") == [\"bar\"]\n    conn2 = put_req_header(conn1, \"x-foo\", \"baz\")\n    assert get_req_header(conn2, \"x-foo\") == [\"baz\"]\n    assert length(conn1.req_headers) ==\n           length(conn2.req_headers)\n  end\n\n  test \"put_req_header/3 raises when the conn was already been sent\" do\n    conn = send_resp(conn(:get, \"/foo\"), 200, \"ok\")\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      put_req_header(conn, \"x-foo\", \"bar\")\n    end\n  end\n\n  test \"put_req_header/3 raises when invalid header key given\" do\n    conn = conn(:get, \"/foo\")\n    assert_raise Plug.Conn.InvalidHeaderError, ~S[header key is not lowercase: \"X-Foo\"], fn ->\n      put_req_header(conn, \"X-Foo\", \"bar\")\n    end\n  end\n\n  test \"delete_req_header/2\" do\n    conn = put_req_header(conn(:head, \"/foo\"), \"x-foo\", \"bar\")\n    assert get_req_header(conn, \"x-foo\") == [\"bar\"]\n    conn = delete_req_header(conn, \"x-foo\")\n    assert get_req_header(conn, \"x-foo\") == []\n  end\n\n  test \"delete_req_header/2 raises when the conn was already been sent\" do\n    conn = send_resp(conn(:head, \"/foo\"), 200, \"ok\")\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      delete_req_header(conn, \"x-foo\")\n    end\n  end\n\n  test \"update_req_header/4\" do\n    conn1 = put_req_header(conn(:head, \"/foo\"), \"x-foo\", \"bar\")\n    conn2 = update_req_header(conn1, \"x-foo\", \"bong\", &(&1 <> \", baz\"))\n    assert get_req_header(conn2, \"x-foo\") == [\"bar, baz\"]\n    assert length(conn1.req_headers) == length(conn2.req_headers)\n\n    conn1 = conn(:head, \"/foo\")\n    conn2 = update_req_header(conn1, \"x-foo\", \"bong\", &(&1 <> \", baz\"))\n    assert get_req_header(conn2, \"x-foo\") == [\"bong\"]\n\n    conn1 = %{conn(:head, \"/foo\") | req_headers:\n      [{\"x-foo\", \"foo\"}, {\"x-foo\", \"bar\"}]}\n    conn2 = update_req_header(conn1, \"x-foo\", \"in\", &String.upcase/1)\n    assert get_req_header(conn2, \"x-foo\") == [\"FOO\", \"bar\"]\n  end\n\n  test \"update_req_header/4 raises when the conn was already been sent\" do\n    conn = send_resp(conn(:head, \"/foo\"), 200, \"ok\")\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      update_req_header(conn, \"x-foo\", \"init\", &(&1))\n    end\n  end\n\n  test \"read_body/1\" do\n    body = :binary.copy(\"abcdefghij\", 1000)\n    conn = put_req_header(conn(:post, \"/foo\", body), \"content-type\", \"text/plain\")\n    assert {:ok, ^body, conn} = read_body(conn)\n    assert {:ok, \"\", _} = read_body(conn)\n  end\n\n  test \"read_body/2 partial retrieval\" do\n    body = :binary.copy(\"abcdefghij\", 100)\n    conn = put_req_header(conn(:post, \"/foo\", body), \"content-type\", \"text/plain\")\n    assert {:more, _, _} = read_body(conn, length: 100)\n  end\n\n  test \"query_params/1 and fetch_query_params/1\" do\n    conn = conn(:get, \"/foo?a=b&c=d\")\n    assert conn.query_params == %Plug.Conn.Unfetched{aspect: :query_params}\n    conn = fetch_query_params(conn)\n    assert conn.query_params == %{\"a\" => \"b\", \"c\" => \"d\"}\n\n    conn = fetch_query_params(conn(:get, \"/foo\"), []) # Pluggable\n    assert conn.query_params == %{}\n  end\n\n  test \"query_params/1, params/1 and fetch_query_params/1\" do\n    conn = conn(:get, \"/foo?a=b&c=d\")\n    assert conn.params == %Plug.Conn.Unfetched{aspect: :params}\n    conn = fetch_query_params(conn)\n    assert conn.params == %{\"a\" => \"b\", \"c\" => \"d\"}\n\n    conn = conn(:get, \"/foo?a=b&c=d\")\n    conn = put_in conn.params, %{\"a\" => \"z\"}\n    conn = fetch_query_params(conn)\n    assert conn.params == %{\"a\" => \"z\", \"c\" => \"d\"}\n  end\n\n  test \"fetch_query_params/1 with invalid utf-8\" do\n    conn = conn(:get, \"/foo?a=\" <> <<139>>)\n    assert_raise Plug.Conn.InvalidQueryError,\n                 \"invalid UTF-8 on query string, got byte 139\", fn ->\n      fetch_query_params(conn)\n    end\n  end\n\n  test \"req_cookies/1 && fetch_cookies/1\" do\n    conn = put_req_header(conn(:get, \"/\"), \"cookie\", \"foo=bar; baz=bat\")\n    assert conn.req_cookies == %Plug.Conn.Unfetched{aspect: :cookies}\n    conn = fetch_cookies(conn)\n    assert conn.req_cookies == %{\"foo\" => \"bar\", \"baz\" => \"bat\"}\n\n    conn = fetch_cookies(conn(:get, \"/foo\"), []) # Pluggable\n    assert conn.req_cookies == %{}\n  end\n\n  test \"put_resp_cookie/4 and delete_resp_cookie/3\" do\n    conn = send_resp(conn(:get, \"/\"), 200, \"ok\")\n    assert get_resp_header(conn, \"set-cookie\") == []\n\n    conn = conn(:get, \"/\") |> put_resp_cookie(\"foo\", \"baz\", path: \"/baz\") |> send_resp(200, \"ok\")\n    assert conn.resp_cookies[\"foo\"] ==\n           %{value: \"baz\", path: \"/baz\"}\n    assert get_resp_header(conn, \"set-cookie\") ==\n           [\"foo=baz; path=/baz; HttpOnly\"]\n\n    conn = conn(:get, \"/\") |> put_resp_cookie(\"foo\", \"baz\") |>\n           delete_resp_cookie(\"foo\", path: \"/baz\") |> send_resp(200, \"ok\")\n    assert conn.resp_cookies[\"foo\"] ==\n           %{max_age: 0, universal_time: {{1970, 1, 1}, {0, 0, 0}}, path: \"/baz\"}\n    assert get_resp_header(conn, \"set-cookie\") ==\n           [\"foo=; path=/baz; expires=Thu, 01 Jan 1970 00:00:00 GMT; max-age=0; HttpOnly\"]\n  end\n\n  test \"put_resp_cookie/4 raises when over 4096 bytes\" do\n    assert_raise Plug.Conn.CookieOverflowError, fn ->\n      conn(:get, \"/\")\n      |> put_resp_cookie(\"foo\", String.duplicate(\"a\", 4095))\n      |> send_resp(200, \"OK\")\n    end\n  end\n\n  test \"put_resp_cookie/4 raises on new line\" do\n    assert_raise Plug.Conn.InvalidHeaderError, fn ->\n      conn(:get, \"/\")\n      |> put_resp_cookie(\"foo\", \"bar\\nbaz\")\n      |> send_resp(200, \"OK\")\n    end\n  end\n\n  test \"put_resp_cookie/4 is secure on https\" do\n    conn = conn(:get, \"https://example.com/\")\n           |> put_resp_cookie(\"foo\", \"baz\", path: \"/baz\")\n           |> send_resp(200, \"ok\")\n    assert conn.resp_cookies[\"foo\"] ==\n           %{value: \"baz\", path: \"/baz\", secure: true}\n\n    conn = conn(:get, \"https://example.com/\")\n           |> put_resp_cookie(\"foo\", \"baz\", path: \"/baz\", secure: false)\n           |> send_resp(200, \"ok\")\n    assert conn.resp_cookies[\"foo\"] ==\n           %{value: \"baz\", path: \"/baz\", secure: false}\n  end\n\n  test \"put_req_cookie/3 and delete_req_cookie/2\" do\n    conn = conn(:get, \"/\")\n    assert get_req_header(conn, \"cookie\") == []\n\n    conn = put_req_cookie(conn, \"foo\", \"bar\")\n    assert get_req_header(conn, \"cookie\") == [\"foo=bar\"]\n\n    conn = delete_req_cookie(conn, \"foo\")\n    assert get_req_header(conn, \"cookie\") == []\n\n    conn = conn |> put_req_cookie(\"foo\", \"bar\") |> put_req_cookie(\"baz\", \"bat\") |> fetch_cookies\n    assert conn.req_cookies[\"foo\"] == \"bar\"\n    assert conn.req_cookies[\"baz\"] == \"bat\"\n\n    assert_raise ArgumentError, fn ->\n      put_req_cookie(conn, \"foo\", \"bar\")\n    end\n  end\n\n  test \"put_resp_cookie/4 and delete_resp_cookie/3 raise when the connection was already sent\" do\n    conn = send_resp(conn(:get, \"/foo\"), 200, \"ok\")\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      put_resp_cookie(conn, \"foo\", \"bar\")\n    end\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      delete_resp_cookie(conn, \"foo\")\n    end\n  end\n\n  test \"recycle_cookies/2\" do\n    conn = conn(:get, \"/foo\", a: \"b\", c: [%{d: \"e\"}, \"f\"])\n           |> put_req_cookie(\"req_cookie\", \"req_cookie\")\n           |> put_req_cookie(\"del_cookie\", \"del_cookie\")\n           |> put_req_cookie(\"over_cookie\", \"pre_cookie\")\n           |> put_resp_cookie(\"over_cookie\", \"pos_cookie\")\n           |> put_resp_cookie(\"resp_cookie\", \"resp_cookie\")\n           |> delete_resp_cookie(\"del_cookie\")\n\n    conn = conn(:get, \"/\") |> recycle_cookies(conn) |> fetch_cookies()\n    assert conn.cookies == %{\"req_cookie\"  => \"req_cookie\",\n                             \"over_cookie\" => \"pos_cookie\",\n                             \"resp_cookie\" => \"resp_cookie\"}\n  end\n\n  test \"cookies/1 loaded early\" do\n    conn = put_req_cookie(conn(:get, \"/\"), \"foo\", \"bar\")\n    assert conn.cookies == %Plug.Conn.Unfetched{aspect: :cookies}\n\n    conn = fetch_cookies(conn)\n    assert conn.cookies[\"foo\"] == \"bar\"\n\n    conn = put_resp_cookie(conn, \"bar\", \"baz\")\n    assert conn.cookies[\"bar\"] == \"baz\"\n\n    conn = put_resp_cookie(conn, \"foo\", \"baz\")\n    assert conn.cookies[\"foo\"] == \"baz\"\n\n    conn = delete_resp_cookie(conn, \"foo\")\n    refute conn.cookies[\"foo\"]\n  end\n\n  test \"cookies/1 loaded late\" do\n    conn = conn(:get, \"/\") |> put_req_cookie(\"foo\", \"bar\") |> put_req_cookie(\"bar\", \"baz\")\n    assert conn.cookies == %Plug.Conn.Unfetched{aspect: :cookies}\n\n    conn = conn |> put_resp_cookie(\"foo\", \"baz\") |> put_resp_cookie(\"baz\", \"bat\") |>\n           delete_resp_cookie(\"bar\") |> fetch_cookies\n\n    assert conn.cookies[\"foo\"] == \"baz\"\n    assert conn.cookies[\"baz\"] == \"bat\"\n    refute conn.cookies[\"bar\"]\n  end\n\n  test \"fetch_session/2 returns the same conn on subsequent calls\" do\n    opts = Plug.Session.init(store: ProcessStore, key: \"foobar\")\n    conn = conn(:get, \"/\") |> Plug.Session.call(opts) |> fetch_session()\n\n    assert fetch_session(conn) == conn\n  end\n\n  test \"session not fetched\" do\n    conn = conn(:get, \"/\")\n\n    assert_raise ArgumentError, \"session not fetched, call fetch_session/2\", fn ->\n      get_session(conn, :foo)\n    end\n\n    assert_raise ArgumentError, \"cannot fetch session without a configured session plug\", fn ->\n      fetch_session(conn)\n    end\n\n    opts = Plug.Session.init(store: ProcessStore, key: \"foobar\")\n    conn = Plug.Session.call(conn, opts)\n\n    assert_raise ArgumentError, \"session not fetched, call fetch_session/2\", fn ->\n      get_session(conn, :foo)\n    end\n\n    conn = fetch_session(conn, []) # Pluggable\n    get_session(conn, :foo)\n  end\n\n  test \"get and put session\" do\n    opts = Plug.Session.init(store: ProcessStore, key: \"foobar\")\n    conn = conn(:get, \"/\") |> Plug.Session.call(opts) |> fetch_session()\n\n    conn = put_session(conn, \"foo\", :bar)\n    conn = put_session(conn, :key, 42)\n\n    assert conn.private[:plug_session_info] == :write\n\n    assert get_session(conn, :foo) == :bar\n    assert get_session(conn, :key) == 42\n    assert get_session(conn, :unknown) == nil\n    assert get_session(conn, \"foo\") == :bar\n    assert get_session(conn, \"key\") == 42\n    assert get_session(conn, \"unknown\") == nil\n\n    conn = %{conn|state: :sent}\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      put_session(conn, :key, 42)\n    end\n\n    conn = %{conn|state: :file}\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      put_session(conn, :key, 42)\n    end\n\n    conn = %{conn|state: :chunked}\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      put_session(conn, :key, 42)\n    end\n  end\n\n  test \"configure_session/2\" do\n    opts = Plug.Session.init(store: ProcessStore, key: \"foobar\")\n    conn = conn(:get, \"/\") |> Plug.Session.call(opts) |> fetch_session()\n\n    conn = configure_session(conn, drop: false, renew: false)\n    assert conn.private[:plug_session_info] == nil\n\n    conn = configure_session(conn, drop: true)\n    assert conn.private[:plug_session_info] == :drop\n\n    conn = configure_session(conn, renew: true)\n    assert conn.private[:plug_session_info] == :renew\n\n    conn = put_session(conn, \"foo\", \"bar\")\n    assert conn.private[:plug_session_info] == :renew\n\n    conn = %{conn|state: :sent}\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      configure_session(conn, renew: true)\n    end\n\n    conn = %{conn|state: :file}\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      configure_session(conn, renew: true)\n    end\n\n    conn = %{conn|state: :chunked}\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      configure_session(conn, renew: true)\n    end\n  end\n\n  test \"configure_session/2 fails when there is no session\" do\n    conn = conn(:get, \"/\")\n    assert_raise ArgumentError, fn ->\n      configure_session(conn, drop: true)\n    end\n  end\n\n  test \"delete_session/2\" do\n    opts = Plug.Session.init(store: ProcessStore, key: \"foobar\")\n    conn = conn(:get, \"/\") |> Plug.Session.call(opts) |> fetch_session()\n\n    conn = conn\n            |> put_session(\"foo\", \"bar\")\n            |> put_session(\"baz\", \"boom\")\n            |> delete_session(\"baz\")\n\n    assert get_session(conn, \"foo\") == \"bar\"\n    assert get_session(conn, \"baz\") == nil\n\n    conn = %{conn|state: :sent}\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      delete_session(conn, \"baz\")\n    end\n\n    conn = %{conn|state: :file}\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      delete_session(conn, \"baz\")\n    end\n\n    conn = %{conn|state: :chunked}\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      delete_session(conn, \"baz\")\n    end\n  end\n\n  test \"clear_session/1\" do\n    opts = Plug.Session.init(store: ProcessStore, key: \"foobar\")\n    conn = conn(:get, \"/\") |> Plug.Session.call(opts) |> fetch_session()\n\n    conn = conn\n            |> put_session(\"foo\", \"bar\")\n            |> put_session(\"baz\", \"boom\")\n            |> clear_session\n\n    assert get_session(conn, \"foo\") == nil\n    assert get_session(conn, \"baz\") == nil\n  end\n\n  test \"halt/1 updates halted to true\" do\n    conn = %Conn{}\n    assert conn.halted == false\n    conn = halt(conn)\n    assert conn.halted == true\n  end\n\n  test \"register_before_send/2 raises when a response has already been sent\" do\n    conn = send_resp(conn(:get, \"/\"), 200, \"ok\")\n    assert_raise Plug.Conn.AlreadySentError, fn ->\n      register_before_send(conn, fn(_) -> nil end)\n    end\n  end\n\n  test \"does not delegate to connections' adapter's chunk/2 when called with emtpy chunk\" do\n    defmodule RaisesOnEmptyChunkAdapter do\n      defdelegate send_chunked(state, status, headers), to: Plug.Adapters.Test.Conn\n\n      def chunk(_payload, \"\"), do: raise \"the empty chunk was unexpectedly sent\"\n      def chunk(payload, chunk), do: Plug.Adapters.Test.Conn.chunk(payload, chunk)\n    end\n\n    conn = %Conn{\n      adapter: {RaisesOnEmptyChunkAdapter, %{chunks: \"\"}},\n      owner: self(),\n      state: :unset\n    }\n    conn = Plug.Conn.send_chunked(conn, 200)\n\n    assert {:ok, conn} == Plug.Conn.chunk(conn, \"\")\n  end\nend\n"], "filenames": ["lib/plug/conn.ex", "test/plug/conn_test.exs"], "buggy_code_start_loc": [992, 607], "buggy_code_end_loc": [992, 607], "fixing_code_start_loc": [993, 608], "fixing_code_end_loc": [994, 616], "type": "CWE-20", "message": "Elixir Plug Plug version All contains a Header Injection vulnerability in Connection that can result in Given a cookie value, Headers can be added. This attack appear to be exploitable via Crafting a value to be sent as a cookie. This vulnerability appears to have been fixed in >= 1.3.5 or ~> 1.2.5 or ~> 1.1.9 or ~> 1.0.6.", "other": {"cve": {"id": "CVE-2018-1000883", "sourceIdentifier": "cve@mitre.org", "published": "2018-12-20T21:29:00.290", "lastModified": "2019-02-14T01:58:54.820", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Elixir Plug Plug version All contains a Header Injection vulnerability in Connection that can result in Given a cookie value, Headers can be added. This attack appear to be exploitable via Crafting a value to be sent as a cookie. This vulnerability appears to have been fixed in >= 1.3.5 or ~> 1.2.5 or ~> 1.1.9 or ~> 1.0.6."}, {"lang": "es", "value": "Elixir Plug Plug, en todas las versiones, contiene una vulnerabilidad de inyecci\u00f3n de cabeceras que puede resultar en la adici\u00f3n de una cabecera, dado un valor de la cookie. El ataque parece ser explotable mediante la manipulaci\u00f3n de un valor para que sea enviado como cookie. La vulnerabilidad parece haber sido solucionada a partir de la versi\u00f3n 1.3.5 o en las versiones 1.2.5, 1.1.9 o 1.0.6."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:plug_project:plug:*:*:*:*:*:*:*:*", "versionStartExcluding": "1.0.6", "versionEndIncluding": "1.1.9", "matchCriteriaId": "62E71DD1-9113-48D5-97BE-7D2600E67579"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:plug_project:plug:*:*:*:*:*:*:*:*", "versionStartExcluding": "1.1.9", "versionEndIncluding": "1.2.5", "matchCriteriaId": "8B0F9D90-1DA7-4BBA-BE51-CD598C45AD69"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:plug_project:plug:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.2.5", "versionEndExcluding": "1.3.5", "matchCriteriaId": "8A567A67-C7FF-4EF8-A332-C6793C3A29DD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:plug_project:plug:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.3.5", "matchCriteriaId": "BF83B69D-B326-4E42-B805-FBDBCAE74763"}]}]}], "references": [{"url": "https://github.com/dependabot/elixir-security-advisories/blob/master/packages/plug/2017-04-17.yml", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/elixir-plug/plug/commit/8857f8ab4acf9b9c22e80480dae2636692f5f573", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/elixir-plug/plug/commit/8857f8ab4acf9b9c22e80480dae2636692f5f573"}}