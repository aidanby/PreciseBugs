{"buggy_code": ["/*\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"fmacros.h\"\n#include \"fpconv_dtoa.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <limits.h>\n#include <math.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <float.h>\n#include <stdint.h>\n#include <errno.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <libgen.h>\n\n#include \"util.h\"\n#include \"sha256.h\"\n#include \"config.h\"\n\n#define UNUSED(x) ((void)(x))\n\n/* Glob-style pattern matching. */\nint stringmatchlen(const char *pattern, int patternLen,\n        const char *string, int stringLen, int nocase)\n{\n    while(patternLen && stringLen) {\n        switch(pattern[0]) {\n        case '*':\n            while (patternLen && pattern[1] == '*') {\n                pattern++;\n                patternLen--;\n            }\n            if (patternLen == 1)\n                return 1; /* match */\n            while(stringLen) {\n                if (stringmatchlen(pattern+1, patternLen-1,\n                            string, stringLen, nocase))\n                    return 1; /* match */\n                string++;\n                stringLen--;\n            }\n            return 0; /* no match */\n            break;\n        case '?':\n            string++;\n            stringLen--;\n            break;\n        case '[':\n        {\n            int not, match;\n\n            pattern++;\n            patternLen--;\n            not = pattern[0] == '^';\n            if (not) {\n                pattern++;\n                patternLen--;\n            }\n            match = 0;\n            while(1) {\n                if (pattern[0] == '\\\\' && patternLen >= 2) {\n                    pattern++;\n                    patternLen--;\n                    if (pattern[0] == string[0])\n                        match = 1;\n                } else if (pattern[0] == ']') {\n                    break;\n                } else if (patternLen == 0) {\n                    pattern--;\n                    patternLen++;\n                    break;\n                } else if (patternLen >= 3 && pattern[1] == '-') {\n                    int start = pattern[0];\n                    int end = pattern[2];\n                    int c = string[0];\n                    if (start > end) {\n                        int t = start;\n                        start = end;\n                        end = t;\n                    }\n                    if (nocase) {\n                        start = tolower(start);\n                        end = tolower(end);\n                        c = tolower(c);\n                    }\n                    pattern += 2;\n                    patternLen -= 2;\n                    if (c >= start && c <= end)\n                        match = 1;\n                } else {\n                    if (!nocase) {\n                        if (pattern[0] == string[0])\n                            match = 1;\n                    } else {\n                        if (tolower((int)pattern[0]) == tolower((int)string[0]))\n                            match = 1;\n                    }\n                }\n                pattern++;\n                patternLen--;\n            }\n            if (not)\n                match = !match;\n            if (!match)\n                return 0; /* no match */\n            string++;\n            stringLen--;\n            break;\n        }\n        case '\\\\':\n            if (patternLen >= 2) {\n                pattern++;\n                patternLen--;\n            }\n            /* fall through */\n        default:\n            if (!nocase) {\n                if (pattern[0] != string[0])\n                    return 0; /* no match */\n            } else {\n                if (tolower((int)pattern[0]) != tolower((int)string[0]))\n                    return 0; /* no match */\n            }\n            string++;\n            stringLen--;\n            break;\n        }\n        pattern++;\n        patternLen--;\n        if (stringLen == 0) {\n            while(*pattern == '*') {\n                pattern++;\n                patternLen--;\n            }\n            break;\n        }\n    }\n    if (patternLen == 0 && stringLen == 0)\n        return 1;\n    return 0;\n}\n\nint stringmatch(const char *pattern, const char *string, int nocase) {\n    return stringmatchlen(pattern,strlen(pattern),string,strlen(string),nocase);\n}\n\n/* Fuzz stringmatchlen() trying to crash it with bad input. */\nint stringmatchlen_fuzz_test(void) {\n    char str[32];\n    char pat[32];\n    int cycles = 10000000;\n    int total_matches = 0;\n    while(cycles--) {\n        int strlen = rand() % sizeof(str);\n        int patlen = rand() % sizeof(pat);\n        for (int j = 0; j < strlen; j++) str[j] = rand() % 128;\n        for (int j = 0; j < patlen; j++) pat[j] = rand() % 128;\n        total_matches += stringmatchlen(pat, patlen, str, strlen, 0);\n    }\n    return total_matches;\n}\n\n\n/* Convert a string representing an amount of memory into the number of\n * bytes, so for instance memtoull(\"1Gb\") will return 1073741824 that is\n * (1024*1024*1024).\n *\n * On parsing error, if *err is not NULL, it's set to 1, otherwise it's\n * set to 0. On error the function return value is 0, regardless of the\n * fact 'err' is NULL or not. */\nunsigned long long memtoull(const char *p, int *err) {\n    const char *u;\n    char buf[128];\n    long mul; /* unit multiplier */\n    unsigned long long val;\n    unsigned int digits;\n\n    if (err) *err = 0;\n\n    /* Search the first non digit character. */\n    u = p;\n    if (*u == '-') {\n        if (err) *err = 1;\n        return 0;\n    }\n    while(*u && isdigit(*u)) u++;\n    if (*u == '\\0' || !strcasecmp(u,\"b\")) {\n        mul = 1;\n    } else if (!strcasecmp(u,\"k\")) {\n        mul = 1000;\n    } else if (!strcasecmp(u,\"kb\")) {\n        mul = 1024;\n    } else if (!strcasecmp(u,\"m\")) {\n        mul = 1000*1000;\n    } else if (!strcasecmp(u,\"mb\")) {\n        mul = 1024*1024;\n    } else if (!strcasecmp(u,\"g\")) {\n        mul = 1000L*1000*1000;\n    } else if (!strcasecmp(u,\"gb\")) {\n        mul = 1024L*1024*1024;\n    } else {\n        if (err) *err = 1;\n        return 0;\n    }\n\n    /* Copy the digits into a buffer, we'll use strtoll() to convert\n     * the digit (without the unit) into a number. */\n    digits = u-p;\n    if (digits >= sizeof(buf)) {\n        if (err) *err = 1;\n        return 0;\n    }\n    memcpy(buf,p,digits);\n    buf[digits] = '\\0';\n\n    char *endptr;\n    errno = 0;\n    val = strtoull(buf,&endptr,10);\n    if ((val == 0 && errno == EINVAL) || *endptr != '\\0') {\n        if (err) *err = 1;\n        return 0;\n    }\n    return val*mul;\n}\n\n/* Search a memory buffer for any set of bytes, like strpbrk().\n * Returns pointer to first found char or NULL.\n */\nconst char *mempbrk(const char *s, size_t len, const char *chars, size_t charslen) {\n    for (size_t j = 0; j < len; j++) {\n        for (size_t n = 0; n < charslen; n++)\n            if (s[j] == chars[n]) return &s[j];\n    }\n\n    return NULL;\n}\n\n/* Modify the buffer replacing all occurrences of chars from the 'from'\n * set with the corresponding char in the 'to' set. Always returns s.\n */\nchar *memmapchars(char *s, size_t len, const char *from, const char *to, size_t setlen) {\n    for (size_t j = 0; j < len; j++) {\n        for (size_t i = 0; i < setlen; i++) {\n            if (s[j] == from[i]) {\n                s[j] = to[i];\n                break;\n            }\n        }\n    }\n    return s;\n}\n\n/* Return the number of digits of 'v' when converted to string in radix 10.\n * See ll2string() for more information. */\nuint32_t digits10(uint64_t v) {\n    if (v < 10) return 1;\n    if (v < 100) return 2;\n    if (v < 1000) return 3;\n    if (v < 1000000000000UL) {\n        if (v < 100000000UL) {\n            if (v < 1000000) {\n                if (v < 10000) return 4;\n                return 5 + (v >= 100000);\n            }\n            return 7 + (v >= 10000000UL);\n        }\n        if (v < 10000000000UL) {\n            return 9 + (v >= 1000000000UL);\n        }\n        return 11 + (v >= 100000000000UL);\n    }\n    return 12 + digits10(v / 1000000000000UL);\n}\n\n/* Like digits10() but for signed values. */\nuint32_t sdigits10(int64_t v) {\n    if (v < 0) {\n        /* Abs value of LLONG_MIN requires special handling. */\n        uint64_t uv = (v != LLONG_MIN) ?\n                      (uint64_t)-v : ((uint64_t) LLONG_MAX)+1;\n        return digits10(uv)+1; /* +1 for the minus. */\n    } else {\n        return digits10(v);\n    }\n}\n\n/* Convert a long long into a string. Returns the number of\n * characters needed to represent the number.\n * If the buffer is not big enough to store the string, 0 is returned. */\nint ll2string(char *dst, size_t dstlen, long long svalue) {\n    unsigned long long value;\n    int negative = 0;\n\n    /* The ull2string function with 64bit unsigned integers for simplicity, so\n     * we convert the number here and remember if it is negative. */\n    if (svalue < 0) {\n        if (svalue != LLONG_MIN) {\n            value = -svalue;\n        } else {\n            value = ((unsigned long long) LLONG_MAX)+1;\n        }\n        if (dstlen < 2)\n            goto err;\n        negative = 1;\n        dst[0] = '-';\n        dst++;\n        dstlen--;\n    } else {\n        value = svalue;\n    }\n\n    /* Converts the unsigned long long value to string*/\n    int length = ull2string(dst, dstlen, value);\n    if (length == 0) return 0;\n    return length + negative;\n\nerr:\n    /* force add Null termination */\n    if (dstlen > 0)\n        dst[0] = '\\0';\n    return 0;\n}\n\n/* Convert a unsigned long long into a string. Returns the number of\n * characters needed to represent the number.\n * If the buffer is not big enough to store the string, 0 is returned.\n *\n * Based on the following article (that apparently does not provide a\n * novel approach but only publicizes an already used technique):\n *\n * https://www.facebook.com/notes/facebook-engineering/three-optimization-tips-for-c/10151361643253920 */\nint ull2string(char *dst, size_t dstlen, unsigned long long value) {\n    static const char digits[201] =\n        \"0001020304050607080910111213141516171819\"\n        \"2021222324252627282930313233343536373839\"\n        \"4041424344454647484950515253545556575859\"\n        \"6061626364656667686970717273747576777879\"\n        \"8081828384858687888990919293949596979899\";\n\n    /* Check length. */\n    uint32_t length = digits10(value);\n    if (length >= dstlen) goto err;;\n\n    /* Null term. */\n    uint32_t next = length - 1;\n    dst[next + 1] = '\\0';\n    while (value >= 100) {\n        int const i = (value % 100) * 2;\n        value /= 100;\n        dst[next] = digits[i + 1];\n        dst[next - 1] = digits[i];\n        next -= 2;\n    }\n\n    /* Handle last 1-2 digits. */\n    if (value < 10) {\n        dst[next] = '0' + (uint32_t) value;\n    } else {\n        int i = (uint32_t) value * 2;\n        dst[next] = digits[i + 1];\n        dst[next - 1] = digits[i];\n    }\n    return length;\nerr:\n    /* force add Null termination */\n    if (dstlen > 0)\n        dst[0] = '\\0';\n    return 0;\n}\n\n/* Convert a string into a long long. Returns 1 if the string could be parsed\n * into a (non-overflowing) long long, 0 otherwise. The value will be set to\n * the parsed value when appropriate.\n *\n * Note that this function demands that the string strictly represents\n * a long long: no spaces or other characters before or after the string\n * representing the number are accepted, nor zeroes at the start if not\n * for the string \"0\" representing the zero number.\n *\n * Because of its strictness, it is safe to use this function to check if\n * you can convert a string into a long long, and obtain back the string\n * from the number without any loss in the string representation. */\nint string2ll(const char *s, size_t slen, long long *value) {\n    const char *p = s;\n    size_t plen = 0;\n    int negative = 0;\n    unsigned long long v;\n\n    /* A string of zero length or excessive length is not a valid number. */\n    if (plen == slen || slen >= LONG_STR_SIZE)\n        return 0;\n\n    /* Special case: first and only digit is 0. */\n    if (slen == 1 && p[0] == '0') {\n        if (value != NULL) *value = 0;\n        return 1;\n    }\n\n    /* Handle negative numbers: just set a flag and continue like if it\n     * was a positive number. Later convert into negative. */\n    if (p[0] == '-') {\n        negative = 1;\n        p++; plen++;\n\n        /* Abort on only a negative sign. */\n        if (plen == slen)\n            return 0;\n    }\n\n    /* First digit should be 1-9, otherwise the string should just be 0. */\n    if (p[0] >= '1' && p[0] <= '9') {\n        v = p[0]-'0';\n        p++; plen++;\n    } else {\n        return 0;\n    }\n\n    /* Parse all the other digits, checking for overflow at every step. */\n    while (plen < slen && p[0] >= '0' && p[0] <= '9') {\n        if (v > (ULLONG_MAX / 10)) /* Overflow. */\n            return 0;\n        v *= 10;\n\n        if (v > (ULLONG_MAX - (p[0]-'0'))) /* Overflow. */\n            return 0;\n        v += p[0]-'0';\n\n        p++; plen++;\n    }\n\n    /* Return if not all bytes were used. */\n    if (plen < slen)\n        return 0;\n\n    /* Convert to negative if needed, and do the final overflow check when\n     * converting from unsigned long long to long long. */\n    if (negative) {\n        if (v > ((unsigned long long)(-(LLONG_MIN+1))+1)) /* Overflow. */\n            return 0;\n        if (value != NULL) *value = -v;\n    } else {\n        if (v > LLONG_MAX) /* Overflow. */\n            return 0;\n        if (value != NULL) *value = v;\n    }\n    return 1;\n}\n\n/* Helper function to convert a string to an unsigned long long value.\n * The function attempts to use the faster string2ll() function inside\n * Redis: if it fails, strtoull() is used instead. The function returns\n * 1 if the conversion happened successfully or 0 if the number is\n * invalid or out of range. */\nint string2ull(const char *s, unsigned long long *value) {\n    long long ll;\n    if (string2ll(s,strlen(s),&ll)) {\n        if (ll < 0) return 0; /* Negative values are out of range. */\n        *value = ll;\n        return 1;\n    }\n    errno = 0;\n    char *endptr = NULL;\n    *value = strtoull(s,&endptr,10);\n    if (errno == EINVAL || errno == ERANGE || !(*s != '\\0' && *endptr == '\\0'))\n        return 0; /* strtoull() failed. */\n    return 1; /* Conversion done! */\n}\n\n/* Convert a string into a long. Returns 1 if the string could be parsed into a\n * (non-overflowing) long, 0 otherwise. The value will be set to the parsed\n * value when appropriate. */\nint string2l(const char *s, size_t slen, long *lval) {\n    long long llval;\n\n    if (!string2ll(s,slen,&llval))\n        return 0;\n\n    if (llval < LONG_MIN || llval > LONG_MAX)\n        return 0;\n\n    *lval = (long)llval;\n    return 1;\n}\n\n/* Convert a string into a double. Returns 1 if the string could be parsed\n * into a (non-overflowing) double, 0 otherwise. The value will be set to\n * the parsed value when appropriate.\n *\n * Note that this function demands that the string strictly represents\n * a double: no spaces or other characters before or after the string\n * representing the number are accepted. */\nint string2ld(const char *s, size_t slen, long double *dp) {\n    char buf[MAX_LONG_DOUBLE_CHARS];\n    long double value;\n    char *eptr;\n\n    if (slen == 0 || slen >= sizeof(buf)) return 0;\n    memcpy(buf,s,slen);\n    buf[slen] = '\\0';\n\n    errno = 0;\n    value = strtold(buf, &eptr);\n    if (isspace(buf[0]) || eptr[0] != '\\0' ||\n        (size_t)(eptr-buf) != slen ||\n        (errno == ERANGE &&\n            (value == HUGE_VAL || value == -HUGE_VAL || fpclassify(value) == FP_ZERO)) ||\n        errno == EINVAL ||\n        isnan(value))\n        return 0;\n\n    if (dp) *dp = value;\n    return 1;\n}\n\n/* Convert a string into a double. Returns 1 if the string could be parsed\n * into a (non-overflowing) double, 0 otherwise. The value will be set to\n * the parsed value when appropriate.\n *\n * Note that this function demands that the string strictly represents\n * a double: no spaces or other characters before or after the string\n * representing the number are accepted. */\nint string2d(const char *s, size_t slen, double *dp) {\n    errno = 0;\n    char *eptr;\n    *dp = strtod(s, &eptr);\n    if (slen == 0 ||\n        isspace(((const char*)s)[0]) ||\n        (size_t)(eptr-(char*)s) != slen ||\n        (errno == ERANGE &&\n            (*dp == HUGE_VAL || *dp == -HUGE_VAL || fpclassify(*dp) == FP_ZERO)) ||\n        isnan(*dp))\n        return 0;\n    return 1;\n}\n\n/* Returns 1 if the double value can safely be represented in long long without\n * precision loss, in which case the corresponding long long is stored in the out variable. */\nint double2ll(double d, long long *out) {\n#if (DBL_MANT_DIG >= 52) && (DBL_MANT_DIG <= 63) && (LLONG_MAX == 0x7fffffffffffffffLL)\n    /* Check if the float is in a safe range to be casted into a\n     * long long. We are assuming that long long is 64 bit here.\n     * Also we are assuming that there are no implementations around where\n     * double has precision < 52 bit.\n     *\n     * Under this assumptions we test if a double is inside a range\n     * where casting to long long is safe. Then using two castings we\n     * make sure the decimal part is zero. If all this is true we can use\n     * integer without precision loss.\n     *\n     * Note that numbers above 2^52 and below 2^63 use all the fraction bits as real part,\n     * and the exponent bits are positive, which means the \"decimal\" part must be 0.\n     * i.e. all double values in that range are representable as a long without precision loss,\n     * but not all long values in that range can be represented as a double.\n     * we only care about the first part here. */\n    if (d < (double)(-LLONG_MAX/2) || d > (double)(LLONG_MAX/2))\n        return 0;\n    long long ll = d;\n    if (ll == d) {\n        *out = ll;\n        return 1;\n    }\n#endif\n    return 0;\n}\n\n/* Convert a double to a string representation. Returns the number of bytes\n * required. The representation should always be parsable by strtod(3).\n * This function does not support human-friendly formatting like ld2string\n * does. It is intended mainly to be used inside t_zset.c when writing scores\n * into a listpack representing a sorted set. */\nint d2string(char *buf, size_t len, double value) {\n    if (isnan(value)) {\n        /* Libc in some systems will format nan in a different way,\n         * like nan, -nan, NAN, nan(char-sequence).\n         * So we normalize it and create a single nan form in an explicit way. */\n        len = snprintf(buf,len,\"nan\");\n    } else if (isinf(value)) {\n        /* Libc in odd systems (Hi Solaris!) will format infinite in a\n         * different way, so better to handle it in an explicit way. */\n        if (value < 0)\n            len = snprintf(buf,len,\"-inf\");\n        else\n            len = snprintf(buf,len,\"inf\");\n    } else if (value == 0) {\n        /* See: http://en.wikipedia.org/wiki/Signed_zero, \"Comparisons\". */\n        if (1.0/value < 0)\n            len = snprintf(buf,len,\"-0\");\n        else\n            len = snprintf(buf,len,\"0\");\n    } else {\n        long long lvalue;\n        /* Integer printing function is much faster, check if we can safely use it. */\n        if (double2ll(value, &lvalue))\n            len = ll2string(buf,len,lvalue);\n        else {\n            len = fpconv_dtoa(value, buf);\n            buf[len] = '\\0';\n        }\n    }\n\n    return len;\n}\n\n/* Convert a double into a string with 'fractional_digits' digits after the dot precision.\n * This is an optimized version of snprintf \"%.<fractional_digits>f\".\n * We convert the double to long and multiply it  by 10 ^ <fractional_digits> to shift\n * the decimal places.\n * Note that multiply it of input value by 10 ^ <fractional_digits> can overflow but on the scenario\n * that we currently use within redis this that is not possible.\n * After we get the long representation we use the logic from ull2string function on this file\n * which is based on the following article:\n * https://www.facebook.com/notes/facebook-engineering/three-optimization-tips-for-c/10151361643253920\n *\n * Input values:\n * char: the buffer to store the string representation\n * dstlen: the buffer length\n * dvalue: the input double\n * fractional_digits: the number of fractional digits after the dot precision. between 1 and 17\n *\n * Return values:\n * Returns the number of characters needed to represent the number.\n * If the buffer is not big enough to store the string, 0 is returned.\n */\nint fixedpoint_d2string(char *dst, size_t dstlen, double dvalue, int fractional_digits) {\n    if (fractional_digits < 1 || fractional_digits > 17)\n        goto err;\n    /* min size of 2 ( due to 0. ) + n fractional_digitits + \\0 */\n    if ((int)dstlen < (fractional_digits+3))\n        goto err;\n    if (dvalue == 0) {\n        dst[0] = '0';\n        dst[1] = '.';\n        memset(dst + 2, '0', fractional_digits);\n        dst[fractional_digits+2] = '\\0';\n        return fractional_digits + 2;\n    }\n    /* scale and round */\n    static double powers_of_ten[] = {1.0, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0,\n    10000000.0, 100000000.0, 1000000000.0, 10000000000.0, 100000000000.0, 1000000000000.0,\n    10000000000000.0, 100000000000000.0, 1000000000000000.0, 10000000000000000.0,\n    100000000000000000.0 };\n    long long svalue = llrint(dvalue * powers_of_ten[fractional_digits]);\n    unsigned long long value;\n    /* write sign */\n    int negative = 0;\n    if (svalue < 0) {\n        if (svalue != LLONG_MIN) {\n            value = -svalue;\n        } else {\n            value = ((unsigned long long) LLONG_MAX)+1;\n        }\n        if (dstlen < 2)\n            goto err;\n        negative = 1;\n        dst[0] = '-';\n        dst++;\n        dstlen--;\n    } else {\n        value = svalue;\n    }\n\n    static const char digitsd[201] =\n        \"0001020304050607080910111213141516171819\"\n        \"2021222324252627282930313233343536373839\"\n        \"4041424344454647484950515253545556575859\"\n        \"6061626364656667686970717273747576777879\"\n        \"8081828384858687888990919293949596979899\";\n\n    /* Check length. */\n    uint32_t ndigits = digits10(value);\n    if (ndigits >= dstlen) goto err;\n    int integer_digits = ndigits - fractional_digits;\n    /* Fractional only check to avoid representing 0.7750 as .7750.\n     * This means we need to increment the length and store 0 as the first character.\n     */\n    if (integer_digits < 1) {\n        dst[0] = '0';\n        integer_digits = 1;\n    }\n    dst[integer_digits] = '.';\n    int size = integer_digits + 1 + fractional_digits;\n    /* fill with 0 from fractional digits until size */\n    memset(dst + integer_digits + 1, '0', fractional_digits);\n    int next = size - 1;\n    while (value >= 100) {\n        int const i = (value % 100) * 2;\n        value /= 100;\n        dst[next] = digitsd[i + 1];\n        dst[next - 1] = digitsd[i];\n        next -= 2;\n        /* dot position */\n        if (next == integer_digits) {\n            next--;\n        }\n    }\n\n    /* Handle last 1-2 digits. */\n    if (value < 10) {\n        dst[next] = '0' + (uint32_t) value;\n    } else {\n        int i = (uint32_t) value * 2;\n        dst[next] = digitsd[i + 1];\n        dst[next - 1] = digitsd[i];\n    }\n    /* Null term. */\n    dst[size] = '\\0';\n    return size + negative;\nerr:\n    /* force add Null termination */\n    if (dstlen > 0)\n        dst[0] = '\\0';\n    return 0;\n}\n\n/* Trims off trailing zeros from a string representing a double. */\nint trimDoubleString(char *buf, size_t len) {\n    if (strchr(buf,'.') != NULL) {\n        char *p = buf+len-1;\n        while(*p == '0') {\n            p--;\n            len--;\n        }\n        if (*p == '.') len--;\n    }\n    buf[len] = '\\0';\n    return len;\n}\n\n/* Create a string object from a long double.\n * If mode is humanfriendly it does not use exponential format and trims trailing\n * zeroes at the end (may result in loss of precision).\n * If mode is default exp format is used and the output of snprintf()\n * is not modified (may result in loss of precision).\n * If mode is hex hexadecimal format is used (no loss of precision)\n *\n * The function returns the length of the string or zero if there was not\n * enough buffer room to store it. */\nint ld2string(char *buf, size_t len, long double value, ld2string_mode mode) {\n    size_t l = 0;\n\n    if (isinf(value)) {\n        /* Libc in odd systems (Hi Solaris!) will format infinite in a\n         * different way, so better to handle it in an explicit way. */\n        if (len < 5) goto err; /* No room. 5 is \"-inf\\0\" */\n        if (value > 0) {\n            memcpy(buf,\"inf\",3);\n            l = 3;\n        } else {\n            memcpy(buf,\"-inf\",4);\n            l = 4;\n        }\n    } else if (isnan(value)) {\n        /* Libc in some systems will format nan in a different way,\n         * like nan, -nan, NAN, nan(char-sequence).\n         * So we normalize it and create a single nan form in an explicit way. */\n        if (len < 4) goto err; /* No room. 4 is \"nan\\0\" */\n        memcpy(buf, \"nan\", 3);\n        l = 3;\n    } else {\n        switch (mode) {\n        case LD_STR_AUTO:\n            l = snprintf(buf,len,\"%.17Lg\",value);\n            if (l+1 > len) goto err;; /* No room. */\n            break;\n        case LD_STR_HEX:\n            l = snprintf(buf,len,\"%La\",value);\n            if (l+1 > len) goto err; /* No room. */\n            break;\n        case LD_STR_HUMAN:\n            /* We use 17 digits precision since with 128 bit floats that precision\n             * after rounding is able to represent most small decimal numbers in a\n             * way that is \"non surprising\" for the user (that is, most small\n             * decimal numbers will be represented in a way that when converted\n             * back into a string are exactly the same as what the user typed.) */\n            l = snprintf(buf,len,\"%.17Lf\",value);\n            if (l+1 > len) goto err; /* No room. */\n            /* Now remove trailing zeroes after the '.' */\n            if (strchr(buf,'.') != NULL) {\n                char *p = buf+l-1;\n                while(*p == '0') {\n                    p--;\n                    l--;\n                }\n                if (*p == '.') l--;\n            }\n            if (l == 2 && buf[0] == '-' && buf[1] == '0') {\n                buf[0] = '0';\n                l = 1;\n            }\n            break;\n        default: goto err; /* Invalid mode. */\n        }\n    }\n    buf[l] = '\\0';\n    return l;\nerr:\n    /* force add Null termination */\n    if (len > 0)\n        buf[0] = '\\0';\n    return 0;\n}\n\n/* Get random bytes, attempts to get an initial seed from /dev/urandom and\n * the uses a one way hash function in counter mode to generate a random\n * stream. However if /dev/urandom is not available, a weaker seed is used.\n *\n * This function is not thread safe, since the state is global. */\nvoid getRandomBytes(unsigned char *p, size_t len) {\n    /* Global state. */\n    static int seed_initialized = 0;\n    static unsigned char seed[64]; /* 512 bit internal block size. */\n    static uint64_t counter = 0; /* The counter we hash with the seed. */\n\n    if (!seed_initialized) {\n        /* Initialize a seed and use SHA1 in counter mode, where we hash\n         * the same seed with a progressive counter. For the goals of this\n         * function we just need non-colliding strings, there are no\n         * cryptographic security needs. */\n        FILE *fp = fopen(\"/dev/urandom\",\"r\");\n        if (fp == NULL || fread(seed,sizeof(seed),1,fp) != 1) {\n            /* Revert to a weaker seed, and in this case reseed again\n             * at every call.*/\n            for (unsigned int j = 0; j < sizeof(seed); j++) {\n                struct timeval tv;\n                gettimeofday(&tv,NULL);\n                pid_t pid = getpid();\n                seed[j] = tv.tv_sec ^ tv.tv_usec ^ pid ^ (long)fp;\n            }\n        } else {\n            seed_initialized = 1;\n        }\n        if (fp) fclose(fp);\n    }\n\n    while(len) {\n        /* This implements SHA256-HMAC. */\n        unsigned char digest[SHA256_BLOCK_SIZE];\n        unsigned char kxor[64];\n        unsigned int copylen =\n            len > SHA256_BLOCK_SIZE ? SHA256_BLOCK_SIZE : len;\n\n        /* IKEY: key xored with 0x36. */\n        memcpy(kxor,seed,sizeof(kxor));\n        for (unsigned int i = 0; i < sizeof(kxor); i++) kxor[i] ^= 0x36;\n\n        /* Obtain HASH(IKEY||MESSAGE). */\n        SHA256_CTX ctx;\n        sha256_init(&ctx);\n        sha256_update(&ctx,kxor,sizeof(kxor));\n        sha256_update(&ctx,(unsigned char*)&counter,sizeof(counter));\n        sha256_final(&ctx,digest);\n\n        /* OKEY: key xored with 0x5c. */\n        memcpy(kxor,seed,sizeof(kxor));\n        for (unsigned int i = 0; i < sizeof(kxor); i++) kxor[i] ^= 0x5C;\n\n        /* Obtain HASH(OKEY || HASH(IKEY||MESSAGE)). */\n        sha256_init(&ctx);\n        sha256_update(&ctx,kxor,sizeof(kxor));\n        sha256_update(&ctx,digest,SHA256_BLOCK_SIZE);\n        sha256_final(&ctx,digest);\n\n        /* Increment the counter for the next iteration. */\n        counter++;\n\n        memcpy(p,digest,copylen);\n        len -= copylen;\n        p += copylen;\n    }\n}\n\n/* Generate the Redis \"Run ID\", a SHA1-sized random number that identifies a\n * given execution of Redis, so that if you are talking with an instance\n * having run_id == A, and you reconnect and it has run_id == B, you can be\n * sure that it is either a different instance or it was restarted. */\nvoid getRandomHexChars(char *p, size_t len) {\n    char *charset = \"0123456789abcdef\";\n    size_t j;\n\n    getRandomBytes((unsigned char*)p,len);\n    for (j = 0; j < len; j++) p[j] = charset[p[j] & 0x0F];\n}\n\n/* Given the filename, return the absolute path as an SDS string, or NULL\n * if it fails for some reason. Note that \"filename\" may be an absolute path\n * already, this will be detected and handled correctly.\n *\n * The function does not try to normalize everything, but only the obvious\n * case of one or more \"../\" appearing at the start of \"filename\"\n * relative path. */\nsds getAbsolutePath(char *filename) {\n    char cwd[1024];\n    sds abspath;\n    sds relpath = sdsnew(filename);\n\n    relpath = sdstrim(relpath,\" \\r\\n\\t\");\n    if (relpath[0] == '/') return relpath; /* Path is already absolute. */\n\n    /* If path is relative, join cwd and relative path. */\n    if (getcwd(cwd,sizeof(cwd)) == NULL) {\n        sdsfree(relpath);\n        return NULL;\n    }\n    abspath = sdsnew(cwd);\n    if (sdslen(abspath) && abspath[sdslen(abspath)-1] != '/')\n        abspath = sdscat(abspath,\"/\");\n\n    /* At this point we have the current path always ending with \"/\", and\n     * the trimmed relative path. Try to normalize the obvious case of\n     * trailing ../ elements at the start of the path.\n     *\n     * For every \"../\" we find in the filename, we remove it and also remove\n     * the last element of the cwd, unless the current cwd is \"/\". */\n    while (sdslen(relpath) >= 3 &&\n           relpath[0] == '.' && relpath[1] == '.' && relpath[2] == '/')\n    {\n        sdsrange(relpath,3,-1);\n        if (sdslen(abspath) > 1) {\n            char *p = abspath + sdslen(abspath)-2;\n            int trimlen = 1;\n\n            while(*p != '/') {\n                p--;\n                trimlen++;\n            }\n            sdsrange(abspath,0,-(trimlen+1));\n        }\n    }\n\n    /* Finally glue the two parts together. */\n    abspath = sdscatsds(abspath,relpath);\n    sdsfree(relpath);\n    return abspath;\n}\n\n/*\n * Gets the proper timezone in a more portable fashion\n * i.e timezone variables are linux specific.\n */\nlong getTimeZone(void) {\n#if defined(__linux__) || defined(__sun)\n    return timezone;\n#else\n    struct timeval tv;\n    struct timezone tz;\n\n    gettimeofday(&tv, &tz);\n\n    return tz.tz_minuteswest * 60L;\n#endif\n}\n\n/* Return true if the specified path is just a file basename without any\n * relative or absolute path. This function just checks that no / or \\\n * character exists inside the specified path, that's enough in the\n * environments where Redis runs. */\nint pathIsBaseName(char *path) {\n    return strchr(path,'/') == NULL && strchr(path,'\\\\') == NULL;\n}\n\nint fileExist(char *filename) {\n    struct stat statbuf;\n    return stat(filename, &statbuf) == 0 && S_ISREG(statbuf.st_mode);\n}\n\nint dirExists(char *dname) {\n    struct stat statbuf;\n    return stat(dname, &statbuf) == 0 && S_ISDIR(statbuf.st_mode);\n}\n\nint dirCreateIfMissing(char *dname) {\n    if (mkdir(dname, 0755) != 0) {\n        if (errno != EEXIST) {\n            return -1;\n        } else if (!dirExists(dname)) {\n            errno = ENOTDIR;\n            return -1;\n        }\n    }\n    return 0;\n}\n\nint dirRemove(char *dname) {\n    DIR *dir;\n    struct stat stat_entry;\n    struct dirent *entry;\n    char full_path[PATH_MAX + 1];\n\n    if ((dir = opendir(dname)) == NULL) {\n        return -1;\n    }\n\n    while ((entry = readdir(dir)) != NULL) {\n        if (!strcmp(entry->d_name, \".\") || !strcmp(entry->d_name, \"..\")) continue;\n\n        snprintf(full_path, sizeof(full_path), \"%s/%s\", dname, entry->d_name);\n\n        int fd = open(full_path, O_RDONLY|O_NONBLOCK);\n        if (fd == -1) {\n            closedir(dir);\n            return -1;\n        }\n\n        if (fstat(fd, &stat_entry) == -1) {\n            close(fd);\n            closedir(dir);\n            return -1;\n        }\n        close(fd);\n\n        if (S_ISDIR(stat_entry.st_mode) != 0) {\n            if (dirRemove(full_path) == -1) {\n                return -1;\n            }\n            continue;\n        }\n\n        if (unlink(full_path) != 0) {\n            closedir(dir);\n            return -1;\n        }\n    }\n\n    if (rmdir(dname) != 0) {\n        closedir(dir);\n        return -1;\n    }\n\n    closedir(dir);\n    return 0;\n}\n\nsds makePath(char *path, char *filename) {\n    return sdscatfmt(sdsempty(), \"%s/%s\", path, filename);\n}\n\n/* Given the filename, sync the corresponding directory.\n *\n * Usually a portable and safe pattern to overwrite existing files would be like:\n * 1. create a new temp file (on the same file system!)\n * 2. write data to the temp file\n * 3. fsync() the temp file\n * 4. rename the temp file to the appropriate name\n * 5. fsync() the containing directory */\nint fsyncFileDir(const char *filename) {\n#ifdef _AIX\n    /* AIX is unable to fsync a directory */\n    return 0;\n#endif\n    char temp_filename[PATH_MAX + 1];\n    char *dname;\n    int dir_fd;\n\n    if (strlen(filename) > PATH_MAX) {\n        errno = ENAMETOOLONG;\n        return -1;\n    }\n\n    /* In the glibc implementation dirname may modify their argument. */\n    memcpy(temp_filename, filename, strlen(filename) + 1);\n    dname = dirname(temp_filename);\n\n    dir_fd = open(dname, O_RDONLY);\n    if (dir_fd == -1) {\n        /* Some OSs don't allow us to open directories at all, just\n         * ignore the error in that case */\n        if (errno == EISDIR) {\n            return 0;\n        }\n        return -1;\n    }\n    /* Some OSs don't allow us to fsync directories at all, so we can ignore\n     * those errors. */\n    if (redis_fsync(dir_fd) == -1 && !(errno == EBADF || errno == EINVAL)) {\n        int save_errno = errno;\n        close(dir_fd);\n        errno = save_errno;\n        return -1;\n    }\n    \n    close(dir_fd);\n    return 0;\n}\n\n /* free OS pages backed by file */\nint reclaimFilePageCache(int fd, size_t offset, size_t length) {\n#ifdef HAVE_FADVISE\n    int ret = posix_fadvise(fd, offset, length, POSIX_FADV_DONTNEED);\n    if (ret) return -1;\n    return 0;\n#else\n    UNUSED(fd);\n    UNUSED(offset);\n    UNUSED(length);\n    return 0;\n#endif\n}\n\n#ifdef REDIS_TEST\n#include <assert.h>\n#include <sys/mman.h>\n#include \"testhelp.h\"\n\nstatic void test_string2ll(void) {\n    char buf[32];\n    long long v;\n\n    /* May not start with +. */\n    redis_strlcpy(buf,\"+1\",sizeof(buf));\n    assert(string2ll(buf,strlen(buf),&v) == 0);\n\n    /* Leading space. */\n    redis_strlcpy(buf,\" 1\",sizeof(buf));\n    assert(string2ll(buf,strlen(buf),&v) == 0);\n\n    /* Trailing space. */\n    redis_strlcpy(buf,\"1 \",sizeof(buf));\n    assert(string2ll(buf,strlen(buf),&v) == 0);\n\n    /* May not start with 0. */\n    redis_strlcpy(buf,\"01\",sizeof(buf));\n    assert(string2ll(buf,strlen(buf),&v) == 0);\n\n    redis_strlcpy(buf,\"-1\",sizeof(buf));\n    assert(string2ll(buf,strlen(buf),&v) == 1);\n    assert(v == -1);\n\n    redis_strlcpy(buf,\"0\",sizeof(buf));\n    assert(string2ll(buf,strlen(buf),&v) == 1);\n    assert(v == 0);\n\n    redis_strlcpy(buf,\"1\",sizeof(buf));\n    assert(string2ll(buf,strlen(buf),&v) == 1);\n    assert(v == 1);\n\n    redis_strlcpy(buf,\"99\",sizeof(buf));\n    assert(string2ll(buf,strlen(buf),&v) == 1);\n    assert(v == 99);\n\n    redis_strlcpy(buf,\"-99\",sizeof(buf));\n    assert(string2ll(buf,strlen(buf),&v) == 1);\n    assert(v == -99);\n\n    redis_strlcpy(buf,\"-9223372036854775808\",sizeof(buf));\n    assert(string2ll(buf,strlen(buf),&v) == 1);\n    assert(v == LLONG_MIN);\n\n    redis_strlcpy(buf,\"-9223372036854775809\",sizeof(buf)); /* overflow */\n    assert(string2ll(buf,strlen(buf),&v) == 0);\n\n    redis_strlcpy(buf,\"9223372036854775807\",sizeof(buf));\n    assert(string2ll(buf,strlen(buf),&v) == 1);\n    assert(v == LLONG_MAX);\n\n    redis_strlcpy(buf,\"9223372036854775808\",sizeof(buf)); /* overflow */\n    assert(string2ll(buf,strlen(buf),&v) == 0);\n}\n\nstatic void test_string2l(void) {\n    char buf[32];\n    long v;\n\n    /* May not start with +. */\n    redis_strlcpy(buf,\"+1\",sizeof(buf));\n    assert(string2l(buf,strlen(buf),&v) == 0);\n\n    /* May not start with 0. */\n    redis_strlcpy(buf,\"01\",sizeof(buf));\n    assert(string2l(buf,strlen(buf),&v) == 0);\n\n    redis_strlcpy(buf,\"-1\",sizeof(buf));\n    assert(string2l(buf,strlen(buf),&v) == 1);\n    assert(v == -1);\n\n    redis_strlcpy(buf,\"0\",sizeof(buf));\n    assert(string2l(buf,strlen(buf),&v) == 1);\n    assert(v == 0);\n\n    redis_strlcpy(buf,\"1\",sizeof(buf));\n    assert(string2l(buf,strlen(buf),&v) == 1);\n    assert(v == 1);\n\n    redis_strlcpy(buf,\"99\",sizeof(buf));\n    assert(string2l(buf,strlen(buf),&v) == 1);\n    assert(v == 99);\n\n    redis_strlcpy(buf,\"-99\",sizeof(buf));\n    assert(string2l(buf,strlen(buf),&v) == 1);\n    assert(v == -99);\n\n#if LONG_MAX != LLONG_MAX\n    redis_strlcpy(buf,\"-2147483648\",sizeof(buf));\n    assert(string2l(buf,strlen(buf),&v) == 1);\n    assert(v == LONG_MIN);\n\n    redis_strlcpy(buf,\"-2147483649\",sizeof(buf)); /* overflow */\n    assert(string2l(buf,strlen(buf),&v) == 0);\n\n    redis_strlcpy(buf,\"2147483647\",sizeof(buf));\n    assert(string2l(buf,strlen(buf),&v) == 1);\n    assert(v == LONG_MAX);\n\n    redis_strlcpy(buf,\"2147483648\",sizeof(buf)); /* overflow */\n    assert(string2l(buf,strlen(buf),&v) == 0);\n#endif\n}\n\nstatic void test_ll2string(void) {\n    char buf[32];\n    long long v;\n    int sz;\n\n    v = 0;\n    sz = ll2string(buf, sizeof buf, v);\n    assert(sz == 1);\n    assert(!strcmp(buf, \"0\"));\n\n    v = -1;\n    sz = ll2string(buf, sizeof buf, v);\n    assert(sz == 2);\n    assert(!strcmp(buf, \"-1\"));\n\n    v = 99;\n    sz = ll2string(buf, sizeof buf, v);\n    assert(sz == 2);\n    assert(!strcmp(buf, \"99\"));\n\n    v = -99;\n    sz = ll2string(buf, sizeof buf, v);\n    assert(sz == 3);\n    assert(!strcmp(buf, \"-99\"));\n\n    v = -2147483648;\n    sz = ll2string(buf, sizeof buf, v);\n    assert(sz == 11);\n    assert(!strcmp(buf, \"-2147483648\"));\n\n    v = LLONG_MIN;\n    sz = ll2string(buf, sizeof buf, v);\n    assert(sz == 20);\n    assert(!strcmp(buf, \"-9223372036854775808\"));\n\n    v = LLONG_MAX;\n    sz = ll2string(buf, sizeof buf, v);\n    assert(sz == 19);\n    assert(!strcmp(buf, \"9223372036854775807\"));\n}\n\nstatic void test_ld2string(void) {\n    char buf[32];\n    long double v;\n    int sz;\n\n    v = 0.0 / 0.0;\n    sz = ld2string(buf, sizeof(buf), v, LD_STR_AUTO);\n    assert(sz == 3);\n    assert(!strcmp(buf, \"nan\"));\n}\n\nstatic void test_fixedpoint_d2string(void) {\n    char buf[32];\n    double v;\n    int sz;\n    v = 0.0;\n    sz = fixedpoint_d2string(buf, sizeof buf, v, 4);\n    assert(sz == 6);\n    assert(!strcmp(buf, \"0.0000\"));\n    sz = fixedpoint_d2string(buf, sizeof buf, v, 1);\n    assert(sz == 3);\n    assert(!strcmp(buf, \"0.0\"));\n    /* set junk in buffer */\n    memset(buf,'A',32);\n    v = 0.0001;\n    sz = fixedpoint_d2string(buf, sizeof buf, v, 4);\n    assert(sz == 6);\n    assert(buf[sz] == '\\0');\n    assert(!strcmp(buf, \"0.0001\"));\n    /* set junk in buffer */\n    memset(buf,'A',32);\n    v = 6.0642951598391699e-05;\n    sz = fixedpoint_d2string(buf, sizeof buf, v, 4);\n    assert(sz == 6);\n    assert(buf[sz] == '\\0');\n    assert(!strcmp(buf, \"0.0001\"));\n    v = 0.01;\n    sz = fixedpoint_d2string(buf, sizeof buf, v, 4);\n    assert(sz == 6);\n    assert(!strcmp(buf, \"0.0100\"));\n    sz = fixedpoint_d2string(buf, sizeof buf, v, 1);\n    assert(sz == 3);\n    assert(!strcmp(buf, \"0.0\"));\n    v = -0.01;\n    sz = fixedpoint_d2string(buf, sizeof buf, v, 4);\n    assert(sz == 7);\n    assert(!strcmp(buf, \"-0.0100\"));\n     v = -0.1;\n    sz = fixedpoint_d2string(buf, sizeof buf, v, 1);\n    assert(sz == 4);\n    assert(!strcmp(buf, \"-0.1\"));\n    v = 0.1;\n    sz = fixedpoint_d2string(buf, sizeof buf, v, 1);\n    assert(sz == 3);\n    assert(!strcmp(buf, \"0.1\"));\n    v = 0.01;\n    sz = fixedpoint_d2string(buf, sizeof buf, v, 17);\n    assert(sz == 19);\n    assert(!strcmp(buf, \"0.01000000000000000\"));\n    v = 10.01;\n    sz = fixedpoint_d2string(buf, sizeof buf, v, 4);\n    assert(sz == 7);\n    assert(!strcmp(buf, \"10.0100\"));\n    /* negative tests */\n    sz = fixedpoint_d2string(buf, sizeof buf, v, 18);\n    assert(sz == 0);\n    sz = fixedpoint_d2string(buf, sizeof buf, v, 0);\n    assert(sz == 0);\n    sz = fixedpoint_d2string(buf, 1, v, 1);\n    assert(sz == 0);\n}\n\n#if defined(__linux__)\n/* Since fadvise and mincore is only supported in specific platforms like\n * Linux, we only verify the fadvise mechanism works in Linux */\nstatic int cache_exist(int fd) {\n    unsigned char flag;\n    void *m = mmap(NULL, 4096, PROT_READ, MAP_SHARED, fd, 0);\n    assert(m);\n    assert(mincore(m, 4096, &flag) == 0);\n    munmap(m, 4096);\n    /* the least significant bit of the byte will be set if the corresponding\n     * page is currently resident in memory */\n    return flag&1;\n}\n\nstatic void test_reclaimFilePageCache(void) {\n    char *tmpfile = \"/tmp/redis-reclaim-cache-test\";\n    int fd = open(tmpfile, O_RDWR|O_CREAT, 0644);\n    assert(fd >= 0);\n\n    /* test write file */\n    char buf[4] = \"foo\";\n    assert(write(fd, buf, sizeof(buf)) > 0);\n    assert(cache_exist(fd));\n    assert(redis_fsync(fd) == 0);\n    assert(reclaimFilePageCache(fd, 0, 0) == 0);\n    assert(!cache_exist(fd));\n\n    /* test read file */\n    assert(pread(fd, buf, sizeof(buf), 0) > 0);\n    assert(cache_exist(fd));\n    assert(reclaimFilePageCache(fd, 0, 0) == 0);\n    assert(!cache_exist(fd));\n\n    unlink(tmpfile);\n    printf(\"reclaimFilePageCach test is ok\\n\");\n}\n#endif\n\nint utilTest(int argc, char **argv, int flags) {\n    UNUSED(argc);\n    UNUSED(argv);\n    UNUSED(flags);\n\n    test_string2ll();\n    test_string2l();\n    test_ll2string();\n    test_ld2string();\n    test_fixedpoint_d2string();\n#if defined(__linux__)\n    if (!(flags & REDIS_TEST_VALGRIND)) {\n        test_reclaimFilePageCache();\n    }\n#endif\n    printf(\"Done testing util\\n\");\n    return 0;\n}\n#endif\n\n\n", "start_server {tags {\"keyspace\"}} {\n    test {DEL against a single item} {\n        r set x foo\n        assert {[r get x] eq \"foo\"}\n        r del x\n        r get x\n    } {}\n\n    test {Vararg DEL} {\n        r set foo1{t} a\n        r set foo2{t} b\n        r set foo3{t} c\n        list [r del foo1{t} foo2{t} foo3{t} foo4{t}] [r mget foo1{t} foo2{t} foo3{t}]\n    } {3 {{} {} {}}}\n\n    test {Untagged multi-key commands} {\n        r mset foo1 a foo2 b foo3 c\n        assert_equal {a b c {}} [r mget foo1 foo2 foo3 foo4]\n        r del foo1 foo2 foo3 foo4\n    } {3} {cluster:skip}\n\n    test {KEYS with pattern} {\n        foreach key {key_x key_y key_z foo_a foo_b foo_c} {\n            r set $key hello\n        }\n        lsort [r keys foo*]\n    } {foo_a foo_b foo_c}\n\n    test {KEYS to get all keys} {\n        lsort [r keys *]\n    } {foo_a foo_b foo_c key_x key_y key_z}\n\n    test {DBSIZE} {\n        r dbsize\n    } {6}\n\n    test {DEL all keys} {\n        foreach key [r keys *] {r del $key}\n        r dbsize\n    } {0}\n\n    test \"DEL against expired key\" {\n        r debug set-active-expire 0\n        r setex keyExpire 1 valExpire\n        after 1100\n        assert_equal 0 [r del keyExpire]\n        r debug set-active-expire 1\n    } {OK} {needs:debug}\n\n    test {EXISTS} {\n        set res {}\n        r set newkey test\n        append res [r exists newkey]\n        r del newkey\n        append res [r exists newkey]\n    } {10}\n\n    test {Zero length value in key. SET/GET/EXISTS} {\n        r set emptykey {}\n        set res [r get emptykey]\n        append res [r exists emptykey]\n        r del emptykey\n        append res [r exists emptykey]\n    } {10}\n\n    test {Commands pipelining} {\n        set fd [r channel]\n        puts -nonewline $fd \"SET k1 xyzk\\r\\nGET k1\\r\\nPING\\r\\n\"\n        flush $fd\n        set res {}\n        append res [string match OK* [r read]]\n        append res [r read]\n        append res [string match PONG* [r read]]\n        format $res\n    } {1xyzk1}\n\n    test {Non existing command} {\n        catch {r foobaredcommand} err\n        string match ERR* $err\n    } {1}\n\n    test {RENAME basic usage} {\n        r set mykey{t} hello\n        r rename mykey{t} mykey1{t}\n        r rename mykey1{t} mykey2{t}\n        r get mykey2{t}\n    } {hello}\n\n    test {RENAME source key should no longer exist} {\n        r exists mykey\n    } {0}\n\n    test {RENAME against already existing key} {\n        r set mykey{t} a\n        r set mykey2{t} b\n        r rename mykey2{t} mykey{t}\n        set res [r get mykey{t}]\n        append res [r exists mykey2{t}]\n    } {b0}\n\n    test {RENAMENX basic usage} {\n        r del mykey{t}\n        r del mykey2{t}\n        r set mykey{t} foobar\n        r renamenx mykey{t} mykey2{t}\n        set res [r get mykey2{t}]\n        append res [r exists mykey{t}]\n    } {foobar0}\n\n    test {RENAMENX against already existing key} {\n        r set mykey{t} foo\n        r set mykey2{t} bar\n        r renamenx mykey{t} mykey2{t}\n    } {0}\n\n    test {RENAMENX against already existing key (2)} {\n        set res [r get mykey{t}]\n        append res [r get mykey2{t}]\n    } {foobar}\n\n    test {RENAME against non existing source key} {\n        catch {r rename nokey{t} foobar{t}} err\n        format $err\n    } {ERR*}\n\n    test {RENAME where source and dest key are the same (existing)} {\n        r set mykey foo\n        r rename mykey mykey\n    } {OK}\n\n    test {RENAMENX where source and dest key are the same (existing)} {\n        r set mykey foo\n        r renamenx mykey mykey\n    } {0}\n\n    test {RENAME where source and dest key are the same (non existing)} {\n        r del mykey\n        catch {r rename mykey mykey} err\n        format $err\n    } {ERR*}\n\n    test {RENAME with volatile key, should move the TTL as well} {\n        r del mykey{t} mykey2{t}\n        r set mykey{t} foo\n        r expire mykey{t} 100\n        assert {[r ttl mykey{t}] > 95 && [r ttl mykey{t}] <= 100}\n        r rename mykey{t} mykey2{t}\n        assert {[r ttl mykey2{t}] > 95 && [r ttl mykey2{t}] <= 100}\n    }\n\n    test {RENAME with volatile key, should not inherit TTL of target key} {\n        r del mykey{t} mykey2{t}\n        r set mykey{t} foo\n        r set mykey2{t} bar\n        r expire mykey2{t} 100\n        assert {[r ttl mykey{t}] == -1 && [r ttl mykey2{t}] > 0}\n        r rename mykey{t} mykey2{t}\n        r ttl mykey2{t}\n    } {-1}\n\n    test {DEL all keys again (DB 0)} {\n        foreach key [r keys *] {\n            r del $key\n        }\n        r dbsize\n    } {0}\n\n    test {DEL all keys again (DB 1)} {\n        r select 10\n        foreach key [r keys *] {\n            r del $key\n        }\n        set res [r dbsize]\n        r select 9\n        format $res\n    } {0} {singledb:skip}\n\n    test {COPY basic usage for string} {\n        r set mykey{t} foobar\n        set res {}\n        r copy mykey{t} mynewkey{t}\n        lappend res [r get mynewkey{t}]\n        lappend res [r dbsize]\n        if {$::singledb} {\n            assert_equal [list foobar 2] [format $res]\n        } else {\n            r copy mykey{t} mynewkey{t} DB 10\n            r select 10\n            lappend res [r get mynewkey{t}]\n            lappend res [r dbsize]\n            r select 9\n            assert_equal [list foobar 2 foobar 1] [format $res]\n        }\n    } \n\n    test {COPY for string does not replace an existing key without REPLACE option} {\n        r set mykey2{t} hello\n        catch {r copy mykey2{t} mynewkey{t} DB 10} e\n        set e\n    } {0} {singledb:skip}\n\n    test {COPY for string can replace an existing key with REPLACE option} {\n        r copy mykey2{t} mynewkey{t} DB 10 REPLACE\n        r select 10\n        r get mynewkey{t}\n    } {hello} {singledb:skip}\n\n    test {COPY for string ensures that copied data is independent of copying data} {\n        r flushdb\n        r select 9\n        r set mykey{t} foobar\n        set res {}\n        r copy mykey{t} mynewkey{t} DB 10\n        r select 10\n        lappend res [r get mynewkey{t}]\n        r set mynewkey{t} hoge\n        lappend res [r get mynewkey{t}]\n        r select 9\n        lappend res [r get mykey{t}]\n        r select 10\n        r flushdb\n        r select 9\n        format $res\n    } [list foobar hoge foobar] {singledb:skip}\n\n    test {COPY for string does not copy data to no-integer DB} {\n        r set mykey{t} foobar\n        catch {r copy mykey{t} mynewkey{t} DB notanumber} e\n        set e\n    } {ERR value is not an integer or out of range}\n\n    test {COPY can copy key expire metadata as well} {\n        r set mykey{t} foobar ex 100\n        r copy mykey{t} mynewkey{t} REPLACE\n        assert {[r ttl mynewkey{t}] > 0 && [r ttl mynewkey{t}] <= 100}\n        assert {[r get mynewkey{t}] eq \"foobar\"}\n    }\n\n    test {COPY does not create an expire if it does not exist} {\n        r set mykey{t} foobar\n        assert {[r ttl mykey{t}] == -1}\n        r copy mykey{t} mynewkey{t} REPLACE\n        assert {[r ttl mynewkey{t}] == -1}\n        assert {[r get mynewkey{t}] eq \"foobar\"}\n    }\n\nsource \"tests/unit/type/list-common.tcl\"\nforeach {type large} [array get largevalue] {\n    set origin_config [config_get_set list-max-listpack-size -1]\n    test \"COPY basic usage for list - $type\" {\n        r del mylist{t} mynewlist{t}\n        r lpush mylist{t} a b $large c d\n        assert_encoding $type mylist{t}\n        r copy mylist{t} mynewlist{t}\n        assert_encoding $type mynewlist{t}\n        set digest [debug_digest_value mylist{t}]\n        assert_equal $digest [debug_digest_value mynewlist{t}]\n        assert_refcount 1 mylist{t}\n        assert_refcount 1 mynewlist{t}\n        r del mylist{t}\n        assert_equal $digest [debug_digest_value mynewlist{t}]\n    }\n    config_set list-max-listpack-size $origin_config\n}\n\n    foreach type {intset listpack hashtable} {\n        test {COPY basic usage for $type set} {\n            r del set1{t} newset1{t}\n            r sadd set1{t} 1 2 3\n            if {$type ne \"intset\"} {\n                r sadd set1{t} a\n            }\n            if {$type eq \"hashtable\"} {\n                for {set i 4} {$i < 200} {incr i} {\n                    r sadd set1{t} $i\n                }\n            }\n            assert_encoding $type set1{t}\n            r copy set1{t} newset1{t}\n            set digest [debug_digest_value set1{t}]\n            assert_equal $digest [debug_digest_value newset1{t}]\n            assert_refcount 1 set1{t}\n            assert_refcount 1 newset1{t}\n            r del set1{t}\n            assert_equal $digest [debug_digest_value newset1{t}]\n        }\n    }\n\n    test {COPY basic usage for listpack sorted set} {\n        r del zset1{t} newzset1{t}\n        r zadd zset1{t} 123 foobar\n        assert_encoding listpack zset1{t}\n        r copy zset1{t} newzset1{t}\n        set digest [debug_digest_value zset1{t}]\n        assert_equal $digest [debug_digest_value newzset1{t}]\n        assert_refcount 1 zset1{t}\n        assert_refcount 1 newzset1{t}\n        r del zset1{t}\n        assert_equal $digest [debug_digest_value newzset1{t}]\n    }\n\n     test {COPY basic usage for skiplist sorted set} {\n        r del zset2{t} newzset2{t}\n        set original_max [lindex [r config get zset-max-ziplist-entries] 1]\n        r config set zset-max-ziplist-entries 0\n        for {set j 0} {$j < 130} {incr j} {\n            r zadd zset2{t} [randomInt 50] ele-[randomInt 10]\n        }\n        assert_encoding skiplist zset2{t}\n        r copy zset2{t} newzset2{t}\n        set digest [debug_digest_value zset2{t}]\n        assert_equal $digest [debug_digest_value newzset2{t}]\n        assert_refcount 1 zset2{t}\n        assert_refcount 1 newzset2{t}\n        r del zset2{t}\n        assert_equal $digest [debug_digest_value newzset2{t}]\n        r config set zset-max-ziplist-entries $original_max\n    }\n\n    test {COPY basic usage for listpack hash} {\n        r del hash1{t} newhash1{t}\n        r hset hash1{t} tmp 17179869184\n        assert_encoding listpack hash1{t}\n        r copy hash1{t} newhash1{t}\n        set digest [debug_digest_value hash1{t}]\n        assert_equal $digest [debug_digest_value newhash1{t}]\n        assert_refcount 1 hash1{t}\n        assert_refcount 1 newhash1{t}\n        r del hash1{t}\n        assert_equal $digest [debug_digest_value newhash1{t}]\n    }\n\n    test {COPY basic usage for hashtable hash} {\n        r del hash2{t} newhash2{t}\n        set original_max [lindex [r config get hash-max-ziplist-entries] 1]\n        r config set hash-max-ziplist-entries 0\n        for {set i 0} {$i < 64} {incr i} {\n            r hset hash2{t} [randomValue] [randomValue]\n        }\n        assert_encoding hashtable hash2{t}\n        r copy hash2{t} newhash2{t}\n        set digest [debug_digest_value hash2{t}]\n        assert_equal $digest [debug_digest_value newhash2{t}]\n        assert_refcount 1 hash2{t}\n        assert_refcount 1 newhash2{t}\n        r del hash2{t}\n        assert_equal $digest [debug_digest_value newhash2{t}]\n        r config set hash-max-ziplist-entries $original_max\n    }\n\n    test {COPY basic usage for stream} {\n        r del mystream{t} mynewstream{t}\n        for {set i 0} {$i < 1000} {incr i} {\n            r XADD mystream{t} * item 2 value b\n        }\n        r copy mystream{t} mynewstream{t}\n        set digest [debug_digest_value mystream{t}]\n        assert_equal $digest [debug_digest_value mynewstream{t}]\n        assert_refcount 1 mystream{t}\n        assert_refcount 1 mynewstream{t}\n        r del mystream{t}\n        assert_equal $digest [debug_digest_value mynewstream{t}]\n    }\n\n    test {COPY basic usage for stream-cgroups} {\n        r del x{t}\n        r XADD x{t} 100 a 1\n        set id [r XADD x{t} 101 b 1]\n        r XADD x{t} 102 c 1\n        r XADD x{t} 103 e 1\n        r XADD x{t} 104 f 1\n        r XADD x{t} 105 g 1\n        r XGROUP CREATE x{t} g1 0\n        r XGROUP CREATE x{t} g2 0\n        r XREADGROUP GROUP g1 Alice COUNT 1 STREAMS x{t} >\n        r XREADGROUP GROUP g1 Bob COUNT 1 STREAMS x{t} >\n        r XREADGROUP GROUP g1 Bob NOACK COUNT 1 STREAMS x{t} >\n        r XREADGROUP GROUP g2 Charlie COUNT 4 STREAMS x{t} >\n        r XGROUP SETID x{t} g1 $id\n        r XREADGROUP GROUP g1 Dave COUNT 3 STREAMS x{t} >\n        r XDEL x{t} 103\n\n        r copy x{t} newx{t}\n        set info [r xinfo stream x{t} full]\n        assert_equal $info [r xinfo stream newx{t} full]\n        assert_refcount 1 x{t}\n        assert_refcount 1 newx{t}\n        r del x{t}\n        assert_equal $info [r xinfo stream newx{t} full]\n        r flushdb\n    }\n\n    test {MOVE basic usage} {\n        r set mykey foobar\n        r move mykey 10\n        set res {}\n        lappend res [r exists mykey]\n        lappend res [r dbsize]\n        r select 10\n        lappend res [r get mykey]\n        lappend res [r dbsize]\n        r select 9\n        format $res\n    } [list 0 0 foobar 1] {singledb:skip}\n\n    test {MOVE against key existing in the target DB} {\n        r set mykey hello\n        r move mykey 10\n    } {0} {singledb:skip}\n\n    test {MOVE against non-integer DB (#1428)} {\n        r set mykey hello\n        catch {r move mykey notanumber} e\n        set e\n    } {ERR value is not an integer or out of range} {singledb:skip}\n\n    test {MOVE can move key expire metadata as well} {\n        r select 10\n        r flushdb\n        r select 9\n        r set mykey foo ex 100\n        r move mykey 10\n        assert {[r ttl mykey] == -2}\n        r select 10\n        assert {[r ttl mykey] > 0 && [r ttl mykey] <= 100}\n        assert {[r get mykey] eq \"foo\"}\n        r select 9\n    } {OK} {singledb:skip}\n\n    test {MOVE does not create an expire if it does not exist} {\n        r select 10\n        r flushdb\n        r select 9\n        r set mykey foo\n        r move mykey 10\n        assert {[r ttl mykey] == -2}\n        r select 10\n        assert {[r ttl mykey] == -1}\n        assert {[r get mykey] eq \"foo\"}\n        r select 9\n    } {OK} {singledb:skip}\n\n    test {SET/GET keys in different DBs} {\n        r set a hello\n        r set b world\n        r select 10\n        r set a foo\n        r set b bared\n        r select 9\n        set res {}\n        lappend res [r get a]\n        lappend res [r get b]\n        r select 10\n        lappend res [r get a]\n        lappend res [r get b]\n        r select 9\n        format $res\n    } {hello world foo bared} {singledb:skip}\n\n    test {RANDOMKEY} {\n        r flushdb\n        r set foo x\n        r set bar y\n        set foo_seen 0\n        set bar_seen 0\n        for {set i 0} {$i < 100} {incr i} {\n            set rkey [r randomkey]\n            if {$rkey eq {foo}} {\n                set foo_seen 1\n            }\n            if {$rkey eq {bar}} {\n                set bar_seen 1\n            }\n        }\n        list $foo_seen $bar_seen\n    } {1 1}\n\n    test {RANDOMKEY against empty DB} {\n        r flushdb\n        r randomkey\n    } {}\n\n    test {RANDOMKEY regression 1} {\n        r flushdb\n        r set x 10\n        r del x\n        r randomkey\n    } {}\n\n    test {KEYS * two times with long key, Github issue #1208} {\n        r flushdb\n        r set dlskeriewrioeuwqoirueioqwrueoqwrueqw test\n        r keys *\n        r keys *\n    } {dlskeriewrioeuwqoirueioqwrueoqwrueqw}\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"fmacros.h\"\n#include \"fpconv_dtoa.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <limits.h>\n#include <math.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <float.h>\n#include <stdint.h>\n#include <errno.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <libgen.h>\n\n#include \"util.h\"\n#include \"sha256.h\"\n#include \"config.h\"\n\n#define UNUSED(x) ((void)(x))\n\n/* Glob-style pattern matching. */\nstatic int stringmatchlen_impl(const char *pattern, int patternLen,\n        const char *string, int stringLen, int nocase, int *skipLongerMatches)\n{\n    while(patternLen && stringLen) {\n        switch(pattern[0]) {\n        case '*':\n            while (patternLen && pattern[1] == '*') {\n                pattern++;\n                patternLen--;\n            }\n            if (patternLen == 1)\n                return 1; /* match */\n            while(stringLen) {\n                if (stringmatchlen_impl(pattern+1, patternLen-1,\n                            string, stringLen, nocase, skipLongerMatches))\n                    return 1; /* match */\n                if (*skipLongerMatches)\n                    return 0; /* no match */\n                string++;\n                stringLen--;\n            }\n            /* There was no match for the rest of the pattern starting\n             * from anywhere in the rest of the string. If there were\n             * any '*' earlier in the pattern, we can terminate the\n             * search early without trying to match them to longer\n             * substrings. This is because a longer match for the\n             * earlier part of the pattern would require the rest of the\n             * pattern to match starting later in the string, and we\n             * have just determined that there is no match for the rest\n             * of the pattern starting from anywhere in the current\n             * string. */\n            *skipLongerMatches = 1;\n            return 0; /* no match */\n            break;\n        case '?':\n            string++;\n            stringLen--;\n            break;\n        case '[':\n        {\n            int not, match;\n\n            pattern++;\n            patternLen--;\n            not = pattern[0] == '^';\n            if (not) {\n                pattern++;\n                patternLen--;\n            }\n            match = 0;\n            while(1) {\n                if (pattern[0] == '\\\\' && patternLen >= 2) {\n                    pattern++;\n                    patternLen--;\n                    if (pattern[0] == string[0])\n                        match = 1;\n                } else if (pattern[0] == ']') {\n                    break;\n                } else if (patternLen == 0) {\n                    pattern--;\n                    patternLen++;\n                    break;\n                } else if (patternLen >= 3 && pattern[1] == '-') {\n                    int start = pattern[0];\n                    int end = pattern[2];\n                    int c = string[0];\n                    if (start > end) {\n                        int t = start;\n                        start = end;\n                        end = t;\n                    }\n                    if (nocase) {\n                        start = tolower(start);\n                        end = tolower(end);\n                        c = tolower(c);\n                    }\n                    pattern += 2;\n                    patternLen -= 2;\n                    if (c >= start && c <= end)\n                        match = 1;\n                } else {\n                    if (!nocase) {\n                        if (pattern[0] == string[0])\n                            match = 1;\n                    } else {\n                        if (tolower((int)pattern[0]) == tolower((int)string[0]))\n                            match = 1;\n                    }\n                }\n                pattern++;\n                patternLen--;\n            }\n            if (not)\n                match = !match;\n            if (!match)\n                return 0; /* no match */\n            string++;\n            stringLen--;\n            break;\n        }\n        case '\\\\':\n            if (patternLen >= 2) {\n                pattern++;\n                patternLen--;\n            }\n            /* fall through */\n        default:\n            if (!nocase) {\n                if (pattern[0] != string[0])\n                    return 0; /* no match */\n            } else {\n                if (tolower((int)pattern[0]) != tolower((int)string[0]))\n                    return 0; /* no match */\n            }\n            string++;\n            stringLen--;\n            break;\n        }\n        pattern++;\n        patternLen--;\n        if (stringLen == 0) {\n            while(*pattern == '*') {\n                pattern++;\n                patternLen--;\n            }\n            break;\n        }\n    }\n    if (patternLen == 0 && stringLen == 0)\n        return 1;\n    return 0;\n}\n\nint stringmatchlen(const char *pattern, int patternLen,\n        const char *string, int stringLen, int nocase) {\n    int skipLongerMatches = 0;\n    return stringmatchlen_impl(pattern,patternLen,string,stringLen,nocase,&skipLongerMatches);\n}\n\nint stringmatch(const char *pattern, const char *string, int nocase) {\n    return stringmatchlen(pattern,strlen(pattern),string,strlen(string),nocase);\n}\n\n/* Fuzz stringmatchlen() trying to crash it with bad input. */\nint stringmatchlen_fuzz_test(void) {\n    char str[32];\n    char pat[32];\n    int cycles = 10000000;\n    int total_matches = 0;\n    while(cycles--) {\n        int strlen = rand() % sizeof(str);\n        int patlen = rand() % sizeof(pat);\n        for (int j = 0; j < strlen; j++) str[j] = rand() % 128;\n        for (int j = 0; j < patlen; j++) pat[j] = rand() % 128;\n        total_matches += stringmatchlen(pat, patlen, str, strlen, 0);\n    }\n    return total_matches;\n}\n\n\n/* Convert a string representing an amount of memory into the number of\n * bytes, so for instance memtoull(\"1Gb\") will return 1073741824 that is\n * (1024*1024*1024).\n *\n * On parsing error, if *err is not NULL, it's set to 1, otherwise it's\n * set to 0. On error the function return value is 0, regardless of the\n * fact 'err' is NULL or not. */\nunsigned long long memtoull(const char *p, int *err) {\n    const char *u;\n    char buf[128];\n    long mul; /* unit multiplier */\n    unsigned long long val;\n    unsigned int digits;\n\n    if (err) *err = 0;\n\n    /* Search the first non digit character. */\n    u = p;\n    if (*u == '-') {\n        if (err) *err = 1;\n        return 0;\n    }\n    while(*u && isdigit(*u)) u++;\n    if (*u == '\\0' || !strcasecmp(u,\"b\")) {\n        mul = 1;\n    } else if (!strcasecmp(u,\"k\")) {\n        mul = 1000;\n    } else if (!strcasecmp(u,\"kb\")) {\n        mul = 1024;\n    } else if (!strcasecmp(u,\"m\")) {\n        mul = 1000*1000;\n    } else if (!strcasecmp(u,\"mb\")) {\n        mul = 1024*1024;\n    } else if (!strcasecmp(u,\"g\")) {\n        mul = 1000L*1000*1000;\n    } else if (!strcasecmp(u,\"gb\")) {\n        mul = 1024L*1024*1024;\n    } else {\n        if (err) *err = 1;\n        return 0;\n    }\n\n    /* Copy the digits into a buffer, we'll use strtoll() to convert\n     * the digit (without the unit) into a number. */\n    digits = u-p;\n    if (digits >= sizeof(buf)) {\n        if (err) *err = 1;\n        return 0;\n    }\n    memcpy(buf,p,digits);\n    buf[digits] = '\\0';\n\n    char *endptr;\n    errno = 0;\n    val = strtoull(buf,&endptr,10);\n    if ((val == 0 && errno == EINVAL) || *endptr != '\\0') {\n        if (err) *err = 1;\n        return 0;\n    }\n    return val*mul;\n}\n\n/* Search a memory buffer for any set of bytes, like strpbrk().\n * Returns pointer to first found char or NULL.\n */\nconst char *mempbrk(const char *s, size_t len, const char *chars, size_t charslen) {\n    for (size_t j = 0; j < len; j++) {\n        for (size_t n = 0; n < charslen; n++)\n            if (s[j] == chars[n]) return &s[j];\n    }\n\n    return NULL;\n}\n\n/* Modify the buffer replacing all occurrences of chars from the 'from'\n * set with the corresponding char in the 'to' set. Always returns s.\n */\nchar *memmapchars(char *s, size_t len, const char *from, const char *to, size_t setlen) {\n    for (size_t j = 0; j < len; j++) {\n        for (size_t i = 0; i < setlen; i++) {\n            if (s[j] == from[i]) {\n                s[j] = to[i];\n                break;\n            }\n        }\n    }\n    return s;\n}\n\n/* Return the number of digits of 'v' when converted to string in radix 10.\n * See ll2string() for more information. */\nuint32_t digits10(uint64_t v) {\n    if (v < 10) return 1;\n    if (v < 100) return 2;\n    if (v < 1000) return 3;\n    if (v < 1000000000000UL) {\n        if (v < 100000000UL) {\n            if (v < 1000000) {\n                if (v < 10000) return 4;\n                return 5 + (v >= 100000);\n            }\n            return 7 + (v >= 10000000UL);\n        }\n        if (v < 10000000000UL) {\n            return 9 + (v >= 1000000000UL);\n        }\n        return 11 + (v >= 100000000000UL);\n    }\n    return 12 + digits10(v / 1000000000000UL);\n}\n\n/* Like digits10() but for signed values. */\nuint32_t sdigits10(int64_t v) {\n    if (v < 0) {\n        /* Abs value of LLONG_MIN requires special handling. */\n        uint64_t uv = (v != LLONG_MIN) ?\n                      (uint64_t)-v : ((uint64_t) LLONG_MAX)+1;\n        return digits10(uv)+1; /* +1 for the minus. */\n    } else {\n        return digits10(v);\n    }\n}\n\n/* Convert a long long into a string. Returns the number of\n * characters needed to represent the number.\n * If the buffer is not big enough to store the string, 0 is returned. */\nint ll2string(char *dst, size_t dstlen, long long svalue) {\n    unsigned long long value;\n    int negative = 0;\n\n    /* The ull2string function with 64bit unsigned integers for simplicity, so\n     * we convert the number here and remember if it is negative. */\n    if (svalue < 0) {\n        if (svalue != LLONG_MIN) {\n            value = -svalue;\n        } else {\n            value = ((unsigned long long) LLONG_MAX)+1;\n        }\n        if (dstlen < 2)\n            goto err;\n        negative = 1;\n        dst[0] = '-';\n        dst++;\n        dstlen--;\n    } else {\n        value = svalue;\n    }\n\n    /* Converts the unsigned long long value to string*/\n    int length = ull2string(dst, dstlen, value);\n    if (length == 0) return 0;\n    return length + negative;\n\nerr:\n    /* force add Null termination */\n    if (dstlen > 0)\n        dst[0] = '\\0';\n    return 0;\n}\n\n/* Convert a unsigned long long into a string. Returns the number of\n * characters needed to represent the number.\n * If the buffer is not big enough to store the string, 0 is returned.\n *\n * Based on the following article (that apparently does not provide a\n * novel approach but only publicizes an already used technique):\n *\n * https://www.facebook.com/notes/facebook-engineering/three-optimization-tips-for-c/10151361643253920 */\nint ull2string(char *dst, size_t dstlen, unsigned long long value) {\n    static const char digits[201] =\n        \"0001020304050607080910111213141516171819\"\n        \"2021222324252627282930313233343536373839\"\n        \"4041424344454647484950515253545556575859\"\n        \"6061626364656667686970717273747576777879\"\n        \"8081828384858687888990919293949596979899\";\n\n    /* Check length. */\n    uint32_t length = digits10(value);\n    if (length >= dstlen) goto err;;\n\n    /* Null term. */\n    uint32_t next = length - 1;\n    dst[next + 1] = '\\0';\n    while (value >= 100) {\n        int const i = (value % 100) * 2;\n        value /= 100;\n        dst[next] = digits[i + 1];\n        dst[next - 1] = digits[i];\n        next -= 2;\n    }\n\n    /* Handle last 1-2 digits. */\n    if (value < 10) {\n        dst[next] = '0' + (uint32_t) value;\n    } else {\n        int i = (uint32_t) value * 2;\n        dst[next] = digits[i + 1];\n        dst[next - 1] = digits[i];\n    }\n    return length;\nerr:\n    /* force add Null termination */\n    if (dstlen > 0)\n        dst[0] = '\\0';\n    return 0;\n}\n\n/* Convert a string into a long long. Returns 1 if the string could be parsed\n * into a (non-overflowing) long long, 0 otherwise. The value will be set to\n * the parsed value when appropriate.\n *\n * Note that this function demands that the string strictly represents\n * a long long: no spaces or other characters before or after the string\n * representing the number are accepted, nor zeroes at the start if not\n * for the string \"0\" representing the zero number.\n *\n * Because of its strictness, it is safe to use this function to check if\n * you can convert a string into a long long, and obtain back the string\n * from the number without any loss in the string representation. */\nint string2ll(const char *s, size_t slen, long long *value) {\n    const char *p = s;\n    size_t plen = 0;\n    int negative = 0;\n    unsigned long long v;\n\n    /* A string of zero length or excessive length is not a valid number. */\n    if (plen == slen || slen >= LONG_STR_SIZE)\n        return 0;\n\n    /* Special case: first and only digit is 0. */\n    if (slen == 1 && p[0] == '0') {\n        if (value != NULL) *value = 0;\n        return 1;\n    }\n\n    /* Handle negative numbers: just set a flag and continue like if it\n     * was a positive number. Later convert into negative. */\n    if (p[0] == '-') {\n        negative = 1;\n        p++; plen++;\n\n        /* Abort on only a negative sign. */\n        if (plen == slen)\n            return 0;\n    }\n\n    /* First digit should be 1-9, otherwise the string should just be 0. */\n    if (p[0] >= '1' && p[0] <= '9') {\n        v = p[0]-'0';\n        p++; plen++;\n    } else {\n        return 0;\n    }\n\n    /* Parse all the other digits, checking for overflow at every step. */\n    while (plen < slen && p[0] >= '0' && p[0] <= '9') {\n        if (v > (ULLONG_MAX / 10)) /* Overflow. */\n            return 0;\n        v *= 10;\n\n        if (v > (ULLONG_MAX - (p[0]-'0'))) /* Overflow. */\n            return 0;\n        v += p[0]-'0';\n\n        p++; plen++;\n    }\n\n    /* Return if not all bytes were used. */\n    if (plen < slen)\n        return 0;\n\n    /* Convert to negative if needed, and do the final overflow check when\n     * converting from unsigned long long to long long. */\n    if (negative) {\n        if (v > ((unsigned long long)(-(LLONG_MIN+1))+1)) /* Overflow. */\n            return 0;\n        if (value != NULL) *value = -v;\n    } else {\n        if (v > LLONG_MAX) /* Overflow. */\n            return 0;\n        if (value != NULL) *value = v;\n    }\n    return 1;\n}\n\n/* Helper function to convert a string to an unsigned long long value.\n * The function attempts to use the faster string2ll() function inside\n * Redis: if it fails, strtoull() is used instead. The function returns\n * 1 if the conversion happened successfully or 0 if the number is\n * invalid or out of range. */\nint string2ull(const char *s, unsigned long long *value) {\n    long long ll;\n    if (string2ll(s,strlen(s),&ll)) {\n        if (ll < 0) return 0; /* Negative values are out of range. */\n        *value = ll;\n        return 1;\n    }\n    errno = 0;\n    char *endptr = NULL;\n    *value = strtoull(s,&endptr,10);\n    if (errno == EINVAL || errno == ERANGE || !(*s != '\\0' && *endptr == '\\0'))\n        return 0; /* strtoull() failed. */\n    return 1; /* Conversion done! */\n}\n\n/* Convert a string into a long. Returns 1 if the string could be parsed into a\n * (non-overflowing) long, 0 otherwise. The value will be set to the parsed\n * value when appropriate. */\nint string2l(const char *s, size_t slen, long *lval) {\n    long long llval;\n\n    if (!string2ll(s,slen,&llval))\n        return 0;\n\n    if (llval < LONG_MIN || llval > LONG_MAX)\n        return 0;\n\n    *lval = (long)llval;\n    return 1;\n}\n\n/* Convert a string into a double. Returns 1 if the string could be parsed\n * into a (non-overflowing) double, 0 otherwise. The value will be set to\n * the parsed value when appropriate.\n *\n * Note that this function demands that the string strictly represents\n * a double: no spaces or other characters before or after the string\n * representing the number are accepted. */\nint string2ld(const char *s, size_t slen, long double *dp) {\n    char buf[MAX_LONG_DOUBLE_CHARS];\n    long double value;\n    char *eptr;\n\n    if (slen == 0 || slen >= sizeof(buf)) return 0;\n    memcpy(buf,s,slen);\n    buf[slen] = '\\0';\n\n    errno = 0;\n    value = strtold(buf, &eptr);\n    if (isspace(buf[0]) || eptr[0] != '\\0' ||\n        (size_t)(eptr-buf) != slen ||\n        (errno == ERANGE &&\n            (value == HUGE_VAL || value == -HUGE_VAL || fpclassify(value) == FP_ZERO)) ||\n        errno == EINVAL ||\n        isnan(value))\n        return 0;\n\n    if (dp) *dp = value;\n    return 1;\n}\n\n/* Convert a string into a double. Returns 1 if the string could be parsed\n * into a (non-overflowing) double, 0 otherwise. The value will be set to\n * the parsed value when appropriate.\n *\n * Note that this function demands that the string strictly represents\n * a double: no spaces or other characters before or after the string\n * representing the number are accepted. */\nint string2d(const char *s, size_t slen, double *dp) {\n    errno = 0;\n    char *eptr;\n    *dp = strtod(s, &eptr);\n    if (slen == 0 ||\n        isspace(((const char*)s)[0]) ||\n        (size_t)(eptr-(char*)s) != slen ||\n        (errno == ERANGE &&\n            (*dp == HUGE_VAL || *dp == -HUGE_VAL || fpclassify(*dp) == FP_ZERO)) ||\n        isnan(*dp))\n        return 0;\n    return 1;\n}\n\n/* Returns 1 if the double value can safely be represented in long long without\n * precision loss, in which case the corresponding long long is stored in the out variable. */\nint double2ll(double d, long long *out) {\n#if (DBL_MANT_DIG >= 52) && (DBL_MANT_DIG <= 63) && (LLONG_MAX == 0x7fffffffffffffffLL)\n    /* Check if the float is in a safe range to be casted into a\n     * long long. We are assuming that long long is 64 bit here.\n     * Also we are assuming that there are no implementations around where\n     * double has precision < 52 bit.\n     *\n     * Under this assumptions we test if a double is inside a range\n     * where casting to long long is safe. Then using two castings we\n     * make sure the decimal part is zero. If all this is true we can use\n     * integer without precision loss.\n     *\n     * Note that numbers above 2^52 and below 2^63 use all the fraction bits as real part,\n     * and the exponent bits are positive, which means the \"decimal\" part must be 0.\n     * i.e. all double values in that range are representable as a long without precision loss,\n     * but not all long values in that range can be represented as a double.\n     * we only care about the first part here. */\n    if (d < (double)(-LLONG_MAX/2) || d > (double)(LLONG_MAX/2))\n        return 0;\n    long long ll = d;\n    if (ll == d) {\n        *out = ll;\n        return 1;\n    }\n#endif\n    return 0;\n}\n\n/* Convert a double to a string representation. Returns the number of bytes\n * required. The representation should always be parsable by strtod(3).\n * This function does not support human-friendly formatting like ld2string\n * does. It is intended mainly to be used inside t_zset.c when writing scores\n * into a listpack representing a sorted set. */\nint d2string(char *buf, size_t len, double value) {\n    if (isnan(value)) {\n        /* Libc in some systems will format nan in a different way,\n         * like nan, -nan, NAN, nan(char-sequence).\n         * So we normalize it and create a single nan form in an explicit way. */\n        len = snprintf(buf,len,\"nan\");\n    } else if (isinf(value)) {\n        /* Libc in odd systems (Hi Solaris!) will format infinite in a\n         * different way, so better to handle it in an explicit way. */\n        if (value < 0)\n            len = snprintf(buf,len,\"-inf\");\n        else\n            len = snprintf(buf,len,\"inf\");\n    } else if (value == 0) {\n        /* See: http://en.wikipedia.org/wiki/Signed_zero, \"Comparisons\". */\n        if (1.0/value < 0)\n            len = snprintf(buf,len,\"-0\");\n        else\n            len = snprintf(buf,len,\"0\");\n    } else {\n        long long lvalue;\n        /* Integer printing function is much faster, check if we can safely use it. */\n        if (double2ll(value, &lvalue))\n            len = ll2string(buf,len,lvalue);\n        else {\n            len = fpconv_dtoa(value, buf);\n            buf[len] = '\\0';\n        }\n    }\n\n    return len;\n}\n\n/* Convert a double into a string with 'fractional_digits' digits after the dot precision.\n * This is an optimized version of snprintf \"%.<fractional_digits>f\".\n * We convert the double to long and multiply it  by 10 ^ <fractional_digits> to shift\n * the decimal places.\n * Note that multiply it of input value by 10 ^ <fractional_digits> can overflow but on the scenario\n * that we currently use within redis this that is not possible.\n * After we get the long representation we use the logic from ull2string function on this file\n * which is based on the following article:\n * https://www.facebook.com/notes/facebook-engineering/three-optimization-tips-for-c/10151361643253920\n *\n * Input values:\n * char: the buffer to store the string representation\n * dstlen: the buffer length\n * dvalue: the input double\n * fractional_digits: the number of fractional digits after the dot precision. between 1 and 17\n *\n * Return values:\n * Returns the number of characters needed to represent the number.\n * If the buffer is not big enough to store the string, 0 is returned.\n */\nint fixedpoint_d2string(char *dst, size_t dstlen, double dvalue, int fractional_digits) {\n    if (fractional_digits < 1 || fractional_digits > 17)\n        goto err;\n    /* min size of 2 ( due to 0. ) + n fractional_digitits + \\0 */\n    if ((int)dstlen < (fractional_digits+3))\n        goto err;\n    if (dvalue == 0) {\n        dst[0] = '0';\n        dst[1] = '.';\n        memset(dst + 2, '0', fractional_digits);\n        dst[fractional_digits+2] = '\\0';\n        return fractional_digits + 2;\n    }\n    /* scale and round */\n    static double powers_of_ten[] = {1.0, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0,\n    10000000.0, 100000000.0, 1000000000.0, 10000000000.0, 100000000000.0, 1000000000000.0,\n    10000000000000.0, 100000000000000.0, 1000000000000000.0, 10000000000000000.0,\n    100000000000000000.0 };\n    long long svalue = llrint(dvalue * powers_of_ten[fractional_digits]);\n    unsigned long long value;\n    /* write sign */\n    int negative = 0;\n    if (svalue < 0) {\n        if (svalue != LLONG_MIN) {\n            value = -svalue;\n        } else {\n            value = ((unsigned long long) LLONG_MAX)+1;\n        }\n        if (dstlen < 2)\n            goto err;\n        negative = 1;\n        dst[0] = '-';\n        dst++;\n        dstlen--;\n    } else {\n        value = svalue;\n    }\n\n    static const char digitsd[201] =\n        \"0001020304050607080910111213141516171819\"\n        \"2021222324252627282930313233343536373839\"\n        \"4041424344454647484950515253545556575859\"\n        \"6061626364656667686970717273747576777879\"\n        \"8081828384858687888990919293949596979899\";\n\n    /* Check length. */\n    uint32_t ndigits = digits10(value);\n    if (ndigits >= dstlen) goto err;\n    int integer_digits = ndigits - fractional_digits;\n    /* Fractional only check to avoid representing 0.7750 as .7750.\n     * This means we need to increment the length and store 0 as the first character.\n     */\n    if (integer_digits < 1) {\n        dst[0] = '0';\n        integer_digits = 1;\n    }\n    dst[integer_digits] = '.';\n    int size = integer_digits + 1 + fractional_digits;\n    /* fill with 0 from fractional digits until size */\n    memset(dst + integer_digits + 1, '0', fractional_digits);\n    int next = size - 1;\n    while (value >= 100) {\n        int const i = (value % 100) * 2;\n        value /= 100;\n        dst[next] = digitsd[i + 1];\n        dst[next - 1] = digitsd[i];\n        next -= 2;\n        /* dot position */\n        if (next == integer_digits) {\n            next--;\n        }\n    }\n\n    /* Handle last 1-2 digits. */\n    if (value < 10) {\n        dst[next] = '0' + (uint32_t) value;\n    } else {\n        int i = (uint32_t) value * 2;\n        dst[next] = digitsd[i + 1];\n        dst[next - 1] = digitsd[i];\n    }\n    /* Null term. */\n    dst[size] = '\\0';\n    return size + negative;\nerr:\n    /* force add Null termination */\n    if (dstlen > 0)\n        dst[0] = '\\0';\n    return 0;\n}\n\n/* Trims off trailing zeros from a string representing a double. */\nint trimDoubleString(char *buf, size_t len) {\n    if (strchr(buf,'.') != NULL) {\n        char *p = buf+len-1;\n        while(*p == '0') {\n            p--;\n            len--;\n        }\n        if (*p == '.') len--;\n    }\n    buf[len] = '\\0';\n    return len;\n}\n\n/* Create a string object from a long double.\n * If mode is humanfriendly it does not use exponential format and trims trailing\n * zeroes at the end (may result in loss of precision).\n * If mode is default exp format is used and the output of snprintf()\n * is not modified (may result in loss of precision).\n * If mode is hex hexadecimal format is used (no loss of precision)\n *\n * The function returns the length of the string or zero if there was not\n * enough buffer room to store it. */\nint ld2string(char *buf, size_t len, long double value, ld2string_mode mode) {\n    size_t l = 0;\n\n    if (isinf(value)) {\n        /* Libc in odd systems (Hi Solaris!) will format infinite in a\n         * different way, so better to handle it in an explicit way. */\n        if (len < 5) goto err; /* No room. 5 is \"-inf\\0\" */\n        if (value > 0) {\n            memcpy(buf,\"inf\",3);\n            l = 3;\n        } else {\n            memcpy(buf,\"-inf\",4);\n            l = 4;\n        }\n    } else if (isnan(value)) {\n        /* Libc in some systems will format nan in a different way,\n         * like nan, -nan, NAN, nan(char-sequence).\n         * So we normalize it and create a single nan form in an explicit way. */\n        if (len < 4) goto err; /* No room. 4 is \"nan\\0\" */\n        memcpy(buf, \"nan\", 3);\n        l = 3;\n    } else {\n        switch (mode) {\n        case LD_STR_AUTO:\n            l = snprintf(buf,len,\"%.17Lg\",value);\n            if (l+1 > len) goto err;; /* No room. */\n            break;\n        case LD_STR_HEX:\n            l = snprintf(buf,len,\"%La\",value);\n            if (l+1 > len) goto err; /* No room. */\n            break;\n        case LD_STR_HUMAN:\n            /* We use 17 digits precision since with 128 bit floats that precision\n             * after rounding is able to represent most small decimal numbers in a\n             * way that is \"non surprising\" for the user (that is, most small\n             * decimal numbers will be represented in a way that when converted\n             * back into a string are exactly the same as what the user typed.) */\n            l = snprintf(buf,len,\"%.17Lf\",value);\n            if (l+1 > len) goto err; /* No room. */\n            /* Now remove trailing zeroes after the '.' */\n            if (strchr(buf,'.') != NULL) {\n                char *p = buf+l-1;\n                while(*p == '0') {\n                    p--;\n                    l--;\n                }\n                if (*p == '.') l--;\n            }\n            if (l == 2 && buf[0] == '-' && buf[1] == '0') {\n                buf[0] = '0';\n                l = 1;\n            }\n            break;\n        default: goto err; /* Invalid mode. */\n        }\n    }\n    buf[l] = '\\0';\n    return l;\nerr:\n    /* force add Null termination */\n    if (len > 0)\n        buf[0] = '\\0';\n    return 0;\n}\n\n/* Get random bytes, attempts to get an initial seed from /dev/urandom and\n * the uses a one way hash function in counter mode to generate a random\n * stream. However if /dev/urandom is not available, a weaker seed is used.\n *\n * This function is not thread safe, since the state is global. */\nvoid getRandomBytes(unsigned char *p, size_t len) {\n    /* Global state. */\n    static int seed_initialized = 0;\n    static unsigned char seed[64]; /* 512 bit internal block size. */\n    static uint64_t counter = 0; /* The counter we hash with the seed. */\n\n    if (!seed_initialized) {\n        /* Initialize a seed and use SHA1 in counter mode, where we hash\n         * the same seed with a progressive counter. For the goals of this\n         * function we just need non-colliding strings, there are no\n         * cryptographic security needs. */\n        FILE *fp = fopen(\"/dev/urandom\",\"r\");\n        if (fp == NULL || fread(seed,sizeof(seed),1,fp) != 1) {\n            /* Revert to a weaker seed, and in this case reseed again\n             * at every call.*/\n            for (unsigned int j = 0; j < sizeof(seed); j++) {\n                struct timeval tv;\n                gettimeofday(&tv,NULL);\n                pid_t pid = getpid();\n                seed[j] = tv.tv_sec ^ tv.tv_usec ^ pid ^ (long)fp;\n            }\n        } else {\n            seed_initialized = 1;\n        }\n        if (fp) fclose(fp);\n    }\n\n    while(len) {\n        /* This implements SHA256-HMAC. */\n        unsigned char digest[SHA256_BLOCK_SIZE];\n        unsigned char kxor[64];\n        unsigned int copylen =\n            len > SHA256_BLOCK_SIZE ? SHA256_BLOCK_SIZE : len;\n\n        /* IKEY: key xored with 0x36. */\n        memcpy(kxor,seed,sizeof(kxor));\n        for (unsigned int i = 0; i < sizeof(kxor); i++) kxor[i] ^= 0x36;\n\n        /* Obtain HASH(IKEY||MESSAGE). */\n        SHA256_CTX ctx;\n        sha256_init(&ctx);\n        sha256_update(&ctx,kxor,sizeof(kxor));\n        sha256_update(&ctx,(unsigned char*)&counter,sizeof(counter));\n        sha256_final(&ctx,digest);\n\n        /* OKEY: key xored with 0x5c. */\n        memcpy(kxor,seed,sizeof(kxor));\n        for (unsigned int i = 0; i < sizeof(kxor); i++) kxor[i] ^= 0x5C;\n\n        /* Obtain HASH(OKEY || HASH(IKEY||MESSAGE)). */\n        sha256_init(&ctx);\n        sha256_update(&ctx,kxor,sizeof(kxor));\n        sha256_update(&ctx,digest,SHA256_BLOCK_SIZE);\n        sha256_final(&ctx,digest);\n\n        /* Increment the counter for the next iteration. */\n        counter++;\n\n        memcpy(p,digest,copylen);\n        len -= copylen;\n        p += copylen;\n    }\n}\n\n/* Generate the Redis \"Run ID\", a SHA1-sized random number that identifies a\n * given execution of Redis, so that if you are talking with an instance\n * having run_id == A, and you reconnect and it has run_id == B, you can be\n * sure that it is either a different instance or it was restarted. */\nvoid getRandomHexChars(char *p, size_t len) {\n    char *charset = \"0123456789abcdef\";\n    size_t j;\n\n    getRandomBytes((unsigned char*)p,len);\n    for (j = 0; j < len; j++) p[j] = charset[p[j] & 0x0F];\n}\n\n/* Given the filename, return the absolute path as an SDS string, or NULL\n * if it fails for some reason. Note that \"filename\" may be an absolute path\n * already, this will be detected and handled correctly.\n *\n * The function does not try to normalize everything, but only the obvious\n * case of one or more \"../\" appearing at the start of \"filename\"\n * relative path. */\nsds getAbsolutePath(char *filename) {\n    char cwd[1024];\n    sds abspath;\n    sds relpath = sdsnew(filename);\n\n    relpath = sdstrim(relpath,\" \\r\\n\\t\");\n    if (relpath[0] == '/') return relpath; /* Path is already absolute. */\n\n    /* If path is relative, join cwd and relative path. */\n    if (getcwd(cwd,sizeof(cwd)) == NULL) {\n        sdsfree(relpath);\n        return NULL;\n    }\n    abspath = sdsnew(cwd);\n    if (sdslen(abspath) && abspath[sdslen(abspath)-1] != '/')\n        abspath = sdscat(abspath,\"/\");\n\n    /* At this point we have the current path always ending with \"/\", and\n     * the trimmed relative path. Try to normalize the obvious case of\n     * trailing ../ elements at the start of the path.\n     *\n     * For every \"../\" we find in the filename, we remove it and also remove\n     * the last element of the cwd, unless the current cwd is \"/\". */\n    while (sdslen(relpath) >= 3 &&\n           relpath[0] == '.' && relpath[1] == '.' && relpath[2] == '/')\n    {\n        sdsrange(relpath,3,-1);\n        if (sdslen(abspath) > 1) {\n            char *p = abspath + sdslen(abspath)-2;\n            int trimlen = 1;\n\n            while(*p != '/') {\n                p--;\n                trimlen++;\n            }\n            sdsrange(abspath,0,-(trimlen+1));\n        }\n    }\n\n    /* Finally glue the two parts together. */\n    abspath = sdscatsds(abspath,relpath);\n    sdsfree(relpath);\n    return abspath;\n}\n\n/*\n * Gets the proper timezone in a more portable fashion\n * i.e timezone variables are linux specific.\n */\nlong getTimeZone(void) {\n#if defined(__linux__) || defined(__sun)\n    return timezone;\n#else\n    struct timeval tv;\n    struct timezone tz;\n\n    gettimeofday(&tv, &tz);\n\n    return tz.tz_minuteswest * 60L;\n#endif\n}\n\n/* Return true if the specified path is just a file basename without any\n * relative or absolute path. This function just checks that no / or \\\n * character exists inside the specified path, that's enough in the\n * environments where Redis runs. */\nint pathIsBaseName(char *path) {\n    return strchr(path,'/') == NULL && strchr(path,'\\\\') == NULL;\n}\n\nint fileExist(char *filename) {\n    struct stat statbuf;\n    return stat(filename, &statbuf) == 0 && S_ISREG(statbuf.st_mode);\n}\n\nint dirExists(char *dname) {\n    struct stat statbuf;\n    return stat(dname, &statbuf) == 0 && S_ISDIR(statbuf.st_mode);\n}\n\nint dirCreateIfMissing(char *dname) {\n    if (mkdir(dname, 0755) != 0) {\n        if (errno != EEXIST) {\n            return -1;\n        } else if (!dirExists(dname)) {\n            errno = ENOTDIR;\n            return -1;\n        }\n    }\n    return 0;\n}\n\nint dirRemove(char *dname) {\n    DIR *dir;\n    struct stat stat_entry;\n    struct dirent *entry;\n    char full_path[PATH_MAX + 1];\n\n    if ((dir = opendir(dname)) == NULL) {\n        return -1;\n    }\n\n    while ((entry = readdir(dir)) != NULL) {\n        if (!strcmp(entry->d_name, \".\") || !strcmp(entry->d_name, \"..\")) continue;\n\n        snprintf(full_path, sizeof(full_path), \"%s/%s\", dname, entry->d_name);\n\n        int fd = open(full_path, O_RDONLY|O_NONBLOCK);\n        if (fd == -1) {\n            closedir(dir);\n            return -1;\n        }\n\n        if (fstat(fd, &stat_entry) == -1) {\n            close(fd);\n            closedir(dir);\n            return -1;\n        }\n        close(fd);\n\n        if (S_ISDIR(stat_entry.st_mode) != 0) {\n            if (dirRemove(full_path) == -1) {\n                return -1;\n            }\n            continue;\n        }\n\n        if (unlink(full_path) != 0) {\n            closedir(dir);\n            return -1;\n        }\n    }\n\n    if (rmdir(dname) != 0) {\n        closedir(dir);\n        return -1;\n    }\n\n    closedir(dir);\n    return 0;\n}\n\nsds makePath(char *path, char *filename) {\n    return sdscatfmt(sdsempty(), \"%s/%s\", path, filename);\n}\n\n/* Given the filename, sync the corresponding directory.\n *\n * Usually a portable and safe pattern to overwrite existing files would be like:\n * 1. create a new temp file (on the same file system!)\n * 2. write data to the temp file\n * 3. fsync() the temp file\n * 4. rename the temp file to the appropriate name\n * 5. fsync() the containing directory */\nint fsyncFileDir(const char *filename) {\n#ifdef _AIX\n    /* AIX is unable to fsync a directory */\n    return 0;\n#endif\n    char temp_filename[PATH_MAX + 1];\n    char *dname;\n    int dir_fd;\n\n    if (strlen(filename) > PATH_MAX) {\n        errno = ENAMETOOLONG;\n        return -1;\n    }\n\n    /* In the glibc implementation dirname may modify their argument. */\n    memcpy(temp_filename, filename, strlen(filename) + 1);\n    dname = dirname(temp_filename);\n\n    dir_fd = open(dname, O_RDONLY);\n    if (dir_fd == -1) {\n        /* Some OSs don't allow us to open directories at all, just\n         * ignore the error in that case */\n        if (errno == EISDIR) {\n            return 0;\n        }\n        return -1;\n    }\n    /* Some OSs don't allow us to fsync directories at all, so we can ignore\n     * those errors. */\n    if (redis_fsync(dir_fd) == -1 && !(errno == EBADF || errno == EINVAL)) {\n        int save_errno = errno;\n        close(dir_fd);\n        errno = save_errno;\n        return -1;\n    }\n    \n    close(dir_fd);\n    return 0;\n}\n\n /* free OS pages backed by file */\nint reclaimFilePageCache(int fd, size_t offset, size_t length) {\n#ifdef HAVE_FADVISE\n    int ret = posix_fadvise(fd, offset, length, POSIX_FADV_DONTNEED);\n    if (ret) return -1;\n    return 0;\n#else\n    UNUSED(fd);\n    UNUSED(offset);\n    UNUSED(length);\n    return 0;\n#endif\n}\n\n#ifdef REDIS_TEST\n#include <assert.h>\n#include <sys/mman.h>\n#include \"testhelp.h\"\n\nstatic void test_string2ll(void) {\n    char buf[32];\n    long long v;\n\n    /* May not start with +. */\n    redis_strlcpy(buf,\"+1\",sizeof(buf));\n    assert(string2ll(buf,strlen(buf),&v) == 0);\n\n    /* Leading space. */\n    redis_strlcpy(buf,\" 1\",sizeof(buf));\n    assert(string2ll(buf,strlen(buf),&v) == 0);\n\n    /* Trailing space. */\n    redis_strlcpy(buf,\"1 \",sizeof(buf));\n    assert(string2ll(buf,strlen(buf),&v) == 0);\n\n    /* May not start with 0. */\n    redis_strlcpy(buf,\"01\",sizeof(buf));\n    assert(string2ll(buf,strlen(buf),&v) == 0);\n\n    redis_strlcpy(buf,\"-1\",sizeof(buf));\n    assert(string2ll(buf,strlen(buf),&v) == 1);\n    assert(v == -1);\n\n    redis_strlcpy(buf,\"0\",sizeof(buf));\n    assert(string2ll(buf,strlen(buf),&v) == 1);\n    assert(v == 0);\n\n    redis_strlcpy(buf,\"1\",sizeof(buf));\n    assert(string2ll(buf,strlen(buf),&v) == 1);\n    assert(v == 1);\n\n    redis_strlcpy(buf,\"99\",sizeof(buf));\n    assert(string2ll(buf,strlen(buf),&v) == 1);\n    assert(v == 99);\n\n    redis_strlcpy(buf,\"-99\",sizeof(buf));\n    assert(string2ll(buf,strlen(buf),&v) == 1);\n    assert(v == -99);\n\n    redis_strlcpy(buf,\"-9223372036854775808\",sizeof(buf));\n    assert(string2ll(buf,strlen(buf),&v) == 1);\n    assert(v == LLONG_MIN);\n\n    redis_strlcpy(buf,\"-9223372036854775809\",sizeof(buf)); /* overflow */\n    assert(string2ll(buf,strlen(buf),&v) == 0);\n\n    redis_strlcpy(buf,\"9223372036854775807\",sizeof(buf));\n    assert(string2ll(buf,strlen(buf),&v) == 1);\n    assert(v == LLONG_MAX);\n\n    redis_strlcpy(buf,\"9223372036854775808\",sizeof(buf)); /* overflow */\n    assert(string2ll(buf,strlen(buf),&v) == 0);\n}\n\nstatic void test_string2l(void) {\n    char buf[32];\n    long v;\n\n    /* May not start with +. */\n    redis_strlcpy(buf,\"+1\",sizeof(buf));\n    assert(string2l(buf,strlen(buf),&v) == 0);\n\n    /* May not start with 0. */\n    redis_strlcpy(buf,\"01\",sizeof(buf));\n    assert(string2l(buf,strlen(buf),&v) == 0);\n\n    redis_strlcpy(buf,\"-1\",sizeof(buf));\n    assert(string2l(buf,strlen(buf),&v) == 1);\n    assert(v == -1);\n\n    redis_strlcpy(buf,\"0\",sizeof(buf));\n    assert(string2l(buf,strlen(buf),&v) == 1);\n    assert(v == 0);\n\n    redis_strlcpy(buf,\"1\",sizeof(buf));\n    assert(string2l(buf,strlen(buf),&v) == 1);\n    assert(v == 1);\n\n    redis_strlcpy(buf,\"99\",sizeof(buf));\n    assert(string2l(buf,strlen(buf),&v) == 1);\n    assert(v == 99);\n\n    redis_strlcpy(buf,\"-99\",sizeof(buf));\n    assert(string2l(buf,strlen(buf),&v) == 1);\n    assert(v == -99);\n\n#if LONG_MAX != LLONG_MAX\n    redis_strlcpy(buf,\"-2147483648\",sizeof(buf));\n    assert(string2l(buf,strlen(buf),&v) == 1);\n    assert(v == LONG_MIN);\n\n    redis_strlcpy(buf,\"-2147483649\",sizeof(buf)); /* overflow */\n    assert(string2l(buf,strlen(buf),&v) == 0);\n\n    redis_strlcpy(buf,\"2147483647\",sizeof(buf));\n    assert(string2l(buf,strlen(buf),&v) == 1);\n    assert(v == LONG_MAX);\n\n    redis_strlcpy(buf,\"2147483648\",sizeof(buf)); /* overflow */\n    assert(string2l(buf,strlen(buf),&v) == 0);\n#endif\n}\n\nstatic void test_ll2string(void) {\n    char buf[32];\n    long long v;\n    int sz;\n\n    v = 0;\n    sz = ll2string(buf, sizeof buf, v);\n    assert(sz == 1);\n    assert(!strcmp(buf, \"0\"));\n\n    v = -1;\n    sz = ll2string(buf, sizeof buf, v);\n    assert(sz == 2);\n    assert(!strcmp(buf, \"-1\"));\n\n    v = 99;\n    sz = ll2string(buf, sizeof buf, v);\n    assert(sz == 2);\n    assert(!strcmp(buf, \"99\"));\n\n    v = -99;\n    sz = ll2string(buf, sizeof buf, v);\n    assert(sz == 3);\n    assert(!strcmp(buf, \"-99\"));\n\n    v = -2147483648;\n    sz = ll2string(buf, sizeof buf, v);\n    assert(sz == 11);\n    assert(!strcmp(buf, \"-2147483648\"));\n\n    v = LLONG_MIN;\n    sz = ll2string(buf, sizeof buf, v);\n    assert(sz == 20);\n    assert(!strcmp(buf, \"-9223372036854775808\"));\n\n    v = LLONG_MAX;\n    sz = ll2string(buf, sizeof buf, v);\n    assert(sz == 19);\n    assert(!strcmp(buf, \"9223372036854775807\"));\n}\n\nstatic void test_ld2string(void) {\n    char buf[32];\n    long double v;\n    int sz;\n\n    v = 0.0 / 0.0;\n    sz = ld2string(buf, sizeof(buf), v, LD_STR_AUTO);\n    assert(sz == 3);\n    assert(!strcmp(buf, \"nan\"));\n}\n\nstatic void test_fixedpoint_d2string(void) {\n    char buf[32];\n    double v;\n    int sz;\n    v = 0.0;\n    sz = fixedpoint_d2string(buf, sizeof buf, v, 4);\n    assert(sz == 6);\n    assert(!strcmp(buf, \"0.0000\"));\n    sz = fixedpoint_d2string(buf, sizeof buf, v, 1);\n    assert(sz == 3);\n    assert(!strcmp(buf, \"0.0\"));\n    /* set junk in buffer */\n    memset(buf,'A',32);\n    v = 0.0001;\n    sz = fixedpoint_d2string(buf, sizeof buf, v, 4);\n    assert(sz == 6);\n    assert(buf[sz] == '\\0');\n    assert(!strcmp(buf, \"0.0001\"));\n    /* set junk in buffer */\n    memset(buf,'A',32);\n    v = 6.0642951598391699e-05;\n    sz = fixedpoint_d2string(buf, sizeof buf, v, 4);\n    assert(sz == 6);\n    assert(buf[sz] == '\\0');\n    assert(!strcmp(buf, \"0.0001\"));\n    v = 0.01;\n    sz = fixedpoint_d2string(buf, sizeof buf, v, 4);\n    assert(sz == 6);\n    assert(!strcmp(buf, \"0.0100\"));\n    sz = fixedpoint_d2string(buf, sizeof buf, v, 1);\n    assert(sz == 3);\n    assert(!strcmp(buf, \"0.0\"));\n    v = -0.01;\n    sz = fixedpoint_d2string(buf, sizeof buf, v, 4);\n    assert(sz == 7);\n    assert(!strcmp(buf, \"-0.0100\"));\n     v = -0.1;\n    sz = fixedpoint_d2string(buf, sizeof buf, v, 1);\n    assert(sz == 4);\n    assert(!strcmp(buf, \"-0.1\"));\n    v = 0.1;\n    sz = fixedpoint_d2string(buf, sizeof buf, v, 1);\n    assert(sz == 3);\n    assert(!strcmp(buf, \"0.1\"));\n    v = 0.01;\n    sz = fixedpoint_d2string(buf, sizeof buf, v, 17);\n    assert(sz == 19);\n    assert(!strcmp(buf, \"0.01000000000000000\"));\n    v = 10.01;\n    sz = fixedpoint_d2string(buf, sizeof buf, v, 4);\n    assert(sz == 7);\n    assert(!strcmp(buf, \"10.0100\"));\n    /* negative tests */\n    sz = fixedpoint_d2string(buf, sizeof buf, v, 18);\n    assert(sz == 0);\n    sz = fixedpoint_d2string(buf, sizeof buf, v, 0);\n    assert(sz == 0);\n    sz = fixedpoint_d2string(buf, 1, v, 1);\n    assert(sz == 0);\n}\n\n#if defined(__linux__)\n/* Since fadvise and mincore is only supported in specific platforms like\n * Linux, we only verify the fadvise mechanism works in Linux */\nstatic int cache_exist(int fd) {\n    unsigned char flag;\n    void *m = mmap(NULL, 4096, PROT_READ, MAP_SHARED, fd, 0);\n    assert(m);\n    assert(mincore(m, 4096, &flag) == 0);\n    munmap(m, 4096);\n    /* the least significant bit of the byte will be set if the corresponding\n     * page is currently resident in memory */\n    return flag&1;\n}\n\nstatic void test_reclaimFilePageCache(void) {\n    char *tmpfile = \"/tmp/redis-reclaim-cache-test\";\n    int fd = open(tmpfile, O_RDWR|O_CREAT, 0644);\n    assert(fd >= 0);\n\n    /* test write file */\n    char buf[4] = \"foo\";\n    assert(write(fd, buf, sizeof(buf)) > 0);\n    assert(cache_exist(fd));\n    assert(redis_fsync(fd) == 0);\n    assert(reclaimFilePageCache(fd, 0, 0) == 0);\n    assert(!cache_exist(fd));\n\n    /* test read file */\n    assert(pread(fd, buf, sizeof(buf), 0) > 0);\n    assert(cache_exist(fd));\n    assert(reclaimFilePageCache(fd, 0, 0) == 0);\n    assert(!cache_exist(fd));\n\n    unlink(tmpfile);\n    printf(\"reclaimFilePageCach test is ok\\n\");\n}\n#endif\n\nint utilTest(int argc, char **argv, int flags) {\n    UNUSED(argc);\n    UNUSED(argv);\n    UNUSED(flags);\n\n    test_string2ll();\n    test_string2l();\n    test_ll2string();\n    test_ld2string();\n    test_fixedpoint_d2string();\n#if defined(__linux__)\n    if (!(flags & REDIS_TEST_VALGRIND)) {\n        test_reclaimFilePageCache();\n    }\n#endif\n    printf(\"Done testing util\\n\");\n    return 0;\n}\n#endif\n\n\n", "start_server {tags {\"keyspace\"}} {\n    test {DEL against a single item} {\n        r set x foo\n        assert {[r get x] eq \"foo\"}\n        r del x\n        r get x\n    } {}\n\n    test {Vararg DEL} {\n        r set foo1{t} a\n        r set foo2{t} b\n        r set foo3{t} c\n        list [r del foo1{t} foo2{t} foo3{t} foo4{t}] [r mget foo1{t} foo2{t} foo3{t}]\n    } {3 {{} {} {}}}\n\n    test {Untagged multi-key commands} {\n        r mset foo1 a foo2 b foo3 c\n        assert_equal {a b c {}} [r mget foo1 foo2 foo3 foo4]\n        r del foo1 foo2 foo3 foo4\n    } {3} {cluster:skip}\n\n    test {KEYS with pattern} {\n        foreach key {key_x key_y key_z foo_a foo_b foo_c} {\n            r set $key hello\n        }\n        lsort [r keys foo*]\n    } {foo_a foo_b foo_c}\n\n    test {KEYS to get all keys} {\n        lsort [r keys *]\n    } {foo_a foo_b foo_c key_x key_y key_z}\n\n    test {DBSIZE} {\n        r dbsize\n    } {6}\n\n    test {DEL all keys} {\n        foreach key [r keys *] {r del $key}\n        r dbsize\n    } {0}\n\n    test \"DEL against expired key\" {\n        r debug set-active-expire 0\n        r setex keyExpire 1 valExpire\n        after 1100\n        assert_equal 0 [r del keyExpire]\n        r debug set-active-expire 1\n    } {OK} {needs:debug}\n\n    test {EXISTS} {\n        set res {}\n        r set newkey test\n        append res [r exists newkey]\n        r del newkey\n        append res [r exists newkey]\n    } {10}\n\n    test {Zero length value in key. SET/GET/EXISTS} {\n        r set emptykey {}\n        set res [r get emptykey]\n        append res [r exists emptykey]\n        r del emptykey\n        append res [r exists emptykey]\n    } {10}\n\n    test {Commands pipelining} {\n        set fd [r channel]\n        puts -nonewline $fd \"SET k1 xyzk\\r\\nGET k1\\r\\nPING\\r\\n\"\n        flush $fd\n        set res {}\n        append res [string match OK* [r read]]\n        append res [r read]\n        append res [string match PONG* [r read]]\n        format $res\n    } {1xyzk1}\n\n    test {Non existing command} {\n        catch {r foobaredcommand} err\n        string match ERR* $err\n    } {1}\n\n    test {RENAME basic usage} {\n        r set mykey{t} hello\n        r rename mykey{t} mykey1{t}\n        r rename mykey1{t} mykey2{t}\n        r get mykey2{t}\n    } {hello}\n\n    test {RENAME source key should no longer exist} {\n        r exists mykey\n    } {0}\n\n    test {RENAME against already existing key} {\n        r set mykey{t} a\n        r set mykey2{t} b\n        r rename mykey2{t} mykey{t}\n        set res [r get mykey{t}]\n        append res [r exists mykey2{t}]\n    } {b0}\n\n    test {RENAMENX basic usage} {\n        r del mykey{t}\n        r del mykey2{t}\n        r set mykey{t} foobar\n        r renamenx mykey{t} mykey2{t}\n        set res [r get mykey2{t}]\n        append res [r exists mykey{t}]\n    } {foobar0}\n\n    test {RENAMENX against already existing key} {\n        r set mykey{t} foo\n        r set mykey2{t} bar\n        r renamenx mykey{t} mykey2{t}\n    } {0}\n\n    test {RENAMENX against already existing key (2)} {\n        set res [r get mykey{t}]\n        append res [r get mykey2{t}]\n    } {foobar}\n\n    test {RENAME against non existing source key} {\n        catch {r rename nokey{t} foobar{t}} err\n        format $err\n    } {ERR*}\n\n    test {RENAME where source and dest key are the same (existing)} {\n        r set mykey foo\n        r rename mykey mykey\n    } {OK}\n\n    test {RENAMENX where source and dest key are the same (existing)} {\n        r set mykey foo\n        r renamenx mykey mykey\n    } {0}\n\n    test {RENAME where source and dest key are the same (non existing)} {\n        r del mykey\n        catch {r rename mykey mykey} err\n        format $err\n    } {ERR*}\n\n    test {RENAME with volatile key, should move the TTL as well} {\n        r del mykey{t} mykey2{t}\n        r set mykey{t} foo\n        r expire mykey{t} 100\n        assert {[r ttl mykey{t}] > 95 && [r ttl mykey{t}] <= 100}\n        r rename mykey{t} mykey2{t}\n        assert {[r ttl mykey2{t}] > 95 && [r ttl mykey2{t}] <= 100}\n    }\n\n    test {RENAME with volatile key, should not inherit TTL of target key} {\n        r del mykey{t} mykey2{t}\n        r set mykey{t} foo\n        r set mykey2{t} bar\n        r expire mykey2{t} 100\n        assert {[r ttl mykey{t}] == -1 && [r ttl mykey2{t}] > 0}\n        r rename mykey{t} mykey2{t}\n        r ttl mykey2{t}\n    } {-1}\n\n    test {DEL all keys again (DB 0)} {\n        foreach key [r keys *] {\n            r del $key\n        }\n        r dbsize\n    } {0}\n\n    test {DEL all keys again (DB 1)} {\n        r select 10\n        foreach key [r keys *] {\n            r del $key\n        }\n        set res [r dbsize]\n        r select 9\n        format $res\n    } {0} {singledb:skip}\n\n    test {COPY basic usage for string} {\n        r set mykey{t} foobar\n        set res {}\n        r copy mykey{t} mynewkey{t}\n        lappend res [r get mynewkey{t}]\n        lappend res [r dbsize]\n        if {$::singledb} {\n            assert_equal [list foobar 2] [format $res]\n        } else {\n            r copy mykey{t} mynewkey{t} DB 10\n            r select 10\n            lappend res [r get mynewkey{t}]\n            lappend res [r dbsize]\n            r select 9\n            assert_equal [list foobar 2 foobar 1] [format $res]\n        }\n    } \n\n    test {COPY for string does not replace an existing key without REPLACE option} {\n        r set mykey2{t} hello\n        catch {r copy mykey2{t} mynewkey{t} DB 10} e\n        set e\n    } {0} {singledb:skip}\n\n    test {COPY for string can replace an existing key with REPLACE option} {\n        r copy mykey2{t} mynewkey{t} DB 10 REPLACE\n        r select 10\n        r get mynewkey{t}\n    } {hello} {singledb:skip}\n\n    test {COPY for string ensures that copied data is independent of copying data} {\n        r flushdb\n        r select 9\n        r set mykey{t} foobar\n        set res {}\n        r copy mykey{t} mynewkey{t} DB 10\n        r select 10\n        lappend res [r get mynewkey{t}]\n        r set mynewkey{t} hoge\n        lappend res [r get mynewkey{t}]\n        r select 9\n        lappend res [r get mykey{t}]\n        r select 10\n        r flushdb\n        r select 9\n        format $res\n    } [list foobar hoge foobar] {singledb:skip}\n\n    test {COPY for string does not copy data to no-integer DB} {\n        r set mykey{t} foobar\n        catch {r copy mykey{t} mynewkey{t} DB notanumber} e\n        set e\n    } {ERR value is not an integer or out of range}\n\n    test {COPY can copy key expire metadata as well} {\n        r set mykey{t} foobar ex 100\n        r copy mykey{t} mynewkey{t} REPLACE\n        assert {[r ttl mynewkey{t}] > 0 && [r ttl mynewkey{t}] <= 100}\n        assert {[r get mynewkey{t}] eq \"foobar\"}\n    }\n\n    test {COPY does not create an expire if it does not exist} {\n        r set mykey{t} foobar\n        assert {[r ttl mykey{t}] == -1}\n        r copy mykey{t} mynewkey{t} REPLACE\n        assert {[r ttl mynewkey{t}] == -1}\n        assert {[r get mynewkey{t}] eq \"foobar\"}\n    }\n\nsource \"tests/unit/type/list-common.tcl\"\nforeach {type large} [array get largevalue] {\n    set origin_config [config_get_set list-max-listpack-size -1]\n    test \"COPY basic usage for list - $type\" {\n        r del mylist{t} mynewlist{t}\n        r lpush mylist{t} a b $large c d\n        assert_encoding $type mylist{t}\n        r copy mylist{t} mynewlist{t}\n        assert_encoding $type mynewlist{t}\n        set digest [debug_digest_value mylist{t}]\n        assert_equal $digest [debug_digest_value mynewlist{t}]\n        assert_refcount 1 mylist{t}\n        assert_refcount 1 mynewlist{t}\n        r del mylist{t}\n        assert_equal $digest [debug_digest_value mynewlist{t}]\n    }\n    config_set list-max-listpack-size $origin_config\n}\n\n    foreach type {intset listpack hashtable} {\n        test {COPY basic usage for $type set} {\n            r del set1{t} newset1{t}\n            r sadd set1{t} 1 2 3\n            if {$type ne \"intset\"} {\n                r sadd set1{t} a\n            }\n            if {$type eq \"hashtable\"} {\n                for {set i 4} {$i < 200} {incr i} {\n                    r sadd set1{t} $i\n                }\n            }\n            assert_encoding $type set1{t}\n            r copy set1{t} newset1{t}\n            set digest [debug_digest_value set1{t}]\n            assert_equal $digest [debug_digest_value newset1{t}]\n            assert_refcount 1 set1{t}\n            assert_refcount 1 newset1{t}\n            r del set1{t}\n            assert_equal $digest [debug_digest_value newset1{t}]\n        }\n    }\n\n    test {COPY basic usage for listpack sorted set} {\n        r del zset1{t} newzset1{t}\n        r zadd zset1{t} 123 foobar\n        assert_encoding listpack zset1{t}\n        r copy zset1{t} newzset1{t}\n        set digest [debug_digest_value zset1{t}]\n        assert_equal $digest [debug_digest_value newzset1{t}]\n        assert_refcount 1 zset1{t}\n        assert_refcount 1 newzset1{t}\n        r del zset1{t}\n        assert_equal $digest [debug_digest_value newzset1{t}]\n    }\n\n     test {COPY basic usage for skiplist sorted set} {\n        r del zset2{t} newzset2{t}\n        set original_max [lindex [r config get zset-max-ziplist-entries] 1]\n        r config set zset-max-ziplist-entries 0\n        for {set j 0} {$j < 130} {incr j} {\n            r zadd zset2{t} [randomInt 50] ele-[randomInt 10]\n        }\n        assert_encoding skiplist zset2{t}\n        r copy zset2{t} newzset2{t}\n        set digest [debug_digest_value zset2{t}]\n        assert_equal $digest [debug_digest_value newzset2{t}]\n        assert_refcount 1 zset2{t}\n        assert_refcount 1 newzset2{t}\n        r del zset2{t}\n        assert_equal $digest [debug_digest_value newzset2{t}]\n        r config set zset-max-ziplist-entries $original_max\n    }\n\n    test {COPY basic usage for listpack hash} {\n        r del hash1{t} newhash1{t}\n        r hset hash1{t} tmp 17179869184\n        assert_encoding listpack hash1{t}\n        r copy hash1{t} newhash1{t}\n        set digest [debug_digest_value hash1{t}]\n        assert_equal $digest [debug_digest_value newhash1{t}]\n        assert_refcount 1 hash1{t}\n        assert_refcount 1 newhash1{t}\n        r del hash1{t}\n        assert_equal $digest [debug_digest_value newhash1{t}]\n    }\n\n    test {COPY basic usage for hashtable hash} {\n        r del hash2{t} newhash2{t}\n        set original_max [lindex [r config get hash-max-ziplist-entries] 1]\n        r config set hash-max-ziplist-entries 0\n        for {set i 0} {$i < 64} {incr i} {\n            r hset hash2{t} [randomValue] [randomValue]\n        }\n        assert_encoding hashtable hash2{t}\n        r copy hash2{t} newhash2{t}\n        set digest [debug_digest_value hash2{t}]\n        assert_equal $digest [debug_digest_value newhash2{t}]\n        assert_refcount 1 hash2{t}\n        assert_refcount 1 newhash2{t}\n        r del hash2{t}\n        assert_equal $digest [debug_digest_value newhash2{t}]\n        r config set hash-max-ziplist-entries $original_max\n    }\n\n    test {COPY basic usage for stream} {\n        r del mystream{t} mynewstream{t}\n        for {set i 0} {$i < 1000} {incr i} {\n            r XADD mystream{t} * item 2 value b\n        }\n        r copy mystream{t} mynewstream{t}\n        set digest [debug_digest_value mystream{t}]\n        assert_equal $digest [debug_digest_value mynewstream{t}]\n        assert_refcount 1 mystream{t}\n        assert_refcount 1 mynewstream{t}\n        r del mystream{t}\n        assert_equal $digest [debug_digest_value mynewstream{t}]\n    }\n\n    test {COPY basic usage for stream-cgroups} {\n        r del x{t}\n        r XADD x{t} 100 a 1\n        set id [r XADD x{t} 101 b 1]\n        r XADD x{t} 102 c 1\n        r XADD x{t} 103 e 1\n        r XADD x{t} 104 f 1\n        r XADD x{t} 105 g 1\n        r XGROUP CREATE x{t} g1 0\n        r XGROUP CREATE x{t} g2 0\n        r XREADGROUP GROUP g1 Alice COUNT 1 STREAMS x{t} >\n        r XREADGROUP GROUP g1 Bob COUNT 1 STREAMS x{t} >\n        r XREADGROUP GROUP g1 Bob NOACK COUNT 1 STREAMS x{t} >\n        r XREADGROUP GROUP g2 Charlie COUNT 4 STREAMS x{t} >\n        r XGROUP SETID x{t} g1 $id\n        r XREADGROUP GROUP g1 Dave COUNT 3 STREAMS x{t} >\n        r XDEL x{t} 103\n\n        r copy x{t} newx{t}\n        set info [r xinfo stream x{t} full]\n        assert_equal $info [r xinfo stream newx{t} full]\n        assert_refcount 1 x{t}\n        assert_refcount 1 newx{t}\n        r del x{t}\n        assert_equal $info [r xinfo stream newx{t} full]\n        r flushdb\n    }\n\n    test {MOVE basic usage} {\n        r set mykey foobar\n        r move mykey 10\n        set res {}\n        lappend res [r exists mykey]\n        lappend res [r dbsize]\n        r select 10\n        lappend res [r get mykey]\n        lappend res [r dbsize]\n        r select 9\n        format $res\n    } [list 0 0 foobar 1] {singledb:skip}\n\n    test {MOVE against key existing in the target DB} {\n        r set mykey hello\n        r move mykey 10\n    } {0} {singledb:skip}\n\n    test {MOVE against non-integer DB (#1428)} {\n        r set mykey hello\n        catch {r move mykey notanumber} e\n        set e\n    } {ERR value is not an integer or out of range} {singledb:skip}\n\n    test {MOVE can move key expire metadata as well} {\n        r select 10\n        r flushdb\n        r select 9\n        r set mykey foo ex 100\n        r move mykey 10\n        assert {[r ttl mykey] == -2}\n        r select 10\n        assert {[r ttl mykey] > 0 && [r ttl mykey] <= 100}\n        assert {[r get mykey] eq \"foo\"}\n        r select 9\n    } {OK} {singledb:skip}\n\n    test {MOVE does not create an expire if it does not exist} {\n        r select 10\n        r flushdb\n        r select 9\n        r set mykey foo\n        r move mykey 10\n        assert {[r ttl mykey] == -2}\n        r select 10\n        assert {[r ttl mykey] == -1}\n        assert {[r get mykey] eq \"foo\"}\n        r select 9\n    } {OK} {singledb:skip}\n\n    test {SET/GET keys in different DBs} {\n        r set a hello\n        r set b world\n        r select 10\n        r set a foo\n        r set b bared\n        r select 9\n        set res {}\n        lappend res [r get a]\n        lappend res [r get b]\n        r select 10\n        lappend res [r get a]\n        lappend res [r get b]\n        r select 9\n        format $res\n    } {hello world foo bared} {singledb:skip}\n\n    test {RANDOMKEY} {\n        r flushdb\n        r set foo x\n        r set bar y\n        set foo_seen 0\n        set bar_seen 0\n        for {set i 0} {$i < 100} {incr i} {\n            set rkey [r randomkey]\n            if {$rkey eq {foo}} {\n                set foo_seen 1\n            }\n            if {$rkey eq {bar}} {\n                set bar_seen 1\n            }\n        }\n        list $foo_seen $bar_seen\n    } {1 1}\n\n    test {RANDOMKEY against empty DB} {\n        r flushdb\n        r randomkey\n    } {}\n\n    test {RANDOMKEY regression 1} {\n        r flushdb\n        r set x 10\n        r del x\n        r randomkey\n    } {}\n\n    test {KEYS * two times with long key, Github issue #1208} {\n        r flushdb\n        r set dlskeriewrioeuwqoirueioqwrueoqwrueqw test\n        r keys *\n        r keys *\n    } {dlskeriewrioeuwqoirueioqwrueoqwrueqw}\n\n    test {Regression for pattern matching long nested loops} {\n        r flushdb\n        r SET aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 1\n        r KEYS \"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*b\"\n    } {}\n}\n"], "filenames": ["src/util.c", "tests/unit/keyspace.tcl"], "buggy_code_start_loc": [56, 495], "buggy_code_end_loc": [173, 495], "fixing_code_start_loc": [56, 496], "fixing_code_end_loc": [193, 502], "type": "CWE-407", "message": "Redis is an in-memory database that persists on disk. Authenticated users can use string matching commands (like `SCAN` or `KEYS`) with a specially crafted pattern to trigger a denial-of-service attack on Redis, causing it to hang and consume 100% CPU time. The problem is fixed in Redis versions 6.0.18, 6.2.11, 7.0.9.", "other": {"cve": {"id": "CVE-2022-36021", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-01T16:15:09.400", "lastModified": "2023-03-09T01:07:23.580", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Redis is an in-memory database that persists on disk. Authenticated users can use string matching commands (like `SCAN` or `KEYS`) with a specially crafted pattern to trigger a denial-of-service attack on Redis, causing it to hang and consume 100% CPU time. The problem is fixed in Redis versions 6.0.18, 6.2.11, 7.0.9."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-407"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-407"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redis:redis:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.0.18", "matchCriteriaId": "6F70AB47-0452-4438-87FC-6CBD440815EF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redis:redis:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.2.0", "versionEndExcluding": "6.2.11", "matchCriteriaId": "F953DA13-66E1-4983-9744-F861931E8628"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redis:redis:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0", "versionEndExcluding": "7.0.9", "matchCriteriaId": "BB0A4E48-9EF2-4F32-B72C-7F243EC31DB2"}]}]}], "references": [{"url": "https://github.com/redis/redis/commit/dcbfcb916ca1a269b3feef86ee86835294758f84", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/redis/redis/security/advisories/GHSA-jr7j-rfj5-8xqv", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/redis/redis/commit/dcbfcb916ca1a269b3feef86ee86835294758f84"}}