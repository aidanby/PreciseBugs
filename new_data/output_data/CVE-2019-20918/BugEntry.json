{"buggy_code": ["/*\n * InspIRCd -- Internet Relay Chat Daemon\n *\n *   Copyright (C) 2019 Peter Powell <petpow@saberuk.com>\n *\n * This file is part of InspIRCd.  InspIRCd is free software: you can\n * redistribute it and/or modify it under the terms of the GNU General Public\n * License as published by the Free Software Foundation, version 2.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n\n#include \"inspircd.h\"\n#include \"modules/ctctags.h\"\n\nenum\n{\n\t// From ircu?\n\tRPL_SILELIST = 271,\n\tRPL_ENDOFSILELIST = 272,\n\tERR_SILELISTFULL = 511,\n\n\t// InspIRCd-specific.\n\tERR_SILENCE = 952\n};\n\nclass SilenceEntry\n{\n public:\n\tenum SilenceFlags\n\t{\n\t\t// Does nothing; for internal use only.\n\t\tSF_NONE = 0,\n\n\t\t// Exclude users who match this flags (\"x\").\n\t\tSF_EXEMPT = 1,\n\n\t\t// 2, 4, 8, 16 are reserved for future use.\n\n\t\t// Matches a NOTICE targeted at a channel (\"n\").\n\t\tSF_NOTICE_CHANNEL = 32,\n\n\t\t// Matches a NOTICE targeted at a user (\"N\").\n\t\tSF_NOTICE_USER = 64,\n\n\t\t// Matches a PRIVMSG targeted at a channel (\"p\").\n\t\tSF_PRIVMSG_CHANNEL = 128,\n\n\t\t// Matches a PRIVMSG targeted at a user (\"P\").\n\t\tSF_PRIVMSG_USER = 256,\n\n\t\t// Matches a TAGMSG targeted at a channel (\"t\").\n\t\tSF_TAGMSG_CHANNEL = 512,\n\n\t\t// Matches a TAGMSG targeted at a user (\"T\").\n\t\tSF_TAGMSG_USER = 1024,\n\n\t\t// Matches a CTCP targeted at a channel (\"c\").\n\t\tSF_CTCP_CHANNEL = 2048,\n\n\t\t// Matches a CTCP targeted at a user (\"C\").\n\t\tSF_CTCP_USER = 4096,\n\n\t\t// Matches an invite to a channel (\"i\").\n\t\tSF_INVITE = 8192,\n\n\t\t// The default if no flags have been specified.\n\t\tSF_DEFAULT = SF_NOTICE_CHANNEL | SF_NOTICE_USER | SF_PRIVMSG_CHANNEL | SF_PRIVMSG_USER | SF_TAGMSG_CHANNEL |\n\t\t\tSF_TAGMSG_USER | SF_CTCP_CHANNEL | SF_CTCP_USER | SF_INVITE\n\t};\n\n\t// The flags that this mask is silenced for.\n\tuint32_t flags;\n\n\t// The mask which is silenced (e.g. *!*@example.com).\n\tstd::string mask;\n\n\tSilenceEntry(uint32_t Flags, const std::string& Mask)\n\t\t: flags(Flags)\n\t\t, mask(Mask)\n\t{\n\t}\n\n\tbool operator <(const SilenceEntry& other) const\n\t{\n\t\tif (flags & SF_EXEMPT && other.flags & ~SF_EXEMPT)\n\t\t\treturn true;\n\t\tif (other.flags & SF_EXEMPT && flags & ~SF_EXEMPT)\n\t\t\treturn false;\n\t\tif (flags < other.flags)\n\t\t\treturn true;\n\t\tif (other.flags < flags)\n\t\t\treturn false;\n\t\treturn mask < other.mask;\n\t}\n\n\t// Converts a flag list to a bitmask.\n\tstatic bool FlagsToBits(const std::string& flags, uint32_t& out)\n\t{\n\t\tout = SF_NONE;\n\t\tfor (std::string::const_iterator flag = flags.begin(); flag != flags.end(); ++flag)\n\t\t{\n\t\t\tswitch (*flag)\n\t\t\t{\n\t\t\t\tcase 'C':\n\t\t\t\t\tout |= SF_CTCP_USER;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'c':\n\t\t\t\t\tout |= SF_CTCP_CHANNEL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd':\n\t\t\t\t\tout |= SF_DEFAULT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'i':\n\t\t\t\t\tout |= SF_INVITE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'N':\n\t\t\t\t\tout |= SF_NOTICE_USER;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'n':\n\t\t\t\t\tout |= SF_NOTICE_CHANNEL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'P':\n\t\t\t\t\tout |= SF_PRIVMSG_USER;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p':\n\t\t\t\t\tout |= SF_PRIVMSG_CHANNEL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'T':\n\t\t\t\t\tout |= SF_TAGMSG_USER;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 't':\n\t\t\t\t\tout |= SF_TAGMSG_CHANNEL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'x':\n\t\t\t\t\tout |= SF_EXEMPT;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tout = SF_NONE;\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t// Converts a bitmask to a flag list.\n\tstatic std::string BitsToFlags(uint32_t flags)\n\t{\n\t\tstd::string out;\n\t\tif (flags & SF_CTCP_USER)\n\t\t\tout.push_back('C');\n\t\tif (flags & SF_CTCP_CHANNEL)\n\t\t\tout.push_back('c');\n\t\tif (flags & SF_INVITE)\n\t\t\tout.push_back('i');\n\t\tif (flags & SF_NOTICE_USER)\n\t\t\tout.push_back('N');\n\t\tif (flags & SF_NOTICE_CHANNEL)\n\t\t\tout.push_back('n');\n\t\tif (flags & SF_PRIVMSG_USER)\n\t\t\tout.push_back('P');\n\t\tif (flags & SF_PRIVMSG_CHANNEL)\n\t\t\tout.push_back('p');\n\t\tif (flags & SF_TAGMSG_CHANNEL)\n\t\t\tout.push_back('T');\n\t\tif (flags & SF_TAGMSG_USER)\n\t\t\tout.push_back('t');\n\t\tif (flags & SF_EXEMPT)\n\t\t\tout.push_back('x');\n\t\treturn out;\n\t}\n};\n\ntypedef insp::flat_set<SilenceEntry> SilenceList;\n\nclass SilenceMessage : public ClientProtocol::Message\n{\n public:\n\tSilenceMessage(const std::string& mask, const std::string& flags)\n\t\t: ClientProtocol::Message(\"SILENCE\")\n\t{\n\t\tPushParam(mask);\n\t\tPushParamRef(flags);\n\t}\n};\n\nclass CommandSilence : public SplitCommand\n{\n private:\n\tClientProtocol::EventProvider msgprov;\n\n\tCmdResult AddSilence(LocalUser* user, const std::string& mask, uint32_t flags)\n\t{\n\t\tSilenceList* list = ext.get(user);\n\t\tif (list && list->size() > maxsilence)\n\t\t{\n\t\t\tuser->WriteNumeric(ERR_SILELISTFULL, mask, SilenceEntry::BitsToFlags(flags), \"Your SILENCE list is full\");\n\t\t\treturn CMD_FAILURE;\n\t\t}\n\t\telse if (!list)\n\t\t{\n\t\t\t// There is no list; create it.\n\t\t\tlist = new SilenceList();\n\t\t\text.set(user, list);\n\t\t}\n\n\t\tif (!list->insert(SilenceEntry(flags, mask)).second)\n\t\t{\n\t\t\tuser->WriteNumeric(ERR_SILENCE, mask, SilenceEntry::BitsToFlags(flags), \"The SILENCE entry you specified already exists\");\n\t\t\treturn CMD_FAILURE;\n\t\t}\n\n\t\tSilenceMessage msg(\"+\" + mask, SilenceEntry::BitsToFlags(flags));\n\t\tuser->Send(msgprov, msg);\n\t\treturn CMD_SUCCESS;\n\t}\n\n\tCmdResult RemoveSilence(LocalUser* user, const std::string& mask, uint32_t flags)\n\t{\n\t\tSilenceList* list = ext.get(user);\n\t\tif (list)\n\t\t{\n\t\t\tfor (SilenceList::iterator iter = list->begin(); iter != list->end(); ++iter)\n\t\t\t{\n\t\t\t\tif (!irc::equals(iter->mask, mask) || iter->flags != flags)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tlist->erase(iter);\n\t\t\t\tSilenceMessage msg(\"-\" + mask, SilenceEntry::BitsToFlags(flags));\n\t\t\t\tuser->Send(msgprov, msg);\n\t\t\t\treturn CMD_SUCCESS;\n\t\t\t}\n\t\t}\n\n\t\tuser->WriteNumeric(ERR_SILENCE, mask, SilenceEntry::BitsToFlags(flags), \"The SILENCE entry you specified could not be found\");\n\t\treturn CMD_FAILURE;\n\t}\n\n\tCmdResult ShowSilenceList(LocalUser* user)\n\t{\n\t\tSilenceList* list = ext.get(user);\n\t\tif (list)\n\t\t{\n\t\t\tfor (SilenceList::const_iterator iter = list->begin(); iter != list->end(); ++iter)\n\t\t\t{\n\t\t\t\tuser->WriteNumeric(RPL_SILELIST, iter->mask, SilenceEntry::BitsToFlags(iter->flags));\n\t\t\t}\n\t\t}\n\t\tuser->WriteNumeric(RPL_ENDOFSILELIST, \"End of SILENCE list\");\n\t\treturn CMD_SUCCESS;\n\t}\n\n public:\n\tSimpleExtItem<SilenceList> ext;\n\tunsigned int maxsilence;\n\n\tCommandSilence(Module* Creator)\n\t\t: SplitCommand(Creator, \"SILENCE\")\n\t\t, msgprov(Creator, \"SILENCE\")\n\t\t, ext(\"silence_list\", ExtensionItem::EXT_USER, Creator)\n\t{\n\t\tallow_empty_last_param = false;\n\t\tsyntax = \"[(+|-)<mask> [CcdiNnPpTtx]]\";\n\t}\n\n\tCmdResult HandleLocal(LocalUser* user, const Params& parameters) CXX11_OVERRIDE\n\t{\n\t\tif (parameters.empty())\n\t\t\treturn ShowSilenceList(user);\n\n\t\t// If neither add nor remove are specified we default to add.\n\t\tbool is_remove = parameters[0][0] == '-';\n\n\t\t// If a prefix mask has been given then strip it and clean it up.\n\t\tstd::string mask = parameters[0];\n\t\tif (mask[0] == '-' || mask[0] == '+')\n\t\t{\n\t\t\tmask.erase(0);\n\t\t\tif (mask.empty())\n\t\t\t\tmask.assign(\"*\");\n\t\t\tModeParser::CleanMask(mask);\n\t\t}\n\n\t\t// If the user specified a flags then use that. Otherwise, default to blocking\n\t\t// all CTCPs, invites, notices, privmsgs, and invites.\n\t\tuint32_t flags = SilenceEntry::SF_DEFAULT;\n\t\tif (parameters.size() > 1)\n\t\t{\n\t\t\tif (!SilenceEntry::FlagsToBits(parameters[1], flags))\n\t\t\t{\n\t\t\t\tuser->WriteNumeric(ERR_SILENCE, mask, parameters[1], \"You specified one or more invalid SILENCE flags\");\n\t\t\t\treturn CMD_FAILURE;\n\t\t\t}\n\t\t\telse if (flags == SilenceEntry::SF_EXEMPT)\n\t\t\t{\n\t\t\t\t// The user specified \"x\" with no other flags which does not make sense; add the \"d\" flag.\n\t\t\t\tflags |= SilenceEntry::SF_DEFAULT;\n\t\t\t}\n\t\t}\n\n\t\treturn is_remove ? RemoveSilence(user, mask, flags) : AddSilence(user, mask, flags);\n\t}\n};\n\nclass ModuleSilence\n\t: public Module\n\t, public CTCTags::EventListener\n{\n private:\n\tbool exemptuline;\n\tCommandSilence cmd;\n\n\tModResult BuildChannelExempts(User* source, Channel* channel, SilenceEntry::SilenceFlags flag, CUList& exemptions)\n\t{\n\t\tconst Channel::MemberMap& members = channel->GetUsers();\n\t\tfor (Channel::MemberMap::const_iterator member = members.begin(); member != members.end(); ++member)\n\t\t{\n\t\t\tif (!CanReceiveMessage(source, member->first, flag))\n\t\t\t\texemptions.insert(member->first);\n\t\t}\n\t\treturn MOD_RES_PASSTHRU;\n\t}\n\n\tbool CanReceiveMessage(User* source, User* target, SilenceEntry::SilenceFlags flag)\n\t{\n\t\t// Servers handle their own clients.\n\t\tif (!IS_LOCAL(target))\n\t\t\treturn true;\n\n\t\tif (exemptuline && source->server->IsULine())\n\t\t\treturn true;\n\n\t\tSilenceList* list = cmd.ext.get(target);\n\t\tif (!list)\n\t\t\treturn true;\n\n\t\tfor (SilenceList::iterator iter = list->begin(); iter != list->end(); ++iter)\n\t\t{\n\t\t\tif (!(iter->flags & flag))\n\t\t\t\tcontinue;\n\n\t\t\tif (InspIRCd::Match(source->GetFullHost(), iter->mask))\n\t\t\t\treturn iter->flags & SilenceEntry::SF_EXEMPT;\n\t\t}\n\n\t\treturn true;\n\t}\n\n public:\n\tModuleSilence()\n\t\t: CTCTags::EventListener(this)\n\t\t, cmd(this)\n\t{\n\t}\n\n\tvoid ReadConfig(ConfigStatus& status) CXX11_OVERRIDE\n\t{\n\t\tConfigTag* tag = ServerInstance->Config->ConfValue(\"silence\");\n\t\texemptuline = tag->getBool(\"exemptuline\", true);\n\t\tcmd.maxsilence = tag->getUInt(\"maxentries\", 32, 1);\n\t}\n\n\tvoid On005Numeric(std::map<std::string, std::string>& tokens) CXX11_OVERRIDE\n\t{\n\t\ttokens[\"ESILENCE\"] = \"CcdiNnPpTtx\";\n\t\ttokens[\"SILENCE\"] = ConvToStr(cmd.maxsilence);\n\t}\n\n\tModResult OnUserPreInvite(User* source, User* dest, Channel* channel, time_t timeout) CXX11_OVERRIDE\n\t{\n\t\treturn CanReceiveMessage(source, dest, SilenceEntry::SF_INVITE) ? MOD_RES_PASSTHRU : MOD_RES_DENY;\n\t}\n\n\tModResult OnUserPreMessage(User* user, const MessageTarget& target, MessageDetails& details) CXX11_OVERRIDE\n\t{\n\t\tstd::string ctcpname;\n\t\tbool is_ctcp = details.IsCTCP(ctcpname) && !irc::equals(ctcpname, \"ACTION\");\n\n\t\tSilenceEntry::SilenceFlags flag = SilenceEntry::SF_NONE;\n\t\tif (target.type == MessageTarget::TYPE_CHANNEL)\n\t\t{\n\t\t\tif (is_ctcp)\n\t\t\t\tflag = SilenceEntry::SF_CTCP_CHANNEL;\n\t\t\telse if (details.type == MSG_NOTICE)\n\t\t\t\tflag = SilenceEntry::SF_NOTICE_CHANNEL;\n\t\t\telse if (details.type == MSG_PRIVMSG)\n\t\t\t\tflag = SilenceEntry::SF_PRIVMSG_CHANNEL;\n\n\t\t\treturn BuildChannelExempts(user, target.Get<Channel>(), flag, details.exemptions);\n\t\t}\n\n\t\tif (target.type == MessageTarget::TYPE_USER)\n\t\t{\n\t\t\tif (is_ctcp)\n\t\t\t\tflag = SilenceEntry::SF_CTCP_USER;\n\t\t\telse if (details.type == MSG_NOTICE)\n\t\t\t\tflag = SilenceEntry::SF_NOTICE_USER;\n\t\t\telse if (details.type == MSG_PRIVMSG)\n\t\t\t\tflag = SilenceEntry::SF_PRIVMSG_USER;\n\n\t\t\tif (!CanReceiveMessage(user, target.Get<User>(), flag))\n\t\t\t{\n\t\t\t\tdetails.echo_original = true;\n\t\t\t\treturn MOD_RES_DENY;\n\t\t\t}\n\t\t}\n\n\t\treturn MOD_RES_PASSTHRU;\n\t}\n\n\tModResult OnUserPreTagMessage(User* user, const MessageTarget& target, CTCTags::TagMessageDetails& details) CXX11_OVERRIDE\n\t{\n\t\tif (target.type == MessageTarget::TYPE_CHANNEL)\n\t\t\treturn BuildChannelExempts(user, target.Get<Channel>(), SilenceEntry::SF_TAGMSG_CHANNEL, details.exemptions);\n\n\t\tif (target.type == MessageTarget::TYPE_USER && !CanReceiveMessage(user, target.Get<User>(), SilenceEntry::SF_TAGMSG_USER))\n\t\t{\n\t\t\tdetails.echo_original = true;\n\t\t\treturn MOD_RES_DENY;\n\t\t}\n\n\t\treturn MOD_RES_PASSTHRU;\n\t}\n\n\tVersion GetVersion() CXX11_OVERRIDE\n\t{\n\t\treturn Version(\"Provides support for blocking users with the SILENCE command\", VF_OPTCOMMON | VF_VENDOR);\n\t}\n};\n\nMODULE_INIT(ModuleSilence)\n"], "fixing_code": ["/*\n * InspIRCd -- Internet Relay Chat Daemon\n *\n *   Copyright (C) 2019 Peter Powell <petpow@saberuk.com>\n *\n * This file is part of InspIRCd.  InspIRCd is free software: you can\n * redistribute it and/or modify it under the terms of the GNU General Public\n * License as published by the Free Software Foundation, version 2.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n\n#include \"inspircd.h\"\n#include \"modules/ctctags.h\"\n\nenum\n{\n\t// From ircu?\n\tRPL_SILELIST = 271,\n\tRPL_ENDOFSILELIST = 272,\n\tERR_SILELISTFULL = 511,\n\n\t// InspIRCd-specific.\n\tERR_SILENCE = 952\n};\n\nclass SilenceEntry\n{\n public:\n\tenum SilenceFlags\n\t{\n\t\t// Does nothing; for internal use only.\n\t\tSF_NONE = 0,\n\n\t\t// Exclude users who match this flags (\"x\").\n\t\tSF_EXEMPT = 1,\n\n\t\t// 2, 4, 8, 16 are reserved for future use.\n\n\t\t// Matches a NOTICE targeted at a channel (\"n\").\n\t\tSF_NOTICE_CHANNEL = 32,\n\n\t\t// Matches a NOTICE targeted at a user (\"N\").\n\t\tSF_NOTICE_USER = 64,\n\n\t\t// Matches a PRIVMSG targeted at a channel (\"p\").\n\t\tSF_PRIVMSG_CHANNEL = 128,\n\n\t\t// Matches a PRIVMSG targeted at a user (\"P\").\n\t\tSF_PRIVMSG_USER = 256,\n\n\t\t// Matches a TAGMSG targeted at a channel (\"t\").\n\t\tSF_TAGMSG_CHANNEL = 512,\n\n\t\t// Matches a TAGMSG targeted at a user (\"T\").\n\t\tSF_TAGMSG_USER = 1024,\n\n\t\t// Matches a CTCP targeted at a channel (\"c\").\n\t\tSF_CTCP_CHANNEL = 2048,\n\n\t\t// Matches a CTCP targeted at a user (\"C\").\n\t\tSF_CTCP_USER = 4096,\n\n\t\t// Matches an invite to a channel (\"i\").\n\t\tSF_INVITE = 8192,\n\n\t\t// The default if no flags have been specified.\n\t\tSF_DEFAULT = SF_NOTICE_CHANNEL | SF_NOTICE_USER | SF_PRIVMSG_CHANNEL | SF_PRIVMSG_USER | SF_TAGMSG_CHANNEL |\n\t\t\tSF_TAGMSG_USER | SF_CTCP_CHANNEL | SF_CTCP_USER | SF_INVITE\n\t};\n\n\t// The flags that this mask is silenced for.\n\tuint32_t flags;\n\n\t// The mask which is silenced (e.g. *!*@example.com).\n\tstd::string mask;\n\n\tSilenceEntry(uint32_t Flags, const std::string& Mask)\n\t\t: flags(Flags)\n\t\t, mask(Mask)\n\t{\n\t}\n\n\tbool operator <(const SilenceEntry& other) const\n\t{\n\t\tif (flags & SF_EXEMPT && other.flags & ~SF_EXEMPT)\n\t\t\treturn true;\n\t\tif (other.flags & SF_EXEMPT && flags & ~SF_EXEMPT)\n\t\t\treturn false;\n\t\tif (flags < other.flags)\n\t\t\treturn true;\n\t\tif (other.flags < flags)\n\t\t\treturn false;\n\t\treturn mask < other.mask;\n\t}\n\n\t// Converts a flag list to a bitmask.\n\tstatic bool FlagsToBits(const std::string& flags, uint32_t& out)\n\t{\n\t\tout = SF_NONE;\n\t\tfor (std::string::const_iterator flag = flags.begin(); flag != flags.end(); ++flag)\n\t\t{\n\t\t\tswitch (*flag)\n\t\t\t{\n\t\t\t\tcase 'C':\n\t\t\t\t\tout |= SF_CTCP_USER;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'c':\n\t\t\t\t\tout |= SF_CTCP_CHANNEL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd':\n\t\t\t\t\tout |= SF_DEFAULT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'i':\n\t\t\t\t\tout |= SF_INVITE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'N':\n\t\t\t\t\tout |= SF_NOTICE_USER;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'n':\n\t\t\t\t\tout |= SF_NOTICE_CHANNEL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'P':\n\t\t\t\t\tout |= SF_PRIVMSG_USER;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p':\n\t\t\t\t\tout |= SF_PRIVMSG_CHANNEL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'T':\n\t\t\t\t\tout |= SF_TAGMSG_USER;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 't':\n\t\t\t\t\tout |= SF_TAGMSG_CHANNEL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'x':\n\t\t\t\t\tout |= SF_EXEMPT;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tout = SF_NONE;\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t// Converts a bitmask to a flag list.\n\tstatic std::string BitsToFlags(uint32_t flags)\n\t{\n\t\tstd::string out;\n\t\tif (flags & SF_CTCP_USER)\n\t\t\tout.push_back('C');\n\t\tif (flags & SF_CTCP_CHANNEL)\n\t\t\tout.push_back('c');\n\t\tif (flags & SF_INVITE)\n\t\t\tout.push_back('i');\n\t\tif (flags & SF_NOTICE_USER)\n\t\t\tout.push_back('N');\n\t\tif (flags & SF_NOTICE_CHANNEL)\n\t\t\tout.push_back('n');\n\t\tif (flags & SF_PRIVMSG_USER)\n\t\t\tout.push_back('P');\n\t\tif (flags & SF_PRIVMSG_CHANNEL)\n\t\t\tout.push_back('p');\n\t\tif (flags & SF_TAGMSG_CHANNEL)\n\t\t\tout.push_back('T');\n\t\tif (flags & SF_TAGMSG_USER)\n\t\t\tout.push_back('t');\n\t\tif (flags & SF_EXEMPT)\n\t\t\tout.push_back('x');\n\t\treturn out;\n\t}\n};\n\ntypedef insp::flat_set<SilenceEntry> SilenceList;\n\nclass SilenceMessage : public ClientProtocol::Message\n{\n public:\n\tSilenceMessage(const std::string& mask, const std::string& flags)\n\t\t: ClientProtocol::Message(\"SILENCE\")\n\t{\n\t\tPushParam(mask);\n\t\tPushParam(flags);\n\t}\n};\n\nclass CommandSilence : public SplitCommand\n{\n private:\n\tClientProtocol::EventProvider msgprov;\n\n\tCmdResult AddSilence(LocalUser* user, const std::string& mask, uint32_t flags)\n\t{\n\t\tSilenceList* list = ext.get(user);\n\t\tif (list && list->size() > maxsilence)\n\t\t{\n\t\t\tuser->WriteNumeric(ERR_SILELISTFULL, mask, SilenceEntry::BitsToFlags(flags), \"Your SILENCE list is full\");\n\t\t\treturn CMD_FAILURE;\n\t\t}\n\t\telse if (!list)\n\t\t{\n\t\t\t// There is no list; create it.\n\t\t\tlist = new SilenceList();\n\t\t\text.set(user, list);\n\t\t}\n\n\t\tif (!list->insert(SilenceEntry(flags, mask)).second)\n\t\t{\n\t\t\tuser->WriteNumeric(ERR_SILENCE, mask, SilenceEntry::BitsToFlags(flags), \"The SILENCE entry you specified already exists\");\n\t\t\treturn CMD_FAILURE;\n\t\t}\n\n\t\tSilenceMessage msg(\"+\" + mask, SilenceEntry::BitsToFlags(flags));\n\t\tuser->Send(msgprov, msg);\n\t\treturn CMD_SUCCESS;\n\t}\n\n\tCmdResult RemoveSilence(LocalUser* user, const std::string& mask, uint32_t flags)\n\t{\n\t\tSilenceList* list = ext.get(user);\n\t\tif (list)\n\t\t{\n\t\t\tfor (SilenceList::iterator iter = list->begin(); iter != list->end(); ++iter)\n\t\t\t{\n\t\t\t\tif (!irc::equals(iter->mask, mask) || iter->flags != flags)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tlist->erase(iter);\n\t\t\t\tSilenceMessage msg(\"-\" + mask, SilenceEntry::BitsToFlags(flags));\n\t\t\t\tuser->Send(msgprov, msg);\n\t\t\t\treturn CMD_SUCCESS;\n\t\t\t}\n\t\t}\n\n\t\tuser->WriteNumeric(ERR_SILENCE, mask, SilenceEntry::BitsToFlags(flags), \"The SILENCE entry you specified could not be found\");\n\t\treturn CMD_FAILURE;\n\t}\n\n\tCmdResult ShowSilenceList(LocalUser* user)\n\t{\n\t\tSilenceList* list = ext.get(user);\n\t\tif (list)\n\t\t{\n\t\t\tfor (SilenceList::const_iterator iter = list->begin(); iter != list->end(); ++iter)\n\t\t\t{\n\t\t\t\tuser->WriteNumeric(RPL_SILELIST, iter->mask, SilenceEntry::BitsToFlags(iter->flags));\n\t\t\t}\n\t\t}\n\t\tuser->WriteNumeric(RPL_ENDOFSILELIST, \"End of SILENCE list\");\n\t\treturn CMD_SUCCESS;\n\t}\n\n public:\n\tSimpleExtItem<SilenceList> ext;\n\tunsigned int maxsilence;\n\n\tCommandSilence(Module* Creator)\n\t\t: SplitCommand(Creator, \"SILENCE\")\n\t\t, msgprov(Creator, \"SILENCE\")\n\t\t, ext(\"silence_list\", ExtensionItem::EXT_USER, Creator)\n\t{\n\t\tallow_empty_last_param = false;\n\t\tsyntax = \"[(+|-)<mask> [CcdiNnPpTtx]]\";\n\t}\n\n\tCmdResult HandleLocal(LocalUser* user, const Params& parameters) CXX11_OVERRIDE\n\t{\n\t\tif (parameters.empty())\n\t\t\treturn ShowSilenceList(user);\n\n\t\t// If neither add nor remove are specified we default to add.\n\t\tbool is_remove = parameters[0][0] == '-';\n\n\t\t// If a prefix mask has been given then strip it and clean it up.\n\t\tstd::string mask = parameters[0];\n\t\tif (mask[0] == '-' || mask[0] == '+')\n\t\t{\n\t\t\tmask.erase(0);\n\t\t\tif (mask.empty())\n\t\t\t\tmask.assign(\"*\");\n\t\t\tModeParser::CleanMask(mask);\n\t\t}\n\n\t\t// If the user specified a flags then use that. Otherwise, default to blocking\n\t\t// all CTCPs, invites, notices, privmsgs, and invites.\n\t\tuint32_t flags = SilenceEntry::SF_DEFAULT;\n\t\tif (parameters.size() > 1)\n\t\t{\n\t\t\tif (!SilenceEntry::FlagsToBits(parameters[1], flags))\n\t\t\t{\n\t\t\t\tuser->WriteNumeric(ERR_SILENCE, mask, parameters[1], \"You specified one or more invalid SILENCE flags\");\n\t\t\t\treturn CMD_FAILURE;\n\t\t\t}\n\t\t\telse if (flags == SilenceEntry::SF_EXEMPT)\n\t\t\t{\n\t\t\t\t// The user specified \"x\" with no other flags which does not make sense; add the \"d\" flag.\n\t\t\t\tflags |= SilenceEntry::SF_DEFAULT;\n\t\t\t}\n\t\t}\n\n\t\treturn is_remove ? RemoveSilence(user, mask, flags) : AddSilence(user, mask, flags);\n\t}\n};\n\nclass ModuleSilence\n\t: public Module\n\t, public CTCTags::EventListener\n{\n private:\n\tbool exemptuline;\n\tCommandSilence cmd;\n\n\tModResult BuildChannelExempts(User* source, Channel* channel, SilenceEntry::SilenceFlags flag, CUList& exemptions)\n\t{\n\t\tconst Channel::MemberMap& members = channel->GetUsers();\n\t\tfor (Channel::MemberMap::const_iterator member = members.begin(); member != members.end(); ++member)\n\t\t{\n\t\t\tif (!CanReceiveMessage(source, member->first, flag))\n\t\t\t\texemptions.insert(member->first);\n\t\t}\n\t\treturn MOD_RES_PASSTHRU;\n\t}\n\n\tbool CanReceiveMessage(User* source, User* target, SilenceEntry::SilenceFlags flag)\n\t{\n\t\t// Servers handle their own clients.\n\t\tif (!IS_LOCAL(target))\n\t\t\treturn true;\n\n\t\tif (exemptuline && source->server->IsULine())\n\t\t\treturn true;\n\n\t\tSilenceList* list = cmd.ext.get(target);\n\t\tif (!list)\n\t\t\treturn true;\n\n\t\tfor (SilenceList::iterator iter = list->begin(); iter != list->end(); ++iter)\n\t\t{\n\t\t\tif (!(iter->flags & flag))\n\t\t\t\tcontinue;\n\n\t\t\tif (InspIRCd::Match(source->GetFullHost(), iter->mask))\n\t\t\t\treturn iter->flags & SilenceEntry::SF_EXEMPT;\n\t\t}\n\n\t\treturn true;\n\t}\n\n public:\n\tModuleSilence()\n\t\t: CTCTags::EventListener(this)\n\t\t, cmd(this)\n\t{\n\t}\n\n\tvoid ReadConfig(ConfigStatus& status) CXX11_OVERRIDE\n\t{\n\t\tConfigTag* tag = ServerInstance->Config->ConfValue(\"silence\");\n\t\texemptuline = tag->getBool(\"exemptuline\", true);\n\t\tcmd.maxsilence = tag->getUInt(\"maxentries\", 32, 1);\n\t}\n\n\tvoid On005Numeric(std::map<std::string, std::string>& tokens) CXX11_OVERRIDE\n\t{\n\t\ttokens[\"ESILENCE\"] = \"CcdiNnPpTtx\";\n\t\ttokens[\"SILENCE\"] = ConvToStr(cmd.maxsilence);\n\t}\n\n\tModResult OnUserPreInvite(User* source, User* dest, Channel* channel, time_t timeout) CXX11_OVERRIDE\n\t{\n\t\treturn CanReceiveMessage(source, dest, SilenceEntry::SF_INVITE) ? MOD_RES_PASSTHRU : MOD_RES_DENY;\n\t}\n\n\tModResult OnUserPreMessage(User* user, const MessageTarget& target, MessageDetails& details) CXX11_OVERRIDE\n\t{\n\t\tstd::string ctcpname;\n\t\tbool is_ctcp = details.IsCTCP(ctcpname) && !irc::equals(ctcpname, \"ACTION\");\n\n\t\tSilenceEntry::SilenceFlags flag = SilenceEntry::SF_NONE;\n\t\tif (target.type == MessageTarget::TYPE_CHANNEL)\n\t\t{\n\t\t\tif (is_ctcp)\n\t\t\t\tflag = SilenceEntry::SF_CTCP_CHANNEL;\n\t\t\telse if (details.type == MSG_NOTICE)\n\t\t\t\tflag = SilenceEntry::SF_NOTICE_CHANNEL;\n\t\t\telse if (details.type == MSG_PRIVMSG)\n\t\t\t\tflag = SilenceEntry::SF_PRIVMSG_CHANNEL;\n\n\t\t\treturn BuildChannelExempts(user, target.Get<Channel>(), flag, details.exemptions);\n\t\t}\n\n\t\tif (target.type == MessageTarget::TYPE_USER)\n\t\t{\n\t\t\tif (is_ctcp)\n\t\t\t\tflag = SilenceEntry::SF_CTCP_USER;\n\t\t\telse if (details.type == MSG_NOTICE)\n\t\t\t\tflag = SilenceEntry::SF_NOTICE_USER;\n\t\t\telse if (details.type == MSG_PRIVMSG)\n\t\t\t\tflag = SilenceEntry::SF_PRIVMSG_USER;\n\n\t\t\tif (!CanReceiveMessage(user, target.Get<User>(), flag))\n\t\t\t{\n\t\t\t\tdetails.echo_original = true;\n\t\t\t\treturn MOD_RES_DENY;\n\t\t\t}\n\t\t}\n\n\t\treturn MOD_RES_PASSTHRU;\n\t}\n\n\tModResult OnUserPreTagMessage(User* user, const MessageTarget& target, CTCTags::TagMessageDetails& details) CXX11_OVERRIDE\n\t{\n\t\tif (target.type == MessageTarget::TYPE_CHANNEL)\n\t\t\treturn BuildChannelExempts(user, target.Get<Channel>(), SilenceEntry::SF_TAGMSG_CHANNEL, details.exemptions);\n\n\t\tif (target.type == MessageTarget::TYPE_USER && !CanReceiveMessage(user, target.Get<User>(), SilenceEntry::SF_TAGMSG_USER))\n\t\t{\n\t\t\tdetails.echo_original = true;\n\t\t\treturn MOD_RES_DENY;\n\t\t}\n\n\t\treturn MOD_RES_PASSTHRU;\n\t}\n\n\tVersion GetVersion() CXX11_OVERRIDE\n\t{\n\t\treturn Version(\"Provides support for blocking users with the SILENCE command\", VF_OPTCOMMON | VF_VENDOR);\n\t}\n};\n\nMODULE_INIT(ModuleSilence)\n"], "filenames": ["src/modules/m_silence.cpp"], "buggy_code_start_loc": [190], "buggy_code_end_loc": [191], "fixing_code_start_loc": [190], "fixing_code_end_loc": [191], "type": "CWE-416", "message": "An issue was discovered in InspIRCd 3 before 3.1.0. The silence module contains a use after free vulnerability. This vulnerability can be used for remote crashing of an InspIRCd server by any user able to fully connect to a server.", "other": {"cve": {"id": "CVE-2019-20918", "sourceIdentifier": "cve@mitre.org", "published": "2020-09-11T05:15:12.543", "lastModified": "2020-09-15T14:33:10.983", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in InspIRCd 3 before 3.1.0. The silence module contains a use after free vulnerability. This vulnerability can be used for remote crashing of an InspIRCd server by any user able to fully connect to a server."}, {"lang": "es", "value": "Se detect\u00f3 un problema en InspIRCd versiones 3 anteriores a 3.1.0.&#xa0;El m\u00f3dulo silence contiene una vulnerabilidad de uso de la memoria previamente liberada.&#xa0;Esta vulnerabilidad puede ser usada para el bloqueo remoto de un servidor de InspIRCd por cualquier usuario que pueda conectarse completamente a un servidor"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:inspircd:inspircd:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0", "versionEndExcluding": "3.1.0", "matchCriteriaId": "E7252B02-D3A7-4A49-B75C-5AE808A062D0"}]}]}], "references": [{"url": "https://docs.inspircd.org/security/2019-01/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/inspircd/inspircd/commit/7b47de3c194f239c5fea09a0e49696c9af017d51", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/inspircd/inspircd/commit/bcd65de1ec4bb71591ae417fee649d7ecd37cd57", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/inspircd/inspircd/commit/7b47de3c194f239c5fea09a0e49696c9af017d51"}}