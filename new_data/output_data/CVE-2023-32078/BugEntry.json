{"buggy_code": ["package controller\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/gravitl/netmaker/auth\"\n\t\"github.com/gravitl/netmaker/logger\"\n\t\"github.com/gravitl/netmaker/logic\"\n\t\"github.com/gravitl/netmaker/models\"\n\t\"github.com/gravitl/netmaker/servercfg\"\n)\n\nvar (\n\tupgrader = websocket.Upgrader{}\n)\n\nfunc userHandlers(r *mux.Router) {\n\n\tr.HandleFunc(\"/api/users/adm/hasadmin\", hasAdmin).Methods(http.MethodGet)\n\tr.HandleFunc(\"/api/users/adm/createadmin\", createAdmin).Methods(http.MethodPost)\n\tr.HandleFunc(\"/api/users/adm/authenticate\", authenticateUser).Methods(http.MethodPost)\n\tr.HandleFunc(\"/api/users/{username}\", logic.SecurityCheck(false, logic.ContinueIfUserMatch(http.HandlerFunc(updateUser)))).Methods(http.MethodPut)\n\tr.HandleFunc(\"/api/users/networks/{username}\", logic.SecurityCheck(true, http.HandlerFunc(updateUserNetworks))).Methods(http.MethodPut)\n\tr.HandleFunc(\"/api/users/{username}/adm\", logic.SecurityCheck(true, http.HandlerFunc(updateUserAdm))).Methods(http.MethodPut)\n\tr.HandleFunc(\"/api/users/{username}\", logic.SecurityCheck(true, checkFreeTierLimits(users_l, http.HandlerFunc(createUser)))).Methods(http.MethodPost)\n\tr.HandleFunc(\"/api/users/{username}\", logic.SecurityCheck(true, http.HandlerFunc(deleteUser))).Methods(http.MethodDelete)\n\tr.HandleFunc(\"/api/users/{username}\", logic.SecurityCheck(false, logic.ContinueIfUserMatch(http.HandlerFunc(getUser)))).Methods(http.MethodGet)\n\tr.HandleFunc(\"/api/users\", logic.SecurityCheck(true, http.HandlerFunc(getUsers))).Methods(http.MethodGet)\n\tr.HandleFunc(\"/api/oauth/login\", auth.HandleAuthLogin).Methods(http.MethodGet)\n\tr.HandleFunc(\"/api/oauth/callback\", auth.HandleAuthCallback).Methods(http.MethodGet)\n\tr.HandleFunc(\"/api/oauth/node-handler\", socketHandler)\n\tr.HandleFunc(\"/api/oauth/headless\", auth.HandleHeadlessSSO)\n\tr.HandleFunc(\"/api/oauth/register/{regKey}\", auth.RegisterNodeSSO).Methods(http.MethodGet)\n}\n\n// swagger:route POST /api/users/adm/authenticate user authenticateUser\n//\n// Node authenticates using its password and retrieves a JWT for authorization.\n//\n//\t\t\tSchemes: https\n//\n//\t\t\tSecurity:\n//\t  \t\toauth\n//\n//\t\t\tResponses:\n//\t\t\t\t200: successResponse\nfunc authenticateUser(response http.ResponseWriter, request *http.Request) {\n\n\t// Auth request consists of Mac Address and Password (from node that is authorizing\n\t// in case of Master, auth is ignored and mac is set to \"mastermac\"\n\tvar authRequest models.UserAuthParams\n\tvar errorResponse = models.ErrorResponse{\n\t\tCode: http.StatusInternalServerError, Message: \"W1R3: It's not you it's me.\",\n\t}\n\n\tif !servercfg.IsBasicAuthEnabled() {\n\t\tlogic.ReturnErrorResponse(response, request, logic.FormatError(fmt.Errorf(\"basic auth is disabled\"), \"badrequest\"))\n\t\treturn\n\t}\n\n\tdecoder := json.NewDecoder(request.Body)\n\tdecoderErr := decoder.Decode(&authRequest)\n\tdefer request.Body.Close()\n\tif decoderErr != nil {\n\t\tlogger.Log(0, \"error decoding request body: \",\n\t\t\tdecoderErr.Error())\n\t\tlogic.ReturnErrorResponse(response, request, errorResponse)\n\t\treturn\n\t}\n\tusername := authRequest.UserName\n\tjwt, err := logic.VerifyAuthRequest(authRequest)\n\tif err != nil {\n\t\tlogger.Log(0, username, \"user validation failed: \",\n\t\t\terr.Error())\n\t\tlogic.ReturnErrorResponse(response, request, logic.FormatError(err, \"badrequest\"))\n\t\treturn\n\t}\n\n\tif jwt == \"\" {\n\t\t// very unlikely that err is !nil and no jwt returned, but handle it anyways.\n\t\tlogger.Log(0, username, \"jwt token is empty\")\n\t\tlogic.ReturnErrorResponse(response, request, logic.FormatError(errors.New(\"no token returned\"), \"internal\"))\n\t\treturn\n\t}\n\n\tvar successResponse = models.SuccessResponse{\n\t\tCode:    http.StatusOK,\n\t\tMessage: \"W1R3: Device \" + username + \" Authorized\",\n\t\tResponse: models.SuccessfulUserLoginResponse{\n\t\t\tAuthToken: jwt,\n\t\t\tUserName:  username,\n\t\t},\n\t}\n\t// Send back the JWT\n\tsuccessJSONResponse, jsonError := json.Marshal(successResponse)\n\n\tif jsonError != nil {\n\t\tlogger.Log(0, username,\n\t\t\t\"error marshalling resp: \", err.Error())\n\t\tlogic.ReturnErrorResponse(response, request, errorResponse)\n\t\treturn\n\t}\n\tlogger.Log(2, username, \"was authenticated\")\n\tresponse.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse.Write(successJSONResponse)\n}\n\n// swagger:route GET /api/users/adm/hasadmin user hasAdmin\n//\n// Checks whether the server has an admin.\n//\n//\t\t\tSchemes: https\n//\n//\t\t\tSecurity:\n//\t  \t\toauth\n//\n//\t\t\tResponses:\n//\t\t\t\t200: successResponse\nfunc hasAdmin(w http.ResponseWriter, r *http.Request) {\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\n\thasadmin, err := logic.HasAdmin()\n\tif err != nil {\n\t\tlogger.Log(0, \"failed to check for admin: \", err.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"internal\"))\n\t\treturn\n\t}\n\n\tjson.NewEncoder(w).Encode(hasadmin)\n\n}\n\n// swagger:route GET /api/users/{username} user getUser\n//\n// Get an individual user.\n//\n//\t\t\tSchemes: https\n//\n//\t\t\tSecurity:\n//\t  \t\toauth\n//\n//\t\t\tResponses:\n//\t\t\t\t200: userBodyResponse\nfunc getUser(w http.ResponseWriter, r *http.Request) {\n\t// set header.\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\n\tvar params = mux.Vars(r)\n\tusernameFetched := params[\"username\"]\n\tuser, err := logic.GetUser(usernameFetched)\n\n\tif err != nil {\n\t\tlogger.Log(0, usernameFetched, \"failed to fetch user: \", err.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"internal\"))\n\t\treturn\n\t}\n\tlogger.Log(2, r.Header.Get(\"user\"), \"fetched user\", usernameFetched)\n\tjson.NewEncoder(w).Encode(user)\n}\n\n// swagger:route GET /api/users user getUsers\n//\n// Get all users.\n//\n//\t\t\tSchemes: https\n//\n//\t\t\tSecurity:\n//\t  \t\toauth\n//\n//\t\t\tResponses:\n//\t\t\t\t200: userBodyResponse\nfunc getUsers(w http.ResponseWriter, r *http.Request) {\n\t// set header.\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\n\tusers, err := logic.GetUsers()\n\n\tif err != nil {\n\t\tlogger.Log(0, \"failed to fetch users: \", err.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"internal\"))\n\t\treturn\n\t}\n\n\tlogger.Log(2, r.Header.Get(\"user\"), \"fetched users\")\n\tjson.NewEncoder(w).Encode(users)\n}\n\n// swagger:route POST /api/users/adm/createadmin user createAdmin\n//\n// Make a user an admin.\n//\n//\t\t\tSchemes: https\n//\n//\t\t\tSecurity:\n//\t  \t\toauth\n//\n//\t\t\tResponses:\n//\t\t\t\t200: userBodyResponse\nfunc createAdmin(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\n\tvar admin models.User\n\n\terr := json.NewDecoder(r.Body).Decode(&admin)\n\tif err != nil {\n\n\t\tlogger.Log(0, admin.UserName, \"error decoding request body: \",\n\t\t\terr.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"badrequest\"))\n\t\treturn\n\t}\n\n\tif !servercfg.IsBasicAuthEnabled() {\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(fmt.Errorf(\"basic auth is disabled\"), \"badrequest\"))\n\t\treturn\n\t}\n\n\terr = logic.CreateAdmin(&admin)\n\tif err != nil {\n\t\tlogger.Log(0, admin.UserName, \"failed to create admin: \",\n\t\t\terr.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"badrequest\"))\n\t\treturn\n\t}\n\n\tlogger.Log(1, admin.UserName, \"was made a new admin\")\n\tjson.NewEncoder(w).Encode(admin)\n}\n\n// swagger:route POST /api/users/{username} user createUser\n//\n// Create a user.\n//\n//\t\t\tSchemes: https\n//\n//\t\t\tSecurity:\n//\t  \t\toauth\n//\n//\t\t\tResponses:\n//\t\t\t\t200: userBodyResponse\nfunc createUser(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\n\tvar user models.User\n\terr := json.NewDecoder(r.Body).Decode(&user)\n\tif err != nil {\n\t\tlogger.Log(0, user.UserName, \"error decoding request body: \",\n\t\t\terr.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"badrequest\"))\n\t\treturn\n\t}\n\n\terr = logic.CreateUser(&user)\n\tif err != nil {\n\t\tlogger.Log(0, user.UserName, \"error creating new user: \",\n\t\t\terr.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"badrequest\"))\n\t\treturn\n\t}\n\tlogger.Log(1, user.UserName, \"was created\")\n\tjson.NewEncoder(w).Encode(user)\n}\n\n// swagger:route PUT /api/users/networks/{username} user updateUserNetworks\n//\n// Updates the networks of the given user.\n//\n//\t\t\tSchemes: https\n//\n//\t\t\tSecurity:\n//\t  \t\toauth\n//\n//\t\t\tResponses:\n//\t\t\t\t200: userBodyResponse\nfunc updateUserNetworks(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tvar params = mux.Vars(r)\n\t// start here\n\tusername := params[\"username\"]\n\tuser, err := logic.GetUser(username)\n\tif err != nil {\n\t\tlogger.Log(0, username,\n\t\t\t\"failed to update user networks: \", err.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"internal\"))\n\t\treturn\n\t}\n\tvar userchange models.User\n\t// we decode our body request params\n\terr = json.NewDecoder(r.Body).Decode(&userchange)\n\tif err != nil {\n\t\tlogger.Log(0, username, \"error decoding request body: \",\n\t\t\terr.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"badrequest\"))\n\t\treturn\n\t}\n\terr = logic.UpdateUserNetworks(userchange.Networks, userchange.Groups, userchange.IsAdmin, &models.ReturnUser{\n\t\tGroups:   user.Groups,\n\t\tIsAdmin:  user.IsAdmin,\n\t\tNetworks: user.Networks,\n\t\tUserName: user.UserName,\n\t})\n\n\tif err != nil {\n\t\tlogger.Log(0, username,\n\t\t\t\"failed to update user networks: \", err.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"badrequest\"))\n\t\treturn\n\t}\n\tlogger.Log(1, username, \"status was updated\")\n\tjson.NewEncoder(w).Encode(user)\n}\n\n// swagger:route PUT /api/users/{username} user updateUser\n//\n// Update a user.\n//\n//\t\t\tSchemes: https\n//\n//\t\t\tSecurity:\n//\t  \t\toauth\n//\n//\t\t\tResponses:\n//\t\t\t\t200: userBodyResponse\nfunc updateUser(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tvar params = mux.Vars(r)\n\t// start here\n\tusername := params[\"username\"]\n\tuser, err := logic.GetUser(username)\n\tif err != nil {\n\t\tlogger.Log(0, username,\n\t\t\t\"failed to update user info: \", err.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"internal\"))\n\t\treturn\n\t}\n\tif auth.IsOauthUser(user) == nil {\n\t\terr := fmt.Errorf(\"cannot update user info for oauth user %s\", username)\n\t\tlogger.Log(0, err.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"forbidden\"))\n\t\treturn\n\t}\n\tvar userchange models.User\n\t// we decode our body request params\n\terr = json.NewDecoder(r.Body).Decode(&userchange)\n\tif err != nil {\n\t\tlogger.Log(0, username, \"error decoding request body: \",\n\t\t\terr.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"badrequest\"))\n\t\treturn\n\t}\n\tuserchange.Networks = nil\n\tuser, err = logic.UpdateUser(&userchange, user)\n\tif err != nil {\n\t\tlogger.Log(0, username,\n\t\t\t\"failed to update user info: \", err.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"badrequest\"))\n\t\treturn\n\t}\n\tlogger.Log(1, username, \"was updated\")\n\tjson.NewEncoder(w).Encode(user)\n}\n\n// swagger:route PUT /api/users/{username}/adm user updateUserAdm\n//\n// Updates the given admin user's info (as long as the user is an admin).\n//\n//\t\t\tSchemes: https\n//\n//\t\t\tSecurity:\n//\t  \t\toauth\n//\n//\t\t\tResponses:\n//\t\t\t\t200: userBodyResponse\nfunc updateUserAdm(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tvar params = mux.Vars(r)\n\t// start here\n\tusername := params[\"username\"]\n\tuser, err := logic.GetUser(username)\n\tif err != nil {\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"internal\"))\n\t\treturn\n\t}\n\tif auth.IsOauthUser(user) != nil {\n\t\terr := fmt.Errorf(\"cannot update user info for oauth user %s\", username)\n\t\tlogger.Log(0, err.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"forbidden\"))\n\t\treturn\n\t}\n\tvar userchange models.User\n\t// we decode our body request params\n\terr = json.NewDecoder(r.Body).Decode(&userchange)\n\tif err != nil {\n\t\tlogger.Log(0, username, \"error decoding request body: \",\n\t\t\terr.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"badrequest\"))\n\t\treturn\n\t}\n\tif !user.IsAdmin {\n\t\tlogger.Log(0, username, \"not an admin user\")\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(errors.New(\"not a admin user\"), \"badrequest\"))\n\t}\n\tuser, err = logic.UpdateUser(&userchange, user)\n\tif err != nil {\n\t\tlogger.Log(0, username,\n\t\t\t\"failed to update user (admin) info: \", err.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"badrequest\"))\n\t\treturn\n\t}\n\tlogger.Log(1, username, \"was updated (admin)\")\n\tjson.NewEncoder(w).Encode(user)\n}\n\n// swagger:route DELETE /api/users/{username} user deleteUser\n//\n// Delete a user.\n//\n//\t\t\tSchemes: https\n//\n//\t\t\tSecurity:\n//\t  \t\toauth\n//\n//\t\t\tResponses:\n//\t\t\t\t200: userBodyResponse\nfunc deleteUser(w http.ResponseWriter, r *http.Request) {\n\t// Set header\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\n\t// get params\n\tvar params = mux.Vars(r)\n\n\tusername := params[\"username\"]\n\n\tsuccess, err := logic.DeleteUser(username)\n\tif err != nil {\n\t\tlogger.Log(0, username,\n\t\t\t\"failed to delete user: \", err.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"internal\"))\n\t\treturn\n\t} else if !success {\n\t\terr := errors.New(\"delete unsuccessful\")\n\t\tlogger.Log(0, username, err.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"badrequest\"))\n\t\treturn\n\t}\n\n\tlogger.Log(1, username, \"was deleted\")\n\tjson.NewEncoder(w).Encode(params[\"username\"] + \" deleted.\")\n}\n\n// Called when vpn client dials in to start the auth flow and first stage is to get register URL itself\nfunc socketHandler(w http.ResponseWriter, r *http.Request) {\n\t// Upgrade our raw HTTP connection to a websocket based one\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlogger.Log(0, \"error during connection upgrade for node sign-in:\", err.Error())\n\t\treturn\n\t}\n\tif conn == nil {\n\t\tlogger.Log(0, \"failed to establish web-socket connection during node sign-in\")\n\t\treturn\n\t}\n\t// Start handling the session\n\t// go auth.SessionHandler(conn)\n}\n", "package logic\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/golang-jwt/jwt/v4\"\n\n\t\"github.com/gravitl/netmaker/logger\"\n\t\"github.com/gravitl/netmaker/models\"\n\t\"github.com/gravitl/netmaker/servercfg\"\n)\n\nvar jwtSecretKey []byte\n\n// SetJWTSecret - sets the jwt secret on server startup\nfunc SetJWTSecret() {\n\tcurrentSecret, jwtErr := FetchJWTSecret()\n\tif jwtErr != nil {\n\t\tnewValue, err := GenerateCryptoString(64)\n\t\tif err != nil {\n\t\t\tlogger.FatalLog(\"something went wrong when generating JWT signature\")\n\t\t}\n\t\tjwtSecretKey = []byte(newValue) // 512 bit random password\n\t\tif err := StoreJWTSecret(string(jwtSecretKey)); err != nil {\n\t\t\tlogger.FatalLog(\"something went wrong when configuring JWT authentication\")\n\t\t}\n\t} else {\n\t\tjwtSecretKey = []byte(currentSecret)\n\t}\n}\n\n// CreateJWT func will used to create the JWT while signing in and signing out\nfunc CreateJWT(uuid string, macAddress string, network string) (response string, err error) {\n\texpirationTime := time.Now().Add(5 * time.Minute)\n\tclaims := &models.Claims{\n\t\tID:         uuid,\n\t\tNetwork:    network,\n\t\tMacAddress: macAddress,\n\t\tRegisteredClaims: jwt.RegisteredClaims{\n\t\t\tIssuer:    \"Netmaker\",\n\t\t\tSubject:   fmt.Sprintf(\"node|%s\", uuid),\n\t\t\tIssuedAt:  jwt.NewNumericDate(time.Now()),\n\t\t\tExpiresAt: jwt.NewNumericDate(expirationTime),\n\t\t},\n\t}\n\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\ttokenString, err := token.SignedString(jwtSecretKey)\n\tif err == nil {\n\t\treturn tokenString, nil\n\t}\n\treturn \"\", err\n}\n\n// CreateProUserJWT - creates a user jwt token\nfunc CreateProUserJWT(username string, networks, groups []string, isadmin bool) (response string, err error) {\n\texpirationTime := time.Now().Add(60 * 12 * time.Minute)\n\tclaims := &models.UserClaims{\n\t\tUserName: username,\n\t\tNetworks: networks,\n\t\tIsAdmin:  isadmin,\n\t\tGroups:   groups,\n\t\tRegisteredClaims: jwt.RegisteredClaims{\n\t\t\tIssuer:    \"Netmaker\",\n\t\t\tSubject:   fmt.Sprintf(\"user|%s\", username),\n\t\t\tIssuedAt:  jwt.NewNumericDate(time.Now()),\n\t\t\tExpiresAt: jwt.NewNumericDate(expirationTime),\n\t\t},\n\t}\n\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\ttokenString, err := token.SignedString(jwtSecretKey)\n\tif err == nil {\n\t\treturn tokenString, nil\n\t}\n\treturn \"\", err\n}\n\n// CreateUserJWT - creates a user jwt token\nfunc CreateUserJWT(username string, networks []string, isadmin bool) (response string, err error) {\n\texpirationTime := time.Now().Add(60 * 12 * time.Minute)\n\tclaims := &models.UserClaims{\n\t\tUserName: username,\n\t\tNetworks: networks,\n\t\tIsAdmin:  isadmin,\n\t\tRegisteredClaims: jwt.RegisteredClaims{\n\t\t\tIssuer:    \"Netmaker\",\n\t\t\tSubject:   fmt.Sprintf(\"user|%s\", username),\n\t\t\tIssuedAt:  jwt.NewNumericDate(time.Now()),\n\t\t\tExpiresAt: jwt.NewNumericDate(expirationTime),\n\t\t},\n\t}\n\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\ttokenString, err := token.SignedString(jwtSecretKey)\n\tif err == nil {\n\t\treturn tokenString, nil\n\t}\n\treturn \"\", err\n}\n\n// VerifyUserToken func will used to Verify the JWT Token while using APIS\nfunc VerifyUserToken(tokenString string) (username string, networks []string, isadmin bool, err error) {\n\tclaims := &models.UserClaims{}\n\n\tif tokenString == servercfg.GetMasterKey() && servercfg.GetMasterKey() != \"\" {\n\t\treturn \"masteradministrator\", nil, true, nil\n\t}\n\n\ttoken, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {\n\t\treturn jwtSecretKey, nil\n\t})\n\n\tif token != nil && token.Valid {\n\t\tvar user *models.User\n\t\t// check that user exists\n\t\tuser, err = GetUser(claims.UserName)\n\t\tif err != nil {\n\t\t\treturn \"\", nil, false, err\n\t\t}\n\n\t\tif user.UserName != \"\" {\n\t\t\treturn claims.UserName, claims.Networks, claims.IsAdmin, nil\n\t\t}\n\t\terr = errors.New(\"user does not exist\")\n\t}\n\treturn \"\", nil, false, err\n}\n\n// VerifyHostToken - [hosts] Only\nfunc VerifyHostToken(tokenString string) (hostID string, mac string, network string, err error) {\n\tclaims := &models.Claims{}\n\n\t// this may be a stupid way of serving up a master key\n\t// TODO: look into a different method. Encryption?\n\tif tokenString == servercfg.GetMasterKey() && servercfg.GetMasterKey() != \"\" {\n\t\treturn \"mastermac\", \"\", \"\", nil\n\t}\n\n\ttoken, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {\n\t\treturn jwtSecretKey, nil\n\t})\n\n\tif token != nil {\n\t\treturn claims.ID, claims.MacAddress, claims.Network, nil\n\t}\n\treturn \"\", \"\", \"\", err\n}\n"], "fixing_code": ["package controller\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/gravitl/netmaker/auth\"\n\t\"github.com/gravitl/netmaker/logger\"\n\t\"github.com/gravitl/netmaker/logic\"\n\t\"github.com/gravitl/netmaker/models\"\n\t\"github.com/gravitl/netmaker/servercfg\"\n)\n\nvar (\n\tupgrader = websocket.Upgrader{}\n)\n\nfunc userHandlers(r *mux.Router) {\n\n\tr.HandleFunc(\"/api/users/adm/hasadmin\", hasAdmin).Methods(http.MethodGet)\n\tr.HandleFunc(\"/api/users/adm/createadmin\", createAdmin).Methods(http.MethodPost)\n\tr.HandleFunc(\"/api/users/adm/authenticate\", authenticateUser).Methods(http.MethodPost)\n\tr.HandleFunc(\"/api/users/{username}\", logic.SecurityCheck(false, logic.ContinueIfUserMatch(http.HandlerFunc(updateUser)))).Methods(http.MethodPut)\n\tr.HandleFunc(\"/api/users/networks/{username}\", logic.SecurityCheck(true, http.HandlerFunc(updateUserNetworks))).Methods(http.MethodPut)\n\tr.HandleFunc(\"/api/users/{username}/adm\", logic.SecurityCheck(true, http.HandlerFunc(updateUserAdm))).Methods(http.MethodPut)\n\tr.HandleFunc(\"/api/users/{username}\", logic.SecurityCheck(true, checkFreeTierLimits(users_l, http.HandlerFunc(createUser)))).Methods(http.MethodPost)\n\tr.HandleFunc(\"/api/users/{username}\", logic.SecurityCheck(true, http.HandlerFunc(deleteUser))).Methods(http.MethodDelete)\n\tr.HandleFunc(\"/api/users/{username}\", logic.SecurityCheck(false, logic.ContinueIfUserMatch(http.HandlerFunc(getUser)))).Methods(http.MethodGet)\n\tr.HandleFunc(\"/api/users\", logic.SecurityCheck(true, http.HandlerFunc(getUsers))).Methods(http.MethodGet)\n\tr.HandleFunc(\"/api/oauth/login\", auth.HandleAuthLogin).Methods(http.MethodGet)\n\tr.HandleFunc(\"/api/oauth/callback\", auth.HandleAuthCallback).Methods(http.MethodGet)\n\tr.HandleFunc(\"/api/oauth/node-handler\", socketHandler)\n\tr.HandleFunc(\"/api/oauth/headless\", auth.HandleHeadlessSSO)\n\tr.HandleFunc(\"/api/oauth/register/{regKey}\", auth.RegisterNodeSSO).Methods(http.MethodGet)\n}\n\n// swagger:route POST /api/users/adm/authenticate user authenticateUser\n//\n// Node authenticates using its password and retrieves a JWT for authorization.\n//\n//\t\t\tSchemes: https\n//\n//\t\t\tSecurity:\n//\t  \t\toauth\n//\n//\t\t\tResponses:\n//\t\t\t\t200: successResponse\nfunc authenticateUser(response http.ResponseWriter, request *http.Request) {\n\n\t// Auth request consists of Mac Address and Password (from node that is authorizing\n\t// in case of Master, auth is ignored and mac is set to \"mastermac\"\n\tvar authRequest models.UserAuthParams\n\tvar errorResponse = models.ErrorResponse{\n\t\tCode: http.StatusInternalServerError, Message: \"W1R3: It's not you it's me.\",\n\t}\n\n\tif !servercfg.IsBasicAuthEnabled() {\n\t\tlogic.ReturnErrorResponse(response, request, logic.FormatError(fmt.Errorf(\"basic auth is disabled\"), \"badrequest\"))\n\t\treturn\n\t}\n\n\tdecoder := json.NewDecoder(request.Body)\n\tdecoderErr := decoder.Decode(&authRequest)\n\tdefer request.Body.Close()\n\tif decoderErr != nil {\n\t\tlogger.Log(0, \"error decoding request body: \",\n\t\t\tdecoderErr.Error())\n\t\tlogic.ReturnErrorResponse(response, request, errorResponse)\n\t\treturn\n\t}\n\tusername := authRequest.UserName\n\tjwt, err := logic.VerifyAuthRequest(authRequest)\n\tif err != nil {\n\t\tlogger.Log(0, username, \"user validation failed: \",\n\t\t\terr.Error())\n\t\tlogic.ReturnErrorResponse(response, request, logic.FormatError(err, \"badrequest\"))\n\t\treturn\n\t}\n\n\tif jwt == \"\" {\n\t\t// very unlikely that err is !nil and no jwt returned, but handle it anyways.\n\t\tlogger.Log(0, username, \"jwt token is empty\")\n\t\tlogic.ReturnErrorResponse(response, request, logic.FormatError(errors.New(\"no token returned\"), \"internal\"))\n\t\treturn\n\t}\n\n\tvar successResponse = models.SuccessResponse{\n\t\tCode:    http.StatusOK,\n\t\tMessage: \"W1R3: Device \" + username + \" Authorized\",\n\t\tResponse: models.SuccessfulUserLoginResponse{\n\t\t\tAuthToken: jwt,\n\t\t\tUserName:  username,\n\t\t},\n\t}\n\t// Send back the JWT\n\tsuccessJSONResponse, jsonError := json.Marshal(successResponse)\n\n\tif jsonError != nil {\n\t\tlogger.Log(0, username,\n\t\t\t\"error marshalling resp: \", err.Error())\n\t\tlogic.ReturnErrorResponse(response, request, errorResponse)\n\t\treturn\n\t}\n\tlogger.Log(2, username, \"was authenticated\")\n\tresponse.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse.Write(successJSONResponse)\n}\n\n// swagger:route GET /api/users/adm/hasadmin user hasAdmin\n//\n// Checks whether the server has an admin.\n//\n//\t\t\tSchemes: https\n//\n//\t\t\tSecurity:\n//\t  \t\toauth\n//\n//\t\t\tResponses:\n//\t\t\t\t200: successResponse\nfunc hasAdmin(w http.ResponseWriter, r *http.Request) {\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\n\thasadmin, err := logic.HasAdmin()\n\tif err != nil {\n\t\tlogger.Log(0, \"failed to check for admin: \", err.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"internal\"))\n\t\treturn\n\t}\n\n\tjson.NewEncoder(w).Encode(hasadmin)\n\n}\n\n// swagger:route GET /api/users/{username} user getUser\n//\n// Get an individual user.\n//\n//\t\t\tSchemes: https\n//\n//\t\t\tSecurity:\n//\t  \t\toauth\n//\n//\t\t\tResponses:\n//\t\t\t\t200: userBodyResponse\nfunc getUser(w http.ResponseWriter, r *http.Request) {\n\t// set header.\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\n\tvar params = mux.Vars(r)\n\tusernameFetched := params[\"username\"]\n\tuser, err := logic.GetUser(usernameFetched)\n\n\tif err != nil {\n\t\tlogger.Log(0, usernameFetched, \"failed to fetch user: \", err.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"internal\"))\n\t\treturn\n\t}\n\tlogger.Log(2, r.Header.Get(\"user\"), \"fetched user\", usernameFetched)\n\tjson.NewEncoder(w).Encode(user)\n}\n\n// swagger:route GET /api/users user getUsers\n//\n// Get all users.\n//\n//\t\t\tSchemes: https\n//\n//\t\t\tSecurity:\n//\t  \t\toauth\n//\n//\t\t\tResponses:\n//\t\t\t\t200: userBodyResponse\nfunc getUsers(w http.ResponseWriter, r *http.Request) {\n\t// set header.\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\n\tusers, err := logic.GetUsers()\n\n\tif err != nil {\n\t\tlogger.Log(0, \"failed to fetch users: \", err.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"internal\"))\n\t\treturn\n\t}\n\n\tlogger.Log(2, r.Header.Get(\"user\"), \"fetched users\")\n\tjson.NewEncoder(w).Encode(users)\n}\n\n// swagger:route POST /api/users/adm/createadmin user createAdmin\n//\n// Make a user an admin.\n//\n//\t\t\tSchemes: https\n//\n//\t\t\tSecurity:\n//\t  \t\toauth\n//\n//\t\t\tResponses:\n//\t\t\t\t200: userBodyResponse\nfunc createAdmin(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\n\tvar admin models.User\n\n\terr := json.NewDecoder(r.Body).Decode(&admin)\n\tif err != nil {\n\n\t\tlogger.Log(0, admin.UserName, \"error decoding request body: \",\n\t\t\terr.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"badrequest\"))\n\t\treturn\n\t}\n\n\tif !servercfg.IsBasicAuthEnabled() {\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(fmt.Errorf(\"basic auth is disabled\"), \"badrequest\"))\n\t\treturn\n\t}\n\n\terr = logic.CreateAdmin(&admin)\n\tif err != nil {\n\t\tlogger.Log(0, admin.UserName, \"failed to create admin: \",\n\t\t\terr.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"badrequest\"))\n\t\treturn\n\t}\n\n\tlogger.Log(1, admin.UserName, \"was made a new admin\")\n\tjson.NewEncoder(w).Encode(admin)\n}\n\n// swagger:route POST /api/users/{username} user createUser\n//\n// Create a user.\n//\n//\t\t\tSchemes: https\n//\n//\t\t\tSecurity:\n//\t  \t\toauth\n//\n//\t\t\tResponses:\n//\t\t\t\t200: userBodyResponse\nfunc createUser(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\n\tvar user models.User\n\terr := json.NewDecoder(r.Body).Decode(&user)\n\tif err != nil {\n\t\tlogger.Log(0, user.UserName, \"error decoding request body: \",\n\t\t\terr.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"badrequest\"))\n\t\treturn\n\t}\n\n\terr = logic.CreateUser(&user)\n\tif err != nil {\n\t\tlogger.Log(0, user.UserName, \"error creating new user: \",\n\t\t\terr.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"badrequest\"))\n\t\treturn\n\t}\n\tlogger.Log(1, user.UserName, \"was created\")\n\tjson.NewEncoder(w).Encode(user)\n}\n\n// swagger:route PUT /api/users/networks/{username} user updateUserNetworks\n//\n// Updates the networks of the given user.\n//\n//\t\t\tSchemes: https\n//\n//\t\t\tSecurity:\n//\t  \t\toauth\n//\n//\t\t\tResponses:\n//\t\t\t\t200: userBodyResponse\nfunc updateUserNetworks(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tvar params = mux.Vars(r)\n\t// start here\n\tusername := params[\"username\"]\n\tuser, err := logic.GetUser(username)\n\tif err != nil {\n\t\tlogger.Log(0, username,\n\t\t\t\"failed to update user networks: \", err.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"internal\"))\n\t\treturn\n\t}\n\tvar userchange models.User\n\t// we decode our body request params\n\terr = json.NewDecoder(r.Body).Decode(&userchange)\n\tif err != nil {\n\t\tlogger.Log(0, username, \"error decoding request body: \",\n\t\t\terr.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"badrequest\"))\n\t\treturn\n\t}\n\terr = logic.UpdateUserNetworks(userchange.Networks, userchange.Groups, userchange.IsAdmin, &models.ReturnUser{\n\t\tGroups:   user.Groups,\n\t\tIsAdmin:  user.IsAdmin,\n\t\tNetworks: user.Networks,\n\t\tUserName: user.UserName,\n\t})\n\n\tif err != nil {\n\t\tlogger.Log(0, username,\n\t\t\t\"failed to update user networks: \", err.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"badrequest\"))\n\t\treturn\n\t}\n\tlogger.Log(1, username, \"status was updated\")\n\tjson.NewEncoder(w).Encode(user)\n}\n\n// swagger:route PUT /api/users/{username} user updateUser\n//\n// Update a user.\n//\n//\t\t\tSchemes: https\n//\n//\t\t\tSecurity:\n//\t  \t\toauth\n//\n//\t\t\tResponses:\n//\t\t\t\t200: userBodyResponse\nfunc updateUser(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tvar params = mux.Vars(r)\n\t// start here\n\tjwtUser, _, isadmin, err := logic.VerifyJWT(r.Header.Get(\"Authorization\"))\n\tif err != nil {\n\t\tlogger.Log(0, \"verifyJWT error\", err.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"internal\"))\n\t\treturn\n\t}\n\tusername := params[\"username\"]\n\tif username != jwtUser && !isadmin {\n\t\tlogger.Log(0, \"non-admin user\", jwtUser, \"attempted to update user\", username)\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(errors.New(\"not authorizied\"), \"unauthorized\"))\n\t\treturn\n\t}\n\tuser, err := logic.GetUser(username)\n\tif err != nil {\n\t\tlogger.Log(0, username,\n\t\t\t\"failed to update user info: \", err.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"internal\"))\n\t\treturn\n\t}\n\tif auth.IsOauthUser(user) == nil {\n\t\terr := fmt.Errorf(\"cannot update user info for oauth user %s\", username)\n\t\tlogger.Log(0, err.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"forbidden\"))\n\t\treturn\n\t}\n\tvar userchange models.User\n\t// we decode our body request params\n\terr = json.NewDecoder(r.Body).Decode(&userchange)\n\tif err != nil {\n\t\tlogger.Log(0, username, \"error decoding request body: \",\n\t\t\terr.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"badrequest\"))\n\t\treturn\n\t}\n\tif userchange.IsAdmin && !isadmin {\n\t\tlogger.Log(0, \"non-admin user\", jwtUser, \"attempted get admin privilages\")\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(errors.New(\"not authorizied\"), \"unauthorized\"))\n\t\treturn\n\t}\n\tuserchange.Networks = nil\n\tuser, err = logic.UpdateUser(&userchange, user)\n\tif err != nil {\n\t\tlogger.Log(0, username,\n\t\t\t\"failed to update user info: \", err.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"badrequest\"))\n\t\treturn\n\t}\n\tlogger.Log(1, username, \"was updated\")\n\tjson.NewEncoder(w).Encode(user)\n}\n\n// swagger:route PUT /api/users/{username}/adm user updateUserAdm\n//\n// Updates the given admin user's info (as long as the user is an admin).\n//\n//\t\t\tSchemes: https\n//\n//\t\t\tSecurity:\n//\t  \t\toauth\n//\n//\t\t\tResponses:\n//\t\t\t\t200: userBodyResponse\nfunc updateUserAdm(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tvar params = mux.Vars(r)\n\t// start here\n\tusername := params[\"username\"]\n\tuser, err := logic.GetUser(username)\n\tif err != nil {\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"internal\"))\n\t\treturn\n\t}\n\tif auth.IsOauthUser(user) != nil {\n\t\terr := fmt.Errorf(\"cannot update user info for oauth user %s\", username)\n\t\tlogger.Log(0, err.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"forbidden\"))\n\t\treturn\n\t}\n\tvar userchange models.User\n\t// we decode our body request params\n\terr = json.NewDecoder(r.Body).Decode(&userchange)\n\tif err != nil {\n\t\tlogger.Log(0, username, \"error decoding request body: \",\n\t\t\terr.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"badrequest\"))\n\t\treturn\n\t}\n\tif !user.IsAdmin {\n\t\tlogger.Log(0, username, \"not an admin user\")\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(errors.New(\"not a admin user\"), \"badrequest\"))\n\t}\n\tuser, err = logic.UpdateUser(&userchange, user)\n\tif err != nil {\n\t\tlogger.Log(0, username,\n\t\t\t\"failed to update user (admin) info: \", err.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"badrequest\"))\n\t\treturn\n\t}\n\tlogger.Log(1, username, \"was updated (admin)\")\n\tjson.NewEncoder(w).Encode(user)\n}\n\n// swagger:route DELETE /api/users/{username} user deleteUser\n//\n// Delete a user.\n//\n//\t\t\tSchemes: https\n//\n//\t\t\tSecurity:\n//\t  \t\toauth\n//\n//\t\t\tResponses:\n//\t\t\t\t200: userBodyResponse\nfunc deleteUser(w http.ResponseWriter, r *http.Request) {\n\t// Set header\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\n\t// get params\n\tvar params = mux.Vars(r)\n\n\tusername := params[\"username\"]\n\n\tsuccess, err := logic.DeleteUser(username)\n\tif err != nil {\n\t\tlogger.Log(0, username,\n\t\t\t\"failed to delete user: \", err.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"internal\"))\n\t\treturn\n\t} else if !success {\n\t\terr := errors.New(\"delete unsuccessful\")\n\t\tlogger.Log(0, username, err.Error())\n\t\tlogic.ReturnErrorResponse(w, r, logic.FormatError(err, \"badrequest\"))\n\t\treturn\n\t}\n\n\tlogger.Log(1, username, \"was deleted\")\n\tjson.NewEncoder(w).Encode(params[\"username\"] + \" deleted.\")\n}\n\n// Called when vpn client dials in to start the auth flow and first stage is to get register URL itself\nfunc socketHandler(w http.ResponseWriter, r *http.Request) {\n\t// Upgrade our raw HTTP connection to a websocket based one\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlogger.Log(0, \"error during connection upgrade for node sign-in:\", err.Error())\n\t\treturn\n\t}\n\tif conn == nil {\n\t\tlogger.Log(0, \"failed to establish web-socket connection during node sign-in\")\n\t\treturn\n\t}\n\t// Start handling the session\n\t// go auth.SessionHandler(conn)\n}\n", "package logic\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/golang-jwt/jwt/v4\"\n\n\t\"github.com/gravitl/netmaker/logger\"\n\t\"github.com/gravitl/netmaker/models\"\n\t\"github.com/gravitl/netmaker/servercfg\"\n)\n\nvar jwtSecretKey []byte\n\n// SetJWTSecret - sets the jwt secret on server startup\nfunc SetJWTSecret() {\n\tcurrentSecret, jwtErr := FetchJWTSecret()\n\tif jwtErr != nil {\n\t\tnewValue, err := GenerateCryptoString(64)\n\t\tif err != nil {\n\t\t\tlogger.FatalLog(\"something went wrong when generating JWT signature\")\n\t\t}\n\t\tjwtSecretKey = []byte(newValue) // 512 bit random password\n\t\tif err := StoreJWTSecret(string(jwtSecretKey)); err != nil {\n\t\t\tlogger.FatalLog(\"something went wrong when configuring JWT authentication\")\n\t\t}\n\t} else {\n\t\tjwtSecretKey = []byte(currentSecret)\n\t}\n}\n\n// CreateJWT func will used to create the JWT while signing in and signing out\nfunc CreateJWT(uuid string, macAddress string, network string) (response string, err error) {\n\texpirationTime := time.Now().Add(5 * time.Minute)\n\tclaims := &models.Claims{\n\t\tID:         uuid,\n\t\tNetwork:    network,\n\t\tMacAddress: macAddress,\n\t\tRegisteredClaims: jwt.RegisteredClaims{\n\t\t\tIssuer:    \"Netmaker\",\n\t\t\tSubject:   fmt.Sprintf(\"node|%s\", uuid),\n\t\t\tIssuedAt:  jwt.NewNumericDate(time.Now()),\n\t\t\tExpiresAt: jwt.NewNumericDate(expirationTime),\n\t\t},\n\t}\n\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\ttokenString, err := token.SignedString(jwtSecretKey)\n\tif err == nil {\n\t\treturn tokenString, nil\n\t}\n\treturn \"\", err\n}\n\n// CreateProUserJWT - creates a user jwt token\nfunc CreateProUserJWT(username string, networks, groups []string, isadmin bool) (response string, err error) {\n\texpirationTime := time.Now().Add(60 * 12 * time.Minute)\n\tclaims := &models.UserClaims{\n\t\tUserName: username,\n\t\tNetworks: networks,\n\t\tIsAdmin:  isadmin,\n\t\tGroups:   groups,\n\t\tRegisteredClaims: jwt.RegisteredClaims{\n\t\t\tIssuer:    \"Netmaker\",\n\t\t\tSubject:   fmt.Sprintf(\"user|%s\", username),\n\t\t\tIssuedAt:  jwt.NewNumericDate(time.Now()),\n\t\t\tExpiresAt: jwt.NewNumericDate(expirationTime),\n\t\t},\n\t}\n\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\ttokenString, err := token.SignedString(jwtSecretKey)\n\tif err == nil {\n\t\treturn tokenString, nil\n\t}\n\treturn \"\", err\n}\n\n// CreateUserJWT - creates a user jwt token\nfunc CreateUserJWT(username string, networks []string, isadmin bool) (response string, err error) {\n\texpirationTime := time.Now().Add(60 * 12 * time.Minute)\n\tclaims := &models.UserClaims{\n\t\tUserName: username,\n\t\tNetworks: networks,\n\t\tIsAdmin:  isadmin,\n\t\tRegisteredClaims: jwt.RegisteredClaims{\n\t\t\tIssuer:    \"Netmaker\",\n\t\t\tSubject:   fmt.Sprintf(\"user|%s\", username),\n\t\t\tIssuedAt:  jwt.NewNumericDate(time.Now()),\n\t\t\tExpiresAt: jwt.NewNumericDate(expirationTime),\n\t\t},\n\t}\n\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\ttokenString, err := token.SignedString(jwtSecretKey)\n\tif err == nil {\n\t\treturn tokenString, nil\n\t}\n\treturn \"\", err\n}\n\n// VerifyJWT verifies Auth Header\nfunc VerifyJWT(bearerToken string) (username string, networks []string, isadmin bool, err error) {\n\ttoken := \"\"\n\ttokenSplit := strings.Split(bearerToken, \" \")\n\tif len(tokenSplit) > 1 {\n\t\ttoken = tokenSplit[1]\n\t} else {\n\t\treturn \"\", nil, false, errors.New(\"invalid auth header\")\n\t}\n\treturn VerifyUserToken(token)\n}\n\n// VerifyUserToken func will used to Verify the JWT Token while using APIS\nfunc VerifyUserToken(tokenString string) (username string, networks []string, isadmin bool, err error) {\n\tclaims := &models.UserClaims{}\n\n\tif tokenString == servercfg.GetMasterKey() && servercfg.GetMasterKey() != \"\" {\n\t\treturn \"masteradministrator\", nil, true, nil\n\t}\n\n\ttoken, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {\n\t\treturn jwtSecretKey, nil\n\t})\n\n\tif token != nil && token.Valid {\n\t\tvar user *models.User\n\t\t// check that user exists\n\t\tuser, err = GetUser(claims.UserName)\n\t\tif err != nil {\n\t\t\treturn \"\", nil, false, err\n\t\t}\n\n\t\tif user.UserName != \"\" {\n\t\t\treturn claims.UserName, claims.Networks, claims.IsAdmin, nil\n\t\t}\n\t\terr = errors.New(\"user does not exist\")\n\t}\n\treturn \"\", nil, false, err\n}\n\n// VerifyHostToken - [hosts] Only\nfunc VerifyHostToken(tokenString string) (hostID string, mac string, network string, err error) {\n\tclaims := &models.Claims{}\n\n\t// this may be a stupid way of serving up a master key\n\t// TODO: look into a different method. Encryption?\n\tif tokenString == servercfg.GetMasterKey() && servercfg.GetMasterKey() != \"\" {\n\t\treturn \"mastermac\", \"\", \"\", nil\n\t}\n\n\ttoken, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {\n\t\treturn jwtSecretKey, nil\n\t})\n\n\tif token != nil {\n\t\treturn claims.ID, claims.MacAddress, claims.Network, nil\n\t}\n\treturn \"\", \"\", \"\", err\n}\n"], "filenames": ["controllers/user.go", "logic/jwts.go"], "buggy_code_start_loc": [333, 5], "buggy_code_end_loc": [356, 103], "fixing_code_start_loc": [334, 6], "fixing_code_end_loc": [373, 117], "type": "CWE-639", "message": "Netmaker makes networks with WireGuard. An Insecure Direct Object Reference (IDOR) vulnerability was found in versions prior to 0.17.1 and 0.18.6 in the user update function. By specifying another user's username, it was possible to update the other user's password. The issue is patched in 0.17.1 and fixed in 0.18.6. If Users are using 0.17.1, they should run `docker pull gravitl/netmaker:v0.17.1` and `docker-compose up -d`. This will switch them to the patched users. If users are using v0.18.0-0.18.5, they should upgrade to v0.18.6 or later. As a workaround, someone using version 0.17.1 can pull the latest docker image of the backend and restart the server.", "other": {"cve": {"id": "CVE-2023-32078", "sourceIdentifier": "security-advisories@github.com", "published": "2023-08-24T22:15:10.267", "lastModified": "2023-08-31T17:59:30.080", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Netmaker makes networks with WireGuard. An Insecure Direct Object Reference (IDOR) vulnerability was found in versions prior to 0.17.1 and 0.18.6 in the user update function. By specifying another user's username, it was possible to update the other user's password. The issue is patched in 0.17.1 and fixed in 0.18.6. If Users are using 0.17.1, they should run `docker pull gravitl/netmaker:v0.17.1` and `docker-compose up -d`. This will switch them to the patched users. If users are using v0.18.0-0.18.5, they should upgrade to v0.18.6 or later. As a workaround, someone using version 0.17.1 can pull the latest docker image of the backend and restart the server."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-639"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gravitl:netmaker:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.17.1", "matchCriteriaId": "D271FC17-56AA-4851-846B-D7D174EBFB45"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gravitl:netmaker:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.18.0", "versionEndIncluding": "0.18.5", "matchCriteriaId": "249015D8-1590-4B85-A3F7-6F5F360CF0AD"}]}]}], "references": [{"url": "https://github.com/gravitl/netmaker/commit/b3be57c65bf0bbfab43b66853c8e3637a43e2839", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/gravitl/netmaker/pull/2158", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/gravitl/netmaker/security/advisories/GHSA-256m-j5qw-38f4", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/gravitl/netmaker/commit/b3be57c65bf0bbfab43b66853c8e3637a43e2839"}}