{"buggy_code": ["/*\n * Copyright (C) 2014-2019 Firejail Authors\n *\n * This file is part of firejail project\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n#ifndef FIREJAIL_H\n#define FIREJAIL_H\n#include \"../include/common.h\"\n#include \"../include/euid_common.h\"\n#include <stdarg.h>\n#include <sys/stat.h>\n\n// debug restricted shell\n//#define DEBUG_RESTRICTED_SHELL\n\n// filesystem\n#define RUN_FIREJAIL_BASEDIR\t\"/run\"\n#define RUN_FIREJAIL_DIR\t\"/run/firejail\"\n#define RUN_FIREJAIL_APPIMAGE_DIR\t\"/run/firejail/appimage\"\n#define RUN_FIREJAIL_NAME_DIR\t\"/run/firejail/name\" // also used in src/lib/pid.c - todo: move it in a common place\n#define RUN_FIREJAIL_LIB_DIR\t\t\"/run/firejail/lib\"\n#define RUN_FIREJAIL_X11_DIR\t\"/run/firejail/x11\"\n#define RUN_FIREJAIL_NETWORK_DIR\t\"/run/firejail/network\"\n#define RUN_FIREJAIL_BANDWIDTH_DIR\t\"/run/firejail/bandwidth\"\n#define RUN_FIREJAIL_PROFILE_DIR\t\t\"/run/firejail/profile\"\n#define RUN_NETWORK_LOCK_FILE\t\"/run/firejail/firejail-network.lock\"\n#define RUN_DIRECTORY_LOCK_FILE\t\"/run/firejail/firejail-run.lock\"\n#define RUN_RO_DIR\t\"/run/firejail/firejail.ro.dir\"\n#define RUN_RO_FILE\t\"/run/firejail/firejail.ro.file\"\n#define RUN_MNT_DIR\t\"/run/firejail/mnt\"\t// a tmpfs is mounted on this directory before any of the files below are created\n#define RUN_CGROUP_CFG\t\"/run/firejail/mnt/cgroup\"\n#define RUN_CPU_CFG\t\"/run/firejail/mnt/cpu\"\n#define RUN_GROUPS_CFG\t\"/run/firejail/mnt/groups\"\n#define RUN_PROTOCOL_CFG\t\"/run/firejail/mnt/protocol\"\n#define RUN_NONEWPRIVS_CFG\t\"/run/firejail/mnt/nonewprivs\"\n#define RUN_HOME_DIR\t\"/run/firejail/mnt/home\"\n#define RUN_ETC_DIR\t\"/run/firejail/mnt/etc\"\n#define RUN_OPT_DIR\t\"/run/firejail/mnt/opt\"\n#define RUN_SRV_DIR\t\"/run/firejail/mnt/srv\"\n#define RUN_BIN_DIR\t\"/run/firejail/mnt/bin\"\n#define RUN_PULSE_DIR\t\"/run/firejail/mnt/pulse\"\n#define RUN_LIB_DIR\t\"/run/firejail/mnt/lib\"\n#define RUN_LIB_FILE\t\"/run/firejail/mnt/libfiles\"\n#define RUN_DNS_ETC\t\"/run/firejail/mnt/dns-etc\"\n\n#define RUN_SECCOMP_LIST\t\"/run/firejail/mnt/seccomp.list\"\t// list of seccomp files installed\n#define RUN_SECCOMP_PROTOCOL\t\"/run/firejail/mnt/seccomp.protocol\"\t// protocol filter\n#define RUN_SECCOMP_CFG\t\"/run/firejail/mnt/seccomp\"\t\t\t// configured filter\n#define RUN_SECCOMP_32\t\"/run/firejail/mnt/seccomp.32\"\t\t// 32bit arch filter installed on 64bit architectures\n#define RUN_SECCOMP_MDWX\t\"/run/firejail/mnt/seccomp.mdwx\"\t\t// filter for memory-deny-write-execute\n#define RUN_SECCOMP_BLOCK_SECONDARY\t\"/run/firejail/mnt/seccomp.block_secondary\"\t// secondary arch blocking filter\n#define RUN_SECCOMP_POSTEXEC\t\"/run/firejail/mnt/seccomp.postexec\"\t\t// filter for post-exec library\n#define PATH_SECCOMP_DEFAULT (LIBDIR \"/firejail/seccomp\")\t\t\t// default filter built during make\n#define PATH_SECCOMP_DEFAULT_DEBUG (LIBDIR \"/firejail/seccomp.debug\")\t// default filter built during make\n#define PATH_SECCOMP_32 (LIBDIR \"/firejail/seccomp.32\")\t\t\t// 32bit arch filter built during make\n#define PATH_SECCOMP_MDWX (LIBDIR \"/firejail/seccomp.mdwx\")\t\t// filter for memory-deny-write-execute built during make\n#define PATH_SECCOMP_BLOCK_SECONDARY (LIBDIR \"/firejail/seccomp.block_secondary\")\t// secondary arch blocking filter built during make\n\n\n#define RUN_DEV_DIR\t\t\"/run/firejail/mnt/dev\"\n#define RUN_DEVLOG_FILE\t\"/run/firejail/mnt/devlog\"\n\n#define RUN_WHITELIST_X11_DIR\t\"/run/firejail/mnt/orig-x11\"\n#define RUN_WHITELIST_HOME_DIR\t\"/run/firejail/mnt/orig-home\"\t// default home directory masking\n#define RUN_WHITELIST_RUN_DIR\t\"/run/firejail/mnt/orig-run\"\t// default run directory masking\n#define RUN_WHITELIST_HOME_USER_DIR\t\"/run/firejail/mnt/orig-home-user\"\t// home directory whitelisting\n#define RUN_WHITELIST_RUN_USER_DIR\t\"/run/firejail/mnt/orig-run-user\"\t// run directory whitelisting\n#define RUN_WHITELIST_TMP_DIR\t\"/run/firejail/mnt/orig-tmp\"\n#define RUN_WHITELIST_MEDIA_DIR\t\"/run/firejail/mnt/orig-media\"\n#define RUN_WHITELIST_MNT_DIR\t\"/run/firejail/mnt/orig-mnt\"\n#define RUN_WHITELIST_VAR_DIR\t\"/run/firejail/mnt/orig-var\"\n#define RUN_WHITELIST_DEV_DIR\t\"/run/firejail/mnt/orig-dev\"\n#define RUN_WHITELIST_OPT_DIR\t\"/run/firejail/mnt/orig-opt\"\n#define RUN_WHITELIST_SRV_DIR   \"/run/firejail/mnt/orig-srv\"\n#define RUN_WHITELIST_ETC_DIR   \"/run/firejail/mnt/orig-etc\"\n#define RUN_WHITELIST_SHARE_DIR   \"/run/firejail/mnt/orig-share\"\n#define RUN_WHITELIST_MODULE_DIR   \"/run/firejail/mnt/orig-module\"\n\n#define RUN_XAUTHORITY_FILE\t\"/run/firejail/mnt/.Xauthority\"\n#define RUN_XAUTHORITY_SEC_FILE\t\"/run/firejail/mnt/sec.Xauthority\"\n#define RUN_ASOUNDRC_FILE\t\"/run/firejail/mnt/.asoundrc\"\n#define RUN_HOSTNAME_FILE\t\"/run/firejail/mnt/hostname\"\n#define RUN_HOSTS_FILE\t\"/run/firejail/mnt/hosts\"\n#define RUN_RESOLVCONF_FILE\t\"/run/firejail/mnt/resolv.conf\"\n#define RUN_MACHINEID\t\"/run/firejail/mnt/machine-id\"\n#define RUN_LDPRELOAD_FILE\t\"/run/firejail/mnt/ld.so.preload\"\n#define RUN_UTMP_FILE\t\t\"/run/firejail/mnt/utmp\"\n#define RUN_PASSWD_FILE\t\t\"/run/firejail/mnt/passwd\"\n#define RUN_GROUP_FILE\t\t\"/run/firejail/mnt/group\"\n#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"\n#define RUN_UMASK_FILE\t\t\"/run/firejail/mnt/umask\"\n#define RUN_OVERLAY_ROOT\t\"/run/firejail/mnt/oroot\"\n#define RUN_READY_FOR_JOIN \t\"/run/firejail/mnt/ready-for-join\"\n\n\n// profiles\n#define DEFAULT_USER_PROFILE\t\"default\"\n#define DEFAULT_ROOT_PROFILE\t\"server\"\n#define MAX_INCLUDE_LEVEL 16\t\t// include levels in profile files\n\n\n#define ASSERT_PERMS(file, uid, gid, mode) \\\n\tdo { \\\n\t\tassert(file);\\\n\t\tstruct stat s;\\\n\t\tif (stat(file, &s) == -1) errExit(\"stat\");\\\n\t\tassert(s.st_uid == uid);\\\n\t\tassert(s.st_gid == gid);\\\n\t\tassert((s.st_mode & 07777) == (mode));\\\n\t} while (0)\n#define ASSERT_PERMS_FD(fd, uid, gid, mode) \\\n\tdo { \\\n\t\tstruct stat s;\\\n\t\tif (fstat(fd, &s) == -1) errExit(\"fstat\");\\\n\t\tassert(s.st_uid == uid);\\\n\t\tassert(s.st_gid == gid);\\\n\t\tassert((s.st_mode & 07777) == (mode));\\\n\t} while (0)\n#define ASSERT_PERMS_STREAM(file, uid, gid, mode) \\\n\tdo { \\\n\t\tint fd = fileno(file);\\\n\t\tif (fd == -1) errExit(\"fileno\");\\\n\t\tASSERT_PERMS_FD(fd, uid, gid, (mode));\\\n\t} while (0)\n\n#define SET_PERMS_FD(fd, uid, gid, mode) \\\n\tdo { \\\n\t\tif (fchmod(fd, (mode)) == -1)\terrExit(\"chmod\");\\\n\t\tif (fchown(fd, uid, gid) == -1) errExit(\"chown\");\\\n\t} while (0)\n#define SET_PERMS_STREAM(stream, uid, gid, mode) \\\n\tdo { \\\n\t\tint fd = fileno(stream);\\\n\t\tif (fd == -1) errExit(\"fileno\");\\\n\t\tSET_PERMS_FD(fd, uid, gid, (mode));\\\n\t} while (0)\n#define SET_PERMS_STREAM_NOERR(stream, uid, gid, mode) \\\n\tdo { \\\n\t\tint fd = fileno(stream);\\\n\t\tif (fd == -1) continue;\\\n\t\tint rv = fchmod(fd, (mode));\\\n\t\t(void) rv;\\\n\t\trv = fchown(fd, uid, gid);\\\n\t\t(void) rv;\\\n\t} while (0)\n\n// main.c\ntypedef struct bridge_t {\n\t// on the host\n\tchar *dev;\t\t// interface device name: bridge or regular ethernet\n\tuint32_t ip;\t\t// interface device IP address\n\tuint32_t mask;\t\t// interface device mask\n\tuint8_t mac[6];\t\t// interface mac address\n\tint mtu;\t\t// interface mtu\n\n\tchar *veth_name;\t// veth name for the device connected to the bridge\n\n\t// inside the sandbox\n\tchar *devsandbox;\t// name of the device inside the sandbox\n\tuint32_t ipsandbox;\t// ip address inside the sandbox\n\tuint32_t masksandbox;\t// network mask inside the sandbox\n\tchar *ip6sandbox;\t// ipv6 address inside the sandbox\n\tuint8_t macsandbox[6]; // mac address inside the sandbox\n\tuint32_t iprange_start;// iprange arp scan start range\n\tuint32_t iprange_end;\t// iprange arp scan end range\n\n\t// flags\n\tuint8_t arg_ip_none;\t// --ip=none\n\tuint8_t macvlan;\t// set by --net=eth0 (or eth1, ...); reset by --net=br0 (or br1, ...)\n\tuint8_t configured;\n\tuint8_t scan;\t\t// set by --scan\n}  Bridge;\n\ntypedef struct interface_t {\n\tchar *dev;\n\tuint32_t ip;\n\tuint32_t mask;\n\tuint8_t mac[6];\n\tint mtu;\n\n\tuint8_t configured;\n} Interface;\n\ntypedef struct profile_entry_t {\n\tstruct profile_entry_t *next;\n\tchar *data;\t// command\n\n\t// whitelist command parameters\n\tchar *link;\t// link name - set if the file is a link\n\tunsigned home_dir:1;\t// whitelist in /home/user directory\n\tunsigned tmp_dir:1;\t// whitelist in /tmp directory\n\tunsigned media_dir:1;\t// whitelist in /media directory\n\tunsigned mnt_dir:1;\t// whitelist in /mnt directory\n\tunsigned var_dir:1;\t// whitelist in /var directory\n\tunsigned dev_dir:1;\t// whitelist in /dev directory\n\tunsigned opt_dir:1;\t// whitelist in /opt directory\n\tunsigned srv_dir:1;\t// whitelist in /srv directory\n\tunsigned etc_dir:1;\t// whitelist in /etc directory\n\tunsigned share_dir:1;\t// whitelist in /usr/share directory\n\tunsigned module_dir:1;\t// whitelist in /sys/module directory\n\tunsigned run_dir:1;\t// whitelist in /run/user/$uid directory\n}ProfileEntry;\n\ntypedef struct config_t {\n\t// user data\n\tchar *username;\n\tchar *homedir;\n\n\t// filesystem\n\tProfileEntry *profile;\n#define MAX_PROFILE_IGNORE 32\n\tchar *profile_ignore[MAX_PROFILE_IGNORE];\n\tchar *chrootdir;\t// chroot directory\n\tchar *home_private;\t// private home directory\n\tchar *home_private_keep;\t// keep list for private home directory\n\tchar *etc_private_keep;\t// keep list for private etc directory\n\tchar *opt_private_keep;\t// keep list for private opt directory\n\tchar *srv_private_keep;\t// keep list for private srv directory\n\tchar *bin_private_keep;\t// keep list for private bin directory\n\tchar *bin_private_lib;\t// executable list sent by private-bin to private-lib\n\tchar *lib_private_keep;\t// keep list for private bin directory\n\tchar *cwd;\t\t// current working directory\n\tchar *overlay_dir;\n\n\t// networking\n\tchar *name;\t\t// sandbox name\n\tchar *hostname;\t// host name\n\tchar *hosts_file;\t\t// hosts file to be installed in the sandbox\n\tuint32_t defaultgw;\t// default gateway\n\tBridge bridge0;\n\tBridge bridge1;\n\tBridge bridge2;\n\tBridge bridge3;\n\tInterface interface0;\n\tInterface interface1;\n\tInterface interface2;\n\tInterface interface3;\n\tchar *dns1;\t// up to 4 IP (v4/v6) addresses for dns servers\n\tchar *dns2;\n\tchar *dns3;\n\tchar *dns4;\n\n\t// seccomp\n\tchar *seccomp_list;//  optional seccomp list on top of default filter\n\tchar *seccomp_list_drop;\t// seccomp drop list\n\tchar *seccomp_list_keep;\t// seccomp keep list\n\tchar *protocol;\t\t\t// protocol list\n\n\t// rlimits\n\tlong long unsigned rlimit_cpu;\n\tlong long unsigned rlimit_nofile;\n\tlong long unsigned rlimit_nproc;\n\tlong long unsigned rlimit_fsize;\n\tlong long unsigned rlimit_sigpending;\n\tlong long unsigned rlimit_as;\n\tunsigned timeout;\t// maximum time elapsed before killing the sandbox\n\n\t// cpu affinity, nice and control groups\n\tuint32_t cpus;\n\tint nice;\n\tchar *cgroup;\n\n\t// command line\n\tchar *command_line;\n\tchar *window_title;\n\tchar *command_name;\n\tchar *shell;\n\tchar **original_argv;\n\tint original_argc;\n\tint original_program_index;\n} Config;\nextern Config cfg;\n\nstatic inline Bridge *last_bridge_configured(void) {\n\tif (cfg.bridge3.configured)\n\t\treturn &cfg.bridge3;\n\telse if (cfg.bridge2.configured)\n\t\treturn &cfg.bridge2;\n\telse if (cfg.bridge1.configured)\n\t\treturn &cfg.bridge1;\n\telse if (cfg.bridge0.configured)\n\t\treturn &cfg.bridge0;\n\telse\n\t\treturn NULL;\n}\n\nstatic inline int any_bridge_configured(void) {\n\tif (cfg.bridge0.configured || cfg.bridge1.configured || cfg.bridge2.configured || cfg.bridge3.configured)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic inline int any_interface_configured(void) {\n\tif (cfg.interface0.configured || cfg.interface1.configured || cfg.interface2.configured || cfg.interface3.configured)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nextern int arg_private;\t\t// mount private /home\nextern int arg_private_cache;\t// private home/.cache\nextern int arg_debug;\t\t// print debug messages\nextern int arg_debug_blacklists;\t// print debug messages for blacklists\nextern int arg_debug_whitelists;\t// print debug messages for whitelists\nextern int arg_debug_private_lib;\t// print debug messages for private-lib\nextern int arg_nonetwork;\t// --net=none\nextern int arg_command;\t// -c\nextern int arg_overlay;\t\t// overlay option\nextern int arg_overlay_keep;\t// place overlay diff in a known directory\nextern int arg_overlay_reuse;\t// allow the reuse of overlays\n\nextern int arg_seccomp;\t// enable default seccomp filter\nextern int arg_seccomp_postexec;\t// need postexec ld.preload library?\nextern int arg_seccomp_block_secondary;\t// block any secondary architectures\n\nextern int arg_caps_default_filter;\t// enable default capabilities filter\nextern int arg_caps_drop;\t\t// drop list\nextern int arg_caps_drop_all;\t\t// drop all capabilities\nextern int arg_caps_keep;\t\t// keep list\nextern char *arg_caps_list;\t\t// optional caps list\n\nextern int arg_trace;\t\t// syscall tracing support\nextern int arg_tracelog;\t// blacklist tracing support\nextern int arg_rlimit_cpu;\t// rlimit cpu\nextern int arg_rlimit_nofile;\t// rlimit nofile\nextern int arg_rlimit_nproc;\t// rlimit nproc\nextern int arg_rlimit_fsize;\t// rlimit fsize\nextern int arg_rlimit_sigpending;// rlimit sigpending\nextern int arg_rlimit_as;\t//rlimit as\nextern int arg_nogroups;\t// disable supplementary groups\nextern int arg_nonewprivs;\t// set the NO_NEW_PRIVS prctl\nextern int arg_noroot;\t\t// create a new user namespace and disable root user\nextern int arg_netfilter;\t// enable netfilter\nextern int arg_netfilter6;\t// enable netfilter6\nextern char *arg_netfilter_file;\t// netfilter file\nextern char *arg_netfilter6_file;\t// netfilter file\nextern char *arg_netns;\t\t// \"ip netns\"-created network namespace to use\nextern int arg_doubledash;\t// double dash\nextern int arg_shell_none;\t// run the program directly without a shell\nextern int arg_private_dev;\t// private dev directory\nextern int arg_keep_dev_shm;    // preserve /dev/shm\nextern int arg_private_etc;\t// private etc directory\nextern int arg_private_opt;\t// private opt directory\nextern int arg_private_srv;\t// private srv directory\nextern int arg_private_bin;\t// private bin directory\nextern int arg_private_tmp;\t// private tmp directory\nextern int arg_private_lib;\t// private lib directory\nextern int arg_scan;\t\t// arp-scan all interfaces\nextern int arg_whitelist;\t// whitelist command\nextern int arg_nosound;\t// disable sound\nextern int arg_noautopulse; // disable automatic ~/.config/pulse init\nextern int arg_novideo; //disable video devices in /dev\nextern int arg_no3d;\t\t// disable 3d hardware acceleration\nextern int arg_quiet;\t\t// no output for scripting\nextern int arg_join_network;\t// join only the network namespace\nextern int arg_join_filesystem;\t// join only the mount namespace\nextern int arg_nice;\t\t// nice value configured\nextern int arg_ipc;\t\t// enable ipc namespace\nextern int arg_writable_etc;\t// writable etc\nextern int arg_writable_var;\t// writable var\nextern int arg_keep_var_tmp; // don't overwrite /var/tmp\nextern int arg_writable_run_user;\t// writable /run/user\nextern int arg_writable_var_log; // writable /var/log\nextern int arg_appimage;\t// appimage\nextern int arg_audit;\t\t// audit\nextern char *arg_audit_prog;\t// audit\nextern int arg_apparmor;\t// apparmor\nextern int arg_allow_debuggers;\t// allow debuggers\nextern int arg_x11_block;\t// block X11\nextern int arg_x11_xorg;\t// use X11 security extension\nextern int arg_allusers;\t// all user home directories visible\nextern int arg_machineid;\t// preserve /etc/machine-id\nextern int arg_disable_mnt;\t// disable /mnt and /media\nextern int arg_noprofile;\t// use default.profile if none other found/specified\nextern int arg_memory_deny_write_execute;\t// block writable and executable memory\nextern int arg_notv;\t// --notv\nextern int arg_nodvd;\t// --nodvd\nextern int arg_nou2f;   // --nou2f\nextern int arg_nodbus; // -nodbus\n\nextern int login_shell;\nextern int parent_to_child_fds[2];\nextern int child_to_parent_fds[2];\nextern pid_t sandbox_pid;\nextern mode_t orig_umask;\nextern unsigned long long start_timestamp;\n\n#define MAX_ARGS 128\t\t// maximum number of command arguments (argc)\nextern char *fullargv[MAX_ARGS];\nextern int fullargc;\n\n// main.c\nvoid check_user_namespace(void);\nchar *guess_shell(void);\n\n// sandbox.c\nint sandbox(void* sandbox_arg);\nvoid start_application(int no_sandbox, FILE *fp);\n\n// network_main.c\nvoid net_configure_sandbox_ip(Bridge *br);\nvoid net_configure_veth_pair(Bridge *br, const char *ifname, pid_t child);\nvoid net_check_cfg(void);\nvoid net_dns_print(pid_t pid);\nvoid network_main(pid_t child);\nvoid net_print(pid_t pid);\n\n// network.c\nint check_ip46_address(const char *addr);\nvoid net_if_up(const char *ifname);\nvoid net_if_down(const char *ifname);\nvoid net_if_ip(const char *ifname, uint32_t ip, uint32_t mask, int mtu);\nvoid net_if_ip6(const char *ifname, const char *addr6);\nint net_get_if_addr(const char *bridge, uint32_t *ip, uint32_t *mask, uint8_t mac[6], int *mtu);\nint net_add_route(uint32_t dest, uint32_t mask, uint32_t gw);\nuint32_t network_get_defaultgw(void);\nint net_config_mac(const char *ifname, const unsigned char mac[6]);\nint net_get_mac(const char *ifname, unsigned char mac[6]);\nvoid net_config_interface(const char *dev, uint32_t ip, uint32_t mask, int mtu);\n\n// preproc.c\nvoid preproc_build_firejail_dir(void);\nvoid preproc_mount_mnt_dir(void);\nvoid preproc_clean_run(void);\n\n// fs.c\n// blacklist files or directories by mounting empty files on top of them\nvoid fs_blacklist(void);\n// mount a writable tmpfs\nvoid fs_tmpfs(const char *dir, unsigned check_owner);\n// remount a directory read-only\nvoid fs_rdonly(const char *dir);\nvoid fs_rdonly_rec(const char *dir);\n// remount a directory noexec, nodev and nosuid\nvoid fs_noexec(const char *dir);\nvoid fs_noexec_rec(const char *dir);\n// mount /proc and /sys directories\nvoid fs_proc_sys_dev_boot(void);\n// build a basic read-only filesystem\nvoid fs_basic_fs(void);\n// mount overlayfs on top of / directory\nchar *fs_check_overlay_dir(const char *subdirname, int allow_reuse);\nvoid fs_overlayfs(void);\n// chroot into an existing directory; mount exiting /dev and update /etc/resolv.conf\nvoid fs_chroot(const char *rootdir);\nvoid fs_check_chroot_dir(const char *rootdir);\nvoid fs_private_tmp(void);\nvoid fs_private_cache(void);\nvoid fs_mnt(const int enforce);\n\n// profile.c\n// find and read the profile specified by name from dir directory\nint profile_find_firejail(const char *name, int add_ext);\n// read a profile file\nvoid profile_read(const char *fname);\n// check profile line; if line == 0, this was generated from a command line option\n// return 1 if the command is to be added to the linked list of profile commands\n// return 0 if the command was already executed inside the function\nint profile_check_line(char *ptr, int lineno, const char *fname);\n// add a profile entry in cfg.profile list; use str to populate the list\nvoid profile_add(char *str);\nvoid profile_add_ignore(const char *str);\n\n// list.c\nvoid list(void);\nvoid tree(void);\nvoid top(void);\nvoid netstats(void);\n\n// usage.c\nvoid usage(void);\n\n// join.c\nvoid join(pid_t pid, int argc, char **argv, int index);\npid_t switch_to_child(pid_t pid);\n\n// shutdown.c\nvoid shut(pid_t pid);\n\n// restricted_shell.c\nint restricted_shell(const char *user);\n\n// arp.c\nvoid arp_announce(const char *dev, Bridge *br);\n// returns 0 if the address is not in use, -1 otherwise\nint arp_check(const char *dev, uint32_t destaddr);\n// assign an IP address using arp scanning\nuint32_t arp_assign(const char *dev, Bridge *br);\n\n// macros.c\nchar *expand_macros(const char *path);\nchar *resolve_macro(const char *name);\nvoid invalid_filename(const char *fname, int globbing);\nint is_macro(const char *name);\nint macro_id(const char *name);\n\n\n// util.c\nvoid errLogExit(char* fmt, ...);\nvoid fwarning(char* fmt, ...);\nvoid fmessage(char* fmt, ...);\nvoid drop_privs(int nogroups);\nint mkpath_as_root(const char* path);\nvoid extract_command_name(int index, char **argv);\nvoid logsignal(int s);\nvoid logmsg(const char *msg);\nvoid logargs(int argc, char **argv) ;\nvoid logerr(const char *msg);\nvoid set_nice(int inc);\nint copy_file(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode);\nvoid copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode);\nvoid copy_file_from_user_to_root(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode);\nvoid touch_file_as_user(const char *fname, mode_t mode);\nint is_dir(const char *fname);\nint is_link(const char *fname);\nvoid trim_trailing_slash_or_dot(char *path);\nchar *line_remove_spaces(const char *buf);\nchar *split_comma(char *str);\nchar *clean_pathname(const char *path);\nvoid check_unsigned(const char *str, const char *msg);\nint find_child(pid_t parent, pid_t *child);\nvoid check_private_dir(void);\nvoid update_map(char *mapping, char *map_file);\nvoid wait_for_other(int fd);\nvoid notify_other(int fd);\nconst char *gnu_basename(const char *path);\nuid_t pid_get_uid(pid_t pid);\nuid_t get_group_id(const char *group);\nint remove_overlay_directory(void);\nvoid flush_stdin(void);\nint create_empty_dir_as_user(const char *dir, mode_t mode);\nvoid create_empty_dir_as_root(const char *dir, mode_t mode);\nvoid create_empty_file_as_root(const char *dir, mode_t mode);\nint set_perms(const char *fname, uid_t uid, gid_t gid, mode_t mode);\nvoid mkdir_attr(const char *fname, mode_t mode, uid_t uid, gid_t gid);\nunsigned extract_timeout(const char *str);\nvoid disable_file_or_dir(const char *fname);\nvoid disable_file_path(const char *path, const char *file);\nint safe_fd(const char *path, int flags);\nint invalid_sandbox(const pid_t pid);\nint has_handler(pid_t pid, int signal);\nvoid enter_network_namespace(pid_t pid);\n\n// Get info regarding the last kernel mount operation from /proc/self/mountinfo\n// The return value points to a static area, and will be overwritten by subsequent calls.\n// The function does an exit(1) if anything goes wrong.\ntypedef struct {\n\tint mountid; // id of the mount\n\tchar *fsname; // the pathname of the directory in the filesystem which forms the root of this mount\n\tchar *dir;\t// mount destination\n\tchar *fstype; // filesystem type\n} MountData;\n\n// mountinfo.c\nMountData *get_last_mount(void);\nint get_mount_id(const char *path);\nchar **build_mount_array(const int mount_id, const char *path);\n\n// fs_var.c\nvoid fs_var_log(void);\t// mounting /var/log\nvoid fs_var_lib(void);\t// various other fixes for software in /var directory\nvoid fs_var_cache(void); // various other fixes for software in /var/cache directory\nvoid fs_var_run(void);\nvoid fs_var_lock(void);\nvoid fs_var_tmp(void);\nvoid fs_var_utmp(void);\nvoid dbg_test_dir(const char *dir);\n\n// fs_dev.c\nvoid fs_dev_shm(void);\nvoid fs_private_dev(void);\nvoid fs_dev_disable_sound(void);\nvoid fs_dev_disable_3d(void);\nvoid fs_dev_disable_video(void);\nvoid fs_dev_disable_tv(void);\nvoid fs_dev_disable_dvd(void);\nvoid fs_dev_disable_u2f(void);\n\n// fs_home.c\n// private mode (--private)\nvoid fs_private(void);\n// private mode (--private=homedir)\nvoid fs_private_homedir(void);\n// check new private home directory (--private= option) - exit if it fails\nvoid fs_check_private_dir(void);\nvoid fs_private_home_list(void);\n\n\n// seccomp.c\nchar *seccomp_check_list(const char *str);\nint seccomp_install_filters(void);\nint seccomp_load(const char *fname);\nint seccomp_filter_drop(void);\nint seccomp_filter_keep(void);\nvoid seccomp_print_filter(pid_t pid);\n\n// caps.c\nvoid seccomp_load_file_list(void);\nint caps_default_filter(void);\nvoid caps_print(void);\nvoid caps_drop_all(void);\nvoid caps_set(uint64_t caps);\nvoid caps_check_list(const char *clist, void (*callback)(int));\nvoid caps_drop_list(const char *clist);\nvoid caps_keep_list(const char *clist);\nvoid caps_print_filter(pid_t pid);\nvoid caps_drop_dac_override(void);\n\n// fs_trace.c\nvoid fs_trace_preload(void);\nvoid fs_trace(void);\n\n// fs_hostname.c\nvoid fs_hostname(const char *hostname);\nvoid fs_resolvconf(void);\nchar *fs_check_hosts_file(const char *fname);\nvoid fs_store_hosts_file(void);\nvoid fs_mount_hosts_file(void);\n\n// rlimit.c\nvoid set_rlimits(void);\n\n// cpu.c\nvoid read_cpu_list(const char *str);\nvoid set_cpu_affinity(void);\nvoid load_cpu(const char *fname);\nvoid save_cpu(void);\nvoid cpu_print_filter(pid_t pid);\n\n// cgroup.c\nvoid save_cgroup(void);\nvoid load_cgroup(const char *fname);\nvoid set_cgroup(const char *path);\n\n// output.c\nvoid check_output(int argc, char **argv);\n\n// netfilter.c\nvoid check_netfilter_file(const char *fname);\nvoid netfilter(const char *fname);\nvoid netfilter6(const char *fname);\nvoid netfilter_print(pid_t pid, int ipv6);\n\n// netns.c\nvoid check_netns(const char *nsname);\nvoid netns(const char *nsname);\nvoid netns_mounts(const char *nsname);\n\n// bandwidth.c\nvoid bandwidth_pid(pid_t pid, const char *command, const char *dev, int down, int up);\nvoid network_set_run_file(pid_t pid);\n\n// fs_etc.c\nvoid fs_machineid(void);\nvoid fs_private_dir_list(const char *private_dir, const char *private_run_dir, const char *private_list);\n\n// no_sandbox.c\nint check_namespace_virt(void);\nint check_kernel_procs(void);\nvoid run_no_sandbox(int argc, char **argv);\n\n// env.c\ntypedef enum {\n\tSETENV = 0,\n\tRMENV\n} ENV_OP;\n\nvoid env_store(const char *str, ENV_OP op);\nvoid env_apply(void);\nvoid env_defaults(void);\nvoid env_ibus_load(void);\n\n// fs_whitelist.c\nvoid fs_whitelist(void);\n\n// pulseaudio.c\nvoid pulseaudio_init(void);\nvoid pulseaudio_disable(void);\n\n// fs_bin.c\nvoid fs_private_bin_list(void);\n\n// fs_lib.c\nvoid fs_private_lib(void);\n\n// protocol.c\nvoid protocol_filter_save(void);\nvoid protocol_filter_load(const char *fname);\nvoid protocol_print_filter(pid_t pid);\n\n// restrict_users.c\nvoid restrict_users(void);\n\n// fs_logger.c\nvoid fs_logger(const char *msg);\nvoid fs_logger2(const char *msg1, const char *msg2);\nvoid fs_logger2int(const char *msg1, int d);\nvoid fs_logger3(const char *msg1, const char *msg2, const char *msg3);\nvoid fs_logger_print(void);\nvoid fs_logger_change_owner(void);\nvoid fs_logger_print_log(pid_t pid);\n\n// run_symlink.c\nvoid run_symlink(int argc, char **argv, int run_as_is);\n\n// paths.c\nchar **build_paths(void);\nunsigned int count_paths(void);\nint program_in_path(const char *program);\n\n// fs_mkdir.c\nvoid fs_mkdir(const char *name);\nvoid fs_mkfile(const char *name);\n\n// x11.c\n\n// X11 display range as assigned by --x11 options\n//     We try display numbers in the range 21 through 1000.\n//     Normal X servers typically use displays in the 0-10 range;\n//     ssh's X11 forwarding uses 10-20, and login screens\n//     (e.g. gdm3) may use displays above 1000.\n#define X11_DISPLAY_START 21\n#define X11_DISPLAY_END 1000\n\nvoid fs_x11(void);\nint x11_display(void);\nvoid x11_start(int argc, char **argv);\nvoid x11_start_xpra(int argc, char **argv);\nvoid x11_start_xephyr(int argc, char **argv);\nvoid x11_block(void);\nvoid x11_start_xvfb(int argc, char **argv);\nvoid x11_xorg(void);\n\n// ls.c\nenum {\n\tSANDBOX_FS_LS = 0,\n\tSANDBOX_FS_GET,\n\tSANDBOX_FS_PUT,\n\tSANDBOX_FS_MAX // this should always be the last entry\n};\nvoid sandboxfs(int op, pid_t pid, const char *path1, const char *path2);\n\n// checkcfg.c\n#define DEFAULT_ARP_PROBES 2\nenum {\n\tCFG_FILE_TRANSFER = 0,\n\tCFG_X11,\n\tCFG_BIND,\n\tCFG_USERNS,\n\tCFG_CHROOT,\n\tCFG_SECCOMP,\n\tCFG_NETWORK,\n\tCFG_RESTRICTED_NETWORK,\n\tCFG_FORCE_NONEWPRIVS,\n\tCFG_WHITELIST,\n\tCFG_XEPHYR_WINDOW_TITLE,\n\tCFG_OVERLAYFS,\n\tCFG_PRIVATE_HOME,\n\tCFG_PRIVATE_BIN_NO_LOCAL,\n\tCFG_FIREJAIL_PROMPT,\n\tCFG_FOLLOW_SYMLINK_AS_USER,\n\tCFG_DISABLE_MNT,\n\tCFG_JOIN,\n\tCFG_ARP_PROBES,\n\tCFG_XPRA_ATTACH,\n\tCFG_BROWSER_DISABLE_U2F,\n\tCFG_PRIVATE_LIB,\n\tCFG_APPARMOR,\n\tCFG_DBUS,\n\tCFG_PRIVATE_CACHE,\n\tCFG_CGROUP,\n\tCFG_NAME_CHANGE,\n\tCFG_MAX // this should always be the last entry\n};\nextern char *xephyr_screen;\nextern char *xephyr_extra_params;\nextern char *xpra_extra_params;\nextern char *xvfb_screen;\nextern char *xvfb_extra_params;\nextern char *netfilter_default;\nint checkcfg(int val);\nvoid print_compiletime_support(void);\n\n// appimage.c\nvoid appimage_set(const char *appimage_path);\nvoid appimage_clear(void);\nconst char *appimage_getdir(void);\n\n// appimage_size.c\nlong unsigned int appimage2_size(const char *fname);\n\n// cmdline.c\nvoid build_cmdline(char **command_line, char **window_title, int argc, char **argv, int index);\nvoid build_appimage_cmdline(char **command_line, char **window_title, int argc, char **argv, int index, char *apprun_path);\n\n// sbox.c\n// programs\n#define PATH_FNET_MAIN (LIBDIR \"/firejail/fnet\")\t\t// when called from main thread\n#define PATH_FNET (RUN_FIREJAIL_LIB_DIR \"/fnet\")\t// when called from sandbox thread\n\n//#define PATH_FNETFILTER (LIBDIR \"/firejail/fnetfilter\")\n#define PATH_FNETFILTER (RUN_FIREJAIL_LIB_DIR \"/fnetfilter\")\n\n#define PATH_FIREMON (PREFIX \"/bin/firemon\")\n#define PATH_FIREJAIL (PREFIX \"/bin/firejail\")\n\n#define PATH_FSECCOMP_MAIN (LIBDIR \"/firejail/fseccomp\")\t\t// when called from main thread\n#define PATH_FSECCOMP ( RUN_FIREJAIL_LIB_DIR \"/fseccomp\")\t// when called from sandbox thread\n\n// FSEC_PRINT is run outside of sandbox by --seccomp.print\n// it is also run from inside the sandbox by --debug; in this case we do an access(filename, X_OK) test first\n#define PATH_FSEC_PRINT (LIBDIR \"/firejail/fsec-print\")\n\n//#define PATH_FSEC_OPTIMIZE (LIBDIR \"/firejail/fsec-optimize\")\n#define PATH_FSEC_OPTIMIZE (RUN_FIREJAIL_LIB_DIR \"/fsec-optimize\")\n\n//#define PATH_FCOPY (LIBDIR \"/firejail/fcopy\")\n#define PATH_FCOPY (RUN_FIREJAIL_LIB_DIR \"/fcopy\")\n\n#define SBOX_STDIN_FILE \"/run/firejail/mnt/sbox_stdin\"\n\n//#define PATH_FLDD (LIBDIR \"/firejail/fldd\")\n#define PATH_FLDD (RUN_FIREJAIL_LIB_DIR \"/fldd\")\n\n// bitmapped filters for sbox_run\n#define SBOX_ROOT (1 << 0)\t\t\t// run the sandbox as root\n#define SBOX_USER (1 << 1)\t\t\t// run the sandbox as a regular user\n#define SBOX_SECCOMP (1 << 2)\t\t// install seccomp\n#define SBOX_CAPS_NONE (1 << 3)\t\t// drop all capabilities\n#define SBOX_CAPS_NETWORK (1 << 4)\t// caps filter for programs running network programs\n#define SBOX_ALLOW_STDIN (1 << 5)\t\t// don't close stdin\n#define SBOX_STDIN_FROM_FILE (1 << 6)\t// open file and redirect it to stdin\n#define SBOX_CAPS_HIDEPID (1 << 7)\t// hidepid caps filter for running firemon\n\n// run sbox\nint sbox_run(unsigned filter, int num, ...);\n\n// run_files.c\nvoid delete_run_files(pid_t pid);\nvoid delete_bandwidth_run_file(pid_t pid);\nvoid set_name_run_file(pid_t pid);\nvoid set_x11_run_file(pid_t pid, int display);\nvoid set_profile_run_file(pid_t pid, const char *fname);\n\n// dbus.c\nvoid dbus_session_disable(void);\n\n#endif\n", "/*\n * Copyright (C) 2014-2019 Firejail Authors\n *\n * This file is part of firejail project\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#include \"firejail.h\"\n#include \"../include/ldd_utils.h\"\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <glob.h>\n#define MAXBUF 4096\n\nextern void fslib_install_stdc(void);\nextern void fslib_install_system(void);\n\nstatic int lib_cnt = 0;\nstatic int dir_cnt = 0;\n\nstatic void report_duplication(const char *full_path) {\n\tchar *fname = strrchr(full_path, '/');\n\tif (fname && *(++fname) != '\\0') {\n\t\t// report the file on all bin paths\n\t\tint i = 0;\n\t\twhile (default_lib_paths[i]) {\n\t\t\tchar *p;\n\t\t\tif (asprintf(&p, \"%s/%s\", default_lib_paths[i], fname) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tfs_logger2(\"clone\", p);\n\t\t\tfree(p);\n\t\t\ti++;\n\t\t}\n\t}\n}\n\nstatic char *build_dest_dir(const char *full_path) {\n\tassert(full_path);\n\tif (strstr(full_path, \"/x86_64-linux-gnu/\"))\n\t\treturn RUN_LIB_DIR \"/x86_64-linux-gnu\";\n\treturn RUN_LIB_DIR;\n}\n\n// copy fname in private_run_dir\nvoid fslib_duplicate(const char *full_path) {\n\tassert(full_path);\n\n\tstruct stat s;\n\tif (stat(full_path, &s) != 0 || s.st_uid != 0 || access(full_path, R_OK))\n\t\treturn;\n\n\tchar *dest_dir = build_dest_dir(full_path);\n\n\t// don't copy it if the file is already there\n\tchar *ptr = strrchr(full_path, '/');\n\tif (!ptr)\n\t\treturn;\n\tptr++;\n\tif (*ptr == '\\0')\n\t\treturn;\n\n\tchar *name;\n\tif (asprintf(&name, \"%s/%s\", dest_dir, ptr) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(name, &s) == 0) {\n\t\tfree(name);\n\t\treturn;\n\t}\n\tfree(name);\n\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"    copying %s to private %s\\n\", full_path, dest_dir);\n\n\tsbox_run(SBOX_ROOT| SBOX_SECCOMP, 4, PATH_FCOPY, \"--follow-link\", full_path, dest_dir);\n\treport_duplication(full_path);\n\tlib_cnt++;\n}\n\n\n// requires full path for lib\n// it could be a library or an executable\n// lib is not copied, only libraries used by it\nvoid fslib_copy_libs(const char *full_path) {\n\tassert(full_path);\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"    fslib_copy_libs %s\\n\", full_path);\n\n\t// if library/executable does not exist or the user does not have read access to it\n\t// print a warning and exit the function.\n\tif (access(full_path, R_OK)) {\n\t\tif (arg_debug || arg_debug_private_lib)\n\t\t\tprintf(\"cannot find %s for private-lib, skipping...\\n\", full_path);\n\t\treturn;\n\t}\n\n\t// create an empty RUN_LIB_FILE and allow the user to write to it\n\tunlink(RUN_LIB_FILE);\t\t\t  // in case is there\n\tcreate_empty_file_as_root(RUN_LIB_FILE, 0644);\n\tif (chown(RUN_LIB_FILE, getuid(), getgid()))\n\t\terrExit(\"chown\");\n\n\t// run fldd to extract the list of files\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"    running fldd %s\\n\", full_path);\n\tsbox_run(SBOX_USER | SBOX_SECCOMP | SBOX_CAPS_NONE, 3, PATH_FLDD, full_path, RUN_LIB_FILE);\n\n\t// open the list of libraries and install them on by one\n\tFILE *fp = fopen(RUN_LIB_FILE, \"r\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\t// remove \\n\n\t\tchar *ptr = strchr(buf, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\t\tfslib_duplicate(buf);\n\t}\n\tfclose(fp);\n}\n\n\nvoid fslib_copy_dir(const char *full_path) {\n\tassert(full_path);\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"    fslib_copy_dir %s\\n\", full_path);\n\n\t// do nothing if the directory does not exist or is not owned by root\n\tstruct stat s;\n\tif (stat(full_path, &s) != 0 || s.st_uid != 0 || !S_ISDIR(s.st_mode) || access(full_path, R_OK))\n\t\treturn;\n\n\tchar *dir_name = strrchr(full_path, '/');\n\tassert(dir_name);\n\tdir_name++;\n\tassert(*dir_name != '\\0');\n\n\t// do nothing if the directory is already there\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/%s\", build_dest_dir(full_path), dir_name) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(dest, &s) == 0) {\n\t\tfree(dest);\n\t\treturn;\n\t}\n\n\t// create new directory and mount the original on top of it\n\tmkdir_attr(dest, 0755, 0, 0);\n\n\tif (mount(full_path, dest, NULL, MS_BIND|MS_REC, NULL) < 0 ||\n\t\tmount(NULL, dest, NULL, MS_BIND|MS_REMOUNT|MS_NOSUID|MS_NODEV|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfs_logger2(\"clone\", full_path);\n\tfs_logger2(\"mount\", full_path);\n\tdir_cnt++;\n\tfree(dest);\n}\n\n// fname should be a vallid full path at this point\nstatic void load_library(const char *fname) {\n\tassert(fname);\n\tassert(*fname == '/');\n\n\t// existing file owned by root, read access\n\tstruct stat s;\n\tif (stat(fname, &s) == 0 && s.st_uid == 0 && !access(fname, R_OK)) {\n\t\t// load directories, regular 64 bit libraries, and 64 bit executables\n\t\tif (is_dir(fname) || is_lib_64(fname)) {\n\t\t\tif (is_dir(fname))\n\t\t\t\tfslib_copy_dir(fname);\n\t\t\telse {\n\t\t\t\tif (strstr(fname, \".so\") ||\n\t\t\t\t    access(fname, X_OK) != 0) // don't duplicate executables, just install the libraries\n\t\t\t\t\tfslib_duplicate(fname);\n\n\t\t\t\tfslib_copy_libs(fname);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void install_list_entry(const char *lib) {\n\tassert(lib);\n\n\t// filename check\n\tint len = strlen(lib);\n\tif (strcspn(lib, \"\\\\&!?\\\"'<>%^(){}[];,\") != (size_t)len ||\n\tstrstr(lib, \"..\")) {\n\t\tfprintf(stderr, \"Error: \\\"%s\\\" is an invalid library\\n\", lib);\n\t\texit(1);\n\t}\n\n\t// if this is a full path, use it as is\n\tif (*lib == '/')\n\t\treturn load_library(lib);\n\n\n\t// find the library\n\tint i;\n\tfor (i = 0; default_lib_paths[i]; i++) {\n\t\tchar *fname = NULL;\n\t\tif (asprintf(&fname, \"%s/%s\", default_lib_paths[i], lib) == -1)\n\t\t\terrExit(\"asprintf\");\n\n#define DO_GLOBBING\n#ifdef DO_GLOBBING\n\t\t// globbing\n\t\tglob_t globbuf;\n\t\tint globerr = glob(fname, GLOB_NOCHECK | GLOB_NOSORT | GLOB_PERIOD, NULL, &globbuf);\n\t\tif (globerr) {\n\t\t\tfprintf(stderr, \"Error: failed to glob private-lib pattern %s\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tsize_t j;\n\t\tfor (j = 0; j < globbuf.gl_pathc; j++) {\n\t\t\tassert(globbuf.gl_pathv[j]);\n//printf(\"glob %s\\n\", globbuf.gl_pathv[j]);\n\t\t\t// GLOB_NOCHECK - no pattern matched returns the original pattern; try to load it anyway\n\t\t\tload_library(globbuf.gl_pathv[j]);\n\t\t}\n\n\t\tglobfree(&globbuf);\n#else\n\t\tload_library(fname);\n#endif\n\t\tfree(fname);\n\t}\n\n//\tfwarning(\"%s library not found, skipping...\\n\", lib);\n\treturn;\n}\n\n\nvoid fslib_install_list(const char *lib_list) {\n\tassert(lib_list);\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"    fslib_install_list  %s\\n\", lib_list);\n\n\tchar *dlist = strdup(lib_list);\n\tif (!dlist)\n\t\terrExit(\"strdup\");\n\n\tchar *ptr = strtok(dlist, \",\");\n\tif (!ptr) {\n\t\tfprintf(stderr, \"Error: invalid private-lib argument\\n\");\n\t\texit(1);\n\t}\n\tinstall_list_entry(ptr);\n\n\twhile ((ptr = strtok(NULL, \",\")) != NULL)\n\t\tinstall_list_entry(ptr);\n\tfree(dlist);\n\tfs_logger_print();\n}\n\n\n\nstatic void mount_directories(void) {\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"Mount-bind %s on top of /lib /lib64 /usr/lib\\n\", RUN_LIB_DIR);\n\n\tif (is_dir(\"/lib\")) {\n\t\tif (mount(RUN_LIB_DIR, \"/lib\", NULL, MS_BIND|MS_REC, NULL) < 0 ||\n\t\t\tmount(NULL, \"/lib\", NULL, MS_BIND|MS_REMOUNT|MS_NOSUID|MS_NODEV|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount bind\");\n\t\tfs_logger2(\"tmpfs\", \"/lib\");\n\t\tfs_logger(\"mount /lib\");\n\t}\n\n\tif (is_dir(\"/lib64\")) {\n\t\tif (mount(RUN_LIB_DIR, \"/lib64\", NULL, MS_BIND|MS_REC, NULL) < 0 ||\n\t\t\tmount(NULL, \"/lib64\", NULL, MS_BIND|MS_REMOUNT|MS_NOSUID|MS_NODEV|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount bind\");\n\t\tfs_logger2(\"tmpfs\", \"/lib64\");\n\t\tfs_logger(\"mount /lib64\");\n\t}\n\n\tif (is_dir(\"/usr/lib\")) {\n\t\tif (mount(RUN_LIB_DIR, \"/usr/lib\", NULL, MS_BIND|MS_REC, NULL) < 0 ||\n\t\t\tmount(NULL, \"/usr/lib\", NULL, MS_BIND|MS_REMOUNT|MS_NOSUID|MS_NODEV|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount bind\");\n\t\tfs_logger2(\"tmpfs\", \"/usr/lib\");\n\t\tfs_logger(\"mount /usr/lib\");\n\t}\n\n\t// for amd64 only - we'll deal with i386 later\n\tif (is_dir(\"/lib32\")) {\n\t\tif (mount(RUN_RO_DIR, \"/lib32\", \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\terrExit(\"disable file\");\n\t\tfs_logger(\"blacklist-nolog /lib32\");\n\t}\n\tif (is_dir(\"/libx32\")) {\n\t\tif (mount(RUN_RO_DIR, \"/libx32\", \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\terrExit(\"disable file\");\n\t\tfs_logger(\"blacklist-nolog /libx32\");\n\t}\n}\n\nvoid fs_private_lib(void) {\n#ifndef __x86_64__\n\tfwarning(\"private-lib feature is currently available only on amd64 platforms\\n\");\n\treturn;\n#endif\n\tchar *private_list = cfg.lib_private_keep;\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"Starting private-lib processing: program %s, shell %s\\n\",\n\t\t\t(cfg.original_program_index > 0)? cfg.original_argv[cfg.original_program_index]: \"none\",\n\t\t(arg_shell_none)? \"none\": cfg.shell);\n\n\t// create /run/firejail/mnt/lib directory\n\tmkdir_attr(RUN_LIB_DIR, 0755, 0, 0);\n\n\t// install standard C libraries\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"Installing standard C library\\n\");\n\tfslib_install_stdc();\n\n\t// start timetrace\n\ttimetrace_start();\n\n\t// copy the libs in the new lib directory for the main exe\n\tif (cfg.original_program_index > 0) {\n\t\tif (arg_debug || arg_debug_private_lib)\n\t\t\tprintf(\"Installing sandboxed program libraries\\n\");\n\t\tfslib_install_list(cfg.original_argv[cfg.original_program_index]);\n\t}\n\n\t// for the shell\n\tif (!arg_shell_none) {\n\t\tif (arg_debug || arg_debug_private_lib)\n\t\t\tprintf(\"Installing shell libraries\\n\");\n\n\t\tfslib_install_list(cfg.shell);\n\t\t// a shell is useless without some basic commands\n\t\tfslib_install_list(\"/bin/ls,/bin/cat,/bin/mv,/bin/rm\");\n\n\t}\n\n\t// for the listed libs and directories\n\tif (private_list && *private_list != '\\0') {\n\t\tif (arg_debug || arg_debug_private_lib)\n\t\t\tprintf(\"Processing private-lib files\\n\");\n\t\tfslib_install_list(private_list);\n\t}\n\n\t// for private-bin files\n\tif (arg_private_bin && cfg.bin_private_lib && *cfg.bin_private_lib != '\\0') {\n\t\tif (arg_debug || arg_debug_private_lib)\n\t\t\tprintf(\"Processing private-bin files\\n\");\n\t\tfslib_install_list(cfg.bin_private_lib);\n\t}\n\tfmessage(\"Program libraries installed in %0.2f ms\\n\", timetrace_end());\n\n\t// install the reset of the system libraries\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"Installing system libraries\\n\");\n\tfslib_install_system();\n\n\t// bring in firejail directory for --trace and seccomp post exec\n\t// bring in firejail executable libraries in case we are redirected here by a firejail symlink from /usr/local/bin/firejail\n\tfslib_install_list(\"/usr/bin/firejail,firejail\"); // todo: use the installed path for the executable\n\n\tfmessage(\"Installed %d %s and %d %s\\n\", lib_cnt, (lib_cnt == 1)? \"library\": \"libraries\",\n\t\tdir_cnt, (dir_cnt == 1)? \"directory\": \"directories\");\n\n\t// mount lib filesystem\n\tmount_directories();\n}\n", "/*\n * Copyright (C) 2014-2019 Firejail Authors\n *\n * This file is part of firejail project\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n#include \"firejail.h\"\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <dirent.h>\n\nstatic int tmpfs_mounted = 0;\n\n// build /run/firejail directory\nvoid preproc_build_firejail_dir(void) {\n\tstruct stat s;\n\n\t// CentOS 6 doesn't have /run directory\n\tif (stat(RUN_FIREJAIL_BASEDIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_BASEDIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_NETWORK_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_NETWORK_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_BANDWIDTH_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_BANDWIDTH_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_NAME_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_NAME_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_PROFILE_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_PROFILE_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_X11_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_X11_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_APPIMAGE_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_APPIMAGE_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_LIB_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_LIB_DIR, 0755);\n\t}\n\n\tif (stat(RUN_MNT_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_MNT_DIR, 0755);\n\t}\n\n\tcreate_empty_file_as_root(RUN_RO_FILE, S_IRUSR);\n\tcreate_empty_dir_as_root(RUN_RO_DIR, S_IRUSR);\n}\n\n// build /run/firejail/mnt directory\nvoid preproc_mount_mnt_dir(void) {\n\t// mount tmpfs on top of /run/firejail/mnt\n\tif (!tmpfs_mounted) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on %s directory\\n\", RUN_MNT_DIR);\n\t\tif (mount(\"tmpfs\", RUN_MNT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /run/firejail/mnt\");\n\t\ttmpfs_mounted = 1;\n\t\tfs_logger2(\"tmpfs\", RUN_MNT_DIR);\n\n#ifdef HAVE_SECCOMP\n\t\tif (arg_seccomp_block_secondary)\n\t\t\tcopy_file(PATH_SECCOMP_BLOCK_SECONDARY, RUN_SECCOMP_BLOCK_SECONDARY, getuid(), getgid(), 0644); // root needed\n\t\telse {\n\t\t\t//copy default seccomp files\n\t\t\tcopy_file(PATH_SECCOMP_32, RUN_SECCOMP_32, getuid(), getgid(), 0644); // root needed\n\t\t}\n\t\tif (arg_allow_debuggers)\n\t\t\tcopy_file(PATH_SECCOMP_DEFAULT_DEBUG, RUN_SECCOMP_CFG, getuid(), getgid(), 0644); // root needed\n\t\telse\n\t\t\tcopy_file(PATH_SECCOMP_DEFAULT, RUN_SECCOMP_CFG, getuid(), getgid(), 0644); // root needed\n\n\t\tif (arg_memory_deny_write_execute)\n\t\t\tcopy_file(PATH_SECCOMP_MDWX, RUN_SECCOMP_MDWX, getuid(), getgid(), 0644); // root needed\n\t\t// as root, create empty RUN_SECCOMP_PROTOCOL and RUN_SECCOMP_POSTEXEC files\n\t\tcreate_empty_file_as_root(RUN_SECCOMP_PROTOCOL, 0644);\n\t\tif (set_perms(RUN_SECCOMP_PROTOCOL, getuid(), getgid(), 0644))\n\t\t\terrExit(\"set_perms\");\n\t\tcreate_empty_file_as_root(RUN_SECCOMP_POSTEXEC, 0644);\n\t\tif (set_perms(RUN_SECCOMP_POSTEXEC, getuid(), getgid(), 0644))\n\t\t\terrExit(\"set_perms\");\n#endif\n\t}\n}\n\nstatic void clean_dir(const char *name, int *pidarr, int start_pid, int max_pids) {\n\tDIR *dir;\n\tif (!(dir = opendir(name))) {\n\t\tfwarning(\"cannot clean %s directory\\n\", name);\n\t\treturn; // we live to fight another day!\n\t}\n\n\t// clean leftover files\n\tstruct dirent *entry;\n\tchar *end;\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\tpid_t pid = strtol(entry->d_name, &end, 10);\n\t\tpid %= max_pids;\n\t\tif (end == entry->d_name || *end)\n\t\t\tcontinue;\n\n\t\tif (pid < start_pid)\n\t\t\tcontinue;\n\t\tif (pidarr[pid] == 0)\n\t\t\tdelete_run_files(pid);\n\t}\n\tclosedir(dir);\n}\n\n\n// clean run directory\nvoid preproc_clean_run(void) {\n\tint max_pids=32769;\n\tint start_pid = 100;\n\t// extract real max_pids\n\tFILE *fp = fopen(\"/proc/sys/kernel/pid_max\", \"r\");\n\tif (fp) {\n\t\tint val;\n\t\tif (fscanf(fp, \"%d\", &val) == 1) {\n\t\t\tif (val > 4194304)\t// this is the max value supported on 64 bit Linux kernels\n\t\t\t\tval = 4194304;\n\t\t\tif (val >= max_pids)\n\t\t\t\tmax_pids = val + 1;\n\t\t}\n\t\tfclose(fp);\n\t}\n\tint *pidarr = malloc(max_pids * sizeof(int));\n\tif (!pidarr)\n\t\terrExit(\"malloc\");\n\n\tmemset(pidarr, 0, max_pids * sizeof(int));\n\n\t// open /proc directory\n\tDIR *dir;\n\tif (!(dir = opendir(\"/proc\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// read /proc and populate pidarr with all active processes\n\tstruct dirent *entry;\n\tchar *end;\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\tpid_t pid = strtol(entry->d_name, &end, 10);\n\t\tpid %= max_pids;\n\t\tif (end == entry->d_name || *end)\n\t\t\tcontinue;\n\n\t\tif (pid < start_pid)\n\t\t\tcontinue;\n\t\tpidarr[pid] = 1;\n\t}\n\tclosedir(dir);\n\n\t// clean profile and name directories\n\tclean_dir(RUN_FIREJAIL_PROFILE_DIR, pidarr, start_pid, max_pids);\n\tclean_dir(RUN_FIREJAIL_NAME_DIR, pidarr, start_pid, max_pids);\n\n\tfree(pidarr);\n}\n", "/*\n * Copyright (C) 2014-2019 Firejail Authors\n *\n * This file is part of firejail project\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n\n#include \"firejail.h\"\n#include <sys/mount.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <errno.h>\n#include <fcntl.h>\n\n#include <sched.h>\n#ifndef CLONE_NEWUSER\n#define CLONE_NEWUSER\t0x10000000\n#endif\n\n#include <sys/prctl.h>\n#ifndef PR_SET_NO_NEW_PRIVS\n# define PR_SET_NO_NEW_PRIVS 38\n#endif\n#ifndef PR_GET_NO_NEW_PRIVS\n# define PR_GET_NO_NEW_PRIVS 39\n#endif\n\n#ifdef HAVE_APPARMOR\n#include <sys/apparmor.h>\n#endif\n#include <syscall.h>\n\n\nstatic int force_nonewprivs = 0;\n\nstatic int monitored_pid = 0;\nstatic void sandbox_handler(int sig){\n\tusleep(10000); // don't race to print a message\n\tfmessage(\"\\nChild received signal %d, shutting down the sandbox...\\n\", sig);\n\n\t// broadcast sigterm to all processes in the group\n\tkill(-1, SIGTERM);\n\tsleep(1);\n\n\tif (monitored_pid) {\n\t\tint monsec = 9;\n\t\tchar *monfile;\n\t\tif (asprintf(&monfile, \"/proc/%d/cmdline\", monitored_pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\twhile (monsec) {\n\t\t\tFILE *fp = fopen(monfile, \"r\");\n\t\t\tif (!fp)\n\t\t\t\tbreak;\n\n\t\t\tchar c;\n\t\t\tsize_t count = fread(&c, 1, 1, fp);\n\t\t\tfclose(fp);\n\t\t\tif (count == 0)\n\t\t\t\tbreak;\n\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Waiting on PID %d to finish\\n\", monitored_pid);\n\t\t\tsleep(1);\n\t\t\tmonsec--;\n\t\t}\n\t\tfree(monfile);\n\t}\n\n\t// broadcast a SIGKILL\n\tkill(-1, SIGKILL);\n\tflush_stdin();\n\n\texit(sig);\n}\n\nstatic void install_handler(void) {\n\tstruct sigaction sga;\n\n\t// block SIGTERM while handling SIGINT\n\tsigemptyset(&sga.sa_mask);\n\tsigaddset(&sga.sa_mask, SIGTERM);\n\tsga.sa_handler = sandbox_handler;\n\tsga.sa_flags = 0;\n\tsigaction(SIGINT, &sga, NULL);\n\n\t// block SIGINT while handling SIGTERM\n\tsigemptyset(&sga.sa_mask);\n\tsigaddset(&sga.sa_mask, SIGINT);\n\tsga.sa_handler = sandbox_handler;\n\tsga.sa_flags = 0;\n\tsigaction(SIGTERM, &sga, NULL);\n}\n\nstatic void set_caps(void) {\n\tif (arg_caps_drop_all)\n\t\tcaps_drop_all();\n\telse if (arg_caps_drop)\n\t\tcaps_drop_list(arg_caps_list);\n\telse if (arg_caps_keep)\n\t\tcaps_keep_list(arg_caps_list);\n\telse if (arg_caps_default_filter)\n\t\tcaps_default_filter();\n\n\t// drop discretionary access control capabilities for root sandboxes\n\t// if caps.keep, the user has to set it manually in the list\n\tif (!arg_caps_keep)\n\t\tcaps_drop_dac_override();\n}\n\nstatic void save_nogroups(void) {\n\tif (arg_nogroups == 0)\n\t\treturn;\n\n\tFILE *fp = fopen(RUN_GROUPS_CFG, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644); // assume mode 0644\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot save nogroups state\\n\");\n\t\texit(1);\n\t}\n}\n\nstatic void save_nonewprivs(void) {\n\tif (arg_nonewprivs == 0)\n\t\treturn;\n\n\tFILE *fp = fopen(RUN_NONEWPRIVS_CFG, \"wxe\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644); // assume mode 0644\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot save nonewprivs state\\n\");\n\t\texit(1);\n\t}\n}\n\nstatic void save_umask(void) {\n\tFILE *fp = fopen(RUN_UMASK_FILE, \"wxe\");\n\tif (fp) {\n\t\tfprintf(fp, \"%o\\n\", orig_umask);\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644); // assume mode 0644\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot save umask\\n\");\n\t\texit(1);\n\t}\n}\n\nstatic FILE *create_ready_for_join_file(void) {\n\tFILE *fp = fopen(RUN_READY_FOR_JOIN, \"wxe\");\n\tif (fp) {\n\t\tASSERT_PERMS_STREAM(fp, 0, 0, 0644);\n\t\treturn fp;\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot create %s\\n\", RUN_READY_FOR_JOIN);\n\t\texit(1);\n\t}\n}\n\nstatic void sandbox_if_up(Bridge *br) {\n\tassert(br);\n\tif (!br->configured)\n\t\treturn;\n\n\tchar *dev = br->devsandbox;\n\tnet_if_up(dev);\n\n\tif (br->arg_ip_none == 1);\t// do nothing\n\telse if (br->arg_ip_none == 0 && br->macvlan == 0) {\n\t\tif (br->ipsandbox == br->ip) {\n\t\t\tfprintf(stderr, \"Error: %d.%d.%d.%d is interface %s address.\\n\", PRINT_IP(br->ipsandbox), br->dev);\n\t\t\texit(1);\n\t\t}\n\n\t\t// just assign the address\n\t\tassert(br->ipsandbox);\n\t\tif (arg_debug)\n\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(br->ipsandbox), dev);\n\t\tnet_config_interface(dev, br->ipsandbox, br->mask, br->mtu);\n\t\tarp_announce(dev, br);\n\t}\n\telse if (br->arg_ip_none == 0 && br->macvlan == 1) {\n\t\t// reassign the macvlan address\n\t\tif (br->ipsandbox == 0)\n\t\t\t// ip address assigned by arp-scan for a macvlan device\n\t\t\tbr->ipsandbox = arp_assign(dev, br); //br->ip, br->mask);\n\t\telse {\n\t\t\tif (br->ipsandbox == br->ip) {\n\t\t\t\tfprintf(stderr, \"Error: %d.%d.%d.%d is interface %s address.\\n\", PRINT_IP(br->ipsandbox), br->dev);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tuint32_t rv = arp_check(dev, br->ipsandbox);\n\t\t\tif (rv) {\n\t\t\t\tfprintf(stderr, \"Error: the address %d.%d.%d.%d is already in use.\\n\", PRINT_IP(br->ipsandbox));\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tif (arg_debug)\n\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(br->ipsandbox), dev);\n\t\tnet_config_interface(dev, br->ipsandbox, br->mask, br->mtu);\n\t\tarp_announce(dev, br);\n\t}\n\n\tif (br->ip6sandbox)\n\t\t net_if_ip6(dev, br->ip6sandbox);\n}\n\nstatic void chk_chroot(void) {\n\t// if we are starting firejail inside some other container technology, we don't care about this\n\tchar *mycont = getenv(\"container\");\n\tif (mycont)\n\t\treturn;\n\n\t// check if this is a regular chroot\n\tstruct stat s;\n\tif (stat(\"/\", &s) == 0) {\n\t\tif (s.st_ino != 2)\n\t\t\treturn;\n\t}\n\n\tfprintf(stderr, \"Error: cannot mount filesystem as slave\\n\");\n\texit(1);\n}\n\nstatic int monitor_application(pid_t app_pid) {\n\tEUID_ASSERT();\n\tmonitored_pid = app_pid;\n\n\t// block signals and install handler\n\tsigset_t oldmask, newmask;\n\tsigemptyset(&oldmask);\n\tsigemptyset(&newmask);\n\tsigaddset(&newmask, SIGTERM);\n\tsigaddset(&newmask, SIGINT);\n\tsigprocmask(SIG_BLOCK, &newmask, &oldmask);\n\tinstall_handler();\n\n\t// handle --timeout\n\tint options = 0;;\n\tunsigned timeout = 0;\n\tif (cfg.timeout) {\n\t\toptions = WNOHANG;\n\t\ttimeout = cfg.timeout;\n\t}\n\n\tint status = 0;\n\twhile (monitored_pid) {\n\t\tusleep(20000);\n\t\tchar *msg;\n\t\tif (asprintf(&msg, \"monitoring pid %d\\n\", monitored_pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tlogmsg(msg);\n\t\tif (arg_debug)\n\t\t\tprintf(\"%s\\n\", msg);\n\t\tfree(msg);\n\n\t\tpid_t rv;\n\t\tdo {\n\t\t\t// handle signals asynchronously\n\t\t\tsigprocmask(SIG_SETMASK, &oldmask, NULL);\n\n\t\t\trv = waitpid(-1, &status, options);\n\n\t\t\t// block signals again\n\t\t\tsigprocmask(SIG_BLOCK, &newmask, NULL);\n\n\t\t\tif (rv == -1) { // we can get here if we have processes joining the sandbox (ECHILD)\n\t\t\t\tsleep(1);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// handle --timeout\n\t\t\tif (options) {\n\t\t\t\tif (--timeout == 0)  {\n\t\t\t\t\tkill(-1, SIGTERM);\n\t\t\t\t\tsleep(1);\n\t\t\t\t\tflush_stdin();\n\t\t\t\t\t_exit(1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsleep(1);\n\t\t\t}\n\t\t}\n\t\twhile(rv != monitored_pid);\n\t\tif (arg_debug)\n\t\t\tprintf(\"Sandbox monitor: waitpid %d retval %d status %d\\n\", monitored_pid, rv, status);\n\n\t\tDIR *dir;\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\t// sleep 2 seconds and try again\n\t\t\tsleep(2);\n\t\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tstruct dirent *entry;\n\t\tmonitored_pid = 0;\n\t\twhile ((entry = readdir(dir)) != NULL) {\n\t\t\tunsigned pid;\n\t\t\tif (sscanf(entry->d_name, \"%u\", &pid) != 1)\n\t\t\t\tcontinue;\n\t\t\tif (pid == 1)\n\t\t\t\tcontinue;\n\n\t\t\t// todo: make this generic\n\t\t\t// Dillo browser leaves a dpid process running, we need to shut it down\n\t\t\tint found = 0;\n\t\t\tif (strcmp(cfg.command_name, \"dillo\") == 0) {\n\t\t\t\tchar *pidname = pid_proc_comm(pid);\n\t\t\t\tif (pidname && strcmp(pidname, \"dpid\") == 0)\n\t\t\t\t\tfound = 1;\n\t\t\t\tfree(pidname);\n\t\t\t}\n\t\t\tif (found)\n\t\t\t\tbreak;\n\n\t\t\tmonitored_pid = pid;\n\t\t\tbreak;\n\t\t}\n\t\tclosedir(dir);\n\n\t\tif (monitored_pid != 0 && arg_debug)\n\t\t\tprintf(\"Sandbox monitor: monitoring %d\\n\", monitored_pid);\n\t}\n\n\t// return the latest exit status.\n\treturn status;\n}\n\nstatic void print_time(void) {\n\tif (start_timestamp) {\n\t\tunsigned long long end_timestamp = getticks();\n\t\t// measure 1 ms\n\t\tusleep(1000);\n\t\tunsigned long long onems = getticks() - end_timestamp;\n\t\tif (onems) {\n\t\t\tfmessage(\"Child process initialized in %.02f ms\\n\",\n\t\t\t\t(float) (end_timestamp - start_timestamp) / (float) onems);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfmessage(\"Child process initialized\\n\");\n}\n\n\n// check execute permissions for the program\n// this is done typically by the shell\n// we are here because of --shell=none\n// we duplicate execvp functionality (man execvp):\n//\t[...] if  the  specified\n//\tfilename  does  not contain a slash (/) character. The file is sought\n//\tin the colon-separated list of directory pathnames  specified  in  the\n//\tPATH  environment  variable.\nstatic int ok_to_run(const char *program) {\n\tif (strstr(program, \"/\")) {\n\t\tif (access(program, X_OK) == 0) // it will also dereference symlinks\n\t\t\treturn 1;\n\t}\n\telse { // search $PATH\n\t\tchar *path1 = getenv(\"PATH\");\n\t\tif (path1) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Searching $PATH for %s\\n\", program);\n\t\t\tchar *path2 = strdup(path1);\n\t\t\tif (!path2)\n\t\t\t\terrExit(\"strdup\");\n\n\t\t\t// use path2 to count the entries\n\t\t\tchar *ptr = strtok(path2, \":\");\n\t\t\twhile (ptr) {\n\t\t\t\tchar *fname;\n\n\t\t\t\tif (asprintf(&fname, \"%s/%s\", ptr, program) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"trying #%s#\\n\", fname);\n\n\t\t\t\tstruct stat s;\n\t\t\t\tint rv = stat(fname, &s);\n\t\t\t\tif (rv == 0) {\n\t\t\t\t\tif (access(fname, X_OK) == 0) {\n\t\t\t\t\t\tfree(path2);\n\t\t\t\t\t\tfree(fname);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tfprintf(stderr, \"Error: execute permission denied for %s\\n\", fname);\n\n\t\t\t\t\tfree(fname);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfree(fname);\n\t\t\t\tptr = strtok(NULL, \":\");\n\t\t\t}\n\t\t\tfree(path2);\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid start_application(int no_sandbox, FILE *fp) {\n\t// set environment\n\tif (no_sandbox == 0) {\n\t\tenv_defaults();\n\t\tenv_apply();\n\t}\n\t// restore original umask\n\tumask(orig_umask);\n\n\tif (arg_debug) {\n\t\tprintf(\"starting application\\n\");\n\t\tprintf(\"LD_PRELOAD=%s\\n\", getenv(\"LD_PRELOAD\"));\n\t}\n\n\t//****************************************\n\t// audit\n\t//****************************************\n\tif (arg_audit) {\n\t\tassert(arg_audit_prog);\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"ready\\n\");\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n#ifdef HAVE_SECCOMP\n\t\tseccomp_install_filters();\n#endif\n\t\texecl(arg_audit_prog, arg_audit_prog, NULL);\n\n\t\tperror(\"execl\");\n\t\texit(1);\n\t}\n\t//****************************************\n\t// start the program without using a shell\n\t//****************************************\n\telse if (arg_shell_none) {\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = cfg.original_program_index; i < cfg.original_argc; i++) {\n\t\t\t\tif (cfg.original_argv[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i - cfg.original_program_index, cfg.original_argv[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (cfg.original_program_index == 0) {\n\t\t\tfprintf(stderr, \"Error: --shell=none configured, but no program specified\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprint_time();\n\n\t\tint rv = ok_to_run(cfg.original_argv[cfg.original_program_index]);\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"ready\\n\");\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n#ifdef HAVE_SECCOMP\n\t\tseccomp_install_filters();\n#endif\n\t\tif (rv)\n\t\t\texecvp(cfg.original_argv[cfg.original_program_index], &cfg.original_argv[cfg.original_program_index]);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: no suitable %s executable found\\n\", cfg.original_argv[cfg.original_program_index]);\n\t\texit(1);\n\t}\n\t//****************************************\n\t// start the program using a shell\n\t//****************************************\n\telse {\n\t\tassert(cfg.shell);\n\t\tassert(cfg.command_line);\n\n\t\tchar *arg[5];\n\t\tint index = 0;\n\t\targ[index++] = cfg.shell;\n\t\tif (login_shell) {\n\t\t\targ[index++] = \"-l\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Starting %s login shell\\n\", cfg.shell);\n\t\t} else {\n\t\t\targ[index++] = \"-c\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Running %s command through %s\\n\", cfg.command_line, cfg.shell);\n\t\t\tif (arg_doubledash)\n\t\t\t\targ[index++] = \"--\";\n\t\t\targ[index++] = cfg.command_line;\n\t\t}\n\t\targ[index] = NULL;\n\t\tassert(index < 5);\n\n\t\tif (arg_debug) {\n\t\t\tchar *msg;\n\t\t\tif (asprintf(&msg, \"sandbox %d, execvp into %s\", sandbox_pid, cfg.command_line) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tlogmsg(msg);\n\t\t\tfree(msg);\n\t\t}\n\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < 5; i++) {\n\t\t\t\tif (arg[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i, arg[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprint_time();\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"ready\\n\");\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n#ifdef HAVE_SECCOMP\n\t\tseccomp_install_filters();\n#endif\n\t\texecvp(arg[0], arg);\n\t}\n\n\tperror(\"execvp\");\n\texit(1); // it should never get here!!!\n}\n\nstatic void enforce_filters(void) {\n\t// enforce NO_NEW_PRIVS\n\targ_nonewprivs = 1;\n\tforce_nonewprivs = 1;\n\n\t// disable all capabilities\n\tfmessage(\"\\n**     Warning: dropping all Linux capabilities     **\\n\");\n\targ_caps_drop_all = 1;\n\n\t// drop all supplementary groups; /etc/group file inside chroot\n\t// is controlled by a regular usr\n\targ_nogroups = 1;\n}\n\nint sandbox(void* sandbox_arg) {\n\t// Get rid of unused parameter warning\n\t(void)sandbox_arg;\n\n\tpid_t child_pid = getpid();\n\tif (arg_debug)\n\t\tprintf(\"Initializing child process\\n\");\n\n \t// close each end of the unused pipes\n \tclose(parent_to_child_fds[1]);\n \tclose(child_to_parent_fds[0]);\n\n \t// wait for parent to do base setup\n \twait_for_other(parent_to_child_fds[0]);\n\n\tif (arg_debug && child_pid == 1)\n\t\tprintf(\"PID namespace installed\\n\");\n\n\n\t//****************************\n\t// set hostname\n\t//****************************\n\tif (cfg.hostname) {\n\t\tif (sethostname(cfg.hostname, strlen(cfg.hostname)) < 0)\n\t\t\terrExit(\"sethostname\");\n\t}\n\n\t//****************************\n\t// mount namespace\n\t//****************************\n\t// mount events are not forwarded between the host the sandbox\n\tif (mount(NULL, \"/\", NULL, MS_SLAVE | MS_REC, NULL) < 0) {\n\t\tchk_chroot();\n\t}\n\t// ... and mount a tmpfs on top of /run/firejail/mnt directory\n\tpreproc_mount_mnt_dir();\n\t// bind-mount firejail binaries and helper programs\n\tif (mount(LIBDIR \"/firejail\", RUN_FIREJAIL_LIB_DIR, \"none\", MS_BIND, NULL) < 0)\n\t\terrExit(\"mounting \" RUN_FIREJAIL_LIB_DIR);\n\n\t//****************************\n\t// log sandbox data\n\t//****************************\n\tif (cfg.name)\n\t\tfs_logger2(\"sandbox name:\", cfg.name);\n\tfs_logger2int(\"sandbox pid:\", (int) sandbox_pid);\n\tif (cfg.chrootdir)\n\t\tfs_logger(\"sandbox filesystem: chroot\");\n\telse if (arg_overlay)\n\t\tfs_logger(\"sandbox filesystem: overlay\");\n\telse\n\t\tfs_logger(\"sandbox filesystem: local\");\n\tfs_logger(\"install mount namespace\");\n\n\t//****************************\n\t// netfilter\n\t//****************************\n\tif (arg_netfilter && any_bridge_configured()) { // assuming by default the client filter\n\t\tnetfilter(arg_netfilter_file);\n\t}\n\tif (arg_netfilter6 && any_bridge_configured()) { // assuming by default the client filter\n\t\tnetfilter6(arg_netfilter6_file);\n\t}\n\n\t//****************************\n\t// networking\n\t//****************************\n\tint gw_cfg_failed = 0; // default gw configuration flag\n\tif (arg_nonetwork) {\n\t\tnet_if_up(\"lo\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Network namespace enabled, only loopback interface available\\n\");\n\t}\n\telse if (arg_netns) {\n\t\tnetns(arg_netns);\n\t\tif (arg_debug)\n\t\t\tprintf(\"Network namespace '%s' activated\\n\", arg_netns);\n\t}\n\telse if (any_bridge_configured() || any_interface_configured()) {\n\t\t// configure lo and eth0...eth3\n\t\tnet_if_up(\"lo\");\n\n\t\tif (mac_not_zero(cfg.bridge0.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge0.devsandbox, cfg.bridge0.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge0);\n\n\t\tif (mac_not_zero(cfg.bridge1.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge1.devsandbox, cfg.bridge1.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge1);\n\n\t\tif (mac_not_zero(cfg.bridge2.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge2.devsandbox, cfg.bridge2.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge2);\n\n\t\tif (mac_not_zero(cfg.bridge3.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge3.devsandbox, cfg.bridge3.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge3);\n\n\n\t\t// moving an interface in a namespace using --interface will reset the interface configuration;\n\t\t// we need to put the configuration back\n\t\tif (cfg.interface0.configured && cfg.interface0.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface0.ip), cfg.interface0.dev);\n\t\t\tnet_config_interface(cfg.interface0.dev, cfg.interface0.ip, cfg.interface0.mask, cfg.interface0.mtu);\n\t\t}\n\t\tif (cfg.interface1.configured && cfg.interface1.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface1.ip), cfg.interface1.dev);\n\t\t\tnet_config_interface(cfg.interface1.dev, cfg.interface1.ip, cfg.interface1.mask, cfg.interface1.mtu);\n\t\t}\n\t\tif (cfg.interface2.configured && cfg.interface2.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface2.ip), cfg.interface2.dev);\n\t\t\tnet_config_interface(cfg.interface2.dev, cfg.interface2.ip, cfg.interface2.mask, cfg.interface2.mtu);\n\t\t}\n\t\tif (cfg.interface3.configured && cfg.interface3.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface3.ip), cfg.interface3.dev);\n\t\t\tnet_config_interface(cfg.interface3.dev, cfg.interface3.ip, cfg.interface3.mask, cfg.interface3.mtu);\n\t\t}\n\n\t\t// add a default route\n\t\tif (cfg.defaultgw) {\n\t\t\t// set the default route\n\t\t\tif (net_add_route(0, 0, cfg.defaultgw)) {\n\t\t\t\tfwarning(\"cannot configure default route\\n\");\n\t\t\t\tgw_cfg_failed = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (arg_debug)\n\t\t\tprintf(\"Network namespace enabled\\n\");\n\t}\n\n\t// print network configuration\n\tif (!arg_quiet) {\n\t\tif (any_bridge_configured() || any_interface_configured() || cfg.defaultgw || cfg.dns1) {\n\t\t\tfmessage(\"\\n\");\n\t\t\tif (any_bridge_configured() || any_interface_configured()) {\n\t\t\t\tif (arg_scan)\n\t\t\t\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 3, PATH_FNET, \"printif\", \"scan\");\n\t\t\t\telse\n\t\t\t\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 2, PATH_FNET, \"printif\");\n\n\t\t\t}\n\t\t\tif (cfg.defaultgw != 0) {\n\t\t\t\tif (gw_cfg_failed)\n\t\t\t\t\tfmessage(\"Default gateway configuration failed\\n\");\n\t\t\t\telse\n\t\t\t\t\tfmessage(\"Default gateway %d.%d.%d.%d\\n\", PRINT_IP(cfg.defaultgw));\n\t\t\t}\n\t\t\tif (cfg.dns1 != NULL)\n\t\t\t\tfmessage(\"DNS server %s\\n\", cfg.dns1);\n\t\t\tif (cfg.dns2 != NULL)\n\t\t\t\tfmessage(\"DNS server %s\\n\", cfg.dns2);\n\t\t\tif (cfg.dns3 != NULL)\n\t\t\t\tfmessage(\"DNS server %s\\n\", cfg.dns3);\n\t\t\tif (cfg.dns4 != NULL)\n\t\t\t\tfmessage(\"DNS server %s\\n\", cfg.dns4);\n\t\t\tfmessage(\"\\n\");\n\t\t}\n\t}\n\n\t// load IBUS env variables\n\tif (arg_nonetwork || any_bridge_configured() || any_interface_configured()) {\n\t\t// do nothing - there are problems with ibus version 1.5.11\n\t}\n\telse {\n\t\tEUID_USER();\n\t\tenv_ibus_load();\n\t\tEUID_ROOT();\n\t}\n\n\t//****************************\n\t// fs pre-processing:\n\t//  - build seccomp filters\n\t//  - create an empty /etc/ld.so.preload\n\t//****************************\n#ifdef HAVE_SECCOMP\n\tif (cfg.protocol) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Build protocol filter: %s\\n\", cfg.protocol);\n\n\t\t// build the seccomp filter as a regular user\n\t\tint rv = sbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 5,\n\t\t\tPATH_FSECCOMP, \"protocol\", \"build\", cfg.protocol, RUN_SECCOMP_PROTOCOL);\n\t\tif (rv)\n\t\t\texit(rv);\n\t}\n\tif (arg_seccomp && (cfg.seccomp_list || cfg.seccomp_list_drop || cfg.seccomp_list_keep))\n\t\targ_seccomp_postexec = 1;\n#endif\n\n\t// need ld.so.preload if tracing or seccomp with any non-default lists\n\tbool need_preload = arg_trace || arg_tracelog || arg_seccomp_postexec;\n\t// for --appimage, --chroot and --overlay* we force NO_NEW_PRIVS\n\t// and drop all capabilities\n\tif (getuid() != 0 && (arg_appimage || cfg.chrootdir || arg_overlay)) {\n\t\tenforce_filters();\n\t\tneed_preload = arg_trace || arg_tracelog;\n\t}\n\n\t// trace pre-install\n\tif (need_preload)\n\t\tfs_trace_preload();\n\n\t// store hosts file\n\tif (cfg.hosts_file)\n\t\tfs_store_hosts_file();\n\n\t//****************************\n\t// configure filesystem\n\t//****************************\n#ifdef HAVE_CHROOT\n\tif (cfg.chrootdir) {\n\t\tfs_chroot(cfg.chrootdir);\n\n\t\t//****************************\n\t\t// trace pre-install, this time inside chroot\n\t\t//****************************\n\t\tif (need_preload)\n\t\t\tfs_trace_preload();\n\t}\n\telse\n#endif\n#ifdef HAVE_OVERLAYFS\n\tif (arg_overlay)\n\t\tfs_overlayfs();\n\telse\n#endif\n\t\tfs_basic_fs();\n\n\t//****************************\n\t// private mode\n\t//****************************\n\tif (arg_private) {\n\t\tif (cfg.home_private) {\t// --private=\n\t\t\tif (cfg.chrootdir)\n\t\t\t\tfwarning(\"private=directory feature is disabled in chroot\\n\");\n\t\t\telse if (arg_overlay)\n\t\t\t\tfwarning(\"private=directory feature is disabled in overlay\\n\");\n\t\t\telse\n\t\t\t\tfs_private_homedir();\n\t\t}\n\t\telse if (cfg.home_private_keep) { // --private-home=\n\t\t\tif (cfg.chrootdir)\n\t\t\t\tfwarning(\"private-home= feature is disabled in chroot\\n\");\n\t\t\telse if (arg_overlay)\n\t\t\t\tfwarning(\"private-home= feature is disabled in overlay\\n\");\n\t\t\telse\n\t\t\t\tfs_private_home_list();\n\t\t}\n\t\telse // --private\n\t\t\tfs_private();\n\t}\n\n\tif (arg_private_dev)\n\t\tfs_private_dev();\n\n\tif (arg_private_etc) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-etc feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-etc feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\tfs_private_dir_list(\"/etc\", RUN_ETC_DIR, cfg.etc_private_keep);\n\t\t\t// create /etc/ld.so.preload file again\n\t\t\tif (need_preload)\n\t\t\t\tfs_trace_preload();\n\t\t}\n\t}\n\n\tif (arg_private_opt) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-opt feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-opt feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\tfs_private_dir_list(\"/opt\", RUN_OPT_DIR, cfg.opt_private_keep);\n\t\t}\n\t}\n\n\tif (arg_private_srv) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-srv feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-srv feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\tfs_private_dir_list(\"/srv\", RUN_SRV_DIR, cfg.srv_private_keep);\n\t\t}\n\t}\n\n\t// private-bin is disabled for appimages\n\tif (arg_private_bin && !arg_appimage) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-bin feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-bin feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\t// for --x11=xorg we need to add xauth command\n\t\t\tif (arg_x11_xorg) {\n\t\t\t\tEUID_USER();\n\t\t\t\tchar *tmp;\n\t\t\t\tif (asprintf(&tmp, \"%s,xauth\", cfg.bin_private_keep) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tcfg.bin_private_keep = tmp;\n\t\t\t\tEUID_ROOT();\n\t\t\t}\n\t\t\tfs_private_bin_list();\n\t\t}\n\t}\n\n\t// private-lib is disabled for appimages\n\tif (arg_private_lib && !arg_appimage) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-lib feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-lib feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\tfs_private_lib();\n\t\t}\n\t}\n\n\tif (arg_private_cache) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-cache feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-cache feature is disabled in overlay\\n\");\n\t\telse\n\t\t\tfs_private_cache();\n\t}\n\n\tif (arg_private_tmp) {\n\t\t// private-tmp is implemented as a whitelist\n\t\tEUID_USER();\n\t\tfs_private_tmp();\n\t\tEUID_ROOT();\n\t}\n\n\t//****************************\n\t// Session D-BUS\n\t//****************************\n\tif (arg_nodbus)\n\t\tdbus_session_disable();\n\n\n\t//****************************\n\t// hosts and hostname\n\t//****************************\n\tif (cfg.hostname)\n\t\tfs_hostname(cfg.hostname);\n\n\tif (cfg.hosts_file)\n\t\tfs_mount_hosts_file();\n\n\t//****************************\n\t// /etc overrides from the network namespace\n\t//****************************\n\tif (arg_netns)\n\t\tnetns_mounts(arg_netns);\n\n\t//****************************\n\t// update /proc, /sys, /dev, /boot directory\n\t//****************************\n\tfs_proc_sys_dev_boot();\n\n\t//****************************\n\t// handle /mnt and /media\n\t//****************************\n\tif (checkcfg(CFG_DISABLE_MNT))\n\t\tfs_mnt(1);\n\telse if (arg_disable_mnt)\n\t\tfs_mnt(0);\n\n\t//****************************\n\t// apply the profile file\n\t//****************************\n\t// apply all whitelist commands ...\n\tfs_whitelist();\n\n\t// ... followed by blacklist commands\n\tfs_blacklist(); // mkdir and mkfile are processed all over again\n\n\t//****************************\n\t// nosound/no3d/notv/novideo and fix for pulseaudio 7.0\n\t//****************************\n\tif (arg_nosound) {\n\t\t// disable pulseaudio\n\t\tpulseaudio_disable();\n\n\t\t// disable /dev/snd\n\t\tfs_dev_disable_sound();\n\t}\n\telse if (!arg_noautopulse)\n\t\tpulseaudio_init();\n\n\tif (arg_no3d)\n\t\tfs_dev_disable_3d();\n\n\tif (arg_notv)\n\t\tfs_dev_disable_tv();\n\n\tif (arg_nodvd)\n\t\tfs_dev_disable_dvd();\n\n\tif (arg_nou2f)\n\t        fs_dev_disable_u2f();\n\n\tif (arg_novideo)\n\t\tfs_dev_disable_video();\n\n\t//****************************\n\t// install trace\n\t//****************************\n\tif (need_preload)\n\t\tfs_trace();\n\n\t//****************************\n\t// set dns\n\t//****************************\n\tfs_resolvconf();\n\n\t//****************************\n\t// fs post-processing\n\t//****************************\n\tfs_logger_print();\n\tfs_logger_change_owner();\n\n\t//****************************\n\t// set application environment\n\t//****************************\n\tEUID_USER();\n\tint cwd = 0;\n\tif (cfg.cwd) {\n\t\tif (chdir(cfg.cwd) == 0)\n\t\t\tcwd = 1;\n\t}\n\n\tif (!cwd) {\n\t\tif (chdir(\"/\") < 0)\n\t\t\terrExit(\"chdir\");\n\t\tif (cfg.homedir) {\n\t\t\tstruct stat s;\n\t\t\tif (stat(cfg.homedir, &s) == 0) {\n\t\t\t\t/* coverity[toctou] */\n\t\t\t\tif (chdir(cfg.homedir) < 0)\n\t\t\t\t\terrExit(\"chdir\");\n\t\t\t}\n\t\t}\n\t}\n\tif (arg_debug) {\n\t\tchar *cpath = get_current_dir_name();\n\t\tif (cpath) {\n\t\t\tprintf(\"Current directory: %s\\n\", cpath);\n\t\t\tfree(cpath);\n\t\t}\n\t}\n\n\tEUID_ROOT();\n\t// clean /tmp/.X11-unix sockets\n\tfs_x11();\n\tif (arg_x11_xorg)\n\t\tx11_xorg();\n\n\t// save original umask\n\tsave_umask();\n\n\t//****************************\n\t// set security filters\n\t//****************************\n\t// save state of nonewprivs\n\tsave_nonewprivs();\n\n\t// set capabilities\n\tset_caps();\n\n\t// save cpu affinity mask to CPU_CFG file\n\tsave_cpu();\n\n\t// save cgroup in CGROUP_CFG file\n\tsave_cgroup();\n\n\t// set seccomp\n#ifdef HAVE_SECCOMP\n\t// install protocol filter\n#ifdef SYS_socket\n\tif (cfg.protocol) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Install protocol filter: %s\\n\", cfg.protocol);\n\t\tseccomp_load(RUN_SECCOMP_PROTOCOL);\t// install filter\n\t\tprotocol_filter_save();\t// save filter in RUN_PROTOCOL_CFG\n\t}\n\telse {\n\t\tint rv = unlink(RUN_SECCOMP_PROTOCOL);\n\t\t(void) rv;\n\t}\n#endif\n\n\t// if a keep list is available, disregard the drop list\n\tif (arg_seccomp == 1) {\n\t\tif (cfg.seccomp_list_keep)\n\t\t\tseccomp_filter_keep();\n\t\telse\n\t\t\tseccomp_filter_drop();\n\n\t}\n\telse { // clean seccomp files under /run/firejail/mnt\n\t\tint rv = unlink(RUN_SECCOMP_CFG);\n\t\trv |= unlink(RUN_SECCOMP_32);\n\t\t(void) rv;\n\t}\n\n\tif (arg_memory_deny_write_execute) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Install memory write&execute filter\\n\");\n\t\tseccomp_load(RUN_SECCOMP_MDWX);\t// install filter\n\t}\n\telse {\n\t\tint rv = unlink(RUN_SECCOMP_MDWX);\n\t\t(void) rv;\n\t}\n#endif\n\n\t//****************************************\n\t// communicate progress of sandbox set up\n\t// to --join\n\t//****************************************\n\n\tFILE *rj = create_ready_for_join_file();\n\n\t//****************************************\n\t// create a new user namespace\n\t//     - too early to drop privileges\n\t//****************************************\n\tsave_nogroups();\n\tif (arg_noroot) {\n\t\tint rv = unshare(CLONE_NEWUSER);\n\t\tif (rv == -1) {\n\t\t\tfwarning(\"cannot create a new user namespace, going forward without it...\\n\");\n\t\t\targ_noroot = 0;\n\t\t}\n\t}\n\n\t// notify parent that new user namespace has been created so a proper\n \t// UID/GID map can be setup\n \tnotify_other(child_to_parent_fds[1]);\n \tclose(child_to_parent_fds[1]);\n\n \t// wait for parent to finish setting up a proper UID/GID map\n \twait_for_other(parent_to_child_fds[0]);\n \tclose(parent_to_child_fds[0]);\n\n\t// somehow, the new user namespace resets capabilities;\n\t// we need to do them again\n\tif (arg_noroot) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"noroot user namespace installed\\n\");\n\t\tset_caps();\n\t}\n\n\t//****************************************\n\t// Set NO_NEW_PRIVS if desired\n\t//****************************************\n\tif (arg_nonewprivs) {\n\t\tprctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\n\t\tif (prctl(PR_GET_NO_NEW_PRIVS, 0, 0, 0, 0) != 1) {\n\t\t\tfwarning(\"cannot set NO_NEW_PRIVS, it requires a Linux kernel version 3.5 or newer.\\n\");\n\t\t\tif (force_nonewprivs) {\n\t\t\t\tfprintf(stderr, \"Error: NO_NEW_PRIVS required for this sandbox, exiting ...\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (arg_debug)\n\t\t\tprintf(\"NO_NEW_PRIVS set\\n\");\n\t}\n\n\t//****************************************\n\t// drop privileges\n\t//****************************************\n\tdrop_privs(arg_nogroups);\n\n\t// kill the sandbox in case the parent died\n\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);\n\n\t//****************************************\n\t// set cpu affinity\n\t//****************************************\n\n\tif (cfg.cpus)\n\t\tset_cpu_affinity();\n\n\t//****************************************\n\t// fork the application and monitor it\n\t//****************************************\n\tpid_t app_pid = fork();\n\tif (app_pid == -1)\n\t\terrExit(\"fork\");\n\n\tif (app_pid == 0) {\n#ifdef HAVE_APPARMOR\n\t\tif (checkcfg(CFG_APPARMOR) && arg_apparmor) {\n\t\t\terrno = 0;\n\t\t\tif (aa_change_onexec(\"firejail-default\")) {\n\t\t\t\tfwarning(\"Cannot confine the application using AppArmor.\\n\"\n\t\t\t\t\t\"Maybe firejail-default AppArmor profile is not loaded into the kernel.\\n\"\n\t\t\t\t\t\"As root, run \\\"aa-enforce firejail-default\\\" to load it.\\n\");\n\t\t\t}\n\t\t\telse if (arg_debug)\n\t\t\t\tprintf(\"AppArmor enabled\\n\");\n\t\t}\n#endif\n\t\t// set nice and rlimits\n\t\tif (arg_nice)\n\t\t\tset_nice(cfg.nice);\n\t\tset_rlimits();\n\n\t\tstart_application(0, rj);\n\t}\n\n\tfclose(rj);\n\n\tint status = monitor_application(app_pid);\t// monitor application\n\tflush_stdin();\n\n\tif (WIFEXITED(status)) {\n\t\t// if we had a proper exit, return that exit status\n\t\treturn WEXITSTATUS(status);\n\t} else {\n\t\t// something else went wrong!\n\t\treturn -1;\n\t}\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2014-2019 Firejail Authors\n *\n * This file is part of firejail project\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n#ifndef FIREJAIL_H\n#define FIREJAIL_H\n#include \"../include/common.h\"\n#include \"../include/euid_common.h\"\n#include <stdarg.h>\n#include <sys/stat.h>\n\n// debug restricted shell\n//#define DEBUG_RESTRICTED_SHELL\n\n// filesystem\n#define RUN_FIREJAIL_BASEDIR\t\"/run\"\n#define RUN_FIREJAIL_DIR\t\"/run/firejail\"\n#define RUN_FIREJAIL_APPIMAGE_DIR\t\"/run/firejail/appimage\"\n#define RUN_FIREJAIL_NAME_DIR\t\"/run/firejail/name\" // also used in src/lib/pid.c - todo: move it in a common place\n#define RUN_FIREJAIL_LIB_DIR\t\t\"/run/firejail/lib\"\n#define RUN_FIREJAIL_X11_DIR\t\"/run/firejail/x11\"\n#define RUN_FIREJAIL_NETWORK_DIR\t\"/run/firejail/network\"\n#define RUN_FIREJAIL_BANDWIDTH_DIR\t\"/run/firejail/bandwidth\"\n#define RUN_FIREJAIL_PROFILE_DIR\t\t\"/run/firejail/profile\"\n#define RUN_NETWORK_LOCK_FILE\t\"/run/firejail/firejail-network.lock\"\n#define RUN_DIRECTORY_LOCK_FILE\t\"/run/firejail/firejail-run.lock\"\n#define RUN_RO_DIR\t\"/run/firejail/firejail.ro.dir\"\n#define RUN_RO_FILE\t\"/run/firejail/firejail.ro.file\"\n#define RUN_MNT_DIR\t\"/run/firejail/mnt\"\t// a tmpfs is mounted on this directory before any of the files below are created\n#define RUN_CGROUP_CFG\t\"/run/firejail/mnt/cgroup\"\n#define RUN_CPU_CFG\t\"/run/firejail/mnt/cpu\"\n#define RUN_GROUPS_CFG\t\"/run/firejail/mnt/groups\"\n#define RUN_PROTOCOL_CFG\t\"/run/firejail/mnt/protocol\"\n#define RUN_NONEWPRIVS_CFG\t\"/run/firejail/mnt/nonewprivs\"\n#define RUN_HOME_DIR\t\"/run/firejail/mnt/home\"\n#define RUN_ETC_DIR\t\"/run/firejail/mnt/etc\"\n#define RUN_OPT_DIR\t\"/run/firejail/mnt/opt\"\n#define RUN_SRV_DIR\t\"/run/firejail/mnt/srv\"\n#define RUN_BIN_DIR\t\"/run/firejail/mnt/bin\"\n#define RUN_PULSE_DIR\t\"/run/firejail/mnt/pulse\"\n#define RUN_LIB_DIR\t\"/run/firejail/mnt/lib\"\n#define RUN_LIB_FILE\t\"/run/firejail/mnt/libfiles\"\n#define RUN_DNS_ETC\t\"/run/firejail/mnt/dns-etc\"\n\n#define RUN_SECCOMP_DIR\t\"/run/firejail/mnt/seccomp\"\n#define RUN_SECCOMP_LIST\t\"/run/firejail/mnt/seccomp/seccomp.list\"\t// list of seccomp files installed\n#define RUN_SECCOMP_PROTOCOL\t\"/run/firejail/mnt/seccomp/seccomp.protocol\"\t// protocol filter\n#define RUN_SECCOMP_CFG\t\"/run/firejail/mnt/seccomp/seccomp\"\t\t\t// configured filter\n#define RUN_SECCOMP_32\t\t\"/run/firejail/mnt/seccomp/seccomp.32\"\t\t// 32bit arch filter installed on 64bit architectures\n#define RUN_SECCOMP_MDWX\t\"/run/firejail/mnt/seccomp/seccomp.mdwx\"\t\t// filter for memory-deny-write-execute\n#define RUN_SECCOMP_BLOCK_SECONDARY\t\"/run/firejail/mnt/seccomp/seccomp.block_secondary\"\t// secondary arch blocking filter\n#define RUN_SECCOMP_POSTEXEC\t\"/run/firejail/mnt/seccomp/seccomp.postexec\"\t\t// filter for post-exec library\n#define PATH_SECCOMP_DEFAULT (LIBDIR \"/firejail/seccomp\")\t\t\t// default filter built during make\n#define PATH_SECCOMP_DEFAULT_DEBUG (LIBDIR \"/firejail/seccomp.debug\")\t// default filter built during make\n#define PATH_SECCOMP_32 (LIBDIR \"/firejail/seccomp.32\")\t\t\t// 32bit arch filter built during make\n#define PATH_SECCOMP_MDWX (LIBDIR \"/firejail/seccomp.mdwx\")\t\t// filter for memory-deny-write-execute built during make\n#define PATH_SECCOMP_BLOCK_SECONDARY (LIBDIR \"/firejail/seccomp.block_secondary\")\t// secondary arch blocking filter built during make\n\n\n#define RUN_DEV_DIR\t\t\"/run/firejail/mnt/dev\"\n#define RUN_DEVLOG_FILE\t\"/run/firejail/mnt/devlog\"\n\n#define RUN_WHITELIST_X11_DIR\t\"/run/firejail/mnt/orig-x11\"\n#define RUN_WHITELIST_HOME_DIR\t\"/run/firejail/mnt/orig-home\"\t// default home directory masking\n#define RUN_WHITELIST_RUN_DIR\t\"/run/firejail/mnt/orig-run\"\t// default run directory masking\n#define RUN_WHITELIST_HOME_USER_DIR\t\"/run/firejail/mnt/orig-home-user\"\t// home directory whitelisting\n#define RUN_WHITELIST_RUN_USER_DIR\t\"/run/firejail/mnt/orig-run-user\"\t// run directory whitelisting\n#define RUN_WHITELIST_TMP_DIR\t\"/run/firejail/mnt/orig-tmp\"\n#define RUN_WHITELIST_MEDIA_DIR\t\"/run/firejail/mnt/orig-media\"\n#define RUN_WHITELIST_MNT_DIR\t\"/run/firejail/mnt/orig-mnt\"\n#define RUN_WHITELIST_VAR_DIR\t\"/run/firejail/mnt/orig-var\"\n#define RUN_WHITELIST_DEV_DIR\t\"/run/firejail/mnt/orig-dev\"\n#define RUN_WHITELIST_OPT_DIR\t\"/run/firejail/mnt/orig-opt\"\n#define RUN_WHITELIST_SRV_DIR   \"/run/firejail/mnt/orig-srv\"\n#define RUN_WHITELIST_ETC_DIR   \"/run/firejail/mnt/orig-etc\"\n#define RUN_WHITELIST_SHARE_DIR   \"/run/firejail/mnt/orig-share\"\n#define RUN_WHITELIST_MODULE_DIR   \"/run/firejail/mnt/orig-module\"\n\n#define RUN_XAUTHORITY_FILE\t\"/run/firejail/mnt/.Xauthority\"\n#define RUN_XAUTHORITY_SEC_FILE\t\"/run/firejail/mnt/sec.Xauthority\"\n#define RUN_ASOUNDRC_FILE\t\"/run/firejail/mnt/.asoundrc\"\n#define RUN_HOSTNAME_FILE\t\"/run/firejail/mnt/hostname\"\n#define RUN_HOSTS_FILE\t\"/run/firejail/mnt/hosts\"\n#define RUN_MACHINEID\t\"/run/firejail/mnt/machine-id\"\n#define RUN_LDPRELOAD_FILE\t\"/run/firejail/mnt/ld.so.preload\"\n#define RUN_UTMP_FILE\t\t\"/run/firejail/mnt/utmp\"\n#define RUN_PASSWD_FILE\t\t\"/run/firejail/mnt/passwd\"\n#define RUN_GROUP_FILE\t\t\"/run/firejail/mnt/group\"\n#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"\n#define RUN_UMASK_FILE\t\t\"/run/firejail/mnt/umask\"\n#define RUN_OVERLAY_ROOT\t\"/run/firejail/mnt/oroot\"\n#define RUN_READY_FOR_JOIN \t\"/run/firejail/mnt/ready-for-join\"\n\n\n// profiles\n#define DEFAULT_USER_PROFILE\t\"default\"\n#define DEFAULT_ROOT_PROFILE\t\"server\"\n#define MAX_INCLUDE_LEVEL 16\t\t// include levels in profile files\n\n\n#define ASSERT_PERMS(file, uid, gid, mode) \\\n\tdo { \\\n\t\tassert(file);\\\n\t\tstruct stat s;\\\n\t\tif (stat(file, &s) == -1) errExit(\"stat\");\\\n\t\tassert(s.st_uid == uid);\\\n\t\tassert(s.st_gid == gid);\\\n\t\tassert((s.st_mode & 07777) == (mode));\\\n\t} while (0)\n#define ASSERT_PERMS_FD(fd, uid, gid, mode) \\\n\tdo { \\\n\t\tstruct stat s;\\\n\t\tif (fstat(fd, &s) == -1) errExit(\"fstat\");\\\n\t\tassert(s.st_uid == uid);\\\n\t\tassert(s.st_gid == gid);\\\n\t\tassert((s.st_mode & 07777) == (mode));\\\n\t} while (0)\n#define ASSERT_PERMS_STREAM(file, uid, gid, mode) \\\n\tdo { \\\n\t\tint fd = fileno(file);\\\n\t\tif (fd == -1) errExit(\"fileno\");\\\n\t\tASSERT_PERMS_FD(fd, uid, gid, (mode));\\\n\t} while (0)\n\n#define SET_PERMS_FD(fd, uid, gid, mode) \\\n\tdo { \\\n\t\tif (fchmod(fd, (mode)) == -1)\terrExit(\"chmod\");\\\n\t\tif (fchown(fd, uid, gid) == -1) errExit(\"chown\");\\\n\t} while (0)\n#define SET_PERMS_STREAM(stream, uid, gid, mode) \\\n\tdo { \\\n\t\tint fd = fileno(stream);\\\n\t\tif (fd == -1) errExit(\"fileno\");\\\n\t\tSET_PERMS_FD(fd, uid, gid, (mode));\\\n\t} while (0)\n#define SET_PERMS_STREAM_NOERR(stream, uid, gid, mode) \\\n\tdo { \\\n\t\tint fd = fileno(stream);\\\n\t\tif (fd == -1) continue;\\\n\t\tint rv = fchmod(fd, (mode));\\\n\t\t(void) rv;\\\n\t\trv = fchown(fd, uid, gid);\\\n\t\t(void) rv;\\\n\t} while (0)\n\n// main.c\ntypedef struct bridge_t {\n\t// on the host\n\tchar *dev;\t\t// interface device name: bridge or regular ethernet\n\tuint32_t ip;\t\t// interface device IP address\n\tuint32_t mask;\t\t// interface device mask\n\tuint8_t mac[6];\t\t// interface mac address\n\tint mtu;\t\t// interface mtu\n\n\tchar *veth_name;\t// veth name for the device connected to the bridge\n\n\t// inside the sandbox\n\tchar *devsandbox;\t// name of the device inside the sandbox\n\tuint32_t ipsandbox;\t// ip address inside the sandbox\n\tuint32_t masksandbox;\t// network mask inside the sandbox\n\tchar *ip6sandbox;\t// ipv6 address inside the sandbox\n\tuint8_t macsandbox[6]; // mac address inside the sandbox\n\tuint32_t iprange_start;// iprange arp scan start range\n\tuint32_t iprange_end;\t// iprange arp scan end range\n\n\t// flags\n\tuint8_t arg_ip_none;\t// --ip=none\n\tuint8_t macvlan;\t// set by --net=eth0 (or eth1, ...); reset by --net=br0 (or br1, ...)\n\tuint8_t configured;\n\tuint8_t scan;\t\t// set by --scan\n}  Bridge;\n\ntypedef struct interface_t {\n\tchar *dev;\n\tuint32_t ip;\n\tuint32_t mask;\n\tuint8_t mac[6];\n\tint mtu;\n\n\tuint8_t configured;\n} Interface;\n\ntypedef struct profile_entry_t {\n\tstruct profile_entry_t *next;\n\tchar *data;\t// command\n\n\t// whitelist command parameters\n\tchar *link;\t// link name - set if the file is a link\n\tunsigned home_dir:1;\t// whitelist in /home/user directory\n\tunsigned tmp_dir:1;\t// whitelist in /tmp directory\n\tunsigned media_dir:1;\t// whitelist in /media directory\n\tunsigned mnt_dir:1;\t// whitelist in /mnt directory\n\tunsigned var_dir:1;\t// whitelist in /var directory\n\tunsigned dev_dir:1;\t// whitelist in /dev directory\n\tunsigned opt_dir:1;\t// whitelist in /opt directory\n\tunsigned srv_dir:1;\t// whitelist in /srv directory\n\tunsigned etc_dir:1;\t// whitelist in /etc directory\n\tunsigned share_dir:1;\t// whitelist in /usr/share directory\n\tunsigned module_dir:1;\t// whitelist in /sys/module directory\n\tunsigned run_dir:1;\t// whitelist in /run/user/$uid directory\n}ProfileEntry;\n\ntypedef struct config_t {\n\t// user data\n\tchar *username;\n\tchar *homedir;\n\n\t// filesystem\n\tProfileEntry *profile;\n#define MAX_PROFILE_IGNORE 32\n\tchar *profile_ignore[MAX_PROFILE_IGNORE];\n\tchar *chrootdir;\t// chroot directory\n\tchar *home_private;\t// private home directory\n\tchar *home_private_keep;\t// keep list for private home directory\n\tchar *etc_private_keep;\t// keep list for private etc directory\n\tchar *opt_private_keep;\t// keep list for private opt directory\n\tchar *srv_private_keep;\t// keep list for private srv directory\n\tchar *bin_private_keep;\t// keep list for private bin directory\n\tchar *bin_private_lib;\t// executable list sent by private-bin to private-lib\n\tchar *lib_private_keep;\t// keep list for private bin directory\n\tchar *cwd;\t\t// current working directory\n\tchar *overlay_dir;\n\n\t// networking\n\tchar *name;\t\t// sandbox name\n\tchar *hostname;\t// host name\n\tchar *hosts_file;\t\t// hosts file to be installed in the sandbox\n\tuint32_t defaultgw;\t// default gateway\n\tBridge bridge0;\n\tBridge bridge1;\n\tBridge bridge2;\n\tBridge bridge3;\n\tInterface interface0;\n\tInterface interface1;\n\tInterface interface2;\n\tInterface interface3;\n\tchar *dns1;\t// up to 4 IP (v4/v6) addresses for dns servers\n\tchar *dns2;\n\tchar *dns3;\n\tchar *dns4;\n\n\t// seccomp\n\tchar *seccomp_list;//  optional seccomp list on top of default filter\n\tchar *seccomp_list_drop;\t// seccomp drop list\n\tchar *seccomp_list_keep;\t// seccomp keep list\n\tchar *protocol;\t\t\t// protocol list\n\n\t// rlimits\n\tlong long unsigned rlimit_cpu;\n\tlong long unsigned rlimit_nofile;\n\tlong long unsigned rlimit_nproc;\n\tlong long unsigned rlimit_fsize;\n\tlong long unsigned rlimit_sigpending;\n\tlong long unsigned rlimit_as;\n\tunsigned timeout;\t// maximum time elapsed before killing the sandbox\n\n\t// cpu affinity, nice and control groups\n\tuint32_t cpus;\n\tint nice;\n\tchar *cgroup;\n\n\t// command line\n\tchar *command_line;\n\tchar *window_title;\n\tchar *command_name;\n\tchar *shell;\n\tchar **original_argv;\n\tint original_argc;\n\tint original_program_index;\n} Config;\nextern Config cfg;\n\nstatic inline Bridge *last_bridge_configured(void) {\n\tif (cfg.bridge3.configured)\n\t\treturn &cfg.bridge3;\n\telse if (cfg.bridge2.configured)\n\t\treturn &cfg.bridge2;\n\telse if (cfg.bridge1.configured)\n\t\treturn &cfg.bridge1;\n\telse if (cfg.bridge0.configured)\n\t\treturn &cfg.bridge0;\n\telse\n\t\treturn NULL;\n}\n\nstatic inline int any_bridge_configured(void) {\n\tif (cfg.bridge0.configured || cfg.bridge1.configured || cfg.bridge2.configured || cfg.bridge3.configured)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic inline int any_interface_configured(void) {\n\tif (cfg.interface0.configured || cfg.interface1.configured || cfg.interface2.configured || cfg.interface3.configured)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nextern int arg_private;\t\t// mount private /home\nextern int arg_private_cache;\t// private home/.cache\nextern int arg_debug;\t\t// print debug messages\nextern int arg_debug_blacklists;\t// print debug messages for blacklists\nextern int arg_debug_whitelists;\t// print debug messages for whitelists\nextern int arg_debug_private_lib;\t// print debug messages for private-lib\nextern int arg_nonetwork;\t// --net=none\nextern int arg_command;\t// -c\nextern int arg_overlay;\t\t// overlay option\nextern int arg_overlay_keep;\t// place overlay diff in a known directory\nextern int arg_overlay_reuse;\t// allow the reuse of overlays\n\nextern int arg_seccomp;\t// enable default seccomp filter\nextern int arg_seccomp_postexec;\t// need postexec ld.preload library?\nextern int arg_seccomp_block_secondary;\t// block any secondary architectures\n\nextern int arg_caps_default_filter;\t// enable default capabilities filter\nextern int arg_caps_drop;\t\t// drop list\nextern int arg_caps_drop_all;\t\t// drop all capabilities\nextern int arg_caps_keep;\t\t// keep list\nextern char *arg_caps_list;\t\t// optional caps list\n\nextern int arg_trace;\t\t// syscall tracing support\nextern int arg_tracelog;\t// blacklist tracing support\nextern int arg_rlimit_cpu;\t// rlimit cpu\nextern int arg_rlimit_nofile;\t// rlimit nofile\nextern int arg_rlimit_nproc;\t// rlimit nproc\nextern int arg_rlimit_fsize;\t// rlimit fsize\nextern int arg_rlimit_sigpending;// rlimit sigpending\nextern int arg_rlimit_as;\t//rlimit as\nextern int arg_nogroups;\t// disable supplementary groups\nextern int arg_nonewprivs;\t// set the NO_NEW_PRIVS prctl\nextern int arg_noroot;\t\t// create a new user namespace and disable root user\nextern int arg_netfilter;\t// enable netfilter\nextern int arg_netfilter6;\t// enable netfilter6\nextern char *arg_netfilter_file;\t// netfilter file\nextern char *arg_netfilter6_file;\t// netfilter file\nextern char *arg_netns;\t\t// \"ip netns\"-created network namespace to use\nextern int arg_doubledash;\t// double dash\nextern int arg_shell_none;\t// run the program directly without a shell\nextern int arg_private_dev;\t// private dev directory\nextern int arg_keep_dev_shm;    // preserve /dev/shm\nextern int arg_private_etc;\t// private etc directory\nextern int arg_private_opt;\t// private opt directory\nextern int arg_private_srv;\t// private srv directory\nextern int arg_private_bin;\t// private bin directory\nextern int arg_private_tmp;\t// private tmp directory\nextern int arg_private_lib;\t// private lib directory\nextern int arg_scan;\t\t// arp-scan all interfaces\nextern int arg_whitelist;\t// whitelist command\nextern int arg_nosound;\t// disable sound\nextern int arg_noautopulse; // disable automatic ~/.config/pulse init\nextern int arg_novideo; //disable video devices in /dev\nextern int arg_no3d;\t\t// disable 3d hardware acceleration\nextern int arg_quiet;\t\t// no output for scripting\nextern int arg_join_network;\t// join only the network namespace\nextern int arg_join_filesystem;\t// join only the mount namespace\nextern int arg_nice;\t\t// nice value configured\nextern int arg_ipc;\t\t// enable ipc namespace\nextern int arg_writable_etc;\t// writable etc\nextern int arg_writable_var;\t// writable var\nextern int arg_keep_var_tmp; // don't overwrite /var/tmp\nextern int arg_writable_run_user;\t// writable /run/user\nextern int arg_writable_var_log; // writable /var/log\nextern int arg_appimage;\t// appimage\nextern int arg_audit;\t\t// audit\nextern char *arg_audit_prog;\t// audit\nextern int arg_apparmor;\t// apparmor\nextern int arg_allow_debuggers;\t// allow debuggers\nextern int arg_x11_block;\t// block X11\nextern int arg_x11_xorg;\t// use X11 security extension\nextern int arg_allusers;\t// all user home directories visible\nextern int arg_machineid;\t// preserve /etc/machine-id\nextern int arg_disable_mnt;\t// disable /mnt and /media\nextern int arg_noprofile;\t// use default.profile if none other found/specified\nextern int arg_memory_deny_write_execute;\t// block writable and executable memory\nextern int arg_notv;\t// --notv\nextern int arg_nodvd;\t// --nodvd\nextern int arg_nou2f;   // --nou2f\nextern int arg_nodbus; // -nodbus\n\nextern int login_shell;\nextern int parent_to_child_fds[2];\nextern int child_to_parent_fds[2];\nextern pid_t sandbox_pid;\nextern mode_t orig_umask;\nextern unsigned long long start_timestamp;\n\n#define MAX_ARGS 128\t\t// maximum number of command arguments (argc)\nextern char *fullargv[MAX_ARGS];\nextern int fullargc;\n\n// main.c\nvoid check_user_namespace(void);\nchar *guess_shell(void);\n\n// sandbox.c\nint sandbox(void* sandbox_arg);\nvoid start_application(int no_sandbox, FILE *fp);\n\n// network_main.c\nvoid net_configure_sandbox_ip(Bridge *br);\nvoid net_configure_veth_pair(Bridge *br, const char *ifname, pid_t child);\nvoid net_check_cfg(void);\nvoid net_dns_print(pid_t pid);\nvoid network_main(pid_t child);\nvoid net_print(pid_t pid);\n\n// network.c\nint check_ip46_address(const char *addr);\nvoid net_if_up(const char *ifname);\nvoid net_if_down(const char *ifname);\nvoid net_if_ip(const char *ifname, uint32_t ip, uint32_t mask, int mtu);\nvoid net_if_ip6(const char *ifname, const char *addr6);\nint net_get_if_addr(const char *bridge, uint32_t *ip, uint32_t *mask, uint8_t mac[6], int *mtu);\nint net_add_route(uint32_t dest, uint32_t mask, uint32_t gw);\nuint32_t network_get_defaultgw(void);\nint net_config_mac(const char *ifname, const unsigned char mac[6]);\nint net_get_mac(const char *ifname, unsigned char mac[6]);\nvoid net_config_interface(const char *dev, uint32_t ip, uint32_t mask, int mtu);\n\n// preproc.c\nvoid preproc_build_firejail_dir(void);\nvoid preproc_mount_mnt_dir(void);\nvoid preproc_clean_run(void);\n\n// fs.c\n// blacklist files or directories by mounting empty files on top of them\nvoid fs_blacklist(void);\n// mount a writable tmpfs\nvoid fs_tmpfs(const char *dir, unsigned check_owner);\n// remount a directory read-only\nvoid fs_rdonly(const char *dir);\nvoid fs_rdonly_rec(const char *dir);\n// remount a directory noexec, nodev and nosuid\nvoid fs_noexec(const char *dir);\nvoid fs_noexec_rec(const char *dir);\n// mount /proc and /sys directories\nvoid fs_proc_sys_dev_boot(void);\n// build a basic read-only filesystem\nvoid fs_basic_fs(void);\n// mount overlayfs on top of / directory\nchar *fs_check_overlay_dir(const char *subdirname, int allow_reuse);\nvoid fs_overlayfs(void);\n// chroot into an existing directory; mount exiting /dev and update /etc/resolv.conf\nvoid fs_chroot(const char *rootdir);\nvoid fs_check_chroot_dir(const char *rootdir);\nvoid fs_private_tmp(void);\nvoid fs_private_cache(void);\nvoid fs_mnt(const int enforce);\n\n// profile.c\n// find and read the profile specified by name from dir directory\nint profile_find_firejail(const char *name, int add_ext);\n// read a profile file\nvoid profile_read(const char *fname);\n// check profile line; if line == 0, this was generated from a command line option\n// return 1 if the command is to be added to the linked list of profile commands\n// return 0 if the command was already executed inside the function\nint profile_check_line(char *ptr, int lineno, const char *fname);\n// add a profile entry in cfg.profile list; use str to populate the list\nvoid profile_add(char *str);\nvoid profile_add_ignore(const char *str);\n\n// list.c\nvoid list(void);\nvoid tree(void);\nvoid top(void);\nvoid netstats(void);\n\n// usage.c\nvoid usage(void);\n\n// join.c\nvoid join(pid_t pid, int argc, char **argv, int index);\npid_t switch_to_child(pid_t pid);\n\n// shutdown.c\nvoid shut(pid_t pid);\n\n// restricted_shell.c\nint restricted_shell(const char *user);\n\n// arp.c\nvoid arp_announce(const char *dev, Bridge *br);\n// returns 0 if the address is not in use, -1 otherwise\nint arp_check(const char *dev, uint32_t destaddr);\n// assign an IP address using arp scanning\nuint32_t arp_assign(const char *dev, Bridge *br);\n\n// macros.c\nchar *expand_macros(const char *path);\nchar *resolve_macro(const char *name);\nvoid invalid_filename(const char *fname, int globbing);\nint is_macro(const char *name);\nint macro_id(const char *name);\n\n\n// util.c\nvoid errLogExit(char* fmt, ...);\nvoid fwarning(char* fmt, ...);\nvoid fmessage(char* fmt, ...);\nvoid drop_privs(int nogroups);\nint mkpath_as_root(const char* path);\nvoid extract_command_name(int index, char **argv);\nvoid logsignal(int s);\nvoid logmsg(const char *msg);\nvoid logargs(int argc, char **argv) ;\nvoid logerr(const char *msg);\nvoid set_nice(int inc);\nint copy_file(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode);\nvoid copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode);\nvoid copy_file_from_user_to_root(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode);\nvoid touch_file_as_user(const char *fname, mode_t mode);\nint is_dir(const char *fname);\nint is_link(const char *fname);\nvoid trim_trailing_slash_or_dot(char *path);\nchar *line_remove_spaces(const char *buf);\nchar *split_comma(char *str);\nchar *clean_pathname(const char *path);\nvoid check_unsigned(const char *str, const char *msg);\nint find_child(pid_t parent, pid_t *child);\nvoid check_private_dir(void);\nvoid update_map(char *mapping, char *map_file);\nvoid wait_for_other(int fd);\nvoid notify_other(int fd);\nconst char *gnu_basename(const char *path);\nuid_t pid_get_uid(pid_t pid);\nuid_t get_group_id(const char *group);\nint remove_overlay_directory(void);\nvoid flush_stdin(void);\nint create_empty_dir_as_user(const char *dir, mode_t mode);\nvoid create_empty_dir_as_root(const char *dir, mode_t mode);\nvoid create_empty_file_as_root(const char *dir, mode_t mode);\nint set_perms(const char *fname, uid_t uid, gid_t gid, mode_t mode);\nvoid mkdir_attr(const char *fname, mode_t mode, uid_t uid, gid_t gid);\nunsigned extract_timeout(const char *str);\nvoid disable_file_or_dir(const char *fname);\nvoid disable_file_path(const char *path, const char *file);\nint safe_fd(const char *path, int flags);\nint invalid_sandbox(const pid_t pid);\nint has_handler(pid_t pid, int signal);\nvoid enter_network_namespace(pid_t pid);\n\n// Get info regarding the last kernel mount operation from /proc/self/mountinfo\n// The return value points to a static area, and will be overwritten by subsequent calls.\n// The function does an exit(1) if anything goes wrong.\ntypedef struct {\n\tint mountid; // id of the mount\n\tchar *fsname; // the pathname of the directory in the filesystem which forms the root of this mount\n\tchar *dir;\t// mount destination\n\tchar *fstype; // filesystem type\n} MountData;\n\n// mountinfo.c\nMountData *get_last_mount(void);\nint get_mount_id(const char *path);\nchar **build_mount_array(const int mount_id, const char *path);\n\n// fs_var.c\nvoid fs_var_log(void);\t// mounting /var/log\nvoid fs_var_lib(void);\t// various other fixes for software in /var directory\nvoid fs_var_cache(void); // various other fixes for software in /var/cache directory\nvoid fs_var_run(void);\nvoid fs_var_lock(void);\nvoid fs_var_tmp(void);\nvoid fs_var_utmp(void);\nvoid dbg_test_dir(const char *dir);\n\n// fs_dev.c\nvoid fs_dev_shm(void);\nvoid fs_private_dev(void);\nvoid fs_dev_disable_sound(void);\nvoid fs_dev_disable_3d(void);\nvoid fs_dev_disable_video(void);\nvoid fs_dev_disable_tv(void);\nvoid fs_dev_disable_dvd(void);\nvoid fs_dev_disable_u2f(void);\n\n// fs_home.c\n// private mode (--private)\nvoid fs_private(void);\n// private mode (--private=homedir)\nvoid fs_private_homedir(void);\n// check new private home directory (--private= option) - exit if it fails\nvoid fs_check_private_dir(void);\nvoid fs_private_home_list(void);\n\n\n// seccomp.c\nchar *seccomp_check_list(const char *str);\nint seccomp_install_filters(void);\nint seccomp_load(const char *fname);\nint seccomp_filter_drop(void);\nint seccomp_filter_keep(void);\nvoid seccomp_print_filter(pid_t pid);\n\n// caps.c\nvoid seccomp_load_file_list(void);\nint caps_default_filter(void);\nvoid caps_print(void);\nvoid caps_drop_all(void);\nvoid caps_set(uint64_t caps);\nvoid caps_check_list(const char *clist, void (*callback)(int));\nvoid caps_drop_list(const char *clist);\nvoid caps_keep_list(const char *clist);\nvoid caps_print_filter(pid_t pid);\nvoid caps_drop_dac_override(void);\n\n// fs_trace.c\nvoid fs_trace_preload(void);\nvoid fs_trace(void);\n\n// fs_hostname.c\nvoid fs_hostname(const char *hostname);\nvoid fs_resolvconf(void);\nchar *fs_check_hosts_file(const char *fname);\nvoid fs_store_hosts_file(void);\nvoid fs_mount_hosts_file(void);\n\n// rlimit.c\nvoid set_rlimits(void);\n\n// cpu.c\nvoid read_cpu_list(const char *str);\nvoid set_cpu_affinity(void);\nvoid load_cpu(const char *fname);\nvoid save_cpu(void);\nvoid cpu_print_filter(pid_t pid);\n\n// cgroup.c\nvoid save_cgroup(void);\nvoid load_cgroup(const char *fname);\nvoid set_cgroup(const char *path);\n\n// output.c\nvoid check_output(int argc, char **argv);\n\n// netfilter.c\nvoid check_netfilter_file(const char *fname);\nvoid netfilter(const char *fname);\nvoid netfilter6(const char *fname);\nvoid netfilter_print(pid_t pid, int ipv6);\n\n// netns.c\nvoid check_netns(const char *nsname);\nvoid netns(const char *nsname);\nvoid netns_mounts(const char *nsname);\n\n// bandwidth.c\nvoid bandwidth_pid(pid_t pid, const char *command, const char *dev, int down, int up);\nvoid network_set_run_file(pid_t pid);\n\n// fs_etc.c\nvoid fs_machineid(void);\nvoid fs_private_dir_list(const char *private_dir, const char *private_run_dir, const char *private_list);\n\n// no_sandbox.c\nint check_namespace_virt(void);\nint check_kernel_procs(void);\nvoid run_no_sandbox(int argc, char **argv);\n\n// env.c\ntypedef enum {\n\tSETENV = 0,\n\tRMENV\n} ENV_OP;\n\nvoid env_store(const char *str, ENV_OP op);\nvoid env_apply(void);\nvoid env_defaults(void);\nvoid env_ibus_load(void);\n\n// fs_whitelist.c\nvoid fs_whitelist(void);\n\n// pulseaudio.c\nvoid pulseaudio_init(void);\nvoid pulseaudio_disable(void);\n\n// fs_bin.c\nvoid fs_private_bin_list(void);\n\n// fs_lib.c\nvoid fs_private_lib(void);\n\n// protocol.c\nvoid protocol_filter_save(void);\nvoid protocol_filter_load(const char *fname);\nvoid protocol_print_filter(pid_t pid);\n\n// restrict_users.c\nvoid restrict_users(void);\n\n// fs_logger.c\nvoid fs_logger(const char *msg);\nvoid fs_logger2(const char *msg1, const char *msg2);\nvoid fs_logger2int(const char *msg1, int d);\nvoid fs_logger3(const char *msg1, const char *msg2, const char *msg3);\nvoid fs_logger_print(void);\nvoid fs_logger_change_owner(void);\nvoid fs_logger_print_log(pid_t pid);\n\n// run_symlink.c\nvoid run_symlink(int argc, char **argv, int run_as_is);\n\n// paths.c\nchar **build_paths(void);\nunsigned int count_paths(void);\nint program_in_path(const char *program);\n\n// fs_mkdir.c\nvoid fs_mkdir(const char *name);\nvoid fs_mkfile(const char *name);\n\n// x11.c\n\n// X11 display range as assigned by --x11 options\n//     We try display numbers in the range 21 through 1000.\n//     Normal X servers typically use displays in the 0-10 range;\n//     ssh's X11 forwarding uses 10-20, and login screens\n//     (e.g. gdm3) may use displays above 1000.\n#define X11_DISPLAY_START 21\n#define X11_DISPLAY_END 1000\n\nvoid fs_x11(void);\nint x11_display(void);\nvoid x11_start(int argc, char **argv);\nvoid x11_start_xpra(int argc, char **argv);\nvoid x11_start_xephyr(int argc, char **argv);\nvoid x11_block(void);\nvoid x11_start_xvfb(int argc, char **argv);\nvoid x11_xorg(void);\n\n// ls.c\nenum {\n\tSANDBOX_FS_LS = 0,\n\tSANDBOX_FS_GET,\n\tSANDBOX_FS_PUT,\n\tSANDBOX_FS_MAX // this should always be the last entry\n};\nvoid sandboxfs(int op, pid_t pid, const char *path1, const char *path2);\n\n// checkcfg.c\n#define DEFAULT_ARP_PROBES 2\nenum {\n\tCFG_FILE_TRANSFER = 0,\n\tCFG_X11,\n\tCFG_BIND,\n\tCFG_USERNS,\n\tCFG_CHROOT,\n\tCFG_SECCOMP,\n\tCFG_NETWORK,\n\tCFG_RESTRICTED_NETWORK,\n\tCFG_FORCE_NONEWPRIVS,\n\tCFG_WHITELIST,\n\tCFG_XEPHYR_WINDOW_TITLE,\n\tCFG_OVERLAYFS,\n\tCFG_PRIVATE_HOME,\n\tCFG_PRIVATE_BIN_NO_LOCAL,\n\tCFG_FIREJAIL_PROMPT,\n\tCFG_FOLLOW_SYMLINK_AS_USER,\n\tCFG_DISABLE_MNT,\n\tCFG_JOIN,\n\tCFG_ARP_PROBES,\n\tCFG_XPRA_ATTACH,\n\tCFG_BROWSER_DISABLE_U2F,\n\tCFG_PRIVATE_LIB,\n\tCFG_APPARMOR,\n\tCFG_DBUS,\n\tCFG_PRIVATE_CACHE,\n\tCFG_CGROUP,\n\tCFG_NAME_CHANGE,\n\tCFG_MAX // this should always be the last entry\n};\nextern char *xephyr_screen;\nextern char *xephyr_extra_params;\nextern char *xpra_extra_params;\nextern char *xvfb_screen;\nextern char *xvfb_extra_params;\nextern char *netfilter_default;\nint checkcfg(int val);\nvoid print_compiletime_support(void);\n\n// appimage.c\nvoid appimage_set(const char *appimage_path);\nvoid appimage_clear(void);\nconst char *appimage_getdir(void);\n\n// appimage_size.c\nlong unsigned int appimage2_size(const char *fname);\n\n// cmdline.c\nvoid build_cmdline(char **command_line, char **window_title, int argc, char **argv, int index);\nvoid build_appimage_cmdline(char **command_line, char **window_title, int argc, char **argv, int index, char *apprun_path);\n\n// sbox.c\n// programs\n#define PATH_FNET_MAIN (LIBDIR \"/firejail/fnet\")\t\t// when called from main thread\n#define PATH_FNET (RUN_FIREJAIL_LIB_DIR \"/fnet\")\t// when called from sandbox thread\n\n//#define PATH_FNETFILTER (LIBDIR \"/firejail/fnetfilter\")\n#define PATH_FNETFILTER (RUN_FIREJAIL_LIB_DIR \"/fnetfilter\")\n\n#define PATH_FIREMON (PREFIX \"/bin/firemon\")\n#define PATH_FIREJAIL (PREFIX \"/bin/firejail\")\n\n#define PATH_FSECCOMP_MAIN (LIBDIR \"/firejail/fseccomp\")\t\t// when called from main thread\n#define PATH_FSECCOMP ( RUN_FIREJAIL_LIB_DIR \"/fseccomp\")\t// when called from sandbox thread\n\n// FSEC_PRINT is run outside of sandbox by --seccomp.print\n// it is also run from inside the sandbox by --debug; in this case we do an access(filename, X_OK) test first\n#define PATH_FSEC_PRINT (LIBDIR \"/firejail/fsec-print\")\n\n//#define PATH_FSEC_OPTIMIZE (LIBDIR \"/firejail/fsec-optimize\")\n#define PATH_FSEC_OPTIMIZE (RUN_FIREJAIL_LIB_DIR \"/fsec-optimize\")\n\n//#define PATH_FCOPY (LIBDIR \"/firejail/fcopy\")\n#define PATH_FCOPY (RUN_FIREJAIL_LIB_DIR \"/fcopy\")\n\n#define SBOX_STDIN_FILE \"/run/firejail/mnt/sbox_stdin\"\n\n//#define PATH_FLDD (LIBDIR \"/firejail/fldd\")\n#define PATH_FLDD (RUN_FIREJAIL_LIB_DIR \"/fldd\")\n\n// bitmapped filters for sbox_run\n#define SBOX_ROOT (1 << 0)\t\t\t// run the sandbox as root\n#define SBOX_USER (1 << 1)\t\t\t// run the sandbox as a regular user\n#define SBOX_SECCOMP (1 << 2)\t\t// install seccomp\n#define SBOX_CAPS_NONE (1 << 3)\t\t// drop all capabilities\n#define SBOX_CAPS_NETWORK (1 << 4)\t// caps filter for programs running network programs\n#define SBOX_ALLOW_STDIN (1 << 5)\t\t// don't close stdin\n#define SBOX_STDIN_FROM_FILE (1 << 6)\t// open file and redirect it to stdin\n#define SBOX_CAPS_HIDEPID (1 << 7)\t// hidepid caps filter for running firemon\n\n// run sbox\nint sbox_run(unsigned filter, int num, ...);\n\n// run_files.c\nvoid delete_run_files(pid_t pid);\nvoid delete_bandwidth_run_file(pid_t pid);\nvoid set_name_run_file(pid_t pid);\nvoid set_x11_run_file(pid_t pid, int display);\nvoid set_profile_run_file(pid_t pid, const char *fname);\n\n// dbus.c\nvoid dbus_session_disable(void);\n\n#endif\n", "/*\n * Copyright (C) 2014-2019 Firejail Authors\n *\n * This file is part of firejail project\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#include \"firejail.h\"\n#include \"../include/ldd_utils.h\"\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <glob.h>\n#define MAXBUF 4096\n\nextern void fslib_install_stdc(void);\nextern void fslib_install_system(void);\n\nstatic int lib_cnt = 0;\nstatic int dir_cnt = 0;\n\nstatic void report_duplication(const char *full_path) {\n\tchar *fname = strrchr(full_path, '/');\n\tif (fname && *(++fname) != '\\0') {\n\t\t// report the file on all bin paths\n\t\tint i = 0;\n\t\twhile (default_lib_paths[i]) {\n\t\t\tchar *p;\n\t\t\tif (asprintf(&p, \"%s/%s\", default_lib_paths[i], fname) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tfs_logger2(\"clone\", p);\n\t\t\tfree(p);\n\t\t\ti++;\n\t\t}\n\t}\n}\n\nstatic char *build_dest_dir(const char *full_path) {\n\tassert(full_path);\n\tif (strstr(full_path, \"/x86_64-linux-gnu/\"))\n\t\treturn RUN_LIB_DIR \"/x86_64-linux-gnu\";\n\treturn RUN_LIB_DIR;\n}\n\n// copy fname in private_run_dir\nvoid fslib_duplicate(const char *full_path) {\n\tassert(full_path);\n\n\tstruct stat s;\n\tif (stat(full_path, &s) != 0 || s.st_uid != 0 || access(full_path, R_OK))\n\t\treturn;\n\n\tchar *dest_dir = build_dest_dir(full_path);\n\n\t// don't copy it if the file is already there\n\tchar *ptr = strrchr(full_path, '/');\n\tif (!ptr)\n\t\treturn;\n\tptr++;\n\tif (*ptr == '\\0')\n\t\treturn;\n\n\tchar *name;\n\tif (asprintf(&name, \"%s/%s\", dest_dir, ptr) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(name, &s) == 0) {\n\t\tfree(name);\n\t\treturn;\n\t}\n\tfree(name);\n\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"    copying %s to private %s\\n\", full_path, dest_dir);\n\n\tsbox_run(SBOX_ROOT| SBOX_SECCOMP, 4, PATH_FCOPY, \"--follow-link\", full_path, dest_dir);\n\treport_duplication(full_path);\n\tlib_cnt++;\n}\n\n\n// requires full path for lib\n// it could be a library or an executable\n// lib is not copied, only libraries used by it\nvoid fslib_copy_libs(const char *full_path) {\n\tassert(full_path);\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"    fslib_copy_libs %s\\n\", full_path);\n\n\t// if library/executable does not exist or the user does not have read access to it\n\t// print a warning and exit the function.\n\tif (access(full_path, R_OK)) {\n\t\tif (arg_debug || arg_debug_private_lib)\n\t\t\tprintf(\"cannot find %s for private-lib, skipping...\\n\", full_path);\n\t\treturn;\n\t}\n\n\t// create an empty RUN_LIB_FILE and allow the user to write to it\n\tunlink(RUN_LIB_FILE);\t\t\t  // in case is there\n\tcreate_empty_file_as_root(RUN_LIB_FILE, 0644);\n\tif (chown(RUN_LIB_FILE, getuid(), getgid()))\n\t\terrExit(\"chown\");\n\n\t// run fldd to extract the list of files\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"    running fldd %s\\n\", full_path);\n\tsbox_run(SBOX_USER | SBOX_SECCOMP | SBOX_CAPS_NONE, 3, PATH_FLDD, full_path, RUN_LIB_FILE);\n\n\t// open the list of libraries and install them on by one\n\tFILE *fp = fopen(RUN_LIB_FILE, \"r\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\t// remove \\n\n\t\tchar *ptr = strchr(buf, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\t\tfslib_duplicate(buf);\n\t}\n\tfclose(fp);\n\tunlink(RUN_LIB_FILE);\n}\n\n\nvoid fslib_copy_dir(const char *full_path) {\n\tassert(full_path);\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"    fslib_copy_dir %s\\n\", full_path);\n\n\t// do nothing if the directory does not exist or is not owned by root\n\tstruct stat s;\n\tif (stat(full_path, &s) != 0 || s.st_uid != 0 || !S_ISDIR(s.st_mode) || access(full_path, R_OK))\n\t\treturn;\n\n\tchar *dir_name = strrchr(full_path, '/');\n\tassert(dir_name);\n\tdir_name++;\n\tassert(*dir_name != '\\0');\n\n\t// do nothing if the directory is already there\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/%s\", build_dest_dir(full_path), dir_name) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(dest, &s) == 0) {\n\t\tfree(dest);\n\t\treturn;\n\t}\n\n\t// create new directory and mount the original on top of it\n\tmkdir_attr(dest, 0755, 0, 0);\n\n\tif (mount(full_path, dest, NULL, MS_BIND|MS_REC, NULL) < 0 ||\n\t\tmount(NULL, dest, NULL, MS_BIND|MS_REMOUNT|MS_NOSUID|MS_NODEV|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfs_logger2(\"clone\", full_path);\n\tfs_logger2(\"mount\", full_path);\n\tdir_cnt++;\n\tfree(dest);\n}\n\n// fname should be a vallid full path at this point\nstatic void load_library(const char *fname) {\n\tassert(fname);\n\tassert(*fname == '/');\n\n\t// existing file owned by root, read access\n\tstruct stat s;\n\tif (stat(fname, &s) == 0 && s.st_uid == 0 && !access(fname, R_OK)) {\n\t\t// load directories, regular 64 bit libraries, and 64 bit executables\n\t\tif (is_dir(fname) || is_lib_64(fname)) {\n\t\t\tif (is_dir(fname))\n\t\t\t\tfslib_copy_dir(fname);\n\t\t\telse {\n\t\t\t\tif (strstr(fname, \".so\") ||\n\t\t\t\t    access(fname, X_OK) != 0) // don't duplicate executables, just install the libraries\n\t\t\t\t\tfslib_duplicate(fname);\n\n\t\t\t\tfslib_copy_libs(fname);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void install_list_entry(const char *lib) {\n\tassert(lib);\n\n\t// filename check\n\tint len = strlen(lib);\n\tif (strcspn(lib, \"\\\\&!?\\\"'<>%^(){}[];,\") != (size_t)len ||\n\tstrstr(lib, \"..\")) {\n\t\tfprintf(stderr, \"Error: \\\"%s\\\" is an invalid library\\n\", lib);\n\t\texit(1);\n\t}\n\n\t// if this is a full path, use it as is\n\tif (*lib == '/')\n\t\treturn load_library(lib);\n\n\n\t// find the library\n\tint i;\n\tfor (i = 0; default_lib_paths[i]; i++) {\n\t\tchar *fname = NULL;\n\t\tif (asprintf(&fname, \"%s/%s\", default_lib_paths[i], lib) == -1)\n\t\t\terrExit(\"asprintf\");\n\n#define DO_GLOBBING\n#ifdef DO_GLOBBING\n\t\t// globbing\n\t\tglob_t globbuf;\n\t\tint globerr = glob(fname, GLOB_NOCHECK | GLOB_NOSORT | GLOB_PERIOD, NULL, &globbuf);\n\t\tif (globerr) {\n\t\t\tfprintf(stderr, \"Error: failed to glob private-lib pattern %s\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tsize_t j;\n\t\tfor (j = 0; j < globbuf.gl_pathc; j++) {\n\t\t\tassert(globbuf.gl_pathv[j]);\n//printf(\"glob %s\\n\", globbuf.gl_pathv[j]);\n\t\t\t// GLOB_NOCHECK - no pattern matched returns the original pattern; try to load it anyway\n\t\t\tload_library(globbuf.gl_pathv[j]);\n\t\t}\n\n\t\tglobfree(&globbuf);\n#else\n\t\tload_library(fname);\n#endif\n\t\tfree(fname);\n\t}\n\n//\tfwarning(\"%s library not found, skipping...\\n\", lib);\n\treturn;\n}\n\n\nvoid fslib_install_list(const char *lib_list) {\n\tassert(lib_list);\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"    fslib_install_list  %s\\n\", lib_list);\n\n\tchar *dlist = strdup(lib_list);\n\tif (!dlist)\n\t\terrExit(\"strdup\");\n\n\tchar *ptr = strtok(dlist, \",\");\n\tif (!ptr) {\n\t\tfprintf(stderr, \"Error: invalid private-lib argument\\n\");\n\t\texit(1);\n\t}\n\tinstall_list_entry(ptr);\n\n\twhile ((ptr = strtok(NULL, \",\")) != NULL)\n\t\tinstall_list_entry(ptr);\n\tfree(dlist);\n\tfs_logger_print();\n}\n\n\n\nstatic void mount_directories(void) {\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"Mount-bind %s on top of /lib /lib64 /usr/lib\\n\", RUN_LIB_DIR);\n\n\tif (is_dir(\"/lib\")) {\n\t\tif (mount(RUN_LIB_DIR, \"/lib\", NULL, MS_BIND|MS_REC, NULL) < 0 ||\n\t\t\tmount(NULL, \"/lib\", NULL, MS_BIND|MS_REMOUNT|MS_NOSUID|MS_NODEV|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount bind\");\n\t\tfs_logger2(\"tmpfs\", \"/lib\");\n\t\tfs_logger(\"mount /lib\");\n\t}\n\n\tif (is_dir(\"/lib64\")) {\n\t\tif (mount(RUN_LIB_DIR, \"/lib64\", NULL, MS_BIND|MS_REC, NULL) < 0 ||\n\t\t\tmount(NULL, \"/lib64\", NULL, MS_BIND|MS_REMOUNT|MS_NOSUID|MS_NODEV|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount bind\");\n\t\tfs_logger2(\"tmpfs\", \"/lib64\");\n\t\tfs_logger(\"mount /lib64\");\n\t}\n\n\tif (is_dir(\"/usr/lib\")) {\n\t\tif (mount(RUN_LIB_DIR, \"/usr/lib\", NULL, MS_BIND|MS_REC, NULL) < 0 ||\n\t\t\tmount(NULL, \"/usr/lib\", NULL, MS_BIND|MS_REMOUNT|MS_NOSUID|MS_NODEV|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount bind\");\n\t\tfs_logger2(\"tmpfs\", \"/usr/lib\");\n\t\tfs_logger(\"mount /usr/lib\");\n\t}\n\n\t// for amd64 only - we'll deal with i386 later\n\tif (is_dir(\"/lib32\")) {\n\t\tif (mount(RUN_RO_DIR, \"/lib32\", \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\terrExit(\"disable file\");\n\t\tfs_logger(\"blacklist-nolog /lib32\");\n\t}\n\tif (is_dir(\"/libx32\")) {\n\t\tif (mount(RUN_RO_DIR, \"/libx32\", \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\terrExit(\"disable file\");\n\t\tfs_logger(\"blacklist-nolog /libx32\");\n\t}\n}\n\nvoid fs_private_lib(void) {\n#ifndef __x86_64__\n\tfwarning(\"private-lib feature is currently available only on amd64 platforms\\n\");\n\treturn;\n#endif\n\tchar *private_list = cfg.lib_private_keep;\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"Starting private-lib processing: program %s, shell %s\\n\",\n\t\t\t(cfg.original_program_index > 0)? cfg.original_argv[cfg.original_program_index]: \"none\",\n\t\t(arg_shell_none)? \"none\": cfg.shell);\n\n\t// create /run/firejail/mnt/lib directory\n\tmkdir_attr(RUN_LIB_DIR, 0755, 0, 0);\n\n\t// install standard C libraries\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"Installing standard C library\\n\");\n\tfslib_install_stdc();\n\n\t// start timetrace\n\ttimetrace_start();\n\n\t// copy the libs in the new lib directory for the main exe\n\tif (cfg.original_program_index > 0) {\n\t\tif (arg_debug || arg_debug_private_lib)\n\t\t\tprintf(\"Installing sandboxed program libraries\\n\");\n\t\tfslib_install_list(cfg.original_argv[cfg.original_program_index]);\n\t}\n\n\t// for the shell\n\tif (!arg_shell_none) {\n\t\tif (arg_debug || arg_debug_private_lib)\n\t\t\tprintf(\"Installing shell libraries\\n\");\n\n\t\tfslib_install_list(cfg.shell);\n\t\t// a shell is useless without some basic commands\n\t\tfslib_install_list(\"/bin/ls,/bin/cat,/bin/mv,/bin/rm\");\n\n\t}\n\n\t// for the listed libs and directories\n\tif (private_list && *private_list != '\\0') {\n\t\tif (arg_debug || arg_debug_private_lib)\n\t\t\tprintf(\"Processing private-lib files\\n\");\n\t\tfslib_install_list(private_list);\n\t}\n\n\t// for private-bin files\n\tif (arg_private_bin && cfg.bin_private_lib && *cfg.bin_private_lib != '\\0') {\n\t\tif (arg_debug || arg_debug_private_lib)\n\t\t\tprintf(\"Processing private-bin files\\n\");\n\t\tfslib_install_list(cfg.bin_private_lib);\n\t}\n\tfmessage(\"Program libraries installed in %0.2f ms\\n\", timetrace_end());\n\n\t// install the reset of the system libraries\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"Installing system libraries\\n\");\n\tfslib_install_system();\n\n\t// bring in firejail directory for --trace and seccomp post exec\n\t// bring in firejail executable libraries in case we are redirected here by a firejail symlink from /usr/local/bin/firejail\n\tfslib_install_list(\"/usr/bin/firejail,firejail\"); // todo: use the installed path for the executable\n\n\tfmessage(\"Installed %d %s and %d %s\\n\", lib_cnt, (lib_cnt == 1)? \"library\": \"libraries\",\n\t\tdir_cnt, (dir_cnt == 1)? \"directory\": \"directories\");\n\n\t// mount lib filesystem\n\tmount_directories();\n}\n", "/*\n * Copyright (C) 2014-2019 Firejail Authors\n *\n * This file is part of firejail project\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n#include \"firejail.h\"\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <dirent.h>\n\nstatic int tmpfs_mounted = 0;\n\n// build /run/firejail directory\nvoid preproc_build_firejail_dir(void) {\n\tstruct stat s;\n\n\t// CentOS 6 doesn't have /run directory\n\tif (stat(RUN_FIREJAIL_BASEDIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_BASEDIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_NETWORK_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_NETWORK_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_BANDWIDTH_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_BANDWIDTH_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_NAME_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_NAME_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_PROFILE_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_PROFILE_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_X11_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_X11_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_APPIMAGE_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_APPIMAGE_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_LIB_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_LIB_DIR, 0755);\n\t}\n\n\tif (stat(RUN_MNT_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_MNT_DIR, 0755);\n\t}\n\n\tcreate_empty_file_as_root(RUN_RO_FILE, S_IRUSR);\n\tcreate_empty_dir_as_root(RUN_RO_DIR, S_IRUSR);\n}\n\n// build /run/firejail/mnt directory\nvoid preproc_mount_mnt_dir(void) {\n\t// mount tmpfs on top of /run/firejail/mnt\n\tif (!tmpfs_mounted) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on %s directory\\n\", RUN_MNT_DIR);\n\t\tif (mount(\"tmpfs\", RUN_MNT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /run/firejail/mnt\");\n\t\ttmpfs_mounted = 1;\n\t\tfs_logger2(\"tmpfs\", RUN_MNT_DIR);\n\n#ifdef HAVE_SECCOMP\n\t\tcreate_empty_dir_as_root(RUN_SECCOMP_DIR, 0755);\n\n\t\tif (arg_seccomp_block_secondary)\n\t\t\tcopy_file(PATH_SECCOMP_BLOCK_SECONDARY, RUN_SECCOMP_BLOCK_SECONDARY, getuid(), getgid(), 0644); // root needed\n\t\telse {\n\t\t\t//copy default seccomp files\n\t\t\tcopy_file(PATH_SECCOMP_32, RUN_SECCOMP_32, getuid(), getgid(), 0644); // root needed\n\t\t}\n\t\tif (arg_allow_debuggers)\n\t\t\tcopy_file(PATH_SECCOMP_DEFAULT_DEBUG, RUN_SECCOMP_CFG, getuid(), getgid(), 0644); // root needed\n\t\telse\n\t\t\tcopy_file(PATH_SECCOMP_DEFAULT, RUN_SECCOMP_CFG, getuid(), getgid(), 0644); // root needed\n\n\t\tif (arg_memory_deny_write_execute)\n\t\t\tcopy_file(PATH_SECCOMP_MDWX, RUN_SECCOMP_MDWX, getuid(), getgid(), 0644); // root needed\n\t\t// as root, create empty RUN_SECCOMP_PROTOCOL and RUN_SECCOMP_POSTEXEC files\n\t\tcreate_empty_file_as_root(RUN_SECCOMP_PROTOCOL, 0644);\n\t\tif (set_perms(RUN_SECCOMP_PROTOCOL, getuid(), getgid(), 0644))\n\t\t\terrExit(\"set_perms\");\n\t\tcreate_empty_file_as_root(RUN_SECCOMP_POSTEXEC, 0644);\n\t\tif (set_perms(RUN_SECCOMP_POSTEXEC, getuid(), getgid(), 0644))\n\t\t\terrExit(\"set_perms\");\n#endif\n\t}\n}\n\nstatic void clean_dir(const char *name, int *pidarr, int start_pid, int max_pids) {\n\tDIR *dir;\n\tif (!(dir = opendir(name))) {\n\t\tfwarning(\"cannot clean %s directory\\n\", name);\n\t\treturn; // we live to fight another day!\n\t}\n\n\t// clean leftover files\n\tstruct dirent *entry;\n\tchar *end;\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\tpid_t pid = strtol(entry->d_name, &end, 10);\n\t\tpid %= max_pids;\n\t\tif (end == entry->d_name || *end)\n\t\t\tcontinue;\n\n\t\tif (pid < start_pid)\n\t\t\tcontinue;\n\t\tif (pidarr[pid] == 0)\n\t\t\tdelete_run_files(pid);\n\t}\n\tclosedir(dir);\n}\n\n\n// clean run directory\nvoid preproc_clean_run(void) {\n\tint max_pids=32769;\n\tint start_pid = 100;\n\t// extract real max_pids\n\tFILE *fp = fopen(\"/proc/sys/kernel/pid_max\", \"r\");\n\tif (fp) {\n\t\tint val;\n\t\tif (fscanf(fp, \"%d\", &val) == 1) {\n\t\t\tif (val > 4194304)\t// this is the max value supported on 64 bit Linux kernels\n\t\t\t\tval = 4194304;\n\t\t\tif (val >= max_pids)\n\t\t\t\tmax_pids = val + 1;\n\t\t}\n\t\tfclose(fp);\n\t}\n\tint *pidarr = malloc(max_pids * sizeof(int));\n\tif (!pidarr)\n\t\terrExit(\"malloc\");\n\n\tmemset(pidarr, 0, max_pids * sizeof(int));\n\n\t// open /proc directory\n\tDIR *dir;\n\tif (!(dir = opendir(\"/proc\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// read /proc and populate pidarr with all active processes\n\tstruct dirent *entry;\n\tchar *end;\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\tpid_t pid = strtol(entry->d_name, &end, 10);\n\t\tpid %= max_pids;\n\t\tif (end == entry->d_name || *end)\n\t\t\tcontinue;\n\n\t\tif (pid < start_pid)\n\t\t\tcontinue;\n\t\tpidarr[pid] = 1;\n\t}\n\tclosedir(dir);\n\n\t// clean profile and name directories\n\tclean_dir(RUN_FIREJAIL_PROFILE_DIR, pidarr, start_pid, max_pids);\n\tclean_dir(RUN_FIREJAIL_NAME_DIR, pidarr, start_pid, max_pids);\n\n\tfree(pidarr);\n}\n", "/*\n * Copyright (C) 2014-2019 Firejail Authors\n *\n * This file is part of firejail project\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n\n#include \"firejail.h\"\n#include <sys/mount.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <errno.h>\n#include <fcntl.h>\n\n#include <sched.h>\n#ifndef CLONE_NEWUSER\n#define CLONE_NEWUSER\t0x10000000\n#endif\n\n#include <sys/prctl.h>\n#ifndef PR_SET_NO_NEW_PRIVS\n# define PR_SET_NO_NEW_PRIVS 38\n#endif\n#ifndef PR_GET_NO_NEW_PRIVS\n# define PR_GET_NO_NEW_PRIVS 39\n#endif\n\n#ifdef HAVE_APPARMOR\n#include <sys/apparmor.h>\n#endif\n#include <syscall.h>\n\n\nstatic int force_nonewprivs = 0;\n\nstatic int monitored_pid = 0;\nstatic void sandbox_handler(int sig){\n\tusleep(10000); // don't race to print a message\n\tfmessage(\"\\nChild received signal %d, shutting down the sandbox...\\n\", sig);\n\n\t// broadcast sigterm to all processes in the group\n\tkill(-1, SIGTERM);\n\tsleep(1);\n\n\tif (monitored_pid) {\n\t\tint monsec = 9;\n\t\tchar *monfile;\n\t\tif (asprintf(&monfile, \"/proc/%d/cmdline\", monitored_pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\twhile (monsec) {\n\t\t\tFILE *fp = fopen(monfile, \"r\");\n\t\t\tif (!fp)\n\t\t\t\tbreak;\n\n\t\t\tchar c;\n\t\t\tsize_t count = fread(&c, 1, 1, fp);\n\t\t\tfclose(fp);\n\t\t\tif (count == 0)\n\t\t\t\tbreak;\n\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Waiting on PID %d to finish\\n\", monitored_pid);\n\t\t\tsleep(1);\n\t\t\tmonsec--;\n\t\t}\n\t\tfree(monfile);\n\t}\n\n\t// broadcast a SIGKILL\n\tkill(-1, SIGKILL);\n\tflush_stdin();\n\n\texit(sig);\n}\n\nstatic void install_handler(void) {\n\tstruct sigaction sga;\n\n\t// block SIGTERM while handling SIGINT\n\tsigemptyset(&sga.sa_mask);\n\tsigaddset(&sga.sa_mask, SIGTERM);\n\tsga.sa_handler = sandbox_handler;\n\tsga.sa_flags = 0;\n\tsigaction(SIGINT, &sga, NULL);\n\n\t// block SIGINT while handling SIGTERM\n\tsigemptyset(&sga.sa_mask);\n\tsigaddset(&sga.sa_mask, SIGINT);\n\tsga.sa_handler = sandbox_handler;\n\tsga.sa_flags = 0;\n\tsigaction(SIGTERM, &sga, NULL);\n}\n\nstatic void set_caps(void) {\n\tif (arg_caps_drop_all)\n\t\tcaps_drop_all();\n\telse if (arg_caps_drop)\n\t\tcaps_drop_list(arg_caps_list);\n\telse if (arg_caps_keep)\n\t\tcaps_keep_list(arg_caps_list);\n\telse if (arg_caps_default_filter)\n\t\tcaps_default_filter();\n\n\t// drop discretionary access control capabilities for root sandboxes\n\t// if caps.keep, the user has to set it manually in the list\n\tif (!arg_caps_keep)\n\t\tcaps_drop_dac_override();\n}\n\nstatic void save_nogroups(void) {\n\tif (arg_nogroups == 0)\n\t\treturn;\n\n\tFILE *fp = fopen(RUN_GROUPS_CFG, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644); // assume mode 0644\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot save nogroups state\\n\");\n\t\texit(1);\n\t}\n}\n\nstatic void save_nonewprivs(void) {\n\tif (arg_nonewprivs == 0)\n\t\treturn;\n\n\tFILE *fp = fopen(RUN_NONEWPRIVS_CFG, \"wxe\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644); // assume mode 0644\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot save nonewprivs state\\n\");\n\t\texit(1);\n\t}\n}\n\nstatic void save_umask(void) {\n\tFILE *fp = fopen(RUN_UMASK_FILE, \"wxe\");\n\tif (fp) {\n\t\tfprintf(fp, \"%o\\n\", orig_umask);\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644); // assume mode 0644\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot save umask\\n\");\n\t\texit(1);\n\t}\n}\n\nstatic FILE *create_ready_for_join_file(void) {\n\tFILE *fp = fopen(RUN_READY_FOR_JOIN, \"wxe\");\n\tif (fp) {\n\t\tASSERT_PERMS_STREAM(fp, 0, 0, 0644);\n\t\treturn fp;\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot create %s\\n\", RUN_READY_FOR_JOIN);\n\t\texit(1);\n\t}\n}\n\nstatic void sandbox_if_up(Bridge *br) {\n\tassert(br);\n\tif (!br->configured)\n\t\treturn;\n\n\tchar *dev = br->devsandbox;\n\tnet_if_up(dev);\n\n\tif (br->arg_ip_none == 1);\t// do nothing\n\telse if (br->arg_ip_none == 0 && br->macvlan == 0) {\n\t\tif (br->ipsandbox == br->ip) {\n\t\t\tfprintf(stderr, \"Error: %d.%d.%d.%d is interface %s address.\\n\", PRINT_IP(br->ipsandbox), br->dev);\n\t\t\texit(1);\n\t\t}\n\n\t\t// just assign the address\n\t\tassert(br->ipsandbox);\n\t\tif (arg_debug)\n\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(br->ipsandbox), dev);\n\t\tnet_config_interface(dev, br->ipsandbox, br->mask, br->mtu);\n\t\tarp_announce(dev, br);\n\t}\n\telse if (br->arg_ip_none == 0 && br->macvlan == 1) {\n\t\t// reassign the macvlan address\n\t\tif (br->ipsandbox == 0)\n\t\t\t// ip address assigned by arp-scan for a macvlan device\n\t\t\tbr->ipsandbox = arp_assign(dev, br); //br->ip, br->mask);\n\t\telse {\n\t\t\tif (br->ipsandbox == br->ip) {\n\t\t\t\tfprintf(stderr, \"Error: %d.%d.%d.%d is interface %s address.\\n\", PRINT_IP(br->ipsandbox), br->dev);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tuint32_t rv = arp_check(dev, br->ipsandbox);\n\t\t\tif (rv) {\n\t\t\t\tfprintf(stderr, \"Error: the address %d.%d.%d.%d is already in use.\\n\", PRINT_IP(br->ipsandbox));\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tif (arg_debug)\n\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(br->ipsandbox), dev);\n\t\tnet_config_interface(dev, br->ipsandbox, br->mask, br->mtu);\n\t\tarp_announce(dev, br);\n\t}\n\n\tif (br->ip6sandbox)\n\t\t net_if_ip6(dev, br->ip6sandbox);\n}\n\nstatic void chk_chroot(void) {\n\t// if we are starting firejail inside some other container technology, we don't care about this\n\tchar *mycont = getenv(\"container\");\n\tif (mycont)\n\t\treturn;\n\n\t// check if this is a regular chroot\n\tstruct stat s;\n\tif (stat(\"/\", &s) == 0) {\n\t\tif (s.st_ino != 2)\n\t\t\treturn;\n\t}\n\n\tfprintf(stderr, \"Error: cannot mount filesystem as slave\\n\");\n\texit(1);\n}\n\nstatic int monitor_application(pid_t app_pid) {\n\tEUID_ASSERT();\n\tmonitored_pid = app_pid;\n\n\t// block signals and install handler\n\tsigset_t oldmask, newmask;\n\tsigemptyset(&oldmask);\n\tsigemptyset(&newmask);\n\tsigaddset(&newmask, SIGTERM);\n\tsigaddset(&newmask, SIGINT);\n\tsigprocmask(SIG_BLOCK, &newmask, &oldmask);\n\tinstall_handler();\n\n\t// handle --timeout\n\tint options = 0;;\n\tunsigned timeout = 0;\n\tif (cfg.timeout) {\n\t\toptions = WNOHANG;\n\t\ttimeout = cfg.timeout;\n\t}\n\n\tint status = 0;\n\twhile (monitored_pid) {\n\t\tusleep(20000);\n\t\tchar *msg;\n\t\tif (asprintf(&msg, \"monitoring pid %d\\n\", monitored_pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tlogmsg(msg);\n\t\tif (arg_debug)\n\t\t\tprintf(\"%s\\n\", msg);\n\t\tfree(msg);\n\n\t\tpid_t rv;\n\t\tdo {\n\t\t\t// handle signals asynchronously\n\t\t\tsigprocmask(SIG_SETMASK, &oldmask, NULL);\n\n\t\t\trv = waitpid(-1, &status, options);\n\n\t\t\t// block signals again\n\t\t\tsigprocmask(SIG_BLOCK, &newmask, NULL);\n\n\t\t\tif (rv == -1) { // we can get here if we have processes joining the sandbox (ECHILD)\n\t\t\t\tsleep(1);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// handle --timeout\n\t\t\tif (options) {\n\t\t\t\tif (--timeout == 0)  {\n\t\t\t\t\tkill(-1, SIGTERM);\n\t\t\t\t\tsleep(1);\n\t\t\t\t\tflush_stdin();\n\t\t\t\t\t_exit(1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsleep(1);\n\t\t\t}\n\t\t}\n\t\twhile(rv != monitored_pid);\n\t\tif (arg_debug)\n\t\t\tprintf(\"Sandbox monitor: waitpid %d retval %d status %d\\n\", monitored_pid, rv, status);\n\n\t\tDIR *dir;\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\t// sleep 2 seconds and try again\n\t\t\tsleep(2);\n\t\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tstruct dirent *entry;\n\t\tmonitored_pid = 0;\n\t\twhile ((entry = readdir(dir)) != NULL) {\n\t\t\tunsigned pid;\n\t\t\tif (sscanf(entry->d_name, \"%u\", &pid) != 1)\n\t\t\t\tcontinue;\n\t\t\tif (pid == 1)\n\t\t\t\tcontinue;\n\n\t\t\t// todo: make this generic\n\t\t\t// Dillo browser leaves a dpid process running, we need to shut it down\n\t\t\tint found = 0;\n\t\t\tif (strcmp(cfg.command_name, \"dillo\") == 0) {\n\t\t\t\tchar *pidname = pid_proc_comm(pid);\n\t\t\t\tif (pidname && strcmp(pidname, \"dpid\") == 0)\n\t\t\t\t\tfound = 1;\n\t\t\t\tfree(pidname);\n\t\t\t}\n\t\t\tif (found)\n\t\t\t\tbreak;\n\n\t\t\tmonitored_pid = pid;\n\t\t\tbreak;\n\t\t}\n\t\tclosedir(dir);\n\n\t\tif (monitored_pid != 0 && arg_debug)\n\t\t\tprintf(\"Sandbox monitor: monitoring %d\\n\", monitored_pid);\n\t}\n\n\t// return the latest exit status.\n\treturn status;\n}\n\nstatic void print_time(void) {\n\tif (start_timestamp) {\n\t\tunsigned long long end_timestamp = getticks();\n\t\t// measure 1 ms\n\t\tusleep(1000);\n\t\tunsigned long long onems = getticks() - end_timestamp;\n\t\tif (onems) {\n\t\t\tfmessage(\"Child process initialized in %.02f ms\\n\",\n\t\t\t\t(float) (end_timestamp - start_timestamp) / (float) onems);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfmessage(\"Child process initialized\\n\");\n}\n\n\n// check execute permissions for the program\n// this is done typically by the shell\n// we are here because of --shell=none\n// we duplicate execvp functionality (man execvp):\n//\t[...] if  the  specified\n//\tfilename  does  not contain a slash (/) character. The file is sought\n//\tin the colon-separated list of directory pathnames  specified  in  the\n//\tPATH  environment  variable.\nstatic int ok_to_run(const char *program) {\n\tif (strstr(program, \"/\")) {\n\t\tif (access(program, X_OK) == 0) // it will also dereference symlinks\n\t\t\treturn 1;\n\t}\n\telse { // search $PATH\n\t\tchar *path1 = getenv(\"PATH\");\n\t\tif (path1) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Searching $PATH for %s\\n\", program);\n\t\t\tchar *path2 = strdup(path1);\n\t\t\tif (!path2)\n\t\t\t\terrExit(\"strdup\");\n\n\t\t\t// use path2 to count the entries\n\t\t\tchar *ptr = strtok(path2, \":\");\n\t\t\twhile (ptr) {\n\t\t\t\tchar *fname;\n\n\t\t\t\tif (asprintf(&fname, \"%s/%s\", ptr, program) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"trying #%s#\\n\", fname);\n\n\t\t\t\tstruct stat s;\n\t\t\t\tint rv = stat(fname, &s);\n\t\t\t\tif (rv == 0) {\n\t\t\t\t\tif (access(fname, X_OK) == 0) {\n\t\t\t\t\t\tfree(path2);\n\t\t\t\t\t\tfree(fname);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tfprintf(stderr, \"Error: execute permission denied for %s\\n\", fname);\n\n\t\t\t\t\tfree(fname);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfree(fname);\n\t\t\t\tptr = strtok(NULL, \":\");\n\t\t\t}\n\t\t\tfree(path2);\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid start_application(int no_sandbox, FILE *fp) {\n\t// set environment\n\tif (no_sandbox == 0) {\n\t\tenv_defaults();\n\t\tenv_apply();\n\t}\n\t// restore original umask\n\tumask(orig_umask);\n\n\tif (arg_debug) {\n\t\tprintf(\"starting application\\n\");\n\t\tprintf(\"LD_PRELOAD=%s\\n\", getenv(\"LD_PRELOAD\"));\n\t}\n\n\t//****************************************\n\t// audit\n\t//****************************************\n\tif (arg_audit) {\n\t\tassert(arg_audit_prog);\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"ready\\n\");\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n#ifdef HAVE_SECCOMP\n\t\tseccomp_install_filters();\n#endif\n\t\texecl(arg_audit_prog, arg_audit_prog, NULL);\n\n\t\tperror(\"execl\");\n\t\texit(1);\n\t}\n\t//****************************************\n\t// start the program without using a shell\n\t//****************************************\n\telse if (arg_shell_none) {\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = cfg.original_program_index; i < cfg.original_argc; i++) {\n\t\t\t\tif (cfg.original_argv[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i - cfg.original_program_index, cfg.original_argv[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (cfg.original_program_index == 0) {\n\t\t\tfprintf(stderr, \"Error: --shell=none configured, but no program specified\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprint_time();\n\n\t\tint rv = ok_to_run(cfg.original_argv[cfg.original_program_index]);\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"ready\\n\");\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n#ifdef HAVE_SECCOMP\n\t\tseccomp_install_filters();\n#endif\n\t\tif (rv)\n\t\t\texecvp(cfg.original_argv[cfg.original_program_index], &cfg.original_argv[cfg.original_program_index]);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: no suitable %s executable found\\n\", cfg.original_argv[cfg.original_program_index]);\n\t\texit(1);\n\t}\n\t//****************************************\n\t// start the program using a shell\n\t//****************************************\n\telse {\n\t\tassert(cfg.shell);\n\t\tassert(cfg.command_line);\n\n\t\tchar *arg[5];\n\t\tint index = 0;\n\t\targ[index++] = cfg.shell;\n\t\tif (login_shell) {\n\t\t\targ[index++] = \"-l\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Starting %s login shell\\n\", cfg.shell);\n\t\t} else {\n\t\t\targ[index++] = \"-c\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Running %s command through %s\\n\", cfg.command_line, cfg.shell);\n\t\t\tif (arg_doubledash)\n\t\t\t\targ[index++] = \"--\";\n\t\t\targ[index++] = cfg.command_line;\n\t\t}\n\t\targ[index] = NULL;\n\t\tassert(index < 5);\n\n\t\tif (arg_debug) {\n\t\t\tchar *msg;\n\t\t\tif (asprintf(&msg, \"sandbox %d, execvp into %s\", sandbox_pid, cfg.command_line) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tlogmsg(msg);\n\t\t\tfree(msg);\n\t\t}\n\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < 5; i++) {\n\t\t\t\tif (arg[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i, arg[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprint_time();\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"ready\\n\");\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n#ifdef HAVE_SECCOMP\n\t\tseccomp_install_filters();\n#endif\n\t\texecvp(arg[0], arg);\n\t}\n\n\tperror(\"execvp\");\n\texit(1); // it should never get here!!!\n}\n\nstatic void enforce_filters(void) {\n\t// enforce NO_NEW_PRIVS\n\targ_nonewprivs = 1;\n\tforce_nonewprivs = 1;\n\n\t// disable all capabilities\n\tfmessage(\"\\n**     Warning: dropping all Linux capabilities     **\\n\");\n\targ_caps_drop_all = 1;\n\n\t// drop all supplementary groups; /etc/group file inside chroot\n\t// is controlled by a regular usr\n\targ_nogroups = 1;\n}\n\nint sandbox(void* sandbox_arg) {\n\t// Get rid of unused parameter warning\n\t(void)sandbox_arg;\n\n\tpid_t child_pid = getpid();\n\tif (arg_debug)\n\t\tprintf(\"Initializing child process\\n\");\n\n \t// close each end of the unused pipes\n \tclose(parent_to_child_fds[1]);\n \tclose(child_to_parent_fds[0]);\n\n \t// wait for parent to do base setup\n \twait_for_other(parent_to_child_fds[0]);\n\n\tif (arg_debug && child_pid == 1)\n\t\tprintf(\"PID namespace installed\\n\");\n\n\n\t//****************************\n\t// set hostname\n\t//****************************\n\tif (cfg.hostname) {\n\t\tif (sethostname(cfg.hostname, strlen(cfg.hostname)) < 0)\n\t\t\terrExit(\"sethostname\");\n\t}\n\n\t//****************************\n\t// mount namespace\n\t//****************************\n\t// mount events are not forwarded between the host the sandbox\n\tif (mount(NULL, \"/\", NULL, MS_SLAVE | MS_REC, NULL) < 0) {\n\t\tchk_chroot();\n\t}\n\t// ... and mount a tmpfs on top of /run/firejail/mnt directory\n\tpreproc_mount_mnt_dir();\n\t// bind-mount firejail binaries and helper programs\n\tif (mount(LIBDIR \"/firejail\", RUN_FIREJAIL_LIB_DIR, \"none\", MS_BIND, NULL) < 0)\n\t\terrExit(\"mounting \" RUN_FIREJAIL_LIB_DIR);\n\n\t//****************************\n\t// log sandbox data\n\t//****************************\n\tif (cfg.name)\n\t\tfs_logger2(\"sandbox name:\", cfg.name);\n\tfs_logger2int(\"sandbox pid:\", (int) sandbox_pid);\n\tif (cfg.chrootdir)\n\t\tfs_logger(\"sandbox filesystem: chroot\");\n\telse if (arg_overlay)\n\t\tfs_logger(\"sandbox filesystem: overlay\");\n\telse\n\t\tfs_logger(\"sandbox filesystem: local\");\n\tfs_logger(\"install mount namespace\");\n\n\t//****************************\n\t// netfilter\n\t//****************************\n\tif (arg_netfilter && any_bridge_configured()) { // assuming by default the client filter\n\t\tnetfilter(arg_netfilter_file);\n\t}\n\tif (arg_netfilter6 && any_bridge_configured()) { // assuming by default the client filter\n\t\tnetfilter6(arg_netfilter6_file);\n\t}\n\n\t//****************************\n\t// networking\n\t//****************************\n\tint gw_cfg_failed = 0; // default gw configuration flag\n\tif (arg_nonetwork) {\n\t\tnet_if_up(\"lo\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Network namespace enabled, only loopback interface available\\n\");\n\t}\n\telse if (arg_netns) {\n\t\tnetns(arg_netns);\n\t\tif (arg_debug)\n\t\t\tprintf(\"Network namespace '%s' activated\\n\", arg_netns);\n\t}\n\telse if (any_bridge_configured() || any_interface_configured()) {\n\t\t// configure lo and eth0...eth3\n\t\tnet_if_up(\"lo\");\n\n\t\tif (mac_not_zero(cfg.bridge0.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge0.devsandbox, cfg.bridge0.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge0);\n\n\t\tif (mac_not_zero(cfg.bridge1.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge1.devsandbox, cfg.bridge1.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge1);\n\n\t\tif (mac_not_zero(cfg.bridge2.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge2.devsandbox, cfg.bridge2.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge2);\n\n\t\tif (mac_not_zero(cfg.bridge3.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge3.devsandbox, cfg.bridge3.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge3);\n\n\n\t\t// moving an interface in a namespace using --interface will reset the interface configuration;\n\t\t// we need to put the configuration back\n\t\tif (cfg.interface0.configured && cfg.interface0.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface0.ip), cfg.interface0.dev);\n\t\t\tnet_config_interface(cfg.interface0.dev, cfg.interface0.ip, cfg.interface0.mask, cfg.interface0.mtu);\n\t\t}\n\t\tif (cfg.interface1.configured && cfg.interface1.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface1.ip), cfg.interface1.dev);\n\t\t\tnet_config_interface(cfg.interface1.dev, cfg.interface1.ip, cfg.interface1.mask, cfg.interface1.mtu);\n\t\t}\n\t\tif (cfg.interface2.configured && cfg.interface2.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface2.ip), cfg.interface2.dev);\n\t\t\tnet_config_interface(cfg.interface2.dev, cfg.interface2.ip, cfg.interface2.mask, cfg.interface2.mtu);\n\t\t}\n\t\tif (cfg.interface3.configured && cfg.interface3.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface3.ip), cfg.interface3.dev);\n\t\t\tnet_config_interface(cfg.interface3.dev, cfg.interface3.ip, cfg.interface3.mask, cfg.interface3.mtu);\n\t\t}\n\n\t\t// add a default route\n\t\tif (cfg.defaultgw) {\n\t\t\t// set the default route\n\t\t\tif (net_add_route(0, 0, cfg.defaultgw)) {\n\t\t\t\tfwarning(\"cannot configure default route\\n\");\n\t\t\t\tgw_cfg_failed = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (arg_debug)\n\t\t\tprintf(\"Network namespace enabled\\n\");\n\t}\n\n\t// print network configuration\n\tif (!arg_quiet) {\n\t\tif (any_bridge_configured() || any_interface_configured() || cfg.defaultgw || cfg.dns1) {\n\t\t\tfmessage(\"\\n\");\n\t\t\tif (any_bridge_configured() || any_interface_configured()) {\n\t\t\t\tif (arg_scan)\n\t\t\t\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 3, PATH_FNET, \"printif\", \"scan\");\n\t\t\t\telse\n\t\t\t\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 2, PATH_FNET, \"printif\");\n\n\t\t\t}\n\t\t\tif (cfg.defaultgw != 0) {\n\t\t\t\tif (gw_cfg_failed)\n\t\t\t\t\tfmessage(\"Default gateway configuration failed\\n\");\n\t\t\t\telse\n\t\t\t\t\tfmessage(\"Default gateway %d.%d.%d.%d\\n\", PRINT_IP(cfg.defaultgw));\n\t\t\t}\n\t\t\tif (cfg.dns1 != NULL)\n\t\t\t\tfmessage(\"DNS server %s\\n\", cfg.dns1);\n\t\t\tif (cfg.dns2 != NULL)\n\t\t\t\tfmessage(\"DNS server %s\\n\", cfg.dns2);\n\t\t\tif (cfg.dns3 != NULL)\n\t\t\t\tfmessage(\"DNS server %s\\n\", cfg.dns3);\n\t\t\tif (cfg.dns4 != NULL)\n\t\t\t\tfmessage(\"DNS server %s\\n\", cfg.dns4);\n\t\t\tfmessage(\"\\n\");\n\t\t}\n\t}\n\n\t// load IBUS env variables\n\tif (arg_nonetwork || any_bridge_configured() || any_interface_configured()) {\n\t\t// do nothing - there are problems with ibus version 1.5.11\n\t}\n\telse {\n\t\tEUID_USER();\n\t\tenv_ibus_load();\n\t\tEUID_ROOT();\n\t}\n\n\t//****************************\n\t// fs pre-processing:\n\t//  - build seccomp filters\n\t//  - create an empty /etc/ld.so.preload\n\t//****************************\n#ifdef HAVE_SECCOMP\n\tif (cfg.protocol) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Build protocol filter: %s\\n\", cfg.protocol);\n\n\t\t// build the seccomp filter as a regular user\n\t\tint rv = sbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 5,\n\t\t\tPATH_FSECCOMP, \"protocol\", \"build\", cfg.protocol, RUN_SECCOMP_PROTOCOL);\n\t\tif (rv)\n\t\t\texit(rv);\n\t}\n\tif (arg_seccomp && (cfg.seccomp_list || cfg.seccomp_list_drop || cfg.seccomp_list_keep))\n\t\targ_seccomp_postexec = 1;\n#endif\n\n\t// need ld.so.preload if tracing or seccomp with any non-default lists\n\tbool need_preload = arg_trace || arg_tracelog || arg_seccomp_postexec;\n\t// for --appimage, --chroot and --overlay* we force NO_NEW_PRIVS\n\t// and drop all capabilities\n\tif (getuid() != 0 && (arg_appimage || cfg.chrootdir || arg_overlay)) {\n\t\tenforce_filters();\n\t\tneed_preload = arg_trace || arg_tracelog;\n\t}\n\n\t// trace pre-install\n\tif (need_preload)\n\t\tfs_trace_preload();\n\n\t// store hosts file\n\tif (cfg.hosts_file)\n\t\tfs_store_hosts_file();\n\n\t//****************************\n\t// configure filesystem\n\t//****************************\n#ifdef HAVE_CHROOT\n\tif (cfg.chrootdir) {\n\t\tfs_chroot(cfg.chrootdir);\n\n\t\t//****************************\n\t\t// trace pre-install, this time inside chroot\n\t\t//****************************\n\t\tif (need_preload)\n\t\t\tfs_trace_preload();\n\t}\n\telse\n#endif\n#ifdef HAVE_OVERLAYFS\n\tif (arg_overlay)\n\t\tfs_overlayfs();\n\telse\n#endif\n\t\tfs_basic_fs();\n\n\t//****************************\n\t// private mode\n\t//****************************\n\tif (arg_private) {\n\t\tif (cfg.home_private) {\t// --private=\n\t\t\tif (cfg.chrootdir)\n\t\t\t\tfwarning(\"private=directory feature is disabled in chroot\\n\");\n\t\t\telse if (arg_overlay)\n\t\t\t\tfwarning(\"private=directory feature is disabled in overlay\\n\");\n\t\t\telse\n\t\t\t\tfs_private_homedir();\n\t\t}\n\t\telse if (cfg.home_private_keep) { // --private-home=\n\t\t\tif (cfg.chrootdir)\n\t\t\t\tfwarning(\"private-home= feature is disabled in chroot\\n\");\n\t\t\telse if (arg_overlay)\n\t\t\t\tfwarning(\"private-home= feature is disabled in overlay\\n\");\n\t\t\telse\n\t\t\t\tfs_private_home_list();\n\t\t}\n\t\telse // --private\n\t\t\tfs_private();\n\t}\n\n\tif (arg_private_dev)\n\t\tfs_private_dev();\n\n\tif (arg_private_etc) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-etc feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-etc feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\tfs_private_dir_list(\"/etc\", RUN_ETC_DIR, cfg.etc_private_keep);\n\t\t\t// create /etc/ld.so.preload file again\n\t\t\tif (need_preload)\n\t\t\t\tfs_trace_preload();\n\t\t}\n\t}\n\n\tif (arg_private_opt) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-opt feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-opt feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\tfs_private_dir_list(\"/opt\", RUN_OPT_DIR, cfg.opt_private_keep);\n\t\t}\n\t}\n\n\tif (arg_private_srv) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-srv feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-srv feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\tfs_private_dir_list(\"/srv\", RUN_SRV_DIR, cfg.srv_private_keep);\n\t\t}\n\t}\n\n\t// private-bin is disabled for appimages\n\tif (arg_private_bin && !arg_appimage) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-bin feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-bin feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\t// for --x11=xorg we need to add xauth command\n\t\t\tif (arg_x11_xorg) {\n\t\t\t\tEUID_USER();\n\t\t\t\tchar *tmp;\n\t\t\t\tif (asprintf(&tmp, \"%s,xauth\", cfg.bin_private_keep) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tcfg.bin_private_keep = tmp;\n\t\t\t\tEUID_ROOT();\n\t\t\t}\n\t\t\tfs_private_bin_list();\n\t\t}\n\t}\n\n\t// private-lib is disabled for appimages\n\tif (arg_private_lib && !arg_appimage) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-lib feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-lib feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\tfs_private_lib();\n\t\t}\n\t}\n\n\tif (arg_private_cache) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-cache feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-cache feature is disabled in overlay\\n\");\n\t\telse\n\t\t\tfs_private_cache();\n\t}\n\n\tif (arg_private_tmp) {\n\t\t// private-tmp is implemented as a whitelist\n\t\tEUID_USER();\n\t\tfs_private_tmp();\n\t\tEUID_ROOT();\n\t}\n\n\t//****************************\n\t// Session D-BUS\n\t//****************************\n\tif (arg_nodbus)\n\t\tdbus_session_disable();\n\n\n\t//****************************\n\t// hosts and hostname\n\t//****************************\n\tif (cfg.hostname)\n\t\tfs_hostname(cfg.hostname);\n\n\tif (cfg.hosts_file)\n\t\tfs_mount_hosts_file();\n\n\t//****************************\n\t// /etc overrides from the network namespace\n\t//****************************\n\tif (arg_netns)\n\t\tnetns_mounts(arg_netns);\n\n\t//****************************\n\t// update /proc, /sys, /dev, /boot directory\n\t//****************************\n\tfs_proc_sys_dev_boot();\n\n\t//****************************\n\t// handle /mnt and /media\n\t//****************************\n\tif (checkcfg(CFG_DISABLE_MNT))\n\t\tfs_mnt(1);\n\telse if (arg_disable_mnt)\n\t\tfs_mnt(0);\n\n\t//****************************\n\t// apply the profile file\n\t//****************************\n\t// apply all whitelist commands ...\n\tfs_whitelist();\n\n\t// ... followed by blacklist commands\n\tfs_blacklist(); // mkdir and mkfile are processed all over again\n\n\t//****************************\n\t// nosound/no3d/notv/novideo and fix for pulseaudio 7.0\n\t//****************************\n\tif (arg_nosound) {\n\t\t// disable pulseaudio\n\t\tpulseaudio_disable();\n\n\t\t// disable /dev/snd\n\t\tfs_dev_disable_sound();\n\t}\n\telse if (!arg_noautopulse)\n\t\tpulseaudio_init();\n\n\tif (arg_no3d)\n\t\tfs_dev_disable_3d();\n\n\tif (arg_notv)\n\t\tfs_dev_disable_tv();\n\n\tif (arg_nodvd)\n\t\tfs_dev_disable_dvd();\n\n\tif (arg_nou2f)\n\t        fs_dev_disable_u2f();\n\n\tif (arg_novideo)\n\t\tfs_dev_disable_video();\n\n\t//****************************\n\t// install trace\n\t//****************************\n\tif (need_preload)\n\t\tfs_trace();\n\n\t//****************************\n\t// set dns\n\t//****************************\n\tfs_resolvconf();\n\n\t//****************************\n\t// fs post-processing\n\t//****************************\n\tfs_logger_print();\n\tfs_logger_change_owner();\n\n\t//****************************\n\t// set application environment\n\t//****************************\n\tEUID_USER();\n\tint cwd = 0;\n\tif (cfg.cwd) {\n\t\tif (chdir(cfg.cwd) == 0)\n\t\t\tcwd = 1;\n\t}\n\n\tif (!cwd) {\n\t\tif (chdir(\"/\") < 0)\n\t\t\terrExit(\"chdir\");\n\t\tif (cfg.homedir) {\n\t\t\tstruct stat s;\n\t\t\tif (stat(cfg.homedir, &s) == 0) {\n\t\t\t\t/* coverity[toctou] */\n\t\t\t\tif (chdir(cfg.homedir) < 0)\n\t\t\t\t\terrExit(\"chdir\");\n\t\t\t}\n\t\t}\n\t}\n\tif (arg_debug) {\n\t\tchar *cpath = get_current_dir_name();\n\t\tif (cpath) {\n\t\t\tprintf(\"Current directory: %s\\n\", cpath);\n\t\t\tfree(cpath);\n\t\t}\n\t}\n\n\tEUID_ROOT();\n\t// clean /tmp/.X11-unix sockets\n\tfs_x11();\n\tif (arg_x11_xorg)\n\t\tx11_xorg();\n\n\t// save original umask\n\tsave_umask();\n\n\t//****************************\n\t// set security filters\n\t//****************************\n\t// save state of nonewprivs\n\tsave_nonewprivs();\n\n\t// save cpu affinity mask to CPU_CFG file\n\tsave_cpu();\n\n\t// save cgroup in CGROUP_CFG file\n\tsave_cgroup();\n\n\t// set seccomp\n#ifdef HAVE_SECCOMP\n\t// install protocol filter\n#ifdef SYS_socket\n\tif (cfg.protocol) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Install protocol filter: %s\\n\", cfg.protocol);\n\t\tseccomp_load(RUN_SECCOMP_PROTOCOL);\t// install filter\n\t\tprotocol_filter_save();\t// save filter in RUN_PROTOCOL_CFG\n\t}\n\telse {\n\t\tint rv = unlink(RUN_SECCOMP_PROTOCOL);\n\t\t(void) rv;\n\t}\n#endif\n\n\t// if a keep list is available, disregard the drop list\n\tif (arg_seccomp == 1) {\n\t\tif (cfg.seccomp_list_keep)\n\t\t\tseccomp_filter_keep();\n\t\telse\n\t\t\tseccomp_filter_drop();\n\n\t}\n\telse { // clean seccomp files under /run/firejail/mnt\n\t\tint rv = unlink(RUN_SECCOMP_CFG);\n\t\trv |= unlink(RUN_SECCOMP_32);\n\t\t(void) rv;\n\t}\n\n\tif (arg_memory_deny_write_execute) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Install memory write&execute filter\\n\");\n\t\tseccomp_load(RUN_SECCOMP_MDWX);\t// install filter\n\t}\n\telse {\n\t\tint rv = unlink(RUN_SECCOMP_MDWX);\n\t\t(void) rv;\n\t}\n\t// make seccomp filters read-only\n\tfs_rdonly(RUN_SECCOMP_DIR);\n#endif\n\n\t// set capabilities\n\tset_caps();\n\n\t//****************************************\n\t// communicate progress of sandbox set up\n\t// to --join\n\t//****************************************\n\n\tFILE *rj = create_ready_for_join_file();\n\n\t//****************************************\n\t// create a new user namespace\n\t//     - too early to drop privileges\n\t//****************************************\n\tsave_nogroups();\n\tif (arg_noroot) {\n\t\tint rv = unshare(CLONE_NEWUSER);\n\t\tif (rv == -1) {\n\t\t\tfwarning(\"cannot create a new user namespace, going forward without it...\\n\");\n\t\t\targ_noroot = 0;\n\t\t}\n\t}\n\n\t// notify parent that new user namespace has been created so a proper\n \t// UID/GID map can be setup\n \tnotify_other(child_to_parent_fds[1]);\n \tclose(child_to_parent_fds[1]);\n\n \t// wait for parent to finish setting up a proper UID/GID map\n \twait_for_other(parent_to_child_fds[0]);\n \tclose(parent_to_child_fds[0]);\n\n\t// somehow, the new user namespace resets capabilities;\n\t// we need to do them again\n\tif (arg_noroot) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"noroot user namespace installed\\n\");\n\t\tset_caps();\n\t}\n\n\t//****************************************\n\t// Set NO_NEW_PRIVS if desired\n\t//****************************************\n\tif (arg_nonewprivs) {\n\t\tprctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\n\t\tif (prctl(PR_GET_NO_NEW_PRIVS, 0, 0, 0, 0) != 1) {\n\t\t\tfwarning(\"cannot set NO_NEW_PRIVS, it requires a Linux kernel version 3.5 or newer.\\n\");\n\t\t\tif (force_nonewprivs) {\n\t\t\t\tfprintf(stderr, \"Error: NO_NEW_PRIVS required for this sandbox, exiting ...\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (arg_debug)\n\t\t\tprintf(\"NO_NEW_PRIVS set\\n\");\n\t}\n\n\t//****************************************\n\t// drop privileges\n\t//****************************************\n\tdrop_privs(arg_nogroups);\n\n\t// kill the sandbox in case the parent died\n\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);\n\n\t//****************************************\n\t// set cpu affinity\n\t//****************************************\n\n\tif (cfg.cpus)\n\t\tset_cpu_affinity();\n\n\t//****************************************\n\t// fork the application and monitor it\n\t//****************************************\n\tpid_t app_pid = fork();\n\tif (app_pid == -1)\n\t\terrExit(\"fork\");\n\n\tif (app_pid == 0) {\n#ifdef HAVE_APPARMOR\n\t\tif (checkcfg(CFG_APPARMOR) && arg_apparmor) {\n\t\t\terrno = 0;\n\t\t\tif (aa_change_onexec(\"firejail-default\")) {\n\t\t\t\tfwarning(\"Cannot confine the application using AppArmor.\\n\"\n\t\t\t\t\t\"Maybe firejail-default AppArmor profile is not loaded into the kernel.\\n\"\n\t\t\t\t\t\"As root, run \\\"aa-enforce firejail-default\\\" to load it.\\n\");\n\t\t\t}\n\t\t\telse if (arg_debug)\n\t\t\t\tprintf(\"AppArmor enabled\\n\");\n\t\t}\n#endif\n\t\t// set nice and rlimits\n\t\tif (arg_nice)\n\t\t\tset_nice(cfg.nice);\n\t\tset_rlimits();\n\n\t\tstart_application(0, rj);\n\t}\n\n\tfclose(rj);\n\n\tint status = monitor_application(app_pid);\t// monitor application\n\tflush_stdin();\n\n\tif (WIFEXITED(status)) {\n\t\t// if we had a proper exit, return that exit status\n\t\treturn WEXITSTATUS(status);\n\t} else {\n\t\t// something else went wrong!\n\t\treturn -1;\n\t}\n}\n"], "filenames": ["src/firejail/firejail.h", "src/firejail/fs_lib.c", "src/firejail/preproc.c", "src/firejail/sandbox.c"], "buggy_code_start_loc": [60, 135, 88, 1056], "buggy_code_end_loc": [99, 135, 88, 1105], "fixing_code_start_loc": [60, 136, 89, 1055], "fixing_code_end_loc": [98, 137, 91, 1107], "type": "CWE-732", "message": "In Firejail before 0.9.60, seccomp filters are writable inside the jail, leading to a lack of intended seccomp restrictions for a process that is joined to the jail after a filter has been modified by an attacker.", "other": {"cve": {"id": "CVE-2019-12589", "sourceIdentifier": "cve@mitre.org", "published": "2019-06-03T03:29:00.320", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In Firejail before 0.9.60, seccomp filters are writable inside the jail, leading to a lack of intended seccomp restrictions for a process that is joined to the jail after a filter has been modified by an attacker."}, {"lang": "es", "value": "En Firejail versi\u00f3n anterior a la 0.9.60, los filtros seccomp son escribibles dentro de la cadena lo que conlleva a una falta de restricciones previstas de seccomp para un proceso que se une a la jaula despu\u00e9s de que un filtro haya sido modificado por un atacante ."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.0, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-732"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:firejail_project:firejail:*:*:*:*:-:*:*:*", "versionEndExcluding": "0.9.60", "matchCriteriaId": "D201C371-BB17-4E90-8125-740E84785DE4"}]}]}], "references": [{"url": "https://github.com/netblue30/firejail/commit/eecf35c2f8249489a1d3e512bb07f0d427183134", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/netblue30/firejail/issues/2718", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/netblue30/firejail/releases/tag/0.9.60", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/CDY7B73YDRBURA25APSHD5PFEO4TNSFW/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/RGVULJ6IKVDO6UAVIQRHQVSKOUD6QDWM/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/netblue30/firejail/commit/eecf35c2f8249489a1d3e512bb07f0d427183134"}}