{"buggy_code": ["/*\n * VC3/DNxHD decoder.\n * Copyright (c) 2007 SmartJog S.A., Baptiste Coudurier <baptiste dot coudurier at smartjog dot com>\n * Copyright (c) 2011 MirriAd Ltd\n * Copyright (c) 2015 Christophe Gisquet\n *\n * 10 bit support added by MirriAd Ltd, Joseph Artsimovich <joseph@mirriad.com>\n * Slice multithreading and MB interlaced support added by Christophe Gisquet\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"libavutil/imgutils.h\"\n#include \"libavutil/timer.h\"\n#include \"avcodec.h\"\n#include \"blockdsp.h\"\n#define  UNCHECKED_BITSTREAM_READER 1\n#include \"get_bits.h\"\n#include \"dnxhddata.h\"\n#include \"idctdsp.h\"\n#include \"internal.h\"\n#include \"profiles.h\"\n#include \"thread.h\"\n\ntypedef struct RowContext {\n    DECLARE_ALIGNED(16, int16_t, blocks)[12][64];\n    int luma_scale[64];\n    int chroma_scale[64];\n    GetBitContext gb;\n    int last_dc[3];\n    int last_qscale;\n    int errors;\n    /** -1:not set yet  0:off=RGB  1:on=YUV  2:variable */\n    int format;\n} RowContext;\n\ntypedef struct DNXHDContext {\n    AVCodecContext *avctx;\n    RowContext *rows;\n    BlockDSPContext bdsp;\n    const uint8_t* buf;\n    int buf_size;\n    int64_t cid;                        ///< compression id\n    unsigned int width, height;\n    enum AVPixelFormat pix_fmt;\n    unsigned int mb_width, mb_height;\n    uint32_t mb_scan_index[512];\n    int data_offset;                    // End of mb_scan_index, where macroblocks start\n    int cur_field;                      ///< current interlaced field\n    VLC ac_vlc, dc_vlc, run_vlc;\n    IDCTDSPContext idsp;\n    ScanTable scantable;\n    const CIDEntry *cid_table;\n    int bit_depth; // 8, 10, 12 or 0 if not initialized at all.\n    int is_444;\n    int mbaff;\n    int act;\n    int (*decode_dct_block)(const struct DNXHDContext *ctx,\n                            RowContext *row, int n);\n} DNXHDContext;\n\n#define DNXHD_VLC_BITS 9\n#define DNXHD_DC_VLC_BITS 7\n\nstatic int dnxhd_decode_dct_block_8(const DNXHDContext *ctx,\n                                    RowContext *row, int n);\nstatic int dnxhd_decode_dct_block_10(const DNXHDContext *ctx,\n                                     RowContext *row, int n);\nstatic int dnxhd_decode_dct_block_10_444(const DNXHDContext *ctx,\n                                         RowContext *row, int n);\nstatic int dnxhd_decode_dct_block_12(const DNXHDContext *ctx,\n                                     RowContext *row, int n);\nstatic int dnxhd_decode_dct_block_12_444(const DNXHDContext *ctx,\n                                         RowContext *row, int n);\n\nstatic av_cold int dnxhd_decode_init(AVCodecContext *avctx)\n{\n    DNXHDContext *ctx = avctx->priv_data;\n\n    ctx->avctx = avctx;\n    ctx->cid = -1;\n    avctx->colorspace = AVCOL_SPC_BT709;\n\n    avctx->coded_width  = FFALIGN(avctx->width,  16);\n    avctx->coded_height = FFALIGN(avctx->height, 16);\n\n    ctx->rows = av_mallocz_array(avctx->thread_count, sizeof(RowContext));\n    if (!ctx->rows)\n        return AVERROR(ENOMEM);\n\n    return 0;\n}\n\nstatic int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid, int bitdepth)\n{\n    if (cid != ctx->cid) {\n        int index;\n\n        if ((index = ff_dnxhd_get_cid_table(cid)) < 0) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"unsupported cid %\"PRIu32\"\\n\", cid);\n            return AVERROR(ENOSYS);\n        }\n        if (ff_dnxhd_cid_table[index].bit_depth != bitdepth &&\n            ff_dnxhd_cid_table[index].bit_depth != DNXHD_VARIABLE) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"bit depth mismatches %d %d\\n\", ff_dnxhd_cid_table[index].bit_depth, bitdepth);\n            return AVERROR_INVALIDDATA;\n        }\n        ctx->cid_table = &ff_dnxhd_cid_table[index];\n        av_log(ctx->avctx, AV_LOG_VERBOSE, \"Profile cid %\"PRIu32\".\\n\", cid);\n\n        ff_free_vlc(&ctx->ac_vlc);\n        ff_free_vlc(&ctx->dc_vlc);\n        ff_free_vlc(&ctx->run_vlc);\n\n        init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,\n                 ctx->cid_table->ac_bits, 1, 1,\n                 ctx->cid_table->ac_codes, 2, 2, 0);\n        init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, bitdepth > 8 ? 14 : 12,\n                 ctx->cid_table->dc_bits, 1, 1,\n                 ctx->cid_table->dc_codes, 1, 1, 0);\n        init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,\n                 ctx->cid_table->run_bits, 1, 1,\n                 ctx->cid_table->run_codes, 2, 2, 0);\n\n        ctx->cid = cid;\n    }\n    return 0;\n}\n\nstatic av_cold int dnxhd_decode_init_thread_copy(AVCodecContext *avctx)\n{\n    DNXHDContext *ctx = avctx->priv_data;\n\n    ctx->avctx = avctx;\n    // make sure VLC tables will be loaded when cid is parsed\n    ctx->cid = -1;\n\n    ctx->rows = av_mallocz_array(avctx->thread_count, sizeof(RowContext));\n    if (!ctx->rows)\n        return AVERROR(ENOMEM);\n\n    return 0;\n}\n\nstatic int dnxhd_get_profile(int cid)\n{\n    switch(cid) {\n    case 1270:\n        return FF_PROFILE_DNXHR_444;\n    case 1271:\n        return FF_PROFILE_DNXHR_HQX;\n    case 1272:\n        return FF_PROFILE_DNXHR_HQ;\n    case 1273:\n        return FF_PROFILE_DNXHR_SQ;\n    case 1274:\n        return FF_PROFILE_DNXHR_LB;\n    }\n    return FF_PROFILE_DNXHD;\n}\n\nstatic int dnxhd_decode_header(DNXHDContext *ctx, AVFrame *frame,\n                               const uint8_t *buf, int buf_size,\n                               int first_field)\n{\n    int i, cid, ret;\n    int old_bit_depth = ctx->bit_depth, bitdepth;\n    uint64_t header_prefix;\n    if (buf_size < 0x280) {\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"buffer too small (%d < 640).\\n\", buf_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    header_prefix = ff_dnxhd_parse_header_prefix(buf);\n    if (header_prefix == 0) {\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"unknown header 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\n               buf[0], buf[1], buf[2], buf[3], buf[4]);\n        return AVERROR_INVALIDDATA;\n    }\n    if (buf[5] & 2) { /* interlaced */\n        ctx->cur_field = buf[5] & 1;\n        frame->interlaced_frame = 1;\n        frame->top_field_first  = first_field ^ ctx->cur_field;\n        av_log(ctx->avctx, AV_LOG_DEBUG,\n               \"interlaced %d, cur field %d\\n\", buf[5] & 3, ctx->cur_field);\n    } else {\n        ctx->cur_field = 0;\n    }\n    ctx->mbaff = (buf[0x6] >> 5) & 1;\n\n    ctx->height = AV_RB16(buf + 0x18);\n    ctx->width  = AV_RB16(buf + 0x1a);\n\n    switch(buf[0x21] >> 5) {\n    case 1: bitdepth = 8; break;\n    case 2: bitdepth = 10; break;\n    case 3: bitdepth = 12; break;\n    default:\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"Unknown bitdepth indicator (%d)\\n\", buf[0x21] >> 5);\n        return AVERROR_INVALIDDATA;\n    }\n\n    cid = AV_RB32(buf + 0x28);\n\n    ctx->avctx->profile = dnxhd_get_profile(cid);\n\n    if ((ret = dnxhd_init_vlc(ctx, cid, bitdepth)) < 0)\n        return ret;\n    if (ctx->mbaff && ctx->cid_table->cid != 1260)\n        av_log(ctx->avctx, AV_LOG_WARNING,\n               \"Adaptive MB interlace flag in an unsupported profile.\\n\");\n\n    ctx->act = buf[0x2C] & 7;\n    if (ctx->act && ctx->cid_table->cid != 1256 && ctx->cid_table->cid != 1270)\n        av_log(ctx->avctx, AV_LOG_WARNING,\n               \"Adaptive color transform in an unsupported profile.\\n\");\n\n    ctx->is_444 = (buf[0x2C] >> 6) & 1;\n    if (ctx->is_444) {\n        if (bitdepth == 8) {\n            avpriv_request_sample(ctx->avctx, \"4:4:4 8 bits\");\n            return AVERROR_INVALIDDATA;\n        } else if (bitdepth == 10) {\n            ctx->decode_dct_block = dnxhd_decode_dct_block_10_444;\n            ctx->pix_fmt = ctx->act ? AV_PIX_FMT_YUV444P10\n                                    : AV_PIX_FMT_GBRP10;\n        } else {\n            ctx->decode_dct_block = dnxhd_decode_dct_block_12_444;\n            ctx->pix_fmt = ctx->act ? AV_PIX_FMT_YUV444P12\n                                    : AV_PIX_FMT_GBRP12;\n        }\n    } else if (bitdepth == 12) {\n        ctx->decode_dct_block = dnxhd_decode_dct_block_12;\n        ctx->pix_fmt = AV_PIX_FMT_YUV422P12;\n    } else if (bitdepth == 10) {\n        if (ctx->avctx->profile == FF_PROFILE_DNXHR_HQX)\n            ctx->decode_dct_block = dnxhd_decode_dct_block_10_444;\n        else\n            ctx->decode_dct_block = dnxhd_decode_dct_block_10;\n        ctx->pix_fmt = AV_PIX_FMT_YUV422P10;\n    } else {\n        ctx->decode_dct_block = dnxhd_decode_dct_block_8;\n        ctx->pix_fmt = AV_PIX_FMT_YUV422P;\n    }\n\n    ctx->avctx->bits_per_raw_sample = ctx->bit_depth = bitdepth;\n    if (ctx->bit_depth != old_bit_depth) {\n        ff_blockdsp_init(&ctx->bdsp, ctx->avctx);\n        ff_idctdsp_init(&ctx->idsp, ctx->avctx);\n        ff_init_scantable(ctx->idsp.idct_permutation, &ctx->scantable,\n                          ff_zigzag_direct);\n    }\n\n    // make sure profile size constraints are respected\n    // DNx100 allows 1920->1440 and 1280->960 subsampling\n    if (ctx->width != ctx->cid_table->width &&\n        ctx->cid_table->width != DNXHD_VARIABLE) {\n        av_reduce(&ctx->avctx->sample_aspect_ratio.num,\n                  &ctx->avctx->sample_aspect_ratio.den,\n                  ctx->width, ctx->cid_table->width, 255);\n        ctx->width = ctx->cid_table->width;\n    }\n\n    if (buf_size < ctx->cid_table->coding_unit_size) {\n        av_log(ctx->avctx, AV_LOG_ERROR, \"incorrect frame size (%d < %u).\\n\",\n               buf_size, ctx->cid_table->coding_unit_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    ctx->mb_width  = (ctx->width + 15)>> 4;\n    ctx->mb_height = AV_RB16(buf + 0x16c);\n\n    if ((ctx->height + 15) >> 4 == ctx->mb_height && frame->interlaced_frame)\n        ctx->height <<= 1;\n\n    av_log(ctx->avctx, AV_LOG_VERBOSE, \"%dx%d, 4:%s %d bits, MBAFF=%d ACT=%d\\n\",\n           ctx->width, ctx->height, ctx->is_444 ? \"4:4\" : \"2:2\",\n           ctx->bit_depth, ctx->mbaff, ctx->act);\n\n    // Newer format supports variable mb_scan_index sizes\n    if (ctx->mb_height > 68 && ff_dnxhd_check_header_prefix_hr(header_prefix)) {\n        ctx->data_offset = 0x170 + (ctx->mb_height << 2);\n    } else {\n        if (ctx->mb_height > 68 ||\n            (ctx->mb_height << frame->interlaced_frame) > (ctx->height + 15) >> 4) {\n            av_log(ctx->avctx, AV_LOG_ERROR,\n                   \"mb height too big: %d\\n\", ctx->mb_height);\n            return AVERROR_INVALIDDATA;\n        }\n        ctx->data_offset = 0x280;\n    }\n\n    if (buf_size < ctx->data_offset) {\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"buffer too small (%d < %d).\\n\", buf_size, ctx->data_offset);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (ctx->mb_height > FF_ARRAY_ELEMS(ctx->mb_scan_index)) {\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"mb_height too big (%d > %\"SIZE_SPECIFIER\").\\n\", ctx->mb_height, FF_ARRAY_ELEMS(ctx->mb_scan_index));\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (i = 0; i < ctx->mb_height; i++) {\n        ctx->mb_scan_index[i] = AV_RB32(buf + 0x170 + (i << 2));\n        ff_dlog(ctx->avctx, \"mb scan index %d, pos %d: %\"PRIu32\"\\n\",\n                i, 0x170 + (i << 2), ctx->mb_scan_index[i]);\n        if (buf_size - ctx->data_offset < ctx->mb_scan_index[i]) {\n            av_log(ctx->avctx, AV_LOG_ERROR,\n                   \"invalid mb scan index (%\"PRIu32\" vs %u).\\n\",\n                   ctx->mb_scan_index[i], buf_size - ctx->data_offset);\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    return 0;\n}\n\nstatic av_always_inline int dnxhd_decode_dct_block(const DNXHDContext *ctx,\n                                                   RowContext *row,\n                                                   int n,\n                                                   int index_bits,\n                                                   int level_bias,\n                                                   int level_shift,\n                                                   int dc_shift)\n{\n    int i, j, index1, index2, len, flags;\n    int level, component, sign;\n    const int *scale;\n    const uint8_t *weight_matrix;\n    const uint8_t *ac_info = ctx->cid_table->ac_info;\n    int16_t *block = row->blocks[n];\n    const int eob_index     = ctx->cid_table->eob_index;\n    int ret = 0;\n    OPEN_READER(bs, &row->gb);\n\n    ctx->bdsp.clear_block(block);\n\n    if (!ctx->is_444) {\n        if (n & 2) {\n            component     = 1 + (n & 1);\n            scale = row->chroma_scale;\n            weight_matrix = ctx->cid_table->chroma_weight;\n        } else {\n            component     = 0;\n            scale = row->luma_scale;\n            weight_matrix = ctx->cid_table->luma_weight;\n        }\n    } else {\n        component = (n >> 1) % 3;\n        if (component) {\n            scale = row->chroma_scale;\n            weight_matrix = ctx->cid_table->chroma_weight;\n        } else {\n            scale = row->luma_scale;\n            weight_matrix = ctx->cid_table->luma_weight;\n        }\n    }\n\n    UPDATE_CACHE(bs, &row->gb);\n    GET_VLC(len, bs, &row->gb, ctx->dc_vlc.table, DNXHD_DC_VLC_BITS, 1);\n    if (len) {\n        level = GET_CACHE(bs, &row->gb);\n        LAST_SKIP_BITS(bs, &row->gb, len);\n        sign  = ~level >> 31;\n        level = (NEG_USR32(sign ^ level, len) ^ sign) - sign;\n        row->last_dc[component] += level * (1 << dc_shift);\n    }\n    block[0] = row->last_dc[component];\n\n    i = 0;\n\n    UPDATE_CACHE(bs, &row->gb);\n    GET_VLC(index1, bs, &row->gb, ctx->ac_vlc.table,\n            DNXHD_VLC_BITS, 2);\n\n    while (index1 != eob_index) {\n        level = ac_info[2*index1+0];\n        flags = ac_info[2*index1+1];\n\n        sign = SHOW_SBITS(bs, &row->gb, 1);\n        SKIP_BITS(bs, &row->gb, 1);\n\n        if (flags & 1) {\n            level += SHOW_UBITS(bs, &row->gb, index_bits) << 7;\n            SKIP_BITS(bs, &row->gb, index_bits);\n        }\n\n        if (flags & 2) {\n            UPDATE_CACHE(bs, &row->gb);\n            GET_VLC(index2, bs, &row->gb, ctx->run_vlc.table,\n                    DNXHD_VLC_BITS, 2);\n            i += ctx->cid_table->run[index2];\n        }\n\n        if (++i > 63) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"ac tex damaged %d, %d\\n\", n, i);\n            ret = -1;\n            break;\n        }\n\n        j     = ctx->scantable.permutated[i];\n        level *= scale[i];\n        level += scale[i] >> 1;\n        if (level_bias < 32 || weight_matrix[i] != level_bias)\n            level += level_bias; // 1<<(level_shift-1)\n        level >>= level_shift;\n\n        block[j] = (level ^ sign) - sign;\n\n        UPDATE_CACHE(bs, &row->gb);\n        GET_VLC(index1, bs, &row->gb, ctx->ac_vlc.table,\n                DNXHD_VLC_BITS, 2);\n    }\n\n    CLOSE_READER(bs, &row->gb);\n    return ret;\n}\n\nstatic int dnxhd_decode_dct_block_8(const DNXHDContext *ctx,\n                                    RowContext *row, int n)\n{\n    return dnxhd_decode_dct_block(ctx, row, n, 4, 32, 6, 0);\n}\n\nstatic int dnxhd_decode_dct_block_10(const DNXHDContext *ctx,\n                                     RowContext *row, int n)\n{\n    return dnxhd_decode_dct_block(ctx, row, n, 6, 8, 4, 0);\n}\n\nstatic int dnxhd_decode_dct_block_10_444(const DNXHDContext *ctx,\n                                         RowContext *row, int n)\n{\n    return dnxhd_decode_dct_block(ctx, row, n, 6, 32, 6, 0);\n}\n\nstatic int dnxhd_decode_dct_block_12(const DNXHDContext *ctx,\n                                     RowContext *row, int n)\n{\n    return dnxhd_decode_dct_block(ctx, row, n, 6, 8, 4, 2);\n}\n\nstatic int dnxhd_decode_dct_block_12_444(const DNXHDContext *ctx,\n                                         RowContext *row, int n)\n{\n    return dnxhd_decode_dct_block(ctx, row, n, 6, 32, 4, 2);\n}\n\nstatic int dnxhd_decode_macroblock(const DNXHDContext *ctx, RowContext *row,\n                                   AVFrame *frame, int x, int y)\n{\n    int shift1 = ctx->bit_depth >= 10;\n    int dct_linesize_luma   = frame->linesize[0];\n    int dct_linesize_chroma = frame->linesize[1];\n    uint8_t *dest_y, *dest_u, *dest_v;\n    int dct_y_offset, dct_x_offset;\n    int qscale, i, act;\n    int interlaced_mb = 0;\n\n    if (ctx->mbaff) {\n        interlaced_mb = get_bits1(&row->gb);\n        qscale = get_bits(&row->gb, 10);\n    } else {\n        qscale = get_bits(&row->gb, 11);\n    }\n    act = get_bits1(&row->gb);\n    if (act) {\n        if (!ctx->act) {\n            static int act_warned;\n            if (!act_warned) {\n                act_warned = 1;\n                av_log(ctx->avctx, AV_LOG_ERROR,\n                       \"ACT flag set, in violation of frame header.\\n\");\n            }\n        } else if (row->format == -1) {\n            row->format = act;\n        } else if (row->format != act) {\n            row->format = 2; // Variable\n        }\n    }\n\n    if (qscale != row->last_qscale) {\n        for (i = 0; i < 64; i++) {\n            row->luma_scale[i]   = qscale * ctx->cid_table->luma_weight[i];\n            row->chroma_scale[i] = qscale * ctx->cid_table->chroma_weight[i];\n        }\n        row->last_qscale = qscale;\n    }\n\n    for (i = 0; i < 8 + 4 * ctx->is_444; i++) {\n        if (ctx->decode_dct_block(ctx, row, i) < 0)\n            return AVERROR_INVALIDDATA;\n    }\n\n    if (frame->interlaced_frame) {\n        dct_linesize_luma   <<= 1;\n        dct_linesize_chroma <<= 1;\n    }\n\n    dest_y = frame->data[0] + ((y * dct_linesize_luma)   << 4) + (x << (4 + shift1));\n    dest_u = frame->data[1] + ((y * dct_linesize_chroma) << 4) + (x << (3 + shift1 + ctx->is_444));\n    dest_v = frame->data[2] + ((y * dct_linesize_chroma) << 4) + (x << (3 + shift1 + ctx->is_444));\n\n    if (frame->interlaced_frame && ctx->cur_field) {\n        dest_y += frame->linesize[0];\n        dest_u += frame->linesize[1];\n        dest_v += frame->linesize[2];\n    }\n    if (interlaced_mb) {\n        dct_linesize_luma   <<= 1;\n        dct_linesize_chroma <<= 1;\n    }\n\n    dct_y_offset = interlaced_mb ? frame->linesize[0] : (dct_linesize_luma << 3);\n    dct_x_offset = 8 << shift1;\n    if (!ctx->is_444) {\n        ctx->idsp.idct_put(dest_y,                               dct_linesize_luma, row->blocks[0]);\n        ctx->idsp.idct_put(dest_y + dct_x_offset,                dct_linesize_luma, row->blocks[1]);\n        ctx->idsp.idct_put(dest_y + dct_y_offset,                dct_linesize_luma, row->blocks[4]);\n        ctx->idsp.idct_put(dest_y + dct_y_offset + dct_x_offset, dct_linesize_luma, row->blocks[5]);\n\n        if (!(ctx->avctx->flags & AV_CODEC_FLAG_GRAY)) {\n            dct_y_offset = interlaced_mb ? frame->linesize[1] : (dct_linesize_chroma << 3);\n            ctx->idsp.idct_put(dest_u,                dct_linesize_chroma, row->blocks[2]);\n            ctx->idsp.idct_put(dest_v,                dct_linesize_chroma, row->blocks[3]);\n            ctx->idsp.idct_put(dest_u + dct_y_offset, dct_linesize_chroma, row->blocks[6]);\n            ctx->idsp.idct_put(dest_v + dct_y_offset, dct_linesize_chroma, row->blocks[7]);\n        }\n    } else {\n        ctx->idsp.idct_put(dest_y,                               dct_linesize_luma, row->blocks[0]);\n        ctx->idsp.idct_put(dest_y + dct_x_offset,                dct_linesize_luma, row->blocks[1]);\n        ctx->idsp.idct_put(dest_y + dct_y_offset,                dct_linesize_luma, row->blocks[6]);\n        ctx->idsp.idct_put(dest_y + dct_y_offset + dct_x_offset, dct_linesize_luma, row->blocks[7]);\n\n        if (!(ctx->avctx->flags & AV_CODEC_FLAG_GRAY)) {\n            dct_y_offset = interlaced_mb ? frame->linesize[1] : (dct_linesize_chroma << 3);\n            ctx->idsp.idct_put(dest_u,                               dct_linesize_chroma, row->blocks[2]);\n            ctx->idsp.idct_put(dest_u + dct_x_offset,                dct_linesize_chroma, row->blocks[3]);\n            ctx->idsp.idct_put(dest_u + dct_y_offset,                dct_linesize_chroma, row->blocks[8]);\n            ctx->idsp.idct_put(dest_u + dct_y_offset + dct_x_offset, dct_linesize_chroma, row->blocks[9]);\n            ctx->idsp.idct_put(dest_v,                               dct_linesize_chroma, row->blocks[4]);\n            ctx->idsp.idct_put(dest_v + dct_x_offset,                dct_linesize_chroma, row->blocks[5]);\n            ctx->idsp.idct_put(dest_v + dct_y_offset,                dct_linesize_chroma, row->blocks[10]);\n            ctx->idsp.idct_put(dest_v + dct_y_offset + dct_x_offset, dct_linesize_chroma, row->blocks[11]);\n        }\n    }\n\n    return 0;\n}\n\nstatic int dnxhd_decode_row(AVCodecContext *avctx, void *data,\n                            int rownb, int threadnb)\n{\n    const DNXHDContext *ctx = avctx->priv_data;\n    uint32_t offset = ctx->mb_scan_index[rownb];\n    RowContext *row = ctx->rows + threadnb;\n    int x;\n\n    row->last_dc[0] =\n    row->last_dc[1] =\n    row->last_dc[2] = 1 << (ctx->bit_depth + 2); // for levels +2^(bitdepth-1)\n    init_get_bits(&row->gb, ctx->buf + offset, (ctx->buf_size - offset) << 3);\n    for (x = 0; x < ctx->mb_width; x++) {\n        //START_TIMER;\n        int ret = dnxhd_decode_macroblock(ctx, row, data, x, rownb);\n        if (ret < 0) {\n            row->errors++;\n            return ret;\n        }\n        //STOP_TIMER(\"decode macroblock\");\n    }\n\n    return 0;\n}\n\nstatic int dnxhd_decode_frame(AVCodecContext *avctx, void *data,\n                              int *got_frame, AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    DNXHDContext *ctx = avctx->priv_data;\n    ThreadFrame frame = { .f = data };\n    AVFrame *picture = data;\n    int first_field = 1;\n    int ret, i;\n\n    ff_dlog(avctx, \"frame size %d\\n\", buf_size);\n\n    for (i = 0; i < avctx->thread_count; i++)\n        ctx->rows[i].format = -1;\n\ndecode_coding_unit:\n    if ((ret = dnxhd_decode_header(ctx, picture, buf, buf_size, first_field)) < 0)\n        return ret;\n\n    if ((avctx->width || avctx->height) &&\n        (ctx->width != avctx->width || ctx->height != avctx->height)) {\n        av_log(avctx, AV_LOG_WARNING, \"frame size changed: %dx%d -> %ux%u\\n\",\n               avctx->width, avctx->height, ctx->width, ctx->height);\n        first_field = 1;\n    }\n    if (avctx->pix_fmt != AV_PIX_FMT_NONE && avctx->pix_fmt != ctx->pix_fmt) {\n        av_log(avctx, AV_LOG_WARNING, \"pix_fmt changed: %s -> %s\\n\",\n               av_get_pix_fmt_name(avctx->pix_fmt), av_get_pix_fmt_name(ctx->pix_fmt));\n        first_field = 1;\n    }\n\n    avctx->pix_fmt = ctx->pix_fmt;\n    ret = ff_set_dimensions(avctx, ctx->width, ctx->height);\n    if (ret < 0)\n        return ret;\n\n    if (first_field) {\n        if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)\n            return ret;\n        picture->pict_type = AV_PICTURE_TYPE_I;\n        picture->key_frame = 1;\n    }\n\n    ctx->buf_size = buf_size - ctx->data_offset;\n    ctx->buf = buf + ctx->data_offset;\n    avctx->execute2(avctx, dnxhd_decode_row, picture, NULL, ctx->mb_height);\n\n    if (first_field && picture->interlaced_frame) {\n        buf      += ctx->cid_table->coding_unit_size;\n        buf_size -= ctx->cid_table->coding_unit_size;\n        first_field = 0;\n        goto decode_coding_unit;\n    }\n\n    ret = 0;\n    for (i = 0; i < avctx->thread_count; i++) {\n        ret += ctx->rows[i].errors;\n        ctx->rows[i].errors = 0;\n    }\n\n    if (ctx->act) {\n        static int act_warned;\n        int format = ctx->rows[0].format;\n        for (i = 1; i < avctx->thread_count; i++) {\n            if (ctx->rows[i].format != format &&\n                ctx->rows[i].format != -1 /* not run */) {\n                format = 2;\n                break;\n            }\n        }\n        switch (format) {\n        case -1:\n        case 2:\n            if (!act_warned) {\n                act_warned = 1;\n                av_log(ctx->avctx, AV_LOG_ERROR,\n                       \"Unsupported: variable ACT flag.\\n\");\n            }\n            break;\n        case 0:\n            ctx->pix_fmt = ctx->bit_depth==10\n                         ? AV_PIX_FMT_GBRP10 : AV_PIX_FMT_GBRP12;\n            break;\n        case 1:\n            ctx->pix_fmt = ctx->bit_depth==10\n                         ? AV_PIX_FMT_YUV444P10 : AV_PIX_FMT_YUV444P12;\n            break;\n        }\n    }\n    avctx->pix_fmt = ctx->pix_fmt;\n    if (ret) {\n        av_log(ctx->avctx, AV_LOG_ERROR, \"%d lines with errors\\n\", ret);\n        return AVERROR_INVALIDDATA;\n    }\n\n    *got_frame = 1;\n    return avpkt->size;\n}\n\nstatic av_cold int dnxhd_decode_close(AVCodecContext *avctx)\n{\n    DNXHDContext *ctx = avctx->priv_data;\n\n    ff_free_vlc(&ctx->ac_vlc);\n    ff_free_vlc(&ctx->dc_vlc);\n    ff_free_vlc(&ctx->run_vlc);\n\n    av_freep(&ctx->rows);\n\n    return 0;\n}\n\nAVCodec ff_dnxhd_decoder = {\n    .name           = \"dnxhd\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"VC3/DNxHD\"),\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_DNXHD,\n    .priv_data_size = sizeof(DNXHDContext),\n    .init           = dnxhd_decode_init,\n    .close          = dnxhd_decode_close,\n    .decode         = dnxhd_decode_frame,\n    .capabilities   = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS |\n                      AV_CODEC_CAP_SLICE_THREADS,\n    .init_thread_copy = ONLY_IF_THREADS_ENABLED(dnxhd_decode_init_thread_copy),\n    .profiles       = NULL_IF_CONFIG_SMALL(ff_dnxhd_profiles),\n};\n"], "fixing_code": ["/*\n * VC3/DNxHD decoder.\n * Copyright (c) 2007 SmartJog S.A., Baptiste Coudurier <baptiste dot coudurier at smartjog dot com>\n * Copyright (c) 2011 MirriAd Ltd\n * Copyright (c) 2015 Christophe Gisquet\n *\n * 10 bit support added by MirriAd Ltd, Joseph Artsimovich <joseph@mirriad.com>\n * Slice multithreading and MB interlaced support added by Christophe Gisquet\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"libavutil/imgutils.h\"\n#include \"libavutil/timer.h\"\n#include \"avcodec.h\"\n#include \"blockdsp.h\"\n#define  UNCHECKED_BITSTREAM_READER 1\n#include \"get_bits.h\"\n#include \"dnxhddata.h\"\n#include \"idctdsp.h\"\n#include \"internal.h\"\n#include \"profiles.h\"\n#include \"thread.h\"\n\ntypedef struct RowContext {\n    DECLARE_ALIGNED(16, int16_t, blocks)[12][64];\n    int luma_scale[64];\n    int chroma_scale[64];\n    GetBitContext gb;\n    int last_dc[3];\n    int last_qscale;\n    int errors;\n    /** -1:not set yet  0:off=RGB  1:on=YUV  2:variable */\n    int format;\n} RowContext;\n\ntypedef struct DNXHDContext {\n    AVCodecContext *avctx;\n    RowContext *rows;\n    BlockDSPContext bdsp;\n    const uint8_t* buf;\n    int buf_size;\n    int64_t cid;                        ///< compression id\n    unsigned int width, height;\n    enum AVPixelFormat pix_fmt;\n    unsigned int mb_width, mb_height;\n    uint32_t mb_scan_index[512];\n    int data_offset;                    // End of mb_scan_index, where macroblocks start\n    int cur_field;                      ///< current interlaced field\n    VLC ac_vlc, dc_vlc, run_vlc;\n    IDCTDSPContext idsp;\n    ScanTable scantable;\n    const CIDEntry *cid_table;\n    int bit_depth; // 8, 10, 12 or 0 if not initialized at all.\n    int is_444;\n    int mbaff;\n    int act;\n    int (*decode_dct_block)(const struct DNXHDContext *ctx,\n                            RowContext *row, int n);\n} DNXHDContext;\n\n#define DNXHD_VLC_BITS 9\n#define DNXHD_DC_VLC_BITS 7\n\nstatic int dnxhd_decode_dct_block_8(const DNXHDContext *ctx,\n                                    RowContext *row, int n);\nstatic int dnxhd_decode_dct_block_10(const DNXHDContext *ctx,\n                                     RowContext *row, int n);\nstatic int dnxhd_decode_dct_block_10_444(const DNXHDContext *ctx,\n                                         RowContext *row, int n);\nstatic int dnxhd_decode_dct_block_12(const DNXHDContext *ctx,\n                                     RowContext *row, int n);\nstatic int dnxhd_decode_dct_block_12_444(const DNXHDContext *ctx,\n                                         RowContext *row, int n);\n\nstatic av_cold int dnxhd_decode_init(AVCodecContext *avctx)\n{\n    DNXHDContext *ctx = avctx->priv_data;\n\n    ctx->avctx = avctx;\n    ctx->cid = -1;\n    avctx->colorspace = AVCOL_SPC_BT709;\n\n    avctx->coded_width  = FFALIGN(avctx->width,  16);\n    avctx->coded_height = FFALIGN(avctx->height, 16);\n\n    ctx->rows = av_mallocz_array(avctx->thread_count, sizeof(RowContext));\n    if (!ctx->rows)\n        return AVERROR(ENOMEM);\n\n    return 0;\n}\n\nstatic int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid, int bitdepth)\n{\n    if (cid != ctx->cid) {\n        int index;\n\n        if ((index = ff_dnxhd_get_cid_table(cid)) < 0) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"unsupported cid %\"PRIu32\"\\n\", cid);\n            return AVERROR(ENOSYS);\n        }\n        if (ff_dnxhd_cid_table[index].bit_depth != bitdepth &&\n            ff_dnxhd_cid_table[index].bit_depth != DNXHD_VARIABLE) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"bit depth mismatches %d %d\\n\", ff_dnxhd_cid_table[index].bit_depth, bitdepth);\n            return AVERROR_INVALIDDATA;\n        }\n        ctx->cid_table = &ff_dnxhd_cid_table[index];\n        av_log(ctx->avctx, AV_LOG_VERBOSE, \"Profile cid %\"PRIu32\".\\n\", cid);\n\n        ff_free_vlc(&ctx->ac_vlc);\n        ff_free_vlc(&ctx->dc_vlc);\n        ff_free_vlc(&ctx->run_vlc);\n\n        init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,\n                 ctx->cid_table->ac_bits, 1, 1,\n                 ctx->cid_table->ac_codes, 2, 2, 0);\n        init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, bitdepth > 8 ? 14 : 12,\n                 ctx->cid_table->dc_bits, 1, 1,\n                 ctx->cid_table->dc_codes, 1, 1, 0);\n        init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,\n                 ctx->cid_table->run_bits, 1, 1,\n                 ctx->cid_table->run_codes, 2, 2, 0);\n\n        ctx->cid = cid;\n    }\n    return 0;\n}\n\nstatic av_cold int dnxhd_decode_init_thread_copy(AVCodecContext *avctx)\n{\n    DNXHDContext *ctx = avctx->priv_data;\n\n    ctx->avctx = avctx;\n    // make sure VLC tables will be loaded when cid is parsed\n    ctx->cid = -1;\n\n    ctx->rows = av_mallocz_array(avctx->thread_count, sizeof(RowContext));\n    if (!ctx->rows)\n        return AVERROR(ENOMEM);\n\n    return 0;\n}\n\nstatic int dnxhd_get_profile(int cid)\n{\n    switch(cid) {\n    case 1270:\n        return FF_PROFILE_DNXHR_444;\n    case 1271:\n        return FF_PROFILE_DNXHR_HQX;\n    case 1272:\n        return FF_PROFILE_DNXHR_HQ;\n    case 1273:\n        return FF_PROFILE_DNXHR_SQ;\n    case 1274:\n        return FF_PROFILE_DNXHR_LB;\n    }\n    return FF_PROFILE_DNXHD;\n}\n\nstatic int dnxhd_decode_header(DNXHDContext *ctx, AVFrame *frame,\n                               const uint8_t *buf, int buf_size,\n                               int first_field)\n{\n    int i, cid, ret;\n    int old_bit_depth = ctx->bit_depth, bitdepth;\n    uint64_t header_prefix;\n    if (buf_size < 0x280) {\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"buffer too small (%d < 640).\\n\", buf_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    header_prefix = ff_dnxhd_parse_header_prefix(buf);\n    if (header_prefix == 0) {\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"unknown header 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\n               buf[0], buf[1], buf[2], buf[3], buf[4]);\n        return AVERROR_INVALIDDATA;\n    }\n    if (buf[5] & 2) { /* interlaced */\n        ctx->cur_field = buf[5] & 1;\n        frame->interlaced_frame = 1;\n        frame->top_field_first  = first_field ^ ctx->cur_field;\n        av_log(ctx->avctx, AV_LOG_DEBUG,\n               \"interlaced %d, cur field %d\\n\", buf[5] & 3, ctx->cur_field);\n    } else {\n        ctx->cur_field = 0;\n    }\n    ctx->mbaff = (buf[0x6] >> 5) & 1;\n\n    ctx->height = AV_RB16(buf + 0x18);\n    ctx->width  = AV_RB16(buf + 0x1a);\n\n    switch(buf[0x21] >> 5) {\n    case 1: bitdepth = 8; break;\n    case 2: bitdepth = 10; break;\n    case 3: bitdepth = 12; break;\n    default:\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"Unknown bitdepth indicator (%d)\\n\", buf[0x21] >> 5);\n        return AVERROR_INVALIDDATA;\n    }\n\n    cid = AV_RB32(buf + 0x28);\n\n    ctx->avctx->profile = dnxhd_get_profile(cid);\n\n    if ((ret = dnxhd_init_vlc(ctx, cid, bitdepth)) < 0)\n        return ret;\n    if (ctx->mbaff && ctx->cid_table->cid != 1260)\n        av_log(ctx->avctx, AV_LOG_WARNING,\n               \"Adaptive MB interlace flag in an unsupported profile.\\n\");\n\n    ctx->act = buf[0x2C] & 7;\n    if (ctx->act && ctx->cid_table->cid != 1256 && ctx->cid_table->cid != 1270)\n        av_log(ctx->avctx, AV_LOG_WARNING,\n               \"Adaptive color transform in an unsupported profile.\\n\");\n\n    ctx->is_444 = (buf[0x2C] >> 6) & 1;\n    if (ctx->is_444) {\n        if (bitdepth == 8) {\n            avpriv_request_sample(ctx->avctx, \"4:4:4 8 bits\");\n            return AVERROR_INVALIDDATA;\n        } else if (bitdepth == 10) {\n            ctx->decode_dct_block = dnxhd_decode_dct_block_10_444;\n            ctx->pix_fmt = ctx->act ? AV_PIX_FMT_YUV444P10\n                                    : AV_PIX_FMT_GBRP10;\n        } else {\n            ctx->decode_dct_block = dnxhd_decode_dct_block_12_444;\n            ctx->pix_fmt = ctx->act ? AV_PIX_FMT_YUV444P12\n                                    : AV_PIX_FMT_GBRP12;\n        }\n    } else if (bitdepth == 12) {\n        ctx->decode_dct_block = dnxhd_decode_dct_block_12;\n        ctx->pix_fmt = AV_PIX_FMT_YUV422P12;\n    } else if (bitdepth == 10) {\n        if (ctx->avctx->profile == FF_PROFILE_DNXHR_HQX)\n            ctx->decode_dct_block = dnxhd_decode_dct_block_10_444;\n        else\n            ctx->decode_dct_block = dnxhd_decode_dct_block_10;\n        ctx->pix_fmt = AV_PIX_FMT_YUV422P10;\n    } else {\n        ctx->decode_dct_block = dnxhd_decode_dct_block_8;\n        ctx->pix_fmt = AV_PIX_FMT_YUV422P;\n    }\n\n    ctx->avctx->bits_per_raw_sample = ctx->bit_depth = bitdepth;\n    if (ctx->bit_depth != old_bit_depth) {\n        ff_blockdsp_init(&ctx->bdsp, ctx->avctx);\n        ff_idctdsp_init(&ctx->idsp, ctx->avctx);\n        ff_init_scantable(ctx->idsp.idct_permutation, &ctx->scantable,\n                          ff_zigzag_direct);\n    }\n\n    // make sure profile size constraints are respected\n    // DNx100 allows 1920->1440 and 1280->960 subsampling\n    if (ctx->width != ctx->cid_table->width &&\n        ctx->cid_table->width != DNXHD_VARIABLE) {\n        av_reduce(&ctx->avctx->sample_aspect_ratio.num,\n                  &ctx->avctx->sample_aspect_ratio.den,\n                  ctx->width, ctx->cid_table->width, 255);\n        ctx->width = ctx->cid_table->width;\n    }\n\n    if (buf_size < ctx->cid_table->coding_unit_size) {\n        av_log(ctx->avctx, AV_LOG_ERROR, \"incorrect frame size (%d < %u).\\n\",\n               buf_size, ctx->cid_table->coding_unit_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    ctx->mb_width  = (ctx->width + 15)>> 4;\n    ctx->mb_height = AV_RB16(buf + 0x16c);\n\n    if ((ctx->height + 15) >> 4 == ctx->mb_height && frame->interlaced_frame)\n        ctx->height <<= 1;\n\n    av_log(ctx->avctx, AV_LOG_VERBOSE, \"%dx%d, 4:%s %d bits, MBAFF=%d ACT=%d\\n\",\n           ctx->width, ctx->height, ctx->is_444 ? \"4:4\" : \"2:2\",\n           ctx->bit_depth, ctx->mbaff, ctx->act);\n\n    // Newer format supports variable mb_scan_index sizes\n    if (ctx->mb_height > 68 && ff_dnxhd_check_header_prefix_hr(header_prefix)) {\n        ctx->data_offset = 0x170 + (ctx->mb_height << 2);\n    } else {\n        if (ctx->mb_height > 68) {\n            av_log(ctx->avctx, AV_LOG_ERROR,\n                   \"mb height too big: %d\\n\", ctx->mb_height);\n            return AVERROR_INVALIDDATA;\n        }\n        ctx->data_offset = 0x280;\n    }\n    if ((ctx->mb_height << frame->interlaced_frame) > (ctx->height + 15) >> 4) {\n        av_log(ctx->avctx, AV_LOG_ERROR,\n                \"mb height too big: %d\\n\", ctx->mb_height);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (buf_size < ctx->data_offset) {\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"buffer too small (%d < %d).\\n\", buf_size, ctx->data_offset);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (ctx->mb_height > FF_ARRAY_ELEMS(ctx->mb_scan_index)) {\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"mb_height too big (%d > %\"SIZE_SPECIFIER\").\\n\", ctx->mb_height, FF_ARRAY_ELEMS(ctx->mb_scan_index));\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (i = 0; i < ctx->mb_height; i++) {\n        ctx->mb_scan_index[i] = AV_RB32(buf + 0x170 + (i << 2));\n        ff_dlog(ctx->avctx, \"mb scan index %d, pos %d: %\"PRIu32\"\\n\",\n                i, 0x170 + (i << 2), ctx->mb_scan_index[i]);\n        if (buf_size - ctx->data_offset < ctx->mb_scan_index[i]) {\n            av_log(ctx->avctx, AV_LOG_ERROR,\n                   \"invalid mb scan index (%\"PRIu32\" vs %u).\\n\",\n                   ctx->mb_scan_index[i], buf_size - ctx->data_offset);\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    return 0;\n}\n\nstatic av_always_inline int dnxhd_decode_dct_block(const DNXHDContext *ctx,\n                                                   RowContext *row,\n                                                   int n,\n                                                   int index_bits,\n                                                   int level_bias,\n                                                   int level_shift,\n                                                   int dc_shift)\n{\n    int i, j, index1, index2, len, flags;\n    int level, component, sign;\n    const int *scale;\n    const uint8_t *weight_matrix;\n    const uint8_t *ac_info = ctx->cid_table->ac_info;\n    int16_t *block = row->blocks[n];\n    const int eob_index     = ctx->cid_table->eob_index;\n    int ret = 0;\n    OPEN_READER(bs, &row->gb);\n\n    ctx->bdsp.clear_block(block);\n\n    if (!ctx->is_444) {\n        if (n & 2) {\n            component     = 1 + (n & 1);\n            scale = row->chroma_scale;\n            weight_matrix = ctx->cid_table->chroma_weight;\n        } else {\n            component     = 0;\n            scale = row->luma_scale;\n            weight_matrix = ctx->cid_table->luma_weight;\n        }\n    } else {\n        component = (n >> 1) % 3;\n        if (component) {\n            scale = row->chroma_scale;\n            weight_matrix = ctx->cid_table->chroma_weight;\n        } else {\n            scale = row->luma_scale;\n            weight_matrix = ctx->cid_table->luma_weight;\n        }\n    }\n\n    UPDATE_CACHE(bs, &row->gb);\n    GET_VLC(len, bs, &row->gb, ctx->dc_vlc.table, DNXHD_DC_VLC_BITS, 1);\n    if (len) {\n        level = GET_CACHE(bs, &row->gb);\n        LAST_SKIP_BITS(bs, &row->gb, len);\n        sign  = ~level >> 31;\n        level = (NEG_USR32(sign ^ level, len) ^ sign) - sign;\n        row->last_dc[component] += level * (1 << dc_shift);\n    }\n    block[0] = row->last_dc[component];\n\n    i = 0;\n\n    UPDATE_CACHE(bs, &row->gb);\n    GET_VLC(index1, bs, &row->gb, ctx->ac_vlc.table,\n            DNXHD_VLC_BITS, 2);\n\n    while (index1 != eob_index) {\n        level = ac_info[2*index1+0];\n        flags = ac_info[2*index1+1];\n\n        sign = SHOW_SBITS(bs, &row->gb, 1);\n        SKIP_BITS(bs, &row->gb, 1);\n\n        if (flags & 1) {\n            level += SHOW_UBITS(bs, &row->gb, index_bits) << 7;\n            SKIP_BITS(bs, &row->gb, index_bits);\n        }\n\n        if (flags & 2) {\n            UPDATE_CACHE(bs, &row->gb);\n            GET_VLC(index2, bs, &row->gb, ctx->run_vlc.table,\n                    DNXHD_VLC_BITS, 2);\n            i += ctx->cid_table->run[index2];\n        }\n\n        if (++i > 63) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"ac tex damaged %d, %d\\n\", n, i);\n            ret = -1;\n            break;\n        }\n\n        j     = ctx->scantable.permutated[i];\n        level *= scale[i];\n        level += scale[i] >> 1;\n        if (level_bias < 32 || weight_matrix[i] != level_bias)\n            level += level_bias; // 1<<(level_shift-1)\n        level >>= level_shift;\n\n        block[j] = (level ^ sign) - sign;\n\n        UPDATE_CACHE(bs, &row->gb);\n        GET_VLC(index1, bs, &row->gb, ctx->ac_vlc.table,\n                DNXHD_VLC_BITS, 2);\n    }\n\n    CLOSE_READER(bs, &row->gb);\n    return ret;\n}\n\nstatic int dnxhd_decode_dct_block_8(const DNXHDContext *ctx,\n                                    RowContext *row, int n)\n{\n    return dnxhd_decode_dct_block(ctx, row, n, 4, 32, 6, 0);\n}\n\nstatic int dnxhd_decode_dct_block_10(const DNXHDContext *ctx,\n                                     RowContext *row, int n)\n{\n    return dnxhd_decode_dct_block(ctx, row, n, 6, 8, 4, 0);\n}\n\nstatic int dnxhd_decode_dct_block_10_444(const DNXHDContext *ctx,\n                                         RowContext *row, int n)\n{\n    return dnxhd_decode_dct_block(ctx, row, n, 6, 32, 6, 0);\n}\n\nstatic int dnxhd_decode_dct_block_12(const DNXHDContext *ctx,\n                                     RowContext *row, int n)\n{\n    return dnxhd_decode_dct_block(ctx, row, n, 6, 8, 4, 2);\n}\n\nstatic int dnxhd_decode_dct_block_12_444(const DNXHDContext *ctx,\n                                         RowContext *row, int n)\n{\n    return dnxhd_decode_dct_block(ctx, row, n, 6, 32, 4, 2);\n}\n\nstatic int dnxhd_decode_macroblock(const DNXHDContext *ctx, RowContext *row,\n                                   AVFrame *frame, int x, int y)\n{\n    int shift1 = ctx->bit_depth >= 10;\n    int dct_linesize_luma   = frame->linesize[0];\n    int dct_linesize_chroma = frame->linesize[1];\n    uint8_t *dest_y, *dest_u, *dest_v;\n    int dct_y_offset, dct_x_offset;\n    int qscale, i, act;\n    int interlaced_mb = 0;\n\n    if (ctx->mbaff) {\n        interlaced_mb = get_bits1(&row->gb);\n        qscale = get_bits(&row->gb, 10);\n    } else {\n        qscale = get_bits(&row->gb, 11);\n    }\n    act = get_bits1(&row->gb);\n    if (act) {\n        if (!ctx->act) {\n            static int act_warned;\n            if (!act_warned) {\n                act_warned = 1;\n                av_log(ctx->avctx, AV_LOG_ERROR,\n                       \"ACT flag set, in violation of frame header.\\n\");\n            }\n        } else if (row->format == -1) {\n            row->format = act;\n        } else if (row->format != act) {\n            row->format = 2; // Variable\n        }\n    }\n\n    if (qscale != row->last_qscale) {\n        for (i = 0; i < 64; i++) {\n            row->luma_scale[i]   = qscale * ctx->cid_table->luma_weight[i];\n            row->chroma_scale[i] = qscale * ctx->cid_table->chroma_weight[i];\n        }\n        row->last_qscale = qscale;\n    }\n\n    for (i = 0; i < 8 + 4 * ctx->is_444; i++) {\n        if (ctx->decode_dct_block(ctx, row, i) < 0)\n            return AVERROR_INVALIDDATA;\n    }\n\n    if (frame->interlaced_frame) {\n        dct_linesize_luma   <<= 1;\n        dct_linesize_chroma <<= 1;\n    }\n\n    dest_y = frame->data[0] + ((y * dct_linesize_luma)   << 4) + (x << (4 + shift1));\n    dest_u = frame->data[1] + ((y * dct_linesize_chroma) << 4) + (x << (3 + shift1 + ctx->is_444));\n    dest_v = frame->data[2] + ((y * dct_linesize_chroma) << 4) + (x << (3 + shift1 + ctx->is_444));\n\n    if (frame->interlaced_frame && ctx->cur_field) {\n        dest_y += frame->linesize[0];\n        dest_u += frame->linesize[1];\n        dest_v += frame->linesize[2];\n    }\n    if (interlaced_mb) {\n        dct_linesize_luma   <<= 1;\n        dct_linesize_chroma <<= 1;\n    }\n\n    dct_y_offset = interlaced_mb ? frame->linesize[0] : (dct_linesize_luma << 3);\n    dct_x_offset = 8 << shift1;\n    if (!ctx->is_444) {\n        ctx->idsp.idct_put(dest_y,                               dct_linesize_luma, row->blocks[0]);\n        ctx->idsp.idct_put(dest_y + dct_x_offset,                dct_linesize_luma, row->blocks[1]);\n        ctx->idsp.idct_put(dest_y + dct_y_offset,                dct_linesize_luma, row->blocks[4]);\n        ctx->idsp.idct_put(dest_y + dct_y_offset + dct_x_offset, dct_linesize_luma, row->blocks[5]);\n\n        if (!(ctx->avctx->flags & AV_CODEC_FLAG_GRAY)) {\n            dct_y_offset = interlaced_mb ? frame->linesize[1] : (dct_linesize_chroma << 3);\n            ctx->idsp.idct_put(dest_u,                dct_linesize_chroma, row->blocks[2]);\n            ctx->idsp.idct_put(dest_v,                dct_linesize_chroma, row->blocks[3]);\n            ctx->idsp.idct_put(dest_u + dct_y_offset, dct_linesize_chroma, row->blocks[6]);\n            ctx->idsp.idct_put(dest_v + dct_y_offset, dct_linesize_chroma, row->blocks[7]);\n        }\n    } else {\n        ctx->idsp.idct_put(dest_y,                               dct_linesize_luma, row->blocks[0]);\n        ctx->idsp.idct_put(dest_y + dct_x_offset,                dct_linesize_luma, row->blocks[1]);\n        ctx->idsp.idct_put(dest_y + dct_y_offset,                dct_linesize_luma, row->blocks[6]);\n        ctx->idsp.idct_put(dest_y + dct_y_offset + dct_x_offset, dct_linesize_luma, row->blocks[7]);\n\n        if (!(ctx->avctx->flags & AV_CODEC_FLAG_GRAY)) {\n            dct_y_offset = interlaced_mb ? frame->linesize[1] : (dct_linesize_chroma << 3);\n            ctx->idsp.idct_put(dest_u,                               dct_linesize_chroma, row->blocks[2]);\n            ctx->idsp.idct_put(dest_u + dct_x_offset,                dct_linesize_chroma, row->blocks[3]);\n            ctx->idsp.idct_put(dest_u + dct_y_offset,                dct_linesize_chroma, row->blocks[8]);\n            ctx->idsp.idct_put(dest_u + dct_y_offset + dct_x_offset, dct_linesize_chroma, row->blocks[9]);\n            ctx->idsp.idct_put(dest_v,                               dct_linesize_chroma, row->blocks[4]);\n            ctx->idsp.idct_put(dest_v + dct_x_offset,                dct_linesize_chroma, row->blocks[5]);\n            ctx->idsp.idct_put(dest_v + dct_y_offset,                dct_linesize_chroma, row->blocks[10]);\n            ctx->idsp.idct_put(dest_v + dct_y_offset + dct_x_offset, dct_linesize_chroma, row->blocks[11]);\n        }\n    }\n\n    return 0;\n}\n\nstatic int dnxhd_decode_row(AVCodecContext *avctx, void *data,\n                            int rownb, int threadnb)\n{\n    const DNXHDContext *ctx = avctx->priv_data;\n    uint32_t offset = ctx->mb_scan_index[rownb];\n    RowContext *row = ctx->rows + threadnb;\n    int x;\n\n    row->last_dc[0] =\n    row->last_dc[1] =\n    row->last_dc[2] = 1 << (ctx->bit_depth + 2); // for levels +2^(bitdepth-1)\n    init_get_bits(&row->gb, ctx->buf + offset, (ctx->buf_size - offset) << 3);\n    for (x = 0; x < ctx->mb_width; x++) {\n        //START_TIMER;\n        int ret = dnxhd_decode_macroblock(ctx, row, data, x, rownb);\n        if (ret < 0) {\n            row->errors++;\n            return ret;\n        }\n        //STOP_TIMER(\"decode macroblock\");\n    }\n\n    return 0;\n}\n\nstatic int dnxhd_decode_frame(AVCodecContext *avctx, void *data,\n                              int *got_frame, AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    DNXHDContext *ctx = avctx->priv_data;\n    ThreadFrame frame = { .f = data };\n    AVFrame *picture = data;\n    int first_field = 1;\n    int ret, i;\n\n    ff_dlog(avctx, \"frame size %d\\n\", buf_size);\n\n    for (i = 0; i < avctx->thread_count; i++)\n        ctx->rows[i].format = -1;\n\ndecode_coding_unit:\n    if ((ret = dnxhd_decode_header(ctx, picture, buf, buf_size, first_field)) < 0)\n        return ret;\n\n    if ((avctx->width || avctx->height) &&\n        (ctx->width != avctx->width || ctx->height != avctx->height)) {\n        av_log(avctx, AV_LOG_WARNING, \"frame size changed: %dx%d -> %ux%u\\n\",\n               avctx->width, avctx->height, ctx->width, ctx->height);\n        first_field = 1;\n    }\n    if (avctx->pix_fmt != AV_PIX_FMT_NONE && avctx->pix_fmt != ctx->pix_fmt) {\n        av_log(avctx, AV_LOG_WARNING, \"pix_fmt changed: %s -> %s\\n\",\n               av_get_pix_fmt_name(avctx->pix_fmt), av_get_pix_fmt_name(ctx->pix_fmt));\n        first_field = 1;\n    }\n\n    avctx->pix_fmt = ctx->pix_fmt;\n    ret = ff_set_dimensions(avctx, ctx->width, ctx->height);\n    if (ret < 0)\n        return ret;\n\n    if (first_field) {\n        if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)\n            return ret;\n        picture->pict_type = AV_PICTURE_TYPE_I;\n        picture->key_frame = 1;\n    }\n\n    ctx->buf_size = buf_size - ctx->data_offset;\n    ctx->buf = buf + ctx->data_offset;\n    avctx->execute2(avctx, dnxhd_decode_row, picture, NULL, ctx->mb_height);\n\n    if (first_field && picture->interlaced_frame) {\n        buf      += ctx->cid_table->coding_unit_size;\n        buf_size -= ctx->cid_table->coding_unit_size;\n        first_field = 0;\n        goto decode_coding_unit;\n    }\n\n    ret = 0;\n    for (i = 0; i < avctx->thread_count; i++) {\n        ret += ctx->rows[i].errors;\n        ctx->rows[i].errors = 0;\n    }\n\n    if (ctx->act) {\n        static int act_warned;\n        int format = ctx->rows[0].format;\n        for (i = 1; i < avctx->thread_count; i++) {\n            if (ctx->rows[i].format != format &&\n                ctx->rows[i].format != -1 /* not run */) {\n                format = 2;\n                break;\n            }\n        }\n        switch (format) {\n        case -1:\n        case 2:\n            if (!act_warned) {\n                act_warned = 1;\n                av_log(ctx->avctx, AV_LOG_ERROR,\n                       \"Unsupported: variable ACT flag.\\n\");\n            }\n            break;\n        case 0:\n            ctx->pix_fmt = ctx->bit_depth==10\n                         ? AV_PIX_FMT_GBRP10 : AV_PIX_FMT_GBRP12;\n            break;\n        case 1:\n            ctx->pix_fmt = ctx->bit_depth==10\n                         ? AV_PIX_FMT_YUV444P10 : AV_PIX_FMT_YUV444P12;\n            break;\n        }\n    }\n    avctx->pix_fmt = ctx->pix_fmt;\n    if (ret) {\n        av_log(ctx->avctx, AV_LOG_ERROR, \"%d lines with errors\\n\", ret);\n        return AVERROR_INVALIDDATA;\n    }\n\n    *got_frame = 1;\n    return avpkt->size;\n}\n\nstatic av_cold int dnxhd_decode_close(AVCodecContext *avctx)\n{\n    DNXHDContext *ctx = avctx->priv_data;\n\n    ff_free_vlc(&ctx->ac_vlc);\n    ff_free_vlc(&ctx->dc_vlc);\n    ff_free_vlc(&ctx->run_vlc);\n\n    av_freep(&ctx->rows);\n\n    return 0;\n}\n\nAVCodec ff_dnxhd_decoder = {\n    .name           = \"dnxhd\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"VC3/DNxHD\"),\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_DNXHD,\n    .priv_data_size = sizeof(DNXHDContext),\n    .init           = dnxhd_decode_init,\n    .close          = dnxhd_decode_close,\n    .decode         = dnxhd_decode_frame,\n    .capabilities   = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS |\n                      AV_CODEC_CAP_SLICE_THREADS,\n    .init_thread_copy = ONLY_IF_THREADS_ENABLED(dnxhd_decode_init_thread_copy),\n    .profiles       = NULL_IF_CONFIG_SMALL(ff_dnxhd_profiles),\n};\n"], "filenames": ["libavcodec/dnxhddec.c"], "buggy_code_start_loc": [301], "buggy_code_end_loc": [307], "fixing_code_start_loc": [301], "fixing_code_end_loc": [312], "type": "CWE-125", "message": "The dnxhd_decode_header function in libavcodec/dnxhddec.c in FFmpeg 3.0 through 3.3.2 allows remote attackers to cause a denial of service (out-of-array access) or possibly have unspecified other impact via a crafted DNxHD file.", "other": {"cve": {"id": "CVE-2017-11719", "sourceIdentifier": "cve@mitre.org", "published": "2017-07-28T05:29:00.980", "lastModified": "2021-01-04T22:15:12.420", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The dnxhd_decode_header function in libavcodec/dnxhddec.c in FFmpeg 3.0 through 3.3.2 allows remote attackers to cause a denial of service (out-of-array access) or possibly have unspecified other impact via a crafted DNxHD file."}, {"lang": "es", "value": "La funci\u00f3n dnxhd_decode_header en el archivo libavcodec/dnxhddec.c en FFmpeg versi\u00f3n 3.0 hasta la versi\u00f3n 3.3.2, permite a los atacantes remotos causar una denegaci\u00f3n de servicio (acceso fuera de la matriz) o posiblemente tener otro impacto no especificado por medio de un archivo DNxHD creado"}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.3.2", "matchCriteriaId": "7950917A-647C-431B-A872-67E914C135A5"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3957", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/100020", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/296debd213bd6dce7647cedd34eb64e5b94cdc92", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/f31fc4755f69ab26bf6e8be47875b7dcede8e29e", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/296debd213bd6dce7647cedd34eb64e5b94cdc92"}}