{"buggy_code": ["/* $Id: form.c,v 1.35 2010/07/18 13:48:48 htrb Exp $ */\n/* \n * HTML forms\n */\n#include \"fm.h\"\n#include \"parsetag.h\"\n#include \"parsetagx.h\"\n#include \"myctype.h\"\n#include \"local.h\"\n#include \"regex.h\"\n\nextern Str *textarea_str;\nextern int max_textarea;\n#ifdef MENU_SELECT\nextern FormSelectOption *select_option;\nextern int max_select;\n#include \"menu.h\"\n#endif\t\t\t\t/* MENU_SELECT */\n\n/* *INDENT-OFF* */\nstruct {\n    char *action;\n    void (*rout)(struct parsed_tagarg *);\n} internal_action[] = {\n    {\"map\", follow_map}, \n    {\"option\", panel_set_option},\n#ifdef USE_COOKIE\n    {\"cookie\", set_cookie_flag},\n#endif\t\t\t\t/* USE_COOKIE */\n    {\"download\", download_action},\n#ifdef USE_M17N\n    { \"charset\", change_charset },\n#endif\n    {\"none\", NULL},\n    {NULL, NULL},\n};\n/* *INDENT-ON* */\n\nstruct form_list *\nnewFormList(char *action, char *method, char *charset, char *enctype,\n\t    char *target, char *name, struct form_list *_next)\n{\n    struct form_list *l;\n    Str a = Strnew_charp(action);\n    int m = FORM_METHOD_GET;\n    int e = FORM_ENCTYPE_URLENCODED;\n#ifdef USE_M17N\n    wc_ces c = 0;\n#endif\n\n    if (method == NULL || !strcasecmp(method, \"get\"))\n\tm = FORM_METHOD_GET;\n    else if (!strcasecmp(method, \"post\"))\n\tm = FORM_METHOD_POST;\n    else if (!strcasecmp(method, \"internal\"))\n\tm = FORM_METHOD_INTERNAL;\n    /* unknown method is regarded as 'get' */\n\n    if (m != FORM_METHOD_GET && enctype != NULL &&\n\t!strcasecmp(enctype, \"multipart/form-data\")) {\n\te = FORM_ENCTYPE_MULTIPART;\n    }\n\n#ifdef USE_M17N\n    if (charset != NULL)\n\tc = wc_guess_charset(charset, 0);\n#endif\n\n    l = New(struct form_list);\n    l->item = l->lastitem = NULL;\n    l->action = a;\n    l->method = m;\n#ifdef USE_M17N\n    l->charset = c;\n#endif\n    l->enctype = e;\n    l->target = target;\n    l->name = name;\n    l->next = _next;\n    l->nitems = 0;\n    l->body = NULL;\n    l->length = 0;\n    return l;\n}\n\n/* \n * add <input> element to form_list\n */\nstruct form_item_list *\nformList_addInput(struct form_list *fl, struct parsed_tag *tag)\n{\n    struct form_item_list *item;\n    char *p;\n    int i;\n\n    /* if not in <form>..</form> environment, just ignore <input> tag */\n    if (fl == NULL)\n\treturn NULL;\n\n    item = New(struct form_item_list);\n    item->type = FORM_UNKNOWN;\n    item->size = -1;\n    item->rows = 0;\n    item->checked = item->init_checked = 0;\n    item->accept = 0;\n    item->name = NULL;\n    item->value = item->init_value = NULL;\n    item->readonly = 0;\n    if (parsedtag_get_value(tag, ATTR_TYPE, &p)) {\n\titem->type = formtype(p);\n\tif (item->size < 0 &&\n\t    (item->type == FORM_INPUT_TEXT ||\n\t     item->type == FORM_INPUT_FILE ||\n\t     item->type == FORM_INPUT_PASSWORD))\n\t    item->size = FORM_I_TEXT_DEFAULT_SIZE;\n    }\n    if (parsedtag_get_value(tag, ATTR_NAME, &p))\n\titem->name = Strnew_charp(p);\n    if (parsedtag_get_value(tag, ATTR_VALUE, &p))\n\titem->value = item->init_value = Strnew_charp(p);\n    item->checked = item->init_checked = parsedtag_exists(tag, ATTR_CHECKED);\n    item->accept = parsedtag_exists(tag, ATTR_ACCEPT);\n    parsedtag_get_value(tag, ATTR_SIZE, &item->size);\n    parsedtag_get_value(tag, ATTR_MAXLENGTH, &item->maxlength);\n    item->readonly = parsedtag_exists(tag, ATTR_READONLY);\n    if (parsedtag_get_value(tag, ATTR_TEXTAREANUMBER, &i)\n\t&& i >= 0 && i < max_textarea)\n\titem->value = item->init_value = textarea_str[i];\n#ifdef MENU_SELECT\n    if (parsedtag_get_value(tag, ATTR_SELECTNUMBER, &i)\n\t&& i >= 0 && i < max_select)\n\titem->select_option = select_option[i].first;\n#endif\t\t\t\t/* MENU_SELECT */\n    if (parsedtag_get_value(tag, ATTR_ROWS, &p))\n\titem->rows = atoi(p);\n    if (item->type == FORM_UNKNOWN) {\n\t/* type attribute is missing. Ignore the tag. */\n\treturn NULL;\n    }\n#ifdef MENU_SELECT\n    if (item->type == FORM_SELECT) {\n\tchooseSelectOption(item, item->select_option);\n\titem->init_selected = item->selected;\n\titem->init_value = item->value;\n\titem->init_label = item->label;\n    }\n#endif\t\t\t\t/* MENU_SELECT */\n    if (item->type == FORM_INPUT_FILE && item->value && item->value->length) {\n\t/* security hole ! */\n\treturn NULL;\n    }\n    item->parent = fl;\n    item->next = NULL;\n    if (fl->item == NULL) {\n\tfl->item = fl->lastitem = item;\n    }\n    else {\n\tfl->lastitem->next = item;\n\tfl->lastitem = item;\n    }\n    if (item->type == FORM_INPUT_HIDDEN)\n\treturn NULL;\n    fl->nitems++;\n    return item;\n}\n\nstatic char *_formtypetbl[] = {\n    \"text\", \"password\", \"checkbox\", \"radio\", \"submit\", \"reset\", \"hidden\",\n    \"image\", \"select\", \"textarea\", \"button\", \"file\", NULL\n};\n\nstatic char *_formmethodtbl[] = {\n    \"GET\", \"POST\", \"INTERNAL\", \"HEAD\"\n};\n\nchar *\nform2str(FormItemList *fi)\n{\n    Str tmp = Strnew();\n\n    if (fi->type != FORM_SELECT && fi->type != FORM_TEXTAREA)\n\tStrcat_charp(tmp, \"input type=\");\n    Strcat_charp(tmp, _formtypetbl[fi->type]);\n    if (fi->name && fi->name->length)\n\tStrcat_m_charp(tmp, \" name=\\\"\", fi->name->ptr, \"\\\"\", NULL);\n    if ((fi->type == FORM_INPUT_RADIO || fi->type == FORM_INPUT_CHECKBOX ||\n\t fi->type == FORM_SELECT) && fi->value)\n\tStrcat_m_charp(tmp, \" value=\\\"\", fi->value->ptr, \"\\\"\", NULL);\n    Strcat_m_charp(tmp, \" (\", _formmethodtbl[fi->parent->method], \" \",\n\t\t   fi->parent->action->ptr, \")\", NULL);\n    return tmp->ptr;\n}\n\nint\nformtype(char *typestr)\n{\n    int i;\n    for (i = 0; _formtypetbl[i]; i++) {\n\tif (!strcasecmp(typestr, _formtypetbl[i]))\n\t    return i;\n    }\n    return FORM_INPUT_TEXT;\n}\n\nvoid\nformRecheckRadio(Anchor *a, Buffer *buf, FormItemList *fi)\n{\n    int i;\n    Anchor *a2;\n    FormItemList *f2;\n\n    for (i = 0; i < buf->formitem->nanchor; i++) {\n\ta2 = &buf->formitem->anchors[i];\n\tf2 = (FormItemList *)a2->url;\n\tif (f2->parent == fi->parent && f2 != fi &&\n\t    f2->type == FORM_INPUT_RADIO && Strcmp(f2->name, fi->name) == 0) {\n\t    f2->checked = 0;\n\t    formUpdateBuffer(a2, buf, f2);\n\t}\n    }\n    fi->checked = 1;\n    formUpdateBuffer(a, buf, fi);\n}\n\nvoid\nformResetBuffer(Buffer *buf, AnchorList *formitem)\n{\n    int i;\n    Anchor *a;\n    FormItemList *f1, *f2;\n\n    if (buf == NULL || buf->formitem == NULL || formitem == NULL)\n\treturn;\n    for (i = 0; i < buf->formitem->nanchor && i < formitem->nanchor; i++) {\n\ta = &buf->formitem->anchors[i];\n\tif (a->y != a->start.line)\n\t    continue;\n\tf1 = (FormItemList *)a->url;\n\tf2 = (FormItemList *)formitem->anchors[i].url;\n\tif (f1->type != f2->type ||\n\t    strcmp(((f1->name == NULL) ? \"\" : f1->name->ptr),\n\t\t   ((f2->name == NULL) ? \"\" : f2->name->ptr)))\n\t    break;\t\t/* What's happening */\n\tswitch (f1->type) {\n\tcase FORM_INPUT_TEXT:\n\tcase FORM_INPUT_PASSWORD:\n\tcase FORM_INPUT_FILE:\n\tcase FORM_TEXTAREA:\n\t    f1->value = f2->value;\n\t    f1->init_value = f2->init_value;\n\t    break;\n\tcase FORM_INPUT_CHECKBOX:\n\tcase FORM_INPUT_RADIO:\n\t    f1->checked = f2->checked;\n\t    f1->init_checked = f2->init_checked;\n\t    break;\n\tcase FORM_SELECT:\n#ifdef MENU_SELECT\n\t    f1->select_option = f2->select_option;\n\t    f1->value = f2->value;\n\t    f1->label = f2->label;\n\t    f1->selected = f2->selected;\n\t    f1->init_value = f2->init_value;\n\t    f1->init_label = f2->init_label;\n\t    f1->init_selected = f2->init_selected;\n#endif\t\t\t\t/* MENU_SELECT */\n\t    break;\n\tdefault:\n\t    continue;\n\t}\n\tformUpdateBuffer(a, buf, f1);\n    }\n}\n\nstatic int\nform_update_line(Line *line, char **str, int spos, int epos, int width,\n\t\t int newline, int password)\n{\n    int c_len = 1, c_width = 1, w, i, len, pos;\n    char *p, *buf;\n    Lineprop c_type, effect, *prop;\n\n    for (p = *str, w = 0, pos = 0; *p && w < width;) {\n\tc_type = get_mctype((unsigned char *)p);\n#ifdef USE_M17N\n\tc_len = get_mclen(p);\n\tc_width = get_mcwidth(p);\n#endif\n\tif (c_type == PC_CTRL) {\n\t    if (newline && *p == '\\n')\n\t\tbreak;\n\t    if (*p != '\\r') {\n\t\tw++;\n\t\tpos++;\n\t    }\n\t}\n\telse if (password) {\n#ifdef USE_M17N\n\t    if (w + c_width > width)\n\t\tbreak;\n#endif\n\t    w += c_width;\n\t    pos += c_width;\n#ifdef USE_M17N\n\t}\n\telse if (c_type & PC_UNKNOWN) {\n\t    w++;\n\t    pos++;\n\t}\n\telse {\n\t    if (w + c_width > width)\n\t\tbreak;\n#endif\n\t    w += c_width;\n\t    pos += c_len;\n\t}\n\tp += c_len;\n    }\n    pos += width - w;\n\n    len = line->len + pos + spos - epos;\n    buf = New_N(char, len + 1);\n    buf[len] = '\\0';\n    prop = New_N(Lineprop, len);\n    bcopy((void *)line->lineBuf, (void *)buf, spos * sizeof(char));\n    bcopy((void *)line->propBuf, (void *)prop, spos * sizeof(Lineprop));\n\n    effect = CharEffect(line->propBuf[spos]);\n    for (p = *str, w = 0, pos = spos; *p && w < width;) {\n\tc_type = get_mctype((unsigned char *)p);\n#ifdef USE_M17N\n\tc_len = get_mclen(p);\n\tc_width = get_mcwidth(p);\n#endif\n\tif (c_type == PC_CTRL) {\n\t    if (newline && *p == '\\n')\n\t\tbreak;\n\t    if (*p != '\\r') {\n\t\tbuf[pos] = password ? '*' : ' ';\n\t\tprop[pos] = effect | PC_ASCII;\n\t\tpos++;\n\t\tw++;\n\t    }\n\t}\n\telse if (password) {\n#ifdef USE_M17N\n\t    if (w + c_width > width)\n\t\tbreak;\n#endif\n\t    for (i = 0; i < c_width; i++) {\n\t\tbuf[pos] = '*';\n\t\tprop[pos] = effect | PC_ASCII;\n\t\tpos++;\n\t\tw++;\n\t    }\n#ifdef USE_M17N\n\t}\n\telse if (c_type & PC_UNKNOWN) {\n\t    buf[pos] = ' ';\n\t    prop[pos] = effect | PC_ASCII;\n\t    pos++;\n\t    w++;\n\t}\n\telse {\n\t    if (w + c_width > width)\n\t\tbreak;\n#else\n\t}\n\telse {\n#endif\n\t    buf[pos] = *p;\n\t    prop[pos] = effect | c_type;\n\t    pos++;\n#ifdef USE_M17N\n\t    c_type = (c_type & ~PC_WCHAR1) | PC_WCHAR2;\n\t    for (i = 1; i < c_len; i++) {\n\t\tbuf[pos] = p[i];\n\t\tprop[pos] = effect | c_type;\n\t\tpos++;\n\t    }\n#endif\n\t    w += c_width;\n\t}\n\tp += c_len;\n    }\n    for (; w < width; w++) {\n\tbuf[pos] = ' ';\n\tprop[pos] = effect | PC_ASCII;\n\tpos++;\n    }\n    if (newline) {\n\tif (!FoldTextarea) {\n\t    while (*p && *p != '\\r' && *p != '\\n')\n\t\tp++;\n\t}\n\tif (*p == '\\r')\n\t    p++;\n\tif (*p == '\\n')\n\t    p++;\n    }\n    *str = p;\n\n    bcopy((void *)&line->lineBuf[epos], (void *)&buf[pos],\n\t  (line->len - epos) * sizeof(char));\n    bcopy((void *)&line->propBuf[epos], (void *)&prop[pos],\n\t  (line->len - epos) * sizeof(Lineprop));\n    line->lineBuf = buf;\n    line->propBuf = prop;\n    line->len = len;\n    line->size = len;\n\n    return pos;\n}\n\nvoid\nformUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)\n{\n    Buffer save;\n    char *p;\n    int spos, epos, rows, c_rows, pos, col = 0;\n    Line *l;\n\n    copyBuffer(&save, buf);\n    gotoLine(buf, a->start.line);\n    switch (form->type) {\n    case FORM_TEXTAREA:\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n#endif\t\t\t\t/* MENU_SELECT */\n\tspos = a->start.pos;\n\tepos = a->end.pos;\n\tbreak;\n    default:\n\tspos = a->start.pos + 1;\n\tepos = a->end.pos - 1;\n    }\n    switch (form->type) {\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n\tif (buf->currentLine == NULL ||\n\t    spos >= buf->currentLine->len || spos < 0)\n\t    break;\n\tif (form->checked)\n\t    buf->currentLine->lineBuf[spos] = '*';\n\telse\n\t    buf->currentLine->lineBuf[spos] = ' ';\n\tbreak;\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_TEXTAREA:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n\tif (form->type == FORM_SELECT) {\n\t    p = form->label->ptr;\n\t    updateSelectOption(form, form->select_option);\n\t}\n\telse\n#endif\t\t\t\t/* MENU_SELECT */\n\t{\n\t    if (!form->value)\n\t\tbreak;\n\t    p = form->value->ptr;\n\t}\n\tl = buf->currentLine;\n\tif (!l)\n\t    break;\n\tif (form->type == FORM_TEXTAREA) {\n\t    int n = a->y - buf->currentLine->linenumber;\n\t    if (n > 0)\n\t\tfor (; l && n; l = l->prev, n--) ;\n\t    else if (n < 0)\n\t\tfor (; l && n; l = l->prev, n++) ;\n\t    if (!l)\n\t\tbreak;\n\t}\n\trows = form->rows ? form->rows : 1;\n\tcol = COLPOS(l, a->start.pos);\n\tfor (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {\n\t    if (rows > 1) {\n\t\tpos = columnPos(l, col);\n\t\ta = retrieveAnchor(buf->formitem, l->linenumber, pos);\n\t\tif (a == NULL)\n\t\t    break;\n\t\tspos = a->start.pos;\n\t\tepos = a->end.pos;\n\t    }\n\t    if (a->start.line != a->end.line || spos > epos || epos >= l->len ||\n\t\tspos < 0 || epos < 0 || COLPOS(l, epos) < col)\n\t\tbreak;\n\t    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,\n\t\t\t\t   rows > 1,\n\t\t\t\t   form->type == FORM_INPUT_PASSWORD);\n\t    if (pos != epos) {\n\t\tshiftAnchorPosition(buf->href, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->name, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->img, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->formitem, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t    }\n\t}\n\tbreak;\n    }\n    copyBuffer(buf, &save);\n    arrangeLine(buf);\n}\n\n\nStr\ntextfieldrep(Str s, int width)\n{\n    Lineprop c_type;\n    Str n = Strnew_size(width + 2);\n    int i, j, k, c_len;\n\n    j = 0;\n    for (i = 0; i < s->length; i += c_len) {\n\tc_type = get_mctype((unsigned char *)&s->ptr[i]);\n\tc_len = get_mclen(&s->ptr[i]);\n\tif (s->ptr[i] == '\\r')\n\t    continue;\n\tk = j + get_mcwidth(&s->ptr[i]);\n\tif (k > width)\n\t    break;\n\tif (c_type == PC_CTRL)\n\t    Strcat_char(n, ' ');\n#ifdef USE_M17N\n\telse if (c_type & PC_UNKNOWN)\n\t    Strcat_char(n, ' ');\n#endif\n\telse if (s->ptr[i] == '&')\n\t    Strcat_charp(n, \"&amp;\");\n\telse if (s->ptr[i] == '<')\n\t    Strcat_charp(n, \"&lt;\");\n\telse if (s->ptr[i] == '>')\n\t    Strcat_charp(n, \"&gt;\");\n\telse\n\t    Strcat_charp_n(n, &s->ptr[i], c_len);\n\tj = k;\n    }\n    for (; j < width; j++)\n\tStrcat_char(n, ' ');\n    return n;\n}\n\nstatic void\nform_fputs_decode(Str s, FILE * f)\n{\n    char *p;\n    Str z = Strnew();\n\n    for (p = s->ptr; *p;) {\n\tswitch (*p) {\n#if !defined( __CYGWIN__ ) && !defined( __EMX__ )\n\tcase '\\r':\n\t    if (*(p + 1) == '\\n')\n\t\tp++;\n\t    /* continue to the next label */\n#endif\t\t\t\t/* !defined( __CYGWIN__ ) && !defined( __EMX__ \n\t\t\t\t * ) */\n\tdefault:\n\t    Strcat_char(z, *p);\n\t    p++;\n\t    break;\n\t}\n    }\n#ifdef USE_M17N\n    z = wc_Str_conv_strict(z, InnerCharset, DisplayCharset);\n#endif\n    Strfputs(z, f);\n}\n\n\nvoid\ninput_textarea(FormItemList *fi)\n{\n    char *tmpf = tmpfname(TMPF_DFL, NULL)->ptr;\n    Str tmp;\n    FILE *f;\n#ifdef USE_M17N\n    wc_ces charset = DisplayCharset;\n    wc_uint8 auto_detect;\n#endif\n\n    f = fopen(tmpf, \"w\");\n    if (f == NULL) {\n\t/* FIXME: gettextize? */\n\tdisp_err_message(\"Can't open temporary file\", FALSE);\n\treturn;\n    }\n    if (fi->value)\n\tform_fputs_decode(fi->value, f);\n    fclose(f);\n\n    fmTerm();\n    system(myEditor(Editor, tmpf, 1)->ptr);\n    fmInit();\n\n    if (fi->readonly)\n\tgoto input_end;\n    f = fopen(tmpf, \"r\");\n    if (f == NULL) {\n\t/* FIXME: gettextize? */\n\tdisp_err_message(\"Can't open temporary file\", FALSE);\n\tgoto input_end;\n    }\n    fi->value = Strnew();\n#ifdef USE_M17N\n    auto_detect = WcOption.auto_detect;\n    WcOption.auto_detect = WC_OPT_DETECT_ON;\n#endif\n    while (tmp = Strfgets(f), tmp->length > 0) {\n\tif (tmp->length == 1 && tmp->ptr[tmp->length - 1] == '\\n') {\n\t    /* null line with bare LF */\n\t    tmp = Strnew_charp(\"\\r\\n\");\n\t}\n\telse if (tmp->length > 1 && tmp->ptr[tmp->length - 1] == '\\n' &&\n\t\t tmp->ptr[tmp->length - 2] != '\\r') {\n\t    Strshrink(tmp, 1);\n\t    Strcat_charp(tmp, \"\\r\\n\");\n\t}\n\ttmp = convertLine(NULL, tmp, RAW_MODE, &charset, DisplayCharset);\n\tStrcat(fi->value, tmp);\n    }\n#ifdef USE_M17N\n    WcOption.auto_detect = auto_detect;\n#endif\n    fclose(f);\n  input_end:\n    unlink(tmpf);\n}\n\nvoid\ndo_internal(char *action, char *data)\n{\n    int i;\n\n    for (i = 0; internal_action[i].action; i++) {\n\tif (strcasecmp(internal_action[i].action, action) == 0) {\n\t    if (internal_action[i].rout)\n\t\tinternal_action[i].rout(cgistr2tagarg(data));\n\t    return;\n\t}\n    }\n}\n\n#ifdef MENU_SELECT\nvoid\naddSelectOption(FormSelectOption *fso, Str value, Str label, int chk)\n{\n    FormSelectOptionItem *o;\n    o = New(FormSelectOptionItem);\n    if (value == NULL)\n\tvalue = label;\n    o->value = value;\n    Strremovefirstspaces(label);\n    Strremovetrailingspaces(label);\n    o->label = label;\n    o->checked = chk;\n    o->next = NULL;\n    if (fso->first == NULL)\n\tfso->first = fso->last = o;\n    else {\n\tfso->last->next = o;\n\tfso->last = o;\n    }\n}\n\nvoid\nchooseSelectOption(FormItemList *fi, FormSelectOptionItem *item)\n{\n    FormSelectOptionItem *opt;\n    int i;\n\n    fi->selected = 0;\n    if (item == NULL) {\n\tfi->value = Strnew_size(0);\n\tfi->label = Strnew_size(0);\n\treturn;\n    }\n    fi->value = item->value;\n    fi->label = item->label;\n    for (i = 0, opt = item; opt != NULL; i++, opt = opt->next) {\n\tif (opt->checked) {\n\t    fi->value = opt->value;\n\t    fi->label = opt->label;\n\t    fi->selected = i;\n\t    break;\n\t}\n    }\n    updateSelectOption(fi, item);\n}\n\nvoid\nupdateSelectOption(FormItemList *fi, FormSelectOptionItem *item)\n{\n    int i;\n\n    if (fi == NULL || item == NULL)\n\treturn;\n    for (i = 0; item != NULL; i++, item = item->next) {\n\tif (i == fi->selected)\n\t    item->checked = TRUE;\n\telse\n\t    item->checked = FALSE;\n    }\n}\n\nint\nformChooseOptionByMenu(struct form_item_list *fi, int x, int y)\n{\n    int i, n, selected = -1, init_select = fi->selected;\n    FormSelectOptionItem *opt;\n    char **label;\n\n    for (n = 0, opt = fi->select_option; opt != NULL; n++, opt = opt->next) ;\n    label = New_N(char *, n + 1);\n    for (i = 0, opt = fi->select_option; opt != NULL; i++, opt = opt->next)\n\tlabel[i] = opt->label->ptr;\n    label[n] = NULL;\n\n    optionMenu(x, y, label, &selected, init_select, NULL);\n\n    if (selected < 0)\n\treturn 0;\n    for (i = 0, opt = fi->select_option; opt != NULL; i++, opt = opt->next) {\n\tif (i == selected) {\n\t    fi->selected = selected;\n\t    fi->value = opt->value;\n\t    fi->label = opt->label;\n\t    break;\n\t}\n    }\n    updateSelectOption(fi, fi->select_option);\n    return 1;\n}\n#endif\t\t\t\t/* MENU_SELECT */\n\nvoid\nform_write_data(FILE * f, char *boundary, char *name, char *value)\n{\n    fprintf(f, \"--%s\\r\\n\", boundary);\n    fprintf(f, \"Content-Disposition: form-data; name=\\\"%s\\\"\\r\\n\\r\\n\", name);\n    fprintf(f, \"%s\\r\\n\", value);\n}\n\nvoid\nform_write_from_file(FILE * f, char *boundary, char *name, char *filename,\n\t\t     char *file)\n{\n    FILE *fd;\n    struct stat st;\n    int c;\n    char *type;\n\n    fprintf(f, \"--%s\\r\\n\", boundary);\n    fprintf(f,\n\t    \"Content-Disposition: form-data; name=\\\"%s\\\"; filename=\\\"%s\\\"\\r\\n\",\n\t    name, mybasename(filename));\n    type = guessContentType(file);\n    fprintf(f, \"Content-Type: %s\\r\\n\\r\\n\",\n\t    type ? type : \"application/octet-stream\");\n\n    if (lstat(file, &st) < 0)\n\tgoto write_end;\n    if (S_ISDIR(st.st_mode))\n\tgoto write_end;\n    fd = fopen(file, \"r\");\n    if (fd != NULL) {\n\twhile ((c = fgetc(fd)) != EOF)\n\t    fputc(c, f);\n\tfclose(fd);\n    }\n  write_end:\n    fprintf(f, \"\\r\\n\");\n}\n\nstruct pre_form_item {\n    int type;\n    char *name;\n    char *value;\n    int checked;\n    struct pre_form_item *next;\n};\n\nstruct pre_form {\n    char *url;\n    Regex *re_url;\n    char *name;\n    char *action;\n    struct pre_form_item *item;\n    struct pre_form *next;\n};\n\nstatic struct pre_form *PreForm = NULL;\n\nstatic struct pre_form *\nadd_pre_form(struct pre_form *prev, char *url, Regex *re_url, char *name, char *action)\n{\n    ParsedURL pu;\n    struct pre_form *new;\n\n    if (prev)\n\tnew = prev->next = New(struct pre_form);\n    else\n\tnew = PreForm = New(struct pre_form);\n    if (url && !re_url) {\n\tparseURL2(url, &pu, NULL);\n\tnew->url = parsedURL2Str(&pu)->ptr;\n    }\n    else\n\tnew->url = url;\n    new->re_url = re_url;\n    new->name = (name && *name) ? name : NULL;\n    new->action = (action && *action) ? action : NULL;\n    new->item = NULL;\n    new->next = NULL;\n    return new;\n}\n\nstatic struct pre_form_item *\nadd_pre_form_item(struct pre_form *pf, struct pre_form_item *prev, int type,\n\t\t  char *name, char *value, char *checked)\n{\n    struct pre_form_item *new;\n\n    if (!pf)\n\treturn NULL;\n    if (prev)\n\tnew = prev->next = New(struct pre_form_item);\n    else\n\tnew = pf->item = New(struct pre_form_item);\n    new->type = type;\n    new->name = name;\n    new->value = value;\n    if (checked && *checked && (!strcmp(checked, \"0\") ||\n\t\t\t\t!strcasecmp(checked, \"off\")\n\t\t\t\t|| !strcasecmp(checked, \"no\")))\n\tnew->checked = 0;\n    else\n\tnew->checked = 1;\n    new->next = NULL;\n    return new;\n}\n\n/*\n * url <url>|/<re-url>/\n * form [<name>] <action>\n * text <name> <value>\n * file <name> <value>\n * passwd <name> <value>\n * checkbox <name> <value> [<checked>]\n * radio <name> <value>\n * select <name> <value>\n * submit [<name> [<value>]]\n * image [<name> [<value>]]\n * textarea <name>\n * <value>\n * /textarea\n */\n\nvoid\nloadPreForm(void)\n{\n    FILE *fp;\n    Str line = NULL, textarea = NULL;\n    struct pre_form *pf = NULL;\n    struct pre_form_item *pi = NULL;\n    int type = -1;\n    char *name = NULL;\n\n    PreForm = NULL;\n    fp = openSecretFile(pre_form_file);\n    if (fp == NULL)\n\treturn;\n    while (1) {\n\tchar *p, *s, *arg;\n\tRegex *re_arg;\n\n\tline = Strfgets(fp);\n\tif (line->length == 0)\n\t    break;\n\tif (textarea && !(!strncmp(line->ptr, \"/textarea\", 9) &&\n\t\t\t  IS_SPACE(line->ptr[9]))) {\n\t    Strcat(textarea, line);\n\t    continue;\n\t}\n\tStrchop(line);\n\tStrremovefirstspaces(line);\n\tp = line->ptr;\n\tif (*p == '#' || *p == '\\0')\n\t    continue;\t\t/* comment or empty line */\n\ts = getWord(&p);\n\n\tif (!strcmp(s, \"url\")) {\n\t    arg = getRegexWord((const char **)&p, &re_arg);\n\t    if (!arg || !*arg)\n\t\tcontinue;\n\t    p = getQWord(&p);\n\t    pf = add_pre_form(pf, arg, re_arg, NULL, p);\n\t    pi = pf->item;\n\t    continue;\n\t}\n\tif (!pf)\n\t    continue;\n\n\targ = getWord(&p);\n\tif (!strcmp(s, \"form\")) {\n\t    if (!arg || !*arg)\n\t\tcontinue;\n\t    s = getQWord(&p);\n\t    p = getQWord(&p);\n\t    if (!p || !*p) {\n\t\tp = s;\n\t\ts = NULL;\n\t    }\n\t    if (pf->item) {\n\t\tstruct pre_form *prev = pf;\n\t\tpf = add_pre_form(prev, \"\", NULL, s, p);\n\t\t/* copy previous URL */\n\t\tpf->url = prev->url;\n\t\tpf->re_url = prev->re_url;\n\t    }\n\t    else {\n\t\tpf->name = s;\n\t\tpf->action = (p && *p) ? p : NULL;\n\t    }\n\t    pi = pf->item;\n\t    continue;\n\t}\n\tif (!strcmp(s, \"text\"))\n\t    type = FORM_INPUT_TEXT;\n\telse if (!strcmp(s, \"file\"))\n\t    type = FORM_INPUT_FILE;\n\telse if (!strcmp(s, \"passwd\") || !strcmp(s, \"password\"))\n\t    type = FORM_INPUT_PASSWORD;\n\telse if (!strcmp(s, \"checkbox\"))\n\t    type = FORM_INPUT_CHECKBOX;\n\telse if (!strcmp(s, \"radio\"))\n\t    type = FORM_INPUT_RADIO;\n\telse if (!strcmp(s, \"submit\"))\n\t    type = FORM_INPUT_SUBMIT;\n\telse if (!strcmp(s, \"image\"))\n\t    type = FORM_INPUT_IMAGE;\n\telse if (!strcmp(s, \"select\"))\n\t    type = FORM_SELECT;\n\telse if (!strcmp(s, \"textarea\")) {\n\t    type = FORM_TEXTAREA;\n\t    name = Strnew_charp(arg)->ptr;\n\t    textarea = Strnew();\n\t    continue;\n\t}\n\telse if (textarea && name && !strcmp(s, \"/textarea\")) {\n\t    pi = add_pre_form_item(pf, pi, type, name, textarea->ptr, NULL);\n\t    textarea = NULL;\n\t    name = NULL;\n\t    continue;\n\t}\n\telse\n\t    continue;\n\ts = getQWord(&p);\n\tpi = add_pre_form_item(pf, pi, type, arg, s, getQWord(&p));\n    }\n    fclose(fp);\n}\n\nvoid\npreFormUpdateBuffer(Buffer *buf)\n{\n    struct pre_form *pf;\n    struct pre_form_item *pi;\n    int i;\n    Anchor *a;\n    FormList *fl;\n    FormItemList *fi;\n#ifdef MENU_SELECT\n    FormSelectOptionItem *opt;\n    int j;\n#endif\n\n    if (!buf || !buf->formitem || !PreForm)\n\treturn;\n\n    for (pf = PreForm; pf; pf = pf->next) {\n\tif (pf->re_url) {\n\t    Str url = parsedURL2Str(&buf->currentURL);\n\t    if (!RegexMatch(pf->re_url, url->ptr, url->length, 1))\n\t\tcontinue;\n\t}\n\telse if (pf->url) {\n\t    if (Strcmp_charp(parsedURL2Str(&buf->currentURL), pf->url))\n\t\tcontinue;\n\t}\n\telse\n\t    continue;\n\tfor (i = 0; i < buf->formitem->nanchor; i++) {\n\t    a = &buf->formitem->anchors[i];\n\t    fi = (FormItemList *)a->url;\n\t    fl = fi->parent;\n\t    if (pf->name && (!fl->name || strcmp(fl->name, pf->name)))\n\t\tcontinue;\n\t    if (pf->action\n\t\t&& (!fl->action || Strcmp_charp(fl->action, pf->action)))\n\t\tcontinue;\n\t    for (pi = pf->item; pi; pi = pi->next) {\n\t\tif (pi->type != fi->type)\n\t\t    continue;\n\t\tif (pi->type == FORM_INPUT_SUBMIT ||\n\t\t    pi->type == FORM_INPUT_IMAGE) {\n\t\t    if ((!pi->name || !*pi->name ||\n\t\t\t (fi->name && !Strcmp_charp(fi->name, pi->name))) &&\n\t\t\t(!pi->value || !*pi->value ||\n\t\t\t (fi->value && !Strcmp_charp(fi->value, pi->value))))\n\t\t\tbuf->submit = a;\n\t\t    continue;\n\t\t}\n\t\tif (!pi->name || !fi->name || Strcmp_charp(fi->name, pi->name))\n\t\t    continue;\n\t\tswitch (pi->type) {\n\t\tcase FORM_INPUT_TEXT:\n\t\tcase FORM_INPUT_FILE:\n\t\tcase FORM_INPUT_PASSWORD:\n\t\tcase FORM_TEXTAREA:\n\t\t    fi->value = Strnew_charp(pi->value);\n\t\t    formUpdateBuffer(a, buf, fi);\n\t\t    break;\n\t\tcase FORM_INPUT_CHECKBOX:\n\t\t    if (pi->value && fi->value &&\n\t\t\t!Strcmp_charp(fi->value, pi->value)) {\n\t\t\tfi->checked = pi->checked;\n\t\t\tformUpdateBuffer(a, buf, fi);\n\t\t    }\n\t\t    break;\n\t\tcase FORM_INPUT_RADIO:\n\t\t    if (pi->value && fi->value &&\n\t\t\t!Strcmp_charp(fi->value, pi->value))\n\t\t\tformRecheckRadio(a, buf, fi);\n\t\t    break;\n#ifdef MENU_SELECT\n\t\tcase FORM_SELECT:\n\t\t    for (j = 0, opt = fi->select_option; opt != NULL;\n\t\t\t j++, opt = opt->next) {\n\t\t\tif (pi->value && opt->value &&\n\t\t\t    !Strcmp_charp(opt->value, pi->value)) {\n\t\t\t    fi->selected = j;\n\t\t\t    fi->value = opt->value;\n\t\t\t    fi->label = opt->label;\n\t\t\t    updateSelectOption(fi, fi->select_option);\n\t\t\t    formUpdateBuffer(a, buf, fi);\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    break;\n#endif\n\t\t}\n\t    }\n\t}\n    }\n}\n"], "fixing_code": ["/* $Id: form.c,v 1.35 2010/07/18 13:48:48 htrb Exp $ */\n/* \n * HTML forms\n */\n#include \"fm.h\"\n#include \"parsetag.h\"\n#include \"parsetagx.h\"\n#include \"myctype.h\"\n#include \"local.h\"\n#include \"regex.h\"\n\nextern Str *textarea_str;\nextern int max_textarea;\n#ifdef MENU_SELECT\nextern FormSelectOption *select_option;\nextern int max_select;\n#include \"menu.h\"\n#endif\t\t\t\t/* MENU_SELECT */\n\n/* *INDENT-OFF* */\nstruct {\n    char *action;\n    void (*rout)(struct parsed_tagarg *);\n} internal_action[] = {\n    {\"map\", follow_map}, \n    {\"option\", panel_set_option},\n#ifdef USE_COOKIE\n    {\"cookie\", set_cookie_flag},\n#endif\t\t\t\t/* USE_COOKIE */\n    {\"download\", download_action},\n#ifdef USE_M17N\n    { \"charset\", change_charset },\n#endif\n    {\"none\", NULL},\n    {NULL, NULL},\n};\n/* *INDENT-ON* */\n\nstruct form_list *\nnewFormList(char *action, char *method, char *charset, char *enctype,\n\t    char *target, char *name, struct form_list *_next)\n{\n    struct form_list *l;\n    Str a = Strnew_charp(action);\n    int m = FORM_METHOD_GET;\n    int e = FORM_ENCTYPE_URLENCODED;\n#ifdef USE_M17N\n    wc_ces c = 0;\n#endif\n\n    if (method == NULL || !strcasecmp(method, \"get\"))\n\tm = FORM_METHOD_GET;\n    else if (!strcasecmp(method, \"post\"))\n\tm = FORM_METHOD_POST;\n    else if (!strcasecmp(method, \"internal\"))\n\tm = FORM_METHOD_INTERNAL;\n    /* unknown method is regarded as 'get' */\n\n    if (m != FORM_METHOD_GET && enctype != NULL &&\n\t!strcasecmp(enctype, \"multipart/form-data\")) {\n\te = FORM_ENCTYPE_MULTIPART;\n    }\n\n#ifdef USE_M17N\n    if (charset != NULL)\n\tc = wc_guess_charset(charset, 0);\n#endif\n\n    l = New(struct form_list);\n    l->item = l->lastitem = NULL;\n    l->action = a;\n    l->method = m;\n#ifdef USE_M17N\n    l->charset = c;\n#endif\n    l->enctype = e;\n    l->target = target;\n    l->name = name;\n    l->next = _next;\n    l->nitems = 0;\n    l->body = NULL;\n    l->length = 0;\n    return l;\n}\n\n/* \n * add <input> element to form_list\n */\nstruct form_item_list *\nformList_addInput(struct form_list *fl, struct parsed_tag *tag)\n{\n    struct form_item_list *item;\n    char *p;\n    int i;\n\n    /* if not in <form>..</form> environment, just ignore <input> tag */\n    if (fl == NULL)\n\treturn NULL;\n\n    item = New(struct form_item_list);\n    item->type = FORM_UNKNOWN;\n    item->size = -1;\n    item->rows = 0;\n    item->checked = item->init_checked = 0;\n    item->accept = 0;\n    item->name = NULL;\n    item->value = item->init_value = NULL;\n    item->readonly = 0;\n    if (parsedtag_get_value(tag, ATTR_TYPE, &p)) {\n\titem->type = formtype(p);\n\tif (item->size < 0 &&\n\t    (item->type == FORM_INPUT_TEXT ||\n\t     item->type == FORM_INPUT_FILE ||\n\t     item->type == FORM_INPUT_PASSWORD))\n\t    item->size = FORM_I_TEXT_DEFAULT_SIZE;\n    }\n    if (parsedtag_get_value(tag, ATTR_NAME, &p))\n\titem->name = Strnew_charp(p);\n    if (parsedtag_get_value(tag, ATTR_VALUE, &p))\n\titem->value = item->init_value = Strnew_charp(p);\n    item->checked = item->init_checked = parsedtag_exists(tag, ATTR_CHECKED);\n    item->accept = parsedtag_exists(tag, ATTR_ACCEPT);\n    parsedtag_get_value(tag, ATTR_SIZE, &item->size);\n    parsedtag_get_value(tag, ATTR_MAXLENGTH, &item->maxlength);\n    item->readonly = parsedtag_exists(tag, ATTR_READONLY);\n    if (parsedtag_get_value(tag, ATTR_TEXTAREANUMBER, &i)\n\t&& i >= 0 && i < max_textarea)\n\titem->value = item->init_value = textarea_str[i];\n#ifdef MENU_SELECT\n    if (parsedtag_get_value(tag, ATTR_SELECTNUMBER, &i)\n\t&& i >= 0 && i < max_select)\n\titem->select_option = select_option[i].first;\n#endif\t\t\t\t/* MENU_SELECT */\n    if (parsedtag_get_value(tag, ATTR_ROWS, &p))\n\titem->rows = atoi(p);\n    if (item->type == FORM_UNKNOWN) {\n\t/* type attribute is missing. Ignore the tag. */\n\treturn NULL;\n    }\n#ifdef MENU_SELECT\n    if (item->type == FORM_SELECT) {\n\tchooseSelectOption(item, item->select_option);\n\titem->init_selected = item->selected;\n\titem->init_value = item->value;\n\titem->init_label = item->label;\n    }\n#endif\t\t\t\t/* MENU_SELECT */\n    if (item->type == FORM_INPUT_FILE && item->value && item->value->length) {\n\t/* security hole ! */\n\treturn NULL;\n    }\n    item->parent = fl;\n    item->next = NULL;\n    if (fl->item == NULL) {\n\tfl->item = fl->lastitem = item;\n    }\n    else {\n\tfl->lastitem->next = item;\n\tfl->lastitem = item;\n    }\n    if (item->type == FORM_INPUT_HIDDEN)\n\treturn NULL;\n    fl->nitems++;\n    return item;\n}\n\nstatic char *_formtypetbl[] = {\n    \"text\", \"password\", \"checkbox\", \"radio\", \"submit\", \"reset\", \"hidden\",\n    \"image\", \"select\", \"textarea\", \"button\", \"file\", NULL\n};\n\nstatic char *_formmethodtbl[] = {\n    \"GET\", \"POST\", \"INTERNAL\", \"HEAD\"\n};\n\nchar *\nform2str(FormItemList *fi)\n{\n    Str tmp = Strnew();\n\n    if (fi->type != FORM_SELECT && fi->type != FORM_TEXTAREA)\n\tStrcat_charp(tmp, \"input type=\");\n    Strcat_charp(tmp, _formtypetbl[fi->type]);\n    if (fi->name && fi->name->length)\n\tStrcat_m_charp(tmp, \" name=\\\"\", fi->name->ptr, \"\\\"\", NULL);\n    if ((fi->type == FORM_INPUT_RADIO || fi->type == FORM_INPUT_CHECKBOX ||\n\t fi->type == FORM_SELECT) && fi->value)\n\tStrcat_m_charp(tmp, \" value=\\\"\", fi->value->ptr, \"\\\"\", NULL);\n    Strcat_m_charp(tmp, \" (\", _formmethodtbl[fi->parent->method], \" \",\n\t\t   fi->parent->action->ptr, \")\", NULL);\n    return tmp->ptr;\n}\n\nint\nformtype(char *typestr)\n{\n    int i;\n    for (i = 0; _formtypetbl[i]; i++) {\n\tif (!strcasecmp(typestr, _formtypetbl[i]))\n\t    return i;\n    }\n    return FORM_INPUT_TEXT;\n}\n\nvoid\nformRecheckRadio(Anchor *a, Buffer *buf, FormItemList *fi)\n{\n    int i;\n    Anchor *a2;\n    FormItemList *f2;\n\n    for (i = 0; i < buf->formitem->nanchor; i++) {\n\ta2 = &buf->formitem->anchors[i];\n\tf2 = (FormItemList *)a2->url;\n\tif (f2->parent == fi->parent && f2 != fi &&\n\t    f2->type == FORM_INPUT_RADIO && Strcmp(f2->name, fi->name) == 0) {\n\t    f2->checked = 0;\n\t    formUpdateBuffer(a2, buf, f2);\n\t}\n    }\n    fi->checked = 1;\n    formUpdateBuffer(a, buf, fi);\n}\n\nvoid\nformResetBuffer(Buffer *buf, AnchorList *formitem)\n{\n    int i;\n    Anchor *a;\n    FormItemList *f1, *f2;\n\n    if (buf == NULL || buf->formitem == NULL || formitem == NULL)\n\treturn;\n    for (i = 0; i < buf->formitem->nanchor && i < formitem->nanchor; i++) {\n\ta = &buf->formitem->anchors[i];\n\tif (a->y != a->start.line)\n\t    continue;\n\tf1 = (FormItemList *)a->url;\n\tf2 = (FormItemList *)formitem->anchors[i].url;\n\tif (f1->type != f2->type ||\n\t    strcmp(((f1->name == NULL) ? \"\" : f1->name->ptr),\n\t\t   ((f2->name == NULL) ? \"\" : f2->name->ptr)))\n\t    break;\t\t/* What's happening */\n\tswitch (f1->type) {\n\tcase FORM_INPUT_TEXT:\n\tcase FORM_INPUT_PASSWORD:\n\tcase FORM_INPUT_FILE:\n\tcase FORM_TEXTAREA:\n\t    f1->value = f2->value;\n\t    f1->init_value = f2->init_value;\n\t    break;\n\tcase FORM_INPUT_CHECKBOX:\n\tcase FORM_INPUT_RADIO:\n\t    f1->checked = f2->checked;\n\t    f1->init_checked = f2->init_checked;\n\t    break;\n\tcase FORM_SELECT:\n#ifdef MENU_SELECT\n\t    f1->select_option = f2->select_option;\n\t    f1->value = f2->value;\n\t    f1->label = f2->label;\n\t    f1->selected = f2->selected;\n\t    f1->init_value = f2->init_value;\n\t    f1->init_label = f2->init_label;\n\t    f1->init_selected = f2->init_selected;\n#endif\t\t\t\t/* MENU_SELECT */\n\t    break;\n\tdefault:\n\t    continue;\n\t}\n\tformUpdateBuffer(a, buf, f1);\n    }\n}\n\nstatic int\nform_update_line(Line *line, char **str, int spos, int epos, int width,\n\t\t int newline, int password)\n{\n    int c_len = 1, c_width = 1, w, i, len, pos;\n    char *p, *buf;\n    Lineprop c_type, effect, *prop;\n\n    for (p = *str, w = 0, pos = 0; *p && w < width;) {\n\tc_type = get_mctype((unsigned char *)p);\n#ifdef USE_M17N\n\tc_len = get_mclen(p);\n\tc_width = get_mcwidth(p);\n#endif\n\tif (c_type == PC_CTRL) {\n\t    if (newline && *p == '\\n')\n\t\tbreak;\n\t    if (*p != '\\r') {\n\t\tw++;\n\t\tpos++;\n\t    }\n\t}\n\telse if (password) {\n#ifdef USE_M17N\n\t    if (w + c_width > width)\n\t\tbreak;\n#endif\n\t    w += c_width;\n\t    pos += c_width;\n#ifdef USE_M17N\n\t}\n\telse if (c_type & PC_UNKNOWN) {\n\t    w++;\n\t    pos++;\n\t}\n\telse {\n\t    if (w + c_width > width)\n\t\tbreak;\n#endif\n\t    w += c_width;\n\t    pos += c_len;\n\t}\n\tp += c_len;\n    }\n    pos += width - w;\n\n    len = line->len + pos + spos - epos;\n    buf = New_N(char, len + 1);\n    buf[len] = '\\0';\n    prop = New_N(Lineprop, len);\n    bcopy((void *)line->lineBuf, (void *)buf, spos * sizeof(char));\n    bcopy((void *)line->propBuf, (void *)prop, spos * sizeof(Lineprop));\n\n    effect = CharEffect(line->propBuf[spos]);\n    for (p = *str, w = 0, pos = spos; *p && w < width;) {\n\tc_type = get_mctype((unsigned char *)p);\n#ifdef USE_M17N\n\tc_len = get_mclen(p);\n\tc_width = get_mcwidth(p);\n#endif\n\tif (c_type == PC_CTRL) {\n\t    if (newline && *p == '\\n')\n\t\tbreak;\n\t    if (*p != '\\r') {\n\t\tbuf[pos] = password ? '*' : ' ';\n\t\tprop[pos] = effect | PC_ASCII;\n\t\tpos++;\n\t\tw++;\n\t    }\n\t}\n\telse if (password) {\n#ifdef USE_M17N\n\t    if (w + c_width > width)\n\t\tbreak;\n#endif\n\t    for (i = 0; i < c_width; i++) {\n\t\tbuf[pos] = '*';\n\t\tprop[pos] = effect | PC_ASCII;\n\t\tpos++;\n\t\tw++;\n\t    }\n#ifdef USE_M17N\n\t}\n\telse if (c_type & PC_UNKNOWN) {\n\t    buf[pos] = ' ';\n\t    prop[pos] = effect | PC_ASCII;\n\t    pos++;\n\t    w++;\n\t}\n\telse {\n\t    if (w + c_width > width)\n\t\tbreak;\n#else\n\t}\n\telse {\n#endif\n\t    buf[pos] = *p;\n\t    prop[pos] = effect | c_type;\n\t    pos++;\n#ifdef USE_M17N\n\t    c_type = (c_type & ~PC_WCHAR1) | PC_WCHAR2;\n\t    for (i = 1; i < c_len; i++) {\n\t\tbuf[pos] = p[i];\n\t\tprop[pos] = effect | c_type;\n\t\tpos++;\n\t    }\n#endif\n\t    w += c_width;\n\t}\n\tp += c_len;\n    }\n    for (; w < width; w++) {\n\tbuf[pos] = ' ';\n\tprop[pos] = effect | PC_ASCII;\n\tpos++;\n    }\n    if (newline) {\n\tif (!FoldTextarea) {\n\t    while (*p && *p != '\\r' && *p != '\\n')\n\t\tp++;\n\t}\n\tif (*p == '\\r')\n\t    p++;\n\tif (*p == '\\n')\n\t    p++;\n    }\n    *str = p;\n\n    bcopy((void *)&line->lineBuf[epos], (void *)&buf[pos],\n\t  (line->len - epos) * sizeof(char));\n    bcopy((void *)&line->propBuf[epos], (void *)&prop[pos],\n\t  (line->len - epos) * sizeof(Lineprop));\n    line->lineBuf = buf;\n    line->propBuf = prop;\n    line->len = len;\n    line->size = len;\n\n    return pos;\n}\n\nvoid\nformUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)\n{\n    Buffer save;\n    char *p;\n    int spos, epos, rows, c_rows, pos, col = 0;\n    Line *l;\n\n    copyBuffer(&save, buf);\n    gotoLine(buf, a->start.line);\n    switch (form->type) {\n    case FORM_TEXTAREA:\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n#endif\t\t\t\t/* MENU_SELECT */\n\tspos = a->start.pos;\n\tepos = a->end.pos;\n\tbreak;\n    default:\n\tspos = a->start.pos + 1;\n\tepos = a->end.pos - 1;\n    }\n    switch (form->type) {\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n\tif (buf->currentLine == NULL ||\n\t    spos >= buf->currentLine->len || spos < 0)\n\t    break;\n\tif (form->checked)\n\t    buf->currentLine->lineBuf[spos] = '*';\n\telse\n\t    buf->currentLine->lineBuf[spos] = ' ';\n\tbreak;\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_TEXTAREA:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n\tif (form->type == FORM_SELECT) {\n\t    p = form->label->ptr;\n\t    updateSelectOption(form, form->select_option);\n\t}\n\telse\n#endif\t\t\t\t/* MENU_SELECT */\n\t{\n\t    if (!form->value)\n\t\tbreak;\n\t    p = form->value->ptr;\n\t}\n\tl = buf->currentLine;\n\tif (!l)\n\t    break;\n\tif (form->type == FORM_TEXTAREA) {\n\t    int n = a->y - buf->currentLine->linenumber;\n\t    if (n > 0)\n\t\tfor (; l && n; l = l->prev, n--) ;\n\t    else if (n < 0)\n\t\tfor (; l && n; l = l->prev, n++) ;\n\t    if (!l)\n\t\tbreak;\n\t}\n\trows = form->rows ? form->rows : 1;\n\tcol = COLPOS(l, a->start.pos);\n\tfor (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {\n\t    if (l == NULL)\n\t\tbreak;\n\t    if (rows > 1) {\n\t\tpos = columnPos(l, col);\n\t\ta = retrieveAnchor(buf->formitem, l->linenumber, pos);\n\t\tif (a == NULL)\n\t\t    break;\n\t\tspos = a->start.pos;\n\t\tepos = a->end.pos;\n\t    }\n\t    if (a->start.line != a->end.line || spos > epos || epos >= l->len ||\n\t\tspos < 0 || epos < 0 || COLPOS(l, epos) < col)\n\t\tbreak;\n\t    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,\n\t\t\t\t   rows > 1,\n\t\t\t\t   form->type == FORM_INPUT_PASSWORD);\n\t    if (pos != epos) {\n\t\tshiftAnchorPosition(buf->href, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->name, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->img, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->formitem, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t    }\n\t}\n\tbreak;\n    }\n    copyBuffer(buf, &save);\n    arrangeLine(buf);\n}\n\n\nStr\ntextfieldrep(Str s, int width)\n{\n    Lineprop c_type;\n    Str n = Strnew_size(width + 2);\n    int i, j, k, c_len;\n\n    j = 0;\n    for (i = 0; i < s->length; i += c_len) {\n\tc_type = get_mctype((unsigned char *)&s->ptr[i]);\n\tc_len = get_mclen(&s->ptr[i]);\n\tif (s->ptr[i] == '\\r')\n\t    continue;\n\tk = j + get_mcwidth(&s->ptr[i]);\n\tif (k > width)\n\t    break;\n\tif (c_type == PC_CTRL)\n\t    Strcat_char(n, ' ');\n#ifdef USE_M17N\n\telse if (c_type & PC_UNKNOWN)\n\t    Strcat_char(n, ' ');\n#endif\n\telse if (s->ptr[i] == '&')\n\t    Strcat_charp(n, \"&amp;\");\n\telse if (s->ptr[i] == '<')\n\t    Strcat_charp(n, \"&lt;\");\n\telse if (s->ptr[i] == '>')\n\t    Strcat_charp(n, \"&gt;\");\n\telse\n\t    Strcat_charp_n(n, &s->ptr[i], c_len);\n\tj = k;\n    }\n    for (; j < width; j++)\n\tStrcat_char(n, ' ');\n    return n;\n}\n\nstatic void\nform_fputs_decode(Str s, FILE * f)\n{\n    char *p;\n    Str z = Strnew();\n\n    for (p = s->ptr; *p;) {\n\tswitch (*p) {\n#if !defined( __CYGWIN__ ) && !defined( __EMX__ )\n\tcase '\\r':\n\t    if (*(p + 1) == '\\n')\n\t\tp++;\n\t    /* continue to the next label */\n#endif\t\t\t\t/* !defined( __CYGWIN__ ) && !defined( __EMX__ \n\t\t\t\t * ) */\n\tdefault:\n\t    Strcat_char(z, *p);\n\t    p++;\n\t    break;\n\t}\n    }\n#ifdef USE_M17N\n    z = wc_Str_conv_strict(z, InnerCharset, DisplayCharset);\n#endif\n    Strfputs(z, f);\n}\n\n\nvoid\ninput_textarea(FormItemList *fi)\n{\n    char *tmpf = tmpfname(TMPF_DFL, NULL)->ptr;\n    Str tmp;\n    FILE *f;\n#ifdef USE_M17N\n    wc_ces charset = DisplayCharset;\n    wc_uint8 auto_detect;\n#endif\n\n    f = fopen(tmpf, \"w\");\n    if (f == NULL) {\n\t/* FIXME: gettextize? */\n\tdisp_err_message(\"Can't open temporary file\", FALSE);\n\treturn;\n    }\n    if (fi->value)\n\tform_fputs_decode(fi->value, f);\n    fclose(f);\n\n    fmTerm();\n    system(myEditor(Editor, tmpf, 1)->ptr);\n    fmInit();\n\n    if (fi->readonly)\n\tgoto input_end;\n    f = fopen(tmpf, \"r\");\n    if (f == NULL) {\n\t/* FIXME: gettextize? */\n\tdisp_err_message(\"Can't open temporary file\", FALSE);\n\tgoto input_end;\n    }\n    fi->value = Strnew();\n#ifdef USE_M17N\n    auto_detect = WcOption.auto_detect;\n    WcOption.auto_detect = WC_OPT_DETECT_ON;\n#endif\n    while (tmp = Strfgets(f), tmp->length > 0) {\n\tif (tmp->length == 1 && tmp->ptr[tmp->length - 1] == '\\n') {\n\t    /* null line with bare LF */\n\t    tmp = Strnew_charp(\"\\r\\n\");\n\t}\n\telse if (tmp->length > 1 && tmp->ptr[tmp->length - 1] == '\\n' &&\n\t\t tmp->ptr[tmp->length - 2] != '\\r') {\n\t    Strshrink(tmp, 1);\n\t    Strcat_charp(tmp, \"\\r\\n\");\n\t}\n\ttmp = convertLine(NULL, tmp, RAW_MODE, &charset, DisplayCharset);\n\tStrcat(fi->value, tmp);\n    }\n#ifdef USE_M17N\n    WcOption.auto_detect = auto_detect;\n#endif\n    fclose(f);\n  input_end:\n    unlink(tmpf);\n}\n\nvoid\ndo_internal(char *action, char *data)\n{\n    int i;\n\n    for (i = 0; internal_action[i].action; i++) {\n\tif (strcasecmp(internal_action[i].action, action) == 0) {\n\t    if (internal_action[i].rout)\n\t\tinternal_action[i].rout(cgistr2tagarg(data));\n\t    return;\n\t}\n    }\n}\n\n#ifdef MENU_SELECT\nvoid\naddSelectOption(FormSelectOption *fso, Str value, Str label, int chk)\n{\n    FormSelectOptionItem *o;\n    o = New(FormSelectOptionItem);\n    if (value == NULL)\n\tvalue = label;\n    o->value = value;\n    Strremovefirstspaces(label);\n    Strremovetrailingspaces(label);\n    o->label = label;\n    o->checked = chk;\n    o->next = NULL;\n    if (fso->first == NULL)\n\tfso->first = fso->last = o;\n    else {\n\tfso->last->next = o;\n\tfso->last = o;\n    }\n}\n\nvoid\nchooseSelectOption(FormItemList *fi, FormSelectOptionItem *item)\n{\n    FormSelectOptionItem *opt;\n    int i;\n\n    fi->selected = 0;\n    if (item == NULL) {\n\tfi->value = Strnew_size(0);\n\tfi->label = Strnew_size(0);\n\treturn;\n    }\n    fi->value = item->value;\n    fi->label = item->label;\n    for (i = 0, opt = item; opt != NULL; i++, opt = opt->next) {\n\tif (opt->checked) {\n\t    fi->value = opt->value;\n\t    fi->label = opt->label;\n\t    fi->selected = i;\n\t    break;\n\t}\n    }\n    updateSelectOption(fi, item);\n}\n\nvoid\nupdateSelectOption(FormItemList *fi, FormSelectOptionItem *item)\n{\n    int i;\n\n    if (fi == NULL || item == NULL)\n\treturn;\n    for (i = 0; item != NULL; i++, item = item->next) {\n\tif (i == fi->selected)\n\t    item->checked = TRUE;\n\telse\n\t    item->checked = FALSE;\n    }\n}\n\nint\nformChooseOptionByMenu(struct form_item_list *fi, int x, int y)\n{\n    int i, n, selected = -1, init_select = fi->selected;\n    FormSelectOptionItem *opt;\n    char **label;\n\n    for (n = 0, opt = fi->select_option; opt != NULL; n++, opt = opt->next) ;\n    label = New_N(char *, n + 1);\n    for (i = 0, opt = fi->select_option; opt != NULL; i++, opt = opt->next)\n\tlabel[i] = opt->label->ptr;\n    label[n] = NULL;\n\n    optionMenu(x, y, label, &selected, init_select, NULL);\n\n    if (selected < 0)\n\treturn 0;\n    for (i = 0, opt = fi->select_option; opt != NULL; i++, opt = opt->next) {\n\tif (i == selected) {\n\t    fi->selected = selected;\n\t    fi->value = opt->value;\n\t    fi->label = opt->label;\n\t    break;\n\t}\n    }\n    updateSelectOption(fi, fi->select_option);\n    return 1;\n}\n#endif\t\t\t\t/* MENU_SELECT */\n\nvoid\nform_write_data(FILE * f, char *boundary, char *name, char *value)\n{\n    fprintf(f, \"--%s\\r\\n\", boundary);\n    fprintf(f, \"Content-Disposition: form-data; name=\\\"%s\\\"\\r\\n\\r\\n\", name);\n    fprintf(f, \"%s\\r\\n\", value);\n}\n\nvoid\nform_write_from_file(FILE * f, char *boundary, char *name, char *filename,\n\t\t     char *file)\n{\n    FILE *fd;\n    struct stat st;\n    int c;\n    char *type;\n\n    fprintf(f, \"--%s\\r\\n\", boundary);\n    fprintf(f,\n\t    \"Content-Disposition: form-data; name=\\\"%s\\\"; filename=\\\"%s\\\"\\r\\n\",\n\t    name, mybasename(filename));\n    type = guessContentType(file);\n    fprintf(f, \"Content-Type: %s\\r\\n\\r\\n\",\n\t    type ? type : \"application/octet-stream\");\n\n    if (lstat(file, &st) < 0)\n\tgoto write_end;\n    if (S_ISDIR(st.st_mode))\n\tgoto write_end;\n    fd = fopen(file, \"r\");\n    if (fd != NULL) {\n\twhile ((c = fgetc(fd)) != EOF)\n\t    fputc(c, f);\n\tfclose(fd);\n    }\n  write_end:\n    fprintf(f, \"\\r\\n\");\n}\n\nstruct pre_form_item {\n    int type;\n    char *name;\n    char *value;\n    int checked;\n    struct pre_form_item *next;\n};\n\nstruct pre_form {\n    char *url;\n    Regex *re_url;\n    char *name;\n    char *action;\n    struct pre_form_item *item;\n    struct pre_form *next;\n};\n\nstatic struct pre_form *PreForm = NULL;\n\nstatic struct pre_form *\nadd_pre_form(struct pre_form *prev, char *url, Regex *re_url, char *name, char *action)\n{\n    ParsedURL pu;\n    struct pre_form *new;\n\n    if (prev)\n\tnew = prev->next = New(struct pre_form);\n    else\n\tnew = PreForm = New(struct pre_form);\n    if (url && !re_url) {\n\tparseURL2(url, &pu, NULL);\n\tnew->url = parsedURL2Str(&pu)->ptr;\n    }\n    else\n\tnew->url = url;\n    new->re_url = re_url;\n    new->name = (name && *name) ? name : NULL;\n    new->action = (action && *action) ? action : NULL;\n    new->item = NULL;\n    new->next = NULL;\n    return new;\n}\n\nstatic struct pre_form_item *\nadd_pre_form_item(struct pre_form *pf, struct pre_form_item *prev, int type,\n\t\t  char *name, char *value, char *checked)\n{\n    struct pre_form_item *new;\n\n    if (!pf)\n\treturn NULL;\n    if (prev)\n\tnew = prev->next = New(struct pre_form_item);\n    else\n\tnew = pf->item = New(struct pre_form_item);\n    new->type = type;\n    new->name = name;\n    new->value = value;\n    if (checked && *checked && (!strcmp(checked, \"0\") ||\n\t\t\t\t!strcasecmp(checked, \"off\")\n\t\t\t\t|| !strcasecmp(checked, \"no\")))\n\tnew->checked = 0;\n    else\n\tnew->checked = 1;\n    new->next = NULL;\n    return new;\n}\n\n/*\n * url <url>|/<re-url>/\n * form [<name>] <action>\n * text <name> <value>\n * file <name> <value>\n * passwd <name> <value>\n * checkbox <name> <value> [<checked>]\n * radio <name> <value>\n * select <name> <value>\n * submit [<name> [<value>]]\n * image [<name> [<value>]]\n * textarea <name>\n * <value>\n * /textarea\n */\n\nvoid\nloadPreForm(void)\n{\n    FILE *fp;\n    Str line = NULL, textarea = NULL;\n    struct pre_form *pf = NULL;\n    struct pre_form_item *pi = NULL;\n    int type = -1;\n    char *name = NULL;\n\n    PreForm = NULL;\n    fp = openSecretFile(pre_form_file);\n    if (fp == NULL)\n\treturn;\n    while (1) {\n\tchar *p, *s, *arg;\n\tRegex *re_arg;\n\n\tline = Strfgets(fp);\n\tif (line->length == 0)\n\t    break;\n\tif (textarea && !(!strncmp(line->ptr, \"/textarea\", 9) &&\n\t\t\t  IS_SPACE(line->ptr[9]))) {\n\t    Strcat(textarea, line);\n\t    continue;\n\t}\n\tStrchop(line);\n\tStrremovefirstspaces(line);\n\tp = line->ptr;\n\tif (*p == '#' || *p == '\\0')\n\t    continue;\t\t/* comment or empty line */\n\ts = getWord(&p);\n\n\tif (!strcmp(s, \"url\")) {\n\t    arg = getRegexWord((const char **)&p, &re_arg);\n\t    if (!arg || !*arg)\n\t\tcontinue;\n\t    p = getQWord(&p);\n\t    pf = add_pre_form(pf, arg, re_arg, NULL, p);\n\t    pi = pf->item;\n\t    continue;\n\t}\n\tif (!pf)\n\t    continue;\n\n\targ = getWord(&p);\n\tif (!strcmp(s, \"form\")) {\n\t    if (!arg || !*arg)\n\t\tcontinue;\n\t    s = getQWord(&p);\n\t    p = getQWord(&p);\n\t    if (!p || !*p) {\n\t\tp = s;\n\t\ts = NULL;\n\t    }\n\t    if (pf->item) {\n\t\tstruct pre_form *prev = pf;\n\t\tpf = add_pre_form(prev, \"\", NULL, s, p);\n\t\t/* copy previous URL */\n\t\tpf->url = prev->url;\n\t\tpf->re_url = prev->re_url;\n\t    }\n\t    else {\n\t\tpf->name = s;\n\t\tpf->action = (p && *p) ? p : NULL;\n\t    }\n\t    pi = pf->item;\n\t    continue;\n\t}\n\tif (!strcmp(s, \"text\"))\n\t    type = FORM_INPUT_TEXT;\n\telse if (!strcmp(s, \"file\"))\n\t    type = FORM_INPUT_FILE;\n\telse if (!strcmp(s, \"passwd\") || !strcmp(s, \"password\"))\n\t    type = FORM_INPUT_PASSWORD;\n\telse if (!strcmp(s, \"checkbox\"))\n\t    type = FORM_INPUT_CHECKBOX;\n\telse if (!strcmp(s, \"radio\"))\n\t    type = FORM_INPUT_RADIO;\n\telse if (!strcmp(s, \"submit\"))\n\t    type = FORM_INPUT_SUBMIT;\n\telse if (!strcmp(s, \"image\"))\n\t    type = FORM_INPUT_IMAGE;\n\telse if (!strcmp(s, \"select\"))\n\t    type = FORM_SELECT;\n\telse if (!strcmp(s, \"textarea\")) {\n\t    type = FORM_TEXTAREA;\n\t    name = Strnew_charp(arg)->ptr;\n\t    textarea = Strnew();\n\t    continue;\n\t}\n\telse if (textarea && name && !strcmp(s, \"/textarea\")) {\n\t    pi = add_pre_form_item(pf, pi, type, name, textarea->ptr, NULL);\n\t    textarea = NULL;\n\t    name = NULL;\n\t    continue;\n\t}\n\telse\n\t    continue;\n\ts = getQWord(&p);\n\tpi = add_pre_form_item(pf, pi, type, arg, s, getQWord(&p));\n    }\n    fclose(fp);\n}\n\nvoid\npreFormUpdateBuffer(Buffer *buf)\n{\n    struct pre_form *pf;\n    struct pre_form_item *pi;\n    int i;\n    Anchor *a;\n    FormList *fl;\n    FormItemList *fi;\n#ifdef MENU_SELECT\n    FormSelectOptionItem *opt;\n    int j;\n#endif\n\n    if (!buf || !buf->formitem || !PreForm)\n\treturn;\n\n    for (pf = PreForm; pf; pf = pf->next) {\n\tif (pf->re_url) {\n\t    Str url = parsedURL2Str(&buf->currentURL);\n\t    if (!RegexMatch(pf->re_url, url->ptr, url->length, 1))\n\t\tcontinue;\n\t}\n\telse if (pf->url) {\n\t    if (Strcmp_charp(parsedURL2Str(&buf->currentURL), pf->url))\n\t\tcontinue;\n\t}\n\telse\n\t    continue;\n\tfor (i = 0; i < buf->formitem->nanchor; i++) {\n\t    a = &buf->formitem->anchors[i];\n\t    fi = (FormItemList *)a->url;\n\t    fl = fi->parent;\n\t    if (pf->name && (!fl->name || strcmp(fl->name, pf->name)))\n\t\tcontinue;\n\t    if (pf->action\n\t\t&& (!fl->action || Strcmp_charp(fl->action, pf->action)))\n\t\tcontinue;\n\t    for (pi = pf->item; pi; pi = pi->next) {\n\t\tif (pi->type != fi->type)\n\t\t    continue;\n\t\tif (pi->type == FORM_INPUT_SUBMIT ||\n\t\t    pi->type == FORM_INPUT_IMAGE) {\n\t\t    if ((!pi->name || !*pi->name ||\n\t\t\t (fi->name && !Strcmp_charp(fi->name, pi->name))) &&\n\t\t\t(!pi->value || !*pi->value ||\n\t\t\t (fi->value && !Strcmp_charp(fi->value, pi->value))))\n\t\t\tbuf->submit = a;\n\t\t    continue;\n\t\t}\n\t\tif (!pi->name || !fi->name || Strcmp_charp(fi->name, pi->name))\n\t\t    continue;\n\t\tswitch (pi->type) {\n\t\tcase FORM_INPUT_TEXT:\n\t\tcase FORM_INPUT_FILE:\n\t\tcase FORM_INPUT_PASSWORD:\n\t\tcase FORM_TEXTAREA:\n\t\t    fi->value = Strnew_charp(pi->value);\n\t\t    formUpdateBuffer(a, buf, fi);\n\t\t    break;\n\t\tcase FORM_INPUT_CHECKBOX:\n\t\t    if (pi->value && fi->value &&\n\t\t\t!Strcmp_charp(fi->value, pi->value)) {\n\t\t\tfi->checked = pi->checked;\n\t\t\tformUpdateBuffer(a, buf, fi);\n\t\t    }\n\t\t    break;\n\t\tcase FORM_INPUT_RADIO:\n\t\t    if (pi->value && fi->value &&\n\t\t\t!Strcmp_charp(fi->value, pi->value))\n\t\t\tformRecheckRadio(a, buf, fi);\n\t\t    break;\n#ifdef MENU_SELECT\n\t\tcase FORM_SELECT:\n\t\t    for (j = 0, opt = fi->select_option; opt != NULL;\n\t\t\t j++, opt = opt->next) {\n\t\t\tif (pi->value && opt->value &&\n\t\t\t    !Strcmp_charp(opt->value, pi->value)) {\n\t\t\t    fi->selected = j;\n\t\t\t    fi->value = opt->value;\n\t\t\t    fi->label = opt->label;\n\t\t\t    updateSelectOption(fi, fi->select_option);\n\t\t\t    formUpdateBuffer(a, buf, fi);\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    break;\n#endif\n\t\t}\n\t    }\n\t}\n    }\n}\n"], "filenames": ["form.c"], "buggy_code_start_loc": [484], "buggy_code_end_loc": [484], "fixing_code_start_loc": [485], "fixing_code_end_loc": [487], "type": "CWE-476", "message": "w3m through 0.5.3 is prone to a NULL pointer dereference flaw in formUpdateBuffer in form.c.", "other": {"cve": {"id": "CVE-2018-6197", "sourceIdentifier": "cve@mitre.org", "published": "2018-01-25T03:29:00.603", "lastModified": "2019-04-05T00:29:01.740", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "w3m through 0.5.3 is prone to a NULL pointer dereference flaw in formUpdateBuffer in form.c."}, {"lang": "es", "value": "w3m hasta la versi\u00f3n 0.5.3 es propenso a un error de desreferencia de puntero NULL en formUpdateBuffer en form.c."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:w3m_project:w3m:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.5.3", "matchCriteriaId": "E9ED2413-606A-403C-82FF-A2EB381867AF"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:17.10:*:*:*:*:*:*:*", "matchCriteriaId": "9070C9D8-A14A-467F-8253-33B966C16886"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-04/msg00028.html", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/102846", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/tats/w3m/commit/7fdc83b0364005a0b5ed869230dd81752ba022e8", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tats/w3m/issues/89", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/04/msg00025.html", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3555-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3555-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tats/w3m/commit/7fdc83b0364005a0b5ed869230dd81752ba022e8"}}