{"buggy_code": ["/**\n ** BigBlueButton open source conferencing system - http://www.bigbluebutton.org/\n *\n * Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).\n *\n * This program is free software; you can redistribute it and/or modify it under the\n * terms of the GNU Lesser General Public License as published by the Free Software\n * Foundation; either version 3.0 of the License, or (at your option) any later\n * version.\n *\n * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License along\n * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage org.bigbluebutton.web.controllers\n\nimport com.google.gson.Gson\nimport grails.web.context.ServletContextHolder\nimport groovy.json.JsonBuilder\nimport org.apache.commons.codec.binary.Base64\nimport org.apache.commons.io.FilenameUtils\nimport org.apache.commons.lang.RandomStringUtils\nimport org.apache.commons.lang.StringUtils\nimport org.bigbluebutton.api.*\nimport org.bigbluebutton.api.domain.Config\nimport org.bigbluebutton.api.domain.GuestPolicy\nimport org.bigbluebutton.api.domain.Meeting\nimport org.bigbluebutton.api.domain.UserSession\nimport org.bigbluebutton.api.util.ParamsUtil\nimport org.bigbluebutton.api.util.ResponseBuilder\nimport org.bigbluebutton.presentation.PresentationUrlDownloadService\nimport org.bigbluebutton.presentation.UploadedPresentation\nimport org.bigbluebutton.web.services.PresentationService\nimport org.bigbluebutton.web.services.turn.StunTurnService\nimport org.bigbluebutton.web.services.turn.TurnEntry\nimport org.bigbluebutton.web.services.turn.StunServer\nimport org.bigbluebutton.web.services.turn.RemoteIceCandidate\nimport org.json.JSONArray\n\nimport javax.servlet.ServletRequest\n\nclass ApiController {\n  private static final Integer SESSION_TIMEOUT = 14400  // 4 hours\n  private static final String CONTROLLER_NAME = 'ApiController'\n  protected static final String RESP_CODE_SUCCESS = 'SUCCESS'\n  protected static final String RESP_CODE_FAILED = 'FAILED'\n  private static final String ROLE_MODERATOR = \"MODERATOR\"\n  private static final String ROLE_ATTENDEE = \"VIEWER\"\n  protected static Boolean REDIRECT_RESPONSE = true\n\n  MeetingService meetingService;\n  PresentationService presentationService\n  ParamsProcessorUtil paramsProcessorUtil\n  ClientConfigService configService\n  PresentationUrlDownloadService presDownloadService\n  StunTurnService stunTurnService\n  ResponseBuilder responseBuilder = initResponseBuilder()\n\n  def initResponseBuilder = {\n    String protocol = this.getClass().getResource(\"\").getProtocol();\n    if (Objects.equals(protocol, \"jar\")) {\n      // Application running inside a JAR file\n      responseBuilder = new ResponseBuilder(getClass().getClassLoader(), \"/WEB-INF/freemarker\")\n    } else if (Objects.equals(protocol, \"file\")) {\n      // Application unzipped and running outside a JAR file\n      String templateLoc = ServletContextHolder.servletContext.getRealPath(\"/WEB-INF/freemarker\")\n      // We should never have a null `templateLoc`\n      responseBuilder = new ResponseBuilder(new File(templateLoc))\n    }\n  }\n\n  /* general methods */\n  def index = {\n    log.debug CONTROLLER_NAME + \"#index\"\n    response.addHeader(\"Cache-Control\", \"no-cache\")\n\n    withFormat {\n      xml {\n        render(text: responseBuilder.buildMeetingVersion(paramsProcessorUtil.getApiVersion(), RESP_CODE_SUCCESS), contentType: \"text/xml\")\n      }\n    }\n  }\n\n  /***********************************\n   * CREATE (API)\n   ***********************************/\n  def create = {\n    String API_CALL = 'create'\n    log.debug CONTROLLER_NAME + \"#${API_CALL}\"\n    log.debug request.getParameterMap().toMapString()\n\n    // BEGIN - backward compatibility\n    if (StringUtils.isEmpty(params.checksum)) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n\n    if (!StringUtils.isEmpty(params.meetingID)) {\n      params.meetingID = StringUtils.strip(params.meetingID);\n      if (StringUtils.isEmpty(params.meetingID)) {\n        invalid(\"missingParamMeetingID\", \"You must specify a meeting ID for the meeting.\");\n        return\n      }\n    } else {\n      invalid(\"missingParamMeetingID\", \"You must specify a meeting ID for the meeting.\");\n      return\n    }\n\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n    // END - backward compatibility\n\n    ApiErrors errors = new ApiErrors();\n    paramsProcessorUtil.processRequiredCreateParams(params, errors);\n\n    if (errors.hasErrors()) {\n      respondWithErrors(errors)\n      return\n    }\n\n    // Do we agree with the checksum? If not, complain.\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      errors.checksumError()\n      respondWithErrors(errors)\n      return\n    }\n\n    Meeting newMeeting = paramsProcessorUtil.processCreateParams(params)\n\n    if (meetingService.createMeeting(newMeeting)) {\n      // See if the request came with pre-uploading of presentation.\n      uploadDocuments(newMeeting);  //\n      respondWithConference(newMeeting, null, null)\n    } else {\n      // Translate the external meeting id into an internal meeting id.\n      String internalMeetingId = paramsProcessorUtil.convertToInternalMeetingId(params.meetingID);\n      Meeting existing = meetingService.getNotEndedMeetingWithId(internalMeetingId);\n      if (existing != null) {\n        log.debug \"Existing conference found\"\n        Map<String, Object> updateParams = paramsProcessorUtil.processUpdateCreateParams(params);\n        if (existing.getViewerPassword().equals(params.get(\"attendeePW\")) && existing.getModeratorPassword().equals(params.get(\"moderatorPW\"))) {\n          //paramsProcessorUtil.updateMeeting(updateParams, existing);\n          // trying to create a conference a second time, return success, but give extra info\n          // Ignore pre-uploaded presentations. We only allow uploading of presentation once.\n          //uploadDocuments(existing);\n          respondWithConference(existing, \"duplicateWarning\", \"This conference was already in existence and may currently be in progress.\");\n        } else {\n          // BEGIN - backward compatibility\n          invalid(\"idNotUnique\", \"A meeting already exists with that meeting ID.  Please use a different meeting ID.\");\n          return\n          // END - backward compatibility\n\n          // enforce meetingID unique-ness\n          errors.nonUniqueMeetingIdError()\n          respondWithErrors(errors)\n        }\n\n        return\n      }\n    }\n  }\n\n\n  /**********************************************\n   * JOIN API\n   *********************************************/\n  def join = {\n    String API_CALL = 'join'\n    log.debug CONTROLLER_NAME + \"#${API_CALL}\"\n    ApiErrors errors = new ApiErrors()\n\n    // BEGIN - backward compatibility\n    if (StringUtils.isEmpty(params.checksum)) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\", REDIRECT_RESPONSE)\n      return\n    }\n\n    //checking for an empty username or for a username containing whitespaces only\n    if (!StringUtils.isEmpty(params.fullName)) {\n      params.fullName = StringUtils.strip(params.fullName);\n      if (StringUtils.isEmpty(params.fullName)) {\n        invalid(\"missingParamFullName\", \"You must specify a name for the attendee who will be joining the meeting.\", REDIRECT_RESPONSE);\n        return\n      }\n    } else {\n      invalid(\"missingParamFullName\", \"You must specify a name for the attendee who will be joining the meeting.\", REDIRECT_RESPONSE);\n      return\n    }\n\n    if (!StringUtils.isEmpty(params.meetingID)) {\n      params.meetingID = StringUtils.strip(params.meetingID);\n      if (StringUtils.isEmpty(params.meetingID)) {\n        invalid(\"missingParamMeetingID\", \"You must specify a meeting ID for the meeting.\", REDIRECT_RESPONSE)\n        return\n      }\n    } else {\n      invalid(\"missingParamMeetingID\", \"You must specify a meeting ID for the meeting.\", REDIRECT_RESPONSE)\n      return\n    }\n\n    if (StringUtils.isEmpty(params.password)) {\n      invalid(\"invalidPassword\", \"You either did not supply a password or the password supplied is neither the attendee or moderator password for this conference.\", REDIRECT_RESPONSE);\n      return\n    }\n\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\", REDIRECT_RESPONSE)\n      return\n    }\n\n    // END - backward compatibility\n\n    // Do we have a checksum? If none, complain.\n    if (StringUtils.isEmpty(params.checksum)) {\n      errors.missingParamError(\"checksum\");\n    }\n\n    Boolean authenticated = false;\n\n    Boolean guest = false;\n    if (!StringUtils.isEmpty(params.guest)) {\n      guest = Boolean.parseBoolean(params.guest)\n    } else {\n      // guest param has not been passed. Make user as\n      // authenticated by default. (ralam july 3, 2018)\n      authenticated = true\n    }\n\n\n    if (!StringUtils.isEmpty(params.auth)) {\n      authenticated = Boolean.parseBoolean(params.auth)\n    }\n\n    Boolean joinViaHtml5 = false;\n    if (!StringUtils.isEmpty(params.joinViaHtml5)) {\n      joinViaHtml5 = Boolean.parseBoolean(params.joinViaHtml5)\n    }\n\n    // Do we have a name for the user joining? If none, complain.\n    if (!StringUtils.isEmpty(params.fullName)) {\n      params.fullName = StringUtils.strip(params.fullName);\n      if (StringUtils.isEmpty(params.fullName)) {\n        errors.missingParamError(\"fullName\");\n      }\n    } else {\n      errors.missingParamError(\"fullName\");\n    }\n    String fullName = ParamsUtil.stripHTMLTags(params.fullName)\n\n    // Do we have a meeting id? If none, complain.\n    if (!StringUtils.isEmpty(params.meetingID)) {\n      params.meetingID = StringUtils.strip(params.meetingID);\n      if (StringUtils.isEmpty(params.meetingID)) {\n        errors.missingParamError(\"meetingID\");\n      }\n    } else {\n      errors.missingParamError(\"meetingID\");\n    }\n    String externalMeetingId = params.meetingID\n\n    // Do we have a password? If not, complain.\n    String attPW = params.password\n    if (StringUtils.isEmpty(attPW)) {\n      errors.missingParamError(\"password\");\n    }\n\n    // Do we agree on the checksum? If not, complain.\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      errors.checksumError()\n    }\n\n    if (errors.hasErrors()) {\n      respondWithErrors(errors, REDIRECT_RESPONSE)\n      return\n    }\n\n    // Everything is good so far. Translate the external meeting id to an internal meeting id. If\n    // we can't find the meeting, complain.\n    String internalMeetingId = paramsProcessorUtil.convertToInternalMeetingId(externalMeetingId);\n\n    log.info(\"Retrieving meeting ${internalMeetingId}\")\n    Meeting meeting = meetingService.getMeeting(internalMeetingId);\n    if (meeting == null) {\n      // BEGIN - backward compatibility\n      invalid(\"invalidMeetingIdentifier\", \"The meeting ID that you supplied did not match any existing meetings\", REDIRECT_RESPONSE);\n      return\n      // END - backward compatibility\n\n      errors.invalidMeetingIdError();\n      respondWithErrors(errors, REDIRECT_RESPONSE)\n      return\n    }\n\n    // the createTime mismatch with meeting's createTime, complain\n    // In the future, the createTime param will be required\n    if (params.createTime != null) {\n      long createTime = 0;\n      try {\n        createTime = Long.parseLong(params.createTime);\n      } catch (Exception e) {\n        log.warn(\"could not parse createTime param\");\n        createTime = -1;\n      }\n      if (createTime != meeting.getCreateTime()) {\n        // BEGIN - backward compatibility\n        invalid(\"mismatchCreateTimeParam\", \"The createTime parameter submitted mismatches with the current meeting.\", REDIRECT_RESPONSE);\n        return\n        // END - backward compatibility\n\n        errors.mismatchCreateTimeParam();\n        respondWithErrors(errors, REDIRECT_RESPONSE);\n        return\n      }\n    }\n\n    // Is this user joining a meeting that has been ended. If so, complain.\n    if (meeting.isForciblyEnded()) {\n      // BEGIN - backward compatibility\n      invalid(\"meetingForciblyEnded\", \"You can not re-join a meeting that has already been forcibly ended.  However, once the meeting is removed from memory (according to the timeout configured on this server, you will be able to once again create a meeting with the same meeting ID\", REDIRECT_RESPONSE);\n      return\n      // END - backward compatibility\n\n      errors.meetingForciblyEndedError();\n      respondWithErrors(errors, REDIRECT_RESPONSE)\n      return\n    }\n\n    // Now determine if this user is a moderator or a viewer.\n    String role = null;\n    if (meeting.getModeratorPassword().equals(attPW)) {\n      role = Meeting.ROLE_MODERATOR\n    } else if (meeting.getViewerPassword().equals(attPW)) {\n      role = Meeting.ROLE_ATTENDEE\n    }\n\n    if (role == null) {\n      // BEGIN - backward compatibility\n      invalid(\"invalidPassword\", \"You either did not supply a password or the password supplied is neither the attendee or moderator password for this conference.\", REDIRECT_RESPONSE);\n      return\n      // END - backward compatibility\n\n      errors.invalidPasswordError()\n      respondWithErrors(errors, REDIRECT_RESPONSE)\n      return\n    }\n\n    // We preprend \"w_\" to our internal meeting Id to indicate that this is a web user.\n    // For users joining using the phone, we will prepend \"v_\" so it will be easier\n    // to distinguish users who doesn't have a web client. (ralam june 12, 2017)\n    String internalUserID = \"w_\" + RandomStringUtils.randomAlphanumeric(12).toLowerCase()\n\n    String authToken = RandomStringUtils.randomAlphanumeric(12).toLowerCase()\n\n    String sessionToken = RandomStringUtils.randomAlphanumeric(16).toLowerCase()\n\n    String externUserID = params.userID\n    if (StringUtils.isEmpty(externUserID)) {\n      externUserID = internalUserID\n    }\n\n    //Return a Map with the user custom data\n    Map<String, String> userCustomData = paramsProcessorUtil.getUserCustomData(params);\n\n    //Currently, it's associated with the externalUserID\n    if (userCustomData.size() > 0)\n      meetingService.addUserCustomData(meeting.getInternalId(), externUserID, userCustomData);\n\n    String configxml = null;\n\n    if (!StringUtils.isEmpty(params.configToken)) {\n      Config conf = meeting.getConfig(params.configToken);\n      if (conf == null) {\n        // Check if this config is one of our pre-built config\n        configxml = configService.getConfig(params.configToken)\n        if (configxml == null) {\n          // BEGIN - backward compatibility\n          invalid(\"noConfigFound\", \"We could not find a config for this request.\", REDIRECT_RESPONSE);\n          return\n          // END - backward compatibility\n\n          errors.noConfigFound();\n          respondWithErrors(errors);\n        }\n      } else {\n        configxml = conf.config;\n      }\n    } else {\n      Config conf = meeting.getDefaultConfig();\n      configxml = conf.config;\n    }\n\n    // Do not fail if there's no default config.xml, needed for an HTML5 client only scenario\n\n    String guestStatusVal = meeting.calcGuestStatus(role, guest, authenticated)\n\n    UserSession us = new UserSession();\n    us.authToken = authToken;\n    us.internalUserId = internalUserID\n    us.conferencename = meeting.getName()\n    us.meetingID = meeting.getInternalId()\n    us.externMeetingID = meeting.getExternalId()\n    us.externUserID = externUserID\n    us.fullname = fullName\n    us.role = role\n    us.conference = meeting.getInternalId()\n    us.room = meeting.getInternalId()\n    us.voicebridge = meeting.getTelVoice()\n    us.webvoiceconf = meeting.getWebVoice()\n    us.mode = \"LIVE\"\n    us.record = meeting.isRecord()\n    us.welcome = meeting.getWelcomeMessage()\n    us.guest = guest\n    us.authed = authenticated\n    us.guestStatus = guestStatusVal\n    us.logoutUrl = meeting.getLogoutUrl()\n    us.configXML = configxml;\n\n    if (!StringUtils.isEmpty(params.defaultLayout)) {\n      us.defaultLayout = params.defaultLayout;\n    }\n\n    if (!StringUtils.isEmpty(params.avatarURL)) {\n      us.avatarURL = params.avatarURL;\n    } else {\n      us.avatarURL = meeting.defaultAvatarURL\n    }\n\n    String meetingId = meeting.getInternalId()\n\n    if (hasReachedMaxParticipants(meeting, us)) {\n      // BEGIN - backward compatibility\n      invalid(\"maxParticipantsReached\", \"The number of participants allowed for this meeting has been reached.\", REDIRECT_RESPONSE);\n      return\n      // END - backward compatibility\n\n      errors.maxParticipantsReached();\n      respondWithErrors(errors, REDIRECT_RESPONSE);\n      return;\n    }\n\n    // Register user into the meeting.\n    meetingService.registerUser(\n        us.meetingID,\n        us.internalUserId,\n        us.fullname,\n        us.role,\n        us.externUserID,\n        us.authToken,\n        us.avatarURL,\n        us.guest,\n        us.authed,\n        guestStatusVal\n    )\n\n    //Identify which of these to logs should be used. sessionToken or user-token\n    log.info(\"Session sessionToken for \" + us.fullname + \" [\" + session[sessionToken] + \"]\")\n    log.info(\"Session user-token for \" + us.fullname + \" [\" + session['user-token'] + \"]\")\n    session.setMaxInactiveInterval(SESSION_TIMEOUT);\n\n    //check if exists the param redirect\n    boolean redirectClient = true;\n    String clientURL = paramsProcessorUtil.getDefaultClientUrl();\n\n    // server-wide configuration:\n    // Depending on configuration, prefer the HTML5 client over Flash for moderators\n    if (paramsProcessorUtil.getModeratorsJoinViaHTML5Client() && role == ROLE_MODERATOR) {\n      joinViaHtml5 = true\n    }\n\n    // Depending on configuration, prefer the HTML5 client over Flash for attendees\n    if (paramsProcessorUtil.getAttendeesJoinViaHTML5Client() && role == ROLE_ATTENDEE) {\n      joinViaHtml5 = true\n    }\n\n    // single client join configuration:\n    // Depending on configuration, prefer the HTML5 client over Flash client\n    if (joinViaHtml5) {\n      clientURL = paramsProcessorUtil.getHTML5ClientUrl();\n    } else {\n      if (!StringUtils.isEmpty(params.clientURL)) {\n        clientURL = params.clientURL;\n      }\n    }\n\n    if (!StringUtils.isEmpty(params.redirect)) {\n      try {\n        redirectClient = Boolean.parseBoolean(params.redirect);\n      } catch (Exception e) {\n        redirectClient = true;\n      }\n    }\n\n    String msgKey = \"successfullyJoined\"\n    String msgValue = \"You have joined successfully.\"\n\n    // Keep track of the client url in case this needs to wait for\n    // approval as guest. We need to be able to send the user to the\n    // client after being approved by moderator.\n    us.clientUrl = clientURL + \"?sessionToken=\" + sessionToken\n\n    session[sessionToken] = sessionToken\n    meetingService.addUserSession(sessionToken, us);\n\n    // Process if we send the user directly to the client or\n    // have it wait for approval.\n    String destUrl = clientURL + \"?sessionToken=\" + sessionToken\n    if (guestStatusVal.equals(GuestPolicy.WAIT)) {\n      String guestWaitUrl = paramsProcessorUtil.getDefaultGuestWaitURL();\n      destUrl = guestWaitUrl + \"?sessionToken=\" + sessionToken\n      msgKey = \"guestWait\"\n      msgValue = \"Guest waiting for approval to join meeting.\"\n    } else if (guestStatusVal.equals(GuestPolicy.DENY)) {\n      destUrl = meeting.getLogoutUrl()\n      msgKey = \"guestDeny\"\n      msgValue = \"Guest denied to join meeting.\"\n    }\n\n    Map<String, Object> logData = new HashMap<String, Object>();\n    logData.put(\"meetingid\", us.meetingID);\n    logData.put(\"extMeetingid\", us.externMeetingID);\n    logData.put(\"name\", us.fullname);\n    logData.put(\"userid\", us.internalUserId);\n    logData.put(\"sessionToken\", sessionToken);\n    logData.put(\"logCode\", \"join_api\");\n    logData.put(\"description\", \"Handle JOIN API.\");\n\n    Gson gson = new Gson();\n    String logStr = gson.toJson(logData);\n\n    log.info(\" --analytics-- data=\" + logStr);\n\n    if (redirectClient) {\n      log.info(\"Redirecting to ${destUrl}\");\n      redirect(url: destUrl);\n    } else {\n      log.info(\"Successfully joined. Sending XML response.\");\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n      withFormat {\n        xml {\n          render(text: responseBuilder.buildJoinMeeting(us, session[sessionToken], guestStatusVal, destUrl, msgKey, msgValue, RESP_CODE_SUCCESS), contentType: \"text/xml\")\n        }\n      }\n    }\n  }\n\n  /*******************************************\n   * IS_MEETING_RUNNING API\n   *******************************************/\n  def isMeetingRunning = {\n    String API_CALL = 'isMeetingRunning'\n    log.debug CONTROLLER_NAME + \"#${API_CALL}\"\n\n    // BEGIN - backward compatibility\n    if (StringUtils.isEmpty(params.checksum)) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n\n    if (!StringUtils.isEmpty(params.meetingID)) {\n      params.meetingID = StringUtils.strip(params.meetingID);\n      if (StringUtils.isEmpty(params.meetingID)) {\n        invalid(\"missingParamMeetingID\", \"You must specify a meeting ID for the meeting.\");\n        return\n      }\n    } else {\n      invalid(\"missingParamMeetingID\", \"You must specify a meeting ID for the meeting.\");\n      return\n    }\n\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n    // END - backward compatibility\n\n    ApiErrors errors = new ApiErrors()\n\n    // Do we have a checksum? If none, complain.\n    if (StringUtils.isEmpty(params.checksum)) {\n      errors.missingParamError(\"checksum\");\n    }\n\n    // Do we have a meeting id? If none, complain.\n    if (!StringUtils.isEmpty(params.meetingID)) {\n      params.meetingID = StringUtils.strip(params.meetingID);\n      if (StringUtils.isEmpty(params.meetingID)) {\n        errors.missingParamError(\"meetingID\");\n      }\n    } else {\n      errors.missingParamError(\"meetingID\");\n    }\n    String externalMeetingId = params.meetingID\n\n\n    if (errors.hasErrors()) {\n      respondWithErrors(errors)\n      return\n    }\n\n    // Do we agree on the checksum? If not, complain.\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      errors.checksumError()\n      respondWithErrors(errors)\n      return\n    }\n\n    // Everything is good so far. Translate the external meeting id to an internal meeting id. If\n    // we can't find the meeting, complain.\n    String internalMeetingId = paramsProcessorUtil.convertToInternalMeetingId(externalMeetingId);\n    log.info(\"Retrieving meeting ${internalMeetingId}\")\n    Meeting meeting = meetingService.getMeeting(internalMeetingId);\n    boolean isRunning = meeting != null && meeting.isRunning();\n\n    response.addHeader(\"Cache-Control\", \"no-cache\")\n    withFormat {\n      xml {\n        render(contentType: \"text/xml\") {\n          render(text: responseBuilder.buildIsMeetingRunning(isRunning, RESP_CODE_SUCCESS), contentType: \"text/xml\")\n        }\n      }\n    }\n  }\n\n  /************************************\n   * END API\n   ************************************/\n  def end = {\n    String API_CALL = \"end\"\n\n    log.debug CONTROLLER_NAME + \"#${API_CALL}\"\n\n    // BEGIN - backward compatibility\n    if (StringUtils.isEmpty(params.checksum)) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n\n    if (!StringUtils.isEmpty(params.meetingID)) {\n      params.meetingID = StringUtils.strip(params.meetingID);\n      if (StringUtils.isEmpty(params.meetingID)) {\n        invalid(\"missingParamMeetingID\", \"You must specify a meeting ID for the meeting.\");\n        return\n      }\n    } else {\n      invalid(\"missingParamMeetingID\", \"You must specify a meeting ID for the meeting.\");\n      return\n    }\n\n    if (StringUtils.isEmpty(params.password)) {\n      invalid(\"invalidPassword\", \"You must supply the moderator password for this call.\");\n      return\n    }\n\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n    // END - backward compatibility\n\n    ApiErrors errors = new ApiErrors()\n\n    // Do we have a checksum? If none, complain.\n    if (StringUtils.isEmpty(params.checksum)) {\n      errors.missingParamError(\"checksum\");\n    }\n\n    // Do we have a meeting id? If none, complain.\n    if (!StringUtils.isEmpty(params.meetingID)) {\n      params.meetingID = StringUtils.strip(params.meetingID);\n      if (StringUtils.isEmpty(params.meetingID)) {\n        errors.missingParamError(\"meetingID\");\n      }\n    } else {\n      errors.missingParamError(\"meetingID\");\n    }\n    String externalMeetingId = params.meetingID\n\n    // Do we have a password? If not, complain.\n    String modPW = params.password\n    if (StringUtils.isEmpty(modPW)) {\n      errors.missingParamError(\"password\");\n    }\n\n    if (errors.hasErrors()) {\n      respondWithErrors(errors)\n      return\n    }\n\n    // Do we agree on the checksum? If not, complain.\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      errors.checksumError()\n      respondWithErrors(errors)\n      return\n    }\n\n    // Everything is good so far. Translate the external meeting id to an internal meeting id. If\n    // we can't find the meeting, complain.\n    String internalMeetingId = paramsProcessorUtil.convertToInternalMeetingId(externalMeetingId);\n    log.info(\"Retrieving meeting ${internalMeetingId}\")\n    Meeting meeting = meetingService.getMeeting(internalMeetingId);\n    if (meeting == null) {\n      // BEGIN - backward compatibility\n      invalid(\"notFound\", \"We could not find a meeting with that meeting ID - perhaps the meeting is not yet running?\");\n      return;\n      // END - backward compatibility\n\n      errors.invalidMeetingIdError();\n      respondWithErrors(errors)\n      return;\n    }\n\n    if (meeting.getModeratorPassword().equals(modPW) == false) {\n      // BEGIN - backward compatibility\n      invalid(\"invalidPassword\", \"You must supply the moderator password for this call.\");\n      return;\n      // END - backward compatibility\n\n      errors.invalidPasswordError();\n      respondWithErrors(errors)\n      return;\n    }\n\n    Map<String, Object> logData = new HashMap<String, Object>();\n    logData.put(\"meetingid\", meeting.getInternalId());\n    logData.put(\"extMeetingid\", meeting.getExternalId());\n    logData.put(\"name\", meeting.getName());\n    logData.put(\"logCode\", \"end_api\");\n    logData.put(\"description\", \"Handle END API.\");\n\n    Gson gson = new Gson();\n    String logStr = gson.toJson(logData);\n\n    log.info(\" --analytics-- data=\" + logStr);\n\n    meetingService.endMeeting(meeting.getInternalId());\n\n    response.addHeader(\"Cache-Control\", \"no-cache\")\n    withFormat {\n      xml {\n        render(contentType: \"text/xml\") {\n          render(text: responseBuilder.buildEndRunning(\"sentEndMeetingRequest\", \"A request to end the meeting was sent.  Please wait a few seconds, and then use the getMeetingInfo or isMeetingRunning API calls to verify that it was ended.\", RESP_CODE_SUCCESS), contentType: \"text/xml\")\n        }\n      }\n    }\n  }\n\n  /*****************************************\n   * GETMEETINGINFO API\n   *****************************************/\n  def getMeetingInfo = {\n    String API_CALL = \"getMeetingInfo\"\n    log.debug CONTROLLER_NAME + \"#${API_CALL}\"\n\n    // BEGIN - backward compatibility\n    if (StringUtils.isEmpty(params.checksum)) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n\n    if (!StringUtils.isEmpty(params.meetingID)) {\n      params.meetingID = StringUtils.strip(params.meetingID);\n      if (StringUtils.isEmpty(params.meetingID)) {\n        invalid(\"missingParamMeetingID\", \"You must specify a meeting ID for the meeting.\");\n        return\n      }\n    } else {\n      invalid(\"missingParamMeetingID\", \"You must specify a meeting ID for the meeting.\");\n      return\n    }\n\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n    // END - backward compatibility\n\n    ApiErrors errors = new ApiErrors()\n\n    // Do we have a checksum? If none, complain.\n    if (StringUtils.isEmpty(params.checksum)) {\n      errors.missingParamError(\"checksum\");\n    }\n\n    // Do we have a meeting id? If none, complain.\n    if (!StringUtils.isEmpty(params.meetingID)) {\n      params.meetingID = StringUtils.strip(params.meetingID);\n      if (StringUtils.isEmpty(params.meetingID)) {\n        errors.missingParamError(\"meetingID\");\n      }\n    } else {\n      errors.missingParamError(\"meetingID\");\n    }\n    String externalMeetingId = params.meetingID\n\n    if (errors.hasErrors()) {\n      respondWithErrors(errors)\n      return\n    }\n\n    // Do we agree on the checksum? If not, complain.\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      errors.checksumError()\n      respondWithErrors(errors)\n      return\n    }\n\n    // Everything is good so far. Translate the external meeting id to an internal meeting id. If\n    // we can't find the meeting, complain.\n    String internalMeetingId = paramsProcessorUtil.convertToInternalMeetingId(externalMeetingId);\n    log.info(\"Retrieving meeting ${internalMeetingId}\")\n    Meeting meeting = meetingService.getMeeting(internalMeetingId);\n    if (meeting == null) {\n      // BEGIN - backward compatibility\n      invalid(\"notFound\", \"We could not find a meeting with that meeting ID\");\n      return;\n      // END - backward compatibility\n\n      errors.invalidMeetingIdError();\n      respondWithErrors(errors)\n      return;\n    }\n\n    withFormat {\n      xml {\n        render(text: responseBuilder.buildGetMeetingInfoResponse(meeting, RESP_CODE_SUCCESS), contentType: \"text/xml\")\n      }\n    }\n  }\n\n  /************************************\n   *  GETMEETINGS API\n   ************************************/\n  def getMeetingsHandler = {\n    String API_CALL = \"getMeetings\"\n    log.debug CONTROLLER_NAME + \"#${API_CALL}\"\n\n    // BEGIN - backward compatibility\n    if (StringUtils.isEmpty(params.checksum)) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n    // END - backward compatibility\n\n    ApiErrors errors = new ApiErrors()\n\n    // Do we have a checksum? If none, complain.\n    if (StringUtils.isEmpty(params.checksum)) {\n      errors.missingParamError(\"checksum\");\n    }\n\n    if (errors.hasErrors()) {\n      respondWithErrors(errors)\n      return\n    }\n\n    // Do we agree on the checksum? If not, complain.\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      errors.checksumError()\n      respondWithErrors(errors)\n      return\n    }\n\n    Collection<Meeting> mtgs = meetingService.getMeetings();\n\n    if (mtgs == null || mtgs.isEmpty()) {\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n      withFormat {\n        xml {\n          render(text: responseBuilder.buildGetMeetingsResponse(mtgs, \"noMeetings\", \"no meetings were found on this server\", RESP_CODE_SUCCESS), contentType: \"text/xml\")\n        }\n      }\n    } else {\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n\n      withFormat {\n        xml {\n          render(text: responseBuilder.buildGetMeetingsResponse(mtgs, null, null, RESP_CODE_SUCCESS), contentType: \"text/xml\")\n        }\n      }\n    }\n  }\n\n  /************************************\n   *  GETSESSIONS API\n   ************************************/\n  def getSessionsHandler = {\n    String API_CALL = \"getSessions\"\n    log.debug CONTROLLER_NAME + \"#${API_CALL}\"\n\n    // BEGIN - backward compatibility\n    if (StringUtils.isEmpty(params.checksum)) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n    // END - backward compatibility\n\n    ApiErrors errors = new ApiErrors()\n\n    // Do we have a checksum? If none, complain.\n    if (StringUtils.isEmpty(params.checksum)) {\n      errors.missingParamError(\"checksum\");\n    }\n\n    if (errors.hasErrors()) {\n      respondWithErrors(errors)\n      return\n    }\n\n    // Do we agree on the checksum? If not, complain.\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      errors.checksumError()\n      respondWithErrors(errors)\n      return\n    }\n\n    Collection<UserSession> sssns = meetingService.getSessions();\n\n    if (sssns == null || sssns.isEmpty()) {\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n      withFormat {\n        xml {\n          render(text: responseBuilder.buildGetSessionsResponse(sssns, \"noSessions\", \"no sessions were found on this serverr\", RESP_CODE_SUCCESS), contentType: \"text/xml\")\n        }\n      }\n    } else {\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n      withFormat {\n        xml {\n          render(contentType: \"text/xml\") {\n            render(text: responseBuilder.buildGetSessionsResponse(sssns, null, null, RESP_CODE_SUCCESS), contentType: \"text/xml\")\n          }\n        }\n      }\n    }\n  }\n\n\n  private static Map<String, String[]> getParameters(ServletRequest request) {\n    // Copy the parameters into our own Map as we can't pass the paramMap\n    // from the request as it's an unmodifiable map.\n    Map<String, String[]> reqParams = new HashMap<String, String[]>();\n    Map<String, String[]> unModReqParams = request.getParameterMap();\n\n    SortedSet<String> keys = new TreeSet<String>(unModReqParams.keySet());\n\n    for(String key : keys) {\n      reqParams.put(key, unModReqParams.get(key));\n    }\n\n    return reqParams;\n  }\n\n  /***********************************************\n   * POLL API\n   ***********************************************/\n  def setPollXML = {\n    String API_CALL = \"setPollXML\"\n    log.debug CONTROLLER_NAME + \"#${API_CALL}\"\n\n    if (StringUtils.isEmpty(params.checksum)) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n\n    if (StringUtils.isEmpty(params.pollXML)) {\n      invalid(\"configXMLError\", \"You did not pass a poll XML\")\n      return\n    }\n\n    if (!StringUtils.isEmpty(params.meetingID)) {\n      params.meetingID = StringUtils.strip(params.meetingID);\n      if (StringUtils.isEmpty(params.meetingID)) {\n        invalid(\"missingParamMeetingID\", \"You must specify a meeting ID for the meeting.\");\n        return\n      }\n    } else {\n      invalid(\"missingParamMeetingID\", \"You must specify a meeting ID for the meeting.\");\n      return\n    }\n\n    // Translate the external meeting id into an internal meeting id.\n    String internalMeetingId = paramsProcessorUtil.convertToInternalMeetingId(params.meetingID);\n    Meeting meeting = meetingService.getMeeting(internalMeetingId);\n    if (meeting == null) {\n      // BEGIN - backward compatibility\n      invalid(\"invalidMeetingIdentifier\", \"The meeting ID that you supplied did not match any existing meetings\");\n      return;\n      // END - backward compatibility\n    }\n\n    Map<String, String[]> reqParams = getParameters(request)\n\n    String pollXML = params.pollXML\n\n    String decodedPollXML;\n\n    try {\n      decodedPollXML = URLDecoder.decode(pollXML, \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      log.error \"Couldn't decode poll XML.\", e\n      invalid(\"pollXMLError\", \"Cannot decode poll XML\")\n      return;\n    }\n\n    if (!paramsProcessorUtil.isPostChecksumSame(API_CALL, reqParams)) {\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n      withFormat {\n        xml {\n          invalid(\"pollXMLChecksumError\", \"pollXMLChecksumError: request did not pass the checksum security check.\")\n        }\n      }\n    } else {\n      def pollxml = new XmlSlurper().parseText(decodedPollXML);\n\n      pollxml.children().each { poll ->\n        String title = poll.title.text();\n        String question = poll.question.text();\n        String questionType = poll.questionType.text();\n\n        ArrayList<String> answers = new ArrayList<String>();\n        poll.answers.children().each { answer ->\n          answers.add(answer.text());\n        }\n\n        //send poll to BigBlueButton Apps\n        meetingService.createdPolls(meeting.getInternalId(), title, question, questionType, answers);\n      }\n\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n      withFormat {\n        xml {\n          // No need to use the response builder here until we have a more complex response\n          render(text: \"<response><returncode>$RESP_CODE_SUCCESS</returncode></response>\", contentType: \"text/xml\")\n        }\n      }\n    }\n  }\n\n  /***********************************************\n   * CONFIG API\n   ***********************************************/\n  def setConfigXML = {\n    String API_CALL = \"setConfigXML\"\n    log.debug CONTROLLER_NAME + \"#${API_CALL}\"\n\n    if (StringUtils.isEmpty(params.checksum)) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n\n    if (StringUtils.isEmpty(params.configXML)) {\n      invalid(\"configXMLError\", \"You did not pass a config XML\")\n      return\n    }\n\n    if (!StringUtils.isEmpty(params.meetingID)) {\n      params.meetingID = StringUtils.strip(params.meetingID);\n      if (StringUtils.isEmpty(params.meetingID)) {\n        invalid(\"missingParamMeetingID\", \"You must specify a meeting ID for the meeting.\");\n        return\n      }\n    } else {\n      invalid(\"missingParamMeetingID\", \"You must specify a meeting ID for the meeting.\");\n      return\n    }\n\n    // Translate the external meeting id into an internal meeting id.\n    String internalMeetingId = paramsProcessorUtil.convertToInternalMeetingId(params.meetingID);\n    Meeting meeting = meetingService.getMeeting(internalMeetingId);\n    if (meeting == null) {\n      // BEGIN - backward compatibility\n      invalid(\"invalidMeetingIdentifier\", \"The meeting ID that you supplied did not match any existing meetings\");\n      return;\n      // END - backward compatibility\n    }\n\n    Map<String, String[]> reqParams = getParameters(request)\n\n    String configXML = params.configXML\n\n    String decodedConfigXML;\n\n    try {\n      decodedConfigXML = URLDecoder.decode(configXML, \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      log.error(\"Couldn't decode config XML.\");\n      invalid(\"configXMLError\", \"Cannot decode config XML\")\n      return;\n    }\n\n    if (!paramsProcessorUtil.isPostChecksumSame(API_CALL, reqParams)) {\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n      withFormat {\n        xml {\n          invalid(\"configXMLChecksumError\", \"configXMLChecksumError: request did not pass the checksum security check.\")\n        }\n      }\n    } else {\n      boolean defaultConfig = false;\n\n      if (!StringUtils.isEmpty(params.defaultConfig)) {\n        try {\n          defaultConfig = Boolean.parseBoolean(params.defaultConfig);\n        } catch (Exception e) {\n          defaultConfig = false;\n        }\n      }\n\n      String token = meeting.storeConfig(defaultConfig, decodedConfigXML);\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n      withFormat {\n        xml {\n          // No need to use the response builder here until we have a more complex response\n          render(text: \"<response><returncode>$RESP_CODE_SUCCESS</returncode><configToken>$token</configToken></response>\", contentType: \"text/xml\")\n        }\n      }\n    }\n  }\n\n  def getDefaultConfigXML = {\n\n    String API_CALL = \"getDefaultConfigXML\"\n    ApiErrors errors = new ApiErrors();\n\n    // BEGIN - backward compatibility\n    if (StringUtils.isEmpty(params.checksum)) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n    // END - backward compatibility\n\n\n    // Do we agree on the checksum? If not, complain.\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      errors.checksumError()\n      respondWithErrors(errors)\n      return\n    }\n\n    String defConfigXML = paramsProcessorUtil.getDefaultConfigXML();\n    if (StringUtils.isEmpty(defConfigXML)) {\n      // BEGIN - backward compatibility\n      invalid(\"noConfigFound\", \"We could not find a config for this request.\", REDIRECT_RESPONSE);\n      return\n      // END - backward compatibility\n\n      errors.noConfigFound();\n      respondWithErrors(errors);\n    }\n\n    response.addHeader(\"Cache-Control\", \"no-cache\")\n    render text: defConfigXML, contentType: 'text/xml'\n  }\n\n  def configXML = {\n    String API_CALL = 'configXML'\n    log.debug CONTROLLER_NAME + \"#${API_CALL}\"\n\n    String logoutUrl = paramsProcessorUtil.getDefaultLogoutUrl()\n    boolean reject = false\n    String sessionToken = sanitizeSessionToken(params.sessionToken)\n    if (!hasValidSession(sessionToken)) {\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n      withFormat {\n        xml {\n          render(text: responseBuilder.buildConfgXmlReject(\"Could not find conference.\", logoutUrl, RESP_CODE_FAILED), contentType: \"text/xml\")\n        }\n      }\n    } else {\n      UserSession us = getUserSession(sessionToken)\n      if (StringUtils.isEmpty(us.configXML)) {\n        // BEGIN - backward compatibility\n        invalid(\"noConfigFound\", \"We could not find a config for this request.\", REDIRECT_RESPONSE);\n        return\n        // END - backward compatibility\n\n        errors.noConfigFound();\n        respondWithErrors(errors);\n      }\n\n      Map<String, Object> logData = new HashMap<String, Object>();\n      logData.put(\"meetingId\", us.meetingID);\n      logData.put(\"externalMeetingId\", us.externMeetingID);\n      logData.put(\"name\", us.fullname);\n      logData.put(\"userId\", us.internalUserId);\n      logData.put(\"sessionToken\", sessionToken);\n      logData.put(\"logCode\", \"handle_configxml_api\");\n      logData.put(\"description\", \"Handling ConfigXml API.\");\n\n      Gson gson = new Gson();\n      String logStr = gson.toJson(logData);\n\n      log.info(\" --analytics-- data=\" + logStr);\n\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n      render text: us.configXML, contentType: 'text/xml'\n    }\n  }\n\n  /**********************************************\n   * GUEST WAIT API\n   *********************************************/\n  def guestWaitHandler = {\n    String API_CALL = 'guestWait'\n    log.debug CONTROLLER_NAME + \"#${API_CALL}\"\n    ApiErrors errors = new ApiErrors()\n    boolean reject = false;\n    String sessionToken = sanitizeSessionToken(params.sessionToken)\n\n    UserSession us = getUserSession(sessionToken);\n    Meeting meeting = null;\n\n    if (us == null) {\n      log.debug(\"No user with session token.\")\n      reject = true;\n    } else {\n      meeting = meetingService.getMeeting(us.meetingID);\n      if (meeting == null || meeting.isForciblyEnded()) {\n        log.debug(\"Meeting not found.\")\n        reject = true\n      }\n    }\n\n    // Determine the logout url so we can send the user there.\n    String logoutUrl = us != null ? us.logoutUrl : paramsProcessorUtil.getDefaultLogoutUrl()\n\n    if (reject) {\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n      withFormat {\n        json {\n          def builder = new JsonBuilder()\n          builder.response {\n            returncode RESP_CODE_FAILED\n            message \"Could not process waiting guest.\"\n            logoutURL logoutUrl\n          }\n          render(contentType: \"application/json\", text: builder.toPrettyString())\n        }\n      }\n    } else {\n      //check if exists the param redirect\n      boolean redirectClient = true;\n\n      // Get the client url we stored in the join api call before\n      // being told to wait.\n      String clientURL = us.clientUrl;\n      log.info(\"clientURL = \" + clientURL)\n      log.info(\"redirect = .\" + redirectClient)\n      if (!StringUtils.isEmpty(params.redirect)) {\n        try {\n          redirectClient = Boolean.parseBoolean(params.redirect);\n          log.info(\"redirect 2 = .\" + redirectClient)\n        } catch (Exception e) {\n          redirectClient = true;\n        }\n      }\n\n      // The client url is ovewriten. Let's allow it.\n      if (!StringUtils.isEmpty(params.clientURL)) {\n        clientURL = params.clientURL;\n      }\n\n      String guestWaitStatus = us.guestStatus\n\n      log.debug(\"GuestWaitStatus = \" + guestWaitStatus)\n\n      String msgKey = \"guestAllowed\"\n      String msgValue = \"Guest allowed to join meeting.\"\n\n      String destUrl = clientURL\n      log.debug(\"destUrl = \" + destUrl)\n\n\n      if (guestWaitStatus.equals(GuestPolicy.WAIT)) {\n        clientURL = paramsProcessorUtil.getDefaultGuestWaitURL();\n        destUrl = clientURL + \"?sessionToken=\" + sessionToken\n        log.debug(\"GuestPolicy.WAIT - destUrl = \" + destUrl)\n        msgKey = \"guestWait\"\n        msgValue = \"Guest waiting for approval to join meeting.\"\n        // We force the response to not do a redirect. Otherwise,\n        // the client would just be redirecting into this endpoint.\n        redirectClient = false\n\n        Map<String, Object> logData = new HashMap<String, Object>();\n        logData.put(\"meetingid\", us.meetingID);\n        logData.put(\"extMeetingid\", us.externMeetingID);\n        logData.put(\"name\", us.fullname);\n        logData.put(\"userid\", us.internalUserId);\n        logData.put(\"sessionToken\", sessionToken);\n        logData.put(\"logCode\", \"guest_wait\");\n        logData.put(\"description\", \"Guest waiting for approval.\");\n\n        Gson gson = new Gson();\n        String logStr = gson.toJson(logData);\n\n        log.info(\" --analytics-- data=\" + logStr);\n\n      } else if (guestWaitStatus.equals(GuestPolicy.DENY)) {\n        destUrl = meeting.getLogoutUrl()\n        msgKey = \"guestDenied\"\n        msgValue = \"Guest denied to join meeting.\"\n\n        Map<String, Object> logData = new HashMap<String, Object>();\n        logData.put(\"meetingid\", us.meetingID);\n        logData.put(\"extMeetingid\", us.externMeetingID);\n        logData.put(\"name\", us.fullname);\n        logData.put(\"userid\", us.internalUserId);\n        logData.put(\"sessionToken\", sessionToken);\n        logData.put(\"logCode\", \"guest_denied\");\n        logData.put(\"description\", \"Guest denied.\");\n\n        Gson gson = new Gson();\n        String logStr = gson.toJson(logData);\n\n        log.info(\" --analytics-- data=\" + logStr);\n      }\n\n      if (redirectClient) {\n        log.info(\"Redirecting to ${destUrl}\");\n        redirect(url: destUrl);\n      } else {\n        log.info(\"Successfully joined. Sending XML response.\");\n        response.addHeader(\"Cache-Control\", \"no-cache\")\n        withFormat {\n          json {\n            def builder = new JsonBuilder()\n            builder.response {\n              returncode RESP_CODE_SUCCESS\n              messageKey msgKey\n              message msgValue\n              meeting_id us.meetingID\n              user_id us.internalUserId\n              auth_token us.authToken\n              session_token session[sessionToken]\n              guestStatus guestWaitStatus\n              url destUrl\n            }\n            render(contentType: \"application/json\", text: builder.toPrettyString())\n          }\n        }\n      }\n    }\n  }\n\n  /***********************************************\n   * ENTER API\n   ***********************************************/\n  def enter = {\n    boolean reject = false;\n\n    String sessionToken = sanitizeSessionToken(params.sessionToken)\n    UserSession us = getUserSession(sessionToken);\n    Meeting meeting = null;\n\n    String respMessage = \"Session \" + sessionToken + \" not found.\"\n\n    if (!hasValidSession(sessionToken)) {\n      reject = true;\n    } else {\n      meeting = meetingService.getMeeting(us.meetingID);\n      if (meeting == null || meeting.isForciblyEnded()) {\n        reject = true\n        respMessage = \"Meeting not found or ended for session \" + sessionToken + \".\"\n      } else {\n        if (hasReachedMaxParticipants(meeting, us)) {\n          reject = true;\n          respMessage = \"The number of participants allowed for this meeting has been reached.\";\n        } else {\n          meeting.userEntered(us.internalUserId);\n        }\n      }\n      if (us.guestStatus.equals(GuestPolicy.DENY)) {\n        respMessage = \"User denied for user with session \" + sessionToken + \".\"\n        reject = true\n      }\n    }\n\n    if (reject) {\n      // Determine the logout url so we can send the user there.\n      String logoutUrl = paramsProcessorUtil.getDefaultLogoutUrl()\n\n      if (us != null) {\n        logoutUrl = us.logoutUrl\n      }\n\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n      withFormat {\n        json {\n          def builder = new JsonBuilder()\n          builder.response {\n            returncode RESP_CODE_FAILED\n            message respMessage\n            logoutURL logoutUrl\n          }\n          render(contentType: \"application/json\", text: builder.toPrettyString())\n        }\n      }\n    } else {\n\n      Map<String, String> userCustomData = paramsProcessorUtil.getUserCustomData(params);\n\n      // Generate a new userId for this user. This prevents old connections from\n      // removing the user when the user reconnects after being disconnected. (ralam jan 22, 2015)\n      // We use underscore (_) to associate userid with the user. We are also able to track\n      // how many times a user reconnects or refresh the browser.\n      String newInternalUserID = us.internalUserId //+ \"_\" + us.incrementConnectionNum()\n\n      Map<String, Object> logData = new HashMap<String, Object>();\n      logData.put(\"meetingid\", us.meetingID);\n      logData.put(\"extMeetingid\", us.externMeetingID);\n      logData.put(\"name\", us.fullname);\n      logData.put(\"userid\", newInternalUserID);\n      logData.put(\"sessionToken\", sessionToken);\n      logData.put(\"logCode\", \"handle_enter_api\");\n      logData.put(\"description\", \"Handling ENTER API.\");\n\n      Gson gson = new Gson();\n      String logStr = gson.toJson(logData);\n\n      log.info(\" --analytics-- data=\" + logStr);\n\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n      withFormat {\n        json {\n          def builder = new JsonBuilder()\n          builder.response {\n            returncode RESP_CODE_SUCCESS\n            fullname us.fullname\n            confname us.conferencename\n            meetingID us.meetingID\n            externMeetingID us.externMeetingID\n            externUserID us.externUserID\n            internalUserID newInternalUserID\n            authToken us.authToken\n            role us.role\n            guest us.guest\n            guestStatus us.guestStatus\n            conference us.conference\n            room us.room\n            voicebridge us.voicebridge\n            dialnumber meeting.getDialNumber()\n            webvoiceconf us.webvoiceconf\n            mode us.mode\n            record us.record\n            isBreakout meeting.isBreakout()\n            logoutTimer meeting.getLogoutTimer()\n            allowStartStopRecording meeting.getAllowStartStopRecording()\n            welcome us.welcome\n            if (!StringUtils.isEmpty(meeting.moderatorOnlyMessage) && us.role.equals(ROLE_MODERATOR)) {\n              modOnlyMessage meeting.moderatorOnlyMessage\n            }\n            if (!StringUtils.isEmpty(meeting.bannerText)) {\n              bannerText meeting.getBannerText()\n              bannerColor meeting.getBannerColor()\n            }\n            customLogoURL meeting.getCustomLogoURL()\n            customCopyright meeting.getCustomCopyright()\n            muteOnStart meeting.getMuteOnStart()\n            allowModsToUnmuteUsers meeting.getAllowModsToUnmuteUsers()\n            logoutUrl us.logoutUrl\n            defaultLayout us.defaultLayout\n            avatarURL us.avatarURL\n            if (meeting.breakoutRoomsParams != null) {\n              breakoutRooms {\n                enabled meeting.breakoutRoomsParams.enabled\n                record meeting.breakoutRoomsParams.record\n                privateChatEnabled meeting.breakoutRoomsParams.privateChatEnabled\n              }\n            }\n            customdata (\n              meeting.getUserCustomData(us.externUserID).collect { k, v ->\n                [\"$k\": v]\n              }\n            )\n            metadata (\n              meeting.getMetadata().collect { k, v ->\n                [\"$k\": v]\n              }\n            )\n          }\n          render(contentType: \"application/json\", text: builder.toPrettyString())\n        }\n      }\n    }\n  }\n\n  /***********************************************\n   * STUN/TURN API\n   ***********************************************/\n  def stuns = {\n    boolean reject = false;\n\n    String sessionToken = sanitizeSessionToken(params.sessionToken)\n    UserSession us = getUserSession(sessionToken);\n    Meeting meeting = null;\n\n    if (!hasValidSession(sessionToken)) {\n      reject = true;\n    } else {\n      meeting = meetingService.getMeeting(us.meetingID);\n      if (meeting == null || meeting.isForciblyEnded()) {\n        reject = true\n      }\n    }\n\n    if (reject) {\n      String logoutUrl = paramsProcessorUtil.getDefaultLogoutUrl()\n\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n      withFormat {\n        json {\n          def builder = new JsonBuilder()\n          builder {\n            returncode RESP_CODE_FAILED\n            message \"Could not find conference.\"\n            logoutURL logoutUrl\n          }\n          render(contentType: \"application/json\", text: builder.toPrettyString())\n        }\n      }\n    } else {\n      Set<StunServer> stuns = stunTurnService.getStunServers()\n      Set<TurnEntry> turns = stunTurnService.getStunAndTurnServersFor(us.internalUserId)\n      Set<RemoteIceCandidate> candidates = stunTurnService.getRemoteIceCandidates()\n\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n      withFormat {\n        json {\n          def builder = new JsonBuilder()\n          builder {\n            stunServers (\n              stuns.collect { stun ->\n                [url: stun.url]\n              }\n            )\n            turnServers (\n              turns.collect { turn ->\n                [\n                  username: turn.username,\n                  password: turn.password,\n                  url: turn.url,\n                  ttl: turn.ttl\n                ]\n              }\n            )\n            remoteIceCandidates (\n              candidates.collect { candidate ->\n                [ip: candidate.ip ]\n              }\n            )\n          }\n          render(contentType: \"application/json\", text: builder.toPrettyString())\n        }\n      }\n    }\n  }\n\n  /*************************************************\n   * SIGNOUT API\n   *************************************************/\n  def signOut = {\n\n    String sessionToken = sanitizeSessionToken(params.sessionToken)\n\n    Meeting meeting = null;\n\n    if (sessionToken != null) {\n\n      UserSession us = meetingService.removeUserSessionWithAuthToken(sessionToken);\n      if (us != null) {\n        Map<String, Object> logData = new HashMap<String, Object>();\n        logData.put(\"meetingid\", us.meetingID);\n        logData.put(\"extMeetingid\", us.externMeetingID);\n        logData.put(\"name\", us.fullname);\n        logData.put(\"userid\", us.internalUserId);\n        logData.put(\"sessionToken\", sessionToken);\n        logData.put(\"message\", \"handle_signout_api\");\n        logData.put(\"logCode\", \"signout_api\");\n        logData.put(\"description\", \"Handling SIGNOUT API.\");\n\n        Gson gson = new Gson();\n        String logStr = gson.toJson(logData);\n        log.info(\" --analytics-- data=\" + logStr);\n      } else {\n        log.info(\"Could not find user session for session token {}\", sessionToken)\n      }\n\n\n      session.removeAttribute(sessionToken)\n    }\n\n    response.addHeader(\"Cache-Control\", \"no-cache\")\n    withFormat {\n      xml {\n        // No need to use the response builder here until we have a more complex response\n        render(text: \"<response><returncode>$RESP_CODE_SUCCESS</returncode></response>\", contentType: \"text/xml\")\n      }\n    }\n  }\n\n  /******************************************************\n   * GET_RECORDINGS API\n   ******************************************************/\n  def getRecordingsHandler = {\n    String API_CALL = \"getRecordings\"\n    log.debug CONTROLLER_NAME + \"#${API_CALL}\"\n\n    // BEGIN - backward compatibility\n    if (StringUtils.isEmpty(params.checksum)) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n    // END - backward compatibility\n\n    ApiErrors errors = new ApiErrors()\n\n    // Do we have a checksum? If none, complain.\n    if (StringUtils.isEmpty(params.checksum)) {\n      errors.missingParamError(\"checksum\");\n      respondWithErrors(errors)\n      return\n    }\n\n    log.debug request.getQueryString()\n\n    // Do we agree on the checksum? If not, complain.\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      errors.checksumError()\n      respondWithErrors(errors)\n      return\n    }\n\n    List<String> externalMeetingIds = new ArrayList<String>();\n    if (!StringUtils.isEmpty(params.meetingID)) {\n      externalMeetingIds = paramsProcessorUtil.decodeIds(params.meetingID);\n    }\n\n    ArrayList<String> internalRecordIds = new ArrayList<String>()\n    if (!StringUtils.isEmpty(params.recordID)) {\n      internalRecordIds = paramsProcessorUtil.decodeIds(params.recordID)\n    }\n\n    ArrayList<String> states = new ArrayList<String>()\n    if (!StringUtils.isEmpty(params.state)) {\n      states = paramsProcessorUtil.decodeIds(params.state)\n    }\n\n    // Everything is good so far.\n    if (internalRecordIds.size() == 0 && externalMeetingIds.size() > 0) {\n      // No recordIDs, process the request based on meetingID(s)\n      // Translate the external meeting ids to internal meeting ids (which is the seed for the recordIDs).\n      internalRecordIds = paramsProcessorUtil.convertToInternalMeetingId(externalMeetingIds);\n    }\n\n    for(String intRecId : internalRecordIds) {\n      log.debug intRecId\n    }\n\n    Map<String, String> metadataFilters = ParamsProcessorUtil.processMetaParam(params);\n\n    def getRecordingsResult = meetingService.getRecordings2x(internalRecordIds, states, metadataFilters)\n\n    withFormat {\n      xml {\n        render(text: getRecordingsResult, contentType: \"text/xml\")\n      }\n    }\n  }\n\n  /******************************************************\n   * PUBLISH_RECORDINGS API\n   ******************************************************/\n  def publishRecordings = {\n    String API_CALL = \"publishRecordings\"\n    log.debug CONTROLLER_NAME + \"#${API_CALL}\"\n\n    // BEGIN - backward compatibility\n    if (StringUtils.isEmpty(params.checksum)) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n\n    if (StringUtils.isEmpty(params.recordID)) {\n      invalid(\"missingParamRecordID\", \"You must specify a recordID.\");\n      return\n    }\n\n    if (StringUtils.isEmpty(params.publish)) {\n      invalid(\"missingParamPublish\", \"You must specify a publish value true or false.\");\n      return\n    }\n\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n    // END - backward compatibility\n\n    ApiErrors errors = new ApiErrors()\n\n    // Do we have a checksum? If none, complain.\n    if (StringUtils.isEmpty(params.checksum)) {\n      errors.missingParamError(\"checksum\");\n    }\n\n    // Do we have a recording id? If none, complain.\n    String recordId = params.recordID\n    if (StringUtils.isEmpty(recordId)) {\n      errors.missingParamError(\"recordID\");\n    }\n    // Do we have a publish status? If none, complain.\n    String publish = params.publish\n    if (StringUtils.isEmpty(publish)) {\n      errors.missingParamError(\"publish\");\n    }\n\n    if (errors.hasErrors()) {\n      respondWithErrors(errors)\n      return\n    }\n\n    // Do we agree on the checksum? If not, complain.\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      errors.checksumError()\n      respondWithErrors(errors)\n      return\n    }\n\n    ArrayList<String> recordIdList = new ArrayList<String>();\n    if (!StringUtils.isEmpty(recordId)) {\n      recordIdList = paramsProcessorUtil.decodeIds(recordId);\n    }\n\n    if (!meetingService.existsAnyRecording(recordIdList)) {\n      // BEGIN - backward compatibility\n      invalid(\"notFound\", \"We could not find recordings\");\n      return;\n      // END - backward compatibility\n\n    }\n\n    meetingService.setPublishRecording(recordIdList, publish.toBoolean());\n    withFormat {\n      xml {\n        // No need to use the response builder here until we have a more complex response\n        render(text: \"<response><returncode>$RESP_CODE_SUCCESS</returncode><published>$publish</published></response>\", contentType: \"text/xml\")\n      }\n    }\n  }\n\n  /******************************************************\n   * DELETE_RECORDINGS API\n   ******************************************************/\n  def deleteRecordings = {\n    String API_CALL = \"deleteRecordings\"\n    log.debug CONTROLLER_NAME + \"#${API_CALL}\"\n\n    // BEGIN - backward compatibility\n    if (StringUtils.isEmpty(params.checksum)) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n\n    if (StringUtils.isEmpty(params.recordID)) {\n      invalid(\"missingParamRecordID\", \"You must specify a recordID.\");\n      return\n    }\n\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n    // END - backward compatibility\n\n    ApiErrors errors = new ApiErrors()\n\n    // Do we have a checksum? If none, complain.\n    if (StringUtils.isEmpty(params.checksum)) {\n      errors.missingParamError(\"checksum\");\n    }\n\n    // Do we have a recording id? If none, complain.\n    String recordId = params.recordID\n    if (StringUtils.isEmpty(recordId)) {\n      errors.missingParamError(\"recordID\");\n    }\n\n    if (errors.hasErrors()) {\n      respondWithErrors(errors)\n      return\n    }\n\n    // Do we agree on the checksum? If not, complain.\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      errors.checksumError()\n      respondWithErrors(errors)\n      return\n    }\n\n    List<String> recordIdList = new ArrayList<String>();\n    if (!StringUtils.isEmpty(recordId)) {\n      recordIdList = paramsProcessorUtil.decodeIds(recordId);\n    }\n\n    if (!meetingService.existsAnyRecording(recordIdList)) {\n      // BEGIN - backward compatibility\n      invalid(\"notFound\", \"We could not find recordings\");\n      return;\n      // END - backward compatibility\n    }\n\n    meetingService.deleteRecordings(recordIdList);\n    withFormat {\n      xml {\n        // No need to use the response builder here until we have a more complex response\n        render(text: \"<response><returncode>$RESP_CODE_SUCCESS</returncode><deleted>true</deleted></response>\", contentType: \"text/xml\")\n      }\n    }\n  }\n\n  /******************************************************\n   * UPDATE_RECORDINGS API\n   ******************************************************/\n  def updateRecordingsHandler = {\n    String API_CALL = \"updateRecordings\"\n    log.debug CONTROLLER_NAME + \"#${API_CALL}\"\n\n    // BEGIN - backward compatibility\n    if (StringUtils.isEmpty(params.checksum)) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n\n    if (StringUtils.isEmpty(params.recordID)) {\n      invalid(\"missingParamRecordID\", \"You must specify a recordID.\");\n      return\n    }\n\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n    // END - backward compatibility\n\n    ApiErrors errors = new ApiErrors()\n\n    // Do we have a checksum? If none, complain.\n    if (StringUtils.isEmpty(params.checksum)) {\n      errors.missingParamError(\"checksum\");\n    }\n\n    // Do we have a recording id? If none, complain.\n    String recordId = params.recordID\n    if (StringUtils.isEmpty(recordId)) {\n      errors.missingParamError(\"recordID\");\n    }\n\n    if (errors.hasErrors()) {\n      respondWithErrors(errors)\n      return\n    }\n\n    // Do we agree on the checksum? If not, complain.\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      errors.checksumError()\n      respondWithErrors(errors)\n      return\n    }\n\n    List<String> recordIdList = new ArrayList<String>();\n    if (!StringUtils.isEmpty(recordId)) {\n      recordIdList = paramsProcessorUtil.decodeIds(recordId);\n    }\n\n    if (!meetingService.existsAnyRecording(recordIdList)) {\n      // BEGIN - backward compatibility\n      invalid(\"notFound\", \"We could not find recordings\");\n      return;\n      // END - backward compatibility\n    }\n\n    //Execute code specific for this call\n    Map<String, String> metaParams = ParamsProcessorUtil.processMetaParam(params)\n    if (!metaParams.empty) {\n      //Proceed with the update\n      meetingService.updateRecordings(recordIdList, metaParams);\n    }\n    withFormat {\n      xml {\n        // No need to use the response builder here until we have a more complex response\n        render(text: \"<response><returncode>$RESP_CODE_SUCCESS</returncode><updated>true</updated></response>\", contentType: \"text/xml\")\n      }\n    }\n  }\n\n  def uploadDocuments(conf) { //\n    log.debug(\"ApiController#uploadDocuments(${conf.getInternalId()})\");\n\n    String requestBody = request.inputStream == null ? null : request.inputStream.text;\n    requestBody = StringUtils.isEmpty(requestBody) ? null : requestBody;\n\n    if (requestBody == null) {\n      downloadAndProcessDocument(presentationService.defaultUploadedPresentation, conf.getInternalId(), true /* default presentation */, '');\n    } else {\n      def xml = new XmlSlurper().parseText(requestBody);\n      xml.children().each { module ->\n        log.debug(\"module config found: [${module.@name}]\");\n\n        if (\"presentation\".equals(module.@name.toString())) {\n          // need to iterate over presentation files and process them\n          Boolean current = true;\n          module.children().each { document ->\n            if (!StringUtils.isEmpty(document.@url.toString())) {\n              def fileName;\n              if (!StringUtils.isEmpty(document.@filename.toString())) {\n                log.debug(\"user provided filename: [${module.@filename}]\");\n                fileName = document.@filename.toString();\n              }\n              downloadAndProcessDocument(document.@url.toString(), conf.getInternalId(), current /* default presentation */, fileName);\n              current = false;\n            } else if (!StringUtils.isEmpty(document.@name.toString())) {\n              def b64 = new Base64()\n              def decodedBytes = b64.decode(document.text().getBytes())\n              processDocumentFromRawBytes(decodedBytes, document.@name.toString(),\n                  conf.getInternalId(), current /* default presentation */);\n              current = false;\n            } else {\n              log.debug(\"presentation module config found, but it did not contain url or name attributes\");\n            }\n          }\n        }\n      }\n    }\n  }\n\n  def processDocumentFromRawBytes(bytes, presOrigFilename, meetingId, current) {\n    def uploadFailed = false\n    def uploadFailReasons = new ArrayList<String>()\n\n    // Gets the name minus the path from a full fileName.\n    // a/b/c.txt --> c.txt\n    def presFilename =  FilenameUtils.getName(presOrigFilename)\n    def filenameExt = FilenameUtils.getExtension(presOrigFilename)\n    def pres = null\n    def presId = null\n\n    if (presFilename == \"\" || filenameExt == \"\") {\n      log.debug(\"Upload failed. Invalid filename \" + presOrigFilename)\n      uploadFailReasons.add(\"invalid_filename\")\n      uploadFailed = true\n    } else {\n      String presentationDir = presentationService.getPresentationDir()\n      presId = Util.generatePresentationId(presFilename)\n\n      File uploadDir = Util.createPresentationDir(meetingId, presentationDir, presId)\n      if (uploadDir != null) {\n        def newFilename = Util.createNewFilename(presId, filenameExt)\n        pres = new File(uploadDir.absolutePath + File.separatorChar + newFilename);\n\n        FileOutputStream fos = new java.io.FileOutputStream(pres)\n        fos.write(bytes)\n        fos.flush()\n        fos.close()\n      } else {\n        log.warn \"Upload failed. File Empty.\"\n        uploadFailReasons.add(\"failed_to_download_file\")\n        uploadFailed = true\n      }\n    }\n\n    // Hardcode pre-uploaded presentation to the default presentation window\n    processUploadedFile(\"DEFAULT_PRESENTATION_POD\",\n              meetingId,\n              presId,\n              presFilename,\n              pres,\n              current,\n              \"preupload-raw-authz-token\",\n              uploadFailed,\n              uploadFailReasons)\n  }\n\n  def downloadAndProcessDocument(address, meetingId, current, fileName) {\n    log.debug(\"ApiController#downloadAndProcessDocument(${address}, ${meetingId}, ${fileName})\");\n    String presOrigFilename;\n    if (StringUtils.isEmpty(fileName)) {\n      presOrigFilename = address.tokenize(\"/\")[-1];\n    } else {\n      presOrigFilename = fileName;\n    }\n\n    def uploadFailed = false\n    def uploadFailReasons = new ArrayList<String>()\n\n    // Gets the name minus the path from a full fileName.\n    // a/b/c.txt --> c.txt\n    def presFilename =  FilenameUtils.getName(presOrigFilename)\n    def filenameExt = FilenameUtils.getExtension(presOrigFilename)\n    def pres = null\n    def presId\n\n    if (presFilename == \"\" || filenameExt == \"\") {\n      log.debug(\"Upload failed. Invalid filename \" + presOrigFilename)\n      uploadFailReasons.add(\"invalid_filename\")\n      uploadFailed = true\n    } else {\n      String presentationDir = presentationService.getPresentationDir()\n      presId = Util.generatePresentationId(presFilename)\n      File uploadDir = Util.createPresentationDir(meetingId, presentationDir, presId)\n      if (uploadDir != null) {\n        def newFilename = Util.createNewFilename(presId, filenameExt)\n        def newFilePath = uploadDir.absolutePath + File.separatorChar + newFilename\n\n        if (presDownloadService.savePresentation(meetingId, newFilePath, address)) {\n          pres = new File(newFilePath)\n        } else {\n          log.error(\"Failed to download presentation=[${address}], meeting=[${meetingId}], fileName=[${fileName}]\")\n          uploadFailReasons.add(\"failed_to_download_file\")\n          uploadFailed = true\n        }\n      }\n    }\n\n    // Hardcode pre-uploaded presentation to the default presentation window\n    processUploadedFile(\n            \"DEFAULT_PRESENTATION_POD\",\n            meetingId,\n            presId,\n            presFilename,\n            pres,\n            current,\n            \"preupload-download-authz-token\",\n            uploadFailed,\n            uploadFailReasons\n    )\n  }\n\n\n  def processUploadedFile(podId, meetingId, presId, filename, presFile, current, authzToken, uploadFailed, uploadFailReasons ) {\n    def presentationBaseUrl = presentationService.presentationBaseUrl\n    // TODO add podId\n    UploadedPresentation uploadedPres = new UploadedPresentation(podId,\n            meetingId,\n            presId,\n            filename,\n            presentationBaseUrl,\n            current,\n            authzToken,\n            uploadFailed,\n            uploadFailReasons)\n    uploadedPres.setUploadedFile(presFile);\n    presentationService.processUploadedPresentation(uploadedPres);\n  }\n\n  def beforeInterceptor = {\n    if (paramsProcessorUtil.isServiceEnabled() == false) {\n      log.info(\"apiNotEnabled: The API service and/or controller is not enabled on this server.  To use it, you must first enable it.\")\n      // TODO: this doesn't stop the request - so it generates invalid XML\n      //      since the request continues and renders a second response\n      invalid(\"apiNotEnabled\", \"The API service and/or controller is not enabled on this server.  To use it, you must first enable it.\")\n    }\n  }\n\n  def respondWithConference(meeting, msgKey, msg) {\n    response.addHeader(\"Cache-Control\", \"no-cache\")\n    withFormat {\n      xml {\n        log.debug \"Rendering as xml\"\n        render(text: responseBuilder.buildMeeting(meeting, msgKey, msg, RESP_CODE_SUCCESS), contentType: \"text/xml\")\n      }\n    }\n  }\n\n  def getUserSession(token) {\n    if (token == null) {\n      return null\n    }\n\n    UserSession us = meetingService.getUserSessionWithAuthToken(token)\n    if (us == null) {\n      log.info(\"Cannot find UserSession for token ${token}\")\n    }\n\n    return us\n  }\n\n  def sanitizeSessionToken(param) {\n    if (param == null) {\n      log.info(\"sanitizeSessionToken: token is null\")\n      return null\n    }\n\n    if (StringUtils.isEmpty(param)) {\n      log.info(\"sanitizeSessionToken: token is empty\")\n      return null\n    }\n\n    return StringUtils.strip(param)\n  }\n\n  private Boolean hasValidSession(token) {\n    UserSession us = getUserSession(token)\n    if (us == null) {\n      return false\n    }\n\n    if (!session[token]) {\n      log.info(\"Session for token ${token} not found\")\n\n      Boolean allowRequestsWithoutSession = paramsProcessorUtil.getAllowRequestsWithoutSession()\n      if (!allowRequestsWithoutSession) {\n        log.info(\"Meeting related to ${token} doesn't allow requests without session\")\n        return false\n      }\n    }\n\n    log.info(\"Token ${token} is valid\")\n    return true\n  }\n\n  // Validate maxParticipants constraint\n  private Boolean hasReachedMaxParticipants(meeting, us) {\n    // Meeting object calls it maxUsers to build up the drama\n    int maxParticipants = meeting.getMaxUsers();\n    // When is set to 0, the validation is ignored\n    Boolean enabled = maxParticipants > 0;\n    // Users refreshing page or reconnecting must be identified\n    Boolean rejoin = meeting.getUserById(us.internalUserId) != null;\n    // Users that passed enter once, still not joined but somehow re-entered\n    Boolean reenter = meeting.getEnteredUserById(us.internalUserId) != null;\n    // Users that already joined the meeting\n    int joinedUsers = meeting.getUsers().size()\n    // Users that are entering the meeting\n    int enteredUsers = meeting.getEnteredUsers().size()\n\n    Boolean reachedMax = (joinedUsers + enteredUsers) >= maxParticipants;\n    if (enabled && !rejoin && !reenter && reachedMax) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private void respondWithErrors(errorList, redirectResponse = false) {\n    log.debug CONTROLLER_NAME + \"#invalid\"\n    if (redirectResponse) {\n      ArrayList<Object> errors = new ArrayList<Object>();\n      errorList.getErrors().each { error ->\n        Map<String, String> errorMap = new LinkedHashMap<String, String>()\n        errorMap.put(\"key\", error[0])\n        errorMap.put(\"message\", error[1])\n        errors.add(errorMap)\n      }\n\n      JSONArray errorsJSONArray = new JSONArray(errors);\n      log.debug errorsJSONArray\n\n      respondWithRedirect(errorsJSONArray)\n    } else {\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n      withFormat {\n        xml {\n          render(text: responseBuilder.buildErrors(errorList.getErrors(), RESP_CODE_FAILED), contentType: \"text/xml\")\n        }\n        json {\n          log.debug \"Rendering as json\"\n          def builder = new JsonBuilder()\n          builder.response {\n            returncode RESP_CODE_FAILED\n            messageKey key\n            message msg\n          }\n          render(contentType: \"application/json\", text: builder.toPrettyString())\n        }\n      }\n    }\n  }\n\n  //TODO: method added for backward compatibility, it will be removed in next versions after 0.8\n  private void invalid(key, msg, redirectResponse = false) {\n    // Note: This xml scheme will be DEPRECATED.\n    log.debug CONTROLLER_NAME + \"#invalid \" + msg\n    if (redirectResponse) {\n      ArrayList<Object> errors = new ArrayList<Object>();\n      Map<String, String> errorMap = new LinkedHashMap<String, String>()\n      errorMap.put(\"key\", key)\n      errorMap.put(\"message\", msg)\n      errors.add(errorMap)\n\n      JSONArray errorsJSONArray = new JSONArray(errors)\n      log.debug \"JSON Errors {}\", errorsJSONArray.toString()\n\n      respondWithRedirect(errorsJSONArray)\n    } else {\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n      withFormat {\n        xml {\n          render(text: responseBuilder.buildError(key, msg, RESP_CODE_FAILED), contentType: \"text/xml\")\n        }\n        json {\n          log.debug \"Rendering as json\"\n          def builder = new JsonBuilder()\n          builder.response {\n            returncode RESP_CODE_FAILED\n            messageKey key\n            message msg\n          }\n          render(contentType: \"application/json\", text: builder.toPrettyString())\n        }\n      }\n    }\n  }\n\n  private void respondWithRedirect(errorsJSONArray) {\n    String logoutUrl = paramsProcessorUtil.getDefaultLogoutUrl()\n    URI oldUri = URI.create(logoutUrl)\n\n    if (!StringUtils.isEmpty(params.logoutURL)) {\n      try {\n        oldUri = URI.create(params.logoutURL)\n      } catch (Exception e) {\n        // Do nothing, the variable oldUri was already initialized\n      }\n    }\n\n    String newQuery = oldUri.getQuery();\n\n    if (newQuery == null) {\n      newQuery = \"errors=\"\n    } else {\n      newQuery += \"&\" + \"errors=\"\n    }\n    newQuery += errorsJSONArray\n\n    URI newUri = new URI(oldUri.getScheme(), oldUri.getAuthority(), oldUri.getPath(), newQuery, oldUri.getFragment())\n\n    log.debug \"Constructed logout URL {}\", newUri.toString()\n    redirect(url: newUri)\n  }\n\n}\n"], "fixing_code": ["/**\n ** BigBlueButton open source conferencing system - http://www.bigbluebutton.org/\n *\n * Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).\n *\n * This program is free software; you can redistribute it and/or modify it under the\n * terms of the GNU Lesser General Public License as published by the Free Software\n * Foundation; either version 3.0 of the License, or (at your option) any later\n * version.\n *\n * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License along\n * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage org.bigbluebutton.web.controllers\n\nimport com.google.gson.Gson\nimport grails.web.context.ServletContextHolder\nimport groovy.json.JsonBuilder\nimport org.apache.commons.codec.binary.Base64\nimport org.apache.commons.io.FilenameUtils\nimport org.apache.commons.lang.RandomStringUtils\nimport org.apache.commons.lang.StringUtils\nimport org.bigbluebutton.api.*\nimport org.bigbluebutton.api.domain.Config\nimport org.bigbluebutton.api.domain.GuestPolicy\nimport org.bigbluebutton.api.domain.Meeting\nimport org.bigbluebutton.api.domain.UserSession\nimport org.bigbluebutton.api.util.ParamsUtil\nimport org.bigbluebutton.api.util.ResponseBuilder\nimport org.bigbluebutton.presentation.PresentationUrlDownloadService\nimport org.bigbluebutton.presentation.UploadedPresentation\nimport org.bigbluebutton.web.services.PresentationService\nimport org.bigbluebutton.web.services.turn.StunTurnService\nimport org.bigbluebutton.web.services.turn.TurnEntry\nimport org.bigbluebutton.web.services.turn.StunServer\nimport org.bigbluebutton.web.services.turn.RemoteIceCandidate\nimport org.json.JSONArray\n\nimport javax.servlet.ServletRequest\n\nclass ApiController {\n  private static final Integer SESSION_TIMEOUT = 14400  // 4 hours\n  private static final String CONTROLLER_NAME = 'ApiController'\n  protected static final String RESP_CODE_SUCCESS = 'SUCCESS'\n  protected static final String RESP_CODE_FAILED = 'FAILED'\n  private static final String ROLE_MODERATOR = \"MODERATOR\"\n  private static final String ROLE_ATTENDEE = \"VIEWER\"\n  protected static Boolean REDIRECT_RESPONSE = true\n\n  MeetingService meetingService;\n  PresentationService presentationService\n  ParamsProcessorUtil paramsProcessorUtil\n  ClientConfigService configService\n  PresentationUrlDownloadService presDownloadService\n  StunTurnService stunTurnService\n  ResponseBuilder responseBuilder = initResponseBuilder()\n\n  def initResponseBuilder = {\n    String protocol = this.getClass().getResource(\"\").getProtocol();\n    if (Objects.equals(protocol, \"jar\")) {\n      // Application running inside a JAR file\n      responseBuilder = new ResponseBuilder(getClass().getClassLoader(), \"/WEB-INF/freemarker\")\n    } else if (Objects.equals(protocol, \"file\")) {\n      // Application unzipped and running outside a JAR file\n      String templateLoc = ServletContextHolder.servletContext.getRealPath(\"/WEB-INF/freemarker\")\n      // We should never have a null `templateLoc`\n      responseBuilder = new ResponseBuilder(new File(templateLoc))\n    }\n  }\n\n  /* general methods */\n  def index = {\n    log.debug CONTROLLER_NAME + \"#index\"\n    response.addHeader(\"Cache-Control\", \"no-cache\")\n\n    withFormat {\n      xml {\n        render(text: responseBuilder.buildMeetingVersion(paramsProcessorUtil.getApiVersion(), RESP_CODE_SUCCESS), contentType: \"text/xml\")\n      }\n    }\n  }\n\n  /***********************************\n   * CREATE (API)\n   ***********************************/\n  def create = {\n    String API_CALL = 'create'\n    log.debug CONTROLLER_NAME + \"#${API_CALL}\"\n    log.debug request.getParameterMap().toMapString()\n\n    // BEGIN - backward compatibility\n    if (StringUtils.isEmpty(params.checksum)) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n\n    if (!StringUtils.isEmpty(params.meetingID)) {\n      params.meetingID = StringUtils.strip(params.meetingID);\n      if (StringUtils.isEmpty(params.meetingID)) {\n        invalid(\"missingParamMeetingID\", \"You must specify a meeting ID for the meeting.\");\n        return\n      }\n    } else {\n      invalid(\"missingParamMeetingID\", \"You must specify a meeting ID for the meeting.\");\n      return\n    }\n\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n    // END - backward compatibility\n\n    ApiErrors errors = new ApiErrors();\n    paramsProcessorUtil.processRequiredCreateParams(params, errors);\n\n    if (errors.hasErrors()) {\n      respondWithErrors(errors)\n      return\n    }\n\n    // Do we agree with the checksum? If not, complain.\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      errors.checksumError()\n      respondWithErrors(errors)\n      return\n    }\n\n    Meeting newMeeting = paramsProcessorUtil.processCreateParams(params)\n\n    if (meetingService.createMeeting(newMeeting)) {\n      // See if the request came with pre-uploading of presentation.\n      uploadDocuments(newMeeting);  //\n      respondWithConference(newMeeting, null, null)\n    } else {\n      // Translate the external meeting id into an internal meeting id.\n      String internalMeetingId = paramsProcessorUtil.convertToInternalMeetingId(params.meetingID);\n      Meeting existing = meetingService.getNotEndedMeetingWithId(internalMeetingId);\n      if (existing != null) {\n        log.debug \"Existing conference found\"\n        Map<String, Object> updateParams = paramsProcessorUtil.processUpdateCreateParams(params);\n        if (existing.getViewerPassword().equals(params.get(\"attendeePW\")) && existing.getModeratorPassword().equals(params.get(\"moderatorPW\"))) {\n          //paramsProcessorUtil.updateMeeting(updateParams, existing);\n          // trying to create a conference a second time, return success, but give extra info\n          // Ignore pre-uploaded presentations. We only allow uploading of presentation once.\n          //uploadDocuments(existing);\n          respondWithConference(existing, \"duplicateWarning\", \"This conference was already in existence and may currently be in progress.\");\n        } else {\n          // BEGIN - backward compatibility\n          invalid(\"idNotUnique\", \"A meeting already exists with that meeting ID.  Please use a different meeting ID.\");\n          return\n          // END - backward compatibility\n\n          // enforce meetingID unique-ness\n          errors.nonUniqueMeetingIdError()\n          respondWithErrors(errors)\n        }\n\n        return\n      }\n    }\n  }\n\n\n  /**********************************************\n   * JOIN API\n   *********************************************/\n  def join = {\n    String API_CALL = 'join'\n    log.debug CONTROLLER_NAME + \"#${API_CALL}\"\n    ApiErrors errors = new ApiErrors()\n\n    // BEGIN - backward compatibility\n    if (StringUtils.isEmpty(params.checksum)) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\", REDIRECT_RESPONSE)\n      return\n    }\n\n    //checking for an empty username or for a username containing whitespaces only\n    if (!StringUtils.isEmpty(params.fullName)) {\n      params.fullName = StringUtils.strip(params.fullName);\n      if (StringUtils.isEmpty(params.fullName)) {\n        invalid(\"missingParamFullName\", \"You must specify a name for the attendee who will be joining the meeting.\", REDIRECT_RESPONSE);\n        return\n      }\n    } else {\n      invalid(\"missingParamFullName\", \"You must specify a name for the attendee who will be joining the meeting.\", REDIRECT_RESPONSE);\n      return\n    }\n\n    if (!StringUtils.isEmpty(params.meetingID)) {\n      params.meetingID = StringUtils.strip(params.meetingID);\n      if (StringUtils.isEmpty(params.meetingID)) {\n        invalid(\"missingParamMeetingID\", \"You must specify a meeting ID for the meeting.\", REDIRECT_RESPONSE)\n        return\n      }\n    } else {\n      invalid(\"missingParamMeetingID\", \"You must specify a meeting ID for the meeting.\", REDIRECT_RESPONSE)\n      return\n    }\n\n    if (StringUtils.isEmpty(params.password)) {\n      invalid(\"invalidPassword\", \"You either did not supply a password or the password supplied is neither the attendee or moderator password for this conference.\", REDIRECT_RESPONSE);\n      return\n    }\n\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\", REDIRECT_RESPONSE)\n      return\n    }\n\n    // END - backward compatibility\n\n    // Do we have a checksum? If none, complain.\n    if (StringUtils.isEmpty(params.checksum)) {\n      errors.missingParamError(\"checksum\");\n    }\n\n    Boolean authenticated = false;\n\n    Boolean guest = false;\n    if (!StringUtils.isEmpty(params.guest)) {\n      guest = Boolean.parseBoolean(params.guest)\n    } else {\n      // guest param has not been passed. Make user as\n      // authenticated by default. (ralam july 3, 2018)\n      authenticated = true\n    }\n\n\n    if (!StringUtils.isEmpty(params.auth)) {\n      authenticated = Boolean.parseBoolean(params.auth)\n    }\n\n    Boolean joinViaHtml5 = false;\n    if (!StringUtils.isEmpty(params.joinViaHtml5)) {\n      joinViaHtml5 = Boolean.parseBoolean(params.joinViaHtml5)\n    }\n\n    // Do we have a name for the user joining? If none, complain.\n    if (!StringUtils.isEmpty(params.fullName)) {\n      params.fullName = StringUtils.strip(params.fullName);\n      // remove control characters ( sanitize )\n      params.fullName = params.fullName.replaceAll(\"\\\\p{Cntrl}\", \"\");\n      if (StringUtils.isEmpty(params.fullName)) {\n        errors.missingParamError(\"fullName\");\n      }\n    } else {\n      errors.missingParamError(\"fullName\");\n    }\n    String fullName = ParamsUtil.stripHTMLTags(params.fullName)\n\n    // Do we have a meeting id? If none, complain.\n    if (!StringUtils.isEmpty(params.meetingID)) {\n      params.meetingID = StringUtils.strip(params.meetingID);\n      if (StringUtils.isEmpty(params.meetingID)) {\n        errors.missingParamError(\"meetingID\");\n      }\n    } else {\n      errors.missingParamError(\"meetingID\");\n    }\n    String externalMeetingId = params.meetingID\n\n    // Do we have a password? If not, complain.\n    String attPW = params.password\n    if (StringUtils.isEmpty(attPW)) {\n      errors.missingParamError(\"password\");\n    }\n\n    // Do we agree on the checksum? If not, complain.\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      errors.checksumError()\n    }\n\n    if (errors.hasErrors()) {\n      respondWithErrors(errors, REDIRECT_RESPONSE)\n      return\n    }\n\n    // Everything is good so far. Translate the external meeting id to an internal meeting id. If\n    // we can't find the meeting, complain.\n    String internalMeetingId = paramsProcessorUtil.convertToInternalMeetingId(externalMeetingId);\n\n    log.info(\"Retrieving meeting ${internalMeetingId}\")\n    Meeting meeting = meetingService.getMeeting(internalMeetingId);\n    if (meeting == null) {\n      // BEGIN - backward compatibility\n      invalid(\"invalidMeetingIdentifier\", \"The meeting ID that you supplied did not match any existing meetings\", REDIRECT_RESPONSE);\n      return\n      // END - backward compatibility\n\n      errors.invalidMeetingIdError();\n      respondWithErrors(errors, REDIRECT_RESPONSE)\n      return\n    }\n\n    // the createTime mismatch with meeting's createTime, complain\n    // In the future, the createTime param will be required\n    if (params.createTime != null) {\n      long createTime = 0;\n      try {\n        createTime = Long.parseLong(params.createTime);\n      } catch (Exception e) {\n        log.warn(\"could not parse createTime param\");\n        createTime = -1;\n      }\n      if (createTime != meeting.getCreateTime()) {\n        // BEGIN - backward compatibility\n        invalid(\"mismatchCreateTimeParam\", \"The createTime parameter submitted mismatches with the current meeting.\", REDIRECT_RESPONSE);\n        return\n        // END - backward compatibility\n\n        errors.mismatchCreateTimeParam();\n        respondWithErrors(errors, REDIRECT_RESPONSE);\n        return\n      }\n    }\n\n    // Is this user joining a meeting that has been ended. If so, complain.\n    if (meeting.isForciblyEnded()) {\n      // BEGIN - backward compatibility\n      invalid(\"meetingForciblyEnded\", \"You can not re-join a meeting that has already been forcibly ended.  However, once the meeting is removed from memory (according to the timeout configured on this server, you will be able to once again create a meeting with the same meeting ID\", REDIRECT_RESPONSE);\n      return\n      // END - backward compatibility\n\n      errors.meetingForciblyEndedError();\n      respondWithErrors(errors, REDIRECT_RESPONSE)\n      return\n    }\n\n    // Now determine if this user is a moderator or a viewer.\n    String role = null;\n    if (meeting.getModeratorPassword().equals(attPW)) {\n      role = Meeting.ROLE_MODERATOR\n    } else if (meeting.getViewerPassword().equals(attPW)) {\n      role = Meeting.ROLE_ATTENDEE\n    }\n\n    if (role == null) {\n      // BEGIN - backward compatibility\n      invalid(\"invalidPassword\", \"You either did not supply a password or the password supplied is neither the attendee or moderator password for this conference.\", REDIRECT_RESPONSE);\n      return\n      // END - backward compatibility\n\n      errors.invalidPasswordError()\n      respondWithErrors(errors, REDIRECT_RESPONSE)\n      return\n    }\n\n    // We preprend \"w_\" to our internal meeting Id to indicate that this is a web user.\n    // For users joining using the phone, we will prepend \"v_\" so it will be easier\n    // to distinguish users who doesn't have a web client. (ralam june 12, 2017)\n    String internalUserID = \"w_\" + RandomStringUtils.randomAlphanumeric(12).toLowerCase()\n\n    String authToken = RandomStringUtils.randomAlphanumeric(12).toLowerCase()\n\n    String sessionToken = RandomStringUtils.randomAlphanumeric(16).toLowerCase()\n\n    String externUserID = params.userID\n    if (StringUtils.isEmpty(externUserID)) {\n      externUserID = internalUserID\n    }\n\n    //Return a Map with the user custom data\n    Map<String, String> userCustomData = paramsProcessorUtil.getUserCustomData(params);\n\n    //Currently, it's associated with the externalUserID\n    if (userCustomData.size() > 0)\n      meetingService.addUserCustomData(meeting.getInternalId(), externUserID, userCustomData);\n\n    String configxml = null;\n\n    if (!StringUtils.isEmpty(params.configToken)) {\n      Config conf = meeting.getConfig(params.configToken);\n      if (conf == null) {\n        // Check if this config is one of our pre-built config\n        configxml = configService.getConfig(params.configToken)\n        if (configxml == null) {\n          // BEGIN - backward compatibility\n          invalid(\"noConfigFound\", \"We could not find a config for this request.\", REDIRECT_RESPONSE);\n          return\n          // END - backward compatibility\n\n          errors.noConfigFound();\n          respondWithErrors(errors);\n        }\n      } else {\n        configxml = conf.config;\n      }\n    } else {\n      Config conf = meeting.getDefaultConfig();\n      configxml = conf.config;\n    }\n\n    // Do not fail if there's no default config.xml, needed for an HTML5 client only scenario\n\n    String guestStatusVal = meeting.calcGuestStatus(role, guest, authenticated)\n\n    UserSession us = new UserSession();\n    us.authToken = authToken;\n    us.internalUserId = internalUserID\n    us.conferencename = meeting.getName()\n    us.meetingID = meeting.getInternalId()\n    us.externMeetingID = meeting.getExternalId()\n    us.externUserID = externUserID\n    us.fullname = fullName\n    us.role = role\n    us.conference = meeting.getInternalId()\n    us.room = meeting.getInternalId()\n    us.voicebridge = meeting.getTelVoice()\n    us.webvoiceconf = meeting.getWebVoice()\n    us.mode = \"LIVE\"\n    us.record = meeting.isRecord()\n    us.welcome = meeting.getWelcomeMessage()\n    us.guest = guest\n    us.authed = authenticated\n    us.guestStatus = guestStatusVal\n    us.logoutUrl = meeting.getLogoutUrl()\n    us.configXML = configxml;\n\n    if (!StringUtils.isEmpty(params.defaultLayout)) {\n      us.defaultLayout = params.defaultLayout;\n    }\n\n    if (!StringUtils.isEmpty(params.avatarURL)) {\n      us.avatarURL = params.avatarURL;\n    } else {\n      us.avatarURL = meeting.defaultAvatarURL\n    }\n\n    String meetingId = meeting.getInternalId()\n\n    if (hasReachedMaxParticipants(meeting, us)) {\n      // BEGIN - backward compatibility\n      invalid(\"maxParticipantsReached\", \"The number of participants allowed for this meeting has been reached.\", REDIRECT_RESPONSE);\n      return\n      // END - backward compatibility\n\n      errors.maxParticipantsReached();\n      respondWithErrors(errors, REDIRECT_RESPONSE);\n      return;\n    }\n\n    // Register user into the meeting.\n    meetingService.registerUser(\n        us.meetingID,\n        us.internalUserId,\n        us.fullname,\n        us.role,\n        us.externUserID,\n        us.authToken,\n        us.avatarURL,\n        us.guest,\n        us.authed,\n        guestStatusVal\n    )\n\n    //Identify which of these to logs should be used. sessionToken or user-token\n    log.info(\"Session sessionToken for \" + us.fullname + \" [\" + session[sessionToken] + \"]\")\n    log.info(\"Session user-token for \" + us.fullname + \" [\" + session['user-token'] + \"]\")\n    session.setMaxInactiveInterval(SESSION_TIMEOUT);\n\n    //check if exists the param redirect\n    boolean redirectClient = true;\n    String clientURL = paramsProcessorUtil.getDefaultClientUrl();\n\n    // server-wide configuration:\n    // Depending on configuration, prefer the HTML5 client over Flash for moderators\n    if (paramsProcessorUtil.getModeratorsJoinViaHTML5Client() && role == ROLE_MODERATOR) {\n      joinViaHtml5 = true\n    }\n\n    // Depending on configuration, prefer the HTML5 client over Flash for attendees\n    if (paramsProcessorUtil.getAttendeesJoinViaHTML5Client() && role == ROLE_ATTENDEE) {\n      joinViaHtml5 = true\n    }\n\n    // single client join configuration:\n    // Depending on configuration, prefer the HTML5 client over Flash client\n    if (joinViaHtml5) {\n      clientURL = paramsProcessorUtil.getHTML5ClientUrl();\n    } else {\n      if (!StringUtils.isEmpty(params.clientURL)) {\n        clientURL = params.clientURL;\n      }\n    }\n\n    if (!StringUtils.isEmpty(params.redirect)) {\n      try {\n        redirectClient = Boolean.parseBoolean(params.redirect);\n      } catch (Exception e) {\n        redirectClient = true;\n      }\n    }\n\n    String msgKey = \"successfullyJoined\"\n    String msgValue = \"You have joined successfully.\"\n\n    // Keep track of the client url in case this needs to wait for\n    // approval as guest. We need to be able to send the user to the\n    // client after being approved by moderator.\n    us.clientUrl = clientURL + \"?sessionToken=\" + sessionToken\n\n    session[sessionToken] = sessionToken\n    meetingService.addUserSession(sessionToken, us);\n\n    // Process if we send the user directly to the client or\n    // have it wait for approval.\n    String destUrl = clientURL + \"?sessionToken=\" + sessionToken\n    if (guestStatusVal.equals(GuestPolicy.WAIT)) {\n      String guestWaitUrl = paramsProcessorUtil.getDefaultGuestWaitURL();\n      destUrl = guestWaitUrl + \"?sessionToken=\" + sessionToken\n      msgKey = \"guestWait\"\n      msgValue = \"Guest waiting for approval to join meeting.\"\n    } else if (guestStatusVal.equals(GuestPolicy.DENY)) {\n      destUrl = meeting.getLogoutUrl()\n      msgKey = \"guestDeny\"\n      msgValue = \"Guest denied to join meeting.\"\n    }\n\n    Map<String, Object> logData = new HashMap<String, Object>();\n    logData.put(\"meetingid\", us.meetingID);\n    logData.put(\"extMeetingid\", us.externMeetingID);\n    logData.put(\"name\", us.fullname);\n    logData.put(\"userid\", us.internalUserId);\n    logData.put(\"sessionToken\", sessionToken);\n    logData.put(\"logCode\", \"join_api\");\n    logData.put(\"description\", \"Handle JOIN API.\");\n\n    Gson gson = new Gson();\n    String logStr = gson.toJson(logData);\n\n    log.info(\" --analytics-- data=\" + logStr);\n\n    if (redirectClient) {\n      log.info(\"Redirecting to ${destUrl}\");\n      redirect(url: destUrl);\n    } else {\n      log.info(\"Successfully joined. Sending XML response.\");\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n      withFormat {\n        xml {\n          render(text: responseBuilder.buildJoinMeeting(us, session[sessionToken], guestStatusVal, destUrl, msgKey, msgValue, RESP_CODE_SUCCESS), contentType: \"text/xml\")\n        }\n      }\n    }\n  }\n\n  /*******************************************\n   * IS_MEETING_RUNNING API\n   *******************************************/\n  def isMeetingRunning = {\n    String API_CALL = 'isMeetingRunning'\n    log.debug CONTROLLER_NAME + \"#${API_CALL}\"\n\n    // BEGIN - backward compatibility\n    if (StringUtils.isEmpty(params.checksum)) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n\n    if (!StringUtils.isEmpty(params.meetingID)) {\n      params.meetingID = StringUtils.strip(params.meetingID);\n      if (StringUtils.isEmpty(params.meetingID)) {\n        invalid(\"missingParamMeetingID\", \"You must specify a meeting ID for the meeting.\");\n        return\n      }\n    } else {\n      invalid(\"missingParamMeetingID\", \"You must specify a meeting ID for the meeting.\");\n      return\n    }\n\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n    // END - backward compatibility\n\n    ApiErrors errors = new ApiErrors()\n\n    // Do we have a checksum? If none, complain.\n    if (StringUtils.isEmpty(params.checksum)) {\n      errors.missingParamError(\"checksum\");\n    }\n\n    // Do we have a meeting id? If none, complain.\n    if (!StringUtils.isEmpty(params.meetingID)) {\n      params.meetingID = StringUtils.strip(params.meetingID);\n      if (StringUtils.isEmpty(params.meetingID)) {\n        errors.missingParamError(\"meetingID\");\n      }\n    } else {\n      errors.missingParamError(\"meetingID\");\n    }\n    String externalMeetingId = params.meetingID\n\n\n    if (errors.hasErrors()) {\n      respondWithErrors(errors)\n      return\n    }\n\n    // Do we agree on the checksum? If not, complain.\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      errors.checksumError()\n      respondWithErrors(errors)\n      return\n    }\n\n    // Everything is good so far. Translate the external meeting id to an internal meeting id. If\n    // we can't find the meeting, complain.\n    String internalMeetingId = paramsProcessorUtil.convertToInternalMeetingId(externalMeetingId);\n    log.info(\"Retrieving meeting ${internalMeetingId}\")\n    Meeting meeting = meetingService.getMeeting(internalMeetingId);\n    boolean isRunning = meeting != null && meeting.isRunning();\n\n    response.addHeader(\"Cache-Control\", \"no-cache\")\n    withFormat {\n      xml {\n        render(contentType: \"text/xml\") {\n          render(text: responseBuilder.buildIsMeetingRunning(isRunning, RESP_CODE_SUCCESS), contentType: \"text/xml\")\n        }\n      }\n    }\n  }\n\n  /************************************\n   * END API\n   ************************************/\n  def end = {\n    String API_CALL = \"end\"\n\n    log.debug CONTROLLER_NAME + \"#${API_CALL}\"\n\n    // BEGIN - backward compatibility\n    if (StringUtils.isEmpty(params.checksum)) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n\n    if (!StringUtils.isEmpty(params.meetingID)) {\n      params.meetingID = StringUtils.strip(params.meetingID);\n      if (StringUtils.isEmpty(params.meetingID)) {\n        invalid(\"missingParamMeetingID\", \"You must specify a meeting ID for the meeting.\");\n        return\n      }\n    } else {\n      invalid(\"missingParamMeetingID\", \"You must specify a meeting ID for the meeting.\");\n      return\n    }\n\n    if (StringUtils.isEmpty(params.password)) {\n      invalid(\"invalidPassword\", \"You must supply the moderator password for this call.\");\n      return\n    }\n\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n    // END - backward compatibility\n\n    ApiErrors errors = new ApiErrors()\n\n    // Do we have a checksum? If none, complain.\n    if (StringUtils.isEmpty(params.checksum)) {\n      errors.missingParamError(\"checksum\");\n    }\n\n    // Do we have a meeting id? If none, complain.\n    if (!StringUtils.isEmpty(params.meetingID)) {\n      params.meetingID = StringUtils.strip(params.meetingID);\n      if (StringUtils.isEmpty(params.meetingID)) {\n        errors.missingParamError(\"meetingID\");\n      }\n    } else {\n      errors.missingParamError(\"meetingID\");\n    }\n    String externalMeetingId = params.meetingID\n\n    // Do we have a password? If not, complain.\n    String modPW = params.password\n    if (StringUtils.isEmpty(modPW)) {\n      errors.missingParamError(\"password\");\n    }\n\n    if (errors.hasErrors()) {\n      respondWithErrors(errors)\n      return\n    }\n\n    // Do we agree on the checksum? If not, complain.\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      errors.checksumError()\n      respondWithErrors(errors)\n      return\n    }\n\n    // Everything is good so far. Translate the external meeting id to an internal meeting id. If\n    // we can't find the meeting, complain.\n    String internalMeetingId = paramsProcessorUtil.convertToInternalMeetingId(externalMeetingId);\n    log.info(\"Retrieving meeting ${internalMeetingId}\")\n    Meeting meeting = meetingService.getMeeting(internalMeetingId);\n    if (meeting == null) {\n      // BEGIN - backward compatibility\n      invalid(\"notFound\", \"We could not find a meeting with that meeting ID - perhaps the meeting is not yet running?\");\n      return;\n      // END - backward compatibility\n\n      errors.invalidMeetingIdError();\n      respondWithErrors(errors)\n      return;\n    }\n\n    if (meeting.getModeratorPassword().equals(modPW) == false) {\n      // BEGIN - backward compatibility\n      invalid(\"invalidPassword\", \"You must supply the moderator password for this call.\");\n      return;\n      // END - backward compatibility\n\n      errors.invalidPasswordError();\n      respondWithErrors(errors)\n      return;\n    }\n\n    Map<String, Object> logData = new HashMap<String, Object>();\n    logData.put(\"meetingid\", meeting.getInternalId());\n    logData.put(\"extMeetingid\", meeting.getExternalId());\n    logData.put(\"name\", meeting.getName());\n    logData.put(\"logCode\", \"end_api\");\n    logData.put(\"description\", \"Handle END API.\");\n\n    Gson gson = new Gson();\n    String logStr = gson.toJson(logData);\n\n    log.info(\" --analytics-- data=\" + logStr);\n\n    meetingService.endMeeting(meeting.getInternalId());\n\n    response.addHeader(\"Cache-Control\", \"no-cache\")\n    withFormat {\n      xml {\n        render(contentType: \"text/xml\") {\n          render(text: responseBuilder.buildEndRunning(\"sentEndMeetingRequest\", \"A request to end the meeting was sent.  Please wait a few seconds, and then use the getMeetingInfo or isMeetingRunning API calls to verify that it was ended.\", RESP_CODE_SUCCESS), contentType: \"text/xml\")\n        }\n      }\n    }\n  }\n\n  /*****************************************\n   * GETMEETINGINFO API\n   *****************************************/\n  def getMeetingInfo = {\n    String API_CALL = \"getMeetingInfo\"\n    log.debug CONTROLLER_NAME + \"#${API_CALL}\"\n\n    // BEGIN - backward compatibility\n    if (StringUtils.isEmpty(params.checksum)) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n\n    if (!StringUtils.isEmpty(params.meetingID)) {\n      params.meetingID = StringUtils.strip(params.meetingID);\n      if (StringUtils.isEmpty(params.meetingID)) {\n        invalid(\"missingParamMeetingID\", \"You must specify a meeting ID for the meeting.\");\n        return\n      }\n    } else {\n      invalid(\"missingParamMeetingID\", \"You must specify a meeting ID for the meeting.\");\n      return\n    }\n\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n    // END - backward compatibility\n\n    ApiErrors errors = new ApiErrors()\n\n    // Do we have a checksum? If none, complain.\n    if (StringUtils.isEmpty(params.checksum)) {\n      errors.missingParamError(\"checksum\");\n    }\n\n    // Do we have a meeting id? If none, complain.\n    if (!StringUtils.isEmpty(params.meetingID)) {\n      params.meetingID = StringUtils.strip(params.meetingID);\n      if (StringUtils.isEmpty(params.meetingID)) {\n        errors.missingParamError(\"meetingID\");\n      }\n    } else {\n      errors.missingParamError(\"meetingID\");\n    }\n    String externalMeetingId = params.meetingID\n\n    if (errors.hasErrors()) {\n      respondWithErrors(errors)\n      return\n    }\n\n    // Do we agree on the checksum? If not, complain.\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      errors.checksumError()\n      respondWithErrors(errors)\n      return\n    }\n\n    // Everything is good so far. Translate the external meeting id to an internal meeting id. If\n    // we can't find the meeting, complain.\n    String internalMeetingId = paramsProcessorUtil.convertToInternalMeetingId(externalMeetingId);\n    log.info(\"Retrieving meeting ${internalMeetingId}\")\n    Meeting meeting = meetingService.getMeeting(internalMeetingId);\n    if (meeting == null) {\n      // BEGIN - backward compatibility\n      invalid(\"notFound\", \"We could not find a meeting with that meeting ID\");\n      return;\n      // END - backward compatibility\n\n      errors.invalidMeetingIdError();\n      respondWithErrors(errors)\n      return;\n    }\n\n    withFormat {\n      xml {\n        render(text: responseBuilder.buildGetMeetingInfoResponse(meeting, RESP_CODE_SUCCESS), contentType: \"text/xml\")\n      }\n    }\n  }\n\n  /************************************\n   *  GETMEETINGS API\n   ************************************/\n  def getMeetingsHandler = {\n    String API_CALL = \"getMeetings\"\n    log.debug CONTROLLER_NAME + \"#${API_CALL}\"\n\n    // BEGIN - backward compatibility\n    if (StringUtils.isEmpty(params.checksum)) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n    // END - backward compatibility\n\n    ApiErrors errors = new ApiErrors()\n\n    // Do we have a checksum? If none, complain.\n    if (StringUtils.isEmpty(params.checksum)) {\n      errors.missingParamError(\"checksum\");\n    }\n\n    if (errors.hasErrors()) {\n      respondWithErrors(errors)\n      return\n    }\n\n    // Do we agree on the checksum? If not, complain.\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      errors.checksumError()\n      respondWithErrors(errors)\n      return\n    }\n\n    Collection<Meeting> mtgs = meetingService.getMeetings();\n\n    if (mtgs == null || mtgs.isEmpty()) {\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n      withFormat {\n        xml {\n          render(text: responseBuilder.buildGetMeetingsResponse(mtgs, \"noMeetings\", \"no meetings were found on this server\", RESP_CODE_SUCCESS), contentType: \"text/xml\")\n        }\n      }\n    } else {\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n\n      withFormat {\n        xml {\n          render(text: responseBuilder.buildGetMeetingsResponse(mtgs, null, null, RESP_CODE_SUCCESS), contentType: \"text/xml\")\n        }\n      }\n    }\n  }\n\n  /************************************\n   *  GETSESSIONS API\n   ************************************/\n  def getSessionsHandler = {\n    String API_CALL = \"getSessions\"\n    log.debug CONTROLLER_NAME + \"#${API_CALL}\"\n\n    // BEGIN - backward compatibility\n    if (StringUtils.isEmpty(params.checksum)) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n    // END - backward compatibility\n\n    ApiErrors errors = new ApiErrors()\n\n    // Do we have a checksum? If none, complain.\n    if (StringUtils.isEmpty(params.checksum)) {\n      errors.missingParamError(\"checksum\");\n    }\n\n    if (errors.hasErrors()) {\n      respondWithErrors(errors)\n      return\n    }\n\n    // Do we agree on the checksum? If not, complain.\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      errors.checksumError()\n      respondWithErrors(errors)\n      return\n    }\n\n    Collection<UserSession> sssns = meetingService.getSessions();\n\n    if (sssns == null || sssns.isEmpty()) {\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n      withFormat {\n        xml {\n          render(text: responseBuilder.buildGetSessionsResponse(sssns, \"noSessions\", \"no sessions were found on this serverr\", RESP_CODE_SUCCESS), contentType: \"text/xml\")\n        }\n      }\n    } else {\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n      withFormat {\n        xml {\n          render(contentType: \"text/xml\") {\n            render(text: responseBuilder.buildGetSessionsResponse(sssns, null, null, RESP_CODE_SUCCESS), contentType: \"text/xml\")\n          }\n        }\n      }\n    }\n  }\n\n\n  private static Map<String, String[]> getParameters(ServletRequest request) {\n    // Copy the parameters into our own Map as we can't pass the paramMap\n    // from the request as it's an unmodifiable map.\n    Map<String, String[]> reqParams = new HashMap<String, String[]>();\n    Map<String, String[]> unModReqParams = request.getParameterMap();\n\n    SortedSet<String> keys = new TreeSet<String>(unModReqParams.keySet());\n\n    for(String key : keys) {\n      reqParams.put(key, unModReqParams.get(key));\n    }\n\n    return reqParams;\n  }\n\n  /***********************************************\n   * POLL API\n   ***********************************************/\n  def setPollXML = {\n    String API_CALL = \"setPollXML\"\n    log.debug CONTROLLER_NAME + \"#${API_CALL}\"\n\n    if (StringUtils.isEmpty(params.checksum)) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n\n    if (StringUtils.isEmpty(params.pollXML)) {\n      invalid(\"configXMLError\", \"You did not pass a poll XML\")\n      return\n    }\n\n    if (!StringUtils.isEmpty(params.meetingID)) {\n      params.meetingID = StringUtils.strip(params.meetingID);\n      if (StringUtils.isEmpty(params.meetingID)) {\n        invalid(\"missingParamMeetingID\", \"You must specify a meeting ID for the meeting.\");\n        return\n      }\n    } else {\n      invalid(\"missingParamMeetingID\", \"You must specify a meeting ID for the meeting.\");\n      return\n    }\n\n    // Translate the external meeting id into an internal meeting id.\n    String internalMeetingId = paramsProcessorUtil.convertToInternalMeetingId(params.meetingID);\n    Meeting meeting = meetingService.getMeeting(internalMeetingId);\n    if (meeting == null) {\n      // BEGIN - backward compatibility\n      invalid(\"invalidMeetingIdentifier\", \"The meeting ID that you supplied did not match any existing meetings\");\n      return;\n      // END - backward compatibility\n    }\n\n    Map<String, String[]> reqParams = getParameters(request)\n\n    String pollXML = params.pollXML\n\n    String decodedPollXML;\n\n    try {\n      decodedPollXML = URLDecoder.decode(pollXML, \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      log.error \"Couldn't decode poll XML.\", e\n      invalid(\"pollXMLError\", \"Cannot decode poll XML\")\n      return;\n    }\n\n    if (!paramsProcessorUtil.isPostChecksumSame(API_CALL, reqParams)) {\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n      withFormat {\n        xml {\n          invalid(\"pollXMLChecksumError\", \"pollXMLChecksumError: request did not pass the checksum security check.\")\n        }\n      }\n    } else {\n      def pollxml = new XmlSlurper().parseText(decodedPollXML);\n\n      pollxml.children().each { poll ->\n        String title = poll.title.text();\n        String question = poll.question.text();\n        String questionType = poll.questionType.text();\n\n        ArrayList<String> answers = new ArrayList<String>();\n        poll.answers.children().each { answer ->\n          answers.add(answer.text());\n        }\n\n        //send poll to BigBlueButton Apps\n        meetingService.createdPolls(meeting.getInternalId(), title, question, questionType, answers);\n      }\n\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n      withFormat {\n        xml {\n          // No need to use the response builder here until we have a more complex response\n          render(text: \"<response><returncode>$RESP_CODE_SUCCESS</returncode></response>\", contentType: \"text/xml\")\n        }\n      }\n    }\n  }\n\n  /***********************************************\n   * CONFIG API\n   ***********************************************/\n  def setConfigXML = {\n    String API_CALL = \"setConfigXML\"\n    log.debug CONTROLLER_NAME + \"#${API_CALL}\"\n\n    if (StringUtils.isEmpty(params.checksum)) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n\n    if (StringUtils.isEmpty(params.configXML)) {\n      invalid(\"configXMLError\", \"You did not pass a config XML\")\n      return\n    }\n\n    if (!StringUtils.isEmpty(params.meetingID)) {\n      params.meetingID = StringUtils.strip(params.meetingID);\n      if (StringUtils.isEmpty(params.meetingID)) {\n        invalid(\"missingParamMeetingID\", \"You must specify a meeting ID for the meeting.\");\n        return\n      }\n    } else {\n      invalid(\"missingParamMeetingID\", \"You must specify a meeting ID for the meeting.\");\n      return\n    }\n\n    // Translate the external meeting id into an internal meeting id.\n    String internalMeetingId = paramsProcessorUtil.convertToInternalMeetingId(params.meetingID);\n    Meeting meeting = meetingService.getMeeting(internalMeetingId);\n    if (meeting == null) {\n      // BEGIN - backward compatibility\n      invalid(\"invalidMeetingIdentifier\", \"The meeting ID that you supplied did not match any existing meetings\");\n      return;\n      // END - backward compatibility\n    }\n\n    Map<String, String[]> reqParams = getParameters(request)\n\n    String configXML = params.configXML\n\n    String decodedConfigXML;\n\n    try {\n      decodedConfigXML = URLDecoder.decode(configXML, \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      log.error(\"Couldn't decode config XML.\");\n      invalid(\"configXMLError\", \"Cannot decode config XML\")\n      return;\n    }\n\n    if (!paramsProcessorUtil.isPostChecksumSame(API_CALL, reqParams)) {\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n      withFormat {\n        xml {\n          invalid(\"configXMLChecksumError\", \"configXMLChecksumError: request did not pass the checksum security check.\")\n        }\n      }\n    } else {\n      boolean defaultConfig = false;\n\n      if (!StringUtils.isEmpty(params.defaultConfig)) {\n        try {\n          defaultConfig = Boolean.parseBoolean(params.defaultConfig);\n        } catch (Exception e) {\n          defaultConfig = false;\n        }\n      }\n\n      String token = meeting.storeConfig(defaultConfig, decodedConfigXML);\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n      withFormat {\n        xml {\n          // No need to use the response builder here until we have a more complex response\n          render(text: \"<response><returncode>$RESP_CODE_SUCCESS</returncode><configToken>$token</configToken></response>\", contentType: \"text/xml\")\n        }\n      }\n    }\n  }\n\n  def getDefaultConfigXML = {\n\n    String API_CALL = \"getDefaultConfigXML\"\n    ApiErrors errors = new ApiErrors();\n\n    // BEGIN - backward compatibility\n    if (StringUtils.isEmpty(params.checksum)) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n    // END - backward compatibility\n\n\n    // Do we agree on the checksum? If not, complain.\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      errors.checksumError()\n      respondWithErrors(errors)\n      return\n    }\n\n    String defConfigXML = paramsProcessorUtil.getDefaultConfigXML();\n    if (StringUtils.isEmpty(defConfigXML)) {\n      // BEGIN - backward compatibility\n      invalid(\"noConfigFound\", \"We could not find a config for this request.\", REDIRECT_RESPONSE);\n      return\n      // END - backward compatibility\n\n      errors.noConfigFound();\n      respondWithErrors(errors);\n    }\n\n    response.addHeader(\"Cache-Control\", \"no-cache\")\n    render text: defConfigXML, contentType: 'text/xml'\n  }\n\n  def configXML = {\n    String API_CALL = 'configXML'\n    log.debug CONTROLLER_NAME + \"#${API_CALL}\"\n\n    String logoutUrl = paramsProcessorUtil.getDefaultLogoutUrl()\n    boolean reject = false\n    String sessionToken = sanitizeSessionToken(params.sessionToken)\n    if (!hasValidSession(sessionToken)) {\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n      withFormat {\n        xml {\n          render(text: responseBuilder.buildConfgXmlReject(\"Could not find conference.\", logoutUrl, RESP_CODE_FAILED), contentType: \"text/xml\")\n        }\n      }\n    } else {\n      UserSession us = getUserSession(sessionToken)\n      if (StringUtils.isEmpty(us.configXML)) {\n        // BEGIN - backward compatibility\n        invalid(\"noConfigFound\", \"We could not find a config for this request.\", REDIRECT_RESPONSE);\n        return\n        // END - backward compatibility\n\n        errors.noConfigFound();\n        respondWithErrors(errors);\n      }\n\n      Map<String, Object> logData = new HashMap<String, Object>();\n      logData.put(\"meetingId\", us.meetingID);\n      logData.put(\"externalMeetingId\", us.externMeetingID);\n      logData.put(\"name\", us.fullname);\n      logData.put(\"userId\", us.internalUserId);\n      logData.put(\"sessionToken\", sessionToken);\n      logData.put(\"logCode\", \"handle_configxml_api\");\n      logData.put(\"description\", \"Handling ConfigXml API.\");\n\n      Gson gson = new Gson();\n      String logStr = gson.toJson(logData);\n\n      log.info(\" --analytics-- data=\" + logStr);\n\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n      render text: us.configXML, contentType: 'text/xml'\n    }\n  }\n\n  /**********************************************\n   * GUEST WAIT API\n   *********************************************/\n  def guestWaitHandler = {\n    String API_CALL = 'guestWait'\n    log.debug CONTROLLER_NAME + \"#${API_CALL}\"\n    ApiErrors errors = new ApiErrors()\n    boolean reject = false;\n    String sessionToken = sanitizeSessionToken(params.sessionToken)\n\n    UserSession us = getUserSession(sessionToken);\n    Meeting meeting = null;\n\n    if (us == null) {\n      log.debug(\"No user with session token.\")\n      reject = true;\n    } else {\n      meeting = meetingService.getMeeting(us.meetingID);\n      if (meeting == null || meeting.isForciblyEnded()) {\n        log.debug(\"Meeting not found.\")\n        reject = true\n      }\n    }\n\n    // Determine the logout url so we can send the user there.\n    String logoutUrl = us != null ? us.logoutUrl : paramsProcessorUtil.getDefaultLogoutUrl()\n\n    if (reject) {\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n      withFormat {\n        json {\n          def builder = new JsonBuilder()\n          builder.response {\n            returncode RESP_CODE_FAILED\n            message \"Could not process waiting guest.\"\n            logoutURL logoutUrl\n          }\n          render(contentType: \"application/json\", text: builder.toPrettyString())\n        }\n      }\n    } else {\n      //check if exists the param redirect\n      boolean redirectClient = true;\n\n      // Get the client url we stored in the join api call before\n      // being told to wait.\n      String clientURL = us.clientUrl;\n      log.info(\"clientURL = \" + clientURL)\n      log.info(\"redirect = .\" + redirectClient)\n      if (!StringUtils.isEmpty(params.redirect)) {\n        try {\n          redirectClient = Boolean.parseBoolean(params.redirect);\n          log.info(\"redirect 2 = .\" + redirectClient)\n        } catch (Exception e) {\n          redirectClient = true;\n        }\n      }\n\n      // The client url is ovewriten. Let's allow it.\n      if (!StringUtils.isEmpty(params.clientURL)) {\n        clientURL = params.clientURL;\n      }\n\n      String guestWaitStatus = us.guestStatus\n\n      log.debug(\"GuestWaitStatus = \" + guestWaitStatus)\n\n      String msgKey = \"guestAllowed\"\n      String msgValue = \"Guest allowed to join meeting.\"\n\n      String destUrl = clientURL\n      log.debug(\"destUrl = \" + destUrl)\n\n\n      if (guestWaitStatus.equals(GuestPolicy.WAIT)) {\n        clientURL = paramsProcessorUtil.getDefaultGuestWaitURL();\n        destUrl = clientURL + \"?sessionToken=\" + sessionToken\n        log.debug(\"GuestPolicy.WAIT - destUrl = \" + destUrl)\n        msgKey = \"guestWait\"\n        msgValue = \"Guest waiting for approval to join meeting.\"\n        // We force the response to not do a redirect. Otherwise,\n        // the client would just be redirecting into this endpoint.\n        redirectClient = false\n\n        Map<String, Object> logData = new HashMap<String, Object>();\n        logData.put(\"meetingid\", us.meetingID);\n        logData.put(\"extMeetingid\", us.externMeetingID);\n        logData.put(\"name\", us.fullname);\n        logData.put(\"userid\", us.internalUserId);\n        logData.put(\"sessionToken\", sessionToken);\n        logData.put(\"logCode\", \"guest_wait\");\n        logData.put(\"description\", \"Guest waiting for approval.\");\n\n        Gson gson = new Gson();\n        String logStr = gson.toJson(logData);\n\n        log.info(\" --analytics-- data=\" + logStr);\n\n      } else if (guestWaitStatus.equals(GuestPolicy.DENY)) {\n        destUrl = meeting.getLogoutUrl()\n        msgKey = \"guestDenied\"\n        msgValue = \"Guest denied to join meeting.\"\n\n        Map<String, Object> logData = new HashMap<String, Object>();\n        logData.put(\"meetingid\", us.meetingID);\n        logData.put(\"extMeetingid\", us.externMeetingID);\n        logData.put(\"name\", us.fullname);\n        logData.put(\"userid\", us.internalUserId);\n        logData.put(\"sessionToken\", sessionToken);\n        logData.put(\"logCode\", \"guest_denied\");\n        logData.put(\"description\", \"Guest denied.\");\n\n        Gson gson = new Gson();\n        String logStr = gson.toJson(logData);\n\n        log.info(\" --analytics-- data=\" + logStr);\n      }\n\n      if (redirectClient) {\n        log.info(\"Redirecting to ${destUrl}\");\n        redirect(url: destUrl);\n      } else {\n        log.info(\"Successfully joined. Sending XML response.\");\n        response.addHeader(\"Cache-Control\", \"no-cache\")\n        withFormat {\n          json {\n            def builder = new JsonBuilder()\n            builder.response {\n              returncode RESP_CODE_SUCCESS\n              messageKey msgKey\n              message msgValue\n              meeting_id us.meetingID\n              user_id us.internalUserId\n              auth_token us.authToken\n              session_token session[sessionToken]\n              guestStatus guestWaitStatus\n              url destUrl\n            }\n            render(contentType: \"application/json\", text: builder.toPrettyString())\n          }\n        }\n      }\n    }\n  }\n\n  /***********************************************\n   * ENTER API\n   ***********************************************/\n  def enter = {\n    boolean reject = false;\n\n    String sessionToken = sanitizeSessionToken(params.sessionToken)\n    UserSession us = getUserSession(sessionToken);\n    Meeting meeting = null;\n\n    String respMessage = \"Session \" + sessionToken + \" not found.\"\n\n    if (!hasValidSession(sessionToken)) {\n      reject = true;\n    } else {\n      meeting = meetingService.getMeeting(us.meetingID);\n      if (meeting == null || meeting.isForciblyEnded()) {\n        reject = true\n        respMessage = \"Meeting not found or ended for session \" + sessionToken + \".\"\n      } else {\n        if (hasReachedMaxParticipants(meeting, us)) {\n          reject = true;\n          respMessage = \"The number of participants allowed for this meeting has been reached.\";\n        } else {\n          meeting.userEntered(us.internalUserId);\n        }\n      }\n      if (us.guestStatus.equals(GuestPolicy.DENY)) {\n        respMessage = \"User denied for user with session \" + sessionToken + \".\"\n        reject = true\n      }\n    }\n\n    if (reject) {\n      // Determine the logout url so we can send the user there.\n      String logoutUrl = paramsProcessorUtil.getDefaultLogoutUrl()\n\n      if (us != null) {\n        logoutUrl = us.logoutUrl\n      }\n\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n      withFormat {\n        json {\n          def builder = new JsonBuilder()\n          builder.response {\n            returncode RESP_CODE_FAILED\n            message respMessage\n            logoutURL logoutUrl\n          }\n          render(contentType: \"application/json\", text: builder.toPrettyString())\n        }\n      }\n    } else {\n\n      Map<String, String> userCustomData = paramsProcessorUtil.getUserCustomData(params);\n\n      // Generate a new userId for this user. This prevents old connections from\n      // removing the user when the user reconnects after being disconnected. (ralam jan 22, 2015)\n      // We use underscore (_) to associate userid with the user. We are also able to track\n      // how many times a user reconnects or refresh the browser.\n      String newInternalUserID = us.internalUserId //+ \"_\" + us.incrementConnectionNum()\n\n      Map<String, Object> logData = new HashMap<String, Object>();\n      logData.put(\"meetingid\", us.meetingID);\n      logData.put(\"extMeetingid\", us.externMeetingID);\n      logData.put(\"name\", us.fullname);\n      logData.put(\"userid\", newInternalUserID);\n      logData.put(\"sessionToken\", sessionToken);\n      logData.put(\"logCode\", \"handle_enter_api\");\n      logData.put(\"description\", \"Handling ENTER API.\");\n\n      Gson gson = new Gson();\n      String logStr = gson.toJson(logData);\n\n      log.info(\" --analytics-- data=\" + logStr);\n\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n      withFormat {\n        json {\n          def builder = new JsonBuilder()\n          builder.response {\n            returncode RESP_CODE_SUCCESS\n            fullname us.fullname\n            confname us.conferencename\n            meetingID us.meetingID\n            externMeetingID us.externMeetingID\n            externUserID us.externUserID\n            internalUserID newInternalUserID\n            authToken us.authToken\n            role us.role\n            guest us.guest\n            guestStatus us.guestStatus\n            conference us.conference\n            room us.room\n            voicebridge us.voicebridge\n            dialnumber meeting.getDialNumber()\n            webvoiceconf us.webvoiceconf\n            mode us.mode\n            record us.record\n            isBreakout meeting.isBreakout()\n            logoutTimer meeting.getLogoutTimer()\n            allowStartStopRecording meeting.getAllowStartStopRecording()\n            welcome us.welcome\n            if (!StringUtils.isEmpty(meeting.moderatorOnlyMessage) && us.role.equals(ROLE_MODERATOR)) {\n              modOnlyMessage meeting.moderatorOnlyMessage\n            }\n            if (!StringUtils.isEmpty(meeting.bannerText)) {\n              bannerText meeting.getBannerText()\n              bannerColor meeting.getBannerColor()\n            }\n            customLogoURL meeting.getCustomLogoURL()\n            customCopyright meeting.getCustomCopyright()\n            muteOnStart meeting.getMuteOnStart()\n            allowModsToUnmuteUsers meeting.getAllowModsToUnmuteUsers()\n            logoutUrl us.logoutUrl\n            defaultLayout us.defaultLayout\n            avatarURL us.avatarURL\n            if (meeting.breakoutRoomsParams != null) {\n              breakoutRooms {\n                enabled meeting.breakoutRoomsParams.enabled\n                record meeting.breakoutRoomsParams.record\n                privateChatEnabled meeting.breakoutRoomsParams.privateChatEnabled\n              }\n            }\n            customdata (\n              meeting.getUserCustomData(us.externUserID).collect { k, v ->\n                [\"$k\": v]\n              }\n            )\n            metadata (\n              meeting.getMetadata().collect { k, v ->\n                [\"$k\": v]\n              }\n            )\n          }\n          render(contentType: \"application/json\", text: builder.toPrettyString())\n        }\n      }\n    }\n  }\n\n  /***********************************************\n   * STUN/TURN API\n   ***********************************************/\n  def stuns = {\n    boolean reject = false;\n\n    String sessionToken = sanitizeSessionToken(params.sessionToken)\n    UserSession us = getUserSession(sessionToken);\n    Meeting meeting = null;\n\n    if (!hasValidSession(sessionToken)) {\n      reject = true;\n    } else {\n      meeting = meetingService.getMeeting(us.meetingID);\n      if (meeting == null || meeting.isForciblyEnded()) {\n        reject = true\n      }\n    }\n\n    if (reject) {\n      String logoutUrl = paramsProcessorUtil.getDefaultLogoutUrl()\n\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n      withFormat {\n        json {\n          def builder = new JsonBuilder()\n          builder {\n            returncode RESP_CODE_FAILED\n            message \"Could not find conference.\"\n            logoutURL logoutUrl\n          }\n          render(contentType: \"application/json\", text: builder.toPrettyString())\n        }\n      }\n    } else {\n      Set<StunServer> stuns = stunTurnService.getStunServers()\n      Set<TurnEntry> turns = stunTurnService.getStunAndTurnServersFor(us.internalUserId)\n      Set<RemoteIceCandidate> candidates = stunTurnService.getRemoteIceCandidates()\n\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n      withFormat {\n        json {\n          def builder = new JsonBuilder()\n          builder {\n            stunServers (\n              stuns.collect { stun ->\n                [url: stun.url]\n              }\n            )\n            turnServers (\n              turns.collect { turn ->\n                [\n                  username: turn.username,\n                  password: turn.password,\n                  url: turn.url,\n                  ttl: turn.ttl\n                ]\n              }\n            )\n            remoteIceCandidates (\n              candidates.collect { candidate ->\n                [ip: candidate.ip ]\n              }\n            )\n          }\n          render(contentType: \"application/json\", text: builder.toPrettyString())\n        }\n      }\n    }\n  }\n\n  /*************************************************\n   * SIGNOUT API\n   *************************************************/\n  def signOut = {\n\n    String sessionToken = sanitizeSessionToken(params.sessionToken)\n\n    Meeting meeting = null;\n\n    if (sessionToken != null) {\n\n      UserSession us = meetingService.removeUserSessionWithAuthToken(sessionToken);\n      if (us != null) {\n        Map<String, Object> logData = new HashMap<String, Object>();\n        logData.put(\"meetingid\", us.meetingID);\n        logData.put(\"extMeetingid\", us.externMeetingID);\n        logData.put(\"name\", us.fullname);\n        logData.put(\"userid\", us.internalUserId);\n        logData.put(\"sessionToken\", sessionToken);\n        logData.put(\"message\", \"handle_signout_api\");\n        logData.put(\"logCode\", \"signout_api\");\n        logData.put(\"description\", \"Handling SIGNOUT API.\");\n\n        Gson gson = new Gson();\n        String logStr = gson.toJson(logData);\n        log.info(\" --analytics-- data=\" + logStr);\n      } else {\n        log.info(\"Could not find user session for session token {}\", sessionToken)\n      }\n\n\n      session.removeAttribute(sessionToken)\n    }\n\n    response.addHeader(\"Cache-Control\", \"no-cache\")\n    withFormat {\n      xml {\n        // No need to use the response builder here until we have a more complex response\n        render(text: \"<response><returncode>$RESP_CODE_SUCCESS</returncode></response>\", contentType: \"text/xml\")\n      }\n    }\n  }\n\n  /******************************************************\n   * GET_RECORDINGS API\n   ******************************************************/\n  def getRecordingsHandler = {\n    String API_CALL = \"getRecordings\"\n    log.debug CONTROLLER_NAME + \"#${API_CALL}\"\n\n    // BEGIN - backward compatibility\n    if (StringUtils.isEmpty(params.checksum)) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n    // END - backward compatibility\n\n    ApiErrors errors = new ApiErrors()\n\n    // Do we have a checksum? If none, complain.\n    if (StringUtils.isEmpty(params.checksum)) {\n      errors.missingParamError(\"checksum\");\n      respondWithErrors(errors)\n      return\n    }\n\n    log.debug request.getQueryString()\n\n    // Do we agree on the checksum? If not, complain.\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      errors.checksumError()\n      respondWithErrors(errors)\n      return\n    }\n\n    List<String> externalMeetingIds = new ArrayList<String>();\n    if (!StringUtils.isEmpty(params.meetingID)) {\n      externalMeetingIds = paramsProcessorUtil.decodeIds(params.meetingID);\n    }\n\n    ArrayList<String> internalRecordIds = new ArrayList<String>()\n    if (!StringUtils.isEmpty(params.recordID)) {\n      internalRecordIds = paramsProcessorUtil.decodeIds(params.recordID)\n    }\n\n    ArrayList<String> states = new ArrayList<String>()\n    if (!StringUtils.isEmpty(params.state)) {\n      states = paramsProcessorUtil.decodeIds(params.state)\n    }\n\n    // Everything is good so far.\n    if (internalRecordIds.size() == 0 && externalMeetingIds.size() > 0) {\n      // No recordIDs, process the request based on meetingID(s)\n      // Translate the external meeting ids to internal meeting ids (which is the seed for the recordIDs).\n      internalRecordIds = paramsProcessorUtil.convertToInternalMeetingId(externalMeetingIds);\n    }\n\n    for(String intRecId : internalRecordIds) {\n      log.debug intRecId\n    }\n\n    Map<String, String> metadataFilters = ParamsProcessorUtil.processMetaParam(params);\n\n    def getRecordingsResult = meetingService.getRecordings2x(internalRecordIds, states, metadataFilters)\n\n    withFormat {\n      xml {\n        render(text: getRecordingsResult, contentType: \"text/xml\")\n      }\n    }\n  }\n\n  /******************************************************\n   * PUBLISH_RECORDINGS API\n   ******************************************************/\n  def publishRecordings = {\n    String API_CALL = \"publishRecordings\"\n    log.debug CONTROLLER_NAME + \"#${API_CALL}\"\n\n    // BEGIN - backward compatibility\n    if (StringUtils.isEmpty(params.checksum)) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n\n    if (StringUtils.isEmpty(params.recordID)) {\n      invalid(\"missingParamRecordID\", \"You must specify a recordID.\");\n      return\n    }\n\n    if (StringUtils.isEmpty(params.publish)) {\n      invalid(\"missingParamPublish\", \"You must specify a publish value true or false.\");\n      return\n    }\n\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n    // END - backward compatibility\n\n    ApiErrors errors = new ApiErrors()\n\n    // Do we have a checksum? If none, complain.\n    if (StringUtils.isEmpty(params.checksum)) {\n      errors.missingParamError(\"checksum\");\n    }\n\n    // Do we have a recording id? If none, complain.\n    String recordId = params.recordID\n    if (StringUtils.isEmpty(recordId)) {\n      errors.missingParamError(\"recordID\");\n    }\n    // Do we have a publish status? If none, complain.\n    String publish = params.publish\n    if (StringUtils.isEmpty(publish)) {\n      errors.missingParamError(\"publish\");\n    }\n\n    if (errors.hasErrors()) {\n      respondWithErrors(errors)\n      return\n    }\n\n    // Do we agree on the checksum? If not, complain.\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      errors.checksumError()\n      respondWithErrors(errors)\n      return\n    }\n\n    ArrayList<String> recordIdList = new ArrayList<String>();\n    if (!StringUtils.isEmpty(recordId)) {\n      recordIdList = paramsProcessorUtil.decodeIds(recordId);\n    }\n\n    if (!meetingService.existsAnyRecording(recordIdList)) {\n      // BEGIN - backward compatibility\n      invalid(\"notFound\", \"We could not find recordings\");\n      return;\n      // END - backward compatibility\n\n    }\n\n    meetingService.setPublishRecording(recordIdList, publish.toBoolean());\n    withFormat {\n      xml {\n        // No need to use the response builder here until we have a more complex response\n        render(text: \"<response><returncode>$RESP_CODE_SUCCESS</returncode><published>$publish</published></response>\", contentType: \"text/xml\")\n      }\n    }\n  }\n\n  /******************************************************\n   * DELETE_RECORDINGS API\n   ******************************************************/\n  def deleteRecordings = {\n    String API_CALL = \"deleteRecordings\"\n    log.debug CONTROLLER_NAME + \"#${API_CALL}\"\n\n    // BEGIN - backward compatibility\n    if (StringUtils.isEmpty(params.checksum)) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n\n    if (StringUtils.isEmpty(params.recordID)) {\n      invalid(\"missingParamRecordID\", \"You must specify a recordID.\");\n      return\n    }\n\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n    // END - backward compatibility\n\n    ApiErrors errors = new ApiErrors()\n\n    // Do we have a checksum? If none, complain.\n    if (StringUtils.isEmpty(params.checksum)) {\n      errors.missingParamError(\"checksum\");\n    }\n\n    // Do we have a recording id? If none, complain.\n    String recordId = params.recordID\n    if (StringUtils.isEmpty(recordId)) {\n      errors.missingParamError(\"recordID\");\n    }\n\n    if (errors.hasErrors()) {\n      respondWithErrors(errors)\n      return\n    }\n\n    // Do we agree on the checksum? If not, complain.\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      errors.checksumError()\n      respondWithErrors(errors)\n      return\n    }\n\n    List<String> recordIdList = new ArrayList<String>();\n    if (!StringUtils.isEmpty(recordId)) {\n      recordIdList = paramsProcessorUtil.decodeIds(recordId);\n    }\n\n    if (!meetingService.existsAnyRecording(recordIdList)) {\n      // BEGIN - backward compatibility\n      invalid(\"notFound\", \"We could not find recordings\");\n      return;\n      // END - backward compatibility\n    }\n\n    meetingService.deleteRecordings(recordIdList);\n    withFormat {\n      xml {\n        // No need to use the response builder here until we have a more complex response\n        render(text: \"<response><returncode>$RESP_CODE_SUCCESS</returncode><deleted>true</deleted></response>\", contentType: \"text/xml\")\n      }\n    }\n  }\n\n  /******************************************************\n   * UPDATE_RECORDINGS API\n   ******************************************************/\n  def updateRecordingsHandler = {\n    String API_CALL = \"updateRecordings\"\n    log.debug CONTROLLER_NAME + \"#${API_CALL}\"\n\n    // BEGIN - backward compatibility\n    if (StringUtils.isEmpty(params.checksum)) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n\n    if (StringUtils.isEmpty(params.recordID)) {\n      invalid(\"missingParamRecordID\", \"You must specify a recordID.\");\n      return\n    }\n\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      invalid(\"checksumError\", \"You did not pass the checksum security check\")\n      return\n    }\n    // END - backward compatibility\n\n    ApiErrors errors = new ApiErrors()\n\n    // Do we have a checksum? If none, complain.\n    if (StringUtils.isEmpty(params.checksum)) {\n      errors.missingParamError(\"checksum\");\n    }\n\n    // Do we have a recording id? If none, complain.\n    String recordId = params.recordID\n    if (StringUtils.isEmpty(recordId)) {\n      errors.missingParamError(\"recordID\");\n    }\n\n    if (errors.hasErrors()) {\n      respondWithErrors(errors)\n      return\n    }\n\n    // Do we agree on the checksum? If not, complain.\n    if (!paramsProcessorUtil.isChecksumSame(API_CALL, params.checksum, request.getQueryString())) {\n      errors.checksumError()\n      respondWithErrors(errors)\n      return\n    }\n\n    List<String> recordIdList = new ArrayList<String>();\n    if (!StringUtils.isEmpty(recordId)) {\n      recordIdList = paramsProcessorUtil.decodeIds(recordId);\n    }\n\n    if (!meetingService.existsAnyRecording(recordIdList)) {\n      // BEGIN - backward compatibility\n      invalid(\"notFound\", \"We could not find recordings\");\n      return;\n      // END - backward compatibility\n    }\n\n    //Execute code specific for this call\n    Map<String, String> metaParams = ParamsProcessorUtil.processMetaParam(params)\n    if (!metaParams.empty) {\n      //Proceed with the update\n      meetingService.updateRecordings(recordIdList, metaParams);\n    }\n    withFormat {\n      xml {\n        // No need to use the response builder here until we have a more complex response\n        render(text: \"<response><returncode>$RESP_CODE_SUCCESS</returncode><updated>true</updated></response>\", contentType: \"text/xml\")\n      }\n    }\n  }\n\n  def uploadDocuments(conf) { //\n    log.debug(\"ApiController#uploadDocuments(${conf.getInternalId()})\");\n\n    String requestBody = request.inputStream == null ? null : request.inputStream.text;\n    requestBody = StringUtils.isEmpty(requestBody) ? null : requestBody;\n\n    if (requestBody == null) {\n      downloadAndProcessDocument(presentationService.defaultUploadedPresentation, conf.getInternalId(), true /* default presentation */, '');\n    } else {\n      def xml = new XmlSlurper().parseText(requestBody);\n      xml.children().each { module ->\n        log.debug(\"module config found: [${module.@name}]\");\n\n        if (\"presentation\".equals(module.@name.toString())) {\n          // need to iterate over presentation files and process them\n          Boolean current = true;\n          module.children().each { document ->\n            if (!StringUtils.isEmpty(document.@url.toString())) {\n              def fileName;\n              if (!StringUtils.isEmpty(document.@filename.toString())) {\n                log.debug(\"user provided filename: [${module.@filename}]\");\n                fileName = document.@filename.toString();\n              }\n              downloadAndProcessDocument(document.@url.toString(), conf.getInternalId(), current /* default presentation */, fileName);\n              current = false;\n            } else if (!StringUtils.isEmpty(document.@name.toString())) {\n              def b64 = new Base64()\n              def decodedBytes = b64.decode(document.text().getBytes())\n              processDocumentFromRawBytes(decodedBytes, document.@name.toString(),\n                  conf.getInternalId(), current /* default presentation */);\n              current = false;\n            } else {\n              log.debug(\"presentation module config found, but it did not contain url or name attributes\");\n            }\n          }\n        }\n      }\n    }\n  }\n\n  def processDocumentFromRawBytes(bytes, presOrigFilename, meetingId, current) {\n    def uploadFailed = false\n    def uploadFailReasons = new ArrayList<String>()\n\n    // Gets the name minus the path from a full fileName.\n    // a/b/c.txt --> c.txt\n    def presFilename =  FilenameUtils.getName(presOrigFilename)\n    def filenameExt = FilenameUtils.getExtension(presOrigFilename)\n    def pres = null\n    def presId = null\n\n    if (presFilename == \"\" || filenameExt == \"\") {\n      log.debug(\"Upload failed. Invalid filename \" + presOrigFilename)\n      uploadFailReasons.add(\"invalid_filename\")\n      uploadFailed = true\n    } else {\n      String presentationDir = presentationService.getPresentationDir()\n      presId = Util.generatePresentationId(presFilename)\n\n      File uploadDir = Util.createPresentationDir(meetingId, presentationDir, presId)\n      if (uploadDir != null) {\n        def newFilename = Util.createNewFilename(presId, filenameExt)\n        pres = new File(uploadDir.absolutePath + File.separatorChar + newFilename);\n\n        FileOutputStream fos = new java.io.FileOutputStream(pres)\n        fos.write(bytes)\n        fos.flush()\n        fos.close()\n      } else {\n        log.warn \"Upload failed. File Empty.\"\n        uploadFailReasons.add(\"failed_to_download_file\")\n        uploadFailed = true\n      }\n    }\n\n    // Hardcode pre-uploaded presentation to the default presentation window\n    processUploadedFile(\"DEFAULT_PRESENTATION_POD\",\n              meetingId,\n              presId,\n              presFilename,\n              pres,\n              current,\n              \"preupload-raw-authz-token\",\n              uploadFailed,\n              uploadFailReasons)\n  }\n\n  def downloadAndProcessDocument(address, meetingId, current, fileName) {\n    log.debug(\"ApiController#downloadAndProcessDocument(${address}, ${meetingId}, ${fileName})\");\n    String presOrigFilename;\n    if (StringUtils.isEmpty(fileName)) {\n      presOrigFilename = address.tokenize(\"/\")[-1];\n    } else {\n      presOrigFilename = fileName;\n    }\n\n    def uploadFailed = false\n    def uploadFailReasons = new ArrayList<String>()\n\n    // Gets the name minus the path from a full fileName.\n    // a/b/c.txt --> c.txt\n    def presFilename =  FilenameUtils.getName(presOrigFilename)\n    def filenameExt = FilenameUtils.getExtension(presOrigFilename)\n    def pres = null\n    def presId\n\n    if (presFilename == \"\" || filenameExt == \"\") {\n      log.debug(\"Upload failed. Invalid filename \" + presOrigFilename)\n      uploadFailReasons.add(\"invalid_filename\")\n      uploadFailed = true\n    } else {\n      String presentationDir = presentationService.getPresentationDir()\n      presId = Util.generatePresentationId(presFilename)\n      File uploadDir = Util.createPresentationDir(meetingId, presentationDir, presId)\n      if (uploadDir != null) {\n        def newFilename = Util.createNewFilename(presId, filenameExt)\n        def newFilePath = uploadDir.absolutePath + File.separatorChar + newFilename\n\n        if (presDownloadService.savePresentation(meetingId, newFilePath, address)) {\n          pres = new File(newFilePath)\n        } else {\n          log.error(\"Failed to download presentation=[${address}], meeting=[${meetingId}], fileName=[${fileName}]\")\n          uploadFailReasons.add(\"failed_to_download_file\")\n          uploadFailed = true\n        }\n      }\n    }\n\n    // Hardcode pre-uploaded presentation to the default presentation window\n    processUploadedFile(\n            \"DEFAULT_PRESENTATION_POD\",\n            meetingId,\n            presId,\n            presFilename,\n            pres,\n            current,\n            \"preupload-download-authz-token\",\n            uploadFailed,\n            uploadFailReasons\n    )\n  }\n\n\n  def processUploadedFile(podId, meetingId, presId, filename, presFile, current, authzToken, uploadFailed, uploadFailReasons ) {\n    def presentationBaseUrl = presentationService.presentationBaseUrl\n    // TODO add podId\n    UploadedPresentation uploadedPres = new UploadedPresentation(podId,\n            meetingId,\n            presId,\n            filename,\n            presentationBaseUrl,\n            current,\n            authzToken,\n            uploadFailed,\n            uploadFailReasons)\n    uploadedPres.setUploadedFile(presFile);\n    presentationService.processUploadedPresentation(uploadedPres);\n  }\n\n  def beforeInterceptor = {\n    if (paramsProcessorUtil.isServiceEnabled() == false) {\n      log.info(\"apiNotEnabled: The API service and/or controller is not enabled on this server.  To use it, you must first enable it.\")\n      // TODO: this doesn't stop the request - so it generates invalid XML\n      //      since the request continues and renders a second response\n      invalid(\"apiNotEnabled\", \"The API service and/or controller is not enabled on this server.  To use it, you must first enable it.\")\n    }\n  }\n\n  def respondWithConference(meeting, msgKey, msg) {\n    response.addHeader(\"Cache-Control\", \"no-cache\")\n    withFormat {\n      xml {\n        log.debug \"Rendering as xml\"\n        render(text: responseBuilder.buildMeeting(meeting, msgKey, msg, RESP_CODE_SUCCESS), contentType: \"text/xml\")\n      }\n    }\n  }\n\n  def getUserSession(token) {\n    if (token == null) {\n      return null\n    }\n\n    UserSession us = meetingService.getUserSessionWithAuthToken(token)\n    if (us == null) {\n      log.info(\"Cannot find UserSession for token ${token}\")\n    }\n\n    return us\n  }\n\n  def sanitizeSessionToken(param) {\n    if (param == null) {\n      log.info(\"sanitizeSessionToken: token is null\")\n      return null\n    }\n\n    if (StringUtils.isEmpty(param)) {\n      log.info(\"sanitizeSessionToken: token is empty\")\n      return null\n    }\n\n    return StringUtils.strip(param)\n  }\n\n  private Boolean hasValidSession(token) {\n    UserSession us = getUserSession(token)\n    if (us == null) {\n      return false\n    }\n\n    if (!session[token]) {\n      log.info(\"Session for token ${token} not found\")\n\n      Boolean allowRequestsWithoutSession = paramsProcessorUtil.getAllowRequestsWithoutSession()\n      if (!allowRequestsWithoutSession) {\n        log.info(\"Meeting related to ${token} doesn't allow requests without session\")\n        return false\n      }\n    }\n\n    log.info(\"Token ${token} is valid\")\n    return true\n  }\n\n  // Validate maxParticipants constraint\n  private Boolean hasReachedMaxParticipants(meeting, us) {\n    // Meeting object calls it maxUsers to build up the drama\n    int maxParticipants = meeting.getMaxUsers();\n    // When is set to 0, the validation is ignored\n    Boolean enabled = maxParticipants > 0;\n    // Users refreshing page or reconnecting must be identified\n    Boolean rejoin = meeting.getUserById(us.internalUserId) != null;\n    // Users that passed enter once, still not joined but somehow re-entered\n    Boolean reenter = meeting.getEnteredUserById(us.internalUserId) != null;\n    // Users that already joined the meeting\n    int joinedUsers = meeting.getUsers().size()\n    // Users that are entering the meeting\n    int enteredUsers = meeting.getEnteredUsers().size()\n\n    Boolean reachedMax = (joinedUsers + enteredUsers) >= maxParticipants;\n    if (enabled && !rejoin && !reenter && reachedMax) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private void respondWithErrors(errorList, redirectResponse = false) {\n    log.debug CONTROLLER_NAME + \"#invalid\"\n    if (redirectResponse) {\n      ArrayList<Object> errors = new ArrayList<Object>();\n      errorList.getErrors().each { error ->\n        Map<String, String> errorMap = new LinkedHashMap<String, String>()\n        errorMap.put(\"key\", error[0])\n        errorMap.put(\"message\", error[1])\n        errors.add(errorMap)\n      }\n\n      JSONArray errorsJSONArray = new JSONArray(errors);\n      log.debug errorsJSONArray\n\n      respondWithRedirect(errorsJSONArray)\n    } else {\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n      withFormat {\n        xml {\n          render(text: responseBuilder.buildErrors(errorList.getErrors(), RESP_CODE_FAILED), contentType: \"text/xml\")\n        }\n        json {\n          log.debug \"Rendering as json\"\n          def builder = new JsonBuilder()\n          builder.response {\n            returncode RESP_CODE_FAILED\n            messageKey key\n            message msg\n          }\n          render(contentType: \"application/json\", text: builder.toPrettyString())\n        }\n      }\n    }\n  }\n\n  //TODO: method added for backward compatibility, it will be removed in next versions after 0.8\n  private void invalid(key, msg, redirectResponse = false) {\n    // Note: This xml scheme will be DEPRECATED.\n    log.debug CONTROLLER_NAME + \"#invalid \" + msg\n    if (redirectResponse) {\n      ArrayList<Object> errors = new ArrayList<Object>();\n      Map<String, String> errorMap = new LinkedHashMap<String, String>()\n      errorMap.put(\"key\", key)\n      errorMap.put(\"message\", msg)\n      errors.add(errorMap)\n\n      JSONArray errorsJSONArray = new JSONArray(errors)\n      log.debug \"JSON Errors {}\", errorsJSONArray.toString()\n\n      respondWithRedirect(errorsJSONArray)\n    } else {\n      response.addHeader(\"Cache-Control\", \"no-cache\")\n      withFormat {\n        xml {\n          render(text: responseBuilder.buildError(key, msg, RESP_CODE_FAILED), contentType: \"text/xml\")\n        }\n        json {\n          log.debug \"Rendering as json\"\n          def builder = new JsonBuilder()\n          builder.response {\n            returncode RESP_CODE_FAILED\n            messageKey key\n            message msg\n          }\n          render(contentType: \"application/json\", text: builder.toPrettyString())\n        }\n      }\n    }\n  }\n\n  private void respondWithRedirect(errorsJSONArray) {\n    String logoutUrl = paramsProcessorUtil.getDefaultLogoutUrl()\n    URI oldUri = URI.create(logoutUrl)\n\n    if (!StringUtils.isEmpty(params.logoutURL)) {\n      try {\n        oldUri = URI.create(params.logoutURL)\n      } catch (Exception e) {\n        // Do nothing, the variable oldUri was already initialized\n      }\n    }\n\n    String newQuery = oldUri.getQuery();\n\n    if (newQuery == null) {\n      newQuery = \"errors=\"\n    } else {\n      newQuery += \"&\" + \"errors=\"\n    }\n    newQuery += errorsJSONArray\n\n    URI newUri = new URI(oldUri.getScheme(), oldUri.getAuthority(), oldUri.getPath(), newQuery, oldUri.getFragment())\n\n    log.debug \"Constructed logout URL {}\", newUri.toString()\n    redirect(url: newUri)\n  }\n\n}\n"], "filenames": ["bigbluebutton-web/grails-app/controllers/org/bigbluebutton/web/controllers/ApiController.groovy"], "buggy_code_start_loc": [247], "buggy_code_end_loc": [247], "fixing_code_start_loc": [248], "fixing_code_end_loc": [250], "type": "CWE-116", "message": "web/controllers/ApiController.groovy in BigBlueButton before 2.2.29 lacks certain parameter sanitization, as demonstrated by accepting control characters in a user name.", "other": {"cve": {"id": "CVE-2020-28954", "sourceIdentifier": "cve@mitre.org", "published": "2020-11-19T22:15:13.757", "lastModified": "2020-11-29T23:41:06.973", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "web/controllers/ApiController.groovy in BigBlueButton before 2.2.29 lacks certain parameter sanitization, as demonstrated by accepting control characters in a user name."}, {"lang": "es", "value": "web/controllers/ApiController.groovy en BigBlueButton versiones anteriores a 2.2.29 carece de cierta desinfecci\u00f3n de par\u00e1metros, como se demuestra al aceptar caracteres de control en un nombre de usuario"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-116"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bigbluebutton:bigbluebutton:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.2.29", "matchCriteriaId": "5FA0DCDA-3F90-4D22-A5A1-E6CD7861C2B8"}]}]}], "references": [{"url": "https://github.com/bigbluebutton/bigbluebutton/commit/5c911ddeec4493f40f42e2f137800ed4692004a4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/bigbluebutton/bigbluebutton/commit/e59bcd0c33a6a3203c011faa8823ba2cac1e4f37", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/bigbluebutton/bigbluebutton/compare/v2.2.28...v2.2.29", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/bigbluebutton/bigbluebutton/issues/10818", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/bigbluebutton/bigbluebutton/commit/5c911ddeec4493f40f42e2f137800ed4692004a4"}}