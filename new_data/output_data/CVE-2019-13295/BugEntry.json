{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%       TTTTT  H   H  RRRR   EEEEE  SSSSS  H   H   OOO   L      DDDD          %\n%         T    H   H  R   R  E      SS     H   H  O   O  L      D   D         %\n%         T    HHHHH  RRRR   EEE     SSS   HHHHH  O   O  L      D   D         %\n%         T    H   H  R R    E         SS  H   H  O   O  L      D   D         %\n%         T    H   H  R  R   EEEEE  SSSSS  H   H   OOO   LLLLL  DDDD          %\n%                                                                             %\n%                                                                             %\n%                      MagickCore Image Threshold Methods                     %\n%                                                                             %\n%                               Software Design                               %\n%                                    Cristy                                   %\n%                                 October 1996                                %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/cache-view.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/configure.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/decorate.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/effect.h\"\n#include \"MagickCore/fx.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/memory-private.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/montage.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/pixel-private.h\"\n#include \"MagickCore/quantize.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/random_.h\"\n#include \"MagickCore/random-private.h\"\n#include \"MagickCore/resize.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/segment.h\"\n#include \"MagickCore/shear.h\"\n#include \"MagickCore/signature-private.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/threshold.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/xml-tree.h\"\n#include \"MagickCore/xml-tree-private.h\"\n\f\n/*\n  Define declarations.\n*/\n#define ThresholdsFilename  \"thresholds.xml\"\n\f\n/*\n  Typedef declarations.\n*/\nstruct _ThresholdMap\n{\n  char\n    *map_id,\n    *description;\n\n  size_t\n    width,\n    height;\n\n  ssize_t\n    divisor,\n    *levels;\n};\n\f\n/*\n  Static declarations.\n*/\nstatic const char\n  *MinimalThresholdMap =\n    \"<?xml version=\\\"1.0\\\"?>\"\n    \"<thresholds>\"\n    \"  <threshold map=\\\"threshold\\\" alias=\\\"1x1\\\">\"\n    \"    <description>Threshold 1x1 (non-dither)</description>\"\n    \"    <levels width=\\\"1\\\" height=\\\"1\\\" divisor=\\\"2\\\">\"\n    \"        1\"\n    \"    </levels>\"\n    \"  </threshold>\"\n    \"  <threshold map=\\\"checks\\\" alias=\\\"2x1\\\">\"\n    \"    <description>Checkerboard 2x1 (dither)</description>\"\n    \"    <levels width=\\\"2\\\" height=\\\"2\\\" divisor=\\\"3\\\">\"\n    \"       1 2\"\n    \"       2 1\"\n    \"    </levels>\"\n    \"  </threshold>\"\n    \"</thresholds>\";\n\f\n/*\n  Forward declarations.\n*/\nstatic ThresholdMap\n  *GetThresholdMapFile(const char *,const char *,const char *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     A d a p t i v e T h r e s h o l d I m a g e                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AdaptiveThresholdImage() selects an individual threshold for each pixel\n%  based on the range of intensity values in its local neighborhood.  This\n%  allows for thresholding of an image whose global intensity histogram\n%  doesn't contain distinctive peaks.\n%\n%  The format of the AdaptiveThresholdImage method is:\n%\n%      Image *AdaptiveThresholdImage(const Image *image,const size_t width,\n%        const size_t height,const double bias,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o width: the width of the local neighborhood.\n%\n%    o height: the height of the local neighborhood.\n%\n%    o bias: the mean bias.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *AdaptiveThresholdImage(const Image *image,\n  const size_t width,const size_t height,const double bias,\n  ExceptionInfo *exception)\n{\n#define AdaptiveThresholdImageTag  \"AdaptiveThreshold/Image\"\n\n  CacheView\n    *image_view,\n    *threshold_view;\n\n  Image\n    *threshold_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  MagickSizeType\n    number_pixels;\n\n  ssize_t\n    y;\n\n  /*\n    Initialize threshold image attributes.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  threshold_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (threshold_image == (Image *) NULL)\n    return((Image *) NULL);\n  status=SetImageStorageClass(threshold_image,DirectClass,exception);\n  if (status == MagickFalse)\n    {\n      threshold_image=DestroyImage(threshold_image);\n      return((Image *) NULL);\n    }\n  /*\n    Threshold image.\n  */\n  status=MagickTrue;\n  progress=0;\n  number_pixels=(MagickSizeType) width*height;\n  image_view=AcquireVirtualCacheView(image,exception);\n  threshold_view=AcquireAuthenticCacheView(threshold_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,threshold_image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    double\n      channel_bias[MaxPixelChannels],\n      channel_sum[MaxPixelChannels];\n\n    register const Quantum\n      *magick_restrict p,\n      *magick_restrict pixels;\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      i,\n      x;\n\n    ssize_t\n      center,\n      u,\n      v;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,-((ssize_t) width/2L),y-(ssize_t)\n      (height/2L),image->columns+width,height,exception);\n    q=QueueCacheViewAuthenticPixels(threshold_view,0,y,threshold_image->columns,\n      1,exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    center=(ssize_t) GetPixelChannels(image)*(image->columns+width)*(height/2L)+\n      GetPixelChannels(image)*(width/2);\n    for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n    {\n      PixelChannel channel = GetPixelChannelChannel(image,i);\n      PixelTrait traits = GetPixelChannelTraits(image,channel);\n      PixelTrait threshold_traits=GetPixelChannelTraits(threshold_image,\n        channel);\n      if ((traits == UndefinedPixelTrait) ||\n          (threshold_traits == UndefinedPixelTrait))\n        continue;\n      if ((threshold_traits & CopyPixelTrait) != 0)\n        {\n          SetPixelChannel(threshold_image,channel,p[center+i],q);\n          continue;\n        }\n      pixels=p;\n      channel_bias[channel]=0.0;\n      channel_sum[channel]=0.0;\n      for (v=0; v < (ssize_t) height; v++)\n      {\n        for (u=0; u < (ssize_t) width; u++)\n        {\n          if (u == (ssize_t) (width-1))\n            channel_bias[channel]+=pixels[i];\n          channel_sum[channel]+=pixels[i];\n          pixels+=GetPixelChannels(image);\n        }\n        pixels+=GetPixelChannels(image)*image->columns;\n      }\n    }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        double\n          mean;\n\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        PixelTrait threshold_traits=GetPixelChannelTraits(threshold_image,\n          channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (threshold_traits == UndefinedPixelTrait))\n          continue;\n        if ((threshold_traits & CopyPixelTrait) != 0)\n          {\n            SetPixelChannel(threshold_image,channel,p[center+i],q);\n            continue;\n          }\n        channel_sum[channel]-=channel_bias[channel];\n        channel_bias[channel]=0.0;\n        pixels=p;\n        for (v=0; v < (ssize_t) height; v++)\n        {\n          channel_bias[channel]+=pixels[i];\n          pixels+=(width-1)*GetPixelChannels(image);\n          channel_sum[channel]+=pixels[i];\n          pixels+=GetPixelChannels(image)*(image->columns+1);\n        }\n        mean=(double) (channel_sum[channel]/number_pixels+bias);\n        SetPixelChannel(threshold_image,channel,(Quantum) ((double)\n          p[center+i] <= mean ? 0 : QuantumRange),q);\n      }\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(threshold_image);\n    }\n    if (SyncCacheViewAuthenticPixels(threshold_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,AdaptiveThresholdImageTag,progress,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  threshold_image->type=image->type;\n  threshold_view=DestroyCacheView(threshold_view);\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    threshold_image=DestroyImage(threshold_image);\n  return(threshold_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     A u t o T h r e s h o l d I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AutoThresholdImage()  automatically performs image thresholding\n%  dependent on which method you specify.\n%\n%  The format of the AutoThresholdImage method is:\n%\n%      MagickBooleanType AutoThresholdImage(Image *image,\n%        const AutoThresholdMethod method,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: The image to auto-threshold.\n%\n%    o method: choose from Kapur, OTSU, or Triangle.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic double KapurThreshold(const Image *image,const double *histogram,\n  ExceptionInfo *exception)\n{\n#define MaxIntensity  255\n\n  double\n    *black_entropy,\n    *cumulative_histogram,\n    entropy,\n    epsilon,\n    maximum_entropy,\n    *white_entropy;\n\n  register ssize_t\n    i,\n    j;\n\n  size_t\n    threshold;\n\n  /*\n    Compute optimal threshold from the entopy of the histogram.\n  */\n  cumulative_histogram=(double *) AcquireQuantumMemory(MaxIntensity+1UL,\n    sizeof(*cumulative_histogram));\n  black_entropy=(double *) AcquireQuantumMemory(MaxIntensity+1UL,\n    sizeof(*black_entropy));\n  white_entropy=(double *) AcquireQuantumMemory(MaxIntensity+1UL,\n    sizeof(*white_entropy));\n  if ((cumulative_histogram == (double *) NULL) ||\n      (black_entropy == (double *) NULL) || (white_entropy == (double *) NULL))\n    {\n      if (white_entropy != (double *) NULL)\n        white_entropy=(double *) RelinquishMagickMemory(white_entropy);\n      if (black_entropy != (double *) NULL)\n        black_entropy=(double *) RelinquishMagickMemory(black_entropy);\n      if (cumulative_histogram != (double *) NULL)\n        cumulative_histogram=(double *)\n          RelinquishMagickMemory(cumulative_histogram);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(-1.0);\n    }\n   /*\n     Entropy for black and white parts of the histogram.\n   */\n   cumulative_histogram[0]=histogram[0];\n   for (i=1; i <= MaxIntensity; i++)\n     cumulative_histogram[i]=cumulative_histogram[i-1]+histogram[i];\n   epsilon=MagickMinimumValue;\n   for (j=0; j <= MaxIntensity; j++)\n   {\n     /*\n       Black entropy.\n     */\n     black_entropy[j]=0.0;\n     if (cumulative_histogram[j] > epsilon)\n       {\n         entropy=0.0;\n         for (i=0; i <= j; i++)\n           if (histogram[i] > epsilon)\n             entropy-=histogram[i]/cumulative_histogram[j]*\n               log(histogram[i]/cumulative_histogram[j]);\n         black_entropy[j]=entropy;\n       }\n     /*\n       White entropy.\n     */\n     white_entropy[j]=0.0;\n     if ((1.0-cumulative_histogram[j]) > epsilon)\n       {\n         entropy=0.0;\n         for (i=j+1; i <= MaxIntensity; i++)\n           if (histogram[i] > epsilon)\n             entropy-=histogram[i]/(1.0-cumulative_histogram[j])*\n               log(histogram[i]/(1.0-cumulative_histogram[j]));\n         white_entropy[j]=entropy;\n       }\n   }\n  /*\n    Find histogram bin with maximum entropy.\n  */\n  maximum_entropy=black_entropy[0]+white_entropy[0];\n  threshold=0;\n  for (j=1; j <= MaxIntensity; j++)\n    if ((black_entropy[j]+white_entropy[j]) > maximum_entropy)\n      {\n        maximum_entropy=black_entropy[j]+white_entropy[j];\n        threshold=(size_t) j;\n      }\n  /*\n    Free resources.\n  */\n  white_entropy=(double *) RelinquishMagickMemory(white_entropy);\n  black_entropy=(double *) RelinquishMagickMemory(black_entropy);\n  cumulative_histogram=(double *) RelinquishMagickMemory(cumulative_histogram);\n  return(100.0*threshold/MaxIntensity);\n}\n\nstatic double OTSUThreshold(const Image *image,const double *histogram,\n  ExceptionInfo *exception)\n{\n  double\n    max_sigma,\n    *myu,\n    *omega,\n    *probability,\n    *sigma,\n    threshold;\n\n  register ssize_t\n    i;\n\n  /*\n    Compute optimal threshold from maximization of inter-class variance.\n  */\n  myu=(double *) AcquireQuantumMemory(MaxIntensity+1UL,sizeof(*myu));\n  omega=(double *) AcquireQuantumMemory(MaxIntensity+1UL,sizeof(*omega));\n  probability=(double *) AcquireQuantumMemory(MaxIntensity+1UL,\n    sizeof(*probability));\n  sigma=(double *) AcquireQuantumMemory(MaxIntensity+1UL,sizeof(*sigma));\n  if ((myu == (double *) NULL) || (omega == (double *) NULL) ||\n      (probability == (double *) NULL) || (sigma == (double *) NULL))\n    {\n      if (sigma != (double *) NULL)\n        sigma=(double *) RelinquishMagickMemory(sigma);\n      if (probability != (double *) NULL)\n        probability=(double *) RelinquishMagickMemory(probability);\n      if (omega != (double *) NULL)\n        omega=(double *) RelinquishMagickMemory(omega);\n      if (myu != (double *) NULL)\n        myu=(double *) RelinquishMagickMemory(myu);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(-1.0);\n    }\n  /*\n    Calculate probability density.\n  */\n  for (i=0; i <= (ssize_t) MaxIntensity; i++)\n    probability[i]=histogram[i];\n  /*\n    Generate probability of graylevels and mean value for separation.\n  */\n  omega[0]=probability[0];\n  myu[0]=0.0;\n  for (i=1; i <= (ssize_t) MaxIntensity; i++)\n  {\n    omega[i]=omega[i-1]+probability[i];\n    myu[i]=myu[i-1]+i*probability[i];\n  }\n  /*\n    Sigma maximization: inter-class variance and compute optimal threshold.\n  */\n  threshold=0;\n  max_sigma=0.0;\n  for (i=0; i < (ssize_t) MaxIntensity; i++)\n  {\n    sigma[i]=0.0;\n    if ((omega[i] != 0.0) && (omega[i] != 1.0))\n      sigma[i]=pow(myu[MaxIntensity]*omega[i]-myu[i],2.0)/(omega[i]*(1.0-\n        omega[i]));\n    if (sigma[i] > max_sigma)\n      {\n        max_sigma=sigma[i];\n        threshold=(double) i;\n      }\n  }\n  /*\n    Free resources.\n  */\n  myu=(double *) RelinquishMagickMemory(myu);\n  omega=(double *) RelinquishMagickMemory(omega);\n  probability=(double *) RelinquishMagickMemory(probability);\n  sigma=(double *) RelinquishMagickMemory(sigma);\n  return(100.0*threshold/MaxIntensity);\n}\n\nstatic double TriangleThreshold(const double *histogram)\n{\n  double\n    a,\n    b,\n    c,\n    count,\n    distance,\n    inverse_ratio,\n    max_distance,\n    segment,\n    x1,\n    x2,\n    y1,\n    y2;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    end,\n    max,\n    start,\n    threshold;\n\n  /*\n    Compute optimal threshold with triangle algorithm.\n  */\n  start=0;  /* find start bin, first bin not zero count */\n  for (i=0; i <= (ssize_t) MaxIntensity; i++)\n    if (histogram[i] > 0.0)\n      {\n        start=i;\n        break;\n      }\n  end=0;  /* find end bin, last bin not zero count */\n  for (i=(ssize_t) MaxIntensity; i >= 0; i--)\n    if (histogram[i] > 0.0)\n      {\n        end=i;\n        break;\n      }\n  max=0;  /* find max bin, bin with largest count */\n  count=0.0;\n  for (i=0; i <= (ssize_t) MaxIntensity; i++)\n    if (histogram[i] > count)\n      {\n        max=i;\n        count=histogram[i];\n      }\n  /*\n    Compute threshold at split point.\n  */\n  x1=(double) max;\n  y1=histogram[max];\n  x2=(double) end;\n  if ((max-start) >= (end-max))\n    x2=(double) start;\n  y2=0.0;\n  a=y1-y2;\n  b=x2-x1;\n  c=(-1.0)*(a*x1+b*y1);\n  inverse_ratio=1.0/sqrt(a*a+b*b+c*c);\n  threshold=0;\n  max_distance=0.0;\n  if (x2 == (double) start)\n    for (i=start; i < max; i++)\n    {\n      segment=inverse_ratio*(a*i+b*histogram[i]+c);\n      distance=sqrt(segment*segment);\n      if ((distance > max_distance) && (segment > 0.0))\n        {\n          threshold=i;\n          max_distance=distance;\n        }\n    }\n  else\n    for (i=end; i > max; i--)\n    {\n      segment=inverse_ratio*(a*i+b*histogram[i]+c);\n      distance=sqrt(segment*segment);\n      if ((distance > max_distance) && (segment < 0.0))\n        {\n          threshold=i;\n          max_distance=distance;\n        }\n    }\n  return(100.0*threshold/MaxIntensity);\n}\n\nMagickExport MagickBooleanType AutoThresholdImage(Image *image,\n  const AutoThresholdMethod method,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  char\n    property[MagickPathExtent];\n\n  double\n    gamma,\n    *histogram,\n    sum,\n    threshold;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  /*\n    Form histogram.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  histogram=(double *) AcquireQuantumMemory(MaxIntensity+1UL,\n    sizeof(*histogram));\n  if (histogram == (double *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  status=MagickTrue;\n  (void) memset(histogram,0,(MaxIntensity+1UL)*sizeof(*histogram));\n  image_view=AcquireVirtualCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double intensity = GetPixelIntensity(image,p);\n      histogram[ScaleQuantumToChar(ClampToQuantum(intensity))]++;\n      p+=GetPixelChannels(image);\n    }\n  }\n  image_view=DestroyCacheView(image_view);\n  /*\n    Normalize histogram.\n  */\n  sum=0.0;\n  for (i=0; i <= (ssize_t) MaxIntensity; i++)\n    sum+=histogram[i];\n  gamma=PerceptibleReciprocal(sum);\n  for (i=0; i <= (ssize_t) MaxIntensity; i++)\n    histogram[i]=gamma*histogram[i];\n  /*\n    Discover threshold from histogram.\n  */\n  switch (method)\n  {\n    case KapurThresholdMethod:\n    {\n      threshold=KapurThreshold(image,histogram,exception);\n      break;\n    }\n    case OTSUThresholdMethod:\n    default:\n    {\n      threshold=OTSUThreshold(image,histogram,exception);\n      break;\n    }\n    case TriangleThresholdMethod:\n    {\n      threshold=TriangleThreshold(histogram);\n      break;\n    }\n  }\n  histogram=(double *) RelinquishMagickMemory(histogram);\n  if (threshold < 0.0)\n    status=MagickFalse;\n  if (status == MagickFalse)\n    return(MagickFalse);\n  /*\n    Threshold image.\n  */\n  (void) FormatLocaleString(property,MagickPathExtent,\"%g%%\",threshold);\n  (void) SetImageProperty(image,\"auto-threshold:threshold\",property,exception);\n  return(BilevelImage(image,QuantumRange*threshold/100.0,exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     B i l e v e l I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  BilevelImage() changes the value of individual pixels based on the\n%  intensity of each pixel channel.  The result is a high-contrast image.\n%\n%  More precisely each channel value of the image is 'thresholded' so that if\n%  it is equal to or less than the given value it is set to zero, while any\n%  value greater than that give is set to it maximum or QuantumRange.\n%\n%  This function is what is used to implement the \"-threshold\" operator for\n%  the command line API.\n%\n%  If the default channel setting is given the image is thresholded using just\n%  the gray 'intensity' of the image, rather than the individual channels.\n%\n%  The format of the BilevelImage method is:\n%\n%      MagickBooleanType BilevelImage(Image *image,const double threshold,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o threshold: define the threshold values.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n%  Aside: You can get the same results as operator using LevelImages()\n%  with the 'threshold' value for both the black_point and the white_point.\n%\n*/\nMagickExport MagickBooleanType BilevelImage(Image *image,const double threshold,\n  ExceptionInfo *exception)\n{\n#define ThresholdImageTag  \"Threshold/Image\"\n\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  if (IsGrayColorspace(image->colorspace) != MagickFalse)\n    (void) SetImageColorspace(image,sRGBColorspace,exception);\n  /*\n    Bilevel threshold image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        pixel;\n\n      register ssize_t\n        i;\n\n      pixel=GetPixelIntensity(image,q);\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        if (image->channel_mask != DefaultChannels)\n          pixel=(double) q[i];\n        q[i]=(Quantum) (pixel <= threshold ? 0 : QuantumRange);\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,ThresholdImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     B l a c k T h r e s h o l d I m a g e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  BlackThresholdImage() is like ThresholdImage() but forces all pixels below\n%  the threshold into black while leaving all pixels at or above the threshold\n%  unchanged.\n%\n%  The format of the BlackThresholdImage method is:\n%\n%      MagickBooleanType BlackThresholdImage(Image *image,\n%        const char *threshold,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o threshold: define the threshold value.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType BlackThresholdImage(Image *image,\n  const char *thresholds,ExceptionInfo *exception)\n{\n#define ThresholdImageTag  \"Threshold/Image\"\n\n  CacheView\n    *image_view;\n\n  GeometryInfo\n    geometry_info;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  PixelInfo\n    threshold;\n\n  MagickStatusType\n    flags;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (thresholds == (const char *) NULL)\n    return(MagickTrue);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  if (IsGrayColorspace(image->colorspace) != MagickFalse)\n    (void) SetImageColorspace(image,sRGBColorspace,exception);\n  GetPixelInfo(image,&threshold);\n  flags=ParseGeometry(thresholds,&geometry_info);\n  threshold.red=geometry_info.rho;\n  threshold.green=geometry_info.rho;\n  threshold.blue=geometry_info.rho;\n  threshold.black=geometry_info.rho;\n  threshold.alpha=100.0;\n  if ((flags & SigmaValue) != 0)\n    threshold.green=geometry_info.sigma;\n  if ((flags & XiValue) != 0)\n    threshold.blue=geometry_info.xi;\n  if ((flags & PsiValue) != 0)\n    threshold.alpha=geometry_info.psi;\n  if (threshold.colorspace == CMYKColorspace)\n    {\n      if ((flags & PsiValue) != 0)\n        threshold.black=geometry_info.psi;\n      if ((flags & ChiValue) != 0)\n        threshold.alpha=geometry_info.chi;\n    }\n  if ((flags & PercentValue) != 0)\n    {\n      threshold.red*=(MagickRealType) (QuantumRange/100.0);\n      threshold.green*=(MagickRealType) (QuantumRange/100.0);\n      threshold.blue*=(MagickRealType) (QuantumRange/100.0);\n      threshold.black*=(MagickRealType) (QuantumRange/100.0);\n      threshold.alpha*=(MagickRealType) (QuantumRange/100.0);\n    }\n  /*\n    White threshold image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        pixel;\n\n      register ssize_t\n        i;\n\n      pixel=GetPixelIntensity(image,q);\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        if (image->channel_mask != DefaultChannels)\n          pixel=(double) q[i];\n        if (pixel < GetPixelInfoChannel(&threshold,channel))\n          q[i]=(Quantum) 0;\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,ThresholdImageTag,progress,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     C l a m p I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ClampImage() set each pixel whose value is below zero to zero and any the\n%  pixel whose value is above the quantum range to the quantum range (e.g.\n%  65535) otherwise the pixel value remains unchanged.\n%\n%  The format of the ClampImage method is:\n%\n%      MagickBooleanType ClampImage(Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nMagickExport MagickBooleanType ClampImage(Image *image,ExceptionInfo *exception)\n{\n#define ClampImageTag  \"Clamp/Image\"\n\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->storage_class == PseudoClass)\n    {\n      register ssize_t\n        i;\n\n      register PixelInfo\n        *magick_restrict q;\n\n      q=image->colormap;\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        q->red=(double) ClampPixel(q->red);\n        q->green=(double) ClampPixel(q->green);\n        q->blue=(double) ClampPixel(q->blue);\n        q->alpha=(double) ClampPixel(q->alpha);\n        q++;\n      }\n      return(SyncImage(image,exception));\n    }\n  /*\n    Clamp image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        q[i]=ClampPixel((MagickRealType) q[i]);\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,ClampImageTag,progress,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  D e s t r o y T h r e s h o l d M a p                                      %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyThresholdMap() de-allocate the given ThresholdMap\n%\n%  The format of the ListThresholdMaps method is:\n%\n%      ThresholdMap *DestroyThresholdMap(Threshold *map)\n%\n%  A description of each parameter follows.\n%\n%    o map:    Pointer to the Threshold map to destroy\n%\n*/\nMagickExport ThresholdMap *DestroyThresholdMap(ThresholdMap *map)\n{\n  assert(map != (ThresholdMap *) NULL);\n  if (map->map_id != (char *) NULL)\n    map->map_id=DestroyString(map->map_id);\n  if (map->description != (char *) NULL)\n    map->description=DestroyString(map->description);\n  if (map->levels != (ssize_t *) NULL)\n    map->levels=(ssize_t *) RelinquishMagickMemory(map->levels);\n  map=(ThresholdMap *) RelinquishMagickMemory(map);\n  return(map);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  G e t T h r e s h o l d M a p                                              %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetThresholdMap() loads and searches one or more threshold map files for the\n%  map matching the given name or alias.\n%\n%  The format of the GetThresholdMap method is:\n%\n%      ThresholdMap *GetThresholdMap(const char *map_id,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o map_id:  ID of the map to look for.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport ThresholdMap *GetThresholdMap(const char *map_id,\n  ExceptionInfo *exception)\n{\n  ThresholdMap\n    *map;\n\n  map=GetThresholdMapFile(MinimalThresholdMap,\"built-in\",map_id,exception);\n  if (map != (ThresholdMap *) NULL)\n    return(map);\n#if !defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\n  {\n    const StringInfo\n      *option;\n\n    LinkedListInfo\n      *options;\n\n    options=GetConfigureOptions(ThresholdsFilename,exception);\n    option=(const StringInfo *) GetNextValueInLinkedList(options);\n    while (option != (const StringInfo *) NULL)\n    {\n      map=GetThresholdMapFile((const char *) GetStringInfoDatum(option),\n        GetStringInfoPath(option),map_id,exception);\n      if (map != (ThresholdMap *) NULL)\n        break;\n      option=(const StringInfo *) GetNextValueInLinkedList(options);\n    }\n    options=DestroyConfigureOptions(options);\n  }\n#endif\n  return(map);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  G e t T h r e s h o l d M a p F i l e                                      %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetThresholdMapFile() look for a given threshold map name or alias in the\n%  given XML file data, and return the allocated the map when found.\n%\n%  The format of the ListThresholdMaps method is:\n%\n%      ThresholdMap *GetThresholdMap(const char *xml,const char *filename,\n%         const char *map_id,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o xml:  The threshold map list in XML format.\n%\n%    o filename:  The threshold map XML filename.\n%\n%    o map_id:  ID of the map to look for in XML list.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic ThresholdMap *GetThresholdMapFile(const char *xml,const char *filename,\n  const char *map_id,ExceptionInfo *exception)\n{\n  char\n    *p;\n\n  const char\n    *attribute,\n    *content;\n\n  double\n    value;\n\n  register ssize_t\n    i;\n\n  ThresholdMap\n    *map;\n\n  XMLTreeInfo\n    *description,\n    *levels,\n    *threshold,\n    *thresholds;\n\n  (void) LogMagickEvent(ConfigureEvent,GetMagickModule(),\n    \"Loading threshold map file \\\"%s\\\" ...\",filename);\n  map=(ThresholdMap *) NULL;\n  thresholds=NewXMLTree(xml,exception);\n  if (thresholds == (XMLTreeInfo *) NULL)\n    return(map);\n  for (threshold=GetXMLTreeChild(thresholds,\"threshold\");\n       threshold != (XMLTreeInfo *) NULL;\n       threshold=GetNextXMLTreeTag(threshold))\n  {\n    attribute=GetXMLTreeAttribute(threshold,\"map\");\n    if ((attribute != (char *) NULL) && (LocaleCompare(map_id,attribute) == 0))\n      break;\n    attribute=GetXMLTreeAttribute(threshold,\"alias\");\n    if ((attribute != (char *) NULL) && (LocaleCompare(map_id,attribute) == 0))\n      break;\n  }\n  if (threshold == (XMLTreeInfo *) NULL)\n    {\n      thresholds=DestroyXMLTree(thresholds);\n      return(map);\n    }\n  description=GetXMLTreeChild(threshold,\"description\");\n  if (description == (XMLTreeInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingElement\", \"<description>, map \\\"%s\\\"\",map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      return(map);\n    }\n  levels=GetXMLTreeChild(threshold,\"levels\");\n  if (levels == (XMLTreeInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingElement\", \"<levels>, map \\\"%s\\\"\", map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      return(map);\n    }\n  map=(ThresholdMap *) AcquireCriticalMemory(sizeof(*map));\n  map->map_id=(char *) NULL;\n  map->description=(char *) NULL;\n  map->levels=(ssize_t *) NULL;\n  attribute=GetXMLTreeAttribute(threshold,\"map\");\n  if (attribute != (char *) NULL)\n    map->map_id=ConstantString(attribute);\n  content=GetXMLTreeContent(description);\n  if (content != (char *) NULL)\n    map->description=ConstantString(content);\n  attribute=GetXMLTreeAttribute(levels,\"width\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\", \"<levels width>, map \\\"%s\\\"\",map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      map=DestroyThresholdMap(map);\n      return(map);\n    }\n  map->width=StringToUnsignedLong(attribute);\n  if (map->width == 0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n       \"XmlInvalidAttribute\", \"<levels width>, map \\\"%s\\\"\",map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      map=DestroyThresholdMap(map);\n      return(map);\n    }\n  attribute=GetXMLTreeAttribute(levels,\"height\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\", \"<levels height>, map \\\"%s\\\"\",map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      map=DestroyThresholdMap(map);\n      return(map);\n    }\n  map->height=StringToUnsignedLong(attribute);\n  if (map->height == 0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidAttribute\", \"<levels height>, map \\\"%s\\\"\",map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      map=DestroyThresholdMap(map);\n      return(map);\n    }\n  attribute=GetXMLTreeAttribute(levels,\"divisor\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\", \"<levels divisor>, map \\\"%s\\\"\",map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      map=DestroyThresholdMap(map);\n      return(map);\n    }\n  map->divisor=(ssize_t) StringToLong(attribute);\n  if (map->divisor < 2)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidAttribute\", \"<levels divisor>, map \\\"%s\\\"\",map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      map=DestroyThresholdMap(map);\n      return(map);\n    }\n  content=GetXMLTreeContent(levels);\n  if (content == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingContent\", \"<levels>, map \\\"%s\\\"\",map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      map=DestroyThresholdMap(map);\n      return(map);\n    }\n  map->levels=(ssize_t *) AcquireQuantumMemory((size_t) map->width,map->height*\n    sizeof(*map->levels));\n  if (map->levels == (ssize_t *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"UnableToAcquireThresholdMap\");\n  for (i=0; i < (ssize_t) (map->width*map->height); i++)\n  {\n    map->levels[i]=(ssize_t) strtol(content,&p,10);\n    if (p == content)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n          \"XmlInvalidContent\", \"<level> too few values, map \\\"%s\\\"\",map_id);\n        thresholds=DestroyXMLTree(thresholds);\n        map=DestroyThresholdMap(map);\n        return(map);\n      }\n    if ((map->levels[i] < 0) || (map->levels[i] > map->divisor))\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n          \"XmlInvalidContent\", \"<level> %.20g out of range, map \\\"%s\\\"\",\n          (double) map->levels[i],map_id);\n        thresholds=DestroyXMLTree(thresholds);\n        map=DestroyThresholdMap(map);\n        return(map);\n      }\n    content=p;\n  }\n  value=(double) strtol(content,&p,10);\n  (void) value;\n  if (p != content)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidContent\", \"<level> too many values, map \\\"%s\\\"\",map_id);\n     thresholds=DestroyXMLTree(thresholds);\n     map=DestroyThresholdMap(map);\n     return(map);\n   }\n  thresholds=DestroyXMLTree(thresholds);\n  return(map);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  L i s t T h r e s h o l d M a p F i l e                                    %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ListThresholdMapFile() lists the threshold maps and their descriptions\n%  in the given XML file data.\n%\n%  The format of the ListThresholdMaps method is:\n%\n%      MagickBooleanType ListThresholdMaps(FILE *file,const char*xml,\n%         const char *filename,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o file:  An pointer to the output FILE.\n%\n%    o xml:  The threshold map list in XML format.\n%\n%    o filename:  The threshold map XML filename.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickBooleanType ListThresholdMapFile(FILE *file,const char *xml,\n  const char *filename,ExceptionInfo *exception)\n{\n  const char\n    *alias,\n    *content,\n    *map;\n\n  XMLTreeInfo\n    *description,\n    *threshold,\n    *thresholds;\n\n  assert( xml != (char *) NULL );\n  assert( file != (FILE *) NULL );\n  (void) LogMagickEvent(ConfigureEvent,GetMagickModule(),\n    \"Loading threshold map file \\\"%s\\\" ...\",filename);\n  thresholds=NewXMLTree(xml,exception);\n  if ( thresholds == (XMLTreeInfo *) NULL )\n    return(MagickFalse);\n  (void) FormatLocaleFile(file,\"%-16s %-12s %s\\n\",\"Map\",\"Alias\",\"Description\");\n  (void) FormatLocaleFile(file,\n    \"----------------------------------------------------\\n\");\n  threshold=GetXMLTreeChild(thresholds,\"threshold\");\n  for ( ; threshold != (XMLTreeInfo *) NULL;\n          threshold=GetNextXMLTreeTag(threshold))\n  {\n    map=GetXMLTreeAttribute(threshold,\"map\");\n    if (map == (char *) NULL)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n          \"XmlMissingAttribute\", \"<map>\");\n        thresholds=DestroyXMLTree(thresholds);\n        return(MagickFalse);\n      }\n    alias=GetXMLTreeAttribute(threshold,\"alias\");\n    description=GetXMLTreeChild(threshold,\"description\");\n    if (description == (XMLTreeInfo *) NULL)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n          \"XmlMissingElement\", \"<description>, map \\\"%s\\\"\",map);\n        thresholds=DestroyXMLTree(thresholds);\n        return(MagickFalse);\n      }\n    content=GetXMLTreeContent(description);\n    if (content == (char *) NULL)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n          \"XmlMissingContent\", \"<description>, map \\\"%s\\\"\", map);\n        thresholds=DestroyXMLTree(thresholds);\n        return(MagickFalse);\n      }\n    (void) FormatLocaleFile(file,\"%-16s %-12s %s\\n\",map,alias ? alias : \"\",\n      content);\n  }\n  thresholds=DestroyXMLTree(thresholds);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  L i s t T h r e s h o l d M a p s                                          %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ListThresholdMaps() lists the threshold maps and their descriptions\n%  as defined by \"threshold.xml\" to a file.\n%\n%  The format of the ListThresholdMaps method is:\n%\n%      MagickBooleanType ListThresholdMaps(FILE *file,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o file:  An pointer to the output FILE.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType ListThresholdMaps(FILE *file,\n  ExceptionInfo *exception)\n{\n  const StringInfo\n    *option;\n\n  LinkedListInfo\n    *options;\n\n  MagickStatusType\n    status;\n\n  status=MagickTrue;\n  if (file == (FILE *) NULL)\n    file=stdout;\n  options=GetConfigureOptions(ThresholdsFilename,exception);\n  (void) FormatLocaleFile(file,\n    \"\\n   Threshold Maps for Ordered Dither Operations\\n\");\n  option=(const StringInfo *) GetNextValueInLinkedList(options);\n  while (option != (const StringInfo *) NULL)\n  {\n    (void) FormatLocaleFile(file,\"\\nPath: %s\\n\\n\",GetStringInfoPath(option));\n    status&=ListThresholdMapFile(file,(const char *) GetStringInfoDatum(option),\n      GetStringInfoPath(option),exception);\n    option=(const StringInfo *) GetNextValueInLinkedList(options);\n  }\n  options=DestroyConfigureOptions(options);\n  return(status != 0 ? MagickTrue : MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     O r d e r e d D i t h e r I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  OrderedDitherImage() will perform a ordered dither based on a number\n%  of pre-defined dithering threshold maps, but over multiple intensity\n%  levels, which can be different for different channels, according to the\n%  input argument.\n%\n%  The format of the OrderedDitherImage method is:\n%\n%      MagickBooleanType OrderedDitherImage(Image *image,\n%        const char *threshold_map,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o threshold_map: A string containing the name of the threshold dither\n%      map to use, followed by zero or more numbers representing the number\n%      of color levels tho dither between.\n%\n%      Any level number less than 2 will be equivalent to 2, and means only\n%      binary dithering will be applied to each color channel.\n%\n%      No numbers also means a 2 level (bitmap) dither will be applied to all\n%      channels, while a single number is the number of levels applied to each\n%      channel in sequence.  More numbers will be applied in turn to each of\n%      the color channels.\n%\n%      For example: \"o3x3,6\" will generate a 6 level posterization of the\n%      image with a ordered 3x3 diffused pixel dither being applied between\n%      each level. While checker,8,8,4 will produce a 332 colormaped image\n%      with only a single checkerboard hash pattern (50% grey) between each\n%      color level, to basically double the number of color levels with\n%      a bare minimim of dithering.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType OrderedDitherImage(Image *image,\n  const char *threshold_map,ExceptionInfo *exception)\n{\n#define DitherImageTag  \"Dither/Image\"\n\n  CacheView\n    *image_view;\n\n  char\n    token[MagickPathExtent];\n\n  const char\n    *p;\n\n  double\n    levels[CompositePixelChannel];\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  ThresholdMap\n    *map;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (threshold_map == (const char *) NULL)\n    return(MagickTrue);\n  p=(char *) threshold_map;\n  while (((isspace((int) ((unsigned char) *p)) != 0) || (*p == ',')) &&\n         (*p != '\\0'))\n    p++;\n  threshold_map=p;\n  while (((isspace((int) ((unsigned char) *p)) == 0) && (*p != ',')) &&\n         (*p != '\\0'))\n  {\n    if ((p-threshold_map) >= (MagickPathExtent-1))\n      break;\n    token[p-threshold_map]=(*p);\n    p++;\n  }\n  token[p-threshold_map]='\\0';\n  map=GetThresholdMap(token,exception);\n  if (map == (ThresholdMap *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"InvalidArgument\",\"%s : '%s'\",\"ordered-dither\",threshold_map);\n      return(MagickFalse);\n    }\n  for (i=0; i < MaxPixelChannels; i++)\n    levels[i]=2.0;\n  p=strchr((char *) threshold_map,',');\n  if ((p != (char *) NULL) && (isdigit((int) ((unsigned char) *(++p))) != 0))\n    {\n      GetNextToken(p,&p,MagickPathExtent,token);\n      for (i=0; (i < MaxPixelChannels); i++)\n        levels[i]=StringToDouble(token,(char **) NULL);\n      for (i=0; (*p != '\\0') && (i < MaxPixelChannels); i++)\n      {\n        GetNextToken(p,&p,MagickPathExtent,token);\n        if (*token == ',')\n          GetNextToken(p,&p,MagickPathExtent,token);\n        levels[i]=StringToDouble(token,(char **) NULL);\n      }\n    }\n  for (i=0; i < MaxPixelChannels; i++)\n    if (fabs(levels[i]) >= 1)\n      levels[i]-=1.0;\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      ssize_t\n        n;\n\n      n=0;\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        ssize_t\n          level,\n          threshold;\n\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        if (fabs(levels[n]) < MagickEpsilon)\n          {\n            n++;\n            continue;\n          }\n        threshold=(ssize_t) (QuantumScale*q[i]*(levels[n]*(map->divisor-1)+1));\n        level=threshold/(map->divisor-1);\n        threshold-=level*(map->divisor-1);\n        q[i]=ClampToQuantum((double) (level+(threshold >=\n          map->levels[(x % map->width)+map->width*(y % map->height)]))*\n          QuantumRange/levels[n]);\n        n++;\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,DitherImageTag,progress,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  map=DestroyThresholdMap(map);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     P e r c e p t i b l e I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  PerceptibleImage() set each pixel whose value is less than |epsilon| to\n%  epsilon or -epsilon (whichever is closer) otherwise the pixel value remains\n%  unchanged.\n%\n%  The format of the PerceptibleImage method is:\n%\n%      MagickBooleanType PerceptibleImage(Image *image,const double epsilon,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o epsilon: the epsilon threshold (e.g. 1.0e-9).\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline Quantum PerceptibleThreshold(const Quantum quantum,\n  const double epsilon)\n{\n  double\n    sign;\n\n  sign=(double) quantum < 0.0 ? -1.0 : 1.0;\n  if ((sign*quantum) >= epsilon)\n    return(quantum);\n  return((Quantum) (sign*epsilon));\n}\n\nMagickExport MagickBooleanType PerceptibleImage(Image *image,\n  const double epsilon,ExceptionInfo *exception)\n{\n#define PerceptibleImageTag  \"Perceptible/Image\"\n\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->storage_class == PseudoClass)\n    {\n      register ssize_t\n        i;\n\n      register PixelInfo\n        *magick_restrict q;\n\n      q=image->colormap;\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        q->red=(double) PerceptibleThreshold(ClampToQuantum(q->red),\n          epsilon);\n        q->green=(double) PerceptibleThreshold(ClampToQuantum(q->green),\n          epsilon);\n        q->blue=(double) PerceptibleThreshold(ClampToQuantum(q->blue),\n          epsilon);\n        q->alpha=(double) PerceptibleThreshold(ClampToQuantum(q->alpha),\n          epsilon);\n        q++;\n      }\n      return(SyncImage(image,exception));\n    }\n  /*\n    Perceptible image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        if (traits == UndefinedPixelTrait)\n          continue;\n        q[i]=PerceptibleThreshold(q[i],epsilon);\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,PerceptibleImageTag,progress,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     R a n d o m T h r e s h o l d I m a g e                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RandomThresholdImage() changes the value of individual pixels based on the\n%  intensity of each pixel compared to a random threshold.  The result is a\n%  low-contrast, two color image.\n%\n%  The format of the RandomThresholdImage method is:\n%\n%      MagickBooleanType RandomThresholdImage(Image *image,\n%        const char *thresholds,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o low,high: Specify the high and low thresholds. These values range from\n%      0 to QuantumRange.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType RandomThresholdImage(Image *image,\n  const double min_threshold, const double max_threshold,ExceptionInfo *exception)\n{\n#define ThresholdImageTag  \"Threshold/Image\"\n\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  PixelInfo\n    threshold;\n\n  RandomInfo\n    **magick_restrict random_info;\n\n  ssize_t\n    y;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  unsigned long\n    key;\n#endif\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  GetPixelInfo(image,&threshold);\n  /*\n    Random threshold image.\n  */\n  status=MagickTrue;\n  progress=0;\n  random_info=AcquireRandomInfoThreadSet();\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  key=GetRandomSecretKey(random_info[0]);\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,image,image->rows,key == ~0UL)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    const int\n      id = GetOpenMPThreadId();\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        double\n          threshold;\n\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        if ((double) q[i] < min_threshold)\n          threshold=min_threshold;\n        else\n          if ((double) q[i] > max_threshold)\n            threshold=max_threshold;\n          else\n            threshold=(double) (QuantumRange*\n              GetPseudoRandomValue(random_info[id]));\n        q[i]=(double) q[i] <= threshold ? 0 : QuantumRange;\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,ThresholdImageTag,progress,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  random_info=DestroyRandomInfoThreadSet(random_info);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     R a n g e T h r e s h o l d I m a g e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RangeThresholdImage() applies soft and hard thresholding.\n%\n%  The format of the RangeThresholdImage method is:\n%\n%      MagickBooleanType RangeThresholdImage(Image *image,\n%        const double low_black,const double low_white,const double high_white,\n%        const double high_black,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o low_black: Define the minimum black threshold value.\n%\n%    o low_white: Define the minimum white threshold value.\n%\n%    o high_white: Define the maximum white threshold value.\n%\n%    o high_black: Define the maximum black threshold value.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType RangeThresholdImage(Image *image,\n  const double low_black,const double low_white,const double high_white,\n  const double high_black,ExceptionInfo *exception)\n{\n#define ThresholdImageTag  \"Threshold/Image\"\n\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  if (IsGrayColorspace(image->colorspace) != MagickFalse)\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  /*\n    Range threshold image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        pixel;\n\n      register ssize_t\n        i;\n\n      pixel=GetPixelIntensity(image,q);\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        if (image->channel_mask != DefaultChannels)\n          pixel=(double) q[i];\n        if (pixel < low_black)\n          q[i]=0;\n        else\n          if ((pixel >= low_black) && (pixel < low_white))\n            q[i]=ClampToQuantum(QuantumRange*\n              PerceptibleReciprocal(low_white-low_black)*(pixel-low_black));\n          else\n            if ((pixel >= low_white) && (pixel <= high_white))\n              q[i]=QuantumRange;\n            else\n              if ((pixel > high_white) && (pixel <= high_black))\n                q[i]=ClampToQuantum(QuantumRange*PerceptibleReciprocal(\n                  high_black-high_white)*(high_black-pixel));\n              else\n                if (pixel > high_black)\n                  q[i]=0;\n                else\n                  q[i]=0;\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,ThresholdImageTag,progress,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     W h i t e T h r e s h o l d I m a g e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WhiteThresholdImage() is like ThresholdImage() but forces all pixels above\n%  the threshold into white while leaving all pixels at or below the threshold\n%  unchanged.\n%\n%  The format of the WhiteThresholdImage method is:\n%\n%      MagickBooleanType WhiteThresholdImage(Image *image,\n%        const char *threshold,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o threshold: Define the threshold value.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType WhiteThresholdImage(Image *image,\n  const char *thresholds,ExceptionInfo *exception)\n{\n#define ThresholdImageTag  \"Threshold/Image\"\n\n  CacheView\n    *image_view;\n\n  GeometryInfo\n    geometry_info;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  PixelInfo\n    threshold;\n\n  MagickStatusType\n    flags;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (thresholds == (const char *) NULL)\n    return(MagickTrue);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  if (IsGrayColorspace(image->colorspace) != MagickFalse)\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  GetPixelInfo(image,&threshold);\n  flags=ParseGeometry(thresholds,&geometry_info);\n  threshold.red=geometry_info.rho;\n  threshold.green=geometry_info.rho;\n  threshold.blue=geometry_info.rho;\n  threshold.black=geometry_info.rho;\n  threshold.alpha=100.0;\n  if ((flags & SigmaValue) != 0)\n    threshold.green=geometry_info.sigma;\n  if ((flags & XiValue) != 0)\n    threshold.blue=geometry_info.xi;\n  if ((flags & PsiValue) != 0)\n    threshold.alpha=geometry_info.psi;\n  if (threshold.colorspace == CMYKColorspace)\n    {\n      if ((flags & PsiValue) != 0)\n        threshold.black=geometry_info.psi;\n      if ((flags & ChiValue) != 0)\n        threshold.alpha=geometry_info.chi;\n    }\n  if ((flags & PercentValue) != 0)\n    {\n      threshold.red*=(MagickRealType) (QuantumRange/100.0);\n      threshold.green*=(MagickRealType) (QuantumRange/100.0);\n      threshold.blue*=(MagickRealType) (QuantumRange/100.0);\n      threshold.black*=(MagickRealType) (QuantumRange/100.0);\n      threshold.alpha*=(MagickRealType) (QuantumRange/100.0);\n    }\n  /*\n    White threshold image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        pixel;\n\n      register ssize_t\n        i;\n\n      pixel=GetPixelIntensity(image,q);\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        if (image->channel_mask != DefaultChannels)\n          pixel=(double) q[i];\n        if (pixel > GetPixelInfoChannel(&threshold,channel))\n          q[i]=QuantumRange;\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,ThresholdImageTag,progress,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%       TTTTT  H   H  RRRR   EEEEE  SSSSS  H   H   OOO   L      DDDD          %\n%         T    H   H  R   R  E      SS     H   H  O   O  L      D   D         %\n%         T    HHHHH  RRRR   EEE     SSS   HHHHH  O   O  L      D   D         %\n%         T    H   H  R R    E         SS  H   H  O   O  L      D   D         %\n%         T    H   H  R  R   EEEEE  SSSSS  H   H   OOO   LLLLL  DDDD          %\n%                                                                             %\n%                                                                             %\n%                      MagickCore Image Threshold Methods                     %\n%                                                                             %\n%                               Software Design                               %\n%                                    Cristy                                   %\n%                                 October 1996                                %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/cache-view.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/configure.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/decorate.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/effect.h\"\n#include \"MagickCore/fx.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/memory-private.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/montage.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/pixel-private.h\"\n#include \"MagickCore/quantize.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/random_.h\"\n#include \"MagickCore/random-private.h\"\n#include \"MagickCore/resize.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/segment.h\"\n#include \"MagickCore/shear.h\"\n#include \"MagickCore/signature-private.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/threshold.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/xml-tree.h\"\n#include \"MagickCore/xml-tree-private.h\"\n\f\n/*\n  Define declarations.\n*/\n#define ThresholdsFilename  \"thresholds.xml\"\n\f\n/*\n  Typedef declarations.\n*/\nstruct _ThresholdMap\n{\n  char\n    *map_id,\n    *description;\n\n  size_t\n    width,\n    height;\n\n  ssize_t\n    divisor,\n    *levels;\n};\n\f\n/*\n  Static declarations.\n*/\nstatic const char\n  *MinimalThresholdMap =\n    \"<?xml version=\\\"1.0\\\"?>\"\n    \"<thresholds>\"\n    \"  <threshold map=\\\"threshold\\\" alias=\\\"1x1\\\">\"\n    \"    <description>Threshold 1x1 (non-dither)</description>\"\n    \"    <levels width=\\\"1\\\" height=\\\"1\\\" divisor=\\\"2\\\">\"\n    \"        1\"\n    \"    </levels>\"\n    \"  </threshold>\"\n    \"  <threshold map=\\\"checks\\\" alias=\\\"2x1\\\">\"\n    \"    <description>Checkerboard 2x1 (dither)</description>\"\n    \"    <levels width=\\\"2\\\" height=\\\"2\\\" divisor=\\\"3\\\">\"\n    \"       1 2\"\n    \"       2 1\"\n    \"    </levels>\"\n    \"  </threshold>\"\n    \"</thresholds>\";\n\f\n/*\n  Forward declarations.\n*/\nstatic ThresholdMap\n  *GetThresholdMapFile(const char *,const char *,const char *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     A d a p t i v e T h r e s h o l d I m a g e                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AdaptiveThresholdImage() selects an individual threshold for each pixel\n%  based on the range of intensity values in its local neighborhood.  This\n%  allows for thresholding of an image whose global intensity histogram\n%  doesn't contain distinctive peaks.\n%\n%  The format of the AdaptiveThresholdImage method is:\n%\n%      Image *AdaptiveThresholdImage(const Image *image,const size_t width,\n%        const size_t height,const double bias,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o width: the width of the local neighborhood.\n%\n%    o height: the height of the local neighborhood.\n%\n%    o bias: the mean bias.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *AdaptiveThresholdImage(const Image *image,\n  const size_t width,const size_t height,const double bias,\n  ExceptionInfo *exception)\n{\n#define AdaptiveThresholdImageTag  \"AdaptiveThreshold/Image\"\n\n  CacheView\n    *image_view,\n    *threshold_view;\n\n  Image\n    *threshold_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  MagickSizeType\n    number_pixels;\n\n  ssize_t\n    y;\n\n  /*\n    Initialize threshold image attributes.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  threshold_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (threshold_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (width == 0)\n    return(threshold_image);\n  status=SetImageStorageClass(threshold_image,DirectClass,exception);\n  if (status == MagickFalse)\n    {\n      threshold_image=DestroyImage(threshold_image);\n      return((Image *) NULL);\n    }\n  /*\n    Threshold image.\n  */\n  status=MagickTrue;\n  progress=0;\n  number_pixels=(MagickSizeType) width*height;\n  image_view=AcquireVirtualCacheView(image,exception);\n  threshold_view=AcquireAuthenticCacheView(threshold_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,threshold_image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    double\n      channel_bias[MaxPixelChannels],\n      channel_sum[MaxPixelChannels];\n\n    register const Quantum\n      *magick_restrict p,\n      *magick_restrict pixels;\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      i,\n      x;\n\n    ssize_t\n      center,\n      u,\n      v;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,-((ssize_t) width/2L),y-(ssize_t)\n      (height/2L),image->columns+width,height,exception);\n    q=QueueCacheViewAuthenticPixels(threshold_view,0,y,threshold_image->columns,\n      1,exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    center=(ssize_t) GetPixelChannels(image)*(image->columns+width)*(height/2L)+\n      GetPixelChannels(image)*(width/2);\n    for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n    {\n      PixelChannel channel = GetPixelChannelChannel(image,i);\n      PixelTrait traits = GetPixelChannelTraits(image,channel);\n      PixelTrait threshold_traits=GetPixelChannelTraits(threshold_image,\n        channel);\n      if ((traits == UndefinedPixelTrait) ||\n          (threshold_traits == UndefinedPixelTrait))\n        continue;\n      if ((threshold_traits & CopyPixelTrait) != 0)\n        {\n          SetPixelChannel(threshold_image,channel,p[center+i],q);\n          continue;\n        }\n      pixels=p;\n      channel_bias[channel]=0.0;\n      channel_sum[channel]=0.0;\n      for (v=0; v < (ssize_t) height; v++)\n      {\n        for (u=0; u < (ssize_t) width; u++)\n        {\n          if (u == (ssize_t) (width-1))\n            channel_bias[channel]+=pixels[i];\n          channel_sum[channel]+=pixels[i];\n          pixels+=GetPixelChannels(image);\n        }\n        pixels+=GetPixelChannels(image)*image->columns;\n      }\n    }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        double\n          mean;\n\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        PixelTrait threshold_traits=GetPixelChannelTraits(threshold_image,\n          channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (threshold_traits == UndefinedPixelTrait))\n          continue;\n        if ((threshold_traits & CopyPixelTrait) != 0)\n          {\n            SetPixelChannel(threshold_image,channel,p[center+i],q);\n            continue;\n          }\n        channel_sum[channel]-=channel_bias[channel];\n        channel_bias[channel]=0.0;\n        pixels=p;\n        for (v=0; v < (ssize_t) height; v++)\n        {\n          channel_bias[channel]+=pixels[i];\n          pixels+=(width-1)*GetPixelChannels(image);\n          channel_sum[channel]+=pixels[i];\n          pixels+=GetPixelChannels(image)*(image->columns+1);\n        }\n        mean=(double) (channel_sum[channel]/number_pixels+bias);\n        SetPixelChannel(threshold_image,channel,(Quantum) ((double)\n          p[center+i] <= mean ? 0 : QuantumRange),q);\n      }\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(threshold_image);\n    }\n    if (SyncCacheViewAuthenticPixels(threshold_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,AdaptiveThresholdImageTag,progress,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  threshold_image->type=image->type;\n  threshold_view=DestroyCacheView(threshold_view);\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    threshold_image=DestroyImage(threshold_image);\n  return(threshold_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     A u t o T h r e s h o l d I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AutoThresholdImage()  automatically performs image thresholding\n%  dependent on which method you specify.\n%\n%  The format of the AutoThresholdImage method is:\n%\n%      MagickBooleanType AutoThresholdImage(Image *image,\n%        const AutoThresholdMethod method,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: The image to auto-threshold.\n%\n%    o method: choose from Kapur, OTSU, or Triangle.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic double KapurThreshold(const Image *image,const double *histogram,\n  ExceptionInfo *exception)\n{\n#define MaxIntensity  255\n\n  double\n    *black_entropy,\n    *cumulative_histogram,\n    entropy,\n    epsilon,\n    maximum_entropy,\n    *white_entropy;\n\n  register ssize_t\n    i,\n    j;\n\n  size_t\n    threshold;\n\n  /*\n    Compute optimal threshold from the entopy of the histogram.\n  */\n  cumulative_histogram=(double *) AcquireQuantumMemory(MaxIntensity+1UL,\n    sizeof(*cumulative_histogram));\n  black_entropy=(double *) AcquireQuantumMemory(MaxIntensity+1UL,\n    sizeof(*black_entropy));\n  white_entropy=(double *) AcquireQuantumMemory(MaxIntensity+1UL,\n    sizeof(*white_entropy));\n  if ((cumulative_histogram == (double *) NULL) ||\n      (black_entropy == (double *) NULL) || (white_entropy == (double *) NULL))\n    {\n      if (white_entropy != (double *) NULL)\n        white_entropy=(double *) RelinquishMagickMemory(white_entropy);\n      if (black_entropy != (double *) NULL)\n        black_entropy=(double *) RelinquishMagickMemory(black_entropy);\n      if (cumulative_histogram != (double *) NULL)\n        cumulative_histogram=(double *)\n          RelinquishMagickMemory(cumulative_histogram);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(-1.0);\n    }\n   /*\n     Entropy for black and white parts of the histogram.\n   */\n   cumulative_histogram[0]=histogram[0];\n   for (i=1; i <= MaxIntensity; i++)\n     cumulative_histogram[i]=cumulative_histogram[i-1]+histogram[i];\n   epsilon=MagickMinimumValue;\n   for (j=0; j <= MaxIntensity; j++)\n   {\n     /*\n       Black entropy.\n     */\n     black_entropy[j]=0.0;\n     if (cumulative_histogram[j] > epsilon)\n       {\n         entropy=0.0;\n         for (i=0; i <= j; i++)\n           if (histogram[i] > epsilon)\n             entropy-=histogram[i]/cumulative_histogram[j]*\n               log(histogram[i]/cumulative_histogram[j]);\n         black_entropy[j]=entropy;\n       }\n     /*\n       White entropy.\n     */\n     white_entropy[j]=0.0;\n     if ((1.0-cumulative_histogram[j]) > epsilon)\n       {\n         entropy=0.0;\n         for (i=j+1; i <= MaxIntensity; i++)\n           if (histogram[i] > epsilon)\n             entropy-=histogram[i]/(1.0-cumulative_histogram[j])*\n               log(histogram[i]/(1.0-cumulative_histogram[j]));\n         white_entropy[j]=entropy;\n       }\n   }\n  /*\n    Find histogram bin with maximum entropy.\n  */\n  maximum_entropy=black_entropy[0]+white_entropy[0];\n  threshold=0;\n  for (j=1; j <= MaxIntensity; j++)\n    if ((black_entropy[j]+white_entropy[j]) > maximum_entropy)\n      {\n        maximum_entropy=black_entropy[j]+white_entropy[j];\n        threshold=(size_t) j;\n      }\n  /*\n    Free resources.\n  */\n  white_entropy=(double *) RelinquishMagickMemory(white_entropy);\n  black_entropy=(double *) RelinquishMagickMemory(black_entropy);\n  cumulative_histogram=(double *) RelinquishMagickMemory(cumulative_histogram);\n  return(100.0*threshold/MaxIntensity);\n}\n\nstatic double OTSUThreshold(const Image *image,const double *histogram,\n  ExceptionInfo *exception)\n{\n  double\n    max_sigma,\n    *myu,\n    *omega,\n    *probability,\n    *sigma,\n    threshold;\n\n  register ssize_t\n    i;\n\n  /*\n    Compute optimal threshold from maximization of inter-class variance.\n  */\n  myu=(double *) AcquireQuantumMemory(MaxIntensity+1UL,sizeof(*myu));\n  omega=(double *) AcquireQuantumMemory(MaxIntensity+1UL,sizeof(*omega));\n  probability=(double *) AcquireQuantumMemory(MaxIntensity+1UL,\n    sizeof(*probability));\n  sigma=(double *) AcquireQuantumMemory(MaxIntensity+1UL,sizeof(*sigma));\n  if ((myu == (double *) NULL) || (omega == (double *) NULL) ||\n      (probability == (double *) NULL) || (sigma == (double *) NULL))\n    {\n      if (sigma != (double *) NULL)\n        sigma=(double *) RelinquishMagickMemory(sigma);\n      if (probability != (double *) NULL)\n        probability=(double *) RelinquishMagickMemory(probability);\n      if (omega != (double *) NULL)\n        omega=(double *) RelinquishMagickMemory(omega);\n      if (myu != (double *) NULL)\n        myu=(double *) RelinquishMagickMemory(myu);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(-1.0);\n    }\n  /*\n    Calculate probability density.\n  */\n  for (i=0; i <= (ssize_t) MaxIntensity; i++)\n    probability[i]=histogram[i];\n  /*\n    Generate probability of graylevels and mean value for separation.\n  */\n  omega[0]=probability[0];\n  myu[0]=0.0;\n  for (i=1; i <= (ssize_t) MaxIntensity; i++)\n  {\n    omega[i]=omega[i-1]+probability[i];\n    myu[i]=myu[i-1]+i*probability[i];\n  }\n  /*\n    Sigma maximization: inter-class variance and compute optimal threshold.\n  */\n  threshold=0;\n  max_sigma=0.0;\n  for (i=0; i < (ssize_t) MaxIntensity; i++)\n  {\n    sigma[i]=0.0;\n    if ((omega[i] != 0.0) && (omega[i] != 1.0))\n      sigma[i]=pow(myu[MaxIntensity]*omega[i]-myu[i],2.0)/(omega[i]*(1.0-\n        omega[i]));\n    if (sigma[i] > max_sigma)\n      {\n        max_sigma=sigma[i];\n        threshold=(double) i;\n      }\n  }\n  /*\n    Free resources.\n  */\n  myu=(double *) RelinquishMagickMemory(myu);\n  omega=(double *) RelinquishMagickMemory(omega);\n  probability=(double *) RelinquishMagickMemory(probability);\n  sigma=(double *) RelinquishMagickMemory(sigma);\n  return(100.0*threshold/MaxIntensity);\n}\n\nstatic double TriangleThreshold(const double *histogram)\n{\n  double\n    a,\n    b,\n    c,\n    count,\n    distance,\n    inverse_ratio,\n    max_distance,\n    segment,\n    x1,\n    x2,\n    y1,\n    y2;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    end,\n    max,\n    start,\n    threshold;\n\n  /*\n    Compute optimal threshold with triangle algorithm.\n  */\n  start=0;  /* find start bin, first bin not zero count */\n  for (i=0; i <= (ssize_t) MaxIntensity; i++)\n    if (histogram[i] > 0.0)\n      {\n        start=i;\n        break;\n      }\n  end=0;  /* find end bin, last bin not zero count */\n  for (i=(ssize_t) MaxIntensity; i >= 0; i--)\n    if (histogram[i] > 0.0)\n      {\n        end=i;\n        break;\n      }\n  max=0;  /* find max bin, bin with largest count */\n  count=0.0;\n  for (i=0; i <= (ssize_t) MaxIntensity; i++)\n    if (histogram[i] > count)\n      {\n        max=i;\n        count=histogram[i];\n      }\n  /*\n    Compute threshold at split point.\n  */\n  x1=(double) max;\n  y1=histogram[max];\n  x2=(double) end;\n  if ((max-start) >= (end-max))\n    x2=(double) start;\n  y2=0.0;\n  a=y1-y2;\n  b=x2-x1;\n  c=(-1.0)*(a*x1+b*y1);\n  inverse_ratio=1.0/sqrt(a*a+b*b+c*c);\n  threshold=0;\n  max_distance=0.0;\n  if (x2 == (double) start)\n    for (i=start; i < max; i++)\n    {\n      segment=inverse_ratio*(a*i+b*histogram[i]+c);\n      distance=sqrt(segment*segment);\n      if ((distance > max_distance) && (segment > 0.0))\n        {\n          threshold=i;\n          max_distance=distance;\n        }\n    }\n  else\n    for (i=end; i > max; i--)\n    {\n      segment=inverse_ratio*(a*i+b*histogram[i]+c);\n      distance=sqrt(segment*segment);\n      if ((distance > max_distance) && (segment < 0.0))\n        {\n          threshold=i;\n          max_distance=distance;\n        }\n    }\n  return(100.0*threshold/MaxIntensity);\n}\n\nMagickExport MagickBooleanType AutoThresholdImage(Image *image,\n  const AutoThresholdMethod method,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  char\n    property[MagickPathExtent];\n\n  double\n    gamma,\n    *histogram,\n    sum,\n    threshold;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  /*\n    Form histogram.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  histogram=(double *) AcquireQuantumMemory(MaxIntensity+1UL,\n    sizeof(*histogram));\n  if (histogram == (double *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  status=MagickTrue;\n  (void) memset(histogram,0,(MaxIntensity+1UL)*sizeof(*histogram));\n  image_view=AcquireVirtualCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double intensity = GetPixelIntensity(image,p);\n      histogram[ScaleQuantumToChar(ClampToQuantum(intensity))]++;\n      p+=GetPixelChannels(image);\n    }\n  }\n  image_view=DestroyCacheView(image_view);\n  /*\n    Normalize histogram.\n  */\n  sum=0.0;\n  for (i=0; i <= (ssize_t) MaxIntensity; i++)\n    sum+=histogram[i];\n  gamma=PerceptibleReciprocal(sum);\n  for (i=0; i <= (ssize_t) MaxIntensity; i++)\n    histogram[i]=gamma*histogram[i];\n  /*\n    Discover threshold from histogram.\n  */\n  switch (method)\n  {\n    case KapurThresholdMethod:\n    {\n      threshold=KapurThreshold(image,histogram,exception);\n      break;\n    }\n    case OTSUThresholdMethod:\n    default:\n    {\n      threshold=OTSUThreshold(image,histogram,exception);\n      break;\n    }\n    case TriangleThresholdMethod:\n    {\n      threshold=TriangleThreshold(histogram);\n      break;\n    }\n  }\n  histogram=(double *) RelinquishMagickMemory(histogram);\n  if (threshold < 0.0)\n    status=MagickFalse;\n  if (status == MagickFalse)\n    return(MagickFalse);\n  /*\n    Threshold image.\n  */\n  (void) FormatLocaleString(property,MagickPathExtent,\"%g%%\",threshold);\n  (void) SetImageProperty(image,\"auto-threshold:threshold\",property,exception);\n  return(BilevelImage(image,QuantumRange*threshold/100.0,exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     B i l e v e l I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  BilevelImage() changes the value of individual pixels based on the\n%  intensity of each pixel channel.  The result is a high-contrast image.\n%\n%  More precisely each channel value of the image is 'thresholded' so that if\n%  it is equal to or less than the given value it is set to zero, while any\n%  value greater than that give is set to it maximum or QuantumRange.\n%\n%  This function is what is used to implement the \"-threshold\" operator for\n%  the command line API.\n%\n%  If the default channel setting is given the image is thresholded using just\n%  the gray 'intensity' of the image, rather than the individual channels.\n%\n%  The format of the BilevelImage method is:\n%\n%      MagickBooleanType BilevelImage(Image *image,const double threshold,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o threshold: define the threshold values.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n%  Aside: You can get the same results as operator using LevelImages()\n%  with the 'threshold' value for both the black_point and the white_point.\n%\n*/\nMagickExport MagickBooleanType BilevelImage(Image *image,const double threshold,\n  ExceptionInfo *exception)\n{\n#define ThresholdImageTag  \"Threshold/Image\"\n\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  if (IsGrayColorspace(image->colorspace) != MagickFalse)\n    (void) SetImageColorspace(image,sRGBColorspace,exception);\n  /*\n    Bilevel threshold image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        pixel;\n\n      register ssize_t\n        i;\n\n      pixel=GetPixelIntensity(image,q);\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        if (image->channel_mask != DefaultChannels)\n          pixel=(double) q[i];\n        q[i]=(Quantum) (pixel <= threshold ? 0 : QuantumRange);\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,ThresholdImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     B l a c k T h r e s h o l d I m a g e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  BlackThresholdImage() is like ThresholdImage() but forces all pixels below\n%  the threshold into black while leaving all pixels at or above the threshold\n%  unchanged.\n%\n%  The format of the BlackThresholdImage method is:\n%\n%      MagickBooleanType BlackThresholdImage(Image *image,\n%        const char *threshold,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o threshold: define the threshold value.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType BlackThresholdImage(Image *image,\n  const char *thresholds,ExceptionInfo *exception)\n{\n#define ThresholdImageTag  \"Threshold/Image\"\n\n  CacheView\n    *image_view;\n\n  GeometryInfo\n    geometry_info;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  PixelInfo\n    threshold;\n\n  MagickStatusType\n    flags;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (thresholds == (const char *) NULL)\n    return(MagickTrue);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  if (IsGrayColorspace(image->colorspace) != MagickFalse)\n    (void) SetImageColorspace(image,sRGBColorspace,exception);\n  GetPixelInfo(image,&threshold);\n  flags=ParseGeometry(thresholds,&geometry_info);\n  threshold.red=geometry_info.rho;\n  threshold.green=geometry_info.rho;\n  threshold.blue=geometry_info.rho;\n  threshold.black=geometry_info.rho;\n  threshold.alpha=100.0;\n  if ((flags & SigmaValue) != 0)\n    threshold.green=geometry_info.sigma;\n  if ((flags & XiValue) != 0)\n    threshold.blue=geometry_info.xi;\n  if ((flags & PsiValue) != 0)\n    threshold.alpha=geometry_info.psi;\n  if (threshold.colorspace == CMYKColorspace)\n    {\n      if ((flags & PsiValue) != 0)\n        threshold.black=geometry_info.psi;\n      if ((flags & ChiValue) != 0)\n        threshold.alpha=geometry_info.chi;\n    }\n  if ((flags & PercentValue) != 0)\n    {\n      threshold.red*=(MagickRealType) (QuantumRange/100.0);\n      threshold.green*=(MagickRealType) (QuantumRange/100.0);\n      threshold.blue*=(MagickRealType) (QuantumRange/100.0);\n      threshold.black*=(MagickRealType) (QuantumRange/100.0);\n      threshold.alpha*=(MagickRealType) (QuantumRange/100.0);\n    }\n  /*\n    White threshold image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        pixel;\n\n      register ssize_t\n        i;\n\n      pixel=GetPixelIntensity(image,q);\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        if (image->channel_mask != DefaultChannels)\n          pixel=(double) q[i];\n        if (pixel < GetPixelInfoChannel(&threshold,channel))\n          q[i]=(Quantum) 0;\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,ThresholdImageTag,progress,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     C l a m p I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ClampImage() set each pixel whose value is below zero to zero and any the\n%  pixel whose value is above the quantum range to the quantum range (e.g.\n%  65535) otherwise the pixel value remains unchanged.\n%\n%  The format of the ClampImage method is:\n%\n%      MagickBooleanType ClampImage(Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nMagickExport MagickBooleanType ClampImage(Image *image,ExceptionInfo *exception)\n{\n#define ClampImageTag  \"Clamp/Image\"\n\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->storage_class == PseudoClass)\n    {\n      register ssize_t\n        i;\n\n      register PixelInfo\n        *magick_restrict q;\n\n      q=image->colormap;\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        q->red=(double) ClampPixel(q->red);\n        q->green=(double) ClampPixel(q->green);\n        q->blue=(double) ClampPixel(q->blue);\n        q->alpha=(double) ClampPixel(q->alpha);\n        q++;\n      }\n      return(SyncImage(image,exception));\n    }\n  /*\n    Clamp image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        q[i]=ClampPixel((MagickRealType) q[i]);\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,ClampImageTag,progress,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  D e s t r o y T h r e s h o l d M a p                                      %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyThresholdMap() de-allocate the given ThresholdMap\n%\n%  The format of the ListThresholdMaps method is:\n%\n%      ThresholdMap *DestroyThresholdMap(Threshold *map)\n%\n%  A description of each parameter follows.\n%\n%    o map:    Pointer to the Threshold map to destroy\n%\n*/\nMagickExport ThresholdMap *DestroyThresholdMap(ThresholdMap *map)\n{\n  assert(map != (ThresholdMap *) NULL);\n  if (map->map_id != (char *) NULL)\n    map->map_id=DestroyString(map->map_id);\n  if (map->description != (char *) NULL)\n    map->description=DestroyString(map->description);\n  if (map->levels != (ssize_t *) NULL)\n    map->levels=(ssize_t *) RelinquishMagickMemory(map->levels);\n  map=(ThresholdMap *) RelinquishMagickMemory(map);\n  return(map);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  G e t T h r e s h o l d M a p                                              %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetThresholdMap() loads and searches one or more threshold map files for the\n%  map matching the given name or alias.\n%\n%  The format of the GetThresholdMap method is:\n%\n%      ThresholdMap *GetThresholdMap(const char *map_id,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o map_id:  ID of the map to look for.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport ThresholdMap *GetThresholdMap(const char *map_id,\n  ExceptionInfo *exception)\n{\n  ThresholdMap\n    *map;\n\n  map=GetThresholdMapFile(MinimalThresholdMap,\"built-in\",map_id,exception);\n  if (map != (ThresholdMap *) NULL)\n    return(map);\n#if !defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\n  {\n    const StringInfo\n      *option;\n\n    LinkedListInfo\n      *options;\n\n    options=GetConfigureOptions(ThresholdsFilename,exception);\n    option=(const StringInfo *) GetNextValueInLinkedList(options);\n    while (option != (const StringInfo *) NULL)\n    {\n      map=GetThresholdMapFile((const char *) GetStringInfoDatum(option),\n        GetStringInfoPath(option),map_id,exception);\n      if (map != (ThresholdMap *) NULL)\n        break;\n      option=(const StringInfo *) GetNextValueInLinkedList(options);\n    }\n    options=DestroyConfigureOptions(options);\n  }\n#endif\n  return(map);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  G e t T h r e s h o l d M a p F i l e                                      %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetThresholdMapFile() look for a given threshold map name or alias in the\n%  given XML file data, and return the allocated the map when found.\n%\n%  The format of the ListThresholdMaps method is:\n%\n%      ThresholdMap *GetThresholdMap(const char *xml,const char *filename,\n%         const char *map_id,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o xml:  The threshold map list in XML format.\n%\n%    o filename:  The threshold map XML filename.\n%\n%    o map_id:  ID of the map to look for in XML list.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic ThresholdMap *GetThresholdMapFile(const char *xml,const char *filename,\n  const char *map_id,ExceptionInfo *exception)\n{\n  char\n    *p;\n\n  const char\n    *attribute,\n    *content;\n\n  double\n    value;\n\n  register ssize_t\n    i;\n\n  ThresholdMap\n    *map;\n\n  XMLTreeInfo\n    *description,\n    *levels,\n    *threshold,\n    *thresholds;\n\n  (void) LogMagickEvent(ConfigureEvent,GetMagickModule(),\n    \"Loading threshold map file \\\"%s\\\" ...\",filename);\n  map=(ThresholdMap *) NULL;\n  thresholds=NewXMLTree(xml,exception);\n  if (thresholds == (XMLTreeInfo *) NULL)\n    return(map);\n  for (threshold=GetXMLTreeChild(thresholds,\"threshold\");\n       threshold != (XMLTreeInfo *) NULL;\n       threshold=GetNextXMLTreeTag(threshold))\n  {\n    attribute=GetXMLTreeAttribute(threshold,\"map\");\n    if ((attribute != (char *) NULL) && (LocaleCompare(map_id,attribute) == 0))\n      break;\n    attribute=GetXMLTreeAttribute(threshold,\"alias\");\n    if ((attribute != (char *) NULL) && (LocaleCompare(map_id,attribute) == 0))\n      break;\n  }\n  if (threshold == (XMLTreeInfo *) NULL)\n    {\n      thresholds=DestroyXMLTree(thresholds);\n      return(map);\n    }\n  description=GetXMLTreeChild(threshold,\"description\");\n  if (description == (XMLTreeInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingElement\", \"<description>, map \\\"%s\\\"\",map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      return(map);\n    }\n  levels=GetXMLTreeChild(threshold,\"levels\");\n  if (levels == (XMLTreeInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingElement\", \"<levels>, map \\\"%s\\\"\", map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      return(map);\n    }\n  map=(ThresholdMap *) AcquireCriticalMemory(sizeof(*map));\n  map->map_id=(char *) NULL;\n  map->description=(char *) NULL;\n  map->levels=(ssize_t *) NULL;\n  attribute=GetXMLTreeAttribute(threshold,\"map\");\n  if (attribute != (char *) NULL)\n    map->map_id=ConstantString(attribute);\n  content=GetXMLTreeContent(description);\n  if (content != (char *) NULL)\n    map->description=ConstantString(content);\n  attribute=GetXMLTreeAttribute(levels,\"width\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\", \"<levels width>, map \\\"%s\\\"\",map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      map=DestroyThresholdMap(map);\n      return(map);\n    }\n  map->width=StringToUnsignedLong(attribute);\n  if (map->width == 0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n       \"XmlInvalidAttribute\", \"<levels width>, map \\\"%s\\\"\",map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      map=DestroyThresholdMap(map);\n      return(map);\n    }\n  attribute=GetXMLTreeAttribute(levels,\"height\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\", \"<levels height>, map \\\"%s\\\"\",map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      map=DestroyThresholdMap(map);\n      return(map);\n    }\n  map->height=StringToUnsignedLong(attribute);\n  if (map->height == 0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidAttribute\", \"<levels height>, map \\\"%s\\\"\",map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      map=DestroyThresholdMap(map);\n      return(map);\n    }\n  attribute=GetXMLTreeAttribute(levels,\"divisor\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\", \"<levels divisor>, map \\\"%s\\\"\",map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      map=DestroyThresholdMap(map);\n      return(map);\n    }\n  map->divisor=(ssize_t) StringToLong(attribute);\n  if (map->divisor < 2)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidAttribute\", \"<levels divisor>, map \\\"%s\\\"\",map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      map=DestroyThresholdMap(map);\n      return(map);\n    }\n  content=GetXMLTreeContent(levels);\n  if (content == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingContent\", \"<levels>, map \\\"%s\\\"\",map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      map=DestroyThresholdMap(map);\n      return(map);\n    }\n  map->levels=(ssize_t *) AcquireQuantumMemory((size_t) map->width,map->height*\n    sizeof(*map->levels));\n  if (map->levels == (ssize_t *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"UnableToAcquireThresholdMap\");\n  for (i=0; i < (ssize_t) (map->width*map->height); i++)\n  {\n    map->levels[i]=(ssize_t) strtol(content,&p,10);\n    if (p == content)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n          \"XmlInvalidContent\", \"<level> too few values, map \\\"%s\\\"\",map_id);\n        thresholds=DestroyXMLTree(thresholds);\n        map=DestroyThresholdMap(map);\n        return(map);\n      }\n    if ((map->levels[i] < 0) || (map->levels[i] > map->divisor))\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n          \"XmlInvalidContent\", \"<level> %.20g out of range, map \\\"%s\\\"\",\n          (double) map->levels[i],map_id);\n        thresholds=DestroyXMLTree(thresholds);\n        map=DestroyThresholdMap(map);\n        return(map);\n      }\n    content=p;\n  }\n  value=(double) strtol(content,&p,10);\n  (void) value;\n  if (p != content)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidContent\", \"<level> too many values, map \\\"%s\\\"\",map_id);\n     thresholds=DestroyXMLTree(thresholds);\n     map=DestroyThresholdMap(map);\n     return(map);\n   }\n  thresholds=DestroyXMLTree(thresholds);\n  return(map);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  L i s t T h r e s h o l d M a p F i l e                                    %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ListThresholdMapFile() lists the threshold maps and their descriptions\n%  in the given XML file data.\n%\n%  The format of the ListThresholdMaps method is:\n%\n%      MagickBooleanType ListThresholdMaps(FILE *file,const char*xml,\n%         const char *filename,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o file:  An pointer to the output FILE.\n%\n%    o xml:  The threshold map list in XML format.\n%\n%    o filename:  The threshold map XML filename.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickBooleanType ListThresholdMapFile(FILE *file,const char *xml,\n  const char *filename,ExceptionInfo *exception)\n{\n  const char\n    *alias,\n    *content,\n    *map;\n\n  XMLTreeInfo\n    *description,\n    *threshold,\n    *thresholds;\n\n  assert( xml != (char *) NULL );\n  assert( file != (FILE *) NULL );\n  (void) LogMagickEvent(ConfigureEvent,GetMagickModule(),\n    \"Loading threshold map file \\\"%s\\\" ...\",filename);\n  thresholds=NewXMLTree(xml,exception);\n  if ( thresholds == (XMLTreeInfo *) NULL )\n    return(MagickFalse);\n  (void) FormatLocaleFile(file,\"%-16s %-12s %s\\n\",\"Map\",\"Alias\",\"Description\");\n  (void) FormatLocaleFile(file,\n    \"----------------------------------------------------\\n\");\n  threshold=GetXMLTreeChild(thresholds,\"threshold\");\n  for ( ; threshold != (XMLTreeInfo *) NULL;\n          threshold=GetNextXMLTreeTag(threshold))\n  {\n    map=GetXMLTreeAttribute(threshold,\"map\");\n    if (map == (char *) NULL)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n          \"XmlMissingAttribute\", \"<map>\");\n        thresholds=DestroyXMLTree(thresholds);\n        return(MagickFalse);\n      }\n    alias=GetXMLTreeAttribute(threshold,\"alias\");\n    description=GetXMLTreeChild(threshold,\"description\");\n    if (description == (XMLTreeInfo *) NULL)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n          \"XmlMissingElement\", \"<description>, map \\\"%s\\\"\",map);\n        thresholds=DestroyXMLTree(thresholds);\n        return(MagickFalse);\n      }\n    content=GetXMLTreeContent(description);\n    if (content == (char *) NULL)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n          \"XmlMissingContent\", \"<description>, map \\\"%s\\\"\", map);\n        thresholds=DestroyXMLTree(thresholds);\n        return(MagickFalse);\n      }\n    (void) FormatLocaleFile(file,\"%-16s %-12s %s\\n\",map,alias ? alias : \"\",\n      content);\n  }\n  thresholds=DestroyXMLTree(thresholds);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  L i s t T h r e s h o l d M a p s                                          %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ListThresholdMaps() lists the threshold maps and their descriptions\n%  as defined by \"threshold.xml\" to a file.\n%\n%  The format of the ListThresholdMaps method is:\n%\n%      MagickBooleanType ListThresholdMaps(FILE *file,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o file:  An pointer to the output FILE.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType ListThresholdMaps(FILE *file,\n  ExceptionInfo *exception)\n{\n  const StringInfo\n    *option;\n\n  LinkedListInfo\n    *options;\n\n  MagickStatusType\n    status;\n\n  status=MagickTrue;\n  if (file == (FILE *) NULL)\n    file=stdout;\n  options=GetConfigureOptions(ThresholdsFilename,exception);\n  (void) FormatLocaleFile(file,\n    \"\\n   Threshold Maps for Ordered Dither Operations\\n\");\n  option=(const StringInfo *) GetNextValueInLinkedList(options);\n  while (option != (const StringInfo *) NULL)\n  {\n    (void) FormatLocaleFile(file,\"\\nPath: %s\\n\\n\",GetStringInfoPath(option));\n    status&=ListThresholdMapFile(file,(const char *) GetStringInfoDatum(option),\n      GetStringInfoPath(option),exception);\n    option=(const StringInfo *) GetNextValueInLinkedList(options);\n  }\n  options=DestroyConfigureOptions(options);\n  return(status != 0 ? MagickTrue : MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     O r d e r e d D i t h e r I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  OrderedDitherImage() will perform a ordered dither based on a number\n%  of pre-defined dithering threshold maps, but over multiple intensity\n%  levels, which can be different for different channels, according to the\n%  input argument.\n%\n%  The format of the OrderedDitherImage method is:\n%\n%      MagickBooleanType OrderedDitherImage(Image *image,\n%        const char *threshold_map,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o threshold_map: A string containing the name of the threshold dither\n%      map to use, followed by zero or more numbers representing the number\n%      of color levels tho dither between.\n%\n%      Any level number less than 2 will be equivalent to 2, and means only\n%      binary dithering will be applied to each color channel.\n%\n%      No numbers also means a 2 level (bitmap) dither will be applied to all\n%      channels, while a single number is the number of levels applied to each\n%      channel in sequence.  More numbers will be applied in turn to each of\n%      the color channels.\n%\n%      For example: \"o3x3,6\" will generate a 6 level posterization of the\n%      image with a ordered 3x3 diffused pixel dither being applied between\n%      each level. While checker,8,8,4 will produce a 332 colormaped image\n%      with only a single checkerboard hash pattern (50% grey) between each\n%      color level, to basically double the number of color levels with\n%      a bare minimim of dithering.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType OrderedDitherImage(Image *image,\n  const char *threshold_map,ExceptionInfo *exception)\n{\n#define DitherImageTag  \"Dither/Image\"\n\n  CacheView\n    *image_view;\n\n  char\n    token[MagickPathExtent];\n\n  const char\n    *p;\n\n  double\n    levels[CompositePixelChannel];\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  ThresholdMap\n    *map;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (threshold_map == (const char *) NULL)\n    return(MagickTrue);\n  p=(char *) threshold_map;\n  while (((isspace((int) ((unsigned char) *p)) != 0) || (*p == ',')) &&\n         (*p != '\\0'))\n    p++;\n  threshold_map=p;\n  while (((isspace((int) ((unsigned char) *p)) == 0) && (*p != ',')) &&\n         (*p != '\\0'))\n  {\n    if ((p-threshold_map) >= (MagickPathExtent-1))\n      break;\n    token[p-threshold_map]=(*p);\n    p++;\n  }\n  token[p-threshold_map]='\\0';\n  map=GetThresholdMap(token,exception);\n  if (map == (ThresholdMap *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"InvalidArgument\",\"%s : '%s'\",\"ordered-dither\",threshold_map);\n      return(MagickFalse);\n    }\n  for (i=0; i < MaxPixelChannels; i++)\n    levels[i]=2.0;\n  p=strchr((char *) threshold_map,',');\n  if ((p != (char *) NULL) && (isdigit((int) ((unsigned char) *(++p))) != 0))\n    {\n      GetNextToken(p,&p,MagickPathExtent,token);\n      for (i=0; (i < MaxPixelChannels); i++)\n        levels[i]=StringToDouble(token,(char **) NULL);\n      for (i=0; (*p != '\\0') && (i < MaxPixelChannels); i++)\n      {\n        GetNextToken(p,&p,MagickPathExtent,token);\n        if (*token == ',')\n          GetNextToken(p,&p,MagickPathExtent,token);\n        levels[i]=StringToDouble(token,(char **) NULL);\n      }\n    }\n  for (i=0; i < MaxPixelChannels; i++)\n    if (fabs(levels[i]) >= 1)\n      levels[i]-=1.0;\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      ssize_t\n        n;\n\n      n=0;\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        ssize_t\n          level,\n          threshold;\n\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        if (fabs(levels[n]) < MagickEpsilon)\n          {\n            n++;\n            continue;\n          }\n        threshold=(ssize_t) (QuantumScale*q[i]*(levels[n]*(map->divisor-1)+1));\n        level=threshold/(map->divisor-1);\n        threshold-=level*(map->divisor-1);\n        q[i]=ClampToQuantum((double) (level+(threshold >=\n          map->levels[(x % map->width)+map->width*(y % map->height)]))*\n          QuantumRange/levels[n]);\n        n++;\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,DitherImageTag,progress,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  map=DestroyThresholdMap(map);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     P e r c e p t i b l e I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  PerceptibleImage() set each pixel whose value is less than |epsilon| to\n%  epsilon or -epsilon (whichever is closer) otherwise the pixel value remains\n%  unchanged.\n%\n%  The format of the PerceptibleImage method is:\n%\n%      MagickBooleanType PerceptibleImage(Image *image,const double epsilon,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o epsilon: the epsilon threshold (e.g. 1.0e-9).\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline Quantum PerceptibleThreshold(const Quantum quantum,\n  const double epsilon)\n{\n  double\n    sign;\n\n  sign=(double) quantum < 0.0 ? -1.0 : 1.0;\n  if ((sign*quantum) >= epsilon)\n    return(quantum);\n  return((Quantum) (sign*epsilon));\n}\n\nMagickExport MagickBooleanType PerceptibleImage(Image *image,\n  const double epsilon,ExceptionInfo *exception)\n{\n#define PerceptibleImageTag  \"Perceptible/Image\"\n\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->storage_class == PseudoClass)\n    {\n      register ssize_t\n        i;\n\n      register PixelInfo\n        *magick_restrict q;\n\n      q=image->colormap;\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        q->red=(double) PerceptibleThreshold(ClampToQuantum(q->red),\n          epsilon);\n        q->green=(double) PerceptibleThreshold(ClampToQuantum(q->green),\n          epsilon);\n        q->blue=(double) PerceptibleThreshold(ClampToQuantum(q->blue),\n          epsilon);\n        q->alpha=(double) PerceptibleThreshold(ClampToQuantum(q->alpha),\n          epsilon);\n        q++;\n      }\n      return(SyncImage(image,exception));\n    }\n  /*\n    Perceptible image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        if (traits == UndefinedPixelTrait)\n          continue;\n        q[i]=PerceptibleThreshold(q[i],epsilon);\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,PerceptibleImageTag,progress,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     R a n d o m T h r e s h o l d I m a g e                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RandomThresholdImage() changes the value of individual pixels based on the\n%  intensity of each pixel compared to a random threshold.  The result is a\n%  low-contrast, two color image.\n%\n%  The format of the RandomThresholdImage method is:\n%\n%      MagickBooleanType RandomThresholdImage(Image *image,\n%        const char *thresholds,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o low,high: Specify the high and low thresholds. These values range from\n%      0 to QuantumRange.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType RandomThresholdImage(Image *image,\n  const double min_threshold, const double max_threshold,ExceptionInfo *exception)\n{\n#define ThresholdImageTag  \"Threshold/Image\"\n\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  PixelInfo\n    threshold;\n\n  RandomInfo\n    **magick_restrict random_info;\n\n  ssize_t\n    y;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  unsigned long\n    key;\n#endif\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  GetPixelInfo(image,&threshold);\n  /*\n    Random threshold image.\n  */\n  status=MagickTrue;\n  progress=0;\n  random_info=AcquireRandomInfoThreadSet();\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  key=GetRandomSecretKey(random_info[0]);\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,image,image->rows,key == ~0UL)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    const int\n      id = GetOpenMPThreadId();\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        double\n          threshold;\n\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        if ((double) q[i] < min_threshold)\n          threshold=min_threshold;\n        else\n          if ((double) q[i] > max_threshold)\n            threshold=max_threshold;\n          else\n            threshold=(double) (QuantumRange*\n              GetPseudoRandomValue(random_info[id]));\n        q[i]=(double) q[i] <= threshold ? 0 : QuantumRange;\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,ThresholdImageTag,progress,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  random_info=DestroyRandomInfoThreadSet(random_info);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     R a n g e T h r e s h o l d I m a g e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RangeThresholdImage() applies soft and hard thresholding.\n%\n%  The format of the RangeThresholdImage method is:\n%\n%      MagickBooleanType RangeThresholdImage(Image *image,\n%        const double low_black,const double low_white,const double high_white,\n%        const double high_black,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o low_black: Define the minimum black threshold value.\n%\n%    o low_white: Define the minimum white threshold value.\n%\n%    o high_white: Define the maximum white threshold value.\n%\n%    o high_black: Define the maximum black threshold value.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType RangeThresholdImage(Image *image,\n  const double low_black,const double low_white,const double high_white,\n  const double high_black,ExceptionInfo *exception)\n{\n#define ThresholdImageTag  \"Threshold/Image\"\n\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  if (IsGrayColorspace(image->colorspace) != MagickFalse)\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  /*\n    Range threshold image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        pixel;\n\n      register ssize_t\n        i;\n\n      pixel=GetPixelIntensity(image,q);\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        if (image->channel_mask != DefaultChannels)\n          pixel=(double) q[i];\n        if (pixel < low_black)\n          q[i]=0;\n        else\n          if ((pixel >= low_black) && (pixel < low_white))\n            q[i]=ClampToQuantum(QuantumRange*\n              PerceptibleReciprocal(low_white-low_black)*(pixel-low_black));\n          else\n            if ((pixel >= low_white) && (pixel <= high_white))\n              q[i]=QuantumRange;\n            else\n              if ((pixel > high_white) && (pixel <= high_black))\n                q[i]=ClampToQuantum(QuantumRange*PerceptibleReciprocal(\n                  high_black-high_white)*(high_black-pixel));\n              else\n                if (pixel > high_black)\n                  q[i]=0;\n                else\n                  q[i]=0;\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,ThresholdImageTag,progress,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     W h i t e T h r e s h o l d I m a g e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WhiteThresholdImage() is like ThresholdImage() but forces all pixels above\n%  the threshold into white while leaving all pixels at or below the threshold\n%  unchanged.\n%\n%  The format of the WhiteThresholdImage method is:\n%\n%      MagickBooleanType WhiteThresholdImage(Image *image,\n%        const char *threshold,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o threshold: Define the threshold value.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType WhiteThresholdImage(Image *image,\n  const char *thresholds,ExceptionInfo *exception)\n{\n#define ThresholdImageTag  \"Threshold/Image\"\n\n  CacheView\n    *image_view;\n\n  GeometryInfo\n    geometry_info;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  PixelInfo\n    threshold;\n\n  MagickStatusType\n    flags;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (thresholds == (const char *) NULL)\n    return(MagickTrue);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  if (IsGrayColorspace(image->colorspace) != MagickFalse)\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  GetPixelInfo(image,&threshold);\n  flags=ParseGeometry(thresholds,&geometry_info);\n  threshold.red=geometry_info.rho;\n  threshold.green=geometry_info.rho;\n  threshold.blue=geometry_info.rho;\n  threshold.black=geometry_info.rho;\n  threshold.alpha=100.0;\n  if ((flags & SigmaValue) != 0)\n    threshold.green=geometry_info.sigma;\n  if ((flags & XiValue) != 0)\n    threshold.blue=geometry_info.xi;\n  if ((flags & PsiValue) != 0)\n    threshold.alpha=geometry_info.psi;\n  if (threshold.colorspace == CMYKColorspace)\n    {\n      if ((flags & PsiValue) != 0)\n        threshold.black=geometry_info.psi;\n      if ((flags & ChiValue) != 0)\n        threshold.alpha=geometry_info.chi;\n    }\n  if ((flags & PercentValue) != 0)\n    {\n      threshold.red*=(MagickRealType) (QuantumRange/100.0);\n      threshold.green*=(MagickRealType) (QuantumRange/100.0);\n      threshold.blue*=(MagickRealType) (QuantumRange/100.0);\n      threshold.black*=(MagickRealType) (QuantumRange/100.0);\n      threshold.alpha*=(MagickRealType) (QuantumRange/100.0);\n    }\n  /*\n    White threshold image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        pixel;\n\n      register ssize_t\n        i;\n\n      pixel=GetPixelIntensity(image,q);\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        if (image->channel_mask != DefaultChannels)\n          pixel=(double) q[i];\n        if (pixel > GetPixelInfoChannel(&threshold,channel))\n          q[i]=QuantumRange;\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,ThresholdImageTag,progress,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n"], "filenames": ["MagickCore/threshold.c"], "buggy_code_start_loc": [220], "buggy_code_end_loc": [220], "fixing_code_start_loc": [221], "fixing_code_end_loc": [223], "type": "CWE-125", "message": "ImageMagick 7.0.8-50 Q16 has a heap-based buffer over-read at MagickCore/threshold.c in AdaptiveThresholdImage because a width of zero is mishandled.", "other": {"cve": {"id": "CVE-2019-13295", "sourceIdentifier": "cve@mitre.org", "published": "2019-07-05T01:15:09.907", "lastModified": "2020-08-19T18:59:09.983", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ImageMagick 7.0.8-50 Q16 has a heap-based buffer over-read at MagickCore/threshold.c in AdaptiveThresholdImage because a width of zero is mishandled."}, {"lang": "es", "value": "ImageMagick versi\u00f3n 7.0.8-50 Q16, presenta una lectura excesiva del b\u00fafer en la regi\u00f3n heap de la memoria en el archivo MagickCore/threshold.c en la funci\u00f3n AdaptiveThresholdImage porque un ancho de cero se maneja inapropiadamente."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.8-50:q16:*:*:*:*:*:*", "matchCriteriaId": "25CCEA99-8329-46C6-9625-4FE15F24CF69"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "F1E78106-58E6-4D59-990F-75DA575BFAD9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-08/msg00069.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/a7759f410b773a1dd57b0e1fb28112e1cd8b97bc", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/1608", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick6/commit/55e6dc49f1a381d9d511ee2f888fdc3e3c3e3953", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/08/msg00021.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/08/msg00030.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4192-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4712", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/a7759f410b773a1dd57b0e1fb28112e1cd8b97bc"}}