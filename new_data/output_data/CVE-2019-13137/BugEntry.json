{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                               PPPP   SSSSS                                  %\n%                               P   P  SS                                     %\n%                               PPPP    SSS                                   %\n%                               P         SS                                  %\n%                               P      SSSSS                                  %\n%                                                                             %\n%                                                                             %\n%                         Read/Write Postscript Format                        %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/delegate.h\"\n#include \"MagickCore/delegate-private.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/nt-base-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/timer-private.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/utility.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WritePSImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I n v o k e P o s t s r i p t D e l e g a t e                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  InvokePostscriptDelegate() executes the Postscript interpreter with the\n%  specified command.\n%\n%  The format of the InvokePostscriptDelegate method is:\n%\n%      MagickBooleanType InvokePostscriptDelegate(\n%        const MagickBooleanType verbose,const char *command,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o verbose: A value other than zero displays the command prior to\n%      executing it.\n%\n%    o command: the address of a character string containing the command to\n%      execute.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n#if defined(MAGICKCORE_GS_DELEGATE) || defined(MAGICKCORE_WINDOWS_SUPPORT)\nstatic int MagickDLLCall PostscriptDelegateMessage(void *handle,\n  const char *message,int length)\n{\n  char\n    **messages;\n\n  ssize_t\n    offset;\n\n  offset=0;\n  messages=(char **) handle;\n  if (*messages == (char *) NULL)\n    *messages=(char *) AcquireQuantumMemory((size_t) length+1,sizeof(char *));\n  else\n    {\n      offset=(ssize_t) strlen(*messages);\n      *messages=(char *) ResizeQuantumMemory(*messages,(size_t) offset+length+1,\n        sizeof(char *));\n    }\n  if (*messages == (char *) NULL)\n    return(0);\n  (void) memcpy(*messages+offset,message,(size_t) length);\n  (*messages)[length+offset] ='\\0';\n  return(length);\n}\n#endif\n\nstatic MagickBooleanType InvokePostscriptDelegate(\n  const MagickBooleanType verbose,const char *command,char *message,\n  ExceptionInfo *exception)\n{\n  int\n    status;\n\n#if defined(MAGICKCORE_GS_DELEGATE) || defined(MAGICKCORE_WINDOWS_SUPPORT)\n#define SetArgsStart(command,args_start) \\\n  if (args_start == (const char *) NULL) \\\n    { \\\n      if (*command != '\"') \\\n        args_start=strchr(command,' '); \\\n      else \\\n        { \\\n          args_start=strchr(command+1,'\"'); \\\n          if (args_start != (const char *) NULL) \\\n            args_start++; \\\n        } \\\n    }\n\n#define ExecuteGhostscriptCommand(command,status) \\\n{ \\\n  status=ExternalDelegateCommand(MagickFalse,verbose,command,message, \\\n    exception); \\\n  if (status == 0) \\\n    return(MagickTrue); \\\n  if (status < 0) \\\n    return(MagickFalse); \\\n  (void) ThrowMagickException(exception,GetMagickModule(),DelegateError, \\\n    \"FailedToExecuteCommand\",\"`%s' (%d)\",command,status); \\\n  return(MagickFalse); \\\n}\n\n  char\n    **argv,\n    *errors;\n\n  const char\n    *args_start = (const char *) NULL;\n\n  const GhostInfo\n    *ghost_info;\n\n  gs_main_instance\n    *interpreter;\n\n  gsapi_revision_t\n    revision;\n\n  int\n    argc,\n    code;\n\n  register ssize_t\n    i;\n\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n  ghost_info=NTGhostscriptDLLVectors();\n#else\n  GhostInfo\n    ghost_info_struct;\n\n  ghost_info=(&ghost_info_struct);\n  (void) memset(&ghost_info_struct,0,sizeof(ghost_info_struct));\n  ghost_info_struct.delete_instance=(void (*)(gs_main_instance *))\n    gsapi_delete_instance;\n  ghost_info_struct.exit=(int (*)(gs_main_instance *)) gsapi_exit;\n  ghost_info_struct.new_instance=(int (*)(gs_main_instance **,void *))\n    gsapi_new_instance;\n  ghost_info_struct.init_with_args=(int (*)(gs_main_instance *,int,char **))\n    gsapi_init_with_args;\n  ghost_info_struct.run_string=(int (*)(gs_main_instance *,const char *,int,\n    int *)) gsapi_run_string;\n  ghost_info_struct.set_stdio=(int (*)(gs_main_instance *,int (*)(void *,char *,\n    int),int (*)(void *,const char *,int),int (*)(void *, const char *, int)))\n    gsapi_set_stdio;\n  ghost_info_struct.revision=(int (*)(gsapi_revision_t *,int)) gsapi_revision;\n#endif\n  if (ghost_info == (GhostInfo *) NULL)\n    ExecuteGhostscriptCommand(command,status);\n  if ((ghost_info->revision)(&revision,(int) sizeof(revision)) != 0)\n    revision.revision=0;\n  if (verbose != MagickFalse)\n    {\n      (void) fprintf(stdout,\"[ghostscript library %.2f]\",(double)\n        revision.revision/100.0);\n      SetArgsStart(command,args_start);\n      (void) fputs(args_start,stdout);\n    }\n  interpreter=(gs_main_instance *) NULL;\n  errors=(char *) NULL;\n  status=(ghost_info->new_instance)(&interpreter,(void *) &errors);\n  if (status < 0)\n    ExecuteGhostscriptCommand(command,status);\n  code=0;\n  argv=StringToArgv(command,&argc);\n  if (argv == (char **) NULL)\n    {\n      (ghost_info->delete_instance)(interpreter);\n      return(MagickFalse);\n    }\n  (void) (ghost_info->set_stdio)(interpreter,(int (MagickDLLCall *)(void *,\n    char *,int)) NULL,PostscriptDelegateMessage,PostscriptDelegateMessage);\n  status=(ghost_info->init_with_args)(interpreter,argc-1,argv+1);\n  if (status == 0)\n    status=(ghost_info->run_string)(interpreter,\"systemdict /start get exec\\n\",\n      0,&code);\n  (ghost_info->exit)(interpreter);\n  (ghost_info->delete_instance)(interpreter);\n  for (i=0; i < (ssize_t) argc; i++)\n    argv[i]=DestroyString(argv[i]);\n  argv=(char **) RelinquishMagickMemory(argv);\n  if (status != 0)\n    {\n      SetArgsStart(command,args_start);\n      if (status == -101) /* quit */\n        (void) FormatLocaleString(message,MagickPathExtent,\n          \"[ghostscript library %.2f]%s: %s\",(double) revision.revision/100.0,\n          args_start,errors);\n      else\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            DelegateError,\"PostscriptDelegateFailed\",\n            \"`[ghostscript library %.2f]%s': %s\",(double) revision.revision/\n            100.0,args_start,errors);\n          if (errors != (char *) NULL)\n            errors=DestroyString(errors);\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Ghostscript returns status %d, exit code %d\",status,code);\n          return(MagickFalse);\n        }\n    }\n  if (errors != (char *) NULL)\n    errors=DestroyString(errors);\n  return(MagickTrue);\n#else\n  status=ExternalDelegateCommand(MagickFalse,verbose,command,message,exception);\n  return(status == 0 ? MagickTrue : MagickFalse);\n#endif\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s P S                                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsPS() returns MagickTrue if the image format type, identified by the\n%  magick string, is PS.\n%\n%  The format of the IsPS method is:\n%\n%      MagickBooleanType IsPS(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsPS(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (memcmp(magick,\"%!\",2) == 0)\n    return(MagickTrue);\n  if (memcmp(magick,\"\\004%!\",3) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d P S I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadPSImage() reads a Postscript image file and returns it.  It allocates\n%  the memory necessary for the new Image structure and returns a pointer\n%  to the new image.\n%\n%  The format of the ReadPSImage method is:\n%\n%      Image *ReadPSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic MagickBooleanType IsPostscriptRendered(const char *path)\n{\n  MagickBooleanType\n    status;\n\n  struct stat\n    attributes;\n\n  if ((path == (const char *) NULL) || (*path == '\\0'))\n    return(MagickFalse);\n  status=GetPathAttributes(path,&attributes);\n  if ((status != MagickFalse) && S_ISREG(attributes.st_mode) &&\n      (attributes.st_size > 0))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic inline int ProfileInteger(Image *image,short int *hex_digits)\n{\n  int\n    c,\n    l,\n    value;\n\n  register ssize_t\n    i;\n\n  l=0;\n  value=0;\n  for (i=0; i < 2; )\n  {\n    c=ReadBlobByte(image);\n    if ((c == EOF) || ((c == '%') && (l == '%')))\n      {\n        value=(-1);\n        break;\n      }\n    l=c;\n    c&=0xff;\n    if (isxdigit(c) == MagickFalse)\n      continue;\n    value=(int) ((size_t) value << 4)+hex_digits[c];\n    i++;\n  }\n  return(value);\n}\n\nstatic Image *ReadPSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define BoundingBox  \"BoundingBox:\"\n#define BeginDocument  \"BeginDocument:\"\n#define BeginXMPPacket  \"<?xpacket begin=\"\n#define EndXMPPacket  \"<?xpacket end=\"\n#define ICCProfile \"BeginICCProfile:\"\n#define CMYKCustomColor  \"CMYKCustomColor:\"\n#define CMYKProcessColor  \"CMYKProcessColor:\"\n#define DocumentMedia  \"DocumentMedia:\"\n#define DocumentCustomColors  \"DocumentCustomColors:\"\n#define DocumentProcessColors  \"DocumentProcessColors:\"\n#define EndDocument  \"EndDocument:\"\n#define HiResBoundingBox  \"HiResBoundingBox:\"\n#define ImageData  \"ImageData:\"\n#define PageBoundingBox  \"PageBoundingBox:\"\n#define LanguageLevel  \"LanguageLevel:\"\n#define PageMedia  \"PageMedia:\"\n#define Pages  \"Pages:\"\n#define PhotoshopProfile  \"BeginPhotoshop:\"\n#define PostscriptLevel  \"!PS-\"\n#define RenderPostscriptText  \"  Rendering Postscript...  \"\n#define SpotColor  \"+ \"\n\n  char\n    command[MagickPathExtent],\n    *density,\n    filename[MagickPathExtent],\n    geometry[MagickPathExtent],\n    input_filename[MagickPathExtent],\n    message[MagickPathExtent],\n    *options,\n    postscript_filename[MagickPathExtent];\n\n  const char\n    *option;\n\n  const DelegateInfo\n    *delegate_info;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *image,\n    *next,\n    *postscript_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    file;\n\n  MagickBooleanType\n    cmyk,\n    fitPage,\n    skip,\n    status;\n\n  MagickStatusType\n    flags;\n\n  PointInfo\n    delta,\n    resolution;\n\n  RectangleInfo\n    page;\n\n  register char\n    *p;\n\n  register ssize_t\n    i;\n\n  SegmentInfo\n    bounds,\n    hires_bounds;\n\n  short int\n    hex_digits[256];\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    priority;\n\n  StringInfo\n    *profile;\n\n  unsigned long\n    columns,\n    extent,\n    language_level,\n    pages,\n    rows,\n    scene,\n    spotcolor;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);\n  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image_info->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Initialize hex values.\n  */\n  (void) memset(hex_digits,0,sizeof(hex_digits));\n  hex_digits[(int) '0']=0;\n  hex_digits[(int) '1']=1;\n  hex_digits[(int) '2']=2;\n  hex_digits[(int) '3']=3;\n  hex_digits[(int) '4']=4;\n  hex_digits[(int) '5']=5;\n  hex_digits[(int) '6']=6;\n  hex_digits[(int) '7']=7;\n  hex_digits[(int) '8']=8;\n  hex_digits[(int) '9']=9;\n  hex_digits[(int) 'a']=10;\n  hex_digits[(int) 'b']=11;\n  hex_digits[(int) 'c']=12;\n  hex_digits[(int) 'd']=13;\n  hex_digits[(int) 'e']=14;\n  hex_digits[(int) 'f']=15;\n  hex_digits[(int) 'A']=10;\n  hex_digits[(int) 'B']=11;\n  hex_digits[(int) 'C']=12;\n  hex_digits[(int) 'D']=13;\n  hex_digits[(int) 'E']=14;\n  hex_digits[(int) 'F']=15;\n  /*\n    Set the page density.\n  */\n  delta.x=DefaultResolution;\n  delta.y=DefaultResolution;\n  if ((image->resolution.x == 0.0) || (image->resolution.y == 0.0))\n    {\n      flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  if (image_info->density != (char *) NULL)\n    {\n      flags=ParseGeometry(image_info->density,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  resolution=image->resolution;\n  page.width=(size_t) ceil((double) (page.width*resolution.x/delta.x)-0.5);\n  page.height=(size_t) ceil((double) (page.height*resolution.y/delta.y)-0.5);\n  /*\n    Determine page geometry from the Postscript bounding box.\n  */\n  (void) memset(&bounds,0,sizeof(bounds));\n  (void) memset(command,0,sizeof(command));\n  cmyk=image_info->colorspace == CMYKColorspace ? MagickTrue : MagickFalse;\n  (void) memset(&hires_bounds,0,sizeof(hires_bounds));\n  columns=0;\n  rows=0;\n  priority=0;\n  rows=0;\n  extent=0;\n  spotcolor=0;\n  language_level=1;\n  pages=(~0UL);\n  skip=MagickFalse;\n  p=command;\n  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n  {\n    /*\n      Note document structuring comments.\n    */\n    *p++=(char) c;\n    if ((strchr(\"\\n\\r%\",c) == (char *) NULL) &&\n        ((size_t) (p-command) < (MagickPathExtent-1)))\n      continue;\n    *p='\\0';\n    p=command;\n    /*\n      Skip %%BeginDocument thru %%EndDocument.\n    */\n    if (LocaleNCompare(BeginDocument,command,strlen(BeginDocument)) == 0)\n      skip=MagickTrue;\n    if (LocaleNCompare(EndDocument,command,strlen(EndDocument)) == 0)\n      skip=MagickFalse;\n    if (skip != MagickFalse)\n      continue;\n    if (LocaleNCompare(PostscriptLevel,command,strlen(PostscriptLevel)) == 0)\n      {\n        (void) SetImageProperty(image,\"ps:Level\",command+4,exception);\n        if (GlobExpression(command,\"*EPSF-*\",MagickTrue) != MagickFalse)\n          pages=1;\n      }\n    if (LocaleNCompare(LanguageLevel,command,strlen(LanguageLevel)) == 0)\n      (void) sscanf(command,LanguageLevel \" %lu\",&language_level);\n    if (LocaleNCompare(Pages,command,strlen(Pages)) == 0)\n      (void) sscanf(command,Pages \" %lu\",&pages);\n    if (LocaleNCompare(ImageData,command,strlen(ImageData)) == 0)\n      (void) sscanf(command,ImageData \" %lu %lu\",&columns,&rows);\n    /*\n      Is this a CMYK document?\n    */\n    length=strlen(DocumentProcessColors);\n    if (LocaleNCompare(DocumentProcessColors,command,length) == 0)\n      {\n        if ((GlobExpression(command,\"*Cyan*\",MagickTrue) != MagickFalse) ||\n            (GlobExpression(command,\"*Magenta*\",MagickTrue) != MagickFalse) ||\n            (GlobExpression(command,\"*Yellow*\",MagickTrue) != MagickFalse))\n          cmyk=MagickTrue;\n      }\n    if (LocaleNCompare(CMYKCustomColor,command,strlen(CMYKCustomColor)) == 0)\n      cmyk=MagickTrue;\n    if (LocaleNCompare(CMYKProcessColor,command,strlen(CMYKProcessColor)) == 0)\n      cmyk=MagickTrue;\n    length=strlen(DocumentCustomColors);\n    if ((LocaleNCompare(DocumentCustomColors,command,length) == 0) ||\n        (LocaleNCompare(CMYKCustomColor,command,strlen(CMYKCustomColor)) == 0) ||\n        (LocaleNCompare(SpotColor,command,strlen(SpotColor)) == 0))\n      {\n        char\n          property[MagickPathExtent],\n          *value;\n\n        register char\n          *q;\n\n        /*\n          Note spot names.\n        */\n        (void) FormatLocaleString(property,MagickPathExtent,\n          \"ps:SpotColor-%.20g\",(double) (spotcolor++));\n        for (q=command; *q != '\\0'; q++)\n          if (isspace((int) (unsigned char) *q) != 0)\n            break;\n        value=ConstantString(q);\n        (void) SubstituteString(&value,\"(\",\"\");\n        (void) SubstituteString(&value,\")\",\"\");\n        (void) StripString(value);\n        if (*value != '\\0')\n          (void) SetImageProperty(image,property,value,exception);\n        value=DestroyString(value);\n        continue;\n      }\n    if (image_info->page != (char *) NULL)\n      continue;\n    /*\n      Note region defined by bounding box.\n    */\n    count=0;\n    i=0;\n    if (LocaleNCompare(BoundingBox,command,strlen(BoundingBox)) == 0)\n      {\n        count=(ssize_t) sscanf(command,BoundingBox \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=2;\n      }\n    if (LocaleNCompare(DocumentMedia,command,strlen(DocumentMedia)) == 0)\n      {\n        count=(ssize_t) sscanf(command,DocumentMedia \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=1;\n      }\n    if (LocaleNCompare(HiResBoundingBox,command,strlen(HiResBoundingBox)) == 0)\n      {\n        count=(ssize_t) sscanf(command,HiResBoundingBox \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=3;\n      }\n    if (LocaleNCompare(PageBoundingBox,command,strlen(PageBoundingBox)) == 0)\n      {\n        count=(ssize_t) sscanf(command,PageBoundingBox \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=1;\n      }\n    if (LocaleNCompare(PageMedia,command,strlen(PageMedia)) == 0)\n      {\n        count=(ssize_t) sscanf(command,PageMedia \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=1;\n      }\n    if ((count != 4) || (i < (ssize_t) priority))\n      continue;\n    if ((fabs(bounds.x2-bounds.x1) <= fabs(hires_bounds.x2-hires_bounds.x1)) ||\n        (fabs(bounds.y2-bounds.y1) <= fabs(hires_bounds.y2-hires_bounds.y1)))\n      if (i ==  (ssize_t) priority)\n        continue;\n    hires_bounds=bounds;\n    priority=i;\n  }\n  if ((fabs(hires_bounds.x2-hires_bounds.x1) >= MagickEpsilon) &&\n      (fabs(hires_bounds.y2-hires_bounds.y1) >= MagickEpsilon))\n    {\n      /*\n        Set Postscript render geometry.\n      */\n      (void) FormatLocaleString(geometry,MagickPathExtent,\"%gx%g%+.15g%+.15g\",\n        hires_bounds.x2-hires_bounds.x1,hires_bounds.y2-hires_bounds.y1,\n        hires_bounds.x1,hires_bounds.y1);\n      (void) SetImageProperty(image,\"ps:HiResBoundingBox\",geometry,exception);\n      page.width=(size_t) ceil((double) ((hires_bounds.x2-hires_bounds.x1)*\n        resolution.x/delta.x)-0.5);\n      page.height=(size_t) ceil((double) ((hires_bounds.y2-hires_bounds.y1)*\n        resolution.y/delta.y)-0.5);\n    }\n  fitPage=MagickFalse;\n  option=GetImageOption(image_info,\"eps:fit-page\");\n  if (option != (char *) NULL)\n    {\n      char\n        *page_geometry;\n\n      page_geometry=GetPageGeometry(option);\n      flags=ParseMetaGeometry(page_geometry,&page.x,&page.y,&page.width,\n        &page.height);\n      if (flags == NoValue)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"InvalidGeometry\",\"`%s'\",option);\n          image=DestroyImage(image);\n          return((Image *) NULL);\n        }\n      page.width=(size_t) ceil((double) (page.width*image->resolution.x/delta.x)\n        -0.5);\n      page.height=(size_t) ceil((double) (page.height*image->resolution.y/\n        delta.y) -0.5);\n      page_geometry=DestroyString(page_geometry);\n      fitPage=MagickTrue;\n    }\n  if (IssRGBCompatibleColorspace(image_info->colorspace) != MagickFalse)\n    cmyk=MagickFalse;\n  /*\n    Create Ghostscript control file.\n  */\n  file=AcquireUniqueFileResource(postscript_filename);\n  if (file == -1)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n        image_info->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) CopyMagickString(command,\"/setpagedevice {pop} bind 1 index where {\"\n    \"dup wcheck {3 1 roll put} {pop def} ifelse} {def} ifelse\\n\"\n    \"<</UseCIEColor true>>setpagedevice\\n\",MagickPathExtent);\n  count=write(file,command,(unsigned int) strlen(command));\n  if (image_info->page == (char *) NULL)\n    {\n      char\n        translate_geometry[MagickPathExtent];\n\n      (void) FormatLocaleString(translate_geometry,MagickPathExtent,\n        \"%g %g translate\\n\",-bounds.x1,-bounds.y1);\n      count=write(file,translate_geometry,(unsigned int)\n        strlen(translate_geometry));\n    }\n  file=close(file)-1;\n  /*\n    Render Postscript with the Ghostscript delegate.\n  */\n  if (image_info->monochrome != MagickFalse)\n    delegate_info=GetDelegateInfo(\"ps:mono\",(char *) NULL,exception);\n  else\n    if (cmyk != MagickFalse)\n      delegate_info=GetDelegateInfo(\"ps:cmyk\",(char *) NULL,exception);\n    else\n      delegate_info=GetDelegateInfo(\"ps:alpha\",(char *) NULL,exception);\n  if (delegate_info == (const DelegateInfo *) NULL)\n    {\n      (void) RelinquishUniqueFileResource(postscript_filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  density=AcquireString(\"\");\n  options=AcquireString(\"\");\n  (void) FormatLocaleString(density,MagickPathExtent,\"%gx%g\",resolution.x,\n    resolution.y);\n  (void) FormatLocaleString(options,MagickPathExtent,\"-g%.20gx%.20g \",(double)\n    page.width,(double) page.height);\n  read_info=CloneImageInfo(image_info);\n  *read_info->magick='\\0';\n  if (read_info->number_scenes != 0)\n    {\n      char\n        pages[MagickPathExtent];\n\n      (void) FormatLocaleString(pages,MagickPathExtent,\"-dFirstPage=%.20g \"\n        \"-dLastPage=%.20g \",(double) read_info->scene+1,(double)\n        (read_info->scene+read_info->number_scenes));\n      (void) ConcatenateMagickString(options,pages,MagickPathExtent);\n      read_info->number_scenes=0;\n      if (read_info->scenes != (char *) NULL)\n        *read_info->scenes='\\0';\n    }\n  if (*image_info->magick == 'E')\n    {\n      option=GetImageOption(image_info,\"eps:use-cropbox\");\n      if ((option == (const char *) NULL) ||\n          (IsStringTrue(option) != MagickFalse))\n        (void) ConcatenateMagickString(options,\"-dEPSCrop \",MagickPathExtent);\n      if (fitPage != MagickFalse)\n        (void) ConcatenateMagickString(options,\"-dEPSFitPage \",\n          MagickPathExtent);\n    }\n  (void) CopyMagickString(filename,read_info->filename,MagickPathExtent);\n  (void) AcquireUniqueFilename(filename);\n  (void) RelinquishUniqueFileResource(filename);\n  (void) ConcatenateMagickString(filename,\"%d\",MagickPathExtent);\n  (void) FormatLocaleString(command,MagickPathExtent,\n    GetDelegateCommands(delegate_info),\n    read_info->antialias != MagickFalse ? 4 : 1,\n    read_info->antialias != MagickFalse ? 4 : 1,density,options,filename,\n    postscript_filename,input_filename);\n  options=DestroyString(options);\n  density=DestroyString(density);\n  *message='\\0';\n  status=InvokePostscriptDelegate(read_info->verbose,command,message,exception);\n  (void) InterpretImageFilename(image_info,image,filename,1,\n    read_info->filename,exception);\n  if ((status == MagickFalse) ||\n      (IsPostscriptRendered(read_info->filename) == MagickFalse))\n    {\n      (void) ConcatenateMagickString(command,\" -c showpage\",MagickPathExtent);\n      status=InvokePostscriptDelegate(read_info->verbose,command,message,\n        exception);\n    }\n  (void) RelinquishUniqueFileResource(postscript_filename);\n  (void) RelinquishUniqueFileResource(input_filename);\n  postscript_image=(Image *) NULL;\n  if (status == MagickFalse)\n    for (i=1; ; i++)\n    {\n      (void) InterpretImageFilename(image_info,image,filename,(int) i,\n        read_info->filename,exception);\n      if (IsPostscriptRendered(read_info->filename) == MagickFalse)\n        break;\n      (void) RelinquishUniqueFileResource(read_info->filename);\n    }\n  else\n    for (i=1; ; i++)\n    {\n      (void) InterpretImageFilename(image_info,image,filename,(int) i,\n        read_info->filename,exception);\n      if (IsPostscriptRendered(read_info->filename) == MagickFalse)\n        break;\n      read_info->blob=NULL;\n      read_info->length=0;\n      next=ReadImage(read_info,exception);\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      if (next == (Image *) NULL)\n        break;\n      AppendImageToList(&postscript_image,next);\n    }\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  if (postscript_image == (Image *) NULL)\n    {\n      if (*message != '\\0')\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          DelegateError,\"PostscriptDelegateFailed\",\"`%s'\",message);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (LocaleCompare(postscript_image->magick,\"BMP\") == 0)\n    {\n      Image\n        *cmyk_image;\n\n      cmyk_image=ConsolidateCMYKImages(postscript_image,exception);\n      if (cmyk_image != (Image *) NULL)\n        {\n          postscript_image=DestroyImageList(postscript_image);\n          postscript_image=cmyk_image;\n        }\n    }\n  (void) SeekBlob(image,0,SEEK_SET);\n  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n  {\n    /*\n      Note document structuring comments.\n    */\n    *p++=(char) c;\n    if ((strchr(\"\\n\\r%\",c) == (char *) NULL) &&\n        ((size_t) (p-command) < (MagickPathExtent-1)))\n      continue;\n    *p='\\0';\n    p=command;\n    /*\n      Skip %%BeginDocument thru %%EndDocument.\n    */\n    if (LocaleNCompare(BeginDocument,command,strlen(BeginDocument)) == 0)\n      skip=MagickTrue;\n    if (LocaleNCompare(EndDocument,command,strlen(EndDocument)) == 0)\n      skip=MagickFalse;\n    if (skip != MagickFalse)\n      continue;\n    if (LocaleNCompare(ICCProfile,command,strlen(ICCProfile)) == 0)\n      {\n        unsigned char\n          *datum;\n\n        /*\n          Read ICC profile.\n        */\n        profile=AcquireStringInfo(MagickPathExtent);\n        datum=GetStringInfoDatum(profile);\n        for (i=0; (c=ProfileInteger(image,hex_digits)) != EOF; i++)\n        {\n          if (i >= (ssize_t) GetStringInfoLength(profile))\n            {\n              SetStringInfoLength(profile,(size_t) i << 1);\n              datum=GetStringInfoDatum(profile);\n            }\n          datum[i]=(unsigned char) c;\n        }\n        SetStringInfoLength(profile,(size_t) i+1);\n        (void) SetImageProfile(image,\"icc\",profile,exception);\n        profile=DestroyStringInfo(profile);\n        continue;\n      }\n    if (LocaleNCompare(PhotoshopProfile,command,strlen(PhotoshopProfile)) == 0)\n      {\n        unsigned char\n          *q;\n\n        /*\n          Read Photoshop profile.\n        */\n        count=(ssize_t) sscanf(command,PhotoshopProfile \" %lu\",&extent);\n        if (count != 1)\n          continue;\n        length=extent;\n        if ((MagickSizeType) length > GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        profile=BlobToStringInfo((const void *) NULL,length);\n        if (profile != (StringInfo *) NULL)\n          {\n            q=GetStringInfoDatum(profile);\n            for (i=0; i < (ssize_t) length; i++)\n              *q++=(unsigned char) ProfileInteger(image,hex_digits);\n            (void) SetImageProfile(image,\"8bim\",profile,exception);\n            profile=DestroyStringInfo(profile);\n          }\n        continue;\n      }\n    if (LocaleNCompare(BeginXMPPacket,command,strlen(BeginXMPPacket)) == 0)\n      {\n        /*\n          Read XMP profile.\n        */\n        p=command;\n        profile=StringToStringInfo(command);\n        for (i=(ssize_t) GetStringInfoLength(profile)-1; c != EOF; i++)\n        {\n          SetStringInfoLength(profile,(size_t) (i+1));\n          c=ReadBlobByte(image);\n          GetStringInfoDatum(profile)[i]=(unsigned char) c;\n          *p++=(char) c;\n          if ((strchr(\"\\n\\r%\",c) == (char *) NULL) &&\n              ((size_t) (p-command) < (MagickPathExtent-1)))\n            continue;\n          *p='\\0';\n          p=command;\n          if (LocaleNCompare(EndXMPPacket,command,strlen(EndXMPPacket)) == 0)\n            break;\n        }\n        SetStringInfoLength(profile,(size_t) i);\n        (void) SetImageProfile(image,\"xmp\",profile,exception);\n        profile=DestroyStringInfo(profile);\n        continue;\n      }\n  }\n  (void) CloseBlob(image);\n  if (image_info->number_scenes != 0)\n    {\n      Image\n        *clone_image;\n\n      /*\n        Add place holder images to meet the subimage specification requirement.\n      */\n      for (i=0; i < (ssize_t) image_info->scene; i++)\n      {\n        clone_image=CloneImage(postscript_image,1,1,MagickTrue,exception);\n        if (clone_image != (Image *) NULL)\n          PrependImageToList(&postscript_image,clone_image);\n      }\n    }\n  do\n  {\n    (void) CopyMagickString(postscript_image->filename,filename,\n      MagickPathExtent);\n    (void) CopyMagickString(postscript_image->magick,image->magick,\n      MagickPathExtent);\n    if (columns != 0)\n      postscript_image->magick_columns=columns;\n    if (rows != 0)\n      postscript_image->magick_rows=rows;\n    postscript_image->page=page;\n    (void) CloneImageProfiles(postscript_image,image);\n    (void) CloneImageProperties(postscript_image,image);\n    next=SyncNextImageInList(postscript_image);\n    if (next != (Image *) NULL)\n      postscript_image=next;\n  } while (next != (Image *) NULL);\n  image=DestroyImageList(image);\n  scene=0;\n  for (next=GetFirstImageInList(postscript_image); next != (Image *) NULL; )\n  {\n    next->scene=scene++;\n    next=GetNextImageInList(next);\n  }\n  return(GetFirstImageInList(postscript_image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r P S I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterPSImage() adds properties for the PS image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterPSImage method is:\n%\n%      size_t RegisterPSImage(void)\n%\n*/\nModuleExport size_t RegisterPSImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"PS\",\"EPI\",\n    \"Encapsulated PostScript Interchange format\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"EPS\",\"Encapsulated PostScript\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"EPSF\",\"Encapsulated PostScript\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"EPSI\",\n    \"Encapsulated PostScript Interchange format\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"PS\",\"PostScript\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r P S I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterPSImage() removes format registrations made by the\n%  PS module from the list of supported formats.\n%\n%  The format of the UnregisterPSImage method is:\n%\n%      UnregisterPSImage(void)\n%\n*/\nModuleExport void UnregisterPSImage(void)\n{\n  (void) UnregisterMagickInfo(\"EPI\");\n  (void) UnregisterMagickInfo(\"EPS\");\n  (void) UnregisterMagickInfo(\"EPSF\");\n  (void) UnregisterMagickInfo(\"EPSI\");\n  (void) UnregisterMagickInfo(\"PS\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P S I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePSImage translates an image to encapsulated Postscript\n%  Level I for printing.  If the supplied geometry is null, the image is\n%  centered on the Postscript page.  Otherwise, the image is positioned as\n%  specified by the geometry.\n%\n%  The format of the WritePSImage method is:\n%\n%      MagickBooleanType WritePSImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline unsigned char *PopHexPixel(const char hex_digits[][3],\n  const size_t pixel,unsigned char *pixels)\n{\n  register const char\n    *hex;\n\n  hex=hex_digits[pixel];\n  *pixels++=(unsigned char) (*hex++ & 0xff);\n  *pixels++=(unsigned char) (*hex & 0xff);\n  return(pixels);\n}\n\nstatic MagickBooleanType WritePSImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n#define WriteRunlengthPacket(image,pixel,length,p) \\\n{ \\\n  if ((image->alpha_trait != UndefinedPixelTrait) && (length != 0) && \\\n      (GetPixelAlpha(image,p) == (Quantum) TransparentAlpha)) \\\n    { \\\n      q=PopHexPixel(hex_digits,0xff,q); \\\n      q=PopHexPixel(hex_digits,0xff,q); \\\n      q=PopHexPixel(hex_digits,0xff,q); \\\n    } \\\n  else \\\n    { \\\n      q=PopHexPixel(hex_digits,ScaleQuantumToChar(ClampToQuantum(pixel.red)),q); \\\n      q=PopHexPixel(hex_digits,ScaleQuantumToChar(ClampToQuantum(pixel.green)),q); \\\n      q=PopHexPixel(hex_digits,ScaleQuantumToChar(ClampToQuantum(pixel.blue)),q); \\\n    } \\\n  q=PopHexPixel(hex_digits,(size_t) MagickMin(length,0xff),q); \\\n}\n\n  static const char\n    hex_digits[][3] =\n    {\n      \"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"0A\", \"0B\",\n      \"0C\", \"0D\", \"0E\", \"0F\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\",\n      \"18\", \"19\", \"1A\", \"1B\", \"1C\", \"1D\", \"1E\", \"1F\", \"20\", \"21\", \"22\", \"23\",\n      \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"2A\", \"2B\", \"2C\", \"2D\", \"2E\", \"2F\",\n      \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\", \"3A\", \"3B\",\n      \"3C\", \"3D\", \"3E\", \"3F\", \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\",\n      \"48\", \"49\", \"4A\", \"4B\", \"4C\", \"4D\", \"4E\", \"4F\", \"50\", \"51\", \"52\", \"53\",\n      \"54\", \"55\", \"56\", \"57\", \"58\", \"59\", \"5A\", \"5B\", \"5C\", \"5D\", \"5E\", \"5F\",\n      \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\", \"6A\", \"6B\",\n      \"6C\", \"6D\", \"6E\", \"6F\", \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\",\n      \"78\", \"79\", \"7A\", \"7B\", \"7C\", \"7D\", \"7E\", \"7F\", \"80\", \"81\", \"82\", \"83\",\n      \"84\", \"85\", \"86\", \"87\", \"88\", \"89\", \"8A\", \"8B\", \"8C\", \"8D\", \"8E\", \"8F\",\n      \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\", \"9A\", \"9B\",\n      \"9C\", \"9D\", \"9E\", \"9F\", \"A0\", \"A1\", \"A2\", \"A3\", \"A4\", \"A5\", \"A6\", \"A7\",\n      \"A8\", \"A9\", \"AA\", \"AB\", \"AC\", \"AD\", \"AE\", \"AF\", \"B0\", \"B1\", \"B2\", \"B3\",\n      \"B4\", \"B5\", \"B6\", \"B7\", \"B8\", \"B9\", \"BA\", \"BB\", \"BC\", \"BD\", \"BE\", \"BF\",\n      \"C0\", \"C1\", \"C2\", \"C3\", \"C4\", \"C5\", \"C6\", \"C7\", \"C8\", \"C9\", \"CA\", \"CB\",\n      \"CC\", \"CD\", \"CE\", \"CF\", \"D0\", \"D1\", \"D2\", \"D3\", \"D4\", \"D5\", \"D6\", \"D7\",\n      \"D8\", \"D9\", \"DA\", \"DB\", \"DC\", \"DD\", \"DE\", \"DF\", \"E0\", \"E1\", \"E2\", \"E3\",\n      \"E4\", \"E5\", \"E6\", \"E7\", \"E8\", \"E9\", \"EA\", \"EB\", \"EC\", \"ED\", \"EE\", \"EF\",\n      \"F0\", \"F1\", \"F2\", \"F3\", \"F4\", \"F5\", \"F6\", \"F7\", \"F8\", \"F9\", \"FA\", \"FB\",\n      \"FC\", \"FD\", \"FE\", \"FF\"\n    },\n    PostscriptProlog[] =\n      \"%%BeginProlog\\n\"\n      \"%\\n\"\n      \"% Display a color image.  The image is displayed in color on\\n\"\n      \"% Postscript viewers or printers that support color, otherwise\\n\"\n      \"% it is displayed as grayscale.\\n\"\n      \"%\\n\"\n      \"/DirectClassPacket\\n\"\n      \"{\\n\"\n      \"  %\\n\"\n      \"  % Get a DirectClass packet.\\n\"\n      \"  %\\n\"\n      \"  % Parameters:\\n\"\n      \"  %   red.\\n\"\n      \"  %   green.\\n\"\n      \"  %   blue.\\n\"\n      \"  %   length: number of pixels minus one of this color (optional).\\n\"\n      \"  %\\n\"\n      \"  currentfile color_packet readhexstring pop pop\\n\"\n      \"  compression 0 eq\\n\"\n      \"  {\\n\"\n      \"    /number_pixels 3 def\\n\"\n      \"  }\\n\"\n      \"  {\\n\"\n      \"    currentfile byte readhexstring pop 0 get\\n\"\n      \"    /number_pixels exch 1 add 3 mul def\\n\"\n      \"  } ifelse\\n\"\n      \"  0 3 number_pixels 1 sub\\n\"\n      \"  {\\n\"\n      \"    pixels exch color_packet putinterval\\n\"\n      \"  } for\\n\"\n      \"  pixels 0 number_pixels getinterval\\n\"\n      \"} bind def\\n\"\n      \"\\n\"\n      \"/DirectClassImage\\n\"\n      \"{\\n\"\n      \"  %\\n\"\n      \"  % Display a DirectClass image.\\n\"\n      \"  %\\n\"\n      \"  systemdict /colorimage known\\n\"\n      \"  {\\n\"\n      \"    columns rows 8\\n\"\n      \"    [\\n\"\n      \"      columns 0 0\\n\"\n      \"      rows neg 0 rows\\n\"\n      \"    ]\\n\"\n      \"    { DirectClassPacket } false 3 colorimage\\n\"\n      \"  }\\n\"\n      \"  {\\n\"\n      \"    %\\n\"\n      \"    % No colorimage operator;  convert to grayscale.\\n\"\n      \"    %\\n\"\n      \"    columns rows 8\\n\"\n      \"    [\\n\"\n      \"      columns 0 0\\n\"\n      \"      rows neg 0 rows\\n\"\n      \"    ]\\n\"\n      \"    { GrayDirectClassPacket } image\\n\"\n      \"  } ifelse\\n\"\n      \"} bind def\\n\"\n      \"\\n\"\n      \"/GrayDirectClassPacket\\n\"\n      \"{\\n\"\n      \"  %\\n\"\n      \"  % Get a DirectClass packet;  convert to grayscale.\\n\"\n      \"  %\\n\"\n      \"  % Parameters:\\n\"\n      \"  %   red\\n\"\n      \"  %   green\\n\"\n      \"  %   blue\\n\"\n      \"  %   length: number of pixels minus one of this color (optional).\\n\"\n      \"  %\\n\"\n      \"  currentfile color_packet readhexstring pop pop\\n\"\n      \"  color_packet 0 get 0.299 mul\\n\"\n      \"  color_packet 1 get 0.587 mul add\\n\"\n      \"  color_packet 2 get 0.114 mul add\\n\"\n      \"  cvi\\n\"\n      \"  /gray_packet exch def\\n\"\n      \"  compression 0 eq\\n\"\n      \"  {\\n\"\n      \"    /number_pixels 1 def\\n\"\n      \"  }\\n\"\n      \"  {\\n\"\n      \"    currentfile byte readhexstring pop 0 get\\n\"\n      \"    /number_pixels exch 1 add def\\n\"\n      \"  } ifelse\\n\"\n      \"  0 1 number_pixels 1 sub\\n\"\n      \"  {\\n\"\n      \"    pixels exch gray_packet put\\n\"\n      \"  } for\\n\"\n      \"  pixels 0 number_pixels getinterval\\n\"\n      \"} bind def\\n\"\n      \"\\n\"\n      \"/GrayPseudoClassPacket\\n\"\n      \"{\\n\"\n      \"  %\\n\"\n      \"  % Get a PseudoClass packet;  convert to grayscale.\\n\"\n      \"  %\\n\"\n      \"  % Parameters:\\n\"\n      \"  %   index: index into the colormap.\\n\"\n      \"  %   length: number of pixels minus one of this color (optional).\\n\"\n      \"  %\\n\"\n      \"  currentfile byte readhexstring pop 0 get\\n\"\n      \"  /offset exch 3 mul def\\n\"\n      \"  /color_packet colormap offset 3 getinterval def\\n\"\n      \"  color_packet 0 get 0.299 mul\\n\"\n      \"  color_packet 1 get 0.587 mul add\\n\"\n      \"  color_packet 2 get 0.114 mul add\\n\"\n      \"  cvi\\n\"\n      \"  /gray_packet exch def\\n\"\n      \"  compression 0 eq\\n\"\n      \"  {\\n\"\n      \"    /number_pixels 1 def\\n\"\n      \"  }\\n\"\n      \"  {\\n\"\n      \"    currentfile byte readhexstring pop 0 get\\n\"\n      \"    /number_pixels exch 1 add def\\n\"\n      \"  } ifelse\\n\"\n      \"  0 1 number_pixels 1 sub\\n\"\n      \"  {\\n\"\n      \"    pixels exch gray_packet put\\n\"\n      \"  } for\\n\"\n      \"  pixels 0 number_pixels getinterval\\n\"\n      \"} bind def\\n\"\n      \"\\n\"\n      \"/PseudoClassPacket\\n\"\n      \"{\\n\"\n      \"  %\\n\"\n      \"  % Get a PseudoClass packet.\\n\"\n      \"  %\\n\"\n      \"  % Parameters:\\n\"\n      \"  %   index: index into the colormap.\\n\"\n      \"  %   length: number of pixels minus one of this color (optional).\\n\"\n      \"  %\\n\"\n      \"  currentfile byte readhexstring pop 0 get\\n\"\n      \"  /offset exch 3 mul def\\n\"\n      \"  /color_packet colormap offset 3 getinterval def\\n\"\n      \"  compression 0 eq\\n\"\n      \"  {\\n\"\n      \"    /number_pixels 3 def\\n\"\n      \"  }\\n\"\n      \"  {\\n\"\n      \"    currentfile byte readhexstring pop 0 get\\n\"\n      \"    /number_pixels exch 1 add 3 mul def\\n\"\n      \"  } ifelse\\n\"\n      \"  0 3 number_pixels 1 sub\\n\"\n      \"  {\\n\"\n      \"    pixels exch color_packet putinterval\\n\"\n      \"  } for\\n\"\n      \"  pixels 0 number_pixels getinterval\\n\"\n      \"} bind def\\n\"\n      \"\\n\"\n      \"/PseudoClassImage\\n\"\n      \"{\\n\"\n      \"  %\\n\"\n      \"  % Display a PseudoClass image.\\n\"\n      \"  %\\n\"\n      \"  % Parameters:\\n\"\n      \"  %   class: 0-PseudoClass or 1-Grayscale.\\n\"\n      \"  %\\n\"\n      \"  currentfile buffer readline pop\\n\"\n      \"  token pop /class exch def pop\\n\"\n      \"  class 0 gt\\n\"\n      \"  {\\n\"\n      \"    currentfile buffer readline pop\\n\"\n      \"    token pop /depth exch def pop\\n\"\n      \"    /grays columns 8 add depth sub depth mul 8 idiv string def\\n\"\n      \"    columns rows depth\\n\"\n      \"    [\\n\"\n      \"      columns 0 0\\n\"\n      \"      rows neg 0 rows\\n\"\n      \"    ]\\n\"\n      \"    { currentfile grays readhexstring pop } image\\n\"\n      \"  }\\n\"\n      \"  {\\n\"\n      \"    %\\n\"\n      \"    % Parameters:\\n\"\n      \"    %   colors: number of colors in the colormap.\\n\"\n      \"    %   colormap: red, green, blue color packets.\\n\"\n      \"    %\\n\"\n      \"    currentfile buffer readline pop\\n\"\n      \"    token pop /colors exch def pop\\n\"\n      \"    /colors colors 3 mul def\\n\"\n      \"    /colormap colors string def\\n\"\n      \"    currentfile colormap readhexstring pop pop\\n\"\n      \"    systemdict /colorimage known\\n\"\n      \"    {\\n\"\n      \"      columns rows 8\\n\"\n      \"      [\\n\"\n      \"        columns 0 0\\n\"\n      \"        rows neg 0 rows\\n\"\n      \"      ]\\n\"\n      \"      { PseudoClassPacket } false 3 colorimage\\n\"\n      \"    }\\n\"\n      \"    {\\n\"\n      \"      %\\n\"\n      \"      % No colorimage operator;  convert to grayscale.\\n\"\n      \"      %\\n\"\n      \"      columns rows 8\\n\"\n      \"      [\\n\"\n      \"        columns 0 0\\n\"\n      \"        rows neg 0 rows\\n\"\n      \"      ]\\n\"\n      \"      { GrayPseudoClassPacket } image\\n\"\n      \"    } ifelse\\n\"\n      \"  } ifelse\\n\"\n      \"} bind def\\n\"\n      \"\\n\"\n      \"/DisplayImage\\n\"\n      \"{\\n\"\n      \"  %\\n\"\n      \"  % Display a DirectClass or PseudoClass image.\\n\"\n      \"  %\\n\"\n      \"  % Parameters:\\n\"\n      \"  %   x & y translation.\\n\"\n      \"  %   x & y scale.\\n\"\n      \"  %   label pointsize.\\n\"\n      \"  %   image label.\\n\"\n      \"  %   image columns & rows.\\n\"\n      \"  %   class: 0-DirectClass or 1-PseudoClass.\\n\"\n      \"  %   compression: 0-none or 1-RunlengthEncoded.\\n\"\n      \"  %   hex color packets.\\n\"\n      \"  %\\n\"\n      \"  gsave\\n\"\n      \"  /buffer 512 string def\\n\"\n      \"  /byte 1 string def\\n\"\n      \"  /color_packet 3 string def\\n\"\n      \"  /pixels 768 string def\\n\"\n      \"\\n\"\n      \"  currentfile buffer readline pop\\n\"\n      \"  token pop /x exch def\\n\"\n      \"  token pop /y exch def pop\\n\"\n      \"  x y translate\\n\"\n      \"  currentfile buffer readline pop\\n\"\n      \"  token pop /x exch def\\n\"\n      \"  token pop /y exch def pop\\n\"\n      \"  currentfile buffer readline pop\\n\"\n      \"  token pop /pointsize exch def pop\\n\",\n    PostscriptEpilog[] =\n      \"  x y scale\\n\"\n      \"  currentfile buffer readline pop\\n\"\n      \"  token pop /columns exch def\\n\"\n      \"  token pop /rows exch def pop\\n\"\n      \"  currentfile buffer readline pop\\n\"\n      \"  token pop /class exch def pop\\n\"\n      \"  currentfile buffer readline pop\\n\"\n      \"  token pop /compression exch def pop\\n\"\n      \"  class 0 gt { PseudoClassImage } { DirectClassImage } ifelse\\n\"\n      \"  grestore\\n\";\n\n  char\n    buffer[MagickPathExtent],\n    date[MagickPathExtent],\n    **labels,\n    page_geometry[MagickPathExtent];\n\n  CompressionType\n    compression;\n\n  const char\n    *value;\n\n  const StringInfo\n    *profile;\n\n  double\n    pointsize;\n\n  GeometryInfo\n    geometry_info;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  MagickStatusType\n    flags;\n\n  PixelInfo\n    pixel;\n\n  PointInfo\n    delta,\n    resolution,\n    scale;\n\n  Quantum\n    index;\n\n  RectangleInfo\n    geometry,\n    media_info,\n    page_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  SegmentInfo\n    bounds;\n\n  size_t\n    bit,\n    byte,\n    imageListLength,\n    length,\n    page,\n    text_size;\n\n  ssize_t\n    j,\n    y;\n\n  time_t\n    timer;\n\n  unsigned char\n    pixels[2048];\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) memset(&bounds,0,sizeof(bounds));\n  compression=image->compression;\n  if (image_info->compression != UndefinedCompression)\n    compression=image_info->compression;\n  page=1;\n  scene=0;\n  imageListLength=GetImageListLength(image);\n  do\n  {\n    /*\n      Scale relative to dots-per-inch.\n    */\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    delta.x=DefaultResolution;\n    delta.y=DefaultResolution;\n    resolution.x=image->resolution.x;\n    resolution.y=image->resolution.y;\n    if ((resolution.x == 0.0) || (resolution.y == 0.0))\n      {\n        flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n        resolution.x=geometry_info.rho;\n        resolution.y=geometry_info.sigma;\n        if ((flags & SigmaValue) == 0)\n          resolution.y=resolution.x;\n      }\n    if (image_info->density != (char *) NULL)\n      {\n        flags=ParseGeometry(image_info->density,&geometry_info);\n        resolution.x=geometry_info.rho;\n        resolution.y=geometry_info.sigma;\n        if ((flags & SigmaValue) == 0)\n          resolution.y=resolution.x;\n      }\n    if (image->units == PixelsPerCentimeterResolution)\n      {\n        resolution.x=(double) ((size_t) (100.0*2.54*resolution.x+0.5)/100.0);\n        resolution.y=(double) ((size_t) (100.0*2.54*resolution.y+0.5)/100.0);\n      }\n    SetGeometry(image,&geometry);\n    (void) FormatLocaleString(page_geometry,MagickPathExtent,\"%.20gx%.20g\",\n      (double) image->columns,(double) image->rows);\n    if (image_info->page != (char *) NULL)\n      (void) CopyMagickString(page_geometry,image_info->page,MagickPathExtent);\n    else\n      if ((image->page.width != 0) && (image->page.height != 0))\n        (void) FormatLocaleString(page_geometry,MagickPathExtent,\n          \"%.20gx%.20g%+.20g%+.20g\",(double) image->page.width,(double)\n          image->page.height,(double) image->page.x,(double) image->page.y);\n      else\n        if ((image->gravity != UndefinedGravity) &&\n            (LocaleCompare(image_info->magick,\"PS\") == 0))\n          (void) CopyMagickString(page_geometry,PSPageGeometry,\n            MagickPathExtent);\n    (void) ConcatenateMagickString(page_geometry,\">\",MagickPathExtent);\n    (void) ParseMetaGeometry(page_geometry,&geometry.x,&geometry.y,\n      &geometry.width,&geometry.height);\n    scale.x=PerceptibleReciprocal(resolution.x)*geometry.width*delta.x;\n    geometry.width=(size_t) floor(scale.x+0.5);\n    scale.y=PerceptibleReciprocal(resolution.y)*geometry.height*delta.y;\n    geometry.height=(size_t) floor(scale.y+0.5);\n    (void) ParseAbsoluteGeometry(page_geometry,&media_info);\n    (void) ParseGravityGeometry(image,page_geometry,&page_info,exception);\n    if (image->gravity != UndefinedGravity)\n      {\n        geometry.x=(-page_info.x);\n        geometry.y=(ssize_t) (media_info.height+page_info.y-image->rows);\n      }\n    pointsize=12.0;\n    if (image_info->pointsize != 0.0)\n      pointsize=image_info->pointsize;\n    text_size=0;\n    value=GetImageProperty(image,\"label\",exception);\n    if (value != (const char *) NULL)\n      text_size=(size_t) (MultilineCensus(value)*pointsize+12);\n    if (page == 1)\n      {\n        /*\n          Output Postscript header.\n        */\n        if (LocaleCompare(image_info->magick,\"PS\") == 0)\n          (void) CopyMagickString(buffer,\"%!PS-Adobe-3.0\\n\",MagickPathExtent);\n        else\n          (void) CopyMagickString(buffer,\"%!PS-Adobe-3.0 EPSF-3.0\\n\",\n            MagickPathExtent);\n        (void) WriteBlobString(image,buffer);\n        (void) WriteBlobString(image,\"%%Creator: (ImageMagick)\\n\");\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%%%%Title: (%s)\\n\",\n          image->filename);\n        (void) WriteBlobString(image,buffer);\n        timer=GetMagickTime();\n        (void) FormatMagickTime(timer,MagickPathExtent,date);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"%%%%CreationDate: (%s)\\n\",date);\n        (void) WriteBlobString(image,buffer);\n        bounds.x1=(double) geometry.x;\n        bounds.y1=(double) geometry.y;\n        bounds.x2=(double) geometry.x+scale.x;\n        bounds.y2=(double) geometry.y+(geometry.height+text_size);\n        if ((image_info->adjoin != MagickFalse) &&\n            (GetNextImageInList(image) != (Image *) NULL))\n          (void) CopyMagickString(buffer,\"%%%%BoundingBox: (atend)\\n\",\n            MagickPathExtent);\n        else\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,\n              \"%%%%BoundingBox: %.20g %.20g %.20g %.20g\\n\",ceil(bounds.x1-0.5),\n              ceil(bounds.y1-0.5),floor(bounds.x2+0.5),floor(bounds.y2+0.5));\n            (void) WriteBlobString(image,buffer);\n            (void) FormatLocaleString(buffer,MagickPathExtent,\n              \"%%%%HiResBoundingBox: %g %g %g %g\\n\",bounds.x1,\n              bounds.y1,bounds.x2,bounds.y2);\n          }\n        (void) WriteBlobString(image,buffer);\n        profile=GetImageProfile(image,\"8bim\");\n        if (profile != (StringInfo *) NULL)\n          {\n            /*\n              Embed Photoshop profile.\n            */\n            (void) FormatLocaleString(buffer,MagickPathExtent,\n              \"%%BeginPhotoshop: %.20g\",(double) GetStringInfoLength(profile));\n            (void) WriteBlobString(image,buffer);\n            for (i=0; i < (ssize_t) GetStringInfoLength(profile); i++)\n            {\n              if ((i % 32) == 0)\n                (void) WriteBlobString(image,\"\\n% \");\n              (void) FormatLocaleString(buffer,MagickPathExtent,\"%02X\",\n                (unsigned int) (GetStringInfoDatum(profile)[i] & 0xff));\n              (void) WriteBlobString(image,buffer);\n            }\n            (void) WriteBlobString(image,\"\\n%EndPhotoshop\\n\");\n          }\n        profile=GetImageProfile(image,\"xmp\");\nDisableMSCWarning(4127)\n        if (0 && (profile != (StringInfo *) NULL))\nRestoreMSCWarning\n          {\n            /*\n              Embed XML profile.\n            */\n            (void) WriteBlobString(image,\"\\n%begin_xml_code\\n\");\n            (void) FormatLocaleString(buffer,MagickPathExtent,\n               \"\\n%%begin_xml_packet: %.20g\\n\",(double)\n               GetStringInfoLength(profile));\n            (void) WriteBlobString(image,buffer);\n            for (i=0; i < (ssize_t) GetStringInfoLength(profile); i++)\n              (void) WriteBlobByte(image,GetStringInfoDatum(profile)[i]);\n            (void) WriteBlobString(image,\"\\n%end_xml_packet\\n%end_xml_code\\n\");\n          }\n        value=GetImageProperty(image,\"label\",exception);\n        if (value != (const char *) NULL)\n          (void) WriteBlobString(image,\n            \"%%DocumentNeededResources: font Times-Roman\\n\");\n        (void) WriteBlobString(image,\"%%DocumentData: Clean7Bit\\n\");\n        (void) WriteBlobString(image,\"%%LanguageLevel: 1\\n\");\n        if (LocaleCompare(image_info->magick,\"PS\") != 0)\n          (void) WriteBlobString(image,\"%%Pages: 1\\n\");\n        else\n          {\n            /*\n              Compute the number of pages.\n            */\n            (void) WriteBlobString(image,\"%%Orientation: Portrait\\n\");\n            (void) WriteBlobString(image,\"%%PageOrder: Ascend\\n\");\n            (void) FormatLocaleString(buffer,MagickPathExtent,\n              \"%%%%Pages: %.20g\\n\",image_info->adjoin != MagickFalse ?\n              (double) imageListLength : 1.0);\n            (void) WriteBlobString(image,buffer);\n          }\n        (void) WriteBlobString(image,\"%%EndComments\\n\");\n        (void) WriteBlobString(image,\"\\n%%BeginDefaults\\n\");\n        (void) WriteBlobString(image,\"%%EndDefaults\\n\\n\");\n        if ((LocaleCompare(image_info->magick,\"EPI\") == 0) ||\n            (LocaleCompare(image_info->magick,\"EPSI\") == 0) ||\n            (LocaleCompare(image_info->magick,\"EPT\") == 0))\n          {\n            Image\n              *preview_image;\n\n            Quantum\n              pixel;\n\n            register ssize_t\n              x;\n\n            ssize_t\n              y;\n\n            /*\n              Create preview image.\n            */\n            preview_image=CloneImage(image,0,0,MagickTrue,exception);\n            if (preview_image == (Image *) NULL)\n              ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n            /*\n              Dump image as bitmap.\n            */\n            (void) FormatLocaleString(buffer,MagickPathExtent,\n              \"%%%%BeginPreview: %.20g %.20g %.20g %.20g\\n%%  \",(double)\n              preview_image->columns,(double) preview_image->rows,1.0,\n              (double) ((((preview_image->columns+7) >> 3)*preview_image->rows+\n              35)/36));\n            (void) WriteBlobString(image,buffer);\n            q=pixels;\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(preview_image,0,y,preview_image->columns,1,\n                exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              bit=0;\n              byte=0;\n              for (x=0; x < (ssize_t) preview_image->columns; x++)\n              {\n                byte<<=1;\n                pixel=ClampToQuantum(GetPixelLuma(preview_image,p));\n                if (pixel >= (Quantum) (QuantumRange/2))\n                  byte|=0x01;\n                bit++;\n                if (bit == 8)\n                  {\n                    q=PopHexPixel(hex_digits,byte,q);\n                    if ((q-pixels+8) >= 80)\n                      {\n                        *q++='\\n';\n                        (void) WriteBlob(image,q-pixels,pixels);\n                        q=pixels;\n                        (void) WriteBlobString(image,\"%  \");\n                      };\n                    bit=0;\n                    byte=0;\n                  }\n              }\n              if (bit != 0)\n                {\n                  byte<<=(8-bit);\n                  q=PopHexPixel(hex_digits,byte,q);\n                  if ((q-pixels+8) >= 80)\n                    {\n                      *q++='\\n';\n                      (void) WriteBlob(image,q-pixels,pixels);\n                      q=pixels;\n                      (void) WriteBlobString(image,\"%  \");\n                    };\n                };\n            }\n            if (q != pixels)\n              {\n                *q++='\\n';\n                (void) WriteBlob(image,q-pixels,pixels);\n              }\n            (void) WriteBlobString(image,\"\\n%%EndPreview\\n\");\n            preview_image=DestroyImage(preview_image);\n          }\n        /*\n          Output Postscript commands.\n        */\n        (void) WriteBlob(image,sizeof(PostscriptProlog)-1,\n          (const unsigned char *) PostscriptProlog);\n        value=GetImageProperty(image,\"label\",exception);\n        if (value != (const char *) NULL)\n          {\n            (void) WriteBlobString(image,\n              \"  /Times-Roman findfont pointsize scalefont setfont\\n\");\n            for (j=(ssize_t) MultilineCensus(value)-1; j >= 0; j--)\n            {\n              (void) WriteBlobString(image,\"  /label 512 string def\\n\");\n              (void) WriteBlobString(image,\n                \"  currentfile label readline pop\\n\");\n              (void) FormatLocaleString(buffer,MagickPathExtent,\n                \"  0 y %g add moveto label show pop\\n\",j*pointsize+12);\n              (void) WriteBlobString(image,buffer);\n            }\n          }\n        (void) WriteBlob(image,sizeof(PostscriptEpilog)-1,\n          (const unsigned char *) PostscriptEpilog);\n        if (LocaleCompare(image_info->magick,\"PS\") == 0)\n          (void) WriteBlobString(image,\"  showpage\\n\");\n        (void) WriteBlobString(image,\"} bind def\\n\");\n        (void) WriteBlobString(image,\"%%EndProlog\\n\");\n      }\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%%%%Page:  1 %.20g\\n\",\n      (double) (page++));\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\n      \"%%%%PageBoundingBox: %.20g %.20g %.20g %.20g\\n\",(double) geometry.x,\n      (double) geometry.y,geometry.x+(double) geometry.width,geometry.y+(double)\n      (geometry.height+text_size));\n    (void) WriteBlobString(image,buffer);\n    if ((double) geometry.x < bounds.x1)\n      bounds.x1=(double) geometry.x;\n    if ((double) geometry.y < bounds.y1)\n      bounds.y1=(double) geometry.y;\n    if ((double) (geometry.x+geometry.width-1) > bounds.x2)\n      bounds.x2=(double) geometry.x+geometry.width-1;\n    if ((double) (geometry.y+(geometry.height+text_size)-1) > bounds.y2)\n      bounds.y2=(double) geometry.y+(geometry.height+text_size)-1;\n    value=GetImageProperty(image,\"label\",exception);\n    if (value != (const char *) NULL)\n      (void) WriteBlobString(image,\"%%%%PageResources: font Times-Roman\\n\");\n    if (LocaleCompare(image_info->magick,\"PS\") != 0)\n      (void) WriteBlobString(image,\"userdict begin\\n\");\n    (void) WriteBlobString(image,\"DisplayImage\\n\");\n    /*\n      Output image data.\n    */\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g %.20g\\n%g %g\\n%g\\n\",\n      (double) geometry.x,(double) geometry.y,scale.x,scale.y,pointsize);\n    (void) WriteBlobString(image,buffer);\n    labels=(char **) NULL;\n    value=GetImageProperty(image,\"label\",exception);\n    if (value != (const char *) NULL)\n      labels=StringToList(value);\n    if (labels != (char **) NULL)\n      {\n        for (i=0; labels[i] != (char *) NULL; i++)\n        {\n          (void) FormatLocaleString(buffer,MagickPathExtent,\"%s \\n\",\n            labels[i]);\n          (void) WriteBlobString(image,buffer);\n          labels[i]=DestroyString(labels[i]);\n        }\n        labels=(char **) RelinquishMagickMemory(labels);\n      }\n    (void) memset(&pixel,0,sizeof(pixel));\n    pixel.alpha=(MagickRealType) TransparentAlpha;\n    index=(Quantum) 0;\n    x=0;\n    if ((image_info->type != TrueColorType) &&\n        (SetImageGray(image,exception) != MagickFalse))\n      {\n        if (SetImageMonochrome(image,exception) == MagickFalse)\n          {\n            Quantum\n              pixel;\n\n            /*\n              Dump image as grayscale.\n            */\n            (void) FormatLocaleString(buffer,MagickPathExtent,\n              \"%.20g %.20g\\n1\\n1\\n1\\n8\\n\",(double) image->columns,(double)\n              image->rows);\n            (void) WriteBlobString(image,buffer);\n            q=pixels;\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                pixel=(Quantum) ScaleQuantumToChar(ClampToQuantum(GetPixelLuma(\n                  image,p)));\n                q=PopHexPixel(hex_digits,(size_t) pixel,q);\n                if ((q-pixels+8) >= 80)\n                  {\n                    *q++='\\n';\n                    (void) WriteBlob(image,q-pixels,pixels);\n                    q=pixels;\n                  }\n                p+=GetPixelChannels(image);\n              }\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            if (q != pixels)\n              {\n                *q++='\\n';\n                (void) WriteBlob(image,q-pixels,pixels);\n              }\n          }\n        else\n          {\n            ssize_t\n              y;\n\n            Quantum\n              pixel;\n\n            /*\n              Dump image as bitmap.\n            */\n            (void) FormatLocaleString(buffer,MagickPathExtent,\n              \"%.20g %.20g\\n1\\n1\\n1\\n1\\n\",(double) image->columns,(double)\n              image->rows);\n            (void) WriteBlobString(image,buffer);\n            q=pixels;\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              bit=0;\n              byte=0;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte<<=1;\n                pixel=ClampToQuantum(GetPixelLuma(image,p));\n                if (pixel >= (Quantum) (QuantumRange/2))\n                  byte|=0x01;\n                bit++;\n                if (bit == 8)\n                  {\n                    q=PopHexPixel(hex_digits,byte,q);\n                    if ((q-pixels+2) >= 80)\n                      {\n                        *q++='\\n';\n                        (void) WriteBlob(image,q-pixels,pixels);\n                        q=pixels;\n                      };\n                    bit=0;\n                    byte=0;\n                  }\n                p+=GetPixelChannels(image);\n              }\n              if (bit != 0)\n                {\n                  byte<<=(8-bit);\n                  q=PopHexPixel(hex_digits,byte,q);\n                  if ((q-pixels+2) >= 80)\n                    {\n                      *q++='\\n';\n                      (void) WriteBlob(image,q-pixels,pixels);\n                      q=pixels;\n                    }\n                };\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            if (q != pixels)\n              {\n                *q++='\\n';\n                (void) WriteBlob(image,q-pixels,pixels);\n              }\n          }\n      }\n    else\n      if ((image->storage_class == DirectClass) ||\n          (image->colors > 256) || (image->alpha_trait != UndefinedPixelTrait))\n        {\n          /*\n            Dump DirectClass image.\n          */\n          (void) FormatLocaleString(buffer,MagickPathExtent,\n            \"%.20g %.20g\\n0\\n%d\\n\",(double) image->columns,(double) image->rows,\n            compression == RLECompression ? 1 : 0);\n          (void) WriteBlobString(image,buffer);\n          switch (compression)\n          {\n            case RLECompression:\n            {\n              /*\n                Dump runlength-encoded DirectColor packets.\n              */\n              q=pixels;\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                GetPixelInfoPixel(image,p,&pixel);\n                length=255;\n                for (x=0; x < (ssize_t) image->columns; x++)\n                {\n                  if ((GetPixelRed(image,p) == ClampToQuantum(pixel.red)) &&\n                      (GetPixelGreen(image,p) == ClampToQuantum(pixel.green)) &&\n                      (GetPixelBlue(image,p) == ClampToQuantum(pixel.blue)) &&\n                      (GetPixelAlpha(image,p) == ClampToQuantum(pixel.alpha)) &&\n                      (length < 255) && (x < (ssize_t) (image->columns-1)))\n                    length++;\n                  else\n                    {\n                      if (x > 0)\n                        {\n                          WriteRunlengthPacket(image,pixel,length,p);\n                          if ((q-pixels+10) >= 80)\n                            {\n                              *q++='\\n';\n                              (void) WriteBlob(image,q-pixels,pixels);\n                              q=pixels;\n                            }\n                        }\n                      length=0;\n                    }\n                  GetPixelInfoPixel(image,p,&pixel);\n                  p+=GetPixelChannels(image);\n                }\n                WriteRunlengthPacket(image,pixel,length,p);\n                if ((q-pixels+10) >= 80)\n                  {\n                    *q++='\\n';\n                    (void) WriteBlob(image,q-pixels,pixels);\n                    q=pixels;\n                  }\n                if (image->previous == (Image *) NULL)\n                  {\n                    status=SetImageProgress(image,SaveImageTag,\n                      (MagickOffsetType) y,image->rows);\n                    if (status == MagickFalse)\n                      break;\n                  }\n              }\n              if (q != pixels)\n                {\n                  *q++='\\n';\n                  (void) WriteBlob(image,q-pixels,pixels);\n                }\n              break;\n            }\n            case NoCompression:\n            default:\n            {\n              /*\n                Dump uncompressed DirectColor packets.\n              */\n              q=pixels;\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                for (x=0; x < (ssize_t) image->columns; x++)\n                {\n                  if ((image->alpha_trait != UndefinedPixelTrait) &&\n                      (GetPixelAlpha(image,p) == (Quantum) TransparentAlpha))\n                    {\n                      q=PopHexPixel(hex_digits,0xff,q);\n                      q=PopHexPixel(hex_digits,0xff,q);\n                      q=PopHexPixel(hex_digits,0xff,q);\n                    }\n                  else\n                    {\n                      q=PopHexPixel(hex_digits,ScaleQuantumToChar(\n                        GetPixelRed(image,p)),q);\n                      q=PopHexPixel(hex_digits,ScaleQuantumToChar(\n                        GetPixelGreen(image,p)),q);\n                      q=PopHexPixel(hex_digits,ScaleQuantumToChar(\n                        GetPixelBlue(image,p)),q);\n                    }\n                  if ((q-pixels+6) >= 80)\n                    {\n                      *q++='\\n';\n                      (void) WriteBlob(image,q-pixels,pixels);\n                      q=pixels;\n                    }\n                  p+=GetPixelChannels(image);\n                }\n                if (image->previous == (Image *) NULL)\n                  {\n                    status=SetImageProgress(image,SaveImageTag,\n                      (MagickOffsetType) y,image->rows);\n                    if (status == MagickFalse)\n                      break;\n                  }\n              }\n              if (q != pixels)\n                {\n                  *q++='\\n';\n                  (void) WriteBlob(image,q-pixels,pixels);\n                }\n              break;\n            }\n          }\n          (void) WriteBlobByte(image,'\\n');\n        }\n      else\n        {\n          /*\n            Dump PseudoClass image.\n          */\n          (void) FormatLocaleString(buffer,MagickPathExtent,\n            \"%.20g %.20g\\n%d\\n%d\\n0\\n\",(double) image->columns,(double)\n            image->rows,image->storage_class == PseudoClass ? 1 : 0,\n            compression == RLECompression ? 1 : 0);\n          (void) WriteBlobString(image,buffer);\n          /*\n            Dump number of colors and colormap.\n          */\n          (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n            image->colors);\n          (void) WriteBlobString(image,buffer);\n          for (i=0; i < (ssize_t) image->colors; i++)\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,\"%02X%02X%02X\\n\",\n              ScaleQuantumToChar(ClampToQuantum(image->colormap[i].red)),\n              ScaleQuantumToChar(ClampToQuantum(image->colormap[i].green)),\n              ScaleQuantumToChar(ClampToQuantum(image->colormap[i].blue)));\n            (void) WriteBlobString(image,buffer);\n          }\n          switch (compression)\n          {\n            case RLECompression:\n            {\n              /*\n                Dump runlength-encoded PseudoColor packets.\n              */\n              q=pixels;\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                index=GetPixelIndex(image,p);\n                length=255;\n                for (x=0; x < (ssize_t) image->columns; x++)\n                {\n                  if ((index == GetPixelIndex(image,p)) &&\n                      (length < 255) && (x < ((ssize_t) image->columns-1)))\n                    length++;\n                  else\n                    {\n                      if (x > 0)\n                        {\n                          q=PopHexPixel(hex_digits,(size_t) index,q);\n                          q=PopHexPixel(hex_digits,(size_t)\n                            MagickMin(length,0xff),q);\n                          i++;\n                          if ((q-pixels+6) >= 80)\n                            {\n                              *q++='\\n';\n                              (void) WriteBlob(image,q-pixels,pixels);\n                              q=pixels;\n                            }\n                        }\n                      length=0;\n                    }\n                  index=GetPixelIndex(image,p);\n                  pixel.red=(MagickRealType) GetPixelRed(image,p);\n                  pixel.green=(MagickRealType) GetPixelGreen(image,p);\n                  pixel.blue=(MagickRealType) GetPixelBlue(image,p);\n                  pixel.alpha=(MagickRealType) GetPixelAlpha(image,p);\n                  p+=GetPixelChannels(image);\n                }\n                q=PopHexPixel(hex_digits,(size_t) index,q);\n                q=PopHexPixel(hex_digits,(size_t) MagickMin(length,0xff),q);\n                if ((q-pixels+6) >= 80)\n                  {\n                    *q++='\\n';\n                    (void) WriteBlob(image,q-pixels,pixels);\n                    q=pixels;\n                  }\n                if (image->previous == (Image *) NULL)\n                  {\n                    status=SetImageProgress(image,SaveImageTag,\n                      (MagickOffsetType) y,image->rows);\n                    if (status == MagickFalse)\n                      break;\n                  }\n              }\n              if (q != pixels)\n                {\n                  *q++='\\n';\n                  (void) WriteBlob(image,q-pixels,pixels);\n                }\n              break;\n            }\n            case NoCompression:\n            default:\n            {\n              /*\n                Dump uncompressed PseudoColor packets.\n              */\n              q=pixels;\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                for (x=0; x < (ssize_t) image->columns; x++)\n                {\n                  q=PopHexPixel(hex_digits,(size_t) GetPixelIndex(image,p),q);\n                  if ((q-pixels+4) >= 80)\n                    {\n                      *q++='\\n';\n                      (void) WriteBlob(image,q-pixels,pixels);\n                      q=pixels;\n                    }\n                  p+=GetPixelChannels(image);\n                }\n                if (image->previous == (Image *) NULL)\n                  {\n                    status=SetImageProgress(image,SaveImageTag,\n                      (MagickOffsetType) y,image->rows);\n                    if (status == MagickFalse)\n                      break;\n                  }\n              }\n              if (q != pixels)\n                {\n                  *q++='\\n';\n                  (void) WriteBlob(image,q-pixels,pixels);\n                }\n              break;\n            }\n          }\n          (void) WriteBlobByte(image,'\\n');\n        }\n    if (LocaleCompare(image_info->magick,\"PS\") != 0)\n      (void) WriteBlobString(image,\"end\\n\");\n    (void) WriteBlobString(image,\"%%PageTrailer\\n\");\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) WriteBlobString(image,\"%%Trailer\\n\");\n  if (page > 2)\n    {\n      (void) FormatLocaleString(buffer,MagickPathExtent,\n        \"%%%%BoundingBox: %.20g %.20g %.20g %.20g\\n\",ceil(bounds.x1-0.5),\n        ceil(bounds.y1-0.5),floor(bounds.x2-0.5),floor(bounds.y2-0.5));\n      (void) WriteBlobString(image,buffer);\n      (void) FormatLocaleString(buffer,MagickPathExtent,\n        \"%%%%HiResBoundingBox: %g %g %g %g\\n\",bounds.x1,bounds.y1,bounds.x2,\n        bounds.y2);\n      (void) WriteBlobString(image,buffer);\n    }\n  (void) WriteBlobString(image,\"%%EOF\\n\");\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                               PPPP   SSSSS                                  %\n%                               P   P  SS                                     %\n%                               PPPP    SSS                                   %\n%                               P         SS                                  %\n%                               P      SSSSS                                  %\n%                                                                             %\n%                                                                             %\n%                         Read/Write Postscript Format                        %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/delegate.h\"\n#include \"MagickCore/delegate-private.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/nt-base-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/timer-private.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/utility.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WritePSImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I n v o k e P o s t s r i p t D e l e g a t e                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  InvokePostscriptDelegate() executes the Postscript interpreter with the\n%  specified command.\n%\n%  The format of the InvokePostscriptDelegate method is:\n%\n%      MagickBooleanType InvokePostscriptDelegate(\n%        const MagickBooleanType verbose,const char *command,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o verbose: A value other than zero displays the command prior to\n%      executing it.\n%\n%    o command: the address of a character string containing the command to\n%      execute.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n#if defined(MAGICKCORE_GS_DELEGATE) || defined(MAGICKCORE_WINDOWS_SUPPORT)\nstatic int MagickDLLCall PostscriptDelegateMessage(void *handle,\n  const char *message,int length)\n{\n  char\n    **messages;\n\n  ssize_t\n    offset;\n\n  offset=0;\n  messages=(char **) handle;\n  if (*messages == (char *) NULL)\n    *messages=(char *) AcquireQuantumMemory((size_t) length+1,sizeof(char *));\n  else\n    {\n      offset=(ssize_t) strlen(*messages);\n      *messages=(char *) ResizeQuantumMemory(*messages,(size_t) offset+length+1,\n        sizeof(char *));\n    }\n  if (*messages == (char *) NULL)\n    return(0);\n  (void) memcpy(*messages+offset,message,(size_t) length);\n  (*messages)[length+offset] ='\\0';\n  return(length);\n}\n#endif\n\nstatic MagickBooleanType InvokePostscriptDelegate(\n  const MagickBooleanType verbose,const char *command,char *message,\n  ExceptionInfo *exception)\n{\n  int\n    status;\n\n#if defined(MAGICKCORE_GS_DELEGATE) || defined(MAGICKCORE_WINDOWS_SUPPORT)\n#define SetArgsStart(command,args_start) \\\n  if (args_start == (const char *) NULL) \\\n    { \\\n      if (*command != '\"') \\\n        args_start=strchr(command,' '); \\\n      else \\\n        { \\\n          args_start=strchr(command+1,'\"'); \\\n          if (args_start != (const char *) NULL) \\\n            args_start++; \\\n        } \\\n    }\n\n#define ExecuteGhostscriptCommand(command,status) \\\n{ \\\n  status=ExternalDelegateCommand(MagickFalse,verbose,command,message, \\\n    exception); \\\n  if (status == 0) \\\n    return(MagickTrue); \\\n  if (status < 0) \\\n    return(MagickFalse); \\\n  (void) ThrowMagickException(exception,GetMagickModule(),DelegateError, \\\n    \"FailedToExecuteCommand\",\"`%s' (%d)\",command,status); \\\n  return(MagickFalse); \\\n}\n\n  char\n    **argv,\n    *errors;\n\n  const char\n    *args_start = (const char *) NULL;\n\n  const GhostInfo\n    *ghost_info;\n\n  gs_main_instance\n    *interpreter;\n\n  gsapi_revision_t\n    revision;\n\n  int\n    argc,\n    code;\n\n  register ssize_t\n    i;\n\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n  ghost_info=NTGhostscriptDLLVectors();\n#else\n  GhostInfo\n    ghost_info_struct;\n\n  ghost_info=(&ghost_info_struct);\n  (void) memset(&ghost_info_struct,0,sizeof(ghost_info_struct));\n  ghost_info_struct.delete_instance=(void (*)(gs_main_instance *))\n    gsapi_delete_instance;\n  ghost_info_struct.exit=(int (*)(gs_main_instance *)) gsapi_exit;\n  ghost_info_struct.new_instance=(int (*)(gs_main_instance **,void *))\n    gsapi_new_instance;\n  ghost_info_struct.init_with_args=(int (*)(gs_main_instance *,int,char **))\n    gsapi_init_with_args;\n  ghost_info_struct.run_string=(int (*)(gs_main_instance *,const char *,int,\n    int *)) gsapi_run_string;\n  ghost_info_struct.set_stdio=(int (*)(gs_main_instance *,int (*)(void *,char *,\n    int),int (*)(void *,const char *,int),int (*)(void *, const char *, int)))\n    gsapi_set_stdio;\n  ghost_info_struct.revision=(int (*)(gsapi_revision_t *,int)) gsapi_revision;\n#endif\n  if (ghost_info == (GhostInfo *) NULL)\n    ExecuteGhostscriptCommand(command,status);\n  if ((ghost_info->revision)(&revision,(int) sizeof(revision)) != 0)\n    revision.revision=0;\n  if (verbose != MagickFalse)\n    {\n      (void) fprintf(stdout,\"[ghostscript library %.2f]\",(double)\n        revision.revision/100.0);\n      SetArgsStart(command,args_start);\n      (void) fputs(args_start,stdout);\n    }\n  interpreter=(gs_main_instance *) NULL;\n  errors=(char *) NULL;\n  status=(ghost_info->new_instance)(&interpreter,(void *) &errors);\n  if (status < 0)\n    ExecuteGhostscriptCommand(command,status);\n  code=0;\n  argv=StringToArgv(command,&argc);\n  if (argv == (char **) NULL)\n    {\n      (ghost_info->delete_instance)(interpreter);\n      return(MagickFalse);\n    }\n  (void) (ghost_info->set_stdio)(interpreter,(int (MagickDLLCall *)(void *,\n    char *,int)) NULL,PostscriptDelegateMessage,PostscriptDelegateMessage);\n  status=(ghost_info->init_with_args)(interpreter,argc-1,argv+1);\n  if (status == 0)\n    status=(ghost_info->run_string)(interpreter,\"systemdict /start get exec\\n\",\n      0,&code);\n  (ghost_info->exit)(interpreter);\n  (ghost_info->delete_instance)(interpreter);\n  for (i=0; i < (ssize_t) argc; i++)\n    argv[i]=DestroyString(argv[i]);\n  argv=(char **) RelinquishMagickMemory(argv);\n  if (status != 0)\n    {\n      SetArgsStart(command,args_start);\n      if (status == -101) /* quit */\n        (void) FormatLocaleString(message,MagickPathExtent,\n          \"[ghostscript library %.2f]%s: %s\",(double) revision.revision/100.0,\n          args_start,errors);\n      else\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            DelegateError,\"PostscriptDelegateFailed\",\n            \"`[ghostscript library %.2f]%s': %s\",(double) revision.revision/\n            100.0,args_start,errors);\n          if (errors != (char *) NULL)\n            errors=DestroyString(errors);\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Ghostscript returns status %d, exit code %d\",status,code);\n          return(MagickFalse);\n        }\n    }\n  if (errors != (char *) NULL)\n    errors=DestroyString(errors);\n  return(MagickTrue);\n#else\n  status=ExternalDelegateCommand(MagickFalse,verbose,command,message,exception);\n  return(status == 0 ? MagickTrue : MagickFalse);\n#endif\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s P S                                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsPS() returns MagickTrue if the image format type, identified by the\n%  magick string, is PS.\n%\n%  The format of the IsPS method is:\n%\n%      MagickBooleanType IsPS(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsPS(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (memcmp(magick,\"%!\",2) == 0)\n    return(MagickTrue);\n  if (memcmp(magick,\"\\004%!\",3) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d P S I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadPSImage() reads a Postscript image file and returns it.  It allocates\n%  the memory necessary for the new Image structure and returns a pointer\n%  to the new image.\n%\n%  The format of the ReadPSImage method is:\n%\n%      Image *ReadPSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic MagickBooleanType IsPostscriptRendered(const char *path)\n{\n  MagickBooleanType\n    status;\n\n  struct stat\n    attributes;\n\n  if ((path == (const char *) NULL) || (*path == '\\0'))\n    return(MagickFalse);\n  status=GetPathAttributes(path,&attributes);\n  if ((status != MagickFalse) && S_ISREG(attributes.st_mode) &&\n      (attributes.st_size > 0))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic inline int ProfileInteger(Image *image,short int *hex_digits)\n{\n  int\n    c,\n    l,\n    value;\n\n  register ssize_t\n    i;\n\n  l=0;\n  value=0;\n  for (i=0; i < 2; )\n  {\n    c=ReadBlobByte(image);\n    if ((c == EOF) || ((c == '%') && (l == '%')))\n      {\n        value=(-1);\n        break;\n      }\n    l=c;\n    c&=0xff;\n    if (isxdigit(c) == MagickFalse)\n      continue;\n    value=(int) ((size_t) value << 4)+hex_digits[c];\n    i++;\n  }\n  return(value);\n}\n\nstatic Image *ReadPSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define BoundingBox  \"BoundingBox:\"\n#define BeginDocument  \"BeginDocument:\"\n#define BeginXMPPacket  \"<?xpacket begin=\"\n#define EndXMPPacket  \"<?xpacket end=\"\n#define ICCProfile \"BeginICCProfile:\"\n#define CMYKCustomColor  \"CMYKCustomColor:\"\n#define CMYKProcessColor  \"CMYKProcessColor:\"\n#define DocumentMedia  \"DocumentMedia:\"\n#define DocumentCustomColors  \"DocumentCustomColors:\"\n#define DocumentProcessColors  \"DocumentProcessColors:\"\n#define EndDocument  \"EndDocument:\"\n#define HiResBoundingBox  \"HiResBoundingBox:\"\n#define ImageData  \"ImageData:\"\n#define PageBoundingBox  \"PageBoundingBox:\"\n#define LanguageLevel  \"LanguageLevel:\"\n#define PageMedia  \"PageMedia:\"\n#define Pages  \"Pages:\"\n#define PhotoshopProfile  \"BeginPhotoshop:\"\n#define PostscriptLevel  \"!PS-\"\n#define RenderPostscriptText  \"  Rendering Postscript...  \"\n#define SpotColor  \"+ \"\n\n  char\n    command[MagickPathExtent],\n    *density,\n    filename[MagickPathExtent],\n    geometry[MagickPathExtent],\n    input_filename[MagickPathExtent],\n    message[MagickPathExtent],\n    *options,\n    postscript_filename[MagickPathExtent];\n\n  const char\n    *option;\n\n  const DelegateInfo\n    *delegate_info;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *image,\n    *next,\n    *postscript_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    file;\n\n  MagickBooleanType\n    cmyk,\n    fitPage,\n    skip,\n    status;\n\n  MagickStatusType\n    flags;\n\n  PointInfo\n    delta,\n    resolution;\n\n  RectangleInfo\n    page;\n\n  register char\n    *p;\n\n  register ssize_t\n    i;\n\n  SegmentInfo\n    bounds,\n    hires_bounds;\n\n  short int\n    hex_digits[256];\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    priority;\n\n  StringInfo\n    *profile;\n\n  unsigned long\n    columns,\n    extent,\n    language_level,\n    pages,\n    rows,\n    scene,\n    spotcolor;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);\n  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image_info->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Initialize hex values.\n  */\n  (void) memset(hex_digits,0,sizeof(hex_digits));\n  hex_digits[(int) '0']=0;\n  hex_digits[(int) '1']=1;\n  hex_digits[(int) '2']=2;\n  hex_digits[(int) '3']=3;\n  hex_digits[(int) '4']=4;\n  hex_digits[(int) '5']=5;\n  hex_digits[(int) '6']=6;\n  hex_digits[(int) '7']=7;\n  hex_digits[(int) '8']=8;\n  hex_digits[(int) '9']=9;\n  hex_digits[(int) 'a']=10;\n  hex_digits[(int) 'b']=11;\n  hex_digits[(int) 'c']=12;\n  hex_digits[(int) 'd']=13;\n  hex_digits[(int) 'e']=14;\n  hex_digits[(int) 'f']=15;\n  hex_digits[(int) 'A']=10;\n  hex_digits[(int) 'B']=11;\n  hex_digits[(int) 'C']=12;\n  hex_digits[(int) 'D']=13;\n  hex_digits[(int) 'E']=14;\n  hex_digits[(int) 'F']=15;\n  /*\n    Set the page density.\n  */\n  delta.x=DefaultResolution;\n  delta.y=DefaultResolution;\n  if ((image->resolution.x == 0.0) || (image->resolution.y == 0.0))\n    {\n      flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  if (image_info->density != (char *) NULL)\n    {\n      flags=ParseGeometry(image_info->density,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  resolution=image->resolution;\n  page.width=(size_t) ceil((double) (page.width*resolution.x/delta.x)-0.5);\n  page.height=(size_t) ceil((double) (page.height*resolution.y/delta.y)-0.5);\n  /*\n    Determine page geometry from the Postscript bounding box.\n  */\n  (void) memset(&bounds,0,sizeof(bounds));\n  (void) memset(command,0,sizeof(command));\n  cmyk=image_info->colorspace == CMYKColorspace ? MagickTrue : MagickFalse;\n  (void) memset(&hires_bounds,0,sizeof(hires_bounds));\n  columns=0;\n  rows=0;\n  priority=0;\n  rows=0;\n  extent=0;\n  spotcolor=0;\n  language_level=1;\n  pages=(~0UL);\n  skip=MagickFalse;\n  p=command;\n  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n  {\n    /*\n      Note document structuring comments.\n    */\n    *p++=(char) c;\n    if ((strchr(\"\\n\\r%\",c) == (char *) NULL) &&\n        ((size_t) (p-command) < (MagickPathExtent-1)))\n      continue;\n    *p='\\0';\n    p=command;\n    /*\n      Skip %%BeginDocument thru %%EndDocument.\n    */\n    if (LocaleNCompare(BeginDocument,command,strlen(BeginDocument)) == 0)\n      skip=MagickTrue;\n    if (LocaleNCompare(EndDocument,command,strlen(EndDocument)) == 0)\n      skip=MagickFalse;\n    if (skip != MagickFalse)\n      continue;\n    if (LocaleNCompare(PostscriptLevel,command,strlen(PostscriptLevel)) == 0)\n      {\n        (void) SetImageProperty(image,\"ps:Level\",command+4,exception);\n        if (GlobExpression(command,\"*EPSF-*\",MagickTrue) != MagickFalse)\n          pages=1;\n      }\n    if (LocaleNCompare(LanguageLevel,command,strlen(LanguageLevel)) == 0)\n      (void) sscanf(command,LanguageLevel \" %lu\",&language_level);\n    if (LocaleNCompare(Pages,command,strlen(Pages)) == 0)\n      (void) sscanf(command,Pages \" %lu\",&pages);\n    if (LocaleNCompare(ImageData,command,strlen(ImageData)) == 0)\n      (void) sscanf(command,ImageData \" %lu %lu\",&columns,&rows);\n    /*\n      Is this a CMYK document?\n    */\n    length=strlen(DocumentProcessColors);\n    if (LocaleNCompare(DocumentProcessColors,command,length) == 0)\n      {\n        if ((GlobExpression(command,\"*Cyan*\",MagickTrue) != MagickFalse) ||\n            (GlobExpression(command,\"*Magenta*\",MagickTrue) != MagickFalse) ||\n            (GlobExpression(command,\"*Yellow*\",MagickTrue) != MagickFalse))\n          cmyk=MagickTrue;\n      }\n    if (LocaleNCompare(CMYKCustomColor,command,strlen(CMYKCustomColor)) == 0)\n      cmyk=MagickTrue;\n    if (LocaleNCompare(CMYKProcessColor,command,strlen(CMYKProcessColor)) == 0)\n      cmyk=MagickTrue;\n    length=strlen(DocumentCustomColors);\n    if ((LocaleNCompare(DocumentCustomColors,command,length) == 0) ||\n        (LocaleNCompare(CMYKCustomColor,command,strlen(CMYKCustomColor)) == 0) ||\n        (LocaleNCompare(SpotColor,command,strlen(SpotColor)) == 0))\n      {\n        char\n          property[MagickPathExtent],\n          *value;\n\n        register char\n          *q;\n\n        /*\n          Note spot names.\n        */\n        (void) FormatLocaleString(property,MagickPathExtent,\n          \"ps:SpotColor-%.20g\",(double) (spotcolor++));\n        for (q=command; *q != '\\0'; q++)\n          if (isspace((int) (unsigned char) *q) != 0)\n            break;\n        value=ConstantString(q);\n        (void) SubstituteString(&value,\"(\",\"\");\n        (void) SubstituteString(&value,\")\",\"\");\n        (void) StripString(value);\n        if (*value != '\\0')\n          (void) SetImageProperty(image,property,value,exception);\n        value=DestroyString(value);\n        continue;\n      }\n    if (image_info->page != (char *) NULL)\n      continue;\n    /*\n      Note region defined by bounding box.\n    */\n    count=0;\n    i=0;\n    if (LocaleNCompare(BoundingBox,command,strlen(BoundingBox)) == 0)\n      {\n        count=(ssize_t) sscanf(command,BoundingBox \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=2;\n      }\n    if (LocaleNCompare(DocumentMedia,command,strlen(DocumentMedia)) == 0)\n      {\n        count=(ssize_t) sscanf(command,DocumentMedia \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=1;\n      }\n    if (LocaleNCompare(HiResBoundingBox,command,strlen(HiResBoundingBox)) == 0)\n      {\n        count=(ssize_t) sscanf(command,HiResBoundingBox \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=3;\n      }\n    if (LocaleNCompare(PageBoundingBox,command,strlen(PageBoundingBox)) == 0)\n      {\n        count=(ssize_t) sscanf(command,PageBoundingBox \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=1;\n      }\n    if (LocaleNCompare(PageMedia,command,strlen(PageMedia)) == 0)\n      {\n        count=(ssize_t) sscanf(command,PageMedia \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=1;\n      }\n    if ((count != 4) || (i < (ssize_t) priority))\n      continue;\n    if ((fabs(bounds.x2-bounds.x1) <= fabs(hires_bounds.x2-hires_bounds.x1)) ||\n        (fabs(bounds.y2-bounds.y1) <= fabs(hires_bounds.y2-hires_bounds.y1)))\n      if (i ==  (ssize_t) priority)\n        continue;\n    hires_bounds=bounds;\n    priority=i;\n  }\n  if ((fabs(hires_bounds.x2-hires_bounds.x1) >= MagickEpsilon) &&\n      (fabs(hires_bounds.y2-hires_bounds.y1) >= MagickEpsilon))\n    {\n      /*\n        Set Postscript render geometry.\n      */\n      (void) FormatLocaleString(geometry,MagickPathExtent,\"%gx%g%+.15g%+.15g\",\n        hires_bounds.x2-hires_bounds.x1,hires_bounds.y2-hires_bounds.y1,\n        hires_bounds.x1,hires_bounds.y1);\n      (void) SetImageProperty(image,\"ps:HiResBoundingBox\",geometry,exception);\n      page.width=(size_t) ceil((double) ((hires_bounds.x2-hires_bounds.x1)*\n        resolution.x/delta.x)-0.5);\n      page.height=(size_t) ceil((double) ((hires_bounds.y2-hires_bounds.y1)*\n        resolution.y/delta.y)-0.5);\n    }\n  fitPage=MagickFalse;\n  option=GetImageOption(image_info,\"eps:fit-page\");\n  if (option != (char *) NULL)\n    {\n      char\n        *page_geometry;\n\n      page_geometry=GetPageGeometry(option);\n      flags=ParseMetaGeometry(page_geometry,&page.x,&page.y,&page.width,\n        &page.height);\n      if (flags == NoValue)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"InvalidGeometry\",\"`%s'\",option);\n          page_geometry=DestroyString(page_geometry);\n          image=DestroyImage(image);\n          return((Image *) NULL);\n        }\n      page.width=(size_t) ceil((double) (page.width*image->resolution.x/delta.x)\n        -0.5);\n      page.height=(size_t) ceil((double) (page.height*image->resolution.y/\n        delta.y) -0.5);\n      page_geometry=DestroyString(page_geometry);\n      fitPage=MagickTrue;\n    }\n  if (IssRGBCompatibleColorspace(image_info->colorspace) != MagickFalse)\n    cmyk=MagickFalse;\n  /*\n    Create Ghostscript control file.\n  */\n  file=AcquireUniqueFileResource(postscript_filename);\n  if (file == -1)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n        image_info->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) CopyMagickString(command,\"/setpagedevice {pop} bind 1 index where {\"\n    \"dup wcheck {3 1 roll put} {pop def} ifelse} {def} ifelse\\n\"\n    \"<</UseCIEColor true>>setpagedevice\\n\",MagickPathExtent);\n  count=write(file,command,(unsigned int) strlen(command));\n  if (image_info->page == (char *) NULL)\n    {\n      char\n        translate_geometry[MagickPathExtent];\n\n      (void) FormatLocaleString(translate_geometry,MagickPathExtent,\n        \"%g %g translate\\n\",-bounds.x1,-bounds.y1);\n      count=write(file,translate_geometry,(unsigned int)\n        strlen(translate_geometry));\n    }\n  file=close(file)-1;\n  /*\n    Render Postscript with the Ghostscript delegate.\n  */\n  if (image_info->monochrome != MagickFalse)\n    delegate_info=GetDelegateInfo(\"ps:mono\",(char *) NULL,exception);\n  else\n    if (cmyk != MagickFalse)\n      delegate_info=GetDelegateInfo(\"ps:cmyk\",(char *) NULL,exception);\n    else\n      delegate_info=GetDelegateInfo(\"ps:alpha\",(char *) NULL,exception);\n  if (delegate_info == (const DelegateInfo *) NULL)\n    {\n      (void) RelinquishUniqueFileResource(postscript_filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  density=AcquireString(\"\");\n  options=AcquireString(\"\");\n  (void) FormatLocaleString(density,MagickPathExtent,\"%gx%g\",resolution.x,\n    resolution.y);\n  (void) FormatLocaleString(options,MagickPathExtent,\"-g%.20gx%.20g \",(double)\n    page.width,(double) page.height);\n  read_info=CloneImageInfo(image_info);\n  *read_info->magick='\\0';\n  if (read_info->number_scenes != 0)\n    {\n      char\n        pages[MagickPathExtent];\n\n      (void) FormatLocaleString(pages,MagickPathExtent,\"-dFirstPage=%.20g \"\n        \"-dLastPage=%.20g \",(double) read_info->scene+1,(double)\n        (read_info->scene+read_info->number_scenes));\n      (void) ConcatenateMagickString(options,pages,MagickPathExtent);\n      read_info->number_scenes=0;\n      if (read_info->scenes != (char *) NULL)\n        *read_info->scenes='\\0';\n    }\n  if (*image_info->magick == 'E')\n    {\n      option=GetImageOption(image_info,\"eps:use-cropbox\");\n      if ((option == (const char *) NULL) ||\n          (IsStringTrue(option) != MagickFalse))\n        (void) ConcatenateMagickString(options,\"-dEPSCrop \",MagickPathExtent);\n      if (fitPage != MagickFalse)\n        (void) ConcatenateMagickString(options,\"-dEPSFitPage \",\n          MagickPathExtent);\n    }\n  (void) CopyMagickString(filename,read_info->filename,MagickPathExtent);\n  (void) AcquireUniqueFilename(filename);\n  (void) RelinquishUniqueFileResource(filename);\n  (void) ConcatenateMagickString(filename,\"%d\",MagickPathExtent);\n  (void) FormatLocaleString(command,MagickPathExtent,\n    GetDelegateCommands(delegate_info),\n    read_info->antialias != MagickFalse ? 4 : 1,\n    read_info->antialias != MagickFalse ? 4 : 1,density,options,filename,\n    postscript_filename,input_filename);\n  options=DestroyString(options);\n  density=DestroyString(density);\n  *message='\\0';\n  status=InvokePostscriptDelegate(read_info->verbose,command,message,exception);\n  (void) InterpretImageFilename(image_info,image,filename,1,\n    read_info->filename,exception);\n  if ((status == MagickFalse) ||\n      (IsPostscriptRendered(read_info->filename) == MagickFalse))\n    {\n      (void) ConcatenateMagickString(command,\" -c showpage\",MagickPathExtent);\n      status=InvokePostscriptDelegate(read_info->verbose,command,message,\n        exception);\n    }\n  (void) RelinquishUniqueFileResource(postscript_filename);\n  (void) RelinquishUniqueFileResource(input_filename);\n  postscript_image=(Image *) NULL;\n  if (status == MagickFalse)\n    for (i=1; ; i++)\n    {\n      (void) InterpretImageFilename(image_info,image,filename,(int) i,\n        read_info->filename,exception);\n      if (IsPostscriptRendered(read_info->filename) == MagickFalse)\n        break;\n      (void) RelinquishUniqueFileResource(read_info->filename);\n    }\n  else\n    for (i=1; ; i++)\n    {\n      (void) InterpretImageFilename(image_info,image,filename,(int) i,\n        read_info->filename,exception);\n      if (IsPostscriptRendered(read_info->filename) == MagickFalse)\n        break;\n      read_info->blob=NULL;\n      read_info->length=0;\n      next=ReadImage(read_info,exception);\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      if (next == (Image *) NULL)\n        break;\n      AppendImageToList(&postscript_image,next);\n    }\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  if (postscript_image == (Image *) NULL)\n    {\n      if (*message != '\\0')\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          DelegateError,\"PostscriptDelegateFailed\",\"`%s'\",message);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (LocaleCompare(postscript_image->magick,\"BMP\") == 0)\n    {\n      Image\n        *cmyk_image;\n\n      cmyk_image=ConsolidateCMYKImages(postscript_image,exception);\n      if (cmyk_image != (Image *) NULL)\n        {\n          postscript_image=DestroyImageList(postscript_image);\n          postscript_image=cmyk_image;\n        }\n    }\n  (void) SeekBlob(image,0,SEEK_SET);\n  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n  {\n    /*\n      Note document structuring comments.\n    */\n    *p++=(char) c;\n    if ((strchr(\"\\n\\r%\",c) == (char *) NULL) &&\n        ((size_t) (p-command) < (MagickPathExtent-1)))\n      continue;\n    *p='\\0';\n    p=command;\n    /*\n      Skip %%BeginDocument thru %%EndDocument.\n    */\n    if (LocaleNCompare(BeginDocument,command,strlen(BeginDocument)) == 0)\n      skip=MagickTrue;\n    if (LocaleNCompare(EndDocument,command,strlen(EndDocument)) == 0)\n      skip=MagickFalse;\n    if (skip != MagickFalse)\n      continue;\n    if (LocaleNCompare(ICCProfile,command,strlen(ICCProfile)) == 0)\n      {\n        unsigned char\n          *datum;\n\n        /*\n          Read ICC profile.\n        */\n        profile=AcquireStringInfo(MagickPathExtent);\n        datum=GetStringInfoDatum(profile);\n        for (i=0; (c=ProfileInteger(image,hex_digits)) != EOF; i++)\n        {\n          if (i >= (ssize_t) GetStringInfoLength(profile))\n            {\n              SetStringInfoLength(profile,(size_t) i << 1);\n              datum=GetStringInfoDatum(profile);\n            }\n          datum[i]=(unsigned char) c;\n        }\n        SetStringInfoLength(profile,(size_t) i+1);\n        (void) SetImageProfile(image,\"icc\",profile,exception);\n        profile=DestroyStringInfo(profile);\n        continue;\n      }\n    if (LocaleNCompare(PhotoshopProfile,command,strlen(PhotoshopProfile)) == 0)\n      {\n        unsigned char\n          *q;\n\n        /*\n          Read Photoshop profile.\n        */\n        count=(ssize_t) sscanf(command,PhotoshopProfile \" %lu\",&extent);\n        if (count != 1)\n          continue;\n        length=extent;\n        if ((MagickSizeType) length > GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        profile=BlobToStringInfo((const void *) NULL,length);\n        if (profile != (StringInfo *) NULL)\n          {\n            q=GetStringInfoDatum(profile);\n            for (i=0; i < (ssize_t) length; i++)\n              *q++=(unsigned char) ProfileInteger(image,hex_digits);\n            (void) SetImageProfile(image,\"8bim\",profile,exception);\n            profile=DestroyStringInfo(profile);\n          }\n        continue;\n      }\n    if (LocaleNCompare(BeginXMPPacket,command,strlen(BeginXMPPacket)) == 0)\n      {\n        /*\n          Read XMP profile.\n        */\n        p=command;\n        profile=StringToStringInfo(command);\n        for (i=(ssize_t) GetStringInfoLength(profile)-1; c != EOF; i++)\n        {\n          SetStringInfoLength(profile,(size_t) (i+1));\n          c=ReadBlobByte(image);\n          GetStringInfoDatum(profile)[i]=(unsigned char) c;\n          *p++=(char) c;\n          if ((strchr(\"\\n\\r%\",c) == (char *) NULL) &&\n              ((size_t) (p-command) < (MagickPathExtent-1)))\n            continue;\n          *p='\\0';\n          p=command;\n          if (LocaleNCompare(EndXMPPacket,command,strlen(EndXMPPacket)) == 0)\n            break;\n        }\n        SetStringInfoLength(profile,(size_t) i);\n        (void) SetImageProfile(image,\"xmp\",profile,exception);\n        profile=DestroyStringInfo(profile);\n        continue;\n      }\n  }\n  (void) CloseBlob(image);\n  if (image_info->number_scenes != 0)\n    {\n      Image\n        *clone_image;\n\n      /*\n        Add place holder images to meet the subimage specification requirement.\n      */\n      for (i=0; i < (ssize_t) image_info->scene; i++)\n      {\n        clone_image=CloneImage(postscript_image,1,1,MagickTrue,exception);\n        if (clone_image != (Image *) NULL)\n          PrependImageToList(&postscript_image,clone_image);\n      }\n    }\n  do\n  {\n    (void) CopyMagickString(postscript_image->filename,filename,\n      MagickPathExtent);\n    (void) CopyMagickString(postscript_image->magick,image->magick,\n      MagickPathExtent);\n    if (columns != 0)\n      postscript_image->magick_columns=columns;\n    if (rows != 0)\n      postscript_image->magick_rows=rows;\n    postscript_image->page=page;\n    (void) CloneImageProfiles(postscript_image,image);\n    (void) CloneImageProperties(postscript_image,image);\n    next=SyncNextImageInList(postscript_image);\n    if (next != (Image *) NULL)\n      postscript_image=next;\n  } while (next != (Image *) NULL);\n  image=DestroyImageList(image);\n  scene=0;\n  for (next=GetFirstImageInList(postscript_image); next != (Image *) NULL; )\n  {\n    next->scene=scene++;\n    next=GetNextImageInList(next);\n  }\n  return(GetFirstImageInList(postscript_image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r P S I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterPSImage() adds properties for the PS image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterPSImage method is:\n%\n%      size_t RegisterPSImage(void)\n%\n*/\nModuleExport size_t RegisterPSImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"PS\",\"EPI\",\n    \"Encapsulated PostScript Interchange format\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"EPS\",\"Encapsulated PostScript\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"EPSF\",\"Encapsulated PostScript\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"EPSI\",\n    \"Encapsulated PostScript Interchange format\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"PS\",\"PostScript\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r P S I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterPSImage() removes format registrations made by the\n%  PS module from the list of supported formats.\n%\n%  The format of the UnregisterPSImage method is:\n%\n%      UnregisterPSImage(void)\n%\n*/\nModuleExport void UnregisterPSImage(void)\n{\n  (void) UnregisterMagickInfo(\"EPI\");\n  (void) UnregisterMagickInfo(\"EPS\");\n  (void) UnregisterMagickInfo(\"EPSF\");\n  (void) UnregisterMagickInfo(\"EPSI\");\n  (void) UnregisterMagickInfo(\"PS\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P S I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePSImage translates an image to encapsulated Postscript\n%  Level I for printing.  If the supplied geometry is null, the image is\n%  centered on the Postscript page.  Otherwise, the image is positioned as\n%  specified by the geometry.\n%\n%  The format of the WritePSImage method is:\n%\n%      MagickBooleanType WritePSImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline unsigned char *PopHexPixel(const char hex_digits[][3],\n  const size_t pixel,unsigned char *pixels)\n{\n  register const char\n    *hex;\n\n  hex=hex_digits[pixel];\n  *pixels++=(unsigned char) (*hex++ & 0xff);\n  *pixels++=(unsigned char) (*hex & 0xff);\n  return(pixels);\n}\n\nstatic MagickBooleanType WritePSImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n#define WriteRunlengthPacket(image,pixel,length,p) \\\n{ \\\n  if ((image->alpha_trait != UndefinedPixelTrait) && (length != 0) && \\\n      (GetPixelAlpha(image,p) == (Quantum) TransparentAlpha)) \\\n    { \\\n      q=PopHexPixel(hex_digits,0xff,q); \\\n      q=PopHexPixel(hex_digits,0xff,q); \\\n      q=PopHexPixel(hex_digits,0xff,q); \\\n    } \\\n  else \\\n    { \\\n      q=PopHexPixel(hex_digits,ScaleQuantumToChar(ClampToQuantum(pixel.red)),q); \\\n      q=PopHexPixel(hex_digits,ScaleQuantumToChar(ClampToQuantum(pixel.green)),q); \\\n      q=PopHexPixel(hex_digits,ScaleQuantumToChar(ClampToQuantum(pixel.blue)),q); \\\n    } \\\n  q=PopHexPixel(hex_digits,(size_t) MagickMin(length,0xff),q); \\\n}\n\n  static const char\n    hex_digits[][3] =\n    {\n      \"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"0A\", \"0B\",\n      \"0C\", \"0D\", \"0E\", \"0F\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\",\n      \"18\", \"19\", \"1A\", \"1B\", \"1C\", \"1D\", \"1E\", \"1F\", \"20\", \"21\", \"22\", \"23\",\n      \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"2A\", \"2B\", \"2C\", \"2D\", \"2E\", \"2F\",\n      \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\", \"3A\", \"3B\",\n      \"3C\", \"3D\", \"3E\", \"3F\", \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\",\n      \"48\", \"49\", \"4A\", \"4B\", \"4C\", \"4D\", \"4E\", \"4F\", \"50\", \"51\", \"52\", \"53\",\n      \"54\", \"55\", \"56\", \"57\", \"58\", \"59\", \"5A\", \"5B\", \"5C\", \"5D\", \"5E\", \"5F\",\n      \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\", \"6A\", \"6B\",\n      \"6C\", \"6D\", \"6E\", \"6F\", \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\",\n      \"78\", \"79\", \"7A\", \"7B\", \"7C\", \"7D\", \"7E\", \"7F\", \"80\", \"81\", \"82\", \"83\",\n      \"84\", \"85\", \"86\", \"87\", \"88\", \"89\", \"8A\", \"8B\", \"8C\", \"8D\", \"8E\", \"8F\",\n      \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\", \"9A\", \"9B\",\n      \"9C\", \"9D\", \"9E\", \"9F\", \"A0\", \"A1\", \"A2\", \"A3\", \"A4\", \"A5\", \"A6\", \"A7\",\n      \"A8\", \"A9\", \"AA\", \"AB\", \"AC\", \"AD\", \"AE\", \"AF\", \"B0\", \"B1\", \"B2\", \"B3\",\n      \"B4\", \"B5\", \"B6\", \"B7\", \"B8\", \"B9\", \"BA\", \"BB\", \"BC\", \"BD\", \"BE\", \"BF\",\n      \"C0\", \"C1\", \"C2\", \"C3\", \"C4\", \"C5\", \"C6\", \"C7\", \"C8\", \"C9\", \"CA\", \"CB\",\n      \"CC\", \"CD\", \"CE\", \"CF\", \"D0\", \"D1\", \"D2\", \"D3\", \"D4\", \"D5\", \"D6\", \"D7\",\n      \"D8\", \"D9\", \"DA\", \"DB\", \"DC\", \"DD\", \"DE\", \"DF\", \"E0\", \"E1\", \"E2\", \"E3\",\n      \"E4\", \"E5\", \"E6\", \"E7\", \"E8\", \"E9\", \"EA\", \"EB\", \"EC\", \"ED\", \"EE\", \"EF\",\n      \"F0\", \"F1\", \"F2\", \"F3\", \"F4\", \"F5\", \"F6\", \"F7\", \"F8\", \"F9\", \"FA\", \"FB\",\n      \"FC\", \"FD\", \"FE\", \"FF\"\n    },\n    PostscriptProlog[] =\n      \"%%BeginProlog\\n\"\n      \"%\\n\"\n      \"% Display a color image.  The image is displayed in color on\\n\"\n      \"% Postscript viewers or printers that support color, otherwise\\n\"\n      \"% it is displayed as grayscale.\\n\"\n      \"%\\n\"\n      \"/DirectClassPacket\\n\"\n      \"{\\n\"\n      \"  %\\n\"\n      \"  % Get a DirectClass packet.\\n\"\n      \"  %\\n\"\n      \"  % Parameters:\\n\"\n      \"  %   red.\\n\"\n      \"  %   green.\\n\"\n      \"  %   blue.\\n\"\n      \"  %   length: number of pixels minus one of this color (optional).\\n\"\n      \"  %\\n\"\n      \"  currentfile color_packet readhexstring pop pop\\n\"\n      \"  compression 0 eq\\n\"\n      \"  {\\n\"\n      \"    /number_pixels 3 def\\n\"\n      \"  }\\n\"\n      \"  {\\n\"\n      \"    currentfile byte readhexstring pop 0 get\\n\"\n      \"    /number_pixels exch 1 add 3 mul def\\n\"\n      \"  } ifelse\\n\"\n      \"  0 3 number_pixels 1 sub\\n\"\n      \"  {\\n\"\n      \"    pixels exch color_packet putinterval\\n\"\n      \"  } for\\n\"\n      \"  pixels 0 number_pixels getinterval\\n\"\n      \"} bind def\\n\"\n      \"\\n\"\n      \"/DirectClassImage\\n\"\n      \"{\\n\"\n      \"  %\\n\"\n      \"  % Display a DirectClass image.\\n\"\n      \"  %\\n\"\n      \"  systemdict /colorimage known\\n\"\n      \"  {\\n\"\n      \"    columns rows 8\\n\"\n      \"    [\\n\"\n      \"      columns 0 0\\n\"\n      \"      rows neg 0 rows\\n\"\n      \"    ]\\n\"\n      \"    { DirectClassPacket } false 3 colorimage\\n\"\n      \"  }\\n\"\n      \"  {\\n\"\n      \"    %\\n\"\n      \"    % No colorimage operator;  convert to grayscale.\\n\"\n      \"    %\\n\"\n      \"    columns rows 8\\n\"\n      \"    [\\n\"\n      \"      columns 0 0\\n\"\n      \"      rows neg 0 rows\\n\"\n      \"    ]\\n\"\n      \"    { GrayDirectClassPacket } image\\n\"\n      \"  } ifelse\\n\"\n      \"} bind def\\n\"\n      \"\\n\"\n      \"/GrayDirectClassPacket\\n\"\n      \"{\\n\"\n      \"  %\\n\"\n      \"  % Get a DirectClass packet;  convert to grayscale.\\n\"\n      \"  %\\n\"\n      \"  % Parameters:\\n\"\n      \"  %   red\\n\"\n      \"  %   green\\n\"\n      \"  %   blue\\n\"\n      \"  %   length: number of pixels minus one of this color (optional).\\n\"\n      \"  %\\n\"\n      \"  currentfile color_packet readhexstring pop pop\\n\"\n      \"  color_packet 0 get 0.299 mul\\n\"\n      \"  color_packet 1 get 0.587 mul add\\n\"\n      \"  color_packet 2 get 0.114 mul add\\n\"\n      \"  cvi\\n\"\n      \"  /gray_packet exch def\\n\"\n      \"  compression 0 eq\\n\"\n      \"  {\\n\"\n      \"    /number_pixels 1 def\\n\"\n      \"  }\\n\"\n      \"  {\\n\"\n      \"    currentfile byte readhexstring pop 0 get\\n\"\n      \"    /number_pixels exch 1 add def\\n\"\n      \"  } ifelse\\n\"\n      \"  0 1 number_pixels 1 sub\\n\"\n      \"  {\\n\"\n      \"    pixels exch gray_packet put\\n\"\n      \"  } for\\n\"\n      \"  pixels 0 number_pixels getinterval\\n\"\n      \"} bind def\\n\"\n      \"\\n\"\n      \"/GrayPseudoClassPacket\\n\"\n      \"{\\n\"\n      \"  %\\n\"\n      \"  % Get a PseudoClass packet;  convert to grayscale.\\n\"\n      \"  %\\n\"\n      \"  % Parameters:\\n\"\n      \"  %   index: index into the colormap.\\n\"\n      \"  %   length: number of pixels minus one of this color (optional).\\n\"\n      \"  %\\n\"\n      \"  currentfile byte readhexstring pop 0 get\\n\"\n      \"  /offset exch 3 mul def\\n\"\n      \"  /color_packet colormap offset 3 getinterval def\\n\"\n      \"  color_packet 0 get 0.299 mul\\n\"\n      \"  color_packet 1 get 0.587 mul add\\n\"\n      \"  color_packet 2 get 0.114 mul add\\n\"\n      \"  cvi\\n\"\n      \"  /gray_packet exch def\\n\"\n      \"  compression 0 eq\\n\"\n      \"  {\\n\"\n      \"    /number_pixels 1 def\\n\"\n      \"  }\\n\"\n      \"  {\\n\"\n      \"    currentfile byte readhexstring pop 0 get\\n\"\n      \"    /number_pixels exch 1 add def\\n\"\n      \"  } ifelse\\n\"\n      \"  0 1 number_pixels 1 sub\\n\"\n      \"  {\\n\"\n      \"    pixels exch gray_packet put\\n\"\n      \"  } for\\n\"\n      \"  pixels 0 number_pixels getinterval\\n\"\n      \"} bind def\\n\"\n      \"\\n\"\n      \"/PseudoClassPacket\\n\"\n      \"{\\n\"\n      \"  %\\n\"\n      \"  % Get a PseudoClass packet.\\n\"\n      \"  %\\n\"\n      \"  % Parameters:\\n\"\n      \"  %   index: index into the colormap.\\n\"\n      \"  %   length: number of pixels minus one of this color (optional).\\n\"\n      \"  %\\n\"\n      \"  currentfile byte readhexstring pop 0 get\\n\"\n      \"  /offset exch 3 mul def\\n\"\n      \"  /color_packet colormap offset 3 getinterval def\\n\"\n      \"  compression 0 eq\\n\"\n      \"  {\\n\"\n      \"    /number_pixels 3 def\\n\"\n      \"  }\\n\"\n      \"  {\\n\"\n      \"    currentfile byte readhexstring pop 0 get\\n\"\n      \"    /number_pixels exch 1 add 3 mul def\\n\"\n      \"  } ifelse\\n\"\n      \"  0 3 number_pixels 1 sub\\n\"\n      \"  {\\n\"\n      \"    pixels exch color_packet putinterval\\n\"\n      \"  } for\\n\"\n      \"  pixels 0 number_pixels getinterval\\n\"\n      \"} bind def\\n\"\n      \"\\n\"\n      \"/PseudoClassImage\\n\"\n      \"{\\n\"\n      \"  %\\n\"\n      \"  % Display a PseudoClass image.\\n\"\n      \"  %\\n\"\n      \"  % Parameters:\\n\"\n      \"  %   class: 0-PseudoClass or 1-Grayscale.\\n\"\n      \"  %\\n\"\n      \"  currentfile buffer readline pop\\n\"\n      \"  token pop /class exch def pop\\n\"\n      \"  class 0 gt\\n\"\n      \"  {\\n\"\n      \"    currentfile buffer readline pop\\n\"\n      \"    token pop /depth exch def pop\\n\"\n      \"    /grays columns 8 add depth sub depth mul 8 idiv string def\\n\"\n      \"    columns rows depth\\n\"\n      \"    [\\n\"\n      \"      columns 0 0\\n\"\n      \"      rows neg 0 rows\\n\"\n      \"    ]\\n\"\n      \"    { currentfile grays readhexstring pop } image\\n\"\n      \"  }\\n\"\n      \"  {\\n\"\n      \"    %\\n\"\n      \"    % Parameters:\\n\"\n      \"    %   colors: number of colors in the colormap.\\n\"\n      \"    %   colormap: red, green, blue color packets.\\n\"\n      \"    %\\n\"\n      \"    currentfile buffer readline pop\\n\"\n      \"    token pop /colors exch def pop\\n\"\n      \"    /colors colors 3 mul def\\n\"\n      \"    /colormap colors string def\\n\"\n      \"    currentfile colormap readhexstring pop pop\\n\"\n      \"    systemdict /colorimage known\\n\"\n      \"    {\\n\"\n      \"      columns rows 8\\n\"\n      \"      [\\n\"\n      \"        columns 0 0\\n\"\n      \"        rows neg 0 rows\\n\"\n      \"      ]\\n\"\n      \"      { PseudoClassPacket } false 3 colorimage\\n\"\n      \"    }\\n\"\n      \"    {\\n\"\n      \"      %\\n\"\n      \"      % No colorimage operator;  convert to grayscale.\\n\"\n      \"      %\\n\"\n      \"      columns rows 8\\n\"\n      \"      [\\n\"\n      \"        columns 0 0\\n\"\n      \"        rows neg 0 rows\\n\"\n      \"      ]\\n\"\n      \"      { GrayPseudoClassPacket } image\\n\"\n      \"    } ifelse\\n\"\n      \"  } ifelse\\n\"\n      \"} bind def\\n\"\n      \"\\n\"\n      \"/DisplayImage\\n\"\n      \"{\\n\"\n      \"  %\\n\"\n      \"  % Display a DirectClass or PseudoClass image.\\n\"\n      \"  %\\n\"\n      \"  % Parameters:\\n\"\n      \"  %   x & y translation.\\n\"\n      \"  %   x & y scale.\\n\"\n      \"  %   label pointsize.\\n\"\n      \"  %   image label.\\n\"\n      \"  %   image columns & rows.\\n\"\n      \"  %   class: 0-DirectClass or 1-PseudoClass.\\n\"\n      \"  %   compression: 0-none or 1-RunlengthEncoded.\\n\"\n      \"  %   hex color packets.\\n\"\n      \"  %\\n\"\n      \"  gsave\\n\"\n      \"  /buffer 512 string def\\n\"\n      \"  /byte 1 string def\\n\"\n      \"  /color_packet 3 string def\\n\"\n      \"  /pixels 768 string def\\n\"\n      \"\\n\"\n      \"  currentfile buffer readline pop\\n\"\n      \"  token pop /x exch def\\n\"\n      \"  token pop /y exch def pop\\n\"\n      \"  x y translate\\n\"\n      \"  currentfile buffer readline pop\\n\"\n      \"  token pop /x exch def\\n\"\n      \"  token pop /y exch def pop\\n\"\n      \"  currentfile buffer readline pop\\n\"\n      \"  token pop /pointsize exch def pop\\n\",\n    PostscriptEpilog[] =\n      \"  x y scale\\n\"\n      \"  currentfile buffer readline pop\\n\"\n      \"  token pop /columns exch def\\n\"\n      \"  token pop /rows exch def pop\\n\"\n      \"  currentfile buffer readline pop\\n\"\n      \"  token pop /class exch def pop\\n\"\n      \"  currentfile buffer readline pop\\n\"\n      \"  token pop /compression exch def pop\\n\"\n      \"  class 0 gt { PseudoClassImage } { DirectClassImage } ifelse\\n\"\n      \"  grestore\\n\";\n\n  char\n    buffer[MagickPathExtent],\n    date[MagickPathExtent],\n    **labels,\n    page_geometry[MagickPathExtent];\n\n  CompressionType\n    compression;\n\n  const char\n    *value;\n\n  const StringInfo\n    *profile;\n\n  double\n    pointsize;\n\n  GeometryInfo\n    geometry_info;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  MagickStatusType\n    flags;\n\n  PixelInfo\n    pixel;\n\n  PointInfo\n    delta,\n    resolution,\n    scale;\n\n  Quantum\n    index;\n\n  RectangleInfo\n    geometry,\n    media_info,\n    page_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  SegmentInfo\n    bounds;\n\n  size_t\n    bit,\n    byte,\n    imageListLength,\n    length,\n    page,\n    text_size;\n\n  ssize_t\n    j,\n    y;\n\n  time_t\n    timer;\n\n  unsigned char\n    pixels[2048];\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) memset(&bounds,0,sizeof(bounds));\n  compression=image->compression;\n  if (image_info->compression != UndefinedCompression)\n    compression=image_info->compression;\n  page=1;\n  scene=0;\n  imageListLength=GetImageListLength(image);\n  do\n  {\n    /*\n      Scale relative to dots-per-inch.\n    */\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    delta.x=DefaultResolution;\n    delta.y=DefaultResolution;\n    resolution.x=image->resolution.x;\n    resolution.y=image->resolution.y;\n    if ((resolution.x == 0.0) || (resolution.y == 0.0))\n      {\n        flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n        resolution.x=geometry_info.rho;\n        resolution.y=geometry_info.sigma;\n        if ((flags & SigmaValue) == 0)\n          resolution.y=resolution.x;\n      }\n    if (image_info->density != (char *) NULL)\n      {\n        flags=ParseGeometry(image_info->density,&geometry_info);\n        resolution.x=geometry_info.rho;\n        resolution.y=geometry_info.sigma;\n        if ((flags & SigmaValue) == 0)\n          resolution.y=resolution.x;\n      }\n    if (image->units == PixelsPerCentimeterResolution)\n      {\n        resolution.x=(double) ((size_t) (100.0*2.54*resolution.x+0.5)/100.0);\n        resolution.y=(double) ((size_t) (100.0*2.54*resolution.y+0.5)/100.0);\n      }\n    SetGeometry(image,&geometry);\n    (void) FormatLocaleString(page_geometry,MagickPathExtent,\"%.20gx%.20g\",\n      (double) image->columns,(double) image->rows);\n    if (image_info->page != (char *) NULL)\n      (void) CopyMagickString(page_geometry,image_info->page,MagickPathExtent);\n    else\n      if ((image->page.width != 0) && (image->page.height != 0))\n        (void) FormatLocaleString(page_geometry,MagickPathExtent,\n          \"%.20gx%.20g%+.20g%+.20g\",(double) image->page.width,(double)\n          image->page.height,(double) image->page.x,(double) image->page.y);\n      else\n        if ((image->gravity != UndefinedGravity) &&\n            (LocaleCompare(image_info->magick,\"PS\") == 0))\n          (void) CopyMagickString(page_geometry,PSPageGeometry,\n            MagickPathExtent);\n    (void) ConcatenateMagickString(page_geometry,\">\",MagickPathExtent);\n    (void) ParseMetaGeometry(page_geometry,&geometry.x,&geometry.y,\n      &geometry.width,&geometry.height);\n    scale.x=PerceptibleReciprocal(resolution.x)*geometry.width*delta.x;\n    geometry.width=(size_t) floor(scale.x+0.5);\n    scale.y=PerceptibleReciprocal(resolution.y)*geometry.height*delta.y;\n    geometry.height=(size_t) floor(scale.y+0.5);\n    (void) ParseAbsoluteGeometry(page_geometry,&media_info);\n    (void) ParseGravityGeometry(image,page_geometry,&page_info,exception);\n    if (image->gravity != UndefinedGravity)\n      {\n        geometry.x=(-page_info.x);\n        geometry.y=(ssize_t) (media_info.height+page_info.y-image->rows);\n      }\n    pointsize=12.0;\n    if (image_info->pointsize != 0.0)\n      pointsize=image_info->pointsize;\n    text_size=0;\n    value=GetImageProperty(image,\"label\",exception);\n    if (value != (const char *) NULL)\n      text_size=(size_t) (MultilineCensus(value)*pointsize+12);\n    if (page == 1)\n      {\n        /*\n          Output Postscript header.\n        */\n        if (LocaleCompare(image_info->magick,\"PS\") == 0)\n          (void) CopyMagickString(buffer,\"%!PS-Adobe-3.0\\n\",MagickPathExtent);\n        else\n          (void) CopyMagickString(buffer,\"%!PS-Adobe-3.0 EPSF-3.0\\n\",\n            MagickPathExtent);\n        (void) WriteBlobString(image,buffer);\n        (void) WriteBlobString(image,\"%%Creator: (ImageMagick)\\n\");\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%%%%Title: (%s)\\n\",\n          image->filename);\n        (void) WriteBlobString(image,buffer);\n        timer=GetMagickTime();\n        (void) FormatMagickTime(timer,MagickPathExtent,date);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"%%%%CreationDate: (%s)\\n\",date);\n        (void) WriteBlobString(image,buffer);\n        bounds.x1=(double) geometry.x;\n        bounds.y1=(double) geometry.y;\n        bounds.x2=(double) geometry.x+scale.x;\n        bounds.y2=(double) geometry.y+(geometry.height+text_size);\n        if ((image_info->adjoin != MagickFalse) &&\n            (GetNextImageInList(image) != (Image *) NULL))\n          (void) CopyMagickString(buffer,\"%%%%BoundingBox: (atend)\\n\",\n            MagickPathExtent);\n        else\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,\n              \"%%%%BoundingBox: %.20g %.20g %.20g %.20g\\n\",ceil(bounds.x1-0.5),\n              ceil(bounds.y1-0.5),floor(bounds.x2+0.5),floor(bounds.y2+0.5));\n            (void) WriteBlobString(image,buffer);\n            (void) FormatLocaleString(buffer,MagickPathExtent,\n              \"%%%%HiResBoundingBox: %g %g %g %g\\n\",bounds.x1,\n              bounds.y1,bounds.x2,bounds.y2);\n          }\n        (void) WriteBlobString(image,buffer);\n        profile=GetImageProfile(image,\"8bim\");\n        if (profile != (StringInfo *) NULL)\n          {\n            /*\n              Embed Photoshop profile.\n            */\n            (void) FormatLocaleString(buffer,MagickPathExtent,\n              \"%%BeginPhotoshop: %.20g\",(double) GetStringInfoLength(profile));\n            (void) WriteBlobString(image,buffer);\n            for (i=0; i < (ssize_t) GetStringInfoLength(profile); i++)\n            {\n              if ((i % 32) == 0)\n                (void) WriteBlobString(image,\"\\n% \");\n              (void) FormatLocaleString(buffer,MagickPathExtent,\"%02X\",\n                (unsigned int) (GetStringInfoDatum(profile)[i] & 0xff));\n              (void) WriteBlobString(image,buffer);\n            }\n            (void) WriteBlobString(image,\"\\n%EndPhotoshop\\n\");\n          }\n        profile=GetImageProfile(image,\"xmp\");\nDisableMSCWarning(4127)\n        if (0 && (profile != (StringInfo *) NULL))\nRestoreMSCWarning\n          {\n            /*\n              Embed XML profile.\n            */\n            (void) WriteBlobString(image,\"\\n%begin_xml_code\\n\");\n            (void) FormatLocaleString(buffer,MagickPathExtent,\n               \"\\n%%begin_xml_packet: %.20g\\n\",(double)\n               GetStringInfoLength(profile));\n            (void) WriteBlobString(image,buffer);\n            for (i=0; i < (ssize_t) GetStringInfoLength(profile); i++)\n              (void) WriteBlobByte(image,GetStringInfoDatum(profile)[i]);\n            (void) WriteBlobString(image,\"\\n%end_xml_packet\\n%end_xml_code\\n\");\n          }\n        value=GetImageProperty(image,\"label\",exception);\n        if (value != (const char *) NULL)\n          (void) WriteBlobString(image,\n            \"%%DocumentNeededResources: font Times-Roman\\n\");\n        (void) WriteBlobString(image,\"%%DocumentData: Clean7Bit\\n\");\n        (void) WriteBlobString(image,\"%%LanguageLevel: 1\\n\");\n        if (LocaleCompare(image_info->magick,\"PS\") != 0)\n          (void) WriteBlobString(image,\"%%Pages: 1\\n\");\n        else\n          {\n            /*\n              Compute the number of pages.\n            */\n            (void) WriteBlobString(image,\"%%Orientation: Portrait\\n\");\n            (void) WriteBlobString(image,\"%%PageOrder: Ascend\\n\");\n            (void) FormatLocaleString(buffer,MagickPathExtent,\n              \"%%%%Pages: %.20g\\n\",image_info->adjoin != MagickFalse ?\n              (double) imageListLength : 1.0);\n            (void) WriteBlobString(image,buffer);\n          }\n        (void) WriteBlobString(image,\"%%EndComments\\n\");\n        (void) WriteBlobString(image,\"\\n%%BeginDefaults\\n\");\n        (void) WriteBlobString(image,\"%%EndDefaults\\n\\n\");\n        if ((LocaleCompare(image_info->magick,\"EPI\") == 0) ||\n            (LocaleCompare(image_info->magick,\"EPSI\") == 0) ||\n            (LocaleCompare(image_info->magick,\"EPT\") == 0))\n          {\n            Image\n              *preview_image;\n\n            Quantum\n              pixel;\n\n            register ssize_t\n              x;\n\n            ssize_t\n              y;\n\n            /*\n              Create preview image.\n            */\n            preview_image=CloneImage(image,0,0,MagickTrue,exception);\n            if (preview_image == (Image *) NULL)\n              ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n            /*\n              Dump image as bitmap.\n            */\n            (void) FormatLocaleString(buffer,MagickPathExtent,\n              \"%%%%BeginPreview: %.20g %.20g %.20g %.20g\\n%%  \",(double)\n              preview_image->columns,(double) preview_image->rows,1.0,\n              (double) ((((preview_image->columns+7) >> 3)*preview_image->rows+\n              35)/36));\n            (void) WriteBlobString(image,buffer);\n            q=pixels;\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(preview_image,0,y,preview_image->columns,1,\n                exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              bit=0;\n              byte=0;\n              for (x=0; x < (ssize_t) preview_image->columns; x++)\n              {\n                byte<<=1;\n                pixel=ClampToQuantum(GetPixelLuma(preview_image,p));\n                if (pixel >= (Quantum) (QuantumRange/2))\n                  byte|=0x01;\n                bit++;\n                if (bit == 8)\n                  {\n                    q=PopHexPixel(hex_digits,byte,q);\n                    if ((q-pixels+8) >= 80)\n                      {\n                        *q++='\\n';\n                        (void) WriteBlob(image,q-pixels,pixels);\n                        q=pixels;\n                        (void) WriteBlobString(image,\"%  \");\n                      };\n                    bit=0;\n                    byte=0;\n                  }\n              }\n              if (bit != 0)\n                {\n                  byte<<=(8-bit);\n                  q=PopHexPixel(hex_digits,byte,q);\n                  if ((q-pixels+8) >= 80)\n                    {\n                      *q++='\\n';\n                      (void) WriteBlob(image,q-pixels,pixels);\n                      q=pixels;\n                      (void) WriteBlobString(image,\"%  \");\n                    };\n                };\n            }\n            if (q != pixels)\n              {\n                *q++='\\n';\n                (void) WriteBlob(image,q-pixels,pixels);\n              }\n            (void) WriteBlobString(image,\"\\n%%EndPreview\\n\");\n            preview_image=DestroyImage(preview_image);\n          }\n        /*\n          Output Postscript commands.\n        */\n        (void) WriteBlob(image,sizeof(PostscriptProlog)-1,\n          (const unsigned char *) PostscriptProlog);\n        value=GetImageProperty(image,\"label\",exception);\n        if (value != (const char *) NULL)\n          {\n            (void) WriteBlobString(image,\n              \"  /Times-Roman findfont pointsize scalefont setfont\\n\");\n            for (j=(ssize_t) MultilineCensus(value)-1; j >= 0; j--)\n            {\n              (void) WriteBlobString(image,\"  /label 512 string def\\n\");\n              (void) WriteBlobString(image,\n                \"  currentfile label readline pop\\n\");\n              (void) FormatLocaleString(buffer,MagickPathExtent,\n                \"  0 y %g add moveto label show pop\\n\",j*pointsize+12);\n              (void) WriteBlobString(image,buffer);\n            }\n          }\n        (void) WriteBlob(image,sizeof(PostscriptEpilog)-1,\n          (const unsigned char *) PostscriptEpilog);\n        if (LocaleCompare(image_info->magick,\"PS\") == 0)\n          (void) WriteBlobString(image,\"  showpage\\n\");\n        (void) WriteBlobString(image,\"} bind def\\n\");\n        (void) WriteBlobString(image,\"%%EndProlog\\n\");\n      }\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%%%%Page:  1 %.20g\\n\",\n      (double) (page++));\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\n      \"%%%%PageBoundingBox: %.20g %.20g %.20g %.20g\\n\",(double) geometry.x,\n      (double) geometry.y,geometry.x+(double) geometry.width,geometry.y+(double)\n      (geometry.height+text_size));\n    (void) WriteBlobString(image,buffer);\n    if ((double) geometry.x < bounds.x1)\n      bounds.x1=(double) geometry.x;\n    if ((double) geometry.y < bounds.y1)\n      bounds.y1=(double) geometry.y;\n    if ((double) (geometry.x+geometry.width-1) > bounds.x2)\n      bounds.x2=(double) geometry.x+geometry.width-1;\n    if ((double) (geometry.y+(geometry.height+text_size)-1) > bounds.y2)\n      bounds.y2=(double) geometry.y+(geometry.height+text_size)-1;\n    value=GetImageProperty(image,\"label\",exception);\n    if (value != (const char *) NULL)\n      (void) WriteBlobString(image,\"%%%%PageResources: font Times-Roman\\n\");\n    if (LocaleCompare(image_info->magick,\"PS\") != 0)\n      (void) WriteBlobString(image,\"userdict begin\\n\");\n    (void) WriteBlobString(image,\"DisplayImage\\n\");\n    /*\n      Output image data.\n    */\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g %.20g\\n%g %g\\n%g\\n\",\n      (double) geometry.x,(double) geometry.y,scale.x,scale.y,pointsize);\n    (void) WriteBlobString(image,buffer);\n    labels=(char **) NULL;\n    value=GetImageProperty(image,\"label\",exception);\n    if (value != (const char *) NULL)\n      labels=StringToList(value);\n    if (labels != (char **) NULL)\n      {\n        for (i=0; labels[i] != (char *) NULL; i++)\n        {\n          (void) FormatLocaleString(buffer,MagickPathExtent,\"%s \\n\",\n            labels[i]);\n          (void) WriteBlobString(image,buffer);\n          labels[i]=DestroyString(labels[i]);\n        }\n        labels=(char **) RelinquishMagickMemory(labels);\n      }\n    (void) memset(&pixel,0,sizeof(pixel));\n    pixel.alpha=(MagickRealType) TransparentAlpha;\n    index=(Quantum) 0;\n    x=0;\n    if ((image_info->type != TrueColorType) &&\n        (SetImageGray(image,exception) != MagickFalse))\n      {\n        if (SetImageMonochrome(image,exception) == MagickFalse)\n          {\n            Quantum\n              pixel;\n\n            /*\n              Dump image as grayscale.\n            */\n            (void) FormatLocaleString(buffer,MagickPathExtent,\n              \"%.20g %.20g\\n1\\n1\\n1\\n8\\n\",(double) image->columns,(double)\n              image->rows);\n            (void) WriteBlobString(image,buffer);\n            q=pixels;\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                pixel=(Quantum) ScaleQuantumToChar(ClampToQuantum(GetPixelLuma(\n                  image,p)));\n                q=PopHexPixel(hex_digits,(size_t) pixel,q);\n                if ((q-pixels+8) >= 80)\n                  {\n                    *q++='\\n';\n                    (void) WriteBlob(image,q-pixels,pixels);\n                    q=pixels;\n                  }\n                p+=GetPixelChannels(image);\n              }\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            if (q != pixels)\n              {\n                *q++='\\n';\n                (void) WriteBlob(image,q-pixels,pixels);\n              }\n          }\n        else\n          {\n            ssize_t\n              y;\n\n            Quantum\n              pixel;\n\n            /*\n              Dump image as bitmap.\n            */\n            (void) FormatLocaleString(buffer,MagickPathExtent,\n              \"%.20g %.20g\\n1\\n1\\n1\\n1\\n\",(double) image->columns,(double)\n              image->rows);\n            (void) WriteBlobString(image,buffer);\n            q=pixels;\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              bit=0;\n              byte=0;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte<<=1;\n                pixel=ClampToQuantum(GetPixelLuma(image,p));\n                if (pixel >= (Quantum) (QuantumRange/2))\n                  byte|=0x01;\n                bit++;\n                if (bit == 8)\n                  {\n                    q=PopHexPixel(hex_digits,byte,q);\n                    if ((q-pixels+2) >= 80)\n                      {\n                        *q++='\\n';\n                        (void) WriteBlob(image,q-pixels,pixels);\n                        q=pixels;\n                      };\n                    bit=0;\n                    byte=0;\n                  }\n                p+=GetPixelChannels(image);\n              }\n              if (bit != 0)\n                {\n                  byte<<=(8-bit);\n                  q=PopHexPixel(hex_digits,byte,q);\n                  if ((q-pixels+2) >= 80)\n                    {\n                      *q++='\\n';\n                      (void) WriteBlob(image,q-pixels,pixels);\n                      q=pixels;\n                    }\n                };\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            if (q != pixels)\n              {\n                *q++='\\n';\n                (void) WriteBlob(image,q-pixels,pixels);\n              }\n          }\n      }\n    else\n      if ((image->storage_class == DirectClass) ||\n          (image->colors > 256) || (image->alpha_trait != UndefinedPixelTrait))\n        {\n          /*\n            Dump DirectClass image.\n          */\n          (void) FormatLocaleString(buffer,MagickPathExtent,\n            \"%.20g %.20g\\n0\\n%d\\n\",(double) image->columns,(double) image->rows,\n            compression == RLECompression ? 1 : 0);\n          (void) WriteBlobString(image,buffer);\n          switch (compression)\n          {\n            case RLECompression:\n            {\n              /*\n                Dump runlength-encoded DirectColor packets.\n              */\n              q=pixels;\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                GetPixelInfoPixel(image,p,&pixel);\n                length=255;\n                for (x=0; x < (ssize_t) image->columns; x++)\n                {\n                  if ((GetPixelRed(image,p) == ClampToQuantum(pixel.red)) &&\n                      (GetPixelGreen(image,p) == ClampToQuantum(pixel.green)) &&\n                      (GetPixelBlue(image,p) == ClampToQuantum(pixel.blue)) &&\n                      (GetPixelAlpha(image,p) == ClampToQuantum(pixel.alpha)) &&\n                      (length < 255) && (x < (ssize_t) (image->columns-1)))\n                    length++;\n                  else\n                    {\n                      if (x > 0)\n                        {\n                          WriteRunlengthPacket(image,pixel,length,p);\n                          if ((q-pixels+10) >= 80)\n                            {\n                              *q++='\\n';\n                              (void) WriteBlob(image,q-pixels,pixels);\n                              q=pixels;\n                            }\n                        }\n                      length=0;\n                    }\n                  GetPixelInfoPixel(image,p,&pixel);\n                  p+=GetPixelChannels(image);\n                }\n                WriteRunlengthPacket(image,pixel,length,p);\n                if ((q-pixels+10) >= 80)\n                  {\n                    *q++='\\n';\n                    (void) WriteBlob(image,q-pixels,pixels);\n                    q=pixels;\n                  }\n                if (image->previous == (Image *) NULL)\n                  {\n                    status=SetImageProgress(image,SaveImageTag,\n                      (MagickOffsetType) y,image->rows);\n                    if (status == MagickFalse)\n                      break;\n                  }\n              }\n              if (q != pixels)\n                {\n                  *q++='\\n';\n                  (void) WriteBlob(image,q-pixels,pixels);\n                }\n              break;\n            }\n            case NoCompression:\n            default:\n            {\n              /*\n                Dump uncompressed DirectColor packets.\n              */\n              q=pixels;\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                for (x=0; x < (ssize_t) image->columns; x++)\n                {\n                  if ((image->alpha_trait != UndefinedPixelTrait) &&\n                      (GetPixelAlpha(image,p) == (Quantum) TransparentAlpha))\n                    {\n                      q=PopHexPixel(hex_digits,0xff,q);\n                      q=PopHexPixel(hex_digits,0xff,q);\n                      q=PopHexPixel(hex_digits,0xff,q);\n                    }\n                  else\n                    {\n                      q=PopHexPixel(hex_digits,ScaleQuantumToChar(\n                        GetPixelRed(image,p)),q);\n                      q=PopHexPixel(hex_digits,ScaleQuantumToChar(\n                        GetPixelGreen(image,p)),q);\n                      q=PopHexPixel(hex_digits,ScaleQuantumToChar(\n                        GetPixelBlue(image,p)),q);\n                    }\n                  if ((q-pixels+6) >= 80)\n                    {\n                      *q++='\\n';\n                      (void) WriteBlob(image,q-pixels,pixels);\n                      q=pixels;\n                    }\n                  p+=GetPixelChannels(image);\n                }\n                if (image->previous == (Image *) NULL)\n                  {\n                    status=SetImageProgress(image,SaveImageTag,\n                      (MagickOffsetType) y,image->rows);\n                    if (status == MagickFalse)\n                      break;\n                  }\n              }\n              if (q != pixels)\n                {\n                  *q++='\\n';\n                  (void) WriteBlob(image,q-pixels,pixels);\n                }\n              break;\n            }\n          }\n          (void) WriteBlobByte(image,'\\n');\n        }\n      else\n        {\n          /*\n            Dump PseudoClass image.\n          */\n          (void) FormatLocaleString(buffer,MagickPathExtent,\n            \"%.20g %.20g\\n%d\\n%d\\n0\\n\",(double) image->columns,(double)\n            image->rows,image->storage_class == PseudoClass ? 1 : 0,\n            compression == RLECompression ? 1 : 0);\n          (void) WriteBlobString(image,buffer);\n          /*\n            Dump number of colors and colormap.\n          */\n          (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n            image->colors);\n          (void) WriteBlobString(image,buffer);\n          for (i=0; i < (ssize_t) image->colors; i++)\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,\"%02X%02X%02X\\n\",\n              ScaleQuantumToChar(ClampToQuantum(image->colormap[i].red)),\n              ScaleQuantumToChar(ClampToQuantum(image->colormap[i].green)),\n              ScaleQuantumToChar(ClampToQuantum(image->colormap[i].blue)));\n            (void) WriteBlobString(image,buffer);\n          }\n          switch (compression)\n          {\n            case RLECompression:\n            {\n              /*\n                Dump runlength-encoded PseudoColor packets.\n              */\n              q=pixels;\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                index=GetPixelIndex(image,p);\n                length=255;\n                for (x=0; x < (ssize_t) image->columns; x++)\n                {\n                  if ((index == GetPixelIndex(image,p)) &&\n                      (length < 255) && (x < ((ssize_t) image->columns-1)))\n                    length++;\n                  else\n                    {\n                      if (x > 0)\n                        {\n                          q=PopHexPixel(hex_digits,(size_t) index,q);\n                          q=PopHexPixel(hex_digits,(size_t)\n                            MagickMin(length,0xff),q);\n                          i++;\n                          if ((q-pixels+6) >= 80)\n                            {\n                              *q++='\\n';\n                              (void) WriteBlob(image,q-pixels,pixels);\n                              q=pixels;\n                            }\n                        }\n                      length=0;\n                    }\n                  index=GetPixelIndex(image,p);\n                  pixel.red=(MagickRealType) GetPixelRed(image,p);\n                  pixel.green=(MagickRealType) GetPixelGreen(image,p);\n                  pixel.blue=(MagickRealType) GetPixelBlue(image,p);\n                  pixel.alpha=(MagickRealType) GetPixelAlpha(image,p);\n                  p+=GetPixelChannels(image);\n                }\n                q=PopHexPixel(hex_digits,(size_t) index,q);\n                q=PopHexPixel(hex_digits,(size_t) MagickMin(length,0xff),q);\n                if ((q-pixels+6) >= 80)\n                  {\n                    *q++='\\n';\n                    (void) WriteBlob(image,q-pixels,pixels);\n                    q=pixels;\n                  }\n                if (image->previous == (Image *) NULL)\n                  {\n                    status=SetImageProgress(image,SaveImageTag,\n                      (MagickOffsetType) y,image->rows);\n                    if (status == MagickFalse)\n                      break;\n                  }\n              }\n              if (q != pixels)\n                {\n                  *q++='\\n';\n                  (void) WriteBlob(image,q-pixels,pixels);\n                }\n              break;\n            }\n            case NoCompression:\n            default:\n            {\n              /*\n                Dump uncompressed PseudoColor packets.\n              */\n              q=pixels;\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                for (x=0; x < (ssize_t) image->columns; x++)\n                {\n                  q=PopHexPixel(hex_digits,(size_t) GetPixelIndex(image,p),q);\n                  if ((q-pixels+4) >= 80)\n                    {\n                      *q++='\\n';\n                      (void) WriteBlob(image,q-pixels,pixels);\n                      q=pixels;\n                    }\n                  p+=GetPixelChannels(image);\n                }\n                if (image->previous == (Image *) NULL)\n                  {\n                    status=SetImageProgress(image,SaveImageTag,\n                      (MagickOffsetType) y,image->rows);\n                    if (status == MagickFalse)\n                      break;\n                  }\n              }\n              if (q != pixels)\n                {\n                  *q++='\\n';\n                  (void) WriteBlob(image,q-pixels,pixels);\n                }\n              break;\n            }\n          }\n          (void) WriteBlobByte(image,'\\n');\n        }\n    if (LocaleCompare(image_info->magick,\"PS\") != 0)\n      (void) WriteBlobString(image,\"end\\n\");\n    (void) WriteBlobString(image,\"%%PageTrailer\\n\");\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) WriteBlobString(image,\"%%Trailer\\n\");\n  if (page > 2)\n    {\n      (void) FormatLocaleString(buffer,MagickPathExtent,\n        \"%%%%BoundingBox: %.20g %.20g %.20g %.20g\\n\",ceil(bounds.x1-0.5),\n        ceil(bounds.y1-0.5),floor(bounds.x2-0.5),floor(bounds.y2-0.5));\n      (void) WriteBlobString(image,buffer);\n      (void) FormatLocaleString(buffer,MagickPathExtent,\n        \"%%%%HiResBoundingBox: %g %g %g %g\\n\",bounds.x1,bounds.y1,bounds.x2,\n        bounds.y2);\n      (void) WriteBlobString(image,buffer);\n    }\n  (void) WriteBlobString(image,\"%%EOF\\n\");\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "filenames": ["coders/ps.c"], "buggy_code_start_loc": [751], "buggy_code_end_loc": [751], "fixing_code_start_loc": [752], "fixing_code_end_loc": [753], "type": "CWE-401", "message": "ImageMagick before 7.0.8-50 has a memory leak vulnerability in the function ReadPSImage in coders/ps.c.", "other": {"cve": {"id": "CVE-2019-13137", "sourceIdentifier": "cve@mitre.org", "published": "2019-07-01T20:15:11.493", "lastModified": "2021-04-28T18:28:33.640", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ImageMagick before 7.0.8-50 has a memory leak vulnerability in the function ReadPSImage in coders/ps.c."}, {"lang": "es", "value": "ImageMagick en versiones anteriores a la 7.0.8-50 tiene una vulnerabilidad de fuga de memoria en la funci\u00f3n ReadPSImage in coders/ps."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.9.10-50", "matchCriteriaId": "BF97F7CB-3E80-4DBB-8854-FF5C012BA0FA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0-0", "versionEndExcluding": "7.0.8-50", "matchCriteriaId": "F8AB2B06-598F-4F38-813C-B1E3E1E7EEE5"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-08/msg00069.html", "source": "cve@mitre.org", "tags": ["Broken Link"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/35ccb468ee2dcbe8ce9cf1e2f1957acc27f54c34", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/1601", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick6/commit/7d11230060fa9c8f67e53c85224daf6648805c7b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4192-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4712", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/35ccb468ee2dcbe8ce9cf1e2f1957acc27f54c34"}}