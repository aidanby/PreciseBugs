{"buggy_code": ["/*\n * Copyright (c) 2013 Functional Streams for Scala\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\npackage fs2\npackage io\npackage net\npackage tls\n\nimport scala.concurrent.duration._\n\nimport cats.effect.{IO, Resource}\nimport cats.syntax.all._\n\nimport com.comcast.ip4s._\n\nclass TLSSocketSuite extends TLSSuite {\n  val size = 8192\n\n  group(\"TLSSocket\") {\n    group(\"google\") {\n      def googleSetup(protocol: SecureContext.SecureVersion) =\n        for {\n          tlsContext <- Resource.pure(\n            Network[IO].tlsContext.fromSecureContext(\n              SecureContext(minVersion = protocol.some, maxVersion = protocol.some)\n            )\n          )\n          socket <- Network[IO].client(SocketAddress(host\"google.com\", port\"443\"))\n          tlsSocket <- tlsContext\n            .clientBuilder(socket)\n            .withParameters(\n              TLSParameters(servername = \"www.google.com\".some)\n            )\n            .build\n        } yield tlsSocket\n\n      val googleDotCom = \"GET / HTTP/1.1\\r\\nHost: www.google.com\\r\\n\\r\\n\"\n      val httpOk = \"HTTP/1.1 200 OK\"\n\n      def writesBeforeReading(protocol: SecureContext.SecureVersion) =\n        test(s\"$protocol - client writes before reading\") {\n          Stream\n            .resource(googleSetup(protocol))\n            .flatMap { tlsSocket =>\n              Stream(googleDotCom)\n                .covary[IO]\n                .through(text.utf8.encode)\n                .through(tlsSocket.writes) ++\n                Stream.exec(tlsSocket.endOfOutput) ++\n                tlsSocket.reads\n                  .through(text.utf8.decode)\n                  .through(text.lines)\n            }\n            .head\n            .compile\n            .string\n            .assertEquals(httpOk)\n        }\n\n      def readsBeforeWriting(protocol: SecureContext.SecureVersion) =\n        test(s\"$protocol - client reads before writing\") {\n          Stream\n            .resource(googleSetup(protocol))\n            .flatMap { socket =>\n              val send = Stream(googleDotCom)\n                .through(text.utf8.encode)\n                .through(socket.writes)\n              val receive = socket.reads\n                .through(text.utf8.decode)\n                .through(text.lines)\n\n              receive.concurrently(send.delayBy(100.millis))\n            }\n            .head\n            .compile\n            .string\n            .assertEquals(httpOk)\n        }\n\n      import SecureContext.SecureVersion._\n      List(TLSv1, `TLSv1.1`, `TLSv1.2`, `TLSv1.3`).foreach { protocol =>\n        writesBeforeReading(protocol)\n        readsBeforeWriting(protocol)\n      }\n    }\n\n    test(\"echo\") {\n      val msg = Chunk.array((\"Hello, world! \" * 20000).getBytes)\n\n      val setup = for {\n        tlsContext <- Resource.eval(testTlsContext)\n        addressAndConnections <- Network[IO].serverResource(Some(ip\"127.0.0.1\"))\n        (serverAddress, server) = addressAndConnections\n        client <- Network[IO]\n          .client(serverAddress)\n          .flatMap(\n            tlsContext\n              .clientBuilder(_)\n              .withParameters(\n                TLSParameters(checkServerIdentity =\n                  Some((sn, _) => Either.cond(sn == \"localhost\", (), new RuntimeException()))\n                )\n              )\n              .build\n          )\n      } yield server.flatMap(s => Stream.resource(tlsContext.server(s))) -> client\n\n      Stream\n        .resource(setup)\n        .flatMap { case (server, clientSocket) =>\n          val echoServer = server.map { socket =>\n            socket.reads.chunks.foreach(socket.write(_))\n          }.parJoinUnbounded\n\n          val client =\n            Stream.exec(clientSocket.write(msg)) ++\n              clientSocket.reads.take(msg.size.toLong)\n\n          client.concurrently(echoServer)\n        }\n        .compile\n        .to(Chunk)\n        .assertEquals(msg)\n    }\n\n    test(\"error\") {\n      val msg = Chunk.array((\"Hello, world! \" * 20000).getBytes)\n\n      val setup = for {\n        tlsContext <- Resource.eval(Network[IO].tlsContext.system)\n        addressAndConnections <- Network[IO].serverResource(Some(ip\"127.0.0.1\"))\n        (serverAddress, server) = addressAndConnections\n        client <- Network[IO]\n          .client(serverAddress)\n          .flatMap(\n            tlsContext\n              .clientBuilder(_)\n              .withParameters(\n                TLSParameters(checkServerIdentity =\n                  Some((sn, _) => Either.cond(sn == \"localhost\", (), new RuntimeException()))\n                )\n              )\n              .build\n          )\n      } yield server.flatMap(s => Stream.resource(tlsContext.server(s))) -> client\n\n      Stream\n        .resource(setup)\n        .flatMap { case (server, clientSocket) =>\n          val echoServer = server.map { socket =>\n            socket.reads.chunks.foreach(socket.write(_))\n          }.parJoinUnbounded\n\n          val client =\n            Stream.exec(clientSocket.write(msg)) ++\n              clientSocket.reads.take(msg.size.toLong)\n\n          client.concurrently(echoServer)\n        }\n        .compile\n        .to(Chunk)\n        .intercept[SSLException]\n    }\n\n  }\n}\n", "/*\n * Copyright (c) 2013 Functional Streams for Scala\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\npackage fs2\npackage io\npackage net\npackage tls\n\nimport cats.effect.IO\nimport cats.syntax.all._\nimport fs2.io.file.Files\nimport fs2.io.file.Path\n\nimport scala.scalajs.js\n\nabstract class TLSSuite extends Fs2Suite {\n  def testTlsContext: IO[TLSContext[IO]] = Files[IO]\n    .readAll(Path(\"io/shared/src/test/resources/keystore.json\"))\n    .through(text.utf8.decode)\n    .compile\n    .string\n    .flatMap(s => IO(js.JSON.parse(s).asInstanceOf[js.Dictionary[CertKey]](\"server\")))\n    .map { certKey =>\n      Network[IO].tlsContext.fromSecureContext(\n        SecureContext(\n          ca = List(certKey.cert.asRight).some,\n          cert = List(certKey.cert.asRight).some,\n          key = List(SecureContext.Key(certKey.key.asRight, \"password\".some)).some\n        )\n      )\n    }\n\n  val logger = TLSLogger.Disabled\n  // val logger = TLSLogger.Enabled(msg => IO(println(s\"\\u001b[33m${msg}\\u001b[0m\")))\n\n}\n\n@js.native\ntrait CertKey extends js.Object {\n  def cert: String = js.native\n  def key: String = js.native\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2013 Functional Streams for Scala\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\npackage fs2\npackage io\npackage net\npackage tls\n\nimport scala.concurrent.duration._\n\nimport cats.effect.{IO, Resource}\nimport cats.syntax.all._\n\nimport com.comcast.ip4s._\n\nclass TLSSocketSuite extends TLSSuite {\n  val size = 8192\n\n  group(\"TLSSocket\") {\n    group(\"google\") {\n      def googleSetup(protocol: SecureContext.SecureVersion) =\n        for {\n          tlsContext <- Resource.pure(\n            Network[IO].tlsContext.fromSecureContext(\n              SecureContext(minVersion = protocol.some, maxVersion = protocol.some)\n            )\n          )\n          socket <- Network[IO].client(SocketAddress(host\"google.com\", port\"443\"))\n          tlsSocket <- tlsContext\n            .clientBuilder(socket)\n            .withParameters(\n              TLSParameters(servername = \"www.google.com\".some)\n            )\n            .build\n        } yield tlsSocket\n\n      val googleDotCom = \"GET / HTTP/1.1\\r\\nHost: www.google.com\\r\\n\\r\\n\"\n      val httpOk = \"HTTP/1.1 200 OK\"\n\n      def writesBeforeReading(protocol: SecureContext.SecureVersion) =\n        test(s\"$protocol - client writes before reading\") {\n          Stream\n            .resource(googleSetup(protocol))\n            .flatMap { tlsSocket =>\n              Stream(googleDotCom)\n                .covary[IO]\n                .through(text.utf8.encode)\n                .through(tlsSocket.writes) ++\n                Stream.exec(tlsSocket.endOfOutput) ++\n                tlsSocket.reads\n                  .through(text.utf8.decode)\n                  .through(text.lines)\n            }\n            .head\n            .compile\n            .string\n            .assertEquals(httpOk)\n        }\n\n      def readsBeforeWriting(protocol: SecureContext.SecureVersion) =\n        test(s\"$protocol - client reads before writing\") {\n          Stream\n            .resource(googleSetup(protocol))\n            .flatMap { socket =>\n              val send = Stream(googleDotCom)\n                .through(text.utf8.encode)\n                .through(socket.writes)\n              val receive = socket.reads\n                .through(text.utf8.decode)\n                .through(text.lines)\n\n              receive.concurrently(send.delayBy(100.millis))\n            }\n            .head\n            .compile\n            .string\n            .assertEquals(httpOk)\n        }\n\n      import SecureContext.SecureVersion._\n      List(TLSv1, `TLSv1.1`, `TLSv1.2`, `TLSv1.3`).foreach { protocol =>\n        writesBeforeReading(protocol)\n        readsBeforeWriting(protocol)\n      }\n    }\n\n    test(\"echo\") {\n      val msg = Chunk.array((\"Hello, world! \" * 20000).getBytes)\n\n      val setup = for {\n        tlsContext <- Resource.eval(testTlsContext(true))\n        addressAndConnections <- Network[IO].serverResource(Some(ip\"127.0.0.1\"))\n        (serverAddress, server) = addressAndConnections\n        client <- Network[IO]\n          .client(serverAddress)\n          .flatMap(\n            tlsContext\n              .clientBuilder(_)\n              .withParameters(\n                TLSParameters(checkServerIdentity =\n                  Some((sn, _) => Either.cond(sn == \"localhost\", (), new RuntimeException()))\n                )\n              )\n              .build\n          )\n      } yield server.flatMap(s => Stream.resource(tlsContext.server(s))) -> client\n\n      Stream\n        .resource(setup)\n        .flatMap { case (server, clientSocket) =>\n          val echoServer = server.map { socket =>\n            socket.reads.chunks.foreach(socket.write(_))\n          }.parJoinUnbounded\n\n          val client =\n            Stream.exec(clientSocket.write(msg)) ++\n              clientSocket.reads.take(msg.size.toLong)\n\n          client.concurrently(echoServer)\n        }\n        .compile\n        .to(Chunk)\n        .assertEquals(msg)\n    }\n\n    test(\"error\") {\n      val msg = Chunk.array((\"Hello, world! \" * 20000).getBytes)\n\n      val setup = for {\n        tlsContext <- Resource.eval(Network[IO].tlsContext.system)\n        addressAndConnections <- Network[IO].serverResource(Some(ip\"127.0.0.1\"))\n        (serverAddress, server) = addressAndConnections\n        client <- Network[IO]\n          .client(serverAddress)\n          .flatMap(\n            tlsContext\n              .clientBuilder(_)\n              .withParameters(\n                TLSParameters(checkServerIdentity =\n                  Some((sn, _) => Either.cond(sn == \"localhost\", (), new RuntimeException()))\n                )\n              )\n              .build\n          )\n      } yield server.flatMap(s => Stream.resource(tlsContext.server(s))) -> client\n\n      Stream\n        .resource(setup)\n        .flatMap { case (server, clientSocket) =>\n          val echoServer = server.map { socket =>\n            socket.reads.chunks.foreach(socket.write(_))\n          }.parJoinUnbounded\n\n          val client =\n            Stream.exec(clientSocket.write(msg)) ++\n              clientSocket.reads.take(msg.size.toLong)\n\n          client.concurrently(echoServer)\n        }\n        .compile\n        .to(Chunk)\n        .intercept[SSLException]\n    }\n\n    test(\"mTLS client verification\".only) { // GHSA-2cpx-6pqp-wf35\n      val msg = Chunk.array((\"Hello, world! \" * 20000).getBytes)\n\n      val setup = for {\n        serverContext <- Resource.eval(testTlsContext(true))\n        clientContext <- Resource.eval(testTlsContext(false))\n        addressAndConnections <- Network[IO].serverResource(Some(ip\"127.0.0.1\"))\n        (serverAddress, server) = addressAndConnections\n        client <- Network[IO]\n          .client(serverAddress)\n          .flatMap(\n            clientContext\n              .clientBuilder(_)\n              .withParameters(\n                TLSParameters(checkServerIdentity =\n                  Some((sn, _) => Either.cond(sn == \"localhost\", (), new RuntimeException()))\n                )\n              )\n              .build\n          )\n      } yield server.flatMap(s =>\n        Stream.resource(\n          serverContext\n            .serverBuilder(s)\n            .withParameters(TLSParameters(requestCert = true.some)) // mTLS\n            .build\n        )\n      ) -> client\n\n      Stream\n        .resource(setup)\n        .flatMap { case (server, clientSocket) =>\n          val echoServer = server.map { socket =>\n            socket.reads.chunks.foreach(socket.write(_))\n          }.parJoinUnbounded\n\n          val client =\n            Stream.exec(clientSocket.write(msg)) ++\n              clientSocket.reads.take(msg.size.toLong)\n\n          client.concurrently(echoServer)\n        }\n        .compile\n        .to(Chunk)\n        .intercept[SSLException]\n    }\n\n  }\n}\n", "/*\n * Copyright (c) 2013 Functional Streams for Scala\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\npackage fs2\npackage io\npackage net\npackage tls\n\nimport cats.effect.IO\nimport cats.syntax.all._\nimport fs2.io.file.Files\nimport fs2.io.file.Path\n\nimport scala.scalajs.js\n\nabstract class TLSSuite extends Fs2Suite {\n\n  def testTlsContext(privateKey: Boolean): IO[TLSContext[IO]] = Files[IO]\n    .readAll(Path(\"io/shared/src/test/resources/keystore.json\"))\n    .through(text.utf8.decode)\n    .compile\n    .string\n    .flatMap(s => IO(js.JSON.parse(s).asInstanceOf[js.Dictionary[CertKey]](\"server\")))\n    .map { certKey =>\n      Network[IO].tlsContext.fromSecureContext(\n        SecureContext(\n          ca = List(certKey.cert.asRight).some,\n          cert = List(certKey.cert.asRight).some,\n          key =\n            if (privateKey) List(SecureContext.Key(certKey.key.asRight, \"password\".some)).some\n            else None\n        )\n      )\n    }\n\n  val logger = TLSLogger.Disabled\n  // val logger = TLSLogger.Enabled(msg => IO(println(s\"\\u001b[33m${msg}\\u001b[0m\")))\n\n}\n\n@js.native\ntrait CertKey extends js.Object {\n  def cert: String = js.native\n  def key: String = js.native\n}\n"], "filenames": ["io/js/src/test/scala/fs2/io/net/tls/TLSSocketSuite.scala", "io/js/src/test/scala/fs2/io/net/tls/TLSSuite.scala"], "buggy_code_start_loc": [109, 35], "buggy_code_end_loc": [182, 47], "fixing_code_start_loc": [109, 35], "fixing_code_end_loc": [230, 50], "type": "CWE-295", "message": "fs2 is a compositional, streaming I/O library for Scala. When establishing a server-mode `TLSSocket` using `fs2-io` on Node.js, the parameter `requestCert = true` is ignored, peer certificate verification is skipped, and the connection proceeds. The vulnerability is limited to: 1. `fs2-io` running on Node.js. The JVM TLS implementation is completely independent. 2. `TLSSocket`s in server-mode. Client-mode `TLSSocket`s are implemented via a different API. 3. mTLS as enabled via `requestCert = true` in `TLSParameters`. The default setting is `false` for server-mode `TLSSocket`s. It was introduced with the initial Node.js implementation of fs2-io in 3.1.0. A patch is released in v3.2.11. The requestCert = true parameter is respected and the peer certificate is verified. If verification fails, a SSLException is raised. If using an unpatched version on Node.js, do not use a server-mode TLSSocket with requestCert = true to establish a mTLS connection.", "other": {"cve": {"id": "CVE-2022-31183", "sourceIdentifier": "security-advisories@github.com", "published": "2022-08-01T20:15:08.410", "lastModified": "2022-08-09T19:38:00.897", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "fs2 is a compositional, streaming I/O library for Scala. When establishing a server-mode `TLSSocket` using `fs2-io` on Node.js, the parameter `requestCert = true` is ignored, peer certificate verification is skipped, and the connection proceeds. The vulnerability is limited to: 1. `fs2-io` running on Node.js. The JVM TLS implementation is completely independent. 2. `TLSSocket`s in server-mode. Client-mode `TLSSocket`s are implemented via a different API. 3. mTLS as enabled via `requestCert = true` in `TLSParameters`. The default setting is `false` for server-mode `TLSSocket`s. It was introduced with the initial Node.js implementation of fs2-io in 3.1.0. A patch is released in v3.2.11. The requestCert = true parameter is respected and the peer certificate is verified. If verification fails, a SSLException is raised. If using an unpatched version on Node.js, do not use a server-mode TLSSocket with requestCert = true to establish a mTLS connection."}, {"lang": "es", "value": "fs2 es una librer\u00eda de E/S de composici\u00f3n para Scala. Cuando es establecido un \"TLSSocket\" en modo servidor usando \"fs2-io\" en Node.js, el par\u00e1metro \"requestCert = true\" es ignorado, la verificaci\u00f3n del certificado del compa\u00f1ero es omitida, y la conexi\u00f3n procede. La vulnerabilidad es limitada a: 1. \"fs2-io\" corriendo en Node.js. La implementaci\u00f3n de TLS en la JVM es completamente independiente. 2. \"TLSSocket\"s en modo servidor. Los \"TLSSocket\" en modo cliente es implementado por medio de una API diferente. 3. mTLS est\u00e1 habilitado por medio de \"requestCert = true\" en \"TLSParameters\". La configuraci\u00f3n por defecto es \"false\" para los \"TLSSocket\" en modo servidor. Es introducida con la implementaci\u00f3n inicial de Node.js de fs2-io en la versi\u00f3n 3.1.0. Ha sido publicado un parche en la versi\u00f3n 3.2.11. Es respetado el par\u00e1metro requestCert = true y es verificado el certificado del compa\u00f1ero. Si la verificaci\u00f3n falla, es lanzada una SSLException. Si es usada una versi\u00f3n sin parche en Node.js, no debe usarse un TLSSocket en modo servidor con requestCert = true para establecer una conexi\u00f3n mTLS"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-295"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:typelevel:fs2:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.1.0", "versionEndExcluding": "3.2.11", "matchCriteriaId": "750D10F3-1FF8-4173-A44A-ACDE06641472"}]}]}], "references": [{"url": "https://github.com/nodejs/node/issues/43994", "source": "security-advisories@github.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/typelevel/fs2/commit/659824395826a314e0a4331535dbf1ef8bef8207", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/typelevel/fs2/security/advisories/GHSA-2cpx-6pqp-wf35", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/typelevel/fs2/commit/659824395826a314e0a4331535dbf1ef8bef8207"}}