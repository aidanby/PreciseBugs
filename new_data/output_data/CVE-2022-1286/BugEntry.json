{"buggy_code": ["/*\n** class.c - Class class\n**\n** See Copyright Notice in mruby.h\n*/\n\n#include <mruby.h>\n#include <mruby/array.h>\n#include <mruby/hash.h>\n#include <mruby/class.h>\n#include <mruby/numeric.h>\n#include <mruby/proc.h>\n#include <mruby/string.h>\n#include <mruby/variable.h>\n#include <mruby/error.h>\n#include <mruby/data.h>\n#include <mruby/istruct.h>\n#include <mruby/opcode.h>\n#include <mruby/internal.h>\n#include <mruby/presym.h>\n\nunion mt_ptr {\n  struct RProc *proc;\n  mrb_func_t func;\n};\n\n#define MT_KEY_P(k) (((k)>>2) != 0)\n#define MT_FUNC_P 1\n#define MT_NOARG_P 2\n#define MT_EMPTY 0\n#define MT_DELETED 1\n\n#define MT_KEY(sym, flags) ((sym)<<2|(flags))\n#define MT_FLAGS(func_p, noarg_p) ((func_p)?MT_FUNC_P:0)|((noarg_p)?MT_NOARG_P:0)\n#define MT_KEY_SYM(k) ((k)>>2)\n#define MT_KEY_FLG(k) ((k)&3)\n\n/* method table structure */\ntypedef struct mt_tbl {\n  int size;\n  int alloc;\n  union mt_ptr *ptr;\n} mt_tbl;\n\n#ifdef MRB_USE_INLINE_METHOD_CACHE\n#define MT_CACHE_SIZE 256\nstatic uint8_t mt_cache[MT_CACHE_SIZE];\n#endif\n\n/* Creates the method table. */\nstatic mt_tbl*\nmt_new(mrb_state *mrb)\n{\n  mt_tbl *t;\n\n  t = (mt_tbl*)mrb_malloc(mrb, sizeof(mt_tbl));\n  t->size = 0;\n  t->alloc = 0;\n  t->ptr = NULL;\n\n  return t;\n}\n\nstatic void mt_put(mrb_state *mrb, mt_tbl *t, mrb_sym sym, mrb_sym flags, union mt_ptr ptr);\n\nstatic void\nmt_rehash(mrb_state *mrb, mt_tbl *t)\n{\n  int old_alloc = t->alloc;\n  int new_alloc = old_alloc+8;\n  union mt_ptr *old_ptr = t->ptr;\n\n  khash_power2(new_alloc);\n  if (old_alloc == new_alloc) return;\n\n  t->alloc = new_alloc;\n  t->size = 0;\n  t->ptr = (union mt_ptr*)mrb_calloc(mrb, sizeof(union mt_ptr)+sizeof(mrb_sym), new_alloc);\n  if (old_alloc == 0) return;\n\n  mrb_sym *keys = (mrb_sym*)&old_ptr[old_alloc];\n  union mt_ptr *vals = old_ptr;\n  for (int i = 0; i < old_alloc; i++) {\n    mrb_sym key = keys[i];\n    if (MT_KEY_P(key)) {\n      mt_put(mrb, t, MT_KEY_SYM(key), MT_KEY_FLG(key), vals[i]);\n    }\n  }\n  mrb_free(mrb, old_ptr);\n}\n\n#define slot_empty_p(slot) ((slot)->key == 0 && (slot)->func_p == 0)\n\n/* Set the value for the symbol in the method table. */\nstatic void\nmt_put(mrb_state *mrb, mt_tbl *t, mrb_sym sym, mrb_sym flags, union mt_ptr ptr)\n{\n  int hash, pos, start, dpos = -1;\n\n  if (t->alloc == 0) {\n    mt_rehash(mrb, t);\n  }\n\n  mrb_sym *keys = (mrb_sym*)&t->ptr[t->alloc];\n  union mt_ptr *vals = t->ptr;\n  hash = kh_int_hash_func(mrb, sym);\n  start = pos = hash & (t->alloc-1);\n  for (;;) {\n    mrb_sym key = keys[pos];\n    if (MT_KEY_SYM(key) == sym) {\n    value_set:\n      keys[pos] = MT_KEY(sym, flags);\n      vals[pos] = ptr;\n      return;\n    }\n    else if (key == MT_EMPTY) {\n      t->size++;\n      goto value_set;\n    }\n    else if (key == MT_DELETED && dpos < 0) {\n      dpos = pos;\n    }\n    pos = (pos+1) & (t->alloc-1);\n    if (pos == start) {         /* not found */\n      if (dpos > 0) {\n        t->size++;\n        pos = dpos;\n        goto value_set;\n      }\n      /* no room */\n      mt_rehash(mrb, t);\n      start = pos = hash & (t->alloc-1);\n      keys = (mrb_sym*)&t->ptr[t->alloc];\n      vals = t->ptr;\n    }\n  }\n}\n\n/* Get a value for a symbol from the method table. */\nstatic mrb_sym\nmt_get(mrb_state *mrb, mt_tbl *t, mrb_sym sym, union mt_ptr *pp)\n{\n  int hash, pos, start;\n\n  if (t == NULL) return 0;\n  if (t->alloc == 0) return 0;\n  if (t->size == 0) return 0;\n\n  mrb_sym *keys = (mrb_sym*)&t->ptr[t->alloc];\n  union mt_ptr *vals = t->ptr;\n  hash = kh_int_hash_func(mrb, sym);\n#ifdef MRB_USE_INLINE_METHOD_CACHE\n  int cpos = (hash^(uintptr_t)t) % MT_CACHE_SIZE;\n  pos = mt_cache[cpos];\n  if (cpos < t->alloc && t->table[cpos].key == sym) {\n    return &t->table[cpos];\n  }\n#endif\n  start = pos = hash & (t->alloc-1);\n  for (;;) {\n    mrb_sym key = keys[pos];\n    if (MT_KEY_SYM(key) == sym) {\n      *pp = vals[pos];\n#ifdef MRB_USE_INLINE_METHOD_CACHE\n      if (pos < 0xff) {\n        mt_cache[cpos] = pos;\n      }\n#endif\n      return key;\n    }\n    else if (key == MT_EMPTY) {\n      return 0;\n    }\n    pos = (pos+1) & (t->alloc-1);\n    if (pos == start) {         /* not found */\n      return 0;\n    }\n  }\n}\n\n/* Deletes the value for the symbol from the method table. */\nstatic mrb_bool\nmt_del(mrb_state *mrb, mt_tbl *t, mrb_sym sym)\n{\n  int hash, pos, start;\n\n  if (t == NULL) return FALSE;\n  if (t->alloc == 0) return  FALSE;\n  if (t->size == 0) return FALSE;\n\n  mrb_sym *keys = (mrb_sym*)&t->ptr[t->alloc];\n  hash = kh_int_hash_func(mrb, sym);\n  start = pos = hash & (t->alloc-1);\n  for (;;) {\n    mrb_sym key = keys[pos];\n    if (MT_KEY_SYM(key) == sym) {\n      t->size--;\n      keys[pos] = MT_DELETED;\n      return TRUE;\n    }\n    else if (key == MT_EMPTY) {\n      return FALSE;\n    }\n    pos = (pos+1) & (t->alloc-1);\n    if (pos == start) {         /* not found */\n      return FALSE;\n    }\n  }\n}\n\n/* Copy the method table. */\nstatic struct mt_tbl*\nmt_copy(mrb_state *mrb, mt_tbl *t)\n{\n  mt_tbl *t2;\n  int i;\n\n  if (t == NULL) return NULL;\n  if (t->alloc == 0) return NULL;\n  if (t->size == 0) return NULL;\n\n  t2 = mt_new(mrb);\n  mrb_sym *keys = (mrb_sym*)&t->ptr[t->alloc];\n  union mt_ptr *vals = t->ptr;\n  for (i=0; i<t->alloc; i++) {\n    if (MT_KEY_P(keys[i])) {\n      mt_put(mrb, t2, MT_KEY_SYM(keys[i]), MT_KEY_FLG(keys[i]), vals[i]);\n    }\n  }\n  return t2;\n}\n\n/* Free memory of the method table. */\nstatic void\nmt_free(mrb_state *mrb, mt_tbl *t)\n{\n  mrb_free(mrb, t->ptr);\n  mrb_free(mrb, t);\n}\n\nMRB_API void\nmrb_mt_foreach(mrb_state *mrb, struct RClass *c, mrb_mt_foreach_func *fn, void *p)\n{\n  mt_tbl *t = c->mt;\n  int i;\n\n  if (t == NULL) return;\n  if (t->alloc == 0) return;\n  if (t->size == 0) return;\n\n  mrb_sym *keys = (mrb_sym*)&t->ptr[t->alloc];\n  union mt_ptr *vals = t->ptr;\n  for (i=0; i<t->alloc; i++) {\n    mrb_sym key = keys[i];\n    if (MT_KEY_SYM(key)) {\n      mrb_method_t m;\n\n      if (key & MT_FUNC_P) {\n        MRB_METHOD_FROM_FUNC(m, vals[i].func);\n      }\n      else {\n        MRB_METHOD_FROM_PROC(m, vals[i].proc);\n      }\n      if (key & MT_NOARG_P) {\n        MRB_METHOD_NOARG_SET(m);\n      }\n\n      if (fn(mrb, MT_KEY_SYM(key), m, p) != 0)\n        return;\n    }\n  }\n  return;\n}\n\nvoid\nmrb_gc_mark_mt(mrb_state *mrb, struct RClass *c)\n{\n  mt_tbl *t = c->mt;\n  int i;\n\n  if (t == NULL) return;\n  if (t->alloc == 0) return;\n  if (t->size == 0) return;\n\n  mrb_sym *keys = (mrb_sym*)&t->ptr[t->alloc];\n  union mt_ptr *vals = t->ptr;\n  for (i=0; i<t->alloc; i++) {\n    if (MT_KEY_P(keys[i]) && (keys[i] & MT_FUNC_P) == 0) { /* Proc pointer */\n      struct RProc *p = vals[i].proc;\n      mrb_gc_mark(mrb, (struct RBasic*)p);\n    }\n  }\n  return;\n}\n\nsize_t\nmrb_gc_mark_mt_size(mrb_state *mrb, struct RClass *c)\n{\n  struct mt_tbl *h = c->mt;\n\n  if (!h) return 0;\n  return (size_t)h->size;\n}\n\nvoid\nmrb_gc_free_mt(mrb_state *mrb, struct RClass *c)\n{\n  if (c->mt) mt_free(mrb, c->mt);\n}\n\nvoid\nmrb_class_name_class(mrb_state *mrb, struct RClass *outer, struct RClass *c, mrb_sym id)\n{\n  mrb_value name;\n  mrb_sym nsym = MRB_SYM(__classname__);\n\n  if (mrb_obj_iv_defined(mrb, (struct RObject*)c, nsym)) return;\n  if (outer == NULL || outer == mrb->object_class) {\n    name = mrb_symbol_value(id);\n  }\n  else {\n    name = mrb_class_path(mrb, outer);\n    if (mrb_nil_p(name)) {      /* unnamed outer class */\n      if (outer != mrb->object_class && outer != c) {\n        mrb_obj_iv_set_force(mrb, (struct RObject*)c, MRB_SYM(__outer__),\n                             mrb_obj_value(outer));\n      }\n      return;\n    }\n    else {\n      mrb_int len;\n      const char *n = mrb_sym_name_len(mrb, id, &len);\n\n      mrb_str_cat_lit(mrb, name, \"::\");\n      mrb_str_cat(mrb, name, n, len);\n    }\n  }\n  mrb_obj_iv_set_force(mrb, (struct RObject*)c, nsym, name);\n}\n\nmrb_bool\nmrb_const_name_p(mrb_state *mrb, const char *name, mrb_int len)\n{\n  return len > 0 && ISUPPER(name[0]) && mrb_ident_p(name+1, len-1);\n}\n\nstatic void\nsetup_class(mrb_state *mrb, struct RClass *outer, struct RClass *c, mrb_sym id)\n{\n  mrb_class_name_class(mrb, outer, c, id);\n  mrb_obj_iv_set(mrb, (struct RObject*)outer, id, mrb_obj_value(c));\n}\n\n#define make_metaclass(mrb, c) prepare_singleton_class((mrb), (struct RBasic*)(c))\n\nstatic void\nprepare_singleton_class(mrb_state *mrb, struct RBasic *o)\n{\n  struct RClass *sc, *c;\n\n  mrb_assert(o->c);\n  if (o->c->tt == MRB_TT_SCLASS) return;\n  sc = MRB_OBJ_ALLOC(mrb, MRB_TT_SCLASS, mrb->class_class);\n  sc->flags |= MRB_FL_CLASS_IS_INHERITED;\n  sc->mt = mt_new(mrb);\n  sc->iv = 0;\n  if (o->tt == MRB_TT_CLASS) {\n    c = (struct RClass*)o;\n    if (!c->super) {\n      sc->super = mrb->class_class;\n    }\n    else {\n      sc->super = c->super->c;\n    }\n  }\n  else if (o->tt == MRB_TT_SCLASS) {\n    c = (struct RClass*)o;\n    while (c->super->tt == MRB_TT_ICLASS)\n      c = c->super;\n    make_metaclass(mrb, c->super);\n    sc->super = c->super->c;\n  }\n  else {\n    sc->super = o->c;\n    prepare_singleton_class(mrb, (struct RBasic*)sc);\n  }\n  o->c = sc;\n  mrb_field_write_barrier(mrb, (struct RBasic*)o, (struct RBasic*)sc);\n  mrb_field_write_barrier(mrb, (struct RBasic*)sc, (struct RBasic*)o);\n  mrb_obj_iv_set(mrb, (struct RObject*)sc, MRB_SYM(__attached__), mrb_obj_value(o));\n  sc->flags |= o->flags & MRB_FL_OBJ_IS_FROZEN;\n}\n\nstatic mrb_value\nclass_name_str(mrb_state *mrb, struct RClass* c)\n{\n  mrb_value path = mrb_class_path(mrb, c);\n  if (mrb_nil_p(path)) {\n    path = c->tt == MRB_TT_MODULE ? mrb_str_new_lit(mrb, \"#<Module:\") :\n                                    mrb_str_new_lit(mrb, \"#<Class:\");\n    mrb_str_cat_str(mrb, path, mrb_ptr_to_str(mrb, c));\n    mrb_str_cat_lit(mrb, path, \">\");\n  }\n  return path;\n}\n\nstatic struct RClass*\nclass_from_sym(mrb_state *mrb, struct RClass *klass, mrb_sym id)\n{\n  mrb_value c = mrb_const_get(mrb, mrb_obj_value(klass), id);\n\n  mrb_check_type(mrb, c, MRB_TT_CLASS);\n  return mrb_class_ptr(c);\n}\n\nstatic struct RClass*\nmodule_from_sym(mrb_state *mrb, struct RClass *klass, mrb_sym id)\n{\n  mrb_value c = mrb_const_get(mrb, mrb_obj_value(klass), id);\n\n  mrb_check_type(mrb, c, MRB_TT_MODULE);\n  return mrb_class_ptr(c);\n}\n\nstatic mrb_bool\nclass_ptr_p(mrb_value obj)\n{\n  switch (mrb_type(obj)) {\n  case MRB_TT_CLASS:\n  case MRB_TT_SCLASS:\n  case MRB_TT_MODULE:\n    return TRUE;\n  default:\n    return FALSE;\n  }\n}\n\nstatic void\ncheck_if_class_or_module(mrb_state *mrb, mrb_value obj)\n{\n  if (!class_ptr_p(obj)) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"%!v is not a class/module\", obj);\n  }\n}\n\nstatic struct RClass*\ndefine_module(mrb_state *mrb, mrb_sym name, struct RClass *outer)\n{\n  struct RClass *m;\n\n  if (mrb_const_defined_at(mrb, mrb_obj_value(outer), name)) {\n    return module_from_sym(mrb, outer, name);\n  }\n  m = mrb_module_new(mrb);\n  setup_class(mrb, outer, m, name);\n\n  return m;\n}\n\nMRB_API struct RClass*\nmrb_define_module_id(mrb_state *mrb, mrb_sym name)\n{\n  return define_module(mrb, name, mrb->object_class);\n}\n\nMRB_API struct RClass*\nmrb_define_module(mrb_state *mrb, const char *name)\n{\n  return define_module(mrb, mrb_intern_cstr(mrb, name), mrb->object_class);\n}\n\nstruct RClass*\nmrb_vm_define_module(mrb_state *mrb, mrb_value outer, mrb_sym id)\n{\n  check_if_class_or_module(mrb, outer);\n  if (mrb_const_defined_at(mrb, outer, id)) {\n    mrb_value old = mrb_const_get(mrb, outer, id);\n\n    if (!mrb_module_p(old)) {\n      mrb_raisef(mrb, E_TYPE_ERROR, \"%!v is not a module\", old);\n    }\n    return mrb_class_ptr(old);\n  }\n  return define_module(mrb, id, mrb_class_ptr(outer));\n}\n\nMRB_API struct RClass*\nmrb_define_module_under_id(mrb_state *mrb, struct RClass *outer, mrb_sym name)\n{\n  struct RClass * c = define_module(mrb, name, outer);\n\n  setup_class(mrb, outer, c, name);\n  return c;\n}\n\nMRB_API struct RClass*\nmrb_define_module_under(mrb_state *mrb, struct RClass *outer, const char *name)\n{\n  mrb_sym id = mrb_intern_cstr(mrb, name);\n  struct RClass * c = define_module(mrb, id, outer);\n\n  setup_class(mrb, outer, c, id);\n  return c;\n}\n\nstatic struct RClass*\nfind_origin(struct RClass *c)\n{\n  MRB_CLASS_ORIGIN(c);\n  return c;\n}\n\nstatic struct RClass*\ndefine_class(mrb_state *mrb, mrb_sym name, struct RClass *super, struct RClass *outer)\n{\n  struct RClass * c;\n\n  if (mrb_const_defined_at(mrb, mrb_obj_value(outer), name)) {\n    c = class_from_sym(mrb, outer, name);\n    MRB_CLASS_ORIGIN(c);\n    if (super && mrb_class_real(c->super) != super) {\n      mrb_raisef(mrb, E_TYPE_ERROR, \"superclass mismatch for Class %n (%C not %C)\",\n                 name, c->super, super);\n    }\n    return c;\n  }\n\n  c = mrb_class_new(mrb, super);\n  setup_class(mrb, outer, c, name);\n\n  return c;\n}\n\nMRB_API struct RClass*\nmrb_define_class_id(mrb_state *mrb, mrb_sym name, struct RClass *super)\n{\n  if (!super) {\n    mrb_warn(mrb, \"no super class for '%n', Object assumed\", name);\n  }\n  return define_class(mrb, name, super, mrb->object_class);\n}\n\nMRB_API struct RClass*\nmrb_define_class(mrb_state *mrb, const char *name, struct RClass *super)\n{\n  return mrb_define_class_id(mrb, mrb_intern_cstr(mrb, name), super);\n}\n\nstatic mrb_value mrb_do_nothing(mrb_state *mrb, mrb_value);\n#ifndef MRB_NO_METHOD_CACHE\nstatic void mc_clear(mrb_state *mrb);\n#else\n#define mc_clear(mrb)\n#endif\n\nstatic void\nmrb_class_inherited(mrb_state *mrb, struct RClass *super, struct RClass *klass)\n{\n  mrb_value s;\n  mrb_sym mid;\n\n  if (!super)\n    super = mrb->object_class;\n  super->flags |= MRB_FL_CLASS_IS_INHERITED;\n  s = mrb_obj_value(super);\n  mrb_mc_clear_by_class(mrb, klass);\n  mid = MRB_SYM(inherited);\n  if (!mrb_func_basic_p(mrb, s, mid, mrb_do_nothing)) {\n    mrb_value c = mrb_obj_value(klass);\n    mrb_funcall_argv(mrb, s, mid, 1, &c);\n  }\n}\n\nstruct RClass*\nmrb_vm_define_class(mrb_state *mrb, mrb_value outer, mrb_value super, mrb_sym id)\n{\n  struct RClass *s;\n  struct RClass *c;\n\n  if (!mrb_nil_p(super)) {\n    if (!mrb_class_p(super)) {\n      mrb_raisef(mrb, E_TYPE_ERROR, \"superclass must be a Class (%!v given)\", super);\n    }\n    s = mrb_class_ptr(super);\n  }\n  else {\n    s = 0;\n  }\n  check_if_class_or_module(mrb, outer);\n  if (mrb_const_defined_at(mrb, outer, id)) {\n    mrb_value old = mrb_const_get(mrb, outer, id);\n\n    if (!mrb_class_p(old)) {\n      mrb_raisef(mrb, E_TYPE_ERROR, \"%!v is not a class\", old);\n    }\n    c = mrb_class_ptr(old);\n    if (s) {\n      /* check super class */\n      if (mrb_class_real(c->super) != s) {\n        mrb_raisef(mrb, E_TYPE_ERROR, \"superclass mismatch for class %v\", old);\n      }\n    }\n    return c;\n  }\n  c = define_class(mrb, id, s, mrb_class_ptr(outer));\n  mrb_class_inherited(mrb, mrb_class_real(c->super), c);\n\n  return c;\n}\n\nMRB_API mrb_bool\nmrb_class_defined(mrb_state *mrb, const char *name)\n{\n  mrb_sym sym = mrb_intern_check_cstr(mrb, name);\n  if (!sym) return FALSE;\n  return mrb_const_defined(mrb, mrb_obj_value(mrb->object_class), sym);\n}\n\nMRB_API mrb_bool\nmrb_class_defined_id(mrb_state *mrb, mrb_sym name)\n{\n  return mrb_const_defined(mrb, mrb_obj_value(mrb->object_class), name);\n}\n\nMRB_API mrb_bool\nmrb_class_defined_under(mrb_state *mrb, struct RClass *outer, const char *name)\n{\n  mrb_sym sym = mrb_intern_check_cstr(mrb, name);\n  if (!sym) return FALSE;\n  return mrb_const_defined_at(mrb, mrb_obj_value(outer), sym);\n}\n\nMRB_API mrb_bool\nmrb_class_defined_under_id(mrb_state *mrb, struct RClass *outer, mrb_sym name)\n{\n  return mrb_const_defined_at(mrb, mrb_obj_value(outer), name);\n}\n\nMRB_API struct RClass*\nmrb_class_get_under(mrb_state *mrb, struct RClass *outer, const char *name)\n{\n  return class_from_sym(mrb, outer, mrb_intern_cstr(mrb, name));\n}\n\nMRB_API struct RClass*\nmrb_class_get_under_id(mrb_state *mrb, struct RClass *outer, mrb_sym name)\n{\n  return class_from_sym(mrb, outer, name);\n}\n\nMRB_API struct RClass*\nmrb_class_get(mrb_state *mrb, const char *name)\n{\n  return mrb_class_get_under(mrb, mrb->object_class, name);\n}\n\nMRB_API struct RClass*\nmrb_class_get_id(mrb_state *mrb, mrb_sym name)\n{\n  return mrb_class_get_under_id(mrb, mrb->object_class, name);\n}\n\nMRB_API struct RClass*\nmrb_exc_get_id(mrb_state *mrb, mrb_sym name)\n{\n  struct RClass *exc, *e;\n  mrb_value c = mrb_const_get(mrb, mrb_obj_value(mrb->object_class), name);\n\n  if (!mrb_class_p(c)) {\n    mrb_raise(mrb, mrb->eException_class, \"exception corrupted\");\n  }\n  exc = e = mrb_class_ptr(c);\n\n  while (e) {\n    if (e == mrb->eException_class)\n      return exc;\n    e = e->super;\n  }\n  return mrb->eException_class;\n}\n\nMRB_API struct RClass*\nmrb_module_get_under(mrb_state *mrb, struct RClass *outer, const char *name)\n{\n  return module_from_sym(mrb, outer, mrb_intern_cstr(mrb, name));\n}\n\nMRB_API struct RClass*\nmrb_module_get_under_id(mrb_state *mrb, struct RClass *outer, mrb_sym name)\n{\n  return module_from_sym(mrb, outer, name);\n}\n\nMRB_API struct RClass*\nmrb_module_get(mrb_state *mrb, const char *name)\n{\n  return mrb_module_get_under(mrb, mrb->object_class, name);\n}\n\nMRB_API struct RClass*\nmrb_module_get_id(mrb_state *mrb, mrb_sym name)\n{\n  return mrb_module_get_under_id(mrb, mrb->object_class, name);\n}\n\n/*!\n * Defines a class under the namespace of \\a outer.\n * \\param outer  a class which contains the new class.\n * \\param name     name of the new class\n * \\param super  a class from which the new class will derive.\n *               NULL means \\c Object class.\n * \\return the created class\n * \\throw TypeError if the constant name \\a name is already taken but\n *                  the constant is not a \\c Class.\n * \\throw NameError if the class is already defined but the class can not\n *                  be reopened because its superclass is not \\a super.\n * \\post top-level constant named \\a name refers the returned class.\n *\n * \\note if a class named \\a name is already defined and its superclass is\n *       \\a super, the function just returns the defined class.\n */\nMRB_API struct RClass*\nmrb_define_class_under_id(mrb_state *mrb, struct RClass *outer, mrb_sym name, struct RClass *super)\n{\n  struct RClass * c;\n\n#if 0\n  if (!super) {\n    mrb_warn(mrb, \"no super class for '%C::%n', Object assumed\", outer, id);\n  }\n#endif\n  c = define_class(mrb, name, super, outer);\n  setup_class(mrb, outer, c, name);\n  return c;\n}\n\nMRB_API struct RClass*\nmrb_define_class_under(mrb_state *mrb, struct RClass *outer, const char *name, struct RClass *super)\n{\n  return mrb_define_class_under_id(mrb, outer, mrb_intern_cstr(mrb, name), super);\n}\n\nMRB_API void\nmrb_define_method_raw(mrb_state *mrb, struct RClass *c, mrb_sym mid, mrb_method_t m)\n{\n  mt_tbl *h;\n  union mt_ptr ptr;\n\n  MRB_CLASS_ORIGIN(c);\n  h = c->mt;\n  mrb_check_frozen(mrb, c);\n  if (!h) h = c->mt = mt_new(mrb);\n  if (MRB_METHOD_PROC_P(m)) {\n    struct RProc *p = MRB_METHOD_PROC(m);\n\n    ptr.proc = p;\n    if (p) {\n      if (p->color != MRB_GC_RED) {\n        p->flags |= MRB_PROC_SCOPE;\n        p->c = NULL;\n        mrb_field_write_barrier(mrb, (struct RBasic*)c, (struct RBasic*)p);\n        if (!MRB_PROC_ENV_P(p)) {\n          MRB_PROC_SET_TARGET_CLASS(p, c);\n        }\n      }\n      else {\n        mrb_assert(MRB_FROZEN_P(p) && MRB_PROC_SCOPE_P(p));\n        mrb_assert(p->c == NULL && p->upper == NULL && p->e.target_class == NULL);\n      }\n    }\n  }\n  else {\n    ptr.func = MRB_METHOD_FUNC(m);\n  }\n  mt_put(mrb, h, mid, MT_FLAGS(MRB_METHOD_FUNC_P(m), MRB_METHOD_NOARG_P(m)), ptr);\n  mc_clear(mrb);\n}\n\nMRB_API void\nmrb_define_method_id(mrb_state *mrb, struct RClass *c, mrb_sym mid, mrb_func_t func, mrb_aspec aspec)\n{\n  mrb_method_t m;\n  int ai = mrb_gc_arena_save(mrb);\n\n  MRB_METHOD_FROM_FUNC(m, func);\n#ifndef MRB_USE_METHOD_T_STRUCT\n  mrb_assert(MRB_METHOD_FUNC(m) == func);\n#endif\n  if (aspec == MRB_ARGS_NONE()) {\n    MRB_METHOD_NOARG_SET(m);\n  }\n  mrb_define_method_raw(mrb, c, mid, m);\n  mrb_gc_arena_restore(mrb, ai);\n}\n\nMRB_API void\nmrb_define_method(mrb_state *mrb, struct RClass *c, const char *name, mrb_func_t func, mrb_aspec aspec)\n{\n  mrb_define_method_id(mrb, c, mrb_intern_cstr(mrb, name), func, aspec);\n}\n\n/* a function to raise NotImplementedError with current method name */\nMRB_API void\nmrb_notimplement(mrb_state *mrb)\n{\n  mrb_callinfo *ci = mrb->c->ci;\n\n  if (ci->mid) {\n    mrb_raisef(mrb, E_NOTIMP_ERROR, \"%n() function is unimplemented on this machine\", ci->mid);\n  }\n}\n\n/* a function to be replacement of unimplemented method */\nMRB_API mrb_value\nmrb_notimplement_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_notimplement(mrb);\n  /* not reached */\n  return mrb_nil_value();\n}\n\nstatic void\nensure_class_type(mrb_state *mrb, mrb_value val)\n{\n  if (!class_ptr_p(val)) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"%v is not class/module\", val);\n  }\n}\n\n#define to_sym(mrb, ss) mrb_obj_to_sym(mrb, ss)\n\nMRB_API mrb_int\nmrb_get_argc(mrb_state *mrb)\n{\n  mrb_int argc = mrb->c->ci->n;\n\n  if (argc == 15) {\n    struct RArray *a = mrb_ary_ptr(mrb->c->ci->stack[1]);\n\n    argc = ARY_LEN(a);\n  }\n  return argc;\n}\n\nMRB_API const mrb_value*\nmrb_get_argv(mrb_state *mrb)\n{\n  mrb_int argc = mrb->c->ci->n;\n  mrb_value *array_argv = mrb->c->ci->stack + 1;\n  if (argc == 15) {\n    struct RArray *a = mrb_ary_ptr(*array_argv);\n\n    array_argv = ARY_PTR(a);\n  }\n  return array_argv;\n}\n\nMRB_API mrb_value\nmrb_get_arg1(mrb_state *mrb)\n{\n  mrb_callinfo *ci = mrb->c->ci;\n  mrb_int argc = ci->n;\n  mrb_value *array_argv = ci->stack + 1;\n  if (argc == 15) {\n    struct RArray *a = mrb_ary_ptr(*array_argv);\n\n    argc = ARY_LEN(a);\n    array_argv = ARY_PTR(a);\n  }\n  if (argc == 0 && ci->nk == 15) {\n    mrb_int n = ci->n;\n    if (n == 15) n = 1;\n    return ci->stack[n+1];      /* kwhash next to positional arguments */\n  }\n  if (argc != 1) {\n    mrb_argnum_error(mrb, argc, 1, 1);\n  }\n  return array_argv[0];\n}\n\nMRB_API mrb_bool\nmrb_block_given_p(mrb_state *mrb)\n{\n  mrb_callinfo *ci = mrb->c->ci;\n  mrb_value b = ci->stack[mrb_ci_bidx(ci)];\n\n  return !mrb_nil_p(b);\n}\n\n/*\n  retrieve arguments from mrb_state.\n\n  mrb_get_args(mrb, format, ...)\n\n  returns number of arguments parsed.\n\n  format specifiers:\n\n    string  mruby type     C type                 note\n    ----------------------------------------------------------------------------------------------\n    o:      Object         [mrb_value]\n    C:      Class/Module   [mrb_value]            when ! follows, the value may be nil\n    S:      String         [mrb_value]            when ! follows, the value may be nil\n    A:      Array          [mrb_value]            when ! follows, the value may be nil\n    H:      Hash           [mrb_value]            when ! follows, the value may be nil\n    s:      String         [const char*,mrb_int]  Receive two arguments; s! gives (NULL,0) for nil\n    z:      String         [const char*]          NUL terminated string; z! gives NULL for nil\n    a:      Array          [const mrb_value*,mrb_int] Receive two arguments; a! gives (NULL,0) for nil\n    c:      Class/Module   [strcut RClass*]       c! gives NULL for nil\n    f:      Integer/Float  [mrb_float]\n    i:      Integer/Float  [mrb_int]\n    b:      boolean        [mrb_bool]\n    n:      String/Symbol  [mrb_sym]\n    d:      data           [void*,mrb_data_type const] 2nd argument will be used to check data type so it won't be modified; when ! follows, the value may be nil\n    I:      inline struct  [void*,struct RClass]  I! gives NULL for nil\n    &:      block          [mrb_value]            &! raises exception if no block given\n    *:      rest argument  [const mrb_value*,mrb_int] The rest of the arguments as an array; *! avoid copy of the stack\n    |:      optional                              Following arguments are optional\n    ?:      optional given [mrb_bool]             true if preceding argument (optional) is given\n    ':':    keyword args   [mrb_kwargs const]     Get keyword arguments\n\n  format modifiers:\n\n    string  note\n    ----------------------------------------------------------------------------------------------\n    !:      Switch to the alternate mode; The behaviour changes depending on the specifier\n    +:      Request a not frozen object; However, except nil value\n */\nMRB_API mrb_int\nmrb_get_args(mrb_state *mrb, const char *format, ...)\n{\n  const char *fmt = format;\n  char c;\n  int i = 0;\n  va_list ap;\n  mrb_callinfo *ci = mrb->c->ci;\n  int argc = ci->n;\n  const mrb_value *argv = ci->stack+1;\n  mrb_bool argv_on_stack;\n  mrb_bool opt = FALSE;\n  mrb_bool opt_skip = TRUE;\n  const mrb_value *pickarg = NULL; /* arguments currently being processed */\n  mrb_value kdict = mrb_nil_value();\n  mrb_bool reqkarg = FALSE;\n  int argc_min = 0, argc_max = 0;\n\n  va_start(ap, format);\n\n  while ((c = *fmt++)) {\n    switch (c) {\n    case '|':\n      opt = TRUE;\n      break;\n    case '*':\n      opt_skip = FALSE;\n      argc_max = -1;\n      if (!reqkarg) reqkarg = strchr(fmt, ':') ? TRUE : FALSE;\n      goto check_exit;\n    case '!':\n    case '+':\n      break;\n    case ':':\n      reqkarg = TRUE;\n      /* fall through */\n    case '&': case '?':\n      if (opt) opt_skip = FALSE;\n      break;\n    default:\n      if (!opt) argc_min++;\n      argc_max++;\n      break;\n    }\n  }\n\n check_exit:\n  if (!reqkarg && ci->nk > 0) {\n    mrb_assert(ci->nk == 15);\n    kdict = ci->stack[mrb_ci_bidx(ci)-1];\n    if (mrb_hash_p(kdict) && mrb_hash_size(mrb, kdict) > 0) {\n      if (argc < 14) {\n        ci->n++;\n        argc++;    /* include kdict in normal arguments */\n      }\n      else {\n        /* 14+1 == 15 so pack first */\n        if (argc == 14) {\n          /* pack arguments and kdict */\n          ci->stack[1] = mrb_ary_new_from_values(mrb, argc+1, &ci->stack[1]);\n          argc = ci->n = 15;\n        }\n        else {\n          /* push kdict to packed arguments */\n          mrb_ary_push(mrb, ci->stack[1], kdict);\n        }\n        ci->stack[2] = ci->stack[mrb_ci_bidx(ci)];\n      }\n      ci->nk = 0;\n    }\n  }\n  if (reqkarg && ci->nk > 0) {\n    kdict = ci->stack[mrb_ci_bidx(ci)-1];\n    mrb_assert(ci->nk == 15);\n    mrb_assert(mrb_hash_p(kdict));\n  }\n\n  argv_on_stack = argc < 15;\n  if (!argv_on_stack) {\n    struct RArray *a = mrb_ary_ptr(*argv);\n    argv = ARY_PTR(a);\n    argc = ARY_LEN(a);\n  }\n\n  opt = FALSE;\n  i = 0;\n  while ((c = *format++)) {\n    mrb_bool altmode = FALSE;\n    mrb_bool needmodify = FALSE;\n\n    for (; *format; format++) {\n      switch (*format) {\n      case '!':\n        if (altmode) goto modifier_exit; /* not accept for multiple '!' */\n        altmode = TRUE;\n        break;\n      case '+':\n        if (needmodify) goto modifier_exit; /* not accept for multiple '+' */\n        needmodify = TRUE;\n        break;\n      default:\n        goto modifier_exit;\n      }\n    }\n\n  modifier_exit:\n    switch (c) {\n    case '|': case '*': case '&': case '?': case ':':\n      if (needmodify) {\n      bad_needmodify:\n        mrb_raisef(mrb, E_ARGUMENT_ERROR, \"wrong `%c+` modified specifier`\", c);\n      }\n      break;\n    default:\n      if (i < argc) {\n        pickarg = &argv[i++];\n        if (needmodify && !mrb_nil_p(*pickarg)) {\n          if (mrb_immediate_p(*pickarg)) {\n            mrb_raisef(mrb, E_FROZEN_ERROR, \"can't modify frozen %t\", *pickarg);\n          }\n          mrb_check_frozen(mrb, mrb_obj_ptr(*pickarg));\n        }\n      }\n      else {\n        if (opt) {\n          pickarg = NULL;\n        }\n        else {\n          mrb_argnum_error(mrb, argc, argc_min, argc_max);\n        }\n      }\n      break;\n    }\n\n    switch (c) {\n    case 'o':\n    case 'C':\n    case 'S':\n    case 'A':\n    case 'H':\n      {\n        mrb_value *p;\n\n        p = va_arg(ap, mrb_value*);\n        if (pickarg) {\n          if (!(altmode && mrb_nil_p(*pickarg))) {\n            switch (c) {\n            case 'C': ensure_class_type(mrb, *pickarg); break;\n            case 'S': mrb_ensure_string_type(mrb, *pickarg); break;\n            case 'A': mrb_ensure_array_type(mrb, *pickarg); break;\n            case 'H': mrb_ensure_hash_type(mrb, *pickarg); break;\n            }\n          }\n          *p = *pickarg;\n        }\n      }\n      break;\n    case 'c':\n      {\n        struct RClass **p;\n\n        p = va_arg(ap, struct RClass**);\n        if (pickarg) {\n          if (altmode && mrb_nil_p(*pickarg)) {\n            *p = NULL;\n          }\n          else {\n            ensure_class_type(mrb, *pickarg);\n            *p = mrb_class_ptr(*pickarg);\n          }\n        }\n      }\n      break;\n    case 's':\n      {\n        const char **ps = 0;\n        mrb_int *pl = 0;\n\n        ps = va_arg(ap, const char**);\n        pl = va_arg(ap, mrb_int*);\n        if (needmodify) goto bad_needmodify;\n        if (pickarg) {\n          if (altmode && mrb_nil_p(*pickarg)) {\n            *ps = NULL;\n            *pl = 0;\n          }\n          else {\n            mrb_ensure_string_type(mrb, *pickarg);\n            *ps = RSTRING_PTR(*pickarg);\n            *pl = RSTRING_LEN(*pickarg);\n          }\n        }\n      }\n      break;\n    case 'z':\n      {\n        const char **ps;\n\n        ps = va_arg(ap, const char**);\n        if (needmodify) goto bad_needmodify;\n        if (pickarg) {\n          if (altmode && mrb_nil_p(*pickarg)) {\n            *ps = NULL;\n          }\n          else {\n            mrb_ensure_string_type(mrb, *pickarg);\n            *ps = RSTRING_CSTR(mrb, *pickarg);\n          }\n        }\n      }\n      break;\n    case 'a':\n      {\n        struct RArray *a;\n        const mrb_value **pb;\n        mrb_int *pl;\n\n        pb = va_arg(ap, const mrb_value**);\n        pl = va_arg(ap, mrb_int*);\n        if (needmodify) goto bad_needmodify;\n        if (pickarg) {\n          if (altmode && mrb_nil_p(*pickarg)) {\n            *pb = 0;\n            *pl = 0;\n          }\n          else {\n            mrb_ensure_array_type(mrb, *pickarg);\n            a = mrb_ary_ptr(*pickarg);\n            *pb = ARY_PTR(a);\n            *pl = ARY_LEN(a);\n          }\n        }\n      }\n      break;\n    case 'I':\n      {\n        void* *p;\n        struct RClass *klass;\n\n        p = va_arg(ap, void**);\n        klass = va_arg(ap, struct RClass*);\n        if (pickarg) {\n          if (altmode && mrb_nil_p(*pickarg)) {\n            *p = NULL;\n          }\n          else {\n            if (!mrb_obj_is_kind_of(mrb, *pickarg, klass)) {\n              mrb_raisef(mrb, E_TYPE_ERROR, \"%v is not a %C\", *pickarg, klass);\n            }\n            if (!mrb_istruct_p(*pickarg)) {\n              mrb_raisef(mrb, E_TYPE_ERROR, \"%v is not inline struct\", *pickarg);\n            }\n            *p = mrb_istruct_ptr(*pickarg);\n          }\n        }\n      }\n      break;\n#ifndef MRB_NO_FLOAT\n    case 'f':\n      {\n        mrb_float *p;\n\n        p = va_arg(ap, mrb_float*);\n        if (pickarg) {\n          *p = mrb_as_float(mrb, *pickarg);\n        }\n      }\n      break;\n#endif\n    case 'i':\n      {\n        mrb_int *p;\n\n        p = va_arg(ap, mrb_int*);\n        if (pickarg) {\n          *p = mrb_as_int(mrb, *pickarg);\n        }\n      }\n      break;\n    case 'b':\n      {\n        mrb_bool *boolp = va_arg(ap, mrb_bool*);\n\n        if (pickarg) {\n          *boolp = mrb_test(*pickarg);\n        }\n      }\n      break;\n    case 'n':\n      {\n        mrb_sym *symp;\n\n        symp = va_arg(ap, mrb_sym*);\n        if (pickarg) {\n          *symp = to_sym(mrb, *pickarg);\n        }\n      }\n      break;\n    case 'd':\n      {\n        void** datap;\n        struct mrb_data_type const* type;\n\n        datap = va_arg(ap, void**);\n        type = va_arg(ap, struct mrb_data_type const*);\n        if (pickarg) {\n          if (altmode && mrb_nil_p(*pickarg)) {\n            *datap = 0;\n          }\n          else {\n            *datap = mrb_data_get_ptr(mrb, *pickarg, type);\n          }\n        }\n      }\n      break;\n\n    case '&':\n      {\n        mrb_value *p, *bp;\n\n        p = va_arg(ap, mrb_value*);\n        bp = ci->stack + mrb_ci_bidx(ci);\n        if (altmode && mrb_nil_p(*bp)) {\n          mrb_raise(mrb, E_ARGUMENT_ERROR, \"no block given\");\n        }\n        *p = *bp;\n      }\n      break;\n    case '|':\n      if (opt_skip && i == argc) goto finish;\n      opt = TRUE;\n      break;\n    case '?':\n      {\n        mrb_bool *p;\n\n        p = va_arg(ap, mrb_bool*);\n        *p = pickarg ? TRUE : FALSE;\n      }\n      break;\n\n    case '*':\n      {\n        const mrb_value **var;\n        mrb_int *pl;\n        mrb_bool nocopy = (altmode || !argv_on_stack) ? TRUE : FALSE;\n\n        var = va_arg(ap, const mrb_value**);\n        pl = va_arg(ap, mrb_int*);\n        if (argc > i) {\n          *pl = argc-i;\n          if (*pl > 0) {\n            if (nocopy) {\n              *var = argv+i;\n            }\n            else {\n              mrb_value args = mrb_ary_new_from_values(mrb, *pl, argv+i);\n              RARRAY(args)->c = NULL;\n              *var = RARRAY_PTR(args);\n            }\n          }\n          i = argc;\n        }\n        else {\n          *pl = 0;\n          *var = NULL;\n        }\n      }\n      break;\n\n    case ':':\n      {\n        mrb_value ksrc = mrb_hash_p(kdict) ? mrb_hash_dup(mrb, kdict) : mrb_hash_new(mrb);\n        const mrb_kwargs *kwargs = va_arg(ap, const mrb_kwargs*);\n        mrb_value *rest;\n\n        if (kwargs == NULL) {\n          rest = NULL;\n        }\n        else {\n          uint32_t kwnum = kwargs->num;\n          uint32_t required = kwargs->required;\n          const mrb_sym *kname = kwargs->table;\n          mrb_value *values = kwargs->values;\n          uint32_t j;\n          const uint32_t keyword_max = 40;\n\n          if (kwnum > keyword_max || required > kwnum) {\n            mrb_raise(mrb, E_ARGUMENT_ERROR, \"keyword number is too large\");\n          }\n\n          for (j = required; j > 0; j--, kname++, values++) {\n            mrb_value k = mrb_symbol_value(*kname);\n            if (!mrb_hash_key_p(mrb, ksrc, k)) {\n              mrb_raisef(mrb, E_ARGUMENT_ERROR, \"missing keyword: %n\", *kname);\n            }\n            *values = mrb_hash_delete_key(mrb, ksrc, k);\n            mrb_gc_protect(mrb, *values);\n          }\n\n          for (j = kwnum - required; j > 0; j--, kname++, values++) {\n            mrb_value k = mrb_symbol_value(*kname);\n            if (mrb_hash_key_p(mrb, ksrc, k)) {\n              *values = mrb_hash_delete_key(mrb, ksrc, k);\n              mrb_gc_protect(mrb, *values);\n            }\n            else {\n              *values = mrb_undef_value();\n            }\n          }\n\n          rest = kwargs->rest;\n        }\n\n        if (rest) {\n          *rest = ksrc;\n        }\n        else if (!mrb_hash_empty_p(mrb, ksrc)) {\n          ksrc = mrb_hash_keys(mrb, ksrc);\n          ksrc = RARRAY_PTR(ksrc)[0];\n          mrb_raisef(mrb, E_ARGUMENT_ERROR, \"unknown keyword: %v\", ksrc);\n        }\n      }\n      break;\n\n    default:\n      mrb_raisef(mrb, E_ARGUMENT_ERROR, \"invalid argument specifier %c\", c);\n      break;\n    }\n  }\n\n  if (!c && argc > i) {\n    mrb_argnum_error(mrb, argc, argc_min, argc_max);\n  }\n\nfinish:\n  va_end(ap);\n  return i;\n}\n\nstatic struct RClass*\nboot_defclass(mrb_state *mrb, struct RClass *super)\n{\n  struct RClass *c;\n\n  c = MRB_OBJ_ALLOC(mrb, MRB_TT_CLASS, mrb->class_class);\n  if (super) {\n    c->super = super;\n    mrb_field_write_barrier(mrb, (struct RBasic*)c, (struct RBasic*)super);\n    c->flags |= MRB_FL_CLASS_IS_INHERITED;\n  }\n  else {\n    c->super = mrb->object_class;\n  }\n  c->mt = mt_new(mrb);\n  return c;\n}\n\nstatic void\nboot_initmod(mrb_state *mrb, struct RClass *mod)\n{\n  if (!mod->mt) {\n    mod->mt = mt_new(mrb);\n  }\n}\n\nstatic struct RClass*\ninclude_class_new(mrb_state *mrb, struct RClass *m, struct RClass *super)\n{\n  struct RClass *ic = MRB_OBJ_ALLOC(mrb, MRB_TT_ICLASS, mrb->class_class);\n  if (m->tt == MRB_TT_ICLASS) {\n    m = m->c;\n  }\n  MRB_CLASS_ORIGIN(m);\n  ic->iv = m->iv;\n  ic->mt = m->mt;\n  ic->super = super;\n  if (m->tt == MRB_TT_ICLASS) {\n    ic->c = m->c;\n  }\n  else {\n    ic->c = m;\n  }\n  return ic;\n}\n\nstatic int\ninclude_module_at(mrb_state *mrb, struct RClass *c, struct RClass *ins_pos, struct RClass *m, int search_super)\n{\n  struct RClass *p, *ic;\n  void *klass_mt = find_origin(c)->mt;\n\n  while (m) {\n    int original_seen = FALSE;\n    int superclass_seen = FALSE;\n\n    if (c == ins_pos) original_seen = TRUE;\n    if (m->flags & MRB_FL_CLASS_IS_PREPENDED)\n      goto skip;\n\n    if (klass_mt && klass_mt == m->mt)\n      return -1;\n\n    p = c->super;\n    while (p) {\n      if (c == p) original_seen = TRUE;\n      if (p->tt == MRB_TT_ICLASS) {\n        if (p->mt == m->mt) {\n          if (!superclass_seen && original_seen) {\n            ins_pos = p; /* move insert point */\n          }\n          goto skip;\n        }\n      } else if (p->tt == MRB_TT_CLASS) {\n        if (!search_super) break;\n        superclass_seen = TRUE;\n      }\n      p = p->super;\n    }\n\n    ic = include_class_new(mrb, m, ins_pos->super);\n    m->flags |= MRB_FL_CLASS_IS_INHERITED;\n    ins_pos->super = ic;\n    mrb_field_write_barrier(mrb, (struct RBasic*)ins_pos, (struct RBasic*)ic);\n    ins_pos = ic;\n  skip:\n    m = m->super;\n  }\n  mc_clear(mrb);\n  return 0;\n}\n\nstatic int\nfix_include_module(mrb_state *mrb, struct RBasic *obj, void *data)\n{\n  struct RClass **m = (struct RClass**)data;\n\n  if (obj->tt == MRB_TT_ICLASS && obj->c == m[0] && !MRB_FLAG_TEST(obj, MRB_FL_CLASS_IS_ORIGIN)) {\n    struct RClass *ic = (struct RClass*)obj;\n    include_module_at(mrb, ic, ic, m[1], 1);\n  }\n  return MRB_EACH_OBJ_OK;\n}\n\nMRB_API void\nmrb_include_module(mrb_state *mrb, struct RClass *c, struct RClass *m)\n{\n  mrb_check_frozen(mrb, c);\n  if (include_module_at(mrb, c, find_origin(c), m, 1) < 0) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"cyclic include detected\");\n  }\n  if (c->tt == MRB_TT_MODULE && (c->flags & MRB_FL_CLASS_IS_INHERITED)) {\n    struct RClass *data[2];\n    data[0] = c;\n    data[1] = m;\n    mrb_objspace_each_objects(mrb, fix_include_module, data);\n  }\n}\n\nstatic int\nfix_prepend_module(mrb_state *mrb, struct RBasic *obj, void *data)\n{\n  struct RClass **m = (struct RClass**)data;\n  struct RClass *c = (struct RClass*)obj;\n\n  if (c->tt == MRB_TT_CLASS || c->tt == MRB_TT_MODULE) {\n    struct RClass *p = c->super;\n    struct RClass *ins_pos = c;\n    while (p) {\n      if (c == m[0]) break;\n      if (p == m[0]->super->c) {\n        ins_pos = c;\n      }\n      if (p->tt == MRB_TT_CLASS) break;\n      if (p->c == m[0]) {\n        include_module_at(mrb, ins_pos, ins_pos, m[1], 0);\n        break;\n      }\n      c = p;\n      p = p->super;\n    }\n  }\n  return MRB_EACH_OBJ_OK;\n}\n\nMRB_API void\nmrb_prepend_module(mrb_state *mrb, struct RClass *c, struct RClass *m)\n{\n  struct RClass *origin;\n\n  mrb_check_frozen(mrb, c);\n  if (!(c->flags & MRB_FL_CLASS_IS_PREPENDED)) {\n    struct RClass *c0;\n\n    if (c->tt == MRB_TT_ICLASS) {\n      c0 = c->c;\n    }\n    else {\n      c0 = c;\n    }\n    origin = MRB_OBJ_ALLOC(mrb, MRB_TT_ICLASS, c0);\n    origin->flags |= MRB_FL_CLASS_IS_ORIGIN | MRB_FL_CLASS_IS_INHERITED;\n    origin->super = c->super;\n    c->super = origin;\n    origin->mt = c->mt;\n    c->mt = NULL;\n    origin->iv = c->iv;\n    mrb_field_write_barrier(mrb, (struct RBasic*)c, (struct RBasic*)origin);\n    c->flags |= MRB_FL_CLASS_IS_PREPENDED;\n  }\n  if (include_module_at(mrb, c, c, m, 0) < 0) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"cyclic prepend detected\");\n  }\n  if (c->tt == MRB_TT_MODULE &&\n      (c->flags & (MRB_FL_CLASS_IS_INHERITED|MRB_FL_CLASS_IS_PREPENDED))) {\n    struct RClass *data[2];\n    data[0] = c;\n    data[1] = m;\n    mrb_objspace_each_objects(mrb, fix_prepend_module, data);\n  }\n}\n\nstatic mrb_value\nmrb_mod_prepend_features(mrb_state *mrb, mrb_value mod)\n{\n  struct RClass *c;\n\n  mrb_check_type(mrb, mod, MRB_TT_MODULE);\n  mrb_get_args(mrb, \"c\", &c);\n  mrb_prepend_module(mrb, c, mrb_class_ptr(mod));\n  return mod;\n}\n\nstatic mrb_value\nmrb_mod_append_features(mrb_state *mrb, mrb_value mod)\n{\n  struct RClass *c;\n\n  mrb_check_type(mrb, mod, MRB_TT_MODULE);\n  mrb_get_args(mrb, \"c\", &c);\n  mrb_include_module(mrb, c, mrb_class_ptr(mod));\n  return mod;\n}\n\n/* 15.2.2.4.28 */\n/*\n *  call-seq:\n *     mod.include?(module)    -> true or false\n *\n *  Returns <code>true</code> if <i>module</i> is included in\n *  <i>mod</i> or one of <i>mod</i>'s ancestors.\n *\n *     module A\n *     end\n *     class B\n *       include A\n *     end\n *     class C < B\n *     end\n *     B.include?(A)   #=> true\n *     C.include?(A)   #=> true\n *     A.include?(A)   #=> false\n */\nstatic mrb_value\nmrb_mod_include_p(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value mod2;\n  struct RClass *c = mrb_class_ptr(mod);\n\n  mrb_get_args(mrb, \"C\", &mod2);\n  mrb_check_type(mrb, mod2, MRB_TT_MODULE);\n\n  while (c) {\n    if (c->tt == MRB_TT_ICLASS) {\n      if (c->c == mrb_class_ptr(mod2)) return mrb_true_value();\n    }\n    c = c->super;\n  }\n  return mrb_false_value();\n}\n\nstatic mrb_value\nmrb_mod_ancestors(mrb_state *mrb, mrb_value self)\n{\n  mrb_value result;\n  struct RClass *c = mrb_class_ptr(self);\n  result = mrb_ary_new(mrb);\n  while (c) {\n    if (c->tt == MRB_TT_ICLASS) {\n      mrb_ary_push(mrb, result, mrb_obj_value(c->c));\n    }\n    else if (!(c->flags & MRB_FL_CLASS_IS_PREPENDED)) {\n      mrb_ary_push(mrb, result, mrb_obj_value(c));\n    }\n    c = c->super;\n  }\n\n  return result;\n}\n\nstatic mrb_value\nmrb_mod_extend_object(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value obj = mrb_get_arg1(mrb);\n\n  mrb_check_type(mrb, mod, MRB_TT_MODULE);\n  mrb_include_module(mrb, mrb_class_ptr(mrb_singleton_class(mrb, obj)), mrb_class_ptr(mod));\n  return mod;\n}\n\nstatic mrb_value\nmrb_mod_initialize(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value b;\n  struct RClass *m = mrb_class_ptr(mod);\n  boot_initmod(mrb, m); /* bootstrap a newly initialized module */\n  mrb_get_args(mrb, \"|&\", &b);\n  if (!mrb_nil_p(b)) {\n    mrb_yield_with_class(mrb, b, 1, &mod, mod, m);\n  }\n  return mod;\n}\n\n/* implementation of module_eval/class_eval */\nmrb_value mrb_mod_module_eval(mrb_state*, mrb_value);\n\nstatic mrb_value\nmrb_mod_dummy_visibility(mrb_state *mrb, mrb_value mod)\n{\n  return mod;\n}\n\n/* returns mrb_class_ptr(mrb_singleton_class()) */\n/* except that it return NULL for immediate values */\nMRB_API struct RClass*\nmrb_singleton_class_ptr(mrb_state *mrb, mrb_value v)\n{\n  struct RBasic *obj;\n\n  switch (mrb_type(v)) {\n  case MRB_TT_FALSE:\n    if (mrb_nil_p(v))\n      return mrb->nil_class;\n    return mrb->false_class;\n  case MRB_TT_TRUE:\n    return mrb->true_class;\n  case MRB_TT_CPTR:\n  case MRB_TT_SYMBOL:\n  case MRB_TT_INTEGER:\n#ifndef MRB_NO_FLOAT\n  case MRB_TT_FLOAT:\n#endif\n    return NULL;\n  default:\n    break;\n  }\n  obj = mrb_basic_ptr(v);\n  if (obj->c == NULL) return NULL;\n  prepare_singleton_class(mrb, obj);\n  return obj->c;\n}\n\nMRB_API mrb_value\nmrb_singleton_class(mrb_state *mrb, mrb_value v)\n{\n  struct RClass *c = mrb_singleton_class_ptr(mrb, v);\n\n  if (c == NULL) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't define singleton\");\n  }\n  return mrb_obj_value(c);\n}\n\nMRB_API void\nmrb_define_singleton_method(mrb_state *mrb, struct RObject *o, const char *name, mrb_func_t func, mrb_aspec aspec)\n{\n  prepare_singleton_class(mrb, (struct RBasic*)o);\n  mrb_define_method_id(mrb, o->c, mrb_intern_cstr(mrb, name), func, aspec);\n}\n\nMRB_API void\nmrb_define_singleton_method_id(mrb_state *mrb, struct RObject *o, mrb_sym name, mrb_func_t func, mrb_aspec aspec)\n{\n  prepare_singleton_class(mrb, (struct RBasic*)o);\n  mrb_define_method_id(mrb, o->c, name, func, aspec);\n}\n\nMRB_API void\nmrb_define_class_method(mrb_state *mrb, struct RClass *c, const char *name, mrb_func_t func, mrb_aspec aspec)\n{\n  mrb_define_singleton_method(mrb, (struct RObject*)c, name, func, aspec);\n}\n\nMRB_API void\nmrb_define_class_method_id(mrb_state *mrb, struct RClass *c, mrb_sym name, mrb_func_t func, mrb_aspec aspec)\n{\n  mrb_define_singleton_method_id(mrb, (struct RObject*)c, name, func, aspec);\n}\n\nMRB_API void\nmrb_define_module_function_id(mrb_state *mrb, struct RClass *c, mrb_sym name, mrb_func_t func, mrb_aspec aspec)\n{\n  mrb_define_class_method_id(mrb, c, name, func, aspec);\n  mrb_define_method_id(mrb, c, name, func, aspec);\n}\n\nMRB_API void\nmrb_define_module_function(mrb_state *mrb, struct RClass *c, const char *name, mrb_func_t func, mrb_aspec aspec)\n{\n  mrb_define_module_function_id(mrb, c, mrb_intern_cstr(mrb, name), func, aspec);\n}\n\n#ifndef MRB_NO_METHOD_CACHE\nstatic void\nmc_clear(mrb_state *mrb)\n{\n  static const struct mrb_cache_entry ce_zero ={0};\n\n  for (int i=0; i<MRB_METHOD_CACHE_SIZE; i++) {\n    mrb->cache[i] = ce_zero;\n  }\n}\n\nvoid\nmrb_mc_clear_by_class(mrb_state *mrb, struct RClass *c)\n{\n  struct mrb_cache_entry *mc = mrb->cache;\n  int i;\n\n  if (c->flags & MRB_FL_CLASS_IS_INHERITED) {\n    mc_clear(mrb);\n    return;\n  }\n  for (i=0; i<MRB_METHOD_CACHE_SIZE; i++) {\n    if (mc[i].c == c) mc[i].c = 0;\n  }\n}\n#endif\n\nMRB_API mrb_method_t\nmrb_method_search_vm(mrb_state *mrb, struct RClass **cp, mrb_sym mid)\n{\n  mrb_method_t m;\n  struct RClass *c = *cp;\n#ifndef MRB_NO_METHOD_CACHE\n  struct RClass *oc = c;\n  int h = kh_int_hash_func(mrb, ((intptr_t)oc) ^ mid) & (MRB_METHOD_CACHE_SIZE-1);\n  struct mrb_cache_entry *mc = &mrb->cache[h];\n\n  if (mc->c == c && mc->mid == mid) {\n    *cp = mc->c0;\n    return mc->m;\n  }\n#endif\n\n  while (c) {\n    mt_tbl *h = c->mt;\n\n    if (h) {\n      union mt_ptr ptr;\n      mrb_sym ret = mt_get(mrb, h, mid, &ptr);\n      if (ret) {\n        if (ptr.proc == 0) break;\n        *cp = c;\n        if (ret & MT_FUNC_P) {\n          MRB_METHOD_FROM_FUNC(m, ptr.func);\n        }\n        else {\n          MRB_METHOD_FROM_PROC(m, ptr.proc);\n        }\n        if (ret & MT_NOARG_P) {\n          MRB_METHOD_NOARG_SET(m);\n        }\n#ifndef MRB_NO_METHOD_CACHE\n        mc->c = oc;\n        mc->c0 = c;\n        mc->mid = mid;\n        mc->m = m;\n#endif\n        return m;\n      }\n    }\n    c = c->super;\n  }\n  MRB_METHOD_FROM_PROC(m, NULL);\n  return m;                  /* no method */\n}\n\nMRB_API mrb_method_t\nmrb_method_search(mrb_state *mrb, struct RClass* c, mrb_sym mid)\n{\n  mrb_method_t m;\n\n  m = mrb_method_search_vm(mrb, &c, mid);\n  if (MRB_METHOD_UNDEF_P(m)) {\n    mrb_name_error(mrb, mid, \"undefined method '%n' for class %C\", mid, c);\n  }\n  return m;\n}\n\n#define ONSTACK_ALLOC_MAX 32\n\nstatic mrb_sym\nprepare_name_common(mrb_state *mrb, mrb_sym sym, const char *prefix, const char *suffix)\n{\n  char onstack[ONSTACK_ALLOC_MAX];\n  mrb_int sym_len;\n  const char *sym_str = mrb_sym_name_len(mrb, sym, &sym_len);\n  size_t prefix_len = prefix ? strlen(prefix) : 0;\n  size_t suffix_len = suffix ? strlen(suffix) : 0;\n  size_t name_len = sym_len + prefix_len + suffix_len;\n  char *buf = name_len > sizeof(onstack) ? (char *)mrb_alloca(mrb, name_len) : onstack;\n  char *p = buf;\n\n  if (prefix_len > 0) {\n    memcpy(p, prefix, prefix_len);\n    p += prefix_len;\n  }\n\n  memcpy(p, sym_str, sym_len);\n  p += sym_len;\n\n  if (suffix_len > 0) {\n    memcpy(p, suffix, suffix_len);\n    p += suffix_len;\n  }\n\n  return mrb_intern(mrb, buf, name_len);\n}\n\nstatic mrb_value\nprepare_ivar_name(mrb_state *mrb, mrb_sym sym)\n{\n  sym = prepare_name_common(mrb, sym, \"@\", NULL);\n  mrb_iv_name_sym_check(mrb, sym);\n  return mrb_symbol_value(sym);\n}\n\nstatic mrb_sym\nprepare_writer_name(mrb_state *mrb, mrb_sym sym)\n{\n  return prepare_name_common(mrb, sym, NULL, \"=\");\n}\n\nstatic mrb_value\nmod_attr_define(mrb_state *mrb, mrb_value mod, mrb_value (*accessor)(mrb_state *, mrb_value), mrb_sym (*access_name)(mrb_state *, mrb_sym))\n{\n  struct RClass *c = mrb_class_ptr(mod);\n  const mrb_value *argv;\n  mrb_int argc, i;\n  int ai;\n\n  mrb_get_args(mrb, \"*\", &argv, &argc);\n  ai = mrb_gc_arena_save(mrb);\n  for (i=0; i<argc; i++) {\n    mrb_value name;\n    mrb_sym method;\n    struct RProc *p;\n    mrb_method_t m;\n\n    method = to_sym(mrb, argv[i]);\n    name = prepare_ivar_name(mrb, method);\n    if (access_name) {\n      method = access_name(mrb, method);\n    }\n\n    p = mrb_proc_new_cfunc_with_env(mrb, accessor, 1, &name);\n    MRB_METHOD_FROM_PROC(m, p);\n    mrb_define_method_raw(mrb, c, method, m);\n    mrb_gc_arena_restore(mrb, ai);\n  }\n  return mrb_nil_value();\n}\n\nstatic mrb_value\nattr_reader(mrb_state *mrb, mrb_value obj)\n{\n  mrb_value name = mrb_proc_cfunc_env_get(mrb, 0);\n  return mrb_iv_get(mrb, obj, to_sym(mrb, name));\n}\n\nstatic mrb_value\nmrb_mod_attr_reader(mrb_state *mrb, mrb_value mod)\n{\n  return mod_attr_define(mrb, mod, attr_reader, NULL);\n}\n\nstatic mrb_value\nattr_writer(mrb_state *mrb, mrb_value obj)\n{\n  mrb_value name = mrb_proc_cfunc_env_get(mrb, 0);\n  mrb_value val = mrb_get_arg1(mrb);\n\n  mrb_iv_set(mrb, obj, to_sym(mrb, name), val);\n  return val;\n}\n\nstatic mrb_value\nmrb_mod_attr_writer(mrb_state *mrb, mrb_value mod)\n{\n  return mod_attr_define(mrb, mod, attr_writer, prepare_writer_name);\n}\n\nstatic mrb_value\nmrb_instance_alloc(mrb_state *mrb, mrb_value cv)\n{\n  struct RClass *c = mrb_class_ptr(cv);\n  struct RObject *o;\n  enum mrb_vtype ttype = MRB_INSTANCE_TT(c);\n\n  if (c->tt == MRB_TT_SCLASS)\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't create instance of singleton class\");\n\n  if (ttype == 0) ttype = MRB_TT_OBJECT;\n  if (ttype <= MRB_TT_CPTR) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"can't create instance of %v\", cv);\n  }\n  o = (struct RObject*)mrb_obj_alloc(mrb, ttype, c);\n  return mrb_obj_value(o);\n}\n\n/*\n *  call-seq:\n *     class.new(args, ...)    ->  obj\n *\n *  Creates a new object of <i>class</i>'s class, then\n *  invokes that object's <code>initialize</code> method,\n *  passing it <i>args</i>. This is the method that ends\n *  up getting called whenever an object is constructed using\n *  `.new`.\n *\n */\n\nmrb_value\nmrb_instance_new(mrb_state *mrb, mrb_value cv)\n{\n  mrb_value obj, blk;\n  const mrb_value *argv;\n  mrb_int argc;\n  mrb_sym init;\n\n  mrb_get_args(mrb, \"*!&\", &argv, &argc, &blk);\n  obj = mrb_instance_alloc(mrb, cv);\n  init = MRB_SYM(initialize);\n  if (!mrb_func_basic_p(mrb, obj, init, mrb_do_nothing)) {\n    mrb_funcall_with_block(mrb, obj, init, argc, argv, blk);\n  }\n  return obj;\n}\n\nMRB_API mrb_value\nmrb_obj_new(mrb_state *mrb, struct RClass *c, mrb_int argc, const mrb_value *argv)\n{\n  mrb_value obj;\n  mrb_sym mid;\n\n  obj = mrb_instance_alloc(mrb, mrb_obj_value(c));\n  mid = MRB_SYM(initialize);\n  if (!mrb_func_basic_p(mrb, obj, mid, mrb_do_nothing)) {\n    mrb_funcall_argv(mrb, obj, mid, argc, argv);\n  }\n  return obj;\n}\n\nstatic mrb_value\nmrb_class_initialize(mrb_state *mrb, mrb_value c)\n{\n  mrb_value a, b;\n\n  mrb_get_args(mrb, \"|C&\", &a, &b);\n  if (!mrb_nil_p(b)) {\n    mrb_yield_with_class(mrb, b, 1, &c, c, mrb_class_ptr(c));\n  }\n  return c;\n}\n\nstatic mrb_value\nmrb_class_new_class(mrb_state *mrb, mrb_value cv)\n{\n  mrb_int n;\n  mrb_value super, blk;\n  mrb_value new_class;\n  mrb_sym mid;\n\n  n = mrb_get_args(mrb, \"|C&\", &super, &blk);\n  if (n == 0) {\n    super = mrb_obj_value(mrb->object_class);\n  }\n  new_class = mrb_obj_value(mrb_class_new(mrb, mrb_class_ptr(super)));\n  mid = MRB_SYM(initialize);\n  if (mrb_func_basic_p(mrb, new_class, mid, mrb_class_initialize)) {\n    mrb_class_initialize(mrb, new_class);\n  }\n  else {\n    mrb_funcall_with_block(mrb, new_class, mid, n, &super, blk);\n  }\n  mrb_class_inherited(mrb, mrb_class_ptr(super), mrb_class_ptr(new_class));\n  return new_class;\n}\n\nstatic mrb_value\nmrb_class_superclass(mrb_state *mrb, mrb_value klass)\n{\n  struct RClass *c;\n\n  c = mrb_class_ptr(klass);\n  c = find_origin(c)->super;\n  while (c && c->tt == MRB_TT_ICLASS) {\n    c = find_origin(c)->super;\n  }\n  if (!c) return mrb_nil_value();\n  return mrb_obj_value(c);\n}\n\nstatic mrb_value\nmrb_do_nothing(mrb_state *mrb, mrb_value cv)\n{\n  return mrb_nil_value();\n}\n\nstatic mrb_value\nmrb_bob_not(mrb_state *mrb, mrb_value cv)\n{\n  return mrb_bool_value(!mrb_test(cv));\n}\n\n/* 15.3.1.3.1  */\n/* 15.3.1.3.10 */\n/* 15.3.1.3.11 */\n/*\n *  call-seq:\n *     obj == other        -> true or false\n *     obj.equal?(other)   -> true or false\n *     obj.eql?(other)     -> true or false\n *\n *  Equality---At the <code>Object</code> level, <code>==</code> returns\n *  <code>true</code> only if <i>obj</i> and <i>other</i> are the\n *  same object. Typically, this method is overridden in descendant\n *  classes to provide class-specific meaning.\n *\n *  Unlike <code>==</code>, the <code>equal?</code> method should never be\n *  overridden by subclasses: it is used to determine object identity\n *  (that is, <code>a.equal?(b)</code> iff <code>a</code> is the same\n *  object as <code>b</code>).\n *\n *  The <code>eql?</code> method returns <code>true</code> if\n *  <i>obj</i> and <i>anObject</i> have the same value. Used by\n *  <code>Hash</code> to test members for equality.  For objects of\n *  class <code>Object</code>, <code>eql?</code> is synonymous with\n *  <code>==</code>. Subclasses normally continue this tradition, but\n *  there are exceptions. <code>Numeric</code> types, for example,\n *  perform type conversion across <code>==</code>, but not across\n *  <code>eql?</code>, so:\n *\n *     1 == 1.0     #=> true\n *     1.eql? 1.0   #=> false\n */\nmrb_value\nmrb_obj_equal_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_value arg = mrb_get_arg1(mrb);\n\n  return mrb_bool_value(mrb_obj_equal(mrb, self, arg));\n}\n\nMRB_API mrb_bool\nmrb_obj_respond_to(mrb_state *mrb, struct RClass* c, mrb_sym mid)\n{\n  mrb_method_t m;\n\n  m = mrb_method_search_vm(mrb, &c, mid);\n  if (MRB_METHOD_UNDEF_P(m)) {\n    return FALSE;\n  }\n  return TRUE;\n}\n\nMRB_API mrb_bool\nmrb_respond_to(mrb_state *mrb, mrb_value obj, mrb_sym mid)\n{\n  return mrb_obj_respond_to(mrb, mrb_class(mrb, obj), mid);\n}\n\nMRB_API mrb_value\nmrb_class_path(mrb_state *mrb, struct RClass *c)\n{\n  mrb_value path;\n  mrb_sym nsym = MRB_SYM(__classname__);\n\n  path = mrb_obj_iv_get(mrb, (struct RObject*)c, nsym);\n  if (mrb_nil_p(path)) {\n    /* no name (yet) */\n    return mrb_class_find_path(mrb, c);\n  }\n  else if (mrb_symbol_p(path)) {\n    /* toplevel class/module */\n    return mrb_sym_str(mrb, mrb_symbol(path));\n  }\n  return mrb_str_dup(mrb, path);\n}\n\nMRB_API struct RClass*\nmrb_class_real(struct RClass* cl)\n{\n  if (cl == 0) return NULL;\n  while ((cl->tt == MRB_TT_SCLASS) || (cl->tt == MRB_TT_ICLASS)) {\n    cl = cl->super;\n    if (cl == 0) return NULL;\n  }\n  return cl;\n}\n\nMRB_API const char*\nmrb_class_name(mrb_state *mrb, struct RClass* c)\n{\n  mrb_value name;\n\n  if (c == NULL) return NULL;\n  name = class_name_str(mrb, c);\n  return RSTRING_PTR(name);\n}\n\nMRB_API const char*\nmrb_obj_classname(mrb_state *mrb, mrb_value obj)\n{\n  return mrb_class_name(mrb, mrb_obj_class(mrb, obj));\n}\n\n/*!\n * Ensures a class can be derived from super.\n *\n * \\param super a reference to an object.\n * \\exception TypeError if \\a super is not a Class or \\a super is a singleton class.\n */\nstatic void\nmrb_check_inheritable(mrb_state *mrb, struct RClass *super)\n{\n  if (super->tt != MRB_TT_CLASS) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"superclass must be a Class (%C given)\", super);\n  }\n  if (super->tt == MRB_TT_SCLASS) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't make subclass of singleton class\");\n  }\n  if (super == mrb->class_class) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't make subclass of Class\");\n  }\n}\n\n/*!\n * Creates a new class.\n * \\param super     a class from which the new class derives.\n * \\exception TypeError \\a super is not inheritable.\n * \\exception TypeError \\a super is the Class class.\n */\nMRB_API struct RClass*\nmrb_class_new(mrb_state *mrb, struct RClass *super)\n{\n  struct RClass *c;\n\n  if (super) {\n    mrb_check_inheritable(mrb, super);\n  }\n  c = boot_defclass(mrb, super);\n  if (super) {\n    MRB_SET_INSTANCE_TT(c, MRB_INSTANCE_TT(super));\n  }\n  make_metaclass(mrb, c);\n\n  return c;\n}\n\n/*!\n * Creates a new module.\n */\nMRB_API struct RClass*\nmrb_module_new(mrb_state *mrb)\n{\n  struct RClass *m = MRB_OBJ_ALLOC(mrb, MRB_TT_MODULE, mrb->module_class);\n  boot_initmod(mrb, m);\n  return m;\n}\n\n/*\n *  call-seq:\n *     obj.class    => class\n *\n *  Returns the class of <i>obj</i>, now preferred over\n *  <code>Object#type</code>, as an object's type in Ruby is only\n *  loosely tied to that object's class. This method must always be\n *  called with an explicit receiver, as <code>class</code> is also a\n *  reserved word in Ruby.\n *\n *     1.class      #=> Integer\n *     self.class   #=> Object\n */\n\nMRB_API struct RClass*\nmrb_obj_class(mrb_state *mrb, mrb_value obj)\n{\n  return mrb_class_real(mrb_class(mrb, obj));\n}\n\nMRB_API void\nmrb_alias_method(mrb_state *mrb, struct RClass *c, mrb_sym a, mrb_sym b)\n{\n  if (a == b) return;\n  mrb_method_t m = mrb_method_search(mrb, c, b);\n\n  if (!MRB_METHOD_CFUNC_P(m)) {\n    struct RProc *p = MRB_METHOD_PROC(m);\n\n    if (MRB_PROC_ENV_P(p)) {\n      MRB_PROC_ENV(p)->mid = b;\n    }\n    else if (p->color != MRB_GC_RED) {\n      struct RClass *tc = MRB_PROC_TARGET_CLASS(p);\n      struct REnv *e = MRB_OBJ_ALLOC(mrb, MRB_TT_ENV, NULL);\n\n      e->mid = b;\n      if (tc) {\n        e->c = tc;\n        mrb_field_write_barrier(mrb, (struct RBasic*)e, (struct RBasic*)tc);\n      }\n      p->e.env = e;\n      p->flags |= MRB_PROC_ENVSET;\n      mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)e);\n    }\n  }\n  mrb_define_method_raw(mrb, c, a, m);\n}\n\n/*!\n * Defines an alias of a method.\n * \\param mrb    the mruby state\n * \\param klass  the class which the original method belongs to\n * \\param name1  a new name for the method\n * \\param name2  the original name of the method\n */\nMRB_API void\nmrb_define_alias(mrb_state *mrb, struct RClass *klass, const char *name1, const char *name2)\n{\n  mrb_alias_method(mrb, klass, mrb_intern_cstr(mrb, name1), mrb_intern_cstr(mrb, name2));\n}\n\nMRB_API void\nmrb_define_alias_id(mrb_state *mrb, struct RClass *klass, mrb_sym a, mrb_sym b)\n{\n  mrb_alias_method(mrb, klass, a, b);\n}\n\n/*\n * call-seq:\n *   mod.to_s   -> string\n *\n * Return a string representing this module or class. For basic\n * classes and modules, this is the name. For singletons, we\n * show information on the thing we're attached to as well.\n */\n\nmrb_value\nmrb_mod_to_s(mrb_state *mrb, mrb_value klass)\n{\n  if (mrb_sclass_p(klass)) {\n    mrb_value v = mrb_iv_get(mrb, klass, MRB_SYM(__attached__));\n    mrb_value str = mrb_str_new_lit(mrb, \"#<Class:\");\n\n    if (class_ptr_p(v)) {\n      mrb_str_cat_str(mrb, str, mrb_inspect(mrb, v));\n    }\n    else {\n      mrb_str_cat_str(mrb, str, mrb_any_to_s(mrb, v));\n    }\n    return mrb_str_cat_lit(mrb, str, \">\");\n  }\n  else {\n    return class_name_str(mrb, mrb_class_ptr(klass));\n  }\n}\n\nstatic mrb_value\nmrb_mod_alias(mrb_state *mrb, mrb_value mod)\n{\n  struct RClass *c = mrb_class_ptr(mod);\n  mrb_sym new_name, old_name;\n\n  mrb_get_args(mrb, \"nn\", &new_name, &old_name);\n  mrb_alias_method(mrb, c, new_name, old_name);\n  mrb_method_added(mrb, c, new_name);\n  return mod;\n}\n\nstatic void\nundef_method(mrb_state *mrb, struct RClass *c, mrb_sym a)\n{\n  mrb_method_t m;\n\n  MRB_METHOD_FROM_PROC(m, NULL);\n  mrb_define_method_raw(mrb, c, a, m);\n}\n\nMRB_API void\nmrb_undef_method_id(mrb_state *mrb, struct RClass *c, mrb_sym a)\n{\n  if (!mrb_obj_respond_to(mrb, c, a)) {\n    mrb_name_error(mrb, a, \"undefined method '%n' for class '%C'\", a, c);\n  }\n  undef_method(mrb, c, a);\n}\n\nMRB_API void\nmrb_undef_method(mrb_state *mrb, struct RClass *c, const char *name)\n{\n  undef_method(mrb, c, mrb_intern_cstr(mrb, name));\n}\n\nMRB_API void\nmrb_undef_class_method_id(mrb_state *mrb, struct RClass *c, mrb_sym name)\n{\n  mrb_undef_method_id(mrb,  mrb_class_ptr(mrb_singleton_class(mrb, mrb_obj_value(c))), name);\n}\n\nMRB_API void\nmrb_undef_class_method(mrb_state *mrb, struct RClass *c, const char *name)\n{\n  mrb_undef_method(mrb,  mrb_class_ptr(mrb_singleton_class(mrb, mrb_obj_value(c))), name);\n}\n\nMRB_API void\nmrb_remove_method(mrb_state *mrb, struct RClass *c, mrb_sym mid)\n{\n  mt_tbl *h;\n\n  MRB_CLASS_ORIGIN(c);\n  h = c->mt;\n\n  if (h && mt_del(mrb, h, mid)) return;\n  mrb_name_error(mrb, mid, \"method '%n' not defined in %C\", mid, c);\n}\n\nstatic mrb_value\nmrb_mod_undef(mrb_state *mrb, mrb_value mod)\n{\n  struct RClass *c = mrb_class_ptr(mod);\n  mrb_int argc;\n  const mrb_value *argv;\n\n  mrb_get_args(mrb, \"*\", &argv, &argc);\n  while (argc--) {\n    mrb_undef_method_id(mrb, c, to_sym(mrb, *argv));\n    argv++;\n  }\n  return mrb_nil_value();\n}\n\nstatic void\ncheck_const_name_sym(mrb_state *mrb, mrb_sym id)\n{\n  mrb_int len;\n  const char *name = mrb_sym_name_len(mrb, id, &len);\n  if (!mrb_const_name_p(mrb, name, len)) {\n    mrb_name_error(mrb, id, \"wrong constant name %n\", id);\n  }\n}\n\nstatic mrb_value\nmrb_mod_const_defined(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym id;\n  mrb_bool inherit = TRUE;\n\n  mrb_get_args(mrb, \"n|b\", &id, &inherit);\n  check_const_name_sym(mrb, id);\n  if (inherit) {\n    return mrb_bool_value(mrb_const_defined(mrb, mod, id));\n  }\n  return mrb_bool_value(mrb_const_defined_at(mrb, mod, id));\n}\n\nstatic mrb_value\nmrb_const_get_sym(mrb_state *mrb, mrb_value mod, mrb_sym id)\n{\n  check_const_name_sym(mrb, id);\n  return mrb_const_get(mrb, mod, id);\n}\n\nstatic mrb_value\nmrb_mod_const_get(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value path = mrb_get_arg1(mrb);\n  mrb_sym id;\n  char *ptr;\n  mrb_int off, end, len;\n\n  if (mrb_symbol_p(path)) {\n    /* const get with symbol */\n    id = mrb_symbol(path);\n    return mrb_const_get_sym(mrb, mod, id);\n  }\n\n  /* const get with class path string */\n  mrb_ensure_string_type(mrb, path);\n  ptr = RSTRING_PTR(path);\n  len = RSTRING_LEN(path);\n  off = 0;\n\n  while (off < len) {\n    end = mrb_str_index_lit(mrb, path, \"::\", off);\n    end = (end == -1) ? len : end;\n    id = mrb_intern(mrb, ptr+off, end-off);\n    mod = mrb_const_get_sym(mrb, mod, id);\n    if (end == len)\n      off = end;\n    else {\n      off = end + 2;\n      if (off == len) {         /* trailing \"::\" */\n        mrb_name_error(mrb, id, \"wrong constant name '%v'\", path);\n      }\n    }\n  }\n\n  return mod;\n}\n\nstatic mrb_value\nmrb_mod_const_set(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym id;\n  mrb_value value;\n\n  mrb_get_args(mrb, \"no\", &id, &value);\n  check_const_name_sym(mrb, id);\n  mrb_const_set(mrb, mod, id, value);\n  return value;\n}\n\nstatic mrb_value\nmrb_mod_remove_const(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym id;\n  mrb_value val;\n\n  mrb_get_args(mrb, \"n\", &id);\n  check_const_name_sym(mrb, id);\n  val = mrb_iv_remove(mrb, mod, id);\n  if (mrb_undef_p(val)) {\n    mrb_name_error(mrb, id, \"constant %n not defined\", id);\n  }\n  return val;\n}\n\nstatic mrb_value\nmrb_mod_const_missing(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym sym;\n\n  mrb_get_args(mrb, \"n\", &sym);\n  mrb->c->ci->mid = 0;\n\n  if (mrb_class_real(mrb_class_ptr(mod)) != mrb->object_class) {\n    mrb_name_error(mrb, sym, \"uninitialized constant %v::%n\", mod, sym);\n  }\n  else {\n    mrb_name_error(mrb, sym, \"uninitialized constant %n\", sym);\n  }\n  /* not reached */\n  return mrb_nil_value();\n}\n\n/* 15.2.2.4.34 */\n/*\n *  call-seq:\n *     mod.method_defined?(symbol)    -> true or false\n *\n *  Returns +true+ if the named method is defined by\n *  _mod_ (or its included modules and, if _mod_ is a class,\n *  its ancestors). Public and protected methods are matched.\n *\n *     module A\n *       def method1()  end\n *     end\n *     class B\n *       def method2()  end\n *     end\n *     class C < B\n *       include A\n *       def method3()  end\n *     end\n *\n *     A.method_defined? :method1    #=> true\n *     C.method_defined? \"method1\"   #=> true\n *     C.method_defined? \"method2\"   #=> true\n *     C.method_defined? \"method3\"   #=> true\n *     C.method_defined? \"method4\"   #=> false\n */\n\nstatic mrb_value\nmrb_mod_method_defined(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym id;\n\n  mrb_get_args(mrb, \"n\", &id);\n  return mrb_bool_value(mrb_obj_respond_to(mrb, mrb_class_ptr(mod), id));\n}\n\nvoid\nmrb_method_added(mrb_state *mrb, struct RClass *c, mrb_sym mid)\n{\n  mrb_sym added;\n  mrb_value recv = mrb_obj_value(c);\n\n  if (c->tt == MRB_TT_SCLASS) {\n    added = MRB_SYM(singleton_method_added);\n    recv = mrb_iv_get(mrb, recv, MRB_SYM(__attached__));\n  }\n  else {\n    added = MRB_SYM(method_added);\n  }\n  mrb_funcall_id(mrb, recv, added, 1, mrb_symbol_value(mid));\n}\n\nmrb_value\nmrb_mod_define_method_m(mrb_state *mrb, struct RClass *c)\n{\n  struct RProc *p;\n  mrb_method_t m;\n  mrb_sym mid;\n  mrb_value proc = mrb_undef_value();\n  mrb_value blk;\n\n  mrb_get_args(mrb, \"n|o&\", &mid, &proc, &blk);\n  switch (mrb_type(proc)) {\n    case MRB_TT_PROC:\n      blk = proc;\n      break;\n    case MRB_TT_UNDEF:\n      /* ignored */\n      break;\n    default:\n      mrb_raisef(mrb, E_TYPE_ERROR, \"wrong argument type %T (expected Proc)\", proc);\n      break;\n  }\n  if (mrb_nil_p(blk)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"no block given\");\n  }\n  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb->proc_class);\n  mrb_proc_copy(mrb, p, mrb_proc_ptr(blk));\n  p->flags |= MRB_PROC_STRICT;\n  MRB_METHOD_FROM_PROC(m, p);\n  mrb_define_method_raw(mrb, c, mid, m);\n  mrb_method_added(mrb, c, mid);\n  return mrb_symbol_value(mid);\n}\n\nstatic mrb_value\nmod_define_method(mrb_state *mrb, mrb_value self)\n{\n  return mrb_mod_define_method_m(mrb, mrb_class_ptr(self));\n}\n\nstatic mrb_value\ntop_define_method(mrb_state *mrb, mrb_value self)\n{\n  return mrb_mod_define_method_m(mrb, mrb->object_class);\n}\n\nstatic mrb_value\nmrb_mod_eqq(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value obj = mrb_get_arg1(mrb);\n  mrb_bool eqq;\n\n  eqq = mrb_obj_is_kind_of(mrb, obj, mrb_class_ptr(mod));\n\n  return mrb_bool_value(eqq);\n}\n\nstatic mrb_value\nmrb_mod_dup(mrb_state *mrb, mrb_value self)\n{\n  mrb_value mod = mrb_obj_clone(mrb, self);\n  MRB_UNSET_FROZEN_FLAG(mrb_obj_ptr(mod));\n  return mod;\n}\n\nstatic mrb_value\nmrb_mod_module_function(mrb_state *mrb, mrb_value mod)\n{\n  const mrb_value *argv;\n  mrb_int argc, i;\n  mrb_sym mid;\n  mrb_method_t m;\n  struct RClass *rclass;\n  int ai;\n\n  mrb_check_type(mrb, mod, MRB_TT_MODULE);\n\n  mrb_get_args(mrb, \"*\", &argv, &argc);\n  if (argc == 0) {\n    /* set MODFUNC SCOPE if implemented */\n    return mod;\n  }\n\n  /* set PRIVATE method visibility if implemented */\n  /* mrb_mod_dummy_visibility(mrb, mod); */\n\n  for (i=0; i<argc; i++) {\n    mrb_check_type(mrb, argv[i], MRB_TT_SYMBOL);\n\n    mid = mrb_symbol(argv[i]);\n    rclass = mrb_class_ptr(mod);\n    m = mrb_method_search(mrb, rclass, mid);\n\n    prepare_singleton_class(mrb, (struct RBasic*)rclass);\n    ai = mrb_gc_arena_save(mrb);\n    mrb_define_method_raw(mrb, rclass->c, mid, m);\n    mrb_gc_arena_restore(mrb, ai);\n  }\n\n  return mod;\n}\n\nstatic struct RClass*\nmrb_singleton_class_clone(mrb_state *mrb, mrb_value obj)\n{\n  struct RClass *klass = mrb_basic_ptr(obj)->c;\n\n  if (klass->tt != MRB_TT_SCLASS)\n    return klass;\n  else {\n    /* copy singleton(unnamed) class */\n    struct RClass *clone = (struct RClass*)mrb_obj_alloc(mrb, klass->tt, mrb->class_class);\n\n    switch (mrb_type(obj)) {\n    case MRB_TT_CLASS:\n    case MRB_TT_SCLASS:\n      break;\n    default:\n      clone->c = mrb_singleton_class_clone(mrb, mrb_obj_value(klass));\n      break;\n    }\n    clone->super = klass->super;\n    if (klass->iv) {\n      mrb_iv_copy(mrb, mrb_obj_value(clone), mrb_obj_value(klass));\n      mrb_obj_iv_set(mrb, (struct RObject*)clone, MRB_SYM(__attached__), obj);\n    }\n    if (klass->mt) {\n      clone->mt = mt_copy(mrb, klass->mt);\n    }\n    else {\n      clone->mt = mt_new(mrb);\n    }\n    clone->tt = MRB_TT_SCLASS;\n    return clone;\n  }\n}\n\nstatic void\ncopy_class(mrb_state *mrb, mrb_value dst, mrb_value src)\n{\n  struct RClass *dc = mrb_class_ptr(dst);\n  struct RClass *sc = mrb_class_ptr(src);\n  /* if the origin is not the same as the class, then the origin and\n     the current class need to be copied */\n  if (sc->flags & MRB_FL_CLASS_IS_PREPENDED) {\n    struct RClass *c0 = sc->super;\n    struct RClass *c1 = dc;\n\n    /* copy prepended iclasses */\n    while (!(c0->flags & MRB_FL_CLASS_IS_ORIGIN)) {\n      c1->super = mrb_class_ptr(mrb_obj_dup(mrb, mrb_obj_value(c0)));\n      c1 = c1->super;\n      c0 = c0->super;\n    }\n    c1->super = mrb_class_ptr(mrb_obj_dup(mrb, mrb_obj_value(c0)));\n    c1->super->flags |= MRB_FL_CLASS_IS_ORIGIN;\n  }\n  if (sc->mt) {\n    dc->mt = mt_copy(mrb, sc->mt);\n  }\n  else {\n    dc->mt = mt_new(mrb);\n  }\n  dc->super = sc->super;\n  MRB_SET_INSTANCE_TT(dc, MRB_INSTANCE_TT(sc));\n}\n\n/* 15.3.1.3.16 */\nstatic mrb_value\nmrb_obj_init_copy(mrb_state *mrb, mrb_value self)\n{\n  mrb_value orig = mrb_get_arg1(mrb);\n\n  if (mrb_obj_equal(mrb, self, orig)) return self;\n  if ((mrb_type(self) != mrb_type(orig)) || (mrb_obj_class(mrb, self) != mrb_obj_class(mrb, orig))) {\n      mrb_raise(mrb, E_TYPE_ERROR, \"initialize_copy should take same class object\");\n  }\n  return self;\n}\n\nstatic void\ninit_copy(mrb_state *mrb, mrb_value dest, mrb_value obj)\n{\n  switch (mrb_type(obj)) {\n    case MRB_TT_ICLASS:\n      copy_class(mrb, dest, obj);\n      return;\n    case MRB_TT_CLASS:\n    case MRB_TT_MODULE:\n      copy_class(mrb, dest, obj);\n      mrb_iv_copy(mrb, dest, obj);\n      mrb_iv_remove(mrb, dest, MRB_SYM(__classname__));\n      break;\n    case MRB_TT_OBJECT:\n    case MRB_TT_SCLASS:\n    case MRB_TT_HASH:\n    case MRB_TT_DATA:\n    case MRB_TT_EXCEPTION:\n      mrb_iv_copy(mrb, dest, obj);\n      break;\n    case MRB_TT_ISTRUCT:\n      mrb_istruct_copy(dest, obj);\n      break;\n\n    default:\n      break;\n  }\n  if (!mrb_func_basic_p(mrb, dest, MRB_SYM(initialize_copy), mrb_obj_init_copy)) {\n    mrb_funcall_id(mrb, dest, MRB_SYM(initialize_copy), 1, obj);\n  }\n}\n\n/* 15.3.1.3.8  */\n/*\n *  call-seq:\n *     obj.clone -> an_object\n *\n *  Produces a shallow copy of <i>obj</i>---the instance variables of\n *  <i>obj</i> are copied, but not the objects they reference. Copies\n *  the frozen state of <i>obj</i>. See also the discussion\n *  under <code>Object#dup</code>.\n *\n *     class Klass\n *        attr_accessor :str\n *     end\n *     s1 = Klass.new      #=> #<Klass:0x401b3a38>\n *     s1.str = \"Hello\"    #=> \"Hello\"\n *     s2 = s1.clone       #=> #<Klass:0x401b3998 @str=\"Hello\">\n *     s2.str[1,4] = \"i\"   #=> \"i\"\n *     s1.inspect          #=> \"#<Klass:0x401b3a38 @str=\\\"Hi\\\">\"\n *     s2.inspect          #=> \"#<Klass:0x401b3998 @str=\\\"Hi\\\">\"\n *\n *  This method may have class-specific behavior.  If so, that\n *  behavior will be documented under the #+initialize_copy+ method of\n *  the class.\n *\n *  Some Class(True False Nil Symbol Integer Float) Object  cannot clone.\n */\nMRB_API mrb_value\nmrb_obj_clone(mrb_state *mrb, mrb_value self)\n{\n  struct RObject *p;\n  mrb_value clone;\n\n  if (mrb_immediate_p(self)) {\n    return self;\n  }\n  if (mrb_sclass_p(self)) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't clone singleton class\");\n  }\n  p = (struct RObject*)mrb_obj_alloc(mrb, mrb_type(self), mrb_obj_class(mrb, self));\n  p->c = mrb_singleton_class_clone(mrb, self);\n  mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)p->c);\n  clone = mrb_obj_value(p);\n  init_copy(mrb, clone, self);\n  p->flags |= mrb_obj_ptr(self)->flags & MRB_FL_OBJ_IS_FROZEN;\n\n  return clone;\n}\n\n/* 15.3.1.3.9  */\n/*\n *  call-seq:\n *     obj.dup -> an_object\n *\n *  Produces a shallow copy of <i>obj</i>---the instance variables of\n *  <i>obj</i> are copied, but not the objects they reference.\n *  <code>dup</code> copies the frozen state of <i>obj</i>. See also\n *  the discussion under <code>Object#clone</code>. In general,\n *  <code>clone</code> and <code>dup</code> may have different semantics\n *  in descendant classes. While <code>clone</code> is used to duplicate\n *  an object, including its internal state, <code>dup</code> typically\n *  uses the class of the descendant object to create the new instance.\n *\n *  This method may have class-specific behavior.  If so, that\n *  behavior will be documented under the #+initialize_copy+ method of\n *  the class.\n */\n\nMRB_API mrb_value\nmrb_obj_dup(mrb_state *mrb, mrb_value obj)\n{\n  struct RBasic *p;\n  mrb_value dup;\n\n  if (mrb_immediate_p(obj)) {\n    return obj;\n  }\n  if (mrb_sclass_p(obj)) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't dup singleton class\");\n  }\n  p = mrb_obj_alloc(mrb, mrb_type(obj), mrb_obj_class(mrb, obj));\n  dup = mrb_obj_value(p);\n  init_copy(mrb, dup, obj);\n\n  return dup;\n}\n\n/* implementation of __id__ */\nmrb_value mrb_obj_id_m(mrb_state *mrb, mrb_value self);\n/* implementation of instance_eval */\nmrb_value mrb_obj_instance_eval(mrb_state*, mrb_value);\n\nstatic mrb_value\ninspect_main(mrb_state *mrb, mrb_value mod)\n{\n  return mrb_str_new_lit(mrb, \"main\");\n}\n\nstatic const mrb_code new_iseq[] = {\n  OP_ENTER, 0x0, 0x10, 0x3,  // OP_ENTER     0:0:1:0:0:1:1\n  OP_LOADSELF, 4,            // OP_LOADSELF  R4\n  OP_SEND, 4, 0, 0,          // OP_SEND      R4  :allocate  n=0\n  OP_MOVE, 0, 4,             // OP_MOVE      R0  R4\n  OP_MOVE, 4, 3,             // OP_MOVE      R4  R3 (&)\n  OP_MOVE, 3, 2,             // OP_MOVE      R3  R2 (**)\n  OP_MOVE, 2, 1,             // OP_MOVE      R2  R1 (*)\n  OP_SSENDB, 1, 1, 255,      // OP_SSENDB    R1  :initialize n=*|nk=*\n  OP_RETURN, 0               // OP_RETURN    R0\n};\n\nMRB_PRESYM_DEFINE_VAR_AND_INITER(new_syms, 2, MRB_SYM(allocate), MRB_SYM(initialize))\n\nstatic const mrb_irep new_irep = {\n  4, 5, 0, MRB_IREP_STATIC,\n  new_iseq, NULL, new_syms, NULL, NULL, NULL,\n  sizeof(new_iseq), 0, 2, 0, 0,\n};\n\nstatic const struct RProc new_proc = {\n  NULL, NULL, MRB_TT_PROC, MRB_GC_RED, MRB_FL_OBJ_IS_FROZEN | MRB_PROC_SCOPE | MRB_PROC_STRICT,\n  { &new_irep }, NULL, { NULL }\n};\n\nstatic void\ninit_class_new(mrb_state *mrb, struct RClass *cls)\n{\n  mrb_method_t m;\n\n  MRB_PRESYM_INIT_SYMBOLS(mrb, new_syms);\n  MRB_METHOD_FROM_PROC(m, &new_proc);\n  mrb_define_method_raw(mrb, cls, MRB_SYM(new), m);\n}\n\n/* implementation of #send method */\nmrb_value mrb_f_send(mrb_state *mrb, mrb_value self);\n\nvoid\nmrb_init_class(mrb_state *mrb)\n{\n  struct RClass *bob;           /* BasicObject */\n  struct RClass *obj;           /* Object */\n  struct RClass *mod;           /* Module */\n  struct RClass *cls;           /* Class */\n\n  /* boot class hierarchy */\n  bob = boot_defclass(mrb, 0);\n  obj = boot_defclass(mrb, bob); mrb->object_class = obj;\n  mod = boot_defclass(mrb, obj); mrb->module_class = mod;/* obj -> mod */\n  cls = boot_defclass(mrb, mod); mrb->class_class = cls; /* obj -> cls */\n  /* fix-up loose ends */\n  bob->c = obj->c = mod->c = cls->c = cls;\n  make_metaclass(mrb, bob);\n  make_metaclass(mrb, obj);\n  make_metaclass(mrb, mod);\n  make_metaclass(mrb, cls);\n\n  /* name basic classes */\n  mrb_define_const_id(mrb, bob, MRB_SYM(BasicObject), mrb_obj_value(bob));\n  mrb_define_const_id(mrb, obj, MRB_SYM(Object),      mrb_obj_value(obj));\n  mrb_define_const_id(mrb, obj, MRB_SYM(Module),      mrb_obj_value(mod));\n  mrb_define_const_id(mrb, obj, MRB_SYM(Class),       mrb_obj_value(cls));\n\n  /* name each classes */\n  mrb_class_name_class(mrb, NULL, bob, MRB_SYM(BasicObject));\n  mrb_class_name_class(mrb, NULL, obj, MRB_SYM(Object)); /* 15.2.1 */\n  mrb_class_name_class(mrb, NULL, mod, MRB_SYM(Module)); /* 15.2.2 */\n  mrb_class_name_class(mrb, NULL, cls, MRB_SYM(Class));  /* 15.2.3 */\n\n  mrb->proc_class = mrb_define_class(mrb, \"Proc\", mrb->object_class);  /* 15.2.17 */\n  MRB_SET_INSTANCE_TT(mrb->proc_class, MRB_TT_PROC);\n\n  MRB_SET_INSTANCE_TT(cls, MRB_TT_CLASS);\n  mrb_define_method(mrb, bob, \"initialize\",              mrb_do_nothing,           MRB_ARGS_NONE());\n  mrb_define_method(mrb, bob, \"!\",                       mrb_bob_not,              MRB_ARGS_NONE());\n  mrb_define_method(mrb, bob, \"==\",                      mrb_obj_equal_m,          MRB_ARGS_REQ(1)); /* 15.3.1.3.1  */\n  mrb_define_method(mrb, bob, \"__id__\",                  mrb_obj_id_m,             MRB_ARGS_NONE()); /* 15.3.1.3.4  */\n  mrb_define_method(mrb, bob, \"__send__\",                mrb_f_send,               MRB_ARGS_REQ(1)|MRB_ARGS_REST()|MRB_ARGS_BLOCK());  /* 15.3.1.3.5  */\n  mrb_define_method(mrb, bob, \"equal?\",                  mrb_obj_equal_m,          MRB_ARGS_REQ(1)); /* 15.3.1.3.11 */\n  mrb_define_method(mrb, bob, \"instance_eval\",           mrb_obj_instance_eval,    MRB_ARGS_OPT(1)|MRB_ARGS_BLOCK());  /* 15.3.1.3.18 */\n  mrb_define_method(mrb, bob, \"singleton_method_added\",  mrb_do_nothing,           MRB_ARGS_REQ(1));\n\n  mrb_define_class_method(mrb, cls, \"new\",               mrb_class_new_class,      MRB_ARGS_OPT(1)|MRB_ARGS_BLOCK());\n  mrb_define_method(mrb, cls, \"allocate\",                mrb_instance_alloc,       MRB_ARGS_NONE());\n  mrb_define_method(mrb, cls, \"superclass\",              mrb_class_superclass,     MRB_ARGS_NONE()); /* 15.2.3.3.4 */\n  mrb_define_method(mrb, cls, \"initialize\",              mrb_class_initialize,     MRB_ARGS_OPT(1)); /* 15.2.3.3.1 */\n  mrb_define_method(mrb, cls, \"inherited\",               mrb_do_nothing,           MRB_ARGS_REQ(1));\n\n  init_class_new(mrb, cls);\n\n  MRB_SET_INSTANCE_TT(mod, MRB_TT_MODULE);\n  mrb_define_method(mrb, mod, \"extend_object\",           mrb_mod_extend_object,    MRB_ARGS_REQ(1)); /* 15.2.2.4.25 */\n  mrb_define_method(mrb, mod, \"extended\",                mrb_do_nothing,           MRB_ARGS_REQ(1)); /* 15.2.2.4.26 */\n  mrb_define_method(mrb, mod, \"prepended\",               mrb_do_nothing,           MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, mod, \"prepend_features\",        mrb_mod_prepend_features, MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, mod, \"include?\",                mrb_mod_include_p,        MRB_ARGS_REQ(1)); /* 15.2.2.4.28 */\n  mrb_define_method(mrb, mod, \"append_features\",         mrb_mod_append_features,  MRB_ARGS_REQ(1)); /* 15.2.2.4.10 */\n  mrb_define_method(mrb, mod, \"class_eval\",              mrb_mod_module_eval,      MRB_ARGS_ANY());  /* 15.2.2.4.15 */\n  mrb_define_method(mrb, mod, \"included\",                mrb_do_nothing,           MRB_ARGS_REQ(1)); /* 15.2.2.4.29 */\n  mrb_define_method(mrb, mod, \"initialize\",              mrb_mod_initialize,       MRB_ARGS_NONE()); /* 15.2.2.4.31 */\n  mrb_define_method(mrb, mod, \"module_eval\",             mrb_mod_module_eval,      MRB_ARGS_ANY());  /* 15.2.2.4.35 */\n  mrb_define_method(mrb, mod, \"module_function\",         mrb_mod_module_function,  MRB_ARGS_ANY());\n  mrb_define_method(mrb, mod, \"private\",                 mrb_mod_dummy_visibility, MRB_ARGS_ANY());  /* 15.2.2.4.36 */\n  mrb_define_method(mrb, mod, \"protected\",               mrb_mod_dummy_visibility, MRB_ARGS_ANY());  /* 15.2.2.4.37 */\n  mrb_define_method(mrb, mod, \"public\",                  mrb_mod_dummy_visibility, MRB_ARGS_ANY());  /* 15.2.2.4.38 */\n  mrb_define_method(mrb, mod, \"attr_reader\",             mrb_mod_attr_reader,      MRB_ARGS_ANY());  /* 15.2.2.4.13 */\n  mrb_define_method(mrb, mod, \"attr_writer\",             mrb_mod_attr_writer,      MRB_ARGS_ANY());  /* 15.2.2.4.14 */\n  mrb_define_method(mrb, mod, \"to_s\",                    mrb_mod_to_s,             MRB_ARGS_NONE());\n  mrb_define_method(mrb, mod, \"inspect\",                 mrb_mod_to_s,             MRB_ARGS_NONE());\n  mrb_define_method(mrb, mod, \"alias_method\",            mrb_mod_alias,            MRB_ARGS_ANY());  /* 15.2.2.4.8 */\n  mrb_define_method(mrb, mod, \"ancestors\",               mrb_mod_ancestors,        MRB_ARGS_NONE()); /* 15.2.2.4.9 */\n  mrb_define_method(mrb, mod, \"undef_method\",            mrb_mod_undef,            MRB_ARGS_ANY());  /* 15.2.2.4.41 */\n  mrb_define_method(mrb, mod, \"const_defined?\",          mrb_mod_const_defined,    MRB_ARGS_ARG(1,1)); /* 15.2.2.4.20 */\n  mrb_define_method(mrb, mod, \"const_get\",               mrb_mod_const_get,        MRB_ARGS_REQ(1)); /* 15.2.2.4.21 */\n  mrb_define_method(mrb, mod, \"const_set\",               mrb_mod_const_set,        MRB_ARGS_REQ(2)); /* 15.2.2.4.23 */\n  mrb_define_method(mrb, mod, \"remove_const\",            mrb_mod_remove_const,     MRB_ARGS_REQ(1)); /* 15.2.2.4.40 */\n  mrb_define_method(mrb, mod, \"const_missing\",           mrb_mod_const_missing,    MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, mod, \"method_defined?\",         mrb_mod_method_defined,   MRB_ARGS_REQ(1)); /* 15.2.2.4.34 */\n  mrb_define_method(mrb, mod, \"define_method\",           mod_define_method,        MRB_ARGS_ARG(1,1));\n  mrb_define_method(mrb, mod, \"===\",                     mrb_mod_eqq,              MRB_ARGS_REQ(1)); /* 15.2.2.4.7 */\n  mrb_define_method(mrb, mod, \"dup\",                     mrb_mod_dup,              MRB_ARGS_NONE());\n  mrb_define_method(mrb, bob, \"method_added\",            mrb_do_nothing,           MRB_ARGS_REQ(1));\n\n  mrb_undef_method(mrb, cls, \"append_features\");\n  mrb_undef_method(mrb, cls, \"prepend_features\");\n  mrb_undef_method(mrb, cls, \"extend_object\");\n  mrb_undef_method(mrb, cls, \"module_function\");\n\n  mrb->top_self = MRB_OBJ_ALLOC(mrb, MRB_TT_OBJECT, mrb->object_class);\n  mrb_define_singleton_method(mrb, mrb->top_self, \"inspect\", inspect_main, MRB_ARGS_NONE());\n  mrb_define_singleton_method(mrb, mrb->top_self, \"to_s\", inspect_main, MRB_ARGS_NONE());\n  mrb_define_singleton_method(mrb, mrb->top_self, \"define_method\", top_define_method, MRB_ARGS_ARG(1,1));\n}\n"], "fixing_code": ["/*\n** class.c - Class class\n**\n** See Copyright Notice in mruby.h\n*/\n\n#include <mruby.h>\n#include <mruby/array.h>\n#include <mruby/hash.h>\n#include <mruby/class.h>\n#include <mruby/numeric.h>\n#include <mruby/proc.h>\n#include <mruby/string.h>\n#include <mruby/variable.h>\n#include <mruby/error.h>\n#include <mruby/data.h>\n#include <mruby/istruct.h>\n#include <mruby/opcode.h>\n#include <mruby/internal.h>\n#include <mruby/presym.h>\n\nunion mt_ptr {\n  struct RProc *proc;\n  mrb_func_t func;\n};\n\n#define MT_KEY_P(k) (((k)>>2) != 0)\n#define MT_FUNC_P 1\n#define MT_NOARG_P 2\n#define MT_EMPTY 0\n#define MT_DELETED 1\n\n#define MT_KEY(sym, flags) ((sym)<<2|(flags))\n#define MT_FLAGS(func_p, noarg_p) ((func_p)?MT_FUNC_P:0)|((noarg_p)?MT_NOARG_P:0)\n#define MT_KEY_SYM(k) ((k)>>2)\n#define MT_KEY_FLG(k) ((k)&3)\n\n/* method table structure */\ntypedef struct mt_tbl {\n  int size;\n  int alloc;\n  union mt_ptr *ptr;\n} mt_tbl;\n\n#ifdef MRB_USE_INLINE_METHOD_CACHE\n#define MT_CACHE_SIZE 256\nstatic uint8_t mt_cache[MT_CACHE_SIZE];\n#endif\n\n/* Creates the method table. */\nstatic mt_tbl*\nmt_new(mrb_state *mrb)\n{\n  mt_tbl *t;\n\n  t = (mt_tbl*)mrb_malloc(mrb, sizeof(mt_tbl));\n  t->size = 0;\n  t->alloc = 0;\n  t->ptr = NULL;\n\n  return t;\n}\n\nstatic void mt_put(mrb_state *mrb, mt_tbl *t, mrb_sym sym, mrb_sym flags, union mt_ptr ptr);\n\nstatic void\nmt_rehash(mrb_state *mrb, mt_tbl *t)\n{\n  int old_alloc = t->alloc;\n  int new_alloc = old_alloc+8;\n  union mt_ptr *old_ptr = t->ptr;\n\n  khash_power2(new_alloc);\n  if (old_alloc == new_alloc) return;\n\n  t->alloc = new_alloc;\n  t->size = 0;\n  t->ptr = (union mt_ptr*)mrb_calloc(mrb, sizeof(union mt_ptr)+sizeof(mrb_sym), new_alloc);\n  if (old_alloc == 0) return;\n\n  mrb_sym *keys = (mrb_sym*)&old_ptr[old_alloc];\n  union mt_ptr *vals = old_ptr;\n  for (int i = 0; i < old_alloc; i++) {\n    mrb_sym key = keys[i];\n    if (MT_KEY_P(key)) {\n      mt_put(mrb, t, MT_KEY_SYM(key), MT_KEY_FLG(key), vals[i]);\n    }\n  }\n  mrb_free(mrb, old_ptr);\n}\n\n#define slot_empty_p(slot) ((slot)->key == 0 && (slot)->func_p == 0)\n\n/* Set the value for the symbol in the method table. */\nstatic void\nmt_put(mrb_state *mrb, mt_tbl *t, mrb_sym sym, mrb_sym flags, union mt_ptr ptr)\n{\n  int hash, pos, start, dpos = -1;\n\n  if (t->alloc == 0) {\n    mt_rehash(mrb, t);\n  }\n\n  mrb_sym *keys = (mrb_sym*)&t->ptr[t->alloc];\n  union mt_ptr *vals = t->ptr;\n  hash = kh_int_hash_func(mrb, sym);\n  start = pos = hash & (t->alloc-1);\n  for (;;) {\n    mrb_sym key = keys[pos];\n    if (MT_KEY_SYM(key) == sym) {\n    value_set:\n      keys[pos] = MT_KEY(sym, flags);\n      vals[pos] = ptr;\n      return;\n    }\n    else if (key == MT_EMPTY) {\n      t->size++;\n      goto value_set;\n    }\n    else if (key == MT_DELETED && dpos < 0) {\n      dpos = pos;\n    }\n    pos = (pos+1) & (t->alloc-1);\n    if (pos == start) {         /* not found */\n      if (dpos > 0) {\n        t->size++;\n        pos = dpos;\n        goto value_set;\n      }\n      /* no room */\n      mt_rehash(mrb, t);\n      start = pos = hash & (t->alloc-1);\n      keys = (mrb_sym*)&t->ptr[t->alloc];\n      vals = t->ptr;\n    }\n  }\n}\n\n/* Get a value for a symbol from the method table. */\nstatic mrb_sym\nmt_get(mrb_state *mrb, mt_tbl *t, mrb_sym sym, union mt_ptr *pp)\n{\n  int hash, pos, start;\n\n  if (t == NULL) return 0;\n  if (t->alloc == 0) return 0;\n  if (t->size == 0) return 0;\n\n  mrb_sym *keys = (mrb_sym*)&t->ptr[t->alloc];\n  union mt_ptr *vals = t->ptr;\n  hash = kh_int_hash_func(mrb, sym);\n#ifdef MRB_USE_INLINE_METHOD_CACHE\n  int cpos = (hash^(uintptr_t)t) % MT_CACHE_SIZE;\n  pos = mt_cache[cpos];\n  if (cpos < t->alloc && t->table[cpos].key == sym) {\n    return &t->table[cpos];\n  }\n#endif\n  start = pos = hash & (t->alloc-1);\n  for (;;) {\n    mrb_sym key = keys[pos];\n    if (MT_KEY_SYM(key) == sym) {\n      *pp = vals[pos];\n#ifdef MRB_USE_INLINE_METHOD_CACHE\n      if (pos < 0xff) {\n        mt_cache[cpos] = pos;\n      }\n#endif\n      return key;\n    }\n    else if (key == MT_EMPTY) {\n      return 0;\n    }\n    pos = (pos+1) & (t->alloc-1);\n    if (pos == start) {         /* not found */\n      return 0;\n    }\n  }\n}\n\n/* Deletes the value for the symbol from the method table. */\nstatic mrb_bool\nmt_del(mrb_state *mrb, mt_tbl *t, mrb_sym sym)\n{\n  int hash, pos, start;\n\n  if (t == NULL) return FALSE;\n  if (t->alloc == 0) return  FALSE;\n  if (t->size == 0) return FALSE;\n\n  mrb_sym *keys = (mrb_sym*)&t->ptr[t->alloc];\n  hash = kh_int_hash_func(mrb, sym);\n  start = pos = hash & (t->alloc-1);\n  for (;;) {\n    mrb_sym key = keys[pos];\n    if (MT_KEY_SYM(key) == sym) {\n      t->size--;\n      keys[pos] = MT_DELETED;\n      return TRUE;\n    }\n    else if (key == MT_EMPTY) {\n      return FALSE;\n    }\n    pos = (pos+1) & (t->alloc-1);\n    if (pos == start) {         /* not found */\n      return FALSE;\n    }\n  }\n}\n\n/* Copy the method table. */\nstatic struct mt_tbl*\nmt_copy(mrb_state *mrb, mt_tbl *t)\n{\n  mt_tbl *t2;\n  int i;\n\n  if (t == NULL) return NULL;\n  if (t->alloc == 0) return NULL;\n  if (t->size == 0) return NULL;\n\n  t2 = mt_new(mrb);\n  mrb_sym *keys = (mrb_sym*)&t->ptr[t->alloc];\n  union mt_ptr *vals = t->ptr;\n  for (i=0; i<t->alloc; i++) {\n    if (MT_KEY_P(keys[i])) {\n      mt_put(mrb, t2, MT_KEY_SYM(keys[i]), MT_KEY_FLG(keys[i]), vals[i]);\n    }\n  }\n  return t2;\n}\n\n/* Free memory of the method table. */\nstatic void\nmt_free(mrb_state *mrb, mt_tbl *t)\n{\n  mrb_free(mrb, t->ptr);\n  mrb_free(mrb, t);\n}\n\nMRB_API void\nmrb_mt_foreach(mrb_state *mrb, struct RClass *c, mrb_mt_foreach_func *fn, void *p)\n{\n  mt_tbl *t = c->mt;\n  int i;\n\n  if (t == NULL) return;\n  if (t->alloc == 0) return;\n  if (t->size == 0) return;\n\n  mrb_sym *keys = (mrb_sym*)&t->ptr[t->alloc];\n  union mt_ptr *vals = t->ptr;\n  for (i=0; i<t->alloc; i++) {\n    mrb_sym key = keys[i];\n    if (MT_KEY_SYM(key)) {\n      mrb_method_t m;\n\n      if (key & MT_FUNC_P) {\n        MRB_METHOD_FROM_FUNC(m, vals[i].func);\n      }\n      else {\n        MRB_METHOD_FROM_PROC(m, vals[i].proc);\n      }\n      if (key & MT_NOARG_P) {\n        MRB_METHOD_NOARG_SET(m);\n      }\n\n      if (fn(mrb, MT_KEY_SYM(key), m, p) != 0)\n        return;\n    }\n  }\n  return;\n}\n\nvoid\nmrb_gc_mark_mt(mrb_state *mrb, struct RClass *c)\n{\n  mt_tbl *t = c->mt;\n  int i;\n\n  if (t == NULL) return;\n  if (t->alloc == 0) return;\n  if (t->size == 0) return;\n\n  mrb_sym *keys = (mrb_sym*)&t->ptr[t->alloc];\n  union mt_ptr *vals = t->ptr;\n  for (i=0; i<t->alloc; i++) {\n    if (MT_KEY_P(keys[i]) && (keys[i] & MT_FUNC_P) == 0) { /* Proc pointer */\n      struct RProc *p = vals[i].proc;\n      mrb_gc_mark(mrb, (struct RBasic*)p);\n    }\n  }\n  return;\n}\n\nsize_t\nmrb_gc_mark_mt_size(mrb_state *mrb, struct RClass *c)\n{\n  struct mt_tbl *h = c->mt;\n\n  if (!h) return 0;\n  return (size_t)h->size;\n}\n\nvoid\nmrb_gc_free_mt(mrb_state *mrb, struct RClass *c)\n{\n  if (c->mt) mt_free(mrb, c->mt);\n}\n\nvoid\nmrb_class_name_class(mrb_state *mrb, struct RClass *outer, struct RClass *c, mrb_sym id)\n{\n  mrb_value name;\n  mrb_sym nsym = MRB_SYM(__classname__);\n\n  if (mrb_obj_iv_defined(mrb, (struct RObject*)c, nsym)) return;\n  if (outer == NULL || outer == mrb->object_class) {\n    name = mrb_symbol_value(id);\n  }\n  else {\n    name = mrb_class_path(mrb, outer);\n    if (mrb_nil_p(name)) {      /* unnamed outer class */\n      if (outer != mrb->object_class && outer != c) {\n        mrb_obj_iv_set_force(mrb, (struct RObject*)c, MRB_SYM(__outer__),\n                             mrb_obj_value(outer));\n      }\n      return;\n    }\n    else {\n      mrb_int len;\n      const char *n = mrb_sym_name_len(mrb, id, &len);\n\n      mrb_str_cat_lit(mrb, name, \"::\");\n      mrb_str_cat(mrb, name, n, len);\n    }\n  }\n  mrb_obj_iv_set_force(mrb, (struct RObject*)c, nsym, name);\n}\n\nmrb_bool\nmrb_const_name_p(mrb_state *mrb, const char *name, mrb_int len)\n{\n  return len > 0 && ISUPPER(name[0]) && mrb_ident_p(name+1, len-1);\n}\n\nstatic void\nsetup_class(mrb_state *mrb, struct RClass *outer, struct RClass *c, mrb_sym id)\n{\n  mrb_class_name_class(mrb, outer, c, id);\n  mrb_obj_iv_set(mrb, (struct RObject*)outer, id, mrb_obj_value(c));\n}\n\n#define make_metaclass(mrb, c) prepare_singleton_class((mrb), (struct RBasic*)(c))\n\nstatic void\nprepare_singleton_class(mrb_state *mrb, struct RBasic *o)\n{\n  struct RClass *sc, *c;\n\n  mrb_assert(o->c);\n  if (o->c->tt == MRB_TT_SCLASS) return;\n  sc = MRB_OBJ_ALLOC(mrb, MRB_TT_SCLASS, mrb->class_class);\n  sc->flags |= MRB_FL_CLASS_IS_INHERITED;\n  sc->mt = mt_new(mrb);\n  sc->iv = 0;\n  if (o->tt == MRB_TT_CLASS) {\n    c = (struct RClass*)o;\n    if (!c->super) {\n      sc->super = mrb->class_class;\n    }\n    else {\n      sc->super = c->super->c;\n    }\n  }\n  else if (o->tt == MRB_TT_SCLASS) {\n    c = (struct RClass*)o;\n    while (c->super->tt == MRB_TT_ICLASS)\n      c = c->super;\n    make_metaclass(mrb, c->super);\n    sc->super = c->super->c;\n  }\n  else {\n    sc->super = o->c;\n    prepare_singleton_class(mrb, (struct RBasic*)sc);\n  }\n  o->c = sc;\n  mrb_field_write_barrier(mrb, (struct RBasic*)o, (struct RBasic*)sc);\n  mrb_field_write_barrier(mrb, (struct RBasic*)sc, (struct RBasic*)o);\n  mrb_obj_iv_set(mrb, (struct RObject*)sc, MRB_SYM(__attached__), mrb_obj_value(o));\n  sc->flags |= o->flags & MRB_FL_OBJ_IS_FROZEN;\n}\n\nstatic mrb_value\nclass_name_str(mrb_state *mrb, struct RClass* c)\n{\n  mrb_value path = mrb_class_path(mrb, c);\n  if (mrb_nil_p(path)) {\n    path = c->tt == MRB_TT_MODULE ? mrb_str_new_lit(mrb, \"#<Module:\") :\n                                    mrb_str_new_lit(mrb, \"#<Class:\");\n    mrb_str_cat_str(mrb, path, mrb_ptr_to_str(mrb, c));\n    mrb_str_cat_lit(mrb, path, \">\");\n  }\n  return path;\n}\n\nstatic struct RClass*\nclass_from_sym(mrb_state *mrb, struct RClass *klass, mrb_sym id)\n{\n  mrb_value c = mrb_const_get(mrb, mrb_obj_value(klass), id);\n\n  mrb_check_type(mrb, c, MRB_TT_CLASS);\n  return mrb_class_ptr(c);\n}\n\nstatic struct RClass*\nmodule_from_sym(mrb_state *mrb, struct RClass *klass, mrb_sym id)\n{\n  mrb_value c = mrb_const_get(mrb, mrb_obj_value(klass), id);\n\n  mrb_check_type(mrb, c, MRB_TT_MODULE);\n  return mrb_class_ptr(c);\n}\n\nstatic mrb_bool\nclass_ptr_p(mrb_value obj)\n{\n  switch (mrb_type(obj)) {\n  case MRB_TT_CLASS:\n  case MRB_TT_SCLASS:\n  case MRB_TT_MODULE:\n    return TRUE;\n  default:\n    return FALSE;\n  }\n}\n\nstatic void\ncheck_if_class_or_module(mrb_state *mrb, mrb_value obj)\n{\n  if (!class_ptr_p(obj)) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"%!v is not a class/module\", obj);\n  }\n}\n\nstatic struct RClass*\ndefine_module(mrb_state *mrb, mrb_sym name, struct RClass *outer)\n{\n  struct RClass *m;\n\n  if (mrb_const_defined_at(mrb, mrb_obj_value(outer), name)) {\n    return module_from_sym(mrb, outer, name);\n  }\n  m = mrb_module_new(mrb);\n  setup_class(mrb, outer, m, name);\n\n  return m;\n}\n\nMRB_API struct RClass*\nmrb_define_module_id(mrb_state *mrb, mrb_sym name)\n{\n  return define_module(mrb, name, mrb->object_class);\n}\n\nMRB_API struct RClass*\nmrb_define_module(mrb_state *mrb, const char *name)\n{\n  return define_module(mrb, mrb_intern_cstr(mrb, name), mrb->object_class);\n}\n\nstruct RClass*\nmrb_vm_define_module(mrb_state *mrb, mrb_value outer, mrb_sym id)\n{\n  check_if_class_or_module(mrb, outer);\n  if (mrb_const_defined_at(mrb, outer, id)) {\n    mrb_value old = mrb_const_get(mrb, outer, id);\n\n    if (!mrb_module_p(old)) {\n      mrb_raisef(mrb, E_TYPE_ERROR, \"%!v is not a module\", old);\n    }\n    return mrb_class_ptr(old);\n  }\n  return define_module(mrb, id, mrb_class_ptr(outer));\n}\n\nMRB_API struct RClass*\nmrb_define_module_under_id(mrb_state *mrb, struct RClass *outer, mrb_sym name)\n{\n  struct RClass * c = define_module(mrb, name, outer);\n\n  setup_class(mrb, outer, c, name);\n  return c;\n}\n\nMRB_API struct RClass*\nmrb_define_module_under(mrb_state *mrb, struct RClass *outer, const char *name)\n{\n  mrb_sym id = mrb_intern_cstr(mrb, name);\n  struct RClass * c = define_module(mrb, id, outer);\n\n  setup_class(mrb, outer, c, id);\n  return c;\n}\n\nstatic struct RClass*\nfind_origin(struct RClass *c)\n{\n  MRB_CLASS_ORIGIN(c);\n  return c;\n}\n\nstatic struct RClass*\ndefine_class(mrb_state *mrb, mrb_sym name, struct RClass *super, struct RClass *outer)\n{\n  struct RClass * c;\n\n  if (mrb_const_defined_at(mrb, mrb_obj_value(outer), name)) {\n    c = class_from_sym(mrb, outer, name);\n    MRB_CLASS_ORIGIN(c);\n    if (super && mrb_class_real(c->super) != super) {\n      mrb_raisef(mrb, E_TYPE_ERROR, \"superclass mismatch for Class %n (%C not %C)\",\n                 name, c->super, super);\n    }\n    return c;\n  }\n\n  c = mrb_class_new(mrb, super);\n  setup_class(mrb, outer, c, name);\n\n  return c;\n}\n\nMRB_API struct RClass*\nmrb_define_class_id(mrb_state *mrb, mrb_sym name, struct RClass *super)\n{\n  if (!super) {\n    mrb_warn(mrb, \"no super class for '%n', Object assumed\", name);\n  }\n  return define_class(mrb, name, super, mrb->object_class);\n}\n\nMRB_API struct RClass*\nmrb_define_class(mrb_state *mrb, const char *name, struct RClass *super)\n{\n  return mrb_define_class_id(mrb, mrb_intern_cstr(mrb, name), super);\n}\n\nstatic mrb_value mrb_do_nothing(mrb_state *mrb, mrb_value);\n#ifndef MRB_NO_METHOD_CACHE\nstatic void mc_clear(mrb_state *mrb);\n#else\n#define mc_clear(mrb)\n#endif\n\nstatic void\nmrb_class_inherited(mrb_state *mrb, struct RClass *super, struct RClass *klass)\n{\n  mrb_value s;\n  mrb_sym mid;\n\n  if (!super)\n    super = mrb->object_class;\n  super->flags |= MRB_FL_CLASS_IS_INHERITED;\n  s = mrb_obj_value(super);\n  mrb_mc_clear_by_class(mrb, klass);\n  mid = MRB_SYM(inherited);\n  if (!mrb_func_basic_p(mrb, s, mid, mrb_do_nothing)) {\n    mrb_value c = mrb_obj_value(klass);\n    mrb_funcall_argv(mrb, s, mid, 1, &c);\n  }\n}\n\nstruct RClass*\nmrb_vm_define_class(mrb_state *mrb, mrb_value outer, mrb_value super, mrb_sym id)\n{\n  struct RClass *s;\n  struct RClass *c;\n\n  if (!mrb_nil_p(super)) {\n    if (!mrb_class_p(super)) {\n      mrb_raisef(mrb, E_TYPE_ERROR, \"superclass must be a Class (%!v given)\", super);\n    }\n    s = mrb_class_ptr(super);\n  }\n  else {\n    s = 0;\n  }\n  check_if_class_or_module(mrb, outer);\n  if (mrb_const_defined_at(mrb, outer, id)) {\n    mrb_value old = mrb_const_get(mrb, outer, id);\n\n    if (!mrb_class_p(old)) {\n      mrb_raisef(mrb, E_TYPE_ERROR, \"%!v is not a class\", old);\n    }\n    c = mrb_class_ptr(old);\n    if (s) {\n      /* check super class */\n      if (mrb_class_real(c->super) != s) {\n        mrb_raisef(mrb, E_TYPE_ERROR, \"superclass mismatch for class %v\", old);\n      }\n    }\n    return c;\n  }\n  c = define_class(mrb, id, s, mrb_class_ptr(outer));\n  mrb_class_inherited(mrb, mrb_class_real(c->super), c);\n\n  return c;\n}\n\nMRB_API mrb_bool\nmrb_class_defined(mrb_state *mrb, const char *name)\n{\n  mrb_sym sym = mrb_intern_check_cstr(mrb, name);\n  if (!sym) return FALSE;\n  return mrb_const_defined(mrb, mrb_obj_value(mrb->object_class), sym);\n}\n\nMRB_API mrb_bool\nmrb_class_defined_id(mrb_state *mrb, mrb_sym name)\n{\n  return mrb_const_defined(mrb, mrb_obj_value(mrb->object_class), name);\n}\n\nMRB_API mrb_bool\nmrb_class_defined_under(mrb_state *mrb, struct RClass *outer, const char *name)\n{\n  mrb_sym sym = mrb_intern_check_cstr(mrb, name);\n  if (!sym) return FALSE;\n  return mrb_const_defined_at(mrb, mrb_obj_value(outer), sym);\n}\n\nMRB_API mrb_bool\nmrb_class_defined_under_id(mrb_state *mrb, struct RClass *outer, mrb_sym name)\n{\n  return mrb_const_defined_at(mrb, mrb_obj_value(outer), name);\n}\n\nMRB_API struct RClass*\nmrb_class_get_under(mrb_state *mrb, struct RClass *outer, const char *name)\n{\n  return class_from_sym(mrb, outer, mrb_intern_cstr(mrb, name));\n}\n\nMRB_API struct RClass*\nmrb_class_get_under_id(mrb_state *mrb, struct RClass *outer, mrb_sym name)\n{\n  return class_from_sym(mrb, outer, name);\n}\n\nMRB_API struct RClass*\nmrb_class_get(mrb_state *mrb, const char *name)\n{\n  return mrb_class_get_under(mrb, mrb->object_class, name);\n}\n\nMRB_API struct RClass*\nmrb_class_get_id(mrb_state *mrb, mrb_sym name)\n{\n  return mrb_class_get_under_id(mrb, mrb->object_class, name);\n}\n\nMRB_API struct RClass*\nmrb_exc_get_id(mrb_state *mrb, mrb_sym name)\n{\n  struct RClass *exc, *e;\n  mrb_value c = mrb_const_get(mrb, mrb_obj_value(mrb->object_class), name);\n\n  if (!mrb_class_p(c)) {\n    mrb_raise(mrb, mrb->eException_class, \"exception corrupted\");\n  }\n  exc = e = mrb_class_ptr(c);\n\n  while (e) {\n    if (e == mrb->eException_class)\n      return exc;\n    e = e->super;\n  }\n  return mrb->eException_class;\n}\n\nMRB_API struct RClass*\nmrb_module_get_under(mrb_state *mrb, struct RClass *outer, const char *name)\n{\n  return module_from_sym(mrb, outer, mrb_intern_cstr(mrb, name));\n}\n\nMRB_API struct RClass*\nmrb_module_get_under_id(mrb_state *mrb, struct RClass *outer, mrb_sym name)\n{\n  return module_from_sym(mrb, outer, name);\n}\n\nMRB_API struct RClass*\nmrb_module_get(mrb_state *mrb, const char *name)\n{\n  return mrb_module_get_under(mrb, mrb->object_class, name);\n}\n\nMRB_API struct RClass*\nmrb_module_get_id(mrb_state *mrb, mrb_sym name)\n{\n  return mrb_module_get_under_id(mrb, mrb->object_class, name);\n}\n\n/*!\n * Defines a class under the namespace of \\a outer.\n * \\param outer  a class which contains the new class.\n * \\param name     name of the new class\n * \\param super  a class from which the new class will derive.\n *               NULL means \\c Object class.\n * \\return the created class\n * \\throw TypeError if the constant name \\a name is already taken but\n *                  the constant is not a \\c Class.\n * \\throw NameError if the class is already defined but the class can not\n *                  be reopened because its superclass is not \\a super.\n * \\post top-level constant named \\a name refers the returned class.\n *\n * \\note if a class named \\a name is already defined and its superclass is\n *       \\a super, the function just returns the defined class.\n */\nMRB_API struct RClass*\nmrb_define_class_under_id(mrb_state *mrb, struct RClass *outer, mrb_sym name, struct RClass *super)\n{\n  struct RClass * c;\n\n#if 0\n  if (!super) {\n    mrb_warn(mrb, \"no super class for '%C::%n', Object assumed\", outer, id);\n  }\n#endif\n  c = define_class(mrb, name, super, outer);\n  setup_class(mrb, outer, c, name);\n  return c;\n}\n\nMRB_API struct RClass*\nmrb_define_class_under(mrb_state *mrb, struct RClass *outer, const char *name, struct RClass *super)\n{\n  return mrb_define_class_under_id(mrb, outer, mrb_intern_cstr(mrb, name), super);\n}\n\nMRB_API void\nmrb_define_method_raw(mrb_state *mrb, struct RClass *c, mrb_sym mid, mrb_method_t m)\n{\n  mt_tbl *h;\n  union mt_ptr ptr;\n\n  MRB_CLASS_ORIGIN(c);\n  h = c->mt;\n  mrb_check_frozen(mrb, c);\n  if (!h) h = c->mt = mt_new(mrb);\n  if (MRB_METHOD_PROC_P(m)) {\n    struct RProc *p = MRB_METHOD_PROC(m);\n\n    ptr.proc = p;\n    if (p) {\n      if (p->color != MRB_GC_RED) {\n        p->flags |= MRB_PROC_SCOPE;\n        p->c = NULL;\n        mrb_field_write_barrier(mrb, (struct RBasic*)c, (struct RBasic*)p);\n        if (!MRB_PROC_ENV_P(p)) {\n          MRB_PROC_SET_TARGET_CLASS(p, c);\n        }\n      }\n      else {\n        mrb_assert(MRB_FROZEN_P(p) && MRB_PROC_SCOPE_P(p));\n        mrb_assert(p->c == NULL && p->upper == NULL && p->e.target_class == NULL);\n      }\n    }\n  }\n  else {\n    ptr.func = MRB_METHOD_FUNC(m);\n  }\n  mt_put(mrb, h, mid, MT_FLAGS(MRB_METHOD_FUNC_P(m), MRB_METHOD_NOARG_P(m)), ptr);\n  mc_clear(mrb);\n}\n\nMRB_API void\nmrb_define_method_id(mrb_state *mrb, struct RClass *c, mrb_sym mid, mrb_func_t func, mrb_aspec aspec)\n{\n  mrb_method_t m;\n  int ai = mrb_gc_arena_save(mrb);\n\n  MRB_METHOD_FROM_FUNC(m, func);\n#ifndef MRB_USE_METHOD_T_STRUCT\n  mrb_assert(MRB_METHOD_FUNC(m) == func);\n#endif\n  if (aspec == MRB_ARGS_NONE()) {\n    MRB_METHOD_NOARG_SET(m);\n  }\n  mrb_define_method_raw(mrb, c, mid, m);\n  mrb_gc_arena_restore(mrb, ai);\n}\n\nMRB_API void\nmrb_define_method(mrb_state *mrb, struct RClass *c, const char *name, mrb_func_t func, mrb_aspec aspec)\n{\n  mrb_define_method_id(mrb, c, mrb_intern_cstr(mrb, name), func, aspec);\n}\n\n/* a function to raise NotImplementedError with current method name */\nMRB_API void\nmrb_notimplement(mrb_state *mrb)\n{\n  mrb_callinfo *ci = mrb->c->ci;\n\n  if (ci->mid) {\n    mrb_raisef(mrb, E_NOTIMP_ERROR, \"%n() function is unimplemented on this machine\", ci->mid);\n  }\n}\n\n/* a function to be replacement of unimplemented method */\nMRB_API mrb_value\nmrb_notimplement_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_notimplement(mrb);\n  /* not reached */\n  return mrb_nil_value();\n}\n\nstatic void\nensure_class_type(mrb_state *mrb, mrb_value val)\n{\n  if (!class_ptr_p(val)) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"%v is not class/module\", val);\n  }\n}\n\n#define to_sym(mrb, ss) mrb_obj_to_sym(mrb, ss)\n\nMRB_API mrb_int\nmrb_get_argc(mrb_state *mrb)\n{\n  mrb_int argc = mrb->c->ci->n;\n\n  if (argc == 15) {\n    struct RArray *a = mrb_ary_ptr(mrb->c->ci->stack[1]);\n\n    argc = ARY_LEN(a);\n  }\n  return argc;\n}\n\nMRB_API const mrb_value*\nmrb_get_argv(mrb_state *mrb)\n{\n  mrb_int argc = mrb->c->ci->n;\n  mrb_value *array_argv = mrb->c->ci->stack + 1;\n  if (argc == 15) {\n    struct RArray *a = mrb_ary_ptr(*array_argv);\n\n    array_argv = ARY_PTR(a);\n  }\n  return array_argv;\n}\n\nMRB_API mrb_value\nmrb_get_arg1(mrb_state *mrb)\n{\n  mrb_callinfo *ci = mrb->c->ci;\n  mrb_int argc = ci->n;\n  mrb_value *array_argv = ci->stack + 1;\n  if (argc == 15) {\n    struct RArray *a = mrb_ary_ptr(*array_argv);\n\n    argc = ARY_LEN(a);\n    array_argv = ARY_PTR(a);\n  }\n  if (argc == 0 && ci->nk == 15) {\n    mrb_int n = ci->n;\n    if (n == 15) n = 1;\n    return ci->stack[n+1];      /* kwhash next to positional arguments */\n  }\n  if (argc != 1) {\n    mrb_argnum_error(mrb, argc, 1, 1);\n  }\n  return array_argv[0];\n}\n\nMRB_API mrb_bool\nmrb_block_given_p(mrb_state *mrb)\n{\n  mrb_callinfo *ci = mrb->c->ci;\n  mrb_value b = ci->stack[mrb_ci_bidx(ci)];\n\n  return !mrb_nil_p(b);\n}\n\n/*\n  retrieve arguments from mrb_state.\n\n  mrb_get_args(mrb, format, ...)\n\n  returns number of arguments parsed.\n\n  format specifiers:\n\n    string  mruby type     C type                 note\n    ----------------------------------------------------------------------------------------------\n    o:      Object         [mrb_value]\n    C:      Class/Module   [mrb_value]            when ! follows, the value may be nil\n    S:      String         [mrb_value]            when ! follows, the value may be nil\n    A:      Array          [mrb_value]            when ! follows, the value may be nil\n    H:      Hash           [mrb_value]            when ! follows, the value may be nil\n    s:      String         [const char*,mrb_int]  Receive two arguments; s! gives (NULL,0) for nil\n    z:      String         [const char*]          NUL terminated string; z! gives NULL for nil\n    a:      Array          [const mrb_value*,mrb_int] Receive two arguments; a! gives (NULL,0) for nil\n    c:      Class/Module   [strcut RClass*]       c! gives NULL for nil\n    f:      Integer/Float  [mrb_float]\n    i:      Integer/Float  [mrb_int]\n    b:      boolean        [mrb_bool]\n    n:      String/Symbol  [mrb_sym]\n    d:      data           [void*,mrb_data_type const] 2nd argument will be used to check data type so it won't be modified; when ! follows, the value may be nil\n    I:      inline struct  [void*,struct RClass]  I! gives NULL for nil\n    &:      block          [mrb_value]            &! raises exception if no block given\n    *:      rest argument  [const mrb_value*,mrb_int] The rest of the arguments as an array; *! avoid copy of the stack\n    |:      optional                              Following arguments are optional\n    ?:      optional given [mrb_bool]             true if preceding argument (optional) is given\n    ':':    keyword args   [mrb_kwargs const]     Get keyword arguments\n\n  format modifiers:\n\n    string  note\n    ----------------------------------------------------------------------------------------------\n    !:      Switch to the alternate mode; The behaviour changes depending on the specifier\n    +:      Request a not frozen object; However, except nil value\n */\nMRB_API mrb_int\nmrb_get_args(mrb_state *mrb, const char *format, ...)\n{\n  const char *fmt = format;\n  char c;\n  int i = 0;\n  va_list ap;\n  mrb_callinfo *ci = mrb->c->ci;\n  int argc = ci->n;\n  const mrb_value *argv = ci->stack+1;\n  mrb_bool argv_on_stack;\n  mrb_bool opt = FALSE;\n  mrb_bool opt_skip = TRUE;\n  const mrb_value *pickarg = NULL; /* arguments currently being processed */\n  mrb_value kdict = mrb_nil_value();\n  mrb_bool reqkarg = FALSE;\n  int argc_min = 0, argc_max = 0;\n\n  va_start(ap, format);\n\n  while ((c = *fmt++)) {\n    switch (c) {\n    case '|':\n      opt = TRUE;\n      break;\n    case '*':\n      opt_skip = FALSE;\n      argc_max = -1;\n      if (!reqkarg) reqkarg = strchr(fmt, ':') ? TRUE : FALSE;\n      goto check_exit;\n    case '!':\n    case '+':\n      break;\n    case ':':\n      reqkarg = TRUE;\n      /* fall through */\n    case '&': case '?':\n      if (opt) opt_skip = FALSE;\n      break;\n    default:\n      if (!opt) argc_min++;\n      argc_max++;\n      break;\n    }\n  }\n\n check_exit:\n  if (!reqkarg && ci->nk > 0) {\n    mrb_assert(ci->nk == 15);\n    kdict = ci->stack[mrb_ci_bidx(ci)-1];\n    if (mrb_hash_p(kdict) && mrb_hash_size(mrb, kdict) > 0) {\n      if (argc < 14) {\n        ci->n++;\n        argc++;    /* include kdict in normal arguments */\n      }\n      else {\n        /* 14+1 == 15 so pack first */\n        if (argc == 14) {\n          /* pack arguments and kdict */\n          ci->stack[1] = mrb_ary_new_from_values(mrb, argc+1, &ci->stack[1]);\n          argc = ci->n = 15;\n        }\n        else {\n          /* push kdict to packed arguments */\n          mrb_ary_push(mrb, ci->stack[1], kdict);\n        }\n        ci->stack[2] = ci->stack[mrb_ci_bidx(ci)];\n      }\n      ci->nk = 0;\n    }\n  }\n  if (reqkarg && ci->nk > 0) {\n    kdict = ci->stack[mrb_ci_bidx(ci)-1];\n    mrb_assert(ci->nk == 15);\n    mrb_assert(mrb_hash_p(kdict));\n  }\n\n  argv_on_stack = argc < 15;\n  if (!argv_on_stack) {\n    struct RArray *a = mrb_ary_ptr(*argv);\n    argv = ARY_PTR(a);\n    argc = ARY_LEN(a);\n  }\n\n  opt = FALSE;\n  i = 0;\n  while ((c = *format++)) {\n    mrb_bool altmode = FALSE;\n    mrb_bool needmodify = FALSE;\n\n    for (; *format; format++) {\n      switch (*format) {\n      case '!':\n        if (altmode) goto modifier_exit; /* not accept for multiple '!' */\n        altmode = TRUE;\n        break;\n      case '+':\n        if (needmodify) goto modifier_exit; /* not accept for multiple '+' */\n        needmodify = TRUE;\n        break;\n      default:\n        goto modifier_exit;\n      }\n    }\n\n  modifier_exit:\n    switch (c) {\n    case '|': case '*': case '&': case '?': case ':':\n      if (needmodify) {\n      bad_needmodify:\n        mrb_raisef(mrb, E_ARGUMENT_ERROR, \"wrong `%c+` modified specifier`\", c);\n      }\n      break;\n    default:\n      if (i < argc) {\n        pickarg = &argv[i++];\n        if (needmodify && !mrb_nil_p(*pickarg)) {\n          if (mrb_immediate_p(*pickarg)) {\n            mrb_raisef(mrb, E_FROZEN_ERROR, \"can't modify frozen %t\", *pickarg);\n          }\n          mrb_check_frozen(mrb, mrb_obj_ptr(*pickarg));\n        }\n      }\n      else {\n        if (opt) {\n          pickarg = NULL;\n        }\n        else {\n          mrb_argnum_error(mrb, argc, argc_min, argc_max);\n        }\n      }\n      break;\n    }\n\n    switch (c) {\n    case 'o':\n    case 'C':\n    case 'S':\n    case 'A':\n    case 'H':\n      {\n        mrb_value *p;\n\n        p = va_arg(ap, mrb_value*);\n        if (pickarg) {\n          if (!(altmode && mrb_nil_p(*pickarg))) {\n            switch (c) {\n            case 'C': ensure_class_type(mrb, *pickarg); break;\n            case 'S': mrb_ensure_string_type(mrb, *pickarg); break;\n            case 'A': mrb_ensure_array_type(mrb, *pickarg); break;\n            case 'H': mrb_ensure_hash_type(mrb, *pickarg); break;\n            }\n          }\n          *p = *pickarg;\n        }\n      }\n      break;\n    case 'c':\n      {\n        struct RClass **p;\n\n        p = va_arg(ap, struct RClass**);\n        if (pickarg) {\n          if (altmode && mrb_nil_p(*pickarg)) {\n            *p = NULL;\n          }\n          else {\n            ensure_class_type(mrb, *pickarg);\n            *p = mrb_class_ptr(*pickarg);\n          }\n        }\n      }\n      break;\n    case 's':\n      {\n        const char **ps = 0;\n        mrb_int *pl = 0;\n\n        ps = va_arg(ap, const char**);\n        pl = va_arg(ap, mrb_int*);\n        if (needmodify) goto bad_needmodify;\n        if (pickarg) {\n          if (altmode && mrb_nil_p(*pickarg)) {\n            *ps = NULL;\n            *pl = 0;\n          }\n          else {\n            mrb_ensure_string_type(mrb, *pickarg);\n            *ps = RSTRING_PTR(*pickarg);\n            *pl = RSTRING_LEN(*pickarg);\n          }\n        }\n      }\n      break;\n    case 'z':\n      {\n        const char **ps;\n\n        ps = va_arg(ap, const char**);\n        if (needmodify) goto bad_needmodify;\n        if (pickarg) {\n          if (altmode && mrb_nil_p(*pickarg)) {\n            *ps = NULL;\n          }\n          else {\n            mrb_ensure_string_type(mrb, *pickarg);\n            *ps = RSTRING_CSTR(mrb, *pickarg);\n          }\n        }\n      }\n      break;\n    case 'a':\n      {\n        struct RArray *a;\n        const mrb_value **pb;\n        mrb_int *pl;\n\n        pb = va_arg(ap, const mrb_value**);\n        pl = va_arg(ap, mrb_int*);\n        if (needmodify) goto bad_needmodify;\n        if (pickarg) {\n          if (altmode && mrb_nil_p(*pickarg)) {\n            *pb = 0;\n            *pl = 0;\n          }\n          else {\n            mrb_ensure_array_type(mrb, *pickarg);\n            a = mrb_ary_ptr(*pickarg);\n            *pb = ARY_PTR(a);\n            *pl = ARY_LEN(a);\n          }\n        }\n      }\n      break;\n    case 'I':\n      {\n        void* *p;\n        struct RClass *klass;\n\n        p = va_arg(ap, void**);\n        klass = va_arg(ap, struct RClass*);\n        if (pickarg) {\n          if (altmode && mrb_nil_p(*pickarg)) {\n            *p = NULL;\n          }\n          else {\n            if (!mrb_obj_is_kind_of(mrb, *pickarg, klass)) {\n              mrb_raisef(mrb, E_TYPE_ERROR, \"%v is not a %C\", *pickarg, klass);\n            }\n            if (!mrb_istruct_p(*pickarg)) {\n              mrb_raisef(mrb, E_TYPE_ERROR, \"%v is not inline struct\", *pickarg);\n            }\n            *p = mrb_istruct_ptr(*pickarg);\n          }\n        }\n      }\n      break;\n#ifndef MRB_NO_FLOAT\n    case 'f':\n      {\n        mrb_float *p;\n\n        p = va_arg(ap, mrb_float*);\n        if (pickarg) {\n          *p = mrb_as_float(mrb, *pickarg);\n        }\n      }\n      break;\n#endif\n    case 'i':\n      {\n        mrb_int *p;\n\n        p = va_arg(ap, mrb_int*);\n        if (pickarg) {\n          *p = mrb_as_int(mrb, *pickarg);\n        }\n      }\n      break;\n    case 'b':\n      {\n        mrb_bool *boolp = va_arg(ap, mrb_bool*);\n\n        if (pickarg) {\n          *boolp = mrb_test(*pickarg);\n        }\n      }\n      break;\n    case 'n':\n      {\n        mrb_sym *symp;\n\n        symp = va_arg(ap, mrb_sym*);\n        if (pickarg) {\n          *symp = to_sym(mrb, *pickarg);\n        }\n      }\n      break;\n    case 'd':\n      {\n        void** datap;\n        struct mrb_data_type const* type;\n\n        datap = va_arg(ap, void**);\n        type = va_arg(ap, struct mrb_data_type const*);\n        if (pickarg) {\n          if (altmode && mrb_nil_p(*pickarg)) {\n            *datap = 0;\n          }\n          else {\n            *datap = mrb_data_get_ptr(mrb, *pickarg, type);\n          }\n        }\n      }\n      break;\n\n    case '&':\n      {\n        mrb_value *p, *bp;\n\n        p = va_arg(ap, mrb_value*);\n        bp = ci->stack + mrb_ci_bidx(ci);\n        if (altmode && mrb_nil_p(*bp)) {\n          mrb_raise(mrb, E_ARGUMENT_ERROR, \"no block given\");\n        }\n        *p = *bp;\n      }\n      break;\n    case '|':\n      if (opt_skip && i == argc) goto finish;\n      opt = TRUE;\n      break;\n    case '?':\n      {\n        mrb_bool *p;\n\n        p = va_arg(ap, mrb_bool*);\n        *p = pickarg ? TRUE : FALSE;\n      }\n      break;\n\n    case '*':\n      {\n        const mrb_value **var;\n        mrb_int *pl;\n        mrb_bool nocopy = (altmode || !argv_on_stack) ? TRUE : FALSE;\n\n        var = va_arg(ap, const mrb_value**);\n        pl = va_arg(ap, mrb_int*);\n        if (argc > i) {\n          *pl = argc-i;\n          if (*pl > 0) {\n            if (nocopy) {\n              *var = argv+i;\n            }\n            else {\n              mrb_value args = mrb_ary_new_from_values(mrb, *pl, argv+i);\n              RARRAY(args)->c = NULL;\n              *var = RARRAY_PTR(args);\n            }\n          }\n          i = argc;\n        }\n        else {\n          *pl = 0;\n          *var = NULL;\n        }\n      }\n      break;\n\n    case ':':\n      {\n        mrb_value ksrc = mrb_hash_p(kdict) ? mrb_hash_dup(mrb, kdict) : mrb_hash_new(mrb);\n        const mrb_kwargs *kwargs = va_arg(ap, const mrb_kwargs*);\n        mrb_value *rest;\n\n        if (kwargs == NULL) {\n          rest = NULL;\n        }\n        else {\n          uint32_t kwnum = kwargs->num;\n          uint32_t required = kwargs->required;\n          const mrb_sym *kname = kwargs->table;\n          mrb_value *values = kwargs->values;\n          uint32_t j;\n          const uint32_t keyword_max = 40;\n\n          if (kwnum > keyword_max || required > kwnum) {\n            mrb_raise(mrb, E_ARGUMENT_ERROR, \"keyword number is too large\");\n          }\n\n          for (j = required; j > 0; j--, kname++, values++) {\n            mrb_value k = mrb_symbol_value(*kname);\n            if (!mrb_hash_key_p(mrb, ksrc, k)) {\n              mrb_raisef(mrb, E_ARGUMENT_ERROR, \"missing keyword: %n\", *kname);\n            }\n            *values = mrb_hash_delete_key(mrb, ksrc, k);\n            mrb_gc_protect(mrb, *values);\n          }\n\n          for (j = kwnum - required; j > 0; j--, kname++, values++) {\n            mrb_value k = mrb_symbol_value(*kname);\n            if (mrb_hash_key_p(mrb, ksrc, k)) {\n              *values = mrb_hash_delete_key(mrb, ksrc, k);\n              mrb_gc_protect(mrb, *values);\n            }\n            else {\n              *values = mrb_undef_value();\n            }\n          }\n\n          rest = kwargs->rest;\n        }\n\n        if (rest) {\n          *rest = ksrc;\n        }\n        else if (!mrb_hash_empty_p(mrb, ksrc)) {\n          ksrc = mrb_hash_keys(mrb, ksrc);\n          ksrc = RARRAY_PTR(ksrc)[0];\n          mrb_raisef(mrb, E_ARGUMENT_ERROR, \"unknown keyword: %v\", ksrc);\n        }\n      }\n      break;\n\n    default:\n      mrb_raisef(mrb, E_ARGUMENT_ERROR, \"invalid argument specifier %c\", c);\n      break;\n    }\n  }\n\n  if (!c && argc > i) {\n    mrb_argnum_error(mrb, argc, argc_min, argc_max);\n  }\n\nfinish:\n  va_end(ap);\n  return i;\n}\n\nstatic struct RClass*\nboot_defclass(mrb_state *mrb, struct RClass *super)\n{\n  struct RClass *c;\n\n  c = MRB_OBJ_ALLOC(mrb, MRB_TT_CLASS, mrb->class_class);\n  if (super) {\n    c->super = super;\n    mrb_field_write_barrier(mrb, (struct RBasic*)c, (struct RBasic*)super);\n    c->flags |= MRB_FL_CLASS_IS_INHERITED;\n  }\n  else {\n    c->super = mrb->object_class;\n  }\n  c->mt = mt_new(mrb);\n  return c;\n}\n\nstatic void\nboot_initmod(mrb_state *mrb, struct RClass *mod)\n{\n  if (!mod->mt) {\n    mod->mt = mt_new(mrb);\n  }\n}\n\nstatic struct RClass*\ninclude_class_new(mrb_state *mrb, struct RClass *m, struct RClass *super)\n{\n  struct RClass *ic = MRB_OBJ_ALLOC(mrb, MRB_TT_ICLASS, mrb->class_class);\n  if (m->tt == MRB_TT_ICLASS) {\n    m = m->c;\n  }\n  MRB_CLASS_ORIGIN(m);\n  ic->iv = m->iv;\n  ic->mt = m->mt;\n  ic->super = super;\n  if (m->tt == MRB_TT_ICLASS) {\n    ic->c = m->c;\n  }\n  else {\n    ic->c = m;\n  }\n  return ic;\n}\n\nstatic int\ninclude_module_at(mrb_state *mrb, struct RClass *c, struct RClass *ins_pos, struct RClass *m, int search_super)\n{\n  struct RClass *p, *ic;\n  void *klass_mt = find_origin(c)->mt;\n\n  while (m) {\n    int original_seen = FALSE;\n    int superclass_seen = FALSE;\n\n    if (c == ins_pos) original_seen = TRUE;\n    if (m->flags & MRB_FL_CLASS_IS_PREPENDED)\n      goto skip;\n\n    if (klass_mt && klass_mt == m->mt)\n      return -1;\n\n    p = c->super;\n    while (p) {\n      if (c == p) original_seen = TRUE;\n      if (p->tt == MRB_TT_ICLASS) {\n        if (p->mt == m->mt) {\n          if (!superclass_seen && original_seen) {\n            ins_pos = p; /* move insert point */\n          }\n          goto skip;\n        }\n      } else if (p->tt == MRB_TT_CLASS) {\n        if (!search_super) break;\n        superclass_seen = TRUE;\n      }\n      p = p->super;\n    }\n\n    ic = include_class_new(mrb, m, ins_pos->super);\n    m->flags |= MRB_FL_CLASS_IS_INHERITED;\n    ins_pos->super = ic;\n    mrb_field_write_barrier(mrb, (struct RBasic*)ins_pos, (struct RBasic*)ic);\n    ins_pos = ic;\n  skip:\n    m = m->super;\n  }\n  mc_clear(mrb);\n  return 0;\n}\n\nstatic int\nfix_include_module(mrb_state *mrb, struct RBasic *obj, void *data)\n{\n  struct RClass **m = (struct RClass**)data;\n\n  if (obj->tt == MRB_TT_ICLASS && obj->c == m[0] && !MRB_FLAG_TEST(obj, MRB_FL_CLASS_IS_ORIGIN)) {\n    struct RClass *ic = (struct RClass*)obj;\n    include_module_at(mrb, ic, ic, m[1], 1);\n  }\n  return MRB_EACH_OBJ_OK;\n}\n\nMRB_API void\nmrb_include_module(mrb_state *mrb, struct RClass *c, struct RClass *m)\n{\n  mrb_check_frozen(mrb, c);\n  if (include_module_at(mrb, c, find_origin(c), m, 1) < 0) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"cyclic include detected\");\n  }\n  if (c->tt == MRB_TT_MODULE && (c->flags & MRB_FL_CLASS_IS_INHERITED)) {\n    struct RClass *data[2];\n    data[0] = c;\n    data[1] = m;\n    mrb_objspace_each_objects(mrb, fix_include_module, data);\n  }\n}\n\nstatic int\nfix_prepend_module(mrb_state *mrb, struct RBasic *obj, void *data)\n{\n  struct RClass **m = (struct RClass**)data;\n  struct RClass *c = (struct RClass*)obj;\n\n  if (c->tt == MRB_TT_CLASS || c->tt == MRB_TT_MODULE) {\n    struct RClass *p = c->super;\n    struct RClass *ins_pos = c;\n    while (p) {\n      if (c == m[0]) break;\n      if (p == m[0]->super->c) {\n        ins_pos = c;\n      }\n      if (p->tt == MRB_TT_CLASS) break;\n      if (p->c == m[0]) {\n        include_module_at(mrb, ins_pos, ins_pos, m[1], 0);\n        break;\n      }\n      c = p;\n      p = p->super;\n    }\n  }\n  return MRB_EACH_OBJ_OK;\n}\n\nMRB_API void\nmrb_prepend_module(mrb_state *mrb, struct RClass *c, struct RClass *m)\n{\n  struct RClass *origin;\n\n  mrb_check_frozen(mrb, c);\n  if (!(c->flags & MRB_FL_CLASS_IS_PREPENDED)) {\n    struct RClass *c0;\n\n    if (c->tt == MRB_TT_ICLASS) {\n      c0 = c->c;\n    }\n    else {\n      c0 = c;\n    }\n    origin = MRB_OBJ_ALLOC(mrb, MRB_TT_ICLASS, c0);\n    origin->flags |= MRB_FL_CLASS_IS_ORIGIN | MRB_FL_CLASS_IS_INHERITED;\n    origin->super = c->super;\n    c->super = origin;\n    origin->mt = c->mt;\n    c->mt = NULL;\n    origin->iv = c->iv;\n    mrb_field_write_barrier(mrb, (struct RBasic*)c, (struct RBasic*)origin);\n    c->flags |= MRB_FL_CLASS_IS_PREPENDED;\n  }\n  if (include_module_at(mrb, c, c, m, 0) < 0) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"cyclic prepend detected\");\n  }\n  if (c->tt == MRB_TT_MODULE &&\n      (c->flags & (MRB_FL_CLASS_IS_INHERITED|MRB_FL_CLASS_IS_PREPENDED))) {\n    struct RClass *data[2];\n    data[0] = c;\n    data[1] = m;\n    mrb_objspace_each_objects(mrb, fix_prepend_module, data);\n  }\n}\n\nstatic mrb_value\nmrb_mod_prepend_features(mrb_state *mrb, mrb_value mod)\n{\n  struct RClass *c;\n\n  mrb_check_type(mrb, mod, MRB_TT_MODULE);\n  mrb_get_args(mrb, \"c\", &c);\n  mrb_prepend_module(mrb, c, mrb_class_ptr(mod));\n  return mod;\n}\n\nstatic mrb_value\nmrb_mod_append_features(mrb_state *mrb, mrb_value mod)\n{\n  struct RClass *c;\n\n  mrb_check_type(mrb, mod, MRB_TT_MODULE);\n  mrb_get_args(mrb, \"c\", &c);\n  mrb_include_module(mrb, c, mrb_class_ptr(mod));\n  return mod;\n}\n\n/* 15.2.2.4.28 */\n/*\n *  call-seq:\n *     mod.include?(module)    -> true or false\n *\n *  Returns <code>true</code> if <i>module</i> is included in\n *  <i>mod</i> or one of <i>mod</i>'s ancestors.\n *\n *     module A\n *     end\n *     class B\n *       include A\n *     end\n *     class C < B\n *     end\n *     B.include?(A)   #=> true\n *     C.include?(A)   #=> true\n *     A.include?(A)   #=> false\n */\nstatic mrb_value\nmrb_mod_include_p(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value mod2;\n  struct RClass *c = mrb_class_ptr(mod);\n\n  mrb_get_args(mrb, \"C\", &mod2);\n  mrb_check_type(mrb, mod2, MRB_TT_MODULE);\n\n  while (c) {\n    if (c->tt == MRB_TT_ICLASS) {\n      if (c->c == mrb_class_ptr(mod2)) return mrb_true_value();\n    }\n    c = c->super;\n  }\n  return mrb_false_value();\n}\n\nstatic mrb_value\nmrb_mod_ancestors(mrb_state *mrb, mrb_value self)\n{\n  mrb_value result;\n  struct RClass *c = mrb_class_ptr(self);\n  result = mrb_ary_new(mrb);\n  while (c) {\n    if (c->tt == MRB_TT_ICLASS) {\n      mrb_ary_push(mrb, result, mrb_obj_value(c->c));\n    }\n    else if (!(c->flags & MRB_FL_CLASS_IS_PREPENDED)) {\n      mrb_ary_push(mrb, result, mrb_obj_value(c));\n    }\n    c = c->super;\n  }\n\n  return result;\n}\n\nstatic mrb_value\nmrb_mod_extend_object(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value obj = mrb_get_arg1(mrb);\n\n  mrb_check_type(mrb, mod, MRB_TT_MODULE);\n  mrb_include_module(mrb, mrb_class_ptr(mrb_singleton_class(mrb, obj)), mrb_class_ptr(mod));\n  return mod;\n}\n\nstatic mrb_value\nmrb_mod_initialize(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value b;\n  struct RClass *m = mrb_class_ptr(mod);\n  boot_initmod(mrb, m); /* bootstrap a newly initialized module */\n  mrb_get_args(mrb, \"|&\", &b);\n  if (!mrb_nil_p(b)) {\n    mrb_yield_with_class(mrb, b, 1, &mod, mod, m);\n  }\n  return mod;\n}\n\n/* implementation of module_eval/class_eval */\nmrb_value mrb_mod_module_eval(mrb_state*, mrb_value);\n\nstatic mrb_value\nmrb_mod_dummy_visibility(mrb_state *mrb, mrb_value mod)\n{\n  return mod;\n}\n\n/* returns mrb_class_ptr(mrb_singleton_class()) */\n/* except that it return NULL for immediate values */\nMRB_API struct RClass*\nmrb_singleton_class_ptr(mrb_state *mrb, mrb_value v)\n{\n  struct RBasic *obj;\n\n  switch (mrb_type(v)) {\n  case MRB_TT_FALSE:\n    if (mrb_nil_p(v))\n      return mrb->nil_class;\n    return mrb->false_class;\n  case MRB_TT_TRUE:\n    return mrb->true_class;\n  case MRB_TT_CPTR:\n  case MRB_TT_SYMBOL:\n  case MRB_TT_INTEGER:\n#ifndef MRB_NO_FLOAT\n  case MRB_TT_FLOAT:\n#endif\n    return NULL;\n  default:\n    break;\n  }\n  obj = mrb_basic_ptr(v);\n  if (obj->c == NULL) return NULL;\n  prepare_singleton_class(mrb, obj);\n  return obj->c;\n}\n\nMRB_API mrb_value\nmrb_singleton_class(mrb_state *mrb, mrb_value v)\n{\n  struct RClass *c = mrb_singleton_class_ptr(mrb, v);\n\n  if (c == NULL) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't define singleton\");\n  }\n  return mrb_obj_value(c);\n}\n\nMRB_API void\nmrb_define_singleton_method(mrb_state *mrb, struct RObject *o, const char *name, mrb_func_t func, mrb_aspec aspec)\n{\n  prepare_singleton_class(mrb, (struct RBasic*)o);\n  mrb_define_method_id(mrb, o->c, mrb_intern_cstr(mrb, name), func, aspec);\n}\n\nMRB_API void\nmrb_define_singleton_method_id(mrb_state *mrb, struct RObject *o, mrb_sym name, mrb_func_t func, mrb_aspec aspec)\n{\n  prepare_singleton_class(mrb, (struct RBasic*)o);\n  mrb_define_method_id(mrb, o->c, name, func, aspec);\n}\n\nMRB_API void\nmrb_define_class_method(mrb_state *mrb, struct RClass *c, const char *name, mrb_func_t func, mrb_aspec aspec)\n{\n  mrb_define_singleton_method(mrb, (struct RObject*)c, name, func, aspec);\n}\n\nMRB_API void\nmrb_define_class_method_id(mrb_state *mrb, struct RClass *c, mrb_sym name, mrb_func_t func, mrb_aspec aspec)\n{\n  mrb_define_singleton_method_id(mrb, (struct RObject*)c, name, func, aspec);\n}\n\nMRB_API void\nmrb_define_module_function_id(mrb_state *mrb, struct RClass *c, mrb_sym name, mrb_func_t func, mrb_aspec aspec)\n{\n  mrb_define_class_method_id(mrb, c, name, func, aspec);\n  mrb_define_method_id(mrb, c, name, func, aspec);\n}\n\nMRB_API void\nmrb_define_module_function(mrb_state *mrb, struct RClass *c, const char *name, mrb_func_t func, mrb_aspec aspec)\n{\n  mrb_define_module_function_id(mrb, c, mrb_intern_cstr(mrb, name), func, aspec);\n}\n\n#ifndef MRB_NO_METHOD_CACHE\nstatic void\nmc_clear(mrb_state *mrb)\n{\n  static const struct mrb_cache_entry ce_zero ={0};\n\n  for (int i=0; i<MRB_METHOD_CACHE_SIZE; i++) {\n    mrb->cache[i] = ce_zero;\n  }\n}\n\nvoid\nmrb_mc_clear_by_class(mrb_state *mrb, struct RClass *c)\n{\n  struct mrb_cache_entry *mc = mrb->cache;\n  int i;\n\n  if (c->flags & MRB_FL_CLASS_IS_INHERITED) {\n    mc_clear(mrb);\n    return;\n  }\n  for (i=0; i<MRB_METHOD_CACHE_SIZE; i++) {\n    if (mc[i].c == c) mc[i].c = 0;\n  }\n}\n#endif\n\nMRB_API mrb_method_t\nmrb_method_search_vm(mrb_state *mrb, struct RClass **cp, mrb_sym mid)\n{\n  mrb_method_t m;\n  struct RClass *c = *cp;\n#ifndef MRB_NO_METHOD_CACHE\n  struct RClass *oc = c;\n  int h = kh_int_hash_func(mrb, ((intptr_t)oc) ^ mid) & (MRB_METHOD_CACHE_SIZE-1);\n  struct mrb_cache_entry *mc = &mrb->cache[h];\n\n  if (mc->c == c && mc->mid == mid) {\n    *cp = mc->c0;\n    return mc->m;\n  }\n#endif\n\n  while (c) {\n    mt_tbl *h = c->mt;\n\n    if (h) {\n      union mt_ptr ptr;\n      mrb_sym ret = mt_get(mrb, h, mid, &ptr);\n      if (ret) {\n        if (ptr.proc == 0) break;\n        *cp = c;\n        if (ret & MT_FUNC_P) {\n          MRB_METHOD_FROM_FUNC(m, ptr.func);\n        }\n        else {\n          MRB_METHOD_FROM_PROC(m, ptr.proc);\n        }\n        if (ret & MT_NOARG_P) {\n          MRB_METHOD_NOARG_SET(m);\n        }\n#ifndef MRB_NO_METHOD_CACHE\n        mc->c = oc;\n        mc->c0 = c;\n        mc->mid = mid;\n        mc->m = m;\n#endif\n        return m;\n      }\n    }\n    c = c->super;\n  }\n  MRB_METHOD_FROM_PROC(m, NULL);\n  return m;                  /* no method */\n}\n\nMRB_API mrb_method_t\nmrb_method_search(mrb_state *mrb, struct RClass* c, mrb_sym mid)\n{\n  mrb_method_t m;\n\n  m = mrb_method_search_vm(mrb, &c, mid);\n  if (MRB_METHOD_UNDEF_P(m)) {\n    mrb_name_error(mrb, mid, \"undefined method '%n' for class %C\", mid, c);\n  }\n  return m;\n}\n\n#define ONSTACK_ALLOC_MAX 32\n\nstatic mrb_sym\nprepare_name_common(mrb_state *mrb, mrb_sym sym, const char *prefix, const char *suffix)\n{\n  char onstack[ONSTACK_ALLOC_MAX];\n  mrb_int sym_len;\n  const char *sym_str = mrb_sym_name_len(mrb, sym, &sym_len);\n  size_t prefix_len = prefix ? strlen(prefix) : 0;\n  size_t suffix_len = suffix ? strlen(suffix) : 0;\n  size_t name_len = sym_len + prefix_len + suffix_len;\n  char *buf = name_len > sizeof(onstack) ? (char *)mrb_alloca(mrb, name_len) : onstack;\n  char *p = buf;\n\n  if (prefix_len > 0) {\n    memcpy(p, prefix, prefix_len);\n    p += prefix_len;\n  }\n\n  memcpy(p, sym_str, sym_len);\n  p += sym_len;\n\n  if (suffix_len > 0) {\n    memcpy(p, suffix, suffix_len);\n    p += suffix_len;\n  }\n\n  return mrb_intern(mrb, buf, name_len);\n}\n\nstatic mrb_value\nprepare_ivar_name(mrb_state *mrb, mrb_sym sym)\n{\n  sym = prepare_name_common(mrb, sym, \"@\", NULL);\n  mrb_iv_name_sym_check(mrb, sym);\n  return mrb_symbol_value(sym);\n}\n\nstatic mrb_sym\nprepare_writer_name(mrb_state *mrb, mrb_sym sym)\n{\n  return prepare_name_common(mrb, sym, NULL, \"=\");\n}\n\nstatic mrb_value\nmod_attr_define(mrb_state *mrb, mrb_value mod, mrb_value (*accessor)(mrb_state *, mrb_value), mrb_sym (*access_name)(mrb_state *, mrb_sym))\n{\n  struct RClass *c = mrb_class_ptr(mod);\n  const mrb_value *argv;\n  mrb_int argc, i;\n  int ai;\n\n  mrb_get_args(mrb, \"*\", &argv, &argc);\n  ai = mrb_gc_arena_save(mrb);\n  for (i=0; i<argc; i++) {\n    mrb_value name;\n    mrb_sym method;\n    struct RProc *p;\n    mrb_method_t m;\n\n    method = to_sym(mrb, argv[i]);\n    name = prepare_ivar_name(mrb, method);\n    if (access_name) {\n      method = access_name(mrb, method);\n    }\n\n    p = mrb_proc_new_cfunc_with_env(mrb, accessor, 1, &name);\n    MRB_METHOD_FROM_PROC(m, p);\n    mrb_define_method_raw(mrb, c, method, m);\n    mrb_gc_arena_restore(mrb, ai);\n  }\n  return mrb_nil_value();\n}\n\nstatic mrb_value\nattr_reader(mrb_state *mrb, mrb_value obj)\n{\n  mrb_value name = mrb_proc_cfunc_env_get(mrb, 0);\n  return mrb_iv_get(mrb, obj, to_sym(mrb, name));\n}\n\nstatic mrb_value\nmrb_mod_attr_reader(mrb_state *mrb, mrb_value mod)\n{\n  return mod_attr_define(mrb, mod, attr_reader, NULL);\n}\n\nstatic mrb_value\nattr_writer(mrb_state *mrb, mrb_value obj)\n{\n  mrb_value name = mrb_proc_cfunc_env_get(mrb, 0);\n  mrb_value val = mrb_get_arg1(mrb);\n\n  mrb_iv_set(mrb, obj, to_sym(mrb, name), val);\n  return val;\n}\n\nstatic mrb_value\nmrb_mod_attr_writer(mrb_state *mrb, mrb_value mod)\n{\n  return mod_attr_define(mrb, mod, attr_writer, prepare_writer_name);\n}\n\nstatic mrb_value\nmrb_instance_alloc(mrb_state *mrb, mrb_value cv)\n{\n  struct RClass *c = mrb_class_ptr(cv);\n  struct RObject *o;\n  enum mrb_vtype ttype = MRB_INSTANCE_TT(c);\n\n  if (c->tt == MRB_TT_SCLASS)\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't create instance of singleton class\");\n\n  if (ttype == 0) ttype = MRB_TT_OBJECT;\n  if (ttype <= MRB_TT_CPTR) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"can't create instance of %v\", cv);\n  }\n  o = (struct RObject*)mrb_obj_alloc(mrb, ttype, c);\n  return mrb_obj_value(o);\n}\n\n/*\n *  call-seq:\n *     class.new(args, ...)    ->  obj\n *\n *  Creates a new object of <i>class</i>'s class, then\n *  invokes that object's <code>initialize</code> method,\n *  passing it <i>args</i>. This is the method that ends\n *  up getting called whenever an object is constructed using\n *  `.new`.\n *\n */\n\nmrb_value\nmrb_instance_new(mrb_state *mrb, mrb_value cv)\n{\n  mrb_value obj, blk;\n  const mrb_value *argv;\n  mrb_int argc;\n  mrb_sym init;\n\n  mrb_get_args(mrb, \"*!&\", &argv, &argc, &blk);\n  obj = mrb_instance_alloc(mrb, cv);\n  init = MRB_SYM(initialize);\n  if (!mrb_func_basic_p(mrb, obj, init, mrb_do_nothing)) {\n    mrb_funcall_with_block(mrb, obj, init, argc, argv, blk);\n  }\n  return obj;\n}\n\nMRB_API mrb_value\nmrb_obj_new(mrb_state *mrb, struct RClass *c, mrb_int argc, const mrb_value *argv)\n{\n  mrb_value obj;\n  mrb_sym mid;\n\n  obj = mrb_instance_alloc(mrb, mrb_obj_value(c));\n  mid = MRB_SYM(initialize);\n  if (!mrb_func_basic_p(mrb, obj, mid, mrb_do_nothing)) {\n    mrb_funcall_argv(mrb, obj, mid, argc, argv);\n  }\n  return obj;\n}\n\nstatic mrb_value\nmrb_class_initialize(mrb_state *mrb, mrb_value c)\n{\n  mrb_value a, b;\n\n  mrb_get_args(mrb, \"|C&\", &a, &b);\n  if (!mrb_nil_p(b)) {\n    mrb_yield_with_class(mrb, b, 1, &c, c, mrb_class_ptr(c));\n  }\n  return c;\n}\n\nstatic mrb_value\nmrb_class_new_class(mrb_state *mrb, mrb_value cv)\n{\n  mrb_int n;\n  mrb_value super, blk;\n  mrb_value new_class;\n  mrb_sym mid;\n\n  n = mrb_get_args(mrb, \"|C&\", &super, &blk);\n  if (n == 0) {\n    super = mrb_obj_value(mrb->object_class);\n  }\n  new_class = mrb_obj_value(mrb_class_new(mrb, mrb_class_ptr(super)));\n  mid = MRB_SYM(initialize);\n  if (mrb_func_basic_p(mrb, new_class, mid, mrb_class_initialize)) {\n    mrb_class_initialize(mrb, new_class);\n  }\n  else {\n    mrb_funcall_with_block(mrb, new_class, mid, n, &super, blk);\n  }\n  mrb_class_inherited(mrb, mrb_class_ptr(super), mrb_class_ptr(new_class));\n  return new_class;\n}\n\nstatic mrb_value\nmrb_class_superclass(mrb_state *mrb, mrb_value klass)\n{\n  struct RClass *c;\n\n  c = mrb_class_ptr(klass);\n  c = find_origin(c)->super;\n  while (c && c->tt == MRB_TT_ICLASS) {\n    c = find_origin(c)->super;\n  }\n  if (!c) return mrb_nil_value();\n  return mrb_obj_value(c);\n}\n\nstatic mrb_value\nmrb_do_nothing(mrb_state *mrb, mrb_value cv)\n{\n  return mrb_nil_value();\n}\n\nstatic mrb_value\nmrb_bob_not(mrb_state *mrb, mrb_value cv)\n{\n  return mrb_bool_value(!mrb_test(cv));\n}\n\n/* 15.3.1.3.1  */\n/* 15.3.1.3.10 */\n/* 15.3.1.3.11 */\n/*\n *  call-seq:\n *     obj == other        -> true or false\n *     obj.equal?(other)   -> true or false\n *     obj.eql?(other)     -> true or false\n *\n *  Equality---At the <code>Object</code> level, <code>==</code> returns\n *  <code>true</code> only if <i>obj</i> and <i>other</i> are the\n *  same object. Typically, this method is overridden in descendant\n *  classes to provide class-specific meaning.\n *\n *  Unlike <code>==</code>, the <code>equal?</code> method should never be\n *  overridden by subclasses: it is used to determine object identity\n *  (that is, <code>a.equal?(b)</code> iff <code>a</code> is the same\n *  object as <code>b</code>).\n *\n *  The <code>eql?</code> method returns <code>true</code> if\n *  <i>obj</i> and <i>anObject</i> have the same value. Used by\n *  <code>Hash</code> to test members for equality.  For objects of\n *  class <code>Object</code>, <code>eql?</code> is synonymous with\n *  <code>==</code>. Subclasses normally continue this tradition, but\n *  there are exceptions. <code>Numeric</code> types, for example,\n *  perform type conversion across <code>==</code>, but not across\n *  <code>eql?</code>, so:\n *\n *     1 == 1.0     #=> true\n *     1.eql? 1.0   #=> false\n */\nmrb_value\nmrb_obj_equal_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_value arg = mrb_get_arg1(mrb);\n\n  return mrb_bool_value(mrb_obj_equal(mrb, self, arg));\n}\n\nMRB_API mrb_bool\nmrb_obj_respond_to(mrb_state *mrb, struct RClass* c, mrb_sym mid)\n{\n  mrb_method_t m;\n\n  m = mrb_method_search_vm(mrb, &c, mid);\n  if (MRB_METHOD_UNDEF_P(m)) {\n    return FALSE;\n  }\n  return TRUE;\n}\n\nMRB_API mrb_bool\nmrb_respond_to(mrb_state *mrb, mrb_value obj, mrb_sym mid)\n{\n  return mrb_obj_respond_to(mrb, mrb_class(mrb, obj), mid);\n}\n\nMRB_API mrb_value\nmrb_class_path(mrb_state *mrb, struct RClass *c)\n{\n  mrb_value path;\n  mrb_sym nsym = MRB_SYM(__classname__);\n\n  path = mrb_obj_iv_get(mrb, (struct RObject*)c, nsym);\n  if (mrb_nil_p(path)) {\n    /* no name (yet) */\n    return mrb_class_find_path(mrb, c);\n  }\n  else if (mrb_symbol_p(path)) {\n    /* toplevel class/module */\n    return mrb_sym_str(mrb, mrb_symbol(path));\n  }\n  return mrb_str_dup(mrb, path);\n}\n\nMRB_API struct RClass*\nmrb_class_real(struct RClass* cl)\n{\n  if (cl == 0) return NULL;\n  while ((cl->tt == MRB_TT_SCLASS) || (cl->tt == MRB_TT_ICLASS)) {\n    cl = cl->super;\n    if (cl == 0) return NULL;\n  }\n  return cl;\n}\n\nMRB_API const char*\nmrb_class_name(mrb_state *mrb, struct RClass* c)\n{\n  mrb_value name;\n\n  if (c == NULL) return NULL;\n  name = class_name_str(mrb, c);\n  return RSTRING_PTR(name);\n}\n\nMRB_API const char*\nmrb_obj_classname(mrb_state *mrb, mrb_value obj)\n{\n  return mrb_class_name(mrb, mrb_obj_class(mrb, obj));\n}\n\n/*!\n * Ensures a class can be derived from super.\n *\n * \\param super a reference to an object.\n * \\exception TypeError if \\a super is not a Class or \\a super is a singleton class.\n */\nstatic void\nmrb_check_inheritable(mrb_state *mrb, struct RClass *super)\n{\n  if (super->tt != MRB_TT_CLASS) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"superclass must be a Class (%C given)\", super);\n  }\n  if (super->tt == MRB_TT_SCLASS) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't make subclass of singleton class\");\n  }\n  if (super == mrb->class_class) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't make subclass of Class\");\n  }\n}\n\n/*!\n * Creates a new class.\n * \\param super     a class from which the new class derives.\n * \\exception TypeError \\a super is not inheritable.\n * \\exception TypeError \\a super is the Class class.\n */\nMRB_API struct RClass*\nmrb_class_new(mrb_state *mrb, struct RClass *super)\n{\n  struct RClass *c;\n\n  if (super) {\n    mrb_check_inheritable(mrb, super);\n  }\n  c = boot_defclass(mrb, super);\n  if (super) {\n    MRB_SET_INSTANCE_TT(c, MRB_INSTANCE_TT(super));\n  }\n  make_metaclass(mrb, c);\n\n  return c;\n}\n\n/*!\n * Creates a new module.\n */\nMRB_API struct RClass*\nmrb_module_new(mrb_state *mrb)\n{\n  struct RClass *m = MRB_OBJ_ALLOC(mrb, MRB_TT_MODULE, mrb->module_class);\n  boot_initmod(mrb, m);\n  return m;\n}\n\n/*\n *  call-seq:\n *     obj.class    => class\n *\n *  Returns the class of <i>obj</i>, now preferred over\n *  <code>Object#type</code>, as an object's type in Ruby is only\n *  loosely tied to that object's class. This method must always be\n *  called with an explicit receiver, as <code>class</code> is also a\n *  reserved word in Ruby.\n *\n *     1.class      #=> Integer\n *     self.class   #=> Object\n */\n\nMRB_API struct RClass*\nmrb_obj_class(mrb_state *mrb, mrb_value obj)\n{\n  return mrb_class_real(mrb_class(mrb, obj));\n}\n\nMRB_API void\nmrb_alias_method(mrb_state *mrb, struct RClass *c, mrb_sym a, mrb_sym b)\n{\n  if (a == b) return;\n  mrb_method_t m = mrb_method_search(mrb, c, b);\n\n  if (!MRB_METHOD_CFUNC_P(m)) {\n    struct RProc *p = MRB_METHOD_PROC(m);\n\n    if (MRB_PROC_ENV_P(p)) {\n      MRB_PROC_ENV(p)->mid = b;\n    }\n    else if (p->color != MRB_GC_RED) {\n      struct RClass *tc = MRB_PROC_TARGET_CLASS(p);\n      struct REnv *e = MRB_OBJ_ALLOC(mrb, MRB_TT_ENV, NULL);\n\n      e->mid = b;\n      if (tc) {\n        e->c = tc;\n        mrb_field_write_barrier(mrb, (struct RBasic*)e, (struct RBasic*)tc);\n      }\n      p->e.env = e;\n      p->flags |= MRB_PROC_ENVSET;\n      mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)e);\n    }\n  }\n  mrb_define_method_raw(mrb, c, a, m);\n}\n\n/*!\n * Defines an alias of a method.\n * \\param mrb    the mruby state\n * \\param klass  the class which the original method belongs to\n * \\param name1  a new name for the method\n * \\param name2  the original name of the method\n */\nMRB_API void\nmrb_define_alias(mrb_state *mrb, struct RClass *klass, const char *name1, const char *name2)\n{\n  mrb_alias_method(mrb, klass, mrb_intern_cstr(mrb, name1), mrb_intern_cstr(mrb, name2));\n}\n\nMRB_API void\nmrb_define_alias_id(mrb_state *mrb, struct RClass *klass, mrb_sym a, mrb_sym b)\n{\n  mrb_alias_method(mrb, klass, a, b);\n}\n\n/*\n * call-seq:\n *   mod.to_s   -> string\n *\n * Return a string representing this module or class. For basic\n * classes and modules, this is the name. For singletons, we\n * show information on the thing we're attached to as well.\n */\n\nmrb_value\nmrb_mod_to_s(mrb_state *mrb, mrb_value klass)\n{\n  if (mrb_sclass_p(klass)) {\n    mrb_value v = mrb_iv_get(mrb, klass, MRB_SYM(__attached__));\n    mrb_value str = mrb_str_new_lit(mrb, \"#<Class:\");\n\n    if (class_ptr_p(v)) {\n      mrb_str_cat_str(mrb, str, mrb_inspect(mrb, v));\n    }\n    else {\n      mrb_str_cat_str(mrb, str, mrb_any_to_s(mrb, v));\n    }\n    return mrb_str_cat_lit(mrb, str, \">\");\n  }\n  else {\n    return class_name_str(mrb, mrb_class_ptr(klass));\n  }\n}\n\nstatic mrb_value\nmrb_mod_alias(mrb_state *mrb, mrb_value mod)\n{\n  struct RClass *c = mrb_class_ptr(mod);\n  mrb_sym new_name, old_name;\n\n  mrb_get_args(mrb, \"nn\", &new_name, &old_name);\n  mrb_alias_method(mrb, c, new_name, old_name);\n  mrb_method_added(mrb, c, new_name);\n  return mod;\n}\n\nstatic void\nundef_method(mrb_state *mrb, struct RClass *c, mrb_sym a)\n{\n  mrb_method_t m;\n\n  MRB_METHOD_FROM_PROC(m, NULL);\n  mrb_define_method_raw(mrb, c, a, m);\n}\n\nMRB_API void\nmrb_undef_method_id(mrb_state *mrb, struct RClass *c, mrb_sym a)\n{\n  if (!mrb_obj_respond_to(mrb, c, a)) {\n    mrb_name_error(mrb, a, \"undefined method '%n' for class '%C'\", a, c);\n  }\n  undef_method(mrb, c, a);\n}\n\nMRB_API void\nmrb_undef_method(mrb_state *mrb, struct RClass *c, const char *name)\n{\n  undef_method(mrb, c, mrb_intern_cstr(mrb, name));\n}\n\nMRB_API void\nmrb_undef_class_method_id(mrb_state *mrb, struct RClass *c, mrb_sym name)\n{\n  mrb_undef_method_id(mrb,  mrb_class_ptr(mrb_singleton_class(mrb, mrb_obj_value(c))), name);\n}\n\nMRB_API void\nmrb_undef_class_method(mrb_state *mrb, struct RClass *c, const char *name)\n{\n  mrb_undef_method(mrb,  mrb_class_ptr(mrb_singleton_class(mrb, mrb_obj_value(c))), name);\n}\n\nMRB_API void\nmrb_remove_method(mrb_state *mrb, struct RClass *c, mrb_sym mid)\n{\n  mt_tbl *h;\n\n  MRB_CLASS_ORIGIN(c);\n  h = c->mt;\n\n  if (h && mt_del(mrb, h, mid)) {\n    mrb_mc_clear_by_class(mrb, c);\n    return;\n  }\n  mrb_name_error(mrb, mid, \"method '%n' not defined in %C\", mid, c);\n}\n\nstatic mrb_value\nmrb_mod_undef(mrb_state *mrb, mrb_value mod)\n{\n  struct RClass *c = mrb_class_ptr(mod);\n  mrb_int argc;\n  const mrb_value *argv;\n\n  mrb_get_args(mrb, \"*\", &argv, &argc);\n  while (argc--) {\n    mrb_undef_method_id(mrb, c, to_sym(mrb, *argv));\n    argv++;\n  }\n  return mrb_nil_value();\n}\n\nstatic void\ncheck_const_name_sym(mrb_state *mrb, mrb_sym id)\n{\n  mrb_int len;\n  const char *name = mrb_sym_name_len(mrb, id, &len);\n  if (!mrb_const_name_p(mrb, name, len)) {\n    mrb_name_error(mrb, id, \"wrong constant name %n\", id);\n  }\n}\n\nstatic mrb_value\nmrb_mod_const_defined(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym id;\n  mrb_bool inherit = TRUE;\n\n  mrb_get_args(mrb, \"n|b\", &id, &inherit);\n  check_const_name_sym(mrb, id);\n  if (inherit) {\n    return mrb_bool_value(mrb_const_defined(mrb, mod, id));\n  }\n  return mrb_bool_value(mrb_const_defined_at(mrb, mod, id));\n}\n\nstatic mrb_value\nmrb_const_get_sym(mrb_state *mrb, mrb_value mod, mrb_sym id)\n{\n  check_const_name_sym(mrb, id);\n  return mrb_const_get(mrb, mod, id);\n}\n\nstatic mrb_value\nmrb_mod_const_get(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value path = mrb_get_arg1(mrb);\n  mrb_sym id;\n  char *ptr;\n  mrb_int off, end, len;\n\n  if (mrb_symbol_p(path)) {\n    /* const get with symbol */\n    id = mrb_symbol(path);\n    return mrb_const_get_sym(mrb, mod, id);\n  }\n\n  /* const get with class path string */\n  mrb_ensure_string_type(mrb, path);\n  ptr = RSTRING_PTR(path);\n  len = RSTRING_LEN(path);\n  off = 0;\n\n  while (off < len) {\n    end = mrb_str_index_lit(mrb, path, \"::\", off);\n    end = (end == -1) ? len : end;\n    id = mrb_intern(mrb, ptr+off, end-off);\n    mod = mrb_const_get_sym(mrb, mod, id);\n    if (end == len)\n      off = end;\n    else {\n      off = end + 2;\n      if (off == len) {         /* trailing \"::\" */\n        mrb_name_error(mrb, id, \"wrong constant name '%v'\", path);\n      }\n    }\n  }\n\n  return mod;\n}\n\nstatic mrb_value\nmrb_mod_const_set(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym id;\n  mrb_value value;\n\n  mrb_get_args(mrb, \"no\", &id, &value);\n  check_const_name_sym(mrb, id);\n  mrb_const_set(mrb, mod, id, value);\n  return value;\n}\n\nstatic mrb_value\nmrb_mod_remove_const(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym id;\n  mrb_value val;\n\n  mrb_get_args(mrb, \"n\", &id);\n  check_const_name_sym(mrb, id);\n  val = mrb_iv_remove(mrb, mod, id);\n  if (mrb_undef_p(val)) {\n    mrb_name_error(mrb, id, \"constant %n not defined\", id);\n  }\n  return val;\n}\n\nstatic mrb_value\nmrb_mod_const_missing(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym sym;\n\n  mrb_get_args(mrb, \"n\", &sym);\n  mrb->c->ci->mid = 0;\n\n  if (mrb_class_real(mrb_class_ptr(mod)) != mrb->object_class) {\n    mrb_name_error(mrb, sym, \"uninitialized constant %v::%n\", mod, sym);\n  }\n  else {\n    mrb_name_error(mrb, sym, \"uninitialized constant %n\", sym);\n  }\n  /* not reached */\n  return mrb_nil_value();\n}\n\n/* 15.2.2.4.34 */\n/*\n *  call-seq:\n *     mod.method_defined?(symbol)    -> true or false\n *\n *  Returns +true+ if the named method is defined by\n *  _mod_ (or its included modules and, if _mod_ is a class,\n *  its ancestors). Public and protected methods are matched.\n *\n *     module A\n *       def method1()  end\n *     end\n *     class B\n *       def method2()  end\n *     end\n *     class C < B\n *       include A\n *       def method3()  end\n *     end\n *\n *     A.method_defined? :method1    #=> true\n *     C.method_defined? \"method1\"   #=> true\n *     C.method_defined? \"method2\"   #=> true\n *     C.method_defined? \"method3\"   #=> true\n *     C.method_defined? \"method4\"   #=> false\n */\n\nstatic mrb_value\nmrb_mod_method_defined(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym id;\n\n  mrb_get_args(mrb, \"n\", &id);\n  return mrb_bool_value(mrb_obj_respond_to(mrb, mrb_class_ptr(mod), id));\n}\n\nvoid\nmrb_method_added(mrb_state *mrb, struct RClass *c, mrb_sym mid)\n{\n  mrb_sym added;\n  mrb_value recv = mrb_obj_value(c);\n\n  if (c->tt == MRB_TT_SCLASS) {\n    added = MRB_SYM(singleton_method_added);\n    recv = mrb_iv_get(mrb, recv, MRB_SYM(__attached__));\n  }\n  else {\n    added = MRB_SYM(method_added);\n  }\n  mrb_funcall_id(mrb, recv, added, 1, mrb_symbol_value(mid));\n}\n\nmrb_value\nmrb_mod_define_method_m(mrb_state *mrb, struct RClass *c)\n{\n  struct RProc *p;\n  mrb_method_t m;\n  mrb_sym mid;\n  mrb_value proc = mrb_undef_value();\n  mrb_value blk;\n\n  mrb_get_args(mrb, \"n|o&\", &mid, &proc, &blk);\n  switch (mrb_type(proc)) {\n    case MRB_TT_PROC:\n      blk = proc;\n      break;\n    case MRB_TT_UNDEF:\n      /* ignored */\n      break;\n    default:\n      mrb_raisef(mrb, E_TYPE_ERROR, \"wrong argument type %T (expected Proc)\", proc);\n      break;\n  }\n  if (mrb_nil_p(blk)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"no block given\");\n  }\n  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb->proc_class);\n  mrb_proc_copy(mrb, p, mrb_proc_ptr(blk));\n  p->flags |= MRB_PROC_STRICT;\n  MRB_METHOD_FROM_PROC(m, p);\n  mrb_define_method_raw(mrb, c, mid, m);\n  mrb_method_added(mrb, c, mid);\n  return mrb_symbol_value(mid);\n}\n\nstatic mrb_value\nmod_define_method(mrb_state *mrb, mrb_value self)\n{\n  return mrb_mod_define_method_m(mrb, mrb_class_ptr(self));\n}\n\nstatic mrb_value\ntop_define_method(mrb_state *mrb, mrb_value self)\n{\n  return mrb_mod_define_method_m(mrb, mrb->object_class);\n}\n\nstatic mrb_value\nmrb_mod_eqq(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value obj = mrb_get_arg1(mrb);\n  mrb_bool eqq;\n\n  eqq = mrb_obj_is_kind_of(mrb, obj, mrb_class_ptr(mod));\n\n  return mrb_bool_value(eqq);\n}\n\nstatic mrb_value\nmrb_mod_dup(mrb_state *mrb, mrb_value self)\n{\n  mrb_value mod = mrb_obj_clone(mrb, self);\n  MRB_UNSET_FROZEN_FLAG(mrb_obj_ptr(mod));\n  return mod;\n}\n\nstatic mrb_value\nmrb_mod_module_function(mrb_state *mrb, mrb_value mod)\n{\n  const mrb_value *argv;\n  mrb_int argc, i;\n  mrb_sym mid;\n  mrb_method_t m;\n  struct RClass *rclass;\n  int ai;\n\n  mrb_check_type(mrb, mod, MRB_TT_MODULE);\n\n  mrb_get_args(mrb, \"*\", &argv, &argc);\n  if (argc == 0) {\n    /* set MODFUNC SCOPE if implemented */\n    return mod;\n  }\n\n  /* set PRIVATE method visibility if implemented */\n  /* mrb_mod_dummy_visibility(mrb, mod); */\n\n  for (i=0; i<argc; i++) {\n    mrb_check_type(mrb, argv[i], MRB_TT_SYMBOL);\n\n    mid = mrb_symbol(argv[i]);\n    rclass = mrb_class_ptr(mod);\n    m = mrb_method_search(mrb, rclass, mid);\n\n    prepare_singleton_class(mrb, (struct RBasic*)rclass);\n    ai = mrb_gc_arena_save(mrb);\n    mrb_define_method_raw(mrb, rclass->c, mid, m);\n    mrb_gc_arena_restore(mrb, ai);\n  }\n\n  return mod;\n}\n\nstatic struct RClass*\nmrb_singleton_class_clone(mrb_state *mrb, mrb_value obj)\n{\n  struct RClass *klass = mrb_basic_ptr(obj)->c;\n\n  if (klass->tt != MRB_TT_SCLASS)\n    return klass;\n  else {\n    /* copy singleton(unnamed) class */\n    struct RClass *clone = (struct RClass*)mrb_obj_alloc(mrb, klass->tt, mrb->class_class);\n\n    switch (mrb_type(obj)) {\n    case MRB_TT_CLASS:\n    case MRB_TT_SCLASS:\n      break;\n    default:\n      clone->c = mrb_singleton_class_clone(mrb, mrb_obj_value(klass));\n      break;\n    }\n    clone->super = klass->super;\n    if (klass->iv) {\n      mrb_iv_copy(mrb, mrb_obj_value(clone), mrb_obj_value(klass));\n      mrb_obj_iv_set(mrb, (struct RObject*)clone, MRB_SYM(__attached__), obj);\n    }\n    if (klass->mt) {\n      clone->mt = mt_copy(mrb, klass->mt);\n    }\n    else {\n      clone->mt = mt_new(mrb);\n    }\n    clone->tt = MRB_TT_SCLASS;\n    return clone;\n  }\n}\n\nstatic void\ncopy_class(mrb_state *mrb, mrb_value dst, mrb_value src)\n{\n  struct RClass *dc = mrb_class_ptr(dst);\n  struct RClass *sc = mrb_class_ptr(src);\n  /* if the origin is not the same as the class, then the origin and\n     the current class need to be copied */\n  if (sc->flags & MRB_FL_CLASS_IS_PREPENDED) {\n    struct RClass *c0 = sc->super;\n    struct RClass *c1 = dc;\n\n    /* copy prepended iclasses */\n    while (!(c0->flags & MRB_FL_CLASS_IS_ORIGIN)) {\n      c1->super = mrb_class_ptr(mrb_obj_dup(mrb, mrb_obj_value(c0)));\n      c1 = c1->super;\n      c0 = c0->super;\n    }\n    c1->super = mrb_class_ptr(mrb_obj_dup(mrb, mrb_obj_value(c0)));\n    c1->super->flags |= MRB_FL_CLASS_IS_ORIGIN;\n  }\n  if (sc->mt) {\n    dc->mt = mt_copy(mrb, sc->mt);\n  }\n  else {\n    dc->mt = mt_new(mrb);\n  }\n  dc->super = sc->super;\n  MRB_SET_INSTANCE_TT(dc, MRB_INSTANCE_TT(sc));\n}\n\n/* 15.3.1.3.16 */\nstatic mrb_value\nmrb_obj_init_copy(mrb_state *mrb, mrb_value self)\n{\n  mrb_value orig = mrb_get_arg1(mrb);\n\n  if (mrb_obj_equal(mrb, self, orig)) return self;\n  if ((mrb_type(self) != mrb_type(orig)) || (mrb_obj_class(mrb, self) != mrb_obj_class(mrb, orig))) {\n      mrb_raise(mrb, E_TYPE_ERROR, \"initialize_copy should take same class object\");\n  }\n  return self;\n}\n\nstatic void\ninit_copy(mrb_state *mrb, mrb_value dest, mrb_value obj)\n{\n  switch (mrb_type(obj)) {\n    case MRB_TT_ICLASS:\n      copy_class(mrb, dest, obj);\n      return;\n    case MRB_TT_CLASS:\n    case MRB_TT_MODULE:\n      copy_class(mrb, dest, obj);\n      mrb_iv_copy(mrb, dest, obj);\n      mrb_iv_remove(mrb, dest, MRB_SYM(__classname__));\n      break;\n    case MRB_TT_OBJECT:\n    case MRB_TT_SCLASS:\n    case MRB_TT_HASH:\n    case MRB_TT_DATA:\n    case MRB_TT_EXCEPTION:\n      mrb_iv_copy(mrb, dest, obj);\n      break;\n    case MRB_TT_ISTRUCT:\n      mrb_istruct_copy(dest, obj);\n      break;\n\n    default:\n      break;\n  }\n  if (!mrb_func_basic_p(mrb, dest, MRB_SYM(initialize_copy), mrb_obj_init_copy)) {\n    mrb_funcall_id(mrb, dest, MRB_SYM(initialize_copy), 1, obj);\n  }\n}\n\n/* 15.3.1.3.8  */\n/*\n *  call-seq:\n *     obj.clone -> an_object\n *\n *  Produces a shallow copy of <i>obj</i>---the instance variables of\n *  <i>obj</i> are copied, but not the objects they reference. Copies\n *  the frozen state of <i>obj</i>. See also the discussion\n *  under <code>Object#dup</code>.\n *\n *     class Klass\n *        attr_accessor :str\n *     end\n *     s1 = Klass.new      #=> #<Klass:0x401b3a38>\n *     s1.str = \"Hello\"    #=> \"Hello\"\n *     s2 = s1.clone       #=> #<Klass:0x401b3998 @str=\"Hello\">\n *     s2.str[1,4] = \"i\"   #=> \"i\"\n *     s1.inspect          #=> \"#<Klass:0x401b3a38 @str=\\\"Hi\\\">\"\n *     s2.inspect          #=> \"#<Klass:0x401b3998 @str=\\\"Hi\\\">\"\n *\n *  This method may have class-specific behavior.  If so, that\n *  behavior will be documented under the #+initialize_copy+ method of\n *  the class.\n *\n *  Some Class(True False Nil Symbol Integer Float) Object  cannot clone.\n */\nMRB_API mrb_value\nmrb_obj_clone(mrb_state *mrb, mrb_value self)\n{\n  struct RObject *p;\n  mrb_value clone;\n\n  if (mrb_immediate_p(self)) {\n    return self;\n  }\n  if (mrb_sclass_p(self)) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't clone singleton class\");\n  }\n  p = (struct RObject*)mrb_obj_alloc(mrb, mrb_type(self), mrb_obj_class(mrb, self));\n  p->c = mrb_singleton_class_clone(mrb, self);\n  mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)p->c);\n  clone = mrb_obj_value(p);\n  init_copy(mrb, clone, self);\n  p->flags |= mrb_obj_ptr(self)->flags & MRB_FL_OBJ_IS_FROZEN;\n\n  return clone;\n}\n\n/* 15.3.1.3.9  */\n/*\n *  call-seq:\n *     obj.dup -> an_object\n *\n *  Produces a shallow copy of <i>obj</i>---the instance variables of\n *  <i>obj</i> are copied, but not the objects they reference.\n *  <code>dup</code> copies the frozen state of <i>obj</i>. See also\n *  the discussion under <code>Object#clone</code>. In general,\n *  <code>clone</code> and <code>dup</code> may have different semantics\n *  in descendant classes. While <code>clone</code> is used to duplicate\n *  an object, including its internal state, <code>dup</code> typically\n *  uses the class of the descendant object to create the new instance.\n *\n *  This method may have class-specific behavior.  If so, that\n *  behavior will be documented under the #+initialize_copy+ method of\n *  the class.\n */\n\nMRB_API mrb_value\nmrb_obj_dup(mrb_state *mrb, mrb_value obj)\n{\n  struct RBasic *p;\n  mrb_value dup;\n\n  if (mrb_immediate_p(obj)) {\n    return obj;\n  }\n  if (mrb_sclass_p(obj)) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't dup singleton class\");\n  }\n  p = mrb_obj_alloc(mrb, mrb_type(obj), mrb_obj_class(mrb, obj));\n  dup = mrb_obj_value(p);\n  init_copy(mrb, dup, obj);\n\n  return dup;\n}\n\n/* implementation of __id__ */\nmrb_value mrb_obj_id_m(mrb_state *mrb, mrb_value self);\n/* implementation of instance_eval */\nmrb_value mrb_obj_instance_eval(mrb_state*, mrb_value);\n\nstatic mrb_value\ninspect_main(mrb_state *mrb, mrb_value mod)\n{\n  return mrb_str_new_lit(mrb, \"main\");\n}\n\nstatic const mrb_code new_iseq[] = {\n  OP_ENTER, 0x0, 0x10, 0x3,  // OP_ENTER     0:0:1:0:0:1:1\n  OP_LOADSELF, 4,            // OP_LOADSELF  R4\n  OP_SEND, 4, 0, 0,          // OP_SEND      R4  :allocate  n=0\n  OP_MOVE, 0, 4,             // OP_MOVE      R0  R4\n  OP_MOVE, 4, 3,             // OP_MOVE      R4  R3 (&)\n  OP_MOVE, 3, 2,             // OP_MOVE      R3  R2 (**)\n  OP_MOVE, 2, 1,             // OP_MOVE      R2  R1 (*)\n  OP_SSENDB, 1, 1, 255,      // OP_SSENDB    R1  :initialize n=*|nk=*\n  OP_RETURN, 0               // OP_RETURN    R0\n};\n\nMRB_PRESYM_DEFINE_VAR_AND_INITER(new_syms, 2, MRB_SYM(allocate), MRB_SYM(initialize))\n\nstatic const mrb_irep new_irep = {\n  4, 5, 0, MRB_IREP_STATIC,\n  new_iseq, NULL, new_syms, NULL, NULL, NULL,\n  sizeof(new_iseq), 0, 2, 0, 0,\n};\n\nstatic const struct RProc new_proc = {\n  NULL, NULL, MRB_TT_PROC, MRB_GC_RED, MRB_FL_OBJ_IS_FROZEN | MRB_PROC_SCOPE | MRB_PROC_STRICT,\n  { &new_irep }, NULL, { NULL }\n};\n\nstatic void\ninit_class_new(mrb_state *mrb, struct RClass *cls)\n{\n  mrb_method_t m;\n\n  MRB_PRESYM_INIT_SYMBOLS(mrb, new_syms);\n  MRB_METHOD_FROM_PROC(m, &new_proc);\n  mrb_define_method_raw(mrb, cls, MRB_SYM(new), m);\n}\n\n/* implementation of #send method */\nmrb_value mrb_f_send(mrb_state *mrb, mrb_value self);\n\nvoid\nmrb_init_class(mrb_state *mrb)\n{\n  struct RClass *bob;           /* BasicObject */\n  struct RClass *obj;           /* Object */\n  struct RClass *mod;           /* Module */\n  struct RClass *cls;           /* Class */\n\n  /* boot class hierarchy */\n  bob = boot_defclass(mrb, 0);\n  obj = boot_defclass(mrb, bob); mrb->object_class = obj;\n  mod = boot_defclass(mrb, obj); mrb->module_class = mod;/* obj -> mod */\n  cls = boot_defclass(mrb, mod); mrb->class_class = cls; /* obj -> cls */\n  /* fix-up loose ends */\n  bob->c = obj->c = mod->c = cls->c = cls;\n  make_metaclass(mrb, bob);\n  make_metaclass(mrb, obj);\n  make_metaclass(mrb, mod);\n  make_metaclass(mrb, cls);\n\n  /* name basic classes */\n  mrb_define_const_id(mrb, bob, MRB_SYM(BasicObject), mrb_obj_value(bob));\n  mrb_define_const_id(mrb, obj, MRB_SYM(Object),      mrb_obj_value(obj));\n  mrb_define_const_id(mrb, obj, MRB_SYM(Module),      mrb_obj_value(mod));\n  mrb_define_const_id(mrb, obj, MRB_SYM(Class),       mrb_obj_value(cls));\n\n  /* name each classes */\n  mrb_class_name_class(mrb, NULL, bob, MRB_SYM(BasicObject));\n  mrb_class_name_class(mrb, NULL, obj, MRB_SYM(Object)); /* 15.2.1 */\n  mrb_class_name_class(mrb, NULL, mod, MRB_SYM(Module)); /* 15.2.2 */\n  mrb_class_name_class(mrb, NULL, cls, MRB_SYM(Class));  /* 15.2.3 */\n\n  mrb->proc_class = mrb_define_class(mrb, \"Proc\", mrb->object_class);  /* 15.2.17 */\n  MRB_SET_INSTANCE_TT(mrb->proc_class, MRB_TT_PROC);\n\n  MRB_SET_INSTANCE_TT(cls, MRB_TT_CLASS);\n  mrb_define_method(mrb, bob, \"initialize\",              mrb_do_nothing,           MRB_ARGS_NONE());\n  mrb_define_method(mrb, bob, \"!\",                       mrb_bob_not,              MRB_ARGS_NONE());\n  mrb_define_method(mrb, bob, \"==\",                      mrb_obj_equal_m,          MRB_ARGS_REQ(1)); /* 15.3.1.3.1  */\n  mrb_define_method(mrb, bob, \"__id__\",                  mrb_obj_id_m,             MRB_ARGS_NONE()); /* 15.3.1.3.4  */\n  mrb_define_method(mrb, bob, \"__send__\",                mrb_f_send,               MRB_ARGS_REQ(1)|MRB_ARGS_REST()|MRB_ARGS_BLOCK());  /* 15.3.1.3.5  */\n  mrb_define_method(mrb, bob, \"equal?\",                  mrb_obj_equal_m,          MRB_ARGS_REQ(1)); /* 15.3.1.3.11 */\n  mrb_define_method(mrb, bob, \"instance_eval\",           mrb_obj_instance_eval,    MRB_ARGS_OPT(1)|MRB_ARGS_BLOCK());  /* 15.3.1.3.18 */\n  mrb_define_method(mrb, bob, \"singleton_method_added\",  mrb_do_nothing,           MRB_ARGS_REQ(1));\n\n  mrb_define_class_method(mrb, cls, \"new\",               mrb_class_new_class,      MRB_ARGS_OPT(1)|MRB_ARGS_BLOCK());\n  mrb_define_method(mrb, cls, \"allocate\",                mrb_instance_alloc,       MRB_ARGS_NONE());\n  mrb_define_method(mrb, cls, \"superclass\",              mrb_class_superclass,     MRB_ARGS_NONE()); /* 15.2.3.3.4 */\n  mrb_define_method(mrb, cls, \"initialize\",              mrb_class_initialize,     MRB_ARGS_OPT(1)); /* 15.2.3.3.1 */\n  mrb_define_method(mrb, cls, \"inherited\",               mrb_do_nothing,           MRB_ARGS_REQ(1));\n\n  init_class_new(mrb, cls);\n\n  MRB_SET_INSTANCE_TT(mod, MRB_TT_MODULE);\n  mrb_define_method(mrb, mod, \"extend_object\",           mrb_mod_extend_object,    MRB_ARGS_REQ(1)); /* 15.2.2.4.25 */\n  mrb_define_method(mrb, mod, \"extended\",                mrb_do_nothing,           MRB_ARGS_REQ(1)); /* 15.2.2.4.26 */\n  mrb_define_method(mrb, mod, \"prepended\",               mrb_do_nothing,           MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, mod, \"prepend_features\",        mrb_mod_prepend_features, MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, mod, \"include?\",                mrb_mod_include_p,        MRB_ARGS_REQ(1)); /* 15.2.2.4.28 */\n  mrb_define_method(mrb, mod, \"append_features\",         mrb_mod_append_features,  MRB_ARGS_REQ(1)); /* 15.2.2.4.10 */\n  mrb_define_method(mrb, mod, \"class_eval\",              mrb_mod_module_eval,      MRB_ARGS_ANY());  /* 15.2.2.4.15 */\n  mrb_define_method(mrb, mod, \"included\",                mrb_do_nothing,           MRB_ARGS_REQ(1)); /* 15.2.2.4.29 */\n  mrb_define_method(mrb, mod, \"initialize\",              mrb_mod_initialize,       MRB_ARGS_NONE()); /* 15.2.2.4.31 */\n  mrb_define_method(mrb, mod, \"module_eval\",             mrb_mod_module_eval,      MRB_ARGS_ANY());  /* 15.2.2.4.35 */\n  mrb_define_method(mrb, mod, \"module_function\",         mrb_mod_module_function,  MRB_ARGS_ANY());\n  mrb_define_method(mrb, mod, \"private\",                 mrb_mod_dummy_visibility, MRB_ARGS_ANY());  /* 15.2.2.4.36 */\n  mrb_define_method(mrb, mod, \"protected\",               mrb_mod_dummy_visibility, MRB_ARGS_ANY());  /* 15.2.2.4.37 */\n  mrb_define_method(mrb, mod, \"public\",                  mrb_mod_dummy_visibility, MRB_ARGS_ANY());  /* 15.2.2.4.38 */\n  mrb_define_method(mrb, mod, \"attr_reader\",             mrb_mod_attr_reader,      MRB_ARGS_ANY());  /* 15.2.2.4.13 */\n  mrb_define_method(mrb, mod, \"attr_writer\",             mrb_mod_attr_writer,      MRB_ARGS_ANY());  /* 15.2.2.4.14 */\n  mrb_define_method(mrb, mod, \"to_s\",                    mrb_mod_to_s,             MRB_ARGS_NONE());\n  mrb_define_method(mrb, mod, \"inspect\",                 mrb_mod_to_s,             MRB_ARGS_NONE());\n  mrb_define_method(mrb, mod, \"alias_method\",            mrb_mod_alias,            MRB_ARGS_ANY());  /* 15.2.2.4.8 */\n  mrb_define_method(mrb, mod, \"ancestors\",               mrb_mod_ancestors,        MRB_ARGS_NONE()); /* 15.2.2.4.9 */\n  mrb_define_method(mrb, mod, \"undef_method\",            mrb_mod_undef,            MRB_ARGS_ANY());  /* 15.2.2.4.41 */\n  mrb_define_method(mrb, mod, \"const_defined?\",          mrb_mod_const_defined,    MRB_ARGS_ARG(1,1)); /* 15.2.2.4.20 */\n  mrb_define_method(mrb, mod, \"const_get\",               mrb_mod_const_get,        MRB_ARGS_REQ(1)); /* 15.2.2.4.21 */\n  mrb_define_method(mrb, mod, \"const_set\",               mrb_mod_const_set,        MRB_ARGS_REQ(2)); /* 15.2.2.4.23 */\n  mrb_define_method(mrb, mod, \"remove_const\",            mrb_mod_remove_const,     MRB_ARGS_REQ(1)); /* 15.2.2.4.40 */\n  mrb_define_method(mrb, mod, \"const_missing\",           mrb_mod_const_missing,    MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, mod, \"method_defined?\",         mrb_mod_method_defined,   MRB_ARGS_REQ(1)); /* 15.2.2.4.34 */\n  mrb_define_method(mrb, mod, \"define_method\",           mod_define_method,        MRB_ARGS_ARG(1,1));\n  mrb_define_method(mrb, mod, \"===\",                     mrb_mod_eqq,              MRB_ARGS_REQ(1)); /* 15.2.2.4.7 */\n  mrb_define_method(mrb, mod, \"dup\",                     mrb_mod_dup,              MRB_ARGS_NONE());\n  mrb_define_method(mrb, bob, \"method_added\",            mrb_do_nothing,           MRB_ARGS_REQ(1));\n\n  mrb_undef_method(mrb, cls, \"append_features\");\n  mrb_undef_method(mrb, cls, \"prepend_features\");\n  mrb_undef_method(mrb, cls, \"extend_object\");\n  mrb_undef_method(mrb, cls, \"module_function\");\n\n  mrb->top_self = MRB_OBJ_ALLOC(mrb, MRB_TT_OBJECT, mrb->object_class);\n  mrb_define_singleton_method(mrb, mrb->top_self, \"inspect\", inspect_main, MRB_ARGS_NONE());\n  mrb_define_singleton_method(mrb, mrb->top_self, \"to_s\", inspect_main, MRB_ARGS_NONE());\n  mrb_define_singleton_method(mrb, mrb->top_self, \"define_method\", top_define_method, MRB_ARGS_ARG(1,1));\n}\n"], "filenames": ["src/class.c"], "buggy_code_start_loc": [2364], "buggy_code_end_loc": [2365], "fixing_code_start_loc": [2364], "fixing_code_end_loc": [2368], "type": "CWE-787", "message": "heap-buffer-overflow in mrb_vm_exec in mruby/mruby in GitHub repository mruby/mruby prior to 3.2. Possible arbitrary code execution if being exploited.", "other": {"cve": {"id": "CVE-2022-1286", "sourceIdentifier": "security@huntr.dev", "published": "2022-04-10T11:15:07.690", "lastModified": "2022-04-18T14:51:16.803", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "heap-buffer-overflow in mrb_vm_exec in mruby/mruby in GitHub repository mruby/mruby prior to 3.2. Possible arbitrary code execution if being exploited."}, {"lang": "es", "value": "Un desbordamiento del b\u00fafer de la pila en la funci\u00f3n mrb_vm_exec en mruby/mruby en el repositorio GitHub mruby/mruby versiones anteriores a 3.2. Una posible ejecuci\u00f3n de c\u00f3digo arbitrario si es explotado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mruby:mruby:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.2", "matchCriteriaId": "36DC54A6-4938-4623-8742-FF7C35178328"}]}]}], "references": [{"url": "https://github.com/mruby/mruby/commit/b1d0296a937fe278239bdfac840a3fd0e93b3ee9", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/f918376e-b488-4113-963d-ffe8716e4189", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mruby/mruby/commit/b1d0296a937fe278239bdfac840a3fd0e93b3ee9"}}