{"buggy_code": ["import filecmp\nimport os\nfrom typing import Any, Dict, List, Mapping, Optional\nfrom unittest.mock import MagicMock, patch\n\nimport orjson\nfrom django.core import mail\nfrom django.test import override_settings\nfrom zulip_bots.custom_exceptions import ConfigValidationError\n\nfrom zerver.actions.realm_settings import do_set_realm_property\nfrom zerver.actions.streams import do_change_stream_permission\nfrom zerver.actions.users import do_change_can_create_users, do_change_user_role, do_deactivate_user\nfrom zerver.lib.bot_config import ConfigError, get_bot_config\nfrom zerver.lib.bot_lib import get_bot_handler\nfrom zerver.lib.integrations import EMBEDDED_BOTS, WebhookIntegration\nfrom zerver.lib.test_classes import UploadSerializeMixin, ZulipTestCase\nfrom zerver.lib.test_helpers import avatar_disk_path, get_test_image_file, queries_captured\nfrom zerver.models import (\n    Realm,\n    Service,\n    UserProfile,\n    get_bot_services,\n    get_realm,\n    get_stream,\n    get_user,\n    is_cross_realm_bot_email,\n)\n\n\n# A test validator\ndef _check_string(var_name: str, val: str) -> Optional[str]:\n    if val.startswith(\"_\"):\n        return f'{var_name} starts with a \"_\" and is hence invalid.'\n    return None\n\n\nstripe_sample_config_options = [\n    WebhookIntegration(\n        \"stripe\",\n        [\"financial\"],\n        display_name=\"Stripe\",\n        config_options=[(\"Stripe API key\", \"stripe_api_key\", _check_string)],\n    ),\n]\n\n\nclass BotTest(ZulipTestCase, UploadSerializeMixin):\n    def get_bot_user(self, email: str) -> UserProfile:\n        realm = get_realm(\"zulip\")\n        bot = get_user(email, realm)\n        return bot\n\n    def assert_num_bots_equal(self, count: int) -> None:\n        result = self.client_get(\"/json/bots\")\n        response_dict = self.assert_json_success(result)\n        self.assert_length(response_dict[\"bots\"], count)\n\n    def create_bot(self, **extras: Any) -> Dict[str, Any]:\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n            \"bot_type\": \"1\",\n        }\n        bot_info.update(extras)\n        result = self.client_post(\"/json/bots\", bot_info)\n        response_dict = self.assert_json_success(result)\n        return response_dict\n\n    def test_bot_domain(self) -> None:\n        self.login(\"hamlet\")\n        self.create_bot()\n        self.assertTrue(UserProfile.objects.filter(email=\"hambot-bot@zulip.testserver\").exists())\n        # The other cases are hard to test directly, since we don't allow creating bots from\n        # the wrong subdomain, and because 'testserver.example.com' is not a valid domain for the bot's email.\n        # So we just test the Realm.get_bot_domain function.\n        realm = get_realm(\"zulip\")\n        self.assertEqual(realm.get_bot_domain(), \"zulip.testserver\")\n\n    def deactivate_bot(self) -> None:\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_delete(f\"/json/bots/{self.get_bot_user(email).id}\")\n        self.assert_json_success(result)\n\n    def test_add_bot_with_bad_username(self) -> None:\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n\n        # Invalid username\n        bot_info = dict(\n            full_name=\"My bot name\",\n            short_name=\"@\",\n        )\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_error(result, \"Bad name or username\")\n        self.assert_num_bots_equal(0)\n\n        # Empty username\n        bot_info = dict(\n            full_name=\"My bot name\",\n            short_name=\"\",\n        )\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_error(result, \"Bad name or username\")\n        self.assert_num_bots_equal(0)\n\n    @override_settings(FAKE_EMAIL_DOMAIN=\"invaliddomain\", REALM_HOSTS={\"zulip\": \"127.0.0.1\"})\n    def test_add_bot_with_invalid_fake_email_domain(self) -> None:\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n            \"bot_type\": \"1\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n\n        error_message = (\n            \"Can't create bots until FAKE_EMAIL_DOMAIN is correctly configured.\\n\"\n            + \"Please contact your server administrator.\"\n        )\n        self.assert_json_error(result, error_message)\n        self.assert_num_bots_equal(0)\n\n    def test_add_bot_with_no_name(self) -> None:\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        bot_info = dict(\n            full_name=\"a\",\n            short_name=\"bot\",\n        )\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_error(result, \"Name too short!\")\n        self.assert_num_bots_equal(0)\n\n    def test_json_users_with_bots(self) -> None:\n        hamlet = self.example_user(\"hamlet\")\n        self.login_user(hamlet)\n        self.assert_num_bots_equal(0)\n\n        num_bots = 3\n        for i in range(num_bots):\n            full_name = f\"Bot {i}\"\n            short_name = f\"bot-{i}\"\n            bot_info = dict(\n                full_name=full_name,\n                short_name=short_name,\n                bot_type=1,\n            )\n            result = self.client_post(\"/json/bots\", bot_info)\n            self.assert_json_success(result)\n\n        self.assert_num_bots_equal(num_bots)\n\n        with queries_captured() as queries:\n            users_result = self.client_get(\"/json/users\")\n\n        self.assert_json_success(users_result)\n\n        self.assert_length(queries, 3)\n\n    def test_add_bot(self) -> None:\n        hamlet = self.example_user(\"hamlet\")\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        events: List[Mapping[str, Any]] = []\n        with self.tornado_redirected_to_list(events, expected_num_events=5):\n            result = self.create_bot()\n        self.assert_num_bots_equal(1)\n\n        email = \"hambot-bot@zulip.testserver\"\n        bot = self.get_bot_user(email)\n\n        (event,) = (e for e in events if e[\"event\"][\"type\"] == \"realm_bot\")\n\n        self.assertEqual(result[\"user_id\"], bot.id)\n        self.assertEqual(\n            dict(\n                type=\"realm_bot\",\n                op=\"add\",\n                bot=dict(\n                    email=\"hambot-bot@zulip.testserver\",\n                    user_id=bot.id,\n                    bot_type=bot.bot_type,\n                    full_name=\"The Bot of Hamlet\",\n                    is_active=True,\n                    api_key=result[\"api_key\"],\n                    avatar_url=result[\"avatar_url\"],\n                    default_sending_stream=None,\n                    default_events_register_stream=None,\n                    default_all_public_streams=False,\n                    services=[],\n                    owner_id=hamlet.id,\n                ),\n            ),\n            event[\"event\"],\n        )\n\n        users_result = self.client_get(\"/json/users\")\n        members = orjson.loads(users_result.content)[\"members\"]\n        [bot_dict] = [m for m in members if m[\"email\"] == \"hambot-bot@zulip.testserver\"]\n        self.assertEqual(bot_dict[\"bot_owner_id\"], self.example_user(\"hamlet\").id)\n        self.assertEqual(bot_dict[\"user_id\"], self.get_bot_user(email).id)\n\n    @override_settings(FAKE_EMAIL_DOMAIN=\"fakedomain.com\", REALM_HOSTS={\"zulip\": \"127.0.0.1\"})\n    def test_add_bot_with_fake_email_domain(self) -> None:\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        self.create_bot()\n        self.assert_num_bots_equal(1)\n\n        email = \"hambot-bot@fakedomain.com\"\n        self.get_bot_user(email)\n\n    @override_settings(EXTERNAL_HOST=\"example.com\")\n    def test_add_bot_verify_subdomain_in_email_address(self) -> None:\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        self.create_bot()\n        self.assert_num_bots_equal(1)\n\n        email = \"hambot-bot@zulip.example.com\"\n        self.get_bot_user(email)\n\n    @override_settings(\n        FAKE_EMAIL_DOMAIN=\"fakedomain.com\", REALM_HOSTS={\"zulip\": \"zulip.example.com\"}\n    )\n    def test_add_bot_host_used_as_domain_if_valid(self) -> None:\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        self.create_bot()\n        self.assert_num_bots_equal(1)\n\n        email = \"hambot-bot@zulip.example.com\"\n        self.get_bot_user(email)\n\n    def test_add_bot_with_username_in_use(self) -> None:\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        self.create_bot()\n        self.assert_num_bots_equal(1)\n\n        # The short_name is used in the email, which we call\n        # \"Username\" for legacy reasons.\n        bot_info = dict(\n            full_name=\"whatever\",\n            short_name=\"hambot\",\n        )\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_error(result, \"Username already in use\")\n\n        dup_full_name = \"The Bot of Hamlet\"\n\n        bot_info = dict(\n            full_name=dup_full_name,\n            short_name=\"whatever\",\n        )\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_error(result, \"Name is already in use!\")\n\n    def test_add_bot_with_user_avatar(self) -> None:\n        email = \"hambot-bot@zulip.testserver\"\n        realm = get_realm(\"zulip\")\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        with get_test_image_file(\"img.png\") as fp:\n            self.create_bot(file=fp)\n            profile = get_user(email, realm)\n            # Make sure that avatar image that we've uploaded is same with avatar image in the server\n            self.assertTrue(\n                filecmp.cmp(fp.name, os.path.splitext(avatar_disk_path(profile))[0] + \".original\")\n            )\n        self.assert_num_bots_equal(1)\n\n        self.assertEqual(profile.avatar_source, UserProfile.AVATAR_FROM_USER)\n        self.assertTrue(os.path.exists(avatar_disk_path(profile)))\n\n    def test_add_bot_with_too_many_files(self) -> None:\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        with get_test_image_file(\"img.png\") as fp1, get_test_image_file(\"img.gif\") as fp2:\n            bot_info = dict(\n                full_name=\"whatever\",\n                short_name=\"whatever\",\n                file1=fp1,\n                file2=fp2,\n            )\n            result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_error(result, \"You may only upload one file at a time\")\n        self.assert_num_bots_equal(0)\n\n    def test_add_bot_with_default_sending_stream(self) -> None:\n        email = \"hambot-bot@zulip.testserver\"\n        realm = get_realm(\"zulip\")\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        result = self.create_bot(default_sending_stream=\"Denmark\")\n        self.assert_num_bots_equal(1)\n        self.assertEqual(result[\"default_sending_stream\"], \"Denmark\")\n\n        profile = get_user(email, realm)\n        assert profile.default_sending_stream is not None\n        self.assertEqual(profile.default_sending_stream.name, \"Denmark\")\n\n    def test_add_bot_with_default_sending_stream_not_subscribed(self) -> None:\n        email = \"hambot-bot@zulip.testserver\"\n        realm = get_realm(\"zulip\")\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        result = self.create_bot(default_sending_stream=\"Rome\")\n        self.assert_num_bots_equal(1)\n        self.assertEqual(result[\"default_sending_stream\"], \"Rome\")\n\n        profile = get_user(email, realm)\n        assert profile.default_sending_stream is not None\n        self.assertEqual(profile.default_sending_stream.name, \"Rome\")\n\n    def test_add_bot_email_address_visibility(self) -> None:\n        # Test that we don't mangle the email field with\n        # email_address_visiblity limited to admins\n        user = self.example_user(\"hamlet\")\n        do_set_realm_property(\n            user.realm,\n            \"email_address_visibility\",\n            Realm.EMAIL_ADDRESS_VISIBILITY_ADMINS,\n            acting_user=None,\n        )\n        user.refresh_from_db()\n\n        self.login_user(user)\n        self.assert_num_bots_equal(0)\n        events: List[Mapping[str, Any]] = []\n        with self.tornado_redirected_to_list(events, expected_num_events=5):\n            result = self.create_bot()\n        self.assert_num_bots_equal(1)\n\n        email = \"hambot-bot@zulip.testserver\"\n        bot = self.get_bot_user(email)\n\n        (event,) = (e for e in events if e[\"event\"][\"type\"] == \"realm_bot\")\n        self.assertEqual(\n            dict(\n                type=\"realm_bot\",\n                op=\"add\",\n                bot=dict(\n                    email=\"hambot-bot@zulip.testserver\",\n                    user_id=bot.id,\n                    bot_type=bot.bot_type,\n                    full_name=\"The Bot of Hamlet\",\n                    is_active=True,\n                    api_key=result[\"api_key\"],\n                    avatar_url=result[\"avatar_url\"],\n                    default_sending_stream=None,\n                    default_events_register_stream=None,\n                    default_all_public_streams=False,\n                    services=[],\n                    owner_id=user.id,\n                ),\n            ),\n            event[\"event\"],\n        )\n\n        users_result = self.client_get(\"/json/users\")\n        members = orjson.loads(users_result.content)[\"members\"]\n        [bot_dict] = [m for m in members if m[\"email\"] == \"hambot-bot@zulip.testserver\"]\n        self.assertEqual(bot_dict[\"bot_owner_id\"], user.id)\n        self.assertEqual(bot_dict[\"user_id\"], self.get_bot_user(email).id)\n\n    def test_bot_add_subscription(self) -> None:\n        \"\"\"\n        Calling POST /json/users/me/subscriptions should successfully add\n        streams, and a stream to the\n        list of subscriptions and confirm the right number of events\n        are generated.\n        When 'principals' has a bot, no notification message event or invitation email\n        is sent when add_subscriptions_backend is called in the above API call.\n        \"\"\"\n        hamlet = self.example_user(\"hamlet\")\n        iago = self.example_user(\"iago\")\n        self.login_user(hamlet)\n\n        # Normal user i.e. not a bot.\n        request_data = {\n            \"principals\": '[\"' + iago.email + '\"]',\n        }\n        events: List[Mapping[str, Any]] = []\n        with self.tornado_redirected_to_list(events, expected_num_events=3):\n            result = self.common_subscribe_to_streams(hamlet, [\"Rome\"], request_data)\n            self.assert_json_success(result)\n\n        msg_event = [e for e in events if e[\"event\"][\"type\"] == \"message\"]\n        self.assert_length(msg_event, 1)  # Notification message event is sent.\n\n        # Create a bot.\n        self.assert_num_bots_equal(0)\n        self.create_bot()\n        self.assert_num_bots_equal(1)\n\n        # A bot\n        bot_request_data = {\n            \"principals\": '[\"hambot-bot@zulip.testserver\"]',\n        }\n        events_bot: List[Mapping[str, Any]] = []\n        with self.tornado_redirected_to_list(events_bot, expected_num_events=2):\n            result = self.common_subscribe_to_streams(hamlet, [\"Rome\"], bot_request_data)\n            self.assert_json_success(result)\n\n        # No notification message event or invitation email is sent because of bot.\n        msg_event = [e for e in events_bot if e[\"event\"][\"type\"] == \"message\"]\n        self.assert_length(msg_event, 0)\n        self.assert_length(events_bot, len(events) - 1)\n\n        # Test runner automatically redirects all sent email to a dummy 'outbox'.\n        self.assert_length(mail.outbox, 0)\n\n    def test_add_bot_with_default_sending_stream_private_allowed(self) -> None:\n        self.login(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        stream = get_stream(\"Denmark\", user_profile.realm)\n        self.subscribe(user_profile, stream.name)\n        do_change_stream_permission(stream, invite_only=True, acting_user=user_profile)\n\n        self.assert_num_bots_equal(0)\n        events: List[Mapping[str, Any]] = []\n        with self.tornado_redirected_to_list(events, expected_num_events=5):\n            result = self.create_bot(default_sending_stream=\"Denmark\")\n        self.assert_num_bots_equal(1)\n        self.assertEqual(result[\"default_sending_stream\"], \"Denmark\")\n\n        email = \"hambot-bot@zulip.testserver\"\n        realm = get_realm(\"zulip\")\n        profile = get_user(email, realm)\n        assert profile.default_sending_stream is not None\n        self.assertEqual(profile.default_sending_stream.name, \"Denmark\")\n\n        (event,) = (e for e in events if e[\"event\"][\"type\"] == \"realm_bot\")\n        self.assertEqual(\n            dict(\n                type=\"realm_bot\",\n                op=\"add\",\n                bot=dict(\n                    email=\"hambot-bot@zulip.testserver\",\n                    user_id=profile.id,\n                    full_name=\"The Bot of Hamlet\",\n                    bot_type=profile.bot_type,\n                    is_active=True,\n                    api_key=result[\"api_key\"],\n                    avatar_url=result[\"avatar_url\"],\n                    default_sending_stream=\"Denmark\",\n                    default_events_register_stream=None,\n                    default_all_public_streams=False,\n                    services=[],\n                    owner_id=user_profile.id,\n                ),\n            ),\n            event[\"event\"],\n        )\n        self.assertEqual(event[\"users\"], [user_profile.id])\n\n    def test_add_bot_with_default_sending_stream_private_denied(self) -> None:\n        self.login(\"hamlet\")\n        realm = self.example_user(\"hamlet\").realm\n        stream = get_stream(\"Denmark\", realm)\n        self.unsubscribe(self.example_user(\"hamlet\"), \"Denmark\")\n        do_change_stream_permission(\n            stream, invite_only=True, acting_user=self.example_user(\"hamlet\")\n        )\n\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n            \"default_sending_stream\": \"Denmark\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_error(result, \"Invalid stream name 'Denmark'\")\n\n    def test_add_bot_with_default_events_register_stream(self) -> None:\n        bot_email = \"hambot-bot@zulip.testserver\"\n        bot_realm = get_realm(\"zulip\")\n\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        result = self.create_bot(default_events_register_stream=\"Denmark\")\n        self.assert_num_bots_equal(1)\n        self.assertEqual(result[\"default_events_register_stream\"], \"Denmark\")\n\n        profile = get_user(bot_email, bot_realm)\n        assert profile.default_events_register_stream is not None\n        self.assertEqual(profile.default_events_register_stream.name, \"Denmark\")\n\n    def test_add_bot_with_default_events_register_stream_private_allowed(self) -> None:\n        self.login(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        stream = self.subscribe(user_profile, \"Denmark\")\n        do_change_stream_permission(stream, invite_only=True, acting_user=user_profile)\n\n        self.assert_num_bots_equal(0)\n        events: List[Mapping[str, Any]] = []\n        with self.tornado_redirected_to_list(events, expected_num_events=5):\n            result = self.create_bot(default_events_register_stream=\"Denmark\")\n        self.assert_num_bots_equal(1)\n        self.assertEqual(result[\"default_events_register_stream\"], \"Denmark\")\n\n        bot_email = \"hambot-bot@zulip.testserver\"\n        bot_realm = get_realm(\"zulip\")\n        bot_profile = get_user(bot_email, bot_realm)\n        assert bot_profile.default_events_register_stream is not None\n        self.assertEqual(bot_profile.default_events_register_stream.name, \"Denmark\")\n\n        (event,) = (e for e in events if e[\"event\"][\"type\"] == \"realm_bot\")\n        self.assertEqual(\n            dict(\n                type=\"realm_bot\",\n                op=\"add\",\n                bot=dict(\n                    email=\"hambot-bot@zulip.testserver\",\n                    full_name=\"The Bot of Hamlet\",\n                    user_id=bot_profile.id,\n                    bot_type=bot_profile.bot_type,\n                    is_active=True,\n                    api_key=result[\"api_key\"],\n                    avatar_url=result[\"avatar_url\"],\n                    default_sending_stream=None,\n                    default_events_register_stream=\"Denmark\",\n                    default_all_public_streams=False,\n                    services=[],\n                    owner_id=user_profile.id,\n                ),\n            ),\n            event[\"event\"],\n        )\n        self.assertEqual(event[\"users\"], [user_profile.id])\n\n    def test_add_bot_with_default_events_register_stream_private_denied(self) -> None:\n        self.login(\"hamlet\")\n        realm = self.example_user(\"hamlet\").realm\n        stream = get_stream(\"Denmark\", realm)\n        self.unsubscribe(self.example_user(\"hamlet\"), \"Denmark\")\n        do_change_stream_permission(\n            stream, invite_only=True, acting_user=self.example_user(\"hamlet\")\n        )\n\n        self.assert_num_bots_equal(0)\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n            \"default_events_register_stream\": \"Denmark\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_error(result, \"Invalid stream name 'Denmark'\")\n\n    def test_add_bot_with_default_all_public_streams(self) -> None:\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        result = self.create_bot(default_all_public_streams=orjson.dumps(True).decode())\n        self.assert_num_bots_equal(1)\n        self.assertTrue(result[\"default_all_public_streams\"])\n\n        bot_email = \"hambot-bot@zulip.testserver\"\n        bot_realm = get_realm(\"zulip\")\n        profile = get_user(bot_email, bot_realm)\n        self.assertEqual(profile.default_all_public_streams, True)\n\n    def test_deactivate_bot(self) -> None:\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        self.create_bot()\n        self.assert_num_bots_equal(1)\n        self.deactivate_bot()\n        # You can deactivate the same bot twice.\n        self.deactivate_bot()\n        self.assert_num_bots_equal(0)\n\n    def test_deactivate_bogus_bot(self) -> None:\n        \"\"\"Deleting a bogus bot will succeed silently.\"\"\"\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        self.create_bot()\n        self.assert_num_bots_equal(1)\n        invalid_user_id = 1000\n        result = self.client_delete(f\"/json/bots/{invalid_user_id}\")\n        self.assert_json_error(result, \"No such bot\")\n        self.assert_num_bots_equal(1)\n\n    def test_deactivate_bot_with_owner_deactivation(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n\n        bot_info = {\n            \"full_name\": \"The Another Bot of Hamlet\",\n            \"short_name\": \"hambot-another\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n\n        self.assertEqual(\n            UserProfile.objects.filter(is_bot=True, bot_owner=user, is_active=True).count(), 2\n        )\n\n        result = self.client_delete(\"/json/users/me\")\n        self.assert_json_success(result)\n        user = self.example_user(\"hamlet\")\n        self.assertFalse(user.is_active)\n\n        self.login(\"iago\")\n        self.assertFalse(\n            UserProfile.objects.filter(is_bot=True, bot_owner=user, is_active=True).exists()\n        )\n\n    def test_cannot_deactivate_other_realm_bot(self) -> None:\n        user = self.mit_user(\"starnine\")\n        self.login_user(user)\n        bot_info = {\n            \"full_name\": \"The Bot in zephyr\",\n            \"short_name\": \"starn-bot\",\n            \"bot_type\": \"1\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info, subdomain=\"zephyr\")\n        self.assert_json_success(result)\n        result = self.client_get(\"/json/bots\", subdomain=\"zephyr\")\n        response_dict = self.assert_json_success(result)\n        bot_email = response_dict[\"bots\"][0][\"username\"]\n        bot = get_user(bot_email, user.realm)\n        self.login(\"iago\")\n        result = self.client_delete(f\"/json/bots/{bot.id}\")\n        self.assert_json_error(result, \"No such bot\")\n\n    def test_bot_deactivation_attacks(self) -> None:\n        \"\"\"You cannot deactivate somebody else's bot.\"\"\"\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        self.create_bot()\n        self.assert_num_bots_equal(1)\n\n        # Have Othello try to deactivate both Hamlet and\n        # Hamlet's bot.\n        self.login(\"othello\")\n\n        # Cannot deactivate a user as a bot\n        result = self.client_delete(\"/json/bots/{}\".format(self.example_user(\"hamlet\").id))\n        self.assert_json_error(result, \"No such bot\")\n\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_delete(f\"/json/bots/{self.get_bot_user(email).id}\")\n        self.assert_json_error(result, \"Insufficient permission\")\n\n        # But we don't actually deactivate the other person's bot.\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(1)\n\n        # Cannot deactivate a bot as a user\n        result = self.client_delete(f\"/json/users/{self.get_bot_user(email).id}\")\n        self.assert_json_error(result, \"No such user\")\n        self.assert_num_bots_equal(1)\n\n    def test_bot_permissions(self) -> None:\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        self.create_bot()\n        self.assert_num_bots_equal(1)\n\n        # Have Othello try to mess with Hamlet's bots.\n        self.login(\"othello\")\n        email = \"hambot-bot@zulip.testserver\"\n\n        result = self.client_post(f\"/json/bots/{self.get_bot_user(email).id}/api_key/regenerate\")\n        self.assert_json_error(result, \"Insufficient permission\")\n\n        bot_info = {\n            \"full_name\": \"Fred\",\n        }\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        self.assert_json_error(result, \"Insufficient permission\")\n\n    def get_bot(self) -> Dict[str, Any]:\n        result = self.client_get(\"/json/bots\")\n        return self.assert_json_success(result)[\"bots\"][0]\n\n    def test_update_api_key(self) -> None:\n        self.login(\"hamlet\")\n        self.create_bot()\n        bot = self.get_bot()\n        old_api_key = bot[\"api_key\"]\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_post(f\"/json/bots/{self.get_bot_user(email).id}/api_key/regenerate\")\n        new_api_key = self.assert_json_success(result)[\"api_key\"]\n        self.assertNotEqual(old_api_key, new_api_key)\n        bot = self.get_bot()\n        self.assertEqual(new_api_key, bot[\"api_key\"])\n\n    def test_update_api_key_for_invalid_user(self) -> None:\n        self.login(\"hamlet\")\n        invalid_user_id = 1000\n        result = self.client_post(f\"/json/bots/{invalid_user_id}/api_key/regenerate\")\n        self.assert_json_error(result, \"No such bot\")\n\n    def test_add_bot_with_bot_type_default(self) -> None:\n        bot_email = \"hambot-bot@zulip.testserver\"\n        bot_realm = get_realm(\"zulip\")\n\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        self.create_bot(bot_type=UserProfile.DEFAULT_BOT)\n        self.assert_num_bots_equal(1)\n\n        profile = get_user(bot_email, bot_realm)\n        self.assertEqual(profile.bot_type, UserProfile.DEFAULT_BOT)\n\n    def test_add_bot_with_bot_type_incoming_webhook(self) -> None:\n        bot_email = \"hambot-bot@zulip.testserver\"\n        bot_realm = get_realm(\"zulip\")\n\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        self.create_bot(bot_type=UserProfile.INCOMING_WEBHOOK_BOT)\n        self.assert_num_bots_equal(1)\n\n        profile = get_user(bot_email, bot_realm)\n        self.assertEqual(profile.bot_type, UserProfile.INCOMING_WEBHOOK_BOT)\n\n    def test_add_bot_with_bot_type_invalid(self) -> None:\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n            \"bot_type\": 7,\n        }\n\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_num_bots_equal(0)\n        self.assert_json_error(result, \"Invalid bot type\")\n\n    def test_no_generic_bots_allowed_for_non_admins(self) -> None:\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n            \"bot_type\": 1,\n        }\n        bot_email = \"hambot-bot@zulip.testserver\"\n        bot_realm = get_realm(\"zulip\")\n        bot_realm.bot_creation_policy = Realm.BOT_CREATION_LIMIT_GENERIC_BOTS\n        bot_realm.save(update_fields=[\"bot_creation_policy\"])\n\n        # A regular user cannot create a generic bot\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_num_bots_equal(0)\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n        # But can create an incoming webhook\n        self.assert_num_bots_equal(0)\n        self.create_bot(bot_type=UserProfile.INCOMING_WEBHOOK_BOT)\n        self.assert_num_bots_equal(1)\n        profile = get_user(bot_email, bot_realm)\n        self.assertEqual(profile.bot_type, UserProfile.INCOMING_WEBHOOK_BOT)\n\n    def test_no_generic_bot_reactivation_allowed_for_non_admins(self) -> None:\n        self.login(\"hamlet\")\n        self.create_bot(bot_type=UserProfile.DEFAULT_BOT)\n\n        bot_realm = get_realm(\"zulip\")\n        bot_realm.bot_creation_policy = Realm.BOT_CREATION_LIMIT_GENERIC_BOTS\n        bot_realm.save(update_fields=[\"bot_creation_policy\"])\n\n        bot_email = \"hambot-bot@zulip.testserver\"\n        bot_user = get_user(bot_email, bot_realm)\n        do_deactivate_user(bot_user, acting_user=None)\n\n        # A regular user cannot reactivate a generic bot\n        self.assert_num_bots_equal(0)\n        result = self.client_post(f\"/json/users/{bot_user.id}/reactivate\")\n        self.assert_json_error(result, \"Must be an organization administrator\")\n        self.assert_num_bots_equal(0)\n\n    def test_no_generic_bots_allowed_for_admins(self) -> None:\n        bot_email = \"hambot-bot@zulip.testserver\"\n        bot_realm = get_realm(\"zulip\")\n        bot_realm.bot_creation_policy = Realm.BOT_CREATION_LIMIT_GENERIC_BOTS\n        bot_realm.save(update_fields=[\"bot_creation_policy\"])\n\n        # An administrator can create any type of bot\n        self.login(\"iago\")\n        self.assert_num_bots_equal(0)\n        self.create_bot(bot_type=UserProfile.DEFAULT_BOT)\n        self.assert_num_bots_equal(1)\n        profile = get_user(bot_email, bot_realm)\n        self.assertEqual(profile.bot_type, UserProfile.DEFAULT_BOT)\n\n    def test_no_bots_allowed_for_non_admins(self) -> None:\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n            \"bot_type\": 1,\n        }\n        bot_realm = get_realm(\"zulip\")\n        bot_realm.bot_creation_policy = Realm.BOT_CREATION_ADMINS_ONLY\n        bot_realm.save(update_fields=[\"bot_creation_policy\"])\n\n        # A regular user cannot create a generic bot\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_num_bots_equal(0)\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n        # Also, a regular user cannot create a incoming bot\n        bot_info[\"bot_type\"] = 2\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_num_bots_equal(0)\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n    def test_no_bots_allowed_for_admins(self) -> None:\n        bot_email = \"hambot-bot@zulip.testserver\"\n        bot_realm = get_realm(\"zulip\")\n        bot_realm.bot_creation_policy = Realm.BOT_CREATION_ADMINS_ONLY\n        bot_realm.save(update_fields=[\"bot_creation_policy\"])\n\n        # An administrator can create any type of bot\n        self.login(\"iago\")\n        self.assert_num_bots_equal(0)\n        self.create_bot(bot_type=UserProfile.DEFAULT_BOT)\n        self.assert_num_bots_equal(1)\n        profile = get_user(bot_email, bot_realm)\n        self.assertEqual(profile.bot_type, UserProfile.DEFAULT_BOT)\n\n    def test_patch_bot_full_name(self) -> None:\n        self.login(\"hamlet\")\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n        bot_info = {\n            \"full_name\": \"Fred\",\n        }\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        response_dict = self.assert_json_success(result)\n\n        self.assertEqual(\"Fred\", response_dict[\"full_name\"])\n\n        bot = self.get_bot()\n        self.assertEqual(\"Fred\", bot[\"full_name\"])\n\n    def test_patch_bot_full_name_in_use(self) -> None:\n        self.login(\"hamlet\")\n\n        original_name = \"The Bot of Hamlet\"\n\n        bot_info = {\n            \"full_name\": original_name,\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n\n        bot_email = \"hambot-bot@zulip.testserver\"\n        bot = self.get_bot_user(bot_email)\n        url = f\"/json/bots/{bot.id}\"\n\n        # It doesn't matter whether a name is taken by a human\n        # or a bot, we can't use it.\n        already_taken_name = self.example_user(\"cordelia\").full_name\n\n        bot_info = {\n            \"full_name\": already_taken_name,\n        }\n        result = self.client_patch(url, bot_info)\n        self.assert_json_error(result, \"Name is already in use!\")\n\n        # We can use our own name (with extra whitespace), and the\n        # server should silently do nothing.\n        original_name_with_padding = \"   \" + original_name + \" \"\n        bot_info = {\n            \"full_name\": original_name_with_padding,\n        }\n        result = self.client_patch(url, bot_info)\n        self.assert_json_success(result)\n\n        bot = self.get_bot_user(bot_email)\n        self.assertEqual(bot.full_name, original_name)\n\n        # And let's do a sanity check with an actual name change\n        # after our various attempts that either failed or did\n        # nothing.\n        bot_info = {\n            \"full_name\": \"Hal\",\n        }\n        result = self.client_patch(url, bot_info)\n        self.assert_json_success(result)\n\n        bot = self.get_bot_user(bot_email)\n        self.assertEqual(bot.full_name, \"Hal\")\n\n    def test_patch_bot_full_name_non_bot(self) -> None:\n        self.login(\"iago\")\n        bot_info = {\n            \"full_name\": \"Fred\",\n        }\n        result = self.client_patch(\"/json/bots/{}\".format(self.example_user(\"hamlet\").id), bot_info)\n        self.assert_json_error(result, \"No such bot\")\n\n    def test_patch_bot_owner(self) -> None:\n        self.login(\"hamlet\")\n        othello = self.example_user(\"othello\")\n\n        bot_info: Dict[str, object] = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n        bot_info = {\n            \"bot_owner_id\": othello.id,\n        }\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        response_dict = self.assert_json_success(result)\n\n        # Test bot's owner has been changed successfully.\n        self.assertEqual(response_dict[\"bot_owner\"], othello.email)\n\n        self.login(\"othello\")\n        bot = self.get_bot()\n        self.assertEqual(\"The Bot of Hamlet\", bot[\"full_name\"])\n\n    def test_patch_bot_owner_bad_user_id(self) -> None:\n        self.login(\"hamlet\")\n        self.create_bot()\n        self.assert_num_bots_equal(1)\n\n        email = \"hambot-bot@zulip.testserver\"\n        profile = get_user(\"hambot-bot@zulip.testserver\", get_realm(\"zulip\"))\n\n        bad_bot_owner_id = 999999\n        bot_info = {\n            \"bot_owner_id\": bad_bot_owner_id,\n        }\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        self.assert_json_error(result, \"Failed to change owner, no such user\")\n        profile = get_user(\"hambot-bot@zulip.testserver\", get_realm(\"zulip\"))\n        self.assertEqual(profile.bot_owner, self.example_user(\"hamlet\"))\n\n    def test_patch_bot_owner_deactivated(self) -> None:\n        self.login(\"hamlet\")\n        self.create_bot()\n        self.assert_num_bots_equal(1)\n\n        target_user_profile = self.example_user(\"othello\")\n        do_deactivate_user(target_user_profile, acting_user=None)\n        target_user_profile = self.example_user(\"othello\")\n        self.assertFalse(target_user_profile.is_active)\n        bot_info = {\n            \"bot_owner_id\": self.example_user(\"othello\").id,\n        }\n\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        self.assert_json_error(result, \"Failed to change owner, user is deactivated\")\n        profile = self.get_bot_user(email)\n        self.assertEqual(profile.bot_owner, self.example_user(\"hamlet\"))\n\n    def test_patch_bot_owner_must_be_in_same_realm(self) -> None:\n        self.login(\"hamlet\")\n        self.create_bot()\n        self.assert_num_bots_equal(1)\n\n        bot_info = {\n            \"bot_owner_id\": self.mit_user(\"starnine\").id,\n        }\n\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        self.assert_json_error(result, \"Failed to change owner, no such user\")\n        profile = self.get_bot_user(email)\n        self.assertEqual(profile.bot_owner, self.example_user(\"hamlet\"))\n\n    def test_patch_bot_owner_noop(self) -> None:\n        self.login(\"hamlet\")\n        self.create_bot()\n        self.assert_num_bots_equal(1)\n\n        bot_info = {\n            \"bot_owner_id\": self.example_user(\"hamlet\").id,\n        }\n\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n\n        # Check that we're still the owner\n        self.assert_json_success(result)\n        profile = self.get_bot_user(email)\n        self.assertEqual(profile.bot_owner, self.example_user(\"hamlet\"))\n\n    def test_patch_bot_owner_a_bot(self) -> None:\n        self.login(\"hamlet\")\n        self.create_bot()\n        self.assert_num_bots_equal(1)\n\n        bot_info: Dict[str, object] = {\n            \"full_name\": \"Another Bot of Hamlet\",\n            \"short_name\": \"hamelbot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n\n        bot_info = {\n            \"bot_owner_id\": self.get_bot_user(\"hamelbot-bot@zulip.testserver\").id,\n        }\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        self.assert_json_error(result, \"Failed to change owner, bots can't own other bots\")\n        profile = get_user(email, get_realm(\"zulip\"))\n        self.assertEqual(profile.bot_owner, self.example_user(\"hamlet\"))\n\n    def test_patch_bot_owner_of_bot_with_can_create_users(self) -> None:\n        \"\"\"\n        can_create_users is granted to organizations upon approval, and thus\n        should be thought of as something that only organization owners should\n        have control over.\n        \"\"\"\n        cordelia = self.example_user(\"cordelia\")\n\n        self.login(\"hamlet\")\n        self.create_bot()\n\n        bot_realm = get_realm(\"zulip\")\n        bot_email = \"hambot-bot@zulip.testserver\"\n        bot_user = get_user(bot_email, bot_realm)\n\n        do_change_can_create_users(bot_user, True)\n\n        self.logout()\n        # iago is an ordinary organization administrator, and thus doesn't have\n        # sufficient permissions to change ownership of this bot.\n        self.login(\"iago\")\n        bot_info = {\n            \"bot_owner_id\": cordelia.id,\n        }\n        result = self.client_patch(f\"/json/bots/{bot_user.id}\", bot_info)\n        self.assert_json_error(\n            result,\n            \"Must be an organization owner\",\n        )\n\n        self.logout()\n        # desdemona is the organization owner and should be allowed to change the bot's ownership.\n        self.login(\"desdemona\")\n        result = self.client_patch(f\"/json/bots/{bot_user.id}\", bot_info)\n        self.assert_json_success(result)\n\n        bot_user.refresh_from_db()\n        self.assertEqual(bot_user.bot_owner, cordelia)\n\n    def test_patch_bot_avatar(self) -> None:\n        self.login(\"hamlet\")\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n\n        bot_email = \"hambot-bot@zulip.testserver\"\n        bot_realm = get_realm(\"zulip\")\n        profile = get_user(bot_email, bot_realm)\n        self.assertEqual(profile.avatar_source, UserProfile.AVATAR_FROM_GRAVATAR)\n\n        email = \"hambot-bot@zulip.testserver\"\n        # Try error case first (too many files):\n        with get_test_image_file(\"img.png\") as fp1, get_test_image_file(\"img.gif\") as fp2:\n            result = self.client_patch_multipart(\n                f\"/json/bots/{self.get_bot_user(email).id}\", dict(file1=fp1, file2=fp2)\n            )\n        self.assert_json_error(result, \"You may only upload one file at a time\")\n\n        profile = get_user(bot_email, bot_realm)\n        self.assertEqual(profile.avatar_version, 1)\n\n        # HAPPY PATH\n        with get_test_image_file(\"img.png\") as fp:\n            result = self.client_patch_multipart(\n                f\"/json/bots/{self.get_bot_user(email).id}\", dict(file=fp)\n            )\n            profile = get_user(bot_email, bot_realm)\n            self.assertEqual(profile.avatar_version, 2)\n            # Make sure that avatar image that we've uploaded is same with avatar image in the server\n            self.assertTrue(\n                filecmp.cmp(fp.name, os.path.splitext(avatar_disk_path(profile))[0] + \".original\")\n            )\n        self.assert_json_success(result)\n\n        self.assertEqual(profile.avatar_source, UserProfile.AVATAR_FROM_USER)\n        self.assertTrue(os.path.exists(avatar_disk_path(profile)))\n\n    def test_patch_bot_to_stream(self) -> None:\n        self.login(\"hamlet\")\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n        bot_info = {\n            \"default_sending_stream\": \"Denmark\",\n        }\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        response_dict = self.assert_json_success(result)\n\n        self.assertEqual(\"Denmark\", response_dict[\"default_sending_stream\"])\n\n        bot = self.get_bot()\n        self.assertEqual(\"Denmark\", bot[\"default_sending_stream\"])\n\n    def test_patch_bot_to_stream_not_subscribed(self) -> None:\n        self.login(\"hamlet\")\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n        bot_info = {\n            \"default_sending_stream\": \"Rome\",\n        }\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        response_dict = self.assert_json_success(result)\n\n        self.assertEqual(\"Rome\", response_dict[\"default_sending_stream\"])\n\n        bot = self.get_bot()\n        self.assertEqual(\"Rome\", bot[\"default_sending_stream\"])\n\n    def test_patch_bot_to_stream_none(self) -> None:\n        self.login(\"hamlet\")\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n        bot_info = {\n            \"default_sending_stream\": \"\",\n        }\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        self.assert_json_success(result)\n\n        bot_email = \"hambot-bot@zulip.testserver\"\n        bot_realm = get_realm(\"zulip\")\n        default_sending_stream = get_user(bot_email, bot_realm).default_sending_stream\n        self.assertEqual(None, default_sending_stream)\n\n        bot = self.get_bot()\n        self.assertEqual(None, bot[\"default_sending_stream\"])\n\n    def test_patch_bot_role(self) -> None:\n        self.login(\"desdemona\")\n\n        email = \"default-bot@zulip.com\"\n        user_profile = self.get_bot_user(email)\n\n        do_change_user_role(user_profile, UserProfile.ROLE_MEMBER, acting_user=user_profile)\n\n        req = dict(role=UserProfile.ROLE_GUEST)\n\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", req)\n        self.assert_json_success(result)\n\n        user_profile = self.get_bot_user(email)\n        self.assertEqual(user_profile.role, UserProfile.ROLE_GUEST)\n\n        # Test for not allowing a non-owner user to make assign a bot an owner role\n        desdemona = self.example_user(\"desdemona\")\n        do_change_user_role(desdemona, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n\n        req = dict(role=UserProfile.ROLE_REALM_OWNER)\n\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", req)\n        self.assert_json_error(result, \"Must be an organization owner\")\n\n    def test_patch_bot_to_stream_private_allowed(self) -> None:\n        self.login(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        stream = self.subscribe(user_profile, \"Denmark\")\n        do_change_stream_permission(stream, invite_only=True, acting_user=user_profile)\n\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n\n        bot_info = {\n            \"default_sending_stream\": \"Denmark\",\n        }\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        response_dict = self.assert_json_success(result)\n\n        self.assertEqual(\"Denmark\", response_dict[\"default_sending_stream\"])\n\n        bot = self.get_bot()\n        self.assertEqual(\"Denmark\", bot[\"default_sending_stream\"])\n\n    def test_patch_bot_to_stream_private_denied(self) -> None:\n        self.login(\"hamlet\")\n        realm = self.example_user(\"hamlet\").realm\n        stream = get_stream(\"Denmark\", realm)\n        self.unsubscribe(self.example_user(\"hamlet\"), \"Denmark\")\n        do_change_stream_permission(\n            stream, invite_only=True, acting_user=self.example_user(\"hamlet\")\n        )\n\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n\n        bot_info = {\n            \"default_sending_stream\": \"Denmark\",\n        }\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        self.assert_json_error(result, \"Invalid stream name 'Denmark'\")\n\n    def test_patch_bot_to_stream_not_found(self) -> None:\n        self.login(\"hamlet\")\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n        bot_info = {\n            \"default_sending_stream\": \"missing\",\n        }\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        self.assert_json_error(result, \"Invalid stream name 'missing'\")\n\n    def test_patch_bot_events_register_stream(self) -> None:\n        hamlet = self.example_user(\"hamlet\")\n        self.login_user(hamlet)\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n\n        email = \"hambot-bot@zulip.testserver\"\n        bot_user = self.get_bot_user(email)\n        url = f\"/json/bots/{bot_user.id}\"\n\n        # Successfully give the bot a default stream.\n        stream_name = \"Denmark\"\n        bot_info = dict(default_events_register_stream=stream_name)\n        result = self.client_patch(url, bot_info)\n        response_dict = self.assert_json_success(result)\n\n        self.assertEqual(stream_name, response_dict[\"default_events_register_stream\"])\n\n        bot = self.get_bot()\n        self.assertEqual(stream_name, bot[\"default_events_register_stream\"])\n\n        # Make sure we are locked out of an unsubscribed private stream.\n        # We'll subscribe the bot but not the owner (since the check is\n        # on owner).\n        stream_name = \"private_stream\"\n        self.make_stream(stream_name, hamlet.realm, invite_only=True)\n        self.subscribe(bot_user, stream_name)\n        bot_info = dict(default_events_register_stream=stream_name)\n        result = self.client_patch(url, bot_info)\n        self.assert_json_error_contains(result, \"Invalid stream name\")\n\n        # Subscribing the owner allows us to patch the stream.\n        self.subscribe(hamlet, stream_name)\n        bot_info = dict(default_events_register_stream=stream_name)\n        result = self.client_patch(url, bot_info)\n        self.assert_json_success(result)\n\n        # Make sure the bot cannot create their own default stream.\n        url = f\"/api/v1/bots/{bot_user.id}\"\n        result = self.api_patch(bot_user, url, bot_info)\n        self.assert_json_error_contains(result, \"endpoint does not accept\")\n\n    def test_patch_bot_events_register_stream_allowed(self) -> None:\n        self.login(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        stream = self.subscribe(user_profile, \"Denmark\")\n        do_change_stream_permission(stream, invite_only=True, acting_user=user_profile)\n\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n        bot_info = {\n            \"default_events_register_stream\": \"Denmark\",\n        }\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        response_dict = self.assert_json_success(result)\n\n        self.assertEqual(\"Denmark\", response_dict[\"default_events_register_stream\"])\n\n        bot = self.get_bot()\n        self.assertEqual(\"Denmark\", bot[\"default_events_register_stream\"])\n\n    def test_patch_bot_events_register_stream_denied(self) -> None:\n        self.login(\"hamlet\")\n        realm = self.example_user(\"hamlet\").realm\n        stream = get_stream(\"Denmark\", realm)\n        self.unsubscribe(self.example_user(\"hamlet\"), \"Denmark\")\n        do_change_stream_permission(\n            stream, invite_only=True, acting_user=self.example_user(\"hamlet\")\n        )\n\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n        bot_info = {\n            \"default_events_register_stream\": \"Denmark\",\n        }\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        self.assert_json_error(result, \"Invalid stream name 'Denmark'\")\n\n    def test_patch_bot_events_register_stream_none(self) -> None:\n        self.login(\"hamlet\")\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n        bot_info = {\n            \"default_events_register_stream\": \"\",\n        }\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        self.assert_json_success(result)\n\n        bot_email = \"hambot-bot@zulip.testserver\"\n        bot_realm = get_realm(\"zulip\")\n        default_events_register_stream = get_user(\n            bot_email, bot_realm\n        ).default_events_register_stream\n        self.assertEqual(None, default_events_register_stream)\n\n        bot = self.get_bot()\n        self.assertEqual(None, bot[\"default_events_register_stream\"])\n\n    def test_patch_bot_events_register_stream_not_found(self) -> None:\n        self.login(\"hamlet\")\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n        bot_info = {\n            \"default_events_register_stream\": \"missing\",\n        }\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        self.assert_json_error(result, \"Invalid stream name 'missing'\")\n\n    def test_patch_bot_default_all_public_streams_true(self) -> None:\n        self.login(\"hamlet\")\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n        bot_info = {\n            \"default_all_public_streams\": orjson.dumps(True).decode(),\n        }\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        response_dict = self.assert_json_success(result)\n\n        self.assertEqual(response_dict[\"default_all_public_streams\"], True)\n\n        bot = self.get_bot()\n        self.assertEqual(bot[\"default_all_public_streams\"], True)\n\n    def test_patch_bot_default_all_public_streams_false(self) -> None:\n        self.login(\"hamlet\")\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n        bot_info = {\n            \"default_all_public_streams\": orjson.dumps(False).decode(),\n        }\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        response_dict = self.assert_json_success(result)\n\n        self.assertEqual(response_dict[\"default_all_public_streams\"], False)\n\n        bot = self.get_bot()\n        self.assertEqual(bot[\"default_all_public_streams\"], False)\n\n    def test_patch_bot_via_post(self) -> None:\n        self.login(\"hamlet\")\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n        bot_info = {\n            \"full_name\": \"Fred\",\n            \"method\": \"PATCH\",\n        }\n        email = \"hambot-bot@zulip.testserver\"\n        # Important: We intentionally use the wrong method, post, here.\n        result = self.client_post(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        response_dict = self.assert_json_success(result)\n\n        self.assertEqual(\"Fred\", response_dict[\"full_name\"])\n\n        bot = self.get_bot()\n        self.assertEqual(\"Fred\", bot[\"full_name\"])\n\n    def test_patch_bogus_bot(self) -> None:\n        \"\"\"Deleting a bogus bot will succeed silently.\"\"\"\n        self.login(\"hamlet\")\n        self.create_bot()\n        bot_info = {\n            \"full_name\": \"Fred\",\n        }\n        invalid_user_id = 1000\n        result = self.client_patch(f\"/json/bots/{invalid_user_id}\", bot_info)\n        self.assert_json_error(result, \"No such bot\")\n        self.assert_num_bots_equal(1)\n\n    def test_patch_outgoing_webhook_bot(self) -> None:\n        self.login(\"hamlet\")\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n            \"bot_type\": UserProfile.OUTGOING_WEBHOOK_BOT,\n            \"payload_url\": orjson.dumps(\"http://foo.bar.com\").decode(),\n            \"interface_type\": Service.GENERIC,\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n        bot_info = {\n            \"service_payload_url\": orjson.dumps(\"http://foo.bar2.com\").decode(),\n            \"service_interface\": Service.SLACK,\n        }\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        self.assert_json_success(result)\n\n        service_interface = orjson.loads(result.content)[\"service_interface\"]\n        self.assertEqual(service_interface, Service.SLACK)\n\n        service_payload_url = orjson.loads(result.content)[\"service_payload_url\"]\n        self.assertEqual(service_payload_url, \"http://foo.bar2.com\")\n\n    @patch(\"zulip_bots.bots.giphy.giphy.GiphyHandler.validate_config\")\n    def test_patch_bot_config_data(self, mock_validate_config: MagicMock) -> None:\n        self.create_test_bot(\n            \"test\",\n            self.example_user(\"hamlet\"),\n            full_name=\"Bot with config data\",\n            bot_type=UserProfile.EMBEDDED_BOT,\n            service_name=\"giphy\",\n            config_data=orjson.dumps({\"key\": \"12345678\"}).decode(),\n        )\n        bot_info = {\"config_data\": orjson.dumps({\"key\": \"87654321\"}).decode()}\n        email = \"test-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        self.assert_json_success(result)\n        config_data = orjson.loads(result.content)[\"config_data\"]\n        self.assertEqual(config_data, orjson.loads(bot_info[\"config_data\"]))\n\n    def test_outgoing_webhook_invalid_interface(self) -> None:\n        self.login(\"hamlet\")\n        bot_info = {\n            \"full_name\": \"Outgoing Webhook test bot\",\n            \"short_name\": \"outgoingservicebot\",\n            \"bot_type\": UserProfile.OUTGOING_WEBHOOK_BOT,\n            \"payload_url\": orjson.dumps(\"http://127.0.0.1:5002\").decode(),\n            \"interface_type\": -1,\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_error(result, \"Invalid interface type\")\n\n        bot_info[\"interface_type\"] = Service.GENERIC\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n\n    def test_create_outgoing_webhook_bot(self, **extras: Any) -> None:\n        self.login(\"hamlet\")\n        bot_info = {\n            \"full_name\": \"Outgoing Webhook test bot\",\n            \"short_name\": \"outgoingservicebot\",\n            \"bot_type\": UserProfile.OUTGOING_WEBHOOK_BOT,\n            \"payload_url\": orjson.dumps(\"http://127.0.0.1:5002\").decode(),\n        }\n        bot_info.update(extras)\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n\n        bot_email = \"outgoingservicebot-bot@zulip.testserver\"\n        bot_realm = get_realm(\"zulip\")\n        bot = get_user(bot_email, bot_realm)\n        [service] = get_bot_services(bot.id)\n\n        self.assertEqual(service.name, \"outgoingservicebot\")\n        self.assertEqual(service.base_url, \"http://127.0.0.1:5002\")\n        self.assertEqual(service.user_profile, bot)\n\n        # invalid URL test case.\n        bot_info[\"payload_url\"] = orjson.dumps(\"http://127.0.0.:5002\").decode()\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_error(result, \"payload_url is not a URL\")\n\n    def test_get_bot_handler(self) -> None:\n        # Test for valid service.\n        test_service_name = \"converter\"\n        test_bot_handler = get_bot_handler(test_service_name)\n        self.assertEqual(\n            str(type(test_bot_handler)),\n            \"<class 'zulip_bots.bots.converter.converter.ConverterHandler'>\",\n        )\n\n        # Test for invalid service.\n        test_service_name = \"incorrect_bot_service_foo\"\n        test_bot_handler = get_bot_handler(test_service_name)\n        self.assertEqual(test_bot_handler, None)\n\n    def test_if_each_embedded_bot_service_exists(self) -> None:\n        for embedded_bot in EMBEDDED_BOTS:\n            self.assertIsNotNone(get_bot_handler(embedded_bot.name))\n\n    def test_outgoing_webhook_interface_type(self) -> None:\n        self.login(\"hamlet\")\n        bot_info = {\n            \"full_name\": \"Outgoing Webhook test bot\",\n            \"short_name\": \"outgoingservicebot\",\n            \"bot_type\": UserProfile.OUTGOING_WEBHOOK_BOT,\n            \"payload_url\": orjson.dumps(\"http://127.0.0.1:5002\").decode(),\n            \"interface_type\": -1,\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_error(result, \"Invalid interface type\")\n\n        bot_info[\"interface_type\"] = Service.GENERIC\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n\n    def test_create_embedded_bot_with_disabled_embedded_bots(self, **extras: Any) -> None:\n        with self.settings(EMBEDDED_BOTS_ENABLED=False):\n            self.fail_to_create_test_bot(\n                short_name=\"embeddedservicebot\",\n                user_profile=self.example_user(\"hamlet\"),\n                bot_type=UserProfile.EMBEDDED_BOT,\n                service_name=\"followup\",\n                config_data=orjson.dumps({\"key\": \"value\"}).decode(),\n                assert_json_error_msg=\"Embedded bots are not enabled.\",\n                **extras,\n            )\n\n    def test_create_embedded_bot(self, **extras: Any) -> None:\n        bot_config_info = {\"key\": \"value\"}\n        self.create_test_bot(\n            short_name=\"embeddedservicebot\",\n            user_profile=self.example_user(\"hamlet\"),\n            bot_type=UserProfile.EMBEDDED_BOT,\n            service_name=\"followup\",\n            config_data=orjson.dumps(bot_config_info).decode(),\n            **extras,\n        )\n        bot_email = \"embeddedservicebot-bot@zulip.testserver\"\n        bot_realm = get_realm(\"zulip\")\n        bot = get_user(bot_email, bot_realm)\n        [service] = get_bot_services(bot.id)\n        bot_config = get_bot_config(bot)\n        self.assertEqual(bot_config, bot_config_info)\n        self.assertEqual(service.name, \"followup\")\n        self.assertEqual(service.user_profile, bot)\n\n    def test_create_embedded_bot_with_incorrect_service_name(self, **extras: Any) -> None:\n        self.fail_to_create_test_bot(\n            short_name=\"embeddedservicebot\",\n            user_profile=self.example_user(\"hamlet\"),\n            bot_type=UserProfile.EMBEDDED_BOT,\n            service_name=\"not_existing_service\",\n            assert_json_error_msg=\"Invalid embedded bot name.\",\n            **extras,\n        )\n\n    def test_create_embedded_bot_with_invalid_config_value(self, **extras: Any) -> None:\n        self.fail_to_create_test_bot(\n            short_name=\"embeddedservicebot\",\n            user_profile=self.example_user(\"hamlet\"),\n            service_name=\"followup\",\n            config_data=orjson.dumps({\"invalid\": [\"config\", \"value\"]}).decode(),\n            assert_json_error_msg=\"config_data contains a value that is not a string\",\n            **extras,\n        )\n\n        # Test to create embedded bot with an incorrect config value\n        incorrect_bot_config_info = {\"key\": \"incorrect key\"}\n        bot_info = {\n            \"full_name\": \"Embedded test bot\",\n            \"short_name\": \"embeddedservicebot3\",\n            \"bot_type\": UserProfile.EMBEDDED_BOT,\n            \"service_name\": \"giphy\",\n            \"config_data\": orjson.dumps(incorrect_bot_config_info).decode(),\n        }\n        bot_info.update(extras)\n        with patch(\n            \"zulip_bots.bots.giphy.giphy.GiphyHandler.validate_config\",\n            side_effect=ConfigValidationError,\n        ):\n            result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_error(result, \"Invalid configuration data!\")\n\n    def test_is_cross_realm_bot_email(self) -> None:\n        self.assertTrue(is_cross_realm_bot_email(\"notification-bot@zulip.com\"))\n        self.assertTrue(is_cross_realm_bot_email(\"notification-BOT@zulip.com\"))\n        self.assertFalse(is_cross_realm_bot_email(\"random-bot@zulip.com\"))\n\n        with self.settings(CROSS_REALM_BOT_EMAILS={\"random-bot@zulip.com\"}):\n            self.assertTrue(is_cross_realm_bot_email(\"random-bot@zulip.com\"))\n            self.assertFalse(is_cross_realm_bot_email(\"notification-bot@zulip.com\"))\n\n    @patch(\"zerver.lib.integrations.WEBHOOK_INTEGRATIONS\", stripe_sample_config_options)\n    def test_create_incoming_webhook_bot_with_service_name_and_with_keys(self) -> None:\n        self.login(\"hamlet\")\n        bot_metadata = {\n            \"full_name\": \"My Stripe Bot\",\n            \"short_name\": \"my-stripe\",\n            \"bot_type\": UserProfile.INCOMING_WEBHOOK_BOT,\n            \"service_name\": \"stripe\",\n            \"config_data\": orjson.dumps({\"stripe_api_key\": \"sample-api-key\"}).decode(),\n        }\n        self.create_bot(**bot_metadata)\n        new_bot = UserProfile.objects.get(full_name=\"My Stripe Bot\")\n        config_data = get_bot_config(new_bot)\n        self.assertEqual(\n            config_data, {\"integration_id\": \"stripe\", \"stripe_api_key\": \"sample-api-key\"}\n        )\n\n    @patch(\"zerver.lib.integrations.WEBHOOK_INTEGRATIONS\", stripe_sample_config_options)\n    def test_create_incoming_webhook_bot_with_service_name_incorrect_keys(self) -> None:\n        self.login(\"hamlet\")\n        bot_metadata = {\n            \"full_name\": \"My Stripe Bot\",\n            \"short_name\": \"my-stripe\",\n            \"bot_type\": UserProfile.INCOMING_WEBHOOK_BOT,\n            \"service_name\": \"stripe\",\n            \"config_data\": orjson.dumps({\"stripe_api_key\": \"_invalid_key\"}).decode(),\n        }\n        response = self.client_post(\"/json/bots\", bot_metadata)\n        self.assertEqual(response.status_code, 400)\n        expected_error_message = 'Invalid stripe_api_key value _invalid_key (stripe_api_key starts with a \"_\" and is hence invalid.)'\n        self.assertEqual(orjson.loads(response.content)[\"msg\"], expected_error_message)\n        with self.assertRaises(UserProfile.DoesNotExist):\n            UserProfile.objects.get(full_name=\"My Stripe Bot\")\n\n    @patch(\"zerver.lib.integrations.WEBHOOK_INTEGRATIONS\", stripe_sample_config_options)\n    def test_create_incoming_webhook_bot_with_service_name_without_keys(self) -> None:\n        self.login(\"hamlet\")\n        bot_metadata = {\n            \"full_name\": \"My Stripe Bot\",\n            \"short_name\": \"my-stripe\",\n            \"bot_type\": UserProfile.INCOMING_WEBHOOK_BOT,\n            \"service_name\": \"stripe\",\n        }\n        response = self.client_post(\"/json/bots\", bot_metadata)\n        self.assertEqual(response.status_code, 400)\n        expected_error_message = \"Missing configuration parameters: {'stripe_api_key'}\"\n        self.assertEqual(orjson.loads(response.content)[\"msg\"], expected_error_message)\n        with self.assertRaises(UserProfile.DoesNotExist):\n            UserProfile.objects.get(full_name=\"My Stripe Bot\")\n\n    @patch(\"zerver.lib.integrations.WEBHOOK_INTEGRATIONS\", stripe_sample_config_options)\n    def test_create_incoming_webhook_bot_without_service_name(self) -> None:\n        self.login(\"hamlet\")\n        bot_metadata = {\n            \"full_name\": \"My Stripe Bot\",\n            \"short_name\": \"my-stripe\",\n            \"bot_type\": UserProfile.INCOMING_WEBHOOK_BOT,\n        }\n        self.create_bot(**bot_metadata)\n        new_bot = UserProfile.objects.get(full_name=\"My Stripe Bot\")\n        with self.assertRaises(ConfigError):\n            get_bot_config(new_bot)\n\n    @patch(\"zerver.lib.integrations.WEBHOOK_INTEGRATIONS\", stripe_sample_config_options)\n    def test_create_incoming_webhook_bot_with_incorrect_service_name(self) -> None:\n        self.login(\"hamlet\")\n        bot_metadata = {\n            \"full_name\": \"My Stripe Bot\",\n            \"short_name\": \"my-stripe\",\n            \"bot_type\": UserProfile.INCOMING_WEBHOOK_BOT,\n            \"service_name\": \"stripes\",\n        }\n        response = self.client_post(\"/json/bots\", bot_metadata)\n        self.assertEqual(response.status_code, 400)\n        expected_error_message = \"Invalid integration 'stripes'.\"\n        self.assertEqual(orjson.loads(response.content)[\"msg\"], expected_error_message)\n        with self.assertRaises(UserProfile.DoesNotExist):\n            UserProfile.objects.get(full_name=\"My Stripe Bot\")\n", "from typing import Any, Dict, List, Optional, Union\n\nfrom django.conf import settings\nfrom django.contrib.auth.models import AnonymousUser\nfrom django.core.files.uploadedfile import UploadedFile\nfrom django.http import HttpRequest, HttpResponse\nfrom django.shortcuts import redirect\nfrom django.utils.translation import gettext as _\n\nfrom zerver.actions.bots import (\n    do_change_bot_owner,\n    do_change_default_all_public_streams,\n    do_change_default_events_register_stream,\n    do_change_default_sending_stream,\n)\nfrom zerver.actions.create_user import do_create_user, do_reactivate_user, notify_created_bot\nfrom zerver.actions.custom_profile_fields import (\n    check_remove_custom_profile_field_value,\n    do_update_user_custom_profile_data_if_changed,\n)\nfrom zerver.actions.user_settings import (\n    check_change_bot_full_name,\n    check_change_full_name,\n    do_change_avatar_fields,\n    do_regenerate_api_key,\n)\nfrom zerver.actions.users import (\n    do_change_user_role,\n    do_deactivate_user,\n    do_update_bot_config_data,\n    do_update_outgoing_webhook_service,\n)\nfrom zerver.context_processors import get_valid_realm_from_request\nfrom zerver.decorator import require_member_or_admin, require_realm_admin\nfrom zerver.forms import PASSWORD_TOO_WEAK_ERROR, CreateUserForm\nfrom zerver.lib.avatar import avatar_url, get_gravatar_url\nfrom zerver.lib.bot_config import set_bot_config\nfrom zerver.lib.email_validation import email_allowed_for_realm\nfrom zerver.lib.exceptions import (\n    CannotDeactivateLastUserError,\n    JsonableError,\n    MissingAuthenticationError,\n    OrganizationOwnerRequired,\n    RateLimited,\n)\nfrom zerver.lib.integrations import EMBEDDED_BOTS\nfrom zerver.lib.rate_limiter import rate_limit_spectator_attachment_access_by_file\nfrom zerver.lib.request import REQ, has_request_variables\nfrom zerver.lib.response import json_response_from_error, json_success\nfrom zerver.lib.streams import access_stream_by_id, access_stream_by_name, subscribed_to_stream\nfrom zerver.lib.types import ProfileDataElementUpdateDict, ProfileDataElementValue, Validator\nfrom zerver.lib.upload import upload_avatar_image\nfrom zerver.lib.url_encoding import append_url_query_string\nfrom zerver.lib.users import (\n    access_bot_by_id,\n    access_user_by_email,\n    access_user_by_id,\n    add_service,\n    check_bot_creation_policy,\n    check_bot_name_available,\n    check_full_name,\n    check_short_name,\n    check_valid_bot_config,\n    check_valid_bot_type,\n    check_valid_interface_type,\n    get_api_key,\n    get_raw_user_data,\n    validate_user_custom_profile_data,\n)\nfrom zerver.lib.utils import generate_api_key\nfrom zerver.lib.validator import (\n    check_bool,\n    check_dict,\n    check_dict_only,\n    check_int,\n    check_int_in,\n    check_list,\n    check_none_or,\n    check_string,\n    check_union,\n    check_url,\n)\nfrom zerver.models import (\n    DisposableEmailError,\n    DomainNotAllowedForRealmError,\n    EmailContainsPlusError,\n    InvalidFakeEmailDomain,\n    Message,\n    Realm,\n    Service,\n    Stream,\n    UserProfile,\n    get_user_by_delivery_email,\n    get_user_by_id_in_realm_including_cross_realm,\n    get_user_including_cross_realm,\n    get_user_profile_by_id_in_realm,\n)\nfrom zproject.backends import check_password_strength\n\n\ndef check_last_owner(user_profile: UserProfile) -> bool:\n    owners = set(user_profile.realm.get_human_owner_users())\n    return user_profile.is_realm_owner and not user_profile.is_bot and len(owners) == 1\n\n\ndef deactivate_user_backend(\n    request: HttpRequest, user_profile: UserProfile, user_id: int\n) -> HttpResponse:\n    target = access_user_by_id(user_profile, user_id, for_admin=True)\n    if target.is_realm_owner and not user_profile.is_realm_owner:\n        raise OrganizationOwnerRequired()\n    if check_last_owner(target):\n        raise JsonableError(_(\"Cannot deactivate the only organization owner\"))\n    return _deactivate_user_profile_backend(request, user_profile, target)\n\n\ndef deactivate_user_own_backend(request: HttpRequest, user_profile: UserProfile) -> HttpResponse:\n    if UserProfile.objects.filter(realm=user_profile.realm, is_active=True).count() == 1:\n        raise CannotDeactivateLastUserError(is_last_owner=False)\n    if user_profile.is_realm_owner and check_last_owner(user_profile):\n        raise CannotDeactivateLastUserError(is_last_owner=True)\n\n    do_deactivate_user(user_profile, acting_user=user_profile)\n    return json_success(request)\n\n\ndef deactivate_bot_backend(\n    request: HttpRequest, user_profile: UserProfile, bot_id: int\n) -> HttpResponse:\n    target = access_bot_by_id(user_profile, bot_id)\n    return _deactivate_user_profile_backend(request, user_profile, target)\n\n\ndef _deactivate_user_profile_backend(\n    request: HttpRequest, user_profile: UserProfile, target: UserProfile\n) -> HttpResponse:\n    do_deactivate_user(target, acting_user=user_profile)\n    return json_success(request)\n\n\ndef reactivate_user_backend(\n    request: HttpRequest, user_profile: UserProfile, user_id: int\n) -> HttpResponse:\n    target = access_user_by_id(\n        user_profile, user_id, allow_deactivated=True, allow_bots=True, for_admin=True\n    )\n    if target.is_bot:\n        assert target.bot_type is not None\n        check_bot_creation_policy(user_profile, target.bot_type)\n    do_reactivate_user(target, acting_user=user_profile)\n    return json_success(request)\n\n\ncheck_profile_data: Validator[\n    List[Dict[str, Optional[Union[int, ProfileDataElementValue]]]]\n] = check_list(\n    check_dict_only(\n        [\n            (\"id\", check_int),\n            (\n                \"value\",\n                check_none_or(\n                    check_union([check_string, check_list(check_int)]),\n                ),\n            ),\n        ]\n    ),\n)\n\n\n@has_request_variables\ndef update_user_backend(\n    request: HttpRequest,\n    user_profile: UserProfile,\n    user_id: int,\n    full_name: Optional[str] = REQ(default=None),\n    role: Optional[int] = REQ(\n        default=None,\n        json_validator=check_int_in(\n            UserProfile.ROLE_TYPES,\n        ),\n    ),\n    profile_data: Optional[List[Dict[str, Optional[Union[int, ProfileDataElementValue]]]]] = REQ(\n        default=None,\n        json_validator=check_profile_data,\n    ),\n) -> HttpResponse:\n    target = access_user_by_id(\n        user_profile, user_id, allow_deactivated=True, allow_bots=True, for_admin=True\n    )\n\n    if role is not None and target.role != role:\n        # Require that the current user has permissions to\n        # grant/remove the role in question.  access_user_by_id has\n        # already verified we're an administrator; here we enforce\n        # that only owners can toggle the is_realm_owner flag.\n        #\n        # Logic replicated in patch_bot_backend.\n        if UserProfile.ROLE_REALM_OWNER in [role, target.role] and not user_profile.is_realm_owner:\n            raise OrganizationOwnerRequired()\n\n        if target.role == UserProfile.ROLE_REALM_OWNER and check_last_owner(target):\n            raise JsonableError(\n                _(\"The owner permission cannot be removed from the only organization owner.\")\n            )\n        do_change_user_role(target, role, acting_user=user_profile)\n\n    if full_name is not None and target.full_name != full_name and full_name.strip() != \"\":\n        # We don't respect `name_changes_disabled` here because the request\n        # is on behalf of the administrator.\n        check_change_full_name(target, full_name, user_profile)\n\n    if profile_data is not None:\n        clean_profile_data: List[ProfileDataElementUpdateDict] = []\n        for entry in profile_data:\n            assert isinstance(entry[\"id\"], int)\n            assert not isinstance(entry[\"value\"], int)\n            if entry[\"value\"] is None or not entry[\"value\"]:\n                field_id = entry[\"id\"]\n                check_remove_custom_profile_field_value(target, field_id)\n            else:\n                clean_profile_data.append(\n                    {\n                        \"id\": entry[\"id\"],\n                        \"value\": entry[\"value\"],\n                    }\n                )\n        validate_user_custom_profile_data(target.realm.id, clean_profile_data)\n        do_update_user_custom_profile_data_if_changed(target, clean_profile_data)\n\n    return json_success(request)\n\n\ndef avatar(\n    request: HttpRequest,\n    maybe_user_profile: Union[UserProfile, AnonymousUser],\n    email_or_id: str,\n    medium: bool = False,\n) -> HttpResponse:\n    \"\"\"Accepts an email address or user ID and returns the avatar\"\"\"\n    is_email = False\n    try:\n        int(email_or_id)\n    except ValueError:\n        is_email = True\n\n    if not maybe_user_profile.is_authenticated:\n        # Allow anonymous access to avatars only if spectators are\n        # enabled in the organization.\n        realm = get_valid_realm_from_request(request)\n        if not realm.allow_web_public_streams_access():\n            raise MissingAuthenticationError()\n\n        # We only allow the ID format for accessing a user's avatar\n        # for spectators. This is mainly for defense in depth, since\n        # email_address_visibility should mean spectators only\n        # interact with fake email addresses anyway.\n        if is_email:\n            raise MissingAuthenticationError()\n\n        if settings.RATE_LIMITING:\n            try:\n                unique_avatar_key = f\"{realm.id}/{email_or_id}/{medium}\"\n                rate_limit_spectator_attachment_access_by_file(unique_avatar_key)\n            except RateLimited:\n                return json_response_from_error(\n                    RateLimited(_(\"Too many attempts, please try after some time.\"))\n                )\n    else:\n        realm = maybe_user_profile.realm\n\n    try:\n        if is_email:\n            avatar_user_profile = get_user_including_cross_realm(email_or_id, realm)\n        else:\n            avatar_user_profile = get_user_by_id_in_realm_including_cross_realm(\n                int(email_or_id), realm\n            )\n        # If there is a valid user account passed in, use its avatar\n        url = avatar_url(avatar_user_profile, medium=medium)\n    except UserProfile.DoesNotExist:\n        # If there is no such user, treat it as a new gravatar\n        email = email_or_id\n        avatar_version = 1\n        url = get_gravatar_url(email, avatar_version, medium)\n\n    # We can rely on the URL already having query parameters. Because\n    # our templates depend on being able to use the ampersand to\n    # add query parameters to our url, get_avatar_url does '?x=x'\n    # hacks to prevent us from having to jump through decode/encode hoops.\n    assert url is not None\n    url = append_url_query_string(url, request.META[\"QUERY_STRING\"])\n    return redirect(url)\n\n\ndef get_stream_name(stream: Optional[Stream]) -> Optional[str]:\n    if stream:\n        return stream.name\n    return None\n\n\n@require_member_or_admin\n@has_request_variables\ndef patch_bot_backend(\n    request: HttpRequest,\n    user_profile: UserProfile,\n    bot_id: int,\n    full_name: Optional[str] = REQ(default=None),\n    role: Optional[int] = REQ(\n        default=None,\n        json_validator=check_int_in(\n            UserProfile.ROLE_TYPES,\n        ),\n    ),\n    bot_owner_id: Optional[int] = REQ(json_validator=check_int, default=None),\n    config_data: Optional[Dict[str, str]] = REQ(\n        default=None, json_validator=check_dict(value_validator=check_string)\n    ),\n    service_payload_url: Optional[str] = REQ(json_validator=check_url, default=None),\n    service_interface: int = REQ(json_validator=check_int, default=1),\n    default_sending_stream: Optional[str] = REQ(default=None),\n    default_events_register_stream: Optional[str] = REQ(default=None),\n    default_all_public_streams: Optional[bool] = REQ(default=None, json_validator=check_bool),\n) -> HttpResponse:\n    bot = access_bot_by_id(user_profile, bot_id)\n\n    if full_name is not None:\n        check_change_bot_full_name(bot, full_name, user_profile)\n\n    if role is not None and bot.role != role:\n        # Logic duplicated from update_user_backend.\n        if UserProfile.ROLE_REALM_OWNER in [role, bot.role] and not user_profile.is_realm_owner:\n            raise OrganizationOwnerRequired()\n\n        do_change_user_role(bot, role, acting_user=user_profile)\n\n    if bot_owner_id is not None:\n        try:\n            owner = get_user_profile_by_id_in_realm(bot_owner_id, user_profile.realm)\n        except UserProfile.DoesNotExist:\n            raise JsonableError(_(\"Failed to change owner, no such user\"))\n        if not owner.is_active:\n            raise JsonableError(_(\"Failed to change owner, user is deactivated\"))\n        if owner.is_bot:\n            raise JsonableError(_(\"Failed to change owner, bots can't own other bots\"))\n\n        previous_owner = bot.bot_owner\n        if previous_owner != owner:\n            do_change_bot_owner(bot, owner, user_profile)\n\n    if default_sending_stream is not None:\n        if default_sending_stream == \"\":\n            stream: Optional[Stream] = None\n        else:\n            (stream, sub) = access_stream_by_name(user_profile, default_sending_stream)\n        do_change_default_sending_stream(bot, stream, acting_user=user_profile)\n    if default_events_register_stream is not None:\n        if default_events_register_stream == \"\":\n            stream = None\n        else:\n            (stream, sub) = access_stream_by_name(user_profile, default_events_register_stream)\n        do_change_default_events_register_stream(bot, stream, acting_user=user_profile)\n    if default_all_public_streams is not None:\n        do_change_default_all_public_streams(\n            bot, default_all_public_streams, acting_user=user_profile\n        )\n\n    if service_payload_url is not None:\n        check_valid_interface_type(service_interface)\n        assert service_interface is not None\n        do_update_outgoing_webhook_service(bot, service_interface, service_payload_url)\n\n    if config_data is not None:\n        do_update_bot_config_data(bot, config_data)\n\n    if len(request.FILES) == 0:\n        pass\n    elif len(request.FILES) == 1:\n        user_file = list(request.FILES.values())[0]\n        assert isinstance(user_file, UploadedFile)\n        assert user_file.size is not None\n        upload_avatar_image(user_file, user_profile, bot)\n        avatar_source = UserProfile.AVATAR_FROM_USER\n        do_change_avatar_fields(bot, avatar_source, acting_user=user_profile)\n    else:\n        raise JsonableError(_(\"You may only upload one file at a time\"))\n\n    json_result = dict(\n        full_name=bot.full_name,\n        avatar_url=avatar_url(bot),\n        service_interface=service_interface,\n        service_payload_url=service_payload_url,\n        config_data=config_data,\n        default_sending_stream=get_stream_name(bot.default_sending_stream),\n        default_events_register_stream=get_stream_name(bot.default_events_register_stream),\n        default_all_public_streams=bot.default_all_public_streams,\n    )\n\n    # Don't include the bot owner in case it is not set.\n    # Default bots have no owner.\n    if bot.bot_owner is not None:\n        json_result[\"bot_owner\"] = bot.bot_owner.email\n\n    return json_success(request, data=json_result)\n\n\n@require_member_or_admin\n@has_request_variables\ndef regenerate_bot_api_key(\n    request: HttpRequest, user_profile: UserProfile, bot_id: int\n) -> HttpResponse:\n    bot = access_bot_by_id(user_profile, bot_id)\n\n    new_api_key = do_regenerate_api_key(bot, user_profile)\n    json_result = dict(\n        api_key=new_api_key,\n    )\n    return json_success(request, data=json_result)\n\n\n@require_member_or_admin\n@has_request_variables\ndef add_bot_backend(\n    request: HttpRequest,\n    user_profile: UserProfile,\n    full_name_raw: str = REQ(\"full_name\"),\n    short_name_raw: str = REQ(\"short_name\"),\n    bot_type: int = REQ(json_validator=check_int, default=UserProfile.DEFAULT_BOT),\n    payload_url: str = REQ(json_validator=check_url, default=\"\"),\n    service_name: Optional[str] = REQ(default=None),\n    config_data: Dict[str, str] = REQ(\n        default={}, json_validator=check_dict(value_validator=check_string)\n    ),\n    interface_type: int = REQ(json_validator=check_int, default=Service.GENERIC),\n    default_sending_stream_name: Optional[str] = REQ(\"default_sending_stream\", default=None),\n    default_events_register_stream_name: Optional[str] = REQ(\n        \"default_events_register_stream\", default=None\n    ),\n    default_all_public_streams: Optional[bool] = REQ(json_validator=check_bool, default=None),\n) -> HttpResponse:\n    short_name = check_short_name(short_name_raw)\n    if bot_type != UserProfile.INCOMING_WEBHOOK_BOT:\n        service_name = service_name or short_name\n    short_name += \"-bot\"\n    full_name = check_full_name(full_name_raw)\n    try:\n        email = f\"{short_name}@{user_profile.realm.get_bot_domain()}\"\n    except InvalidFakeEmailDomain:\n        raise JsonableError(\n            _(\n                \"Can't create bots until FAKE_EMAIL_DOMAIN is correctly configured.\\n\"\n                \"Please contact your server administrator.\"\n            )\n        )\n    form = CreateUserForm({\"full_name\": full_name, \"email\": email})\n\n    if bot_type == UserProfile.EMBEDDED_BOT:\n        if not settings.EMBEDDED_BOTS_ENABLED:\n            raise JsonableError(_(\"Embedded bots are not enabled.\"))\n        if service_name not in [bot.name for bot in EMBEDDED_BOTS]:\n            raise JsonableError(_(\"Invalid embedded bot name.\"))\n\n    if not form.is_valid():\n        # We validate client-side as well\n        raise JsonableError(_(\"Bad name or username\"))\n    try:\n        get_user_by_delivery_email(email, user_profile.realm)\n        raise JsonableError(_(\"Username already in use\"))\n    except UserProfile.DoesNotExist:\n        pass\n\n    check_bot_name_available(\n        realm_id=user_profile.realm_id,\n        full_name=full_name,\n    )\n\n    check_bot_creation_policy(user_profile, bot_type)\n    check_valid_bot_type(user_profile, bot_type)\n    check_valid_interface_type(interface_type)\n\n    if len(request.FILES) == 0:\n        avatar_source = UserProfile.AVATAR_FROM_GRAVATAR\n    elif len(request.FILES) != 1:\n        raise JsonableError(_(\"You may only upload one file at a time\"))\n    else:\n        avatar_source = UserProfile.AVATAR_FROM_USER\n\n    default_sending_stream = None\n    if default_sending_stream_name is not None:\n        (default_sending_stream, ignored_sub) = access_stream_by_name(\n            user_profile, default_sending_stream_name\n        )\n\n    default_events_register_stream = None\n    if default_events_register_stream_name is not None:\n        (default_events_register_stream, ignored_sub) = access_stream_by_name(\n            user_profile, default_events_register_stream_name\n        )\n\n    if bot_type in (UserProfile.INCOMING_WEBHOOK_BOT, UserProfile.EMBEDDED_BOT) and service_name:\n        check_valid_bot_config(bot_type, service_name, config_data)\n\n    bot_profile = do_create_user(\n        email=email,\n        password=None,\n        realm=user_profile.realm,\n        full_name=full_name,\n        bot_type=bot_type,\n        bot_owner=user_profile,\n        avatar_source=avatar_source,\n        default_sending_stream=default_sending_stream,\n        default_events_register_stream=default_events_register_stream,\n        default_all_public_streams=default_all_public_streams,\n        acting_user=user_profile,\n    )\n    if len(request.FILES) == 1:\n        user_file = list(request.FILES.values())[0]\n        assert isinstance(user_file, UploadedFile)\n        assert user_file.size is not None\n        upload_avatar_image(user_file, user_profile, bot_profile)\n\n    if bot_type in (UserProfile.OUTGOING_WEBHOOK_BOT, UserProfile.EMBEDDED_BOT):\n        assert isinstance(service_name, str)\n        add_service(\n            name=service_name,\n            user_profile=bot_profile,\n            base_url=payload_url,\n            interface=interface_type,\n            token=generate_api_key(),\n        )\n\n    if bot_type == UserProfile.INCOMING_WEBHOOK_BOT and service_name:\n        set_bot_config(bot_profile, \"integration_id\", service_name)\n\n    if bot_type in (UserProfile.INCOMING_WEBHOOK_BOT, UserProfile.EMBEDDED_BOT):\n        for key, value in config_data.items():\n            set_bot_config(bot_profile, key, value)\n\n    notify_created_bot(bot_profile)\n\n    api_key = get_api_key(bot_profile)\n\n    json_result = dict(\n        user_id=bot_profile.id,\n        api_key=api_key,\n        avatar_url=avatar_url(bot_profile),\n        default_sending_stream=get_stream_name(bot_profile.default_sending_stream),\n        default_events_register_stream=get_stream_name(bot_profile.default_events_register_stream),\n        default_all_public_streams=bot_profile.default_all_public_streams,\n    )\n    return json_success(request, data=json_result)\n\n\n@require_member_or_admin\ndef get_bots_backend(request: HttpRequest, user_profile: UserProfile) -> HttpResponse:\n    bot_profiles = UserProfile.objects.filter(is_bot=True, is_active=True, bot_owner=user_profile)\n    bot_profiles = bot_profiles.select_related(\n        \"default_sending_stream\", \"default_events_register_stream\"\n    )\n    bot_profiles = bot_profiles.order_by(\"date_joined\")\n\n    def bot_info(bot_profile: UserProfile) -> Dict[str, Any]:\n        default_sending_stream = get_stream_name(bot_profile.default_sending_stream)\n        default_events_register_stream = get_stream_name(bot_profile.default_events_register_stream)\n\n        # Bots are supposed to have only one API key, at least for now.\n        # Therefore we can safely assume that one and only valid API key will be\n        # the first one.\n        api_key = get_api_key(bot_profile)\n\n        return dict(\n            username=bot_profile.email,\n            full_name=bot_profile.full_name,\n            api_key=api_key,\n            avatar_url=avatar_url(bot_profile),\n            default_sending_stream=default_sending_stream,\n            default_events_register_stream=default_events_register_stream,\n            default_all_public_streams=bot_profile.default_all_public_streams,\n        )\n\n    return json_success(request, data={\"bots\": list(map(bot_info, bot_profiles))})\n\n\ndef get_user_data(\n    user_profile: UserProfile,\n    include_custom_profile_fields: bool,\n    client_gravatar: bool,\n    target_user: Optional[UserProfile] = None,\n) -> Dict[str, Any]:\n    \"\"\"\n    The client_gravatar field here is set to True by default assuming that clients\n    can compute their own gravatars, which saves bandwidth. This is more important of\n    an optimization than it might seem because gravatar URLs contain MD5 hashes that\n    compress very poorly compared to other data.\n    \"\"\"\n    realm = user_profile.realm\n    if realm.email_address_visibility != Realm.EMAIL_ADDRESS_VISIBILITY_EVERYONE:\n        # If email addresses are only available to administrators,\n        # clients cannot compute gravatars, so we force-set it to false.\n        client_gravatar = False\n\n    members = get_raw_user_data(\n        realm,\n        user_profile,\n        target_user=target_user,\n        client_gravatar=client_gravatar,\n        user_avatar_url_field_optional=False,\n        include_custom_profile_fields=include_custom_profile_fields,\n    )\n\n    if target_user is not None:\n        data: Dict[str, Any] = {\"user\": members[target_user.id]}\n    else:\n        data = {\"members\": [members[k] for k in members]}\n\n    return data\n\n\n@has_request_variables\ndef get_members_backend(\n    request: HttpRequest,\n    user_profile: UserProfile,\n    user_id: Optional[int] = None,\n    include_custom_profile_fields: bool = REQ(json_validator=check_bool, default=False),\n    client_gravatar: bool = REQ(json_validator=check_bool, default=True),\n) -> HttpResponse:\n    target_user = None\n    if user_id is not None:\n        target_user = access_user_by_id(\n            user_profile, user_id, allow_deactivated=True, allow_bots=True, for_admin=False\n        )\n\n    data = get_user_data(user_profile, include_custom_profile_fields, client_gravatar, target_user)\n\n    return json_success(request, data)\n\n\n@require_realm_admin\n@has_request_variables\ndef create_user_backend(\n    request: HttpRequest,\n    user_profile: UserProfile,\n    email: str = REQ(),\n    password: str = REQ(),\n    full_name_raw: str = REQ(\"full_name\"),\n) -> HttpResponse:\n    if not user_profile.can_create_users:\n        raise JsonableError(_(\"User not authorized for this query\"))\n\n    full_name = check_full_name(full_name_raw)\n    form = CreateUserForm({\"full_name\": full_name, \"email\": email})\n    if not form.is_valid():\n        raise JsonableError(_(\"Bad name or username\"))\n\n    # Check that the new user's email address belongs to the admin's realm\n    # (Since this is an admin API, we don't require the user to have been\n    # invited first.)\n    realm = user_profile.realm\n    try:\n        email_allowed_for_realm(email, user_profile.realm)\n    except DomainNotAllowedForRealmError:\n        raise JsonableError(\n            _(\"Email '{email}' not allowed in this organization\").format(\n                email=email,\n            )\n        )\n    except DisposableEmailError:\n        raise JsonableError(_(\"Disposable email addresses are not allowed in this organization\"))\n    except EmailContainsPlusError:\n        raise JsonableError(_(\"Email addresses containing + are not allowed.\"))\n\n    try:\n        get_user_by_delivery_email(email, user_profile.realm)\n        raise JsonableError(_(\"Email '{}' already in use\").format(email))\n    except UserProfile.DoesNotExist:\n        pass\n\n    if not check_password_strength(password):\n        raise JsonableError(PASSWORD_TOO_WEAK_ERROR)\n\n    target_user = do_create_user(\n        email,\n        password,\n        realm,\n        full_name,\n        # Explicitly set tos_version=None. For servers that have\n        # configured Terms of Service, this means that users created\n        # via this mechanism will be prompted to accept the Terms of\n        # Service on first login.\n        tos_version=None,\n        acting_user=user_profile,\n    )\n    return json_success(request, data={\"user_id\": target_user.id})\n\n\ndef get_profile_backend(request: HttpRequest, user_profile: UserProfile) -> HttpResponse:\n    raw_user_data = get_raw_user_data(\n        user_profile.realm,\n        user_profile,\n        target_user=user_profile,\n        client_gravatar=False,\n        user_avatar_url_field_optional=False,\n    )\n    result: Dict[str, Any] = raw_user_data[user_profile.id]\n\n    result[\"max_message_id\"] = -1\n\n    messages = Message.objects.filter(usermessage__user_profile=user_profile).order_by(\"-id\")[:1]\n    if messages:\n        result[\"max_message_id\"] = messages[0].id\n\n    return json_success(request, data=result)\n\n\n@has_request_variables\ndef get_subscription_backend(\n    request: HttpRequest,\n    user_profile: UserProfile,\n    user_id: int = REQ(json_validator=check_int, path_only=True),\n    stream_id: int = REQ(json_validator=check_int, path_only=True),\n) -> HttpResponse:\n    target_user = access_user_by_id(user_profile, user_id, for_admin=False)\n    (stream, sub) = access_stream_by_id(user_profile, stream_id, allow_realm_admin=True)\n\n    subscription_status = {\"is_subscribed\": subscribed_to_stream(target_user, stream_id)}\n\n    return json_success(request, data=subscription_status)\n\n\n@has_request_variables\ndef get_user_by_email(\n    request: HttpRequest,\n    user_profile: UserProfile,\n    email: str,\n    include_custom_profile_fields: bool = REQ(json_validator=check_bool, default=False),\n    client_gravatar: bool = REQ(json_validator=check_bool, default=True),\n) -> HttpResponse:\n    target_user = access_user_by_email(\n        user_profile, email, allow_deactivated=True, allow_bots=True, for_admin=False\n    )\n\n    data = get_user_data(user_profile, include_custom_profile_fields, client_gravatar, target_user)\n    return json_success(request, data)\n"], "fixing_code": ["import filecmp\nimport os\nfrom typing import Any, Dict, List, Mapping, Optional\nfrom unittest.mock import MagicMock, patch\n\nimport orjson\nfrom django.core import mail\nfrom django.test import override_settings\nfrom zulip_bots.custom_exceptions import ConfigValidationError\n\nfrom zerver.actions.bots import do_change_bot_owner\nfrom zerver.actions.realm_settings import do_set_realm_property\nfrom zerver.actions.streams import do_change_stream_permission\nfrom zerver.actions.users import do_change_can_create_users, do_change_user_role, do_deactivate_user\nfrom zerver.lib.bot_config import ConfigError, get_bot_config\nfrom zerver.lib.bot_lib import get_bot_handler\nfrom zerver.lib.integrations import EMBEDDED_BOTS, WebhookIntegration\nfrom zerver.lib.test_classes import UploadSerializeMixin, ZulipTestCase\nfrom zerver.lib.test_helpers import avatar_disk_path, get_test_image_file, queries_captured\nfrom zerver.models import (\n    Realm,\n    Service,\n    UserProfile,\n    get_bot_services,\n    get_realm,\n    get_stream,\n    get_user,\n    is_cross_realm_bot_email,\n)\n\n\n# A test validator\ndef _check_string(var_name: str, val: str) -> Optional[str]:\n    if val.startswith(\"_\"):\n        return f'{var_name} starts with a \"_\" and is hence invalid.'\n    return None\n\n\nstripe_sample_config_options = [\n    WebhookIntegration(\n        \"stripe\",\n        [\"financial\"],\n        display_name=\"Stripe\",\n        config_options=[(\"Stripe API key\", \"stripe_api_key\", _check_string)],\n    ),\n]\n\n\nclass BotTest(ZulipTestCase, UploadSerializeMixin):\n    def get_bot_user(self, email: str) -> UserProfile:\n        realm = get_realm(\"zulip\")\n        bot = get_user(email, realm)\n        return bot\n\n    def assert_num_bots_equal(self, count: int) -> None:\n        result = self.client_get(\"/json/bots\")\n        response_dict = self.assert_json_success(result)\n        self.assert_length(response_dict[\"bots\"], count)\n\n    def create_bot(self, **extras: Any) -> Dict[str, Any]:\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n            \"bot_type\": \"1\",\n        }\n        bot_info.update(extras)\n        result = self.client_post(\"/json/bots\", bot_info)\n        response_dict = self.assert_json_success(result)\n        return response_dict\n\n    def test_bot_domain(self) -> None:\n        self.login(\"hamlet\")\n        self.create_bot()\n        self.assertTrue(UserProfile.objects.filter(email=\"hambot-bot@zulip.testserver\").exists())\n        # The other cases are hard to test directly, since we don't allow creating bots from\n        # the wrong subdomain, and because 'testserver.example.com' is not a valid domain for the bot's email.\n        # So we just test the Realm.get_bot_domain function.\n        realm = get_realm(\"zulip\")\n        self.assertEqual(realm.get_bot_domain(), \"zulip.testserver\")\n\n    def deactivate_bot(self) -> None:\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_delete(f\"/json/bots/{self.get_bot_user(email).id}\")\n        self.assert_json_success(result)\n\n    def test_add_bot_with_bad_username(self) -> None:\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n\n        # Invalid username\n        bot_info = dict(\n            full_name=\"My bot name\",\n            short_name=\"@\",\n        )\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_error(result, \"Bad name or username\")\n        self.assert_num_bots_equal(0)\n\n        # Empty username\n        bot_info = dict(\n            full_name=\"My bot name\",\n            short_name=\"\",\n        )\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_error(result, \"Bad name or username\")\n        self.assert_num_bots_equal(0)\n\n    @override_settings(FAKE_EMAIL_DOMAIN=\"invaliddomain\", REALM_HOSTS={\"zulip\": \"127.0.0.1\"})\n    def test_add_bot_with_invalid_fake_email_domain(self) -> None:\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n            \"bot_type\": \"1\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n\n        error_message = (\n            \"Can't create bots until FAKE_EMAIL_DOMAIN is correctly configured.\\n\"\n            + \"Please contact your server administrator.\"\n        )\n        self.assert_json_error(result, error_message)\n        self.assert_num_bots_equal(0)\n\n    def test_add_bot_with_no_name(self) -> None:\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        bot_info = dict(\n            full_name=\"a\",\n            short_name=\"bot\",\n        )\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_error(result, \"Name too short!\")\n        self.assert_num_bots_equal(0)\n\n    def test_json_users_with_bots(self) -> None:\n        hamlet = self.example_user(\"hamlet\")\n        self.login_user(hamlet)\n        self.assert_num_bots_equal(0)\n\n        num_bots = 3\n        for i in range(num_bots):\n            full_name = f\"Bot {i}\"\n            short_name = f\"bot-{i}\"\n            bot_info = dict(\n                full_name=full_name,\n                short_name=short_name,\n                bot_type=1,\n            )\n            result = self.client_post(\"/json/bots\", bot_info)\n            self.assert_json_success(result)\n\n        self.assert_num_bots_equal(num_bots)\n\n        with queries_captured() as queries:\n            users_result = self.client_get(\"/json/users\")\n\n        self.assert_json_success(users_result)\n\n        self.assert_length(queries, 3)\n\n    def test_add_bot(self) -> None:\n        hamlet = self.example_user(\"hamlet\")\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        events: List[Mapping[str, Any]] = []\n        with self.tornado_redirected_to_list(events, expected_num_events=5):\n            result = self.create_bot()\n        self.assert_num_bots_equal(1)\n\n        email = \"hambot-bot@zulip.testserver\"\n        bot = self.get_bot_user(email)\n\n        (event,) = (e for e in events if e[\"event\"][\"type\"] == \"realm_bot\")\n\n        self.assertEqual(result[\"user_id\"], bot.id)\n        self.assertEqual(\n            dict(\n                type=\"realm_bot\",\n                op=\"add\",\n                bot=dict(\n                    email=\"hambot-bot@zulip.testserver\",\n                    user_id=bot.id,\n                    bot_type=bot.bot_type,\n                    full_name=\"The Bot of Hamlet\",\n                    is_active=True,\n                    api_key=result[\"api_key\"],\n                    avatar_url=result[\"avatar_url\"],\n                    default_sending_stream=None,\n                    default_events_register_stream=None,\n                    default_all_public_streams=False,\n                    services=[],\n                    owner_id=hamlet.id,\n                ),\n            ),\n            event[\"event\"],\n        )\n\n        users_result = self.client_get(\"/json/users\")\n        members = orjson.loads(users_result.content)[\"members\"]\n        [bot_dict] = [m for m in members if m[\"email\"] == \"hambot-bot@zulip.testserver\"]\n        self.assertEqual(bot_dict[\"bot_owner_id\"], self.example_user(\"hamlet\").id)\n        self.assertEqual(bot_dict[\"user_id\"], self.get_bot_user(email).id)\n\n    @override_settings(FAKE_EMAIL_DOMAIN=\"fakedomain.com\", REALM_HOSTS={\"zulip\": \"127.0.0.1\"})\n    def test_add_bot_with_fake_email_domain(self) -> None:\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        self.create_bot()\n        self.assert_num_bots_equal(1)\n\n        email = \"hambot-bot@fakedomain.com\"\n        self.get_bot_user(email)\n\n    @override_settings(EXTERNAL_HOST=\"example.com\")\n    def test_add_bot_verify_subdomain_in_email_address(self) -> None:\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        self.create_bot()\n        self.assert_num_bots_equal(1)\n\n        email = \"hambot-bot@zulip.example.com\"\n        self.get_bot_user(email)\n\n    @override_settings(\n        FAKE_EMAIL_DOMAIN=\"fakedomain.com\", REALM_HOSTS={\"zulip\": \"zulip.example.com\"}\n    )\n    def test_add_bot_host_used_as_domain_if_valid(self) -> None:\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        self.create_bot()\n        self.assert_num_bots_equal(1)\n\n        email = \"hambot-bot@zulip.example.com\"\n        self.get_bot_user(email)\n\n    def test_add_bot_with_username_in_use(self) -> None:\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        self.create_bot()\n        self.assert_num_bots_equal(1)\n\n        # The short_name is used in the email, which we call\n        # \"Username\" for legacy reasons.\n        bot_info = dict(\n            full_name=\"whatever\",\n            short_name=\"hambot\",\n        )\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_error(result, \"Username already in use\")\n\n        dup_full_name = \"The Bot of Hamlet\"\n\n        bot_info = dict(\n            full_name=dup_full_name,\n            short_name=\"whatever\",\n        )\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_error(result, \"Name is already in use!\")\n\n    def test_add_bot_with_user_avatar(self) -> None:\n        email = \"hambot-bot@zulip.testserver\"\n        realm = get_realm(\"zulip\")\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        with get_test_image_file(\"img.png\") as fp:\n            self.create_bot(file=fp)\n            profile = get_user(email, realm)\n            # Make sure that avatar image that we've uploaded is same with avatar image in the server\n            self.assertTrue(\n                filecmp.cmp(fp.name, os.path.splitext(avatar_disk_path(profile))[0] + \".original\")\n            )\n        self.assert_num_bots_equal(1)\n\n        self.assertEqual(profile.avatar_source, UserProfile.AVATAR_FROM_USER)\n        self.assertTrue(os.path.exists(avatar_disk_path(profile)))\n\n    def test_add_bot_with_too_many_files(self) -> None:\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        with get_test_image_file(\"img.png\") as fp1, get_test_image_file(\"img.gif\") as fp2:\n            bot_info = dict(\n                full_name=\"whatever\",\n                short_name=\"whatever\",\n                file1=fp1,\n                file2=fp2,\n            )\n            result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_error(result, \"You may only upload one file at a time\")\n        self.assert_num_bots_equal(0)\n\n    def test_add_bot_with_default_sending_stream(self) -> None:\n        email = \"hambot-bot@zulip.testserver\"\n        realm = get_realm(\"zulip\")\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        result = self.create_bot(default_sending_stream=\"Denmark\")\n        self.assert_num_bots_equal(1)\n        self.assertEqual(result[\"default_sending_stream\"], \"Denmark\")\n\n        profile = get_user(email, realm)\n        assert profile.default_sending_stream is not None\n        self.assertEqual(profile.default_sending_stream.name, \"Denmark\")\n\n    def test_add_bot_with_default_sending_stream_not_subscribed(self) -> None:\n        email = \"hambot-bot@zulip.testserver\"\n        realm = get_realm(\"zulip\")\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        result = self.create_bot(default_sending_stream=\"Rome\")\n        self.assert_num_bots_equal(1)\n        self.assertEqual(result[\"default_sending_stream\"], \"Rome\")\n\n        profile = get_user(email, realm)\n        assert profile.default_sending_stream is not None\n        self.assertEqual(profile.default_sending_stream.name, \"Rome\")\n\n    def test_add_bot_email_address_visibility(self) -> None:\n        # Test that we don't mangle the email field with\n        # email_address_visiblity limited to admins\n        user = self.example_user(\"hamlet\")\n        do_set_realm_property(\n            user.realm,\n            \"email_address_visibility\",\n            Realm.EMAIL_ADDRESS_VISIBILITY_ADMINS,\n            acting_user=None,\n        )\n        user.refresh_from_db()\n\n        self.login_user(user)\n        self.assert_num_bots_equal(0)\n        events: List[Mapping[str, Any]] = []\n        with self.tornado_redirected_to_list(events, expected_num_events=5):\n            result = self.create_bot()\n        self.assert_num_bots_equal(1)\n\n        email = \"hambot-bot@zulip.testserver\"\n        bot = self.get_bot_user(email)\n\n        (event,) = (e for e in events if e[\"event\"][\"type\"] == \"realm_bot\")\n        self.assertEqual(\n            dict(\n                type=\"realm_bot\",\n                op=\"add\",\n                bot=dict(\n                    email=\"hambot-bot@zulip.testserver\",\n                    user_id=bot.id,\n                    bot_type=bot.bot_type,\n                    full_name=\"The Bot of Hamlet\",\n                    is_active=True,\n                    api_key=result[\"api_key\"],\n                    avatar_url=result[\"avatar_url\"],\n                    default_sending_stream=None,\n                    default_events_register_stream=None,\n                    default_all_public_streams=False,\n                    services=[],\n                    owner_id=user.id,\n                ),\n            ),\n            event[\"event\"],\n        )\n\n        users_result = self.client_get(\"/json/users\")\n        members = orjson.loads(users_result.content)[\"members\"]\n        [bot_dict] = [m for m in members if m[\"email\"] == \"hambot-bot@zulip.testserver\"]\n        self.assertEqual(bot_dict[\"bot_owner_id\"], user.id)\n        self.assertEqual(bot_dict[\"user_id\"], self.get_bot_user(email).id)\n\n    def test_bot_add_subscription(self) -> None:\n        \"\"\"\n        Calling POST /json/users/me/subscriptions should successfully add\n        streams, and a stream to the\n        list of subscriptions and confirm the right number of events\n        are generated.\n        When 'principals' has a bot, no notification message event or invitation email\n        is sent when add_subscriptions_backend is called in the above API call.\n        \"\"\"\n        hamlet = self.example_user(\"hamlet\")\n        iago = self.example_user(\"iago\")\n        self.login_user(hamlet)\n\n        # Normal user i.e. not a bot.\n        request_data = {\n            \"principals\": '[\"' + iago.email + '\"]',\n        }\n        events: List[Mapping[str, Any]] = []\n        with self.tornado_redirected_to_list(events, expected_num_events=3):\n            result = self.common_subscribe_to_streams(hamlet, [\"Rome\"], request_data)\n            self.assert_json_success(result)\n\n        msg_event = [e for e in events if e[\"event\"][\"type\"] == \"message\"]\n        self.assert_length(msg_event, 1)  # Notification message event is sent.\n\n        # Create a bot.\n        self.assert_num_bots_equal(0)\n        self.create_bot()\n        self.assert_num_bots_equal(1)\n\n        # A bot\n        bot_request_data = {\n            \"principals\": '[\"hambot-bot@zulip.testserver\"]',\n        }\n        events_bot: List[Mapping[str, Any]] = []\n        with self.tornado_redirected_to_list(events_bot, expected_num_events=2):\n            result = self.common_subscribe_to_streams(hamlet, [\"Rome\"], bot_request_data)\n            self.assert_json_success(result)\n\n        # No notification message event or invitation email is sent because of bot.\n        msg_event = [e for e in events_bot if e[\"event\"][\"type\"] == \"message\"]\n        self.assert_length(msg_event, 0)\n        self.assert_length(events_bot, len(events) - 1)\n\n        # Test runner automatically redirects all sent email to a dummy 'outbox'.\n        self.assert_length(mail.outbox, 0)\n\n    def test_add_bot_with_default_sending_stream_private_allowed(self) -> None:\n        self.login(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        stream = get_stream(\"Denmark\", user_profile.realm)\n        self.subscribe(user_profile, stream.name)\n        do_change_stream_permission(stream, invite_only=True, acting_user=user_profile)\n\n        self.assert_num_bots_equal(0)\n        events: List[Mapping[str, Any]] = []\n        with self.tornado_redirected_to_list(events, expected_num_events=5):\n            result = self.create_bot(default_sending_stream=\"Denmark\")\n        self.assert_num_bots_equal(1)\n        self.assertEqual(result[\"default_sending_stream\"], \"Denmark\")\n\n        email = \"hambot-bot@zulip.testserver\"\n        realm = get_realm(\"zulip\")\n        profile = get_user(email, realm)\n        assert profile.default_sending_stream is not None\n        self.assertEqual(profile.default_sending_stream.name, \"Denmark\")\n\n        (event,) = (e for e in events if e[\"event\"][\"type\"] == \"realm_bot\")\n        self.assertEqual(\n            dict(\n                type=\"realm_bot\",\n                op=\"add\",\n                bot=dict(\n                    email=\"hambot-bot@zulip.testserver\",\n                    user_id=profile.id,\n                    full_name=\"The Bot of Hamlet\",\n                    bot_type=profile.bot_type,\n                    is_active=True,\n                    api_key=result[\"api_key\"],\n                    avatar_url=result[\"avatar_url\"],\n                    default_sending_stream=\"Denmark\",\n                    default_events_register_stream=None,\n                    default_all_public_streams=False,\n                    services=[],\n                    owner_id=user_profile.id,\n                ),\n            ),\n            event[\"event\"],\n        )\n        self.assertEqual(event[\"users\"], [user_profile.id])\n\n    def test_add_bot_with_default_sending_stream_private_denied(self) -> None:\n        self.login(\"hamlet\")\n        realm = self.example_user(\"hamlet\").realm\n        stream = get_stream(\"Denmark\", realm)\n        self.unsubscribe(self.example_user(\"hamlet\"), \"Denmark\")\n        do_change_stream_permission(\n            stream, invite_only=True, acting_user=self.example_user(\"hamlet\")\n        )\n\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n            \"default_sending_stream\": \"Denmark\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_error(result, \"Invalid stream name 'Denmark'\")\n\n    def test_add_bot_with_default_events_register_stream(self) -> None:\n        bot_email = \"hambot-bot@zulip.testserver\"\n        bot_realm = get_realm(\"zulip\")\n\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        result = self.create_bot(default_events_register_stream=\"Denmark\")\n        self.assert_num_bots_equal(1)\n        self.assertEqual(result[\"default_events_register_stream\"], \"Denmark\")\n\n        profile = get_user(bot_email, bot_realm)\n        assert profile.default_events_register_stream is not None\n        self.assertEqual(profile.default_events_register_stream.name, \"Denmark\")\n\n    def test_add_bot_with_default_events_register_stream_private_allowed(self) -> None:\n        self.login(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        stream = self.subscribe(user_profile, \"Denmark\")\n        do_change_stream_permission(stream, invite_only=True, acting_user=user_profile)\n\n        self.assert_num_bots_equal(0)\n        events: List[Mapping[str, Any]] = []\n        with self.tornado_redirected_to_list(events, expected_num_events=5):\n            result = self.create_bot(default_events_register_stream=\"Denmark\")\n        self.assert_num_bots_equal(1)\n        self.assertEqual(result[\"default_events_register_stream\"], \"Denmark\")\n\n        bot_email = \"hambot-bot@zulip.testserver\"\n        bot_realm = get_realm(\"zulip\")\n        bot_profile = get_user(bot_email, bot_realm)\n        assert bot_profile.default_events_register_stream is not None\n        self.assertEqual(bot_profile.default_events_register_stream.name, \"Denmark\")\n\n        (event,) = (e for e in events if e[\"event\"][\"type\"] == \"realm_bot\")\n        self.assertEqual(\n            dict(\n                type=\"realm_bot\",\n                op=\"add\",\n                bot=dict(\n                    email=\"hambot-bot@zulip.testserver\",\n                    full_name=\"The Bot of Hamlet\",\n                    user_id=bot_profile.id,\n                    bot_type=bot_profile.bot_type,\n                    is_active=True,\n                    api_key=result[\"api_key\"],\n                    avatar_url=result[\"avatar_url\"],\n                    default_sending_stream=None,\n                    default_events_register_stream=\"Denmark\",\n                    default_all_public_streams=False,\n                    services=[],\n                    owner_id=user_profile.id,\n                ),\n            ),\n            event[\"event\"],\n        )\n        self.assertEqual(event[\"users\"], [user_profile.id])\n\n    def test_add_bot_with_default_events_register_stream_private_denied(self) -> None:\n        self.login(\"hamlet\")\n        realm = self.example_user(\"hamlet\").realm\n        stream = get_stream(\"Denmark\", realm)\n        self.unsubscribe(self.example_user(\"hamlet\"), \"Denmark\")\n        do_change_stream_permission(\n            stream, invite_only=True, acting_user=self.example_user(\"hamlet\")\n        )\n\n        self.assert_num_bots_equal(0)\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n            \"default_events_register_stream\": \"Denmark\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_error(result, \"Invalid stream name 'Denmark'\")\n\n    def test_add_bot_with_default_all_public_streams(self) -> None:\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        result = self.create_bot(default_all_public_streams=orjson.dumps(True).decode())\n        self.assert_num_bots_equal(1)\n        self.assertTrue(result[\"default_all_public_streams\"])\n\n        bot_email = \"hambot-bot@zulip.testserver\"\n        bot_realm = get_realm(\"zulip\")\n        profile = get_user(bot_email, bot_realm)\n        self.assertEqual(profile.default_all_public_streams, True)\n\n    def test_deactivate_bot(self) -> None:\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        self.create_bot()\n        self.assert_num_bots_equal(1)\n        self.deactivate_bot()\n        # You can deactivate the same bot twice.\n        self.deactivate_bot()\n        self.assert_num_bots_equal(0)\n\n    def test_deactivate_bogus_bot(self) -> None:\n        \"\"\"Deleting a bogus bot will succeed silently.\"\"\"\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        self.create_bot()\n        self.assert_num_bots_equal(1)\n        invalid_user_id = 1000\n        result = self.client_delete(f\"/json/bots/{invalid_user_id}\")\n        self.assert_json_error(result, \"No such bot\")\n        self.assert_num_bots_equal(1)\n\n    def test_deactivate_bot_with_owner_deactivation(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n\n        bot_info = {\n            \"full_name\": \"The Another Bot of Hamlet\",\n            \"short_name\": \"hambot-another\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n\n        self.assertEqual(\n            UserProfile.objects.filter(is_bot=True, bot_owner=user, is_active=True).count(), 2\n        )\n\n        result = self.client_delete(\"/json/users/me\")\n        self.assert_json_success(result)\n        user = self.example_user(\"hamlet\")\n        self.assertFalse(user.is_active)\n\n        self.login(\"iago\")\n        self.assertFalse(\n            UserProfile.objects.filter(is_bot=True, bot_owner=user, is_active=True).exists()\n        )\n\n    def test_cannot_deactivate_other_realm_bot(self) -> None:\n        user = self.mit_user(\"starnine\")\n        self.login_user(user)\n        bot_info = {\n            \"full_name\": \"The Bot in zephyr\",\n            \"short_name\": \"starn-bot\",\n            \"bot_type\": \"1\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info, subdomain=\"zephyr\")\n        self.assert_json_success(result)\n        result = self.client_get(\"/json/bots\", subdomain=\"zephyr\")\n        response_dict = self.assert_json_success(result)\n        bot_email = response_dict[\"bots\"][0][\"username\"]\n        bot = get_user(bot_email, user.realm)\n        self.login(\"iago\")\n        result = self.client_delete(f\"/json/bots/{bot.id}\")\n        self.assert_json_error(result, \"No such bot\")\n\n    def test_bot_deactivation_attacks(self) -> None:\n        \"\"\"You cannot deactivate somebody else's bot.\"\"\"\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        self.create_bot()\n        self.assert_num_bots_equal(1)\n\n        # Have Othello try to deactivate both Hamlet and\n        # Hamlet's bot.\n        self.login(\"othello\")\n\n        # Cannot deactivate a user as a bot\n        result = self.client_delete(\"/json/bots/{}\".format(self.example_user(\"hamlet\").id))\n        self.assert_json_error(result, \"No such bot\")\n\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_delete(f\"/json/bots/{self.get_bot_user(email).id}\")\n        self.assert_json_error(result, \"Insufficient permission\")\n\n        # But we don't actually deactivate the other person's bot.\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(1)\n\n        # Cannot deactivate a bot as a user\n        result = self.client_delete(f\"/json/users/{self.get_bot_user(email).id}\")\n        self.assert_json_error(result, \"No such user\")\n        self.assert_num_bots_equal(1)\n\n    def test_bot_permissions(self) -> None:\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        self.create_bot()\n        self.assert_num_bots_equal(1)\n\n        # Have Othello try to mess with Hamlet's bots.\n        self.login(\"othello\")\n        email = \"hambot-bot@zulip.testserver\"\n\n        result = self.client_post(f\"/json/bots/{self.get_bot_user(email).id}/api_key/regenerate\")\n        self.assert_json_error(result, \"Insufficient permission\")\n\n        bot_info = {\n            \"full_name\": \"Fred\",\n        }\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        self.assert_json_error(result, \"Insufficient permission\")\n\n    def get_bot(self) -> Dict[str, Any]:\n        result = self.client_get(\"/json/bots\")\n        return self.assert_json_success(result)[\"bots\"][0]\n\n    def test_update_api_key(self) -> None:\n        self.login(\"hamlet\")\n        self.create_bot()\n        bot = self.get_bot()\n        old_api_key = bot[\"api_key\"]\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_post(f\"/json/bots/{self.get_bot_user(email).id}/api_key/regenerate\")\n        new_api_key = self.assert_json_success(result)[\"api_key\"]\n        self.assertNotEqual(old_api_key, new_api_key)\n        bot = self.get_bot()\n        self.assertEqual(new_api_key, bot[\"api_key\"])\n\n    def test_update_api_key_for_invalid_user(self) -> None:\n        self.login(\"hamlet\")\n        invalid_user_id = 1000\n        result = self.client_post(f\"/json/bots/{invalid_user_id}/api_key/regenerate\")\n        self.assert_json_error(result, \"No such bot\")\n\n    def test_add_bot_with_bot_type_default(self) -> None:\n        bot_email = \"hambot-bot@zulip.testserver\"\n        bot_realm = get_realm(\"zulip\")\n\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        self.create_bot(bot_type=UserProfile.DEFAULT_BOT)\n        self.assert_num_bots_equal(1)\n\n        profile = get_user(bot_email, bot_realm)\n        self.assertEqual(profile.bot_type, UserProfile.DEFAULT_BOT)\n\n    def test_add_bot_with_bot_type_incoming_webhook(self) -> None:\n        bot_email = \"hambot-bot@zulip.testserver\"\n        bot_realm = get_realm(\"zulip\")\n\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        self.create_bot(bot_type=UserProfile.INCOMING_WEBHOOK_BOT)\n        self.assert_num_bots_equal(1)\n\n        profile = get_user(bot_email, bot_realm)\n        self.assertEqual(profile.bot_type, UserProfile.INCOMING_WEBHOOK_BOT)\n\n    def test_add_bot_with_bot_type_invalid(self) -> None:\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n            \"bot_type\": 7,\n        }\n\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_num_bots_equal(0)\n        self.assert_json_error(result, \"Invalid bot type\")\n\n    def test_no_generic_bots_allowed_for_non_admins(self) -> None:\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n            \"bot_type\": 1,\n        }\n        bot_email = \"hambot-bot@zulip.testserver\"\n        bot_realm = get_realm(\"zulip\")\n        bot_realm.bot_creation_policy = Realm.BOT_CREATION_LIMIT_GENERIC_BOTS\n        bot_realm.save(update_fields=[\"bot_creation_policy\"])\n\n        # A regular user cannot create a generic bot\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_num_bots_equal(0)\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n        # But can create an incoming webhook\n        self.assert_num_bots_equal(0)\n        self.create_bot(bot_type=UserProfile.INCOMING_WEBHOOK_BOT)\n        self.assert_num_bots_equal(1)\n        profile = get_user(bot_email, bot_realm)\n        self.assertEqual(profile.bot_type, UserProfile.INCOMING_WEBHOOK_BOT)\n\n    def test_no_generic_bot_reactivation_allowed_for_non_admins(self) -> None:\n        self.login(\"hamlet\")\n        self.create_bot(bot_type=UserProfile.DEFAULT_BOT)\n\n        bot_realm = get_realm(\"zulip\")\n        bot_realm.bot_creation_policy = Realm.BOT_CREATION_LIMIT_GENERIC_BOTS\n        bot_realm.save(update_fields=[\"bot_creation_policy\"])\n\n        bot_email = \"hambot-bot@zulip.testserver\"\n        bot_user = get_user(bot_email, bot_realm)\n        do_deactivate_user(bot_user, acting_user=None)\n\n        # A regular user cannot reactivate a generic bot\n        self.assert_num_bots_equal(0)\n        result = self.client_post(f\"/json/users/{bot_user.id}/reactivate\")\n        self.assert_json_error(result, \"Must be an organization administrator\")\n        self.assert_num_bots_equal(0)\n\n    def test_no_generic_bots_allowed_for_admins(self) -> None:\n        bot_email = \"hambot-bot@zulip.testserver\"\n        bot_realm = get_realm(\"zulip\")\n        bot_realm.bot_creation_policy = Realm.BOT_CREATION_LIMIT_GENERIC_BOTS\n        bot_realm.save(update_fields=[\"bot_creation_policy\"])\n\n        # An administrator can create any type of bot\n        self.login(\"iago\")\n        self.assert_num_bots_equal(0)\n        self.create_bot(bot_type=UserProfile.DEFAULT_BOT)\n        self.assert_num_bots_equal(1)\n        profile = get_user(bot_email, bot_realm)\n        self.assertEqual(profile.bot_type, UserProfile.DEFAULT_BOT)\n\n    def test_no_bots_allowed_for_non_admins(self) -> None:\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n            \"bot_type\": 1,\n        }\n        bot_realm = get_realm(\"zulip\")\n        bot_realm.bot_creation_policy = Realm.BOT_CREATION_ADMINS_ONLY\n        bot_realm.save(update_fields=[\"bot_creation_policy\"])\n\n        # A regular user cannot create a generic bot\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_num_bots_equal(0)\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n        # Also, a regular user cannot create a incoming bot\n        bot_info[\"bot_type\"] = 2\n        self.login(\"hamlet\")\n        self.assert_num_bots_equal(0)\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_num_bots_equal(0)\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n    def test_no_bots_allowed_for_admins(self) -> None:\n        bot_email = \"hambot-bot@zulip.testserver\"\n        bot_realm = get_realm(\"zulip\")\n        bot_realm.bot_creation_policy = Realm.BOT_CREATION_ADMINS_ONLY\n        bot_realm.save(update_fields=[\"bot_creation_policy\"])\n\n        # An administrator can create any type of bot\n        self.login(\"iago\")\n        self.assert_num_bots_equal(0)\n        self.create_bot(bot_type=UserProfile.DEFAULT_BOT)\n        self.assert_num_bots_equal(1)\n        profile = get_user(bot_email, bot_realm)\n        self.assertEqual(profile.bot_type, UserProfile.DEFAULT_BOT)\n\n    def test_patch_bot_full_name(self) -> None:\n        self.login(\"hamlet\")\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n        bot_info = {\n            \"full_name\": \"Fred\",\n        }\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        response_dict = self.assert_json_success(result)\n\n        self.assertEqual(\"Fred\", response_dict[\"full_name\"])\n\n        bot = self.get_bot()\n        self.assertEqual(\"Fred\", bot[\"full_name\"])\n\n    def test_patch_bot_full_name_in_use(self) -> None:\n        self.login(\"hamlet\")\n\n        original_name = \"The Bot of Hamlet\"\n\n        bot_info = {\n            \"full_name\": original_name,\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n\n        bot_email = \"hambot-bot@zulip.testserver\"\n        bot = self.get_bot_user(bot_email)\n        url = f\"/json/bots/{bot.id}\"\n\n        # It doesn't matter whether a name is taken by a human\n        # or a bot, we can't use it.\n        already_taken_name = self.example_user(\"cordelia\").full_name\n\n        bot_info = {\n            \"full_name\": already_taken_name,\n        }\n        result = self.client_patch(url, bot_info)\n        self.assert_json_error(result, \"Name is already in use!\")\n\n        # We can use our own name (with extra whitespace), and the\n        # server should silently do nothing.\n        original_name_with_padding = \"   \" + original_name + \" \"\n        bot_info = {\n            \"full_name\": original_name_with_padding,\n        }\n        result = self.client_patch(url, bot_info)\n        self.assert_json_success(result)\n\n        bot = self.get_bot_user(bot_email)\n        self.assertEqual(bot.full_name, original_name)\n\n        # And let's do a sanity check with an actual name change\n        # after our various attempts that either failed or did\n        # nothing.\n        bot_info = {\n            \"full_name\": \"Hal\",\n        }\n        result = self.client_patch(url, bot_info)\n        self.assert_json_success(result)\n\n        bot = self.get_bot_user(bot_email)\n        self.assertEqual(bot.full_name, \"Hal\")\n\n    def test_patch_bot_full_name_non_bot(self) -> None:\n        self.login(\"iago\")\n        bot_info = {\n            \"full_name\": \"Fred\",\n        }\n        result = self.client_patch(\"/json/bots/{}\".format(self.example_user(\"hamlet\").id), bot_info)\n        self.assert_json_error(result, \"No such bot\")\n\n    def test_patch_bot_owner(self) -> None:\n        self.login(\"hamlet\")\n        othello = self.example_user(\"othello\")\n\n        bot_info: Dict[str, object] = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n        bot_info = {\n            \"bot_owner_id\": othello.id,\n        }\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        response_dict = self.assert_json_success(result)\n\n        # Test bot's owner has been changed successfully.\n        self.assertEqual(response_dict[\"bot_owner\"], othello.email)\n\n        self.login(\"othello\")\n        bot = self.get_bot()\n        self.assertEqual(\"The Bot of Hamlet\", bot[\"full_name\"])\n\n    def test_patch_bot_owner_bad_user_id(self) -> None:\n        self.login(\"hamlet\")\n        self.create_bot()\n        self.assert_num_bots_equal(1)\n\n        email = \"hambot-bot@zulip.testserver\"\n        profile = get_user(\"hambot-bot@zulip.testserver\", get_realm(\"zulip\"))\n\n        bad_bot_owner_id = 999999\n        bot_info = {\n            \"bot_owner_id\": bad_bot_owner_id,\n        }\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        self.assert_json_error(result, \"Failed to change owner, no such user\")\n        profile = get_user(\"hambot-bot@zulip.testserver\", get_realm(\"zulip\"))\n        self.assertEqual(profile.bot_owner, self.example_user(\"hamlet\"))\n\n    def test_patch_bot_owner_deactivated(self) -> None:\n        self.login(\"hamlet\")\n        self.create_bot()\n        self.assert_num_bots_equal(1)\n\n        target_user_profile = self.example_user(\"othello\")\n        do_deactivate_user(target_user_profile, acting_user=None)\n        target_user_profile = self.example_user(\"othello\")\n        self.assertFalse(target_user_profile.is_active)\n        bot_info = {\n            \"bot_owner_id\": self.example_user(\"othello\").id,\n        }\n\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        self.assert_json_error(result, \"Failed to change owner, user is deactivated\")\n        profile = self.get_bot_user(email)\n        self.assertEqual(profile.bot_owner, self.example_user(\"hamlet\"))\n\n    def test_patch_bot_owner_must_be_in_same_realm(self) -> None:\n        self.login(\"hamlet\")\n        self.create_bot()\n        self.assert_num_bots_equal(1)\n\n        bot_info = {\n            \"bot_owner_id\": self.mit_user(\"starnine\").id,\n        }\n\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        self.assert_json_error(result, \"Failed to change owner, no such user\")\n        profile = self.get_bot_user(email)\n        self.assertEqual(profile.bot_owner, self.example_user(\"hamlet\"))\n\n    def test_patch_bot_owner_noop(self) -> None:\n        self.login(\"hamlet\")\n        self.create_bot()\n        self.assert_num_bots_equal(1)\n\n        bot_info = {\n            \"bot_owner_id\": self.example_user(\"hamlet\").id,\n        }\n\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n\n        # Check that we're still the owner\n        self.assert_json_success(result)\n        profile = self.get_bot_user(email)\n        self.assertEqual(profile.bot_owner, self.example_user(\"hamlet\"))\n\n    def test_patch_bot_owner_a_bot(self) -> None:\n        self.login(\"hamlet\")\n        self.create_bot()\n        self.assert_num_bots_equal(1)\n\n        bot_info: Dict[str, object] = {\n            \"full_name\": \"Another Bot of Hamlet\",\n            \"short_name\": \"hamelbot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n\n        bot_info = {\n            \"bot_owner_id\": self.get_bot_user(\"hamelbot-bot@zulip.testserver\").id,\n        }\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        self.assert_json_error(result, \"Failed to change owner, bots can't own other bots\")\n        profile = get_user(email, get_realm(\"zulip\"))\n        self.assertEqual(profile.bot_owner, self.example_user(\"hamlet\"))\n\n    def test_patch_bot_owner_of_bot_with_can_create_users(self) -> None:\n        \"\"\"\n        can_create_users is granted to organizations upon approval, and thus\n        should be thought of as something that only organization owners should\n        have control over.\n        \"\"\"\n        cordelia = self.example_user(\"cordelia\")\n\n        self.login(\"hamlet\")\n        self.create_bot()\n\n        bot_realm = get_realm(\"zulip\")\n        bot_email = \"hambot-bot@zulip.testserver\"\n        bot_user = get_user(bot_email, bot_realm)\n\n        do_change_can_create_users(bot_user, True)\n\n        self.logout()\n        # iago is an ordinary organization administrator, and thus doesn't have\n        # sufficient permissions to change ownership of this bot.\n        self.login(\"iago\")\n        bot_info = {\n            \"bot_owner_id\": cordelia.id,\n        }\n        result = self.client_patch(f\"/json/bots/{bot_user.id}\", bot_info)\n        self.assert_json_error(\n            result,\n            \"Must be an organization owner\",\n        )\n\n        self.logout()\n        # desdemona is the organization owner and should be allowed to change the bot's ownership.\n        self.login(\"desdemona\")\n        result = self.client_patch(f\"/json/bots/{bot_user.id}\", bot_info)\n        self.assert_json_success(result)\n\n        bot_user.refresh_from_db()\n        self.assertEqual(bot_user.bot_owner, cordelia)\n\n    def test_patch_bot_avatar(self) -> None:\n        self.login(\"hamlet\")\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n\n        bot_email = \"hambot-bot@zulip.testserver\"\n        bot_realm = get_realm(\"zulip\")\n        profile = get_user(bot_email, bot_realm)\n        self.assertEqual(profile.avatar_source, UserProfile.AVATAR_FROM_GRAVATAR)\n\n        email = \"hambot-bot@zulip.testserver\"\n        # Try error case first (too many files):\n        with get_test_image_file(\"img.png\") as fp1, get_test_image_file(\"img.gif\") as fp2:\n            result = self.client_patch_multipart(\n                f\"/json/bots/{self.get_bot_user(email).id}\", dict(file1=fp1, file2=fp2)\n            )\n        self.assert_json_error(result, \"You may only upload one file at a time\")\n\n        profile = get_user(bot_email, bot_realm)\n        self.assertEqual(profile.avatar_version, 1)\n\n        # HAPPY PATH\n        with get_test_image_file(\"img.png\") as fp:\n            result = self.client_patch_multipart(\n                f\"/json/bots/{self.get_bot_user(email).id}\", dict(file=fp)\n            )\n            profile = get_user(bot_email, bot_realm)\n            self.assertEqual(profile.avatar_version, 2)\n            # Make sure that avatar image that we've uploaded is same with avatar image in the server\n            self.assertTrue(\n                filecmp.cmp(fp.name, os.path.splitext(avatar_disk_path(profile))[0] + \".original\")\n            )\n        self.assert_json_success(result)\n\n        self.assertEqual(profile.avatar_source, UserProfile.AVATAR_FROM_USER)\n        self.assertTrue(os.path.exists(avatar_disk_path(profile)))\n\n    def test_patch_bot_to_stream(self) -> None:\n        self.login(\"hamlet\")\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n        bot_info = {\n            \"default_sending_stream\": \"Denmark\",\n        }\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        response_dict = self.assert_json_success(result)\n\n        self.assertEqual(\"Denmark\", response_dict[\"default_sending_stream\"])\n\n        bot = self.get_bot()\n        self.assertEqual(\"Denmark\", bot[\"default_sending_stream\"])\n\n    def test_patch_bot_to_stream_not_subscribed(self) -> None:\n        self.login(\"hamlet\")\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n        bot_info = {\n            \"default_sending_stream\": \"Rome\",\n        }\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        response_dict = self.assert_json_success(result)\n\n        self.assertEqual(\"Rome\", response_dict[\"default_sending_stream\"])\n\n        bot = self.get_bot()\n        self.assertEqual(\"Rome\", bot[\"default_sending_stream\"])\n\n    def test_patch_bot_to_stream_none(self) -> None:\n        self.login(\"hamlet\")\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n        bot_info = {\n            \"default_sending_stream\": \"\",\n        }\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        self.assert_json_success(result)\n\n        bot_email = \"hambot-bot@zulip.testserver\"\n        bot_realm = get_realm(\"zulip\")\n        default_sending_stream = get_user(bot_email, bot_realm).default_sending_stream\n        self.assertEqual(None, default_sending_stream)\n\n        bot = self.get_bot()\n        self.assertEqual(None, bot[\"default_sending_stream\"])\n\n    def test_patch_bot_role(self) -> None:\n        self.login(\"desdemona\")\n\n        email = \"default-bot@zulip.com\"\n        user_profile = self.get_bot_user(email)\n\n        do_change_user_role(user_profile, UserProfile.ROLE_MEMBER, acting_user=user_profile)\n\n        req = dict(role=UserProfile.ROLE_GUEST)\n\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", req)\n        self.assert_json_success(result)\n\n        user_profile = self.get_bot_user(email)\n        self.assertEqual(user_profile.role, UserProfile.ROLE_GUEST)\n\n        # Test for not allowing a non-owner user to make assign a bot an owner role\n        desdemona = self.example_user(\"desdemona\")\n        do_change_user_role(desdemona, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n\n        req = dict(role=UserProfile.ROLE_REALM_OWNER)\n\n        result = self.client_patch(f\"/json/users/{user_profile.id}\", req)\n        self.assert_json_error(result, \"Must be an organization owner\")\n\n        result = self.client_patch(f\"/json/bots/{user_profile.id}\", req)\n        self.assert_json_error(result, \"Must be an organization owner\")\n\n        # Test for not allowing a non-administrator user to assign a bot an administrator role\n        shiva = self.example_user(\"shiva\")\n        self.assertEqual(shiva.role, UserProfile.ROLE_MODERATOR)\n        self.login_user(shiva)\n        do_change_bot_owner(user_profile, shiva, acting_user=None)\n\n        req = dict(role=UserProfile.ROLE_REALM_ADMINISTRATOR)\n\n        result = self.client_patch(f\"/json/users/{user_profile.id}\", req)\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n        result = self.client_patch(f\"/json/bots/{user_profile.id}\", req)\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n    def test_patch_bot_to_stream_private_allowed(self) -> None:\n        self.login(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        stream = self.subscribe(user_profile, \"Denmark\")\n        do_change_stream_permission(stream, invite_only=True, acting_user=user_profile)\n\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n\n        bot_info = {\n            \"default_sending_stream\": \"Denmark\",\n        }\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        response_dict = self.assert_json_success(result)\n\n        self.assertEqual(\"Denmark\", response_dict[\"default_sending_stream\"])\n\n        bot = self.get_bot()\n        self.assertEqual(\"Denmark\", bot[\"default_sending_stream\"])\n\n    def test_patch_bot_to_stream_private_denied(self) -> None:\n        self.login(\"hamlet\")\n        realm = self.example_user(\"hamlet\").realm\n        stream = get_stream(\"Denmark\", realm)\n        self.unsubscribe(self.example_user(\"hamlet\"), \"Denmark\")\n        do_change_stream_permission(\n            stream, invite_only=True, acting_user=self.example_user(\"hamlet\")\n        )\n\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n\n        bot_info = {\n            \"default_sending_stream\": \"Denmark\",\n        }\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        self.assert_json_error(result, \"Invalid stream name 'Denmark'\")\n\n    def test_patch_bot_to_stream_not_found(self) -> None:\n        self.login(\"hamlet\")\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n        bot_info = {\n            \"default_sending_stream\": \"missing\",\n        }\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        self.assert_json_error(result, \"Invalid stream name 'missing'\")\n\n    def test_patch_bot_events_register_stream(self) -> None:\n        hamlet = self.example_user(\"hamlet\")\n        self.login_user(hamlet)\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n\n        email = \"hambot-bot@zulip.testserver\"\n        bot_user = self.get_bot_user(email)\n        url = f\"/json/bots/{bot_user.id}\"\n\n        # Successfully give the bot a default stream.\n        stream_name = \"Denmark\"\n        bot_info = dict(default_events_register_stream=stream_name)\n        result = self.client_patch(url, bot_info)\n        response_dict = self.assert_json_success(result)\n\n        self.assertEqual(stream_name, response_dict[\"default_events_register_stream\"])\n\n        bot = self.get_bot()\n        self.assertEqual(stream_name, bot[\"default_events_register_stream\"])\n\n        # Make sure we are locked out of an unsubscribed private stream.\n        # We'll subscribe the bot but not the owner (since the check is\n        # on owner).\n        stream_name = \"private_stream\"\n        self.make_stream(stream_name, hamlet.realm, invite_only=True)\n        self.subscribe(bot_user, stream_name)\n        bot_info = dict(default_events_register_stream=stream_name)\n        result = self.client_patch(url, bot_info)\n        self.assert_json_error_contains(result, \"Invalid stream name\")\n\n        # Subscribing the owner allows us to patch the stream.\n        self.subscribe(hamlet, stream_name)\n        bot_info = dict(default_events_register_stream=stream_name)\n        result = self.client_patch(url, bot_info)\n        self.assert_json_success(result)\n\n        # Make sure the bot cannot create their own default stream.\n        url = f\"/api/v1/bots/{bot_user.id}\"\n        result = self.api_patch(bot_user, url, bot_info)\n        self.assert_json_error_contains(result, \"endpoint does not accept\")\n\n    def test_patch_bot_events_register_stream_allowed(self) -> None:\n        self.login(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        stream = self.subscribe(user_profile, \"Denmark\")\n        do_change_stream_permission(stream, invite_only=True, acting_user=user_profile)\n\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n        bot_info = {\n            \"default_events_register_stream\": \"Denmark\",\n        }\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        response_dict = self.assert_json_success(result)\n\n        self.assertEqual(\"Denmark\", response_dict[\"default_events_register_stream\"])\n\n        bot = self.get_bot()\n        self.assertEqual(\"Denmark\", bot[\"default_events_register_stream\"])\n\n    def test_patch_bot_events_register_stream_denied(self) -> None:\n        self.login(\"hamlet\")\n        realm = self.example_user(\"hamlet\").realm\n        stream = get_stream(\"Denmark\", realm)\n        self.unsubscribe(self.example_user(\"hamlet\"), \"Denmark\")\n        do_change_stream_permission(\n            stream, invite_only=True, acting_user=self.example_user(\"hamlet\")\n        )\n\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n        bot_info = {\n            \"default_events_register_stream\": \"Denmark\",\n        }\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        self.assert_json_error(result, \"Invalid stream name 'Denmark'\")\n\n    def test_patch_bot_events_register_stream_none(self) -> None:\n        self.login(\"hamlet\")\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n        bot_info = {\n            \"default_events_register_stream\": \"\",\n        }\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        self.assert_json_success(result)\n\n        bot_email = \"hambot-bot@zulip.testserver\"\n        bot_realm = get_realm(\"zulip\")\n        default_events_register_stream = get_user(\n            bot_email, bot_realm\n        ).default_events_register_stream\n        self.assertEqual(None, default_events_register_stream)\n\n        bot = self.get_bot()\n        self.assertEqual(None, bot[\"default_events_register_stream\"])\n\n    def test_patch_bot_events_register_stream_not_found(self) -> None:\n        self.login(\"hamlet\")\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n        bot_info = {\n            \"default_events_register_stream\": \"missing\",\n        }\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        self.assert_json_error(result, \"Invalid stream name 'missing'\")\n\n    def test_patch_bot_default_all_public_streams_true(self) -> None:\n        self.login(\"hamlet\")\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n        bot_info = {\n            \"default_all_public_streams\": orjson.dumps(True).decode(),\n        }\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        response_dict = self.assert_json_success(result)\n\n        self.assertEqual(response_dict[\"default_all_public_streams\"], True)\n\n        bot = self.get_bot()\n        self.assertEqual(bot[\"default_all_public_streams\"], True)\n\n    def test_patch_bot_default_all_public_streams_false(self) -> None:\n        self.login(\"hamlet\")\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n        bot_info = {\n            \"default_all_public_streams\": orjson.dumps(False).decode(),\n        }\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        response_dict = self.assert_json_success(result)\n\n        self.assertEqual(response_dict[\"default_all_public_streams\"], False)\n\n        bot = self.get_bot()\n        self.assertEqual(bot[\"default_all_public_streams\"], False)\n\n    def test_patch_bot_via_post(self) -> None:\n        self.login(\"hamlet\")\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n        bot_info = {\n            \"full_name\": \"Fred\",\n            \"method\": \"PATCH\",\n        }\n        email = \"hambot-bot@zulip.testserver\"\n        # Important: We intentionally use the wrong method, post, here.\n        result = self.client_post(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        response_dict = self.assert_json_success(result)\n\n        self.assertEqual(\"Fred\", response_dict[\"full_name\"])\n\n        bot = self.get_bot()\n        self.assertEqual(\"Fred\", bot[\"full_name\"])\n\n    def test_patch_bogus_bot(self) -> None:\n        \"\"\"Deleting a bogus bot will succeed silently.\"\"\"\n        self.login(\"hamlet\")\n        self.create_bot()\n        bot_info = {\n            \"full_name\": \"Fred\",\n        }\n        invalid_user_id = 1000\n        result = self.client_patch(f\"/json/bots/{invalid_user_id}\", bot_info)\n        self.assert_json_error(result, \"No such bot\")\n        self.assert_num_bots_equal(1)\n\n    def test_patch_outgoing_webhook_bot(self) -> None:\n        self.login(\"hamlet\")\n        bot_info = {\n            \"full_name\": \"The Bot of Hamlet\",\n            \"short_name\": \"hambot\",\n            \"bot_type\": UserProfile.OUTGOING_WEBHOOK_BOT,\n            \"payload_url\": orjson.dumps(\"http://foo.bar.com\").decode(),\n            \"interface_type\": Service.GENERIC,\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n        bot_info = {\n            \"service_payload_url\": orjson.dumps(\"http://foo.bar2.com\").decode(),\n            \"service_interface\": Service.SLACK,\n        }\n        email = \"hambot-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        self.assert_json_success(result)\n\n        service_interface = orjson.loads(result.content)[\"service_interface\"]\n        self.assertEqual(service_interface, Service.SLACK)\n\n        service_payload_url = orjson.loads(result.content)[\"service_payload_url\"]\n        self.assertEqual(service_payload_url, \"http://foo.bar2.com\")\n\n    @patch(\"zulip_bots.bots.giphy.giphy.GiphyHandler.validate_config\")\n    def test_patch_bot_config_data(self, mock_validate_config: MagicMock) -> None:\n        self.create_test_bot(\n            \"test\",\n            self.example_user(\"hamlet\"),\n            full_name=\"Bot with config data\",\n            bot_type=UserProfile.EMBEDDED_BOT,\n            service_name=\"giphy\",\n            config_data=orjson.dumps({\"key\": \"12345678\"}).decode(),\n        )\n        bot_info = {\"config_data\": orjson.dumps({\"key\": \"87654321\"}).decode()}\n        email = \"test-bot@zulip.testserver\"\n        result = self.client_patch(f\"/json/bots/{self.get_bot_user(email).id}\", bot_info)\n        self.assert_json_success(result)\n        config_data = orjson.loads(result.content)[\"config_data\"]\n        self.assertEqual(config_data, orjson.loads(bot_info[\"config_data\"]))\n\n    def test_outgoing_webhook_invalid_interface(self) -> None:\n        self.login(\"hamlet\")\n        bot_info = {\n            \"full_name\": \"Outgoing Webhook test bot\",\n            \"short_name\": \"outgoingservicebot\",\n            \"bot_type\": UserProfile.OUTGOING_WEBHOOK_BOT,\n            \"payload_url\": orjson.dumps(\"http://127.0.0.1:5002\").decode(),\n            \"interface_type\": -1,\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_error(result, \"Invalid interface type\")\n\n        bot_info[\"interface_type\"] = Service.GENERIC\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n\n    def test_create_outgoing_webhook_bot(self, **extras: Any) -> None:\n        self.login(\"hamlet\")\n        bot_info = {\n            \"full_name\": \"Outgoing Webhook test bot\",\n            \"short_name\": \"outgoingservicebot\",\n            \"bot_type\": UserProfile.OUTGOING_WEBHOOK_BOT,\n            \"payload_url\": orjson.dumps(\"http://127.0.0.1:5002\").decode(),\n        }\n        bot_info.update(extras)\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n\n        bot_email = \"outgoingservicebot-bot@zulip.testserver\"\n        bot_realm = get_realm(\"zulip\")\n        bot = get_user(bot_email, bot_realm)\n        [service] = get_bot_services(bot.id)\n\n        self.assertEqual(service.name, \"outgoingservicebot\")\n        self.assertEqual(service.base_url, \"http://127.0.0.1:5002\")\n        self.assertEqual(service.user_profile, bot)\n\n        # invalid URL test case.\n        bot_info[\"payload_url\"] = orjson.dumps(\"http://127.0.0.:5002\").decode()\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_error(result, \"payload_url is not a URL\")\n\n    def test_get_bot_handler(self) -> None:\n        # Test for valid service.\n        test_service_name = \"converter\"\n        test_bot_handler = get_bot_handler(test_service_name)\n        self.assertEqual(\n            str(type(test_bot_handler)),\n            \"<class 'zulip_bots.bots.converter.converter.ConverterHandler'>\",\n        )\n\n        # Test for invalid service.\n        test_service_name = \"incorrect_bot_service_foo\"\n        test_bot_handler = get_bot_handler(test_service_name)\n        self.assertEqual(test_bot_handler, None)\n\n    def test_if_each_embedded_bot_service_exists(self) -> None:\n        for embedded_bot in EMBEDDED_BOTS:\n            self.assertIsNotNone(get_bot_handler(embedded_bot.name))\n\n    def test_outgoing_webhook_interface_type(self) -> None:\n        self.login(\"hamlet\")\n        bot_info = {\n            \"full_name\": \"Outgoing Webhook test bot\",\n            \"short_name\": \"outgoingservicebot\",\n            \"bot_type\": UserProfile.OUTGOING_WEBHOOK_BOT,\n            \"payload_url\": orjson.dumps(\"http://127.0.0.1:5002\").decode(),\n            \"interface_type\": -1,\n        }\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_error(result, \"Invalid interface type\")\n\n        bot_info[\"interface_type\"] = Service.GENERIC\n        result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_success(result)\n\n    def test_create_embedded_bot_with_disabled_embedded_bots(self, **extras: Any) -> None:\n        with self.settings(EMBEDDED_BOTS_ENABLED=False):\n            self.fail_to_create_test_bot(\n                short_name=\"embeddedservicebot\",\n                user_profile=self.example_user(\"hamlet\"),\n                bot_type=UserProfile.EMBEDDED_BOT,\n                service_name=\"followup\",\n                config_data=orjson.dumps({\"key\": \"value\"}).decode(),\n                assert_json_error_msg=\"Embedded bots are not enabled.\",\n                **extras,\n            )\n\n    def test_create_embedded_bot(self, **extras: Any) -> None:\n        bot_config_info = {\"key\": \"value\"}\n        self.create_test_bot(\n            short_name=\"embeddedservicebot\",\n            user_profile=self.example_user(\"hamlet\"),\n            bot_type=UserProfile.EMBEDDED_BOT,\n            service_name=\"followup\",\n            config_data=orjson.dumps(bot_config_info).decode(),\n            **extras,\n        )\n        bot_email = \"embeddedservicebot-bot@zulip.testserver\"\n        bot_realm = get_realm(\"zulip\")\n        bot = get_user(bot_email, bot_realm)\n        [service] = get_bot_services(bot.id)\n        bot_config = get_bot_config(bot)\n        self.assertEqual(bot_config, bot_config_info)\n        self.assertEqual(service.name, \"followup\")\n        self.assertEqual(service.user_profile, bot)\n\n    def test_create_embedded_bot_with_incorrect_service_name(self, **extras: Any) -> None:\n        self.fail_to_create_test_bot(\n            short_name=\"embeddedservicebot\",\n            user_profile=self.example_user(\"hamlet\"),\n            bot_type=UserProfile.EMBEDDED_BOT,\n            service_name=\"not_existing_service\",\n            assert_json_error_msg=\"Invalid embedded bot name.\",\n            **extras,\n        )\n\n    def test_create_embedded_bot_with_invalid_config_value(self, **extras: Any) -> None:\n        self.fail_to_create_test_bot(\n            short_name=\"embeddedservicebot\",\n            user_profile=self.example_user(\"hamlet\"),\n            service_name=\"followup\",\n            config_data=orjson.dumps({\"invalid\": [\"config\", \"value\"]}).decode(),\n            assert_json_error_msg=\"config_data contains a value that is not a string\",\n            **extras,\n        )\n\n        # Test to create embedded bot with an incorrect config value\n        incorrect_bot_config_info = {\"key\": \"incorrect key\"}\n        bot_info = {\n            \"full_name\": \"Embedded test bot\",\n            \"short_name\": \"embeddedservicebot3\",\n            \"bot_type\": UserProfile.EMBEDDED_BOT,\n            \"service_name\": \"giphy\",\n            \"config_data\": orjson.dumps(incorrect_bot_config_info).decode(),\n        }\n        bot_info.update(extras)\n        with patch(\n            \"zulip_bots.bots.giphy.giphy.GiphyHandler.validate_config\",\n            side_effect=ConfigValidationError,\n        ):\n            result = self.client_post(\"/json/bots\", bot_info)\n        self.assert_json_error(result, \"Invalid configuration data!\")\n\n    def test_is_cross_realm_bot_email(self) -> None:\n        self.assertTrue(is_cross_realm_bot_email(\"notification-bot@zulip.com\"))\n        self.assertTrue(is_cross_realm_bot_email(\"notification-BOT@zulip.com\"))\n        self.assertFalse(is_cross_realm_bot_email(\"random-bot@zulip.com\"))\n\n        with self.settings(CROSS_REALM_BOT_EMAILS={\"random-bot@zulip.com\"}):\n            self.assertTrue(is_cross_realm_bot_email(\"random-bot@zulip.com\"))\n            self.assertFalse(is_cross_realm_bot_email(\"notification-bot@zulip.com\"))\n\n    @patch(\"zerver.lib.integrations.WEBHOOK_INTEGRATIONS\", stripe_sample_config_options)\n    def test_create_incoming_webhook_bot_with_service_name_and_with_keys(self) -> None:\n        self.login(\"hamlet\")\n        bot_metadata = {\n            \"full_name\": \"My Stripe Bot\",\n            \"short_name\": \"my-stripe\",\n            \"bot_type\": UserProfile.INCOMING_WEBHOOK_BOT,\n            \"service_name\": \"stripe\",\n            \"config_data\": orjson.dumps({\"stripe_api_key\": \"sample-api-key\"}).decode(),\n        }\n        self.create_bot(**bot_metadata)\n        new_bot = UserProfile.objects.get(full_name=\"My Stripe Bot\")\n        config_data = get_bot_config(new_bot)\n        self.assertEqual(\n            config_data, {\"integration_id\": \"stripe\", \"stripe_api_key\": \"sample-api-key\"}\n        )\n\n    @patch(\"zerver.lib.integrations.WEBHOOK_INTEGRATIONS\", stripe_sample_config_options)\n    def test_create_incoming_webhook_bot_with_service_name_incorrect_keys(self) -> None:\n        self.login(\"hamlet\")\n        bot_metadata = {\n            \"full_name\": \"My Stripe Bot\",\n            \"short_name\": \"my-stripe\",\n            \"bot_type\": UserProfile.INCOMING_WEBHOOK_BOT,\n            \"service_name\": \"stripe\",\n            \"config_data\": orjson.dumps({\"stripe_api_key\": \"_invalid_key\"}).decode(),\n        }\n        response = self.client_post(\"/json/bots\", bot_metadata)\n        self.assertEqual(response.status_code, 400)\n        expected_error_message = 'Invalid stripe_api_key value _invalid_key (stripe_api_key starts with a \"_\" and is hence invalid.)'\n        self.assertEqual(orjson.loads(response.content)[\"msg\"], expected_error_message)\n        with self.assertRaises(UserProfile.DoesNotExist):\n            UserProfile.objects.get(full_name=\"My Stripe Bot\")\n\n    @patch(\"zerver.lib.integrations.WEBHOOK_INTEGRATIONS\", stripe_sample_config_options)\n    def test_create_incoming_webhook_bot_with_service_name_without_keys(self) -> None:\n        self.login(\"hamlet\")\n        bot_metadata = {\n            \"full_name\": \"My Stripe Bot\",\n            \"short_name\": \"my-stripe\",\n            \"bot_type\": UserProfile.INCOMING_WEBHOOK_BOT,\n            \"service_name\": \"stripe\",\n        }\n        response = self.client_post(\"/json/bots\", bot_metadata)\n        self.assertEqual(response.status_code, 400)\n        expected_error_message = \"Missing configuration parameters: {'stripe_api_key'}\"\n        self.assertEqual(orjson.loads(response.content)[\"msg\"], expected_error_message)\n        with self.assertRaises(UserProfile.DoesNotExist):\n            UserProfile.objects.get(full_name=\"My Stripe Bot\")\n\n    @patch(\"zerver.lib.integrations.WEBHOOK_INTEGRATIONS\", stripe_sample_config_options)\n    def test_create_incoming_webhook_bot_without_service_name(self) -> None:\n        self.login(\"hamlet\")\n        bot_metadata = {\n            \"full_name\": \"My Stripe Bot\",\n            \"short_name\": \"my-stripe\",\n            \"bot_type\": UserProfile.INCOMING_WEBHOOK_BOT,\n        }\n        self.create_bot(**bot_metadata)\n        new_bot = UserProfile.objects.get(full_name=\"My Stripe Bot\")\n        with self.assertRaises(ConfigError):\n            get_bot_config(new_bot)\n\n    @patch(\"zerver.lib.integrations.WEBHOOK_INTEGRATIONS\", stripe_sample_config_options)\n    def test_create_incoming_webhook_bot_with_incorrect_service_name(self) -> None:\n        self.login(\"hamlet\")\n        bot_metadata = {\n            \"full_name\": \"My Stripe Bot\",\n            \"short_name\": \"my-stripe\",\n            \"bot_type\": UserProfile.INCOMING_WEBHOOK_BOT,\n            \"service_name\": \"stripes\",\n        }\n        response = self.client_post(\"/json/bots\", bot_metadata)\n        self.assertEqual(response.status_code, 400)\n        expected_error_message = \"Invalid integration 'stripes'.\"\n        self.assertEqual(orjson.loads(response.content)[\"msg\"], expected_error_message)\n        with self.assertRaises(UserProfile.DoesNotExist):\n            UserProfile.objects.get(full_name=\"My Stripe Bot\")\n", "from typing import Any, Dict, List, Optional, Union\n\nfrom django.conf import settings\nfrom django.contrib.auth.models import AnonymousUser\nfrom django.core.files.uploadedfile import UploadedFile\nfrom django.http import HttpRequest, HttpResponse\nfrom django.shortcuts import redirect\nfrom django.utils.translation import gettext as _\n\nfrom zerver.actions.bots import (\n    do_change_bot_owner,\n    do_change_default_all_public_streams,\n    do_change_default_events_register_stream,\n    do_change_default_sending_stream,\n)\nfrom zerver.actions.create_user import do_create_user, do_reactivate_user, notify_created_bot\nfrom zerver.actions.custom_profile_fields import (\n    check_remove_custom_profile_field_value,\n    do_update_user_custom_profile_data_if_changed,\n)\nfrom zerver.actions.user_settings import (\n    check_change_bot_full_name,\n    check_change_full_name,\n    do_change_avatar_fields,\n    do_regenerate_api_key,\n)\nfrom zerver.actions.users import (\n    do_change_user_role,\n    do_deactivate_user,\n    do_update_bot_config_data,\n    do_update_outgoing_webhook_service,\n)\nfrom zerver.context_processors import get_valid_realm_from_request\nfrom zerver.decorator import require_member_or_admin, require_realm_admin\nfrom zerver.forms import PASSWORD_TOO_WEAK_ERROR, CreateUserForm\nfrom zerver.lib.avatar import avatar_url, get_gravatar_url\nfrom zerver.lib.bot_config import set_bot_config\nfrom zerver.lib.email_validation import email_allowed_for_realm\nfrom zerver.lib.exceptions import (\n    CannotDeactivateLastUserError,\n    JsonableError,\n    MissingAuthenticationError,\n    OrganizationAdministratorRequired,\n    OrganizationOwnerRequired,\n    RateLimited,\n)\nfrom zerver.lib.integrations import EMBEDDED_BOTS\nfrom zerver.lib.rate_limiter import rate_limit_spectator_attachment_access_by_file\nfrom zerver.lib.request import REQ, has_request_variables\nfrom zerver.lib.response import json_response_from_error, json_success\nfrom zerver.lib.streams import access_stream_by_id, access_stream_by_name, subscribed_to_stream\nfrom zerver.lib.types import ProfileDataElementUpdateDict, ProfileDataElementValue, Validator\nfrom zerver.lib.upload import upload_avatar_image\nfrom zerver.lib.url_encoding import append_url_query_string\nfrom zerver.lib.users import (\n    access_bot_by_id,\n    access_user_by_email,\n    access_user_by_id,\n    add_service,\n    check_bot_creation_policy,\n    check_bot_name_available,\n    check_full_name,\n    check_short_name,\n    check_valid_bot_config,\n    check_valid_bot_type,\n    check_valid_interface_type,\n    get_api_key,\n    get_raw_user_data,\n    validate_user_custom_profile_data,\n)\nfrom zerver.lib.utils import generate_api_key\nfrom zerver.lib.validator import (\n    check_bool,\n    check_dict,\n    check_dict_only,\n    check_int,\n    check_int_in,\n    check_list,\n    check_none_or,\n    check_string,\n    check_union,\n    check_url,\n)\nfrom zerver.models import (\n    DisposableEmailError,\n    DomainNotAllowedForRealmError,\n    EmailContainsPlusError,\n    InvalidFakeEmailDomain,\n    Message,\n    Realm,\n    Service,\n    Stream,\n    UserProfile,\n    get_user_by_delivery_email,\n    get_user_by_id_in_realm_including_cross_realm,\n    get_user_including_cross_realm,\n    get_user_profile_by_id_in_realm,\n)\nfrom zproject.backends import check_password_strength\n\n\ndef check_last_owner(user_profile: UserProfile) -> bool:\n    owners = set(user_profile.realm.get_human_owner_users())\n    return user_profile.is_realm_owner and not user_profile.is_bot and len(owners) == 1\n\n\ndef deactivate_user_backend(\n    request: HttpRequest, user_profile: UserProfile, user_id: int\n) -> HttpResponse:\n    target = access_user_by_id(user_profile, user_id, for_admin=True)\n    if target.is_realm_owner and not user_profile.is_realm_owner:\n        raise OrganizationOwnerRequired()\n    if check_last_owner(target):\n        raise JsonableError(_(\"Cannot deactivate the only organization owner\"))\n    return _deactivate_user_profile_backend(request, user_profile, target)\n\n\ndef deactivate_user_own_backend(request: HttpRequest, user_profile: UserProfile) -> HttpResponse:\n    if UserProfile.objects.filter(realm=user_profile.realm, is_active=True).count() == 1:\n        raise CannotDeactivateLastUserError(is_last_owner=False)\n    if user_profile.is_realm_owner and check_last_owner(user_profile):\n        raise CannotDeactivateLastUserError(is_last_owner=True)\n\n    do_deactivate_user(user_profile, acting_user=user_profile)\n    return json_success(request)\n\n\ndef deactivate_bot_backend(\n    request: HttpRequest, user_profile: UserProfile, bot_id: int\n) -> HttpResponse:\n    target = access_bot_by_id(user_profile, bot_id)\n    return _deactivate_user_profile_backend(request, user_profile, target)\n\n\ndef _deactivate_user_profile_backend(\n    request: HttpRequest, user_profile: UserProfile, target: UserProfile\n) -> HttpResponse:\n    do_deactivate_user(target, acting_user=user_profile)\n    return json_success(request)\n\n\ndef reactivate_user_backend(\n    request: HttpRequest, user_profile: UserProfile, user_id: int\n) -> HttpResponse:\n    target = access_user_by_id(\n        user_profile, user_id, allow_deactivated=True, allow_bots=True, for_admin=True\n    )\n    if target.is_bot:\n        assert target.bot_type is not None\n        check_bot_creation_policy(user_profile, target.bot_type)\n    do_reactivate_user(target, acting_user=user_profile)\n    return json_success(request)\n\n\ncheck_profile_data: Validator[\n    List[Dict[str, Optional[Union[int, ProfileDataElementValue]]]]\n] = check_list(\n    check_dict_only(\n        [\n            (\"id\", check_int),\n            (\n                \"value\",\n                check_none_or(\n                    check_union([check_string, check_list(check_int)]),\n                ),\n            ),\n        ]\n    ),\n)\n\n\n@has_request_variables\ndef update_user_backend(\n    request: HttpRequest,\n    user_profile: UserProfile,\n    user_id: int,\n    full_name: Optional[str] = REQ(default=None),\n    role: Optional[int] = REQ(\n        default=None,\n        json_validator=check_int_in(\n            UserProfile.ROLE_TYPES,\n        ),\n    ),\n    profile_data: Optional[List[Dict[str, Optional[Union[int, ProfileDataElementValue]]]]] = REQ(\n        default=None,\n        json_validator=check_profile_data,\n    ),\n) -> HttpResponse:\n    target = access_user_by_id(\n        user_profile, user_id, allow_deactivated=True, allow_bots=True, for_admin=True\n    )\n\n    if role is not None and target.role != role:\n        # Require that the current user has permissions to\n        # grant/remove the role in question.\n        #\n        # Logic replicated in patch_bot_backend.\n        if UserProfile.ROLE_REALM_OWNER in [role, target.role] and not user_profile.is_realm_owner:\n            raise OrganizationOwnerRequired()\n        elif not user_profile.is_realm_admin:\n            raise OrganizationAdministratorRequired()\n\n        if target.role == UserProfile.ROLE_REALM_OWNER and check_last_owner(target):\n            raise JsonableError(\n                _(\"The owner permission cannot be removed from the only organization owner.\")\n            )\n        do_change_user_role(target, role, acting_user=user_profile)\n\n    if full_name is not None and target.full_name != full_name and full_name.strip() != \"\":\n        # We don't respect `name_changes_disabled` here because the request\n        # is on behalf of the administrator.\n        check_change_full_name(target, full_name, user_profile)\n\n    if profile_data is not None:\n        clean_profile_data: List[ProfileDataElementUpdateDict] = []\n        for entry in profile_data:\n            assert isinstance(entry[\"id\"], int)\n            assert not isinstance(entry[\"value\"], int)\n            if entry[\"value\"] is None or not entry[\"value\"]:\n                field_id = entry[\"id\"]\n                check_remove_custom_profile_field_value(target, field_id)\n            else:\n                clean_profile_data.append(\n                    {\n                        \"id\": entry[\"id\"],\n                        \"value\": entry[\"value\"],\n                    }\n                )\n        validate_user_custom_profile_data(target.realm.id, clean_profile_data)\n        do_update_user_custom_profile_data_if_changed(target, clean_profile_data)\n\n    return json_success(request)\n\n\ndef avatar(\n    request: HttpRequest,\n    maybe_user_profile: Union[UserProfile, AnonymousUser],\n    email_or_id: str,\n    medium: bool = False,\n) -> HttpResponse:\n    \"\"\"Accepts an email address or user ID and returns the avatar\"\"\"\n    is_email = False\n    try:\n        int(email_or_id)\n    except ValueError:\n        is_email = True\n\n    if not maybe_user_profile.is_authenticated:\n        # Allow anonymous access to avatars only if spectators are\n        # enabled in the organization.\n        realm = get_valid_realm_from_request(request)\n        if not realm.allow_web_public_streams_access():\n            raise MissingAuthenticationError()\n\n        # We only allow the ID format for accessing a user's avatar\n        # for spectators. This is mainly for defense in depth, since\n        # email_address_visibility should mean spectators only\n        # interact with fake email addresses anyway.\n        if is_email:\n            raise MissingAuthenticationError()\n\n        if settings.RATE_LIMITING:\n            try:\n                unique_avatar_key = f\"{realm.id}/{email_or_id}/{medium}\"\n                rate_limit_spectator_attachment_access_by_file(unique_avatar_key)\n            except RateLimited:\n                return json_response_from_error(\n                    RateLimited(_(\"Too many attempts, please try after some time.\"))\n                )\n    else:\n        realm = maybe_user_profile.realm\n\n    try:\n        if is_email:\n            avatar_user_profile = get_user_including_cross_realm(email_or_id, realm)\n        else:\n            avatar_user_profile = get_user_by_id_in_realm_including_cross_realm(\n                int(email_or_id), realm\n            )\n        # If there is a valid user account passed in, use its avatar\n        url = avatar_url(avatar_user_profile, medium=medium)\n    except UserProfile.DoesNotExist:\n        # If there is no such user, treat it as a new gravatar\n        email = email_or_id\n        avatar_version = 1\n        url = get_gravatar_url(email, avatar_version, medium)\n\n    # We can rely on the URL already having query parameters. Because\n    # our templates depend on being able to use the ampersand to\n    # add query parameters to our url, get_avatar_url does '?x=x'\n    # hacks to prevent us from having to jump through decode/encode hoops.\n    assert url is not None\n    url = append_url_query_string(url, request.META[\"QUERY_STRING\"])\n    return redirect(url)\n\n\ndef get_stream_name(stream: Optional[Stream]) -> Optional[str]:\n    if stream:\n        return stream.name\n    return None\n\n\n@require_member_or_admin\n@has_request_variables\ndef patch_bot_backend(\n    request: HttpRequest,\n    user_profile: UserProfile,\n    bot_id: int,\n    full_name: Optional[str] = REQ(default=None),\n    role: Optional[int] = REQ(\n        default=None,\n        json_validator=check_int_in(\n            UserProfile.ROLE_TYPES,\n        ),\n    ),\n    bot_owner_id: Optional[int] = REQ(json_validator=check_int, default=None),\n    config_data: Optional[Dict[str, str]] = REQ(\n        default=None, json_validator=check_dict(value_validator=check_string)\n    ),\n    service_payload_url: Optional[str] = REQ(json_validator=check_url, default=None),\n    service_interface: int = REQ(json_validator=check_int, default=1),\n    default_sending_stream: Optional[str] = REQ(default=None),\n    default_events_register_stream: Optional[str] = REQ(default=None),\n    default_all_public_streams: Optional[bool] = REQ(default=None, json_validator=check_bool),\n) -> HttpResponse:\n    bot = access_bot_by_id(user_profile, bot_id)\n\n    if full_name is not None:\n        check_change_bot_full_name(bot, full_name, user_profile)\n\n    if role is not None and bot.role != role:\n        # Logic duplicated from update_user_backend.\n        if UserProfile.ROLE_REALM_OWNER in [role, bot.role] and not user_profile.is_realm_owner:\n            raise OrganizationOwnerRequired()\n        elif not user_profile.is_realm_admin:\n            raise OrganizationAdministratorRequired()\n\n        do_change_user_role(bot, role, acting_user=user_profile)\n\n    if bot_owner_id is not None:\n        try:\n            owner = get_user_profile_by_id_in_realm(bot_owner_id, user_profile.realm)\n        except UserProfile.DoesNotExist:\n            raise JsonableError(_(\"Failed to change owner, no such user\"))\n        if not owner.is_active:\n            raise JsonableError(_(\"Failed to change owner, user is deactivated\"))\n        if owner.is_bot:\n            raise JsonableError(_(\"Failed to change owner, bots can't own other bots\"))\n\n        previous_owner = bot.bot_owner\n        if previous_owner != owner:\n            do_change_bot_owner(bot, owner, user_profile)\n\n    if default_sending_stream is not None:\n        if default_sending_stream == \"\":\n            stream: Optional[Stream] = None\n        else:\n            (stream, sub) = access_stream_by_name(user_profile, default_sending_stream)\n        do_change_default_sending_stream(bot, stream, acting_user=user_profile)\n    if default_events_register_stream is not None:\n        if default_events_register_stream == \"\":\n            stream = None\n        else:\n            (stream, sub) = access_stream_by_name(user_profile, default_events_register_stream)\n        do_change_default_events_register_stream(bot, stream, acting_user=user_profile)\n    if default_all_public_streams is not None:\n        do_change_default_all_public_streams(\n            bot, default_all_public_streams, acting_user=user_profile\n        )\n\n    if service_payload_url is not None:\n        check_valid_interface_type(service_interface)\n        assert service_interface is not None\n        do_update_outgoing_webhook_service(bot, service_interface, service_payload_url)\n\n    if config_data is not None:\n        do_update_bot_config_data(bot, config_data)\n\n    if len(request.FILES) == 0:\n        pass\n    elif len(request.FILES) == 1:\n        user_file = list(request.FILES.values())[0]\n        assert isinstance(user_file, UploadedFile)\n        assert user_file.size is not None\n        upload_avatar_image(user_file, user_profile, bot)\n        avatar_source = UserProfile.AVATAR_FROM_USER\n        do_change_avatar_fields(bot, avatar_source, acting_user=user_profile)\n    else:\n        raise JsonableError(_(\"You may only upload one file at a time\"))\n\n    json_result = dict(\n        full_name=bot.full_name,\n        avatar_url=avatar_url(bot),\n        service_interface=service_interface,\n        service_payload_url=service_payload_url,\n        config_data=config_data,\n        default_sending_stream=get_stream_name(bot.default_sending_stream),\n        default_events_register_stream=get_stream_name(bot.default_events_register_stream),\n        default_all_public_streams=bot.default_all_public_streams,\n    )\n\n    # Don't include the bot owner in case it is not set.\n    # Default bots have no owner.\n    if bot.bot_owner is not None:\n        json_result[\"bot_owner\"] = bot.bot_owner.email\n\n    return json_success(request, data=json_result)\n\n\n@require_member_or_admin\n@has_request_variables\ndef regenerate_bot_api_key(\n    request: HttpRequest, user_profile: UserProfile, bot_id: int\n) -> HttpResponse:\n    bot = access_bot_by_id(user_profile, bot_id)\n\n    new_api_key = do_regenerate_api_key(bot, user_profile)\n    json_result = dict(\n        api_key=new_api_key,\n    )\n    return json_success(request, data=json_result)\n\n\n@require_member_or_admin\n@has_request_variables\ndef add_bot_backend(\n    request: HttpRequest,\n    user_profile: UserProfile,\n    full_name_raw: str = REQ(\"full_name\"),\n    short_name_raw: str = REQ(\"short_name\"),\n    bot_type: int = REQ(json_validator=check_int, default=UserProfile.DEFAULT_BOT),\n    payload_url: str = REQ(json_validator=check_url, default=\"\"),\n    service_name: Optional[str] = REQ(default=None),\n    config_data: Dict[str, str] = REQ(\n        default={}, json_validator=check_dict(value_validator=check_string)\n    ),\n    interface_type: int = REQ(json_validator=check_int, default=Service.GENERIC),\n    default_sending_stream_name: Optional[str] = REQ(\"default_sending_stream\", default=None),\n    default_events_register_stream_name: Optional[str] = REQ(\n        \"default_events_register_stream\", default=None\n    ),\n    default_all_public_streams: Optional[bool] = REQ(json_validator=check_bool, default=None),\n) -> HttpResponse:\n    short_name = check_short_name(short_name_raw)\n    if bot_type != UserProfile.INCOMING_WEBHOOK_BOT:\n        service_name = service_name or short_name\n    short_name += \"-bot\"\n    full_name = check_full_name(full_name_raw)\n    try:\n        email = f\"{short_name}@{user_profile.realm.get_bot_domain()}\"\n    except InvalidFakeEmailDomain:\n        raise JsonableError(\n            _(\n                \"Can't create bots until FAKE_EMAIL_DOMAIN is correctly configured.\\n\"\n                \"Please contact your server administrator.\"\n            )\n        )\n    form = CreateUserForm({\"full_name\": full_name, \"email\": email})\n\n    if bot_type == UserProfile.EMBEDDED_BOT:\n        if not settings.EMBEDDED_BOTS_ENABLED:\n            raise JsonableError(_(\"Embedded bots are not enabled.\"))\n        if service_name not in [bot.name for bot in EMBEDDED_BOTS]:\n            raise JsonableError(_(\"Invalid embedded bot name.\"))\n\n    if not form.is_valid():\n        # We validate client-side as well\n        raise JsonableError(_(\"Bad name or username\"))\n    try:\n        get_user_by_delivery_email(email, user_profile.realm)\n        raise JsonableError(_(\"Username already in use\"))\n    except UserProfile.DoesNotExist:\n        pass\n\n    check_bot_name_available(\n        realm_id=user_profile.realm_id,\n        full_name=full_name,\n    )\n\n    check_bot_creation_policy(user_profile, bot_type)\n    check_valid_bot_type(user_profile, bot_type)\n    check_valid_interface_type(interface_type)\n\n    if len(request.FILES) == 0:\n        avatar_source = UserProfile.AVATAR_FROM_GRAVATAR\n    elif len(request.FILES) != 1:\n        raise JsonableError(_(\"You may only upload one file at a time\"))\n    else:\n        avatar_source = UserProfile.AVATAR_FROM_USER\n\n    default_sending_stream = None\n    if default_sending_stream_name is not None:\n        (default_sending_stream, ignored_sub) = access_stream_by_name(\n            user_profile, default_sending_stream_name\n        )\n\n    default_events_register_stream = None\n    if default_events_register_stream_name is not None:\n        (default_events_register_stream, ignored_sub) = access_stream_by_name(\n            user_profile, default_events_register_stream_name\n        )\n\n    if bot_type in (UserProfile.INCOMING_WEBHOOK_BOT, UserProfile.EMBEDDED_BOT) and service_name:\n        check_valid_bot_config(bot_type, service_name, config_data)\n\n    bot_profile = do_create_user(\n        email=email,\n        password=None,\n        realm=user_profile.realm,\n        full_name=full_name,\n        bot_type=bot_type,\n        bot_owner=user_profile,\n        avatar_source=avatar_source,\n        default_sending_stream=default_sending_stream,\n        default_events_register_stream=default_events_register_stream,\n        default_all_public_streams=default_all_public_streams,\n        acting_user=user_profile,\n    )\n    if len(request.FILES) == 1:\n        user_file = list(request.FILES.values())[0]\n        assert isinstance(user_file, UploadedFile)\n        assert user_file.size is not None\n        upload_avatar_image(user_file, user_profile, bot_profile)\n\n    if bot_type in (UserProfile.OUTGOING_WEBHOOK_BOT, UserProfile.EMBEDDED_BOT):\n        assert isinstance(service_name, str)\n        add_service(\n            name=service_name,\n            user_profile=bot_profile,\n            base_url=payload_url,\n            interface=interface_type,\n            token=generate_api_key(),\n        )\n\n    if bot_type == UserProfile.INCOMING_WEBHOOK_BOT and service_name:\n        set_bot_config(bot_profile, \"integration_id\", service_name)\n\n    if bot_type in (UserProfile.INCOMING_WEBHOOK_BOT, UserProfile.EMBEDDED_BOT):\n        for key, value in config_data.items():\n            set_bot_config(bot_profile, key, value)\n\n    notify_created_bot(bot_profile)\n\n    api_key = get_api_key(bot_profile)\n\n    json_result = dict(\n        user_id=bot_profile.id,\n        api_key=api_key,\n        avatar_url=avatar_url(bot_profile),\n        default_sending_stream=get_stream_name(bot_profile.default_sending_stream),\n        default_events_register_stream=get_stream_name(bot_profile.default_events_register_stream),\n        default_all_public_streams=bot_profile.default_all_public_streams,\n    )\n    return json_success(request, data=json_result)\n\n\n@require_member_or_admin\ndef get_bots_backend(request: HttpRequest, user_profile: UserProfile) -> HttpResponse:\n    bot_profiles = UserProfile.objects.filter(is_bot=True, is_active=True, bot_owner=user_profile)\n    bot_profiles = bot_profiles.select_related(\n        \"default_sending_stream\", \"default_events_register_stream\"\n    )\n    bot_profiles = bot_profiles.order_by(\"date_joined\")\n\n    def bot_info(bot_profile: UserProfile) -> Dict[str, Any]:\n        default_sending_stream = get_stream_name(bot_profile.default_sending_stream)\n        default_events_register_stream = get_stream_name(bot_profile.default_events_register_stream)\n\n        # Bots are supposed to have only one API key, at least for now.\n        # Therefore we can safely assume that one and only valid API key will be\n        # the first one.\n        api_key = get_api_key(bot_profile)\n\n        return dict(\n            username=bot_profile.email,\n            full_name=bot_profile.full_name,\n            api_key=api_key,\n            avatar_url=avatar_url(bot_profile),\n            default_sending_stream=default_sending_stream,\n            default_events_register_stream=default_events_register_stream,\n            default_all_public_streams=bot_profile.default_all_public_streams,\n        )\n\n    return json_success(request, data={\"bots\": list(map(bot_info, bot_profiles))})\n\n\ndef get_user_data(\n    user_profile: UserProfile,\n    include_custom_profile_fields: bool,\n    client_gravatar: bool,\n    target_user: Optional[UserProfile] = None,\n) -> Dict[str, Any]:\n    \"\"\"\n    The client_gravatar field here is set to True by default assuming that clients\n    can compute their own gravatars, which saves bandwidth. This is more important of\n    an optimization than it might seem because gravatar URLs contain MD5 hashes that\n    compress very poorly compared to other data.\n    \"\"\"\n    realm = user_profile.realm\n    if realm.email_address_visibility != Realm.EMAIL_ADDRESS_VISIBILITY_EVERYONE:\n        # If email addresses are only available to administrators,\n        # clients cannot compute gravatars, so we force-set it to false.\n        client_gravatar = False\n\n    members = get_raw_user_data(\n        realm,\n        user_profile,\n        target_user=target_user,\n        client_gravatar=client_gravatar,\n        user_avatar_url_field_optional=False,\n        include_custom_profile_fields=include_custom_profile_fields,\n    )\n\n    if target_user is not None:\n        data: Dict[str, Any] = {\"user\": members[target_user.id]}\n    else:\n        data = {\"members\": [members[k] for k in members]}\n\n    return data\n\n\n@has_request_variables\ndef get_members_backend(\n    request: HttpRequest,\n    user_profile: UserProfile,\n    user_id: Optional[int] = None,\n    include_custom_profile_fields: bool = REQ(json_validator=check_bool, default=False),\n    client_gravatar: bool = REQ(json_validator=check_bool, default=True),\n) -> HttpResponse:\n    target_user = None\n    if user_id is not None:\n        target_user = access_user_by_id(\n            user_profile, user_id, allow_deactivated=True, allow_bots=True, for_admin=False\n        )\n\n    data = get_user_data(user_profile, include_custom_profile_fields, client_gravatar, target_user)\n\n    return json_success(request, data)\n\n\n@require_realm_admin\n@has_request_variables\ndef create_user_backend(\n    request: HttpRequest,\n    user_profile: UserProfile,\n    email: str = REQ(),\n    password: str = REQ(),\n    full_name_raw: str = REQ(\"full_name\"),\n) -> HttpResponse:\n    if not user_profile.can_create_users:\n        raise JsonableError(_(\"User not authorized for this query\"))\n\n    full_name = check_full_name(full_name_raw)\n    form = CreateUserForm({\"full_name\": full_name, \"email\": email})\n    if not form.is_valid():\n        raise JsonableError(_(\"Bad name or username\"))\n\n    # Check that the new user's email address belongs to the admin's realm\n    # (Since this is an admin API, we don't require the user to have been\n    # invited first.)\n    realm = user_profile.realm\n    try:\n        email_allowed_for_realm(email, user_profile.realm)\n    except DomainNotAllowedForRealmError:\n        raise JsonableError(\n            _(\"Email '{email}' not allowed in this organization\").format(\n                email=email,\n            )\n        )\n    except DisposableEmailError:\n        raise JsonableError(_(\"Disposable email addresses are not allowed in this organization\"))\n    except EmailContainsPlusError:\n        raise JsonableError(_(\"Email addresses containing + are not allowed.\"))\n\n    try:\n        get_user_by_delivery_email(email, user_profile.realm)\n        raise JsonableError(_(\"Email '{}' already in use\").format(email))\n    except UserProfile.DoesNotExist:\n        pass\n\n    if not check_password_strength(password):\n        raise JsonableError(PASSWORD_TOO_WEAK_ERROR)\n\n    target_user = do_create_user(\n        email,\n        password,\n        realm,\n        full_name,\n        # Explicitly set tos_version=None. For servers that have\n        # configured Terms of Service, this means that users created\n        # via this mechanism will be prompted to accept the Terms of\n        # Service on first login.\n        tos_version=None,\n        acting_user=user_profile,\n    )\n    return json_success(request, data={\"user_id\": target_user.id})\n\n\ndef get_profile_backend(request: HttpRequest, user_profile: UserProfile) -> HttpResponse:\n    raw_user_data = get_raw_user_data(\n        user_profile.realm,\n        user_profile,\n        target_user=user_profile,\n        client_gravatar=False,\n        user_avatar_url_field_optional=False,\n    )\n    result: Dict[str, Any] = raw_user_data[user_profile.id]\n\n    result[\"max_message_id\"] = -1\n\n    messages = Message.objects.filter(usermessage__user_profile=user_profile).order_by(\"-id\")[:1]\n    if messages:\n        result[\"max_message_id\"] = messages[0].id\n\n    return json_success(request, data=result)\n\n\n@has_request_variables\ndef get_subscription_backend(\n    request: HttpRequest,\n    user_profile: UserProfile,\n    user_id: int = REQ(json_validator=check_int, path_only=True),\n    stream_id: int = REQ(json_validator=check_int, path_only=True),\n) -> HttpResponse:\n    target_user = access_user_by_id(user_profile, user_id, for_admin=False)\n    (stream, sub) = access_stream_by_id(user_profile, stream_id, allow_realm_admin=True)\n\n    subscription_status = {\"is_subscribed\": subscribed_to_stream(target_user, stream_id)}\n\n    return json_success(request, data=subscription_status)\n\n\n@has_request_variables\ndef get_user_by_email(\n    request: HttpRequest,\n    user_profile: UserProfile,\n    email: str,\n    include_custom_profile_fields: bool = REQ(json_validator=check_bool, default=False),\n    client_gravatar: bool = REQ(json_validator=check_bool, default=True),\n) -> HttpResponse:\n    target_user = access_user_by_email(\n        user_profile, email, allow_deactivated=True, allow_bots=True, for_admin=False\n    )\n\n    data = get_user_data(user_profile, include_custom_profile_fields, client_gravatar, target_user)\n    return json_success(request, data)\n"], "filenames": ["zerver/tests/test_bots.py", "zerver/views/users.py"], "buggy_code_start_loc": [10, 42], "buggy_code_end_loc": [1194, 333], "fixing_code_start_loc": [11, 43], "fixing_code_end_loc": [1213, 337], "type": "CWE-285", "message": "Zulip is an open source team chat tool. Due to an incorrect authorization check in Zulip Server 5.4 and earlier, a member of an organization could craft an API call that grants organization administrator privileges to one of their bots. The vulnerability is fixed in Zulip Server 5.5. Members who don\u00e2\u20ac\u2122t own any bots, and lack permission to create them, can\u00e2\u20ac\u2122t exploit the vulnerability. As a workaround for the vulnerability, an organization administrator can restrict the `Who can create bots` permission to administrators only, and change the ownership of existing bots.", "other": {"cve": {"id": "CVE-2022-31168", "sourceIdentifier": "security-advisories@github.com", "published": "2022-07-22T13:15:08.540", "lastModified": "2022-07-29T19:29:12.773", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Zulip is an open source team chat tool. Due to an incorrect authorization check in Zulip Server 5.4 and earlier, a member of an organization could craft an API call that grants organization administrator privileges to one of their bots. The vulnerability is fixed in Zulip Server 5.5. Members who don\u00e2\u20ac\u2122t own any bots, and lack permission to create them, can\u00e2\u20ac\u2122t exploit the vulnerability. As a workaround for the vulnerability, an organization administrator can restrict the `Who can create bots` permission to administrators only, and change the ownership of existing bots."}, {"lang": "es", "value": "Zulip es una herramienta de chat de equipo de c\u00f3digo abierto. Debido a una comprobaci\u00f3n de autorizaci\u00f3n incorrecta en Zulip Server versiones 5.4 y anteriores, un miembro de una organizaci\u00f3n podr\u00eda dise\u00f1ar una llamada a la API que conceda privilegios de administrador de la organizaci\u00f3n a uno de sus bots. La vulnerabilidad ha sido corregida en Zulip Server versi\u00f3n 5.5. Los miembros que no posean ning\u00fan bot, y carezcan de permiso para crearlos, no pueden explotar la vulnerabilidad. Como mitigaci\u00f3n a la vulnerabilidad, un administrador de la organizaci\u00f3n puede restringir el permiso \"Who can create bots\" a administradores solamente, y cambiar la propiedad de los bots existentes"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-285"}, {"lang": "en", "value": "CWE-863"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:zulip:zulip:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.5", "matchCriteriaId": "524C7064-D386-4FB6-AB29-54123411EB07"}]}]}], "references": [{"url": "https://github.com/zulip/zulip/commit/751b2a03e565e9eb02ffe923b7c24ac73d604034", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/zulip/zulip/releases/tag/5.5", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/zulip/zulip/security/advisories/GHSA-c3cp-ggg5-9xw5", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/zulip/zulip/commit/751b2a03e565e9eb02ffe923b7c24ac73d604034"}}