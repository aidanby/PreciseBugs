{"buggy_code": ["/*\n * pam.go - Utility functions for interfacing with the PAM libraries.\n *\n * Copyright 2017 Google Inc.\n * Author: Joe Richey (joerichey@google.com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage pam\n\n/*\n#cgo LDFLAGS: -lpam\n#include \"pam.h\"\n\n#include <pwd.h>\n#include <stdlib.h>\n#include <security/pam_modules.h>\n*/\nimport \"C\"\nimport (\n\t\"errors\"\n\t\"log\"\n\t\"os/user\"\n\t\"unsafe\"\n\n\t\"github.com/google/fscrypt/security\"\n\t\"github.com/google/fscrypt/util\"\n)\n\n// Handle wraps the C pam_handle_t type. This is used from within modules.\ntype Handle struct {\n\thandle *C.pam_handle_t\n\tstatus C.int\n\t// OrigUser is the user who invoked the PAM module (usually root)\n\tOrigUser *user.User\n\t// PamUser is the user who the PAM module is for\n\tPamUser *user.User\n}\n\n// NewHandle creates a Handle from a raw pointer.\nfunc NewHandle(pamh unsafe.Pointer) (*Handle, error) {\n\tvar err error\n\th := &Handle{\n\t\thandle: (*C.pam_handle_t)(pamh),\n\t\tstatus: C.PAM_SUCCESS,\n\t}\n\n\tvar pamUsername *C.char\n\th.status = C.pam_get_user(h.handle, &pamUsername, nil)\n\tif err = h.err(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif h.PamUser, err = user.Lookup(C.GoString(pamUsername)); err != nil {\n\t\treturn nil, err\n\t}\n\tif h.OrigUser, err = util.EffectiveUser(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn h, nil\n}\n\nfunc (h *Handle) setData(name string, data unsafe.Pointer, cleanup C.CleanupFunc) error {\n\tcName := C.CString(name)\n\tdefer C.free(unsafe.Pointer(cName))\n\th.status = C.pam_set_data(h.handle, cName, data, cleanup)\n\treturn h.err()\n}\n\nfunc (h *Handle) getData(name string) (unsafe.Pointer, error) {\n\tvar data unsafe.Pointer\n\tcName := C.CString(name)\n\tdefer C.free(unsafe.Pointer(cName))\n\th.status = C.pam_get_data(h.handle, cName, &data)\n\treturn data, h.err()\n}\n\n// ClearData remotes the PAM data with the specified name.\nfunc (h *Handle) ClearData(name string) error {\n\treturn h.setData(name, unsafe.Pointer(C.CString(\"\")), C.CleanupFunc(C.freeData))\n}\n\n// SetSecret sets a copy of the C string secret into the PAM data with the\n// specified name. This copy will be held in locked memory until this PAM data\n// is cleared.\nfunc (h *Handle) SetSecret(name string, secret unsafe.Pointer) error {\n\treturn h.setData(name, C.copyIntoSecret(secret), C.CleanupFunc(C.freeSecret))\n}\n\n// GetSecret returns a pointer to the C string PAM data with the specified name.\n// This a pointer directory to the data, so it shouldn't be modified. It should\n// have been previously set with SetSecret().\nfunc (h *Handle) GetSecret(name string) (unsafe.Pointer, error) {\n\treturn h.getData(name)\n}\n\n// SetString sets a string value for the PAM data with the specified name.\nfunc (h *Handle) SetString(name string, s string) error {\n\treturn h.setData(name, unsafe.Pointer(C.CString(s)), C.CleanupFunc(C.freeData))\n}\n\n// GetString gets a string value for the PAM data with the specified name. It\n// should have been previously set with SetString().\nfunc (h *Handle) GetString(name string) (string, error) {\n\tdata, err := h.getData(name)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn C.GoString((*C.char)(data)), nil\n}\n\n// GetItem retrieves a PAM information item. This is a pointer directly to the\n// data, so it shouldn't be modified.\nfunc (h *Handle) GetItem(i Item) (unsafe.Pointer, error) {\n\tvar data unsafe.Pointer\n\th.status = C.pam_get_item(h.handle, C.int(i), &data)\n\tif err := h.err(); err != nil {\n\t\treturn nil, err\n\t}\n\tif data == nil {\n\t\treturn nil, errors.New(\"item not found\")\n\t}\n\treturn data, nil\n}\n\n// StartAsPamUser sets the effective privileges to that of the PAM user, and\n// configures the PAM user's keyrings to be properly linked.\nfunc (h *Handle) StartAsPamUser() error {\n\tif _, err := security.UserKeyringID(h.PamUser, true); err != nil {\n\t\tlog.Printf(\"Setting up keyrings in PAM: %v\", err)\n\t}\n\treturn security.SetProcessPrivileges(h.PamUser)\n}\n\n// StopAsPamUser restores the original privileges that were running the\n// PAM module (this is usually root). As this error is often ignored in a defer\n// statement, any error is also logged.\nfunc (h *Handle) StopAsPamUser() error {\n\terr := security.SetProcessPrivileges(h.OrigUser)\n\tif err != nil {\n\t\tlog.Print(err)\n\t}\n\treturn err\n}\n\nfunc (h *Handle) err() error {\n\tif h.status == C.PAM_SUCCESS {\n\t\treturn nil\n\t}\n\ts := C.GoString(C.pam_strerror(h.handle, C.int(h.status)))\n\treturn errors.New(s)\n}\n\n// Transaction represents a wrapped pam_handle_t type created with pam_start\n// form an application.\ntype Transaction Handle\n\n// Start initializes a pam Transaction. End() should be called after the\n// Transaction is no longer needed.\nfunc Start(service, username string) (*Transaction, error) {\n\tcService := C.CString(service)\n\tdefer C.free(unsafe.Pointer(cService))\n\tcUsername := C.CString(username)\n\tdefer C.free(unsafe.Pointer(cUsername))\n\n\tt := &Transaction{\n\t\thandle: nil,\n\t\tstatus: C.PAM_SUCCESS,\n\t}\n\tt.status = C.pam_start(\n\t\tcService,\n\t\tcUsername,\n\t\tC.goConv,\n\t\t&t.handle)\n\treturn t, (*Handle)(t).err()\n}\n\n// End finalizes a pam Transaction with pam_end().\nfunc (t *Transaction) End() {\n\tC.pam_end(t.handle, t.status)\n}\n\n// Authenticate returns a boolean indicating if the user authenticated correctly\n// or not. If the authentication check did not complete, an error is returned.\nfunc (t *Transaction) Authenticate(quiet bool) (bool, error) {\n\tvar flags C.int = C.PAM_DISALLOW_NULL_AUTHTOK\n\tif quiet {\n\t\tflags |= C.PAM_SILENT\n\t}\n\tt.status = C.pam_authenticate(t.handle, flags)\n\tif t.status == C.PAM_AUTH_ERR {\n\t\treturn false, nil\n\t}\n\treturn true, (*Handle)(t).err()\n}\n", "/*\n * privileges.go - Functions for managing users and privileges.\n *\n * Copyright 2017 Google Inc.\n * Author: Joe Richey (joerichey@google.com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\n// Package security manages:\n//  - Cache clearing (cache.go)\n//  - Keyring Operations (keyring.go)\n//  - Privilege manipulation (privileges.go)\n//  - Maintaining the link between the root and user keyrings.\npackage security\n\n// Use the libc versions of setreuid, setregid, and setgroups instead of the\n// \"sys/unix\" versions.  The \"sys/unix\" versions use the raw syscalls which\n// operate on the calling thread only, whereas the libc versions operate on the\n// whole process.  And we need to operate on the whole process, firstly for\n// pam_fscrypt to prevent the privileges of Go worker threads from diverging\n// from the PAM stack's \"main\" thread, violating libc's assumption and causing\n// an abort() later in the PAM stack; and secondly because Go code may migrate\n// between OS-level threads while it's running.\n//\n// See also: https://github.com/golang/go/issues/1435\n//\n// Also we need to wrap the libc functions in our own C functions rather than\n// calling them directly because in the glibc headers (but not necessarily in\n// the headers for other C libraries that may be used on Linux) they are\n// declared to take __uid_t and __gid_t arguments rather than uid_t and gid_t.\n// And while these are typedef'ed to the same underlying type, before Go 1.10,\n// cgo maps them to different Go types.\n\n/*\n#include <sys/types.h>\n#include <unistd.h>\t// setreuid, setregid\n#include <grp.h>\t// setgroups\n\nstatic int my_setreuid(uid_t ruid, uid_t euid)\n{\n\treturn setreuid(ruid, euid);\n}\n\nstatic int my_setregid(gid_t rgid, gid_t egid)\n{\n\treturn setregid(rgid, egid);\n}\n\nstatic int my_setgroups(size_t size, const gid_t *list)\n{\n\treturn setgroups(size, list);\n}\n*/\nimport \"C\"\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"os/user\"\n\t\"syscall\"\n\n\t\"github.com/pkg/errors\"\n\n\t\"github.com/google/fscrypt/util\"\n)\n\n// SetProcessPrivileges temporarily drops the privileges of the current process\n// to have the effective uid/gid of the target user. The privileges can be\n// changed again with another call to SetProcessPrivileges.\nfunc SetProcessPrivileges(target *user.User) error {\n\teuid := util.AtoiOrPanic(target.Uid)\n\tegid := util.AtoiOrPanic(target.Gid)\n\tif os.Geteuid() == euid {\n\t\tlog.Printf(\"Privileges already set to %q\", target.Username)\n\t\treturn nil\n\t}\n\tlog.Printf(\"Setting privileges to %q\", target.Username)\n\n\t// If setting privs to root, we want to set the uid first, so we will\n\t// then have the necessary permissions to perform the other actions.\n\tif euid == 0 {\n\t\tif err := setUids(-1, euid); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := setGids(-1, egid); err != nil {\n\t\treturn err\n\t}\n\tif err := setGroups(target); err != nil {\n\t\treturn err\n\t}\n\t// If not setting privs to root, we want to avoid dropping the uid\n\t// util the very end.\n\tif euid != 0 {\n\t\tif err := setUids(-1, euid); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc setUids(ruid, euid int) error {\n\tres, err := C.my_setreuid(C.uid_t(ruid), C.uid_t(euid))\n\tlog.Printf(\"setreuid(%d, %d) = %d (errno %v)\", ruid, euid, res, err)\n\tif res == 0 {\n\t\treturn nil\n\t}\n\treturn errors.Wrapf(err.(syscall.Errno), \"setting uids\")\n}\n\nfunc setGids(rgid, egid int) error {\n\tres, err := C.my_setregid(C.gid_t(rgid), C.gid_t(egid))\n\tlog.Printf(\"setregid(%d, %d) = %d (errno %v)\", rgid, egid, res, err)\n\tif res == 0 {\n\t\treturn nil\n\t}\n\treturn errors.Wrapf(err.(syscall.Errno), \"setting gids\")\n}\n\nfunc setGroups(target *user.User) error {\n\tgroupStrings, err := target.GroupIds()\n\tif err != nil {\n\t\treturn util.SystemError(err.Error())\n\t}\n\tgids := make([]C.gid_t, len(groupStrings))\n\tfor i, groupString := range groupStrings {\n\t\tgids[i] = C.gid_t(util.AtoiOrPanic(groupString))\n\t}\n\tres, err := C.my_setgroups(C.size_t(len(groupStrings)), &gids[0])\n\tlog.Printf(\"setgroups(%v) = %d (errno %v)\", gids, res, err)\n\tif res == 0 {\n\t\treturn nil\n\t}\n\treturn errors.Wrapf(err.(syscall.Errno), \"setting groups\")\n}\n"], "fixing_code": ["/*\n * pam.go - Utility functions for interfacing with the PAM libraries.\n *\n * Copyright 2017 Google Inc.\n * Author: Joe Richey (joerichey@google.com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage pam\n\n/*\n#cgo LDFLAGS: -lpam\n#include \"pam.h\"\n\n#include <pwd.h>\n#include <stdlib.h>\n#include <security/pam_modules.h>\n*/\nimport \"C\"\nimport (\n\t\"errors\"\n\t\"log\"\n\t\"os/user\"\n\t\"unsafe\"\n\n\t\"github.com/google/fscrypt/security\"\n)\n\n// Handle wraps the C pam_handle_t type. This is used from within modules.\ntype Handle struct {\n\thandle    *C.pam_handle_t\n\tstatus    C.int\n\torigPrivs *security.Privileges\n\t// PamUser is the user for whom the PAM module is running.\n\tPamUser *user.User\n}\n\n// NewHandle creates a Handle from a raw pointer.\nfunc NewHandle(pamh unsafe.Pointer) (*Handle, error) {\n\tvar err error\n\th := &Handle{\n\t\thandle: (*C.pam_handle_t)(pamh),\n\t\tstatus: C.PAM_SUCCESS,\n\t}\n\n\tvar pamUsername *C.char\n\th.status = C.pam_get_user(h.handle, &pamUsername, nil)\n\tif err = h.err(); err != nil {\n\t\treturn nil, err\n\t}\n\n\th.PamUser, err = user.Lookup(C.GoString(pamUsername))\n\treturn h, err\n}\n\nfunc (h *Handle) setData(name string, data unsafe.Pointer, cleanup C.CleanupFunc) error {\n\tcName := C.CString(name)\n\tdefer C.free(unsafe.Pointer(cName))\n\th.status = C.pam_set_data(h.handle, cName, data, cleanup)\n\treturn h.err()\n}\n\nfunc (h *Handle) getData(name string) (unsafe.Pointer, error) {\n\tvar data unsafe.Pointer\n\tcName := C.CString(name)\n\tdefer C.free(unsafe.Pointer(cName))\n\th.status = C.pam_get_data(h.handle, cName, &data)\n\treturn data, h.err()\n}\n\n// ClearData remotes the PAM data with the specified name.\nfunc (h *Handle) ClearData(name string) error {\n\treturn h.setData(name, unsafe.Pointer(C.CString(\"\")), C.CleanupFunc(C.freeData))\n}\n\n// SetSecret sets a copy of the C string secret into the PAM data with the\n// specified name. This copy will be held in locked memory until this PAM data\n// is cleared.\nfunc (h *Handle) SetSecret(name string, secret unsafe.Pointer) error {\n\treturn h.setData(name, C.copyIntoSecret(secret), C.CleanupFunc(C.freeSecret))\n}\n\n// GetSecret returns a pointer to the C string PAM data with the specified name.\n// This a pointer directory to the data, so it shouldn't be modified. It should\n// have been previously set with SetSecret().\nfunc (h *Handle) GetSecret(name string) (unsafe.Pointer, error) {\n\treturn h.getData(name)\n}\n\n// SetString sets a string value for the PAM data with the specified name.\nfunc (h *Handle) SetString(name string, s string) error {\n\treturn h.setData(name, unsafe.Pointer(C.CString(s)), C.CleanupFunc(C.freeData))\n}\n\n// GetString gets a string value for the PAM data with the specified name. It\n// should have been previously set with SetString().\nfunc (h *Handle) GetString(name string) (string, error) {\n\tdata, err := h.getData(name)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn C.GoString((*C.char)(data)), nil\n}\n\n// GetItem retrieves a PAM information item. This is a pointer directly to the\n// data, so it shouldn't be modified.\nfunc (h *Handle) GetItem(i Item) (unsafe.Pointer, error) {\n\tvar data unsafe.Pointer\n\th.status = C.pam_get_item(h.handle, C.int(i), &data)\n\tif err := h.err(); err != nil {\n\t\treturn nil, err\n\t}\n\tif data == nil {\n\t\treturn nil, errors.New(\"item not found\")\n\t}\n\treturn data, nil\n}\n\n// StartAsPamUser sets the effective privileges to that of the PAM user, and\n// configures the PAM user's keyrings to be properly linked.\nfunc (h *Handle) StartAsPamUser() error {\n\tif _, err := security.UserKeyringID(h.PamUser, true); err != nil {\n\t\tlog.Printf(\"Setting up keyrings in PAM: %v\", err)\n\t}\n\tuserPrivs, err := security.UserPrivileges(h.PamUser)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif h.origPrivs, err = security.ProcessPrivileges(); err != nil {\n\t\treturn err\n\t}\n\treturn security.SetProcessPrivileges(userPrivs)\n}\n\n// StopAsPamUser restores the original privileges that were running the\n// PAM module (this is usually root).\nfunc (h *Handle) StopAsPamUser() error {\n\terr := security.SetProcessPrivileges(h.origPrivs)\n\tif err != nil {\n\t\tlog.Print(err)\n\t}\n\treturn err\n}\n\nfunc (h *Handle) err() error {\n\tif h.status == C.PAM_SUCCESS {\n\t\treturn nil\n\t}\n\ts := C.GoString(C.pam_strerror(h.handle, C.int(h.status)))\n\treturn errors.New(s)\n}\n\n// Transaction represents a wrapped pam_handle_t type created with pam_start\n// form an application.\ntype Transaction Handle\n\n// Start initializes a pam Transaction. End() should be called after the\n// Transaction is no longer needed.\nfunc Start(service, username string) (*Transaction, error) {\n\tcService := C.CString(service)\n\tdefer C.free(unsafe.Pointer(cService))\n\tcUsername := C.CString(username)\n\tdefer C.free(unsafe.Pointer(cUsername))\n\n\tt := &Transaction{\n\t\thandle: nil,\n\t\tstatus: C.PAM_SUCCESS,\n\t}\n\tt.status = C.pam_start(\n\t\tcService,\n\t\tcUsername,\n\t\tC.goConv,\n\t\t&t.handle)\n\treturn t, (*Handle)(t).err()\n}\n\n// End finalizes a pam Transaction with pam_end().\nfunc (t *Transaction) End() {\n\tC.pam_end(t.handle, t.status)\n}\n\n// Authenticate returns a boolean indicating if the user authenticated correctly\n// or not. If the authentication check did not complete, an error is returned.\nfunc (t *Transaction) Authenticate(quiet bool) (bool, error) {\n\tvar flags C.int = C.PAM_DISALLOW_NULL_AUTHTOK\n\tif quiet {\n\t\tflags |= C.PAM_SILENT\n\t}\n\tt.status = C.pam_authenticate(t.handle, flags)\n\tif t.status == C.PAM_AUTH_ERR {\n\t\treturn false, nil\n\t}\n\treturn true, (*Handle)(t).err()\n}\n", "/*\n * privileges.go - Functions for managing users and privileges.\n *\n * Copyright 2017 Google Inc.\n * Author: Joe Richey (joerichey@google.com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\n// Package security manages:\n//  - Cache clearing (cache.go)\n//  - Keyring Operations (keyring.go)\n//  - Privilege manipulation (privileges.go)\n//  - Maintaining the link between the root and user keyrings.\npackage security\n\n// Use the libc versions of setreuid, setregid, and setgroups instead of the\n// \"sys/unix\" versions.  The \"sys/unix\" versions use the raw syscalls which\n// operate on the calling thread only, whereas the libc versions operate on the\n// whole process.  And we need to operate on the whole process, firstly for\n// pam_fscrypt to prevent the privileges of Go worker threads from diverging\n// from the PAM stack's \"main\" thread, violating libc's assumption and causing\n// an abort() later in the PAM stack; and secondly because Go code may migrate\n// between OS-level threads while it's running.\n//\n// See also: https://github.com/golang/go/issues/1435\n//\n// Also we need to wrap the libc functions in our own C functions rather than\n// calling them directly because in the glibc headers (but not necessarily in\n// the headers for other C libraries that may be used on Linux) they are\n// declared to take __uid_t and __gid_t arguments rather than uid_t and gid_t.\n// And while these are typedef'ed to the same underlying type, before Go 1.10,\n// cgo maps them to different Go types.\n\n/*\n#define _GNU_SOURCE    // for getresuid and setresuid\n#include <sys/types.h>\n#include <unistd.h>    // getting and setting uids and gids\n#include <grp.h>       // setgroups\n*/\nimport \"C\"\n\nimport (\n\t\"log\"\n\t\"os/user\"\n\t\"syscall\"\n\n\t\"github.com/pkg/errors\"\n\n\t\"github.com/google/fscrypt/util\"\n)\n\n// Privileges encapulate the effective uid/gid and groups of a process.\ntype Privileges struct {\n\teuid   C.uid_t\n\tegid   C.gid_t\n\tgroups []C.gid_t\n}\n\n// ProcessPrivileges returns the process's current effective privileges.\nfunc ProcessPrivileges() (*Privileges, error) {\n\truid := C.getuid()\n\teuid := C.geteuid()\n\trgid := C.getgid()\n\tegid := C.getegid()\n\n\tvar groups []C.gid_t\n\tn, err := C.getgroups(0, nil)\n\tif n < 0 {\n\t\treturn nil, err\n\t}\n\t// If n == 0, the user isn't in any groups, so groups == nil is fine.\n\tif n > 0 {\n\t\tgroups = make([]C.gid_t, n)\n\t\tn, err = C.getgroups(n, &groups[0])\n\t\tif n < 0 {\n\t\t\treturn nil, err\n\t\t}\n\t\tgroups = groups[:n]\n\t}\n\tlog.Printf(\"Current privs (real, effective): uid=(%d,%d) gid=(%d,%d) groups=%v\",\n\t\truid, euid, rgid, egid, groups)\n\treturn &Privileges{euid, egid, groups}, nil\n}\n\n// UserPrivileges returns the defualt privileges for the specified user.\nfunc UserPrivileges(user *user.User) (*Privileges, error) {\n\tprivs := &Privileges{\n\t\teuid: C.uid_t(util.AtoiOrPanic(user.Uid)),\n\t\tegid: C.gid_t(util.AtoiOrPanic(user.Gid)),\n\t}\n\tuserGroups, err := user.GroupIds()\n\tif err != nil {\n\t\treturn nil, util.SystemError(err.Error())\n\t}\n\tprivs.groups = make([]C.gid_t, len(userGroups))\n\tfor i, group := range userGroups {\n\t\tprivs.groups[i] = C.gid_t(util.AtoiOrPanic(group))\n\t}\n\treturn privs, nil\n}\n\n// SetProcessPrivileges sets the privileges of the current process to have those\n// specified by privs. The original privileges can be obtained by first saving\n// the output of ProcessPrivileges, calling SetProcessPrivileges with the\n// desired privs, then calling SetProcessPrivileges with the saved privs.\nfunc SetProcessPrivileges(privs *Privileges) error {\n\tlog.Printf(\"Setting euid=%d egid=%d groups=%v\", privs.euid, privs.egid, privs.groups)\n\n\t// If setting privs as root, we need to set the euid to 0 first, so that\n\t// we will have the necessary permissions to make the other changes to\n\t// the groups/egid/euid, regardless of our original euid.\n\tC.seteuid(0)\n\n\t// Seperately handle the case where the user is in no groups.\n\tnumGroups := C.size_t(len(privs.groups))\n\tgroupsPtr := (*C.gid_t)(nil)\n\tif numGroups > 0 {\n\t\tgroupsPtr = &privs.groups[0]\n\t}\n\n\tif res, err := C.setgroups(numGroups, groupsPtr); res < 0 {\n\t\treturn errors.Wrapf(err.(syscall.Errno), \"setting groups\")\n\t}\n\tif res, err := C.setegid(privs.egid); res < 0 {\n\t\treturn errors.Wrapf(err.(syscall.Errno), \"setting egid\")\n\t}\n\tif res, err := C.seteuid(privs.euid); res < 0 {\n\t\treturn errors.Wrapf(err.(syscall.Errno), \"setting euid\")\n\t}\n\tProcessPrivileges()\n\treturn nil\n}\n\nfunc setUids(ruid, euid int) error {\n\tres, err := C.setreuid(C.uid_t(ruid), C.uid_t(euid))\n\tlog.Printf(\"setreuid(%d, %d) = %d (errno %v)\", ruid, euid, res, err)\n\tif res == 0 {\n\t\treturn nil\n\t}\n\treturn errors.Wrapf(err.(syscall.Errno), \"setting uids\")\n}\n"], "filenames": ["pam/pam.go", "security/privileges.go"], "buggy_code_start_loc": [38, 45], "buggy_code_end_loc": [151, 147], "fixing_code_start_loc": [37, 46], "fixing_code_end_loc": [150, 152], "type": "NVD-CWE-noinfo", "message": "The pam_fscrypt module in fscrypt before 0.2.4 may incorrectly restore primary and supplementary group IDs to the values associated with the root user, which allows attackers to gain privileges via a successful login through certain applications that use Linux-PAM (aka pam).", "other": {"cve": {"id": "CVE-2018-6558", "sourceIdentifier": "security@ubuntu.com", "published": "2018-08-23T19:29:01.127", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The pam_fscrypt module in fscrypt before 0.2.4 may incorrectly restore primary and supplementary group IDs to the values associated with the root user, which allows attackers to gain privileges via a successful login through certain applications that use Linux-PAM (aka pam)."}, {"lang": "es", "value": "El m\u00f3dulo pam_fscrypt en fscrypt en versiones anteriores a la 0.2.4 podr\u00eda restaurar incorrectamente los ID de los grupos primarios y suplementarios a los valores asociados con el usuario root, lo que permite que los atacantes obtengan privilegios mediante un inicio de sesi\u00f3n con \u00e9xito a trav\u00e9s de determinadas aplicaciones que utilicen Linux-PAM (tambi\u00e9n conocido como pam)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 6.8, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:fscrypt:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.2.4", "matchCriteriaId": "80891EB5-205B-4BB3-8BEA-589FD0B5CDB3"}]}]}], "references": [{"url": "https://github.com/google/fscrypt/commit/3022c1603d968c22f147b4a2c49c4637dd1be91b", "source": "security@ubuntu.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/google/fscrypt/commit/315f9b042237200174a1fb99427f74027e191d66", "source": "security@ubuntu.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/google/fscrypt/issues/77", "source": "security@ubuntu.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://launchpad.net/bugs/1787548", "source": "security@ubuntu.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/google/fscrypt/commit/3022c1603d968c22f147b4a2c49c4637dd1be91b"}}