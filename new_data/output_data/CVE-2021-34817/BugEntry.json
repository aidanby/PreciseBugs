{"buggy_code": ["'use strict';\n/**\n * Copyright 2009 Google Inc., 2011 Peter 'Pita' Martischka (Primary Technology Ltd)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst padutils = require('./pad_utils').padutils;\nconst padcookie = require('./pad_cookie').padcookie;\nconst Tinycon = require('tinycon/tinycon');\nconst hooks = require('./pluginfw/hooks');\nconst padeditor = require('./pad_editor').padeditor;\n\nexports.chat = (() => {\n  let isStuck = false;\n  let userAndChat = false;\n  let chatMentions = 0;\n  return {\n    show() {\n      $('#chaticon').removeClass('visible');\n      $('#chatbox').addClass('visible');\n      this.scrollDown(true);\n      chatMentions = 0;\n      Tinycon.setBubble(0);\n      $('.chat-gritter-msg').each(function () {\n        $.gritter.remove(this.id);\n      });\n    },\n    focus: () => {\n      setTimeout(() => {\n        $('#chatinput').focus();\n      }, 100);\n    },\n    // Make chat stick to right hand side of screen\n    stickToScreen(fromInitialCall) {\n      if (pad.settings.hideChat) {\n        return;\n      }\n      this.show();\n      isStuck = (!isStuck || fromInitialCall);\n      $('#chatbox').hide();\n      // Add timeout to disable the chatbox animations\n      setTimeout(() => {\n        $('#chatbox, .sticky-container').toggleClass('stickyChat', isStuck);\n        $('#chatbox').css('display', 'flex');\n      }, 0);\n\n      padcookie.setPref('chatAlwaysVisible', isStuck);\n      $('#options-stickychat').prop('checked', isStuck);\n    },\n    chatAndUsers(fromInitialCall) {\n      const toEnable = $('#options-chatandusers').is(':checked');\n      if (toEnable || !userAndChat || fromInitialCall) {\n        this.stickToScreen(true);\n        $('#options-stickychat').prop('checked', true);\n        $('#options-chatandusers').prop('checked', true);\n        $('#options-stickychat').prop('disabled', 'disabled');\n        userAndChat = true;\n      } else {\n        $('#options-stickychat').prop('disabled', false);\n        userAndChat = false;\n      }\n      padcookie.setPref('chatAndUsers', userAndChat);\n      $('#users, .sticky-container')\n          .toggleClass('chatAndUsers popup-show stickyUsers', userAndChat);\n      $('#chatbox').toggleClass('chatAndUsersChat', userAndChat);\n    },\n    hide() {\n      // decide on hide logic based on chat window being maximized or not\n      if ($('#options-stickychat').prop('checked')) {\n        this.stickToScreen();\n        $('#options-stickychat').prop('checked', false);\n      } else {\n        $('#chatcounter').text('0');\n        $('#chaticon').addClass('visible');\n        $('#chatbox').removeClass('visible');\n      }\n    },\n    scrollDown(force) {\n      if ($('#chatbox').hasClass('visible')) {\n        if (force || !this.lastMessage || !this.lastMessage.position() ||\n            this.lastMessage.position().top < ($('#chattext').outerHeight() + 20)) {\n          // if we use a slow animate here we can have a race condition\n          // when a users focus can not be moved away from the last message recieved.\n          $('#chattext').animate(\n              {scrollTop: $('#chattext')[0].scrollHeight},\n              {duration: 400, queue: false});\n          this.lastMessage = $('#chattext > p').eq(-1);\n        }\n      }\n    },\n    send() {\n      const text = $('#chatinput').val();\n      if (text.replace(/\\s+/, '').length === 0) return;\n      this._pad.collabClient.sendMessage({type: 'CHAT_MESSAGE', text});\n      $('#chatinput').val('');\n    },\n    addMessage(msg, increment, isHistoryAdd) {\n      // correct the time\n      msg.time += this._pad.clientTimeOffset;\n\n      // create the time string\n      let minutes = `${new Date(msg.time).getMinutes()}`;\n      let hours = `${new Date(msg.time).getHours()}`;\n      if (minutes.length === 1) minutes = `0${minutes}`;\n      if (hours.length === 1) hours = `0${hours}`;\n      const timeStr = `${hours}:${minutes}`;\n\n      // create the authorclass\n      if (!msg.userId) {\n        /*\n         * If, for a bug or a database corruption, the message coming from the\n         * server does not contain the userId field (see for example #3731),\n         * let's be defensive and replace it with \"unknown\".\n         */\n        msg.userId = 'unknown';\n        console.warn(\n            'The \"userId\" field of a chat message coming from the server was not present. ' +\n            'Replacing with \"unknown\". This may be a bug or a database corruption.');\n      }\n\n      const authorClass = `author-${msg.userId.replace(/[^a-y0-9]/g, (c) => {\n        if (c === '.') return '-';\n        return `z${c.charCodeAt(0)}z`;\n      })}`;\n\n      const text = padutils.escapeHtmlWithClickableLinks(msg.text, '_blank');\n\n      const authorName = msg.userName == null ? html10n.get('pad.userlist.unnamed')\n        : padutils.escapeHtml(msg.userName);\n\n      // the hook args\n      const ctx = {\n        authorName,\n        author: msg.userId,\n        text,\n        sticky: false,\n        timestamp: msg.time,\n        timeStr,\n        duration: 4000,\n      };\n\n      // is the users focus already in the chatbox?\n      const alreadyFocused = $('#chatinput').is(':focus');\n\n      // does the user already have the chatbox open?\n      const chatOpen = $('#chatbox').hasClass('visible');\n\n      // does this message contain this user's name? (is the curretn user mentioned?)\n      const myName = $('#myusernameedit').val();\n      const wasMentioned =\n          text.toLowerCase().indexOf(myName.toLowerCase()) !== -1 && myName !== 'undefined';\n\n      // If the user was mentioned, make the message sticky\n      if (wasMentioned && !alreadyFocused && !isHistoryAdd && !chatOpen) {\n        chatMentions++;\n        Tinycon.setBubble(chatMentions);\n        ctx.sticky = true;\n      }\n\n      // Call chat message hook\n      hooks.aCallAll('chatNewMessage', ctx, () => {\n        const html =\n            `<p data-authorId='${msg.userId}' class='${authorClass}'><b>${authorName}:</b>` +\n            `<span class='time ${authorClass}'>${ctx.timeStr}</span> ${ctx.text}</p>`;\n        if (isHistoryAdd) $(html).insertAfter('#chatloadmessagesbutton');\n        else $('#chattext').append(html);\n\n        // should we increment the counter??\n        if (increment && !isHistoryAdd) {\n          // Update the counter of unread messages\n          let count = Number($('#chatcounter').text());\n          count++;\n          $('#chatcounter').text(count);\n\n          if (!chatOpen && ctx.duration > 0) {\n            $.gritter.add({\n              // Note: ctx.authorName and ctx.text are already HTML-escaped.\n              text: $('<p>')\n                  .append($('<span>').addClass('author-name').html(ctx.authorName))\n                  .append(ctx.text),\n              sticky: ctx.sticky,\n              time: 5000,\n              position: 'bottom',\n              class_name: 'chat-gritter-msg',\n            });\n          }\n        }\n      });\n\n      // Clear the chat mentions when the user clicks on the chat input box\n      $('#chatinput').click(() => {\n        chatMentions = 0;\n        Tinycon.setBubble(0);\n      });\n      if (!isHistoryAdd) this.scrollDown();\n    },\n    init(pad) {\n      this._pad = pad;\n      $('#chatinput').on('keydown', (evt) => {\n        // If the event is Alt C or Escape & we're already in the chat menu\n        // Send the users focus back to the pad\n        if ((evt.altKey === true && evt.which === 67) || evt.which === 27) {\n          // If we're in chat already..\n          $(':focus').blur(); // required to do not try to remove!\n          padeditor.ace.focus(); // Sends focus back to pad\n          evt.preventDefault();\n          return false;\n        }\n      });\n\n      const self = this;\n      $('body:not(#chatinput)').on('keypress', function (evt) {\n        if (evt.altKey && evt.which === 67) {\n          // Alt c focuses on the Chat window\n          $(this).blur();\n          self.show();\n          $('#chatinput').focus();\n          evt.preventDefault();\n        }\n      });\n\n      $('#chatinput').keypress((evt) => {\n        // if the user typed enter, fire the send\n        if (evt.which === 13 || evt.which === 10) {\n          evt.preventDefault();\n          this.send();\n        }\n      });\n\n      // initial messages are loaded in pad.js' _afterHandshake\n\n      $('#chatcounter').text(0);\n      $('#chatloadmessagesbutton').click(() => {\n        const start = Math.max(this.historyPointer - 20, 0);\n        const end = this.historyPointer;\n\n        if (start === end) return; // nothing to load\n\n        $('#chatloadmessagesbutton').css('display', 'none');\n        $('#chatloadmessagesball').css('display', 'block');\n\n        pad.collabClient.sendMessage({type: 'GET_CHAT_MESSAGES', start, end});\n        this.historyPointer = start;\n      });\n    },\n  };\n})();\n"], "fixing_code": ["'use strict';\n/**\n * Copyright 2009 Google Inc., 2011 Peter 'Pita' Martischka (Primary Technology Ltd)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst padutils = require('./pad_utils').padutils;\nconst padcookie = require('./pad_cookie').padcookie;\nconst Tinycon = require('tinycon/tinycon');\nconst hooks = require('./pluginfw/hooks');\nconst padeditor = require('./pad_editor').padeditor;\n\nexports.chat = (() => {\n  let isStuck = false;\n  let userAndChat = false;\n  let chatMentions = 0;\n  return {\n    show() {\n      $('#chaticon').removeClass('visible');\n      $('#chatbox').addClass('visible');\n      this.scrollDown(true);\n      chatMentions = 0;\n      Tinycon.setBubble(0);\n      $('.chat-gritter-msg').each(function () {\n        $.gritter.remove(this.id);\n      });\n    },\n    focus: () => {\n      setTimeout(() => {\n        $('#chatinput').focus();\n      }, 100);\n    },\n    // Make chat stick to right hand side of screen\n    stickToScreen(fromInitialCall) {\n      if (pad.settings.hideChat) {\n        return;\n      }\n      this.show();\n      isStuck = (!isStuck || fromInitialCall);\n      $('#chatbox').hide();\n      // Add timeout to disable the chatbox animations\n      setTimeout(() => {\n        $('#chatbox, .sticky-container').toggleClass('stickyChat', isStuck);\n        $('#chatbox').css('display', 'flex');\n      }, 0);\n\n      padcookie.setPref('chatAlwaysVisible', isStuck);\n      $('#options-stickychat').prop('checked', isStuck);\n    },\n    chatAndUsers(fromInitialCall) {\n      const toEnable = $('#options-chatandusers').is(':checked');\n      if (toEnable || !userAndChat || fromInitialCall) {\n        this.stickToScreen(true);\n        $('#options-stickychat').prop('checked', true);\n        $('#options-chatandusers').prop('checked', true);\n        $('#options-stickychat').prop('disabled', 'disabled');\n        userAndChat = true;\n      } else {\n        $('#options-stickychat').prop('disabled', false);\n        userAndChat = false;\n      }\n      padcookie.setPref('chatAndUsers', userAndChat);\n      $('#users, .sticky-container')\n          .toggleClass('chatAndUsers popup-show stickyUsers', userAndChat);\n      $('#chatbox').toggleClass('chatAndUsersChat', userAndChat);\n    },\n    hide() {\n      // decide on hide logic based on chat window being maximized or not\n      if ($('#options-stickychat').prop('checked')) {\n        this.stickToScreen();\n        $('#options-stickychat').prop('checked', false);\n      } else {\n        $('#chatcounter').text('0');\n        $('#chaticon').addClass('visible');\n        $('#chatbox').removeClass('visible');\n      }\n    },\n    scrollDown(force) {\n      if ($('#chatbox').hasClass('visible')) {\n        if (force || !this.lastMessage || !this.lastMessage.position() ||\n            this.lastMessage.position().top < ($('#chattext').outerHeight() + 20)) {\n          // if we use a slow animate here we can have a race condition\n          // when a users focus can not be moved away from the last message recieved.\n          $('#chattext').animate(\n              {scrollTop: $('#chattext')[0].scrollHeight},\n              {duration: 400, queue: false});\n          this.lastMessage = $('#chattext > p').eq(-1);\n        }\n      }\n    },\n    send() {\n      const text = $('#chatinput').val();\n      if (text.replace(/\\s+/, '').length === 0) return;\n      this._pad.collabClient.sendMessage({type: 'CHAT_MESSAGE', text});\n      $('#chatinput').val('');\n    },\n    addMessage(msg, increment, isHistoryAdd) {\n      // correct the time\n      msg.time += this._pad.clientTimeOffset;\n\n      // create the time string\n      let minutes = `${new Date(msg.time).getMinutes()}`;\n      let hours = `${new Date(msg.time).getHours()}`;\n      if (minutes.length === 1) minutes = `0${minutes}`;\n      if (hours.length === 1) hours = `0${hours}`;\n      const timeStr = `${hours}:${minutes}`;\n\n      // create the authorclass\n      if (!msg.userId) {\n        /*\n         * If, for a bug or a database corruption, the message coming from the\n         * server does not contain the userId field (see for example #3731),\n         * let's be defensive and replace it with \"unknown\".\n         */\n        msg.userId = 'unknown';\n        console.warn(\n            'The \"userId\" field of a chat message coming from the server was not present. ' +\n            'Replacing with \"unknown\". This may be a bug or a database corruption.');\n      }\n\n      msg.userId = padutils.escapeHtml(msg.userId);\n      const authorClass = `author-${msg.userId.replace(/[^a-y0-9]/g, (c) => {\n        if (c === '.') return '-';\n        return `z${c.charCodeAt(0)}z`;\n      })}`;\n\n      const text = padutils.escapeHtmlWithClickableLinks(msg.text, '_blank');\n\n      const authorName = msg.userName == null ? html10n.get('pad.userlist.unnamed')\n        : padutils.escapeHtml(msg.userName);\n\n      // the hook args\n      const ctx = {\n        authorName,\n        author: msg.userId,\n        text,\n        sticky: false,\n        timestamp: msg.time,\n        timeStr,\n        duration: 4000,\n      };\n\n      // is the users focus already in the chatbox?\n      const alreadyFocused = $('#chatinput').is(':focus');\n\n      // does the user already have the chatbox open?\n      const chatOpen = $('#chatbox').hasClass('visible');\n\n      // does this message contain this user's name? (is the curretn user mentioned?)\n      const myName = $('#myusernameedit').val();\n      const wasMentioned =\n          text.toLowerCase().indexOf(myName.toLowerCase()) !== -1 && myName !== 'undefined';\n\n      // If the user was mentioned, make the message sticky\n      if (wasMentioned && !alreadyFocused && !isHistoryAdd && !chatOpen) {\n        chatMentions++;\n        Tinycon.setBubble(chatMentions);\n        ctx.sticky = true;\n      }\n\n      // Call chat message hook\n      hooks.aCallAll('chatNewMessage', ctx, () => {\n        const html =\n            `<p data-authorId='${msg.userId}' class='${authorClass}'><b>${authorName}:</b>` +\n            `<span class='time ${authorClass}'>${ctx.timeStr}</span> ${ctx.text}</p>`;\n        if (isHistoryAdd) $(html).insertAfter('#chatloadmessagesbutton');\n        else $('#chattext').append(html);\n\n        // should we increment the counter??\n        if (increment && !isHistoryAdd) {\n          // Update the counter of unread messages\n          let count = Number($('#chatcounter').text());\n          count++;\n          $('#chatcounter').text(count);\n\n          if (!chatOpen && ctx.duration > 0) {\n            $.gritter.add({\n              // Note: ctx.authorName and ctx.text are already HTML-escaped.\n              text: $('<p>')\n                  .append($('<span>').addClass('author-name').html(ctx.authorName))\n                  .append(ctx.text),\n              sticky: ctx.sticky,\n              time: 5000,\n              position: 'bottom',\n              class_name: 'chat-gritter-msg',\n            });\n          }\n        }\n      });\n\n      // Clear the chat mentions when the user clicks on the chat input box\n      $('#chatinput').click(() => {\n        chatMentions = 0;\n        Tinycon.setBubble(0);\n      });\n      if (!isHistoryAdd) this.scrollDown();\n    },\n    init(pad) {\n      this._pad = pad;\n      $('#chatinput').on('keydown', (evt) => {\n        // If the event is Alt C or Escape & we're already in the chat menu\n        // Send the users focus back to the pad\n        if ((evt.altKey === true && evt.which === 67) || evt.which === 27) {\n          // If we're in chat already..\n          $(':focus').blur(); // required to do not try to remove!\n          padeditor.ace.focus(); // Sends focus back to pad\n          evt.preventDefault();\n          return false;\n        }\n      });\n\n      const self = this;\n      $('body:not(#chatinput)').on('keypress', function (evt) {\n        if (evt.altKey && evt.which === 67) {\n          // Alt c focuses on the Chat window\n          $(this).blur();\n          self.show();\n          $('#chatinput').focus();\n          evt.preventDefault();\n        }\n      });\n\n      $('#chatinput').keypress((evt) => {\n        // if the user typed enter, fire the send\n        if (evt.which === 13 || evt.which === 10) {\n          evt.preventDefault();\n          this.send();\n        }\n      });\n\n      // initial messages are loaded in pad.js' _afterHandshake\n\n      $('#chatcounter').text(0);\n      $('#chatloadmessagesbutton').click(() => {\n        const start = Math.max(this.historyPointer - 20, 0);\n        const end = this.historyPointer;\n\n        if (start === end) return; // nothing to load\n\n        $('#chatloadmessagesbutton').css('display', 'none');\n        $('#chatloadmessagesball').css('display', 'block');\n\n        pad.collabClient.sendMessage({type: 'GET_CHAT_MESSAGES', start, end});\n        this.historyPointer = start;\n      });\n    },\n  };\n})();\n"], "filenames": ["src/static/js/chat.js"], "buggy_code_start_loc": [131], "buggy_code_end_loc": [131], "fixing_code_start_loc": [132], "fixing_code_end_loc": [133], "type": "CWE-79", "message": "A Cross-Site Scripting (XSS) issue in the chat component of Etherpad 1.8.13 allows remote attackers to inject arbitrary JavaScript or HTML by importing a crafted pad.", "other": {"cve": {"id": "CVE-2021-34817", "sourceIdentifier": "cve@mitre.org", "published": "2021-07-19T14:15:08.150", "lastModified": "2021-07-27T18:14:59.487", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A Cross-Site Scripting (XSS) issue in the chat component of Etherpad 1.8.13 allows remote attackers to inject arbitrary JavaScript or HTML by importing a crafted pad."}, {"lang": "es", "value": "Un problema de tipo Cross-Site Scripting (XSS) en el componente chat de Etherpad versi\u00f3n 1.8.13, permite a atacantes remotos inyectar JavaScript o HTML arbitrario al importar un pad dise\u00f1ado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:etherpad:etherpad:1.8.13:*:*:*:*:*:*:*", "matchCriteriaId": "A5B28B8D-9C9D-41A7-834C-2DEBE3862A6D"}]}]}], "references": [{"url": "https://blog.sonarsource.com/etherpad-code-execution-vulnerabilities", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://etherpad.org/#download", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/ether/etherpad-lite/commit/a7968115581e20ef47a533e030f59f830486bdfa", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ether/etherpad-lite/releases/tag/1.8.14", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ether/etherpad-lite/commit/a7968115581e20ef47a533e030f59f830486bdfa"}}