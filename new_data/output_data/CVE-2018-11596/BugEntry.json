{"buggy_code": ["/*\n * This file is part of Espruino, a JavaScript interpreter for Microcontrollers\n *\n * Copyright (C) 2013 Gordon Williams <gw@pur3.co.uk>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * ----------------------------------------------------------------------------\n * Variables\n * ----------------------------------------------------------------------------\n */\n#include \"jsvar.h\"\n#include \"jslex.h\"\n#include \"jsparse.h\"\n#include \"jswrap_json.h\"\n#include \"jsinteractive.h\"\n#include \"jswrapper.h\"\n#include \"jswrap_math.h\" // for jswrap_math_mod\n#include \"jswrap_object.h\" // for jswrap_object_toString\n#include \"jswrap_arraybuffer.h\" // for jsvNewTypedArray\n#include \"jswrap_dataview.h\" // for jsvNewDataViewWithData\n\n#ifdef DEBUG\n  /** When freeing, clear the references (nextChild/etc) in the JsVar.\n   * This means we can assert at the end of jsvFreePtr to make sure\n   * everything really is free. */\n  #define CLEAR_MEMORY_ON_FREE\n#endif\n\n/** Basically, JsVars are stored in one big array, so save the need for\n * lots of memory allocation. On Linux, the arrays are in blocks, so that\n * more blocks can be allocated. We can't use realloc on one big block as\n * this may change the address of vars that are already locked!\n *\n */\n\n#ifdef RESIZABLE_JSVARS\nJsVar **jsVarBlocks = 0;\nunsigned int jsVarsSize = 0;\n#define JSVAR_BLOCK_SIZE 4096\n#define JSVAR_BLOCK_SHIFT 12\n#else\nJsVar jsVars[JSVAR_CACHE_SIZE];\nunsigned int jsVarsSize = JSVAR_CACHE_SIZE;\n#endif\n\ntypedef enum {\n  MEM_NOT_BUSY,\n  MEMBUSY_SYSTEM,\n  MEMBUSY_GC\n} MemBusyType;\n\nvolatile bool touchedFreeList = false;\nvolatile JsVarRef jsVarFirstEmpty; ///< reference of first unused variable (variables are in a linked list)\nvolatile MemBusyType isMemoryBusy; ///< Are we doing garbage collection or similar, so can't access memory?\n\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n\nbool jsvIsRoot(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_ROOT; }\nbool jsvIsPin(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_PIN; }\nbool jsvIsSimpleInt(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_INTEGER; } // is just a very basic integer value\nbool jsvIsInt(const JsVar *v) { return v && ((v->flags&JSV_VARTYPEMASK)==JSV_INTEGER || (v->flags&JSV_VARTYPEMASK)==JSV_PIN || (v->flags&JSV_VARTYPEMASK)==JSV_NAME_INT || (v->flags&JSV_VARTYPEMASK)==JSV_NAME_INT_INT || (v->flags&JSV_VARTYPEMASK)==JSV_NAME_INT_BOOL); }\nbool jsvIsFloat(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_FLOAT; }\nbool jsvIsBoolean(const JsVar *v) { return v && ((v->flags&JSV_VARTYPEMASK)==JSV_BOOLEAN || (v->flags&JSV_VARTYPEMASK)==JSV_NAME_INT_BOOL); }\nbool jsvIsString(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)>=_JSV_STRING_START && (v->flags&JSV_VARTYPEMASK)<=_JSV_STRING_END; } ///< String, or a NAME too\nbool jsvIsBasicString(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)>=JSV_STRING_0 && (v->flags&JSV_VARTYPEMASK)<=JSV_STRING_MAX; } ///< Just a string (NOT a name)\nbool jsvIsStringExt(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)>=JSV_STRING_EXT_0 && (v->flags&JSV_VARTYPEMASK)<=JSV_STRING_EXT_MAX; } ///< The extra bits dumped onto the end of a string to store more data\nbool jsvIsFlatString(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_FLAT_STRING; }\nbool jsvIsNativeString(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_NATIVE_STRING; }\nbool jsvIsNumeric(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)>=_JSV_NUMERIC_START && (v->flags&JSV_VARTYPEMASK)<=_JSV_NUMERIC_END; }\nbool jsvIsFunction(const JsVar *v) { return v && ((v->flags&JSV_VARTYPEMASK)==JSV_FUNCTION || (v->flags&JSV_VARTYPEMASK)==JSV_FUNCTION_RETURN); }\nbool jsvIsFunctionReturn(const JsVar *v) { return v && ((v->flags&JSV_VARTYPEMASK)==JSV_FUNCTION_RETURN); } ///< Is this a function with an implicit 'return' at the start?\nbool jsvIsFunctionParameter(const JsVar *v) { return v && (v->flags&JSV_NATIVE) && jsvIsString(v); }\nbool jsvIsObject(const JsVar *v) { return v && (((v->flags&JSV_VARTYPEMASK)==JSV_OBJECT) || ((v->flags&JSV_VARTYPEMASK)==JSV_ROOT)); }\nbool jsvIsArray(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_ARRAY; }\nbool jsvIsArrayBuffer(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_ARRAYBUFFER; }\nbool jsvIsArrayBufferName(const JsVar *v) { return v && (v->flags&(JSV_VARTYPEMASK))==JSV_ARRAYBUFFERNAME; }\nbool jsvIsNative(const JsVar *v) { return v && (v->flags&JSV_NATIVE)!=0; }\nbool jsvIsNativeFunction(const JsVar *v) { return v && (v->flags&(JSV_NATIVE|JSV_VARTYPEMASK))==(JSV_NATIVE|JSV_FUNCTION); }\nbool jsvIsUndefined(const JsVar *v) { return v==0; }\nbool jsvIsNull(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_NULL; }\nbool jsvIsBasic(const JsVar *v) { return jsvIsNumeric(v) || jsvIsString(v);} ///< Is this *not* an array/object/etc\nbool jsvIsName(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)>=_JSV_NAME_START && (v->flags&JSV_VARTYPEMASK)<=_JSV_NAME_END; } ///< NAMEs are what's used to name a variable (it is not the data itself)\n/// Names with values have firstChild set to a value - AND NOT A REFERENCE\nbool jsvIsNameWithValue(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)>=_JSV_NAME_WITH_VALUE_START && (v->flags&JSV_VARTYPEMASK)<=_JSV_NAME_WITH_VALUE_END; }\nbool jsvIsNameInt(const JsVar *v) { return v && ((v->flags&JSV_VARTYPEMASK)==JSV_NAME_INT_INT || ((v->flags&JSV_VARTYPEMASK)>=JSV_NAME_STRING_INT_0 && (v->flags&JSV_VARTYPEMASK)<=JSV_NAME_STRING_INT_MAX)); }\nbool jsvIsNameIntInt(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_NAME_INT_INT; }\nbool jsvIsNameIntBool(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_NAME_INT_BOOL; }\n/// What happens when we access a variable that doesn't exist. We get a NAME where the next + previous siblings point to the object that may one day contain them\nbool jsvIsNewChild(const JsVar *v) { return jsvIsName(v) && jsvGetNextSibling(v) && jsvGetNextSibling(v)==jsvGetPrevSibling(v); }\n\n/// Are var.varData.ref.* (excl pad) used for data (so we expect them not to be empty)\nbool jsvIsRefUsedForData(const JsVar *v) { return jsvIsStringExt(v) || (jsvIsString(v)&&!jsvIsName(v)) ||  jsvIsFloat(v) || jsvIsNativeFunction(v) || jsvIsArrayBuffer(v) || jsvIsArrayBufferName(v); }\n\n/// Can the given variable be converted into an integer without loss of precision\nbool jsvIsIntegerish(const JsVar *v) { return jsvIsInt(v) || jsvIsPin(v) || jsvIsBoolean(v) || jsvIsNull(v); }\n\nbool jsvIsIterable(const JsVar *v) {\n  return jsvIsArray(v) || jsvIsObject(v) || jsvIsFunction(v) ||\n         jsvIsString(v) || jsvIsArrayBuffer(v);\n}\n\n\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n\n\n/** Return a pointer - UNSAFE for null refs.\n * This is effectively a Lock without locking! */\nstatic ALWAYS_INLINE JsVar *jsvGetAddressOf(JsVarRef ref) {\n  assert(ref);\n#ifdef RESIZABLE_JSVARS\n  JsVarRef t = ref-1;\n  return &jsVarBlocks[t>>JSVAR_BLOCK_SHIFT][t&(JSVAR_BLOCK_SIZE-1)];\n#else\n  return &jsVars[ref-1];\n#endif\n}\n\nJsVar *_jsvGetAddressOf(JsVarRef ref) {\n  return jsvGetAddressOf(ref);\n}\n\n#ifdef JSVARREF_PACKED_BITS\n#define JSVARREF_PACKED_BIT_MASK ((1U<<JSVARREF_PACKED_BITS)-1)\nJsVarRef jsvGetFirstChild(const JsVar *v) { return (JsVarRef)(v->varData.ref.firstChild | (((v->varData.ref.pack)&JSVARREF_PACKED_BIT_MASK))<<8); }\nJsVarRefSigned jsvGetFirstChildSigned(const JsVar *v) {\n  JsVarRefSigned r = (JsVarRefSigned)jsvGetFirstChild(v);\n  if (r & (1<<(JSVARREF_PACKED_BITS+7)))\n    r -= 1<<(JSVARREF_PACKED_BITS+8);\n  return r;\n}\nJsVarRef jsvGetNextSibling(const JsVar *v) { return (JsVarRef)(v->varData.ref.nextSibling | (((v->varData.ref.pack >> (JSVARREF_PACKED_BITS*2))&JSVARREF_PACKED_BIT_MASK))<<8); }\nJsVarRef jsvGetPrevSibling(const JsVar *v) { return (JsVarRef)(v->varData.ref.prevSibling | (((v->varData.ref.pack >> (JSVARREF_PACKED_BITS*3))&JSVARREF_PACKED_BIT_MASK))<<8); }\nvoid jsvSetFirstChild(JsVar *v, JsVarRef r) {\n  v->varData.ref.firstChild = (unsigned char)(r & 0xFF);\n  v->varData.ref.pack = (unsigned char)((v->varData.ref.pack & ~JSVARREF_PACKED_BIT_MASK) | ((r >> 8) & JSVARREF_PACKED_BIT_MASK));\n}\nvoid jsvSetNextSibling(JsVar *v, JsVarRef r) {\n  v->varData.ref.nextSibling = (unsigned char)(r & 0xFF);\n  v->varData.ref.pack = (unsigned char)((v->varData.ref.pack & ~(JSVARREF_PACKED_BIT_MASK<<(JSVARREF_PACKED_BITS*2))) | (((r >> 8) & JSVARREF_PACKED_BIT_MASK) << (JSVARREF_PACKED_BITS*2)));\n}\nvoid jsvSetPrevSibling(JsVar *v, JsVarRef r) {\n  v->varData.ref.prevSibling = (unsigned char)(r & 0xFF);\n  v->varData.ref.pack = (unsigned char)((v->varData.ref.pack & ~(JSVARREF_PACKED_BIT_MASK<<(JSVARREF_PACKED_BITS*3))) | (((r >> 8) & JSVARREF_PACKED_BIT_MASK) << (JSVARREF_PACKED_BITS*3)));\n}\n/* lastchild stores the upper 2 bits in JsVarFlags because then STRING_EXT can use one more character! */\nJsVarRef jsvGetLastChild(const JsVar *v) {\n  return (JsVarRef)(v->varData.ref.lastChild | (((v->flags >> JSV_LASTCHILD_BIT_SHIFT)&JSVARREF_PACKED_BIT_MASK))<<8);\n}\nvoid jsvSetLastChild(JsVar *v, JsVarRef r) {\n  v->varData.ref.lastChild = (unsigned char)(r & 0xFF);\n  v->flags = (v->flags & ~JSV_LASTCHILD_BIT_MASK) | ((r >> 8) << JSV_LASTCHILD_BIT_SHIFT);\n}\n#endif\n\n\n// For debugging/testing ONLY - maximum # of vars we are allowed to use\nvoid jsvSetMaxVarsUsed(unsigned int size) {\n#ifdef RESIZABLE_JSVARS\n  assert(size < JSVAR_BLOCK_SIZE); // remember - this is only for DEBUGGING - as such it doesn't use multiple blocks\n#else\n  assert(size < JSVAR_CACHE_SIZE);\n#endif\n  jsVarsSize = size;\n}\n\n// maps the empty variables in...\nvoid jsvCreateEmptyVarList() {\n  assert(!isMemoryBusy);\n  isMemoryBusy = MEMBUSY_SYSTEM;\n  jsVarFirstEmpty = 0;\n  JsVar firstVar; // temporary var to simplify code in the loop below\n  jsvSetNextSibling(&firstVar, 0);\n  JsVar *lastEmpty = &firstVar;\n\n  JsVarRef i;\n  for (i=1;i<=jsVarsSize;i++) {\n    JsVar *var = jsvGetAddressOf(i);\n    if ((var->flags&JSV_VARTYPEMASK) == JSV_UNUSED) {\n      jsvSetNextSibling(lastEmpty, i);\n      lastEmpty = var;\n    } else if (jsvIsFlatString(var)) {\n      // skip over used blocks for flat strings\n      i = (JsVarRef)(i+jsvGetFlatStringBlocks(var));\n    }\n  }\n  jsvSetNextSibling(lastEmpty, 0);\n  jsVarFirstEmpty = jsvGetNextSibling(&firstVar);\n  isMemoryBusy = MEM_NOT_BUSY;\n}\n\n/* Removes the empty variable counter, cleaving clear runs of 0s\n where no data resides. This helps if compressing the variables\n for storage. */\nvoid jsvClearEmptyVarList() {\n  assert(!isMemoryBusy);\n  isMemoryBusy = MEMBUSY_SYSTEM;\n  jsVarFirstEmpty = 0;\n  JsVarRef i;\n  for (i=1;i<=jsVarsSize;i++) {\n    JsVar *var = jsvGetAddressOf(i);\n    if ((var->flags&JSV_VARTYPEMASK) == JSV_UNUSED) {\n      // completely zero it (JSV_UNUSED==0, so it still stays the same)\n      memset((void*)var,0,sizeof(JsVar));\n    } else if (jsvIsFlatString(var)) {\n      // skip over used blocks for flat strings\n      i = (JsVarRef)(i+jsvGetFlatStringBlocks(var));\n    }\n  }\n  isMemoryBusy = MEM_NOT_BUSY;\n}\n\nvoid jsvSoftInit() {\n  jsvCreateEmptyVarList();\n}\n\nvoid jsvSoftKill() {\n  jsvClearEmptyVarList();\n}\n\n/** This links all JsVars together, so we can have our nice\n * linked list of free JsVars. It returns the ref of the first\n * item - that we should set jsVarFirstEmpty to (if it is 0) */\nstatic JsVarRef jsvInitJsVars(JsVarRef start, unsigned int count) {\n  JsVarRef i;\n  for (i=start;i<start+count;i++) {\n    JsVar *v = jsvGetAddressOf(i);\n    v->flags = JSV_UNUSED;\n    // v->locks = 0; // locks is 0 anyway because it is stored in flags\n    jsvSetNextSibling(v, (JsVarRef)(i+1)); // link to next\n  }\n  jsvSetNextSibling(jsvGetAddressOf((JsVarRef)(start+count-1)), (JsVarRef)0); // set the final one to 0\n  return start;\n}\n\nvoid jsvInit() {\n#ifdef RESIZABLE_JSVARS\n  jsVarsSize = JSVAR_BLOCK_SIZE;\n  jsVarBlocks = malloc(sizeof(JsVar*)); // just 1\n  jsVarBlocks[0] = malloc(sizeof(JsVar) * JSVAR_BLOCK_SIZE);\n#endif\n\n  jsVarFirstEmpty = jsvInitJsVars(1/*first*/, jsVarsSize);\n  jsvSoftInit();\n}\n\nvoid jsvKill() {\n#ifdef RESIZABLE_JSVARS\n  unsigned int i;\n  for (i=0;i<jsVarsSize>>JSVAR_BLOCK_SHIFT;i++)\n    free(jsVarBlocks[i]);\n  free(jsVarBlocks);\n  jsVarBlocks = 0;\n  jsVarsSize = 0;\n#endif\n}\n\n/** Find or create the ROOT variable item - used mainly\n * if recovering from a saved state. */\nJsVar *jsvFindOrCreateRoot() {\n  JsVarRef i;\n  for (i=1;i<=jsVarsSize;i++)\n    if (jsvIsRoot(jsvGetAddressOf(i)))\n      return jsvLock(i);\n\n  return jsvRef(jsvNewWithFlags(JSV_ROOT));\n}\n\n/// Get number of memory records (JsVars) used\nunsigned int jsvGetMemoryUsage() {\n  unsigned int usage = 0;\n  unsigned int i;\n  for (i=1;i<=jsVarsSize;i++) {\n    JsVar *v = jsvGetAddressOf((JsVarRef)i);\n    if ((v->flags&JSV_VARTYPEMASK) != JSV_UNUSED) {\n      usage++;\n      if (jsvIsFlatString(v)) {\n        unsigned int b = (unsigned int)jsvGetFlatStringBlocks(v);\n        i+=b;\n        usage+=b;\n      }\n    }\n  }\n  return usage;\n}\n\n/// Get total amount of memory records\nunsigned int jsvGetMemoryTotal() {\n  return jsVarsSize;\n}\n\n/// Try and allocate more memory - only works if RESIZABLE_JSVARS is defined\nvoid jsvSetMemoryTotal(unsigned int jsNewVarCount) {\n#ifdef RESIZABLE_JSVARS\n  assert(!isMemoryBusy);\n  if (jsNewVarCount <= jsVarsSize) return; // never allow us to have less!\n  isMemoryBusy = MEMBUSY_SYSTEM;\n  // When resizing, we just allocate a bunch more\n  unsigned int oldSize = jsVarsSize;\n  unsigned int oldBlockCount = jsVarsSize >> JSVAR_BLOCK_SHIFT;\n  unsigned int newBlockCount = (jsNewVarCount+JSVAR_BLOCK_SIZE-1) >> JSVAR_BLOCK_SHIFT;\n  jsVarsSize = newBlockCount << JSVAR_BLOCK_SHIFT;\n  // resize block table\n  jsVarBlocks = realloc(jsVarBlocks, sizeof(JsVar*)*newBlockCount);\n  // allocate more blocks\n  unsigned int i;\n  for (i=oldBlockCount;i<newBlockCount;i++)\n    jsVarBlocks[i] = malloc(sizeof(JsVar) * JSVAR_BLOCK_SIZE);\n  /** and now reset all the newly allocated vars. We know jsVarFirstEmpty\n   * is 0 (because jsiFreeMoreMemory returned 0) so we can just assign it.  */\n  assert(!jsVarFirstEmpty);\n  jsVarFirstEmpty = jsvInitJsVars(oldSize+1, jsVarsSize-oldSize);\n  // jsiConsolePrintf(\"Resized memory from %d blocks to %d\\n\", oldBlockCount, newBlockCount);\n  touchedFreeList = true;\n  isMemoryBusy = MEM_NOT_BUSY;\n#else\n  NOT_USED(jsNewVarCount);\n  assert(0);\n#endif\n}\n\nbool jsvMoreFreeVariablesThan(unsigned int vars) {\n  if (!vars) return false;\n  JsVarRef r = jsVarFirstEmpty;\n  while (r) {\n    if (!vars--) return true;\n    r = jsvGetNextSibling(jsvGetAddressOf(r));\n  }\n  return false;\n}\n\n/// Get whether memory is full or not\nbool jsvIsMemoryFull() {\n  return !jsVarFirstEmpty;\n}\n\n// Show what is still allocated, for debugging memory problems\nvoid jsvShowAllocated() {\n  JsVarRef i;\n  for (i=1;i<=jsVarsSize;i++) {\n    if ((jsvGetAddressOf(i)->flags&JSV_VARTYPEMASK) != JSV_UNUSED) {\n      jsiConsolePrintf(\"USED VAR #%d:\",i);\n      jsvTrace(jsvGetAddressOf(i), 2);\n    }\n  }\n}\n\nbool jsvHasCharacterData(const JsVar *v) {\n  return jsvIsString(v) || jsvIsStringExt(v);\n}\n\nbool jsvHasStringExt(const JsVar *v) {\n  return jsvIsString(v) || jsvIsStringExt(v);\n}\n\nbool jsvHasChildren(const JsVar *v) {\n  return jsvIsFunction(v) || jsvIsObject(v) || jsvIsArray(v) || jsvIsRoot(v);\n}\n\n/// Is this variable a type that uses firstChild to point to a single Variable (ie. it doesn't have multiple children)\nbool jsvHasSingleChild(const JsVar *v) {\n  return jsvIsArrayBuffer(v) ||\n      (jsvIsName(v) && !jsvIsNameWithValue(v));\n}\n\n/** Return the is the number of characters this one JsVar can contain, NOT string length (eg, a chain of JsVars)\n * This will return an invalid length when applied to Flat Strings */\nsize_t jsvGetMaxCharactersInVar(const JsVar *v) {\n  // see jsvCopy - we need to know about this in there too\n  if (jsvIsStringExt(v)) return JSVAR_DATA_STRING_MAX_LEN;\n  assert(jsvHasCharacterData(v));\n  if (jsvIsName(v)) return JSVAR_DATA_STRING_NAME_LEN;\n  return JSVAR_DATA_STRING_LEN;\n}\n\n/// This is the number of characters a JsVar can contain, NOT string length\nsize_t jsvGetCharactersInVar(const JsVar *v) {\n  unsigned int f = v->flags&JSV_VARTYPEMASK;\n  if (f == JSV_FLAT_STRING)\n    return (size_t)v->varData.integer;\n  if (f == JSV_NATIVE_STRING)\n    return (size_t)v->varData.nativeStr.len;\n  assert(f >= JSV_NAME_STRING_INT_0);\n  assert((JSV_NAME_STRING_INT_0 < JSV_NAME_STRING_0) &&\n         (JSV_NAME_STRING_0 < JSV_STRING_0) &&\n         (JSV_STRING_0 < JSV_STRING_EXT_0)); // this relies on ordering\n  if (f<=JSV_NAME_STRING_MAX) {\n    if (f<=JSV_NAME_STRING_INT_MAX)\n      return f-JSV_NAME_STRING_INT_0;\n    else\n      return f-JSV_NAME_STRING_0;\n  } else {\n    if (f<=JSV_STRING_MAX) return f-JSV_STRING_0;\n    assert(f <= JSV_STRING_EXT_MAX);\n    return f - JSV_STRING_EXT_0;\n  }\n}\n\n/// This is the number of characters a JsVar can contain, NOT string length\nvoid jsvSetCharactersInVar(JsVar *v, size_t chars) {\n  unsigned int f = v->flags&JSV_VARTYPEMASK;\n  assert(!(jsvIsFlatString(v) || jsvIsNativeString(v)));\n\n  JsVarFlags m = (JsVarFlags)(v->flags&~JSV_VARTYPEMASK);\n  assert(f >= JSV_NAME_STRING_INT_0);\n  assert((JSV_NAME_STRING_INT_0 < JSV_NAME_STRING_0) &&\n         (JSV_NAME_STRING_0 < JSV_STRING_0) &&\n         (JSV_STRING_0 < JSV_STRING_EXT_0)); // this relies on ordering\n  if (f<=JSV_NAME_STRING_MAX) {\n    assert(chars <= JSVAR_DATA_STRING_NAME_LEN);\n    if (f<=JSV_NAME_STRING_INT_MAX)\n      v->flags = (JsVarFlags)(m | (JSV_NAME_STRING_INT_0+chars));\n    else\n      v->flags = (JsVarFlags)(m | (JSV_NAME_STRING_0+chars));\n  } else {\n    if (f<=JSV_STRING_MAX) {\n      assert(chars <= JSVAR_DATA_STRING_LEN);\n      v->flags = (JsVarFlags)(m | (JSV_STRING_0+chars));\n    } else {\n      assert(chars <= JSVAR_DATA_STRING_MAX_LEN);\n      assert(f <= JSV_STRING_EXT_MAX);\n      v->flags = (JsVarFlags)(m | (JSV_STRING_EXT_0+chars));\n    }\n  }\n}\n\nvoid jsvResetVariable(JsVar *v, JsVarFlags flags) {\n  assert((v->flags&JSV_VARTYPEMASK) == JSV_UNUSED);\n  // make sure we clear all data...\n  /* Force a proper zeroing of all data. We don't use\n   * memset because that'd create a function call. This\n   * should just generate a bunch of STR instructions */\n  unsigned int i;\n  assert((sizeof(JsVar)&3) == 0); // must be a multiple of 4 in size\n  for (i=0;i<sizeof(JsVar)/sizeof(uint32_t);i++)\n    ((uint32_t*)v)[i] = 0;\n  // set flags\n  assert(!(flags & JSV_LOCK_MASK));\n  v->flags = flags | JSV_LOCK_ONE;\n}\n\nJsVar *jsvNewWithFlags(JsVarFlags flags) {\n  if (isMemoryBusy) {\n    jsErrorFlags |= JSERR_MEMORY_BUSY;\n    return 0;\n  }\n  JsVar *v = 0;\n  jshInterruptOff(); // to allow this to be used from an IRQ\n  if (jsVarFirstEmpty!=0) {\n    v = jsvGetAddressOf(jsVarFirstEmpty); // jsvResetVariable will lock\n    jsVarFirstEmpty = jsvGetNextSibling(v); // move our reference to the next in the fr\n    touchedFreeList = true;\n  }\n  jshInterruptOn();\n  if (v) {\n    assert(v->flags == JSV_UNUSED);\n    // Cope with IRQs/multi-threading when getting a new free variable\n /*   JsVarRef empty;\n    JsVarRef next;\n    JsVar *v;\n    do {\n      empty = jsVarFirstEmpty;\n      v = jsvGetAddressOf(empty); // jsvResetVariable will lock\n      next = jsvGetNextSibling(v); // move our reference to the next in the free list\n      touchedFreeList = true;\n    } while (!__sync_bool_compare_and_swap(&jsVarFirstEmpty, empty, next));\n    assert(v->flags == JSV_UNUSED);*/\n    jsvResetVariable(v, flags); // setup variable, and add one lock\n    // return pointer\n    return v;\n  }\n  jsErrorFlags |= JSERR_LOW_MEMORY;\n  /* If we're calling from an IRQ, do NOT try and do fancy\n   * stuff to free memory */\n  if (jshIsInInterrupt()) {\n    return 0;\n  }\n  /* we don't have memory - second last hope - run garbage collector */\n  if (jsvGarbageCollect()) {\n    return jsvNewWithFlags(flags); // if it freed something, continue\n  }\n  /* we don't have memory - last hope - ask jsInteractive to try and free some it\n   may have kicking around */\n  if (jsiFreeMoreMemory()) {\n    return jsvNewWithFlags(flags);\n  }\n  /* We couldn't claim any more memory by Garbage collecting... */\n#ifdef RESIZABLE_JSVARS\n  jsvSetMemoryTotal(jsVarsSize*2);\n  return jsvNewWithFlags(flags);\n#else\n  // On a micro, we're screwed.\n  jsErrorFlags |= JSERR_MEMORY;\n  jspSetInterrupted(true);\n  return 0;\n#endif\n}\n\nstatic NO_INLINE void jsvFreePtrInternal(JsVar *var) {\n  assert(jsvGetLocks(var)==0);\n  var->flags = JSV_UNUSED;\n  // add this to our free list\n  jshInterruptOff(); // to allow this to be used from an IRQ\n  jsvSetNextSibling(var, jsVarFirstEmpty);\n  jsVarFirstEmpty = jsvGetRef(var);\n  touchedFreeList = true;\n  jshInterruptOn();\n}\n\nALWAYS_INLINE void jsvFreePtr(JsVar *var) {\n  /* To be here, we're not supposed to be part of anything else. If\n   * we were, we'd have been freed by jsvGarbageCollect */\n  assert((!jsvGetNextSibling(var) && !jsvGetPrevSibling(var)) || // check that next/prevSibling are not set\n      jsvIsRefUsedForData(var) ||  // UNLESS we're part of a string and nextSibling/prevSibling are used for string data\n      (jsvIsName(var) && (jsvGetNextSibling(var)==jsvGetPrevSibling(var)))); // UNLESS we're signalling that we're jsvIsNewChild\n\n  // Names that Link to other things\n  if (jsvIsNameWithValue(var)) {\n#ifdef CLEAR_MEMORY_ON_FREE\n    jsvSetFirstChild(var, 0); // it just contained random data - zero it\n#endif // CLEAR_MEMORY_ON_FREE\n  } else if (jsvHasSingleChild(var)) {\n    if (jsvGetFirstChild(var)) {\n      JsVar *child = jsvLock(jsvGetFirstChild(var));\n      jsvUnRef(child);\n#ifdef CLEAR_MEMORY_ON_FREE\n      jsvSetFirstChild(var, 0); // unlink the child\n#endif // CLEAR_MEMORY_ON_FREE\n      jsvUnLock(child); // unlock should trigger a free\n    }\n  }\n  /* No else, because a String Name may have a single child, but\n   * also StringExts  */\n\n  /* Now, free children - see jsvar.h comments for how! */\n  if (jsvHasStringExt(var)) {\n    // Free the string without recursing\n    JsVarRef stringDataRef = jsvGetLastChild(var);\n#ifdef CLEAR_MEMORY_ON_FREE\n    jsvSetLastChild(var, 0);\n#endif // CLEAR_MEMORY_ON_FREE\n    while (stringDataRef) {\n      JsVar *child = jsvGetAddressOf(stringDataRef);\n      assert(jsvIsStringExt(child));\n      stringDataRef = jsvGetLastChild(child);\n      jsvFreePtrInternal(child);\n    }\n    // We might be a flat string\n    if (jsvIsFlatString(var)) {\n      // in which case we need to free all the blocks.\n      size_t count = jsvGetFlatStringBlocks(var);\n      JsVarRef i = (JsVarRef)(jsvGetRef(var)+count);\n      // do it in reverse, so the free list ends up in kind of the right order\n      while (count--) {\n        JsVar *p = jsvGetAddressOf(i--);\n        p->flags = JSV_UNUSED; // set locks to 0 so the assert in jsvFreePtrInternal doesn't get fed up\n        jsvFreePtrInternal(p);\n      }\n    } else if (jsvIsBasicString(var)) {\n#ifdef CLEAR_MEMORY_ON_FREE\n      jsvSetFirstChild(var, 0); // firstchild could have had string data in\n#endif // CLEAR_MEMORY_ON_FREE\n    }\n\n  }\n  /* NO ELSE HERE - because jsvIsNewChild stuff can be for Names, which\n    can be ints or strings */\n\n  if (jsvHasChildren(var)) {\n    JsVarRef childref = jsvGetFirstChild(var);\n#ifdef CLEAR_MEMORY_ON_FREE\n    jsvSetFirstChild(var, 0);\n    jsvSetLastChild(var, 0);\n#endif // CLEAR_MEMORY_ON_FREE\n    while (childref) {\n      JsVar *child = jsvLock(childref);\n      assert(jsvIsName(child));\n      childref = jsvGetNextSibling(child);\n      jsvSetPrevSibling(child, 0);\n      jsvSetNextSibling(child, 0);\n      jsvUnRef(child);\n      jsvUnLock(child);\n    }\n  } else {\n#ifdef CLEAR_MEMORY_ON_FREE\n#if JSVARREF_SIZE==1\n    assert(jsvIsFloat(var) || !jsvGetFirstChild(var));\n    assert(jsvIsFloat(var) || !jsvGetLastChild(var));\n#else\n    assert(!jsvGetFirstChild(var)); // strings use firstchild now as well\n    assert(!jsvGetLastChild(var));\n#endif\n#endif // CLEAR_MEMORY_ON_FREE\n    if (jsvIsName(var)) {\n      assert(jsvGetNextSibling(var)==jsvGetPrevSibling(var)); // the case for jsvIsNewChild\n      if (jsvGetNextSibling(var)) {\n        jsvUnRefRef(jsvGetNextSibling(var));\n        jsvUnRefRef(jsvGetPrevSibling(var));\n      }\n    }\n  }\n\n  // free!\n  jsvFreePtrInternal(var);\n}\n\n/// Get a reference from a var - SAFE for null vars\nALWAYS_INLINE JsVarRef jsvGetRef(JsVar *var) {\n  if (!var) return 0;\n#ifdef RESIZABLE_JSVARS\n  unsigned int i, c = jsVarsSize>>JSVAR_BLOCK_SHIFT;\n  for (i=0;i<c;i++) {\n    if (var>=jsVarBlocks[i] && var<&jsVarBlocks[i][JSVAR_BLOCK_SIZE]) {\n      JsVarRef r = (JsVarRef)(1 + (i<<JSVAR_BLOCK_SHIFT) + (var - jsVarBlocks[i]));\n      return r;\n    }\n  }\n  return 0;\n#else\n  return (JsVarRef)(1 + (var - jsVars));\n#endif\n}\n\n/// Lock this reference and return a pointer - UNSAFE for null refs\nALWAYS_INLINE JsVar *jsvLock(JsVarRef ref) {\n  JsVar *var = jsvGetAddressOf(ref);\n  //var->locks++;\n  assert(jsvGetLocks(var) < JSV_LOCK_MAX);\n  var->flags += JSV_LOCK_ONE;\n#ifdef DEBUG\n  if (jsvGetLocks(var)==0) {\n    jsError(\"Too many locks to Variable!\");\n    //jsPrint(\"Var #\");jsPrintInt(ref);jsPrint(\"\\n\");\n  }\n#endif\n  return var;\n}\n\n/// Lock this pointer and return a pointer - UNSAFE for null pointer\nALWAYS_INLINE JsVar *jsvLockAgain(JsVar *var) {\n  assert(var);\n  assert(jsvGetLocks(var) < JSV_LOCK_MAX);\n  var->flags += JSV_LOCK_ONE;\n  return var;\n}\n\n/// Lock this pointer and return a pointer - UNSAFE for null pointer\nALWAYS_INLINE JsVar *jsvLockAgainSafe(JsVar *var) {\n  return var ? jsvLockAgain(var) : 0;\n}\n\n// CALL ONLY FROM jsvUnlock\n// jsvGetLocks(var) must == 0\nstatic NO_INLINE void jsvUnLockFreeIfNeeded(JsVar *var) {\n  assert(jsvGetLocks(var) == 0);\n  /* if we know we're free, then we can just free this variable right now.\n   * Loops of variables are handled by the Garbage Collector.\n   * Note: we checked locks already in jsvUnLock as it is fastest to check */\n  if (jsvGetRefs(var) == 0 &&\n      jsvHasRef(var) &&\n      (var->flags&JSV_VARTYPEMASK)!=JSV_UNUSED) { // we might be in an IRQ now, with GC in the main thread. If so, don't free!\n    jsvFreePtr(var);\n  }\n}\n\n\n/// Unlock this variable - this is SAFE for null variables\nALWAYS_INLINE void jsvUnLock(JsVar *var) {\n  if (!var) return;\n  assert(jsvGetLocks(var)>0);\n  var->flags -= JSV_LOCK_ONE;\n  // Now see if we can properly free the data\n  // Note: we check locks first as they are already in a register\n  if ((var->flags & JSV_LOCK_MASK) == 0) jsvUnLockFreeIfNeeded(var);\n}\n\n/// Unlock 2 variables in one go\nvoid jsvUnLock2(JsVar *var1, JsVar *var2) {\n  jsvUnLock(var1);\n  jsvUnLock(var2);\n}\n/// Unlock 3 variables in one go\nvoid jsvUnLock3(JsVar *var1, JsVar *var2, JsVar *var3) {\n  jsvUnLock(var1);\n  jsvUnLock(var2);\n  jsvUnLock(var3);\n}\n/// Unlock 4 variables in one go\nvoid jsvUnLock4(JsVar *var1, JsVar *var2, JsVar *var3, JsVar *var4) {\n  jsvUnLock(var1);\n  jsvUnLock(var2);\n  jsvUnLock(var3);\n  jsvUnLock(var4);\n}\n\n/// Unlock an array of variables\nNO_INLINE void jsvUnLockMany(unsigned int count, JsVar **vars) {\n  while (count) jsvUnLock(vars[--count]);\n}\n\n/// Reference - set this variable as used by something\nJsVar *jsvRef(JsVar *var) {\n  assert(var && jsvHasRef(var));\n  jsvSetRefs(var, (JsVarRefCounter)(jsvGetRefs(var)+1));\n  assert(jsvGetRefs(var));\n  return var;\n}\n\n/// Unreference - set this variable as not used by anything\nvoid jsvUnRef(JsVar *var) {\n  assert(var && jsvGetRefs(var)>0 && jsvHasRef(var));\n  jsvSetRefs(var, (JsVarRefCounter)(jsvGetRefs(var)-1));\n}\n\n/// Helper fn, Reference - set this variable as used by something\nJsVarRef jsvRefRef(JsVarRef ref) {\n  JsVar *v;\n  assert(ref);\n  v = jsvLock(ref);\n  assert(!jsvIsStringExt(v));\n  jsvRef(v);\n  jsvUnLock(v);\n  return ref;\n}\n\n/// Helper fn, Unreference - set this variable as not used by anything\nJsVarRef jsvUnRefRef(JsVarRef ref) {\n  JsVar *v;\n  assert(ref);\n  v = jsvLock(ref);\n  assert(!jsvIsStringExt(v));\n  jsvUnRef(v);\n  jsvUnLock(v);\n  return 0;\n}\n\nJsVar *jsvNewFlatStringOfLength(unsigned int byteLength) {\n  if (isMemoryBusy) {\n    jsErrorFlags |= JSERR_MEMORY_BUSY;\n    return 0;\n  }\n  // Work out how many blocks we need. One for the header, plus some for the characters\n  size_t requiredBlocks = 1 + ((byteLength+sizeof(JsVar)-1) / sizeof(JsVar));\n\n  JsVar *flatString = 0;\n\n  /* Now try and find a contiguous set of 'requiredBlocks' blocks by\n  searching the free list. This can be done as long as nobody's\n  messed with the free list in the mean time (which we check for with\n  touchedFreeList). If someone has messed with it, we restart.*/\n  bool memoryTouched = true;\n  while (memoryTouched) {\n    memoryTouched = false;\n    touchedFreeList = false;\n    JsVarRef beforeStartBlock = 0;\n    JsVarRef curr = jsVarFirstEmpty;\n    JsVarRef startBlock = curr;\n    unsigned int blockCount = 1;\n    while (curr && !touchedFreeList) {\n      JsVar *currVar = jsvGetAddressOf(curr);\n      JsVarRef next = jsvGetNextSibling(currVar);\n#ifdef RESIZABLE_JSVARS\n      if (next && jsvGetAddressOf(next)==currVar+1) {\n#else\n      if (next == curr+1) {\n#endif\n        blockCount++;\n        if (blockCount>=requiredBlocks) {\n          JsVar *nextVar = jsvGetAddressOf(next);\n          JsVarRef nextFree = jsvGetNextSibling(nextVar);\n          jshInterruptOff();\n          if (!touchedFreeList) {\n            // we're there! Quickly re-link free list\n            if (beforeStartBlock) {\n              jsvSetNextSibling(jsvGetAddressOf(beforeStartBlock),nextFree);\n            } else {\n              jsVarFirstEmpty = nextFree;\n            }\n            flatString = jsvGetAddressOf(startBlock);\n            // Set up the header block (including one lock)\n            jsvResetVariable(flatString, JSV_FLAT_STRING);\n            flatString->varData.integer = (JsVarInt)byteLength;\n          }\n          jshInterruptOn();\n          // if success, break out!\n          if (flatString) break;\n        }\n      } else {\n        // this block is not immediately after the last - restart run\n        blockCount = 1;\n        beforeStartBlock = curr;\n        startBlock = next;\n      }\n      // move to next!\n      curr = next;\n    }\n    // memory list has been touched - restart!\n    if (touchedFreeList) {\n      memoryTouched = true;\n    }\n  }\n\n  /* Nope... we couldn't find a free string. It could be because\n   * the free list is fragmented, so GCing might well fix it - which\n   * we'll try. */\n  if (!flatString) {\n    if (jsvGarbageCollect())\n      return jsvNewFlatStringOfLength(byteLength);\n    return 0;\n  }\n\n  /* We now have the string! All that's left is to clear it,\n   * which we can do outside of an IRQ */\n  // clear data\n  memset((char*)&flatString[1], 0, sizeof(JsVar)*(requiredBlocks-1));\n  /* We did mess with the free list - set it here in case we\n  are trying to create a flat string in an IRQ while trying to\n  make one outside the IRQ too */\n  touchedFreeList = true;\n  // and we're done\n  return flatString;\n}\n\nJsVar *jsvNewFromString(const char *str) {\n  // Create a var\n  JsVar *first = jsvNewWithFlags(JSV_STRING_0);\n  if (!first) return 0; // out of memory\n  // Now we copy the string, but keep creating new jsVars if we go\n  // over the end\n  JsVar *var = jsvLockAgain(first);\n  while (*str) {\n    // copy data in\n    size_t i, l = jsvGetMaxCharactersInVar(var);\n    for (i=0;i<l && *str;i++)\n      var->varData.str[i] = *(str++);\n    // we already set the variable data to 0, so no need for adding one\n\n    // we've stopped if the string was empty\n    jsvSetCharactersInVar(var, i);\n\n    // if there is still some left, it's because we filled up our var...\n    // make a new one, link it in, and unlock the old one.\n    if (*str) {\n      JsVar *next = jsvNewWithFlags(JSV_STRING_EXT_0);\n      if (!next) {\n        // Truncating string as not enough memory\n        jsvUnLock(var);\n        return first;\n      }\n      // we don't ref, because  StringExts are never reffed as they only have one owner (and ALWAYS have an owner)\n      jsvSetLastChild(var, jsvGetRef(next));\n      jsvUnLock(var);\n      var = next;\n    }\n  }\n  jsvUnLock(var);\n  // return\n  return first;\n}\n\nJsVar *jsvNewStringOfLength(unsigned int byteLength, const char *initialData) {\n  // if string large enough, try and make a flat string instead\n  if (byteLength > JSV_FLAT_STRING_BREAK_EVEN) {\n    JsVar *v = jsvNewFlatStringOfLength(byteLength);\n    if (v) {\n      if (initialData) jsvSetString(v, initialData, byteLength);\n      return v;\n    }\n  }\n  // Create a var\n  JsVar *first = jsvNewWithFlags(JSV_STRING_0);\n  if (!first) return 0; // out of memory, will have already set flag\n  // Now keep creating enough new jsVars\n  JsVar *var = jsvLockAgain(first);\n  while (true) {\n    // copy data in\n    unsigned int l = (unsigned int)jsvGetMaxCharactersInVar(var);\n    if (l>=byteLength) {\n      if (initialData)\n        memcpy(var->varData.str, initialData, byteLength);\n      // we've got enough\n      jsvSetCharactersInVar(var, byteLength);\n      break;\n    } else {\n      if (initialData) {\n        memcpy(var->varData.str, initialData, l);\n        initialData+=l;\n      }\n      // We need more\n      jsvSetCharactersInVar(var, l);\n      byteLength -= l;\n      // Make a new one, link it in, and unlock the old one.\n      JsVar *next = jsvNewWithFlags(JSV_STRING_EXT_0);\n      if (!next) break; // out of memory, will have already set flag\n      // we don't ref, because  StringExts are never reffed as they only have one owner (and ALWAYS have an owner)\n      jsvSetLastChild(var, jsvGetRef(next));\n      jsvUnLock(var);\n      var = next;\n    }\n  }\n  jsvUnLock(var);\n  // return\n  return first;\n}\n\nJsVar *jsvNewFromInteger(JsVarInt value) {\n  JsVar *var = jsvNewWithFlags(JSV_INTEGER);\n  if (!var) return 0; // no memory\n  var->varData.integer = value;\n  return var;\n}\nJsVar *jsvNewFromBool(bool value) {\n  JsVar *var = jsvNewWithFlags(JSV_BOOLEAN);\n  if (!var) return 0; // no memory\n  var->varData.integer = value ? 1 : 0;\n  return var;\n}\nJsVar *jsvNewFromFloat(JsVarFloat value) {\n  JsVar *var = jsvNewWithFlags(JSV_FLOAT);\n  if (!var) return 0; // no memory\n  var->varData.floating = value;\n  return var;\n}\nJsVar *jsvNewFromLongInteger(long long value) {\n  if (value>=-2147483648LL && value<=2147483647LL)\n    return jsvNewFromInteger((JsVarInt)value);\n  else\n    return jsvNewFromFloat((JsVarFloat)value);\n}\n\n\nJsVar *jsvMakeIntoVariableName(JsVar *var, JsVar *valueOrZero) {\n  if (!var) return 0;\n  assert(jsvGetRefs(var)==0); // make sure it's unused\n  assert(jsvIsSimpleInt(var) || jsvIsString(var));\n  JsVarFlags varType = (var->flags & JSV_VARTYPEMASK);\n  if (varType==JSV_INTEGER) {\n    int t = JSV_NAME_INT;\n    if ((jsvIsInt(valueOrZero) || jsvIsBoolean(valueOrZero)) && !jsvIsPin(valueOrZero)) {\n      JsVarInt v = valueOrZero->varData.integer;\n      if (v>=JSVARREF_MIN && v<=JSVARREF_MAX) {\n        t = jsvIsInt(valueOrZero) ? JSV_NAME_INT_INT : JSV_NAME_INT_BOOL;\n        jsvSetFirstChild(var, (JsVarRef)v);\n        valueOrZero = 0;\n      }\n    }\n    var->flags = (JsVarFlags)(var->flags & ~JSV_VARTYPEMASK) | t;\n  } else if (varType>=_JSV_STRING_START && varType<=_JSV_STRING_END) {\n    if (jsvGetCharactersInVar(var) > JSVAR_DATA_STRING_NAME_LEN) {\n      /* Argh. String is too large to fit in a JSV_NAME! We must chomp make\n       * new STRINGEXTs to put the data in\n       */\n      JsvStringIterator it;\n      jsvStringIteratorNew(&it, var, JSVAR_DATA_STRING_NAME_LEN);\n      JsVar *startExt = jsvNewWithFlags(JSV_STRING_EXT_0);\n      JsVar *ext = jsvLockAgainSafe(startExt);\n      size_t nChars = 0;\n      while (ext && jsvStringIteratorHasChar(&it)) {\n        if (nChars >= JSVAR_DATA_STRING_MAX_LEN) {\n          jsvSetCharactersInVar(ext, nChars);\n          JsVar *ext2 = jsvNewWithFlags(JSV_STRING_EXT_0);\n          if (ext2) {\n            jsvSetLastChild(ext, jsvGetRef(ext2));\n          }\n          jsvUnLock(ext);\n          ext = ext2;\n          nChars = 0;\n        }\n        ext->varData.str[nChars++] = jsvStringIteratorGetChar(&it);\n        jsvStringIteratorNext(&it);\n      }\n      jsvStringIteratorFree(&it);\n      if (ext) {\n        jsvSetCharactersInVar(ext, nChars);\n        jsvUnLock(ext);\n      }\n      jsvSetCharactersInVar(var, JSVAR_DATA_STRING_NAME_LEN);\n      // Free any old stringexts\n      JsVarRef oldRef = jsvGetLastChild(var);\n      while (oldRef) {\n        JsVar *v = jsvGetAddressOf(oldRef);\n        oldRef = jsvGetLastChild(v);\n        jsvFreePtrInternal(v);\n      }\n      // set up new stringexts\n      jsvSetLastChild(var, jsvGetRef(startExt));\n      jsvSetNextSibling(var, 0);\n      jsvSetPrevSibling(var, 0);\n      jsvSetFirstChild(var, 0);\n      jsvUnLock(startExt);\n    }\n\n    size_t t = JSV_NAME_STRING_0;\n    if (jsvIsInt(valueOrZero) && !jsvIsPin(valueOrZero)) {\n      JsVarInt v = valueOrZero->varData.integer;\n      if (v>=JSVARREF_MIN && v<=JSVARREF_MAX) {\n        t = JSV_NAME_STRING_INT_0;\n        jsvSetFirstChild(var, (JsVarRef)v);\n        valueOrZero = 0;\n      }\n    } else\n      jsvSetFirstChild(var, 0);\n    var->flags = (var->flags & (JsVarFlags)~JSV_VARTYPEMASK) | (t+jsvGetCharactersInVar(var));\n  } else assert(0);\n\n  if (valueOrZero)\n    jsvSetFirstChild(var, jsvGetRef(jsvRef(valueOrZero)));\n  return var;\n}\n\nvoid jsvMakeFunctionParameter(JsVar *v) {\n  assert(jsvIsString(v));\n  if (!jsvIsName(v)) jsvMakeIntoVariableName(v,0);\n  v->flags = (JsVarFlags)(v->flags | JSV_NATIVE);\n}\n\nJsVar *jsvNewFromPin(int pin) {\n  JsVar *v = jsvNewFromInteger((JsVarInt)pin);\n  if (v) {\n    v->flags = (JsVarFlags)((v->flags & ~JSV_VARTYPEMASK) | JSV_PIN);\n  }\n  return v;\n}\n\nJsVar *jsvNewObject() {\n  return jsvNewWithFlags(JSV_OBJECT);\n}\n\nJsVar *jsvNewEmptyArray() {\n  return jsvNewWithFlags(JSV_ARRAY);\n}\n\n/// Create an array containing the given elements\nJsVar *jsvNewArray(JsVar **elements, int elementCount) {\n  JsVar *arr = jsvNewEmptyArray();\n  if (!arr) return 0;\n  int i;\n  for (i=0;i<elementCount;i++)\n    jsvArrayPush(arr, elements[i]);\n  return arr;\n}\n\nJsVar *jsvNewNativeFunction(void (*ptr)(void), unsigned short argTypes) {\n  JsVar *func = jsvNewWithFlags(JSV_FUNCTION | JSV_NATIVE);\n  if (!func) return 0;\n  func->varData.native.ptr = ptr;\n  func->varData.native.argTypes = argTypes;\n  return func;\n}\n\nJsVar *jsvNewNativeString(char *ptr, size_t len) {\n  if (len>JSV_NATIVE_STR_MAX_LENGTH) len=JSV_NATIVE_STR_MAX_LENGTH; // crop string to what we can store in nativeStr.len\n  JsVar *str = jsvNewWithFlags(JSV_NATIVE_STRING);\n  if (!str) return 0;\n  str->varData.nativeStr.ptr = ptr;\n  str->varData.nativeStr.len = (uint16_t)len;\n  return str;\n}\n\nvoid *jsvGetNativeFunctionPtr(const JsVar *function) {\n  /* see descriptions in jsvar.h. If we have a child called JSPARSE_FUNCTION_CODE_NAME\n   * then we execute code straight from that */\n  JsVar *flatString = jsvFindChildFromString((JsVar*)function, JSPARSE_FUNCTION_CODE_NAME, 0);\n  if (flatString) {\n    flatString = jsvSkipNameAndUnLock(flatString);\n    void *v = (void*)((size_t)function->varData.native.ptr + (char*)jsvGetFlatStringPointer(flatString));\n    jsvUnLock(flatString);\n    return v;\n  } else\n    return (void *)function->varData.native.ptr;\n}\n\n/// Create a new ArrayBuffer backed by the given string. If length is not specified, it will be worked out\nJsVar *jsvNewArrayBufferFromString(JsVar *str, unsigned int lengthOrZero) {\n  JsVar *arr = jsvNewWithFlags(JSV_ARRAYBUFFER);\n  if (!arr) return 0;\n  jsvSetFirstChild(arr, jsvGetRef(jsvRef(str)));\n  arr->varData.arraybuffer.type = ARRAYBUFFERVIEW_ARRAYBUFFER;\n  assert(arr->varData.arraybuffer.byteOffset == 0);\n  if (lengthOrZero==0) lengthOrZero = (unsigned int)jsvGetStringLength(str);\n  arr->varData.arraybuffer.length = (unsigned short)lengthOrZero;\n  return arr;\n}\n\nbool jsvIsBasicVarEqual(JsVar *a, JsVar *b) {\n  // quick checks\n  if (a==b) return true;\n  if (!a || !b) return false; // one of them is undefined\n  // OPT: would this be useful as compare instead?\n  assert(jsvIsBasic(a) && jsvIsBasic(b));\n  if (jsvIsNumeric(a) && jsvIsNumeric(b)) {\n    if (jsvIsIntegerish(a)) {\n      if (jsvIsIntegerish(b)) {\n        return a->varData.integer == b->varData.integer;\n      } else {\n        assert(jsvIsFloat(b));\n        return a->varData.integer == b->varData.floating;\n      }\n    } else {\n      assert(jsvIsFloat(a));\n      if (jsvIsIntegerish(b)) {\n        return a->varData.floating == b->varData.integer;\n      } else {\n        assert(jsvIsFloat(b));\n        return a->varData.floating == b->varData.floating;\n      }\n    }\n  } else if (jsvIsString(a) && jsvIsString(b)) {\n    JsvStringIterator ita, itb;\n    jsvStringIteratorNew(&ita, a, 0);\n    jsvStringIteratorNew(&itb, b, 0);\n    while (true) {\n      char a = jsvStringIteratorGetChar(&ita);\n      char b = jsvStringIteratorGetChar(&itb);\n      if (a != b) {\n        jsvStringIteratorFree(&ita);\n        jsvStringIteratorFree(&itb);\n        return false;\n      }\n      if (!a) { // equal, but end of string\n        jsvStringIteratorFree(&ita);\n        jsvStringIteratorFree(&itb);\n        return true;\n      }\n      jsvStringIteratorNext(&ita);\n      jsvStringIteratorNext(&itb);\n    }\n    // we never get here\n    return false; // make compiler happy\n  } else {\n    //TODO: are there any other combinations we should check here?? String v int?\n    return false;\n  }\n}\n\nbool jsvIsEqual(JsVar *a, JsVar *b) {\n  if (jsvIsBasic(a) && jsvIsBasic(b))\n    return jsvIsBasicVarEqual(a,b);\n  return jsvGetRef(a)==jsvGetRef(b);\n}\n\n/// Get a const string representing this variable - if we can. Otherwise return 0\nconst char *jsvGetConstString(const JsVar *v) {\n  if (jsvIsUndefined(v)) {\n    return \"undefined\";\n  } else if (jsvIsNull(v)) {\n    return \"null\";\n  } else if (jsvIsBoolean(v)) {\n    return jsvGetBool(v) ? \"true\" : \"false\";\n  }\n  return 0;\n}\n\n/// Return the 'type' of the JS variable (eg. JS's typeof operator)\nconst char *jsvGetTypeOf(const JsVar *v) {\n  if (jsvIsUndefined(v)) return \"undefined\";\n  if (jsvIsNull(v) || jsvIsObject(v) ||\n      jsvIsArray(v) || jsvIsArrayBuffer(v)) return \"object\";\n  if (jsvIsFunction(v)) return \"function\";\n  if (jsvIsString(v)) return \"string\";\n  if (jsvIsBoolean(v)) return \"boolean\";\n  if (jsvIsNumeric(v)) return \"number\";\n  return \"?\";\n}\n\n/// Return the JsVar, or if it's an object and has a valueOf function, call that\nJsVar *jsvGetValueOf(JsVar *v) {\n  if (!jsvIsObject(v)) return jsvLockAgainSafe(v);\n  JsVar *valueOf = jspGetNamedField(v, \"valueOf\", false);\n  if (!jsvIsFunction(valueOf)) {\n    jsvUnLock(valueOf);\n    return jsvLockAgain(v);\n  }\n  v = jspeFunctionCall(valueOf, 0, v, false, 0, 0);\n  jsvUnLock(valueOf);\n  return v;\n}\n\n/** Save this var as a string to the given buffer, and return how long it was (return val doesn't include terminating 0)\nIf the buffer length is exceeded, the returned value will == len */\nsize_t jsvGetString(const JsVar *v, char *str, size_t len) {\n  assert(len>0);\n  const char *s = jsvGetConstString(v);\n  if (s) {\n    /* don't use strncpy here because we don't\n     * want to pad the entire buffer with zeros */\n    len--;\n    int l = 0;\n    while (*s && l<len) {\n      str[l] = s[l];\n      l++;\n    }\n    str[l] = 0;\n    return l;\n  } else if (jsvIsInt(v)) {\n    itostr(v->varData.integer, str, 10);\n    return strlen(str);\n  } else if (jsvIsFloat(v)) {\n    ftoa_bounded(v->varData.floating, str, len);\n    return strlen(str);\n  } else if (jsvHasCharacterData(v)) {\n    assert(!jsvIsStringExt(v));\n    size_t l = len;\n    JsvStringIterator it;\n    jsvStringIteratorNewConst(&it, v, 0);\n    while (jsvStringIteratorHasChar(&it)) {\n      if (l--<=1) {\n        *str = 0;\n        jsvStringIteratorFree(&it);\n        return len;\n      }\n      *(str++) = jsvStringIteratorGetChar(&it);\n      jsvStringIteratorNext(&it);\n    }\n    jsvStringIteratorFree(&it);\n    *str = 0;\n    return len-l;\n  } else {\n    // Try and get as a JsVar string, and try again\n    JsVar *stringVar = jsvAsString((JsVar*)v, false); // we know we're casting to non-const here\n    if (stringVar) {\n      size_t l = jsvGetString(stringVar, str, len); // call again - but this time with converted var\n      jsvUnLock(stringVar);\n      return l;\n    } else {\n      str[0] = 0;\n      jsExceptionHere(JSET_INTERNALERROR, \"Variable type cannot be converted to string\");\n      return 0;\n    }\n  }\n}\n\n/// Get len bytes of string data from this string. Does not error if string len is not equal to len\nsize_t jsvGetStringChars(const JsVar *v, size_t startChar, char *str, size_t len) {\n  assert(jsvHasCharacterData(v));\n  size_t l = len;\n  JsvStringIterator it;\n  jsvStringIteratorNewConst(&it, v, startChar);\n  while (jsvStringIteratorHasChar(&it)) {\n    if (l--<=0) {\n      jsvStringIteratorFree(&it);\n      return len;\n    }\n    *(str++) = jsvStringIteratorGetChar(&it);\n    jsvStringIteratorNext(&it);\n  }\n  jsvStringIteratorFree(&it);\n  *str = 0;\n  return len-l;\n}\n\n/// Set the Data in this string. This must JUST overwrite - not extend or shrink\nvoid jsvSetString(JsVar *v, const char *str, size_t len) {\n  assert(jsvHasCharacterData(v));\n  // the iterator checks, so it is safe not to assert if the length is different\n  //assert(len == jsvGetStringLength(v));\n\n\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, v, 0);\n  size_t i;\n  for (i=0;i<len;i++) {\n    jsvStringIteratorSetChar(&it, str[i]);\n    jsvStringIteratorNext(&it);\n  }\n  jsvStringIteratorFree(&it);\n}\n\n/** If var is a string, lock and return it, else\n * create a new string. unlockVar means this will auto-unlock 'var'  */\nJsVar *jsvAsString(JsVar *v, bool unlockVar) {\n  JsVar *str = 0;\n  // If it is string-ish, but not quite a string, copy it\n  if (jsvHasCharacterData(v) && jsvIsName(v)) {\n    str = jsvNewFromStringVar(v,0,JSVAPPENDSTRINGVAR_MAXLENGTH);\n  } else if (jsvIsString(v)) { // If it is a string - just return a reference\n    str = jsvLockAgain(v);\n  } else if (jsvIsObject(v)) { // If it is an object and we can call toString on it\n    JsVar *toStringFn = jspGetNamedField(v, \"toString\", false);\n    if (toStringFn && toStringFn->varData.native.ptr != (void (*)(void))jswrap_object_toString) {\n      // Function found and it's not the default one - execute it\n      JsVar *result = jspExecuteFunction(toStringFn,v,0,0);\n      jsvUnLock(toStringFn);\n      str = jsvAsString(result, true);\n    } else {\n      jsvUnLock(toStringFn);\n      str = jsvNewFromString(\"[object Object]\");\n    }\n  } else {\n    const char *constChar = jsvGetConstString(v);\n    assert(JS_NUMBER_BUFFER_SIZE>=10);\n    char buf[JS_NUMBER_BUFFER_SIZE];\n    if (constChar) {\n      // if we could get this as a simple const char, do that..\n      str = jsvNewFromString(constChar);\n    } else if (jsvIsPin(v)) {\n      jshGetPinString(buf, (Pin)v->varData.integer);\n      str = jsvNewFromString(buf);\n    } else if (jsvIsInt(v)) {\n      itostr(v->varData.integer, buf, 10);\n      str = jsvNewFromString(buf);\n    } else if (jsvIsFloat(v)) {\n      ftoa_bounded(v->varData.floating, buf, sizeof(buf));\n      str = jsvNewFromString(buf);\n    } else if (jsvIsArray(v) || jsvIsArrayBuffer(v)) {\n      JsVar *filler = jsvNewFromString(\",\");\n      str = jsvArrayJoin(v, filler);\n      jsvUnLock(filler);\n    } else if (jsvIsFunction(v)) {\n      str = jsvNewFromEmptyString();\n      if (str) jsfGetJSON(v, str, JSON_NONE);\n    } else {\n      jsExceptionHere(JSET_INTERNALERROR, \"Variable type cannot be converted to string\");\n      str = 0;\n    }\n  }\n\n  if (unlockVar) jsvUnLock(v);\n  return str;\n}\n\nJsVar *jsvAsFlatString(JsVar *var) {\n  if (jsvIsFlatString(var)) return jsvLockAgain(var);\n  JsVar *str = jsvAsString(var, false);\n  size_t len = jsvGetStringLength(str);\n  JsVar *flat = jsvNewFlatStringOfLength((unsigned int)len);\n  if (flat) {\n    JsvStringIterator src;\n    JsvStringIterator dst;\n    jsvStringIteratorNew(&src, str, 0);\n    jsvStringIteratorNew(&dst, flat, 0);\n    while (len--) {\n      jsvStringIteratorSetChar(&dst, jsvStringIteratorGetChar(&src));\n      if (len>0) {\n        jsvStringIteratorNext(&src);\n        jsvStringIteratorNext(&dst);\n      }\n    }\n    jsvStringIteratorFree(&src);\n    jsvStringIteratorFree(&dst);\n  }\n  jsvUnLock(str);\n  return flat;\n}\n\n/** Given a JsVar meant to be an index to an array, convert it to\n * the actual variable type we'll use to access the array. For example\n * a[\"0\"] is actually translated to a[0]\n */\nJsVar *jsvAsArrayIndex(JsVar *index) {\n  if (jsvIsSimpleInt(index)) {\n    return jsvLockAgain(index); // we're ok!\n  } else if (jsvIsString(index)) {\n    /* Index filtering (bug #19) - if we have an array index A that is:\n     is_string(A) && int_to_string(string_to_int(A)) == A\n     then convert it to an integer. Shouldn't be too nasty for performance\n     as we only do this when accessing an array with a string */\n    if (jsvIsStringNumericStrict(index)) {\n      JsVar *i = jsvNewFromInteger(jsvGetInteger(index));\n      JsVar *is = jsvAsString(i, false);\n      if (jsvCompareString(index,is,0,0,false)==0) {\n        // two items are identical - use the integer\n        jsvUnLock(is);\n        return i;\n      } else {\n        // not identical, use as a string\n        jsvUnLock2(i,is);\n      }\n    }\n  } else if (jsvIsFloat(index)) {\n    // if it's a float that is actually integral, return an integer...\n    JsVarFloat v = jsvGetFloat(index);\n    JsVarInt vi = jsvGetInteger(index);\n    if (v == vi) return jsvNewFromInteger(vi);\n  }\n\n  // else if it's not a simple numeric type, convert it to a string\n  return jsvAsString(index, false);\n}\n\n/** Same as jsvAsArrayIndex, but ensures that 'index' is unlocked */\nJsVar *jsvAsArrayIndexAndUnLock(JsVar *a) {\n  JsVar *b = jsvAsArrayIndex(a);\n  jsvUnLock(a);\n  return b;\n}\n\n/// Returns true if the string is empty - faster than jsvGetStringLength(v)==0\nbool jsvIsEmptyString(JsVar *v) {\n  if (!jsvHasCharacterData(v)) return true;\n  return jsvGetCharactersInVar(v)==0;\n}\n\nsize_t jsvGetStringLength(const JsVar *v) {\n  size_t strLength = 0;\n  const JsVar *var = v;\n  JsVar *newVar = 0;\n  if (!jsvHasCharacterData(v)) return 0;\n\n  while (var) {\n    JsVarRef ref = jsvGetLastChild(var);\n    strLength += jsvGetCharactersInVar(var);\n\n    // Go to next\n    jsvUnLock(newVar); // note use of if (ref), not var\n    var = newVar = ref ? jsvLock(ref) : 0;\n  }\n  jsvUnLock(newVar); // note use of if (ref), not var\n  return strLength;\n}\n\nsize_t jsvGetFlatStringBlocks(const JsVar *v) {\n  assert(jsvIsFlatString(v));\n  return ((size_t)v->varData.integer+sizeof(JsVar)-1) / sizeof(JsVar);\n}\n\nchar *jsvGetFlatStringPointer(JsVar *v) {\n  assert(jsvIsFlatString(v));\n  if (!jsvIsFlatString(v)) return 0;\n  return (char*)(v+1); // pointer to the next JsVar\n}\n\nJsVar *jsvGetFlatStringFromPointer(char *v) {\n  JsVar *secondVar = (JsVar*)v;\n  JsVar *flatStr = secondVar-1;\n  assert(jsvIsFlatString(flatStr));\n  return flatStr;\n}\n\n/// If the variable points to a *flat* area of memory, return a pointer (and set length). Otherwise return 0.\nchar *jsvGetDataPointer(JsVar *v, size_t *len) {\n  assert(len);\n  if (jsvIsArrayBuffer(v)) {\n    /* Arraybuffers generally use some kind of string to store their data.\n     * Find it, then call ourselves again to figure out if we can get a\n     * raw pointer to it.  */\n    JsVar *d = jsvGetArrayBufferBackingString(v);\n    char *r = jsvGetDataPointer(d, len);\n    jsvUnLock(d);\n    if (r) {\n      r += v->varData.arraybuffer.byteOffset;\n      *len = v->varData.arraybuffer.length;\n    }\n    return r;\n  }\n  if (jsvIsNativeString(v)) {\n    *len = v->varData.nativeStr.len;\n    return (char*)v->varData.nativeStr.ptr;\n  }\n  if (jsvIsFlatString(v)) {\n    *len = jsvGetStringLength(v);\n    return jsvGetFlatStringPointer(v);\n  }\n  return 0;\n}\n\n//  IN A STRING  get the number of lines in the string (min=1)\nsize_t jsvGetLinesInString(JsVar *v) {\n  size_t lines = 1;\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, v, 0);\n  while (jsvStringIteratorHasChar(&it)) {\n    if (jsvStringIteratorGetChar(&it)=='\\n') lines++;\n    jsvStringIteratorNext(&it);\n  }\n  jsvStringIteratorFree(&it);\n  return lines;\n}\n\n// IN A STRING Get the number of characters on a line - lines start at 1\nsize_t jsvGetCharsOnLine(JsVar *v, size_t line) {\n  size_t currentLine = 1;\n  size_t chars = 0;\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, v, 0);\n  while (jsvStringIteratorHasChar(&it)) {\n    if (jsvStringIteratorGetChar(&it)=='\\n') {\n      currentLine++;\n      if (currentLine > line) break;\n    } else if (currentLine==line) chars++;\n    jsvStringIteratorNext(&it);\n  }\n  jsvStringIteratorFree(&it);\n  return chars;\n}\n\n//  IN A STRING, get the 1-based line and column of the given character. Both values must be non-null\nvoid jsvGetLineAndCol(JsVar *v, size_t charIdx, size_t *line, size_t *col) {\n  size_t x = 1;\n  size_t y = 1;\n  size_t n = 0;\n  assert(line && col);\n\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, v, 0);\n  while (jsvStringIteratorHasChar(&it)) {\n    char ch = jsvStringIteratorGetChar(&it);\n    if (n==charIdx) {\n      jsvStringIteratorFree(&it);\n      *line = y;\n      *col = x;\n      return;\n    }\n    x++;\n    if (ch=='\\n') {\n      x=1; y++;\n    }\n    n++;\n    jsvStringIteratorNext(&it);\n  }\n  jsvStringIteratorFree(&it);\n  // uh-oh - not found\n  *line = y;\n  *col = x;\n}\n\n//  IN A STRING, get a character index from a line and column\nsize_t jsvGetIndexFromLineAndCol(JsVar *v, size_t line, size_t col) {\n  size_t x = 1;\n  size_t y = 1;\n  size_t n = 0;\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, v, 0);\n  while (jsvStringIteratorHasChar(&it)) {\n    char ch = jsvStringIteratorGetChar(&it);\n    if ((y==line && x>=col) || y>line) {\n      jsvStringIteratorFree(&it);\n      return (y>line) ? (n-1) : n;\n    }\n    x++;\n    if (ch=='\\n') {\n      x=1; y++;\n    }\n    n++;\n    jsvStringIteratorNext(&it);\n  }\n  jsvStringIteratorFree(&it);\n  return n;\n}\n\nvoid jsvAppendString(JsVar *var, const char *str) {\n  assert(jsvIsString(var));\n  JsvStringIterator dst;\n  jsvStringIteratorNew(&dst, var, 0);\n  jsvStringIteratorGotoEnd(&dst);\n  // now start appending\n  /* This isn't as fast as something single-purpose, but it's not that bad,\n   * and is less likely to break :) */\n  while (*str)\n    jsvStringIteratorAppend(&dst, *(str++));\n  jsvStringIteratorFree(&dst);\n}\n\n// Append the given string to this one - but does not use null-terminated strings\nvoid jsvAppendStringBuf(JsVar *var, const char *str, size_t length) {\n  assert(jsvIsString(var));\n  JsvStringIterator dst;\n  jsvStringIteratorNew(&dst, var, 0);\n  jsvStringIteratorGotoEnd(&dst);\n  // now start appending\n  /* This isn't as fast as something single-purpose, but it's not that bad,\n   * and is less likely to break :) */\n  while (length) {\n    jsvStringIteratorAppend(&dst, *(str++));\n    length--;\n  }\n  jsvStringIteratorFree(&dst);\n}\n\n/// Special version of append designed for use with vcbprintf_callback (See jsvAppendPrintf)\nvoid jsvStringIteratorPrintfCallback(const char *str, void *user_data) {\n  while (*str)\n    jsvStringIteratorAppend((JsvStringIterator *)user_data, *(str++));\n}\n\nvoid jsvAppendPrintf(JsVar *var, const char *fmt, ...) {\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, var, 0);\n  jsvStringIteratorGotoEnd(&it);\n\n  va_list argp;\n  va_start(argp, fmt);\n  vcbprintf((vcbprintf_callback)jsvStringIteratorPrintfCallback,&it, fmt, argp);\n  va_end(argp);\n\n  jsvStringIteratorFree(&it);\n}\n\nJsVar *jsvVarPrintf( const char *fmt, ...) {\n  JsVar *str = jsvNewFromEmptyString();\n  if (!str) return 0;\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, str, 0);\n  jsvStringIteratorGotoEnd(&it);\n\n  va_list argp;\n  va_start(argp, fmt);\n  vcbprintf((vcbprintf_callback)jsvStringIteratorPrintfCallback,&it, fmt, argp);\n  va_end(argp);\n\n  jsvStringIteratorFree(&it);\n  return str;\n}\n\n/** Append str to var. Both must be strings. stridx = start char or str, maxLength = max number of characters (can be JSVAPPENDSTRINGVAR_MAXLENGTH) */\nvoid jsvAppendStringVar(JsVar *var, const JsVar *str, size_t stridx, size_t maxLength) {\n  assert(jsvIsString(var));\n\n  JsvStringIterator dst;\n  jsvStringIteratorNew(&dst, var, 0);\n  jsvStringIteratorGotoEnd(&dst);\n  // now start appending\n  /* This isn't as fast as something single-purpose, but it's not that bad,\n     * and is less likely to break :) */\n  JsvStringIterator it;\n  jsvStringIteratorNewConst(&it, str, stridx);\n  while (jsvStringIteratorHasChar(&it) && (maxLength-->0)) {\n    char ch = jsvStringIteratorGetChar(&it);\n    jsvStringIteratorAppend(&dst, ch);\n    jsvStringIteratorNext(&it);\n  }\n  jsvStringIteratorFree(&it);\n  jsvStringIteratorFree(&dst);\n}\n\n/** Create a new variable from a substring. argument must be a string. stridx = start char or str, maxLength = max number of characters (can be JSVAPPENDSTRINGVAR_MAXLENGTH) */\nJsVar *jsvNewFromStringVar(const JsVar *str, size_t stridx, size_t maxLength) {\n  JsVar *var = jsvNewFromEmptyString();\n  if (var) jsvAppendStringVar(var, str, stridx, maxLength);\n  return var;\n}\n\n/** Append all of str to var. Both must be strings.  */\nvoid jsvAppendStringVarComplete(JsVar *var, const JsVar *str) {\n  jsvAppendStringVar(var, str, 0, JSVAPPENDSTRINGVAR_MAXLENGTH);\n}\n\nchar jsvGetCharInString(JsVar *v, size_t idx) {\n  if (!jsvIsString(v)) return 0;\n\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, v, idx);\n  char ch = jsvStringIteratorGetChar(&it);\n  jsvStringIteratorFree(&it);\n  return ch;\n}\n\n/// Get the index of a character in a string, or -1\nint jsvGetStringIndexOf(JsVar *str, char ch) {\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, str, 0);\n  while (jsvStringIteratorHasChar(&it)) {\n    if (jsvStringIteratorGetChar(&it) == ch) {\n      int idx = (int)jsvStringIteratorGetIndex(&it);\n      jsvStringIteratorFree(&it);\n      return idx;\n    };\n    jsvStringIteratorNext(&it);\n  }\n  jsvStringIteratorFree(&it);\n  return -1;\n}\n\n/** Does this string contain only Numeric characters (with optional '-'/'+' at the front)? NOT '.'/'e' and similar (allowDecimalPoint is for '.' only) */\nbool jsvIsStringNumericInt(const JsVar *var, bool allowDecimalPoint) {\n  assert(jsvIsString(var));\n  JsvStringIterator it;\n  jsvStringIteratorNewConst(&it, var, 0); // we know it's non const\n\n  // skip whitespace\n  while (jsvStringIteratorHasChar(&it) && isWhitespace(jsvStringIteratorGetChar(&it)))\n    jsvStringIteratorNext(&it);\n\n  // skip a minus. if there was one\n  if (jsvStringIteratorGetChar(&it)=='-' || jsvStringIteratorGetChar(&it)=='+')\n    jsvStringIteratorNext(&it);\n\n  int radix = 0;\n  if (jsvStringIteratorGetChar(&it)=='0') {\n    jsvStringIteratorNext(&it);\n    char buf[3];\n    buf[0] = '0';\n    buf[1] = jsvStringIteratorGetChar(&it);\n    buf[2] = 0;\n    const char *p = buf;\n    radix = getRadix(&p,0,0);\n    if (p>&buf[1]) jsvStringIteratorNext(&it);\n  }\n  if (radix==0) radix=10;\n\n  // now check...\n  int chars=0;\n  while (jsvStringIteratorHasChar(&it)) {\n    chars++;\n    char ch = jsvStringIteratorGetChar(&it);\n    if (ch=='.' && allowDecimalPoint) {\n      allowDecimalPoint = false; // there can be only one\n    } else {\n      int n = chtod(ch);\n      if (n<0 || n>=radix) {\n        jsvStringIteratorFree(&it);\n        return false;\n      }\n    }\n    jsvStringIteratorNext(&it);\n  }\n  jsvStringIteratorFree(&it);\n  return chars>0;\n}\n\n/** Does this string contain only Numeric characters? This is for arrays\n * and makes the assertion that int_to_string(string_to_int(var))==var */\nbool jsvIsStringNumericStrict(const JsVar *var) {\n  assert(jsvIsString(var));\n  JsvStringIterator it;\n  jsvStringIteratorNewConst(&it, var, 0);  // we know it's non const\n  bool hadNonZero = false;\n  bool hasLeadingZero = false;\n  int chars = 0;\n  while (jsvStringIteratorHasChar(&it)) {\n    chars++;\n    char ch = jsvStringIteratorGetChar(&it);\n    if (!isNumeric(ch)) {\n      // test for leading zero ensures int_to_string(string_to_int(var))==var\n      jsvStringIteratorFree(&it);\n      return false;\n    }\n    if (!hadNonZero && ch=='0') hasLeadingZero=true;\n    if (ch!='0') hadNonZero=true;\n    jsvStringIteratorNext(&it);\n  }\n  jsvStringIteratorFree(&it);\n  return chars>0 && (!hasLeadingZero || chars==1);\n}\n\n\nJsVarInt jsvGetInteger(const JsVar *v) {\n  if (!v) return 0; // undefined\n  /* strtol understands about hex and octal */\n  if (jsvIsNull(v)) return 0;\n  if (jsvIsUndefined(v)) return 0;\n  if (jsvIsIntegerish(v) || jsvIsArrayBufferName(v)) return v->varData.integer;\n  if (jsvIsArray(v) || jsvIsArrayBuffer(v)) {\n    JsVarInt l = jsvGetLength((JsVar *)v);\n    if (l==0) return 0; // 0 length, return 0\n    if (l==1) {\n      if (jsvIsArrayBuffer(v))\n        return jsvGetIntegerAndUnLock(jsvArrayBufferGet((JsVar*)v,0));\n      return jsvGetIntegerAndUnLock(jsvSkipNameAndUnLock(jsvGetArrayItem(v,0)));\n    }\n  }\n  if (jsvIsFloat(v)) {\n    if (isfinite(v->varData.floating))\n      return (JsVarInt)(long long)v->varData.floating;\n    return 0;\n  }\n  if (jsvIsString(v) && jsvIsStringNumericInt(v, true/* allow decimal point*/)) {\n    char buf[32];\n    if (jsvGetString(v, buf, sizeof(buf))==sizeof(buf))\n      jsExceptionHere(JSET_ERROR, \"String too big to convert to integer\\n\");\n    else\n      return (JsVarInt)stringToInt(buf);\n  }\n  return 0;\n}\n\nlong long jsvGetLongInteger(const JsVar *v) {\n  if (jsvIsInt(v)) return jsvGetInteger(v);\n  return (long long)jsvGetFloat(v);\n}\n\nlong long jsvGetLongIntegerAndUnLock(JsVar *v) {\n  long long i = jsvGetLongInteger(v);\n  jsvUnLock(v);\n  return i;\n}\n\n\nvoid jsvSetInteger(JsVar *v, JsVarInt value) {\n  assert(jsvIsInt(v));\n  v->varData.integer  = value;\n}\n\n/**\n * Get the boolean value of a variable.\n * From a JavaScript variable, we determine its boolean value.  The rules\n * are:\n *\n * * If integer, true if value is not 0.\n * * If float, true if value is not 0.0.\n * * If function, array or object, always true.\n * * If string, true if length of string is greater than 0.\n */\nbool jsvGetBool(const JsVar *v) {\n  if (jsvIsString(v))\n    return jsvGetStringLength((JsVar*)v)!=0;\n  if (jsvIsFunction(v) || jsvIsArray(v) || jsvIsObject(v) || jsvIsArrayBuffer(v))\n    return true;\n  if (jsvIsFloat(v)) {\n    JsVarFloat f = jsvGetFloat(v);\n    return !isnan(f) && f!=0.0;\n  }\n  return jsvGetInteger(v)!=0;\n}\n\nJsVarFloat jsvGetFloat(const JsVar *v) {\n  if (!v) return NAN; // undefined\n  if (jsvIsFloat(v)) return v->varData.floating;\n  if (jsvIsIntegerish(v)) return (JsVarFloat)v->varData.integer;\n  if (jsvIsArray(v) || jsvIsArrayBuffer(v)) {\n    JsVarInt l = jsvGetLength(v);\n    if (l==0) return 0; // zero element array==0 (not undefined)\n    if (l==1) {\n      if (jsvIsArrayBuffer(v))\n        return jsvGetFloatAndUnLock(jsvArrayBufferGet((JsVar*)v,0));\n      return jsvGetFloatAndUnLock(jsvSkipNameAndUnLock(jsvGetArrayItem(v,0)));\n    }\n  }\n  if (jsvIsString(v)) {\n    char buf[64];\n    if (jsvGetString(v, buf, sizeof(buf))==sizeof(buf)) {\n      jsExceptionHere(JSET_ERROR, \"String too big to convert to float\\n\");\n    } else {\n      if (buf[0]==0) return 0; // empty string -> 0\n      if (!strcmp(buf,\"Infinity\")) return INFINITY;\n      if (!strcmp(buf,\"-Infinity\")) return -INFINITY;\n      return stringToFloat(buf);\n    }\n  }\n  return NAN;\n}\n\n/// Convert the given variable to a number\nJsVar *jsvAsNumber(JsVar *var) {\n  // stuff that we can just keep\n  if (jsvIsInt(var) || jsvIsFloat(var)) return jsvLockAgain(var);\n  // stuff that can be converted to an int\n  if (jsvIsBoolean(var) ||\n      jsvIsPin(var) ||\n      jsvIsNull(var) ||\n      jsvIsBoolean(var) ||\n      jsvIsArrayBufferName(var))\n    return jsvNewFromInteger(jsvGetInteger(var));\n  if (jsvIsString(var) && (jsvIsEmptyString(var) || jsvIsStringNumericInt(var, false/* no decimal pt - handle that with GetFloat */))) {\n    // handle strings like this, in case they're too big for an int\n    char buf[64];\n    if (jsvGetString(var, buf, sizeof(buf))==sizeof(buf)) {\n      jsExceptionHere(JSET_ERROR, \"String too big to convert to integer\\n\");\n      return jsvNewFromFloat(NAN);\n    } else\n      return jsvNewFromLongInteger(stringToInt(buf));\n  }\n  // Else just try and get a float\n  return jsvNewFromFloat(jsvGetFloat(var));\n}\n\nJsVarInt jsvGetIntegerAndUnLock(JsVar *v) { return _jsvGetIntegerAndUnLock(v); }\nJsVarFloat jsvGetFloatAndUnLock(JsVar *v) { return _jsvGetFloatAndUnLock(v); }\nbool jsvGetBoolAndUnLock(JsVar *v) { return _jsvGetBoolAndUnLock(v); }\n\n/** Get the item at the given location in the array buffer and return the result */\nsize_t jsvGetArrayBufferLength(const JsVar *arrayBuffer) {\n  assert(jsvIsArrayBuffer(arrayBuffer));\n  return arrayBuffer->varData.arraybuffer.length;\n}\n\n/** Get the String the contains the data for this arrayBuffer */\nJsVar *jsvGetArrayBufferBackingString(JsVar *arrayBuffer) {\n  jsvLockAgain(arrayBuffer);\n  while (jsvIsArrayBuffer(arrayBuffer)) {\n    JsVar *s = jsvLock(jsvGetFirstChild(arrayBuffer));\n    jsvUnLock(arrayBuffer);\n    arrayBuffer = s;\n  }\n  assert(jsvIsString(arrayBuffer));\n  return arrayBuffer;\n}\n\n/** Get the item at the given location in the array buffer and return the result */\nJsVar *jsvArrayBufferGet(JsVar *arrayBuffer, size_t idx) {\n  JsvArrayBufferIterator it;\n  jsvArrayBufferIteratorNew(&it, arrayBuffer, idx);\n  JsVar *v = jsvArrayBufferIteratorGetValue(&it);\n  jsvArrayBufferIteratorFree(&it);\n  return v;\n}\n\n/** Set the item at the given location in the array buffer */\nvoid jsvArrayBufferSet(JsVar *arrayBuffer, size_t idx, JsVar *value) {\n  JsvArrayBufferIterator it;\n  jsvArrayBufferIteratorNew(&it, arrayBuffer, idx);\n  jsvArrayBufferIteratorSetValue(&it, value);\n  jsvArrayBufferIteratorFree(&it);\n}\n\n\n/** Given an integer name that points to an arraybuffer or an arraybufferview, evaluate it and return the result */\nJsVar *jsvArrayBufferGetFromName(JsVar *name) {\n  assert(jsvIsArrayBufferName(name));\n  size_t idx = (size_t)jsvGetInteger(name);\n  JsVar *arrayBuffer = jsvLock(jsvGetFirstChild(name));\n  JsVar *value = jsvArrayBufferGet(arrayBuffer, idx);\n  jsvUnLock(arrayBuffer);\n  return value;\n}\n\n\nJsVar *jsvGetFunctionArgumentLength(JsVar *functionScope) {\n  JsVar *args = jsvNewEmptyArray();\n  if (!args) return 0; // out of memory\n\n  JsvObjectIterator it;\n  jsvObjectIteratorNew(&it, functionScope);\n  while (jsvObjectIteratorHasValue(&it)) {\n    JsVar *idx = jsvObjectIteratorGetKey(&it);\n    if (jsvIsFunctionParameter(idx)) {\n      JsVar *val = jsvSkipOneName(idx);\n      jsvArrayPushAndUnLock(args, val);\n    }\n    jsvUnLock(idx);\n    jsvObjectIteratorNext(&it);\n  }\n  jsvObjectIteratorFree(&it);\n\n  return args;\n}\n\n/** Is this variable actually defined? eg, can we pass it into `jsvSkipName`\n * without getting a ReferenceError? This also returns false if the variable\n * if ok, but has the value `undefined`. */\nbool jsvIsVariableDefined(JsVar *a) {\n  return !jsvIsName(a) ||\n         jsvIsNameWithValue(a) ||\n         (jsvGetFirstChild(a)!=0);\n}\n\n/** If a is a name skip it and go to what it points to - and so on.\n * ALWAYS locks - so must unlock what it returns. It MAY\n * return 0. Throws a ReferenceError if variable is not defined,\n * but you can check if it will with jsvIsReferenceError */\nJsVar *jsvSkipName(JsVar *a) {\n  if (!a) return 0;\n  if (jsvIsArrayBufferName(a)) return jsvArrayBufferGetFromName(a);\n  if (jsvIsNameInt(a)) return jsvNewFromInteger((JsVarInt)jsvGetFirstChildSigned(a));\n  if (jsvIsNameIntBool(a)) return jsvNewFromBool(jsvGetFirstChild(a)!=0);\n  JsVar *pa = jsvLockAgain(a);\n  while (jsvIsName(pa)) {\n    JsVarRef n = jsvGetFirstChild(pa);\n    jsvUnLock(pa);\n    if (!n) {\n      if (pa==a && jsvGetRefs(a)==0 && !jsvIsNewChild(a)) {\n        jsExceptionHere(JSET_REFERENCEERROR, \"%q is not defined\", a);\n      }\n      return 0;\n    }\n    pa = jsvLock(n);\n    assert(pa!=a);\n  }\n  return pa;\n}\n\n/** If a is a name skip it and go to what it points to.\n * ALWAYS locks - so must unlock what it returns. It MAY\n * return 0. Throws a ReferenceError if variable is not defined,\n * but you can check if it will with jsvIsReferenceError */\nJsVar *jsvSkipOneName(JsVar *a) {\n  if (!a) return 0;\n  if (jsvIsArrayBufferName(a)) return jsvArrayBufferGetFromName(a);\n  if (jsvIsNameInt(a)) return jsvNewFromInteger((JsVarInt)jsvGetFirstChildSigned(a));\n  if (jsvIsNameIntBool(a)) return jsvNewFromBool(jsvGetFirstChild(a)!=0);\n  JsVar *pa = jsvLockAgain(a);\n  if (jsvIsName(pa)) {\n    JsVarRef n = jsvGetFirstChild(pa);\n    jsvUnLock(pa);\n    if (!n) {\n      if (pa==a && jsvGetRefs(a)==0 && !jsvIsNewChild(a)) {\n        jsExceptionHere(JSET_REFERENCEERROR, \"%q is not defined\", a);\n      }\n      return 0;\n    }\n    pa = jsvLock(n);\n    assert(pa!=a);\n  }\n  return pa;\n}\n\n/** If a is a's child is a name skip it and go to what it points to.\n * ALWAYS locks - so must unlock what it returns.  */\nJsVar *jsvSkipToLastName(JsVar *a) {\n  assert(jsvIsName(a));\n  a = jsvLockAgain(a);\n  while (true) {\n    if (!jsvGetFirstChild(a)) return a;\n    JsVar *child = jsvLock(jsvGetFirstChild(a));\n    if (jsvIsName(child)) {\n      jsvUnLock(a);\n      a = child;\n    } else {\n      jsvUnLock(child);\n      return a;\n    }\n  }\n  return 0; // not called\n}\n\n/** Same as jsvSkipName, but ensures that 'a' is unlocked */\nJsVar *jsvSkipNameAndUnLock(JsVar *a) {\n  JsVar *b = jsvSkipName(a);\n  jsvUnLock(a);\n  return b;\n}\n\n/** Same as jsvSkipOneName, but ensures that 'a' is unlocked */\nJsVar *jsvSkipOneNameAndUnLock(JsVar *a) {\n  JsVar *b = jsvSkipOneName(a);\n  jsvUnLock(a);\n  return b;\n}\n\nbool jsvIsStringEqualOrStartsWithOffset(JsVar *var, const char *str, bool isStartsWith, size_t startIdx, bool ignoreCase) {\n  if (!jsvHasCharacterData(var)) {\n    return 0; // not a string so not equal!\n  }\n\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, var, startIdx);\n  if (ignoreCase) {\n      while (jsvStringIteratorHasChar(&it) && *str &&\n             jsvStringCharToLower(jsvStringIteratorGetChar(&it)) == jsvStringCharToLower(*str)) {\n        str++;\n        jsvStringIteratorNext(&it);\n      }\n  } else {\n      while (jsvStringIteratorHasChar(&it) && *str &&\n             jsvStringIteratorGetChar(&it) == *str) {\n        str++;\n        jsvStringIteratorNext(&it);\n      }\n  }\n  bool eq = (isStartsWith && !*str) ||\n            jsvStringIteratorGetChar(&it)==*str; // should both be 0 if equal\n  jsvStringIteratorFree(&it);\n  return eq;\n}\n\n/*\njsvIsStringEqualOrStartsWith(A, B, false) is a proper A==B\njsvIsStringEqualOrStartsWith(A, B, true) is A.startsWith(B)\n */\nbool jsvIsStringEqualOrStartsWith(JsVar *var, const char *str, bool isStartsWith) {\n  return jsvIsStringEqualOrStartsWithOffset(var, str, isStartsWith, 0, false);\n}\n\n// Also see jsvIsBasicVarEqual\nbool jsvIsStringEqual(JsVar *var, const char *str) {\n  return jsvIsStringEqualOrStartsWith(var, str, false);\n}\n\n// Also see jsvIsBasicVarEqual\nbool jsvIsStringIEqualAndUnLock(JsVar *var, const char *str) {\n  bool b = jsvIsStringEqualOrStartsWithOffset(var, str, false, 0, true);\n  jsvUnLock(var);\n  return b;\n}\n\n\n/** Compare 2 strings, starting from the given character positions. equalAtEndOfString means that\n * if one of the strings ends (even if the other hasn't), we treat them as equal.\n * For a basic strcmp, do: jsvCompareString(a,b,0,0,false)\n *  */\nint jsvCompareString(JsVar *va, JsVar *vb, size_t starta, size_t startb, bool equalAtEndOfString) {\n  JsvStringIterator ita, itb;\n  jsvStringIteratorNew(&ita, va, starta);\n  jsvStringIteratorNew(&itb, vb, startb);\n  // step to first positions\n  while (true) {\n    int ca = jsvStringIteratorGetCharOrMinusOne(&ita);\n    int cb = jsvStringIteratorGetCharOrMinusOne(&itb);\n\n    if (ca != cb) {\n      jsvStringIteratorFree(&ita);\n      jsvStringIteratorFree(&itb);\n      if ((ca<0 || cb<0) && equalAtEndOfString) return 0;\n      return ca - cb;\n    }\n    if (ca < 0) { // both equal, but end of string\n      jsvStringIteratorFree(&ita);\n      jsvStringIteratorFree(&itb);\n      return 0;\n    }\n    jsvStringIteratorNext(&ita);\n    jsvStringIteratorNext(&itb);\n  }\n  // never get here, but the compiler warns...\n  return true;\n}\n\n/** Return a new string containing just the characters that are\n * shared between two strings. */\nJsVar *jsvGetCommonCharacters(JsVar *va, JsVar *vb) {\n  JsVar *v = jsvNewFromEmptyString();\n  if (!v) return 0;\n  JsvStringIterator ita, itb;\n  jsvStringIteratorNew(&ita, va, 0);\n  jsvStringIteratorNew(&itb, vb, 0);\n  int ca = jsvStringIteratorGetCharOrMinusOne(&ita);\n  int cb = jsvStringIteratorGetCharOrMinusOne(&itb);\n  while (ca>0 && cb>0 && ca == cb) {\n    jsvAppendCharacter(v, (char)ca);\n    jsvStringIteratorNext(&ita);\n    jsvStringIteratorNext(&itb);\n    ca = jsvStringIteratorGetCharOrMinusOne(&ita);\n    cb = jsvStringIteratorGetCharOrMinusOne(&itb);\n  }\n  jsvStringIteratorFree(&ita);\n  jsvStringIteratorFree(&itb);\n  return v;\n}\n\n\n/** Compare 2 integers, >0 if va>vb,  <0 if va<vb. If compared with a non-integer, that gets put later */\nint jsvCompareInteger(JsVar *va, JsVar *vb) {\n  if (jsvIsInt(va) && jsvIsInt(vb))\n    return (int)(jsvGetInteger(va) - jsvGetInteger(vb));\n  else if (jsvIsInt(va))\n    return -1;\n  else if (jsvIsInt(vb))\n    return 1;\n  else\n    return 0;\n}\n\n/** Copy only a name, not what it points to. ALTHOUGH the link to what it points to is maintained unless linkChildren=false\n    If keepAsName==false, this will be converted into a normal variable */\nJsVar *jsvCopyNameOnly(JsVar *src, bool linkChildren, bool keepAsName) {\n  assert(jsvIsName(src));\n  JsVarFlags flags = src->flags;\n  JsVar *dst = 0;\n  if (!keepAsName) {\n    JsVarFlags t = src->flags & JSV_VARTYPEMASK;\n    if (t>=_JSV_NAME_INT_START && t<=_JSV_NAME_INT_END) {\n      flags = (flags & ~JSV_VARTYPEMASK) | JSV_INTEGER;\n    } else {\n      assert((JSV_NAME_STRING_INT_0 < JSV_NAME_STRING_0) &&\n          (JSV_NAME_STRING_0 < JSV_STRING_0) &&\n          (JSV_STRING_0 < JSV_STRING_EXT_0)); // this relies on ordering\n      assert(t>=JSV_NAME_STRING_INT_0 && t<=JSV_NAME_STRING_MAX);\n      if (jsvGetLastChild(src)) {\n        /* it's not a simple name string - it has STRING_EXT bits on the end.\n         * Because the max length of NAME and STRING is different we must just\n         * copy */\n        dst = jsvNewFromStringVar(src, 0, JSVAPPENDSTRINGVAR_MAXLENGTH);\n        if (!dst) return 0;\n      } else {\n        flags = (flags & (JsVarFlags)~JSV_VARTYPEMASK) | (JSV_STRING_0 + jsvGetCharactersInVar(src));\n      }\n    }\n  }\n  if (!dst) {\n    dst = jsvNewWithFlags(flags & JSV_VARIABLEINFOMASK);\n    if (!dst) return 0; // out of memory\n\n    memcpy(&dst->varData, &src->varData, JSVAR_DATA_STRING_NAME_LEN);\n\n    assert(jsvGetLastChild(dst) == 0);\n    assert(jsvGetFirstChild(dst) == 0);\n    assert(jsvGetPrevSibling(dst) == 0);\n    assert(jsvGetNextSibling(dst) == 0);\n    // Copy extra string data if there was any\n    if (jsvHasStringExt(src)) {\n      // If it had extra string data it should have been handled above\n      assert(keepAsName || !jsvGetLastChild(src));\n      // copy extra bits of string if there were any\n      if (jsvGetLastChild(src)) {\n        JsVar *child = jsvLock(jsvGetLastChild(src));\n        JsVar *childCopy = jsvCopy(child, true);\n        if (childCopy) { // could be out of memory\n          jsvSetLastChild(dst, jsvGetRef(childCopy)); // no ref for stringext\n          jsvUnLock(childCopy);\n        }\n        jsvUnLock(child);\n      }\n    } else {\n      assert(jsvIsBasic(src)); // in case we missed something!\n    }\n  }\n  // Copy LINK of what it points to\n  if (linkChildren && jsvGetFirstChild(src)) {\n    if (jsvIsNameWithValue(src))\n      jsvSetFirstChild(dst, jsvGetFirstChild(src));\n    else\n      jsvSetFirstChild(dst, jsvRefRef(jsvGetFirstChild(src)));\n  }\n  return dst;\n}\n\nJsVar *jsvCopy(JsVar *src, bool copyChildren) {\n  if (jsvIsFlatString(src)) {\n    // Copy a Flat String into a non-flat string - it's just safer\n    return jsvNewFromStringVar(src, 0, JSVAPPENDSTRINGVAR_MAXLENGTH);\n  }\n  JsVar *dst = jsvNewWithFlags(src->flags & JSV_VARIABLEINFOMASK);\n  if (!dst) return 0; // out of memory\n  if (!jsvIsStringExt(src)) {\n      memcpy(&dst->varData, &src->varData, (jsvIsBasicString(src)||jsvIsNativeString(src)) ? JSVAR_DATA_STRING_LEN : JSVAR_DATA_STRING_NAME_LEN);\n      if (!(jsvIsBasicString(src)||jsvIsNativeString(src))) {\n        assert(jsvGetPrevSibling(dst) == 0);\n        assert(jsvGetNextSibling(dst) == 0);\n        assert(jsvGetFirstChild(dst) == 0);\n      }\n      assert(jsvGetLastChild(dst) == 0);\n  } else {\n    // stringexts use the extra pointers after varData to store characters\n    // see jsvGetMaxCharactersInVar\n    memcpy(&dst->varData, &src->varData, JSVAR_DATA_STRING_MAX_LEN);\n    assert(jsvGetLastChild(dst) == 0);\n  }\n\n  // Copy what names point to\n  if (copyChildren && jsvIsName(src)) {\n    if (jsvGetFirstChild(src)) {\n      if (jsvIsNameWithValue(src)) {\n        // name_int/etc don't need references\n        jsvSetFirstChild(dst, jsvGetFirstChild(src));\n      } else {\n        JsVar *child = jsvLock(jsvGetFirstChild(src));\n        JsVar *childCopy = jsvRef(jsvCopy(child, true));\n        jsvUnLock(child);\n        if (childCopy) { // could have been out of memory\n          jsvSetFirstChild(dst, jsvGetRef(childCopy));\n          jsvUnLock(childCopy);\n        }\n      }\n    }\n  }\n\n  if (jsvHasStringExt(src)) {\n    // copy extra bits of string if there were any\n    if (jsvGetLastChild(src)) {\n      JsVar *child = jsvLock(jsvGetLastChild(src));\n      JsVar *childCopy = jsvCopy(child, true);\n      if (childCopy) {// could be out of memory\n        jsvSetLastChild(dst, jsvGetRef(childCopy)); // no ref for stringext\n        jsvUnLock(childCopy);\n      }\n      jsvUnLock(child);\n    }\n  } else if (jsvHasChildren(src)) {\n    if (copyChildren) {\n      // Copy children..\n      JsVarRef vr;\n      vr = jsvGetFirstChild(src);\n      while (vr) {\n        JsVar *name = jsvLock(vr);\n        JsVar *child = jsvCopyNameOnly(name, true/*link children*/, true/*keep as name*/); // NO DEEP COPY!\n        if (child) { // could have been out of memory\n          jsvAddName(dst, child);\n          jsvUnLock(child);\n        }\n        vr = jsvGetNextSibling(name);\n        jsvUnLock(name);\n      }\n    }\n  } else {\n    assert(jsvIsBasic(src)); // in case we missed something!\n  }\n\n  return dst;\n}\n\nvoid jsvAddName(JsVar *parent, JsVar *namedChild) {\n  namedChild = jsvRef(namedChild); // ref here VERY important as adding to structure!\n  assert(jsvIsName(namedChild));\n\n  // update array length\n  if (jsvIsArray(parent) && jsvIsInt(namedChild)) {\n    JsVarInt index = namedChild->varData.integer;\n    if (index >= jsvGetArrayLength(parent)) {\n      jsvSetArrayLength(parent, index + 1, false);\n    }\n  }\n\n  if (jsvGetLastChild(parent)) { // we have children already\n    JsVar *insertAfter = jsvLock(jsvGetLastChild(parent));\n    if (jsvIsArray(parent)) {\n      // we must insert in order - so step back until we get the right place\n      while (insertAfter && jsvCompareInteger(namedChild, insertAfter)<0) {\n        JsVarRef prev = jsvGetPrevSibling(insertAfter);\n        jsvUnLock(insertAfter);\n        insertAfter = prev ? jsvLock(prev) : 0;\n      }\n    }\n\n    if (insertAfter) {\n      if (jsvGetNextSibling(insertAfter)) {\n        // great, we're in the middle...\n        JsVar *insertBefore = jsvLock(jsvGetNextSibling(insertAfter));\n        jsvSetPrevSibling(insertBefore, jsvGetRef(namedChild));\n        jsvSetNextSibling(namedChild, jsvGetRef(insertBefore));\n        jsvUnLock(insertBefore);\n      } else {\n        // We're at the end - just set up the parent\n        jsvSetLastChild(parent, jsvGetRef(namedChild));\n      }\n      jsvSetNextSibling(insertAfter, jsvGetRef(namedChild));\n      jsvSetPrevSibling(namedChild, jsvGetRef(insertAfter));\n      jsvUnLock(insertAfter);\n    } else { // Insert right at the beginning of the array\n      // Link 2 children together\n      JsVar *firstChild = jsvLock(jsvGetFirstChild(parent));\n      jsvSetPrevSibling(firstChild, jsvGetRef(namedChild));\n      jsvUnLock(firstChild);\n\n      jsvSetNextSibling(namedChild, jsvGetFirstChild(parent));\n      // finally set the new child as the first one\n      jsvSetFirstChild(parent, jsvGetRef(namedChild));\n    }\n  } else { // we have no children - just add it\n    JsVarRef r = jsvGetRef(namedChild);\n    jsvSetFirstChild(parent, r);\n    jsvSetLastChild(parent, r);\n  }\n}\n\nJsVar *jsvAddNamedChild(JsVar *parent, JsVar *child, const char *name) {\n  JsVar *namedChild = jsvMakeIntoVariableName(jsvNewFromString(name), child);\n  if (!namedChild) return 0; // Out of memory\n  jsvAddName(parent, namedChild);\n  return namedChild;\n}\n\nJsVar *jsvSetNamedChild(JsVar *parent, JsVar *child, const char *name) {\n  JsVar *namedChild = jsvFindChildFromString(parent, name, true);\n  if (namedChild) // could be out of memory\n    return jsvSetValueOfName(namedChild, child);\n  return 0;\n}\n\nJsVar *jsvSetValueOfName(JsVar *name, JsVar *src) {\n  assert(name && jsvIsName(name));\n  assert(name!=src); // no infinite loops!\n  // all is fine, so replace the existing child...\n  /* Existing child may be null in the case of Z = 0 where\n   * we create 'Z' and pass it down to '=' to have the value\n   * filled in (or it may be undefined). */\n  if (jsvIsNameWithValue(name)) {\n    if (jsvIsString(name))\n      name->flags = (name->flags & (JsVarFlags)~JSV_VARTYPEMASK) | (JSV_NAME_STRING_0 + jsvGetCharactersInVar(name));\n    else\n      name->flags = (name->flags & (JsVarFlags)~JSV_VARTYPEMASK) | JSV_NAME_INT;\n    jsvSetFirstChild(name, 0);\n  } else if (jsvGetFirstChild(name))\n    jsvUnRefRef(jsvGetFirstChild(name)); // free existing\n  if (src) {\n    if (jsvIsInt(name)) {\n      if ((jsvIsInt(src) || jsvIsBoolean(src)) && !jsvIsPin(src)) {\n        JsVarInt v = src->varData.integer;\n        if (v>=JSVARREF_MIN && v<=JSVARREF_MAX) {\n          name->flags = (name->flags & (JsVarFlags)~JSV_VARTYPEMASK) | (jsvIsInt(src) ? JSV_NAME_INT_INT : JSV_NAME_INT_BOOL);\n          jsvSetFirstChild(name, (JsVarRef)v);\n          return name;\n        }\n      }\n    } else if (jsvIsString(name)) {\n      if (jsvIsInt(src) && !jsvIsPin(src)) {\n        JsVarInt v = src->varData.integer;\n        if (v>=JSVARREF_MIN && v<=JSVARREF_MAX) {\n          name->flags = (name->flags & (JsVarFlags)~JSV_VARTYPEMASK) | (JSV_NAME_STRING_INT_0 + jsvGetCharactersInVar(name));\n          jsvSetFirstChild(name, (JsVarRef)v);\n          return name;\n        }\n      }\n    }\n    // we can link to a name if we want (so can remove the assert!)\n    jsvSetFirstChild(name, jsvGetRef(jsvRef(src)));\n  } else\n    jsvSetFirstChild(name, 0);\n  return name;\n}\n\nJsVar *jsvFindChildFromString(JsVar *parent, const char *name, bool addIfNotFound) {\n  /* Pull out first 4 bytes, and ensure that everything\n   * is 0 padded so that we can do a nice speedy check. */\n  char fastCheck[4];\n  fastCheck[0] = name[0];\n  if (name[0]) {\n    fastCheck[1] = name[1];\n    if (name[1]) {\n      fastCheck[2] = name[2];\n      if (name[2]) {\n        fastCheck[3] = name[3];\n      } else {\n        fastCheck[3] = 0;\n      }\n    } else {\n      fastCheck[2] = 0;\n      fastCheck[3] = 0;\n    }\n  } else {\n    fastCheck[1] = 0;\n    fastCheck[2] = 0;\n    fastCheck[3] = 0;\n  }\n\n  assert(jsvHasChildren(parent));\n  JsVarRef childref = jsvGetFirstChild(parent);\n  while (childref) {\n    // Don't Lock here, just use GetAddressOf - to try and speed up the finding\n    // TODO: We can do this now, but when/if we move to cacheing vars, it'll break\n    JsVar *child = jsvGetAddressOf(childref);\n    if (*(int*)fastCheck==*(int*)child->varData.str && // speedy check of first 4 bytes\n        jsvIsStringEqual(child, name)) {\n      // found it! unlock parent but leave child locked\n      return jsvLockAgain(child);\n    }\n    childref = jsvGetNextSibling(child);\n  }\n\n  JsVar *child = 0;\n  if (addIfNotFound) {\n    child = jsvMakeIntoVariableName(jsvNewFromString(name), 0);\n    if (child) // could be out of memory\n      jsvAddName(parent, child);\n  }\n  return child;\n}\n\n/// See jsvIsNewChild - for fields that don't exist yet\nJsVar *jsvCreateNewChild(JsVar *parent, JsVar *index, JsVar *child) {\n  JsVar *newChild = jsvAsName(index);\n  if (!newChild) return 0;\n  assert(!jsvGetFirstChild(newChild));\n  if (child) jsvSetValueOfName(newChild, child);\n  assert(!jsvGetNextSibling(newChild) && !jsvGetPrevSibling(newChild));\n  // by setting the siblings as the same, we signal that if set,\n  // we should be made a member of the given object\n  JsVarRef r = jsvGetRef(jsvRef(jsvRef(parent)));\n  jsvSetNextSibling(newChild, r);\n  jsvSetPrevSibling(newChild, r);\n\n  return newChild;\n}\n\n/** Try and turn the supplied variable into a name. If not, make a new one. This locks again. */\nJsVar *jsvAsName(JsVar *var) {\n  if (!var) return 0;\n  if (jsvGetRefs(var) == 0) {\n    // Not reffed - great! let's just use it\n    if (!jsvIsName(var))\n      var = jsvMakeIntoVariableName(var, 0);\n    return jsvLockAgain(var);\n  } else { // it was reffed, we must add a new one\n    return jsvMakeIntoVariableName(jsvCopy(var, false), 0);\n  }\n}\n\n/** Non-recursive finding */\nJsVar *jsvFindChildFromVar(JsVar *parent, JsVar *childName, bool addIfNotFound) {\n  JsVar *child;\n  JsVarRef childref = jsvGetFirstChild(parent);\n\n  while (childref) {\n    child = jsvLock(childref);\n    if (jsvIsBasicVarEqual(child, childName)) {\n      // found it! unlock parent but leave child locked\n      return child;\n    }\n    childref = jsvGetNextSibling(child);\n    jsvUnLock(child);\n  }\n\n  child = 0;\n  if (addIfNotFound && childName) {\n    child = jsvAsName(childName);\n    jsvAddName(parent, child);\n  }\n  return child;\n}\n\nvoid jsvRemoveChild(JsVar *parent, JsVar *child) {\n  assert(jsvHasChildren(parent));\n  assert(jsvIsName(child));\n  JsVarRef childref = jsvGetRef(child);\n  bool wasChild = false;\n  // unlink from parent\n  if (jsvGetFirstChild(parent) == childref) {\n    jsvSetFirstChild(parent, jsvGetNextSibling(child));\n    wasChild = true;\n  }\n  if (jsvGetLastChild(parent) == childref) {\n    jsvSetLastChild(parent, jsvGetPrevSibling(child));\n    wasChild = true;\n    // If this was an array and we were the last\n    // element, update the length\n    if (jsvIsArray(parent)) {\n      JsVarInt l = 0;\n      // get index of last child\n      if (jsvGetLastChild(parent))\n        l = jsvGetIntegerAndUnLock(jsvLock(jsvGetLastChild(parent)))+1;\n      // set it\n      jsvSetArrayLength(parent, l, false);\n    }\n  }\n  // unlink from child list\n  if (jsvGetPrevSibling(child)) {\n    JsVar *v = jsvLock(jsvGetPrevSibling(child));\n    assert(jsvGetNextSibling(v) == jsvGetRef(child));\n    jsvSetNextSibling(v, jsvGetNextSibling(child));\n    jsvUnLock(v);\n    wasChild = true;\n  }\n  if (jsvGetNextSibling(child)) {\n    JsVar *v = jsvLock(jsvGetNextSibling(child));\n    assert(jsvGetPrevSibling(v) == jsvGetRef(child));\n    jsvSetPrevSibling(v, jsvGetPrevSibling(child));\n    jsvUnLock(v);\n    wasChild = true;\n  }\n\n  jsvSetPrevSibling(child, 0);\n  jsvSetNextSibling(child, 0);\n  if (wasChild)\n    jsvUnRef(child);\n}\n\nvoid jsvRemoveAllChildren(JsVar *parent) {\n  assert(jsvHasChildren(parent));\n  while (jsvGetFirstChild(parent)) {\n    JsVar *v = jsvLock(jsvGetFirstChild(parent));\n    jsvRemoveChild(parent, v);\n    jsvUnLock(v);\n  }\n}\n\n/// Check if the given name is a child of the parent\nbool jsvIsChild(JsVar *parent, JsVar *child) {\n  assert(jsvIsArray(parent) || jsvIsObject(parent));\n  assert(jsvIsName(child));\n  JsVarRef childref = jsvGetRef(child);\n  JsVarRef indexref;\n  indexref = jsvGetFirstChild(parent);\n  while (indexref) {\n    if (indexref == childref) return true;\n    // get next\n    JsVar *indexVar = jsvLock(indexref);\n    indexref = jsvGetNextSibling(indexVar);\n    jsvUnLock(indexVar);\n  }\n  return false; // not found undefined\n}\n\n/// Get the named child of an object. If createChild!=0 then create the child\nJsVar *jsvObjectGetChild(JsVar *obj, const char *name, JsVarFlags createChild) {\n  if (!obj) return 0;\n  assert(jsvHasChildren(obj));\n  JsVar *childName = jsvFindChildFromString(obj, name, createChild!=0);\n  JsVar *child = jsvSkipName(childName);\n  if (!child && createChild && childName!=0/*out of memory?*/) {\n    child = jsvNewWithFlags(createChild);\n    jsvSetValueOfName(childName, child);\n    jsvUnLock(childName);\n    return child;\n  }\n  jsvUnLock(childName);\n  return child;\n}\n\n/// Set the named child of an object, and return the child (so you can choose to unlock it if you want)\nJsVar *jsvObjectSetChild(JsVar *obj, const char *name, JsVar *child) {\n  assert(jsvHasChildren(obj));\n  if (!jsvHasChildren(obj)) return 0;\n  // child can actually be a name (for instance if it is a named function)\n  JsVar *childName = jsvFindChildFromString(obj, name, true);\n  if (!childName) return 0; // out of memory\n  jsvSetValueOfName(childName, child);\n  jsvUnLock(childName);\n  return child;\n}\n\n/// Set the named child of an object, and return the child (so you can choose to unlock it if you want)\nJsVar *jsvObjectSetChildVar(JsVar *obj, JsVar *name, JsVar *child) {\n  assert(jsvHasChildren(obj));\n  if (!jsvHasChildren(obj)) return 0;\n  // child can actually be a name (for instance if it is a named function)\n  JsVar *childName = jsvFindChildFromVar(obj, name, true);\n  if (!childName) return 0; // out of memory\n  jsvSetValueOfName(childName, child);\n  jsvUnLock(childName);\n  return child;\n}\n\nvoid jsvObjectSetChildAndUnLock(JsVar *obj, const char *name, JsVar *child) {\n  jsvUnLock(jsvObjectSetChild(obj, name, child));\n}\n\nvoid jsvObjectRemoveChild(JsVar *obj, const char *name) {\n  JsVar *child = jsvFindChildFromString(obj, name, false);\n  if (child) {\n    jsvRemoveChild(obj, child);\n    jsvUnLock(child);\n  }\n}\n\n/** Set the named child of an object, and return the child (so you can choose to unlock it if you want).\n * If the child is 0, the 'name' is also removed from the object */\nJsVar *jsvObjectSetOrRemoveChild(JsVar *obj, const char *name, JsVar *child) {\n  if (child)\n    jsvObjectSetChild(obj, name, child);\n  else\n    jsvObjectRemoveChild(obj, name);\n  return child;\n}\n\n/** Append all keys from the source object to the target object. Will ignore hidden/internal fields */\nvoid jsvObjectAppendAll(JsVar *target, JsVar *source) {\n  assert(jsvIsObject(target));\n  assert(jsvIsObject(source));\n  JsvObjectIterator it;\n  jsvObjectIteratorNew(&it, source);\n  while (jsvObjectIteratorHasValue(&it)) {\n    JsVar *k = jsvObjectIteratorGetKey(&it);\n    JsVar *v = jsvSkipName(k);\n    if (!jsvIsInternalObjectKey(k))\n      jsvObjectSetChildVar(target, k, v);\n    jsvUnLock2(k,v);\n    jsvObjectIteratorNext(&it);\n  }\n  jsvObjectIteratorFree(&it);\n}\n\nint jsvGetChildren(const JsVar *v) {\n  //OPT: could length be stored as the value of the array?\n  int children = 0;\n  JsVarRef childref = jsvGetFirstChild(v);\n  while (childref) {\n    JsVar *child = jsvLock(childref);\n    children++;\n    childref = jsvGetNextSibling(child);\n    jsvUnLock(child);\n  }\n  return children;\n}\n\n/// Get the first child's name from an object,array or function\nJsVar *jsvGetFirstName(JsVar *v) {\n  assert(jsvHasChildren(v));\n  if (!jsvGetFirstChild(v)) return 0;\n  return jsvLock(jsvGetFirstChild(v));\n}\n\nJsVarInt jsvGetArrayLength(const JsVar *arr) {\n  if (!arr) return 0;\n  assert(jsvIsArray(arr));\n  return arr->varData.integer;\n}\n\nJsVarInt jsvSetArrayLength(JsVar *arr, JsVarInt length, bool truncate) {\n  assert(jsvIsArray(arr));\n  if (truncate && length < arr->varData.integer) {\n    // @TODO implement truncation here\n  }\n  arr->varData.integer = length;\n  return length;\n}\n\nJsVarInt jsvGetLength(const JsVar *src) {\n  if (jsvIsArray(src)) {\n    return jsvGetArrayLength(src);\n  } else if (jsvIsArrayBuffer(src)) {\n    return (JsVarInt)jsvGetArrayBufferLength(src);\n  } else if (jsvIsString(src)) {\n    return (JsVarInt)jsvGetStringLength(src);\n  } else if (jsvIsObject(src) || jsvIsFunction(src)) {\n    return jsvGetChildren(src);\n  } else {\n    return 1;\n  }\n}\n\n/** Count the amount of JsVars used. Mostly useful for debugging */\nstatic size_t _jsvCountJsVarsUsedRecursive(JsVar *v, bool resetRecursionFlag) {\n  if (!v) return 0;\n  // Use IS_RECURSING  flag to stop recursion\n  if (resetRecursionFlag) {\n    if (!(v->flags & JSV_IS_RECURSING))\n      return 0;\n    v->flags &= ~JSV_IS_RECURSING;\n  } else {\n    if (v->flags & JSV_IS_RECURSING)\n      return 0;\n    v->flags |= JSV_IS_RECURSING;\n  }\n\n  size_t count = 1;\n  if (jsvHasSingleChild(v) || jsvHasChildren(v)) {\n    JsVarRef childref = jsvGetFirstChild(v);\n    while (childref) {\n      JsVar *child = jsvLock(childref);\n      count += _jsvCountJsVarsUsedRecursive(child, resetRecursionFlag);\n      if (jsvHasChildren(v)) childref = jsvGetNextSibling(child);\n      else childref = 0;\n      jsvUnLock(child);\n    }\n  } else if (jsvIsFlatString(v))\n    count += jsvGetFlatStringBlocks(v);\n  if (jsvHasCharacterData(v)) {\n    JsVarRef childref = jsvGetLastChild(v);\n    while (childref) {\n      JsVar *child = jsvLock(childref);\n      count++;\n      childref = jsvGetLastChild(child);\n      jsvUnLock(child);\n    }\n  }\n  if (jsvIsName(v) && !jsvIsNameWithValue(v) && jsvGetFirstChild(v)) {\n    JsVar *child = jsvLock(jsvGetFirstChild(v));\n    count += _jsvCountJsVarsUsedRecursive(child, resetRecursionFlag);\n    jsvUnLock(child);\n  }\n  return count;\n}\n\n/** Count the amount of JsVars used. Mostly useful for debugging */\nsize_t jsvCountJsVarsUsed(JsVar *v) {\n  // we do this so we don't count the same item twice, but don't use too much memory\n  size_t c = _jsvCountJsVarsUsedRecursive(v, false);\n  _jsvCountJsVarsUsedRecursive(v, true);\n  return c;\n}\n\nJsVar *jsvGetArrayIndex(const JsVar *arr, JsVarInt index) {\n  JsVarRef childref = jsvGetLastChild(arr);\n  JsVarInt lastArrayIndex = 0;\n  // Look at last non-string element!\n  while (childref) {\n    JsVar *child = jsvLock(childref);\n    if (jsvIsInt(child)) {\n      lastArrayIndex = child->varData.integer;\n      // it was the last element... sorted!\n      if (lastArrayIndex == index) {\n        return child;\n      }\n      jsvUnLock(child);\n      break;\n    }\n    // if not an int, keep going\n    childref = jsvGetPrevSibling(child);\n    jsvUnLock(child);\n  }\n  // it's not in this array - don't search the whole lot...\n  if (index > lastArrayIndex)\n    return 0;\n  // otherwise is it more than halfway through?\n  if (index > lastArrayIndex/2) {\n    // it's in the final half of the array (probably) - search backwards\n    while (childref) {\n      JsVar *child = jsvLock(childref);\n\n      assert(jsvIsInt(child));\n      if (child->varData.integer == index) {\n        return child;\n      }\n      childref = jsvGetPrevSibling(child);\n      jsvUnLock(child);\n    }\n  } else {\n    // it's in the first half of the array (probably) - search forwards\n    childref = jsvGetFirstChild(arr);\n    while (childref) {\n      JsVar *child = jsvLock(childref);\n\n      assert(jsvIsInt(child));\n      if (child->varData.integer == index) {\n        return child;\n      }\n      childref = jsvGetNextSibling(child);\n      jsvUnLock(child);\n    }\n  }\n  return 0; // undefined\n}\n\nJsVar *jsvGetArrayItem(const JsVar *arr, JsVarInt index) {\n  return jsvSkipNameAndUnLock(jsvGetArrayIndex(arr,index));\n}\n\nvoid jsvSetArrayItem(JsVar *arr, JsVarInt index, JsVar *item) {\n  JsVar *indexVar = jsvGetArrayIndex(arr, index);\n  if (indexVar) {\n    jsvSetValueOfName(indexVar, item);\n  } else {\n    indexVar = jsvMakeIntoVariableName(jsvNewFromInteger(index), item);\n    jsvAddName(arr, indexVar);\n  }\n  jsvUnLock(indexVar);\n}\n\n// Get all elements from arr and put them in itemPtr (unless it'd overflow).\n// Makes sure all of itemPtr either contains a JsVar or 0\nvoid jsvGetArrayItems(JsVar *arr, unsigned int itemCount, JsVar **itemPtr) {\n  JsvObjectIterator it;\n  jsvObjectIteratorNew(&it, arr);\n  unsigned int i = 0;\n  while (jsvObjectIteratorHasValue(&it)) {\n    if (i<itemCount)\n      itemPtr[i++] = jsvObjectIteratorGetValue(&it);\n    jsvObjectIteratorNext(&it);\n  }\n  jsvObjectIteratorFree(&it);\n  while (i<itemCount)\n    itemPtr[i++] = 0; // just ensure we don't end up with bad data\n}\n\n/// Get the index of the value in the array (matchExact==use pointer not equality check, matchIntegerIndices = don't check non-integers)\nJsVar *jsvGetIndexOfFull(JsVar *arr, JsVar *value, bool matchExact, bool matchIntegerIndices, int startIdx) {\n  JsVarRef indexref;\n  assert(jsvIsArray(arr) || jsvIsObject(arr));\n  indexref = jsvGetFirstChild(arr);\n  while (indexref) {\n    JsVar *childIndex = jsvLock(indexref);\n    if (!matchIntegerIndices ||\n        (jsvIsInt(childIndex) && jsvGetInteger(childIndex)>=startIdx)) {\n      assert(jsvIsName(childIndex));\n      JsVar *childValue = jsvSkipName(childIndex);\n      if (childValue==value ||\n          (!matchExact && jsvMathsOpTypeEqual(childValue, value))) {\n        jsvUnLock(childValue);\n        return childIndex;\n      }\n      jsvUnLock(childValue);\n    }\n    indexref = jsvGetNextSibling(childIndex);\n    jsvUnLock(childIndex);\n  }\n  return 0; // undefined\n}\n\n/// Get the index of the value in the array or object (matchExact==use pointer, not equality check)\nJsVar *jsvGetIndexOf(JsVar *arr, JsVar *value, bool matchExact) {\n  return jsvGetIndexOfFull(arr, value, matchExact, false, 0);\n}\n\n\n/// Adds new elements to the end of an array, and returns the new length. initialValue is the item index when no items are currently in the array.\nJsVarInt jsvArrayAddToEnd(JsVar *arr, JsVar *value, JsVarInt initialValue) {\n  assert(jsvIsArray(arr));\n  JsVarInt index = initialValue;\n  if (jsvGetLastChild(arr)) {\n    JsVar *last = jsvLock(jsvGetLastChild(arr));\n    index = jsvGetInteger(last)+1;\n    jsvUnLock(last);\n  }\n\n  JsVar *idx = jsvMakeIntoVariableName(jsvNewFromInteger(index), value);\n  if (!idx) return 0; // out of memory - error flag will have been set already\n  jsvAddName(arr, idx);\n  jsvUnLock(idx);\n  return index+1;\n}\n\n/// Adds new elements to the end of an array, and returns the new length\nJsVarInt jsvArrayPush(JsVar *arr, JsVar *value) {\n  assert(jsvIsArray(arr));\n  JsVarInt index = jsvGetArrayLength(arr);\n  JsVar *idx = jsvMakeIntoVariableName(jsvNewFromInteger(index), value);\n  if (!idx) return 0; // out of memory - error flag will have been set already\n  jsvAddName(arr, idx);\n  jsvUnLock(idx);\n  return jsvGetArrayLength(arr);\n}\n\n/// Adds a new element to the end of an array, unlocks it, and returns the new length\nJsVarInt jsvArrayPushAndUnLock(JsVar *arr, JsVar *value) {\n  JsVarInt l = jsvArrayPush(arr, value);\n  jsvUnLock(value);\n  return l;\n}\n\n/// Append all values from the source array to the target array\nvoid jsvArrayPushAll(JsVar *target, JsVar *source, bool checkDuplicates) {\n  assert(jsvIsArray(target));\n  assert(jsvIsArray(source));\n  JsvObjectIterator it;\n  jsvObjectIteratorNew(&it, source);\n  while (jsvObjectIteratorHasValue(&it)) {\n    JsVar *v = jsvObjectIteratorGetValue(&it);\n    bool add = true;\n    if (checkDuplicates) {\n      JsVar *idx = jsvGetIndexOf(target, v, false);\n      if (idx) {\n        add = false;\n        jsvUnLock(idx);\n      }\n    }\n    if (add) jsvArrayPush(target, v);\n    jsvUnLock(v);\n    jsvObjectIteratorNext(&it);\n  }\n  jsvObjectIteratorFree(&it);\n}\n\n/// Removes the last element of an array, and returns that element (or 0 if empty). includes the NAME\nJsVar *jsvArrayPop(JsVar *arr) {\n  assert(jsvIsArray(arr));\n  JsVar *child = 0;\n  JsVarInt length = jsvGetArrayLength(arr);\n  if (length > 0) {\n    length--;\n\n    if (jsvGetLastChild(arr)) {\n      // find last child with an integer key\n      JsVarRef ref = jsvGetLastChild(arr);\n      child = jsvLock(ref);\n      while (child && !jsvIsInt(child)) {\n        ref = jsvGetPrevSibling(child);\n        jsvUnLock(child);\n        if (ref) {\n          child = jsvLock(ref);\n        } else {\n          child = 0;\n        }\n      }\n      // check if the last integer key really is the last element\n      if (child) {\n        if (jsvGetInteger(child) == length) {\n          // child is the last element - remove it\n          jsvRemoveChild(arr, child);\n        } else {\n          // child is not the last element\n          jsvUnLock(child);\n          child = 0;\n        }\n      }\n    }\n    // and finally shrink the array\n    jsvSetArrayLength(arr, length, false);\n  }\n\n  return child;\n}\n\n/// Removes the first element of an array, and returns that element (or 0 if empty). DOES NOT RENUMBER.\nJsVar *jsvArrayPopFirst(JsVar *arr) {\n  assert(jsvIsArray(arr));\n  if (jsvGetFirstChild(arr)) {\n    JsVar *child = jsvLock(jsvGetFirstChild(arr));\n    if (jsvGetFirstChild(arr) == jsvGetLastChild(arr))\n      jsvSetLastChild(arr, 0); // if 1 item in array\n    jsvSetFirstChild(arr, jsvGetNextSibling(child)); // unlink from end of array\n    jsvUnRef(child); // as no longer in array\n    if (jsvGetNextSibling(child)) {\n      JsVar *v = jsvLock(jsvGetNextSibling(child));\n      jsvSetPrevSibling(v, 0);\n      jsvUnLock(v);\n    }\n    jsvSetNextSibling(child, 0);\n    return child; // and return it\n  } else {\n    // no children!\n    return 0;\n  }\n}\n\n/// Adds a new variable element to the end of an array (IF it was not already there). Return true if successful\nvoid jsvArrayAddUnique(JsVar *arr, JsVar *v) {\n  JsVar *idx = jsvGetIndexOf(arr, v, false); // did it already exist?\n  if (!idx) {\n    jsvArrayPush(arr, v); // if 0, it failed\n  } else {\n    jsvUnLock(idx);\n  }\n}\n\n/// Join all elements of an array together into a string\nJsVar *jsvArrayJoin(JsVar *arr, JsVar *filler) {\n  JsVar *str = jsvNewFromEmptyString();\n  if (!str) return 0; // out of memory\n\n  JsvIterator it;\n  jsvIteratorNew(&it, arr, JSIF_EVERY_ARRAY_ELEMENT);\n  bool first = true;\n  while (!jspIsInterrupted() && jsvIteratorHasElement(&it)) {\n    JsVar *key = jsvIteratorGetKey(&it);\n    if (jsvIsInt(key)) {\n      // add the filler\n      if (filler && !first)\n        jsvAppendStringVarComplete(str, filler);\n      first = false;\n      // add the value\n      JsVar *value = jsvIteratorGetValue(&it);\n      if (value && !jsvIsNull(value)) {\n        JsVar *valueStr = jsvAsString(value, false);\n        if (valueStr) { // could be out of memory\n          jsvAppendStringVarComplete(str, valueStr);\n          jsvUnLock(valueStr);\n        }\n      }\n      jsvUnLock(value);\n    }\n    jsvUnLock(key);\n    jsvIteratorNext(&it);\n  }\n  jsvIteratorFree(&it);\n  return str;\n}\n\n/// Insert a new element before beforeIndex, DOES NOT UPDATE INDICES\nvoid jsvArrayInsertBefore(JsVar *arr, JsVar *beforeIndex, JsVar *element) {\n  if (beforeIndex) {\n    JsVar *idxVar = jsvMakeIntoVariableName(jsvNewFromInteger(0), element);\n    if (!idxVar) return; // out of memory\n\n    JsVarRef idxRef = jsvGetRef(jsvRef(idxVar));\n    JsVarRef prev = jsvGetPrevSibling(beforeIndex);\n    if (prev) {\n      JsVar *prevVar = jsvRef(jsvLock(prev));\n      jsvSetInteger(idxVar, jsvGetInteger(prevVar)+1); // update index number\n      jsvSetNextSibling(prevVar, idxRef);\n      jsvUnLock(prevVar);\n      jsvSetPrevSibling(idxVar, prev);\n    } else {\n      jsvSetPrevSibling(idxVar, 0);\n      jsvSetFirstChild(arr, idxRef);\n    }\n    jsvSetPrevSibling(beforeIndex, idxRef);\n    jsvSetNextSibling(idxVar, jsvGetRef(jsvRef(beforeIndex)));\n    jsvUnLock(idxVar);\n  } else\n    jsvArrayPush(arr, element);\n}\n\n/** Same as jsvMathsOpPtr, but if a or b are a name, skip them\n * and go to what they point to. Also handle the case where\n * they may be objects with valueOf functions. */\nJsVar *jsvMathsOpSkipNames(JsVar *a, JsVar *b, int op) {\n  JsVar *pa = jsvSkipName(a);\n  JsVar *pb = jsvSkipName(b);\n  JsVar *oa = jsvGetValueOf(pa);\n  JsVar *ob = jsvGetValueOf(pb);\n  jsvUnLock2(pa, pb);\n  JsVar *res = jsvMathsOp(oa,ob,op);\n  jsvUnLock2(oa, ob);\n  return res;\n}\n\n\nJsVar *jsvMathsOpError(int op, const char *datatype) {\n  char opName[32];\n  jslTokenAsString(op, opName, sizeof(opName));\n  jsError(\"Operation %s not supported on the %s datatype\", opName, datatype);\n  return 0;\n}\n\nbool jsvMathsOpTypeEqual(JsVar *a, JsVar *b) {\n  // check type first, then call again to check data\n  bool eql = (a==0) == (b==0);\n  if (a && b) {\n    // Check whether both are numbers, otherwise check the variable\n    // type flags themselves\n    eql = ((jsvIsInt(a)||jsvIsFloat(a)) && (jsvIsInt(b)||jsvIsFloat(b))) ||\n        ((a->flags & JSV_VARTYPEMASK) == (b->flags & JSV_VARTYPEMASK));\n  }\n  if (eql) {\n    JsVar *contents = jsvMathsOp(a,b, LEX_EQUAL);\n    if (!jsvGetBool(contents)) eql = false;\n    jsvUnLock(contents);\n  } else {\n    /* Make sure we don't get in the situation where we have two equal\n     * strings with a check that fails because they were stored differently */\n    assert(!(jsvIsString(a) && jsvIsString(b) && jsvIsBasicVarEqual(a,b)));\n  }\n  return eql;\n}\n\nJsVar *jsvMathsOp(JsVar *a, JsVar *b, int op) {\n  // Type equality check\n  if (op == LEX_TYPEEQUAL || op == LEX_NTYPEEQUAL) {\n    bool eql = jsvMathsOpTypeEqual(a,b);\n    if (op == LEX_TYPEEQUAL)\n      return jsvNewFromBool(eql);\n    else\n      return jsvNewFromBool(!eql);\n  }\n\n  bool needsInt = op=='&' || op=='|' || op=='^' || op==LEX_LSHIFT || op==LEX_RSHIFT || op==LEX_RSHIFTUNSIGNED;\n  bool needsNumeric = needsInt || op=='*' || op=='/' || op=='%' || op=='-';\n  bool isCompare = op==LEX_EQUAL || op==LEX_NEQUAL || op=='<' || op==LEX_LEQUAL || op=='>'|| op==LEX_GEQUAL;\n  if (isCompare) {\n    if (jsvIsNumeric(a) && jsvIsString(b)) {\n      needsNumeric = true;\n      needsInt = jsvIsIntegerish(a) && jsvIsStringNumericInt(b, false);\n    } else if (jsvIsNumeric(b) && jsvIsString(a)) {\n      needsNumeric = true;\n      needsInt = jsvIsIntegerish(b) && jsvIsStringNumericInt(a, false);\n    }\n  }\n\n  // do maths...\n  if (jsvIsUndefined(a) && jsvIsUndefined(b)) {\n    if (op == LEX_EQUAL)\n      return jsvNewFromBool(true);\n    else if (op == LEX_NEQUAL)\n      return jsvNewFromBool(false);\n    else\n      return 0; // undefined\n  } else if (needsNumeric ||\n      ((jsvIsNumeric(a) || jsvIsUndefined(a) || jsvIsNull(a)) &&\n          (jsvIsNumeric(b) || jsvIsUndefined(b) || jsvIsNull(b)))) {\n    if (needsInt || (jsvIsIntegerish(a) && jsvIsIntegerish(b))) {\n      // note that int+undefined should be handled as a double\n      // use ints\n      JsVarInt da = jsvGetInteger(a);\n      JsVarInt db = jsvGetInteger(b);\n      switch (op) {\n      case '+': return jsvNewFromLongInteger((long long)da + (long long)db);\n      case '-': return jsvNewFromLongInteger((long long)da - (long long)db);\n      case '*': return jsvNewFromLongInteger((long long)da * (long long)db);\n      case '/': return jsvNewFromFloat((JsVarFloat)da/(JsVarFloat)db);\n      case '&': return jsvNewFromInteger(da&db);\n      case '|': return jsvNewFromInteger(da|db);\n      case '^': return jsvNewFromInteger(da^db);\n      case '%': return db ? jsvNewFromInteger(da%db) : jsvNewFromFloat(NAN);\n      case LEX_LSHIFT: return jsvNewFromInteger(da << db);\n      case LEX_RSHIFT: return jsvNewFromInteger(da >> db);\n      case LEX_RSHIFTUNSIGNED: return jsvNewFromInteger((JsVarInt)(((JsVarIntUnsigned)da) >> db));\n      case LEX_EQUAL:     return jsvNewFromBool(da==db && jsvIsNull(a)==jsvIsNull(b));\n      case LEX_NEQUAL:    return jsvNewFromBool(da!=db || jsvIsNull(a)!=jsvIsNull(b));\n      case '<':           return jsvNewFromBool(da<db);\n      case LEX_LEQUAL:    return jsvNewFromBool(da<=db);\n      case '>':           return jsvNewFromBool(da>db);\n      case LEX_GEQUAL:    return jsvNewFromBool(da>=db);\n      default: return jsvMathsOpError(op, \"Integer\");\n      }\n    } else {\n      // use doubles\n      JsVarFloat da = jsvGetFloat(a);\n      JsVarFloat db = jsvGetFloat(b);\n      switch (op) {\n      case '+': return jsvNewFromFloat(da+db);\n      case '-': return jsvNewFromFloat(da-db);\n      case '*': return jsvNewFromFloat(da*db);\n      case '/': return jsvNewFromFloat(da/db);\n      case '%': return jsvNewFromFloat(jswrap_math_mod(da, db));\n      case LEX_EQUAL:\n      case LEX_NEQUAL:  { bool equal = da==db;\n      if ((jsvIsNull(a) && jsvIsUndefined(b)) ||\n          (jsvIsNull(b) && jsvIsUndefined(a))) equal = true; // JS quirk :)\n      return jsvNewFromBool((op==LEX_EQUAL) ? equal : ((bool)!equal));\n      }\n      case '<':           return jsvNewFromBool(da<db);\n      case LEX_LEQUAL:    return jsvNewFromBool(da<=db);\n      case '>':           return jsvNewFromBool(da>db);\n      case LEX_GEQUAL:    return jsvNewFromBool(da>=db);\n      default: return jsvMathsOpError(op, \"Double\");\n      }\n    }\n  } else if ((jsvIsArray(a) || jsvIsObject(a) || jsvIsFunction(a) ||\n      jsvIsArray(b) || jsvIsObject(b) || jsvIsFunction(b)) &&\n      jsvIsArray(a)==jsvIsArray(b) && // Fix #283 - convert to string and test if only one is an array\n      (op == LEX_EQUAL || op==LEX_NEQUAL)) {\n    bool equal = a==b;\n\n    if (jsvIsNativeFunction(a) || jsvIsNativeFunction(b)) {\n      // even if one is not native, the contents will be different\n      equal = a && b && \n          a->varData.native.ptr == b->varData.native.ptr &&\n          a->varData.native.argTypes == b->varData.native.argTypes &&\n          jsvGetFirstChild(a) == jsvGetFirstChild(b);\n    }\n\n    /* Just check pointers */\n    switch (op) {\n    case LEX_EQUAL:  return jsvNewFromBool(equal);\n    case LEX_NEQUAL: return jsvNewFromBool(!equal);\n    default: return jsvMathsOpError(op, jsvIsArray(a)?\"Array\":\"Object\");\n    }\n  } else {\n    JsVar *da = jsvAsString(a, false);\n    JsVar *db = jsvAsString(b, false);\n    if (!da || !db) { // out of memory\n      jsvUnLock2(da, db);\n      return 0;\n    }\n    if (op=='+') {\n      JsVar *v = jsvCopy(da, false);\n      // TODO: can we be fancy and not copy da if we know it isn't reffed? what about locks?\n      if (v) // could be out of memory\n        jsvAppendStringVarComplete(v, db);\n      jsvUnLock2(da, db);\n      return v;\n    }\n\n    int cmp = jsvCompareString(da,db,0,0,false);\n    jsvUnLock2(da, db);\n    // use strings\n    switch (op) {\n    case LEX_EQUAL:     return jsvNewFromBool(cmp==0);\n    case LEX_NEQUAL:    return jsvNewFromBool(cmp!=0);\n    case '<':           return jsvNewFromBool(cmp<0);\n    case LEX_LEQUAL:    return jsvNewFromBool(cmp<=0);\n    case '>':           return jsvNewFromBool(cmp>0);\n    case LEX_GEQUAL:    return jsvNewFromBool(cmp>=0);\n    default: return jsvMathsOpError(op, \"String\");\n    }\n  }\n}\n\nJsVar *jsvNegateAndUnLock(JsVar *v) {\n  JsVar *zero = jsvNewFromInteger(0);\n  JsVar *res = jsvMathsOpSkipNames(zero, v, '-');\n  jsvUnLock2(zero, v);\n  return res;\n}\n\n/** If the given element is found, return the path to it as a string of\n * the form 'foo.bar', else return 0. If we would have returned a.b and\n * ignoreParent is a, don't! */\nJsVar *jsvGetPathTo(JsVar *root, JsVar *element, int maxDepth, JsVar *ignoreParent) {\n  if (maxDepth<=0) return 0;\n  JsvIterator it;\n  jsvIteratorNew(&it, root, JSIF_DEFINED_ARRAY_ElEMENTS);\n  while (jsvIteratorHasElement(&it)) {\n    JsVar *el = jsvIteratorGetValue(&it);\n    if (el == element && root != ignoreParent) {\n      // if we found it - send the key name back!\n      JsVar *name = jsvAsString(jsvIteratorGetKey(&it), true);\n      jsvIteratorFree(&it);\n      return name;\n    } else if (jsvIsObject(el) || jsvIsArray(el) || jsvIsFunction(el)) {\n      // recursively search\n      JsVar *n = jsvGetPathTo(el, element, maxDepth-1, ignoreParent);\n      if (n) {\n        // we found it! Append our name onto it as well\n        JsVar *keyName = jsvIteratorGetKey(&it);\n        JsVar *name = jsvVarPrintf(jsvIsObject(el) ? \"%v.%v\" : \"%v[%q]\",keyName,n);\n        jsvUnLock2(keyName, n);\n        jsvIteratorFree(&it);\n        return name;\n      }\n    }\n    jsvIteratorNext(&it);\n  }\n  jsvIteratorFree(&it);\n  return 0;\n}\n\nvoid jsvTraceLockInfo(JsVar *v) {\n  jsiConsolePrintf(\"#%d[r%d,l%d] \",jsvGetRef(v),jsvGetRefs(v),jsvGetLocks(v));\n}\n\n/** Get the lowest level at which searchRef appears */\nint _jsvTraceGetLowestLevel(JsVar *var, JsVar *searchVar) {\n  if (var == searchVar) return 0;\n  int found = -1;\n\n  // Use IS_RECURSING  flag to stop recursion\n  if (var->flags & JSV_IS_RECURSING)\n    return -1;\n  var->flags |= JSV_IS_RECURSING;\n\n  if (jsvHasSingleChild(var) && jsvGetFirstChild(var)) {\n    JsVar *child = jsvLock(jsvGetFirstChild(var));\n    int f = _jsvTraceGetLowestLevel(child, searchVar);\n    jsvUnLock(child);\n    if (f>=0 && (found<0 || f<found)) found=f+1;\n  }\n  if (jsvHasChildren(var)) {\n    JsVarRef childRef = jsvGetFirstChild(var);\n    while (childRef) {\n      JsVar *child = jsvLock(childRef);\n      int f = _jsvTraceGetLowestLevel(child, searchVar);\n      if (f>=0 && (found<0 || f<found)) found=f+1;\n      childRef = jsvGetNextSibling(child);\n      jsvUnLock(child);\n    }\n  }\n\n  var->flags &= ~JSV_IS_RECURSING;\n\n  return found; // searchRef not found\n}\n\nvoid _jsvTrace(JsVar *var, int indent, JsVar *baseVar, int level) {\n#ifdef SAVE_ON_FLASH\n  jsiConsolePrint(\"Trace unimplemented in this version.\\n\");\n#else\n  int i;\n  for (i=0;i<indent;i++) jsiConsolePrint(\" \");\n\n  if (!var) {\n    jsiConsolePrint(\"undefined\");\n    return;\n  }\n\n  jsvTraceLockInfo(var);\n\n  int lowestLevel = _jsvTraceGetLowestLevel(baseVar, var);\n  if (lowestLevel < level) {\n    // If this data is available elsewhere in the tree (but nearer the root)\n    // then don't print it. This makes the dump significantly more readable!\n    // It also stops us getting in recursive loops ...\n    jsiConsolePrint(\"...\\n\");\n    return;\n  }\n\n  if (jsvIsName(var)) jsiConsolePrint(\"Name \");\n\n  char endBracket = ' ';\n  if (jsvIsObject(var)) { jsiConsolePrint(\"Object { \"); endBracket = '}'; }\n  else if (jsvIsArray(var)) { jsiConsolePrintf(\"Array(%d) [ \", var->varData.integer); endBracket = ']'; }\n  else if (jsvIsNativeFunction(var)) { jsiConsolePrintf(\"NativeFunction 0x%x (%d) { \", var->varData.native.ptr, var->varData.native.argTypes); endBracket = '}'; }\n  else if (jsvIsFunction(var)) {\n    jsiConsolePrint(\"Function { \");\n    if (jsvIsFunctionReturn(var)) jsiConsolePrint(\"return \");\n    endBracket = '}';\n  } else if (jsvIsPin(var)) jsiConsolePrintf(\"Pin %d\", jsvGetInteger(var));\n  else if (jsvIsInt(var)) jsiConsolePrintf(\"Integer %d\", jsvGetInteger(var));\n  else if (jsvIsBoolean(var)) jsiConsolePrintf(\"Bool %s\", jsvGetBool(var)?\"true\":\"false\");\n  else if (jsvIsFloat(var)) jsiConsolePrintf(\"Double %f\", jsvGetFloat(var));\n  else if (jsvIsFunctionParameter(var)) jsiConsolePrintf(\"Param %q \", var);\n  else if (jsvIsArrayBufferName(var)) jsiConsolePrintf(\"ArrayBufferName[%d] \", jsvGetInteger(var));\n  else if (jsvIsArrayBuffer(var)) jsiConsolePrintf(\"%s \", jswGetBasicObjectName(var)?jswGetBasicObjectName(var):\"unknown ArrayBuffer\"); // way to get nice name\n  else if (jsvIsString(var)) {\n    size_t blocks = 1;\n    if (jsvGetLastChild(var)) {\n      JsVar *v = jsvLock(jsvGetLastChild(var));\n      blocks += jsvCountJsVarsUsed(v);\n      jsvUnLock(v);\n    }\n    if (jsvIsFlatString(var)) {\n      blocks += jsvGetFlatStringBlocks(var);\n    }\n    jsiConsolePrintf(\"%sString [%d blocks] %q\", jsvIsFlatString(var)?\"Flat\":(jsvIsNativeString(var)?\"Native\":\"\"), blocks, var);\n  } else {\n    jsiConsolePrintf(\"Unknown %d\", var->flags & (JsVarFlags)~(JSV_LOCK_MASK));\n  }\n\n  // print a value if it was stored in here as well...\n  if (jsvIsNameInt(var)) {\n    jsiConsolePrintf(\"= int %d\\n\", (int)jsvGetFirstChildSigned(var));\n    return;\n  } else if (jsvIsNameIntBool(var)) {\n    jsiConsolePrintf(\"= bool %s\\n\", jsvGetFirstChild(var)?\"true\":\"false\");\n    return;\n  }\n\n  if (jsvHasSingleChild(var)) {\n    JsVar *child = jsvGetFirstChild(var) ? jsvLock(jsvGetFirstChild(var)) : 0;\n    _jsvTrace(child, indent+2, baseVar, level+1);\n    jsvUnLock(child);\n  } else if (jsvHasChildren(var)) {\n    JsvIterator it;\n    jsvIteratorNew(&it, var, JSIF_DEFINED_ARRAY_ElEMENTS);\n    bool first = true;\n    while (jsvIteratorHasElement(&it) && !jspIsInterrupted()) {\n      if (first) jsiConsolePrintf(\"\\n\");\n      first = false;\n      JsVar *child = jsvIteratorGetKey(&it);\n      _jsvTrace(child, indent+2, baseVar, level+1);\n      jsvUnLock(child);\n      jsiConsolePrintf(\"\\n\");\n      jsvIteratorNext(&it);\n    }\n    jsvIteratorFree(&it);\n    if (!first)\n      for (i=0;i<indent;i++) jsiConsolePrint(\" \");\n  }\n  jsiConsolePrintf(\"%c\", endBracket);\n#endif\n}\n\n/** Write debug info for this Var out to the console */\nvoid jsvTrace(JsVar *var, int indent) {\n  _jsvTrace(var,indent,var,0);\n  jsiConsolePrintf(\"\\n\");\n}\n\n\n/** Recursively mark the variable */\nstatic void jsvGarbageCollectMarkUsed(JsVar *var) {\n  var->flags &= (JsVarFlags)~JSV_GARBAGE_COLLECT;\n\n  if (jsvHasCharacterData(var)) {\n    // non-recursively scan strings\n    JsVarRef child = jsvGetLastChild(var);\n    while (child) {\n      JsVar *childVar;\n      childVar = jsvGetAddressOf(child);\n      childVar->flags &= (JsVarFlags)~JSV_GARBAGE_COLLECT;\n      child = jsvGetLastChild(childVar);\n    }\n  }\n  // intentionally no else\n  if (jsvHasSingleChild(var)) {\n    if (jsvGetFirstChild(var)) {\n      JsVar *childVar = jsvGetAddressOf(jsvGetFirstChild(var));\n      if (childVar->flags & JSV_GARBAGE_COLLECT)\n        jsvGarbageCollectMarkUsed(childVar);\n    }\n  } else if (jsvHasChildren(var)) {\n    JsVarRef child = jsvGetFirstChild(var);\n    while (child) {\n      JsVar *childVar;\n      childVar = jsvGetAddressOf(child);\n      if (childVar->flags & JSV_GARBAGE_COLLECT)\n        jsvGarbageCollectMarkUsed(childVar);\n      child = jsvGetNextSibling(childVar);\n    }\n  }\n}\n\n/** Run a garbage collection sweep - return nonzero if things have been freed */\nint jsvGarbageCollect() {\n  if (isMemoryBusy) return false;\n  isMemoryBusy = MEMBUSY_GC;\n  JsVarRef i;\n  // Add GC flags to anything that is currently used\n  for (i=1;i<=jsVarsSize;i++)  {\n    JsVar *var = jsvGetAddressOf(i);\n    if ((var->flags&JSV_VARTYPEMASK) != JSV_UNUSED) { // if it is not unused\n      var->flags |= (JsVarFlags)JSV_GARBAGE_COLLECT;\n      // if we have a flat string, skip that many blocks\n      if (jsvIsFlatString(var))\n        i = (JsVarRef)(i+jsvGetFlatStringBlocks(var));\n    }\n  }\n  /* recursively remove anything that is referenced from a var that is locked. */\n  for (i=1;i<=jsVarsSize;i++)  {\n    JsVar *var = jsvGetAddressOf(i);\n    if ((var->flags & JSV_GARBAGE_COLLECT) && // not already GC'd\n        jsvGetLocks(var)>0) // or it is locked\n      jsvGarbageCollectMarkUsed(var);\n    // if we have a flat string, skip that many blocks\n    if (jsvIsFlatString(var))\n      i = (JsVarRef)(i+jsvGetFlatStringBlocks(var));\n  }\n  /* now sweep for things that we can GC!\n   * Also update the free list - this means that every new variable that\n   * gets allocated gets allocated towards the start of memory, which\n   * hopefully helps compact everything towards the start. */\n  unsigned int freedCount = 0;\n  jsVarFirstEmpty = 0;\n  JsVar *lastEmpty = 0;\n  for (i=1;i<=jsVarsSize;i++)  {\n    JsVar *var = jsvGetAddressOf(i);\n    if (var->flags & JSV_GARBAGE_COLLECT) {\n      if (jsvIsFlatString(var)) {\n        // If we're a flat string, there are more blocks to free.\n        unsigned int count = (unsigned int)jsvGetFlatStringBlocks(var);\n        freedCount+=count;\n        // Free the first block\n        var->flags = JSV_UNUSED;\n        // add this to our free list\n        if (lastEmpty) jsvSetNextSibling(lastEmpty, i);\n        else jsVarFirstEmpty = i;\n        lastEmpty = var;\n        // free subsequent blocks\n        while (count-- > 0) {\n          i++;\n          var = jsvGetAddressOf((JsVarRef)(i));\n          var->flags = JSV_UNUSED;\n          // add this to our free list\n          if (lastEmpty) jsvSetNextSibling(lastEmpty, i);\n          else jsVarFirstEmpty = i;\n          lastEmpty = var;\n        }\n      } else {\n        // otherwise just free 1 block\n        if (jsvHasSingleChild(var)) {\n          /* If this had a child that wasn't listed for GC then we need to\n           * unref it. Everything else is fine because it'll disappear anyway.\n           * We don't have to check if we should free this other variable\n           * here because we know the GC picked up it was referenced from\n           * somewhere else. */\n          JsVarRef ch = jsvGetFirstChild(var);\n          if (ch) {\n            JsVar *child = jsvGetAddressOf(ch); // not locked\n            if (child->flags!=JSV_UNUSED && // not already GC'd!\n                !(child->flags&JSV_GARBAGE_COLLECT)) // not marked for GC\n              jsvUnRef(child);\n          }\n        }\n        /* Sanity checks here. We're making sure that any variables that are\n         * linked from this one have either already been garbage collected or\n         * are marked for GC */\n        assert(!jsvHasChildren(var) || !jsvGetFirstChild(var) ||\n            jsvGetAddressOf(jsvGetFirstChild(var))->flags==JSV_UNUSED ||\n            (jsvGetAddressOf(jsvGetFirstChild(var))->flags&JSV_GARBAGE_COLLECT));\n        assert(!jsvHasChildren(var) || !jsvGetLastChild(var) ||\n            jsvGetAddressOf(jsvGetLastChild(var))->flags==JSV_UNUSED ||\n            (jsvGetAddressOf(jsvGetLastChild(var))->flags&JSV_GARBAGE_COLLECT));\n        assert(!jsvIsName(var) || !jsvGetPrevSibling(var) ||\n            jsvGetAddressOf(jsvGetPrevSibling(var))->flags==JSV_UNUSED ||\n            (jsvGetAddressOf(jsvGetPrevSibling(var))->flags&JSV_GARBAGE_COLLECT));\n        assert(!jsvIsName(var) || !jsvGetNextSibling(var) ||\n            jsvGetAddressOf(jsvGetNextSibling(var))->flags==JSV_UNUSED ||\n            (jsvGetAddressOf(jsvGetNextSibling(var))->flags&JSV_GARBAGE_COLLECT));\n        // free!\n        var->flags = JSV_UNUSED;\n        // add this to our free list\n        if (lastEmpty) jsvSetNextSibling(lastEmpty, i);\n        else jsVarFirstEmpty = i;\n        lastEmpty = var;\n        freedCount++;\n      }\n    } else if (jsvIsFlatString(var)) {\n      // if we have a flat string, skip forward that many blocks\n      i = (JsVarRef)(i+jsvGetFlatStringBlocks(var));\n    } else if (var->flags == JSV_UNUSED) {\n      // this is already free - add it to the free list\n      if (lastEmpty) jsvSetNextSibling(lastEmpty, i);\n      else jsVarFirstEmpty = i;\n      lastEmpty = var;\n    }\n  }\n  if (lastEmpty) jsvSetNextSibling(lastEmpty, 0);\n  isMemoryBusy = MEM_NOT_BUSY;\n  return (int)freedCount;\n}\n\n#ifndef RELEASE\n// Dump any locked variables that aren't referenced from `global` - for debugging memory leaks\nvoid jsvDumpLockedVars() {\n  jsvGarbageCollect();\n  if (isMemoryBusy) return;\n  isMemoryBusy = MEMBUSY_SYSTEM;\n  JsVarRef i;\n  // clear garbage collect flags\n  for (i=1;i<=jsVarsSize;i++)  {\n    JsVar *var = jsvGetAddressOf(i);\n    if ((var->flags&JSV_VARTYPEMASK) != JSV_UNUSED) { // if it is not unused\n      var->flags |= (JsVarFlags)JSV_GARBAGE_COLLECT;\n      // if we have a flat string, skip that many blocks\n      if (jsvIsFlatString(var))\n        i = (JsVarRef)(i+jsvGetFlatStringBlocks(var));\n    }\n  }\n  // Add global\n  jsvGarbageCollectMarkUsed(execInfo.root);\n  // Now dump any that aren't used!\n  for (i=1;i<=jsVarsSize;i++)  {\n    JsVar *var = jsvGetAddressOf(i);\n    if ((var->flags&JSV_VARTYPEMASK) != JSV_UNUSED) {\n      if (var->flags & JSV_GARBAGE_COLLECT) {\n        jsvGarbageCollectMarkUsed(var);\n        jsvTrace(var, 0);\n      }\n    }\n  }\n  isMemoryBusy = MEM_NOT_BUSY;\n}\n\n// Dump the free list - in order\nvoid jsvDumpFreeList() {\n  JsVarRef ref = jsVarFirstEmpty;\n  int n = 0;\n  while (ref) {\n    jsiConsolePrintf(\"%5d \", (int)ref);\n    if (++n >= 16) {\n      n = 0;\n      jsiConsolePrintf(\"\\n\");\n    }\n    JsVar *v = jsvGetAddressOf(ref);\n    ref = jsvGetNextSibling(v);\n  }\n  jsiConsolePrintf(\"\\n\");\n}\n#endif\n\n\n/** Remove whitespace to the right of a string - on MULTIPLE LINES */\nJsVar *jsvStringTrimRight(JsVar *srcString) {\n  JsvStringIterator src, dst;\n  JsVar *dstString = jsvNewFromEmptyString();\n  jsvStringIteratorNew(&src, srcString, 0);\n  jsvStringIteratorNew(&dst, dstString, 0);\n  int spaces = 0;\n  while (jsvStringIteratorHasChar(&src)) {\n    char ch = jsvStringIteratorGetChar(&src);\n    jsvStringIteratorNext(&src);\n\n    if (ch==' ') spaces++;\n    else if (ch=='\\n') {\n      spaces = 0;\n      jsvStringIteratorAppend(&dst, ch);\n    } else {\n      for (;spaces>0;spaces--)\n        jsvStringIteratorAppend(&dst, ' ');\n      jsvStringIteratorAppend(&dst, ch);\n    }\n  }\n  jsvStringIteratorFree(&src);\n  jsvStringIteratorFree(&dst);\n  return dstString;\n}\n\n/// If v is the key of a function, return true if it is internal and shouldn't be visible to the user\nbool jsvIsInternalFunctionKey(JsVar *v) {\n  return (jsvIsString(v) && (\n      v->varData.str[0]==JS_HIDDEN_CHAR)\n  ) ||\n  jsvIsFunctionParameter(v);\n}\n\n/// If v is the key of an object, return true if it is internal and shouldn't be visible to the user\nbool jsvIsInternalObjectKey(JsVar *v) {\n  return (jsvIsString(v) && (\n      v->varData.str[0]==JS_HIDDEN_CHAR ||\n      jsvIsStringEqual(v, JSPARSE_INHERITS_VAR) ||\n      jsvIsStringEqual(v, JSPARSE_CONSTRUCTOR_VAR)\n  ));\n}\n\n/// Get the correct checker function for the given variable. see jsvIsInternalFunctionKey/jsvIsInternalObjectKey\nJsvIsInternalChecker jsvGetInternalFunctionCheckerFor(JsVar *v) {\n  if (jsvIsFunction(v)) return jsvIsInternalFunctionKey;\n  if (jsvIsObject(v)) return jsvIsInternalObjectKey;\n  return 0;\n}\n\n/** Using 'configs', this reads 'object' into the given pointers, returns true on success.\n *  If object is not undefined and not an object, an error is raised.\n *  If there are fields that are not  in the list of configs, an error is raised\n */\nbool jsvReadConfigObject(JsVar *object, jsvConfigObject *configs, int nConfigs) {\n  if (jsvIsUndefined(object)) return true;\n  if (!jsvIsObject(object)) {\n    jsExceptionHere(JSET_ERROR, \"Expecting an Object, or undefined\");\n    return false;\n  }\n  // Ok, it's an object\n  JsvObjectIterator it;\n  jsvObjectIteratorNew(&it, object);\n  bool ok = true;\n  while (ok && jsvObjectIteratorHasValue(&it)) {\n    JsVar *key = jsvObjectIteratorGetKey(&it);\n    bool found = false;\n    int i;\n    for (i=0;i<nConfigs;i++) {\n      if (jsvIsStringEqual(key, configs[i].name)) {\n        found = true;\n        if (configs[i].ptr) {\n          JsVar *val = jsvObjectIteratorGetValue(&it);\n          switch (configs[i].type) {\n          case 0: break;\n          case JSV_OBJECT:\n          case JSV_STRING_0:\n          case JSV_ARRAY:\n          case JSV_FUNCTION:\n            *((JsVar**)configs[i].ptr) = jsvLockAgain(val); break;\n          case JSV_PIN: *((Pin*)configs[i].ptr) = jshGetPinFromVar(val); break;\n          case JSV_BOOLEAN: *((bool*)configs[i].ptr) = jsvGetBool(val); break;\n          case JSV_INTEGER: *((JsVarInt*)configs[i].ptr) = jsvGetInteger(val); break;\n          case JSV_FLOAT: *((JsVarFloat*)configs[i].ptr) = jsvGetFloat(val); break;\n          default: assert(0); break;\n          }\n          jsvUnLock(val);\n        }\n      }\n    }\n    if (!found) {\n      jsExceptionHere(JSET_ERROR, \"Unknown option %q\", key);\n      ok = false;\n    }\n    jsvUnLock(key);\n\n    jsvObjectIteratorNext(&it);\n  }\n  jsvObjectIteratorFree(&it);\n  return ok;\n}\n\n/// Is the variable an instance of the given class. Eg. `jsvIsInstanceOf(e, \"Error\")` - does a simple, non-recursive check that doesn't take account of builtins like String\nbool jsvIsInstanceOf(JsVar *var, const char *constructorName) {\n  bool isInst = false;\n  if (!jsvHasChildren(var)) return false;\n  JsVar *proto = jsvObjectGetChild(var, JSPARSE_INHERITS_VAR, 0);\n  if (jsvIsObject(proto)) {\n    JsVar *constr = jsvObjectGetChild(proto, JSPARSE_CONSTRUCTOR_VAR, 0);\n    if (constr)\n      isInst = jspIsConstructor(constr, constructorName);\n    jsvUnLock(constr);\n  }\n  jsvUnLock(proto);\n  return isInst;\n}\n\nJsVar *jsvNewTypedArray(JsVarDataArrayBufferViewType type, JsVarInt length) {\n  JsVar *lenVar = jsvNewFromInteger(length);\n  if (!lenVar) return 0;\n  JsVar *array = jswrap_typedarray_constructor(type, lenVar,0,0);\n  jsvUnLock(lenVar);\n  return array;\n}\n\n#ifndef SAVE_ON_FLASH\nJsVar *jsvNewDataViewWithData(JsVarInt length, unsigned char *data) {\n  JsVar *buf = jswrap_arraybuffer_constructor(length);\n  if (!buf) return 0;\n  JsVar *view = jswrap_dataview_constructor(buf, 0, 0);\n  if (!view) {\n    jsvUnLock(buf);\n    return 0;\n  }\n  if (data) {\n    JsVar *arrayBufferData = jsvGetArrayBufferBackingString(buf);\n    if (arrayBufferData)\n      jsvSetString(arrayBufferData, (char *)data, (size_t)length);\n    jsvUnLock(arrayBufferData);\n  }\n  jsvUnLock(buf);\n  return view;\n}\n#endif\n\nJsVar *jsvNewArrayBufferWithPtr(unsigned int length, char **ptr) {\n  assert(ptr);\n  *ptr=0;\n  JsVar *backingString = jsvNewFlatStringOfLength(length);\n  if (!backingString) return 0;\n  JsVar *arr = jsvNewArrayBufferFromString(backingString, length);\n  if (!arr) {\n    jsvUnLock(backingString);\n    return 0;\n  }\n  *ptr = jsvGetFlatStringPointer(backingString);\n  jsvUnLock(backingString);\n  return arr;\n}\n\nJsVar *jsvNewArrayBufferWithData(JsVarInt length, unsigned char *data) {\n  assert(data);\n  JsVar *dst = 0;\n  JsVar *arr = jsvNewArrayBufferWithPtr((unsigned int)length, (char**)&dst);\n  if (!dst) {\n    jsvUnLock(arr);\n    return 0;\n  }\n  memcpy(dst, data, (size_t)length);\n  return arr;\n}\n\nvoid *jsvMalloc(size_t size) {\n  /** Allocate flat string, return pointer to its first element.\n   * As we drop the pointer here, it's left locked. jsvGetFlatStringPointer\n   * is also safe if 0 is passed in.  */\n  JsVar *flatStr = jsvNewFlatStringOfLength((unsigned int)size);\n  if (!flatStr) {\n    jsErrorFlags |= JSERR_LOW_MEMORY;\n    // Not allocated - try and free any command history/etc\n    while (jsiFreeMoreMemory());\n    // Garbage collect\n    jsvGarbageCollect();\n    // Try again\n    flatStr = jsvNewFlatStringOfLength((unsigned int)size);\n  }\n  // intentionally no jsvUnLock - see above\n  void *p = (void*)jsvGetFlatStringPointer(flatStr);\n  if (p) {\n    //jsiConsolePrintf(\"jsvMalloc var %d-%d at %d (%d bytes)\\n\", jsvGetRef(flatStr), jsvGetRef(flatStr)+jsvGetFlatStringBlocks(flatStr), p, size);\n    memset(p,0,size);\n  }\n  return p;\n}\n\nvoid jsvFree(void *ptr) {\n  JsVar *flatStr = jsvGetFlatStringFromPointer((char *)ptr);\n  //jsiConsolePrintf(\"jsvFree var %d at %d (%d bytes)\\n\", jsvGetRef(flatStr), ptr, jsvGetLength(flatStr));\n\n  jsvUnLock(flatStr);\n}\n"], "fixing_code": ["/*\n * This file is part of Espruino, a JavaScript interpreter for Microcontrollers\n *\n * Copyright (C) 2013 Gordon Williams <gw@pur3.co.uk>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * ----------------------------------------------------------------------------\n * Variables\n * ----------------------------------------------------------------------------\n */\n#include \"jsvar.h\"\n#include \"jslex.h\"\n#include \"jsparse.h\"\n#include \"jswrap_json.h\"\n#include \"jsinteractive.h\"\n#include \"jswrapper.h\"\n#include \"jswrap_math.h\" // for jswrap_math_mod\n#include \"jswrap_object.h\" // for jswrap_object_toString\n#include \"jswrap_arraybuffer.h\" // for jsvNewTypedArray\n#include \"jswrap_dataview.h\" // for jsvNewDataViewWithData\n\n#ifdef DEBUG\n  /** When freeing, clear the references (nextChild/etc) in the JsVar.\n   * This means we can assert at the end of jsvFreePtr to make sure\n   * everything really is free. */\n  #define CLEAR_MEMORY_ON_FREE\n#endif\n\n/** Basically, JsVars are stored in one big array, so save the need for\n * lots of memory allocation. On Linux, the arrays are in blocks, so that\n * more blocks can be allocated. We can't use realloc on one big block as\n * this may change the address of vars that are already locked!\n *\n */\n\n#ifdef RESIZABLE_JSVARS\nJsVar **jsVarBlocks = 0;\nunsigned int jsVarsSize = 0;\n#define JSVAR_BLOCK_SIZE 4096\n#define JSVAR_BLOCK_SHIFT 12\n#else\nJsVar jsVars[JSVAR_CACHE_SIZE];\nunsigned int jsVarsSize = JSVAR_CACHE_SIZE;\n#endif\n\ntypedef enum {\n  MEM_NOT_BUSY,\n  MEMBUSY_SYSTEM,\n  MEMBUSY_GC\n} MemBusyType;\n\nvolatile bool touchedFreeList = false;\nvolatile JsVarRef jsVarFirstEmpty; ///< reference of first unused variable (variables are in a linked list)\nvolatile MemBusyType isMemoryBusy; ///< Are we doing garbage collection or similar, so can't access memory?\n\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n\nbool jsvIsRoot(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_ROOT; }\nbool jsvIsPin(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_PIN; }\nbool jsvIsSimpleInt(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_INTEGER; } // is just a very basic integer value\nbool jsvIsInt(const JsVar *v) { return v && ((v->flags&JSV_VARTYPEMASK)==JSV_INTEGER || (v->flags&JSV_VARTYPEMASK)==JSV_PIN || (v->flags&JSV_VARTYPEMASK)==JSV_NAME_INT || (v->flags&JSV_VARTYPEMASK)==JSV_NAME_INT_INT || (v->flags&JSV_VARTYPEMASK)==JSV_NAME_INT_BOOL); }\nbool jsvIsFloat(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_FLOAT; }\nbool jsvIsBoolean(const JsVar *v) { return v && ((v->flags&JSV_VARTYPEMASK)==JSV_BOOLEAN || (v->flags&JSV_VARTYPEMASK)==JSV_NAME_INT_BOOL); }\nbool jsvIsString(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)>=_JSV_STRING_START && (v->flags&JSV_VARTYPEMASK)<=_JSV_STRING_END; } ///< String, or a NAME too\nbool jsvIsBasicString(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)>=JSV_STRING_0 && (v->flags&JSV_VARTYPEMASK)<=JSV_STRING_MAX; } ///< Just a string (NOT a name)\nbool jsvIsStringExt(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)>=JSV_STRING_EXT_0 && (v->flags&JSV_VARTYPEMASK)<=JSV_STRING_EXT_MAX; } ///< The extra bits dumped onto the end of a string to store more data\nbool jsvIsFlatString(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_FLAT_STRING; }\nbool jsvIsNativeString(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_NATIVE_STRING; }\nbool jsvIsNumeric(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)>=_JSV_NUMERIC_START && (v->flags&JSV_VARTYPEMASK)<=_JSV_NUMERIC_END; }\nbool jsvIsFunction(const JsVar *v) { return v && ((v->flags&JSV_VARTYPEMASK)==JSV_FUNCTION || (v->flags&JSV_VARTYPEMASK)==JSV_FUNCTION_RETURN); }\nbool jsvIsFunctionReturn(const JsVar *v) { return v && ((v->flags&JSV_VARTYPEMASK)==JSV_FUNCTION_RETURN); } ///< Is this a function with an implicit 'return' at the start?\nbool jsvIsFunctionParameter(const JsVar *v) { return v && (v->flags&JSV_NATIVE) && jsvIsString(v); }\nbool jsvIsObject(const JsVar *v) { return v && (((v->flags&JSV_VARTYPEMASK)==JSV_OBJECT) || ((v->flags&JSV_VARTYPEMASK)==JSV_ROOT)); }\nbool jsvIsArray(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_ARRAY; }\nbool jsvIsArrayBuffer(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_ARRAYBUFFER; }\nbool jsvIsArrayBufferName(const JsVar *v) { return v && (v->flags&(JSV_VARTYPEMASK))==JSV_ARRAYBUFFERNAME; }\nbool jsvIsNative(const JsVar *v) { return v && (v->flags&JSV_NATIVE)!=0; }\nbool jsvIsNativeFunction(const JsVar *v) { return v && (v->flags&(JSV_NATIVE|JSV_VARTYPEMASK))==(JSV_NATIVE|JSV_FUNCTION); }\nbool jsvIsUndefined(const JsVar *v) { return v==0; }\nbool jsvIsNull(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_NULL; }\nbool jsvIsBasic(const JsVar *v) { return jsvIsNumeric(v) || jsvIsString(v);} ///< Is this *not* an array/object/etc\nbool jsvIsName(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)>=_JSV_NAME_START && (v->flags&JSV_VARTYPEMASK)<=_JSV_NAME_END; } ///< NAMEs are what's used to name a variable (it is not the data itself)\n/// Names with values have firstChild set to a value - AND NOT A REFERENCE\nbool jsvIsNameWithValue(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)>=_JSV_NAME_WITH_VALUE_START && (v->flags&JSV_VARTYPEMASK)<=_JSV_NAME_WITH_VALUE_END; }\nbool jsvIsNameInt(const JsVar *v) { return v && ((v->flags&JSV_VARTYPEMASK)==JSV_NAME_INT_INT || ((v->flags&JSV_VARTYPEMASK)>=JSV_NAME_STRING_INT_0 && (v->flags&JSV_VARTYPEMASK)<=JSV_NAME_STRING_INT_MAX)); }\nbool jsvIsNameIntInt(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_NAME_INT_INT; }\nbool jsvIsNameIntBool(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_NAME_INT_BOOL; }\n/// What happens when we access a variable that doesn't exist. We get a NAME where the next + previous siblings point to the object that may one day contain them\nbool jsvIsNewChild(const JsVar *v) { return jsvIsName(v) && jsvGetNextSibling(v) && jsvGetNextSibling(v)==jsvGetPrevSibling(v); }\n\n/// Are var.varData.ref.* (excl pad) used for data (so we expect them not to be empty)\nbool jsvIsRefUsedForData(const JsVar *v) { return jsvIsStringExt(v) || (jsvIsString(v)&&!jsvIsName(v)) ||  jsvIsFloat(v) || jsvIsNativeFunction(v) || jsvIsArrayBuffer(v) || jsvIsArrayBufferName(v); }\n\n/// Can the given variable be converted into an integer without loss of precision\nbool jsvIsIntegerish(const JsVar *v) { return jsvIsInt(v) || jsvIsPin(v) || jsvIsBoolean(v) || jsvIsNull(v); }\n\nbool jsvIsIterable(const JsVar *v) {\n  return jsvIsArray(v) || jsvIsObject(v) || jsvIsFunction(v) ||\n         jsvIsString(v) || jsvIsArrayBuffer(v);\n}\n\n\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n\n\n/** Return a pointer - UNSAFE for null refs.\n * This is effectively a Lock without locking! */\nstatic ALWAYS_INLINE JsVar *jsvGetAddressOf(JsVarRef ref) {\n  assert(ref);\n#ifdef RESIZABLE_JSVARS\n  JsVarRef t = ref-1;\n  return &jsVarBlocks[t>>JSVAR_BLOCK_SHIFT][t&(JSVAR_BLOCK_SIZE-1)];\n#else\n  return &jsVars[ref-1];\n#endif\n}\n\nJsVar *_jsvGetAddressOf(JsVarRef ref) {\n  return jsvGetAddressOf(ref);\n}\n\n#ifdef JSVARREF_PACKED_BITS\n#define JSVARREF_PACKED_BIT_MASK ((1U<<JSVARREF_PACKED_BITS)-1)\nJsVarRef jsvGetFirstChild(const JsVar *v) { return (JsVarRef)(v->varData.ref.firstChild | (((v->varData.ref.pack)&JSVARREF_PACKED_BIT_MASK))<<8); }\nJsVarRefSigned jsvGetFirstChildSigned(const JsVar *v) {\n  JsVarRefSigned r = (JsVarRefSigned)jsvGetFirstChild(v);\n  if (r & (1<<(JSVARREF_PACKED_BITS+7)))\n    r -= 1<<(JSVARREF_PACKED_BITS+8);\n  return r;\n}\nJsVarRef jsvGetNextSibling(const JsVar *v) { return (JsVarRef)(v->varData.ref.nextSibling | (((v->varData.ref.pack >> (JSVARREF_PACKED_BITS*2))&JSVARREF_PACKED_BIT_MASK))<<8); }\nJsVarRef jsvGetPrevSibling(const JsVar *v) { return (JsVarRef)(v->varData.ref.prevSibling | (((v->varData.ref.pack >> (JSVARREF_PACKED_BITS*3))&JSVARREF_PACKED_BIT_MASK))<<8); }\nvoid jsvSetFirstChild(JsVar *v, JsVarRef r) {\n  v->varData.ref.firstChild = (unsigned char)(r & 0xFF);\n  v->varData.ref.pack = (unsigned char)((v->varData.ref.pack & ~JSVARREF_PACKED_BIT_MASK) | ((r >> 8) & JSVARREF_PACKED_BIT_MASK));\n}\nvoid jsvSetNextSibling(JsVar *v, JsVarRef r) {\n  v->varData.ref.nextSibling = (unsigned char)(r & 0xFF);\n  v->varData.ref.pack = (unsigned char)((v->varData.ref.pack & ~(JSVARREF_PACKED_BIT_MASK<<(JSVARREF_PACKED_BITS*2))) | (((r >> 8) & JSVARREF_PACKED_BIT_MASK) << (JSVARREF_PACKED_BITS*2)));\n}\nvoid jsvSetPrevSibling(JsVar *v, JsVarRef r) {\n  v->varData.ref.prevSibling = (unsigned char)(r & 0xFF);\n  v->varData.ref.pack = (unsigned char)((v->varData.ref.pack & ~(JSVARREF_PACKED_BIT_MASK<<(JSVARREF_PACKED_BITS*3))) | (((r >> 8) & JSVARREF_PACKED_BIT_MASK) << (JSVARREF_PACKED_BITS*3)));\n}\n/* lastchild stores the upper 2 bits in JsVarFlags because then STRING_EXT can use one more character! */\nJsVarRef jsvGetLastChild(const JsVar *v) {\n  return (JsVarRef)(v->varData.ref.lastChild | (((v->flags >> JSV_LASTCHILD_BIT_SHIFT)&JSVARREF_PACKED_BIT_MASK))<<8);\n}\nvoid jsvSetLastChild(JsVar *v, JsVarRef r) {\n  v->varData.ref.lastChild = (unsigned char)(r & 0xFF);\n  v->flags = (v->flags & ~JSV_LASTCHILD_BIT_MASK) | ((r >> 8) << JSV_LASTCHILD_BIT_SHIFT);\n}\n#endif\n\n\n// For debugging/testing ONLY - maximum # of vars we are allowed to use\nvoid jsvSetMaxVarsUsed(unsigned int size) {\n#ifdef RESIZABLE_JSVARS\n  assert(size < JSVAR_BLOCK_SIZE); // remember - this is only for DEBUGGING - as such it doesn't use multiple blocks\n#else\n  assert(size < JSVAR_CACHE_SIZE);\n#endif\n  jsVarsSize = size;\n}\n\n// maps the empty variables in...\nvoid jsvCreateEmptyVarList() {\n  assert(!isMemoryBusy);\n  isMemoryBusy = MEMBUSY_SYSTEM;\n  jsVarFirstEmpty = 0;\n  JsVar firstVar; // temporary var to simplify code in the loop below\n  jsvSetNextSibling(&firstVar, 0);\n  JsVar *lastEmpty = &firstVar;\n\n  JsVarRef i;\n  for (i=1;i<=jsVarsSize;i++) {\n    JsVar *var = jsvGetAddressOf(i);\n    if ((var->flags&JSV_VARTYPEMASK) == JSV_UNUSED) {\n      jsvSetNextSibling(lastEmpty, i);\n      lastEmpty = var;\n    } else if (jsvIsFlatString(var)) {\n      // skip over used blocks for flat strings\n      i = (JsVarRef)(i+jsvGetFlatStringBlocks(var));\n    }\n  }\n  jsvSetNextSibling(lastEmpty, 0);\n  jsVarFirstEmpty = jsvGetNextSibling(&firstVar);\n  isMemoryBusy = MEM_NOT_BUSY;\n}\n\n/* Removes the empty variable counter, cleaving clear runs of 0s\n where no data resides. This helps if compressing the variables\n for storage. */\nvoid jsvClearEmptyVarList() {\n  assert(!isMemoryBusy);\n  isMemoryBusy = MEMBUSY_SYSTEM;\n  jsVarFirstEmpty = 0;\n  JsVarRef i;\n  for (i=1;i<=jsVarsSize;i++) {\n    JsVar *var = jsvGetAddressOf(i);\n    if ((var->flags&JSV_VARTYPEMASK) == JSV_UNUSED) {\n      // completely zero it (JSV_UNUSED==0, so it still stays the same)\n      memset((void*)var,0,sizeof(JsVar));\n    } else if (jsvIsFlatString(var)) {\n      // skip over used blocks for flat strings\n      i = (JsVarRef)(i+jsvGetFlatStringBlocks(var));\n    }\n  }\n  isMemoryBusy = MEM_NOT_BUSY;\n}\n\nvoid jsvSoftInit() {\n  jsvCreateEmptyVarList();\n}\n\nvoid jsvSoftKill() {\n  jsvClearEmptyVarList();\n}\n\n/** This links all JsVars together, so we can have our nice\n * linked list of free JsVars. It returns the ref of the first\n * item - that we should set jsVarFirstEmpty to (if it is 0) */\nstatic JsVarRef jsvInitJsVars(JsVarRef start, unsigned int count) {\n  JsVarRef i;\n  for (i=start;i<start+count;i++) {\n    JsVar *v = jsvGetAddressOf(i);\n    v->flags = JSV_UNUSED;\n    // v->locks = 0; // locks is 0 anyway because it is stored in flags\n    jsvSetNextSibling(v, (JsVarRef)(i+1)); // link to next\n  }\n  jsvSetNextSibling(jsvGetAddressOf((JsVarRef)(start+count-1)), (JsVarRef)0); // set the final one to 0\n  return start;\n}\n\nvoid jsvInit() {\n#ifdef RESIZABLE_JSVARS\n  jsVarsSize = JSVAR_BLOCK_SIZE;\n  jsVarBlocks = malloc(sizeof(JsVar*)); // just 1\n  jsVarBlocks[0] = malloc(sizeof(JsVar) * JSVAR_BLOCK_SIZE);\n#endif\n\n  jsVarFirstEmpty = jsvInitJsVars(1/*first*/, jsVarsSize);\n  jsvSoftInit();\n}\n\nvoid jsvKill() {\n#ifdef RESIZABLE_JSVARS\n  unsigned int i;\n  for (i=0;i<jsVarsSize>>JSVAR_BLOCK_SHIFT;i++)\n    free(jsVarBlocks[i]);\n  free(jsVarBlocks);\n  jsVarBlocks = 0;\n  jsVarsSize = 0;\n#endif\n}\n\n/** Find or create the ROOT variable item - used mainly\n * if recovering from a saved state. */\nJsVar *jsvFindOrCreateRoot() {\n  JsVarRef i;\n  for (i=1;i<=jsVarsSize;i++)\n    if (jsvIsRoot(jsvGetAddressOf(i)))\n      return jsvLock(i);\n\n  return jsvRef(jsvNewWithFlags(JSV_ROOT));\n}\n\n/// Get number of memory records (JsVars) used\nunsigned int jsvGetMemoryUsage() {\n  unsigned int usage = 0;\n  unsigned int i;\n  for (i=1;i<=jsVarsSize;i++) {\n    JsVar *v = jsvGetAddressOf((JsVarRef)i);\n    if ((v->flags&JSV_VARTYPEMASK) != JSV_UNUSED) {\n      usage++;\n      if (jsvIsFlatString(v)) {\n        unsigned int b = (unsigned int)jsvGetFlatStringBlocks(v);\n        i+=b;\n        usage+=b;\n      }\n    }\n  }\n  return usage;\n}\n\n/// Get total amount of memory records\nunsigned int jsvGetMemoryTotal() {\n  return jsVarsSize;\n}\n\n/// Try and allocate more memory - only works if RESIZABLE_JSVARS is defined\nvoid jsvSetMemoryTotal(unsigned int jsNewVarCount) {\n#ifdef RESIZABLE_JSVARS\n  assert(!isMemoryBusy);\n  if (jsNewVarCount <= jsVarsSize) return; // never allow us to have less!\n  isMemoryBusy = MEMBUSY_SYSTEM;\n  // When resizing, we just allocate a bunch more\n  unsigned int oldSize = jsVarsSize;\n  unsigned int oldBlockCount = jsVarsSize >> JSVAR_BLOCK_SHIFT;\n  unsigned int newBlockCount = (jsNewVarCount+JSVAR_BLOCK_SIZE-1) >> JSVAR_BLOCK_SHIFT;\n  jsVarsSize = newBlockCount << JSVAR_BLOCK_SHIFT;\n  // resize block table\n  jsVarBlocks = realloc(jsVarBlocks, sizeof(JsVar*)*newBlockCount);\n  // allocate more blocks\n  unsigned int i;\n  for (i=oldBlockCount;i<newBlockCount;i++)\n    jsVarBlocks[i] = malloc(sizeof(JsVar) * JSVAR_BLOCK_SIZE);\n  /** and now reset all the newly allocated vars. We know jsVarFirstEmpty\n   * is 0 (because jsiFreeMoreMemory returned 0) so we can just assign it.  */\n  assert(!jsVarFirstEmpty);\n  jsVarFirstEmpty = jsvInitJsVars(oldSize+1, jsVarsSize-oldSize);\n  // jsiConsolePrintf(\"Resized memory from %d blocks to %d\\n\", oldBlockCount, newBlockCount);\n  touchedFreeList = true;\n  isMemoryBusy = MEM_NOT_BUSY;\n#else\n  NOT_USED(jsNewVarCount);\n  assert(0);\n#endif\n}\n\nbool jsvMoreFreeVariablesThan(unsigned int vars) {\n  if (!vars) return false;\n  JsVarRef r = jsVarFirstEmpty;\n  while (r) {\n    if (!vars--) return true;\n    r = jsvGetNextSibling(jsvGetAddressOf(r));\n  }\n  return false;\n}\n\n/// Get whether memory is full or not\nbool jsvIsMemoryFull() {\n  return !jsVarFirstEmpty;\n}\n\n// Show what is still allocated, for debugging memory problems\nvoid jsvShowAllocated() {\n  JsVarRef i;\n  for (i=1;i<=jsVarsSize;i++) {\n    if ((jsvGetAddressOf(i)->flags&JSV_VARTYPEMASK) != JSV_UNUSED) {\n      jsiConsolePrintf(\"USED VAR #%d:\",i);\n      jsvTrace(jsvGetAddressOf(i), 2);\n    }\n  }\n}\n\nbool jsvHasCharacterData(const JsVar *v) {\n  return jsvIsString(v) || jsvIsStringExt(v);\n}\n\nbool jsvHasStringExt(const JsVar *v) {\n  return jsvIsString(v) || jsvIsStringExt(v);\n}\n\nbool jsvHasChildren(const JsVar *v) {\n  return jsvIsFunction(v) || jsvIsObject(v) || jsvIsArray(v) || jsvIsRoot(v);\n}\n\n/// Is this variable a type that uses firstChild to point to a single Variable (ie. it doesn't have multiple children)\nbool jsvHasSingleChild(const JsVar *v) {\n  return jsvIsArrayBuffer(v) ||\n      (jsvIsName(v) && !jsvIsNameWithValue(v));\n}\n\n/** Return the is the number of characters this one JsVar can contain, NOT string length (eg, a chain of JsVars)\n * This will return an invalid length when applied to Flat Strings */\nsize_t jsvGetMaxCharactersInVar(const JsVar *v) {\n  // see jsvCopy - we need to know about this in there too\n  if (jsvIsStringExt(v)) return JSVAR_DATA_STRING_MAX_LEN;\n  assert(jsvHasCharacterData(v));\n  if (jsvIsName(v)) return JSVAR_DATA_STRING_NAME_LEN;\n  return JSVAR_DATA_STRING_LEN;\n}\n\n/// This is the number of characters a JsVar can contain, NOT string length\nsize_t jsvGetCharactersInVar(const JsVar *v) {\n  unsigned int f = v->flags&JSV_VARTYPEMASK;\n  if (f == JSV_FLAT_STRING)\n    return (size_t)v->varData.integer;\n  if (f == JSV_NATIVE_STRING)\n    return (size_t)v->varData.nativeStr.len;\n  assert(f >= JSV_NAME_STRING_INT_0);\n  assert((JSV_NAME_STRING_INT_0 < JSV_NAME_STRING_0) &&\n         (JSV_NAME_STRING_0 < JSV_STRING_0) &&\n         (JSV_STRING_0 < JSV_STRING_EXT_0)); // this relies on ordering\n  if (f<=JSV_NAME_STRING_MAX) {\n    if (f<=JSV_NAME_STRING_INT_MAX)\n      return f-JSV_NAME_STRING_INT_0;\n    else\n      return f-JSV_NAME_STRING_0;\n  } else {\n    if (f<=JSV_STRING_MAX) return f-JSV_STRING_0;\n    assert(f <= JSV_STRING_EXT_MAX);\n    return f - JSV_STRING_EXT_0;\n  }\n}\n\n/// This is the number of characters a JsVar can contain, NOT string length\nvoid jsvSetCharactersInVar(JsVar *v, size_t chars) {\n  unsigned int f = v->flags&JSV_VARTYPEMASK;\n  assert(!(jsvIsFlatString(v) || jsvIsNativeString(v)));\n\n  JsVarFlags m = (JsVarFlags)(v->flags&~JSV_VARTYPEMASK);\n  assert(f >= JSV_NAME_STRING_INT_0);\n  assert((JSV_NAME_STRING_INT_0 < JSV_NAME_STRING_0) &&\n         (JSV_NAME_STRING_0 < JSV_STRING_0) &&\n         (JSV_STRING_0 < JSV_STRING_EXT_0)); // this relies on ordering\n  if (f<=JSV_NAME_STRING_MAX) {\n    assert(chars <= JSVAR_DATA_STRING_NAME_LEN);\n    if (f<=JSV_NAME_STRING_INT_MAX)\n      v->flags = (JsVarFlags)(m | (JSV_NAME_STRING_INT_0+chars));\n    else\n      v->flags = (JsVarFlags)(m | (JSV_NAME_STRING_0+chars));\n  } else {\n    if (f<=JSV_STRING_MAX) {\n      assert(chars <= JSVAR_DATA_STRING_LEN);\n      v->flags = (JsVarFlags)(m | (JSV_STRING_0+chars));\n    } else {\n      assert(chars <= JSVAR_DATA_STRING_MAX_LEN);\n      assert(f <= JSV_STRING_EXT_MAX);\n      v->flags = (JsVarFlags)(m | (JSV_STRING_EXT_0+chars));\n    }\n  }\n}\n\nvoid jsvResetVariable(JsVar *v, JsVarFlags flags) {\n  assert((v->flags&JSV_VARTYPEMASK) == JSV_UNUSED);\n  // make sure we clear all data...\n  /* Force a proper zeroing of all data. We don't use\n   * memset because that'd create a function call. This\n   * should just generate a bunch of STR instructions */\n  unsigned int i;\n  assert((sizeof(JsVar)&3) == 0); // must be a multiple of 4 in size\n  for (i=0;i<sizeof(JsVar)/sizeof(uint32_t);i++)\n    ((uint32_t*)v)[i] = 0;\n  // set flags\n  assert(!(flags & JSV_LOCK_MASK));\n  v->flags = flags | JSV_LOCK_ONE;\n}\n\nJsVar *jsvNewWithFlags(JsVarFlags flags) {\n  if (isMemoryBusy) {\n    jsErrorFlags |= JSERR_MEMORY_BUSY;\n    return 0;\n  }\n  JsVar *v = 0;\n  jshInterruptOff(); // to allow this to be used from an IRQ\n  if (jsVarFirstEmpty!=0) {\n    v = jsvGetAddressOf(jsVarFirstEmpty); // jsvResetVariable will lock\n    jsVarFirstEmpty = jsvGetNextSibling(v); // move our reference to the next in the fr\n    touchedFreeList = true;\n  }\n  jshInterruptOn();\n  if (v) {\n    assert(v->flags == JSV_UNUSED);\n    // Cope with IRQs/multi-threading when getting a new free variable\n /*   JsVarRef empty;\n    JsVarRef next;\n    JsVar *v;\n    do {\n      empty = jsVarFirstEmpty;\n      v = jsvGetAddressOf(empty); // jsvResetVariable will lock\n      next = jsvGetNextSibling(v); // move our reference to the next in the free list\n      touchedFreeList = true;\n    } while (!__sync_bool_compare_and_swap(&jsVarFirstEmpty, empty, next));\n    assert(v->flags == JSV_UNUSED);*/\n    jsvResetVariable(v, flags); // setup variable, and add one lock\n    // return pointer\n    return v;\n  }\n  jsErrorFlags |= JSERR_LOW_MEMORY;\n  /* If we're calling from an IRQ, do NOT try and do fancy\n   * stuff to free memory */\n  if (jshIsInInterrupt()) {\n    return 0;\n  }\n  /* we don't have memory - second last hope - run garbage collector */\n  if (jsvGarbageCollect()) {\n    return jsvNewWithFlags(flags); // if it freed something, continue\n  }\n  /* we don't have memory - last hope - ask jsInteractive to try and free some it\n   may have kicking around */\n  if (jsiFreeMoreMemory()) {\n    return jsvNewWithFlags(flags);\n  }\n  /* We couldn't claim any more memory by Garbage collecting... */\n#ifdef RESIZABLE_JSVARS\n  jsvSetMemoryTotal(jsVarsSize*2);\n  return jsvNewWithFlags(flags);\n#else\n  // On a micro, we're screwed.\n  jsErrorFlags |= JSERR_MEMORY;\n  jspSetInterrupted(true);\n  return 0;\n#endif\n}\n\nstatic NO_INLINE void jsvFreePtrInternal(JsVar *var) {\n  assert(jsvGetLocks(var)==0);\n  var->flags = JSV_UNUSED;\n  // add this to our free list\n  jshInterruptOff(); // to allow this to be used from an IRQ\n  jsvSetNextSibling(var, jsVarFirstEmpty);\n  jsVarFirstEmpty = jsvGetRef(var);\n  touchedFreeList = true;\n  jshInterruptOn();\n}\n\nALWAYS_INLINE void jsvFreePtr(JsVar *var) {\n  /* To be here, we're not supposed to be part of anything else. If\n   * we were, we'd have been freed by jsvGarbageCollect */\n  assert((!jsvGetNextSibling(var) && !jsvGetPrevSibling(var)) || // check that next/prevSibling are not set\n      jsvIsRefUsedForData(var) ||  // UNLESS we're part of a string and nextSibling/prevSibling are used for string data\n      (jsvIsName(var) && (jsvGetNextSibling(var)==jsvGetPrevSibling(var)))); // UNLESS we're signalling that we're jsvIsNewChild\n\n  // Names that Link to other things\n  if (jsvIsNameWithValue(var)) {\n#ifdef CLEAR_MEMORY_ON_FREE\n    jsvSetFirstChild(var, 0); // it just contained random data - zero it\n#endif // CLEAR_MEMORY_ON_FREE\n  } else if (jsvHasSingleChild(var)) {\n    if (jsvGetFirstChild(var)) {\n      JsVar *child = jsvLock(jsvGetFirstChild(var));\n      jsvUnRef(child);\n#ifdef CLEAR_MEMORY_ON_FREE\n      jsvSetFirstChild(var, 0); // unlink the child\n#endif // CLEAR_MEMORY_ON_FREE\n      jsvUnLock(child); // unlock should trigger a free\n    }\n  }\n  /* No else, because a String Name may have a single child, but\n   * also StringExts  */\n\n  /* Now, free children - see jsvar.h comments for how! */\n  if (jsvHasStringExt(var)) {\n    // Free the string without recursing\n    JsVarRef stringDataRef = jsvGetLastChild(var);\n#ifdef CLEAR_MEMORY_ON_FREE\n    jsvSetLastChild(var, 0);\n#endif // CLEAR_MEMORY_ON_FREE\n    while (stringDataRef) {\n      JsVar *child = jsvGetAddressOf(stringDataRef);\n      assert(jsvIsStringExt(child));\n      stringDataRef = jsvGetLastChild(child);\n      jsvFreePtrInternal(child);\n    }\n    // We might be a flat string\n    if (jsvIsFlatString(var)) {\n      // in which case we need to free all the blocks.\n      size_t count = jsvGetFlatStringBlocks(var);\n      JsVarRef i = (JsVarRef)(jsvGetRef(var)+count);\n      // do it in reverse, so the free list ends up in kind of the right order\n      while (count--) {\n        JsVar *p = jsvGetAddressOf(i--);\n        p->flags = JSV_UNUSED; // set locks to 0 so the assert in jsvFreePtrInternal doesn't get fed up\n        jsvFreePtrInternal(p);\n      }\n    } else if (jsvIsBasicString(var)) {\n#ifdef CLEAR_MEMORY_ON_FREE\n      jsvSetFirstChild(var, 0); // firstchild could have had string data in\n#endif // CLEAR_MEMORY_ON_FREE\n    }\n\n  }\n  /* NO ELSE HERE - because jsvIsNewChild stuff can be for Names, which\n    can be ints or strings */\n\n  if (jsvHasChildren(var)) {\n    JsVarRef childref = jsvGetFirstChild(var);\n#ifdef CLEAR_MEMORY_ON_FREE\n    jsvSetFirstChild(var, 0);\n    jsvSetLastChild(var, 0);\n#endif // CLEAR_MEMORY_ON_FREE\n    while (childref) {\n      JsVar *child = jsvLock(childref);\n      assert(jsvIsName(child));\n      childref = jsvGetNextSibling(child);\n      jsvSetPrevSibling(child, 0);\n      jsvSetNextSibling(child, 0);\n      jsvUnRef(child);\n      jsvUnLock(child);\n    }\n  } else {\n#ifdef CLEAR_MEMORY_ON_FREE\n#if JSVARREF_SIZE==1\n    assert(jsvIsFloat(var) || !jsvGetFirstChild(var));\n    assert(jsvIsFloat(var) || !jsvGetLastChild(var));\n#else\n    assert(!jsvGetFirstChild(var)); // strings use firstchild now as well\n    assert(!jsvGetLastChild(var));\n#endif\n#endif // CLEAR_MEMORY_ON_FREE\n    if (jsvIsName(var)) {\n      assert(jsvGetNextSibling(var)==jsvGetPrevSibling(var)); // the case for jsvIsNewChild\n      if (jsvGetNextSibling(var)) {\n        jsvUnRefRef(jsvGetNextSibling(var));\n        jsvUnRefRef(jsvGetPrevSibling(var));\n      }\n    }\n  }\n\n  // free!\n  jsvFreePtrInternal(var);\n}\n\n/// Get a reference from a var - SAFE for null vars\nALWAYS_INLINE JsVarRef jsvGetRef(JsVar *var) {\n  if (!var) return 0;\n#ifdef RESIZABLE_JSVARS\n  unsigned int i, c = jsVarsSize>>JSVAR_BLOCK_SHIFT;\n  for (i=0;i<c;i++) {\n    if (var>=jsVarBlocks[i] && var<&jsVarBlocks[i][JSVAR_BLOCK_SIZE]) {\n      JsVarRef r = (JsVarRef)(1 + (i<<JSVAR_BLOCK_SHIFT) + (var - jsVarBlocks[i]));\n      return r;\n    }\n  }\n  return 0;\n#else\n  return (JsVarRef)(1 + (var - jsVars));\n#endif\n}\n\n/// Lock this reference and return a pointer - UNSAFE for null refs\nALWAYS_INLINE JsVar *jsvLock(JsVarRef ref) {\n  JsVar *var = jsvGetAddressOf(ref);\n  //var->locks++;\n  assert(jsvGetLocks(var) < JSV_LOCK_MAX);\n  var->flags += JSV_LOCK_ONE;\n#ifdef DEBUG\n  if (jsvGetLocks(var)==0) {\n    jsError(\"Too many locks to Variable!\");\n    //jsPrint(\"Var #\");jsPrintInt(ref);jsPrint(\"\\n\");\n  }\n#endif\n  return var;\n}\n\n/// Lock this pointer and return a pointer - UNSAFE for null pointer\nALWAYS_INLINE JsVar *jsvLockAgain(JsVar *var) {\n  assert(var);\n  assert(jsvGetLocks(var) < JSV_LOCK_MAX);\n  var->flags += JSV_LOCK_ONE;\n  return var;\n}\n\n/// Lock this pointer and return a pointer - UNSAFE for null pointer\nALWAYS_INLINE JsVar *jsvLockAgainSafe(JsVar *var) {\n  return var ? jsvLockAgain(var) : 0;\n}\n\n// CALL ONLY FROM jsvUnlock\n// jsvGetLocks(var) must == 0\nstatic NO_INLINE void jsvUnLockFreeIfNeeded(JsVar *var) {\n  assert(jsvGetLocks(var) == 0);\n  /* if we know we're free, then we can just free this variable right now.\n   * Loops of variables are handled by the Garbage Collector.\n   * Note: we checked locks already in jsvUnLock as it is fastest to check */\n  if (jsvGetRefs(var) == 0 &&\n      jsvHasRef(var) &&\n      (var->flags&JSV_VARTYPEMASK)!=JSV_UNUSED) { // we might be in an IRQ now, with GC in the main thread. If so, don't free!\n    jsvFreePtr(var);\n  }\n}\n\n\n/// Unlock this variable - this is SAFE for null variables\nALWAYS_INLINE void jsvUnLock(JsVar *var) {\n  if (!var) return;\n  assert(jsvGetLocks(var)>0);\n  var->flags -= JSV_LOCK_ONE;\n  // Now see if we can properly free the data\n  // Note: we check locks first as they are already in a register\n  if ((var->flags & JSV_LOCK_MASK) == 0) jsvUnLockFreeIfNeeded(var);\n}\n\n/// Unlock 2 variables in one go\nvoid jsvUnLock2(JsVar *var1, JsVar *var2) {\n  jsvUnLock(var1);\n  jsvUnLock(var2);\n}\n/// Unlock 3 variables in one go\nvoid jsvUnLock3(JsVar *var1, JsVar *var2, JsVar *var3) {\n  jsvUnLock(var1);\n  jsvUnLock(var2);\n  jsvUnLock(var3);\n}\n/// Unlock 4 variables in one go\nvoid jsvUnLock4(JsVar *var1, JsVar *var2, JsVar *var3, JsVar *var4) {\n  jsvUnLock(var1);\n  jsvUnLock(var2);\n  jsvUnLock(var3);\n  jsvUnLock(var4);\n}\n\n/// Unlock an array of variables\nNO_INLINE void jsvUnLockMany(unsigned int count, JsVar **vars) {\n  while (count) jsvUnLock(vars[--count]);\n}\n\n/// Reference - set this variable as used by something\nJsVar *jsvRef(JsVar *var) {\n  assert(var && jsvHasRef(var));\n  jsvSetRefs(var, (JsVarRefCounter)(jsvGetRefs(var)+1));\n  assert(jsvGetRefs(var));\n  return var;\n}\n\n/// Unreference - set this variable as not used by anything\nvoid jsvUnRef(JsVar *var) {\n  assert(var && jsvGetRefs(var)>0 && jsvHasRef(var));\n  jsvSetRefs(var, (JsVarRefCounter)(jsvGetRefs(var)-1));\n}\n\n/// Helper fn, Reference - set this variable as used by something\nJsVarRef jsvRefRef(JsVarRef ref) {\n  JsVar *v;\n  assert(ref);\n  v = jsvLock(ref);\n  assert(!jsvIsStringExt(v));\n  jsvRef(v);\n  jsvUnLock(v);\n  return ref;\n}\n\n/// Helper fn, Unreference - set this variable as not used by anything\nJsVarRef jsvUnRefRef(JsVarRef ref) {\n  JsVar *v;\n  assert(ref);\n  v = jsvLock(ref);\n  assert(!jsvIsStringExt(v));\n  jsvUnRef(v);\n  jsvUnLock(v);\n  return 0;\n}\n\nJsVar *jsvNewFlatStringOfLength(unsigned int byteLength) {\n  if (isMemoryBusy) {\n    jsErrorFlags |= JSERR_MEMORY_BUSY;\n    return 0;\n  }\n  // Work out how many blocks we need. One for the header, plus some for the characters\n  size_t requiredBlocks = 1 + ((byteLength+sizeof(JsVar)-1) / sizeof(JsVar));\n\n  JsVar *flatString = 0;\n\n  /* Now try and find a contiguous set of 'requiredBlocks' blocks by\n  searching the free list. This can be done as long as nobody's\n  messed with the free list in the mean time (which we check for with\n  touchedFreeList). If someone has messed with it, we restart.*/\n  bool memoryTouched = true;\n  while (memoryTouched) {\n    memoryTouched = false;\n    touchedFreeList = false;\n    JsVarRef beforeStartBlock = 0;\n    JsVarRef curr = jsVarFirstEmpty;\n    JsVarRef startBlock = curr;\n    unsigned int blockCount = 1;\n    while (curr && !touchedFreeList) {\n      JsVar *currVar = jsvGetAddressOf(curr);\n      JsVarRef next = jsvGetNextSibling(currVar);\n#ifdef RESIZABLE_JSVARS\n      if (next && jsvGetAddressOf(next)==currVar+1) {\n#else\n      if (next == curr+1) {\n#endif\n        blockCount++;\n        if (blockCount>=requiredBlocks) {\n          JsVar *nextVar = jsvGetAddressOf(next);\n          JsVarRef nextFree = jsvGetNextSibling(nextVar);\n          jshInterruptOff();\n          if (!touchedFreeList) {\n            // we're there! Quickly re-link free list\n            if (beforeStartBlock) {\n              jsvSetNextSibling(jsvGetAddressOf(beforeStartBlock),nextFree);\n            } else {\n              jsVarFirstEmpty = nextFree;\n            }\n            flatString = jsvGetAddressOf(startBlock);\n            // Set up the header block (including one lock)\n            jsvResetVariable(flatString, JSV_FLAT_STRING);\n            flatString->varData.integer = (JsVarInt)byteLength;\n          }\n          jshInterruptOn();\n          // if success, break out!\n          if (flatString) break;\n        }\n      } else {\n        // this block is not immediately after the last - restart run\n        blockCount = 1;\n        beforeStartBlock = curr;\n        startBlock = next;\n      }\n      // move to next!\n      curr = next;\n    }\n    // memory list has been touched - restart!\n    if (touchedFreeList) {\n      memoryTouched = true;\n    }\n  }\n\n  /* Nope... we couldn't find a free string. It could be because\n   * the free list is fragmented, so GCing might well fix it - which\n   * we'll try. */\n  if (!flatString) {\n    if (jsvGarbageCollect())\n      return jsvNewFlatStringOfLength(byteLength);\n    return 0;\n  }\n\n  /* We now have the string! All that's left is to clear it,\n   * which we can do outside of an IRQ */\n  // clear data\n  memset((char*)&flatString[1], 0, sizeof(JsVar)*(requiredBlocks-1));\n  /* We did mess with the free list - set it here in case we\n  are trying to create a flat string in an IRQ while trying to\n  make one outside the IRQ too */\n  touchedFreeList = true;\n  // and we're done\n  return flatString;\n}\n\nJsVar *jsvNewFromString(const char *str) {\n  // Create a var\n  JsVar *first = jsvNewWithFlags(JSV_STRING_0);\n  if (!first) return 0; // out of memory\n  // Now we copy the string, but keep creating new jsVars if we go\n  // over the end\n  JsVar *var = jsvLockAgain(first);\n  while (*str) {\n    // copy data in\n    size_t i, l = jsvGetMaxCharactersInVar(var);\n    for (i=0;i<l && *str;i++)\n      var->varData.str[i] = *(str++);\n    // we already set the variable data to 0, so no need for adding one\n\n    // we've stopped if the string was empty\n    jsvSetCharactersInVar(var, i);\n\n    // if there is still some left, it's because we filled up our var...\n    // make a new one, link it in, and unlock the old one.\n    if (*str) {\n      JsVar *next = jsvNewWithFlags(JSV_STRING_EXT_0);\n      if (!next) {\n        // Truncating string as not enough memory\n        jsvUnLock(var);\n        return first;\n      }\n      // we don't ref, because  StringExts are never reffed as they only have one owner (and ALWAYS have an owner)\n      jsvSetLastChild(var, jsvGetRef(next));\n      jsvUnLock(var);\n      var = next;\n    }\n  }\n  jsvUnLock(var);\n  // return\n  return first;\n}\n\nJsVar *jsvNewStringOfLength(unsigned int byteLength, const char *initialData) {\n  // if string large enough, try and make a flat string instead\n  if (byteLength > JSV_FLAT_STRING_BREAK_EVEN) {\n    JsVar *v = jsvNewFlatStringOfLength(byteLength);\n    if (v) {\n      if (initialData) jsvSetString(v, initialData, byteLength);\n      return v;\n    }\n  }\n  // Create a var\n  JsVar *first = jsvNewWithFlags(JSV_STRING_0);\n  if (!first) return 0; // out of memory, will have already set flag\n  // Now keep creating enough new jsVars\n  JsVar *var = jsvLockAgain(first);\n  while (true) {\n    // copy data in\n    unsigned int l = (unsigned int)jsvGetMaxCharactersInVar(var);\n    if (l>=byteLength) {\n      if (initialData)\n        memcpy(var->varData.str, initialData, byteLength);\n      // we've got enough\n      jsvSetCharactersInVar(var, byteLength);\n      break;\n    } else {\n      if (initialData) {\n        memcpy(var->varData.str, initialData, l);\n        initialData+=l;\n      }\n      // We need more\n      jsvSetCharactersInVar(var, l);\n      byteLength -= l;\n      // Make a new one, link it in, and unlock the old one.\n      JsVar *next = jsvNewWithFlags(JSV_STRING_EXT_0);\n      if (!next) break; // out of memory, will have already set flag\n      // we don't ref, because  StringExts are never reffed as they only have one owner (and ALWAYS have an owner)\n      jsvSetLastChild(var, jsvGetRef(next));\n      jsvUnLock(var);\n      var = next;\n    }\n  }\n  jsvUnLock(var);\n  // return\n  return first;\n}\n\nJsVar *jsvNewFromInteger(JsVarInt value) {\n  JsVar *var = jsvNewWithFlags(JSV_INTEGER);\n  if (!var) return 0; // no memory\n  var->varData.integer = value;\n  return var;\n}\nJsVar *jsvNewFromBool(bool value) {\n  JsVar *var = jsvNewWithFlags(JSV_BOOLEAN);\n  if (!var) return 0; // no memory\n  var->varData.integer = value ? 1 : 0;\n  return var;\n}\nJsVar *jsvNewFromFloat(JsVarFloat value) {\n  JsVar *var = jsvNewWithFlags(JSV_FLOAT);\n  if (!var) return 0; // no memory\n  var->varData.floating = value;\n  return var;\n}\nJsVar *jsvNewFromLongInteger(long long value) {\n  if (value>=-2147483648LL && value<=2147483647LL)\n    return jsvNewFromInteger((JsVarInt)value);\n  else\n    return jsvNewFromFloat((JsVarFloat)value);\n}\n\n\nJsVar *jsvMakeIntoVariableName(JsVar *var, JsVar *valueOrZero) {\n  if (!var) return 0;\n  assert(jsvGetRefs(var)==0); // make sure it's unused\n  assert(jsvIsSimpleInt(var) || jsvIsString(var));\n  JsVarFlags varType = (var->flags & JSV_VARTYPEMASK);\n  if (varType==JSV_INTEGER) {\n    int t = JSV_NAME_INT;\n    if ((jsvIsInt(valueOrZero) || jsvIsBoolean(valueOrZero)) && !jsvIsPin(valueOrZero)) {\n      JsVarInt v = valueOrZero->varData.integer;\n      if (v>=JSVARREF_MIN && v<=JSVARREF_MAX) {\n        t = jsvIsInt(valueOrZero) ? JSV_NAME_INT_INT : JSV_NAME_INT_BOOL;\n        jsvSetFirstChild(var, (JsVarRef)v);\n        valueOrZero = 0;\n      }\n    }\n    var->flags = (JsVarFlags)(var->flags & ~JSV_VARTYPEMASK) | t;\n  } else if (varType>=_JSV_STRING_START && varType<=_JSV_STRING_END) {\n    if (jsvGetCharactersInVar(var) > JSVAR_DATA_STRING_NAME_LEN) {\n      /* Argh. String is too large to fit in a JSV_NAME! We must chomp make\n       * new STRINGEXTs to put the data in\n       */\n      JsvStringIterator it;\n      jsvStringIteratorNew(&it, var, JSVAR_DATA_STRING_NAME_LEN);\n      JsVar *startExt = jsvNewWithFlags(JSV_STRING_EXT_0);\n      JsVar *ext = jsvLockAgainSafe(startExt);\n      size_t nChars = 0;\n      while (ext && jsvStringIteratorHasChar(&it)) {\n        if (nChars >= JSVAR_DATA_STRING_MAX_LEN) {\n          jsvSetCharactersInVar(ext, nChars);\n          JsVar *ext2 = jsvNewWithFlags(JSV_STRING_EXT_0);\n          if (ext2) {\n            jsvSetLastChild(ext, jsvGetRef(ext2));\n          }\n          jsvUnLock(ext);\n          ext = ext2;\n          nChars = 0;\n        }\n        ext->varData.str[nChars++] = jsvStringIteratorGetChar(&it);\n        jsvStringIteratorNext(&it);\n      }\n      jsvStringIteratorFree(&it);\n      if (ext) {\n        jsvSetCharactersInVar(ext, nChars);\n        jsvUnLock(ext);\n      }\n      jsvSetCharactersInVar(var, JSVAR_DATA_STRING_NAME_LEN);\n      // Free any old stringexts\n      JsVarRef oldRef = jsvGetLastChild(var);\n      while (oldRef) {\n        JsVar *v = jsvGetAddressOf(oldRef);\n        oldRef = jsvGetLastChild(v);\n        jsvFreePtrInternal(v);\n      }\n      // set up new stringexts\n      jsvSetLastChild(var, jsvGetRef(startExt));\n      jsvSetNextSibling(var, 0);\n      jsvSetPrevSibling(var, 0);\n      jsvSetFirstChild(var, 0);\n      jsvUnLock(startExt);\n    }\n\n    size_t t = JSV_NAME_STRING_0;\n    if (jsvIsInt(valueOrZero) && !jsvIsPin(valueOrZero)) {\n      JsVarInt v = valueOrZero->varData.integer;\n      if (v>=JSVARREF_MIN && v<=JSVARREF_MAX) {\n        t = JSV_NAME_STRING_INT_0;\n        jsvSetFirstChild(var, (JsVarRef)v);\n        valueOrZero = 0;\n      }\n    } else\n      jsvSetFirstChild(var, 0);\n    var->flags = (var->flags & (JsVarFlags)~JSV_VARTYPEMASK) | (t+jsvGetCharactersInVar(var));\n  } else assert(0);\n\n  if (valueOrZero)\n    jsvSetFirstChild(var, jsvGetRef(jsvRef(valueOrZero)));\n  return var;\n}\n\nvoid jsvMakeFunctionParameter(JsVar *v) {\n  assert(jsvIsString(v));\n  if (!jsvIsName(v)) jsvMakeIntoVariableName(v,0);\n  v->flags = (JsVarFlags)(v->flags | JSV_NATIVE);\n}\n\nJsVar *jsvNewFromPin(int pin) {\n  JsVar *v = jsvNewFromInteger((JsVarInt)pin);\n  if (v) {\n    v->flags = (JsVarFlags)((v->flags & ~JSV_VARTYPEMASK) | JSV_PIN);\n  }\n  return v;\n}\n\nJsVar *jsvNewObject() {\n  return jsvNewWithFlags(JSV_OBJECT);\n}\n\nJsVar *jsvNewEmptyArray() {\n  return jsvNewWithFlags(JSV_ARRAY);\n}\n\n/// Create an array containing the given elements\nJsVar *jsvNewArray(JsVar **elements, int elementCount) {\n  JsVar *arr = jsvNewEmptyArray();\n  if (!arr) return 0;\n  int i;\n  for (i=0;i<elementCount;i++)\n    jsvArrayPush(arr, elements[i]);\n  return arr;\n}\n\nJsVar *jsvNewNativeFunction(void (*ptr)(void), unsigned short argTypes) {\n  JsVar *func = jsvNewWithFlags(JSV_FUNCTION | JSV_NATIVE);\n  if (!func) return 0;\n  func->varData.native.ptr = ptr;\n  func->varData.native.argTypes = argTypes;\n  return func;\n}\n\nJsVar *jsvNewNativeString(char *ptr, size_t len) {\n  if (len>JSV_NATIVE_STR_MAX_LENGTH) len=JSV_NATIVE_STR_MAX_LENGTH; // crop string to what we can store in nativeStr.len\n  JsVar *str = jsvNewWithFlags(JSV_NATIVE_STRING);\n  if (!str) return 0;\n  str->varData.nativeStr.ptr = ptr;\n  str->varData.nativeStr.len = (uint16_t)len;\n  return str;\n}\n\nvoid *jsvGetNativeFunctionPtr(const JsVar *function) {\n  /* see descriptions in jsvar.h. If we have a child called JSPARSE_FUNCTION_CODE_NAME\n   * then we execute code straight from that */\n  JsVar *flatString = jsvFindChildFromString((JsVar*)function, JSPARSE_FUNCTION_CODE_NAME, 0);\n  if (flatString) {\n    flatString = jsvSkipNameAndUnLock(flatString);\n    void *v = (void*)((size_t)function->varData.native.ptr + (char*)jsvGetFlatStringPointer(flatString));\n    jsvUnLock(flatString);\n    return v;\n  } else\n    return (void *)function->varData.native.ptr;\n}\n\n/// Create a new ArrayBuffer backed by the given string. If length is not specified, it will be worked out\nJsVar *jsvNewArrayBufferFromString(JsVar *str, unsigned int lengthOrZero) {\n  JsVar *arr = jsvNewWithFlags(JSV_ARRAYBUFFER);\n  if (!arr) return 0;\n  jsvSetFirstChild(arr, jsvGetRef(jsvRef(str)));\n  arr->varData.arraybuffer.type = ARRAYBUFFERVIEW_ARRAYBUFFER;\n  assert(arr->varData.arraybuffer.byteOffset == 0);\n  if (lengthOrZero==0) lengthOrZero = (unsigned int)jsvGetStringLength(str);\n  arr->varData.arraybuffer.length = (unsigned short)lengthOrZero;\n  return arr;\n}\n\nbool jsvIsBasicVarEqual(JsVar *a, JsVar *b) {\n  // quick checks\n  if (a==b) return true;\n  if (!a || !b) return false; // one of them is undefined\n  // OPT: would this be useful as compare instead?\n  assert(jsvIsBasic(a) && jsvIsBasic(b));\n  if (jsvIsNumeric(a) && jsvIsNumeric(b)) {\n    if (jsvIsIntegerish(a)) {\n      if (jsvIsIntegerish(b)) {\n        return a->varData.integer == b->varData.integer;\n      } else {\n        assert(jsvIsFloat(b));\n        return a->varData.integer == b->varData.floating;\n      }\n    } else {\n      assert(jsvIsFloat(a));\n      if (jsvIsIntegerish(b)) {\n        return a->varData.floating == b->varData.integer;\n      } else {\n        assert(jsvIsFloat(b));\n        return a->varData.floating == b->varData.floating;\n      }\n    }\n  } else if (jsvIsString(a) && jsvIsString(b)) {\n    JsvStringIterator ita, itb;\n    jsvStringIteratorNew(&ita, a, 0);\n    jsvStringIteratorNew(&itb, b, 0);\n    while (true) {\n      char a = jsvStringIteratorGetChar(&ita);\n      char b = jsvStringIteratorGetChar(&itb);\n      if (a != b) {\n        jsvStringIteratorFree(&ita);\n        jsvStringIteratorFree(&itb);\n        return false;\n      }\n      if (!a) { // equal, but end of string\n        jsvStringIteratorFree(&ita);\n        jsvStringIteratorFree(&itb);\n        return true;\n      }\n      jsvStringIteratorNext(&ita);\n      jsvStringIteratorNext(&itb);\n    }\n    // we never get here\n    return false; // make compiler happy\n  } else {\n    //TODO: are there any other combinations we should check here?? String v int?\n    return false;\n  }\n}\n\nbool jsvIsEqual(JsVar *a, JsVar *b) {\n  if (jsvIsBasic(a) && jsvIsBasic(b))\n    return jsvIsBasicVarEqual(a,b);\n  return jsvGetRef(a)==jsvGetRef(b);\n}\n\n/// Get a const string representing this variable - if we can. Otherwise return 0\nconst char *jsvGetConstString(const JsVar *v) {\n  if (jsvIsUndefined(v)) {\n    return \"undefined\";\n  } else if (jsvIsNull(v)) {\n    return \"null\";\n  } else if (jsvIsBoolean(v)) {\n    return jsvGetBool(v) ? \"true\" : \"false\";\n  }\n  return 0;\n}\n\n/// Return the 'type' of the JS variable (eg. JS's typeof operator)\nconst char *jsvGetTypeOf(const JsVar *v) {\n  if (jsvIsUndefined(v)) return \"undefined\";\n  if (jsvIsNull(v) || jsvIsObject(v) ||\n      jsvIsArray(v) || jsvIsArrayBuffer(v)) return \"object\";\n  if (jsvIsFunction(v)) return \"function\";\n  if (jsvIsString(v)) return \"string\";\n  if (jsvIsBoolean(v)) return \"boolean\";\n  if (jsvIsNumeric(v)) return \"number\";\n  return \"?\";\n}\n\n/// Return the JsVar, or if it's an object and has a valueOf function, call that\nJsVar *jsvGetValueOf(JsVar *v) {\n  if (!jsvIsObject(v)) return jsvLockAgainSafe(v);\n  JsVar *valueOf = jspGetNamedField(v, \"valueOf\", false);\n  if (!jsvIsFunction(valueOf)) {\n    jsvUnLock(valueOf);\n    return jsvLockAgain(v);\n  }\n  v = jspeFunctionCall(valueOf, 0, v, false, 0, 0);\n  jsvUnLock(valueOf);\n  return v;\n}\n\n/** Save this var as a string to the given buffer, and return how long it was (return val doesn't include terminating 0)\nIf the buffer length is exceeded, the returned value will == len */\nsize_t jsvGetString(const JsVar *v, char *str, size_t len) {\n  assert(len>0);\n  const char *s = jsvGetConstString(v);\n  if (s) {\n    /* don't use strncpy here because we don't\n     * want to pad the entire buffer with zeros */\n    len--;\n    int l = 0;\n    while (s[l] && l<len) {\n      str[l] = s[l];\n      l++;\n    }\n    str[l] = 0;\n    return l;\n  } else if (jsvIsInt(v)) {\n    itostr(v->varData.integer, str, 10);\n    return strlen(str);\n  } else if (jsvIsFloat(v)) {\n    ftoa_bounded(v->varData.floating, str, len);\n    return strlen(str);\n  } else if (jsvHasCharacterData(v)) {\n    assert(!jsvIsStringExt(v));\n    size_t l = len;\n    JsvStringIterator it;\n    jsvStringIteratorNewConst(&it, v, 0);\n    while (jsvStringIteratorHasChar(&it)) {\n      if (l--<=1) {\n        *str = 0;\n        jsvStringIteratorFree(&it);\n        return len;\n      }\n      *(str++) = jsvStringIteratorGetChar(&it);\n      jsvStringIteratorNext(&it);\n    }\n    jsvStringIteratorFree(&it);\n    *str = 0;\n    return len-l;\n  } else {\n    // Try and get as a JsVar string, and try again\n    JsVar *stringVar = jsvAsString((JsVar*)v, false); // we know we're casting to non-const here\n    if (stringVar) {\n      size_t l = jsvGetString(stringVar, str, len); // call again - but this time with converted var\n      jsvUnLock(stringVar);\n      return l;\n    } else {\n      str[0] = 0;\n      jsExceptionHere(JSET_INTERNALERROR, \"Variable type cannot be converted to string\");\n      return 0;\n    }\n  }\n}\n\n/// Get len bytes of string data from this string. Does not error if string len is not equal to len\nsize_t jsvGetStringChars(const JsVar *v, size_t startChar, char *str, size_t len) {\n  assert(jsvHasCharacterData(v));\n  size_t l = len;\n  JsvStringIterator it;\n  jsvStringIteratorNewConst(&it, v, startChar);\n  while (jsvStringIteratorHasChar(&it)) {\n    if (l--<=0) {\n      jsvStringIteratorFree(&it);\n      return len;\n    }\n    *(str++) = jsvStringIteratorGetChar(&it);\n    jsvStringIteratorNext(&it);\n  }\n  jsvStringIteratorFree(&it);\n  *str = 0;\n  return len-l;\n}\n\n/// Set the Data in this string. This must JUST overwrite - not extend or shrink\nvoid jsvSetString(JsVar *v, const char *str, size_t len) {\n  assert(jsvHasCharacterData(v));\n  // the iterator checks, so it is safe not to assert if the length is different\n  //assert(len == jsvGetStringLength(v));\n\n\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, v, 0);\n  size_t i;\n  for (i=0;i<len;i++) {\n    jsvStringIteratorSetChar(&it, str[i]);\n    jsvStringIteratorNext(&it);\n  }\n  jsvStringIteratorFree(&it);\n}\n\n/** If var is a string, lock and return it, else\n * create a new string. unlockVar means this will auto-unlock 'var'  */\nJsVar *jsvAsString(JsVar *v, bool unlockVar) {\n  JsVar *str = 0;\n  // If it is string-ish, but not quite a string, copy it\n  if (jsvHasCharacterData(v) && jsvIsName(v)) {\n    str = jsvNewFromStringVar(v,0,JSVAPPENDSTRINGVAR_MAXLENGTH);\n  } else if (jsvIsString(v)) { // If it is a string - just return a reference\n    str = jsvLockAgain(v);\n  } else if (jsvIsObject(v)) { // If it is an object and we can call toString on it\n    JsVar *toStringFn = jspGetNamedField(v, \"toString\", false);\n    if (toStringFn && toStringFn->varData.native.ptr != (void (*)(void))jswrap_object_toString) {\n      // Function found and it's not the default one - execute it\n      JsVar *result = jspExecuteFunction(toStringFn,v,0,0);\n      jsvUnLock(toStringFn);\n      str = jsvAsString(result, true);\n    } else {\n      jsvUnLock(toStringFn);\n      str = jsvNewFromString(\"[object Object]\");\n    }\n  } else {\n    const char *constChar = jsvGetConstString(v);\n    assert(JS_NUMBER_BUFFER_SIZE>=10);\n    char buf[JS_NUMBER_BUFFER_SIZE];\n    if (constChar) {\n      // if we could get this as a simple const char, do that..\n      str = jsvNewFromString(constChar);\n    } else if (jsvIsPin(v)) {\n      jshGetPinString(buf, (Pin)v->varData.integer);\n      str = jsvNewFromString(buf);\n    } else if (jsvIsInt(v)) {\n      itostr(v->varData.integer, buf, 10);\n      str = jsvNewFromString(buf);\n    } else if (jsvIsFloat(v)) {\n      ftoa_bounded(v->varData.floating, buf, sizeof(buf));\n      str = jsvNewFromString(buf);\n    } else if (jsvIsArray(v) || jsvIsArrayBuffer(v)) {\n      JsVar *filler = jsvNewFromString(\",\");\n      str = jsvArrayJoin(v, filler);\n      jsvUnLock(filler);\n    } else if (jsvIsFunction(v)) {\n      str = jsvNewFromEmptyString();\n      if (str) jsfGetJSON(v, str, JSON_NONE);\n    } else {\n      jsExceptionHere(JSET_INTERNALERROR, \"Variable type cannot be converted to string\");\n      str = 0;\n    }\n  }\n\n  if (unlockVar) jsvUnLock(v);\n  return str;\n}\n\nJsVar *jsvAsFlatString(JsVar *var) {\n  if (jsvIsFlatString(var)) return jsvLockAgain(var);\n  JsVar *str = jsvAsString(var, false);\n  size_t len = jsvGetStringLength(str);\n  JsVar *flat = jsvNewFlatStringOfLength((unsigned int)len);\n  if (flat) {\n    JsvStringIterator src;\n    JsvStringIterator dst;\n    jsvStringIteratorNew(&src, str, 0);\n    jsvStringIteratorNew(&dst, flat, 0);\n    while (len--) {\n      jsvStringIteratorSetChar(&dst, jsvStringIteratorGetChar(&src));\n      if (len>0) {\n        jsvStringIteratorNext(&src);\n        jsvStringIteratorNext(&dst);\n      }\n    }\n    jsvStringIteratorFree(&src);\n    jsvStringIteratorFree(&dst);\n  }\n  jsvUnLock(str);\n  return flat;\n}\n\n/** Given a JsVar meant to be an index to an array, convert it to\n * the actual variable type we'll use to access the array. For example\n * a[\"0\"] is actually translated to a[0]\n */\nJsVar *jsvAsArrayIndex(JsVar *index) {\n  if (jsvIsSimpleInt(index)) {\n    return jsvLockAgain(index); // we're ok!\n  } else if (jsvIsString(index)) {\n    /* Index filtering (bug #19) - if we have an array index A that is:\n     is_string(A) && int_to_string(string_to_int(A)) == A\n     then convert it to an integer. Shouldn't be too nasty for performance\n     as we only do this when accessing an array with a string */\n    if (jsvIsStringNumericStrict(index)) {\n      JsVar *i = jsvNewFromInteger(jsvGetInteger(index));\n      JsVar *is = jsvAsString(i, false);\n      if (jsvCompareString(index,is,0,0,false)==0) {\n        // two items are identical - use the integer\n        jsvUnLock(is);\n        return i;\n      } else {\n        // not identical, use as a string\n        jsvUnLock2(i,is);\n      }\n    }\n  } else if (jsvIsFloat(index)) {\n    // if it's a float that is actually integral, return an integer...\n    JsVarFloat v = jsvGetFloat(index);\n    JsVarInt vi = jsvGetInteger(index);\n    if (v == vi) return jsvNewFromInteger(vi);\n  }\n\n  // else if it's not a simple numeric type, convert it to a string\n  return jsvAsString(index, false);\n}\n\n/** Same as jsvAsArrayIndex, but ensures that 'index' is unlocked */\nJsVar *jsvAsArrayIndexAndUnLock(JsVar *a) {\n  JsVar *b = jsvAsArrayIndex(a);\n  jsvUnLock(a);\n  return b;\n}\n\n/// Returns true if the string is empty - faster than jsvGetStringLength(v)==0\nbool jsvIsEmptyString(JsVar *v) {\n  if (!jsvHasCharacterData(v)) return true;\n  return jsvGetCharactersInVar(v)==0;\n}\n\nsize_t jsvGetStringLength(const JsVar *v) {\n  size_t strLength = 0;\n  const JsVar *var = v;\n  JsVar *newVar = 0;\n  if (!jsvHasCharacterData(v)) return 0;\n\n  while (var) {\n    JsVarRef ref = jsvGetLastChild(var);\n    strLength += jsvGetCharactersInVar(var);\n\n    // Go to next\n    jsvUnLock(newVar); // note use of if (ref), not var\n    var = newVar = ref ? jsvLock(ref) : 0;\n  }\n  jsvUnLock(newVar); // note use of if (ref), not var\n  return strLength;\n}\n\nsize_t jsvGetFlatStringBlocks(const JsVar *v) {\n  assert(jsvIsFlatString(v));\n  return ((size_t)v->varData.integer+sizeof(JsVar)-1) / sizeof(JsVar);\n}\n\nchar *jsvGetFlatStringPointer(JsVar *v) {\n  assert(jsvIsFlatString(v));\n  if (!jsvIsFlatString(v)) return 0;\n  return (char*)(v+1); // pointer to the next JsVar\n}\n\nJsVar *jsvGetFlatStringFromPointer(char *v) {\n  JsVar *secondVar = (JsVar*)v;\n  JsVar *flatStr = secondVar-1;\n  assert(jsvIsFlatString(flatStr));\n  return flatStr;\n}\n\n/// If the variable points to a *flat* area of memory, return a pointer (and set length). Otherwise return 0.\nchar *jsvGetDataPointer(JsVar *v, size_t *len) {\n  assert(len);\n  if (jsvIsArrayBuffer(v)) {\n    /* Arraybuffers generally use some kind of string to store their data.\n     * Find it, then call ourselves again to figure out if we can get a\n     * raw pointer to it.  */\n    JsVar *d = jsvGetArrayBufferBackingString(v);\n    char *r = jsvGetDataPointer(d, len);\n    jsvUnLock(d);\n    if (r) {\n      r += v->varData.arraybuffer.byteOffset;\n      *len = v->varData.arraybuffer.length;\n    }\n    return r;\n  }\n  if (jsvIsNativeString(v)) {\n    *len = v->varData.nativeStr.len;\n    return (char*)v->varData.nativeStr.ptr;\n  }\n  if (jsvIsFlatString(v)) {\n    *len = jsvGetStringLength(v);\n    return jsvGetFlatStringPointer(v);\n  }\n  return 0;\n}\n\n//  IN A STRING  get the number of lines in the string (min=1)\nsize_t jsvGetLinesInString(JsVar *v) {\n  size_t lines = 1;\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, v, 0);\n  while (jsvStringIteratorHasChar(&it)) {\n    if (jsvStringIteratorGetChar(&it)=='\\n') lines++;\n    jsvStringIteratorNext(&it);\n  }\n  jsvStringIteratorFree(&it);\n  return lines;\n}\n\n// IN A STRING Get the number of characters on a line - lines start at 1\nsize_t jsvGetCharsOnLine(JsVar *v, size_t line) {\n  size_t currentLine = 1;\n  size_t chars = 0;\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, v, 0);\n  while (jsvStringIteratorHasChar(&it)) {\n    if (jsvStringIteratorGetChar(&it)=='\\n') {\n      currentLine++;\n      if (currentLine > line) break;\n    } else if (currentLine==line) chars++;\n    jsvStringIteratorNext(&it);\n  }\n  jsvStringIteratorFree(&it);\n  return chars;\n}\n\n//  IN A STRING, get the 1-based line and column of the given character. Both values must be non-null\nvoid jsvGetLineAndCol(JsVar *v, size_t charIdx, size_t *line, size_t *col) {\n  size_t x = 1;\n  size_t y = 1;\n  size_t n = 0;\n  assert(line && col);\n\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, v, 0);\n  while (jsvStringIteratorHasChar(&it)) {\n    char ch = jsvStringIteratorGetChar(&it);\n    if (n==charIdx) {\n      jsvStringIteratorFree(&it);\n      *line = y;\n      *col = x;\n      return;\n    }\n    x++;\n    if (ch=='\\n') {\n      x=1; y++;\n    }\n    n++;\n    jsvStringIteratorNext(&it);\n  }\n  jsvStringIteratorFree(&it);\n  // uh-oh - not found\n  *line = y;\n  *col = x;\n}\n\n//  IN A STRING, get a character index from a line and column\nsize_t jsvGetIndexFromLineAndCol(JsVar *v, size_t line, size_t col) {\n  size_t x = 1;\n  size_t y = 1;\n  size_t n = 0;\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, v, 0);\n  while (jsvStringIteratorHasChar(&it)) {\n    char ch = jsvStringIteratorGetChar(&it);\n    if ((y==line && x>=col) || y>line) {\n      jsvStringIteratorFree(&it);\n      return (y>line) ? (n-1) : n;\n    }\n    x++;\n    if (ch=='\\n') {\n      x=1; y++;\n    }\n    n++;\n    jsvStringIteratorNext(&it);\n  }\n  jsvStringIteratorFree(&it);\n  return n;\n}\n\nvoid jsvAppendString(JsVar *var, const char *str) {\n  assert(jsvIsString(var));\n  JsvStringIterator dst;\n  jsvStringIteratorNew(&dst, var, 0);\n  jsvStringIteratorGotoEnd(&dst);\n  // now start appending\n  /* This isn't as fast as something single-purpose, but it's not that bad,\n   * and is less likely to break :) */\n  while (*str)\n    jsvStringIteratorAppend(&dst, *(str++));\n  jsvStringIteratorFree(&dst);\n}\n\n// Append the given string to this one - but does not use null-terminated strings\nvoid jsvAppendStringBuf(JsVar *var, const char *str, size_t length) {\n  assert(jsvIsString(var));\n  JsvStringIterator dst;\n  jsvStringIteratorNew(&dst, var, 0);\n  jsvStringIteratorGotoEnd(&dst);\n  // now start appending\n  /* This isn't as fast as something single-purpose, but it's not that bad,\n   * and is less likely to break :) */\n  while (length) {\n    jsvStringIteratorAppend(&dst, *(str++));\n    length--;\n  }\n  jsvStringIteratorFree(&dst);\n}\n\n/// Special version of append designed for use with vcbprintf_callback (See jsvAppendPrintf)\nvoid jsvStringIteratorPrintfCallback(const char *str, void *user_data) {\n  while (*str)\n    jsvStringIteratorAppend((JsvStringIterator *)user_data, *(str++));\n}\n\nvoid jsvAppendPrintf(JsVar *var, const char *fmt, ...) {\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, var, 0);\n  jsvStringIteratorGotoEnd(&it);\n\n  va_list argp;\n  va_start(argp, fmt);\n  vcbprintf((vcbprintf_callback)jsvStringIteratorPrintfCallback,&it, fmt, argp);\n  va_end(argp);\n\n  jsvStringIteratorFree(&it);\n}\n\nJsVar *jsvVarPrintf( const char *fmt, ...) {\n  JsVar *str = jsvNewFromEmptyString();\n  if (!str) return 0;\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, str, 0);\n  jsvStringIteratorGotoEnd(&it);\n\n  va_list argp;\n  va_start(argp, fmt);\n  vcbprintf((vcbprintf_callback)jsvStringIteratorPrintfCallback,&it, fmt, argp);\n  va_end(argp);\n\n  jsvStringIteratorFree(&it);\n  return str;\n}\n\n/** Append str to var. Both must be strings. stridx = start char or str, maxLength = max number of characters (can be JSVAPPENDSTRINGVAR_MAXLENGTH) */\nvoid jsvAppendStringVar(JsVar *var, const JsVar *str, size_t stridx, size_t maxLength) {\n  assert(jsvIsString(var));\n\n  JsvStringIterator dst;\n  jsvStringIteratorNew(&dst, var, 0);\n  jsvStringIteratorGotoEnd(&dst);\n  // now start appending\n  /* This isn't as fast as something single-purpose, but it's not that bad,\n     * and is less likely to break :) */\n  JsvStringIterator it;\n  jsvStringIteratorNewConst(&it, str, stridx);\n  while (jsvStringIteratorHasChar(&it) && (maxLength-->0)) {\n    char ch = jsvStringIteratorGetChar(&it);\n    jsvStringIteratorAppend(&dst, ch);\n    jsvStringIteratorNext(&it);\n  }\n  jsvStringIteratorFree(&it);\n  jsvStringIteratorFree(&dst);\n}\n\n/** Create a new variable from a substring. argument must be a string. stridx = start char or str, maxLength = max number of characters (can be JSVAPPENDSTRINGVAR_MAXLENGTH) */\nJsVar *jsvNewFromStringVar(const JsVar *str, size_t stridx, size_t maxLength) {\n  JsVar *var = jsvNewFromEmptyString();\n  if (var) jsvAppendStringVar(var, str, stridx, maxLength);\n  return var;\n}\n\n/** Append all of str to var. Both must be strings.  */\nvoid jsvAppendStringVarComplete(JsVar *var, const JsVar *str) {\n  jsvAppendStringVar(var, str, 0, JSVAPPENDSTRINGVAR_MAXLENGTH);\n}\n\nchar jsvGetCharInString(JsVar *v, size_t idx) {\n  if (!jsvIsString(v)) return 0;\n\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, v, idx);\n  char ch = jsvStringIteratorGetChar(&it);\n  jsvStringIteratorFree(&it);\n  return ch;\n}\n\n/// Get the index of a character in a string, or -1\nint jsvGetStringIndexOf(JsVar *str, char ch) {\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, str, 0);\n  while (jsvStringIteratorHasChar(&it)) {\n    if (jsvStringIteratorGetChar(&it) == ch) {\n      int idx = (int)jsvStringIteratorGetIndex(&it);\n      jsvStringIteratorFree(&it);\n      return idx;\n    };\n    jsvStringIteratorNext(&it);\n  }\n  jsvStringIteratorFree(&it);\n  return -1;\n}\n\n/** Does this string contain only Numeric characters (with optional '-'/'+' at the front)? NOT '.'/'e' and similar (allowDecimalPoint is for '.' only) */\nbool jsvIsStringNumericInt(const JsVar *var, bool allowDecimalPoint) {\n  assert(jsvIsString(var));\n  JsvStringIterator it;\n  jsvStringIteratorNewConst(&it, var, 0); // we know it's non const\n\n  // skip whitespace\n  while (jsvStringIteratorHasChar(&it) && isWhitespace(jsvStringIteratorGetChar(&it)))\n    jsvStringIteratorNext(&it);\n\n  // skip a minus. if there was one\n  if (jsvStringIteratorGetChar(&it)=='-' || jsvStringIteratorGetChar(&it)=='+')\n    jsvStringIteratorNext(&it);\n\n  int radix = 0;\n  if (jsvStringIteratorGetChar(&it)=='0') {\n    jsvStringIteratorNext(&it);\n    char buf[3];\n    buf[0] = '0';\n    buf[1] = jsvStringIteratorGetChar(&it);\n    buf[2] = 0;\n    const char *p = buf;\n    radix = getRadix(&p,0,0);\n    if (p>&buf[1]) jsvStringIteratorNext(&it);\n  }\n  if (radix==0) radix=10;\n\n  // now check...\n  int chars=0;\n  while (jsvStringIteratorHasChar(&it)) {\n    chars++;\n    char ch = jsvStringIteratorGetChar(&it);\n    if (ch=='.' && allowDecimalPoint) {\n      allowDecimalPoint = false; // there can be only one\n    } else {\n      int n = chtod(ch);\n      if (n<0 || n>=radix) {\n        jsvStringIteratorFree(&it);\n        return false;\n      }\n    }\n    jsvStringIteratorNext(&it);\n  }\n  jsvStringIteratorFree(&it);\n  return chars>0;\n}\n\n/** Does this string contain only Numeric characters? This is for arrays\n * and makes the assertion that int_to_string(string_to_int(var))==var */\nbool jsvIsStringNumericStrict(const JsVar *var) {\n  assert(jsvIsString(var));\n  JsvStringIterator it;\n  jsvStringIteratorNewConst(&it, var, 0);  // we know it's non const\n  bool hadNonZero = false;\n  bool hasLeadingZero = false;\n  int chars = 0;\n  while (jsvStringIteratorHasChar(&it)) {\n    chars++;\n    char ch = jsvStringIteratorGetChar(&it);\n    if (!isNumeric(ch)) {\n      // test for leading zero ensures int_to_string(string_to_int(var))==var\n      jsvStringIteratorFree(&it);\n      return false;\n    }\n    if (!hadNonZero && ch=='0') hasLeadingZero=true;\n    if (ch!='0') hadNonZero=true;\n    jsvStringIteratorNext(&it);\n  }\n  jsvStringIteratorFree(&it);\n  return chars>0 && (!hasLeadingZero || chars==1);\n}\n\n\nJsVarInt jsvGetInteger(const JsVar *v) {\n  if (!v) return 0; // undefined\n  /* strtol understands about hex and octal */\n  if (jsvIsNull(v)) return 0;\n  if (jsvIsUndefined(v)) return 0;\n  if (jsvIsIntegerish(v) || jsvIsArrayBufferName(v)) return v->varData.integer;\n  if (jsvIsArray(v) || jsvIsArrayBuffer(v)) {\n    JsVarInt l = jsvGetLength((JsVar *)v);\n    if (l==0) return 0; // 0 length, return 0\n    if (l==1) {\n      if (jsvIsArrayBuffer(v))\n        return jsvGetIntegerAndUnLock(jsvArrayBufferGet((JsVar*)v,0));\n      return jsvGetIntegerAndUnLock(jsvSkipNameAndUnLock(jsvGetArrayItem(v,0)));\n    }\n  }\n  if (jsvIsFloat(v)) {\n    if (isfinite(v->varData.floating))\n      return (JsVarInt)(long long)v->varData.floating;\n    return 0;\n  }\n  if (jsvIsString(v) && jsvIsStringNumericInt(v, true/* allow decimal point*/)) {\n    char buf[32];\n    if (jsvGetString(v, buf, sizeof(buf))==sizeof(buf))\n      jsExceptionHere(JSET_ERROR, \"String too big to convert to integer\\n\");\n    else\n      return (JsVarInt)stringToInt(buf);\n  }\n  return 0;\n}\n\nlong long jsvGetLongInteger(const JsVar *v) {\n  if (jsvIsInt(v)) return jsvGetInteger(v);\n  return (long long)jsvGetFloat(v);\n}\n\nlong long jsvGetLongIntegerAndUnLock(JsVar *v) {\n  long long i = jsvGetLongInteger(v);\n  jsvUnLock(v);\n  return i;\n}\n\n\nvoid jsvSetInteger(JsVar *v, JsVarInt value) {\n  assert(jsvIsInt(v));\n  v->varData.integer  = value;\n}\n\n/**\n * Get the boolean value of a variable.\n * From a JavaScript variable, we determine its boolean value.  The rules\n * are:\n *\n * * If integer, true if value is not 0.\n * * If float, true if value is not 0.0.\n * * If function, array or object, always true.\n * * If string, true if length of string is greater than 0.\n */\nbool jsvGetBool(const JsVar *v) {\n  if (jsvIsString(v))\n    return jsvGetStringLength((JsVar*)v)!=0;\n  if (jsvIsFunction(v) || jsvIsArray(v) || jsvIsObject(v) || jsvIsArrayBuffer(v))\n    return true;\n  if (jsvIsFloat(v)) {\n    JsVarFloat f = jsvGetFloat(v);\n    return !isnan(f) && f!=0.0;\n  }\n  return jsvGetInteger(v)!=0;\n}\n\nJsVarFloat jsvGetFloat(const JsVar *v) {\n  if (!v) return NAN; // undefined\n  if (jsvIsFloat(v)) return v->varData.floating;\n  if (jsvIsIntegerish(v)) return (JsVarFloat)v->varData.integer;\n  if (jsvIsArray(v) || jsvIsArrayBuffer(v)) {\n    JsVarInt l = jsvGetLength(v);\n    if (l==0) return 0; // zero element array==0 (not undefined)\n    if (l==1) {\n      if (jsvIsArrayBuffer(v))\n        return jsvGetFloatAndUnLock(jsvArrayBufferGet((JsVar*)v,0));\n      return jsvGetFloatAndUnLock(jsvSkipNameAndUnLock(jsvGetArrayItem(v,0)));\n    }\n  }\n  if (jsvIsString(v)) {\n    char buf[64];\n    if (jsvGetString(v, buf, sizeof(buf))==sizeof(buf)) {\n      jsExceptionHere(JSET_ERROR, \"String too big to convert to float\\n\");\n    } else {\n      if (buf[0]==0) return 0; // empty string -> 0\n      if (!strcmp(buf,\"Infinity\")) return INFINITY;\n      if (!strcmp(buf,\"-Infinity\")) return -INFINITY;\n      return stringToFloat(buf);\n    }\n  }\n  return NAN;\n}\n\n/// Convert the given variable to a number\nJsVar *jsvAsNumber(JsVar *var) {\n  // stuff that we can just keep\n  if (jsvIsInt(var) || jsvIsFloat(var)) return jsvLockAgain(var);\n  // stuff that can be converted to an int\n  if (jsvIsBoolean(var) ||\n      jsvIsPin(var) ||\n      jsvIsNull(var) ||\n      jsvIsBoolean(var) ||\n      jsvIsArrayBufferName(var))\n    return jsvNewFromInteger(jsvGetInteger(var));\n  if (jsvIsString(var) && (jsvIsEmptyString(var) || jsvIsStringNumericInt(var, false/* no decimal pt - handle that with GetFloat */))) {\n    // handle strings like this, in case they're too big for an int\n    char buf[64];\n    if (jsvGetString(var, buf, sizeof(buf))==sizeof(buf)) {\n      jsExceptionHere(JSET_ERROR, \"String too big to convert to integer\\n\");\n      return jsvNewFromFloat(NAN);\n    } else\n      return jsvNewFromLongInteger(stringToInt(buf));\n  }\n  // Else just try and get a float\n  return jsvNewFromFloat(jsvGetFloat(var));\n}\n\nJsVarInt jsvGetIntegerAndUnLock(JsVar *v) { return _jsvGetIntegerAndUnLock(v); }\nJsVarFloat jsvGetFloatAndUnLock(JsVar *v) { return _jsvGetFloatAndUnLock(v); }\nbool jsvGetBoolAndUnLock(JsVar *v) { return _jsvGetBoolAndUnLock(v); }\n\n/** Get the item at the given location in the array buffer and return the result */\nsize_t jsvGetArrayBufferLength(const JsVar *arrayBuffer) {\n  assert(jsvIsArrayBuffer(arrayBuffer));\n  return arrayBuffer->varData.arraybuffer.length;\n}\n\n/** Get the String the contains the data for this arrayBuffer */\nJsVar *jsvGetArrayBufferBackingString(JsVar *arrayBuffer) {\n  jsvLockAgain(arrayBuffer);\n  while (jsvIsArrayBuffer(arrayBuffer)) {\n    JsVar *s = jsvLock(jsvGetFirstChild(arrayBuffer));\n    jsvUnLock(arrayBuffer);\n    arrayBuffer = s;\n  }\n  assert(jsvIsString(arrayBuffer));\n  return arrayBuffer;\n}\n\n/** Get the item at the given location in the array buffer and return the result */\nJsVar *jsvArrayBufferGet(JsVar *arrayBuffer, size_t idx) {\n  JsvArrayBufferIterator it;\n  jsvArrayBufferIteratorNew(&it, arrayBuffer, idx);\n  JsVar *v = jsvArrayBufferIteratorGetValue(&it);\n  jsvArrayBufferIteratorFree(&it);\n  return v;\n}\n\n/** Set the item at the given location in the array buffer */\nvoid jsvArrayBufferSet(JsVar *arrayBuffer, size_t idx, JsVar *value) {\n  JsvArrayBufferIterator it;\n  jsvArrayBufferIteratorNew(&it, arrayBuffer, idx);\n  jsvArrayBufferIteratorSetValue(&it, value);\n  jsvArrayBufferIteratorFree(&it);\n}\n\n\n/** Given an integer name that points to an arraybuffer or an arraybufferview, evaluate it and return the result */\nJsVar *jsvArrayBufferGetFromName(JsVar *name) {\n  assert(jsvIsArrayBufferName(name));\n  size_t idx = (size_t)jsvGetInteger(name);\n  JsVar *arrayBuffer = jsvLock(jsvGetFirstChild(name));\n  JsVar *value = jsvArrayBufferGet(arrayBuffer, idx);\n  jsvUnLock(arrayBuffer);\n  return value;\n}\n\n\nJsVar *jsvGetFunctionArgumentLength(JsVar *functionScope) {\n  JsVar *args = jsvNewEmptyArray();\n  if (!args) return 0; // out of memory\n\n  JsvObjectIterator it;\n  jsvObjectIteratorNew(&it, functionScope);\n  while (jsvObjectIteratorHasValue(&it)) {\n    JsVar *idx = jsvObjectIteratorGetKey(&it);\n    if (jsvIsFunctionParameter(idx)) {\n      JsVar *val = jsvSkipOneName(idx);\n      jsvArrayPushAndUnLock(args, val);\n    }\n    jsvUnLock(idx);\n    jsvObjectIteratorNext(&it);\n  }\n  jsvObjectIteratorFree(&it);\n\n  return args;\n}\n\n/** Is this variable actually defined? eg, can we pass it into `jsvSkipName`\n * without getting a ReferenceError? This also returns false if the variable\n * if ok, but has the value `undefined`. */\nbool jsvIsVariableDefined(JsVar *a) {\n  return !jsvIsName(a) ||\n         jsvIsNameWithValue(a) ||\n         (jsvGetFirstChild(a)!=0);\n}\n\n/** If a is a name skip it and go to what it points to - and so on.\n * ALWAYS locks - so must unlock what it returns. It MAY\n * return 0. Throws a ReferenceError if variable is not defined,\n * but you can check if it will with jsvIsReferenceError */\nJsVar *jsvSkipName(JsVar *a) {\n  if (!a) return 0;\n  if (jsvIsArrayBufferName(a)) return jsvArrayBufferGetFromName(a);\n  if (jsvIsNameInt(a)) return jsvNewFromInteger((JsVarInt)jsvGetFirstChildSigned(a));\n  if (jsvIsNameIntBool(a)) return jsvNewFromBool(jsvGetFirstChild(a)!=0);\n  JsVar *pa = jsvLockAgain(a);\n  while (jsvIsName(pa)) {\n    JsVarRef n = jsvGetFirstChild(pa);\n    jsvUnLock(pa);\n    if (!n) {\n      if (pa==a && jsvGetRefs(a)==0 && !jsvIsNewChild(a)) {\n        jsExceptionHere(JSET_REFERENCEERROR, \"%q is not defined\", a);\n      }\n      return 0;\n    }\n    pa = jsvLock(n);\n    assert(pa!=a);\n  }\n  return pa;\n}\n\n/** If a is a name skip it and go to what it points to.\n * ALWAYS locks - so must unlock what it returns. It MAY\n * return 0. Throws a ReferenceError if variable is not defined,\n * but you can check if it will with jsvIsReferenceError */\nJsVar *jsvSkipOneName(JsVar *a) {\n  if (!a) return 0;\n  if (jsvIsArrayBufferName(a)) return jsvArrayBufferGetFromName(a);\n  if (jsvIsNameInt(a)) return jsvNewFromInteger((JsVarInt)jsvGetFirstChildSigned(a));\n  if (jsvIsNameIntBool(a)) return jsvNewFromBool(jsvGetFirstChild(a)!=0);\n  JsVar *pa = jsvLockAgain(a);\n  if (jsvIsName(pa)) {\n    JsVarRef n = jsvGetFirstChild(pa);\n    jsvUnLock(pa);\n    if (!n) {\n      if (pa==a && jsvGetRefs(a)==0 && !jsvIsNewChild(a)) {\n        jsExceptionHere(JSET_REFERENCEERROR, \"%q is not defined\", a);\n      }\n      return 0;\n    }\n    pa = jsvLock(n);\n    assert(pa!=a);\n  }\n  return pa;\n}\n\n/** If a is a's child is a name skip it and go to what it points to.\n * ALWAYS locks - so must unlock what it returns.  */\nJsVar *jsvSkipToLastName(JsVar *a) {\n  assert(jsvIsName(a));\n  a = jsvLockAgain(a);\n  while (true) {\n    if (!jsvGetFirstChild(a)) return a;\n    JsVar *child = jsvLock(jsvGetFirstChild(a));\n    if (jsvIsName(child)) {\n      jsvUnLock(a);\n      a = child;\n    } else {\n      jsvUnLock(child);\n      return a;\n    }\n  }\n  return 0; // not called\n}\n\n/** Same as jsvSkipName, but ensures that 'a' is unlocked */\nJsVar *jsvSkipNameAndUnLock(JsVar *a) {\n  JsVar *b = jsvSkipName(a);\n  jsvUnLock(a);\n  return b;\n}\n\n/** Same as jsvSkipOneName, but ensures that 'a' is unlocked */\nJsVar *jsvSkipOneNameAndUnLock(JsVar *a) {\n  JsVar *b = jsvSkipOneName(a);\n  jsvUnLock(a);\n  return b;\n}\n\nbool jsvIsStringEqualOrStartsWithOffset(JsVar *var, const char *str, bool isStartsWith, size_t startIdx, bool ignoreCase) {\n  if (!jsvHasCharacterData(var)) {\n    return 0; // not a string so not equal!\n  }\n\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, var, startIdx);\n  if (ignoreCase) {\n      while (jsvStringIteratorHasChar(&it) && *str &&\n             jsvStringCharToLower(jsvStringIteratorGetChar(&it)) == jsvStringCharToLower(*str)) {\n        str++;\n        jsvStringIteratorNext(&it);\n      }\n  } else {\n      while (jsvStringIteratorHasChar(&it) && *str &&\n             jsvStringIteratorGetChar(&it) == *str) {\n        str++;\n        jsvStringIteratorNext(&it);\n      }\n  }\n  bool eq = (isStartsWith && !*str) ||\n            jsvStringIteratorGetChar(&it)==*str; // should both be 0 if equal\n  jsvStringIteratorFree(&it);\n  return eq;\n}\n\n/*\njsvIsStringEqualOrStartsWith(A, B, false) is a proper A==B\njsvIsStringEqualOrStartsWith(A, B, true) is A.startsWith(B)\n */\nbool jsvIsStringEqualOrStartsWith(JsVar *var, const char *str, bool isStartsWith) {\n  return jsvIsStringEqualOrStartsWithOffset(var, str, isStartsWith, 0, false);\n}\n\n// Also see jsvIsBasicVarEqual\nbool jsvIsStringEqual(JsVar *var, const char *str) {\n  return jsvIsStringEqualOrStartsWith(var, str, false);\n}\n\n// Also see jsvIsBasicVarEqual\nbool jsvIsStringIEqualAndUnLock(JsVar *var, const char *str) {\n  bool b = jsvIsStringEqualOrStartsWithOffset(var, str, false, 0, true);\n  jsvUnLock(var);\n  return b;\n}\n\n\n/** Compare 2 strings, starting from the given character positions. equalAtEndOfString means that\n * if one of the strings ends (even if the other hasn't), we treat them as equal.\n * For a basic strcmp, do: jsvCompareString(a,b,0,0,false)\n *  */\nint jsvCompareString(JsVar *va, JsVar *vb, size_t starta, size_t startb, bool equalAtEndOfString) {\n  JsvStringIterator ita, itb;\n  jsvStringIteratorNew(&ita, va, starta);\n  jsvStringIteratorNew(&itb, vb, startb);\n  // step to first positions\n  while (true) {\n    int ca = jsvStringIteratorGetCharOrMinusOne(&ita);\n    int cb = jsvStringIteratorGetCharOrMinusOne(&itb);\n\n    if (ca != cb) {\n      jsvStringIteratorFree(&ita);\n      jsvStringIteratorFree(&itb);\n      if ((ca<0 || cb<0) && equalAtEndOfString) return 0;\n      return ca - cb;\n    }\n    if (ca < 0) { // both equal, but end of string\n      jsvStringIteratorFree(&ita);\n      jsvStringIteratorFree(&itb);\n      return 0;\n    }\n    jsvStringIteratorNext(&ita);\n    jsvStringIteratorNext(&itb);\n  }\n  // never get here, but the compiler warns...\n  return true;\n}\n\n/** Return a new string containing just the characters that are\n * shared between two strings. */\nJsVar *jsvGetCommonCharacters(JsVar *va, JsVar *vb) {\n  JsVar *v = jsvNewFromEmptyString();\n  if (!v) return 0;\n  JsvStringIterator ita, itb;\n  jsvStringIteratorNew(&ita, va, 0);\n  jsvStringIteratorNew(&itb, vb, 0);\n  int ca = jsvStringIteratorGetCharOrMinusOne(&ita);\n  int cb = jsvStringIteratorGetCharOrMinusOne(&itb);\n  while (ca>0 && cb>0 && ca == cb) {\n    jsvAppendCharacter(v, (char)ca);\n    jsvStringIteratorNext(&ita);\n    jsvStringIteratorNext(&itb);\n    ca = jsvStringIteratorGetCharOrMinusOne(&ita);\n    cb = jsvStringIteratorGetCharOrMinusOne(&itb);\n  }\n  jsvStringIteratorFree(&ita);\n  jsvStringIteratorFree(&itb);\n  return v;\n}\n\n\n/** Compare 2 integers, >0 if va>vb,  <0 if va<vb. If compared with a non-integer, that gets put later */\nint jsvCompareInteger(JsVar *va, JsVar *vb) {\n  if (jsvIsInt(va) && jsvIsInt(vb))\n    return (int)(jsvGetInteger(va) - jsvGetInteger(vb));\n  else if (jsvIsInt(va))\n    return -1;\n  else if (jsvIsInt(vb))\n    return 1;\n  else\n    return 0;\n}\n\n/** Copy only a name, not what it points to. ALTHOUGH the link to what it points to is maintained unless linkChildren=false\n    If keepAsName==false, this will be converted into a normal variable */\nJsVar *jsvCopyNameOnly(JsVar *src, bool linkChildren, bool keepAsName) {\n  assert(jsvIsName(src));\n  JsVarFlags flags = src->flags;\n  JsVar *dst = 0;\n  if (!keepAsName) {\n    JsVarFlags t = src->flags & JSV_VARTYPEMASK;\n    if (t>=_JSV_NAME_INT_START && t<=_JSV_NAME_INT_END) {\n      flags = (flags & ~JSV_VARTYPEMASK) | JSV_INTEGER;\n    } else {\n      assert((JSV_NAME_STRING_INT_0 < JSV_NAME_STRING_0) &&\n          (JSV_NAME_STRING_0 < JSV_STRING_0) &&\n          (JSV_STRING_0 < JSV_STRING_EXT_0)); // this relies on ordering\n      assert(t>=JSV_NAME_STRING_INT_0 && t<=JSV_NAME_STRING_MAX);\n      if (jsvGetLastChild(src)) {\n        /* it's not a simple name string - it has STRING_EXT bits on the end.\n         * Because the max length of NAME and STRING is different we must just\n         * copy */\n        dst = jsvNewFromStringVar(src, 0, JSVAPPENDSTRINGVAR_MAXLENGTH);\n        if (!dst) return 0;\n      } else {\n        flags = (flags & (JsVarFlags)~JSV_VARTYPEMASK) | (JSV_STRING_0 + jsvGetCharactersInVar(src));\n      }\n    }\n  }\n  if (!dst) {\n    dst = jsvNewWithFlags(flags & JSV_VARIABLEINFOMASK);\n    if (!dst) return 0; // out of memory\n\n    memcpy(&dst->varData, &src->varData, JSVAR_DATA_STRING_NAME_LEN);\n\n    assert(jsvGetLastChild(dst) == 0);\n    assert(jsvGetFirstChild(dst) == 0);\n    assert(jsvGetPrevSibling(dst) == 0);\n    assert(jsvGetNextSibling(dst) == 0);\n    // Copy extra string data if there was any\n    if (jsvHasStringExt(src)) {\n      // If it had extra string data it should have been handled above\n      assert(keepAsName || !jsvGetLastChild(src));\n      // copy extra bits of string if there were any\n      if (jsvGetLastChild(src)) {\n        JsVar *child = jsvLock(jsvGetLastChild(src));\n        JsVar *childCopy = jsvCopy(child, true);\n        if (childCopy) { // could be out of memory\n          jsvSetLastChild(dst, jsvGetRef(childCopy)); // no ref for stringext\n          jsvUnLock(childCopy);\n        }\n        jsvUnLock(child);\n      }\n    } else {\n      assert(jsvIsBasic(src)); // in case we missed something!\n    }\n  }\n  // Copy LINK of what it points to\n  if (linkChildren && jsvGetFirstChild(src)) {\n    if (jsvIsNameWithValue(src))\n      jsvSetFirstChild(dst, jsvGetFirstChild(src));\n    else\n      jsvSetFirstChild(dst, jsvRefRef(jsvGetFirstChild(src)));\n  }\n  return dst;\n}\n\nJsVar *jsvCopy(JsVar *src, bool copyChildren) {\n  if (jsvIsFlatString(src)) {\n    // Copy a Flat String into a non-flat string - it's just safer\n    return jsvNewFromStringVar(src, 0, JSVAPPENDSTRINGVAR_MAXLENGTH);\n  }\n  JsVar *dst = jsvNewWithFlags(src->flags & JSV_VARIABLEINFOMASK);\n  if (!dst) return 0; // out of memory\n  if (!jsvIsStringExt(src)) {\n      memcpy(&dst->varData, &src->varData, (jsvIsBasicString(src)||jsvIsNativeString(src)) ? JSVAR_DATA_STRING_LEN : JSVAR_DATA_STRING_NAME_LEN);\n      if (!(jsvIsBasicString(src)||jsvIsNativeString(src))) {\n        assert(jsvGetPrevSibling(dst) == 0);\n        assert(jsvGetNextSibling(dst) == 0);\n        assert(jsvGetFirstChild(dst) == 0);\n      }\n      assert(jsvGetLastChild(dst) == 0);\n  } else {\n    // stringexts use the extra pointers after varData to store characters\n    // see jsvGetMaxCharactersInVar\n    memcpy(&dst->varData, &src->varData, JSVAR_DATA_STRING_MAX_LEN);\n    assert(jsvGetLastChild(dst) == 0);\n  }\n\n  // Copy what names point to\n  if (copyChildren && jsvIsName(src)) {\n    if (jsvGetFirstChild(src)) {\n      if (jsvIsNameWithValue(src)) {\n        // name_int/etc don't need references\n        jsvSetFirstChild(dst, jsvGetFirstChild(src));\n      } else {\n        JsVar *child = jsvLock(jsvGetFirstChild(src));\n        JsVar *childCopy = jsvRef(jsvCopy(child, true));\n        jsvUnLock(child);\n        if (childCopy) { // could have been out of memory\n          jsvSetFirstChild(dst, jsvGetRef(childCopy));\n          jsvUnLock(childCopy);\n        }\n      }\n    }\n  }\n\n  if (jsvHasStringExt(src)) {\n    // copy extra bits of string if there were any\n    if (jsvGetLastChild(src)) {\n      JsVar *child = jsvLock(jsvGetLastChild(src));\n      JsVar *childCopy = jsvCopy(child, true);\n      if (childCopy) {// could be out of memory\n        jsvSetLastChild(dst, jsvGetRef(childCopy)); // no ref for stringext\n        jsvUnLock(childCopy);\n      }\n      jsvUnLock(child);\n    }\n  } else if (jsvHasChildren(src)) {\n    if (copyChildren) {\n      // Copy children..\n      JsVarRef vr;\n      vr = jsvGetFirstChild(src);\n      while (vr) {\n        JsVar *name = jsvLock(vr);\n        JsVar *child = jsvCopyNameOnly(name, true/*link children*/, true/*keep as name*/); // NO DEEP COPY!\n        if (child) { // could have been out of memory\n          jsvAddName(dst, child);\n          jsvUnLock(child);\n        }\n        vr = jsvGetNextSibling(name);\n        jsvUnLock(name);\n      }\n    }\n  } else {\n    assert(jsvIsBasic(src)); // in case we missed something!\n  }\n\n  return dst;\n}\n\nvoid jsvAddName(JsVar *parent, JsVar *namedChild) {\n  namedChild = jsvRef(namedChild); // ref here VERY important as adding to structure!\n  assert(jsvIsName(namedChild));\n\n  // update array length\n  if (jsvIsArray(parent) && jsvIsInt(namedChild)) {\n    JsVarInt index = namedChild->varData.integer;\n    if (index >= jsvGetArrayLength(parent)) {\n      jsvSetArrayLength(parent, index + 1, false);\n    }\n  }\n\n  if (jsvGetLastChild(parent)) { // we have children already\n    JsVar *insertAfter = jsvLock(jsvGetLastChild(parent));\n    if (jsvIsArray(parent)) {\n      // we must insert in order - so step back until we get the right place\n      while (insertAfter && jsvCompareInteger(namedChild, insertAfter)<0) {\n        JsVarRef prev = jsvGetPrevSibling(insertAfter);\n        jsvUnLock(insertAfter);\n        insertAfter = prev ? jsvLock(prev) : 0;\n      }\n    }\n\n    if (insertAfter) {\n      if (jsvGetNextSibling(insertAfter)) {\n        // great, we're in the middle...\n        JsVar *insertBefore = jsvLock(jsvGetNextSibling(insertAfter));\n        jsvSetPrevSibling(insertBefore, jsvGetRef(namedChild));\n        jsvSetNextSibling(namedChild, jsvGetRef(insertBefore));\n        jsvUnLock(insertBefore);\n      } else {\n        // We're at the end - just set up the parent\n        jsvSetLastChild(parent, jsvGetRef(namedChild));\n      }\n      jsvSetNextSibling(insertAfter, jsvGetRef(namedChild));\n      jsvSetPrevSibling(namedChild, jsvGetRef(insertAfter));\n      jsvUnLock(insertAfter);\n    } else { // Insert right at the beginning of the array\n      // Link 2 children together\n      JsVar *firstChild = jsvLock(jsvGetFirstChild(parent));\n      jsvSetPrevSibling(firstChild, jsvGetRef(namedChild));\n      jsvUnLock(firstChild);\n\n      jsvSetNextSibling(namedChild, jsvGetFirstChild(parent));\n      // finally set the new child as the first one\n      jsvSetFirstChild(parent, jsvGetRef(namedChild));\n    }\n  } else { // we have no children - just add it\n    JsVarRef r = jsvGetRef(namedChild);\n    jsvSetFirstChild(parent, r);\n    jsvSetLastChild(parent, r);\n  }\n}\n\nJsVar *jsvAddNamedChild(JsVar *parent, JsVar *child, const char *name) {\n  JsVar *namedChild = jsvMakeIntoVariableName(jsvNewFromString(name), child);\n  if (!namedChild) return 0; // Out of memory\n  jsvAddName(parent, namedChild);\n  return namedChild;\n}\n\nJsVar *jsvSetNamedChild(JsVar *parent, JsVar *child, const char *name) {\n  JsVar *namedChild = jsvFindChildFromString(parent, name, true);\n  if (namedChild) // could be out of memory\n    return jsvSetValueOfName(namedChild, child);\n  return 0;\n}\n\nJsVar *jsvSetValueOfName(JsVar *name, JsVar *src) {\n  assert(name && jsvIsName(name));\n  assert(name!=src); // no infinite loops!\n  // all is fine, so replace the existing child...\n  /* Existing child may be null in the case of Z = 0 where\n   * we create 'Z' and pass it down to '=' to have the value\n   * filled in (or it may be undefined). */\n  if (jsvIsNameWithValue(name)) {\n    if (jsvIsString(name))\n      name->flags = (name->flags & (JsVarFlags)~JSV_VARTYPEMASK) | (JSV_NAME_STRING_0 + jsvGetCharactersInVar(name));\n    else\n      name->flags = (name->flags & (JsVarFlags)~JSV_VARTYPEMASK) | JSV_NAME_INT;\n    jsvSetFirstChild(name, 0);\n  } else if (jsvGetFirstChild(name))\n    jsvUnRefRef(jsvGetFirstChild(name)); // free existing\n  if (src) {\n    if (jsvIsInt(name)) {\n      if ((jsvIsInt(src) || jsvIsBoolean(src)) && !jsvIsPin(src)) {\n        JsVarInt v = src->varData.integer;\n        if (v>=JSVARREF_MIN && v<=JSVARREF_MAX) {\n          name->flags = (name->flags & (JsVarFlags)~JSV_VARTYPEMASK) | (jsvIsInt(src) ? JSV_NAME_INT_INT : JSV_NAME_INT_BOOL);\n          jsvSetFirstChild(name, (JsVarRef)v);\n          return name;\n        }\n      }\n    } else if (jsvIsString(name)) {\n      if (jsvIsInt(src) && !jsvIsPin(src)) {\n        JsVarInt v = src->varData.integer;\n        if (v>=JSVARREF_MIN && v<=JSVARREF_MAX) {\n          name->flags = (name->flags & (JsVarFlags)~JSV_VARTYPEMASK) | (JSV_NAME_STRING_INT_0 + jsvGetCharactersInVar(name));\n          jsvSetFirstChild(name, (JsVarRef)v);\n          return name;\n        }\n      }\n    }\n    // we can link to a name if we want (so can remove the assert!)\n    jsvSetFirstChild(name, jsvGetRef(jsvRef(src)));\n  } else\n    jsvSetFirstChild(name, 0);\n  return name;\n}\n\nJsVar *jsvFindChildFromString(JsVar *parent, const char *name, bool addIfNotFound) {\n  /* Pull out first 4 bytes, and ensure that everything\n   * is 0 padded so that we can do a nice speedy check. */\n  char fastCheck[4];\n  fastCheck[0] = name[0];\n  if (name[0]) {\n    fastCheck[1] = name[1];\n    if (name[1]) {\n      fastCheck[2] = name[2];\n      if (name[2]) {\n        fastCheck[3] = name[3];\n      } else {\n        fastCheck[3] = 0;\n      }\n    } else {\n      fastCheck[2] = 0;\n      fastCheck[3] = 0;\n    }\n  } else {\n    fastCheck[1] = 0;\n    fastCheck[2] = 0;\n    fastCheck[3] = 0;\n  }\n\n  assert(jsvHasChildren(parent));\n  JsVarRef childref = jsvGetFirstChild(parent);\n  while (childref) {\n    // Don't Lock here, just use GetAddressOf - to try and speed up the finding\n    // TODO: We can do this now, but when/if we move to cacheing vars, it'll break\n    JsVar *child = jsvGetAddressOf(childref);\n    if (*(int*)fastCheck==*(int*)child->varData.str && // speedy check of first 4 bytes\n        jsvIsStringEqual(child, name)) {\n      // found it! unlock parent but leave child locked\n      return jsvLockAgain(child);\n    }\n    childref = jsvGetNextSibling(child);\n  }\n\n  JsVar *child = 0;\n  if (addIfNotFound) {\n    child = jsvMakeIntoVariableName(jsvNewFromString(name), 0);\n    if (child) // could be out of memory\n      jsvAddName(parent, child);\n  }\n  return child;\n}\n\n/// See jsvIsNewChild - for fields that don't exist yet\nJsVar *jsvCreateNewChild(JsVar *parent, JsVar *index, JsVar *child) {\n  JsVar *newChild = jsvAsName(index);\n  if (!newChild) return 0;\n  assert(!jsvGetFirstChild(newChild));\n  if (child) jsvSetValueOfName(newChild, child);\n  assert(!jsvGetNextSibling(newChild) && !jsvGetPrevSibling(newChild));\n  // by setting the siblings as the same, we signal that if set,\n  // we should be made a member of the given object\n  JsVarRef r = jsvGetRef(jsvRef(jsvRef(parent)));\n  jsvSetNextSibling(newChild, r);\n  jsvSetPrevSibling(newChild, r);\n\n  return newChild;\n}\n\n/** Try and turn the supplied variable into a name. If not, make a new one. This locks again. */\nJsVar *jsvAsName(JsVar *var) {\n  if (!var) return 0;\n  if (jsvGetRefs(var) == 0) {\n    // Not reffed - great! let's just use it\n    if (!jsvIsName(var))\n      var = jsvMakeIntoVariableName(var, 0);\n    return jsvLockAgain(var);\n  } else { // it was reffed, we must add a new one\n    return jsvMakeIntoVariableName(jsvCopy(var, false), 0);\n  }\n}\n\n/** Non-recursive finding */\nJsVar *jsvFindChildFromVar(JsVar *parent, JsVar *childName, bool addIfNotFound) {\n  JsVar *child;\n  JsVarRef childref = jsvGetFirstChild(parent);\n\n  while (childref) {\n    child = jsvLock(childref);\n    if (jsvIsBasicVarEqual(child, childName)) {\n      // found it! unlock parent but leave child locked\n      return child;\n    }\n    childref = jsvGetNextSibling(child);\n    jsvUnLock(child);\n  }\n\n  child = 0;\n  if (addIfNotFound && childName) {\n    child = jsvAsName(childName);\n    jsvAddName(parent, child);\n  }\n  return child;\n}\n\nvoid jsvRemoveChild(JsVar *parent, JsVar *child) {\n  assert(jsvHasChildren(parent));\n  assert(jsvIsName(child));\n  JsVarRef childref = jsvGetRef(child);\n  bool wasChild = false;\n  // unlink from parent\n  if (jsvGetFirstChild(parent) == childref) {\n    jsvSetFirstChild(parent, jsvGetNextSibling(child));\n    wasChild = true;\n  }\n  if (jsvGetLastChild(parent) == childref) {\n    jsvSetLastChild(parent, jsvGetPrevSibling(child));\n    wasChild = true;\n    // If this was an array and we were the last\n    // element, update the length\n    if (jsvIsArray(parent)) {\n      JsVarInt l = 0;\n      // get index of last child\n      if (jsvGetLastChild(parent))\n        l = jsvGetIntegerAndUnLock(jsvLock(jsvGetLastChild(parent)))+1;\n      // set it\n      jsvSetArrayLength(parent, l, false);\n    }\n  }\n  // unlink from child list\n  if (jsvGetPrevSibling(child)) {\n    JsVar *v = jsvLock(jsvGetPrevSibling(child));\n    assert(jsvGetNextSibling(v) == jsvGetRef(child));\n    jsvSetNextSibling(v, jsvGetNextSibling(child));\n    jsvUnLock(v);\n    wasChild = true;\n  }\n  if (jsvGetNextSibling(child)) {\n    JsVar *v = jsvLock(jsvGetNextSibling(child));\n    assert(jsvGetPrevSibling(v) == jsvGetRef(child));\n    jsvSetPrevSibling(v, jsvGetPrevSibling(child));\n    jsvUnLock(v);\n    wasChild = true;\n  }\n\n  jsvSetPrevSibling(child, 0);\n  jsvSetNextSibling(child, 0);\n  if (wasChild)\n    jsvUnRef(child);\n}\n\nvoid jsvRemoveAllChildren(JsVar *parent) {\n  assert(jsvHasChildren(parent));\n  while (jsvGetFirstChild(parent)) {\n    JsVar *v = jsvLock(jsvGetFirstChild(parent));\n    jsvRemoveChild(parent, v);\n    jsvUnLock(v);\n  }\n}\n\n/// Check if the given name is a child of the parent\nbool jsvIsChild(JsVar *parent, JsVar *child) {\n  assert(jsvIsArray(parent) || jsvIsObject(parent));\n  assert(jsvIsName(child));\n  JsVarRef childref = jsvGetRef(child);\n  JsVarRef indexref;\n  indexref = jsvGetFirstChild(parent);\n  while (indexref) {\n    if (indexref == childref) return true;\n    // get next\n    JsVar *indexVar = jsvLock(indexref);\n    indexref = jsvGetNextSibling(indexVar);\n    jsvUnLock(indexVar);\n  }\n  return false; // not found undefined\n}\n\n/// Get the named child of an object. If createChild!=0 then create the child\nJsVar *jsvObjectGetChild(JsVar *obj, const char *name, JsVarFlags createChild) {\n  if (!obj) return 0;\n  assert(jsvHasChildren(obj));\n  JsVar *childName = jsvFindChildFromString(obj, name, createChild!=0);\n  JsVar *child = jsvSkipName(childName);\n  if (!child && createChild && childName!=0/*out of memory?*/) {\n    child = jsvNewWithFlags(createChild);\n    jsvSetValueOfName(childName, child);\n    jsvUnLock(childName);\n    return child;\n  }\n  jsvUnLock(childName);\n  return child;\n}\n\n/// Set the named child of an object, and return the child (so you can choose to unlock it if you want)\nJsVar *jsvObjectSetChild(JsVar *obj, const char *name, JsVar *child) {\n  assert(jsvHasChildren(obj));\n  if (!jsvHasChildren(obj)) return 0;\n  // child can actually be a name (for instance if it is a named function)\n  JsVar *childName = jsvFindChildFromString(obj, name, true);\n  if (!childName) return 0; // out of memory\n  jsvSetValueOfName(childName, child);\n  jsvUnLock(childName);\n  return child;\n}\n\n/// Set the named child of an object, and return the child (so you can choose to unlock it if you want)\nJsVar *jsvObjectSetChildVar(JsVar *obj, JsVar *name, JsVar *child) {\n  assert(jsvHasChildren(obj));\n  if (!jsvHasChildren(obj)) return 0;\n  // child can actually be a name (for instance if it is a named function)\n  JsVar *childName = jsvFindChildFromVar(obj, name, true);\n  if (!childName) return 0; // out of memory\n  jsvSetValueOfName(childName, child);\n  jsvUnLock(childName);\n  return child;\n}\n\nvoid jsvObjectSetChildAndUnLock(JsVar *obj, const char *name, JsVar *child) {\n  jsvUnLock(jsvObjectSetChild(obj, name, child));\n}\n\nvoid jsvObjectRemoveChild(JsVar *obj, const char *name) {\n  JsVar *child = jsvFindChildFromString(obj, name, false);\n  if (child) {\n    jsvRemoveChild(obj, child);\n    jsvUnLock(child);\n  }\n}\n\n/** Set the named child of an object, and return the child (so you can choose to unlock it if you want).\n * If the child is 0, the 'name' is also removed from the object */\nJsVar *jsvObjectSetOrRemoveChild(JsVar *obj, const char *name, JsVar *child) {\n  if (child)\n    jsvObjectSetChild(obj, name, child);\n  else\n    jsvObjectRemoveChild(obj, name);\n  return child;\n}\n\n/** Append all keys from the source object to the target object. Will ignore hidden/internal fields */\nvoid jsvObjectAppendAll(JsVar *target, JsVar *source) {\n  assert(jsvIsObject(target));\n  assert(jsvIsObject(source));\n  JsvObjectIterator it;\n  jsvObjectIteratorNew(&it, source);\n  while (jsvObjectIteratorHasValue(&it)) {\n    JsVar *k = jsvObjectIteratorGetKey(&it);\n    JsVar *v = jsvSkipName(k);\n    if (!jsvIsInternalObjectKey(k))\n      jsvObjectSetChildVar(target, k, v);\n    jsvUnLock2(k,v);\n    jsvObjectIteratorNext(&it);\n  }\n  jsvObjectIteratorFree(&it);\n}\n\nint jsvGetChildren(const JsVar *v) {\n  //OPT: could length be stored as the value of the array?\n  int children = 0;\n  JsVarRef childref = jsvGetFirstChild(v);\n  while (childref) {\n    JsVar *child = jsvLock(childref);\n    children++;\n    childref = jsvGetNextSibling(child);\n    jsvUnLock(child);\n  }\n  return children;\n}\n\n/// Get the first child's name from an object,array or function\nJsVar *jsvGetFirstName(JsVar *v) {\n  assert(jsvHasChildren(v));\n  if (!jsvGetFirstChild(v)) return 0;\n  return jsvLock(jsvGetFirstChild(v));\n}\n\nJsVarInt jsvGetArrayLength(const JsVar *arr) {\n  if (!arr) return 0;\n  assert(jsvIsArray(arr));\n  return arr->varData.integer;\n}\n\nJsVarInt jsvSetArrayLength(JsVar *arr, JsVarInt length, bool truncate) {\n  assert(jsvIsArray(arr));\n  if (truncate && length < arr->varData.integer) {\n    // @TODO implement truncation here\n  }\n  arr->varData.integer = length;\n  return length;\n}\n\nJsVarInt jsvGetLength(const JsVar *src) {\n  if (jsvIsArray(src)) {\n    return jsvGetArrayLength(src);\n  } else if (jsvIsArrayBuffer(src)) {\n    return (JsVarInt)jsvGetArrayBufferLength(src);\n  } else if (jsvIsString(src)) {\n    return (JsVarInt)jsvGetStringLength(src);\n  } else if (jsvIsObject(src) || jsvIsFunction(src)) {\n    return jsvGetChildren(src);\n  } else {\n    return 1;\n  }\n}\n\n/** Count the amount of JsVars used. Mostly useful for debugging */\nstatic size_t _jsvCountJsVarsUsedRecursive(JsVar *v, bool resetRecursionFlag) {\n  if (!v) return 0;\n  // Use IS_RECURSING  flag to stop recursion\n  if (resetRecursionFlag) {\n    if (!(v->flags & JSV_IS_RECURSING))\n      return 0;\n    v->flags &= ~JSV_IS_RECURSING;\n  } else {\n    if (v->flags & JSV_IS_RECURSING)\n      return 0;\n    v->flags |= JSV_IS_RECURSING;\n  }\n\n  size_t count = 1;\n  if (jsvHasSingleChild(v) || jsvHasChildren(v)) {\n    JsVarRef childref = jsvGetFirstChild(v);\n    while (childref) {\n      JsVar *child = jsvLock(childref);\n      count += _jsvCountJsVarsUsedRecursive(child, resetRecursionFlag);\n      if (jsvHasChildren(v)) childref = jsvGetNextSibling(child);\n      else childref = 0;\n      jsvUnLock(child);\n    }\n  } else if (jsvIsFlatString(v))\n    count += jsvGetFlatStringBlocks(v);\n  if (jsvHasCharacterData(v)) {\n    JsVarRef childref = jsvGetLastChild(v);\n    while (childref) {\n      JsVar *child = jsvLock(childref);\n      count++;\n      childref = jsvGetLastChild(child);\n      jsvUnLock(child);\n    }\n  }\n  if (jsvIsName(v) && !jsvIsNameWithValue(v) && jsvGetFirstChild(v)) {\n    JsVar *child = jsvLock(jsvGetFirstChild(v));\n    count += _jsvCountJsVarsUsedRecursive(child, resetRecursionFlag);\n    jsvUnLock(child);\n  }\n  return count;\n}\n\n/** Count the amount of JsVars used. Mostly useful for debugging */\nsize_t jsvCountJsVarsUsed(JsVar *v) {\n  // we do this so we don't count the same item twice, but don't use too much memory\n  size_t c = _jsvCountJsVarsUsedRecursive(v, false);\n  _jsvCountJsVarsUsedRecursive(v, true);\n  return c;\n}\n\nJsVar *jsvGetArrayIndex(const JsVar *arr, JsVarInt index) {\n  JsVarRef childref = jsvGetLastChild(arr);\n  JsVarInt lastArrayIndex = 0;\n  // Look at last non-string element!\n  while (childref) {\n    JsVar *child = jsvLock(childref);\n    if (jsvIsInt(child)) {\n      lastArrayIndex = child->varData.integer;\n      // it was the last element... sorted!\n      if (lastArrayIndex == index) {\n        return child;\n      }\n      jsvUnLock(child);\n      break;\n    }\n    // if not an int, keep going\n    childref = jsvGetPrevSibling(child);\n    jsvUnLock(child);\n  }\n  // it's not in this array - don't search the whole lot...\n  if (index > lastArrayIndex)\n    return 0;\n  // otherwise is it more than halfway through?\n  if (index > lastArrayIndex/2) {\n    // it's in the final half of the array (probably) - search backwards\n    while (childref) {\n      JsVar *child = jsvLock(childref);\n\n      assert(jsvIsInt(child));\n      if (child->varData.integer == index) {\n        return child;\n      }\n      childref = jsvGetPrevSibling(child);\n      jsvUnLock(child);\n    }\n  } else {\n    // it's in the first half of the array (probably) - search forwards\n    childref = jsvGetFirstChild(arr);\n    while (childref) {\n      JsVar *child = jsvLock(childref);\n\n      assert(jsvIsInt(child));\n      if (child->varData.integer == index) {\n        return child;\n      }\n      childref = jsvGetNextSibling(child);\n      jsvUnLock(child);\n    }\n  }\n  return 0; // undefined\n}\n\nJsVar *jsvGetArrayItem(const JsVar *arr, JsVarInt index) {\n  return jsvSkipNameAndUnLock(jsvGetArrayIndex(arr,index));\n}\n\nvoid jsvSetArrayItem(JsVar *arr, JsVarInt index, JsVar *item) {\n  JsVar *indexVar = jsvGetArrayIndex(arr, index);\n  if (indexVar) {\n    jsvSetValueOfName(indexVar, item);\n  } else {\n    indexVar = jsvMakeIntoVariableName(jsvNewFromInteger(index), item);\n    jsvAddName(arr, indexVar);\n  }\n  jsvUnLock(indexVar);\n}\n\n// Get all elements from arr and put them in itemPtr (unless it'd overflow).\n// Makes sure all of itemPtr either contains a JsVar or 0\nvoid jsvGetArrayItems(JsVar *arr, unsigned int itemCount, JsVar **itemPtr) {\n  JsvObjectIterator it;\n  jsvObjectIteratorNew(&it, arr);\n  unsigned int i = 0;\n  while (jsvObjectIteratorHasValue(&it)) {\n    if (i<itemCount)\n      itemPtr[i++] = jsvObjectIteratorGetValue(&it);\n    jsvObjectIteratorNext(&it);\n  }\n  jsvObjectIteratorFree(&it);\n  while (i<itemCount)\n    itemPtr[i++] = 0; // just ensure we don't end up with bad data\n}\n\n/// Get the index of the value in the array (matchExact==use pointer not equality check, matchIntegerIndices = don't check non-integers)\nJsVar *jsvGetIndexOfFull(JsVar *arr, JsVar *value, bool matchExact, bool matchIntegerIndices, int startIdx) {\n  JsVarRef indexref;\n  assert(jsvIsArray(arr) || jsvIsObject(arr));\n  indexref = jsvGetFirstChild(arr);\n  while (indexref) {\n    JsVar *childIndex = jsvLock(indexref);\n    if (!matchIntegerIndices ||\n        (jsvIsInt(childIndex) && jsvGetInteger(childIndex)>=startIdx)) {\n      assert(jsvIsName(childIndex));\n      JsVar *childValue = jsvSkipName(childIndex);\n      if (childValue==value ||\n          (!matchExact && jsvMathsOpTypeEqual(childValue, value))) {\n        jsvUnLock(childValue);\n        return childIndex;\n      }\n      jsvUnLock(childValue);\n    }\n    indexref = jsvGetNextSibling(childIndex);\n    jsvUnLock(childIndex);\n  }\n  return 0; // undefined\n}\n\n/// Get the index of the value in the array or object (matchExact==use pointer, not equality check)\nJsVar *jsvGetIndexOf(JsVar *arr, JsVar *value, bool matchExact) {\n  return jsvGetIndexOfFull(arr, value, matchExact, false, 0);\n}\n\n\n/// Adds new elements to the end of an array, and returns the new length. initialValue is the item index when no items are currently in the array.\nJsVarInt jsvArrayAddToEnd(JsVar *arr, JsVar *value, JsVarInt initialValue) {\n  assert(jsvIsArray(arr));\n  JsVarInt index = initialValue;\n  if (jsvGetLastChild(arr)) {\n    JsVar *last = jsvLock(jsvGetLastChild(arr));\n    index = jsvGetInteger(last)+1;\n    jsvUnLock(last);\n  }\n\n  JsVar *idx = jsvMakeIntoVariableName(jsvNewFromInteger(index), value);\n  if (!idx) return 0; // out of memory - error flag will have been set already\n  jsvAddName(arr, idx);\n  jsvUnLock(idx);\n  return index+1;\n}\n\n/// Adds new elements to the end of an array, and returns the new length\nJsVarInt jsvArrayPush(JsVar *arr, JsVar *value) {\n  assert(jsvIsArray(arr));\n  JsVarInt index = jsvGetArrayLength(arr);\n  JsVar *idx = jsvMakeIntoVariableName(jsvNewFromInteger(index), value);\n  if (!idx) return 0; // out of memory - error flag will have been set already\n  jsvAddName(arr, idx);\n  jsvUnLock(idx);\n  return jsvGetArrayLength(arr);\n}\n\n/// Adds a new element to the end of an array, unlocks it, and returns the new length\nJsVarInt jsvArrayPushAndUnLock(JsVar *arr, JsVar *value) {\n  JsVarInt l = jsvArrayPush(arr, value);\n  jsvUnLock(value);\n  return l;\n}\n\n/// Append all values from the source array to the target array\nvoid jsvArrayPushAll(JsVar *target, JsVar *source, bool checkDuplicates) {\n  assert(jsvIsArray(target));\n  assert(jsvIsArray(source));\n  JsvObjectIterator it;\n  jsvObjectIteratorNew(&it, source);\n  while (jsvObjectIteratorHasValue(&it)) {\n    JsVar *v = jsvObjectIteratorGetValue(&it);\n    bool add = true;\n    if (checkDuplicates) {\n      JsVar *idx = jsvGetIndexOf(target, v, false);\n      if (idx) {\n        add = false;\n        jsvUnLock(idx);\n      }\n    }\n    if (add) jsvArrayPush(target, v);\n    jsvUnLock(v);\n    jsvObjectIteratorNext(&it);\n  }\n  jsvObjectIteratorFree(&it);\n}\n\n/// Removes the last element of an array, and returns that element (or 0 if empty). includes the NAME\nJsVar *jsvArrayPop(JsVar *arr) {\n  assert(jsvIsArray(arr));\n  JsVar *child = 0;\n  JsVarInt length = jsvGetArrayLength(arr);\n  if (length > 0) {\n    length--;\n\n    if (jsvGetLastChild(arr)) {\n      // find last child with an integer key\n      JsVarRef ref = jsvGetLastChild(arr);\n      child = jsvLock(ref);\n      while (child && !jsvIsInt(child)) {\n        ref = jsvGetPrevSibling(child);\n        jsvUnLock(child);\n        if (ref) {\n          child = jsvLock(ref);\n        } else {\n          child = 0;\n        }\n      }\n      // check if the last integer key really is the last element\n      if (child) {\n        if (jsvGetInteger(child) == length) {\n          // child is the last element - remove it\n          jsvRemoveChild(arr, child);\n        } else {\n          // child is not the last element\n          jsvUnLock(child);\n          child = 0;\n        }\n      }\n    }\n    // and finally shrink the array\n    jsvSetArrayLength(arr, length, false);\n  }\n\n  return child;\n}\n\n/// Removes the first element of an array, and returns that element (or 0 if empty). DOES NOT RENUMBER.\nJsVar *jsvArrayPopFirst(JsVar *arr) {\n  assert(jsvIsArray(arr));\n  if (jsvGetFirstChild(arr)) {\n    JsVar *child = jsvLock(jsvGetFirstChild(arr));\n    if (jsvGetFirstChild(arr) == jsvGetLastChild(arr))\n      jsvSetLastChild(arr, 0); // if 1 item in array\n    jsvSetFirstChild(arr, jsvGetNextSibling(child)); // unlink from end of array\n    jsvUnRef(child); // as no longer in array\n    if (jsvGetNextSibling(child)) {\n      JsVar *v = jsvLock(jsvGetNextSibling(child));\n      jsvSetPrevSibling(v, 0);\n      jsvUnLock(v);\n    }\n    jsvSetNextSibling(child, 0);\n    return child; // and return it\n  } else {\n    // no children!\n    return 0;\n  }\n}\n\n/// Adds a new variable element to the end of an array (IF it was not already there). Return true if successful\nvoid jsvArrayAddUnique(JsVar *arr, JsVar *v) {\n  JsVar *idx = jsvGetIndexOf(arr, v, false); // did it already exist?\n  if (!idx) {\n    jsvArrayPush(arr, v); // if 0, it failed\n  } else {\n    jsvUnLock(idx);\n  }\n}\n\n/// Join all elements of an array together into a string\nJsVar *jsvArrayJoin(JsVar *arr, JsVar *filler) {\n  JsVar *str = jsvNewFromEmptyString();\n  if (!str) return 0; // out of memory\n\n  JsvIterator it;\n  jsvIteratorNew(&it, arr, JSIF_EVERY_ARRAY_ELEMENT);\n  bool first = true;\n  while (!jspIsInterrupted() && jsvIteratorHasElement(&it)) {\n    JsVar *key = jsvIteratorGetKey(&it);\n    if (jsvIsInt(key)) {\n      // add the filler\n      if (filler && !first)\n        jsvAppendStringVarComplete(str, filler);\n      first = false;\n      // add the value\n      JsVar *value = jsvIteratorGetValue(&it);\n      if (value && !jsvIsNull(value)) {\n        JsVar *valueStr = jsvAsString(value, false);\n        if (valueStr) { // could be out of memory\n          jsvAppendStringVarComplete(str, valueStr);\n          jsvUnLock(valueStr);\n        }\n      }\n      jsvUnLock(value);\n    }\n    jsvUnLock(key);\n    jsvIteratorNext(&it);\n  }\n  jsvIteratorFree(&it);\n  return str;\n}\n\n/// Insert a new element before beforeIndex, DOES NOT UPDATE INDICES\nvoid jsvArrayInsertBefore(JsVar *arr, JsVar *beforeIndex, JsVar *element) {\n  if (beforeIndex) {\n    JsVar *idxVar = jsvMakeIntoVariableName(jsvNewFromInteger(0), element);\n    if (!idxVar) return; // out of memory\n\n    JsVarRef idxRef = jsvGetRef(jsvRef(idxVar));\n    JsVarRef prev = jsvGetPrevSibling(beforeIndex);\n    if (prev) {\n      JsVar *prevVar = jsvRef(jsvLock(prev));\n      jsvSetInteger(idxVar, jsvGetInteger(prevVar)+1); // update index number\n      jsvSetNextSibling(prevVar, idxRef);\n      jsvUnLock(prevVar);\n      jsvSetPrevSibling(idxVar, prev);\n    } else {\n      jsvSetPrevSibling(idxVar, 0);\n      jsvSetFirstChild(arr, idxRef);\n    }\n    jsvSetPrevSibling(beforeIndex, idxRef);\n    jsvSetNextSibling(idxVar, jsvGetRef(jsvRef(beforeIndex)));\n    jsvUnLock(idxVar);\n  } else\n    jsvArrayPush(arr, element);\n}\n\n/** Same as jsvMathsOpPtr, but if a or b are a name, skip them\n * and go to what they point to. Also handle the case where\n * they may be objects with valueOf functions. */\nJsVar *jsvMathsOpSkipNames(JsVar *a, JsVar *b, int op) {\n  JsVar *pa = jsvSkipName(a);\n  JsVar *pb = jsvSkipName(b);\n  JsVar *oa = jsvGetValueOf(pa);\n  JsVar *ob = jsvGetValueOf(pb);\n  jsvUnLock2(pa, pb);\n  JsVar *res = jsvMathsOp(oa,ob,op);\n  jsvUnLock2(oa, ob);\n  return res;\n}\n\n\nJsVar *jsvMathsOpError(int op, const char *datatype) {\n  char opName[32];\n  jslTokenAsString(op, opName, sizeof(opName));\n  jsError(\"Operation %s not supported on the %s datatype\", opName, datatype);\n  return 0;\n}\n\nbool jsvMathsOpTypeEqual(JsVar *a, JsVar *b) {\n  // check type first, then call again to check data\n  bool eql = (a==0) == (b==0);\n  if (a && b) {\n    // Check whether both are numbers, otherwise check the variable\n    // type flags themselves\n    eql = ((jsvIsInt(a)||jsvIsFloat(a)) && (jsvIsInt(b)||jsvIsFloat(b))) ||\n        ((a->flags & JSV_VARTYPEMASK) == (b->flags & JSV_VARTYPEMASK));\n  }\n  if (eql) {\n    JsVar *contents = jsvMathsOp(a,b, LEX_EQUAL);\n    if (!jsvGetBool(contents)) eql = false;\n    jsvUnLock(contents);\n  } else {\n    /* Make sure we don't get in the situation where we have two equal\n     * strings with a check that fails because they were stored differently */\n    assert(!(jsvIsString(a) && jsvIsString(b) && jsvIsBasicVarEqual(a,b)));\n  }\n  return eql;\n}\n\nJsVar *jsvMathsOp(JsVar *a, JsVar *b, int op) {\n  // Type equality check\n  if (op == LEX_TYPEEQUAL || op == LEX_NTYPEEQUAL) {\n    bool eql = jsvMathsOpTypeEqual(a,b);\n    if (op == LEX_TYPEEQUAL)\n      return jsvNewFromBool(eql);\n    else\n      return jsvNewFromBool(!eql);\n  }\n\n  bool needsInt = op=='&' || op=='|' || op=='^' || op==LEX_LSHIFT || op==LEX_RSHIFT || op==LEX_RSHIFTUNSIGNED;\n  bool needsNumeric = needsInt || op=='*' || op=='/' || op=='%' || op=='-';\n  bool isCompare = op==LEX_EQUAL || op==LEX_NEQUAL || op=='<' || op==LEX_LEQUAL || op=='>'|| op==LEX_GEQUAL;\n  if (isCompare) {\n    if (jsvIsNumeric(a) && jsvIsString(b)) {\n      needsNumeric = true;\n      needsInt = jsvIsIntegerish(a) && jsvIsStringNumericInt(b, false);\n    } else if (jsvIsNumeric(b) && jsvIsString(a)) {\n      needsNumeric = true;\n      needsInt = jsvIsIntegerish(b) && jsvIsStringNumericInt(a, false);\n    }\n  }\n\n  // do maths...\n  if (jsvIsUndefined(a) && jsvIsUndefined(b)) {\n    if (op == LEX_EQUAL)\n      return jsvNewFromBool(true);\n    else if (op == LEX_NEQUAL)\n      return jsvNewFromBool(false);\n    else\n      return 0; // undefined\n  } else if (needsNumeric ||\n      ((jsvIsNumeric(a) || jsvIsUndefined(a) || jsvIsNull(a)) &&\n          (jsvIsNumeric(b) || jsvIsUndefined(b) || jsvIsNull(b)))) {\n    if (needsInt || (jsvIsIntegerish(a) && jsvIsIntegerish(b))) {\n      // note that int+undefined should be handled as a double\n      // use ints\n      JsVarInt da = jsvGetInteger(a);\n      JsVarInt db = jsvGetInteger(b);\n      switch (op) {\n      case '+': return jsvNewFromLongInteger((long long)da + (long long)db);\n      case '-': return jsvNewFromLongInteger((long long)da - (long long)db);\n      case '*': return jsvNewFromLongInteger((long long)da * (long long)db);\n      case '/': return jsvNewFromFloat((JsVarFloat)da/(JsVarFloat)db);\n      case '&': return jsvNewFromInteger(da&db);\n      case '|': return jsvNewFromInteger(da|db);\n      case '^': return jsvNewFromInteger(da^db);\n      case '%': return db ? jsvNewFromInteger(da%db) : jsvNewFromFloat(NAN);\n      case LEX_LSHIFT: return jsvNewFromInteger(da << db);\n      case LEX_RSHIFT: return jsvNewFromInteger(da >> db);\n      case LEX_RSHIFTUNSIGNED: return jsvNewFromInteger((JsVarInt)(((JsVarIntUnsigned)da) >> db));\n      case LEX_EQUAL:     return jsvNewFromBool(da==db && jsvIsNull(a)==jsvIsNull(b));\n      case LEX_NEQUAL:    return jsvNewFromBool(da!=db || jsvIsNull(a)!=jsvIsNull(b));\n      case '<':           return jsvNewFromBool(da<db);\n      case LEX_LEQUAL:    return jsvNewFromBool(da<=db);\n      case '>':           return jsvNewFromBool(da>db);\n      case LEX_GEQUAL:    return jsvNewFromBool(da>=db);\n      default: return jsvMathsOpError(op, \"Integer\");\n      }\n    } else {\n      // use doubles\n      JsVarFloat da = jsvGetFloat(a);\n      JsVarFloat db = jsvGetFloat(b);\n      switch (op) {\n      case '+': return jsvNewFromFloat(da+db);\n      case '-': return jsvNewFromFloat(da-db);\n      case '*': return jsvNewFromFloat(da*db);\n      case '/': return jsvNewFromFloat(da/db);\n      case '%': return jsvNewFromFloat(jswrap_math_mod(da, db));\n      case LEX_EQUAL:\n      case LEX_NEQUAL:  { bool equal = da==db;\n      if ((jsvIsNull(a) && jsvIsUndefined(b)) ||\n          (jsvIsNull(b) && jsvIsUndefined(a))) equal = true; // JS quirk :)\n      return jsvNewFromBool((op==LEX_EQUAL) ? equal : ((bool)!equal));\n      }\n      case '<':           return jsvNewFromBool(da<db);\n      case LEX_LEQUAL:    return jsvNewFromBool(da<=db);\n      case '>':           return jsvNewFromBool(da>db);\n      case LEX_GEQUAL:    return jsvNewFromBool(da>=db);\n      default: return jsvMathsOpError(op, \"Double\");\n      }\n    }\n  } else if ((jsvIsArray(a) || jsvIsObject(a) || jsvIsFunction(a) ||\n      jsvIsArray(b) || jsvIsObject(b) || jsvIsFunction(b)) &&\n      jsvIsArray(a)==jsvIsArray(b) && // Fix #283 - convert to string and test if only one is an array\n      (op == LEX_EQUAL || op==LEX_NEQUAL)) {\n    bool equal = a==b;\n\n    if (jsvIsNativeFunction(a) || jsvIsNativeFunction(b)) {\n      // even if one is not native, the contents will be different\n      equal = a && b && \n          a->varData.native.ptr == b->varData.native.ptr &&\n          a->varData.native.argTypes == b->varData.native.argTypes &&\n          jsvGetFirstChild(a) == jsvGetFirstChild(b);\n    }\n\n    /* Just check pointers */\n    switch (op) {\n    case LEX_EQUAL:  return jsvNewFromBool(equal);\n    case LEX_NEQUAL: return jsvNewFromBool(!equal);\n    default: return jsvMathsOpError(op, jsvIsArray(a)?\"Array\":\"Object\");\n    }\n  } else {\n    JsVar *da = jsvAsString(a, false);\n    JsVar *db = jsvAsString(b, false);\n    if (!da || !db) { // out of memory\n      jsvUnLock2(da, db);\n      return 0;\n    }\n    if (op=='+') {\n      JsVar *v = jsvCopy(da, false);\n      // TODO: can we be fancy and not copy da if we know it isn't reffed? what about locks?\n      if (v) // could be out of memory\n        jsvAppendStringVarComplete(v, db);\n      jsvUnLock2(da, db);\n      return v;\n    }\n\n    int cmp = jsvCompareString(da,db,0,0,false);\n    jsvUnLock2(da, db);\n    // use strings\n    switch (op) {\n    case LEX_EQUAL:     return jsvNewFromBool(cmp==0);\n    case LEX_NEQUAL:    return jsvNewFromBool(cmp!=0);\n    case '<':           return jsvNewFromBool(cmp<0);\n    case LEX_LEQUAL:    return jsvNewFromBool(cmp<=0);\n    case '>':           return jsvNewFromBool(cmp>0);\n    case LEX_GEQUAL:    return jsvNewFromBool(cmp>=0);\n    default: return jsvMathsOpError(op, \"String\");\n    }\n  }\n}\n\nJsVar *jsvNegateAndUnLock(JsVar *v) {\n  JsVar *zero = jsvNewFromInteger(0);\n  JsVar *res = jsvMathsOpSkipNames(zero, v, '-');\n  jsvUnLock2(zero, v);\n  return res;\n}\n\n/** If the given element is found, return the path to it as a string of\n * the form 'foo.bar', else return 0. If we would have returned a.b and\n * ignoreParent is a, don't! */\nJsVar *jsvGetPathTo(JsVar *root, JsVar *element, int maxDepth, JsVar *ignoreParent) {\n  if (maxDepth<=0) return 0;\n  JsvIterator it;\n  jsvIteratorNew(&it, root, JSIF_DEFINED_ARRAY_ElEMENTS);\n  while (jsvIteratorHasElement(&it)) {\n    JsVar *el = jsvIteratorGetValue(&it);\n    if (el == element && root != ignoreParent) {\n      // if we found it - send the key name back!\n      JsVar *name = jsvAsString(jsvIteratorGetKey(&it), true);\n      jsvIteratorFree(&it);\n      return name;\n    } else if (jsvIsObject(el) || jsvIsArray(el) || jsvIsFunction(el)) {\n      // recursively search\n      JsVar *n = jsvGetPathTo(el, element, maxDepth-1, ignoreParent);\n      if (n) {\n        // we found it! Append our name onto it as well\n        JsVar *keyName = jsvIteratorGetKey(&it);\n        JsVar *name = jsvVarPrintf(jsvIsObject(el) ? \"%v.%v\" : \"%v[%q]\",keyName,n);\n        jsvUnLock2(keyName, n);\n        jsvIteratorFree(&it);\n        return name;\n      }\n    }\n    jsvIteratorNext(&it);\n  }\n  jsvIteratorFree(&it);\n  return 0;\n}\n\nvoid jsvTraceLockInfo(JsVar *v) {\n  jsiConsolePrintf(\"#%d[r%d,l%d] \",jsvGetRef(v),jsvGetRefs(v),jsvGetLocks(v));\n}\n\n/** Get the lowest level at which searchRef appears */\nint _jsvTraceGetLowestLevel(JsVar *var, JsVar *searchVar) {\n  if (var == searchVar) return 0;\n  int found = -1;\n\n  // Use IS_RECURSING  flag to stop recursion\n  if (var->flags & JSV_IS_RECURSING)\n    return -1;\n  var->flags |= JSV_IS_RECURSING;\n\n  if (jsvHasSingleChild(var) && jsvGetFirstChild(var)) {\n    JsVar *child = jsvLock(jsvGetFirstChild(var));\n    int f = _jsvTraceGetLowestLevel(child, searchVar);\n    jsvUnLock(child);\n    if (f>=0 && (found<0 || f<found)) found=f+1;\n  }\n  if (jsvHasChildren(var)) {\n    JsVarRef childRef = jsvGetFirstChild(var);\n    while (childRef) {\n      JsVar *child = jsvLock(childRef);\n      int f = _jsvTraceGetLowestLevel(child, searchVar);\n      if (f>=0 && (found<0 || f<found)) found=f+1;\n      childRef = jsvGetNextSibling(child);\n      jsvUnLock(child);\n    }\n  }\n\n  var->flags &= ~JSV_IS_RECURSING;\n\n  return found; // searchRef not found\n}\n\nvoid _jsvTrace(JsVar *var, int indent, JsVar *baseVar, int level) {\n#ifdef SAVE_ON_FLASH\n  jsiConsolePrint(\"Trace unimplemented in this version.\\n\");\n#else\n  int i;\n  for (i=0;i<indent;i++) jsiConsolePrint(\" \");\n\n  if (!var) {\n    jsiConsolePrint(\"undefined\");\n    return;\n  }\n\n  jsvTraceLockInfo(var);\n\n  int lowestLevel = _jsvTraceGetLowestLevel(baseVar, var);\n  if (lowestLevel < level) {\n    // If this data is available elsewhere in the tree (but nearer the root)\n    // then don't print it. This makes the dump significantly more readable!\n    // It also stops us getting in recursive loops ...\n    jsiConsolePrint(\"...\\n\");\n    return;\n  }\n\n  if (jsvIsName(var)) jsiConsolePrint(\"Name \");\n\n  char endBracket = ' ';\n  if (jsvIsObject(var)) { jsiConsolePrint(\"Object { \"); endBracket = '}'; }\n  else if (jsvIsArray(var)) { jsiConsolePrintf(\"Array(%d) [ \", var->varData.integer); endBracket = ']'; }\n  else if (jsvIsNativeFunction(var)) { jsiConsolePrintf(\"NativeFunction 0x%x (%d) { \", var->varData.native.ptr, var->varData.native.argTypes); endBracket = '}'; }\n  else if (jsvIsFunction(var)) {\n    jsiConsolePrint(\"Function { \");\n    if (jsvIsFunctionReturn(var)) jsiConsolePrint(\"return \");\n    endBracket = '}';\n  } else if (jsvIsPin(var)) jsiConsolePrintf(\"Pin %d\", jsvGetInteger(var));\n  else if (jsvIsInt(var)) jsiConsolePrintf(\"Integer %d\", jsvGetInteger(var));\n  else if (jsvIsBoolean(var)) jsiConsolePrintf(\"Bool %s\", jsvGetBool(var)?\"true\":\"false\");\n  else if (jsvIsFloat(var)) jsiConsolePrintf(\"Double %f\", jsvGetFloat(var));\n  else if (jsvIsFunctionParameter(var)) jsiConsolePrintf(\"Param %q \", var);\n  else if (jsvIsArrayBufferName(var)) jsiConsolePrintf(\"ArrayBufferName[%d] \", jsvGetInteger(var));\n  else if (jsvIsArrayBuffer(var)) jsiConsolePrintf(\"%s \", jswGetBasicObjectName(var)?jswGetBasicObjectName(var):\"unknown ArrayBuffer\"); // way to get nice name\n  else if (jsvIsString(var)) {\n    size_t blocks = 1;\n    if (jsvGetLastChild(var)) {\n      JsVar *v = jsvLock(jsvGetLastChild(var));\n      blocks += jsvCountJsVarsUsed(v);\n      jsvUnLock(v);\n    }\n    if (jsvIsFlatString(var)) {\n      blocks += jsvGetFlatStringBlocks(var);\n    }\n    jsiConsolePrintf(\"%sString [%d blocks] %q\", jsvIsFlatString(var)?\"Flat\":(jsvIsNativeString(var)?\"Native\":\"\"), blocks, var);\n  } else {\n    jsiConsolePrintf(\"Unknown %d\", var->flags & (JsVarFlags)~(JSV_LOCK_MASK));\n  }\n\n  // print a value if it was stored in here as well...\n  if (jsvIsNameInt(var)) {\n    jsiConsolePrintf(\"= int %d\\n\", (int)jsvGetFirstChildSigned(var));\n    return;\n  } else if (jsvIsNameIntBool(var)) {\n    jsiConsolePrintf(\"= bool %s\\n\", jsvGetFirstChild(var)?\"true\":\"false\");\n    return;\n  }\n\n  if (jsvHasSingleChild(var)) {\n    JsVar *child = jsvGetFirstChild(var) ? jsvLock(jsvGetFirstChild(var)) : 0;\n    _jsvTrace(child, indent+2, baseVar, level+1);\n    jsvUnLock(child);\n  } else if (jsvHasChildren(var)) {\n    JsvIterator it;\n    jsvIteratorNew(&it, var, JSIF_DEFINED_ARRAY_ElEMENTS);\n    bool first = true;\n    while (jsvIteratorHasElement(&it) && !jspIsInterrupted()) {\n      if (first) jsiConsolePrintf(\"\\n\");\n      first = false;\n      JsVar *child = jsvIteratorGetKey(&it);\n      _jsvTrace(child, indent+2, baseVar, level+1);\n      jsvUnLock(child);\n      jsiConsolePrintf(\"\\n\");\n      jsvIteratorNext(&it);\n    }\n    jsvIteratorFree(&it);\n    if (!first)\n      for (i=0;i<indent;i++) jsiConsolePrint(\" \");\n  }\n  jsiConsolePrintf(\"%c\", endBracket);\n#endif\n}\n\n/** Write debug info for this Var out to the console */\nvoid jsvTrace(JsVar *var, int indent) {\n  _jsvTrace(var,indent,var,0);\n  jsiConsolePrintf(\"\\n\");\n}\n\n\n/** Recursively mark the variable */\nstatic void jsvGarbageCollectMarkUsed(JsVar *var) {\n  var->flags &= (JsVarFlags)~JSV_GARBAGE_COLLECT;\n\n  if (jsvHasCharacterData(var)) {\n    // non-recursively scan strings\n    JsVarRef child = jsvGetLastChild(var);\n    while (child) {\n      JsVar *childVar;\n      childVar = jsvGetAddressOf(child);\n      childVar->flags &= (JsVarFlags)~JSV_GARBAGE_COLLECT;\n      child = jsvGetLastChild(childVar);\n    }\n  }\n  // intentionally no else\n  if (jsvHasSingleChild(var)) {\n    if (jsvGetFirstChild(var)) {\n      JsVar *childVar = jsvGetAddressOf(jsvGetFirstChild(var));\n      if (childVar->flags & JSV_GARBAGE_COLLECT)\n        jsvGarbageCollectMarkUsed(childVar);\n    }\n  } else if (jsvHasChildren(var)) {\n    JsVarRef child = jsvGetFirstChild(var);\n    while (child) {\n      JsVar *childVar;\n      childVar = jsvGetAddressOf(child);\n      if (childVar->flags & JSV_GARBAGE_COLLECT)\n        jsvGarbageCollectMarkUsed(childVar);\n      child = jsvGetNextSibling(childVar);\n    }\n  }\n}\n\n/** Run a garbage collection sweep - return nonzero if things have been freed */\nint jsvGarbageCollect() {\n  if (isMemoryBusy) return false;\n  isMemoryBusy = MEMBUSY_GC;\n  JsVarRef i;\n  // Add GC flags to anything that is currently used\n  for (i=1;i<=jsVarsSize;i++)  {\n    JsVar *var = jsvGetAddressOf(i);\n    if ((var->flags&JSV_VARTYPEMASK) != JSV_UNUSED) { // if it is not unused\n      var->flags |= (JsVarFlags)JSV_GARBAGE_COLLECT;\n      // if we have a flat string, skip that many blocks\n      if (jsvIsFlatString(var))\n        i = (JsVarRef)(i+jsvGetFlatStringBlocks(var));\n    }\n  }\n  /* recursively remove anything that is referenced from a var that is locked. */\n  for (i=1;i<=jsVarsSize;i++)  {\n    JsVar *var = jsvGetAddressOf(i);\n    if ((var->flags & JSV_GARBAGE_COLLECT) && // not already GC'd\n        jsvGetLocks(var)>0) // or it is locked\n      jsvGarbageCollectMarkUsed(var);\n    // if we have a flat string, skip that many blocks\n    if (jsvIsFlatString(var))\n      i = (JsVarRef)(i+jsvGetFlatStringBlocks(var));\n  }\n  /* now sweep for things that we can GC!\n   * Also update the free list - this means that every new variable that\n   * gets allocated gets allocated towards the start of memory, which\n   * hopefully helps compact everything towards the start. */\n  unsigned int freedCount = 0;\n  jsVarFirstEmpty = 0;\n  JsVar *lastEmpty = 0;\n  for (i=1;i<=jsVarsSize;i++)  {\n    JsVar *var = jsvGetAddressOf(i);\n    if (var->flags & JSV_GARBAGE_COLLECT) {\n      if (jsvIsFlatString(var)) {\n        // If we're a flat string, there are more blocks to free.\n        unsigned int count = (unsigned int)jsvGetFlatStringBlocks(var);\n        freedCount+=count;\n        // Free the first block\n        var->flags = JSV_UNUSED;\n        // add this to our free list\n        if (lastEmpty) jsvSetNextSibling(lastEmpty, i);\n        else jsVarFirstEmpty = i;\n        lastEmpty = var;\n        // free subsequent blocks\n        while (count-- > 0) {\n          i++;\n          var = jsvGetAddressOf((JsVarRef)(i));\n          var->flags = JSV_UNUSED;\n          // add this to our free list\n          if (lastEmpty) jsvSetNextSibling(lastEmpty, i);\n          else jsVarFirstEmpty = i;\n          lastEmpty = var;\n        }\n      } else {\n        // otherwise just free 1 block\n        if (jsvHasSingleChild(var)) {\n          /* If this had a child that wasn't listed for GC then we need to\n           * unref it. Everything else is fine because it'll disappear anyway.\n           * We don't have to check if we should free this other variable\n           * here because we know the GC picked up it was referenced from\n           * somewhere else. */\n          JsVarRef ch = jsvGetFirstChild(var);\n          if (ch) {\n            JsVar *child = jsvGetAddressOf(ch); // not locked\n            if (child->flags!=JSV_UNUSED && // not already GC'd!\n                !(child->flags&JSV_GARBAGE_COLLECT)) // not marked for GC\n              jsvUnRef(child);\n          }\n        }\n        /* Sanity checks here. We're making sure that any variables that are\n         * linked from this one have either already been garbage collected or\n         * are marked for GC */\n        assert(!jsvHasChildren(var) || !jsvGetFirstChild(var) ||\n            jsvGetAddressOf(jsvGetFirstChild(var))->flags==JSV_UNUSED ||\n            (jsvGetAddressOf(jsvGetFirstChild(var))->flags&JSV_GARBAGE_COLLECT));\n        assert(!jsvHasChildren(var) || !jsvGetLastChild(var) ||\n            jsvGetAddressOf(jsvGetLastChild(var))->flags==JSV_UNUSED ||\n            (jsvGetAddressOf(jsvGetLastChild(var))->flags&JSV_GARBAGE_COLLECT));\n        assert(!jsvIsName(var) || !jsvGetPrevSibling(var) ||\n            jsvGetAddressOf(jsvGetPrevSibling(var))->flags==JSV_UNUSED ||\n            (jsvGetAddressOf(jsvGetPrevSibling(var))->flags&JSV_GARBAGE_COLLECT));\n        assert(!jsvIsName(var) || !jsvGetNextSibling(var) ||\n            jsvGetAddressOf(jsvGetNextSibling(var))->flags==JSV_UNUSED ||\n            (jsvGetAddressOf(jsvGetNextSibling(var))->flags&JSV_GARBAGE_COLLECT));\n        // free!\n        var->flags = JSV_UNUSED;\n        // add this to our free list\n        if (lastEmpty) jsvSetNextSibling(lastEmpty, i);\n        else jsVarFirstEmpty = i;\n        lastEmpty = var;\n        freedCount++;\n      }\n    } else if (jsvIsFlatString(var)) {\n      // if we have a flat string, skip forward that many blocks\n      i = (JsVarRef)(i+jsvGetFlatStringBlocks(var));\n    } else if (var->flags == JSV_UNUSED) {\n      // this is already free - add it to the free list\n      if (lastEmpty) jsvSetNextSibling(lastEmpty, i);\n      else jsVarFirstEmpty = i;\n      lastEmpty = var;\n    }\n  }\n  if (lastEmpty) jsvSetNextSibling(lastEmpty, 0);\n  isMemoryBusy = MEM_NOT_BUSY;\n  return (int)freedCount;\n}\n\n#ifndef RELEASE\n// Dump any locked variables that aren't referenced from `global` - for debugging memory leaks\nvoid jsvDumpLockedVars() {\n  jsvGarbageCollect();\n  if (isMemoryBusy) return;\n  isMemoryBusy = MEMBUSY_SYSTEM;\n  JsVarRef i;\n  // clear garbage collect flags\n  for (i=1;i<=jsVarsSize;i++)  {\n    JsVar *var = jsvGetAddressOf(i);\n    if ((var->flags&JSV_VARTYPEMASK) != JSV_UNUSED) { // if it is not unused\n      var->flags |= (JsVarFlags)JSV_GARBAGE_COLLECT;\n      // if we have a flat string, skip that many blocks\n      if (jsvIsFlatString(var))\n        i = (JsVarRef)(i+jsvGetFlatStringBlocks(var));\n    }\n  }\n  // Add global\n  jsvGarbageCollectMarkUsed(execInfo.root);\n  // Now dump any that aren't used!\n  for (i=1;i<=jsVarsSize;i++)  {\n    JsVar *var = jsvGetAddressOf(i);\n    if ((var->flags&JSV_VARTYPEMASK) != JSV_UNUSED) {\n      if (var->flags & JSV_GARBAGE_COLLECT) {\n        jsvGarbageCollectMarkUsed(var);\n        jsvTrace(var, 0);\n      }\n    }\n  }\n  isMemoryBusy = MEM_NOT_BUSY;\n}\n\n// Dump the free list - in order\nvoid jsvDumpFreeList() {\n  JsVarRef ref = jsVarFirstEmpty;\n  int n = 0;\n  while (ref) {\n    jsiConsolePrintf(\"%5d \", (int)ref);\n    if (++n >= 16) {\n      n = 0;\n      jsiConsolePrintf(\"\\n\");\n    }\n    JsVar *v = jsvGetAddressOf(ref);\n    ref = jsvGetNextSibling(v);\n  }\n  jsiConsolePrintf(\"\\n\");\n}\n#endif\n\n\n/** Remove whitespace to the right of a string - on MULTIPLE LINES */\nJsVar *jsvStringTrimRight(JsVar *srcString) {\n  JsvStringIterator src, dst;\n  JsVar *dstString = jsvNewFromEmptyString();\n  jsvStringIteratorNew(&src, srcString, 0);\n  jsvStringIteratorNew(&dst, dstString, 0);\n  int spaces = 0;\n  while (jsvStringIteratorHasChar(&src)) {\n    char ch = jsvStringIteratorGetChar(&src);\n    jsvStringIteratorNext(&src);\n\n    if (ch==' ') spaces++;\n    else if (ch=='\\n') {\n      spaces = 0;\n      jsvStringIteratorAppend(&dst, ch);\n    } else {\n      for (;spaces>0;spaces--)\n        jsvStringIteratorAppend(&dst, ' ');\n      jsvStringIteratorAppend(&dst, ch);\n    }\n  }\n  jsvStringIteratorFree(&src);\n  jsvStringIteratorFree(&dst);\n  return dstString;\n}\n\n/// If v is the key of a function, return true if it is internal and shouldn't be visible to the user\nbool jsvIsInternalFunctionKey(JsVar *v) {\n  return (jsvIsString(v) && (\n      v->varData.str[0]==JS_HIDDEN_CHAR)\n  ) ||\n  jsvIsFunctionParameter(v);\n}\n\n/// If v is the key of an object, return true if it is internal and shouldn't be visible to the user\nbool jsvIsInternalObjectKey(JsVar *v) {\n  return (jsvIsString(v) && (\n      v->varData.str[0]==JS_HIDDEN_CHAR ||\n      jsvIsStringEqual(v, JSPARSE_INHERITS_VAR) ||\n      jsvIsStringEqual(v, JSPARSE_CONSTRUCTOR_VAR)\n  ));\n}\n\n/// Get the correct checker function for the given variable. see jsvIsInternalFunctionKey/jsvIsInternalObjectKey\nJsvIsInternalChecker jsvGetInternalFunctionCheckerFor(JsVar *v) {\n  if (jsvIsFunction(v)) return jsvIsInternalFunctionKey;\n  if (jsvIsObject(v)) return jsvIsInternalObjectKey;\n  return 0;\n}\n\n/** Using 'configs', this reads 'object' into the given pointers, returns true on success.\n *  If object is not undefined and not an object, an error is raised.\n *  If there are fields that are not  in the list of configs, an error is raised\n */\nbool jsvReadConfigObject(JsVar *object, jsvConfigObject *configs, int nConfigs) {\n  if (jsvIsUndefined(object)) return true;\n  if (!jsvIsObject(object)) {\n    jsExceptionHere(JSET_ERROR, \"Expecting an Object, or undefined\");\n    return false;\n  }\n  // Ok, it's an object\n  JsvObjectIterator it;\n  jsvObjectIteratorNew(&it, object);\n  bool ok = true;\n  while (ok && jsvObjectIteratorHasValue(&it)) {\n    JsVar *key = jsvObjectIteratorGetKey(&it);\n    bool found = false;\n    int i;\n    for (i=0;i<nConfigs;i++) {\n      if (jsvIsStringEqual(key, configs[i].name)) {\n        found = true;\n        if (configs[i].ptr) {\n          JsVar *val = jsvObjectIteratorGetValue(&it);\n          switch (configs[i].type) {\n          case 0: break;\n          case JSV_OBJECT:\n          case JSV_STRING_0:\n          case JSV_ARRAY:\n          case JSV_FUNCTION:\n            *((JsVar**)configs[i].ptr) = jsvLockAgain(val); break;\n          case JSV_PIN: *((Pin*)configs[i].ptr) = jshGetPinFromVar(val); break;\n          case JSV_BOOLEAN: *((bool*)configs[i].ptr) = jsvGetBool(val); break;\n          case JSV_INTEGER: *((JsVarInt*)configs[i].ptr) = jsvGetInteger(val); break;\n          case JSV_FLOAT: *((JsVarFloat*)configs[i].ptr) = jsvGetFloat(val); break;\n          default: assert(0); break;\n          }\n          jsvUnLock(val);\n        }\n      }\n    }\n    if (!found) {\n      jsExceptionHere(JSET_ERROR, \"Unknown option %q\", key);\n      ok = false;\n    }\n    jsvUnLock(key);\n\n    jsvObjectIteratorNext(&it);\n  }\n  jsvObjectIteratorFree(&it);\n  return ok;\n}\n\n/// Is the variable an instance of the given class. Eg. `jsvIsInstanceOf(e, \"Error\")` - does a simple, non-recursive check that doesn't take account of builtins like String\nbool jsvIsInstanceOf(JsVar *var, const char *constructorName) {\n  bool isInst = false;\n  if (!jsvHasChildren(var)) return false;\n  JsVar *proto = jsvObjectGetChild(var, JSPARSE_INHERITS_VAR, 0);\n  if (jsvIsObject(proto)) {\n    JsVar *constr = jsvObjectGetChild(proto, JSPARSE_CONSTRUCTOR_VAR, 0);\n    if (constr)\n      isInst = jspIsConstructor(constr, constructorName);\n    jsvUnLock(constr);\n  }\n  jsvUnLock(proto);\n  return isInst;\n}\n\nJsVar *jsvNewTypedArray(JsVarDataArrayBufferViewType type, JsVarInt length) {\n  JsVar *lenVar = jsvNewFromInteger(length);\n  if (!lenVar) return 0;\n  JsVar *array = jswrap_typedarray_constructor(type, lenVar,0,0);\n  jsvUnLock(lenVar);\n  return array;\n}\n\n#ifndef SAVE_ON_FLASH\nJsVar *jsvNewDataViewWithData(JsVarInt length, unsigned char *data) {\n  JsVar *buf = jswrap_arraybuffer_constructor(length);\n  if (!buf) return 0;\n  JsVar *view = jswrap_dataview_constructor(buf, 0, 0);\n  if (!view) {\n    jsvUnLock(buf);\n    return 0;\n  }\n  if (data) {\n    JsVar *arrayBufferData = jsvGetArrayBufferBackingString(buf);\n    if (arrayBufferData)\n      jsvSetString(arrayBufferData, (char *)data, (size_t)length);\n    jsvUnLock(arrayBufferData);\n  }\n  jsvUnLock(buf);\n  return view;\n}\n#endif\n\nJsVar *jsvNewArrayBufferWithPtr(unsigned int length, char **ptr) {\n  assert(ptr);\n  *ptr=0;\n  JsVar *backingString = jsvNewFlatStringOfLength(length);\n  if (!backingString) return 0;\n  JsVar *arr = jsvNewArrayBufferFromString(backingString, length);\n  if (!arr) {\n    jsvUnLock(backingString);\n    return 0;\n  }\n  *ptr = jsvGetFlatStringPointer(backingString);\n  jsvUnLock(backingString);\n  return arr;\n}\n\nJsVar *jsvNewArrayBufferWithData(JsVarInt length, unsigned char *data) {\n  assert(data);\n  JsVar *dst = 0;\n  JsVar *arr = jsvNewArrayBufferWithPtr((unsigned int)length, (char**)&dst);\n  if (!dst) {\n    jsvUnLock(arr);\n    return 0;\n  }\n  memcpy(dst, data, (size_t)length);\n  return arr;\n}\n\nvoid *jsvMalloc(size_t size) {\n  /** Allocate flat string, return pointer to its first element.\n   * As we drop the pointer here, it's left locked. jsvGetFlatStringPointer\n   * is also safe if 0 is passed in.  */\n  JsVar *flatStr = jsvNewFlatStringOfLength((unsigned int)size);\n  if (!flatStr) {\n    jsErrorFlags |= JSERR_LOW_MEMORY;\n    // Not allocated - try and free any command history/etc\n    while (jsiFreeMoreMemory());\n    // Garbage collect\n    jsvGarbageCollect();\n    // Try again\n    flatStr = jsvNewFlatStringOfLength((unsigned int)size);\n  }\n  // intentionally no jsvUnLock - see above\n  void *p = (void*)jsvGetFlatStringPointer(flatStr);\n  if (p) {\n    //jsiConsolePrintf(\"jsvMalloc var %d-%d at %d (%d bytes)\\n\", jsvGetRef(flatStr), jsvGetRef(flatStr)+jsvGetFlatStringBlocks(flatStr), p, size);\n    memset(p,0,size);\n  }\n  return p;\n}\n\nvoid jsvFree(void *ptr) {\n  JsVar *flatStr = jsvGetFlatStringFromPointer((char *)ptr);\n  //jsiConsolePrintf(\"jsvFree var %d at %d (%d bytes)\\n\", jsvGetRef(flatStr), ptr, jsvGetLength(flatStr));\n\n  jsvUnLock(flatStr);\n}\n"], "filenames": ["src/jsvar.c"], "buggy_code_start_loc": [1193], "buggy_code_end_loc": [1194], "fixing_code_start_loc": [1193], "fixing_code_end_loc": [1194], "type": "CWE-119", "message": "Espruino before 1.99 allows attackers to cause a denial of service (application crash) with a user crafted input file via a Buffer Overflow during syntax parsing because a check for '\\0' is made for the wrong array element in jsvar.c.", "other": {"cve": {"id": "CVE-2018-11596", "sourceIdentifier": "cve@mitre.org", "published": "2018-05-31T16:29:00.550", "lastModified": "2018-06-08T17:09:44.123", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Espruino before 1.99 allows attackers to cause a denial of service (application crash) with a user crafted input file via a Buffer Overflow during syntax parsing because a check for '\\0' is made for the wrong array element in jsvar.c."}, {"lang": "es", "value": "Espruino en versiones anteriores a la 1.99 permite que los atacantes provoquen una denegaci\u00f3n de servicio (cierre inesperado de la aplicaci\u00f3n) con un archivo de entrada manipulado por el usuario mediante un desbordamiento de b\u00fafer durante el an\u00e1lisis sint\u00e1ctico debido a que se comprueban los valores \"\\0\" en el elemento de array err\u00f3neo en jsvar.c."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:espruino:espruino:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.99", "matchCriteriaId": "0AC819A2-4289-44FA-9EBB-12DC6DB5455F"}]}]}], "references": [{"url": "https://github.com/espruino/Espruino/commit/ce1924193862d58cb43d3d4d9dada710a8361b89", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/espruino/Espruino/issues/1435", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/espruino/Espruino/commit/ce1924193862d58cb43d3d4d9dada710a8361b89"}}