{"buggy_code": ["/************************************************************\n * Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.\n *\n * Permission to use, copy, modify, and distribute this\n * software and its documentation for any purpose and without\n * fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright\n * notice and this permission notice appear in supporting\n * documentation, and that the name of Silicon Graphics not be\n * used in advertising or publicity pertaining to distribution\n * of the software without specific prior written permission.\n * Silicon Graphics makes no representation about the suitability\n * of this software for any purpose. It is provided \"as is\"\n * without any express or implied warranty.\n *\n * SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS\n * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON\n * GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL\n * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\n * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH\n * THE USE OR PERFORMANCE OF THIS SOFTWARE.\n *\n ********************************************************/\n\n/*\n * Copyright \u00a9 2012 Intel Corporation\n * Copyright \u00a9 2012 Ran Benita <ran234@gmail.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice (including the next\n * paragraph) shall be included in all copies or substantial portions of the\n * Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n * Author: Daniel Stone <daniel@fooishbar.org>\n *         Ran Benita <ran234@gmail.com>\n */\n\n#include \"xkbcomp-priv.h\"\n#include \"ast-build.h\"\n#include \"include.h\"\n\nParseCommon *\nAppendStmt(ParseCommon *to, ParseCommon *append)\n{\n    ParseCommon *iter;\n\n    if (!to)\n        return append;\n\n    for (iter = to; iter->next; iter = iter->next);\n\n    iter->next = append;\n    return to;\n}\n\nstatic ExprDef *\nExprCreate(enum expr_op_type op, enum expr_value_type type, size_t size)\n{\n    ExprDef *expr = malloc(size);\n    if (!expr)\n        return NULL;\n\n    expr->common.type = STMT_EXPR;\n    expr->common.next = NULL;\n    expr->expr.op = op;\n    expr->expr.value_type = type;\n\n    return expr;\n}\n\n#define EXPR_CREATE(type_, name_, op_, value_type_) \\\n    ExprDef *name_ = ExprCreate(op_, value_type_, sizeof(type_)); \\\n    if (!name_) \\\n        return NULL;\n\nExprDef *\nExprCreateString(xkb_atom_t str)\n{\n    EXPR_CREATE(ExprString, expr, EXPR_VALUE, EXPR_TYPE_STRING);\n    expr->string.str = str;\n    return expr;\n}\n\nExprDef *\nExprCreateInteger(int ival)\n{\n    EXPR_CREATE(ExprInteger, expr, EXPR_VALUE, EXPR_TYPE_INT);\n    expr->integer.ival = ival;\n    return expr;\n}\n\nExprDef *\nExprCreateBoolean(bool set)\n{\n    EXPR_CREATE(ExprBoolean, expr, EXPR_VALUE, EXPR_TYPE_BOOLEAN);\n    expr->boolean.set = set;\n    return expr;\n}\n\nExprDef *\nExprCreateKeyName(xkb_atom_t key_name)\n{\n    EXPR_CREATE(ExprKeyName, expr, EXPR_VALUE, EXPR_TYPE_KEYNAME);\n    expr->key_name.key_name = key_name;\n    return expr;\n}\n\nExprDef *\nExprCreateIdent(xkb_atom_t ident)\n{\n    EXPR_CREATE(ExprIdent, expr, EXPR_IDENT, EXPR_TYPE_UNKNOWN);\n    expr->ident.ident = ident;\n    return expr;\n}\n\nExprDef *\nExprCreateUnary(enum expr_op_type op, enum expr_value_type type,\n                ExprDef *child)\n{\n    EXPR_CREATE(ExprUnary, expr, op, type);\n    expr->unary.child = child;\n    return expr;\n}\n\nExprDef *\nExprCreateBinary(enum expr_op_type op, ExprDef *left, ExprDef *right)\n{\n    EXPR_CREATE(ExprBinary, expr, op, EXPR_TYPE_UNKNOWN);\n\n    if (op == EXPR_ASSIGN || left->expr.value_type == EXPR_TYPE_UNKNOWN)\n        expr->expr.value_type = right->expr.value_type;\n    else if (left->expr.value_type == right->expr.value_type ||\n             right->expr.value_type == EXPR_TYPE_UNKNOWN)\n        expr->expr.value_type = left->expr.value_type;\n    expr->binary.left = left;\n    expr->binary.right = right;\n\n    return expr;\n}\n\nExprDef *\nExprCreateFieldRef(xkb_atom_t element, xkb_atom_t field)\n{\n    EXPR_CREATE(ExprFieldRef, expr, EXPR_FIELD_REF, EXPR_TYPE_UNKNOWN);\n    expr->field_ref.element = element;\n    expr->field_ref.field = field;\n    return expr;\n}\n\nExprDef *\nExprCreateArrayRef(xkb_atom_t element, xkb_atom_t field, ExprDef *entry)\n{\n    EXPR_CREATE(ExprArrayRef, expr, EXPR_ARRAY_REF, EXPR_TYPE_UNKNOWN);\n    expr->array_ref.element = element;\n    expr->array_ref.field = field;\n    expr->array_ref.entry = entry;\n    return expr;\n}\n\nExprDef *\nExprCreateAction(xkb_atom_t name, ExprDef *args)\n{\n    EXPR_CREATE(ExprAction, expr, EXPR_ACTION_DECL, EXPR_TYPE_UNKNOWN);\n    expr->action.name = name;\n    expr->action.args = args;\n    return expr;\n}\n\nExprDef *\nExprCreateKeysymList(xkb_keysym_t sym)\n{\n    EXPR_CREATE(ExprKeysymList, expr, EXPR_KEYSYM_LIST, EXPR_TYPE_SYMBOLS);\n\n    darray_init(expr->keysym_list.syms);\n    darray_init(expr->keysym_list.symsMapIndex);\n    darray_init(expr->keysym_list.symsNumEntries);\n\n    darray_append(expr->keysym_list.syms, sym);\n    darray_append(expr->keysym_list.symsMapIndex, 0);\n    darray_append(expr->keysym_list.symsNumEntries, 1);\n\n    return expr;\n}\n\nExprDef *\nExprCreateMultiKeysymList(ExprDef *expr)\n{\n    unsigned nLevels = darray_size(expr->keysym_list.symsMapIndex);\n\n    darray_resize(expr->keysym_list.symsMapIndex, 1);\n    darray_resize(expr->keysym_list.symsNumEntries, 1);\n    darray_item(expr->keysym_list.symsMapIndex, 0) = 0;\n    darray_item(expr->keysym_list.symsNumEntries, 0) = nLevels;\n\n    return expr;\n}\n\nExprDef *\nExprAppendKeysymList(ExprDef *expr, xkb_keysym_t sym)\n{\n    unsigned nSyms = darray_size(expr->keysym_list.syms);\n\n    darray_append(expr->keysym_list.symsMapIndex, nSyms);\n    darray_append(expr->keysym_list.symsNumEntries, 1);\n    darray_append(expr->keysym_list.syms, sym);\n\n    return expr;\n}\n\nExprDef *\nExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)\n{\n    unsigned nSyms = darray_size(expr->keysym_list.syms);\n    unsigned numEntries = darray_size(append->keysym_list.syms);\n\n    darray_append(expr->keysym_list.symsMapIndex, nSyms);\n    darray_append(expr->keysym_list.symsNumEntries, numEntries);\n    darray_concat(expr->keysym_list.syms, append->keysym_list.syms);\n\n    FreeStmt((ParseCommon *) &append);\n\n    return expr;\n}\n\nKeycodeDef *\nKeycodeCreate(xkb_atom_t name, int64_t value)\n{\n    KeycodeDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_KEYCODE;\n    def->common.next = NULL;\n    def->name = name;\n    def->value = value;\n\n    return def;\n}\n\nKeyAliasDef *\nKeyAliasCreate(xkb_atom_t alias, xkb_atom_t real)\n{\n    KeyAliasDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_ALIAS;\n    def->common.next = NULL;\n    def->alias = alias;\n    def->real = real;\n\n    return def;\n}\n\nVModDef *\nVModCreate(xkb_atom_t name, ExprDef *value)\n{\n    VModDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_VMOD;\n    def->common.next = NULL;\n    def->name = name;\n    def->value = value;\n\n    return def;\n}\n\nVarDef *\nVarCreate(ExprDef *name, ExprDef *value)\n{\n    VarDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_VAR;\n    def->common.next = NULL;\n    def->name = name;\n    def->value = value;\n\n    return def;\n}\n\nVarDef *\nBoolVarCreate(xkb_atom_t ident, bool set)\n{\n    ExprDef *name, *value;\n    VarDef *def;\n    if (!(name = ExprCreateIdent(ident))) {\n        return NULL;\n    }\n    if (!(value = ExprCreateBoolean(set))) {\n        FreeStmt((ParseCommon *) name);\n        return NULL;\n    }\n    if (!(def = VarCreate(name, value))) {\n        FreeStmt((ParseCommon *) name);\n        FreeStmt((ParseCommon *) value);\n        return NULL;\n    }\n    return def;\n}\n\nInterpDef *\nInterpCreate(xkb_keysym_t sym, ExprDef *match)\n{\n    InterpDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_INTERP;\n    def->common.next = NULL;\n    def->sym = sym;\n    def->match = match;\n    def->def = NULL;\n\n    return def;\n}\n\nKeyTypeDef *\nKeyTypeCreate(xkb_atom_t name, VarDef *body)\n{\n    KeyTypeDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_TYPE;\n    def->common.next = NULL;\n    def->merge = MERGE_DEFAULT;\n    def->name = name;\n    def->body = body;\n\n    return def;\n}\n\nSymbolsDef *\nSymbolsCreate(xkb_atom_t keyName, VarDef *symbols)\n{\n    SymbolsDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_SYMBOLS;\n    def->common.next = NULL;\n    def->merge = MERGE_DEFAULT;\n    def->keyName = keyName;\n    def->symbols = symbols;\n\n    return def;\n}\n\nGroupCompatDef *\nGroupCompatCreate(unsigned group, ExprDef *val)\n{\n    GroupCompatDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_GROUP_COMPAT;\n    def->common.next = NULL;\n    def->merge = MERGE_DEFAULT;\n    def->group = group;\n    def->def = val;\n\n    return def;\n}\n\nModMapDef *\nModMapCreate(xkb_atom_t modifier, ExprDef *keys)\n{\n    ModMapDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_MODMAP;\n    def->common.next = NULL;\n    def->merge = MERGE_DEFAULT;\n    def->modifier = modifier;\n    def->keys = keys;\n\n    return def;\n}\n\nLedMapDef *\nLedMapCreate(xkb_atom_t name, VarDef *body)\n{\n    LedMapDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_LED_MAP;\n    def->common.next = NULL;\n    def->merge = MERGE_DEFAULT;\n    def->name = name;\n    def->body = body;\n\n    return def;\n}\n\nLedNameDef *\nLedNameCreate(unsigned ndx, ExprDef *name, bool virtual)\n{\n    LedNameDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_LED_NAME;\n    def->common.next = NULL;\n    def->merge = MERGE_DEFAULT;\n    def->ndx = ndx;\n    def->name = name;\n    def->virtual = virtual;\n\n    return def;\n}\n\nstatic void\nFreeInclude(IncludeStmt *incl);\n\nIncludeStmt *\nIncludeCreate(struct xkb_context *ctx, char *str, enum merge_mode merge)\n{\n    IncludeStmt *incl, *first;\n    char *file, *map, *stmt, *tmp, *extra_data;\n    char nextop;\n\n    incl = first = NULL;\n    file = map = NULL;\n    tmp = str;\n    stmt = strdup_safe(str);\n    while (tmp && *tmp)\n    {\n        if (!ParseIncludeMap(&tmp, &file, &map, &nextop, &extra_data))\n            goto err;\n\n        /*\n         * Given an RMLVO (here layout) like 'us,,fr', the rules parser\n         * will give out something like 'pc+us+:2+fr:3+inet(evdev)'.\n         * We should just skip the ':2' in this case and leave it to the\n         * appropriate section to deal with the empty group.\n         */\n        if (isempty(file)) {\n            free(file);\n            free(map);\n            free(extra_data);\n            continue;\n        }\n\n        if (first == NULL) {\n            first = incl = malloc(sizeof(*first));\n        } else {\n            incl->next_incl = malloc(sizeof(*first));\n            incl = incl->next_incl;\n        }\n\n        if (!incl)\n            break;\n\n        incl->common.type = STMT_INCLUDE;\n        incl->common.next = NULL;\n        incl->merge = merge;\n        incl->stmt = NULL;\n        incl->file = file;\n        incl->map = map;\n        incl->modifier = extra_data;\n        incl->next_incl = NULL;\n\n        if (nextop == '|')\n            merge = MERGE_AUGMENT;\n        else\n            merge = MERGE_OVERRIDE;\n    }\n\n    if (first)\n        first->stmt = stmt;\n    else\n        free(stmt);\n\n    return first;\n\nerr:\n    log_err(ctx, \"Illegal include statement \\\"%s\\\"; Ignored\\n\", stmt);\n    FreeInclude(first);\n    free(stmt);\n    return NULL;\n}\n\nXkbFile *\nXkbFileCreate(enum xkb_file_type type, char *name, ParseCommon *defs,\n              enum xkb_map_flags flags)\n{\n    XkbFile *file;\n\n    file = calloc(1, sizeof(*file));\n    if (!file)\n        return NULL;\n\n    XkbEscapeMapName(name);\n    file->file_type = type;\n    file->name = name ? name : strdup(\"(unnamed)\");\n    file->defs = defs;\n    file->flags = flags;\n\n    return file;\n}\n\nXkbFile *\nXkbFileFromComponents(struct xkb_context *ctx,\n                      const struct xkb_component_names *kkctgs)\n{\n    char *const components[] = {\n        kkctgs->keycodes, kkctgs->types,\n        kkctgs->compat, kkctgs->symbols,\n    };\n    enum xkb_file_type type;\n    IncludeStmt *include = NULL;\n    XkbFile *file = NULL;\n    ParseCommon *defs = NULL;\n\n    for (type = FIRST_KEYMAP_FILE_TYPE; type <= LAST_KEYMAP_FILE_TYPE; type++) {\n        include = IncludeCreate(ctx, components[type], MERGE_DEFAULT);\n        if (!include)\n            goto err;\n\n        file = XkbFileCreate(type, NULL, (ParseCommon *) include, 0);\n        if (!file) {\n            FreeInclude(include);\n            goto err;\n        }\n\n        defs = AppendStmt(defs, &file->common);\n    }\n\n    file = XkbFileCreate(FILE_TYPE_KEYMAP, NULL, defs, 0);\n    if (!file)\n        goto err;\n\n    return file;\n\nerr:\n    FreeXkbFile((XkbFile *) defs);\n    return NULL;\n}\n\nstatic void\nFreeExpr(ExprDef *expr)\n{\n    if (!expr)\n        return;\n\n    switch (expr->expr.op) {\n    case EXPR_ACTION_LIST:\n    case EXPR_NEGATE:\n    case EXPR_UNARY_PLUS:\n    case EXPR_NOT:\n    case EXPR_INVERT:\n        FreeStmt((ParseCommon *) expr->unary.child);\n        break;\n\n    case EXPR_DIVIDE:\n    case EXPR_ADD:\n    case EXPR_SUBTRACT:\n    case EXPR_MULTIPLY:\n    case EXPR_ASSIGN:\n        FreeStmt((ParseCommon *) expr->binary.left);\n        FreeStmt((ParseCommon *) expr->binary.right);\n        break;\n\n    case EXPR_ACTION_DECL:\n        FreeStmt((ParseCommon *) expr->action.args);\n        break;\n\n    case EXPR_ARRAY_REF:\n        FreeStmt((ParseCommon *) expr->array_ref.entry);\n        break;\n\n    case EXPR_KEYSYM_LIST:\n        darray_free(expr->keysym_list.syms);\n        darray_free(expr->keysym_list.symsMapIndex);\n        darray_free(expr->keysym_list.symsNumEntries);\n        break;\n\n    default:\n        break;\n    }\n}\n\nstatic void\nFreeInclude(IncludeStmt *incl)\n{\n    IncludeStmt *next;\n\n    while (incl)\n    {\n        next = incl->next_incl;\n\n        free(incl->file);\n        free(incl->map);\n        free(incl->modifier);\n        free(incl->stmt);\n\n        free(incl);\n        incl = next;\n    }\n}\n\nvoid\nFreeStmt(ParseCommon *stmt)\n{\n    ParseCommon *next;\n\n    while (stmt)\n    {\n        next = stmt->next;\n\n        switch (stmt->type) {\n        case STMT_INCLUDE:\n            FreeInclude((IncludeStmt *) stmt);\n            /* stmt is already free'd here. */\n            stmt = NULL;\n            break;\n        case STMT_EXPR:\n            FreeExpr((ExprDef *) stmt);\n            break;\n        case STMT_VAR:\n            FreeStmt((ParseCommon *) ((VarDef *) stmt)->name);\n            FreeStmt((ParseCommon *) ((VarDef *) stmt)->value);\n            break;\n        case STMT_TYPE:\n            FreeStmt((ParseCommon *) ((KeyTypeDef *) stmt)->body);\n            break;\n        case STMT_INTERP:\n            FreeStmt((ParseCommon *) ((InterpDef *) stmt)->match);\n            FreeStmt((ParseCommon *) ((InterpDef *) stmt)->def);\n            break;\n        case STMT_VMOD:\n            FreeStmt((ParseCommon *) ((VModDef *) stmt)->value);\n            break;\n        case STMT_SYMBOLS:\n            FreeStmt((ParseCommon *) ((SymbolsDef *) stmt)->symbols);\n            break;\n        case STMT_MODMAP:\n            FreeStmt((ParseCommon *) ((ModMapDef *) stmt)->keys);\n            break;\n        case STMT_GROUP_COMPAT:\n            FreeStmt((ParseCommon *) ((GroupCompatDef *) stmt)->def);\n            break;\n        case STMT_LED_MAP:\n            FreeStmt((ParseCommon *) ((LedMapDef *) stmt)->body);\n            break;\n        case STMT_LED_NAME:\n            FreeStmt((ParseCommon *) ((LedNameDef *) stmt)->name);\n            break;\n        default:\n            break;\n        }\n\n        free(stmt);\n        stmt = next;\n    }\n}\n\nvoid\nFreeXkbFile(XkbFile *file)\n{\n    XkbFile *next;\n\n    while (file)\n    {\n        next = (XkbFile *) file->common.next;\n\n        switch (file->file_type) {\n        case FILE_TYPE_KEYMAP:\n            FreeXkbFile((XkbFile *) file->defs);\n            break;\n\n        case FILE_TYPE_TYPES:\n        case FILE_TYPE_COMPAT:\n        case FILE_TYPE_SYMBOLS:\n        case FILE_TYPE_KEYCODES:\n        case FILE_TYPE_GEOMETRY:\n            FreeStmt(file->defs);\n            break;\n\n        default:\n            break;\n        }\n\n        free(file->name);\n        free(file);\n        file = next;\n    }\n}\n\nstatic const char *xkb_file_type_strings[_FILE_TYPE_NUM_ENTRIES] = {\n    [FILE_TYPE_KEYCODES] = \"xkb_keycodes\",\n    [FILE_TYPE_TYPES] = \"xkb_types\",\n    [FILE_TYPE_COMPAT] = \"xkb_compatibility\",\n    [FILE_TYPE_SYMBOLS] = \"xkb_symbols\",\n    [FILE_TYPE_GEOMETRY] = \"xkb_geometry\",\n    [FILE_TYPE_KEYMAP] = \"xkb_keymap\",\n    [FILE_TYPE_RULES] = \"rules\",\n};\n\nconst char *\nxkb_file_type_to_string(enum xkb_file_type type)\n{\n    if (type > _FILE_TYPE_NUM_ENTRIES)\n        return \"unknown\";\n    return xkb_file_type_strings[type];\n}\n\nstatic const char *stmt_type_strings[_STMT_NUM_VALUES] = {\n    [STMT_UNKNOWN] = \"unknown statement\",\n    [STMT_INCLUDE] = \"include statement\",\n    [STMT_KEYCODE] = \"key name definition\",\n    [STMT_ALIAS] = \"key alias definition\",\n    [STMT_EXPR] = \"expression\",\n    [STMT_VAR] = \"variable definition\",\n    [STMT_TYPE] = \"key type definition\",\n    [STMT_INTERP] = \"symbol interpretation definition\",\n    [STMT_VMOD] = \"virtual modifiers definition\",\n    [STMT_SYMBOLS] = \"key symbols definition\",\n    [STMT_MODMAP] = \"modifier map declaration\",\n    [STMT_GROUP_COMPAT] = \"group declaration\",\n    [STMT_LED_MAP] = \"indicator map declaration\",\n    [STMT_LED_NAME] = \"indicator name declaration\",\n};\n\nconst char *\nstmt_type_to_string(enum stmt_type type)\n{\n    if (type >= _STMT_NUM_VALUES)\n        return NULL;\n    return stmt_type_strings[type];\n}\n\nstatic const char *expr_op_type_strings[_EXPR_NUM_VALUES] = {\n    [EXPR_VALUE] = \"literal\",\n    [EXPR_IDENT] = \"identifier\",\n    [EXPR_ACTION_DECL] = \"action declaration\",\n    [EXPR_FIELD_REF] = \"field reference\",\n    [EXPR_ARRAY_REF] = \"array reference\",\n    [EXPR_KEYSYM_LIST] = \"list of keysyms\",\n    [EXPR_ACTION_LIST] = \"list of actions\",\n    [EXPR_ADD] = \"addition\",\n    [EXPR_SUBTRACT] = \"subtraction\",\n    [EXPR_MULTIPLY] = \"multiplication\",\n    [EXPR_DIVIDE] = \"division\",\n    [EXPR_ASSIGN] = \"assignment\",\n    [EXPR_NOT] = \"logical negation\",\n    [EXPR_NEGATE] = \"arithmetic negation\",\n    [EXPR_INVERT] = \"bitwise inversion\",\n    [EXPR_UNARY_PLUS] = \"unary plus\",\n};\n\nconst char *\nexpr_op_type_to_string(enum expr_op_type type)\n{\n    if (type >= _EXPR_NUM_VALUES)\n        return NULL;\n    return expr_op_type_strings[type];\n}\n\nstatic const char *expr_value_type_strings[_EXPR_TYPE_NUM_VALUES] = {\n    [EXPR_TYPE_UNKNOWN] = \"unknown\",\n    [EXPR_TYPE_BOOLEAN] = \"boolean\",\n    [EXPR_TYPE_INT] = \"int\",\n    [EXPR_TYPE_STRING] = \"string\",\n    [EXPR_TYPE_ACTION] = \"action\",\n    [EXPR_TYPE_KEYNAME] = \"keyname\",\n    [EXPR_TYPE_SYMBOLS] = \"symbols\",\n};\n\nconst char *\nexpr_value_type_to_string(enum expr_value_type type)\n{\n    if (type >= _EXPR_TYPE_NUM_VALUES)\n        return NULL;\n    return expr_value_type_strings[type];\n}\n", "/************************************************************\n * Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.\n *\n * Permission to use, copy, modify, and distribute this\n * software and its documentation for any purpose and without\n * fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright\n * notice and this permission notice appear in supporting\n * documentation, and that the name of Silicon Graphics not be\n * used in advertising or publicity pertaining to distribution\n * of the software without specific prior written permission.\n * Silicon Graphics makes no representation about the suitability\n * of this software for any purpose. It is provided \"as is\"\n * without any express or implied warranty.\n *\n * SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS\n * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON\n * GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL\n * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\n * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH\n * THE USE OR PERFORMANCE OF THIS SOFTWARE.\n *\n ********************************************************/\n\n#ifndef XKBCOMP_AST_BUILD_H\n#define XKBCOMP_AST_BUILD_H\n\nParseCommon *\nAppendStmt(ParseCommon *to, ParseCommon *append);\n\nExprDef *\nExprCreateString(xkb_atom_t str);\n\nExprDef *\nExprCreateInteger(int ival);\n\nExprDef *\nExprCreateBoolean(bool set);\n\nExprDef *\nExprCreateKeyName(xkb_atom_t key_name);\n\nExprDef *\nExprCreateIdent(xkb_atom_t ident);\n\nExprDef *\nExprCreateUnary(enum expr_op_type op, enum expr_value_type type,\n                ExprDef *child);\n\nExprDef *\nExprCreateBinary(enum expr_op_type op, ExprDef *left, ExprDef *right);\n\nExprDef *\nExprCreateFieldRef(xkb_atom_t element, xkb_atom_t field);\n\nExprDef *\nExprCreateArrayRef(xkb_atom_t element, xkb_atom_t field, ExprDef *entry);\n\nExprDef *\nExprCreateAction(xkb_atom_t name, ExprDef *args);\n\nExprDef *\nExprCreateMultiKeysymList(ExprDef *list);\n\nExprDef *\nExprCreateKeysymList(xkb_keysym_t sym);\n\nExprDef *\nExprAppendMultiKeysymList(ExprDef *list, ExprDef *append);\n\nExprDef *\nExprAppendKeysymList(ExprDef *list, xkb_keysym_t sym);\n\nKeycodeDef *\nKeycodeCreate(xkb_atom_t name, int64_t value);\n\nKeyAliasDef *\nKeyAliasCreate(xkb_atom_t alias, xkb_atom_t real);\n\nVModDef *\nVModCreate(xkb_atom_t name, ExprDef *value);\n\nVarDef *\nVarCreate(ExprDef *name, ExprDef *value);\n\nVarDef *\nBoolVarCreate(xkb_atom_t ident, bool set);\n\nInterpDef *\nInterpCreate(xkb_keysym_t sym, ExprDef *match);\n\nKeyTypeDef *\nKeyTypeCreate(xkb_atom_t name, VarDef *body);\n\nSymbolsDef *\nSymbolsCreate(xkb_atom_t keyName, VarDef *symbols);\n\nGroupCompatDef *\nGroupCompatCreate(unsigned group, ExprDef *def);\n\nModMapDef *\nModMapCreate(xkb_atom_t modifier, ExprDef *keys);\n\nLedMapDef *\nLedMapCreate(xkb_atom_t name, VarDef *body);\n\nLedNameDef *\nLedNameCreate(unsigned ndx, ExprDef *name, bool virtual);\n\nIncludeStmt *\nIncludeCreate(struct xkb_context *ctx, char *str, enum merge_mode merge);\n\nXkbFile *\nXkbFileCreate(enum xkb_file_type type, char *name, ParseCommon *defs,\n              enum xkb_map_flags flags);\n\nvoid\nFreeStmt(ParseCommon *stmt);\n\n#endif\n", "/************************************************************\n * Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.\n *\n * Permission to use, copy, modify, and distribute this\n * software and its documentation for any purpose and without\n * fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright\n * notice and this permission notice appear in supporting\n * documentation, and that the name of Silicon Graphics not be\n * used in advertising or publicity pertaining to distribution\n * of the software without specific prior written permission.\n * Silicon Graphics makes no representation about the suitability\n * of this software for any purpose. It is provided \"as is\"\n * without any express or implied warranty.\n *\n * SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS\n * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON\n * GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL\n * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\n * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH\n * THE USE OR PERFORMANCE OF THIS SOFTWARE.\n *\n ********************************************************/\n\n/*\n * Copyright \u00a9 2012 Ran Benita <ran234@gmail.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice (including the next\n * paragraph) shall be included in all copies or substantial portions of the\n * Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n#ifndef XKBCOMP_AST_H\n#define XKBCOMP_AST_H\n\nenum xkb_file_type {\n    /* Component files, by order of compilation. */\n    FILE_TYPE_KEYCODES = 0,\n    FILE_TYPE_TYPES = 1,\n    FILE_TYPE_COMPAT = 2,\n    FILE_TYPE_SYMBOLS = 3,\n    /* Geometry is not compiled any more. */\n    FILE_TYPE_GEOMETRY = 4,\n\n    /* A top level file which includes the above files. */\n    FILE_TYPE_KEYMAP,\n\n/* File types which must be found in a keymap file. */\n#define FIRST_KEYMAP_FILE_TYPE FILE_TYPE_KEYCODES\n#define LAST_KEYMAP_FILE_TYPE  FILE_TYPE_SYMBOLS\n\n    /* This one doesn't mix with the others, but useful here as well. */\n    FILE_TYPE_RULES,\n\n    _FILE_TYPE_NUM_ENTRIES\n};\n\nenum stmt_type {\n    STMT_UNKNOWN = 0,\n    STMT_INCLUDE,\n    STMT_KEYCODE,\n    STMT_ALIAS,\n    STMT_EXPR,\n    STMT_VAR,\n    STMT_TYPE,\n    STMT_INTERP,\n    STMT_VMOD,\n    STMT_SYMBOLS,\n    STMT_MODMAP,\n    STMT_GROUP_COMPAT,\n    STMT_LED_MAP,\n    STMT_LED_NAME,\n\n    _STMT_NUM_VALUES\n};\n\nenum expr_value_type {\n    EXPR_TYPE_UNKNOWN = 0,\n    EXPR_TYPE_BOOLEAN,\n    EXPR_TYPE_INT,\n    EXPR_TYPE_STRING,\n    EXPR_TYPE_ACTION,\n    EXPR_TYPE_KEYNAME,\n    EXPR_TYPE_SYMBOLS,\n\n    _EXPR_TYPE_NUM_VALUES\n};\n\nenum expr_op_type {\n    EXPR_VALUE,\n    EXPR_IDENT,\n    EXPR_ACTION_DECL,\n    EXPR_FIELD_REF,\n    EXPR_ARRAY_REF,\n    EXPR_KEYSYM_LIST,\n    EXPR_ACTION_LIST,\n    EXPR_ADD,\n    EXPR_SUBTRACT,\n    EXPR_MULTIPLY,\n    EXPR_DIVIDE,\n    EXPR_ASSIGN,\n    EXPR_NOT,\n    EXPR_NEGATE,\n    EXPR_INVERT,\n    EXPR_UNARY_PLUS,\n\n    _EXPR_NUM_VALUES\n};\n\nenum merge_mode {\n    MERGE_DEFAULT,\n    MERGE_AUGMENT,\n    MERGE_OVERRIDE,\n    MERGE_REPLACE,\n};\n\nconst char *\nxkb_file_type_to_string(enum xkb_file_type type);\n\nconst char *\nstmt_type_to_string(enum stmt_type type);\n\nconst char *\nexpr_op_type_to_string(enum expr_op_type type);\n\nconst char *\nexpr_value_type_to_string(enum expr_value_type type);\n\ntypedef struct _ParseCommon  {\n    struct _ParseCommon *next;\n    enum stmt_type type;\n} ParseCommon;\n\ntypedef struct _IncludeStmt {\n    ParseCommon common;\n    enum merge_mode merge;\n    char *stmt;\n    char *file;\n    char *map;\n    char *modifier;\n    struct _IncludeStmt *next_incl;\n} IncludeStmt;\n\ntypedef struct {\n    ParseCommon common;\n    enum expr_op_type op;\n    enum expr_value_type value_type;\n} ExprCommon;\n\ntypedef union ExprDef ExprDef;\n\ntypedef struct {\n    ExprCommon expr;\n    xkb_atom_t ident;\n} ExprIdent;\n\ntypedef struct {\n    ExprCommon expr;\n    xkb_atom_t str;\n} ExprString;\n\ntypedef struct {\n    ExprCommon expr;\n    bool set;\n} ExprBoolean;\n\ntypedef struct {\n    ExprCommon expr;\n    int ival;\n} ExprInteger;\n\ntypedef struct {\n    ExprCommon expr;\n    xkb_atom_t key_name;\n} ExprKeyName;\n\ntypedef struct {\n    ExprCommon expr;\n    ExprDef *left;\n    ExprDef *right;\n} ExprBinary;\n\ntypedef struct {\n    ExprCommon expr;\n    ExprDef *child;\n} ExprUnary;\n\ntypedef struct {\n    ExprCommon expr;\n    xkb_atom_t element;\n    xkb_atom_t field;\n} ExprFieldRef;\n\ntypedef struct {\n    ExprCommon expr;\n    xkb_atom_t element;\n    xkb_atom_t field;\n    ExprDef *entry;\n} ExprArrayRef;\n\ntypedef struct {\n    ExprCommon expr;\n    xkb_atom_t name;\n    ExprDef *args;\n} ExprAction;\n\ntypedef struct {\n    ExprCommon expr;\n    darray(xkb_keysym_t) syms;\n    darray(unsigned int) symsMapIndex;\n    darray(unsigned int) symsNumEntries;\n} ExprKeysymList;\n\nunion ExprDef {\n    ParseCommon common;\n    /* Maybe someday we can use C11 anonymous struct for ExprCommon here. */\n    ExprCommon expr;\n    ExprIdent ident;\n    ExprString string;\n    ExprBoolean boolean;\n    ExprInteger integer;\n    ExprKeyName key_name;\n    ExprBinary binary;\n    ExprUnary unary;\n    ExprFieldRef field_ref;\n    ExprArrayRef array_ref;\n    ExprAction action;\n    ExprKeysymList keysym_list;\n};\n\ntypedef struct {\n    ParseCommon common;\n    enum merge_mode merge;\n    ExprDef *name;\n    ExprDef *value;\n} VarDef;\n\ntypedef struct {\n    ParseCommon common;\n    enum merge_mode merge;\n    xkb_atom_t name;\n    ExprDef *value;\n} VModDef;\n\ntypedef struct {\n    ParseCommon common;\n    enum merge_mode merge;\n    xkb_atom_t name;\n    int64_t value;\n} KeycodeDef;\n\ntypedef struct {\n    ParseCommon common;\n    enum merge_mode merge;\n    xkb_atom_t alias;\n    xkb_atom_t real;\n} KeyAliasDef;\n\ntypedef struct {\n    ParseCommon common;\n    enum merge_mode merge;\n    xkb_atom_t name;\n    VarDef *body;\n} KeyTypeDef;\n\ntypedef struct {\n    ParseCommon common;\n    enum merge_mode merge;\n    xkb_atom_t keyName;\n    VarDef *symbols;\n} SymbolsDef;\n\ntypedef struct {\n    ParseCommon common;\n    enum merge_mode merge;\n    xkb_atom_t modifier;\n    ExprDef *keys;\n} ModMapDef;\n\ntypedef struct {\n    ParseCommon common;\n    enum merge_mode merge;\n    unsigned group;\n    ExprDef *def;\n} GroupCompatDef;\n\ntypedef struct {\n    ParseCommon common;\n    enum merge_mode merge;\n    xkb_keysym_t sym;\n    ExprDef *match;\n    VarDef *def;\n} InterpDef;\n\ntypedef struct {\n    ParseCommon common;\n    enum merge_mode merge;\n    unsigned ndx;\n    ExprDef *name;\n    bool virtual;\n} LedNameDef;\n\ntypedef struct {\n    ParseCommon common;\n    enum merge_mode merge;\n    xkb_atom_t name;\n    VarDef *body;\n} LedMapDef;\n\nenum xkb_map_flags {\n    MAP_IS_DEFAULT = (1 << 0),\n    MAP_IS_PARTIAL = (1 << 1),\n    MAP_IS_HIDDEN = (1 << 2),\n    MAP_HAS_ALPHANUMERIC = (1 << 3),\n    MAP_HAS_MODIFIER = (1 << 4),\n    MAP_HAS_KEYPAD = (1 << 5),\n    MAP_HAS_FN = (1 << 6),\n    MAP_IS_ALTGR = (1 << 7),\n};\n\ntypedef struct {\n    ParseCommon common;\n    enum xkb_file_type file_type;\n    char *name;\n    ParseCommon *defs;\n    enum xkb_map_flags flags;\n} XkbFile;\n\n#endif\n", "/************************************************************\n Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.\n\n Permission to use, copy, modify, and distribute this\n software and its documentation for any purpose and without\n fee is hereby granted, provided that the above copyright\n notice appear in all copies and that both that copyright\n notice and this permission notice appear in supporting\n documentation, and that the name of Silicon Graphics not be\n used in advertising or publicity pertaining to distribution\n of the software without specific prior written permission.\n Silicon Graphics makes no representation about the suitability\n of this software for any purpose. It is provided \"as is\"\n without any express or implied warranty.\n\n SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS\n SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON\n GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL\n DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\n DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH\n THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n ********************************************************/\n\n/*\n * The parser should work with reasonably recent versions of either\n * bison or byacc.  So if you make changes, try to make sure it works\n * in both!\n */\n\n%{\n#include \"xkbcomp/xkbcomp-priv.h\"\n#include \"xkbcomp/ast-build.h\"\n#include \"xkbcomp/parser-priv.h\"\n#include \"scanner-utils.h\"\n\nstruct parser_param {\n    struct xkb_context *ctx;\n    struct scanner *scanner;\n    XkbFile *rtrn;\n    bool more_maps;\n};\n\n#define parser_err(param, fmt, ...) \\\n    scanner_err((param)->scanner, fmt, ##__VA_ARGS__)\n\n#define parser_warn(param, fmt, ...) \\\n    scanner_warn((param)->scanner, fmt, ##__VA_ARGS__)\n\nstatic void\n_xkbcommon_error(struct parser_param *param, const char *msg)\n{\n    parser_err(param, \"%s\", msg);\n}\n\nstatic bool\nresolve_keysym(const char *name, xkb_keysym_t *sym_rtrn)\n{\n    xkb_keysym_t sym;\n\n    if (!name || istreq(name, \"any\") || istreq(name, \"nosymbol\")) {\n        *sym_rtrn = XKB_KEY_NoSymbol;\n        return true;\n    }\n\n    if (istreq(name, \"none\") || istreq(name, \"voidsymbol\")) {\n        *sym_rtrn = XKB_KEY_VoidSymbol;\n        return true;\n    }\n\n    sym = xkb_keysym_from_name(name, XKB_KEYSYM_NO_FLAGS);\n    if (sym != XKB_KEY_NoSymbol) {\n        *sym_rtrn = sym;\n        return true;\n    }\n\n    return false;\n}\n\n#define param_scanner param->scanner\n%}\n\n%pure-parser\n%lex-param      { struct scanner *param_scanner }\n%parse-param    { struct parser_param *param }\n\n%token\n        END_OF_FILE     0\n        ERROR_TOK       255\n        XKB_KEYMAP      1\n        XKB_KEYCODES    2\n        XKB_TYPES       3\n        XKB_SYMBOLS     4\n        XKB_COMPATMAP   5\n        XKB_GEOMETRY    6\n        XKB_SEMANTICS   7\n        XKB_LAYOUT      8\n        INCLUDE         10\n        OVERRIDE        11\n        AUGMENT         12\n        REPLACE         13\n        ALTERNATE       14\n        VIRTUAL_MODS    20\n        TYPE            21\n        INTERPRET       22\n        ACTION_TOK      23\n        KEY             24\n        ALIAS           25\n        GROUP           26\n        MODIFIER_MAP    27\n        INDICATOR       28\n        SHAPE           29\n        KEYS            30\n        ROW             31\n        SECTION         32\n        OVERLAY         33\n        TEXT            34\n        OUTLINE         35\n        SOLID           36\n        LOGO            37\n        VIRTUAL         38\n        EQUALS          40\n        PLUS            41\n        MINUS           42\n        DIVIDE          43\n        TIMES           44\n        OBRACE          45\n        CBRACE          46\n        OPAREN          47\n        CPAREN          48\n        OBRACKET        49\n        CBRACKET        50\n        DOT             51\n        COMMA           52\n        SEMI            53\n        EXCLAM          54\n        INVERT          55\n        STRING          60\n        INTEGER         61\n        FLOAT           62\n        IDENT           63\n        KEYNAME         64\n        PARTIAL         70\n        DEFAULT         71\n        HIDDEN          72\n        ALPHANUMERIC_KEYS       73\n        MODIFIER_KEYS           74\n        KEYPAD_KEYS             75\n        FUNCTION_KEYS           76\n        ALTERNATE_GROUP         77\n\n%right  EQUALS\n%left   PLUS MINUS\n%left   TIMES DIVIDE\n%left   EXCLAM INVERT\n%left   OPAREN\n\n%start  XkbFile\n\n%union  {\n        int              ival;\n        int64_t          num;\n        enum xkb_file_type file_type;\n        char            *str;\n        xkb_atom_t      atom;\n        enum merge_mode merge;\n        enum xkb_map_flags mapFlags;\n        xkb_keysym_t    keysym;\n        ParseCommon     *any;\n        ExprDef         *expr;\n        VarDef          *var;\n        VModDef         *vmod;\n        InterpDef       *interp;\n        KeyTypeDef      *keyType;\n        SymbolsDef      *syms;\n        ModMapDef       *modMask;\n        GroupCompatDef  *groupCompat;\n        LedMapDef       *ledMap;\n        LedNameDef      *ledName;\n        KeycodeDef      *keyCode;\n        KeyAliasDef     *keyAlias;\n        void            *geom;\n        XkbFile         *file;\n}\n\n%type <num>     INTEGER FLOAT\n%type <str>     IDENT STRING\n%type <atom>    KEYNAME\n%type <num>     KeyCode\n%type <ival>    Number Integer Float SignedNumber DoodadType\n%type <merge>   MergeMode OptMergeMode\n%type <file_type> XkbCompositeType FileType\n%type <mapFlags> Flag Flags OptFlags\n%type <str>     MapName OptMapName\n%type <atom>    FieldSpec Ident Element String\n%type <keysym>  KeySym\n%type <any>     DeclList Decl\n%type <expr>    OptExprList ExprList Expr Term Lhs Terminal ArrayInit KeySyms\n%type <expr>    OptKeySymList KeySymList Action ActionList Coord CoordList\n%type <var>     VarDecl VarDeclList SymbolsBody SymbolsVarDecl\n%type <vmod>    VModDecl VModDefList VModDef\n%type <interp>  InterpretDecl InterpretMatch\n%type <keyType> KeyTypeDecl\n%type <syms>    SymbolsDecl\n%type <modMask> ModMapDecl\n%type <groupCompat> GroupCompatDecl\n%type <ledMap>  LedMapDecl\n%type <ledName> LedNameDecl\n%type <keyCode> KeyNameDecl\n%type <keyAlias> KeyAliasDecl\n%type <geom>    ShapeDecl SectionDecl SectionBody SectionBodyItem RowBody RowBodyItem\n%type <geom>    Keys Key OverlayDecl OverlayKeyList OverlayKey OutlineList OutlineInList\n%type <geom>    DoodadDecl\n%type <file>    XkbFile XkbMapConfigList XkbMapConfig\n%type <file>    XkbCompositeMap\n\n%destructor { FreeStmt((ParseCommon *) $$); }\n    <any> <expr> <var> <vmod> <interp> <keyType> <syms> <modMask> <groupCompat>\n    <ledMap> <ledName> <keyCode> <keyAlias>\n/* The destructor also runs on the start symbol when the parser *succeeds*.\n * The `if` here catches this case. */\n%destructor { if (!param->rtrn) FreeXkbFile($$); } <file>\n%destructor { free($$); } <str>\n\n%%\n\n/*\n * An actual file may contain more than one map. However, if we do things\n * in the normal yacc way, i.e. aggregate all of the maps into a list and\n * let the caller find the map it wants, we end up scanning and parsing a\n * lot of unneeded maps (in the end we always just need one).\n * Instead of doing that, we make yyparse return one map at a time, and\n * then call it repeatedly until we find the map we need. Once we find it,\n * we don't need to parse everything that follows in the file.\n * This does mean that if we e.g. always use the first map, the file may\n * contain complete garbage after that. But it's worth it.\n */\n\nXkbFile         :       XkbCompositeMap\n                        { $$ = param->rtrn = $1; param->more_maps = true; }\n                |       XkbMapConfig\n                        { $$ = param->rtrn = $1; param->more_maps = true; YYACCEPT; }\n                |       END_OF_FILE\n                        { $$ = param->rtrn = NULL; param->more_maps = false; }\n                ;\n\nXkbCompositeMap :       OptFlags XkbCompositeType OptMapName OBRACE\n                            XkbMapConfigList\n                        CBRACE SEMI\n                        { $$ = XkbFileCreate($2, $3, (ParseCommon *) $5, $1); }\n                ;\n\nXkbCompositeType:       XKB_KEYMAP      { $$ = FILE_TYPE_KEYMAP; }\n                |       XKB_SEMANTICS   { $$ = FILE_TYPE_KEYMAP; }\n                |       XKB_LAYOUT      { $$ = FILE_TYPE_KEYMAP; }\n                ;\n\nXkbMapConfigList :      XkbMapConfigList XkbMapConfig\n                        {\n                            if (!$2)\n                                $$ = $1;\n                            else\n                                $$ = (XkbFile *) AppendStmt((ParseCommon *) $1,\n                                                            (ParseCommon *) $2);\n                        }\n                |       XkbMapConfig\n                        { $$ = $1; }\n                ;\n\nXkbMapConfig    :       OptFlags FileType OptMapName OBRACE\n                            DeclList\n                        CBRACE SEMI\n                        {\n                            if ($2 == FILE_TYPE_GEOMETRY) {\n                                free($3);\n                                FreeStmt($5);\n                                $$ = NULL;\n                            }\n                            else {\n                                $$ = XkbFileCreate($2, $3, $5, $1);\n                            }\n                        }\n                ;\n\nFileType        :       XKB_KEYCODES            { $$ = FILE_TYPE_KEYCODES; }\n                |       XKB_TYPES               { $$ = FILE_TYPE_TYPES; }\n                |       XKB_COMPATMAP           { $$ = FILE_TYPE_COMPAT; }\n                |       XKB_SYMBOLS             { $$ = FILE_TYPE_SYMBOLS; }\n                |       XKB_GEOMETRY            { $$ = FILE_TYPE_GEOMETRY; }\n                ;\n\nOptFlags        :       Flags                   { $$ = $1; }\n                |                               { $$ = 0; }\n                ;\n\nFlags           :       Flags Flag              { $$ = ($1 | $2); }\n                |       Flag                    { $$ = $1; }\n                ;\n\nFlag            :       PARTIAL                 { $$ = MAP_IS_PARTIAL; }\n                |       DEFAULT                 { $$ = MAP_IS_DEFAULT; }\n                |       HIDDEN                  { $$ = MAP_IS_HIDDEN; }\n                |       ALPHANUMERIC_KEYS       { $$ = MAP_HAS_ALPHANUMERIC; }\n                |       MODIFIER_KEYS           { $$ = MAP_HAS_MODIFIER; }\n                |       KEYPAD_KEYS             { $$ = MAP_HAS_KEYPAD; }\n                |       FUNCTION_KEYS           { $$ = MAP_HAS_FN; }\n                |       ALTERNATE_GROUP         { $$ = MAP_IS_ALTGR; }\n                ;\n\nDeclList        :       DeclList Decl\n                        { $$ = AppendStmt($1, $2); }\n                |       { $$ = NULL; }\n                ;\n\nDecl            :       OptMergeMode VarDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode VModDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode InterpretDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode KeyNameDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode KeyAliasDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode KeyTypeDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode SymbolsDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode ModMapDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode GroupCompatDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode LedMapDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode LedNameDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode ShapeDecl          { $$ = NULL; }\n                |       OptMergeMode SectionDecl        { $$ = NULL; }\n                |       OptMergeMode DoodadDecl         { $$ = NULL; }\n                |       MergeMode STRING\n                        {\n                            $$ = (ParseCommon *) IncludeCreate(param->ctx, $2, $1);\n                            free($2);\n                        }\n                ;\n\nVarDecl         :       Lhs EQUALS Expr SEMI\n                        { $$ = VarCreate($1, $3); }\n                |       Ident SEMI\n                        { $$ = BoolVarCreate($1, true); }\n                |       EXCLAM Ident SEMI\n                        { $$ = BoolVarCreate($2, false); }\n                ;\n\nKeyNameDecl     :       KEYNAME EQUALS KeyCode SEMI\n                        { $$ = KeycodeCreate($1, $3); }\n                ;\n\nKeyAliasDecl    :       ALIAS KEYNAME EQUALS KEYNAME SEMI\n                        { $$ = KeyAliasCreate($2, $4); }\n                ;\n\nVModDecl        :       VIRTUAL_MODS VModDefList SEMI\n                        { $$ = $2; }\n                ;\n\nVModDefList     :       VModDefList COMMA VModDef\n                        { $$ = (VModDef *) AppendStmt((ParseCommon *) $1,\n                                                      (ParseCommon *) $3); }\n                |       VModDef\n                        { $$ = $1; }\n                ;\n\nVModDef         :       Ident\n                        { $$ = VModCreate($1, NULL); }\n                |       Ident EQUALS Expr\n                        { $$ = VModCreate($1, $3); }\n                ;\n\nInterpretDecl   :       INTERPRET InterpretMatch OBRACE\n                            VarDeclList\n                        CBRACE SEMI\n                        { $2->def = $4; $$ = $2; }\n                ;\n\nInterpretMatch  :       KeySym PLUS Expr\n                        { $$ = InterpCreate($1, $3); }\n                |       KeySym\n                        { $$ = InterpCreate($1, NULL); }\n                ;\n\nVarDeclList     :       VarDeclList VarDecl\n                        { $$ = (VarDef *) AppendStmt((ParseCommon *) $1,\n                                                     (ParseCommon *) $2); }\n                |       VarDecl\n                        { $$ = $1; }\n                ;\n\nKeyTypeDecl     :       TYPE String OBRACE\n                            VarDeclList\n                        CBRACE SEMI\n                        { $$ = KeyTypeCreate($2, $4); }\n                ;\n\nSymbolsDecl     :       KEY KEYNAME OBRACE\n                            SymbolsBody\n                        CBRACE SEMI\n                        { $$ = SymbolsCreate($2, $4); }\n                ;\n\nSymbolsBody     :       SymbolsBody COMMA SymbolsVarDecl\n                        { $$ = (VarDef *) AppendStmt((ParseCommon *) $1,\n                                                     (ParseCommon *) $3); }\n                |       SymbolsVarDecl\n                        { $$ = $1; }\n                |       { $$ = NULL; }\n                ;\n\nSymbolsVarDecl  :       Lhs EQUALS Expr         { $$ = VarCreate($1, $3); }\n                |       Lhs EQUALS ArrayInit    { $$ = VarCreate($1, $3); }\n                |       Ident                   { $$ = BoolVarCreate($1, true); }\n                |       EXCLAM Ident            { $$ = BoolVarCreate($2, false); }\n                |       ArrayInit               { $$ = VarCreate(NULL, $1); }\n                ;\n\nArrayInit       :       OBRACKET OptKeySymList CBRACKET\n                        { $$ = $2; }\n                |       OBRACKET ActionList CBRACKET\n                        { $$ = ExprCreateUnary(EXPR_ACTION_LIST, EXPR_TYPE_ACTION, $2); }\n                ;\n\nGroupCompatDecl :       GROUP Integer EQUALS Expr SEMI\n                        { $$ = GroupCompatCreate($2, $4); }\n                ;\n\nModMapDecl      :       MODIFIER_MAP Ident OBRACE ExprList CBRACE SEMI\n                        { $$ = ModMapCreate($2, $4); }\n                ;\n\nLedMapDecl:             INDICATOR String OBRACE VarDeclList CBRACE SEMI\n                        { $$ = LedMapCreate($2, $4); }\n                ;\n\nLedNameDecl:            INDICATOR Integer EQUALS Expr SEMI\n                        { $$ = LedNameCreate($2, $4, false); }\n                |       VIRTUAL INDICATOR Integer EQUALS Expr SEMI\n                        { $$ = LedNameCreate($3, $5, true); }\n                ;\n\nShapeDecl       :       SHAPE String OBRACE OutlineList CBRACE SEMI\n                        { $$ = NULL; }\n                |       SHAPE String OBRACE CoordList CBRACE SEMI\n                        { (void) $4; $$ = NULL; }\n                ;\n\nSectionDecl     :       SECTION String OBRACE SectionBody CBRACE SEMI\n                        { $$ = NULL; }\n                ;\n\nSectionBody     :       SectionBody SectionBodyItem     { $$ = NULL;}\n                |       SectionBodyItem                 { $$ = NULL; }\n                ;\n\nSectionBodyItem :       ROW OBRACE RowBody CBRACE SEMI\n                        { $$ = NULL; }\n                |       VarDecl\n                        { FreeStmt((ParseCommon *) $1); $$ = NULL; }\n                |       DoodadDecl\n                        { $$ = NULL; }\n                |       LedMapDecl\n                        { FreeStmt((ParseCommon *) $1); $$ = NULL; }\n                |       OverlayDecl\n                        { $$ = NULL; }\n                ;\n\nRowBody         :       RowBody RowBodyItem     { $$ = NULL;}\n                |       RowBodyItem             { $$ = NULL; }\n                ;\n\nRowBodyItem     :       KEYS OBRACE Keys CBRACE SEMI { $$ = NULL; }\n                |       VarDecl\n                        { FreeStmt((ParseCommon *) $1); $$ = NULL; }\n                ;\n\nKeys            :       Keys COMMA Key          { $$ = NULL; }\n                |       Key                     { $$ = NULL; }\n                ;\n\nKey             :       KEYNAME\n                        { $$ = NULL; }\n                |       OBRACE ExprList CBRACE\n                        { FreeStmt((ParseCommon *) $2); $$ = NULL; }\n                ;\n\nOverlayDecl     :       OVERLAY String OBRACE OverlayKeyList CBRACE SEMI\n                        { $$ = NULL; }\n                ;\n\nOverlayKeyList  :       OverlayKeyList COMMA OverlayKey { $$ = NULL; }\n                |       OverlayKey                      { $$ = NULL; }\n                ;\n\nOverlayKey      :       KEYNAME EQUALS KEYNAME          { $$ = NULL; }\n                ;\n\nOutlineList     :       OutlineList COMMA OutlineInList\n                        { $$ = NULL;}\n                |       OutlineInList\n                        { $$ = NULL; }\n                ;\n\nOutlineInList   :       OBRACE CoordList CBRACE\n                        { (void) $2; $$ = NULL; }\n                |       Ident EQUALS OBRACE CoordList CBRACE\n                        { (void) $4; $$ = NULL; }\n                |       Ident EQUALS Expr\n                        { FreeStmt((ParseCommon *) $3); $$ = NULL; }\n                ;\n\nCoordList       :       CoordList COMMA Coord\n                        { (void) $1; (void) $3; $$ = NULL; }\n                |       Coord\n                        { (void) $1; $$ = NULL; }\n                ;\n\nCoord           :       OBRACKET SignedNumber COMMA SignedNumber CBRACKET\n                        { $$ = NULL; }\n                ;\n\nDoodadDecl      :       DoodadType String OBRACE VarDeclList CBRACE SEMI\n                        { FreeStmt((ParseCommon *) $4); $$ = NULL; }\n                ;\n\nDoodadType      :       TEXT    { $$ = 0; }\n                |       OUTLINE { $$ = 0; }\n                |       SOLID   { $$ = 0; }\n                |       LOGO    { $$ = 0; }\n                ;\n\nFieldSpec       :       Ident   { $$ = $1; }\n                |       Element { $$ = $1; }\n                ;\n\nElement         :       ACTION_TOK\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"action\"); }\n                |       INTERPRET\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"interpret\"); }\n                |       TYPE\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"type\"); }\n                |       KEY\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"key\"); }\n                |       GROUP\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"group\"); }\n                |       MODIFIER_MAP\n                        {$$ = xkb_atom_intern_literal(param->ctx, \"modifier_map\");}\n                |       INDICATOR\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"indicator\"); }\n                |       SHAPE\n                        { $$ = XKB_ATOM_NONE; }\n                |       ROW\n                        { $$ = XKB_ATOM_NONE; }\n                |       SECTION\n                        { $$ = XKB_ATOM_NONE; }\n                |       TEXT\n                        { $$ = XKB_ATOM_NONE; }\n                ;\n\nOptMergeMode    :       MergeMode       { $$ = $1; }\n                |                       { $$ = MERGE_DEFAULT; }\n                ;\n\nMergeMode       :       INCLUDE         { $$ = MERGE_DEFAULT; }\n                |       AUGMENT         { $$ = MERGE_AUGMENT; }\n                |       OVERRIDE        { $$ = MERGE_OVERRIDE; }\n                |       REPLACE         { $$ = MERGE_REPLACE; }\n                |       ALTERNATE\n                {\n                    /*\n                     * This used to be MERGE_ALT_FORM. This functionality was\n                     * unused and has been removed.\n                     */\n                    $$ = MERGE_DEFAULT;\n                }\n                ;\n\nOptExprList     :       ExprList        { $$ = $1; }\n                |                       { $$ = NULL; }\n                ;\n\nExprList        :       ExprList COMMA Expr\n                        { $$ = (ExprDef *) AppendStmt((ParseCommon *) $1,\n                                                      (ParseCommon *) $3); }\n                |       Expr\n                        { $$ = $1; }\n                ;\n\nExpr            :       Expr DIVIDE Expr\n                        { $$ = ExprCreateBinary(EXPR_DIVIDE, $1, $3); }\n                |       Expr PLUS Expr\n                        { $$ = ExprCreateBinary(EXPR_ADD, $1, $3); }\n                |       Expr MINUS Expr\n                        { $$ = ExprCreateBinary(EXPR_SUBTRACT, $1, $3); }\n                |       Expr TIMES Expr\n                        { $$ = ExprCreateBinary(EXPR_MULTIPLY, $1, $3); }\n                |       Lhs EQUALS Expr\n                        { $$ = ExprCreateBinary(EXPR_ASSIGN, $1, $3); }\n                |       Term\n                        { $$ = $1; }\n                ;\n\nTerm            :       MINUS Term\n                        { $$ = ExprCreateUnary(EXPR_NEGATE, $2->expr.value_type, $2); }\n                |       PLUS Term\n                        { $$ = ExprCreateUnary(EXPR_UNARY_PLUS, $2->expr.value_type, $2); }\n                |       EXCLAM Term\n                        { $$ = ExprCreateUnary(EXPR_NOT, EXPR_TYPE_BOOLEAN, $2); }\n                |       INVERT Term\n                        { $$ = ExprCreateUnary(EXPR_INVERT, $2->expr.value_type, $2); }\n                |       Lhs\n                        { $$ = $1;  }\n                |       FieldSpec OPAREN OptExprList CPAREN %prec OPAREN\n                        { $$ = ExprCreateAction($1, $3); }\n                |       Terminal\n                        { $$ = $1;  }\n                |       OPAREN Expr CPAREN\n                        { $$ = $2;  }\n                ;\n\nActionList      :       ActionList COMMA Action\n                        { $$ = (ExprDef *) AppendStmt((ParseCommon *) $1,\n                                                      (ParseCommon *) $3); }\n                |       Action\n                        { $$ = $1; }\n                ;\n\nAction          :       FieldSpec OPAREN OptExprList CPAREN\n                        { $$ = ExprCreateAction($1, $3); }\n                ;\n\nLhs             :       FieldSpec\n                        { $$ = ExprCreateIdent($1); }\n                |       FieldSpec DOT FieldSpec\n                        { $$ = ExprCreateFieldRef($1, $3); }\n                |       FieldSpec OBRACKET Expr CBRACKET\n                        { $$ = ExprCreateArrayRef(XKB_ATOM_NONE, $1, $3); }\n                |       FieldSpec DOT FieldSpec OBRACKET Expr CBRACKET\n                        { $$ = ExprCreateArrayRef($1, $3, $5); }\n                ;\n\nTerminal        :       String\n                        { $$ = ExprCreateString($1); }\n                |       Integer\n                        { $$ = ExprCreateInteger($1); }\n                |       Float\n                        { $$ = NULL; }\n                |       KEYNAME\n                        { $$ = ExprCreateKeyName($1); }\n                ;\n\nOptKeySymList   :       KeySymList      { $$ = $1; }\n                |                       { $$ = NULL; }\n                ;\n\nKeySymList      :       KeySymList COMMA KeySym\n                        { $$ = ExprAppendKeysymList($1, $3); }\n                |       KeySymList COMMA KeySyms\n                        { $$ = ExprAppendMultiKeysymList($1, $3); }\n                |       KeySym\n                        { $$ = ExprCreateKeysymList($1); }\n                |       KeySyms\n                        { $$ = ExprCreateMultiKeysymList($1); }\n                ;\n\nKeySyms         :       OBRACE KeySymList CBRACE\n                        { $$ = $2; }\n                ;\n\nKeySym          :       IDENT\n                        {\n                            if (!resolve_keysym($1, &$$))\n                                parser_warn(param, \"unrecognized keysym \\\"%s\\\"\", $1);\n                            free($1);\n                        }\n                |       SECTION { $$ = XKB_KEY_section; }\n                |       Integer\n                        {\n                            if ($1 < 0) {\n                                parser_warn(param, \"unrecognized keysym \\\"%d\\\"\", $1);\n                                $$ = XKB_KEY_NoSymbol;\n                            }\n                            else if ($1 < 10) {      /* XKB_KEY_0 .. XKB_KEY_9 */\n                                $$ = XKB_KEY_0 + (xkb_keysym_t) $1;\n                            }\n                            else {\n                                char buf[17];\n                                snprintf(buf, sizeof(buf), \"0x%x\", $1);\n                                if (!resolve_keysym(buf, &$$)) {\n                                    parser_warn(param, \"unrecognized keysym \\\"%s\\\"\", buf);\n                                    $$ = XKB_KEY_NoSymbol;\n                                }\n                            }\n                        }\n                ;\n\nSignedNumber    :       MINUS Number    { $$ = -$2; }\n                |       Number          { $$ = $1; }\n                ;\n\nNumber          :       FLOAT   { $$ = $1; }\n                |       INTEGER { $$ = $1; }\n                ;\n\nFloat           :       FLOAT   { $$ = 0; }\n                ;\n\nInteger         :       INTEGER { $$ = $1; }\n                ;\n\nKeyCode         :       INTEGER { $$ = $1; }\n                ;\n\nIdent           :       IDENT   { $$ = xkb_atom_steal(param->ctx, $1); }\n                |       DEFAULT { $$ = xkb_atom_intern_literal(param->ctx, \"default\"); }\n                ;\n\nString          :       STRING  { $$ = xkb_atom_steal(param->ctx, $1); }\n                ;\n\nOptMapName      :       MapName { $$ = $1; }\n                |               { $$ = NULL; }\n                ;\n\nMapName         :       STRING  { $$ = $1; }\n                ;\n\n%%\n\nXkbFile *\nparse(struct xkb_context *ctx, struct scanner *scanner, const char *map)\n{\n    int ret;\n    XkbFile *first = NULL;\n    struct parser_param param = {\n        .scanner = scanner,\n        .ctx = ctx,\n        .rtrn = NULL,\n    };\n\n    /*\n     * If we got a specific map, we look for it exclusively and return\n     * immediately upon finding it. Otherwise, we need to get the\n     * default map. If we find a map marked as default, we return it\n     * immediately. If there are no maps marked as default, we return\n     * the first map in the file.\n     */\n\n    while ((ret = yyparse(&param)) == 0 && param.more_maps) {\n        if (map) {\n            if (streq_not_null(map, param.rtrn->name))\n                return param.rtrn;\n            else\n                FreeXkbFile(param.rtrn);\n        }\n        else {\n            if (param.rtrn->flags & MAP_IS_DEFAULT) {\n                FreeXkbFile(first);\n                return param.rtrn;\n            }\n            else if (!first) {\n                first = param.rtrn;\n            }\n            else {\n                FreeXkbFile(param.rtrn);\n            }\n        }\n        param.rtrn = NULL;\n    }\n\n    if (ret != 0) {\n        FreeXkbFile(first);\n        return NULL;\n    }\n\n    if (first)\n        log_vrb(ctx, 5,\n                \"No map in include statement, but \\\"%s\\\" contains several; \"\n                \"Using first defined map, \\\"%s\\\"\\n\",\n                scanner->file_name, first->name);\n\n    return first;\n}\n"], "fixing_code": ["/************************************************************\n * Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.\n *\n * Permission to use, copy, modify, and distribute this\n * software and its documentation for any purpose and without\n * fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright\n * notice and this permission notice appear in supporting\n * documentation, and that the name of Silicon Graphics not be\n * used in advertising or publicity pertaining to distribution\n * of the software without specific prior written permission.\n * Silicon Graphics makes no representation about the suitability\n * of this software for any purpose. It is provided \"as is\"\n * without any express or implied warranty.\n *\n * SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS\n * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON\n * GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL\n * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\n * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH\n * THE USE OR PERFORMANCE OF THIS SOFTWARE.\n *\n ********************************************************/\n\n/*\n * Copyright \u00a9 2012 Intel Corporation\n * Copyright \u00a9 2012 Ran Benita <ran234@gmail.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice (including the next\n * paragraph) shall be included in all copies or substantial portions of the\n * Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n * Author: Daniel Stone <daniel@fooishbar.org>\n *         Ran Benita <ran234@gmail.com>\n */\n\n#include \"xkbcomp-priv.h\"\n#include \"ast-build.h\"\n#include \"include.h\"\n\nParseCommon *\nAppendStmt(ParseCommon *to, ParseCommon *append)\n{\n    ParseCommon *iter;\n\n    if (!to)\n        return append;\n\n    for (iter = to; iter->next; iter = iter->next);\n\n    iter->next = append;\n    return to;\n}\n\nstatic ExprDef *\nExprCreate(enum expr_op_type op, enum expr_value_type type, size_t size)\n{\n    ExprDef *expr = malloc(size);\n    if (!expr)\n        return NULL;\n\n    expr->common.type = STMT_EXPR;\n    expr->common.next = NULL;\n    expr->expr.op = op;\n    expr->expr.value_type = type;\n\n    return expr;\n}\n\n#define EXPR_CREATE(type_, name_, op_, value_type_) \\\n    ExprDef *name_ = ExprCreate(op_, value_type_, sizeof(type_)); \\\n    if (!name_) \\\n        return NULL;\n\nExprDef *\nExprCreateString(xkb_atom_t str)\n{\n    EXPR_CREATE(ExprString, expr, EXPR_VALUE, EXPR_TYPE_STRING);\n    expr->string.str = str;\n    return expr;\n}\n\nExprDef *\nExprCreateInteger(int ival)\n{\n    EXPR_CREATE(ExprInteger, expr, EXPR_VALUE, EXPR_TYPE_INT);\n    expr->integer.ival = ival;\n    return expr;\n}\n\nExprDef *\nExprCreateFloat(void)\n{\n    EXPR_CREATE(ExprFloat, expr, EXPR_VALUE, EXPR_TYPE_FLOAT);\n    return expr;\n}\n\nExprDef *\nExprCreateBoolean(bool set)\n{\n    EXPR_CREATE(ExprBoolean, expr, EXPR_VALUE, EXPR_TYPE_BOOLEAN);\n    expr->boolean.set = set;\n    return expr;\n}\n\nExprDef *\nExprCreateKeyName(xkb_atom_t key_name)\n{\n    EXPR_CREATE(ExprKeyName, expr, EXPR_VALUE, EXPR_TYPE_KEYNAME);\n    expr->key_name.key_name = key_name;\n    return expr;\n}\n\nExprDef *\nExprCreateIdent(xkb_atom_t ident)\n{\n    EXPR_CREATE(ExprIdent, expr, EXPR_IDENT, EXPR_TYPE_UNKNOWN);\n    expr->ident.ident = ident;\n    return expr;\n}\n\nExprDef *\nExprCreateUnary(enum expr_op_type op, enum expr_value_type type,\n                ExprDef *child)\n{\n    EXPR_CREATE(ExprUnary, expr, op, type);\n    expr->unary.child = child;\n    return expr;\n}\n\nExprDef *\nExprCreateBinary(enum expr_op_type op, ExprDef *left, ExprDef *right)\n{\n    EXPR_CREATE(ExprBinary, expr, op, EXPR_TYPE_UNKNOWN);\n\n    if (op == EXPR_ASSIGN || left->expr.value_type == EXPR_TYPE_UNKNOWN)\n        expr->expr.value_type = right->expr.value_type;\n    else if (left->expr.value_type == right->expr.value_type ||\n             right->expr.value_type == EXPR_TYPE_UNKNOWN)\n        expr->expr.value_type = left->expr.value_type;\n    expr->binary.left = left;\n    expr->binary.right = right;\n\n    return expr;\n}\n\nExprDef *\nExprCreateFieldRef(xkb_atom_t element, xkb_atom_t field)\n{\n    EXPR_CREATE(ExprFieldRef, expr, EXPR_FIELD_REF, EXPR_TYPE_UNKNOWN);\n    expr->field_ref.element = element;\n    expr->field_ref.field = field;\n    return expr;\n}\n\nExprDef *\nExprCreateArrayRef(xkb_atom_t element, xkb_atom_t field, ExprDef *entry)\n{\n    EXPR_CREATE(ExprArrayRef, expr, EXPR_ARRAY_REF, EXPR_TYPE_UNKNOWN);\n    expr->array_ref.element = element;\n    expr->array_ref.field = field;\n    expr->array_ref.entry = entry;\n    return expr;\n}\n\nExprDef *\nExprCreateAction(xkb_atom_t name, ExprDef *args)\n{\n    EXPR_CREATE(ExprAction, expr, EXPR_ACTION_DECL, EXPR_TYPE_UNKNOWN);\n    expr->action.name = name;\n    expr->action.args = args;\n    return expr;\n}\n\nExprDef *\nExprCreateKeysymList(xkb_keysym_t sym)\n{\n    EXPR_CREATE(ExprKeysymList, expr, EXPR_KEYSYM_LIST, EXPR_TYPE_SYMBOLS);\n\n    darray_init(expr->keysym_list.syms);\n    darray_init(expr->keysym_list.symsMapIndex);\n    darray_init(expr->keysym_list.symsNumEntries);\n\n    darray_append(expr->keysym_list.syms, sym);\n    darray_append(expr->keysym_list.symsMapIndex, 0);\n    darray_append(expr->keysym_list.symsNumEntries, 1);\n\n    return expr;\n}\n\nExprDef *\nExprCreateMultiKeysymList(ExprDef *expr)\n{\n    unsigned nLevels = darray_size(expr->keysym_list.symsMapIndex);\n\n    darray_resize(expr->keysym_list.symsMapIndex, 1);\n    darray_resize(expr->keysym_list.symsNumEntries, 1);\n    darray_item(expr->keysym_list.symsMapIndex, 0) = 0;\n    darray_item(expr->keysym_list.symsNumEntries, 0) = nLevels;\n\n    return expr;\n}\n\nExprDef *\nExprAppendKeysymList(ExprDef *expr, xkb_keysym_t sym)\n{\n    unsigned nSyms = darray_size(expr->keysym_list.syms);\n\n    darray_append(expr->keysym_list.symsMapIndex, nSyms);\n    darray_append(expr->keysym_list.symsNumEntries, 1);\n    darray_append(expr->keysym_list.syms, sym);\n\n    return expr;\n}\n\nExprDef *\nExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)\n{\n    unsigned nSyms = darray_size(expr->keysym_list.syms);\n    unsigned numEntries = darray_size(append->keysym_list.syms);\n\n    darray_append(expr->keysym_list.symsMapIndex, nSyms);\n    darray_append(expr->keysym_list.symsNumEntries, numEntries);\n    darray_concat(expr->keysym_list.syms, append->keysym_list.syms);\n\n    FreeStmt((ParseCommon *) &append);\n\n    return expr;\n}\n\nKeycodeDef *\nKeycodeCreate(xkb_atom_t name, int64_t value)\n{\n    KeycodeDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_KEYCODE;\n    def->common.next = NULL;\n    def->name = name;\n    def->value = value;\n\n    return def;\n}\n\nKeyAliasDef *\nKeyAliasCreate(xkb_atom_t alias, xkb_atom_t real)\n{\n    KeyAliasDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_ALIAS;\n    def->common.next = NULL;\n    def->alias = alias;\n    def->real = real;\n\n    return def;\n}\n\nVModDef *\nVModCreate(xkb_atom_t name, ExprDef *value)\n{\n    VModDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_VMOD;\n    def->common.next = NULL;\n    def->name = name;\n    def->value = value;\n\n    return def;\n}\n\nVarDef *\nVarCreate(ExprDef *name, ExprDef *value)\n{\n    VarDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_VAR;\n    def->common.next = NULL;\n    def->name = name;\n    def->value = value;\n\n    return def;\n}\n\nVarDef *\nBoolVarCreate(xkb_atom_t ident, bool set)\n{\n    ExprDef *name, *value;\n    VarDef *def;\n    if (!(name = ExprCreateIdent(ident))) {\n        return NULL;\n    }\n    if (!(value = ExprCreateBoolean(set))) {\n        FreeStmt((ParseCommon *) name);\n        return NULL;\n    }\n    if (!(def = VarCreate(name, value))) {\n        FreeStmt((ParseCommon *) name);\n        FreeStmt((ParseCommon *) value);\n        return NULL;\n    }\n    return def;\n}\n\nInterpDef *\nInterpCreate(xkb_keysym_t sym, ExprDef *match)\n{\n    InterpDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_INTERP;\n    def->common.next = NULL;\n    def->sym = sym;\n    def->match = match;\n    def->def = NULL;\n\n    return def;\n}\n\nKeyTypeDef *\nKeyTypeCreate(xkb_atom_t name, VarDef *body)\n{\n    KeyTypeDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_TYPE;\n    def->common.next = NULL;\n    def->merge = MERGE_DEFAULT;\n    def->name = name;\n    def->body = body;\n\n    return def;\n}\n\nSymbolsDef *\nSymbolsCreate(xkb_atom_t keyName, VarDef *symbols)\n{\n    SymbolsDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_SYMBOLS;\n    def->common.next = NULL;\n    def->merge = MERGE_DEFAULT;\n    def->keyName = keyName;\n    def->symbols = symbols;\n\n    return def;\n}\n\nGroupCompatDef *\nGroupCompatCreate(unsigned group, ExprDef *val)\n{\n    GroupCompatDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_GROUP_COMPAT;\n    def->common.next = NULL;\n    def->merge = MERGE_DEFAULT;\n    def->group = group;\n    def->def = val;\n\n    return def;\n}\n\nModMapDef *\nModMapCreate(xkb_atom_t modifier, ExprDef *keys)\n{\n    ModMapDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_MODMAP;\n    def->common.next = NULL;\n    def->merge = MERGE_DEFAULT;\n    def->modifier = modifier;\n    def->keys = keys;\n\n    return def;\n}\n\nLedMapDef *\nLedMapCreate(xkb_atom_t name, VarDef *body)\n{\n    LedMapDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_LED_MAP;\n    def->common.next = NULL;\n    def->merge = MERGE_DEFAULT;\n    def->name = name;\n    def->body = body;\n\n    return def;\n}\n\nLedNameDef *\nLedNameCreate(unsigned ndx, ExprDef *name, bool virtual)\n{\n    LedNameDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_LED_NAME;\n    def->common.next = NULL;\n    def->merge = MERGE_DEFAULT;\n    def->ndx = ndx;\n    def->name = name;\n    def->virtual = virtual;\n\n    return def;\n}\n\nstatic void\nFreeInclude(IncludeStmt *incl);\n\nIncludeStmt *\nIncludeCreate(struct xkb_context *ctx, char *str, enum merge_mode merge)\n{\n    IncludeStmt *incl, *first;\n    char *file, *map, *stmt, *tmp, *extra_data;\n    char nextop;\n\n    incl = first = NULL;\n    file = map = NULL;\n    tmp = str;\n    stmt = strdup_safe(str);\n    while (tmp && *tmp)\n    {\n        if (!ParseIncludeMap(&tmp, &file, &map, &nextop, &extra_data))\n            goto err;\n\n        /*\n         * Given an RMLVO (here layout) like 'us,,fr', the rules parser\n         * will give out something like 'pc+us+:2+fr:3+inet(evdev)'.\n         * We should just skip the ':2' in this case and leave it to the\n         * appropriate section to deal with the empty group.\n         */\n        if (isempty(file)) {\n            free(file);\n            free(map);\n            free(extra_data);\n            continue;\n        }\n\n        if (first == NULL) {\n            first = incl = malloc(sizeof(*first));\n        } else {\n            incl->next_incl = malloc(sizeof(*first));\n            incl = incl->next_incl;\n        }\n\n        if (!incl)\n            break;\n\n        incl->common.type = STMT_INCLUDE;\n        incl->common.next = NULL;\n        incl->merge = merge;\n        incl->stmt = NULL;\n        incl->file = file;\n        incl->map = map;\n        incl->modifier = extra_data;\n        incl->next_incl = NULL;\n\n        if (nextop == '|')\n            merge = MERGE_AUGMENT;\n        else\n            merge = MERGE_OVERRIDE;\n    }\n\n    if (first)\n        first->stmt = stmt;\n    else\n        free(stmt);\n\n    return first;\n\nerr:\n    log_err(ctx, \"Illegal include statement \\\"%s\\\"; Ignored\\n\", stmt);\n    FreeInclude(first);\n    free(stmt);\n    return NULL;\n}\n\nXkbFile *\nXkbFileCreate(enum xkb_file_type type, char *name, ParseCommon *defs,\n              enum xkb_map_flags flags)\n{\n    XkbFile *file;\n\n    file = calloc(1, sizeof(*file));\n    if (!file)\n        return NULL;\n\n    XkbEscapeMapName(name);\n    file->file_type = type;\n    file->name = name ? name : strdup(\"(unnamed)\");\n    file->defs = defs;\n    file->flags = flags;\n\n    return file;\n}\n\nXkbFile *\nXkbFileFromComponents(struct xkb_context *ctx,\n                      const struct xkb_component_names *kkctgs)\n{\n    char *const components[] = {\n        kkctgs->keycodes, kkctgs->types,\n        kkctgs->compat, kkctgs->symbols,\n    };\n    enum xkb_file_type type;\n    IncludeStmt *include = NULL;\n    XkbFile *file = NULL;\n    ParseCommon *defs = NULL;\n\n    for (type = FIRST_KEYMAP_FILE_TYPE; type <= LAST_KEYMAP_FILE_TYPE; type++) {\n        include = IncludeCreate(ctx, components[type], MERGE_DEFAULT);\n        if (!include)\n            goto err;\n\n        file = XkbFileCreate(type, NULL, (ParseCommon *) include, 0);\n        if (!file) {\n            FreeInclude(include);\n            goto err;\n        }\n\n        defs = AppendStmt(defs, &file->common);\n    }\n\n    file = XkbFileCreate(FILE_TYPE_KEYMAP, NULL, defs, 0);\n    if (!file)\n        goto err;\n\n    return file;\n\nerr:\n    FreeXkbFile((XkbFile *) defs);\n    return NULL;\n}\n\nstatic void\nFreeExpr(ExprDef *expr)\n{\n    if (!expr)\n        return;\n\n    switch (expr->expr.op) {\n    case EXPR_ACTION_LIST:\n    case EXPR_NEGATE:\n    case EXPR_UNARY_PLUS:\n    case EXPR_NOT:\n    case EXPR_INVERT:\n        FreeStmt((ParseCommon *) expr->unary.child);\n        break;\n\n    case EXPR_DIVIDE:\n    case EXPR_ADD:\n    case EXPR_SUBTRACT:\n    case EXPR_MULTIPLY:\n    case EXPR_ASSIGN:\n        FreeStmt((ParseCommon *) expr->binary.left);\n        FreeStmt((ParseCommon *) expr->binary.right);\n        break;\n\n    case EXPR_ACTION_DECL:\n        FreeStmt((ParseCommon *) expr->action.args);\n        break;\n\n    case EXPR_ARRAY_REF:\n        FreeStmt((ParseCommon *) expr->array_ref.entry);\n        break;\n\n    case EXPR_KEYSYM_LIST:\n        darray_free(expr->keysym_list.syms);\n        darray_free(expr->keysym_list.symsMapIndex);\n        darray_free(expr->keysym_list.symsNumEntries);\n        break;\n\n    default:\n        break;\n    }\n}\n\nstatic void\nFreeInclude(IncludeStmt *incl)\n{\n    IncludeStmt *next;\n\n    while (incl)\n    {\n        next = incl->next_incl;\n\n        free(incl->file);\n        free(incl->map);\n        free(incl->modifier);\n        free(incl->stmt);\n\n        free(incl);\n        incl = next;\n    }\n}\n\nvoid\nFreeStmt(ParseCommon *stmt)\n{\n    ParseCommon *next;\n\n    while (stmt)\n    {\n        next = stmt->next;\n\n        switch (stmt->type) {\n        case STMT_INCLUDE:\n            FreeInclude((IncludeStmt *) stmt);\n            /* stmt is already free'd here. */\n            stmt = NULL;\n            break;\n        case STMT_EXPR:\n            FreeExpr((ExprDef *) stmt);\n            break;\n        case STMT_VAR:\n            FreeStmt((ParseCommon *) ((VarDef *) stmt)->name);\n            FreeStmt((ParseCommon *) ((VarDef *) stmt)->value);\n            break;\n        case STMT_TYPE:\n            FreeStmt((ParseCommon *) ((KeyTypeDef *) stmt)->body);\n            break;\n        case STMT_INTERP:\n            FreeStmt((ParseCommon *) ((InterpDef *) stmt)->match);\n            FreeStmt((ParseCommon *) ((InterpDef *) stmt)->def);\n            break;\n        case STMT_VMOD:\n            FreeStmt((ParseCommon *) ((VModDef *) stmt)->value);\n            break;\n        case STMT_SYMBOLS:\n            FreeStmt((ParseCommon *) ((SymbolsDef *) stmt)->symbols);\n            break;\n        case STMT_MODMAP:\n            FreeStmt((ParseCommon *) ((ModMapDef *) stmt)->keys);\n            break;\n        case STMT_GROUP_COMPAT:\n            FreeStmt((ParseCommon *) ((GroupCompatDef *) stmt)->def);\n            break;\n        case STMT_LED_MAP:\n            FreeStmt((ParseCommon *) ((LedMapDef *) stmt)->body);\n            break;\n        case STMT_LED_NAME:\n            FreeStmt((ParseCommon *) ((LedNameDef *) stmt)->name);\n            break;\n        default:\n            break;\n        }\n\n        free(stmt);\n        stmt = next;\n    }\n}\n\nvoid\nFreeXkbFile(XkbFile *file)\n{\n    XkbFile *next;\n\n    while (file)\n    {\n        next = (XkbFile *) file->common.next;\n\n        switch (file->file_type) {\n        case FILE_TYPE_KEYMAP:\n            FreeXkbFile((XkbFile *) file->defs);\n            break;\n\n        case FILE_TYPE_TYPES:\n        case FILE_TYPE_COMPAT:\n        case FILE_TYPE_SYMBOLS:\n        case FILE_TYPE_KEYCODES:\n        case FILE_TYPE_GEOMETRY:\n            FreeStmt(file->defs);\n            break;\n\n        default:\n            break;\n        }\n\n        free(file->name);\n        free(file);\n        file = next;\n    }\n}\n\nstatic const char *xkb_file_type_strings[_FILE_TYPE_NUM_ENTRIES] = {\n    [FILE_TYPE_KEYCODES] = \"xkb_keycodes\",\n    [FILE_TYPE_TYPES] = \"xkb_types\",\n    [FILE_TYPE_COMPAT] = \"xkb_compatibility\",\n    [FILE_TYPE_SYMBOLS] = \"xkb_symbols\",\n    [FILE_TYPE_GEOMETRY] = \"xkb_geometry\",\n    [FILE_TYPE_KEYMAP] = \"xkb_keymap\",\n    [FILE_TYPE_RULES] = \"rules\",\n};\n\nconst char *\nxkb_file_type_to_string(enum xkb_file_type type)\n{\n    if (type > _FILE_TYPE_NUM_ENTRIES)\n        return \"unknown\";\n    return xkb_file_type_strings[type];\n}\n\nstatic const char *stmt_type_strings[_STMT_NUM_VALUES] = {\n    [STMT_UNKNOWN] = \"unknown statement\",\n    [STMT_INCLUDE] = \"include statement\",\n    [STMT_KEYCODE] = \"key name definition\",\n    [STMT_ALIAS] = \"key alias definition\",\n    [STMT_EXPR] = \"expression\",\n    [STMT_VAR] = \"variable definition\",\n    [STMT_TYPE] = \"key type definition\",\n    [STMT_INTERP] = \"symbol interpretation definition\",\n    [STMT_VMOD] = \"virtual modifiers definition\",\n    [STMT_SYMBOLS] = \"key symbols definition\",\n    [STMT_MODMAP] = \"modifier map declaration\",\n    [STMT_GROUP_COMPAT] = \"group declaration\",\n    [STMT_LED_MAP] = \"indicator map declaration\",\n    [STMT_LED_NAME] = \"indicator name declaration\",\n};\n\nconst char *\nstmt_type_to_string(enum stmt_type type)\n{\n    if (type >= _STMT_NUM_VALUES)\n        return NULL;\n    return stmt_type_strings[type];\n}\n\nstatic const char *expr_op_type_strings[_EXPR_NUM_VALUES] = {\n    [EXPR_VALUE] = \"literal\",\n    [EXPR_IDENT] = \"identifier\",\n    [EXPR_ACTION_DECL] = \"action declaration\",\n    [EXPR_FIELD_REF] = \"field reference\",\n    [EXPR_ARRAY_REF] = \"array reference\",\n    [EXPR_KEYSYM_LIST] = \"list of keysyms\",\n    [EXPR_ACTION_LIST] = \"list of actions\",\n    [EXPR_ADD] = \"addition\",\n    [EXPR_SUBTRACT] = \"subtraction\",\n    [EXPR_MULTIPLY] = \"multiplication\",\n    [EXPR_DIVIDE] = \"division\",\n    [EXPR_ASSIGN] = \"assignment\",\n    [EXPR_NOT] = \"logical negation\",\n    [EXPR_NEGATE] = \"arithmetic negation\",\n    [EXPR_INVERT] = \"bitwise inversion\",\n    [EXPR_UNARY_PLUS] = \"unary plus\",\n};\n\nconst char *\nexpr_op_type_to_string(enum expr_op_type type)\n{\n    if (type >= _EXPR_NUM_VALUES)\n        return NULL;\n    return expr_op_type_strings[type];\n}\n\nstatic const char *expr_value_type_strings[_EXPR_TYPE_NUM_VALUES] = {\n    [EXPR_TYPE_UNKNOWN] = \"unknown\",\n    [EXPR_TYPE_BOOLEAN] = \"boolean\",\n    [EXPR_TYPE_INT] = \"int\",\n    [EXPR_TYPE_FLOAT] = \"float\",\n    [EXPR_TYPE_STRING] = \"string\",\n    [EXPR_TYPE_ACTION] = \"action\",\n    [EXPR_TYPE_KEYNAME] = \"keyname\",\n    [EXPR_TYPE_SYMBOLS] = \"symbols\",\n};\n\nconst char *\nexpr_value_type_to_string(enum expr_value_type type)\n{\n    if (type >= _EXPR_TYPE_NUM_VALUES)\n        return NULL;\n    return expr_value_type_strings[type];\n}\n", "/************************************************************\n * Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.\n *\n * Permission to use, copy, modify, and distribute this\n * software and its documentation for any purpose and without\n * fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright\n * notice and this permission notice appear in supporting\n * documentation, and that the name of Silicon Graphics not be\n * used in advertising or publicity pertaining to distribution\n * of the software without specific prior written permission.\n * Silicon Graphics makes no representation about the suitability\n * of this software for any purpose. It is provided \"as is\"\n * without any express or implied warranty.\n *\n * SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS\n * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON\n * GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL\n * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\n * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH\n * THE USE OR PERFORMANCE OF THIS SOFTWARE.\n *\n ********************************************************/\n\n#ifndef XKBCOMP_AST_BUILD_H\n#define XKBCOMP_AST_BUILD_H\n\nParseCommon *\nAppendStmt(ParseCommon *to, ParseCommon *append);\n\nExprDef *\nExprCreateString(xkb_atom_t str);\n\nExprDef *\nExprCreateInteger(int ival);\n\nExprDef *\nExprCreateFloat(void);\n\nExprDef *\nExprCreateBoolean(bool set);\n\nExprDef *\nExprCreateKeyName(xkb_atom_t key_name);\n\nExprDef *\nExprCreateIdent(xkb_atom_t ident);\n\nExprDef *\nExprCreateUnary(enum expr_op_type op, enum expr_value_type type,\n                ExprDef *child);\n\nExprDef *\nExprCreateBinary(enum expr_op_type op, ExprDef *left, ExprDef *right);\n\nExprDef *\nExprCreateFieldRef(xkb_atom_t element, xkb_atom_t field);\n\nExprDef *\nExprCreateArrayRef(xkb_atom_t element, xkb_atom_t field, ExprDef *entry);\n\nExprDef *\nExprCreateAction(xkb_atom_t name, ExprDef *args);\n\nExprDef *\nExprCreateMultiKeysymList(ExprDef *list);\n\nExprDef *\nExprCreateKeysymList(xkb_keysym_t sym);\n\nExprDef *\nExprAppendMultiKeysymList(ExprDef *list, ExprDef *append);\n\nExprDef *\nExprAppendKeysymList(ExprDef *list, xkb_keysym_t sym);\n\nKeycodeDef *\nKeycodeCreate(xkb_atom_t name, int64_t value);\n\nKeyAliasDef *\nKeyAliasCreate(xkb_atom_t alias, xkb_atom_t real);\n\nVModDef *\nVModCreate(xkb_atom_t name, ExprDef *value);\n\nVarDef *\nVarCreate(ExprDef *name, ExprDef *value);\n\nVarDef *\nBoolVarCreate(xkb_atom_t ident, bool set);\n\nInterpDef *\nInterpCreate(xkb_keysym_t sym, ExprDef *match);\n\nKeyTypeDef *\nKeyTypeCreate(xkb_atom_t name, VarDef *body);\n\nSymbolsDef *\nSymbolsCreate(xkb_atom_t keyName, VarDef *symbols);\n\nGroupCompatDef *\nGroupCompatCreate(unsigned group, ExprDef *def);\n\nModMapDef *\nModMapCreate(xkb_atom_t modifier, ExprDef *keys);\n\nLedMapDef *\nLedMapCreate(xkb_atom_t name, VarDef *body);\n\nLedNameDef *\nLedNameCreate(unsigned ndx, ExprDef *name, bool virtual);\n\nIncludeStmt *\nIncludeCreate(struct xkb_context *ctx, char *str, enum merge_mode merge);\n\nXkbFile *\nXkbFileCreate(enum xkb_file_type type, char *name, ParseCommon *defs,\n              enum xkb_map_flags flags);\n\nvoid\nFreeStmt(ParseCommon *stmt);\n\n#endif\n", "/************************************************************\n * Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.\n *\n * Permission to use, copy, modify, and distribute this\n * software and its documentation for any purpose and without\n * fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright\n * notice and this permission notice appear in supporting\n * documentation, and that the name of Silicon Graphics not be\n * used in advertising or publicity pertaining to distribution\n * of the software without specific prior written permission.\n * Silicon Graphics makes no representation about the suitability\n * of this software for any purpose. It is provided \"as is\"\n * without any express or implied warranty.\n *\n * SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS\n * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON\n * GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL\n * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\n * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH\n * THE USE OR PERFORMANCE OF THIS SOFTWARE.\n *\n ********************************************************/\n\n/*\n * Copyright \u00a9 2012 Ran Benita <ran234@gmail.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice (including the next\n * paragraph) shall be included in all copies or substantial portions of the\n * Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n#ifndef XKBCOMP_AST_H\n#define XKBCOMP_AST_H\n\nenum xkb_file_type {\n    /* Component files, by order of compilation. */\n    FILE_TYPE_KEYCODES = 0,\n    FILE_TYPE_TYPES = 1,\n    FILE_TYPE_COMPAT = 2,\n    FILE_TYPE_SYMBOLS = 3,\n    /* Geometry is not compiled any more. */\n    FILE_TYPE_GEOMETRY = 4,\n\n    /* A top level file which includes the above files. */\n    FILE_TYPE_KEYMAP,\n\n/* File types which must be found in a keymap file. */\n#define FIRST_KEYMAP_FILE_TYPE FILE_TYPE_KEYCODES\n#define LAST_KEYMAP_FILE_TYPE  FILE_TYPE_SYMBOLS\n\n    /* This one doesn't mix with the others, but useful here as well. */\n    FILE_TYPE_RULES,\n\n    _FILE_TYPE_NUM_ENTRIES\n};\n\nenum stmt_type {\n    STMT_UNKNOWN = 0,\n    STMT_INCLUDE,\n    STMT_KEYCODE,\n    STMT_ALIAS,\n    STMT_EXPR,\n    STMT_VAR,\n    STMT_TYPE,\n    STMT_INTERP,\n    STMT_VMOD,\n    STMT_SYMBOLS,\n    STMT_MODMAP,\n    STMT_GROUP_COMPAT,\n    STMT_LED_MAP,\n    STMT_LED_NAME,\n\n    _STMT_NUM_VALUES\n};\n\nenum expr_value_type {\n    EXPR_TYPE_UNKNOWN = 0,\n    EXPR_TYPE_BOOLEAN,\n    EXPR_TYPE_INT,\n    EXPR_TYPE_FLOAT,\n    EXPR_TYPE_STRING,\n    EXPR_TYPE_ACTION,\n    EXPR_TYPE_KEYNAME,\n    EXPR_TYPE_SYMBOLS,\n\n    _EXPR_TYPE_NUM_VALUES\n};\n\nenum expr_op_type {\n    EXPR_VALUE,\n    EXPR_IDENT,\n    EXPR_ACTION_DECL,\n    EXPR_FIELD_REF,\n    EXPR_ARRAY_REF,\n    EXPR_KEYSYM_LIST,\n    EXPR_ACTION_LIST,\n    EXPR_ADD,\n    EXPR_SUBTRACT,\n    EXPR_MULTIPLY,\n    EXPR_DIVIDE,\n    EXPR_ASSIGN,\n    EXPR_NOT,\n    EXPR_NEGATE,\n    EXPR_INVERT,\n    EXPR_UNARY_PLUS,\n\n    _EXPR_NUM_VALUES\n};\n\nenum merge_mode {\n    MERGE_DEFAULT,\n    MERGE_AUGMENT,\n    MERGE_OVERRIDE,\n    MERGE_REPLACE,\n};\n\nconst char *\nxkb_file_type_to_string(enum xkb_file_type type);\n\nconst char *\nstmt_type_to_string(enum stmt_type type);\n\nconst char *\nexpr_op_type_to_string(enum expr_op_type type);\n\nconst char *\nexpr_value_type_to_string(enum expr_value_type type);\n\ntypedef struct _ParseCommon  {\n    struct _ParseCommon *next;\n    enum stmt_type type;\n} ParseCommon;\n\ntypedef struct _IncludeStmt {\n    ParseCommon common;\n    enum merge_mode merge;\n    char *stmt;\n    char *file;\n    char *map;\n    char *modifier;\n    struct _IncludeStmt *next_incl;\n} IncludeStmt;\n\ntypedef struct {\n    ParseCommon common;\n    enum expr_op_type op;\n    enum expr_value_type value_type;\n} ExprCommon;\n\ntypedef union ExprDef ExprDef;\n\ntypedef struct {\n    ExprCommon expr;\n    xkb_atom_t ident;\n} ExprIdent;\n\ntypedef struct {\n    ExprCommon expr;\n    xkb_atom_t str;\n} ExprString;\n\ntypedef struct {\n    ExprCommon expr;\n    bool set;\n} ExprBoolean;\n\ntypedef struct {\n    ExprCommon expr;\n    int ival;\n} ExprInteger;\n\ntypedef struct {\n    ExprCommon expr;\n    /* We don't support floats, but we still represnt them in the AST, in\n     * order to provide proper error messages. */\n} ExprFloat;\n\ntypedef struct {\n    ExprCommon expr;\n    xkb_atom_t key_name;\n} ExprKeyName;\n\ntypedef struct {\n    ExprCommon expr;\n    ExprDef *left;\n    ExprDef *right;\n} ExprBinary;\n\ntypedef struct {\n    ExprCommon expr;\n    ExprDef *child;\n} ExprUnary;\n\ntypedef struct {\n    ExprCommon expr;\n    xkb_atom_t element;\n    xkb_atom_t field;\n} ExprFieldRef;\n\ntypedef struct {\n    ExprCommon expr;\n    xkb_atom_t element;\n    xkb_atom_t field;\n    ExprDef *entry;\n} ExprArrayRef;\n\ntypedef struct {\n    ExprCommon expr;\n    xkb_atom_t name;\n    ExprDef *args;\n} ExprAction;\n\ntypedef struct {\n    ExprCommon expr;\n    darray(xkb_keysym_t) syms;\n    darray(unsigned int) symsMapIndex;\n    darray(unsigned int) symsNumEntries;\n} ExprKeysymList;\n\nunion ExprDef {\n    ParseCommon common;\n    /* Maybe someday we can use C11 anonymous struct for ExprCommon here. */\n    ExprCommon expr;\n    ExprIdent ident;\n    ExprString string;\n    ExprBoolean boolean;\n    ExprInteger integer;\n    ExprKeyName key_name;\n    ExprBinary binary;\n    ExprUnary unary;\n    ExprFieldRef field_ref;\n    ExprArrayRef array_ref;\n    ExprAction action;\n    ExprKeysymList keysym_list;\n};\n\ntypedef struct {\n    ParseCommon common;\n    enum merge_mode merge;\n    ExprDef *name;\n    ExprDef *value;\n} VarDef;\n\ntypedef struct {\n    ParseCommon common;\n    enum merge_mode merge;\n    xkb_atom_t name;\n    ExprDef *value;\n} VModDef;\n\ntypedef struct {\n    ParseCommon common;\n    enum merge_mode merge;\n    xkb_atom_t name;\n    int64_t value;\n} KeycodeDef;\n\ntypedef struct {\n    ParseCommon common;\n    enum merge_mode merge;\n    xkb_atom_t alias;\n    xkb_atom_t real;\n} KeyAliasDef;\n\ntypedef struct {\n    ParseCommon common;\n    enum merge_mode merge;\n    xkb_atom_t name;\n    VarDef *body;\n} KeyTypeDef;\n\ntypedef struct {\n    ParseCommon common;\n    enum merge_mode merge;\n    xkb_atom_t keyName;\n    VarDef *symbols;\n} SymbolsDef;\n\ntypedef struct {\n    ParseCommon common;\n    enum merge_mode merge;\n    xkb_atom_t modifier;\n    ExprDef *keys;\n} ModMapDef;\n\ntypedef struct {\n    ParseCommon common;\n    enum merge_mode merge;\n    unsigned group;\n    ExprDef *def;\n} GroupCompatDef;\n\ntypedef struct {\n    ParseCommon common;\n    enum merge_mode merge;\n    xkb_keysym_t sym;\n    ExprDef *match;\n    VarDef *def;\n} InterpDef;\n\ntypedef struct {\n    ParseCommon common;\n    enum merge_mode merge;\n    unsigned ndx;\n    ExprDef *name;\n    bool virtual;\n} LedNameDef;\n\ntypedef struct {\n    ParseCommon common;\n    enum merge_mode merge;\n    xkb_atom_t name;\n    VarDef *body;\n} LedMapDef;\n\nenum xkb_map_flags {\n    MAP_IS_DEFAULT = (1 << 0),\n    MAP_IS_PARTIAL = (1 << 1),\n    MAP_IS_HIDDEN = (1 << 2),\n    MAP_HAS_ALPHANUMERIC = (1 << 3),\n    MAP_HAS_MODIFIER = (1 << 4),\n    MAP_HAS_KEYPAD = (1 << 5),\n    MAP_HAS_FN = (1 << 6),\n    MAP_IS_ALTGR = (1 << 7),\n};\n\ntypedef struct {\n    ParseCommon common;\n    enum xkb_file_type file_type;\n    char *name;\n    ParseCommon *defs;\n    enum xkb_map_flags flags;\n} XkbFile;\n\n#endif\n", "/************************************************************\n Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.\n\n Permission to use, copy, modify, and distribute this\n software and its documentation for any purpose and without\n fee is hereby granted, provided that the above copyright\n notice appear in all copies and that both that copyright\n notice and this permission notice appear in supporting\n documentation, and that the name of Silicon Graphics not be\n used in advertising or publicity pertaining to distribution\n of the software without specific prior written permission.\n Silicon Graphics makes no representation about the suitability\n of this software for any purpose. It is provided \"as is\"\n without any express or implied warranty.\n\n SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS\n SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON\n GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL\n DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\n DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH\n THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n ********************************************************/\n\n/*\n * The parser should work with reasonably recent versions of either\n * bison or byacc.  So if you make changes, try to make sure it works\n * in both!\n */\n\n%{\n#include \"xkbcomp/xkbcomp-priv.h\"\n#include \"xkbcomp/ast-build.h\"\n#include \"xkbcomp/parser-priv.h\"\n#include \"scanner-utils.h\"\n\nstruct parser_param {\n    struct xkb_context *ctx;\n    struct scanner *scanner;\n    XkbFile *rtrn;\n    bool more_maps;\n};\n\n#define parser_err(param, fmt, ...) \\\n    scanner_err((param)->scanner, fmt, ##__VA_ARGS__)\n\n#define parser_warn(param, fmt, ...) \\\n    scanner_warn((param)->scanner, fmt, ##__VA_ARGS__)\n\nstatic void\n_xkbcommon_error(struct parser_param *param, const char *msg)\n{\n    parser_err(param, \"%s\", msg);\n}\n\nstatic bool\nresolve_keysym(const char *name, xkb_keysym_t *sym_rtrn)\n{\n    xkb_keysym_t sym;\n\n    if (!name || istreq(name, \"any\") || istreq(name, \"nosymbol\")) {\n        *sym_rtrn = XKB_KEY_NoSymbol;\n        return true;\n    }\n\n    if (istreq(name, \"none\") || istreq(name, \"voidsymbol\")) {\n        *sym_rtrn = XKB_KEY_VoidSymbol;\n        return true;\n    }\n\n    sym = xkb_keysym_from_name(name, XKB_KEYSYM_NO_FLAGS);\n    if (sym != XKB_KEY_NoSymbol) {\n        *sym_rtrn = sym;\n        return true;\n    }\n\n    return false;\n}\n\n#define param_scanner param->scanner\n%}\n\n%pure-parser\n%lex-param      { struct scanner *param_scanner }\n%parse-param    { struct parser_param *param }\n\n%token\n        END_OF_FILE     0\n        ERROR_TOK       255\n        XKB_KEYMAP      1\n        XKB_KEYCODES    2\n        XKB_TYPES       3\n        XKB_SYMBOLS     4\n        XKB_COMPATMAP   5\n        XKB_GEOMETRY    6\n        XKB_SEMANTICS   7\n        XKB_LAYOUT      8\n        INCLUDE         10\n        OVERRIDE        11\n        AUGMENT         12\n        REPLACE         13\n        ALTERNATE       14\n        VIRTUAL_MODS    20\n        TYPE            21\n        INTERPRET       22\n        ACTION_TOK      23\n        KEY             24\n        ALIAS           25\n        GROUP           26\n        MODIFIER_MAP    27\n        INDICATOR       28\n        SHAPE           29\n        KEYS            30\n        ROW             31\n        SECTION         32\n        OVERLAY         33\n        TEXT            34\n        OUTLINE         35\n        SOLID           36\n        LOGO            37\n        VIRTUAL         38\n        EQUALS          40\n        PLUS            41\n        MINUS           42\n        DIVIDE          43\n        TIMES           44\n        OBRACE          45\n        CBRACE          46\n        OPAREN          47\n        CPAREN          48\n        OBRACKET        49\n        CBRACKET        50\n        DOT             51\n        COMMA           52\n        SEMI            53\n        EXCLAM          54\n        INVERT          55\n        STRING          60\n        INTEGER         61\n        FLOAT           62\n        IDENT           63\n        KEYNAME         64\n        PARTIAL         70\n        DEFAULT         71\n        HIDDEN          72\n        ALPHANUMERIC_KEYS       73\n        MODIFIER_KEYS           74\n        KEYPAD_KEYS             75\n        FUNCTION_KEYS           76\n        ALTERNATE_GROUP         77\n\n%right  EQUALS\n%left   PLUS MINUS\n%left   TIMES DIVIDE\n%left   EXCLAM INVERT\n%left   OPAREN\n\n%start  XkbFile\n\n%union  {\n        int              ival;\n        int64_t          num;\n        enum xkb_file_type file_type;\n        char            *str;\n        xkb_atom_t      atom;\n        enum merge_mode merge;\n        enum xkb_map_flags mapFlags;\n        xkb_keysym_t    keysym;\n        ParseCommon     *any;\n        ExprDef         *expr;\n        VarDef          *var;\n        VModDef         *vmod;\n        InterpDef       *interp;\n        KeyTypeDef      *keyType;\n        SymbolsDef      *syms;\n        ModMapDef       *modMask;\n        GroupCompatDef  *groupCompat;\n        LedMapDef       *ledMap;\n        LedNameDef      *ledName;\n        KeycodeDef      *keyCode;\n        KeyAliasDef     *keyAlias;\n        void            *geom;\n        XkbFile         *file;\n}\n\n%type <num>     INTEGER FLOAT\n%type <str>     IDENT STRING\n%type <atom>    KEYNAME\n%type <num>     KeyCode\n%type <ival>    Number Integer Float SignedNumber DoodadType\n%type <merge>   MergeMode OptMergeMode\n%type <file_type> XkbCompositeType FileType\n%type <mapFlags> Flag Flags OptFlags\n%type <str>     MapName OptMapName\n%type <atom>    FieldSpec Ident Element String\n%type <keysym>  KeySym\n%type <any>     DeclList Decl\n%type <expr>    OptExprList ExprList Expr Term Lhs Terminal ArrayInit KeySyms\n%type <expr>    OptKeySymList KeySymList Action ActionList Coord CoordList\n%type <var>     VarDecl VarDeclList SymbolsBody SymbolsVarDecl\n%type <vmod>    VModDecl VModDefList VModDef\n%type <interp>  InterpretDecl InterpretMatch\n%type <keyType> KeyTypeDecl\n%type <syms>    SymbolsDecl\n%type <modMask> ModMapDecl\n%type <groupCompat> GroupCompatDecl\n%type <ledMap>  LedMapDecl\n%type <ledName> LedNameDecl\n%type <keyCode> KeyNameDecl\n%type <keyAlias> KeyAliasDecl\n%type <geom>    ShapeDecl SectionDecl SectionBody SectionBodyItem RowBody RowBodyItem\n%type <geom>    Keys Key OverlayDecl OverlayKeyList OverlayKey OutlineList OutlineInList\n%type <geom>    DoodadDecl\n%type <file>    XkbFile XkbMapConfigList XkbMapConfig\n%type <file>    XkbCompositeMap\n\n%destructor { FreeStmt((ParseCommon *) $$); }\n    <any> <expr> <var> <vmod> <interp> <keyType> <syms> <modMask> <groupCompat>\n    <ledMap> <ledName> <keyCode> <keyAlias>\n/* The destructor also runs on the start symbol when the parser *succeeds*.\n * The `if` here catches this case. */\n%destructor { if (!param->rtrn) FreeXkbFile($$); } <file>\n%destructor { free($$); } <str>\n\n%%\n\n/*\n * An actual file may contain more than one map. However, if we do things\n * in the normal yacc way, i.e. aggregate all of the maps into a list and\n * let the caller find the map it wants, we end up scanning and parsing a\n * lot of unneeded maps (in the end we always just need one).\n * Instead of doing that, we make yyparse return one map at a time, and\n * then call it repeatedly until we find the map we need. Once we find it,\n * we don't need to parse everything that follows in the file.\n * This does mean that if we e.g. always use the first map, the file may\n * contain complete garbage after that. But it's worth it.\n */\n\nXkbFile         :       XkbCompositeMap\n                        { $$ = param->rtrn = $1; param->more_maps = true; }\n                |       XkbMapConfig\n                        { $$ = param->rtrn = $1; param->more_maps = true; YYACCEPT; }\n                |       END_OF_FILE\n                        { $$ = param->rtrn = NULL; param->more_maps = false; }\n                ;\n\nXkbCompositeMap :       OptFlags XkbCompositeType OptMapName OBRACE\n                            XkbMapConfigList\n                        CBRACE SEMI\n                        { $$ = XkbFileCreate($2, $3, (ParseCommon *) $5, $1); }\n                ;\n\nXkbCompositeType:       XKB_KEYMAP      { $$ = FILE_TYPE_KEYMAP; }\n                |       XKB_SEMANTICS   { $$ = FILE_TYPE_KEYMAP; }\n                |       XKB_LAYOUT      { $$ = FILE_TYPE_KEYMAP; }\n                ;\n\nXkbMapConfigList :      XkbMapConfigList XkbMapConfig\n                        {\n                            if (!$2)\n                                $$ = $1;\n                            else\n                                $$ = (XkbFile *) AppendStmt((ParseCommon *) $1,\n                                                            (ParseCommon *) $2);\n                        }\n                |       XkbMapConfig\n                        { $$ = $1; }\n                ;\n\nXkbMapConfig    :       OptFlags FileType OptMapName OBRACE\n                            DeclList\n                        CBRACE SEMI\n                        {\n                            if ($2 == FILE_TYPE_GEOMETRY) {\n                                free($3);\n                                FreeStmt($5);\n                                $$ = NULL;\n                            }\n                            else {\n                                $$ = XkbFileCreate($2, $3, $5, $1);\n                            }\n                        }\n                ;\n\nFileType        :       XKB_KEYCODES            { $$ = FILE_TYPE_KEYCODES; }\n                |       XKB_TYPES               { $$ = FILE_TYPE_TYPES; }\n                |       XKB_COMPATMAP           { $$ = FILE_TYPE_COMPAT; }\n                |       XKB_SYMBOLS             { $$ = FILE_TYPE_SYMBOLS; }\n                |       XKB_GEOMETRY            { $$ = FILE_TYPE_GEOMETRY; }\n                ;\n\nOptFlags        :       Flags                   { $$ = $1; }\n                |                               { $$ = 0; }\n                ;\n\nFlags           :       Flags Flag              { $$ = ($1 | $2); }\n                |       Flag                    { $$ = $1; }\n                ;\n\nFlag            :       PARTIAL                 { $$ = MAP_IS_PARTIAL; }\n                |       DEFAULT                 { $$ = MAP_IS_DEFAULT; }\n                |       HIDDEN                  { $$ = MAP_IS_HIDDEN; }\n                |       ALPHANUMERIC_KEYS       { $$ = MAP_HAS_ALPHANUMERIC; }\n                |       MODIFIER_KEYS           { $$ = MAP_HAS_MODIFIER; }\n                |       KEYPAD_KEYS             { $$ = MAP_HAS_KEYPAD; }\n                |       FUNCTION_KEYS           { $$ = MAP_HAS_FN; }\n                |       ALTERNATE_GROUP         { $$ = MAP_IS_ALTGR; }\n                ;\n\nDeclList        :       DeclList Decl\n                        { $$ = AppendStmt($1, $2); }\n                |       { $$ = NULL; }\n                ;\n\nDecl            :       OptMergeMode VarDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode VModDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode InterpretDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode KeyNameDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode KeyAliasDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode KeyTypeDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode SymbolsDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode ModMapDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode GroupCompatDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode LedMapDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode LedNameDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode ShapeDecl          { $$ = NULL; }\n                |       OptMergeMode SectionDecl        { $$ = NULL; }\n                |       OptMergeMode DoodadDecl         { $$ = NULL; }\n                |       MergeMode STRING\n                        {\n                            $$ = (ParseCommon *) IncludeCreate(param->ctx, $2, $1);\n                            free($2);\n                        }\n                ;\n\nVarDecl         :       Lhs EQUALS Expr SEMI\n                        { $$ = VarCreate($1, $3); }\n                |       Ident SEMI\n                        { $$ = BoolVarCreate($1, true); }\n                |       EXCLAM Ident SEMI\n                        { $$ = BoolVarCreate($2, false); }\n                ;\n\nKeyNameDecl     :       KEYNAME EQUALS KeyCode SEMI\n                        { $$ = KeycodeCreate($1, $3); }\n                ;\n\nKeyAliasDecl    :       ALIAS KEYNAME EQUALS KEYNAME SEMI\n                        { $$ = KeyAliasCreate($2, $4); }\n                ;\n\nVModDecl        :       VIRTUAL_MODS VModDefList SEMI\n                        { $$ = $2; }\n                ;\n\nVModDefList     :       VModDefList COMMA VModDef\n                        { $$ = (VModDef *) AppendStmt((ParseCommon *) $1,\n                                                      (ParseCommon *) $3); }\n                |       VModDef\n                        { $$ = $1; }\n                ;\n\nVModDef         :       Ident\n                        { $$ = VModCreate($1, NULL); }\n                |       Ident EQUALS Expr\n                        { $$ = VModCreate($1, $3); }\n                ;\n\nInterpretDecl   :       INTERPRET InterpretMatch OBRACE\n                            VarDeclList\n                        CBRACE SEMI\n                        { $2->def = $4; $$ = $2; }\n                ;\n\nInterpretMatch  :       KeySym PLUS Expr\n                        { $$ = InterpCreate($1, $3); }\n                |       KeySym\n                        { $$ = InterpCreate($1, NULL); }\n                ;\n\nVarDeclList     :       VarDeclList VarDecl\n                        { $$ = (VarDef *) AppendStmt((ParseCommon *) $1,\n                                                     (ParseCommon *) $2); }\n                |       VarDecl\n                        { $$ = $1; }\n                ;\n\nKeyTypeDecl     :       TYPE String OBRACE\n                            VarDeclList\n                        CBRACE SEMI\n                        { $$ = KeyTypeCreate($2, $4); }\n                ;\n\nSymbolsDecl     :       KEY KEYNAME OBRACE\n                            SymbolsBody\n                        CBRACE SEMI\n                        { $$ = SymbolsCreate($2, $4); }\n                ;\n\nSymbolsBody     :       SymbolsBody COMMA SymbolsVarDecl\n                        { $$ = (VarDef *) AppendStmt((ParseCommon *) $1,\n                                                     (ParseCommon *) $3); }\n                |       SymbolsVarDecl\n                        { $$ = $1; }\n                |       { $$ = NULL; }\n                ;\n\nSymbolsVarDecl  :       Lhs EQUALS Expr         { $$ = VarCreate($1, $3); }\n                |       Lhs EQUALS ArrayInit    { $$ = VarCreate($1, $3); }\n                |       Ident                   { $$ = BoolVarCreate($1, true); }\n                |       EXCLAM Ident            { $$ = BoolVarCreate($2, false); }\n                |       ArrayInit               { $$ = VarCreate(NULL, $1); }\n                ;\n\nArrayInit       :       OBRACKET OptKeySymList CBRACKET\n                        { $$ = $2; }\n                |       OBRACKET ActionList CBRACKET\n                        { $$ = ExprCreateUnary(EXPR_ACTION_LIST, EXPR_TYPE_ACTION, $2); }\n                ;\n\nGroupCompatDecl :       GROUP Integer EQUALS Expr SEMI\n                        { $$ = GroupCompatCreate($2, $4); }\n                ;\n\nModMapDecl      :       MODIFIER_MAP Ident OBRACE ExprList CBRACE SEMI\n                        { $$ = ModMapCreate($2, $4); }\n                ;\n\nLedMapDecl:             INDICATOR String OBRACE VarDeclList CBRACE SEMI\n                        { $$ = LedMapCreate($2, $4); }\n                ;\n\nLedNameDecl:            INDICATOR Integer EQUALS Expr SEMI\n                        { $$ = LedNameCreate($2, $4, false); }\n                |       VIRTUAL INDICATOR Integer EQUALS Expr SEMI\n                        { $$ = LedNameCreate($3, $5, true); }\n                ;\n\nShapeDecl       :       SHAPE String OBRACE OutlineList CBRACE SEMI\n                        { $$ = NULL; }\n                |       SHAPE String OBRACE CoordList CBRACE SEMI\n                        { (void) $4; $$ = NULL; }\n                ;\n\nSectionDecl     :       SECTION String OBRACE SectionBody CBRACE SEMI\n                        { $$ = NULL; }\n                ;\n\nSectionBody     :       SectionBody SectionBodyItem     { $$ = NULL;}\n                |       SectionBodyItem                 { $$ = NULL; }\n                ;\n\nSectionBodyItem :       ROW OBRACE RowBody CBRACE SEMI\n                        { $$ = NULL; }\n                |       VarDecl\n                        { FreeStmt((ParseCommon *) $1); $$ = NULL; }\n                |       DoodadDecl\n                        { $$ = NULL; }\n                |       LedMapDecl\n                        { FreeStmt((ParseCommon *) $1); $$ = NULL; }\n                |       OverlayDecl\n                        { $$ = NULL; }\n                ;\n\nRowBody         :       RowBody RowBodyItem     { $$ = NULL;}\n                |       RowBodyItem             { $$ = NULL; }\n                ;\n\nRowBodyItem     :       KEYS OBRACE Keys CBRACE SEMI { $$ = NULL; }\n                |       VarDecl\n                        { FreeStmt((ParseCommon *) $1); $$ = NULL; }\n                ;\n\nKeys            :       Keys COMMA Key          { $$ = NULL; }\n                |       Key                     { $$ = NULL; }\n                ;\n\nKey             :       KEYNAME\n                        { $$ = NULL; }\n                |       OBRACE ExprList CBRACE\n                        { FreeStmt((ParseCommon *) $2); $$ = NULL; }\n                ;\n\nOverlayDecl     :       OVERLAY String OBRACE OverlayKeyList CBRACE SEMI\n                        { $$ = NULL; }\n                ;\n\nOverlayKeyList  :       OverlayKeyList COMMA OverlayKey { $$ = NULL; }\n                |       OverlayKey                      { $$ = NULL; }\n                ;\n\nOverlayKey      :       KEYNAME EQUALS KEYNAME          { $$ = NULL; }\n                ;\n\nOutlineList     :       OutlineList COMMA OutlineInList\n                        { $$ = NULL;}\n                |       OutlineInList\n                        { $$ = NULL; }\n                ;\n\nOutlineInList   :       OBRACE CoordList CBRACE\n                        { (void) $2; $$ = NULL; }\n                |       Ident EQUALS OBRACE CoordList CBRACE\n                        { (void) $4; $$ = NULL; }\n                |       Ident EQUALS Expr\n                        { FreeStmt((ParseCommon *) $3); $$ = NULL; }\n                ;\n\nCoordList       :       CoordList COMMA Coord\n                        { (void) $1; (void) $3; $$ = NULL; }\n                |       Coord\n                        { (void) $1; $$ = NULL; }\n                ;\n\nCoord           :       OBRACKET SignedNumber COMMA SignedNumber CBRACKET\n                        { $$ = NULL; }\n                ;\n\nDoodadDecl      :       DoodadType String OBRACE VarDeclList CBRACE SEMI\n                        { FreeStmt((ParseCommon *) $4); $$ = NULL; }\n                ;\n\nDoodadType      :       TEXT    { $$ = 0; }\n                |       OUTLINE { $$ = 0; }\n                |       SOLID   { $$ = 0; }\n                |       LOGO    { $$ = 0; }\n                ;\n\nFieldSpec       :       Ident   { $$ = $1; }\n                |       Element { $$ = $1; }\n                ;\n\nElement         :       ACTION_TOK\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"action\"); }\n                |       INTERPRET\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"interpret\"); }\n                |       TYPE\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"type\"); }\n                |       KEY\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"key\"); }\n                |       GROUP\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"group\"); }\n                |       MODIFIER_MAP\n                        {$$ = xkb_atom_intern_literal(param->ctx, \"modifier_map\");}\n                |       INDICATOR\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"indicator\"); }\n                |       SHAPE\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"shape\"); }\n                |       ROW\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"row\"); }\n                |       SECTION\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"section\"); }\n                |       TEXT\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"text\"); }\n                ;\n\nOptMergeMode    :       MergeMode       { $$ = $1; }\n                |                       { $$ = MERGE_DEFAULT; }\n                ;\n\nMergeMode       :       INCLUDE         { $$ = MERGE_DEFAULT; }\n                |       AUGMENT         { $$ = MERGE_AUGMENT; }\n                |       OVERRIDE        { $$ = MERGE_OVERRIDE; }\n                |       REPLACE         { $$ = MERGE_REPLACE; }\n                |       ALTERNATE\n                {\n                    /*\n                     * This used to be MERGE_ALT_FORM. This functionality was\n                     * unused and has been removed.\n                     */\n                    $$ = MERGE_DEFAULT;\n                }\n                ;\n\nOptExprList     :       ExprList        { $$ = $1; }\n                |                       { $$ = NULL; }\n                ;\n\nExprList        :       ExprList COMMA Expr\n                        { $$ = (ExprDef *) AppendStmt((ParseCommon *) $1,\n                                                      (ParseCommon *) $3); }\n                |       Expr\n                        { $$ = $1; }\n                ;\n\nExpr            :       Expr DIVIDE Expr\n                        { $$ = ExprCreateBinary(EXPR_DIVIDE, $1, $3); }\n                |       Expr PLUS Expr\n                        { $$ = ExprCreateBinary(EXPR_ADD, $1, $3); }\n                |       Expr MINUS Expr\n                        { $$ = ExprCreateBinary(EXPR_SUBTRACT, $1, $3); }\n                |       Expr TIMES Expr\n                        { $$ = ExprCreateBinary(EXPR_MULTIPLY, $1, $3); }\n                |       Lhs EQUALS Expr\n                        { $$ = ExprCreateBinary(EXPR_ASSIGN, $1, $3); }\n                |       Term\n                        { $$ = $1; }\n                ;\n\nTerm            :       MINUS Term\n                        { $$ = ExprCreateUnary(EXPR_NEGATE, $2->expr.value_type, $2); }\n                |       PLUS Term\n                        { $$ = ExprCreateUnary(EXPR_UNARY_PLUS, $2->expr.value_type, $2); }\n                |       EXCLAM Term\n                        { $$ = ExprCreateUnary(EXPR_NOT, EXPR_TYPE_BOOLEAN, $2); }\n                |       INVERT Term\n                        { $$ = ExprCreateUnary(EXPR_INVERT, $2->expr.value_type, $2); }\n                |       Lhs\n                        { $$ = $1;  }\n                |       FieldSpec OPAREN OptExprList CPAREN %prec OPAREN\n                        { $$ = ExprCreateAction($1, $3); }\n                |       Terminal\n                        { $$ = $1;  }\n                |       OPAREN Expr CPAREN\n                        { $$ = $2;  }\n                ;\n\nActionList      :       ActionList COMMA Action\n                        { $$ = (ExprDef *) AppendStmt((ParseCommon *) $1,\n                                                      (ParseCommon *) $3); }\n                |       Action\n                        { $$ = $1; }\n                ;\n\nAction          :       FieldSpec OPAREN OptExprList CPAREN\n                        { $$ = ExprCreateAction($1, $3); }\n                ;\n\nLhs             :       FieldSpec\n                        { $$ = ExprCreateIdent($1); }\n                |       FieldSpec DOT FieldSpec\n                        { $$ = ExprCreateFieldRef($1, $3); }\n                |       FieldSpec OBRACKET Expr CBRACKET\n                        { $$ = ExprCreateArrayRef(XKB_ATOM_NONE, $1, $3); }\n                |       FieldSpec DOT FieldSpec OBRACKET Expr CBRACKET\n                        { $$ = ExprCreateArrayRef($1, $3, $5); }\n                ;\n\nTerminal        :       String\n                        { $$ = ExprCreateString($1); }\n                |       Integer\n                        { $$ = ExprCreateInteger($1); }\n                |       Float\n                        { $$ = ExprCreateFloat(/* Discard $1 */); }\n                |       KEYNAME\n                        { $$ = ExprCreateKeyName($1); }\n                ;\n\nOptKeySymList   :       KeySymList      { $$ = $1; }\n                |                       { $$ = NULL; }\n                ;\n\nKeySymList      :       KeySymList COMMA KeySym\n                        { $$ = ExprAppendKeysymList($1, $3); }\n                |       KeySymList COMMA KeySyms\n                        { $$ = ExprAppendMultiKeysymList($1, $3); }\n                |       KeySym\n                        { $$ = ExprCreateKeysymList($1); }\n                |       KeySyms\n                        { $$ = ExprCreateMultiKeysymList($1); }\n                ;\n\nKeySyms         :       OBRACE KeySymList CBRACE\n                        { $$ = $2; }\n                ;\n\nKeySym          :       IDENT\n                        {\n                            if (!resolve_keysym($1, &$$))\n                                parser_warn(param, \"unrecognized keysym \\\"%s\\\"\", $1);\n                            free($1);\n                        }\n                |       SECTION { $$ = XKB_KEY_section; }\n                |       Integer\n                        {\n                            if ($1 < 0) {\n                                parser_warn(param, \"unrecognized keysym \\\"%d\\\"\", $1);\n                                $$ = XKB_KEY_NoSymbol;\n                            }\n                            else if ($1 < 10) {      /* XKB_KEY_0 .. XKB_KEY_9 */\n                                $$ = XKB_KEY_0 + (xkb_keysym_t) $1;\n                            }\n                            else {\n                                char buf[17];\n                                snprintf(buf, sizeof(buf), \"0x%x\", $1);\n                                if (!resolve_keysym(buf, &$$)) {\n                                    parser_warn(param, \"unrecognized keysym \\\"%s\\\"\", buf);\n                                    $$ = XKB_KEY_NoSymbol;\n                                }\n                            }\n                        }\n                ;\n\nSignedNumber    :       MINUS Number    { $$ = -$2; }\n                |       Number          { $$ = $1; }\n                ;\n\nNumber          :       FLOAT   { $$ = $1; }\n                |       INTEGER { $$ = $1; }\n                ;\n\nFloat           :       FLOAT   { $$ = 0; }\n                ;\n\nInteger         :       INTEGER { $$ = $1; }\n                ;\n\nKeyCode         :       INTEGER { $$ = $1; }\n                ;\n\nIdent           :       IDENT   { $$ = xkb_atom_steal(param->ctx, $1); }\n                |       DEFAULT { $$ = xkb_atom_intern_literal(param->ctx, \"default\"); }\n                ;\n\nString          :       STRING  { $$ = xkb_atom_steal(param->ctx, $1); }\n                ;\n\nOptMapName      :       MapName { $$ = $1; }\n                |               { $$ = NULL; }\n                ;\n\nMapName         :       STRING  { $$ = $1; }\n                ;\n\n%%\n\nXkbFile *\nparse(struct xkb_context *ctx, struct scanner *scanner, const char *map)\n{\n    int ret;\n    XkbFile *first = NULL;\n    struct parser_param param = {\n        .scanner = scanner,\n        .ctx = ctx,\n        .rtrn = NULL,\n    };\n\n    /*\n     * If we got a specific map, we look for it exclusively and return\n     * immediately upon finding it. Otherwise, we need to get the\n     * default map. If we find a map marked as default, we return it\n     * immediately. If there are no maps marked as default, we return\n     * the first map in the file.\n     */\n\n    while ((ret = yyparse(&param)) == 0 && param.more_maps) {\n        if (map) {\n            if (streq_not_null(map, param.rtrn->name))\n                return param.rtrn;\n            else\n                FreeXkbFile(param.rtrn);\n        }\n        else {\n            if (param.rtrn->flags & MAP_IS_DEFAULT) {\n                FreeXkbFile(first);\n                return param.rtrn;\n            }\n            else if (!first) {\n                first = param.rtrn;\n            }\n            else {\n                FreeXkbFile(param.rtrn);\n            }\n        }\n        param.rtrn = NULL;\n    }\n\n    if (ret != 0) {\n        FreeXkbFile(first);\n        return NULL;\n    }\n\n    if (first)\n        log_vrb(ctx, 5,\n                \"No map in include statement, but \\\"%s\\\" contains several; \"\n                \"Using first defined map, \\\"%s\\\"\\n\",\n                scanner->file_name, first->name);\n\n    return first;\n}\n"], "filenames": ["src/xkbcomp/ast-build.c", "src/xkbcomp/ast-build.h", "src/xkbcomp/ast.h", "src/xkbcomp/parser.y"], "buggy_code_start_loc": [108, 37, 97, 594], "buggy_code_end_loc": [785, 37, 190, 691], "fixing_code_start_loc": [109, 38, 98, 594], "fixing_code_end_loc": [794, 41, 198, 691], "type": "CWE-476", "message": "Unchecked NULL pointer usage in xkbcommon before 0.8.1 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file, because geometry tokens were desupported incorrectly.", "other": {"cve": {"id": "CVE-2018-15854", "sourceIdentifier": "cve@mitre.org", "published": "2018-08-25T21:29:01.593", "lastModified": "2019-08-06T17:15:24.947", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Unchecked NULL pointer usage in xkbcommon before 0.8.1 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file, because geometry tokens were desupported incorrectly."}, {"lang": "es", "value": "El uso de un puntero NULL no verificado en xkbcommon en versiones anteriores a la 0.8.1 podr\u00eda ser aprovechado por atacantes locales para provocar el cierre inesperado (desreferencia de puntero NULL) del analizador xkbcommon proporcionando un archivo keymap manipulado, debido a que los tokens de geometr\u00eda dejaron de ser soportados incorrectamente."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xkbcommon_project:xkbcommon:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.8.1", "matchCriteriaId": "2F9BAF72-405A-41EA-AA6D-509128B3E4AD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2019:2079", "source": "cve@mitre.org"}, {"url": "https://github.com/xkbcommon/libxkbcommon/commit/e3cacae7b1bfda0d839c280494f23284a1187adf", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.freedesktop.org/archives/wayland-devel/2018-August/039232.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201810-05", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3786-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3786-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/xkbcommon/libxkbcommon/commit/e3cacae7b1bfda0d839c280494f23284a1187adf"}}