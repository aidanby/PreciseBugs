{"buggy_code": ["/*\n *  DBD::mysql - DBI driver for the mysql database\n *\n *  Copyright (c) 2004-2014 Patrick Galbraith\n *  Copyright (c) 2013-2014 Michiel Beijen \n *  Copyright (c) 2004-2007 Alexey Stroganov \n *  Copyright (c) 2003-2005  Rudolf Lippan\n *  Copyright (c) 1997-2003  Jochen Wiedmann\n *\n *  You may distribute this under the terms of either the GNU General Public\n *  License or the Artistic License, as specified in the Perl README file.\n */\n\n\n#ifdef WIN32\n#include \"windows.h\"\n#include \"winsock.h\"\n#endif\n\n#include \"dbdimp.h\"\n\n#if defined(WIN32)  &&  defined(WORD)\n#undef WORD\ntypedef short WORD;\n#endif\n\n#if MYSQL_ASYNC\n#  include <poll.h>\n#  define ASYNC_CHECK_RETURN(h, value)\\\n    if(imp_dbh->async_query_in_flight) {\\\n        do_error(h, 2000, \"Calling a synchronous function on an asynchronous handle\", \"HY000\");\\\n        return (value);\\\n    }\n#else\n#  define ASYNC_CHECK_RETURN(h, value)\n#endif\n\nstatic int parse_number(char *string, STRLEN len, char **end);\n\nDBISTATE_DECLARE;\n\ntypedef struct sql_type_info_s\n{\n    const char *type_name;\n    int data_type;\n    int column_size;\n    const char *literal_prefix;\n    const char *literal_suffix;\n    const char *create_params;\n    int nullable;\n    int case_sensitive;\n    int searchable;\n    int unsigned_attribute;\n    int fixed_prec_scale;\n    int auto_unique_value;\n    const char *local_type_name;\n    int minimum_scale;\n    int maximum_scale;\n    int num_prec_radix;\n    int sql_datatype;\n    int sql_datetime_sub;\n    int interval_precision;\n    int native_type;\n    int is_num;\n} sql_type_info_t;\n\n\n/*\n\n  This function manually counts the number of placeholders in an SQL statement,\n  used for emulated prepare statements < 4.1.3\n\n*/\nstatic int\ncount_params(imp_xxh_t *imp_xxh, pTHX_ char *statement, bool bind_comment_placeholders)\n{\n  bool comment_end= false;\n  char* ptr= statement;\n  int num_params= 0;\n  int comment_length= 0;\n  char c;\n\n  if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \">count_params statement %s\\n\", statement);\n\n  while ( (c = *ptr++) )\n  {\n    switch (c) {\n      /* so, this is a -- comment, so let's burn up characters */\n    case '-':\n      {\n          if (bind_comment_placeholders)\n          {\n              c = *ptr++;\n              break;\n          }\n          else\n          {\n              comment_length= 1;\n              /* let's see if the next one is a dash */\n              c = *ptr++;\n\n              if  (c == '-') {\n                  /* if two dashes, ignore everything until newline */\n                  while ((c = *ptr))\n                  {\n                      if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\n                          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%c\\n\", c);\n                      ptr++;\n                      comment_length++;\n                      if (c == '\\n')\n                      {\n                          comment_end= true;\n                          break;\n                      }\n                  }\n                  /*\n                    if not comment_end, the comment never ended and we need to iterate\n                    back to the beginning of where we started and let the database \n                    handle whatever is in the statement\n                */\n                  if (! comment_end)\n                      ptr-= comment_length;\n              }\n              /* otherwise, only one dash/hyphen, backtrack by one */\n              else\n                  ptr--;\n              break;\n          }\n      }\n    /* c-type comments */\n    case '/':\n      {\n          if (bind_comment_placeholders)\n          {\n              c = *ptr++;\n              break;\n          }\n          else\n          {\n              c = *ptr++;\n              /* let's check if the next one is an asterisk */\n              if  (c == '*')\n              {\n                  comment_length= 0;\n                  comment_end= false;\n                  /* ignore everything until closing comment */\n                  while ((c= *ptr))\n                  {\n                      ptr++;\n                      comment_length++;\n\n                      if (c == '*')\n                      {\n                          c = *ptr++;\n                          /* alas, end of comment */\n                          if (c == '/')\n                          {\n                              comment_end= true;\n                              break;\n                          }\n                          /*\n                            nope, just an asterisk, not so fast, not\n                            end of comment, go back one\n                        */\n                          else\n                              ptr--;\n                      }\n                  }\n                  /*\n                    if the end of the comment was never found, we have\n                    to backtrack to whereever we first started skipping\n                    over the possible comment.\n                    This means we will pass the statement to the database\n                    to see its own fate and issue the error\n                */\n                  if (!comment_end)\n                      ptr -= comment_length;\n              }\n              else\n                  ptr--;\n              break;\n          }\n      }\n    case '`':\n    case '\"':\n    case '\\'':\n      /* Skip string */\n      {\n        char end_token = c;\n        while ((c = *ptr)  &&  c != end_token)\n        {\n          if (c == '\\\\')\n            if (! *(++ptr))\n              continue;\n\n          ++ptr;\n        }\n        if (c)\n          ++ptr;\n        break;\n      }\n\n    case '?':\n      ++num_params;\n      break;\n\n    default:\n      break;\n    }\n  }\n  return num_params;\n}\n\n/*\n  allocate memory in statement handle per number of placeholders\n*/\nstatic imp_sth_ph_t *alloc_param(int num_params)\n{\n  imp_sth_ph_t *params;\n\n  if (num_params)\n    Newz(908, params, (unsigned int) num_params, imp_sth_ph_t);\n  else\n    params= NULL;\n\n  return params;\n}\n\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n/*\n  allocate memory in MYSQL_BIND bind structure per\n  number of placeholders\n*/\nstatic MYSQL_BIND *alloc_bind(int num_params)\n{\n  MYSQL_BIND *bind;\n\n  if (num_params)\n    Newz(908, bind, (unsigned int) num_params, MYSQL_BIND);\n  else\n    bind= NULL;\n\n  return bind;\n}\n\n/*\n  allocate memory in fbind imp_sth_phb_t structure per\n  number of placeholders\n*/\nstatic imp_sth_phb_t *alloc_fbind(int num_params)\n{\n  imp_sth_phb_t *fbind;\n\n  if (num_params)\n    Newz(908, fbind, (unsigned int) num_params, imp_sth_phb_t);\n  else\n    fbind= NULL;\n\n  return fbind;\n}\n\n/*\n  alloc memory for imp_sth_fbh_t fbuffer per number of fields\n*/\nstatic imp_sth_fbh_t *alloc_fbuffer(int num_fields)\n{\n  imp_sth_fbh_t *fbh;\n\n  if (num_fields)\n    Newz(908, fbh, (unsigned int) num_fields, imp_sth_fbh_t);\n  else\n    fbh= NULL;\n\n  return fbh;\n}\n\n/*\n  free MYSQL_BIND bind struct\n*/\nstatic void free_bind(MYSQL_BIND *bind)\n{\n  if (bind)\n    Safefree(bind);\n}\n\n/*\n   free imp_sth_phb_t fbind structure\n*/\nstatic void free_fbind(imp_sth_phb_t *fbind)\n{\n  if (fbind)\n    Safefree(fbind);\n}\n\n/*\n  free imp_sth_fbh_t fbh structure\n*/\nstatic void free_fbuffer(imp_sth_fbh_t *fbh)\n{\n  if (fbh)\n    Safefree(fbh);\n}\n\n#endif\n\n/*\n  free statement param structure per num_params\n*/\nstatic void\nfree_param(pTHX_ imp_sth_ph_t *params, int num_params)\n{\n  if (params)\n  {\n    int i;\n    for (i= 0;  i < num_params;  i++)\n    {\n      imp_sth_ph_t *ph= params+i;\n      if (ph->value)\n      {\n        (void) SvREFCNT_dec(ph->value);\n        ph->value= NULL;\n      }\n    }\n    Safefree(params);\n  }\n}\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n/* \n  Convert a MySQL type to a type that perl can handle\n\n  NOTE: In the future we may want to return a struct with a lot of\n  information for each type\n*/\n\nstatic enum enum_field_types mysql_to_perl_type(enum enum_field_types type)\n{\n  static enum enum_field_types enum_type;\n\n  switch (type) {\n  case MYSQL_TYPE_DOUBLE:\n  case MYSQL_TYPE_FLOAT:\n    enum_type= MYSQL_TYPE_DOUBLE;\n    break;\n\n  case MYSQL_TYPE_SHORT:\n  case MYSQL_TYPE_TINY:\n  case MYSQL_TYPE_LONG:\n  case MYSQL_TYPE_INT24:\n  case MYSQL_TYPE_YEAR:\n#if MYSQL_VERSION_ID > NEW_DATATYPE_VERSION\n  case MYSQL_TYPE_BIT:\n#endif\n    enum_type= MYSQL_TYPE_LONG;\n    break;\n\n#if MYSQL_VERSION_ID > NEW_DATATYPE_VERSION\n  case MYSQL_TYPE_NEWDECIMAL:\n#endif\n  case MYSQL_TYPE_DECIMAL:\n    enum_type= MYSQL_TYPE_DECIMAL;\n    break;\n\n  case MYSQL_TYPE_LONGLONG:\t\t\t/* No longlong in perl */\n  case MYSQL_TYPE_DATE:\n  case MYSQL_TYPE_TIME:\n  case MYSQL_TYPE_DATETIME:\n  case MYSQL_TYPE_NEWDATE:\n  case MYSQL_TYPE_TIMESTAMP:\n  case MYSQL_TYPE_VAR_STRING:\n#if MYSQL_VERSION_ID > NEW_DATATYPE_VERSION\n  case MYSQL_TYPE_VARCHAR:\n#endif\n  case MYSQL_TYPE_STRING:\n    enum_type= MYSQL_TYPE_STRING;\n    break;\n\n#if MYSQL_VERSION_ID > GEO_DATATYPE_VERSION\n  case MYSQL_TYPE_GEOMETRY:\n#endif\n  case MYSQL_TYPE_BLOB:\n  case MYSQL_TYPE_TINY_BLOB:\n    enum_type= MYSQL_TYPE_BLOB;\n    break;\n\n  default:\n    enum_type= MYSQL_TYPE_STRING;    /* MySQL can handle all types as strings */\n  }\n  return(enum_type);\n}\n#endif\n\n#if defined(DBD_MYSQL_EMBEDDED)\n/* \n  count embedded options\n*/\nint count_embedded_options(char *st)\n{\n  int rc;\n  char c;\n  char *ptr;\n\n  ptr= st;\n  rc= 0;\n\n  if (st)\n  {\n    while ((c= *ptr++))\n    {\n      if (c == ',')\n        rc++;\n    }\n    rc++;\n  }\n\n  return rc;\n}\n\n/*\n  Free embbedded options\n*/\nint free_embedded_options(char ** options_list, int options_count)\n{\n  int i;\n\n  for (i= 0; i < options_count; i++)\n  {\n    if (options_list[i])\n      free(options_list[i]);\n  }\n  free(options_list);\n\n  return 1;\n}\n\n/*\n Print out embbedded option settings\n\n*/\nint print_embedded_options(char ** options_list, int options_count)\n{\n  int i;\n\n  for (i=0; i<options_count; i++)\n  {\n    if (options_list[i])\n        PerlIO_printf(DBILOGFP,\n                      \"Embedded server, parameter[%d]=%s\\n\",\n                      i, options_list[i]);\n  }\n  return 1;\n}\n\n/*\n\n*/\nchar **fill_out_embedded_options(char *options,\n                                 int options_type,\n                                 int slen, int cnt)\n{\n  int  ind, len;\n  char c;\n  char *ptr;\n  char **options_list= NULL;\n\n  if (!(options_list= (char **) calloc(cnt, sizeof(char *))))\n  {\n    PerlIO_printf(DBILOGFP,\n                  \"Initialize embedded server. Out of memory \\n\");\n    return NULL;\n  }\n\n  ptr= options;\n  ind= 0;\n\n  if (options_type == 0)\n  {\n    /* server_groups list NULL terminated */\n    options_list[cnt]= (char *) NULL;\n  }\n\n  if (options_type == 1)\n  {\n    /* first item in server_options list is ignored. fill it with \\0 */\n    if (!(options_list[0]= calloc(1,sizeof(char))))\n      return NULL;\n\n    ind++;\n  }\n\n  while ((c= *ptr++))\n  {\n    slen--;\n    if (c == ',' || !slen)\n    {\n      len= ptr - options;\n      if (c == ',')\n        len--;\n      if (!(options_list[ind]=calloc(len+1,sizeof(char))))\n        return NULL;\n\n      strncpy(options_list[ind], options, len);\n      ind++;\n      options= ptr;\n    }\n  }\n  return options_list;\n}\n#endif\n\n/*\n  constructs an SQL statement previously prepared with\n  actual values replacing placeholders\n*/\nstatic char *parse_params(\n                          imp_xxh_t *imp_xxh,\n                          pTHX_ MYSQL *sock,\n                          char *statement,\n                          STRLEN *slen_ptr,\n                          imp_sth_ph_t* params,\n                          int num_params,\n                          bool bind_type_guessing,\n                          bool bind_comment_placeholders)\n{\n  bool comment_end= false;\n  char *salloc, *statement_ptr;\n  char *statement_ptr_end, *ptr, *valbuf;\n  char *cp, *end;\n  int alen, i;\n  int slen= *slen_ptr;\n  int limit_flag= 0;\n  int comment_length=0;\n  STRLEN vallen;\n  imp_sth_ph_t *ph;\n\n  if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \">parse_params statement %s\\n\", statement);\n\n  if (num_params == 0)\n    return NULL;\n\n  while (isspace(*statement))\n  {\n    ++statement;\n    --slen;\n  }\n\n  /* Calculate the number of bytes being allocated for the statement */\n  alen= slen;\n\n  for (i= 0, ph= params; i < num_params; i++, ph++)\n  {\n    int defined= 0;\n    if (ph->value)\n    {\n      if (SvMAGICAL(ph->value))\n        mg_get(ph->value);\n      if (SvOK(ph->value))\n        defined=1;\n    }\n    if (!defined)\n      alen+= 3;  /* Erase '?', insert 'NULL' */\n    else\n    {\n      valbuf= SvPV(ph->value, vallen);\n      alen+= 2+vallen+1;\n      /* this will most likely not happen since line 214 */\n      /* of mysql.xs hardcodes all types to SQL_VARCHAR */\n      if (!ph->type)\n      {\n        if (bind_type_guessing)\n        {\n          valbuf= SvPV(ph->value, vallen);\n          ph->type= SQL_INTEGER;\n\n          if (parse_number(valbuf, vallen, &end) != 0)\n          {\n              ph->type= SQL_VARCHAR;\n          }\n        }\n        else\n          ph->type= SQL_VARCHAR;\n      }\n    }\n  }\n\n  /* Allocate memory, why *2, well, because we have ptr and statement_ptr */\n  New(908, salloc, alen*2, char);\n  ptr= salloc;\n\n  i= 0;\n /* Now create the statement string; compare count_params above */\n  statement_ptr_end= (statement_ptr= statement)+ slen;\n\n  while (statement_ptr < statement_ptr_end)\n  {\n    /* LIMIT should be the last part of the query, in most cases */\n    if (! limit_flag)\n    {\n      /*\n        it would be good to be able to handle any number of cases and orders\n      */\n      if ((*statement_ptr == 'l' || *statement_ptr == 'L') &&\n          (!strncmp(statement_ptr+1, \"imit ?\", 6) ||\n           !strncmp(statement_ptr+1, \"IMIT ?\", 6)))\n      {\n        limit_flag = 1;\n      }\n    }\n    switch (*statement_ptr)\n    {\n      /* comment detection. Anything goes in a comment */\n      case '-':\n      {\n          if (bind_comment_placeholders)\n          {\n              *ptr++= *statement_ptr++;\n              break;\n          }\n          else\n          {\n              comment_length= 1;\n              comment_end= false;\n              *ptr++ = *statement_ptr++;\n              if  (*statement_ptr == '-')\n              {\n                  /* ignore everything until newline or end of string */\n                  while (*statement_ptr)\n                  {\n                      comment_length++;\n                      *ptr++ = *statement_ptr++;\n                      if (!*statement_ptr || *statement_ptr == '\\n')\n                      {\n                          comment_end= true;\n                          break;\n                      }\n                  }\n                  /* if not end of comment, go back to where we started, no end found */\n                  if (! comment_end)\n                  {\n                      statement_ptr -= comment_length;\n                      ptr -= comment_length;\n                  }\n              }\n              break;\n          }\n      }\n      /* c-type comments */\n      case '/':\n      {\n          if (bind_comment_placeholders)\n          {\n              *ptr++= *statement_ptr++;\n              break;\n          }\n          else\n          {\n              comment_length= 1;\n              comment_end= false;\n              *ptr++ = *statement_ptr++;\n              if  (*statement_ptr == '*')\n              {\n                  /* use up characters everything until newline */\n                  while (*statement_ptr)\n                  {\n                      *ptr++ = *statement_ptr++;\n                      comment_length++;\n                      if (!strncmp(statement_ptr, \"*/\", 2))\n                      {\n                          comment_length += 2;\n                          comment_end= true;\n                          break;\n                      }\n                  }\n                  /* Go back to where started if comment end not found */\n                  if (! comment_end)\n                  {\n                      statement_ptr -= comment_length;\n                      ptr -= comment_length;\n                  }\n              }\n              break;\n          }\n      }\n      case '`':\n      case '\\'':\n      case '\"':\n      /* Skip string */\n      {\n        char endToken = *statement_ptr++;\n        *ptr++ = endToken;\n        while (statement_ptr != statement_ptr_end &&\n               *statement_ptr != endToken)\n        {\n          if (*statement_ptr == '\\\\')\n          {\n            *ptr++ = *statement_ptr++;\n            if (statement_ptr == statement_ptr_end)\n\t      break;\n\t  }\n          *ptr++= *statement_ptr++;\n\t}\n\tif (statement_ptr != statement_ptr_end)\n          *ptr++= *statement_ptr++;\n      }\n      break;\n\n      case '?':\n        /* Insert parameter */\n        statement_ptr++;\n        if (i >= num_params)\n        {\n          break;\n        }\n\n        ph = params+ (i++);\n        if (!ph->value  ||  !SvOK(ph->value))\n        {\n          *ptr++ = 'N';\n          *ptr++ = 'U';\n          *ptr++ = 'L';\n          *ptr++ = 'L';\n        }\n        else\n        {\n          int is_num = FALSE;\n\n          valbuf= SvPV(ph->value, vallen);\n          if (valbuf)\n          {\n            switch (ph->type)\n            {\n              case SQL_NUMERIC:\n              case SQL_DECIMAL:\n              case SQL_INTEGER:\n              case SQL_SMALLINT:\n              case SQL_FLOAT:\n              case SQL_REAL:\n              case SQL_DOUBLE:\n              case SQL_BIGINT:\n              case SQL_TINYINT:\n                is_num = TRUE;\n                break;\n            }\n\n            /* (note this sets *end, which we use if is_num) */\n            if ( parse_number(valbuf, vallen, &end) != 0 && is_num)\n            {\n              if (bind_type_guessing) {\n                /* .. not a number, so apparerently we guessed wrong */\n                is_num = 0;\n                ph->type = SQL_VARCHAR;\n              }\n            }\n\n\n            /* we're at the end of the query, so any placeholders if */\n            /* after a LIMIT clause will be numbers and should not be quoted */\n            if (limit_flag == 1)\n              is_num = TRUE;\n\n            if (!is_num)\n            {\n              *ptr++ = '\\'';\n              ptr += mysql_real_escape_string(sock, ptr, valbuf, vallen);\n              *ptr++ = '\\'';\n            }\n            else\n            {\n              for (cp= valbuf; cp < end; cp++)\n                  *ptr++= *cp;\n            }\n          }\n        }\n        break;\n\n\t/* in case this is a nested LIMIT */\n      case ')':\n        limit_flag = 0;\n\t*ptr++ = *statement_ptr++;\n        break;\n\n      default:\n        *ptr++ = *statement_ptr++;\n        break;\n\n    }\n  }\n\n  *slen_ptr = ptr - salloc;\n  *ptr++ = '\\0';\n\n  return(salloc);\n}\n\nint bind_param(imp_sth_ph_t *ph, SV *value, IV sql_type)\n{\n  dTHX;\n  if (ph->value)\n  {\n    if (SvMAGICAL(ph->value))\n      mg_get(ph->value);\n    (void) SvREFCNT_dec(ph->value);\n  }\n\n  ph->value= newSVsv(value);\n\n  if (sql_type)\n    ph->type = sql_type;\n\n  return TRUE;\n}\n\nstatic const sql_type_info_t SQL_GET_TYPE_INFO_values[]= {\n  { \"varchar\",    SQL_VARCHAR,                    255, \"'\",  \"'\",  \"max length\",\n    1, 0, 3, 0, 0, 0, \"variable length string\",\n    0, 0, 0,\n    SQL_VARCHAR, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_VAR_STRING,  0,\n#else\n    MYSQL_TYPE_STRING,  0,\n#endif\n  },\n  { \"decimal\",   SQL_DECIMAL,                      15, NULL, NULL, \"precision,scale\",\n    1, 0, 3, 0, 0, 0, \"double\",\n    0, 6, 2,\n    SQL_DECIMAL, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_DECIMAL,     1\n#else\n    MYSQL_TYPE_DECIMAL,     1\n#endif\n  },\n  { \"tinyint\",   SQL_TINYINT,                       3, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"Tiny integer\",\n    0, 0, 10,\n    SQL_TINYINT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_TINY,        1\n#else\n    MYSQL_TYPE_TINY,     1\n#endif\n  },\n  { \"smallint\",  SQL_SMALLINT,                      5, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"Short integer\",\n    0, 0, 10,\n    SQL_SMALLINT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_SHORT,       1\n#else\n    MYSQL_TYPE_SHORT,     1\n#endif\n  },\n  { \"integer\",   SQL_INTEGER,                      10, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"integer\",\n    0, 0, 10,\n    SQL_INTEGER, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_LONG,        1\n#else\n    MYSQL_TYPE_LONG,     1\n#endif\n  },\n  { \"float\",     SQL_REAL,                          7,  NULL, NULL, NULL,\n    1, 0, 0, 0, 0, 0, \"float\",\n    0, 2, 10,\n    SQL_FLOAT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_FLOAT,       1\n#else\n    MYSQL_TYPE_FLOAT,     1\n#endif\n  },\n  { \"double\",    SQL_FLOAT,                       15,  NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"double\",\n    0, 4, 2,\n    SQL_FLOAT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_DOUBLE,      1\n#else\n    MYSQL_TYPE_DOUBLE,     1\n#endif\n  },\n  { \"double\",    SQL_DOUBLE,                       15,  NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"double\",\n    0, 4, 10,\n    SQL_DOUBLE, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_DOUBLE,      1\n#else\n    MYSQL_TYPE_DOUBLE,     1\n#endif\n  },\n  /*\n    FIELD_TYPE_NULL ?\n  */\n  { \"timestamp\", SQL_TIMESTAMP,                    14, \"'\", \"'\", NULL,\n    0, 0, 3, 0, 0, 0, \"timestamp\",\n    0, 0, 0,\n    SQL_TIMESTAMP, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_TIMESTAMP,   0\n#else\n    MYSQL_TYPE_TIMESTAMP,     0\n#endif\n  },\n  { \"bigint\",    SQL_BIGINT,                       19, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"Longlong integer\",\n    0, 0, 10,\n    SQL_BIGINT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_LONGLONG,    1\n#else\n    MYSQL_TYPE_LONGLONG,     1\n#endif\n  },\n  { \"mediumint\", SQL_INTEGER,                       8, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"Medium integer\",\n    0, 0, 10,\n    SQL_INTEGER, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_INT24,       1\n#else\n    MYSQL_TYPE_INT24,     1\n#endif\n  },\n  { \"date\", SQL_DATE, 10, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"date\",\n    0, 0, 0,\n    SQL_DATE, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_DATE, 0\n#else\n    MYSQL_TYPE_DATE, 0\n#endif\n  },\n  { \"time\", SQL_TIME, 6, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"time\",\n    0, 0, 0,\n    SQL_TIME, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_TIME,        0\n#else\n    MYSQL_TYPE_TIME,     0\n#endif\n  },\n  { \"datetime\",  SQL_TIMESTAMP, 21, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"datetime\",\n    0, 0, 0,\n    SQL_TIMESTAMP, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_DATETIME,    0\n#else\n    MYSQL_TYPE_DATETIME,     0\n#endif\n  },\n  { \"year\", SQL_SMALLINT, 4, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"year\",\n    0, 0, 10,\n    SQL_SMALLINT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_YEAR,        0\n#else\n    MYSQL_TYPE_YEAR,     0\n#endif\n  },\n  { \"date\", SQL_DATE, 10, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"date\",\n    0, 0, 0,\n    SQL_DATE, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_NEWDATE,     0\n#else\n    MYSQL_TYPE_NEWDATE,     0\n#endif\n  },\n  { \"enum\",      SQL_VARCHAR,                     255, \"'\",  \"'\",  NULL,\n    1, 0, 1, 0, 0, 0, \"enum(value1,value2,value3...)\",\n    0, 0, 0,\n    0, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_ENUM,        0\n#else\n    MYSQL_TYPE_ENUM,     0\n#endif\n  },\n  { \"set\",       SQL_VARCHAR,                     255, \"'\",  \"'\",  NULL,\n    1, 0, 1, 0, 0, 0, \"set(value1,value2,value3...)\",\n    0, 0, 0,\n    0, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_SET,         0\n#else\n    MYSQL_TYPE_SET,     0\n#endif\n  },\n  { \"blob\",       SQL_LONGVARBINARY,              65535, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"binary large object (0-65535)\",\n    0, 0, 0,\n    SQL_LONGVARBINARY, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_BLOB,        0\n#else\n    MYSQL_TYPE_BLOB,     0\n#endif\n  },\n  { \"tinyblob\",  SQL_VARBINARY,                 255, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"binary large object (0-255) \",\n    0, 0, 0,\n    SQL_VARBINARY, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_TINY_BLOB,   0\n#else\n    FIELD_TYPE_TINY_BLOB,        0\n#endif\n  },\n  { \"mediumblob\", SQL_LONGVARBINARY,           16777215, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"binary large object\",\n    0, 0, 0,\n    SQL_LONGVARBINARY, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0 \n    FIELD_TYPE_MEDIUM_BLOB, 0\n#else\n    MYSQL_TYPE_MEDIUM_BLOB, 0\n#endif\n  },\n  { \"longblob\",   SQL_LONGVARBINARY,         2147483647, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"binary large object, use mediumblob instead\",\n    0, 0, 0,\n    SQL_LONGVARBINARY, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0 \n    FIELD_TYPE_LONG_BLOB,   0\n#else\n    MYSQL_TYPE_LONG_BLOB,   0\n#endif\n  },\n  { \"char\",       SQL_CHAR,                       255, \"'\",  \"'\",  \"max length\",\n    1, 0, 3, 0, 0, 0, \"string\",\n    0, 0, 0,\n    SQL_CHAR, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0 \n    FIELD_TYPE_STRING,      0\n#else\n    MYSQL_TYPE_STRING,   0\n#endif\n  },\n\n  { \"decimal\",            SQL_NUMERIC,            15,  NULL, NULL, \"precision,scale\",\n    1, 0, 3, 0, 0, 0, \"double\",\n    0, 6, 2,\n    SQL_NUMERIC, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_DECIMAL,     1\n#else\n    MYSQL_TYPE_DECIMAL,   1 \n#endif\n  },\n  { \"tinyint unsigned\",   SQL_TINYINT,              3, NULL, NULL, NULL,\n    1, 0, 3, 1, 0, 0, \"Tiny integer unsigned\",\n    0, 0, 10,\n    SQL_TINYINT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_TINY,        1\n#else\n    MYSQL_TYPE_TINY,        1\n#endif\n  },\n  { \"smallint unsigned\",  SQL_SMALLINT,             5, NULL, NULL, NULL,\n    1, 0, 3, 1, 0, 0, \"Short integer unsigned\",\n    0, 0, 10,\n    SQL_SMALLINT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_SHORT,       1\n#else\n    MYSQL_TYPE_SHORT,       1\n#endif\n  },\n  { \"mediumint unsigned\", SQL_INTEGER,              8, NULL, NULL, NULL,\n    1, 0, 3, 1, 0, 0, \"Medium integer unsigned\",\n    0, 0, 10,\n    SQL_INTEGER, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_INT24,       1\n#else\n    MYSQL_TYPE_INT24,       1\n#endif\n  },\n  { \"int unsigned\",       SQL_INTEGER,             10, NULL, NULL, NULL,\n    1, 0, 3, 1, 0, 0, \"integer unsigned\",\n    0, 0, 10,\n    SQL_INTEGER, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_LONG,        1\n#else\n    MYSQL_TYPE_LONG,        1\n#endif\n  },\n  { \"int\",                SQL_INTEGER,             10, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"integer\",\n    0, 0, 10,\n    SQL_INTEGER, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_LONG,        1\n#else\n    MYSQL_TYPE_LONG,        1\n#endif\n  },\n  { \"integer unsigned\",   SQL_INTEGER,             10, NULL, NULL, NULL,\n    1, 0, 3, 1, 0, 0, \"integer\",\n    0, 0, 10,\n    SQL_INTEGER, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_LONG,        1\n#else\n    MYSQL_TYPE_LONG,        1\n#endif\n  },\n  { \"bigint unsigned\",    SQL_BIGINT,              20, NULL, NULL, NULL,\n    1, 0, 3, 1, 0, 0, \"Longlong integer unsigned\",\n    0, 0, 10,\n    SQL_BIGINT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_LONGLONG,    1\n#else\n    MYSQL_TYPE_LONGLONG,    1\n#endif\n  },\n  { \"text\",               SQL_LONGVARCHAR,      65535, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"large text object (0-65535)\",\n    0, 0, 0,\n    SQL_LONGVARCHAR, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_BLOB,        0\n#else\n    MYSQL_TYPE_BLOB,        0\n#endif\n  },\n  { \"mediumtext\",         SQL_LONGVARCHAR,   16777215, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"large text object\",\n    0, 0, 0,\n    SQL_LONGVARCHAR, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_MEDIUM_BLOB, 0\n#else\n    MYSQL_TYPE_MEDIUM_BLOB, 0\n#endif\n  },\n  { \"mediumint unsigned auto_increment\", SQL_INTEGER, 8, NULL, NULL, NULL,\n    0, 0, 3, 1, 0, 1, \"Medium integer unsigned auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_INTEGER, 0, 0, FIELD_TYPE_INT24, 1,\n#else\n    SQL_INTEGER, 0, 0, MYSQL_TYPE_INT24, 1,\n#endif\n  },\n  { \"tinyint unsigned auto_increment\", SQL_TINYINT, 3, NULL, NULL, NULL,\n    0, 0, 3, 1, 0, 1, \"tinyint unsigned auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_TINYINT, 0, 0, FIELD_TYPE_TINY, 1\n#else\n    SQL_TINYINT, 0, 0, MYSQL_TYPE_TINY, 1\n#endif\n  },\n\n  { \"smallint auto_increment\", SQL_SMALLINT, 5, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"smallint auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_SMALLINT, 0, 0, FIELD_TYPE_SHORT, 1\n#else\n    SQL_SMALLINT, 0, 0, MYSQL_TYPE_SHORT, 1\n#endif\n  },\n\n  { \"int unsigned auto_increment\", SQL_INTEGER, 10, NULL, NULL, NULL,\n    0, 0, 3, 1, 0, 1, \"integer unsigned auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_INTEGER, 0, 0, FIELD_TYPE_LONG, 1\n#else\n    SQL_INTEGER, 0, 0, MYSQL_TYPE_LONG, 1\n#endif\n  },\n\n  { \"mediumint\", SQL_INTEGER, 7, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"Medium integer\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_INTEGER, 0, 0, FIELD_TYPE_INT24, 1\n#else\n    SQL_INTEGER, 0, 0, MYSQL_TYPE_INT24, 1\n#endif\n  },\n\n  { \"bit\", SQL_BIT, 1, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"char(1)\", 0, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_BIT, 0, 0, FIELD_TYPE_TINY, 0\n#else\n    SQL_BIT, 0, 0, MYSQL_TYPE_TINY, 0\n#endif\n  },\n\n  { \"numeric\", SQL_NUMERIC, 19, NULL, NULL, \"precision,scale\",\n    1, 0, 3, 0, 0, 0, \"numeric\", 0, 19, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_NUMERIC, 0, 0, FIELD_TYPE_DECIMAL, 1,\n#else\n    SQL_NUMERIC, 0, 0, MYSQL_TYPE_DECIMAL, 1,\n#endif\n  },\n\n  { \"integer unsigned auto_increment\", SQL_INTEGER, 10, NULL, NULL, NULL,\n    0, 0, 3, 1, 0, 1, \"integer unsigned auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_INTEGER, 0, 0, FIELD_TYPE_LONG, 1,\n#else\n    SQL_INTEGER, 0, 0, MYSQL_TYPE_LONG, 1,\n#endif\n  },\n\n  { \"mediumint unsigned\", SQL_INTEGER, 8, NULL, NULL, NULL,\n    1, 0, 3, 1, 0, 0, \"Medium integer unsigned\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_INTEGER, 0, 0, FIELD_TYPE_INT24, 1\n#else\n    SQL_INTEGER, 0, 0, MYSQL_TYPE_INT24, 1\n#endif\n  },\n\n  { \"smallint unsigned auto_increment\", SQL_SMALLINT, 5, NULL, NULL, NULL,\n    0, 0, 3, 1, 0, 1, \"smallint unsigned auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_SMALLINT, 0, 0, FIELD_TYPE_SHORT, 1\n#else\n    SQL_SMALLINT, 0, 0, MYSQL_TYPE_SHORT, 1\n#endif\n  },\n\n  { \"int auto_increment\", SQL_INTEGER, 10, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"integer auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_INTEGER, 0, 0, FIELD_TYPE_LONG, 1\n#else\n    SQL_INTEGER, 0, 0, MYSQL_TYPE_LONG, 1\n#endif\n  },\n\n  { \"long varbinary\", SQL_LONGVARBINARY, 16777215, \"0x\", NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"mediumblob\", 0, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_LONGVARBINARY, 0, 0, FIELD_TYPE_LONG_BLOB, 0\n#else\n    SQL_LONGVARBINARY, 0, 0, MYSQL_TYPE_LONG_BLOB, 0\n#endif\n  },\n\n  { \"double auto_increment\", SQL_FLOAT, 15, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"double auto_increment\", 0, 4, 2,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_FLOAT, 0, 0, FIELD_TYPE_DOUBLE, 1\n#else\n    SQL_FLOAT, 0, 0, MYSQL_TYPE_DOUBLE, 1\n#endif\n  },\n\n  { \"double auto_increment\", SQL_DOUBLE, 15, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"double auto_increment\", 0, 4, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_DOUBLE, 0, 0, FIELD_TYPE_DOUBLE, 1\n#else\n    SQL_DOUBLE, 0, 0, MYSQL_TYPE_DOUBLE, 1\n#endif\n  },\n\n  { \"integer auto_increment\", SQL_INTEGER, 10, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"integer auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_INTEGER, 0, 0, FIELD_TYPE_LONG, 1,\n#else\n    SQL_INTEGER, 0, 0, MYSQL_TYPE_LONG, 1,\n#endif\n  },\n\n  { \"bigint auto_increment\", SQL_BIGINT, 19, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"bigint auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_BIGINT, 0, 0, FIELD_TYPE_LONGLONG, 1\n#else\n    SQL_BIGINT, 0, 0, MYSQL_TYPE_LONGLONG, 1\n#endif\n  },\n\n  { \"bit auto_increment\", SQL_BIT, 1, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"char(1) auto_increment\", 0, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_BIT, 0, 0, FIELD_TYPE_TINY, 1\n#else\n    SQL_BIT, 0, 0, MYSQL_TYPE_TINY, 1\n#endif\n  },\n\n  { \"mediumint auto_increment\", SQL_INTEGER, 7, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"Medium integer auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_INTEGER, 0, 0, FIELD_TYPE_INT24, 1\n#else\n    SQL_INTEGER, 0, 0, MYSQL_TYPE_INT24, 1\n#endif\n  },\n\n  { \"float auto_increment\", SQL_REAL, 7, NULL, NULL, NULL,\n    0, 0, 0, 0, 0, 1, \"float auto_increment\", 0, 2, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_FLOAT, 0, 0, FIELD_TYPE_FLOAT, 1\n#else\n    SQL_FLOAT, 0, 0, MYSQL_TYPE_FLOAT, 1\n#endif\n  },\n\n  { \"long varchar\", SQL_LONGVARCHAR, 16777215, \"'\", \"'\", NULL,\n    1, 0, 3, 0, 0, 0, \"mediumtext\", 0, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_LONGVARCHAR, 0, 0, FIELD_TYPE_MEDIUM_BLOB, 1\n#else\n    SQL_LONGVARCHAR, 0, 0, MYSQL_TYPE_MEDIUM_BLOB, 1\n#endif\n\n  },\n\n  { \"tinyint auto_increment\", SQL_TINYINT, 3, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"tinyint auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_TINYINT, 0, 0, FIELD_TYPE_TINY, 1\n#else\n    SQL_TINYINT, 0, 0, MYSQL_TYPE_TINY, 1\n#endif\n  },\n\n  { \"bigint unsigned auto_increment\", SQL_BIGINT, 20, NULL, NULL, NULL,\n    0, 0, 3, 1, 0, 1, \"bigint unsigned auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_BIGINT, 0, 0, FIELD_TYPE_LONGLONG, 1\n#else\n    SQL_BIGINT, 0, 0, MYSQL_TYPE_LONGLONG, 1\n#endif\n  },\n\n/* END MORE STUFF */\n};\n\n/* \n  static const sql_type_info_t* native2sql (int t)\n*/\nstatic const sql_type_info_t *native2sql(int t)\n{\n  switch (t) {\n    case FIELD_TYPE_VAR_STRING:  return &SQL_GET_TYPE_INFO_values[0];\n    case FIELD_TYPE_DECIMAL:     return &SQL_GET_TYPE_INFO_values[1];\n#ifdef FIELD_TYPE_NEWDECIMAL\n    case FIELD_TYPE_NEWDECIMAL:  return &SQL_GET_TYPE_INFO_values[1];\n#endif\n    case FIELD_TYPE_TINY:        return &SQL_GET_TYPE_INFO_values[2];\n    case FIELD_TYPE_SHORT:       return &SQL_GET_TYPE_INFO_values[3];\n    case FIELD_TYPE_LONG:        return &SQL_GET_TYPE_INFO_values[4];\n    case FIELD_TYPE_FLOAT:       return &SQL_GET_TYPE_INFO_values[5];\n\n    /* 6  */\n    case FIELD_TYPE_DOUBLE:      return &SQL_GET_TYPE_INFO_values[7];\n    case FIELD_TYPE_TIMESTAMP:   return &SQL_GET_TYPE_INFO_values[8];\n    case FIELD_TYPE_LONGLONG:    return &SQL_GET_TYPE_INFO_values[9];\n    case FIELD_TYPE_INT24:       return &SQL_GET_TYPE_INFO_values[10];\n    case FIELD_TYPE_DATE:        return &SQL_GET_TYPE_INFO_values[11];\n    case FIELD_TYPE_TIME:        return &SQL_GET_TYPE_INFO_values[12];\n    case FIELD_TYPE_DATETIME:    return &SQL_GET_TYPE_INFO_values[13];\n    case FIELD_TYPE_YEAR:        return &SQL_GET_TYPE_INFO_values[14];\n    case FIELD_TYPE_NEWDATE:     return &SQL_GET_TYPE_INFO_values[15];\n    case FIELD_TYPE_ENUM:        return &SQL_GET_TYPE_INFO_values[16];\n    case FIELD_TYPE_SET:         return &SQL_GET_TYPE_INFO_values[17];\n    case FIELD_TYPE_BLOB:        return &SQL_GET_TYPE_INFO_values[18];\n    case FIELD_TYPE_TINY_BLOB:   return &SQL_GET_TYPE_INFO_values[19];\n    case FIELD_TYPE_MEDIUM_BLOB: return &SQL_GET_TYPE_INFO_values[20];\n    case FIELD_TYPE_LONG_BLOB:   return &SQL_GET_TYPE_INFO_values[21];\n    case FIELD_TYPE_STRING:      return &SQL_GET_TYPE_INFO_values[22];\n    default:                     return &SQL_GET_TYPE_INFO_values[0];\n  }\n}\n\n\n#define SQL_GET_TYPE_INFO_num \\\n\t(sizeof(SQL_GET_TYPE_INFO_values)/sizeof(sql_type_info_t))\n\n\n/***************************************************************************\n *\n *  Name:    dbd_init\n *\n *  Purpose: Called when the driver is installed by DBI\n *\n *  Input:   dbistate - pointer to the DBI state variable, used for some\n *               DBI internal things\n *\n *  Returns: Nothing\n *\n **************************************************************************/\n\nvoid dbd_init(dbistate_t* dbistate)\n{\n    dTHX;\n    DBISTATE_INIT;\n}\n\n\n/**************************************************************************\n *\n *  Name:    do_error, do_warn\n *\n *  Purpose: Called to associate an error code and an error message\n *           to some handle\n *\n *  Input:   h - the handle in error condition\n *           rc - the error code\n *           what - the error message\n *\n *  Returns: Nothing\n *\n **************************************************************************/\n\nvoid do_error(SV* h, int rc, const char* what, const char* sqlstate)\n{\n  dTHX;\n  D_imp_xxh(h);\n  STRLEN lna;\n  SV *errstr;\n  SV *errstate;\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\t--> do_error\\n\");\n  errstr= DBIc_ERRSTR(imp_xxh);\n  sv_setiv(DBIc_ERR(imp_xxh), (IV)rc);\t/* set err early\t*/\n  sv_setpv(errstr, what);\n\n#if MYSQL_VERSION_ID >= SQL_STATE_VERSION\n  if (sqlstate)\n  {\n    errstate= DBIc_STATE(imp_xxh);\n    sv_setpvn(errstate, sqlstate, 5);\n  }\n#endif\n\n  /* NO EFFECT DBIh_EVENT2(h, ERROR_event, DBIc_ERR(imp_xxh), errstr); */\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%s error %d recorded: %s\\n\",\n    what, rc, SvPV(errstr,lna));\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\t<-- do_error\\n\");\n}\n\n/*\n  void do_warn(SV* h, int rc, char* what)\n*/\nvoid do_warn(SV* h, int rc, char* what)\n{\n  dTHX;\n  D_imp_xxh(h);\n  STRLEN lna;\n\n  SV *errstr = DBIc_ERRSTR(imp_xxh);\n  sv_setiv(DBIc_ERR(imp_xxh), (IV)rc);\t/* set err early\t*/\n  sv_setpv(errstr, what);\n  /* NO EFFECT DBIh_EVENT2(h, WARN_event, DBIc_ERR(imp_xxh), errstr);*/\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%s warning %d recorded: %s\\n\",\n    what, rc, SvPV(errstr,lna));\n  warn(\"%s\", what);\n}\n\n#if defined(DBD_MYSQL_EMBEDDED)\n #define DBD_MYSQL_NAMESPACE \"DBD::mysqlEmb::QUIET\";\n#else\n #define DBD_MYSQL_NAMESPACE \"DBD::mysql::QUIET\";\n#endif\n\n#define doquietwarn(s) \\\n  { \\\n    SV* sv = perl_get_sv(DBD_MYSQL_NAMESPACE, FALSE);  \\\n    if (!sv  ||  !SvTRUE(sv)) { \\\n      warn s; \\\n    } \\\n  }\n\n\n/***************************************************************************\n *\n *  Name:    mysql_dr_connect\n *\n *  Purpose: Replacement for mysql_connect\n *\n *  Input:   MYSQL* sock - Pointer to a MYSQL structure being\n *             initialized\n *           char* mysql_socket - Name of a UNIX socket being used\n *             or NULL\n *           char* host - Host name being used or NULL for localhost\n *           char* port - Port number being used or NULL for default\n *           char* user - User name being used or NULL\n *           char* password - Password being used or NULL\n *           char* dbname - Database name being used or NULL\n *           char* imp_dbh - Pointer to internal dbh structure\n *\n *  Returns: The sock argument for success, NULL otherwise;\n *           you have to call do_error in the latter case.\n *\n **************************************************************************/\n\nMYSQL *mysql_dr_connect(\n                        SV* dbh,\n                        MYSQL* sock,\n                        char* mysql_socket,\n                        char* host,\n\t\t\t                  char* port,\n                        char* user,\n                        char* password,\n\t\t\t                  char* dbname,\n                        imp_dbh_t *imp_dbh)\n{\n  int portNr;\n  unsigned int client_flag;\n  MYSQL* result;\n  dTHX;\n  D_imp_xxh(dbh);\n\n  /* per Monty, already in client.c in API */\n  /* but still not exist in libmysqld.c */\n#if defined(DBD_MYSQL_EMBEDDED)\n   if (host && !*host) host = NULL;\n#endif\n\n  portNr= (port && *port) ? atoi(port) : 0;\n\n  /* already in client.c in API */\n  /* if (user && !*user) user = NULL; */\n  /* if (password && !*password) password = NULL; */\n\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->mysql_dr_connect: host = |%s|, port = %d,\" \\\n\t\t  \" uid = %s, pwd = %s\\n\",\n\t\t  host ? host : \"NULL\", portNr,\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\");\n\n  {\n\n#if defined(DBD_MYSQL_EMBEDDED)\n    if (imp_dbh)\n    {\n      D_imp_drh_from_dbh;\n      SV* sv = DBIc_IMP_DATA(imp_dbh);\n\n      if (sv  &&  SvROK(sv))\n      {\n        SV** svp;\n        STRLEN lna;\n        char * options;\n        int server_args_cnt= 0;\n        int server_groups_cnt= 0;\n        int rc= 0;\n\n        char ** server_args = NULL;\n        char ** server_groups = NULL;\n\n        HV* hv = (HV*) SvRV(sv);\n\n        if (SvTYPE(hv) != SVt_PVHV)\n          return NULL;\n\n        if (!imp_drh->embedded.state)\n        {\n          /* Init embedded server */\n          if ((svp = hv_fetch(hv, \"mysql_embedded_groups\", 21, FALSE))  &&\n              *svp  &&  SvTRUE(*svp))\n          {\n            options = SvPV(*svp, lna);\n            imp_drh->embedded.groups=newSVsv(*svp);\n\n            if ((server_groups_cnt=count_embedded_options(options)))\n            {\n              /* number of server_groups always server_groups+1 */\n              server_groups=fill_out_embedded_options(options, 0, \n                                                      (int)lna, ++server_groups_cnt);\n              if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n              {\n                PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                              \"Groups names passed to embedded server:\\n\");\n                print_embedded_options(DBIc_LOGPIO(imp_xxh), server_groups, server_groups_cnt);\n              }\n            }\n          }\n\n          if ((svp = hv_fetch(hv, \"mysql_embedded_options\", 22, FALSE))  &&\n              *svp  &&  SvTRUE(*svp))\n          {\n            options = SvPV(*svp, lna);\n            imp_drh->embedded.args=newSVsv(*svp);\n\n            if ((server_args_cnt=count_embedded_options(options)))\n            {\n              /* number of server_options always server_options+1 */\n              server_args=fill_out_embedded_options(options, 1, (int)lna, ++server_args_cnt);\n              if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n              {\n                PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Server options passed to embedded server:\\n\");\n                print_embedded_options(DBIc_LOGPIO(imp_xxh), server_args, server_args_cnt);\n              }\n            }\n          }\n          if (mysql_server_init(server_args_cnt, server_args, server_groups))\n          {\n            do_warn(dbh, AS_ERR_EMBEDDED, \"Embedded server was not started. \\\n                    Could not initialize environment.\");\n            return NULL;\n          }\n          imp_drh->embedded.state=1;\n\n          if (server_args_cnt)\n            free_embedded_options(server_args, server_args_cnt);\n          if (server_groups_cnt)\n            free_embedded_options(server_groups, server_groups_cnt);\n        }\n        else\n        {\n         /*\n          * Check if embedded parameters passed to connect() differ from\n          * first ones\n          */\n\n          if ( ((svp = hv_fetch(hv, \"mysql_embedded_groups\", 21, FALSE)) &&\n            *svp  &&  SvTRUE(*svp)))\n            rc =+ abs(sv_cmp(*svp, imp_drh->embedded.groups));\n\n          if ( ((svp = hv_fetch(hv, \"mysql_embedded_options\", 22, FALSE)) &&\n            *svp  &&  SvTRUE(*svp)) )\n            rc =+ abs(sv_cmp(*svp, imp_drh->embedded.args));\n\n          if (rc)\n          {\n            do_warn(dbh, AS_ERR_EMBEDDED,\n                    \"Embedded server was already started. You cannot pass init\\\n                    parameters to embedded server once\");\n            return NULL;\n          }\n        }\n      }\n    }\n#endif\n\n#ifdef MYSQL_NO_CLIENT_FOUND_ROWS\n    client_flag = 0;\n#else\n    client_flag = CLIENT_FOUND_ROWS;\n#endif\n    mysql_init(sock);\n\n    if (imp_dbh)\n    {\n      SV* sv = DBIc_IMP_DATA(imp_dbh);\n\n      DBIc_set(imp_dbh, DBIcf_AutoCommit, TRUE);\n      if (sv  &&  SvROK(sv))\n      {\n        HV* hv = (HV*) SvRV(sv);\n        SV** svp;\n        STRLEN lna;\n\n        /* thanks to Peter John Edwards for mysql_init_command */ \n        if ((svp = hv_fetch(hv, \"mysql_init_command\", 18, FALSE)) &&\n            *svp && SvTRUE(*svp))\n        {\n          char* df = SvPV(*svp, lna);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                           \"imp_dbh->mysql_dr_connect: Setting\" \\\n                           \" init command (%s).\\n\", df);\n          mysql_options(sock, MYSQL_INIT_COMMAND, df);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_compression\", 17, FALSE))  &&\n            *svp && SvTRUE(*svp))\n        {\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->mysql_dr_connect: Enabling\" \\\n                          \" compression.\\n\");\n          mysql_options(sock, MYSQL_OPT_COMPRESS, NULL);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_connect_timeout\", 21, FALSE))\n            &&  *svp  &&  SvTRUE(*svp))\n        {\n          int to = SvIV(*svp);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->mysql_dr_connect: Setting\" \\\n                          \" connect timeout (%d).\\n\",to);\n          mysql_options(sock, MYSQL_OPT_CONNECT_TIMEOUT,\n                        (const char *)&to);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_write_timeout\", 19, FALSE))\n            &&  *svp  &&  SvTRUE(*svp))\n        {\n          int to = SvIV(*svp);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->mysql_dr_connect: Setting\" \\\n                          \" write timeout (%d).\\n\",to);\n          mysql_options(sock, MYSQL_OPT_WRITE_TIMEOUT,\n                        (const char *)&to);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_read_timeout\", 18, FALSE))\n            &&  *svp  &&  SvTRUE(*svp))\n        {\n          int to = SvIV(*svp);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->mysql_dr_connect: Setting\" \\\n                          \" read timeout (%d).\\n\",to);\n          mysql_options(sock, MYSQL_OPT_READ_TIMEOUT,\n                        (const char *)&to);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_skip_secure_auth\", 22, FALSE)) &&\n            *svp  &&  SvTRUE(*svp))\n        {\n          my_bool secauth = 0;\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->mysql_dr_connect: Skipping\" \\\n                          \" secure auth\\n\");\n          mysql_options(sock, MYSQL_SECURE_AUTH, &secauth);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_read_default_file\", 23, FALSE)) &&\n            *svp  &&  SvTRUE(*svp))\n        {\n          char* df = SvPV(*svp, lna);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->mysql_dr_connect: Reading\" \\\n                          \" default file %s.\\n\", df);\n          mysql_options(sock, MYSQL_READ_DEFAULT_FILE, df);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_read_default_group\", 24,\n                            FALSE))  &&\n            *svp  &&  SvTRUE(*svp)) {\n          char* gr = SvPV(*svp, lna);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"imp_dbh->mysql_dr_connect: Using\" \\\n                    \" default group %s.\\n\", gr);\n\n          mysql_options(sock, MYSQL_READ_DEFAULT_GROUP, gr);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_client_found_rows\", 23, FALSE)) && *svp)\n        {\n          if (SvTRUE(*svp))\n            client_flag |= CLIENT_FOUND_ROWS;\n          else\n            client_flag &= ~CLIENT_FOUND_ROWS;\n        }\n        if ((svp = hv_fetch(hv, \"mysql_use_result\", 16, FALSE)) && *svp)\n        {\n          imp_dbh->use_mysql_use_result = SvTRUE(*svp);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->use_mysql_use_result: %d\\n\",\n                          imp_dbh->use_mysql_use_result);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_bind_type_guessing\", 24, TRUE)) && *svp)\n        {\n          imp_dbh->bind_type_guessing= SvTRUE(*svp);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->bind_type_guessing: %d\\n\",\n                          imp_dbh->bind_type_guessing);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_bind_comment_placeholders\", 31, FALSE)) && *svp)\n        {\n          imp_dbh->bind_comment_placeholders = SvTRUE(*svp);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->bind_comment_placeholders: %d\\n\",\n                          imp_dbh->bind_comment_placeholders);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_no_autocommit_cmd\", 23, FALSE)) && *svp)\n        {\n          imp_dbh->no_autocommit_cmd= SvTRUE(*svp);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->no_autocommit_cmd: %d\\n\",\n                          imp_dbh->no_autocommit_cmd);\n        }\n\n\n#if defined(CLIENT_MULTI_STATEMENTS)\n\tif ((svp = hv_fetch(hv, \"mysql_multi_statements\", 22, FALSE)) && *svp)\n        {\n\t  if (SvTRUE(*svp))\n\t    client_flag |= CLIENT_MULTI_STATEMENTS;\n          else\n            client_flag &= ~CLIENT_MULTI_STATEMENTS;\n\t}\n#endif\n\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n\t/* took out  client_flag |= CLIENT_PROTOCOL_41; */\n\t/* because libmysql.c already sets this no matter what */\n\tif ((svp = hv_fetch(hv, \"mysql_server_prepare\", 20, FALSE))\n            && *svp)\n        {\n\t  if (SvTRUE(*svp))\n          {\n\t    client_flag |= CLIENT_PROTOCOL_41;\n            imp_dbh->use_server_side_prepare = TRUE;\n\t  }\n          else\n          {\n\t    client_flag &= ~CLIENT_PROTOCOL_41;\n            imp_dbh->use_server_side_prepare = FALSE;\n\t  }\n\t}\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                        \"imp_dbh->use_server_side_prepare: %d\\n\",\n                        imp_dbh->use_server_side_prepare);\n#endif\n\n        /* HELMUT */\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n        if ((svp = hv_fetch(hv, \"mysql_enable_utf8\", 17, FALSE)) && *svp) {\n          /* Do not touch imp_dbh->enable_utf8 as we are called earlier\n           * than it is set and mysql_options() must be before:\n           * mysql_real_connect()\n          */\n         mysql_options(sock, MYSQL_SET_CHARSET_NAME,\n                       (SvTRUE(*svp) ? \"utf8\" : \"latin1\"));\n         if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n           PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                         \"mysql_options: MYSQL_SET_CHARSET_NAME=%s\\n\",\n                         (SvTRUE(*svp) ? \"utf8\" : \"latin1\"));\n        }\n#endif\n\n#if defined(DBD_MYSQL_WITH_SSL) && !defined(DBD_MYSQL_EMBEDDED) && \\\n    (defined(CLIENT_SSL) || (MYSQL_VERSION_ID >= 40000))\n\tif ((svp = hv_fetch(hv, \"mysql_ssl\", 9, FALSE))  &&  *svp)\n        {\n\t  if (SvTRUE(*svp))\n          {\n\t    char *client_key = NULL;\n\t    char *client_cert = NULL;\n\t    char *ca_file = NULL;\n\t    char *ca_path = NULL;\n\t    char *cipher = NULL;\n\t    STRLEN lna;\n#if MYSQL_VERSION_ID >= SSL_VERIFY_VERSION\n            /*\n              New code to utilise MySQLs new feature that verifies that the\n              server's hostname that the client connects to matches that of\n              the certificate\n            */\n\t    my_bool ssl_verify_true = 0;\n\t    if ((svp = hv_fetch(hv, \"mysql_ssl_verify_server_cert\", 28, FALSE))  &&  *svp)\n\t      ssl_verify_true = SvTRUE(*svp);\n#endif\n\t    if ((svp = hv_fetch(hv, \"mysql_ssl_client_key\", 20, FALSE)) && *svp)\n\t      client_key = SvPV(*svp, lna);\n\n\t    if ((svp = hv_fetch(hv, \"mysql_ssl_client_cert\", 21, FALSE)) &&\n                *svp)\n\t      client_cert = SvPV(*svp, lna);\n\n\t    if ((svp = hv_fetch(hv, \"mysql_ssl_ca_file\", 17, FALSE)) &&\n\t\t *svp)\n\t      ca_file = SvPV(*svp, lna);\n\n\t    if ((svp = hv_fetch(hv, \"mysql_ssl_ca_path\", 17, FALSE)) &&\n                *svp)\n\t      ca_path = SvPV(*svp, lna);\n\n\t    if ((svp = hv_fetch(hv, \"mysql_ssl_cipher\", 16, FALSE)) &&\n\t\t*svp)\n\t      cipher = SvPV(*svp, lna);\n\n\t    mysql_ssl_set(sock, client_key, client_cert, ca_file,\n\t\t\t  ca_path, cipher);\n#if MYSQL_VERSION_ID >= SSL_VERIFY_VERSION\n\t    mysql_options(sock, MYSQL_OPT_SSL_VERIFY_SERVER_CERT, &ssl_verify_true);\n#endif\n\t    client_flag |= CLIENT_SSL;\n\t  }\n\t}\n#endif\n#if (MYSQL_VERSION_ID >= 32349)\n\t/*\n\t * MySQL 3.23.49 disables LOAD DATA LOCAL by default. Use\n\t * mysql_local_infile=1 in the DSN to enable it.\n\t */\n     if ((svp = hv_fetch( hv, \"mysql_local_infile\", 18, FALSE))  &&  *svp)\n     {\n\t  unsigned int flag = SvTRUE(*svp);\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n\t    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n        \"imp_dbh->mysql_dr_connect: Using\" \\\n        \" local infile %u.\\n\", flag);\n\t  mysql_options(sock, MYSQL_OPT_LOCAL_INFILE, (const char *) &flag);\n\t}\n#endif\n      }\n    }\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"imp_dbh->mysql_dr_connect: client_flags = %d\\n\",\n\t\t    client_flag);\n\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n    client_flag|= CLIENT_MULTI_RESULTS;\n#endif\n    result = mysql_real_connect(sock, host, user, password, dbname,\n\t\t\t\tportNr, mysql_socket, client_flag);\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"imp_dbh->mysql_dr_connect: <-\");\n\n    if (result)\n    {\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n      /* connection succeeded. */\n      /* imp_dbh == NULL when mysql_dr_connect() is called from mysql.xs\n         functions (_admin_internal(),_ListDBs()). */\n      if (!(result->client_flag & CLIENT_PROTOCOL_41) && imp_dbh)\n        imp_dbh->use_server_side_prepare = FALSE;\n#endif\n\n#if MYSQL_ASYNC\n      if(imp_dbh) {\n          imp_dbh->async_query_in_flight = NULL;\n      }\n#endif\n\n      /*\n        we turn off Mysql's auto reconnect and handle re-connecting ourselves\n        so that we can keep track of when this happens.\n      */\n      result->reconnect=0;\n    }\n    else {\n      /* \n         sock was allocated with mysql_init() \n         fixes: https://rt.cpan.org/Ticket/Display.html?id=86153\n\n      Safefree(sock);\n\n         rurban: No, we still need this handle later in mysql_dr_error().\n         RT #97625. It will be freed as imp_dbh->pmysql in dbd_db_destroy(),\n         which is called by the DESTROY handler.\n      */\n    }\n    return result;\n  }\n}\n\n/*\n  safe_hv_fetch\n*/\nstatic char *safe_hv_fetch(pTHX_ HV *hv, const char *name, int name_length)\n{\n  SV** svp;\n  STRLEN len;\n  char *res= NULL;\n\n  if ((svp= hv_fetch(hv, name, name_length, FALSE)))\n  {\n    res= SvPV(*svp, len);\n    if (!len)\n      res= NULL;\n  }\n  return res;\n}\n\n/*\n Frontend for mysql_dr_connect\n*/\nstatic int my_login(pTHX_ SV* dbh, imp_dbh_t *imp_dbh)\n{\n  SV* sv;\n  HV* hv;\n  char* dbname;\n  char* host;\n  char* port;\n  char* user;\n  char* password;\n  char* mysql_socket;\n  int   result;\n  D_imp_xxh(dbh);\n\n  /* TODO- resolve this so that it is set only if DBI is 1.607 */\n#define TAKE_IMP_DATA_VERSION 1\n#if TAKE_IMP_DATA_VERSION\n  if (DBIc_has(imp_dbh, DBIcf_IMPSET))\n  { /* eg from take_imp_data() */\n    if (DBIc_has(imp_dbh, DBIcf_ACTIVE))\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"my_login skip connect\\n\");\n      /* tell our parent we've adopted an active child */\n      ++DBIc_ACTIVE_KIDS(DBIc_PARENT_COM(imp_dbh));\n      return TRUE;\n    }\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"my_login IMPSET but not ACTIVE so connect not skipped\\n\");\n  }\n#endif\n\n  sv = DBIc_IMP_DATA(imp_dbh);\n\n  if (!sv  ||  !SvROK(sv))\n    return FALSE;\n\n  hv = (HV*) SvRV(sv);\n  if (SvTYPE(hv) != SVt_PVHV)\n    return FALSE;\n\n  host=\t\tsafe_hv_fetch(aTHX_ hv, \"host\", 4);\n  port=\t\tsafe_hv_fetch(aTHX_ hv, \"port\", 4);\n  user=\t\tsafe_hv_fetch(aTHX_ hv, \"user\", 4);\n  password=\tsafe_hv_fetch(aTHX_ hv, \"password\", 8);\n  dbname=\tsafe_hv_fetch(aTHX_ hv, \"database\", 8);\n  mysql_socket=\tsafe_hv_fetch(aTHX_ hv, \"mysql_socket\", 12);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->my_login : dbname = %s, uid = %s, pwd = %s,\" \\\n\t\t  \"host = %s, port = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\",\n\t\t  host ? host : \"NULL\",\n\t\t  port ? port : \"NULL\");\n\n  if (!imp_dbh->pmysql) {\n     Newz(908, imp_dbh->pmysql, 1, MYSQL);\n  }\n  result = mysql_dr_connect(dbh, imp_dbh->pmysql, mysql_socket, host, port, user,\n\t\t\t  password, dbname, imp_dbh) ? TRUE : FALSE;\n  if (!result)\n      Safefree(imp_dbh->pmysql);\n  return result;\n}\n\n\n/**************************************************************************\n *\n *  Name:    dbd_db_login\n *\n *  Purpose: Called for connecting to a database and logging in.\n *\n *  Input:   dbh - database handle being initialized\n *           imp_dbh - drivers private database handle data\n *           dbname - the database we want to log into; may be like\n *               \"dbname:host\" or \"dbname:host:port\"\n *           user - user name to connect as\n *           password - passwort to connect with\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error has already\n *           been called in the latter case\n *\n **************************************************************************/\n\nint dbd_db_login(SV* dbh, imp_dbh_t* imp_dbh, char* dbname, char* user,\n\t\t char* password) {\n#ifdef dTHR\n  dTHR;\n#endif\n  dTHX; \n  D_imp_xxh(dbh);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->connect: dsn = %s, uid = %s, pwd = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\");\n\n  imp_dbh->stats.auto_reconnects_ok= 0;\n  imp_dbh->stats.auto_reconnects_failed= 0;\n  imp_dbh->bind_type_guessing= FALSE;\n  imp_dbh->bind_comment_placeholders= FALSE;\n  imp_dbh->has_transactions= TRUE;\n /* Safer we flip this to TRUE perl side if we detect a mod_perl env. */\n  imp_dbh->auto_reconnect = FALSE;\n\n  /* HELMUT */\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  imp_dbh->enable_utf8 = FALSE;  /* initialize mysql_enable_utf8 */\n#endif\n\n  if (!my_login(aTHX_ dbh, imp_dbh))\n  {\n    do_error(dbh, mysql_errno(imp_dbh->pmysql),\n            mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n    return FALSE;\n  }\n\n    /*\n     *  Tell DBI, that dbh->disconnect should be called for this handle\n     */\n    DBIc_ACTIVE_on(imp_dbh);\n\n    /* Tell DBI, that dbh->destroy should be called for this handle */\n    DBIc_on(imp_dbh, DBIcf_IMPSET);\n\n    return TRUE;\n}\n\n\n/***************************************************************************\n *\n *  Name:    dbd_db_commit\n *           dbd_db_rollback\n *\n *  Purpose: You guess what they should do. \n *\n *  Input:   dbh - database handle being commited or rolled back\n *           imp_dbh - drivers private database handle data\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error has already\n *           been called in the latter case\n *\n **************************************************************************/\n\nint\ndbd_db_commit(SV* dbh, imp_dbh_t* imp_dbh)\n{\n  if (DBIc_has(imp_dbh, DBIcf_AutoCommit))\n    return FALSE;\n\n  ASYNC_CHECK_RETURN(dbh, FALSE);\n\n  if (imp_dbh->has_transactions)\n  {\n#if MYSQL_VERSION_ID < SERVER_PREPARE_VERSION\n    if (mysql_real_query(imp_dbh->pmysql, \"COMMIT\", 6))\n#else\n    if (mysql_commit(imp_dbh->pmysql))\n#endif\n    {\n      do_error(dbh, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql)\n               ,mysql_sqlstate(imp_dbh->pmysql));\n      return FALSE;\n    }\n  }\n  else\n    do_warn(dbh, JW_ERR_NOT_IMPLEMENTED,\n            \"Commit ineffective because transactions are not available\");\n  return TRUE;\n}\n\n/*\n dbd_db_rollback\n*/\nint\ndbd_db_rollback(SV* dbh, imp_dbh_t* imp_dbh) {\n  /* croak, if not in AutoCommit mode */\n  if (DBIc_has(imp_dbh, DBIcf_AutoCommit))\n    return FALSE;\n\n  ASYNC_CHECK_RETURN(dbh, FALSE);\n\n  if (imp_dbh->has_transactions)\n  {\n#if MYSQL_VERSION_ID < SERVER_PREPARE_VERSION\n    if (mysql_real_query(imp_dbh->pmysql, \"ROLLBACK\", 8))\n#else\n      if (mysql_rollback(imp_dbh->pmysql))\n#endif\n      {\n        do_error(dbh, mysql_errno(imp_dbh->pmysql),\n                 mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n        return FALSE;\n      }\n  }\n  else\n    do_error(dbh, JW_ERR_NOT_IMPLEMENTED,\n             \"Rollback ineffective because transactions are not available\" ,NULL);\n  return TRUE;\n}\n\n/*\n ***************************************************************************\n *\n *  Name:    dbd_db_disconnect\n *\n *  Purpose: Disconnect a database handle from its database\n *\n *  Input:   dbh - database handle being disconnected\n *           imp_dbh - drivers private database handle data\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error has already\n *           been called in the latter case\n *\n **************************************************************************/\n\nint dbd_db_disconnect(SV* dbh, imp_dbh_t* imp_dbh)\n{\n#ifdef dTHR\n  dTHR;\n#endif\n  dTHX;\n  D_imp_xxh(dbh);\n\n  /* We assume that disconnect will always work       */\n  /* since most errors imply already disconnected.    */\n  DBIc_ACTIVE_off(imp_dbh);\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"imp_dbh->pmysql: %lx\\n\",\n\t\t              (long) imp_dbh->pmysql);\n  mysql_close(imp_dbh->pmysql );\n\n  /* We don't free imp_dbh since a reference still exists    */\n  /* The DESTROY method is the only one to 'free' memory.    */\n  return TRUE;\n}\n\n\n/***************************************************************************\n *\n *  Name:    dbd_discon_all\n *\n *  Purpose: Disconnect all database handles at shutdown time\n *\n *  Input:   dbh - database handle being disconnected\n *           imp_dbh - drivers private database handle data\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error has already\n *           been called in the latter case\n *\n **************************************************************************/\n\nint dbd_discon_all (SV *drh, imp_drh_t *imp_drh) {\n#if defined(dTHR)\n  dTHR;\n#endif\n  dTHX;\n  D_imp_xxh(drh);\n\n#if defined(DBD_MYSQL_EMBEDDED)\n  if (imp_drh->embedded.state)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Stop embedded server\\n\");\n\n    mysql_server_end();\n    if (imp_drh->embedded.groups)\n    {\n      (void) SvREFCNT_dec(imp_drh->embedded.groups);\n      imp_drh->embedded.groups = NULL;\n    }\n\n    if (imp_drh->embedded.args)\n    {\n      (void) SvREFCNT_dec(imp_drh->embedded.args);\n      imp_drh->embedded.args = NULL;\n    }\n\n\n  }\n#else\n  mysql_server_end();\n#endif\n\n  /* The disconnect_all concept is flawed and needs more work */\n  if (!PL_dirty && !SvTRUE(perl_get_sv(\"DBI::PERL_ENDING\",0))) {\n    sv_setiv(DBIc_ERR(imp_drh), (IV)1);\n    sv_setpv(DBIc_ERRSTR(imp_drh),\n             (char*)\"disconnect_all not implemented\");\n    /* NO EFFECT DBIh_EVENT2(drh, ERROR_event,\n      DBIc_ERR(imp_drh), DBIc_ERRSTR(imp_drh)); */\n    return FALSE;\n  }\n  PL_perl_destruct_level = 0;\n  return FALSE;\n}\n\n\n/****************************************************************************\n *\n *  Name:    dbd_db_destroy\n *\n *  Purpose: Our part of the dbh destructor\n *\n *  Input:   dbh - database handle being destroyed\n *           imp_dbh - drivers private database handle data\n *\n *  Returns: Nothing\n *\n **************************************************************************/\n\nvoid dbd_db_destroy(SV* dbh, imp_dbh_t* imp_dbh) {\n\n    /*\n     *  Being on the safe side never hurts ...\n     */\n  if (DBIc_ACTIVE(imp_dbh))\n  {\n    if (imp_dbh->has_transactions)\n    {\n      if (!DBIc_has(imp_dbh, DBIcf_AutoCommit))\n#if MYSQL_VERSION_ID < SERVER_PREPARE_VERSION\n        if ( mysql_real_query(imp_dbh->pmysql, \"ROLLBACK\", 8))\n#else\n        if (mysql_rollback(imp_dbh->pmysql))\n#endif\n            do_error(dbh, TX_ERR_ROLLBACK,\"ROLLBACK failed\" ,NULL);\n    }\n    dbd_db_disconnect(dbh, imp_dbh);\n  }\n  Safefree(imp_dbh->pmysql);\n\n  /* Tell DBI, that dbh->destroy must no longer be called */\n  DBIc_off(imp_dbh, DBIcf_IMPSET);\n}\n\n/* \n ***************************************************************************\n *\n *  Name:    dbd_db_STORE_attrib\n *\n *  Purpose: Function for storing dbh attributes; we currently support\n *           just nothing. :-)\n *\n *  Input:   dbh - database handle being modified\n *           imp_dbh - drivers private database handle data\n *           keysv - the attribute name\n *           valuesv - the attribute value\n *\n *  Returns: TRUE for success, FALSE otherwise\n *\n **************************************************************************/\nint\ndbd_db_STORE_attrib(\n                    SV* dbh,\n                    imp_dbh_t* imp_dbh,\n                    SV* keysv,\n                    SV* valuesv\n                   )\n{\n  dTHX;\n  STRLEN kl;\n  char *key = SvPV(keysv, kl);\n  SV *cachesv = Nullsv;\n  int cacheit = FALSE;\n  bool bool_value = SvTRUE(valuesv);\n\n  if (kl==10 && strEQ(key, \"AutoCommit\"))\n  {\n    if (imp_dbh->has_transactions)\n    {\n      bool oldval = DBIc_has(imp_dbh,DBIcf_AutoCommit) ? 1 : 0;\n\n      if (bool_value == oldval)\n        return TRUE;\n\n      /* if setting AutoCommit on ... */\n      if (!imp_dbh->no_autocommit_cmd)\n      {\n        if (\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n            mysql_autocommit(imp_dbh->pmysql, bool_value)\n#else\n            mysql_real_query(imp_dbh->pmysql,\n                             bool_value ? \"SET AUTOCOMMIT=1\" : \"SET AUTOCOMMIT=0\",\n                             16)\n#endif\n           )\n        {\n          do_error(dbh, TX_ERR_AUTOCOMMIT,\n                   bool_value ?\n                   \"Turning on AutoCommit failed\" :\n                   \"Turning off AutoCommit failed\"\n                   ,NULL);\n          return TRUE;  /* TRUE means we handled it - important to avoid spurious errors */\n        }\n      }\n      DBIc_set(imp_dbh, DBIcf_AutoCommit, bool_value);\n    }\n    else\n    {\n      /*\n       *  We do support neither transactions nor \"AutoCommit\".\n       *  But we stub it. :-)\n      */\n      if (!bool_value)\n      {\n        do_error(dbh, JW_ERR_NOT_IMPLEMENTED,\n                 \"Transactions not supported by database\" ,NULL);\n        croak(\"Transactions not supported by database\");\n      }\n    }\n  }\n  else if (kl == 16 && strEQ(key,\"mysql_use_result\"))\n    imp_dbh->use_mysql_use_result = bool_value;\n  else if (kl == 20 && strEQ(key,\"mysql_auto_reconnect\"))\n    imp_dbh->auto_reconnect = bool_value;\n  else if (kl == 20 && strEQ(key, \"mysql_server_prepare\"))\n    imp_dbh->use_server_side_prepare=SvTRUE(valuesv);\n  else if (kl == 23 && strEQ(key,\"mysql_no_autocommit_cmd\"))\n    imp_dbh->no_autocommit_cmd= SvTRUE(valuesv);\n  else if (kl == 24 && strEQ(key,\"mysql_bind_type_guessing\"))\n    imp_dbh->bind_type_guessing = SvTRUE(valuesv);\n  else if (kl == 31 && strEQ(key,\"mysql_bind_comment_placeholders\"))\n    imp_dbh->bind_type_guessing = SvTRUE(valuesv);\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  else if (kl == 17 && strEQ(key, \"mysql_enable_utf8\"))\n    imp_dbh->enable_utf8 = bool_value;\n#endif\n  else\n    return FALSE;\t\t\t\t/* Unknown key */\n\n  if (cacheit) /* cache value for later DBI 'quick' fetch? */\n    hv_store((HV*)SvRV(dbh), key, kl, cachesv, 0);\n  return TRUE;\n}\n\n/***************************************************************************\n *\n *  Name:    dbd_db_FETCH_attrib\n *\n *  Purpose: Function for fetching dbh attributes\n *\n *  Input:   dbh - database handle being queried\n *           imp_dbh - drivers private database handle data\n *           keysv - the attribute name\n *\n *  Returns: An SV*, if sucessfull; NULL otherwise\n *\n *  Notes:   Do not forget to call sv_2mortal in the former case!\n *\n **************************************************************************/\nstatic SV*\nmy_ulonglong2str(pTHX_ my_ulonglong val)\n{\n  char buf[64];\n  char *ptr = buf + sizeof(buf) - 1;\n\n  if (val == 0)\n    return newSVpv(\"0\", 1);\n\n  *ptr = '\\0';\n  while (val > 0)\n  {\n    *(--ptr) = ('0' + (val % 10));\n    val = val / 10;\n  }\n  return newSVpv(ptr, (buf+ sizeof(buf) - 1) - ptr);\n}\n\nSV* dbd_db_FETCH_attrib(SV *dbh, imp_dbh_t *imp_dbh, SV *keysv)\n{\n  dTHX;\n  STRLEN kl;\n  char *key = SvPV(keysv, kl);\n  char* fine_key = NULL;\n  SV* result = NULL;\n  dbh= dbh;\n\n  switch (*key) {\n    case 'A':\n      if (strEQ(key, \"AutoCommit\"))\n      {\n        if (imp_dbh->has_transactions)\n          return sv_2mortal(boolSV(DBIc_has(imp_dbh,DBIcf_AutoCommit)));\n        /* Default */\n        return &PL_sv_yes;\n      }\n      break;\n  }\n  if (strncmp(key, \"mysql_\", 6) == 0) {\n    fine_key = key;\n    key = key+6;\n    kl = kl-6;\n  }\n\n  /* MONTY:  Check if kl should not be used or used everywhere */\n  switch(*key) {\n  case 'a':\n    if (kl == strlen(\"auto_reconnect\") && strEQ(key, \"auto_reconnect\"))\n      result= sv_2mortal(newSViv(imp_dbh->auto_reconnect));\n    break;\n  case 'b':\n    if (kl == strlen(\"bind_type_guessing\") &&\n        strEQ(key, \"bind_type_guessing\"))\n    {\n      result = sv_2mortal(newSViv(imp_dbh->bind_type_guessing));\n    }\n    else if (kl == strlen(\"bind_comment_placeholders\") &&\n        strEQ(key, \"bind_comment_placeholders\"))\n    {\n      result = sv_2mortal(newSViv(imp_dbh->bind_comment_placeholders));\n    }\n    break;\n  case 'c':\n    if (kl == 10 && strEQ(key, \"clientinfo\"))\n    {\n      const char* clientinfo = mysql_get_client_info();\n      result= clientinfo ?\n        sv_2mortal(newSVpv(clientinfo, strlen(clientinfo))) : &PL_sv_undef;\n    }\n    else if (kl == 13 && strEQ(key, \"clientversion\"))\n    {\n      result= sv_2mortal(my_ulonglong2str(aTHX_ mysql_get_client_version()));\n    }\n    break;\n  case 'e':\n    if (strEQ(key, \"errno\"))\n      result= sv_2mortal(newSViv((IV)mysql_errno(imp_dbh->pmysql)));\n    else if ( strEQ(key, \"error\") || strEQ(key, \"errmsg\"))\n    {\n    /* Note that errmsg is obsolete, as of 2.09! */\n      const char* msg = mysql_error(imp_dbh->pmysql);\n      result= sv_2mortal(newSVpv(msg, strlen(msg)));\n    }\n    /* HELMUT */\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n    else if (kl == strlen(\"enable_utf8\") && strEQ(key, \"enable_utf8\"))\n        result = sv_2mortal(newSViv(imp_dbh->enable_utf8));\n#endif\n    break;\n\n  case 'd':\n    if (strEQ(key, \"dbd_stats\"))\n    {\n      HV* hv = newHV();\n      hv_store(\n               hv,\n               \"auto_reconnects_ok\",\n               strlen(\"auto_reconnects_ok\"),\n               newSViv(imp_dbh->stats.auto_reconnects_ok),\n               0\n              );\n      hv_store(\n               hv,\n               \"auto_reconnects_failed\",\n               strlen(\"auto_reconnects_failed\"),\n               newSViv(imp_dbh->stats.auto_reconnects_failed),\n               0\n              );\n\n      result= sv_2mortal((newRV_noinc((SV*)hv)));\n    }\n\n  case 'h':\n    if (strEQ(key, \"hostinfo\"))\n    {\n      const char* hostinfo = mysql_get_host_info(imp_dbh->pmysql);\n      result= hostinfo ?\n        sv_2mortal(newSVpv(hostinfo, strlen(hostinfo))) : &PL_sv_undef;\n    }\n    break;\n\n  case 'i':\n    if (strEQ(key, \"info\"))\n    {\n      const char* info = mysql_info(imp_dbh->pmysql);\n      result= info ? sv_2mortal(newSVpv(info, strlen(info))) : &PL_sv_undef;\n    }\n    else if (kl == 8  &&  strEQ(key, \"insertid\"))\n      /* We cannot return an IV, because the insertid is a long. */\n      result= sv_2mortal(my_ulonglong2str(aTHX_ mysql_insert_id(imp_dbh->pmysql)));\n    break;\n  case 'n':\n    if (kl == strlen(\"no_autocommit_cmd\") &&\n        strEQ(key, \"no_autocommit_cmd\"))\n      result = sv_2mortal(newSViv(imp_dbh->no_autocommit_cmd));\n    break;\n\n  case 'p':\n    if (kl == 9  &&  strEQ(key, \"protoinfo\"))\n      result= sv_2mortal(newSViv(mysql_get_proto_info(imp_dbh->pmysql)));\n    break;\n\n  case 's':\n    if (kl == 10 && strEQ(key, \"serverinfo\")) {\n      const char* serverinfo = mysql_get_server_info(imp_dbh->pmysql);\n      result= serverinfo ?\n        sv_2mortal(newSVpv(serverinfo, strlen(serverinfo))) : &PL_sv_undef;\n    } \n    else if (kl == 13 && strEQ(key, \"serverversion\"))\n      result= sv_2mortal(my_ulonglong2str(aTHX_ mysql_get_server_version(imp_dbh->pmysql)));\n    else if (strEQ(key, \"sock\"))\n      result= sv_2mortal(newSViv((IV) imp_dbh->pmysql));\n    else if (strEQ(key, \"sockfd\"))\n      result= sv_2mortal(newSViv((IV) imp_dbh->pmysql->net.fd));\n    else if (strEQ(key, \"stat\"))\n    {\n      const char* stats = mysql_stat(imp_dbh->pmysql);\n      result= stats ?\n        sv_2mortal(newSVpv(stats, strlen(stats))) : &PL_sv_undef;\n    }\n    else if (strEQ(key, \"stats\"))\n    {\n      /* Obsolete, as of 2.09 */\n      const char* stats = mysql_stat(imp_dbh->pmysql);\n      result= stats ?\n        sv_2mortal(newSVpv(stats, strlen(stats))) : &PL_sv_undef;\n    }\n    else if (kl == 14 && strEQ(key,\"server_prepare\"))\n        result= sv_2mortal(newSViv((IV) imp_dbh->use_server_side_prepare));\n    break;\n\n  case 't':\n    if (kl == 9  &&  strEQ(key, \"thread_id\"))\n      result= sv_2mortal(newSViv(mysql_thread_id(imp_dbh->pmysql)));\n    break;\n\n  case 'w':\n    if (kl == 13 && strEQ(key, \"warning_count\"))\n      result= sv_2mortal(newSViv(mysql_warning_count(imp_dbh->pmysql)));\n    break;\n  case 'u':\n    if (strEQ(key, \"use_result\"))\n    {\n      result= sv_2mortal(newSViv((IV) imp_dbh->use_mysql_use_result));\n    }\n    break;\n  }\n\n  if (result== NULL)\n    return Nullsv;\n\n  return result;\n}\n\n\n/* \n **************************************************************************\n *\n *  Name:    dbd_st_prepare\n *\n *  Purpose: Called for preparing an SQL statement; our part of the\n *           statement handle constructor\n *\n *  Input:   sth - statement handle being initialized\n *           imp_sth - drivers private statement handle data\n *           statement - pointer to string with SQL statement\n *           attribs - statement attributes, currently not in use\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error will\n *           be called in the latter case\n *\n **************************************************************************/\nint\ndbd_st_prepare(\n  SV *sth,\n  imp_sth_t *imp_sth,\n  char *statement,\n  SV *attribs)\n{\n  int i;\n  SV **svp;\n  dTHX;\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  char *str_ptr;\n  int col_type, prepare_retval, limit_flag=0;\n  MYSQL_BIND *bind, *bind_end;\n  imp_sth_phb_t *fbind;\n#endif\n  D_imp_xxh(sth);\n  D_imp_dbh_from_sth;\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                 \"\\t-> dbd_st_prepare MYSQL_VERSION_ID %d, SQL statement: %s\\n\",\n                  MYSQL_VERSION_ID, statement);\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n /* Set default value of 'mysql_server_prepare' attribute for sth from dbh */\n  imp_sth->use_server_side_prepare= imp_dbh->use_server_side_prepare;\n  if (attribs)\n  {\n    svp= DBD_ATTRIB_GET_SVP(attribs, \"mysql_server_prepare\", 20);\n    imp_sth->use_server_side_prepare = (svp) ?\n      SvTRUE(*svp) : imp_dbh->use_server_side_prepare;\n\n    svp = DBD_ATTRIB_GET_SVP(attribs, \"async\", 5);\n\n    if(svp && SvTRUE(*svp)) {\n#if MYSQL_ASYNC\n        imp_sth->is_async = TRUE;\n        imp_sth->use_server_side_prepare = FALSE;\n#else\n        do_error(sth, 2000,\n                 \"Async support was not built into this version of DBD::mysql\", \"HY000\");\n        return 0;\n#endif\n    }\n  }\n\n  imp_sth->fetch_done= 0;\n#endif\n\n  imp_sth->done_desc= 0;\n  imp_sth->result= NULL;\n  imp_sth->currow= 0;\n\n  /* Set default value of 'mysql_use_result' attribute for sth from dbh */\n  svp= DBD_ATTRIB_GET_SVP(attribs, \"mysql_use_result\", 16);\n  imp_sth->use_mysql_use_result= svp ?\n    SvTRUE(*svp) : imp_dbh->use_mysql_use_result;\n\n  for (i= 0; i < AV_ATTRIB_LAST; i++)\n    imp_sth->av_attr[i]= Nullav;\n\n  /*\n     Clean-up previous result set(s) for sth to prevent\n     'Commands out of sync' error \n  */\n  mysql_st_free_result_sets(sth, imp_sth);\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tuse_server_side_prepare set, check LIMIT\\n\");\n    /*\n      This code is here because mysql < 5.1 didn't support placeholders\n      in prepared statements and also we have to disable some statements\n      for PS mode\n    */ \n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tneed to test for LIMIT\\n\");\n    for (str_ptr= statement; *str_ptr; str_ptr++)\n    {\n      /* \n        Processing of multi-result-set is not possible due to lack\n        of some calls in PS API. CALL() statement is disabled for PS\n        mode as it may cause multi-resut-set.\n      */\n\n      if ( (tolower(*(str_ptr + 0)) == 'c') &&\n           (tolower(*(str_ptr + 1)) == 'a') &&\n           (tolower(*(str_ptr + 2)) == 'l') &&\n           (tolower(*(str_ptr + 3)) == 'l') &&\n           (tolower(*(str_ptr + 4)) == ' '))\n      {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Disable PS mode for CALL()\\n\");\n        imp_sth->use_server_side_prepare= 0;\n      }\n\n#if MYSQL_VERSION_ID < LIMIT_PLACEHOLDER_VERSION\n      /*\n        If there is a 'limit' in the statement and placeholders are\n        NOT supported\n      */\n      if ( (tolower(*(str_ptr + 0)) == 'l') &&\n           (tolower(*(str_ptr + 1)) == 'i') &&\n           (tolower(*(str_ptr + 2)) == 'm') &&\n           (tolower(*(str_ptr + 3)) == 'i') &&\n           (tolower(*(str_ptr + 4)) == 't'))\n      {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"LIMIT set limit flag to 1\\n\");\n        limit_flag= 1;\n      }\n\n      if (limit_flag)\n      {\n        /* ... and place holders after the limit flag is set... */\n        if (*str_ptr == '?')\n        {\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tLIMIT and ? found, set to use_server_side_prepare=0\\n\");\n          /* ... then we do not want to try server side prepare (use emulation) */\n          imp_sth->use_server_side_prepare= 0;\n          break;\n        }\n      }\n#endif\n    }\n  }\n#endif\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tuse_server_side_prepare set\\n\");\n    /* do we really need this? If we do, we should return, not just continue */\n    if (imp_sth->stmt)\n      fprintf(stderr,\n              \"ERROR: Trying to prepare new stmt while we have \\\n              already not closed one \\n\");\n\n    imp_sth->stmt= mysql_stmt_init(imp_dbh->pmysql);\n\n    if (! imp_sth->stmt)\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                      \"\\t\\tERROR: Unable to return MYSQL_STMT structure \\\n                      from mysql_stmt_init(): ERROR NO: %d ERROR MSG:%s\\n\",\n                      mysql_errno(imp_dbh->pmysql),\n                      mysql_error(imp_dbh->pmysql));\n    }\n\n    prepare_retval= mysql_stmt_prepare(imp_sth->stmt,\n                                       statement,\n                                       strlen(statement));\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                      \"\\t\\tmysql_stmt_prepare returned %d\\n\",\n                      prepare_retval);\n\n    if (prepare_retval)\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                      \"\\t\\tmysql_stmt_prepare %d %s\\n\",\n                      mysql_stmt_errno(imp_sth->stmt),\n                      mysql_stmt_error(imp_sth->stmt));\n\n      /* For commands that are not supported by server side prepared statement\n         mechanism lets try to pass them through regular API */\n      if (mysql_stmt_errno(imp_sth->stmt) == ER_UNSUPPORTED_PS)\n      {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tSETTING imp_sth->use_server_side_prepare to 0\\n\");\n        imp_sth->use_server_side_prepare= 0;\n      }\n      else\n      {\n        do_error(sth, mysql_stmt_errno(imp_sth->stmt),\n                 mysql_stmt_error(imp_sth->stmt),\n                mysql_sqlstate(imp_dbh->pmysql));\n        mysql_stmt_close(imp_sth->stmt);\n        imp_sth->stmt= NULL;\n        return FALSE;\n      }\n    }\n    else\n    {\n      DBIc_NUM_PARAMS(imp_sth)= mysql_stmt_param_count(imp_sth->stmt);\n      /* mysql_stmt_param_count */\n\n      if (DBIc_NUM_PARAMS(imp_sth) > 0)\n      {\n        int has_statement_fields= imp_sth->stmt->fields != 0;\n        /* Allocate memory for bind variables */\n        imp_sth->bind=            alloc_bind(DBIc_NUM_PARAMS(imp_sth));\n        imp_sth->fbind=           alloc_fbind(DBIc_NUM_PARAMS(imp_sth));\n        imp_sth->has_been_bound=  0;\n\n        /* Initialize ph variables with  NULL values */\n        for (i= 0,\n             bind=      imp_sth->bind,\n             fbind=     imp_sth->fbind,\n             bind_end=  bind+DBIc_NUM_PARAMS(imp_sth);\n             bind < bind_end ;\n             bind++, fbind++, i++ )\n        {\n          /*\n            if this statement has a result set, field types will be\n            correctly identified. If there is no result set, such as\n            with an INSERT, fields will not be defined, and all buffer_type\n            will default to MYSQL_TYPE_VAR_STRING\n          */\n          col_type= (has_statement_fields ?\n                     imp_sth->stmt->fields[i].type : MYSQL_TYPE_STRING);\n\n          bind->buffer_type=  mysql_to_perl_type(col_type);\n\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tmysql_to_perl_type returned %d\\n\", col_type);\n\n          bind->buffer=       NULL;\n          bind->length=       &(fbind->length);\n          bind->is_null=      (char*) &(fbind->is_null);\n          fbind->is_null=     1;\n          fbind->length=      0;\n        }\n      }\n    }\n  }\n#endif\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  /* Count the number of parameters (driver, vs server-side) */\n  if (imp_sth->use_server_side_prepare == 0)\n    DBIc_NUM_PARAMS(imp_sth) = count_params((imp_xxh_t *)imp_dbh, aTHX_ statement,\n                                            imp_dbh->bind_comment_placeholders);\n#else\n  DBIc_NUM_PARAMS(imp_sth) = count_params((imp_xxh_t *)imp_dbh, aTHX_ statement,\n                                          imp_dbh->bind_comment_placeholders);\n#endif\n\n  /* Allocate memory for parameters */\n  imp_sth->params= alloc_param(DBIc_NUM_PARAMS(imp_sth));\n  DBIc_IMPSET_on(imp_sth);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_prepare\\n\");\n  return 1;\n}\n\n/***************************************************************************\n * Name: dbd_st_free_result_sets\n *\n * Purpose: Clean-up single or multiple result sets (if any)\n *\n * Inputs: sth - Statement handle\n *         imp_sth - driver's private statement handle\n *\n * Returns: 1 ok\n *          0 error\n *************************************************************************/\nint mysql_st_free_result_sets (SV * sth, imp_sth_t * imp_sth)\n{\n  dTHX;\n  D_imp_dbh_from_sth;\n  D_imp_xxh(sth);\n  int next_result_rc= -1;\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t>- dbd_st_free_result_sets\\n\");\n\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n  do\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets RC %d\\n\", next_result_rc);\n\n    if (next_result_rc == 0)\n    {\n      if (!(imp_sth->result = mysql_use_result(imp_dbh->pmysql)))\n      {\n        /* Check for possible error */\n        if (mysql_field_count(imp_dbh->pmysql))\n        {\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets ERROR: %s\\n\",\n                                  mysql_error(imp_dbh->pmysql));\n\n          do_error(sth, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\n                   mysql_sqlstate(imp_dbh->pmysql));\n          return 0;\n        }\n      }\n    }\n    if (imp_sth->result)\n    {\n      mysql_free_result(imp_sth->result);\n      imp_sth->result=NULL;\n    }\n  } while ((next_result_rc=mysql_next_result(imp_dbh->pmysql))==0);\n\n  if (next_result_rc > 0)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets: Error while processing multi-result set: %s\\n\",\n                    mysql_error(imp_dbh->pmysql));\n\n    do_error(sth, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\n             mysql_sqlstate(imp_dbh->pmysql));\n  }\n\n#else\n\n  if (imp_sth->result)\n  {\n    mysql_free_result(imp_sth->result);\n    imp_sth->result=NULL;\n  }\n#endif\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets\\n\");\n\n  return 1;\n}\n\n\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n/***************************************************************************\n * Name: dbd_st_more_results\n *\n * Purpose: Move onto the next result set (if any)\n *\n * Inputs: sth - Statement handle\n *         imp_sth - driver's private statement handle\n *\n * Returns: 1 if there are more results sets\n *          0 if there are not\n *         -1 for errors.\n *************************************************************************/\nint dbd_st_more_results(SV* sth, imp_sth_t* imp_sth)\n{\n  dTHX;\n  D_imp_dbh_from_sth;\n  D_imp_xxh(sth);\n\n  int use_mysql_use_result=imp_sth->use_mysql_use_result;\n  int next_result_return_code, i;\n  MYSQL* svsock= imp_dbh->pmysql;\n\n  if (!SvROK(sth) || SvTYPE(SvRV(sth)) != SVt_PVHV)\n    croak(\"Expected hash array\");\n\n  if (!mysql_more_results(svsock))\n  {\n    /* No more pending result set(s)*/\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t    \"\\n      <- dbs_st_more_results no more results\\n\");\n    return 0;\n  }\n\n  if (imp_sth->use_server_side_prepare)\n  {\n    do_warn(sth, JW_ERR_NOT_IMPLEMENTED,\n            \"Processing of multiple result set is not possible with server side prepare\");\n    return 0;\n  }\n\n  /*\n   *  Free cached array attributes\n   */\n  for (i= 0; i < AV_ATTRIB_LAST;  i++)\n  {\n    if (imp_sth->av_attr[i])\n      SvREFCNT_dec(imp_sth->av_attr[i]);\n\n    imp_sth->av_attr[i]= Nullav;\n  }\n\n  /* Release previous MySQL result*/\n  if (imp_sth->result)\n    mysql_free_result(imp_sth->result);\n\n  if (DBIc_ACTIVE(imp_sth))\n    DBIc_ACTIVE_off(imp_sth);\n\n  next_result_return_code= mysql_next_result(svsock);\n\n  imp_sth->warning_count = mysql_warning_count(imp_dbh->pmysql);\n\n  /*\n    mysql_next_result returns\n      0 if there are more results\n     -1 if there are no more results\n     >0 if there was an error\n   */\n  if (next_result_return_code > 0)\n  {\n    do_error(sth, mysql_errno(svsock), mysql_error(svsock),\n             mysql_sqlstate(svsock));\n\n    return 0;\n  }\n  else if(next_result_return_code == -1)                                                                                                                  \n  {                                                                                                                                                       \n    return 0;                                                                                                                                             \n  }  \n  else\n  {\n    /* Store the result from the Query */\n    imp_sth->result = use_mysql_use_result ?\n     mysql_use_result(svsock) : mysql_store_result(svsock);\n\n    if (mysql_errno(svsock))\n    {\n      do_error(sth, mysql_errno(svsock), mysql_error(svsock), \n               mysql_sqlstate(svsock));\n      return 0;\n    }\n\n    imp_sth->row_num= mysql_affected_rows(imp_dbh->pmysql);\n\n    if (imp_sth->result == NULL)\n    {\n      /* No \"real\" rowset*/\n      DBIc_NUM_FIELDS(imp_sth)= 0; /* for DBI <= 1.53 */\n      DBIS->set_attr_k(sth, sv_2mortal(newSVpvn(\"NUM_OF_FIELDS\",13)), 0,\n\t\t\t               sv_2mortal(newSViv(0)));\n      return 1;\n    }\n    else\n    {\n      /* We have a new rowset */\n      imp_sth->currow=0;\n\n\n      /* delete cached handle attributes */\n      /* XXX should be driven by a list to ease maintenance */\n      hv_delete((HV*)SvRV(sth), \"NAME\", 4, G_DISCARD);\n      hv_delete((HV*)SvRV(sth), \"NULLABLE\", 8, G_DISCARD);\n      hv_delete((HV*)SvRV(sth), \"NUM_OF_FIELDS\", 13, G_DISCARD);\n      hv_delete((HV*)SvRV(sth), \"PRECISION\", 9, G_DISCARD);\n      hv_delete((HV*)SvRV(sth), \"SCALE\", 5, G_DISCARD);\n      hv_delete((HV*)SvRV(sth), \"TYPE\", 4, G_DISCARD);\n      hv_delete((HV*)SvRV(sth), \"mysql_insertid\", 14, G_DISCARD);\n      hv_delete((HV*)SvRV(sth), \"mysql_is_auto_increment\", 23, G_DISCARD);\n      hv_delete((HV*)SvRV(sth), \"mysql_is_blob\", 13, G_DISCARD);\n      hv_delete((HV*)SvRV(sth), \"mysql_is_key\", 12, G_DISCARD);\n      hv_delete((HV*)SvRV(sth), \"mysql_is_num\", 12, G_DISCARD);\n      hv_delete((HV*)SvRV(sth), \"mysql_is_pri_key\", 16, G_DISCARD);\n      hv_delete((HV*)SvRV(sth), \"mysql_length\", 12, G_DISCARD);\n      hv_delete((HV*)SvRV(sth), \"mysql_max_length\", 16, G_DISCARD);\n      hv_delete((HV*)SvRV(sth), \"mysql_table\", 11, G_DISCARD);\n      hv_delete((HV*)SvRV(sth), \"mysql_type\", 10, G_DISCARD);\n      hv_delete((HV*)SvRV(sth), \"mysql_type_name\", 15, G_DISCARD);\n      hv_delete((HV*)SvRV(sth), \"mysql_warning_count\", 20, G_DISCARD);\n\n      /* Adjust NUM_OF_FIELDS - which also adjusts the row buffer size */\n      DBIc_NUM_FIELDS(imp_sth)= 0; /* for DBI <= 1.53 */\n      DBIc_DBISTATE(imp_sth)->set_attr_k(sth, sv_2mortal(newSVpvn(\"NUM_OF_FIELDS\",13)), 0,\n          sv_2mortal(newSViv(mysql_num_fields(imp_sth->result)))\n      );\n\n      DBIc_ACTIVE_on(imp_sth);\n\n      imp_sth->done_desc = 0;\n    }\n    imp_dbh->pmysql->net.last_errno= 0;\n    return 1;\n  }\n}\n#endif\n/**************************************************************************\n *\n *  Name:    mysql_st_internal_execute\n *\n *  Purpose: Internal version for executing a statement, called both from\n *           within the \"do\" and the \"execute\" method.\n *\n *  Inputs:  h - object handle, for storing error messages\n *           statement - query being executed\n *           attribs - statement attributes, currently ignored\n *           num_params - number of parameters being bound\n *           params - parameter array\n *           result - where to store results, if any\n *           svsock - socket connected to the database\n *\n **************************************************************************/\n\n\nmy_ulonglong mysql_st_internal_execute(\n                                       SV *h, /* could be sth or dbh */\n                                       SV *statement,\n                                       SV *attribs,\n                                       int num_params,\n                                       imp_sth_ph_t *params,\n                                       MYSQL_RES **result,\n                                       MYSQL *svsock,\n                                       int use_mysql_use_result\n                                      )\n{\n  dTHX;\n  bool bind_type_guessing= FALSE;\n  bool bind_comment_placeholders= TRUE;\n  STRLEN slen;\n  char *sbuf = SvPV(statement, slen);\n  char *table;\n  char *salloc;\n  int htype;\n  int errno;\n#if MYSQL_ASYNC\n  bool async = FALSE;\n#endif\n  my_ulonglong rows= 0;\n  /* thank you DBI.c for this info! */\n  D_imp_xxh(h);\n  attribs= attribs;\n\n  htype= DBIc_TYPE(imp_xxh);\n  /*\n    It is important to import imp_dbh properly according to the htype\n    that it is! Also, one might ask why bind_type_guessing is assigned\n    in each block. Well, it's because D_imp_ macros called in these\n    blocks make it so imp_dbh is not \"visible\" or defined outside of the\n    if/else (when compiled, it fails for imp_dbh not being defined).\n  */\n  /* h is a dbh */\n  if (htype == DBIt_DB)\n  {\n    D_imp_dbh(h);\n    /* if imp_dbh is not available, it causes segfault (proper) on OpenBSD */\n    if (imp_dbh && imp_dbh->bind_type_guessing)\n    {\n      bind_type_guessing= imp_dbh->bind_type_guessing;\n      bind_comment_placeholders= bind_comment_placeholders;\n    }\n#if MYSQL_ASYNC\n    async = (bool) (imp_dbh->async_query_in_flight != NULL);\n#endif\n  }\n  /* h is a sth */\n  else\n  {\n    D_imp_sth(h);\n    D_imp_dbh_from_sth;\n    /* if imp_dbh is not available, it causes segfault (proper) on OpenBSD */\n    if (imp_dbh)\n    {\n      bind_type_guessing= imp_dbh->bind_type_guessing;\n      bind_comment_placeholders= imp_dbh->bind_comment_placeholders;\n    }\n#if MYSQL_ASYNC\n    async = imp_sth->is_async;\n    if(async) {\n        imp_dbh->async_query_in_flight = imp_sth;\n    } else {\n        imp_dbh->async_query_in_flight = NULL;\n    }\n#endif\n  }\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"mysql_st_internal_execute MYSQL_VERSION_ID %d\\n\",\n                  MYSQL_VERSION_ID );\n\n  salloc= parse_params(imp_xxh,\n                              aTHX_ svsock,\n                              sbuf,\n                              &slen,\n                              params,\n                              num_params,\n                              bind_type_guessing,\n                              bind_comment_placeholders);\n\n  if (salloc)\n  {\n    sbuf= salloc;\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Binding parameters: %s\\n\", sbuf);\n  }\n\n  if (slen >= 11 && (!strncmp(sbuf, \"listfields \", 11) ||\n                     !strncmp(sbuf, \"LISTFIELDS \", 11)))\n  {\n    /* remove pre-space */\n    slen-= 10;\n    sbuf+= 10;\n    while (slen && isspace(*sbuf)) { --slen;  ++sbuf; }\n\n    if (!slen)\n    {\n      do_error(h, JW_ERR_QUERY, \"Missing table name\" ,NULL);\n      return -2;\n    }\n    if (!(table= malloc(slen+1)))\n    {\n      do_error(h, JW_ERR_MEM, \"Out of memory\" ,NULL);\n      return -2;\n    }\n\n    strncpy(table, sbuf, slen);\n    sbuf= table;\n\n    while (slen && !isspace(*sbuf))\n    {\n      --slen;\n      ++sbuf;\n    }\n    *sbuf++= '\\0';\n\n    *result= mysql_list_fields(svsock, table, NULL);\n\n    free(table);\n\n    if (!(*result))\n    {\n      do_error(h, mysql_errno(svsock), mysql_error(svsock)\n               ,mysql_sqlstate(svsock));\n      return -2;\n    }\n\n    return 0;\n  }\n\n#if MYSQL_ASYNC\n  if(async) {\n    if((mysql_send_query(svsock, sbuf, slen)) &&\n       (!mysql_db_reconnect(h) ||\n        (mysql_send_query(svsock, sbuf, slen))))\n    {\n        rows = -2;\n    } else {\n        rows = 0;\n    }\n  } else {\n#endif\n      if ((mysql_real_query(svsock, sbuf, slen))  &&\n          (!mysql_db_reconnect(h)  ||\n           (mysql_real_query(svsock, sbuf, slen))))\n      {\n        rows = -2;\n      } else {\n          /** Store the result from the Query */\n          *result= use_mysql_use_result ?\n            mysql_use_result(svsock) : mysql_store_result(svsock);\n\n          if (mysql_errno(svsock))\n            do_error(h, mysql_errno(svsock), mysql_error(svsock)\n                     ,mysql_sqlstate(svsock));\n\n          if (!*result)\n            rows= mysql_affected_rows(svsock);\n          else\n            rows= mysql_num_rows(*result);\n      }\n#if MYSQL_ASYNC\n  }\n#endif\n\n  if (salloc)\n    Safefree(salloc);\n\n  if(rows == -2) {\n    do_error(h, mysql_errno(svsock), mysql_error(svsock), \n             mysql_sqlstate(svsock));\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"IGNORING ERROR errno %d\\n\", errno);\n    rows = -2;\n  }\n  return(rows);\n}\n\n /**************************************************************************\n *\n *  Name:    mysql_st_internal_execute41\n *\n *  Purpose: Internal version for executing a prepared statement, called both\n *           from within the \"do\" and the \"execute\" method.\n *           MYSQL 4.1 API\n *\n *\n *  Inputs:  h - object handle, for storing error messages\n *           statement - query being executed\n *           attribs - statement attributes, currently ignored\n *           num_params - number of parameters being bound\n *           params - parameter array\n *           result - where to store results, if any\n *           svsock - socket connected to the database\n *\n **************************************************************************/\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n\nmy_ulonglong mysql_st_internal_execute41(\n                                         SV *sth,\n                                         int num_params,\n                                         MYSQL_RES **result,\n                                         MYSQL_STMT *stmt,\n                                         MYSQL_BIND *bind,\n                                         int *has_been_bound\n                                        )\n{\n  int i;\n  enum enum_field_types enum_type;\n  dTHX;\n  int execute_retval;\n  my_ulonglong rows=0;\n  D_imp_xxh(sth);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t-> mysql_st_internal_execute41\\n\");\n\n  /* free result if exists */\n  if (*result)\n  {\n    mysql_free_result(*result);\n    *result= 0;\n  }\n\n  /*\n    If were performed any changes with ph variables\n    we have to rebind them\n  */\n\n  if (num_params > 0 && !(*has_been_bound))\n  {\n    if (mysql_stmt_bind_param(stmt,bind))\n      goto error;\n\n    *has_been_bound= 1;\n  }\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t\\tmysql_st_internal_execute41 calling mysql_execute with %d num_params\\n\",\n                  num_params);\n\n  execute_retval= mysql_stmt_execute(stmt);\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t\\tmysql_stmt_execute returned %d\\n\",\n                  execute_retval);\n  if (execute_retval)\n    goto error;\n\n  /*\n   This statement does not return a result set (INSERT, UPDATE...)\n  */\n  if (!(*result= mysql_stmt_result_metadata(stmt)))\n  {\n    if (mysql_stmt_errno(stmt))\n      goto error;\n\n    rows= mysql_stmt_affected_rows(stmt);\n  }\n  /*\n    This statement returns a result set (SELECT...)\n  */\n  else\n  {\n    for (i = mysql_stmt_field_count(stmt) - 1; i >=0; --i) {\n        enum_type = mysql_to_perl_type(stmt->fields[i].type);\n        if (enum_type != MYSQL_TYPE_DOUBLE && enum_type != MYSQL_TYPE_LONG)\n        {\n            /* mysql_stmt_store_result to update MYSQL_FIELD->max_length */\n            my_bool on = 1;\n            mysql_stmt_attr_set(stmt, STMT_ATTR_UPDATE_MAX_LENGTH, &on);\n            break;\n        }\n    }\n    /* Get the total rows affected and return */\n    if (mysql_stmt_store_result(stmt))\n      goto error;\n    else\n      rows= mysql_stmt_num_rows(stmt);\n  }\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t<- mysql_internal_execute_41 returning %d rows\\n\",\n                  (int) rows);\n  return(rows);\n\nerror:\n  if (*result)\n  {\n    mysql_free_result(*result);\n    *result= 0;\n  }\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"     errno %d err message %s\\n\",\n                  mysql_stmt_errno(stmt),\n                  mysql_stmt_error(stmt));\n  do_error(sth, mysql_stmt_errno(stmt), mysql_stmt_error(stmt),\n           mysql_stmt_sqlstate(stmt));\n  mysql_stmt_reset(stmt);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t<- mysql_st_internal_execute41\\n\");\n  return -2;\n\n}\n#endif\n\n\n/***************************************************************************\n *\n *  Name:    dbd_st_execute\n *\n *  Purpose: Called for preparing an SQL statement; our part of the\n *           statement handle constructor\n *\n *  Input:   sth - statement handle being initialized\n *           imp_sth - drivers private statement handle data\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error will\n *           be called in the latter case\n *\n **************************************************************************/\n\nint dbd_st_execute(SV* sth, imp_sth_t* imp_sth)\n{\n  dTHX;\n  char actual_row_num[64];\n  int i;\n  SV **statement;\n  D_imp_dbh_from_sth;\n  D_imp_xxh(sth);\n#if defined (dTHR)\n  dTHR;\n#endif\n\n  ASYNC_CHECK_RETURN(sth, -2);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n      \" -> dbd_st_execute for %08lx\\n\", (u_long) sth);\n\n  if (!SvROK(sth)  ||  SvTYPE(SvRV(sth)) != SVt_PVHV)\n    croak(\"Expected hash array\");\n\n  /* Free cached array attributes */\n  for (i= 0;  i < AV_ATTRIB_LAST;  i++)\n  {\n    if (imp_sth->av_attr[i])\n      SvREFCNT_dec(imp_sth->av_attr[i]);\n\n    imp_sth->av_attr[i]= Nullav;\n  }\n\n  statement= hv_fetch((HV*) SvRV(sth), \"Statement\", 9, FALSE);\n\n  /* \n     Clean-up previous result set(s) for sth to prevent\n     'Commands out of sync' error \n  */\n  mysql_st_free_result_sets (sth, imp_sth);\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n\n  if (imp_sth->use_server_side_prepare && ! imp_sth->use_mysql_use_result)\n  {\n    imp_sth->row_num= mysql_st_internal_execute41(\n                                                  sth,\n                                                  DBIc_NUM_PARAMS(imp_sth),\n                                                  &imp_sth->result,\n                                                  imp_sth->stmt,\n                                                  imp_sth->bind,\n                                                  &imp_sth->has_been_bound\n                                                 );\n  }\n  else {\n#endif\n    imp_sth->row_num= mysql_st_internal_execute(\n                                                sth,\n                                                *statement,\n                                                NULL,\n                                                DBIc_NUM_PARAMS(imp_sth),\n                                                imp_sth->params,\n                                                &imp_sth->result,\n                                                imp_dbh->pmysql,\n                                                imp_sth->use_mysql_use_result\n                                               );\n#if MYSQL_ASYNC\n    if(imp_dbh->async_query_in_flight) {\n        DBIc_ACTIVE_on(imp_sth);\n        return 0;\n    }\n#endif\n  }\n\n  if (imp_sth->row_num+1 != (my_ulonglong)-1)\n  {\n    if (!imp_sth->result)\n    {\n      imp_sth->insertid= mysql_insert_id(imp_dbh->pmysql);\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n      if (mysql_more_results(imp_dbh->pmysql))\n        DBIc_ACTIVE_on(imp_sth);\n#endif\n    }\n    else\n    {\n      /** Store the result in the current statement handle */\n      DBIc_NUM_FIELDS(imp_sth)= mysql_num_fields(imp_sth->result);\n      DBIc_ACTIVE_on(imp_sth);\n      if (!imp_sth->use_server_side_prepare)\n        imp_sth->done_desc= 0;\n      imp_sth->fetch_done= 0;\n    }\n  }\n\n  imp_sth->warning_count = mysql_warning_count(imp_dbh->pmysql);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n  {\n    /* \n      PerlIO_printf doesn't always handle imp_sth->row_num %llu \n      consistantly!!\n    */\n    sprintf(actual_row_num, \"%llu\", imp_sth->row_num);\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \" <- dbd_st_execute returning imp_sth->row_num %s\\n\",\n                  actual_row_num);\n  }\n\n  return (int)imp_sth->row_num;\n}\n\n /**************************************************************************\n *\n *  Name:    dbd_describe\n *\n *  Purpose: Called from within the fetch method to describe the result\n *\n *  Input:   sth - statement handle being initialized\n *           imp_sth - our part of the statement handle, there's no\n *               need for supplying both; Tim just doesn't remove it\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error will\n *           be called in the latter case\n *\n **************************************************************************/\n\nint dbd_describe(SV* sth, imp_sth_t* imp_sth)\n{\n  dTHX;\n  D_imp_xxh(sth);\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t--> dbd_describe\\n\");\n\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n\n  if (imp_sth->use_server_side_prepare)\n  {\n    int i;\n    int col_type;\n    int num_fields= DBIc_NUM_FIELDS(imp_sth);\n    imp_sth_fbh_t *fbh;\n    MYSQL_BIND *buffer;\n    MYSQL_FIELD *fields;\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_describe() num_fields %d\\n\",\n                    num_fields);\n\n    if (imp_sth->done_desc)\n      return TRUE;\n\n    if (!num_fields || !imp_sth->result)\n    {\n      /* no metadata */\n      do_error(sth, JW_ERR_SEQUENCE,\n               \"no metadata information while trying describe result set\",\n               NULL);\n      return 0;\n    }\n\n    /* allocate fields buffers  */\n    if (  !(imp_sth->fbh= alloc_fbuffer(num_fields))\n          || !(imp_sth->buffer= alloc_bind(num_fields)) )\n    {\n      /* Out of memory */\n      do_error(sth, JW_ERR_SEQUENCE,\n               \"Out of memory in dbd_sescribe()\",NULL);\n      return 0;\n    }\n\n    fields= mysql_fetch_fields(imp_sth->result);\n\n    for (\n         fbh= imp_sth->fbh, buffer= (MYSQL_BIND*)imp_sth->buffer, i= 0;\n         i < num_fields;\n         i++, fbh++, buffer++\n        )\n    {\n      /* get the column type */\n      col_type = fields ? fields[i].type : MYSQL_TYPE_STRING;\n\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      {\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\ti %d col_type %d fbh->length %d\\n\",\n                      i, col_type, (int) fbh->length);\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                      \"\\t\\tfields[i].length %lu fields[i].max_length %lu fields[i].type %d fields[i].charsetnr %d\\n\",\n                      (long unsigned int) fields[i].length, (long unsigned int) fields[i].max_length, fields[i].type,\n                      fields[i].charsetnr);\n      }\n      fbh->charsetnr = fields[i].charsetnr;\n#if MYSQL_VERSION_ID < FIELD_CHARSETNR_VERSION \n      fbh->flags     = fields[i].flags;\n#endif\n\n      buffer->buffer_type= mysql_to_perl_type(col_type);\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tmysql_to_perl_type returned %d\\n\",\n                      col_type);\n      buffer->length= &(fbh->length);\n      buffer->is_null= (char*) &(fbh->is_null);\n\n      switch (buffer->buffer_type) {\n      case MYSQL_TYPE_DOUBLE:\n        buffer->buffer_length= sizeof(fbh->ddata);\n        buffer->buffer= (char*) &fbh->ddata;\n        break;\n\n      case MYSQL_TYPE_LONG:\n        buffer->buffer_length= sizeof(fbh->ldata);\n        buffer->buffer= (char*) &fbh->ldata;\n        buffer->is_unsigned= (fields[i].flags & UNSIGNED_FLAG) ? 1 : 0;\n        break;\n\n      default:\n        buffer->buffer_length= fields[i].max_length ? fields[i].max_length : 1;\n        Newz(908, fbh->data, buffer->buffer_length, char);\n        buffer->buffer= (char *) fbh->data;\n      }\n    }\n\n    if (mysql_stmt_bind_result(imp_sth->stmt, imp_sth->buffer))\n    {\n      do_error(sth, mysql_stmt_errno(imp_sth->stmt),\n               mysql_stmt_error(imp_sth->stmt),\n               mysql_stmt_sqlstate(imp_sth->stmt));\n      return 0;\n    }\n  }\n#endif\n\n  imp_sth->done_desc= 1;\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_describe\\n\");\n  return TRUE;\n}\n\n/**************************************************************************\n *\n *  Name:    dbd_st_fetch\n *\n *  Purpose: Called for fetching a result row\n *\n *  Input:   sth - statement handle being initialized\n *           imp_sth - drivers private statement handle data\n *\n *  Returns: array of columns; the array is allocated by DBI via\n *           DBIc_DBISTATE(imp_sth)->get_fbav(imp_sth), even the values\n *           of the array are prepared, we just need to modify them\n *           appropriately\n *\n **************************************************************************/\n\nAV*\ndbd_st_fetch(SV *sth, imp_sth_t* imp_sth)\n{\n  dTHX;\n  int num_fields, ChopBlanks, i, rc;\n  unsigned long *lengths;\n  AV *av;\n  int av_length, av_readonly;\n  MYSQL_ROW cols;\n  D_imp_dbh_from_sth;\n  MYSQL* svsock= imp_dbh->pmysql;\n  imp_sth_fbh_t *fbh;\n  D_imp_xxh(sth);\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  MYSQL_BIND *buffer;\n#endif\n  MYSQL_FIELD *fields;\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t-> dbd_st_fetch\\n\");\n\n#if MYSQL_ASYNC\n  if(imp_dbh->async_query_in_flight) {\n      if(mysql_db_async_result(sth, &imp_sth->result) <= 0) {\n        return Nullav;\n      }\n  }\n#endif\n\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (!DBIc_ACTIVE(imp_sth) )\n    {\n      do_error(sth, JW_ERR_SEQUENCE, \"no statement executing\\n\",NULL);\n      return Nullav;\n    }\n\n    if (imp_sth->fetch_done)\n    {\n      do_error(sth, JW_ERR_SEQUENCE, \"fetch() but fetch already done\",NULL);\n      return Nullav;\n    }\n\n    if (!imp_sth->done_desc)\n    {\n      if (!dbd_describe(sth, imp_sth))\n      {\n        do_error(sth, JW_ERR_SEQUENCE, \"Error while describe result set.\",\n                 NULL);\n        return Nullav;\n      }\n    }\n  }\n#endif\n\n  ChopBlanks = DBIc_is(imp_sth, DBIcf_ChopBlanks);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t\\tdbd_st_fetch for %08lx, chopblanks %d\\n\",\n                  (u_long) sth, ChopBlanks);\n\n  if (!imp_sth->result)\n  {\n    do_error(sth, JW_ERR_SEQUENCE, \"fetch() without execute()\" ,NULL);\n    return Nullav;\n  }\n\n  /* fix from 2.9008 */\n  imp_dbh->pmysql->net.last_errno = 0;\n\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch calling mysql_fetch\\n\");\n\n    if ((rc= mysql_stmt_fetch(imp_sth->stmt)))\n    {\n      if (rc == 1)\n        do_error(sth, mysql_stmt_errno(imp_sth->stmt),\n                 mysql_stmt_error(imp_sth->stmt),\n                mysql_stmt_sqlstate(imp_sth->stmt));\n\n#if MYSQL_VERSION_ID >= MYSQL_VERSION_5_0 \n      if (rc == MYSQL_DATA_TRUNCATED)\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch data truncated\\n\");\n#endif\n\n      if (rc == MYSQL_NO_DATA)\n      {\n        /* Update row_num to affected_rows value */\n        imp_sth->row_num= mysql_stmt_affected_rows(imp_sth->stmt);\n        imp_sth->fetch_done=1;\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch no data\\n\");\n      }\n\n      dbd_st_finish(sth, imp_sth);\n\n      return Nullav;\n    }\n\n    imp_sth->currow++;\n\n    av= DBIc_DBISTATE(imp_sth)->get_fbav(imp_sth);\n    num_fields=mysql_stmt_field_count(imp_sth->stmt);\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tdbd_st_fetch called mysql_fetch, rc %d num_fields %d\\n\",\n                    rc, num_fields);\n\n    for (\n         buffer= imp_sth->buffer,\n         fbh= imp_sth->fbh,\n         i= 0;\n         i < num_fields;\n         i++,\n         fbh++,\n         buffer++\n        )\n    {\n      SV *sv= AvARRAY(av)[i]; /* Note: we (re)use the SV in the AV\t*/\n      STRLEN len;\n\n      /* This is wrong, null is not being set correctly\n       * This is not the way to determine length (this would break blobs!)\n       */\n      if (fbh->is_null)\n        (void) SvOK_off(sv);  /*  Field is NULL, return undef  */\n      else\n      {\n        /* In case of BLOB/TEXT fields we allocate only 8192 bytes\n           in dbd_describe() for data. Here we know real size of field\n           so we should increase buffer size and refetch column value\n        */\n        if (fbh->length > buffer->buffer_length)\n        {\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\tRefetch BLOB/TEXT column: %d\\n\", i);\n\n          Renew(fbh->data, fbh->length, char);\n          buffer->buffer_length= fbh->length;\n          buffer->buffer= (char *) fbh->data;\n\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\tbuffer->buffer: %s\\n\", (char *) buffer->buffer);\n\n          /*TODO: Use offset instead of 0 to fetch only remain part of data*/\n          if (mysql_stmt_fetch_column(imp_sth->stmt, buffer , i, 0))\n            do_error(sth, mysql_stmt_errno(imp_sth->stmt),\n                     mysql_stmt_error(imp_sth->stmt),\n                     mysql_stmt_sqlstate(imp_sth->stmt));\n        }\n\n        /* This does look a lot like Georg's PHP driver doesn't it?  --Brian */\n        /* Credit due to Georg - mysqli_api.c  ;) --PMG */\n        switch (buffer->buffer_type) {\n        case MYSQL_TYPE_DOUBLE:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tst_fetch double data %f\\n\", fbh->ddata);\n          sv_setnv(sv, fbh->ddata);\n          break;\n\n        case MYSQL_TYPE_LONG:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tst_fetch int data %d, unsigned? %d\\n\",\n                          (int) fbh->ldata, buffer->is_unsigned);\n          if (buffer->is_unsigned)\n            sv_setuv(sv, fbh->ldata);\n          else\n            sv_setiv(sv, fbh->ldata);\n\n          break;\n\n        default:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tERROR IN st_fetch_string\");\n          len= fbh->length;\n\t  /* ChopBlanks server-side prepared statement */\n          if (ChopBlanks)\n          {\n            /* \n              see bottom of:\n              http://www.mysql.org/doc/refman/5.0/en/c-api-datatypes.html\n            */\n            if (fbh->charsetnr != 63)\n              while (len && fbh->data[len-1] == ' ') { --len; }\n          }\n\t  /* END OF ChopBlanks */\n\n          sv_setpvn(sv, fbh->data, len);\n\n\t/* UTF8 */\n        /*HELMUT*/\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n\n#if MYSQL_VERSION_ID >= FIELD_CHARSETNR_VERSION \n  /* see bottom of: http://www.mysql.org/doc/refman/5.0/en/c-api-datatypes.html */\n        if (imp_dbh->enable_utf8 && fbh->charsetnr != 63)\n#else\n\tif (imp_dbh->enable_utf8 && !(fbh->flags & BINARY_FLAG))\n#endif\n\t  sv_utf8_decode(sv);\n#endif\n\t/* END OF UTF8 */\n          break;\n\n        }\n\n      }\n    }\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, %d cols\\n\", num_fields);\n\n    return av;\n  }\n  else\n  {\n#endif\n\n    imp_sth->currow++;\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    {\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch result set details\\n\");\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\timp_sth->result=%08lx\\n\",(long unsigned int) imp_sth->result);\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_num_fields=%llu\\n\",\n                    (long long unsigned int) mysql_num_fields(imp_sth->result));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_num_rows=%llu\\n\",\n                    mysql_num_rows(imp_sth->result));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_affected_rows=%llu\\n\",\n                    mysql_affected_rows(imp_dbh->pmysql));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch for %08lx, currow= %d\\n\",\n                    (u_long) sth,imp_sth->currow);\n    }\n\n    if (!(cols= mysql_fetch_row(imp_sth->result)))\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      {\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch, no more rows to fetch\");\n      }\n      if (mysql_errno(imp_dbh->pmysql))\n        do_error(sth, mysql_errno(imp_dbh->pmysql),\n                 mysql_error(imp_dbh->pmysql),\n                 mysql_sqlstate(imp_dbh->pmysql));\n\n\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n      if (!mysql_more_results(svsock))\n#endif\n        dbd_st_finish(sth, imp_sth);\n      return Nullav;\n    }\n\n    num_fields= mysql_num_fields(imp_sth->result);\n    fields= mysql_fetch_fields(imp_sth->result);\n    lengths= mysql_fetch_lengths(imp_sth->result);\n\n    if ((av= DBIc_FIELDS_AV(imp_sth)) != Nullav)\n    {\n      av_length= av_len(av)+1;\n\n      if (av_length != num_fields)              /* Resize array if necessary */\n      {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, size of results array(%d) != num_fields(%d)\\n\",\n                                   av_length, num_fields);\n\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, result fields(%d)\\n\",\n                                   DBIc_NUM_FIELDS(imp_sth));\n\n        av_readonly = SvREADONLY(av);\n\n        if (av_readonly)\n          SvREADONLY_off( av );              /* DBI sets this readonly */\n\n        while (av_length < num_fields)\n        {\n          av_store(av, av_length++, newSV(0));\n        }\n\n        while (av_length > num_fields)\n        {\n          SvREFCNT_dec(av_pop(av));\n          av_length--;\n        }\n        if (av_readonly)\n          SvREADONLY_on(av);\n      }\n    }\n\n    av= DBIc_DBISTATE(imp_sth)->get_fbav(imp_sth);\n\n    for (i= 0;  i < num_fields; ++i)\n    {\n      char *col= cols[i];\n      SV *sv= AvARRAY(av)[i]; /* Note: we (re)use the SV in the AV\t*/\n\n      if (col)\n      {\n        STRLEN len= lengths[i];\n        if (ChopBlanks)\n        {\n          while (len && col[len-1] == ' ')\n          {\t--len; }\n        }\n        sv_setpvn(sv, col, len);\n\t/* UTF8 */\n        /*HELMUT*/\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n\n  /* see bottom of: http://www.mysql.org/doc/refman/5.0/en/c-api-datatypes.html */\n        if (imp_dbh->enable_utf8 && fields[i].charsetnr != 63)\n\t  sv_utf8_decode(sv);\n#endif\n\t/* END OF UTF8 */\n      }\n      else\n        (void) SvOK_off(sv);  /*  Field is NULL, return undef  */\n    }\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, %d cols\\n\", num_fields);\n    return av;\n\n#if MYSQL_VERSION_ID  >= SERVER_PREPARE_VERSION\n  }\n#endif\n\n}\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n/*\n  We have to fetch all data from stmt\n  There is may be usefull for 2 cases:\n  1. st_finish when we have undef statement\n  2. call st_execute again when we have some unfetched data in stmt\n */\n\nint mysql_st_clean_cursor(SV* sth, imp_sth_t* imp_sth) {\n\n  if (DBIc_ACTIVE(imp_sth) && dbd_describe(sth, imp_sth) &&\n      !imp_sth->fetch_done)\n    mysql_stmt_free_result(imp_sth->stmt);\n  return 1;\n}\n#endif\n\n/***************************************************************************\n *\n *  Name:    dbd_st_finish\n *\n *  Purpose: Called for freeing a mysql result\n *\n *  Input:   sth - statement handle being finished\n *           imp_sth - drivers private statement handle data\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error() will\n *           be called in the latter case\n *\n **************************************************************************/\n\nint dbd_st_finish(SV* sth, imp_sth_t* imp_sth) {\n  dTHX;\n  D_imp_xxh(sth);\n\n#if defined (dTHR)\n  dTHR;\n#endif\n\n#if MYSQL_ASYNC\n  D_imp_dbh_from_sth;\n  if(imp_dbh->async_query_in_flight) {\n    mysql_db_async_result(sth, &imp_sth->result);\n  }\n#endif\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n  {\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\n--> dbd_st_finish\\n\");\n  }\n\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (imp_sth && imp_sth->stmt)\n    {\n      if (!mysql_st_clean_cursor(sth, imp_sth))\n      {\n        do_error(sth, JW_ERR_SEQUENCE,\n                 \"Error happened while tried to clean up stmt\",NULL);\n        return 0;\n      }\n    }\n  }\n#endif\n\n  /*\n    Cancel further fetches from this cursor.\n    We don't close the cursor till DESTROY.\n    The application may re execute it.\n  */\n  if (imp_sth && DBIc_ACTIVE(imp_sth))\n  {\n    /*\n      Clean-up previous result set(s) for sth to prevent\n      'Commands out of sync' error\n    */\n    mysql_st_free_result_sets(sth, imp_sth);\n  }\n  DBIc_ACTIVE_off(imp_sth);\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n  {\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\n<-- dbd_st_finish\\n\");\n  }\n  return 1;\n}\n\n\n/**************************************************************************\n *\n *  Name:    dbd_st_destroy\n *\n *  Purpose: Our part of the statement handles destructor\n *\n *  Input:   sth - statement handle being destroyed\n *           imp_sth - drivers private statement handle data\n *\n *  Returns: Nothing\n *\n **************************************************************************/\n\nvoid dbd_st_destroy(SV *sth, imp_sth_t *imp_sth) {\n  dTHX;\n  D_imp_xxh(sth);\n\n#if defined (dTHR)\n  dTHR;\n#endif\n\n  int i;\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  imp_sth_fbh_t *fbh;\n  int n;\n\n  n= DBIc_NUM_PARAMS(imp_sth);\n  if (n)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tFreeing %d parameters, bind %p fbind %p\\n\",\n          n, imp_sth->bind, imp_sth->fbind);\n\n    free_bind(imp_sth->bind);\n    free_fbind(imp_sth->fbind);\n  }\n\n  fbh= imp_sth->fbh;\n  if (fbh)\n  {\n    n = DBIc_NUM_FIELDS(imp_sth);\n    i = 0;\n    while (i < n)\n    {\n      if (fbh[i].data) Safefree(fbh[i].data);\n      ++i;\n    }\n\n    free_fbuffer(fbh);\n    if (imp_sth->buffer)\n      free_bind(imp_sth->buffer);\n  }\n\n  if (imp_sth->stmt)\n  {\n    if (mysql_stmt_close(imp_sth->stmt))\n    {\n      do_error(DBIc_PARENT_H(imp_sth), mysql_stmt_errno(imp_sth->stmt),\n          mysql_stmt_error(imp_sth->stmt),\n          mysql_stmt_sqlstate(imp_sth->stmt));\n    }\n  }\n#endif\n\n\n  /* dbd_st_finish has already been called by .xs code if needed.\t*/\n\n  /* Free values allocated by dbd_bind_ph */\n  if (imp_sth->params)\n  {\n    free_param(aTHX_ imp_sth->params, DBIc_NUM_PARAMS(imp_sth));\n    imp_sth->params= NULL;\n  }\n\n  /* Free cached array attributes */\n  for (i= 0; i < AV_ATTRIB_LAST; i++)\n  {\n    if (imp_sth->av_attr[i])\n      SvREFCNT_dec(imp_sth->av_attr[i]);\n    imp_sth->av_attr[i]= Nullav;\n  }\n  /* let DBI know we've done it   */\n  DBIc_IMPSET_off(imp_sth);\n}\n\n\n/*\n **************************************************************************\n *\n *  Name:    dbd_st_STORE_attrib\n *\n *  Purpose: Modifies a statement handles attributes; we currently\n *           support just nothing\n *\n *  Input:   sth - statement handle being destroyed\n *           imp_sth - drivers private statement handle data\n *           keysv - attribute name\n *           valuesv - attribute value\n *\n *  Returns: TRUE for success, FALSE otrherwise; do_error will\n *           be called in the latter case\n *\n **************************************************************************/\nint\ndbd_st_STORE_attrib(\n                    SV *sth,\n                    imp_sth_t *imp_sth,\n                    SV *keysv,\n                    SV *valuesv\n                   )\n{\n  dTHX;\n  STRLEN(kl);\n  char *key= SvPV(keysv, kl);\n  int retval= FALSE;\n  D_imp_xxh(sth);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t\\t-> dbd_st_STORE_attrib for %08lx, key %s\\n\",\n                  (u_long) sth, key);\n\n  if (strEQ(key, \"mysql_use_result\"))\n  {\n    imp_sth->use_mysql_use_result= SvTRUE(valuesv);\n  }\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t\\t<- dbd_st_STORE_attrib for %08lx, result %d\\n\",\n                  (u_long) sth, retval);\n\n  return retval;\n}\n\n\n/*\n **************************************************************************\n *\n *  Name:    dbd_st_FETCH_internal\n *\n *  Purpose: Retrieves a statement handles array attributes; we use\n *           a separate function, because creating the array\n *           attributes shares much code and it aids in supporting\n *           enhanced features like caching.\n *\n *  Input:   sth - statement handle; may even be a database handle,\n *               in which case this will be used for storing error\n *               messages only. This is only valid, if cacheit (the\n *               last argument) is set to TRUE.\n *           what - internal attribute number\n *           res - pointer to a DBMS result\n *           cacheit - TRUE, if results may be cached in the sth.\n *\n *  Returns: RV pointing to result array in case of success, NULL\n *           otherwise; do_error has already been called in the latter\n *           case.\n *\n **************************************************************************/\n\n#ifndef IS_KEY\n#define IS_KEY(A) (((A) & (PRI_KEY_FLAG | UNIQUE_KEY_FLAG | MULTIPLE_KEY_FLAG)) != 0)\n#endif\n\n#if !defined(IS_AUTO_INCREMENT) && defined(AUTO_INCREMENT_FLAG)\n#define IS_AUTO_INCREMENT(A) (((A) & AUTO_INCREMENT_FLAG) != 0)\n#endif\n\nSV*\ndbd_st_FETCH_internal(\n  SV *sth,\n  int what,\n  MYSQL_RES *res,\n  int cacheit\n)\n{\n  dTHX;\n  D_imp_sth(sth);\n  AV *av= Nullav;\n  MYSQL_FIELD *curField;\n\n  /* Are we asking for a legal value? */\n  if (what < 0 ||  what >= AV_ATTRIB_LAST)\n    do_error(sth, JW_ERR_NOT_IMPLEMENTED, \"Not implemented\", NULL);\n\n  /* Return cached value, if possible */\n  else if (cacheit  &&  imp_sth->av_attr[what])\n    av= imp_sth->av_attr[what];\n\n  /* Does this sth really have a result? */\n  else if (!res)\n    do_error(sth, JW_ERR_NOT_ACTIVE,\n\t     \"statement contains no result\" ,NULL);\n  /* Do the real work. */\n  else\n  {\n    av= newAV();\n    mysql_field_seek(res, 0);\n    while ((curField= mysql_fetch_field(res)))\n    {\n      SV *sv;\n\n      switch(what) {\n      case AV_ATTRIB_NAME:\n        sv= newSVpv(curField->name, strlen(curField->name));\n        break;\n\n      case AV_ATTRIB_TABLE:\n        sv= newSVpv(curField->table, strlen(curField->table));\n        break;\n\n      case AV_ATTRIB_TYPE:\n        sv= newSViv((int) curField->type);\n        break;\n\n      case AV_ATTRIB_SQL_TYPE:\n        sv= newSViv((int) native2sql(curField->type)->data_type);\n        break;\n      case AV_ATTRIB_IS_PRI_KEY:\n        sv= boolSV(IS_PRI_KEY(curField->flags));\n        break;\n\n      case AV_ATTRIB_IS_NOT_NULL:\n        sv= boolSV(IS_NOT_NULL(curField->flags));\n        break;\n\n      case AV_ATTRIB_NULLABLE:\n        sv= boolSV(!IS_NOT_NULL(curField->flags));\n        break;\n\n      case AV_ATTRIB_LENGTH:\n        sv= newSViv((int) curField->length);\n        break;\n\n      case AV_ATTRIB_IS_NUM:\n        sv= newSViv((int) native2sql(curField->type)->is_num);\n        break;\n\n      case AV_ATTRIB_TYPE_NAME:\n        sv= newSVpv((char*) native2sql(curField->type)->type_name, 0);\n        break;\n\n      case AV_ATTRIB_MAX_LENGTH:\n        sv= newSViv((int) curField->max_length);\n        break;\n\n      case AV_ATTRIB_IS_AUTO_INCREMENT:\n#if defined(AUTO_INCREMENT_FLAG)\n        sv= boolSV(IS_AUTO_INCREMENT(curField->flags));\n        break;\n#else\n        croak(\"AUTO_INCREMENT_FLAG is not supported on this machine\");\n#endif\n\n      case AV_ATTRIB_IS_KEY:\n        sv= boolSV(IS_KEY(curField->flags));\n        break;\n\n      case AV_ATTRIB_IS_BLOB:\n        sv= boolSV(IS_BLOB(curField->flags));\n        break;\n\n      case AV_ATTRIB_SCALE:\n        sv= newSViv((int) curField->decimals);\n        break;\n\n      case AV_ATTRIB_PRECISION:\n        sv= newSViv((int) (curField->length > curField->max_length) ?\n                     curField->length : curField->max_length);\n        break;\n\n      default:\n        sv= &PL_sv_undef;\n        break;\n      }\n      av_push(av, sv);\n    }\n\n    /* Ensure that this value is kept, decremented in\n     *  dbd_st_destroy and dbd_st_execute.  */\n    if (!cacheit)\n      return sv_2mortal(newRV_noinc((SV*)av));\n    imp_sth->av_attr[what]= av;\n  }\n\n  if (av == Nullav)\n    return &PL_sv_undef;\n\n  return sv_2mortal(newRV_inc((SV*)av));\n}\n\n\n/*\n **************************************************************************\n *\n *  Name:    dbd_st_FETCH_attrib\n *\n *  Purpose: Retrieves a statement handles attributes\n *\n *  Input:   sth - statement handle being destroyed\n *           imp_sth - drivers private statement handle data\n *           keysv - attribute name\n *\n *  Returns: NULL for an unknown attribute, \"undef\" for error,\n *           attribute value otherwise.\n *\n **************************************************************************/\n\n#define ST_FETCH_AV(what) \\\n    dbd_st_FETCH_internal(sth, (what), imp_sth->result, TRUE)\n\n  SV* dbd_st_FETCH_attrib(\n                          SV *sth,\n                          imp_sth_t *imp_sth,\n                          SV *keysv\n                         )\n{\n  dTHX;\n  STRLEN(kl);\n  char *key= SvPV(keysv, kl);\n  SV *retsv= Nullsv;\n  D_imp_xxh(sth);\n\n  if (kl < 2)\n    return Nullsv;\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"    -> dbd_st_FETCH_attrib for %08lx, key %s\\n\",\n                  (u_long) sth, key);\n\n  switch (*key) {\n  case 'N':\n    if (strEQ(key, \"NAME\"))\n      retsv= ST_FETCH_AV(AV_ATTRIB_NAME);\n    else if (strEQ(key, \"NULLABLE\"))\n      retsv= ST_FETCH_AV(AV_ATTRIB_NULLABLE);\n    break;\n  case 'P':\n    if (strEQ(key, \"PRECISION\"))\n      retsv= ST_FETCH_AV(AV_ATTRIB_PRECISION);\n    if (strEQ(key, \"ParamValues\"))\n    {\n        HV *pvhv= newHV();\n        if (DBIc_NUM_PARAMS(imp_sth))\n        {\n            int n;\n            char key[100];\n            I32 keylen;\n            for (n= 0; n < DBIc_NUM_PARAMS(imp_sth); n++)\n            {\n                keylen= sprintf(key, \"%d\", n);\n                hv_store(pvhv, key,\n                         keylen, newSVsv(imp_sth->params[n].value), 0);\n            }\n        }\n        retsv= newRV_noinc((SV*)pvhv);\n    }\n    break;\n  case 'S':\n    if (strEQ(key, \"SCALE\"))\n      retsv= ST_FETCH_AV(AV_ATTRIB_SCALE);\n    break;\n  case 'T':\n    if (strEQ(key, \"TYPE\"))\n      retsv= ST_FETCH_AV(AV_ATTRIB_SQL_TYPE);\n    break;\n  case 'm':\n    switch (kl) {\n    case 10:\n      if (strEQ(key, \"mysql_type\"))\n        retsv= ST_FETCH_AV(AV_ATTRIB_TYPE);\n      break;\n    case 11:\n      if (strEQ(key, \"mysql_table\"))\n        retsv= ST_FETCH_AV(AV_ATTRIB_TABLE);\n      break;\n    case 12:\n      if (       strEQ(key, \"mysql_is_key\"))\n        retsv= ST_FETCH_AV(AV_ATTRIB_IS_KEY);\n      else if (strEQ(key, \"mysql_is_num\"))\n        retsv= ST_FETCH_AV(AV_ATTRIB_IS_NUM);\n      else if (strEQ(key, \"mysql_length\"))\n        retsv= ST_FETCH_AV(AV_ATTRIB_LENGTH);\n      else if (strEQ(key, \"mysql_result\"))\n        retsv= sv_2mortal(newSViv((IV) imp_sth->result));\n      break;\n    case 13:\n      if (strEQ(key, \"mysql_is_blob\"))\n        retsv= ST_FETCH_AV(AV_ATTRIB_IS_BLOB);\n      break;\n    case 14:\n      if (strEQ(key, \"mysql_insertid\"))\n      {\n        /* We cannot return an IV, because the insertid is a long.  */\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"INSERT ID %d\\n\", (int) imp_sth->insertid);\n\n        return sv_2mortal(my_ulonglong2str(aTHX_ imp_sth->insertid));\n      }\n      break;\n    case 15:\n      if (strEQ(key, \"mysql_type_name\"))\n        retsv = ST_FETCH_AV(AV_ATTRIB_TYPE_NAME);\n      break;\n    case 16:\n      if ( strEQ(key, \"mysql_is_pri_key\"))\n        retsv= ST_FETCH_AV(AV_ATTRIB_IS_PRI_KEY);\n      else if (strEQ(key, \"mysql_max_length\"))\n        retsv= ST_FETCH_AV(AV_ATTRIB_MAX_LENGTH);\n      else if (strEQ(key, \"mysql_use_result\"))\n        retsv= boolSV(imp_sth->use_mysql_use_result);\n      break;\n    case 19:\n      if (strEQ(key, \"mysql_warning_count\"))\n        retsv= sv_2mortal(newSViv((IV) imp_sth->warning_count));\n      break;\n    case 20:\n      if (strEQ(key, \"mysql_server_prepare\"))\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n        retsv= sv_2mortal(newSViv((IV) imp_sth->use_server_side_prepare));\n#else\n        retsv= boolSV(0);\n#endif\n      break;\n    case 23:\n      if (strEQ(key, \"mysql_is_auto_increment\"))\n        retsv = ST_FETCH_AV(AV_ATTRIB_IS_AUTO_INCREMENT);\n      break;\n    }\n    break;\n  }\n  return retsv;\n}\n\n\n/***************************************************************************\n *\n *  Name:    dbd_st_blob_read\n *\n *  Purpose: Used for blob reads if the statement handles \"LongTruncOk\"\n *           attribute (currently not supported by DBD::mysql)\n *\n *  Input:   SV* - statement handle from which a blob will be fetched\n *           imp_sth - drivers private statement handle data\n *           field - field number of the blob (note, that a row may\n *               contain more than one blob)\n *           offset - the offset of the field, where to start reading\n *           len - maximum number of bytes to read\n *           destrv - RV* that tells us where to store\n *           destoffset - destination offset\n *\n *  Returns: TRUE for success, FALSE otrherwise; do_error will\n *           be called in the latter case\n *\n **************************************************************************/\n\nint dbd_st_blob_read (\n  SV *sth,\n  imp_sth_t *imp_sth,\n  int field,\n  long offset,\n  long len,\n  SV *destrv,\n  long destoffset)\n{\n    /* quell warnings */\n    sth= sth;\n    imp_sth=imp_sth;\n    field= field;\n    offset= offset;\n    len= len;\n    destrv= destrv;\n    destoffset= destoffset;\n    return FALSE;\n}\n\n\n/***************************************************************************\n *\n *  Name:    dbd_bind_ph\n *\n *  Purpose: Binds a statement value to a parameter\n *\n *  Input:   sth - statement handle\n *           imp_sth - drivers private statement handle data\n *           param - parameter number, counting starts with 1\n *           value - value being inserted for parameter \"param\"\n *           sql_type - SQL type of the value\n *           attribs - bind parameter attributes, currently this must be\n *               one of the values SQL_CHAR, ...\n *           inout - TRUE, if parameter is an output variable (currently\n *               this is not supported)\n *           maxlen - ???\n *\n *  Returns: TRUE for success, FALSE otherwise\n *\n **************************************************************************/\n\nint dbd_bind_ph(SV *sth, imp_sth_t *imp_sth, SV *param, SV *value,\n\t\t IV sql_type, SV *attribs, int is_inout, IV maxlen) {\n  dTHX;\n  int rc;\n  int param_num= SvIV(param);\n  int idx= param_num - 1;\n  char err_msg[64];\n  D_imp_xxh(sth);\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  STRLEN slen;\n  char *buffer= NULL;\n  int buffer_is_null= 0;\n  int buffer_length= slen;\n  unsigned int buffer_type= 0;\n#endif\n\n  D_imp_dbh_from_sth;\n  ASYNC_CHECK_RETURN(sth, FALSE);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"   Called: dbd_bind_ph\\n\");\n\n  attribs= attribs;\n  maxlen= maxlen;\n\n  if (param_num <= 0  ||  param_num > DBIc_NUM_PARAMS(imp_sth))\n  {\n    do_error(sth, JW_ERR_ILLEGAL_PARAM_NUM, \"Illegal parameter number\", NULL);\n    return FALSE;\n  }\n\n  /*\n     This fixes the bug whereby no warning was issued upone binding a\n     defined non-numeric as numeric\n   */\n  if (SvOK(value) &&\n      (sql_type == SQL_NUMERIC  ||\n       sql_type == SQL_DECIMAL  ||\n       sql_type == SQL_INTEGER  ||\n       sql_type == SQL_SMALLINT ||\n       sql_type == SQL_FLOAT    ||\n       sql_type == SQL_REAL     ||\n       sql_type == SQL_DOUBLE) )\n  {\n    if (! looks_like_number(value))\n    {\n      sprintf(err_msg,\n              \"Binding non-numeric field %d, value %s as a numeric!\",\n              param_num, neatsvpv(value,0));\n      do_error(sth, JW_ERR_ILLEGAL_PARAM_NUM, err_msg, NULL);\n    }\n  }\n\n  if (is_inout)\n  {\n    do_error(sth, JW_ERR_NOT_IMPLEMENTED, \"Output parameters not implemented\", NULL);\n    return FALSE;\n  }\n\n  rc = bind_param(&imp_sth->params[idx], value, sql_type);\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n      switch(sql_type) {\n      case SQL_NUMERIC:\n      case SQL_INTEGER:\n      case SQL_SMALLINT:\n      case SQL_BIGINT:\n      case SQL_TINYINT:\n          buffer_type= MYSQL_TYPE_LONG;\n          break;\n      case SQL_DOUBLE:\n      case SQL_DECIMAL: \n      case SQL_FLOAT: \n      case SQL_REAL:\n          buffer_type= MYSQL_TYPE_DOUBLE;\n          break;\n      case SQL_CHAR: \n      case SQL_VARCHAR: \n      case SQL_DATE: \n      case SQL_TIME: \n      case SQL_TIMESTAMP: \n      case SQL_LONGVARCHAR: \n      case SQL_BINARY: \n      case SQL_VARBINARY: \n      case SQL_LONGVARBINARY:\n          buffer_type= MYSQL_TYPE_BLOB;\n          break;\n      default:\n          buffer_type= MYSQL_TYPE_STRING;\n    }\n    buffer_is_null = !(SvOK(imp_sth->params[idx].value) && imp_sth->params[idx].value);\n    if (! buffer_is_null) {\n      switch(buffer_type) {\n        case MYSQL_TYPE_LONG:\n          /* INT */\n          if (!SvIOK(imp_sth->params[idx].value) && DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tTRY TO BIND AN INT NUMBER\\n\");\n          buffer_length = sizeof imp_sth->fbind[idx].numeric_val.lval;\n          imp_sth->fbind[idx].numeric_val.lval= SvIV(imp_sth->params[idx].value);\n          buffer=(void*)&(imp_sth->fbind[idx].numeric_val.lval);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"   SCALAR type %d ->%ld<- IS A INT NUMBER\\n\",\n                          (int) sql_type, (long) (*buffer));\n          break;\n\n        case MYSQL_TYPE_DOUBLE:\n          if (!SvNOK(imp_sth->params[idx].value) && DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tTRY TO BIND A FLOAT NUMBER\\n\");\n          buffer_length = sizeof imp_sth->fbind[idx].numeric_val.dval;\n          imp_sth->fbind[idx].numeric_val.dval= SvNV(imp_sth->params[idx].value);\n          buffer=(char*)&(imp_sth->fbind[idx].numeric_val.dval);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"   SCALAR type %d ->%f<- IS A FLOAT NUMBER\\n\",\n                          (int) sql_type, (double)(*buffer));\n          break;\n\n        case MYSQL_TYPE_BLOB:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"   SCALAR type BLOB\\n\");\n          break;\n\n        case MYSQL_TYPE_STRING:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"   SCALAR type STRING %d, buffertype=%d\\n\", (int) sql_type, buffer_type);\n          break;\n\n        default:\n          croak(\"Bug in DBD::Mysql file dbdimp.c#dbd_bind_ph: do not know how to handle unknown buffer type.\");\n      }\n\n      if (buffer_type == MYSQL_TYPE_STRING || buffer_type == MYSQL_TYPE_BLOB)\n      {\n        buffer= SvPV(imp_sth->params[idx].value, slen);\n        buffer_length= slen;\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                        \" SCALAR type %d ->length %d<- IS A STRING or BLOB\\n\",\n                        (int) sql_type, buffer_length);\n      }\n    }\n    else\n    {\n      /*case: buffer_is_null != 0*/\n      buffer= NULL;\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                      \"   SCALAR NULL VALUE: buffer type is: %d\\n\", buffer_type);\n    }\n\n    /* Type of column was changed. Force to rebind */\n    if (imp_sth->bind[idx].buffer_type != buffer_type) {\n      /* Note: this looks like being another bug:\n       * if type of parameter N changes, then a bind is triggered\n       * with an only partially filled bind structure ??\n       */\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                        \"   FORCE REBIND: buffer type changed from %d to %d, sql-type=%d\\n\",\n                        (int) imp_sth->bind[idx].buffer_type, buffer_type, (int) sql_type);\n      imp_sth->has_been_bound = 0;\n    }\n\n    /* prepare has not been called */\n    if (imp_sth->has_been_bound == 0)\n    {\n      imp_sth->bind[idx].buffer_type= buffer_type;\n      imp_sth->bind[idx].buffer= buffer;\n      imp_sth->bind[idx].buffer_length= buffer_length;\n    }\n    else /* prepare has been called */\n    {\n      imp_sth->stmt->params[idx].buffer= buffer;\n      imp_sth->stmt->params[idx].buffer_length= buffer_length;\n    }\n    imp_sth->fbind[idx].length= buffer_length;\n    imp_sth->fbind[idx].is_null= buffer_is_null;\n  }\n#endif\n  return rc;\n}\n\n\n/***************************************************************************\n *\n *  Name:    mysql_db_reconnect\n *\n *  Purpose: If the server has disconnected, try to reconnect.\n *\n *  Input:   h - database or statement handle\n *\n *  Returns: TRUE for success, FALSE otherwise\n *\n **************************************************************************/\n\nint mysql_db_reconnect(SV* h)\n{\n  dTHX;\n  D_imp_xxh(h);\n  imp_dbh_t* imp_dbh;\n  MYSQL save_socket;\n\n  if (DBIc_TYPE(imp_xxh) == DBIt_ST)\n  {\n    imp_dbh = (imp_dbh_t*) DBIc_PARENT_COM(imp_xxh);\n    h = DBIc_PARENT_H(imp_xxh);\n  }\n  else\n    imp_dbh= (imp_dbh_t*) imp_xxh;\n\n  if (mysql_errno(imp_dbh->pmysql) != CR_SERVER_GONE_ERROR)\n    /* Other error */\n    return FALSE;\n\n  if (!DBIc_has(imp_dbh, DBIcf_AutoCommit) || !imp_dbh->auto_reconnect)\n  {\n    /* We never reconnect if AutoCommit is turned off.\n     * Otherwise we might get an inconsistent transaction\n     * state.\n     */\n    return FALSE;\n  }\n\n  /* my_login will blow away imp_dbh->mysql so we save a copy of\n   * imp_dbh->mysql and put it back where it belongs if the reconnect\n   * fail.  Think server is down & reconnect fails but the application eval{}s\n   * the execute, so next time $dbh->quote() gets called, instant SIGSEGV!\n   */\n  save_socket= *(imp_dbh->pmysql);\n  memcpy (&save_socket, imp_dbh->pmysql,sizeof(save_socket));\n  memset (imp_dbh->pmysql,0,sizeof(*(imp_dbh->pmysql)));\n\n  /* we should disconnect the db handle before reconnecting, this will\n   * prevent my_login from thinking it's adopting an active child which\n   * would prevent the handle from actually reconnecting\n   */\n  if (!dbd_db_disconnect(h, imp_dbh) || !my_login(aTHX_ h, imp_dbh))\n  {\n    do_error(h, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\n             mysql_sqlstate(imp_dbh->pmysql));\n    memcpy (imp_dbh->pmysql, &save_socket, sizeof(save_socket));\n    ++imp_dbh->stats.auto_reconnects_failed;\n    return FALSE;\n  }\n\n  /*\n   *  Tell DBI, that dbh->disconnect should be called for this handle\n   */\n  DBIc_ACTIVE_on(imp_dbh);\n\n  ++imp_dbh->stats.auto_reconnects_ok;\n  return TRUE;\n}\n\n\n/**************************************************************************\n *\n *  Name:    dbd_db_type_info_all\n *\n *  Purpose: Implements $dbh->type_info_all\n *\n *  Input:   dbh - database handle\n *           imp_sth - drivers private database handle data\n *\n *  Returns: RV to AV of types\n *\n **************************************************************************/\n\n#define PV_PUSH(c)                              \\\n    if (c) {                                    \\\n\tsv= newSVpv((char*) (c), 0);           \\\n\tSvREADONLY_on(sv);                      \\\n    } else {                                    \\\n        sv= &PL_sv_undef;                         \\\n    }                                           \\\n    av_push(row, sv);\n\n#define IV_PUSH(i) sv= newSViv((i)); SvREADONLY_on(sv); av_push(row, sv);\n\nAV *dbd_db_type_info_all(SV *dbh, imp_dbh_t *imp_dbh)\n{\n  dTHX;\n  AV *av= newAV();\n  AV *row;\n  HV *hv;\n  SV *sv;\n  int i;\n  const char *cols[] = {\n    \"TYPE_NAME\",\n    \"DATA_TYPE\",\n    \"COLUMN_SIZE\",\n    \"LITERAL_PREFIX\",\n    \"LITERAL_SUFFIX\",\n    \"CREATE_PARAMS\",\n    \"NULLABLE\",\n    \"CASE_SENSITIVE\",\n    \"SEARCHABLE\",\n    \"UNSIGNED_ATTRIBUTE\",\n    \"FIXED_PREC_SCALE\",\n    \"AUTO_UNIQUE_VALUE\",\n    \"LOCAL_TYPE_NAME\",\n    \"MINIMUM_SCALE\",\n    \"MAXIMUM_SCALE\",\n    \"NUM_PREC_RADIX\",\n    \"SQL_DATATYPE\",\n    \"SQL_DATETIME_SUB\",\n    \"INTERVAL_PRECISION\",\n    \"mysql_native_type\",\n    \"mysql_is_num\"\n  };\n\n  dbh= dbh;\n  imp_dbh= imp_dbh;\n \n  hv= newHV();\n  av_push(av, newRV_noinc((SV*) hv));\n  for (i= 0;  i < (int)(sizeof(cols) / sizeof(const char*));  i++)\n  {\n    if (!hv_store(hv, (char*) cols[i], strlen(cols[i]), newSViv(i), 0))\n    {\n      SvREFCNT_dec((SV*) av);\n      return Nullav;\n    }\n  }\n  for (i= 0;  i < (int)SQL_GET_TYPE_INFO_num;  i++)\n  {\n    const sql_type_info_t *t= &SQL_GET_TYPE_INFO_values[i];\n\n    row= newAV();\n    av_push(av, newRV_noinc((SV*) row));\n    PV_PUSH(t->type_name);\n    IV_PUSH(t->data_type);\n    IV_PUSH(t->column_size);\n    PV_PUSH(t->literal_prefix);\n    PV_PUSH(t->literal_suffix);\n    PV_PUSH(t->create_params);\n    IV_PUSH(t->nullable);\n    IV_PUSH(t->case_sensitive);\n    IV_PUSH(t->searchable);\n    IV_PUSH(t->unsigned_attribute);\n    IV_PUSH(t->fixed_prec_scale);\n    IV_PUSH(t->auto_unique_value);\n    PV_PUSH(t->local_type_name);\n    IV_PUSH(t->minimum_scale);\n    IV_PUSH(t->maximum_scale);\n\n    if (t->num_prec_radix)\n    {\n      IV_PUSH(t->num_prec_radix);\n    }\n    else\n      av_push(row, &PL_sv_undef);\n\n    IV_PUSH(t->sql_datatype); /* SQL_DATATYPE*/\n    IV_PUSH(t->sql_datetime_sub); /* SQL_DATETIME_SUB*/\n    IV_PUSH(t->interval_precision); /* INTERVAL_PERCISION */\n    IV_PUSH(t->native_type);\n    IV_PUSH(t->is_num);\n  }\n  return av;\n}\n\n\n/*\n  dbd_db_quote\n\n  Properly quotes a value \n*/\nSV* dbd_db_quote(SV *dbh, SV *str, SV *type)\n{\n  dTHX;\n  SV *result;\n\n  if (SvGMAGICAL(str))\n    mg_get(str);\n\n  if (!SvOK(str))\n    result= newSVpv(\"NULL\", 4);\n  else\n  {\n    char *ptr, *sptr;\n    STRLEN len;\n\n    D_imp_dbh(dbh);\n\n    if (type && SvMAGICAL(type))\n      mg_get(type);\n\n    if (type  &&  SvOK(type))\n    {\n      int i;\n      int tp= SvIV(type);\n      for (i= 0;  i < (int)SQL_GET_TYPE_INFO_num;  i++)\n      {\n        const sql_type_info_t *t= &SQL_GET_TYPE_INFO_values[i];\n        if (t->data_type == tp)\n        {\n          if (!t->literal_prefix)\n            return Nullsv;\n          break;\n        }\n      }\n    }\n\n    ptr= SvPV(str, len);\n    result= newSV(len*2+3);\n#ifdef SvUTF8\n    if (SvUTF8(str)) SvUTF8_on(result);\n#endif\n    sptr= SvPVX(result);\n\n    *sptr++ = '\\'';\n    sptr+= mysql_real_escape_string(imp_dbh->pmysql, sptr,\n                                     ptr, len);\n    *sptr++= '\\'';\n    SvPOK_on(result);\n    SvCUR_set(result, sptr - SvPVX(result));\n    /* Never hurts NUL terminating a Per string */\n    *sptr++= '\\0';\n  }\n  return result;\n}\n\n#ifdef DBD_MYSQL_INSERT_ID_IS_GOOD\nSV *mysql_db_last_insert_id(SV *dbh, imp_dbh_t *imp_dbh,\n        SV *catalog, SV *schema, SV *table, SV *field, SV *attr)\n{\n  dTHX;\n  /* all these non-op settings are to stifle OS X compile warnings */\n  imp_dbh= imp_dbh;\n  dbh= dbh;\n  catalog= catalog;\n  schema= schema;\n  table= table;\n  field= field;\n  attr= attr;\n\n  ASYNC_CHECK_RETURN(dbh, &PL_sv_undef);\n  return sv_2mortal(my_ulonglong2str(aTHX_ mysql_insert_id(imp_dbh->pmysql)));\n}\n#endif\n\n#if MYSQL_ASYNC\nint mysql_db_async_result(SV* h, MYSQL_RES** resp)\n{\n  dTHX;\n  D_imp_xxh(h);\n  imp_dbh_t* dbh;\n  MYSQL* svsock = NULL;\n  MYSQL_RES* _res;\n  int retval = 0;\n  int htype;\n\n  if(! resp) {\n      resp = &_res;\n  }\n  htype = DBIc_TYPE(imp_xxh);\n\n\n  if(htype == DBIt_DB) {\n      D_imp_dbh(h);\n      dbh = imp_dbh;\n  } else {\n      D_imp_sth(h);\n      D_imp_dbh_from_sth;\n      dbh = imp_dbh;\n  }\n\n  if(! dbh->async_query_in_flight) {\n      do_error(h, 2000, \"Gathering asynchronous results for a synchronous handle\", \"HY000\");\n      return -1;\n  }\n  if(dbh->async_query_in_flight != imp_xxh) {\n      do_error(h, 2000, \"Gathering async_query_in_flight results for the wrong handle\", \"HY000\");\n      return -1;\n  }\n  dbh->async_query_in_flight = NULL;\n\n  svsock= dbh->pmysql;\n  retval= mysql_read_query_result(svsock);\n  if(! retval) {\n    *resp= mysql_store_result(svsock);\n\n    if (mysql_errno(svsock))\n      do_error(h, mysql_errno(svsock), mysql_error(svsock), mysql_sqlstate(svsock));\n    if (!*resp)\n      retval= mysql_affected_rows(svsock);\n    else {\n      retval= mysql_num_rows(*resp);\n      if(resp == &_res) {\n        mysql_free_result(*resp);\n      }\n    }\n    if(htype == DBIt_ST) {\n      D_imp_sth(h);\n      D_imp_dbh_from_sth;\n\n      if(retval+1 != (my_ulonglong)-1) {\n        if(! *resp) {\n          imp_sth->insertid= mysql_insert_id(svsock);\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n          if(! mysql_more_results(svsock))\n            DBIc_ACTIVE_off(imp_sth);\n#endif\n        } else {\n          DBIc_NUM_FIELDS(imp_sth)= mysql_num_fields(imp_sth->result);\n          imp_sth->done_desc= 0;\n          imp_sth->fetch_done= 0;\n        }\n      }\n      imp_sth->warning_count = mysql_warning_count(imp_dbh->pmysql);\n    }\n  } else {\n     do_error(h, mysql_errno(svsock), mysql_error(svsock),\n              mysql_sqlstate(svsock));\n     return -1;\n  }\n return retval;\n}\n\nint mysql_db_async_ready(SV* h)\n{\n  dTHX;\n  D_imp_xxh(h);\n  imp_dbh_t* dbh;\n  int htype;\n\n  htype = DBIc_TYPE(imp_xxh);\n  \n  if(htype == DBIt_DB) {\n      D_imp_dbh(h);\n      dbh = imp_dbh;\n  } else {\n      D_imp_sth(h);\n      D_imp_dbh_from_sth;\n      dbh = imp_dbh;\n  }\n\n  if(dbh->async_query_in_flight) {\n      if(dbh->async_query_in_flight == imp_xxh) {\n          struct pollfd fds;\n          int retval;\n\n          fds.fd = dbh->pmysql->net.fd;\n          fds.events = POLLIN;\n\n          retval = poll(&fds, 1, 0);\n\n          if(retval < 0) {\n              do_error(h, errno, strerror(errno), \"HY000\");\n          }\n          return retval;\n      } else {\n          do_error(h, 2000, \"Calling mysql_async_ready on the wrong handle\", \"HY000\");\n          return -1;\n      }\n  } else {\n      do_error(h, 2000, \"Handle is not in asynchronous mode\", \"HY000\");\n      return -1;\n  }\n}\n#endif\n\n\nstatic int parse_number(char *string, STRLEN len, char **end)\n{\n    int seen_neg;\n    int seen_dec;\n    int seen_e;\n    int seen_plus;\n    int seen_digit;\n    char *cp;\n\n    seen_neg= seen_dec= seen_e= seen_plus= seen_digit= 0;\n\n    if (len <= 0) {\n        len= strlen(string);\n    }\n\n    cp= string;\n\n    /* Skip leading whitespace */\n    while (*cp && isspace(*cp))\n      cp++;\n\n    for ( ; *cp; cp++)\n    {\n      if ('-' == *cp)\n      {\n        if (seen_neg >= 2)\n        {\n          /*\n            third '-'. number can contains two '-'.\n            because -1e-10 is valid number */\n          break;\n        }\n        seen_neg += 1;\n      }\n      else if ('.' == *cp)\n      {\n        if (seen_dec)\n        {\n          /* second '.' */\n          break;\n        }\n        seen_dec= 1;\n      }\n      else if ('e' == *cp)\n      {\n        if (seen_e)\n        {\n          /* second 'e' */\n          break;\n        }\n        seen_e= 1;\n      }\n      else if ('+' == *cp)\n      {\n        if (seen_plus)\n        {\n          /* second '+' */\n          break;\n        }\n        seen_plus= 1;\n      }\n      else if (!isdigit(*cp))\n      {\n        /* Not sure why this was changed */\n        /* seen_digit= 1; */\n        break;\n      }\n    }\n\n    *end= cp;\n\n    /* length 0 -> not a number */\n    /* Need to revisit this */\n    /*if (len == 0 || cp - string < (int) len || seen_digit == 0) {*/\n    if (len == 0 || cp - string < (int) len) {\n        return -1;\n    }\n\n    return 0;\n}\n"], "fixing_code": ["/*\n *  DBD::mysql - DBI driver for the mysql database\n *\n *  Copyright (c) 2004-2014 Patrick Galbraith\n *  Copyright (c) 2013-2014 Michiel Beijen \n *  Copyright (c) 2004-2007 Alexey Stroganov \n *  Copyright (c) 2003-2005  Rudolf Lippan\n *  Copyright (c) 1997-2003  Jochen Wiedmann\n *\n *  You may distribute this under the terms of either the GNU General Public\n *  License or the Artistic License, as specified in the Perl README file.\n */\n\n\n#ifdef WIN32\n#include \"windows.h\"\n#include \"winsock.h\"\n#endif\n\n#include \"dbdimp.h\"\n\n#if defined(WIN32)  &&  defined(WORD)\n#undef WORD\ntypedef short WORD;\n#endif\n\n#if MYSQL_ASYNC\n#  include <poll.h>\n#  define ASYNC_CHECK_RETURN(h, value)\\\n    if(imp_dbh->async_query_in_flight) {\\\n        do_error(h, 2000, \"Calling a synchronous function on an asynchronous handle\", \"HY000\");\\\n        return (value);\\\n    }\n#else\n#  define ASYNC_CHECK_RETURN(h, value)\n#endif\n\nstatic int parse_number(char *string, STRLEN len, char **end);\n\nDBISTATE_DECLARE;\n\ntypedef struct sql_type_info_s\n{\n    const char *type_name;\n    int data_type;\n    int column_size;\n    const char *literal_prefix;\n    const char *literal_suffix;\n    const char *create_params;\n    int nullable;\n    int case_sensitive;\n    int searchable;\n    int unsigned_attribute;\n    int fixed_prec_scale;\n    int auto_unique_value;\n    const char *local_type_name;\n    int minimum_scale;\n    int maximum_scale;\n    int num_prec_radix;\n    int sql_datatype;\n    int sql_datetime_sub;\n    int interval_precision;\n    int native_type;\n    int is_num;\n} sql_type_info_t;\n\n\n/*\n\n  This function manually counts the number of placeholders in an SQL statement,\n  used for emulated prepare statements < 4.1.3\n\n*/\nstatic int\ncount_params(imp_xxh_t *imp_xxh, pTHX_ char *statement, bool bind_comment_placeholders)\n{\n  bool comment_end= false;\n  char* ptr= statement;\n  int num_params= 0;\n  int comment_length= 0;\n  char c;\n\n  if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \">count_params statement %s\\n\", statement);\n\n  while ( (c = *ptr++) )\n  {\n    switch (c) {\n      /* so, this is a -- comment, so let's burn up characters */\n    case '-':\n      {\n          if (bind_comment_placeholders)\n          {\n              c = *ptr++;\n              break;\n          }\n          else\n          {\n              comment_length= 1;\n              /* let's see if the next one is a dash */\n              c = *ptr++;\n\n              if  (c == '-') {\n                  /* if two dashes, ignore everything until newline */\n                  while ((c = *ptr))\n                  {\n                      if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\n                          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%c\\n\", c);\n                      ptr++;\n                      comment_length++;\n                      if (c == '\\n')\n                      {\n                          comment_end= true;\n                          break;\n                      }\n                  }\n                  /*\n                    if not comment_end, the comment never ended and we need to iterate\n                    back to the beginning of where we started and let the database \n                    handle whatever is in the statement\n                */\n                  if (! comment_end)\n                      ptr-= comment_length;\n              }\n              /* otherwise, only one dash/hyphen, backtrack by one */\n              else\n                  ptr--;\n              break;\n          }\n      }\n    /* c-type comments */\n    case '/':\n      {\n          if (bind_comment_placeholders)\n          {\n              c = *ptr++;\n              break;\n          }\n          else\n          {\n              c = *ptr++;\n              /* let's check if the next one is an asterisk */\n              if  (c == '*')\n              {\n                  comment_length= 0;\n                  comment_end= false;\n                  /* ignore everything until closing comment */\n                  while ((c= *ptr))\n                  {\n                      ptr++;\n                      comment_length++;\n\n                      if (c == '*')\n                      {\n                          c = *ptr++;\n                          /* alas, end of comment */\n                          if (c == '/')\n                          {\n                              comment_end= true;\n                              break;\n                          }\n                          /*\n                            nope, just an asterisk, not so fast, not\n                            end of comment, go back one\n                        */\n                          else\n                              ptr--;\n                      }\n                  }\n                  /*\n                    if the end of the comment was never found, we have\n                    to backtrack to whereever we first started skipping\n                    over the possible comment.\n                    This means we will pass the statement to the database\n                    to see its own fate and issue the error\n                */\n                  if (!comment_end)\n                      ptr -= comment_length;\n              }\n              else\n                  ptr--;\n              break;\n          }\n      }\n    case '`':\n    case '\"':\n    case '\\'':\n      /* Skip string */\n      {\n        char end_token = c;\n        while ((c = *ptr)  &&  c != end_token)\n        {\n          if (c == '\\\\')\n            if (! *(++ptr))\n              continue;\n\n          ++ptr;\n        }\n        if (c)\n          ++ptr;\n        break;\n      }\n\n    case '?':\n      ++num_params;\n      break;\n\n    default:\n      break;\n    }\n  }\n  return num_params;\n}\n\n/*\n  allocate memory in statement handle per number of placeholders\n*/\nstatic imp_sth_ph_t *alloc_param(int num_params)\n{\n  imp_sth_ph_t *params;\n\n  if (num_params)\n    Newz(908, params, (unsigned int) num_params, imp_sth_ph_t);\n  else\n    params= NULL;\n\n  return params;\n}\n\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n/*\n  allocate memory in MYSQL_BIND bind structure per\n  number of placeholders\n*/\nstatic MYSQL_BIND *alloc_bind(int num_params)\n{\n  MYSQL_BIND *bind;\n\n  if (num_params)\n    Newz(908, bind, (unsigned int) num_params, MYSQL_BIND);\n  else\n    bind= NULL;\n\n  return bind;\n}\n\n/*\n  allocate memory in fbind imp_sth_phb_t structure per\n  number of placeholders\n*/\nstatic imp_sth_phb_t *alloc_fbind(int num_params)\n{\n  imp_sth_phb_t *fbind;\n\n  if (num_params)\n    Newz(908, fbind, (unsigned int) num_params, imp_sth_phb_t);\n  else\n    fbind= NULL;\n\n  return fbind;\n}\n\n/*\n  alloc memory for imp_sth_fbh_t fbuffer per number of fields\n*/\nstatic imp_sth_fbh_t *alloc_fbuffer(int num_fields)\n{\n  imp_sth_fbh_t *fbh;\n\n  if (num_fields)\n    Newz(908, fbh, (unsigned int) num_fields, imp_sth_fbh_t);\n  else\n    fbh= NULL;\n\n  return fbh;\n}\n\n/*\n  free MYSQL_BIND bind struct\n*/\nstatic void free_bind(MYSQL_BIND *bind)\n{\n  if (bind)\n    Safefree(bind);\n}\n\n/*\n   free imp_sth_phb_t fbind structure\n*/\nstatic void free_fbind(imp_sth_phb_t *fbind)\n{\n  if (fbind)\n    Safefree(fbind);\n}\n\n/*\n  free imp_sth_fbh_t fbh structure\n*/\nstatic void free_fbuffer(imp_sth_fbh_t *fbh)\n{\n  if (fbh)\n    Safefree(fbh);\n}\n\n#endif\n\n/*\n  free statement param structure per num_params\n*/\nstatic void\nfree_param(pTHX_ imp_sth_ph_t *params, int num_params)\n{\n  if (params)\n  {\n    int i;\n    for (i= 0;  i < num_params;  i++)\n    {\n      imp_sth_ph_t *ph= params+i;\n      if (ph->value)\n      {\n        (void) SvREFCNT_dec(ph->value);\n        ph->value= NULL;\n      }\n    }\n    Safefree(params);\n  }\n}\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n/* \n  Convert a MySQL type to a type that perl can handle\n\n  NOTE: In the future we may want to return a struct with a lot of\n  information for each type\n*/\n\nstatic enum enum_field_types mysql_to_perl_type(enum enum_field_types type)\n{\n  static enum enum_field_types enum_type;\n\n  switch (type) {\n  case MYSQL_TYPE_DOUBLE:\n  case MYSQL_TYPE_FLOAT:\n    enum_type= MYSQL_TYPE_DOUBLE;\n    break;\n\n  case MYSQL_TYPE_SHORT:\n  case MYSQL_TYPE_TINY:\n  case MYSQL_TYPE_LONG:\n  case MYSQL_TYPE_INT24:\n  case MYSQL_TYPE_YEAR:\n#if MYSQL_VERSION_ID > NEW_DATATYPE_VERSION\n  case MYSQL_TYPE_BIT:\n#endif\n    enum_type= MYSQL_TYPE_LONG;\n    break;\n\n#if MYSQL_VERSION_ID > NEW_DATATYPE_VERSION\n  case MYSQL_TYPE_NEWDECIMAL:\n#endif\n  case MYSQL_TYPE_DECIMAL:\n    enum_type= MYSQL_TYPE_DECIMAL;\n    break;\n\n  case MYSQL_TYPE_LONGLONG:\t\t\t/* No longlong in perl */\n  case MYSQL_TYPE_DATE:\n  case MYSQL_TYPE_TIME:\n  case MYSQL_TYPE_DATETIME:\n  case MYSQL_TYPE_NEWDATE:\n  case MYSQL_TYPE_TIMESTAMP:\n  case MYSQL_TYPE_VAR_STRING:\n#if MYSQL_VERSION_ID > NEW_DATATYPE_VERSION\n  case MYSQL_TYPE_VARCHAR:\n#endif\n  case MYSQL_TYPE_STRING:\n    enum_type= MYSQL_TYPE_STRING;\n    break;\n\n#if MYSQL_VERSION_ID > GEO_DATATYPE_VERSION\n  case MYSQL_TYPE_GEOMETRY:\n#endif\n  case MYSQL_TYPE_BLOB:\n  case MYSQL_TYPE_TINY_BLOB:\n    enum_type= MYSQL_TYPE_BLOB;\n    break;\n\n  default:\n    enum_type= MYSQL_TYPE_STRING;    /* MySQL can handle all types as strings */\n  }\n  return(enum_type);\n}\n#endif\n\n#if defined(DBD_MYSQL_EMBEDDED)\n/* \n  count embedded options\n*/\nint count_embedded_options(char *st)\n{\n  int rc;\n  char c;\n  char *ptr;\n\n  ptr= st;\n  rc= 0;\n\n  if (st)\n  {\n    while ((c= *ptr++))\n    {\n      if (c == ',')\n        rc++;\n    }\n    rc++;\n  }\n\n  return rc;\n}\n\n/*\n  Free embbedded options\n*/\nint free_embedded_options(char ** options_list, int options_count)\n{\n  int i;\n\n  for (i= 0; i < options_count; i++)\n  {\n    if (options_list[i])\n      free(options_list[i]);\n  }\n  free(options_list);\n\n  return 1;\n}\n\n/*\n Print out embbedded option settings\n\n*/\nint print_embedded_options(char ** options_list, int options_count)\n{\n  int i;\n\n  for (i=0; i<options_count; i++)\n  {\n    if (options_list[i])\n        PerlIO_printf(DBILOGFP,\n                      \"Embedded server, parameter[%d]=%s\\n\",\n                      i, options_list[i]);\n  }\n  return 1;\n}\n\n/*\n\n*/\nchar **fill_out_embedded_options(char *options,\n                                 int options_type,\n                                 int slen, int cnt)\n{\n  int  ind, len;\n  char c;\n  char *ptr;\n  char **options_list= NULL;\n\n  if (!(options_list= (char **) calloc(cnt, sizeof(char *))))\n  {\n    PerlIO_printf(DBILOGFP,\n                  \"Initialize embedded server. Out of memory \\n\");\n    return NULL;\n  }\n\n  ptr= options;\n  ind= 0;\n\n  if (options_type == 0)\n  {\n    /* server_groups list NULL terminated */\n    options_list[cnt]= (char *) NULL;\n  }\n\n  if (options_type == 1)\n  {\n    /* first item in server_options list is ignored. fill it with \\0 */\n    if (!(options_list[0]= calloc(1,sizeof(char))))\n      return NULL;\n\n    ind++;\n  }\n\n  while ((c= *ptr++))\n  {\n    slen--;\n    if (c == ',' || !slen)\n    {\n      len= ptr - options;\n      if (c == ',')\n        len--;\n      if (!(options_list[ind]=calloc(len+1,sizeof(char))))\n        return NULL;\n\n      strncpy(options_list[ind], options, len);\n      ind++;\n      options= ptr;\n    }\n  }\n  return options_list;\n}\n#endif\n\n/*\n  constructs an SQL statement previously prepared with\n  actual values replacing placeholders\n*/\nstatic char *parse_params(\n                          imp_xxh_t *imp_xxh,\n                          pTHX_ MYSQL *sock,\n                          char *statement,\n                          STRLEN *slen_ptr,\n                          imp_sth_ph_t* params,\n                          int num_params,\n                          bool bind_type_guessing,\n                          bool bind_comment_placeholders)\n{\n  bool comment_end= false;\n  char *salloc, *statement_ptr;\n  char *statement_ptr_end, *ptr, *valbuf;\n  char *cp, *end;\n  int alen, i;\n  int slen= *slen_ptr;\n  int limit_flag= 0;\n  int comment_length=0;\n  STRLEN vallen;\n  imp_sth_ph_t *ph;\n\n  if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \">parse_params statement %s\\n\", statement);\n\n  if (num_params == 0)\n    return NULL;\n\n  while (isspace(*statement))\n  {\n    ++statement;\n    --slen;\n  }\n\n  /* Calculate the number of bytes being allocated for the statement */\n  alen= slen;\n\n  for (i= 0, ph= params; i < num_params; i++, ph++)\n  {\n    int defined= 0;\n    if (ph->value)\n    {\n      if (SvMAGICAL(ph->value))\n        mg_get(ph->value);\n      if (SvOK(ph->value))\n        defined=1;\n    }\n    if (!defined)\n      alen+= 3;  /* Erase '?', insert 'NULL' */\n    else\n    {\n      valbuf= SvPV(ph->value, vallen);\n      alen+= 2+vallen+1;\n      /* this will most likely not happen since line 214 */\n      /* of mysql.xs hardcodes all types to SQL_VARCHAR */\n      if (!ph->type)\n      {\n        if (bind_type_guessing)\n        {\n          valbuf= SvPV(ph->value, vallen);\n          ph->type= SQL_INTEGER;\n\n          if (parse_number(valbuf, vallen, &end) != 0)\n          {\n              ph->type= SQL_VARCHAR;\n          }\n        }\n        else\n          ph->type= SQL_VARCHAR;\n      }\n    }\n  }\n\n  /* Allocate memory, why *2, well, because we have ptr and statement_ptr */\n  New(908, salloc, alen*2, char);\n  ptr= salloc;\n\n  i= 0;\n /* Now create the statement string; compare count_params above */\n  statement_ptr_end= (statement_ptr= statement)+ slen;\n\n  while (statement_ptr < statement_ptr_end)\n  {\n    /* LIMIT should be the last part of the query, in most cases */\n    if (! limit_flag)\n    {\n      /*\n        it would be good to be able to handle any number of cases and orders\n      */\n      if ((*statement_ptr == 'l' || *statement_ptr == 'L') &&\n          (!strncmp(statement_ptr+1, \"imit ?\", 6) ||\n           !strncmp(statement_ptr+1, \"IMIT ?\", 6)))\n      {\n        limit_flag = 1;\n      }\n    }\n    switch (*statement_ptr)\n    {\n      /* comment detection. Anything goes in a comment */\n      case '-':\n      {\n          if (bind_comment_placeholders)\n          {\n              *ptr++= *statement_ptr++;\n              break;\n          }\n          else\n          {\n              comment_length= 1;\n              comment_end= false;\n              *ptr++ = *statement_ptr++;\n              if  (*statement_ptr == '-')\n              {\n                  /* ignore everything until newline or end of string */\n                  while (*statement_ptr)\n                  {\n                      comment_length++;\n                      *ptr++ = *statement_ptr++;\n                      if (!*statement_ptr || *statement_ptr == '\\n')\n                      {\n                          comment_end= true;\n                          break;\n                      }\n                  }\n                  /* if not end of comment, go back to where we started, no end found */\n                  if (! comment_end)\n                  {\n                      statement_ptr -= comment_length;\n                      ptr -= comment_length;\n                  }\n              }\n              break;\n          }\n      }\n      /* c-type comments */\n      case '/':\n      {\n          if (bind_comment_placeholders)\n          {\n              *ptr++= *statement_ptr++;\n              break;\n          }\n          else\n          {\n              comment_length= 1;\n              comment_end= false;\n              *ptr++ = *statement_ptr++;\n              if  (*statement_ptr == '*')\n              {\n                  /* use up characters everything until newline */\n                  while (*statement_ptr)\n                  {\n                      *ptr++ = *statement_ptr++;\n                      comment_length++;\n                      if (!strncmp(statement_ptr, \"*/\", 2))\n                      {\n                          comment_length += 2;\n                          comment_end= true;\n                          break;\n                      }\n                  }\n                  /* Go back to where started if comment end not found */\n                  if (! comment_end)\n                  {\n                      statement_ptr -= comment_length;\n                      ptr -= comment_length;\n                  }\n              }\n              break;\n          }\n      }\n      case '`':\n      case '\\'':\n      case '\"':\n      /* Skip string */\n      {\n        char endToken = *statement_ptr++;\n        *ptr++ = endToken;\n        while (statement_ptr != statement_ptr_end &&\n               *statement_ptr != endToken)\n        {\n          if (*statement_ptr == '\\\\')\n          {\n            *ptr++ = *statement_ptr++;\n            if (statement_ptr == statement_ptr_end)\n\t      break;\n\t  }\n          *ptr++= *statement_ptr++;\n\t}\n\tif (statement_ptr != statement_ptr_end)\n          *ptr++= *statement_ptr++;\n      }\n      break;\n\n      case '?':\n        /* Insert parameter */\n        statement_ptr++;\n        if (i >= num_params)\n        {\n          break;\n        }\n\n        ph = params+ (i++);\n        if (!ph->value  ||  !SvOK(ph->value))\n        {\n          *ptr++ = 'N';\n          *ptr++ = 'U';\n          *ptr++ = 'L';\n          *ptr++ = 'L';\n        }\n        else\n        {\n          int is_num = FALSE;\n\n          valbuf= SvPV(ph->value, vallen);\n          if (valbuf)\n          {\n            switch (ph->type)\n            {\n              case SQL_NUMERIC:\n              case SQL_DECIMAL:\n              case SQL_INTEGER:\n              case SQL_SMALLINT:\n              case SQL_FLOAT:\n              case SQL_REAL:\n              case SQL_DOUBLE:\n              case SQL_BIGINT:\n              case SQL_TINYINT:\n                is_num = TRUE;\n                break;\n            }\n\n            /* (note this sets *end, which we use if is_num) */\n            if ( parse_number(valbuf, vallen, &end) != 0 && is_num)\n            {\n              if (bind_type_guessing) {\n                /* .. not a number, so apparerently we guessed wrong */\n                is_num = 0;\n                ph->type = SQL_VARCHAR;\n              }\n            }\n\n\n            /* we're at the end of the query, so any placeholders if */\n            /* after a LIMIT clause will be numbers and should not be quoted */\n            if (limit_flag == 1)\n              is_num = TRUE;\n\n            if (!is_num)\n            {\n              *ptr++ = '\\'';\n              ptr += mysql_real_escape_string(sock, ptr, valbuf, vallen);\n              *ptr++ = '\\'';\n            }\n            else\n            {\n              for (cp= valbuf; cp < end; cp++)\n                  *ptr++= *cp;\n            }\n          }\n        }\n        break;\n\n\t/* in case this is a nested LIMIT */\n      case ')':\n        limit_flag = 0;\n\t*ptr++ = *statement_ptr++;\n        break;\n\n      default:\n        *ptr++ = *statement_ptr++;\n        break;\n\n    }\n  }\n\n  *slen_ptr = ptr - salloc;\n  *ptr++ = '\\0';\n\n  return(salloc);\n}\n\nint bind_param(imp_sth_ph_t *ph, SV *value, IV sql_type)\n{\n  dTHX;\n  if (ph->value)\n  {\n    if (SvMAGICAL(ph->value))\n      mg_get(ph->value);\n    (void) SvREFCNT_dec(ph->value);\n  }\n\n  ph->value= newSVsv(value);\n\n  if (sql_type)\n    ph->type = sql_type;\n\n  return TRUE;\n}\n\nstatic const sql_type_info_t SQL_GET_TYPE_INFO_values[]= {\n  { \"varchar\",    SQL_VARCHAR,                    255, \"'\",  \"'\",  \"max length\",\n    1, 0, 3, 0, 0, 0, \"variable length string\",\n    0, 0, 0,\n    SQL_VARCHAR, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_VAR_STRING,  0,\n#else\n    MYSQL_TYPE_STRING,  0,\n#endif\n  },\n  { \"decimal\",   SQL_DECIMAL,                      15, NULL, NULL, \"precision,scale\",\n    1, 0, 3, 0, 0, 0, \"double\",\n    0, 6, 2,\n    SQL_DECIMAL, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_DECIMAL,     1\n#else\n    MYSQL_TYPE_DECIMAL,     1\n#endif\n  },\n  { \"tinyint\",   SQL_TINYINT,                       3, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"Tiny integer\",\n    0, 0, 10,\n    SQL_TINYINT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_TINY,        1\n#else\n    MYSQL_TYPE_TINY,     1\n#endif\n  },\n  { \"smallint\",  SQL_SMALLINT,                      5, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"Short integer\",\n    0, 0, 10,\n    SQL_SMALLINT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_SHORT,       1\n#else\n    MYSQL_TYPE_SHORT,     1\n#endif\n  },\n  { \"integer\",   SQL_INTEGER,                      10, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"integer\",\n    0, 0, 10,\n    SQL_INTEGER, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_LONG,        1\n#else\n    MYSQL_TYPE_LONG,     1\n#endif\n  },\n  { \"float\",     SQL_REAL,                          7,  NULL, NULL, NULL,\n    1, 0, 0, 0, 0, 0, \"float\",\n    0, 2, 10,\n    SQL_FLOAT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_FLOAT,       1\n#else\n    MYSQL_TYPE_FLOAT,     1\n#endif\n  },\n  { \"double\",    SQL_FLOAT,                       15,  NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"double\",\n    0, 4, 2,\n    SQL_FLOAT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_DOUBLE,      1\n#else\n    MYSQL_TYPE_DOUBLE,     1\n#endif\n  },\n  { \"double\",    SQL_DOUBLE,                       15,  NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"double\",\n    0, 4, 10,\n    SQL_DOUBLE, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_DOUBLE,      1\n#else\n    MYSQL_TYPE_DOUBLE,     1\n#endif\n  },\n  /*\n    FIELD_TYPE_NULL ?\n  */\n  { \"timestamp\", SQL_TIMESTAMP,                    14, \"'\", \"'\", NULL,\n    0, 0, 3, 0, 0, 0, \"timestamp\",\n    0, 0, 0,\n    SQL_TIMESTAMP, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_TIMESTAMP,   0\n#else\n    MYSQL_TYPE_TIMESTAMP,     0\n#endif\n  },\n  { \"bigint\",    SQL_BIGINT,                       19, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"Longlong integer\",\n    0, 0, 10,\n    SQL_BIGINT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_LONGLONG,    1\n#else\n    MYSQL_TYPE_LONGLONG,     1\n#endif\n  },\n  { \"mediumint\", SQL_INTEGER,                       8, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"Medium integer\",\n    0, 0, 10,\n    SQL_INTEGER, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_INT24,       1\n#else\n    MYSQL_TYPE_INT24,     1\n#endif\n  },\n  { \"date\", SQL_DATE, 10, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"date\",\n    0, 0, 0,\n    SQL_DATE, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_DATE, 0\n#else\n    MYSQL_TYPE_DATE, 0\n#endif\n  },\n  { \"time\", SQL_TIME, 6, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"time\",\n    0, 0, 0,\n    SQL_TIME, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_TIME,        0\n#else\n    MYSQL_TYPE_TIME,     0\n#endif\n  },\n  { \"datetime\",  SQL_TIMESTAMP, 21, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"datetime\",\n    0, 0, 0,\n    SQL_TIMESTAMP, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_DATETIME,    0\n#else\n    MYSQL_TYPE_DATETIME,     0\n#endif\n  },\n  { \"year\", SQL_SMALLINT, 4, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"year\",\n    0, 0, 10,\n    SQL_SMALLINT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_YEAR,        0\n#else\n    MYSQL_TYPE_YEAR,     0\n#endif\n  },\n  { \"date\", SQL_DATE, 10, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"date\",\n    0, 0, 0,\n    SQL_DATE, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_NEWDATE,     0\n#else\n    MYSQL_TYPE_NEWDATE,     0\n#endif\n  },\n  { \"enum\",      SQL_VARCHAR,                     255, \"'\",  \"'\",  NULL,\n    1, 0, 1, 0, 0, 0, \"enum(value1,value2,value3...)\",\n    0, 0, 0,\n    0, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_ENUM,        0\n#else\n    MYSQL_TYPE_ENUM,     0\n#endif\n  },\n  { \"set\",       SQL_VARCHAR,                     255, \"'\",  \"'\",  NULL,\n    1, 0, 1, 0, 0, 0, \"set(value1,value2,value3...)\",\n    0, 0, 0,\n    0, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_SET,         0\n#else\n    MYSQL_TYPE_SET,     0\n#endif\n  },\n  { \"blob\",       SQL_LONGVARBINARY,              65535, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"binary large object (0-65535)\",\n    0, 0, 0,\n    SQL_LONGVARBINARY, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_BLOB,        0\n#else\n    MYSQL_TYPE_BLOB,     0\n#endif\n  },\n  { \"tinyblob\",  SQL_VARBINARY,                 255, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"binary large object (0-255) \",\n    0, 0, 0,\n    SQL_VARBINARY, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_TINY_BLOB,   0\n#else\n    FIELD_TYPE_TINY_BLOB,        0\n#endif\n  },\n  { \"mediumblob\", SQL_LONGVARBINARY,           16777215, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"binary large object\",\n    0, 0, 0,\n    SQL_LONGVARBINARY, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0 \n    FIELD_TYPE_MEDIUM_BLOB, 0\n#else\n    MYSQL_TYPE_MEDIUM_BLOB, 0\n#endif\n  },\n  { \"longblob\",   SQL_LONGVARBINARY,         2147483647, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"binary large object, use mediumblob instead\",\n    0, 0, 0,\n    SQL_LONGVARBINARY, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0 \n    FIELD_TYPE_LONG_BLOB,   0\n#else\n    MYSQL_TYPE_LONG_BLOB,   0\n#endif\n  },\n  { \"char\",       SQL_CHAR,                       255, \"'\",  \"'\",  \"max length\",\n    1, 0, 3, 0, 0, 0, \"string\",\n    0, 0, 0,\n    SQL_CHAR, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0 \n    FIELD_TYPE_STRING,      0\n#else\n    MYSQL_TYPE_STRING,   0\n#endif\n  },\n\n  { \"decimal\",            SQL_NUMERIC,            15,  NULL, NULL, \"precision,scale\",\n    1, 0, 3, 0, 0, 0, \"double\",\n    0, 6, 2,\n    SQL_NUMERIC, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_DECIMAL,     1\n#else\n    MYSQL_TYPE_DECIMAL,   1 \n#endif\n  },\n  { \"tinyint unsigned\",   SQL_TINYINT,              3, NULL, NULL, NULL,\n    1, 0, 3, 1, 0, 0, \"Tiny integer unsigned\",\n    0, 0, 10,\n    SQL_TINYINT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_TINY,        1\n#else\n    MYSQL_TYPE_TINY,        1\n#endif\n  },\n  { \"smallint unsigned\",  SQL_SMALLINT,             5, NULL, NULL, NULL,\n    1, 0, 3, 1, 0, 0, \"Short integer unsigned\",\n    0, 0, 10,\n    SQL_SMALLINT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_SHORT,       1\n#else\n    MYSQL_TYPE_SHORT,       1\n#endif\n  },\n  { \"mediumint unsigned\", SQL_INTEGER,              8, NULL, NULL, NULL,\n    1, 0, 3, 1, 0, 0, \"Medium integer unsigned\",\n    0, 0, 10,\n    SQL_INTEGER, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_INT24,       1\n#else\n    MYSQL_TYPE_INT24,       1\n#endif\n  },\n  { \"int unsigned\",       SQL_INTEGER,             10, NULL, NULL, NULL,\n    1, 0, 3, 1, 0, 0, \"integer unsigned\",\n    0, 0, 10,\n    SQL_INTEGER, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_LONG,        1\n#else\n    MYSQL_TYPE_LONG,        1\n#endif\n  },\n  { \"int\",                SQL_INTEGER,             10, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"integer\",\n    0, 0, 10,\n    SQL_INTEGER, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_LONG,        1\n#else\n    MYSQL_TYPE_LONG,        1\n#endif\n  },\n  { \"integer unsigned\",   SQL_INTEGER,             10, NULL, NULL, NULL,\n    1, 0, 3, 1, 0, 0, \"integer\",\n    0, 0, 10,\n    SQL_INTEGER, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_LONG,        1\n#else\n    MYSQL_TYPE_LONG,        1\n#endif\n  },\n  { \"bigint unsigned\",    SQL_BIGINT,              20, NULL, NULL, NULL,\n    1, 0, 3, 1, 0, 0, \"Longlong integer unsigned\",\n    0, 0, 10,\n    SQL_BIGINT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_LONGLONG,    1\n#else\n    MYSQL_TYPE_LONGLONG,    1\n#endif\n  },\n  { \"text\",               SQL_LONGVARCHAR,      65535, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"large text object (0-65535)\",\n    0, 0, 0,\n    SQL_LONGVARCHAR, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_BLOB,        0\n#else\n    MYSQL_TYPE_BLOB,        0\n#endif\n  },\n  { \"mediumtext\",         SQL_LONGVARCHAR,   16777215, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"large text object\",\n    0, 0, 0,\n    SQL_LONGVARCHAR, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_MEDIUM_BLOB, 0\n#else\n    MYSQL_TYPE_MEDIUM_BLOB, 0\n#endif\n  },\n  { \"mediumint unsigned auto_increment\", SQL_INTEGER, 8, NULL, NULL, NULL,\n    0, 0, 3, 1, 0, 1, \"Medium integer unsigned auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_INTEGER, 0, 0, FIELD_TYPE_INT24, 1,\n#else\n    SQL_INTEGER, 0, 0, MYSQL_TYPE_INT24, 1,\n#endif\n  },\n  { \"tinyint unsigned auto_increment\", SQL_TINYINT, 3, NULL, NULL, NULL,\n    0, 0, 3, 1, 0, 1, \"tinyint unsigned auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_TINYINT, 0, 0, FIELD_TYPE_TINY, 1\n#else\n    SQL_TINYINT, 0, 0, MYSQL_TYPE_TINY, 1\n#endif\n  },\n\n  { \"smallint auto_increment\", SQL_SMALLINT, 5, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"smallint auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_SMALLINT, 0, 0, FIELD_TYPE_SHORT, 1\n#else\n    SQL_SMALLINT, 0, 0, MYSQL_TYPE_SHORT, 1\n#endif\n  },\n\n  { \"int unsigned auto_increment\", SQL_INTEGER, 10, NULL, NULL, NULL,\n    0, 0, 3, 1, 0, 1, \"integer unsigned auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_INTEGER, 0, 0, FIELD_TYPE_LONG, 1\n#else\n    SQL_INTEGER, 0, 0, MYSQL_TYPE_LONG, 1\n#endif\n  },\n\n  { \"mediumint\", SQL_INTEGER, 7, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"Medium integer\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_INTEGER, 0, 0, FIELD_TYPE_INT24, 1\n#else\n    SQL_INTEGER, 0, 0, MYSQL_TYPE_INT24, 1\n#endif\n  },\n\n  { \"bit\", SQL_BIT, 1, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"char(1)\", 0, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_BIT, 0, 0, FIELD_TYPE_TINY, 0\n#else\n    SQL_BIT, 0, 0, MYSQL_TYPE_TINY, 0\n#endif\n  },\n\n  { \"numeric\", SQL_NUMERIC, 19, NULL, NULL, \"precision,scale\",\n    1, 0, 3, 0, 0, 0, \"numeric\", 0, 19, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_NUMERIC, 0, 0, FIELD_TYPE_DECIMAL, 1,\n#else\n    SQL_NUMERIC, 0, 0, MYSQL_TYPE_DECIMAL, 1,\n#endif\n  },\n\n  { \"integer unsigned auto_increment\", SQL_INTEGER, 10, NULL, NULL, NULL,\n    0, 0, 3, 1, 0, 1, \"integer unsigned auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_INTEGER, 0, 0, FIELD_TYPE_LONG, 1,\n#else\n    SQL_INTEGER, 0, 0, MYSQL_TYPE_LONG, 1,\n#endif\n  },\n\n  { \"mediumint unsigned\", SQL_INTEGER, 8, NULL, NULL, NULL,\n    1, 0, 3, 1, 0, 0, \"Medium integer unsigned\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_INTEGER, 0, 0, FIELD_TYPE_INT24, 1\n#else\n    SQL_INTEGER, 0, 0, MYSQL_TYPE_INT24, 1\n#endif\n  },\n\n  { \"smallint unsigned auto_increment\", SQL_SMALLINT, 5, NULL, NULL, NULL,\n    0, 0, 3, 1, 0, 1, \"smallint unsigned auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_SMALLINT, 0, 0, FIELD_TYPE_SHORT, 1\n#else\n    SQL_SMALLINT, 0, 0, MYSQL_TYPE_SHORT, 1\n#endif\n  },\n\n  { \"int auto_increment\", SQL_INTEGER, 10, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"integer auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_INTEGER, 0, 0, FIELD_TYPE_LONG, 1\n#else\n    SQL_INTEGER, 0, 0, MYSQL_TYPE_LONG, 1\n#endif\n  },\n\n  { \"long varbinary\", SQL_LONGVARBINARY, 16777215, \"0x\", NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"mediumblob\", 0, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_LONGVARBINARY, 0, 0, FIELD_TYPE_LONG_BLOB, 0\n#else\n    SQL_LONGVARBINARY, 0, 0, MYSQL_TYPE_LONG_BLOB, 0\n#endif\n  },\n\n  { \"double auto_increment\", SQL_FLOAT, 15, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"double auto_increment\", 0, 4, 2,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_FLOAT, 0, 0, FIELD_TYPE_DOUBLE, 1\n#else\n    SQL_FLOAT, 0, 0, MYSQL_TYPE_DOUBLE, 1\n#endif\n  },\n\n  { \"double auto_increment\", SQL_DOUBLE, 15, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"double auto_increment\", 0, 4, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_DOUBLE, 0, 0, FIELD_TYPE_DOUBLE, 1\n#else\n    SQL_DOUBLE, 0, 0, MYSQL_TYPE_DOUBLE, 1\n#endif\n  },\n\n  { \"integer auto_increment\", SQL_INTEGER, 10, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"integer auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_INTEGER, 0, 0, FIELD_TYPE_LONG, 1,\n#else\n    SQL_INTEGER, 0, 0, MYSQL_TYPE_LONG, 1,\n#endif\n  },\n\n  { \"bigint auto_increment\", SQL_BIGINT, 19, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"bigint auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_BIGINT, 0, 0, FIELD_TYPE_LONGLONG, 1\n#else\n    SQL_BIGINT, 0, 0, MYSQL_TYPE_LONGLONG, 1\n#endif\n  },\n\n  { \"bit auto_increment\", SQL_BIT, 1, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"char(1) auto_increment\", 0, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_BIT, 0, 0, FIELD_TYPE_TINY, 1\n#else\n    SQL_BIT, 0, 0, MYSQL_TYPE_TINY, 1\n#endif\n  },\n\n  { \"mediumint auto_increment\", SQL_INTEGER, 7, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"Medium integer auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_INTEGER, 0, 0, FIELD_TYPE_INT24, 1\n#else\n    SQL_INTEGER, 0, 0, MYSQL_TYPE_INT24, 1\n#endif\n  },\n\n  { \"float auto_increment\", SQL_REAL, 7, NULL, NULL, NULL,\n    0, 0, 0, 0, 0, 1, \"float auto_increment\", 0, 2, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_FLOAT, 0, 0, FIELD_TYPE_FLOAT, 1\n#else\n    SQL_FLOAT, 0, 0, MYSQL_TYPE_FLOAT, 1\n#endif\n  },\n\n  { \"long varchar\", SQL_LONGVARCHAR, 16777215, \"'\", \"'\", NULL,\n    1, 0, 3, 0, 0, 0, \"mediumtext\", 0, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_LONGVARCHAR, 0, 0, FIELD_TYPE_MEDIUM_BLOB, 1\n#else\n    SQL_LONGVARCHAR, 0, 0, MYSQL_TYPE_MEDIUM_BLOB, 1\n#endif\n\n  },\n\n  { \"tinyint auto_increment\", SQL_TINYINT, 3, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"tinyint auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_TINYINT, 0, 0, FIELD_TYPE_TINY, 1\n#else\n    SQL_TINYINT, 0, 0, MYSQL_TYPE_TINY, 1\n#endif\n  },\n\n  { \"bigint unsigned auto_increment\", SQL_BIGINT, 20, NULL, NULL, NULL,\n    0, 0, 3, 1, 0, 1, \"bigint unsigned auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_BIGINT, 0, 0, FIELD_TYPE_LONGLONG, 1\n#else\n    SQL_BIGINT, 0, 0, MYSQL_TYPE_LONGLONG, 1\n#endif\n  },\n\n/* END MORE STUFF */\n};\n\n/* \n  static const sql_type_info_t* native2sql (int t)\n*/\nstatic const sql_type_info_t *native2sql(int t)\n{\n  switch (t) {\n    case FIELD_TYPE_VAR_STRING:  return &SQL_GET_TYPE_INFO_values[0];\n    case FIELD_TYPE_DECIMAL:     return &SQL_GET_TYPE_INFO_values[1];\n#ifdef FIELD_TYPE_NEWDECIMAL\n    case FIELD_TYPE_NEWDECIMAL:  return &SQL_GET_TYPE_INFO_values[1];\n#endif\n    case FIELD_TYPE_TINY:        return &SQL_GET_TYPE_INFO_values[2];\n    case FIELD_TYPE_SHORT:       return &SQL_GET_TYPE_INFO_values[3];\n    case FIELD_TYPE_LONG:        return &SQL_GET_TYPE_INFO_values[4];\n    case FIELD_TYPE_FLOAT:       return &SQL_GET_TYPE_INFO_values[5];\n\n    /* 6  */\n    case FIELD_TYPE_DOUBLE:      return &SQL_GET_TYPE_INFO_values[7];\n    case FIELD_TYPE_TIMESTAMP:   return &SQL_GET_TYPE_INFO_values[8];\n    case FIELD_TYPE_LONGLONG:    return &SQL_GET_TYPE_INFO_values[9];\n    case FIELD_TYPE_INT24:       return &SQL_GET_TYPE_INFO_values[10];\n    case FIELD_TYPE_DATE:        return &SQL_GET_TYPE_INFO_values[11];\n    case FIELD_TYPE_TIME:        return &SQL_GET_TYPE_INFO_values[12];\n    case FIELD_TYPE_DATETIME:    return &SQL_GET_TYPE_INFO_values[13];\n    case FIELD_TYPE_YEAR:        return &SQL_GET_TYPE_INFO_values[14];\n    case FIELD_TYPE_NEWDATE:     return &SQL_GET_TYPE_INFO_values[15];\n    case FIELD_TYPE_ENUM:        return &SQL_GET_TYPE_INFO_values[16];\n    case FIELD_TYPE_SET:         return &SQL_GET_TYPE_INFO_values[17];\n    case FIELD_TYPE_BLOB:        return &SQL_GET_TYPE_INFO_values[18];\n    case FIELD_TYPE_TINY_BLOB:   return &SQL_GET_TYPE_INFO_values[19];\n    case FIELD_TYPE_MEDIUM_BLOB: return &SQL_GET_TYPE_INFO_values[20];\n    case FIELD_TYPE_LONG_BLOB:   return &SQL_GET_TYPE_INFO_values[21];\n    case FIELD_TYPE_STRING:      return &SQL_GET_TYPE_INFO_values[22];\n    default:                     return &SQL_GET_TYPE_INFO_values[0];\n  }\n}\n\n\n#define SQL_GET_TYPE_INFO_num \\\n\t(sizeof(SQL_GET_TYPE_INFO_values)/sizeof(sql_type_info_t))\n\n\n/***************************************************************************\n *\n *  Name:    dbd_init\n *\n *  Purpose: Called when the driver is installed by DBI\n *\n *  Input:   dbistate - pointer to the DBI state variable, used for some\n *               DBI internal things\n *\n *  Returns: Nothing\n *\n **************************************************************************/\n\nvoid dbd_init(dbistate_t* dbistate)\n{\n    dTHX;\n    DBISTATE_INIT;\n}\n\n\n/**************************************************************************\n *\n *  Name:    do_error, do_warn\n *\n *  Purpose: Called to associate an error code and an error message\n *           to some handle\n *\n *  Input:   h - the handle in error condition\n *           rc - the error code\n *           what - the error message\n *\n *  Returns: Nothing\n *\n **************************************************************************/\n\nvoid do_error(SV* h, int rc, const char* what, const char* sqlstate)\n{\n  dTHX;\n  D_imp_xxh(h);\n  STRLEN lna;\n  SV *errstr;\n  SV *errstate;\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\t--> do_error\\n\");\n  errstr= DBIc_ERRSTR(imp_xxh);\n  sv_setiv(DBIc_ERR(imp_xxh), (IV)rc);\t/* set err early\t*/\n  sv_setpv(errstr, what);\n\n#if MYSQL_VERSION_ID >= SQL_STATE_VERSION\n  if (sqlstate)\n  {\n    errstate= DBIc_STATE(imp_xxh);\n    sv_setpvn(errstate, sqlstate, 5);\n  }\n#endif\n\n  /* NO EFFECT DBIh_EVENT2(h, ERROR_event, DBIc_ERR(imp_xxh), errstr); */\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%s error %d recorded: %s\\n\",\n    what, rc, SvPV(errstr,lna));\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\t<-- do_error\\n\");\n}\n\n/*\n  void do_warn(SV* h, int rc, char* what)\n*/\nvoid do_warn(SV* h, int rc, char* what)\n{\n  dTHX;\n  D_imp_xxh(h);\n  STRLEN lna;\n\n  SV *errstr = DBIc_ERRSTR(imp_xxh);\n  sv_setiv(DBIc_ERR(imp_xxh), (IV)rc);\t/* set err early\t*/\n  sv_setpv(errstr, what);\n  /* NO EFFECT DBIh_EVENT2(h, WARN_event, DBIc_ERR(imp_xxh), errstr);*/\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%s warning %d recorded: %s\\n\",\n    what, rc, SvPV(errstr,lna));\n  warn(\"%s\", what);\n}\n\n#if defined(DBD_MYSQL_EMBEDDED)\n #define DBD_MYSQL_NAMESPACE \"DBD::mysqlEmb::QUIET\";\n#else\n #define DBD_MYSQL_NAMESPACE \"DBD::mysql::QUIET\";\n#endif\n\n#define doquietwarn(s) \\\n  { \\\n    SV* sv = perl_get_sv(DBD_MYSQL_NAMESPACE, FALSE);  \\\n    if (!sv  ||  !SvTRUE(sv)) { \\\n      warn s; \\\n    } \\\n  }\n\n\n/***************************************************************************\n *\n *  Name:    mysql_dr_connect\n *\n *  Purpose: Replacement for mysql_connect\n *\n *  Input:   MYSQL* sock - Pointer to a MYSQL structure being\n *             initialized\n *           char* mysql_socket - Name of a UNIX socket being used\n *             or NULL\n *           char* host - Host name being used or NULL for localhost\n *           char* port - Port number being used or NULL for default\n *           char* user - User name being used or NULL\n *           char* password - Password being used or NULL\n *           char* dbname - Database name being used or NULL\n *           char* imp_dbh - Pointer to internal dbh structure\n *\n *  Returns: The sock argument for success, NULL otherwise;\n *           you have to call do_error in the latter case.\n *\n **************************************************************************/\n\nMYSQL *mysql_dr_connect(\n                        SV* dbh,\n                        MYSQL* sock,\n                        char* mysql_socket,\n                        char* host,\n\t\t\t                  char* port,\n                        char* user,\n                        char* password,\n\t\t\t                  char* dbname,\n                        imp_dbh_t *imp_dbh)\n{\n  int portNr;\n  unsigned int client_flag;\n  MYSQL* result;\n  dTHX;\n  D_imp_xxh(dbh);\n\n  /* per Monty, already in client.c in API */\n  /* but still not exist in libmysqld.c */\n#if defined(DBD_MYSQL_EMBEDDED)\n   if (host && !*host) host = NULL;\n#endif\n\n  portNr= (port && *port) ? atoi(port) : 0;\n\n  /* already in client.c in API */\n  /* if (user && !*user) user = NULL; */\n  /* if (password && !*password) password = NULL; */\n\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->mysql_dr_connect: host = |%s|, port = %d,\" \\\n\t\t  \" uid = %s, pwd = %s\\n\",\n\t\t  host ? host : \"NULL\", portNr,\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\");\n\n  {\n\n#if defined(DBD_MYSQL_EMBEDDED)\n    if (imp_dbh)\n    {\n      D_imp_drh_from_dbh;\n      SV* sv = DBIc_IMP_DATA(imp_dbh);\n\n      if (sv  &&  SvROK(sv))\n      {\n        SV** svp;\n        STRLEN lna;\n        char * options;\n        int server_args_cnt= 0;\n        int server_groups_cnt= 0;\n        int rc= 0;\n\n        char ** server_args = NULL;\n        char ** server_groups = NULL;\n\n        HV* hv = (HV*) SvRV(sv);\n\n        if (SvTYPE(hv) != SVt_PVHV)\n          return NULL;\n\n        if (!imp_drh->embedded.state)\n        {\n          /* Init embedded server */\n          if ((svp = hv_fetch(hv, \"mysql_embedded_groups\", 21, FALSE))  &&\n              *svp  &&  SvTRUE(*svp))\n          {\n            options = SvPV(*svp, lna);\n            imp_drh->embedded.groups=newSVsv(*svp);\n\n            if ((server_groups_cnt=count_embedded_options(options)))\n            {\n              /* number of server_groups always server_groups+1 */\n              server_groups=fill_out_embedded_options(options, 0, \n                                                      (int)lna, ++server_groups_cnt);\n              if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n              {\n                PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                              \"Groups names passed to embedded server:\\n\");\n                print_embedded_options(DBIc_LOGPIO(imp_xxh), server_groups, server_groups_cnt);\n              }\n            }\n          }\n\n          if ((svp = hv_fetch(hv, \"mysql_embedded_options\", 22, FALSE))  &&\n              *svp  &&  SvTRUE(*svp))\n          {\n            options = SvPV(*svp, lna);\n            imp_drh->embedded.args=newSVsv(*svp);\n\n            if ((server_args_cnt=count_embedded_options(options)))\n            {\n              /* number of server_options always server_options+1 */\n              server_args=fill_out_embedded_options(options, 1, (int)lna, ++server_args_cnt);\n              if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n              {\n                PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Server options passed to embedded server:\\n\");\n                print_embedded_options(DBIc_LOGPIO(imp_xxh), server_args, server_args_cnt);\n              }\n            }\n          }\n          if (mysql_server_init(server_args_cnt, server_args, server_groups))\n          {\n            do_warn(dbh, AS_ERR_EMBEDDED, \"Embedded server was not started. \\\n                    Could not initialize environment.\");\n            return NULL;\n          }\n          imp_drh->embedded.state=1;\n\n          if (server_args_cnt)\n            free_embedded_options(server_args, server_args_cnt);\n          if (server_groups_cnt)\n            free_embedded_options(server_groups, server_groups_cnt);\n        }\n        else\n        {\n         /*\n          * Check if embedded parameters passed to connect() differ from\n          * first ones\n          */\n\n          if ( ((svp = hv_fetch(hv, \"mysql_embedded_groups\", 21, FALSE)) &&\n            *svp  &&  SvTRUE(*svp)))\n            rc =+ abs(sv_cmp(*svp, imp_drh->embedded.groups));\n\n          if ( ((svp = hv_fetch(hv, \"mysql_embedded_options\", 22, FALSE)) &&\n            *svp  &&  SvTRUE(*svp)) )\n            rc =+ abs(sv_cmp(*svp, imp_drh->embedded.args));\n\n          if (rc)\n          {\n            do_warn(dbh, AS_ERR_EMBEDDED,\n                    \"Embedded server was already started. You cannot pass init\\\n                    parameters to embedded server once\");\n            return NULL;\n          }\n        }\n      }\n    }\n#endif\n\n#ifdef MYSQL_NO_CLIENT_FOUND_ROWS\n    client_flag = 0;\n#else\n    client_flag = CLIENT_FOUND_ROWS;\n#endif\n    mysql_init(sock);\n\n    if (imp_dbh)\n    {\n      SV* sv = DBIc_IMP_DATA(imp_dbh);\n\n      DBIc_set(imp_dbh, DBIcf_AutoCommit, TRUE);\n      if (sv  &&  SvROK(sv))\n      {\n        HV* hv = (HV*) SvRV(sv);\n        SV** svp;\n        STRLEN lna;\n\n        /* thanks to Peter John Edwards for mysql_init_command */ \n        if ((svp = hv_fetch(hv, \"mysql_init_command\", 18, FALSE)) &&\n            *svp && SvTRUE(*svp))\n        {\n          char* df = SvPV(*svp, lna);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                           \"imp_dbh->mysql_dr_connect: Setting\" \\\n                           \" init command (%s).\\n\", df);\n          mysql_options(sock, MYSQL_INIT_COMMAND, df);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_compression\", 17, FALSE))  &&\n            *svp && SvTRUE(*svp))\n        {\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->mysql_dr_connect: Enabling\" \\\n                          \" compression.\\n\");\n          mysql_options(sock, MYSQL_OPT_COMPRESS, NULL);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_connect_timeout\", 21, FALSE))\n            &&  *svp  &&  SvTRUE(*svp))\n        {\n          int to = SvIV(*svp);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->mysql_dr_connect: Setting\" \\\n                          \" connect timeout (%d).\\n\",to);\n          mysql_options(sock, MYSQL_OPT_CONNECT_TIMEOUT,\n                        (const char *)&to);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_write_timeout\", 19, FALSE))\n            &&  *svp  &&  SvTRUE(*svp))\n        {\n          int to = SvIV(*svp);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->mysql_dr_connect: Setting\" \\\n                          \" write timeout (%d).\\n\",to);\n          mysql_options(sock, MYSQL_OPT_WRITE_TIMEOUT,\n                        (const char *)&to);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_read_timeout\", 18, FALSE))\n            &&  *svp  &&  SvTRUE(*svp))\n        {\n          int to = SvIV(*svp);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->mysql_dr_connect: Setting\" \\\n                          \" read timeout (%d).\\n\",to);\n          mysql_options(sock, MYSQL_OPT_READ_TIMEOUT,\n                        (const char *)&to);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_skip_secure_auth\", 22, FALSE)) &&\n            *svp  &&  SvTRUE(*svp))\n        {\n          my_bool secauth = 0;\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->mysql_dr_connect: Skipping\" \\\n                          \" secure auth\\n\");\n          mysql_options(sock, MYSQL_SECURE_AUTH, &secauth);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_read_default_file\", 23, FALSE)) &&\n            *svp  &&  SvTRUE(*svp))\n        {\n          char* df = SvPV(*svp, lna);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->mysql_dr_connect: Reading\" \\\n                          \" default file %s.\\n\", df);\n          mysql_options(sock, MYSQL_READ_DEFAULT_FILE, df);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_read_default_group\", 24,\n                            FALSE))  &&\n            *svp  &&  SvTRUE(*svp)) {\n          char* gr = SvPV(*svp, lna);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"imp_dbh->mysql_dr_connect: Using\" \\\n                    \" default group %s.\\n\", gr);\n\n          mysql_options(sock, MYSQL_READ_DEFAULT_GROUP, gr);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_client_found_rows\", 23, FALSE)) && *svp)\n        {\n          if (SvTRUE(*svp))\n            client_flag |= CLIENT_FOUND_ROWS;\n          else\n            client_flag &= ~CLIENT_FOUND_ROWS;\n        }\n        if ((svp = hv_fetch(hv, \"mysql_use_result\", 16, FALSE)) && *svp)\n        {\n          imp_dbh->use_mysql_use_result = SvTRUE(*svp);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->use_mysql_use_result: %d\\n\",\n                          imp_dbh->use_mysql_use_result);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_bind_type_guessing\", 24, TRUE)) && *svp)\n        {\n          imp_dbh->bind_type_guessing= SvTRUE(*svp);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->bind_type_guessing: %d\\n\",\n                          imp_dbh->bind_type_guessing);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_bind_comment_placeholders\", 31, FALSE)) && *svp)\n        {\n          imp_dbh->bind_comment_placeholders = SvTRUE(*svp);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->bind_comment_placeholders: %d\\n\",\n                          imp_dbh->bind_comment_placeholders);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_no_autocommit_cmd\", 23, FALSE)) && *svp)\n        {\n          imp_dbh->no_autocommit_cmd= SvTRUE(*svp);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->no_autocommit_cmd: %d\\n\",\n                          imp_dbh->no_autocommit_cmd);\n        }\n\n\n#if defined(CLIENT_MULTI_STATEMENTS)\n\tif ((svp = hv_fetch(hv, \"mysql_multi_statements\", 22, FALSE)) && *svp)\n        {\n\t  if (SvTRUE(*svp))\n\t    client_flag |= CLIENT_MULTI_STATEMENTS;\n          else\n            client_flag &= ~CLIENT_MULTI_STATEMENTS;\n\t}\n#endif\n\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n\t/* took out  client_flag |= CLIENT_PROTOCOL_41; */\n\t/* because libmysql.c already sets this no matter what */\n\tif ((svp = hv_fetch(hv, \"mysql_server_prepare\", 20, FALSE))\n            && *svp)\n        {\n\t  if (SvTRUE(*svp))\n          {\n\t    client_flag |= CLIENT_PROTOCOL_41;\n            imp_dbh->use_server_side_prepare = TRUE;\n\t  }\n          else\n          {\n\t    client_flag &= ~CLIENT_PROTOCOL_41;\n            imp_dbh->use_server_side_prepare = FALSE;\n\t  }\n\t}\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                        \"imp_dbh->use_server_side_prepare: %d\\n\",\n                        imp_dbh->use_server_side_prepare);\n#endif\n\n        /* HELMUT */\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n        if ((svp = hv_fetch(hv, \"mysql_enable_utf8\", 17, FALSE)) && *svp) {\n          /* Do not touch imp_dbh->enable_utf8 as we are called earlier\n           * than it is set and mysql_options() must be before:\n           * mysql_real_connect()\n          */\n         mysql_options(sock, MYSQL_SET_CHARSET_NAME,\n                       (SvTRUE(*svp) ? \"utf8\" : \"latin1\"));\n         if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n           PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                         \"mysql_options: MYSQL_SET_CHARSET_NAME=%s\\n\",\n                         (SvTRUE(*svp) ? \"utf8\" : \"latin1\"));\n        }\n#endif\n\n#if defined(DBD_MYSQL_WITH_SSL) && !defined(DBD_MYSQL_EMBEDDED) && \\\n    (defined(CLIENT_SSL) || (MYSQL_VERSION_ID >= 40000))\n\tif ((svp = hv_fetch(hv, \"mysql_ssl\", 9, FALSE))  &&  *svp)\n        {\n\t  if (SvTRUE(*svp))\n          {\n\t    char *client_key = NULL;\n\t    char *client_cert = NULL;\n\t    char *ca_file = NULL;\n\t    char *ca_path = NULL;\n\t    char *cipher = NULL;\n\t    STRLEN lna;\n#if MYSQL_VERSION_ID >= SSL_VERIFY_VERSION\n            /*\n              New code to utilise MySQLs new feature that verifies that the\n              server's hostname that the client connects to matches that of\n              the certificate\n            */\n\t    my_bool ssl_verify_true = 0;\n\t    if ((svp = hv_fetch(hv, \"mysql_ssl_verify_server_cert\", 28, FALSE))  &&  *svp)\n\t      ssl_verify_true = SvTRUE(*svp);\n#endif\n\t    if ((svp = hv_fetch(hv, \"mysql_ssl_client_key\", 20, FALSE)) && *svp)\n\t      client_key = SvPV(*svp, lna);\n\n\t    if ((svp = hv_fetch(hv, \"mysql_ssl_client_cert\", 21, FALSE)) &&\n                *svp)\n\t      client_cert = SvPV(*svp, lna);\n\n\t    if ((svp = hv_fetch(hv, \"mysql_ssl_ca_file\", 17, FALSE)) &&\n\t\t *svp)\n\t      ca_file = SvPV(*svp, lna);\n\n\t    if ((svp = hv_fetch(hv, \"mysql_ssl_ca_path\", 17, FALSE)) &&\n                *svp)\n\t      ca_path = SvPV(*svp, lna);\n\n\t    if ((svp = hv_fetch(hv, \"mysql_ssl_cipher\", 16, FALSE)) &&\n\t\t*svp)\n\t      cipher = SvPV(*svp, lna);\n\n\t    mysql_ssl_set(sock, client_key, client_cert, ca_file,\n\t\t\t  ca_path, cipher);\n#if MYSQL_VERSION_ID >= SSL_VERIFY_VERSION\n\t    mysql_options(sock, MYSQL_OPT_SSL_VERIFY_SERVER_CERT, &ssl_verify_true);\n#endif\n\t    client_flag |= CLIENT_SSL;\n\t  }\n\t}\n#endif\n#if (MYSQL_VERSION_ID >= 32349)\n\t/*\n\t * MySQL 3.23.49 disables LOAD DATA LOCAL by default. Use\n\t * mysql_local_infile=1 in the DSN to enable it.\n\t */\n     if ((svp = hv_fetch( hv, \"mysql_local_infile\", 18, FALSE))  &&  *svp)\n     {\n\t  unsigned int flag = SvTRUE(*svp);\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n\t    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n        \"imp_dbh->mysql_dr_connect: Using\" \\\n        \" local infile %u.\\n\", flag);\n\t  mysql_options(sock, MYSQL_OPT_LOCAL_INFILE, (const char *) &flag);\n\t}\n#endif\n      }\n    }\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"imp_dbh->mysql_dr_connect: client_flags = %d\\n\",\n\t\t    client_flag);\n\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n    client_flag|= CLIENT_MULTI_RESULTS;\n#endif\n    result = mysql_real_connect(sock, host, user, password, dbname,\n\t\t\t\tportNr, mysql_socket, client_flag);\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"imp_dbh->mysql_dr_connect: <-\");\n\n    if (result)\n    {\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n      /* connection succeeded. */\n      /* imp_dbh == NULL when mysql_dr_connect() is called from mysql.xs\n         functions (_admin_internal(),_ListDBs()). */\n      if (!(result->client_flag & CLIENT_PROTOCOL_41) && imp_dbh)\n        imp_dbh->use_server_side_prepare = FALSE;\n#endif\n\n#if MYSQL_ASYNC\n      if(imp_dbh) {\n          imp_dbh->async_query_in_flight = NULL;\n      }\n#endif\n\n      /*\n        we turn off Mysql's auto reconnect and handle re-connecting ourselves\n        so that we can keep track of when this happens.\n      */\n      result->reconnect=0;\n    }\n    else {\n      /* \n         sock was allocated with mysql_init() \n         fixes: https://rt.cpan.org/Ticket/Display.html?id=86153\n\n      Safefree(sock);\n\n         rurban: No, we still need this handle later in mysql_dr_error().\n         RT #97625. It will be freed as imp_dbh->pmysql in dbd_db_destroy(),\n         which is called by the DESTROY handler.\n      */\n    }\n    return result;\n  }\n}\n\n/*\n  safe_hv_fetch\n*/\nstatic char *safe_hv_fetch(pTHX_ HV *hv, const char *name, int name_length)\n{\n  SV** svp;\n  STRLEN len;\n  char *res= NULL;\n\n  if ((svp= hv_fetch(hv, name, name_length, FALSE)))\n  {\n    res= SvPV(*svp, len);\n    if (!len)\n      res= NULL;\n  }\n  return res;\n}\n\n/*\n Frontend for mysql_dr_connect\n*/\nstatic int my_login(pTHX_ SV* dbh, imp_dbh_t *imp_dbh)\n{\n  SV* sv;\n  HV* hv;\n  char* dbname;\n  char* host;\n  char* port;\n  char* user;\n  char* password;\n  char* mysql_socket;\n  int   result;\n  int\tfresh = 0;\n  D_imp_xxh(dbh);\n\n  /* TODO- resolve this so that it is set only if DBI is 1.607 */\n#define TAKE_IMP_DATA_VERSION 1\n#if TAKE_IMP_DATA_VERSION\n  if (DBIc_has(imp_dbh, DBIcf_IMPSET))\n  { /* eg from take_imp_data() */\n    if (DBIc_has(imp_dbh, DBIcf_ACTIVE))\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"my_login skip connect\\n\");\n      /* tell our parent we've adopted an active child */\n      ++DBIc_ACTIVE_KIDS(DBIc_PARENT_COM(imp_dbh));\n      return TRUE;\n    }\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"my_login IMPSET but not ACTIVE so connect not skipped\\n\");\n  }\n#endif\n\n  sv = DBIc_IMP_DATA(imp_dbh);\n\n  if (!sv  ||  !SvROK(sv))\n    return FALSE;\n\n  hv = (HV*) SvRV(sv);\n  if (SvTYPE(hv) != SVt_PVHV)\n    return FALSE;\n\n  host=\t\tsafe_hv_fetch(aTHX_ hv, \"host\", 4);\n  port=\t\tsafe_hv_fetch(aTHX_ hv, \"port\", 4);\n  user=\t\tsafe_hv_fetch(aTHX_ hv, \"user\", 4);\n  password=\tsafe_hv_fetch(aTHX_ hv, \"password\", 8);\n  dbname=\tsafe_hv_fetch(aTHX_ hv, \"database\", 8);\n  mysql_socket=\tsafe_hv_fetch(aTHX_ hv, \"mysql_socket\", 12);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->my_login : dbname = %s, uid = %s, pwd = %s,\" \\\n\t\t  \"host = %s, port = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\",\n\t\t  host ? host : \"NULL\",\n\t\t  port ? port : \"NULL\");\n\n  if (!imp_dbh->pmysql) {\n     fresh = 1;\n     Newz(908, imp_dbh->pmysql, 1, MYSQL);\n  }\n  result = mysql_dr_connect(dbh, imp_dbh->pmysql, mysql_socket, host, port, user,\n\t\t\t  password, dbname, imp_dbh) ? TRUE : FALSE;\n  if (fresh && !result) {\n      /* Prevent leaks, but do not free in case of a reconnect. See #97625 */\n      do_error(dbh, mysql_errno(imp_dbh->pmysql),\n              mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n      Safefree(imp_dbh->pmysql);\n      imp_dbh->pmysql = NULL;\n  }\n  return result;\n}\n\n\n/**************************************************************************\n *\n *  Name:    dbd_db_login\n *\n *  Purpose: Called for connecting to a database and logging in.\n *\n *  Input:   dbh - database handle being initialized\n *           imp_dbh - drivers private database handle data\n *           dbname - the database we want to log into; may be like\n *               \"dbname:host\" or \"dbname:host:port\"\n *           user - user name to connect as\n *           password - passwort to connect with\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error has already\n *           been called in the latter case\n *\n **************************************************************************/\n\nint dbd_db_login(SV* dbh, imp_dbh_t* imp_dbh, char* dbname, char* user,\n\t\t char* password) {\n#ifdef dTHR\n  dTHR;\n#endif\n  dTHX; \n  D_imp_xxh(dbh);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->connect: dsn = %s, uid = %s, pwd = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\");\n\n  imp_dbh->stats.auto_reconnects_ok= 0;\n  imp_dbh->stats.auto_reconnects_failed= 0;\n  imp_dbh->bind_type_guessing= FALSE;\n  imp_dbh->bind_comment_placeholders= FALSE;\n  imp_dbh->has_transactions= TRUE;\n /* Safer we flip this to TRUE perl side if we detect a mod_perl env. */\n  imp_dbh->auto_reconnect = FALSE;\n\n  /* HELMUT */\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  imp_dbh->enable_utf8 = FALSE;  /* initialize mysql_enable_utf8 */\n#endif\n\n  if (!my_login(aTHX_ dbh, imp_dbh))\n  {\n    if(imp_dbh->pmysql)\n        do_error(dbh, mysql_errno(imp_dbh->pmysql),\n                mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n    return FALSE;\n  }\n\n    /*\n     *  Tell DBI, that dbh->disconnect should be called for this handle\n     */\n    DBIc_ACTIVE_on(imp_dbh);\n\n    /* Tell DBI, that dbh->destroy should be called for this handle */\n    DBIc_on(imp_dbh, DBIcf_IMPSET);\n\n    return TRUE;\n}\n\n\n/***************************************************************************\n *\n *  Name:    dbd_db_commit\n *           dbd_db_rollback\n *\n *  Purpose: You guess what they should do. \n *\n *  Input:   dbh - database handle being commited or rolled back\n *           imp_dbh - drivers private database handle data\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error has already\n *           been called in the latter case\n *\n **************************************************************************/\n\nint\ndbd_db_commit(SV* dbh, imp_dbh_t* imp_dbh)\n{\n  if (DBIc_has(imp_dbh, DBIcf_AutoCommit))\n    return FALSE;\n\n  ASYNC_CHECK_RETURN(dbh, FALSE);\n\n  if (imp_dbh->has_transactions)\n  {\n#if MYSQL_VERSION_ID < SERVER_PREPARE_VERSION\n    if (mysql_real_query(imp_dbh->pmysql, \"COMMIT\", 6))\n#else\n    if (mysql_commit(imp_dbh->pmysql))\n#endif\n    {\n      do_error(dbh, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql)\n               ,mysql_sqlstate(imp_dbh->pmysql));\n      return FALSE;\n    }\n  }\n  else\n    do_warn(dbh, JW_ERR_NOT_IMPLEMENTED,\n            \"Commit ineffective because transactions are not available\");\n  return TRUE;\n}\n\n/*\n dbd_db_rollback\n*/\nint\ndbd_db_rollback(SV* dbh, imp_dbh_t* imp_dbh) {\n  /* croak, if not in AutoCommit mode */\n  if (DBIc_has(imp_dbh, DBIcf_AutoCommit))\n    return FALSE;\n\n  ASYNC_CHECK_RETURN(dbh, FALSE);\n\n  if (imp_dbh->has_transactions)\n  {\n#if MYSQL_VERSION_ID < SERVER_PREPARE_VERSION\n    if (mysql_real_query(imp_dbh->pmysql, \"ROLLBACK\", 8))\n#else\n      if (mysql_rollback(imp_dbh->pmysql))\n#endif\n      {\n        do_error(dbh, mysql_errno(imp_dbh->pmysql),\n                 mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n        return FALSE;\n      }\n  }\n  else\n    do_error(dbh, JW_ERR_NOT_IMPLEMENTED,\n             \"Rollback ineffective because transactions are not available\" ,NULL);\n  return TRUE;\n}\n\n/*\n ***************************************************************************\n *\n *  Name:    dbd_db_disconnect\n *\n *  Purpose: Disconnect a database handle from its database\n *\n *  Input:   dbh - database handle being disconnected\n *           imp_dbh - drivers private database handle data\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error has already\n *           been called in the latter case\n *\n **************************************************************************/\n\nint dbd_db_disconnect(SV* dbh, imp_dbh_t* imp_dbh)\n{\n#ifdef dTHR\n  dTHR;\n#endif\n  dTHX;\n  D_imp_xxh(dbh);\n\n  /* We assume that disconnect will always work       */\n  /* since most errors imply already disconnected.    */\n  DBIc_ACTIVE_off(imp_dbh);\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"imp_dbh->pmysql: %lx\\n\",\n\t\t              (long) imp_dbh->pmysql);\n  mysql_close(imp_dbh->pmysql );\n\n  /* We don't free imp_dbh since a reference still exists    */\n  /* The DESTROY method is the only one to 'free' memory.    */\n  return TRUE;\n}\n\n\n/***************************************************************************\n *\n *  Name:    dbd_discon_all\n *\n *  Purpose: Disconnect all database handles at shutdown time\n *\n *  Input:   dbh - database handle being disconnected\n *           imp_dbh - drivers private database handle data\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error has already\n *           been called in the latter case\n *\n **************************************************************************/\n\nint dbd_discon_all (SV *drh, imp_drh_t *imp_drh) {\n#if defined(dTHR)\n  dTHR;\n#endif\n  dTHX;\n  D_imp_xxh(drh);\n\n#if defined(DBD_MYSQL_EMBEDDED)\n  if (imp_drh->embedded.state)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Stop embedded server\\n\");\n\n    mysql_server_end();\n    if (imp_drh->embedded.groups)\n    {\n      (void) SvREFCNT_dec(imp_drh->embedded.groups);\n      imp_drh->embedded.groups = NULL;\n    }\n\n    if (imp_drh->embedded.args)\n    {\n      (void) SvREFCNT_dec(imp_drh->embedded.args);\n      imp_drh->embedded.args = NULL;\n    }\n\n\n  }\n#else\n  mysql_server_end();\n#endif\n\n  /* The disconnect_all concept is flawed and needs more work */\n  if (!PL_dirty && !SvTRUE(perl_get_sv(\"DBI::PERL_ENDING\",0))) {\n    sv_setiv(DBIc_ERR(imp_drh), (IV)1);\n    sv_setpv(DBIc_ERRSTR(imp_drh),\n             (char*)\"disconnect_all not implemented\");\n    /* NO EFFECT DBIh_EVENT2(drh, ERROR_event,\n      DBIc_ERR(imp_drh), DBIc_ERRSTR(imp_drh)); */\n    return FALSE;\n  }\n  PL_perl_destruct_level = 0;\n  return FALSE;\n}\n\n\n/****************************************************************************\n *\n *  Name:    dbd_db_destroy\n *\n *  Purpose: Our part of the dbh destructor\n *\n *  Input:   dbh - database handle being destroyed\n *           imp_dbh - drivers private database handle data\n *\n *  Returns: Nothing\n *\n **************************************************************************/\n\nvoid dbd_db_destroy(SV* dbh, imp_dbh_t* imp_dbh) {\n\n    /*\n     *  Being on the safe side never hurts ...\n     */\n  if (DBIc_ACTIVE(imp_dbh))\n  {\n    if (imp_dbh->has_transactions)\n    {\n      if (!DBIc_has(imp_dbh, DBIcf_AutoCommit))\n#if MYSQL_VERSION_ID < SERVER_PREPARE_VERSION\n        if ( mysql_real_query(imp_dbh->pmysql, \"ROLLBACK\", 8))\n#else\n        if (mysql_rollback(imp_dbh->pmysql))\n#endif\n            do_error(dbh, TX_ERR_ROLLBACK,\"ROLLBACK failed\" ,NULL);\n    }\n    dbd_db_disconnect(dbh, imp_dbh);\n  }\n  Safefree(imp_dbh->pmysql);\n\n  /* Tell DBI, that dbh->destroy must no longer be called */\n  DBIc_off(imp_dbh, DBIcf_IMPSET);\n}\n\n/* \n ***************************************************************************\n *\n *  Name:    dbd_db_STORE_attrib\n *\n *  Purpose: Function for storing dbh attributes; we currently support\n *           just nothing. :-)\n *\n *  Input:   dbh - database handle being modified\n *           imp_dbh - drivers private database handle data\n *           keysv - the attribute name\n *           valuesv - the attribute value\n *\n *  Returns: TRUE for success, FALSE otherwise\n *\n **************************************************************************/\nint\ndbd_db_STORE_attrib(\n                    SV* dbh,\n                    imp_dbh_t* imp_dbh,\n                    SV* keysv,\n                    SV* valuesv\n                   )\n{\n  dTHX;\n  STRLEN kl;\n  char *key = SvPV(keysv, kl);\n  SV *cachesv = Nullsv;\n  int cacheit = FALSE;\n  bool bool_value = SvTRUE(valuesv);\n\n  if (kl==10 && strEQ(key, \"AutoCommit\"))\n  {\n    if (imp_dbh->has_transactions)\n    {\n      bool oldval = DBIc_has(imp_dbh,DBIcf_AutoCommit) ? 1 : 0;\n\n      if (bool_value == oldval)\n        return TRUE;\n\n      /* if setting AutoCommit on ... */\n      if (!imp_dbh->no_autocommit_cmd)\n      {\n        if (\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n            mysql_autocommit(imp_dbh->pmysql, bool_value)\n#else\n            mysql_real_query(imp_dbh->pmysql,\n                             bool_value ? \"SET AUTOCOMMIT=1\" : \"SET AUTOCOMMIT=0\",\n                             16)\n#endif\n           )\n        {\n          do_error(dbh, TX_ERR_AUTOCOMMIT,\n                   bool_value ?\n                   \"Turning on AutoCommit failed\" :\n                   \"Turning off AutoCommit failed\"\n                   ,NULL);\n          return TRUE;  /* TRUE means we handled it - important to avoid spurious errors */\n        }\n      }\n      DBIc_set(imp_dbh, DBIcf_AutoCommit, bool_value);\n    }\n    else\n    {\n      /*\n       *  We do support neither transactions nor \"AutoCommit\".\n       *  But we stub it. :-)\n      */\n      if (!bool_value)\n      {\n        do_error(dbh, JW_ERR_NOT_IMPLEMENTED,\n                 \"Transactions not supported by database\" ,NULL);\n        croak(\"Transactions not supported by database\");\n      }\n    }\n  }\n  else if (kl == 16 && strEQ(key,\"mysql_use_result\"))\n    imp_dbh->use_mysql_use_result = bool_value;\n  else if (kl == 20 && strEQ(key,\"mysql_auto_reconnect\"))\n    imp_dbh->auto_reconnect = bool_value;\n  else if (kl == 20 && strEQ(key, \"mysql_server_prepare\"))\n    imp_dbh->use_server_side_prepare=SvTRUE(valuesv);\n  else if (kl == 23 && strEQ(key,\"mysql_no_autocommit_cmd\"))\n    imp_dbh->no_autocommit_cmd= SvTRUE(valuesv);\n  else if (kl == 24 && strEQ(key,\"mysql_bind_type_guessing\"))\n    imp_dbh->bind_type_guessing = SvTRUE(valuesv);\n  else if (kl == 31 && strEQ(key,\"mysql_bind_comment_placeholders\"))\n    imp_dbh->bind_type_guessing = SvTRUE(valuesv);\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  else if (kl == 17 && strEQ(key, \"mysql_enable_utf8\"))\n    imp_dbh->enable_utf8 = bool_value;\n#endif\n  else\n    return FALSE;\t\t\t\t/* Unknown key */\n\n  if (cacheit) /* cache value for later DBI 'quick' fetch? */\n    hv_store((HV*)SvRV(dbh), key, kl, cachesv, 0);\n  return TRUE;\n}\n\n/***************************************************************************\n *\n *  Name:    dbd_db_FETCH_attrib\n *\n *  Purpose: Function for fetching dbh attributes\n *\n *  Input:   dbh - database handle being queried\n *           imp_dbh - drivers private database handle data\n *           keysv - the attribute name\n *\n *  Returns: An SV*, if sucessfull; NULL otherwise\n *\n *  Notes:   Do not forget to call sv_2mortal in the former case!\n *\n **************************************************************************/\nstatic SV*\nmy_ulonglong2str(pTHX_ my_ulonglong val)\n{\n  char buf[64];\n  char *ptr = buf + sizeof(buf) - 1;\n\n  if (val == 0)\n    return newSVpv(\"0\", 1);\n\n  *ptr = '\\0';\n  while (val > 0)\n  {\n    *(--ptr) = ('0' + (val % 10));\n    val = val / 10;\n  }\n  return newSVpv(ptr, (buf+ sizeof(buf) - 1) - ptr);\n}\n\nSV* dbd_db_FETCH_attrib(SV *dbh, imp_dbh_t *imp_dbh, SV *keysv)\n{\n  dTHX;\n  STRLEN kl;\n  char *key = SvPV(keysv, kl);\n  char* fine_key = NULL;\n  SV* result = NULL;\n  dbh= dbh;\n\n  switch (*key) {\n    case 'A':\n      if (strEQ(key, \"AutoCommit\"))\n      {\n        if (imp_dbh->has_transactions)\n          return sv_2mortal(boolSV(DBIc_has(imp_dbh,DBIcf_AutoCommit)));\n        /* Default */\n        return &PL_sv_yes;\n      }\n      break;\n  }\n  if (strncmp(key, \"mysql_\", 6) == 0) {\n    fine_key = key;\n    key = key+6;\n    kl = kl-6;\n  }\n\n  /* MONTY:  Check if kl should not be used or used everywhere */\n  switch(*key) {\n  case 'a':\n    if (kl == strlen(\"auto_reconnect\") && strEQ(key, \"auto_reconnect\"))\n      result= sv_2mortal(newSViv(imp_dbh->auto_reconnect));\n    break;\n  case 'b':\n    if (kl == strlen(\"bind_type_guessing\") &&\n        strEQ(key, \"bind_type_guessing\"))\n    {\n      result = sv_2mortal(newSViv(imp_dbh->bind_type_guessing));\n    }\n    else if (kl == strlen(\"bind_comment_placeholders\") &&\n        strEQ(key, \"bind_comment_placeholders\"))\n    {\n      result = sv_2mortal(newSViv(imp_dbh->bind_comment_placeholders));\n    }\n    break;\n  case 'c':\n    if (kl == 10 && strEQ(key, \"clientinfo\"))\n    {\n      const char* clientinfo = mysql_get_client_info();\n      result= clientinfo ?\n        sv_2mortal(newSVpv(clientinfo, strlen(clientinfo))) : &PL_sv_undef;\n    }\n    else if (kl == 13 && strEQ(key, \"clientversion\"))\n    {\n      result= sv_2mortal(my_ulonglong2str(aTHX_ mysql_get_client_version()));\n    }\n    break;\n  case 'e':\n    if (strEQ(key, \"errno\"))\n      result= sv_2mortal(newSViv((IV)mysql_errno(imp_dbh->pmysql)));\n    else if ( strEQ(key, \"error\") || strEQ(key, \"errmsg\"))\n    {\n    /* Note that errmsg is obsolete, as of 2.09! */\n      const char* msg = mysql_error(imp_dbh->pmysql);\n      result= sv_2mortal(newSVpv(msg, strlen(msg)));\n    }\n    /* HELMUT */\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n    else if (kl == strlen(\"enable_utf8\") && strEQ(key, \"enable_utf8\"))\n        result = sv_2mortal(newSViv(imp_dbh->enable_utf8));\n#endif\n    break;\n\n  case 'd':\n    if (strEQ(key, \"dbd_stats\"))\n    {\n      HV* hv = newHV();\n      hv_store(\n               hv,\n               \"auto_reconnects_ok\",\n               strlen(\"auto_reconnects_ok\"),\n               newSViv(imp_dbh->stats.auto_reconnects_ok),\n               0\n              );\n      hv_store(\n               hv,\n               \"auto_reconnects_failed\",\n               strlen(\"auto_reconnects_failed\"),\n               newSViv(imp_dbh->stats.auto_reconnects_failed),\n               0\n              );\n\n      result= sv_2mortal((newRV_noinc((SV*)hv)));\n    }\n\n  case 'h':\n    if (strEQ(key, \"hostinfo\"))\n    {\n      const char* hostinfo = mysql_get_host_info(imp_dbh->pmysql);\n      result= hostinfo ?\n        sv_2mortal(newSVpv(hostinfo, strlen(hostinfo))) : &PL_sv_undef;\n    }\n    break;\n\n  case 'i':\n    if (strEQ(key, \"info\"))\n    {\n      const char* info = mysql_info(imp_dbh->pmysql);\n      result= info ? sv_2mortal(newSVpv(info, strlen(info))) : &PL_sv_undef;\n    }\n    else if (kl == 8  &&  strEQ(key, \"insertid\"))\n      /* We cannot return an IV, because the insertid is a long. */\n      result= sv_2mortal(my_ulonglong2str(aTHX_ mysql_insert_id(imp_dbh->pmysql)));\n    break;\n  case 'n':\n    if (kl == strlen(\"no_autocommit_cmd\") &&\n        strEQ(key, \"no_autocommit_cmd\"))\n      result = sv_2mortal(newSViv(imp_dbh->no_autocommit_cmd));\n    break;\n\n  case 'p':\n    if (kl == 9  &&  strEQ(key, \"protoinfo\"))\n      result= sv_2mortal(newSViv(mysql_get_proto_info(imp_dbh->pmysql)));\n    break;\n\n  case 's':\n    if (kl == 10 && strEQ(key, \"serverinfo\")) {\n      const char* serverinfo = mysql_get_server_info(imp_dbh->pmysql);\n      result= serverinfo ?\n        sv_2mortal(newSVpv(serverinfo, strlen(serverinfo))) : &PL_sv_undef;\n    } \n    else if (kl == 13 && strEQ(key, \"serverversion\"))\n      result= sv_2mortal(my_ulonglong2str(aTHX_ mysql_get_server_version(imp_dbh->pmysql)));\n    else if (strEQ(key, \"sock\"))\n      result= sv_2mortal(newSViv((IV) imp_dbh->pmysql));\n    else if (strEQ(key, \"sockfd\"))\n      result= sv_2mortal(newSViv((IV) imp_dbh->pmysql->net.fd));\n    else if (strEQ(key, \"stat\"))\n    {\n      const char* stats = mysql_stat(imp_dbh->pmysql);\n      result= stats ?\n        sv_2mortal(newSVpv(stats, strlen(stats))) : &PL_sv_undef;\n    }\n    else if (strEQ(key, \"stats\"))\n    {\n      /* Obsolete, as of 2.09 */\n      const char* stats = mysql_stat(imp_dbh->pmysql);\n      result= stats ?\n        sv_2mortal(newSVpv(stats, strlen(stats))) : &PL_sv_undef;\n    }\n    else if (kl == 14 && strEQ(key,\"server_prepare\"))\n        result= sv_2mortal(newSViv((IV) imp_dbh->use_server_side_prepare));\n    break;\n\n  case 't':\n    if (kl == 9  &&  strEQ(key, \"thread_id\"))\n      result= sv_2mortal(newSViv(mysql_thread_id(imp_dbh->pmysql)));\n    break;\n\n  case 'w':\n    if (kl == 13 && strEQ(key, \"warning_count\"))\n      result= sv_2mortal(newSViv(mysql_warning_count(imp_dbh->pmysql)));\n    break;\n  case 'u':\n    if (strEQ(key, \"use_result\"))\n    {\n      result= sv_2mortal(newSViv((IV) imp_dbh->use_mysql_use_result));\n    }\n    break;\n  }\n\n  if (result== NULL)\n    return Nullsv;\n\n  return result;\n}\n\n\n/* \n **************************************************************************\n *\n *  Name:    dbd_st_prepare\n *\n *  Purpose: Called for preparing an SQL statement; our part of the\n *           statement handle constructor\n *\n *  Input:   sth - statement handle being initialized\n *           imp_sth - drivers private statement handle data\n *           statement - pointer to string with SQL statement\n *           attribs - statement attributes, currently not in use\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error will\n *           be called in the latter case\n *\n **************************************************************************/\nint\ndbd_st_prepare(\n  SV *sth,\n  imp_sth_t *imp_sth,\n  char *statement,\n  SV *attribs)\n{\n  int i;\n  SV **svp;\n  dTHX;\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  char *str_ptr;\n  int col_type, prepare_retval, limit_flag=0;\n  MYSQL_BIND *bind, *bind_end;\n  imp_sth_phb_t *fbind;\n#endif\n  D_imp_xxh(sth);\n  D_imp_dbh_from_sth;\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                 \"\\t-> dbd_st_prepare MYSQL_VERSION_ID %d, SQL statement: %s\\n\",\n                  MYSQL_VERSION_ID, statement);\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n /* Set default value of 'mysql_server_prepare' attribute for sth from dbh */\n  imp_sth->use_server_side_prepare= imp_dbh->use_server_side_prepare;\n  if (attribs)\n  {\n    svp= DBD_ATTRIB_GET_SVP(attribs, \"mysql_server_prepare\", 20);\n    imp_sth->use_server_side_prepare = (svp) ?\n      SvTRUE(*svp) : imp_dbh->use_server_side_prepare;\n\n    svp = DBD_ATTRIB_GET_SVP(attribs, \"async\", 5);\n\n    if(svp && SvTRUE(*svp)) {\n#if MYSQL_ASYNC\n        imp_sth->is_async = TRUE;\n        imp_sth->use_server_side_prepare = FALSE;\n#else\n        do_error(sth, 2000,\n                 \"Async support was not built into this version of DBD::mysql\", \"HY000\");\n        return 0;\n#endif\n    }\n  }\n\n  imp_sth->fetch_done= 0;\n#endif\n\n  imp_sth->done_desc= 0;\n  imp_sth->result= NULL;\n  imp_sth->currow= 0;\n\n  /* Set default value of 'mysql_use_result' attribute for sth from dbh */\n  svp= DBD_ATTRIB_GET_SVP(attribs, \"mysql_use_result\", 16);\n  imp_sth->use_mysql_use_result= svp ?\n    SvTRUE(*svp) : imp_dbh->use_mysql_use_result;\n\n  for (i= 0; i < AV_ATTRIB_LAST; i++)\n    imp_sth->av_attr[i]= Nullav;\n\n  /*\n     Clean-up previous result set(s) for sth to prevent\n     'Commands out of sync' error \n  */\n  mysql_st_free_result_sets(sth, imp_sth);\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tuse_server_side_prepare set, check LIMIT\\n\");\n    /*\n      This code is here because mysql < 5.1 didn't support placeholders\n      in prepared statements and also we have to disable some statements\n      for PS mode\n    */ \n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tneed to test for LIMIT\\n\");\n    for (str_ptr= statement; *str_ptr; str_ptr++)\n    {\n      /* \n        Processing of multi-result-set is not possible due to lack\n        of some calls in PS API. CALL() statement is disabled for PS\n        mode as it may cause multi-resut-set.\n      */\n\n      if ( (tolower(*(str_ptr + 0)) == 'c') &&\n           (tolower(*(str_ptr + 1)) == 'a') &&\n           (tolower(*(str_ptr + 2)) == 'l') &&\n           (tolower(*(str_ptr + 3)) == 'l') &&\n           (tolower(*(str_ptr + 4)) == ' '))\n      {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Disable PS mode for CALL()\\n\");\n        imp_sth->use_server_side_prepare= 0;\n      }\n\n#if MYSQL_VERSION_ID < LIMIT_PLACEHOLDER_VERSION\n      /*\n        If there is a 'limit' in the statement and placeholders are\n        NOT supported\n      */\n      if ( (tolower(*(str_ptr + 0)) == 'l') &&\n           (tolower(*(str_ptr + 1)) == 'i') &&\n           (tolower(*(str_ptr + 2)) == 'm') &&\n           (tolower(*(str_ptr + 3)) == 'i') &&\n           (tolower(*(str_ptr + 4)) == 't'))\n      {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"LIMIT set limit flag to 1\\n\");\n        limit_flag= 1;\n      }\n\n      if (limit_flag)\n      {\n        /* ... and place holders after the limit flag is set... */\n        if (*str_ptr == '?')\n        {\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tLIMIT and ? found, set to use_server_side_prepare=0\\n\");\n          /* ... then we do not want to try server side prepare (use emulation) */\n          imp_sth->use_server_side_prepare= 0;\n          break;\n        }\n      }\n#endif\n    }\n  }\n#endif\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tuse_server_side_prepare set\\n\");\n    /* do we really need this? If we do, we should return, not just continue */\n    if (imp_sth->stmt)\n      fprintf(stderr,\n              \"ERROR: Trying to prepare new stmt while we have \\\n              already not closed one \\n\");\n\n    imp_sth->stmt= mysql_stmt_init(imp_dbh->pmysql);\n\n    if (! imp_sth->stmt)\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                      \"\\t\\tERROR: Unable to return MYSQL_STMT structure \\\n                      from mysql_stmt_init(): ERROR NO: %d ERROR MSG:%s\\n\",\n                      mysql_errno(imp_dbh->pmysql),\n                      mysql_error(imp_dbh->pmysql));\n    }\n\n    prepare_retval= mysql_stmt_prepare(imp_sth->stmt,\n                                       statement,\n                                       strlen(statement));\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                      \"\\t\\tmysql_stmt_prepare returned %d\\n\",\n                      prepare_retval);\n\n    if (prepare_retval)\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                      \"\\t\\tmysql_stmt_prepare %d %s\\n\",\n                      mysql_stmt_errno(imp_sth->stmt),\n                      mysql_stmt_error(imp_sth->stmt));\n\n      /* For commands that are not supported by server side prepared statement\n         mechanism lets try to pass them through regular API */\n      if (mysql_stmt_errno(imp_sth->stmt) == ER_UNSUPPORTED_PS)\n      {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tSETTING imp_sth->use_server_side_prepare to 0\\n\");\n        imp_sth->use_server_side_prepare= 0;\n      }\n      else\n      {\n        do_error(sth, mysql_stmt_errno(imp_sth->stmt),\n                 mysql_stmt_error(imp_sth->stmt),\n                mysql_sqlstate(imp_dbh->pmysql));\n        mysql_stmt_close(imp_sth->stmt);\n        imp_sth->stmt= NULL;\n        return FALSE;\n      }\n    }\n    else\n    {\n      DBIc_NUM_PARAMS(imp_sth)= mysql_stmt_param_count(imp_sth->stmt);\n      /* mysql_stmt_param_count */\n\n      if (DBIc_NUM_PARAMS(imp_sth) > 0)\n      {\n        int has_statement_fields= imp_sth->stmt->fields != 0;\n        /* Allocate memory for bind variables */\n        imp_sth->bind=            alloc_bind(DBIc_NUM_PARAMS(imp_sth));\n        imp_sth->fbind=           alloc_fbind(DBIc_NUM_PARAMS(imp_sth));\n        imp_sth->has_been_bound=  0;\n\n        /* Initialize ph variables with  NULL values */\n        for (i= 0,\n             bind=      imp_sth->bind,\n             fbind=     imp_sth->fbind,\n             bind_end=  bind+DBIc_NUM_PARAMS(imp_sth);\n             bind < bind_end ;\n             bind++, fbind++, i++ )\n        {\n          /*\n            if this statement has a result set, field types will be\n            correctly identified. If there is no result set, such as\n            with an INSERT, fields will not be defined, and all buffer_type\n            will default to MYSQL_TYPE_VAR_STRING\n          */\n          col_type= (has_statement_fields ?\n                     imp_sth->stmt->fields[i].type : MYSQL_TYPE_STRING);\n\n          bind->buffer_type=  mysql_to_perl_type(col_type);\n\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tmysql_to_perl_type returned %d\\n\", col_type);\n\n          bind->buffer=       NULL;\n          bind->length=       &(fbind->length);\n          bind->is_null=      (char*) &(fbind->is_null);\n          fbind->is_null=     1;\n          fbind->length=      0;\n        }\n      }\n    }\n  }\n#endif\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  /* Count the number of parameters (driver, vs server-side) */\n  if (imp_sth->use_server_side_prepare == 0)\n    DBIc_NUM_PARAMS(imp_sth) = count_params((imp_xxh_t *)imp_dbh, aTHX_ statement,\n                                            imp_dbh->bind_comment_placeholders);\n#else\n  DBIc_NUM_PARAMS(imp_sth) = count_params((imp_xxh_t *)imp_dbh, aTHX_ statement,\n                                          imp_dbh->bind_comment_placeholders);\n#endif\n\n  /* Allocate memory for parameters */\n  imp_sth->params= alloc_param(DBIc_NUM_PARAMS(imp_sth));\n  DBIc_IMPSET_on(imp_sth);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_prepare\\n\");\n  return 1;\n}\n\n/***************************************************************************\n * Name: dbd_st_free_result_sets\n *\n * Purpose: Clean-up single or multiple result sets (if any)\n *\n * Inputs: sth - Statement handle\n *         imp_sth - driver's private statement handle\n *\n * Returns: 1 ok\n *          0 error\n *************************************************************************/\nint mysql_st_free_result_sets (SV * sth, imp_sth_t * imp_sth)\n{\n  dTHX;\n  D_imp_dbh_from_sth;\n  D_imp_xxh(sth);\n  int next_result_rc= -1;\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t>- dbd_st_free_result_sets\\n\");\n\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n  do\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets RC %d\\n\", next_result_rc);\n\n    if (next_result_rc == 0)\n    {\n      if (!(imp_sth->result = mysql_use_result(imp_dbh->pmysql)))\n      {\n        /* Check for possible error */\n        if (mysql_field_count(imp_dbh->pmysql))\n        {\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets ERROR: %s\\n\",\n                                  mysql_error(imp_dbh->pmysql));\n\n          do_error(sth, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\n                   mysql_sqlstate(imp_dbh->pmysql));\n          return 0;\n        }\n      }\n    }\n    if (imp_sth->result)\n    {\n      mysql_free_result(imp_sth->result);\n      imp_sth->result=NULL;\n    }\n  } while ((next_result_rc=mysql_next_result(imp_dbh->pmysql))==0);\n\n  if (next_result_rc > 0)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets: Error while processing multi-result set: %s\\n\",\n                    mysql_error(imp_dbh->pmysql));\n\n    do_error(sth, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\n             mysql_sqlstate(imp_dbh->pmysql));\n  }\n\n#else\n\n  if (imp_sth->result)\n  {\n    mysql_free_result(imp_sth->result);\n    imp_sth->result=NULL;\n  }\n#endif\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets\\n\");\n\n  return 1;\n}\n\n\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n/***************************************************************************\n * Name: dbd_st_more_results\n *\n * Purpose: Move onto the next result set (if any)\n *\n * Inputs: sth - Statement handle\n *         imp_sth - driver's private statement handle\n *\n * Returns: 1 if there are more results sets\n *          0 if there are not\n *         -1 for errors.\n *************************************************************************/\nint dbd_st_more_results(SV* sth, imp_sth_t* imp_sth)\n{\n  dTHX;\n  D_imp_dbh_from_sth;\n  D_imp_xxh(sth);\n\n  int use_mysql_use_result=imp_sth->use_mysql_use_result;\n  int next_result_return_code, i;\n  MYSQL* svsock= imp_dbh->pmysql;\n\n  if (!SvROK(sth) || SvTYPE(SvRV(sth)) != SVt_PVHV)\n    croak(\"Expected hash array\");\n\n  if (!mysql_more_results(svsock))\n  {\n    /* No more pending result set(s)*/\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t    \"\\n      <- dbs_st_more_results no more results\\n\");\n    return 0;\n  }\n\n  if (imp_sth->use_server_side_prepare)\n  {\n    do_warn(sth, JW_ERR_NOT_IMPLEMENTED,\n            \"Processing of multiple result set is not possible with server side prepare\");\n    return 0;\n  }\n\n  /*\n   *  Free cached array attributes\n   */\n  for (i= 0; i < AV_ATTRIB_LAST;  i++)\n  {\n    if (imp_sth->av_attr[i])\n      SvREFCNT_dec(imp_sth->av_attr[i]);\n\n    imp_sth->av_attr[i]= Nullav;\n  }\n\n  /* Release previous MySQL result*/\n  if (imp_sth->result)\n    mysql_free_result(imp_sth->result);\n\n  if (DBIc_ACTIVE(imp_sth))\n    DBIc_ACTIVE_off(imp_sth);\n\n  next_result_return_code= mysql_next_result(svsock);\n\n  imp_sth->warning_count = mysql_warning_count(imp_dbh->pmysql);\n\n  /*\n    mysql_next_result returns\n      0 if there are more results\n     -1 if there are no more results\n     >0 if there was an error\n   */\n  if (next_result_return_code > 0)\n  {\n    do_error(sth, mysql_errno(svsock), mysql_error(svsock),\n             mysql_sqlstate(svsock));\n\n    return 0;\n  }\n  else if(next_result_return_code == -1)                                                                                                                  \n  {                                                                                                                                                       \n    return 0;                                                                                                                                             \n  }  \n  else\n  {\n    /* Store the result from the Query */\n    imp_sth->result = use_mysql_use_result ?\n     mysql_use_result(svsock) : mysql_store_result(svsock);\n\n    if (mysql_errno(svsock))\n    {\n      do_error(sth, mysql_errno(svsock), mysql_error(svsock), \n               mysql_sqlstate(svsock));\n      return 0;\n    }\n\n    imp_sth->row_num= mysql_affected_rows(imp_dbh->pmysql);\n\n    if (imp_sth->result == NULL)\n    {\n      /* No \"real\" rowset*/\n      DBIc_NUM_FIELDS(imp_sth)= 0; /* for DBI <= 1.53 */\n      DBIS->set_attr_k(sth, sv_2mortal(newSVpvn(\"NUM_OF_FIELDS\",13)), 0,\n\t\t\t               sv_2mortal(newSViv(0)));\n      return 1;\n    }\n    else\n    {\n      /* We have a new rowset */\n      imp_sth->currow=0;\n\n\n      /* delete cached handle attributes */\n      /* XXX should be driven by a list to ease maintenance */\n      hv_delete((HV*)SvRV(sth), \"NAME\", 4, G_DISCARD);\n      hv_delete((HV*)SvRV(sth), \"NULLABLE\", 8, G_DISCARD);\n      hv_delete((HV*)SvRV(sth), \"NUM_OF_FIELDS\", 13, G_DISCARD);\n      hv_delete((HV*)SvRV(sth), \"PRECISION\", 9, G_DISCARD);\n      hv_delete((HV*)SvRV(sth), \"SCALE\", 5, G_DISCARD);\n      hv_delete((HV*)SvRV(sth), \"TYPE\", 4, G_DISCARD);\n      hv_delete((HV*)SvRV(sth), \"mysql_insertid\", 14, G_DISCARD);\n      hv_delete((HV*)SvRV(sth), \"mysql_is_auto_increment\", 23, G_DISCARD);\n      hv_delete((HV*)SvRV(sth), \"mysql_is_blob\", 13, G_DISCARD);\n      hv_delete((HV*)SvRV(sth), \"mysql_is_key\", 12, G_DISCARD);\n      hv_delete((HV*)SvRV(sth), \"mysql_is_num\", 12, G_DISCARD);\n      hv_delete((HV*)SvRV(sth), \"mysql_is_pri_key\", 16, G_DISCARD);\n      hv_delete((HV*)SvRV(sth), \"mysql_length\", 12, G_DISCARD);\n      hv_delete((HV*)SvRV(sth), \"mysql_max_length\", 16, G_DISCARD);\n      hv_delete((HV*)SvRV(sth), \"mysql_table\", 11, G_DISCARD);\n      hv_delete((HV*)SvRV(sth), \"mysql_type\", 10, G_DISCARD);\n      hv_delete((HV*)SvRV(sth), \"mysql_type_name\", 15, G_DISCARD);\n      hv_delete((HV*)SvRV(sth), \"mysql_warning_count\", 20, G_DISCARD);\n\n      /* Adjust NUM_OF_FIELDS - which also adjusts the row buffer size */\n      DBIc_NUM_FIELDS(imp_sth)= 0; /* for DBI <= 1.53 */\n      DBIc_DBISTATE(imp_sth)->set_attr_k(sth, sv_2mortal(newSVpvn(\"NUM_OF_FIELDS\",13)), 0,\n          sv_2mortal(newSViv(mysql_num_fields(imp_sth->result)))\n      );\n\n      DBIc_ACTIVE_on(imp_sth);\n\n      imp_sth->done_desc = 0;\n    }\n    imp_dbh->pmysql->net.last_errno= 0;\n    return 1;\n  }\n}\n#endif\n/**************************************************************************\n *\n *  Name:    mysql_st_internal_execute\n *\n *  Purpose: Internal version for executing a statement, called both from\n *           within the \"do\" and the \"execute\" method.\n *\n *  Inputs:  h - object handle, for storing error messages\n *           statement - query being executed\n *           attribs - statement attributes, currently ignored\n *           num_params - number of parameters being bound\n *           params - parameter array\n *           result - where to store results, if any\n *           svsock - socket connected to the database\n *\n **************************************************************************/\n\n\nmy_ulonglong mysql_st_internal_execute(\n                                       SV *h, /* could be sth or dbh */\n                                       SV *statement,\n                                       SV *attribs,\n                                       int num_params,\n                                       imp_sth_ph_t *params,\n                                       MYSQL_RES **result,\n                                       MYSQL *svsock,\n                                       int use_mysql_use_result\n                                      )\n{\n  dTHX;\n  bool bind_type_guessing= FALSE;\n  bool bind_comment_placeholders= TRUE;\n  STRLEN slen;\n  char *sbuf = SvPV(statement, slen);\n  char *table;\n  char *salloc;\n  int htype;\n  int errno;\n#if MYSQL_ASYNC\n  bool async = FALSE;\n#endif\n  my_ulonglong rows= 0;\n  /* thank you DBI.c for this info! */\n  D_imp_xxh(h);\n  attribs= attribs;\n\n  htype= DBIc_TYPE(imp_xxh);\n  /*\n    It is important to import imp_dbh properly according to the htype\n    that it is! Also, one might ask why bind_type_guessing is assigned\n    in each block. Well, it's because D_imp_ macros called in these\n    blocks make it so imp_dbh is not \"visible\" or defined outside of the\n    if/else (when compiled, it fails for imp_dbh not being defined).\n  */\n  /* h is a dbh */\n  if (htype == DBIt_DB)\n  {\n    D_imp_dbh(h);\n    /* if imp_dbh is not available, it causes segfault (proper) on OpenBSD */\n    if (imp_dbh && imp_dbh->bind_type_guessing)\n    {\n      bind_type_guessing= imp_dbh->bind_type_guessing;\n      bind_comment_placeholders= bind_comment_placeholders;\n    }\n#if MYSQL_ASYNC\n    async = (bool) (imp_dbh->async_query_in_flight != NULL);\n#endif\n  }\n  /* h is a sth */\n  else\n  {\n    D_imp_sth(h);\n    D_imp_dbh_from_sth;\n    /* if imp_dbh is not available, it causes segfault (proper) on OpenBSD */\n    if (imp_dbh)\n    {\n      bind_type_guessing= imp_dbh->bind_type_guessing;\n      bind_comment_placeholders= imp_dbh->bind_comment_placeholders;\n    }\n#if MYSQL_ASYNC\n    async = imp_sth->is_async;\n    if(async) {\n        imp_dbh->async_query_in_flight = imp_sth;\n    } else {\n        imp_dbh->async_query_in_flight = NULL;\n    }\n#endif\n  }\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"mysql_st_internal_execute MYSQL_VERSION_ID %d\\n\",\n                  MYSQL_VERSION_ID );\n\n  salloc= parse_params(imp_xxh,\n                              aTHX_ svsock,\n                              sbuf,\n                              &slen,\n                              params,\n                              num_params,\n                              bind_type_guessing,\n                              bind_comment_placeholders);\n\n  if (salloc)\n  {\n    sbuf= salloc;\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Binding parameters: %s\\n\", sbuf);\n  }\n\n  if (slen >= 11 && (!strncmp(sbuf, \"listfields \", 11) ||\n                     !strncmp(sbuf, \"LISTFIELDS \", 11)))\n  {\n    /* remove pre-space */\n    slen-= 10;\n    sbuf+= 10;\n    while (slen && isspace(*sbuf)) { --slen;  ++sbuf; }\n\n    if (!slen)\n    {\n      do_error(h, JW_ERR_QUERY, \"Missing table name\" ,NULL);\n      return -2;\n    }\n    if (!(table= malloc(slen+1)))\n    {\n      do_error(h, JW_ERR_MEM, \"Out of memory\" ,NULL);\n      return -2;\n    }\n\n    strncpy(table, sbuf, slen);\n    sbuf= table;\n\n    while (slen && !isspace(*sbuf))\n    {\n      --slen;\n      ++sbuf;\n    }\n    *sbuf++= '\\0';\n\n    *result= mysql_list_fields(svsock, table, NULL);\n\n    free(table);\n\n    if (!(*result))\n    {\n      do_error(h, mysql_errno(svsock), mysql_error(svsock)\n               ,mysql_sqlstate(svsock));\n      return -2;\n    }\n\n    return 0;\n  }\n\n#if MYSQL_ASYNC\n  if(async) {\n    if((mysql_send_query(svsock, sbuf, slen)) &&\n       (!mysql_db_reconnect(h) ||\n        (mysql_send_query(svsock, sbuf, slen))))\n    {\n        rows = -2;\n    } else {\n        rows = 0;\n    }\n  } else {\n#endif\n      if ((mysql_real_query(svsock, sbuf, slen))  &&\n          (!mysql_db_reconnect(h)  ||\n           (mysql_real_query(svsock, sbuf, slen))))\n      {\n        rows = -2;\n      } else {\n          /** Store the result from the Query */\n          *result= use_mysql_use_result ?\n            mysql_use_result(svsock) : mysql_store_result(svsock);\n\n          if (mysql_errno(svsock))\n            do_error(h, mysql_errno(svsock), mysql_error(svsock)\n                     ,mysql_sqlstate(svsock));\n\n          if (!*result)\n            rows= mysql_affected_rows(svsock);\n          else\n            rows= mysql_num_rows(*result);\n      }\n#if MYSQL_ASYNC\n  }\n#endif\n\n  if (salloc)\n    Safefree(salloc);\n\n  if(rows == -2) {\n    do_error(h, mysql_errno(svsock), mysql_error(svsock), \n             mysql_sqlstate(svsock));\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"IGNORING ERROR errno %d\\n\", errno);\n    rows = -2;\n  }\n  return(rows);\n}\n\n /**************************************************************************\n *\n *  Name:    mysql_st_internal_execute41\n *\n *  Purpose: Internal version for executing a prepared statement, called both\n *           from within the \"do\" and the \"execute\" method.\n *           MYSQL 4.1 API\n *\n *\n *  Inputs:  h - object handle, for storing error messages\n *           statement - query being executed\n *           attribs - statement attributes, currently ignored\n *           num_params - number of parameters being bound\n *           params - parameter array\n *           result - where to store results, if any\n *           svsock - socket connected to the database\n *\n **************************************************************************/\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n\nmy_ulonglong mysql_st_internal_execute41(\n                                         SV *sth,\n                                         int num_params,\n                                         MYSQL_RES **result,\n                                         MYSQL_STMT *stmt,\n                                         MYSQL_BIND *bind,\n                                         int *has_been_bound\n                                        )\n{\n  int i;\n  enum enum_field_types enum_type;\n  dTHX;\n  int execute_retval;\n  my_ulonglong rows=0;\n  D_imp_xxh(sth);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t-> mysql_st_internal_execute41\\n\");\n\n  /* free result if exists */\n  if (*result)\n  {\n    mysql_free_result(*result);\n    *result= 0;\n  }\n\n  /*\n    If were performed any changes with ph variables\n    we have to rebind them\n  */\n\n  if (num_params > 0 && !(*has_been_bound))\n  {\n    if (mysql_stmt_bind_param(stmt,bind))\n      goto error;\n\n    *has_been_bound= 1;\n  }\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t\\tmysql_st_internal_execute41 calling mysql_execute with %d num_params\\n\",\n                  num_params);\n\n  execute_retval= mysql_stmt_execute(stmt);\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t\\tmysql_stmt_execute returned %d\\n\",\n                  execute_retval);\n  if (execute_retval)\n    goto error;\n\n  /*\n   This statement does not return a result set (INSERT, UPDATE...)\n  */\n  if (!(*result= mysql_stmt_result_metadata(stmt)))\n  {\n    if (mysql_stmt_errno(stmt))\n      goto error;\n\n    rows= mysql_stmt_affected_rows(stmt);\n  }\n  /*\n    This statement returns a result set (SELECT...)\n  */\n  else\n  {\n    for (i = mysql_stmt_field_count(stmt) - 1; i >=0; --i) {\n        enum_type = mysql_to_perl_type(stmt->fields[i].type);\n        if (enum_type != MYSQL_TYPE_DOUBLE && enum_type != MYSQL_TYPE_LONG)\n        {\n            /* mysql_stmt_store_result to update MYSQL_FIELD->max_length */\n            my_bool on = 1;\n            mysql_stmt_attr_set(stmt, STMT_ATTR_UPDATE_MAX_LENGTH, &on);\n            break;\n        }\n    }\n    /* Get the total rows affected and return */\n    if (mysql_stmt_store_result(stmt))\n      goto error;\n    else\n      rows= mysql_stmt_num_rows(stmt);\n  }\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t<- mysql_internal_execute_41 returning %d rows\\n\",\n                  (int) rows);\n  return(rows);\n\nerror:\n  if (*result)\n  {\n    mysql_free_result(*result);\n    *result= 0;\n  }\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"     errno %d err message %s\\n\",\n                  mysql_stmt_errno(stmt),\n                  mysql_stmt_error(stmt));\n  do_error(sth, mysql_stmt_errno(stmt), mysql_stmt_error(stmt),\n           mysql_stmt_sqlstate(stmt));\n  mysql_stmt_reset(stmt);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t<- mysql_st_internal_execute41\\n\");\n  return -2;\n\n}\n#endif\n\n\n/***************************************************************************\n *\n *  Name:    dbd_st_execute\n *\n *  Purpose: Called for preparing an SQL statement; our part of the\n *           statement handle constructor\n *\n *  Input:   sth - statement handle being initialized\n *           imp_sth - drivers private statement handle data\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error will\n *           be called in the latter case\n *\n **************************************************************************/\n\nint dbd_st_execute(SV* sth, imp_sth_t* imp_sth)\n{\n  dTHX;\n  char actual_row_num[64];\n  int i;\n  SV **statement;\n  D_imp_dbh_from_sth;\n  D_imp_xxh(sth);\n#if defined (dTHR)\n  dTHR;\n#endif\n\n  ASYNC_CHECK_RETURN(sth, -2);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n      \" -> dbd_st_execute for %08lx\\n\", (u_long) sth);\n\n  if (!SvROK(sth)  ||  SvTYPE(SvRV(sth)) != SVt_PVHV)\n    croak(\"Expected hash array\");\n\n  /* Free cached array attributes */\n  for (i= 0;  i < AV_ATTRIB_LAST;  i++)\n  {\n    if (imp_sth->av_attr[i])\n      SvREFCNT_dec(imp_sth->av_attr[i]);\n\n    imp_sth->av_attr[i]= Nullav;\n  }\n\n  statement= hv_fetch((HV*) SvRV(sth), \"Statement\", 9, FALSE);\n\n  /* \n     Clean-up previous result set(s) for sth to prevent\n     'Commands out of sync' error \n  */\n  mysql_st_free_result_sets (sth, imp_sth);\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n\n  if (imp_sth->use_server_side_prepare && ! imp_sth->use_mysql_use_result)\n  {\n    imp_sth->row_num= mysql_st_internal_execute41(\n                                                  sth,\n                                                  DBIc_NUM_PARAMS(imp_sth),\n                                                  &imp_sth->result,\n                                                  imp_sth->stmt,\n                                                  imp_sth->bind,\n                                                  &imp_sth->has_been_bound\n                                                 );\n  }\n  else {\n#endif\n    imp_sth->row_num= mysql_st_internal_execute(\n                                                sth,\n                                                *statement,\n                                                NULL,\n                                                DBIc_NUM_PARAMS(imp_sth),\n                                                imp_sth->params,\n                                                &imp_sth->result,\n                                                imp_dbh->pmysql,\n                                                imp_sth->use_mysql_use_result\n                                               );\n#if MYSQL_ASYNC\n    if(imp_dbh->async_query_in_flight) {\n        DBIc_ACTIVE_on(imp_sth);\n        return 0;\n    }\n#endif\n  }\n\n  if (imp_sth->row_num+1 != (my_ulonglong)-1)\n  {\n    if (!imp_sth->result)\n    {\n      imp_sth->insertid= mysql_insert_id(imp_dbh->pmysql);\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n      if (mysql_more_results(imp_dbh->pmysql))\n        DBIc_ACTIVE_on(imp_sth);\n#endif\n    }\n    else\n    {\n      /** Store the result in the current statement handle */\n      DBIc_NUM_FIELDS(imp_sth)= mysql_num_fields(imp_sth->result);\n      DBIc_ACTIVE_on(imp_sth);\n      if (!imp_sth->use_server_side_prepare)\n        imp_sth->done_desc= 0;\n      imp_sth->fetch_done= 0;\n    }\n  }\n\n  imp_sth->warning_count = mysql_warning_count(imp_dbh->pmysql);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n  {\n    /* \n      PerlIO_printf doesn't always handle imp_sth->row_num %llu \n      consistantly!!\n    */\n    sprintf(actual_row_num, \"%llu\", imp_sth->row_num);\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \" <- dbd_st_execute returning imp_sth->row_num %s\\n\",\n                  actual_row_num);\n  }\n\n  return (int)imp_sth->row_num;\n}\n\n /**************************************************************************\n *\n *  Name:    dbd_describe\n *\n *  Purpose: Called from within the fetch method to describe the result\n *\n *  Input:   sth - statement handle being initialized\n *           imp_sth - our part of the statement handle, there's no\n *               need for supplying both; Tim just doesn't remove it\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error will\n *           be called in the latter case\n *\n **************************************************************************/\n\nint dbd_describe(SV* sth, imp_sth_t* imp_sth)\n{\n  dTHX;\n  D_imp_xxh(sth);\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t--> dbd_describe\\n\");\n\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n\n  if (imp_sth->use_server_side_prepare)\n  {\n    int i;\n    int col_type;\n    int num_fields= DBIc_NUM_FIELDS(imp_sth);\n    imp_sth_fbh_t *fbh;\n    MYSQL_BIND *buffer;\n    MYSQL_FIELD *fields;\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_describe() num_fields %d\\n\",\n                    num_fields);\n\n    if (imp_sth->done_desc)\n      return TRUE;\n\n    if (!num_fields || !imp_sth->result)\n    {\n      /* no metadata */\n      do_error(sth, JW_ERR_SEQUENCE,\n               \"no metadata information while trying describe result set\",\n               NULL);\n      return 0;\n    }\n\n    /* allocate fields buffers  */\n    if (  !(imp_sth->fbh= alloc_fbuffer(num_fields))\n          || !(imp_sth->buffer= alloc_bind(num_fields)) )\n    {\n      /* Out of memory */\n      do_error(sth, JW_ERR_SEQUENCE,\n               \"Out of memory in dbd_sescribe()\",NULL);\n      return 0;\n    }\n\n    fields= mysql_fetch_fields(imp_sth->result);\n\n    for (\n         fbh= imp_sth->fbh, buffer= (MYSQL_BIND*)imp_sth->buffer, i= 0;\n         i < num_fields;\n         i++, fbh++, buffer++\n        )\n    {\n      /* get the column type */\n      col_type = fields ? fields[i].type : MYSQL_TYPE_STRING;\n\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      {\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\ti %d col_type %d fbh->length %d\\n\",\n                      i, col_type, (int) fbh->length);\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                      \"\\t\\tfields[i].length %lu fields[i].max_length %lu fields[i].type %d fields[i].charsetnr %d\\n\",\n                      (long unsigned int) fields[i].length, (long unsigned int) fields[i].max_length, fields[i].type,\n                      fields[i].charsetnr);\n      }\n      fbh->charsetnr = fields[i].charsetnr;\n#if MYSQL_VERSION_ID < FIELD_CHARSETNR_VERSION \n      fbh->flags     = fields[i].flags;\n#endif\n\n      buffer->buffer_type= mysql_to_perl_type(col_type);\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tmysql_to_perl_type returned %d\\n\",\n                      col_type);\n      buffer->length= &(fbh->length);\n      buffer->is_null= (char*) &(fbh->is_null);\n\n      switch (buffer->buffer_type) {\n      case MYSQL_TYPE_DOUBLE:\n        buffer->buffer_length= sizeof(fbh->ddata);\n        buffer->buffer= (char*) &fbh->ddata;\n        break;\n\n      case MYSQL_TYPE_LONG:\n        buffer->buffer_length= sizeof(fbh->ldata);\n        buffer->buffer= (char*) &fbh->ldata;\n        buffer->is_unsigned= (fields[i].flags & UNSIGNED_FLAG) ? 1 : 0;\n        break;\n\n      default:\n        buffer->buffer_length= fields[i].max_length ? fields[i].max_length : 1;\n        Newz(908, fbh->data, buffer->buffer_length, char);\n        buffer->buffer= (char *) fbh->data;\n      }\n    }\n\n    if (mysql_stmt_bind_result(imp_sth->stmt, imp_sth->buffer))\n    {\n      do_error(sth, mysql_stmt_errno(imp_sth->stmt),\n               mysql_stmt_error(imp_sth->stmt),\n               mysql_stmt_sqlstate(imp_sth->stmt));\n      return 0;\n    }\n  }\n#endif\n\n  imp_sth->done_desc= 1;\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_describe\\n\");\n  return TRUE;\n}\n\n/**************************************************************************\n *\n *  Name:    dbd_st_fetch\n *\n *  Purpose: Called for fetching a result row\n *\n *  Input:   sth - statement handle being initialized\n *           imp_sth - drivers private statement handle data\n *\n *  Returns: array of columns; the array is allocated by DBI via\n *           DBIc_DBISTATE(imp_sth)->get_fbav(imp_sth), even the values\n *           of the array are prepared, we just need to modify them\n *           appropriately\n *\n **************************************************************************/\n\nAV*\ndbd_st_fetch(SV *sth, imp_sth_t* imp_sth)\n{\n  dTHX;\n  int num_fields, ChopBlanks, i, rc;\n  unsigned long *lengths;\n  AV *av;\n  int av_length, av_readonly;\n  MYSQL_ROW cols;\n  D_imp_dbh_from_sth;\n  MYSQL* svsock= imp_dbh->pmysql;\n  imp_sth_fbh_t *fbh;\n  D_imp_xxh(sth);\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  MYSQL_BIND *buffer;\n#endif\n  MYSQL_FIELD *fields;\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t-> dbd_st_fetch\\n\");\n\n#if MYSQL_ASYNC\n  if(imp_dbh->async_query_in_flight) {\n      if(mysql_db_async_result(sth, &imp_sth->result) <= 0) {\n        return Nullav;\n      }\n  }\n#endif\n\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (!DBIc_ACTIVE(imp_sth) )\n    {\n      do_error(sth, JW_ERR_SEQUENCE, \"no statement executing\\n\",NULL);\n      return Nullav;\n    }\n\n    if (imp_sth->fetch_done)\n    {\n      do_error(sth, JW_ERR_SEQUENCE, \"fetch() but fetch already done\",NULL);\n      return Nullav;\n    }\n\n    if (!imp_sth->done_desc)\n    {\n      if (!dbd_describe(sth, imp_sth))\n      {\n        do_error(sth, JW_ERR_SEQUENCE, \"Error while describe result set.\",\n                 NULL);\n        return Nullav;\n      }\n    }\n  }\n#endif\n\n  ChopBlanks = DBIc_is(imp_sth, DBIcf_ChopBlanks);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t\\tdbd_st_fetch for %08lx, chopblanks %d\\n\",\n                  (u_long) sth, ChopBlanks);\n\n  if (!imp_sth->result)\n  {\n    do_error(sth, JW_ERR_SEQUENCE, \"fetch() without execute()\" ,NULL);\n    return Nullav;\n  }\n\n  /* fix from 2.9008 */\n  imp_dbh->pmysql->net.last_errno = 0;\n\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch calling mysql_fetch\\n\");\n\n    if ((rc= mysql_stmt_fetch(imp_sth->stmt)))\n    {\n      if (rc == 1)\n        do_error(sth, mysql_stmt_errno(imp_sth->stmt),\n                 mysql_stmt_error(imp_sth->stmt),\n                mysql_stmt_sqlstate(imp_sth->stmt));\n\n#if MYSQL_VERSION_ID >= MYSQL_VERSION_5_0 \n      if (rc == MYSQL_DATA_TRUNCATED)\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch data truncated\\n\");\n#endif\n\n      if (rc == MYSQL_NO_DATA)\n      {\n        /* Update row_num to affected_rows value */\n        imp_sth->row_num= mysql_stmt_affected_rows(imp_sth->stmt);\n        imp_sth->fetch_done=1;\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch no data\\n\");\n      }\n\n      dbd_st_finish(sth, imp_sth);\n\n      return Nullav;\n    }\n\n    imp_sth->currow++;\n\n    av= DBIc_DBISTATE(imp_sth)->get_fbav(imp_sth);\n    num_fields=mysql_stmt_field_count(imp_sth->stmt);\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tdbd_st_fetch called mysql_fetch, rc %d num_fields %d\\n\",\n                    rc, num_fields);\n\n    for (\n         buffer= imp_sth->buffer,\n         fbh= imp_sth->fbh,\n         i= 0;\n         i < num_fields;\n         i++,\n         fbh++,\n         buffer++\n        )\n    {\n      SV *sv= AvARRAY(av)[i]; /* Note: we (re)use the SV in the AV\t*/\n      STRLEN len;\n\n      /* This is wrong, null is not being set correctly\n       * This is not the way to determine length (this would break blobs!)\n       */\n      if (fbh->is_null)\n        (void) SvOK_off(sv);  /*  Field is NULL, return undef  */\n      else\n      {\n        /* In case of BLOB/TEXT fields we allocate only 8192 bytes\n           in dbd_describe() for data. Here we know real size of field\n           so we should increase buffer size and refetch column value\n        */\n        if (fbh->length > buffer->buffer_length)\n        {\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\tRefetch BLOB/TEXT column: %d\\n\", i);\n\n          Renew(fbh->data, fbh->length, char);\n          buffer->buffer_length= fbh->length;\n          buffer->buffer= (char *) fbh->data;\n\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\tbuffer->buffer: %s\\n\", (char *) buffer->buffer);\n\n          /*TODO: Use offset instead of 0 to fetch only remain part of data*/\n          if (mysql_stmt_fetch_column(imp_sth->stmt, buffer , i, 0))\n            do_error(sth, mysql_stmt_errno(imp_sth->stmt),\n                     mysql_stmt_error(imp_sth->stmt),\n                     mysql_stmt_sqlstate(imp_sth->stmt));\n        }\n\n        /* This does look a lot like Georg's PHP driver doesn't it?  --Brian */\n        /* Credit due to Georg - mysqli_api.c  ;) --PMG */\n        switch (buffer->buffer_type) {\n        case MYSQL_TYPE_DOUBLE:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tst_fetch double data %f\\n\", fbh->ddata);\n          sv_setnv(sv, fbh->ddata);\n          break;\n\n        case MYSQL_TYPE_LONG:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tst_fetch int data %d, unsigned? %d\\n\",\n                          (int) fbh->ldata, buffer->is_unsigned);\n          if (buffer->is_unsigned)\n            sv_setuv(sv, fbh->ldata);\n          else\n            sv_setiv(sv, fbh->ldata);\n\n          break;\n\n        default:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tERROR IN st_fetch_string\");\n          len= fbh->length;\n\t  /* ChopBlanks server-side prepared statement */\n          if (ChopBlanks)\n          {\n            /* \n              see bottom of:\n              http://www.mysql.org/doc/refman/5.0/en/c-api-datatypes.html\n            */\n            if (fbh->charsetnr != 63)\n              while (len && fbh->data[len-1] == ' ') { --len; }\n          }\n\t  /* END OF ChopBlanks */\n\n          sv_setpvn(sv, fbh->data, len);\n\n\t/* UTF8 */\n        /*HELMUT*/\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n\n#if MYSQL_VERSION_ID >= FIELD_CHARSETNR_VERSION \n  /* see bottom of: http://www.mysql.org/doc/refman/5.0/en/c-api-datatypes.html */\n        if (imp_dbh->enable_utf8 && fbh->charsetnr != 63)\n#else\n\tif (imp_dbh->enable_utf8 && !(fbh->flags & BINARY_FLAG))\n#endif\n\t  sv_utf8_decode(sv);\n#endif\n\t/* END OF UTF8 */\n          break;\n\n        }\n\n      }\n    }\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, %d cols\\n\", num_fields);\n\n    return av;\n  }\n  else\n  {\n#endif\n\n    imp_sth->currow++;\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    {\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch result set details\\n\");\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\timp_sth->result=%08lx\\n\",(long unsigned int) imp_sth->result);\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_num_fields=%llu\\n\",\n                    (long long unsigned int) mysql_num_fields(imp_sth->result));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_num_rows=%llu\\n\",\n                    mysql_num_rows(imp_sth->result));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_affected_rows=%llu\\n\",\n                    mysql_affected_rows(imp_dbh->pmysql));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch for %08lx, currow= %d\\n\",\n                    (u_long) sth,imp_sth->currow);\n    }\n\n    if (!(cols= mysql_fetch_row(imp_sth->result)))\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      {\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch, no more rows to fetch\");\n      }\n      if (mysql_errno(imp_dbh->pmysql))\n        do_error(sth, mysql_errno(imp_dbh->pmysql),\n                 mysql_error(imp_dbh->pmysql),\n                 mysql_sqlstate(imp_dbh->pmysql));\n\n\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n      if (!mysql_more_results(svsock))\n#endif\n        dbd_st_finish(sth, imp_sth);\n      return Nullav;\n    }\n\n    num_fields= mysql_num_fields(imp_sth->result);\n    fields= mysql_fetch_fields(imp_sth->result);\n    lengths= mysql_fetch_lengths(imp_sth->result);\n\n    if ((av= DBIc_FIELDS_AV(imp_sth)) != Nullav)\n    {\n      av_length= av_len(av)+1;\n\n      if (av_length != num_fields)              /* Resize array if necessary */\n      {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, size of results array(%d) != num_fields(%d)\\n\",\n                                   av_length, num_fields);\n\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, result fields(%d)\\n\",\n                                   DBIc_NUM_FIELDS(imp_sth));\n\n        av_readonly = SvREADONLY(av);\n\n        if (av_readonly)\n          SvREADONLY_off( av );              /* DBI sets this readonly */\n\n        while (av_length < num_fields)\n        {\n          av_store(av, av_length++, newSV(0));\n        }\n\n        while (av_length > num_fields)\n        {\n          SvREFCNT_dec(av_pop(av));\n          av_length--;\n        }\n        if (av_readonly)\n          SvREADONLY_on(av);\n      }\n    }\n\n    av= DBIc_DBISTATE(imp_sth)->get_fbav(imp_sth);\n\n    for (i= 0;  i < num_fields; ++i)\n    {\n      char *col= cols[i];\n      SV *sv= AvARRAY(av)[i]; /* Note: we (re)use the SV in the AV\t*/\n\n      if (col)\n      {\n        STRLEN len= lengths[i];\n        if (ChopBlanks)\n        {\n          while (len && col[len-1] == ' ')\n          {\t--len; }\n        }\n        sv_setpvn(sv, col, len);\n\t/* UTF8 */\n        /*HELMUT*/\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n\n  /* see bottom of: http://www.mysql.org/doc/refman/5.0/en/c-api-datatypes.html */\n        if (imp_dbh->enable_utf8 && fields[i].charsetnr != 63)\n\t  sv_utf8_decode(sv);\n#endif\n\t/* END OF UTF8 */\n      }\n      else\n        (void) SvOK_off(sv);  /*  Field is NULL, return undef  */\n    }\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, %d cols\\n\", num_fields);\n    return av;\n\n#if MYSQL_VERSION_ID  >= SERVER_PREPARE_VERSION\n  }\n#endif\n\n}\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n/*\n  We have to fetch all data from stmt\n  There is may be usefull for 2 cases:\n  1. st_finish when we have undef statement\n  2. call st_execute again when we have some unfetched data in stmt\n */\n\nint mysql_st_clean_cursor(SV* sth, imp_sth_t* imp_sth) {\n\n  if (DBIc_ACTIVE(imp_sth) && dbd_describe(sth, imp_sth) &&\n      !imp_sth->fetch_done)\n    mysql_stmt_free_result(imp_sth->stmt);\n  return 1;\n}\n#endif\n\n/***************************************************************************\n *\n *  Name:    dbd_st_finish\n *\n *  Purpose: Called for freeing a mysql result\n *\n *  Input:   sth - statement handle being finished\n *           imp_sth - drivers private statement handle data\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error() will\n *           be called in the latter case\n *\n **************************************************************************/\n\nint dbd_st_finish(SV* sth, imp_sth_t* imp_sth) {\n  dTHX;\n  D_imp_xxh(sth);\n\n#if defined (dTHR)\n  dTHR;\n#endif\n\n#if MYSQL_ASYNC\n  D_imp_dbh_from_sth;\n  if(imp_dbh->async_query_in_flight) {\n    mysql_db_async_result(sth, &imp_sth->result);\n  }\n#endif\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n  {\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\n--> dbd_st_finish\\n\");\n  }\n\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (imp_sth && imp_sth->stmt)\n    {\n      if (!mysql_st_clean_cursor(sth, imp_sth))\n      {\n        do_error(sth, JW_ERR_SEQUENCE,\n                 \"Error happened while tried to clean up stmt\",NULL);\n        return 0;\n      }\n    }\n  }\n#endif\n\n  /*\n    Cancel further fetches from this cursor.\n    We don't close the cursor till DESTROY.\n    The application may re execute it.\n  */\n  if (imp_sth && DBIc_ACTIVE(imp_sth))\n  {\n    /*\n      Clean-up previous result set(s) for sth to prevent\n      'Commands out of sync' error\n    */\n    mysql_st_free_result_sets(sth, imp_sth);\n  }\n  DBIc_ACTIVE_off(imp_sth);\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n  {\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\n<-- dbd_st_finish\\n\");\n  }\n  return 1;\n}\n\n\n/**************************************************************************\n *\n *  Name:    dbd_st_destroy\n *\n *  Purpose: Our part of the statement handles destructor\n *\n *  Input:   sth - statement handle being destroyed\n *           imp_sth - drivers private statement handle data\n *\n *  Returns: Nothing\n *\n **************************************************************************/\n\nvoid dbd_st_destroy(SV *sth, imp_sth_t *imp_sth) {\n  dTHX;\n  D_imp_xxh(sth);\n\n#if defined (dTHR)\n  dTHR;\n#endif\n\n  int i;\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  imp_sth_fbh_t *fbh;\n  int n;\n\n  n= DBIc_NUM_PARAMS(imp_sth);\n  if (n)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tFreeing %d parameters, bind %p fbind %p\\n\",\n          n, imp_sth->bind, imp_sth->fbind);\n\n    free_bind(imp_sth->bind);\n    free_fbind(imp_sth->fbind);\n  }\n\n  fbh= imp_sth->fbh;\n  if (fbh)\n  {\n    n = DBIc_NUM_FIELDS(imp_sth);\n    i = 0;\n    while (i < n)\n    {\n      if (fbh[i].data) Safefree(fbh[i].data);\n      ++i;\n    }\n\n    free_fbuffer(fbh);\n    if (imp_sth->buffer)\n      free_bind(imp_sth->buffer);\n  }\n\n  if (imp_sth->stmt)\n  {\n    if (mysql_stmt_close(imp_sth->stmt))\n    {\n      do_error(DBIc_PARENT_H(imp_sth), mysql_stmt_errno(imp_sth->stmt),\n          mysql_stmt_error(imp_sth->stmt),\n          mysql_stmt_sqlstate(imp_sth->stmt));\n    }\n  }\n#endif\n\n\n  /* dbd_st_finish has already been called by .xs code if needed.\t*/\n\n  /* Free values allocated by dbd_bind_ph */\n  if (imp_sth->params)\n  {\n    free_param(aTHX_ imp_sth->params, DBIc_NUM_PARAMS(imp_sth));\n    imp_sth->params= NULL;\n  }\n\n  /* Free cached array attributes */\n  for (i= 0; i < AV_ATTRIB_LAST; i++)\n  {\n    if (imp_sth->av_attr[i])\n      SvREFCNT_dec(imp_sth->av_attr[i]);\n    imp_sth->av_attr[i]= Nullav;\n  }\n  /* let DBI know we've done it   */\n  DBIc_IMPSET_off(imp_sth);\n}\n\n\n/*\n **************************************************************************\n *\n *  Name:    dbd_st_STORE_attrib\n *\n *  Purpose: Modifies a statement handles attributes; we currently\n *           support just nothing\n *\n *  Input:   sth - statement handle being destroyed\n *           imp_sth - drivers private statement handle data\n *           keysv - attribute name\n *           valuesv - attribute value\n *\n *  Returns: TRUE for success, FALSE otrherwise; do_error will\n *           be called in the latter case\n *\n **************************************************************************/\nint\ndbd_st_STORE_attrib(\n                    SV *sth,\n                    imp_sth_t *imp_sth,\n                    SV *keysv,\n                    SV *valuesv\n                   )\n{\n  dTHX;\n  STRLEN(kl);\n  char *key= SvPV(keysv, kl);\n  int retval= FALSE;\n  D_imp_xxh(sth);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t\\t-> dbd_st_STORE_attrib for %08lx, key %s\\n\",\n                  (u_long) sth, key);\n\n  if (strEQ(key, \"mysql_use_result\"))\n  {\n    imp_sth->use_mysql_use_result= SvTRUE(valuesv);\n  }\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t\\t<- dbd_st_STORE_attrib for %08lx, result %d\\n\",\n                  (u_long) sth, retval);\n\n  return retval;\n}\n\n\n/*\n **************************************************************************\n *\n *  Name:    dbd_st_FETCH_internal\n *\n *  Purpose: Retrieves a statement handles array attributes; we use\n *           a separate function, because creating the array\n *           attributes shares much code and it aids in supporting\n *           enhanced features like caching.\n *\n *  Input:   sth - statement handle; may even be a database handle,\n *               in which case this will be used for storing error\n *               messages only. This is only valid, if cacheit (the\n *               last argument) is set to TRUE.\n *           what - internal attribute number\n *           res - pointer to a DBMS result\n *           cacheit - TRUE, if results may be cached in the sth.\n *\n *  Returns: RV pointing to result array in case of success, NULL\n *           otherwise; do_error has already been called in the latter\n *           case.\n *\n **************************************************************************/\n\n#ifndef IS_KEY\n#define IS_KEY(A) (((A) & (PRI_KEY_FLAG | UNIQUE_KEY_FLAG | MULTIPLE_KEY_FLAG)) != 0)\n#endif\n\n#if !defined(IS_AUTO_INCREMENT) && defined(AUTO_INCREMENT_FLAG)\n#define IS_AUTO_INCREMENT(A) (((A) & AUTO_INCREMENT_FLAG) != 0)\n#endif\n\nSV*\ndbd_st_FETCH_internal(\n  SV *sth,\n  int what,\n  MYSQL_RES *res,\n  int cacheit\n)\n{\n  dTHX;\n  D_imp_sth(sth);\n  AV *av= Nullav;\n  MYSQL_FIELD *curField;\n\n  /* Are we asking for a legal value? */\n  if (what < 0 ||  what >= AV_ATTRIB_LAST)\n    do_error(sth, JW_ERR_NOT_IMPLEMENTED, \"Not implemented\", NULL);\n\n  /* Return cached value, if possible */\n  else if (cacheit  &&  imp_sth->av_attr[what])\n    av= imp_sth->av_attr[what];\n\n  /* Does this sth really have a result? */\n  else if (!res)\n    do_error(sth, JW_ERR_NOT_ACTIVE,\n\t     \"statement contains no result\" ,NULL);\n  /* Do the real work. */\n  else\n  {\n    av= newAV();\n    mysql_field_seek(res, 0);\n    while ((curField= mysql_fetch_field(res)))\n    {\n      SV *sv;\n\n      switch(what) {\n      case AV_ATTRIB_NAME:\n        sv= newSVpv(curField->name, strlen(curField->name));\n        break;\n\n      case AV_ATTRIB_TABLE:\n        sv= newSVpv(curField->table, strlen(curField->table));\n        break;\n\n      case AV_ATTRIB_TYPE:\n        sv= newSViv((int) curField->type);\n        break;\n\n      case AV_ATTRIB_SQL_TYPE:\n        sv= newSViv((int) native2sql(curField->type)->data_type);\n        break;\n      case AV_ATTRIB_IS_PRI_KEY:\n        sv= boolSV(IS_PRI_KEY(curField->flags));\n        break;\n\n      case AV_ATTRIB_IS_NOT_NULL:\n        sv= boolSV(IS_NOT_NULL(curField->flags));\n        break;\n\n      case AV_ATTRIB_NULLABLE:\n        sv= boolSV(!IS_NOT_NULL(curField->flags));\n        break;\n\n      case AV_ATTRIB_LENGTH:\n        sv= newSViv((int) curField->length);\n        break;\n\n      case AV_ATTRIB_IS_NUM:\n        sv= newSViv((int) native2sql(curField->type)->is_num);\n        break;\n\n      case AV_ATTRIB_TYPE_NAME:\n        sv= newSVpv((char*) native2sql(curField->type)->type_name, 0);\n        break;\n\n      case AV_ATTRIB_MAX_LENGTH:\n        sv= newSViv((int) curField->max_length);\n        break;\n\n      case AV_ATTRIB_IS_AUTO_INCREMENT:\n#if defined(AUTO_INCREMENT_FLAG)\n        sv= boolSV(IS_AUTO_INCREMENT(curField->flags));\n        break;\n#else\n        croak(\"AUTO_INCREMENT_FLAG is not supported on this machine\");\n#endif\n\n      case AV_ATTRIB_IS_KEY:\n        sv= boolSV(IS_KEY(curField->flags));\n        break;\n\n      case AV_ATTRIB_IS_BLOB:\n        sv= boolSV(IS_BLOB(curField->flags));\n        break;\n\n      case AV_ATTRIB_SCALE:\n        sv= newSViv((int) curField->decimals);\n        break;\n\n      case AV_ATTRIB_PRECISION:\n        sv= newSViv((int) (curField->length > curField->max_length) ?\n                     curField->length : curField->max_length);\n        break;\n\n      default:\n        sv= &PL_sv_undef;\n        break;\n      }\n      av_push(av, sv);\n    }\n\n    /* Ensure that this value is kept, decremented in\n     *  dbd_st_destroy and dbd_st_execute.  */\n    if (!cacheit)\n      return sv_2mortal(newRV_noinc((SV*)av));\n    imp_sth->av_attr[what]= av;\n  }\n\n  if (av == Nullav)\n    return &PL_sv_undef;\n\n  return sv_2mortal(newRV_inc((SV*)av));\n}\n\n\n/*\n **************************************************************************\n *\n *  Name:    dbd_st_FETCH_attrib\n *\n *  Purpose: Retrieves a statement handles attributes\n *\n *  Input:   sth - statement handle being destroyed\n *           imp_sth - drivers private statement handle data\n *           keysv - attribute name\n *\n *  Returns: NULL for an unknown attribute, \"undef\" for error,\n *           attribute value otherwise.\n *\n **************************************************************************/\n\n#define ST_FETCH_AV(what) \\\n    dbd_st_FETCH_internal(sth, (what), imp_sth->result, TRUE)\n\n  SV* dbd_st_FETCH_attrib(\n                          SV *sth,\n                          imp_sth_t *imp_sth,\n                          SV *keysv\n                         )\n{\n  dTHX;\n  STRLEN(kl);\n  char *key= SvPV(keysv, kl);\n  SV *retsv= Nullsv;\n  D_imp_xxh(sth);\n\n  if (kl < 2)\n    return Nullsv;\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"    -> dbd_st_FETCH_attrib for %08lx, key %s\\n\",\n                  (u_long) sth, key);\n\n  switch (*key) {\n  case 'N':\n    if (strEQ(key, \"NAME\"))\n      retsv= ST_FETCH_AV(AV_ATTRIB_NAME);\n    else if (strEQ(key, \"NULLABLE\"))\n      retsv= ST_FETCH_AV(AV_ATTRIB_NULLABLE);\n    break;\n  case 'P':\n    if (strEQ(key, \"PRECISION\"))\n      retsv= ST_FETCH_AV(AV_ATTRIB_PRECISION);\n    if (strEQ(key, \"ParamValues\"))\n    {\n        HV *pvhv= newHV();\n        if (DBIc_NUM_PARAMS(imp_sth))\n        {\n            int n;\n            char key[100];\n            I32 keylen;\n            for (n= 0; n < DBIc_NUM_PARAMS(imp_sth); n++)\n            {\n                keylen= sprintf(key, \"%d\", n);\n                hv_store(pvhv, key,\n                         keylen, newSVsv(imp_sth->params[n].value), 0);\n            }\n        }\n        retsv= newRV_noinc((SV*)pvhv);\n    }\n    break;\n  case 'S':\n    if (strEQ(key, \"SCALE\"))\n      retsv= ST_FETCH_AV(AV_ATTRIB_SCALE);\n    break;\n  case 'T':\n    if (strEQ(key, \"TYPE\"))\n      retsv= ST_FETCH_AV(AV_ATTRIB_SQL_TYPE);\n    break;\n  case 'm':\n    switch (kl) {\n    case 10:\n      if (strEQ(key, \"mysql_type\"))\n        retsv= ST_FETCH_AV(AV_ATTRIB_TYPE);\n      break;\n    case 11:\n      if (strEQ(key, \"mysql_table\"))\n        retsv= ST_FETCH_AV(AV_ATTRIB_TABLE);\n      break;\n    case 12:\n      if (       strEQ(key, \"mysql_is_key\"))\n        retsv= ST_FETCH_AV(AV_ATTRIB_IS_KEY);\n      else if (strEQ(key, \"mysql_is_num\"))\n        retsv= ST_FETCH_AV(AV_ATTRIB_IS_NUM);\n      else if (strEQ(key, \"mysql_length\"))\n        retsv= ST_FETCH_AV(AV_ATTRIB_LENGTH);\n      else if (strEQ(key, \"mysql_result\"))\n        retsv= sv_2mortal(newSViv((IV) imp_sth->result));\n      break;\n    case 13:\n      if (strEQ(key, \"mysql_is_blob\"))\n        retsv= ST_FETCH_AV(AV_ATTRIB_IS_BLOB);\n      break;\n    case 14:\n      if (strEQ(key, \"mysql_insertid\"))\n      {\n        /* We cannot return an IV, because the insertid is a long.  */\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"INSERT ID %d\\n\", (int) imp_sth->insertid);\n\n        return sv_2mortal(my_ulonglong2str(aTHX_ imp_sth->insertid));\n      }\n      break;\n    case 15:\n      if (strEQ(key, \"mysql_type_name\"))\n        retsv = ST_FETCH_AV(AV_ATTRIB_TYPE_NAME);\n      break;\n    case 16:\n      if ( strEQ(key, \"mysql_is_pri_key\"))\n        retsv= ST_FETCH_AV(AV_ATTRIB_IS_PRI_KEY);\n      else if (strEQ(key, \"mysql_max_length\"))\n        retsv= ST_FETCH_AV(AV_ATTRIB_MAX_LENGTH);\n      else if (strEQ(key, \"mysql_use_result\"))\n        retsv= boolSV(imp_sth->use_mysql_use_result);\n      break;\n    case 19:\n      if (strEQ(key, \"mysql_warning_count\"))\n        retsv= sv_2mortal(newSViv((IV) imp_sth->warning_count));\n      break;\n    case 20:\n      if (strEQ(key, \"mysql_server_prepare\"))\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n        retsv= sv_2mortal(newSViv((IV) imp_sth->use_server_side_prepare));\n#else\n        retsv= boolSV(0);\n#endif\n      break;\n    case 23:\n      if (strEQ(key, \"mysql_is_auto_increment\"))\n        retsv = ST_FETCH_AV(AV_ATTRIB_IS_AUTO_INCREMENT);\n      break;\n    }\n    break;\n  }\n  return retsv;\n}\n\n\n/***************************************************************************\n *\n *  Name:    dbd_st_blob_read\n *\n *  Purpose: Used for blob reads if the statement handles \"LongTruncOk\"\n *           attribute (currently not supported by DBD::mysql)\n *\n *  Input:   SV* - statement handle from which a blob will be fetched\n *           imp_sth - drivers private statement handle data\n *           field - field number of the blob (note, that a row may\n *               contain more than one blob)\n *           offset - the offset of the field, where to start reading\n *           len - maximum number of bytes to read\n *           destrv - RV* that tells us where to store\n *           destoffset - destination offset\n *\n *  Returns: TRUE for success, FALSE otrherwise; do_error will\n *           be called in the latter case\n *\n **************************************************************************/\n\nint dbd_st_blob_read (\n  SV *sth,\n  imp_sth_t *imp_sth,\n  int field,\n  long offset,\n  long len,\n  SV *destrv,\n  long destoffset)\n{\n    /* quell warnings */\n    sth= sth;\n    imp_sth=imp_sth;\n    field= field;\n    offset= offset;\n    len= len;\n    destrv= destrv;\n    destoffset= destoffset;\n    return FALSE;\n}\n\n\n/***************************************************************************\n *\n *  Name:    dbd_bind_ph\n *\n *  Purpose: Binds a statement value to a parameter\n *\n *  Input:   sth - statement handle\n *           imp_sth - drivers private statement handle data\n *           param - parameter number, counting starts with 1\n *           value - value being inserted for parameter \"param\"\n *           sql_type - SQL type of the value\n *           attribs - bind parameter attributes, currently this must be\n *               one of the values SQL_CHAR, ...\n *           inout - TRUE, if parameter is an output variable (currently\n *               this is not supported)\n *           maxlen - ???\n *\n *  Returns: TRUE for success, FALSE otherwise\n *\n **************************************************************************/\n\nint dbd_bind_ph(SV *sth, imp_sth_t *imp_sth, SV *param, SV *value,\n\t\t IV sql_type, SV *attribs, int is_inout, IV maxlen) {\n  dTHX;\n  int rc;\n  int param_num= SvIV(param);\n  int idx= param_num - 1;\n  char err_msg[64];\n  D_imp_xxh(sth);\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  STRLEN slen;\n  char *buffer= NULL;\n  int buffer_is_null= 0;\n  int buffer_length= slen;\n  unsigned int buffer_type= 0;\n#endif\n\n  D_imp_dbh_from_sth;\n  ASYNC_CHECK_RETURN(sth, FALSE);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"   Called: dbd_bind_ph\\n\");\n\n  attribs= attribs;\n  maxlen= maxlen;\n\n  if (param_num <= 0  ||  param_num > DBIc_NUM_PARAMS(imp_sth))\n  {\n    do_error(sth, JW_ERR_ILLEGAL_PARAM_NUM, \"Illegal parameter number\", NULL);\n    return FALSE;\n  }\n\n  /*\n     This fixes the bug whereby no warning was issued upone binding a\n     defined non-numeric as numeric\n   */\n  if (SvOK(value) &&\n      (sql_type == SQL_NUMERIC  ||\n       sql_type == SQL_DECIMAL  ||\n       sql_type == SQL_INTEGER  ||\n       sql_type == SQL_SMALLINT ||\n       sql_type == SQL_FLOAT    ||\n       sql_type == SQL_REAL     ||\n       sql_type == SQL_DOUBLE) )\n  {\n    if (! looks_like_number(value))\n    {\n      sprintf(err_msg,\n              \"Binding non-numeric field %d, value %s as a numeric!\",\n              param_num, neatsvpv(value,0));\n      do_error(sth, JW_ERR_ILLEGAL_PARAM_NUM, err_msg, NULL);\n    }\n  }\n\n  if (is_inout)\n  {\n    do_error(sth, JW_ERR_NOT_IMPLEMENTED, \"Output parameters not implemented\", NULL);\n    return FALSE;\n  }\n\n  rc = bind_param(&imp_sth->params[idx], value, sql_type);\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n      switch(sql_type) {\n      case SQL_NUMERIC:\n      case SQL_INTEGER:\n      case SQL_SMALLINT:\n      case SQL_BIGINT:\n      case SQL_TINYINT:\n          buffer_type= MYSQL_TYPE_LONG;\n          break;\n      case SQL_DOUBLE:\n      case SQL_DECIMAL: \n      case SQL_FLOAT: \n      case SQL_REAL:\n          buffer_type= MYSQL_TYPE_DOUBLE;\n          break;\n      case SQL_CHAR: \n      case SQL_VARCHAR: \n      case SQL_DATE: \n      case SQL_TIME: \n      case SQL_TIMESTAMP: \n      case SQL_LONGVARCHAR: \n      case SQL_BINARY: \n      case SQL_VARBINARY: \n      case SQL_LONGVARBINARY:\n          buffer_type= MYSQL_TYPE_BLOB;\n          break;\n      default:\n          buffer_type= MYSQL_TYPE_STRING;\n    }\n    buffer_is_null = !(SvOK(imp_sth->params[idx].value) && imp_sth->params[idx].value);\n    if (! buffer_is_null) {\n      switch(buffer_type) {\n        case MYSQL_TYPE_LONG:\n          /* INT */\n          if (!SvIOK(imp_sth->params[idx].value) && DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tTRY TO BIND AN INT NUMBER\\n\");\n          buffer_length = sizeof imp_sth->fbind[idx].numeric_val.lval;\n          imp_sth->fbind[idx].numeric_val.lval= SvIV(imp_sth->params[idx].value);\n          buffer=(void*)&(imp_sth->fbind[idx].numeric_val.lval);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"   SCALAR type %d ->%ld<- IS A INT NUMBER\\n\",\n                          (int) sql_type, (long) (*buffer));\n          break;\n\n        case MYSQL_TYPE_DOUBLE:\n          if (!SvNOK(imp_sth->params[idx].value) && DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tTRY TO BIND A FLOAT NUMBER\\n\");\n          buffer_length = sizeof imp_sth->fbind[idx].numeric_val.dval;\n          imp_sth->fbind[idx].numeric_val.dval= SvNV(imp_sth->params[idx].value);\n          buffer=(char*)&(imp_sth->fbind[idx].numeric_val.dval);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"   SCALAR type %d ->%f<- IS A FLOAT NUMBER\\n\",\n                          (int) sql_type, (double)(*buffer));\n          break;\n\n        case MYSQL_TYPE_BLOB:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"   SCALAR type BLOB\\n\");\n          break;\n\n        case MYSQL_TYPE_STRING:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"   SCALAR type STRING %d, buffertype=%d\\n\", (int) sql_type, buffer_type);\n          break;\n\n        default:\n          croak(\"Bug in DBD::Mysql file dbdimp.c#dbd_bind_ph: do not know how to handle unknown buffer type.\");\n      }\n\n      if (buffer_type == MYSQL_TYPE_STRING || buffer_type == MYSQL_TYPE_BLOB)\n      {\n        buffer= SvPV(imp_sth->params[idx].value, slen);\n        buffer_length= slen;\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                        \" SCALAR type %d ->length %d<- IS A STRING or BLOB\\n\",\n                        (int) sql_type, buffer_length);\n      }\n    }\n    else\n    {\n      /*case: buffer_is_null != 0*/\n      buffer= NULL;\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                      \"   SCALAR NULL VALUE: buffer type is: %d\\n\", buffer_type);\n    }\n\n    /* Type of column was changed. Force to rebind */\n    if (imp_sth->bind[idx].buffer_type != buffer_type) {\n      /* Note: this looks like being another bug:\n       * if type of parameter N changes, then a bind is triggered\n       * with an only partially filled bind structure ??\n       */\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                        \"   FORCE REBIND: buffer type changed from %d to %d, sql-type=%d\\n\",\n                        (int) imp_sth->bind[idx].buffer_type, buffer_type, (int) sql_type);\n      imp_sth->has_been_bound = 0;\n    }\n\n    /* prepare has not been called */\n    if (imp_sth->has_been_bound == 0)\n    {\n      imp_sth->bind[idx].buffer_type= buffer_type;\n      imp_sth->bind[idx].buffer= buffer;\n      imp_sth->bind[idx].buffer_length= buffer_length;\n    }\n    else /* prepare has been called */\n    {\n      imp_sth->stmt->params[idx].buffer= buffer;\n      imp_sth->stmt->params[idx].buffer_length= buffer_length;\n    }\n    imp_sth->fbind[idx].length= buffer_length;\n    imp_sth->fbind[idx].is_null= buffer_is_null;\n  }\n#endif\n  return rc;\n}\n\n\n/***************************************************************************\n *\n *  Name:    mysql_db_reconnect\n *\n *  Purpose: If the server has disconnected, try to reconnect.\n *\n *  Input:   h - database or statement handle\n *\n *  Returns: TRUE for success, FALSE otherwise\n *\n **************************************************************************/\n\nint mysql_db_reconnect(SV* h)\n{\n  dTHX;\n  D_imp_xxh(h);\n  imp_dbh_t* imp_dbh;\n  MYSQL save_socket;\n\n  if (DBIc_TYPE(imp_xxh) == DBIt_ST)\n  {\n    imp_dbh = (imp_dbh_t*) DBIc_PARENT_COM(imp_xxh);\n    h = DBIc_PARENT_H(imp_xxh);\n  }\n  else\n    imp_dbh= (imp_dbh_t*) imp_xxh;\n\n  if (mysql_errno(imp_dbh->pmysql) != CR_SERVER_GONE_ERROR)\n    /* Other error */\n    return FALSE;\n\n  if (!DBIc_has(imp_dbh, DBIcf_AutoCommit) || !imp_dbh->auto_reconnect)\n  {\n    /* We never reconnect if AutoCommit is turned off.\n     * Otherwise we might get an inconsistent transaction\n     * state.\n     */\n    return FALSE;\n  }\n\n  /* my_login will blow away imp_dbh->mysql so we save a copy of\n   * imp_dbh->mysql and put it back where it belongs if the reconnect\n   * fail.  Think server is down & reconnect fails but the application eval{}s\n   * the execute, so next time $dbh->quote() gets called, instant SIGSEGV!\n   */\n  save_socket= *(imp_dbh->pmysql);\n  memcpy (&save_socket, imp_dbh->pmysql,sizeof(save_socket));\n  memset (imp_dbh->pmysql,0,sizeof(*(imp_dbh->pmysql)));\n\n  /* we should disconnect the db handle before reconnecting, this will\n   * prevent my_login from thinking it's adopting an active child which\n   * would prevent the handle from actually reconnecting\n   */\n  if (!dbd_db_disconnect(h, imp_dbh) || !my_login(aTHX_ h, imp_dbh))\n  {\n    do_error(h, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\n             mysql_sqlstate(imp_dbh->pmysql));\n    memcpy (imp_dbh->pmysql, &save_socket, sizeof(save_socket));\n    ++imp_dbh->stats.auto_reconnects_failed;\n    return FALSE;\n  }\n\n  /*\n   *  Tell DBI, that dbh->disconnect should be called for this handle\n   */\n  DBIc_ACTIVE_on(imp_dbh);\n\n  ++imp_dbh->stats.auto_reconnects_ok;\n  return TRUE;\n}\n\n\n/**************************************************************************\n *\n *  Name:    dbd_db_type_info_all\n *\n *  Purpose: Implements $dbh->type_info_all\n *\n *  Input:   dbh - database handle\n *           imp_sth - drivers private database handle data\n *\n *  Returns: RV to AV of types\n *\n **************************************************************************/\n\n#define PV_PUSH(c)                              \\\n    if (c) {                                    \\\n\tsv= newSVpv((char*) (c), 0);           \\\n\tSvREADONLY_on(sv);                      \\\n    } else {                                    \\\n        sv= &PL_sv_undef;                         \\\n    }                                           \\\n    av_push(row, sv);\n\n#define IV_PUSH(i) sv= newSViv((i)); SvREADONLY_on(sv); av_push(row, sv);\n\nAV *dbd_db_type_info_all(SV *dbh, imp_dbh_t *imp_dbh)\n{\n  dTHX;\n  AV *av= newAV();\n  AV *row;\n  HV *hv;\n  SV *sv;\n  int i;\n  const char *cols[] = {\n    \"TYPE_NAME\",\n    \"DATA_TYPE\",\n    \"COLUMN_SIZE\",\n    \"LITERAL_PREFIX\",\n    \"LITERAL_SUFFIX\",\n    \"CREATE_PARAMS\",\n    \"NULLABLE\",\n    \"CASE_SENSITIVE\",\n    \"SEARCHABLE\",\n    \"UNSIGNED_ATTRIBUTE\",\n    \"FIXED_PREC_SCALE\",\n    \"AUTO_UNIQUE_VALUE\",\n    \"LOCAL_TYPE_NAME\",\n    \"MINIMUM_SCALE\",\n    \"MAXIMUM_SCALE\",\n    \"NUM_PREC_RADIX\",\n    \"SQL_DATATYPE\",\n    \"SQL_DATETIME_SUB\",\n    \"INTERVAL_PRECISION\",\n    \"mysql_native_type\",\n    \"mysql_is_num\"\n  };\n\n  dbh= dbh;\n  imp_dbh= imp_dbh;\n \n  hv= newHV();\n  av_push(av, newRV_noinc((SV*) hv));\n  for (i= 0;  i < (int)(sizeof(cols) / sizeof(const char*));  i++)\n  {\n    if (!hv_store(hv, (char*) cols[i], strlen(cols[i]), newSViv(i), 0))\n    {\n      SvREFCNT_dec((SV*) av);\n      return Nullav;\n    }\n  }\n  for (i= 0;  i < (int)SQL_GET_TYPE_INFO_num;  i++)\n  {\n    const sql_type_info_t *t= &SQL_GET_TYPE_INFO_values[i];\n\n    row= newAV();\n    av_push(av, newRV_noinc((SV*) row));\n    PV_PUSH(t->type_name);\n    IV_PUSH(t->data_type);\n    IV_PUSH(t->column_size);\n    PV_PUSH(t->literal_prefix);\n    PV_PUSH(t->literal_suffix);\n    PV_PUSH(t->create_params);\n    IV_PUSH(t->nullable);\n    IV_PUSH(t->case_sensitive);\n    IV_PUSH(t->searchable);\n    IV_PUSH(t->unsigned_attribute);\n    IV_PUSH(t->fixed_prec_scale);\n    IV_PUSH(t->auto_unique_value);\n    PV_PUSH(t->local_type_name);\n    IV_PUSH(t->minimum_scale);\n    IV_PUSH(t->maximum_scale);\n\n    if (t->num_prec_radix)\n    {\n      IV_PUSH(t->num_prec_radix);\n    }\n    else\n      av_push(row, &PL_sv_undef);\n\n    IV_PUSH(t->sql_datatype); /* SQL_DATATYPE*/\n    IV_PUSH(t->sql_datetime_sub); /* SQL_DATETIME_SUB*/\n    IV_PUSH(t->interval_precision); /* INTERVAL_PERCISION */\n    IV_PUSH(t->native_type);\n    IV_PUSH(t->is_num);\n  }\n  return av;\n}\n\n\n/*\n  dbd_db_quote\n\n  Properly quotes a value \n*/\nSV* dbd_db_quote(SV *dbh, SV *str, SV *type)\n{\n  dTHX;\n  SV *result;\n\n  if (SvGMAGICAL(str))\n    mg_get(str);\n\n  if (!SvOK(str))\n    result= newSVpv(\"NULL\", 4);\n  else\n  {\n    char *ptr, *sptr;\n    STRLEN len;\n\n    D_imp_dbh(dbh);\n\n    if (type && SvMAGICAL(type))\n      mg_get(type);\n\n    if (type  &&  SvOK(type))\n    {\n      int i;\n      int tp= SvIV(type);\n      for (i= 0;  i < (int)SQL_GET_TYPE_INFO_num;  i++)\n      {\n        const sql_type_info_t *t= &SQL_GET_TYPE_INFO_values[i];\n        if (t->data_type == tp)\n        {\n          if (!t->literal_prefix)\n            return Nullsv;\n          break;\n        }\n      }\n    }\n\n    ptr= SvPV(str, len);\n    result= newSV(len*2+3);\n#ifdef SvUTF8\n    if (SvUTF8(str)) SvUTF8_on(result);\n#endif\n    sptr= SvPVX(result);\n\n    *sptr++ = '\\'';\n    sptr+= mysql_real_escape_string(imp_dbh->pmysql, sptr,\n                                     ptr, len);\n    *sptr++= '\\'';\n    SvPOK_on(result);\n    SvCUR_set(result, sptr - SvPVX(result));\n    /* Never hurts NUL terminating a Per string */\n    *sptr++= '\\0';\n  }\n  return result;\n}\n\n#ifdef DBD_MYSQL_INSERT_ID_IS_GOOD\nSV *mysql_db_last_insert_id(SV *dbh, imp_dbh_t *imp_dbh,\n        SV *catalog, SV *schema, SV *table, SV *field, SV *attr)\n{\n  dTHX;\n  /* all these non-op settings are to stifle OS X compile warnings */\n  imp_dbh= imp_dbh;\n  dbh= dbh;\n  catalog= catalog;\n  schema= schema;\n  table= table;\n  field= field;\n  attr= attr;\n\n  ASYNC_CHECK_RETURN(dbh, &PL_sv_undef);\n  return sv_2mortal(my_ulonglong2str(aTHX_ mysql_insert_id(imp_dbh->pmysql)));\n}\n#endif\n\n#if MYSQL_ASYNC\nint mysql_db_async_result(SV* h, MYSQL_RES** resp)\n{\n  dTHX;\n  D_imp_xxh(h);\n  imp_dbh_t* dbh;\n  MYSQL* svsock = NULL;\n  MYSQL_RES* _res;\n  int retval = 0;\n  int htype;\n\n  if(! resp) {\n      resp = &_res;\n  }\n  htype = DBIc_TYPE(imp_xxh);\n\n\n  if(htype == DBIt_DB) {\n      D_imp_dbh(h);\n      dbh = imp_dbh;\n  } else {\n      D_imp_sth(h);\n      D_imp_dbh_from_sth;\n      dbh = imp_dbh;\n  }\n\n  if(! dbh->async_query_in_flight) {\n      do_error(h, 2000, \"Gathering asynchronous results for a synchronous handle\", \"HY000\");\n      return -1;\n  }\n  if(dbh->async_query_in_flight != imp_xxh) {\n      do_error(h, 2000, \"Gathering async_query_in_flight results for the wrong handle\", \"HY000\");\n      return -1;\n  }\n  dbh->async_query_in_flight = NULL;\n\n  svsock= dbh->pmysql;\n  retval= mysql_read_query_result(svsock);\n  if(! retval) {\n    *resp= mysql_store_result(svsock);\n\n    if (mysql_errno(svsock))\n      do_error(h, mysql_errno(svsock), mysql_error(svsock), mysql_sqlstate(svsock));\n    if (!*resp)\n      retval= mysql_affected_rows(svsock);\n    else {\n      retval= mysql_num_rows(*resp);\n      if(resp == &_res) {\n        mysql_free_result(*resp);\n      }\n    }\n    if(htype == DBIt_ST) {\n      D_imp_sth(h);\n      D_imp_dbh_from_sth;\n\n      if(retval+1 != (my_ulonglong)-1) {\n        if(! *resp) {\n          imp_sth->insertid= mysql_insert_id(svsock);\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n          if(! mysql_more_results(svsock))\n            DBIc_ACTIVE_off(imp_sth);\n#endif\n        } else {\n          DBIc_NUM_FIELDS(imp_sth)= mysql_num_fields(imp_sth->result);\n          imp_sth->done_desc= 0;\n          imp_sth->fetch_done= 0;\n        }\n      }\n      imp_sth->warning_count = mysql_warning_count(imp_dbh->pmysql);\n    }\n  } else {\n     do_error(h, mysql_errno(svsock), mysql_error(svsock),\n              mysql_sqlstate(svsock));\n     return -1;\n  }\n return retval;\n}\n\nint mysql_db_async_ready(SV* h)\n{\n  dTHX;\n  D_imp_xxh(h);\n  imp_dbh_t* dbh;\n  int htype;\n\n  htype = DBIc_TYPE(imp_xxh);\n  \n  if(htype == DBIt_DB) {\n      D_imp_dbh(h);\n      dbh = imp_dbh;\n  } else {\n      D_imp_sth(h);\n      D_imp_dbh_from_sth;\n      dbh = imp_dbh;\n  }\n\n  if(dbh->async_query_in_flight) {\n      if(dbh->async_query_in_flight == imp_xxh) {\n          struct pollfd fds;\n          int retval;\n\n          fds.fd = dbh->pmysql->net.fd;\n          fds.events = POLLIN;\n\n          retval = poll(&fds, 1, 0);\n\n          if(retval < 0) {\n              do_error(h, errno, strerror(errno), \"HY000\");\n          }\n          return retval;\n      } else {\n          do_error(h, 2000, \"Calling mysql_async_ready on the wrong handle\", \"HY000\");\n          return -1;\n      }\n  } else {\n      do_error(h, 2000, \"Handle is not in asynchronous mode\", \"HY000\");\n      return -1;\n  }\n}\n#endif\n\n\nstatic int parse_number(char *string, STRLEN len, char **end)\n{\n    int seen_neg;\n    int seen_dec;\n    int seen_e;\n    int seen_plus;\n    int seen_digit;\n    char *cp;\n\n    seen_neg= seen_dec= seen_e= seen_plus= seen_digit= 0;\n\n    if (len <= 0) {\n        len= strlen(string);\n    }\n\n    cp= string;\n\n    /* Skip leading whitespace */\n    while (*cp && isspace(*cp))\n      cp++;\n\n    for ( ; *cp; cp++)\n    {\n      if ('-' == *cp)\n      {\n        if (seen_neg >= 2)\n        {\n          /*\n            third '-'. number can contains two '-'.\n            because -1e-10 is valid number */\n          break;\n        }\n        seen_neg += 1;\n      }\n      else if ('.' == *cp)\n      {\n        if (seen_dec)\n        {\n          /* second '.' */\n          break;\n        }\n        seen_dec= 1;\n      }\n      else if ('e' == *cp)\n      {\n        if (seen_e)\n        {\n          /* second 'e' */\n          break;\n        }\n        seen_e= 1;\n      }\n      else if ('+' == *cp)\n      {\n        if (seen_plus)\n        {\n          /* second '+' */\n          break;\n        }\n        seen_plus= 1;\n      }\n      else if (!isdigit(*cp))\n      {\n        /* Not sure why this was changed */\n        /* seen_digit= 1; */\n        break;\n      }\n    }\n\n    *end= cp;\n\n    /* length 0 -> not a number */\n    /* Need to revisit this */\n    /*if (len == 0 || cp - string < (int) len || seen_digit == 0) {*/\n    if (len == 0 || cp - string < (int) len) {\n        return -1;\n    }\n\n    return 0;\n}\n"], "filenames": ["dbdimp.c"], "buggy_code_start_loc": [1998], "buggy_code_end_loc": [2107], "fixing_code_start_loc": [1999], "fixing_code_end_loc": [2115], "type": "CWE-416", "message": "Use-after-free vulnerability in DBD::mysql before 4.029 allows attackers to cause a denial of service (program crash) or possibly execute arbitrary code via vectors related to a lost server connection.", "other": {"cve": {"id": "CVE-2014-9906", "sourceIdentifier": "security@debian.org", "published": "2016-08-19T21:59:00.133", "lastModified": "2016-11-28T19:15:49.847", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Use-after-free vulnerability in DBD::mysql before 4.029 allows attackers to cause a denial of service (program crash) or possibly execute arbitrary code via vectors related to a lost server connection."}, {"lang": "es", "value": "Vulnerabilidad de uso despu\u00e9s de liberaci\u00f3n de memoria en DBD::mysql en versiones anteriores a 4.029 permite a atacantes provocar una denegaci\u00f3n de servicio (ca\u00edda del programa) o posiblemente ejecutar c\u00f3digo arbitrario a trav\u00e9s de vectores relacionados con una conexi\u00f3n de servidor perdida."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 10.0}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dbd-mysql_project:dbd-mysql:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.028", "matchCriteriaId": "11802C6C-236E-4C5F-B56D-82B6CE2AF2C5"}]}]}], "references": [{"url": "http://cpansearch.perl.org/src/CAPTTOFU/DBD-mysql-4.029/ChangeLog", "source": "security@debian.org", "tags": ["Release Notes"]}, {"url": "http://www.debian.org/security/2016/dsa-3635", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/07/27/5", "source": "security@debian.org", "tags": ["Mailing List", "VDB Entry"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/07/27/6", "source": "security@debian.org", "tags": ["Mailing List", "VDB Entry"]}, {"url": "http://www.securityfocus.com/bid/92149", "source": "security@debian.org"}, {"url": "https://github.com/perl5-dbi/DBD-mysql/commit/a56ae87a4c1c1fead7d09c3653905841ccccf1cc", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://rt.cpan.org/Public/Bug/Display.html?id=97625", "source": "security@debian.org", "tags": ["Issue Tracking"]}]}, "github_commit_url": "https://github.com/perl5-dbi/DBD-mysql/commit/a56ae87a4c1c1fead7d09c3653905841ccccf1cc"}}