{"buggy_code": ["/*\n * Bittorrent Client using Qt and libtorrent.\n * Copyright (C) 2014  Vladimir Golovnev <glassez@yandex.ru>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n * In addition, as a special exception, the copyright holders give permission to\n * link this program with the OpenSSL project's \"OpenSSL\" library (or with\n * modified versions of it that use the same license as the \"OpenSSL\" library),\n * and distribute the linked executables. You must obey the GNU General Public\n * License in all respects for all of the code used other than \"OpenSSL\".  If you\n * modify file(s), you may extend this exception to your version of the file(s),\n * but you are not obligated to do so. If you do not wish to do so, delete this\n * exception statement from your version.\n */\n\n#ifndef HTTP_TYPES_H\n#define HTTP_TYPES_H\n\n#include <QString>\n#include <QMap>\n#include <QHostAddress>\n#include <QVector>\n\n#include \"base/types.h\"\n\nnamespace Http\n{\n    const QString HEADER_SET_COOKIE = \"Set-Cookie\";\n    const QString HEADER_CONTENT_TYPE = \"Content-Type\";\n    const QString HEADER_CONTENT_ENCODING = \"Content-Encoding\";\n    const QString HEADER_CONTENT_LENGTH = \"Content-Length\";\n    const QString HEADER_CACHE_CONTROL = \"Cache-Control\";\n\n    const QString CONTENT_TYPE_CSS = \"text/css; charset=UTF-8\";\n    const QString CONTENT_TYPE_GIF = \"image/gif\";\n    const QString CONTENT_TYPE_HTML = \"text/html; charset=UTF-8\";\n    const QString CONTENT_TYPE_JS = \"application/javascript; charset=UTF-8\";\n    const QString CONTENT_TYPE_JSON = \"application/json\";\n    const QString CONTENT_TYPE_PNG = \"image/png\";\n    const QString CONTENT_TYPE_TXT = \"text/plain; charset=UTF-8\";\n\n    struct Environment\n    {\n        QHostAddress clientAddress;\n    };\n\n    struct UploadedFile\n    {\n        QString filename; // original filename\n        QString type; // MIME type\n        QByteArray data; // File data\n    };\n\n    struct Request\n    {\n        QString method;\n        QString path;\n        QStringMap headers;\n        QStringMap gets;\n        QStringMap posts;\n        QVector<UploadedFile> files;\n    };\n\n    struct ResponseStatus\n    {\n        uint code;\n        QString text;\n\n        ResponseStatus(uint code = 200, const QString& text = \"OK\"): code(code), text(text) {}\n    };\n\n    struct Response\n    {\n        ResponseStatus status;\n        QStringMap headers;\n        QByteArray content;\n\n        Response(uint code = 200, const QString& text = \"OK\"): status(code, text) {}\n    };\n}\n\n#endif // HTTP_TYPES_H\n", "/*\n * Bittorrent Client using Qt and libtorrent.\n * Copyright (C) 2014  Vladimir Golovnev <glassez@yandex.ru>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n * In addition, as a special exception, the copyright holders give permission to\n * link this program with the OpenSSL project's \"OpenSSL\" library (or with\n * modified versions of it that use the same license as the \"OpenSSL\" library),\n * and distribute the linked executables. You must obey the GNU General Public\n * License in all respects for all of the code used other than \"OpenSSL\".  If you\n * modify file(s), you may extend this exception to your version of the file(s),\n * but you are not obligated to do so. If you do not wish to do so, delete this\n * exception statement from your version.\n */\n\n#include \"abstractwebapplication.h\"\n\n#include <QCoreApplication>\n#include <QDateTime>\n#include <QDebug>\n#include <QDir>\n#include <QFile>\n#include <QNetworkCookie>\n#include <QTemporaryFile>\n#include <QTimer>\n\n#include \"base/preferences.h\"\n#include \"base/utils/fs.h\"\n#include \"base/utils/random.h\"\n#include \"websessiondata.h\"\n\n// UnbanTimer\n\nclass UnbanTimer: public QTimer\n{\npublic:\n    UnbanTimer(const QHostAddress& peer_ip, QObject *parent)\n        : QTimer(parent), m_peerIp(peer_ip)\n    {\n        setSingleShot(true);\n        setInterval(BAN_TIME);\n    }\n\n    inline const QHostAddress& peerIp() const { return m_peerIp; }\n\nprivate:\n    QHostAddress m_peerIp;\n};\n\n// WebSession\n\nstruct WebSession\n{\n    const QString id;\n    uint timestamp;\n    WebSessionData data;\n\n    WebSession(const QString& id)\n        : id(id)\n    {\n        updateTimestamp();\n    }\n\n    void updateTimestamp()\n    {\n        timestamp = QDateTime::currentDateTime().toTime_t();\n    }\n};\n\n// AbstractWebApplication\n\nAbstractWebApplication::AbstractWebApplication(QObject *parent)\n    : Http::ResponseBuilder(parent)\n    , session_(0)\n{\n    QTimer *timer = new QTimer(this);\n    timer->setInterval(60000); // 1 min.\n    connect(timer, SIGNAL(timeout()), SLOT(removeInactiveSessions()));\n}\n\nAbstractWebApplication::~AbstractWebApplication()\n{\n    // cleanup sessions data\n    qDeleteAll(sessions_);\n}\n\nHttp::Response AbstractWebApplication::processRequest(const Http::Request &request, const Http::Environment &env)\n{\n    session_ = 0;\n    request_ = request;\n    env_ = env;\n\n    clear(); // clear response\n\n    sessionInitialize();\n    if (!sessionActive() && !isAuthNeeded())\n        sessionStart();\n\n    if (isBanned()) {\n        status(403, \"Forbidden\");\n        print(QObject::tr(\"Your IP address has been banned after too many failed authentication attempts.\"), Http::CONTENT_TYPE_TXT);\n    }\n    else {\n        processRequest();\n    }\n\n    return response();\n}\n\nvoid AbstractWebApplication::UnbanTimerEvent()\n{\n    UnbanTimer* ubantimer = static_cast<UnbanTimer*>(sender());\n    qDebug(\"Ban period has expired for %s\", qPrintable(ubantimer->peerIp().toString()));\n    clientFailedAttempts_.remove(ubantimer->peerIp());\n    ubantimer->deleteLater();\n}\n\nvoid AbstractWebApplication::removeInactiveSessions()\n{\n    const uint now = QDateTime::currentDateTime().toTime_t();\n\n    foreach (const QString &id, sessions_.keys()) {\n        if ((now - sessions_[id]->timestamp) > INACTIVE_TIME)\n            delete sessions_.take(id);\n    }\n}\n\nbool AbstractWebApplication::sessionInitialize()\n{\n    static const QString SID_START = QLatin1String(C_SID) + QLatin1String(\"=\");\n\n    if (session_ == 0)\n    {\n        QString cookie = request_.headers.value(\"cookie\");\n        //qDebug() << Q_FUNC_INFO << \"cookie: \" << cookie;\n\n        QString sessionId;\n        int pos = cookie.indexOf(SID_START);\n        if (pos >= 0) {\n            pos += SID_START.length();\n            int end = cookie.indexOf(QRegExp(\"[,;]\"), pos);\n            sessionId = cookie.mid(pos, end >= 0 ? end - pos : end);\n        }\n\n        // TODO: Additional session check\n\n        if (!sessionId.isNull()) {\n            if (sessions_.contains(sessionId)) {\n                session_ = sessions_[sessionId];\n                session_->updateTimestamp();\n                return true;\n            }\n            else {\n                qDebug() << Q_FUNC_INFO << \"session does not exist!\";\n            }\n        }\n    }\n\n    return false;\n}\n\nbool AbstractWebApplication::readFile(const QString& path, QByteArray &data, QString &type)\n{\n    QString ext = \"\";\n    int index = path.lastIndexOf('.') + 1;\n    if (index > 0)\n        ext = path.mid(index);\n\n    // find translated file in cache\n    if (translatedFiles_.contains(path)) {\n        data = translatedFiles_[path];\n    }\n    else {\n        QFile file(path);\n        if (!file.open(QIODevice::ReadOnly)) {\n            qDebug(\"File %s was not found!\", qPrintable(path));\n            return false;\n        }\n\n        data = file.readAll();\n        file.close();\n\n        // Translate the file\n        if ((ext == \"html\") || ((ext == \"js\") && !path.endsWith(\"excanvas-compressed.js\"))) {\n            QString dataStr = QString::fromUtf8(data.constData());\n            translateDocument(dataStr);\n\n            if (path.endsWith(\"about.html\") || path.endsWith(\"index.html\") || path.endsWith(\"client.js\"))\n                dataStr.replace(\"${VERSION}\", VERSION);\n\n            data = dataStr.toUtf8();\n            translatedFiles_[path] = data; // cashing translated file\n        }\n    }\n\n    type = CONTENT_TYPE_BY_EXT[ext];\n    return true;\n}\n\nWebSessionData *AbstractWebApplication::session()\n{\n    Q_ASSERT(session_ != 0);\n    return &session_->data;\n}\n\n\nQString AbstractWebApplication::generateSid()\n{\n    QString sid;\n\n    do {\n        const size_t size = 6;\n        quint32 tmp[size];\n\n        for (size_t i = 0; i < size; ++i)\n            tmp[i] = Utils::Random::rand();\n\n        sid = QByteArray::fromRawData(reinterpret_cast<const char *>(tmp), sizeof(quint32) * size).toBase64();\n    }\n    while (sessions_.contains(sid));\n\n    return sid;\n}\n\nvoid AbstractWebApplication::translateDocument(QString& data)\n{\n    const QRegExp regex(\"QBT_TR\\\\((([^\\\\)]|\\\\)(?!QBT_TR))+)\\\\)QBT_TR(\\\\[CONTEXT=([a-zA-Z_][a-zA-Z0-9_]*)\\\\])?\");\n    const QRegExp mnemonic(\"\\\\(?&([a-zA-Z]?\\\\))?\");\n    const std::string contexts[] = {\n        \"TransferListFiltersWidget\", \"TransferListWidget\", \"PropertiesWidget\",\n        \"HttpServer\", \"confirmDeletionDlg\", \"TrackerList\", \"TorrentFilesModel\",\n        \"options_imp\", \"Preferences\", \"TrackersAdditionDlg\", \"ScanFoldersModel\",\n        \"PropTabBar\", \"TorrentModel\", \"downloadFromURL\", \"MainWindow\", \"misc\",\n        \"StatusBar\", \"AboutDlg\", \"about\", \"PeerListWidget\", \"StatusFiltersWidget\",\n        \"CategoryFiltersList\", \"TransferListDelegate\"\n    };\n    const size_t context_count = sizeof(contexts) / sizeof(contexts[0]);\n    int i = 0;\n    bool found = true;\n\n    const QString locale = Preferences::instance()->getLocale();\n    bool isTranslationNeeded = !locale.startsWith(\"en\") || locale.startsWith(\"en_AU\") || locale.startsWith(\"en_GB\");\n\n    while(i < data.size() && found) {\n        i = regex.indexIn(data, i);\n        if (i >= 0) {\n            //qDebug(\"Found translatable string: %s\", regex.cap(1).toUtf8().data());\n            QByteArray word = regex.cap(1).toUtf8();\n\n            QString translation = word;\n            if (isTranslationNeeded) {\n                QString context = regex.cap(4);\n                if (context.length() > 0) {\n#ifndef QBT_USES_QT5\n                    translation = qApp->translate(context.toUtf8().constData(), word.constData(), 0, QCoreApplication::UnicodeUTF8, 1);\n#else\n                    translation = qApp->translate(context.toUtf8().constData(), word.constData(), 0, 1);\n#endif\n                }\n                else {\n                    size_t context_index = 0;\n                    while ((context_index < context_count) && (translation == word)) {\n#ifndef QBT_USES_QT5\n                        translation = qApp->translate(contexts[context_index].c_str(), word.constData(), 0, QCoreApplication::UnicodeUTF8, 1);\n#else\n                        translation = qApp->translate(contexts[context_index].c_str(), word.constData(), 0, 1);\n#endif\n                        ++context_index;\n                    }\n                }\n            }\n            // Remove keyboard shortcuts\n            translation.replace(mnemonic, \"\");\n\n            // Use HTML code for quotes to prevent issues with JS\n            translation.replace(\"'\", \"&#39;\");\n            translation.replace(\"\\\"\", \"&#34;\");\n\n            data.replace(i, regex.matchedLength(), translation);\n            i += translation.length();\n        }\n        else {\n            found = false; // no more translatable strings\n        }\n    }\n}\n\nbool AbstractWebApplication::isBanned() const\n{\n    return clientFailedAttempts_.value(env_.clientAddress, 0) >= MAX_AUTH_FAILED_ATTEMPTS;\n}\n\nint AbstractWebApplication::failedAttempts() const\n{\n    return clientFailedAttempts_.value(env_.clientAddress, 0);\n}\n\nvoid AbstractWebApplication::resetFailedAttempts()\n{\n    clientFailedAttempts_.remove(env_.clientAddress);\n}\n\nvoid AbstractWebApplication::increaseFailedAttempts()\n{\n    const int nb_fail = clientFailedAttempts_.value(env_.clientAddress, 0) + 1;\n\n    clientFailedAttempts_[env_.clientAddress] = nb_fail;\n    if (nb_fail == MAX_AUTH_FAILED_ATTEMPTS) {\n        // Max number of failed attempts reached\n        // Start ban period\n        UnbanTimer* ubantimer = new UnbanTimer(env_.clientAddress, this);\n        connect(ubantimer, SIGNAL(timeout()), SLOT(UnbanTimerEvent()));\n        ubantimer->start();\n    }\n}\n\nbool AbstractWebApplication::isAuthNeeded()\n{\n    return (env_.clientAddress != QHostAddress::LocalHost\n            && env_.clientAddress != QHostAddress::LocalHostIPv6\n            && env_.clientAddress != QHostAddress(\"::ffff:127.0.0.1\"))\n            || Preferences::instance()->isWebUiLocalAuthEnabled();\n}\n\nvoid AbstractWebApplication::printFile(const QString& path)\n{\n    QByteArray data;\n    QString type;\n\n    if (!readFile(path, data, type)) {\n        status(404, \"Not Found\");\n        return;\n    }\n\n    print(data, type);\n}\n\nbool AbstractWebApplication::sessionStart()\n{\n    if (session_ == 0) {\n        session_ = new WebSession(generateSid());\n        sessions_[session_->id] = session_;\n\n        QNetworkCookie cookie(C_SID, session_->id.toUtf8());\n        cookie.setPath(QLatin1String(\"/\"));\n        header(Http::HEADER_SET_COOKIE, cookie.toRawForm());\n\n        return true;\n    }\n\n    return false;\n}\n\nbool AbstractWebApplication::sessionEnd()\n{\n    if ((session_ != 0) && (sessions_.contains(session_->id))) {\n        QNetworkCookie cookie(C_SID, session_->id.toUtf8());\n        cookie.setPath(QLatin1String(\"/\"));\n        cookie.setExpirationDate(QDateTime::currentDateTime());\n\n        sessions_.remove(session_->id);\n        delete session_;\n        session_ = 0;\n\n        header(Http::HEADER_SET_COOKIE, cookie.toRawForm());\n        return true;\n    }\n\n    return false;\n}\n\nQString AbstractWebApplication::saveTmpFile(const QByteArray &data)\n{\n    QTemporaryFile tmpfile(Utils::Fs::tempPath() + \"XXXXXX.torrent\");\n    tmpfile.setAutoRemove(false);\n    if (tmpfile.open()) {\n        tmpfile.write(data);\n        tmpfile.close();\n        return tmpfile.fileName();\n    }\n\n    qWarning() << \"I/O Error: Could not create temporary file\";\n    return QString();\n}\n\nQStringMap AbstractWebApplication::initializeContentTypeByExtMap()\n{\n    QStringMap map;\n\n    map[\"htm\"] = Http::CONTENT_TYPE_HTML;\n    map[\"html\"] = Http::CONTENT_TYPE_HTML;\n    map[\"css\"] = Http::CONTENT_TYPE_CSS;\n    map[\"gif\"] = Http::CONTENT_TYPE_GIF;\n    map[\"png\"] = Http::CONTENT_TYPE_PNG;\n    map[\"js\"] = Http::CONTENT_TYPE_JS;\n\n    return map;\n}\n\nconst QStringMap AbstractWebApplication::CONTENT_TYPE_BY_EXT = AbstractWebApplication::initializeContentTypeByExtMap();\n"], "fixing_code": ["/*\n * Bittorrent Client using Qt and libtorrent.\n * Copyright (C) 2014  Vladimir Golovnev <glassez@yandex.ru>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n * In addition, as a special exception, the copyright holders give permission to\n * link this program with the OpenSSL project's \"OpenSSL\" library (or with\n * modified versions of it that use the same license as the \"OpenSSL\" library),\n * and distribute the linked executables. You must obey the GNU General Public\n * License in all respects for all of the code used other than \"OpenSSL\".  If you\n * modify file(s), you may extend this exception to your version of the file(s),\n * but you are not obligated to do so. If you do not wish to do so, delete this\n * exception statement from your version.\n */\n\n#ifndef HTTP_TYPES_H\n#define HTTP_TYPES_H\n\n#include <QString>\n#include <QMap>\n#include <QHostAddress>\n#include <QVector>\n\n#include \"base/types.h\"\n\nnamespace Http\n{\n    const QString HEADER_SET_COOKIE = \"Set-Cookie\";\n    const QString HEADER_CONTENT_TYPE = \"Content-Type\";\n    const QString HEADER_CONTENT_ENCODING = \"Content-Encoding\";\n    const QString HEADER_CONTENT_LENGTH = \"Content-Length\";\n    const QString HEADER_CACHE_CONTROL = \"Cache-Control\";\n    const QString HEADER_X_FRAME_OPTIONS = \"X-Frame-Options\";\n\n    const QString CONTENT_TYPE_CSS = \"text/css; charset=UTF-8\";\n    const QString CONTENT_TYPE_GIF = \"image/gif\";\n    const QString CONTENT_TYPE_HTML = \"text/html; charset=UTF-8\";\n    const QString CONTENT_TYPE_JS = \"application/javascript; charset=UTF-8\";\n    const QString CONTENT_TYPE_JSON = \"application/json\";\n    const QString CONTENT_TYPE_PNG = \"image/png\";\n    const QString CONTENT_TYPE_TXT = \"text/plain; charset=UTF-8\";\n\n    struct Environment\n    {\n        QHostAddress clientAddress;\n    };\n\n    struct UploadedFile\n    {\n        QString filename; // original filename\n        QString type; // MIME type\n        QByteArray data; // File data\n    };\n\n    struct Request\n    {\n        QString method;\n        QString path;\n        QStringMap headers;\n        QStringMap gets;\n        QStringMap posts;\n        QVector<UploadedFile> files;\n    };\n\n    struct ResponseStatus\n    {\n        uint code;\n        QString text;\n\n        ResponseStatus(uint code = 200, const QString& text = \"OK\"): code(code), text(text) {}\n    };\n\n    struct Response\n    {\n        ResponseStatus status;\n        QStringMap headers;\n        QByteArray content;\n\n        Response(uint code = 200, const QString& text = \"OK\"): status(code, text) {}\n    };\n}\n\n#endif // HTTP_TYPES_H\n", "/*\n * Bittorrent Client using Qt and libtorrent.\n * Copyright (C) 2014  Vladimir Golovnev <glassez@yandex.ru>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n * In addition, as a special exception, the copyright holders give permission to\n * link this program with the OpenSSL project's \"OpenSSL\" library (or with\n * modified versions of it that use the same license as the \"OpenSSL\" library),\n * and distribute the linked executables. You must obey the GNU General Public\n * License in all respects for all of the code used other than \"OpenSSL\".  If you\n * modify file(s), you may extend this exception to your version of the file(s),\n * but you are not obligated to do so. If you do not wish to do so, delete this\n * exception statement from your version.\n */\n\n#include \"abstractwebapplication.h\"\n\n#include <QCoreApplication>\n#include <QDateTime>\n#include <QDebug>\n#include <QDir>\n#include <QFile>\n#include <QNetworkCookie>\n#include <QTemporaryFile>\n#include <QTimer>\n\n#include \"base/preferences.h\"\n#include \"base/utils/fs.h\"\n#include \"base/utils/random.h\"\n#include \"websessiondata.h\"\n\n// UnbanTimer\n\nclass UnbanTimer: public QTimer\n{\npublic:\n    UnbanTimer(const QHostAddress& peer_ip, QObject *parent)\n        : QTimer(parent), m_peerIp(peer_ip)\n    {\n        setSingleShot(true);\n        setInterval(BAN_TIME);\n    }\n\n    inline const QHostAddress& peerIp() const { return m_peerIp; }\n\nprivate:\n    QHostAddress m_peerIp;\n};\n\n// WebSession\n\nstruct WebSession\n{\n    const QString id;\n    uint timestamp;\n    WebSessionData data;\n\n    WebSession(const QString& id)\n        : id(id)\n    {\n        updateTimestamp();\n    }\n\n    void updateTimestamp()\n    {\n        timestamp = QDateTime::currentDateTime().toTime_t();\n    }\n};\n\n// AbstractWebApplication\n\nAbstractWebApplication::AbstractWebApplication(QObject *parent)\n    : Http::ResponseBuilder(parent)\n    , session_(0)\n{\n    QTimer *timer = new QTimer(this);\n    timer->setInterval(60000); // 1 min.\n    connect(timer, SIGNAL(timeout()), SLOT(removeInactiveSessions()));\n}\n\nAbstractWebApplication::~AbstractWebApplication()\n{\n    // cleanup sessions data\n    qDeleteAll(sessions_);\n}\n\nHttp::Response AbstractWebApplication::processRequest(const Http::Request &request, const Http::Environment &env)\n{\n    session_ = 0;\n    request_ = request;\n    env_ = env;\n\n    // clear response\n    clear();\n\n    // avoid clickjacking attacks\n    header(Http::HEADER_X_FRAME_OPTIONS, \"SAMEORIGIN\");\n\n    sessionInitialize();\n    if (!sessionActive() && !isAuthNeeded())\n        sessionStart();\n\n    if (isBanned()) {\n        status(403, \"Forbidden\");\n        print(QObject::tr(\"Your IP address has been banned after too many failed authentication attempts.\"), Http::CONTENT_TYPE_TXT);\n    }\n    else {\n        processRequest();\n    }\n\n    return response();\n}\n\nvoid AbstractWebApplication::UnbanTimerEvent()\n{\n    UnbanTimer* ubantimer = static_cast<UnbanTimer*>(sender());\n    qDebug(\"Ban period has expired for %s\", qPrintable(ubantimer->peerIp().toString()));\n    clientFailedAttempts_.remove(ubantimer->peerIp());\n    ubantimer->deleteLater();\n}\n\nvoid AbstractWebApplication::removeInactiveSessions()\n{\n    const uint now = QDateTime::currentDateTime().toTime_t();\n\n    foreach (const QString &id, sessions_.keys()) {\n        if ((now - sessions_[id]->timestamp) > INACTIVE_TIME)\n            delete sessions_.take(id);\n    }\n}\n\nbool AbstractWebApplication::sessionInitialize()\n{\n    static const QString SID_START = QLatin1String(C_SID) + QLatin1String(\"=\");\n\n    if (session_ == 0)\n    {\n        QString cookie = request_.headers.value(\"cookie\");\n        //qDebug() << Q_FUNC_INFO << \"cookie: \" << cookie;\n\n        QString sessionId;\n        int pos = cookie.indexOf(SID_START);\n        if (pos >= 0) {\n            pos += SID_START.length();\n            int end = cookie.indexOf(QRegExp(\"[,;]\"), pos);\n            sessionId = cookie.mid(pos, end >= 0 ? end - pos : end);\n        }\n\n        // TODO: Additional session check\n\n        if (!sessionId.isNull()) {\n            if (sessions_.contains(sessionId)) {\n                session_ = sessions_[sessionId];\n                session_->updateTimestamp();\n                return true;\n            }\n            else {\n                qDebug() << Q_FUNC_INFO << \"session does not exist!\";\n            }\n        }\n    }\n\n    return false;\n}\n\nbool AbstractWebApplication::readFile(const QString& path, QByteArray &data, QString &type)\n{\n    QString ext = \"\";\n    int index = path.lastIndexOf('.') + 1;\n    if (index > 0)\n        ext = path.mid(index);\n\n    // find translated file in cache\n    if (translatedFiles_.contains(path)) {\n        data = translatedFiles_[path];\n    }\n    else {\n        QFile file(path);\n        if (!file.open(QIODevice::ReadOnly)) {\n            qDebug(\"File %s was not found!\", qPrintable(path));\n            return false;\n        }\n\n        data = file.readAll();\n        file.close();\n\n        // Translate the file\n        if ((ext == \"html\") || ((ext == \"js\") && !path.endsWith(\"excanvas-compressed.js\"))) {\n            QString dataStr = QString::fromUtf8(data.constData());\n            translateDocument(dataStr);\n\n            if (path.endsWith(\"about.html\") || path.endsWith(\"index.html\") || path.endsWith(\"client.js\"))\n                dataStr.replace(\"${VERSION}\", VERSION);\n\n            data = dataStr.toUtf8();\n            translatedFiles_[path] = data; // cashing translated file\n        }\n    }\n\n    type = CONTENT_TYPE_BY_EXT[ext];\n    return true;\n}\n\nWebSessionData *AbstractWebApplication::session()\n{\n    Q_ASSERT(session_ != 0);\n    return &session_->data;\n}\n\n\nQString AbstractWebApplication::generateSid()\n{\n    QString sid;\n\n    do {\n        const size_t size = 6;\n        quint32 tmp[size];\n\n        for (size_t i = 0; i < size; ++i)\n            tmp[i] = Utils::Random::rand();\n\n        sid = QByteArray::fromRawData(reinterpret_cast<const char *>(tmp), sizeof(quint32) * size).toBase64();\n    }\n    while (sessions_.contains(sid));\n\n    return sid;\n}\n\nvoid AbstractWebApplication::translateDocument(QString& data)\n{\n    const QRegExp regex(\"QBT_TR\\\\((([^\\\\)]|\\\\)(?!QBT_TR))+)\\\\)QBT_TR(\\\\[CONTEXT=([a-zA-Z_][a-zA-Z0-9_]*)\\\\])?\");\n    const QRegExp mnemonic(\"\\\\(?&([a-zA-Z]?\\\\))?\");\n    const std::string contexts[] = {\n        \"TransferListFiltersWidget\", \"TransferListWidget\", \"PropertiesWidget\",\n        \"HttpServer\", \"confirmDeletionDlg\", \"TrackerList\", \"TorrentFilesModel\",\n        \"options_imp\", \"Preferences\", \"TrackersAdditionDlg\", \"ScanFoldersModel\",\n        \"PropTabBar\", \"TorrentModel\", \"downloadFromURL\", \"MainWindow\", \"misc\",\n        \"StatusBar\", \"AboutDlg\", \"about\", \"PeerListWidget\", \"StatusFiltersWidget\",\n        \"CategoryFiltersList\", \"TransferListDelegate\"\n    };\n    const size_t context_count = sizeof(contexts) / sizeof(contexts[0]);\n    int i = 0;\n    bool found = true;\n\n    const QString locale = Preferences::instance()->getLocale();\n    bool isTranslationNeeded = !locale.startsWith(\"en\") || locale.startsWith(\"en_AU\") || locale.startsWith(\"en_GB\");\n\n    while(i < data.size() && found) {\n        i = regex.indexIn(data, i);\n        if (i >= 0) {\n            //qDebug(\"Found translatable string: %s\", regex.cap(1).toUtf8().data());\n            QByteArray word = regex.cap(1).toUtf8();\n\n            QString translation = word;\n            if (isTranslationNeeded) {\n                QString context = regex.cap(4);\n                if (context.length() > 0) {\n#ifndef QBT_USES_QT5\n                    translation = qApp->translate(context.toUtf8().constData(), word.constData(), 0, QCoreApplication::UnicodeUTF8, 1);\n#else\n                    translation = qApp->translate(context.toUtf8().constData(), word.constData(), 0, 1);\n#endif\n                }\n                else {\n                    size_t context_index = 0;\n                    while ((context_index < context_count) && (translation == word)) {\n#ifndef QBT_USES_QT5\n                        translation = qApp->translate(contexts[context_index].c_str(), word.constData(), 0, QCoreApplication::UnicodeUTF8, 1);\n#else\n                        translation = qApp->translate(contexts[context_index].c_str(), word.constData(), 0, 1);\n#endif\n                        ++context_index;\n                    }\n                }\n            }\n            // Remove keyboard shortcuts\n            translation.replace(mnemonic, \"\");\n\n            // Use HTML code for quotes to prevent issues with JS\n            translation.replace(\"'\", \"&#39;\");\n            translation.replace(\"\\\"\", \"&#34;\");\n\n            data.replace(i, regex.matchedLength(), translation);\n            i += translation.length();\n        }\n        else {\n            found = false; // no more translatable strings\n        }\n    }\n}\n\nbool AbstractWebApplication::isBanned() const\n{\n    return clientFailedAttempts_.value(env_.clientAddress, 0) >= MAX_AUTH_FAILED_ATTEMPTS;\n}\n\nint AbstractWebApplication::failedAttempts() const\n{\n    return clientFailedAttempts_.value(env_.clientAddress, 0);\n}\n\nvoid AbstractWebApplication::resetFailedAttempts()\n{\n    clientFailedAttempts_.remove(env_.clientAddress);\n}\n\nvoid AbstractWebApplication::increaseFailedAttempts()\n{\n    const int nb_fail = clientFailedAttempts_.value(env_.clientAddress, 0) + 1;\n\n    clientFailedAttempts_[env_.clientAddress] = nb_fail;\n    if (nb_fail == MAX_AUTH_FAILED_ATTEMPTS) {\n        // Max number of failed attempts reached\n        // Start ban period\n        UnbanTimer* ubantimer = new UnbanTimer(env_.clientAddress, this);\n        connect(ubantimer, SIGNAL(timeout()), SLOT(UnbanTimerEvent()));\n        ubantimer->start();\n    }\n}\n\nbool AbstractWebApplication::isAuthNeeded()\n{\n    return (env_.clientAddress != QHostAddress::LocalHost\n            && env_.clientAddress != QHostAddress::LocalHostIPv6\n            && env_.clientAddress != QHostAddress(\"::ffff:127.0.0.1\"))\n            || Preferences::instance()->isWebUiLocalAuthEnabled();\n}\n\nvoid AbstractWebApplication::printFile(const QString& path)\n{\n    QByteArray data;\n    QString type;\n\n    if (!readFile(path, data, type)) {\n        status(404, \"Not Found\");\n        return;\n    }\n\n    print(data, type);\n}\n\nbool AbstractWebApplication::sessionStart()\n{\n    if (session_ == 0) {\n        session_ = new WebSession(generateSid());\n        sessions_[session_->id] = session_;\n\n        QNetworkCookie cookie(C_SID, session_->id.toUtf8());\n        cookie.setPath(QLatin1String(\"/\"));\n        header(Http::HEADER_SET_COOKIE, cookie.toRawForm());\n\n        return true;\n    }\n\n    return false;\n}\n\nbool AbstractWebApplication::sessionEnd()\n{\n    if ((session_ != 0) && (sessions_.contains(session_->id))) {\n        QNetworkCookie cookie(C_SID, session_->id.toUtf8());\n        cookie.setPath(QLatin1String(\"/\"));\n        cookie.setExpirationDate(QDateTime::currentDateTime());\n\n        sessions_.remove(session_->id);\n        delete session_;\n        session_ = 0;\n\n        header(Http::HEADER_SET_COOKIE, cookie.toRawForm());\n        return true;\n    }\n\n    return false;\n}\n\nQString AbstractWebApplication::saveTmpFile(const QByteArray &data)\n{\n    QTemporaryFile tmpfile(Utils::Fs::tempPath() + \"XXXXXX.torrent\");\n    tmpfile.setAutoRemove(false);\n    if (tmpfile.open()) {\n        tmpfile.write(data);\n        tmpfile.close();\n        return tmpfile.fileName();\n    }\n\n    qWarning() << \"I/O Error: Could not create temporary file\";\n    return QString();\n}\n\nQStringMap AbstractWebApplication::initializeContentTypeByExtMap()\n{\n    QStringMap map;\n\n    map[\"htm\"] = Http::CONTENT_TYPE_HTML;\n    map[\"html\"] = Http::CONTENT_TYPE_HTML;\n    map[\"css\"] = Http::CONTENT_TYPE_CSS;\n    map[\"gif\"] = Http::CONTENT_TYPE_GIF;\n    map[\"png\"] = Http::CONTENT_TYPE_PNG;\n    map[\"js\"] = Http::CONTENT_TYPE_JS;\n\n    return map;\n}\n\nconst QStringMap AbstractWebApplication::CONTENT_TYPE_BY_EXT = AbstractWebApplication::initializeContentTypeByExtMap();\n"], "filenames": ["src/base/http/types.h", "src/webui/abstractwebapplication.cpp"], "buggy_code_start_loc": [45, 106], "buggy_code_end_loc": [45, 107], "fixing_code_start_loc": [46, 106], "fixing_code_end_loc": [47, 111], "type": "CWE-20", "message": "WebUI in qBittorrent before 3.3.11 did not set the X-Frame-Options header, which could potentially lead to clickjacking.", "other": {"cve": {"id": "CVE-2017-6504", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-06T02:59:00.823", "lastModified": "2017-03-07T12:39:29.637", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "WebUI in qBittorrent before 3.3.11 did not set the X-Frame-Options header, which could potentially lead to clickjacking."}, {"lang": "es", "value": "Interfaz web en qBittorrent en versiones anteriores a 3.3.11 no estableci\u00f3 el encabezado X-Frame-Options, lo que podr\u00eda conducir potencialmente a secuestro de clic."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:qbittorrent:qbittorrent:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.3.10", "matchCriteriaId": "E5FA12FE-8F2A-4725-A5CB-2D6897FE6A61"}]}]}], "references": [{"url": "https://github.com/qbittorrent/qBittorrent/commit/f5ad04766f4abaa78374ff03704316f8ce04627d", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://www.qbittorrent.org/news.php", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes"]}]}, "github_commit_url": "https://github.com/qbittorrent/qBittorrent/commit/f5ad04766f4abaa78374ff03704316f8ce04627d"}}