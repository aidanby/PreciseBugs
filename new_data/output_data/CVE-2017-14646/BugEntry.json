{"buggy_code": ["/*****************************************************************\n|\n|    AP4 - avcC Atoms \n|\n|    Copyright 2002-2008 Axiomatic Systems, LLC\n|\n|\n|    This file is part of Bento4/AP4 (MP4 Atom Processing Library).\n|\n|    Unless you have obtained Bento4 under a difference license,\n|    this version of Bento4 is Bento4|GPL.\n|    Bento4|GPL is free software; you can redistribute it and/or modify\n|    it under the terms of the GNU General Public License as published by\n|    the Free Software Foundation; either version 2, or (at your option)\n|    any later version.\n|\n|    Bento4|GPL is distributed in the hope that it will be useful,\n|    but WITHOUT ANY WARRANTY; without even the implied warranty of\n|    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n|    GNU General Public License for more details.\n|\n|    You should have received a copy of the GNU General Public License\n|    along with Bento4|GPL; see the file COPYING.  If not, write to the\n|    Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n|    02111-1307, USA.\n|\n****************************************************************/\n\n/*----------------------------------------------------------------------\n|   includes\n+---------------------------------------------------------------------*/\n#include \"Ap4AvccAtom.h\"\n#include \"Ap4AtomFactory.h\"\n#include \"Ap4Utils.h\"\n#include \"Ap4Types.h\"\n\n/*----------------------------------------------------------------------\n|   dynamic cast support\n+---------------------------------------------------------------------*/\nAP4_DEFINE_DYNAMIC_CAST_ANCHOR(AP4_AvccAtom)\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::GetProfileName\n+---------------------------------------------------------------------*/\nconst char*\nAP4_AvccAtom::GetProfileName(AP4_UI08 profile)\n{\n    switch (profile) {\n        case AP4_AVC_PROFILE_BASELINE: return \"Baseline\";   \n        case AP4_AVC_PROFILE_MAIN:     return \"Main\";\n        case AP4_AVC_PROFILE_EXTENDED: return \"Extended\";\n        case AP4_AVC_PROFILE_HIGH:     return \"High\";\n        case AP4_AVC_PROFILE_HIGH_10:  return \"High 10\";\n        case AP4_AVC_PROFILE_HIGH_422: return \"High 4:2:2\";\n        case AP4_AVC_PROFILE_HIGH_444: return \"High 4:4:4\";\n    }\n\n    return NULL;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::Create\n+---------------------------------------------------------------------*/\nAP4_AvccAtom* \nAP4_AvccAtom::Create(AP4_Size size, AP4_ByteStream& stream)\n{\n    // read the raw bytes in a buffer\n    unsigned int payload_size = size-AP4_ATOM_HEADER_SIZE;\n    AP4_DataBuffer payload_data(payload_size);\n    AP4_Result result = stream.Read(payload_data.UseData(), payload_size);\n    if (AP4_FAILED(result)) return NULL;\n    \n    // check the version\n    const AP4_UI08* payload = payload_data.GetData();\n    if (payload[0] != 1) {\n        return NULL;\n    }\n\n    // check the size\n    if (payload_size < 6) return NULL;\n    unsigned int num_seq_params = payload[5]&31;\n    unsigned int cursor = 6;\n    for (unsigned int i=0; i<num_seq_params; i++) {\n        if (cursor+2 > payload_size) return NULL;\n        cursor += 2+AP4_BytesToInt16BE(&payload[cursor]);\n        if (cursor > payload_size) return NULL;\n    }\n    unsigned int num_pic_params = payload[cursor++];\n    if (cursor > payload_size) return NULL;\n    for (unsigned int i=0; i<num_pic_params; i++) {\n        if (cursor+2 > payload_size) return NULL;\n        cursor += 2+AP4_BytesToInt16BE(&payload[cursor]);\n        if (cursor > payload_size) return NULL;\n    }\n    return new AP4_AvccAtom(size, payload);\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::AP4_AvccAtom\n+---------------------------------------------------------------------*/\nAP4_AvccAtom::AP4_AvccAtom() :\n    AP4_Atom(AP4_ATOM_TYPE_AVCC, AP4_ATOM_HEADER_SIZE),\n    m_ConfigurationVersion(1),\n    m_Profile(0),\n    m_Level(0),\n    m_ProfileCompatibility(0),\n    m_NaluLengthSize(0)\n{\n    UpdateRawBytes();\n    m_Size32 += m_RawBytes.GetDataSize();\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::AP4_AvccAtom\n+---------------------------------------------------------------------*/\nAP4_AvccAtom::AP4_AvccAtom(const AP4_AvccAtom& other) :\n    AP4_Atom(AP4_ATOM_TYPE_AVCC, other.m_Size32),\n    m_ConfigurationVersion(other.m_ConfigurationVersion),\n    m_Profile(other.m_Profile),\n    m_Level(other.m_Level),\n    m_ProfileCompatibility(other.m_ProfileCompatibility),\n    m_NaluLengthSize(other.m_NaluLengthSize),\n    m_RawBytes(other.m_RawBytes)\n{\n    // deep copy of the parameters\n    unsigned int i = 0;\n    for (i=0; i<other.m_SequenceParameters.ItemCount(); i++) {\n        m_SequenceParameters.Append(other.m_SequenceParameters[i]);\n    }\n    for (i=0; i<other.m_PictureParameters.ItemCount(); i++) {\n        m_PictureParameters.Append(other.m_PictureParameters[i]);\n    }    \n}\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::AP4_AvccAtom\n+---------------------------------------------------------------------*/\nAP4_AvccAtom::AP4_AvccAtom(AP4_UI32 size, const AP4_UI08* payload) :\n    AP4_Atom(AP4_ATOM_TYPE_AVCC, size)\n{\n    // make a copy of our configuration bytes\n    unsigned int payload_size = size-AP4_ATOM_HEADER_SIZE;\n    m_RawBytes.SetData(payload, payload_size);\n\n    // parse the payload\n    m_ConfigurationVersion = payload[0];\n    m_Profile              = payload[1];\n    m_ProfileCompatibility = payload[2];\n    m_Level                = payload[3];\n    m_NaluLengthSize       = 1+(payload[4]&3);\n    AP4_UI08 num_seq_params = payload[5]&31;\n    m_SequenceParameters.EnsureCapacity(num_seq_params);\n    unsigned int cursor = 6;\n    for (unsigned int i=0; i<num_seq_params; i++) {\n        m_SequenceParameters.Append(AP4_DataBuffer());\n        AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n        m_SequenceParameters[i].SetData(&payload[cursor]+2, param_length);\n        cursor += 2+param_length;\n    }\n    AP4_UI08 num_pic_params = payload[cursor++];\n    m_PictureParameters.EnsureCapacity(num_pic_params);\n    for (unsigned int i=0; i<num_pic_params; i++) {\n        m_PictureParameters.Append(AP4_DataBuffer());\n        AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n        m_PictureParameters[i].SetData(&payload[cursor]+2, param_length);\n        cursor += 2+param_length;\n    }\n}\n\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::AP4_AvccAtom\n+---------------------------------------------------------------------*/\nAP4_AvccAtom::AP4_AvccAtom(AP4_UI08                         profile, \n                           AP4_UI08                         level, \n                           AP4_UI08                         profile_compatibility, \n                           AP4_UI08                         length_size, \n                           const AP4_Array<AP4_DataBuffer>& sequence_parameters, \n                           const AP4_Array<AP4_DataBuffer>& picture_parameters) :\n    AP4_Atom(AP4_ATOM_TYPE_AVCC, AP4_ATOM_HEADER_SIZE),\n    m_ConfigurationVersion(1),\n    m_Profile(profile),\n    m_Level(level),\n    m_ProfileCompatibility(profile_compatibility),\n    m_NaluLengthSize(length_size)\n{\n    // deep copy of the parameters\n    unsigned int i = 0;\n    for (i=0; i<sequence_parameters.ItemCount(); i++) {\n        m_SequenceParameters.Append(sequence_parameters[i]);\n    }\n    for (i=0; i<picture_parameters.ItemCount(); i++) {\n        m_PictureParameters.Append(picture_parameters[i]);\n    }    \n\n    // compute the raw bytes\n    UpdateRawBytes();\n\n    // update the size\n    m_Size32 += m_RawBytes.GetDataSize();\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::UpdateRawBytes\n+---------------------------------------------------------------------*/\nvoid\nAP4_AvccAtom::UpdateRawBytes()\n{\n    // compute the payload size\n    unsigned int payload_size = 6;    \n    for (unsigned int i=0; i<m_SequenceParameters.ItemCount(); i++) {\n        payload_size += 2+m_SequenceParameters[i].GetDataSize();\n    }\n    ++payload_size;\n    for (unsigned int i=0; i<m_PictureParameters.ItemCount(); i++) {\n        payload_size += 2+m_PictureParameters[i].GetDataSize();\n    }\n    m_RawBytes.SetDataSize(payload_size);\n    AP4_UI08* payload = m_RawBytes.UseData();\n\n    payload[0] = m_ConfigurationVersion;\n    payload[1] = m_Profile;\n    payload[2] = m_ProfileCompatibility;\n    payload[3] = m_Level;\n    payload[4] = 0xFC | (m_NaluLengthSize-1);\n    payload[5] = 0xE0 | (AP4_UI08)m_SequenceParameters.ItemCount();\n    unsigned int cursor = 6;\n    for (unsigned int i=0; i<m_SequenceParameters.ItemCount(); i++) {\n        AP4_UI16 param_length = (AP4_UI16)m_SequenceParameters[i].GetDataSize();\n        AP4_BytesFromUInt16BE(&payload[cursor], param_length);\n        cursor += 2;\n        AP4_CopyMemory(&payload[cursor], m_SequenceParameters[i].GetData(), param_length);\n        cursor += param_length;\n    }\n    payload[cursor++] = (AP4_UI08)m_PictureParameters.ItemCount();\n    for (unsigned int i=0; i<m_PictureParameters.ItemCount(); i++) {\n        AP4_UI16 param_length = (AP4_UI16)m_PictureParameters[i].GetDataSize();\n        AP4_BytesFromUInt16BE(&payload[cursor], param_length);\n        cursor += 2;\n        AP4_CopyMemory(&payload[cursor], m_PictureParameters[i].GetData(), param_length);\n        cursor += param_length;\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::WriteFields\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_AvccAtom::WriteFields(AP4_ByteStream& stream)\n{\n    return stream.Write(m_RawBytes.GetData(), m_RawBytes.GetDataSize());\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::InspectFields\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_AvccAtom::InspectFields(AP4_AtomInspector& inspector)\n{\n    inspector.AddField(\"Configuration Version\", m_ConfigurationVersion);\n    const char* profile_name = GetProfileName(m_Profile);\n    if (profile_name) {\n        inspector.AddField(\"Profile\", profile_name);\n    } else {\n        inspector.AddField(\"Profile\", m_Profile);\n    }\n    inspector.AddField(\"Profile Compatibility\", m_ProfileCompatibility, AP4_AtomInspector::HINT_HEX);\n    inspector.AddField(\"Level\", m_Level);\n    inspector.AddField(\"NALU Length Size\", m_NaluLengthSize);\n    for (unsigned int i=0; i<m_SequenceParameters.ItemCount(); i++) {\n        inspector.AddField(\"Sequence Parameter\", m_SequenceParameters[i].GetData(), m_SequenceParameters[i].GetDataSize());\n    }\n    for (unsigned int i=0; i<m_PictureParameters.ItemCount(); i++) {\n        inspector.AddField(\"Picture Parameter\", m_PictureParameters[i].GetData(), m_PictureParameters[i].GetDataSize());\n    }\n    return AP4_SUCCESS;\n}\n", "/*****************************************************************\n|\n|    AP4 - hvcC Atoms\n|\n|    Copyright 2002-2016 Axiomatic Systems, LLC\n|\n|\n|    This file is part of Bento4/AP4 (MP4 Atom Processing Library).\n|\n|    Unless you have obtained Bento4 under a difference license,\n|    this version of Bento4 is Bento4|GPL.\n|    Bento4|GPL is free software; you can redistribute it and/or modify\n|    it under the terms of the GNU General Public License as published by\n|    the Free Software Foundation; either version 2, or (at your option)\n|    any later version.\n|\n|    Bento4|GPL is distributed in the hope that it will be useful,\n|    but WITHOUT ANY WARRANTY; without even the implied warranty of\n|    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n|    GNU General Public License for more details.\n|\n|    You should have received a copy of the GNU General Public License\n|    along with Bento4|GPL; see the file COPYING.  If not, write to the\n|    Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n|    02111-1307, USA.\n|\n****************************************************************/\n\n/*----------------------------------------------------------------------\n|   includes\n+---------------------------------------------------------------------*/\n#include \"Ap4HvccAtom.h\"\n#include \"Ap4AtomFactory.h\"\n#include \"Ap4Utils.h\"\n#include \"Ap4Types.h\"\n#include \"Ap4HevcParser.h\"\n\n/*----------------------------------------------------------------------\n|   dynamic cast support\n+---------------------------------------------------------------------*/\nAP4_DEFINE_DYNAMIC_CAST_ANCHOR(AP4_HvccAtom)\n\n/*----------------------------------------------------------------------\n|   AP4_HvccAtom::GetProfileName\n+---------------------------------------------------------------------*/\nconst char*\nAP4_HvccAtom::GetProfileName(AP4_UI08 profile_space, AP4_UI08 profile)\n{\n    if (profile_space != 0) {\n        return NULL;\n    }\n    switch (profile) {\n        case AP4_HEVC_PROFILE_MAIN:               return \"Main\";\n        case AP4_HEVC_PROFILE_MAIN_10:            return \"Main 10\";\n        case AP4_HEVC_PROFILE_MAIN_STILL_PICTURE: return \"Main Still Picture\";\n        case AP4_HEVC_PROFILE_REXT:               return \"Rext\";\n    }\n\n    return NULL;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_HvccAtom::GetChromaFormatName\n+---------------------------------------------------------------------*/\nconst char*\nAP4_HvccAtom::GetChromaFormatName(AP4_UI08 chroma_format)\n{\n    switch (chroma_format) {\n        case AP4_HEVC_CHROMA_FORMAT_MONOCHROME: return \"Monochrome\";\n        case AP4_HEVC_CHROMA_FORMAT_420:        return \"4:2:0\";\n        case AP4_HEVC_CHROMA_FORMAT_422:        return \"4:2:2\";\n        case AP4_HEVC_CHROMA_FORMAT_444:        return \"4:4:4\";\n    }\n\n    return NULL;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::Create\n+---------------------------------------------------------------------*/\nAP4_HvccAtom*\nAP4_HvccAtom::Create(AP4_Size size, AP4_ByteStream& stream)\n{\n    // read the raw bytes in a buffer\n    unsigned int payload_size = size-AP4_ATOM_HEADER_SIZE;\n    AP4_DataBuffer payload_data(payload_size);\n    AP4_Result result = stream.Read(payload_data.UseData(), payload_size);\n    if (AP4_FAILED(result)) return NULL;\n    \n    return new AP4_HvccAtom(size, payload_data.GetData());\n}\n\n/*----------------------------------------------------------------------\n|   AP4_HvccAtom::AP4_HvccAtom\n+---------------------------------------------------------------------*/\nAP4_HvccAtom::AP4_HvccAtom() :\n    AP4_Atom(AP4_ATOM_TYPE_HVCC, AP4_ATOM_HEADER_SIZE),\n    m_ConfigurationVersion(1),\n    m_GeneralProfileSpace(0),\n    m_GeneralTierFlag(0),\n    m_GeneralProfile(0),\n    m_GeneralProfileCompatibilityFlags(0),\n    m_GeneralConstraintIndicatorFlags(0),\n    m_GeneralLevel(0),\n    m_Reserved1(0),\n    m_MinSpatialSegmentation(0),\n    m_Reserved2(0),\n    m_ParallelismType(0),\n    m_Reserved3(0),\n    m_ChromaFormat(0),\n    m_Reserved4(0),\n    m_LumaBitDepth(8),\n    m_Reserved5(0),\n    m_ChromaBitDepth(8),\n    m_AverageFrameRate(0),\n    m_ConstantFrameRate(0),\n    m_NumTemporalLayers(0),\n    m_TemporalIdNested(0),\n    m_NaluLengthSize(4)\n{\n    UpdateRawBytes();\n    m_Size32 += m_RawBytes.GetDataSize();\n}\n\n/*----------------------------------------------------------------------\n|   AP4_HvccAtom::AP4_HvccAtom\n+---------------------------------------------------------------------*/\nAP4_HvccAtom::AP4_HvccAtom(const AP4_HvccAtom& other) :\n    AP4_Atom(AP4_ATOM_TYPE_HVCC, other.m_Size32),\n    m_ConfigurationVersion(other.m_ConfigurationVersion),\n    m_GeneralProfileSpace(other.m_GeneralProfileSpace),\n    m_GeneralTierFlag(other.m_GeneralTierFlag),\n    m_GeneralProfile(other.m_GeneralProfile),\n    m_GeneralProfileCompatibilityFlags(other.m_GeneralProfileCompatibilityFlags),\n    m_GeneralConstraintIndicatorFlags(other.m_GeneralConstraintIndicatorFlags),\n    m_GeneralLevel(other.m_GeneralLevel),\n    m_Reserved1(other.m_Reserved1),\n    m_MinSpatialSegmentation(other.m_MinSpatialSegmentation),\n    m_Reserved2(other.m_Reserved2),\n    m_ParallelismType(other.m_ParallelismType),\n    m_Reserved3(other.m_Reserved3),\n    m_ChromaFormat(other.m_ChromaFormat),\n    m_Reserved4(other.m_Reserved4),\n    m_LumaBitDepth(other.m_LumaBitDepth),\n    m_Reserved5(other.m_Reserved5),\n    m_ChromaBitDepth(other.m_ChromaBitDepth),\n    m_AverageFrameRate(other.m_AverageFrameRate),\n    m_ConstantFrameRate(other.m_ConstantFrameRate),\n    m_NumTemporalLayers(other.m_NumTemporalLayers),\n    m_TemporalIdNested(other.m_TemporalIdNested),\n    m_NaluLengthSize(other.m_NaluLengthSize),\n    m_RawBytes(other.m_RawBytes)\n{\n    // deep copy of the parameters\n    unsigned int i = 0;\n    for (i=0; i<other.m_Sequences.ItemCount(); i++) {\n        m_Sequences.Append(other.m_Sequences[i]);\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_HvccAtom::AP4_HvccAtom\n+---------------------------------------------------------------------*/\nAP4_HvccAtom::AP4_HvccAtom(AP4_UI08                         general_profile_space,\n                           AP4_UI08                         general_tier_flag,\n                           AP4_UI08                         general_profile,\n                           AP4_UI32                         general_profile_compatibility_flags,\n                           AP4_UI64                         general_constraint_indicator_flags,\n                           AP4_UI08                         general_level,\n                           AP4_UI32                         min_spatial_segmentation,\n                           AP4_UI08                         parallelism_type,\n                           AP4_UI08                         chroma_format,\n                           AP4_UI08                         luma_bit_depth,\n                           AP4_UI08                         chroma_bit_depth,\n                           AP4_UI16                         average_frame_rate,\n                           AP4_UI08                         constant_frame_rate,\n                           AP4_UI08                         num_temporal_layers,\n                           AP4_UI08                         temporal_id_nested,\n                           AP4_UI08                         nalu_length_size,\n                           const AP4_Array<AP4_DataBuffer>& video_parameters,\n                           const AP4_Array<AP4_DataBuffer>& sequence_parameters,\n                           const AP4_Array<AP4_DataBuffer>& picture_parameters) :\n    AP4_Atom(AP4_ATOM_TYPE_HVCC, AP4_ATOM_HEADER_SIZE),\n    m_ConfigurationVersion(1),\n    m_GeneralProfileSpace(general_profile_space),\n    m_GeneralTierFlag(general_tier_flag),\n    m_GeneralProfile(general_profile),\n    m_GeneralProfileCompatibilityFlags(general_profile_compatibility_flags),\n    m_GeneralConstraintIndicatorFlags(general_constraint_indicator_flags),\n    m_GeneralLevel(general_level),\n    m_Reserved1(0),\n    m_MinSpatialSegmentation(min_spatial_segmentation),\n    m_Reserved2(0),\n    m_ParallelismType(parallelism_type),\n    m_Reserved3(0),\n    m_ChromaFormat(chroma_format),\n    m_Reserved4(0),\n    m_LumaBitDepth(luma_bit_depth),\n    m_Reserved5(0),\n    m_ChromaBitDepth(chroma_bit_depth),\n    m_AverageFrameRate(average_frame_rate),\n    m_ConstantFrameRate(constant_frame_rate),\n    m_NumTemporalLayers(num_temporal_layers),\n    m_TemporalIdNested(temporal_id_nested),\n    m_NaluLengthSize(nalu_length_size)\n{\n    // deep copy of the parameters\n    AP4_HvccAtom::Sequence vps_sequence;\n    vps_sequence.m_NaluType = AP4_HEVC_NALU_TYPE_VPS_NUT;\n    vps_sequence.m_ArrayCompleteness = 0;\n    for (unsigned int i=0; i<video_parameters.ItemCount(); i++) {\n        vps_sequence.m_Nalus.Append(video_parameters[i]);\n    }\n    if (vps_sequence.m_Nalus.ItemCount()) {\n        m_Sequences.Append(vps_sequence);\n    }\n    \n    AP4_HvccAtom::Sequence sps_sequence;\n    sps_sequence.m_NaluType = AP4_HEVC_NALU_TYPE_SPS_NUT;\n    sps_sequence.m_ArrayCompleteness = 0;\n    for (unsigned int i=0; i<sequence_parameters.ItemCount(); i++) {\n        sps_sequence.m_Nalus.Append(sequence_parameters[i]);\n    }\n    if (sps_sequence.m_Nalus.ItemCount()) {\n        m_Sequences.Append(sps_sequence);\n    }\n\n    AP4_HvccAtom::Sequence pps_sequence;\n    pps_sequence.m_NaluType = AP4_HEVC_NALU_TYPE_PPS_NUT;\n    pps_sequence.m_ArrayCompleteness = 0;\n    for (unsigned int i=0; i<picture_parameters.ItemCount(); i++) {\n        pps_sequence.m_Nalus.Append(picture_parameters[i]);\n    }\n    if (pps_sequence.m_Nalus.ItemCount()) {\n        m_Sequences.Append(pps_sequence);\n    }\n    \n    UpdateRawBytes();\n    m_Size32 += m_RawBytes.GetDataSize();\n}\n\n/*----------------------------------------------------------------------\n|   AP4_HvccAtom::AP4_HvccAtom\n+---------------------------------------------------------------------*/\nAP4_HvccAtom::AP4_HvccAtom(AP4_UI32 size, const AP4_UI08* payload) :\n    AP4_Atom(AP4_ATOM_TYPE_HVCC, size)\n{\n    // make a copy of our configuration bytes\n    unsigned int payload_size = size-AP4_ATOM_HEADER_SIZE;\n    m_RawBytes.SetData(payload, payload_size);\n\n    // parse the payload\n    m_ConfigurationVersion   = payload[0];\n    m_GeneralProfileSpace    = (payload[1]>>6) & 0x03;\n    m_GeneralTierFlag        = (payload[1]>>5) & 0x01;\n    m_GeneralProfile         = (payload[1]   ) & 0x1F;\n    m_GeneralProfileCompatibilityFlags = AP4_BytesToUInt32BE(&payload[2]);\n    m_GeneralConstraintIndicatorFlags  = (((AP4_UI64)AP4_BytesToUInt32BE(&payload[6]))<<16) | AP4_BytesToUInt16BE(&payload[10]);\n    m_GeneralLevel           = payload[12];\n    m_Reserved1              = (payload[13]>>4) & 0x0F;\n    m_MinSpatialSegmentation = AP4_BytesToUInt16BE(&payload[13]) & 0x0FFF;\n    m_Reserved2              = (payload[15]>>2) & 0x3F;\n    m_ParallelismType        = payload[15] & 0x03;\n    m_Reserved3              = (payload[16]>>2) & 0x3F;\n    m_ChromaFormat           = payload[16] & 0x03;\n    m_Reserved4              = (payload[17]>>3) & 0x1F;\n    m_LumaBitDepth           = 8+(payload[17] & 0x07);\n    m_Reserved5              = (payload[18]>>3) & 0x1F;\n    m_ChromaBitDepth         = 8+(payload[18] & 0x07);\n    m_AverageFrameRate       = AP4_BytesToUInt16BE(&payload[19]);\n    m_ConstantFrameRate      = (payload[21]>>6) & 0x03;\n    m_NumTemporalLayers      = (payload[21]>>3) & 0x07;\n    m_TemporalIdNested       = (payload[21]>>2) & 0x01;\n    m_NaluLengthSize         = 1+(payload[21] & 0x03);\n    \n    AP4_UI08 num_seq = payload[22];\n    m_Sequences.SetItemCount(num_seq);\n    unsigned int cursor = 23;\n    for (unsigned int i=0; i<num_seq; i++) {\n\n        Sequence& seq = m_Sequences[i];\n        if (cursor+1 > payload_size) break;\n        seq.m_ArrayCompleteness = (payload[cursor] >> 7) & 0x01;\n        seq.m_Reserved          = (payload[cursor] >> 6) & 0x01;\n        seq.m_NaluType          = payload[cursor] & 0x3F;\n        cursor += 1;\n        \n        if (cursor+2 > payload_size) break;\n        AP4_UI16 nalu_count = AP4_BytesToUInt16BE(&payload[cursor]);\n        seq.m_Nalus.SetItemCount(nalu_count);\n        cursor += 2;\n        \n        for (unsigned int j=0; j<nalu_count; j++) {\n            if (cursor+2 > payload_size) break;\n            unsigned int nalu_length = AP4_BytesToUInt16BE(&payload[cursor]);\n            cursor += 2;\n            if (cursor + nalu_length > payload_size) break;\n            seq.m_Nalus[j].SetData(&payload[cursor], nalu_length);\n            cursor += nalu_length;\n        }\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_HvccAtom::UpdateRawBytes\n+---------------------------------------------------------------------*/\nvoid\nAP4_HvccAtom::UpdateRawBytes()\n{\n    AP4_BitWriter bits(23);\n    bits.Write(m_ConfigurationVersion, 8);\n    bits.Write(m_GeneralProfileSpace, 2);\n    bits.Write(m_GeneralTierFlag, 1);\n    bits.Write(m_GeneralProfile, 5);\n    bits.Write(m_GeneralProfileCompatibilityFlags, 32);\n    bits.Write((AP4_UI32)(m_GeneralConstraintIndicatorFlags>>32), 16);\n    bits.Write((AP4_UI32)(m_GeneralConstraintIndicatorFlags), 32);\n    bits.Write(m_GeneralLevel, 8);\n    bits.Write(0xFF, 4);\n    bits.Write(m_MinSpatialSegmentation, 12);\n    bits.Write(0xFF, 6);\n    bits.Write(m_ParallelismType, 2);\n    bits.Write(0xFF, 6);\n    bits.Write(m_ChromaFormat, 2);\n    bits.Write(0xFF, 5);\n    bits.Write(m_LumaBitDepth >= 8 ? m_LumaBitDepth - 8 : 0, 3);\n    bits.Write(0xFF, 5);\n    bits.Write(m_ChromaBitDepth >= 8 ? m_ChromaBitDepth - 8 : 0, 3);\n    bits.Write(m_AverageFrameRate, 16);\n    bits.Write(m_ConstantFrameRate, 2);\n    bits.Write(m_NumTemporalLayers, 3);\n    bits.Write(m_TemporalIdNested, 1);\n    bits.Write(m_NaluLengthSize > 0 ? m_NaluLengthSize - 1 : 0, 2);\n    bits.Write(m_Sequences.ItemCount(), 8);\n    \n    m_RawBytes.SetData(bits.GetData(), 23);\n\n    for (unsigned int i=0; i<m_Sequences.ItemCount(); i++) {\n        AP4_UI08 bytes[3];\n        bytes[0] = (m_Sequences[i].m_ArrayCompleteness ? (1<<7) : 0) | m_Sequences[i].m_NaluType;\n        AP4_BytesFromUInt16BE(&bytes[1], m_Sequences[i].m_Nalus.ItemCount());\n        m_RawBytes.AppendData(bytes, 3);\n        \n        for (unsigned int j=0; j<m_Sequences[i].m_Nalus.ItemCount(); j++) {\n            AP4_UI08 size[2];\n            AP4_BytesFromUInt16BE(&size[0], (AP4_UI16)m_Sequences[i].m_Nalus[j].GetDataSize());\n            m_RawBytes.AppendData(size, 2);\n            m_RawBytes.AppendData(m_Sequences[i].m_Nalus[j].GetData(), m_Sequences[i].m_Nalus[j].GetDataSize());\n        }\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_HvccAtom::WriteFields\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_HvccAtom::WriteFields(AP4_ByteStream& stream)\n{\n    return stream.Write(m_RawBytes.GetData(), m_RawBytes.GetDataSize());\n}\n\n/*----------------------------------------------------------------------\n|   AP4_HvccAtom::InspectFields\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_HvccAtom::InspectFields(AP4_AtomInspector& inspector)\n{\n    inspector.AddField(\"Configuration Version\", m_ConfigurationVersion);\n    inspector.AddField(\"Profile Space\", m_GeneralProfileSpace);\n    const char* profile_name = GetProfileName(m_GeneralProfileSpace, m_GeneralProfile);\n    if (profile_name) {\n        inspector.AddField(\"Profile\", profile_name);\n    } else {\n        inspector.AddField(\"Profile\", m_GeneralProfile);\n    }\n    inspector.AddField(\"Tier\", m_GeneralTierFlag);\n    inspector.AddField(\"Profile Compatibility\", m_GeneralProfileCompatibilityFlags, AP4_AtomInspector::HINT_HEX);\n    inspector.AddField(\"Constraint\", m_GeneralConstraintIndicatorFlags, AP4_AtomInspector::HINT_HEX);\n    inspector.AddField(\"Level\", m_GeneralLevel);\n    inspector.AddField(\"Min Spatial Segmentation\", m_MinSpatialSegmentation);\n    inspector.AddField(\"Parallelism Type\", m_ParallelismType);\n    inspector.AddField(\"Chroma Format\", m_ChromaFormat);\n    inspector.AddField(\"Chroma Depth\", m_ChromaBitDepth);\n    inspector.AddField(\"Luma Depth\", m_LumaBitDepth);\n    inspector.AddField(\"Average Frame Rate\", m_AverageFrameRate);\n    inspector.AddField(\"Constant Frame Rate\", m_ConstantFrameRate);\n    inspector.AddField(\"Number Of Temporal Layers\", m_NumTemporalLayers);\n    inspector.AddField(\"Temporal Id Nested\", m_TemporalIdNested);\n    inspector.AddField(\"NALU Length Size\", m_NaluLengthSize);\n    return AP4_SUCCESS;\n}\n"], "fixing_code": ["/*****************************************************************\n|\n|    AP4 - avcC Atoms \n|\n|    Copyright 2002-2008 Axiomatic Systems, LLC\n|\n|\n|    This file is part of Bento4/AP4 (MP4 Atom Processing Library).\n|\n|    Unless you have obtained Bento4 under a difference license,\n|    this version of Bento4 is Bento4|GPL.\n|    Bento4|GPL is free software; you can redistribute it and/or modify\n|    it under the terms of the GNU General Public License as published by\n|    the Free Software Foundation; either version 2, or (at your option)\n|    any later version.\n|\n|    Bento4|GPL is distributed in the hope that it will be useful,\n|    but WITHOUT ANY WARRANTY; without even the implied warranty of\n|    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n|    GNU General Public License for more details.\n|\n|    You should have received a copy of the GNU General Public License\n|    along with Bento4|GPL; see the file COPYING.  If not, write to the\n|    Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n|    02111-1307, USA.\n|\n****************************************************************/\n\n/*----------------------------------------------------------------------\n|   includes\n+---------------------------------------------------------------------*/\n#include \"Ap4AvccAtom.h\"\n#include \"Ap4AtomFactory.h\"\n#include \"Ap4Utils.h\"\n#include \"Ap4Types.h\"\n\n/*----------------------------------------------------------------------\n|   dynamic cast support\n+---------------------------------------------------------------------*/\nAP4_DEFINE_DYNAMIC_CAST_ANCHOR(AP4_AvccAtom)\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::GetProfileName\n+---------------------------------------------------------------------*/\nconst char*\nAP4_AvccAtom::GetProfileName(AP4_UI08 profile)\n{\n    switch (profile) {\n        case AP4_AVC_PROFILE_BASELINE: return \"Baseline\";   \n        case AP4_AVC_PROFILE_MAIN:     return \"Main\";\n        case AP4_AVC_PROFILE_EXTENDED: return \"Extended\";\n        case AP4_AVC_PROFILE_HIGH:     return \"High\";\n        case AP4_AVC_PROFILE_HIGH_10:  return \"High 10\";\n        case AP4_AVC_PROFILE_HIGH_422: return \"High 4:2:2\";\n        case AP4_AVC_PROFILE_HIGH_444: return \"High 4:4:4\";\n    }\n\n    return NULL;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::Create\n+---------------------------------------------------------------------*/\nAP4_AvccAtom* \nAP4_AvccAtom::Create(AP4_Size size, AP4_ByteStream& stream)\n{\n    // read the raw bytes in a buffer\n    unsigned int payload_size = size-AP4_ATOM_HEADER_SIZE;\n    AP4_DataBuffer payload_data(payload_size);\n    AP4_Result result = stream.Read(payload_data.UseData(), payload_size);\n    if (AP4_FAILED(result)) return NULL;\n    \n    // check the version\n    const AP4_UI08* payload = payload_data.GetData();\n    if (payload[0] != 1) {\n        return NULL;\n    }\n\n    // check the size\n    if (payload_size < 6) return NULL;\n    unsigned int num_seq_params = payload[5]&31;\n    unsigned int cursor = 6;\n    for (unsigned int i=0; i<num_seq_params; i++) {\n        if (cursor+2 > payload_size) return NULL;\n        cursor += 2+AP4_BytesToInt16BE(&payload[cursor]);\n        if (cursor > payload_size) return NULL;\n    }\n    unsigned int num_pic_params = payload[cursor++];\n    if (cursor > payload_size) return NULL;\n    for (unsigned int i=0; i<num_pic_params; i++) {\n        if (cursor+2 > payload_size) return NULL;\n        cursor += 2+AP4_BytesToInt16BE(&payload[cursor]);\n        if (cursor > payload_size) return NULL;\n    }\n    return new AP4_AvccAtom(size, payload);\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::AP4_AvccAtom\n+---------------------------------------------------------------------*/\nAP4_AvccAtom::AP4_AvccAtom() :\n    AP4_Atom(AP4_ATOM_TYPE_AVCC, AP4_ATOM_HEADER_SIZE),\n    m_ConfigurationVersion(1),\n    m_Profile(0),\n    m_Level(0),\n    m_ProfileCompatibility(0),\n    m_NaluLengthSize(0)\n{\n    UpdateRawBytes();\n    m_Size32 += m_RawBytes.GetDataSize();\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::AP4_AvccAtom\n+---------------------------------------------------------------------*/\nAP4_AvccAtom::AP4_AvccAtom(const AP4_AvccAtom& other) :\n    AP4_Atom(AP4_ATOM_TYPE_AVCC, other.m_Size32),\n    m_ConfigurationVersion(other.m_ConfigurationVersion),\n    m_Profile(other.m_Profile),\n    m_Level(other.m_Level),\n    m_ProfileCompatibility(other.m_ProfileCompatibility),\n    m_NaluLengthSize(other.m_NaluLengthSize),\n    m_RawBytes(other.m_RawBytes)\n{\n    // deep copy of the parameters\n    unsigned int i = 0;\n    for (i=0; i<other.m_SequenceParameters.ItemCount(); i++) {\n        m_SequenceParameters.Append(other.m_SequenceParameters[i]);\n    }\n    for (i=0; i<other.m_PictureParameters.ItemCount(); i++) {\n        m_PictureParameters.Append(other.m_PictureParameters[i]);\n    }    \n}\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::AP4_AvccAtom\n+---------------------------------------------------------------------*/\nAP4_AvccAtom::AP4_AvccAtom(AP4_UI32 size, const AP4_UI08* payload) :\n    AP4_Atom(AP4_ATOM_TYPE_AVCC, size)\n{\n    // make a copy of our configuration bytes\n    unsigned int payload_size = size-AP4_ATOM_HEADER_SIZE;\n    m_RawBytes.SetData(payload, payload_size);\n\n    // parse the payload\n    m_ConfigurationVersion = payload[0];\n    m_Profile              = payload[1];\n    m_ProfileCompatibility = payload[2];\n    m_Level                = payload[3];\n    m_NaluLengthSize       = 1+(payload[4]&3);\n    AP4_UI08 num_seq_params = payload[5]&31;\n    m_SequenceParameters.EnsureCapacity(num_seq_params);\n    unsigned int cursor = 6;\n    for (unsigned int i=0; i<num_seq_params; i++) {\n        if (cursor+2 <= payload_size) {\n            AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n            cursor += 2;\n            if (cursor + param_length < payload_size) {\n                m_SequenceParameters.Append(AP4_DataBuffer());\n                m_SequenceParameters[i].SetData(&payload[cursor], param_length);\n                cursor += param_length;\n            }\n        }\n    }\n    AP4_UI08 num_pic_params = payload[cursor++];\n    m_PictureParameters.EnsureCapacity(num_pic_params);\n    for (unsigned int i=0; i<num_pic_params; i++) {\n        if (cursor+2 <= payload_size) {\n            AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n            cursor += 2;\n            if (cursor + param_length < payload_size) {\n                m_PictureParameters.Append(AP4_DataBuffer());\n                m_PictureParameters[i].SetData(&payload[cursor], param_length);\n                cursor += param_length;\n            }\n        }\n    }\n}\n\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::AP4_AvccAtom\n+---------------------------------------------------------------------*/\nAP4_AvccAtom::AP4_AvccAtom(AP4_UI08                         profile, \n                           AP4_UI08                         level, \n                           AP4_UI08                         profile_compatibility, \n                           AP4_UI08                         length_size, \n                           const AP4_Array<AP4_DataBuffer>& sequence_parameters, \n                           const AP4_Array<AP4_DataBuffer>& picture_parameters) :\n    AP4_Atom(AP4_ATOM_TYPE_AVCC, AP4_ATOM_HEADER_SIZE),\n    m_ConfigurationVersion(1),\n    m_Profile(profile),\n    m_Level(level),\n    m_ProfileCompatibility(profile_compatibility),\n    m_NaluLengthSize(length_size)\n{\n    // deep copy of the parameters\n    unsigned int i = 0;\n    for (i=0; i<sequence_parameters.ItemCount(); i++) {\n        m_SequenceParameters.Append(sequence_parameters[i]);\n    }\n    for (i=0; i<picture_parameters.ItemCount(); i++) {\n        m_PictureParameters.Append(picture_parameters[i]);\n    }    \n\n    // compute the raw bytes\n    UpdateRawBytes();\n\n    // update the size\n    m_Size32 += m_RawBytes.GetDataSize();\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::UpdateRawBytes\n+---------------------------------------------------------------------*/\nvoid\nAP4_AvccAtom::UpdateRawBytes()\n{\n    // compute the payload size\n    unsigned int payload_size = 6;    \n    for (unsigned int i=0; i<m_SequenceParameters.ItemCount(); i++) {\n        payload_size += 2+m_SequenceParameters[i].GetDataSize();\n    }\n    ++payload_size;\n    for (unsigned int i=0; i<m_PictureParameters.ItemCount(); i++) {\n        payload_size += 2+m_PictureParameters[i].GetDataSize();\n    }\n    m_RawBytes.SetDataSize(payload_size);\n    AP4_UI08* payload = m_RawBytes.UseData();\n\n    payload[0] = m_ConfigurationVersion;\n    payload[1] = m_Profile;\n    payload[2] = m_ProfileCompatibility;\n    payload[3] = m_Level;\n    payload[4] = 0xFC | (m_NaluLengthSize-1);\n    payload[5] = 0xE0 | (AP4_UI08)m_SequenceParameters.ItemCount();\n    unsigned int cursor = 6;\n    for (unsigned int i=0; i<m_SequenceParameters.ItemCount(); i++) {\n        AP4_UI16 param_length = (AP4_UI16)m_SequenceParameters[i].GetDataSize();\n        AP4_BytesFromUInt16BE(&payload[cursor], param_length);\n        cursor += 2;\n        AP4_CopyMemory(&payload[cursor], m_SequenceParameters[i].GetData(), param_length);\n        cursor += param_length;\n    }\n    payload[cursor++] = (AP4_UI08)m_PictureParameters.ItemCount();\n    for (unsigned int i=0; i<m_PictureParameters.ItemCount(); i++) {\n        AP4_UI16 param_length = (AP4_UI16)m_PictureParameters[i].GetDataSize();\n        AP4_BytesFromUInt16BE(&payload[cursor], param_length);\n        cursor += 2;\n        AP4_CopyMemory(&payload[cursor], m_PictureParameters[i].GetData(), param_length);\n        cursor += param_length;\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::WriteFields\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_AvccAtom::WriteFields(AP4_ByteStream& stream)\n{\n    return stream.Write(m_RawBytes.GetData(), m_RawBytes.GetDataSize());\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::InspectFields\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_AvccAtom::InspectFields(AP4_AtomInspector& inspector)\n{\n    inspector.AddField(\"Configuration Version\", m_ConfigurationVersion);\n    const char* profile_name = GetProfileName(m_Profile);\n    if (profile_name) {\n        inspector.AddField(\"Profile\", profile_name);\n    } else {\n        inspector.AddField(\"Profile\", m_Profile);\n    }\n    inspector.AddField(\"Profile Compatibility\", m_ProfileCompatibility, AP4_AtomInspector::HINT_HEX);\n    inspector.AddField(\"Level\", m_Level);\n    inspector.AddField(\"NALU Length Size\", m_NaluLengthSize);\n    for (unsigned int i=0; i<m_SequenceParameters.ItemCount(); i++) {\n        inspector.AddField(\"Sequence Parameter\", m_SequenceParameters[i].GetData(), m_SequenceParameters[i].GetDataSize());\n    }\n    for (unsigned int i=0; i<m_PictureParameters.ItemCount(); i++) {\n        inspector.AddField(\"Picture Parameter\", m_PictureParameters[i].GetData(), m_PictureParameters[i].GetDataSize());\n    }\n    return AP4_SUCCESS;\n}\n", "/*****************************************************************\n|\n|    AP4 - hvcC Atoms\n|\n|    Copyright 2002-2016 Axiomatic Systems, LLC\n|\n|\n|    This file is part of Bento4/AP4 (MP4 Atom Processing Library).\n|\n|    Unless you have obtained Bento4 under a difference license,\n|    this version of Bento4 is Bento4|GPL.\n|    Bento4|GPL is free software; you can redistribute it and/or modify\n|    it under the terms of the GNU General Public License as published by\n|    the Free Software Foundation; either version 2, or (at your option)\n|    any later version.\n|\n|    Bento4|GPL is distributed in the hope that it will be useful,\n|    but WITHOUT ANY WARRANTY; without even the implied warranty of\n|    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n|    GNU General Public License for more details.\n|\n|    You should have received a copy of the GNU General Public License\n|    along with Bento4|GPL; see the file COPYING.  If not, write to the\n|    Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n|    02111-1307, USA.\n|\n****************************************************************/\n\n/*----------------------------------------------------------------------\n|   includes\n+---------------------------------------------------------------------*/\n#include \"Ap4HvccAtom.h\"\n#include \"Ap4AtomFactory.h\"\n#include \"Ap4Utils.h\"\n#include \"Ap4Types.h\"\n#include \"Ap4HevcParser.h\"\n\n/*----------------------------------------------------------------------\n|   dynamic cast support\n+---------------------------------------------------------------------*/\nAP4_DEFINE_DYNAMIC_CAST_ANCHOR(AP4_HvccAtom)\n\n/*----------------------------------------------------------------------\n|   AP4_HvccAtom::GetProfileName\n+---------------------------------------------------------------------*/\nconst char*\nAP4_HvccAtom::GetProfileName(AP4_UI08 profile_space, AP4_UI08 profile)\n{\n    if (profile_space != 0) {\n        return NULL;\n    }\n    switch (profile) {\n        case AP4_HEVC_PROFILE_MAIN:               return \"Main\";\n        case AP4_HEVC_PROFILE_MAIN_10:            return \"Main 10\";\n        case AP4_HEVC_PROFILE_MAIN_STILL_PICTURE: return \"Main Still Picture\";\n        case AP4_HEVC_PROFILE_REXT:               return \"Rext\";\n    }\n\n    return NULL;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_HvccAtom::GetChromaFormatName\n+---------------------------------------------------------------------*/\nconst char*\nAP4_HvccAtom::GetChromaFormatName(AP4_UI08 chroma_format)\n{\n    switch (chroma_format) {\n        case AP4_HEVC_CHROMA_FORMAT_MONOCHROME: return \"Monochrome\";\n        case AP4_HEVC_CHROMA_FORMAT_420:        return \"4:2:0\";\n        case AP4_HEVC_CHROMA_FORMAT_422:        return \"4:2:2\";\n        case AP4_HEVC_CHROMA_FORMAT_444:        return \"4:4:4\";\n    }\n\n    return NULL;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AvccAtom::Create\n+---------------------------------------------------------------------*/\nAP4_HvccAtom*\nAP4_HvccAtom::Create(AP4_Size size, AP4_ByteStream& stream)\n{\n    // read the raw bytes in a buffer\n    unsigned int payload_size = size-AP4_ATOM_HEADER_SIZE;\n    AP4_DataBuffer payload_data(payload_size);\n    AP4_Result result = stream.Read(payload_data.UseData(), payload_size);\n    if (AP4_FAILED(result)) return NULL;\n    \n    return new AP4_HvccAtom(size, payload_data.GetData());\n}\n\n/*----------------------------------------------------------------------\n|   AP4_HvccAtom::AP4_HvccAtom\n+---------------------------------------------------------------------*/\nAP4_HvccAtom::AP4_HvccAtom() :\n    AP4_Atom(AP4_ATOM_TYPE_HVCC, AP4_ATOM_HEADER_SIZE),\n    m_ConfigurationVersion(1),\n    m_GeneralProfileSpace(0),\n    m_GeneralTierFlag(0),\n    m_GeneralProfile(0),\n    m_GeneralProfileCompatibilityFlags(0),\n    m_GeneralConstraintIndicatorFlags(0),\n    m_GeneralLevel(0),\n    m_Reserved1(0),\n    m_MinSpatialSegmentation(0),\n    m_Reserved2(0),\n    m_ParallelismType(0),\n    m_Reserved3(0),\n    m_ChromaFormat(0),\n    m_Reserved4(0),\n    m_LumaBitDepth(8),\n    m_Reserved5(0),\n    m_ChromaBitDepth(8),\n    m_AverageFrameRate(0),\n    m_ConstantFrameRate(0),\n    m_NumTemporalLayers(0),\n    m_TemporalIdNested(0),\n    m_NaluLengthSize(4)\n{\n    UpdateRawBytes();\n    m_Size32 += m_RawBytes.GetDataSize();\n}\n\n/*----------------------------------------------------------------------\n|   AP4_HvccAtom::AP4_HvccAtom\n+---------------------------------------------------------------------*/\nAP4_HvccAtom::AP4_HvccAtom(const AP4_HvccAtom& other) :\n    AP4_Atom(AP4_ATOM_TYPE_HVCC, other.m_Size32),\n    m_ConfigurationVersion(other.m_ConfigurationVersion),\n    m_GeneralProfileSpace(other.m_GeneralProfileSpace),\n    m_GeneralTierFlag(other.m_GeneralTierFlag),\n    m_GeneralProfile(other.m_GeneralProfile),\n    m_GeneralProfileCompatibilityFlags(other.m_GeneralProfileCompatibilityFlags),\n    m_GeneralConstraintIndicatorFlags(other.m_GeneralConstraintIndicatorFlags),\n    m_GeneralLevel(other.m_GeneralLevel),\n    m_Reserved1(other.m_Reserved1),\n    m_MinSpatialSegmentation(other.m_MinSpatialSegmentation),\n    m_Reserved2(other.m_Reserved2),\n    m_ParallelismType(other.m_ParallelismType),\n    m_Reserved3(other.m_Reserved3),\n    m_ChromaFormat(other.m_ChromaFormat),\n    m_Reserved4(other.m_Reserved4),\n    m_LumaBitDepth(other.m_LumaBitDepth),\n    m_Reserved5(other.m_Reserved5),\n    m_ChromaBitDepth(other.m_ChromaBitDepth),\n    m_AverageFrameRate(other.m_AverageFrameRate),\n    m_ConstantFrameRate(other.m_ConstantFrameRate),\n    m_NumTemporalLayers(other.m_NumTemporalLayers),\n    m_TemporalIdNested(other.m_TemporalIdNested),\n    m_NaluLengthSize(other.m_NaluLengthSize),\n    m_RawBytes(other.m_RawBytes)\n{\n    // deep copy of the parameters\n    unsigned int i = 0;\n    for (i=0; i<other.m_Sequences.ItemCount(); i++) {\n        m_Sequences.Append(other.m_Sequences[i]);\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_HvccAtom::AP4_HvccAtom\n+---------------------------------------------------------------------*/\nAP4_HvccAtom::AP4_HvccAtom(AP4_UI08                         general_profile_space,\n                           AP4_UI08                         general_tier_flag,\n                           AP4_UI08                         general_profile,\n                           AP4_UI32                         general_profile_compatibility_flags,\n                           AP4_UI64                         general_constraint_indicator_flags,\n                           AP4_UI08                         general_level,\n                           AP4_UI32                         min_spatial_segmentation,\n                           AP4_UI08                         parallelism_type,\n                           AP4_UI08                         chroma_format,\n                           AP4_UI08                         luma_bit_depth,\n                           AP4_UI08                         chroma_bit_depth,\n                           AP4_UI16                         average_frame_rate,\n                           AP4_UI08                         constant_frame_rate,\n                           AP4_UI08                         num_temporal_layers,\n                           AP4_UI08                         temporal_id_nested,\n                           AP4_UI08                         nalu_length_size,\n                           const AP4_Array<AP4_DataBuffer>& video_parameters,\n                           const AP4_Array<AP4_DataBuffer>& sequence_parameters,\n                           const AP4_Array<AP4_DataBuffer>& picture_parameters) :\n    AP4_Atom(AP4_ATOM_TYPE_HVCC, AP4_ATOM_HEADER_SIZE),\n    m_ConfigurationVersion(1),\n    m_GeneralProfileSpace(general_profile_space),\n    m_GeneralTierFlag(general_tier_flag),\n    m_GeneralProfile(general_profile),\n    m_GeneralProfileCompatibilityFlags(general_profile_compatibility_flags),\n    m_GeneralConstraintIndicatorFlags(general_constraint_indicator_flags),\n    m_GeneralLevel(general_level),\n    m_Reserved1(0),\n    m_MinSpatialSegmentation(min_spatial_segmentation),\n    m_Reserved2(0),\n    m_ParallelismType(parallelism_type),\n    m_Reserved3(0),\n    m_ChromaFormat(chroma_format),\n    m_Reserved4(0),\n    m_LumaBitDepth(luma_bit_depth),\n    m_Reserved5(0),\n    m_ChromaBitDepth(chroma_bit_depth),\n    m_AverageFrameRate(average_frame_rate),\n    m_ConstantFrameRate(constant_frame_rate),\n    m_NumTemporalLayers(num_temporal_layers),\n    m_TemporalIdNested(temporal_id_nested),\n    m_NaluLengthSize(nalu_length_size)\n{\n    // deep copy of the parameters\n    AP4_HvccAtom::Sequence vps_sequence;\n    vps_sequence.m_NaluType = AP4_HEVC_NALU_TYPE_VPS_NUT;\n    vps_sequence.m_ArrayCompleteness = 0;\n    for (unsigned int i=0; i<video_parameters.ItemCount(); i++) {\n        vps_sequence.m_Nalus.Append(video_parameters[i]);\n    }\n    if (vps_sequence.m_Nalus.ItemCount()) {\n        m_Sequences.Append(vps_sequence);\n    }\n    \n    AP4_HvccAtom::Sequence sps_sequence;\n    sps_sequence.m_NaluType = AP4_HEVC_NALU_TYPE_SPS_NUT;\n    sps_sequence.m_ArrayCompleteness = 0;\n    for (unsigned int i=0; i<sequence_parameters.ItemCount(); i++) {\n        sps_sequence.m_Nalus.Append(sequence_parameters[i]);\n    }\n    if (sps_sequence.m_Nalus.ItemCount()) {\n        m_Sequences.Append(sps_sequence);\n    }\n\n    AP4_HvccAtom::Sequence pps_sequence;\n    pps_sequence.m_NaluType = AP4_HEVC_NALU_TYPE_PPS_NUT;\n    pps_sequence.m_ArrayCompleteness = 0;\n    for (unsigned int i=0; i<picture_parameters.ItemCount(); i++) {\n        pps_sequence.m_Nalus.Append(picture_parameters[i]);\n    }\n    if (pps_sequence.m_Nalus.ItemCount()) {\n        m_Sequences.Append(pps_sequence);\n    }\n    \n    UpdateRawBytes();\n    m_Size32 += m_RawBytes.GetDataSize();\n}\n\n/*----------------------------------------------------------------------\n|   AP4_HvccAtom::AP4_HvccAtom\n+---------------------------------------------------------------------*/\nAP4_HvccAtom::AP4_HvccAtom(AP4_UI32 size, const AP4_UI08* payload) :\n    AP4_Atom(AP4_ATOM_TYPE_HVCC, size)\n{\n    // make a copy of our configuration bytes\n    unsigned int payload_size = size-AP4_ATOM_HEADER_SIZE;\n\n    // keep a raw copy\n    if (payload_size < 22) return;\n    m_RawBytes.SetData(payload, payload_size);\n\n    // parse the payload\n    m_ConfigurationVersion   = payload[0];\n    m_GeneralProfileSpace    = (payload[1]>>6) & 0x03;\n    m_GeneralTierFlag        = (payload[1]>>5) & 0x01;\n    m_GeneralProfile         = (payload[1]   ) & 0x1F;\n    m_GeneralProfileCompatibilityFlags = AP4_BytesToUInt32BE(&payload[2]);\n    m_GeneralConstraintIndicatorFlags  = (((AP4_UI64)AP4_BytesToUInt32BE(&payload[6]))<<16) | AP4_BytesToUInt16BE(&payload[10]);\n    m_GeneralLevel           = payload[12];\n    m_Reserved1              = (payload[13]>>4) & 0x0F;\n    m_MinSpatialSegmentation = AP4_BytesToUInt16BE(&payload[13]) & 0x0FFF;\n    m_Reserved2              = (payload[15]>>2) & 0x3F;\n    m_ParallelismType        = payload[15] & 0x03;\n    m_Reserved3              = (payload[16]>>2) & 0x3F;\n    m_ChromaFormat           = payload[16] & 0x03;\n    m_Reserved4              = (payload[17]>>3) & 0x1F;\n    m_LumaBitDepth           = 8+(payload[17] & 0x07);\n    m_Reserved5              = (payload[18]>>3) & 0x1F;\n    m_ChromaBitDepth         = 8+(payload[18] & 0x07);\n    m_AverageFrameRate       = AP4_BytesToUInt16BE(&payload[19]);\n    m_ConstantFrameRate      = (payload[21]>>6) & 0x03;\n    m_NumTemporalLayers      = (payload[21]>>3) & 0x07;\n    m_TemporalIdNested       = (payload[21]>>2) & 0x01;\n    m_NaluLengthSize         = 1+(payload[21] & 0x03);\n    \n    AP4_UI08 num_seq = payload[22];\n    m_Sequences.SetItemCount(num_seq);\n    unsigned int cursor = 23;\n    for (unsigned int i=0; i<num_seq; i++) {\n\n        Sequence& seq = m_Sequences[i];\n        if (cursor+1 > payload_size) break;\n        seq.m_ArrayCompleteness = (payload[cursor] >> 7) & 0x01;\n        seq.m_Reserved          = (payload[cursor] >> 6) & 0x01;\n        seq.m_NaluType          = payload[cursor] & 0x3F;\n        cursor += 1;\n        \n        if (cursor+2 > payload_size) break;\n        AP4_UI16 nalu_count = AP4_BytesToUInt16BE(&payload[cursor]);\n        seq.m_Nalus.SetItemCount(nalu_count);\n        cursor += 2;\n        \n        for (unsigned int j=0; j<nalu_count; j++) {\n            if (cursor+2 > payload_size) break;\n            unsigned int nalu_length = AP4_BytesToUInt16BE(&payload[cursor]);\n            cursor += 2;\n            if (cursor + nalu_length > payload_size) break;\n            seq.m_Nalus[j].SetData(&payload[cursor], nalu_length);\n            cursor += nalu_length;\n        }\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_HvccAtom::UpdateRawBytes\n+---------------------------------------------------------------------*/\nvoid\nAP4_HvccAtom::UpdateRawBytes()\n{\n    AP4_BitWriter bits(23);\n    bits.Write(m_ConfigurationVersion, 8);\n    bits.Write(m_GeneralProfileSpace, 2);\n    bits.Write(m_GeneralTierFlag, 1);\n    bits.Write(m_GeneralProfile, 5);\n    bits.Write(m_GeneralProfileCompatibilityFlags, 32);\n    bits.Write((AP4_UI32)(m_GeneralConstraintIndicatorFlags>>32), 16);\n    bits.Write((AP4_UI32)(m_GeneralConstraintIndicatorFlags), 32);\n    bits.Write(m_GeneralLevel, 8);\n    bits.Write(0xFF, 4);\n    bits.Write(m_MinSpatialSegmentation, 12);\n    bits.Write(0xFF, 6);\n    bits.Write(m_ParallelismType, 2);\n    bits.Write(0xFF, 6);\n    bits.Write(m_ChromaFormat, 2);\n    bits.Write(0xFF, 5);\n    bits.Write(m_LumaBitDepth >= 8 ? m_LumaBitDepth - 8 : 0, 3);\n    bits.Write(0xFF, 5);\n    bits.Write(m_ChromaBitDepth >= 8 ? m_ChromaBitDepth - 8 : 0, 3);\n    bits.Write(m_AverageFrameRate, 16);\n    bits.Write(m_ConstantFrameRate, 2);\n    bits.Write(m_NumTemporalLayers, 3);\n    bits.Write(m_TemporalIdNested, 1);\n    bits.Write(m_NaluLengthSize > 0 ? m_NaluLengthSize - 1 : 0, 2);\n    bits.Write(m_Sequences.ItemCount(), 8);\n    \n    m_RawBytes.SetData(bits.GetData(), 23);\n\n    for (unsigned int i=0; i<m_Sequences.ItemCount(); i++) {\n        AP4_UI08 bytes[3];\n        bytes[0] = (m_Sequences[i].m_ArrayCompleteness ? (1<<7) : 0) | m_Sequences[i].m_NaluType;\n        AP4_BytesFromUInt16BE(&bytes[1], m_Sequences[i].m_Nalus.ItemCount());\n        m_RawBytes.AppendData(bytes, 3);\n        \n        for (unsigned int j=0; j<m_Sequences[i].m_Nalus.ItemCount(); j++) {\n            AP4_UI08 size[2];\n            AP4_BytesFromUInt16BE(&size[0], (AP4_UI16)m_Sequences[i].m_Nalus[j].GetDataSize());\n            m_RawBytes.AppendData(size, 2);\n            m_RawBytes.AppendData(m_Sequences[i].m_Nalus[j].GetData(), m_Sequences[i].m_Nalus[j].GetDataSize());\n        }\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_HvccAtom::WriteFields\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_HvccAtom::WriteFields(AP4_ByteStream& stream)\n{\n    return stream.Write(m_RawBytes.GetData(), m_RawBytes.GetDataSize());\n}\n\n/*----------------------------------------------------------------------\n|   AP4_HvccAtom::InspectFields\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_HvccAtom::InspectFields(AP4_AtomInspector& inspector)\n{\n    inspector.AddField(\"Configuration Version\", m_ConfigurationVersion);\n    inspector.AddField(\"Profile Space\", m_GeneralProfileSpace);\n    const char* profile_name = GetProfileName(m_GeneralProfileSpace, m_GeneralProfile);\n    if (profile_name) {\n        inspector.AddField(\"Profile\", profile_name);\n    } else {\n        inspector.AddField(\"Profile\", m_GeneralProfile);\n    }\n    inspector.AddField(\"Tier\", m_GeneralTierFlag);\n    inspector.AddField(\"Profile Compatibility\", m_GeneralProfileCompatibilityFlags, AP4_AtomInspector::HINT_HEX);\n    inspector.AddField(\"Constraint\", m_GeneralConstraintIndicatorFlags, AP4_AtomInspector::HINT_HEX);\n    inspector.AddField(\"Level\", m_GeneralLevel);\n    inspector.AddField(\"Min Spatial Segmentation\", m_MinSpatialSegmentation);\n    inspector.AddField(\"Parallelism Type\", m_ParallelismType);\n    inspector.AddField(\"Chroma Format\", m_ChromaFormat);\n    inspector.AddField(\"Chroma Depth\", m_ChromaBitDepth);\n    inspector.AddField(\"Luma Depth\", m_LumaBitDepth);\n    inspector.AddField(\"Average Frame Rate\", m_AverageFrameRate);\n    inspector.AddField(\"Constant Frame Rate\", m_ConstantFrameRate);\n    inspector.AddField(\"Number Of Temporal Layers\", m_NumTemporalLayers);\n    inspector.AddField(\"Temporal Id Nested\", m_TemporalIdNested);\n    inspector.AddField(\"NALU Length Size\", m_NaluLengthSize);\n    return AP4_SUCCESS;\n}\n"], "filenames": ["Source/C++/Core/Ap4AvccAtom.cpp", "Source/C++/Core/Ap4HvccAtom.cpp"], "buggy_code_start_loc": [155, 249], "buggy_code_end_loc": [167, 249], "fixing_code_start_loc": [155, 250], "fixing_code_end_loc": [177, 253], "type": "CWE-125", "message": "The AP4_AvccAtom and AP4_HvccAtom classes in Bento4 version 1.5.0-617 do not properly validate data sizes, leading to a heap-based buffer over-read and application crash in AP4_DataBuffer::SetData in Core/Ap4DataBuffer.cpp.", "other": {"cve": {"id": "CVE-2017-14646", "sourceIdentifier": "cve@mitre.org", "published": "2017-09-21T17:29:00.433", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The AP4_AvccAtom and AP4_HvccAtom classes in Bento4 version 1.5.0-617 do not properly validate data sizes, leading to a heap-based buffer over-read and application crash in AP4_DataBuffer::SetData in Core/Ap4DataBuffer.cpp."}, {"lang": "es", "value": "Las clases AP4_AvccAtom y AP4_HvccAtom en Bento4 1.5.0-617 no validan correctamente los tama\u00f1os de los datos, provocando una sobrelectura de b\u00fafer basada en memoria din\u00e1mica (heap) y el cierre inesperado de la aplicaci\u00f3n en AP4_DataBuffer::SetData en Core/Ap4DataBuffer.cpp."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:axiosys:bento4:1.5.0-617:*:*:*:*:*:*:*", "matchCriteriaId": "3AADCDAA-F274-4231-BF07-2478EC64FBE6"}]}]}], "references": [{"url": "https://blogs.gentoo.org/ago/2017/09/14/bento4-heap-based-buffer-overflow-in-ap4_databuffersetdata-ap4databuffer-cpp/", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/axiomatic-systems/Bento4/commit/53499d8d4c69142137c7c7f0097a444783fdeb90", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/axiomatic-systems/Bento4/issues/188", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/axiomatic-systems/Bento4/commit/53499d8d4c69142137c7c7f0097a444783fdeb90"}}