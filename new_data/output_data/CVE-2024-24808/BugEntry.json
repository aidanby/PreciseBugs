{"buggy_code": ["# -*- coding: utf-8 -*-\n\nimport datetime\nimport mimetypes\nimport operator\nimport os\nimport re\nimport sys\nimport time\nfrom logging import getLogger\nfrom urllib.parse import unquote\n\nimport flask\nfrom pyload import APPID, PKGDIR\nfrom pyload.core.utils import format\n\nfrom ..helpers import (\n    clear_session, get_permission, get_redirect_url, is_authenticated, login_required, permlist, render_base,\n    render_template, set_session, static_file_url)\n\n_RE_LOGLINE = re.compile(r\"\\[([\\d\\-]+) ([\\d:]+)\\] +([A-Z]+) +(.+?) (.*)\")\n\nbp = flask.Blueprint(\"app\", __name__)\nlog = getLogger(APPID)\n\n\n@bp.route(\"/favicon.ico\", endpoint=\"favicon\")\ndef favicon():\n    location = static_file_url(\"img/favicon.ico\")\n    return flask.redirect(location)\n\n\n@bp.route(\"/render/<path:filename>\", endpoint=\"render\")\ndef render(filename):\n    mimetype = mimetypes.guess_type(filename)[0] or \"text/html\"\n    data = render_template(filename)\n    return flask.Response(data, mimetype=mimetype)\n\n\n@bp.route(\"/robots.txt\", endpoint=\"robots\")\ndef robots():\n    return \"User-agent: *\\nDisallow: /\"\n\n\n# TODO: Rewrite login route using flask-login\n@bp.route(\"/login\", methods=[\"GET\", \"POST\"], endpoint=\"login\")\ndef login():\n    api = flask.current_app.config[\"PYLOAD_API\"]\n\n    next = get_redirect_url(fallback=flask.url_for(\"app.dashboard\"))\n\n    if flask.request.method == \"POST\":\n        user = flask.request.form[\"username\"]\n        password = flask.request.form[\"password\"]\n        user_info = api.check_auth(user, password)\n\n        sanitized_user = user.replace(\"\\n\", \"\\\\n\").replace(\"\\r\", \"\\\\r\")\n        if not user_info:\n            log.error(f\"Login failed for user '{sanitized_user}'\")\n            return render_template(\"login.html\", next=next, errors=True)\n\n        set_session(user_info)\n        log.info(f\"User '{sanitized_user}' successfully logged in\")\n        flask.flash(\"Logged in successfully\")\n\n    if is_authenticated():\n        return flask.redirect(next)\n\n    if api.get_config_value(\"webui\", \"autologin\"):\n        allusers = api.get_all_userdata()\n        if len(allusers) == 1:  # TODO: check if localhost\n            user_info = list(allusers.values())[0]\n            set_session(user_info)\n            # NOTE: Double-check authentication here because if session[name] is empty,\n            #       next login_required redirects here again and all loop out.\n            if is_authenticated():\n                return flask.redirect(next)\n\n    return render_template(\"login.html\", next=next)\n\n\n@bp.route(\"/logout\", endpoint=\"logout\")\ndef logout():\n    s = flask.session\n    user = s.get(\"name\")\n    clear_session(s)\n    if user:\n        log.info(f\"User '{user}' logged out\")\n    return render_template(\"logout.html\")\n\n\n@bp.route(\"/\", endpoint=\"index\")\n@bp.route(\"/home\", endpoint=\"home\")\n@bp.route(\"/dashboard\", endpoint=\"dashboard\")\n@login_required(\"LIST\")\ndef dashboard():\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    links = api.status_downloads()\n\n    for link in links:\n        if link[\"status\"] == 12:\n            current_size = link[\"size\"] - link[\"bleft\"]\n            formatted_speed = format.speed(link[\"speed\"])\n            link[\"info\"] = f\"{current_size} KiB @ {formatted_speed}\"\n\n    return render_template(\"dashboard.html\", res=links)\n\n\n@bp.route(\"/queue\", endpoint=\"queue\")\n@login_required(\"LIST\")\ndef queue():\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    queue = api.get_queue()\n    queue.sort(key=operator.attrgetter(\"order\"))\n\n    return render_template(\"packages.html\", content=queue, target=1)\n\n\n@bp.route(\"/collector\", endpoint=\"collector\")\n@login_required(\"LIST\")\ndef collector():\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    queue = api.get_collector()\n\n    queue.sort(key=operator.attrgetter(\"order\"))\n\n    return render_template(\"packages.html\", content=queue, target=0)\n\n\n@bp.route(\"/files\", endpoint=\"files\")\n@login_required(\"DOWNLOAD\")\ndef files():\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    root = api.get_config_value(\"general\", \"storage_folder\")\n\n    if not os.path.isdir(root):\n        messages = [\"Download directory not found.\"]\n        return render_base(messages)\n    data = {\"folder\": [], \"files\": []}\n\n    for entry in sorted(os.listdir(root)):\n        if os.path.isdir(os.path.join(root, entry)):\n            folder = {\"name\": entry, \"path\": entry, \"files\": []}\n            files = os.listdir(os.path.join(root, entry))\n            for file in sorted(files):\n                try:\n                    if os.path.isfile(os.path.join(root, entry, file)):\n                        folder[\"files\"].append(file)\n                except Exception:\n                    pass\n\n            data[\"folder\"].append(folder)\n\n        elif os.path.isfile(os.path.join(root, entry)):\n            data[\"files\"].append(entry)\n\n    return render_template(\"files.html\", files=data)\n\n\n@bp.route(\"/files/get/<path:path>\", endpoint=\"get_file\")\n@login_required(\"DOWNLOAD\")\ndef get_file(path):\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    path = unquote(path).replace(\"..\", \"\")\n    directory = api.get_config_value(\"general\", \"storage_folder\")\n    return flask.send_from_directory(directory, path, as_attachment=True)\n\n\n@bp.route(\"/settings\", endpoint=\"settings\")\n@login_required(\"SETTINGS\")\ndef settings():\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    conf = api.get_config()\n    plugin = api.get_plugin_config()\n\n    conf_menu = []\n    plugin_menu = []\n\n    for entry in sorted(conf.keys()):\n        conf_menu.append((entry, conf[entry].description))\n\n    for entry in sorted(plugin.keys()):\n        plugin_menu.append((entry, plugin[entry].description))\n\n    accs = []\n\n    for userdata in api.get_accounts(False):\n        if userdata.trafficleft is None:\n            trafficleft = \"not available\"\n        elif userdata.trafficleft == -1:\n            trafficleft = \"unlimited\"\n        elif userdata.trafficleft == 0:\n            trafficleft = \"drained\"\n        else:\n            trafficleft = format.size(userdata.trafficleft)\n\n        if userdata.validuntil == -1:\n            validuntil = \"unlimited\"\n        elif not userdata.validuntil:\n            validuntil = \"not available\"\n        else:\n            t = time.localtime(userdata.validuntil)\n            validuntil = time.strftime(\"%d.%m.%Y\", t)\n\n        if \"time\" in userdata.options:\n            try:\n                _time = userdata.options[\"time\"][0]\n            except Exception:\n                _time = \"\"\n        else:\n            _time = \"\"\n\n        if \"limit_dl\" in userdata.options:\n            try:\n                limitdl = userdata.options[\"limit_dl\"][0]\n            except Exception:\n                limitdl = \"0\"\n        else:\n            limitdl = \"0\"\n\n        accs.append(\n            {\n                \"type\": userdata.type,\n                \"login\": userdata.login,\n                \"valid\": userdata.valid,\n                \"premium\": userdata.premium,\n                \"trafficleft\": trafficleft,\n                \"validuntil\": validuntil,\n                \"limitdl\": limitdl,\n                \"time\": _time,\n            }\n        )\n\n    all_users = api.get_all_userdata()\n    users = {}\n    for userdata in all_users.values():\n        name = userdata[\"name\"]\n        users[name] = {\"perms\": get_permission(userdata[\"permission\"])}\n        users[name][\"perms\"][\"admin\"] = userdata[\"role\"] == 0\n\n    admin_menu = {\n        \"permlist\": permlist(),\n        \"users\": users\n    }\n\n    context = {\n        \"conf\": {\"plugin\": plugin_menu, \"general\": conf_menu, \"accs\": accs, \"admin\": admin_menu},\n        \"types\": api.get_account_types(),\n    }\n    return render_template(\"settings.html\", **context)\n\n\n@bp.route(\"/pathchooser/\", endpoint=\"pathchooser\")\n@bp.route(\"/filechooser/\", endpoint=\"filechooser\")\n@login_required(\"SETTINGS\")\ndef pathchooser():\n    browse_for = \"folder\" if flask.request.endpoint == \"app.pathchooser\" else \"file\"\n    path = os.path.normpath(flask.request.args.get('path', \"\"))\n\n    if os.path.isfile(path):\n        oldfile = path\n        path = os.path.dirname(path)\n    else:\n        oldfile = \"\"\n\n    abs = False\n\n    if os.path.isdir(path):\n        if os.path.isabs(path):\n            cwd = os.path.realpath(path)\n            abs = True\n        else:\n            cwd = os.path.relpath(path)\n    else:\n        cwd = os.getcwd()\n\n    cwd = os.path.normpath(os.path.realpath(cwd))\n    parentdir = os.path.dirname(cwd)\n    if not abs:\n        if os.path.realpath(cwd) == os.path.realpath(\"/\"):\n            cwd = os.path.relpath(cwd)\n        else:\n            cwd = os.path.relpath(cwd) + os.path.sep\n        parentdir = os.path.relpath(parentdir) + os.path.sep\n\n    if os.path.realpath(cwd) == os.path.realpath(\"/\"):\n        parentdir = \"\"\n\n    try:\n        folders = os.listdir(cwd)\n    except Exception:\n        folders = []\n\n    files = []\n\n    for f in folders:\n        try:\n            data = {\"name\": f, \"fullpath\": os.path.join(cwd, f)}\n            data[\"sort\"] = data[\"fullpath\"].lower()\n            data[\"modified\"] = datetime.datetime.fromtimestamp(\n                int(os.path.getmtime(os.path.join(cwd, f)))\n            )\n            data[\"ext\"] = os.path.splitext(f)[1]\n        except Exception:\n            continue\n\n        if os.path.isfile(os.path.join(cwd, f)):\n            data[\"type\"] = \"file\"\n            data[\"size\"] = os.path.getsize(os.path.join(cwd, f))\n\n            power = 0\n            while (data[\"size\"] >> 10) > 0.3:\n                power += 1\n                data[\"size\"] >>= 10\n            units = (\"\", \"K\", \"M\", \"G\", \"T\")\n            data[\"unit\"] = units[power] + \"Byte\"\n        else:\n            data[\"type\"] = \"dir\"\n            data[\"size\"] = \"\"\n\n        files.append(data)\n\n    files = sorted(files, key=operator.itemgetter(\"type\", \"sort\"))\n\n    context = {\n        \"cwd\": cwd,\n        \"files\": files,\n        \"parentdir\": parentdir,\n        \"type\": browse_for,\n        \"oldfile\": oldfile,\n        \"absolute\": abs,\n    }\n    return render_template(\"pathchooser.html\", **context)\n\n\n@bp.route(\"/logs\", methods=[\"GET\", \"POST\"], endpoint=\"logs\")\n@bp.route(\"/logs/<int:start_line>\", methods=[\"GET\", \"POST\"], endpoint=\"logs\")\n@login_required(\"LOGS\")\ndef logs(start_line=-1):\n    s = flask.session\n    api = flask.current_app.config[\"PYLOAD_API\"]\n\n    per_page = s.get(\"perpage\", 34)\n    reversed = s.get(\"reversed\", False)\n\n    warning = \"\"\n    conf = api.get_config_value(\"log\", \"filelog\")\n    if not conf:\n        warning = \"Warning: File log is disabled, see settings page.\"\n\n    per_page_selection = ((20, 20), (34, 34), (40, 40), (100, 100), (0, \"all\"))\n    fro = None\n\n    if flask.request.method == \"POST\":\n        try:\n            from_form = flask.request.form[\"from\"]\n            fro = datetime.datetime.strptime(from_form, \"%Y-%m-%d %H:%M:%S\")\n        except Exception:\n            pass\n\n        per_page = int(flask.request.form.get(\"perpage\", 34))\n        s[\"perpage\"] = per_page\n\n        reversed = bool(flask.request.form.get(\"reversed\", False))\n        s[\"reversed\"] = reversed\n\n        # s.modified = True\n\n    log_entries = api.get_log()\n    if not per_page:\n        start_line = 0\n\n    if start_line < 1:\n        start_line = (\n            1 if len(log_entries) - per_page + 1 < 1 or per_page == 0 else len(log_entries) - per_page + 1\n        )\n\n    if isinstance(fro, datetime.datetime):  #: we will search for datetime.datetime\n        start_line = -1\n\n    data = []\n    inpage_counter = 0\n    for counter, logline in enumerate(log_entries, start=1):\n        if counter >= start_line:\n            try:\n                date, time, level, source, message = _RE_LOGLINE.match(logline).groups()\n                dtime = datetime.datetime.strptime(\n                    date + \" \" + time, \"%Y-%m-%d %H:%M:%S\"\n                )\n                message = message.strip()\n            except (AttributeError, IndexError):\n                dtime = None\n                date = \"?\"\n                time = \" \"\n                level = \"?\"\n                source = \"?\"\n                message = logline\n            if start_line == -1 and dtime is not None and fro <= dtime:\n                start_line = counter  #: found our datetime.datetime\n\n            if start_line >= 0:\n                data.append(\n                    {\n                        \"line\": counter,\n                        \"date\": date + \" \" + time,\n                        \"level\": level,\n                        \"source\": source,\n                        \"message\": message.rstrip('\\n'),\n                    }\n                )\n                inpage_counter += 1\n                if (\n                    fro is None and dtime is not None\n                ):  #: if fro not set, set it to first showed line\n                    fro = dtime\n            if inpage_counter >= per_page > 0:\n                break\n\n    if fro is None:  #: still not set, empty log?\n        fro = datetime.datetime.now()\n\n    if reversed:\n        data.reverse()\n\n    context = {\n        \"warning\": warning,\n        \"log\": data,\n        \"from\": fro.strftime(\"%Y-%m-%d %H:%M:%S\"),\n        \"reversed\": reversed,\n        \"perpage\": per_page,\n        \"perpage_p\": sorted(per_page_selection),\n        \"iprev\": max(start_line - per_page, 1),\n        \"inext\": (start_line + per_page) if start_line + per_page <= len(log_entries) else start_line,\n    }\n    return render_template(\"logs.html\", **context)\n\n\n@bp.route(\"/filemanager\", endpoint=\"filemanager\")\n@login_required(\"MODIFY\")\ndef filemanager(path):\n    return render_template(\"filemanager.html\")\n\n\n@bp.route(\"/info\", endpoint=\"info\")\n@login_required(\"STATUS\")\ndef info():\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    conf = api.get_config_dict()\n    extra = os.uname() if hasattr(os, \"uname\") else tuple()\n\n    context = {\n        \"python\": sys.version,\n        \"os\": \" \".join((os.name, sys.platform) + extra),\n        \"version\": api.get_server_version(),\n        \"folder\": PKGDIR,\n        \"config_folder\": api.get_userdir(),\n        \"download\": conf[\"general\"][\"storage_folder\"][\"value\"],\n        \"freespace\": format.size(api.free_space()),\n        \"webif\": conf[\"webui\"][\"port\"][\"value\"],\n        \"language\": conf[\"general\"][\"language\"][\"value\"],\n    }\n    return render_template(\"info.html\", **context)\n", "# -*- coding: utf-8 -*-\n\nimport json\nfrom functools import wraps\nfrom urllib.parse import unquote, urljoin, urlparse\n\nimport flask\nimport flask_themes2\nfrom pyload.core.api import Perms, Role, has_permission\n\n\nclass JSONEncoder(json.JSONEncoder):\n    def default(self, obj):\n        try:\n            return dict(obj)\n        except TypeError:\n            pass\n        return super().default(obj)\n\n\ntry:\n    JSONProviderBase = flask.json.provider.JSONProvider\nexcept AttributeError:\n    pass\nelse:\n    class JSONProvider(JSONProviderBase):\n        def dumps(self, obj, **kwargs):\n            return json.dumps(obj, **kwargs, cls=JSONEncoder)\n\n        def loads(self, s, **kwargs):\n            return json.loads(s, **kwargs)\n\n\n#: Checks if location belongs to same host address\ndef is_safe_url(location):\n    ref_url = urlparse(flask.request.host_url)\n    test_url = urlparse(urljoin(flask.request.host_url, location))\n    return test_url.scheme in ('http', 'https') and ref_url.netloc == test_url.netloc\n\n\ndef get_redirect_url(fallback=None):\n    login_url = urljoin(flask.request.url_root, flask.url_for('app.login'))\n    request_url = unquote(flask.request.url)\n    for location in flask.request.values.get(\"next\"), flask.request.referrer:\n        if not location:\n            continue\n        if location in (request_url, login_url):  # don't redirect to same location\n            continue\n        if is_safe_url(location):\n            return location\n    return fallback\n\n\ndef render_base(messages):\n    return render_template(\"base.html\", messages=messages)\n\n\ndef clear_session(session=flask.session, permanent=True):\n    session.permanent = bool(permanent)\n    session.clear()\n    # session.modified = True\n\n\ndef current_theme_id():\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    return api.get_config_value(\"webui\", \"theme\").lower()\n\n\n#: tries to serve the file from the static directory of the current theme otherwise fallback to builtin one\ndef static_file_url(filename):\n    themeid = current_theme_id()\n    try:\n        url = flask_themes2.static_file_url(themeid, filename)\n    except KeyError:\n        url = flask.url_for(\"static\", filename=filename)\n    return url\n\n\ndef theme_template(filename):\n    return flask.url_for(\"app.render\", filename=filename)\n\n\n#: tries to render the template of the current theme otherwise fallback to builtin template\ndef render_template(template, **context):\n    themeid = current_theme_id()\n    return flask_themes2.render_theme_template(themeid, template, **context)\n\n\ndef parse_permissions(session=flask.session):\n    perms = {x.name: False for x in Perms}\n    perms[\"ADMIN\"] = False\n    perms[\"is_admin\"] = False\n\n    if not session.get(\"authenticated\", False):\n        return perms\n\n    perms[\"ANY\"] = True\n    if session.get(\"role\") == Role.ADMIN:\n        for key in perms.keys():\n            perms[key] = True\n\n    elif session.get(\"perms\"):\n        p = session.get(\"perms\")\n        perms.update(get_permission(p))\n\n    return perms\n\n\ndef permlist():\n    return [x.name for x in Perms if x.name != \"ANY\"]\n\n\ndef get_permission(userperms):\n    \"\"\"\n    Returns a dict with permission key.\n\n    :param userperms: permission bits\n    \"\"\"\n    return {\n        name: has_permission(userperms, getattr(Perms, name).value)\n        for name in permlist()\n    }\n\n\ndef set_permission(perms):\n    \"\"\"\n    generates permission bits from dictionary.\n\n    :param perms: dict\n    \"\"\"\n    permission = 0\n    for name in permlist():\n        if name.startswith(\"_\"):\n            continue\n\n        if name in perms and perms[name]:\n            permission |= getattr(Perms, name)\n\n    return permission\n\n\ndef set_session(user_info, session=flask.session, permanent=True):\n    session.permanent = bool(permanent)\n    session.update(\n        {\n            \"authenticated\": True,\n            \"id\": user_info[\"id\"],\n            \"name\": user_info[\"name\"],\n            \"role\": user_info[\"role\"],\n            \"perms\": user_info[\"permission\"],\n            \"template\": user_info[\"template\"],\n        }\n    )\n    # session.modified = True\n    return session\n\n\n# TODO: Recheck...\ndef parse_userdata(session=flask.session):\n    return {\n        \"name\": session.get(\"name\", \"Anonymous\"),\n        \"is_admin\": session.get(\"role\", 1) == 0,\n        \"is_authenticated\": session.get(\"authenticated\", False),\n    }\n\n\ndef apiver_check(func):\n    # if no apiver is provided assumes latest\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        api = flask.current_app.config[\"PYLOAD_API\"]\n        core_apiver = api.__version__\n        if int(kwargs.get(\"apiver\", core_apiver).strip(\"v\")) < core_apiver:\n            return \"Obsolete API\", 404\n        return func(*args, **kwargs)\n\n    return wrapper\n\n\ndef is_authenticated(session=flask.session):\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    user = session.get(\"name\")\n    authenticated = session.get(\"authenticated\")\n\n    return authenticated and api.user_exists(user)\n\n\ndef login_required(perm):\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            s = flask.session\n            #: already authenticated?\n            if is_authenticated(s):\n                perms = parse_permissions(s)\n                if perm not in perms or not perms[perm]:\n                    response = \"Forbidden\", 403\n                else:\n                    response = func(*args, **kwargs)\n\n            else:\n                clear_session(s)\n                if flask.request.headers.get(\"X-Requested-With\") == \"XMLHttpRequest\":\n                    response = \"Forbidden\", 403\n\n                else:\n                    location = flask.url_for(\n                        \"app.login\",\n                        next=flask.request.url\n                    )\n                    response = flask.redirect(location)\n\n            return response\n\n        return wrapper\n\n    return decorator\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n\nimport datetime\nimport mimetypes\nimport operator\nimport os\nimport re\nimport sys\nimport time\nfrom logging import getLogger\nfrom urllib.parse import unquote\n\nimport flask\nfrom pyload import APPID, PKGDIR\nfrom pyload.core.utils import format\n\nfrom ..helpers import (\n    clear_session, get_permission, get_redirect_url, is_authenticated, login_required, permlist, render_base,\n    render_template, set_session, static_file_url)\n\n_RE_LOGLINE = re.compile(r\"\\[([\\d\\-]+) ([\\d:]+)\\] +([A-Z]+) +(.+?) (.*)\")\n\nbp = flask.Blueprint(\"app\", __name__)\nlog = getLogger(APPID)\n\n\n@bp.route(\"/favicon.ico\", endpoint=\"favicon\")\ndef favicon():\n    location = static_file_url(\"img/favicon.ico\")\n    return flask.redirect(location)\n\n\n@bp.route(\"/render/<path:filename>\", endpoint=\"render\")\ndef render(filename):\n    mimetype = mimetypes.guess_type(filename)[0] or \"text/html\"\n    data = render_template(filename)\n    return flask.Response(data, mimetype=mimetype)\n\n\n@bp.route(\"/robots.txt\", endpoint=\"robots\")\ndef robots():\n    return \"User-agent: *\\nDisallow: /\"\n\n\n# TODO: Rewrite login route using flask-login\n@bp.route(\"/login\", methods=[\"GET\", \"POST\"], endpoint=\"login\")\ndef login():\n    api = flask.current_app.config[\"PYLOAD_API\"]\n\n    next_url = get_redirect_url(fallback=\"app.dashboard\")\n\n    if flask.request.method == \"POST\":\n        user = flask.request.form[\"username\"]\n        password = flask.request.form[\"password\"]\n        user_info = api.check_auth(user, password)\n\n        sanitized_user = user.replace(\"\\n\", \"\\\\n\").replace(\"\\r\", \"\\\\r\")\n        if not user_info:\n            log.error(f\"Login failed for user '{sanitized_user}'\")\n            return render_template(\"login.html\", errors=True)\n\n        set_session(user_info)\n        log.info(f\"User '{sanitized_user}' successfully logged in\")\n        flask.flash(\"Logged in successfully\")\n\n    if is_authenticated():\n        return flask.redirect(next_url)\n\n    if api.get_config_value(\"webui\", \"autologin\"):\n        allusers = api.get_all_userdata()\n        if len(allusers) == 1:  # TODO: check if localhost\n            user_info = list(allusers.values())[0]\n            set_session(user_info)\n            # NOTE: Double-check authentication here because if session[name] is empty,\n            #       next login_required redirects here again and all loop out.\n            if is_authenticated():\n                return flask.redirect(next_url)\n\n    return render_template(\"login.html\")\n\n\n@bp.route(\"/logout\", endpoint=\"logout\")\ndef logout():\n    s = flask.session\n    user = s.get(\"name\")\n    clear_session(s)\n    if user:\n        log.info(f\"User '{user}' logged out\")\n    return render_template(\"logout.html\")\n\n\n@bp.route(\"/\", endpoint=\"index\")\n@bp.route(\"/home\", endpoint=\"home\")\n@bp.route(\"/dashboard\", endpoint=\"dashboard\")\n@login_required(\"LIST\")\ndef dashboard():\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    links = api.status_downloads()\n\n    for link in links:\n        if link[\"status\"] == 12:\n            current_size = link[\"size\"] - link[\"bleft\"]\n            formatted_speed = format.speed(link[\"speed\"])\n            link[\"info\"] = f\"{current_size} KiB @ {formatted_speed}\"\n\n    return render_template(\"dashboard.html\", res=links)\n\n\n@bp.route(\"/queue\", endpoint=\"queue\")\n@login_required(\"LIST\")\ndef queue():\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    queue = api.get_queue()\n    queue.sort(key=operator.attrgetter(\"order\"))\n\n    return render_template(\"packages.html\", content=queue, target=1)\n\n\n@bp.route(\"/collector\", endpoint=\"collector\")\n@login_required(\"LIST\")\ndef collector():\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    queue = api.get_collector()\n\n    queue.sort(key=operator.attrgetter(\"order\"))\n\n    return render_template(\"packages.html\", content=queue, target=0)\n\n\n@bp.route(\"/files\", endpoint=\"files\")\n@login_required(\"DOWNLOAD\")\ndef files():\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    root = api.get_config_value(\"general\", \"storage_folder\")\n\n    if not os.path.isdir(root):\n        messages = [\"Download directory not found.\"]\n        return render_base(messages)\n    data = {\"folder\": [], \"files\": []}\n\n    for entry in sorted(os.listdir(root)):\n        if os.path.isdir(os.path.join(root, entry)):\n            folder = {\"name\": entry, \"path\": entry, \"files\": []}\n            files = os.listdir(os.path.join(root, entry))\n            for file in sorted(files):\n                try:\n                    if os.path.isfile(os.path.join(root, entry, file)):\n                        folder[\"files\"].append(file)\n                except Exception:\n                    pass\n\n            data[\"folder\"].append(folder)\n\n        elif os.path.isfile(os.path.join(root, entry)):\n            data[\"files\"].append(entry)\n\n    return render_template(\"files.html\", files=data)\n\n\n@bp.route(\"/files/get/<path:path>\", endpoint=\"get_file\")\n@login_required(\"DOWNLOAD\")\ndef get_file(path):\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    path = unquote(path).replace(\"..\", \"\")\n    directory = api.get_config_value(\"general\", \"storage_folder\")\n    return flask.send_from_directory(directory, path, as_attachment=True)\n\n\n@bp.route(\"/settings\", endpoint=\"settings\")\n@login_required(\"SETTINGS\")\ndef settings():\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    conf = api.get_config()\n    plugin = api.get_plugin_config()\n\n    conf_menu = []\n    plugin_menu = []\n\n    for entry in sorted(conf.keys()):\n        conf_menu.append((entry, conf[entry].description))\n\n    for entry in sorted(plugin.keys()):\n        plugin_menu.append((entry, plugin[entry].description))\n\n    accs = []\n\n    for userdata in api.get_accounts(False):\n        if userdata.trafficleft is None:\n            trafficleft = \"not available\"\n        elif userdata.trafficleft == -1:\n            trafficleft = \"unlimited\"\n        elif userdata.trafficleft == 0:\n            trafficleft = \"drained\"\n        else:\n            trafficleft = format.size(userdata.trafficleft)\n\n        if userdata.validuntil == -1:\n            validuntil = \"unlimited\"\n        elif not userdata.validuntil:\n            validuntil = \"not available\"\n        else:\n            t = time.localtime(userdata.validuntil)\n            validuntil = time.strftime(\"%d.%m.%Y\", t)\n\n        if \"time\" in userdata.options:\n            try:\n                _time = userdata.options[\"time\"][0]\n            except Exception:\n                _time = \"\"\n        else:\n            _time = \"\"\n\n        if \"limit_dl\" in userdata.options:\n            try:\n                limitdl = userdata.options[\"limit_dl\"][0]\n            except Exception:\n                limitdl = \"0\"\n        else:\n            limitdl = \"0\"\n\n        accs.append(\n            {\n                \"type\": userdata.type,\n                \"login\": userdata.login,\n                \"valid\": userdata.valid,\n                \"premium\": userdata.premium,\n                \"trafficleft\": trafficleft,\n                \"validuntil\": validuntil,\n                \"limitdl\": limitdl,\n                \"time\": _time,\n            }\n        )\n\n    all_users = api.get_all_userdata()\n    users = {}\n    for userdata in all_users.values():\n        name = userdata[\"name\"]\n        users[name] = {\"perms\": get_permission(userdata[\"permission\"])}\n        users[name][\"perms\"][\"admin\"] = userdata[\"role\"] == 0\n\n    admin_menu = {\n        \"permlist\": permlist(),\n        \"users\": users\n    }\n\n    context = {\n        \"conf\": {\"plugin\": plugin_menu, \"general\": conf_menu, \"accs\": accs, \"admin\": admin_menu},\n        \"types\": api.get_account_types(),\n    }\n    return render_template(\"settings.html\", **context)\n\n\n@bp.route(\"/pathchooser/\", endpoint=\"pathchooser\")\n@bp.route(\"/filechooser/\", endpoint=\"filechooser\")\n@login_required(\"SETTINGS\")\ndef pathchooser():\n    browse_for = \"folder\" if flask.request.endpoint == \"app.pathchooser\" else \"file\"\n    path = os.path.normpath(flask.request.args.get('path', \"\"))\n\n    if os.path.isfile(path):\n        oldfile = path\n        path = os.path.dirname(path)\n    else:\n        oldfile = \"\"\n\n    abs = False\n\n    if os.path.isdir(path):\n        if os.path.isabs(path):\n            cwd = os.path.realpath(path)\n            abs = True\n        else:\n            cwd = os.path.relpath(path)\n    else:\n        cwd = os.getcwd()\n\n    cwd = os.path.normpath(os.path.realpath(cwd))\n    parentdir = os.path.dirname(cwd)\n    if not abs:\n        if os.path.realpath(cwd) == os.path.realpath(\"/\"):\n            cwd = os.path.relpath(cwd)\n        else:\n            cwd = os.path.relpath(cwd) + os.path.sep\n        parentdir = os.path.relpath(parentdir) + os.path.sep\n\n    if os.path.realpath(cwd) == os.path.realpath(\"/\"):\n        parentdir = \"\"\n\n    try:\n        folders = os.listdir(cwd)\n    except Exception:\n        folders = []\n\n    files = []\n\n    for f in folders:\n        try:\n            data = {\"name\": f, \"fullpath\": os.path.join(cwd, f)}\n            data[\"sort\"] = data[\"fullpath\"].lower()\n            data[\"modified\"] = datetime.datetime.fromtimestamp(\n                int(os.path.getmtime(os.path.join(cwd, f)))\n            )\n            data[\"ext\"] = os.path.splitext(f)[1]\n        except Exception:\n            continue\n\n        if os.path.isfile(os.path.join(cwd, f)):\n            data[\"type\"] = \"file\"\n            data[\"size\"] = os.path.getsize(os.path.join(cwd, f))\n\n            power = 0\n            while (data[\"size\"] >> 10) > 0.3:\n                power += 1\n                data[\"size\"] >>= 10\n            units = (\"\", \"K\", \"M\", \"G\", \"T\")\n            data[\"unit\"] = units[power] + \"Byte\"\n        else:\n            data[\"type\"] = \"dir\"\n            data[\"size\"] = \"\"\n\n        files.append(data)\n\n    files = sorted(files, key=operator.itemgetter(\"type\", \"sort\"))\n\n    context = {\n        \"cwd\": cwd,\n        \"files\": files,\n        \"parentdir\": parentdir,\n        \"type\": browse_for,\n        \"oldfile\": oldfile,\n        \"absolute\": abs,\n    }\n    return render_template(\"pathchooser.html\", **context)\n\n\n@bp.route(\"/logs\", methods=[\"GET\", \"POST\"], endpoint=\"logs\")\n@bp.route(\"/logs/<int:start_line>\", methods=[\"GET\", \"POST\"], endpoint=\"logs\")\n@login_required(\"LOGS\")\ndef logs(start_line=-1):\n    s = flask.session\n    api = flask.current_app.config[\"PYLOAD_API\"]\n\n    per_page = s.get(\"perpage\", 34)\n    reversed = s.get(\"reversed\", False)\n\n    warning = \"\"\n    conf = api.get_config_value(\"log\", \"filelog\")\n    if not conf:\n        warning = \"Warning: File log is disabled, see settings page.\"\n\n    per_page_selection = ((20, 20), (34, 34), (40, 40), (100, 100), (0, \"all\"))\n    fro = None\n\n    if flask.request.method == \"POST\":\n        try:\n            from_form = flask.request.form[\"from\"]\n            fro = datetime.datetime.strptime(from_form, \"%Y-%m-%d %H:%M:%S\")\n        except Exception:\n            pass\n\n        per_page = int(flask.request.form.get(\"perpage\", 34))\n        s[\"perpage\"] = per_page\n\n        reversed = bool(flask.request.form.get(\"reversed\", False))\n        s[\"reversed\"] = reversed\n\n        # s.modified = True\n\n    log_entries = api.get_log()\n    if not per_page:\n        start_line = 0\n\n    if start_line < 1:\n        start_line = (\n            1 if len(log_entries) - per_page + 1 < 1 or per_page == 0 else len(log_entries) - per_page + 1\n        )\n\n    if isinstance(fro, datetime.datetime):  #: we will search for datetime.datetime\n        start_line = -1\n\n    data = []\n    inpage_counter = 0\n    for counter, logline in enumerate(log_entries, start=1):\n        if counter >= start_line:\n            try:\n                date, time, level, source, message = _RE_LOGLINE.match(logline).groups()\n                dtime = datetime.datetime.strptime(\n                    date + \" \" + time, \"%Y-%m-%d %H:%M:%S\"\n                )\n                message = message.strip()\n            except (AttributeError, IndexError):\n                dtime = None\n                date = \"?\"\n                time = \" \"\n                level = \"?\"\n                source = \"?\"\n                message = logline\n            if start_line == -1 and dtime is not None and fro <= dtime:\n                start_line = counter  #: found our datetime.datetime\n\n            if start_line >= 0:\n                data.append(\n                    {\n                        \"line\": counter,\n                        \"date\": date + \" \" + time,\n                        \"level\": level,\n                        \"source\": source,\n                        \"message\": message.rstrip('\\n'),\n                    }\n                )\n                inpage_counter += 1\n                if (\n                    fro is None and dtime is not None\n                ):  #: if fro not set, set it to first showed line\n                    fro = dtime\n            if inpage_counter >= per_page > 0:\n                break\n\n    if fro is None:  #: still not set, empty log?\n        fro = datetime.datetime.now()\n\n    if reversed:\n        data.reverse()\n\n    context = {\n        \"warning\": warning,\n        \"log\": data,\n        \"from\": fro.strftime(\"%Y-%m-%d %H:%M:%S\"),\n        \"reversed\": reversed,\n        \"perpage\": per_page,\n        \"perpage_p\": sorted(per_page_selection),\n        \"iprev\": max(start_line - per_page, 1),\n        \"inext\": (start_line + per_page) if start_line + per_page <= len(log_entries) else start_line,\n    }\n    return render_template(\"logs.html\", **context)\n\n\n@bp.route(\"/filemanager\", endpoint=\"filemanager\")\n@login_required(\"MODIFY\")\ndef filemanager(path):\n    return render_template(\"filemanager.html\")\n\n\n@bp.route(\"/info\", endpoint=\"info\")\n@login_required(\"STATUS\")\ndef info():\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    conf = api.get_config_dict()\n    extra = os.uname() if hasattr(os, \"uname\") else tuple()\n\n    context = {\n        \"python\": sys.version,\n        \"os\": \" \".join((os.name, sys.platform) + extra),\n        \"version\": api.get_server_version(),\n        \"folder\": PKGDIR,\n        \"config_folder\": api.get_userdir(),\n        \"download\": conf[\"general\"][\"storage_folder\"][\"value\"],\n        \"freespace\": format.size(api.free_space()),\n        \"webif\": conf[\"webui\"][\"port\"][\"value\"],\n        \"language\": conf[\"general\"][\"language\"][\"value\"],\n    }\n    return render_template(\"info.html\", **context)\n", "# -*- coding: utf-8 -*-\n\nimport json\nfrom functools import wraps\nfrom urllib.parse import urljoin, urlparse\n\nimport flask\nimport flask_themes2\nimport werkzeug.routing.exceptions\nfrom pyload.core.api import Perms, Role, has_permission\n\n\nclass JSONEncoder(json.JSONEncoder):\n    def default(self, obj):\n        try:\n            return dict(obj)\n        except TypeError:\n            pass\n        return super().default(obj)\n\n\ntry:\n    JSONProviderBase = flask.json.provider.JSONProvider\nexcept AttributeError:\n    pass\nelse:\n    class JSONProvider(JSONProviderBase):\n        def dumps(self, obj, **kwargs):\n            return json.dumps(obj, **kwargs, cls=JSONEncoder)\n\n        def loads(self, s, **kwargs):\n            return json.loads(s, **kwargs)\n\n\n#: Checks if location belongs to same host address\ndef is_safe_url(location):\n    location_urlp = urlparse(location)\n    #: if relative URL then must start with \"/\"\n    if not location_urlp.netloc and location[0] != \"/\":\n        return False\n    host_urlp = urlparse(flask.request.host_url)\n    test_urlp = urlparse(urljoin(flask.request.host_url, location))\n    return test_urlp.scheme in ('http', 'https') and host_urlp.netloc == test_urlp.netloc\n\n\ndef get_redirect_url(fallback=None):\n    next_arg = flask.request.values.get(\"next\")\n    redirect_url = flask.url_for(fallback)\n    if next_arg and next_arg != \"login\":  # don't redirect to same location\n        try:\n            redirect_url = flask.url_for(f\"app.{next_arg}\")\n        except werkzeug.routing.exceptions.BuildError:\n            pass\n\n    return urljoin(flask.request.url_root, redirect_url)\n\n\ndef render_base(messages):\n    return render_template(\"base.html\", messages=messages)\n\n\ndef clear_session(session=flask.session, permanent=True):\n    session.permanent = bool(permanent)\n    session.clear()\n    # session.modified = True\n\n\ndef current_theme_id():\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    return api.get_config_value(\"webui\", \"theme\").lower()\n\n\n#: tries to serve the file from the static directory of the current theme otherwise fallback to builtin one\ndef static_file_url(filename):\n    themeid = current_theme_id()\n    try:\n        url = flask_themes2.static_file_url(themeid, filename)\n    except KeyError:\n        url = flask.url_for(\"static\", filename=filename)\n    return url\n\n\ndef theme_template(filename):\n    return flask.url_for(\"app.render\", filename=filename)\n\n\n#: tries to render the template of the current theme otherwise fallback to builtin template\ndef render_template(template, **context):\n    themeid = current_theme_id()\n    return flask_themes2.render_theme_template(themeid, template, **context)\n\n\ndef parse_permissions(session=flask.session):\n    perms = {x.name: False for x in Perms}\n    perms[\"ADMIN\"] = False\n    perms[\"is_admin\"] = False\n\n    if not session.get(\"authenticated\", False):\n        return perms\n\n    perms[\"ANY\"] = True\n    if session.get(\"role\") == Role.ADMIN:\n        for key in perms.keys():\n            perms[key] = True\n\n    elif session.get(\"perms\"):\n        p = session.get(\"perms\")\n        perms.update(get_permission(p))\n\n    return perms\n\n\ndef permlist():\n    return [x.name for x in Perms if x.name != \"ANY\"]\n\n\ndef get_permission(userperms):\n    \"\"\"\n    Returns a dict with permission key.\n\n    :param userperms: permission bits\n    \"\"\"\n    return {\n        name: has_permission(userperms, getattr(Perms, name).value)\n        for name in permlist()\n    }\n\n\ndef set_permission(perms):\n    \"\"\"\n    generates permission bits from dictionary.\n\n    :param perms: dict\n    \"\"\"\n    permission = 0\n    for name in permlist():\n        if name.startswith(\"_\"):\n            continue\n\n        if name in perms and perms[name]:\n            permission |= getattr(Perms, name)\n\n    return permission\n\n\ndef set_session(user_info, session=flask.session, permanent=True):\n    session.permanent = bool(permanent)\n    session.update(\n        {\n            \"authenticated\": True,\n            \"id\": user_info[\"id\"],\n            \"name\": user_info[\"name\"],\n            \"role\": user_info[\"role\"],\n            \"perms\": user_info[\"permission\"],\n            \"template\": user_info[\"template\"],\n        }\n    )\n    # session.modified = True\n    return session\n\n\n# TODO: Recheck...\ndef parse_userdata(session=flask.session):\n    return {\n        \"name\": session.get(\"name\", \"Anonymous\"),\n        \"is_admin\": session.get(\"role\", 1) == 0,\n        \"is_authenticated\": session.get(\"authenticated\", False),\n    }\n\n\ndef apiver_check(func):\n    # if no apiver is provided assumes latest\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        api = flask.current_app.config[\"PYLOAD_API\"]\n        core_apiver = api.__version__\n        if int(kwargs.get(\"apiver\", core_apiver).strip(\"v\")) < core_apiver:\n            return \"Obsolete API\", 404\n        return func(*args, **kwargs)\n\n    return wrapper\n\n\ndef is_authenticated(session=flask.session):\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    user = session.get(\"name\")\n    authenticated = session.get(\"authenticated\")\n\n    return authenticated and api.user_exists(user)\n\n\ndef login_required(perm):\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            s = flask.session\n            #: already authenticated?\n            if is_authenticated(s):\n                perms = parse_permissions(s)\n                if perm not in perms or not perms[perm]:\n                    response = \"Forbidden\", 403\n                else:\n                    response = func(*args, **kwargs)\n\n            else:\n                clear_session(s)\n                if flask.request.headers.get(\"X-Requested-With\") == \"XMLHttpRequest\":\n                    response = \"Forbidden\", 403\n\n                else:\n                    location = flask.url_for(\n                        \"app.login\",\n                        next=flask.request.endpoint.split(\".\")[-1]\n                    )\n                    response = flask.redirect(location)\n\n            return response\n\n        return wrapper\n\n    return decorator\n"], "filenames": ["src/pyload/webui/app/blueprints/app_blueprint.py", "src/pyload/webui/app/helpers.py"], "buggy_code_start_loc": [50, 5], "buggy_code_end_loc": [80, 210], "fixing_code_start_loc": [50, 5], "fixing_code_end_loc": [80, 214], "type": "CWE-601", "message": "pyLoad is an open-source Download Manager written in pure Python. There is an open redirect vulnerability due to incorrect validation of input values when redirecting users after login. pyLoad is validating URLs via the `get_redirect_url` function when redirecting users at login. This vulnerability has been patched with commit fe94451.", "other": {"cve": {"id": "CVE-2024-24808", "sourceIdentifier": "security-advisories@github.com", "published": "2024-02-06T04:15:08.260", "lastModified": "2024-02-13T22:48:57.290", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "pyLoad is an open-source Download Manager written in pure Python. There is an open redirect vulnerability due to incorrect validation of input values when redirecting users after login. pyLoad is validating URLs via the `get_redirect_url` function when redirecting users at login. This vulnerability has been patched with commit fe94451."}, {"lang": "es", "value": "pyLoad es un administrador de descargas de c\u00f3digo abierto escrito en Python puro. Existe una vulnerabilidad de redireccionamiento abierto debido a la validaci\u00f3n incorrecta de los valores de entrada al redirigir a los usuarios despu\u00e9s de iniciar sesi\u00f3n. pyLoad valida las URL a trav\u00e9s de la funci\u00f3n `get_redirect_url` cuando redirige a los usuarios al iniciar sesi\u00f3n. Esta vulnerabilidad se ha solucionado con el commit fe94451."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-601"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pyload:pyload:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.5.0", "matchCriteriaId": "9347973D-3989-4969-8721-8A55ABBE2F6E"}]}]}], "references": [{"url": "https://github.com/pyload/pyload/commit/fe94451dcc2be90b3889e2fd9d07b483c8a6dccd", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/pyload/pyload/security/advisories/GHSA-g3cm-qg2v-2hj5", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/pyload/pyload/commit/fe94451dcc2be90b3889e2fd9d07b483c8a6dccd"}}