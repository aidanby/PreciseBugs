{"buggy_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * File System Virtual Channel\n *\n * Copyright 2010-2012 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2010-2011 Vic Lee\n * Copyright 2012 Gerald Richter\n * Copyright 2015 Thincast Technologies GmbH\n * Copyright 2015 DI (FH) Martin Haimberger <martin.haimberger@thincast.com>\n * Copyright 2016 Inuvika Inc.\n * Copyright 2016 David PHAM-VAN <d.phamvan@inuvika.com>\n * Copyright 2017 Armin Novak <armin.novak@thincast.com>\n * Copyright 2017 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#include <winpr/wtypes.h>\n#include <winpr/crt.h>\n#include <winpr/path.h>\n#include <winpr/file.h>\n#include <winpr/stream.h>\n\n#include <freerdp/channels/rdpdr.h>\n\n#include \"drive_file.h\"\n\n#ifdef WITH_DEBUG_RDPDR\n#define DEBUG_WSTR(msg, wstr)                                            \\\n\tdo                                                                   \\\n\t{                                                                    \\\n\t\tLPSTR lpstr;                                                     \\\n\t\tConvertFromUnicode(CP_UTF8, 0, wstr, -1, &lpstr, 0, NULL, NULL); \\\n\t\tWLog_DBG(TAG, msg, lpstr);                                       \\\n\t\tfree(lpstr);                                                     \\\n\t} while (0)\n#else\n#define DEBUG_WSTR(msg, wstr) \\\n\tdo                        \\\n\t{                         \\\n\t} while (0)\n#endif\n\nstatic void drive_file_fix_path(WCHAR* path)\n{\n\tsize_t i;\n\tsize_t length = _wcslen(path);\n\n\tfor (i = 0; i < length; i++)\n\t{\n\t\tif (path[i] == L'\\\\')\n\t\t\tpath[i] = L'/';\n\t}\n\n#ifdef WIN32\n\n\tif ((length == 3) && (path[1] == L':') && (path[2] == L'/'))\n\t\treturn;\n\n#else\n\n\tif ((length == 1) && (path[0] == L'/'))\n\t\treturn;\n\n#endif\n\n\tif ((length > 0) && (path[length - 1] == L'/'))\n\t\tpath[length - 1] = L'\\0';\n}\n\nstatic WCHAR* drive_file_combine_fullpath(const WCHAR* base_path, const WCHAR* path,\n                                          size_t PathLength)\n{\n\tWCHAR* fullpath;\n\tsize_t base_path_length;\n\n\tif (!base_path || (!path && (PathLength > 0)))\n\t\treturn NULL;\n\n\tbase_path_length = _wcslen(base_path) * 2;\n\tfullpath = (WCHAR*)calloc(1, base_path_length + PathLength + sizeof(WCHAR));\n\n\tif (!fullpath)\n\t{\n\t\tWLog_ERR(TAG, \"malloc failed!\");\n\t\treturn NULL;\n\t}\n\n\tCopyMemory(fullpath, base_path, base_path_length);\n\tif (path)\n\t\tCopyMemory((char*)fullpath + base_path_length, path, PathLength);\n\tdrive_file_fix_path(fullpath);\n\treturn fullpath;\n}\n\nstatic BOOL drive_file_remove_dir(const WCHAR* path)\n{\n\tWIN32_FIND_DATAW findFileData;\n\tBOOL ret = TRUE;\n\tHANDLE dir;\n\tWCHAR* fullpath;\n\tWCHAR* path_slash;\n\tsize_t base_path_length;\n\n\tif (!path)\n\t\treturn FALSE;\n\n\tbase_path_length = _wcslen(path) * 2;\n\tpath_slash = (WCHAR*)calloc(1, base_path_length + sizeof(WCHAR) * 3);\n\n\tif (!path_slash)\n\t{\n\t\tWLog_ERR(TAG, \"malloc failed!\");\n\t\treturn FALSE;\n\t}\n\n\tCopyMemory(path_slash, path, base_path_length);\n\tpath_slash[base_path_length / 2] = L'/';\n\tpath_slash[base_path_length / 2 + 1] = L'*';\n\tDEBUG_WSTR(\"Search in %s\", path_slash);\n\tdir = FindFirstFileW(path_slash, &findFileData);\n\tpath_slash[base_path_length / 2 + 1] = 0;\n\n\tif (dir == INVALID_HANDLE_VALUE)\n\t{\n\t\tfree(path_slash);\n\t\treturn FALSE;\n\t}\n\n\tdo\n\t{\n\t\tsize_t len = _wcslen(findFileData.cFileName);\n\n\t\tif ((len == 1 && findFileData.cFileName[0] == L'.') ||\n\t\t    (len == 2 && findFileData.cFileName[0] == L'.' && findFileData.cFileName[1] == L'.'))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tfullpath = drive_file_combine_fullpath(path_slash, findFileData.cFileName, len * 2);\n\t\tDEBUG_WSTR(\"Delete %s\", fullpath);\n\n\t\tif (findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)\n\t\t{\n\t\t\tret = drive_file_remove_dir(fullpath);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tret = DeleteFileW(fullpath);\n\t\t}\n\n\t\tfree(fullpath);\n\n\t\tif (!ret)\n\t\t\tbreak;\n\t} while (ret && FindNextFileW(dir, &findFileData) != 0);\n\n\tFindClose(dir);\n\n\tif (ret)\n\t{\n\t\tif (!RemoveDirectoryW(path))\n\t\t{\n\t\t\tret = FALSE;\n\t\t}\n\t}\n\n\tfree(path_slash);\n\treturn ret;\n}\n\nstatic BOOL drive_file_set_fullpath(DRIVE_FILE* file, WCHAR* fullpath)\n{\n\tif (!file || !fullpath)\n\t\treturn FALSE;\n\n\tfree(file->fullpath);\n\tfile->fullpath = fullpath;\n\tfile->filename = _wcsrchr(file->fullpath, L'/');\n\n\tif (file->filename == NULL)\n\t\tfile->filename = file->fullpath;\n\telse\n\t\tfile->filename += 1;\n\n\treturn TRUE;\n}\n\nstatic BOOL drive_file_init(DRIVE_FILE* file)\n{\n\tUINT CreateDisposition = 0;\n\tDWORD dwAttr = GetFileAttributesW(file->fullpath);\n\n\tif (dwAttr != INVALID_FILE_ATTRIBUTES)\n\t{\n\t\t/* The file exists */\n\t\tfile->is_dir = (dwAttr & FILE_ATTRIBUTE_DIRECTORY) != 0;\n\n\t\tif (file->is_dir)\n\t\t{\n\t\t\tif (file->CreateDisposition == FILE_CREATE)\n\t\t\t{\n\t\t\t\tSetLastError(ERROR_ALREADY_EXISTS);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tif (file->CreateOptions & FILE_NON_DIRECTORY_FILE)\n\t\t\t{\n\t\t\t\tSetLastError(ERROR_ACCESS_DENIED);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\treturn TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (file->CreateOptions & FILE_DIRECTORY_FILE)\n\t\t\t{\n\t\t\t\tSetLastError(ERROR_DIRECTORY);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tfile->is_dir = ((file->CreateOptions & FILE_DIRECTORY_FILE) ? TRUE : FALSE);\n\n\t\tif (file->is_dir)\n\t\t{\n\t\t\t/* Should only create the directory if the disposition allows for it */\n\t\t\tif ((file->CreateDisposition == FILE_OPEN_IF) ||\n\t\t\t    (file->CreateDisposition == FILE_CREATE))\n\t\t\t{\n\t\t\t\tif (CreateDirectoryW(file->fullpath, NULL) != 0)\n\t\t\t\t{\n\t\t\t\t\treturn TRUE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSetLastError(ERROR_FILE_NOT_FOUND);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tif (file->file_handle == INVALID_HANDLE_VALUE)\n\t{\n\t\tswitch (file->CreateDisposition)\n\t\t{\n\t\t\tcase FILE_SUPERSEDE: /* If the file already exists, replace it with the given file. If\n\t\t\t                        it does not, create the given file. */\n\t\t\t\tCreateDisposition = CREATE_ALWAYS;\n\t\t\t\tbreak;\n\n\t\t\tcase FILE_OPEN: /* If the file already exists, open it instead of creating a new file.\n\t\t\t                   If it does not, fail the request and do not create a new file. */\n\t\t\t\tCreateDisposition = OPEN_EXISTING;\n\t\t\t\tbreak;\n\n\t\t\tcase FILE_CREATE: /* If the file already exists, fail the request and do not create or\n\t\t\t                     open the given file. If it does not, create the given file. */\n\t\t\t\tCreateDisposition = CREATE_NEW;\n\t\t\t\tbreak;\n\n\t\t\tcase FILE_OPEN_IF: /* If the file already exists, open it. If it does not, create the\n\t\t\t                      given file. */\n\t\t\t\tCreateDisposition = OPEN_ALWAYS;\n\t\t\t\tbreak;\n\n\t\t\tcase FILE_OVERWRITE: /* If the file already exists, open it and overwrite it. If it does\n\t\t\t                        not, fail the request. */\n\t\t\t\tCreateDisposition = TRUNCATE_EXISTING;\n\t\t\t\tbreak;\n\n\t\t\tcase FILE_OVERWRITE_IF: /* If the file already exists, open it and overwrite it. If it\n\t\t\t                           does not, create the given file. */\n\t\t\t\tCreateDisposition = CREATE_ALWAYS;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n#ifndef WIN32\n\t\tfile->SharedAccess = 0;\n#endif\n\t\tfile->file_handle = CreateFileW(file->fullpath, file->DesiredAccess, file->SharedAccess,\n\t\t                                NULL, CreateDisposition, file->FileAttributes, NULL);\n\t}\n\n#ifdef WIN32\n\tif (file->file_handle == INVALID_HANDLE_VALUE)\n\t{\n\t\t/* Get the error message, if any. */\n\t\tDWORD errorMessageID = GetLastError();\n\n\t\tif (errorMessageID != 0)\n\t\t{\n\t\t\tLPSTR messageBuffer = NULL;\n\t\t\tsize_t size =\n\t\t\t    FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |\n\t\t\t                       FORMAT_MESSAGE_IGNORE_INSERTS,\n\t\t\t                   NULL, errorMessageID, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n\t\t\t                   (LPSTR)&messageBuffer, 0, NULL);\n\t\t\tWLog_ERR(TAG, \"Error in drive_file_init: %s %s\", messageBuffer, file->fullpath);\n\t\t\t/* Free the buffer. */\n\t\t\tLocalFree(messageBuffer);\n\t\t\t/* restore original error code */\n\t\t\tSetLastError(errorMessageID);\n\t\t}\n\t}\n#endif\n\n\treturn file->file_handle != INVALID_HANDLE_VALUE;\n}\n\nDRIVE_FILE* drive_file_new(const WCHAR* base_path, const WCHAR* path, UINT32 PathLength, UINT32 id,\n                           UINT32 DesiredAccess, UINT32 CreateDisposition, UINT32 CreateOptions,\n                           UINT32 FileAttributes, UINT32 SharedAccess)\n{\n\tDRIVE_FILE* file;\n\n\tif (!base_path || (!path && (PathLength > 0)))\n\t\treturn NULL;\n\n\tfile = (DRIVE_FILE*)calloc(1, sizeof(DRIVE_FILE));\n\n\tif (!file)\n\t{\n\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\treturn NULL;\n\t}\n\n\tfile->file_handle = INVALID_HANDLE_VALUE;\n\tfile->find_handle = INVALID_HANDLE_VALUE;\n\tfile->id = id;\n\tfile->basepath = base_path;\n\tfile->FileAttributes = FileAttributes;\n\tfile->DesiredAccess = DesiredAccess;\n\tfile->CreateDisposition = CreateDisposition;\n\tfile->CreateOptions = CreateOptions;\n\tfile->SharedAccess = SharedAccess;\n\tdrive_file_set_fullpath(file, drive_file_combine_fullpath(base_path, path, PathLength));\n\n\tif (!drive_file_init(file))\n\t{\n\t\tDWORD lastError = GetLastError();\n\t\tdrive_file_free(file);\n\t\tSetLastError(lastError);\n\t\treturn NULL;\n\t}\n\n\treturn file;\n}\n\nBOOL drive_file_free(DRIVE_FILE* file)\n{\n\tBOOL rc = FALSE;\n\n\tif (!file)\n\t\treturn FALSE;\n\n\tif (file->file_handle != INVALID_HANDLE_VALUE)\n\t{\n\t\tCloseHandle(file->file_handle);\n\t\tfile->file_handle = INVALID_HANDLE_VALUE;\n\t}\n\n\tif (file->find_handle != INVALID_HANDLE_VALUE)\n\t{\n\t\tFindClose(file->find_handle);\n\t\tfile->find_handle = INVALID_HANDLE_VALUE;\n\t}\n\n\tif (file->delete_pending)\n\t{\n\t\tif (file->is_dir)\n\t\t{\n\t\t\tif (!drive_file_remove_dir(file->fullpath))\n\t\t\t\tgoto fail;\n\t\t}\n\t\telse if (!DeleteFileW(file->fullpath))\n\t\t\tgoto fail;\n\t}\n\n\trc = TRUE;\nfail:\n\tDEBUG_WSTR(\"Free %s\", file->fullpath);\n\tfree(file->fullpath);\n\tfree(file);\n\treturn rc;\n}\n\nBOOL drive_file_seek(DRIVE_FILE* file, UINT64 Offset)\n{\n\tLARGE_INTEGER loffset;\n\n\tif (!file)\n\t\treturn FALSE;\n\n\tif (Offset > INT64_MAX)\n\t\treturn FALSE;\n\n\tloffset.QuadPart = (LONGLONG)Offset;\n\treturn SetFilePointerEx(file->file_handle, loffset, NULL, FILE_BEGIN);\n}\n\nBOOL drive_file_read(DRIVE_FILE* file, BYTE* buffer, UINT32* Length)\n{\n\tUINT32 read;\n\n\tif (!file || !buffer || !Length)\n\t\treturn FALSE;\n\n\tDEBUG_WSTR(\"Read file %s\", file->fullpath);\n\n\tif (ReadFile(file->file_handle, buffer, *Length, &read, NULL))\n\t{\n\t\t*Length = read;\n\t\treturn TRUE;\n\t}\n\n\treturn FALSE;\n}\n\nBOOL drive_file_write(DRIVE_FILE* file, BYTE* buffer, UINT32 Length)\n{\n\tUINT32 written;\n\n\tif (!file || !buffer)\n\t\treturn FALSE;\n\n\tDEBUG_WSTR(\"Write file %s\", file->fullpath);\n\n\twhile (Length > 0)\n\t{\n\t\tif (!WriteFile(file->file_handle, buffer, Length, &written, NULL))\n\t\t\treturn FALSE;\n\n\t\tLength -= written;\n\t\tbuffer += written;\n\t}\n\n\treturn TRUE;\n}\n\nBOOL drive_file_query_information(DRIVE_FILE* file, UINT32 FsInformationClass, wStream* output)\n{\n\tWIN32_FILE_ATTRIBUTE_DATA fileAttributes;\n\tDEBUG_WSTR(\"FindFirstFile %s\", file->fullpath);\n\n\tif (!file || !output)\n\t\treturn FALSE;\n\n\tif (!GetFileAttributesExW(file->fullpath, GetFileExInfoStandard, &fileAttributes))\n\t\tgoto out_fail;\n\n\tswitch (FsInformationClass)\n\t{\n\t\tcase FileBasicInformation:\n\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232094.aspx */\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 4 + 36))\n\t\t\t\tgoto out_fail;\n\n\t\t\tStream_Write_UINT32(output, 36); /* Length */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    fileAttributes.ftCreationTime.dwLowDateTime); /* CreationTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    fileAttributes.ftCreationTime.dwHighDateTime); /* CreationTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    fileAttributes.ftLastAccessTime.dwLowDateTime); /* LastAccessTime */\n\t\t\tStream_Write_UINT32(\n\t\t\t    output, fileAttributes.ftLastAccessTime.dwHighDateTime); /* LastAccessTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    fileAttributes.ftLastWriteTime.dwLowDateTime); /* LastWriteTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    fileAttributes.ftLastWriteTime.dwHighDateTime); /* LastWriteTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    fileAttributes.ftLastWriteTime.dwLowDateTime); /* ChangeTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    fileAttributes.ftLastWriteTime.dwHighDateTime); /* ChangeTime */\n\t\t\tStream_Write_UINT32(output, fileAttributes.dwFileAttributes);       /* FileAttributes */\n\t\t\t/* Reserved(4), MUST NOT be added! */\n\t\t\tbreak;\n\n\t\tcase FileStandardInformation:\n\n\t\t\t/*  http://msdn.microsoft.com/en-us/library/cc232088.aspx */\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 4 + 22))\n\t\t\t\tgoto out_fail;\n\n\t\t\tStream_Write_UINT32(output, 22);                           /* Length */\n\t\t\tStream_Write_UINT32(output, fileAttributes.nFileSizeLow);  /* AllocationSize */\n\t\t\tStream_Write_UINT32(output, fileAttributes.nFileSizeHigh); /* AllocationSize */\n\t\t\tStream_Write_UINT32(output, fileAttributes.nFileSizeLow);  /* EndOfFile */\n\t\t\tStream_Write_UINT32(output, fileAttributes.nFileSizeHigh); /* EndOfFile */\n\t\t\tStream_Write_UINT32(output, 0);                            /* NumberOfLinks */\n\t\t\tStream_Write_UINT8(output, file->delete_pending ? 1 : 0);  /* DeletePending */\n\t\t\tStream_Write_UINT8(output, fileAttributes.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY\n\t\t\t                               ? TRUE\n\t\t\t                               : FALSE); /* Directory */\n\t\t\t/* Reserved(2), MUST NOT be added! */\n\t\t\tbreak;\n\n\t\tcase FileAttributeTagInformation:\n\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232093.aspx */\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 4 + 8))\n\t\t\t\tgoto out_fail;\n\n\t\t\tStream_Write_UINT32(output, 8);                               /* Length */\n\t\t\tStream_Write_UINT32(output, fileAttributes.dwFileAttributes); /* FileAttributes */\n\t\t\tStream_Write_UINT32(output, 0);                               /* ReparseTag */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Unhandled FsInformationClass */\n\t\t\tgoto out_fail;\n\t}\n\n\treturn TRUE;\nout_fail:\n\tStream_Write_UINT32(output, 0); /* Length */\n\treturn FALSE;\n}\n\nBOOL drive_file_set_information(DRIVE_FILE* file, UINT32 FsInformationClass, UINT32 Length,\n                                wStream* input)\n{\n\tINT64 size;\n\tWCHAR* fullpath;\n\tULARGE_INTEGER liCreationTime;\n\tULARGE_INTEGER liLastAccessTime;\n\tULARGE_INTEGER liLastWriteTime;\n\tULARGE_INTEGER liChangeTime;\n\tFILETIME ftCreationTime;\n\tFILETIME ftLastAccessTime;\n\tFILETIME ftLastWriteTime;\n\tFILETIME* pftCreationTime = NULL;\n\tFILETIME* pftLastAccessTime = NULL;\n\tFILETIME* pftLastWriteTime = NULL;\n\tUINT32 FileAttributes;\n\tUINT32 FileNameLength;\n\tLARGE_INTEGER liSize;\n\tUINT8 delete_pending;\n\tUINT8 ReplaceIfExists;\n\tDWORD attr;\n\n\tif (!file || !input)\n\t\treturn FALSE;\n\n\tswitch (FsInformationClass)\n\t{\n\t\tcase FileBasicInformation:\n\t\t\tif (Stream_GetRemainingLength(input) < 36)\n\t\t\t\treturn FALSE;\n\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232094.aspx */\n\t\t\tStream_Read_UINT64(input, liCreationTime.QuadPart);\n\t\t\tStream_Read_UINT64(input, liLastAccessTime.QuadPart);\n\t\t\tStream_Read_UINT64(input, liLastWriteTime.QuadPart);\n\t\t\tStream_Read_UINT64(input, liChangeTime.QuadPart);\n\t\t\tStream_Read_UINT32(input, FileAttributes);\n\n\t\t\tif (!PathFileExistsW(file->fullpath))\n\t\t\t\treturn FALSE;\n\n\t\t\tif (file->file_handle == INVALID_HANDLE_VALUE)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Unable to set file time %s (%\" PRId32 \")\", file->fullpath,\n\t\t\t\t         GetLastError());\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tif (liCreationTime.QuadPart != 0)\n\t\t\t{\n\t\t\t\tftCreationTime.dwHighDateTime = liCreationTime.u.HighPart;\n\t\t\t\tftCreationTime.dwLowDateTime = liCreationTime.u.LowPart;\n\t\t\t\tpftCreationTime = &ftCreationTime;\n\t\t\t}\n\n\t\t\tif (liLastAccessTime.QuadPart != 0)\n\t\t\t{\n\t\t\t\tftLastAccessTime.dwHighDateTime = liLastAccessTime.u.HighPart;\n\t\t\t\tftLastAccessTime.dwLowDateTime = liLastAccessTime.u.LowPart;\n\t\t\t\tpftLastAccessTime = &ftLastAccessTime;\n\t\t\t}\n\n\t\t\tif (liLastWriteTime.QuadPart != 0)\n\t\t\t{\n\t\t\t\tftLastWriteTime.dwHighDateTime = liLastWriteTime.u.HighPart;\n\t\t\t\tftLastWriteTime.dwLowDateTime = liLastWriteTime.u.LowPart;\n\t\t\t\tpftLastWriteTime = &ftLastWriteTime;\n\t\t\t}\n\n\t\t\tif (liChangeTime.QuadPart != 0 && liChangeTime.QuadPart > liLastWriteTime.QuadPart)\n\t\t\t{\n\t\t\t\tftLastWriteTime.dwHighDateTime = liChangeTime.u.HighPart;\n\t\t\t\tftLastWriteTime.dwLowDateTime = liChangeTime.u.LowPart;\n\t\t\t\tpftLastWriteTime = &ftLastWriteTime;\n\t\t\t}\n\n\t\t\tDEBUG_WSTR(\"SetFileTime %s\", file->fullpath);\n\n\t\t\tSetFileAttributesW(file->fullpath, FileAttributes);\n\t\t\tif (!SetFileTime(file->file_handle, pftCreationTime, pftLastAccessTime,\n\t\t\t                 pftLastWriteTime))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Unable to set file time to %s\", file->fullpath);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase FileEndOfFileInformation:\n\n\t\t/* http://msdn.microsoft.com/en-us/library/cc232067.aspx */\n\t\tcase FileAllocationInformation:\n\t\t\tif (Stream_GetRemainingLength(input) < 8)\n\t\t\t\treturn FALSE;\n\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232076.aspx */\n\t\t\tStream_Read_INT64(input, size);\n\n\t\t\tif (file->file_handle == INVALID_HANDLE_VALUE)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Unable to truncate %s to %\" PRId64 \" (%\" PRId32 \")\", file->fullpath,\n\t\t\t\t         size, GetLastError());\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tliSize.QuadPart = size;\n\n\t\t\tif (!SetFilePointerEx(file->file_handle, liSize, NULL, FILE_BEGIN))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Unable to truncate %s to %d (%\" PRId32 \")\", file->fullpath, size,\n\t\t\t\t         GetLastError());\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tDEBUG_WSTR(\"Truncate %s\", file->fullpath);\n\n\t\t\tif (SetEndOfFile(file->file_handle) == 0)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Unable to truncate %s to %d (%\" PRId32 \")\", file->fullpath, size,\n\t\t\t\t         GetLastError());\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase FileDispositionInformation:\n\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232098.aspx */\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc241371.aspx */\n\t\t\tif (file->is_dir && !PathIsDirectoryEmptyW(file->fullpath))\n\t\t\t\tbreak; /* TODO: SetLastError ??? */\n\n\t\t\tif (Length)\n\t\t\t{\n\t\t\t\tif (Stream_GetRemainingLength(input) < 1)\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tStream_Read_UINT8(input, delete_pending);\n\t\t\t}\n\t\t\telse\n\t\t\t\tdelete_pending = 1;\n\n\t\t\tif (delete_pending)\n\t\t\t{\n\t\t\t\tDEBUG_WSTR(\"SetDeletePending %s\", file->fullpath);\n\t\t\t\tattr = GetFileAttributesW(file->fullpath);\n\n\t\t\t\tif (attr & FILE_ATTRIBUTE_READONLY)\n\t\t\t\t{\n\t\t\t\t\tSetLastError(ERROR_ACCESS_DENIED);\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfile->delete_pending = delete_pending;\n\t\t\tbreak;\n\n\t\tcase FileRenameInformation:\n\t\t\tif (Stream_GetRemainingLength(input) < 6)\n\t\t\t\treturn FALSE;\n\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232085.aspx */\n\t\t\tStream_Read_UINT8(input, ReplaceIfExists);\n\t\t\tStream_Seek_UINT8(input); /* RootDirectory */\n\t\t\tStream_Read_UINT32(input, FileNameLength);\n\n\t\t\tif (Stream_GetRemainingLength(input) < FileNameLength)\n\t\t\t\treturn FALSE;\n\n\t\t\tfullpath = drive_file_combine_fullpath(file->basepath, (WCHAR*)Stream_Pointer(input),\n\t\t\t                                       FileNameLength);\n\n\t\t\tif (!fullpath)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"drive_file_combine_fullpath failed!\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n#ifdef _WIN32\n\n\t\t\tif (file->file_handle != INVALID_HANDLE_VALUE)\n\t\t\t{\n\t\t\t\tCloseHandle(file->file_handle);\n\t\t\t\tfile->file_handle = INVALID_HANDLE_VALUE;\n\t\t\t}\n\n#endif\n\t\t\tDEBUG_WSTR(\"MoveFileExW %s\", file->fullpath);\n\n\t\t\tif (MoveFileExW(file->fullpath, fullpath,\n\t\t\t                MOVEFILE_COPY_ALLOWED |\n\t\t\t                    (ReplaceIfExists ? MOVEFILE_REPLACE_EXISTING : 0)))\n\t\t\t{\n\t\t\t\tif (!drive_file_set_fullpath(file, fullpath))\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n#ifdef _WIN32\n\t\t\tdrive_file_init(file);\n#endif\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nBOOL drive_file_query_directory(DRIVE_FILE* file, UINT32 FsInformationClass, BYTE InitialQuery,\n                                const WCHAR* path, UINT32 PathLength, wStream* output)\n{\n\tsize_t length;\n\tWCHAR* ent_path;\n\n\tif (!file || !path || !output)\n\t\treturn FALSE;\n\n\tif (InitialQuery != 0)\n\t{\n\t\t/* release search handle */\n\t\tif (file->find_handle != INVALID_HANDLE_VALUE)\n\t\t\tFindClose(file->find_handle);\n\n\t\tent_path = drive_file_combine_fullpath(file->basepath, path, PathLength);\n\t\t/* open new search handle and retrieve the first entry */\n\t\tfile->find_handle = FindFirstFileW(ent_path, &file->find_data);\n\t\tfree(ent_path);\n\n\t\tif (file->find_handle == INVALID_HANDLE_VALUE)\n\t\t\tgoto out_fail;\n\t}\n\telse if (!FindNextFileW(file->find_handle, &file->find_data))\n\t\tgoto out_fail;\n\n\tlength = _wcslen(file->find_data.cFileName) * 2;\n\n\tswitch (FsInformationClass)\n\t{\n\t\tcase FileDirectoryInformation:\n\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232097.aspx */\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 4 + 64 + length))\n\t\t\t\tgoto out_fail;\n\n\t\t\tif (length > UINT32_MAX - 64)\n\t\t\t\tgoto out_fail;\n\n\t\t\tStream_Write_UINT32(output, (UINT32)(64 + length)); /* Length */\n\t\t\tStream_Write_UINT32(output, 0);                     /* NextEntryOffset */\n\t\t\tStream_Write_UINT32(output, 0);                     /* FileIndex */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftCreationTime.dwLowDateTime); /* CreationTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftCreationTime.dwHighDateTime); /* CreationTime */\n\t\t\tStream_Write_UINT32(\n\t\t\t    output, file->find_data.ftLastAccessTime.dwLowDateTime); /* LastAccessTime */\n\t\t\tStream_Write_UINT32(\n\t\t\t    output, file->find_data.ftLastAccessTime.dwHighDateTime); /* LastAccessTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftLastWriteTime.dwLowDateTime); /* LastWriteTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftLastWriteTime.dwHighDateTime); /* LastWriteTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftLastWriteTime.dwLowDateTime); /* ChangeTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftLastWriteTime.dwHighDateTime); /* ChangeTime */\n\t\t\tStream_Write_UINT32(output, file->find_data.nFileSizeLow);           /* EndOfFile */\n\t\t\tStream_Write_UINT32(output, file->find_data.nFileSizeHigh);          /* EndOfFile */\n\t\t\tStream_Write_UINT32(output, file->find_data.nFileSizeLow);     /* AllocationSize */\n\t\t\tStream_Write_UINT32(output, file->find_data.nFileSizeHigh);    /* AllocationSize */\n\t\t\tStream_Write_UINT32(output, file->find_data.dwFileAttributes); /* FileAttributes */\n\t\t\tStream_Write_UINT32(output, (UINT32)length);                   /* FileNameLength */\n\t\t\tStream_Write(output, file->find_data.cFileName, length);\n\t\t\tbreak;\n\n\t\tcase FileFullDirectoryInformation:\n\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232068.aspx */\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 4 + 68 + length))\n\t\t\t\tgoto out_fail;\n\n\t\t\tif (length > UINT32_MAX - 68)\n\t\t\t\tgoto out_fail;\n\n\t\t\tStream_Write_UINT32(output, (UINT32)(68 + length)); /* Length */\n\t\t\tStream_Write_UINT32(output, 0);                     /* NextEntryOffset */\n\t\t\tStream_Write_UINT32(output, 0);                     /* FileIndex */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftCreationTime.dwLowDateTime); /* CreationTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftCreationTime.dwHighDateTime); /* CreationTime */\n\t\t\tStream_Write_UINT32(\n\t\t\t    output, file->find_data.ftLastAccessTime.dwLowDateTime); /* LastAccessTime */\n\t\t\tStream_Write_UINT32(\n\t\t\t    output, file->find_data.ftLastAccessTime.dwHighDateTime); /* LastAccessTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftLastWriteTime.dwLowDateTime); /* LastWriteTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftLastWriteTime.dwHighDateTime); /* LastWriteTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftLastWriteTime.dwLowDateTime); /* ChangeTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftLastWriteTime.dwHighDateTime); /* ChangeTime */\n\t\t\tStream_Write_UINT32(output, file->find_data.nFileSizeLow);           /* EndOfFile */\n\t\t\tStream_Write_UINT32(output, file->find_data.nFileSizeHigh);          /* EndOfFile */\n\t\t\tStream_Write_UINT32(output, file->find_data.nFileSizeLow);     /* AllocationSize */\n\t\t\tStream_Write_UINT32(output, file->find_data.nFileSizeHigh);    /* AllocationSize */\n\t\t\tStream_Write_UINT32(output, file->find_data.dwFileAttributes); /* FileAttributes */\n\t\t\tStream_Write_UINT32(output, (UINT32)length);                   /* FileNameLength */\n\t\t\tStream_Write_UINT32(output, 0);                                /* EaSize */\n\t\t\tStream_Write(output, file->find_data.cFileName, length);\n\t\t\tbreak;\n\n\t\tcase FileBothDirectoryInformation:\n\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232095.aspx */\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 4 + 93 + length))\n\t\t\t\tgoto out_fail;\n\n\t\t\tif (length > UINT32_MAX - 93)\n\t\t\t\tgoto out_fail;\n\n\t\t\tStream_Write_UINT32(output, (UINT32)(93 + length)); /* Length */\n\t\t\tStream_Write_UINT32(output, 0);                     /* NextEntryOffset */\n\t\t\tStream_Write_UINT32(output, 0);                     /* FileIndex */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftCreationTime.dwLowDateTime); /* CreationTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftCreationTime.dwHighDateTime); /* CreationTime */\n\t\t\tStream_Write_UINT32(\n\t\t\t    output, file->find_data.ftLastAccessTime.dwLowDateTime); /* LastAccessTime */\n\t\t\tStream_Write_UINT32(\n\t\t\t    output, file->find_data.ftLastAccessTime.dwHighDateTime); /* LastAccessTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftLastWriteTime.dwLowDateTime); /* LastWriteTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftLastWriteTime.dwHighDateTime); /* LastWriteTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftLastWriteTime.dwLowDateTime); /* ChangeTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftLastWriteTime.dwHighDateTime); /* ChangeTime */\n\t\t\tStream_Write_UINT32(output, file->find_data.nFileSizeLow);           /* EndOfFile */\n\t\t\tStream_Write_UINT32(output, file->find_data.nFileSizeHigh);          /* EndOfFile */\n\t\t\tStream_Write_UINT32(output, file->find_data.nFileSizeLow);     /* AllocationSize */\n\t\t\tStream_Write_UINT32(output, file->find_data.nFileSizeHigh);    /* AllocationSize */\n\t\t\tStream_Write_UINT32(output, file->find_data.dwFileAttributes); /* FileAttributes */\n\t\t\tStream_Write_UINT32(output, (UINT32)length);                   /* FileNameLength */\n\t\t\tStream_Write_UINT32(output, 0);                                /* EaSize */\n\t\t\tStream_Write_UINT8(output, 0);                                 /* ShortNameLength */\n\t\t\t/* Reserved(1), MUST NOT be added! */\n\t\t\tStream_Zero(output, 24); /* ShortName */\n\t\t\tStream_Write(output, file->find_data.cFileName, length);\n\t\t\tbreak;\n\n\t\tcase FileNamesInformation:\n\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232077.aspx */\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 4 + 12 + length))\n\t\t\t\tgoto out_fail;\n\n\t\t\tif (length > UINT32_MAX - 12)\n\t\t\t\tgoto out_fail;\n\n\t\t\tStream_Write_UINT32(output, (UINT32)(12 + length)); /* Length */\n\t\t\tStream_Write_UINT32(output, 0);                     /* NextEntryOffset */\n\t\t\tStream_Write_UINT32(output, 0);                     /* FileIndex */\n\t\t\tStream_Write_UINT32(output, (UINT32)length);        /* FileNameLength */\n\t\t\tStream_Write(output, file->find_data.cFileName, length);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"unhandled FsInformationClass %\" PRIu32, FsInformationClass);\n\t\t\t/* Unhandled FsInformationClass */\n\t\t\tgoto out_fail;\n\t}\n\n\treturn TRUE;\nout_fail:\n\tStream_Write_UINT32(output, 0); /* Length */\n\tStream_Write_UINT8(output, 0);  /* Padding */\n\treturn FALSE;\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * File System Virtual Channel\n *\n * Copyright 2010-2012 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2010-2011 Vic Lee\n * Copyright 2012 Gerald Richter\n * Copyright 2015 Thincast Technologies GmbH\n * Copyright 2015 DI (FH) Martin Haimberger <martin.haimberger@thincast.com>\n * Copyright 2016 Inuvika Inc.\n * Copyright 2016 David PHAM-VAN <d.phamvan@inuvika.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef FREERDP_CHANNEL_DRIVE_CLIENT_FILE_H\n#define FREERDP_CHANNEL_DRIVE_CLIENT_FILE_H\n\n#include <winpr/stream.h>\n#include <freerdp/channels/log.h>\n\n#define TAG CHANNELS_TAG(\"drive.client\")\n\ntypedef struct _DRIVE_FILE DRIVE_FILE;\n\nstruct _DRIVE_FILE\n{\n\tUINT32 id;\n\tBOOL is_dir;\n\tHANDLE file_handle;\n\tHANDLE find_handle;\n\tWIN32_FIND_DATAW find_data;\n\tconst WCHAR* basepath;\n\tWCHAR* fullpath;\n\tWCHAR* filename;\n\tBOOL delete_pending;\n\tUINT32 FileAttributes;\n\tUINT32 SharedAccess;\n\tUINT32 DesiredAccess;\n\tUINT32 CreateDisposition;\n\tUINT32 CreateOptions;\n};\n\nDRIVE_FILE* drive_file_new(const WCHAR* base_path, const WCHAR* path, UINT32 PathLength, UINT32 id,\n                           UINT32 DesiredAccess, UINT32 CreateDisposition, UINT32 CreateOptions,\n                           UINT32 FileAttributes, UINT32 SharedAccess);\nBOOL drive_file_free(DRIVE_FILE* file);\n\nBOOL drive_file_open(DRIVE_FILE* file);\nBOOL drive_file_seek(DRIVE_FILE* file, UINT64 Offset);\nBOOL drive_file_read(DRIVE_FILE* file, BYTE* buffer, UINT32* Length);\nBOOL drive_file_write(DRIVE_FILE* file, BYTE* buffer, UINT32 Length);\nBOOL drive_file_query_information(DRIVE_FILE* file, UINT32 FsInformationClass, wStream* output);\nBOOL drive_file_set_information(DRIVE_FILE* file, UINT32 FsInformationClass, UINT32 Length,\n                                wStream* input);\nBOOL drive_file_query_directory(DRIVE_FILE* file, UINT32 FsInformationClass, BYTE InitialQuery,\n                                const WCHAR* path, UINT32 PathLength, wStream* output);\n\n#endif /* FREERDP_CHANNEL_DRIVE_FILE_H */\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * File System Virtual Channel\n *\n * Copyright 2010-2011 Vic Lee\n * Copyright 2010-2012 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2015 Thincast Technologies GmbH\n * Copyright 2015 DI (FH) Martin Haimberger <martin.haimberger@thincast.com>\n * Copyright 2016 David PHAM-VAN <d.phamvan@inuvika.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <winpr/crt.h>\n#include <winpr/path.h>\n#include <winpr/file.h>\n#include <winpr/string.h>\n#include <winpr/synch.h>\n#include <winpr/thread.h>\n#include <winpr/stream.h>\n#include <winpr/environment.h>\n#include <winpr/interlocked.h>\n#include <winpr/collections.h>\n#include <winpr/shell.h>\n\n#include <freerdp/channels/rdpdr.h>\n\n#include \"drive_file.h\"\n\ntypedef struct _DRIVE_DEVICE DRIVE_DEVICE;\n\nstruct _DRIVE_DEVICE\n{\n\tDEVICE device;\n\n\tWCHAR* path;\n\tBOOL automount;\n\tUINT32 PathLength;\n\twListDictionary* files;\n\n\tHANDLE thread;\n\twMessageQueue* IrpQueue;\n\n\tDEVMAN* devman;\n\n\trdpContext* rdpcontext;\n};\n\nstatic UINT sys_code_page = 0;\n\nstatic DWORD drive_map_windows_err(DWORD fs_errno)\n{\n\tDWORD rc;\n\n\t/* try to return NTSTATUS version of error code */\n\n\tswitch (fs_errno)\n\t{\n\t\tcase STATUS_SUCCESS:\n\t\t\trc = STATUS_SUCCESS;\n\t\t\tbreak;\n\n\t\tcase ERROR_ACCESS_DENIED:\n\t\tcase ERROR_SHARING_VIOLATION:\n\t\t\trc = STATUS_ACCESS_DENIED;\n\t\t\tbreak;\n\n\t\tcase ERROR_FILE_NOT_FOUND:\n\t\t\trc = STATUS_NO_SUCH_FILE;\n\t\t\tbreak;\n\n\t\tcase ERROR_BUSY_DRIVE:\n\t\t\trc = STATUS_DEVICE_BUSY;\n\t\t\tbreak;\n\n\t\tcase ERROR_INVALID_DRIVE:\n\t\t\trc = STATUS_NO_SUCH_DEVICE;\n\t\t\tbreak;\n\n\t\tcase ERROR_NOT_READY:\n\t\t\trc = STATUS_NO_SUCH_DEVICE;\n\t\t\tbreak;\n\n\t\tcase ERROR_FILE_EXISTS:\n\t\tcase ERROR_ALREADY_EXISTS:\n\t\t\trc = STATUS_OBJECT_NAME_COLLISION;\n\t\t\tbreak;\n\n\t\tcase ERROR_INVALID_NAME:\n\t\t\trc = STATUS_NO_SUCH_FILE;\n\t\t\tbreak;\n\n\t\tcase ERROR_INVALID_HANDLE:\n\t\t\trc = STATUS_INVALID_HANDLE;\n\t\t\tbreak;\n\n\t\tcase ERROR_NO_MORE_FILES:\n\t\t\trc = STATUS_NO_MORE_FILES;\n\t\t\tbreak;\n\n\t\tcase ERROR_DIRECTORY:\n\t\t\trc = STATUS_NOT_A_DIRECTORY;\n\t\t\tbreak;\n\n\t\tcase ERROR_PATH_NOT_FOUND:\n\t\t\trc = STATUS_OBJECT_PATH_NOT_FOUND;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\trc = STATUS_UNSUCCESSFUL;\n\t\t\tWLog_ERR(TAG, \"Error code not found: %\" PRIu32 \"\", fs_errno);\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic DRIVE_FILE* drive_get_file_by_id(DRIVE_DEVICE* drive, UINT32 id)\n{\n\tDRIVE_FILE* file = NULL;\n\tvoid* key = (void*)(size_t)id;\n\n\tif (!drive)\n\t\treturn NULL;\n\n\tfile = (DRIVE_FILE*)ListDictionary_GetItemValue(drive->files, key);\n\treturn file;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_create(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tUINT32 FileId;\n\tDRIVE_FILE* file;\n\tBYTE Information;\n\tUINT32 FileAttributes;\n\tUINT32 SharedAccess;\n\tUINT32 DesiredAccess;\n\tUINT32 CreateDisposition;\n\tUINT32 CreateOptions;\n\tUINT32 PathLength;\n\tUINT64 allocationSize;\n\tconst WCHAR* path;\n\n\tif (!drive || !irp || !irp->devman || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 6 * 4 + 8)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, DesiredAccess);\n\tStream_Read_UINT64(irp->input, allocationSize);\n\tStream_Read_UINT32(irp->input, FileAttributes);\n\tStream_Read_UINT32(irp->input, SharedAccess);\n\tStream_Read_UINT32(irp->input, CreateDisposition);\n\tStream_Read_UINT32(irp->input, CreateOptions);\n\tStream_Read_UINT32(irp->input, PathLength);\n\n\tif (Stream_GetRemainingLength(irp->input) < PathLength)\n\t\treturn ERROR_INVALID_DATA;\n\n\tpath = (const WCHAR*)Stream_Pointer(irp->input);\n\tFileId = irp->devman->id_sequence++;\n\tfile = drive_file_new(drive->path, path, PathLength, FileId, DesiredAccess, CreateDisposition,\n\t                      CreateOptions, FileAttributes, SharedAccess);\n\n\tif (!file)\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tFileId = 0;\n\t\tInformation = 0;\n\t}\n\telse\n\t{\n\t\tvoid* key = (void*)(size_t)file->id;\n\n\t\tif (!ListDictionary_Add(drive->files, key, file))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"ListDictionary_Add failed!\");\n\t\t\treturn ERROR_INTERNAL_ERROR;\n\t\t}\n\n\t\tswitch (CreateDisposition)\n\t\t{\n\t\t\tcase FILE_SUPERSEDE:\n\t\t\tcase FILE_OPEN:\n\t\t\tcase FILE_CREATE:\n\t\t\tcase FILE_OVERWRITE:\n\t\t\t\tInformation = FILE_SUPERSEDED;\n\t\t\t\tbreak;\n\n\t\t\tcase FILE_OPEN_IF:\n\t\t\t\tInformation = FILE_OPENED;\n\t\t\t\tbreak;\n\n\t\t\tcase FILE_OVERWRITE_IF:\n\t\t\t\tInformation = FILE_OVERWRITTEN;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tInformation = 0;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tStream_Write_UINT32(irp->output, FileId);\n\tStream_Write_UINT8(irp->output, Information);\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_close(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tvoid* key;\n\tDRIVE_FILE* file;\n\n\tif (!drive || !irp || !irp->Complete || !irp->output)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\tkey = (void*)(size_t)irp->FileId;\n\n\tif (!file)\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\telse\n\t{\n\t\tListDictionary_Remove(drive->files, key);\n\n\t\tif (drive_file_free(file))\n\t\t\tirp->IoStatus = STATUS_SUCCESS;\n\t\telse\n\t\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t}\n\n\tStream_Zero(irp->output, 5); /* Padding(5) */\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_read(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tDRIVE_FILE* file;\n\tUINT32 Length;\n\tUINT64 Offset;\n\n\tif (!drive || !irp || !irp->output || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 12)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Read_UINT64(irp->input, Offset);\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\n\tif (!file)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_seek(file, Offset))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\n\tif (!Stream_EnsureRemainingCapacity(irp->output, Length + 4))\n\t{\n\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\telse if (Length == 0)\n\t\tStream_Write_UINT32(irp->output, 0);\n\telse\n\t{\n\t\tBYTE* buffer = Stream_Pointer(irp->output) + sizeof(UINT32);\n\n\t\tif (!drive_file_read(file, buffer, &Length))\n\t\t{\n\t\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\t\tStream_Write_UINT32(irp->output, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStream_Write_UINT32(irp->output, Length);\n\t\t\tStream_Seek(irp->output, Length);\n\t\t}\n\t}\n\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_write(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tDRIVE_FILE* file;\n\tUINT32 Length;\n\tUINT64 Offset;\n\tvoid* ptr;\n\n\tif (!drive || !irp || !irp->input || !irp->output || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Read_UINT64(irp->input, Offset);\n\tStream_Seek(irp->input, 20); /* Padding */\n\tptr = Stream_Pointer(irp->input);\n\tif (!Stream_SafeSeek(irp->input, Length))\n\t\treturn ERROR_INVALID_DATA;\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\n\tif (!file)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_seek(file, Offset))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_write(file, ptr, Length))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\n\tStream_Write_UINT32(irp->output, Length);\n\tStream_Write_UINT8(irp->output, 0); /* Padding */\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_query_information(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tDRIVE_FILE* file;\n\tUINT32 FsInformationClass;\n\n\tif (!drive || !irp || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 4)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\n\tif (!file)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t}\n\telse if (!drive_file_query_information(file, FsInformationClass, irp->output))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t}\n\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_set_information(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tDRIVE_FILE* file;\n\tUINT32 FsInformationClass;\n\tUINT32 Length;\n\n\tif (!drive || !irp || !irp->Complete || !irp->input || !irp->output)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Seek(irp->input, 24); /* Padding */\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\n\tif (!file)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t}\n\telse if (!drive_file_set_information(file, FsInformationClass, Length, irp->input))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t}\n\n\tif (file && file->is_dir && !PathIsDirectoryEmptyW(file->fullpath))\n\t\tirp->IoStatus = STATUS_DIRECTORY_NOT_EMPTY;\n\n\tStream_Write_UINT32(irp->output, Length);\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_query_volume_information(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tUINT32 FsInformationClass;\n\twStream* output = NULL;\n\tchar* volumeLabel = { \"FREERDP\" };\n\tchar* diskType = { \"FAT32\" };\n\tWCHAR* outStr = NULL;\n\tint length;\n\tDWORD lpSectorsPerCluster;\n\tDWORD lpBytesPerSector;\n\tDWORD lpNumberOfFreeClusters;\n\tDWORD lpTotalNumberOfClusters;\n\tWIN32_FILE_ATTRIBUTE_DATA wfad;\n\n\tif (!drive || !irp)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\toutput = irp->output;\n\n\tif (Stream_GetRemainingLength(irp->input) < 4)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tGetDiskFreeSpaceW(drive->path, &lpSectorsPerCluster, &lpBytesPerSector, &lpNumberOfFreeClusters,\n\t                  &lpTotalNumberOfClusters);\n\n\tswitch (FsInformationClass)\n\t{\n\t\tcase FileFsVolumeInformation:\n\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232108.aspx */\n\t\t\tif ((length = ConvertToUnicode(sys_code_page, 0, volumeLabel, -1, &outStr, 0) * 2) <= 0)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"ConvertToUnicode failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT32(output, 17 + length); /* Length */\n\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 17 + length))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\t\tfree(outStr);\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tGetFileAttributesExW(drive->path, GetFileExInfoStandard, &wfad);\n\t\t\tStream_Write_UINT32(output, wfad.ftCreationTime.dwLowDateTime); /* VolumeCreationTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    wfad.ftCreationTime.dwHighDateTime);      /* VolumeCreationTime */\n\t\t\tStream_Write_UINT32(output, lpNumberOfFreeClusters & 0xffff); /* VolumeSerialNumber */\n\t\t\tStream_Write_UINT32(output, length);                          /* VolumeLabelLength */\n\t\t\tStream_Write_UINT8(output, 0);                                /* SupportsObjects */\n\t\t\t/* Reserved(1), MUST NOT be added! */\n\t\t\tStream_Write(output, outStr, length); /* VolumeLabel (Unicode) */\n\t\t\tfree(outStr);\n\t\t\tbreak;\n\n\t\tcase FileFsSizeInformation:\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232107.aspx */\n\t\t\tStream_Write_UINT32(output, 24); /* Length */\n\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 24))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT64(output, lpTotalNumberOfClusters); /* TotalAllocationUnits */\n\t\t\tStream_Write_UINT64(output, lpNumberOfFreeClusters);  /* AvailableAllocationUnits */\n\t\t\tStream_Write_UINT32(output, lpSectorsPerCluster);     /* SectorsPerAllocationUnit */\n\t\t\tStream_Write_UINT32(output, lpBytesPerSector);        /* BytesPerSector */\n\t\t\tbreak;\n\n\t\tcase FileFsAttributeInformation:\n\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232101.aspx */\n\t\t\tif ((length = ConvertToUnicode(sys_code_page, 0, diskType, -1, &outStr, 0) * 2) <= 0)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"ConvertToUnicode failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT32(output, 12 + length); /* Length */\n\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 12 + length))\n\t\t\t{\n\t\t\t\tfree(outStr);\n\t\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT32(output, FILE_CASE_SENSITIVE_SEARCH | FILE_CASE_PRESERVED_NAMES |\n\t\t\t                                FILE_UNICODE_ON_DISK); /* FileSystemAttributes */\n\t\t\tStream_Write_UINT32(output, MAX_PATH);                 /* MaximumComponentNameLength */\n\t\t\tStream_Write_UINT32(output, length);                   /* FileSystemNameLength */\n\t\t\tStream_Write(output, outStr, length);                  /* FileSystemName (Unicode) */\n\t\t\tfree(outStr);\n\t\t\tbreak;\n\n\t\tcase FileFsFullSizeInformation:\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232104.aspx */\n\t\t\tStream_Write_UINT32(output, 32); /* Length */\n\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 32))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT64(output, lpTotalNumberOfClusters); /* TotalAllocationUnits */\n\t\t\tStream_Write_UINT64(output,\n\t\t\t                    lpNumberOfFreeClusters); /* CallerAvailableAllocationUnits */\n\t\t\tStream_Write_UINT64(output, lpNumberOfFreeClusters); /* AvailableAllocationUnits */\n\t\t\tStream_Write_UINT32(output, lpSectorsPerCluster);    /* SectorsPerAllocationUnit */\n\t\t\tStream_Write_UINT32(output, lpBytesPerSector);       /* BytesPerSector */\n\t\t\tbreak;\n\n\t\tcase FileFsDeviceInformation:\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232109.aspx */\n\t\t\tStream_Write_UINT32(output, 8); /* Length */\n\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 8))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT32(output, FILE_DEVICE_DISK); /* DeviceType */\n\t\t\tStream_Write_UINT32(output, 0);                /* Characteristics */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\t\tStream_Write_UINT32(output, 0); /* Length */\n\t\t\tbreak;\n\t}\n\n\treturn irp->Complete(irp);\n}\n\n/* http://msdn.microsoft.com/en-us/library/cc241518.aspx */\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_silent_ignore(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tUINT32 FsInformationClass;\n\n\tif (!drive || !irp || !irp->output || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 4)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tStream_Write_UINT32(irp->output, 0); /* Length */\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_query_directory(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tconst WCHAR* path;\n\tDRIVE_FILE* file;\n\tBYTE InitialQuery;\n\tUINT32 PathLength;\n\tUINT32 FsInformationClass;\n\n\tif (!drive || !irp || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tStream_Read_UINT8(irp->input, InitialQuery);\n\tStream_Read_UINT32(irp->input, PathLength);\n\tStream_Seek(irp->input, 23); /* Padding */\n\tpath = (WCHAR*)Stream_Pointer(irp->input);\n\tif (!Stream_CheckAndLogRequiredLength(TAG, irp->input, PathLength))\n\t\treturn ERROR_INVALID_DATA;\n\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\n\tif (file == NULL)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tStream_Write_UINT32(irp->output, 0); /* Length */\n\t}\n\telse if (!drive_file_query_directory(file, FsInformationClass, InitialQuery, path, PathLength,\n\t                                     irp->output))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t}\n\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_directory_control(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tif (!drive || !irp)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tswitch (irp->MinorFunction)\n\t{\n\t\tcase IRP_MN_QUERY_DIRECTORY:\n\t\t\treturn drive_process_irp_query_directory(drive, irp);\n\n\t\tcase IRP_MN_NOTIFY_CHANGE_DIRECTORY: /* TODO */\n\t\t\treturn irp->Discard(irp);\n\n\t\tdefault:\n\t\t\tirp->IoStatus = STATUS_NOT_SUPPORTED;\n\t\t\tStream_Write_UINT32(irp->output, 0); /* Length */\n\t\t\treturn irp->Complete(irp);\n\t}\n\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_device_control(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tif (!drive || !irp)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tStream_Write_UINT32(irp->output, 0); /* OutputBufferLength */\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tUINT error;\n\n\tif (!drive || !irp)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tirp->IoStatus = STATUS_SUCCESS;\n\n\tswitch (irp->MajorFunction)\n\t{\n\t\tcase IRP_MJ_CREATE:\n\t\t\terror = drive_process_irp_create(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_CLOSE:\n\t\t\terror = drive_process_irp_close(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_READ:\n\t\t\terror = drive_process_irp_read(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_WRITE:\n\t\t\terror = drive_process_irp_write(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_QUERY_INFORMATION:\n\t\t\terror = drive_process_irp_query_information(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_SET_INFORMATION:\n\t\t\terror = drive_process_irp_set_information(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_QUERY_VOLUME_INFORMATION:\n\t\t\terror = drive_process_irp_query_volume_information(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_LOCK_CONTROL:\n\t\t\terror = drive_process_irp_silent_ignore(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_DIRECTORY_CONTROL:\n\t\t\terror = drive_process_irp_directory_control(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_DEVICE_CONTROL:\n\t\t\terror = drive_process_irp_device_control(drive, irp);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tirp->IoStatus = STATUS_NOT_SUPPORTED;\n\t\t\terror = irp->Complete(irp);\n\t\t\tbreak;\n\t}\n\n\treturn error;\n}\n\nstatic DWORD WINAPI drive_thread_func(LPVOID arg)\n{\n\tIRP* irp;\n\twMessage message;\n\tDRIVE_DEVICE* drive = (DRIVE_DEVICE*)arg;\n\tUINT error = CHANNEL_RC_OK;\n\n\tif (!drive)\n\t{\n\t\terror = ERROR_INVALID_PARAMETER;\n\t\tgoto fail;\n\t}\n\n\twhile (1)\n\t{\n\t\tif (!MessageQueue_Wait(drive->IrpQueue))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"MessageQueue_Wait failed!\");\n\t\t\terror = ERROR_INTERNAL_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!MessageQueue_Peek(drive->IrpQueue, &message, TRUE))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"MessageQueue_Peek failed!\");\n\t\t\terror = ERROR_INTERNAL_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (message.id == WMQ_QUIT)\n\t\t\tbreak;\n\n\t\tirp = (IRP*)message.wParam;\n\n\t\tif (irp)\n\t\t{\n\t\t\tif ((error = drive_process_irp(drive, irp)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"drive_process_irp failed with error %\" PRIu32 \"!\", error);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\nfail:\n\n\tif (error && drive && drive->rdpcontext)\n\t\tsetChannelError(drive->rdpcontext, error, \"drive_thread_func reported an error\");\n\n\tExitThread(error);\n\treturn error;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_irp_request(DEVICE* device, IRP* irp)\n{\n\tDRIVE_DEVICE* drive = (DRIVE_DEVICE*)device;\n\n\tif (!drive)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (!MessageQueue_Post(drive->IrpQueue, NULL, 0, (void*)irp, NULL))\n\t{\n\t\tWLog_ERR(TAG, \"MessageQueue_Post failed!\");\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\treturn CHANNEL_RC_OK;\n}\n\nstatic UINT drive_free_int(DRIVE_DEVICE* drive)\n{\n\tUINT error = CHANNEL_RC_OK;\n\n\tif (!drive)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tCloseHandle(drive->thread);\n\tListDictionary_Free(drive->files);\n\tMessageQueue_Free(drive->IrpQueue);\n\tStream_Free(drive->device.data, TRUE);\n\tfree(drive->path);\n\tfree(drive);\n\treturn error;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_free(DEVICE* device)\n{\n\tDRIVE_DEVICE* drive = (DRIVE_DEVICE*)device;\n\tUINT error = CHANNEL_RC_OK;\n\n\tif (!drive)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (MessageQueue_PostQuit(drive->IrpQueue, 0) &&\n\t    (WaitForSingleObject(drive->thread, INFINITE) == WAIT_FAILED))\n\t{\n\t\terror = GetLastError();\n\t\tWLog_ERR(TAG, \"WaitForSingleObject failed with error %\" PRIu32 \"\", error);\n\t\treturn error;\n\t}\n\n\treturn drive_free_int(drive);\n}\n\n/**\n * Helper function used for freeing list dictionary value object\n */\nstatic void drive_file_objfree(void* obj)\n{\n\tdrive_file_free((DRIVE_FILE*)obj);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_register_drive_path(PDEVICE_SERVICE_ENTRY_POINTS pEntryPoints, const char* name,\n                                      const char* path, BOOL automount)\n{\n\tsize_t i, length;\n\tDRIVE_DEVICE* drive;\n\tUINT error = ERROR_INTERNAL_ERROR;\n\n\tif (!pEntryPoints || !name || !path)\n\t{\n\t\tWLog_ERR(TAG, \"[%s] Invalid parameters: pEntryPoints=%p, name=%p, path=%p\", pEntryPoints,\n\t\t         name, path);\n\t\treturn ERROR_INVALID_PARAMETER;\n\t}\n\n\tif (name[0] && path[0])\n\t{\n\t\tsize_t pathLength = strnlen(path, MAX_PATH);\n\t\tdrive = (DRIVE_DEVICE*)calloc(1, sizeof(DRIVE_DEVICE));\n\n\t\tif (!drive)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\t\tdrive->device.type = RDPDR_DTYP_FILESYSTEM;\n\t\tdrive->device.IRPRequest = drive_irp_request;\n\t\tdrive->device.Free = drive_free;\n\t\tdrive->rdpcontext = pEntryPoints->rdpcontext;\n\t\tdrive->automount = automount;\n\t\tlength = strlen(name);\n\t\tdrive->device.data = Stream_New(NULL, length + 1);\n\n\t\tif (!drive->device.data)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Stream_New failed!\");\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tfor (i = 0; i < length; i++)\n\t\t{\n\t\t\t/* Filter 2.2.1.3 Device Announce Header (DEVICE_ANNOUNCE) forbidden symbols */\n\t\t\tswitch (name[i])\n\t\t\t{\n\t\t\t\tcase ':':\n\t\t\t\tcase '<':\n\t\t\t\tcase '>':\n\t\t\t\tcase '\\\"':\n\t\t\t\tcase '/':\n\t\t\t\tcase '\\\\':\n\t\t\t\tcase '|':\n\t\t\t\tcase ' ':\n\t\t\t\t\tStream_Write_UINT8(drive->device.data, '_');\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tStream_Write_UINT8(drive->device.data, (BYTE)name[i]);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tStream_Write_UINT8(drive->device.data, '\\0');\n\n\t\tdrive->device.name = (const char*)Stream_Buffer(drive->device.data);\n\t\tif (!drive->device.name)\n\t\t\tgoto out_error;\n\n\t\tif ((pathLength > 1) && (path[pathLength - 1] == '/'))\n\t\t\tpathLength--;\n\n\t\tif (ConvertToUnicode(sys_code_page, 0, path, pathLength, &drive->path, 0) <= 0)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"ConvertToUnicode failed!\");\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tdrive->files = ListDictionary_New(TRUE);\n\n\t\tif (!drive->files)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"ListDictionary_New failed!\");\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tListDictionary_ValueObject(drive->files)->fnObjectFree = drive_file_objfree;\n\t\tdrive->IrpQueue = MessageQueue_New(NULL);\n\n\t\tif (!drive->IrpQueue)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"ListDictionary_New failed!\");\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tif ((error = pEntryPoints->RegisterDevice(pEntryPoints->devman, (DEVICE*)drive)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"RegisterDevice failed with error %\" PRIu32 \"!\", error);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tif (!(drive->thread =\n\t\t          CreateThread(NULL, 0, drive_thread_func, drive, CREATE_SUSPENDED, NULL)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"CreateThread failed!\");\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tResumeThread(drive->thread);\n\t}\n\n\treturn CHANNEL_RC_OK;\nout_error:\n\tdrive_free_int(drive);\n\treturn error;\n}\n\n#ifdef BUILTIN_CHANNELS\n#define DeviceServiceEntry drive_DeviceServiceEntry\n#else\n#define DeviceServiceEntry FREERDP_API DeviceServiceEntry\n#endif\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nUINT DeviceServiceEntry(PDEVICE_SERVICE_ENTRY_POINTS pEntryPoints)\n{\n\tRDPDR_DRIVE* drive;\n\tUINT error;\n#ifdef WIN32\n\tchar* dev;\n\tint len;\n\tchar devlist[512], buf[512];\n\tchar* bufdup;\n\tchar* devdup;\n#endif\n\tdrive = (RDPDR_DRIVE*)pEntryPoints->device;\n#ifndef WIN32\n\tsys_code_page = CP_UTF8;\n\n\tif (strcmp(drive->Path, \"*\") == 0)\n\t{\n\t\t/* all drives */\n\t\tfree(drive->Path);\n\t\tdrive->Path = _strdup(\"/\");\n\n\t\tif (!drive->Path)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"_strdup failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\t}\n\telse if (strcmp(drive->Path, \"%\") == 0)\n\t{\n\t\tfree(drive->Path);\n\t\tdrive->Path = GetKnownPath(KNOWN_PATH_HOME);\n\n\t\tif (!drive->Path)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"_strdup failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\t}\n\n\terror = drive_register_drive_path(pEntryPoints, drive->Name, drive->Path, drive->automount);\n#else\n\tsys_code_page = GetACP();\n\n\t/* Special case: path[0] == '*' -> export all drives */\n\t/* Special case: path[0] == '%' -> user home dir */\n\tif (strcmp(drive->Path, \"%\") == 0)\n\t{\n\t\tGetEnvironmentVariableA(\"USERPROFILE\", buf, sizeof(buf));\n\t\tPathCchAddBackslashA(buf, sizeof(buf));\n\t\tfree(drive->Path);\n\t\tdrive->Path = _strdup(buf);\n\n\t\tif (!drive->Path)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"_strdup failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\t\terror = drive_register_drive_path(pEntryPoints, drive->Name, drive->Path, drive->automount);\n\t}\n\telse if (strcmp(drive->Path, \"*\") == 0)\n\t{\n\t\tint i;\n\t\t/* Enumerate all devices: */\n\t\tGetLogicalDriveStringsA(sizeof(devlist) - 1, devlist);\n\n\t\tfor (dev = devlist, i = 0; *dev; dev += 4, i++)\n\t\t{\n\t\t\tif (*dev > 'B')\n\t\t\t{\n\t\t\t\t/* Suppress disk drives A and B to avoid pesty messages */\n\t\t\t\tlen = sprintf_s(buf, sizeof(buf) - 4, \"%s\", drive->Name);\n\t\t\t\tbuf[len] = '_';\n\t\t\t\tbuf[len + 1] = dev[0];\n\t\t\t\tbuf[len + 2] = 0;\n\t\t\t\tbuf[len + 3] = 0;\n\n\t\t\t\tif (!(bufdup = _strdup(buf)))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"_strdup failed!\");\n\t\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t\t}\n\n\t\t\t\tif (!(devdup = _strdup(dev)))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"_strdup failed!\");\n\t\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t\t}\n\n\t\t\t\tif ((error = drive_register_drive_path(pEntryPoints, bufdup, devdup, TRUE)))\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\terror = drive_register_drive_path(pEntryPoints, drive->Name, drive->Path, drive->automount);\n\t}\n\n#endif\n\treturn error;\n}\n"], "fixing_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * File System Virtual Channel\n *\n * Copyright 2010-2012 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2010-2011 Vic Lee\n * Copyright 2012 Gerald Richter\n * Copyright 2015 Thincast Technologies GmbH\n * Copyright 2015 DI (FH) Martin Haimberger <martin.haimberger@thincast.com>\n * Copyright 2016 Inuvika Inc.\n * Copyright 2016 David PHAM-VAN <d.phamvan@inuvika.com>\n * Copyright 2017 Armin Novak <armin.novak@thincast.com>\n * Copyright 2017 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#include <winpr/wtypes.h>\n#include <winpr/crt.h>\n#include <winpr/path.h>\n#include <winpr/file.h>\n#include <winpr/stream.h>\n\n#include <freerdp/channels/rdpdr.h>\n\n#include \"drive_file.h\"\n\n#ifdef WITH_DEBUG_RDPDR\n#define DEBUG_WSTR(msg, wstr)                                            \\\n\tdo                                                                   \\\n\t{                                                                    \\\n\t\tLPSTR lpstr;                                                     \\\n\t\tConvertFromUnicode(CP_UTF8, 0, wstr, -1, &lpstr, 0, NULL, NULL); \\\n\t\tWLog_DBG(TAG, msg, lpstr);                                       \\\n\t\tfree(lpstr);                                                     \\\n\t} while (0)\n#else\n#define DEBUG_WSTR(msg, wstr) \\\n\tdo                        \\\n\t{                         \\\n\t} while (0)\n#endif\n\nstatic BOOL drive_file_fix_path(WCHAR* path, size_t length)\n{\n\tsize_t i;\n\n\tif ((length == 0) || (length > UINT32_MAX))\n\t\treturn FALSE;\n\n\tWINPR_ASSERT(path);\n\n\tfor (i = 0; i < length; i++)\n\t{\n\t\tif (path[i] == L'\\\\')\n\t\t\tpath[i] = L'/';\n\t}\n\n#ifdef WIN32\n\n\tif ((length == 3) && (path[1] == L':') && (path[2] == L'/'))\n\t\treturn FALSE;\n\n#else\n\n\tif ((length == 1) && (path[0] == L'/'))\n\t\treturn FALSE;\n\n#endif\n\n\tif ((length > 0) && (path[length - 1] == L'/'))\n\t\tpath[length - 1] = L'\\0';\n\n\treturn TRUE;\n}\n\nstatic WCHAR* drive_file_combine_fullpath(const WCHAR* base_path, const WCHAR* path,\n                                          size_t PathWCharLength)\n{\n\tBOOL ok = FALSE;\n\tWCHAR* fullpath = NULL;\n\tsize_t length;\n\n\tif (!base_path || (!path && (PathWCharLength > 0)))\n\t\tgoto fail;\n\n\tconst size_t base_path_length = _wcsnlen(base_path, MAX_PATH);\n\tlength = base_path_length + PathWCharLength + 1;\n\tfullpath = (WCHAR*)calloc(length, sizeof(WCHAR));\n\n\tif (!fullpath)\n\t\tgoto fail;\n\n\tCopyMemory(fullpath, base_path, base_path_length * sizeof(WCHAR));\n\tif (path)\n\t\tCopyMemory(&fullpath[base_path_length], path, PathWCharLength * sizeof(WCHAR));\n\n\tif (!drive_file_fix_path(fullpath, length))\n\t\tgoto fail;\n\n\t/* Ensure the path does not contain sequences like '..' */\n\tconst WCHAR dotdot[] = { '.', '.', '\\0' };\n\tif (_wcsstr(&fullpath[base_path_length], dotdot))\n\t{\n\t\tchar abuffer[MAX_PATH] = { 0 };\n\t\tConvertFromUnicode(CP_UTF8, 0, &fullpath[base_path_length], -1, (char**)&abuffer,\n\t\t                   ARRAYSIZE(abuffer) - 1, NULL, NULL);\n\n\t\tWLog_WARN(TAG, \"[rdpdr] received invalid file path '%s' from server, aborting!\",\n\t\t          &abuffer[base_path_length]);\n\t\tgoto fail;\n\t}\n\n\tok = TRUE;\nfail:\n\tif (!ok)\n\t{\n\t\tfree(fullpath);\n\t\tfullpath = NULL;\n\t}\n\treturn fullpath;\n}\n\nstatic BOOL drive_file_remove_dir(const WCHAR* path)\n{\n\tWIN32_FIND_DATAW findFileData = { 0 };\n\tBOOL ret = TRUE;\n\tHANDLE dir = INVALID_HANDLE_VALUE;\n\tWCHAR* fullpath = NULL;\n\tWCHAR* path_slash = NULL;\n\tsize_t base_path_length = 0;\n\n\tif (!path)\n\t\treturn FALSE;\n\n\tbase_path_length = _wcslen(path);\n\tpath_slash = (WCHAR*)calloc(base_path_length + 3, sizeof(WCHAR));\n\n\tif (!path_slash)\n\t{\n\t\tWLog_ERR(TAG, \"malloc failed!\");\n\t\treturn FALSE;\n\t}\n\n\tCopyMemory(path_slash, path, base_path_length * sizeof(WCHAR));\n\tpath_slash[base_path_length] = L'/';\n\tpath_slash[base_path_length + 1] = L'*';\n\tDEBUG_WSTR(\"Search in %s\", path_slash);\n\tdir = FindFirstFileW(path_slash, &findFileData);\n\n\tif (dir == INVALID_HANDLE_VALUE)\n\t{\n\t\tfree(path_slash);\n\t\treturn FALSE;\n\t}\n\n\tdo\n\t{\n\t\tconst size_t len = _wcsnlen(findFileData.cFileName, ARRAYSIZE(findFileData.cFileName));\n\n\t\tif ((len == 1 && findFileData.cFileName[0] == L'.') ||\n\t\t    (len == 2 && findFileData.cFileName[0] == L'.' && findFileData.cFileName[1] == L'.'))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tfullpath = drive_file_combine_fullpath(path_slash, findFileData.cFileName, len);\n\t\tDEBUG_WSTR(\"Delete %s\", fullpath);\n\n\t\tif (findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)\n\t\t{\n\t\t\tret = drive_file_remove_dir(fullpath);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tret = DeleteFileW(fullpath);\n\t\t}\n\n\t\tfree(fullpath);\n\n\t\tif (!ret)\n\t\t\tbreak;\n\t} while (ret && FindNextFileW(dir, &findFileData) != 0);\n\n\tFindClose(dir);\n\n\tif (ret)\n\t{\n\t\tif (!RemoveDirectoryW(path))\n\t\t{\n\t\t\tret = FALSE;\n\t\t}\n\t}\n\n\tfree(path_slash);\n\treturn ret;\n}\n\nstatic BOOL drive_file_set_fullpath(DRIVE_FILE* file, WCHAR* fullpath)\n{\n\tif (!file || !fullpath)\n\t\treturn FALSE;\n\n\tfree(file->fullpath);\n\tfile->fullpath = fullpath;\n\tfile->filename = _wcsrchr(file->fullpath, L'/');\n\n\tif (file->filename == NULL)\n\t\tfile->filename = file->fullpath;\n\telse\n\t\tfile->filename += 1;\n\n\treturn TRUE;\n}\n\nstatic BOOL drive_file_init(DRIVE_FILE* file)\n{\n\tUINT CreateDisposition = 0;\n\tDWORD dwAttr = GetFileAttributesW(file->fullpath);\n\n\tif (dwAttr != INVALID_FILE_ATTRIBUTES)\n\t{\n\t\t/* The file exists */\n\t\tfile->is_dir = (dwAttr & FILE_ATTRIBUTE_DIRECTORY) != 0;\n\n\t\tif (file->is_dir)\n\t\t{\n\t\t\tif (file->CreateDisposition == FILE_CREATE)\n\t\t\t{\n\t\t\t\tSetLastError(ERROR_ALREADY_EXISTS);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tif (file->CreateOptions & FILE_NON_DIRECTORY_FILE)\n\t\t\t{\n\t\t\t\tSetLastError(ERROR_ACCESS_DENIED);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\treturn TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (file->CreateOptions & FILE_DIRECTORY_FILE)\n\t\t\t{\n\t\t\t\tSetLastError(ERROR_DIRECTORY);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tfile->is_dir = ((file->CreateOptions & FILE_DIRECTORY_FILE) ? TRUE : FALSE);\n\n\t\tif (file->is_dir)\n\t\t{\n\t\t\t/* Should only create the directory if the disposition allows for it */\n\t\t\tif ((file->CreateDisposition == FILE_OPEN_IF) ||\n\t\t\t    (file->CreateDisposition == FILE_CREATE))\n\t\t\t{\n\t\t\t\tif (CreateDirectoryW(file->fullpath, NULL) != 0)\n\t\t\t\t{\n\t\t\t\t\treturn TRUE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSetLastError(ERROR_FILE_NOT_FOUND);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tif (file->file_handle == INVALID_HANDLE_VALUE)\n\t{\n\t\tswitch (file->CreateDisposition)\n\t\t{\n\t\t\tcase FILE_SUPERSEDE: /* If the file already exists, replace it with the given file. If\n\t\t\t                        it does not, create the given file. */\n\t\t\t\tCreateDisposition = CREATE_ALWAYS;\n\t\t\t\tbreak;\n\n\t\t\tcase FILE_OPEN: /* If the file already exists, open it instead of creating a new file.\n\t\t\t                   If it does not, fail the request and do not create a new file. */\n\t\t\t\tCreateDisposition = OPEN_EXISTING;\n\t\t\t\tbreak;\n\n\t\t\tcase FILE_CREATE: /* If the file already exists, fail the request and do not create or\n\t\t\t                     open the given file. If it does not, create the given file. */\n\t\t\t\tCreateDisposition = CREATE_NEW;\n\t\t\t\tbreak;\n\n\t\t\tcase FILE_OPEN_IF: /* If the file already exists, open it. If it does not, create the\n\t\t\t                      given file. */\n\t\t\t\tCreateDisposition = OPEN_ALWAYS;\n\t\t\t\tbreak;\n\n\t\t\tcase FILE_OVERWRITE: /* If the file already exists, open it and overwrite it. If it does\n\t\t\t                        not, fail the request. */\n\t\t\t\tCreateDisposition = TRUNCATE_EXISTING;\n\t\t\t\tbreak;\n\n\t\t\tcase FILE_OVERWRITE_IF: /* If the file already exists, open it and overwrite it. If it\n\t\t\t                           does not, create the given file. */\n\t\t\t\tCreateDisposition = CREATE_ALWAYS;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n#ifndef WIN32\n\t\tfile->SharedAccess = 0;\n#endif\n\t\tfile->file_handle = CreateFileW(file->fullpath, file->DesiredAccess, file->SharedAccess,\n\t\t                                NULL, CreateDisposition, file->FileAttributes, NULL);\n\t}\n\n#ifdef WIN32\n\tif (file->file_handle == INVALID_HANDLE_VALUE)\n\t{\n\t\t/* Get the error message, if any. */\n\t\tDWORD errorMessageID = GetLastError();\n\n\t\tif (errorMessageID != 0)\n\t\t{\n\t\t\tLPSTR messageBuffer = NULL;\n\t\t\tsize_t size =\n\t\t\t    FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |\n\t\t\t                       FORMAT_MESSAGE_IGNORE_INSERTS,\n\t\t\t                   NULL, errorMessageID, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n\t\t\t                   (LPSTR)&messageBuffer, 0, NULL);\n\t\t\tWLog_ERR(TAG, \"Error in drive_file_init: %s %s\", messageBuffer, file->fullpath);\n\t\t\t/* Free the buffer. */\n\t\t\tLocalFree(messageBuffer);\n\t\t\t/* restore original error code */\n\t\t\tSetLastError(errorMessageID);\n\t\t}\n\t}\n#endif\n\n\treturn file->file_handle != INVALID_HANDLE_VALUE;\n}\n\nDRIVE_FILE* drive_file_new(const WCHAR* base_path, const WCHAR* path, UINT32 PathWCharLength,\n                           UINT32 id, UINT32 DesiredAccess, UINT32 CreateDisposition,\n                           UINT32 CreateOptions, UINT32 FileAttributes, UINT32 SharedAccess)\n{\n\tDRIVE_FILE* file;\n\n\tif (!base_path || (!path && (PathWCharLength > 0)))\n\t\treturn NULL;\n\n\tfile = (DRIVE_FILE*)calloc(1, sizeof(DRIVE_FILE));\n\n\tif (!file)\n\t{\n\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\treturn NULL;\n\t}\n\n\tfile->file_handle = INVALID_HANDLE_VALUE;\n\tfile->find_handle = INVALID_HANDLE_VALUE;\n\tfile->id = id;\n\tfile->basepath = base_path;\n\tfile->FileAttributes = FileAttributes;\n\tfile->DesiredAccess = DesiredAccess;\n\tfile->CreateDisposition = CreateDisposition;\n\tfile->CreateOptions = CreateOptions;\n\tfile->SharedAccess = SharedAccess;\n\tdrive_file_set_fullpath(file, drive_file_combine_fullpath(base_path, path, PathWCharLength));\n\n\tif (!drive_file_init(file))\n\t{\n\t\tDWORD lastError = GetLastError();\n\t\tdrive_file_free(file);\n\t\tSetLastError(lastError);\n\t\treturn NULL;\n\t}\n\n\treturn file;\n}\n\nBOOL drive_file_free(DRIVE_FILE* file)\n{\n\tBOOL rc = FALSE;\n\n\tif (!file)\n\t\treturn FALSE;\n\n\tif (file->file_handle != INVALID_HANDLE_VALUE)\n\t{\n\t\tCloseHandle(file->file_handle);\n\t\tfile->file_handle = INVALID_HANDLE_VALUE;\n\t}\n\n\tif (file->find_handle != INVALID_HANDLE_VALUE)\n\t{\n\t\tFindClose(file->find_handle);\n\t\tfile->find_handle = INVALID_HANDLE_VALUE;\n\t}\n\n\tif (file->delete_pending)\n\t{\n\t\tif (file->is_dir)\n\t\t{\n\t\t\tif (!drive_file_remove_dir(file->fullpath))\n\t\t\t\tgoto fail;\n\t\t}\n\t\telse if (!DeleteFileW(file->fullpath))\n\t\t\tgoto fail;\n\t}\n\n\trc = TRUE;\nfail:\n\tDEBUG_WSTR(\"Free %s\", file->fullpath);\n\tfree(file->fullpath);\n\tfree(file);\n\treturn rc;\n}\n\nBOOL drive_file_seek(DRIVE_FILE* file, UINT64 Offset)\n{\n\tLARGE_INTEGER loffset;\n\n\tif (!file)\n\t\treturn FALSE;\n\n\tif (Offset > INT64_MAX)\n\t\treturn FALSE;\n\n\tloffset.QuadPart = (LONGLONG)Offset;\n\treturn SetFilePointerEx(file->file_handle, loffset, NULL, FILE_BEGIN);\n}\n\nBOOL drive_file_read(DRIVE_FILE* file, BYTE* buffer, UINT32* Length)\n{\n\tUINT32 read;\n\n\tif (!file || !buffer || !Length)\n\t\treturn FALSE;\n\n\tDEBUG_WSTR(\"Read file %s\", file->fullpath);\n\n\tif (ReadFile(file->file_handle, buffer, *Length, &read, NULL))\n\t{\n\t\t*Length = read;\n\t\treturn TRUE;\n\t}\n\n\treturn FALSE;\n}\n\nBOOL drive_file_write(DRIVE_FILE* file, BYTE* buffer, UINT32 Length)\n{\n\tUINT32 written;\n\n\tif (!file || !buffer)\n\t\treturn FALSE;\n\n\tDEBUG_WSTR(\"Write file %s\", file->fullpath);\n\n\twhile (Length > 0)\n\t{\n\t\tif (!WriteFile(file->file_handle, buffer, Length, &written, NULL))\n\t\t\treturn FALSE;\n\n\t\tLength -= written;\n\t\tbuffer += written;\n\t}\n\n\treturn TRUE;\n}\n\nBOOL drive_file_query_information(DRIVE_FILE* file, UINT32 FsInformationClass, wStream* output)\n{\n\tWIN32_FILE_ATTRIBUTE_DATA fileAttributes;\n\tDEBUG_WSTR(\"FindFirstFile %s\", file->fullpath);\n\n\tif (!file || !output)\n\t\treturn FALSE;\n\n\tif (!GetFileAttributesExW(file->fullpath, GetFileExInfoStandard, &fileAttributes))\n\t\tgoto out_fail;\n\n\tswitch (FsInformationClass)\n\t{\n\t\tcase FileBasicInformation:\n\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232094.aspx */\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 4 + 36))\n\t\t\t\tgoto out_fail;\n\n\t\t\tStream_Write_UINT32(output, 36); /* Length */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    fileAttributes.ftCreationTime.dwLowDateTime); /* CreationTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    fileAttributes.ftCreationTime.dwHighDateTime); /* CreationTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    fileAttributes.ftLastAccessTime.dwLowDateTime); /* LastAccessTime */\n\t\t\tStream_Write_UINT32(\n\t\t\t    output, fileAttributes.ftLastAccessTime.dwHighDateTime); /* LastAccessTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    fileAttributes.ftLastWriteTime.dwLowDateTime); /* LastWriteTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    fileAttributes.ftLastWriteTime.dwHighDateTime); /* LastWriteTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    fileAttributes.ftLastWriteTime.dwLowDateTime); /* ChangeTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    fileAttributes.ftLastWriteTime.dwHighDateTime); /* ChangeTime */\n\t\t\tStream_Write_UINT32(output, fileAttributes.dwFileAttributes);       /* FileAttributes */\n\t\t\t/* Reserved(4), MUST NOT be added! */\n\t\t\tbreak;\n\n\t\tcase FileStandardInformation:\n\n\t\t\t/*  http://msdn.microsoft.com/en-us/library/cc232088.aspx */\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 4 + 22))\n\t\t\t\tgoto out_fail;\n\n\t\t\tStream_Write_UINT32(output, 22);                           /* Length */\n\t\t\tStream_Write_UINT32(output, fileAttributes.nFileSizeLow);  /* AllocationSize */\n\t\t\tStream_Write_UINT32(output, fileAttributes.nFileSizeHigh); /* AllocationSize */\n\t\t\tStream_Write_UINT32(output, fileAttributes.nFileSizeLow);  /* EndOfFile */\n\t\t\tStream_Write_UINT32(output, fileAttributes.nFileSizeHigh); /* EndOfFile */\n\t\t\tStream_Write_UINT32(output, 0);                            /* NumberOfLinks */\n\t\t\tStream_Write_UINT8(output, file->delete_pending ? 1 : 0);  /* DeletePending */\n\t\t\tStream_Write_UINT8(output, fileAttributes.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY\n\t\t\t                               ? TRUE\n\t\t\t                               : FALSE); /* Directory */\n\t\t\t/* Reserved(2), MUST NOT be added! */\n\t\t\tbreak;\n\n\t\tcase FileAttributeTagInformation:\n\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232093.aspx */\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 4 + 8))\n\t\t\t\tgoto out_fail;\n\n\t\t\tStream_Write_UINT32(output, 8);                               /* Length */\n\t\t\tStream_Write_UINT32(output, fileAttributes.dwFileAttributes); /* FileAttributes */\n\t\t\tStream_Write_UINT32(output, 0);                               /* ReparseTag */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Unhandled FsInformationClass */\n\t\t\tgoto out_fail;\n\t}\n\n\treturn TRUE;\nout_fail:\n\tStream_Write_UINT32(output, 0); /* Length */\n\treturn FALSE;\n}\n\nBOOL drive_file_set_information(DRIVE_FILE* file, UINT32 FsInformationClass, UINT32 Length,\n                                wStream* input)\n{\n\tINT64 size;\n\tWCHAR* fullpath;\n\tULARGE_INTEGER liCreationTime;\n\tULARGE_INTEGER liLastAccessTime;\n\tULARGE_INTEGER liLastWriteTime;\n\tULARGE_INTEGER liChangeTime;\n\tFILETIME ftCreationTime;\n\tFILETIME ftLastAccessTime;\n\tFILETIME ftLastWriteTime;\n\tFILETIME* pftCreationTime = NULL;\n\tFILETIME* pftLastAccessTime = NULL;\n\tFILETIME* pftLastWriteTime = NULL;\n\tUINT32 FileAttributes;\n\tUINT32 FileNameLength;\n\tLARGE_INTEGER liSize;\n\tUINT8 delete_pending;\n\tUINT8 ReplaceIfExists;\n\tDWORD attr;\n\n\tif (!file || !input)\n\t\treturn FALSE;\n\n\tswitch (FsInformationClass)\n\t{\n\t\tcase FileBasicInformation:\n\t\t\tif (Stream_GetRemainingLength(input) < 36)\n\t\t\t\treturn FALSE;\n\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232094.aspx */\n\t\t\tStream_Read_UINT64(input, liCreationTime.QuadPart);\n\t\t\tStream_Read_UINT64(input, liLastAccessTime.QuadPart);\n\t\t\tStream_Read_UINT64(input, liLastWriteTime.QuadPart);\n\t\t\tStream_Read_UINT64(input, liChangeTime.QuadPart);\n\t\t\tStream_Read_UINT32(input, FileAttributes);\n\n\t\t\tif (!PathFileExistsW(file->fullpath))\n\t\t\t\treturn FALSE;\n\n\t\t\tif (file->file_handle == INVALID_HANDLE_VALUE)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Unable to set file time %s (%\" PRId32 \")\", file->fullpath,\n\t\t\t\t         GetLastError());\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tif (liCreationTime.QuadPart != 0)\n\t\t\t{\n\t\t\t\tftCreationTime.dwHighDateTime = liCreationTime.u.HighPart;\n\t\t\t\tftCreationTime.dwLowDateTime = liCreationTime.u.LowPart;\n\t\t\t\tpftCreationTime = &ftCreationTime;\n\t\t\t}\n\n\t\t\tif (liLastAccessTime.QuadPart != 0)\n\t\t\t{\n\t\t\t\tftLastAccessTime.dwHighDateTime = liLastAccessTime.u.HighPart;\n\t\t\t\tftLastAccessTime.dwLowDateTime = liLastAccessTime.u.LowPart;\n\t\t\t\tpftLastAccessTime = &ftLastAccessTime;\n\t\t\t}\n\n\t\t\tif (liLastWriteTime.QuadPart != 0)\n\t\t\t{\n\t\t\t\tftLastWriteTime.dwHighDateTime = liLastWriteTime.u.HighPart;\n\t\t\t\tftLastWriteTime.dwLowDateTime = liLastWriteTime.u.LowPart;\n\t\t\t\tpftLastWriteTime = &ftLastWriteTime;\n\t\t\t}\n\n\t\t\tif (liChangeTime.QuadPart != 0 && liChangeTime.QuadPart > liLastWriteTime.QuadPart)\n\t\t\t{\n\t\t\t\tftLastWriteTime.dwHighDateTime = liChangeTime.u.HighPart;\n\t\t\t\tftLastWriteTime.dwLowDateTime = liChangeTime.u.LowPart;\n\t\t\t\tpftLastWriteTime = &ftLastWriteTime;\n\t\t\t}\n\n\t\t\tDEBUG_WSTR(\"SetFileTime %s\", file->fullpath);\n\n\t\t\tSetFileAttributesW(file->fullpath, FileAttributes);\n\t\t\tif (!SetFileTime(file->file_handle, pftCreationTime, pftLastAccessTime,\n\t\t\t                 pftLastWriteTime))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Unable to set file time to %s\", file->fullpath);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase FileEndOfFileInformation:\n\n\t\t/* http://msdn.microsoft.com/en-us/library/cc232067.aspx */\n\t\tcase FileAllocationInformation:\n\t\t\tif (Stream_GetRemainingLength(input) < 8)\n\t\t\t\treturn FALSE;\n\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232076.aspx */\n\t\t\tStream_Read_INT64(input, size);\n\n\t\t\tif (file->file_handle == INVALID_HANDLE_VALUE)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Unable to truncate %s to %\" PRId64 \" (%\" PRId32 \")\", file->fullpath,\n\t\t\t\t         size, GetLastError());\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tliSize.QuadPart = size;\n\n\t\t\tif (!SetFilePointerEx(file->file_handle, liSize, NULL, FILE_BEGIN))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Unable to truncate %s to %d (%\" PRId32 \")\", file->fullpath, size,\n\t\t\t\t         GetLastError());\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tDEBUG_WSTR(\"Truncate %s\", file->fullpath);\n\n\t\t\tif (SetEndOfFile(file->file_handle) == 0)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Unable to truncate %s to %d (%\" PRId32 \")\", file->fullpath, size,\n\t\t\t\t         GetLastError());\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase FileDispositionInformation:\n\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232098.aspx */\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc241371.aspx */\n\t\t\tif (file->is_dir && !PathIsDirectoryEmptyW(file->fullpath))\n\t\t\t\tbreak; /* TODO: SetLastError ??? */\n\n\t\t\tif (Length)\n\t\t\t{\n\t\t\t\tif (Stream_GetRemainingLength(input) < 1)\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tStream_Read_UINT8(input, delete_pending);\n\t\t\t}\n\t\t\telse\n\t\t\t\tdelete_pending = 1;\n\n\t\t\tif (delete_pending)\n\t\t\t{\n\t\t\t\tDEBUG_WSTR(\"SetDeletePending %s\", file->fullpath);\n\t\t\t\tattr = GetFileAttributesW(file->fullpath);\n\n\t\t\t\tif (attr & FILE_ATTRIBUTE_READONLY)\n\t\t\t\t{\n\t\t\t\t\tSetLastError(ERROR_ACCESS_DENIED);\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfile->delete_pending = delete_pending;\n\t\t\tbreak;\n\n\t\tcase FileRenameInformation:\n\t\t\tif (Stream_GetRemainingLength(input) < 6)\n\t\t\t\treturn FALSE;\n\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232085.aspx */\n\t\t\tStream_Read_UINT8(input, ReplaceIfExists);\n\t\t\tStream_Seek_UINT8(input); /* RootDirectory */\n\t\t\tStream_Read_UINT32(input, FileNameLength);\n\n\t\t\tif (Stream_GetRemainingLength(input) < FileNameLength)\n\t\t\t\treturn FALSE;\n\n\t\t\tfullpath = drive_file_combine_fullpath(file->basepath, (WCHAR*)Stream_Pointer(input),\n\t\t\t                                       FileNameLength / sizeof(WCHAR));\n\n\t\t\tif (!fullpath)\n\t\t\t\treturn FALSE;\n\n#ifdef _WIN32\n\n\t\t\tif (file->file_handle != INVALID_HANDLE_VALUE)\n\t\t\t{\n\t\t\t\tCloseHandle(file->file_handle);\n\t\t\t\tfile->file_handle = INVALID_HANDLE_VALUE;\n\t\t\t}\n\n#endif\n\t\t\tDEBUG_WSTR(\"MoveFileExW %s\", file->fullpath);\n\n\t\t\tif (MoveFileExW(file->fullpath, fullpath,\n\t\t\t                MOVEFILE_COPY_ALLOWED |\n\t\t\t                    (ReplaceIfExists ? MOVEFILE_REPLACE_EXISTING : 0)))\n\t\t\t{\n\t\t\t\tif (!drive_file_set_fullpath(file, fullpath))\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n#ifdef _WIN32\n\t\t\tdrive_file_init(file);\n#endif\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nBOOL drive_file_query_directory(DRIVE_FILE* file, UINT32 FsInformationClass, BYTE InitialQuery,\n                                const WCHAR* path, UINT32 PathWCharLength, wStream* output)\n{\n\tsize_t length;\n\tWCHAR* ent_path;\n\n\tif (!file || !path || !output)\n\t\treturn FALSE;\n\n\tif (InitialQuery != 0)\n\t{\n\t\t/* release search handle */\n\t\tif (file->find_handle != INVALID_HANDLE_VALUE)\n\t\t\tFindClose(file->find_handle);\n\n\t\tent_path = drive_file_combine_fullpath(file->basepath, path, PathWCharLength);\n\t\t/* open new search handle and retrieve the first entry */\n\t\tfile->find_handle = FindFirstFileW(ent_path, &file->find_data);\n\t\tfree(ent_path);\n\n\t\tif (file->find_handle == INVALID_HANDLE_VALUE)\n\t\t\tgoto out_fail;\n\t}\n\telse if (!FindNextFileW(file->find_handle, &file->find_data))\n\t\tgoto out_fail;\n\n\tlength = _wcslen(file->find_data.cFileName) * 2;\n\n\tswitch (FsInformationClass)\n\t{\n\t\tcase FileDirectoryInformation:\n\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232097.aspx */\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 4 + 64 + length))\n\t\t\t\tgoto out_fail;\n\n\t\t\tif (length > UINT32_MAX - 64)\n\t\t\t\tgoto out_fail;\n\n\t\t\tStream_Write_UINT32(output, (UINT32)(64 + length)); /* Length */\n\t\t\tStream_Write_UINT32(output, 0);                     /* NextEntryOffset */\n\t\t\tStream_Write_UINT32(output, 0);                     /* FileIndex */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftCreationTime.dwLowDateTime); /* CreationTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftCreationTime.dwHighDateTime); /* CreationTime */\n\t\t\tStream_Write_UINT32(\n\t\t\t    output, file->find_data.ftLastAccessTime.dwLowDateTime); /* LastAccessTime */\n\t\t\tStream_Write_UINT32(\n\t\t\t    output, file->find_data.ftLastAccessTime.dwHighDateTime); /* LastAccessTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftLastWriteTime.dwLowDateTime); /* LastWriteTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftLastWriteTime.dwHighDateTime); /* LastWriteTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftLastWriteTime.dwLowDateTime); /* ChangeTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftLastWriteTime.dwHighDateTime); /* ChangeTime */\n\t\t\tStream_Write_UINT32(output, file->find_data.nFileSizeLow);           /* EndOfFile */\n\t\t\tStream_Write_UINT32(output, file->find_data.nFileSizeHigh);          /* EndOfFile */\n\t\t\tStream_Write_UINT32(output, file->find_data.nFileSizeLow);     /* AllocationSize */\n\t\t\tStream_Write_UINT32(output, file->find_data.nFileSizeHigh);    /* AllocationSize */\n\t\t\tStream_Write_UINT32(output, file->find_data.dwFileAttributes); /* FileAttributes */\n\t\t\tStream_Write_UINT32(output, (UINT32)length);                   /* FileNameLength */\n\t\t\tStream_Write(output, file->find_data.cFileName, length);\n\t\t\tbreak;\n\n\t\tcase FileFullDirectoryInformation:\n\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232068.aspx */\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 4 + 68 + length))\n\t\t\t\tgoto out_fail;\n\n\t\t\tif (length > UINT32_MAX - 68)\n\t\t\t\tgoto out_fail;\n\n\t\t\tStream_Write_UINT32(output, (UINT32)(68 + length)); /* Length */\n\t\t\tStream_Write_UINT32(output, 0);                     /* NextEntryOffset */\n\t\t\tStream_Write_UINT32(output, 0);                     /* FileIndex */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftCreationTime.dwLowDateTime); /* CreationTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftCreationTime.dwHighDateTime); /* CreationTime */\n\t\t\tStream_Write_UINT32(\n\t\t\t    output, file->find_data.ftLastAccessTime.dwLowDateTime); /* LastAccessTime */\n\t\t\tStream_Write_UINT32(\n\t\t\t    output, file->find_data.ftLastAccessTime.dwHighDateTime); /* LastAccessTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftLastWriteTime.dwLowDateTime); /* LastWriteTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftLastWriteTime.dwHighDateTime); /* LastWriteTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftLastWriteTime.dwLowDateTime); /* ChangeTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftLastWriteTime.dwHighDateTime); /* ChangeTime */\n\t\t\tStream_Write_UINT32(output, file->find_data.nFileSizeLow);           /* EndOfFile */\n\t\t\tStream_Write_UINT32(output, file->find_data.nFileSizeHigh);          /* EndOfFile */\n\t\t\tStream_Write_UINT32(output, file->find_data.nFileSizeLow);     /* AllocationSize */\n\t\t\tStream_Write_UINT32(output, file->find_data.nFileSizeHigh);    /* AllocationSize */\n\t\t\tStream_Write_UINT32(output, file->find_data.dwFileAttributes); /* FileAttributes */\n\t\t\tStream_Write_UINT32(output, (UINT32)length);                   /* FileNameLength */\n\t\t\tStream_Write_UINT32(output, 0);                                /* EaSize */\n\t\t\tStream_Write(output, file->find_data.cFileName, length);\n\t\t\tbreak;\n\n\t\tcase FileBothDirectoryInformation:\n\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232095.aspx */\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 4 + 93 + length))\n\t\t\t\tgoto out_fail;\n\n\t\t\tif (length > UINT32_MAX - 93)\n\t\t\t\tgoto out_fail;\n\n\t\t\tStream_Write_UINT32(output, (UINT32)(93 + length)); /* Length */\n\t\t\tStream_Write_UINT32(output, 0);                     /* NextEntryOffset */\n\t\t\tStream_Write_UINT32(output, 0);                     /* FileIndex */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftCreationTime.dwLowDateTime); /* CreationTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftCreationTime.dwHighDateTime); /* CreationTime */\n\t\t\tStream_Write_UINT32(\n\t\t\t    output, file->find_data.ftLastAccessTime.dwLowDateTime); /* LastAccessTime */\n\t\t\tStream_Write_UINT32(\n\t\t\t    output, file->find_data.ftLastAccessTime.dwHighDateTime); /* LastAccessTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftLastWriteTime.dwLowDateTime); /* LastWriteTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftLastWriteTime.dwHighDateTime); /* LastWriteTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftLastWriteTime.dwLowDateTime); /* ChangeTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    file->find_data.ftLastWriteTime.dwHighDateTime); /* ChangeTime */\n\t\t\tStream_Write_UINT32(output, file->find_data.nFileSizeLow);           /* EndOfFile */\n\t\t\tStream_Write_UINT32(output, file->find_data.nFileSizeHigh);          /* EndOfFile */\n\t\t\tStream_Write_UINT32(output, file->find_data.nFileSizeLow);     /* AllocationSize */\n\t\t\tStream_Write_UINT32(output, file->find_data.nFileSizeHigh);    /* AllocationSize */\n\t\t\tStream_Write_UINT32(output, file->find_data.dwFileAttributes); /* FileAttributes */\n\t\t\tStream_Write_UINT32(output, (UINT32)length);                   /* FileNameLength */\n\t\t\tStream_Write_UINT32(output, 0);                                /* EaSize */\n\t\t\tStream_Write_UINT8(output, 0);                                 /* ShortNameLength */\n\t\t\t/* Reserved(1), MUST NOT be added! */\n\t\t\tStream_Zero(output, 24); /* ShortName */\n\t\t\tStream_Write(output, file->find_data.cFileName, length);\n\t\t\tbreak;\n\n\t\tcase FileNamesInformation:\n\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232077.aspx */\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 4 + 12 + length))\n\t\t\t\tgoto out_fail;\n\n\t\t\tif (length > UINT32_MAX - 12)\n\t\t\t\tgoto out_fail;\n\n\t\t\tStream_Write_UINT32(output, (UINT32)(12 + length)); /* Length */\n\t\t\tStream_Write_UINT32(output, 0);                     /* NextEntryOffset */\n\t\t\tStream_Write_UINT32(output, 0);                     /* FileIndex */\n\t\t\tStream_Write_UINT32(output, (UINT32)length);        /* FileNameLength */\n\t\t\tStream_Write(output, file->find_data.cFileName, length);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"unhandled FsInformationClass %\" PRIu32, FsInformationClass);\n\t\t\t/* Unhandled FsInformationClass */\n\t\t\tgoto out_fail;\n\t}\n\n\treturn TRUE;\nout_fail:\n\tStream_Write_UINT32(output, 0); /* Length */\n\tStream_Write_UINT8(output, 0);  /* Padding */\n\treturn FALSE;\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * File System Virtual Channel\n *\n * Copyright 2010-2012 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2010-2011 Vic Lee\n * Copyright 2012 Gerald Richter\n * Copyright 2015 Thincast Technologies GmbH\n * Copyright 2015 DI (FH) Martin Haimberger <martin.haimberger@thincast.com>\n * Copyright 2016 Inuvika Inc.\n * Copyright 2016 David PHAM-VAN <d.phamvan@inuvika.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef FREERDP_CHANNEL_DRIVE_CLIENT_FILE_H\n#define FREERDP_CHANNEL_DRIVE_CLIENT_FILE_H\n\n#include <winpr/stream.h>\n#include <freerdp/channels/log.h>\n\n#define TAG CHANNELS_TAG(\"drive.client\")\n\ntypedef struct _DRIVE_FILE DRIVE_FILE;\n\nstruct _DRIVE_FILE\n{\n\tUINT32 id;\n\tBOOL is_dir;\n\tHANDLE file_handle;\n\tHANDLE find_handle;\n\tWIN32_FIND_DATAW find_data;\n\tconst WCHAR* basepath;\n\tWCHAR* fullpath;\n\tWCHAR* filename;\n\tBOOL delete_pending;\n\tUINT32 FileAttributes;\n\tUINT32 SharedAccess;\n\tUINT32 DesiredAccess;\n\tUINT32 CreateDisposition;\n\tUINT32 CreateOptions;\n};\n\nDRIVE_FILE* drive_file_new(const WCHAR* base_path, const WCHAR* path, UINT32 PathWCharLength,\n                           UINT32 id, UINT32 DesiredAccess, UINT32 CreateDisposition,\n                           UINT32 CreateOptions, UINT32 FileAttributes, UINT32 SharedAccess);\nBOOL drive_file_free(DRIVE_FILE* file);\n\nBOOL drive_file_open(DRIVE_FILE* file);\nBOOL drive_file_seek(DRIVE_FILE* file, UINT64 Offset);\nBOOL drive_file_read(DRIVE_FILE* file, BYTE* buffer, UINT32* Length);\nBOOL drive_file_write(DRIVE_FILE* file, BYTE* buffer, UINT32 Length);\nBOOL drive_file_query_information(DRIVE_FILE* file, UINT32 FsInformationClass, wStream* output);\nBOOL drive_file_set_information(DRIVE_FILE* file, UINT32 FsInformationClass, UINT32 Length,\n                                wStream* input);\nBOOL drive_file_query_directory(DRIVE_FILE* file, UINT32 FsInformationClass, BYTE InitialQuery,\n                                const WCHAR* path, UINT32 PathWCharLength, wStream* output);\n\n#endif /* FREERDP_CHANNEL_DRIVE_FILE_H */\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * File System Virtual Channel\n *\n * Copyright 2010-2011 Vic Lee\n * Copyright 2010-2012 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2015 Thincast Technologies GmbH\n * Copyright 2015 DI (FH) Martin Haimberger <martin.haimberger@thincast.com>\n * Copyright 2016 David PHAM-VAN <d.phamvan@inuvika.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <winpr/crt.h>\n#include <winpr/path.h>\n#include <winpr/file.h>\n#include <winpr/string.h>\n#include <winpr/synch.h>\n#include <winpr/thread.h>\n#include <winpr/stream.h>\n#include <winpr/environment.h>\n#include <winpr/interlocked.h>\n#include <winpr/collections.h>\n#include <winpr/shell.h>\n\n#include <freerdp/channels/rdpdr.h>\n\n#include \"drive_file.h\"\n\ntypedef struct _DRIVE_DEVICE DRIVE_DEVICE;\n\nstruct _DRIVE_DEVICE\n{\n\tDEVICE device;\n\n\tWCHAR* path;\n\tBOOL automount;\n\tUINT32 PathLength;\n\twListDictionary* files;\n\n\tHANDLE thread;\n\twMessageQueue* IrpQueue;\n\n\tDEVMAN* devman;\n\n\trdpContext* rdpcontext;\n};\n\nstatic UINT sys_code_page = 0;\n\nstatic DWORD drive_map_windows_err(DWORD fs_errno)\n{\n\tDWORD rc;\n\n\t/* try to return NTSTATUS version of error code */\n\n\tswitch (fs_errno)\n\t{\n\t\tcase STATUS_SUCCESS:\n\t\t\trc = STATUS_SUCCESS;\n\t\t\tbreak;\n\n\t\tcase ERROR_ACCESS_DENIED:\n\t\tcase ERROR_SHARING_VIOLATION:\n\t\t\trc = STATUS_ACCESS_DENIED;\n\t\t\tbreak;\n\n\t\tcase ERROR_FILE_NOT_FOUND:\n\t\t\trc = STATUS_NO_SUCH_FILE;\n\t\t\tbreak;\n\n\t\tcase ERROR_BUSY_DRIVE:\n\t\t\trc = STATUS_DEVICE_BUSY;\n\t\t\tbreak;\n\n\t\tcase ERROR_INVALID_DRIVE:\n\t\t\trc = STATUS_NO_SUCH_DEVICE;\n\t\t\tbreak;\n\n\t\tcase ERROR_NOT_READY:\n\t\t\trc = STATUS_NO_SUCH_DEVICE;\n\t\t\tbreak;\n\n\t\tcase ERROR_FILE_EXISTS:\n\t\tcase ERROR_ALREADY_EXISTS:\n\t\t\trc = STATUS_OBJECT_NAME_COLLISION;\n\t\t\tbreak;\n\n\t\tcase ERROR_INVALID_NAME:\n\t\t\trc = STATUS_NO_SUCH_FILE;\n\t\t\tbreak;\n\n\t\tcase ERROR_INVALID_HANDLE:\n\t\t\trc = STATUS_INVALID_HANDLE;\n\t\t\tbreak;\n\n\t\tcase ERROR_NO_MORE_FILES:\n\t\t\trc = STATUS_NO_MORE_FILES;\n\t\t\tbreak;\n\n\t\tcase ERROR_DIRECTORY:\n\t\t\trc = STATUS_NOT_A_DIRECTORY;\n\t\t\tbreak;\n\n\t\tcase ERROR_PATH_NOT_FOUND:\n\t\t\trc = STATUS_OBJECT_PATH_NOT_FOUND;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\trc = STATUS_UNSUCCESSFUL;\n\t\t\tWLog_ERR(TAG, \"Error code not found: %\" PRIu32 \"\", fs_errno);\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic DRIVE_FILE* drive_get_file_by_id(DRIVE_DEVICE* drive, UINT32 id)\n{\n\tDRIVE_FILE* file = NULL;\n\tvoid* key = (void*)(size_t)id;\n\n\tif (!drive)\n\t\treturn NULL;\n\n\tfile = (DRIVE_FILE*)ListDictionary_GetItemValue(drive->files, key);\n\treturn file;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_create(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tUINT32 FileId;\n\tDRIVE_FILE* file;\n\tBYTE Information;\n\tUINT32 FileAttributes;\n\tUINT32 SharedAccess;\n\tUINT32 DesiredAccess;\n\tUINT32 CreateDisposition;\n\tUINT32 CreateOptions;\n\tUINT32 PathLength;\n\tUINT64 allocationSize;\n\tconst WCHAR* path;\n\n\tif (!drive || !irp || !irp->devman || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 6 * 4 + 8)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, DesiredAccess);\n\tStream_Read_UINT64(irp->input, allocationSize);\n\tStream_Read_UINT32(irp->input, FileAttributes);\n\tStream_Read_UINT32(irp->input, SharedAccess);\n\tStream_Read_UINT32(irp->input, CreateDisposition);\n\tStream_Read_UINT32(irp->input, CreateOptions);\n\tStream_Read_UINT32(irp->input, PathLength);\n\n\tif (Stream_GetRemainingLength(irp->input) < PathLength)\n\t\treturn ERROR_INVALID_DATA;\n\n\tpath = (const WCHAR*)Stream_Pointer(irp->input);\n\tFileId = irp->devman->id_sequence++;\n\tfile = drive_file_new(drive->path, path, PathLength / sizeof(WCHAR), FileId, DesiredAccess,\n\t                      CreateDisposition, CreateOptions, FileAttributes, SharedAccess);\n\n\tif (!file)\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tFileId = 0;\n\t\tInformation = 0;\n\t}\n\telse\n\t{\n\t\tvoid* key = (void*)(size_t)file->id;\n\n\t\tif (!ListDictionary_Add(drive->files, key, file))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"ListDictionary_Add failed!\");\n\t\t\treturn ERROR_INTERNAL_ERROR;\n\t\t}\n\n\t\tswitch (CreateDisposition)\n\t\t{\n\t\t\tcase FILE_SUPERSEDE:\n\t\t\tcase FILE_OPEN:\n\t\t\tcase FILE_CREATE:\n\t\t\tcase FILE_OVERWRITE:\n\t\t\t\tInformation = FILE_SUPERSEDED;\n\t\t\t\tbreak;\n\n\t\t\tcase FILE_OPEN_IF:\n\t\t\t\tInformation = FILE_OPENED;\n\t\t\t\tbreak;\n\n\t\t\tcase FILE_OVERWRITE_IF:\n\t\t\t\tInformation = FILE_OVERWRITTEN;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tInformation = 0;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tStream_Write_UINT32(irp->output, FileId);\n\tStream_Write_UINT8(irp->output, Information);\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_close(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tvoid* key;\n\tDRIVE_FILE* file;\n\n\tif (!drive || !irp || !irp->Complete || !irp->output)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\tkey = (void*)(size_t)irp->FileId;\n\n\tif (!file)\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\telse\n\t{\n\t\tListDictionary_Remove(drive->files, key);\n\n\t\tif (drive_file_free(file))\n\t\t\tirp->IoStatus = STATUS_SUCCESS;\n\t\telse\n\t\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t}\n\n\tStream_Zero(irp->output, 5); /* Padding(5) */\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_read(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tDRIVE_FILE* file;\n\tUINT32 Length;\n\tUINT64 Offset;\n\n\tif (!drive || !irp || !irp->output || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 12)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Read_UINT64(irp->input, Offset);\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\n\tif (!file)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_seek(file, Offset))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\n\tif (!Stream_EnsureRemainingCapacity(irp->output, Length + 4))\n\t{\n\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\telse if (Length == 0)\n\t\tStream_Write_UINT32(irp->output, 0);\n\telse\n\t{\n\t\tBYTE* buffer = Stream_Pointer(irp->output) + sizeof(UINT32);\n\n\t\tif (!drive_file_read(file, buffer, &Length))\n\t\t{\n\t\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\t\tStream_Write_UINT32(irp->output, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStream_Write_UINT32(irp->output, Length);\n\t\t\tStream_Seek(irp->output, Length);\n\t\t}\n\t}\n\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_write(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tDRIVE_FILE* file;\n\tUINT32 Length;\n\tUINT64 Offset;\n\tvoid* ptr;\n\n\tif (!drive || !irp || !irp->input || !irp->output || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Read_UINT64(irp->input, Offset);\n\tStream_Seek(irp->input, 20); /* Padding */\n\tptr = Stream_Pointer(irp->input);\n\tif (!Stream_SafeSeek(irp->input, Length))\n\t\treturn ERROR_INVALID_DATA;\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\n\tif (!file)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_seek(file, Offset))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_write(file, ptr, Length))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\n\tStream_Write_UINT32(irp->output, Length);\n\tStream_Write_UINT8(irp->output, 0); /* Padding */\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_query_information(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tDRIVE_FILE* file;\n\tUINT32 FsInformationClass;\n\n\tif (!drive || !irp || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 4)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\n\tif (!file)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t}\n\telse if (!drive_file_query_information(file, FsInformationClass, irp->output))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t}\n\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_set_information(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tDRIVE_FILE* file;\n\tUINT32 FsInformationClass;\n\tUINT32 Length;\n\n\tif (!drive || !irp || !irp->Complete || !irp->input || !irp->output)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Seek(irp->input, 24); /* Padding */\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\n\tif (!file)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t}\n\telse if (!drive_file_set_information(file, FsInformationClass, Length, irp->input))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t}\n\n\tif (file && file->is_dir && !PathIsDirectoryEmptyW(file->fullpath))\n\t\tirp->IoStatus = STATUS_DIRECTORY_NOT_EMPTY;\n\n\tStream_Write_UINT32(irp->output, Length);\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_query_volume_information(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tUINT32 FsInformationClass;\n\twStream* output = NULL;\n\tchar* volumeLabel = { \"FREERDP\" };\n\tchar* diskType = { \"FAT32\" };\n\tWCHAR* outStr = NULL;\n\tint length;\n\tDWORD lpSectorsPerCluster;\n\tDWORD lpBytesPerSector;\n\tDWORD lpNumberOfFreeClusters;\n\tDWORD lpTotalNumberOfClusters;\n\tWIN32_FILE_ATTRIBUTE_DATA wfad;\n\n\tif (!drive || !irp)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\toutput = irp->output;\n\n\tif (Stream_GetRemainingLength(irp->input) < 4)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tGetDiskFreeSpaceW(drive->path, &lpSectorsPerCluster, &lpBytesPerSector, &lpNumberOfFreeClusters,\n\t                  &lpTotalNumberOfClusters);\n\n\tswitch (FsInformationClass)\n\t{\n\t\tcase FileFsVolumeInformation:\n\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232108.aspx */\n\t\t\tif ((length = ConvertToUnicode(sys_code_page, 0, volumeLabel, -1, &outStr, 0) * 2) <= 0)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"ConvertToUnicode failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT32(output, 17 + length); /* Length */\n\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 17 + length))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\t\tfree(outStr);\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tGetFileAttributesExW(drive->path, GetFileExInfoStandard, &wfad);\n\t\t\tStream_Write_UINT32(output, wfad.ftCreationTime.dwLowDateTime); /* VolumeCreationTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    wfad.ftCreationTime.dwHighDateTime);      /* VolumeCreationTime */\n\t\t\tStream_Write_UINT32(output, lpNumberOfFreeClusters & 0xffff); /* VolumeSerialNumber */\n\t\t\tStream_Write_UINT32(output, length);                          /* VolumeLabelLength */\n\t\t\tStream_Write_UINT8(output, 0);                                /* SupportsObjects */\n\t\t\t/* Reserved(1), MUST NOT be added! */\n\t\t\tStream_Write(output, outStr, length); /* VolumeLabel (Unicode) */\n\t\t\tfree(outStr);\n\t\t\tbreak;\n\n\t\tcase FileFsSizeInformation:\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232107.aspx */\n\t\t\tStream_Write_UINT32(output, 24); /* Length */\n\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 24))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT64(output, lpTotalNumberOfClusters); /* TotalAllocationUnits */\n\t\t\tStream_Write_UINT64(output, lpNumberOfFreeClusters);  /* AvailableAllocationUnits */\n\t\t\tStream_Write_UINT32(output, lpSectorsPerCluster);     /* SectorsPerAllocationUnit */\n\t\t\tStream_Write_UINT32(output, lpBytesPerSector);        /* BytesPerSector */\n\t\t\tbreak;\n\n\t\tcase FileFsAttributeInformation:\n\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232101.aspx */\n\t\t\tif ((length = ConvertToUnicode(sys_code_page, 0, diskType, -1, &outStr, 0) * 2) <= 0)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"ConvertToUnicode failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT32(output, 12 + length); /* Length */\n\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 12 + length))\n\t\t\t{\n\t\t\t\tfree(outStr);\n\t\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT32(output, FILE_CASE_SENSITIVE_SEARCH | FILE_CASE_PRESERVED_NAMES |\n\t\t\t                                FILE_UNICODE_ON_DISK); /* FileSystemAttributes */\n\t\t\tStream_Write_UINT32(output, MAX_PATH);                 /* MaximumComponentNameLength */\n\t\t\tStream_Write_UINT32(output, length);                   /* FileSystemNameLength */\n\t\t\tStream_Write(output, outStr, length);                  /* FileSystemName (Unicode) */\n\t\t\tfree(outStr);\n\t\t\tbreak;\n\n\t\tcase FileFsFullSizeInformation:\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232104.aspx */\n\t\t\tStream_Write_UINT32(output, 32); /* Length */\n\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 32))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT64(output, lpTotalNumberOfClusters); /* TotalAllocationUnits */\n\t\t\tStream_Write_UINT64(output,\n\t\t\t                    lpNumberOfFreeClusters); /* CallerAvailableAllocationUnits */\n\t\t\tStream_Write_UINT64(output, lpNumberOfFreeClusters); /* AvailableAllocationUnits */\n\t\t\tStream_Write_UINT32(output, lpSectorsPerCluster);    /* SectorsPerAllocationUnit */\n\t\t\tStream_Write_UINT32(output, lpBytesPerSector);       /* BytesPerSector */\n\t\t\tbreak;\n\n\t\tcase FileFsDeviceInformation:\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232109.aspx */\n\t\t\tStream_Write_UINT32(output, 8); /* Length */\n\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 8))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT32(output, FILE_DEVICE_DISK); /* DeviceType */\n\t\t\tStream_Write_UINT32(output, 0);                /* Characteristics */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\t\tStream_Write_UINT32(output, 0); /* Length */\n\t\t\tbreak;\n\t}\n\n\treturn irp->Complete(irp);\n}\n\n/* http://msdn.microsoft.com/en-us/library/cc241518.aspx */\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_silent_ignore(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tUINT32 FsInformationClass;\n\n\tif (!drive || !irp || !irp->output || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 4)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tStream_Write_UINT32(irp->output, 0); /* Length */\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_query_directory(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tconst WCHAR* path;\n\tDRIVE_FILE* file;\n\tBYTE InitialQuery;\n\tUINT32 PathLength;\n\tUINT32 FsInformationClass;\n\n\tif (!drive || !irp || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tStream_Read_UINT8(irp->input, InitialQuery);\n\tStream_Read_UINT32(irp->input, PathLength);\n\tStream_Seek(irp->input, 23); /* Padding */\n\tpath = (WCHAR*)Stream_Pointer(irp->input);\n\tif (!Stream_CheckAndLogRequiredLength(TAG, irp->input, PathLength))\n\t\treturn ERROR_INVALID_DATA;\n\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\n\tif (file == NULL)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tStream_Write_UINT32(irp->output, 0); /* Length */\n\t}\n\telse if (!drive_file_query_directory(file, FsInformationClass, InitialQuery, path,\n\t                                     PathLength / sizeof(WCHAR), irp->output))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t}\n\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_directory_control(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tif (!drive || !irp)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tswitch (irp->MinorFunction)\n\t{\n\t\tcase IRP_MN_QUERY_DIRECTORY:\n\t\t\treturn drive_process_irp_query_directory(drive, irp);\n\n\t\tcase IRP_MN_NOTIFY_CHANGE_DIRECTORY: /* TODO */\n\t\t\treturn irp->Discard(irp);\n\n\t\tdefault:\n\t\t\tirp->IoStatus = STATUS_NOT_SUPPORTED;\n\t\t\tStream_Write_UINT32(irp->output, 0); /* Length */\n\t\t\treturn irp->Complete(irp);\n\t}\n\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_device_control(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tif (!drive || !irp)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tStream_Write_UINT32(irp->output, 0); /* OutputBufferLength */\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tUINT error;\n\n\tif (!drive || !irp)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tirp->IoStatus = STATUS_SUCCESS;\n\n\tswitch (irp->MajorFunction)\n\t{\n\t\tcase IRP_MJ_CREATE:\n\t\t\terror = drive_process_irp_create(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_CLOSE:\n\t\t\terror = drive_process_irp_close(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_READ:\n\t\t\terror = drive_process_irp_read(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_WRITE:\n\t\t\terror = drive_process_irp_write(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_QUERY_INFORMATION:\n\t\t\terror = drive_process_irp_query_information(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_SET_INFORMATION:\n\t\t\terror = drive_process_irp_set_information(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_QUERY_VOLUME_INFORMATION:\n\t\t\terror = drive_process_irp_query_volume_information(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_LOCK_CONTROL:\n\t\t\terror = drive_process_irp_silent_ignore(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_DIRECTORY_CONTROL:\n\t\t\terror = drive_process_irp_directory_control(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_DEVICE_CONTROL:\n\t\t\terror = drive_process_irp_device_control(drive, irp);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tirp->IoStatus = STATUS_NOT_SUPPORTED;\n\t\t\terror = irp->Complete(irp);\n\t\t\tbreak;\n\t}\n\n\treturn error;\n}\n\nstatic DWORD WINAPI drive_thread_func(LPVOID arg)\n{\n\tIRP* irp;\n\twMessage message;\n\tDRIVE_DEVICE* drive = (DRIVE_DEVICE*)arg;\n\tUINT error = CHANNEL_RC_OK;\n\n\tif (!drive)\n\t{\n\t\terror = ERROR_INVALID_PARAMETER;\n\t\tgoto fail;\n\t}\n\n\twhile (1)\n\t{\n\t\tif (!MessageQueue_Wait(drive->IrpQueue))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"MessageQueue_Wait failed!\");\n\t\t\terror = ERROR_INTERNAL_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!MessageQueue_Peek(drive->IrpQueue, &message, TRUE))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"MessageQueue_Peek failed!\");\n\t\t\terror = ERROR_INTERNAL_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (message.id == WMQ_QUIT)\n\t\t\tbreak;\n\n\t\tirp = (IRP*)message.wParam;\n\n\t\tif (irp)\n\t\t{\n\t\t\tif ((error = drive_process_irp(drive, irp)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"drive_process_irp failed with error %\" PRIu32 \"!\", error);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\nfail:\n\n\tif (error && drive && drive->rdpcontext)\n\t\tsetChannelError(drive->rdpcontext, error, \"drive_thread_func reported an error\");\n\n\tExitThread(error);\n\treturn error;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_irp_request(DEVICE* device, IRP* irp)\n{\n\tDRIVE_DEVICE* drive = (DRIVE_DEVICE*)device;\n\n\tif (!drive)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (!MessageQueue_Post(drive->IrpQueue, NULL, 0, (void*)irp, NULL))\n\t{\n\t\tWLog_ERR(TAG, \"MessageQueue_Post failed!\");\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\treturn CHANNEL_RC_OK;\n}\n\nstatic UINT drive_free_int(DRIVE_DEVICE* drive)\n{\n\tUINT error = CHANNEL_RC_OK;\n\n\tif (!drive)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tCloseHandle(drive->thread);\n\tListDictionary_Free(drive->files);\n\tMessageQueue_Free(drive->IrpQueue);\n\tStream_Free(drive->device.data, TRUE);\n\tfree(drive->path);\n\tfree(drive);\n\treturn error;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_free(DEVICE* device)\n{\n\tDRIVE_DEVICE* drive = (DRIVE_DEVICE*)device;\n\tUINT error = CHANNEL_RC_OK;\n\n\tif (!drive)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (MessageQueue_PostQuit(drive->IrpQueue, 0) &&\n\t    (WaitForSingleObject(drive->thread, INFINITE) == WAIT_FAILED))\n\t{\n\t\terror = GetLastError();\n\t\tWLog_ERR(TAG, \"WaitForSingleObject failed with error %\" PRIu32 \"\", error);\n\t\treturn error;\n\t}\n\n\treturn drive_free_int(drive);\n}\n\n/**\n * Helper function used for freeing list dictionary value object\n */\nstatic void drive_file_objfree(void* obj)\n{\n\tdrive_file_free((DRIVE_FILE*)obj);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_register_drive_path(PDEVICE_SERVICE_ENTRY_POINTS pEntryPoints, const char* name,\n                                      const char* path, BOOL automount)\n{\n\tsize_t i, length;\n\tDRIVE_DEVICE* drive;\n\tUINT error = ERROR_INTERNAL_ERROR;\n\n\tif (!pEntryPoints || !name || !path)\n\t{\n\t\tWLog_ERR(TAG, \"[%s] Invalid parameters: pEntryPoints=%p, name=%p, path=%p\", pEntryPoints,\n\t\t         name, path);\n\t\treturn ERROR_INVALID_PARAMETER;\n\t}\n\n\tif (name[0] && path[0])\n\t{\n\t\tsize_t pathLength = strnlen(path, MAX_PATH);\n\t\tdrive = (DRIVE_DEVICE*)calloc(1, sizeof(DRIVE_DEVICE));\n\n\t\tif (!drive)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\t\tdrive->device.type = RDPDR_DTYP_FILESYSTEM;\n\t\tdrive->device.IRPRequest = drive_irp_request;\n\t\tdrive->device.Free = drive_free;\n\t\tdrive->rdpcontext = pEntryPoints->rdpcontext;\n\t\tdrive->automount = automount;\n\t\tlength = strlen(name);\n\t\tdrive->device.data = Stream_New(NULL, length + 1);\n\n\t\tif (!drive->device.data)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Stream_New failed!\");\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tfor (i = 0; i < length; i++)\n\t\t{\n\t\t\t/* Filter 2.2.1.3 Device Announce Header (DEVICE_ANNOUNCE) forbidden symbols */\n\t\t\tswitch (name[i])\n\t\t\t{\n\t\t\t\tcase ':':\n\t\t\t\tcase '<':\n\t\t\t\tcase '>':\n\t\t\t\tcase '\\\"':\n\t\t\t\tcase '/':\n\t\t\t\tcase '\\\\':\n\t\t\t\tcase '|':\n\t\t\t\tcase ' ':\n\t\t\t\t\tStream_Write_UINT8(drive->device.data, '_');\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tStream_Write_UINT8(drive->device.data, (BYTE)name[i]);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tStream_Write_UINT8(drive->device.data, '\\0');\n\n\t\tdrive->device.name = (const char*)Stream_Buffer(drive->device.data);\n\t\tif (!drive->device.name)\n\t\t\tgoto out_error;\n\n\t\tif ((pathLength > 1) && (path[pathLength - 1] == '/'))\n\t\t\tpathLength--;\n\n\t\tif (ConvertToUnicode(sys_code_page, 0, path, pathLength, &drive->path, 0) <= 0)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"ConvertToUnicode failed!\");\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tdrive->files = ListDictionary_New(TRUE);\n\n\t\tif (!drive->files)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"ListDictionary_New failed!\");\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tListDictionary_ValueObject(drive->files)->fnObjectFree = drive_file_objfree;\n\t\tdrive->IrpQueue = MessageQueue_New(NULL);\n\n\t\tif (!drive->IrpQueue)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"ListDictionary_New failed!\");\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tif ((error = pEntryPoints->RegisterDevice(pEntryPoints->devman, (DEVICE*)drive)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"RegisterDevice failed with error %\" PRIu32 \"!\", error);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tif (!(drive->thread =\n\t\t          CreateThread(NULL, 0, drive_thread_func, drive, CREATE_SUSPENDED, NULL)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"CreateThread failed!\");\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tResumeThread(drive->thread);\n\t}\n\n\treturn CHANNEL_RC_OK;\nout_error:\n\tdrive_free_int(drive);\n\treturn error;\n}\n\n#ifdef BUILTIN_CHANNELS\n#define DeviceServiceEntry drive_DeviceServiceEntry\n#else\n#define DeviceServiceEntry FREERDP_API DeviceServiceEntry\n#endif\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nUINT DeviceServiceEntry(PDEVICE_SERVICE_ENTRY_POINTS pEntryPoints)\n{\n\tRDPDR_DRIVE* drive;\n\tUINT error;\n#ifdef WIN32\n\tchar* dev;\n\tint len;\n\tchar devlist[512], buf[512];\n\tchar* bufdup;\n\tchar* devdup;\n#endif\n\tdrive = (RDPDR_DRIVE*)pEntryPoints->device;\n#ifndef WIN32\n\tsys_code_page = CP_UTF8;\n\n\tif (strcmp(drive->Path, \"*\") == 0)\n\t{\n\t\t/* all drives */\n\t\tfree(drive->Path);\n\t\tdrive->Path = _strdup(\"/\");\n\n\t\tif (!drive->Path)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"_strdup failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\t}\n\telse if (strcmp(drive->Path, \"%\") == 0)\n\t{\n\t\tfree(drive->Path);\n\t\tdrive->Path = GetKnownPath(KNOWN_PATH_HOME);\n\n\t\tif (!drive->Path)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"_strdup failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\t}\n\n\terror = drive_register_drive_path(pEntryPoints, drive->Name, drive->Path, drive->automount);\n#else\n\tsys_code_page = GetACP();\n\n\t/* Special case: path[0] == '*' -> export all drives */\n\t/* Special case: path[0] == '%' -> user home dir */\n\tif (strcmp(drive->Path, \"%\") == 0)\n\t{\n\t\tGetEnvironmentVariableA(\"USERPROFILE\", buf, sizeof(buf));\n\t\tPathCchAddBackslashA(buf, sizeof(buf));\n\t\tfree(drive->Path);\n\t\tdrive->Path = _strdup(buf);\n\n\t\tif (!drive->Path)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"_strdup failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\t\terror = drive_register_drive_path(pEntryPoints, drive->Name, drive->Path, drive->automount);\n\t}\n\telse if (strcmp(drive->Path, \"*\") == 0)\n\t{\n\t\tint i;\n\t\t/* Enumerate all devices: */\n\t\tGetLogicalDriveStringsA(sizeof(devlist) - 1, devlist);\n\n\t\tfor (dev = devlist, i = 0; *dev; dev += 4, i++)\n\t\t{\n\t\t\tif (*dev > 'B')\n\t\t\t{\n\t\t\t\t/* Suppress disk drives A and B to avoid pesty messages */\n\t\t\t\tlen = sprintf_s(buf, sizeof(buf) - 4, \"%s\", drive->Name);\n\t\t\t\tbuf[len] = '_';\n\t\t\t\tbuf[len + 1] = dev[0];\n\t\t\t\tbuf[len + 2] = 0;\n\t\t\t\tbuf[len + 3] = 0;\n\n\t\t\t\tif (!(bufdup = _strdup(buf)))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"_strdup failed!\");\n\t\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t\t}\n\n\t\t\t\tif (!(devdup = _strdup(dev)))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"_strdup failed!\");\n\t\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t\t}\n\n\t\t\t\tif ((error = drive_register_drive_path(pEntryPoints, bufdup, devdup, TRUE)))\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\terror = drive_register_drive_path(pEntryPoints, drive->Name, drive->Path, drive->automount);\n\t}\n\n#endif\n\treturn error;\n}\n"], "filenames": ["channels/drive/client/drive_file.c", "channels/drive/client/drive_file.h", "channels/drive/client/drive_main.c"], "buggy_code_start_loc": [64, 54, 187], "buggy_code_end_loc": [777, 68, 644], "fixing_code_start_loc": [64, 54, 187], "fixing_code_end_loc": [801, 68, 644], "type": "CWE-22", "message": "FreeRDP is a free remote desktop protocol library and clients. Affected versions of FreeRDP are missing path canonicalization and base path check for `drive` channel. A malicious server can trick a FreeRDP based client to read files outside the shared directory. This issue has been addressed in version 2.9.0 and all users are advised to upgrade. Users unable to upgrade should not use the `/drive`, `/drives` or `+home-drive` redirection switch.", "other": {"cve": {"id": "CVE-2022-39347", "sourceIdentifier": "security-advisories@github.com", "published": "2022-11-16T20:15:10.367", "lastModified": "2023-01-25T19:56:30.127", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "FreeRDP is a free remote desktop protocol library and clients. Affected versions of FreeRDP are missing path canonicalization and base path check for `drive` channel. A malicious server can trick a FreeRDP based client to read files outside the shared directory. This issue has been addressed in version 2.9.0 and all users are advised to upgrade. Users unable to upgrade should not use the `/drive`, `/drives` or `+home-drive` redirection switch."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.6, "baseSeverity": "LOW"}, "exploitabilityScore": 1.2, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.9.0", "matchCriteriaId": "AF273D61-AA72-44FE-937E-D5749D565AEE"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}], "references": [{"url": "https://github.com/FreeRDP/FreeRDP/commit/027424c2c6c0991cb9c22f9511478229c9b17e5d", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/security/advisories/GHSA-c5xq-8v35-pffg", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/UDOTAOJBCZKREZJPT6VZ25GESI5T6RBG/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/YGQN3OWQNHSMWKOF4D35PF5ASKNLC74B/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FreeRDP/FreeRDP/commit/027424c2c6c0991cb9c22f9511478229c9b17e5d"}}