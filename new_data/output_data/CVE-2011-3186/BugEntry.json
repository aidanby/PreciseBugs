{"buggy_code": ["require 'digest/md5'\n\nmodule ActionController # :nodoc:\n  # Represents an HTTP response generated by a controller action. One can use\n  # an ActionController::Response object to retrieve the current state\n  # of the response, or customize the response. An Response object can\n  # either represent a \"real\" HTTP response (i.e. one that is meant to be sent\n  # back to the web browser) or a test response (i.e. one that is generated\n  # from integration tests). See CgiResponse and TestResponse, respectively.\n  #\n  # Response is mostly a Ruby on Rails framework implement detail, and\n  # should never be used directly in controllers. Controllers should use the\n  # methods defined in ActionController::Base instead. For example, if you want\n  # to set the HTTP response's content MIME type, then use\n  # ActionControllerBase#headers instead of Response#headers.\n  #\n  # Nevertheless, integration tests may want to inspect controller responses in\n  # more detail, and that's when Response can be useful for application\n  # developers. Integration test methods such as\n  # ActionController::Integration::Session#get and\n  # ActionController::Integration::Session#post return objects of type\n  # TestResponse (which are of course also of type Response).\n  #\n  # For example, the following demo integration \"test\" prints the body of the\n  # controller response to the console:\n  #\n  #  class DemoControllerTest < ActionController::IntegrationTest\n  #    def test_print_root_path_to_console\n  #      get('/')\n  #      puts @response.body\n  #    end\n  #  end\n  class Response < Rack::Response\n    DEFAULT_HEADERS = { \"Cache-Control\" => \"no-cache\" }\n    attr_accessor :request\n\n    attr_accessor :session, :assigns, :template, :layout\n    attr_accessor :redirected_to, :redirected_to_method_params\n\n    delegate :default_charset, :to => 'ActionController::Base'\n\n    def initialize\n      @status = 200\n      @header = Rack::Utils::HeaderHash.new(DEFAULT_HEADERS)\n\n      @writer = lambda { |x| @body << x }\n      @block = nil\n\n      @body = \"\",\n      @session = []\n      @assigns = []\n    end\n\n    def location; headers['Location'] end\n    def location=(url) headers['Location'] = url end\n\n\n    # Sets the HTTP response's content MIME type. For example, in the controller\n    # you could write this:\n    #\n    #  response.content_type = \"text/plain\"\n    #\n    # If a character set has been defined for this response (see charset=) then\n    # the character set information will also be included in the content type\n    # information.\n    def content_type=(mime_type)\n      self.headers[\"Content-Type\"] =\n        if mime_type =~ /charset/ || (c = charset).nil?\n          mime_type.to_s\n        else\n          \"#{mime_type}; charset=#{c}\"\n        end\n    end\n\n    # Returns the response's content MIME type, or nil if content type has been set.\n    def content_type\n      content_type = String(headers[\"Content-Type\"] || headers[\"type\"]).split(\";\")[0]\n      content_type.blank? ? nil : content_type\n    end\n\n    # Set the charset of the Content-Type header. Set to nil to remove it.\n    # If no content type is set, it defaults to HTML.\n    def charset=(charset)\n      headers[\"Content-Type\"] =\n        if charset\n          \"#{content_type || Mime::HTML}; charset=#{charset}\"\n        else\n          content_type || Mime::HTML.to_s\n        end\n    end\n\n    def charset\n      charset = String(headers[\"Content-Type\"] || headers[\"type\"]).split(\";\")[1]\n      charset.blank? ? nil : charset.strip.split(\"=\")[1]\n    end\n\n    def last_modified\n      if last = headers['Last-Modified']\n        Time.httpdate(last)\n      end\n    end\n\n    def last_modified?\n      headers.include?('Last-Modified')\n    end\n\n    def last_modified=(utc_time)\n      headers['Last-Modified'] = utc_time.httpdate\n    end\n\n    def etag\n      headers['ETag']\n    end\n\n    def etag?\n      headers.include?('ETag')\n    end\n\n    def etag=(etag)\n      headers['ETag'] = %(\"#{Digest::MD5.hexdigest(ActiveSupport::Cache.expand_cache_key(etag))}\")\n    end\n\n    def redirect(url, status)\n      self.status = status\n      self.location = url.gsub(/[\\r\\n]/, '')\n      self.body = \"<html><body>You are being <a href=\\\"#{CGI.escapeHTML(url)}\\\">redirected</a>.</body></html>\"\n    end\n\n    def sending_file?\n      headers[\"Content-Transfer-Encoding\"] == \"binary\"\n    end\n\n    def assign_default_content_type_and_charset!\n      self.content_type ||= Mime::HTML\n      self.charset ||= default_charset unless sending_file?\n    end\n\n    def prepare!\n      assign_default_content_type_and_charset!\n      handle_conditional_get!\n      set_content_length!\n      convert_content_type!\n      convert_language!\n      convert_cookies!\n    end\n\n    def each(&callback)\n      if @body.respond_to?(:call)\n        @writer = lambda { |x| callback.call(x) }\n        @body.call(self, self)\n      elsif @body.respond_to?(:to_str)\n        yield @body\n      else\n        @body.each(&callback)\n      end\n\n      @writer = callback\n      @block.call(self) if @block\n    end\n\n    def write(str)\n      @writer.call str.to_s\n      str\n    end\n\n    def flush #:nodoc:\n      ActiveSupport::Deprecation.warn(\n        'Calling output.flush is no longer needed for streaming output ' +\n        'because ActionController::Response automatically handles it', caller)\n    end\n\n    def set_cookie(key, value)\n      if value.has_key?(:http_only)\n        ActiveSupport::Deprecation.warn(\n          \"The :http_only option in ActionController::Response#set_cookie \" +\n          \"has been renamed. Please use :httponly instead.\", caller)\n        value[:httponly] ||= value.delete(:http_only)\n      end\n\n      super(key, value)\n    end\n\n    private\n      def handle_conditional_get!\n        if etag? || last_modified?\n          set_conditional_cache_control!\n        elsif nonempty_ok_response?\n          self.etag = body\n\n          if request && request.etag_matches?(etag)\n            self.status = '304 Not Modified'\n            self.body = ''\n          end\n\n          set_conditional_cache_control!\n        end\n      end\n\n      def nonempty_ok_response?\n        ok = !status || status.to_s[0..2] == '200'\n        ok && body.is_a?(String) && !body.blank?\n      end\n\n      def set_conditional_cache_control!\n        if headers['Cache-Control'] == DEFAULT_HEADERS['Cache-Control']\n          headers['Cache-Control'] = 'private, max-age=0, must-revalidate'\n        end\n      end\n\n      def convert_content_type!\n        headers['Content-Type'] ||= \"text/html\"\n        headers['Content-Type'] += \"; charset=\" + headers.delete('charset') if headers['charset']\n      end\n\n      # Don't set the Content-Length for block-based bodies as that would mean\n      # reading it all into memory. Not nice for, say, a 2GB streaming file.\n      def set_content_length!\n        if status && status.to_s[0..2] == '204'\n          headers.delete('Content-Length')\n        elsif length = headers['Content-Length']\n          headers['Content-Length'] = length.to_s\n        elsif !body.respond_to?(:call) && (!status || status.to_s[0..2] != '304')\n          headers[\"Content-Length\"] = (body.respond_to?(:bytesize) ? body.bytesize : body.size).to_s\n        end\n      end\n\n      def convert_language!\n        headers[\"Content-Language\"] = headers.delete(\"language\") if headers[\"language\"]\n      end\n\n      def convert_cookies!\n        cookies = Array(headers['Set-Cookie']).compact\n        headers['Set-Cookie'] = cookies unless cookies.empty?\n      end\n  end\nend\n", "require 'abstract_unit'\n\nclass ContentTypeController < ActionController::Base\n  def render_content_type_from_body\n    response.content_type = Mime::RSS\n    render :text => \"hello world!\"\n  end\n\n  def render_defaults\n    render :text => \"hello world!\"\n  end\n\n  def render_content_type_from_render\n    render :text => \"hello world!\", :content_type => Mime::RSS\n  end\n\n  def render_charset_from_body\n    response.charset = \"utf-16\"\n    render :text => \"hello world!\"\n  end\n\n  def render_nil_charset_from_body\n    response.charset = nil\n    render :text => \"hello world!\"\n  end\n\n  def render_default_for_rhtml\n  end\n\n  def render_default_for_rxml\n  end\n\n  def render_default_for_rjs\n  end\n\n  def render_change_for_rxml\n    response.content_type = Mime::HTML\n    render :action => \"render_default_for_rxml\"\n  end\n\n  def render_default_content_types_for_respond_to\n    respond_to do |format|\n      format.html { render :text   => \"hello world!\" }\n      format.xml  { render :action => \"render_default_content_types_for_respond_to.rhtml\" }\n      format.js   { render :text   => \"hello world!\" }\n      format.rss  { render :text   => \"hello world!\", :content_type => Mime::XML }\n    end\n  end\n\n  def rescue_action(e) raise end\nend\n\nclass ContentTypeTest < ActionController::TestCase\n  tests ContentTypeController\n\n  def setup\n    # enable a logger so that (e.g.) the benchmarking stuff runs, so we can get\n    # a more accurate simulation of what happens in \"real life\".\n    @controller.logger = Logger.new(nil)\n  end\n\n  def test_render_defaults\n    get :render_defaults\n    assert_equal \"utf-8\", @response.charset\n    assert_equal Mime::HTML, @response.content_type\n  end\n\n  def test_render_changed_charset_default\n    ContentTypeController.default_charset = \"utf-16\"\n    get :render_defaults\n    assert_equal \"utf-16\", @response.charset\n    assert_equal Mime::HTML, @response.content_type\n    ContentTypeController.default_charset = \"utf-8\"\n  end\n\n  def test_content_type_from_body\n    get :render_content_type_from_body\n    assert_equal \"application/rss+xml\", @response.content_type\n    assert_equal \"utf-8\", @response.charset\n  end\n\n  def test_content_type_from_render\n    get :render_content_type_from_render\n    assert_equal \"application/rss+xml\", @response.content_type\n    assert_equal \"utf-8\", @response.charset\n  end\n\n  def test_charset_from_body\n    get :render_charset_from_body\n    assert_equal Mime::HTML, @response.content_type\n    assert_equal \"utf-16\", @response.charset\n  end\n\n  def test_nil_charset_from_body\n    get :render_nil_charset_from_body\n    assert_equal Mime::HTML, @response.content_type\n    assert_equal \"utf-8\", @response.charset, @response.headers.inspect\n  end\n\n  def test_nil_default_for_rhtml\n    ContentTypeController.default_charset = nil\n    get :render_default_for_rhtml\n    assert_equal Mime::HTML, @response.content_type\n    assert_nil @response.charset, @response.headers.inspect\n  ensure\n    ContentTypeController.default_charset = \"utf-8\"\n  end\n\n  def test_default_for_rhtml\n    get :render_default_for_rhtml\n    assert_equal Mime::HTML, @response.content_type\n    assert_equal \"utf-8\", @response.charset\n  end\n\n  def test_default_for_rxml\n    get :render_default_for_rxml\n    assert_equal Mime::XML, @response.content_type\n    assert_equal \"utf-8\", @response.charset\n  end\n\n  def test_default_for_rjs\n    xhr :post, :render_default_for_rjs\n    assert_equal Mime::JS, @response.content_type\n    assert_equal \"utf-8\", @response.charset\n  end\n\n  def test_change_for_rxml\n    get :render_change_for_rxml\n    assert_equal Mime::HTML, @response.content_type\n    assert_equal \"utf-8\", @response.charset\n  end\nend\n\nclass AcceptBasedContentTypeTest < ActionController::TestCase\n\n  tests ContentTypeController\n\n  def setup\n    ActionController::Base.use_accept_header = true\n  end\n\n  def teardown\n    ActionController::Base.use_accept_header = false\n  end\n\n\n  def test_render_default_content_types_for_respond_to\n    @request.accept = Mime::HTML.to_s\n    get :render_default_content_types_for_respond_to\n    assert_equal Mime::HTML, @response.content_type\n\n    @request.accept = Mime::JS.to_s\n    get :render_default_content_types_for_respond_to\n    assert_equal Mime::JS, @response.content_type\n  end\n\n  def test_render_default_content_types_for_respond_to_with_template\n    @request.accept = Mime::XML.to_s\n    get :render_default_content_types_for_respond_to\n    assert_equal Mime::XML, @response.content_type\n  end\n\n  def test_render_default_content_types_for_respond_to_with_overwrite\n    @request.accept = Mime::RSS.to_s\n    get :render_default_content_types_for_respond_to\n    assert_equal Mime::XML, @response.content_type\n  end\nend\n"], "fixing_code": ["require 'digest/md5'\n\nmodule ActionController # :nodoc:\n  # Represents an HTTP response generated by a controller action. One can use\n  # an ActionController::Response object to retrieve the current state\n  # of the response, or customize the response. An Response object can\n  # either represent a \"real\" HTTP response (i.e. one that is meant to be sent\n  # back to the web browser) or a test response (i.e. one that is generated\n  # from integration tests). See CgiResponse and TestResponse, respectively.\n  #\n  # Response is mostly a Ruby on Rails framework implement detail, and\n  # should never be used directly in controllers. Controllers should use the\n  # methods defined in ActionController::Base instead. For example, if you want\n  # to set the HTTP response's content MIME type, then use\n  # ActionControllerBase#headers instead of Response#headers.\n  #\n  # Nevertheless, integration tests may want to inspect controller responses in\n  # more detail, and that's when Response can be useful for application\n  # developers. Integration test methods such as\n  # ActionController::Integration::Session#get and\n  # ActionController::Integration::Session#post return objects of type\n  # TestResponse (which are of course also of type Response).\n  #\n  # For example, the following demo integration \"test\" prints the body of the\n  # controller response to the console:\n  #\n  #  class DemoControllerTest < ActionController::IntegrationTest\n  #    def test_print_root_path_to_console\n  #      get('/')\n  #      puts @response.body\n  #    end\n  #  end\n  class Response < Rack::Response\n    DEFAULT_HEADERS = { \"Cache-Control\" => \"no-cache\" }\n    attr_accessor :request\n\n    attr_accessor :session, :assigns, :template, :layout\n    attr_accessor :redirected_to, :redirected_to_method_params\n\n    delegate :default_charset, :to => 'ActionController::Base'\n\n    def initialize\n      @status = 200\n      @header = Rack::Utils::HeaderHash.new(DEFAULT_HEADERS)\n\n      @writer = lambda { |x| @body << x }\n      @block = nil\n\n      @body = \"\",\n      @session = []\n      @assigns = []\n    end\n\n    def location; headers['Location'] end\n    def location=(url) headers['Location'] = url end\n\n\n    # Sets the HTTP response's content MIME type. For example, in the controller\n    # you could write this:\n    #\n    #  response.content_type = \"text/plain\"\n    #\n    # If a character set has been defined for this response (see charset=) then\n    # the character set information will also be included in the content type\n    # information.\n    def content_type=(mime_type)\n      new_content_type =\n        if mime_type =~ /charset/ || (c = charset).nil?\n          mime_type.to_s\n        else\n          \"#{mime_type}; charset=#{c}\"\n        end\n      self.headers[\"Content-Type\"] = URI.escape(new_content_type, \"\\r\\n\")\n    end\n\n    # Returns the response's content MIME type, or nil if content type has been set.\n    def content_type\n      content_type = String(headers[\"Content-Type\"] || headers[\"type\"]).split(\";\")[0]\n      content_type.blank? ? nil : content_type\n    end\n\n    # Set the charset of the Content-Type header. Set to nil to remove it.\n    # If no content type is set, it defaults to HTML.\n    def charset=(charset)\n      headers[\"Content-Type\"] =\n        if charset\n          \"#{content_type || Mime::HTML}; charset=#{charset}\"\n        else\n          content_type || Mime::HTML.to_s\n        end\n    end\n\n    def charset\n      charset = String(headers[\"Content-Type\"] || headers[\"type\"]).split(\";\")[1]\n      charset.blank? ? nil : charset.strip.split(\"=\")[1]\n    end\n\n    def last_modified\n      if last = headers['Last-Modified']\n        Time.httpdate(last)\n      end\n    end\n\n    def last_modified?\n      headers.include?('Last-Modified')\n    end\n\n    def last_modified=(utc_time)\n      headers['Last-Modified'] = utc_time.httpdate\n    end\n\n    def etag\n      headers['ETag']\n    end\n\n    def etag?\n      headers.include?('ETag')\n    end\n\n    def etag=(etag)\n      headers['ETag'] = %(\"#{Digest::MD5.hexdigest(ActiveSupport::Cache.expand_cache_key(etag))}\")\n    end\n\n    def redirect(url, status)\n      self.status = status\n      self.location = url.gsub(/[\\r\\n]/, '')\n      self.body = \"<html><body>You are being <a href=\\\"#{CGI.escapeHTML(url)}\\\">redirected</a>.</body></html>\"\n    end\n\n    def sending_file?\n      headers[\"Content-Transfer-Encoding\"] == \"binary\"\n    end\n\n    def assign_default_content_type_and_charset!\n      self.content_type ||= Mime::HTML\n      self.charset ||= default_charset unless sending_file?\n    end\n\n    def prepare!\n      assign_default_content_type_and_charset!\n      handle_conditional_get!\n      set_content_length!\n      convert_content_type!\n      convert_language!\n      convert_cookies!\n    end\n\n    def each(&callback)\n      if @body.respond_to?(:call)\n        @writer = lambda { |x| callback.call(x) }\n        @body.call(self, self)\n      elsif @body.respond_to?(:to_str)\n        yield @body\n      else\n        @body.each(&callback)\n      end\n\n      @writer = callback\n      @block.call(self) if @block\n    end\n\n    def write(str)\n      @writer.call str.to_s\n      str\n    end\n\n    def flush #:nodoc:\n      ActiveSupport::Deprecation.warn(\n        'Calling output.flush is no longer needed for streaming output ' +\n        'because ActionController::Response automatically handles it', caller)\n    end\n\n    def set_cookie(key, value)\n      if value.has_key?(:http_only)\n        ActiveSupport::Deprecation.warn(\n          \"The :http_only option in ActionController::Response#set_cookie \" +\n          \"has been renamed. Please use :httponly instead.\", caller)\n        value[:httponly] ||= value.delete(:http_only)\n      end\n\n      super(key, value)\n    end\n\n    private\n      def handle_conditional_get!\n        if etag? || last_modified?\n          set_conditional_cache_control!\n        elsif nonempty_ok_response?\n          self.etag = body\n\n          if request && request.etag_matches?(etag)\n            self.status = '304 Not Modified'\n            self.body = ''\n          end\n\n          set_conditional_cache_control!\n        end\n      end\n\n      def nonempty_ok_response?\n        ok = !status || status.to_s[0..2] == '200'\n        ok && body.is_a?(String) && !body.blank?\n      end\n\n      def set_conditional_cache_control!\n        if headers['Cache-Control'] == DEFAULT_HEADERS['Cache-Control']\n          headers['Cache-Control'] = 'private, max-age=0, must-revalidate'\n        end\n      end\n\n      def convert_content_type!\n        headers['Content-Type'] ||= \"text/html\"\n        headers['Content-Type'] += \"; charset=\" + headers.delete('charset') if headers['charset']\n      end\n\n      # Don't set the Content-Length for block-based bodies as that would mean\n      # reading it all into memory. Not nice for, say, a 2GB streaming file.\n      def set_content_length!\n        if status && status.to_s[0..2] == '204'\n          headers.delete('Content-Length')\n        elsif length = headers['Content-Length']\n          headers['Content-Length'] = length.to_s\n        elsif !body.respond_to?(:call) && (!status || status.to_s[0..2] != '304')\n          headers[\"Content-Length\"] = (body.respond_to?(:bytesize) ? body.bytesize : body.size).to_s\n        end\n      end\n\n      def convert_language!\n        headers[\"Content-Language\"] = headers.delete(\"language\") if headers[\"language\"]\n      end\n\n      def convert_cookies!\n        cookies = Array(headers['Set-Cookie']).compact\n        headers['Set-Cookie'] = cookies unless cookies.empty?\n      end\n  end\nend\n", "require 'abstract_unit'\n\nclass ContentTypeController < ActionController::Base\n  def render_content_type_from_body\n    response.content_type = Mime::RSS\n    render :text => \"hello world!\"\n  end\n\n  def render_defaults\n    render :text => \"hello world!\"\n  end\n\n  def render_content_type_from_render\n    render :text => \"hello world!\", :content_type => Mime::RSS\n  end\n\n  def render_charset_from_body\n    response.charset = \"utf-16\"\n    render :text => \"hello world!\"\n  end\n\n  def render_nil_charset_from_body\n    response.charset = nil\n    render :text => \"hello world!\"\n  end\n\n  def render_default_for_rhtml\n  end\n\n  def render_default_for_rxml\n  end\n\n  def render_default_for_rjs\n  end\n\n  def render_change_for_rxml\n    response.content_type = Mime::HTML\n    render :action => \"render_default_for_rxml\"\n  end\n\n  def render_default_content_types_for_respond_to\n    respond_to do |format|\n      format.html { render :text   => \"hello world!\" }\n      format.xml  { render :action => \"render_default_content_types_for_respond_to.rhtml\" }\n      format.js   { render :text   => \"hello world!\" }\n      format.rss  { render :text   => \"hello world!\", :content_type => Mime::XML }\n    end\n  end\n  \n  def render_content_type_from_user_input\n    response.content_type= params[:hello]\n    render :text=>\"hello\"\n  end\n\n  def rescue_action(e) raise end\nend\n\nclass ContentTypeTest < ActionController::TestCase\n  tests ContentTypeController\n\n  def setup\n    # enable a logger so that (e.g.) the benchmarking stuff runs, so we can get\n    # a more accurate simulation of what happens in \"real life\".\n    @controller.logger = Logger.new(nil)\n  end\n\n  def test_render_defaults\n    get :render_defaults\n    assert_equal \"utf-8\", @response.charset\n    assert_equal Mime::HTML, @response.content_type\n  end\n\n  def test_render_changed_charset_default\n    ContentTypeController.default_charset = \"utf-16\"\n    get :render_defaults\n    assert_equal \"utf-16\", @response.charset\n    assert_equal Mime::HTML, @response.content_type\n    ContentTypeController.default_charset = \"utf-8\"\n  end\n\n  def test_content_type_from_body\n    get :render_content_type_from_body\n    assert_equal \"application/rss+xml\", @response.content_type\n    assert_equal \"utf-8\", @response.charset\n  end\n\n  def test_content_type_from_render\n    get :render_content_type_from_render\n    assert_equal \"application/rss+xml\", @response.content_type\n    assert_equal \"utf-8\", @response.charset\n  end\n\n  def test_charset_from_body\n    get :render_charset_from_body\n    assert_equal Mime::HTML, @response.content_type\n    assert_equal \"utf-16\", @response.charset\n  end\n\n  def test_nil_charset_from_body\n    get :render_nil_charset_from_body\n    assert_equal Mime::HTML, @response.content_type\n    assert_equal \"utf-8\", @response.charset, @response.headers.inspect\n  end\n\n  def test_nil_default_for_rhtml\n    ContentTypeController.default_charset = nil\n    get :render_default_for_rhtml\n    assert_equal Mime::HTML, @response.content_type\n    assert_nil @response.charset, @response.headers.inspect\n  ensure\n    ContentTypeController.default_charset = \"utf-8\"\n  end\n\n  def test_default_for_rhtml\n    get :render_default_for_rhtml\n    assert_equal Mime::HTML, @response.content_type\n    assert_equal \"utf-8\", @response.charset\n  end\n\n  def test_default_for_rxml\n    get :render_default_for_rxml\n    assert_equal Mime::XML, @response.content_type\n    assert_equal \"utf-8\", @response.charset\n  end\n\n  def test_default_for_rjs\n    xhr :post, :render_default_for_rjs\n    assert_equal Mime::JS, @response.content_type\n    assert_equal \"utf-8\", @response.charset\n  end\n\n  def test_change_for_rxml\n    get :render_change_for_rxml\n    assert_equal Mime::HTML, @response.content_type\n    assert_equal \"utf-8\", @response.charset\n  end\n  \n  def test_user_supplied_value\n    get :render_content_type_from_user_input, :hello=>\"hello/world\\r\\nAttack: true\"\n    assert_equal \"hello/world%0D%0AAttack: true\", @response.content_type\n  end\nend\n\nclass AcceptBasedContentTypeTest < ActionController::TestCase\n\n  tests ContentTypeController\n\n  def setup\n    ActionController::Base.use_accept_header = true\n  end\n\n  def teardown\n    ActionController::Base.use_accept_header = false\n  end\n\n\n  def test_render_default_content_types_for_respond_to\n    @request.accept = Mime::HTML.to_s\n    get :render_default_content_types_for_respond_to\n    assert_equal Mime::HTML, @response.content_type\n\n    @request.accept = Mime::JS.to_s\n    get :render_default_content_types_for_respond_to\n    assert_equal Mime::JS, @response.content_type\n  end\n\n  def test_render_default_content_types_for_respond_to_with_template\n    @request.accept = Mime::XML.to_s\n    get :render_default_content_types_for_respond_to\n    assert_equal Mime::XML, @response.content_type\n  end\n\n  def test_render_default_content_types_for_respond_to_with_overwrite\n    @request.accept = Mime::RSS.to_s\n    get :render_default_content_types_for_respond_to\n    assert_equal Mime::XML, @response.content_type\n  end\nend\n"], "filenames": ["actionpack/lib/action_controller/response.rb", "actionpack/test/controller/content_type_test.rb"], "buggy_code_start_loc": [67, 47], "buggy_code_end_loc": [72, 131], "fixing_code_start_loc": [67, 48], "fixing_code_end_loc": [74, 142], "type": "CWE-94", "message": "CRLF injection vulnerability in actionpack/lib/action_controller/response.rb in Ruby on Rails 2.3.x before 2.3.13 allows remote attackers to inject arbitrary HTTP headers and conduct HTTP response splitting attacks via the Content-Type header.", "other": {"cve": {"id": "CVE-2011-3186", "sourceIdentifier": "secalert@redhat.com", "published": "2011-08-29T18:55:01.643", "lastModified": "2019-08-08T14:38:51.640", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "CRLF injection vulnerability in actionpack/lib/action_controller/response.rb in Ruby on Rails 2.3.x before 2.3.13 allows remote attackers to inject arbitrary HTTP headers and conduct HTTP response splitting attacks via the Content-Type header."}, {"lang": "es", "value": "Vulnerabilidad de falsificaci\u00f3n de petici\u00f3n en sitios cruzados (CRLF) actionpack/lib/action_controller/response.rb en Ruby on Rails v2.3.x antes dev 2.3.13 permite a atacantes remotos inyectar cabeceras HTTP de su elecci\u00f3n y llevar a cabo ataques HTTP de divisi\u00f3n de respuesta a trav\u00e9s de la cabecera Content-Type."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-94"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "D1467583-23E9-4E2B-982D-80A356174BB6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "4DC784C0-5618-4C32-8C17-BE7041656E14"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "CFB9ABB5-1F78-4CF0-BA82-7833E0F7A56E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.3.9:*:*:*:*:*:*:*", "matchCriteriaId": "AF3ED96F-3EA4-4E47-A559-9DF9A7D3DDE2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.3.10:*:*:*:*:*:*:*", "matchCriteriaId": "3B38EAA4-E948-45A7-B6E5-7214F2B545E3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.3.11:*:*:*:*:*:*:*", "matchCriteriaId": "6ECC8C49-5A46-4D23-81F9-8243F5D508DB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.3.12:*:*:*:*:*:*:*", "matchCriteriaId": "312848C5-BA35-4A48-B66D-195A5E1CD00F"}]}]}], "references": [{"url": "http://groups.google.com/group/rubyonrails-security/msg/bbe342e43abaa78c?dmode=source&output=gplain", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2011-September/065137.html", "source": "secalert@redhat.com"}, {"url": "http://www.debian.org/security/2011/dsa-2301", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2011/08/17/1", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://www.openwall.com/lists/oss-security/2011/08/19/11", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://www.openwall.com/lists/oss-security/2011/08/20/1", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://www.openwall.com/lists/oss-security/2011/08/22/13", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://www.openwall.com/lists/oss-security/2011/08/22/14", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2011/08/22/5", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=732156", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://github.com/rails/rails/commit/11dafeaa7533be26441a63618be93a03869c83a9", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/rails/rails/commit/11dafeaa7533be26441a63618be93a03869c83a9"}}