{"buggy_code": ["/*\n *  Copyright (C) 2005-2018 Team Kodi\n *  This file is part of Kodi - https://kodi.tv\n *\n *  SPDX-License-Identifier: GPL-2.0-or-later\n *  See LICENSES/README.md for more information.\n */\n\n#include \"PlayListPLS.h\"\n\n#include \"PlayListFactory.h\"\n#include \"Util.h\"\n#include \"filesystem/File.h\"\n#include \"music/tags/MusicInfoTag.h\"\n#include \"utils/CharsetConverter.h\"\n#include \"utils/StringUtils.h\"\n#include \"utils/URIUtils.h\"\n#include \"utils/XBMCTinyXML.h\"\n#include \"utils/XMLUtils.h\"\n#include \"utils/log.h\"\n#include \"video/VideoInfoTag.h\"\n\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n\nusing namespace XFILE;\nusing namespace PLAYLIST;\n\n#define START_PLAYLIST_MARKER \"[playlist]\" // may be case-insensitive (equivalent to .ini file on win32)\n#define PLAYLIST_NAME     \"PlaylistName\"\n\n/*----------------------------------------------------------------------\n[playlist]\nPlaylistName=Playlist 001\nFile1=E:\\Program Files\\Winamp3\\demo.mp3\nTitle1=demo\nLength1=5\nFile2=E:\\Program Files\\Winamp3\\demo.mp3\nTitle2=demo\nLength2=5\nNumberOfEntries=2\nVersion=2\n----------------------------------------------------------------------*/\nCPlayListPLS::CPlayListPLS(void) = default;\n\nCPlayListPLS::~CPlayListPLS(void) = default;\n\nbool CPlayListPLS::Load(const std::string &strFile)\n{\n  //read it from the file\n  std::string strFileName(strFile);\n  m_strPlayListName = URIUtils::GetFileName(strFileName);\n\n  Clear();\n\n  bool bShoutCast = false;\n  if( StringUtils::StartsWithNoCase(strFileName, \"shout://\") )\n  {\n    strFileName.replace(0, 8, \"http://\");\n    m_strBasePath = \"\";\n    bShoutCast = true;\n  }\n  else\n    URIUtils::GetParentPath(strFileName, m_strBasePath);\n\n  CFile file;\n  if (!file.Open(strFileName) )\n  {\n    file.Close();\n    return false;\n  }\n\n  if (file.GetLength() > 1024*1024)\n  {\n    CLog::Log(LOGWARNING, \"{} - File is larger than 1 MB, most likely not a playlist\",\n              __FUNCTION__);\n    return false;\n  }\n\n  char szLine[4096];\n  std::string strLine;\n\n  // run through looking for the [playlist] marker.\n  // if we find another http stream, then load it.\n  while (true)\n  {\n    if ( !file.ReadString(szLine, sizeof(szLine) ) )\n    {\n      file.Close();\n      return size() > 0;\n    }\n    strLine = szLine;\n    StringUtils::Trim(strLine);\n    if(StringUtils::EqualsNoCase(strLine, START_PLAYLIST_MARKER))\n      break;\n\n    // if there is something else before playlist marker, this isn't a pls file\n    if(!strLine.empty())\n      return false;\n  }\n\n  bool bFailed = false;\n  while (file.ReadString(szLine, sizeof(szLine) ) )\n  {\n    strLine = szLine;\n    StringUtils::RemoveCRLF(strLine);\n    size_t iPosEqual = strLine.find('=');\n    if (iPosEqual != std::string::npos)\n    {\n      std::string strLeft = strLine.substr(0, iPosEqual);\n      iPosEqual++;\n      std::string strValue = strLine.substr(iPosEqual);\n      StringUtils::ToLower(strLeft);\n      StringUtils::TrimLeft(strLeft);\n\n      if (strLeft == \"numberofentries\")\n      {\n        m_vecItems.reserve(atoi(strValue.c_str()));\n      }\n      else if (StringUtils::StartsWith(strLeft, \"file\"))\n      {\n        std::vector <int>::size_type idx = atoi(strLeft.c_str() + 4);\n        if (!Resize(idx))\n        {\n          bFailed = true;\n          break;\n        }\n\n        // Skip self - do not load playlist recursively\n        if (StringUtils::EqualsNoCase(URIUtils::GetFileName(strValue),\n                                      URIUtils::GetFileName(strFileName)))\n          continue;\n\n        if (m_vecItems[idx - 1]->GetLabel().empty())\n          m_vecItems[idx - 1]->SetLabel(URIUtils::GetFileName(strValue));\n        CFileItem item(strValue, false);\n        if (bShoutCast && !item.IsAudio())\n          strValue.replace(0, 7, \"shout://\");\n\n        strValue = URIUtils::SubstitutePath(strValue);\n        CUtil::GetQualifiedFilename(m_strBasePath, strValue);\n        g_charsetConverter.unknownToUTF8(strValue);\n        m_vecItems[idx - 1]->SetPath(strValue);\n      }\n      else if (StringUtils::StartsWith(strLeft, \"title\"))\n      {\n        std::vector <int>::size_type idx = atoi(strLeft.c_str() + 5);\n        if (!Resize(idx))\n        {\n          bFailed = true;\n          break;\n        }\n        g_charsetConverter.unknownToUTF8(strValue);\n        m_vecItems[idx - 1]->SetLabel(strValue);\n      }\n      else if (StringUtils::StartsWith(strLeft, \"length\"))\n      {\n        std::vector <int>::size_type idx = atoi(strLeft.c_str() + 6);\n        if (!Resize(idx))\n        {\n          bFailed = true;\n          break;\n        }\n        m_vecItems[idx - 1]->GetMusicInfoTag()->SetDuration(atol(strValue.c_str()));\n      }\n      else if (strLeft == \"playlistname\")\n      {\n        m_strPlayListName = strValue;\n        g_charsetConverter.unknownToUTF8(m_strPlayListName);\n      }\n    }\n  }\n  file.Close();\n\n  if (bFailed)\n  {\n    CLog::Log(LOGERROR,\n              \"File {} is not a valid PLS playlist. Location of first file,title or length is not \"\n              \"permitted (eg. File0 should be File1)\",\n              URIUtils::GetFileName(strFileName));\n    return false;\n  }\n\n  // check for missing entries\n  ivecItems p = m_vecItems.begin();\n  while ( p != m_vecItems.end())\n  {\n    if ((*p)->GetPath().empty())\n    {\n      p = m_vecItems.erase(p);\n    }\n    else\n    {\n      ++p;\n    }\n  }\n\n  return true;\n}\n\nvoid CPlayListPLS::Save(const std::string& strFileName) const\n{\n  if (!m_vecItems.size()) return ;\n  std::string strPlaylist = CUtil::MakeLegalPath(strFileName);\n  CFile file;\n  if (!file.OpenForWrite(strPlaylist, true))\n  {\n    CLog::Log(LOGERROR, \"Could not save PLS playlist: [{}]\", strPlaylist);\n    return;\n  }\n  std::string write;\n  write += StringUtils::Format(\"{}\\n\", START_PLAYLIST_MARKER);\n  std::string strPlayListName=m_strPlayListName;\n  g_charsetConverter.utf8ToStringCharset(strPlayListName);\n  write += StringUtils::Format(\"PlaylistName={}\\n\", strPlayListName);\n\n  for (int i = 0; i < (int)m_vecItems.size(); ++i)\n  {\n    CFileItemPtr item = m_vecItems[i];\n    std::string strFileName=item->GetPath();\n    g_charsetConverter.utf8ToStringCharset(strFileName);\n    std::string strDescription=item->GetLabel();\n    g_charsetConverter.utf8ToStringCharset(strDescription);\n    write += StringUtils::Format(\"File{}={}\\n\", i + 1, strFileName);\n    write += StringUtils::Format(\"Title{}={}\\n\", i + 1, strDescription.c_str());\n    write +=\n        StringUtils::Format(\"Length{}={}\\n\", i + 1, item->GetMusicInfoTag()->GetDuration() / 1000);\n  }\n\n  write += StringUtils::Format(\"NumberOfEntries={0}\\n\", m_vecItems.size());\n  write += StringUtils::Format(\"Version=2\\n\");\n  file.Write(write.c_str(), write.size());\n  file.Close();\n}\n\nbool CPlayListASX::LoadAsxIniInfo(std::istream &stream)\n{\n  CLog::Log(LOGINFO, \"Parsing INI style ASX\");\n\n  std::string name, value;\n\n  while( stream.good() )\n  {\n    // consume blank rows, and blanks\n    while((stream.peek() == '\\r' || stream.peek() == '\\n' || stream.peek() == ' ') && stream.good())\n      stream.get();\n\n    if(stream.peek() == '[')\n    {\n      // this is an [section] part, just ignore it\n      while(stream.good() && stream.peek() != '\\r' && stream.peek() != '\\n')\n        stream.get();\n      continue;\n    }\n    name = \"\";\n    value = \"\";\n    // consume name\n    while(stream.peek() != '\\r' && stream.peek() != '\\n' && stream.peek() != '=' && stream.good())\n      name += stream.get();\n\n    // consume =\n    if(stream.get() != '=')\n      continue;\n\n    // consume value\n    while(stream.peek() != '\\r' && stream.peek() != '\\n' && stream.good())\n      value += stream.get();\n\n    CLog::Log(LOGINFO, \"Adding element {}={}\", name, value);\n    CFileItemPtr newItem(new CFileItem(value));\n    newItem->SetPath(value);\n    if (newItem->IsVideo() && !newItem->HasVideoInfoTag()) // File is a video and needs a VideoInfoTag\n      newItem->GetVideoInfoTag()->Reset(); // Force VideoInfoTag creation\n    Add(newItem);\n  }\n\n  return true;\n}\n\nbool CPlayListASX::LoadData(std::istream& stream)\n{\n  CLog::Log(LOGINFO, \"Parsing ASX\");\n\n  if(stream.peek() == '[')\n  {\n    return LoadAsxIniInfo(stream);\n  }\n  else\n  {\n    CXBMCTinyXML xmlDoc;\n    stream >> xmlDoc;\n\n    if (xmlDoc.Error())\n    {\n      CLog::Log(LOGERROR, \"Unable to parse ASX info Error: {}\", xmlDoc.ErrorDesc());\n      return false;\n    }\n\n    TiXmlElement *pRootElement = xmlDoc.RootElement();\n\n    // lowercase every element\n    TiXmlNode *pNode = pRootElement;\n    TiXmlNode *pChild = NULL;\n    std::string value;\n    value = pNode->Value();\n    StringUtils::ToLower(value);\n    pNode->SetValue(value);\n    while(pNode)\n    {\n      pChild = pNode->IterateChildren(pChild);\n      if(pChild)\n      {\n        if (pChild->Type() == TiXmlNode::TINYXML_ELEMENT)\n        {\n          value = pChild->Value();\n          StringUtils::ToLower(value);\n          pChild->SetValue(value);\n\n          TiXmlAttribute* pAttr = pChild->ToElement()->FirstAttribute();\n          while(pAttr)\n          {\n            value = pAttr->Name();\n            StringUtils::ToLower(value);\n            pAttr->SetName(value);\n            pAttr = pAttr->Next();\n          }\n        }\n\n        pNode = pChild;\n        pChild = NULL;\n        continue;\n      }\n\n      pChild = pNode;\n      pNode = pNode->Parent();\n    }\n    std::string roottitle;\n    TiXmlElement *pElement = pRootElement->FirstChildElement();\n    while (pElement)\n    {\n      value = pElement->Value();\n      if (value == \"title\" && !pElement->NoChildren())\n      {\n        roottitle = pElement->FirstChild()->ValueStr();\n      }\n      else if (value == \"entry\")\n      {\n        std::string title(roottitle);\n\n        TiXmlElement *pRef = pElement->FirstChildElement(\"ref\");\n        TiXmlElement *pTitle = pElement->FirstChildElement(\"title\");\n\n        if(pTitle && !pTitle->NoChildren())\n          title = pTitle->FirstChild()->ValueStr();\n\n        while (pRef)\n        { // multiple references may appear for one entry\n          // duration may exist on this level too\n          value = XMLUtils::GetAttribute(pRef, \"href\");\n          if (!value.empty())\n          {\n            if(title.empty())\n              title = value;\n\n            CLog::Log(LOGINFO, \"Adding element {}, {}\", title, value);\n            CFileItemPtr newItem(new CFileItem(title));\n            newItem->SetPath(value);\n            Add(newItem);\n          }\n          pRef = pRef->NextSiblingElement(\"ref\");\n        }\n      }\n      else if (value == \"entryref\")\n      {\n        value = XMLUtils::GetAttribute(pElement, \"href\");\n        if (!value.empty())\n        { // found an entryref, let's try loading that url\n          std::unique_ptr<CPlayList> playlist(CPlayListFactory::Create(value));\n          if (nullptr != playlist)\n            if (playlist->Load(value))\n              Add(*playlist);\n        }\n      }\n      pElement = pElement->NextSiblingElement();\n    }\n  }\n\n  return true;\n}\n\n\nbool CPlayListRAM::LoadData(std::istream& stream)\n{\n  CLog::Log(LOGINFO, \"Parsing RAM\");\n\n  std::string strMMS;\n  while( stream.peek() != '\\n' && stream.peek() != '\\r' )\n    strMMS += stream.get();\n\n  CLog::Log(LOGINFO, \"Adding element {}\", strMMS);\n  CFileItemPtr newItem(new CFileItem(strMMS));\n  newItem->SetPath(strMMS);\n  Add(newItem);\n  return true;\n}\n\nbool CPlayListPLS::Resize(std::vector <int>::size_type newSize)\n{\n  if (newSize == 0)\n    return false;\n\n  while (m_vecItems.size() < newSize)\n  {\n    CFileItemPtr fileItem(new CFileItem());\n    m_vecItems.push_back(fileItem);\n  }\n  return true;\n}\n"], "fixing_code": ["/*\n *  Copyright (C) 2005-2018 Team Kodi\n *  This file is part of Kodi - https://kodi.tv\n *\n *  SPDX-License-Identifier: GPL-2.0-or-later\n *  See LICENSES/README.md for more information.\n */\n\n#include \"PlayListPLS.h\"\n\n#include \"PlayListFactory.h\"\n#include \"Util.h\"\n#include \"filesystem/File.h\"\n#include \"music/tags/MusicInfoTag.h\"\n#include \"utils/CharsetConverter.h\"\n#include \"utils/StringUtils.h\"\n#include \"utils/URIUtils.h\"\n#include \"utils/XBMCTinyXML.h\"\n#include \"utils/XMLUtils.h\"\n#include \"utils/log.h\"\n#include \"video/VideoInfoTag.h\"\n\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n\nusing namespace XFILE;\nusing namespace PLAYLIST;\n\n#define START_PLAYLIST_MARKER \"[playlist]\" // may be case-insensitive (equivalent to .ini file on win32)\n#define PLAYLIST_NAME     \"PlaylistName\"\n\n/*----------------------------------------------------------------------\n[playlist]\nPlaylistName=Playlist 001\nFile1=E:\\Program Files\\Winamp3\\demo.mp3\nTitle1=demo\nLength1=5\nFile2=E:\\Program Files\\Winamp3\\demo.mp3\nTitle2=demo\nLength2=5\nNumberOfEntries=2\nVersion=2\n----------------------------------------------------------------------*/\nCPlayListPLS::CPlayListPLS(void) = default;\n\nCPlayListPLS::~CPlayListPLS(void) = default;\n\nbool CPlayListPLS::Load(const std::string &strFile)\n{\n  //read it from the file\n  std::string strFileName(strFile);\n  m_strPlayListName = URIUtils::GetFileName(strFileName);\n\n  Clear();\n\n  bool bShoutCast = false;\n  if( StringUtils::StartsWithNoCase(strFileName, \"shout://\") )\n  {\n    strFileName.replace(0, 8, \"http://\");\n    m_strBasePath = \"\";\n    bShoutCast = true;\n  }\n  else\n    URIUtils::GetParentPath(strFileName, m_strBasePath);\n\n  CFile file;\n  if (!file.Open(strFileName) )\n  {\n    file.Close();\n    return false;\n  }\n\n  if (file.GetLength() > 1024*1024)\n  {\n    CLog::Log(LOGWARNING, \"{} - File is larger than 1 MB, most likely not a playlist\",\n              __FUNCTION__);\n    return false;\n  }\n\n  char szLine[4096];\n  std::string strLine;\n\n  // run through looking for the [playlist] marker.\n  // if we find another http stream, then load it.\n  while (true)\n  {\n    if ( !file.ReadString(szLine, sizeof(szLine) ) )\n    {\n      file.Close();\n      return size() > 0;\n    }\n    strLine = szLine;\n    StringUtils::Trim(strLine);\n    if(StringUtils::EqualsNoCase(strLine, START_PLAYLIST_MARKER))\n      break;\n\n    // if there is something else before playlist marker, this isn't a pls file\n    if(!strLine.empty())\n      return false;\n  }\n\n  bool bFailed = false;\n  while (file.ReadString(szLine, sizeof(szLine) ) )\n  {\n    strLine = szLine;\n    StringUtils::RemoveCRLF(strLine);\n    size_t iPosEqual = strLine.find('=');\n    if (iPosEqual != std::string::npos)\n    {\n      std::string strLeft = strLine.substr(0, iPosEqual);\n      iPosEqual++;\n      std::string strValue = strLine.substr(iPosEqual);\n      StringUtils::ToLower(strLeft);\n      StringUtils::TrimLeft(strLeft);\n\n      if (strLeft == \"numberofentries\")\n      {\n        m_vecItems.reserve(atoi(strValue.c_str()));\n      }\n      else if (StringUtils::StartsWith(strLeft, \"file\"))\n      {\n        std::vector <int>::size_type idx = atoi(strLeft.c_str() + 4);\n        if (!Resize(idx))\n        {\n          bFailed = true;\n          break;\n        }\n\n        // Skip self - do not load playlist recursively\n        if (StringUtils::EqualsNoCase(URIUtils::GetFileName(strValue),\n                                      URIUtils::GetFileName(strFileName)))\n          continue;\n\n        if (m_vecItems[idx - 1]->GetLabel().empty())\n          m_vecItems[idx - 1]->SetLabel(URIUtils::GetFileName(strValue));\n        CFileItem item(strValue, false);\n        if (bShoutCast && !item.IsAudio())\n          strValue.replace(0, 7, \"shout://\");\n\n        strValue = URIUtils::SubstitutePath(strValue);\n        CUtil::GetQualifiedFilename(m_strBasePath, strValue);\n        g_charsetConverter.unknownToUTF8(strValue);\n        m_vecItems[idx - 1]->SetPath(strValue);\n      }\n      else if (StringUtils::StartsWith(strLeft, \"title\"))\n      {\n        std::vector <int>::size_type idx = atoi(strLeft.c_str() + 5);\n        if (!Resize(idx))\n        {\n          bFailed = true;\n          break;\n        }\n        g_charsetConverter.unknownToUTF8(strValue);\n        m_vecItems[idx - 1]->SetLabel(strValue);\n      }\n      else if (StringUtils::StartsWith(strLeft, \"length\"))\n      {\n        std::vector <int>::size_type idx = atoi(strLeft.c_str() + 6);\n        if (!Resize(idx))\n        {\n          bFailed = true;\n          break;\n        }\n        m_vecItems[idx - 1]->GetMusicInfoTag()->SetDuration(atol(strValue.c_str()));\n      }\n      else if (strLeft == \"playlistname\")\n      {\n        m_strPlayListName = strValue;\n        g_charsetConverter.unknownToUTF8(m_strPlayListName);\n      }\n    }\n  }\n  file.Close();\n\n  if (bFailed)\n  {\n    CLog::Log(LOGERROR,\n              \"File {} is not a valid PLS playlist. Location of first file,title or length is not \"\n              \"permitted (eg. File0 should be File1)\",\n              URIUtils::GetFileName(strFileName));\n    return false;\n  }\n\n  // check for missing entries\n  ivecItems p = m_vecItems.begin();\n  while ( p != m_vecItems.end())\n  {\n    if ((*p)->GetPath().empty())\n    {\n      p = m_vecItems.erase(p);\n    }\n    else\n    {\n      ++p;\n    }\n  }\n\n  return true;\n}\n\nvoid CPlayListPLS::Save(const std::string& strFileName) const\n{\n  if (!m_vecItems.size()) return ;\n  std::string strPlaylist = CUtil::MakeLegalPath(strFileName);\n  CFile file;\n  if (!file.OpenForWrite(strPlaylist, true))\n  {\n    CLog::Log(LOGERROR, \"Could not save PLS playlist: [{}]\", strPlaylist);\n    return;\n  }\n  std::string write;\n  write += StringUtils::Format(\"{}\\n\", START_PLAYLIST_MARKER);\n  std::string strPlayListName=m_strPlayListName;\n  g_charsetConverter.utf8ToStringCharset(strPlayListName);\n  write += StringUtils::Format(\"PlaylistName={}\\n\", strPlayListName);\n\n  for (int i = 0; i < (int)m_vecItems.size(); ++i)\n  {\n    CFileItemPtr item = m_vecItems[i];\n    std::string strFileName=item->GetPath();\n    g_charsetConverter.utf8ToStringCharset(strFileName);\n    std::string strDescription=item->GetLabel();\n    g_charsetConverter.utf8ToStringCharset(strDescription);\n    write += StringUtils::Format(\"File{}={}\\n\", i + 1, strFileName);\n    write += StringUtils::Format(\"Title{}={}\\n\", i + 1, strDescription.c_str());\n    write +=\n        StringUtils::Format(\"Length{}={}\\n\", i + 1, item->GetMusicInfoTag()->GetDuration() / 1000);\n  }\n\n  write += StringUtils::Format(\"NumberOfEntries={0}\\n\", m_vecItems.size());\n  write += StringUtils::Format(\"Version=2\\n\");\n  file.Write(write.c_str(), write.size());\n  file.Close();\n}\n\nbool CPlayListASX::LoadAsxIniInfo(std::istream &stream)\n{\n  CLog::Log(LOGINFO, \"Parsing INI style ASX\");\n\n  std::string name, value;\n\n  while( stream.good() )\n  {\n    // consume blank rows, and blanks\n    while((stream.peek() == '\\r' || stream.peek() == '\\n' || stream.peek() == ' ') && stream.good())\n      stream.get();\n\n    if(stream.peek() == '[')\n    {\n      // this is an [section] part, just ignore it\n      while(stream.good() && stream.peek() != '\\r' && stream.peek() != '\\n')\n        stream.get();\n      continue;\n    }\n    name = \"\";\n    value = \"\";\n    // consume name\n    while(stream.peek() != '\\r' && stream.peek() != '\\n' && stream.peek() != '=' && stream.good())\n      name += stream.get();\n\n    // consume =\n    if(stream.get() != '=')\n      continue;\n\n    // consume value\n    while(stream.peek() != '\\r' && stream.peek() != '\\n' && stream.good())\n      value += stream.get();\n\n    CLog::Log(LOGINFO, \"Adding element {}={}\", name, value);\n    CFileItemPtr newItem(new CFileItem(value));\n    newItem->SetPath(value);\n    if (newItem->IsVideo() && !newItem->HasVideoInfoTag()) // File is a video and needs a VideoInfoTag\n      newItem->GetVideoInfoTag()->Reset(); // Force VideoInfoTag creation\n    Add(newItem);\n  }\n\n  return true;\n}\n\nbool CPlayListASX::LoadData(std::istream& stream)\n{\n  CLog::Log(LOGINFO, \"Parsing ASX\");\n\n  if(stream.peek() == '[')\n  {\n    return LoadAsxIniInfo(stream);\n  }\n  else\n  {\n    std::string asxstream(std::istreambuf_iterator<char>(stream), {});\n    CXBMCTinyXML xmlDoc;\n    xmlDoc.Parse(asxstream, TIXML_DEFAULT_ENCODING);\n\n    if (xmlDoc.Error())\n    {\n      CLog::Log(LOGERROR, \"Unable to parse ASX info Error: {}\", xmlDoc.ErrorDesc());\n      return false;\n    }\n\n    TiXmlElement *pRootElement = xmlDoc.RootElement();\n\n    if (!pRootElement)\n      return false;\n\n    // lowercase every element\n    TiXmlNode *pNode = pRootElement;\n    TiXmlNode *pChild = NULL;\n    std::string value;\n    value = pNode->Value();\n    StringUtils::ToLower(value);\n    pNode->SetValue(value);\n    while(pNode)\n    {\n      pChild = pNode->IterateChildren(pChild);\n      if(pChild)\n      {\n        if (pChild->Type() == TiXmlNode::TINYXML_ELEMENT)\n        {\n          value = pChild->Value();\n          StringUtils::ToLower(value);\n          pChild->SetValue(value);\n\n          TiXmlAttribute* pAttr = pChild->ToElement()->FirstAttribute();\n          while(pAttr)\n          {\n            value = pAttr->Name();\n            StringUtils::ToLower(value);\n            pAttr->SetName(value);\n            pAttr = pAttr->Next();\n          }\n        }\n\n        pNode = pChild;\n        pChild = NULL;\n        continue;\n      }\n\n      pChild = pNode;\n      pNode = pNode->Parent();\n    }\n    std::string roottitle;\n    TiXmlElement *pElement = pRootElement->FirstChildElement();\n    while (pElement)\n    {\n      value = pElement->Value();\n      if (value == \"title\" && !pElement->NoChildren())\n      {\n        roottitle = pElement->FirstChild()->ValueStr();\n      }\n      else if (value == \"entry\")\n      {\n        std::string title(roottitle);\n\n        TiXmlElement *pRef = pElement->FirstChildElement(\"ref\");\n        TiXmlElement *pTitle = pElement->FirstChildElement(\"title\");\n\n        if(pTitle && !pTitle->NoChildren())\n          title = pTitle->FirstChild()->ValueStr();\n\n        while (pRef)\n        { // multiple references may appear for one entry\n          // duration may exist on this level too\n          value = XMLUtils::GetAttribute(pRef, \"href\");\n          if (!value.empty())\n          {\n            if(title.empty())\n              title = value;\n\n            CLog::Log(LOGINFO, \"Adding element {}, {}\", title, value);\n            CFileItemPtr newItem(new CFileItem(title));\n            newItem->SetPath(value);\n            Add(newItem);\n          }\n          pRef = pRef->NextSiblingElement(\"ref\");\n        }\n      }\n      else if (value == \"entryref\")\n      {\n        value = XMLUtils::GetAttribute(pElement, \"href\");\n        if (!value.empty())\n        { // found an entryref, let's try loading that url\n          std::unique_ptr<CPlayList> playlist(CPlayListFactory::Create(value));\n          if (nullptr != playlist)\n            if (playlist->Load(value))\n              Add(*playlist);\n        }\n      }\n      pElement = pElement->NextSiblingElement();\n    }\n  }\n\n  return true;\n}\n\n\nbool CPlayListRAM::LoadData(std::istream& stream)\n{\n  CLog::Log(LOGINFO, \"Parsing RAM\");\n\n  std::string strMMS;\n  while( stream.peek() != '\\n' && stream.peek() != '\\r' )\n    strMMS += stream.get();\n\n  CLog::Log(LOGINFO, \"Adding element {}\", strMMS);\n  CFileItemPtr newItem(new CFileItem(strMMS));\n  newItem->SetPath(strMMS);\n  Add(newItem);\n  return true;\n}\n\nbool CPlayListPLS::Resize(std::vector <int>::size_type newSize)\n{\n  if (newSize == 0)\n    return false;\n\n  while (m_vecItems.size() < newSize)\n  {\n    CFileItemPtr fileItem(new CFileItem());\n    m_vecItems.push_back(fileItem);\n  }\n  return true;\n}\n"], "filenames": ["xbmc/playlists/PlayListPLS.cpp"], "buggy_code_start_loc": [291], "buggy_code_end_loc": [301], "fixing_code_start_loc": [292], "fixing_code_end_loc": [306], "type": "CWE-120", "message": "Buffer overflow vulnerability in Kodi xbmc up to 19.0, allows attackers to cause a denial of service due to improper length of values passed to istream.", "other": {"cve": {"id": "CVE-2021-42917", "sourceIdentifier": "cve@mitre.org", "published": "2021-11-01T19:15:07.910", "lastModified": "2021-11-02T19:46:07.617", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Buffer overflow vulnerability in Kodi xbmc up to 19.0, allows attackers to cause a denial of service due to improper length of values passed to istream."}, {"lang": "es", "value": "Una vulnerabilidad de desbordamiento de b\u00fafer en Kodi xbmc versiones hasta 19.0, permite a atacantes causar una denegaci\u00f3n de servicio debido a una longitud inapropiada de los valores pasados a istream"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:kodi:kodi:*:*:*:*:*:*:*:*", "versionEndExcluding": "19.0", "matchCriteriaId": "91304B46-2581-43C9-A78E-CB9666DF7F3D"}]}]}], "references": [{"url": "https://github.com/fuzzard/xbmc/commit/80c8138c09598e88b4ddb6dbb279fa193bbb3237", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/xbmc/xbmc/commit/48730b64494798705d46dfccc4029bd36d072df3", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/xbmc/xbmc/issues/20305", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/xbmc/xbmc/pull/20306", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/fuzzard/xbmc/commit/80c8138c09598e88b4ddb6dbb279fa193bbb3237"}}