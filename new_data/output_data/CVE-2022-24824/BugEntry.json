{"buggy_code": ["# frozen_string_literal: true\n\nrequire_dependency \"mobile_detection\"\nrequire_dependency \"crawler_detection\"\nrequire_dependency \"guardian\"\nrequire_dependency \"http_language_parser\"\n\nmodule Middleware\n  class AnonymousCache\n\n    def self.cache_key_segments\n      @@cache_key_segments ||= {\n        m: 'key_is_mobile?',\n        c: 'key_is_crawler?',\n        b: 'key_has_brotli?',\n        t: 'key_cache_theme_ids',\n        ca: 'key_compress_anon',\n        l: 'key_locale'\n      }\n    end\n\n    # Compile a string builder method that will be called to create\n    # an anonymous cache key\n    def self.compile_key_builder\n      method = +\"def self.__compiled_key_builder(h)\\n  \\\"\"\n      cache_key_segments.each do |k, v|\n        raise \"Invalid key name\" unless k =~ /^[a-z]+$/\n        raise \"Invalid method name\" unless v =~ /^key_[a-z_\\?]+$/\n        method << \"|#{k}=#\\{h.#{v}}\"\n      end\n      method << \"\\\"\\nend\"\n      eval(method) # rubocop:disable Security/Eval\n      @@compiled = true\n    end\n\n    def self.build_cache_key(helper)\n      compile_key_builder unless defined?(@@compiled)\n      __compiled_key_builder(helper)\n    end\n\n    def self.anon_cache(env, duration)\n      env[\"ANON_CACHE_DURATION\"] = duration\n    end\n\n    # This gives us an API to insert anonymous cache segments\n    class Helper\n      RACK_SESSION     = \"rack.session\"\n      USER_AGENT       = \"HTTP_USER_AGENT\"\n      ACCEPT_ENCODING  = \"HTTP_ACCEPT_ENCODING\"\n      DISCOURSE_RENDER = \"HTTP_DISCOURSE_RENDER\"\n\n      def initialize(env, request = nil)\n        @env = env\n        @request = request || Rack::Request.new(@env)\n      end\n\n      def blocked_crawler?\n        @request.get? &&\n        !@request.xhr? &&\n        !@request.path.ends_with?('robots.txt') &&\n        !@request.path.ends_with?('srv/status') &&\n        @request[Auth::DefaultCurrentUserProvider::API_KEY].nil? &&\n        @env[Auth::DefaultCurrentUserProvider::USER_API_KEY].nil? &&\n        CrawlerDetection.is_blocked_crawler?(@env[USER_AGENT])\n      end\n\n      def is_mobile=(val)\n        @is_mobile = val ? :true : :false\n      end\n\n      def is_mobile?\n        @is_mobile ||=\n          begin\n            session = @env[RACK_SESSION]\n            # don't initialize params until later\n            # otherwise you get a broken params on the request\n            params = {}\n\n            MobileDetection.resolve_mobile_view!(@env[USER_AGENT], params, session) ? :true : :false\n          end\n\n        @is_mobile == :true\n      end\n      alias_method :key_is_mobile?, :is_mobile?\n\n      def key_has_brotli?\n        @has_brotli ||=\n          begin\n            @env[ACCEPT_ENCODING].to_s =~ /br/ ? :true : :false\n          end\n        @has_brotli == :true\n      end\n\n      def key_locale\n        if SiteSetting.set_locale_from_accept_language_header\n          HttpLanguageParser.parse(@env[\"HTTP_ACCEPT_LANGUAGE\"])\n        else\n          \"\" # No need to key, it is the same for all anon users\n        end\n      end\n\n      def is_crawler?\n        @is_crawler ||=\n          begin\n            user_agent = @env[USER_AGENT]\n\n            if @env[DISCOURSE_RENDER] == \"crawler\" || CrawlerDetection.crawler?(user_agent, @env[\"HTTP_VIA\"])\n              :true\n            else\n              user_agent.downcase.include?(\"discourse\") && !user_agent.downcase.include?(\"mobile\") ? :true : :false\n            end\n          end\n        @is_crawler == :true\n      end\n      alias_method :key_is_crawler?, :is_crawler?\n\n      def cache_key\n        return @cache_key if defined?(@cache_key)\n\n        @cache_key = +\"ANON_CACHE_#{@env[\"HTTP_ACCEPT\"]}_#{@env[Rack::RACK_URL_SCHEME]}_#{@env[\"HTTP_HOST\"]}#{@env[\"REQUEST_URI\"]}\"\n        @cache_key << AnonymousCache.build_cache_key(self)\n        @cache_key\n      end\n\n      def key_cache_theme_ids\n        theme_ids.join(',')\n      end\n\n      def key_compress_anon\n        GlobalSetting.compress_anon_cache\n      end\n\n      def theme_ids\n        ids, _ = @request.cookies['theme_ids']&.split('|')\n        id = ids&.split(\",\")&.map(&:to_i)&.first\n        if id && Guardian.new.allow_themes?([id])\n          Theme.transform_ids(id)\n        else\n          []\n        end\n      end\n\n      def cache_key_count\n        @cache_key_count ||= \"#{cache_key}_count\"\n      end\n\n      def cache_key_body\n        @cache_key_body ||= \"#{cache_key}_body\"\n      end\n\n      def cache_key_other\n        @cache_key_other || \"#{cache_key}_other\"\n      end\n\n      def get?\n        @env[\"REQUEST_METHOD\"] == \"GET\"\n      end\n\n      def has_auth_cookie?\n        CurrentUser.has_auth_cookie?(@env)\n      end\n\n      def no_cache_bypass\n        request = Rack::Request.new(@env)\n        request.cookies['_bypass_cache'].nil? &&\n          (request.path != '/srv/status') &&\n          request[Auth::DefaultCurrentUserProvider::API_KEY].nil? &&\n          @env[Auth::DefaultCurrentUserProvider::USER_API_KEY].nil?\n      end\n\n      def force_anonymous!\n        @env[Auth::DefaultCurrentUserProvider::USER_API_KEY] = nil\n        @env['HTTP_COOKIE'] = nil\n        @env['HTTP_DISCOURSE_LOGGED_IN'] = nil\n        @env['rack.request.cookie.hash'] = {}\n        @env['rack.request.cookie.string'] = ''\n        @env['_bypass_cache'] = nil\n        request = Rack::Request.new(@env)\n        request.delete_param('api_username')\n        request.delete_param('api_key')\n      end\n\n      def logged_in_anon_limiter\n        @logged_in_anon_limiter ||= RateLimiter.new(\n          nil,\n          \"logged_in_anon_cache_#{@env[\"HTTP_HOST\"]}/#{@env[\"REQUEST_URI\"]}\",\n          GlobalSetting.force_anonymous_min_per_10_seconds,\n          10\n        )\n      end\n\n      def check_logged_in_rate_limit!\n        !logged_in_anon_limiter.performed!(raise_error: false)\n      end\n\n      MIN_TIME_TO_CHECK = 0.05\n      ADP = \"action_dispatch.request.parameters\"\n\n      def should_force_anonymous?\n        if (queue_time = @env['REQUEST_QUEUE_SECONDS']) && get?\n          if queue_time > GlobalSetting.force_anonymous_min_queue_seconds\n            return check_logged_in_rate_limit!\n          elsif queue_time >= MIN_TIME_TO_CHECK\n            if !logged_in_anon_limiter.can_perform?\n              return check_logged_in_rate_limit!\n            end\n          end\n        end\n\n        false\n      end\n\n      def cacheable?\n        !!(!has_auth_cookie? && get? && no_cache_bypass)\n      end\n\n      def compress(val)\n        if val && GlobalSetting.compress_anon_cache\n          require \"lz4-ruby\" if !defined?(LZ4)\n          LZ4::compress(val)\n        else\n          val\n        end\n      end\n\n      def decompress(val)\n        if val && GlobalSetting.compress_anon_cache\n          require \"lz4-ruby\" if !defined?(LZ4)\n          LZ4::uncompress(val)\n        else\n          val\n        end\n      end\n\n      def cached(env = {})\n        if body = decompress(Discourse.redis.get(cache_key_body))\n          if other = Discourse.redis.get(cache_key_other)\n            other = JSON.parse(other)\n            if req_params = other[1].delete(ADP)\n              env[ADP] = req_params\n            end\n            [other[0], other[1], [body]]\n          end\n        end\n      end\n\n      def cache_duration\n        @env[\"ANON_CACHE_DURATION\"]\n      end\n\n      # NOTE in an ideal world cache still serves out cached content except for one magic worker\n      #  that fills it up, this avoids a herd killing you, we can probably do this using a job or redis tricks\n      #  but coordinating this is tricky\n      def cache(result, env = {})\n        return result if GlobalSetting.anon_cache_store_threshold == 0\n\n        status, headers, response = result\n\n        if status == 200 && cache_duration\n\n          if GlobalSetting.anon_cache_store_threshold > 1\n            count = Discourse.redis.eval(<<~REDIS, [cache_key_count], [cache_duration])\n              local current = redis.call(\"incr\", KEYS[1])\n              redis.call(\"expire\",KEYS[1],ARGV[1])\n              return current\n            REDIS\n\n            # technically lua will cast for us, but might as well be\n            # prudent here, hence the to_i\n            if count.to_i < GlobalSetting.anon_cache_store_threshold\n              headers[\"X-Discourse-Cached\"] = \"skip\"\n              return [status, headers, response]\n            end\n          end\n\n          headers_stripped = headers.dup.delete_if { |k, _| [\"Set-Cookie\", \"X-MiniProfiler-Ids\"].include? k }\n          headers_stripped[\"X-Discourse-Cached\"] = \"true\"\n          parts = []\n          response.each do |part|\n            parts << part\n          end\n\n          if req_params = env[ADP]\n            headers_stripped[ADP] = {\n              \"action\" => req_params[\"action\"],\n              \"controller\" => req_params[\"controller\"]\n            }\n          end\n\n          Discourse.redis.setex(cache_key_body,  cache_duration, compress(parts.join))\n          Discourse.redis.setex(cache_key_other, cache_duration, [status, headers_stripped].to_json)\n\n          headers[\"X-Discourse-Cached\"] = \"store\"\n        else\n          parts = response\n        end\n\n        [status, headers, parts]\n      end\n\n      def clear_cache\n        Discourse.redis.del(cache_key_body)\n        Discourse.redis.del(cache_key_other)\n      end\n\n    end\n\n    def initialize(app, settings = {})\n      @app = app\n    end\n\n    PAYLOAD_INVALID_REQUEST_METHODS = [\"GET\", \"HEAD\"]\n\n    def call(env)\n      if PAYLOAD_INVALID_REQUEST_METHODS.include?(env[Rack::REQUEST_METHOD]) &&\n        env[Rack::RACK_INPUT].size > 0\n\n        return [413, { \"Cache-Control\" => \"private, max-age=0, must-revalidate\" }, []]\n      end\n\n      helper = Helper.new(env)\n      force_anon = false\n\n      if helper.blocked_crawler?\n        env[\"discourse.request_tracker.skip\"] = true\n        return [403, {}, [\"Crawler is not allowed!\"]]\n      end\n\n      if helper.should_force_anonymous?\n        force_anon = env[\"DISCOURSE_FORCE_ANON\"] = true\n        helper.force_anonymous!\n      end\n\n      if (env[\"HTTP_DISCOURSE_BACKGROUND\"] == \"true\") && (queue_time = env[\"REQUEST_QUEUE_SECONDS\"])\n        max_time = GlobalSetting.background_requests_max_queue_length.to_f\n        if max_time > 0 && queue_time.to_f > max_time\n          return [\n            429,\n            {\n              \"content-type\" => \"application/json; charset=utf-8\"\n            },\n            [{\n              errors: I18n.t(\"rate_limiter.slow_down\"),\n              extras: {\n                wait_seconds: 5 + (5 * rand).round(2)\n              }\n            }.to_json]\n          ]\n        end\n      end\n\n      result =\n        if helper.cacheable?\n          helper.cached(env) || helper.cache(@app.call(env), env)\n        else\n          @app.call(env)\n        end\n\n      if force_anon\n        result[1][\"Set-Cookie\"] = \"dosp=1; Path=/\"\n      end\n\n      result\n    end\n\n  end\n\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\ndescribe Middleware::AnonymousCache do\n  let(:middleware) { Middleware::AnonymousCache.new(lambda { |_| [200, {}, []] }) }\n\n  def env(opts = {})\n    create_request_env(path: \"http://test.com/path?bla=1\").merge(opts)\n  end\n\n  describe Middleware::AnonymousCache::Helper do\n    def new_helper(opts = {})\n      Middleware::AnonymousCache::Helper.new(env(opts))\n    end\n\n    context \"cacheable?\" do\n      it \"true by default\" do\n        expect(new_helper.cacheable?).to eq(true)\n      end\n\n      it \"is false for non GET\" do\n        expect(new_helper(\"ANON_CACHE_DURATION\" => 10, \"REQUEST_METHOD\" => \"POST\").cacheable?).to eq(false)\n      end\n\n      it \"is false if it has a valid auth cookie\" do\n        cookie = create_auth_cookie(token: SecureRandom.hex)\n        expect(new_helper(\"HTTP_COOKIE\" => \"jack=1; _t=#{cookie}; jill=2\").cacheable?).to eq(false)\n      end\n\n      it \"is true if it has an invalid auth cookie\" do\n        cookie = create_auth_cookie(token: SecureRandom.hex, issued_at: 5.minutes.ago)\n        cookie = swap_2_different_characters(cookie)\n        expect(new_helper(\"HTTP_COOKIE\" => \"jack=1; _t=#{cookie}; jill=2\").cacheable?).to eq(true)\n      end\n\n      it \"is false for srv/status routes\" do\n        expect(new_helper(\"PATH_INFO\" => \"/srv/status\").cacheable?).to eq(false)\n      end\n    end\n\n    context \"per theme cache\" do\n      it \"handles theme keys\" do\n        theme = Fabricate(:theme, user_selectable: true)\n\n        with_bad_theme_key = new_helper(\"HTTP_COOKIE\" => \"theme_ids=abc\").cache_key\n        with_no_theme_key = new_helper().cache_key\n\n        expect(with_bad_theme_key).to eq(with_no_theme_key)\n\n        with_good_theme_key = new_helper(\"HTTP_COOKIE\" => \"theme_ids=#{theme.id}\").cache_key\n\n        expect(with_good_theme_key).not_to eq(with_no_theme_key)\n      end\n    end\n\n    context \"with header-based locale locale\" do\n      it \"handles different languages\" do\n        # Normally does not check the language header\n        french1 = new_helper(\"HTTP_ACCEPT_LANGUAGE\" => \"fr\").cache_key\n        french2 = new_helper(\"HTTP_ACCEPT_LANGUAGE\" => \"FR\").cache_key\n        english = new_helper(\"HTTP_ACCEPT_LANGUAGE\" => SiteSetting.default_locale).cache_key\n        none = new_helper.cache_key\n\n        expect(none).to eq(french1)\n        expect(none).to eq(french2)\n        expect(none).to eq(english)\n\n        SiteSetting.allow_user_locale = true\n        SiteSetting.set_locale_from_accept_language_header = true\n\n        french1 = new_helper(\"HTTP_ACCEPT_LANGUAGE\" => \"fr\").cache_key\n        french2 = new_helper(\"HTTP_ACCEPT_LANGUAGE\" => \"FR\").cache_key\n        english = new_helper(\"HTTP_ACCEPT_LANGUAGE\" => SiteSetting.default_locale).cache_key\n        none = new_helper.cache_key\n\n        expect(none).to eq(english)\n        expect(french1).to eq(french2)\n        expect(french1).not_to eq(none)\n      end\n    end\n\n    context \"cached\" do\n      let!(:helper) do\n        new_helper(\"ANON_CACHE_DURATION\" => 10)\n      end\n\n      let!(:crawler) do\n        new_helper(\"ANON_CACHE_DURATION\" => 10, \"HTTP_USER_AGENT\" => \"AdsBot-Google (+http://www.google.com/adsbot.html)\")\n      end\n\n      after do\n        helper.clear_cache\n        crawler.clear_cache\n      end\n\n      before do\n        global_setting :anon_cache_store_threshold, 1\n      end\n\n      it \"compresses body on demand\" do\n        global_setting :compress_anon_cache, true\n\n        payload = \"x\" * 1000\n        helper.cache([200, { \"HELLO\" => \"WORLD\" }, [payload]])\n\n        helper = new_helper(\"ANON_CACHE_DURATION\" => 10)\n        expect(helper.cached).to eq([200, { \"X-Discourse-Cached\" => \"true\", \"HELLO\" => \"WORLD\" }, [payload]])\n\n        # depends on i7z implementation, but lets assume it is stable unless we discover\n        # otherwise\n        expect(Discourse.redis.get(helper.cache_key_body).length).to eq(16)\n      end\n\n      it \"handles brotli switching\" do\n        helper.cache([200, { \"HELLO\" => \"WORLD\" }, [\"hello \", \"my world\"]])\n\n        helper = new_helper(\"ANON_CACHE_DURATION\" => 10)\n        expect(helper.cached).to eq([200, { \"X-Discourse-Cached\" => \"true\", \"HELLO\" => \"WORLD\" }, [\"hello my world\"]])\n\n        helper = new_helper(\"ANON_CACHE_DURATION\" => 10, \"HTTP_ACCEPT_ENCODING\" => \"gz, br\")\n        expect(helper.cached).to eq(nil)\n      end\n\n      it \"returns cached data for cached requests\" do\n        helper.is_mobile = true\n        expect(helper.cached).to eq(nil)\n        helper.cache([200, { \"HELLO\" => \"WORLD\" }, [\"hello \", \"my world\"]])\n\n        helper = new_helper(\"ANON_CACHE_DURATION\" => 10)\n        helper.is_mobile = true\n        expect(helper.cached).to eq([200, { \"X-Discourse-Cached\" => \"true\", \"HELLO\" => \"WORLD\" }, [\"hello my world\"]])\n\n        expect(crawler.cached).to eq(nil)\n        crawler.cache([200, { \"HELLO\" => \"WORLD\" }, [\"hello \", \"world\"]])\n        expect(crawler.cached).to eq([200, { \"X-Discourse-Cached\" => \"true\", \"HELLO\" => \"WORLD\" }, [\"hello world\"]])\n      end\n    end\n  end\n\n  context 'background request rate limit' do\n    it 'will rate limit background requests' do\n\n      app = Middleware::AnonymousCache.new(\n        lambda do |env|\n          [200, {}, [\"ok\"]]\n        end\n      )\n\n      global_setting :background_requests_max_queue_length, \"0.5\"\n\n      cookie = create_auth_cookie(token: SecureRandom.hex)\n      env = create_request_env.merge(\n        \"HTTP_COOKIE\" => \"_t=#{cookie}\",\n        \"HOST\" => \"site.com\",\n        \"REQUEST_METHOD\" => \"GET\",\n        \"REQUEST_URI\" => \"/somewhere/rainbow\",\n        \"REQUEST_QUEUE_SECONDS\" => 2.1,\n        \"rack.input\" => StringIO.new\n      )\n\n      # non background ... long request\n      env[\"REQUEST_QUEUE_SECONDS\"] = 2\n\n      status, _ = app.call(env.dup)\n      expect(status).to eq(200)\n\n      env[\"HTTP_DISCOURSE_BACKGROUND\"] = \"true\"\n\n      status, headers, body = app.call(env.dup)\n      expect(status).to eq(429)\n      expect(headers[\"content-type\"]).to eq(\"application/json; charset=utf-8\")\n      json = JSON.parse(body.join)\n      expect(json[\"extras\"][\"wait_seconds\"]).to be > 4.9\n\n      env[\"REQUEST_QUEUE_SECONDS\"] = 0.4\n\n      status, _ = app.call(env.dup)\n      expect(status).to eq(200)\n\n    end\n  end\n\n  context 'force_anonymous!' do\n    before do\n      RateLimiter.enable\n    end\n\n    it 'will revert to anonymous once we reach the limit' do\n\n      RateLimiter.clear_all!\n\n      is_anon = false\n\n      app = Middleware::AnonymousCache.new(\n        lambda do |env|\n          is_anon = env[\"HTTP_COOKIE\"].nil? && env[\"HTTP_DISCOURSE_LOGGED_IN\"].nil?\n          [200, {}, [\"ok\"]]\n        end\n      )\n\n      global_setting :force_anonymous_min_per_10_seconds, 2\n      global_setting :force_anonymous_min_queue_seconds, 1\n\n      cookie = create_auth_cookie(token: SecureRandom.hex)\n      env = create_request_env.merge(\n        \"HTTP_COOKIE\" => \"_t=#{cookie}\",\n        \"HTTP_DISCOURSE_LOGGED_IN\" => \"true\",\n        \"HOST\" => \"site.com\",\n        \"REQUEST_METHOD\" => \"GET\",\n        \"REQUEST_URI\" => \"/somewhere/rainbow\",\n        \"REQUEST_QUEUE_SECONDS\" => 2.1,\n        \"rack.input\" => StringIO.new\n      )\n\n      is_anon = false\n      app.call(env.dup)\n      expect(is_anon).to eq(false)\n\n      is_anon = false\n      app.call(env.dup)\n      expect(is_anon).to eq(false)\n\n      is_anon = false\n      app.call(env.dup)\n      expect(is_anon).to eq(true)\n\n      is_anon = false\n      _status, headers, _body = app.call(env.dup)\n      expect(is_anon).to eq(true)\n      expect(headers['Set-Cookie']).to eq('dosp=1; Path=/')\n\n      # tricky change, a 50ms delay still will trigger protection\n      # once it is tripped\n\n      env[\"REQUEST_QUEUE_SECONDS\"] = 0.05\n      is_anon = false\n\n      app.call(env.dup)\n      expect(is_anon).to eq(true)\n\n      is_anon = false\n      env[\"REQUEST_QUEUE_SECONDS\"] = 0.01\n\n      app.call(env.dup)\n      expect(is_anon).to eq(false)\n    end\n  end\n\n  context 'invalid request payload' do\n    it 'returns 413 for GET request with payload' do\n      status, headers, _ = middleware.call(env.tap do |environment|\n        environment[Rack::RACK_INPUT].write(\"test\")\n      end)\n\n      expect(status).to eq(413)\n      expect(headers[\"Cache-Control\"]).to eq(\"private, max-age=0, must-revalidate\")\n    end\n  end\n\n  context \"crawler blocking\" do\n    let :non_crawler do\n      {\n        \"HTTP_USER_AGENT\" =>\n        \"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36\"\n      }\n    end\n\n    def get(path, options)\n      @env = env({\n        \"REQUEST_URI\" => path,\n        \"PATH_INFO\" => path,\n        \"REQUEST_PATH\" => path\n      }.merge(options[:headers]))\n      @status, @response_header, @response = middleware.call(@env)\n    end\n\n    it \"applies allowed_crawler_user_agents correctly\" do\n      SiteSetting.allowed_crawler_user_agents = 'Googlebot'\n\n      get '/', headers: {\n        'HTTP_USER_AGENT' => 'Googlebot/2.1 (+http://www.google.com/bot.html)'\n      }\n\n      expect(@status).to eq(200)\n\n      get '/', headers: {\n        'HTTP_USER_AGENT' => 'Anotherbot/2.1 (+http://www.notgoogle.com/bot.html)'\n      }\n\n      expect(@status).to eq(403)\n      expect(@response).to be_an(Array)\n\n      get '/', headers: non_crawler\n      expect(@status).to eq(200)\n    end\n\n    it \"doesn't block api requests\" do\n      SiteSetting.allowed_crawler_user_agents = 'Googlebot'\n      api_key = Fabricate(:api_key)\n\n      get \"/latest?api_key=#{api_key.key}&api_username=system\", headers: {\n        \"QUERY_STRING\" => \"api_key=#{api_key.key}&api_username=system\"\n      }\n      expect(@status).to eq(200)\n    end\n\n    it \"applies blocked_crawler_user_agents correctly\" do\n      SiteSetting.blocked_crawler_user_agents = 'Googlebot'\n\n      get '/', headers: non_crawler\n      expect(@status).to eq(200)\n\n      get '/', headers: {\n        'HTTP_USER_AGENT' => 'Googlebot/2.1 (+http://www.google.com/bot.html)'\n      }\n\n      expect(@status).to eq(403)\n\n      get '/', headers: {\n        'HTTP_USER_AGENT' => 'Twitterbot/2.1 (+http://www.notgoogle.com/bot.html)'\n      }\n\n      expect(@status).to eq(200)\n    end\n\n    it \"should never block robots.txt\" do\n      SiteSetting.blocked_crawler_user_agents = 'Googlebot'\n\n      get '/robots.txt', headers: {\n        'HTTP_USER_AGENT' => 'Googlebot/2.1 (+http://www.google.com/bot.html)'\n      }\n\n      expect(@status).to eq(200)\n    end\n\n    it \"should never block srv/status\" do\n      SiteSetting.blocked_crawler_user_agents = 'Googlebot'\n\n      get '/srv/status', headers: {\n        'HTTP_USER_AGENT' => 'Googlebot/2.1 (+http://www.google.com/bot.html)'\n      }\n\n      expect(@status).to eq(200)\n    end\n\n    it \"blocked crawlers shouldn't log page views\" do\n      SiteSetting.blocked_crawler_user_agents = 'Googlebot'\n\n      get '/', headers: {\n        'HTTP_USER_AGENT' => 'Googlebot/2.1 (+http://www.google.com/bot.html)'\n      }\n\n      expect(@env[\"discourse.request_tracker.skip\"]).to eq(true)\n    end\n\n    it \"blocks json requests\" do\n      SiteSetting.blocked_crawler_user_agents = 'Googlebot'\n\n      get '/srv/status.json', headers: {\n        'HTTP_USER_AGENT' => 'Googlebot/2.1 (+http://www.google.com/bot.html)'\n      }\n\n      expect(@status).to eq(403)\n    end\n  end\n\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nrequire_dependency \"mobile_detection\"\nrequire_dependency \"crawler_detection\"\nrequire_dependency \"guardian\"\nrequire_dependency \"http_language_parser\"\n\nmodule Middleware\n  class AnonymousCache\n\n    def self.cache_key_segments\n      @@cache_key_segments ||= {\n        m: 'key_is_mobile?',\n        c: 'key_is_crawler?',\n        o: 'key_is_old_browser?',\n        b: 'key_has_brotli?',\n        t: 'key_cache_theme_ids',\n        ca: 'key_compress_anon',\n        l: 'key_locale'\n      }\n    end\n\n    # Compile a string builder method that will be called to create\n    # an anonymous cache key\n    def self.compile_key_builder\n      method = +\"def self.__compiled_key_builder(h)\\n  \\\"\"\n      cache_key_segments.each do |k, v|\n        raise \"Invalid key name\" unless k =~ /^[a-z]+$/\n        raise \"Invalid method name\" unless v =~ /^key_[a-z_\\?]+$/\n        method << \"|#{k}=#\\{h.#{v}}\"\n      end\n      method << \"\\\"\\nend\"\n      eval(method) # rubocop:disable Security/Eval\n      @@compiled = true\n    end\n\n    def self.build_cache_key(helper)\n      compile_key_builder unless defined?(@@compiled)\n      __compiled_key_builder(helper)\n    end\n\n    def self.anon_cache(env, duration)\n      env[\"ANON_CACHE_DURATION\"] = duration\n    end\n\n    # This gives us an API to insert anonymous cache segments\n    class Helper\n      RACK_SESSION     = \"rack.session\"\n      USER_AGENT       = \"HTTP_USER_AGENT\"\n      ACCEPT_ENCODING  = \"HTTP_ACCEPT_ENCODING\"\n      DISCOURSE_RENDER = \"HTTP_DISCOURSE_RENDER\"\n\n      def initialize(env, request = nil)\n        @env = env\n        @request = request || Rack::Request.new(@env)\n      end\n\n      def blocked_crawler?\n        @request.get? &&\n        !@request.xhr? &&\n        !@request.path.ends_with?('robots.txt') &&\n        !@request.path.ends_with?('srv/status') &&\n        @request[Auth::DefaultCurrentUserProvider::API_KEY].nil? &&\n        @env[Auth::DefaultCurrentUserProvider::USER_API_KEY].nil? &&\n        CrawlerDetection.is_blocked_crawler?(@env[USER_AGENT])\n      end\n\n      def is_mobile=(val)\n        @is_mobile = val ? :true : :false\n      end\n\n      def is_mobile?\n        @is_mobile ||=\n          begin\n            session = @env[RACK_SESSION]\n            # don't initialize params until later\n            # otherwise you get a broken params on the request\n            params = {}\n\n            MobileDetection.resolve_mobile_view!(@env[USER_AGENT], params, session) ? :true : :false\n          end\n\n        @is_mobile == :true\n      end\n      alias_method :key_is_mobile?, :is_mobile?\n\n      def key_has_brotli?\n        @has_brotli ||=\n          begin\n            @env[ACCEPT_ENCODING].to_s =~ /br/ ? :true : :false\n          end\n        @has_brotli == :true\n      end\n\n      def key_locale\n        if SiteSetting.set_locale_from_accept_language_header\n          HttpLanguageParser.parse(@env[\"HTTP_ACCEPT_LANGUAGE\"])\n        else\n          \"\" # No need to key, it is the same for all anon users\n        end\n      end\n\n      def is_crawler?\n        @is_crawler ||=\n          begin\n            user_agent = @env[USER_AGENT]\n\n            if @env[DISCOURSE_RENDER] == \"crawler\" || CrawlerDetection.crawler?(user_agent, @env[\"HTTP_VIA\"])\n              :true\n            else\n              user_agent.downcase.include?(\"discourse\") && !user_agent.downcase.include?(\"mobile\") ? :true : :false\n            end\n          end\n        @is_crawler == :true\n      end\n      alias_method :key_is_crawler?, :is_crawler?\n\n      def key_is_old_browser?\n        CrawlerDetection.show_browser_update?(@env[USER_AGENT]) if @env[USER_AGENT]\n      end\n\n      def cache_key\n        return @cache_key if defined?(@cache_key)\n\n        @cache_key = +\"ANON_CACHE_#{@env[\"HTTP_ACCEPT\"]}_#{@env[Rack::RACK_URL_SCHEME]}_#{@env[\"HTTP_HOST\"]}#{@env[\"REQUEST_URI\"]}\"\n        @cache_key << AnonymousCache.build_cache_key(self)\n        @cache_key\n      end\n\n      def key_cache_theme_ids\n        theme_ids.join(',')\n      end\n\n      def key_compress_anon\n        GlobalSetting.compress_anon_cache\n      end\n\n      def theme_ids\n        ids, _ = @request.cookies['theme_ids']&.split('|')\n        id = ids&.split(\",\")&.map(&:to_i)&.first\n        if id && Guardian.new.allow_themes?([id])\n          Theme.transform_ids(id)\n        else\n          []\n        end\n      end\n\n      def cache_key_count\n        @cache_key_count ||= \"#{cache_key}_count\"\n      end\n\n      def cache_key_body\n        @cache_key_body ||= \"#{cache_key}_body\"\n      end\n\n      def cache_key_other\n        @cache_key_other || \"#{cache_key}_other\"\n      end\n\n      def get?\n        @env[\"REQUEST_METHOD\"] == \"GET\"\n      end\n\n      def has_auth_cookie?\n        CurrentUser.has_auth_cookie?(@env)\n      end\n\n      def no_cache_bypass\n        request = Rack::Request.new(@env)\n        request.cookies['_bypass_cache'].nil? &&\n          (request.path != '/srv/status') &&\n          request[Auth::DefaultCurrentUserProvider::API_KEY].nil? &&\n          @env[Auth::DefaultCurrentUserProvider::USER_API_KEY].nil?\n      end\n\n      def force_anonymous!\n        @env[Auth::DefaultCurrentUserProvider::USER_API_KEY] = nil\n        @env['HTTP_COOKIE'] = nil\n        @env['HTTP_DISCOURSE_LOGGED_IN'] = nil\n        @env['rack.request.cookie.hash'] = {}\n        @env['rack.request.cookie.string'] = ''\n        @env['_bypass_cache'] = nil\n        request = Rack::Request.new(@env)\n        request.delete_param('api_username')\n        request.delete_param('api_key')\n      end\n\n      def logged_in_anon_limiter\n        @logged_in_anon_limiter ||= RateLimiter.new(\n          nil,\n          \"logged_in_anon_cache_#{@env[\"HTTP_HOST\"]}/#{@env[\"REQUEST_URI\"]}\",\n          GlobalSetting.force_anonymous_min_per_10_seconds,\n          10\n        )\n      end\n\n      def check_logged_in_rate_limit!\n        !logged_in_anon_limiter.performed!(raise_error: false)\n      end\n\n      MIN_TIME_TO_CHECK = 0.05\n      ADP = \"action_dispatch.request.parameters\"\n\n      def should_force_anonymous?\n        if (queue_time = @env['REQUEST_QUEUE_SECONDS']) && get?\n          if queue_time > GlobalSetting.force_anonymous_min_queue_seconds\n            return check_logged_in_rate_limit!\n          elsif queue_time >= MIN_TIME_TO_CHECK\n            if !logged_in_anon_limiter.can_perform?\n              return check_logged_in_rate_limit!\n            end\n          end\n        end\n\n        false\n      end\n\n      def cacheable?\n        !!(!has_auth_cookie? && get? && no_cache_bypass)\n      end\n\n      def compress(val)\n        if val && GlobalSetting.compress_anon_cache\n          require \"lz4-ruby\" if !defined?(LZ4)\n          LZ4::compress(val)\n        else\n          val\n        end\n      end\n\n      def decompress(val)\n        if val && GlobalSetting.compress_anon_cache\n          require \"lz4-ruby\" if !defined?(LZ4)\n          LZ4::uncompress(val)\n        else\n          val\n        end\n      end\n\n      def cached(env = {})\n        if body = decompress(Discourse.redis.get(cache_key_body))\n          if other = Discourse.redis.get(cache_key_other)\n            other = JSON.parse(other)\n            if req_params = other[1].delete(ADP)\n              env[ADP] = req_params\n            end\n            [other[0], other[1], [body]]\n          end\n        end\n      end\n\n      def cache_duration\n        @env[\"ANON_CACHE_DURATION\"]\n      end\n\n      # NOTE in an ideal world cache still serves out cached content except for one magic worker\n      #  that fills it up, this avoids a herd killing you, we can probably do this using a job or redis tricks\n      #  but coordinating this is tricky\n      def cache(result, env = {})\n        return result if GlobalSetting.anon_cache_store_threshold == 0\n\n        status, headers, response = result\n\n        if status == 200 && cache_duration\n\n          if GlobalSetting.anon_cache_store_threshold > 1\n            count = Discourse.redis.eval(<<~REDIS, [cache_key_count], [cache_duration])\n              local current = redis.call(\"incr\", KEYS[1])\n              redis.call(\"expire\",KEYS[1],ARGV[1])\n              return current\n            REDIS\n\n            # technically lua will cast for us, but might as well be\n            # prudent here, hence the to_i\n            if count.to_i < GlobalSetting.anon_cache_store_threshold\n              headers[\"X-Discourse-Cached\"] = \"skip\"\n              return [status, headers, response]\n            end\n          end\n\n          headers_stripped = headers.dup.delete_if { |k, _| [\"Set-Cookie\", \"X-MiniProfiler-Ids\"].include? k }\n          headers_stripped[\"X-Discourse-Cached\"] = \"true\"\n          parts = []\n          response.each do |part|\n            parts << part\n          end\n\n          if req_params = env[ADP]\n            headers_stripped[ADP] = {\n              \"action\" => req_params[\"action\"],\n              \"controller\" => req_params[\"controller\"]\n            }\n          end\n\n          Discourse.redis.setex(cache_key_body,  cache_duration, compress(parts.join))\n          Discourse.redis.setex(cache_key_other, cache_duration, [status, headers_stripped].to_json)\n\n          headers[\"X-Discourse-Cached\"] = \"store\"\n        else\n          parts = response\n        end\n\n        [status, headers, parts]\n      end\n\n      def clear_cache\n        Discourse.redis.del(cache_key_body)\n        Discourse.redis.del(cache_key_other)\n      end\n\n    end\n\n    def initialize(app, settings = {})\n      @app = app\n    end\n\n    PAYLOAD_INVALID_REQUEST_METHODS = [\"GET\", \"HEAD\"]\n\n    def call(env)\n      if PAYLOAD_INVALID_REQUEST_METHODS.include?(env[Rack::REQUEST_METHOD]) &&\n        env[Rack::RACK_INPUT].size > 0\n\n        return [413, { \"Cache-Control\" => \"private, max-age=0, must-revalidate\" }, []]\n      end\n\n      helper = Helper.new(env)\n      force_anon = false\n\n      if helper.blocked_crawler?\n        env[\"discourse.request_tracker.skip\"] = true\n        return [403, {}, [\"Crawler is not allowed!\"]]\n      end\n\n      if helper.should_force_anonymous?\n        force_anon = env[\"DISCOURSE_FORCE_ANON\"] = true\n        helper.force_anonymous!\n      end\n\n      if (env[\"HTTP_DISCOURSE_BACKGROUND\"] == \"true\") && (queue_time = env[\"REQUEST_QUEUE_SECONDS\"])\n        max_time = GlobalSetting.background_requests_max_queue_length.to_f\n        if max_time > 0 && queue_time.to_f > max_time\n          return [\n            429,\n            {\n              \"content-type\" => \"application/json; charset=utf-8\"\n            },\n            [{\n              errors: I18n.t(\"rate_limiter.slow_down\"),\n              extras: {\n                wait_seconds: 5 + (5 * rand).round(2)\n              }\n            }.to_json]\n          ]\n        end\n      end\n\n      result =\n        if helper.cacheable?\n          helper.cached(env) || helper.cache(@app.call(env), env)\n        else\n          @app.call(env)\n        end\n\n      if force_anon\n        result[1][\"Set-Cookie\"] = \"dosp=1; Path=/\"\n      end\n\n      result\n    end\n\n  end\n\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\ndescribe Middleware::AnonymousCache do\n  let(:middleware) { Middleware::AnonymousCache.new(lambda { |_| [200, {}, []] }) }\n\n  def env(opts = {})\n    create_request_env(path: \"http://test.com/path?bla=1\").merge(opts)\n  end\n\n  describe Middleware::AnonymousCache::Helper do\n    def new_helper(opts = {})\n      Middleware::AnonymousCache::Helper.new(env(opts))\n    end\n\n    context \"cacheable?\" do\n      it \"true by default\" do\n        expect(new_helper.cacheable?).to eq(true)\n      end\n\n      it \"is false for non GET\" do\n        expect(new_helper(\"ANON_CACHE_DURATION\" => 10, \"REQUEST_METHOD\" => \"POST\").cacheable?).to eq(false)\n      end\n\n      it \"is false if it has a valid auth cookie\" do\n        cookie = create_auth_cookie(token: SecureRandom.hex)\n        expect(new_helper(\"HTTP_COOKIE\" => \"jack=1; _t=#{cookie}; jill=2\").cacheable?).to eq(false)\n      end\n\n      it \"is true if it has an invalid auth cookie\" do\n        cookie = create_auth_cookie(token: SecureRandom.hex, issued_at: 5.minutes.ago)\n        cookie = swap_2_different_characters(cookie)\n        expect(new_helper(\"HTTP_COOKIE\" => \"jack=1; _t=#{cookie}; jill=2\").cacheable?).to eq(true)\n      end\n\n      it \"is false for srv/status routes\" do\n        expect(new_helper(\"PATH_INFO\" => \"/srv/status\").cacheable?).to eq(false)\n      end\n    end\n\n    context \"per theme cache\" do\n      it \"handles theme keys\" do\n        theme = Fabricate(:theme, user_selectable: true)\n\n        with_bad_theme_key = new_helper(\"HTTP_COOKIE\" => \"theme_ids=abc\").cache_key\n        with_no_theme_key = new_helper().cache_key\n\n        expect(with_bad_theme_key).to eq(with_no_theme_key)\n\n        with_good_theme_key = new_helper(\"HTTP_COOKIE\" => \"theme_ids=#{theme.id}\").cache_key\n\n        expect(with_good_theme_key).not_to eq(with_no_theme_key)\n      end\n    end\n\n    context \"with header-based locale locale\" do\n      it \"handles different languages\" do\n        # Normally does not check the language header\n        french1 = new_helper(\"HTTP_ACCEPT_LANGUAGE\" => \"fr\").cache_key\n        french2 = new_helper(\"HTTP_ACCEPT_LANGUAGE\" => \"FR\").cache_key\n        english = new_helper(\"HTTP_ACCEPT_LANGUAGE\" => SiteSetting.default_locale).cache_key\n        none = new_helper.cache_key\n\n        expect(none).to eq(french1)\n        expect(none).to eq(french2)\n        expect(none).to eq(english)\n\n        SiteSetting.allow_user_locale = true\n        SiteSetting.set_locale_from_accept_language_header = true\n\n        french1 = new_helper(\"HTTP_ACCEPT_LANGUAGE\" => \"fr\").cache_key\n        french2 = new_helper(\"HTTP_ACCEPT_LANGUAGE\" => \"FR\").cache_key\n        english = new_helper(\"HTTP_ACCEPT_LANGUAGE\" => SiteSetting.default_locale).cache_key\n        none = new_helper.cache_key\n\n        expect(none).to eq(english)\n        expect(french1).to eq(french2)\n        expect(french1).not_to eq(none)\n      end\n    end\n\n    it \"handles old browsers\" do\n      SiteSetting.browser_update_user_agents = \"my_old_browser\"\n\n      key1 = new_helper(\"HTTP_USER_AGENT\" => \"my_old_browser\").cache_key\n      key2 = new_helper(\"HTTP_USER_AGENT\" => \"my_new_browser\").cache_key\n      expect(key1).not_to eq(key2)\n    end\n\n    context \"cached\" do\n      let!(:helper) do\n        new_helper(\"ANON_CACHE_DURATION\" => 10)\n      end\n\n      let!(:crawler) do\n        new_helper(\"ANON_CACHE_DURATION\" => 10, \"HTTP_USER_AGENT\" => \"AdsBot-Google (+http://www.google.com/adsbot.html)\")\n      end\n\n      after do\n        helper.clear_cache\n        crawler.clear_cache\n      end\n\n      before do\n        global_setting :anon_cache_store_threshold, 1\n      end\n\n      it \"compresses body on demand\" do\n        global_setting :compress_anon_cache, true\n\n        payload = \"x\" * 1000\n        helper.cache([200, { \"HELLO\" => \"WORLD\" }, [payload]])\n\n        helper = new_helper(\"ANON_CACHE_DURATION\" => 10)\n        expect(helper.cached).to eq([200, { \"X-Discourse-Cached\" => \"true\", \"HELLO\" => \"WORLD\" }, [payload]])\n\n        # depends on i7z implementation, but lets assume it is stable unless we discover\n        # otherwise\n        expect(Discourse.redis.get(helper.cache_key_body).length).to eq(16)\n      end\n\n      it \"handles brotli switching\" do\n        helper.cache([200, { \"HELLO\" => \"WORLD\" }, [\"hello \", \"my world\"]])\n\n        helper = new_helper(\"ANON_CACHE_DURATION\" => 10)\n        expect(helper.cached).to eq([200, { \"X-Discourse-Cached\" => \"true\", \"HELLO\" => \"WORLD\" }, [\"hello my world\"]])\n\n        helper = new_helper(\"ANON_CACHE_DURATION\" => 10, \"HTTP_ACCEPT_ENCODING\" => \"gz, br\")\n        expect(helper.cached).to eq(nil)\n      end\n\n      it \"returns cached data for cached requests\" do\n        helper.is_mobile = true\n        expect(helper.cached).to eq(nil)\n        helper.cache([200, { \"HELLO\" => \"WORLD\" }, [\"hello \", \"my world\"]])\n\n        helper = new_helper(\"ANON_CACHE_DURATION\" => 10)\n        helper.is_mobile = true\n        expect(helper.cached).to eq([200, { \"X-Discourse-Cached\" => \"true\", \"HELLO\" => \"WORLD\" }, [\"hello my world\"]])\n\n        expect(crawler.cached).to eq(nil)\n        crawler.cache([200, { \"HELLO\" => \"WORLD\" }, [\"hello \", \"world\"]])\n        expect(crawler.cached).to eq([200, { \"X-Discourse-Cached\" => \"true\", \"HELLO\" => \"WORLD\" }, [\"hello world\"]])\n      end\n    end\n  end\n\n  context 'background request rate limit' do\n    it 'will rate limit background requests' do\n\n      app = Middleware::AnonymousCache.new(\n        lambda do |env|\n          [200, {}, [\"ok\"]]\n        end\n      )\n\n      global_setting :background_requests_max_queue_length, \"0.5\"\n\n      cookie = create_auth_cookie(token: SecureRandom.hex)\n      env = create_request_env.merge(\n        \"HTTP_COOKIE\" => \"_t=#{cookie}\",\n        \"HOST\" => \"site.com\",\n        \"REQUEST_METHOD\" => \"GET\",\n        \"REQUEST_URI\" => \"/somewhere/rainbow\",\n        \"REQUEST_QUEUE_SECONDS\" => 2.1,\n        \"rack.input\" => StringIO.new\n      )\n\n      # non background ... long request\n      env[\"REQUEST_QUEUE_SECONDS\"] = 2\n\n      status, _ = app.call(env.dup)\n      expect(status).to eq(200)\n\n      env[\"HTTP_DISCOURSE_BACKGROUND\"] = \"true\"\n\n      status, headers, body = app.call(env.dup)\n      expect(status).to eq(429)\n      expect(headers[\"content-type\"]).to eq(\"application/json; charset=utf-8\")\n      json = JSON.parse(body.join)\n      expect(json[\"extras\"][\"wait_seconds\"]).to be > 4.9\n\n      env[\"REQUEST_QUEUE_SECONDS\"] = 0.4\n\n      status, _ = app.call(env.dup)\n      expect(status).to eq(200)\n\n    end\n  end\n\n  context 'force_anonymous!' do\n    before do\n      RateLimiter.enable\n    end\n\n    it 'will revert to anonymous once we reach the limit' do\n\n      RateLimiter.clear_all!\n\n      is_anon = false\n\n      app = Middleware::AnonymousCache.new(\n        lambda do |env|\n          is_anon = env[\"HTTP_COOKIE\"].nil? && env[\"HTTP_DISCOURSE_LOGGED_IN\"].nil?\n          [200, {}, [\"ok\"]]\n        end\n      )\n\n      global_setting :force_anonymous_min_per_10_seconds, 2\n      global_setting :force_anonymous_min_queue_seconds, 1\n\n      cookie = create_auth_cookie(token: SecureRandom.hex)\n      env = create_request_env.merge(\n        \"HTTP_COOKIE\" => \"_t=#{cookie}\",\n        \"HTTP_DISCOURSE_LOGGED_IN\" => \"true\",\n        \"HOST\" => \"site.com\",\n        \"REQUEST_METHOD\" => \"GET\",\n        \"REQUEST_URI\" => \"/somewhere/rainbow\",\n        \"REQUEST_QUEUE_SECONDS\" => 2.1,\n        \"rack.input\" => StringIO.new\n      )\n\n      is_anon = false\n      app.call(env.dup)\n      expect(is_anon).to eq(false)\n\n      is_anon = false\n      app.call(env.dup)\n      expect(is_anon).to eq(false)\n\n      is_anon = false\n      app.call(env.dup)\n      expect(is_anon).to eq(true)\n\n      is_anon = false\n      _status, headers, _body = app.call(env.dup)\n      expect(is_anon).to eq(true)\n      expect(headers['Set-Cookie']).to eq('dosp=1; Path=/')\n\n      # tricky change, a 50ms delay still will trigger protection\n      # once it is tripped\n\n      env[\"REQUEST_QUEUE_SECONDS\"] = 0.05\n      is_anon = false\n\n      app.call(env.dup)\n      expect(is_anon).to eq(true)\n\n      is_anon = false\n      env[\"REQUEST_QUEUE_SECONDS\"] = 0.01\n\n      app.call(env.dup)\n      expect(is_anon).to eq(false)\n    end\n  end\n\n  context 'invalid request payload' do\n    it 'returns 413 for GET request with payload' do\n      status, headers, _ = middleware.call(env.tap do |environment|\n        environment[Rack::RACK_INPUT].write(\"test\")\n      end)\n\n      expect(status).to eq(413)\n      expect(headers[\"Cache-Control\"]).to eq(\"private, max-age=0, must-revalidate\")\n    end\n  end\n\n  context \"crawler blocking\" do\n    let :non_crawler do\n      {\n        \"HTTP_USER_AGENT\" =>\n        \"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36\"\n      }\n    end\n\n    def get(path, options)\n      @env = env({\n        \"REQUEST_URI\" => path,\n        \"PATH_INFO\" => path,\n        \"REQUEST_PATH\" => path\n      }.merge(options[:headers]))\n      @status, @response_header, @response = middleware.call(@env)\n    end\n\n    it \"applies allowed_crawler_user_agents correctly\" do\n      SiteSetting.allowed_crawler_user_agents = 'Googlebot'\n\n      get '/', headers: {\n        'HTTP_USER_AGENT' => 'Googlebot/2.1 (+http://www.google.com/bot.html)'\n      }\n\n      expect(@status).to eq(200)\n\n      get '/', headers: {\n        'HTTP_USER_AGENT' => 'Anotherbot/2.1 (+http://www.notgoogle.com/bot.html)'\n      }\n\n      expect(@status).to eq(403)\n      expect(@response).to be_an(Array)\n\n      get '/', headers: non_crawler\n      expect(@status).to eq(200)\n    end\n\n    it \"doesn't block api requests\" do\n      SiteSetting.allowed_crawler_user_agents = 'Googlebot'\n      api_key = Fabricate(:api_key)\n\n      get \"/latest?api_key=#{api_key.key}&api_username=system\", headers: {\n        \"QUERY_STRING\" => \"api_key=#{api_key.key}&api_username=system\"\n      }\n      expect(@status).to eq(200)\n    end\n\n    it \"applies blocked_crawler_user_agents correctly\" do\n      SiteSetting.blocked_crawler_user_agents = 'Googlebot'\n\n      get '/', headers: non_crawler\n      expect(@status).to eq(200)\n\n      get '/', headers: {\n        'HTTP_USER_AGENT' => 'Googlebot/2.1 (+http://www.google.com/bot.html)'\n      }\n\n      expect(@status).to eq(403)\n\n      get '/', headers: {\n        'HTTP_USER_AGENT' => 'Twitterbot/2.1 (+http://www.notgoogle.com/bot.html)'\n      }\n\n      expect(@status).to eq(200)\n    end\n\n    it \"should never block robots.txt\" do\n      SiteSetting.blocked_crawler_user_agents = 'Googlebot'\n\n      get '/robots.txt', headers: {\n        'HTTP_USER_AGENT' => 'Googlebot/2.1 (+http://www.google.com/bot.html)'\n      }\n\n      expect(@status).to eq(200)\n    end\n\n    it \"should never block srv/status\" do\n      SiteSetting.blocked_crawler_user_agents = 'Googlebot'\n\n      get '/srv/status', headers: {\n        'HTTP_USER_AGENT' => 'Googlebot/2.1 (+http://www.google.com/bot.html)'\n      }\n\n      expect(@status).to eq(200)\n    end\n\n    it \"blocked crawlers shouldn't log page views\" do\n      SiteSetting.blocked_crawler_user_agents = 'Googlebot'\n\n      get '/', headers: {\n        'HTTP_USER_AGENT' => 'Googlebot/2.1 (+http://www.google.com/bot.html)'\n      }\n\n      expect(@env[\"discourse.request_tracker.skip\"]).to eq(true)\n    end\n\n    it \"blocks json requests\" do\n      SiteSetting.blocked_crawler_user_agents = 'Googlebot'\n\n      get '/srv/status.json', headers: {\n        'HTTP_USER_AGENT' => 'Googlebot/2.1 (+http://www.google.com/bot.html)'\n      }\n\n      expect(@status).to eq(403)\n    end\n  end\n\nend\n"], "filenames": ["lib/middleware/anonymous_cache.rb", "spec/components/middleware/anonymous_cache_spec.rb"], "buggy_code_start_loc": [14, 80], "buggy_code_end_loc": [115, 80], "fixing_code_start_loc": [15, 81], "fixing_code_end_loc": [121, 89], "type": "CWE-829", "message": "Discourse is an open source platform for community discussion. In affected versions an attacker can poison the cache for anonymous (i.e. not logged in) users, such that the users are shown the crawler view of the site instead of the HTML page. This can lead to a partial denial-of-service. This issue is patched in the latest stable, beta and tests-passed versions of Discourse. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-24824", "sourceIdentifier": "security-advisories@github.com", "published": "2022-04-14T22:15:07.827", "lastModified": "2022-04-22T19:53:10.497", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse is an open source platform for community discussion. In affected versions an attacker can poison the cache for anonymous (i.e. not logged in) users, such that the users are shown the crawler view of the site instead of the HTML page. This can lead to a partial denial-of-service. This issue is patched in the latest stable, beta and tests-passed versions of Discourse. There are no known workarounds for this issue."}, {"lang": "es", "value": "Discourse es una plataforma de c\u00f3digo abierto para la discusi\u00f3n comunitaria. En las versiones afectadas, un atacante puede envenenar la cach\u00e9 para usuarios an\u00f3nimos (es decir, que no han iniciado sesi\u00f3n), de tal manera que a usuarios les es mostrado la vista del rastreador del sitio en lugar de la p\u00e1gina HTML. Esto puede conllevar a una denegaci\u00f3n de servicio parcial. Este problema est\u00e1 parcheado en las \u00faltimas versiones estables, beta y de prueba de Discourse. No se presentan medidas de mitigaci\u00f3n conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-829"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.8.3", "matchCriteriaId": "F9653E97-F0B1-4559-AF43-F202A84403D2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "B3803EF9-A296-42B7-887F-93C5E68E94C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "8BA3D313-3C11-43E2-A47D-CBB532D1B6F8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "6F42673E-65F3-4807-9484-20CB747420FB"}]}]}], "references": [{"url": "https://github.com/discourse/discourse/commit/b72b0dac10493d09f4f9eb8f3c3ce7817295e34e", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse/security/advisories/GHSA-46v9-3jc4-f53w", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse/commit/b72b0dac10493d09f4f9eb8f3c3ce7817295e34e"}}