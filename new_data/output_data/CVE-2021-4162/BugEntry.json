{"buggy_code": ["import logging\nfrom pathlib import Path\nfrom shutil import which\n\nfrom elasticsearch.exceptions import RequestError\nfrom flask import Flask\nfrom flask_compress import Compress\nfrom flask_login import LoginManager\n\nfrom archivy import helpers\nfrom archivy.api import api_bp\nfrom archivy.models import User\nfrom archivy.config import Config\nfrom archivy.helpers import load_config, get_elastic_client\n\napp = Flask(__name__)\napp.logger.setLevel(logging.INFO)\nconfig = Config()\ntry:\n    # if it exists, load user config\n    config.override(load_config(config.INTERNAL_DIR))\nexcept FileNotFoundError:\n    pass\n\napp.config.from_object(config)\n(Path(app.config[\"USER_DIR\"]) / \"data\").mkdir(parents=True, exist_ok=True)\n(Path(app.config[\"USER_DIR\"]) / \"images\").mkdir(parents=True, exist_ok=True)\n\nwith app.app_context():\n    app.config[\"RG_INSTALLED\"] = which(\"rg\") != None\n    app.config[\"HOOKS\"] = helpers.load_hooks()\n    app.config[\"SCRAPING_PATTERNS\"] = helpers.load_scraper()\nif app.config[\"SEARCH_CONF\"][\"enabled\"]:\n    with app.app_context():\n        search_engines = [\"elasticsearch\", \"ripgrep\"]\n        es = None\n        if (\n            \"engine\" not in app.config[\"SEARCH_CONF\"]\n            or app.config[\"SEARCH_CONF\"][\"engine\"] not in search_engines\n        ):\n            # try to guess desired search engine if present\n            app.logger.warning(\n                \"Search is enabled but engine option is invalid or absent. Archivy will\"\n                \" try to guess preferred search engine.\"\n            )\n            app.config[\"SEARCH_CONF\"][\"engine\"] = \"none\"\n\n            es = get_elastic_client(error_if_invalid=False)\n            if es:\n                app.config[\"SEARCH_CONF\"][\"engine\"] = \"elasticsearch\"\n            else:\n                if which(\"rg\"):\n                    app.config[\"SEARCH_CONF\"][\"engine\"] = \"ripgrep\"\n            engine = app.config[\"SEARCH_CONF\"][\"engine\"]\n            if engine == \"none\":\n                app.logger.warning(\"No working search engine found. Disabling search.\")\n                app.config[\"SEARCH_CONF\"][\"enabled\"] = 0\n            else:\n                app.logger.info(f\"Running {engine} installation found.\")\n\n        if app.config[\"SEARCH_CONF\"][\"engine\"] == \"elasticsearch\":\n            es = es or get_elastic_client()\n            try:\n                es.indices.create(\n                    index=app.config[\"SEARCH_CONF\"][\"index_name\"],\n                    body=app.config[\"SEARCH_CONF\"][\"es_processing_conf\"],\n                )\n            except RequestError:\n                app.logger.info(\"Elasticsearch index already created\")\n        if app.config[\"SEARCH_CONF\"][\"engine\"] == \"ripgrep\" and not which(\"rg\"):\n            app.logger.info(\"Ripgrep not found on system. Disabling search.\")\n            app.config[\"SEARCH_CONF\"][\"enabled\"] = 0\n\n\n# login routes / setup\nlogin_manager = LoginManager()\nlogin_manager.login_view = \"login\"\nlogin_manager.init_app(app)\napp.register_blueprint(api_bp, url_prefix=\"/api\")\n\n# compress files\nCompress(app)\n\n\n@login_manager.user_loader\ndef load_user(user_id):\n    db = helpers.get_db()\n    res = db.get(doc_id=int(user_id))\n    if res and res[\"type\"] == \"user\":\n        return User.from_db(res)\n    return None\n\n\napp.jinja_options[\"extensions\"].append(\"jinja2.ext.do\")\n\n\n@app.template_filter(\"pluralize\")\ndef pluralize(number, singular=\"\", plural=\"s\"):\n    if number == 1:\n        return singular\n    else:\n        return plural\n\n\nfrom archivy import routes  # noqa:\n", "import os\r\nimport shutil\r\nimport subprocess\r\nimport sys\r\nimport tempfile\r\nimport traceback\r\nfrom pathlib import Path\r\nfrom typing import List\r\n\r\nfrom flask import Response, request\r\nfrom werkzeug.utils import secure_filename\r\n\r\nfrom archivy import click_web\r\n\r\nfrom .input_fields import FieldId\r\n\r\nlogger = None\r\n\r\n\r\ndef exec(command_path):\r\n    \"\"\"\r\n    Execute the command and stream the output from it as response\r\n    :param command_path:\r\n    \"\"\"\r\n    command_path = \"cli/\" + command_path\r\n    global logger\r\n    logger = click_web.logger\r\n\r\n    omitted = [\"shell\", \"run\", \"routes\", \"create-admin\"]\r\n    root_command, *commands = command_path.split(\"/\")\r\n    cmd = [\"archivy\"]\r\n    req_to_args = RequestToCommandArgs()\r\n    # root command_index should not add a command\r\n    cmd.extend(req_to_args.command_args(0))\r\n    for i, command in enumerate(commands):\r\n        if command in omitted:\r\n            return Response(status=400)\r\n        cmd.append(command)\r\n        cmd.extend(req_to_args.command_args(i + 1))\r\n\r\n    def _generate_output():\r\n        yield _create_cmd_header(commands)\r\n        try:\r\n            yield from _run_script_and_generate_stream(req_to_args, cmd)\r\n        except Exception as e:\r\n            # exited prematurely, show the error to user\r\n            yield f\"\\nERROR: Got exception when reading output from script: {type(e)}\\n\"\r\n            yield traceback.format_exc()\r\n            raise\r\n\r\n    return Response(_generate_output(), mimetype=\"text/plain\")\r\n\r\n\r\ndef _run_script_and_generate_stream(\r\n    req_to_args: \"RequestToCommandArgs\", cmd: List[str]\r\n):\r\n    \"\"\"\r\n    Execute the command the via Popen and yield output\r\n    \"\"\"\r\n    logger.info(\"Executing archivy command\")\r\n    if not os.environ.get(\"PYTHONIOENCODING\"):\r\n        # Fix unicode on windows\r\n        os.environ[\"PYTHONIOENCODING\"] = \"UTF-8\"\r\n\r\n    process = subprocess.Popen(\r\n        cmd, shell=False, stdout=subprocess.PIPE, stderr=subprocess.STDOUT\r\n    )\r\n    logger.info(\"script running Pid: %d\", process.pid)\r\n\r\n    encoding = sys.getdefaultencoding()\r\n    with process.stdout:\r\n        for line in iter(process.stdout.readline, b\"\"):\r\n            yield line.decode(encoding)\r\n\r\n    process.wait()  # wait for the subprocess to exit\r\n    logger.info(\"script finished Pid: %d\", process.pid)\r\n    for fi in req_to_args.field_infos:\r\n        fi.after_script_executed()\r\n\r\n\r\ndef _create_cmd_header(commands: List[str]):\r\n    \"\"\"\r\n    Generate a command header.\r\n    Note:\r\n        here we always allow to generate HTML as long as we have it between CLICK-WEB comments.\r\n        This way the JS frontend can insert it in the correct place in the DOM.\r\n    \"\"\"\r\n\r\n    def generate():\r\n        yield \"<!-- CLICK_WEB START HEADER -->\"\r\n        yield '<div class=\"command-line\">Executing: {}</div>'.format(\"/\".join(commands))\r\n        yield \"<!-- CLICK_WEB END HEADER -->\"\r\n\r\n    # important yield this block as one string so it pushed to client in one go.\r\n    # so the whole block can be treated as html.\r\n    html_str = \"\\n\".join(generate())\r\n    return html_str\r\n\r\n\r\ndef _create_result_footer(req_to_args: \"RequestToCommandArgs\"):\r\n    \"\"\"\r\n    Generate a footer.\r\n    Note:\r\n        here we always allow to generate HTML as long as we have it between CLICK-WEB comments.\r\n        This way the JS frontend can insert it in the correct place in the DOM.\r\n    \"\"\"\r\n    to_download = [\r\n        fi\r\n        for fi in req_to_args.field_infos\r\n        if fi.generate_download_link and fi.link_name\r\n    ]\r\n    # important yield this block as one string so it pushed to client in one go.\r\n    # This is so the whole block can be treated as html if JS frontend.\r\n    lines = []\r\n    lines.append(\"<!-- CLICK_WEB START FOOTER -->\")\r\n    if to_download:\r\n        lines.append(\"<b>Result files:</b><br>\")\r\n        for fi in to_download:\r\n            lines.append(\"<ul> \")\r\n            lines.append(f\"<li>{_get_download_link(fi)}<br>\")\r\n            lines.append(\"</ul>\")\r\n\r\n    else:\r\n        lines.append(\"<b>DONE</b>\")\r\n    lines.append(\"<!-- CLICK_WEB END FOOTER -->\")\r\n    html_str = \"\\n\".join(lines)\r\n    yield html_str\r\n\r\n\r\ndef _get_download_link(field_info):\r\n    \"\"\"Hack as url_for need request context\"\"\"\r\n\r\n    rel_file_path = Path(field_info.file_path).relative_to(click_web.OUTPUT_FOLDER)\r\n    uri = f\"/static/results/{rel_file_path.as_posix()}\"\r\n    return f'<a href=\"{uri}\">{field_info.link_name}</a>'\r\n\r\n\r\nclass RequestToCommandArgs:\r\n    def __init__(self):\r\n        field_infos = [\r\n            FieldInfo.factory(key)\r\n            for key in list(request.form.keys()) + list(request.files.keys())\r\n        ]\r\n        # important to sort them so they will be in expected order on command line\r\n        self.field_infos = list(sorted(field_infos))\r\n\r\n    def command_args(self, command_index) -> List[str]:\r\n        \"\"\"\r\n        Convert the post request into a list of command line arguments\r\n\r\n        :param command_index: (int) the index for the command to get arguments for.\r\n        :return: list of command line arguments for command at that cmd_index\r\n        \"\"\"\r\n        args = []\r\n\r\n        # only include relevant fields for this command index\r\n        commands_field_infos = [\r\n            fi for fi in self.field_infos if fi.param.command_index == command_index\r\n        ]\r\n        commands_field_infos = sorted(commands_field_infos)\r\n\r\n        for fi in commands_field_infos:\r\n\r\n            # must be called mostly for saving and preparing file output.\r\n            fi.before_script_execute()\r\n\r\n            if fi.cmd_opt.startswith(\"--\"):\r\n                # it's an option\r\n                args.extend(self._process_option(fi))\r\n\r\n            else:\r\n                # argument(s)\r\n                if isinstance(fi, FieldFileInfo):\r\n                    # it's a file, append the written temp file path\r\n                    # TODO: does file upload support multiple keys? In that case support it.\r\n                    args.append(fi.file_path)\r\n                else:\r\n                    arg_values = request.form.getlist(fi.key)\r\n                    has_values = bool(\"\".join(arg_values))\r\n                    if has_values:\r\n                        if fi.param.nargs == -1:\r\n                            # Variadic argument, in html form each argument\r\n                            # is a separate line in a textarea.\r\n                            # treat each line we get from text area as a separate argument.\r\n                            for value in arg_values:\r\n                                values = value.splitlines()\r\n                                logger.info(\r\n                                    f'variadic arguments, split into: \"{values}\"'\r\n                                )\r\n                                args.extend(values)\r\n                        else:\r\n                            logger.info(f'arg_value: \"{arg_values}\"')\r\n                            args.extend(arg_values)\r\n        return args\r\n\r\n    def _process_option(self, field_info):\r\n        vals = request.form.getlist(field_info.key)\r\n        if field_info.is_file:\r\n            if field_info.link_name:\r\n                # it's a file, append the file path\r\n                yield field_info.cmd_opt\r\n                yield field_info.file_path\r\n        elif field_info.param.param_type == \"flag\":\r\n            # To work with flag that is default True\r\n            # a hidden field with same name is also sent by form.\r\n            # This is to detect if checkbox was not checked as then\r\n            # we will get the field anyway with the \"off flag\" as value.\r\n            if len(vals) == 1:\r\n                off_flag = vals[0]\r\n                flag_on_cmd_line = off_flag\r\n            else:\r\n                # we got both off and on flags, checkbox is checked.\r\n                on_flag = vals[1]\r\n                flag_on_cmd_line = on_flag\r\n\r\n            yield flag_on_cmd_line\r\n        elif \"\".join(vals):\r\n            # opt with value, if option was given multiple times get the values for each.\r\n            # flag options should always be set if we get them\r\n            # for normal options they must have a non empty value\r\n            yield field_info.cmd_opt\r\n            for val in vals:\r\n                if val:\r\n                    yield val\r\n        else:\r\n            # option with empty values, should not be added to command line.\r\n            pass\r\n\r\n\r\nclass FieldInfo:\r\n    \"\"\"\r\n    Extract information from the encoded form input field name\r\n    the parts:\r\n        [command_index].[opt_or_arg_index].[click_type].[html_input_type].[opt_or_arg_name]\r\n    e.g.\r\n        \"0.0.option.text.text.--an-option\"\r\n        \"0.1.argument.file[rb].text.an-argument\"\r\n    \"\"\"\r\n\r\n    @staticmethod\r\n    def factory(key):\r\n        field_id = FieldId.from_string(key)\r\n        is_file = field_id.click_type.startswith(\"file\")\r\n        is_path = field_id.click_type.startswith(\"path\")\r\n        is_uploaded = key in request.files\r\n        if is_file:\r\n            if is_uploaded:\r\n                field_info = FieldFileInfo(field_id)\r\n            else:\r\n                field_info = FieldOutFileInfo(field_id)\r\n        elif is_path:\r\n            if is_uploaded:\r\n                field_info = FieldPathInfo(field_id)\r\n            else:\r\n                field_info = FieldPathOutInfo(field_id)\r\n        else:\r\n            field_info = FieldInfo(field_id)\r\n        return field_info\r\n\r\n    def __init__(self, param: FieldId):\r\n        self.param = param\r\n        self.key = param.key\r\n\r\n        \"Type of option (file, text)\"\r\n        self.is_file = self.param.click_type.startswith(\"file\")\r\n\r\n        \"The actual command line option (--debug)\"\r\n        self.cmd_opt = param.name\r\n\r\n        self.generate_download_link = False\r\n\r\n    def before_script_execute(self):\r\n        pass\r\n\r\n    def after_script_executed(self):\r\n        pass\r\n\r\n    def __str__(self):\r\n        return str(self.param)\r\n\r\n    def __lt__(self, other):\r\n        \"Make class sortable\"\r\n        return (self.param.command_index, self.param.param_index) < (\r\n            other.param.command_index,\r\n            other.param.param_index,\r\n        )\r\n\r\n    def __eq__(self, other):\r\n        return self.key == other.key\r\n\r\n\r\nclass FieldFileInfo(FieldInfo):\r\n    \"\"\"\r\n    Use for processing input fields of file type.\r\n    Saves the posted data to a temp file.\r\n    \"\"\"\r\n\r\n    \"temp dir is on class in order to be uniqe for each request\"\r\n    _temp_dir = None\r\n\r\n    def __init__(self, fimeta):\r\n        super().__init__(fimeta)\r\n        # Extract the file mode that is in the type e.g file[rw]\r\n        self.mode = self.param.click_type.split(\"[\")[1][:-1]\r\n        self.generate_download_link = True if \"w\" in self.mode else False\r\n        self.link_name = f\"{self.cmd_opt}.out\"\r\n\r\n        logger.info(f\"File mode for {self.key} is {self.mode}\")\r\n\r\n    def before_script_execute(self):\r\n        self.save()\r\n\r\n    @classmethod\r\n    def temp_dir(cls):\r\n        if not cls._temp_dir:\r\n            cls._temp_dir = tempfile.mkdtemp(dir=click_web.OUTPUT_FOLDER)\r\n        logger.info(f\"Temp dir: {cls._temp_dir}\")\r\n        return cls._temp_dir\r\n\r\n    def save(self):\r\n        logger.info(\"Saving...\")\r\n\r\n        logger.info(\"field value is a file! %s\", self.key)\r\n        file = request.files[self.key]\r\n        # if user does not select file, browser also\r\n        # submit a empty part without filename\r\n        if file.filename == \"\":\r\n            raise ValueError(\"No selected file\")\r\n        elif file and file.filename:\r\n            filename = secure_filename(file.filename)\r\n            name, suffix = os.path.splitext(filename)\r\n\r\n            fd, filename = tempfile.mkstemp(\r\n                dir=self.temp_dir(), prefix=name, suffix=suffix\r\n            )\r\n            self.file_path = filename\r\n            logger.info(f\"Saving {self.key} to {filename}\")\r\n            file.save(filename)\r\n\r\n    def __str__(self):\r\n\r\n        res = [super().__str__()]\r\n        res.append(f\"file_path: {self.file_path}\")\r\n        return \", \".join(res)\r\n\r\n\r\nclass FieldOutFileInfo(FieldFileInfo):\r\n    \"\"\"\r\n    Used when file option is just for output and form posted it as hidden or text field.\r\n    Just create a empty temp file to give it's path to command.\r\n    \"\"\"\r\n\r\n    def __init__(self, fimeta):\r\n        super().__init__(fimeta)\r\n        if self.param.form_type == \"text\":\r\n            self.link_name = request.form[self.key]\r\n            # set the postfix to name name provided from form\r\n            # this way it will at least have the same extension when downloaded\r\n            self.file_suffix = request.form[self.key]\r\n        else:\r\n            # hidden no preferred file name can be provided by user\r\n            self.file_suffix = \".out\"\r\n\r\n    def save(self):\r\n        name = secure_filename(self.key)\r\n\r\n        filename = tempfile.mkstemp(\r\n            dir=self.temp_dir(), prefix=name, suffix=self.file_suffix\r\n        )\r\n        logger.info(f\"Creating empty file for {self.key} as {filename}\")\r\n        self.file_path = filename\r\n\r\n\r\nclass FieldPathInfo(FieldFileInfo):\r\n    \"\"\"\r\n    Use for processing input fields of path type.\r\n    Extracts the posted data to a temp folder.\r\n    When script finished zip that folder and provide download link to zip file.\r\n    \"\"\"\r\n\r\n    def save(self):\r\n        super().save()\r\n        zip_extract_dir = tempfile.mkdtemp(dir=self.temp_dir())\r\n\r\n        logger.info(f\"Extracting: {self.file_path} to {zip_extract_dir}\")\r\n        shutil.unpack_archive(self.file_path, zip_extract_dir, \"zip\")\r\n        self.file_path = zip_extract_dir\r\n\r\n    def after_script_executed(self):\r\n        super().after_script_executed()\r\n        fd, filename = tempfile.mkstemp(dir=self.temp_dir(), prefix=self.key)\r\n        folder_path = self.file_path\r\n        self.file_path = filename\r\n\r\n        logger.info(f\"Zipping {self.key} to {filename}\")\r\n        self.file_path = shutil.make_archive(self.file_path, \"zip\", folder_path)\r\n        logger.info(f\"Zip file created {self.file_path}\")\r\n        self.generate_download_link = True\r\n\r\n\r\nclass FieldPathOutInfo(FieldOutFileInfo):\r\n    \"\"\"\r\n    Use for processing output fields of path type.\r\n    Create a folder and use as path to script.\r\n    When script finished zip that folder and provide download link to zip file.\r\n    \"\"\"\r\n\r\n    def save(self):\r\n        super().save()\r\n        self.file_path = tempfile.mkdtemp(dir=self.temp_dir())\r\n\r\n    def after_script_executed(self):\r\n        super().after_script_executed()\r\n        fd, filename = tempfile.mkstemp(dir=self.temp_dir(), prefix=self.key)\r\n        folder_path = self.file_path\r\n        self.file_path = filename\r\n        logger.info(f\"Zipping {self.key} to {filename}\")\r\n        self.file_path = shutil.make_archive(self.file_path, \"zip\", folder_path)\r\n        logger.info(f\"Zip file created {self.file_path}\")\r\n        self.generate_download_link = True\r\n", "from pathlib import Path\nfrom os.path import sep\nfrom pkg_resources import require\nfrom shutil import which\n\nimport frontmatter\nfrom flask import (\n    render_template,\n    flash,\n    redirect,\n    request,\n    url_for,\n    send_file,\n    send_from_directory,\n)\nfrom flask_login import login_user, current_user, logout_user\nfrom tinydb import Query\nfrom werkzeug.security import check_password_hash, generate_password_hash\n\nfrom archivy.models import DataObj, User\nfrom archivy import data, app, forms\nfrom archivy.helpers import get_db, write_config\nfrom archivy.tags import get_all_tags\nfrom archivy.search import search\nfrom archivy.config import Config\n\nimport re\n\n\n@app.context_processor\ndef pass_defaults():\n    dataobjs = data.get_items(load_content=False)\n    version = require(\"archivy\")[0].version\n    SEP = sep\n    # check windows parsing for js (https://github.com/Uzay-G/archivy/issues/115)\n    if SEP == \"\\\\\":\n        SEP += \"\\\\\"\n    return dict(dataobjs=dataobjs, SEP=SEP, version=version)\n\n\n@app.before_request\ndef check_perms():\n    allowed_path = (\n        request.path.startswith(\"/login\")\n        or request.path.startswith(\"/static\")\n        or request.path.startswith(\"/api/login\")\n    )\n    if not current_user.is_authenticated and not allowed_path:\n        return redirect(url_for(\"login\", next=request.path))\n    return\n\n\n@app.route(\"/\")\n@app.route(\"/index\")\ndef index():\n    path = request.args.get(\"path\", \"\").lstrip(\"/\")\n    try:\n        files = data.get_items(path=path)\n    except FileNotFoundError:\n        flash(\"Directory does not exist.\", \"error\")\n        return redirect(\"/\")\n\n    return render_template(\n        \"home.html\",\n        title=path or \"root\",\n        search_enabled=app.config[\"SEARCH_CONF\"][\"enabled\"],\n        dir=files,\n        current_path=path,\n        new_folder_form=forms.NewFolderForm(),\n        delete_form=forms.DeleteFolderForm(),\n        rename_form=forms.RenameDirectoryForm(),\n        view_only=0,\n        search_engine=app.config[\"SEARCH_CONF\"][\"engine\"],\n    )\n\n\n# TODO: refactor two following methods\n@app.route(\"/bookmarks/new\", methods=[\"GET\", \"POST\"])\ndef new_bookmark():\n    default_dir = app.config.get(\"DEFAULT_BOOKMARKS_DIR\", \"root directory\")\n    form = forms.NewBookmarkForm(path=default_dir)\n    form.path.choices = [(\"\", \"root directory\")] + [\n        (pathname, pathname) for pathname in data.get_dirs()\n    ]\n    if form.validate_on_submit():\n        path = form.path.data\n        tags = form.tags.data.split(\",\") if form.tags.data != \"\" else []\n        tags = [tag.strip() for tag in tags]\n        bookmark = DataObj(url=form.url.data, tags=tags, path=path, type=\"bookmark\")\n        bookmark.process_bookmark_url()\n        bookmark_id = bookmark.insert()\n        if bookmark_id:\n            flash(\"Bookmark Saved!\", \"success\")\n            return redirect(f\"/dataobj/{bookmark_id}\")\n        else:\n            flash(bookmark.error, \"error\")\n            return redirect(\"/bookmarks/new\")\n    # for bookmarklet\n    form.url.data = request.args.get(\"url\", \"\")\n    path = request.args.get(\"path\", default_dir).strip(\"/\")\n    # handle empty argument\n    form.path.data = path\n    return render_template(\"dataobjs/new.html\", title=\"New Bookmark\", form=form)\n\n\n@app.route(\"/notes/new\", methods=[\"GET\", \"POST\"])\ndef new_note():\n    form = forms.NewNoteForm()\n    default_dir = \"root directory\"\n    form.path.choices = [(\"\", default_dir)] + [\n        (pathname, pathname) for pathname in data.get_dirs()\n    ]\n    if form.validate_on_submit():\n        path = form.path.data\n        tags = form.tags.data.split(\",\") if form.tags.data != \"\" else []\n        tags = [tag.strip() for tag in tags]\n        note = DataObj(title=form.title.data, path=path, tags=tags, type=\"note\")\n        note_id = note.insert()\n        if note_id:\n            flash(\"Note Saved!\", \"success\")\n            return redirect(f\"/dataobj/{note_id}\")\n    path = request.args.get(\"path\", default_dir).strip(\"/\")\n    # handle empty argument\n    form.path.data = path\n    return render_template(\"/dataobjs/new.html\", title=\"New Note\", form=form)\n\n\n@app.route(\"/tags\")\ndef show_all_tags():\n    if not app.config[\"SEARCH_CONF\"][\"engine\"] == \"ripgrep\" and not which(\"rg\"):\n        flash(\"Ripgrep must be installed to view pages about embedded tags.\", \"error\")\n        return redirect(\"/\")\n    tags = sorted(get_all_tags(force=True))\n    return render_template(\"tags/all.html\", title=\"All Tags\", tags=tags)\n\n\n@app.route(\"/tags/<tag_name>\")\ndef show_tag(tag_name):\n    if not app.config[\"SEARCH_CONF\"][\"enabled\"] and not which(\"rg\"):\n        flash(\n            \"Search (for example ripgrep) must be installed to view pages about embedded tags.\",\n            \"error\",\n        )\n        return redirect(\"/\")\n\n    search_results = search(f\"#{tag_name}#\", strict=True)\n\n    return render_template(\n        \"tags/show.html\",\n        title=f\"Tags - {tag_name}\",\n        tag_name=tag_name,\n        search_result=search_results,\n    )\n\n\n@app.route(\"/dataobj/<int:dataobj_id>\")\ndef show_dataobj(dataobj_id):\n    dataobj = data.get_item(dataobj_id)\n    get_title_id_pairs = lambda x: (x[\"title\"], x[\"id\"])\n    titles = list(\n        map(get_title_id_pairs, data.get_items(structured=False, load_content=False))\n    )\n\n    if not dataobj:\n        flash(\"Data could not be found!\", \"error\")\n        return redirect(\"/\")\n\n    if request.args.get(\"raw\") == \"1\":\n        return frontmatter.dumps(dataobj)\n\n    backlinks = []\n    if app.config[\"SEARCH_CONF\"][\"enabled\"]:\n        if app.config[\"SEARCH_CONF\"][\"engine\"] == \"ripgrep\":\n            query = f\"\\|{dataobj_id}]]\"\n        else:\n            query = f\"|{dataobj_id})]]\"\n        backlinks = search(query, strict=True)\n\n    # Form for moving data into another folder\n    move_form = forms.MoveItemForm()\n    move_form.path.choices = [(\"\", \"root directory\")] + [\n        (pathname, pathname) for pathname in data.get_dirs()\n    ]\n\n    post_title_form = forms.TitleForm()\n    post_title_form.title.data = dataobj[\"title\"]\n\n    # Get all tags\n    tag_list = get_all_tags()\n    # and the ones present in this dataobj\n    embedded_tags = set()\n    PATTERN = r\"(?:^|\\n| )#(?:[-_a-zA-Z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff0-9]+)#\"\n    for match in re.finditer(PATTERN, dataobj.content):\n        embedded_tags.add(match.group(0).replace(\"#\", \"\").lstrip())\n\n    return render_template(\n        \"dataobjs/show.html\",\n        title=dataobj[\"title\"],\n        dataobj=dataobj,\n        backlinks=backlinks,\n        current_path=dataobj[\"dir\"],\n        form=forms.DeleteDataForm(),\n        view_only=0,\n        search_enabled=app.config[\"SEARCH_CONF\"][\"enabled\"],\n        post_title_form=post_title_form,\n        move_form=move_form,\n        tag_list=tag_list,\n        embedded_tags=embedded_tags,\n        titles=titles,\n    )\n\n\n@app.route(\"/dataobj/move/<int:dataobj_id>\", methods=[\"POST\"])\ndef move_item(dataobj_id):\n    form = forms.MoveItemForm()\n    out_dir = form.path.data if form.path.data != \"\" else \"root directory\"\n    if form.path.data == None:\n        flash(\"No path specified.\")\n        return redirect(f\"/dataobj/{dataobj_id}\")\n    try:\n        if data.move_item(dataobj_id, form.path.data):\n            flash(f\"Data successfully moved to {out_dir}.\", \"success\")\n            return redirect(f\"/dataobj/{dataobj_id}\")\n        else:\n            flash(f\"Data could not be moved to {out_dir}.\", \"error\")\n            return redirect(f\"/dataobj/{dataobj_id}\")\n    except FileNotFoundError:\n        flash(\"Data not found.\", \"error\")\n        return redirect(\"/\")\n    except FileExistsError:\n        flash(\"Data already in target directory.\", \"error\")\n        return redirect(f\"/dataobj/{dataobj_id}\")\n\n\n@app.route(\"/dataobj/delete/<int:dataobj_id>\", methods=[\"DELETE\", \"GET\"])\ndef delete_data(dataobj_id):\n    try:\n        data.delete_item(dataobj_id)\n    except BaseException:\n        flash(\"Data could not be found!\", \"error\")\n        return redirect(\"/\")\n    flash(\"Data deleted!\", \"success\")\n    return redirect(\"/\")\n\n\n@app.route(\"/login\", methods=[\"GET\", \"POST\"])\ndef login():\n    form = forms.UserForm()\n    if form.validate_on_submit():\n        db = get_db()\n        user = db.search(\n            (Query().username == form.username.data) & (Query().type == \"user\")\n        )\n\n        if user and check_password_hash(user[0][\"hashed_password\"], form.password.data):\n            user = User.from_db(user[0])\n            login_user(user, remember=True)\n            flash(\"Login successful!\", \"success\")\n\n            next_url = request.args.get(\"next\")\n            return redirect(next_url or \"/\")\n\n        flash(\"Invalid credentials\", \"error\")\n        return redirect(\"/login\")\n    return render_template(\"users/login.html\", form=form, title=\"Login\")\n\n\n@app.route(\"/logout\", methods=[\"DELETE\", \"GET\"])\ndef logout():\n    logout_user()\n    flash(\"Logged out successfully\", \"success\")\n    return redirect(\"/\")\n\n\n@app.route(\"/user/edit\", methods=[\"GET\", \"POST\"])\ndef edit_user():\n    form = forms.UserForm()\n    if form.validate_on_submit():\n        db = get_db()\n        db.update(\n            {\n                \"username\": form.username.data,\n                \"hashed_password\": generate_password_hash(form.password.data),\n            },\n            doc_ids=[current_user.id],\n        )\n        flash(\"Information saved!\", \"success\")\n        return redirect(\"/\")\n    form.username.data = current_user.username\n    return render_template(\"users/edit.html\", form=form, title=\"Edit Profile\")\n\n\n@app.route(\"/folders/create\", methods=[\"POST\"])\ndef create_folder():\n    form = forms.NewFolderForm()\n    if form.validate_on_submit():\n        path = Path(form.parent_dir.data.strip(\"/\")) / form.new_dir.data\n        new_path = data.create_dir(str(path))\n        flash(\"Folder successfully created.\", \"success\")\n        return redirect(f\"/?path={new_path}\")\n    flash(\"Could not create folder.\", \"error\")\n    return redirect(request.referrer or \"/\")\n\n\n@app.route(\"/folders/delete\", methods=[\"POST\"])\ndef delete_folder():\n    form = forms.DeleteFolderForm()\n    if form.validate_on_submit():\n        if data.delete_dir(form.dir_name.data):\n            flash(\"Folder successfully deleted.\", \"success\")\n            return redirect(\"/\")\n        else:\n            flash(\"Folder not found.\", \"error\")\n            return redirect(request.referrer or \"/\", 404)\n    flash(\"Could not delete folder.\", \"error\")\n    return redirect(request.referrer or \"/\")\n\n\n@app.route(\"/folders/rename\", methods=[\"POST\"])\ndef rename_folder():\n    form = forms.RenameDirectoryForm()\n    if form.validate_on_submit():\n        try:\n            new_path = data.rename_folder(form.current_path.data, form.new_name.data)\n            if not new_path:\n                flash(\"Invalid input.\", \"error\")\n            else:\n                flash(\"Renamed successfully.\", \"success\")\n                return redirect(f\"/?path={new_path}\")\n        except FileNotFoundError:\n            flash(\"Directory not found.\", \"error\")\n        except FileExistsError:\n            flash(\"Target directory exists.\", \"error\")\n    return redirect(\"/\")\n\n\n@app.route(\"/bookmarklet\")\ndef bookmarklet():\n    return render_template(\"bookmarklet.html\", title=\"Bookmarklet\")\n\n\n@app.route(\"/images/<filename>\")\ndef serve_image(filename):\n    if filename and data.valid_image_filename(filename):\n        image_path = data.image_exists(filename)\n        if image_path:\n            return send_file(image_path)\n        else:\n            return \"Image not found\", 404\n    else:\n        return \"Invalid file request\", 413\n\n\n@app.route(\"/static/custom.css\")\ndef custom_css():\n    if not app.config[\"THEME_CONF\"].get(\"use_custom_css\", False):\n        return \"\"\n    return send_from_directory(\n        Path(app.config[\"USER_DIR\"]) / \"css\",\n        app.config[\"THEME_CONF\"][\"custom_css_file\"],\n    )\n\n\n@app.route(\"/config\", methods=[\"GET\", \"POST\"])\ndef config():\n    \"\"\"\n    Web View to edit and update configuration.\n    \"\"\"\n\n    def update_config_value(key, val, dictionary):\n        if key != \"SECRET_KEY\":\n            if type(val) is dict:\n                for k, v in val.items():\n                    update_config_value(k, v, dictionary[key])\n            else:\n                dictionary[key] = val\n\n    form = forms.config_form(app.config)\n    default = vars(Config())\n    if form.validate_on_submit():\n        changed_config = Config()\n        changed_config.override(form.data)\n        for k, v in vars(changed_config).items():\n            # propagate changes to configuration\n            update_config_value(k, v, app.config)\n        write_config(vars(changed_config))  # save to filesystem config\n        flash(\"Config successfully updated.\", \"success\")\n    elif request.method == \"POST\":\n        flash(\"Could not update config.\", \"error\")\n    return render_template(\n        \"config.html\", conf=form, default=default, title=\"Edit Config\"\n    )\n", "{% import 'click_web/form_macros.html' as macros %}\r\n<h2 class=\"command-title-parents\">{{ levels[1:-1]| join(' - ', attribute='command.name')|title }}</h2>\r\n<h3 class=\"command-title\">{{ command.name|title }}</h3>\r\n<div class=\"command-help\">{{ command.html_help }}</div>\r\n\r\n<form id=\"inputform\"\r\n      method=\"post\"\r\n      action=\"{{ request.url }}\"\r\n      onsubmit=\"return postAndRead('{{ request.url }}');\"\r\n      class=\"pure-form pure-form-aligned\"\r\n      enctype=\"multipart/form-data\">\r\n    {% set command_list = [] %}\r\n    {% for level in levels %}\r\n        {% for field in level.fields %}\r\n            <div class=\"parameter {{ field.param }} {{ field.type }}\">\r\n                <div class=\"pure-control-group\">\r\n                    {% if field.nargs == -1 %}\r\n                        {{ macros.add_variadic_field_input(field) }}\r\n                    {% else %}\r\n                        <label for=\"{{ field.name }}\">\r\n                            {{ field.human_readable_name|capitalize }}\r\n                        </label>\r\n                        {% for arg in range(field.nargs) %}\r\n                            {{ macros.add_field_input(field) }}\r\n                        {% endfor %}\r\n\r\n                    {% endif %}\r\n                </div>\r\n            </div>\r\n        {% endfor %}\r\n    {% endfor %}\r\n    <button type=\"submit\" id=\"submit_btn\" class=\"btn btn-primary m-2\">Run</button>\r\n</form>\r\n\r\n<div id=\"output-header\" hidden=\"true\"></div>\r\n<div class=\"script-output\" id=\"output\" hidden=\"true\"></div>\r\n<div id=\"output-footer\" hidden=\"true\"></div>\r\n", "{% extends \"base.html\" %}\n\n{% block content %}\n  <form id=\"tag_tooltip\" class=\"hidden\">\n    <input list=\"tags\" id=\"tag_tooltip_input\" class=\"floating_input\" required />\n    <datalist id=\"tags\">\n      {% for tag in tag_list %}\n        <option value=\"#{{tag}}\">\n      {% endfor %}\n    </datalist>\n  </form>\n\n  <form id=\"note_link_tooltip\" class=\"hidden\">\n    <input list=\"titles\" id=\"title_tooltip_input\" class=\"floating_input\" required placeholder=\"Title of linked note\" />\n    <datalist id=\"titles\">\n      {% for dataobj_title, id in titles %}\n        <option value=\"[[{{ dataobj_title }}|{{id}}]]\" data-id=\"{{ id }}\">\n      {% endfor %}\n    </datalist>\n  </form\n\n  {% include \"markdown-parser.html\" %}\n  {% if not view_only %}\n    <link rel=\"stylesheet\" href=\"/static/editor.css\">\n    {% if config.THEME_CONF.get('use_theme_dark', False) %}\n      <link rel=\"stylesheet\" href=\"/static/editor_dark.css\">\n    {% endif %}\n    <link rel=\"stylesheet\" href=\"/static/accessibility.css\">\n    <script async src=\"/static/editor.js\"></script>\n  {% endif %}\n  <link rel=\"stylesheet\" href=\"/static/markdown.css\">\n  {% if config.THEME_CONF.get('use_theme_dark', False) %}\n    <link rel=\"stylesheet\" href=\"/static/markdown_dark.css\">\n  {% endif %}\n  <div class=\"post-header\">\n    <!-- Form for editing the frontmatter -->\n    {% if not view_only %}\n    <form id=\"post-title-form\">\n      {{ post_title_form.hidden_tag() }}\n      {{ post_title_form.title() }}\n      {{ post_title_form.submit() }}\n    </form>\n    {% else %}\n      <h2 id=\"post-title\">\n        {{ dataobj['title'] }}\n      </h2>\n    {% endif %}\n\n    <div class=\"embedded-tags post-tags\">\n      {% for tag in embedded_tags %}\n        <span class=\"post-tag\">{{ tag }}</span>\n      {% endfor %}\n    </div>\n    <div class=\"metadata-tags post-tags\">\n      {% for tag in dataobj[\"tags\"] %}\n\t<span class=\"post-tag\">{{ tag }}</span>\n      {% endfor %}\n    </div>\n    <span class=\"post-date\">{{ dataobj['date'] }}</span>\n\n    {% if dataobj['type'] == 'bookmark' or dataobj['type'] == 'pocket_bookmark' %}\n      <a href=\"{{ dataobj['url'] }}\" rel=\"noopener\">\n        Link\n      </a>\n    {% endif %}\n    <br>\n    <!-- Edit / Delete buttons -->\n    {% if not view_only %}\n      <div class=\"d-flex\" id=\"post-btns\">\n          <button onclick=\"toggleEditor(this)\" class=\"btn\">\n            <svg class=\"octicon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M11.013 1.427a1.75 1.75 0 012.474 0l1.086 1.086a1.75 1.75 0 010 2.474l-8.61 8.61c-.21.21-.47.364-.756.445l-3.251.93a.75.75 0 01-.927-.928l.929-3.25a1.75 1.75 0 01.445-.758l8.61-8.61zm1.414 1.06a.25.25 0 00-.354 0L10.811 3.75l1.439 1.44 1.263-1.263a.25.25 0 000-.354l-1.086-1.086zM11.189 6.25L9.75 4.81l-6.286 6.287a.25.25 0 00-.064.108l-.558 1.953 1.953-.558a.249.249 0 00.108-.064l6.286-6.286z\"></path></svg>\n            <span>Edit</span>\n          </button>\n          <form action=\"/dataobj/delete/{{ dataobj['id'] }}\" method=\"delete\" onsubmit=\"return confirm('Delete this item permanently?')\" novalidate>\n            {{ form.hidden_tag() }}\n            <button class=\"btn btn-delete\">\n              <svg class=\"octicon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M6.5 1.75a.25.25 0 01.25-.25h2.5a.25.25 0 01.25.25V3h-3V1.75zm4.5 0V3h2.25a.75.75 0 010 1.5H2.75a.75.75 0 010-1.5H5V1.75C5 .784 5.784 0 6.75 0h2.5C10.216 0 11 .784 11 1.75zM4.496 6.675a.75.75 0 10-1.492.15l.66 6.6A1.75 1.75 0 005.405 15h5.19c.9 0 1.652-.681 1.741-1.576l.66-6.6a.75.75 0 00-1.492-.149l-.66 6.6a.25.25 0 01-.249.225h-5.19a.25.25 0 01-.249-.225l-.66-6.6z\"></path></svg>\n              <span>Delete</span>\n            </button>\n          </form>\n\n          <form action=\"/dataobj/move/{{ dataobj['id'] }}\" method=\"post\" novalidate id=\"post-move-form\">\n            {{ move_form.hidden_tag() }}\n            <button class=\"btn\">\n              Move to\n            </button>\n            {{ move_form.path(placeholder=move_form.path.name) }}\n          </form>\n          <label class=\"sr-only\">\n            <input type=\"checkbox\" id=\"sr-checkbox\">\n            screenreader mode\n          </label>\n      </div>\n\n    {% endif %}\n  </div>\n\n\n  <div id=\"content-cont\" class=\"markdown-body\">\n    <div id=\"content\"></div>\n      {% if not view_only %}\n        <textarea id=\"original-textarea\" aria-label=\"Text editor\"></textarea>\n      {% endif %}\n\n    {% if backlinks %}\n      <ul id=\"backlinks\" style=\"padding: 0\">\n        <h1>Backlinks</h3>\n        {% for backlink in backlinks %}\n          <li><a href=\"/dataobj/{{ backlink['id'] }}\">{{ backlink[\"title\"] }}:</a></li>\n          {% if \"matches\" in backlink %}\n            {% for link in backlink[\"matches\"] %}\n              <div class=\"backlink-markdown\">{{ link }}</div>\n            {% endfor %}\n          {% endif %}\n        {% endfor %}\n      </ul>\n    {% endif %}\n  </div>\n  <br>\n  {% if not view_only %}\n    <button class=\"sr-only\" type=\"button\" id=\"sr-savebutton\">Save</button>\n  {% endif %}\n  <script>\n    // escape text for template literal - double slashes for python rendering and js rendering\n    /* {% set content = dataobj[\"content\"]\n                          | replace(\"\\\\\", \"\\\\\\\\\")\n                          | replace(\"`\", \"\\\\`\")\n                          | replace(\"${\", \"\\\\${\")\n                          | safe\n       %} */\n    // Render the content with TOC\n    let contentDiv = document.getElementById(\"content\");\n    function renderContent(content) {\n      return window.parser.customRender(\"${toc}\\n\\n\" + content);\n    }\n    contentDiv.innerHTML = renderContent(`{{ content }}`);\n\n    {% if not view_only %}\n      // Also show the editing options\n      // The form for editing the front matter\n      let update_frontmatter_callback = function(e) {\n        let payload = {\n          method: \"PUT\",\n          body: JSON.stringify({\n            \"title\": post_title_form.title.value,\n          }),\n          headers: {\n            \"content-type\": \"application/json\"\n          }\n        };\n\n        response = fetch(`${SCRIPT_ROOT}/dataobjs/frontmatter/{{dataobj['id']}}`, payload);\n        post_title_form.submit.classList.add(\"post-title-form-sucess\");\n        e.preventDefault();\n      }\n\n      let post_title_form = document.getElementById(\"post-title-form\");\n      post_title_form.addEventListener(\"submit\", update_frontmatter_callback, true);\n\n      // Render the editor and put the dataobj in it\n      let editorDiv, oldContent, editor, savedContent = `{{ content }}`;\n\n      // Show the form for embedding links\n      let searchHits = document.getElementById(\"searchHits\");\n      let linkForm = document.getElementById(\"link-form\");\n      function toggleLinkForm() {\n        {% if not search_enabled %} return {% endif %}\n        if (linkForm.style.display == \"none\") {\n          linkForm.style.display = \"block\";\n        } else {\n          linkForm.style.display = \"none\";\n          input.value = \"\";\n          searchHits.innerHTML = \"\";\n        }\n      }\n\n      window.addEventListener(\"load\", function() {\n        // Set up the editor\n        editor = new EasyMDE({\n          autofocus: true,\n          uploadImage: true,\n          imageUploadEndpoint: \"{{ SCRIPT_ROOT }}/api/images\",\n          previewRender: function(content) {\n            return renderContent(content);\n          },\n          imagePathAbsolute: true,\n          imageAccept: \"image/png, image/jpeg, image/gif\",\n          imageMaxSize: \"100000000\",\n          toolbar: [\n            \"bold\",\n            \"italic\",\n            \"link\",\n            \"upload-image\",\n            \"heading\",\n            \"code\",\n            \"strikethrough\",\n            \"quote\",\n            \"table\",\n            {\n              name: \"LaTeX\",\n              className: \"fa fa-math\",\n              title: \"Embed Maths\",\n              action: (editor) => {\n                editor.codemirror.replaceSelection(\"$$\\n$$\")\n              }\n            },\n            \"side-by-side\",\n            \"fullscreen\",\n            {\n              name: \"local-archive-btn\",\n              className: \"fa fa-bookmark\",\n              title: \"Archives and links to local copy of selected url\",\n              action: async editor => {\n                let link = editor.codemirror.getSelection().trim(), url;\n                try {\n                  url = new URL(link);\n                } catch (_) {\n                  return false;\n                }\n                if (url.protocol !== \"http:\" && url.protocol !== \"https:\") {\n                  return false;\n                }\n                let req = await fetch(`${SCRIPT_ROOT}/bookmarks`, {\n                  method: \"POST\",\n                  body: JSON.stringify({\n                    \"url\": link\n                  }),\n                  headers: {\n                    \"content-type\": \"application/json\"\n                  }\n                })\n                if (req.ok) {\n                  let bookmark = await req.json();\n                  editor.codemirror.replaceSelection(`[${link}](/dataobj/${bookmark[\"bookmark_id\"]})\\n`);\n                }\n              }  // action\n            },  // archive-btn\n            {\n              name: \"save\",\n              title: \"Save note contents\",\n              className: \"fa fa-save\",\n              action: (editor) => {\n                fetch(`${SCRIPT_ROOT}/dataobjs/{{dataobj['id']}}`, {\n                  method: \"PUT\",\n                  body: JSON.stringify({\n                    \"content\": editor.value()\n                  }),\n                  headers: {\n                    \"content-type\": \"application/json\"\n                  }\n                })\n                statusBtn.classList.add(\"fa-check-circle\");\n                statusBtn.classList.remove(\"fa-times\");\n                savedContent = editor.value();\n                // update dataobj tags\n                let post_tags = document.querySelector(\".embedded-tags\");\n                let matches = [...savedContent.matchAll(\"(?:^|\\\\n| )#(?:[a-zA-Z0-9_-]+)\\\\w\")];\n                let all_tags = []\n                for (i=0; i < matches.length; i++) {\n                  all_tags.push(matches[i][0].trim())\n                }\n                post_tags.innerHTML = \"\"\n                let uniq_tags = [...new Set(all_tags)];\n                for (i=0; i < uniq_tags.length; i++) {\n                  let new_tag = document.createElement(\"span\")\n                  new_tag.classList.add(\"post-tag\")\n                  new_tag.innerHTML = uniq_tags[i]\n                  post_tags.appendChild(new_tag)\n                }\n              }, // action\n            }, // save-button\n            {\n              name: \"status\",\n              className: \"fa fa-check-circle status\"\n            },\n            {\n              name: \"doc\",\n              className: \"fa fa-question-circle\",\n              action: \"https://archivy.github.io/editing\",\n              title: \"Editing Guide\"\n            }\n          ], // toolbar\n          shortcuts: {\n            \"save\": \"Ctrl-S\"\n          },\n        });  // EasyMDE\n\n        editor.value(`{{ content }}`)\n\n        let statusBtn = document.querySelector(\".status .fa\");\n        editor.codemirror.on(\"change\", function() {\n          statusBtn.classList.remove(\"fa-check-circle\");\n          statusBtn.classList.add(\"fa-times\")\n        })\n        oldContent = document.getElementById(\"content\"), editorDiv = document.querySelector(\".EasyMDEContainer\");\n        editorDiv.classList.add(\"hidden\");\n        document.body.scrollIntoView(true);\n\n        /////////////////////////////////////////////////////////////////\n        //                      Tag and note link autocompletion       //\n        /////////////////////////////////////////////////////////////////\n        // The container, datalist input and CoreMirror instance. \n        let tag_tooltip = document.querySelector(\"#tag_tooltip\");\n        let note_link_tooltip = document.querySelector(\"#note_link_tooltip\")\n        let tag_tooltip_input = document.querySelector(\"#tag_tooltip_input\")\n        let title_tooltip_input = document.querySelector(\"#title_tooltip_input\");\n        let cm = document.getElementsByClassName(\"CodeMirror\")[0].CodeMirror;\n\n        // Put `data` where the cursor is right now\n        function insertText(data) {\n          let doc = cm.getDoc();\n          let cursor = doc.getCursor(); // gets the line number in the cursor position\n          doc.replaceRange(data, cursor);\n        }\n\n        // Add a tag\n        //  1. Put the value of the datalist into the editor\n        //  2. Add to the index\n        function add_tag() {\n          let tag = tag_tooltip_input.value;\n          if (tag[0] != \"#\") {\n            tag = \"#\" + tag;\n          }\n          tagname = tag.slice(1);\n\n          // 1.\n          toggle_tag_tooltip();\n          insertText(tag + \"#\");\n\n          editor.codemirror.focus();\n\n          // 2.\n          let payload = {\n            method: \"PUT\",\n            body: JSON.stringify({\n              \"dataobj_id\": {{dataobj['id']}},\n              \"tag\": tagname\n            }),\n            headers: {\n              \"content-type\": \"application/json\"\n            }\n          };\n          response = fetch(`${SCRIPT_ROOT}/tags/add_to_index`, payload);\n        }\n\n\n        // When toggling the tooltips we want to position it right first.\n        // Otherwise, clear the input and hide it.\n        // initVal is just the value we wanna set the tooltip input to when we display it\n        function toggle_tooltip(tooltip, input, initVal = '') {\n          if (tooltip.classList.contains(\"hidden\")) {\n            let cursor_coordinates = cm.cursorCoords()\n            tooltip.style.zIndex = 9999;\n            tooltip.style.position = \"absolute\";\n            tooltip.style.top = cursor_coordinates.top - cm.defaultTextHeight() + \"px\";\n            tooltip.style.left = cursor_coordinates.left - 10 + \"px\";\n            tooltip.classList.remove(\"hidden\");\n            input.value = initVal;\n            input.focus();\n          } else {\n            tooltip.classList.add(\"hidden\");\n            input.value = \"\";\n            document.activeElement.blur();\n          }\n        }\n        function toggle_tag_tooltip()\n        {\n          toggle_tooltip(tag_tooltip, tag_tooltip_input, \"#\")\n        }\n        function toggle_link_tooltip()\n        {\n          toggle_tooltip(note_link_tooltip, title_tooltip_input, '[[')\n        }\n\n        // Whenever the content of the editor changes:\n        //   Check what the last character is. Is it a `#`?\n        //   Then get rid of the `#` and put it into the tag tooltip and show that.\n        editor.codemirror.on(\"change\", function(ed, change) {\n          let line = ed.doc.getCursor().line, // Cursor line\n          ch = ed.doc.getCursor().ch;\n          let currLine = ed.doc.getLine(line);\n          let currChar = currLine[ch - 1];\n          let is_tag_beginning = (currChar === \"#\" && (ch == 1 || currLine[ch-2] === ' ') && (ch == currLine.length || currLine[ch] === ' '));\n          // checks the user inputted \"[[\" on a line without other text adjacent to it.\n          let is_note_link_beginning = currChar === '[' && ch != 1 && currLine[ch-2] === '[' && (ch == 2 || currLine[ch-3] === ' ') && (ch == currLine.length || currLine[ch] === ' ');\n          if (is_tag_beginning) {\n            ed.doc.replaceRange(\"\", {\n              line: line,\n              ch: ch - 1\n            }, {\n              line: line,\n              ch: ch\n            })\n            toggle_tag_tooltip();\n          }\n          else if (is_note_link_beginning)\n          {\n            ed.doc.replaceRange(\"\", {\n              line: line,\n              ch: ch - 2\n            }, {\n              line: line,\n              ch: ch\n            })\n            toggle_link_tooltip();\n          }\n        });\n\n        // When the user hits enter, add the tag.\n        tag_tooltip.onsubmit = function(e) {\n          e.preventDefault()\n          add_tag();\n        };\n\n\n        note_link_tooltip.onsubmit = function(e) {\n          e.preventDefault();\n          let note_link = title_tooltip_input.value;\n          if (note_link === \"\") return;\n          let currOption = document.querySelector(`option[value=\"${note_link}\"]`)\n          if (!currOption) { return; }\n          let id = currOption.getAttribute(\"data-id\");\n          insertText(note_link);\n          toggle_link_tooltip();\n        }\n\n        // We watch for two cases:\n        //  1. The input is empty => hide the tooltip\n        //  2. The tooltip contains a whitespace. Just put the value into the editor and hide the tooltip.\n        tag_tooltip_input.oninput = function() {\n          tag_tooltip_input.focus();\n          if (tag_tooltip_input.value === \"\" || tag_tooltip_input.value.includes(\" \")) {\n            insertText(tag_tooltip_input.value);\n            toggle_tag_tooltip();\n            editor.codemirror.focus();\n          }\n        }\n\n        title_tooltip_input.oninput = function()\n\t{\n\t  title_tooltip_input.focus();\n\t  if (!title_tooltip_input.value.startsWith(\"[[\"))\n\t  {\n\t    toggle_link_tooltip();\n\t    insertText(title_tooltip_input.value)\n\t    editor.codemirror.focus();\n          }\n        }\n\n        /////////////////////////////////////////////////////////////////\n        //                      Screenreader stuff                     //\n        /////////////////////////////////////////////////////////////////\n        /* Screenreader mode checkbox */\n        function toggleScreenReaderMode(cbox, editor)\n        {\n          return function () {\n            if (cbox.checked) {\n              editor.toTextArea();\n              editor = null;\n            } else {\n              location.reload();\n            }\n          }\n        }\n\n        /* Add screenreader checkbox toggle */\n        let srCbox = document.getElementById(\"sr-checkbox\");\n        srCbox.onchange = toggleScreenReaderMode(srCbox, editor);\n\n        /* Screenreader save button handler */\n        function screenReaderSave(btn) {\n          fetch(`${SCRIPT_ROOT}/dataobjs/{{dataobj['id']}}`, {\n            method: \"PUT\",\n            body: JSON.stringify({\n              \"content\": document.getElementById(\"original-textarea\").value\n            }),\n            headers: {\n              \"content-type\": \"application/json\"\n            }\n          });\n          let saveAlert = document.createElement(\"span\");\n          saveAlert.setAttribute(\"role\", \"alert\");\n          let saveAlertText = document.createTextNode(\"Note saved\");\n          saveAlert.appendChild(saveAlertText);\n          document.body.appendChild(saveAlert);\n        }  // function screenReaderSave\n\n        /* Add screenreader save button handler */\n        let srSaveBtn = document.getElementById(\"sr-savebutton\");\n        srSaveBtn.onclick = screenReaderSave;\n      })  // window.addEventListener(\"load\")\n\n\n\n      function toggleEditor(btn) {\n        let btnText = btn.querySelector(\"span\");\n        if (btnText.textContent == \"Edit\") {\n          btnText.textContent = \"Hide Editor\";\n        } else {\n          btnText.textContent = \"Edit\";\n          contentDiv.innerHTML = renderContent(savedContent);\n        }\n        oldContent.classList.toggle(\"hidden\"), editorDiv.classList.toggle(\"hidden\");\n      }\n\n      // render backlinks\n\n      document.querySelectorAll(\".backlink-markdown\").forEach((link) => {\n        link.innerHTML = window.parser.customRender(`> ${link.innerHTML}`);\n      })\n    {% endif %}\n  </script>\n{% endblock %}\n", "import os\nimport re\n\nfrom flask.testing import FlaskClient\nfrom flask import request\nfrom flask_login import current_user\nfrom responses import RequestsMock, GET\nfrom werkzeug.security import generate_password_hash\n\nfrom archivy.helpers import get_max_id, get_db\nfrom archivy.data import get_dirs, create_dir, get_items, get_item\n\n\ndef test_get_index(test_app, client: FlaskClient):\n    response = client.get(\"/\")\n    assert response.status_code == 200\n\n\ndef test_get_custom_css(test_app, client: FlaskClient):\n    test_app.config[\"THEME_CONF\"][\"use_custom_css\"] = True\n    css_file = \"custom.css\"\n    css_contents = \"\"\"\n        body {\n            color: red\n        }\n    \"\"\"\n\n    os.mkdir(f\"{test_app.config['USER_DIR']}/css/\")\n    with open(f\"{test_app.config['USER_DIR']}/css/{css_file}\", \"w\") as f:\n        f.write(css_contents)\n    test_app.config[\"THEME_CONF\"][\"custom_css_file\"] = css_file\n    resp = client.get(\"/static/custom.css\")\n    assert css_contents.encode(\"utf-8\") in resp.data\n    test_app.config[\"THEME_CONF\"][\"use_custom_css\"] = False\n\n\ndef test_get_new_bookmark(test_app, client: FlaskClient):\n    response = client.get(\"/bookmarks/new\")\n    assert response.status_code == 200\n\n\ndef test_post_new_bookmark_missing_fields(test_app, client: FlaskClient):\n    response = client.post(\"/bookmarks/new\", data={\"submit\": True})\n    assert response.status_code == 200\n    assert b\"This field is required\" in response.data\n\n\ndef test_get_new_note(test_app, client: FlaskClient):\n    response = client.get(\"/notes/new\")\n    assert response.status_code == 200\n\n\ndef test_get_dataobj_not_found(test_app, client: FlaskClient):\n    response = client.get(\"/dataobj/1\")\n    assert response.status_code == 302\n\n\ndef test_get_dataobj(test_app, client: FlaskClient, note_fixture):\n    response = client.get(\"/dataobj/1\")\n    assert response.status_code == 200\n\n\ndef test_get_delete_dataobj_not_found(test_app, client: FlaskClient):\n    response = client.get(\"/dataobj/delete/1\")\n    assert response.status_code == 302\n\n\ndef test_get_delete_dataobj(test_app, client: FlaskClient, note_fixture):\n    response = client.get(\"/dataobj/delete/1\")\n    assert response.status_code == 302\n\n\ndef test_create_new_bookmark(\n    test_app, client: FlaskClient, mocked_responses: RequestsMock\n):\n    mocked_responses.add(\n        GET,\n        \"https://example.com/\",\n        body=\"\"\"<html>\n        <head><title>Random</title></head><body><p>\n            Lorem ipsum dolor sit amet, consectetur adipiscing elit\n        </p></body></html>\n    \"\"\",\n    )\n\n    bookmark_data = {\n        \"url\": \"https://example.com\",\n        \"tags\": \"testing,bookmark\",\n        \"path\": \"\",\n        \"submit\": \"true\",\n    }\n\n    resp = client.post(\"/bookmarks/new\", data=bookmark_data)\n    assert resp.status_code == 302\n    assert not b\"invalid\" in resp.data\n\n    resp = client.post(\"/bookmarks/new\", data=bookmark_data, follow_redirects=True)\n    assert resp.status_code == 200\n    assert b'<span class=\"post-tag\">bookmark</span>' in resp.data\n    assert b'<span class=\"post-tag\">testing</span>' in resp.data\n    assert b\"https://example.com\" in resp.data\n    assert b\"Random\" in resp.data\n\n\ndef test_creating_bookmark_without_passing_path_saves_to_default_dir(\n    test_app, client, mocked_responses\n):\n    mocked_responses.add(GET, \"http://example.org\", body=\"Example\\n\")\n    bookmarks_dir = \"bookmarks\"\n    test_app.config[\"DEFAULT_BOOKMARKS_DIR\"] = bookmarks_dir\n    create_dir(bookmarks_dir)\n    resp = client.post(\n        \"/bookmarks/new\",\n        data={\n            \"url\": \"http://example.org\",\n            \"submit\": \"true\",\n        },\n    )\n    bookmark = get_items(structured=False)[0]\n    assert (\n        \"bookmarks\" in bookmark[\"path\"]\n    )  # verify it was saved to default bookmark dir\n\n\ndef test_create_note(test_app, client: FlaskClient):\n\n    note_data = {\n        \"title\": \"Testing the create route\",\n        \"tags\": \"testing,note\",\n        \"path\": \"\",\n        \"submit\": \"true\",\n    }\n\n    resp = client.post(\"/notes/new\", data=note_data)\n    assert resp.status_code == 302\n    assert not b\"invalid\" in resp.data\n\n    resp = client.post(\"/notes/new\", data=note_data, follow_redirects=True)\n    assert resp.status_code == 200\n    assert b'<span class=\"post-tag\">note</span>' in resp.data\n    assert b'<span class=\"post-tag\">testing</span>' in resp.data\n    assert b\"Testing the create route\" in resp.data\n\n\ndef test_logging_in(test_app, client: FlaskClient):\n    resp = client.post(\n        \"/login\",\n        data={\"username\": \"halcyon\", \"password\": \"password\"},\n        follow_redirects=True,\n    )\n    assert resp.status_code == 200\n    assert request.path == \"/\"\n    assert current_user\n\n\ndef test_logging_in_with_invalid_creds(test_app, client: FlaskClient):\n    resp = client.post(\n        \"/login\",\n        data={\"username\": \"invalid\", \"password\": \"dasdasd\"},\n        follow_redirects=True,\n    )\n    assert resp.status_code == 200\n    assert request.path == \"/login\"\n    assert b\"Invalid credentials\" in resp.data\n\n\ndef test_edit_user(test_app, client: FlaskClient):\n    \"\"\"Tests editing a user's info, logging out and then logging in with new info.\"\"\"\n\n    new_user = \"new_halcyon\"\n    new_pass = \"password2\"\n    resp = client.post(\n        \"/user/edit\",\n        data={\"username\": new_user, \"password\": new_pass},\n        follow_redirects=True,\n    )\n\n    assert request.path == \"/\"\n\n    client.delete(\"/logout\")\n\n    resp = client.post(\n        \"/login\",\n        data={\"username\": new_user, \"password\": new_pass},\n        follow_redirects=True,\n    )\n    assert resp.status_code == 200\n    assert request.path == \"/\"\n    # check information has updated.\n\n\ndef test_logging_out(test_app, client: FlaskClient):\n    \"\"\"Tests logging out and then accessing restricted views\"\"\"\n\n    client.delete(\"/logout\")\n\n    resp = client.get(\"/\", follow_redirects=True)\n    assert request.path == \"/login\"\n\n\ndef test_create_dir(test_app, client: FlaskClient):\n    \"\"\"Tests /folders/create endpoint\"\"\"\n\n    resp = client.post(\n        \"/folders/create\",\n        data={\"parent_dir\": \"\", \"new_dir\": \"testing\"},\n        follow_redirects=True,\n    )\n\n    assert resp.status_code == 200\n    assert request.args.get(\"path\") == \"testing\"\n    assert \"testing\" in get_dirs()\n    assert b\"Folder successfully created\" in resp.data\n\n\ndef test_creating_without_dirname_fails(test_app, client: FlaskClient):\n    resp = client.post(\n        \"/folders/create\", data={\"parent_dir\": \"\"}, follow_redirects=True\n    )\n\n    assert resp.status_code == 200\n    assert request.path == \"/\"\n    assert b\"Could not create folder.\" in resp.data\n\n\ndef test_visiting_nonexistent_dir_fails(test_app, client: FlaskClient):\n    resp = client.get(\"/?path=nonexistent_dir\", follow_redirects=True)\n    assert b\"Directory does not exist.\" in resp.data\n\n\ndef test_deleting_dir(test_app, client: FlaskClient):\n    create_dir(\"testing\")\n    assert \"testing\" in get_dirs()\n    resp = client.post(\n        \"/folders/delete\", data={\"dir_name\": \"testing\"}, follow_redirects=True\n    )\n    assert not \"testing\" in get_dirs()\n    assert b\"Folder successfully deleted.\" in resp.data\n\n\ndef test_deleting_nonexisting_folder_fails(test_app, client: FlaskClient):\n    resp = client.post(\"/folders/delete\", data={\"dir_name\": \"testing\"})\n    assert resp.status_code == 404\n\n\ndef test_bookmarklet(test_app, client: FlaskClient):\n    resp = client.get(\"/bookmarklet\")\n    assert resp.status_code == 200\n\n\ndef test_backlinks_are_saved(\n    test_app, client: FlaskClient, note_fixture, bookmark_fixture\n):\n    test_app.config[\"SEARCH_CONF\"][\"enabled\"] = 1\n    test_app.config[\"SEARCH_CONF\"][\"engine\"] = \"ripgrep\"\n\n    resp = client.put(\n        f\"/api/dataobjs/{note_fixture.id}\",\n        json={\"content\": f\"[[{bookmark_fixture.title}|{bookmark_fixture.id}]]\"},\n    )\n    assert resp.status_code == 200\n\n    resp = client.get(f\"/dataobj/{bookmark_fixture.id}\")\n    assert b\"Backlinks\" in resp.data  # backlink was detected\n    test_app.config[\"SEARCH_CONF\"][\"enabled\"] = 0\n\n\ndef test_bookmark_with_long_title_gets_truncated(test_app, client, mocked_responses):\n\n    long_title = \"a\" * 300\n    # check that our mock title is indeed longer than the limit\n    # and would cause an error, without our truncating\n    assert os.pathconf(\"/\", \"PC_NAME_MAX\") < len(long_title)\n    mocked_responses.add(GET, \"https://example.com\", f\"<title>{long_title}</title>\")\n    bookmark_data = {\n        \"url\": \"https://example.com\",\n        \"submit\": \"true\",\n    }\n\n    resp = client.post(\"/bookmarks/new\", data=bookmark_data)\n    assert resp.status_code == 200\n\n\ndef test_move_data(test_app, note_fixture, client):\n    create_dir(\"random\")\n\n    resp = client.post(\n        \"/dataobj/move/1\",\n        data={\"path\": \"random\", \"submit\": \"true\"},\n        follow_redirects=True,\n    )\n    assert resp.status_code == 200\n    assert b\"Data successfully moved to random.\" in resp.data\n\n    assert get_item(1)[\"dir\"] == \"random\"\n\n\ndef test_invalid_inputs_fail_move_data(test_app, note_fixture, client):\n\n    resp = client.post(\"/dataobj/move/1\", follow_redirects=True)\n    assert b\"No path specified.\" in resp.data\n\n    resp = client.post(\n        \"/dataobj/move/2\", data={\"path\": \"aaa\", \"submit\": \"true\"}, follow_redirects=True\n    )\n    assert b\"Data not found\" in resp.data\n\n    resp = client.post(\n        \"/dataobj/move/1\", data={\"path\": \"\", \"submit\": \"true\"}, follow_redirects=True\n    )\n    assert b\"Data already in target directory\" in resp.data\n\n    faulty_paths = [\"../adarnad\", \"~/adasd\", \"ssss\"]\n    for p in faulty_paths:\n        resp = client.post(\n            \"/dataobj/move/1\", data={\"path\": p, \"submit\": \"true\"}, follow_redirects=True\n        )\n        assert b\"Data could not be moved to \" + bytes(p, \"utf-8\") in resp.data\n\n\ndef test_rename_dir(test_app, client):\n    create_dir(\"random\")\n\n    resp = client.post(\n        \"/folders/rename\",\n        data={\"current_path\": \"random\", \"new_name\": \"renamed_random\"},\n        follow_redirects=True,\n    )\n    assert resp.status_code == 200\n    assert b\"Renamed successfully\" in resp.data\n\n\ndef test_invalid_inputs_fail_renaming(test_app, client):\n    create_dir(\"random\")\n    create_dir(\"random2\")\n    resp = client.post(\n        \"/folders/rename\",\n        data={\"current_path\": \"inexisting\", \"new_name\": \"random3\"},\n        follow_redirects=True,\n    )\n    assert b\"Directory not found\" in resp.data\n\n    resp = client.post(\n        \"/folders/rename\",\n        data={\"current_path\": \"random\", \"new_name\": \"random2\"},\n        follow_redirects=True,\n    )\n    assert b\"Target directory exists.\" in resp.data\n\n    faulty_paths = [\"../adarnad\", \"~/adasd\", \"/illegal_dir\", \".\"]\n    for p in faulty_paths:\n        print(p)\n        resp = client.post(\n            \"/folders/rename\",\n            data={\"current_path\": \"random\", \"new_name\": p},\n            follow_redirects=True,\n        )\n        assert b\"Invalid input\" in resp.data\n\n\ndef test_get_config_page(test_app, client):\n    resp = client.get(\"/config\")\n    assert resp.status_code == 200\n    assert b\"Edit Config\" in resp.data\n\n\ndef test_post_updated_config(test_app, client):\n    # use dark theme as random conf value to change\n    dark_theme = test_app.config[\"THEME_CONF\"][\"use_theme_dark\"]\n\n    resp = client.post(\n        \"/config\", data={\"submit\": True, \"THEME_CONF-use_theme_dark\": not dark_theme}\n    )\n    assert test_app.config[\"THEME_CONF\"][\"use_theme_dark\"] == (not dark_theme)\n\n\ndef test_getting_all_tags(test_app, client, bookmark_fixture):\n    # bookmark fixture has embedded tags\n    resp = client.get(\"/tags\")\n    bookmark_tags = [\"embedded-tag\", \"tag2\"]\n    assert resp.status_code == 200\n    for tag in bookmark_tags:\n        assert f\"#{tag}\" in str(resp.data)\n\n\ndef test_getting_matches_for_specific_tag(test_app, client, bookmark_fixture):\n    resp = client.get(\"/tags/tag2\")\n    assert resp.status_code == 200\n    assert bookmark_fixture.title in str(resp.data)\n    assert str(bookmark_fixture.id) in str(resp.data)\n"], "fixing_code": ["import logging\nfrom pathlib import Path\nfrom shutil import which\n\nfrom elasticsearch.exceptions import RequestError\nfrom flask import Flask\nfrom flask_compress import Compress\nfrom flask_login import LoginManager\nfrom flask_wtf.csrf import CSRFProtect\n\nfrom archivy import helpers\nfrom archivy.api import api_bp\nfrom archivy.models import User\nfrom archivy.config import Config\nfrom archivy.helpers import load_config, get_elastic_client\n\napp = Flask(__name__)\napp.logger.setLevel(logging.INFO)\nconfig = Config()\ntry:\n    # if it exists, load user config\n    config.override(load_config(config.INTERNAL_DIR))\nexcept FileNotFoundError:\n    pass\n\napp.config.from_object(config)\n(Path(app.config[\"USER_DIR\"]) / \"data\").mkdir(parents=True, exist_ok=True)\n(Path(app.config[\"USER_DIR\"]) / \"images\").mkdir(parents=True, exist_ok=True)\n\nwith app.app_context():\n    app.config[\"RG_INSTALLED\"] = which(\"rg\") != None\n    app.config[\"HOOKS\"] = helpers.load_hooks()\n    app.config[\"SCRAPING_PATTERNS\"] = helpers.load_scraper()\nif app.config[\"SEARCH_CONF\"][\"enabled\"]:\n    with app.app_context():\n        search_engines = [\"elasticsearch\", \"ripgrep\"]\n        es = None\n        if (\n            \"engine\" not in app.config[\"SEARCH_CONF\"]\n            or app.config[\"SEARCH_CONF\"][\"engine\"] not in search_engines\n        ):\n            # try to guess desired search engine if present\n            app.logger.warning(\n                \"Search is enabled but engine option is invalid or absent. Archivy will\"\n                \" try to guess preferred search engine.\"\n            )\n            app.config[\"SEARCH_CONF\"][\"engine\"] = \"none\"\n\n            es = get_elastic_client(error_if_invalid=False)\n            if es:\n                app.config[\"SEARCH_CONF\"][\"engine\"] = \"elasticsearch\"\n            else:\n                if which(\"rg\"):\n                    app.config[\"SEARCH_CONF\"][\"engine\"] = \"ripgrep\"\n            engine = app.config[\"SEARCH_CONF\"][\"engine\"]\n            if engine == \"none\":\n                app.logger.warning(\"No working search engine found. Disabling search.\")\n                app.config[\"SEARCH_CONF\"][\"enabled\"] = 0\n            else:\n                app.logger.info(f\"Running {engine} installation found.\")\n\n        if app.config[\"SEARCH_CONF\"][\"engine\"] == \"elasticsearch\":\n            es = es or get_elastic_client()\n            try:\n                es.indices.create(\n                    index=app.config[\"SEARCH_CONF\"][\"index_name\"],\n                    body=app.config[\"SEARCH_CONF\"][\"es_processing_conf\"],\n                )\n            except RequestError:\n                app.logger.info(\"Elasticsearch index already created\")\n        if app.config[\"SEARCH_CONF\"][\"engine\"] == \"ripgrep\" and not which(\"rg\"):\n            app.logger.info(\"Ripgrep not found on system. Disabling search.\")\n            app.config[\"SEARCH_CONF\"][\"enabled\"] = 0\n\n\n# login routes / setup\nlogin_manager = LoginManager()\nlogin_manager.login_view = \"login\"\nlogin_manager.init_app(app)\napp.register_blueprint(api_bp, url_prefix=\"/api\")\ncsrf = CSRFProtect(app)\n\n# compress files\nCompress(app)\n\n\n@login_manager.user_loader\ndef load_user(user_id):\n    db = helpers.get_db()\n    res = db.get(doc_id=int(user_id))\n    if res and res[\"type\"] == \"user\":\n        return User.from_db(res)\n    return None\n\n\napp.jinja_options[\"extensions\"].append(\"jinja2.ext.do\")\n\n\n@app.template_filter(\"pluralize\")\ndef pluralize(number, singular=\"\", plural=\"s\"):\n    if number == 1:\n        return singular\n    else:\n        return plural\n\n\nfrom archivy import routes  # noqa:\n", "import os\r\nimport shutil\r\nimport subprocess\r\nimport sys\r\nimport tempfile\r\nimport traceback\r\nfrom pathlib import Path\r\nfrom typing import List\r\n\r\nfrom flask import Response, request\r\nfrom werkzeug.utils import secure_filename\r\n\r\nfrom archivy import click_web\r\n\r\nfrom .input_fields import FieldId\r\n\r\nlogger = None\r\n\r\n\r\ndef exec(command_path):\r\n    \"\"\"\r\n    Execute the command and stream the output from it as response\r\n    :param command_path:\r\n    \"\"\"\r\n    command_path = \"cli/\" + command_path\r\n    global logger\r\n    logger = click_web.logger\r\n\r\n    omitted = [\"shell\", \"run\", \"routes\", \"create-admin\"]\r\n    root_command, *commands = command_path.split(\"/\")\r\n    cmd = [\"archivy\"]\r\n    req_to_args = RequestToCommandArgs()\r\n    # root command_index should not add a command\r\n    cmd.extend(req_to_args.command_args(0))\r\n    for i, command in enumerate(commands):\r\n        if command in omitted:\r\n            return Response(status=400)\r\n        cmd.append(command)\r\n        cmd.extend(req_to_args.command_args(i + 1))\r\n\r\n    def _generate_output():\r\n        yield _create_cmd_header(commands)\r\n        try:\r\n            yield from _run_script_and_generate_stream(req_to_args, cmd)\r\n        except Exception as e:\r\n            # exited prematurely, show the error to user\r\n            yield f\"\\nERROR: Got exception when reading output from script: {type(e)}\\n\"\r\n            yield traceback.format_exc()\r\n            raise\r\n\r\n    return Response(_generate_output(), mimetype=\"text/plain\")\r\n\r\n\r\ndef _run_script_and_generate_stream(\r\n    req_to_args: \"RequestToCommandArgs\", cmd: List[str]\r\n):\r\n    \"\"\"\r\n    Execute the command the via Popen and yield output\r\n    \"\"\"\r\n    logger.info(\"Executing archivy command\")\r\n    if not os.environ.get(\"PYTHONIOENCODING\"):\r\n        # Fix unicode on windows\r\n        os.environ[\"PYTHONIOENCODING\"] = \"UTF-8\"\r\n\r\n    process = subprocess.Popen(\r\n        cmd, shell=False, stdout=subprocess.PIPE, stderr=subprocess.STDOUT\r\n    )\r\n    logger.info(\"script running Pid: %d\", process.pid)\r\n\r\n    encoding = sys.getdefaultencoding()\r\n    with process.stdout:\r\n        for line in iter(process.stdout.readline, b\"\"):\r\n            yield line.decode(encoding)\r\n\r\n    process.wait()  # wait for the subprocess to exit\r\n    logger.info(\"script finished Pid: %d\", process.pid)\r\n    for fi in req_to_args.field_infos:\r\n        fi.after_script_executed()\r\n\r\n\r\ndef _create_cmd_header(commands: List[str]):\r\n    \"\"\"\r\n    Generate a command header.\r\n    Note:\r\n        here we always allow to generate HTML as long as we have it between CLICK-WEB comments.\r\n        This way the JS frontend can insert it in the correct place in the DOM.\r\n    \"\"\"\r\n\r\n    def generate():\r\n        yield \"<!-- CLICK_WEB START HEADER -->\"\r\n        yield '<div class=\"command-line\">Executing: {}</div>'.format(\"/\".join(commands))\r\n        yield \"<!-- CLICK_WEB END HEADER -->\"\r\n\r\n    # important yield this block as one string so it pushed to client in one go.\r\n    # so the whole block can be treated as html.\r\n    html_str = \"\\n\".join(generate())\r\n    return html_str\r\n\r\n\r\ndef _create_result_footer(req_to_args: \"RequestToCommandArgs\"):\r\n    \"\"\"\r\n    Generate a footer.\r\n    Note:\r\n        here we always allow to generate HTML as long as we have it between CLICK-WEB comments.\r\n        This way the JS frontend can insert it in the correct place in the DOM.\r\n    \"\"\"\r\n    to_download = [\r\n        fi\r\n        for fi in req_to_args.field_infos\r\n        if fi.generate_download_link and fi.link_name\r\n    ]\r\n    # important yield this block as one string so it pushed to client in one go.\r\n    # This is so the whole block can be treated as html if JS frontend.\r\n    lines = []\r\n    lines.append(\"<!-- CLICK_WEB START FOOTER -->\")\r\n    if to_download:\r\n        lines.append(\"<b>Result files:</b><br>\")\r\n        for fi in to_download:\r\n            lines.append(\"<ul> \")\r\n            lines.append(f\"<li>{_get_download_link(fi)}<br>\")\r\n            lines.append(\"</ul>\")\r\n\r\n    else:\r\n        lines.append(\"<b>DONE</b>\")\r\n    lines.append(\"<!-- CLICK_WEB END FOOTER -->\")\r\n    html_str = \"\\n\".join(lines)\r\n    yield html_str\r\n\r\n\r\ndef _get_download_link(field_info):\r\n    \"\"\"Hack as url_for need request context\"\"\"\r\n\r\n    rel_file_path = Path(field_info.file_path).relative_to(click_web.OUTPUT_FOLDER)\r\n    uri = f\"/static/results/{rel_file_path.as_posix()}\"\r\n    return f'<a href=\"{uri}\">{field_info.link_name}</a>'\r\n\r\n\r\nclass RequestToCommandArgs:\r\n    def __init__(self):\r\n        keys = [key for key in list(request.form.keys()) + list(request.files.keys())]\r\n        field_infos = [FieldInfo.factory(key) for key in keys if key != \"csrf_token\"]\r\n        # important to sort them so they will be in expected order on command line\r\n        self.field_infos = list(sorted(field_infos))\r\n\r\n    def command_args(self, command_index) -> List[str]:\r\n        \"\"\"\r\n        Convert the post request into a list of command line arguments\r\n\r\n        :param command_index: (int) the index for the command to get arguments for.\r\n        :return: list of command line arguments for command at that cmd_index\r\n        \"\"\"\r\n        args = []\r\n\r\n        # only include relevant fields for this command index\r\n        commands_field_infos = [\r\n            fi for fi in self.field_infos if fi.param.command_index == command_index\r\n        ]\r\n        commands_field_infos = sorted(commands_field_infos)\r\n\r\n        for fi in commands_field_infos:\r\n\r\n            # must be called mostly for saving and preparing file output.\r\n            fi.before_script_execute()\r\n\r\n            if fi.cmd_opt.startswith(\"--\"):\r\n                # it's an option\r\n                args.extend(self._process_option(fi))\r\n\r\n            else:\r\n                # argument(s)\r\n                if isinstance(fi, FieldFileInfo):\r\n                    # it's a file, append the written temp file path\r\n                    # TODO: does file upload support multiple keys? In that case support it.\r\n                    args.append(fi.file_path)\r\n                else:\r\n                    arg_values = request.form.getlist(fi.key)\r\n                    has_values = bool(\"\".join(arg_values))\r\n                    if has_values:\r\n                        if fi.param.nargs == -1:\r\n                            # Variadic argument, in html form each argument\r\n                            # is a separate line in a textarea.\r\n                            # treat each line we get from text area as a separate argument.\r\n                            for value in arg_values:\r\n                                values = value.splitlines()\r\n                                logger.info(\r\n                                    f'variadic arguments, split into: \"{values}\"'\r\n                                )\r\n                                args.extend(values)\r\n                        else:\r\n                            logger.info(f'arg_value: \"{arg_values}\"')\r\n                            args.extend(arg_values)\r\n        return args\r\n\r\n    def _process_option(self, field_info):\r\n        vals = request.form.getlist(field_info.key)\r\n        if field_info.is_file:\r\n            if field_info.link_name:\r\n                # it's a file, append the file path\r\n                yield field_info.cmd_opt\r\n                yield field_info.file_path\r\n        elif field_info.param.param_type == \"flag\":\r\n            # To work with flag that is default True\r\n            # a hidden field with same name is also sent by form.\r\n            # This is to detect if checkbox was not checked as then\r\n            # we will get the field anyway with the \"off flag\" as value.\r\n            if len(vals) == 1:\r\n                off_flag = vals[0]\r\n                flag_on_cmd_line = off_flag\r\n            else:\r\n                # we got both off and on flags, checkbox is checked.\r\n                on_flag = vals[1]\r\n                flag_on_cmd_line = on_flag\r\n\r\n            yield flag_on_cmd_line\r\n        elif \"\".join(vals):\r\n            # opt with value, if option was given multiple times get the values for each.\r\n            # flag options should always be set if we get them\r\n            # for normal options they must have a non empty value\r\n            yield field_info.cmd_opt\r\n            for val in vals:\r\n                if val:\r\n                    yield val\r\n        else:\r\n            # option with empty values, should not be added to command line.\r\n            pass\r\n\r\n\r\nclass FieldInfo:\r\n    \"\"\"\r\n    Extract information from the encoded form input field name\r\n    the parts:\r\n        [command_index].[opt_or_arg_index].[click_type].[html_input_type].[opt_or_arg_name]\r\n    e.g.\r\n        \"0.0.option.text.text.--an-option\"\r\n        \"0.1.argument.file[rb].text.an-argument\"\r\n    \"\"\"\r\n\r\n    @staticmethod\r\n    def factory(key):\r\n        field_id = FieldId.from_string(key)\r\n        is_file = field_id.click_type.startswith(\"file\")\r\n        is_path = field_id.click_type.startswith(\"path\")\r\n        is_uploaded = key in request.files\r\n        if is_file:\r\n            if is_uploaded:\r\n                field_info = FieldFileInfo(field_id)\r\n            else:\r\n                field_info = FieldOutFileInfo(field_id)\r\n        elif is_path:\r\n            if is_uploaded:\r\n                field_info = FieldPathInfo(field_id)\r\n            else:\r\n                field_info = FieldPathOutInfo(field_id)\r\n        else:\r\n            field_info = FieldInfo(field_id)\r\n        return field_info\r\n\r\n    def __init__(self, param: FieldId):\r\n        self.param = param\r\n        self.key = param.key\r\n\r\n        \"Type of option (file, text)\"\r\n        self.is_file = self.param.click_type.startswith(\"file\")\r\n\r\n        \"The actual command line option (--debug)\"\r\n        self.cmd_opt = param.name\r\n\r\n        self.generate_download_link = False\r\n\r\n    def before_script_execute(self):\r\n        pass\r\n\r\n    def after_script_executed(self):\r\n        pass\r\n\r\n    def __str__(self):\r\n        return str(self.param)\r\n\r\n    def __lt__(self, other):\r\n        \"Make class sortable\"\r\n        return (self.param.command_index, self.param.param_index) < (\r\n            other.param.command_index,\r\n            other.param.param_index,\r\n        )\r\n\r\n    def __eq__(self, other):\r\n        return self.key == other.key\r\n\r\n\r\nclass FieldFileInfo(FieldInfo):\r\n    \"\"\"\r\n    Use for processing input fields of file type.\r\n    Saves the posted data to a temp file.\r\n    \"\"\"\r\n\r\n    \"temp dir is on class in order to be uniqe for each request\"\r\n    _temp_dir = None\r\n\r\n    def __init__(self, fimeta):\r\n        super().__init__(fimeta)\r\n        # Extract the file mode that is in the type e.g file[rw]\r\n        self.mode = self.param.click_type.split(\"[\")[1][:-1]\r\n        self.generate_download_link = True if \"w\" in self.mode else False\r\n        self.link_name = f\"{self.cmd_opt}.out\"\r\n\r\n        logger.info(f\"File mode for {self.key} is {self.mode}\")\r\n\r\n    def before_script_execute(self):\r\n        self.save()\r\n\r\n    @classmethod\r\n    def temp_dir(cls):\r\n        if not cls._temp_dir:\r\n            cls._temp_dir = tempfile.mkdtemp(dir=click_web.OUTPUT_FOLDER)\r\n        logger.info(f\"Temp dir: {cls._temp_dir}\")\r\n        return cls._temp_dir\r\n\r\n    def save(self):\r\n        logger.info(\"Saving...\")\r\n\r\n        logger.info(\"field value is a file! %s\", self.key)\r\n        file = request.files[self.key]\r\n        # if user does not select file, browser also\r\n        # submit a empty part without filename\r\n        if file.filename == \"\":\r\n            raise ValueError(\"No selected file\")\r\n        elif file and file.filename:\r\n            filename = secure_filename(file.filename)\r\n            name, suffix = os.path.splitext(filename)\r\n\r\n            fd, filename = tempfile.mkstemp(\r\n                dir=self.temp_dir(), prefix=name, suffix=suffix\r\n            )\r\n            self.file_path = filename\r\n            logger.info(f\"Saving {self.key} to {filename}\")\r\n            file.save(filename)\r\n\r\n    def __str__(self):\r\n\r\n        res = [super().__str__()]\r\n        res.append(f\"file_path: {self.file_path}\")\r\n        return \", \".join(res)\r\n\r\n\r\nclass FieldOutFileInfo(FieldFileInfo):\r\n    \"\"\"\r\n    Used when file option is just for output and form posted it as hidden or text field.\r\n    Just create a empty temp file to give it's path to command.\r\n    \"\"\"\r\n\r\n    def __init__(self, fimeta):\r\n        super().__init__(fimeta)\r\n        if self.param.form_type == \"text\":\r\n            self.link_name = request.form[self.key]\r\n            # set the postfix to name name provided from form\r\n            # this way it will at least have the same extension when downloaded\r\n            self.file_suffix = request.form[self.key]\r\n        else:\r\n            # hidden no preferred file name can be provided by user\r\n            self.file_suffix = \".out\"\r\n\r\n    def save(self):\r\n        name = secure_filename(self.key)\r\n\r\n        filename = tempfile.mkstemp(\r\n            dir=self.temp_dir(), prefix=name, suffix=self.file_suffix\r\n        )\r\n        logger.info(f\"Creating empty file for {self.key} as {filename}\")\r\n        self.file_path = filename\r\n\r\n\r\nclass FieldPathInfo(FieldFileInfo):\r\n    \"\"\"\r\n    Use for processing input fields of path type.\r\n    Extracts the posted data to a temp folder.\r\n    When script finished zip that folder and provide download link to zip file.\r\n    \"\"\"\r\n\r\n    def save(self):\r\n        super().save()\r\n        zip_extract_dir = tempfile.mkdtemp(dir=self.temp_dir())\r\n\r\n        logger.info(f\"Extracting: {self.file_path} to {zip_extract_dir}\")\r\n        shutil.unpack_archive(self.file_path, zip_extract_dir, \"zip\")\r\n        self.file_path = zip_extract_dir\r\n\r\n    def after_script_executed(self):\r\n        super().after_script_executed()\r\n        fd, filename = tempfile.mkstemp(dir=self.temp_dir(), prefix=self.key)\r\n        folder_path = self.file_path\r\n        self.file_path = filename\r\n\r\n        logger.info(f\"Zipping {self.key} to {filename}\")\r\n        self.file_path = shutil.make_archive(self.file_path, \"zip\", folder_path)\r\n        logger.info(f\"Zip file created {self.file_path}\")\r\n        self.generate_download_link = True\r\n\r\n\r\nclass FieldPathOutInfo(FieldOutFileInfo):\r\n    \"\"\"\r\n    Use for processing output fields of path type.\r\n    Create a folder and use as path to script.\r\n    When script finished zip that folder and provide download link to zip file.\r\n    \"\"\"\r\n\r\n    def save(self):\r\n        super().save()\r\n        self.file_path = tempfile.mkdtemp(dir=self.temp_dir())\r\n\r\n    def after_script_executed(self):\r\n        super().after_script_executed()\r\n        fd, filename = tempfile.mkstemp(dir=self.temp_dir(), prefix=self.key)\r\n        folder_path = self.file_path\r\n        self.file_path = filename\r\n        logger.info(f\"Zipping {self.key} to {filename}\")\r\n        self.file_path = shutil.make_archive(self.file_path, \"zip\", folder_path)\r\n        logger.info(f\"Zip file created {self.file_path}\")\r\n        self.generate_download_link = True\r\n", "from pathlib import Path\nfrom os.path import sep\nfrom pkg_resources import require\nfrom shutil import which\n\nimport frontmatter\nfrom flask import (\n    render_template,\n    flash,\n    redirect,\n    request,\n    url_for,\n    send_file,\n    send_from_directory,\n)\nfrom flask_login import login_user, current_user, logout_user\nfrom tinydb import Query\nfrom werkzeug.security import check_password_hash, generate_password_hash\n\nfrom archivy.models import DataObj, User\nfrom archivy import data, app, forms\nfrom archivy.helpers import get_db, write_config\nfrom archivy.tags import get_all_tags\nfrom archivy.search import search\nfrom archivy.config import Config\n\nimport re\n\n\n@app.context_processor\ndef pass_defaults():\n    dataobjs = data.get_items(load_content=False)\n    version = require(\"archivy\")[0].version\n    SEP = sep\n    # check windows parsing for js (https://github.com/Uzay-G/archivy/issues/115)\n    if SEP == \"\\\\\":\n        SEP += \"\\\\\"\n    return dict(dataobjs=dataobjs, SEP=SEP, version=version)\n\n\n@app.before_request\ndef check_perms():\n    allowed_path = (\n        request.path.startswith(\"/login\")\n        or request.path.startswith(\"/static\")\n        or request.path.startswith(\"/api/login\")\n    )\n    if not current_user.is_authenticated and not allowed_path:\n        return redirect(url_for(\"login\", next=request.path))\n    return\n\n\n@app.route(\"/\")\n@app.route(\"/index\")\ndef index():\n    path = request.args.get(\"path\", \"\").lstrip(\"/\")\n    try:\n        files = data.get_items(path=path)\n    except FileNotFoundError:\n        flash(\"Directory does not exist.\", \"error\")\n        return redirect(\"/\")\n\n    return render_template(\n        \"home.html\",\n        title=path or \"root\",\n        search_enabled=app.config[\"SEARCH_CONF\"][\"enabled\"],\n        dir=files,\n        current_path=path,\n        new_folder_form=forms.NewFolderForm(),\n        delete_form=forms.DeleteFolderForm(),\n        rename_form=forms.RenameDirectoryForm(),\n        view_only=0,\n        search_engine=app.config[\"SEARCH_CONF\"][\"engine\"],\n    )\n\n\n# TODO: refactor two following methods\n@app.route(\"/bookmarks/new\", methods=[\"GET\", \"POST\"])\ndef new_bookmark():\n    default_dir = app.config.get(\"DEFAULT_BOOKMARKS_DIR\", \"root directory\")\n    form = forms.NewBookmarkForm(path=default_dir)\n    form.path.choices = [(\"\", \"root directory\")] + [\n        (pathname, pathname) for pathname in data.get_dirs()\n    ]\n    if form.validate_on_submit():\n        path = form.path.data\n        tags = form.tags.data.split(\",\") if form.tags.data != \"\" else []\n        tags = [tag.strip() for tag in tags]\n        bookmark = DataObj(url=form.url.data, tags=tags, path=path, type=\"bookmark\")\n        bookmark.process_bookmark_url()\n        bookmark_id = bookmark.insert()\n        if bookmark_id:\n            flash(\"Bookmark Saved!\", \"success\")\n            return redirect(f\"/dataobj/{bookmark_id}\")\n        else:\n            flash(bookmark.error, \"error\")\n            return redirect(\"/bookmarks/new\")\n    # for bookmarklet\n    form.url.data = request.args.get(\"url\", \"\")\n    path = request.args.get(\"path\", default_dir).strip(\"/\")\n    # handle empty argument\n    form.path.data = path\n    return render_template(\"dataobjs/new.html\", title=\"New Bookmark\", form=form)\n\n\n@app.route(\"/notes/new\", methods=[\"GET\", \"POST\"])\ndef new_note():\n    form = forms.NewNoteForm()\n    default_dir = \"root directory\"\n    form.path.choices = [(\"\", default_dir)] + [\n        (pathname, pathname) for pathname in data.get_dirs()\n    ]\n    if form.validate_on_submit():\n        path = form.path.data\n        tags = form.tags.data.split(\",\") if form.tags.data != \"\" else []\n        tags = [tag.strip() for tag in tags]\n        note = DataObj(title=form.title.data, path=path, tags=tags, type=\"note\")\n        note_id = note.insert()\n        if note_id:\n            flash(\"Note Saved!\", \"success\")\n            return redirect(f\"/dataobj/{note_id}\")\n    path = request.args.get(\"path\", default_dir).strip(\"/\")\n    # handle empty argument\n    form.path.data = path\n    return render_template(\"/dataobjs/new.html\", title=\"New Note\", form=form)\n\n\n@app.route(\"/tags\")\ndef show_all_tags():\n    if not app.config[\"SEARCH_CONF\"][\"engine\"] == \"ripgrep\" and not which(\"rg\"):\n        flash(\"Ripgrep must be installed to view pages about embedded tags.\", \"error\")\n        return redirect(\"/\")\n    tags = sorted(get_all_tags(force=True))\n    return render_template(\"tags/all.html\", title=\"All Tags\", tags=tags)\n\n\n@app.route(\"/tags/<tag_name>\")\ndef show_tag(tag_name):\n    if not app.config[\"SEARCH_CONF\"][\"enabled\"] and not which(\"rg\"):\n        flash(\n            \"Search (for example ripgrep) must be installed to view pages about embedded tags.\",\n            \"error\",\n        )\n        return redirect(\"/\")\n\n    search_results = search(f\"#{tag_name}#\", strict=True)\n\n    return render_template(\n        \"tags/show.html\",\n        title=f\"Tags - {tag_name}\",\n        tag_name=tag_name,\n        search_result=search_results,\n    )\n\n\n@app.route(\"/dataobj/<int:dataobj_id>\")\ndef show_dataobj(dataobj_id):\n    dataobj = data.get_item(dataobj_id)\n    get_title_id_pairs = lambda x: (x[\"title\"], x[\"id\"])\n    titles = list(\n        map(get_title_id_pairs, data.get_items(structured=False, load_content=False))\n    )\n\n    if not dataobj:\n        flash(\"Data could not be found!\", \"error\")\n        return redirect(\"/\")\n\n    if request.args.get(\"raw\") == \"1\":\n        return frontmatter.dumps(dataobj)\n\n    backlinks = []\n    if app.config[\"SEARCH_CONF\"][\"enabled\"]:\n        if app.config[\"SEARCH_CONF\"][\"engine\"] == \"ripgrep\":\n            query = f\"\\|{dataobj_id}]]\"\n        else:\n            query = f\"|{dataobj_id})]]\"\n        backlinks = search(query, strict=True)\n\n    # Form for moving data into another folder\n    move_form = forms.MoveItemForm()\n    move_form.path.choices = [(\"\", \"root directory\")] + [\n        (pathname, pathname) for pathname in data.get_dirs()\n    ]\n\n    post_title_form = forms.TitleForm()\n    post_title_form.title.data = dataobj[\"title\"]\n\n    # Get all tags\n    tag_list = get_all_tags()\n    # and the ones present in this dataobj\n    embedded_tags = set()\n    PATTERN = r\"(?:^|\\n| )#(?:[-_a-zA-Z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff0-9]+)#\"\n    for match in re.finditer(PATTERN, dataobj.content):\n        embedded_tags.add(match.group(0).replace(\"#\", \"\").lstrip())\n\n    return render_template(\n        \"dataobjs/show.html\",\n        title=dataobj[\"title\"],\n        dataobj=dataobj,\n        backlinks=backlinks,\n        current_path=dataobj[\"dir\"],\n        form=forms.DeleteDataForm(),\n        view_only=0,\n        search_enabled=app.config[\"SEARCH_CONF\"][\"enabled\"],\n        post_title_form=post_title_form,\n        move_form=move_form,\n        tag_list=tag_list,\n        embedded_tags=embedded_tags,\n        titles=titles,\n    )\n\n\n@app.route(\"/dataobj/move/<int:dataobj_id>\", methods=[\"POST\"])\ndef move_item(dataobj_id):\n    form = forms.MoveItemForm()\n    out_dir = form.path.data if form.path.data != \"\" else \"root directory\"\n    if form.path.data == None:\n        flash(\"No path specified.\")\n        return redirect(f\"/dataobj/{dataobj_id}\")\n    try:\n        if data.move_item(dataobj_id, form.path.data):\n            flash(f\"Data successfully moved to {out_dir}.\", \"success\")\n            return redirect(f\"/dataobj/{dataobj_id}\")\n        else:\n            flash(f\"Data could not be moved to {out_dir}.\", \"error\")\n            return redirect(f\"/dataobj/{dataobj_id}\")\n    except FileNotFoundError:\n        flash(\"Data not found.\", \"error\")\n        return redirect(\"/\")\n    except FileExistsError:\n        flash(\"Data already in target directory.\", \"error\")\n        return redirect(f\"/dataobj/{dataobj_id}\")\n\n\n@app.route(\"/dataobj/delete/<int:dataobj_id>\", methods=[\"POST\"])\ndef delete_data(dataobj_id):\n    try:\n        data.delete_item(dataobj_id)\n    except BaseException:\n        flash(\"Data could not be found!\", \"error\")\n        return redirect(\"/\")\n    flash(\"Data deleted!\", \"success\")\n    return redirect(\"/\")\n\n\n@app.route(\"/login\", methods=[\"GET\", \"POST\"])\ndef login():\n    form = forms.UserForm()\n    if form.validate_on_submit():\n        db = get_db()\n        user = db.search(\n            (Query().username == form.username.data) & (Query().type == \"user\")\n        )\n\n        if user and check_password_hash(user[0][\"hashed_password\"], form.password.data):\n            user = User.from_db(user[0])\n            login_user(user, remember=True)\n            flash(\"Login successful!\", \"success\")\n\n            next_url = request.args.get(\"next\")\n            return redirect(next_url or \"/\")\n\n        flash(\"Invalid credentials\", \"error\")\n        return redirect(\"/login\")\n    return render_template(\"users/login.html\", form=form, title=\"Login\")\n\n\n@app.route(\"/logout\", methods=[\"DELETE\", \"GET\"])\ndef logout():\n    logout_user()\n    flash(\"Logged out successfully\", \"success\")\n    return redirect(\"/\")\n\n\n@app.route(\"/user/edit\", methods=[\"GET\", \"POST\"])\ndef edit_user():\n    form = forms.UserForm()\n    if form.validate_on_submit():\n        db = get_db()\n        db.update(\n            {\n                \"username\": form.username.data,\n                \"hashed_password\": generate_password_hash(form.password.data),\n            },\n            doc_ids=[current_user.id],\n        )\n        flash(\"Information saved!\", \"success\")\n        return redirect(\"/\")\n    form.username.data = current_user.username\n    return render_template(\"users/edit.html\", form=form, title=\"Edit Profile\")\n\n\n@app.route(\"/folders/create\", methods=[\"POST\"])\ndef create_folder():\n    form = forms.NewFolderForm()\n    if form.validate_on_submit():\n        path = Path(form.parent_dir.data.strip(\"/\")) / form.new_dir.data\n        new_path = data.create_dir(str(path))\n        flash(\"Folder successfully created.\", \"success\")\n        return redirect(f\"/?path={new_path}\")\n    flash(\"Could not create folder.\", \"error\")\n    return redirect(request.referrer or \"/\")\n\n\n@app.route(\"/folders/delete\", methods=[\"POST\"])\ndef delete_folder():\n    form = forms.DeleteFolderForm()\n    if form.validate_on_submit():\n        if data.delete_dir(form.dir_name.data):\n            flash(\"Folder successfully deleted.\", \"success\")\n            return redirect(\"/\")\n        else:\n            flash(\"Folder not found.\", \"error\")\n            return redirect(request.referrer or \"/\", 404)\n    flash(\"Could not delete folder.\", \"error\")\n    return redirect(request.referrer or \"/\")\n\n\n@app.route(\"/folders/rename\", methods=[\"POST\"])\ndef rename_folder():\n    form = forms.RenameDirectoryForm()\n    if form.validate_on_submit():\n        try:\n            new_path = data.rename_folder(form.current_path.data, form.new_name.data)\n            if not new_path:\n                flash(\"Invalid input.\", \"error\")\n            else:\n                flash(\"Renamed successfully.\", \"success\")\n                return redirect(f\"/?path={new_path}\")\n        except FileNotFoundError:\n            flash(\"Directory not found.\", \"error\")\n        except FileExistsError:\n            flash(\"Target directory exists.\", \"error\")\n    return redirect(\"/\")\n\n\n@app.route(\"/bookmarklet\")\ndef bookmarklet():\n    return render_template(\"bookmarklet.html\", title=\"Bookmarklet\")\n\n\n@app.route(\"/images/<filename>\")\ndef serve_image(filename):\n    if filename and data.valid_image_filename(filename):\n        image_path = data.image_exists(filename)\n        if image_path:\n            return send_file(image_path)\n        else:\n            return \"Image not found\", 404\n    else:\n        return \"Invalid file request\", 413\n\n\n@app.route(\"/static/custom.css\")\ndef custom_css():\n    if not app.config[\"THEME_CONF\"].get(\"use_custom_css\", False):\n        return \"\"\n    return send_from_directory(\n        Path(app.config[\"USER_DIR\"]) / \"css\",\n        app.config[\"THEME_CONF\"][\"custom_css_file\"],\n    )\n\n\n@app.route(\"/config\", methods=[\"GET\", \"POST\"])\ndef config():\n    \"\"\"\n    Web View to edit and update configuration.\n    \"\"\"\n\n    def update_config_value(key, val, dictionary):\n        if key != \"SECRET_KEY\":\n            if type(val) is dict:\n                for k, v in val.items():\n                    update_config_value(k, v, dictionary[key])\n            else:\n                dictionary[key] = val\n\n    form = forms.config_form(app.config)\n    default = vars(Config())\n    if form.validate_on_submit():\n        changed_config = Config()\n        changed_config.override(form.data)\n        for k, v in vars(changed_config).items():\n            # propagate changes to configuration\n            update_config_value(k, v, app.config)\n        write_config(vars(changed_config))  # save to filesystem config\n        flash(\"Config successfully updated.\", \"success\")\n    elif request.method == \"POST\":\n        flash(\"Could not update config.\", \"error\")\n    return render_template(\n        \"config.html\", conf=form, default=default, title=\"Edit Config\"\n    )\n", "{% import 'click_web/form_macros.html' as macros %}\r\n<h2 class=\"command-title-parents\">{{ levels[1:-1]| join(' - ', attribute='command.name')|title }}</h2>\r\n<h3 class=\"command-title\">{{ command.name|title }}</h3>\r\n<div class=\"command-help\">{{ command.html_help }}</div>\r\n\r\n<form id=\"inputform\"\r\n      method=\"post\"\r\n      action=\"{{ request.url }}\"\r\n      onsubmit=\"return postAndRead('{{ request.url }}');\"\r\n      class=\"pure-form pure-form-aligned\"\r\n      enctype=\"multipart/form-data\">\r\n    {% set command_list = [] %}\r\n    {% for level in levels %}\r\n        {% for field in level.fields %}\r\n            <div class=\"parameter {{ field.param }} {{ field.type }}\">\r\n                <div class=\"pure-control-group\">\r\n                    {% if field.nargs == -1 %}\r\n                        {{ macros.add_variadic_field_input(field) }}\r\n                    {% else %}\r\n                        <label for=\"{{ field.name }}\">\r\n                            {{ field.human_readable_name|capitalize }}\r\n                        </label>\r\n                        {% for arg in range(field.nargs) %}\r\n                            {{ macros.add_field_input(field) }}\r\n                        {% endfor %}\r\n\r\n                    {% endif %}\r\n                </div>\r\n            </div>\r\n        {% endfor %}\r\n    {% endfor %}\r\n\t<input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token() }}\"/>\r\n    <button type=\"submit\" id=\"submit_btn\" class=\"btn btn-primary m-2\">Run</button>\r\n</form>\r\n\r\n<div id=\"output-header\" hidden=\"true\"></div>\r\n<div class=\"script-output\" id=\"output\" hidden=\"true\"></div>\r\n<div id=\"output-footer\" hidden=\"true\"></div>\r\n", "{% extends \"base.html\" %}\n\n{% block content %}\n  <form id=\"tag_tooltip\" class=\"hidden\">\n    <input list=\"tags\" id=\"tag_tooltip_input\" class=\"floating_input\" required />\n    <datalist id=\"tags\">\n      {% for tag in tag_list %}\n        <option value=\"#{{tag}}\">\n      {% endfor %}\n    </datalist>\n  </form>\n\n  <form id=\"note_link_tooltip\" class=\"hidden\">\n    <input list=\"titles\" id=\"title_tooltip_input\" class=\"floating_input\" required placeholder=\"Title of linked note\" />\n    <datalist id=\"titles\">\n      {% for dataobj_title, id in titles %}\n        <option value=\"[[{{ dataobj_title }}|{{id}}]]\" data-id=\"{{ id }}\">\n      {% endfor %}\n    </datalist>\n  </form\n\n  {% include \"markdown-parser.html\" %}\n  {% if not view_only %}\n    <link rel=\"stylesheet\" href=\"/static/editor.css\">\n    {% if config.THEME_CONF.get('use_theme_dark', False) %}\n      <link rel=\"stylesheet\" href=\"/static/editor_dark.css\">\n    {% endif %}\n    <link rel=\"stylesheet\" href=\"/static/accessibility.css\">\n    <script async src=\"/static/editor.js\"></script>\n  {% endif %}\n  <link rel=\"stylesheet\" href=\"/static/markdown.css\">\n  {% if config.THEME_CONF.get('use_theme_dark', False) %}\n    <link rel=\"stylesheet\" href=\"/static/markdown_dark.css\">\n  {% endif %}\n  <div class=\"post-header\">\n    <!-- Form for editing the frontmatter -->\n    {% if not view_only %}\n    <form id=\"post-title-form\">\n      {{ post_title_form.hidden_tag() }}\n      {{ post_title_form.title() }}\n      {{ post_title_form.submit() }}\n    </form>\n    {% else %}\n      <h2 id=\"post-title\">\n        {{ dataobj['title'] }}\n      </h2>\n    {% endif %}\n\n    <div class=\"embedded-tags post-tags\">\n      {% for tag in embedded_tags %}\n        <span class=\"post-tag\">{{ tag }}</span>\n      {% endfor %}\n    </div>\n    <div class=\"metadata-tags post-tags\">\n      {% for tag in dataobj[\"tags\"] %}\n\t<span class=\"post-tag\">{{ tag }}</span>\n      {% endfor %}\n    </div>\n    <span class=\"post-date\">{{ dataobj['date'] }}</span>\n\n    {% if dataobj['type'] == 'bookmark' or dataobj['type'] == 'pocket_bookmark' %}\n      <a href=\"{{ dataobj['url'] }}\" rel=\"noopener\">\n        Link\n      </a>\n    {% endif %}\n    <br>\n    <!-- Edit / Delete buttons -->\n    {% if not view_only %}\n      <div class=\"d-flex\" id=\"post-btns\">\n          <button onclick=\"toggleEditor(this)\" class=\"btn\">\n            <svg class=\"octicon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M11.013 1.427a1.75 1.75 0 012.474 0l1.086 1.086a1.75 1.75 0 010 2.474l-8.61 8.61c-.21.21-.47.364-.756.445l-3.251.93a.75.75 0 01-.927-.928l.929-3.25a1.75 1.75 0 01.445-.758l8.61-8.61zm1.414 1.06a.25.25 0 00-.354 0L10.811 3.75l1.439 1.44 1.263-1.263a.25.25 0 000-.354l-1.086-1.086zM11.189 6.25L9.75 4.81l-6.286 6.287a.25.25 0 00-.064.108l-.558 1.953 1.953-.558a.249.249 0 00.108-.064l6.286-6.286z\"></path></svg>\n            <span>Edit</span>\n          </button>\n          <form action=\"/dataobj/delete/{{ dataobj['id'] }}\" method=\"POST\" onsubmit=\"return confirm('Delete this item permanently?')\" novalidate>\n            {{ form.hidden_tag() }}\n            <button class=\"btn btn-delete\">\n              <svg class=\"octicon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M6.5 1.75a.25.25 0 01.25-.25h2.5a.25.25 0 01.25.25V3h-3V1.75zm4.5 0V3h2.25a.75.75 0 010 1.5H2.75a.75.75 0 010-1.5H5V1.75C5 .784 5.784 0 6.75 0h2.5C10.216 0 11 .784 11 1.75zM4.496 6.675a.75.75 0 10-1.492.15l.66 6.6A1.75 1.75 0 005.405 15h5.19c.9 0 1.652-.681 1.741-1.576l.66-6.6a.75.75 0 00-1.492-.149l-.66 6.6a.25.25 0 01-.249.225h-5.19a.25.25 0 01-.249-.225l-.66-6.6z\"></path></svg>\n              <span>Delete</span>\n            </button>\n          </form>\n\n          <form action=\"/dataobj/move/{{ dataobj['id'] }}\" method=\"post\" novalidate id=\"post-move-form\">\n            {{ move_form.hidden_tag() }}\n            <button class=\"btn\">\n              Move to\n            </button>\n            {{ move_form.path(placeholder=move_form.path.name) }}\n          </form>\n          <label class=\"sr-only\">\n            <input type=\"checkbox\" id=\"sr-checkbox\">\n            screenreader mode\n          </label>\n      </div>\n\n    {% endif %}\n  </div>\n\n\n  <div id=\"content-cont\" class=\"markdown-body\">\n    <div id=\"content\"></div>\n      {% if not view_only %}\n        <textarea id=\"original-textarea\" aria-label=\"Text editor\"></textarea>\n      {% endif %}\n\n    {% if backlinks %}\n      <ul id=\"backlinks\" style=\"padding: 0\">\n        <h1>Backlinks</h3>\n        {% for backlink in backlinks %}\n          <li><a href=\"/dataobj/{{ backlink['id'] }}\">{{ backlink[\"title\"] }}:</a></li>\n          {% if \"matches\" in backlink %}\n            {% for link in backlink[\"matches\"] %}\n              <div class=\"backlink-markdown\">{{ link }}</div>\n            {% endfor %}\n          {% endif %}\n        {% endfor %}\n      </ul>\n    {% endif %}\n  </div>\n  <br>\n  {% if not view_only %}\n    <button class=\"sr-only\" type=\"button\" id=\"sr-savebutton\">Save</button>\n  {% endif %}\n  <script>\n    // escape text for template literal - double slashes for python rendering and js rendering\n    /* {% set content = dataobj[\"content\"]\n                          | replace(\"\\\\\", \"\\\\\\\\\")\n                          | replace(\"`\", \"\\\\`\")\n                          | replace(\"${\", \"\\\\${\")\n                          | safe\n       %} */\n    // Render the content with TOC\n    let contentDiv = document.getElementById(\"content\");\n    function renderContent(content) {\n      return window.parser.customRender(\"${toc}\\n\\n\" + content);\n    }\n    contentDiv.innerHTML = renderContent(`{{ content }}`);\n\n    {% if not view_only %}\n      // Also show the editing options\n      // The form for editing the front matter\n      let update_frontmatter_callback = function(e) {\n        let payload = {\n          method: \"PUT\",\n          body: JSON.stringify({\n            \"title\": post_title_form.title.value,\n          }),\n          headers: {\n            \"content-type\": \"application/json\"\n          }\n        };\n\n        response = fetch(`${SCRIPT_ROOT}/dataobjs/frontmatter/{{dataobj['id']}}`, payload);\n        post_title_form.submit.classList.add(\"post-title-form-sucess\");\n        e.preventDefault();\n      }\n\n      let post_title_form = document.getElementById(\"post-title-form\");\n      post_title_form.addEventListener(\"submit\", update_frontmatter_callback, true);\n\n      // Render the editor and put the dataobj in it\n      let editorDiv, oldContent, editor, savedContent = `{{ content }}`;\n\n      // Show the form for embedding links\n      let searchHits = document.getElementById(\"searchHits\");\n      let linkForm = document.getElementById(\"link-form\");\n      function toggleLinkForm() {\n        {% if not search_enabled %} return {% endif %}\n        if (linkForm.style.display == \"none\") {\n          linkForm.style.display = \"block\";\n        } else {\n          linkForm.style.display = \"none\";\n          input.value = \"\";\n          searchHits.innerHTML = \"\";\n        }\n      }\n\n      window.addEventListener(\"load\", function() {\n        // Set up the editor\n        editor = new EasyMDE({\n          autofocus: true,\n          uploadImage: true,\n          imageUploadEndpoint: \"{{ SCRIPT_ROOT }}/api/images\",\n          previewRender: function(content) {\n            return renderContent(content);\n          },\n          imagePathAbsolute: true,\n          imageAccept: \"image/png, image/jpeg, image/gif\",\n          imageMaxSize: \"100000000\",\n          toolbar: [\n            \"bold\",\n            \"italic\",\n            \"link\",\n            \"upload-image\",\n            \"heading\",\n            \"code\",\n            \"strikethrough\",\n            \"quote\",\n            \"table\",\n            {\n              name: \"LaTeX\",\n              className: \"fa fa-math\",\n              title: \"Embed Maths\",\n              action: (editor) => {\n                editor.codemirror.replaceSelection(\"$$\\n$$\")\n              }\n            },\n            \"side-by-side\",\n            \"fullscreen\",\n            {\n              name: \"local-archive-btn\",\n              className: \"fa fa-bookmark\",\n              title: \"Archives and links to local copy of selected url\",\n              action: async editor => {\n                let link = editor.codemirror.getSelection().trim(), url;\n                try {\n                  url = new URL(link);\n                } catch (_) {\n                  return false;\n                }\n                if (url.protocol !== \"http:\" && url.protocol !== \"https:\") {\n                  return false;\n                }\n                let req = await fetch(`${SCRIPT_ROOT}/bookmarks`, {\n                  method: \"POST\",\n                  body: JSON.stringify({\n                    \"url\": link\n                  }),\n                  headers: {\n                    \"content-type\": \"application/json\"\n                  }\n                })\n                if (req.ok) {\n                  let bookmark = await req.json();\n                  editor.codemirror.replaceSelection(`[${link}](/dataobj/${bookmark[\"bookmark_id\"]})\\n`);\n                }\n              }  // action\n            },  // archive-btn\n            {\n              name: \"save\",\n              title: \"Save note contents\",\n              className: \"fa fa-save\",\n              action: (editor) => {\n                fetch(`${SCRIPT_ROOT}/dataobjs/{{dataobj['id']}}`, {\n                  method: \"PUT\",\n                  body: JSON.stringify({\n                    \"content\": editor.value()\n                  }),\n                  headers: {\n                    \"content-type\": \"application/json\"\n                  }\n                })\n                statusBtn.classList.add(\"fa-check-circle\");\n                statusBtn.classList.remove(\"fa-times\");\n                savedContent = editor.value();\n                // update dataobj tags\n                let post_tags = document.querySelector(\".embedded-tags\");\n                let matches = [...savedContent.matchAll(\"(?:^|\\\\n| )#(?:[a-zA-Z0-9_-]+)\\\\w\")];\n                let all_tags = []\n                for (i=0; i < matches.length; i++) {\n                  all_tags.push(matches[i][0].trim())\n                }\n                post_tags.innerHTML = \"\"\n                let uniq_tags = [...new Set(all_tags)];\n                for (i=0; i < uniq_tags.length; i++) {\n                  let new_tag = document.createElement(\"span\")\n                  new_tag.classList.add(\"post-tag\")\n                  new_tag.innerHTML = uniq_tags[i]\n                  post_tags.appendChild(new_tag)\n                }\n              }, // action\n            }, // save-button\n            {\n              name: \"status\",\n              className: \"fa fa-check-circle status\"\n            },\n            {\n              name: \"doc\",\n              className: \"fa fa-question-circle\",\n              action: \"https://archivy.github.io/editing\",\n              title: \"Editing Guide\"\n            }\n          ], // toolbar\n          shortcuts: {\n            \"save\": \"Ctrl-S\"\n          },\n        });  // EasyMDE\n\n        editor.value(`{{ content }}`)\n\n        let statusBtn = document.querySelector(\".status .fa\");\n        editor.codemirror.on(\"change\", function() {\n          statusBtn.classList.remove(\"fa-check-circle\");\n          statusBtn.classList.add(\"fa-times\")\n        })\n        oldContent = document.getElementById(\"content\"), editorDiv = document.querySelector(\".EasyMDEContainer\");\n        editorDiv.classList.add(\"hidden\");\n        document.body.scrollIntoView(true);\n\n        /////////////////////////////////////////////////////////////////\n        //                      Tag and note link autocompletion       //\n        /////////////////////////////////////////////////////////////////\n        // The container, datalist input and CoreMirror instance. \n        let tag_tooltip = document.querySelector(\"#tag_tooltip\");\n        let note_link_tooltip = document.querySelector(\"#note_link_tooltip\")\n        let tag_tooltip_input = document.querySelector(\"#tag_tooltip_input\")\n        let title_tooltip_input = document.querySelector(\"#title_tooltip_input\");\n        let cm = document.getElementsByClassName(\"CodeMirror\")[0].CodeMirror;\n\n        // Put `data` where the cursor is right now\n        function insertText(data) {\n          let doc = cm.getDoc();\n          let cursor = doc.getCursor(); // gets the line number in the cursor position\n          doc.replaceRange(data, cursor);\n        }\n\n        // Add a tag\n        //  1. Put the value of the datalist into the editor\n        //  2. Add to the index\n        function add_tag() {\n          let tag = tag_tooltip_input.value;\n          if (tag[0] != \"#\") {\n            tag = \"#\" + tag;\n          }\n          tagname = tag.slice(1);\n\n          // 1.\n          toggle_tag_tooltip();\n          insertText(tag + \"#\");\n\n          editor.codemirror.focus();\n\n          // 2.\n          let payload = {\n            method: \"PUT\",\n            body: JSON.stringify({\n              \"dataobj_id\": {{dataobj['id']}},\n              \"tag\": tagname\n            }),\n            headers: {\n              \"content-type\": \"application/json\"\n            }\n          };\n          response = fetch(`${SCRIPT_ROOT}/tags/add_to_index`, payload);\n        }\n\n\n        // When toggling the tooltips we want to position it right first.\n        // Otherwise, clear the input and hide it.\n        // initVal is just the value we wanna set the tooltip input to when we display it\n        function toggle_tooltip(tooltip, input, initVal = '') {\n          if (tooltip.classList.contains(\"hidden\")) {\n            let cursor_coordinates = cm.cursorCoords()\n            tooltip.style.zIndex = 9999;\n            tooltip.style.position = \"absolute\";\n            tooltip.style.top = cursor_coordinates.top - cm.defaultTextHeight() + \"px\";\n            tooltip.style.left = cursor_coordinates.left - 10 + \"px\";\n            tooltip.classList.remove(\"hidden\");\n            input.value = initVal;\n            input.focus();\n          } else {\n            tooltip.classList.add(\"hidden\");\n            input.value = \"\";\n            document.activeElement.blur();\n          }\n        }\n        function toggle_tag_tooltip()\n        {\n          toggle_tooltip(tag_tooltip, tag_tooltip_input, \"#\")\n        }\n        function toggle_link_tooltip()\n        {\n          toggle_tooltip(note_link_tooltip, title_tooltip_input, '[[')\n        }\n\n        // Whenever the content of the editor changes:\n        //   Check what the last character is. Is it a `#`?\n        //   Then get rid of the `#` and put it into the tag tooltip and show that.\n        editor.codemirror.on(\"change\", function(ed, change) {\n          let line = ed.doc.getCursor().line, // Cursor line\n          ch = ed.doc.getCursor().ch;\n          let currLine = ed.doc.getLine(line);\n          let currChar = currLine[ch - 1];\n          let is_tag_beginning = (currChar === \"#\" && (ch == 1 || currLine[ch-2] === ' ') && (ch == currLine.length || currLine[ch] === ' '));\n          // checks the user inputted \"[[\" on a line without other text adjacent to it.\n          let is_note_link_beginning = currChar === '[' && ch != 1 && currLine[ch-2] === '[' && (ch == 2 || currLine[ch-3] === ' ') && (ch == currLine.length || currLine[ch] === ' ');\n          if (is_tag_beginning) {\n            ed.doc.replaceRange(\"\", {\n              line: line,\n              ch: ch - 1\n            }, {\n              line: line,\n              ch: ch\n            })\n            toggle_tag_tooltip();\n          }\n          else if (is_note_link_beginning)\n          {\n            ed.doc.replaceRange(\"\", {\n              line: line,\n              ch: ch - 2\n            }, {\n              line: line,\n              ch: ch\n            })\n            toggle_link_tooltip();\n          }\n        });\n\n        // When the user hits enter, add the tag.\n        tag_tooltip.onsubmit = function(e) {\n          e.preventDefault()\n          add_tag();\n        };\n\n\n        note_link_tooltip.onsubmit = function(e) {\n          e.preventDefault();\n          let note_link = title_tooltip_input.value;\n          if (note_link === \"\") return;\n          let currOption = document.querySelector(`option[value=\"${note_link}\"]`)\n          if (!currOption) { return; }\n          let id = currOption.getAttribute(\"data-id\");\n          insertText(note_link);\n          toggle_link_tooltip();\n        }\n\n        // We watch for two cases:\n        //  1. The input is empty => hide the tooltip\n        //  2. The tooltip contains a whitespace. Just put the value into the editor and hide the tooltip.\n        tag_tooltip_input.oninput = function() {\n          tag_tooltip_input.focus();\n          if (tag_tooltip_input.value === \"\" || tag_tooltip_input.value.includes(\" \")) {\n            insertText(tag_tooltip_input.value);\n            toggle_tag_tooltip();\n            editor.codemirror.focus();\n          }\n        }\n\n        title_tooltip_input.oninput = function()\n\t{\n\t  title_tooltip_input.focus();\n\t  if (!title_tooltip_input.value.startsWith(\"[[\"))\n\t  {\n\t    toggle_link_tooltip();\n\t    insertText(title_tooltip_input.value)\n\t    editor.codemirror.focus();\n          }\n        }\n\n        /////////////////////////////////////////////////////////////////\n        //                      Screenreader stuff                     //\n        /////////////////////////////////////////////////////////////////\n        /* Screenreader mode checkbox */\n        function toggleScreenReaderMode(cbox, editor)\n        {\n          return function () {\n            if (cbox.checked) {\n              editor.toTextArea();\n              editor = null;\n            } else {\n              location.reload();\n            }\n          }\n        }\n\n        /* Add screenreader checkbox toggle */\n        let srCbox = document.getElementById(\"sr-checkbox\");\n        srCbox.onchange = toggleScreenReaderMode(srCbox, editor);\n\n        /* Screenreader save button handler */\n        function screenReaderSave(btn) {\n          fetch(`${SCRIPT_ROOT}/dataobjs/{{dataobj['id']}}`, {\n            method: \"PUT\",\n            body: JSON.stringify({\n              \"content\": document.getElementById(\"original-textarea\").value\n            }),\n            headers: {\n              \"content-type\": \"application/json\"\n            }\n          });\n          let saveAlert = document.createElement(\"span\");\n          saveAlert.setAttribute(\"role\", \"alert\");\n          let saveAlertText = document.createTextNode(\"Note saved\");\n          saveAlert.appendChild(saveAlertText);\n          document.body.appendChild(saveAlert);\n        }  // function screenReaderSave\n\n        /* Add screenreader save button handler */\n        let srSaveBtn = document.getElementById(\"sr-savebutton\");\n        srSaveBtn.onclick = screenReaderSave;\n      })  // window.addEventListener(\"load\")\n\n\n\n      function toggleEditor(btn) {\n        let btnText = btn.querySelector(\"span\");\n        if (btnText.textContent == \"Edit\") {\n          btnText.textContent = \"Hide Editor\";\n        } else {\n          btnText.textContent = \"Edit\";\n          contentDiv.innerHTML = renderContent(savedContent);\n        }\n        oldContent.classList.toggle(\"hidden\"), editorDiv.classList.toggle(\"hidden\");\n      }\n\n      // render backlinks\n\n      document.querySelectorAll(\".backlink-markdown\").forEach((link) => {\n        link.innerHTML = window.parser.customRender(`> ${link.innerHTML}`);\n      })\n    {% endif %}\n  </script>\n{% endblock %}\n", "import os\nimport re\n\nfrom flask.testing import FlaskClient\nfrom flask import request\nfrom flask_login import current_user\nfrom responses import RequestsMock, GET\nfrom werkzeug.security import generate_password_hash\n\nfrom archivy.helpers import get_max_id, get_db\nfrom archivy.data import get_dirs, create_dir, get_items, get_item\n\n\ndef test_get_index(test_app, client: FlaskClient):\n    response = client.get(\"/\")\n    assert response.status_code == 200\n\n\ndef test_get_custom_css(test_app, client: FlaskClient):\n    test_app.config[\"THEME_CONF\"][\"use_custom_css\"] = True\n    css_file = \"custom.css\"\n    css_contents = \"\"\"\n        body {\n            color: red\n        }\n    \"\"\"\n\n    os.mkdir(f\"{test_app.config['USER_DIR']}/css/\")\n    with open(f\"{test_app.config['USER_DIR']}/css/{css_file}\", \"w\") as f:\n        f.write(css_contents)\n    test_app.config[\"THEME_CONF\"][\"custom_css_file\"] = css_file\n    resp = client.get(\"/static/custom.css\")\n    assert css_contents.encode(\"utf-8\") in resp.data\n    test_app.config[\"THEME_CONF\"][\"use_custom_css\"] = False\n\n\ndef test_get_new_bookmark(test_app, client: FlaskClient):\n    response = client.get(\"/bookmarks/new\")\n    assert response.status_code == 200\n\n\ndef test_post_new_bookmark_missing_fields(test_app, client: FlaskClient):\n    response = client.post(\"/bookmarks/new\", data={\"submit\": True})\n    assert response.status_code == 200\n    assert b\"This field is required\" in response.data\n\n\ndef test_get_new_note(test_app, client: FlaskClient):\n    response = client.get(\"/notes/new\")\n    assert response.status_code == 200\n\n\ndef test_get_dataobj_not_found(test_app, client: FlaskClient):\n    response = client.get(\"/dataobj/1\")\n    assert response.status_code == 302\n\n\ndef test_get_dataobj(test_app, client: FlaskClient, note_fixture):\n    response = client.get(\"/dataobj/1\")\n    assert response.status_code == 200\n\n\ndef test_get_delete_dataobj_not_found(test_app, client: FlaskClient):\n    response = client.post(\"/dataobj/delete/1\")\n    assert response.status_code == 302\n\n\ndef test_get_delete_dataobj(test_app, client: FlaskClient, note_fixture):\n    response = client.post(\"/dataobj/delete/1\")\n    assert response.status_code == 302\n\n\ndef test_create_new_bookmark(\n    test_app, client: FlaskClient, mocked_responses: RequestsMock\n):\n    mocked_responses.add(\n        GET,\n        \"https://example.com/\",\n        body=\"\"\"<html>\n        <head><title>Random</title></head><body><p>\n            Lorem ipsum dolor sit amet, consectetur adipiscing elit\n        </p></body></html>\n    \"\"\",\n    )\n\n    bookmark_data = {\n        \"url\": \"https://example.com\",\n        \"tags\": \"testing,bookmark\",\n        \"path\": \"\",\n        \"submit\": \"true\",\n    }\n\n    resp = client.post(\"/bookmarks/new\", data=bookmark_data)\n    assert resp.status_code == 302\n    assert not b\"invalid\" in resp.data\n\n    resp = client.post(\"/bookmarks/new\", data=bookmark_data, follow_redirects=True)\n    assert resp.status_code == 200\n    assert b'<span class=\"post-tag\">bookmark</span>' in resp.data\n    assert b'<span class=\"post-tag\">testing</span>' in resp.data\n    assert b\"https://example.com\" in resp.data\n    assert b\"Random\" in resp.data\n\n\ndef test_creating_bookmark_without_passing_path_saves_to_default_dir(\n    test_app, client, mocked_responses\n):\n    mocked_responses.add(GET, \"http://example.org\", body=\"Example\\n\")\n    bookmarks_dir = \"bookmarks\"\n    test_app.config[\"DEFAULT_BOOKMARKS_DIR\"] = bookmarks_dir\n    create_dir(bookmarks_dir)\n    resp = client.post(\n        \"/bookmarks/new\",\n        data={\n            \"url\": \"http://example.org\",\n            \"submit\": \"true\",\n        },\n    )\n    bookmark = get_items(structured=False)[0]\n    assert (\n        \"bookmarks\" in bookmark[\"path\"]\n    )  # verify it was saved to default bookmark dir\n\n\ndef test_create_note(test_app, client: FlaskClient):\n\n    note_data = {\n        \"title\": \"Testing the create route\",\n        \"tags\": \"testing,note\",\n        \"path\": \"\",\n        \"submit\": \"true\",\n    }\n\n    resp = client.post(\"/notes/new\", data=note_data)\n    assert resp.status_code == 302\n    assert not b\"invalid\" in resp.data\n\n    resp = client.post(\"/notes/new\", data=note_data, follow_redirects=True)\n    assert resp.status_code == 200\n    assert b'<span class=\"post-tag\">note</span>' in resp.data\n    assert b'<span class=\"post-tag\">testing</span>' in resp.data\n    assert b\"Testing the create route\" in resp.data\n\n\ndef test_logging_in(test_app, client: FlaskClient):\n    resp = client.post(\n        \"/login\",\n        data={\"username\": \"halcyon\", \"password\": \"password\"},\n        follow_redirects=True,\n    )\n    assert resp.status_code == 200\n    assert request.path == \"/\"\n    assert current_user\n\n\ndef test_logging_in_with_invalid_creds(test_app, client: FlaskClient):\n    resp = client.post(\n        \"/login\",\n        data={\"username\": \"invalid\", \"password\": \"dasdasd\"},\n        follow_redirects=True,\n    )\n    assert resp.status_code == 200\n    assert request.path == \"/login\"\n    assert b\"Invalid credentials\" in resp.data\n\n\ndef test_edit_user(test_app, client: FlaskClient):\n    \"\"\"Tests editing a user's info, logging out and then logging in with new info.\"\"\"\n\n    new_user = \"new_halcyon\"\n    new_pass = \"password2\"\n    resp = client.post(\n        \"/user/edit\",\n        data={\"username\": new_user, \"password\": new_pass},\n        follow_redirects=True,\n    )\n\n    assert request.path == \"/\"\n\n    client.delete(\"/logout\")\n\n    resp = client.post(\n        \"/login\",\n        data={\"username\": new_user, \"password\": new_pass},\n        follow_redirects=True,\n    )\n    assert resp.status_code == 200\n    assert request.path == \"/\"\n    # check information has updated.\n\n\ndef test_logging_out(test_app, client: FlaskClient):\n    \"\"\"Tests logging out and then accessing restricted views\"\"\"\n\n    client.delete(\"/logout\")\n\n    resp = client.get(\"/\", follow_redirects=True)\n    assert request.path == \"/login\"\n\n\ndef test_create_dir(test_app, client: FlaskClient):\n    \"\"\"Tests /folders/create endpoint\"\"\"\n\n    resp = client.post(\n        \"/folders/create\",\n        data={\"parent_dir\": \"\", \"new_dir\": \"testing\"},\n        follow_redirects=True,\n    )\n\n    assert resp.status_code == 200\n    assert request.args.get(\"path\") == \"testing\"\n    assert \"testing\" in get_dirs()\n    assert b\"Folder successfully created\" in resp.data\n\n\ndef test_creating_without_dirname_fails(test_app, client: FlaskClient):\n    resp = client.post(\n        \"/folders/create\", data={\"parent_dir\": \"\"}, follow_redirects=True\n    )\n\n    assert resp.status_code == 200\n    assert request.path == \"/\"\n    assert b\"Could not create folder.\" in resp.data\n\n\ndef test_visiting_nonexistent_dir_fails(test_app, client: FlaskClient):\n    resp = client.get(\"/?path=nonexistent_dir\", follow_redirects=True)\n    assert b\"Directory does not exist.\" in resp.data\n\n\ndef test_deleting_dir(test_app, client: FlaskClient):\n    create_dir(\"testing\")\n    assert \"testing\" in get_dirs()\n    resp = client.post(\n        \"/folders/delete\", data={\"dir_name\": \"testing\"}, follow_redirects=True\n    )\n    assert not \"testing\" in get_dirs()\n    assert b\"Folder successfully deleted.\" in resp.data\n\n\ndef test_deleting_nonexisting_folder_fails(test_app, client: FlaskClient):\n    resp = client.post(\"/folders/delete\", data={\"dir_name\": \"testing\"})\n    assert resp.status_code == 404\n\n\ndef test_bookmarklet(test_app, client: FlaskClient):\n    resp = client.get(\"/bookmarklet\")\n    assert resp.status_code == 200\n\n\ndef test_backlinks_are_saved(\n    test_app, client: FlaskClient, note_fixture, bookmark_fixture\n):\n    test_app.config[\"SEARCH_CONF\"][\"enabled\"] = 1\n    test_app.config[\"SEARCH_CONF\"][\"engine\"] = \"ripgrep\"\n\n    resp = client.put(\n        f\"/api/dataobjs/{note_fixture.id}\",\n        json={\"content\": f\"[[{bookmark_fixture.title}|{bookmark_fixture.id}]]\"},\n    )\n    assert resp.status_code == 200\n\n    resp = client.get(f\"/dataobj/{bookmark_fixture.id}\")\n    assert b\"Backlinks\" in resp.data  # backlink was detected\n    test_app.config[\"SEARCH_CONF\"][\"enabled\"] = 0\n\n\ndef test_bookmark_with_long_title_gets_truncated(test_app, client, mocked_responses):\n\n    long_title = \"a\" * 300\n    # check that our mock title is indeed longer than the limit\n    # and would cause an error, without our truncating\n    assert os.pathconf(\"/\", \"PC_NAME_MAX\") < len(long_title)\n    mocked_responses.add(GET, \"https://example.com\", f\"<title>{long_title}</title>\")\n    bookmark_data = {\n        \"url\": \"https://example.com\",\n        \"submit\": \"true\",\n    }\n\n    resp = client.post(\"/bookmarks/new\", data=bookmark_data)\n    assert resp.status_code == 200\n\n\ndef test_move_data(test_app, note_fixture, client):\n    create_dir(\"random\")\n\n    resp = client.post(\n        \"/dataobj/move/1\",\n        data={\"path\": \"random\", \"submit\": \"true\"},\n        follow_redirects=True,\n    )\n    assert resp.status_code == 200\n    assert b\"Data successfully moved to random.\" in resp.data\n\n    assert get_item(1)[\"dir\"] == \"random\"\n\n\ndef test_invalid_inputs_fail_move_data(test_app, note_fixture, client):\n\n    resp = client.post(\"/dataobj/move/1\", follow_redirects=True)\n    assert b\"No path specified.\" in resp.data\n\n    resp = client.post(\n        \"/dataobj/move/2\", data={\"path\": \"aaa\", \"submit\": \"true\"}, follow_redirects=True\n    )\n    assert b\"Data not found\" in resp.data\n\n    resp = client.post(\n        \"/dataobj/move/1\", data={\"path\": \"\", \"submit\": \"true\"}, follow_redirects=True\n    )\n    assert b\"Data already in target directory\" in resp.data\n\n    faulty_paths = [\"../adarnad\", \"~/adasd\", \"ssss\"]\n    for p in faulty_paths:\n        resp = client.post(\n            \"/dataobj/move/1\", data={\"path\": p, \"submit\": \"true\"}, follow_redirects=True\n        )\n        assert b\"Data could not be moved to \" + bytes(p, \"utf-8\") in resp.data\n\n\ndef test_rename_dir(test_app, client):\n    create_dir(\"random\")\n\n    resp = client.post(\n        \"/folders/rename\",\n        data={\"current_path\": \"random\", \"new_name\": \"renamed_random\"},\n        follow_redirects=True,\n    )\n    assert resp.status_code == 200\n    assert b\"Renamed successfully\" in resp.data\n\n\ndef test_invalid_inputs_fail_renaming(test_app, client):\n    create_dir(\"random\")\n    create_dir(\"random2\")\n    resp = client.post(\n        \"/folders/rename\",\n        data={\"current_path\": \"inexisting\", \"new_name\": \"random3\"},\n        follow_redirects=True,\n    )\n    assert b\"Directory not found\" in resp.data\n\n    resp = client.post(\n        \"/folders/rename\",\n        data={\"current_path\": \"random\", \"new_name\": \"random2\"},\n        follow_redirects=True,\n    )\n    assert b\"Target directory exists.\" in resp.data\n\n    faulty_paths = [\"../adarnad\", \"~/adasd\", \"/illegal_dir\", \".\"]\n    for p in faulty_paths:\n        print(p)\n        resp = client.post(\n            \"/folders/rename\",\n            data={\"current_path\": \"random\", \"new_name\": p},\n            follow_redirects=True,\n        )\n        assert b\"Invalid input\" in resp.data\n\n\ndef test_get_config_page(test_app, client):\n    resp = client.get(\"/config\")\n    assert resp.status_code == 200\n    assert b\"Edit Config\" in resp.data\n\n\ndef test_post_updated_config(test_app, client):\n    # use dark theme as random conf value to change\n    dark_theme = test_app.config[\"THEME_CONF\"][\"use_theme_dark\"]\n\n    resp = client.post(\n        \"/config\", data={\"submit\": True, \"THEME_CONF-use_theme_dark\": not dark_theme}\n    )\n    assert test_app.config[\"THEME_CONF\"][\"use_theme_dark\"] == (not dark_theme)\n\n\ndef test_getting_all_tags(test_app, client, bookmark_fixture):\n    # bookmark fixture has embedded tags\n    resp = client.get(\"/tags\")\n    bookmark_tags = [\"embedded-tag\", \"tag2\"]\n    assert resp.status_code == 200\n    for tag in bookmark_tags:\n        assert f\"#{tag}\" in str(resp.data)\n\n\ndef test_getting_matches_for_specific_tag(test_app, client, bookmark_fixture):\n    resp = client.get(\"/tags/tag2\")\n    assert resp.status_code == 200\n    assert bookmark_fixture.title in str(resp.data)\n    assert str(bookmark_fixture.id) in str(resp.data)\n"], "filenames": ["archivy/__init__.py", "archivy/click_web/resources/cmd_exec.py", "archivy/routes.py", "archivy/templates/click_web/command_form.html", "archivy/templates/dataobjs/show.html", "tests/functional/test_routes.py"], "buggy_code_start_loc": [8, 140, 235, 31, 74, 64], "buggy_code_end_loc": [79, 144, 236, 31, 75, 70], "fixing_code_start_loc": [9, 140, 235, 32, 74, 64], "fixing_code_end_loc": [82, 142, 236, 33, 75, 70], "type": "CWE-352", "message": "archivy is vulnerable to Cross-Site Request Forgery (CSRF)", "other": {"cve": {"id": "CVE-2021-4162", "sourceIdentifier": "security@huntr.dev", "published": "2021-12-25T12:15:17.173", "lastModified": "2022-01-04T19:44:54.213", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "archivy is vulnerable to Cross-Site Request Forgery (CSRF)"}, {"lang": "es", "value": "archivy es vulnerable a un ataque de tipo Cross-Site Request Forgery (CSRF)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-352"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:archivy_project:archivy:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.6.1", "matchCriteriaId": "8848F8BD-F026-4795-B2A4-71A88B96003B"}]}]}], "references": [{"url": "https://github.com/archivy/archivy/commit/796c3ae318eea183fc88c87ec5a27355b0f6a99d", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/e204a768-2129-4b6f-abad-e436309c7c32", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/archivy/archivy/commit/796c3ae318eea183fc88c87ec5a27355b0f6a99d"}}