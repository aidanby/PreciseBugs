{"buggy_code": ["/*\n *\n * Copyright 2019 Asylo authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n#include \"asylo/platform/system_call/system_call.h\"\n\n#include <errno.h>\n\n#include <array>\n#include <cstdarg>\n#include <cstdint>\n#include <memory>\n\n#include \"asylo/platform/system_call/metadata.h\"\n#include \"asylo/platform/system_call/serialize.h\"\n#include \"asylo/platform/system_call/type_conversions/manual_types_functions.h\"\n#include \"asylo/platform/system_call/type_conversions/types_functions.h\"\n\nnamespace {\n\n// Deleter object for malloc() allocated buffers.\nstruct MallocDeleter {\n  void operator()(uint8_t *buffer) { free(buffer); }\n};\n\n// Default abort handler if none provided.\nvoid default_error_handler(const char *message) { abort(); }\n\nsyscall_dispatch_callback global_syscall_callback = nullptr;\nvoid (*error_handler)(const char *message) = nullptr;\n\n}  // namespace\n\nextern \"C\" bool enc_is_syscall_dispatcher_set() {\n  return global_syscall_callback != nullptr;\n}\n\nextern \"C\" bool enc_is_error_handler_set() { return error_handler != nullptr; }\n\nextern \"C\" void enc_set_dispatch_syscall(syscall_dispatch_callback callback) {\n  global_syscall_callback = callback;\n}\n\nextern \"C\" void enc_set_error_handler(\n    void (*abort_handler)(const char *message)) {\n  error_handler = abort_handler;\n}\n\nextern \"C\" int64_t enc_untrusted_syscall(int sysno, ...) {\n  if (!enc_is_error_handler_set()) {\n    enc_set_error_handler(default_error_handler);\n  }\n\n  asylo::system_call::SystemCallDescriptor descriptor{sysno};\n  if (!descriptor.is_valid()) {\n    error_handler(\"system_call.cc: Invalid SystemCallDescriptor encountered.\");\n  }\n\n  // Collect the passed parameter list into an array.\n  std::array<uint64_t, asylo::system_call::kParameterMax> parameters;\n  va_list args;\n  va_start(args, sysno);\n  for (int i = 0; i < descriptor.parameter_count(); i++) {\n    parameters[i] = va_arg(args, uint64_t);\n  }\n  va_end(args);\n\n  // Allocate a buffer for the serialized request.\n  asylo::primitives::Extent request;\n  asylo::primitives::PrimitiveStatus status;\n  status = asylo::system_call::SerializeRequest(sysno, parameters, &request);\n  if (!status.ok()) {\n    error_handler(\n        \"system_call.cc: Encountered serialization error when serializing \"\n        \"syscall parameters.\");\n  }\n\n  std::unique_ptr<uint8_t, MallocDeleter> request_owner(request.As<uint8_t>());\n\n  // Invoke the system call dispatch callback to execute the system call.\n  uint8_t *response_buffer;\n  size_t response_size;\n\n  if (!enc_is_syscall_dispatcher_set()) {\n    error_handler(\"system_.cc: system call dispatcher not set.\");\n  }\n  status = global_syscall_callback(request.As<uint8_t>(), request.size(),\n                                   &response_buffer, &response_size);\n  if (!status.ok()) {\n    error_handler(\n        \"system_call.cc: Callback from syscall dispatcher was unsuccessful.\");\n  }\n\n  std::unique_ptr<uint8_t, MallocDeleter> response_owner(response_buffer);\n\n  if (!response_buffer) {\n    error_handler(\n        \"system_call.cc: null response buffer received for the syscall.\");\n  }\n\n  // Copy outputs back into pointer parameters.\n  auto response_reader =\n      asylo::system_call::MessageReader({response_buffer, response_size});\n  const asylo::primitives::PrimitiveStatus response_status =\n      response_reader.Validate();\n  if (!response_status.ok()) {\n    error_handler(\n        \"system_call.cc: Error deserializing response buffer into response \"\n        \"reader.\");\n  }\n\n  for (int i = 0; i < asylo::system_call::kParameterMax; i++) {\n    asylo::system_call::ParameterDescriptor parameter = descriptor.parameter(i);\n    if (parameter.is_out()) {\n      size_t size;\n      if (parameter.is_fixed()) {\n        size = parameter.size();\n      } else {\n        size = parameters[parameter.size()] * parameter.element_size();\n      }\n      const void *src = response_reader.parameter_address(i);\n      void *dst = reinterpret_cast<void *>(parameters[i]);\n      if (dst != nullptr) {\n        memcpy(dst, src, size);\n      }\n    }\n  }\n\n  uint64_t result = response_reader.header()->result;\n  if (static_cast<int64_t>(result) == -1) {\n    int klinux_errno = response_reader.header()->error_number;\n\n    // Simply having a return value of -1 from a syscall is not a necessary\n    // condition that the syscall failed. Some syscalls can return -1 when\n    // successful (eg., lseek). The reliable way to check for syscall failure is\n    // to therefore check both return value and presence of a non-zero errno.\n    if (klinux_errno != 0) {\n      errno = FromkLinuxErrno(klinux_errno);\n    }\n  }\n  return result;\n}\n"], "fixing_code": ["/*\n *\n * Copyright 2019 Asylo authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n#include \"asylo/platform/system_call/system_call.h\"\n\n#include <errno.h>\n\n#include <array>\n#include <cstdarg>\n#include <cstdint>\n#include <memory>\n\n#include \"asylo/platform/system_call/metadata.h\"\n#include \"asylo/platform/system_call/serialize.h\"\n#include \"asylo/platform/system_call/type_conversions/manual_types_functions.h\"\n#include \"asylo/platform/system_call/type_conversions/types_functions.h\"\n\nnamespace {\n\n// Deleter object for malloc() allocated buffers.\nstruct MallocDeleter {\n  void operator()(uint8_t *buffer) { free(buffer); }\n};\n\n// Default abort handler if none provided.\nvoid default_error_handler(const char *message) { abort(); }\n\nsyscall_dispatch_callback global_syscall_callback = nullptr;\nvoid (*error_handler)(const char *message) = nullptr;\n\n}  // namespace\n\nextern \"C\" bool enc_is_syscall_dispatcher_set() {\n  return global_syscall_callback != nullptr;\n}\n\nextern \"C\" bool enc_is_error_handler_set() { return error_handler != nullptr; }\n\nextern \"C\" void enc_set_dispatch_syscall(syscall_dispatch_callback callback) {\n  global_syscall_callback = callback;\n}\n\nextern \"C\" void enc_set_error_handler(\n    void (*abort_handler)(const char *message)) {\n  error_handler = abort_handler;\n}\n\nextern \"C\" int64_t enc_untrusted_syscall(int sysno, ...) {\n  if (!enc_is_error_handler_set()) {\n    enc_set_error_handler(default_error_handler);\n  }\n\n  asylo::system_call::SystemCallDescriptor descriptor{sysno};\n  if (!descriptor.is_valid()) {\n    error_handler(\"system_call.cc: Invalid SystemCallDescriptor encountered.\");\n  }\n\n  // Collect the passed parameter list into an array.\n  std::array<uint64_t, asylo::system_call::kParameterMax> parameters;\n  va_list args;\n  va_start(args, sysno);\n  for (int i = 0; i < descriptor.parameter_count(); i++) {\n    parameters[i] = va_arg(args, uint64_t);\n  }\n  va_end(args);\n\n  // Allocate a buffer for the serialized request.\n  asylo::primitives::Extent request;\n  asylo::primitives::PrimitiveStatus status;\n  status = asylo::system_call::SerializeRequest(sysno, parameters, &request);\n  if (!status.ok()) {\n    error_handler(\n        \"system_call.cc: Encountered serialization error when serializing \"\n        \"syscall parameters.\");\n  }\n\n  std::unique_ptr<uint8_t, MallocDeleter> request_owner(request.As<uint8_t>());\n\n  // Invoke the system call dispatch callback to execute the system call.\n  uint8_t *response_buffer;\n  size_t response_size;\n\n  if (!enc_is_syscall_dispatcher_set()) {\n    error_handler(\"system_.cc: system call dispatcher not set.\");\n  }\n  status = global_syscall_callback(request.As<uint8_t>(), request.size(),\n                                   &response_buffer, &response_size);\n  if (!status.ok()) {\n    error_handler(\n        \"system_call.cc: Callback from syscall dispatcher was unsuccessful.\");\n  }\n\n  std::unique_ptr<uint8_t, MallocDeleter> response_owner(response_buffer);\n\n  if (!response_buffer) {\n    error_handler(\n        \"system_call.cc: null response buffer received for the syscall.\");\n  }\n\n  // Copy outputs back into pointer parameters.\n  auto response_reader =\n      asylo::system_call::MessageReader({response_buffer, response_size});\n  if (response_reader.sysno() != sysno) {\n    error_handler(\"system_call.cc: Unexpected sysno in response\");\n  }\n  const asylo::primitives::PrimitiveStatus response_status =\n      response_reader.Validate();\n  if (!response_status.ok()) {\n    error_handler(\n        \"system_call.cc: Error deserializing response buffer into response \"\n        \"reader.\");\n  }\n\n  for (int i = 0; i < asylo::system_call::kParameterMax; i++) {\n    asylo::system_call::ParameterDescriptor parameter = descriptor.parameter(i);\n    if (parameter.is_out()) {\n      size_t size;\n      if (parameter.is_fixed()) {\n        size = parameter.size();\n      } else {\n        size = parameters[parameter.size()] * parameter.element_size();\n      }\n      const void *src = response_reader.parameter_address(i);\n      void *dst = reinterpret_cast<void *>(parameters[i]);\n      if (dst != nullptr) {\n        memcpy(dst, src, size);\n      }\n    }\n  }\n\n  uint64_t result = response_reader.header()->result;\n  if (static_cast<int64_t>(result) == -1) {\n    int klinux_errno = response_reader.header()->error_number;\n\n    // Simply having a return value of -1 from a syscall is not a necessary\n    // condition that the syscall failed. Some syscalls can return -1 when\n    // successful (eg., lseek). The reliable way to check for syscall failure is\n    // to therefore check both return value and presence of a non-zero errno.\n    if (klinux_errno != 0) {\n      errno = FromkLinuxErrno(klinux_errno);\n    }\n  }\n  return result;\n}\n"], "filenames": ["asylo/platform/system_call/system_call.cc"], "buggy_code_start_loc": [117], "buggy_code_end_loc": [117], "fixing_code_start_loc": [118], "fixing_code_end_loc": [121], "type": "CWE-125", "message": "An untrusted memory read vulnerability in Asylo versions up to 0.6.1 allows an untrusted attacker to pass a syscall number in MessageReader that is then used by sysno() and can bypass validation. This can allow the attacker to read memory from within the secure enclave. We recommend updating to Asylo 0.6.3 or past https://github.com/google/asylo/commit/90d7619e9dd99bcdb6cd28c7649d741d254d9a1a", "other": {"cve": {"id": "CVE-2021-22552", "sourceIdentifier": "cve-coordination@google.com", "published": "2021-08-02T16:15:07.817", "lastModified": "2021-08-10T19:51:18.330", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An untrusted memory read vulnerability in Asylo versions up to 0.6.1 allows an untrusted attacker to pass a syscall number in MessageReader that is then used by sysno() and can bypass validation. This can allow the attacker to read memory from within the secure enclave. We recommend updating to Asylo 0.6.3 or past https://github.com/google/asylo/commit/90d7619e9dd99bcdb6cd28c7649d741d254d9a1a"}, {"lang": "es", "value": "Una vulnerabilidad de lectura de memoria no confiable en Asylo versiones hasta 0.6.1, permite a un atacante no confiable pasar un n\u00famero de syscall en MessageReader que luego es usado por la funci\u00f3n sysno() y puede omitir una comprobaci\u00f3n. Esto puede permitir al atacante leer la memoria desde el enclave seguro. Recomendamos actualizar a Asylo versi\u00f3n 0.6.3 o a versi\u00f3n anterior https://github.com/google/asylo/commit/90d7619e9dd99bcdb6cd28c7649d741d254d9a1a"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "cve-coordination@google.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "cve-coordination@google.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-126"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:asylo:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.6.1", "matchCriteriaId": "D3DBB15C-13B3-4E86-837A-C297F290AED4"}]}]}], "references": [{"url": "https://github.com/google/asylo/commit/90d7619e9dd99bcdb6cd28c7649d741d254d9a1a", "source": "cve-coordination@google.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/google/asylo/commit/90d7619e9dd99bcdb6cd28c7649d741d254d9a1a"}}