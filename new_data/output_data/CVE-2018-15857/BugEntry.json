{"buggy_code": ["/************************************************************\n * Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.\n *\n * Permission to use, copy, modify, and distribute this\n * software and its documentation for any purpose and without\n * fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright\n * notice and this permission notice appear in supporting\n * documentation, and that the name of Silicon Graphics not be\n * used in advertising or publicity pertaining to distribution\n * of the software without specific prior written permission.\n * Silicon Graphics makes no representation about the suitability\n * of this software for any purpose. It is provided \"as is\"\n * without any express or implied warranty.\n *\n * SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS\n * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON\n * GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL\n * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\n * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH\n * THE USE OR PERFORMANCE OF THIS SOFTWARE.\n *\n ********************************************************/\n\n/*\n * Copyright \u00a9 2012 Intel Corporation\n * Copyright \u00a9 2012 Ran Benita <ran234@gmail.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice (including the next\n * paragraph) shall be included in all copies or substantial portions of the\n * Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n * Author: Daniel Stone <daniel@fooishbar.org>\n *         Ran Benita <ran234@gmail.com>\n */\n\n#include \"xkbcomp-priv.h\"\n#include \"ast-build.h\"\n#include \"include.h\"\n\nParseCommon *\nAppendStmt(ParseCommon *to, ParseCommon *append)\n{\n    ParseCommon *iter;\n\n    if (!to)\n        return append;\n\n    for (iter = to; iter->next; iter = iter->next);\n\n    iter->next = append;\n    return to;\n}\n\nstatic ExprDef *\nExprCreate(enum expr_op_type op, enum expr_value_type type, size_t size)\n{\n    ExprDef *expr = malloc(size);\n    if (!expr)\n        return NULL;\n\n    expr->common.type = STMT_EXPR;\n    expr->common.next = NULL;\n    expr->expr.op = op;\n    expr->expr.value_type = type;\n\n    return expr;\n}\n\n#define EXPR_CREATE(type_, name_, op_, value_type_) \\\n    ExprDef *name_ = ExprCreate(op_, value_type_, sizeof(type_)); \\\n    if (!name_) \\\n        return NULL;\n\nExprDef *\nExprCreateString(xkb_atom_t str)\n{\n    EXPR_CREATE(ExprString, expr, EXPR_VALUE, EXPR_TYPE_STRING);\n    expr->string.str = str;\n    return expr;\n}\n\nExprDef *\nExprCreateInteger(int ival)\n{\n    EXPR_CREATE(ExprInteger, expr, EXPR_VALUE, EXPR_TYPE_INT);\n    expr->integer.ival = ival;\n    return expr;\n}\n\nExprDef *\nExprCreateFloat(void)\n{\n    EXPR_CREATE(ExprFloat, expr, EXPR_VALUE, EXPR_TYPE_FLOAT);\n    return expr;\n}\n\nExprDef *\nExprCreateBoolean(bool set)\n{\n    EXPR_CREATE(ExprBoolean, expr, EXPR_VALUE, EXPR_TYPE_BOOLEAN);\n    expr->boolean.set = set;\n    return expr;\n}\n\nExprDef *\nExprCreateKeyName(xkb_atom_t key_name)\n{\n    EXPR_CREATE(ExprKeyName, expr, EXPR_VALUE, EXPR_TYPE_KEYNAME);\n    expr->key_name.key_name = key_name;\n    return expr;\n}\n\nExprDef *\nExprCreateIdent(xkb_atom_t ident)\n{\n    EXPR_CREATE(ExprIdent, expr, EXPR_IDENT, EXPR_TYPE_UNKNOWN);\n    expr->ident.ident = ident;\n    return expr;\n}\n\nExprDef *\nExprCreateUnary(enum expr_op_type op, enum expr_value_type type,\n                ExprDef *child)\n{\n    EXPR_CREATE(ExprUnary, expr, op, type);\n    expr->unary.child = child;\n    return expr;\n}\n\nExprDef *\nExprCreateBinary(enum expr_op_type op, ExprDef *left, ExprDef *right)\n{\n    EXPR_CREATE(ExprBinary, expr, op, EXPR_TYPE_UNKNOWN);\n\n    if (op == EXPR_ASSIGN || left->expr.value_type == EXPR_TYPE_UNKNOWN)\n        expr->expr.value_type = right->expr.value_type;\n    else if (left->expr.value_type == right->expr.value_type ||\n             right->expr.value_type == EXPR_TYPE_UNKNOWN)\n        expr->expr.value_type = left->expr.value_type;\n    expr->binary.left = left;\n    expr->binary.right = right;\n\n    return expr;\n}\n\nExprDef *\nExprCreateFieldRef(xkb_atom_t element, xkb_atom_t field)\n{\n    EXPR_CREATE(ExprFieldRef, expr, EXPR_FIELD_REF, EXPR_TYPE_UNKNOWN);\n    expr->field_ref.element = element;\n    expr->field_ref.field = field;\n    return expr;\n}\n\nExprDef *\nExprCreateArrayRef(xkb_atom_t element, xkb_atom_t field, ExprDef *entry)\n{\n    EXPR_CREATE(ExprArrayRef, expr, EXPR_ARRAY_REF, EXPR_TYPE_UNKNOWN);\n    expr->array_ref.element = element;\n    expr->array_ref.field = field;\n    expr->array_ref.entry = entry;\n    return expr;\n}\n\nExprDef *\nExprCreateAction(xkb_atom_t name, ExprDef *args)\n{\n    EXPR_CREATE(ExprAction, expr, EXPR_ACTION_DECL, EXPR_TYPE_UNKNOWN);\n    expr->action.name = name;\n    expr->action.args = args;\n    return expr;\n}\n\nExprDef *\nExprCreateKeysymList(xkb_keysym_t sym)\n{\n    EXPR_CREATE(ExprKeysymList, expr, EXPR_KEYSYM_LIST, EXPR_TYPE_SYMBOLS);\n\n    darray_init(expr->keysym_list.syms);\n    darray_init(expr->keysym_list.symsMapIndex);\n    darray_init(expr->keysym_list.symsNumEntries);\n\n    darray_append(expr->keysym_list.syms, sym);\n    darray_append(expr->keysym_list.symsMapIndex, 0);\n    darray_append(expr->keysym_list.symsNumEntries, 1);\n\n    return expr;\n}\n\nExprDef *\nExprCreateMultiKeysymList(ExprDef *expr)\n{\n    unsigned nLevels = darray_size(expr->keysym_list.symsMapIndex);\n\n    darray_resize(expr->keysym_list.symsMapIndex, 1);\n    darray_resize(expr->keysym_list.symsNumEntries, 1);\n    darray_item(expr->keysym_list.symsMapIndex, 0) = 0;\n    darray_item(expr->keysym_list.symsNumEntries, 0) = nLevels;\n\n    return expr;\n}\n\nExprDef *\nExprAppendKeysymList(ExprDef *expr, xkb_keysym_t sym)\n{\n    unsigned nSyms = darray_size(expr->keysym_list.syms);\n\n    darray_append(expr->keysym_list.symsMapIndex, nSyms);\n    darray_append(expr->keysym_list.symsNumEntries, 1);\n    darray_append(expr->keysym_list.syms, sym);\n\n    return expr;\n}\n\nExprDef *\nExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)\n{\n    unsigned nSyms = darray_size(expr->keysym_list.syms);\n    unsigned numEntries = darray_size(append->keysym_list.syms);\n\n    darray_append(expr->keysym_list.symsMapIndex, nSyms);\n    darray_append(expr->keysym_list.symsNumEntries, numEntries);\n    darray_concat(expr->keysym_list.syms, append->keysym_list.syms);\n\n    FreeStmt((ParseCommon *) &append);\n\n    return expr;\n}\n\nKeycodeDef *\nKeycodeCreate(xkb_atom_t name, int64_t value)\n{\n    KeycodeDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_KEYCODE;\n    def->common.next = NULL;\n    def->name = name;\n    def->value = value;\n\n    return def;\n}\n\nKeyAliasDef *\nKeyAliasCreate(xkb_atom_t alias, xkb_atom_t real)\n{\n    KeyAliasDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_ALIAS;\n    def->common.next = NULL;\n    def->alias = alias;\n    def->real = real;\n\n    return def;\n}\n\nVModDef *\nVModCreate(xkb_atom_t name, ExprDef *value)\n{\n    VModDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_VMOD;\n    def->common.next = NULL;\n    def->name = name;\n    def->value = value;\n\n    return def;\n}\n\nVarDef *\nVarCreate(ExprDef *name, ExprDef *value)\n{\n    VarDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_VAR;\n    def->common.next = NULL;\n    def->name = name;\n    def->value = value;\n\n    return def;\n}\n\nVarDef *\nBoolVarCreate(xkb_atom_t ident, bool set)\n{\n    ExprDef *name, *value;\n    VarDef *def;\n    if (!(name = ExprCreateIdent(ident))) {\n        return NULL;\n    }\n    if (!(value = ExprCreateBoolean(set))) {\n        FreeStmt((ParseCommon *) name);\n        return NULL;\n    }\n    if (!(def = VarCreate(name, value))) {\n        FreeStmt((ParseCommon *) name);\n        FreeStmt((ParseCommon *) value);\n        return NULL;\n    }\n    return def;\n}\n\nInterpDef *\nInterpCreate(xkb_keysym_t sym, ExprDef *match)\n{\n    InterpDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_INTERP;\n    def->common.next = NULL;\n    def->sym = sym;\n    def->match = match;\n    def->def = NULL;\n\n    return def;\n}\n\nKeyTypeDef *\nKeyTypeCreate(xkb_atom_t name, VarDef *body)\n{\n    KeyTypeDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_TYPE;\n    def->common.next = NULL;\n    def->merge = MERGE_DEFAULT;\n    def->name = name;\n    def->body = body;\n\n    return def;\n}\n\nSymbolsDef *\nSymbolsCreate(xkb_atom_t keyName, VarDef *symbols)\n{\n    SymbolsDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_SYMBOLS;\n    def->common.next = NULL;\n    def->merge = MERGE_DEFAULT;\n    def->keyName = keyName;\n    def->symbols = symbols;\n\n    return def;\n}\n\nGroupCompatDef *\nGroupCompatCreate(unsigned group, ExprDef *val)\n{\n    GroupCompatDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_GROUP_COMPAT;\n    def->common.next = NULL;\n    def->merge = MERGE_DEFAULT;\n    def->group = group;\n    def->def = val;\n\n    return def;\n}\n\nModMapDef *\nModMapCreate(xkb_atom_t modifier, ExprDef *keys)\n{\n    ModMapDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_MODMAP;\n    def->common.next = NULL;\n    def->merge = MERGE_DEFAULT;\n    def->modifier = modifier;\n    def->keys = keys;\n\n    return def;\n}\n\nLedMapDef *\nLedMapCreate(xkb_atom_t name, VarDef *body)\n{\n    LedMapDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_LED_MAP;\n    def->common.next = NULL;\n    def->merge = MERGE_DEFAULT;\n    def->name = name;\n    def->body = body;\n\n    return def;\n}\n\nLedNameDef *\nLedNameCreate(unsigned ndx, ExprDef *name, bool virtual)\n{\n    LedNameDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_LED_NAME;\n    def->common.next = NULL;\n    def->merge = MERGE_DEFAULT;\n    def->ndx = ndx;\n    def->name = name;\n    def->virtual = virtual;\n\n    return def;\n}\n\nstatic void\nFreeInclude(IncludeStmt *incl);\n\nIncludeStmt *\nIncludeCreate(struct xkb_context *ctx, char *str, enum merge_mode merge)\n{\n    IncludeStmt *incl, *first;\n    char *file, *map, *stmt, *tmp, *extra_data;\n    char nextop;\n\n    incl = first = NULL;\n    file = map = NULL;\n    tmp = str;\n    stmt = strdup_safe(str);\n    while (tmp && *tmp)\n    {\n        if (!ParseIncludeMap(&tmp, &file, &map, &nextop, &extra_data))\n            goto err;\n\n        /*\n         * Given an RMLVO (here layout) like 'us,,fr', the rules parser\n         * will give out something like 'pc+us+:2+fr:3+inet(evdev)'.\n         * We should just skip the ':2' in this case and leave it to the\n         * appropriate section to deal with the empty group.\n         */\n        if (isempty(file)) {\n            free(file);\n            free(map);\n            free(extra_data);\n            continue;\n        }\n\n        if (first == NULL) {\n            first = incl = malloc(sizeof(*first));\n        } else {\n            incl->next_incl = malloc(sizeof(*first));\n            incl = incl->next_incl;\n        }\n\n        if (!incl)\n            break;\n\n        incl->common.type = STMT_INCLUDE;\n        incl->common.next = NULL;\n        incl->merge = merge;\n        incl->stmt = NULL;\n        incl->file = file;\n        incl->map = map;\n        incl->modifier = extra_data;\n        incl->next_incl = NULL;\n\n        if (nextop == '|')\n            merge = MERGE_AUGMENT;\n        else\n            merge = MERGE_OVERRIDE;\n    }\n\n    if (first)\n        first->stmt = stmt;\n    else\n        free(stmt);\n\n    return first;\n\nerr:\n    log_err(ctx, \"Illegal include statement \\\"%s\\\"; Ignored\\n\", stmt);\n    FreeInclude(first);\n    free(stmt);\n    return NULL;\n}\n\nXkbFile *\nXkbFileCreate(enum xkb_file_type type, char *name, ParseCommon *defs,\n              enum xkb_map_flags flags)\n{\n    XkbFile *file;\n\n    file = calloc(1, sizeof(*file));\n    if (!file)\n        return NULL;\n\n    XkbEscapeMapName(name);\n    file->file_type = type;\n    file->name = name ? name : strdup(\"(unnamed)\");\n    file->defs = defs;\n    file->flags = flags;\n\n    return file;\n}\n\nXkbFile *\nXkbFileFromComponents(struct xkb_context *ctx,\n                      const struct xkb_component_names *kkctgs)\n{\n    char *const components[] = {\n        kkctgs->keycodes, kkctgs->types,\n        kkctgs->compat, kkctgs->symbols,\n    };\n    enum xkb_file_type type;\n    IncludeStmt *include = NULL;\n    XkbFile *file = NULL;\n    ParseCommon *defs = NULL;\n\n    for (type = FIRST_KEYMAP_FILE_TYPE; type <= LAST_KEYMAP_FILE_TYPE; type++) {\n        include = IncludeCreate(ctx, components[type], MERGE_DEFAULT);\n        if (!include)\n            goto err;\n\n        file = XkbFileCreate(type, NULL, (ParseCommon *) include, 0);\n        if (!file) {\n            FreeInclude(include);\n            goto err;\n        }\n\n        defs = AppendStmt(defs, &file->common);\n    }\n\n    file = XkbFileCreate(FILE_TYPE_KEYMAP, NULL, defs, 0);\n    if (!file)\n        goto err;\n\n    return file;\n\nerr:\n    FreeXkbFile((XkbFile *) defs);\n    return NULL;\n}\n\nstatic void\nFreeExpr(ExprDef *expr)\n{\n    if (!expr)\n        return;\n\n    switch (expr->expr.op) {\n    case EXPR_ACTION_LIST:\n    case EXPR_NEGATE:\n    case EXPR_UNARY_PLUS:\n    case EXPR_NOT:\n    case EXPR_INVERT:\n        FreeStmt((ParseCommon *) expr->unary.child);\n        break;\n\n    case EXPR_DIVIDE:\n    case EXPR_ADD:\n    case EXPR_SUBTRACT:\n    case EXPR_MULTIPLY:\n    case EXPR_ASSIGN:\n        FreeStmt((ParseCommon *) expr->binary.left);\n        FreeStmt((ParseCommon *) expr->binary.right);\n        break;\n\n    case EXPR_ACTION_DECL:\n        FreeStmt((ParseCommon *) expr->action.args);\n        break;\n\n    case EXPR_ARRAY_REF:\n        FreeStmt((ParseCommon *) expr->array_ref.entry);\n        break;\n\n    case EXPR_KEYSYM_LIST:\n        darray_free(expr->keysym_list.syms);\n        darray_free(expr->keysym_list.symsMapIndex);\n        darray_free(expr->keysym_list.symsNumEntries);\n        break;\n\n    default:\n        break;\n    }\n}\n\nstatic void\nFreeInclude(IncludeStmt *incl)\n{\n    IncludeStmt *next;\n\n    while (incl)\n    {\n        next = incl->next_incl;\n\n        free(incl->file);\n        free(incl->map);\n        free(incl->modifier);\n        free(incl->stmt);\n\n        free(incl);\n        incl = next;\n    }\n}\n\nvoid\nFreeStmt(ParseCommon *stmt)\n{\n    ParseCommon *next;\n\n    while (stmt)\n    {\n        next = stmt->next;\n\n        switch (stmt->type) {\n        case STMT_INCLUDE:\n            FreeInclude((IncludeStmt *) stmt);\n            /* stmt is already free'd here. */\n            stmt = NULL;\n            break;\n        case STMT_EXPR:\n            FreeExpr((ExprDef *) stmt);\n            break;\n        case STMT_VAR:\n            FreeStmt((ParseCommon *) ((VarDef *) stmt)->name);\n            FreeStmt((ParseCommon *) ((VarDef *) stmt)->value);\n            break;\n        case STMT_TYPE:\n            FreeStmt((ParseCommon *) ((KeyTypeDef *) stmt)->body);\n            break;\n        case STMT_INTERP:\n            FreeStmt((ParseCommon *) ((InterpDef *) stmt)->match);\n            FreeStmt((ParseCommon *) ((InterpDef *) stmt)->def);\n            break;\n        case STMT_VMOD:\n            FreeStmt((ParseCommon *) ((VModDef *) stmt)->value);\n            break;\n        case STMT_SYMBOLS:\n            FreeStmt((ParseCommon *) ((SymbolsDef *) stmt)->symbols);\n            break;\n        case STMT_MODMAP:\n            FreeStmt((ParseCommon *) ((ModMapDef *) stmt)->keys);\n            break;\n        case STMT_GROUP_COMPAT:\n            FreeStmt((ParseCommon *) ((GroupCompatDef *) stmt)->def);\n            break;\n        case STMT_LED_MAP:\n            FreeStmt((ParseCommon *) ((LedMapDef *) stmt)->body);\n            break;\n        case STMT_LED_NAME:\n            FreeStmt((ParseCommon *) ((LedNameDef *) stmt)->name);\n            break;\n        default:\n            break;\n        }\n\n        free(stmt);\n        stmt = next;\n    }\n}\n\nvoid\nFreeXkbFile(XkbFile *file)\n{\n    XkbFile *next;\n\n    while (file)\n    {\n        next = (XkbFile *) file->common.next;\n\n        switch (file->file_type) {\n        case FILE_TYPE_KEYMAP:\n            FreeXkbFile((XkbFile *) file->defs);\n            break;\n\n        case FILE_TYPE_TYPES:\n        case FILE_TYPE_COMPAT:\n        case FILE_TYPE_SYMBOLS:\n        case FILE_TYPE_KEYCODES:\n        case FILE_TYPE_GEOMETRY:\n            FreeStmt(file->defs);\n            break;\n\n        default:\n            break;\n        }\n\n        free(file->name);\n        free(file);\n        file = next;\n    }\n}\n\nstatic const char *xkb_file_type_strings[_FILE_TYPE_NUM_ENTRIES] = {\n    [FILE_TYPE_KEYCODES] = \"xkb_keycodes\",\n    [FILE_TYPE_TYPES] = \"xkb_types\",\n    [FILE_TYPE_COMPAT] = \"xkb_compatibility\",\n    [FILE_TYPE_SYMBOLS] = \"xkb_symbols\",\n    [FILE_TYPE_GEOMETRY] = \"xkb_geometry\",\n    [FILE_TYPE_KEYMAP] = \"xkb_keymap\",\n    [FILE_TYPE_RULES] = \"rules\",\n};\n\nconst char *\nxkb_file_type_to_string(enum xkb_file_type type)\n{\n    if (type > _FILE_TYPE_NUM_ENTRIES)\n        return \"unknown\";\n    return xkb_file_type_strings[type];\n}\n\nstatic const char *stmt_type_strings[_STMT_NUM_VALUES] = {\n    [STMT_UNKNOWN] = \"unknown statement\",\n    [STMT_INCLUDE] = \"include statement\",\n    [STMT_KEYCODE] = \"key name definition\",\n    [STMT_ALIAS] = \"key alias definition\",\n    [STMT_EXPR] = \"expression\",\n    [STMT_VAR] = \"variable definition\",\n    [STMT_TYPE] = \"key type definition\",\n    [STMT_INTERP] = \"symbol interpretation definition\",\n    [STMT_VMOD] = \"virtual modifiers definition\",\n    [STMT_SYMBOLS] = \"key symbols definition\",\n    [STMT_MODMAP] = \"modifier map declaration\",\n    [STMT_GROUP_COMPAT] = \"group declaration\",\n    [STMT_LED_MAP] = \"indicator map declaration\",\n    [STMT_LED_NAME] = \"indicator name declaration\",\n};\n\nconst char *\nstmt_type_to_string(enum stmt_type type)\n{\n    if (type >= _STMT_NUM_VALUES)\n        return NULL;\n    return stmt_type_strings[type];\n}\n\nstatic const char *expr_op_type_strings[_EXPR_NUM_VALUES] = {\n    [EXPR_VALUE] = \"literal\",\n    [EXPR_IDENT] = \"identifier\",\n    [EXPR_ACTION_DECL] = \"action declaration\",\n    [EXPR_FIELD_REF] = \"field reference\",\n    [EXPR_ARRAY_REF] = \"array reference\",\n    [EXPR_KEYSYM_LIST] = \"list of keysyms\",\n    [EXPR_ACTION_LIST] = \"list of actions\",\n    [EXPR_ADD] = \"addition\",\n    [EXPR_SUBTRACT] = \"subtraction\",\n    [EXPR_MULTIPLY] = \"multiplication\",\n    [EXPR_DIVIDE] = \"division\",\n    [EXPR_ASSIGN] = \"assignment\",\n    [EXPR_NOT] = \"logical negation\",\n    [EXPR_NEGATE] = \"arithmetic negation\",\n    [EXPR_INVERT] = \"bitwise inversion\",\n    [EXPR_UNARY_PLUS] = \"unary plus\",\n};\n\nconst char *\nexpr_op_type_to_string(enum expr_op_type type)\n{\n    if (type >= _EXPR_NUM_VALUES)\n        return NULL;\n    return expr_op_type_strings[type];\n}\n\nstatic const char *expr_value_type_strings[_EXPR_TYPE_NUM_VALUES] = {\n    [EXPR_TYPE_UNKNOWN] = \"unknown\",\n    [EXPR_TYPE_BOOLEAN] = \"boolean\",\n    [EXPR_TYPE_INT] = \"int\",\n    [EXPR_TYPE_FLOAT] = \"float\",\n    [EXPR_TYPE_STRING] = \"string\",\n    [EXPR_TYPE_ACTION] = \"action\",\n    [EXPR_TYPE_KEYNAME] = \"keyname\",\n    [EXPR_TYPE_SYMBOLS] = \"symbols\",\n};\n\nconst char *\nexpr_value_type_to_string(enum expr_value_type type)\n{\n    if (type >= _EXPR_TYPE_NUM_VALUES)\n        return NULL;\n    return expr_value_type_strings[type];\n}\n"], "fixing_code": ["/************************************************************\n * Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.\n *\n * Permission to use, copy, modify, and distribute this\n * software and its documentation for any purpose and without\n * fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright\n * notice and this permission notice appear in supporting\n * documentation, and that the name of Silicon Graphics not be\n * used in advertising or publicity pertaining to distribution\n * of the software without specific prior written permission.\n * Silicon Graphics makes no representation about the suitability\n * of this software for any purpose. It is provided \"as is\"\n * without any express or implied warranty.\n *\n * SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS\n * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON\n * GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL\n * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\n * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH\n * THE USE OR PERFORMANCE OF THIS SOFTWARE.\n *\n ********************************************************/\n\n/*\n * Copyright \u00a9 2012 Intel Corporation\n * Copyright \u00a9 2012 Ran Benita <ran234@gmail.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice (including the next\n * paragraph) shall be included in all copies or substantial portions of the\n * Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n * Author: Daniel Stone <daniel@fooishbar.org>\n *         Ran Benita <ran234@gmail.com>\n */\n\n#include \"xkbcomp-priv.h\"\n#include \"ast-build.h\"\n#include \"include.h\"\n\nParseCommon *\nAppendStmt(ParseCommon *to, ParseCommon *append)\n{\n    ParseCommon *iter;\n\n    if (!to)\n        return append;\n\n    for (iter = to; iter->next; iter = iter->next);\n\n    iter->next = append;\n    return to;\n}\n\nstatic ExprDef *\nExprCreate(enum expr_op_type op, enum expr_value_type type, size_t size)\n{\n    ExprDef *expr = malloc(size);\n    if (!expr)\n        return NULL;\n\n    expr->common.type = STMT_EXPR;\n    expr->common.next = NULL;\n    expr->expr.op = op;\n    expr->expr.value_type = type;\n\n    return expr;\n}\n\n#define EXPR_CREATE(type_, name_, op_, value_type_) \\\n    ExprDef *name_ = ExprCreate(op_, value_type_, sizeof(type_)); \\\n    if (!name_) \\\n        return NULL;\n\nExprDef *\nExprCreateString(xkb_atom_t str)\n{\n    EXPR_CREATE(ExprString, expr, EXPR_VALUE, EXPR_TYPE_STRING);\n    expr->string.str = str;\n    return expr;\n}\n\nExprDef *\nExprCreateInteger(int ival)\n{\n    EXPR_CREATE(ExprInteger, expr, EXPR_VALUE, EXPR_TYPE_INT);\n    expr->integer.ival = ival;\n    return expr;\n}\n\nExprDef *\nExprCreateFloat(void)\n{\n    EXPR_CREATE(ExprFloat, expr, EXPR_VALUE, EXPR_TYPE_FLOAT);\n    return expr;\n}\n\nExprDef *\nExprCreateBoolean(bool set)\n{\n    EXPR_CREATE(ExprBoolean, expr, EXPR_VALUE, EXPR_TYPE_BOOLEAN);\n    expr->boolean.set = set;\n    return expr;\n}\n\nExprDef *\nExprCreateKeyName(xkb_atom_t key_name)\n{\n    EXPR_CREATE(ExprKeyName, expr, EXPR_VALUE, EXPR_TYPE_KEYNAME);\n    expr->key_name.key_name = key_name;\n    return expr;\n}\n\nExprDef *\nExprCreateIdent(xkb_atom_t ident)\n{\n    EXPR_CREATE(ExprIdent, expr, EXPR_IDENT, EXPR_TYPE_UNKNOWN);\n    expr->ident.ident = ident;\n    return expr;\n}\n\nExprDef *\nExprCreateUnary(enum expr_op_type op, enum expr_value_type type,\n                ExprDef *child)\n{\n    EXPR_CREATE(ExprUnary, expr, op, type);\n    expr->unary.child = child;\n    return expr;\n}\n\nExprDef *\nExprCreateBinary(enum expr_op_type op, ExprDef *left, ExprDef *right)\n{\n    EXPR_CREATE(ExprBinary, expr, op, EXPR_TYPE_UNKNOWN);\n\n    if (op == EXPR_ASSIGN || left->expr.value_type == EXPR_TYPE_UNKNOWN)\n        expr->expr.value_type = right->expr.value_type;\n    else if (left->expr.value_type == right->expr.value_type ||\n             right->expr.value_type == EXPR_TYPE_UNKNOWN)\n        expr->expr.value_type = left->expr.value_type;\n    expr->binary.left = left;\n    expr->binary.right = right;\n\n    return expr;\n}\n\nExprDef *\nExprCreateFieldRef(xkb_atom_t element, xkb_atom_t field)\n{\n    EXPR_CREATE(ExprFieldRef, expr, EXPR_FIELD_REF, EXPR_TYPE_UNKNOWN);\n    expr->field_ref.element = element;\n    expr->field_ref.field = field;\n    return expr;\n}\n\nExprDef *\nExprCreateArrayRef(xkb_atom_t element, xkb_atom_t field, ExprDef *entry)\n{\n    EXPR_CREATE(ExprArrayRef, expr, EXPR_ARRAY_REF, EXPR_TYPE_UNKNOWN);\n    expr->array_ref.element = element;\n    expr->array_ref.field = field;\n    expr->array_ref.entry = entry;\n    return expr;\n}\n\nExprDef *\nExprCreateAction(xkb_atom_t name, ExprDef *args)\n{\n    EXPR_CREATE(ExprAction, expr, EXPR_ACTION_DECL, EXPR_TYPE_UNKNOWN);\n    expr->action.name = name;\n    expr->action.args = args;\n    return expr;\n}\n\nExprDef *\nExprCreateKeysymList(xkb_keysym_t sym)\n{\n    EXPR_CREATE(ExprKeysymList, expr, EXPR_KEYSYM_LIST, EXPR_TYPE_SYMBOLS);\n\n    darray_init(expr->keysym_list.syms);\n    darray_init(expr->keysym_list.symsMapIndex);\n    darray_init(expr->keysym_list.symsNumEntries);\n\n    darray_append(expr->keysym_list.syms, sym);\n    darray_append(expr->keysym_list.symsMapIndex, 0);\n    darray_append(expr->keysym_list.symsNumEntries, 1);\n\n    return expr;\n}\n\nExprDef *\nExprCreateMultiKeysymList(ExprDef *expr)\n{\n    unsigned nLevels = darray_size(expr->keysym_list.symsMapIndex);\n\n    darray_resize(expr->keysym_list.symsMapIndex, 1);\n    darray_resize(expr->keysym_list.symsNumEntries, 1);\n    darray_item(expr->keysym_list.symsMapIndex, 0) = 0;\n    darray_item(expr->keysym_list.symsNumEntries, 0) = nLevels;\n\n    return expr;\n}\n\nExprDef *\nExprAppendKeysymList(ExprDef *expr, xkb_keysym_t sym)\n{\n    unsigned nSyms = darray_size(expr->keysym_list.syms);\n\n    darray_append(expr->keysym_list.symsMapIndex, nSyms);\n    darray_append(expr->keysym_list.symsNumEntries, 1);\n    darray_append(expr->keysym_list.syms, sym);\n\n    return expr;\n}\n\nExprDef *\nExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)\n{\n    unsigned nSyms = darray_size(expr->keysym_list.syms);\n    unsigned numEntries = darray_size(append->keysym_list.syms);\n\n    darray_append(expr->keysym_list.symsMapIndex, nSyms);\n    darray_append(expr->keysym_list.symsNumEntries, numEntries);\n    darray_concat(expr->keysym_list.syms, append->keysym_list.syms);\n\n    FreeStmt((ParseCommon *) append);\n\n    return expr;\n}\n\nKeycodeDef *\nKeycodeCreate(xkb_atom_t name, int64_t value)\n{\n    KeycodeDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_KEYCODE;\n    def->common.next = NULL;\n    def->name = name;\n    def->value = value;\n\n    return def;\n}\n\nKeyAliasDef *\nKeyAliasCreate(xkb_atom_t alias, xkb_atom_t real)\n{\n    KeyAliasDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_ALIAS;\n    def->common.next = NULL;\n    def->alias = alias;\n    def->real = real;\n\n    return def;\n}\n\nVModDef *\nVModCreate(xkb_atom_t name, ExprDef *value)\n{\n    VModDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_VMOD;\n    def->common.next = NULL;\n    def->name = name;\n    def->value = value;\n\n    return def;\n}\n\nVarDef *\nVarCreate(ExprDef *name, ExprDef *value)\n{\n    VarDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_VAR;\n    def->common.next = NULL;\n    def->name = name;\n    def->value = value;\n\n    return def;\n}\n\nVarDef *\nBoolVarCreate(xkb_atom_t ident, bool set)\n{\n    ExprDef *name, *value;\n    VarDef *def;\n    if (!(name = ExprCreateIdent(ident))) {\n        return NULL;\n    }\n    if (!(value = ExprCreateBoolean(set))) {\n        FreeStmt((ParseCommon *) name);\n        return NULL;\n    }\n    if (!(def = VarCreate(name, value))) {\n        FreeStmt((ParseCommon *) name);\n        FreeStmt((ParseCommon *) value);\n        return NULL;\n    }\n    return def;\n}\n\nInterpDef *\nInterpCreate(xkb_keysym_t sym, ExprDef *match)\n{\n    InterpDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_INTERP;\n    def->common.next = NULL;\n    def->sym = sym;\n    def->match = match;\n    def->def = NULL;\n\n    return def;\n}\n\nKeyTypeDef *\nKeyTypeCreate(xkb_atom_t name, VarDef *body)\n{\n    KeyTypeDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_TYPE;\n    def->common.next = NULL;\n    def->merge = MERGE_DEFAULT;\n    def->name = name;\n    def->body = body;\n\n    return def;\n}\n\nSymbolsDef *\nSymbolsCreate(xkb_atom_t keyName, VarDef *symbols)\n{\n    SymbolsDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_SYMBOLS;\n    def->common.next = NULL;\n    def->merge = MERGE_DEFAULT;\n    def->keyName = keyName;\n    def->symbols = symbols;\n\n    return def;\n}\n\nGroupCompatDef *\nGroupCompatCreate(unsigned group, ExprDef *val)\n{\n    GroupCompatDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_GROUP_COMPAT;\n    def->common.next = NULL;\n    def->merge = MERGE_DEFAULT;\n    def->group = group;\n    def->def = val;\n\n    return def;\n}\n\nModMapDef *\nModMapCreate(xkb_atom_t modifier, ExprDef *keys)\n{\n    ModMapDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_MODMAP;\n    def->common.next = NULL;\n    def->merge = MERGE_DEFAULT;\n    def->modifier = modifier;\n    def->keys = keys;\n\n    return def;\n}\n\nLedMapDef *\nLedMapCreate(xkb_atom_t name, VarDef *body)\n{\n    LedMapDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_LED_MAP;\n    def->common.next = NULL;\n    def->merge = MERGE_DEFAULT;\n    def->name = name;\n    def->body = body;\n\n    return def;\n}\n\nLedNameDef *\nLedNameCreate(unsigned ndx, ExprDef *name, bool virtual)\n{\n    LedNameDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_LED_NAME;\n    def->common.next = NULL;\n    def->merge = MERGE_DEFAULT;\n    def->ndx = ndx;\n    def->name = name;\n    def->virtual = virtual;\n\n    return def;\n}\n\nstatic void\nFreeInclude(IncludeStmt *incl);\n\nIncludeStmt *\nIncludeCreate(struct xkb_context *ctx, char *str, enum merge_mode merge)\n{\n    IncludeStmt *incl, *first;\n    char *file, *map, *stmt, *tmp, *extra_data;\n    char nextop;\n\n    incl = first = NULL;\n    file = map = NULL;\n    tmp = str;\n    stmt = strdup_safe(str);\n    while (tmp && *tmp)\n    {\n        if (!ParseIncludeMap(&tmp, &file, &map, &nextop, &extra_data))\n            goto err;\n\n        /*\n         * Given an RMLVO (here layout) like 'us,,fr', the rules parser\n         * will give out something like 'pc+us+:2+fr:3+inet(evdev)'.\n         * We should just skip the ':2' in this case and leave it to the\n         * appropriate section to deal with the empty group.\n         */\n        if (isempty(file)) {\n            free(file);\n            free(map);\n            free(extra_data);\n            continue;\n        }\n\n        if (first == NULL) {\n            first = incl = malloc(sizeof(*first));\n        } else {\n            incl->next_incl = malloc(sizeof(*first));\n            incl = incl->next_incl;\n        }\n\n        if (!incl)\n            break;\n\n        incl->common.type = STMT_INCLUDE;\n        incl->common.next = NULL;\n        incl->merge = merge;\n        incl->stmt = NULL;\n        incl->file = file;\n        incl->map = map;\n        incl->modifier = extra_data;\n        incl->next_incl = NULL;\n\n        if (nextop == '|')\n            merge = MERGE_AUGMENT;\n        else\n            merge = MERGE_OVERRIDE;\n    }\n\n    if (first)\n        first->stmt = stmt;\n    else\n        free(stmt);\n\n    return first;\n\nerr:\n    log_err(ctx, \"Illegal include statement \\\"%s\\\"; Ignored\\n\", stmt);\n    FreeInclude(first);\n    free(stmt);\n    return NULL;\n}\n\nXkbFile *\nXkbFileCreate(enum xkb_file_type type, char *name, ParseCommon *defs,\n              enum xkb_map_flags flags)\n{\n    XkbFile *file;\n\n    file = calloc(1, sizeof(*file));\n    if (!file)\n        return NULL;\n\n    XkbEscapeMapName(name);\n    file->file_type = type;\n    file->name = name ? name : strdup(\"(unnamed)\");\n    file->defs = defs;\n    file->flags = flags;\n\n    return file;\n}\n\nXkbFile *\nXkbFileFromComponents(struct xkb_context *ctx,\n                      const struct xkb_component_names *kkctgs)\n{\n    char *const components[] = {\n        kkctgs->keycodes, kkctgs->types,\n        kkctgs->compat, kkctgs->symbols,\n    };\n    enum xkb_file_type type;\n    IncludeStmt *include = NULL;\n    XkbFile *file = NULL;\n    ParseCommon *defs = NULL;\n\n    for (type = FIRST_KEYMAP_FILE_TYPE; type <= LAST_KEYMAP_FILE_TYPE; type++) {\n        include = IncludeCreate(ctx, components[type], MERGE_DEFAULT);\n        if (!include)\n            goto err;\n\n        file = XkbFileCreate(type, NULL, (ParseCommon *) include, 0);\n        if (!file) {\n            FreeInclude(include);\n            goto err;\n        }\n\n        defs = AppendStmt(defs, &file->common);\n    }\n\n    file = XkbFileCreate(FILE_TYPE_KEYMAP, NULL, defs, 0);\n    if (!file)\n        goto err;\n\n    return file;\n\nerr:\n    FreeXkbFile((XkbFile *) defs);\n    return NULL;\n}\n\nstatic void\nFreeExpr(ExprDef *expr)\n{\n    if (!expr)\n        return;\n\n    switch (expr->expr.op) {\n    case EXPR_ACTION_LIST:\n    case EXPR_NEGATE:\n    case EXPR_UNARY_PLUS:\n    case EXPR_NOT:\n    case EXPR_INVERT:\n        FreeStmt((ParseCommon *) expr->unary.child);\n        break;\n\n    case EXPR_DIVIDE:\n    case EXPR_ADD:\n    case EXPR_SUBTRACT:\n    case EXPR_MULTIPLY:\n    case EXPR_ASSIGN:\n        FreeStmt((ParseCommon *) expr->binary.left);\n        FreeStmt((ParseCommon *) expr->binary.right);\n        break;\n\n    case EXPR_ACTION_DECL:\n        FreeStmt((ParseCommon *) expr->action.args);\n        break;\n\n    case EXPR_ARRAY_REF:\n        FreeStmt((ParseCommon *) expr->array_ref.entry);\n        break;\n\n    case EXPR_KEYSYM_LIST:\n        darray_free(expr->keysym_list.syms);\n        darray_free(expr->keysym_list.symsMapIndex);\n        darray_free(expr->keysym_list.symsNumEntries);\n        break;\n\n    default:\n        break;\n    }\n}\n\nstatic void\nFreeInclude(IncludeStmt *incl)\n{\n    IncludeStmt *next;\n\n    while (incl)\n    {\n        next = incl->next_incl;\n\n        free(incl->file);\n        free(incl->map);\n        free(incl->modifier);\n        free(incl->stmt);\n\n        free(incl);\n        incl = next;\n    }\n}\n\nvoid\nFreeStmt(ParseCommon *stmt)\n{\n    ParseCommon *next;\n\n    while (stmt)\n    {\n        next = stmt->next;\n\n        switch (stmt->type) {\n        case STMT_INCLUDE:\n            FreeInclude((IncludeStmt *) stmt);\n            /* stmt is already free'd here. */\n            stmt = NULL;\n            break;\n        case STMT_EXPR:\n            FreeExpr((ExprDef *) stmt);\n            break;\n        case STMT_VAR:\n            FreeStmt((ParseCommon *) ((VarDef *) stmt)->name);\n            FreeStmt((ParseCommon *) ((VarDef *) stmt)->value);\n            break;\n        case STMT_TYPE:\n            FreeStmt((ParseCommon *) ((KeyTypeDef *) stmt)->body);\n            break;\n        case STMT_INTERP:\n            FreeStmt((ParseCommon *) ((InterpDef *) stmt)->match);\n            FreeStmt((ParseCommon *) ((InterpDef *) stmt)->def);\n            break;\n        case STMT_VMOD:\n            FreeStmt((ParseCommon *) ((VModDef *) stmt)->value);\n            break;\n        case STMT_SYMBOLS:\n            FreeStmt((ParseCommon *) ((SymbolsDef *) stmt)->symbols);\n            break;\n        case STMT_MODMAP:\n            FreeStmt((ParseCommon *) ((ModMapDef *) stmt)->keys);\n            break;\n        case STMT_GROUP_COMPAT:\n            FreeStmt((ParseCommon *) ((GroupCompatDef *) stmt)->def);\n            break;\n        case STMT_LED_MAP:\n            FreeStmt((ParseCommon *) ((LedMapDef *) stmt)->body);\n            break;\n        case STMT_LED_NAME:\n            FreeStmt((ParseCommon *) ((LedNameDef *) stmt)->name);\n            break;\n        default:\n            break;\n        }\n\n        free(stmt);\n        stmt = next;\n    }\n}\n\nvoid\nFreeXkbFile(XkbFile *file)\n{\n    XkbFile *next;\n\n    while (file)\n    {\n        next = (XkbFile *) file->common.next;\n\n        switch (file->file_type) {\n        case FILE_TYPE_KEYMAP:\n            FreeXkbFile((XkbFile *) file->defs);\n            break;\n\n        case FILE_TYPE_TYPES:\n        case FILE_TYPE_COMPAT:\n        case FILE_TYPE_SYMBOLS:\n        case FILE_TYPE_KEYCODES:\n        case FILE_TYPE_GEOMETRY:\n            FreeStmt(file->defs);\n            break;\n\n        default:\n            break;\n        }\n\n        free(file->name);\n        free(file);\n        file = next;\n    }\n}\n\nstatic const char *xkb_file_type_strings[_FILE_TYPE_NUM_ENTRIES] = {\n    [FILE_TYPE_KEYCODES] = \"xkb_keycodes\",\n    [FILE_TYPE_TYPES] = \"xkb_types\",\n    [FILE_TYPE_COMPAT] = \"xkb_compatibility\",\n    [FILE_TYPE_SYMBOLS] = \"xkb_symbols\",\n    [FILE_TYPE_GEOMETRY] = \"xkb_geometry\",\n    [FILE_TYPE_KEYMAP] = \"xkb_keymap\",\n    [FILE_TYPE_RULES] = \"rules\",\n};\n\nconst char *\nxkb_file_type_to_string(enum xkb_file_type type)\n{\n    if (type > _FILE_TYPE_NUM_ENTRIES)\n        return \"unknown\";\n    return xkb_file_type_strings[type];\n}\n\nstatic const char *stmt_type_strings[_STMT_NUM_VALUES] = {\n    [STMT_UNKNOWN] = \"unknown statement\",\n    [STMT_INCLUDE] = \"include statement\",\n    [STMT_KEYCODE] = \"key name definition\",\n    [STMT_ALIAS] = \"key alias definition\",\n    [STMT_EXPR] = \"expression\",\n    [STMT_VAR] = \"variable definition\",\n    [STMT_TYPE] = \"key type definition\",\n    [STMT_INTERP] = \"symbol interpretation definition\",\n    [STMT_VMOD] = \"virtual modifiers definition\",\n    [STMT_SYMBOLS] = \"key symbols definition\",\n    [STMT_MODMAP] = \"modifier map declaration\",\n    [STMT_GROUP_COMPAT] = \"group declaration\",\n    [STMT_LED_MAP] = \"indicator map declaration\",\n    [STMT_LED_NAME] = \"indicator name declaration\",\n};\n\nconst char *\nstmt_type_to_string(enum stmt_type type)\n{\n    if (type >= _STMT_NUM_VALUES)\n        return NULL;\n    return stmt_type_strings[type];\n}\n\nstatic const char *expr_op_type_strings[_EXPR_NUM_VALUES] = {\n    [EXPR_VALUE] = \"literal\",\n    [EXPR_IDENT] = \"identifier\",\n    [EXPR_ACTION_DECL] = \"action declaration\",\n    [EXPR_FIELD_REF] = \"field reference\",\n    [EXPR_ARRAY_REF] = \"array reference\",\n    [EXPR_KEYSYM_LIST] = \"list of keysyms\",\n    [EXPR_ACTION_LIST] = \"list of actions\",\n    [EXPR_ADD] = \"addition\",\n    [EXPR_SUBTRACT] = \"subtraction\",\n    [EXPR_MULTIPLY] = \"multiplication\",\n    [EXPR_DIVIDE] = \"division\",\n    [EXPR_ASSIGN] = \"assignment\",\n    [EXPR_NOT] = \"logical negation\",\n    [EXPR_NEGATE] = \"arithmetic negation\",\n    [EXPR_INVERT] = \"bitwise inversion\",\n    [EXPR_UNARY_PLUS] = \"unary plus\",\n};\n\nconst char *\nexpr_op_type_to_string(enum expr_op_type type)\n{\n    if (type >= _EXPR_NUM_VALUES)\n        return NULL;\n    return expr_op_type_strings[type];\n}\n\nstatic const char *expr_value_type_strings[_EXPR_TYPE_NUM_VALUES] = {\n    [EXPR_TYPE_UNKNOWN] = \"unknown\",\n    [EXPR_TYPE_BOOLEAN] = \"boolean\",\n    [EXPR_TYPE_INT] = \"int\",\n    [EXPR_TYPE_FLOAT] = \"float\",\n    [EXPR_TYPE_STRING] = \"string\",\n    [EXPR_TYPE_ACTION] = \"action\",\n    [EXPR_TYPE_KEYNAME] = \"keyname\",\n    [EXPR_TYPE_SYMBOLS] = \"symbols\",\n};\n\nconst char *\nexpr_value_type_to_string(enum expr_value_type type)\n{\n    if (type >= _EXPR_TYPE_NUM_VALUES)\n        return NULL;\n    return expr_value_type_strings[type];\n}\n"], "filenames": ["src/xkbcomp/ast-build.c"], "buggy_code_start_loc": [243], "buggy_code_end_loc": [244], "fixing_code_start_loc": [243], "fixing_code_end_loc": [244], "type": "CWE-416", "message": "An invalid free in ExprAppendMultiKeysymList in xkbcomp/ast-build.c in xkbcommon before 0.8.1 could be used by local attackers to crash xkbcommon keymap parsers or possibly have unspecified other impact by supplying a crafted keymap file.", "other": {"cve": {"id": "CVE-2018-15857", "sourceIdentifier": "cve@mitre.org", "published": "2018-08-25T21:29:01.953", "lastModified": "2019-08-06T17:15:25.383", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An invalid free in ExprAppendMultiKeysymList in xkbcomp/ast-build.c in xkbcommon before 0.8.1 could be used by local attackers to crash xkbcommon keymap parsers or possibly have unspecified other impact by supplying a crafted keymap file."}, {"lang": "es", "value": "Una liberaci\u00f3n no v\u00e1lida en ExprAppendMultiKeysymList en xkbcomp/ast-build.c en xkbcommon, en versiones anteriores a la 0.8.1, podr\u00eda ser empleada por atacantes locales para provocar el cierre inesperado de los analizadores keymap de xkbcommon o, posiblemente, lograr otro tipo de impacto sin especificar proporcionando un archivo keymap manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xkbcommon:libxkbcommon:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.8.1", "matchCriteriaId": "33CC7ED5-C297-470D-B26A-25D0EB694460"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xkbcommon:xkbcommon:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.8.1", "matchCriteriaId": "C7D955F4-3540-42A7-8551-EA1A266DDEA6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2019:2079", "source": "cve@mitre.org"}, {"url": "https://github.com/xkbcommon/libxkbcommon/commit/c1e5ac16e77a21f87bdf3bc4dea61b037a17dddb", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.freedesktop.org/archives/wayland-devel/2018-August/039232.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201810-05", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3786-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3786-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/xkbcommon/libxkbcommon/commit/c1e5ac16e77a21f87bdf3bc4dea61b037a17dddb"}}