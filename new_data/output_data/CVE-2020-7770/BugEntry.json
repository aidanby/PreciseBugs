{"buggy_code": ["# JSON8 Merge Patch\n\n## Introduction\n\nJSON Merge Patch [RFC 7396](https://tools.ietf.org/html/rfc7396) toolkit for JavaScript.\n\n---\n\n- [Introduction](#introduction)\n- [Getting started](#getting-started)\n- [Methods](#methods)\n  - [apply](#apply)\n  - [patch](#patch)\n  - [diff](#diff)\n\n## Getting started\n\n`npm install json8-merge-patch`\n\n---\n\n```javascript\nconst mergePatch = require(\"json8-merge-patch\");\n```\n\n[\u2191](#json8-merge-patch)\n\n## Methods\n\n### apply\n\nApply a JSON Merge Patch to a JSON document.\n\n- May mutates the target document, if you wish to pass a shallow copy use [JSON8 clone](https://github.com/sonnyp/JSON8/tree/master/packages/json8#ooclone).\n- Does not validate the patch nor the target nor the result for JSON correctness, use [JSON8 valid](https://github.com/sonnyp/JSON8/tree/master/packages/json8#oovalid).\n\n```javascript\ndoc = mergePatch.apply(doc, mergePatch);\n```\n\n```javascript\nlet person = {\n  \"name\": \"John Doe\",\n  \"friendly\": true,\n  \"age\": 18,\n  \"address\": {\n    \"country\": \"France\"\n  }\n}\n\nconst patch = {\n  \"age\": 19,\n  \"friendly\": \"maybe\"\n  \"address\": {\n    \"country\": null\n  }\n}\n\nperson = mergePatch.apply(person, patch)\n/*\n{\n  \"name\": \"John Doe\",\n  \"friendly\": \"maybe\",\n  \"age\": 19,\n  \"address\": {}\n}\n*/\n```\n\n[\u2191](#json8-merge-patch)\n\n### patch\n\nAlias for [apply](#apply) method.\n\n[\u2191](#json8-merge-patch)\n\n### diff\n\nCompares two JSON documents and returns a JSON Merge Patch.\n\n```javascript\nconst a = { foo: \"bar\", bar: \"foo\" };\nconst b = { foo: \"foo\" };\n\nmergePatch.diff(a, b);\n/*\n{\n  \"foo\": \"foo\",\n  \"bar\": null\n}\n*/\n```\n\n[\u2191](#json8-merge-patch)\n", "\"use strict\";\n\nconst OBJECT = \"object\";\n\n/**\n * Apply a JSON merge patch onto a document\n * https://tools.ietf.org/html/rfc7396\n * @param  {Object} doc    - JSON object document\n * @param  {Object} patch  - JSON object patch\n * @return {Object}        - JSON object document\n */\nmodule.exports = function apply(doc, patch) {\n  if (typeof patch !== OBJECT || patch === null || Array.isArray(patch)) {\n    return patch;\n  }\n\n  if (typeof doc !== OBJECT || doc === null || Array.isArray(doc)) {\n    doc = Object.create(null);\n  }\n\n  const keys = Object.keys(patch);\n  for (const key of keys) {\n    const v = patch[key];\n    if (v === null) {\n      delete doc[key];\n      continue;\n    }\n    doc[key] = apply(doc[key], v);\n  }\n\n  return doc;\n};\n", "\"use strict\";\n\nconst assert = require(\"assert\");\nconst apply = require(\"../lib/apply\");\n\ndescribe(\"apply\", () => {\n  it(\"returns the patch argument if it's not an object\", () => {\n    [true, false, null, [], 42, \"foo\"].forEach((v) => {\n      assert.equal(apply({}, v), v);\n    });\n  });\n\n  it(\"returns an object if document argument is not an object\", () => {\n    [true, false, null, [], 42, \"foo\"].forEach((v) => {\n      const doc = apply(v, {});\n      assert.equal(typeof doc, \"object\");\n      assert(doc !== null);\n    });\n  });\n\n  it(\"deletes patch properties with value null\", () => {\n    let doc = { foo: \"bar\" };\n    doc = apply(doc, { foo: null });\n    assert.deepEqual(doc, {});\n  });\n\n  it(\"deletes nested patch properties with value null\", () => {\n    let doc = { foo: { bar: \"foo\" } };\n    doc = apply(doc, { foo: { bar: null } });\n    assert.deepEqual(doc, { foo: {} });\n  });\n\n  it(\"adds patch properties with non null value\", () => {\n    let doc = {};\n    const patch = { foo: \"bar\", bar: \"foo\" };\n    doc = apply(doc, patch);\n    assert.deepEqual(doc, patch);\n  });\n\n  it(\"adds nested patch properties with non null value\", () => {\n    let doc = {};\n    const patch = { foo: { bar: \"foo\" } };\n    doc = apply(doc, patch);\n    assert.deepEqual(doc, patch);\n  });\n\n  it(\"ignores inherited properties on patch\", () => {\n    let doc = {};\n    const patch = Object.create({ foo: \"bar\" });\n    doc = apply(doc, patch);\n    assert.deepEqual(doc, {});\n  });\n\n  // https://github.com/lodash/lodash/pull/4337\n  it(\"prevents prototype pollution\", () => {\n    let doc = {};\n    const patch = { __proto__: { foobar: true } };\n    doc = apply(doc, patch);\n\n    assert.deepEqual(doc, {});\n  });\n\n  // https://github.com/lodash/lodash/pull/4336\n  it(\"prevents constructor pollution\", () => {\n    let doc = {};\n\n    const patch = { constructor: { foo: \"bar\" } };\n    doc = apply(doc, patch);\n    assert.equal(\"foo\" in Object, false);\n    assert.equal(Object.foo, undefined);\n    assert.deepEqual(doc, patch);\n  });\n});\n"], "fixing_code": ["# JSON8 Merge Patch\n\n## Introduction\n\nJSON Merge Patch [RFC 7396](https://tools.ietf.org/html/rfc7396) toolkit for JavaScript.\n\n---\n\n- [Introduction](#introduction)\n- [Getting started](#getting-started)\n- [Methods](#methods)\n  - [apply](#apply)\n  - [patch](#patch)\n  - [diff](#diff)\n\n## Getting started\n\n`npm install json8-merge-patch`\n\n---\n\n```javascript\nconst mergePatch = require(\"json8-merge-patch\");\n```\n\n[\u2191](#json8-merge-patch)\n\n## Methods\n\n### apply\n\nApply a JSON Merge Patch to a JSON document.\n\n- May mutates the target document, if you wish to pass a shallow copy use [JSON8 clone](https://github.com/sonnyp/JSON8/tree/master/packages/json8#ooclone).\n- Does not validate the patch nor the target nor the result for JSON correctness, use [JSON8 valid](https://github.com/sonnyp/JSON8/tree/master/packages/json8#oovalid).\n\n```javascript\ndoc = mergePatch.apply(doc, mergePatch);\n```\n\n```javascript\nlet person = {\n  \"name\": \"John Doe\",\n  \"friendly\": true,\n  \"age\": 18,\n  \"address\": {\n    \"country\": \"France\"\n  }\n}\n\nconst patch = {\n  \"age\": 19,\n  \"friendly\": \"maybe\"\n  \"address\": {\n    \"country\": null\n  }\n}\n\nperson = mergePatch.apply(person, patch)\n/*\n{\n  \"name\": \"John Doe\",\n  \"friendly\": \"maybe\",\n  \"age\": 19,\n  \"address\": {}\n}\n*/\n```\n\n[\u2191](#json8-merge-patch)\n\n### object creation\n\nWhen needed, `apply` creates objects with `null` prototype, you can choose the prototype to use with `{proto: Object}` as a third argument.\n\n[\u2191](#json8-merge-patch)\n\n### prototype pollution\n\n`apply` will throw with an error if [prototype pollution](https://github.com/HoLyVieR/prototype-pollution-nsec18) is attempted. You can allow for prototype pollution by passing `{pollute: true}` as a third argument.\n\n[\u2191](#json8-merge-patch)\n\n### patch\n\nAlias for [apply](#apply) method.\n\n[\u2191](#json8-merge-patch)\n\n### diff\n\nCompares two JSON documents and returns a JSON Merge Patch.\n\n```javascript\nconst a = { foo: \"bar\", bar: \"foo\" };\nconst b = { foo: \"foo\" };\n\nmergePatch.diff(a, b);\n/*\n{\n  \"foo\": \"foo\",\n  \"bar\": null\n}\n*/\n```\n\n[\u2191](#json8-merge-patch)\n", "\"use strict\";\n\nconst OBJECT = \"object\";\n\n/**\n * Apply a JSON merge patch onto a document\n * https://tools.ietf.org/html/rfc7396\n * @param  {Object}  doc                       - JSON object document\n * @param  {Object}  patch                     - JSON object patch\n * @param  {Object}  [options]                 - options\n * @param  {Boolean} [options.pollute=false]   - Allow prototype pollution - throw otherwise\n * @param  {Object}  [options.proto=null]      - Prototype to use for object creation\n * @return {Object}                            - JSON object document\n */\nmodule.exports = function apply(doc, patch, options) {\n  if (typeof patch !== OBJECT || patch === null || Array.isArray(patch)) {\n    return patch;\n  }\n\n  options = options || Object.create(null);\n\n  if (typeof doc !== OBJECT || doc === null || Array.isArray(doc)) {\n    doc = Object.create(options.proto || null);\n  }\n\n  const keys = Object.keys(patch);\n  for (const key of keys) {\n    if (options.pollute !== true && key === \"__proto__\") {\n      throw new Error(\"Prototype pollution attempt\");\n    }\n    const v = patch[key];\n    if (v === null) {\n      delete doc[key];\n      continue;\n    }\n    doc[key] = apply(doc[key], v);\n  }\n\n  return doc;\n};\n", "\"use strict\";\n\nconst assert = require(\"assert\");\nconst apply = require(\"../lib/apply\");\n\ndescribe(\"apply\", () => {\n  it(\"returns the patch argument if it's not an object\", () => {\n    [true, false, null, [], 42, \"foo\"].forEach((v) => {\n      assert.equal(apply({}, v), v);\n    });\n  });\n\n  it(\"returns an object if document argument is not an object\", () => {\n    [true, false, null, [], 42, \"foo\"].forEach((v) => {\n      const doc = apply(v, {});\n      assert.equal(typeof doc, \"object\");\n      assert(doc !== null);\n    });\n  });\n\n  it(\"deletes patch properties with value null\", () => {\n    let doc = { foo: \"bar\" };\n    doc = apply(doc, { foo: null });\n    assert.deepEqual(doc, {});\n  });\n\n  it(\"deletes nested patch properties with value null\", () => {\n    let doc = { foo: { bar: \"foo\" } };\n    doc = apply(doc, { foo: { bar: null } });\n    assert.deepEqual(doc, { foo: {} });\n  });\n\n  it(\"adds patch properties with non null value\", () => {\n    let doc = {};\n    const patch = { foo: \"bar\", bar: \"foo\" };\n    doc = apply(doc, patch);\n    assert.deepEqual(doc, patch);\n  });\n\n  it(\"adds nested patch properties with non null value\", () => {\n    let doc = {};\n    const patch = { foo: { bar: \"foo\" } };\n    doc = apply(doc, patch);\n    assert.deepEqual(doc, patch);\n  });\n\n  it(\"ignores inherited properties on patch\", () => {\n    let doc = {};\n    const patch = Object.create({ foo: \"bar\" });\n    doc = apply(doc, patch);\n    assert.deepEqual(doc, {});\n  });\n\n  // https://github.com/sonnyp/JSON8/issues/113\n  // https://github.com/HoLyVieR/prototype-pollution-nsec18\n  it(\"prevents prototype pollution\", () => {\n    let doc = {};\n    const patch = JSON.parse('{ \"__proto__\": { \"isAdmin\": true }}');\n\n    assert.throws(\n      () => {\n        doc = apply(doc, patch);\n      },\n      Error,\n      \"Prototype pollution attempt\"\n    );\n\n    assert.equal(doc.isAdmin, undefined);\n    assert.equal(\"isAdmin\" in doc, false);\n  });\n});\n"], "filenames": ["packages/merge-patch/README.md", "packages/merge-patch/lib/apply.js", "packages/merge-patch/test/apply.js"], "buggy_code_start_loc": [71, 8, 54], "buggy_code_end_loc": [71, 22, 72], "fixing_code_start_loc": [72, 8, 54], "fixing_code_end_loc": [84, 31, 70], "type": "CWE-1321", "message": "This affects the package json8 before 1.0.3. The function adds in the target object the property specified in the path, however it does not properly check the key being set, leading to a prototype pollution.", "other": {"cve": {"id": "CVE-2020-7770", "sourceIdentifier": "report@snyk.io", "published": "2020-11-12T11:15:11.870", "lastModified": "2022-12-02T19:44:07.183", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "This affects the package json8 before 1.0.3. The function adds in the target object the property specified in the path, however it does not properly check the key being set, leading to a prototype pollution."}, {"lang": "es", "value": "Esto afecta al paquete json8 versiones anteriores a 1.0.3.&#xa0;La funci\u00f3n incorpora en el objeto destino la propiedad especificada en la ruta, sin embargo, no comprueba apropiadamente la clave que ha sido configurada, conllevando a una contaminaci\u00f3n de prototipo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:json8_project:json8:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.3", "matchCriteriaId": "CB6253FC-B143-4486-B5A4-9C6112F7421A"}]}]}], "references": [{"url": "https://github.com/sonnyp/JSON8/commit/2e890261b66cbc54ae01d0c79c71b0fd18379e7e", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-JSON8-1017116", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/sonnyp/JSON8/commit/2e890261b66cbc54ae01d0c79c71b0fd18379e7e"}}