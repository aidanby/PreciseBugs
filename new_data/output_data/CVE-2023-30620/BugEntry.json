{"buggy_code": ["import os\nimport zipfile\nimport tarfile\n\nfrom flask import request, current_app as ca\nfrom flask_restx import Resource\nimport tempfile\nimport multipart\nimport requests\n\nfrom mindsdb.utilities import log\nfrom mindsdb.api.http.utils import http_error\nfrom mindsdb.api.http.namespaces.configs.files import ns_conf\nfrom mindsdb.utilities.config import Config\nfrom mindsdb.utilities.context import context as ctx\n\n\n@ns_conf.route('/')\nclass FilesList(Resource):\n    @ns_conf.doc('get_files_list')\n    def get(self):\n        '''List all files'''\n        return ca.file_controller.get_files()\n\n\n@ns_conf.route('/<name>')\n@ns_conf.param('name', \"MindsDB's name for file\")\nclass File(Resource):\n    @ns_conf.doc('put_file')\n    def put(self, name: str):\n        ''' add new file\n            params in FormData:\n                - file\n                - original_file_name [optional]\n        '''\n\n        data = {}\n        mindsdb_file_name = name\n\n        existing_file_names = ca.file_controller.get_files_names()\n\n        def on_field(field):\n            name = field.field_name.decode()\n            value = field.value.decode()\n            data[name] = value\n\n        file_object = None\n\n        def on_file(file):\n            nonlocal file_object\n            data['file'] = file.file_name.decode()\n            file_object = file.file_object\n\n        temp_dir_path = tempfile.mkdtemp(prefix='mindsdb_file_')\n\n        if request.headers['Content-Type'].startswith('multipart/form-data'):\n            parser = multipart.create_form_parser(\n                headers=request.headers,\n                on_field=on_field,\n                on_file=on_file,\n                config={\n                    'UPLOAD_DIR': temp_dir_path.encode(),    # bytes required\n                    'UPLOAD_KEEP_FILENAME': True,\n                    'UPLOAD_KEEP_EXTENSIONS': True,\n                    'MAX_MEMORY_FILE_SIZE': 0\n                }\n            )\n\n            while True:\n                chunk = request.stream.read(8192)\n                if not chunk:\n                    break\n                parser.write(chunk)\n            parser.finalize()\n            parser.close()\n\n            if file_object is not None and not file_object.closed:\n                file_object.close()\n        else:\n            data = request.json\n\n        if mindsdb_file_name in existing_file_names:\n            return http_error(\n                400,\n                \"File already exists\",\n                f\"File with name '{data['file']}' already exists\"\n            )\n\n        if data.get('source_type') == 'url':\n            url = data['source']\n            data['file'] = data['name']\n\n            config = Config()\n            is_cloud = config.get('cloud', False)\n            if is_cloud is True and ctx.user_class != 1:\n                info = requests.head(url)\n                file_size = info.headers.get('Content-Length')\n                try:\n                    file_size = int(file_size)\n                except Exception:\n                    pass\n\n                if file_size is None:\n                    return http_error(\n                        400,\n                        \"Error getting file info\",\n                        \"\u0421an't determine remote file size\"\n                    )\n                if file_size > 1024 * 1024 * 100:\n                    return http_error(\n                        400,\n                        \"File is too big\",\n                        \"Upload limit for file is 100Mb\"\n                    )\n            with requests.get(url, stream=True) as r:\n                if r.status_code != 200:\n                    return http_error(\n                        400,\n                        \"Error getting file\",\n                        f\"Got status code: {r.status_code}\"\n                    )\n                file_path = os.path.join(temp_dir_path, data['file'])\n                with open(file_path, 'wb') as f:\n                    for chunk in r.iter_content(chunk_size=8192):\n                        f.write(chunk)\n\n        original_file_name = data.get('original_file_name')\n\n        file_path = os.path.join(temp_dir_path, data['file'])\n        lp = file_path.lower()\n        if lp.endswith(('.zip', '.tar.gz')):\n            if lp.endswith('.zip'):\n                with zipfile.ZipFile(file_path) as f:\n                    f.extractall(temp_dir_path)\n            elif lp.endswith('.tar.gz'):\n                with tarfile.open(file_path) as f:\n                    f.extractall(temp_dir_path)\n            os.remove(file_path)\n            files = os.listdir(temp_dir_path)\n            if len(files) != 1:\n                os.rmdir(temp_dir_path)\n                return http_error(400, 'Wrong content.', 'Archive must contain only one data file.')\n            file_path = os.path.join(temp_dir_path, files[0])\n            mindsdb_file_name = files[0]\n            if not os.path.isfile(file_path):\n                os.rmdir(temp_dir_path)\n                return http_error(400, 'Wrong content.', 'Archive must contain data file in root.')\n\n        ca.file_controller.save_file(mindsdb_file_name, file_path, file_name=original_file_name)\n\n        os.rmdir(temp_dir_path)\n\n        return '', 200\n\n    @ns_conf.doc('delete_file')\n    def delete(self, name: str):\n        '''delete file'''\n\n        try:\n            ca.file_controller.delete_file(name)\n        except Exception as e:\n            log.logger.error(e)\n            return http_error(\n                400,\n                \"Error deleting file\",\n                f\"There was an error while tring to delete file with name '{name}'\"\n            )\n        return '', 200\n", "import json\n\nfrom flask import Response\n\n\ndef http_error(status_code, title, detail=''):\n    ''' Wrapper for error responce acoording with RFC 7807 (https://tools.ietf.org/html/rfc7807)\n\n        :param status_code: int - http status code for response\n        :param title: str\n        :param detail: str\n\n        :return: flask Response object\n    '''\n    return Response(\n        response=json.dumps({\n            'title': title,\n            'detail': detail\n        }),\n        status=status_code,\n        headers={\n            'Content-Type': 'application/problem+json'\n        }\n    )\n"], "fixing_code": ["import os\nimport zipfile\nimport tarfile\n\nfrom flask import request, current_app as ca\nfrom flask_restx import Resource\nimport tempfile\nimport multipart\nimport requests\n\nfrom mindsdb.utilities import log\nfrom mindsdb.api.http.utils import http_error, safe_extract\nfrom mindsdb.api.http.namespaces.configs.files import ns_conf\nfrom mindsdb.utilities.config import Config\nfrom mindsdb.utilities.context import context as ctx\n\n\n@ns_conf.route('/')\nclass FilesList(Resource):\n    @ns_conf.doc('get_files_list')\n    def get(self):\n        '''List all files'''\n        return ca.file_controller.get_files()\n\n\n@ns_conf.route('/<name>')\n@ns_conf.param('name', \"MindsDB's name for file\")\nclass File(Resource):\n    @ns_conf.doc('put_file')\n    def put(self, name: str):\n        ''' add new file\n            params in FormData:\n                - file\n                - original_file_name [optional]\n        '''\n\n        data = {}\n        mindsdb_file_name = name\n\n        existing_file_names = ca.file_controller.get_files_names()\n\n        def on_field(field):\n            name = field.field_name.decode()\n            value = field.value.decode()\n            data[name] = value\n\n        file_object = None\n\n        def on_file(file):\n            nonlocal file_object\n            data['file'] = file.file_name.decode()\n            file_object = file.file_object\n\n        temp_dir_path = tempfile.mkdtemp(prefix='mindsdb_file_')\n\n        if request.headers['Content-Type'].startswith('multipart/form-data'):\n            parser = multipart.create_form_parser(\n                headers=request.headers,\n                on_field=on_field,\n                on_file=on_file,\n                config={\n                    'UPLOAD_DIR': temp_dir_path.encode(),    # bytes required\n                    'UPLOAD_KEEP_FILENAME': True,\n                    'UPLOAD_KEEP_EXTENSIONS': True,\n                    'MAX_MEMORY_FILE_SIZE': 0\n                }\n            )\n\n            while True:\n                chunk = request.stream.read(8192)\n                if not chunk:\n                    break\n                parser.write(chunk)\n            parser.finalize()\n            parser.close()\n\n            if file_object is not None and not file_object.closed:\n                file_object.close()\n        else:\n            data = request.json\n\n        if mindsdb_file_name in existing_file_names:\n            return http_error(\n                400,\n                \"File already exists\",\n                f\"File with name '{data['file']}' already exists\"\n            )\n\n        if data.get('source_type') == 'url':\n            url = data['source']\n            data['file'] = data['name']\n\n            config = Config()\n            is_cloud = config.get('cloud', False)\n            if is_cloud is True and ctx.user_class != 1:\n                info = requests.head(url)\n                file_size = info.headers.get('Content-Length')\n                try:\n                    file_size = int(file_size)\n                except Exception:\n                    pass\n\n                if file_size is None:\n                    return http_error(\n                        400,\n                        \"Error getting file info\",\n                        \"\u0421an't determine remote file size\"\n                    )\n                if file_size > 1024 * 1024 * 100:\n                    return http_error(\n                        400,\n                        \"File is too big\",\n                        \"Upload limit for file is 100Mb\"\n                    )\n            with requests.get(url, stream=True) as r:\n                if r.status_code != 200:\n                    return http_error(\n                        400,\n                        \"Error getting file\",\n                        f\"Got status code: {r.status_code}\"\n                    )\n                file_path = os.path.join(temp_dir_path, data['file'])\n                with open(file_path, 'wb') as f:\n                    for chunk in r.iter_content(chunk_size=8192):\n                        f.write(chunk)\n\n        original_file_name = data.get('original_file_name')\n\n        file_path = os.path.join(temp_dir_path, data['file'])\n        lp = file_path.lower()\n        if lp.endswith(('.zip', '.tar.gz')):\n            if lp.endswith('.zip'):\n                with zipfile.ZipFile(file_path) as f:\n                    f.extractall(temp_dir_path)\n            elif lp.endswith('.tar.gz'):\n                with tarfile.open(file_path) as f:\n                    safe_extract(f, temp_dir_path)\n            os.remove(file_path)\n            files = os.listdir(temp_dir_path)\n            if len(files) != 1:\n                os.rmdir(temp_dir_path)\n                return http_error(400, 'Wrong content.', 'Archive must contain only one data file.')\n            file_path = os.path.join(temp_dir_path, files[0])\n            mindsdb_file_name = files[0]\n            if not os.path.isfile(file_path):\n                os.rmdir(temp_dir_path)\n                return http_error(400, 'Wrong content.', 'Archive must contain data file in root.')\n\n        ca.file_controller.save_file(mindsdb_file_name, file_path, file_name=original_file_name)\n\n        os.rmdir(temp_dir_path)\n\n        return '', 200\n\n    @ns_conf.doc('delete_file')\n    def delete(self, name: str):\n        '''delete file'''\n\n        try:\n            ca.file_controller.delete_file(name)\n        except Exception as e:\n            log.logger.error(e)\n            return http_error(\n                400,\n                \"Error deleting file\",\n                f\"There was an error while tring to delete file with name '{name}'\"\n            )\n        return '', 200\n", "import json\nimport os\n\nfrom flask import Response\n\n\ndef http_error(status_code, title, detail=''):\n    ''' Wrapper for error responce acoording with RFC 7807 (https://tools.ietf.org/html/rfc7807)\n\n        :param status_code: int - http status code for response\n        :param title: str\n        :param detail: str\n\n        :return: flask Response object\n    '''\n    return Response(\n        response=json.dumps({\n            'title': title,\n            'detail': detail\n        }),\n        status=status_code,\n        headers={\n            'Content-Type': 'application/problem+json'\n        }\n    )\n\ndef __is_within_directory(directory, target):\n    abs_directory = os.path.abspath(directory)\n    abs_target = os.path.abspath(target)\n    prefix = os.path.commonprefix([abs_directory, abs_target])\n    return prefix == abs_directory\n\ndef safe_extract(tar, path=\".\", members=None, *, numeric_owner=False):\n    for member in tar.getmembers():\n        member_path = os.path.join(path, member.name)\n        if not __is_within_directory(path, member_path):\n            raise Exception(\"Attempted Path Traversal in Tar File\")\n    tar.extractall(path, members, numeric_owner) \n\n"], "filenames": ["mindsdb/api/http/namespaces/file.py", "mindsdb/api/http/utils.py"], "buggy_code_start_loc": [12, 1], "buggy_code_end_loc": [138, 24], "fixing_code_start_loc": [12, 2], "fixing_code_end_loc": [138, 40], "type": "CWE-22", "message": "mindsdb is a Machine Learning platform to help developers build AI solutions. In affected versions an unsafe extraction is being performed using `tarfile.extractall()` from a remotely retrieved tarball. Which may lead to the writing of the extracted files to an unintended location. Sometimes, the vulnerability is called a TarSlip or a ZipSlip variant. An attacker may leverage this vulnerability to overwrite any local file which the server process has access to. There is no risk of file exposure with this vulnerability. This issue has been addressed in release `23.2.1.0 `. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-30620", "sourceIdentifier": "security-advisories@github.com", "published": "2023-04-21T21:15:08.053", "lastModified": "2023-04-29T03:06:57.767", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "mindsdb is a Machine Learning platform to help developers build AI solutions. In affected versions an unsafe extraction is being performed using `tarfile.extractall()` from a remotely retrieved tarball. Which may lead to the writing of the extracted files to an unintended location. Sometimes, the vulnerability is called a TarSlip or a ZipSlip variant. An attacker may leverage this vulnerability to overwrite any local file which the server process has access to. There is no risk of file exposure with this vulnerability. This issue has been addressed in release `23.2.1.0 `. Users are advised to upgrade. There are no known workarounds for this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mindsdb:mindsdb:*:*:*:*:*:*:*:*", "versionEndIncluding": "23.1.5.0", "matchCriteriaId": "501BDCF9-A4E3-40F3-8408-1D1CA91B6D51"}]}]}], "references": [{"url": "https://github.com/mindsdb/mindsdb/commit/4419b0f0019c000db390b54d8b9d06e1d3670039", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/mindsdb/mindsdb/releases/tag/v23.2.1.0", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/mindsdb/mindsdb/security/advisories/GHSA-2g5w-29q9-w6hx", "source": "security-advisories@github.com", "tags": ["Exploit", "Mitigation", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/mindsdb/mindsdb/commit/4419b0f0019c000db390b54d8b9d06e1d3670039"}}