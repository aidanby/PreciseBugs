{"buggy_code": ["/*\n    Conexant cx24116/cx24118 - DVBS/S2 Satellite demod/tuner driver\n\n    Copyright (C) 2006-2008 Steven Toth <stoth@hauppauge.com>\n    Copyright (C) 2006-2007 Georg Acher\n    Copyright (C) 2007-2008 Darron Broad\n\tMarch 2007\n\t    Fixed some bugs.\n\t    Added diseqc support.\n\t    Added corrected signal strength support.\n\tAugust 2007\n\t    Sync with legacy version.\n\t    Some clean ups.\n    Copyright (C) 2008 Igor Liplianin\n\tSeptember, 9th 2008\n\t    Fixed locking on high symbol rates (>30000).\n\t    Implement MPEG initialization parameter.\n\tJanuary, 17th 2009\n\t    Fill set_voltage with actually control voltage code.\n\t    Correct set tone to not affect voltage.\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n*/\n\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/firmware.h>\n\n#include \"dvb_frontend.h\"\n#include \"cx24116.h\"\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Activates frontend debugging (default:0)\");\n\n#define dprintk(args...) \\\n\tdo { \\\n\t\tif (debug) \\\n\t\t\tprintk(KERN_INFO \"cx24116: \" args); \\\n\t} while (0)\n\n#define CX24116_DEFAULT_FIRMWARE \"dvb-fe-cx24116.fw\"\n#define CX24116_SEARCH_RANGE_KHZ 5000\n\n/* known registers */\n#define CX24116_REG_COMMAND (0x00)      /* command args 0x00..0x1e */\n#define CX24116_REG_EXECUTE (0x1f)      /* execute command */\n#define CX24116_REG_MAILBOX (0x96)      /* FW or multipurpose mailbox? */\n#define CX24116_REG_RESET   (0x20)      /* reset status > 0     */\n#define CX24116_REG_SIGNAL  (0x9e)      /* signal low           */\n#define CX24116_REG_SSTATUS (0x9d)      /* signal high / status */\n#define CX24116_REG_QUALITY8 (0xa3)\n#define CX24116_REG_QSTATUS (0xbc)\n#define CX24116_REG_QUALITY0 (0xd5)\n#define CX24116_REG_BER0    (0xc9)\n#define CX24116_REG_BER8    (0xc8)\n#define CX24116_REG_BER16   (0xc7)\n#define CX24116_REG_BER24   (0xc6)\n#define CX24116_REG_UCB0    (0xcb)\n#define CX24116_REG_UCB8    (0xca)\n#define CX24116_REG_CLKDIV  (0xf3)\n#define CX24116_REG_RATEDIV (0xf9)\n\n/* configured fec (not tuned) or actual FEC (tuned) 1=1/2 2=2/3 etc */\n#define CX24116_REG_FECSTATUS (0x9c)\n\n/* FECSTATUS bits */\n/* mask to determine configured fec (not tuned) or actual fec (tuned) */\n#define CX24116_FEC_FECMASK   (0x1f)\n\n/* Select DVB-S demodulator, else DVB-S2 */\n#define CX24116_FEC_DVBS      (0x20)\n#define CX24116_FEC_UNKNOWN   (0x40)    /* Unknown/unused */\n\n/* Pilot mode requested when tuning else always reset when tuned */\n#define CX24116_FEC_PILOT     (0x80)\n\n/* arg buffer size */\n#define CX24116_ARGLEN (0x1e)\n\n/* rolloff */\n#define CX24116_ROLLOFF_020 (0x00)\n#define CX24116_ROLLOFF_025 (0x01)\n#define CX24116_ROLLOFF_035 (0x02)\n\n/* pilot bit */\n#define CX24116_PILOT_OFF (0x00)\n#define CX24116_PILOT_ON (0x40)\n\n/* signal status */\n#define CX24116_HAS_SIGNAL   (0x01)\n#define CX24116_HAS_CARRIER  (0x02)\n#define CX24116_HAS_VITERBI  (0x04)\n#define CX24116_HAS_SYNCLOCK (0x08)\n#define CX24116_HAS_UNKNOWN1 (0x10)\n#define CX24116_HAS_UNKNOWN2 (0x20)\n#define CX24116_STATUS_MASK  (0x0f)\n#define CX24116_SIGNAL_MASK  (0xc0)\n\n#define CX24116_DISEQC_TONEOFF   (0)    /* toneburst never sent */\n#define CX24116_DISEQC_TONECACHE (1)    /* toneburst cached     */\n#define CX24116_DISEQC_MESGCACHE (2)    /* message cached       */\n\n/* arg offset for DiSEqC */\n#define CX24116_DISEQC_BURST  (1)\n#define CX24116_DISEQC_ARG2_2 (2)   /* unknown value=2 */\n#define CX24116_DISEQC_ARG3_0 (3)   /* unknown value=0 */\n#define CX24116_DISEQC_ARG4_0 (4)   /* unknown value=0 */\n#define CX24116_DISEQC_MSGLEN (5)\n#define CX24116_DISEQC_MSGOFS (6)\n\n/* DiSEqC burst */\n#define CX24116_DISEQC_MINI_A (0)\n#define CX24116_DISEQC_MINI_B (1)\n\n/* DiSEqC tone burst */\nstatic int toneburst = 1;\nmodule_param(toneburst, int, 0644);\nMODULE_PARM_DESC(toneburst, \"DiSEqC toneburst 0=OFF, 1=TONE CACHE, \"\\\n\t\"2=MESSAGE CACHE (default:1)\");\n\n/* SNR measurements */\nstatic int esno_snr;\nmodule_param(esno_snr, int, 0644);\nMODULE_PARM_DESC(esno_snr, \"SNR return units, 0=PERCENTAGE 0-100, \"\\\n\t\"1=ESNO(db * 10) (default:0)\");\n\nenum cmds {\n\tCMD_SET_VCO     = 0x10,\n\tCMD_TUNEREQUEST = 0x11,\n\tCMD_MPEGCONFIG  = 0x13,\n\tCMD_TUNERINIT   = 0x14,\n\tCMD_BANDWIDTH   = 0x15,\n\tCMD_GETAGC      = 0x19,\n\tCMD_LNBCONFIG   = 0x20,\n\tCMD_LNBSEND     = 0x21, /* Formerly CMD_SEND_DISEQC */\n\tCMD_LNBDCLEVEL  = 0x22,\n\tCMD_SET_TONE    = 0x23,\n\tCMD_UPDFWVERS   = 0x35,\n\tCMD_TUNERSLEEP  = 0x36,\n\tCMD_AGCCONTROL  = 0x3b, /* Unknown */\n};\n\n/* The Demod/Tuner can't easily provide these, we cache them */\nstruct cx24116_tuning {\n\tu32 frequency;\n\tu32 symbol_rate;\n\tfe_spectral_inversion_t inversion;\n\tfe_code_rate_t fec;\n\n\tfe_delivery_system_t delsys;\n\tfe_modulation_t modulation;\n\tfe_pilot_t pilot;\n\tfe_rolloff_t rolloff;\n\n\t/* Demod values */\n\tu8 fec_val;\n\tu8 fec_mask;\n\tu8 inversion_val;\n\tu8 pilot_val;\n\tu8 rolloff_val;\n};\n\n/* Basic commands that are sent to the firmware */\nstruct cx24116_cmd {\n\tu8 len;\n\tu8 args[CX24116_ARGLEN];\n};\n\nstruct cx24116_state {\n\tstruct i2c_adapter *i2c;\n\tconst struct cx24116_config *config;\n\n\tstruct dvb_frontend frontend;\n\n\tstruct cx24116_tuning dcur;\n\tstruct cx24116_tuning dnxt;\n\n\tu8 skip_fw_load;\n\tu8 burst;\n\tstruct cx24116_cmd dsec_cmd;\n};\n\nstatic int cx24116_writereg(struct cx24116_state *state, int reg, int data)\n{\n\tu8 buf[] = { reg, data };\n\tstruct i2c_msg msg = { .addr = state->config->demod_address,\n\t\t.flags = 0, .buf = buf, .len = 2 };\n\tint err;\n\n\tif (debug > 1)\n\t\tprintk(\"cx24116: %s: write reg 0x%02x, value 0x%02x\\n\",\n\t\t\t__func__, reg, data);\n\n\terr = i2c_transfer(state->i2c, &msg, 1);\n\tif (err != 1) {\n\t\tprintk(KERN_ERR \"%s: writereg error(err == %i, reg == 0x%02x,\"\n\t\t\t \" value == 0x%02x)\\n\", __func__, err, reg, data);\n\t\treturn -EREMOTEIO;\n\t}\n\n\treturn 0;\n}\n\n/* Bulk byte writes to a single I2C address, for 32k firmware load */\nstatic int cx24116_writeregN(struct cx24116_state *state, int reg,\n\t\t\t     const u8 *data, u16 len)\n{\n\tint ret = -EREMOTEIO;\n\tstruct i2c_msg msg;\n\tu8 *buf;\n\n\tbuf = kmalloc(len + 1, GFP_KERNEL);\n\tif (buf == NULL) {\n\t\tprintk(\"Unable to kmalloc\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\t*(buf) = reg;\n\tmemcpy(buf + 1, data, len);\n\n\tmsg.addr = state->config->demod_address;\n\tmsg.flags = 0;\n\tmsg.buf = buf;\n\tmsg.len = len + 1;\n\n\tif (debug > 1)\n\t\tprintk(KERN_INFO \"cx24116: %s:  write regN 0x%02x, len = %d\\n\",\n\t\t\t__func__, reg, len);\n\n\tret = i2c_transfer(state->i2c, &msg, 1);\n\tif (ret != 1) {\n\t\tprintk(KERN_ERR \"%s: writereg error(err == %i, reg == 0x%02x\\n\",\n\t\t\t __func__, ret, reg);\n\t\tret = -EREMOTEIO;\n\t}\n\nerror:\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic int cx24116_readreg(struct cx24116_state *state, u8 reg)\n{\n\tint ret;\n\tu8 b0[] = { reg };\n\tu8 b1[] = { 0 };\n\tstruct i2c_msg msg[] = {\n\t\t{ .addr = state->config->demod_address, .flags = 0,\n\t\t\t.buf = b0, .len = 1 },\n\t\t{ .addr = state->config->demod_address, .flags = I2C_M_RD,\n\t\t\t.buf = b1, .len = 1 }\n\t};\n\n\tret = i2c_transfer(state->i2c, msg, 2);\n\n\tif (ret != 2) {\n\t\tprintk(KERN_ERR \"%s: reg=0x%x (error=%d)\\n\",\n\t\t\t__func__, reg, ret);\n\t\treturn ret;\n\t}\n\n\tif (debug > 1)\n\t\tprintk(KERN_INFO \"cx24116: read reg 0x%02x, value 0x%02x\\n\",\n\t\t\treg, b1[0]);\n\n\treturn b1[0];\n}\n\nstatic int cx24116_set_inversion(struct cx24116_state *state,\n\tfe_spectral_inversion_t inversion)\n{\n\tdprintk(\"%s(%d)\\n\", __func__, inversion);\n\n\tswitch (inversion) {\n\tcase INVERSION_OFF:\n\t\tstate->dnxt.inversion_val = 0x00;\n\t\tbreak;\n\tcase INVERSION_ON:\n\t\tstate->dnxt.inversion_val = 0x04;\n\t\tbreak;\n\tcase INVERSION_AUTO:\n\t\tstate->dnxt.inversion_val = 0x0C;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tstate->dnxt.inversion = inversion;\n\n\treturn 0;\n}\n\n/*\n * modfec (modulation and FEC)\n * ===========================\n *\n * MOD          FEC             mask/val    standard\n * ----         --------        ----------- --------\n * QPSK         FEC_1_2         0x02 0x02+X DVB-S\n * QPSK         FEC_2_3         0x04 0x02+X DVB-S\n * QPSK         FEC_3_4         0x08 0x02+X DVB-S\n * QPSK         FEC_4_5         0x10 0x02+X DVB-S (?)\n * QPSK         FEC_5_6         0x20 0x02+X DVB-S\n * QPSK         FEC_6_7         0x40 0x02+X DVB-S\n * QPSK         FEC_7_8         0x80 0x02+X DVB-S\n * QPSK         FEC_8_9         0x01 0x02+X DVB-S (?) (NOT SUPPORTED?)\n * QPSK         AUTO            0xff 0x02+X DVB-S\n *\n * For DVB-S high byte probably represents FEC\n * and low byte selects the modulator. The high\n * byte is search range mask. Bit 5 may turn\n * on DVB-S and remaining bits represent some\n * kind of calibration (how/what i do not know).\n *\n * Eg.(2/3) szap \"Zone Horror\"\n *\n * mask/val = 0x04, 0x20\n * status 1f | signal c3c0 | snr a333 | ber 00000098 | unc 0 | FE_HAS_LOCK\n *\n * mask/val = 0x04, 0x30\n * status 1f | signal c3c0 | snr a333 | ber 00000000 | unc 0 | FE_HAS_LOCK\n *\n * After tuning FECSTATUS contains actual FEC\n * in use numbered 1 through to 8 for 1/2 .. 2/3 etc\n *\n * NBC=NOT/NON BACKWARD COMPATIBLE WITH DVB-S (DVB-S2 only)\n *\n * NBC-QPSK     FEC_1_2         0x00, 0x04      DVB-S2\n * NBC-QPSK     FEC_3_5         0x00, 0x05      DVB-S2\n * NBC-QPSK     FEC_2_3         0x00, 0x06      DVB-S2\n * NBC-QPSK     FEC_3_4         0x00, 0x07      DVB-S2\n * NBC-QPSK     FEC_4_5         0x00, 0x08      DVB-S2\n * NBC-QPSK     FEC_5_6         0x00, 0x09      DVB-S2\n * NBC-QPSK     FEC_8_9         0x00, 0x0a      DVB-S2\n * NBC-QPSK     FEC_9_10        0x00, 0x0b      DVB-S2\n *\n * NBC-8PSK     FEC_3_5         0x00, 0x0c      DVB-S2\n * NBC-8PSK     FEC_2_3         0x00, 0x0d      DVB-S2\n * NBC-8PSK     FEC_3_4         0x00, 0x0e      DVB-S2\n * NBC-8PSK     FEC_5_6         0x00, 0x0f      DVB-S2\n * NBC-8PSK     FEC_8_9         0x00, 0x10      DVB-S2\n * NBC-8PSK     FEC_9_10        0x00, 0x11      DVB-S2\n *\n * For DVB-S2 low bytes selects both modulator\n * and FEC. High byte is meaningless here. To\n * set pilot, bit 6 (0x40) is set. When inspecting\n * FECSTATUS bit 7 (0x80) represents the pilot\n * selection whilst not tuned. When tuned, actual FEC\n * in use is found in FECSTATUS as per above. Pilot\n * value is reset.\n */\n\n/* A table of modulation, fec and configuration bytes for the demod.\n * Not all S2 mmodulation schemes are support and not all rates with\n * a scheme are support. Especially, no auto detect when in S2 mode.\n */\nstatic struct cx24116_modfec {\n\tfe_delivery_system_t delivery_system;\n\tfe_modulation_t modulation;\n\tfe_code_rate_t fec;\n\tu8 mask;\t/* In DVBS mode this is used to autodetect */\n\tu8 val;\t\t/* Passed to the firmware to indicate mode selection */\n} CX24116_MODFEC_MODES[] = {\n /* QPSK. For unknown rates we set hardware to auto detect 0xfe 0x30 */\n\n /*mod   fec       mask  val */\n { SYS_DVBS, QPSK, FEC_NONE, 0xfe, 0x30 },\n { SYS_DVBS, QPSK, FEC_1_2,  0x02, 0x2e }, /* 00000010 00101110 */\n { SYS_DVBS, QPSK, FEC_2_3,  0x04, 0x2f }, /* 00000100 00101111 */\n { SYS_DVBS, QPSK, FEC_3_4,  0x08, 0x30 }, /* 00001000 00110000 */\n { SYS_DVBS, QPSK, FEC_4_5,  0xfe, 0x30 }, /* 000?0000 ?        */\n { SYS_DVBS, QPSK, FEC_5_6,  0x20, 0x31 }, /* 00100000 00110001 */\n { SYS_DVBS, QPSK, FEC_6_7,  0xfe, 0x30 }, /* 0?000000 ?        */\n { SYS_DVBS, QPSK, FEC_7_8,  0x80, 0x32 }, /* 10000000 00110010 */\n { SYS_DVBS, QPSK, FEC_8_9,  0xfe, 0x30 }, /* 0000000? ?        */\n { SYS_DVBS, QPSK, FEC_AUTO, 0xfe, 0x30 },\n /* NBC-QPSK */\n { SYS_DVBS2, QPSK, FEC_1_2,  0x00, 0x04 },\n { SYS_DVBS2, QPSK, FEC_3_5,  0x00, 0x05 },\n { SYS_DVBS2, QPSK, FEC_2_3,  0x00, 0x06 },\n { SYS_DVBS2, QPSK, FEC_3_4,  0x00, 0x07 },\n { SYS_DVBS2, QPSK, FEC_4_5,  0x00, 0x08 },\n { SYS_DVBS2, QPSK, FEC_5_6,  0x00, 0x09 },\n { SYS_DVBS2, QPSK, FEC_8_9,  0x00, 0x0a },\n { SYS_DVBS2, QPSK, FEC_9_10, 0x00, 0x0b },\n /* 8PSK */\n { SYS_DVBS2, PSK_8, FEC_3_5,  0x00, 0x0c },\n { SYS_DVBS2, PSK_8, FEC_2_3,  0x00, 0x0d },\n { SYS_DVBS2, PSK_8, FEC_3_4,  0x00, 0x0e },\n { SYS_DVBS2, PSK_8, FEC_5_6,  0x00, 0x0f },\n { SYS_DVBS2, PSK_8, FEC_8_9,  0x00, 0x10 },\n { SYS_DVBS2, PSK_8, FEC_9_10, 0x00, 0x11 },\n /*\n  * `val' can be found in the FECSTATUS register when tuning.\n  * FECSTATUS will give the actual FEC in use if tuning was successful.\n  */\n};\n\nstatic int cx24116_lookup_fecmod(struct cx24116_state *state,\n\tfe_delivery_system_t d, fe_modulation_t m, fe_code_rate_t f)\n{\n\tint i, ret = -EOPNOTSUPP;\n\n\tdprintk(\"%s(0x%02x,0x%02x)\\n\", __func__, m, f);\n\n\tfor (i = 0; i < ARRAY_SIZE(CX24116_MODFEC_MODES); i++) {\n\t\tif ((d == CX24116_MODFEC_MODES[i].delivery_system) &&\n\t\t\t(m == CX24116_MODFEC_MODES[i].modulation) &&\n\t\t\t(f == CX24116_MODFEC_MODES[i].fec)) {\n\t\t\t\tret = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int cx24116_set_fec(struct cx24116_state *state,\n\tfe_delivery_system_t delsys, fe_modulation_t mod, fe_code_rate_t fec)\n{\n\tint ret = 0;\n\n\tdprintk(\"%s(0x%02x,0x%02x)\\n\", __func__, mod, fec);\n\n\tret = cx24116_lookup_fecmod(state, delsys, mod, fec);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tstate->dnxt.fec = fec;\n\tstate->dnxt.fec_val = CX24116_MODFEC_MODES[ret].val;\n\tstate->dnxt.fec_mask = CX24116_MODFEC_MODES[ret].mask;\n\tdprintk(\"%s() mask/val = 0x%02x/0x%02x\\n\", __func__,\n\t\tstate->dnxt.fec_mask, state->dnxt.fec_val);\n\n\treturn 0;\n}\n\nstatic int cx24116_set_symbolrate(struct cx24116_state *state, u32 rate)\n{\n\tdprintk(\"%s(%d)\\n\", __func__, rate);\n\n\t/*  check if symbol rate is within limits */\n\tif ((rate > state->frontend.ops.info.symbol_rate_max) ||\n\t    (rate < state->frontend.ops.info.symbol_rate_min)) {\n\t\tdprintk(\"%s() unsupported symbol_rate = %d\\n\", __func__, rate);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tstate->dnxt.symbol_rate = rate;\n\tdprintk(\"%s() symbol_rate = %d\\n\", __func__, rate);\n\n\treturn 0;\n}\n\nstatic int cx24116_load_firmware(struct dvb_frontend *fe,\n\tconst struct firmware *fw);\n\nstatic int cx24116_firmware_ondemand(struct dvb_frontend *fe)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tconst struct firmware *fw;\n\tint ret = 0;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\tif (cx24116_readreg(state, 0x20) > 0) {\n\n\t\tif (state->skip_fw_load)\n\t\t\treturn 0;\n\n\t\t/* Load firmware */\n\t\t/* request the firmware, this will block until loaded */\n\t\tprintk(KERN_INFO \"%s: Waiting for firmware upload (%s)...\\n\",\n\t\t\t__func__, CX24116_DEFAULT_FIRMWARE);\n\t\tret = request_firmware(&fw, CX24116_DEFAULT_FIRMWARE,\n\t\t\tstate->i2c->dev.parent);\n\t\tprintk(KERN_INFO \"%s: Waiting for firmware upload(2)...\\n\",\n\t\t\t__func__);\n\t\tif (ret) {\n\t\t\tprintk(KERN_ERR \"%s: No firmware uploaded \"\n\t\t\t\t\"(timeout or file not found?)\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* Make sure we don't recurse back through here\n\t\t * during loading */\n\t\tstate->skip_fw_load = 1;\n\n\t\tret = cx24116_load_firmware(fe, fw);\n\t\tif (ret)\n\t\t\tprintk(KERN_ERR \"%s: Writing firmware to device failed\\n\",\n\t\t\t\t__func__);\n\n\t\trelease_firmware(fw);\n\n\t\tprintk(KERN_INFO \"%s: Firmware upload %s\\n\", __func__,\n\t\t\tret == 0 ? \"complete\" : \"failed\");\n\n\t\t/* Ensure firmware is always loaded if required */\n\t\tstate->skip_fw_load = 0;\n\t}\n\n\treturn ret;\n}\n\n/* Take a basic firmware command structure, format it\n * and forward it for processing\n */\nstatic int cx24116_cmd_execute(struct dvb_frontend *fe, struct cx24116_cmd *cmd)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tint i, ret;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\t/* Load the firmware if required */\n\tret = cx24116_firmware_ondemand(fe);\n\tif (ret != 0) {\n\t\tprintk(KERN_ERR \"%s(): Unable initialise the firmware\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\t/* Write the command */\n\tfor (i = 0; i < cmd->len ; i++) {\n\t\tdprintk(\"%s: 0x%02x == 0x%02x\\n\", __func__, i, cmd->args[i]);\n\t\tcx24116_writereg(state, i, cmd->args[i]);\n\t}\n\n\t/* Start execution and wait for cmd to terminate */\n\tcx24116_writereg(state, CX24116_REG_EXECUTE, 0x01);\n\twhile (cx24116_readreg(state, CX24116_REG_EXECUTE)) {\n\t\tmsleep(10);\n\t\tif (i++ > 64) {\n\t\t\t/* Avoid looping forever if the firmware does\n\t\t\t\tnot respond */\n\t\t\tprintk(KERN_WARNING \"%s() Firmware not responding\\n\",\n\t\t\t\t__func__);\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int cx24116_load_firmware(struct dvb_frontend *fe,\n\tconst struct firmware *fw)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tstruct cx24116_cmd cmd;\n\tint i, ret, len, max, remaining;\n\tunsigned char vers[4];\n\n\tdprintk(\"%s\\n\", __func__);\n\tdprintk(\"Firmware is %zu bytes (%02x %02x .. %02x %02x)\\n\",\n\t\t\tfw->size,\n\t\t\tfw->data[0],\n\t\t\tfw->data[1],\n\t\t\tfw->data[fw->size-2],\n\t\t\tfw->data[fw->size-1]);\n\n\t/* Toggle 88x SRST pin to reset demod */\n\tif (state->config->reset_device)\n\t\tstate->config->reset_device(fe);\n\n\t/* Begin the firmware load process */\n\t/* Prepare the demod, load the firmware, cleanup after load */\n\n\t/* Init PLL */\n\tcx24116_writereg(state, 0xE5, 0x00);\n\tcx24116_writereg(state, 0xF1, 0x08);\n\tcx24116_writereg(state, 0xF2, 0x13);\n\n\t/* Start PLL */\n\tcx24116_writereg(state, 0xe0, 0x03);\n\tcx24116_writereg(state, 0xe0, 0x00);\n\n\t/* Unknown */\n\tcx24116_writereg(state, CX24116_REG_CLKDIV, 0x46);\n\tcx24116_writereg(state, CX24116_REG_RATEDIV, 0x00);\n\n\t/* Unknown */\n\tcx24116_writereg(state, 0xF0, 0x03);\n\tcx24116_writereg(state, 0xF4, 0x81);\n\tcx24116_writereg(state, 0xF5, 0x00);\n\tcx24116_writereg(state, 0xF6, 0x00);\n\n\t/* Split firmware to the max I2C write len and write.\n\t * Writes whole firmware as one write when i2c_wr_max is set to 0. */\n\tif (state->config->i2c_wr_max)\n\t\tmax = state->config->i2c_wr_max;\n\telse\n\t\tmax = INT_MAX; /* enough for 32k firmware */\n\n\tfor (remaining = fw->size; remaining > 0; remaining -= max - 1) {\n\t\tlen = remaining;\n\t\tif (len > max - 1)\n\t\t\tlen = max - 1;\n\n\t\tcx24116_writeregN(state, 0xF7, &fw->data[fw->size - remaining],\n\t\t\tlen);\n\t}\n\n\tcx24116_writereg(state, 0xF4, 0x10);\n\tcx24116_writereg(state, 0xF0, 0x00);\n\tcx24116_writereg(state, 0xF8, 0x06);\n\n\t/* Firmware CMD 10: VCO config */\n\tcmd.args[0x00] = CMD_SET_VCO;\n\tcmd.args[0x01] = 0x05;\n\tcmd.args[0x02] = 0xdc;\n\tcmd.args[0x03] = 0xda;\n\tcmd.args[0x04] = 0xae;\n\tcmd.args[0x05] = 0xaa;\n\tcmd.args[0x06] = 0x04;\n\tcmd.args[0x07] = 0x9d;\n\tcmd.args[0x08] = 0xfc;\n\tcmd.args[0x09] = 0x06;\n\tcmd.len = 0x0a;\n\tret = cx24116_cmd_execute(fe, &cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tcx24116_writereg(state, CX24116_REG_SSTATUS, 0x00);\n\n\t/* Firmware CMD 14: Tuner config */\n\tcmd.args[0x00] = CMD_TUNERINIT;\n\tcmd.args[0x01] = 0x00;\n\tcmd.args[0x02] = 0x00;\n\tcmd.len = 0x03;\n\tret = cx24116_cmd_execute(fe, &cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tcx24116_writereg(state, 0xe5, 0x00);\n\n\t/* Firmware CMD 13: MPEG config */\n\tcmd.args[0x00] = CMD_MPEGCONFIG;\n\tcmd.args[0x01] = 0x01;\n\tcmd.args[0x02] = 0x75;\n\tcmd.args[0x03] = 0x00;\n\tif (state->config->mpg_clk_pos_pol)\n\t\tcmd.args[0x04] = state->config->mpg_clk_pos_pol;\n\telse\n\t\tcmd.args[0x04] = 0x02;\n\tcmd.args[0x05] = 0x00;\n\tcmd.len = 0x06;\n\tret = cx24116_cmd_execute(fe, &cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* Firmware CMD 35: Get firmware version */\n\tcmd.args[0x00] = CMD_UPDFWVERS;\n\tcmd.len = 0x02;\n\tfor (i = 0; i < 4; i++) {\n\t\tcmd.args[0x01] = i;\n\t\tret = cx24116_cmd_execute(fe, &cmd);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tvers[i] = cx24116_readreg(state, CX24116_REG_MAILBOX);\n\t}\n\tprintk(KERN_INFO \"%s: FW version %i.%i.%i.%i\\n\", __func__,\n\t\tvers[0], vers[1], vers[2], vers[3]);\n\n\treturn 0;\n}\n\nstatic int cx24116_read_status(struct dvb_frontend *fe, fe_status_t *status)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\n\tint lock = cx24116_readreg(state, CX24116_REG_SSTATUS) &\n\t\tCX24116_STATUS_MASK;\n\n\tdprintk(\"%s: status = 0x%02x\\n\", __func__, lock);\n\n\t*status = 0;\n\n\tif (lock & CX24116_HAS_SIGNAL)\n\t\t*status |= FE_HAS_SIGNAL;\n\tif (lock & CX24116_HAS_CARRIER)\n\t\t*status |= FE_HAS_CARRIER;\n\tif (lock & CX24116_HAS_VITERBI)\n\t\t*status |= FE_HAS_VITERBI;\n\tif (lock & CX24116_HAS_SYNCLOCK)\n\t\t*status |= FE_HAS_SYNC | FE_HAS_LOCK;\n\n\treturn 0;\n}\n\nstatic int cx24116_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\t*ber =  (cx24116_readreg(state, CX24116_REG_BER24) << 24) |\n\t\t(cx24116_readreg(state, CX24116_REG_BER16) << 16) |\n\t\t(cx24116_readreg(state, CX24116_REG_BER8)  << 8)  |\n\t\t cx24116_readreg(state, CX24116_REG_BER0);\n\n\treturn 0;\n}\n\n/* TODO Determine function and scale appropriately */\nstatic int cx24116_read_signal_strength(struct dvb_frontend *fe,\n\tu16 *signal_strength)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tstruct cx24116_cmd cmd;\n\tint ret;\n\tu16 sig_reading;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\t/* Firmware CMD 19: Get AGC */\n\tcmd.args[0x00] = CMD_GETAGC;\n\tcmd.len = 0x01;\n\tret = cx24116_cmd_execute(fe, &cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tsig_reading =\n\t\t(cx24116_readreg(state,\n\t\t\tCX24116_REG_SSTATUS) & CX24116_SIGNAL_MASK) |\n\t\t(cx24116_readreg(state, CX24116_REG_SIGNAL) << 6);\n\t*signal_strength = 0 - sig_reading;\n\n\tdprintk(\"%s: raw / cooked = 0x%04x / 0x%04x\\n\",\n\t\t__func__, sig_reading, *signal_strength);\n\n\treturn 0;\n}\n\n/* SNR (0..100)% = (sig & 0xf0) * 10 + (sig & 0x0f) * 10 / 16 */\nstatic int cx24116_read_snr_pct(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tu8 snr_reading;\n\tstatic const u32 snr_tab[] = { /* 10 x Table (rounded up) */\n\t\t0x00000, 0x0199A, 0x03333, 0x04ccD, 0x06667,\n\t\t0x08000, 0x0999A, 0x0b333, 0x0cccD, 0x0e667,\n\t\t0x10000, 0x1199A, 0x13333, 0x14ccD, 0x16667,\n\t\t0x18000 };\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\tsnr_reading = cx24116_readreg(state, CX24116_REG_QUALITY0);\n\n\tif (snr_reading >= 0xa0 /* 100% */)\n\t\t*snr = 0xffff;\n\telse\n\t\t*snr = snr_tab[(snr_reading & 0xf0) >> 4] +\n\t\t\t(snr_tab[(snr_reading & 0x0f)] >> 4);\n\n\tdprintk(\"%s: raw / cooked = 0x%02x / 0x%04x\\n\", __func__,\n\t\tsnr_reading, *snr);\n\n\treturn 0;\n}\n\n/* The reelbox patches show the value in the registers represents\n * ESNO, from 0->30db (values 0->300). We provide this value by\n * default.\n */\nstatic int cx24116_read_snr_esno(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\t*snr = cx24116_readreg(state, CX24116_REG_QUALITY8) << 8 |\n\t\tcx24116_readreg(state, CX24116_REG_QUALITY0);\n\n\tdprintk(\"%s: raw 0x%04x\\n\", __func__, *snr);\n\n\treturn 0;\n}\n\nstatic int cx24116_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tif (esno_snr == 1)\n\t\treturn cx24116_read_snr_esno(fe, snr);\n\telse\n\t\treturn cx24116_read_snr_pct(fe, snr);\n}\n\nstatic int cx24116_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\t*ucblocks = (cx24116_readreg(state, CX24116_REG_UCB8) << 8) |\n\t\tcx24116_readreg(state, CX24116_REG_UCB0);\n\n\treturn 0;\n}\n\n/* Overwrite the current tuning params, we are about to tune */\nstatic void cx24116_clone_params(struct dvb_frontend *fe)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tstate->dcur = state->dnxt;\n}\n\n/* Wait for LNB */\nstatic int cx24116_wait_for_lnb(struct dvb_frontend *fe)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tint i;\n\n\tdprintk(\"%s() qstatus = 0x%02x\\n\", __func__,\n\t\tcx24116_readreg(state, CX24116_REG_QSTATUS));\n\n\t/* Wait for up to 300 ms */\n\tfor (i = 0; i < 30 ; i++) {\n\t\tif (cx24116_readreg(state, CX24116_REG_QSTATUS) & 0x20)\n\t\t\treturn 0;\n\t\tmsleep(10);\n\t}\n\n\tdprintk(\"%s(): LNB not ready\\n\", __func__);\n\n\treturn -ETIMEDOUT; /* -EBUSY ? */\n}\n\nstatic int cx24116_set_voltage(struct dvb_frontend *fe,\n\tfe_sec_voltage_t voltage)\n{\n\tstruct cx24116_cmd cmd;\n\tint ret;\n\n\tdprintk(\"%s: %s\\n\", __func__,\n\t\tvoltage == SEC_VOLTAGE_13 ? \"SEC_VOLTAGE_13\" :\n\t\tvoltage == SEC_VOLTAGE_18 ? \"SEC_VOLTAGE_18\" : \"??\");\n\n\t/* Wait for LNB ready */\n\tret = cx24116_wait_for_lnb(fe);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* Wait for voltage/min repeat delay */\n\tmsleep(100);\n\n\tcmd.args[0x00] = CMD_LNBDCLEVEL;\n\tcmd.args[0x01] = (voltage == SEC_VOLTAGE_18 ? 0x01 : 0x00);\n\tcmd.len = 0x02;\n\n\t/* Min delay time before DiSEqC send */\n\tmsleep(15);\n\n\treturn cx24116_cmd_execute(fe, &cmd);\n}\n\nstatic int cx24116_set_tone(struct dvb_frontend *fe,\n\tfe_sec_tone_mode_t tone)\n{\n\tstruct cx24116_cmd cmd;\n\tint ret;\n\n\tdprintk(\"%s(%d)\\n\", __func__, tone);\n\tif ((tone != SEC_TONE_ON) && (tone != SEC_TONE_OFF)) {\n\t\tprintk(KERN_ERR \"%s: Invalid, tone=%d\\n\", __func__, tone);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Wait for LNB ready */\n\tret = cx24116_wait_for_lnb(fe);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* Min delay time after DiSEqC send */\n\tmsleep(15); /* XXX determine is FW does this, see send_diseqc/burst */\n\n\t/* Now we set the tone */\n\tcmd.args[0x00] = CMD_SET_TONE;\n\tcmd.args[0x01] = 0x00;\n\tcmd.args[0x02] = 0x00;\n\n\tswitch (tone) {\n\tcase SEC_TONE_ON:\n\t\tdprintk(\"%s: setting tone on\\n\", __func__);\n\t\tcmd.args[0x03] = 0x01;\n\t\tbreak;\n\tcase SEC_TONE_OFF:\n\t\tdprintk(\"%s: setting tone off\\n\", __func__);\n\t\tcmd.args[0x03] = 0x00;\n\t\tbreak;\n\t}\n\tcmd.len = 0x04;\n\n\t/* Min delay time before DiSEqC send */\n\tmsleep(15); /* XXX determine is FW does this, see send_diseqc/burst */\n\n\treturn cx24116_cmd_execute(fe, &cmd);\n}\n\n/* Initialise DiSEqC */\nstatic int cx24116_diseqc_init(struct dvb_frontend *fe)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tstruct cx24116_cmd cmd;\n\tint ret;\n\n\t/* Firmware CMD 20: LNB/DiSEqC config */\n\tcmd.args[0x00] = CMD_LNBCONFIG;\n\tcmd.args[0x01] = 0x00;\n\tcmd.args[0x02] = 0x10;\n\tcmd.args[0x03] = 0x00;\n\tcmd.args[0x04] = 0x8f;\n\tcmd.args[0x05] = 0x28;\n\tcmd.args[0x06] = (toneburst == CX24116_DISEQC_TONEOFF) ? 0x00 : 0x01;\n\tcmd.args[0x07] = 0x01;\n\tcmd.len = 0x08;\n\tret = cx24116_cmd_execute(fe, &cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* Prepare a DiSEqC command */\n\tstate->dsec_cmd.args[0x00] = CMD_LNBSEND;\n\n\t/* DiSEqC burst */\n\tstate->dsec_cmd.args[CX24116_DISEQC_BURST]  = CX24116_DISEQC_MINI_A;\n\n\t/* Unknown */\n\tstate->dsec_cmd.args[CX24116_DISEQC_ARG2_2] = 0x02;\n\tstate->dsec_cmd.args[CX24116_DISEQC_ARG3_0] = 0x00;\n\t/* Continuation flag? */\n\tstate->dsec_cmd.args[CX24116_DISEQC_ARG4_0] = 0x00;\n\n\t/* DiSEqC message length */\n\tstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN] = 0x00;\n\n\t/* Command length */\n\tstate->dsec_cmd.len = CX24116_DISEQC_MSGOFS;\n\n\treturn 0;\n}\n\n/* Send DiSEqC message with derived burst (hack) || previous burst */\nstatic int cx24116_send_diseqc_msg(struct dvb_frontend *fe,\n\tstruct dvb_diseqc_master_cmd *d)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tint i, ret;\n\n\t/* Dump DiSEqC message */\n\tif (debug) {\n\t\tprintk(KERN_INFO \"cx24116: %s(\", __func__);\n\t\tfor (i = 0 ; i < d->msg_len ;) {\n\t\t\tprintk(KERN_INFO \"0x%02x\", d->msg[i]);\n\t\t\tif (++i < d->msg_len)\n\t\t\t\tprintk(KERN_INFO \", \");\n\t\t}\n\t\tprintk(\") toneburst=%d\\n\", toneburst);\n\t}\n\n\t/* Validate length */\n\tif (d->msg_len > (CX24116_ARGLEN - CX24116_DISEQC_MSGOFS))\n\t\treturn -EINVAL;\n\n\t/* DiSEqC message */\n\tfor (i = 0; i < d->msg_len; i++)\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_MSGOFS + i] = d->msg[i];\n\n\t/* DiSEqC message length */\n\tstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN] = d->msg_len;\n\n\t/* Command length */\n\tstate->dsec_cmd.len = CX24116_DISEQC_MSGOFS +\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN];\n\n\t/* DiSEqC toneburst */\n\tif (toneburst == CX24116_DISEQC_MESGCACHE)\n\t\t/* Message is cached */\n\t\treturn 0;\n\n\telse if (toneburst == CX24116_DISEQC_TONEOFF)\n\t\t/* Message is sent without burst */\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] = 0;\n\n\telse if (toneburst == CX24116_DISEQC_TONECACHE) {\n\t\t/*\n\t\t * Message is sent with derived else cached burst\n\t\t *\n\t\t * WRITE PORT GROUP COMMAND 38\n\t\t *\n\t\t * 0/A/A: E0 10 38 F0..F3\n\t\t * 1/B/B: E0 10 38 F4..F7\n\t\t * 2/C/A: E0 10 38 F8..FB\n\t\t * 3/D/B: E0 10 38 FC..FF\n\t\t *\n\t\t * databyte[3]= 8421:8421\n\t\t *              ABCD:WXYZ\n\t\t *              CLR :SET\n\t\t *\n\t\t *              WX= PORT SELECT 0..3    (X=TONEBURST)\n\t\t *              Y = VOLTAGE             (0=13V, 1=18V)\n\t\t *              Z = BAND                (0=LOW, 1=HIGH(22K))\n\t\t */\n\t\tif (d->msg_len >= 4 && d->msg[2] == 0x38)\n\t\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] =\n\t\t\t\t((d->msg[3] & 4) >> 2);\n\t\tif (debug)\n\t\t\tdprintk(\"%s burst=%d\\n\", __func__,\n\t\t\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST]);\n\t}\n\n\t/* Wait for LNB ready */\n\tret = cx24116_wait_for_lnb(fe);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* Wait for voltage/min repeat delay */\n\tmsleep(100);\n\n\t/* Command */\n\tret = cx24116_cmd_execute(fe, &state->dsec_cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\t/*\n\t * Wait for send\n\t *\n\t * Eutelsat spec:\n\t * >15ms delay          + (XXX determine if FW does this, see set_tone)\n\t *  13.5ms per byte     +\n\t * >15ms delay          +\n\t *  12.5ms burst        +\n\t * >15ms delay            (XXX determine if FW does this, see set_tone)\n\t */\n\tmsleep((state->dsec_cmd.args[CX24116_DISEQC_MSGLEN] << 4) +\n\t\t((toneburst == CX24116_DISEQC_TONEOFF) ? 30 : 60));\n\n\treturn 0;\n}\n\n/* Send DiSEqC burst */\nstatic int cx24116_diseqc_send_burst(struct dvb_frontend *fe,\n\tfe_sec_mini_cmd_t burst)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tint ret;\n\n\tdprintk(\"%s(%d) toneburst=%d\\n\", __func__, burst, toneburst);\n\n\t/* DiSEqC burst */\n\tif (burst == SEC_MINI_A)\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] =\n\t\t\tCX24116_DISEQC_MINI_A;\n\telse if (burst == SEC_MINI_B)\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] =\n\t\t\tCX24116_DISEQC_MINI_B;\n\telse\n\t\treturn -EINVAL;\n\n\t/* DiSEqC toneburst */\n\tif (toneburst != CX24116_DISEQC_MESGCACHE)\n\t\t/* Burst is cached */\n\t\treturn 0;\n\n\t/* Burst is to be sent with cached message */\n\n\t/* Wait for LNB ready */\n\tret = cx24116_wait_for_lnb(fe);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* Wait for voltage/min repeat delay */\n\tmsleep(100);\n\n\t/* Command */\n\tret = cx24116_cmd_execute(fe, &state->dsec_cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/*\n\t * Wait for send\n\t *\n\t * Eutelsat spec:\n\t * >15ms delay          + (XXX determine if FW does this, see set_tone)\n\t *  13.5ms per byte     +\n\t * >15ms delay          +\n\t *  12.5ms burst        +\n\t * >15ms delay            (XXX determine if FW does this, see set_tone)\n\t */\n\tmsleep((state->dsec_cmd.args[CX24116_DISEQC_MSGLEN] << 4) + 60);\n\n\treturn 0;\n}\n\nstatic void cx24116_release(struct dvb_frontend *fe)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tdprintk(\"%s\\n\", __func__);\n\tkfree(state);\n}\n\nstatic struct dvb_frontend_ops cx24116_ops;\n\nstruct dvb_frontend *cx24116_attach(const struct cx24116_config *config,\n\tstruct i2c_adapter *i2c)\n{\n\tstruct cx24116_state *state = NULL;\n\tint ret;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\t/* allocate memory for the internal state */\n\tstate = kzalloc(sizeof(struct cx24116_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\tgoto error1;\n\n\tstate->config = config;\n\tstate->i2c = i2c;\n\n\t/* check if the demod is present */\n\tret = (cx24116_readreg(state, 0xFF) << 8) |\n\t\tcx24116_readreg(state, 0xFE);\n\tif (ret != 0x0501) {\n\t\tprintk(KERN_INFO \"Invalid probe, probably not a CX24116 device\\n\");\n\t\tgoto error2;\n\t}\n\n\t/* create dvb_frontend */\n\tmemcpy(&state->frontend.ops, &cx24116_ops,\n\t\tsizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\treturn &state->frontend;\n\nerror2: kfree(state);\nerror1: return NULL;\n}\nEXPORT_SYMBOL(cx24116_attach);\n\n/*\n * Initialise or wake up device\n *\n * Power config will reset and load initial firmware if required\n */\nstatic int cx24116_initfe(struct dvb_frontend *fe)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tstruct cx24116_cmd cmd;\n\tint ret;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\t/* Power on */\n\tcx24116_writereg(state, 0xe0, 0);\n\tcx24116_writereg(state, 0xe1, 0);\n\tcx24116_writereg(state, 0xea, 0);\n\n\t/* Firmware CMD 36: Power config */\n\tcmd.args[0x00] = CMD_TUNERSLEEP;\n\tcmd.args[0x01] = 0;\n\tcmd.len = 0x02;\n\tret = cx24116_cmd_execute(fe, &cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tret = cx24116_diseqc_init(fe);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* HVR-4000 needs this */\n\treturn cx24116_set_voltage(fe, SEC_VOLTAGE_13);\n}\n\n/*\n * Put device to sleep\n */\nstatic int cx24116_sleep(struct dvb_frontend *fe)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tstruct cx24116_cmd cmd;\n\tint ret;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\t/* Firmware CMD 36: Power config */\n\tcmd.args[0x00] = CMD_TUNERSLEEP;\n\tcmd.args[0x01] = 1;\n\tcmd.len = 0x02;\n\tret = cx24116_cmd_execute(fe, &cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* Power off (Shutdown clocks) */\n\tcx24116_writereg(state, 0xea, 0xff);\n\tcx24116_writereg(state, 0xe1, 1);\n\tcx24116_writereg(state, 0xe0, 1);\n\n\treturn 0;\n}\n\n/* dvb-core told us to tune, the tv property cache will be complete,\n * it's safe for is to pull values and use them for tuning purposes.\n */\nstatic int cx24116_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct cx24116_cmd cmd;\n\tfe_status_t tunerstat;\n\tint i, status, ret, retune = 1;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBS:\n\t\tdprintk(\"%s: DVB-S delivery system selected\\n\", __func__);\n\n\t\t/* Only QPSK is supported for DVB-S */\n\t\tif (c->modulation != QPSK) {\n\t\t\tdprintk(\"%s: unsupported modulation selected (%d)\\n\",\n\t\t\t\t__func__, c->modulation);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\t/* Pilot doesn't exist in DVB-S, turn bit off */\n\t\tstate->dnxt.pilot_val = CX24116_PILOT_OFF;\n\n\t\t/* DVB-S only supports 0.35 */\n\t\tif (c->rolloff != ROLLOFF_35) {\n\t\t\tdprintk(\"%s: unsupported rolloff selected (%d)\\n\",\n\t\t\t\t__func__, c->rolloff);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tstate->dnxt.rolloff_val = CX24116_ROLLOFF_035;\n\t\tbreak;\n\n\tcase SYS_DVBS2:\n\t\tdprintk(\"%s: DVB-S2 delivery system selected\\n\", __func__);\n\n\t\t/*\n\t\t * NBC 8PSK/QPSK with DVB-S is supported for DVB-S2,\n\t\t * but not hardware auto detection\n\t\t */\n\t\tif (c->modulation != PSK_8 && c->modulation != QPSK) {\n\t\t\tdprintk(\"%s: unsupported modulation selected (%d)\\n\",\n\t\t\t\t__func__, c->modulation);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tswitch (c->pilot) {\n\t\tcase PILOT_AUTO:\t/* Not supported but emulated */\n\t\t\tstate->dnxt.pilot_val = (c->modulation == QPSK)\n\t\t\t\t? CX24116_PILOT_OFF : CX24116_PILOT_ON;\n\t\t\tretune++;\n\t\t\tbreak;\n\t\tcase PILOT_OFF:\n\t\t\tstate->dnxt.pilot_val = CX24116_PILOT_OFF;\n\t\t\tbreak;\n\t\tcase PILOT_ON:\n\t\t\tstate->dnxt.pilot_val = CX24116_PILOT_ON;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(\"%s: unsupported pilot mode selected (%d)\\n\",\n\t\t\t\t__func__, c->pilot);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tswitch (c->rolloff) {\n\t\tcase ROLLOFF_20:\n\t\t\tstate->dnxt.rolloff_val = CX24116_ROLLOFF_020;\n\t\t\tbreak;\n\t\tcase ROLLOFF_25:\n\t\t\tstate->dnxt.rolloff_val = CX24116_ROLLOFF_025;\n\t\t\tbreak;\n\t\tcase ROLLOFF_35:\n\t\t\tstate->dnxt.rolloff_val = CX24116_ROLLOFF_035;\n\t\t\tbreak;\n\t\tcase ROLLOFF_AUTO:\t/* Rolloff must be explicit */\n\t\tdefault:\n\t\t\tdprintk(\"%s: unsupported rolloff selected (%d)\\n\",\n\t\t\t\t__func__, c->rolloff);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdprintk(\"%s: unsupported delivery system selected (%d)\\n\",\n\t\t\t__func__, c->delivery_system);\n\t\treturn -EOPNOTSUPP;\n\t}\n\tstate->dnxt.delsys = c->delivery_system;\n\tstate->dnxt.modulation = c->modulation;\n\tstate->dnxt.frequency = c->frequency;\n\tstate->dnxt.pilot = c->pilot;\n\tstate->dnxt.rolloff = c->rolloff;\n\n\tret = cx24116_set_inversion(state, c->inversion);\n\tif (ret !=  0)\n\t\treturn ret;\n\n\t/* FEC_NONE/AUTO for DVB-S2 is not supported and detected here */\n\tret = cx24116_set_fec(state, c->delivery_system, c->modulation, c->fec_inner);\n\tif (ret !=  0)\n\t\treturn ret;\n\n\tret = cx24116_set_symbolrate(state, c->symbol_rate);\n\tif (ret !=  0)\n\t\treturn ret;\n\n\t/* discard the 'current' tuning parameters and prepare to tune */\n\tcx24116_clone_params(fe);\n\n\tdprintk(\"%s:   delsys      = %d\\n\", __func__, state->dcur.delsys);\n\tdprintk(\"%s:   modulation  = %d\\n\", __func__, state->dcur.modulation);\n\tdprintk(\"%s:   frequency   = %d\\n\", __func__, state->dcur.frequency);\n\tdprintk(\"%s:   pilot       = %d (val = 0x%02x)\\n\", __func__,\n\t\tstate->dcur.pilot, state->dcur.pilot_val);\n\tdprintk(\"%s:   retune      = %d\\n\", __func__, retune);\n\tdprintk(\"%s:   rolloff     = %d (val = 0x%02x)\\n\", __func__,\n\t\tstate->dcur.rolloff, state->dcur.rolloff_val);\n\tdprintk(\"%s:   symbol_rate = %d\\n\", __func__, state->dcur.symbol_rate);\n\tdprintk(\"%s:   FEC         = %d (mask/val = 0x%02x/0x%02x)\\n\", __func__,\n\t\tstate->dcur.fec, state->dcur.fec_mask, state->dcur.fec_val);\n\tdprintk(\"%s:   Inversion   = %d (val = 0x%02x)\\n\", __func__,\n\t\tstate->dcur.inversion, state->dcur.inversion_val);\n\n\t/* This is also done in advise/acquire on HVR4000 but not on LITE */\n\tif (state->config->set_ts_params)\n\t\tstate->config->set_ts_params(fe, 0);\n\n\t/* Set/Reset B/W */\n\tcmd.args[0x00] = CMD_BANDWIDTH;\n\tcmd.args[0x01] = 0x01;\n\tcmd.len = 0x02;\n\tret = cx24116_cmd_execute(fe, &cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* Prepare a tune request */\n\tcmd.args[0x00] = CMD_TUNEREQUEST;\n\n\t/* Frequency */\n\tcmd.args[0x01] = (state->dcur.frequency & 0xff0000) >> 16;\n\tcmd.args[0x02] = (state->dcur.frequency & 0x00ff00) >> 8;\n\tcmd.args[0x03] = (state->dcur.frequency & 0x0000ff);\n\n\t/* Symbol Rate */\n\tcmd.args[0x04] = ((state->dcur.symbol_rate / 1000) & 0xff00) >> 8;\n\tcmd.args[0x05] = ((state->dcur.symbol_rate / 1000) & 0x00ff);\n\n\t/* Automatic Inversion */\n\tcmd.args[0x06] = state->dcur.inversion_val;\n\n\t/* Modulation / FEC / Pilot */\n\tcmd.args[0x07] = state->dcur.fec_val | state->dcur.pilot_val;\n\n\tcmd.args[0x08] = CX24116_SEARCH_RANGE_KHZ >> 8;\n\tcmd.args[0x09] = CX24116_SEARCH_RANGE_KHZ & 0xff;\n\tcmd.args[0x0a] = 0x00;\n\tcmd.args[0x0b] = 0x00;\n\tcmd.args[0x0c] = state->dcur.rolloff_val;\n\tcmd.args[0x0d] = state->dcur.fec_mask;\n\n\tif (state->dcur.symbol_rate > 30000000) {\n\t\tcmd.args[0x0e] = 0x04;\n\t\tcmd.args[0x0f] = 0x00;\n\t\tcmd.args[0x10] = 0x01;\n\t\tcmd.args[0x11] = 0x77;\n\t\tcmd.args[0x12] = 0x36;\n\t\tcx24116_writereg(state, CX24116_REG_CLKDIV, 0x44);\n\t\tcx24116_writereg(state, CX24116_REG_RATEDIV, 0x01);\n\t} else {\n\t\tcmd.args[0x0e] = 0x06;\n\t\tcmd.args[0x0f] = 0x00;\n\t\tcmd.args[0x10] = 0x00;\n\t\tcmd.args[0x11] = 0xFA;\n\t\tcmd.args[0x12] = 0x24;\n\t\tcx24116_writereg(state, CX24116_REG_CLKDIV, 0x46);\n\t\tcx24116_writereg(state, CX24116_REG_RATEDIV, 0x00);\n\t}\n\n\tcmd.len = 0x13;\n\n\t/* We need to support pilot and non-pilot tuning in the\n\t * driver automatically. This is a workaround for because\n\t * the demod does not support autodetect.\n\t */\n\tdo {\n\t\t/* Reset status register */\n\t\tstatus = cx24116_readreg(state, CX24116_REG_SSTATUS)\n\t\t\t& CX24116_SIGNAL_MASK;\n\t\tcx24116_writereg(state, CX24116_REG_SSTATUS, status);\n\n\t\t/* Tune */\n\t\tret = cx24116_cmd_execute(fe, &cmd);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Wait for up to 500 ms before retrying\n\t\t *\n\t\t * If we are able to tune then generally it occurs within 100ms.\n\t\t * If it takes longer, try a different toneburst setting.\n\t\t */\n\t\tfor (i = 0; i < 50 ; i++) {\n\t\t\tcx24116_read_status(fe, &tunerstat);\n\t\t\tstatus = tunerstat & (FE_HAS_SIGNAL | FE_HAS_SYNC);\n\t\t\tif (status == (FE_HAS_SIGNAL | FE_HAS_SYNC)) {\n\t\t\t\tdprintk(\"%s: Tuned\\n\", __func__);\n\t\t\t\tgoto tuned;\n\t\t\t}\n\t\t\tmsleep(10);\n\t\t}\n\n\t\tdprintk(\"%s: Not tuned\\n\", __func__);\n\n\t\t/* Toggle pilot bit when in auto-pilot */\n\t\tif (state->dcur.pilot == PILOT_AUTO)\n\t\t\tcmd.args[0x07] ^= CX24116_PILOT_ON;\n\t} while (--retune);\n\ntuned:  /* Set/Reset B/W */\n\tcmd.args[0x00] = CMD_BANDWIDTH;\n\tcmd.args[0x01] = 0x00;\n\tcmd.len = 0x02;\n\treturn cx24116_cmd_execute(fe, &cmd);\n}\n\nstatic int cx24116_tune(struct dvb_frontend *fe, bool re_tune,\n\tunsigned int mode_flags, unsigned int *delay, fe_status_t *status)\n{\n\t/*\n\t * It is safe to discard \"params\" here, as the DVB core will sync\n\t * fe->dtv_property_cache with fepriv->parameters_in, where the\n\t * DVBv3 params are stored. The only practical usage for it indicate\n\t * that re-tuning is needed, e. g. (fepriv->state & FESTATE_RETUNE) is\n\t * true.\n\t */\n\n\t*delay = HZ / 5;\n\tif (re_tune) {\n\t\tint ret = cx24116_set_frontend(fe);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn cx24116_read_status(fe, status);\n}\n\nstatic int cx24116_get_algo(struct dvb_frontend *fe)\n{\n\treturn DVBFE_ALGO_HW;\n}\n\nstatic struct dvb_frontend_ops cx24116_ops = {\n\t.delsys = { SYS_DVBS, SYS_DVBS2 },\n\t.info = {\n\t\t.name = \"Conexant CX24116/CX24118\",\n\t\t.frequency_min = 950000,\n\t\t.frequency_max = 2150000,\n\t\t.frequency_stepsize = 1011, /* kHz for QPSK frontends */\n\t\t.frequency_tolerance = 5000,\n\t\t.symbol_rate_min = 1000000,\n\t\t.symbol_rate_max = 45000000,\n\t\t.caps = FE_CAN_INVERSION_AUTO |\n\t\t\tFE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_4_5 | FE_CAN_FEC_5_6 | FE_CAN_FEC_6_7 |\n\t\t\tFE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_2G_MODULATION |\n\t\t\tFE_CAN_QPSK | FE_CAN_RECOVER\n\t},\n\n\t.release = cx24116_release,\n\n\t.init = cx24116_initfe,\n\t.sleep = cx24116_sleep,\n\t.read_status = cx24116_read_status,\n\t.read_ber = cx24116_read_ber,\n\t.read_signal_strength = cx24116_read_signal_strength,\n\t.read_snr = cx24116_read_snr,\n\t.read_ucblocks = cx24116_read_ucblocks,\n\t.set_tone = cx24116_set_tone,\n\t.set_voltage = cx24116_set_voltage,\n\t.diseqc_send_master_cmd = cx24116_send_diseqc_msg,\n\t.diseqc_send_burst = cx24116_diseqc_send_burst,\n\t.get_frontend_algo = cx24116_get_algo,\n\t.tune = cx24116_tune,\n\n\t.set_frontend = cx24116_set_frontend,\n};\n\nMODULE_DESCRIPTION(\"DVB Frontend module for Conexant cx24116/cx24118 hardware\");\nMODULE_AUTHOR(\"Steven Toth\");\nMODULE_LICENSE(\"GPL\");\n\n"], "fixing_code": ["/*\n    Conexant cx24116/cx24118 - DVBS/S2 Satellite demod/tuner driver\n\n    Copyright (C) 2006-2008 Steven Toth <stoth@hauppauge.com>\n    Copyright (C) 2006-2007 Georg Acher\n    Copyright (C) 2007-2008 Darron Broad\n\tMarch 2007\n\t    Fixed some bugs.\n\t    Added diseqc support.\n\t    Added corrected signal strength support.\n\tAugust 2007\n\t    Sync with legacy version.\n\t    Some clean ups.\n    Copyright (C) 2008 Igor Liplianin\n\tSeptember, 9th 2008\n\t    Fixed locking on high symbol rates (>30000).\n\t    Implement MPEG initialization parameter.\n\tJanuary, 17th 2009\n\t    Fill set_voltage with actually control voltage code.\n\t    Correct set tone to not affect voltage.\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n*/\n\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/firmware.h>\n\n#include \"dvb_frontend.h\"\n#include \"cx24116.h\"\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Activates frontend debugging (default:0)\");\n\n#define dprintk(args...) \\\n\tdo { \\\n\t\tif (debug) \\\n\t\t\tprintk(KERN_INFO \"cx24116: \" args); \\\n\t} while (0)\n\n#define CX24116_DEFAULT_FIRMWARE \"dvb-fe-cx24116.fw\"\n#define CX24116_SEARCH_RANGE_KHZ 5000\n\n/* known registers */\n#define CX24116_REG_COMMAND (0x00)      /* command args 0x00..0x1e */\n#define CX24116_REG_EXECUTE (0x1f)      /* execute command */\n#define CX24116_REG_MAILBOX (0x96)      /* FW or multipurpose mailbox? */\n#define CX24116_REG_RESET   (0x20)      /* reset status > 0     */\n#define CX24116_REG_SIGNAL  (0x9e)      /* signal low           */\n#define CX24116_REG_SSTATUS (0x9d)      /* signal high / status */\n#define CX24116_REG_QUALITY8 (0xa3)\n#define CX24116_REG_QSTATUS (0xbc)\n#define CX24116_REG_QUALITY0 (0xd5)\n#define CX24116_REG_BER0    (0xc9)\n#define CX24116_REG_BER8    (0xc8)\n#define CX24116_REG_BER16   (0xc7)\n#define CX24116_REG_BER24   (0xc6)\n#define CX24116_REG_UCB0    (0xcb)\n#define CX24116_REG_UCB8    (0xca)\n#define CX24116_REG_CLKDIV  (0xf3)\n#define CX24116_REG_RATEDIV (0xf9)\n\n/* configured fec (not tuned) or actual FEC (tuned) 1=1/2 2=2/3 etc */\n#define CX24116_REG_FECSTATUS (0x9c)\n\n/* FECSTATUS bits */\n/* mask to determine configured fec (not tuned) or actual fec (tuned) */\n#define CX24116_FEC_FECMASK   (0x1f)\n\n/* Select DVB-S demodulator, else DVB-S2 */\n#define CX24116_FEC_DVBS      (0x20)\n#define CX24116_FEC_UNKNOWN   (0x40)    /* Unknown/unused */\n\n/* Pilot mode requested when tuning else always reset when tuned */\n#define CX24116_FEC_PILOT     (0x80)\n\n/* arg buffer size */\n#define CX24116_ARGLEN (0x1e)\n\n/* rolloff */\n#define CX24116_ROLLOFF_020 (0x00)\n#define CX24116_ROLLOFF_025 (0x01)\n#define CX24116_ROLLOFF_035 (0x02)\n\n/* pilot bit */\n#define CX24116_PILOT_OFF (0x00)\n#define CX24116_PILOT_ON (0x40)\n\n/* signal status */\n#define CX24116_HAS_SIGNAL   (0x01)\n#define CX24116_HAS_CARRIER  (0x02)\n#define CX24116_HAS_VITERBI  (0x04)\n#define CX24116_HAS_SYNCLOCK (0x08)\n#define CX24116_HAS_UNKNOWN1 (0x10)\n#define CX24116_HAS_UNKNOWN2 (0x20)\n#define CX24116_STATUS_MASK  (0x0f)\n#define CX24116_SIGNAL_MASK  (0xc0)\n\n#define CX24116_DISEQC_TONEOFF   (0)    /* toneburst never sent */\n#define CX24116_DISEQC_TONECACHE (1)    /* toneburst cached     */\n#define CX24116_DISEQC_MESGCACHE (2)    /* message cached       */\n\n/* arg offset for DiSEqC */\n#define CX24116_DISEQC_BURST  (1)\n#define CX24116_DISEQC_ARG2_2 (2)   /* unknown value=2 */\n#define CX24116_DISEQC_ARG3_0 (3)   /* unknown value=0 */\n#define CX24116_DISEQC_ARG4_0 (4)   /* unknown value=0 */\n#define CX24116_DISEQC_MSGLEN (5)\n#define CX24116_DISEQC_MSGOFS (6)\n\n/* DiSEqC burst */\n#define CX24116_DISEQC_MINI_A (0)\n#define CX24116_DISEQC_MINI_B (1)\n\n/* DiSEqC tone burst */\nstatic int toneburst = 1;\nmodule_param(toneburst, int, 0644);\nMODULE_PARM_DESC(toneburst, \"DiSEqC toneburst 0=OFF, 1=TONE CACHE, \"\\\n\t\"2=MESSAGE CACHE (default:1)\");\n\n/* SNR measurements */\nstatic int esno_snr;\nmodule_param(esno_snr, int, 0644);\nMODULE_PARM_DESC(esno_snr, \"SNR return units, 0=PERCENTAGE 0-100, \"\\\n\t\"1=ESNO(db * 10) (default:0)\");\n\nenum cmds {\n\tCMD_SET_VCO     = 0x10,\n\tCMD_TUNEREQUEST = 0x11,\n\tCMD_MPEGCONFIG  = 0x13,\n\tCMD_TUNERINIT   = 0x14,\n\tCMD_BANDWIDTH   = 0x15,\n\tCMD_GETAGC      = 0x19,\n\tCMD_LNBCONFIG   = 0x20,\n\tCMD_LNBSEND     = 0x21, /* Formerly CMD_SEND_DISEQC */\n\tCMD_LNBDCLEVEL  = 0x22,\n\tCMD_SET_TONE    = 0x23,\n\tCMD_UPDFWVERS   = 0x35,\n\tCMD_TUNERSLEEP  = 0x36,\n\tCMD_AGCCONTROL  = 0x3b, /* Unknown */\n};\n\n/* The Demod/Tuner can't easily provide these, we cache them */\nstruct cx24116_tuning {\n\tu32 frequency;\n\tu32 symbol_rate;\n\tfe_spectral_inversion_t inversion;\n\tfe_code_rate_t fec;\n\n\tfe_delivery_system_t delsys;\n\tfe_modulation_t modulation;\n\tfe_pilot_t pilot;\n\tfe_rolloff_t rolloff;\n\n\t/* Demod values */\n\tu8 fec_val;\n\tu8 fec_mask;\n\tu8 inversion_val;\n\tu8 pilot_val;\n\tu8 rolloff_val;\n};\n\n/* Basic commands that are sent to the firmware */\nstruct cx24116_cmd {\n\tu8 len;\n\tu8 args[CX24116_ARGLEN];\n};\n\nstruct cx24116_state {\n\tstruct i2c_adapter *i2c;\n\tconst struct cx24116_config *config;\n\n\tstruct dvb_frontend frontend;\n\n\tstruct cx24116_tuning dcur;\n\tstruct cx24116_tuning dnxt;\n\n\tu8 skip_fw_load;\n\tu8 burst;\n\tstruct cx24116_cmd dsec_cmd;\n};\n\nstatic int cx24116_writereg(struct cx24116_state *state, int reg, int data)\n{\n\tu8 buf[] = { reg, data };\n\tstruct i2c_msg msg = { .addr = state->config->demod_address,\n\t\t.flags = 0, .buf = buf, .len = 2 };\n\tint err;\n\n\tif (debug > 1)\n\t\tprintk(\"cx24116: %s: write reg 0x%02x, value 0x%02x\\n\",\n\t\t\t__func__, reg, data);\n\n\terr = i2c_transfer(state->i2c, &msg, 1);\n\tif (err != 1) {\n\t\tprintk(KERN_ERR \"%s: writereg error(err == %i, reg == 0x%02x,\"\n\t\t\t \" value == 0x%02x)\\n\", __func__, err, reg, data);\n\t\treturn -EREMOTEIO;\n\t}\n\n\treturn 0;\n}\n\n/* Bulk byte writes to a single I2C address, for 32k firmware load */\nstatic int cx24116_writeregN(struct cx24116_state *state, int reg,\n\t\t\t     const u8 *data, u16 len)\n{\n\tint ret = -EREMOTEIO;\n\tstruct i2c_msg msg;\n\tu8 *buf;\n\n\tbuf = kmalloc(len + 1, GFP_KERNEL);\n\tif (buf == NULL) {\n\t\tprintk(\"Unable to kmalloc\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\t*(buf) = reg;\n\tmemcpy(buf + 1, data, len);\n\n\tmsg.addr = state->config->demod_address;\n\tmsg.flags = 0;\n\tmsg.buf = buf;\n\tmsg.len = len + 1;\n\n\tif (debug > 1)\n\t\tprintk(KERN_INFO \"cx24116: %s:  write regN 0x%02x, len = %d\\n\",\n\t\t\t__func__, reg, len);\n\n\tret = i2c_transfer(state->i2c, &msg, 1);\n\tif (ret != 1) {\n\t\tprintk(KERN_ERR \"%s: writereg error(err == %i, reg == 0x%02x\\n\",\n\t\t\t __func__, ret, reg);\n\t\tret = -EREMOTEIO;\n\t}\n\nerror:\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic int cx24116_readreg(struct cx24116_state *state, u8 reg)\n{\n\tint ret;\n\tu8 b0[] = { reg };\n\tu8 b1[] = { 0 };\n\tstruct i2c_msg msg[] = {\n\t\t{ .addr = state->config->demod_address, .flags = 0,\n\t\t\t.buf = b0, .len = 1 },\n\t\t{ .addr = state->config->demod_address, .flags = I2C_M_RD,\n\t\t\t.buf = b1, .len = 1 }\n\t};\n\n\tret = i2c_transfer(state->i2c, msg, 2);\n\n\tif (ret != 2) {\n\t\tprintk(KERN_ERR \"%s: reg=0x%x (error=%d)\\n\",\n\t\t\t__func__, reg, ret);\n\t\treturn ret;\n\t}\n\n\tif (debug > 1)\n\t\tprintk(KERN_INFO \"cx24116: read reg 0x%02x, value 0x%02x\\n\",\n\t\t\treg, b1[0]);\n\n\treturn b1[0];\n}\n\nstatic int cx24116_set_inversion(struct cx24116_state *state,\n\tfe_spectral_inversion_t inversion)\n{\n\tdprintk(\"%s(%d)\\n\", __func__, inversion);\n\n\tswitch (inversion) {\n\tcase INVERSION_OFF:\n\t\tstate->dnxt.inversion_val = 0x00;\n\t\tbreak;\n\tcase INVERSION_ON:\n\t\tstate->dnxt.inversion_val = 0x04;\n\t\tbreak;\n\tcase INVERSION_AUTO:\n\t\tstate->dnxt.inversion_val = 0x0C;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tstate->dnxt.inversion = inversion;\n\n\treturn 0;\n}\n\n/*\n * modfec (modulation and FEC)\n * ===========================\n *\n * MOD          FEC             mask/val    standard\n * ----         --------        ----------- --------\n * QPSK         FEC_1_2         0x02 0x02+X DVB-S\n * QPSK         FEC_2_3         0x04 0x02+X DVB-S\n * QPSK         FEC_3_4         0x08 0x02+X DVB-S\n * QPSK         FEC_4_5         0x10 0x02+X DVB-S (?)\n * QPSK         FEC_5_6         0x20 0x02+X DVB-S\n * QPSK         FEC_6_7         0x40 0x02+X DVB-S\n * QPSK         FEC_7_8         0x80 0x02+X DVB-S\n * QPSK         FEC_8_9         0x01 0x02+X DVB-S (?) (NOT SUPPORTED?)\n * QPSK         AUTO            0xff 0x02+X DVB-S\n *\n * For DVB-S high byte probably represents FEC\n * and low byte selects the modulator. The high\n * byte is search range mask. Bit 5 may turn\n * on DVB-S and remaining bits represent some\n * kind of calibration (how/what i do not know).\n *\n * Eg.(2/3) szap \"Zone Horror\"\n *\n * mask/val = 0x04, 0x20\n * status 1f | signal c3c0 | snr a333 | ber 00000098 | unc 0 | FE_HAS_LOCK\n *\n * mask/val = 0x04, 0x30\n * status 1f | signal c3c0 | snr a333 | ber 00000000 | unc 0 | FE_HAS_LOCK\n *\n * After tuning FECSTATUS contains actual FEC\n * in use numbered 1 through to 8 for 1/2 .. 2/3 etc\n *\n * NBC=NOT/NON BACKWARD COMPATIBLE WITH DVB-S (DVB-S2 only)\n *\n * NBC-QPSK     FEC_1_2         0x00, 0x04      DVB-S2\n * NBC-QPSK     FEC_3_5         0x00, 0x05      DVB-S2\n * NBC-QPSK     FEC_2_3         0x00, 0x06      DVB-S2\n * NBC-QPSK     FEC_3_4         0x00, 0x07      DVB-S2\n * NBC-QPSK     FEC_4_5         0x00, 0x08      DVB-S2\n * NBC-QPSK     FEC_5_6         0x00, 0x09      DVB-S2\n * NBC-QPSK     FEC_8_9         0x00, 0x0a      DVB-S2\n * NBC-QPSK     FEC_9_10        0x00, 0x0b      DVB-S2\n *\n * NBC-8PSK     FEC_3_5         0x00, 0x0c      DVB-S2\n * NBC-8PSK     FEC_2_3         0x00, 0x0d      DVB-S2\n * NBC-8PSK     FEC_3_4         0x00, 0x0e      DVB-S2\n * NBC-8PSK     FEC_5_6         0x00, 0x0f      DVB-S2\n * NBC-8PSK     FEC_8_9         0x00, 0x10      DVB-S2\n * NBC-8PSK     FEC_9_10        0x00, 0x11      DVB-S2\n *\n * For DVB-S2 low bytes selects both modulator\n * and FEC. High byte is meaningless here. To\n * set pilot, bit 6 (0x40) is set. When inspecting\n * FECSTATUS bit 7 (0x80) represents the pilot\n * selection whilst not tuned. When tuned, actual FEC\n * in use is found in FECSTATUS as per above. Pilot\n * value is reset.\n */\n\n/* A table of modulation, fec and configuration bytes for the demod.\n * Not all S2 mmodulation schemes are support and not all rates with\n * a scheme are support. Especially, no auto detect when in S2 mode.\n */\nstatic struct cx24116_modfec {\n\tfe_delivery_system_t delivery_system;\n\tfe_modulation_t modulation;\n\tfe_code_rate_t fec;\n\tu8 mask;\t/* In DVBS mode this is used to autodetect */\n\tu8 val;\t\t/* Passed to the firmware to indicate mode selection */\n} CX24116_MODFEC_MODES[] = {\n /* QPSK. For unknown rates we set hardware to auto detect 0xfe 0x30 */\n\n /*mod   fec       mask  val */\n { SYS_DVBS, QPSK, FEC_NONE, 0xfe, 0x30 },\n { SYS_DVBS, QPSK, FEC_1_2,  0x02, 0x2e }, /* 00000010 00101110 */\n { SYS_DVBS, QPSK, FEC_2_3,  0x04, 0x2f }, /* 00000100 00101111 */\n { SYS_DVBS, QPSK, FEC_3_4,  0x08, 0x30 }, /* 00001000 00110000 */\n { SYS_DVBS, QPSK, FEC_4_5,  0xfe, 0x30 }, /* 000?0000 ?        */\n { SYS_DVBS, QPSK, FEC_5_6,  0x20, 0x31 }, /* 00100000 00110001 */\n { SYS_DVBS, QPSK, FEC_6_7,  0xfe, 0x30 }, /* 0?000000 ?        */\n { SYS_DVBS, QPSK, FEC_7_8,  0x80, 0x32 }, /* 10000000 00110010 */\n { SYS_DVBS, QPSK, FEC_8_9,  0xfe, 0x30 }, /* 0000000? ?        */\n { SYS_DVBS, QPSK, FEC_AUTO, 0xfe, 0x30 },\n /* NBC-QPSK */\n { SYS_DVBS2, QPSK, FEC_1_2,  0x00, 0x04 },\n { SYS_DVBS2, QPSK, FEC_3_5,  0x00, 0x05 },\n { SYS_DVBS2, QPSK, FEC_2_3,  0x00, 0x06 },\n { SYS_DVBS2, QPSK, FEC_3_4,  0x00, 0x07 },\n { SYS_DVBS2, QPSK, FEC_4_5,  0x00, 0x08 },\n { SYS_DVBS2, QPSK, FEC_5_6,  0x00, 0x09 },\n { SYS_DVBS2, QPSK, FEC_8_9,  0x00, 0x0a },\n { SYS_DVBS2, QPSK, FEC_9_10, 0x00, 0x0b },\n /* 8PSK */\n { SYS_DVBS2, PSK_8, FEC_3_5,  0x00, 0x0c },\n { SYS_DVBS2, PSK_8, FEC_2_3,  0x00, 0x0d },\n { SYS_DVBS2, PSK_8, FEC_3_4,  0x00, 0x0e },\n { SYS_DVBS2, PSK_8, FEC_5_6,  0x00, 0x0f },\n { SYS_DVBS2, PSK_8, FEC_8_9,  0x00, 0x10 },\n { SYS_DVBS2, PSK_8, FEC_9_10, 0x00, 0x11 },\n /*\n  * `val' can be found in the FECSTATUS register when tuning.\n  * FECSTATUS will give the actual FEC in use if tuning was successful.\n  */\n};\n\nstatic int cx24116_lookup_fecmod(struct cx24116_state *state,\n\tfe_delivery_system_t d, fe_modulation_t m, fe_code_rate_t f)\n{\n\tint i, ret = -EOPNOTSUPP;\n\n\tdprintk(\"%s(0x%02x,0x%02x)\\n\", __func__, m, f);\n\n\tfor (i = 0; i < ARRAY_SIZE(CX24116_MODFEC_MODES); i++) {\n\t\tif ((d == CX24116_MODFEC_MODES[i].delivery_system) &&\n\t\t\t(m == CX24116_MODFEC_MODES[i].modulation) &&\n\t\t\t(f == CX24116_MODFEC_MODES[i].fec)) {\n\t\t\t\tret = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int cx24116_set_fec(struct cx24116_state *state,\n\tfe_delivery_system_t delsys, fe_modulation_t mod, fe_code_rate_t fec)\n{\n\tint ret = 0;\n\n\tdprintk(\"%s(0x%02x,0x%02x)\\n\", __func__, mod, fec);\n\n\tret = cx24116_lookup_fecmod(state, delsys, mod, fec);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tstate->dnxt.fec = fec;\n\tstate->dnxt.fec_val = CX24116_MODFEC_MODES[ret].val;\n\tstate->dnxt.fec_mask = CX24116_MODFEC_MODES[ret].mask;\n\tdprintk(\"%s() mask/val = 0x%02x/0x%02x\\n\", __func__,\n\t\tstate->dnxt.fec_mask, state->dnxt.fec_val);\n\n\treturn 0;\n}\n\nstatic int cx24116_set_symbolrate(struct cx24116_state *state, u32 rate)\n{\n\tdprintk(\"%s(%d)\\n\", __func__, rate);\n\n\t/*  check if symbol rate is within limits */\n\tif ((rate > state->frontend.ops.info.symbol_rate_max) ||\n\t    (rate < state->frontend.ops.info.symbol_rate_min)) {\n\t\tdprintk(\"%s() unsupported symbol_rate = %d\\n\", __func__, rate);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tstate->dnxt.symbol_rate = rate;\n\tdprintk(\"%s() symbol_rate = %d\\n\", __func__, rate);\n\n\treturn 0;\n}\n\nstatic int cx24116_load_firmware(struct dvb_frontend *fe,\n\tconst struct firmware *fw);\n\nstatic int cx24116_firmware_ondemand(struct dvb_frontend *fe)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tconst struct firmware *fw;\n\tint ret = 0;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\tif (cx24116_readreg(state, 0x20) > 0) {\n\n\t\tif (state->skip_fw_load)\n\t\t\treturn 0;\n\n\t\t/* Load firmware */\n\t\t/* request the firmware, this will block until loaded */\n\t\tprintk(KERN_INFO \"%s: Waiting for firmware upload (%s)...\\n\",\n\t\t\t__func__, CX24116_DEFAULT_FIRMWARE);\n\t\tret = request_firmware(&fw, CX24116_DEFAULT_FIRMWARE,\n\t\t\tstate->i2c->dev.parent);\n\t\tprintk(KERN_INFO \"%s: Waiting for firmware upload(2)...\\n\",\n\t\t\t__func__);\n\t\tif (ret) {\n\t\t\tprintk(KERN_ERR \"%s: No firmware uploaded \"\n\t\t\t\t\"(timeout or file not found?)\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* Make sure we don't recurse back through here\n\t\t * during loading */\n\t\tstate->skip_fw_load = 1;\n\n\t\tret = cx24116_load_firmware(fe, fw);\n\t\tif (ret)\n\t\t\tprintk(KERN_ERR \"%s: Writing firmware to device failed\\n\",\n\t\t\t\t__func__);\n\n\t\trelease_firmware(fw);\n\n\t\tprintk(KERN_INFO \"%s: Firmware upload %s\\n\", __func__,\n\t\t\tret == 0 ? \"complete\" : \"failed\");\n\n\t\t/* Ensure firmware is always loaded if required */\n\t\tstate->skip_fw_load = 0;\n\t}\n\n\treturn ret;\n}\n\n/* Take a basic firmware command structure, format it\n * and forward it for processing\n */\nstatic int cx24116_cmd_execute(struct dvb_frontend *fe, struct cx24116_cmd *cmd)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tint i, ret;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\t/* Load the firmware if required */\n\tret = cx24116_firmware_ondemand(fe);\n\tif (ret != 0) {\n\t\tprintk(KERN_ERR \"%s(): Unable initialise the firmware\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\t/* Write the command */\n\tfor (i = 0; i < cmd->len ; i++) {\n\t\tdprintk(\"%s: 0x%02x == 0x%02x\\n\", __func__, i, cmd->args[i]);\n\t\tcx24116_writereg(state, i, cmd->args[i]);\n\t}\n\n\t/* Start execution and wait for cmd to terminate */\n\tcx24116_writereg(state, CX24116_REG_EXECUTE, 0x01);\n\twhile (cx24116_readreg(state, CX24116_REG_EXECUTE)) {\n\t\tmsleep(10);\n\t\tif (i++ > 64) {\n\t\t\t/* Avoid looping forever if the firmware does\n\t\t\t\tnot respond */\n\t\t\tprintk(KERN_WARNING \"%s() Firmware not responding\\n\",\n\t\t\t\t__func__);\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int cx24116_load_firmware(struct dvb_frontend *fe,\n\tconst struct firmware *fw)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tstruct cx24116_cmd cmd;\n\tint i, ret, len, max, remaining;\n\tunsigned char vers[4];\n\n\tdprintk(\"%s\\n\", __func__);\n\tdprintk(\"Firmware is %zu bytes (%02x %02x .. %02x %02x)\\n\",\n\t\t\tfw->size,\n\t\t\tfw->data[0],\n\t\t\tfw->data[1],\n\t\t\tfw->data[fw->size-2],\n\t\t\tfw->data[fw->size-1]);\n\n\t/* Toggle 88x SRST pin to reset demod */\n\tif (state->config->reset_device)\n\t\tstate->config->reset_device(fe);\n\n\t/* Begin the firmware load process */\n\t/* Prepare the demod, load the firmware, cleanup after load */\n\n\t/* Init PLL */\n\tcx24116_writereg(state, 0xE5, 0x00);\n\tcx24116_writereg(state, 0xF1, 0x08);\n\tcx24116_writereg(state, 0xF2, 0x13);\n\n\t/* Start PLL */\n\tcx24116_writereg(state, 0xe0, 0x03);\n\tcx24116_writereg(state, 0xe0, 0x00);\n\n\t/* Unknown */\n\tcx24116_writereg(state, CX24116_REG_CLKDIV, 0x46);\n\tcx24116_writereg(state, CX24116_REG_RATEDIV, 0x00);\n\n\t/* Unknown */\n\tcx24116_writereg(state, 0xF0, 0x03);\n\tcx24116_writereg(state, 0xF4, 0x81);\n\tcx24116_writereg(state, 0xF5, 0x00);\n\tcx24116_writereg(state, 0xF6, 0x00);\n\n\t/* Split firmware to the max I2C write len and write.\n\t * Writes whole firmware as one write when i2c_wr_max is set to 0. */\n\tif (state->config->i2c_wr_max)\n\t\tmax = state->config->i2c_wr_max;\n\telse\n\t\tmax = INT_MAX; /* enough for 32k firmware */\n\n\tfor (remaining = fw->size; remaining > 0; remaining -= max - 1) {\n\t\tlen = remaining;\n\t\tif (len > max - 1)\n\t\t\tlen = max - 1;\n\n\t\tcx24116_writeregN(state, 0xF7, &fw->data[fw->size - remaining],\n\t\t\tlen);\n\t}\n\n\tcx24116_writereg(state, 0xF4, 0x10);\n\tcx24116_writereg(state, 0xF0, 0x00);\n\tcx24116_writereg(state, 0xF8, 0x06);\n\n\t/* Firmware CMD 10: VCO config */\n\tcmd.args[0x00] = CMD_SET_VCO;\n\tcmd.args[0x01] = 0x05;\n\tcmd.args[0x02] = 0xdc;\n\tcmd.args[0x03] = 0xda;\n\tcmd.args[0x04] = 0xae;\n\tcmd.args[0x05] = 0xaa;\n\tcmd.args[0x06] = 0x04;\n\tcmd.args[0x07] = 0x9d;\n\tcmd.args[0x08] = 0xfc;\n\tcmd.args[0x09] = 0x06;\n\tcmd.len = 0x0a;\n\tret = cx24116_cmd_execute(fe, &cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tcx24116_writereg(state, CX24116_REG_SSTATUS, 0x00);\n\n\t/* Firmware CMD 14: Tuner config */\n\tcmd.args[0x00] = CMD_TUNERINIT;\n\tcmd.args[0x01] = 0x00;\n\tcmd.args[0x02] = 0x00;\n\tcmd.len = 0x03;\n\tret = cx24116_cmd_execute(fe, &cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tcx24116_writereg(state, 0xe5, 0x00);\n\n\t/* Firmware CMD 13: MPEG config */\n\tcmd.args[0x00] = CMD_MPEGCONFIG;\n\tcmd.args[0x01] = 0x01;\n\tcmd.args[0x02] = 0x75;\n\tcmd.args[0x03] = 0x00;\n\tif (state->config->mpg_clk_pos_pol)\n\t\tcmd.args[0x04] = state->config->mpg_clk_pos_pol;\n\telse\n\t\tcmd.args[0x04] = 0x02;\n\tcmd.args[0x05] = 0x00;\n\tcmd.len = 0x06;\n\tret = cx24116_cmd_execute(fe, &cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* Firmware CMD 35: Get firmware version */\n\tcmd.args[0x00] = CMD_UPDFWVERS;\n\tcmd.len = 0x02;\n\tfor (i = 0; i < 4; i++) {\n\t\tcmd.args[0x01] = i;\n\t\tret = cx24116_cmd_execute(fe, &cmd);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tvers[i] = cx24116_readreg(state, CX24116_REG_MAILBOX);\n\t}\n\tprintk(KERN_INFO \"%s: FW version %i.%i.%i.%i\\n\", __func__,\n\t\tvers[0], vers[1], vers[2], vers[3]);\n\n\treturn 0;\n}\n\nstatic int cx24116_read_status(struct dvb_frontend *fe, fe_status_t *status)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\n\tint lock = cx24116_readreg(state, CX24116_REG_SSTATUS) &\n\t\tCX24116_STATUS_MASK;\n\n\tdprintk(\"%s: status = 0x%02x\\n\", __func__, lock);\n\n\t*status = 0;\n\n\tif (lock & CX24116_HAS_SIGNAL)\n\t\t*status |= FE_HAS_SIGNAL;\n\tif (lock & CX24116_HAS_CARRIER)\n\t\t*status |= FE_HAS_CARRIER;\n\tif (lock & CX24116_HAS_VITERBI)\n\t\t*status |= FE_HAS_VITERBI;\n\tif (lock & CX24116_HAS_SYNCLOCK)\n\t\t*status |= FE_HAS_SYNC | FE_HAS_LOCK;\n\n\treturn 0;\n}\n\nstatic int cx24116_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\t*ber =  (cx24116_readreg(state, CX24116_REG_BER24) << 24) |\n\t\t(cx24116_readreg(state, CX24116_REG_BER16) << 16) |\n\t\t(cx24116_readreg(state, CX24116_REG_BER8)  << 8)  |\n\t\t cx24116_readreg(state, CX24116_REG_BER0);\n\n\treturn 0;\n}\n\n/* TODO Determine function and scale appropriately */\nstatic int cx24116_read_signal_strength(struct dvb_frontend *fe,\n\tu16 *signal_strength)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tstruct cx24116_cmd cmd;\n\tint ret;\n\tu16 sig_reading;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\t/* Firmware CMD 19: Get AGC */\n\tcmd.args[0x00] = CMD_GETAGC;\n\tcmd.len = 0x01;\n\tret = cx24116_cmd_execute(fe, &cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tsig_reading =\n\t\t(cx24116_readreg(state,\n\t\t\tCX24116_REG_SSTATUS) & CX24116_SIGNAL_MASK) |\n\t\t(cx24116_readreg(state, CX24116_REG_SIGNAL) << 6);\n\t*signal_strength = 0 - sig_reading;\n\n\tdprintk(\"%s: raw / cooked = 0x%04x / 0x%04x\\n\",\n\t\t__func__, sig_reading, *signal_strength);\n\n\treturn 0;\n}\n\n/* SNR (0..100)% = (sig & 0xf0) * 10 + (sig & 0x0f) * 10 / 16 */\nstatic int cx24116_read_snr_pct(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tu8 snr_reading;\n\tstatic const u32 snr_tab[] = { /* 10 x Table (rounded up) */\n\t\t0x00000, 0x0199A, 0x03333, 0x04ccD, 0x06667,\n\t\t0x08000, 0x0999A, 0x0b333, 0x0cccD, 0x0e667,\n\t\t0x10000, 0x1199A, 0x13333, 0x14ccD, 0x16667,\n\t\t0x18000 };\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\tsnr_reading = cx24116_readreg(state, CX24116_REG_QUALITY0);\n\n\tif (snr_reading >= 0xa0 /* 100% */)\n\t\t*snr = 0xffff;\n\telse\n\t\t*snr = snr_tab[(snr_reading & 0xf0) >> 4] +\n\t\t\t(snr_tab[(snr_reading & 0x0f)] >> 4);\n\n\tdprintk(\"%s: raw / cooked = 0x%02x / 0x%04x\\n\", __func__,\n\t\tsnr_reading, *snr);\n\n\treturn 0;\n}\n\n/* The reelbox patches show the value in the registers represents\n * ESNO, from 0->30db (values 0->300). We provide this value by\n * default.\n */\nstatic int cx24116_read_snr_esno(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\t*snr = cx24116_readreg(state, CX24116_REG_QUALITY8) << 8 |\n\t\tcx24116_readreg(state, CX24116_REG_QUALITY0);\n\n\tdprintk(\"%s: raw 0x%04x\\n\", __func__, *snr);\n\n\treturn 0;\n}\n\nstatic int cx24116_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tif (esno_snr == 1)\n\t\treturn cx24116_read_snr_esno(fe, snr);\n\telse\n\t\treturn cx24116_read_snr_pct(fe, snr);\n}\n\nstatic int cx24116_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\t*ucblocks = (cx24116_readreg(state, CX24116_REG_UCB8) << 8) |\n\t\tcx24116_readreg(state, CX24116_REG_UCB0);\n\n\treturn 0;\n}\n\n/* Overwrite the current tuning params, we are about to tune */\nstatic void cx24116_clone_params(struct dvb_frontend *fe)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tstate->dcur = state->dnxt;\n}\n\n/* Wait for LNB */\nstatic int cx24116_wait_for_lnb(struct dvb_frontend *fe)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tint i;\n\n\tdprintk(\"%s() qstatus = 0x%02x\\n\", __func__,\n\t\tcx24116_readreg(state, CX24116_REG_QSTATUS));\n\n\t/* Wait for up to 300 ms */\n\tfor (i = 0; i < 30 ; i++) {\n\t\tif (cx24116_readreg(state, CX24116_REG_QSTATUS) & 0x20)\n\t\t\treturn 0;\n\t\tmsleep(10);\n\t}\n\n\tdprintk(\"%s(): LNB not ready\\n\", __func__);\n\n\treturn -ETIMEDOUT; /* -EBUSY ? */\n}\n\nstatic int cx24116_set_voltage(struct dvb_frontend *fe,\n\tfe_sec_voltage_t voltage)\n{\n\tstruct cx24116_cmd cmd;\n\tint ret;\n\n\tdprintk(\"%s: %s\\n\", __func__,\n\t\tvoltage == SEC_VOLTAGE_13 ? \"SEC_VOLTAGE_13\" :\n\t\tvoltage == SEC_VOLTAGE_18 ? \"SEC_VOLTAGE_18\" : \"??\");\n\n\t/* Wait for LNB ready */\n\tret = cx24116_wait_for_lnb(fe);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* Wait for voltage/min repeat delay */\n\tmsleep(100);\n\n\tcmd.args[0x00] = CMD_LNBDCLEVEL;\n\tcmd.args[0x01] = (voltage == SEC_VOLTAGE_18 ? 0x01 : 0x00);\n\tcmd.len = 0x02;\n\n\t/* Min delay time before DiSEqC send */\n\tmsleep(15);\n\n\treturn cx24116_cmd_execute(fe, &cmd);\n}\n\nstatic int cx24116_set_tone(struct dvb_frontend *fe,\n\tfe_sec_tone_mode_t tone)\n{\n\tstruct cx24116_cmd cmd;\n\tint ret;\n\n\tdprintk(\"%s(%d)\\n\", __func__, tone);\n\tif ((tone != SEC_TONE_ON) && (tone != SEC_TONE_OFF)) {\n\t\tprintk(KERN_ERR \"%s: Invalid, tone=%d\\n\", __func__, tone);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Wait for LNB ready */\n\tret = cx24116_wait_for_lnb(fe);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* Min delay time after DiSEqC send */\n\tmsleep(15); /* XXX determine is FW does this, see send_diseqc/burst */\n\n\t/* Now we set the tone */\n\tcmd.args[0x00] = CMD_SET_TONE;\n\tcmd.args[0x01] = 0x00;\n\tcmd.args[0x02] = 0x00;\n\n\tswitch (tone) {\n\tcase SEC_TONE_ON:\n\t\tdprintk(\"%s: setting tone on\\n\", __func__);\n\t\tcmd.args[0x03] = 0x01;\n\t\tbreak;\n\tcase SEC_TONE_OFF:\n\t\tdprintk(\"%s: setting tone off\\n\", __func__);\n\t\tcmd.args[0x03] = 0x00;\n\t\tbreak;\n\t}\n\tcmd.len = 0x04;\n\n\t/* Min delay time before DiSEqC send */\n\tmsleep(15); /* XXX determine is FW does this, see send_diseqc/burst */\n\n\treturn cx24116_cmd_execute(fe, &cmd);\n}\n\n/* Initialise DiSEqC */\nstatic int cx24116_diseqc_init(struct dvb_frontend *fe)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tstruct cx24116_cmd cmd;\n\tint ret;\n\n\t/* Firmware CMD 20: LNB/DiSEqC config */\n\tcmd.args[0x00] = CMD_LNBCONFIG;\n\tcmd.args[0x01] = 0x00;\n\tcmd.args[0x02] = 0x10;\n\tcmd.args[0x03] = 0x00;\n\tcmd.args[0x04] = 0x8f;\n\tcmd.args[0x05] = 0x28;\n\tcmd.args[0x06] = (toneburst == CX24116_DISEQC_TONEOFF) ? 0x00 : 0x01;\n\tcmd.args[0x07] = 0x01;\n\tcmd.len = 0x08;\n\tret = cx24116_cmd_execute(fe, &cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* Prepare a DiSEqC command */\n\tstate->dsec_cmd.args[0x00] = CMD_LNBSEND;\n\n\t/* DiSEqC burst */\n\tstate->dsec_cmd.args[CX24116_DISEQC_BURST]  = CX24116_DISEQC_MINI_A;\n\n\t/* Unknown */\n\tstate->dsec_cmd.args[CX24116_DISEQC_ARG2_2] = 0x02;\n\tstate->dsec_cmd.args[CX24116_DISEQC_ARG3_0] = 0x00;\n\t/* Continuation flag? */\n\tstate->dsec_cmd.args[CX24116_DISEQC_ARG4_0] = 0x00;\n\n\t/* DiSEqC message length */\n\tstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN] = 0x00;\n\n\t/* Command length */\n\tstate->dsec_cmd.len = CX24116_DISEQC_MSGOFS;\n\n\treturn 0;\n}\n\n/* Send DiSEqC message with derived burst (hack) || previous burst */\nstatic int cx24116_send_diseqc_msg(struct dvb_frontend *fe,\n\tstruct dvb_diseqc_master_cmd *d)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tint i, ret;\n\n\t/* Validate length */\n\tif (d->msg_len > sizeof(d->msg))\n                return -EINVAL;\n\n\t/* Dump DiSEqC message */\n\tif (debug) {\n\t\tprintk(KERN_INFO \"cx24116: %s(\", __func__);\n\t\tfor (i = 0 ; i < d->msg_len ;) {\n\t\t\tprintk(KERN_INFO \"0x%02x\", d->msg[i]);\n\t\t\tif (++i < d->msg_len)\n\t\t\t\tprintk(KERN_INFO \", \");\n\t\t}\n\t\tprintk(\") toneburst=%d\\n\", toneburst);\n\t}\n\n\t/* DiSEqC message */\n\tfor (i = 0; i < d->msg_len; i++)\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_MSGOFS + i] = d->msg[i];\n\n\t/* DiSEqC message length */\n\tstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN] = d->msg_len;\n\n\t/* Command length */\n\tstate->dsec_cmd.len = CX24116_DISEQC_MSGOFS +\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN];\n\n\t/* DiSEqC toneburst */\n\tif (toneburst == CX24116_DISEQC_MESGCACHE)\n\t\t/* Message is cached */\n\t\treturn 0;\n\n\telse if (toneburst == CX24116_DISEQC_TONEOFF)\n\t\t/* Message is sent without burst */\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] = 0;\n\n\telse if (toneburst == CX24116_DISEQC_TONECACHE) {\n\t\t/*\n\t\t * Message is sent with derived else cached burst\n\t\t *\n\t\t * WRITE PORT GROUP COMMAND 38\n\t\t *\n\t\t * 0/A/A: E0 10 38 F0..F3\n\t\t * 1/B/B: E0 10 38 F4..F7\n\t\t * 2/C/A: E0 10 38 F8..FB\n\t\t * 3/D/B: E0 10 38 FC..FF\n\t\t *\n\t\t * databyte[3]= 8421:8421\n\t\t *              ABCD:WXYZ\n\t\t *              CLR :SET\n\t\t *\n\t\t *              WX= PORT SELECT 0..3    (X=TONEBURST)\n\t\t *              Y = VOLTAGE             (0=13V, 1=18V)\n\t\t *              Z = BAND                (0=LOW, 1=HIGH(22K))\n\t\t */\n\t\tif (d->msg_len >= 4 && d->msg[2] == 0x38)\n\t\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] =\n\t\t\t\t((d->msg[3] & 4) >> 2);\n\t\tif (debug)\n\t\t\tdprintk(\"%s burst=%d\\n\", __func__,\n\t\t\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST]);\n\t}\n\n\t/* Wait for LNB ready */\n\tret = cx24116_wait_for_lnb(fe);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* Wait for voltage/min repeat delay */\n\tmsleep(100);\n\n\t/* Command */\n\tret = cx24116_cmd_execute(fe, &state->dsec_cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\t/*\n\t * Wait for send\n\t *\n\t * Eutelsat spec:\n\t * >15ms delay          + (XXX determine if FW does this, see set_tone)\n\t *  13.5ms per byte     +\n\t * >15ms delay          +\n\t *  12.5ms burst        +\n\t * >15ms delay            (XXX determine if FW does this, see set_tone)\n\t */\n\tmsleep((state->dsec_cmd.args[CX24116_DISEQC_MSGLEN] << 4) +\n\t\t((toneburst == CX24116_DISEQC_TONEOFF) ? 30 : 60));\n\n\treturn 0;\n}\n\n/* Send DiSEqC burst */\nstatic int cx24116_diseqc_send_burst(struct dvb_frontend *fe,\n\tfe_sec_mini_cmd_t burst)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tint ret;\n\n\tdprintk(\"%s(%d) toneburst=%d\\n\", __func__, burst, toneburst);\n\n\t/* DiSEqC burst */\n\tif (burst == SEC_MINI_A)\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] =\n\t\t\tCX24116_DISEQC_MINI_A;\n\telse if (burst == SEC_MINI_B)\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] =\n\t\t\tCX24116_DISEQC_MINI_B;\n\telse\n\t\treturn -EINVAL;\n\n\t/* DiSEqC toneburst */\n\tif (toneburst != CX24116_DISEQC_MESGCACHE)\n\t\t/* Burst is cached */\n\t\treturn 0;\n\n\t/* Burst is to be sent with cached message */\n\n\t/* Wait for LNB ready */\n\tret = cx24116_wait_for_lnb(fe);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* Wait for voltage/min repeat delay */\n\tmsleep(100);\n\n\t/* Command */\n\tret = cx24116_cmd_execute(fe, &state->dsec_cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/*\n\t * Wait for send\n\t *\n\t * Eutelsat spec:\n\t * >15ms delay          + (XXX determine if FW does this, see set_tone)\n\t *  13.5ms per byte     +\n\t * >15ms delay          +\n\t *  12.5ms burst        +\n\t * >15ms delay            (XXX determine if FW does this, see set_tone)\n\t */\n\tmsleep((state->dsec_cmd.args[CX24116_DISEQC_MSGLEN] << 4) + 60);\n\n\treturn 0;\n}\n\nstatic void cx24116_release(struct dvb_frontend *fe)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tdprintk(\"%s\\n\", __func__);\n\tkfree(state);\n}\n\nstatic struct dvb_frontend_ops cx24116_ops;\n\nstruct dvb_frontend *cx24116_attach(const struct cx24116_config *config,\n\tstruct i2c_adapter *i2c)\n{\n\tstruct cx24116_state *state = NULL;\n\tint ret;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\t/* allocate memory for the internal state */\n\tstate = kzalloc(sizeof(struct cx24116_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\tgoto error1;\n\n\tstate->config = config;\n\tstate->i2c = i2c;\n\n\t/* check if the demod is present */\n\tret = (cx24116_readreg(state, 0xFF) << 8) |\n\t\tcx24116_readreg(state, 0xFE);\n\tif (ret != 0x0501) {\n\t\tprintk(KERN_INFO \"Invalid probe, probably not a CX24116 device\\n\");\n\t\tgoto error2;\n\t}\n\n\t/* create dvb_frontend */\n\tmemcpy(&state->frontend.ops, &cx24116_ops,\n\t\tsizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\treturn &state->frontend;\n\nerror2: kfree(state);\nerror1: return NULL;\n}\nEXPORT_SYMBOL(cx24116_attach);\n\n/*\n * Initialise or wake up device\n *\n * Power config will reset and load initial firmware if required\n */\nstatic int cx24116_initfe(struct dvb_frontend *fe)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tstruct cx24116_cmd cmd;\n\tint ret;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\t/* Power on */\n\tcx24116_writereg(state, 0xe0, 0);\n\tcx24116_writereg(state, 0xe1, 0);\n\tcx24116_writereg(state, 0xea, 0);\n\n\t/* Firmware CMD 36: Power config */\n\tcmd.args[0x00] = CMD_TUNERSLEEP;\n\tcmd.args[0x01] = 0;\n\tcmd.len = 0x02;\n\tret = cx24116_cmd_execute(fe, &cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tret = cx24116_diseqc_init(fe);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* HVR-4000 needs this */\n\treturn cx24116_set_voltage(fe, SEC_VOLTAGE_13);\n}\n\n/*\n * Put device to sleep\n */\nstatic int cx24116_sleep(struct dvb_frontend *fe)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tstruct cx24116_cmd cmd;\n\tint ret;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\t/* Firmware CMD 36: Power config */\n\tcmd.args[0x00] = CMD_TUNERSLEEP;\n\tcmd.args[0x01] = 1;\n\tcmd.len = 0x02;\n\tret = cx24116_cmd_execute(fe, &cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* Power off (Shutdown clocks) */\n\tcx24116_writereg(state, 0xea, 0xff);\n\tcx24116_writereg(state, 0xe1, 1);\n\tcx24116_writereg(state, 0xe0, 1);\n\n\treturn 0;\n}\n\n/* dvb-core told us to tune, the tv property cache will be complete,\n * it's safe for is to pull values and use them for tuning purposes.\n */\nstatic int cx24116_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct cx24116_cmd cmd;\n\tfe_status_t tunerstat;\n\tint i, status, ret, retune = 1;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBS:\n\t\tdprintk(\"%s: DVB-S delivery system selected\\n\", __func__);\n\n\t\t/* Only QPSK is supported for DVB-S */\n\t\tif (c->modulation != QPSK) {\n\t\t\tdprintk(\"%s: unsupported modulation selected (%d)\\n\",\n\t\t\t\t__func__, c->modulation);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\t/* Pilot doesn't exist in DVB-S, turn bit off */\n\t\tstate->dnxt.pilot_val = CX24116_PILOT_OFF;\n\n\t\t/* DVB-S only supports 0.35 */\n\t\tif (c->rolloff != ROLLOFF_35) {\n\t\t\tdprintk(\"%s: unsupported rolloff selected (%d)\\n\",\n\t\t\t\t__func__, c->rolloff);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tstate->dnxt.rolloff_val = CX24116_ROLLOFF_035;\n\t\tbreak;\n\n\tcase SYS_DVBS2:\n\t\tdprintk(\"%s: DVB-S2 delivery system selected\\n\", __func__);\n\n\t\t/*\n\t\t * NBC 8PSK/QPSK with DVB-S is supported for DVB-S2,\n\t\t * but not hardware auto detection\n\t\t */\n\t\tif (c->modulation != PSK_8 && c->modulation != QPSK) {\n\t\t\tdprintk(\"%s: unsupported modulation selected (%d)\\n\",\n\t\t\t\t__func__, c->modulation);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tswitch (c->pilot) {\n\t\tcase PILOT_AUTO:\t/* Not supported but emulated */\n\t\t\tstate->dnxt.pilot_val = (c->modulation == QPSK)\n\t\t\t\t? CX24116_PILOT_OFF : CX24116_PILOT_ON;\n\t\t\tretune++;\n\t\t\tbreak;\n\t\tcase PILOT_OFF:\n\t\t\tstate->dnxt.pilot_val = CX24116_PILOT_OFF;\n\t\t\tbreak;\n\t\tcase PILOT_ON:\n\t\t\tstate->dnxt.pilot_val = CX24116_PILOT_ON;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(\"%s: unsupported pilot mode selected (%d)\\n\",\n\t\t\t\t__func__, c->pilot);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tswitch (c->rolloff) {\n\t\tcase ROLLOFF_20:\n\t\t\tstate->dnxt.rolloff_val = CX24116_ROLLOFF_020;\n\t\t\tbreak;\n\t\tcase ROLLOFF_25:\n\t\t\tstate->dnxt.rolloff_val = CX24116_ROLLOFF_025;\n\t\t\tbreak;\n\t\tcase ROLLOFF_35:\n\t\t\tstate->dnxt.rolloff_val = CX24116_ROLLOFF_035;\n\t\t\tbreak;\n\t\tcase ROLLOFF_AUTO:\t/* Rolloff must be explicit */\n\t\tdefault:\n\t\t\tdprintk(\"%s: unsupported rolloff selected (%d)\\n\",\n\t\t\t\t__func__, c->rolloff);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdprintk(\"%s: unsupported delivery system selected (%d)\\n\",\n\t\t\t__func__, c->delivery_system);\n\t\treturn -EOPNOTSUPP;\n\t}\n\tstate->dnxt.delsys = c->delivery_system;\n\tstate->dnxt.modulation = c->modulation;\n\tstate->dnxt.frequency = c->frequency;\n\tstate->dnxt.pilot = c->pilot;\n\tstate->dnxt.rolloff = c->rolloff;\n\n\tret = cx24116_set_inversion(state, c->inversion);\n\tif (ret !=  0)\n\t\treturn ret;\n\n\t/* FEC_NONE/AUTO for DVB-S2 is not supported and detected here */\n\tret = cx24116_set_fec(state, c->delivery_system, c->modulation, c->fec_inner);\n\tif (ret !=  0)\n\t\treturn ret;\n\n\tret = cx24116_set_symbolrate(state, c->symbol_rate);\n\tif (ret !=  0)\n\t\treturn ret;\n\n\t/* discard the 'current' tuning parameters and prepare to tune */\n\tcx24116_clone_params(fe);\n\n\tdprintk(\"%s:   delsys      = %d\\n\", __func__, state->dcur.delsys);\n\tdprintk(\"%s:   modulation  = %d\\n\", __func__, state->dcur.modulation);\n\tdprintk(\"%s:   frequency   = %d\\n\", __func__, state->dcur.frequency);\n\tdprintk(\"%s:   pilot       = %d (val = 0x%02x)\\n\", __func__,\n\t\tstate->dcur.pilot, state->dcur.pilot_val);\n\tdprintk(\"%s:   retune      = %d\\n\", __func__, retune);\n\tdprintk(\"%s:   rolloff     = %d (val = 0x%02x)\\n\", __func__,\n\t\tstate->dcur.rolloff, state->dcur.rolloff_val);\n\tdprintk(\"%s:   symbol_rate = %d\\n\", __func__, state->dcur.symbol_rate);\n\tdprintk(\"%s:   FEC         = %d (mask/val = 0x%02x/0x%02x)\\n\", __func__,\n\t\tstate->dcur.fec, state->dcur.fec_mask, state->dcur.fec_val);\n\tdprintk(\"%s:   Inversion   = %d (val = 0x%02x)\\n\", __func__,\n\t\tstate->dcur.inversion, state->dcur.inversion_val);\n\n\t/* This is also done in advise/acquire on HVR4000 but not on LITE */\n\tif (state->config->set_ts_params)\n\t\tstate->config->set_ts_params(fe, 0);\n\n\t/* Set/Reset B/W */\n\tcmd.args[0x00] = CMD_BANDWIDTH;\n\tcmd.args[0x01] = 0x01;\n\tcmd.len = 0x02;\n\tret = cx24116_cmd_execute(fe, &cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* Prepare a tune request */\n\tcmd.args[0x00] = CMD_TUNEREQUEST;\n\n\t/* Frequency */\n\tcmd.args[0x01] = (state->dcur.frequency & 0xff0000) >> 16;\n\tcmd.args[0x02] = (state->dcur.frequency & 0x00ff00) >> 8;\n\tcmd.args[0x03] = (state->dcur.frequency & 0x0000ff);\n\n\t/* Symbol Rate */\n\tcmd.args[0x04] = ((state->dcur.symbol_rate / 1000) & 0xff00) >> 8;\n\tcmd.args[0x05] = ((state->dcur.symbol_rate / 1000) & 0x00ff);\n\n\t/* Automatic Inversion */\n\tcmd.args[0x06] = state->dcur.inversion_val;\n\n\t/* Modulation / FEC / Pilot */\n\tcmd.args[0x07] = state->dcur.fec_val | state->dcur.pilot_val;\n\n\tcmd.args[0x08] = CX24116_SEARCH_RANGE_KHZ >> 8;\n\tcmd.args[0x09] = CX24116_SEARCH_RANGE_KHZ & 0xff;\n\tcmd.args[0x0a] = 0x00;\n\tcmd.args[0x0b] = 0x00;\n\tcmd.args[0x0c] = state->dcur.rolloff_val;\n\tcmd.args[0x0d] = state->dcur.fec_mask;\n\n\tif (state->dcur.symbol_rate > 30000000) {\n\t\tcmd.args[0x0e] = 0x04;\n\t\tcmd.args[0x0f] = 0x00;\n\t\tcmd.args[0x10] = 0x01;\n\t\tcmd.args[0x11] = 0x77;\n\t\tcmd.args[0x12] = 0x36;\n\t\tcx24116_writereg(state, CX24116_REG_CLKDIV, 0x44);\n\t\tcx24116_writereg(state, CX24116_REG_RATEDIV, 0x01);\n\t} else {\n\t\tcmd.args[0x0e] = 0x06;\n\t\tcmd.args[0x0f] = 0x00;\n\t\tcmd.args[0x10] = 0x00;\n\t\tcmd.args[0x11] = 0xFA;\n\t\tcmd.args[0x12] = 0x24;\n\t\tcx24116_writereg(state, CX24116_REG_CLKDIV, 0x46);\n\t\tcx24116_writereg(state, CX24116_REG_RATEDIV, 0x00);\n\t}\n\n\tcmd.len = 0x13;\n\n\t/* We need to support pilot and non-pilot tuning in the\n\t * driver automatically. This is a workaround for because\n\t * the demod does not support autodetect.\n\t */\n\tdo {\n\t\t/* Reset status register */\n\t\tstatus = cx24116_readreg(state, CX24116_REG_SSTATUS)\n\t\t\t& CX24116_SIGNAL_MASK;\n\t\tcx24116_writereg(state, CX24116_REG_SSTATUS, status);\n\n\t\t/* Tune */\n\t\tret = cx24116_cmd_execute(fe, &cmd);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Wait for up to 500 ms before retrying\n\t\t *\n\t\t * If we are able to tune then generally it occurs within 100ms.\n\t\t * If it takes longer, try a different toneburst setting.\n\t\t */\n\t\tfor (i = 0; i < 50 ; i++) {\n\t\t\tcx24116_read_status(fe, &tunerstat);\n\t\t\tstatus = tunerstat & (FE_HAS_SIGNAL | FE_HAS_SYNC);\n\t\t\tif (status == (FE_HAS_SIGNAL | FE_HAS_SYNC)) {\n\t\t\t\tdprintk(\"%s: Tuned\\n\", __func__);\n\t\t\t\tgoto tuned;\n\t\t\t}\n\t\t\tmsleep(10);\n\t\t}\n\n\t\tdprintk(\"%s: Not tuned\\n\", __func__);\n\n\t\t/* Toggle pilot bit when in auto-pilot */\n\t\tif (state->dcur.pilot == PILOT_AUTO)\n\t\t\tcmd.args[0x07] ^= CX24116_PILOT_ON;\n\t} while (--retune);\n\ntuned:  /* Set/Reset B/W */\n\tcmd.args[0x00] = CMD_BANDWIDTH;\n\tcmd.args[0x01] = 0x00;\n\tcmd.len = 0x02;\n\treturn cx24116_cmd_execute(fe, &cmd);\n}\n\nstatic int cx24116_tune(struct dvb_frontend *fe, bool re_tune,\n\tunsigned int mode_flags, unsigned int *delay, fe_status_t *status)\n{\n\t/*\n\t * It is safe to discard \"params\" here, as the DVB core will sync\n\t * fe->dtv_property_cache with fepriv->parameters_in, where the\n\t * DVBv3 params are stored. The only practical usage for it indicate\n\t * that re-tuning is needed, e. g. (fepriv->state & FESTATE_RETUNE) is\n\t * true.\n\t */\n\n\t*delay = HZ / 5;\n\tif (re_tune) {\n\t\tint ret = cx24116_set_frontend(fe);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn cx24116_read_status(fe, status);\n}\n\nstatic int cx24116_get_algo(struct dvb_frontend *fe)\n{\n\treturn DVBFE_ALGO_HW;\n}\n\nstatic struct dvb_frontend_ops cx24116_ops = {\n\t.delsys = { SYS_DVBS, SYS_DVBS2 },\n\t.info = {\n\t\t.name = \"Conexant CX24116/CX24118\",\n\t\t.frequency_min = 950000,\n\t\t.frequency_max = 2150000,\n\t\t.frequency_stepsize = 1011, /* kHz for QPSK frontends */\n\t\t.frequency_tolerance = 5000,\n\t\t.symbol_rate_min = 1000000,\n\t\t.symbol_rate_max = 45000000,\n\t\t.caps = FE_CAN_INVERSION_AUTO |\n\t\t\tFE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_4_5 | FE_CAN_FEC_5_6 | FE_CAN_FEC_6_7 |\n\t\t\tFE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_2G_MODULATION |\n\t\t\tFE_CAN_QPSK | FE_CAN_RECOVER\n\t},\n\n\t.release = cx24116_release,\n\n\t.init = cx24116_initfe,\n\t.sleep = cx24116_sleep,\n\t.read_status = cx24116_read_status,\n\t.read_ber = cx24116_read_ber,\n\t.read_signal_strength = cx24116_read_signal_strength,\n\t.read_snr = cx24116_read_snr,\n\t.read_ucblocks = cx24116_read_ucblocks,\n\t.set_tone = cx24116_set_tone,\n\t.set_voltage = cx24116_set_voltage,\n\t.diseqc_send_master_cmd = cx24116_send_diseqc_msg,\n\t.diseqc_send_burst = cx24116_diseqc_send_burst,\n\t.get_frontend_algo = cx24116_get_algo,\n\t.tune = cx24116_tune,\n\n\t.set_frontend = cx24116_set_frontend,\n};\n\nMODULE_DESCRIPTION(\"DVB Frontend module for Conexant cx24116/cx24118 hardware\");\nMODULE_AUTHOR(\"Steven Toth\");\nMODULE_LICENSE(\"GPL\");\n\n"], "filenames": ["drivers/media/dvb-frontends/cx24116.c"], "buggy_code_start_loc": [965], "buggy_code_end_loc": [980], "fixing_code_start_loc": [966], "fixing_code_end_loc": [979], "type": "CWE-125", "message": "In the Linux kernel before 4.1.4, a buffer overflow occurs when checking userspace params in drivers/media/dvb-frontends/cx24116.c. The maximum size for a DiSEqC command is 6, according to the userspace API. However, the code allows larger values such as 23.", "other": {"cve": {"id": "CVE-2015-9289", "sourceIdentifier": "cve@mitre.org", "published": "2019-07-27T22:15:11.417", "lastModified": "2019-12-11T19:29:55.587", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the Linux kernel before 4.1.4, a buffer overflow occurs when checking userspace params in drivers/media/dvb-frontends/cx24116.c. The maximum size for a DiSEqC command is 6, according to the userspace API. However, the code allows larger values such as 23."}, {"lang": "es", "value": "En el kernel de Linux anterior a versi\u00f3n 4.1.4, ocurre un desbordamiento de b\u00fafer cuando se comprueban los par\u00e1metros username en el archivo drivers/media/dvb-frontends/cx24116.c. El tama\u00f1o m\u00e1ximo para un comando DiSEqC es 6, seg\u00fan la API de username. Sin embargo, el c\u00f3digo permite valores m\u00e1s grandes como 23."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.1.4", "matchCriteriaId": "5E435159-977A-43FC-93A0-A155211E7143"}]}]}], "references": [{"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=1fa2337a315a2448c5434f41e00d56b01a22283c", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/1fa2337a315a2448c5434f41e00d56b01a22283c", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.1.4", "source": "cve@mitre.org", "tags": ["Release Notes"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/1fa2337a315a2448c5434f41e00d56b01a22283c"}}