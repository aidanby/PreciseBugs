{"buggy_code": ["/* radare - LGPL - Copyright 2006-2016 - pancake */\n\n#include \"r_config.h\"\n#include \"r_util.h\" // r_str_hash, r_str_chop, ...\n#ifdef _MSC_VER\n#define strcasecmp stricmp\n#endif\nR_API RConfigNode* r_config_node_new(const char *name, const char *value) {\n\tRConfigNode *node;\n\tif (STRNULL (name)) {\n\t\treturn NULL;\n\t}\n\tnode = R_NEW0 (RConfigNode);\n\tif (!node) {\n\t\treturn NULL;\n\t}\n\tnode->name = strdup (name);\n\tnode->value = strdup (value? value: \"\");\n\tnode->flags = CN_RW | CN_STR;\n\tnode->i_value = r_num_get (NULL, value);\n\tnode->options = r_list_new ();\n\treturn node;\n}\n\nR_API RConfigNode* r_config_node_clone(RConfigNode *n) {\n\tRConfigNode *cn = R_NEW0 (RConfigNode);\n\tif (!cn) {\n\t\treturn NULL;\n\t}\n\tcn->name = strdup (n->name);\n\tcn->desc = n->desc? strdup (n->desc): NULL;\n\tcn->value = strdup (n->value? n->value: \"\");\n\tcn->i_value = n->i_value;\n\tcn->flags = n->flags;\n\tcn->setter = n->setter;\n\tcn->options = r_list_clone (n->options);\n\treturn cn;\n}\n\nR_API void r_config_node_free(void *n) {\n\tRConfigNode *node = (RConfigNode *)n;\n\tif (!node) {\n\t\treturn;\n\t}\n\tfree (node->name);\n\tfree (node->desc);\n\tfree (node->value);\n\tr_list_free (node->options);\n\tfree (node);\n}\n\nstatic void config_print_value_json(RConfig *cfg, RConfigNode *node) {\n\tconst char *val = node->value;\n\tif (!val) {\n\t\tval = \"0\";\n\t}\n\tchar *sval = r_str_escape (val);\n\tif (node->flags & CN_BOOL || node->flags & CN_INT || node->flags & CN_OFFT) {\n\t\tif (!strncmp (val, \"0x\", 2)) {\n\t\t\tut64 n = r_num_get (NULL, val);\n\t\t\tcfg->cb_printf (\"%\"PFMT64d, n);\n\t\t} else if (r_str_isnumber (val) || !strcmp (val, \"true\") || !strcmp (val, \"false\")) {\n\t\t\tcfg->cb_printf (\"%s\", val);\n\t\t} else {\n\t\t\tcfg->cb_printf (\"\\\"%s\\\"\", sval);\n\t\t}\n\t} else {\n\t\tcfg->cb_printf (\"\\\"%s\\\"\", sval);\n\t}\n\tfree (sval);\n}\n\nstatic void config_print_node(RConfig *cfg, RConfigNode *node, const char *pfx, const char *sfx, bool verbose, bool json) {\n\tchar *option;\n\tbool isFirst;\n\tRListIter *iter;\n\tchar *es = NULL;\n\n\tif (json) {\n\t\tif (verbose) {\n\t\t\tcfg->cb_printf (\"{\");\n\t\t\tcfg->cb_printf (\"\\\"name\\\":\\\"%s\\\",\", node->name);\n\t\t\tcfg->cb_printf (\"\\\"value\\\":\");\n\t\t\tconfig_print_value_json (cfg, node);\n\t\t\tcfg->cb_printf (\",\\\"type\\\":\\\"%s\\\",\", r_config_node_type (node));\n\t\t\tes = r_str_escape (node->desc);\n\t\t\tif (es) {\n\t\t\t\tcfg->cb_printf (\"\\\"desc\\\":\\\"%s\\\",\", es);\n\t\t\t\tfree (es);\n\t\t\t}\n\t\t\tcfg->cb_printf (\"\\\"ro\\\":%s\", node->flags & CN_RO ? \"true\" : \"false\");\n\t\t\tif (!r_list_empty (node->options)) {\n\t\t\t\tisFirst = true;\n\t\t\t\tcfg->cb_printf (\",\\\"options\\\":[\");\n\t\t\t\tr_list_foreach (node->options, iter, option) {\n\t\t\t\t\tes = r_str_escape (option);\n\t\t\t\t\tif (es) {\n\t\t\t\t\t\tif (isFirst) {\n\t\t\t\t\t\t\tisFirst = false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcfg->cb_printf (\",\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcfg->cb_printf (\"\\\"%s\\\"\", es);\n\t\t\t\t\t\tfree (es);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcfg->cb_printf (\"]\");\n\t\t\t}\n\t\t\tcfg->cb_printf (\"}\");\n\t\t} else {\n\t\t\tcfg->cb_printf (\"\\\"%s\\\":\", node->name);\n\t\t\tconfig_print_value_json (cfg, node);\n\t\t}\n\t} else {\n\t\tif (verbose) {\n\t\t\tcfg->cb_printf (\"%s%s = %s%s %s; %s\", pfx,\n\t\t\t\tnode->name, node->value, sfx, \n\t\t\t\tnode->flags & CN_RO ? \"(ro)\" : \"\", \n\t\t\t\tnode->desc);\n\t\t\tif (!r_list_empty (node->options)) {\n\t\t\t\tisFirst = true;\n\t\t\t\tcfg->cb_printf(\" [\");\n\t\t\t\tr_list_foreach (node->options, iter, option) {\n\t\t\t\t\tif (isFirst) {\n\t\t\t\t\t\tisFirst = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcfg->cb_printf(\", \");\n\t\t\t\t\t}\n\t\t\t\t\tcfg->cb_printf(\"%s\", option);\n\t\t\t\t}\n\t\t\t\tcfg->cb_printf(\"]\");\n\t\t\t}\n\t\t\tcfg->cb_printf (\"\\n\");\n\t\t} else {\n\t\t\tcfg->cb_printf (\"%s%s = %s%s\\n\", pfx,\n\t\t\t\tnode->name, node->value, sfx);\n\t\t}\n\t}\n}\n\nR_API void r_config_list(RConfig *cfg, const char *str, int rad) {\n\tRConfigNode *node;\n\tRListIter *iter;\n\tconst char *sfx = \"\";\n\tconst char *pfx = \"\";\n\tint len = 0;\n\tbool verbose = false;\n\tbool json = false;\n\tbool isFirst = false;\n\n\tif (!STRNULL (str)) {\n\t\tstr = r_str_chop_ro (str);\n\t\tlen = strlen (str);\n\t\tif (len > 0 && str[0] == 'j') {\n\t\t\tstr++;\n\t\t\tlen--;\n\t\t\tjson = true;\n\t\t\trad = 'J';\n\t\t}\n\t\tif (len > 0 && str[0] == ' ') {\n\t\t\tstr++;\n\t\t\tlen--;\n\t\t}\n\t\tif (strlen (str) == 0) {\n\t\t\tstr = NULL;\n\t\t\tlen = 0;\n\t\t}\n\t}\n\n\tswitch (rad) {\n\tcase 1:\n\t\tpfx = \"\\\"e \";\n\t\tsfx = \"\\\"\";\n\t/* fallthrou */\n\tcase 0:\n\t\tr_list_foreach (cfg->nodes, iter, node) {\n\t\t\tif (!str || (str && (!strncmp (str, node->name, len)))) {\n\t\t\t\tconfig_print_node (cfg, node, pfx, sfx, verbose, json);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tr_list_foreach (cfg->nodes, iter, node) {\n\t\t\tif (!str || (str && (!strncmp (str, node->name, len)))) {\n\t\t\t\tif (!str || !strncmp (str, node->name, len)) {\n\t\t\t\t\tcfg->cb_printf (\"%20s: %s\\n\", node->name,\n\t\t\t\t\t\tnode->desc? node->desc: \"\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'v':\n\t\tverbose = true;\n\t\tr_list_foreach (cfg->nodes, iter, node) {\n\t\t\tif (!str || (str && (!strncmp (str, node->name, len)))) {\n\t\t\t\tconfig_print_node (cfg, node, pfx, sfx, verbose, json);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'q':\n\t\tr_list_foreach (cfg->nodes, iter, node) {\n\t\t\tcfg->cb_printf (\"%s\\n\", node->name);\n\t\t}\n\t\tbreak;\n\tcase 'J':\n\t\tverbose = true;\n\t/* fallthrou */\n\tcase 'j':\n\t\tjson = true;\n\t\tisFirst = true;\n\t\tif (verbose) {\n\t\t\tcfg->cb_printf (\"[\");\n\t\t} else {\n\t\t\tcfg->cb_printf (\"{\");\n\t\t}\n\t\tr_list_foreach (cfg->nodes, iter, node) {\n\t\t\tif (!str || (str && (!strncmp (str, node->name, len)))) {\n\t\t\t\tif (!str || !strncmp (str, node->name, len)) {\n\t\t\t\t\tif (isFirst) {\n\t\t\t\t\t\tisFirst = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcfg->cb_printf (\",\");\n\t\t\t\t\t}\n\t\t\t\t\tconfig_print_node (cfg, node, pfx, sfx, verbose, json);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (verbose) {\n\t\t\tcfg->cb_printf (\"]\\n\");\n\t\t} else {\n\t\t\tcfg->cb_printf (\"}\\n\");\n\t\t}\n\t\tbreak;\n\t}\n}\n\nR_API RConfigNode* r_config_node_get(RConfig *cfg, const char *name) {\n\tif (STRNULL (name)) {\n\t\treturn NULL;\n\t}\n\treturn ht_find (cfg->ht, name, NULL);\n}\n\nR_API int r_config_set_getter(RConfig *cfg, const char *key, RConfigCallback cb) {\n\tRConfigNode *node = r_config_node_get (cfg, key);\n\tif (node) {\n\t\tnode->getter = cb;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nR_API int r_config_set_setter(RConfig *cfg, const char *key, RConfigCallback cb) {\n\tRConfigNode *node = r_config_node_get (cfg, key);\n\tif (node) {\n\t\tnode->setter = cb;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic bool is_true(const char *s) {\n\treturn !strcasecmp (\"true\", s) || !strcasecmp (\"1\", s);\n}\n\nstatic bool is_bool(const char *s) {\n\treturn !strcasecmp (\"true\", s) || !strcasecmp (\"false\", s);\n}\n\nR_API const char* r_config_get(RConfig *cfg, const char *name) {\n\tRConfigNode *node = r_config_node_get (cfg, name);\n\tif (node) {\n\t\tif (node->getter) {\n\t\t\tnode->getter (cfg->user, node);\n\t\t}\n\t\tcfg->last_notfound = 0;\n\t\tif (node->flags & CN_BOOL) {\n\t\t\treturn r_str_bool (is_true (node->value));\n\t\t}\n\t\treturn node->value;\n\t} else {\n\t\teprintf (\"r_config_get: variable '%s' not found\\n\", name);\n\t}\n\tcfg->last_notfound = 1;\n\treturn NULL;\n}\n\nR_API int r_config_toggle(RConfig *cfg, const char *name) {\n\tRConfigNode *node = r_config_node_get (cfg, name);\n\tif (node && node->flags & CN_BOOL) {\n\t\t(void)r_config_set_i (cfg, name, !node->i_value);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API ut64 r_config_get_i(RConfig *cfg, const char *name) {\n\tRConfigNode *node = r_config_node_get (cfg, name);\n\tif (node) {\n\t\tif (node->getter) {\n\t\t\tnode->getter (cfg->user, node);\n\t\t}\n\t\tif (node->i_value || !strcmp (node->value, \"false\")) {\n\t\t\treturn node->i_value;\n\t\t}\n\t\treturn (ut64) r_num_math (cfg->num, node->value);\n\t}\n\treturn (ut64) 0LL;\n}\n\nR_API const char* r_config_node_type(RConfigNode *node) {\n\tif (node) {\n\t\tint f = node->flags;\n\t\tif (f & CN_BOOL) {\n\t\t\treturn \"bool\";\n\t\t}\n\t\tif (f & CN_STR) {\n\t\t\treturn \"str\";\n\t\t}\n\t\tif (f & CN_OFFT || f & CN_INT) {\n\t\t\tif (!strncmp (node->value, \"0x\", 2)) {\n\t\t\t\treturn \"addr\";\n\t\t\t}\n\t\t\treturn \"int\";\n\t\t}\n\t}\n\treturn \"\";\n}\n\nR_API RConfigNode* r_config_set_cb(RConfig *cfg, const char *name, const char *value, RConfigCallback cb) {\n\tRConfigNode *node = r_config_set (cfg, name, value);\n\tif (node && (node->setter = cb)) {\n\t\tif (!cb (cfg->user, node)) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn node;\n}\n\nR_API RConfigNode* r_config_set_i_cb(RConfig *cfg, const char *name, int ivalue, RConfigCallback cb) {\n\tRConfigNode *node = r_config_set_i (cfg, name, ivalue);\n\tif (node && (node->setter = cb)) {\n\t\tif (!node->setter (cfg->user, node)) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn node;\n}\n\n/* TODO: reduce number of strdups here */\nR_API RConfigNode* r_config_set(RConfig *cfg, const char *name, const char *value) {\n\tRConfigNode *node = NULL;\n\tchar *ov = NULL;\n\tut64 oi;\n\tif (!cfg || STRNULL (name)) {\n\t\treturn NULL;\n\t}\n\tnode = r_config_node_get (cfg, name);\n\tif (node) {\n\t\tif (node->flags & CN_RO) {\n\t\t\teprintf (\"(error: '%s' config key is read only)\\n\", name);\n\t\t\treturn node;\n\t\t}\n\t\toi = node->i_value;\n\t\tif (node->value) {\n\t\t\tov = strdup (node->value);\n\t\t\tif (!ov) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t} else {\n\t\t\tfree (node->value);\n\t\t\tnode->value = strdup (\"\");\n\t\t}\n\t\tif (node->flags & CN_BOOL) {\n\t\t\tbool b = is_true (value);\n\t\t\tnode->i_value = (ut64) b? 1: 0;\n\t\t\tchar *value = strdup (r_str_bool (b));\n\t\t\tif (value) {\n\t\t\t\tfree (node->value);\n\t\t\t\tnode->value = value;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!value) {\n\t\t\t\tfree (node->value);\n\t\t\t\tnode->value = strdup (\"\");\n\t\t\t\tnode->i_value = 0;\n\t\t\t} else {\n\t\t\t\tif (node->value == value) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tfree (node->value);\n\t\t\t\tnode->value = strdup (value);\n\t\t\t\tif (IS_DIGIT (*value)) {\n\t\t\t\t\tif (strchr (value, '/')) {\n\t\t\t\t\t\tnode->i_value = r_num_get (cfg->num, value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode->i_value = r_num_math (cfg->num, value);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnode->i_value = 0;\n\t\t\t\t}\n\t\t\t\tnode->flags |= CN_INT;\n\t\t\t}\n\t\t}\n\t} else { // Create a new RConfigNode\n\t\toi = UT64_MAX;\n\t\tif (!cfg->lock) {\n\t\t\tnode = r_config_node_new (name, value);\n\t\t\tif (node) {\n\t\t\t\tif (value && is_bool (value)) {\n\t\t\t\t\tnode->flags |= CN_BOOL;\n\t\t\t\t\tnode->i_value = is_true (value)? 1: 0;\n\t\t\t\t}\n\t\t\t\tif (cfg->ht) {\n\t\t\t\t\tht_insert (cfg->ht, node->name, node);\n\t\t\t\t\tr_list_append (cfg->nodes, node);\n\t\t\t\t\tcfg->n_nodes++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\teprintf (\"r_config_set: unable to create a new RConfigNode\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"r_config_set: variable '%s' not found\\n\", name);\n\t\t}\n\t}\n\n\tif (node && node->setter) {\n\t\tint ret = node->setter (cfg->user, node);\n\t\tif (ret == false) {\n\t\t\tif (oi != UT64_MAX) {\n\t\t\t\tnode->i_value = oi;\n\t\t\t}\n\t\t\tfree (node->value);\n\t\t\tnode->value = strdup (ov? ov: \"\");\n\t\t}\n\t}\nbeach:\n\tfree (ov);\n\treturn node;\n}\n\n/* r_config_desc takes a RConfig and a name,\n * r_config_node_desc takes a RConfigNode\n * Both set and return node->desc */\nR_API const char* r_config_desc(RConfig *cfg, const char *name, const char *desc) {\n\tRConfigNode *node = r_config_node_get (cfg, name);\n\treturn r_config_node_desc (node, desc);\n}\n\nR_API const char* r_config_node_desc(RConfigNode *node, const char *desc) {\n\tif (node) {\n\t\tif (desc) {\n\t\t\tfree (node->desc);\n\t\t\tnode->desc = strdup (desc);\n\t\t}\n\t\treturn node->desc;\n\t}\n\treturn NULL;\n}\n\nR_API int r_config_rm(RConfig *cfg, const char *name) {\n\tRConfigNode *node = r_config_node_get (cfg, name);\n\tif (node) {\n\t\tht_delete (cfg->ht, node->name);\n\t\tr_list_delete_data (cfg->nodes, node);\n\t\tcfg->n_nodes--;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API RConfigNode* r_config_set_i(RConfig *cfg, const char *name, const ut64 i) {\n\tchar buf[128], *ov = NULL;\n\tif (!cfg || !name) {\n\t\treturn NULL;\n\t}\n\tRConfigNode *node = r_config_node_get (cfg, name);\n\tif (node) {\n\t\tif (node->flags & CN_RO) {\n\t\t\tnode = NULL;\n\t\t\tgoto beach;\n\t\t}\n\t\tif (node->value) {\n\t\t\tov = strdup (node->value);\n\t\t\tif (!ov) {\n\t\t\t\tnode = NULL;\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tfree (node->value);\n\t\t}\n\t\tif (node->flags & CN_BOOL) {\n\t\t\tnode->value = strdup (r_str_bool (i));\n\t\t} else {\n\t\t\tsnprintf (buf, sizeof (buf) - 1, \"%\" PFMT64d, i);\n\t\t\tnode->value = strdup (buf);\n\t\t}\n\t\tif (!node->value) {\n\t\t\tnode = NULL;\n\t\t\tgoto beach;\n\t\t}\n\t\t//node->flags = CN_RW | CN_INT;\n\t\tnode->i_value = i;\n\t} else {\n\t\tif (!cfg->lock) {\n\t\t\tif (i < 1024) {\n\t\t\t\tsnprintf (buf, sizeof (buf), \"%\" PFMT64d \"\", i);\n\t\t\t} else {\n\t\t\t\tsnprintf (buf, sizeof (buf), \"0x%08\" PFMT64x \"\", i);\n\t\t\t}\n\t\t\tnode = r_config_node_new (name, buf);\n\t\t\tif (!node) {\n\t\t\t\tnode = NULL;\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tnode->flags = CN_RW | CN_OFFT;\n\t\t\tnode->i_value = i;\n\t\t\tif (cfg->ht) {\n\t\t\t\tht_insert (cfg->ht, node->name, node);\n\t\t\t}\n\t\t\tif (cfg->nodes) {\n\t\t\t\tr_list_append (cfg->nodes, node);\n\t\t\t\tcfg->n_nodes++;\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"(locked: no new keys can be created (%s))\\n\", name);\n\t\t}\n\t}\n\n\tif (node && node->setter) {\n\t\tut64 oi = node->i_value;\n\t\tint ret = node->setter (cfg->user, node);\n\t\tif (!ret) {\n\t\t\tnode->i_value = oi;\n\t\t\tfree (node->value);\n\t\t\tnode->value = strdup (ov? ov: \"\");\n\t\t}\n\t}\nbeach:\n\tfree (ov);\n\treturn node;\n}\n\nR_API int r_config_eval(RConfig *cfg, const char *str) {\n\tchar *ptr, *a, *b, name[1024];\n\tunsigned int len;\n\tif (!str || !cfg) {\n\t\treturn false;\n\t}\n\tlen = strlen (str) + 1;\n\tif (len >= sizeof (name)) {\n\t\treturn false;\n\t}\n\tmemcpy (name, str, len);\n\tstr = r_str_chop (name);\n\n\tif (!str) {\n\t\treturn false;\n\t}\n\n\tif (str[0] == '\\0' || !strcmp (str, \"help\")) {\n\t\tr_config_list (cfg, NULL, 0);\n\t\treturn false;\n\t}\n\n\tif (str[0] == '-') {\n\t\tr_config_rm (cfg, str + 1);\n\t\treturn false;\n\t}\n\n\tptr = strchr (str, '=');\n\tif (ptr) {\n\t\t/* set */\n\t\tptr[0] = '\\0';\n\t\ta = r_str_chop (name);\n\t\tb = r_str_chop (ptr + 1);\n\t\t(void) r_config_set (cfg, a, b);\n\t} else {\n\t\tchar *foo = r_str_chop (name);\n\t\tif (foo[strlen (foo) - 1] == '.') {\n\t\t\tr_config_list (cfg, name, 0);\n\t\t\treturn false;\n\t\t} else {\n\t\t\t/* get */\n\t\t\tconst char *str = r_config_get (cfg, foo);\n\t\t\tif (str) {\n\t\t\t\tcfg->cb_printf (\"%s\\n\",\n\t\t\t\t\t(((int) (size_t) str) == 1)? \"true\": str);\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic int cmp(RConfigNode *a, RConfigNode *b) {\n\treturn strcmp (a->name, b->name);\n}\n\nR_API void r_config_lock(RConfig *cfg, int l) {\n\tr_list_sort (cfg->nodes, (RListComparator) cmp);\n\tcfg->lock = l;\n}\n\nR_API int r_config_readonly(RConfig *cfg, const char *key) {\n\tRConfigNode *n = r_config_node_get (cfg, key);\n\tif (!n) {\n\t\treturn false;\n\t}\n\tn->flags |= CN_RO;\n\treturn true;\n}\n\nstatic void _ht_node_free_kv(HtKv *kv) {\n\tfree (kv->key);\n\t//we do not free kv->value because there is other reference \n\tfree (kv);\n}\n\nR_API RConfig* r_config_new(void *user) {\n\tRConfig *cfg = R_NEW0 (RConfig);\n\tif (!cfg) {\n\t\treturn NULL;\n\t}\n\tcfg->ht = ht_new (NULL, _ht_node_free_kv, NULL);\n\tcfg->nodes = r_list_newf ((RListFree)r_config_node_free);\n\tif (!cfg->nodes) {\n\t\tR_FREE (cfg);\n\t\treturn NULL;\n\t}\n\tcfg->user = user;\n\tcfg->num = NULL;\n\tcfg->n_nodes = 0;\n\tcfg->lock = 0;\n\tcfg->cb_printf = (void *) printf;\n\treturn cfg;\n}\n\nR_API RConfig* r_config_clone(RConfig *cfg) {\n\tRListIter *iter;\n\tRConfigNode *node;\n\tRConfig *c = r_config_new (cfg->user);\n\tif (!c) {\n\t\treturn NULL;\n\t}\n\tr_list_foreach (cfg->nodes, iter, node) {\n\t\tRConfigNode *nn = r_config_node_clone (node);\n\t\tht_insert (c->ht, node->name, nn);\n\t\tr_list_append (c->nodes, nn);\n\t\tc->n_nodes++;\n\t}\n\tc->lock = cfg->lock;\n\tc->cb_printf = cfg->cb_printf;\n\treturn c;\n}\n\nR_API int r_config_free(RConfig *cfg) {\n\tif (!cfg) {\n\t\treturn 0;\n\t}\n\tcfg->nodes->free = r_config_node_free; // damn\n\tr_list_free (cfg->nodes);\n\tht_free (cfg->ht);\n\tfree (cfg);\n\treturn 0;\n}\n\nR_API void r_config_visual_hit_i(RConfig *cfg, const char *name, int delta) {\n\tRConfigNode *node = r_config_node_get (cfg, name);\n\tif (node && (node->flags & CN_INT || node->flags & CN_OFFT)) {\n\t\t(void)r_config_set_i (cfg, name, r_config_get_i (cfg, name) + delta);\n\t}\n}\n\nR_API void r_config_bump(RConfig *cfg, const char *key) {\n\tchar *orig = strdup (r_config_get (cfg, key));\n\tr_config_set (cfg, key, orig);\n\tfree (orig);\n}\n\nR_API bool r_config_save_char(RConfigHold *h, ...) {\n\tva_list ap;\n\tchar *key;\n\tif (!h->list_char) {\n\t\th->list_char = r_list_newf ((RListFree) free);\n\t\tif (!h->list_char) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tva_start (ap, h);\n\twhile ((key = va_arg (ap, char *))) {\n\t\tRConfigHoldChar *hc = R_NEW0 (RConfigHoldChar);\n\t\tif (!hc) {\n\t\t\tcontinue;\n\t\t}\n\t\thc->key = key;\n\t\thc->value = r_config_get (h->cfg, key);\n\t\tr_list_append (h->list_char, hc);\n\t}\n\tva_end (ap);\n\treturn true;\n}\n\nR_API bool r_config_save_num(RConfigHold *h, ...) {\n\tva_list ap;\n\tchar *key;\n\tif (!h->list_num) {\n\t\th->list_num = r_list_newf ((RListFree) free);\n\t\tif (!h->list_num) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tva_start (ap, h);\n\twhile ((key = va_arg (ap, char *))) {\n\t\tRConfigHoldNum *hc = R_NEW0 (RConfigHoldNum);\n\t\tif (!hc) {\n\t\t\tcontinue;\n\t\t}\n\t\thc->key = key;\n\t\thc->value = r_config_get_i (h->cfg, key);\n\t\tr_list_append (h->list_num, hc);\n\t}\n\tva_end (ap);\n\treturn true;\n}\n\nR_API RConfigHold* r_config_hold_new(RConfig *cfg) {\n\tif (cfg) {\n\t\tRConfigHold *hold = R_NEW0 (RConfigHold);\n\t\tif (hold) {\n\t\t\thold->cfg = cfg;\n\t\t\treturn hold;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API void r_config_restore(RConfigHold *h) {\n\tRListIter *iter;\n\tRConfigHoldChar *hchar;\n\tRConfigHoldNum *hnum;\n\tif (h) {\n\t\tr_list_foreach (h->list_num, iter, hnum) {\n\t\t\t(void)r_config_set_i (h->cfg, hnum->key, hnum->value);\n\t\t}\n\t\tr_list_foreach (h->list_char, iter, hchar) {\n\t\t\t(void)r_config_set (h->cfg, hchar->key, hchar->value);\n\t\t}\n\t}\n}\n\nR_API void r_config_hold_free(RConfigHold *h) {\n\tif (h) {\n\t\tr_list_free (h->list_num);\n\t\tr_list_free (h->list_char);\n\t\tR_FREE (h);\n\t}\n}\n", "/* radare - LGPL - Copyright 2011-2017 - earada, pancake */\n\n#include <r_core.h>\n#include \"r_util.h\"\n\n#define is_in_range(at, from, sz) ((at) >= (from) && (at) < ((from) + (sz)))\n\n#define VA_FALSE    0\n#define VA_TRUE     1\n#define VA_NOREBASE 2\n\n#define IS_MODE_SET(mode) (mode & R_CORE_BIN_SET)\n#define IS_MODE_SIMPLE(mode) (mode & R_CORE_BIN_SIMPLE)\n#define IS_MODE_SIMPLEST(mode) (mode & R_CORE_BIN_SIMPLEST)\n#define IS_MODE_JSON(mode) (mode & R_CORE_BIN_JSON)\n#define IS_MODE_RAD(mode) (mode & R_CORE_BIN_RADARE)\n#define IS_MODE_NORMAL(mode) (!mode)\n\n// dup from cmd_info\n#define PAIR_WIDTH 9\n\nstatic void pair(const char *a, const char *b, int mode, bool last) {\n\tif (!b || !(*b)) {\n\t\treturn;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tconst char *lst = last ? \"\" : \",\";\n\t\tr_cons_printf (\"\\\"%s\\\":%s%s\", a, b, lst);\n\t} else {\n\t\tchar ws[16];\n\t\tint al = strlen (a);\n\t\tal = PAIR_WIDTH - al;\n\t\tif (al < 0) {\n\t\t\tal = 0;\n\t\t}\n\t\tmemset (ws, ' ', al);\n\t\tws[al] = 0;\n\t\tr_cons_printf (\"%s%s%s\\n\", a, ws, b);\n\t}\n}\n\nstatic void pair_bool(const char *a, bool t, int mode, bool last) {\n\tpair (a, r_str_bool (t), mode, last);\n}\n\nstatic void pair_int(const char *a, int n, int mode, bool last) {\n\tpair (a, sdb_fmt (0, \"%d\", n), mode, last);\n}\n\nstatic void pair_str(const char *a, const char *b, int mode, int last) {\n\tif (IS_MODE_JSON (mode)) {\n\t\tif (!b) {\n\t\t\tb = \"\";\n\t\t}\n\t\tchar *eb = r_str_utf16_encode (b, -1);\n\t\tif (eb) {\n\t\t\tpair (a, sdb_fmt (0, \"\\\"%s\\\"\", eb), mode, last);\n\t\t\tfree (eb);\n\t\t}\n\t} else {\n\t\tpair (a, b, mode, last);\n\t}\n}\n\n#define STR(x) (x)?(x):\"\"\nR_API int r_core_bin_set_cur (RCore *core, RBinFile *binfile);\n\nstatic ut64 rva(RBin *bin, ut64 paddr, ut64 vaddr, int va) {\n\tif (va == VA_TRUE) {\n\t\treturn r_bin_get_vaddr (bin, paddr, vaddr);\n\t}\n\tif (va == VA_NOREBASE) {\n\t\treturn vaddr;\n\t}\n\treturn paddr;\n}\n\nR_API int r_core_bin_set_by_fd(RCore *core, ut64 bin_fd) {\n\tif (r_bin_file_set_cur_by_fd (core->bin, bin_fd)) {\n\t\tr_core_bin_set_cur (core, r_core_bin_cur (core));\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API int r_core_bin_set_by_name(RCore *core, const char * name) {\n\tif (r_bin_file_set_cur_by_name (core->bin, name)) {\n\t\tr_core_bin_set_cur (core, r_core_bin_cur (core));\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API int r_core_bin_set_env(RCore *r, RBinFile *binfile) {\n\tRBinObject *binobj = binfile ? binfile->o: NULL;\n\tRBinInfo *info = binobj ? binobj->info: NULL;\n\tif (info) {\n\t\tint va = info->has_va;\n\t\tconst char * arch = info->arch;\n\t\tut16 bits = info->bits;\n\t\tut64 baseaddr = r_bin_get_baddr (r->bin);\n\t\t/* Hack to make baddr work on some corner */\n\t\tr_config_set_i (r->config, \"io.va\",\n\t\t\t(binobj->info)? binobj->info->has_va: 0);\n\t\tr_config_set_i (r->config, \"bin.baddr\", baseaddr);\n\t\tr_config_set (r->config, \"asm.arch\", arch);\n\t\tr_config_set_i (r->config, \"asm.bits\", bits);\n\t\tr_config_set (r->config, \"anal.arch\", arch);\n\t\tif (info->cpu && *info->cpu) {\n\t\t\tr_config_set (r->config, \"anal.cpu\", info->cpu);\n\t\t} else {\n\t\t\tr_config_set (r->config, \"anal.cpu\", arch);\n\t\t}\n\t\tr_asm_use (r->assembler, arch);\n\t\tr_core_bin_info (r, R_CORE_BIN_ACC_ALL, R_CORE_BIN_SET, va, NULL, NULL);\n\t\tr_core_bin_set_cur (r, binfile);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API int r_core_bin_set_cur(RCore *core, RBinFile *binfile) {\n\tif (!core->bin) {\n\t\treturn false;\n\t}\n\tif (!binfile) {\n\t\t// Find first available binfile\n\t\tut32 fd = r_core_file_cur_fd (core);\n\t\tbinfile = fd != (ut32)-1\n\t\t\t\t  ? r_bin_file_find_by_fd (core->bin, fd)\n\t\t\t\t  : NULL;\n\t\tif (!binfile) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tr_bin_file_set_cur_binfile (core->bin, binfile);\n\treturn true;\n}\n\nR_API int r_core_bin_refresh_strings(RCore *r) {\n\treturn r_bin_reset_strings (r->bin) ? true: false;\n}\n\nR_API RBinFile * r_core_bin_cur(RCore *core) {\n\tRBinFile *binfile = r_bin_cur (core->bin);\n\treturn binfile;\n}\n\nstatic bool string_filter(RCore *core, const char *str) {\n\tint i;\n\t/* pointer/rawdata detection */\n\tif (core->bin->strpurge) {\n\t\tut8 bo[0x100];\n\t\tint up = 0;\n\t\tint lo = 0;\n\t\tint ot = 0;\n\t\tint di = 0;\n\t\tint ln = 0;\n\t\tint sp = 0;\n\t\tint nm = 0;\n\t\tfor (i = 0; i < 0x100; i++) {\n\t\t\tbo[i] = 0;\n\t\t}\n\t\tfor (i = 0; str[i]; i++) {\n\t\t\tif (IS_DIGIT(str[i])) {\n\t\t\t\tnm++;\n\t\t\t} else if (str[i]>='a' && str[i]<='z') {\n\t\t\t\tlo++;\n\t\t\t} else if (str[i]>='A' && str[i]<='Z') {\n\t\t\t\tup++;\n\t\t\t} else {\n\t\t\t\tot++;\n\t\t\t}\n\t\t\tif (str[i]=='\\\\') {\n\t\t\t\tot++;\n\t\t\t}\n\t\t\tif (str[i]==' ') {\n\t\t\t\tsp++;\n\t\t\t}\n\t\t\tbo[(ut8)str[i]] = 1;\n\t\t\tln++;\n\t\t}\n\t\tfor (i = 0; i<0x100; i++) {\n\t\t\tif (bo[i]) {\n\t\t\t\tdi++;\n\t\t\t}\n\t\t}\n\t\tif (ln > 2 && str[0] != '_') {\n\t\t\tif (ln < 10) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (ot >= (nm + up + lo)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (lo < 3) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (core->bin->strfilter) {\n\tcase 'U': // only uppercase strings\n\t\tfor (i = 0; str[i]; i++) {\n\t\t\tchar ch = str[i];\n\t\t\tif (ch == ' ') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ch < '@'|| ch > 'Z') {\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (ch < 0 || !IS_PRINTABLE (ch)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (str[0] && str[1]) {\n\t\t\tfor (i = 2; i<6 && str[i]; i++) {\n\t\t\t\tif (str[i] == str[0]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (str[i] == str[1]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (str[0] == str[2]) {\n\t\t\treturn false; // rm false positives\n\t\t}\n\t\tbreak;\n\tcase 'a': // only alphanumeric - plain ascii\n\t\tfor (i = 0; str[i]; i++) {\n\t\t\tchar ch = str[i];\n\t\t\tif (ch < 1 || !IS_PRINTABLE (ch)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'e': // emails\n\t\tif (str && *str) {\n\t\t\tif (!strstr (str + 1, \"@\")) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!strstr (str + 1, \".\")) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase 'f': // format-string\n\t\tif (str && *str) {\n\t\t\tif (!strstr (str+1, \"%\"))\n\t\t\t\treturn false;\n\t\t} else return false;\n\t\tbreak;\n\tcase 'u': // URLs\n\t\tif (!strstr (str, \"://\")) {\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n        case 'i': //IPV4\n\t\t{\n\t\t\tint segment = 0;\n\t\t\tint segmentsum = 0;\n\t\t\tbool prevd = false;\n\t\t\tfor (i = 0; str[i]; i++) {\n\t\t\t\tchar ch = str[i];\n\t\t\t\tif (IS_DIGIT(ch)) {\n\t\t\t\t\tsegmentsum = segmentsum*10 + (ch - '0');\n\t\t\t\t\tif (segment == 3) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tprevd = true;\n\t\t\t\t} else if (ch == '.') {\n\t\t\t\t\tif (prevd == true && segmentsum < 256){\n\t\t\t\t\t\tsegment++;\n\t\t\t\t\t\tsegmentsum = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsegmentsum = 0;\n\t\t\t\t\t\tsegment = 0;\n\t\t\t\t\t}\n\t\t\t\t\tprevd = false;\n\t\t\t\t} else {\n\t\t\t\t\tsegmentsum = 0;\n\t\t\t\t\tprevd = false;\n\t\t\t\t\tsegment = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\tcase 'p': // path\n\t\tif (str[0] != '/') {\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase '8': // utf8\n\t\tfor (i = 0; str[i]; i++) {\n\t\t\tchar ch = str[i];\n\t\t\tif (ch < 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void _print_strings(RCore *r, RList *list, int mode, int va) {\n\tint minstr = r_config_get_i (r->config, \"bin.minstr\");\n\tint maxstr = r_config_get_i (r->config, \"bin.maxstr\");\n\tRBin *bin = r->bin;\n\tRListIter *iter;\n\tRBinString *string;\n\tRBinSection *section;\n\tchar *q;\n\n\tbin->minstrlen = minstr;\n\tbin->maxstrlen = maxstr;\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"[\");\n\t}\n\tif (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"fs strings\");\n\t}\n\tif (IS_MODE_SET (mode) && r_config_get_i (r->config, \"bin.strings\")) {\n\t\tr_flag_space_set (r->flags, \"strings\");\n\t\tr_cons_break_push (NULL, NULL);\n\t}\n\tr_list_foreach (list, iter, string) {\n\t\tconst char *section_name, *type_string;\n\t\tut64 paddr, vaddr, addr;\n\t\tif (!string_filter (r, string->string)) {\n\t\t\tcontinue;\n\t\t}\n\t\tpaddr = string->paddr;\n\t\tvaddr = r_bin_get_vaddr (bin, paddr, string->vaddr);\n\t\taddr = va ? vaddr : paddr;\n\t\tif (string->length < minstr) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (maxstr && string->length > maxstr) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tsection = r_bin_get_section_at (r_bin_cur_object (bin), paddr, 0);\n\t\tsection_name = section ? section->name : \"unknown\";\n\t\ttype_string = r_bin_string_type (string->type);\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\tchar *f_name, *str;\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_meta_add (r->anal, R_META_TYPE_STRING, addr, addr + string->size, string->string);\n\t\t\tf_name = strdup (string->string);\n\t\t\tr_name_filter (f_name, -1);\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tstr = r_str_newf (\"%s.str.%s\", r->bin->prefix, f_name);\n\t\t\t} else {\n\t\t\t\tstr = r_str_newf (\"str.%s\", f_name);\n\t\t\t}\n\t\t\tr_flag_set (r->flags, str, addr, string->size);\n\t\t\tfree (str);\n\t\t\tfree (f_name);\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tr_cons_printf (\"0x%\"PFMT64x\" %d %d %s\\n\", addr, string->size, string->length, string->string);\n\t\t} else if (IS_MODE_SIMPLEST (mode)) {\n\t\t\tr_cons_println (string->string);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tq = r_base64_encode_dyn (string->string, -1);\n\t\t\tr_cons_printf (\"%s{\\\"vaddr\\\":%\"PFMT64d\n\t\t\t\t\",\\\"paddr\\\":%\"PFMT64d\",\\\"ordinal\\\":%d\"\n\t\t\t\t\",\\\"size\\\":%d,\\\"length\\\":%d,\\\"section\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\\\"string\\\":\\\"%s\\\"}\",\n\t\t\t\titer->p ? \",\": \"\",\n\t\t\t\tvaddr, paddr, string->ordinal, string->size,\n\t\t\t\tstring->length, section_name, type_string, q);\n\t\t\tfree (q);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tchar *f_name, *str;\n\t\t\tf_name = strdup (string->string);\n\t\t\tr_name_filter (f_name, R_FLAG_NAME_SIZE);\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tstr = r_str_newf (\"%s.str.%s\", r->bin->prefix, f_name);\n\t\t\t\tr_cons_printf (\"f %s.str.%s %\"PFMT64d\" @ 0x%08\"PFMT64x\"\\n\"\n\t\t\t\t\t\"Cs %\"PFMT64d\" @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\tr->bin->prefix, f_name, string->size, addr,\n\t\t\t\t\tstring->size, addr);\n\t\t\t} else {\n\t\t\t\tstr = r_str_newf (\"str.%s\", f_name);\n\t\t\t\tr_cons_printf (\"f str.%s %\"PFMT64d\" @ 0x%08\"PFMT64x\"\\n\"\n\t\t\t\t\t\"Cs %\"PFMT64d\" @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\tf_name, string->size, addr,\n\t\t\t\t\tstring->size, addr);\n\t\t\t}\n\t\t\tfree (str);\n\t\t\tfree (f_name);\n\t\t} else {\n\t\t\tr_cons_printf (\"vaddr=0x%08\"PFMT64x\" paddr=0x%08\"\n\t\t\t\tPFMT64x\" ordinal=%03u sz=%u len=%u \"\n\t\t\t\t\"section=%s type=%s string=%s\\n\",\n\t\t\t\tvaddr, paddr, string->ordinal, string->size,\n\t\t\t\tstring->length, section_name, type_string,\n\t\t\t\tstring->string);\n\t\t}\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"]\");\n\t}\n\tif (IS_MODE_SET (mode)) {\n\t\tr_cons_break_pop ();\n\t}\n}\n\nstatic bool bin_raw_strings(RCore *r, int mode, int va) {\n\tRBinFile *bf = r_bin_cur (r->bin);\n\tif (!bf && r->io && r->io->desc && r->io->desc->uri) {\n\t\tconst char *file = r->io->desc->uri;\n\t\tr_sys_cmdf (\"rabin2 -qzzz '%s'\", file);\n\t\t// eprintf (\"Likely you used -nn \\n\");\n\t\t// eprintf (\"try: .!rabin2 -B <baddr> -zzr filename\\n\");\n\t\treturn false;\n\t}\n\tif (bf && strstr (bf->file, \"malloc://\")) {\n\t\t//sync bf->buf to search string on it\n\t\tr_io_read_at (r->io, 0, bf->buf->buf, bf->size);\n\t}\n\tif (!r->file) {\n\t\teprintf (\"Core file not open\\n\");\n\t\treturn false;\n\t}\n\tRList *l = r_bin_raw_strings (bf, 0);\n\t_print_strings (r, l, mode, va);\n\treturn true;\n}\n\nstatic bool bin_strings(RCore *r, int mode, int va) {\n\tRList *list;\n\tRBinFile *binfile = r_core_bin_cur (r);\n\tRBinPlugin *plugin = r_bin_file_cur_plugin (binfile);\n\tint rawstr = r_config_get_i (r->config, \"bin.rawstr\");\n\tif (!binfile) {\n\t\treturn false;\n\t}\n\tif (!r_config_get_i (r->config, \"bin.strings\")) {\n\t\treturn 0;\n\t}\n\tif (!plugin) {\n\t\treturn 0;\n\t}\n\tif (plugin->info && plugin->name) {\n\t\tif (strcmp (plugin->name, \"any\") == 0 && !rawstr) {\n\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\tr_cons_print(\"[]\");\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (!(list = r_bin_get_strings (r->bin))) {\n\t\treturn false;\n\t}\n\t_print_strings (r, list, mode, va);\n\treturn true;\n}\n\nstatic const char* get_compile_time(Sdb *binFileSdb) {\n\tSdb *info_ns = sdb_ns (binFileSdb, \"info\", false);\n\tconst char *timeDateStamp_string = sdb_const_get (info_ns,\n\t\t\"image_file_header.TimeDateStamp_string\", 0);\n\treturn timeDateStamp_string;\n}\n\nstatic int is_executable(RBinObject *obj) {\n\tRListIter *it;\n\tRBinSection* sec;\n\tif (obj) {\n\t\tif (obj->info && obj->info->arch) {\n\t\t\treturn true;\n\t\t}\n\t\tr_list_foreach (obj->sections, it, sec) {\n\t\t\tif (R_BIN_SCN_EXECUTABLE & sec->srwx) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n#define DBSPATH R2_PREFIX \"/share/radare2/\" R2_VERSION \"/fcnsign\"\nstatic void sdb_concat_by_path(Sdb *s, const char *path) {\n\tSdb *db = sdb_new (0, path, 0);\n\tsdb_merge (s, db);\n\tsdb_close (db);\n\tsdb_free (db);\n}\n\nR_API void r_core_anal_type_init(RCore *core) {\n\tSdb *types = NULL;\n\tconst char *anal_arch = NULL, *os = NULL;\n\tint bits = 0;\n\tchar *dbpath;\n\tif (!core || !core->anal) {\n\t\treturn;\n\t}\n\tbits = core->assembler->bits;\n\ttypes = core->anal->sdb_types;\n \t// make sure they are empty this is initializing\n\tsdb_reset (types);\n\tanal_arch = r_config_get (core->config, \"anal.arch\");\n\tos = r_config_get (core->config, \"asm.os\");\n\tif (r_file_exists (DBSPATH\"/types.sdb\")) {\n\t\tsdb_concat_by_path (types, DBSPATH\"/types.sdb\");\n\t}\n\tdbpath = sdb_fmt (-1, DBSPATH\"/types-%s.sdb\", anal_arch);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (-1, DBSPATH\"/types-%s.sdb\", os);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (-1, DBSPATH\"/types-%d.sdb\", bits);\n\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (-1, DBSPATH\"/types-%s-%d.sdb\", os, bits);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (-1, DBSPATH\"/types-%s-%d.sdb\", anal_arch, bits);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (-1, DBSPATH\"/types-%s-%s.sdb\", anal_arch, os);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (-1, DBSPATH\"/types-%s-%s-%d.sdb\", anal_arch, os, bits);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n}\n\nstatic int save_ptr(void *p, const char *k, const char *v) {\n\tSdb *sdbs[2];\n\tsdbs[0] = ((Sdb**) p)[0];\n\tsdbs[1] = ((Sdb**) p)[1];\n\tif (!strncmp (v, \"cc\", strlen (\"cc\") + 1)) {\n\t\tconst char *x = sdb_const_get (sdbs[1], sdb_fmt (-1, \"cc.%s.name\", k), 0);\n\t\tchar *tmp = sdb_fmt (-1, \"%p\", x);\n\t\tsdb_set (sdbs[0], tmp, x, 0);\n\t}\n\treturn 1;\n}\n\nR_API void r_core_anal_cc_init(RCore *core) {\n\tSdb *sdbs[2] = {\n\t\tsdb_new0 (),\n\t\tcore->anal->sdb_cc\n\t};\n\t//save pointers and values stored inside them\n\t//to recover from freeing heeps\n\tconst char *defaultcc = sdb_const_get (sdbs[1], \"default.cc\", 0);\n\tsdb_set (sdbs[0], sdb_fmt (-1, \"0x%08\"PFMT64x, r_num_get (NULL, defaultcc)), defaultcc, 0);\n\tsdb_foreach (core->anal->sdb_cc, save_ptr, sdbs);\n\tsdb_reset ( core->anal->sdb_cc);\n\tconst char *anal_arch = r_config_get (core->config, \"anal.arch\");\n\n\tint bits = core->anal->bits;\n\tif (bits == 16 && !strcmp (anal_arch, \"arm\")) {\n\t\tbits = 32;\n\t}\n\n\tchar *dbpath = sdb_fmt (-1, DBSPATH\"/cc-%s-%d.sdb\", anal_arch, bits);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (core->anal->sdb_cc, dbpath);\n\t}\n\t//restore all freed CC or replace with new default cc\n\tRListIter *it;\n\tRAnalFunction *fcn;\n\tr_list_foreach (core->anal->fcns, it, fcn) {\n\t\tchar *ptr = sdb_fmt (-1, \"%p\", fcn->cc);\n\t\tconst char *cc = sdb_const_get (sdbs[0], ptr, 0);\n\t\tif (cc) {\n\t\t\tfcn->cc = r_anal_cc_to_constant (core->anal, (char *)cc);\n\t\t}\n\t\tif (!fcn->cc) {\n\t\t\tfcn->cc = r_anal_cc_default (core->anal);\n\t\t}\n\t\tfcn->cc = r_str_const (fcn->cc);\n\t}\n\tsdb_close (sdbs[0]);\n\tsdb_free (sdbs[0]);\n}\n#undef DBSPATH\n\nstatic int bin_info(RCore *r, int mode) {\n\tint i, j, v;\n\tchar str[R_FLAG_NAME_SIZE];\n\tRBinInfo *info = r_bin_get_info (r->bin);\n\tRBinFile *binfile = r_core_bin_cur (r);\n\tRBinObject *obj = r_bin_cur_object (r->bin);\n\tconst char *compiled = NULL;\n\tbool havecode;\n\n\tif (!binfile || !info || !obj) {\n\t\tif (mode & R_CORE_BIN_JSON) {\n\t\t\tr_cons_printf (\"{}\");\n\t\t}\n\t\treturn false;\n\t}\n\thavecode = is_executable (obj) | (obj->entries != NULL);\n\tcompiled = get_compile_time (binfile->sdb);\n\n\tif (IS_MODE_SET (mode)) {\n\t\tr_config_set (r->config, \"file.type\", info->rclass);\n\t\tr_config_set (r->config, \"cfg.bigendian\",\n\t\t\t      info->big_endian ? \"true\" : \"false\");\n\t\tif (info->rclass && !strcmp (info->rclass, \"fs\")) {\n\t\t\tr_config_set (r->config, \"asm.arch\", info->arch);\n\t\t\tr_core_cmdf (r, \"m /root %s 0\", info->arch);\n\t\t} else {\n\t\t\tif (info->lang) {\n\t\t\t\tr_config_set (r->config, \"bin.lang\", info->lang);\n\t\t\t}\n\t\t\tr_config_set (r->config, \"asm.os\", info->os);\n\t\t\tr_config_set (r->config, \"asm.arch\", info->arch);\n\t\t\tr_config_set (r->config, \"anal.arch\", info->arch);\n\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"%i\", info->bits);\n\t\t\tr_config_set (r->config, \"asm.bits\", str);\n\t\t\tr_config_set (r->config, \"asm.dwarf\",\n\t\t\t\t(R_BIN_DBG_STRIPPED & info->dbg_info) ? \"false\" : \"true\");\n\t\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_ALIGN);\n\t\t\tif (v != -1) r_config_set_i (r->config, \"asm.pcalign\", v);\n\t\t}\n\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\tr_cons_printf (\"arch %s\\n\", info->arch);\n\t\tr_cons_printf (\"bits %d\\n\", info->bits);\n\t\tr_cons_printf (\"os %s\\n\", info->os);\n\t\tr_cons_printf (\"endian %s\\n\", info->big_endian? \"big\": \"little\");\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);\n\t\tif (v != -1) {\n\t\t\tr_cons_printf (\"minopsz %d\\n\", v);\n\t\t}\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_MAX_OP_SIZE);\n\t\tif (v != -1) {\n\t\t\tr_cons_printf (\"maxopsz %d\\n\", v);\n\t\t}\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_ALIGN);\n\t\tif (v != -1) {\n\t\t\tr_cons_printf (\"pcalign %d\\n\", v);\n\t\t}\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tif (info->type && !strcmp (info->type, \"fs\")) {\n\t\t\tr_cons_printf (\"e file.type=fs\\n\");\n\t\t\tr_cons_printf (\"m /root %s 0\\n\", info->arch);\n\t\t} else {\n\t\t\tr_cons_printf (\"e cfg.bigendian=%s\\n\"\n\t\t\t\t\"e asm.bits=%i\\n\"\n\t\t\t\t\"e asm.dwarf=%s\\n\",\n\t\t\t\tr_str_bool (info->big_endian),\n\t\t\t\tinfo->bits,\n\t\t\t\tr_str_bool (R_BIN_DBG_STRIPPED &info->dbg_info));\n\t\t\tif (info->lang && *info->lang) {\n\t\t\t\tr_cons_printf (\"e bin.lang=%s\\n\", info->lang);\n\t\t\t}\n\t\t\tif (info->rclass && *info->rclass) {\n\t\t\t\tr_cons_printf (\"e file.type=%s\\n\",\n\t\t\t\t\tinfo->rclass);\n\t\t\t}\n\t\t\tif (info->os) {\n\t\t\t\tr_cons_printf (\"e asm.os=%s\\n\", info->os);\n\t\t\t}\n\t\t\tif (info->arch) {\n\t\t\t\tr_cons_printf (\"e asm.arch=%s\\n\", info->arch);\n\t\t\t}\n\t\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_ALIGN);\n\t\t\tif (v != -1) r_cons_printf (\"e asm.pcalign=%d\\n\", v);\n\t\t}\n\t} else {\n\t\t// XXX: if type is 'fs' show something different?\n\t\tchar *tmp_buf;\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"{\");\n\t\t}\n\t\tpair_str (\"arch\", info->arch, mode, false);\n\t\tpair_int (\"binsz\", r_bin_get_size (r->bin), mode, false);\n\t\tpair_str (\"bintype\", info->rclass, mode, false);\n\t\tpair_int (\"bits\", info->bits, mode, false);\n\t\tpair_bool (\"canary\", info->has_canary, mode, false);\n\t\tpair_str (\"class\", info->bclass, mode, false);\n\t\tif (info->actual_checksum) {\n\t\t\t/* computed checksum */\n\t\t\tpair_str (\"cmp.csum\", info->actual_checksum, mode, false);\n\t\t}\n\t\tpair_str (\"compiled\", compiled, mode, false);\n\t\tpair_bool (\"crypto\", info->has_crypto, mode, false);\n\t\ttmp_buf = r_str_escape (info->debug_file_name);\n\t\tpair_str (\"dbg_file\", tmp_buf, mode, false);\n\t\tfree (tmp_buf);\n\t\tpair_str (\"endian\", info->big_endian ? \"big\" : \"little\", mode, false);\n\t\tpair_bool (\"havecode\", havecode, mode, false);\n\t\tif (info->claimed_checksum) {\n\t\t\t/* checksum specified in header */\n\t\t\tpair_str (\"hdr.csum\", info->claimed_checksum, mode, false);\n\t\t}\n\t\tpair_str (\"guid\", info->guid, mode, false);\n\t\tpair_str (\"intrp\", info->intrp, mode, false);\n\t\tpair_str (\"lang\", info->lang, mode, false);\n\t\tpair_bool (\"linenum\", R_BIN_DBG_LINENUMS & info->dbg_info, mode, false);\n\t\tpair_bool (\"lsyms\", R_BIN_DBG_SYMS & info->dbg_info, mode, false);\n\t\tpair_str (\"machine\", info->machine, mode, false);\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_MAX_OP_SIZE);\n\t\tif (v != -1) {\n\t\t\tpair_int (\"maxopsz\", v, mode, false);\n\t\t}\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);\n\t\tif (v != -1) {\n\t\t\tpair_int (\"minopsz\", v, mode, false);\n\t\t}\n\t\tpair_bool (\"nx\", info->has_nx, mode, false);\n\t\tpair_str (\"os\", info->os, mode, false);\n\t\tif (info->rclass && !strcmp (info->rclass, \"pe\")) {\n\t\t\tpair_bool (\"overlay\", info->pe_overlay, mode, false);\n\t\t}\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_ALIGN);\n\t\tif (v != -1) {\n\t\t\tpair_int (\"pcalign\", v, mode, false);\n\t\t}\n\t\tpair_bool (\"pic\", info->has_pi, mode, false);\n\t\tpair_bool (\"relocs\", R_BIN_DBG_RELOCS & info->dbg_info, mode, false);\n\t\ttmp_buf = sdb_get (obj->kv, \"elf.relro\", 0);\n\t\tif (tmp_buf) {\n\t\t\tpair_str (\"relro\", tmp_buf, mode, false);\n\t\t\tfree (tmp_buf);\n\t\t}\n\t\tpair_str (\"rpath\", info->rpath, mode, false);\n\t\tif (info->rclass && !strcmp (info->rclass, \"pe\")) {\n\t\t\t//this should be moved if added to mach0 (or others)\n\t\t\tpair_bool (\"signed\", info->signature, mode, false);\n\t\t}\n\t\tpair_bool (\"static\", r_bin_is_static (r->bin), mode, false);\n\t\tpair_bool (\"stripped\", R_BIN_DBG_STRIPPED & info->dbg_info, mode, false);\n\t\tpair_str (\"subsys\", info->subsystem, mode, false);\n\t\tpair_bool (\"va\", info->has_va, mode, true);\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\",\\\"checksums\\\":{\");\n\t\t\tfor (i = 0; info->sum[i].type; i++) {\n\t\t\t\tRBinHash *h = &info->sum[i];\n\t\t\t\tut64 hash = r_hash_name_to_bits (h->type);\n\t\t\t\tRHash *rh = r_hash_new (true, hash);\n\t\t\t\tint len = r_hash_calculate (rh, hash, (const ut8*)\n\t\t\t\t\t\tbinfile->buf->buf+h->from, h->to);\n\t\t\t\tif (len < 1) {\n\t\t\t\t\teprintf (\"Invaild checksum length\\n\");\n\t\t\t\t}\n\t\t\t\tr_hash_free (rh);\n\t\t\t\tr_cons_printf (\"%s\\\"%s\\\":{\\\"hex\\\":\\\"\", i?\",\": \"\", h->type);\n\t\t\t\t// r_cons_printf (\"%s\\t%d-%dc\\t\", h->type, h->from, h->to+h->from);\n\t\t\t\tfor (j = 0; j < h->len; j++) {\n\t\t\t\t\tr_cons_printf (\"%02x\", h->buf[j]);\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"\\\"}\");\n\t\t\t}\n\t\t\tr_cons_printf (\"}\");\n\t\t} else {\n\t\t\tfor (i = 0; info->sum[i].type; i++) {\n\t\t\t\tRBinHash *h = &info->sum[i];\n\t\t\t\tut64 hash = r_hash_name_to_bits (h->type);\n\t\t\t\tRHash *rh = r_hash_new (true, hash);\n\t\t\t\tint len = r_hash_calculate (rh, hash, (const ut8*)\n\t\t\t\t\t\tbinfile->buf->buf+h->from, h->to);\n\t\t\t\tif (len < 1) {\n\t\t\t\t\teprintf (\"Invaild wtf\\n\");\n\t\t\t\t}\n\t\t\t\tr_hash_free (rh);\n\t\t\t\tr_cons_printf (\"%s\\t%d-%dc\\t\", h->type, h->from, h->to+h->from);\n\t\t\t\tfor (j = 0; j < h->len; j++) {\n\t\t\t\t\tr_cons_printf (\"%02x\", h->buf[j]);\n\t\t\t\t}\n\t\t\t\tr_cons_newline ();\n\t\t\t}\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) r_cons_printf (\"}\");\n\t}\n\tr_core_anal_type_init (r);\n\tr_core_anal_cc_init (r);\n\treturn true;\n}\n\nstatic int bin_dwarf(RCore *core, int mode) {\n\tRBinDwarfRow *row;\n\tRListIter *iter;\n\tRList *list = NULL;\n\tRBinFile *binfile = r_core_bin_cur (core);\n\tRBinPlugin * plugin = r_bin_file_cur_plugin (binfile);\n\tif (!binfile) {\n\t\treturn false;\n\t}\n\tif (plugin && plugin->lines) {\n\t\tlist = plugin->lines (binfile);\n\t} else if (core->bin) {\n\t\t// TODO: complete and speed-up support for dwarf\n\t\tif (r_config_get_i (core->config, \"bin.dbginfo\")) {\n\t\t\tRBinDwarfDebugAbbrev *da = NULL;\n\t\t\tda = r_bin_dwarf_parse_abbrev (core->bin, mode);\n\t\t\tr_bin_dwarf_parse_info (da, core->bin, mode);\n\t\t\tr_bin_dwarf_parse_aranges (core->bin, mode);\n\t\t\tlist = r_bin_dwarf_parse_line (core->bin, mode);\n\t\t\tr_bin_dwarf_free_debug_abbrev (da);\n\t\t\tfree (da);\n\t\t}\n\t}\n\tif (!list) {\n\t\treturn false;\n\t}\n\n\tr_cons_break_push (NULL, NULL);\n\t/* cache file:line contents */\n\tconst char *lastFile = NULL;\n\tint *lastFileLines = NULL;\n\tchar *lastFileContents = NULL;\n\tint lastFileLinesCount = 0;\n\n\t/* ugly dupe for speedup */\n\tconst char *lastFile2 = NULL;\n\tint *lastFileLines2 = NULL;\n\tchar *lastFileContents2 = NULL;\n\tint lastFileLinesCount2 = 0;\n\n\n\tconst char *lf = NULL;\n\tint *lfl = NULL;\n\tchar *lfc = NULL;\n\tint lflc = 0;\n\n\t//TODO we should need to store all this in sdb, or do a filecontentscache in libr/util\n\t//XXX this whole thing has leaks\n\tr_list_foreach (list, iter, row) {\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tif (mode) {\n\t\t\t// TODO: use 'Cl' instead of CC\n\t\t\tconst char *path = row->file;\n\t\t\tif (!lastFile || strcmp (path, lastFile)) {\n\t\t\t\tif (lastFile && lastFile2 && !strcmp (path, lastFile2)) {\n\t\t\t\t\tlf = lastFile;\n\t\t\t\t\tlfl = lastFileLines;\n\t\t\t\t\tlfc = lastFileContents;\n\t\t\t\t\tlflc = lastFileLinesCount;\n\t\t\t\t\tlastFile = lastFile2;\n\t\t\t\t\tlastFileLines = lastFileLines2;\n\t\t\t\t\tlastFileContents = lastFileContents2;\n\t\t\t\t\tlastFileLinesCount = lastFileLinesCount2;\n\t\t\t\t\tlastFile2 = lf;\n\t\t\t\t\tlastFileLines2 = lfl;\n\t\t\t\t\tlastFileContents2 = lfc;\n\t\t\t\t\tlastFileLinesCount2 = lflc;\n\t\t\t\t} else {\n\t\t\t\t\tlastFile2 = lastFile;\n\t\t\t\t\tlastFileLines2 = lastFileLines;\n\t\t\t\t\tlastFileContents2 = lastFileContents;\n\t\t\t\t\tlastFileLinesCount2 = lastFileLinesCount;\n\t\t\t\t\tlastFile = path;\n\t\t\t\t\tlastFileContents = r_file_slurp (path, NULL);\n\t\t\t\t\tif (lastFileContents) {\n\t\t\t\t\t\tlastFileLines = r_str_split_lines (lastFileContents, &lastFileLinesCount);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tchar *line = NULL;\n\t\t\t//r_file_slurp_line (path, row->line - 1, 0);\n\t\t\tif (lastFileLines && lastFileContents) {\n\t\t\t\tint nl = row->line - 1;\n\t\t\t\tif (nl >= 0 && nl < lastFileLinesCount) {\n\t\t\t\t\tline = strdup (lastFileContents + lastFileLines[nl]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tline = NULL;\n\t\t\t}\n\t\t\tif (line) {\n\t\t\t\tr_str_filter (line, strlen (line));\n\t\t\t\tline = r_str_replace (line, \"\\\"\", \"\\\\\\\"\", 1);\n\t\t\t\tline = r_str_replace (line, \"\\\\\\\\\", \"\\\\\", 1);\n\t\t\t}\n\t\t\tbool chopPath = !r_config_get_i (core->config, \"dir.dwarf.abspath\");\n\t\t\tchar *file = strdup (row->file);\n\t\t\tif (chopPath) {\n\t\t\t\tconst char *slash = r_str_lchr (file, '/');\n\t\t\t\tif (slash) {\n\t\t\t\t\tmemmove (file, slash + 1, strlen (slash));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// TODO: implement internal : if ((mode & R_CORE_BIN_SET))\n\t\t\tif ((mode & R_CORE_BIN_SET)) {\n\t\t\t\t// TODO: use CL here.. but its not necessary.. so better not do anything imho\n\t\t\t\t// r_core_cmdf (core, \"CL %s:%d 0x%08\"PFMT64x, file, (int)row->line, row->address);\n#if 0\n\t\t\t\tchar *cmt = r_str_newf (\"%s:%d %s\", file, (int)row->line, line? line: \"\");\n\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, row->address, cmt);\n\t\t\t\tfree (cmt);\n#endif\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"CL %s:%d 0x%08\" PFMT64x \"\\n\",\n\t\t\t\t\t       file, (int)row->line,\n\t\t\t\t\t       row->address);\n\t\t\t\tr_cons_printf (\"\\\"CC %s:%d %s\\\"@0x%\" PFMT64x\n\t\t\t\t\t       \"\\n\",\n\t\t\t\t\t       file, row->line,\n\t\t\t\t\t       line ? line : \"\", row->address);\n\t\t\t}\n\t\t\tfree (file);\n\t\t\tfree (line);\n\t\t} else {\n\t\t\tr_cons_printf (\"0x%08\" PFMT64x \"\\t%s\\t%d\\n\",\n\t\t\t\t       row->address, row->file, row->line);\n\t\t}\n\t}\n\tr_cons_break_pop ();\n\tR_FREE (lastFileContents);\n\tR_FREE (lastFileContents2);\n\tr_list_free (list);\n\tfree (lastFileLines);\n\treturn true;\n}\n\nstatic int bin_pdb(RCore *core, int mode) {\n\tR_PDB pdb = R_EMPTY;\n\tut64 baddr = r_bin_get_baddr (core->bin);\n\n\tpdb.cb_printf = r_cons_printf;\n\tif (!init_pdb_parser (&pdb, core->bin->file)) {\n\t\treturn false;\n\t}\n\tif (!pdb.pdb_parse (&pdb)) {\n\t\teprintf (\"pdb was not parsed\\n\");\n\t\tpdb.finish_pdb_parse (&pdb);\n\t\treturn false;\n\t}\n\tif (mode == R_CORE_BIN_JSON) {\n\t\tr_cons_printf(\"[\");\n\t}\n\n\tswitch (mode) {\n\tcase R_CORE_BIN_SET:\n\t\tmode = 's';\n\t\tr_core_cmd0 (core, \".iP*\");\n\t\treturn true;\n\tcase R_CORE_BIN_JSON:\n\t\tmode = 'j';\n\t\tbreak;\n\tcase '*':\n\tcase 1:\n\t\tmode = 'r';\n\t\tbreak;\n\tdefault:\n\t\tmode = 'd'; // default\n\t\tbreak;\n\t}\n\n\tpdb.print_types (&pdb, mode);\n\tif (mode == 'j') {\n\t\tr_cons_printf (\",\");\n\t}\n\tpdb.print_gvars (&pdb, baddr, mode);\n\tif (mode == 'j') {\n\t\tr_cons_printf (\"]\");\n\t}\n\tpdb.finish_pdb_parse (&pdb);\n\n\treturn true;\n}\n\nstatic int bin_main(RCore *r, int mode, int va) {\n\tRBinAddr *binmain = r_bin_get_sym (r->bin, R_BIN_SYM_MAIN);\n\tut64 addr;\n\tif (!binmain) {\n\t\treturn false;\n\t}\n\taddr = va ? r_bin_a2b (r->bin, binmain->vaddr) : binmain->paddr;\n\n\tif (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, \"symbols\");\n\t\tr_flag_set (r->flags, \"main\", addr, r->blocksize);\n\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\tr_cons_printf (\"%\"PFMT64d, addr);\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"fs symbols\\n\");\n\t\tr_cons_printf (\"f main @ 0x%08\"PFMT64x\"\\n\", addr);\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"{\\\"vaddr\\\":%\" PFMT64d\n\t\t\t\",\\\"paddr\\\":%\" PFMT64d \"}\", addr, binmain->paddr);\n\t} else {\n\t\tr_cons_printf (\"[Main]\\n\");\n\t\tr_cons_printf (\"vaddr=0x%08\"PFMT64x\" paddr=0x%08\"PFMT64x\"\\n\",\n\t\t\taddr, binmain->paddr);\n\t}\n\treturn true;\n}\n\nstatic int bin_entry(RCore *r, int mode, ut64 laddr, int va) {\n\tchar str[R_FLAG_NAME_SIZE];\n\tRList *entries = r_bin_get_entries (r->bin);\n\tRListIter *iter;\n\tRBinAddr *entry = NULL;\n\tint i = 0;\n\tut64 baddr = r_bin_get_baddr (r->bin);\n\n\tif (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"fs symbols\\n\");\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"[\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"[Entrypoints]\\n\");\n\t}\n\n\tr_list_foreach (entries, iter, entry) {\n\t\tut64 paddr = entry->paddr;\n\t\tut64 haddr = UT64_MAX;\n\t\tif (entry->haddr) {\n\t\t\thaddr = entry->haddr;\n\t\t}\n\t\tut64 at = rva (r->bin, paddr, entry->vaddr, va);\n\t\tconst char *type = r_bin_entry_type_string (entry->type);\n\t\tif (!type) {\n\t\t\ttype = \"unknown\";\n\t\t}\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\tr_flag_space_set (r->flags, \"symbols\");\n\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"entry%i\", i);\n\t\t\tr_flag_set (r->flags, str, at, 1);\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"\\n\", at);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"%s{\\\"vaddr\\\":%\" PFMT64d \",\"\n\t\t\t\t\"\\\"paddr\\\":%\" PFMT64d \",\"\n\t\t\t\t\"\\\"baddr\\\":%\" PFMT64d \",\"\n\t\t\t\t\"\\\"laddr\\\":%\" PFMT64d \",\"\n\t\t\t\t\"\\\"haddr\\\":%\" PFMT64d \",\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\"}\",\n\t\t\t\titer->p ? \",\" : \"\", at, paddr, baddr, laddr, haddr, type);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"f entry%i 1 @ 0x%08\"PFMT64x\"\\n\", i, at);\n\t\t\tr_cons_printf (\"f entry%i_haddr 1 @ 0x%08\"PFMT64x\"\\n\", i, haddr);\n\t\t\tr_cons_printf (\"s entry%i\\n\", i);\n\t\t} else {\n\t\t\tr_cons_printf (\n\t\t\t\t \"vaddr=0x%08\"PFMT64x\n\t\t\t\t\" paddr=0x%08\"PFMT64x\n\t\t\t\t\" baddr=0x%08\"PFMT64x\n\t\t\t\t\" laddr=0x%08\"PFMT64x,\n\t\t\t\tat, paddr, baddr, laddr);\n\t\t\tif (haddr == UT64_MAX) {\n\t\t\t\tr_cons_printf (\n\t\t\t\t\t\" haddr=%\"PFMT64d\n\t\t\t\t\t\" type=%s\\n\",\n\t\t\t\t\thaddr, type);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\n\t\t\t\t\t\" haddr=0x%08\"PFMT64x\n\t\t\t\t\t\" type=%s\\n\",\n\t\t\t\t\thaddr, type);\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\tif (IS_MODE_SET (mode)) {\n\t\tif (entry) {\n\t\t\tut64 at = rva (r->bin, entry->paddr, entry->vaddr, va);\n\t\t\tr_core_seek (r, at, 0);\n\t\t}\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"]\");\n\t\tr_cons_newline ();\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"\\n%i entrypoints\\n\", i);\n\t}\n\treturn true;\n}\n\nstatic const char *bin_reloc_type_name(RBinReloc *reloc) {\n#define CASE(T) case R_BIN_RELOC_ ## T: return reloc->additive ? \"ADD_\" #T : \"SET_\" #T\n\tswitch (reloc->type) {\n\t\tCASE(8);\n\t\tCASE(16);\n\t\tCASE(32);\n\t\tCASE(64);\n\t}\n\treturn \"UNKNOWN\";\n#undef CASE\n}\n\nstatic ut8 bin_reloc_size(RBinReloc *reloc) {\n#define CASE(T) case R_BIN_RELOC_ ## T: return T / 8\n\tswitch (reloc->type) {\n\t\tCASE(8);\n\t\tCASE(16);\n\t\tCASE(32);\n\t\tCASE(64);\n\t}\n\treturn 0;\n#undef CASE\n}\n\nstatic char *resolveModuleOrdinal(Sdb *sdb, const char *module, int ordinal) {\n\tSdb *db = sdb;\n\tchar *foo = sdb_get (db, sdb_fmt (0, \"%d\", ordinal), 0);\n\treturn (foo && *foo) ? foo : NULL;\n}\n\nstatic char *get_reloc_name(RBinReloc *reloc, ut64 addr) {\n\tchar *reloc_name = NULL;\n\tif (reloc->import && reloc->import->name) {\n\t\treloc_name = sdb_fmt (-1, \"reloc.%s_%d\", reloc->import->name,\n\t\t\t\t      (int)(addr & 0xff));\n\t\tif (!reloc_name) {\n\t\t\treturn NULL;\n\t\t}\n\t\tr_str_replace_char (reloc_name, '$', '_');\n\t} else if (reloc->symbol && reloc->symbol->name) {\n\t\treloc_name = sdb_fmt (-1, \"reloc.%s_%d\", reloc->symbol->name, (int)(addr & 0xff));\n\t\tif (!reloc_name) {\n\t\t\treturn NULL;\n\t\t}\n\t\tr_str_replace_char (reloc_name, '$', '_');\n\t} else if (reloc->is_ifunc) {\n\t\t// addend is the function pointer for the resolving ifunc\n\t\treloc_name = sdb_fmt (-1, \"reloc.ifunc_%\"PFMT64x, reloc->addend);\n\t} else {\n\t\t// TODO(eddyb) implement constant relocs.\n\t}\n\treturn reloc_name;\n}\n\nstatic void set_bin_relocs(RCore *r, RBinReloc *reloc, ut64 addr, Sdb **db, char **sdb_module) {\n\tint bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tconst char *lang = r_config_get (r->config, \"bin.lang\");\n\tchar *reloc_name, *demname = NULL;\n\tbool is_pe = true;\n\tint is_sandbox = r_sandbox_enable (0);\n\n\tif (reloc->import && reloc->import->name[0]) {\n\t\tchar str[R_FLAG_NAME_SIZE];\n\t\tRFlagItem *fi;\n\n\t\tif (is_pe && !is_sandbox && strstr (reloc->import->name, \"Ordinal\")) {\n\t\t\tconst char *TOKEN = \".dll_Ordinal_\";\n\t\t\tchar *module = strdup (reloc->import->name);\n\t\t\tchar *import = strstr (module, TOKEN);\n\n\t\t\tr_str_case (module, false);\n\t\t\tif (import) {\n\t\t\t\tchar *filename = NULL;\n\t\t\t\tint ordinal;\n\t\t\t\t*import = 0;\n\t\t\t\timport += strlen (TOKEN);\n\t\t\t\tordinal = atoi (import);\n\t\t\t\tif (!*sdb_module || strcmp (module, *sdb_module)) {\n\t\t\t\t\tsdb_free (*db);\n\t\t\t\t\t*db = NULL;\n\t\t\t\t\tfree (*sdb_module);\n\t\t\t\t\t*sdb_module = strdup (module);\n\t\t\t\t\t/* always lowercase */\n\t\t\t\t\tfilename = sdb_fmt (1, \"%s.sdb\", module);\n\t\t\t\t\tr_str_case (filename, false);\n\t\t\t\t\tif (r_file_exists (filename)) {\n\t\t\t\t\t\t*db = sdb_new (NULL, filename, 0);\n\t\t\t\t\t} else {\n#if __WINDOWS__\n\t\t\t\t\t\tchar invoke_dir[MAX_PATH];\n\t\t\t\t\t\tif (r_sys_get_src_dir_w32(invoke_dir)) {\n\t\t\t\t\t\t\tfilename = sdb_fmt (1, \"%s/share/radare2/\"R2_VERSION \"/format/dll/%s.sdb\", invoke_dir, module);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfilename = sdb_fmt (1, \"share/radare2/\"R2_VERSION\"/format/dll/%s.sdb\", module);\n\t\t\t\t\t\t}\n#else\n\t\t\t\t\t\tfilename = sdb_fmt (1, R2_PREFIX\"/share/radare2/\" R2_VERSION\"/format/dll/%s.sdb\", module);\n#endif\n\t\t\t\t\t\tif (r_file_exists (filename)) {\n\t\t\t\t\t\t\t*db = sdb_new (NULL, filename, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (*db) {\n\t\t\t\t\t// ordinal-1 because we enumerate starting at 0\n\t\t\t\t\tchar *symname = resolveModuleOrdinal (*db, module, ordinal - 1);\n\t\t\t\t\tif (symname) {\n\t\t\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\t\t\treloc->import->name = r_str_newf\n\t\t\t\t\t\t\t\t(\"%s.%s.%s\", r->bin->prefix, module, symname);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treloc->import->name = r_str_newf\n\t\t\t\t\t\t\t\t(\"%s.%s\", module, symname);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (module);\n\t\t\tr_anal_hint_set_size (r->anal, reloc->vaddr, 4);\n\t\t\tr_meta_add (r->anal, R_META_TYPE_DATA, reloc->vaddr, reloc->vaddr+4, NULL);\n\t\t}\n\t\treloc_name = reloc->import->name;\n\t\tif (r->bin->prefix) {\n\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"%s.reloc.%s_%d\", r->bin->prefix, reloc_name, (int)(addr&0xff));\n\t\t} else {\n\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"reloc.%s_%d\", reloc_name, (int)(addr&0xff));\n\t\t}\n\t\tif (bin_demangle) {\n\t\t\tdemname = r_bin_demangle (r->bin->cur, lang, str, addr);\n\t\t}\n\t\tr_name_filter (str, 0);\n\t\tfi = r_flag_set (r->flags, str, addr, bin_reloc_size (reloc));\n\t\tif (demname) {\n\t\t\tchar *realname;\n\t\t\tif (r->bin->prefix) {\n\t\t\t\trealname = sdb_fmt (0, \"%s.reloc.%s\", r->bin->prefix, demname);\n\t\t\t} else {\n\t\t\t\trealname = sdb_fmt (0, \"reloc.%s\", demname);\n\t\t\t}\n\t\t\tr_flag_item_set_realname (fi, realname);\n\t\t}\n\t} else {\n\t\tchar *reloc_name = get_reloc_name (reloc, addr);\n\t\tr_flag_set (r->flags, reloc_name, addr, bin_reloc_size (reloc));\n\t}\n}\n\nstatic int bin_relocs(RCore *r, int mode, int va) {\n\tint bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tRList *relocs;\n\tRListIter *iter;\n\tRBinReloc *reloc = NULL;\n\tSdb *db = NULL;\n\tchar *sdb_module = NULL;\n\tint i = 0;\n\n\tva = VA_TRUE; // XXX relocs always vaddr?\n\t//this has been created for reloc object files\n\trelocs = r_bin_patch_relocs (r->bin);\n\tif (!relocs) {\n\t\trelocs = r_bin_get_relocs (r->bin);\n\t}\n\n\tif (IS_MODE_RAD (mode)) {\n\t\tr_cons_println (\"fs relocs\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_println (\"[Relocations]\");\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"[\");\n\t} else if (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, \"relocs\");\n\t}\n\tRBinFile * binfile = r->bin->cur;\n\tRBinObject *binobj = binfile ? binfile->o: NULL;\n\tRBinInfo *info = binobj ? binobj->info: NULL;\n\tint cdsz = info? (info->bits == 64? 8: info->bits == 32? 4: info->bits == 16 ? 4: 0): 0;\n\tr_list_foreach (relocs, iter, reloc) {\n\t\tut64 addr = rva (r->bin, reloc->paddr, reloc->vaddr, va);\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\tset_bin_relocs (r, reloc, addr, &db, &sdb_module);\n\t\t\tif (cdsz) {\n\t\t\t\tr_meta_add (r->anal, R_META_TYPE_DATA, reloc->vaddr, reloc->vaddr + cdsz, NULL);\n\t\t\t}\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"  %s\\n\", addr, reloc->import ? reloc->import->name : \"\");\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tchar *name = reloc->import\n\t\t\t\t? strdup (reloc->import->name)\n\t\t\t\t: (reloc->symbol ? strdup (reloc->symbol->name) : NULL);\n\t\t\tif (name && bin_demangle) {\n\t\t\t\tchar *mn = r_bin_demangle (r->bin->cur, NULL, name, addr);\n\t\t\t\tif (mn) {\n\t\t\t\t\tfree (name);\n\t\t\t\t\tname = mn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (name) {\n\t\t\t\tr_cons_printf (\"f %s%s%s @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\tr->bin->prefix ? r->bin->prefix : \"reloc.\",\n\t\t\t\t\tr->bin->prefix ? \".\" : \"\", name, addr);\n\t\t\t\tif (cdsz) {\n\t\t\t\t\tr_cons_printf (\"f Cd %d @ 0x%08\"PFMT64x\"\\n\", cdsz, addr);\n\t\t\t\t}\n\t\t\t\tfree (name);\n\t\t\t}\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tif (iter->p) {\n\t\t\t\tr_cons_printf (\",{\\\"name\\\":\");\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"{\\\"name\\\":\");\n\t\t\t}\n\t\t\t// take care with very long symbol names! do not use sdb_fmt or similar\n\t\t\tif (reloc->import) {\n\t\t\t\tr_cons_printf (\"\\\"%s\\\"\", reloc->import->name);\n\t\t\t} else if (reloc->symbol) {\n\t\t\t\tr_cons_printf (\"\\\"%s\\\"\", reloc->symbol->name);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"null\");\n\t\t\t}\n\n\t\t\tr_cons_printf (\",\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"paddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"is_ifunc\\\":%s}\",\n\t\t\t\tbin_reloc_type_name (reloc),\n\t\t\t\treloc->vaddr, reloc->paddr,\n\t\t\t\tr_str_bool (reloc->is_ifunc));\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tchar *name = reloc->import\n\t\t\t\t? strdup (reloc->import->name)\n\t\t\t\t: reloc->symbol\n\t\t\t\t? strdup (reloc->symbol->name)\n\t\t\t\t: strdup (\"null\");\n\t\t\tif (bin_demangle) {\n\t\t\t\tchar *mn = r_bin_demangle (r->bin->cur, NULL, name, addr);\n\t\t\t\tif (mn && *mn) {\n\t\t\t\t\tfree (name);\n\t\t\t\t\tname = mn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_cons_printf (\"vaddr=0x%08\"PFMT64x\" paddr=0x%08\"PFMT64x\" type=%s\",\n\t\t\t\taddr, reloc->paddr, bin_reloc_type_name (reloc));\n\t\t\tif (reloc->import && reloc->import->name[0]) {\n\t\t\t\tr_cons_printf (\" %s\", name);\n\t\t\t} else if (reloc->symbol && name && name[0]) {\n\t\t\t\tr_cons_printf (\" %s\", name);\n\t\t\t}\n\t\t\tfree (name);\n\t\t\tif (reloc->addend) {\n\t\t\t\tif (reloc->import && reloc->addend > 0) {\n\t\t\t\t\tr_cons_printf (\" +\");\n\t\t\t\t}\n\t\t\t\tif (reloc->addend < 0) {\n\t\t\t\t\tr_cons_printf (\" - 0x%08\"PFMT64x, -reloc->addend);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\" 0x%08\"PFMT64x, reloc->addend);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (reloc->is_ifunc) {\n\t\t\t\tr_cons_print (\" (ifunc)\");\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t}\n\t\ti++;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"]\");\n\t}\n\tif (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"\\n%i relocations\\n\", i);\n\t}\n\treturn relocs != NULL;\n}\n\n#define MYDB 1\n/* this is a hacky workaround that needs proper refactoring in Rbin to use Sdb */\n#if MYDB\nstatic Sdb *mydb = NULL;\nstatic RList *osymbols = NULL;\n\nstatic RBinSymbol *get_symbol(RBin *bin, RList *symbols, const char *name, ut64 addr) {\n\tRBinSymbol *symbol, *res = NULL;\n\tRListIter *iter;\n\tif (mydb && symbols != osymbols) {\n\t\tsdb_free (mydb);\n\t\tmydb = NULL;\n\t\tosymbols = symbols;\n\t}\n\tif (mydb) {\n\t\tif (name) {\n\t\t\tres = (RBinSymbol*)(void*)(size_t)\n\t\t\t\tsdb_num_get (mydb, sdb_fmt (0, \"%x\", sdb_hash (name)), NULL);\n\t\t} else {\n\t\t\tres = (RBinSymbol*)(void*)(size_t)\n\t\t\t\tsdb_num_get (mydb, sdb_fmt (0, \"0x\"PFMT64x, addr), NULL);\n\t\t}\n\t} else {\n\t\tmydb = sdb_new0 ();\n\t\tr_list_foreach (symbols, iter, symbol) {\n\t\t\t/* ${name}=${ptrToSymbol} */\n\t\t\tif (!sdb_num_add (mydb, sdb_fmt (0, \"%x\", sdb_hash (symbol->name)), (ut64)(size_t)symbol, 0)) {\n\t\t\t//\teprintf (\"DUP (%s)\\n\", symbol->name);\n\t\t\t}\n\t\t\t/* 0x${vaddr}=${ptrToSymbol} */\n\t\t\tif (!sdb_num_add (mydb, sdb_fmt (0, \"0x\"PFMT64x, symbol->vaddr), (ut64)(size_t)symbol, 0)) {\n\t\t\t//\teprintf (\"DUP (%s)\\n\", symbol->name);\n\t\t\t}\n\t\t\tif (name) {\n\t\t\t\tif (!res && !strcmp (symbol->name, name)) {\n\t\t\t\t\tres = symbol;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (symbol->vaddr == addr) {\n\t\t\t\t\tres = symbol;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n#else\nstatic RList *osymbols = NULL;\nstatic RBinSymbol *get_symbol(RBin *bin, RList *symbols, const char *name, ut64 addr) {\n\tRBinSymbol *symbol;\n\tRListIter *iter;\n\tr_list_foreach (symbols, iter, symbol) {\n\t\tif (name) {\n\t\t\tif (!strcmp (symbol->name, name))\n\t\t\t\treturn symbol;\n\t\t} else {\n\t\t\tif (symbol->vaddr == addr) {\n\t\t\t\treturn symbol;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n#endif\n\n/* XXX: This is a hack to get PLT references in rabin2 -i */\n/* imp. is a prefix that can be rewritten by the symbol table */\nstatic ut64 impaddr(RBin *bin, int va, const char *name) {\n\tchar *impname;\n\tRList *symbols;\n\tRBinSymbol *s;\n\n\tif (!name || !*name) {\n\t\treturn false;\n\t}\n\tif (!(symbols = r_bin_get_symbols (bin))) {\n\t\treturn false;\n\t}\n\timpname = sdb_fmt (2, \"imp.%s\", name);\n\ts = get_symbol (bin, symbols, impname, 0LL);\n\tif (s) {\n\t\tif (va) {\n\t\t\treturn r_bin_get_vaddr (bin, s->paddr, s->vaddr);\n\t\t}\n\t\treturn s->paddr;\n\t}\n\treturn 0LL;\n}\n\nstatic int bin_imports(RCore *r, int mode, int va, const char *name) {\n\tint bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tRBinImport *import;\n\tRListIter *iter;\n\tRList *imports;\n\tchar *str;\n\tint i = 0;\n\n\timports = r_bin_get_imports (r->bin);\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"[\");\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_println (\"fs imports\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_println (\"[Imports]\");\n\t}\n\tr_list_foreach (imports, iter, import) {\n\t\tchar *symname;\n\t\tut64 addr;\n\t\tif (name && strcmp (import->name, name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tsymname = strdup (import->name);\n\t\taddr = impaddr (r->bin, va, symname);\n\t\tif (bin_demangle) {\n\t\t\tchar *dname = r_bin_demangle (r->bin->cur, NULL, symname, addr);\n\t\t\tif (dname) {\n\t\t\t\tfree (symname);\n\t\t\t\tsymname = r_str_newf (\"sym.imp.%s\", dname);\n\t\t\t\tfree (dname);\n\t\t\t}\n\t\t}\n\t\tif (r->bin->prefix) {\n\t\t\tchar *prname;\n\t\t\tprname = r_str_newf (\"%s.%s\", r->bin->prefix, symname);\n\t\t\tfree (symname);\n\t\t\tsymname = prname;\n\t\t}\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\t// TODO(eddyb) symbols that are imports.\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tr_cons_println (symname);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tstr = r_str_utf16_encode (symname, -1);\n\t\t\tstr = r_str_replace (str, \"\\\"\", \"\\\\\\\"\", 1);\n\t\t\tr_cons_printf (\"%s{\\\"ordinal\\\":%d,\"\n\t\t\t\t\"\\\"bind\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\",\n\t\t\t\titer->p ? \",\" : \"\",\n\t\t\t\timport->ordinal,\n\t\t\t\timport->bind,\n\t\t\t\timport->type);\n\t\t\tif (import->classname && import->classname[0]) {\n\t\t\t\tr_cons_printf (\"\\\"classname\\\":\\\"%s\\\",\"\n\t\t\t\t\t\"\\\"descriptor\\\":\\\"%s\\\",\",\n\t\t\t\t\timport->classname,\n\t\t\t\t\timport->descriptor);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"name\\\":\\\"%s\\\",\\\"plt\\\":%\"PFMT64d\"}\",\n\t\t\t\tstr, addr);\n\t\t\tfree (str);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\t// TODO(eddyb) symbols that are imports.\n\t\t} else {\n\t\t\tconst char *bind = r_str_get (import->bind);\n\t\t\tconst char *type = r_str_get (import->type);\n\t\t\tr_cons_printf (\"ordinal=%03d plt=0x%08\"PFMT64x\" bind=%s type=%s\",\n\t\t\t\timport->ordinal, addr, bind, type);\n\t\t\tif (import->classname && import->classname[0]) {\n\t\t\t\tr_cons_printf (\" classname=%s\", import->classname);\n\t\t\t}\n\t\t\tr_cons_printf (\" name=%s\", symname);\n\t\t\tif (import->descriptor && import->descriptor[0]) {\n\t\t\t\tr_cons_printf (\" descriptor=%s\", import->descriptor);\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t}\n\t\tfree (symname);\n\t\ti++;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"]\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"\\n%i imports\\n\", i);\n\t}\n#if MYDB\n\tosymbols = NULL;\n\tsdb_free (mydb);\n\tmydb = NULL;\n#endif\n\treturn true;\n}\n\nstatic const char *getPrefixFor(const char *s) {\n\tif (s) {\n\t\tif (!strcmp (s, \"NOTYPE\")) {\n\t\t\treturn \"loc\";\n\t\t}\n\t\tif (!strcmp (s, \"OBJECT\")) {\n\t\t\treturn \"obj\";\n\t\t}\n\t}\n\treturn \"sym\";\n}\n\ntypedef struct {\n\tconst char *pfx; // prefix for flags\n\tchar *name;      // raw symbol name\n\tchar *nameflag;  // flag name for symbol\n\tchar *demname;   // demangled raw symbol name\n\tchar *demflag;   // flag name for demangled symbol\n\tchar *classname; // classname\n\tchar *classflag; // flag for classname\n\tchar *methname;  // methods [class]::[method]\n\tchar *methflag;  // methods flag sym.[class].[method]\n} SymName;\n\nstatic void snInit(RCore *r, SymName *sn, RBinSymbol *sym, const char *lang) {\n#define MAXFLAG_LEN 128\n\tint bin_demangle = lang != NULL;\n\tconst char *pfx;\n\tif (!r || !sym || !sym->name) return;\n\tpfx = getPrefixFor (sym->type);\n\tsn->name = strdup (sym->name);\n\tif (sym->dup_count) {\n\t\tsn->nameflag = r_str_newf (\"%s.%s_%d\", pfx, sym->name, sym->dup_count);\n\t} else {\n\t\tsn->nameflag = r_str_newf (\"%s.%s\", pfx, sym->name);\n\t}\n\tr_name_filter (sn->nameflag, MAXFLAG_LEN);\n\tif (sym->classname && sym->classname[0]) {\n\t\tsn->classname = strdup (sym->classname);\n\t\tsn->classflag = r_str_newf (\"sym.%s.%s\", sn->classname, sn->name);\n\t\tr_name_filter (sn->classflag, MAXFLAG_LEN);\n\t\tconst char *name = sym->dname? sym->dname: sym->name;\n\t\tsn->methname = r_str_newf (\"%s::%s\", sn->classname, name);\n\t\tsn->methflag = r_str_newf (\"sym.%s.%s\", sn->classname, name);\n\t\tr_name_filter (sn->methflag, strlen (sn->methflag));\n\t} else {\n\t\tsn->classname = NULL;\n\t\tsn->classflag = NULL;\n\t\tsn->methname = NULL;\n\t\tsn->methflag = NULL;\n\t}\n\tsn->demname = NULL;\n\tsn->demflag = NULL;\n\tif (bin_demangle && sym->paddr) {\n\t\tsn->demname = r_bin_demangle (r->bin->cur, lang, sn->name, sym->vaddr);\n\t\tif (sn->demname) {\n\t\t\tsn->demflag = r_str_newf (\"%s.%s\", pfx, sn->demname);\n\t\t\tr_name_filter (sn->demflag, -1);\n\t\t}\n\t}\n}\n\nstatic void snFini(SymName *sn) {\n\tR_FREE (sn->name);\n\tR_FREE (sn->nameflag);\n\tR_FREE (sn->demname);\n\tR_FREE (sn->demflag);\n\tR_FREE (sn->classname);\n\tR_FREE (sn->classflag);\n\tR_FREE (sn->methname);\n\tR_FREE (sn->methflag);\n}\n\n\nstatic bool isAnExport(RBinSymbol *s) {\n\t/* workaround for some bin plugs */\n\tif (!strncmp (s->name, \"imp.\", 4)) {\n\t\treturn false;\n\t}\n\treturn (s->bind && !strcmp (s->bind, \"GLOBAL\"));\n}\n\nstatic int bin_symbols_internal(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, bool exponly) {\n\tRBinInfo *info = r_bin_get_info (r->bin);\n\tRList *entries = r_bin_get_entries (r->bin);\n\tRBinSymbol *symbol;\n\tRBinAddr *entry;\n\tRListIter *iter;\n\tRList *symbols;\n\tconst char *lang;\n\tbool firstexp = true;\n\tint i = 0, is_arm, lastfs = 's',\n\t    bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tif (!info) {\n\t\treturn 0;\n\t}\n\tis_arm = info && info->arch && !strncmp (info->arch, \"arm\", 3);\n\tlang = bin_demangle ? r_config_get (r->config, \"bin.lang\") : NULL;\n\n\tsymbols = r_bin_get_symbols (r->bin);\n\tr_space_set (&r->anal->meta_spaces, \"bin\");\n\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"[\");\n\t} else if (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, \"symbols\");\n\t} else if (!at && exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs exports\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (\"[Exports]\\n\");\n\t\t}\n\t} else if (!at && !exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs symbols\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (\"[Symbols]\\n\");\n\t\t}\n\t}\n\n\tr_list_foreach (symbols, iter, symbol) {\n\t\tut64 addr = rva (r->bin, symbol->paddr, symbol->vaddr, va);\n\t\tSymName sn;\n\n\t\tif (exponly && !isAnExport (symbol)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (name && strcmp (symbol->name, name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (at && (!symbol->size || !is_in_range (at, addr, symbol->size))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tsnInit (r, &sn, symbol, lang);\n\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\tif (is_arm && info->bits < 33) { // 16 or 32\n\t\t\t\tint force_bits = 0;\n\t\t\t\tif (symbol->paddr & 1 || symbol->bits == 16) {\n\t\t\t\t\tforce_bits = 16;\n\t\t\t\t} else if (info->bits == 16 && symbol->bits == 32) {\n\t\t\t\t\tforce_bits = 32;\n\t\t\t\t} else if (!(symbol->paddr & 1) && symbol->bits == 32) {\n\t\t\t\t\tforce_bits = 32;\n\t\t\t\t}\n\t\t\t\tif (force_bits) {\n\t\t\t\t\tr_anal_hint_set_bits (r->anal, addr, force_bits);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!strncmp (symbol->name, \"imp.\", 4)) {\n\t\t\t\tif (lastfs != 'i') {\n\t\t\t\t\tr_flag_space_set (r->flags, \"imports\");\n\t\t\t\t}\n\t\t\t\tlastfs = 'i';\n\t\t\t} else {\n\t\t\t\tif (lastfs != 's') {\n\t\t\t\t\tr_flag_space_set (r->flags, \"symbols\");\n\t\t\t\t}\n\t\t\t\tlastfs = 's';\n\t\t\t}\n\t\t\t/* If that's a Classed symbol (method or so) */\n\t\t\tif (sn.classname) {\n\t\t\t\tRFlagItem *fi = NULL;\n\t\t\t\tchar *comment = NULL;\n\t\t\t\tfi = r_flag_get (r->flags, sn.methflag);\n\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\tchar *prname;\n\t\t\t\t\tprname = r_str_newf (\"%s.%s\", r->bin->prefix, sn.methflag);\n\t\t\t\t\tr_name_filter (sn.methflag, -1);\n\t\t\t\t\tfree (sn.methflag);\n\t\t\t\t\tsn.methflag = prname;\n\t\t\t\t}\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, sn.methname);\n\t\t\t\t\tif ((fi->offset - r->flags->base) == addr) {\n\t\t\t\t\t\tcomment = fi->comment ? strdup (fi->comment) : NULL;\n\t\t\t\t\t\tr_flag_unset (r->flags, fi);\n\t\t\t\t\t\tfi = NULL;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfi = r_flag_set (r->flags, sn.methflag, addr, symbol->size);\n\t\t\t\t\tcomment = fi->comment ? strdup (fi->comment) : NULL;\n\t\t\t\t\tif (comment) {\n\t\t\t\t\t\tr_flag_item_set_comment (fi, comment);\n\t\t\t\t\t\tR_FREE (comment);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst char *fn, *n;\n\t\t\t\tRFlagItem *fi;\n\t\t\t\tn = sn.demname ? sn.demname : sn.name;\n\t\t\t\tfn = sn.demflag ? sn.demflag : sn.nameflag;\n\t\t\t\tchar *fnp = (r->bin->prefix) ?\n\t\t\t\t\tr_str_newf (\"%s.%s\", r->bin->prefix, fn):\n\t\t\t\t\tstrdup (fn);\n\t\t\t\tfi = r_flag_set (r->flags, fnp, addr, symbol->size);\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, n);\n\t\t\t\t} else {\n\t\t\t\t\tif (fn) {\n\t\t\t\t\t\teprintf (\"[Warning] Can't find flag (%s)\\n\", fn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (fnp);\n\t\t\t}\n\t\t\tif (sn.demname) {\n\t\t\t\tr_meta_add (r->anal, R_META_TYPE_COMMENT,\n\t\t\t\t\taddr, symbol->size, sn.demname);\n\t\t\t}\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tchar *str = r_str_utf16_encode (symbol->name, -1);\n\t\t\tstr = r_str_replace (str, \"\\\"\", \"\\\\\\\"\", 1);\n\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"demname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"flagname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"size\\\":%d,\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"paddr\\\":%\"PFMT64d\"}\",\n\t\t\t\t(exponly && firstexp) ? \"\" : (iter->p ? \",\" : \"\"), str,\n\t\t\t\tsn.demname? sn.demname: \"\",\n\t\t\t\tsn.nameflag,\n\t\t\t\t(int)symbol->size,\n\t\t\t\tsymbol->type,\n\t\t\t\t(ut64)addr, (ut64)symbol->paddr);\n\t\t\tfree (str);\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: symbol->name;\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" %d %s\\n\",\n\t\t\t\taddr, (int)symbol->size, name);\n\t\t} else if (IS_MODE_SIMPLEST (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: symbol->name;\n\t\t\tr_cons_printf (\"%s\\n\", name);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tRBinFile *binfile;\n\t\t\tRBinPlugin *plugin;\n\t\t\tchar *name = strdup (sn.demname? sn.demname: symbol->name);\n\t\t\tr_name_filter (name, -1);\n\t\t\tif (!strncmp (name, \"imp.\", 4)) {\n\t\t\t\tif (lastfs != 'i')\n\t\t\t\t\tr_cons_printf (\"fs imports\\n\");\n\t\t\t\tlastfs = 'i';\n\t\t\t} else {\n\t\t\t\tif (lastfs != 's') {\n\t\t\t\t\tr_cons_printf (\"fs %s\\n\",\n\t\t\t\t\t\texponly? \"exports\": \"symbols\");\n\t\t\t\t}\n\t\t\t\tlastfs = 's';\n\t\t\t}\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tif (symbol->dup_count) {\n\t\t\t\t\tr_cons_printf (\"f %s.sym.%s_%d %u 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\tr->bin->prefix, name, symbol->dup_count, symbol->size, addr);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"f %s.sym.%s %u 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\tr->bin->prefix, name, symbol->size, addr);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (symbol->dup_count) {\n\t\t\t\t\tr_cons_printf (\"f sym.%s_%d %u 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\tname, symbol->dup_count, symbol->size, addr);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"f sym.%s %u 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\tname, symbol->size, addr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbinfile = r_core_bin_cur (r);\n\t\t\tplugin = r_bin_file_cur_plugin (binfile);\n\t\t\tif (plugin && plugin->name) {\n\t\t\t\tif (!strncmp (plugin->name, \"pe\", 2)) {\n\t\t\t\t\tchar *p, *module = strdup (symbol->name);\n\t\t\t\t\tp = strstr (module, \".dll_\");\n\t\t\t\t\tif (p) {\n\t\t\t\t\t\tconst char *symname = p + 5;\n\t\t\t\t\t\t*p = 0;\n\t\t\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s.%s\\n\",\n\t\t\t\t\t\t\t\tmodule, symbol->ordinal, r->bin->prefix, symname);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s\\n\",\n\t\t\t\t\t\t\t\tmodule, symbol->ordinal, symname);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree (module);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *bind = symbol->bind;\n\t\t\tconst char *type = symbol->type;\n\t\t\tconst char *name = sn.demname? sn.demname: symbol->name;\n\t\t\tconst char *fwd = symbol->forwarder;\n\t\t\tif (!bind) bind = \"\";\n\t\t\tif (!type) type = \"\";\n\t\t\tif (!fwd) fwd = \"\";\n\t\t\tr_cons_printf (\"vaddr=0x%08\"PFMT64x\" paddr=0x%08\"PFMT64x\" ord=%03u \"\n\t\t\t\t\"fwd=%s sz=%u bind=%s type=%s name=%s\\n\",\n\t\t\t\taddr, symbol->paddr, symbol->ordinal, fwd,\n\t\t\t\tsymbol->size, bind, type, name);\n\t\t}\n\t\tsnFini (&sn);\n\t\ti++;\n\t\tif (exponly && firstexp) {\n\t\t\tfirstexp = false;\n\t\t}\n\t}\n\n\t//handle thumb and arm for entry point since they are not present in symbols\n\tif (is_arm) {\n\t\tr_list_foreach (entries, iter, entry) {\n\t\t\tif (IS_MODE_SET (mode)) {\n\t\t\t\tif (info->bits < 33) { // 16 or 32\n\t\t\t\t\tint force_bits = 0;\n\t\t\t\t\tut64 addr = rva (r->bin, entry->paddr, entry->vaddr, va);\n\t\t\t\t\tif (entry->paddr & 1 || entry->bits == 16) {\n\t\t\t\t\t\tforce_bits = 16;\n\t\t\t\t\t} else if (info->bits == 16 && entry->bits == 32) {\n\t\t\t\t\t\tforce_bits = 32;\n\t\t\t\t\t} else if (!(entry->paddr & 1)) {\n\t\t\t\t\t\tforce_bits = 32;\n\t\t\t\t\t}\n\t\t\t\t\tif (force_bits) {\n\t\t\t\t\t\tr_anal_hint_set_bits (r->anal, addr, force_bits);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (IS_MODE_JSON (mode)) r_cons_printf (\"]\");\n\tif (IS_MODE_NORMAL (mode) && !at) {\n\t\tr_cons_printf (\"\\n%i %s\\n\", i, exponly ? \"exports\" : \"symbols\");\n\t}\n\n\tr_space_set (&r->anal->meta_spaces, NULL);\n\treturn true;\n}\n\nstatic int bin_exports(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name) {\n\treturn bin_symbols_internal (r, mode, laddr, va, at, name, true);\n}\n\nstatic int bin_symbols(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name) {\n\treturn bin_symbols_internal (r, mode, laddr, va, at, name, false);\n}\n\nstatic char *build_hash_string(int mode, const char *chksum, ut8 *data, ut32 datalen) {\n\tchar *chkstr = NULL, *aux, *ret = NULL;\n\tconst char *ptr = chksum;\n\tchar tmp[128];\n\tint i;\n\tdo {\n\t\tfor (i = 0; *ptr && *ptr != ',' && i < sizeof (tmp) -1; i++) {\n\t\t\ttmp[i] = *ptr++;\n\t\t}\n\t\ttmp[i] = '\\0';\n\t\tchkstr = r_hash_to_string (NULL, tmp, data, datalen);\n\t\tif (!chkstr) {\n\t\t\tif (*ptr && *ptr == ',') {\n\t\t\t\tptr++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (IS_MODE_SIMPLE (mode)) {\n\t\t\taux = r_str_newf (\"%s \", chkstr);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\taux = r_str_newf (\"\\\"%s\\\":\\\"%s\\\",\", tmp, chkstr);\n\t\t} else {\n\t\t\taux = r_str_newf (\"%s=%s \", tmp, chkstr);\n\t\t}\n\t\tret = r_str_append (ret, aux);\n\t\tfree (chkstr);\n\t\tfree (aux);\n\t\tif (*ptr && *ptr == ',') ptr++;\n\t} while (*ptr);\n\n\treturn ret;\n}\n\nstatic int bin_sections(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, const char *chksum) {\n\tchar str[R_FLAG_NAME_SIZE];\n\tRBinSection *section;\n\tRBinInfo *info = NULL;\n\tRList *sections;\n\tRListIter *iter;\n\tint i = 0;\n\tint fd = -1;\n\tsections = r_bin_get_sections (r->bin);\n\tbool inDebugger = r_config_get_i (r->config, \"cfg.debug\");\n\n\tif (IS_MODE_JSON (mode)) r_cons_printf (\"[\");\n\telse if (IS_MODE_RAD (mode) && !at) r_cons_printf (\"fs sections\\n\");\n\telse if (IS_MODE_NORMAL (mode) && !at) r_cons_printf (\"[Sections]\\n\");\n\telse if (IS_MODE_SET (mode)) {\n\t\tfd = r_core_file_cur_fd (r);\n\t\tr_flag_space_set (r->flags, \"sections\");\n\t}\n\tr_list_foreach (sections, iter, section) {\n\t\tchar perms[] = \"-----\";\n\t\tint va_sect = va;\n\t\tut64 addr;\n\n\t\tif (va && !(section->srwx & R_BIN_SCN_READABLE)) {\n\t\t\tva_sect = VA_NOREBASE;\n\t\t}\n\t\taddr = rva (r->bin, section->paddr, section->vaddr, va_sect);\n\n\t\tif (name && strcmp (section->name, name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tr_name_filter (section->name, sizeof (section->name));\n\t\tif (at && (!section->size || !is_in_range (at, addr, section->size))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (section->srwx & R_BIN_SCN_MAP) perms[0] = 'm';\n\t\tif (section->srwx & R_BIN_SCN_SHAREABLE) perms[1] = 's';\n\t\tif (section->srwx & R_BIN_SCN_READABLE) perms[2] = 'r';\n\t\tif (section->srwx & R_BIN_SCN_WRITABLE) perms[3] = 'w';\n\t\tif (section->srwx & R_BIN_SCN_EXECUTABLE) perms[4] = 'x';\n\n\t\tif (IS_MODE_SET (mode)) {\n#if LOAD_BSS_MALLOC\n\t\t\tif (!strcmp (section->name, \".bss\")) {\n\t\t\t\t// check if there's already a file opened there\n\t\t\t\tint loaded = 0;\n\t\t\t\tRListIter *iter;\n\t\t\t\tRIOMap *m;\n\t\t\t\tr_list_foreach (r->io->maps, iter, m) {\n\t\t\t\t\tif (m->from == addr) {\n\t\t\t\t\t\tloaded = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!loaded && !inDebugger) {\n\t\t\t\t\tr_core_cmdf (r, \"on malloc://%d 0x%\"PFMT64x\" # bss\\n\",\n\t\t\t\t\t\tsection->vsize, addr);\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tr_name_filter (section->name, 128);\n\t\t\tif (section->format) {\n\t\t\t\t// This is damn slow if section vsize is HUGE\n\t\t\t\tif (section->vsize < 1024 * 1024 * 2) {\n\t\t\t\t\tr_core_cmdf (r, \"%s @ 0x%\"PFMT64x, section->format, section->vaddr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tsnprintf (str, sizeof(str)-1, \"%s.section.%s\",\n\t\t\t\t\tr->bin->prefix, section->name);\n\t\t\t} else {\n\t\t\t\tsnprintf (str, sizeof(str)-1, \"section.%s\", section->name);\n\n\t\t\t}\n\t\t\tr_flag_set (r->flags, str, addr, section->size);\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tsnprintf (str, sizeof(str) - 1, \"%s.section_end.%s\",\n\t\t\t\t\tr->bin->prefix, section->name);\n\t\t\t} else {\n\t\t\t\tsnprintf (str, sizeof(str) - 1, \"section_end.%s\", section->name);\n\t\t\t}\n\n\t\t\tr_flag_set (r->flags, str, addr + section->size, 0);\n\t\t\tif (section->arch || section->bits) {\n\t\t\t\tconst char *arch = section->arch;\n\t\t\t\tint bits = section->bits;\n\t\t\t\tif (info) {\n\t\t\t\t\tif (!arch) {\n\t\t\t\t\t\tarch = info->arch;\n\t\t\t\t\t}\n\t\t\t\t\tif (!bits) {\n\t\t\t\t\t\tbits = info->bits;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//r_io_section_set_archbits (r->io, addr, arch, bits);\n\t\t\t}\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tsnprintf (str, sizeof (str)-1, \"section %i va=0x%08\"PFMT64x\" pa=0x%08\"\n\t\t\t\t\tPFMT64x\" sz=%\" PFMT64d\" vsz=%\"PFMT64d\" rwx=%s %s.%s\",\n\t\t\t\t\ti, addr, section->paddr, section->size, section->vsize,\n\t\t\t\t\tperms, r->bin->prefix, section->name);\n\t\t\t} else {\n\t\t\t\tsnprintf (str, sizeof (str)-1, \"section %i va=0x%08\"PFMT64x\" pa=0x%08\"\n\t\t\t\t\tPFMT64x\" sz=%\" PFMT64d\" vsz=%\"PFMT64d\" rwx=%s %s\",\n\t\t\t\t\ti, addr, section->paddr, section->size, section->vsize,\n\t\t\t\t\tperms, section->name);\n\n\t\t\t}\n\t\t\tr_meta_add (r->anal, R_META_TYPE_COMMENT, addr, addr, str);\n\t\t\tif (section->add) {\n\t\t\t\tr_io_section_add (r->io, section->paddr, addr,\n\t\t\t\t\t\t  section->size, section->vsize,\n\t\t\t\t\t\t  section->srwx, section->name,\n\t\t\t\t\t\t  0, fd);\n\t\t\t}\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tchar *hashstr = NULL;\n\t\t\tif (chksum) {\n\t\t\t\tut8 *data = malloc (section->size);\n\t\t\t\tif (!data) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tut32 datalen = section->size;\n\t\t\t\tr_io_pread (r->io, section->paddr, data, datalen);\n\t\t\t\thashstr = build_hash_string (mode, chksum,\n\t\t\t\t\t\t\tdata, datalen);\n\t\t\t\tfree (data);\n\t\t\t}\n\t\t\tr_cons_printf (\"0x%\"PFMT64x\" 0x%\"PFMT64x\" %s %s%s%s\\n\",\n\t\t\t\taddr, addr + section->size,\n\t\t\t\tperms,\n\t\t\t\thashstr ? hashstr : \"\", hashstr ? \" \" : \"\",\n\t\t\t\tsection->name\n\t\t\t);\n\t\t\tfree (hashstr);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tchar *hashstr = NULL;\n\t\t\tif (chksum) {\n\t\t\t\tut8 *data = malloc (section->size);\n\t\t\t\tif (!data) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tut32 datalen = section->size;\n\t\t\t\tr_io_pread (r->io, section->paddr, data, datalen);\n\t\t\t\thashstr = build_hash_string (mode, chksum,\n\t\t\t\t\t\t\tdata, datalen);\n\t\t\t\tfree (data);\n\n\t\t\t}\n\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"size\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"vsize\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"flags\\\":\\\"%s\\\",\"\n\t\t\t\t\"%s\"\n\t\t\t\t\"\\\"paddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\"}\",\n\t\t\t\titer->p?\",\":\"\",\n\t\t\t\tsection->name,\n\t\t\t\tsection->size,\n\t\t\t\tsection->vsize,\n\t\t\t\tperms,\n\t\t\t\thashstr ? hashstr : \"\",\n\t\t\t\tsection->paddr,\n\t\t\t\taddr);\n\t\t\tfree (hashstr);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tif (!strcmp (section->name, \".bss\") && !inDebugger) {\n#if LOAD_BSS_MALLOC\n\t\t\t\tr_cons_printf (\"on malloc://%d 0x%\"PFMT64x\" # bss\\n\",\n\t\t\t\t\t\tsection->vsize, addr);\n#endif\n\t\t\t}\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tr_cons_printf (\"S 0x%08\"PFMT64x\" 0x%08\"PFMT64x\" 0x%08\"PFMT64x\" 0x%08\"PFMT64x\" %s.%s %d\\n\",\n\t\t\t\t\tsection->paddr, addr, section->size, section->vsize,\n\t\t\t\t\tr->bin->prefix, section->name, (int)section->srwx);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"S 0x%08\"PFMT64x\" 0x%08\"PFMT64x\" 0x%08\"PFMT64x\" 0x%08\"PFMT64x\" %s %d\\n\",\n\t\t\t\t\tsection->paddr, addr, section->size, section->vsize,\n\t\t\t\t\tsection->name, (int)section->srwx);\n\n\t\t\t}\n\t\t\tif (section->arch || section->bits) {\n\t\t\t\tconst char *arch = section->arch;\n\t\t\t\tint bits = section->bits;\n\t\t\t\tif (info) {\n\t\t\t\t\tif (!arch) arch = info->arch;\n\t\t\t\t\tif (!bits) bits = info->bits;\n\t\t\t\t}\n\t\t\t\tif (!arch) {\n\t\t\t\t\tarch = r_config_get (r->config, \"asm.arch\");\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"Sa %s %d @ 0x%08\"\n\t\t\t\t\tPFMT64x\"\\n\", arch, bits, addr);\n\t\t\t}\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tr_cons_printf (\"f %s.section.%s %\"PFMT64d\" 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\tr->bin->prefix, section->name, section->size, addr);\n\t\t\t\tr_cons_printf (\"f %s.section_end.%s 1 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\tr->bin->prefix, section->name, addr + section->size);\n\t\t\t\tr_cons_printf (\"CC section %i va=0x%08\"PFMT64x\" pa=0x%08\"PFMT64x\" sz=%\"PFMT64d\" vsz=%\"PFMT64d\" \"\n\t\t\t\t\t\t\"rwx=%s %s.%s @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\ti, addr, section->paddr, section->size, section->vsize,\n\t\t\t\t\t\tperms, r->bin->prefix, section->name, addr);\n\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"f section.%s %\"PFMT64d\" 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\tsection->name, section->size, addr);\n\t\t\t\tr_cons_printf (\"f section_end.%s 1 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\tsection->name, addr + section->size);\n\t\t\t\tr_cons_printf (\"CC section %i va=0x%08\"PFMT64x\" pa=0x%08\"PFMT64x\" sz=%\"PFMT64d\" vsz=%\"PFMT64d\" \"\n\t\t\t\t\t\t\"rwx=%s %s @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\ti, addr, section->paddr, section->size, section->vsize,\n\t\t\t\t\t\tperms, section->name, addr);\n\t\t\t}\n\t\t} else {\n\t\t\tchar *hashstr = NULL, str[128];\n\t\t\tif (chksum) {\n\t\t\t\tut8 *data = malloc (section->size);\n\t\t\t\tif (!data) return false;\n\t\t\t\tut32 datalen = section->size;\n\t\t\t\t// VA READ IS BROKEN?\n\t\t\t\tr_io_pread (r->io, section->paddr, data, datalen);\n\t\t\t\thashstr = build_hash_string (mode, chksum,\n\t\t\t\t\t\t\tdata, datalen);\n\t\t\t\tfree (data);\n\t\t\t}\n\t\t\tif (section->arch || section->bits) {\n\t\t\t\tconst char *arch = section->arch;\n\t\t\t\tint bits = section->bits;\n\t\t\t\tif (!arch && info) {\n\t\t\t\t\tarch = info->arch;\n\t\t\t\t\tif (!arch) {\n\t\t\t\t\t\tarch = r_config_get (r->config, \"asm.arch\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!bits) {\n\t\t\t\t\tbits = info? info->bits: R_SYS_BITS;\n\t\t\t\t}\n\t\t\t\tsnprintf (str, sizeof (str), \"arch=%s bits=%d \",\n\t\t\t\t\tr_str_get2 (arch), bits);\n\t\t\t} else {\n\t\t\t\tstr[0] = 0;\n\t\t\t}\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tr_cons_printf (\"idx=%02i vaddr=0x%08\"PFMT64x\" paddr=0x%08\"PFMT64x\" sz=%\"PFMT64d\" vsz=%\"PFMT64d\" \"\n\t\t\t\t\t\"perm=%s %s%sname=%s.%s\\n\",\n\t\t\t\t\ti, addr, section->paddr, section->size, section->vsize,\n\t\t\t\t\tperms, str, hashstr ?hashstr : \"\", r->bin->prefix, section->name);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"idx=%02i vaddr=0x%08\"PFMT64x\" paddr=0x%08\"PFMT64x\" sz=%\"PFMT64d\" vsz=%\"PFMT64d\" \"\n\t\t\t\t\t\"perm=%s %s%sname=%s\\n\",\n\t\t\t\t\ti, addr, section->paddr, section->size, section->vsize,\n\t\t\t\t\tperms, str, hashstr ?hashstr : \"\", section->name);\n\t\t\t}\n\t\t\tfree (hashstr);\n\t\t}\n\t\ti++;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_println (\"]\");\n\t} else if (IS_MODE_NORMAL (mode) && !at) {\n\t\tr_cons_printf (\"\\n%i sections\\n\", i);\n\t}\n\treturn true;\n}\n\nstatic int bin_fields(RCore *r, int mode, int va) {\n\tRList *fields;\n\tRListIter *iter;\n\tRBinField *field;\n\tint i = 0;\n\tRBin *bin = r->bin;\n\tRBinFile *binfile = r_core_bin_cur (r);\n\tut64 size = binfile ? binfile->size : UT64_MAX;\n\tut64 baddr = r_bin_get_baddr (r->bin);\n\n\tif (!(fields = r_bin_get_fields (bin))) {\n\t\treturn false;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"[\");\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_println (\"fs header\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_println (\"[Header fields]\");\n\t}\n//why this? there is an overlap in bin_sections with ehdr\n//because there can't be two sections with the same name\n#if 0\n\telse if (IS_MODE_SET (mode)) {\n\t\t// XXX: Need more flags??\n\t\t// this will be set even if the binary does not have an ehdr\n\t\tint fd = r_core_file_cur_fd(r);\n\t\tr_io_section_add (r->io, 0, baddr, size, size, 7, \"ehdr\", 0, fd);\n\t}\n#endif\n\tr_list_foreach (fields, iter, field) {\n\t\tut64 addr = rva (bin, field->paddr, field->vaddr, va);\n\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_name_filter (field->name, -1);\n\t\t\tr_cons_printf (\"f header.%s @ 0x%08\"PFMT64x\"\\n\", field->name, addr);\n\t\t\tif (field->comment && *field->comment) {\n\t\t\t\tr_cons_printf (\"CC %s @ 0x%\"PFMT64x\"\\n\", field->comment, addr);\n\t\t\t}\n\t\t\tif (field->format && *field->format) {\n\t\t\t\tr_cons_printf (\"pf.%s %s\\n\", field->name, field->format);\n\t\t\t}\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"paddr\\\":%\"PFMT64d,\n\t\t\t\titer->p? \",\": \"\",\n\t\t\t\tfield->name,\n\t\t\t\tfield->vaddr,\n\t\t\t\tfield->paddr\n\t\t\t\t);\n\t\t\tif (field->comment && *field->comment) {\n\t\t\t\t// TODO: filter comment before json\n\t\t\t\tr_cons_printf (\",\\\"comment\\\":\\\"%s\\\"\", field->comment);\n\t\t\t}\n\t\t\tif (field->format && *field->format) {\n\t\t\t\t// TODO: filter comment before json\n\t\t\t\tr_cons_printf (\",\\\"format\\\":\\\"%s\\\"\", field->format);\n\t\t\t}\n\t\t\tr_cons_printf (\"}\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tconst bool haveComment = (field->comment && *field->comment);\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" 0x%08\"PFMT64x\" %s%s%s\\n\",\n\t\t\t\tfield->vaddr, field->paddr, field->name,\n\t\t\t\thaveComment? \"; \": \"\",\n\t\t\t\thaveComment? field->comment: \"\");\n\t\t}\n\t\ti++;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"]\");\n\t} else if (IS_MODE_RAD (mode)) {\n\t\t/* add program header section */\n\t\tr_cons_printf (\"S 0 0x%\"PFMT64x\" 0x%\"PFMT64x\" 0x%\"PFMT64x\" ehdr rwx\\n\",\n\t\t\tbaddr, size, size);\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"\\n%i fields\\n\", i);\n\t}\n\n\treturn true;\n}\n\nstatic int bin_classes(RCore *r, int mode) {\n\tRListIter *iter, *iter2;\n\tRBinSymbol *sym;\n\tRBinClass *c;\n\tchar *name;\n\tRList *cs = r_bin_get_classes (r->bin);\n\tif (!cs) {\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_print(\"[]\");\n\t\t}\n\t\treturn false;\n\t}\n\t// XXX: support for classes is broken and needs more love\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"[\");\n\t} else if (IS_MODE_SET (mode)) {\n\t\tif (!r_config_get_i (r->config, \"bin.classes\")) {\n\t\t\treturn false;\n\t\t}\n\t\tr_flag_space_set (r->flags, \"classes\");\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_println (\"fs classes\");\n\t}\n\n\tr_list_foreach (cs, iter, c) {\n\t\tif (!c || !c->name || !c->name[0]) {\n\t\t\tcontinue;\n\t\t}\n\t\tname = strdup (c->name);\n\t\tr_name_filter (name, 0);\n\t\tut64 at_min = UT64_MAX;\n\t\tut64 at_max = 0LL;\n\n\t\tr_list_foreach (c->methods, iter2, sym) {\n\t\t\tif (sym->vaddr) {\n\t\t\t\tif (sym->vaddr < at_min) {\n\t\t\t\t\tat_min = sym->vaddr;\n\t\t\t\t}\n\t\t\t\tif (sym->vaddr + sym->size > at_max) {\n\t\t\t\t\tat_max = sym->vaddr + sym->size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (at_min == UT64_MAX) {\n\t\t\tat_min = c->addr;\n\t\t\tat_max = c->addr; // XXX + size?\n\t\t}\n\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\tconst char *classname = sdb_fmt (0, \"class.%s\", name);\n\t\t\tr_flag_set (r->flags, classname, c->addr, 1);\n\t\t\tr_list_foreach (c->methods, iter2, sym) {\n\t\t\t\tchar *mflags = r_core_bin_method_flags_str (sym, mode);\n\t\t\t\tchar *method = sdb_fmt (1, \"method%s.%s.%s\",\n\t\t\t\t\tmflags, c->name, sym->name);\n\t\t\t\tR_FREE (mflags);\n\t\t\t\tr_name_filter (method, -1);\n\t\t\t\tr_flag_set (r->flags, method, sym->vaddr, 1);\n\t\t\t}\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" [0x%08\"PFMT64x\" - 0x%08\"PFMT64x\"] %s%s%s\\n\",\n\t\t\t\tc->addr, at_min, at_max, c->name, c->super ? \" \" : \"\",\n\t\t\t\tc->super ? c->super : \"\");\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"\\\"f class.%s = 0x%\"PFMT64x\"\\\"\\n\",\n\t\t\t\tname, at_min);\n\t\t\tif (c->super) {\n\t\t\t\tr_cons_printf (\"\\\"f super.%s.%s = %d\\\"\\n\",\n\t\t\t\t\tc->name, c->super, c->index);\n\t\t\t}\n\t\t\tr_list_foreach (c->methods, iter2, sym) {\n\t\t\t\tchar *mflags = r_core_bin_method_flags_str (sym, mode);\n\t\t\t\tr_cons_printf (\"\\\"f method%s.%s.%s = 0x%\"PFMT64x\"\\\"\\n\", mflags, c->name, sym->name, sym->vaddr);\n\t\t\t\tR_FREE (mflags);\n\t\t\t}\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tif (c->super) {\n\t\t\t\tr_cons_printf (\"%s{\\\"classname\\\":\\\"%s\\\",\\\"addr\\\":%\"PFMT64d\",\\\"index\\\":%\"PFMT64d\",\\\"super\\\":\\\"%s\\\",\\\"methods\\\":[\",\n\t\t\t\t\titer->p ? \",\" : \"\", c->name, c->addr,\n\t\t\t\t\tc->index, c->super);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"%s{\\\"classname\\\":\\\"%s\\\",\\\"addr\\\":%\"PFMT64d\",\\\"index\\\":%\"PFMT64d\",\\\"methods\\\":[\",\n\t\t\t\t\titer->p ? \",\" : \"\", c->name, c->addr,\n\t\t\t\t\tc->index);\n\t\t\t}\n\t\t\tr_list_foreach (c->methods, iter2, sym) {\n\t\t\t\tif (sym->method_flags) {\n\t\t\t\t\tchar *mflags = r_core_bin_method_flags_str (sym, mode);\n\t\t\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\\\"flags\\\":%s,\\\"addr\\\":%\"PFMT64d\"}\",\n\t\t\t\t\t\titer2->p? \",\": \"\", sym->name, mflags, sym->vaddr);\n\t\t\t\t\tR_FREE (mflags);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\\\"addr\\\":%\"PFMT64d\"}\",\n\t\t\t\t\t\titer2->p? \",\": \"\", sym->name, sym->vaddr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_cons_printf (\"]}\");\n\t\t} else {\n\t\t\tint m = 0;\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" [0x%08\"PFMT64x\" - 0x%08\"PFMT64x\"] (sz %d) class %d %s\",\n\t\t\t\tc->addr, at_min, at_max, (at_max - at_min), c->index, c->name);\n\t\t\tif (c->super) {\n\t\t\t\tr_cons_printf (\" super: %s\\n\", c->super);\n\t\t\t} else {\n\t\t\t\tr_cons_newline ();\n\t\t\t}\n\t\t\tr_list_foreach (c->methods, iter2, sym) {\n\t\t\t\tchar *mflags = r_core_bin_method_flags_str (sym, mode);\n\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" method %d %s %s\\n\",\n\t\t\t\t\tsym->vaddr, m, mflags, sym->dname? sym->dname: sym->name);\n\t\t\t\tR_FREE (mflags);\n\t\t\t\tm++;\n\t\t\t}\n\t\t}\n\t\tfree (name);\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"]\");\n\t}\n\n\treturn true;\n}\n\nstatic int bin_size(RCore *r, int mode) {\n\tut64 size = r_bin_get_size (r->bin);\n\tif (IS_MODE_SIMPLE (mode) || IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"%\"PFMT64u\"\\n\", size);\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"f bin_size @ %\"PFMT64u\"\\n\", size);\n\t} else if (IS_MODE_SET (mode)) {\n\t\tr_core_cmdf (r, \"f bin_size @ %\"PFMT64u\"\\n\", size);\n\t} else {\n\t\tr_cons_printf (\"%\"PFMT64u\"\\n\", size);\n\t}\n\treturn true;\n}\n\nstatic int bin_libs(RCore *r, int mode) {\n\tRList *libs;\n\tRListIter *iter;\n\tchar* lib;\n\tint i = 0;\n\n\tif (!(libs = r_bin_get_libs (r->bin))) {\n\t\treturn false;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"[\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_println (\"[Linked libraries]\");\n\t}\n\tr_list_foreach (libs, iter, lib) {\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\t// Nothing to set.\n\t\t\t// TODO: load libraries with iomaps?\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"CCa entry0 %s\\n\", lib);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"%s\\\"%s\\\"\", iter->p ? \",\" : \"\", lib);\n\t\t} else {\n\t\t\t// simple and normal print mode\n\t\t\tr_cons_println (lib);\n\t\t}\n\t\ti++;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"]\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tif (i == 1) {\n\t\t\tr_cons_printf (\"\\n%i library\\n\", i);\n\t\t} else {\n\t\t\tr_cons_printf (\"\\n%i libraries\\n\", i);\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic void bin_mem_print(RList *mems, int perms, int depth, int mode) {\n\tRBinMem *mem;\n\tRListIter *iter;\n\tif (!mems) {\n\t\treturn;\n\t}\n\tr_list_foreach (mems, iter, mem) {\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"{\\\"name\\\":\\\"%s\\\",\\\"size\\\":%d,\\\"address\\\":%d,\"\n\t\t\t\t\t\"\\\"flags\\\":\\\"%s\\\"}\", mem->name, mem->size,\n\t\t\t\t\tmem->addr, r_str_rwx_i (mem->perms & perms));\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"\\n\", mem->addr);\n\t\t} else {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" +0x%04x %s %*s%-*s\\n\",\n\t\t\t\t\tmem->addr, mem->size, r_str_rwx_i (mem->perms & perms),\n\t\t\t\t\tdepth, \"\", 20-depth, mem->name);\n\t\t}\n\t\tif (mem->mirrors) {\n\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\tr_cons_printf (\",\");\n\t\t\t}\n\t\t\tbin_mem_print (mem->mirrors, mem->perms & perms, depth + 1, mode);\n\t\t}\n\t\tif (IS_MODE_JSON(mode)) {\n\t\t\tif (iter->n) {\n\t\t\t\tr_cons_printf (\",\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int bin_mem(RCore *r, int mode) {\n\tRList *mem = NULL;\n\tif (!r)\treturn false;\n\tif (!IS_MODE_JSON(mode)) {\n\t\tif (!(IS_MODE_RAD (mode) || IS_MODE_SET (mode))) {\n\t\t\tr_cons_println (\"[Memory]\\n\");\n\t\t}\n\t}\n\tif (!(mem = r_bin_get_mem (r->bin))) {\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_print(\"[]\");\n\t\t}\n\t\treturn false;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"[\");\n\t\tbin_mem_print (mem, 7, 0, R_CORE_BIN_JSON);\n\t\tr_cons_println (\"]\");\n\t\treturn true;\n\t} else if (!(IS_MODE_RAD (mode) || IS_MODE_SET (mode))) {\n\t\tbin_mem_print (mem, 7, 0, mode);\n\t}\n\treturn true;\n}\n\nstatic void bin_pe_versioninfo(RCore *r) {\n\tSdb *sdb = NULL;\n\tint num_version = 0;\n\tint num_stringtable = 0;\n\tint num_string = 0;\n\tconst char *format_version = \"bin/cur/info/vs_version_info/VS_VERSIONINFO%d\";\n\tconst char *format_stringtable = \"%s/string_file_info/stringtable%d\";\n\tconst char *format_string = \"%s/string%d\";\n\tr_cons_printf (\"=== VS_VERSIONINFO ===\\n\\n\");\n\tdo {\n\t\tchar path_version[256] = R_EMPTY;\n\t\tsnprintf (path_version, sizeof (path_version), format_version, num_version);\n\t\tif (!(sdb = sdb_ns_path (r->sdb, path_version, 0)))\n\t\t\tbreak;\n\t\tr_cons_printf (\"# VS_FIXEDFILEINFO\\n\\n\");\n\t\tchar path_fixedfileinfo[256] = R_EMPTY;\n\t\tsnprintf (path_fixedfileinfo, sizeof (path_fixedfileinfo), \"%s/fixed_file_info\", path_version);\n\t\tif (!(sdb = sdb_ns_path (r->sdb, path_fixedfileinfo, 0)))\n\t\t\tbreak;\n\n\t\tr_cons_printf (\"  Signature: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"Signature\", 0));\n\t\tr_cons_printf (\"  StrucVersion: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"StrucVersion\", 0));\n\t\tr_cons_printf (\"  FileVersion: %\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\"\\n\",\n\t\t\tsdb_num_get (sdb, \"FileVersionMS\", 0) >> 16,\n\t\t\tsdb_num_get (sdb, \"FileVersionMS\", 0) & 0xFFFF,\n\t\t\tsdb_num_get (sdb, \"FileVersionLS\", 0) >> 16,\n\t\t\tsdb_num_get (sdb, \"FileVersionLS\", 0) & 0xFFFF);\n\t\tr_cons_printf (\"  ProductVersion: %\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\"\\n\",\n\t\t\tsdb_num_get (sdb, \"ProductVersionMS\", 0) >> 16,\n\t\t\tsdb_num_get (sdb, \"ProductVersionMS\", 0) & 0xFFFF,\n\t\t\tsdb_num_get (sdb, \"ProductVersionLS\", 0) >> 16,\n\t\t\tsdb_num_get (sdb, \"ProductVersionLS\", 0) & 0xFFFF);\n\t\tr_cons_printf (\"  FileFlagsMask: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"FileFlagsMask\", 0));\n\t\tr_cons_printf (\"  FileFlags: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"FileFlags\", 0));\n\t\tr_cons_printf (\"  FileOS: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"FileOS\", 0));\n\t\tr_cons_printf (\"  FileType: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"FileType\", 0));\n\t\tr_cons_printf (\"  FileSubType: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"FileSubType\", 0));\n#if 0\n\t\tr_cons_printf (\"  FileDate: %d.%d.%d.%d\\n\",\n\t\t\tsdb_num_get (sdb, \"FileDateMS\", 0) >> 16,\n\t\t\tsdb_num_get (sdb, \"FileDateMS\", 0) & 0xFFFF,\n\t\t\tsdb_num_get (sdb, \"FileDateLS\", 0) >> 16,\n\t\t\tsdb_num_get (sdb, \"FileDateLS\", 0) & 0xFFFF);\n#endif\n\t\tr_cons_newline ();\n\t\tr_cons_println (\"# StringTable\\n\");\n\t\tfor (num_stringtable = 0; sdb; ++num_stringtable) {\n\t\t\tchar path_stringtable[256] = R_EMPTY;\n\t\t\tsnprintf (path_stringtable, sizeof (path_stringtable), format_stringtable, path_version, num_stringtable);\n\t\t\tsdb = sdb_ns_path (r->sdb, path_stringtable, 0);\n\t\t\tfor (num_string = 0; sdb; ++num_string) {\n\t\t\t\tchar path_string[256] = R_EMPTY;\n\t\t\t\tsnprintf (path_string, sizeof (path_string), format_string, path_stringtable, num_string);\n\t\t\t\tsdb = sdb_ns_path (r->sdb, path_string, 0);\n\t\t\t\tif (sdb) {\n\t\t\t\t\tint lenkey = 0;\n\t\t\t\t\tint lenval = 0;\n\t\t\t\t\tut8 *key_utf16 = sdb_decode (sdb_const_get (sdb, \"key\", 0), &lenkey);\n\t\t\t\t\tut8 *val_utf16 = sdb_decode (sdb_const_get (sdb, \"value\", 0), &lenval);\n\t\t\t\t\tut8 *key_utf8 = calloc (lenkey * 2, 1);\n\t\t\t\t\tut8 *val_utf8 = calloc (lenval * 2, 1);\n\n\t\t\t\t\tif (r_str_utf16_to_utf8 (key_utf8, lenkey * 2, key_utf16, lenkey, true) < 0\n\t\t\t\t\t\t|| r_str_utf16_to_utf8 (val_utf8, lenval * 2, val_utf16, lenval, true) < 0) {\n\t\t\t\t\t\teprintf (\"Warning: Cannot decode utf16 to utf8\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"  %s: %s\\n\", (char*)key_utf8, (char*)val_utf8);\n\t\t\t\t\t}\n\n\t\t\t\t\tfree (key_utf8);\n\t\t\t\t\tfree (val_utf8);\n\t\t\t\t\tfree (key_utf16);\n\t\t\t\t\tfree (val_utf16);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t++num_version;\n\t} while (sdb);\n}\n\nstatic void bin_elf_versioninfo(RCore *r) {\n\tconst char *format = \"bin/cur/info/versioninfo/%s%d\";\n\tchar path[256] = R_EMPTY;\n\tint num_versym = 0;\n\tint num_verneed = 0;\n\tint num_entry = 0;\n\tSdb *sdb = NULL;\n\tdo {\n\t\tsnprintf (path, sizeof (path), format, \"versym\", num_versym++);\n\t\tif (!(sdb = sdb_ns_path (r->sdb, path, 0))) {\n\t\t\tbreak;\n\t\t}\n\t\tut64 addr = sdb_num_get (sdb, \"addr\", 0);\n\t\tut64 offset = sdb_num_get (sdb, \"offset\", 0);\n\t\tut64 link = sdb_num_get (sdb, \"link\", 0);\n\t\tut64 num_entries = sdb_num_get (sdb, \"num_entries\", 0);\n\t\tconst char *section_name = sdb_const_get (sdb, \"section_name\", 0);\n\t\tconst char *link_section_name = sdb_const_get (sdb, \"link_section_name\", 0);\n\n\t\tr_cons_printf (\"Version symbols section '%s' contains %\"PFMT64u\" entries:\\n\", section_name, num_entries);\n\t\tr_cons_printf (\" Addr: 0x%08\"PFMT64x\"  Offset: 0x%08\"PFMT64x\"  Link: %x (%s)\\n\",\n\t\t\t(ut64)addr, (ut64)offset, (ut32)link, link_section_name);\n\n\t\tdo {\n\t\t\tint num_val = 0;\n\t\t\tchar path_entry[256] = R_EMPTY;\n\t\t\tsnprintf (path_entry, sizeof (path_entry), \"%s/entry%d\", path, num_entry++);\n\t\t\tif (!(sdb = sdb_ns_path (r->sdb, path_entry, 0)))\n\t\t\t\tbreak;\n\n\t\t\tr_cons_printf (\"  0x%08\"PFMT64x\": \", sdb_num_get (sdb, \"idx\", 0));\n\t\t\tconst char *value = NULL;\n\n\t\t\tdo {\n\t\t\t\tchar key[32] = R_EMPTY;\n\t\t\t\tsnprintf (key, sizeof (key), \"value%d\", num_val++);\n\n\t\t\t\tif ((value = sdb_const_get (sdb, key, 0)))\n\t\t\t\t\tr_cons_printf (\"%s \", value);\n\t\t\t} while (value);\n\t\t\tr_cons_newline ();\n\t\t} while (sdb);\n\t\tr_cons_println (\"\\n\");\n\t} while (sdb);\n\n\tdo {\n\t\tint num_version = 0;\n\t\tchar path_version[256] = R_EMPTY;\n\t\tsnprintf (path, sizeof (path), format, \"verneed\", num_verneed++);\n\t\tif (!(sdb = sdb_ns_path (r->sdb, path, 0)))\n\t\t\tbreak;\n\n\t\tr_cons_printf (\"Version need section '%s' contains %d entries:\\n\",\n\t\t\tsdb_const_get (sdb, \"section_name\", 0), (int)sdb_num_get (sdb, \"num_entries\", 0));\n\n\t\tr_cons_printf (\" Addr: 0x%08\"PFMT64x, sdb_num_get (sdb, \"addr\", 0));\n\n\t\tr_cons_printf (\"  Offset: 0x%08\"PFMT64x\"  Link to section: %\"PFMT64d\" (%s)\\n\",\n\t\t\tsdb_num_get (sdb, \"offset\", 0), sdb_num_get (sdb, \"link\", 0),\n\t\t\tsdb_const_get (sdb, \"link_section_name\", 0));\n\n\t\tdo {\n\t\t\tsnprintf (path_version, sizeof (path_version), \"%s/version%d\", path, num_version++);\n\t\t\tconst char *filename = NULL;\n\t\t\tchar path_vernaux[256] = R_EMPTY;\n\t\t\tint num_vernaux = 0;\n\t\t\tif (!(sdb = sdb_ns_path (r->sdb, path_version, 0)))\n\t\t\t\tbreak;\n\n\t\t\tr_cons_printf (\"  0x%08\"PFMT64x\": Version: %d\",\n\t\t\t\tsdb_num_get (sdb, \"idx\", 0), (int)sdb_num_get (sdb, \"vn_version\", 0));\n\n\t\t\tif ((filename = sdb_const_get (sdb, \"file_name\", 0)))\n\t\t\t\tr_cons_printf (\"  File: %s\", filename);\n\n\t\t\tr_cons_printf (\"  Cnt: %d\\n\", (int)sdb_num_get (sdb, \"cnt\", 0));\n\t\t\tdo {\n\t\t\t\tsnprintf (path_vernaux, sizeof (path_vernaux), \"%s/vernaux%d\",\n\t\t\t\t\tpath_version, num_vernaux++);\n\t\t\t\tif (!(sdb = sdb_ns_path (r->sdb, path_vernaux, 0)))\n\t\t\t\t\tbreak;\n\n\t\t\t\tr_cons_printf (\"  0x%08\"PFMT64x\":   Name: %s\",\n\t\t\t\t\tsdb_num_get (sdb, \"idx\", 0), sdb_const_get (sdb, \"name\", 0));\n\n\t\t\t\tr_cons_printf (\"  Flags: %s Version: %d\\n\",\n\t\t\t\t\tsdb_const_get (sdb, \"flags\", 0), (int)sdb_num_get (sdb, \"version\", 0));\n\t\t\t} while (sdb);\n\t\t} while (sdb);\n\t} while (sdb);\n}\n\nstatic void bin_mach0_versioninfo(RCore *r) {\n\t/* TODO */\n}\n\nstatic void bin_pe_resources(RCore *r, int mode) {\n\tSdb *sdb = NULL;\n\tint index = 0;\n\tconst char *pe_path = \"bin/cur/info/pe_resource\";\n\tif (!(sdb = sdb_ns_path (r->sdb, pe_path, 0))) {\n\t\treturn;\n\t}\n\tif (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, \"resources\");\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"fs resources\\n\");\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"[\");\n\t}\n\twhile (true) {\n\t\tconst char *timestrKey = sdb_fmt (0, \"resource.%d.timestr\", index);\n\t\tconst char *paddrKey = sdb_fmt (1, \"resource.%d.paddr\", index);\n\t\tconst char *sizeKey  = sdb_fmt (2, \"resource.%d.size\", index);\n\t\tconst char *typeKey  = sdb_fmt (3, \"resource.%d.type\", index);\n\t\tconst char *languageKey = sdb_fmt (4, \"resource.%d.language\", index);\n\t\tconst char *nameKey = sdb_fmt (5, \"resource.%d.name\", index);\n\t\tchar *timestr = sdb_get (sdb, timestrKey, 0);\n\t\tif (!timestr) {\n\t\t\tbreak;\n\t\t}\n\t\tut64 paddr = sdb_num_get (sdb, paddrKey, 0);\n\t\tint size = (int)sdb_num_get (sdb, sizeKey, 0);\n\t\tint name = (int)sdb_num_get (sdb, nameKey, 0);\n\t\tchar *type = sdb_get (sdb, typeKey, 0);\n\t\tchar *lang = sdb_get (sdb, languageKey, 0);\n\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\tconst char *name = sdb_fmt (4, \"resource.%d\", index);\n\t\t\tr_flag_set (r->flags, name, paddr, size);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"f resource.%d %d 0x%08\"PFMT32x\"\\n\", index, size, paddr); \n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf(\"%s{\\\"name\\\":%d,\\\"index\\\":%d, \\\"type\\\":\\\"%s\\\",\" \n\t\t\t\t\t\"\\\"paddr\\\":%\"PFMT32d\", \\\"size\\\":%d, \\\"lang\\\":\\\"%s\\\"}\", \n\t\t\t\t\tindex? \",\": \"\", name, index, type, paddr, size, lang);\n\t\t} else {\n\t\t\tchar *humanSize = r_num_units (NULL, size);\n\t\t\tr_cons_printf (\"Resource %d\\n\", index);\n\t\t\tr_cons_printf (\"\\tname: %d\\n\", name);\n\t\t\tr_cons_printf (\"\\ttimestamp: %s\\n\", timestr);\n\t\t\tr_cons_printf (\"\\tpaddr: 0x%08\"PFMT32x\"\\n\", paddr);\n\t\t\tr_cons_printf (\"\\tsize: %s\\n\", humanSize);\n\t\t\tr_cons_printf (\"\\ttype: %s\\n\", type);\n\t\t\tr_cons_printf (\"\\tlanguage: %s\\n\", lang);\n\t\t\tfree (humanSize);\n\t\t}\n\t\tindex++;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"]\");\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"fs *\");\n\t}\n}\n\n\nstatic int bin_resources(RCore *r, int mode) {\n\tconst RBinInfo *info = r_bin_get_info (r->bin);\n\tif (!info || !info->rclass) {\n\t\treturn false;\n\t}\n\tif (!strncmp (\"pe\", info->rclass, 2)) {\n\t\tbin_pe_resources (r, mode);\n\t}\n\treturn true;\n}\n\nstatic int bin_versioninfo(RCore *r, int mode) {\n\tconst RBinInfo *info = r_bin_get_info (r->bin);\n\tif (!info || !info->rclass) {\n\t\treturn false;\n\t}\n\tif (!strncmp (\"pe\", info->rclass, 2)) {\n\t\tbin_pe_versioninfo (r);\n\t} else if (!strncmp (\"elf\", info->rclass, 3)) {\n\t\tbin_elf_versioninfo (r);\n\t} else if (!strncmp (\"mach0\", info->rclass, 5)) {\n\t\tbin_mach0_versioninfo (r);\n\t} else {\n\t\tr_cons_println (\"Unknown format\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic int bin_signature(RCore *r, int mode) {\n\tRBinFile *cur = r_bin_cur (r->bin);\n\tRBinPlugin *plg = r_bin_file_cur_plugin (cur);\n\tif (plg && plg->signature) {\n\t\tconst char *signature = plg->signature (cur, IS_MODE_JSON (mode));\n\t\tr_cons_println (signature);\n\t\tfree ((char*) signature);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\nR_API void r_core_bin_export_info_rad(RCore *core) {\n\tSdb *db = NULL;\n\tchar *flagname, *offset = NULL;\n\tRBinFile *bf = r_core_bin_cur (core);\n\tif (!bf) {\n\t\treturn;\n\t}\n\tdb = sdb_ns (bf->sdb, \"info\", 0);;\n\tif (!db) {\n\t\treturn;\n\t}\n\tif (db) {\n\t\tSdbListIter *iter;\n\t\tSdbKv *kv;\n\t\tr_cons_printf (\"fs format\\n\");\n\t\t// iterate over all keys\n\t\tSdbList *ls = sdb_foreach_list (db, false);\n\t\tls_foreach (ls, iter, kv) {\n\t\t\tchar *k = kv->key;\n\t\t\tchar *v = kv->value;\n\t\t\tchar *dup = strdup (k);\n\t\t\t//printf (\"?e (%s) (%s)\\n\", k, v);\n\n\t\t\tif ((flagname = strstr (dup, \".offset\"))) {\n\t\t\t\t*flagname = 0;\n\t\t\t\tflagname = dup;\n\t\t\t\tr_cons_printf (\"f %s @ %s\\n\", flagname, v);\n\t\t\t\tfree (offset);\n\t\t\t\toffset = strdup (v);\n\t\t\t}\n\t\t\tif ((flagname = strstr (dup, \".cparse\"))) {\n\t\t\t\tr_cons_printf (\"\\\"td %s\\\"\\n\", v);\n\t\t\t}\n\t\t\tfree (dup);\n\t\t}\n\t\tR_FREE (offset);\n\t\tls_foreach (ls, iter, kv) {\n\t\t\tchar *dup = kv->key;\n\t\t\tchar *v = kv->value;\n\t\t\tif ((flagname = strstr (dup, \".format\"))) {\n\t\t\t\t*flagname = 0;\n\t\t\t\tif (!offset) {\n\t\t\t\t\toffset = strdup (\"0\");\n\t\t\t\t}\n\t\t\t\tflagname = dup;\n\t\t\t\tr_cons_printf (\"pf.%s %s\\n\", flagname, v);\n\t\t\t\tint fmtsize = r_print_format_struct_size (v, core->print, 0);\n\t\t\t\tchar *offset_key = r_str_newf (\"%s.offset\", flagname);\n\t\t\t\tconst char *off = sdb_const_get (db, offset_key, 0);\n\t\t\t\tfree (offset_key);\n\t\t\t\tif (off) {\n\t\t\t\t\tr_cons_printf (\"Cf %d %s @ %s\\n\", fmtsize, v, off);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((flagname = strstr (dup, \".size\"))) {\n\t\t\t\t*flagname = 0;\n\t\t\t\tflagname = dup;\n\t\t\t\tr_cons_printf (\"fl %s %s\\n\", flagname, v);\n\t\t\t}\n\t\t}\n\t\tfree (offset);\n\t}\n}\n\nstatic int bin_header(RCore *r, int mode) {\n\tRBinFile *cur = r_bin_cur (r->bin);\n\tRBinPlugin *plg = r_bin_file_cur_plugin (cur);\n\tif (plg && plg->header) {\n\t\tplg->header (cur);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API int r_core_bin_info(RCore *core, int action, int mode, int va, RCoreBinFilter *filter, const char *chksum) {\n\tint ret = true;\n\tconst char *name = NULL;\n\tut64 at = 0, loadaddr = r_bin_get_laddr (core->bin);\n\tif (filter && filter->offset) {\n\t\tat = filter->offset;\n\t}\n\tif (filter && filter->name) {\n\t\tname = filter->name;\n\t}\n\t// use our internal values for va\n\tva = va ? VA_TRUE : VA_FALSE;\n\tif (r_config_get_i (core->config, \"anal.strings\")) {\n\t\tr_core_cmd0 (core, \"aar\");\n\t}\n\tif ((action & R_CORE_BIN_ACC_STRINGS)) ret &= bin_strings (core, mode, va);\n\tif ((action & R_CORE_BIN_ACC_RAW_STRINGS)) ret &= bin_raw_strings (core, mode, va);\n\tif ((action & R_CORE_BIN_ACC_INFO)) ret &= bin_info (core, mode);\n\tif ((action & R_CORE_BIN_ACC_MAIN)) ret &= bin_main (core, mode, va);\n\tif ((action & R_CORE_BIN_ACC_DWARF)) ret &= bin_dwarf (core, mode);\n\tif ((action & R_CORE_BIN_ACC_PDB)) ret &= bin_pdb (core, mode);\n\tif ((action & R_CORE_BIN_ACC_ENTRIES)) ret &= bin_entry (core, mode, loadaddr, va);\n\tif ((action & R_CORE_BIN_ACC_SECTIONS)) ret &= bin_sections (core, mode, loadaddr, va, at, name, chksum);\n\tif (r_config_get_i (core->config, \"bin.relocs\")) {\n\t\tif ((action & R_CORE_BIN_ACC_RELOCS)) ret &= bin_relocs (core, mode, va);\n\t}\n\tif ((action & R_CORE_BIN_ACC_IMPORTS)) ret &= bin_imports (core, mode, va, name);\n\tif ((action & R_CORE_BIN_ACC_EXPORTS)) ret &= bin_exports (core, mode, loadaddr, va, at, name);\n\tif ((action & R_CORE_BIN_ACC_SYMBOLS)) ret &= bin_symbols (core, mode, loadaddr, va, at, name);\n\tif ((action & R_CORE_BIN_ACC_LIBS)) ret &= bin_libs (core, mode);\n\tif ((action & R_CORE_BIN_ACC_CLASSES)) ret &= bin_classes (core, mode);\n\tif ((action & R_CORE_BIN_ACC_SIZE)) ret &= bin_size (core, mode);\n\tif ((action & R_CORE_BIN_ACC_MEM)) ret &= bin_mem (core, mode);\n\tif ((action & R_CORE_BIN_ACC_VERSIONINFO)) ret &= bin_versioninfo (core, mode);\n\tif ((action & R_CORE_BIN_ACC_RESOURCES)) ret &= bin_resources (core, mode);\n\tif ((action & R_CORE_BIN_ACC_SIGNATURE)) ret &= bin_signature (core, mode);\n\tif ((action & R_CORE_BIN_ACC_FIELDS)) {\n\t\tif (IS_MODE_SIMPLE (mode)) {\n\t\t\tif ((action & R_CORE_BIN_ACC_HEADER) || action & R_CORE_BIN_ACC_FIELDS) {\n\t\t\t\t/* ignore mode, just for quiet/simple here */\n\t\t\t\tret &= bin_fields (core, 0, va);\n\t\t\t}\n\t\t} else {\n\t\t\tif (IS_MODE_NORMAL(mode)) {\n\t\t\t\tret &= bin_header (core, mode);\n\t\t\t} else {\n\t\t\t\tif ((action & R_CORE_BIN_ACC_HEADER) || action & R_CORE_BIN_ACC_FIELDS) {\n\t\t\t\t\tret &= bin_fields (core, mode, va);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nR_API int r_core_bin_set_arch_bits(RCore *r, const char *name, const char * arch, ut16 bits) {\n\tRCoreFile *cf = r_core_file_cur (r);\n\tRBinFile *binfile;\n\tif (!name) {\n\t\tname = (cf && cf->desc) ? cf->desc->name : NULL;\n\t}\n\tif (!name) {\n\t\treturn false;\n\t}\n\t/* Check if the arch name is a valid name */\n\tif (!r_asm_is_valid (r->assembler, arch)) {\n\t\treturn false;\n\t}\n\t/* Find a file with the requested name/arch/bits */\n\tbinfile = r_bin_file_find_by_arch_bits (r->bin, arch, bits, name);\n\tif (!binfile) {\n\t\treturn false;\n\t}\n\tif (!r_bin_use_arch (r->bin, arch, bits, name)) {\n\t\treturn false;\n\t}\n\tr_core_bin_set_cur (r, binfile);\n\treturn r_core_bin_set_env (r, binfile);\n}\n\nR_API int r_core_bin_update_arch_bits(RCore *r) {\n\tRBinFile *binfile = NULL;\n\tconst char *name = NULL, *arch = NULL;\n\tut16 bits = 0;\n\tif (!r) {\n\t\treturn 0;\n\t}\n\tif (r->assembler) {\n\t\tbits = r->assembler->bits;\n\t   \tif (r->assembler->cur) {\n\t\t\tarch = r->assembler->cur->arch;\n\t\t}\n\t}\n\tbinfile = r_core_bin_cur (r);\n\tname = binfile ? binfile->file : NULL;\n\tif (r && r->bin && r->bin->binxtrs) {\n\t\tr_anal_hint_clear (r->anal);\n\t}\n\treturn r_core_bin_set_arch_bits (r, name, arch, bits);\n}\n\nR_API int r_core_bin_raise(RCore *core, ut32 binfile_idx, ut32 binobj_idx) {\n\tRBin *bin = core->bin;\n\tRBinFile *binfile = NULL;\n\n\tif (binfile_idx == UT32_MAX && binobj_idx == UT32_MAX) {\n\t\treturn false;\n\t}\n\tif (!r_bin_select_by_ids (bin, binfile_idx, binobj_idx)) {\n\t\treturn false;\n\t}\n\tbinfile = r_core_bin_cur (core);\n\tif (binfile) {\n\t\tr_io_raise (core->io, binfile->fd);\n\t}\n\t// it should be 0 to use r_io_use_fd in r_core_block_read\n\tcore->switch_file_view = 0;\n\treturn binfile && r_core_bin_set_env (core, binfile) && r_core_block_read (core);\n}\n\nR_API bool r_core_bin_delete(RCore *core, ut32 binfile_idx, ut32 binobj_idx) {\n\tif (binfile_idx == UT32_MAX && binobj_idx == UT32_MAX) {\n\t\treturn false;\n\t}\n\tif (!r_bin_object_delete (core->bin, binfile_idx, binobj_idx)) {\n\t\treturn false;\n\t}\n\tRBinFile *binfile = r_core_bin_cur (core);\n\tif (binfile) {\n\t\tr_io_raise (core->io, binfile->fd);\n\t}\n\tcore->switch_file_view = 0;\n\treturn binfile && r_core_bin_set_env (core, binfile) && r_core_block_read (core);\n}\n\nstatic int r_core_bin_file_print(RCore *core, RBinFile *binfile, int mode) {\n\tRListIter *iter;\n\tRBinObject *obj;\n\tconst char *name = binfile ? binfile->file : NULL;\n\t(void)r_bin_get_info (core->bin); // XXX is this necssary for proper iniitialization\n\tut32 id = binfile ? binfile->id : 0;\n\tut32 fd = binfile ? binfile->fd : 0;\n\tut32 bin_sz = binfile ? binfile->size : 0;\n\t// TODO: handle mode to print in json and r2 commands\n\n\tif (!binfile) {\n\t\treturn false;\n\t}\n\tswitch (mode) {\n\tcase 'j':\n\t\tr_cons_printf (\"{\\\"name\\\":\\\"%s\\\",\\\"fd\\\":%d,\\\"id\\\":%d,\\\"size\\\":%d,\\\"objs\\\":[\",\n\t\t\tname, fd, id, bin_sz);\n\t\tr_list_foreach (binfile->objs, iter, obj) {\n\t\t\tRBinInfo *info = obj->info;\n\t\t\tut8 bits = info ? info->bits : 0;\n\t\t\tconst char *arch = info ? info->arch : \"unknown\";\n\t\t\tr_cons_printf (\"{\\\"objid\\\":%d,\\\"arch\\\":\\\"%s\\\",\\\"bits\\\":%d,\\\"binoffset\\\":%\"\n\t\t\t\t\tPFMT64d\",\\\"objsize\\\":%\"PFMT64d\"}\",\n\t\t\t\t\tobj->id, arch, bits, obj->boffset, obj->obj_size);\n\t\t\tif (iter->n) {\n\t\t\t\tr_cons_print (\",\");\n\t\t\t}\n\t\t}\n\t\tr_cons_print (\"]}\");\n\t\tbreak;\n\tdefault:\n\t\tr_cons_printf (\"binfile fd=%d name=%s id=%d\\n\", fd, name, id);\n\t\tr_list_foreach (binfile->objs, iter, obj) {\n\t\t\tRBinInfo *info = obj->info;\n\t\t\tut8 bits = info ? info->bits : 0;\n\t\t\tconst char *arch = info ? info->arch : \"unknown\";\n\t\t\tif (!arch) {\n\t\t\t\tarch = r_config_get (core->config, \"asm.arch\");\n\t\t\t}\n\t\t\tr_cons_printf (\"objid=%d arch=%s bits=%d boffset=0x%04\"PFMT64x\" size=0x%04\"PFMT64x\"\\n\",\n\t\t\t\t\tobj->id, arch, bits, obj->boffset, obj->obj_size );\n\t\t}\n\t\tbreak;\n\t}\n\treturn true;\n}\n\nR_API int r_core_bin_list(RCore *core, int mode) {\n\t// list all binfiles and there objects and there archs\n\tint count = 0;\n\tRListIter *iter;\n\tRBinFile *binfile = NULL; //, *cur_bf = r_core_bin_cur (core) ;\n\tRBin *bin = core->bin;\n\tconst RList *binfiles = bin ? bin->binfiles: NULL;\n\tif (!binfiles) {\n\t\treturn false;\n\t}\n\tif (mode == 'j') {\n\t\tr_cons_print (\"[\");\n\t}\n\tr_list_foreach (binfiles, iter, binfile) {\n\t\tr_core_bin_file_print (core, binfile, mode);\n\t\tif (iter->n && mode == 'j') {\n\t\t\tr_cons_print (\",\");\n\t\t}\n\t}\n\tif (mode == 'j') {\n\t\tr_cons_println (\"]\");\n\t}\n\t//r_core_file_set_by_file (core, cur_cf);\n\t//r_core_bin_bind (core, cur_bf);\n\treturn count;\n}\n\nR_API char *r_core_bin_method_flags_str(RBinSymbol *sym, int mode) {\n\tchar *str;\n\tRStrBuf *buf;\n\tint i, len = 0;\n\n\tbuf = r_strbuf_new (\"\");\n\tif (IS_MODE_SET (mode) || IS_MODE_RAD (mode)) {\n\t\tif (!sym->method_flags) {\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i != 64; i++) {\n\t\t\tut64 flag = sym->method_flags & (1L << i);\n\t\t\tif (flag) {\n\t\t\t\tconst char *flag_string = r_bin_get_meth_flag_string (flag, false);\n\t\t\t\tif (flag_string) {\n\t\t\t\t\tr_strbuf_appendf (buf, \".%s\", flag_string);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tif (!sym->method_flags) {\n\t\t\tr_strbuf_append (buf, \"[]\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tr_strbuf_append (buf, \"[\");\n\n\t\tfor (i = 0; i != 64; i++) {\n\t\t\tut64 flag = sym->method_flags & (1L << i);\n\t\t\tif (flag) {\n\t\t\t\tconst char *flag_string = r_bin_get_meth_flag_string (flag, false);\n\n\t\t\t\tif (len != 0) {\n\t\t\t\t\tr_strbuf_append (buf, \",\");\n\t\t\t\t}\n\t\t\t\tif (flag_string) {\n\t\t\t\t\tr_strbuf_appendf (buf, \"\\\"%s\\\"\", flag_string);\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_appendf (buf, \"\\\"0x%08\"PFMT64x\"\\\"\", flag);\n\t\t\t\t}\n\t\t\t\tlen++;\n\t\t\t}\n\t\t}\n\n\t\tr_strbuf_append (buf, \"]\");\n\t} else {\n\t\tint pad_len = 4; //TODO: move to a config variable\n\n\t\tif (!sym->method_flags) {\n\t\t\tgoto padding;\n\t\t}\n\t\tfor (i = 0; i != 64; i++) {\n\t\t\tut64 flag = sym->method_flags & (1L << i);\n\t\t\tif (flag) {\n\t\t\t\tconst char *flag_string = r_bin_get_meth_flag_string (flag, true);\n\n\t\t\t\tif (flag_string) {\n\t\t\t\t\tr_strbuf_append (buf, flag_string);\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_append (buf, \"?\");\n\t\t\t\t}\n\n\t\t\t\tlen++;\n\t\t\t}\n\t\t}\npadding:\n\t\tfor ( ; len < pad_len; len++) {\n\t\t\tr_strbuf_append (buf, \" \");\n\t\t}\n\t}\n\nout:\n\tstr = strdup (r_strbuf_get (buf));\n\tr_strbuf_free (buf);\n\n\treturn str;\n}\n"], "fixing_code": ["/* radare - LGPL - Copyright 2006-2016 - pancake */\n\n#include \"r_config.h\"\n#include \"r_util.h\" // r_str_hash, r_str_chop, ...\n#ifdef _MSC_VER\n#define strcasecmp stricmp\n#endif\nR_API RConfigNode* r_config_node_new(const char *name, const char *value) {\n\tRConfigNode *node;\n\tif (STRNULL (name)) {\n\t\treturn NULL;\n\t}\n\tnode = R_NEW0 (RConfigNode);\n\tif (!node) {\n\t\treturn NULL;\n\t}\n\tnode->name = strdup (name);\n\tnode->value = strdup (value? value: \"\");\n\tnode->flags = CN_RW | CN_STR;\n\tnode->i_value = r_num_get (NULL, value);\n\tnode->options = r_list_new ();\n\treturn node;\n}\n\nR_API RConfigNode* r_config_node_clone(RConfigNode *n) {\n\tRConfigNode *cn = R_NEW0 (RConfigNode);\n\tif (!cn) {\n\t\treturn NULL;\n\t}\n\tcn->name = strdup (n->name);\n\tcn->desc = n->desc? strdup (n->desc): NULL;\n\tcn->value = strdup (n->value? n->value: \"\");\n\tcn->i_value = n->i_value;\n\tcn->flags = n->flags;\n\tcn->setter = n->setter;\n\tcn->options = r_list_clone (n->options);\n\treturn cn;\n}\n\nR_API void r_config_node_free(void *n) {\n\tRConfigNode *node = (RConfigNode *)n;\n\tif (!node) {\n\t\treturn;\n\t}\n\tfree (node->name);\n\tfree (node->desc);\n\tfree (node->value);\n\tr_list_free (node->options);\n\tfree (node);\n}\n\nstatic void config_print_value_json(RConfig *cfg, RConfigNode *node) {\n\tconst char *val = node->value;\n\tif (!val) {\n\t\tval = \"0\";\n\t}\n\tchar *sval = r_str_escape (val);\n\tif (node->flags & CN_BOOL || node->flags & CN_INT || node->flags & CN_OFFT) {\n\t\tif (!strncmp (val, \"0x\", 2)) {\n\t\t\tut64 n = r_num_get (NULL, val);\n\t\t\tcfg->cb_printf (\"%\"PFMT64d, n);\n\t\t} else if (r_str_isnumber (val) || !strcmp (val, \"true\") || !strcmp (val, \"false\")) {\n\t\t\tcfg->cb_printf (\"%s\", val);\n\t\t} else {\n\t\t\tcfg->cb_printf (\"\\\"%s\\\"\", sval);\n\t\t}\n\t} else {\n\t\tcfg->cb_printf (\"\\\"%s\\\"\", sval);\n\t}\n\tfree (sval);\n}\n\nstatic void config_print_node(RConfig *cfg, RConfigNode *node, const char *pfx, const char *sfx, bool verbose, bool json) {\n\tchar *option;\n\tbool isFirst;\n\tRListIter *iter;\n\tchar *es = NULL;\n\n\tif (json) {\n\t\tif (verbose) {\n\t\t\tcfg->cb_printf (\"{\");\n\t\t\tcfg->cb_printf (\"\\\"name\\\":\\\"%s\\\",\", node->name);\n\t\t\tcfg->cb_printf (\"\\\"value\\\":\");\n\t\t\tconfig_print_value_json (cfg, node);\n\t\t\tcfg->cb_printf (\",\\\"type\\\":\\\"%s\\\",\", r_config_node_type (node));\n\t\t\tes = r_str_escape (node->desc);\n\t\t\tif (es) {\n\t\t\t\tcfg->cb_printf (\"\\\"desc\\\":\\\"%s\\\",\", es);\n\t\t\t\tfree (es);\n\t\t\t}\n\t\t\tcfg->cb_printf (\"\\\"ro\\\":%s\", node->flags & CN_RO ? \"true\" : \"false\");\n\t\t\tif (!r_list_empty (node->options)) {\n\t\t\t\tisFirst = true;\n\t\t\t\tcfg->cb_printf (\",\\\"options\\\":[\");\n\t\t\t\tr_list_foreach (node->options, iter, option) {\n\t\t\t\t\tes = r_str_escape (option);\n\t\t\t\t\tif (es) {\n\t\t\t\t\t\tif (isFirst) {\n\t\t\t\t\t\t\tisFirst = false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcfg->cb_printf (\",\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcfg->cb_printf (\"\\\"%s\\\"\", es);\n\t\t\t\t\t\tfree (es);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcfg->cb_printf (\"]\");\n\t\t\t}\n\t\t\tcfg->cb_printf (\"}\");\n\t\t} else {\n\t\t\tcfg->cb_printf (\"\\\"%s\\\":\", node->name);\n\t\t\tconfig_print_value_json (cfg, node);\n\t\t}\n\t} else {\n\t\tif (verbose) {\n\t\t\tcfg->cb_printf (\"%s%s = %s%s %s; %s\", pfx,\n\t\t\t\tnode->name, node->value, sfx, \n\t\t\t\tnode->flags & CN_RO ? \"(ro)\" : \"\", \n\t\t\t\tnode->desc);\n\t\t\tif (!r_list_empty (node->options)) {\n\t\t\t\tisFirst = true;\n\t\t\t\tcfg->cb_printf(\" [\");\n\t\t\t\tr_list_foreach (node->options, iter, option) {\n\t\t\t\t\tif (isFirst) {\n\t\t\t\t\t\tisFirst = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcfg->cb_printf(\", \");\n\t\t\t\t\t}\n\t\t\t\t\tcfg->cb_printf(\"%s\", option);\n\t\t\t\t}\n\t\t\t\tcfg->cb_printf(\"]\");\n\t\t\t}\n\t\t\tcfg->cb_printf (\"\\n\");\n\t\t} else {\n\t\t\tcfg->cb_printf (\"%s%s = %s%s\\n\", pfx,\n\t\t\t\tnode->name, node->value, sfx);\n\t\t}\n\t}\n}\n\nR_API void r_config_list(RConfig *cfg, const char *str, int rad) {\n\tRConfigNode *node;\n\tRListIter *iter;\n\tconst char *sfx = \"\";\n\tconst char *pfx = \"\";\n\tint len = 0;\n\tbool verbose = false;\n\tbool json = false;\n\tbool isFirst = false;\n\n\tif (!STRNULL (str)) {\n\t\tstr = r_str_chop_ro (str);\n\t\tlen = strlen (str);\n\t\tif (len > 0 && str[0] == 'j') {\n\t\t\tstr++;\n\t\t\tlen--;\n\t\t\tjson = true;\n\t\t\trad = 'J';\n\t\t}\n\t\tif (len > 0 && str[0] == ' ') {\n\t\t\tstr++;\n\t\t\tlen--;\n\t\t}\n\t\tif (strlen (str) == 0) {\n\t\t\tstr = NULL;\n\t\t\tlen = 0;\n\t\t}\n\t}\n\n\tswitch (rad) {\n\tcase 1:\n\t\tpfx = \"\\\"e \";\n\t\tsfx = \"\\\"\";\n\t/* fallthrou */\n\tcase 0:\n\t\tr_list_foreach (cfg->nodes, iter, node) {\n\t\t\tif (!str || (str && (!strncmp (str, node->name, len)))) {\n\t\t\t\tconfig_print_node (cfg, node, pfx, sfx, verbose, json);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tr_list_foreach (cfg->nodes, iter, node) {\n\t\t\tif (!str || (str && (!strncmp (str, node->name, len)))) {\n\t\t\t\tif (!str || !strncmp (str, node->name, len)) {\n\t\t\t\t\tcfg->cb_printf (\"%20s: %s\\n\", node->name,\n\t\t\t\t\t\tnode->desc? node->desc: \"\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'v':\n\t\tverbose = true;\n\t\tr_list_foreach (cfg->nodes, iter, node) {\n\t\t\tif (!str || (str && (!strncmp (str, node->name, len)))) {\n\t\t\t\tconfig_print_node (cfg, node, pfx, sfx, verbose, json);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'q':\n\t\tr_list_foreach (cfg->nodes, iter, node) {\n\t\t\tcfg->cb_printf (\"%s\\n\", node->name);\n\t\t}\n\t\tbreak;\n\tcase 'J':\n\t\tverbose = true;\n\t/* fallthrou */\n\tcase 'j':\n\t\tjson = true;\n\t\tisFirst = true;\n\t\tif (verbose) {\n\t\t\tcfg->cb_printf (\"[\");\n\t\t} else {\n\t\t\tcfg->cb_printf (\"{\");\n\t\t}\n\t\tr_list_foreach (cfg->nodes, iter, node) {\n\t\t\tif (!str || (str && (!strncmp (str, node->name, len)))) {\n\t\t\t\tif (!str || !strncmp (str, node->name, len)) {\n\t\t\t\t\tif (isFirst) {\n\t\t\t\t\t\tisFirst = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcfg->cb_printf (\",\");\n\t\t\t\t\t}\n\t\t\t\t\tconfig_print_node (cfg, node, pfx, sfx, verbose, json);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (verbose) {\n\t\t\tcfg->cb_printf (\"]\\n\");\n\t\t} else {\n\t\t\tcfg->cb_printf (\"}\\n\");\n\t\t}\n\t\tbreak;\n\t}\n}\n\nR_API RConfigNode* r_config_node_get(RConfig *cfg, const char *name) {\n\tif (STRNULL (name)) {\n\t\treturn NULL;\n\t}\n\treturn ht_find (cfg->ht, name, NULL);\n}\n\nR_API int r_config_set_getter(RConfig *cfg, const char *key, RConfigCallback cb) {\n\tRConfigNode *node = r_config_node_get (cfg, key);\n\tif (node) {\n\t\tnode->getter = cb;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nR_API int r_config_set_setter(RConfig *cfg, const char *key, RConfigCallback cb) {\n\tRConfigNode *node = r_config_node_get (cfg, key);\n\tif (node) {\n\t\tnode->setter = cb;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic bool is_true(const char *s) {\n\treturn !strcasecmp (\"true\", s) || !strcasecmp (\"1\", s);\n}\n\nstatic bool is_bool(const char *s) {\n\treturn !strcasecmp (\"true\", s) || !strcasecmp (\"false\", s);\n}\n\nR_API const char* r_config_get(RConfig *cfg, const char *name) {\n\tRConfigNode *node = r_config_node_get (cfg, name);\n\tif (node) {\n\t\tif (node->getter) {\n\t\t\tnode->getter (cfg->user, node);\n\t\t}\n\t\tcfg->last_notfound = 0;\n\t\tif (node->flags & CN_BOOL) {\n\t\t\treturn r_str_bool (is_true (node->value));\n\t\t}\n\t\treturn node->value;\n\t} else {\n\t\teprintf (\"r_config_get: variable '%s' not found\\n\", name);\n\t}\n\tcfg->last_notfound = 1;\n\treturn NULL;\n}\n\nR_API int r_config_toggle(RConfig *cfg, const char *name) {\n\tRConfigNode *node = r_config_node_get (cfg, name);\n\tif (node && node->flags & CN_BOOL) {\n\t\t(void)r_config_set_i (cfg, name, !node->i_value);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API ut64 r_config_get_i(RConfig *cfg, const char *name) {\n\tRConfigNode *node = r_config_node_get (cfg, name);\n\tif (node) {\n\t\tif (node->getter) {\n\t\t\tnode->getter (cfg->user, node);\n\t\t}\n\t\tif (node->i_value || !strcmp (node->value, \"false\")) {\n\t\t\treturn node->i_value;\n\t\t}\n\t\treturn (ut64) r_num_math (cfg->num, node->value);\n\t}\n\treturn (ut64) 0LL;\n}\n\nR_API const char* r_config_node_type(RConfigNode *node) {\n\tif (node) {\n\t\tint f = node->flags;\n\t\tif (f & CN_BOOL) {\n\t\t\treturn \"bool\";\n\t\t}\n\t\tif (f & CN_STR) {\n\t\t\treturn \"str\";\n\t\t}\n\t\tif (f & CN_OFFT || f & CN_INT) {\n\t\t\tif (!strncmp (node->value, \"0x\", 2)) {\n\t\t\t\treturn \"addr\";\n\t\t\t}\n\t\t\treturn \"int\";\n\t\t}\n\t}\n\treturn \"\";\n}\n\nR_API RConfigNode* r_config_set_cb(RConfig *cfg, const char *name, const char *value, RConfigCallback cb) {\n\tRConfigNode *node = r_config_set (cfg, name, value);\n\tif (node && (node->setter = cb)) {\n\t\tif (!cb (cfg->user, node)) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn node;\n}\n\nR_API RConfigNode* r_config_set_i_cb(RConfig *cfg, const char *name, int ivalue, RConfigCallback cb) {\n\tRConfigNode *node = r_config_set_i (cfg, name, ivalue);\n\tif (node && (node->setter = cb)) {\n\t\tif (!node->setter (cfg->user, node)) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn node;\n}\n\n/* TODO: reduce number of strdups here */\nR_API RConfigNode* r_config_set(RConfig *cfg, const char *name, const char *value) {\n\tRConfigNode *node = NULL;\n\tchar *ov = NULL;\n\tut64 oi;\n\tif (!cfg || STRNULL (name)) {\n\t\treturn NULL;\n\t}\n\tnode = r_config_node_get (cfg, name);\n\tif (node) {\n\t\tif (node->flags & CN_RO) {\n\t\t\teprintf (\"(error: '%s' config key is read only)\\n\", name);\n\t\t\treturn node;\n\t\t}\n\t\toi = node->i_value;\n\t\tif (node->value) {\n\t\t\tov = strdup (node->value);\n\t\t\tif (!ov) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t} else {\n\t\t\tfree (node->value);\n\t\t\tnode->value = strdup (\"\");\n\t\t}\n\t\tif (node->flags & CN_BOOL) {\n\t\t\tbool b = is_true (value);\n\t\t\tnode->i_value = (ut64) b? 1: 0;\n\t\t\tchar *value = strdup (r_str_bool (b));\n\t\t\tif (value) {\n\t\t\t\tfree (node->value);\n\t\t\t\tnode->value = value;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!value) {\n\t\t\t\tfree (node->value);\n\t\t\t\tnode->value = strdup (\"\");\n\t\t\t\tnode->i_value = 0;\n\t\t\t} else {\n\t\t\t\tif (node->value == value) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tchar *tmp = node->value;\n\t\t\t\tnode->value = strdup (value);\n\t\t\t\tfree (tmp);\n\t\t\t\tif (IS_DIGIT (*value)) {\n\t\t\t\t\tif (strchr (value, '/')) {\n\t\t\t\t\t\tnode->i_value = r_num_get (cfg->num, value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode->i_value = r_num_math (cfg->num, value);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnode->i_value = 0;\n\t\t\t\t}\n\t\t\t\tnode->flags |= CN_INT;\n\t\t\t}\n\t\t}\n\t} else { // Create a new RConfigNode\n\t\toi = UT64_MAX;\n\t\tif (!cfg->lock) {\n\t\t\tnode = r_config_node_new (name, value);\n\t\t\tif (node) {\n\t\t\t\tif (value && is_bool (value)) {\n\t\t\t\t\tnode->flags |= CN_BOOL;\n\t\t\t\t\tnode->i_value = is_true (value)? 1: 0;\n\t\t\t\t}\n\t\t\t\tif (cfg->ht) {\n\t\t\t\t\tht_insert (cfg->ht, node->name, node);\n\t\t\t\t\tr_list_append (cfg->nodes, node);\n\t\t\t\t\tcfg->n_nodes++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\teprintf (\"r_config_set: unable to create a new RConfigNode\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"r_config_set: variable '%s' not found\\n\", name);\n\t\t}\n\t}\n\n\tif (node && node->setter) {\n\t\tint ret = node->setter (cfg->user, node);\n\t\tif (ret == false) {\n\t\t\tif (oi != UT64_MAX) {\n\t\t\t\tnode->i_value = oi;\n\t\t\t}\n\t\t\tfree (node->value);\n\t\t\tnode->value = strdup (ov? ov: \"\");\n\t\t}\n\t}\nbeach:\n\tfree (ov);\n\treturn node;\n}\n\n/* r_config_desc takes a RConfig and a name,\n * r_config_node_desc takes a RConfigNode\n * Both set and return node->desc */\nR_API const char* r_config_desc(RConfig *cfg, const char *name, const char *desc) {\n\tRConfigNode *node = r_config_node_get (cfg, name);\n\treturn r_config_node_desc (node, desc);\n}\n\nR_API const char* r_config_node_desc(RConfigNode *node, const char *desc) {\n\tif (node) {\n\t\tif (desc) {\n\t\t\tfree (node->desc);\n\t\t\tnode->desc = strdup (desc);\n\t\t}\n\t\treturn node->desc;\n\t}\n\treturn NULL;\n}\n\nR_API int r_config_rm(RConfig *cfg, const char *name) {\n\tRConfigNode *node = r_config_node_get (cfg, name);\n\tif (node) {\n\t\tht_delete (cfg->ht, node->name);\n\t\tr_list_delete_data (cfg->nodes, node);\n\t\tcfg->n_nodes--;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API RConfigNode* r_config_set_i(RConfig *cfg, const char *name, const ut64 i) {\n\tchar buf[128], *ov = NULL;\n\tif (!cfg || !name) {\n\t\treturn NULL;\n\t}\n\tRConfigNode *node = r_config_node_get (cfg, name);\n\tif (node) {\n\t\tif (node->flags & CN_RO) {\n\t\t\tnode = NULL;\n\t\t\tgoto beach;\n\t\t}\n\t\tif (node->value) {\n\t\t\tov = strdup (node->value);\n\t\t\tif (!ov) {\n\t\t\t\tnode = NULL;\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tfree (node->value);\n\t\t}\n\t\tif (node->flags & CN_BOOL) {\n\t\t\tnode->value = strdup (r_str_bool (i));\n\t\t} else {\n\t\t\tsnprintf (buf, sizeof (buf) - 1, \"%\" PFMT64d, i);\n\t\t\tnode->value = strdup (buf);\n\t\t}\n\t\tif (!node->value) {\n\t\t\tnode = NULL;\n\t\t\tgoto beach;\n\t\t}\n\t\t//node->flags = CN_RW | CN_INT;\n\t\tnode->i_value = i;\n\t} else {\n\t\tif (!cfg->lock) {\n\t\t\tif (i < 1024) {\n\t\t\t\tsnprintf (buf, sizeof (buf), \"%\" PFMT64d \"\", i);\n\t\t\t} else {\n\t\t\t\tsnprintf (buf, sizeof (buf), \"0x%08\" PFMT64x \"\", i);\n\t\t\t}\n\t\t\tnode = r_config_node_new (name, buf);\n\t\t\tif (!node) {\n\t\t\t\tnode = NULL;\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tnode->flags = CN_RW | CN_OFFT;\n\t\t\tnode->i_value = i;\n\t\t\tif (cfg->ht) {\n\t\t\t\tht_insert (cfg->ht, node->name, node);\n\t\t\t}\n\t\t\tif (cfg->nodes) {\n\t\t\t\tr_list_append (cfg->nodes, node);\n\t\t\t\tcfg->n_nodes++;\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"(locked: no new keys can be created (%s))\\n\", name);\n\t\t}\n\t}\n\n\tif (node && node->setter) {\n\t\tut64 oi = node->i_value;\n\t\tint ret = node->setter (cfg->user, node);\n\t\tif (!ret) {\n\t\t\tnode->i_value = oi;\n\t\t\tfree (node->value);\n\t\t\tnode->value = strdup (ov? ov: \"\");\n\t\t}\n\t}\nbeach:\n\tfree (ov);\n\treturn node;\n}\n\nR_API int r_config_eval(RConfig *cfg, const char *str) {\n\tchar *ptr, *a, *b, name[1024];\n\tunsigned int len;\n\tif (!str || !cfg) {\n\t\treturn false;\n\t}\n\tlen = strlen (str) + 1;\n\tif (len >= sizeof (name)) {\n\t\treturn false;\n\t}\n\tmemcpy (name, str, len);\n\tstr = r_str_chop (name);\n\n\tif (!str) {\n\t\treturn false;\n\t}\n\n\tif (str[0] == '\\0' || !strcmp (str, \"help\")) {\n\t\tr_config_list (cfg, NULL, 0);\n\t\treturn false;\n\t}\n\n\tif (str[0] == '-') {\n\t\tr_config_rm (cfg, str + 1);\n\t\treturn false;\n\t}\n\n\tptr = strchr (str, '=');\n\tif (ptr) {\n\t\t/* set */\n\t\tptr[0] = '\\0';\n\t\ta = r_str_chop (name);\n\t\tb = r_str_chop (ptr + 1);\n\t\t(void) r_config_set (cfg, a, b);\n\t} else {\n\t\tchar *foo = r_str_chop (name);\n\t\tif (foo[strlen (foo) - 1] == '.') {\n\t\t\tr_config_list (cfg, name, 0);\n\t\t\treturn false;\n\t\t} else {\n\t\t\t/* get */\n\t\t\tconst char *str = r_config_get (cfg, foo);\n\t\t\tif (str) {\n\t\t\t\tcfg->cb_printf (\"%s\\n\",\n\t\t\t\t\t(((int) (size_t) str) == 1)? \"true\": str);\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic int cmp(RConfigNode *a, RConfigNode *b) {\n\treturn strcmp (a->name, b->name);\n}\n\nR_API void r_config_lock(RConfig *cfg, int l) {\n\tr_list_sort (cfg->nodes, (RListComparator) cmp);\n\tcfg->lock = l;\n}\n\nR_API int r_config_readonly(RConfig *cfg, const char *key) {\n\tRConfigNode *n = r_config_node_get (cfg, key);\n\tif (!n) {\n\t\treturn false;\n\t}\n\tn->flags |= CN_RO;\n\treturn true;\n}\n\nstatic void _ht_node_free_kv(HtKv *kv) {\n\tfree (kv->key);\n\t//we do not free kv->value because there is other reference \n\tfree (kv);\n}\n\nR_API RConfig* r_config_new(void *user) {\n\tRConfig *cfg = R_NEW0 (RConfig);\n\tif (!cfg) {\n\t\treturn NULL;\n\t}\n\tcfg->ht = ht_new (NULL, _ht_node_free_kv, NULL);\n\tcfg->nodes = r_list_newf ((RListFree)r_config_node_free);\n\tif (!cfg->nodes) {\n\t\tR_FREE (cfg);\n\t\treturn NULL;\n\t}\n\tcfg->user = user;\n\tcfg->num = NULL;\n\tcfg->n_nodes = 0;\n\tcfg->lock = 0;\n\tcfg->cb_printf = (void *) printf;\n\treturn cfg;\n}\n\nR_API RConfig* r_config_clone(RConfig *cfg) {\n\tRListIter *iter;\n\tRConfigNode *node;\n\tRConfig *c = r_config_new (cfg->user);\n\tif (!c) {\n\t\treturn NULL;\n\t}\n\tr_list_foreach (cfg->nodes, iter, node) {\n\t\tRConfigNode *nn = r_config_node_clone (node);\n\t\tht_insert (c->ht, node->name, nn);\n\t\tr_list_append (c->nodes, nn);\n\t\tc->n_nodes++;\n\t}\n\tc->lock = cfg->lock;\n\tc->cb_printf = cfg->cb_printf;\n\treturn c;\n}\n\nR_API int r_config_free(RConfig *cfg) {\n\tif (!cfg) {\n\t\treturn 0;\n\t}\n\tcfg->nodes->free = r_config_node_free; // damn\n\tr_list_free (cfg->nodes);\n\tht_free (cfg->ht);\n\tfree (cfg);\n\treturn 0;\n}\n\nR_API void r_config_visual_hit_i(RConfig *cfg, const char *name, int delta) {\n\tRConfigNode *node = r_config_node_get (cfg, name);\n\tif (node && (node->flags & CN_INT || node->flags & CN_OFFT)) {\n\t\t(void)r_config_set_i (cfg, name, r_config_get_i (cfg, name) + delta);\n\t}\n}\n\nR_API void r_config_bump(RConfig *cfg, const char *key) {\n\tchar *orig = strdup (r_config_get (cfg, key));\n\tr_config_set (cfg, key, orig);\n\tfree (orig);\n}\n\nR_API bool r_config_save_char(RConfigHold *h, ...) {\n\tva_list ap;\n\tchar *key;\n\tif (!h->list_char) {\n\t\th->list_char = r_list_newf ((RListFree) free);\n\t\tif (!h->list_char) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tva_start (ap, h);\n\twhile ((key = va_arg (ap, char *))) {\n\t\tRConfigHoldChar *hc = R_NEW0 (RConfigHoldChar);\n\t\tif (!hc) {\n\t\t\tcontinue;\n\t\t}\n\t\thc->key = key;\n\t\thc->value = r_config_get (h->cfg, key);\n\t\tr_list_append (h->list_char, hc);\n\t}\n\tva_end (ap);\n\treturn true;\n}\n\nR_API bool r_config_save_num(RConfigHold *h, ...) {\n\tva_list ap;\n\tchar *key;\n\tif (!h->list_num) {\n\t\th->list_num = r_list_newf ((RListFree) free);\n\t\tif (!h->list_num) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tva_start (ap, h);\n\twhile ((key = va_arg (ap, char *))) {\n\t\tRConfigHoldNum *hc = R_NEW0 (RConfigHoldNum);\n\t\tif (!hc) {\n\t\t\tcontinue;\n\t\t}\n\t\thc->key = key;\n\t\thc->value = r_config_get_i (h->cfg, key);\n\t\tr_list_append (h->list_num, hc);\n\t}\n\tva_end (ap);\n\treturn true;\n}\n\nR_API RConfigHold* r_config_hold_new(RConfig *cfg) {\n\tif (cfg) {\n\t\tRConfigHold *hold = R_NEW0 (RConfigHold);\n\t\tif (hold) {\n\t\t\thold->cfg = cfg;\n\t\t\treturn hold;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API void r_config_restore(RConfigHold *h) {\n\tRListIter *iter;\n\tRConfigHoldChar *hchar;\n\tRConfigHoldNum *hnum;\n\tif (h) {\n\t\tr_list_foreach (h->list_num, iter, hnum) {\n\t\t\t(void)r_config_set_i (h->cfg, hnum->key, hnum->value);\n\t\t}\n\t\tr_list_foreach (h->list_char, iter, hchar) {\n\t\t\t(void)r_config_set (h->cfg, hchar->key, hchar->value);\n\t\t}\n\t}\n}\n\nR_API void r_config_hold_free(RConfigHold *h) {\n\tif (h) {\n\t\tr_list_free (h->list_num);\n\t\tr_list_free (h->list_char);\n\t\tR_FREE (h);\n\t}\n}\n", "/* radare - LGPL - Copyright 2011-2017 - earada, pancake */\n\n#include <r_core.h>\n#include \"r_util.h\"\n\n#define is_in_range(at, from, sz) ((at) >= (from) && (at) < ((from) + (sz)))\n\n#define VA_FALSE    0\n#define VA_TRUE     1\n#define VA_NOREBASE 2\n\n#define IS_MODE_SET(mode) (mode & R_CORE_BIN_SET)\n#define IS_MODE_SIMPLE(mode) (mode & R_CORE_BIN_SIMPLE)\n#define IS_MODE_SIMPLEST(mode) (mode & R_CORE_BIN_SIMPLEST)\n#define IS_MODE_JSON(mode) (mode & R_CORE_BIN_JSON)\n#define IS_MODE_RAD(mode) (mode & R_CORE_BIN_RADARE)\n#define IS_MODE_NORMAL(mode) (!mode)\n\n// dup from cmd_info\n#define PAIR_WIDTH 9\n\nstatic void pair(const char *a, const char *b, int mode, bool last) {\n\tif (!b || !(*b)) {\n\t\treturn;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tconst char *lst = last ? \"\" : \",\";\n\t\tr_cons_printf (\"\\\"%s\\\":%s%s\", a, b, lst);\n\t} else {\n\t\tchar ws[16];\n\t\tint al = strlen (a);\n\t\tal = PAIR_WIDTH - al;\n\t\tif (al < 0) {\n\t\t\tal = 0;\n\t\t}\n\t\tmemset (ws, ' ', al);\n\t\tws[al] = 0;\n\t\tr_cons_printf (\"%s%s%s\\n\", a, ws, b);\n\t}\n}\n\nstatic void pair_bool(const char *a, bool t, int mode, bool last) {\n\tpair (a, r_str_bool (t), mode, last);\n}\n\nstatic void pair_int(const char *a, int n, int mode, bool last) {\n\tpair (a, sdb_fmt (0, \"%d\", n), mode, last);\n}\n\nstatic void pair_str(const char *a, const char *b, int mode, int last) {\n\tif (IS_MODE_JSON (mode)) {\n\t\tif (!b) {\n\t\t\tb = \"\";\n\t\t}\n\t\tchar *eb = r_str_utf16_encode (b, -1);\n\t\tif (eb) {\n\t\t\tpair (a, sdb_fmt (0, \"\\\"%s\\\"\", eb), mode, last);\n\t\t\tfree (eb);\n\t\t}\n\t} else {\n\t\tpair (a, b, mode, last);\n\t}\n}\n\n#define STR(x) (x)?(x):\"\"\nR_API int r_core_bin_set_cur (RCore *core, RBinFile *binfile);\n\nstatic ut64 rva(RBin *bin, ut64 paddr, ut64 vaddr, int va) {\n\tif (va == VA_TRUE) {\n\t\treturn r_bin_get_vaddr (bin, paddr, vaddr);\n\t}\n\tif (va == VA_NOREBASE) {\n\t\treturn vaddr;\n\t}\n\treturn paddr;\n}\n\nR_API int r_core_bin_set_by_fd(RCore *core, ut64 bin_fd) {\n\tif (r_bin_file_set_cur_by_fd (core->bin, bin_fd)) {\n\t\tr_core_bin_set_cur (core, r_core_bin_cur (core));\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API int r_core_bin_set_by_name(RCore *core, const char * name) {\n\tif (r_bin_file_set_cur_by_name (core->bin, name)) {\n\t\tr_core_bin_set_cur (core, r_core_bin_cur (core));\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API int r_core_bin_set_env(RCore *r, RBinFile *binfile) {\n\tRBinObject *binobj = binfile ? binfile->o: NULL;\n\tRBinInfo *info = binobj ? binobj->info: NULL;\n\tif (info) {\n\t\tint va = info->has_va;\n\t\tchar * arch = strdup(info->arch);\n\t\tchar * cpu = info->cpu? strdup(info->cpu): NULL;\n\t\tut16 bits = info->bits;\n\t\tut64 baseaddr = r_bin_get_baddr (r->bin);\n\t\t/* Hack to make baddr work on some corner */\n\t\tr_config_set_i (r->config, \"io.va\",\n\t\t\t(binobj->info)? binobj->info->has_va: 0);\n\t\tr_config_set_i (r->config, \"bin.baddr\", baseaddr);\n\t\tr_config_set (r->config, \"asm.arch\", arch);\n\t\tr_config_set_i (r->config, \"asm.bits\", bits);\n\t\tr_config_set (r->config, \"anal.arch\", arch);\n\t\tif (cpu && *cpu) {\n\t\t\tr_config_set (r->config, \"anal.cpu\", cpu);\n\t\t} else {\n\t\t\tr_config_set (r->config, \"anal.cpu\", arch);\n\t\t}\n\t\tr_asm_use (r->assembler, arch);\n\t\tr_core_bin_info (r, R_CORE_BIN_ACC_ALL, R_CORE_BIN_SET, va, NULL, NULL);\n\t\tr_core_bin_set_cur (r, binfile);\n\t\tfree (cpu);\n\t\tfree (arch);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API int r_core_bin_set_cur(RCore *core, RBinFile *binfile) {\n\tif (!core->bin) {\n\t\treturn false;\n\t}\n\tif (!binfile) {\n\t\t// Find first available binfile\n\t\tut32 fd = r_core_file_cur_fd (core);\n\t\tbinfile = fd != (ut32)-1\n\t\t\t\t  ? r_bin_file_find_by_fd (core->bin, fd)\n\t\t\t\t  : NULL;\n\t\tif (!binfile) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tr_bin_file_set_cur_binfile (core->bin, binfile);\n\treturn true;\n}\n\nR_API int r_core_bin_refresh_strings(RCore *r) {\n\treturn r_bin_reset_strings (r->bin) ? true: false;\n}\n\nR_API RBinFile * r_core_bin_cur(RCore *core) {\n\tRBinFile *binfile = r_bin_cur (core->bin);\n\treturn binfile;\n}\n\nstatic bool string_filter(RCore *core, const char *str) {\n\tint i;\n\t/* pointer/rawdata detection */\n\tif (core->bin->strpurge) {\n\t\tut8 bo[0x100];\n\t\tint up = 0;\n\t\tint lo = 0;\n\t\tint ot = 0;\n\t\tint di = 0;\n\t\tint ln = 0;\n\t\tint sp = 0;\n\t\tint nm = 0;\n\t\tfor (i = 0; i < 0x100; i++) {\n\t\t\tbo[i] = 0;\n\t\t}\n\t\tfor (i = 0; str[i]; i++) {\n\t\t\tif (IS_DIGIT(str[i])) {\n\t\t\t\tnm++;\n\t\t\t} else if (str[i]>='a' && str[i]<='z') {\n\t\t\t\tlo++;\n\t\t\t} else if (str[i]>='A' && str[i]<='Z') {\n\t\t\t\tup++;\n\t\t\t} else {\n\t\t\t\tot++;\n\t\t\t}\n\t\t\tif (str[i]=='\\\\') {\n\t\t\t\tot++;\n\t\t\t}\n\t\t\tif (str[i]==' ') {\n\t\t\t\tsp++;\n\t\t\t}\n\t\t\tbo[(ut8)str[i]] = 1;\n\t\t\tln++;\n\t\t}\n\t\tfor (i = 0; i<0x100; i++) {\n\t\t\tif (bo[i]) {\n\t\t\t\tdi++;\n\t\t\t}\n\t\t}\n\t\tif (ln > 2 && str[0] != '_') {\n\t\t\tif (ln < 10) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (ot >= (nm + up + lo)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (lo < 3) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (core->bin->strfilter) {\n\tcase 'U': // only uppercase strings\n\t\tfor (i = 0; str[i]; i++) {\n\t\t\tchar ch = str[i];\n\t\t\tif (ch == ' ') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ch < '@'|| ch > 'Z') {\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (ch < 0 || !IS_PRINTABLE (ch)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (str[0] && str[1]) {\n\t\t\tfor (i = 2; i<6 && str[i]; i++) {\n\t\t\t\tif (str[i] == str[0]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (str[i] == str[1]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (str[0] == str[2]) {\n\t\t\treturn false; // rm false positives\n\t\t}\n\t\tbreak;\n\tcase 'a': // only alphanumeric - plain ascii\n\t\tfor (i = 0; str[i]; i++) {\n\t\t\tchar ch = str[i];\n\t\t\tif (ch < 1 || !IS_PRINTABLE (ch)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'e': // emails\n\t\tif (str && *str) {\n\t\t\tif (!strstr (str + 1, \"@\")) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!strstr (str + 1, \".\")) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase 'f': // format-string\n\t\tif (str && *str) {\n\t\t\tif (!strstr (str+1, \"%\"))\n\t\t\t\treturn false;\n\t\t} else return false;\n\t\tbreak;\n\tcase 'u': // URLs\n\t\tif (!strstr (str, \"://\")) {\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n        case 'i': //IPV4\n\t\t{\n\t\t\tint segment = 0;\n\t\t\tint segmentsum = 0;\n\t\t\tbool prevd = false;\n\t\t\tfor (i = 0; str[i]; i++) {\n\t\t\t\tchar ch = str[i];\n\t\t\t\tif (IS_DIGIT(ch)) {\n\t\t\t\t\tsegmentsum = segmentsum*10 + (ch - '0');\n\t\t\t\t\tif (segment == 3) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tprevd = true;\n\t\t\t\t} else if (ch == '.') {\n\t\t\t\t\tif (prevd == true && segmentsum < 256){\n\t\t\t\t\t\tsegment++;\n\t\t\t\t\t\tsegmentsum = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsegmentsum = 0;\n\t\t\t\t\t\tsegment = 0;\n\t\t\t\t\t}\n\t\t\t\t\tprevd = false;\n\t\t\t\t} else {\n\t\t\t\t\tsegmentsum = 0;\n\t\t\t\t\tprevd = false;\n\t\t\t\t\tsegment = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\tcase 'p': // path\n\t\tif (str[0] != '/') {\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase '8': // utf8\n\t\tfor (i = 0; str[i]; i++) {\n\t\t\tchar ch = str[i];\n\t\t\tif (ch < 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void _print_strings(RCore *r, RList *list, int mode, int va) {\n\tint minstr = r_config_get_i (r->config, \"bin.minstr\");\n\tint maxstr = r_config_get_i (r->config, \"bin.maxstr\");\n\tRBin *bin = r->bin;\n\tRListIter *iter;\n\tRBinString *string;\n\tRBinSection *section;\n\tchar *q;\n\n\tbin->minstrlen = minstr;\n\tbin->maxstrlen = maxstr;\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"[\");\n\t}\n\tif (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"fs strings\");\n\t}\n\tif (IS_MODE_SET (mode) && r_config_get_i (r->config, \"bin.strings\")) {\n\t\tr_flag_space_set (r->flags, \"strings\");\n\t\tr_cons_break_push (NULL, NULL);\n\t}\n\tr_list_foreach (list, iter, string) {\n\t\tconst char *section_name, *type_string;\n\t\tut64 paddr, vaddr, addr;\n\t\tif (!string_filter (r, string->string)) {\n\t\t\tcontinue;\n\t\t}\n\t\tpaddr = string->paddr;\n\t\tvaddr = r_bin_get_vaddr (bin, paddr, string->vaddr);\n\t\taddr = va ? vaddr : paddr;\n\t\tif (string->length < minstr) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (maxstr && string->length > maxstr) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tsection = r_bin_get_section_at (r_bin_cur_object (bin), paddr, 0);\n\t\tsection_name = section ? section->name : \"unknown\";\n\t\ttype_string = r_bin_string_type (string->type);\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\tchar *f_name, *str;\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_meta_add (r->anal, R_META_TYPE_STRING, addr, addr + string->size, string->string);\n\t\t\tf_name = strdup (string->string);\n\t\t\tr_name_filter (f_name, -1);\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tstr = r_str_newf (\"%s.str.%s\", r->bin->prefix, f_name);\n\t\t\t} else {\n\t\t\t\tstr = r_str_newf (\"str.%s\", f_name);\n\t\t\t}\n\t\t\tr_flag_set (r->flags, str, addr, string->size);\n\t\t\tfree (str);\n\t\t\tfree (f_name);\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tr_cons_printf (\"0x%\"PFMT64x\" %d %d %s\\n\", addr, string->size, string->length, string->string);\n\t\t} else if (IS_MODE_SIMPLEST (mode)) {\n\t\t\tr_cons_println (string->string);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tq = r_base64_encode_dyn (string->string, -1);\n\t\t\tr_cons_printf (\"%s{\\\"vaddr\\\":%\"PFMT64d\n\t\t\t\t\",\\\"paddr\\\":%\"PFMT64d\",\\\"ordinal\\\":%d\"\n\t\t\t\t\",\\\"size\\\":%d,\\\"length\\\":%d,\\\"section\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\\\"string\\\":\\\"%s\\\"}\",\n\t\t\t\titer->p ? \",\": \"\",\n\t\t\t\tvaddr, paddr, string->ordinal, string->size,\n\t\t\t\tstring->length, section_name, type_string, q);\n\t\t\tfree (q);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tchar *f_name, *str;\n\t\t\tf_name = strdup (string->string);\n\t\t\tr_name_filter (f_name, R_FLAG_NAME_SIZE);\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tstr = r_str_newf (\"%s.str.%s\", r->bin->prefix, f_name);\n\t\t\t\tr_cons_printf (\"f %s.str.%s %\"PFMT64d\" @ 0x%08\"PFMT64x\"\\n\"\n\t\t\t\t\t\"Cs %\"PFMT64d\" @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\tr->bin->prefix, f_name, string->size, addr,\n\t\t\t\t\tstring->size, addr);\n\t\t\t} else {\n\t\t\t\tstr = r_str_newf (\"str.%s\", f_name);\n\t\t\t\tr_cons_printf (\"f str.%s %\"PFMT64d\" @ 0x%08\"PFMT64x\"\\n\"\n\t\t\t\t\t\"Cs %\"PFMT64d\" @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\tf_name, string->size, addr,\n\t\t\t\t\tstring->size, addr);\n\t\t\t}\n\t\t\tfree (str);\n\t\t\tfree (f_name);\n\t\t} else {\n\t\t\tr_cons_printf (\"vaddr=0x%08\"PFMT64x\" paddr=0x%08\"\n\t\t\t\tPFMT64x\" ordinal=%03u sz=%u len=%u \"\n\t\t\t\t\"section=%s type=%s string=%s\\n\",\n\t\t\t\tvaddr, paddr, string->ordinal, string->size,\n\t\t\t\tstring->length, section_name, type_string,\n\t\t\t\tstring->string);\n\t\t}\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"]\");\n\t}\n\tif (IS_MODE_SET (mode)) {\n\t\tr_cons_break_pop ();\n\t}\n}\n\nstatic bool bin_raw_strings(RCore *r, int mode, int va) {\n\tRBinFile *bf = r_bin_cur (r->bin);\n\tif (!bf && r->io && r->io->desc && r->io->desc->uri) {\n\t\tconst char *file = r->io->desc->uri;\n\t\tr_sys_cmdf (\"rabin2 -qzzz '%s'\", file);\n\t\t// eprintf (\"Likely you used -nn \\n\");\n\t\t// eprintf (\"try: .!rabin2 -B <baddr> -zzr filename\\n\");\n\t\treturn false;\n\t}\n\tif (bf && strstr (bf->file, \"malloc://\")) {\n\t\t//sync bf->buf to search string on it\n\t\tr_io_read_at (r->io, 0, bf->buf->buf, bf->size);\n\t}\n\tif (!r->file) {\n\t\teprintf (\"Core file not open\\n\");\n\t\treturn false;\n\t}\n\tRList *l = r_bin_raw_strings (bf, 0);\n\t_print_strings (r, l, mode, va);\n\treturn true;\n}\n\nstatic bool bin_strings(RCore *r, int mode, int va) {\n\tRList *list;\n\tRBinFile *binfile = r_core_bin_cur (r);\n\tRBinPlugin *plugin = r_bin_file_cur_plugin (binfile);\n\tint rawstr = r_config_get_i (r->config, \"bin.rawstr\");\n\tif (!binfile) {\n\t\treturn false;\n\t}\n\tif (!r_config_get_i (r->config, \"bin.strings\")) {\n\t\treturn 0;\n\t}\n\tif (!plugin) {\n\t\treturn 0;\n\t}\n\tif (plugin->info && plugin->name) {\n\t\tif (strcmp (plugin->name, \"any\") == 0 && !rawstr) {\n\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\tr_cons_print(\"[]\");\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (!(list = r_bin_get_strings (r->bin))) {\n\t\treturn false;\n\t}\n\t_print_strings (r, list, mode, va);\n\treturn true;\n}\n\nstatic const char* get_compile_time(Sdb *binFileSdb) {\n\tSdb *info_ns = sdb_ns (binFileSdb, \"info\", false);\n\tconst char *timeDateStamp_string = sdb_const_get (info_ns,\n\t\t\"image_file_header.TimeDateStamp_string\", 0);\n\treturn timeDateStamp_string;\n}\n\nstatic int is_executable(RBinObject *obj) {\n\tRListIter *it;\n\tRBinSection* sec;\n\tif (obj) {\n\t\tif (obj->info && obj->info->arch) {\n\t\t\treturn true;\n\t\t}\n\t\tr_list_foreach (obj->sections, it, sec) {\n\t\t\tif (R_BIN_SCN_EXECUTABLE & sec->srwx) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n#define DBSPATH R2_PREFIX \"/share/radare2/\" R2_VERSION \"/fcnsign\"\nstatic void sdb_concat_by_path(Sdb *s, const char *path) {\n\tSdb *db = sdb_new (0, path, 0);\n\tsdb_merge (s, db);\n\tsdb_close (db);\n\tsdb_free (db);\n}\n\nR_API void r_core_anal_type_init(RCore *core) {\n\tSdb *types = NULL;\n\tconst char *anal_arch = NULL, *os = NULL;\n\tint bits = 0;\n\tchar *dbpath;\n\tif (!core || !core->anal) {\n\t\treturn;\n\t}\n\tbits = core->assembler->bits;\n\ttypes = core->anal->sdb_types;\n \t// make sure they are empty this is initializing\n\tsdb_reset (types);\n\tanal_arch = r_config_get (core->config, \"anal.arch\");\n\tos = r_config_get (core->config, \"asm.os\");\n\tif (r_file_exists (DBSPATH\"/types.sdb\")) {\n\t\tsdb_concat_by_path (types, DBSPATH\"/types.sdb\");\n\t}\n\tdbpath = sdb_fmt (-1, DBSPATH\"/types-%s.sdb\", anal_arch);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (-1, DBSPATH\"/types-%s.sdb\", os);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (-1, DBSPATH\"/types-%d.sdb\", bits);\n\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (-1, DBSPATH\"/types-%s-%d.sdb\", os, bits);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (-1, DBSPATH\"/types-%s-%d.sdb\", anal_arch, bits);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (-1, DBSPATH\"/types-%s-%s.sdb\", anal_arch, os);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (-1, DBSPATH\"/types-%s-%s-%d.sdb\", anal_arch, os, bits);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n}\n\nstatic int save_ptr(void *p, const char *k, const char *v) {\n\tSdb *sdbs[2];\n\tsdbs[0] = ((Sdb**) p)[0];\n\tsdbs[1] = ((Sdb**) p)[1];\n\tif (!strncmp (v, \"cc\", strlen (\"cc\") + 1)) {\n\t\tconst char *x = sdb_const_get (sdbs[1], sdb_fmt (-1, \"cc.%s.name\", k), 0);\n\t\tchar *tmp = sdb_fmt (-1, \"%p\", x);\n\t\tsdb_set (sdbs[0], tmp, x, 0);\n\t}\n\treturn 1;\n}\n\nR_API void r_core_anal_cc_init(RCore *core) {\n\tSdb *sdbs[2] = {\n\t\tsdb_new0 (),\n\t\tcore->anal->sdb_cc\n\t};\n\t//save pointers and values stored inside them\n\t//to recover from freeing heeps\n\tconst char *defaultcc = sdb_const_get (sdbs[1], \"default.cc\", 0);\n\tsdb_set (sdbs[0], sdb_fmt (-1, \"0x%08\"PFMT64x, r_num_get (NULL, defaultcc)), defaultcc, 0);\n\tsdb_foreach (core->anal->sdb_cc, save_ptr, sdbs);\n\tsdb_reset ( core->anal->sdb_cc);\n\tconst char *anal_arch = r_config_get (core->config, \"anal.arch\");\n\n\tint bits = core->anal->bits;\n\tif (bits == 16 && !strcmp (anal_arch, \"arm\")) {\n\t\tbits = 32;\n\t}\n\n\tchar *dbpath = sdb_fmt (-1, DBSPATH\"/cc-%s-%d.sdb\", anal_arch, bits);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (core->anal->sdb_cc, dbpath);\n\t}\n\t//restore all freed CC or replace with new default cc\n\tRListIter *it;\n\tRAnalFunction *fcn;\n\tr_list_foreach (core->anal->fcns, it, fcn) {\n\t\tchar *ptr = sdb_fmt (-1, \"%p\", fcn->cc);\n\t\tconst char *cc = sdb_const_get (sdbs[0], ptr, 0);\n\t\tif (cc) {\n\t\t\tfcn->cc = r_anal_cc_to_constant (core->anal, (char *)cc);\n\t\t}\n\t\tif (!fcn->cc) {\n\t\t\tfcn->cc = r_anal_cc_default (core->anal);\n\t\t}\n\t\tfcn->cc = r_str_const (fcn->cc);\n\t}\n\tsdb_close (sdbs[0]);\n\tsdb_free (sdbs[0]);\n}\n#undef DBSPATH\n\nstatic int bin_info(RCore *r, int mode) {\n\tint i, j, v;\n\tchar str[R_FLAG_NAME_SIZE];\n\tRBinInfo *info = r_bin_get_info (r->bin);\n\tRBinFile *binfile = r_core_bin_cur (r);\n\tRBinObject *obj = r_bin_cur_object (r->bin);\n\tconst char *compiled = NULL;\n\tbool havecode;\n\n\tif (!binfile || !info || !obj) {\n\t\tif (mode & R_CORE_BIN_JSON) {\n\t\t\tr_cons_printf (\"{}\");\n\t\t}\n\t\treturn false;\n\t}\n\thavecode = is_executable (obj) | (obj->entries != NULL);\n\tcompiled = get_compile_time (binfile->sdb);\n\n\tif (IS_MODE_SET (mode)) {\n\t\tr_config_set (r->config, \"file.type\", info->rclass);\n\t\tr_config_set (r->config, \"cfg.bigendian\",\n\t\t\t      info->big_endian ? \"true\" : \"false\");\n\t\tif (info->rclass && !strcmp (info->rclass, \"fs\")) {\n\t\t\tr_config_set (r->config, \"asm.arch\", info->arch);\n\t\t\tr_core_cmdf (r, \"m /root %s 0\", info->arch);\n\t\t} else {\n\t\t\tif (info->lang) {\n\t\t\t\tr_config_set (r->config, \"bin.lang\", info->lang);\n\t\t\t}\n\t\t\tr_config_set (r->config, \"asm.os\", info->os);\n\t\t\tr_config_set (r->config, \"asm.arch\", info->arch);\n\t\t\tr_config_set (r->config, \"anal.arch\", info->arch);\n\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"%i\", info->bits);\n\t\t\tr_config_set (r->config, \"asm.bits\", str);\n\t\t\tr_config_set (r->config, \"asm.dwarf\",\n\t\t\t\t(R_BIN_DBG_STRIPPED & info->dbg_info) ? \"false\" : \"true\");\n\t\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_ALIGN);\n\t\t\tif (v != -1) r_config_set_i (r->config, \"asm.pcalign\", v);\n\t\t}\n\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\tr_cons_printf (\"arch %s\\n\", info->arch);\n\t\tr_cons_printf (\"bits %d\\n\", info->bits);\n\t\tr_cons_printf (\"os %s\\n\", info->os);\n\t\tr_cons_printf (\"endian %s\\n\", info->big_endian? \"big\": \"little\");\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);\n\t\tif (v != -1) {\n\t\t\tr_cons_printf (\"minopsz %d\\n\", v);\n\t\t}\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_MAX_OP_SIZE);\n\t\tif (v != -1) {\n\t\t\tr_cons_printf (\"maxopsz %d\\n\", v);\n\t\t}\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_ALIGN);\n\t\tif (v != -1) {\n\t\t\tr_cons_printf (\"pcalign %d\\n\", v);\n\t\t}\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tif (info->type && !strcmp (info->type, \"fs\")) {\n\t\t\tr_cons_printf (\"e file.type=fs\\n\");\n\t\t\tr_cons_printf (\"m /root %s 0\\n\", info->arch);\n\t\t} else {\n\t\t\tr_cons_printf (\"e cfg.bigendian=%s\\n\"\n\t\t\t\t\"e asm.bits=%i\\n\"\n\t\t\t\t\"e asm.dwarf=%s\\n\",\n\t\t\t\tr_str_bool (info->big_endian),\n\t\t\t\tinfo->bits,\n\t\t\t\tr_str_bool (R_BIN_DBG_STRIPPED &info->dbg_info));\n\t\t\tif (info->lang && *info->lang) {\n\t\t\t\tr_cons_printf (\"e bin.lang=%s\\n\", info->lang);\n\t\t\t}\n\t\t\tif (info->rclass && *info->rclass) {\n\t\t\t\tr_cons_printf (\"e file.type=%s\\n\",\n\t\t\t\t\tinfo->rclass);\n\t\t\t}\n\t\t\tif (info->os) {\n\t\t\t\tr_cons_printf (\"e asm.os=%s\\n\", info->os);\n\t\t\t}\n\t\t\tif (info->arch) {\n\t\t\t\tr_cons_printf (\"e asm.arch=%s\\n\", info->arch);\n\t\t\t}\n\t\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_ALIGN);\n\t\t\tif (v != -1) r_cons_printf (\"e asm.pcalign=%d\\n\", v);\n\t\t}\n\t} else {\n\t\t// XXX: if type is 'fs' show something different?\n\t\tchar *tmp_buf;\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"{\");\n\t\t}\n\t\tpair_str (\"arch\", info->arch, mode, false);\n\t\tpair_int (\"binsz\", r_bin_get_size (r->bin), mode, false);\n\t\tpair_str (\"bintype\", info->rclass, mode, false);\n\t\tpair_int (\"bits\", info->bits, mode, false);\n\t\tpair_bool (\"canary\", info->has_canary, mode, false);\n\t\tpair_str (\"class\", info->bclass, mode, false);\n\t\tif (info->actual_checksum) {\n\t\t\t/* computed checksum */\n\t\t\tpair_str (\"cmp.csum\", info->actual_checksum, mode, false);\n\t\t}\n\t\tpair_str (\"compiled\", compiled, mode, false);\n\t\tpair_bool (\"crypto\", info->has_crypto, mode, false);\n\t\ttmp_buf = r_str_escape (info->debug_file_name);\n\t\tpair_str (\"dbg_file\", tmp_buf, mode, false);\n\t\tfree (tmp_buf);\n\t\tpair_str (\"endian\", info->big_endian ? \"big\" : \"little\", mode, false);\n\t\tpair_bool (\"havecode\", havecode, mode, false);\n\t\tif (info->claimed_checksum) {\n\t\t\t/* checksum specified in header */\n\t\t\tpair_str (\"hdr.csum\", info->claimed_checksum, mode, false);\n\t\t}\n\t\tpair_str (\"guid\", info->guid, mode, false);\n\t\tpair_str (\"intrp\", info->intrp, mode, false);\n\t\tpair_str (\"lang\", info->lang, mode, false);\n\t\tpair_bool (\"linenum\", R_BIN_DBG_LINENUMS & info->dbg_info, mode, false);\n\t\tpair_bool (\"lsyms\", R_BIN_DBG_SYMS & info->dbg_info, mode, false);\n\t\tpair_str (\"machine\", info->machine, mode, false);\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_MAX_OP_SIZE);\n\t\tif (v != -1) {\n\t\t\tpair_int (\"maxopsz\", v, mode, false);\n\t\t}\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);\n\t\tif (v != -1) {\n\t\t\tpair_int (\"minopsz\", v, mode, false);\n\t\t}\n\t\tpair_bool (\"nx\", info->has_nx, mode, false);\n\t\tpair_str (\"os\", info->os, mode, false);\n\t\tif (info->rclass && !strcmp (info->rclass, \"pe\")) {\n\t\t\tpair_bool (\"overlay\", info->pe_overlay, mode, false);\n\t\t}\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_ALIGN);\n\t\tif (v != -1) {\n\t\t\tpair_int (\"pcalign\", v, mode, false);\n\t\t}\n\t\tpair_bool (\"pic\", info->has_pi, mode, false);\n\t\tpair_bool (\"relocs\", R_BIN_DBG_RELOCS & info->dbg_info, mode, false);\n\t\ttmp_buf = sdb_get (obj->kv, \"elf.relro\", 0);\n\t\tif (tmp_buf) {\n\t\t\tpair_str (\"relro\", tmp_buf, mode, false);\n\t\t\tfree (tmp_buf);\n\t\t}\n\t\tpair_str (\"rpath\", info->rpath, mode, false);\n\t\tif (info->rclass && !strcmp (info->rclass, \"pe\")) {\n\t\t\t//this should be moved if added to mach0 (or others)\n\t\t\tpair_bool (\"signed\", info->signature, mode, false);\n\t\t}\n\t\tpair_bool (\"static\", r_bin_is_static (r->bin), mode, false);\n\t\tpair_bool (\"stripped\", R_BIN_DBG_STRIPPED & info->dbg_info, mode, false);\n\t\tpair_str (\"subsys\", info->subsystem, mode, false);\n\t\tpair_bool (\"va\", info->has_va, mode, true);\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\",\\\"checksums\\\":{\");\n\t\t\tfor (i = 0; info->sum[i].type; i++) {\n\t\t\t\tRBinHash *h = &info->sum[i];\n\t\t\t\tut64 hash = r_hash_name_to_bits (h->type);\n\t\t\t\tRHash *rh = r_hash_new (true, hash);\n\t\t\t\tint len = r_hash_calculate (rh, hash, (const ut8*)\n\t\t\t\t\t\tbinfile->buf->buf+h->from, h->to);\n\t\t\t\tif (len < 1) {\n\t\t\t\t\teprintf (\"Invaild checksum length\\n\");\n\t\t\t\t}\n\t\t\t\tr_hash_free (rh);\n\t\t\t\tr_cons_printf (\"%s\\\"%s\\\":{\\\"hex\\\":\\\"\", i?\",\": \"\", h->type);\n\t\t\t\t// r_cons_printf (\"%s\\t%d-%dc\\t\", h->type, h->from, h->to+h->from);\n\t\t\t\tfor (j = 0; j < h->len; j++) {\n\t\t\t\t\tr_cons_printf (\"%02x\", h->buf[j]);\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"\\\"}\");\n\t\t\t}\n\t\t\tr_cons_printf (\"}\");\n\t\t} else {\n\t\t\tfor (i = 0; info->sum[i].type; i++) {\n\t\t\t\tRBinHash *h = &info->sum[i];\n\t\t\t\tut64 hash = r_hash_name_to_bits (h->type);\n\t\t\t\tRHash *rh = r_hash_new (true, hash);\n\t\t\t\tint len = r_hash_calculate (rh, hash, (const ut8*)\n\t\t\t\t\t\tbinfile->buf->buf+h->from, h->to);\n\t\t\t\tif (len < 1) {\n\t\t\t\t\teprintf (\"Invaild wtf\\n\");\n\t\t\t\t}\n\t\t\t\tr_hash_free (rh);\n\t\t\t\tr_cons_printf (\"%s\\t%d-%dc\\t\", h->type, h->from, h->to+h->from);\n\t\t\t\tfor (j = 0; j < h->len; j++) {\n\t\t\t\t\tr_cons_printf (\"%02x\", h->buf[j]);\n\t\t\t\t}\n\t\t\t\tr_cons_newline ();\n\t\t\t}\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) r_cons_printf (\"}\");\n\t}\n\tr_core_anal_type_init (r);\n\tr_core_anal_cc_init (r);\n\treturn true;\n}\n\nstatic int bin_dwarf(RCore *core, int mode) {\n\tRBinDwarfRow *row;\n\tRListIter *iter;\n\tRList *list = NULL;\n\tRBinFile *binfile = r_core_bin_cur (core);\n\tRBinPlugin * plugin = r_bin_file_cur_plugin (binfile);\n\tif (!binfile) {\n\t\treturn false;\n\t}\n\tif (plugin && plugin->lines) {\n\t\tlist = plugin->lines (binfile);\n\t} else if (core->bin) {\n\t\t// TODO: complete and speed-up support for dwarf\n\t\tif (r_config_get_i (core->config, \"bin.dbginfo\")) {\n\t\t\tRBinDwarfDebugAbbrev *da = NULL;\n\t\t\tda = r_bin_dwarf_parse_abbrev (core->bin, mode);\n\t\t\tr_bin_dwarf_parse_info (da, core->bin, mode);\n\t\t\tr_bin_dwarf_parse_aranges (core->bin, mode);\n\t\t\tlist = r_bin_dwarf_parse_line (core->bin, mode);\n\t\t\tr_bin_dwarf_free_debug_abbrev (da);\n\t\t\tfree (da);\n\t\t}\n\t}\n\tif (!list) {\n\t\treturn false;\n\t}\n\n\tr_cons_break_push (NULL, NULL);\n\t/* cache file:line contents */\n\tconst char *lastFile = NULL;\n\tint *lastFileLines = NULL;\n\tchar *lastFileContents = NULL;\n\tint lastFileLinesCount = 0;\n\n\t/* ugly dupe for speedup */\n\tconst char *lastFile2 = NULL;\n\tint *lastFileLines2 = NULL;\n\tchar *lastFileContents2 = NULL;\n\tint lastFileLinesCount2 = 0;\n\n\n\tconst char *lf = NULL;\n\tint *lfl = NULL;\n\tchar *lfc = NULL;\n\tint lflc = 0;\n\n\t//TODO we should need to store all this in sdb, or do a filecontentscache in libr/util\n\t//XXX this whole thing has leaks\n\tr_list_foreach (list, iter, row) {\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tif (mode) {\n\t\t\t// TODO: use 'Cl' instead of CC\n\t\t\tconst char *path = row->file;\n\t\t\tif (!lastFile || strcmp (path, lastFile)) {\n\t\t\t\tif (lastFile && lastFile2 && !strcmp (path, lastFile2)) {\n\t\t\t\t\tlf = lastFile;\n\t\t\t\t\tlfl = lastFileLines;\n\t\t\t\t\tlfc = lastFileContents;\n\t\t\t\t\tlflc = lastFileLinesCount;\n\t\t\t\t\tlastFile = lastFile2;\n\t\t\t\t\tlastFileLines = lastFileLines2;\n\t\t\t\t\tlastFileContents = lastFileContents2;\n\t\t\t\t\tlastFileLinesCount = lastFileLinesCount2;\n\t\t\t\t\tlastFile2 = lf;\n\t\t\t\t\tlastFileLines2 = lfl;\n\t\t\t\t\tlastFileContents2 = lfc;\n\t\t\t\t\tlastFileLinesCount2 = lflc;\n\t\t\t\t} else {\n\t\t\t\t\tlastFile2 = lastFile;\n\t\t\t\t\tlastFileLines2 = lastFileLines;\n\t\t\t\t\tlastFileContents2 = lastFileContents;\n\t\t\t\t\tlastFileLinesCount2 = lastFileLinesCount;\n\t\t\t\t\tlastFile = path;\n\t\t\t\t\tlastFileContents = r_file_slurp (path, NULL);\n\t\t\t\t\tif (lastFileContents) {\n\t\t\t\t\t\tlastFileLines = r_str_split_lines (lastFileContents, &lastFileLinesCount);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tchar *line = NULL;\n\t\t\t//r_file_slurp_line (path, row->line - 1, 0);\n\t\t\tif (lastFileLines && lastFileContents) {\n\t\t\t\tint nl = row->line - 1;\n\t\t\t\tif (nl >= 0 && nl < lastFileLinesCount) {\n\t\t\t\t\tline = strdup (lastFileContents + lastFileLines[nl]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tline = NULL;\n\t\t\t}\n\t\t\tif (line) {\n\t\t\t\tr_str_filter (line, strlen (line));\n\t\t\t\tline = r_str_replace (line, \"\\\"\", \"\\\\\\\"\", 1);\n\t\t\t\tline = r_str_replace (line, \"\\\\\\\\\", \"\\\\\", 1);\n\t\t\t}\n\t\t\tbool chopPath = !r_config_get_i (core->config, \"dir.dwarf.abspath\");\n\t\t\tchar *file = strdup (row->file);\n\t\t\tif (chopPath) {\n\t\t\t\tconst char *slash = r_str_lchr (file, '/');\n\t\t\t\tif (slash) {\n\t\t\t\t\tmemmove (file, slash + 1, strlen (slash));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// TODO: implement internal : if ((mode & R_CORE_BIN_SET))\n\t\t\tif ((mode & R_CORE_BIN_SET)) {\n\t\t\t\t// TODO: use CL here.. but its not necessary.. so better not do anything imho\n\t\t\t\t// r_core_cmdf (core, \"CL %s:%d 0x%08\"PFMT64x, file, (int)row->line, row->address);\n#if 0\n\t\t\t\tchar *cmt = r_str_newf (\"%s:%d %s\", file, (int)row->line, line? line: \"\");\n\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, row->address, cmt);\n\t\t\t\tfree (cmt);\n#endif\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"CL %s:%d 0x%08\" PFMT64x \"\\n\",\n\t\t\t\t\t       file, (int)row->line,\n\t\t\t\t\t       row->address);\n\t\t\t\tr_cons_printf (\"\\\"CC %s:%d %s\\\"@0x%\" PFMT64x\n\t\t\t\t\t       \"\\n\",\n\t\t\t\t\t       file, row->line,\n\t\t\t\t\t       line ? line : \"\", row->address);\n\t\t\t}\n\t\t\tfree (file);\n\t\t\tfree (line);\n\t\t} else {\n\t\t\tr_cons_printf (\"0x%08\" PFMT64x \"\\t%s\\t%d\\n\",\n\t\t\t\t       row->address, row->file, row->line);\n\t\t}\n\t}\n\tr_cons_break_pop ();\n\tR_FREE (lastFileContents);\n\tR_FREE (lastFileContents2);\n\tr_list_free (list);\n\tfree (lastFileLines);\n\treturn true;\n}\n\nstatic int bin_pdb(RCore *core, int mode) {\n\tR_PDB pdb = R_EMPTY;\n\tut64 baddr = r_bin_get_baddr (core->bin);\n\n\tpdb.cb_printf = r_cons_printf;\n\tif (!init_pdb_parser (&pdb, core->bin->file)) {\n\t\treturn false;\n\t}\n\tif (!pdb.pdb_parse (&pdb)) {\n\t\teprintf (\"pdb was not parsed\\n\");\n\t\tpdb.finish_pdb_parse (&pdb);\n\t\treturn false;\n\t}\n\tif (mode == R_CORE_BIN_JSON) {\n\t\tr_cons_printf(\"[\");\n\t}\n\n\tswitch (mode) {\n\tcase R_CORE_BIN_SET:\n\t\tmode = 's';\n\t\tr_core_cmd0 (core, \".iP*\");\n\t\treturn true;\n\tcase R_CORE_BIN_JSON:\n\t\tmode = 'j';\n\t\tbreak;\n\tcase '*':\n\tcase 1:\n\t\tmode = 'r';\n\t\tbreak;\n\tdefault:\n\t\tmode = 'd'; // default\n\t\tbreak;\n\t}\n\n\tpdb.print_types (&pdb, mode);\n\tif (mode == 'j') {\n\t\tr_cons_printf (\",\");\n\t}\n\tpdb.print_gvars (&pdb, baddr, mode);\n\tif (mode == 'j') {\n\t\tr_cons_printf (\"]\");\n\t}\n\tpdb.finish_pdb_parse (&pdb);\n\n\treturn true;\n}\n\nstatic int bin_main(RCore *r, int mode, int va) {\n\tRBinAddr *binmain = r_bin_get_sym (r->bin, R_BIN_SYM_MAIN);\n\tut64 addr;\n\tif (!binmain) {\n\t\treturn false;\n\t}\n\taddr = va ? r_bin_a2b (r->bin, binmain->vaddr) : binmain->paddr;\n\n\tif (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, \"symbols\");\n\t\tr_flag_set (r->flags, \"main\", addr, r->blocksize);\n\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\tr_cons_printf (\"%\"PFMT64d, addr);\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"fs symbols\\n\");\n\t\tr_cons_printf (\"f main @ 0x%08\"PFMT64x\"\\n\", addr);\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"{\\\"vaddr\\\":%\" PFMT64d\n\t\t\t\",\\\"paddr\\\":%\" PFMT64d \"}\", addr, binmain->paddr);\n\t} else {\n\t\tr_cons_printf (\"[Main]\\n\");\n\t\tr_cons_printf (\"vaddr=0x%08\"PFMT64x\" paddr=0x%08\"PFMT64x\"\\n\",\n\t\t\taddr, binmain->paddr);\n\t}\n\treturn true;\n}\n\nstatic int bin_entry(RCore *r, int mode, ut64 laddr, int va) {\n\tchar str[R_FLAG_NAME_SIZE];\n\tRList *entries = r_bin_get_entries (r->bin);\n\tRListIter *iter;\n\tRBinAddr *entry = NULL;\n\tint i = 0;\n\tut64 baddr = r_bin_get_baddr (r->bin);\n\n\tif (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"fs symbols\\n\");\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"[\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"[Entrypoints]\\n\");\n\t}\n\n\tr_list_foreach (entries, iter, entry) {\n\t\tut64 paddr = entry->paddr;\n\t\tut64 haddr = UT64_MAX;\n\t\tif (entry->haddr) {\n\t\t\thaddr = entry->haddr;\n\t\t}\n\t\tut64 at = rva (r->bin, paddr, entry->vaddr, va);\n\t\tconst char *type = r_bin_entry_type_string (entry->type);\n\t\tif (!type) {\n\t\t\ttype = \"unknown\";\n\t\t}\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\tr_flag_space_set (r->flags, \"symbols\");\n\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"entry%i\", i);\n\t\t\tr_flag_set (r->flags, str, at, 1);\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"\\n\", at);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"%s{\\\"vaddr\\\":%\" PFMT64d \",\"\n\t\t\t\t\"\\\"paddr\\\":%\" PFMT64d \",\"\n\t\t\t\t\"\\\"baddr\\\":%\" PFMT64d \",\"\n\t\t\t\t\"\\\"laddr\\\":%\" PFMT64d \",\"\n\t\t\t\t\"\\\"haddr\\\":%\" PFMT64d \",\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\"}\",\n\t\t\t\titer->p ? \",\" : \"\", at, paddr, baddr, laddr, haddr, type);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"f entry%i 1 @ 0x%08\"PFMT64x\"\\n\", i, at);\n\t\t\tr_cons_printf (\"f entry%i_haddr 1 @ 0x%08\"PFMT64x\"\\n\", i, haddr);\n\t\t\tr_cons_printf (\"s entry%i\\n\", i);\n\t\t} else {\n\t\t\tr_cons_printf (\n\t\t\t\t \"vaddr=0x%08\"PFMT64x\n\t\t\t\t\" paddr=0x%08\"PFMT64x\n\t\t\t\t\" baddr=0x%08\"PFMT64x\n\t\t\t\t\" laddr=0x%08\"PFMT64x,\n\t\t\t\tat, paddr, baddr, laddr);\n\t\t\tif (haddr == UT64_MAX) {\n\t\t\t\tr_cons_printf (\n\t\t\t\t\t\" haddr=%\"PFMT64d\n\t\t\t\t\t\" type=%s\\n\",\n\t\t\t\t\thaddr, type);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\n\t\t\t\t\t\" haddr=0x%08\"PFMT64x\n\t\t\t\t\t\" type=%s\\n\",\n\t\t\t\t\thaddr, type);\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\tif (IS_MODE_SET (mode)) {\n\t\tif (entry) {\n\t\t\tut64 at = rva (r->bin, entry->paddr, entry->vaddr, va);\n\t\t\tr_core_seek (r, at, 0);\n\t\t}\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"]\");\n\t\tr_cons_newline ();\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"\\n%i entrypoints\\n\", i);\n\t}\n\treturn true;\n}\n\nstatic const char *bin_reloc_type_name(RBinReloc *reloc) {\n#define CASE(T) case R_BIN_RELOC_ ## T: return reloc->additive ? \"ADD_\" #T : \"SET_\" #T\n\tswitch (reloc->type) {\n\t\tCASE(8);\n\t\tCASE(16);\n\t\tCASE(32);\n\t\tCASE(64);\n\t}\n\treturn \"UNKNOWN\";\n#undef CASE\n}\n\nstatic ut8 bin_reloc_size(RBinReloc *reloc) {\n#define CASE(T) case R_BIN_RELOC_ ## T: return T / 8\n\tswitch (reloc->type) {\n\t\tCASE(8);\n\t\tCASE(16);\n\t\tCASE(32);\n\t\tCASE(64);\n\t}\n\treturn 0;\n#undef CASE\n}\n\nstatic char *resolveModuleOrdinal(Sdb *sdb, const char *module, int ordinal) {\n\tSdb *db = sdb;\n\tchar *foo = sdb_get (db, sdb_fmt (0, \"%d\", ordinal), 0);\n\treturn (foo && *foo) ? foo : NULL;\n}\n\nstatic char *get_reloc_name(RBinReloc *reloc, ut64 addr) {\n\tchar *reloc_name = NULL;\n\tif (reloc->import && reloc->import->name) {\n\t\treloc_name = sdb_fmt (-1, \"reloc.%s_%d\", reloc->import->name,\n\t\t\t\t      (int)(addr & 0xff));\n\t\tif (!reloc_name) {\n\t\t\treturn NULL;\n\t\t}\n\t\tr_str_replace_char (reloc_name, '$', '_');\n\t} else if (reloc->symbol && reloc->symbol->name) {\n\t\treloc_name = sdb_fmt (-1, \"reloc.%s_%d\", reloc->symbol->name, (int)(addr & 0xff));\n\t\tif (!reloc_name) {\n\t\t\treturn NULL;\n\t\t}\n\t\tr_str_replace_char (reloc_name, '$', '_');\n\t} else if (reloc->is_ifunc) {\n\t\t// addend is the function pointer for the resolving ifunc\n\t\treloc_name = sdb_fmt (-1, \"reloc.ifunc_%\"PFMT64x, reloc->addend);\n\t} else {\n\t\t// TODO(eddyb) implement constant relocs.\n\t}\n\treturn reloc_name;\n}\n\nstatic void set_bin_relocs(RCore *r, RBinReloc *reloc, ut64 addr, Sdb **db, char **sdb_module) {\n\tint bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tconst char *lang = r_config_get (r->config, \"bin.lang\");\n\tchar *reloc_name, *demname = NULL;\n\tbool is_pe = true;\n\tint is_sandbox = r_sandbox_enable (0);\n\n\tif (reloc->import && reloc->import->name[0]) {\n\t\tchar str[R_FLAG_NAME_SIZE];\n\t\tRFlagItem *fi;\n\n\t\tif (is_pe && !is_sandbox && strstr (reloc->import->name, \"Ordinal\")) {\n\t\t\tconst char *TOKEN = \".dll_Ordinal_\";\n\t\t\tchar *module = strdup (reloc->import->name);\n\t\t\tchar *import = strstr (module, TOKEN);\n\n\t\t\tr_str_case (module, false);\n\t\t\tif (import) {\n\t\t\t\tchar *filename = NULL;\n\t\t\t\tint ordinal;\n\t\t\t\t*import = 0;\n\t\t\t\timport += strlen (TOKEN);\n\t\t\t\tordinal = atoi (import);\n\t\t\t\tif (!*sdb_module || strcmp (module, *sdb_module)) {\n\t\t\t\t\tsdb_free (*db);\n\t\t\t\t\t*db = NULL;\n\t\t\t\t\tfree (*sdb_module);\n\t\t\t\t\t*sdb_module = strdup (module);\n\t\t\t\t\t/* always lowercase */\n\t\t\t\t\tfilename = sdb_fmt (1, \"%s.sdb\", module);\n\t\t\t\t\tr_str_case (filename, false);\n\t\t\t\t\tif (r_file_exists (filename)) {\n\t\t\t\t\t\t*db = sdb_new (NULL, filename, 0);\n\t\t\t\t\t} else {\n#if __WINDOWS__\n\t\t\t\t\t\tchar invoke_dir[MAX_PATH];\n\t\t\t\t\t\tif (r_sys_get_src_dir_w32(invoke_dir)) {\n\t\t\t\t\t\t\tfilename = sdb_fmt (1, \"%s/share/radare2/\"R2_VERSION \"/format/dll/%s.sdb\", invoke_dir, module);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfilename = sdb_fmt (1, \"share/radare2/\"R2_VERSION\"/format/dll/%s.sdb\", module);\n\t\t\t\t\t\t}\n#else\n\t\t\t\t\t\tfilename = sdb_fmt (1, R2_PREFIX\"/share/radare2/\" R2_VERSION\"/format/dll/%s.sdb\", module);\n#endif\n\t\t\t\t\t\tif (r_file_exists (filename)) {\n\t\t\t\t\t\t\t*db = sdb_new (NULL, filename, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (*db) {\n\t\t\t\t\t// ordinal-1 because we enumerate starting at 0\n\t\t\t\t\tchar *symname = resolveModuleOrdinal (*db, module, ordinal - 1);\n\t\t\t\t\tif (symname) {\n\t\t\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\t\t\treloc->import->name = r_str_newf\n\t\t\t\t\t\t\t\t(\"%s.%s.%s\", r->bin->prefix, module, symname);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treloc->import->name = r_str_newf\n\t\t\t\t\t\t\t\t(\"%s.%s\", module, symname);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (module);\n\t\t\tr_anal_hint_set_size (r->anal, reloc->vaddr, 4);\n\t\t\tr_meta_add (r->anal, R_META_TYPE_DATA, reloc->vaddr, reloc->vaddr+4, NULL);\n\t\t}\n\t\treloc_name = reloc->import->name;\n\t\tif (r->bin->prefix) {\n\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"%s.reloc.%s_%d\", r->bin->prefix, reloc_name, (int)(addr&0xff));\n\t\t} else {\n\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"reloc.%s_%d\", reloc_name, (int)(addr&0xff));\n\t\t}\n\t\tif (bin_demangle) {\n\t\t\tdemname = r_bin_demangle (r->bin->cur, lang, str, addr);\n\t\t}\n\t\tr_name_filter (str, 0);\n\t\tfi = r_flag_set (r->flags, str, addr, bin_reloc_size (reloc));\n\t\tif (demname) {\n\t\t\tchar *realname;\n\t\t\tif (r->bin->prefix) {\n\t\t\t\trealname = sdb_fmt (0, \"%s.reloc.%s\", r->bin->prefix, demname);\n\t\t\t} else {\n\t\t\t\trealname = sdb_fmt (0, \"reloc.%s\", demname);\n\t\t\t}\n\t\t\tr_flag_item_set_realname (fi, realname);\n\t\t}\n\t} else {\n\t\tchar *reloc_name = get_reloc_name (reloc, addr);\n\t\tr_flag_set (r->flags, reloc_name, addr, bin_reloc_size (reloc));\n\t}\n}\n\nstatic int bin_relocs(RCore *r, int mode, int va) {\n\tint bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tRList *relocs;\n\tRListIter *iter;\n\tRBinReloc *reloc = NULL;\n\tSdb *db = NULL;\n\tchar *sdb_module = NULL;\n\tint i = 0;\n\n\tva = VA_TRUE; // XXX relocs always vaddr?\n\t//this has been created for reloc object files\n\trelocs = r_bin_patch_relocs (r->bin);\n\tif (!relocs) {\n\t\trelocs = r_bin_get_relocs (r->bin);\n\t}\n\n\tif (IS_MODE_RAD (mode)) {\n\t\tr_cons_println (\"fs relocs\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_println (\"[Relocations]\");\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"[\");\n\t} else if (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, \"relocs\");\n\t}\n\tRBinFile * binfile = r->bin->cur;\n\tRBinObject *binobj = binfile ? binfile->o: NULL;\n\tRBinInfo *info = binobj ? binobj->info: NULL;\n\tint cdsz = info? (info->bits == 64? 8: info->bits == 32? 4: info->bits == 16 ? 4: 0): 0;\n\tr_list_foreach (relocs, iter, reloc) {\n\t\tut64 addr = rva (r->bin, reloc->paddr, reloc->vaddr, va);\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\tset_bin_relocs (r, reloc, addr, &db, &sdb_module);\n\t\t\tif (cdsz) {\n\t\t\t\tr_meta_add (r->anal, R_META_TYPE_DATA, reloc->vaddr, reloc->vaddr + cdsz, NULL);\n\t\t\t}\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"  %s\\n\", addr, reloc->import ? reloc->import->name : \"\");\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tchar *name = reloc->import\n\t\t\t\t? strdup (reloc->import->name)\n\t\t\t\t: (reloc->symbol ? strdup (reloc->symbol->name) : NULL);\n\t\t\tif (name && bin_demangle) {\n\t\t\t\tchar *mn = r_bin_demangle (r->bin->cur, NULL, name, addr);\n\t\t\t\tif (mn) {\n\t\t\t\t\tfree (name);\n\t\t\t\t\tname = mn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (name) {\n\t\t\t\tr_cons_printf (\"f %s%s%s @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\tr->bin->prefix ? r->bin->prefix : \"reloc.\",\n\t\t\t\t\tr->bin->prefix ? \".\" : \"\", name, addr);\n\t\t\t\tif (cdsz) {\n\t\t\t\t\tr_cons_printf (\"f Cd %d @ 0x%08\"PFMT64x\"\\n\", cdsz, addr);\n\t\t\t\t}\n\t\t\t\tfree (name);\n\t\t\t}\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tif (iter->p) {\n\t\t\t\tr_cons_printf (\",{\\\"name\\\":\");\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"{\\\"name\\\":\");\n\t\t\t}\n\t\t\t// take care with very long symbol names! do not use sdb_fmt or similar\n\t\t\tif (reloc->import) {\n\t\t\t\tr_cons_printf (\"\\\"%s\\\"\", reloc->import->name);\n\t\t\t} else if (reloc->symbol) {\n\t\t\t\tr_cons_printf (\"\\\"%s\\\"\", reloc->symbol->name);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"null\");\n\t\t\t}\n\n\t\t\tr_cons_printf (\",\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"paddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"is_ifunc\\\":%s}\",\n\t\t\t\tbin_reloc_type_name (reloc),\n\t\t\t\treloc->vaddr, reloc->paddr,\n\t\t\t\tr_str_bool (reloc->is_ifunc));\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tchar *name = reloc->import\n\t\t\t\t? strdup (reloc->import->name)\n\t\t\t\t: reloc->symbol\n\t\t\t\t? strdup (reloc->symbol->name)\n\t\t\t\t: strdup (\"null\");\n\t\t\tif (bin_demangle) {\n\t\t\t\tchar *mn = r_bin_demangle (r->bin->cur, NULL, name, addr);\n\t\t\t\tif (mn && *mn) {\n\t\t\t\t\tfree (name);\n\t\t\t\t\tname = mn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_cons_printf (\"vaddr=0x%08\"PFMT64x\" paddr=0x%08\"PFMT64x\" type=%s\",\n\t\t\t\taddr, reloc->paddr, bin_reloc_type_name (reloc));\n\t\t\tif (reloc->import && reloc->import->name[0]) {\n\t\t\t\tr_cons_printf (\" %s\", name);\n\t\t\t} else if (reloc->symbol && name && name[0]) {\n\t\t\t\tr_cons_printf (\" %s\", name);\n\t\t\t}\n\t\t\tfree (name);\n\t\t\tif (reloc->addend) {\n\t\t\t\tif (reloc->import && reloc->addend > 0) {\n\t\t\t\t\tr_cons_printf (\" +\");\n\t\t\t\t}\n\t\t\t\tif (reloc->addend < 0) {\n\t\t\t\t\tr_cons_printf (\" - 0x%08\"PFMT64x, -reloc->addend);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\" 0x%08\"PFMT64x, reloc->addend);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (reloc->is_ifunc) {\n\t\t\t\tr_cons_print (\" (ifunc)\");\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t}\n\t\ti++;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"]\");\n\t}\n\tif (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"\\n%i relocations\\n\", i);\n\t}\n\treturn relocs != NULL;\n}\n\n#define MYDB 1\n/* this is a hacky workaround that needs proper refactoring in Rbin to use Sdb */\n#if MYDB\nstatic Sdb *mydb = NULL;\nstatic RList *osymbols = NULL;\n\nstatic RBinSymbol *get_symbol(RBin *bin, RList *symbols, const char *name, ut64 addr) {\n\tRBinSymbol *symbol, *res = NULL;\n\tRListIter *iter;\n\tif (mydb && symbols != osymbols) {\n\t\tsdb_free (mydb);\n\t\tmydb = NULL;\n\t\tosymbols = symbols;\n\t}\n\tif (mydb) {\n\t\tif (name) {\n\t\t\tres = (RBinSymbol*)(void*)(size_t)\n\t\t\t\tsdb_num_get (mydb, sdb_fmt (0, \"%x\", sdb_hash (name)), NULL);\n\t\t} else {\n\t\t\tres = (RBinSymbol*)(void*)(size_t)\n\t\t\t\tsdb_num_get (mydb, sdb_fmt (0, \"0x\"PFMT64x, addr), NULL);\n\t\t}\n\t} else {\n\t\tmydb = sdb_new0 ();\n\t\tr_list_foreach (symbols, iter, symbol) {\n\t\t\t/* ${name}=${ptrToSymbol} */\n\t\t\tif (!sdb_num_add (mydb, sdb_fmt (0, \"%x\", sdb_hash (symbol->name)), (ut64)(size_t)symbol, 0)) {\n\t\t\t//\teprintf (\"DUP (%s)\\n\", symbol->name);\n\t\t\t}\n\t\t\t/* 0x${vaddr}=${ptrToSymbol} */\n\t\t\tif (!sdb_num_add (mydb, sdb_fmt (0, \"0x\"PFMT64x, symbol->vaddr), (ut64)(size_t)symbol, 0)) {\n\t\t\t//\teprintf (\"DUP (%s)\\n\", symbol->name);\n\t\t\t}\n\t\t\tif (name) {\n\t\t\t\tif (!res && !strcmp (symbol->name, name)) {\n\t\t\t\t\tres = symbol;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (symbol->vaddr == addr) {\n\t\t\t\t\tres = symbol;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n#else\nstatic RList *osymbols = NULL;\nstatic RBinSymbol *get_symbol(RBin *bin, RList *symbols, const char *name, ut64 addr) {\n\tRBinSymbol *symbol;\n\tRListIter *iter;\n\tr_list_foreach (symbols, iter, symbol) {\n\t\tif (name) {\n\t\t\tif (!strcmp (symbol->name, name))\n\t\t\t\treturn symbol;\n\t\t} else {\n\t\t\tif (symbol->vaddr == addr) {\n\t\t\t\treturn symbol;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n#endif\n\n/* XXX: This is a hack to get PLT references in rabin2 -i */\n/* imp. is a prefix that can be rewritten by the symbol table */\nstatic ut64 impaddr(RBin *bin, int va, const char *name) {\n\tchar *impname;\n\tRList *symbols;\n\tRBinSymbol *s;\n\n\tif (!name || !*name) {\n\t\treturn false;\n\t}\n\tif (!(symbols = r_bin_get_symbols (bin))) {\n\t\treturn false;\n\t}\n\timpname = sdb_fmt (2, \"imp.%s\", name);\n\ts = get_symbol (bin, symbols, impname, 0LL);\n\tif (s) {\n\t\tif (va) {\n\t\t\treturn r_bin_get_vaddr (bin, s->paddr, s->vaddr);\n\t\t}\n\t\treturn s->paddr;\n\t}\n\treturn 0LL;\n}\n\nstatic int bin_imports(RCore *r, int mode, int va, const char *name) {\n\tint bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tRBinImport *import;\n\tRListIter *iter;\n\tRList *imports;\n\tchar *str;\n\tint i = 0;\n\n\timports = r_bin_get_imports (r->bin);\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"[\");\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_println (\"fs imports\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_println (\"[Imports]\");\n\t}\n\tr_list_foreach (imports, iter, import) {\n\t\tchar *symname;\n\t\tut64 addr;\n\t\tif (name && strcmp (import->name, name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tsymname = strdup (import->name);\n\t\taddr = impaddr (r->bin, va, symname);\n\t\tif (bin_demangle) {\n\t\t\tchar *dname = r_bin_demangle (r->bin->cur, NULL, symname, addr);\n\t\t\tif (dname) {\n\t\t\t\tfree (symname);\n\t\t\t\tsymname = r_str_newf (\"sym.imp.%s\", dname);\n\t\t\t\tfree (dname);\n\t\t\t}\n\t\t}\n\t\tif (r->bin->prefix) {\n\t\t\tchar *prname;\n\t\t\tprname = r_str_newf (\"%s.%s\", r->bin->prefix, symname);\n\t\t\tfree (symname);\n\t\t\tsymname = prname;\n\t\t}\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\t// TODO(eddyb) symbols that are imports.\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tr_cons_println (symname);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tstr = r_str_utf16_encode (symname, -1);\n\t\t\tstr = r_str_replace (str, \"\\\"\", \"\\\\\\\"\", 1);\n\t\t\tr_cons_printf (\"%s{\\\"ordinal\\\":%d,\"\n\t\t\t\t\"\\\"bind\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\",\n\t\t\t\titer->p ? \",\" : \"\",\n\t\t\t\timport->ordinal,\n\t\t\t\timport->bind,\n\t\t\t\timport->type);\n\t\t\tif (import->classname && import->classname[0]) {\n\t\t\t\tr_cons_printf (\"\\\"classname\\\":\\\"%s\\\",\"\n\t\t\t\t\t\"\\\"descriptor\\\":\\\"%s\\\",\",\n\t\t\t\t\timport->classname,\n\t\t\t\t\timport->descriptor);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"name\\\":\\\"%s\\\",\\\"plt\\\":%\"PFMT64d\"}\",\n\t\t\t\tstr, addr);\n\t\t\tfree (str);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\t// TODO(eddyb) symbols that are imports.\n\t\t} else {\n\t\t\tconst char *bind = r_str_get (import->bind);\n\t\t\tconst char *type = r_str_get (import->type);\n\t\t\tr_cons_printf (\"ordinal=%03d plt=0x%08\"PFMT64x\" bind=%s type=%s\",\n\t\t\t\timport->ordinal, addr, bind, type);\n\t\t\tif (import->classname && import->classname[0]) {\n\t\t\t\tr_cons_printf (\" classname=%s\", import->classname);\n\t\t\t}\n\t\t\tr_cons_printf (\" name=%s\", symname);\n\t\t\tif (import->descriptor && import->descriptor[0]) {\n\t\t\t\tr_cons_printf (\" descriptor=%s\", import->descriptor);\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t}\n\t\tfree (symname);\n\t\ti++;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"]\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"\\n%i imports\\n\", i);\n\t}\n#if MYDB\n\tosymbols = NULL;\n\tsdb_free (mydb);\n\tmydb = NULL;\n#endif\n\treturn true;\n}\n\nstatic const char *getPrefixFor(const char *s) {\n\tif (s) {\n\t\tif (!strcmp (s, \"NOTYPE\")) {\n\t\t\treturn \"loc\";\n\t\t}\n\t\tif (!strcmp (s, \"OBJECT\")) {\n\t\t\treturn \"obj\";\n\t\t}\n\t}\n\treturn \"sym\";\n}\n\ntypedef struct {\n\tconst char *pfx; // prefix for flags\n\tchar *name;      // raw symbol name\n\tchar *nameflag;  // flag name for symbol\n\tchar *demname;   // demangled raw symbol name\n\tchar *demflag;   // flag name for demangled symbol\n\tchar *classname; // classname\n\tchar *classflag; // flag for classname\n\tchar *methname;  // methods [class]::[method]\n\tchar *methflag;  // methods flag sym.[class].[method]\n} SymName;\n\nstatic void snInit(RCore *r, SymName *sn, RBinSymbol *sym, const char *lang) {\n#define MAXFLAG_LEN 128\n\tint bin_demangle = lang != NULL;\n\tconst char *pfx;\n\tif (!r || !sym || !sym->name) return;\n\tpfx = getPrefixFor (sym->type);\n\tsn->name = strdup (sym->name);\n\tif (sym->dup_count) {\n\t\tsn->nameflag = r_str_newf (\"%s.%s_%d\", pfx, sym->name, sym->dup_count);\n\t} else {\n\t\tsn->nameflag = r_str_newf (\"%s.%s\", pfx, sym->name);\n\t}\n\tr_name_filter (sn->nameflag, MAXFLAG_LEN);\n\tif (sym->classname && sym->classname[0]) {\n\t\tsn->classname = strdup (sym->classname);\n\t\tsn->classflag = r_str_newf (\"sym.%s.%s\", sn->classname, sn->name);\n\t\tr_name_filter (sn->classflag, MAXFLAG_LEN);\n\t\tconst char *name = sym->dname? sym->dname: sym->name;\n\t\tsn->methname = r_str_newf (\"%s::%s\", sn->classname, name);\n\t\tsn->methflag = r_str_newf (\"sym.%s.%s\", sn->classname, name);\n\t\tr_name_filter (sn->methflag, strlen (sn->methflag));\n\t} else {\n\t\tsn->classname = NULL;\n\t\tsn->classflag = NULL;\n\t\tsn->methname = NULL;\n\t\tsn->methflag = NULL;\n\t}\n\tsn->demname = NULL;\n\tsn->demflag = NULL;\n\tif (bin_demangle && sym->paddr) {\n\t\tsn->demname = r_bin_demangle (r->bin->cur, lang, sn->name, sym->vaddr);\n\t\tif (sn->demname) {\n\t\t\tsn->demflag = r_str_newf (\"%s.%s\", pfx, sn->demname);\n\t\t\tr_name_filter (sn->demflag, -1);\n\t\t}\n\t}\n}\n\nstatic void snFini(SymName *sn) {\n\tR_FREE (sn->name);\n\tR_FREE (sn->nameflag);\n\tR_FREE (sn->demname);\n\tR_FREE (sn->demflag);\n\tR_FREE (sn->classname);\n\tR_FREE (sn->classflag);\n\tR_FREE (sn->methname);\n\tR_FREE (sn->methflag);\n}\n\n\nstatic bool isAnExport(RBinSymbol *s) {\n\t/* workaround for some bin plugs */\n\tif (!strncmp (s->name, \"imp.\", 4)) {\n\t\treturn false;\n\t}\n\treturn (s->bind && !strcmp (s->bind, \"GLOBAL\"));\n}\n\nstatic int bin_symbols_internal(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, bool exponly) {\n\tRBinInfo *info = r_bin_get_info (r->bin);\n\tRList *entries = r_bin_get_entries (r->bin);\n\tRBinSymbol *symbol;\n\tRBinAddr *entry;\n\tRListIter *iter;\n\tRList *symbols;\n\tconst char *lang;\n\tbool firstexp = true;\n\tint i = 0, is_arm, lastfs = 's',\n\t    bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tif (!info) {\n\t\treturn 0;\n\t}\n\tis_arm = info && info->arch && !strncmp (info->arch, \"arm\", 3);\n\tlang = bin_demangle ? r_config_get (r->config, \"bin.lang\") : NULL;\n\n\tsymbols = r_bin_get_symbols (r->bin);\n\tr_space_set (&r->anal->meta_spaces, \"bin\");\n\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"[\");\n\t} else if (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, \"symbols\");\n\t} else if (!at && exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs exports\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (\"[Exports]\\n\");\n\t\t}\n\t} else if (!at && !exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs symbols\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (\"[Symbols]\\n\");\n\t\t}\n\t}\n\n\tr_list_foreach (symbols, iter, symbol) {\n\t\tut64 addr = rva (r->bin, symbol->paddr, symbol->vaddr, va);\n\t\tSymName sn;\n\n\t\tif (exponly && !isAnExport (symbol)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (name && strcmp (symbol->name, name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (at && (!symbol->size || !is_in_range (at, addr, symbol->size))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tsnInit (r, &sn, symbol, lang);\n\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\tif (is_arm && info->bits < 33) { // 16 or 32\n\t\t\t\tint force_bits = 0;\n\t\t\t\tif (symbol->paddr & 1 || symbol->bits == 16) {\n\t\t\t\t\tforce_bits = 16;\n\t\t\t\t} else if (info->bits == 16 && symbol->bits == 32) {\n\t\t\t\t\tforce_bits = 32;\n\t\t\t\t} else if (!(symbol->paddr & 1) && symbol->bits == 32) {\n\t\t\t\t\tforce_bits = 32;\n\t\t\t\t}\n\t\t\t\tif (force_bits) {\n\t\t\t\t\tr_anal_hint_set_bits (r->anal, addr, force_bits);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!strncmp (symbol->name, \"imp.\", 4)) {\n\t\t\t\tif (lastfs != 'i') {\n\t\t\t\t\tr_flag_space_set (r->flags, \"imports\");\n\t\t\t\t}\n\t\t\t\tlastfs = 'i';\n\t\t\t} else {\n\t\t\t\tif (lastfs != 's') {\n\t\t\t\t\tr_flag_space_set (r->flags, \"symbols\");\n\t\t\t\t}\n\t\t\t\tlastfs = 's';\n\t\t\t}\n\t\t\t/* If that's a Classed symbol (method or so) */\n\t\t\tif (sn.classname) {\n\t\t\t\tRFlagItem *fi = NULL;\n\t\t\t\tchar *comment = NULL;\n\t\t\t\tfi = r_flag_get (r->flags, sn.methflag);\n\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\tchar *prname;\n\t\t\t\t\tprname = r_str_newf (\"%s.%s\", r->bin->prefix, sn.methflag);\n\t\t\t\t\tr_name_filter (sn.methflag, -1);\n\t\t\t\t\tfree (sn.methflag);\n\t\t\t\t\tsn.methflag = prname;\n\t\t\t\t}\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, sn.methname);\n\t\t\t\t\tif ((fi->offset - r->flags->base) == addr) {\n\t\t\t\t\t\tcomment = fi->comment ? strdup (fi->comment) : NULL;\n\t\t\t\t\t\tr_flag_unset (r->flags, fi);\n\t\t\t\t\t\tfi = NULL;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfi = r_flag_set (r->flags, sn.methflag, addr, symbol->size);\n\t\t\t\t\tcomment = fi->comment ? strdup (fi->comment) : NULL;\n\t\t\t\t\tif (comment) {\n\t\t\t\t\t\tr_flag_item_set_comment (fi, comment);\n\t\t\t\t\t\tR_FREE (comment);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst char *fn, *n;\n\t\t\t\tRFlagItem *fi;\n\t\t\t\tn = sn.demname ? sn.demname : sn.name;\n\t\t\t\tfn = sn.demflag ? sn.demflag : sn.nameflag;\n\t\t\t\tchar *fnp = (r->bin->prefix) ?\n\t\t\t\t\tr_str_newf (\"%s.%s\", r->bin->prefix, fn):\n\t\t\t\t\tstrdup (fn);\n\t\t\t\tfi = r_flag_set (r->flags, fnp, addr, symbol->size);\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, n);\n\t\t\t\t} else {\n\t\t\t\t\tif (fn) {\n\t\t\t\t\t\teprintf (\"[Warning] Can't find flag (%s)\\n\", fn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (fnp);\n\t\t\t}\n\t\t\tif (sn.demname) {\n\t\t\t\tr_meta_add (r->anal, R_META_TYPE_COMMENT,\n\t\t\t\t\taddr, symbol->size, sn.demname);\n\t\t\t}\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tchar *str = r_str_utf16_encode (symbol->name, -1);\n\t\t\tstr = r_str_replace (str, \"\\\"\", \"\\\\\\\"\", 1);\n\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"demname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"flagname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"size\\\":%d,\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"paddr\\\":%\"PFMT64d\"}\",\n\t\t\t\t(exponly && firstexp) ? \"\" : (iter->p ? \",\" : \"\"), str,\n\t\t\t\tsn.demname? sn.demname: \"\",\n\t\t\t\tsn.nameflag,\n\t\t\t\t(int)symbol->size,\n\t\t\t\tsymbol->type,\n\t\t\t\t(ut64)addr, (ut64)symbol->paddr);\n\t\t\tfree (str);\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: symbol->name;\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" %d %s\\n\",\n\t\t\t\taddr, (int)symbol->size, name);\n\t\t} else if (IS_MODE_SIMPLEST (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: symbol->name;\n\t\t\tr_cons_printf (\"%s\\n\", name);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tRBinFile *binfile;\n\t\t\tRBinPlugin *plugin;\n\t\t\tchar *name = strdup (sn.demname? sn.demname: symbol->name);\n\t\t\tr_name_filter (name, -1);\n\t\t\tif (!strncmp (name, \"imp.\", 4)) {\n\t\t\t\tif (lastfs != 'i')\n\t\t\t\t\tr_cons_printf (\"fs imports\\n\");\n\t\t\t\tlastfs = 'i';\n\t\t\t} else {\n\t\t\t\tif (lastfs != 's') {\n\t\t\t\t\tr_cons_printf (\"fs %s\\n\",\n\t\t\t\t\t\texponly? \"exports\": \"symbols\");\n\t\t\t\t}\n\t\t\t\tlastfs = 's';\n\t\t\t}\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tif (symbol->dup_count) {\n\t\t\t\t\tr_cons_printf (\"f %s.sym.%s_%d %u 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\tr->bin->prefix, name, symbol->dup_count, symbol->size, addr);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"f %s.sym.%s %u 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\tr->bin->prefix, name, symbol->size, addr);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (symbol->dup_count) {\n\t\t\t\t\tr_cons_printf (\"f sym.%s_%d %u 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\tname, symbol->dup_count, symbol->size, addr);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"f sym.%s %u 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\tname, symbol->size, addr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbinfile = r_core_bin_cur (r);\n\t\t\tplugin = r_bin_file_cur_plugin (binfile);\n\t\t\tif (plugin && plugin->name) {\n\t\t\t\tif (!strncmp (plugin->name, \"pe\", 2)) {\n\t\t\t\t\tchar *p, *module = strdup (symbol->name);\n\t\t\t\t\tp = strstr (module, \".dll_\");\n\t\t\t\t\tif (p) {\n\t\t\t\t\t\tconst char *symname = p + 5;\n\t\t\t\t\t\t*p = 0;\n\t\t\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s.%s\\n\",\n\t\t\t\t\t\t\t\tmodule, symbol->ordinal, r->bin->prefix, symname);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s\\n\",\n\t\t\t\t\t\t\t\tmodule, symbol->ordinal, symname);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree (module);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *bind = symbol->bind;\n\t\t\tconst char *type = symbol->type;\n\t\t\tconst char *name = sn.demname? sn.demname: symbol->name;\n\t\t\tconst char *fwd = symbol->forwarder;\n\t\t\tif (!bind) bind = \"\";\n\t\t\tif (!type) type = \"\";\n\t\t\tif (!fwd) fwd = \"\";\n\t\t\tr_cons_printf (\"vaddr=0x%08\"PFMT64x\" paddr=0x%08\"PFMT64x\" ord=%03u \"\n\t\t\t\t\"fwd=%s sz=%u bind=%s type=%s name=%s\\n\",\n\t\t\t\taddr, symbol->paddr, symbol->ordinal, fwd,\n\t\t\t\tsymbol->size, bind, type, name);\n\t\t}\n\t\tsnFini (&sn);\n\t\ti++;\n\t\tif (exponly && firstexp) {\n\t\t\tfirstexp = false;\n\t\t}\n\t}\n\n\t//handle thumb and arm for entry point since they are not present in symbols\n\tif (is_arm) {\n\t\tr_list_foreach (entries, iter, entry) {\n\t\t\tif (IS_MODE_SET (mode)) {\n\t\t\t\tif (info->bits < 33) { // 16 or 32\n\t\t\t\t\tint force_bits = 0;\n\t\t\t\t\tut64 addr = rva (r->bin, entry->paddr, entry->vaddr, va);\n\t\t\t\t\tif (entry->paddr & 1 || entry->bits == 16) {\n\t\t\t\t\t\tforce_bits = 16;\n\t\t\t\t\t} else if (info->bits == 16 && entry->bits == 32) {\n\t\t\t\t\t\tforce_bits = 32;\n\t\t\t\t\t} else if (!(entry->paddr & 1)) {\n\t\t\t\t\t\tforce_bits = 32;\n\t\t\t\t\t}\n\t\t\t\t\tif (force_bits) {\n\t\t\t\t\t\tr_anal_hint_set_bits (r->anal, addr, force_bits);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (IS_MODE_JSON (mode)) r_cons_printf (\"]\");\n\tif (IS_MODE_NORMAL (mode) && !at) {\n\t\tr_cons_printf (\"\\n%i %s\\n\", i, exponly ? \"exports\" : \"symbols\");\n\t}\n\n\tr_space_set (&r->anal->meta_spaces, NULL);\n\treturn true;\n}\n\nstatic int bin_exports(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name) {\n\treturn bin_symbols_internal (r, mode, laddr, va, at, name, true);\n}\n\nstatic int bin_symbols(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name) {\n\treturn bin_symbols_internal (r, mode, laddr, va, at, name, false);\n}\n\nstatic char *build_hash_string(int mode, const char *chksum, ut8 *data, ut32 datalen) {\n\tchar *chkstr = NULL, *aux, *ret = NULL;\n\tconst char *ptr = chksum;\n\tchar tmp[128];\n\tint i;\n\tdo {\n\t\tfor (i = 0; *ptr && *ptr != ',' && i < sizeof (tmp) -1; i++) {\n\t\t\ttmp[i] = *ptr++;\n\t\t}\n\t\ttmp[i] = '\\0';\n\t\tchkstr = r_hash_to_string (NULL, tmp, data, datalen);\n\t\tif (!chkstr) {\n\t\t\tif (*ptr && *ptr == ',') {\n\t\t\t\tptr++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (IS_MODE_SIMPLE (mode)) {\n\t\t\taux = r_str_newf (\"%s \", chkstr);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\taux = r_str_newf (\"\\\"%s\\\":\\\"%s\\\",\", tmp, chkstr);\n\t\t} else {\n\t\t\taux = r_str_newf (\"%s=%s \", tmp, chkstr);\n\t\t}\n\t\tret = r_str_append (ret, aux);\n\t\tfree (chkstr);\n\t\tfree (aux);\n\t\tif (*ptr && *ptr == ',') ptr++;\n\t} while (*ptr);\n\n\treturn ret;\n}\n\nstatic int bin_sections(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, const char *chksum) {\n\tchar str[R_FLAG_NAME_SIZE];\n\tRBinSection *section;\n\tRBinInfo *info = NULL;\n\tRList *sections;\n\tRListIter *iter;\n\tint i = 0;\n\tint fd = -1;\n\tsections = r_bin_get_sections (r->bin);\n\tbool inDebugger = r_config_get_i (r->config, \"cfg.debug\");\n\n\tif (IS_MODE_JSON (mode)) r_cons_printf (\"[\");\n\telse if (IS_MODE_RAD (mode) && !at) r_cons_printf (\"fs sections\\n\");\n\telse if (IS_MODE_NORMAL (mode) && !at) r_cons_printf (\"[Sections]\\n\");\n\telse if (IS_MODE_SET (mode)) {\n\t\tfd = r_core_file_cur_fd (r);\n\t\tr_flag_space_set (r->flags, \"sections\");\n\t}\n\tr_list_foreach (sections, iter, section) {\n\t\tchar perms[] = \"-----\";\n\t\tint va_sect = va;\n\t\tut64 addr;\n\n\t\tif (va && !(section->srwx & R_BIN_SCN_READABLE)) {\n\t\t\tva_sect = VA_NOREBASE;\n\t\t}\n\t\taddr = rva (r->bin, section->paddr, section->vaddr, va_sect);\n\n\t\tif (name && strcmp (section->name, name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tr_name_filter (section->name, sizeof (section->name));\n\t\tif (at && (!section->size || !is_in_range (at, addr, section->size))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (section->srwx & R_BIN_SCN_MAP) perms[0] = 'm';\n\t\tif (section->srwx & R_BIN_SCN_SHAREABLE) perms[1] = 's';\n\t\tif (section->srwx & R_BIN_SCN_READABLE) perms[2] = 'r';\n\t\tif (section->srwx & R_BIN_SCN_WRITABLE) perms[3] = 'w';\n\t\tif (section->srwx & R_BIN_SCN_EXECUTABLE) perms[4] = 'x';\n\n\t\tif (IS_MODE_SET (mode)) {\n#if LOAD_BSS_MALLOC\n\t\t\tif (!strcmp (section->name, \".bss\")) {\n\t\t\t\t// check if there's already a file opened there\n\t\t\t\tint loaded = 0;\n\t\t\t\tRListIter *iter;\n\t\t\t\tRIOMap *m;\n\t\t\t\tr_list_foreach (r->io->maps, iter, m) {\n\t\t\t\t\tif (m->from == addr) {\n\t\t\t\t\t\tloaded = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!loaded && !inDebugger) {\n\t\t\t\t\tr_core_cmdf (r, \"on malloc://%d 0x%\"PFMT64x\" # bss\\n\",\n\t\t\t\t\t\tsection->vsize, addr);\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tr_name_filter (section->name, 128);\n\t\t\tif (section->format) {\n\t\t\t\t// This is damn slow if section vsize is HUGE\n\t\t\t\tif (section->vsize < 1024 * 1024 * 2) {\n\t\t\t\t\tr_core_cmdf (r, \"%s @ 0x%\"PFMT64x, section->format, section->vaddr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tsnprintf (str, sizeof(str)-1, \"%s.section.%s\",\n\t\t\t\t\tr->bin->prefix, section->name);\n\t\t\t} else {\n\t\t\t\tsnprintf (str, sizeof(str)-1, \"section.%s\", section->name);\n\n\t\t\t}\n\t\t\tr_flag_set (r->flags, str, addr, section->size);\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tsnprintf (str, sizeof(str) - 1, \"%s.section_end.%s\",\n\t\t\t\t\tr->bin->prefix, section->name);\n\t\t\t} else {\n\t\t\t\tsnprintf (str, sizeof(str) - 1, \"section_end.%s\", section->name);\n\t\t\t}\n\n\t\t\tr_flag_set (r->flags, str, addr + section->size, 0);\n\t\t\tif (section->arch || section->bits) {\n\t\t\t\tconst char *arch = section->arch;\n\t\t\t\tint bits = section->bits;\n\t\t\t\tif (info) {\n\t\t\t\t\tif (!arch) {\n\t\t\t\t\t\tarch = info->arch;\n\t\t\t\t\t}\n\t\t\t\t\tif (!bits) {\n\t\t\t\t\t\tbits = info->bits;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//r_io_section_set_archbits (r->io, addr, arch, bits);\n\t\t\t}\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tsnprintf (str, sizeof (str)-1, \"section %i va=0x%08\"PFMT64x\" pa=0x%08\"\n\t\t\t\t\tPFMT64x\" sz=%\" PFMT64d\" vsz=%\"PFMT64d\" rwx=%s %s.%s\",\n\t\t\t\t\ti, addr, section->paddr, section->size, section->vsize,\n\t\t\t\t\tperms, r->bin->prefix, section->name);\n\t\t\t} else {\n\t\t\t\tsnprintf (str, sizeof (str)-1, \"section %i va=0x%08\"PFMT64x\" pa=0x%08\"\n\t\t\t\t\tPFMT64x\" sz=%\" PFMT64d\" vsz=%\"PFMT64d\" rwx=%s %s\",\n\t\t\t\t\ti, addr, section->paddr, section->size, section->vsize,\n\t\t\t\t\tperms, section->name);\n\n\t\t\t}\n\t\t\tr_meta_add (r->anal, R_META_TYPE_COMMENT, addr, addr, str);\n\t\t\tif (section->add) {\n\t\t\t\tr_io_section_add (r->io, section->paddr, addr,\n\t\t\t\t\t\t  section->size, section->vsize,\n\t\t\t\t\t\t  section->srwx, section->name,\n\t\t\t\t\t\t  0, fd);\n\t\t\t}\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tchar *hashstr = NULL;\n\t\t\tif (chksum) {\n\t\t\t\tut8 *data = malloc (section->size);\n\t\t\t\tif (!data) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tut32 datalen = section->size;\n\t\t\t\tr_io_pread (r->io, section->paddr, data, datalen);\n\t\t\t\thashstr = build_hash_string (mode, chksum,\n\t\t\t\t\t\t\tdata, datalen);\n\t\t\t\tfree (data);\n\t\t\t}\n\t\t\tr_cons_printf (\"0x%\"PFMT64x\" 0x%\"PFMT64x\" %s %s%s%s\\n\",\n\t\t\t\taddr, addr + section->size,\n\t\t\t\tperms,\n\t\t\t\thashstr ? hashstr : \"\", hashstr ? \" \" : \"\",\n\t\t\t\tsection->name\n\t\t\t);\n\t\t\tfree (hashstr);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tchar *hashstr = NULL;\n\t\t\tif (chksum) {\n\t\t\t\tut8 *data = malloc (section->size);\n\t\t\t\tif (!data) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tut32 datalen = section->size;\n\t\t\t\tr_io_pread (r->io, section->paddr, data, datalen);\n\t\t\t\thashstr = build_hash_string (mode, chksum,\n\t\t\t\t\t\t\tdata, datalen);\n\t\t\t\tfree (data);\n\n\t\t\t}\n\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"size\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"vsize\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"flags\\\":\\\"%s\\\",\"\n\t\t\t\t\"%s\"\n\t\t\t\t\"\\\"paddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\"}\",\n\t\t\t\titer->p?\",\":\"\",\n\t\t\t\tsection->name,\n\t\t\t\tsection->size,\n\t\t\t\tsection->vsize,\n\t\t\t\tperms,\n\t\t\t\thashstr ? hashstr : \"\",\n\t\t\t\tsection->paddr,\n\t\t\t\taddr);\n\t\t\tfree (hashstr);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tif (!strcmp (section->name, \".bss\") && !inDebugger) {\n#if LOAD_BSS_MALLOC\n\t\t\t\tr_cons_printf (\"on malloc://%d 0x%\"PFMT64x\" # bss\\n\",\n\t\t\t\t\t\tsection->vsize, addr);\n#endif\n\t\t\t}\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tr_cons_printf (\"S 0x%08\"PFMT64x\" 0x%08\"PFMT64x\" 0x%08\"PFMT64x\" 0x%08\"PFMT64x\" %s.%s %d\\n\",\n\t\t\t\t\tsection->paddr, addr, section->size, section->vsize,\n\t\t\t\t\tr->bin->prefix, section->name, (int)section->srwx);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"S 0x%08\"PFMT64x\" 0x%08\"PFMT64x\" 0x%08\"PFMT64x\" 0x%08\"PFMT64x\" %s %d\\n\",\n\t\t\t\t\tsection->paddr, addr, section->size, section->vsize,\n\t\t\t\t\tsection->name, (int)section->srwx);\n\n\t\t\t}\n\t\t\tif (section->arch || section->bits) {\n\t\t\t\tconst char *arch = section->arch;\n\t\t\t\tint bits = section->bits;\n\t\t\t\tif (info) {\n\t\t\t\t\tif (!arch) arch = info->arch;\n\t\t\t\t\tif (!bits) bits = info->bits;\n\t\t\t\t}\n\t\t\t\tif (!arch) {\n\t\t\t\t\tarch = r_config_get (r->config, \"asm.arch\");\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"Sa %s %d @ 0x%08\"\n\t\t\t\t\tPFMT64x\"\\n\", arch, bits, addr);\n\t\t\t}\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tr_cons_printf (\"f %s.section.%s %\"PFMT64d\" 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\tr->bin->prefix, section->name, section->size, addr);\n\t\t\t\tr_cons_printf (\"f %s.section_end.%s 1 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\tr->bin->prefix, section->name, addr + section->size);\n\t\t\t\tr_cons_printf (\"CC section %i va=0x%08\"PFMT64x\" pa=0x%08\"PFMT64x\" sz=%\"PFMT64d\" vsz=%\"PFMT64d\" \"\n\t\t\t\t\t\t\"rwx=%s %s.%s @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\ti, addr, section->paddr, section->size, section->vsize,\n\t\t\t\t\t\tperms, r->bin->prefix, section->name, addr);\n\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"f section.%s %\"PFMT64d\" 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\tsection->name, section->size, addr);\n\t\t\t\tr_cons_printf (\"f section_end.%s 1 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\tsection->name, addr + section->size);\n\t\t\t\tr_cons_printf (\"CC section %i va=0x%08\"PFMT64x\" pa=0x%08\"PFMT64x\" sz=%\"PFMT64d\" vsz=%\"PFMT64d\" \"\n\t\t\t\t\t\t\"rwx=%s %s @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\ti, addr, section->paddr, section->size, section->vsize,\n\t\t\t\t\t\tperms, section->name, addr);\n\t\t\t}\n\t\t} else {\n\t\t\tchar *hashstr = NULL, str[128];\n\t\t\tif (chksum) {\n\t\t\t\tut8 *data = malloc (section->size);\n\t\t\t\tif (!data) return false;\n\t\t\t\tut32 datalen = section->size;\n\t\t\t\t// VA READ IS BROKEN?\n\t\t\t\tr_io_pread (r->io, section->paddr, data, datalen);\n\t\t\t\thashstr = build_hash_string (mode, chksum,\n\t\t\t\t\t\t\tdata, datalen);\n\t\t\t\tfree (data);\n\t\t\t}\n\t\t\tif (section->arch || section->bits) {\n\t\t\t\tconst char *arch = section->arch;\n\t\t\t\tint bits = section->bits;\n\t\t\t\tif (!arch && info) {\n\t\t\t\t\tarch = info->arch;\n\t\t\t\t\tif (!arch) {\n\t\t\t\t\t\tarch = r_config_get (r->config, \"asm.arch\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!bits) {\n\t\t\t\t\tbits = info? info->bits: R_SYS_BITS;\n\t\t\t\t}\n\t\t\t\tsnprintf (str, sizeof (str), \"arch=%s bits=%d \",\n\t\t\t\t\tr_str_get2 (arch), bits);\n\t\t\t} else {\n\t\t\t\tstr[0] = 0;\n\t\t\t}\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tr_cons_printf (\"idx=%02i vaddr=0x%08\"PFMT64x\" paddr=0x%08\"PFMT64x\" sz=%\"PFMT64d\" vsz=%\"PFMT64d\" \"\n\t\t\t\t\t\"perm=%s %s%sname=%s.%s\\n\",\n\t\t\t\t\ti, addr, section->paddr, section->size, section->vsize,\n\t\t\t\t\tperms, str, hashstr ?hashstr : \"\", r->bin->prefix, section->name);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"idx=%02i vaddr=0x%08\"PFMT64x\" paddr=0x%08\"PFMT64x\" sz=%\"PFMT64d\" vsz=%\"PFMT64d\" \"\n\t\t\t\t\t\"perm=%s %s%sname=%s\\n\",\n\t\t\t\t\ti, addr, section->paddr, section->size, section->vsize,\n\t\t\t\t\tperms, str, hashstr ?hashstr : \"\", section->name);\n\t\t\t}\n\t\t\tfree (hashstr);\n\t\t}\n\t\ti++;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_println (\"]\");\n\t} else if (IS_MODE_NORMAL (mode) && !at) {\n\t\tr_cons_printf (\"\\n%i sections\\n\", i);\n\t}\n\treturn true;\n}\n\nstatic int bin_fields(RCore *r, int mode, int va) {\n\tRList *fields;\n\tRListIter *iter;\n\tRBinField *field;\n\tint i = 0;\n\tRBin *bin = r->bin;\n\tRBinFile *binfile = r_core_bin_cur (r);\n\tut64 size = binfile ? binfile->size : UT64_MAX;\n\tut64 baddr = r_bin_get_baddr (r->bin);\n\n\tif (!(fields = r_bin_get_fields (bin))) {\n\t\treturn false;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"[\");\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_println (\"fs header\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_println (\"[Header fields]\");\n\t}\n//why this? there is an overlap in bin_sections with ehdr\n//because there can't be two sections with the same name\n#if 0\n\telse if (IS_MODE_SET (mode)) {\n\t\t// XXX: Need more flags??\n\t\t// this will be set even if the binary does not have an ehdr\n\t\tint fd = r_core_file_cur_fd(r);\n\t\tr_io_section_add (r->io, 0, baddr, size, size, 7, \"ehdr\", 0, fd);\n\t}\n#endif\n\tr_list_foreach (fields, iter, field) {\n\t\tut64 addr = rva (bin, field->paddr, field->vaddr, va);\n\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_name_filter (field->name, -1);\n\t\t\tr_cons_printf (\"f header.%s @ 0x%08\"PFMT64x\"\\n\", field->name, addr);\n\t\t\tif (field->comment && *field->comment) {\n\t\t\t\tr_cons_printf (\"CC %s @ 0x%\"PFMT64x\"\\n\", field->comment, addr);\n\t\t\t}\n\t\t\tif (field->format && *field->format) {\n\t\t\t\tr_cons_printf (\"pf.%s %s\\n\", field->name, field->format);\n\t\t\t}\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"paddr\\\":%\"PFMT64d,\n\t\t\t\titer->p? \",\": \"\",\n\t\t\t\tfield->name,\n\t\t\t\tfield->vaddr,\n\t\t\t\tfield->paddr\n\t\t\t\t);\n\t\t\tif (field->comment && *field->comment) {\n\t\t\t\t// TODO: filter comment before json\n\t\t\t\tr_cons_printf (\",\\\"comment\\\":\\\"%s\\\"\", field->comment);\n\t\t\t}\n\t\t\tif (field->format && *field->format) {\n\t\t\t\t// TODO: filter comment before json\n\t\t\t\tr_cons_printf (\",\\\"format\\\":\\\"%s\\\"\", field->format);\n\t\t\t}\n\t\t\tr_cons_printf (\"}\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tconst bool haveComment = (field->comment && *field->comment);\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" 0x%08\"PFMT64x\" %s%s%s\\n\",\n\t\t\t\tfield->vaddr, field->paddr, field->name,\n\t\t\t\thaveComment? \"; \": \"\",\n\t\t\t\thaveComment? field->comment: \"\");\n\t\t}\n\t\ti++;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"]\");\n\t} else if (IS_MODE_RAD (mode)) {\n\t\t/* add program header section */\n\t\tr_cons_printf (\"S 0 0x%\"PFMT64x\" 0x%\"PFMT64x\" 0x%\"PFMT64x\" ehdr rwx\\n\",\n\t\t\tbaddr, size, size);\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"\\n%i fields\\n\", i);\n\t}\n\n\treturn true;\n}\n\nstatic int bin_classes(RCore *r, int mode) {\n\tRListIter *iter, *iter2;\n\tRBinSymbol *sym;\n\tRBinClass *c;\n\tchar *name;\n\tRList *cs = r_bin_get_classes (r->bin);\n\tif (!cs) {\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_print(\"[]\");\n\t\t}\n\t\treturn false;\n\t}\n\t// XXX: support for classes is broken and needs more love\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"[\");\n\t} else if (IS_MODE_SET (mode)) {\n\t\tif (!r_config_get_i (r->config, \"bin.classes\")) {\n\t\t\treturn false;\n\t\t}\n\t\tr_flag_space_set (r->flags, \"classes\");\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_println (\"fs classes\");\n\t}\n\n\tr_list_foreach (cs, iter, c) {\n\t\tif (!c || !c->name || !c->name[0]) {\n\t\t\tcontinue;\n\t\t}\n\t\tname = strdup (c->name);\n\t\tr_name_filter (name, 0);\n\t\tut64 at_min = UT64_MAX;\n\t\tut64 at_max = 0LL;\n\n\t\tr_list_foreach (c->methods, iter2, sym) {\n\t\t\tif (sym->vaddr) {\n\t\t\t\tif (sym->vaddr < at_min) {\n\t\t\t\t\tat_min = sym->vaddr;\n\t\t\t\t}\n\t\t\t\tif (sym->vaddr + sym->size > at_max) {\n\t\t\t\t\tat_max = sym->vaddr + sym->size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (at_min == UT64_MAX) {\n\t\t\tat_min = c->addr;\n\t\t\tat_max = c->addr; // XXX + size?\n\t\t}\n\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\tconst char *classname = sdb_fmt (0, \"class.%s\", name);\n\t\t\tr_flag_set (r->flags, classname, c->addr, 1);\n\t\t\tr_list_foreach (c->methods, iter2, sym) {\n\t\t\t\tchar *mflags = r_core_bin_method_flags_str (sym, mode);\n\t\t\t\tchar *method = sdb_fmt (1, \"method%s.%s.%s\",\n\t\t\t\t\tmflags, c->name, sym->name);\n\t\t\t\tR_FREE (mflags);\n\t\t\t\tr_name_filter (method, -1);\n\t\t\t\tr_flag_set (r->flags, method, sym->vaddr, 1);\n\t\t\t}\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" [0x%08\"PFMT64x\" - 0x%08\"PFMT64x\"] %s%s%s\\n\",\n\t\t\t\tc->addr, at_min, at_max, c->name, c->super ? \" \" : \"\",\n\t\t\t\tc->super ? c->super : \"\");\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"\\\"f class.%s = 0x%\"PFMT64x\"\\\"\\n\",\n\t\t\t\tname, at_min);\n\t\t\tif (c->super) {\n\t\t\t\tr_cons_printf (\"\\\"f super.%s.%s = %d\\\"\\n\",\n\t\t\t\t\tc->name, c->super, c->index);\n\t\t\t}\n\t\t\tr_list_foreach (c->methods, iter2, sym) {\n\t\t\t\tchar *mflags = r_core_bin_method_flags_str (sym, mode);\n\t\t\t\tr_cons_printf (\"\\\"f method%s.%s.%s = 0x%\"PFMT64x\"\\\"\\n\", mflags, c->name, sym->name, sym->vaddr);\n\t\t\t\tR_FREE (mflags);\n\t\t\t}\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tif (c->super) {\n\t\t\t\tr_cons_printf (\"%s{\\\"classname\\\":\\\"%s\\\",\\\"addr\\\":%\"PFMT64d\",\\\"index\\\":%\"PFMT64d\",\\\"super\\\":\\\"%s\\\",\\\"methods\\\":[\",\n\t\t\t\t\titer->p ? \",\" : \"\", c->name, c->addr,\n\t\t\t\t\tc->index, c->super);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"%s{\\\"classname\\\":\\\"%s\\\",\\\"addr\\\":%\"PFMT64d\",\\\"index\\\":%\"PFMT64d\",\\\"methods\\\":[\",\n\t\t\t\t\titer->p ? \",\" : \"\", c->name, c->addr,\n\t\t\t\t\tc->index);\n\t\t\t}\n\t\t\tr_list_foreach (c->methods, iter2, sym) {\n\t\t\t\tif (sym->method_flags) {\n\t\t\t\t\tchar *mflags = r_core_bin_method_flags_str (sym, mode);\n\t\t\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\\\"flags\\\":%s,\\\"addr\\\":%\"PFMT64d\"}\",\n\t\t\t\t\t\titer2->p? \",\": \"\", sym->name, mflags, sym->vaddr);\n\t\t\t\t\tR_FREE (mflags);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\\\"addr\\\":%\"PFMT64d\"}\",\n\t\t\t\t\t\titer2->p? \",\": \"\", sym->name, sym->vaddr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_cons_printf (\"]}\");\n\t\t} else {\n\t\t\tint m = 0;\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" [0x%08\"PFMT64x\" - 0x%08\"PFMT64x\"] (sz %d) class %d %s\",\n\t\t\t\tc->addr, at_min, at_max, (at_max - at_min), c->index, c->name);\n\t\t\tif (c->super) {\n\t\t\t\tr_cons_printf (\" super: %s\\n\", c->super);\n\t\t\t} else {\n\t\t\t\tr_cons_newline ();\n\t\t\t}\n\t\t\tr_list_foreach (c->methods, iter2, sym) {\n\t\t\t\tchar *mflags = r_core_bin_method_flags_str (sym, mode);\n\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" method %d %s %s\\n\",\n\t\t\t\t\tsym->vaddr, m, mflags, sym->dname? sym->dname: sym->name);\n\t\t\t\tR_FREE (mflags);\n\t\t\t\tm++;\n\t\t\t}\n\t\t}\n\t\tfree (name);\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"]\");\n\t}\n\n\treturn true;\n}\n\nstatic int bin_size(RCore *r, int mode) {\n\tut64 size = r_bin_get_size (r->bin);\n\tif (IS_MODE_SIMPLE (mode) || IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"%\"PFMT64u\"\\n\", size);\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"f bin_size @ %\"PFMT64u\"\\n\", size);\n\t} else if (IS_MODE_SET (mode)) {\n\t\tr_core_cmdf (r, \"f bin_size @ %\"PFMT64u\"\\n\", size);\n\t} else {\n\t\tr_cons_printf (\"%\"PFMT64u\"\\n\", size);\n\t}\n\treturn true;\n}\n\nstatic int bin_libs(RCore *r, int mode) {\n\tRList *libs;\n\tRListIter *iter;\n\tchar* lib;\n\tint i = 0;\n\n\tif (!(libs = r_bin_get_libs (r->bin))) {\n\t\treturn false;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"[\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_println (\"[Linked libraries]\");\n\t}\n\tr_list_foreach (libs, iter, lib) {\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\t// Nothing to set.\n\t\t\t// TODO: load libraries with iomaps?\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"CCa entry0 %s\\n\", lib);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"%s\\\"%s\\\"\", iter->p ? \",\" : \"\", lib);\n\t\t} else {\n\t\t\t// simple and normal print mode\n\t\t\tr_cons_println (lib);\n\t\t}\n\t\ti++;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"]\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tif (i == 1) {\n\t\t\tr_cons_printf (\"\\n%i library\\n\", i);\n\t\t} else {\n\t\t\tr_cons_printf (\"\\n%i libraries\\n\", i);\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic void bin_mem_print(RList *mems, int perms, int depth, int mode) {\n\tRBinMem *mem;\n\tRListIter *iter;\n\tif (!mems) {\n\t\treturn;\n\t}\n\tr_list_foreach (mems, iter, mem) {\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"{\\\"name\\\":\\\"%s\\\",\\\"size\\\":%d,\\\"address\\\":%d,\"\n\t\t\t\t\t\"\\\"flags\\\":\\\"%s\\\"}\", mem->name, mem->size,\n\t\t\t\t\tmem->addr, r_str_rwx_i (mem->perms & perms));\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"\\n\", mem->addr);\n\t\t} else {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" +0x%04x %s %*s%-*s\\n\",\n\t\t\t\t\tmem->addr, mem->size, r_str_rwx_i (mem->perms & perms),\n\t\t\t\t\tdepth, \"\", 20-depth, mem->name);\n\t\t}\n\t\tif (mem->mirrors) {\n\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\tr_cons_printf (\",\");\n\t\t\t}\n\t\t\tbin_mem_print (mem->mirrors, mem->perms & perms, depth + 1, mode);\n\t\t}\n\t\tif (IS_MODE_JSON(mode)) {\n\t\t\tif (iter->n) {\n\t\t\t\tr_cons_printf (\",\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int bin_mem(RCore *r, int mode) {\n\tRList *mem = NULL;\n\tif (!r)\treturn false;\n\tif (!IS_MODE_JSON(mode)) {\n\t\tif (!(IS_MODE_RAD (mode) || IS_MODE_SET (mode))) {\n\t\t\tr_cons_println (\"[Memory]\\n\");\n\t\t}\n\t}\n\tif (!(mem = r_bin_get_mem (r->bin))) {\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_print(\"[]\");\n\t\t}\n\t\treturn false;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"[\");\n\t\tbin_mem_print (mem, 7, 0, R_CORE_BIN_JSON);\n\t\tr_cons_println (\"]\");\n\t\treturn true;\n\t} else if (!(IS_MODE_RAD (mode) || IS_MODE_SET (mode))) {\n\t\tbin_mem_print (mem, 7, 0, mode);\n\t}\n\treturn true;\n}\n\nstatic void bin_pe_versioninfo(RCore *r) {\n\tSdb *sdb = NULL;\n\tint num_version = 0;\n\tint num_stringtable = 0;\n\tint num_string = 0;\n\tconst char *format_version = \"bin/cur/info/vs_version_info/VS_VERSIONINFO%d\";\n\tconst char *format_stringtable = \"%s/string_file_info/stringtable%d\";\n\tconst char *format_string = \"%s/string%d\";\n\tr_cons_printf (\"=== VS_VERSIONINFO ===\\n\\n\");\n\tdo {\n\t\tchar path_version[256] = R_EMPTY;\n\t\tsnprintf (path_version, sizeof (path_version), format_version, num_version);\n\t\tif (!(sdb = sdb_ns_path (r->sdb, path_version, 0)))\n\t\t\tbreak;\n\t\tr_cons_printf (\"# VS_FIXEDFILEINFO\\n\\n\");\n\t\tchar path_fixedfileinfo[256] = R_EMPTY;\n\t\tsnprintf (path_fixedfileinfo, sizeof (path_fixedfileinfo), \"%s/fixed_file_info\", path_version);\n\t\tif (!(sdb = sdb_ns_path (r->sdb, path_fixedfileinfo, 0)))\n\t\t\tbreak;\n\n\t\tr_cons_printf (\"  Signature: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"Signature\", 0));\n\t\tr_cons_printf (\"  StrucVersion: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"StrucVersion\", 0));\n\t\tr_cons_printf (\"  FileVersion: %\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\"\\n\",\n\t\t\tsdb_num_get (sdb, \"FileVersionMS\", 0) >> 16,\n\t\t\tsdb_num_get (sdb, \"FileVersionMS\", 0) & 0xFFFF,\n\t\t\tsdb_num_get (sdb, \"FileVersionLS\", 0) >> 16,\n\t\t\tsdb_num_get (sdb, \"FileVersionLS\", 0) & 0xFFFF);\n\t\tr_cons_printf (\"  ProductVersion: %\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\"\\n\",\n\t\t\tsdb_num_get (sdb, \"ProductVersionMS\", 0) >> 16,\n\t\t\tsdb_num_get (sdb, \"ProductVersionMS\", 0) & 0xFFFF,\n\t\t\tsdb_num_get (sdb, \"ProductVersionLS\", 0) >> 16,\n\t\t\tsdb_num_get (sdb, \"ProductVersionLS\", 0) & 0xFFFF);\n\t\tr_cons_printf (\"  FileFlagsMask: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"FileFlagsMask\", 0));\n\t\tr_cons_printf (\"  FileFlags: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"FileFlags\", 0));\n\t\tr_cons_printf (\"  FileOS: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"FileOS\", 0));\n\t\tr_cons_printf (\"  FileType: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"FileType\", 0));\n\t\tr_cons_printf (\"  FileSubType: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"FileSubType\", 0));\n#if 0\n\t\tr_cons_printf (\"  FileDate: %d.%d.%d.%d\\n\",\n\t\t\tsdb_num_get (sdb, \"FileDateMS\", 0) >> 16,\n\t\t\tsdb_num_get (sdb, \"FileDateMS\", 0) & 0xFFFF,\n\t\t\tsdb_num_get (sdb, \"FileDateLS\", 0) >> 16,\n\t\t\tsdb_num_get (sdb, \"FileDateLS\", 0) & 0xFFFF);\n#endif\n\t\tr_cons_newline ();\n\t\tr_cons_println (\"# StringTable\\n\");\n\t\tfor (num_stringtable = 0; sdb; ++num_stringtable) {\n\t\t\tchar path_stringtable[256] = R_EMPTY;\n\t\t\tsnprintf (path_stringtable, sizeof (path_stringtable), format_stringtable, path_version, num_stringtable);\n\t\t\tsdb = sdb_ns_path (r->sdb, path_stringtable, 0);\n\t\t\tfor (num_string = 0; sdb; ++num_string) {\n\t\t\t\tchar path_string[256] = R_EMPTY;\n\t\t\t\tsnprintf (path_string, sizeof (path_string), format_string, path_stringtable, num_string);\n\t\t\t\tsdb = sdb_ns_path (r->sdb, path_string, 0);\n\t\t\t\tif (sdb) {\n\t\t\t\t\tint lenkey = 0;\n\t\t\t\t\tint lenval = 0;\n\t\t\t\t\tut8 *key_utf16 = sdb_decode (sdb_const_get (sdb, \"key\", 0), &lenkey);\n\t\t\t\t\tut8 *val_utf16 = sdb_decode (sdb_const_get (sdb, \"value\", 0), &lenval);\n\t\t\t\t\tut8 *key_utf8 = calloc (lenkey * 2, 1);\n\t\t\t\t\tut8 *val_utf8 = calloc (lenval * 2, 1);\n\n\t\t\t\t\tif (r_str_utf16_to_utf8 (key_utf8, lenkey * 2, key_utf16, lenkey, true) < 0\n\t\t\t\t\t\t|| r_str_utf16_to_utf8 (val_utf8, lenval * 2, val_utf16, lenval, true) < 0) {\n\t\t\t\t\t\teprintf (\"Warning: Cannot decode utf16 to utf8\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"  %s: %s\\n\", (char*)key_utf8, (char*)val_utf8);\n\t\t\t\t\t}\n\n\t\t\t\t\tfree (key_utf8);\n\t\t\t\t\tfree (val_utf8);\n\t\t\t\t\tfree (key_utf16);\n\t\t\t\t\tfree (val_utf16);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t++num_version;\n\t} while (sdb);\n}\n\nstatic void bin_elf_versioninfo(RCore *r) {\n\tconst char *format = \"bin/cur/info/versioninfo/%s%d\";\n\tchar path[256] = R_EMPTY;\n\tint num_versym = 0;\n\tint num_verneed = 0;\n\tint num_entry = 0;\n\tSdb *sdb = NULL;\n\tdo {\n\t\tsnprintf (path, sizeof (path), format, \"versym\", num_versym++);\n\t\tif (!(sdb = sdb_ns_path (r->sdb, path, 0))) {\n\t\t\tbreak;\n\t\t}\n\t\tut64 addr = sdb_num_get (sdb, \"addr\", 0);\n\t\tut64 offset = sdb_num_get (sdb, \"offset\", 0);\n\t\tut64 link = sdb_num_get (sdb, \"link\", 0);\n\t\tut64 num_entries = sdb_num_get (sdb, \"num_entries\", 0);\n\t\tconst char *section_name = sdb_const_get (sdb, \"section_name\", 0);\n\t\tconst char *link_section_name = sdb_const_get (sdb, \"link_section_name\", 0);\n\n\t\tr_cons_printf (\"Version symbols section '%s' contains %\"PFMT64u\" entries:\\n\", section_name, num_entries);\n\t\tr_cons_printf (\" Addr: 0x%08\"PFMT64x\"  Offset: 0x%08\"PFMT64x\"  Link: %x (%s)\\n\",\n\t\t\t(ut64)addr, (ut64)offset, (ut32)link, link_section_name);\n\n\t\tdo {\n\t\t\tint num_val = 0;\n\t\t\tchar path_entry[256] = R_EMPTY;\n\t\t\tsnprintf (path_entry, sizeof (path_entry), \"%s/entry%d\", path, num_entry++);\n\t\t\tif (!(sdb = sdb_ns_path (r->sdb, path_entry, 0)))\n\t\t\t\tbreak;\n\n\t\t\tr_cons_printf (\"  0x%08\"PFMT64x\": \", sdb_num_get (sdb, \"idx\", 0));\n\t\t\tconst char *value = NULL;\n\n\t\t\tdo {\n\t\t\t\tchar key[32] = R_EMPTY;\n\t\t\t\tsnprintf (key, sizeof (key), \"value%d\", num_val++);\n\n\t\t\t\tif ((value = sdb_const_get (sdb, key, 0)))\n\t\t\t\t\tr_cons_printf (\"%s \", value);\n\t\t\t} while (value);\n\t\t\tr_cons_newline ();\n\t\t} while (sdb);\n\t\tr_cons_println (\"\\n\");\n\t} while (sdb);\n\n\tdo {\n\t\tint num_version = 0;\n\t\tchar path_version[256] = R_EMPTY;\n\t\tsnprintf (path, sizeof (path), format, \"verneed\", num_verneed++);\n\t\tif (!(sdb = sdb_ns_path (r->sdb, path, 0)))\n\t\t\tbreak;\n\n\t\tr_cons_printf (\"Version need section '%s' contains %d entries:\\n\",\n\t\t\tsdb_const_get (sdb, \"section_name\", 0), (int)sdb_num_get (sdb, \"num_entries\", 0));\n\n\t\tr_cons_printf (\" Addr: 0x%08\"PFMT64x, sdb_num_get (sdb, \"addr\", 0));\n\n\t\tr_cons_printf (\"  Offset: 0x%08\"PFMT64x\"  Link to section: %\"PFMT64d\" (%s)\\n\",\n\t\t\tsdb_num_get (sdb, \"offset\", 0), sdb_num_get (sdb, \"link\", 0),\n\t\t\tsdb_const_get (sdb, \"link_section_name\", 0));\n\n\t\tdo {\n\t\t\tsnprintf (path_version, sizeof (path_version), \"%s/version%d\", path, num_version++);\n\t\t\tconst char *filename = NULL;\n\t\t\tchar path_vernaux[256] = R_EMPTY;\n\t\t\tint num_vernaux = 0;\n\t\t\tif (!(sdb = sdb_ns_path (r->sdb, path_version, 0)))\n\t\t\t\tbreak;\n\n\t\t\tr_cons_printf (\"  0x%08\"PFMT64x\": Version: %d\",\n\t\t\t\tsdb_num_get (sdb, \"idx\", 0), (int)sdb_num_get (sdb, \"vn_version\", 0));\n\n\t\t\tif ((filename = sdb_const_get (sdb, \"file_name\", 0)))\n\t\t\t\tr_cons_printf (\"  File: %s\", filename);\n\n\t\t\tr_cons_printf (\"  Cnt: %d\\n\", (int)sdb_num_get (sdb, \"cnt\", 0));\n\t\t\tdo {\n\t\t\t\tsnprintf (path_vernaux, sizeof (path_vernaux), \"%s/vernaux%d\",\n\t\t\t\t\tpath_version, num_vernaux++);\n\t\t\t\tif (!(sdb = sdb_ns_path (r->sdb, path_vernaux, 0)))\n\t\t\t\t\tbreak;\n\n\t\t\t\tr_cons_printf (\"  0x%08\"PFMT64x\":   Name: %s\",\n\t\t\t\t\tsdb_num_get (sdb, \"idx\", 0), sdb_const_get (sdb, \"name\", 0));\n\n\t\t\t\tr_cons_printf (\"  Flags: %s Version: %d\\n\",\n\t\t\t\t\tsdb_const_get (sdb, \"flags\", 0), (int)sdb_num_get (sdb, \"version\", 0));\n\t\t\t} while (sdb);\n\t\t} while (sdb);\n\t} while (sdb);\n}\n\nstatic void bin_mach0_versioninfo(RCore *r) {\n\t/* TODO */\n}\n\nstatic void bin_pe_resources(RCore *r, int mode) {\n\tSdb *sdb = NULL;\n\tint index = 0;\n\tconst char *pe_path = \"bin/cur/info/pe_resource\";\n\tif (!(sdb = sdb_ns_path (r->sdb, pe_path, 0))) {\n\t\treturn;\n\t}\n\tif (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, \"resources\");\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"fs resources\\n\");\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"[\");\n\t}\n\twhile (true) {\n\t\tconst char *timestrKey = sdb_fmt (0, \"resource.%d.timestr\", index);\n\t\tconst char *paddrKey = sdb_fmt (1, \"resource.%d.paddr\", index);\n\t\tconst char *sizeKey  = sdb_fmt (2, \"resource.%d.size\", index);\n\t\tconst char *typeKey  = sdb_fmt (3, \"resource.%d.type\", index);\n\t\tconst char *languageKey = sdb_fmt (4, \"resource.%d.language\", index);\n\t\tconst char *nameKey = sdb_fmt (5, \"resource.%d.name\", index);\n\t\tchar *timestr = sdb_get (sdb, timestrKey, 0);\n\t\tif (!timestr) {\n\t\t\tbreak;\n\t\t}\n\t\tut64 paddr = sdb_num_get (sdb, paddrKey, 0);\n\t\tint size = (int)sdb_num_get (sdb, sizeKey, 0);\n\t\tint name = (int)sdb_num_get (sdb, nameKey, 0);\n\t\tchar *type = sdb_get (sdb, typeKey, 0);\n\t\tchar *lang = sdb_get (sdb, languageKey, 0);\n\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\tconst char *name = sdb_fmt (4, \"resource.%d\", index);\n\t\t\tr_flag_set (r->flags, name, paddr, size);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"f resource.%d %d 0x%08\"PFMT32x\"\\n\", index, size, paddr); \n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf(\"%s{\\\"name\\\":%d,\\\"index\\\":%d, \\\"type\\\":\\\"%s\\\",\" \n\t\t\t\t\t\"\\\"paddr\\\":%\"PFMT32d\", \\\"size\\\":%d, \\\"lang\\\":\\\"%s\\\"}\", \n\t\t\t\t\tindex? \",\": \"\", name, index, type, paddr, size, lang);\n\t\t} else {\n\t\t\tchar *humanSize = r_num_units (NULL, size);\n\t\t\tr_cons_printf (\"Resource %d\\n\", index);\n\t\t\tr_cons_printf (\"\\tname: %d\\n\", name);\n\t\t\tr_cons_printf (\"\\ttimestamp: %s\\n\", timestr);\n\t\t\tr_cons_printf (\"\\tpaddr: 0x%08\"PFMT32x\"\\n\", paddr);\n\t\t\tr_cons_printf (\"\\tsize: %s\\n\", humanSize);\n\t\t\tr_cons_printf (\"\\ttype: %s\\n\", type);\n\t\t\tr_cons_printf (\"\\tlanguage: %s\\n\", lang);\n\t\t\tfree (humanSize);\n\t\t}\n\t\tindex++;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"]\");\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"fs *\");\n\t}\n}\n\n\nstatic int bin_resources(RCore *r, int mode) {\n\tconst RBinInfo *info = r_bin_get_info (r->bin);\n\tif (!info || !info->rclass) {\n\t\treturn false;\n\t}\n\tif (!strncmp (\"pe\", info->rclass, 2)) {\n\t\tbin_pe_resources (r, mode);\n\t}\n\treturn true;\n}\n\nstatic int bin_versioninfo(RCore *r, int mode) {\n\tconst RBinInfo *info = r_bin_get_info (r->bin);\n\tif (!info || !info->rclass) {\n\t\treturn false;\n\t}\n\tif (!strncmp (\"pe\", info->rclass, 2)) {\n\t\tbin_pe_versioninfo (r);\n\t} else if (!strncmp (\"elf\", info->rclass, 3)) {\n\t\tbin_elf_versioninfo (r);\n\t} else if (!strncmp (\"mach0\", info->rclass, 5)) {\n\t\tbin_mach0_versioninfo (r);\n\t} else {\n\t\tr_cons_println (\"Unknown format\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic int bin_signature(RCore *r, int mode) {\n\tRBinFile *cur = r_bin_cur (r->bin);\n\tRBinPlugin *plg = r_bin_file_cur_plugin (cur);\n\tif (plg && plg->signature) {\n\t\tconst char *signature = plg->signature (cur, IS_MODE_JSON (mode));\n\t\tr_cons_println (signature);\n\t\tfree ((char*) signature);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\nR_API void r_core_bin_export_info_rad(RCore *core) {\n\tSdb *db = NULL;\n\tchar *flagname, *offset = NULL;\n\tRBinFile *bf = r_core_bin_cur (core);\n\tif (!bf) {\n\t\treturn;\n\t}\n\tdb = sdb_ns (bf->sdb, \"info\", 0);;\n\tif (!db) {\n\t\treturn;\n\t}\n\tif (db) {\n\t\tSdbListIter *iter;\n\t\tSdbKv *kv;\n\t\tr_cons_printf (\"fs format\\n\");\n\t\t// iterate over all keys\n\t\tSdbList *ls = sdb_foreach_list (db, false);\n\t\tls_foreach (ls, iter, kv) {\n\t\t\tchar *k = kv->key;\n\t\t\tchar *v = kv->value;\n\t\t\tchar *dup = strdup (k);\n\t\t\t//printf (\"?e (%s) (%s)\\n\", k, v);\n\n\t\t\tif ((flagname = strstr (dup, \".offset\"))) {\n\t\t\t\t*flagname = 0;\n\t\t\t\tflagname = dup;\n\t\t\t\tr_cons_printf (\"f %s @ %s\\n\", flagname, v);\n\t\t\t\tfree (offset);\n\t\t\t\toffset = strdup (v);\n\t\t\t}\n\t\t\tif ((flagname = strstr (dup, \".cparse\"))) {\n\t\t\t\tr_cons_printf (\"\\\"td %s\\\"\\n\", v);\n\t\t\t}\n\t\t\tfree (dup);\n\t\t}\n\t\tR_FREE (offset);\n\t\tls_foreach (ls, iter, kv) {\n\t\t\tchar *dup = kv->key;\n\t\t\tchar *v = kv->value;\n\t\t\tif ((flagname = strstr (dup, \".format\"))) {\n\t\t\t\t*flagname = 0;\n\t\t\t\tif (!offset) {\n\t\t\t\t\toffset = strdup (\"0\");\n\t\t\t\t}\n\t\t\t\tflagname = dup;\n\t\t\t\tr_cons_printf (\"pf.%s %s\\n\", flagname, v);\n\t\t\t\tint fmtsize = r_print_format_struct_size (v, core->print, 0);\n\t\t\t\tchar *offset_key = r_str_newf (\"%s.offset\", flagname);\n\t\t\t\tconst char *off = sdb_const_get (db, offset_key, 0);\n\t\t\t\tfree (offset_key);\n\t\t\t\tif (off) {\n\t\t\t\t\tr_cons_printf (\"Cf %d %s @ %s\\n\", fmtsize, v, off);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((flagname = strstr (dup, \".size\"))) {\n\t\t\t\t*flagname = 0;\n\t\t\t\tflagname = dup;\n\t\t\t\tr_cons_printf (\"fl %s %s\\n\", flagname, v);\n\t\t\t}\n\t\t}\n\t\tfree (offset);\n\t}\n}\n\nstatic int bin_header(RCore *r, int mode) {\n\tRBinFile *cur = r_bin_cur (r->bin);\n\tRBinPlugin *plg = r_bin_file_cur_plugin (cur);\n\tif (plg && plg->header) {\n\t\tplg->header (cur);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API int r_core_bin_info(RCore *core, int action, int mode, int va, RCoreBinFilter *filter, const char *chksum) {\n\tint ret = true;\n\tconst char *name = NULL;\n\tut64 at = 0, loadaddr = r_bin_get_laddr (core->bin);\n\tif (filter && filter->offset) {\n\t\tat = filter->offset;\n\t}\n\tif (filter && filter->name) {\n\t\tname = filter->name;\n\t}\n\t// use our internal values for va\n\tva = va ? VA_TRUE : VA_FALSE;\n\tif (r_config_get_i (core->config, \"anal.strings\")) {\n\t\tr_core_cmd0 (core, \"aar\");\n\t}\n\tif ((action & R_CORE_BIN_ACC_STRINGS)) ret &= bin_strings (core, mode, va);\n\tif ((action & R_CORE_BIN_ACC_RAW_STRINGS)) ret &= bin_raw_strings (core, mode, va);\n\tif ((action & R_CORE_BIN_ACC_INFO)) ret &= bin_info (core, mode);\n\tif ((action & R_CORE_BIN_ACC_MAIN)) ret &= bin_main (core, mode, va);\n\tif ((action & R_CORE_BIN_ACC_DWARF)) ret &= bin_dwarf (core, mode);\n\tif ((action & R_CORE_BIN_ACC_PDB)) ret &= bin_pdb (core, mode);\n\tif ((action & R_CORE_BIN_ACC_ENTRIES)) ret &= bin_entry (core, mode, loadaddr, va);\n\tif ((action & R_CORE_BIN_ACC_SECTIONS)) ret &= bin_sections (core, mode, loadaddr, va, at, name, chksum);\n\tif (r_config_get_i (core->config, \"bin.relocs\")) {\n\t\tif ((action & R_CORE_BIN_ACC_RELOCS)) ret &= bin_relocs (core, mode, va);\n\t}\n\tif ((action & R_CORE_BIN_ACC_IMPORTS)) ret &= bin_imports (core, mode, va, name);\n\tif ((action & R_CORE_BIN_ACC_EXPORTS)) ret &= bin_exports (core, mode, loadaddr, va, at, name);\n\tif ((action & R_CORE_BIN_ACC_SYMBOLS)) ret &= bin_symbols (core, mode, loadaddr, va, at, name);\n\tif ((action & R_CORE_BIN_ACC_LIBS)) ret &= bin_libs (core, mode);\n\tif ((action & R_CORE_BIN_ACC_CLASSES)) ret &= bin_classes (core, mode);\n\tif ((action & R_CORE_BIN_ACC_SIZE)) ret &= bin_size (core, mode);\n\tif ((action & R_CORE_BIN_ACC_MEM)) ret &= bin_mem (core, mode);\n\tif ((action & R_CORE_BIN_ACC_VERSIONINFO)) ret &= bin_versioninfo (core, mode);\n\tif ((action & R_CORE_BIN_ACC_RESOURCES)) ret &= bin_resources (core, mode);\n\tif ((action & R_CORE_BIN_ACC_SIGNATURE)) ret &= bin_signature (core, mode);\n\tif ((action & R_CORE_BIN_ACC_FIELDS)) {\n\t\tif (IS_MODE_SIMPLE (mode)) {\n\t\t\tif ((action & R_CORE_BIN_ACC_HEADER) || action & R_CORE_BIN_ACC_FIELDS) {\n\t\t\t\t/* ignore mode, just for quiet/simple here */\n\t\t\t\tret &= bin_fields (core, 0, va);\n\t\t\t}\n\t\t} else {\n\t\t\tif (IS_MODE_NORMAL(mode)) {\n\t\t\t\tret &= bin_header (core, mode);\n\t\t\t} else {\n\t\t\t\tif ((action & R_CORE_BIN_ACC_HEADER) || action & R_CORE_BIN_ACC_FIELDS) {\n\t\t\t\t\tret &= bin_fields (core, mode, va);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nR_API int r_core_bin_set_arch_bits(RCore *r, const char *name, const char * arch, ut16 bits) {\n\tRCoreFile *cf = r_core_file_cur (r);\n\tRBinFile *binfile;\n\tif (!name) {\n\t\tname = (cf && cf->desc) ? cf->desc->name : NULL;\n\t}\n\tif (!name) {\n\t\treturn false;\n\t}\n\t/* Check if the arch name is a valid name */\n\tif (!r_asm_is_valid (r->assembler, arch)) {\n\t\treturn false;\n\t}\n\t/* Find a file with the requested name/arch/bits */\n\tbinfile = r_bin_file_find_by_arch_bits (r->bin, arch, bits, name);\n\tif (!binfile) {\n\t\treturn false;\n\t}\n\tif (!r_bin_use_arch (r->bin, arch, bits, name)) {\n\t\treturn false;\n\t}\n\tr_core_bin_set_cur (r, binfile);\n\treturn r_core_bin_set_env (r, binfile);\n}\n\nR_API int r_core_bin_update_arch_bits(RCore *r) {\n\tRBinFile *binfile = NULL;\n\tconst char *name = NULL, *arch = NULL;\n\tut16 bits = 0;\n\tif (!r) {\n\t\treturn 0;\n\t}\n\tif (r->assembler) {\n\t\tbits = r->assembler->bits;\n\t   \tif (r->assembler->cur) {\n\t\t\tarch = r->assembler->cur->arch;\n\t\t}\n\t}\n\tbinfile = r_core_bin_cur (r);\n\tname = binfile ? binfile->file : NULL;\n\tif (r && r->bin && r->bin->binxtrs) {\n\t\tr_anal_hint_clear (r->anal);\n\t}\n\treturn r_core_bin_set_arch_bits (r, name, arch, bits);\n}\n\nR_API int r_core_bin_raise(RCore *core, ut32 binfile_idx, ut32 binobj_idx) {\n\tRBin *bin = core->bin;\n\tRBinFile *binfile = NULL;\n\n\tif (binfile_idx == UT32_MAX && binobj_idx == UT32_MAX) {\n\t\treturn false;\n\t}\n\tif (!r_bin_select_by_ids (bin, binfile_idx, binobj_idx)) {\n\t\treturn false;\n\t}\n\tbinfile = r_core_bin_cur (core);\n\tif (binfile) {\n\t\tr_io_raise (core->io, binfile->fd);\n\t}\n\t// it should be 0 to use r_io_use_fd in r_core_block_read\n\tcore->switch_file_view = 0;\n\treturn binfile && r_core_bin_set_env (core, binfile) && r_core_block_read (core);\n}\n\nR_API bool r_core_bin_delete(RCore *core, ut32 binfile_idx, ut32 binobj_idx) {\n\tif (binfile_idx == UT32_MAX && binobj_idx == UT32_MAX) {\n\t\treturn false;\n\t}\n\tif (!r_bin_object_delete (core->bin, binfile_idx, binobj_idx)) {\n\t\treturn false;\n\t}\n\tRBinFile *binfile = r_core_bin_cur (core);\n\tif (binfile) {\n\t\tr_io_raise (core->io, binfile->fd);\n\t}\n\tcore->switch_file_view = 0;\n\treturn binfile && r_core_bin_set_env (core, binfile) && r_core_block_read (core);\n}\n\nstatic int r_core_bin_file_print(RCore *core, RBinFile *binfile, int mode) {\n\tRListIter *iter;\n\tRBinObject *obj;\n\tconst char *name = binfile ? binfile->file : NULL;\n\t(void)r_bin_get_info (core->bin); // XXX is this necssary for proper iniitialization\n\tut32 id = binfile ? binfile->id : 0;\n\tut32 fd = binfile ? binfile->fd : 0;\n\tut32 bin_sz = binfile ? binfile->size : 0;\n\t// TODO: handle mode to print in json and r2 commands\n\n\tif (!binfile) {\n\t\treturn false;\n\t}\n\tswitch (mode) {\n\tcase 'j':\n\t\tr_cons_printf (\"{\\\"name\\\":\\\"%s\\\",\\\"fd\\\":%d,\\\"id\\\":%d,\\\"size\\\":%d,\\\"objs\\\":[\",\n\t\t\tname, fd, id, bin_sz);\n\t\tr_list_foreach (binfile->objs, iter, obj) {\n\t\t\tRBinInfo *info = obj->info;\n\t\t\tut8 bits = info ? info->bits : 0;\n\t\t\tconst char *arch = info ? info->arch : \"unknown\";\n\t\t\tr_cons_printf (\"{\\\"objid\\\":%d,\\\"arch\\\":\\\"%s\\\",\\\"bits\\\":%d,\\\"binoffset\\\":%\"\n\t\t\t\t\tPFMT64d\",\\\"objsize\\\":%\"PFMT64d\"}\",\n\t\t\t\t\tobj->id, arch, bits, obj->boffset, obj->obj_size);\n\t\t\tif (iter->n) {\n\t\t\t\tr_cons_print (\",\");\n\t\t\t}\n\t\t}\n\t\tr_cons_print (\"]}\");\n\t\tbreak;\n\tdefault:\n\t\tr_cons_printf (\"binfile fd=%d name=%s id=%d\\n\", fd, name, id);\n\t\tr_list_foreach (binfile->objs, iter, obj) {\n\t\t\tRBinInfo *info = obj->info;\n\t\t\tut8 bits = info ? info->bits : 0;\n\t\t\tconst char *arch = info ? info->arch : \"unknown\";\n\t\t\tif (!arch) {\n\t\t\t\tarch = r_config_get (core->config, \"asm.arch\");\n\t\t\t}\n\t\t\tr_cons_printf (\"objid=%d arch=%s bits=%d boffset=0x%04\"PFMT64x\" size=0x%04\"PFMT64x\"\\n\",\n\t\t\t\t\tobj->id, arch, bits, obj->boffset, obj->obj_size );\n\t\t}\n\t\tbreak;\n\t}\n\treturn true;\n}\n\nR_API int r_core_bin_list(RCore *core, int mode) {\n\t// list all binfiles and there objects and there archs\n\tint count = 0;\n\tRListIter *iter;\n\tRBinFile *binfile = NULL; //, *cur_bf = r_core_bin_cur (core) ;\n\tRBin *bin = core->bin;\n\tconst RList *binfiles = bin ? bin->binfiles: NULL;\n\tif (!binfiles) {\n\t\treturn false;\n\t}\n\tif (mode == 'j') {\n\t\tr_cons_print (\"[\");\n\t}\n\tr_list_foreach (binfiles, iter, binfile) {\n\t\tr_core_bin_file_print (core, binfile, mode);\n\t\tif (iter->n && mode == 'j') {\n\t\t\tr_cons_print (\",\");\n\t\t}\n\t}\n\tif (mode == 'j') {\n\t\tr_cons_println (\"]\");\n\t}\n\t//r_core_file_set_by_file (core, cur_cf);\n\t//r_core_bin_bind (core, cur_bf);\n\treturn count;\n}\n\nR_API char *r_core_bin_method_flags_str(RBinSymbol *sym, int mode) {\n\tchar *str;\n\tRStrBuf *buf;\n\tint i, len = 0;\n\n\tbuf = r_strbuf_new (\"\");\n\tif (IS_MODE_SET (mode) || IS_MODE_RAD (mode)) {\n\t\tif (!sym->method_flags) {\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i != 64; i++) {\n\t\t\tut64 flag = sym->method_flags & (1L << i);\n\t\t\tif (flag) {\n\t\t\t\tconst char *flag_string = r_bin_get_meth_flag_string (flag, false);\n\t\t\t\tif (flag_string) {\n\t\t\t\t\tr_strbuf_appendf (buf, \".%s\", flag_string);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tif (!sym->method_flags) {\n\t\t\tr_strbuf_append (buf, \"[]\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tr_strbuf_append (buf, \"[\");\n\n\t\tfor (i = 0; i != 64; i++) {\n\t\t\tut64 flag = sym->method_flags & (1L << i);\n\t\t\tif (flag) {\n\t\t\t\tconst char *flag_string = r_bin_get_meth_flag_string (flag, false);\n\n\t\t\t\tif (len != 0) {\n\t\t\t\t\tr_strbuf_append (buf, \",\");\n\t\t\t\t}\n\t\t\t\tif (flag_string) {\n\t\t\t\t\tr_strbuf_appendf (buf, \"\\\"%s\\\"\", flag_string);\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_appendf (buf, \"\\\"0x%08\"PFMT64x\"\\\"\", flag);\n\t\t\t\t}\n\t\t\t\tlen++;\n\t\t\t}\n\t\t}\n\n\t\tr_strbuf_append (buf, \"]\");\n\t} else {\n\t\tint pad_len = 4; //TODO: move to a config variable\n\n\t\tif (!sym->method_flags) {\n\t\t\tgoto padding;\n\t\t}\n\t\tfor (i = 0; i != 64; i++) {\n\t\t\tut64 flag = sym->method_flags & (1L << i);\n\t\t\tif (flag) {\n\t\t\t\tconst char *flag_string = r_bin_get_meth_flag_string (flag, true);\n\n\t\t\t\tif (flag_string) {\n\t\t\t\t\tr_strbuf_append (buf, flag_string);\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_append (buf, \"?\");\n\t\t\t\t}\n\n\t\t\t\tlen++;\n\t\t\t}\n\t\t}\npadding:\n\t\tfor ( ; len < pad_len; len++) {\n\t\t\tr_strbuf_append (buf, \" \");\n\t\t}\n\t}\n\nout:\n\tstr = strdup (r_strbuf_get (buf));\n\tr_strbuf_free (buf);\n\n\treturn str;\n}\n"], "filenames": ["libr/config/config.c", "libr/core/cbin.c"], "buggy_code_start_loc": [391, 99], "buggy_code_end_loc": [392, 116], "fixing_code_start_loc": [391, 99], "fixing_code_end_loc": [394, 120], "type": "CWE-416", "message": "The r_config_set function in libr/config/config.c in radare2 1.5.0 allows remote attackers to cause a denial of service (use-after-free and application crash) via a crafted DEX file.", "other": {"cve": {"id": "CVE-2017-9520", "sourceIdentifier": "cve@mitre.org", "published": "2017-06-08T14:29:00.297", "lastModified": "2017-06-27T14:57:55.227", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The r_config_set function in libr/config/config.c in radare2 1.5.0 allows remote attackers to cause a denial of service (use-after-free and application crash) via a crafted DEX file."}, {"lang": "es", "value": "La funci\u00f3n r_config_set en el archivo libr/config/config.c en radare2 versi\u00f3n 1.5.0, permite a los atacantes remotos causar una denegaci\u00f3n de servicio (uso de memoria previamente liberada y bloqueo de aplicaci\u00f3n) por medio de un archivo DEX especialmente dise\u00f1ado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:1.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "1F6336FC-AB50-4F45-B01E-2BC3BA758117"}]}]}], "references": [{"url": "https://github.com/radare/radare2/commit/f85bc674b2a2256a364fe796351bc1971e106005", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/radare/radare2/issues/7698", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}]}, "github_commit_url": "https://github.com/radare/radare2/commit/f85bc674b2a2256a364fe796351bc1971e106005"}}