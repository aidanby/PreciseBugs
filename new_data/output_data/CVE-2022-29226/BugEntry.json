{"buggy_code": ["#include \"source/extensions/filters/http/oauth2/filter.h\"\n\n#include <algorithm>\n#include <chrono>\n#include <memory>\n#include <string>\n#include <vector>\n\n#include \"source/common/common/assert.h\"\n#include \"source/common/common/empty_string.h\"\n#include \"source/common/common/enum_to_int.h\"\n#include \"source/common/common/fmt.h\"\n#include \"source/common/common/hex.h\"\n#include \"source/common/common/matchers.h\"\n#include \"source/common/crypto/utility.h\"\n#include \"source/common/http/header_map_impl.h\"\n#include \"source/common/http/header_utility.h\"\n#include \"source/common/http/headers.h\"\n#include \"source/common/http/message_impl.h\"\n#include \"source/common/http/utility.h\"\n#include \"source/common/protobuf/utility.h\"\n\n#include \"absl/strings/escaping.h\"\n#include \"absl/strings/match.h\"\n#include \"absl/strings/str_cat.h\"\n#include \"absl/strings/str_join.h\"\n#include \"absl/strings/str_replace.h\"\n#include \"absl/strings/str_split.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace HttpFilters {\nnamespace Oauth2 {\n\nnamespace {\nHttp::RegisterCustomInlineHeader<Http::CustomInlineHeaderRegistry::Type::RequestHeaders>\n    authorization_handle(Http::CustomHeaders::get().Authorization);\n\n// Deleted OauthHMAC cookie.\nconstexpr const char* SignoutCookieValue =\n    \"{}=deleted; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT\";\n\n// Deleted BearerToken cookie.\nconstexpr const char* SignoutBearerTokenValue =\n    \"{}=deleted; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT\";\n\nconstexpr absl::string_view SignoutIdTokenValue =\n    \"IdToken=deleted; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT\";\n\nconstexpr absl::string_view SignoutRefreshTokenValue =\n    \"RefreshToken=deleted; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT\";\n\nconstexpr const char* CookieTailFormatString = \";version=1;path=/;Max-Age={};secure\";\n\nconstexpr const char* CookieTailHttpOnlyFormatString =\n    \";version=1;path=/;Max-Age={};secure;HttpOnly\";\n\nconst char* AuthorizationEndpointFormat =\n    \"{}?client_id={}&scope={}&response_type=code&redirect_uri={}&state={}\";\n\nconstexpr absl::string_view UnauthorizedBodyMessage = \"OAuth flow failed.\";\n\nconst std::string& queryParamsError() { CONSTRUCT_ON_FIRST_USE(std::string, \"error\"); }\nconst std::string& queryParamsCode() { CONSTRUCT_ON_FIRST_USE(std::string, \"code\"); }\nconst std::string& queryParamsState() { CONSTRUCT_ON_FIRST_USE(std::string, \"state\"); }\n\nconstexpr absl::string_view REDIRECT_RACE = \"oauth.race_redirect\";\nconstexpr absl::string_view REDIRECT_LOGGED_IN = \"oauth.logged_in\";\nconstexpr absl::string_view REDIRECT_FOR_CREDENTIALS = \"oauth.missing_credentials\";\nconstexpr absl::string_view SIGN_OUT = \"oauth.sign_out\";\nconstexpr absl::string_view DEFAULT_AUTH_SCOPE = \"user\";\n\ntemplate <class T>\nstd::vector<Http::HeaderUtility::HeaderData> headerMatchers(const T& matcher_protos) {\n  std::vector<Http::HeaderUtility::HeaderData> matchers;\n  matchers.reserve(matcher_protos.size());\n\n  for (const auto& proto : matcher_protos) {\n    matchers.emplace_back(proto);\n  }\n\n  return matchers;\n}\n\n// Transforms the proto list of 'auth_scopes' into a vector of std::string, also\n// handling the default value logic.\nstd::vector<std::string>\nauthScopesList(const Protobuf::RepeatedPtrField<std::string>& auth_scopes_protos) {\n  std::vector<std::string> scopes;\n\n  // If 'auth_scopes' is empty it must return a list with the default value.\n  if (auth_scopes_protos.empty()) {\n    scopes.emplace_back(DEFAULT_AUTH_SCOPE);\n  } else {\n    scopes.reserve(auth_scopes_protos.size());\n\n    for (const auto& scope : auth_scopes_protos) {\n      scopes.emplace_back(scope);\n    }\n  }\n  return scopes;\n}\n\n// Transforms the proto list into encoded resource params\n// Takes care of percentage encoding http and https is needed\nstd::string encodeResourceList(const Protobuf::RepeatedPtrField<std::string>& resources_protos) {\n  std::string result = \"\";\n  for (const auto& resource : resources_protos) {\n    result += \"&resource=\" + Http::Utility::PercentEncoding::encode(resource, \":/=&? \");\n  }\n  return result;\n}\n\n// Sets the auth token as the Bearer token in the authorization header.\nvoid setBearerToken(Http::RequestHeaderMap& headers, const std::string& token) {\n  headers.setInline(authorization_handle.handle(), absl::StrCat(\"Bearer \", token));\n}\n\nstd::string findValue(const absl::flat_hash_map<std::string, std::string>& map,\n                      const std::string& key) {\n  const auto value_it = map.find(key);\n  return value_it != map.end() ? value_it->second : EMPTY_STRING;\n}\n} // namespace\n\nFilterConfig::FilterConfig(\n    const envoy::extensions::filters::http::oauth2::v3::OAuth2Config& proto_config,\n    Upstream::ClusterManager& cluster_manager, std::shared_ptr<SecretReader> secret_reader,\n    Stats::Scope& scope, const std::string& stats_prefix)\n    : oauth_token_endpoint_(proto_config.token_endpoint()),\n      authorization_endpoint_(proto_config.authorization_endpoint()),\n      client_id_(proto_config.credentials().client_id()),\n      redirect_uri_(proto_config.redirect_uri()),\n      redirect_matcher_(proto_config.redirect_path_matcher()),\n      signout_path_(proto_config.signout_path()), secret_reader_(secret_reader),\n      stats_(FilterConfig::generateStats(stats_prefix, scope)),\n      encoded_auth_scopes_(Http::Utility::PercentEncoding::encode(\n          absl::StrJoin(authScopesList(proto_config.auth_scopes()), \" \"), \":/=&? \")),\n      encoded_resource_query_params_(encodeResourceList(proto_config.resources())),\n      forward_bearer_token_(proto_config.forward_bearer_token()),\n      pass_through_header_matchers_(headerMatchers(proto_config.pass_through_matcher())),\n      cookie_names_(proto_config.credentials().cookie_names()) {\n  if (!cluster_manager.clusters().hasCluster(oauth_token_endpoint_.cluster())) {\n    throw EnvoyException(fmt::format(\"OAuth2 filter: unknown cluster '{}' in config. Please \"\n                                     \"specify which cluster to direct OAuth requests to.\",\n                                     oauth_token_endpoint_.cluster()));\n  }\n}\n\nFilterStats FilterConfig::generateStats(const std::string& prefix, Stats::Scope& scope) {\n  return {ALL_OAUTH_FILTER_STATS(POOL_COUNTER_PREFIX(scope, prefix))};\n}\n\nvoid OAuth2CookieValidator::setParams(const Http::RequestHeaderMap& headers,\n                                      const std::string& secret) {\n  const auto& cookies = Http::Utility::parseCookies(headers, [this](absl::string_view key) -> bool {\n    return key == cookie_names_.oauth_expires_ || key == cookie_names_.bearer_token_ ||\n           key == cookie_names_.oauth_hmac_ || key == \"IdToken\" || key == \"RefreshToken\";\n  });\n\n  expires_ = findValue(cookies, cookie_names_.oauth_expires_);\n  token_ = findValue(cookies, cookie_names_.bearer_token_);\n  id_token_ = findValue(cookies, \"IdToken\");\n  refresh_token_ = findValue(cookies, \"RefreshToken\");\n  hmac_ = findValue(cookies, cookie_names_.oauth_hmac_);\n  host_ = headers.Host()->value().getStringView();\n\n  secret_.assign(secret.begin(), secret.end());\n}\n\nbool OAuth2CookieValidator::hmacIsValid() const {\n  auto& crypto_util = Envoy::Common::Crypto::UtilitySingleton::get();\n  const auto hmac_payload = absl::StrCat(host_, expires_, token_, id_token_, refresh_token_);\n  const auto pre_encoded_hmac = Hex::encode(crypto_util.getSha256Hmac(secret_, hmac_payload));\n  std::string encoded_hmac;\n  absl::Base64Escape(pre_encoded_hmac, &encoded_hmac);\n\n  return encoded_hmac == hmac_;\n}\n\nbool OAuth2CookieValidator::timestampIsValid() const {\n  uint64_t expires;\n  if (!absl::SimpleAtoi(expires_, &expires)) {\n    return false;\n  }\n\n  const auto current_epoch = time_source_.systemTime().time_since_epoch();\n  return std::chrono::seconds(expires) > current_epoch;\n}\n\nbool OAuth2CookieValidator::isValid() const { return hmacIsValid() && timestampIsValid(); }\n\nOAuth2Filter::OAuth2Filter(FilterConfigSharedPtr config,\n                           std::unique_ptr<OAuth2Client>&& oauth_client, TimeSource& time_source)\n    : validator_(std::make_shared<OAuth2CookieValidator>(time_source, config->cookieNames())),\n      oauth_client_(std::move(oauth_client)), config_(std::move(config)),\n      time_source_(time_source) {\n\n  oauth_client_->setCallbacks(*this);\n}\n\nconst std::string& OAuth2Filter::bearerPrefix() const {\n  CONSTRUCT_ON_FIRST_USE(std::string, \"bearer \");\n}\n\nstd::string OAuth2Filter::extractAccessToken(const Http::RequestHeaderMap& headers) const {\n  ASSERT(headers.Path() != nullptr);\n\n  // Start by looking for a bearer token in the Authorization header.\n  const Http::HeaderEntry* authorization = headers.getInline(authorization_handle.handle());\n  if (authorization != nullptr) {\n    const auto value = StringUtil::trim(authorization->value().getStringView());\n    const auto& bearer_prefix = bearerPrefix();\n    if (absl::StartsWithIgnoreCase(value, bearer_prefix)) {\n      const size_t start = bearer_prefix.length();\n      return std::string(StringUtil::ltrim(value.substr(start)));\n    }\n  }\n\n  // Check for the named query string parameter.\n  const auto path = headers.Path()->value().getStringView();\n  const auto params = Http::Utility::parseQueryString(path);\n  const auto param = params.find(\"token\");\n  if (param != params.end()) {\n    return param->second;\n  }\n\n  return EMPTY_STRING;\n}\n\n/**\n * primary cases:\n * 1) user is signing out\n * 2) /_oauth redirect\n * 3) user is authorized\n * 4) user is unauthorized\n */\nHttp::FilterHeadersStatus OAuth2Filter::decodeHeaders(Http::RequestHeaderMap& headers, bool) {\n\n  // The following 2 headers are guaranteed for regular requests. The asserts are helpful when\n  // writing test code to not forget these important variables in mock requests\n  const Http::HeaderEntry* host_header = headers.Host();\n  ASSERT(host_header != nullptr);\n  host_ = host_header->value().getStringView();\n\n  const Http::HeaderEntry* path_header = headers.Path();\n  ASSERT(path_header != nullptr);\n  const absl::string_view path_str = path_header->value().getStringView();\n\n  // We should check if this is a sign out request.\n  if (config_->signoutPath().match(path_header->value().getStringView())) {\n    return signOutUser(headers);\n  }\n\n  if (canSkipOAuth(headers)) {\n    // Update the path header with the query string parameters after a successful OAuth login.\n    // This is necessary if a website requests multiple resources which get redirected to the\n    // auth server. A cached login on the authorization server side will set cookies\n    // correctly but cause a race condition on future requests that have their location set\n    // to the callback path.\n\n    if (config_->redirectPathMatcher().match(path_str)) {\n      Http::Utility::QueryParams query_parameters = Http::Utility::parseQueryString(path_str);\n\n      const auto state =\n          Http::Utility::PercentEncoding::decode(query_parameters.at(queryParamsState()));\n      Http::Utility::Url state_url;\n      if (!state_url.initialize(state, false)) {\n        sendUnauthorizedResponse();\n        return Http::FilterHeadersStatus::StopIteration;\n      }\n      // Avoid infinite redirect storm\n      if (config_->redirectPathMatcher().match(state_url.pathAndQueryParams())) {\n        sendUnauthorizedResponse();\n        return Http::FilterHeadersStatus::StopIteration;\n      }\n      Http::ResponseHeaderMapPtr response_headers{\n          Http::createHeaderMap<Http::ResponseHeaderMapImpl>(\n              {{Http::Headers::get().Status, std::to_string(enumToInt(Http::Code::Found))},\n               {Http::Headers::get().Location, state}})};\n      decoder_callbacks_->encodeHeaders(std::move(response_headers), true, REDIRECT_RACE);\n    }\n\n    // Continue on with the filter stack.\n    return Http::FilterHeadersStatus::Continue;\n  }\n\n  // Save the request headers for later modification if needed.\n  if (config_->forwardBearerToken()) {\n    request_headers_ = &headers;\n  }\n\n  // If a bearer token is supplied as a header or param, we ingest it here and kick off the\n  // user resolution immediately. Note this comes after HMAC validation, so technically this\n  // header is sanitized in a way, as the validation check forces the correct Bearer Cookie value.\n  access_token_ = extractAccessToken(headers);\n  if (!access_token_.empty()) {\n    found_bearer_token_ = true;\n    finishFlow();\n    return Http::FilterHeadersStatus::Continue;\n  }\n\n  // If no access token and this isn't the callback URI, redirect to acquire credentials.\n  //\n  // The following conditional could be replaced with a regex pattern-match,\n  // if we're concerned about strict matching against the callback path.\n  if (!config_->redirectPathMatcher().match(path_str)) {\n    Http::ResponseHeaderMapPtr response_headers{Http::createHeaderMap<Http::ResponseHeaderMapImpl>(\n        {{Http::Headers::get().Status, std::to_string(enumToInt(Http::Code::Found))}})};\n\n    // Construct the correct scheme. We default to https since this is a requirement for OAuth to\n    // succeed. However, if a downstream client explicitly declares the \"http\" scheme for whatever\n    // reason, we also use \"http\" when constructing our redirect uri to the authorization server.\n    auto scheme = Http::Headers::get().SchemeValues.Https;\n\n    const auto* scheme_header = headers.Scheme();\n    if ((scheme_header != nullptr &&\n         scheme_header->value().getStringView() == Http::Headers::get().SchemeValues.Http)) {\n      scheme = Http::Headers::get().SchemeValues.Http;\n    }\n\n    const std::string base_path = absl::StrCat(scheme, \"://\", host_);\n    const std::string state_path = absl::StrCat(base_path, headers.Path()->value().getStringView());\n    const std::string escaped_state = Http::Utility::PercentEncoding::encode(state_path, \":/=&?\");\n\n    Formatter::FormatterImpl formatter(config_->redirectUri());\n    const auto redirect_uri = formatter.format(headers, *Http::ResponseHeaderMapImpl::create(),\n                                               *Http::ResponseTrailerMapImpl::create(),\n                                               decoder_callbacks_->streamInfo(), \"\");\n    const std::string escaped_redirect_uri =\n        Http::Utility::PercentEncoding::encode(redirect_uri, \":/=&?\");\n\n    const std::string new_url = fmt::format(\n        AuthorizationEndpointFormat, config_->authorizationEndpoint(), config_->clientId(),\n        config_->encodedAuthScopes(), escaped_redirect_uri, escaped_state);\n\n    response_headers->setLocation(new_url + config_->encodedResourceQueryParams());\n    decoder_callbacks_->encodeHeaders(std::move(response_headers), true, REDIRECT_FOR_CREDENTIALS);\n\n    config_->stats().oauth_unauthorized_rq_.inc();\n\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n\n  // At this point, we *are* on /_oauth. We believe this request comes from the authorization\n  // server and we expect the query strings to contain the information required to get the access\n  // token\n  const auto query_parameters = Http::Utility::parseQueryString(path_str);\n  if (query_parameters.find(queryParamsError()) != query_parameters.end()) {\n    sendUnauthorizedResponse();\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n\n  // if the data we need is not present on the URL, stop execution\n  if (query_parameters.find(queryParamsCode()) == query_parameters.end() ||\n      query_parameters.find(queryParamsState()) == query_parameters.end()) {\n    sendUnauthorizedResponse();\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n\n  auth_code_ = query_parameters.at(queryParamsCode());\n  state_ = Http::Utility::PercentEncoding::decode(query_parameters.at(queryParamsState()));\n\n  Http::Utility::Url state_url;\n  if (!state_url.initialize(state_, false)) {\n    sendUnauthorizedResponse();\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n\n  Formatter::FormatterImpl formatter(config_->redirectUri());\n  const auto redirect_uri = formatter.format(headers, *Http::ResponseHeaderMapImpl::create(),\n                                             *Http::ResponseTrailerMapImpl::create(),\n                                             decoder_callbacks_->streamInfo(), \"\");\n  oauth_client_->asyncGetAccessToken(auth_code_, config_->clientId(), config_->clientSecret(),\n                                     redirect_uri);\n\n  // pause while we await the next step from the OAuth server\n  return Http::FilterHeadersStatus::StopAllIterationAndBuffer;\n}\n\n// Defines a sequence of checks determining whether we should initiate a new OAuth flow or skip to\n// the next filter in the chain.\nbool OAuth2Filter::canSkipOAuth(Http::RequestHeaderMap& headers) const {\n  // We can skip OAuth if the supplied HMAC cookie is valid. Apply the OAuth details as headers\n  // if we successfully validate the cookie.\n  validator_->setParams(headers, config_->tokenSecret());\n  if (validator_->isValid()) {\n    config_->stats().oauth_success_.inc();\n    if (config_->forwardBearerToken() && !validator_->token().empty()) {\n      setBearerToken(headers, validator_->token());\n    }\n    return true;\n  }\n\n  for (const auto& matcher : config_->passThroughMatchers()) {\n    if (matcher.matchesHeaders(headers)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Modifies the state of the filter by adding response headers to the decoder_callbacks\n */\nHttp::FilterHeadersStatus OAuth2Filter::signOutUser(const Http::RequestHeaderMap& headers) {\n  Http::ResponseHeaderMapPtr response_headers{Http::createHeaderMap<Http::ResponseHeaderMapImpl>(\n      {{Http::Headers::get().Status, std::to_string(enumToInt(Http::Code::Found))}})};\n\n  const std::string new_path = absl::StrCat(Http::Utility::getScheme(headers), \"://\", host_, \"/\");\n  response_headers->addReferenceKey(\n      Http::Headers::get().SetCookie,\n      fmt::format(SignoutCookieValue, config_->cookieNames().oauth_hmac_));\n  response_headers->addReferenceKey(\n      Http::Headers::get().SetCookie,\n      fmt::format(SignoutBearerTokenValue, config_->cookieNames().bearer_token_));\n  response_headers->addReferenceKey(Http::Headers::get().SetCookie, SignoutIdTokenValue);\n  response_headers->addReferenceKey(Http::Headers::get().SetCookie, SignoutRefreshTokenValue);\n  response_headers->setLocation(new_path);\n  decoder_callbacks_->encodeHeaders(std::move(response_headers), true, SIGN_OUT);\n\n  return Http::FilterHeadersStatus::StopIteration;\n}\n\nvoid OAuth2Filter::onGetAccessTokenSuccess(const std::string& access_code,\n                                           const std::string& id_token,\n                                           const std::string& refresh_token,\n                                           std::chrono::seconds expires_in) {\n  access_token_ = access_code;\n  id_token_ = id_token;\n  refresh_token_ = refresh_token;\n\n  const auto new_epoch = time_source_.systemTime() + expires_in;\n  new_expires_ = std::to_string(\n      std::chrono::duration_cast<std::chrono::seconds>(new_epoch.time_since_epoch()).count());\n\n  finishFlow();\n}\n\nvoid OAuth2Filter::finishFlow() {\n\n  // We have fully completed the entire OAuth flow, whether through Authorization header or from\n  // user redirection to the auth server.\n  if (found_bearer_token_) {\n    if (config_->forwardBearerToken()) {\n      setBearerToken(*request_headers_, access_token_);\n    }\n    config_->stats().oauth_success_.inc();\n    decoder_callbacks_->continueDecoding();\n    return;\n  }\n\n  std::string token_payload;\n  if (config_->forwardBearerToken()) {\n    token_payload = absl::StrCat(host_, new_expires_, access_token_, id_token_, refresh_token_);\n  } else {\n    token_payload = absl::StrCat(host_, new_expires_);\n  }\n\n  auto& crypto_util = Envoy::Common::Crypto::UtilitySingleton::get();\n\n  auto token_secret = config_->tokenSecret();\n  std::vector<uint8_t> token_secret_vec(token_secret.begin(), token_secret.end());\n  const std::string pre_encoded_token =\n      Hex::encode(crypto_util.getSha256Hmac(token_secret_vec, token_payload));\n  std::string encoded_token;\n  absl::Base64Escape(pre_encoded_token, &encoded_token);\n\n  // We use HTTP Only cookies for the HMAC and Expiry.\n  const std::string cookie_tail = fmt::format(CookieTailFormatString, new_expires_);\n  const std::string cookie_tail_http_only =\n      fmt::format(CookieTailHttpOnlyFormatString, new_expires_);\n\n  // At this point we have all of the pieces needed to authorize a user that did not originally\n  // have a bearer access token. Now, we construct a redirect request to return the user to their\n  // previous state and additionally set the OAuth cookies in browser.\n  // The redirection should result in successfully passing this filter.\n  Http::ResponseHeaderMapPtr response_headers{Http::createHeaderMap<Http::ResponseHeaderMapImpl>(\n      {{Http::Headers::get().Status, std::to_string(enumToInt(Http::Code::Found))}})};\n\n  const CookieNames& cookie_names = config_->cookieNames();\n\n  response_headers->addReferenceKey(\n      Http::Headers::get().SetCookie,\n      absl::StrCat(cookie_names.oauth_hmac_, \"=\", encoded_token, cookie_tail_http_only));\n  response_headers->addReferenceKey(\n      Http::Headers::get().SetCookie,\n      absl::StrCat(cookie_names.oauth_expires_, \"=\", new_expires_, cookie_tail_http_only));\n\n  // If opted-in, we also create a new Bearer cookie for the authorization token provided by the\n  // auth server.\n  if (config_->forwardBearerToken()) {\n    response_headers->addReferenceKey(\n        Http::Headers::get().SetCookie,\n        absl::StrCat(cookie_names.bearer_token_, \"=\", access_token_, cookie_tail));\n    if (id_token_ != EMPTY_STRING) {\n      response_headers->addReferenceKey(Http::Headers::get().SetCookie,\n                                        absl::StrCat(\"IdToken=\", id_token_, cookie_tail));\n    }\n\n    if (refresh_token_ != EMPTY_STRING) {\n      response_headers->addReferenceKey(Http::Headers::get().SetCookie,\n                                        absl::StrCat(\"RefreshToken=\", refresh_token_, cookie_tail));\n    }\n  }\n\n  response_headers->setLocation(state_);\n\n  decoder_callbacks_->encodeHeaders(std::move(response_headers), true, REDIRECT_LOGGED_IN);\n  config_->stats().oauth_success_.inc();\n  decoder_callbacks_->continueDecoding();\n}\n\nvoid OAuth2Filter::sendUnauthorizedResponse() {\n  config_->stats().oauth_failure_.inc();\n  decoder_callbacks_->sendLocalReply(Http::Code::Unauthorized, UnauthorizedBodyMessage, nullptr,\n                                     absl::nullopt, EMPTY_STRING);\n}\n\n} // namespace Oauth2\n} // namespace HttpFilters\n} // namespace Extensions\n} // namespace Envoy\n", "#pragma once\n\n#include <memory>\n#include <string>\n#include <vector>\n\n#include \"envoy/common/callback.h\"\n#include \"envoy/common/matchers.h\"\n#include \"envoy/config/core/v3/http_uri.pb.h\"\n#include \"envoy/extensions/filters/http/oauth2/v3/oauth.pb.h\"\n#include \"envoy/http/header_map.h\"\n#include \"envoy/server/filter_config.h\"\n#include \"envoy/stats/stats_macros.h\"\n#include \"envoy/stream_info/stream_info.h\"\n#include \"envoy/upstream/cluster_manager.h\"\n\n#include \"source/common/common/assert.h\"\n#include \"source/common/common/matchers.h\"\n#include \"source/common/config/datasource.h\"\n#include \"source/common/formatter/substitution_formatter.h\"\n#include \"source/common/http/header_map_impl.h\"\n#include \"source/common/http/header_utility.h\"\n#include \"source/common/http/rest_api_fetcher.h\"\n#include \"source/common/http/utility.h\"\n#include \"source/extensions/filters/http/common/pass_through_filter.h\"\n#include \"source/extensions/filters/http/oauth2/oauth.h\"\n#include \"source/extensions/filters/http/oauth2/oauth_client.h\"\n\n#include \"absl/strings/str_split.h\"\n#include \"absl/strings/string_view.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace HttpFilters {\nnamespace Oauth2 {\n\nclass OAuth2Client;\n\n// Helper class used to fetch secrets (usually from SDS).\nclass SecretReader {\npublic:\n  virtual ~SecretReader() = default;\n  virtual const std::string& clientSecret() const PURE;\n  virtual const std::string& tokenSecret() const PURE;\n};\n\nclass SDSSecretReader : public SecretReader {\npublic:\n  SDSSecretReader(Secret::GenericSecretConfigProviderSharedPtr client_secret_provider,\n                  Secret::GenericSecretConfigProviderSharedPtr token_secret_provider, Api::Api& api)\n      : update_callback_client_(readAndWatchSecret(client_secret_, client_secret_provider, api)),\n        update_callback_token_(readAndWatchSecret(token_secret_, token_secret_provider, api)) {}\n\n  const std::string& clientSecret() const override { return client_secret_; }\n\n  const std::string& tokenSecret() const override { return token_secret_; }\n\nprivate:\n  Envoy::Common::CallbackHandlePtr\n  readAndWatchSecret(std::string& value,\n                     Secret::GenericSecretConfigProviderSharedPtr& secret_provider, Api::Api& api) {\n    const auto* secret = secret_provider->secret();\n    if (secret != nullptr) {\n      value = Config::DataSource::read(secret->secret(), true, api);\n    }\n\n    return secret_provider->addUpdateCallback([secret_provider, &api, &value]() {\n      const auto* secret = secret_provider->secret();\n      if (secret != nullptr) {\n        value = Config::DataSource::read(secret->secret(), true, api);\n      }\n    });\n  }\n\n  std::string client_secret_;\n  std::string token_secret_;\n\n  Envoy::Common::CallbackHandlePtr update_callback_client_;\n  Envoy::Common::CallbackHandlePtr update_callback_token_;\n};\n\n/**\n * All stats for the OAuth filter. @see stats_macros.h\n */\n#define ALL_OAUTH_FILTER_STATS(COUNTER)                                                            \\\n  COUNTER(oauth_unauthorized_rq)                                                                   \\\n  COUNTER(oauth_failure)                                                                           \\\n  COUNTER(oauth_success)\n\n/**\n * Wrapper struct filter stats. @see stats_macros.h\n */\nstruct FilterStats {\n  ALL_OAUTH_FILTER_STATS(GENERATE_COUNTER_STRUCT)\n};\n\n/**\n * Helper structure to hold custom cookie names.\n */\nstruct CookieNames {\n  CookieNames(const envoy::extensions::filters::http::oauth2::v3::OAuth2Credentials::CookieNames&\n                  cookie_names)\n      : CookieNames(cookie_names.bearer_token(), cookie_names.oauth_hmac(),\n                    cookie_names.oauth_expires()) {}\n\n  CookieNames(const std::string& bearer_token, const std::string& oauth_hmac,\n              const std::string& oauth_expires)\n      : bearer_token_(bearer_token.empty() ? \"BearerToken\" : bearer_token),\n        oauth_hmac_(oauth_hmac.empty() ? \"OauthHMAC\" : oauth_hmac),\n        oauth_expires_(oauth_expires.empty() ? \"OauthExpires\" : oauth_expires) {}\n\n  const std::string bearer_token_;\n  const std::string oauth_hmac_;\n  const std::string oauth_expires_;\n};\n\n/**\n * This class encapsulates all data needed for the filter to operate so that we don't pass around\n * raw protobufs and other arbitrary data.\n */\nclass FilterConfig {\npublic:\n  FilterConfig(const envoy::extensions::filters::http::oauth2::v3::OAuth2Config& proto_config,\n               Upstream::ClusterManager& cluster_manager,\n               std::shared_ptr<SecretReader> secret_reader, Stats::Scope& scope,\n               const std::string& stats_prefix);\n  const std::string& clusterName() const { return oauth_token_endpoint_.cluster(); }\n  const std::string& clientId() const { return client_id_; }\n  bool forwardBearerToken() const { return forward_bearer_token_; }\n  const std::vector<Http::HeaderUtility::HeaderData>& passThroughMatchers() const {\n    return pass_through_header_matchers_;\n  }\n\n  const envoy::config::core::v3::HttpUri& oauthTokenEndpoint() const {\n    return oauth_token_endpoint_;\n  }\n  const std::string& authorizationEndpoint() const { return authorization_endpoint_; }\n  const std::string& redirectUri() const { return redirect_uri_; }\n  const Matchers::PathMatcher& redirectPathMatcher() const { return redirect_matcher_; }\n  const Matchers::PathMatcher& signoutPath() const { return signout_path_; }\n  std::string clientSecret() const { return secret_reader_->clientSecret(); }\n  std::string tokenSecret() const { return secret_reader_->tokenSecret(); }\n  FilterStats& stats() { return stats_; }\n  const std::string& encodedAuthScopes() const { return encoded_auth_scopes_; }\n  const std::string& encodedResourceQueryParams() const { return encoded_resource_query_params_; }\n  const CookieNames& cookieNames() const { return cookie_names_; }\n\nprivate:\n  static FilterStats generateStats(const std::string& prefix, Stats::Scope& scope);\n\n  const envoy::config::core::v3::HttpUri oauth_token_endpoint_;\n  const std::string authorization_endpoint_;\n  const std::string client_id_;\n  const std::string redirect_uri_;\n  const Matchers::PathMatcher redirect_matcher_;\n  const Matchers::PathMatcher signout_path_;\n  std::shared_ptr<SecretReader> secret_reader_;\n  FilterStats stats_;\n  const std::string encoded_auth_scopes_;\n  const std::string encoded_resource_query_params_;\n  const bool forward_bearer_token_ : 1;\n  const std::vector<Http::HeaderUtility::HeaderData> pass_through_header_matchers_;\n  const CookieNames cookie_names_;\n};\n\nusing FilterConfigSharedPtr = std::shared_ptr<FilterConfig>;\n\n/**\n * An OAuth cookie validator:\n * 1. extracts cookies from a request\n * 2. HMAC/encodes the values\n * 3. Compares the result to the cookie HMAC\n * 4. Checks that the `expires` value is valid relative to current time\n *\n * Required components:\n * - header map\n * - secret\n */\nclass CookieValidator {\npublic:\n  virtual ~CookieValidator() = default;\n  virtual const std::string& token() const PURE;\n  virtual void setParams(const Http::RequestHeaderMap& headers, const std::string& secret) PURE;\n  virtual bool isValid() const PURE;\n};\n\nclass OAuth2CookieValidator : public CookieValidator {\npublic:\n  explicit OAuth2CookieValidator(TimeSource& time_source, const CookieNames& cookie_names)\n      : time_source_(time_source), cookie_names_(cookie_names) {}\n\n  const std::string& token() const override { return token_; }\n  void setParams(const Http::RequestHeaderMap& headers, const std::string& secret) override;\n  bool isValid() const override;\n  bool hmacIsValid() const;\n  bool timestampIsValid() const;\n\nprivate:\n  std::string token_;\n  std::string id_token_;\n  std::string refresh_token_;\n  std::string expires_;\n  std::string hmac_;\n  std::vector<uint8_t> secret_;\n  absl::string_view host_;\n  TimeSource& time_source_;\n  const CookieNames cookie_names_;\n};\n\n/**\n * The filter is the primary entry point for the OAuth workflow. Its responsibilities are to\n * receive incoming requests and decide at what state of the OAuth workflow they are in. Logic\n * beyond that is broken into component classes.\n */\nclass OAuth2Filter : public Http::PassThroughDecoderFilter, public FilterCallbacks {\npublic:\n  OAuth2Filter(FilterConfigSharedPtr config, std::unique_ptr<OAuth2Client>&& oauth_client,\n               TimeSource& time_source);\n\n  // Http::PassThroughDecoderFilter\n  Http::FilterHeadersStatus decodeHeaders(Http::RequestHeaderMap& headers, bool) override;\n\n  // FilterCallbacks\n  void onGetAccessTokenSuccess(const std::string& access_code, const std::string& id_token,\n                               const std::string& refresh_token,\n                               std::chrono::seconds expires_in) override;\n  // a catch-all function used for request failures. we don't retry, as a user can simply refresh\n  // the page in the case of a network blip.\n  void sendUnauthorizedResponse() override;\n\n  void finishFlow();\n\nprivate:\n  friend class OAuth2Test;\n\n  std::shared_ptr<CookieValidator> validator_;\n\n  // wrap up some of these in a UserData struct or something...\n  std::string auth_code_;\n  std::string access_token_; // TODO - see if we can avoid this being a member variable\n  std::string id_token_;\n  std::string refresh_token_;\n  std::string new_expires_;\n  absl::string_view host_;\n  std::string state_;\n  bool found_bearer_token_{false};\n  Http::RequestHeaderMap* request_headers_{nullptr};\n\n  std::unique_ptr<OAuth2Client> oauth_client_;\n  FilterConfigSharedPtr config_;\n  TimeSource& time_source_;\n\n  // Determines whether or not the current request can skip the entire OAuth flow (HMAC is valid,\n  // connection is mTLS, etc.)\n  bool canSkipOAuth(Http::RequestHeaderMap& headers) const;\n\n  Http::FilterHeadersStatus signOutUser(const Http::RequestHeaderMap& headers);\n\n  const std::string& bearerPrefix() const;\n  std::string extractAccessToken(const Http::RequestHeaderMap& headers) const;\n};\n\n} // namespace Oauth2\n} // namespace HttpFilters\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"source/extensions/filters/http/oauth2/oauth_client.h\"\n\n#include <chrono>\n\n#include \"envoy/http/async_client.h\"\n#include \"envoy/http/message.h\"\n#include \"envoy/upstream/cluster_manager.h\"\n\n#include \"source/common/common/empty_string.h\"\n#include \"source/common/common/fmt.h\"\n#include \"source/common/common/logger.h\"\n#include \"source/common/http/message_impl.h\"\n#include \"source/common/http/utility.h\"\n#include \"source/common/protobuf/message_validator_impl.h\"\n#include \"source/common/protobuf/utility.h\"\n#include \"source/extensions/filters/http/oauth2/oauth_response.pb.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace HttpFilters {\nnamespace Oauth2 {\n\nnamespace {\nHttp::RegisterCustomInlineHeader<Http::CustomInlineHeaderRegistry::Type::RequestHeaders>\n    authorization_handle(Http::CustomHeaders::get().Authorization);\n\nconstexpr const char* GetAccessTokenBodyFormatString =\n    \"grant_type=authorization_code&code={0}&client_id={1}&client_secret={2}&redirect_uri={3}\";\n\n} // namespace\n\nvoid OAuth2ClientImpl::asyncGetAccessToken(const std::string& auth_code,\n                                           const std::string& client_id, const std::string& secret,\n                                           const std::string& cb_url) {\n  const auto encoded_client_id = Http::Utility::PercentEncoding::encode(client_id, \":/=&?\");\n  const auto encoded_secret = Http::Utility::PercentEncoding::encode(secret, \":/=&?\");\n  const auto encoded_cb_url = Http::Utility::PercentEncoding::encode(cb_url, \":/=&?\");\n\n  Http::RequestMessagePtr request = createPostRequest();\n  const std::string body = fmt::format(GetAccessTokenBodyFormatString, auth_code, encoded_client_id,\n                                       encoded_secret, encoded_cb_url);\n  request->body().add(body);\n  request->headers().setContentLength(body.length());\n  ENVOY_LOG(debug, \"Dispatching OAuth request for access token.\");\n  dispatchRequest(std::move(request));\n\n  ASSERT(state_ == OAuthState::Idle);\n  state_ = OAuthState::PendingAccessToken;\n}\n\nvoid OAuth2ClientImpl::dispatchRequest(Http::RequestMessagePtr&& msg) {\n  const auto thread_local_cluster = cm_.getThreadLocalCluster(uri_.cluster());\n  if (thread_local_cluster != nullptr) {\n    in_flight_request_ = thread_local_cluster->httpAsyncClient().send(\n        std::move(msg), *this,\n        Http::AsyncClient::RequestOptions().setTimeout(\n            std::chrono::milliseconds(PROTOBUF_GET_MS_REQUIRED(uri_, timeout))));\n  } else {\n    parent_->sendUnauthorizedResponse();\n  }\n}\n\nvoid OAuth2ClientImpl::onSuccess(const Http::AsyncClient::Request&,\n                                 Http::ResponseMessagePtr&& message) {\n  in_flight_request_ = nullptr;\n\n  ASSERT(state_ == OAuthState::PendingAccessToken);\n  state_ = OAuthState::Idle;\n\n  // Check that the auth cluster returned a happy response.\n  const auto response_code = message->headers().Status()->value().getStringView();\n  if (response_code != \"200\") {\n    ENVOY_LOG(debug, \"Oauth response code: {}\", response_code);\n    ENVOY_LOG(debug, \"Oauth response body: {}\", message->bodyAsString());\n    parent_->sendUnauthorizedResponse();\n    return;\n  }\n\n  const std::string response_body = message->bodyAsString();\n\n  envoy::extensions::http_filters::oauth2::OAuthResponse response;\n  try {\n    MessageUtil::loadFromJson(response_body, response, ProtobufMessage::getNullValidationVisitor());\n  } catch (EnvoyException& e) {\n    ENVOY_LOG(debug, \"Error parsing response body, received exception: {}\", e.what());\n    ENVOY_LOG(debug, \"Response body: {}\", response_body);\n    parent_->sendUnauthorizedResponse();\n    return;\n  }\n\n  // TODO(snowp): Should this be a pgv validation instead? A more readable log\n  // message might be good enough reason to do this manually?\n  if (!response.has_access_token() || !response.has_expires_in()) {\n    ENVOY_LOG(debug, \"No access token or expiration after asyncGetAccessToken\");\n    parent_->sendUnauthorizedResponse();\n    return;\n  }\n\n  const std::string access_token{PROTOBUF_GET_WRAPPED_REQUIRED(response, access_token)};\n  const std::string id_token{PROTOBUF_GET_WRAPPED_OR_DEFAULT(response, id_token, EMPTY_STRING)};\n  const std::string refresh_token{\n      PROTOBUF_GET_WRAPPED_OR_DEFAULT(response, refresh_token, EMPTY_STRING)};\n  const std::chrono::seconds expires_in{PROTOBUF_GET_WRAPPED_REQUIRED(response, expires_in)};\n\n  parent_->onGetAccessTokenSuccess(access_token, id_token, refresh_token, expires_in);\n}\n\nvoid OAuth2ClientImpl::onFailure(const Http::AsyncClient::Request&,\n                                 Http::AsyncClient::FailureReason) {\n  ENVOY_LOG(debug, \"OAuth request failed.\");\n  in_flight_request_ = nullptr;\n  parent_->sendUnauthorizedResponse();\n}\n\n} // namespace Oauth2\n} // namespace HttpFilters\n} // namespace Extensions\n} // namespace Envoy\n", "#include <memory>\n#include <string>\n\n#include \"envoy/extensions/filters/http/oauth2/v3/oauth.pb.h\"\n#include \"envoy/extensions/filters/http/oauth2/v3/oauth.pb.validate.h\"\n#include \"envoy/http/async_client.h\"\n#include \"envoy/http/message.h\"\n\n#include \"source/common/common/macros.h\"\n#include \"source/common/http/message_impl.h\"\n#include \"source/common/protobuf/message_validator_impl.h\"\n#include \"source/common/protobuf/utility.h\"\n#include \"source/common/secret/secret_manager_impl.h\"\n#include \"source/extensions/filters/http/oauth2/filter.h\"\n\n#include \"test/mocks/http/mocks.h\"\n#include \"test/mocks/server/mocks.h\"\n#include \"test/mocks/upstream/mocks.h\"\n#include \"test/test_common/utility.h\"\n\n#include \"gmock/gmock.h\"\n#include \"gtest/gtest.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace HttpFilters {\nnamespace Oauth2 {\n\nusing testing::_;\nusing testing::NiceMock;\nusing testing::Return;\nusing testing::ReturnRef;\n\nstatic const std::string TEST_CALLBACK = \"/_oauth\";\nstatic const std::string TEST_CLIENT_ID = \"1\";\nstatic const std::string TEST_CLIENT_SECRET_ID = \"MyClientSecretKnoxID\";\nstatic const std::string TEST_TOKEN_SECRET_ID = \"MyTokenSecretKnoxID\";\nstatic const std::string TEST_DEFAULT_SCOPE = \"user\";\nstatic const std::string TEST_ENCODED_AUTH_SCOPES = \"user%20openid%20email\";\n\nnamespace {\nHttp::RegisterCustomInlineHeader<Http::CustomInlineHeaderRegistry::Type::RequestHeaders>\n    authorization_handle(Http::CustomHeaders::get().Authorization);\n}\n\nclass MockSecretReader : public SecretReader {\npublic:\n  const std::string& clientSecret() const override {\n    CONSTRUCT_ON_FIRST_USE(std::string, \"asdf_client_secret_fdsa\");\n  }\n  const std::string& tokenSecret() const override {\n    CONSTRUCT_ON_FIRST_USE(std::string, \"asdf_token_secret_fdsa\");\n  }\n};\n\nclass MockOAuth2CookieValidator : public CookieValidator {\npublic:\n  MOCK_METHOD(std::string&, username, (), (const));\n  MOCK_METHOD(std::string&, token, (), (const));\n  MOCK_METHOD(bool, isValid, (), (const));\n  MOCK_METHOD(void, setParams, (const Http::RequestHeaderMap& headers, const std::string& secret));\n};\n\nclass MockOAuth2Client : public OAuth2Client {\npublic:\n  void onSuccess(const Http::AsyncClient::Request&, Http::ResponseMessagePtr&&) override {}\n  void onFailure(const Http::AsyncClient::Request&, Http::AsyncClient::FailureReason) override {}\n  void setCallbacks(FilterCallbacks&) override {}\n  void onBeforeFinalizeUpstreamSpan(Envoy::Tracing::Span&,\n                                    const Http::ResponseHeaderMap*) override {}\n\n  MOCK_METHOD(void, asyncGetAccessToken,\n              (const std::string&, const std::string&, const std::string&, const std::string&));\n};\n\nclass OAuth2Test : public testing::Test {\npublic:\n  OAuth2Test() : request_(&cm_.thread_local_cluster_.async_client_) {\n    factory_context_.cluster_manager_.initializeClusters({\"auth.example.com\"}, {});\n    init();\n  }\n\n  void init() { init(getConfig()); }\n\n  void init(FilterConfigSharedPtr config) {\n    // Set up the OAuth client.\n    oauth_client_ = new MockOAuth2Client();\n    std::unique_ptr<OAuth2Client> oauth_client_ptr{oauth_client_};\n\n    config_ = config;\n    filter_ = std::make_shared<OAuth2Filter>(config_, std::move(oauth_client_ptr), test_time_);\n    filter_->setDecoderFilterCallbacks(decoder_callbacks_);\n    validator_ = std::make_shared<MockOAuth2CookieValidator>();\n    filter_->validator_ = validator_;\n  }\n\n  // Set up proto fields with standard config.\n  FilterConfigSharedPtr getConfig() {\n    envoy::extensions::filters::http::oauth2::v3::OAuth2Config p;\n    auto* endpoint = p.mutable_token_endpoint();\n    endpoint->set_cluster(\"auth.example.com\");\n    endpoint->set_uri(\"auth.example.com/_oauth\");\n    endpoint->mutable_timeout()->set_seconds(1);\n    p.set_redirect_uri(\"%REQ(:scheme)%://%REQ(:authority)%\" + TEST_CALLBACK);\n    p.mutable_redirect_path_matcher()->mutable_path()->set_exact(TEST_CALLBACK);\n    p.set_authorization_endpoint(\"https://auth.example.com/oauth/authorize/\");\n    p.mutable_signout_path()->mutable_path()->set_exact(\"/_signout\");\n    p.set_forward_bearer_token(true);\n    p.add_auth_scopes(\"user\");\n    p.add_auth_scopes(\"openid\");\n    p.add_auth_scopes(\"email\");\n    p.add_resources(\"oauth2-resource\");\n    p.add_resources(\"http://example.com\");\n    p.add_resources(\"https://example.com\");\n    auto* matcher = p.add_pass_through_matcher();\n    matcher->set_name(\":method\");\n    matcher->mutable_string_match()->set_exact(\"OPTIONS\");\n    auto credentials = p.mutable_credentials();\n    credentials->set_client_id(TEST_CLIENT_ID);\n    credentials->mutable_token_secret()->set_name(\"secret\");\n    credentials->mutable_hmac_secret()->set_name(\"hmac\");\n    // Skipping setting credentials.cookie_names field should give default cookie names:\n    // BearerToken, OauthHMAC, and OauthExpires.\n\n    MessageUtil::validate(p, ProtobufMessage::getStrictValidationVisitor());\n\n    // Create filter config.\n    auto secret_reader = std::make_shared<MockSecretReader>();\n    FilterConfigSharedPtr c = std::make_shared<FilterConfig>(p, factory_context_.cluster_manager_,\n                                                             secret_reader, scope_, \"test.\");\n\n    return c;\n  }\n\n  Http::AsyncClient::Callbacks* popPendingCallback() {\n    if (callbacks_.empty()) {\n      // Can't use ASSERT_* as this is not a test function\n      throw std::underflow_error(\"empty deque\");\n    }\n\n    auto callbacks = callbacks_.front();\n    callbacks_.pop_front();\n    return callbacks;\n  }\n\n  // Validates the behavior of the cookie validator.\n  void expectValidCookies(const CookieNames& cookie_names) {\n    // Set SystemTime to a fixed point so we get consistent HMAC encodings between test runs.\n    test_time_.setSystemTime(SystemTime(std::chrono::seconds(0)));\n\n    const auto expires_at_s = DateUtil::nowToSeconds(test_time_.timeSystem()) + 10;\n\n    Http::TestRequestHeaderMapImpl request_headers{\n        {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n        {Http::Headers::get().Path.get(), \"/anypath\"},\n        {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n        {Http::Headers::get().Cookie.get(),\n         fmt::format(\"{}={};version=test\", cookie_names.oauth_expires_, expires_at_s)},\n        {Http::Headers::get().Cookie.get(),\n         absl::StrCat(cookie_names.bearer_token_, \"=xyztoken;version=test\")},\n        {Http::Headers::get().Cookie.get(),\n         absl::StrCat(cookie_names.oauth_hmac_, \"=\"\n                                                \"NGQ3MzVjZGExNGM5NTFiZGJjODBkMjBmYjAyYjNiOTFjMmNjYj\"\n                                                \"IxMTUzNmNiNWU0NjQzMmMxMWUzZmE2ZWJjYg==\"\n                                                \";version=test\")},\n    };\n\n    auto cookie_validator = std::make_shared<OAuth2CookieValidator>(test_time_, cookie_names);\n    EXPECT_EQ(cookie_validator->token(), \"\");\n    cookie_validator->setParams(request_headers, \"mock-secret\");\n\n    EXPECT_TRUE(cookie_validator->hmacIsValid());\n    EXPECT_TRUE(cookie_validator->timestampIsValid());\n    EXPECT_TRUE(cookie_validator->isValid());\n\n    // If we advance time beyond 10s the timestamp should no longer be valid.\n    test_time_.advanceTimeWait(std::chrono::seconds(11));\n\n    EXPECT_FALSE(cookie_validator->timestampIsValid());\n    EXPECT_FALSE(cookie_validator->isValid());\n  }\n\n  NiceMock<Event::MockTimer>* attachmentTimeout_timer_{};\n  NiceMock<Server::Configuration::MockFactoryContext> factory_context_;\n  NiceMock<Http::MockStreamDecoderFilterCallbacks> decoder_callbacks_;\n  NiceMock<Upstream::MockClusterManager> cm_;\n  std::shared_ptr<MockOAuth2CookieValidator> validator_;\n  std::shared_ptr<OAuth2Filter> filter_;\n  MockOAuth2Client* oauth_client_;\n  FilterConfigSharedPtr config_;\n  Http::MockAsyncClientRequest request_;\n  std::deque<Http::AsyncClient::Callbacks*> callbacks_;\n  Stats::IsolatedStoreImpl scope_;\n  Event::SimulatedTimeSystem test_time_;\n};\n\n// Verifies that the OAuth SDSSecretReader correctly updates dynamic generic secret.\nTEST_F(OAuth2Test, SdsDynamicGenericSecret) {\n  NiceMock<Server::MockConfigTracker> config_tracker;\n  Secret::SecretManagerImpl secret_manager{config_tracker};\n  envoy::config::core::v3::ConfigSource config_source;\n\n  NiceMock<Server::Configuration::MockTransportSocketFactoryContext> secret_context;\n  NiceMock<LocalInfo::MockLocalInfo> local_info;\n  Api::ApiPtr api = Api::createApiForTest();\n  Stats::IsolatedStoreImpl stats;\n  NiceMock<Init::MockManager> init_manager;\n  Init::TargetHandlePtr init_handle;\n  NiceMock<Event::MockDispatcher> dispatcher;\n  EXPECT_CALL(secret_context, localInfo()).WillRepeatedly(ReturnRef(local_info));\n  EXPECT_CALL(secret_context, api()).WillRepeatedly(ReturnRef(*api));\n  EXPECT_CALL(secret_context, mainThreadDispatcher()).WillRepeatedly(ReturnRef(dispatcher));\n  EXPECT_CALL(secret_context, stats()).WillRepeatedly(ReturnRef(stats));\n  EXPECT_CALL(secret_context, initManager()).WillRepeatedly(ReturnRef(init_manager));\n  EXPECT_CALL(init_manager, add(_))\n      .WillRepeatedly(Invoke([&init_handle](const Init::Target& target) {\n        init_handle = target.createHandle(\"test\");\n      }));\n\n  auto client_secret_provider =\n      secret_manager.findOrCreateGenericSecretProvider(config_source, \"client\", secret_context);\n  auto client_callback = secret_context.cluster_manager_.subscription_factory_.callbacks_;\n  auto token_secret_provider =\n      secret_manager.findOrCreateGenericSecretProvider(config_source, \"token\", secret_context);\n  auto token_callback = secret_context.cluster_manager_.subscription_factory_.callbacks_;\n\n  SDSSecretReader secret_reader(client_secret_provider, token_secret_provider, *api);\n  EXPECT_TRUE(secret_reader.clientSecret().empty());\n  EXPECT_TRUE(secret_reader.tokenSecret().empty());\n\n  const std::string yaml_client = R\"EOF(\nname: client\ngeneric_secret:\n  secret:\n    inline_string: \"client_test\"\n)EOF\";\n\n  envoy::extensions::transport_sockets::tls::v3::Secret typed_secret;\n  TestUtility::loadFromYaml(yaml_client, typed_secret);\n  const auto decoded_resources_client = TestUtility::decodeResources({typed_secret});\n\n  client_callback->onConfigUpdate(decoded_resources_client.refvec_, \"\");\n  EXPECT_EQ(secret_reader.clientSecret(), \"client_test\");\n  EXPECT_EQ(secret_reader.tokenSecret(), \"\");\n\n  const std::string yaml_token = R\"EOF(\nname: token\ngeneric_secret:\n  secret:\n    inline_string: \"token_test\"\n)EOF\";\n  TestUtility::loadFromYaml(yaml_token, typed_secret);\n  const auto decoded_resources_token = TestUtility::decodeResources({typed_secret});\n\n  token_callback->onConfigUpdate(decoded_resources_token.refvec_, \"\");\n  EXPECT_EQ(secret_reader.clientSecret(), \"client_test\");\n  EXPECT_EQ(secret_reader.tokenSecret(), \"token_test\");\n\n  const std::string yaml_client_recheck = R\"EOF(\nname: client\ngeneric_secret:\n  secret:\n    inline_string: \"client_test_recheck\"\n)EOF\";\n  TestUtility::loadFromYaml(yaml_client_recheck, typed_secret);\n  const auto decoded_resources_client_recheck = TestUtility::decodeResources({typed_secret});\n\n  client_callback->onConfigUpdate(decoded_resources_client_recheck.refvec_, \"\");\n  EXPECT_EQ(secret_reader.clientSecret(), \"client_test_recheck\");\n  EXPECT_EQ(secret_reader.tokenSecret(), \"token_test\");\n}\n// Verifies that we fail constructing the filter if the configured cluster doesn't exist.\nTEST_F(OAuth2Test, InvalidCluster) {\n  ON_CALL(factory_context_.cluster_manager_, clusters())\n      .WillByDefault(Return(Upstream::ClusterManager::ClusterInfoMaps()));\n\n  EXPECT_THROW_WITH_MESSAGE(init(), EnvoyException,\n                            \"OAuth2 filter: unknown cluster 'auth.example.com' in config. Please \"\n                            \"specify which cluster to direct OAuth requests to.\");\n}\n\n// Verifies that the OAuth config is created with a default value for auth_scopes field when it is\n// not set in proto/yaml.\nTEST_F(OAuth2Test, DefaultAuthScope) {\n\n  // Set up proto fields with no auth scope set.\n  envoy::extensions::filters::http::oauth2::v3::OAuth2Config p;\n  auto* endpoint = p.mutable_token_endpoint();\n  endpoint->set_cluster(\"auth.example.com\");\n  endpoint->set_uri(\"auth.example.com/_oauth\");\n  endpoint->mutable_timeout()->set_seconds(1);\n  p.set_redirect_uri(\"%REQ(:scheme)%://%REQ(:authority)%\" + TEST_CALLBACK);\n  p.mutable_redirect_path_matcher()->mutable_path()->set_exact(TEST_CALLBACK);\n  p.set_authorization_endpoint(\"https://auth.example.com/oauth/authorize/\");\n  p.mutable_signout_path()->mutable_path()->set_exact(\"/_signout\");\n  p.set_forward_bearer_token(true);\n  auto* matcher = p.add_pass_through_matcher();\n  matcher->set_name(\":method\");\n  matcher->mutable_string_match()->set_exact(\"OPTIONS\");\n\n  auto credentials = p.mutable_credentials();\n  credentials->set_client_id(TEST_CLIENT_ID);\n  credentials->mutable_token_secret()->set_name(\"secret\");\n  credentials->mutable_hmac_secret()->set_name(\"hmac\");\n\n  MessageUtil::validate(p, ProtobufMessage::getStrictValidationVisitor());\n\n  // Create the OAuth config.\n  auto secret_reader = std::make_shared<MockSecretReader>();\n  FilterConfigSharedPtr test_config_;\n  test_config_ = std::make_shared<FilterConfig>(p, factory_context_.cluster_manager_, secret_reader,\n                                                scope_, \"test.\");\n\n  // Auth_scopes was not set, should return default value.\n  EXPECT_EQ(test_config_->encodedAuthScopes(), TEST_DEFAULT_SCOPE);\n\n  // resource is optional\n  EXPECT_EQ(test_config_->encodedResourceQueryParams(), \"\");\n\n  // Recreate the filter with current config and test if the scope was added\n  // as a query parameter in response headers.\n  init(test_config_);\n  Http::TestRequestHeaderMapImpl request_headers{\n      {Http::Headers::get().Path.get(), \"/not/_oauth\"},\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n      {Http::Headers::get().Scheme.get(), \"http\"},\n  };\n\n  Http::TestResponseHeaderMapImpl response_headers{\n      {Http::Headers::get().Status.get(), \"302\"},\n      {Http::Headers::get().Location.get(),\n       \"https://auth.example.com/oauth/\"\n       \"authorize/?client_id=\" +\n           TEST_CLIENT_ID + \"&scope=\" + TEST_DEFAULT_SCOPE +\n           \"&response_type=code&\"\n           \"redirect_uri=http%3A%2F%2Ftraffic.example.com%2F\"\n           \"_oauth&state=http%3A%2F%2Ftraffic.example.com%2Fnot%2F_oauth\"},\n  };\n\n  // explicitly tell the validator to fail the validation.\n  EXPECT_CALL(*validator_, setParams(_, _));\n  EXPECT_CALL(*validator_, isValid()).WillOnce(Return(false));\n\n  EXPECT_CALL(decoder_callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), true));\n\n  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,\n            filter_->decodeHeaders(request_headers, false));\n}\n\n/**\n * Scenario: The OAuth filter receives a sign out request.\n *\n * Expected behavior: the filter should redirect to the server name with cleared OAuth cookies.\n */\nTEST_F(OAuth2Test, RequestSignout) {\n  Http::TestRequestHeaderMapImpl request_headers{\n      {Http::Headers::get().Path.get(), \"/_signout\"},\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n      {Http::Headers::get().Scheme.get(), \"https\"},\n  };\n\n  Http::TestResponseHeaderMapImpl response_headers{\n      {Http::Headers::get().Status.get(), \"302\"},\n      {Http::Headers::get().SetCookie.get(),\n       \"OauthHMAC=deleted; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT\"},\n      {Http::Headers::get().SetCookie.get(),\n       \"BearerToken=deleted; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT\"},\n      {Http::Headers::get().SetCookie.get(),\n       \"IdToken=deleted; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT\"},\n      {Http::Headers::get().SetCookie.get(),\n       \"RefreshToken=deleted; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT\"},\n      {Http::Headers::get().Location.get(), \"https://traffic.example.com/\"},\n  };\n  EXPECT_CALL(decoder_callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), true));\n\n  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,\n            filter_->decodeHeaders(request_headers, false));\n}\n\n/**\n * Scenario: The OAuth filter receives a request to an arbitrary path with valid OAuth cookies\n * (cookie values and validation are mocked out)\n * In a real flow, the injected OAuth headers should be sanitized and replaced with legitimate\n * values.\n *\n * Expected behavior: the filter should let the request proceed, and sanitize the injected headers.\n */\nTEST_F(OAuth2Test, OAuthOkPass) {\n  Http::TestRequestHeaderMapImpl mock_request_headers{\n      {Http::Headers::get().Path.get(), \"/anypath\"},\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n      {Http::Headers::get().Scheme.get(), \"https\"},\n      {Http::CustomHeaders::get().Authorization.get(), \"Bearer injected_malice!\"},\n  };\n\n  Http::TestRequestHeaderMapImpl expected_headers{\n      {Http::Headers::get().Path.get(), \"/anypath\"},\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n      {Http::Headers::get().Scheme.get(), \"https\"},\n      {Http::CustomHeaders::get().Authorization.get(), \"Bearer legit_token\"},\n  };\n\n  // cookie-validation mocking\n  EXPECT_CALL(*validator_, setParams(_, _));\n  EXPECT_CALL(*validator_, isValid()).WillOnce(Return(true));\n\n  // Sanitized return reference mocking\n  std::string legit_token{\"legit_token\"};\n  EXPECT_CALL(*validator_, token()).WillRepeatedly(ReturnRef(legit_token));\n\n  EXPECT_EQ(Http::FilterHeadersStatus::Continue,\n            filter_->decodeHeaders(mock_request_headers, false));\n\n  // Ensure that existing OAuth forwarded headers got sanitized.\n  EXPECT_EQ(mock_request_headers, expected_headers);\n\n  EXPECT_EQ(scope_.counterFromString(\"test.oauth_failure\").value(), 0);\n  EXPECT_EQ(scope_.counterFromString(\"test.oauth_success\").value(), 1);\n}\n\n/**\n * Scenario: The OAuth filter receives a request without valid OAuth cookies to a non-callback URL\n * (indicating that the user needs to re-validate cookies or get 401'd).\n * This also tests both a forwarded http protocol from upstream and a plaintext connection.\n *\n * Expected behavior: the filter should redirect the user to the OAuth server with the credentials\n * in the query parameters.\n */\nTEST_F(OAuth2Test, OAuthErrorNonOAuthHttpCallback) {\n  Http::TestRequestHeaderMapImpl request_headers{\n      {Http::Headers::get().Path.get(), \"/not/_oauth\"},\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n      {Http::Headers::get().Scheme.get(), \"http\"},\n  };\n\n  Http::TestResponseHeaderMapImpl response_headers{\n      {Http::Headers::get().Status.get(), \"302\"},\n      {Http::Headers::get().Location.get(),\n       \"https://auth.example.com/oauth/\"\n       \"authorize/?client_id=\" +\n           TEST_CLIENT_ID + \"&scope=\" + TEST_ENCODED_AUTH_SCOPES +\n           \"&response_type=code&\"\n           \"redirect_uri=http%3A%2F%2Ftraffic.example.com%2F\"\n           \"_oauth&state=http%3A%2F%2Ftraffic.example.com%2Fnot%2F_oauth\"\n           \"&resource=oauth2-resource&resource=http%3A%2F%2Fexample.com\"\n           \"&resource=https%3A%2F%2Fexample.com\"},\n  };\n\n  // explicitly tell the validator to fail the validation\n  EXPECT_CALL(*validator_, setParams(_, _));\n  EXPECT_CALL(*validator_, isValid()).WillOnce(Return(false));\n\n  EXPECT_CALL(decoder_callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), true));\n\n  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,\n            filter_->decodeHeaders(request_headers, false));\n}\n\n/**\n * Scenario: The OAuth filter receives a callback request with an error code\n */\nTEST_F(OAuth2Test, OAuthErrorQueryString) {\n  Http::TestRequestHeaderMapImpl request_headers{\n      {Http::Headers::get().Path.get(), \"/_oauth?error=someerrorcode\"},\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n  };\n\n  Http::TestResponseHeaderMapImpl response_headers{\n      {Http::Headers::get().Status.get(), \"401\"},\n      {Http::Headers::get().ContentLength.get(), \"18\"}, // unauthorizedBodyMessage()\n      {Http::Headers::get().ContentType.get(), \"text/plain\"},\n  };\n\n  EXPECT_CALL(*validator_, setParams(_, _));\n  EXPECT_CALL(*validator_, isValid()).WillOnce(Return(false));\n\n  EXPECT_CALL(decoder_callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), false));\n  EXPECT_CALL(decoder_callbacks_, encodeData(_, true));\n\n  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,\n            filter_->decodeHeaders(request_headers, false));\n\n  EXPECT_EQ(scope_.counterFromString(\"test.oauth_failure\").value(), 1);\n  EXPECT_EQ(scope_.counterFromString(\"test.oauth_success\").value(), 0);\n}\n\n/**\n * Scenario: The OAuth filter requests credentials from auth.example.com which returns a\n * response without expires_in (JSON response is mocked out)\n *\n * Expected behavior: the filter should return a 401 directly to the user.\n */\nTEST_F(OAuth2Test, OAuthCallbackStartsAuthentication) {\n  Http::TestRequestHeaderMapImpl request_headers{\n      {Http::Headers::get().Path.get(), \"/_oauth?code=123&state=https://asdf&method=GET\"},\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Scheme.get(), \"https\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n  };\n\n  // Deliberately fail the HMAC Validation check.\n  EXPECT_CALL(*validator_, setParams(_, _));\n  EXPECT_CALL(*validator_, isValid()).WillOnce(Return(false));\n\n  EXPECT_CALL(*oauth_client_, asyncGetAccessToken(\"123\", TEST_CLIENT_ID, \"asdf_client_secret_fdsa\",\n                                                  \"https://traffic.example.com\" + TEST_CALLBACK));\n\n  EXPECT_EQ(Http::FilterHeadersStatus::StopAllIterationAndBuffer,\n            filter_->decodeHeaders(request_headers, false));\n}\n\n/**\n * Scenario: Protoc in opted-in to allow OPTIONS requests to pass-through. This is important as\n * POST requests initiate an OPTIONS request first in order to ensure POST is supported. During a\n * preflight request where the client Javascript initiates a remote call to a different endpoint,\n * we don't want to fail the call immediately due to browser restrictions, and use existing\n * cookies instead (OPTIONS requests do not send OAuth cookies.)\n */\nTEST_F(OAuth2Test, OAuthOptionsRequestAndContinue) {\n  Http::TestRequestHeaderMapImpl request_headers{\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Path.get(), \"/anypath\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Options},\n  };\n\n  EXPECT_CALL(*validator_, setParams(_, _));\n  EXPECT_CALL(*validator_, isValid()).WillOnce(Return(false));\n  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->decodeHeaders(request_headers, false));\n}\n\n// Validates the behavior of the cookie validator.\nTEST_F(OAuth2Test, CookieValidator) {\n  expectValidCookies(CookieNames{\"BearerToken\", \"OauthHMAC\", \"OauthExpires\"});\n}\n\n// Validates the behavior of the cookie validator with custom cookie names.\nTEST_F(OAuth2Test, CookieValidatorWithCustomNames) {\n  expectValidCookies(CookieNames{\"CustomBearerToken\", \"CustomOauthHMAC\", \"CustomOauthExpires\"});\n}\n\n// Validates the behavior of the cookie validator when the expires_at value is not a valid integer.\nTEST_F(OAuth2Test, CookieValidatorInvalidExpiresAt) {\n  Http::TestRequestHeaderMapImpl request_headers{\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Path.get(), \"/anypath\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n      {Http::Headers::get().Cookie.get(), \"OauthExpires=notanumber;version=test\"},\n      {Http::Headers::get().Cookie.get(), \"BearerToken=xyztoken;version=test\"},\n      {Http::Headers::get().Cookie.get(),\n       \"OauthHMAC=\"\n       \"M2NjZmIxYWE0NzQzOGZlZTJjMjQwMzBiZTU5OTdkN2Y0NDRhZjE5MjZiOWNhY2YzNjM0MWRmMTNkMDVmZWFlOQ==\"\n       \";version=test\"},\n  };\n\n  auto cookie_validator = std::make_shared<OAuth2CookieValidator>(\n      test_time_, CookieNames{\"BearerToken\", \"OauthHMAC\", \"OauthExpires\"});\n  cookie_validator->setParams(request_headers, \"mock-secret\");\n\n  EXPECT_TRUE(cookie_validator->hmacIsValid());\n  EXPECT_FALSE(cookie_validator->timestampIsValid());\n  EXPECT_FALSE(cookie_validator->isValid());\n}\n\n// Verify that we 401 the request if the state query param doesn't contain a valid URL.\nTEST_F(OAuth2Test, OAuthTestInvalidUrlInStateQueryParam) {\n  Http::TestRequestHeaderMapImpl request_headers{\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n      {Http::Headers::get().Path.get(),\n       \"/_oauth?code=abcdefxyz123&scope=\" + TEST_ENCODED_AUTH_SCOPES + \"&state=blah\"},\n      {Http::Headers::get().Cookie.get(), \"OauthExpires=123;version=test\"},\n      {Http::Headers::get().Cookie.get(), \"BearerToken=legit_token;version=test\"},\n      {Http::Headers::get().Cookie.get(),\n       \"OauthHMAC=\"\n       \"ZTRlMzU5N2Q4ZDIwZWE5ZTU5NTg3YTU3YTcxZTU0NDFkMzY1ZTc1NjMyODYyMj\"\n       \"RlNjMxZTJmNTZkYzRmZTM0ZQ====;version=test\"},\n  };\n\n  Http::TestRequestHeaderMapImpl expected_headers{\n      {Http::Headers::get().Status.get(), \"401\"},\n      {Http::Headers::get().ContentLength.get(), \"18\"},\n      {Http::Headers::get().ContentType.get(), \"text/plain\"},\n      // Invalid URL: we inject a few : in the middle of the URL.\n  };\n\n  // Succeed the HMAC validation.\n  EXPECT_CALL(*validator_, setParams(_, _));\n  EXPECT_CALL(*validator_, isValid()).WillOnce(Return(true));\n\n  std::string legit_token{\"legit_token\"};\n  EXPECT_CALL(*validator_, token()).WillRepeatedly(ReturnRef(legit_token));\n\n  EXPECT_CALL(decoder_callbacks_, encodeHeaders_(HeaderMapEqualRef(&expected_headers), false));\n  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,\n            filter_->decodeHeaders(request_headers, false));\n}\n\n// Verify that we 401 the request if the state query param contains the callback URL.\nTEST_F(OAuth2Test, OAuthTestCallbackUrlInStateQueryParam) {\n  Http::TestRequestHeaderMapImpl request_headers{\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n      {Http::Headers::get().Path.get(),\n       \"/_oauth?code=abcdefxyz123&scope=\" + TEST_ENCODED_AUTH_SCOPES +\n           \"&state=https%3A%2F%2Ftraffic.example.com%2F_oauth\"},\n\n      {Http::Headers::get().Cookie.get(), \"OauthExpires=123;version=test\"},\n      {Http::Headers::get().Cookie.get(), \"BearerToken=legit_token;version=test\"},\n      {Http::Headers::get().Cookie.get(),\n       \"OauthHMAC=\"\n       \"ZTRlMzU5N2Q4ZDIwZWE5ZTU5NTg3YTU3YTcxZTU0NDFkMzY1ZTc1NjMyODYyMj\"\n       \"RlNjMxZTJmNTZkYzRmZTM0ZQ====;version=test\"},\n  };\n\n  Http::TestRequestHeaderMapImpl expected_response_headers{\n      {Http::Headers::get().Status.get(), \"401\"},\n      {Http::Headers::get().ContentLength.get(), \"18\"},\n      {Http::Headers::get().ContentType.get(), \"text/plain\"},\n  };\n\n  // Succeed the HMAC validation.\n  EXPECT_CALL(*validator_, setParams(_, _));\n  EXPECT_CALL(*validator_, isValid()).WillOnce(Return(true));\n\n  std::string legit_token{\"legit_token\"};\n  EXPECT_CALL(*validator_, token()).WillRepeatedly(ReturnRef(legit_token));\n\n  EXPECT_CALL(decoder_callbacks_,\n              encodeHeaders_(HeaderMapEqualRef(&expected_response_headers), false));\n  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,\n            filter_->decodeHeaders(request_headers, false));\n\n  Http::TestRequestHeaderMapImpl final_request_headers{\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n      {Http::Headers::get().Path.get(),\n       \"/_oauth?code=abcdefxyz123&scope=\" + TEST_ENCODED_AUTH_SCOPES +\n           \"&state=https%3A%2F%2Ftraffic.example.com%2F_oauth\"},\n      {Http::Headers::get().Cookie.get(), \"OauthExpires=123;version=test\"},\n      {Http::Headers::get().Cookie.get(), \"BearerToken=legit_token;version=test\"},\n      {Http::Headers::get().Cookie.get(),\n       \"OauthHMAC=\"\n       \"ZTRlMzU5N2Q4ZDIwZWE5ZTU5NTg3YTU3YTcxZTU0NDFkMzY1ZTc1NjMyODYyMj\"\n       \"RlNjMxZTJmNTZkYzRmZTM0ZQ====;version=test\"},\n      {Http::CustomHeaders::get().Authorization.get(), \"Bearer legit_token\"},\n  };\n\n  EXPECT_EQ(request_headers, final_request_headers);\n}\n\n/**\n * Testing the Path header replacement after an OAuth success.\n *\n * Expected behavior: the passed in HeaderMap should pass the OAuth flow, but since it's during\n * a callback from the authentication server, we should first parse out the state query string\n * parameter and set it to be the new path.\n */\nTEST_F(OAuth2Test, OAuthTestUpdatePathAfterSuccess) {\n  Http::TestRequestHeaderMapImpl request_headers{\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n      {Http::Headers::get().Path.get(),\n       \"/_oauth?code=abcdefxyz123&scope=\" + TEST_ENCODED_AUTH_SCOPES +\n           \"&state=https%3A%2F%2Ftraffic.example.com%2Foriginal_path\"},\n      {Http::Headers::get().Cookie.get(), \"OauthExpires=123;version=test\"},\n      {Http::Headers::get().Cookie.get(), \"BearerToken=legit_token;version=test\"},\n      {Http::Headers::get().Cookie.get(),\n       \"OauthHMAC=\"\n       \"ZTRlMzU5N2Q4ZDIwZWE5ZTU5NTg3YTU3YTcxZTU0NDFkMzY1ZTc1NjMyODYyMj\"\n       \"RlNjMxZTJmNTZkYzRmZTM0ZQ====;version=test\"},\n  };\n\n  Http::TestRequestHeaderMapImpl expected_response_headers{\n      {Http::Headers::get().Status.get(), \"302\"},\n      {Http::Headers::get().Location.get(), \"https://traffic.example.com/original_path\"},\n  };\n\n  // Succeed the HMAC validation.\n  EXPECT_CALL(*validator_, setParams(_, _));\n  EXPECT_CALL(*validator_, isValid()).WillOnce(Return(true));\n\n  std::string legit_token{\"legit_token\"};\n  EXPECT_CALL(*validator_, token()).WillRepeatedly(ReturnRef(legit_token));\n\n  EXPECT_CALL(decoder_callbacks_,\n              encodeHeaders_(HeaderMapEqualRef(&expected_response_headers), true));\n  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->decodeHeaders(request_headers, false));\n\n  Http::TestRequestHeaderMapImpl final_request_headers{\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n      {Http::Headers::get().Path.get(),\n       \"/_oauth?code=abcdefxyz123&scope=\" + TEST_ENCODED_AUTH_SCOPES +\n           \"&state=https%3A%2F%2Ftraffic.example.com%2Foriginal_path\"},\n      {Http::Headers::get().Cookie.get(), \"OauthExpires=123;version=test\"},\n      {Http::Headers::get().Cookie.get(), \"BearerToken=legit_token;version=test\"},\n      {Http::Headers::get().Cookie.get(),\n       \"OauthHMAC=\"\n       \"ZTRlMzU5N2Q4ZDIwZWE5ZTU5NTg3YTU3YTcxZTU0NDFkMzY1ZTc1NjMyODYyMj\"\n       \"RlNjMxZTJmNTZkYzRmZTM0ZQ====;version=test\"},\n      {Http::CustomHeaders::get().Authorization.get(), \"Bearer legit_token\"},\n  };\n\n  EXPECT_EQ(request_headers, final_request_headers);\n}\n\n/**\n * Testing oauth state with query string parameters.\n *\n * Expected behavior: HTTP Utility should not strip the parameters of the original request.\n */\nTEST_F(OAuth2Test, OAuthTestFullFlowPostWithParameters) {\n  // First construct the initial request to the oauth filter with URI parameters.\n  Http::TestRequestHeaderMapImpl first_request_headers{\n      {Http::Headers::get().Path.get(), \"/test?name=admin&level=trace\"},\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Post},\n      {Http::Headers::get().Scheme.get(), \"https\"},\n  };\n\n  // This is the immediate response - a redirect to the auth cluster.\n  Http::TestResponseHeaderMapImpl first_response_headers{\n      {Http::Headers::get().Status.get(), \"302\"},\n      {Http::Headers::get().Location.get(),\n       \"https://auth.example.com/oauth/\"\n       \"authorize/?client_id=\" +\n           TEST_CLIENT_ID + \"&scope=\" + TEST_ENCODED_AUTH_SCOPES +\n           \"&response_type=code&\"\n           \"redirect_uri=https%3A%2F%2Ftraffic.example.com%2F\"\n           \"_oauth&state=https%3A%2F%2Ftraffic.example.com%2Ftest%\"\n           \"3Fname%3Dadmin%26level%3Dtrace\"\n           \"&resource=oauth2-resource&resource=http%3A%2F%2Fexample.com\"\n           \"&resource=https%3A%2F%2Fexample.com\"},\n  };\n\n  // Fail the validation to trigger the OAuth flow.\n  EXPECT_CALL(*validator_, setParams(_, _));\n  EXPECT_CALL(*validator_, isValid()).WillOnce(Return(false));\n\n  // Check that the redirect includes the escaped parameter characters, '?', '&' and '='.\n  EXPECT_CALL(decoder_callbacks_, encodeHeaders_(HeaderMapEqualRef(&first_response_headers), true));\n\n  // This represents the beginning of the OAuth filter.\n  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,\n            filter_->decodeHeaders(first_request_headers, false));\n\n  // This represents the callback request from the authorization server.\n  Http::TestRequestHeaderMapImpl second_request_headers{\n      {Http::Headers::get().Path.get(), \"/_oauth?code=123&state=https%3A%2F%2Ftraffic.example.com%\"\n                                        \"2Ftest%3Fname%3Dadmin%26level%3Dtrace\"},\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n      {Http::Headers::get().Scheme.get(), \"https\"},\n  };\n\n  // Deliberately fail the HMAC validation check.\n  EXPECT_CALL(*validator_, setParams(_, _));\n  EXPECT_CALL(*validator_, isValid()).WillOnce(Return(false));\n\n  EXPECT_CALL(*oauth_client_, asyncGetAccessToken(\"123\", TEST_CLIENT_ID, \"asdf_client_secret_fdsa\",\n                                                  \"https://traffic.example.com\" + TEST_CALLBACK));\n\n  // Invoke the callback logic. As a side effect, state_ will be populated.\n  EXPECT_EQ(Http::FilterHeadersStatus::StopAllIterationAndBuffer,\n            filter_->decodeHeaders(second_request_headers, false));\n\n  EXPECT_EQ(1, config_->stats().oauth_unauthorized_rq_.value());\n  EXPECT_EQ(config_->clusterName(), \"auth.example.com\");\n\n  // Expected response after the callback & validation is complete - verifying we kept the\n  // state and method of the original request, including the query string parameters.\n  Http::TestRequestHeaderMapImpl second_response_headers{\n      {Http::Headers::get().Status.get(), \"302\"},\n      {Http::Headers::get().SetCookie.get(),\n       \"OauthHMAC=\"\n       \"NWUzNzE5MWQwYTg0ZjA2NjIyMjVjMzk3MzY3MzMyZmE0NjZmMWI2MjI1NWFhNDhkYjQ4NDFlZmRiMTVmMTk0MQ==;\"\n       \"version=1;path=/;Max-Age=;secure;HttpOnly\"},\n      {Http::Headers::get().SetCookie.get(),\n       \"OauthExpires=;version=1;path=/;Max-Age=;secure;HttpOnly\"},\n      {Http::Headers::get().SetCookie.get(), \"BearerToken=;version=1;path=/;Max-Age=;secure\"},\n      {Http::Headers::get().Location.get(),\n       \"https://traffic.example.com/test?name=admin&level=trace\"},\n  };\n\n  EXPECT_CALL(decoder_callbacks_,\n              encodeHeaders_(HeaderMapEqualRef(&second_response_headers), true));\n  EXPECT_CALL(decoder_callbacks_, continueDecoding());\n\n  filter_->finishFlow();\n}\n\nTEST_F(OAuth2Test, OAuthBearerTokenFlowFromHeader) {\n  Http::TestRequestHeaderMapImpl request_headers_before{\n      {Http::Headers::get().Path.get(), \"/test?role=bearer\"},\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n      {Http::Headers::get().Scheme.get(), \"https\"},\n      {Http::CustomHeaders::get().Authorization.get(), \"Bearer xyz-header-token\"},\n  };\n  // Expected decoded headers after the callback & validation of the bearer token is complete.\n  Http::TestRequestHeaderMapImpl request_headers_after{\n      {Http::Headers::get().Path.get(), \"/test?role=bearer\"},\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n      {Http::Headers::get().Scheme.get(), \"https\"},\n      {Http::CustomHeaders::get().Authorization.get(), \"Bearer xyz-header-token\"},\n  };\n\n  // Fail the validation to trigger the OAuth flow.\n  EXPECT_CALL(*validator_, setParams(_, _));\n  EXPECT_CALL(*validator_, isValid()).WillOnce(Return(false));\n\n  EXPECT_EQ(Http::FilterHeadersStatus::Continue,\n            filter_->decodeHeaders(request_headers_before, false));\n\n  // Finally, expect that the header map had OAuth information appended to it.\n  EXPECT_EQ(request_headers_before, request_headers_after);\n}\n\nTEST_F(OAuth2Test, OAuthBearerTokenFlowFromQueryParameters) {\n  Http::TestRequestHeaderMapImpl request_headers_before{\n      {Http::Headers::get().Path.get(), \"/test?role=bearer&token=xyz-queryparam-token\"},\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n      {Http::Headers::get().Scheme.get(), \"https\"},\n  };\n  Http::TestRequestHeaderMapImpl request_headers_after{\n      {Http::Headers::get().Path.get(), \"/test?role=bearer&token=xyz-queryparam-token\"},\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n      {Http::Headers::get().Scheme.get(), \"https\"},\n      {Http::CustomHeaders::get().Authorization.get(), \"Bearer xyz-queryparam-token\"},\n  };\n\n  // Fail the validation to trigger the OAuth flow.\n  EXPECT_CALL(*validator_, setParams(_, _));\n  EXPECT_CALL(*validator_, isValid()).WillOnce(Return(false));\n\n  EXPECT_EQ(Http::FilterHeadersStatus::Continue,\n            filter_->decodeHeaders(request_headers_before, false));\n\n  // Expected decoded headers after the callback & validation of the bearer token is complete.\n  EXPECT_EQ(request_headers_before, request_headers_after);\n}\n\n} // namespace Oauth2\n} // namespace HttpFilters\n} // namespace Extensions\n} // namespace Envoy\n"], "fixing_code": ["#include \"source/extensions/filters/http/oauth2/filter.h\"\n\n#include <algorithm>\n#include <chrono>\n#include <memory>\n#include <string>\n#include <vector>\n\n#include \"source/common/common/assert.h\"\n#include \"source/common/common/empty_string.h\"\n#include \"source/common/common/enum_to_int.h\"\n#include \"source/common/common/fmt.h\"\n#include \"source/common/common/hex.h\"\n#include \"source/common/common/matchers.h\"\n#include \"source/common/crypto/utility.h\"\n#include \"source/common/http/header_map_impl.h\"\n#include \"source/common/http/header_utility.h\"\n#include \"source/common/http/headers.h\"\n#include \"source/common/http/message_impl.h\"\n#include \"source/common/http/utility.h\"\n#include \"source/common/protobuf/utility.h\"\n\n#include \"absl/strings/escaping.h\"\n#include \"absl/strings/match.h\"\n#include \"absl/strings/str_cat.h\"\n#include \"absl/strings/str_join.h\"\n#include \"absl/strings/str_replace.h\"\n#include \"absl/strings/str_split.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace HttpFilters {\nnamespace Oauth2 {\n\nnamespace {\nHttp::RegisterCustomInlineHeader<Http::CustomInlineHeaderRegistry::Type::RequestHeaders>\n    authorization_handle(Http::CustomHeaders::get().Authorization);\n\n// Deleted OauthHMAC cookie.\nconstexpr const char* SignoutCookieValue =\n    \"{}=deleted; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT\";\n\n// Deleted BearerToken cookie.\nconstexpr const char* SignoutBearerTokenValue =\n    \"{}=deleted; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT\";\n\nconstexpr absl::string_view SignoutIdTokenValue =\n    \"IdToken=deleted; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT\";\n\nconstexpr absl::string_view SignoutRefreshTokenValue =\n    \"RefreshToken=deleted; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT\";\n\nconstexpr const char* CookieTailFormatString = \";version=1;path=/;Max-Age={};secure\";\n\nconstexpr const char* CookieTailHttpOnlyFormatString =\n    \";version=1;path=/;Max-Age={};secure;HttpOnly\";\n\nconst char* AuthorizationEndpointFormat =\n    \"{}?client_id={}&scope={}&response_type=code&redirect_uri={}&state={}\";\n\nconstexpr absl::string_view UnauthorizedBodyMessage = \"OAuth flow failed.\";\n\nconst std::string& queryParamsError() { CONSTRUCT_ON_FIRST_USE(std::string, \"error\"); }\nconst std::string& queryParamsCode() { CONSTRUCT_ON_FIRST_USE(std::string, \"code\"); }\nconst std::string& queryParamsState() { CONSTRUCT_ON_FIRST_USE(std::string, \"state\"); }\n\nconstexpr absl::string_view REDIRECT_RACE = \"oauth.race_redirect\";\nconstexpr absl::string_view REDIRECT_LOGGED_IN = \"oauth.logged_in\";\nconstexpr absl::string_view REDIRECT_FOR_CREDENTIALS = \"oauth.missing_credentials\";\nconstexpr absl::string_view SIGN_OUT = \"oauth.sign_out\";\nconstexpr absl::string_view DEFAULT_AUTH_SCOPE = \"user\";\n\ntemplate <class T>\nstd::vector<Http::HeaderUtility::HeaderData> headerMatchers(const T& matcher_protos) {\n  std::vector<Http::HeaderUtility::HeaderData> matchers;\n  matchers.reserve(matcher_protos.size());\n\n  for (const auto& proto : matcher_protos) {\n    matchers.emplace_back(proto);\n  }\n\n  return matchers;\n}\n\n// Transforms the proto list of 'auth_scopes' into a vector of std::string, also\n// handling the default value logic.\nstd::vector<std::string>\nauthScopesList(const Protobuf::RepeatedPtrField<std::string>& auth_scopes_protos) {\n  std::vector<std::string> scopes;\n\n  // If 'auth_scopes' is empty it must return a list with the default value.\n  if (auth_scopes_protos.empty()) {\n    scopes.emplace_back(DEFAULT_AUTH_SCOPE);\n  } else {\n    scopes.reserve(auth_scopes_protos.size());\n\n    for (const auto& scope : auth_scopes_protos) {\n      scopes.emplace_back(scope);\n    }\n  }\n  return scopes;\n}\n\n// Transforms the proto list into encoded resource params\n// Takes care of percentage encoding http and https is needed\nstd::string encodeResourceList(const Protobuf::RepeatedPtrField<std::string>& resources_protos) {\n  std::string result = \"\";\n  for (const auto& resource : resources_protos) {\n    result += \"&resource=\" + Http::Utility::PercentEncoding::encode(resource, \":/=&? \");\n  }\n  return result;\n}\n\n// Sets the auth token as the Bearer token in the authorization header.\nvoid setBearerToken(Http::RequestHeaderMap& headers, const std::string& token) {\n  headers.setInline(authorization_handle.handle(), absl::StrCat(\"Bearer \", token));\n}\n\nstd::string findValue(const absl::flat_hash_map<std::string, std::string>& map,\n                      const std::string& key) {\n  const auto value_it = map.find(key);\n  return value_it != map.end() ? value_it->second : EMPTY_STRING;\n}\n} // namespace\n\nFilterConfig::FilterConfig(\n    const envoy::extensions::filters::http::oauth2::v3::OAuth2Config& proto_config,\n    Upstream::ClusterManager& cluster_manager, std::shared_ptr<SecretReader> secret_reader,\n    Stats::Scope& scope, const std::string& stats_prefix)\n    : oauth_token_endpoint_(proto_config.token_endpoint()),\n      authorization_endpoint_(proto_config.authorization_endpoint()),\n      client_id_(proto_config.credentials().client_id()),\n      redirect_uri_(proto_config.redirect_uri()),\n      redirect_matcher_(proto_config.redirect_path_matcher()),\n      signout_path_(proto_config.signout_path()), secret_reader_(secret_reader),\n      stats_(FilterConfig::generateStats(stats_prefix, scope)),\n      encoded_auth_scopes_(Http::Utility::PercentEncoding::encode(\n          absl::StrJoin(authScopesList(proto_config.auth_scopes()), \" \"), \":/=&? \")),\n      encoded_resource_query_params_(encodeResourceList(proto_config.resources())),\n      forward_bearer_token_(proto_config.forward_bearer_token()),\n      pass_through_header_matchers_(headerMatchers(proto_config.pass_through_matcher())),\n      cookie_names_(proto_config.credentials().cookie_names()) {\n  if (!cluster_manager.clusters().hasCluster(oauth_token_endpoint_.cluster())) {\n    throw EnvoyException(fmt::format(\"OAuth2 filter: unknown cluster '{}' in config. Please \"\n                                     \"specify which cluster to direct OAuth requests to.\",\n                                     oauth_token_endpoint_.cluster()));\n  }\n}\n\nFilterStats FilterConfig::generateStats(const std::string& prefix, Stats::Scope& scope) {\n  return {ALL_OAUTH_FILTER_STATS(POOL_COUNTER_PREFIX(scope, prefix))};\n}\n\nvoid OAuth2CookieValidator::setParams(const Http::RequestHeaderMap& headers,\n                                      const std::string& secret) {\n  const auto& cookies = Http::Utility::parseCookies(headers, [this](absl::string_view key) -> bool {\n    return key == cookie_names_.oauth_expires_ || key == cookie_names_.bearer_token_ ||\n           key == cookie_names_.oauth_hmac_ || key == \"IdToken\" || key == \"RefreshToken\";\n  });\n\n  expires_ = findValue(cookies, cookie_names_.oauth_expires_);\n  token_ = findValue(cookies, cookie_names_.bearer_token_);\n  id_token_ = findValue(cookies, \"IdToken\");\n  refresh_token_ = findValue(cookies, \"RefreshToken\");\n  hmac_ = findValue(cookies, cookie_names_.oauth_hmac_);\n  host_ = headers.Host()->value().getStringView();\n\n  secret_.assign(secret.begin(), secret.end());\n}\n\nbool OAuth2CookieValidator::hmacIsValid() const {\n  auto& crypto_util = Envoy::Common::Crypto::UtilitySingleton::get();\n  const auto hmac_payload = absl::StrCat(host_, expires_, token_, id_token_, refresh_token_);\n  const auto pre_encoded_hmac = Hex::encode(crypto_util.getSha256Hmac(secret_, hmac_payload));\n  std::string encoded_hmac;\n  absl::Base64Escape(pre_encoded_hmac, &encoded_hmac);\n\n  return encoded_hmac == hmac_;\n}\n\nbool OAuth2CookieValidator::timestampIsValid() const {\n  uint64_t expires;\n  if (!absl::SimpleAtoi(expires_, &expires)) {\n    return false;\n  }\n\n  const auto current_epoch = time_source_.systemTime().time_since_epoch();\n  return std::chrono::seconds(expires) > current_epoch;\n}\n\nbool OAuth2CookieValidator::isValid() const { return hmacIsValid() && timestampIsValid(); }\n\nOAuth2Filter::OAuth2Filter(FilterConfigSharedPtr config,\n                           std::unique_ptr<OAuth2Client>&& oauth_client, TimeSource& time_source)\n    : validator_(std::make_shared<OAuth2CookieValidator>(time_source, config->cookieNames())),\n      oauth_client_(std::move(oauth_client)), config_(std::move(config)),\n      time_source_(time_source) {\n\n  oauth_client_->setCallbacks(*this);\n}\n\nconst std::string& OAuth2Filter::bearerPrefix() const {\n  CONSTRUCT_ON_FIRST_USE(std::string, \"bearer \");\n}\n\n/**\n * primary cases:\n * 1) user is signing out\n * 2) /_oauth redirect\n * 3) user is authorized\n * 4) user is unauthorized\n */\nHttp::FilterHeadersStatus OAuth2Filter::decodeHeaders(Http::RequestHeaderMap& headers, bool) {\n  // Sanitize the Authorization header, since we have no way to validate its content. Also,\n  // if token forwarding is enabled, this header will be set based on what is on the HMAC cookie\n  // before forwarding the request upstream.\n  headers.removeInline(authorization_handle.handle());\n\n  // The following 2 headers are guaranteed for regular requests. The asserts are helpful when\n  // writing test code to not forget these important variables in mock requests\n  const Http::HeaderEntry* host_header = headers.Host();\n  ASSERT(host_header != nullptr);\n  host_ = host_header->value().getStringView();\n\n  const Http::HeaderEntry* path_header = headers.Path();\n  ASSERT(path_header != nullptr);\n  const absl::string_view path_str = path_header->value().getStringView();\n\n  // We should check if this is a sign out request.\n  if (config_->signoutPath().match(path_header->value().getStringView())) {\n    return signOutUser(headers);\n  }\n\n  if (canSkipOAuth(headers)) {\n    // Update the path header with the query string parameters after a successful OAuth login.\n    // This is necessary if a website requests multiple resources which get redirected to the\n    // auth server. A cached login on the authorization server side will set cookies\n    // correctly but cause a race condition on future requests that have their location set\n    // to the callback path.\n\n    if (config_->redirectPathMatcher().match(path_str)) {\n      Http::Utility::QueryParams query_parameters = Http::Utility::parseQueryString(path_str);\n\n      const auto state =\n          Http::Utility::PercentEncoding::decode(query_parameters.at(queryParamsState()));\n      Http::Utility::Url state_url;\n      if (!state_url.initialize(state, false)) {\n        sendUnauthorizedResponse();\n        return Http::FilterHeadersStatus::StopIteration;\n      }\n      // Avoid infinite redirect storm\n      if (config_->redirectPathMatcher().match(state_url.pathAndQueryParams())) {\n        sendUnauthorizedResponse();\n        return Http::FilterHeadersStatus::StopIteration;\n      }\n      Http::ResponseHeaderMapPtr response_headers{\n          Http::createHeaderMap<Http::ResponseHeaderMapImpl>(\n              {{Http::Headers::get().Status, std::to_string(enumToInt(Http::Code::Found))},\n               {Http::Headers::get().Location, state}})};\n      decoder_callbacks_->encodeHeaders(std::move(response_headers), true, REDIRECT_RACE);\n    }\n\n    // Continue on with the filter stack.\n    return Http::FilterHeadersStatus::Continue;\n  }\n\n  // Save the request headers for later modification if needed.\n  if (config_->forwardBearerToken()) {\n    request_headers_ = &headers;\n  }\n\n  // If this isn't the callback URI, redirect to acquire credentials.\n  //\n  // The following conditional could be replaced with a regex pattern-match,\n  // if we're concerned about strict matching against the callback path.\n  if (!config_->redirectPathMatcher().match(path_str)) {\n    Http::ResponseHeaderMapPtr response_headers{Http::createHeaderMap<Http::ResponseHeaderMapImpl>(\n        {{Http::Headers::get().Status, std::to_string(enumToInt(Http::Code::Found))}})};\n\n    // Construct the correct scheme. We default to https since this is a requirement for OAuth to\n    // succeed. However, if a downstream client explicitly declares the \"http\" scheme for whatever\n    // reason, we also use \"http\" when constructing our redirect uri to the authorization server.\n    auto scheme = Http::Headers::get().SchemeValues.Https;\n\n    const auto* scheme_header = headers.Scheme();\n    if ((scheme_header != nullptr &&\n         scheme_header->value().getStringView() == Http::Headers::get().SchemeValues.Http)) {\n      scheme = Http::Headers::get().SchemeValues.Http;\n    }\n\n    const std::string base_path = absl::StrCat(scheme, \"://\", host_);\n    const std::string state_path = absl::StrCat(base_path, headers.Path()->value().getStringView());\n    const std::string escaped_state = Http::Utility::PercentEncoding::encode(state_path, \":/=&?\");\n\n    Formatter::FormatterImpl formatter(config_->redirectUri());\n    const auto redirect_uri = formatter.format(headers, *Http::ResponseHeaderMapImpl::create(),\n                                               *Http::ResponseTrailerMapImpl::create(),\n                                               decoder_callbacks_->streamInfo(), \"\");\n    const std::string escaped_redirect_uri =\n        Http::Utility::PercentEncoding::encode(redirect_uri, \":/=&?\");\n\n    const std::string new_url = fmt::format(\n        AuthorizationEndpointFormat, config_->authorizationEndpoint(), config_->clientId(),\n        config_->encodedAuthScopes(), escaped_redirect_uri, escaped_state);\n\n    response_headers->setLocation(new_url + config_->encodedResourceQueryParams());\n    decoder_callbacks_->encodeHeaders(std::move(response_headers), true, REDIRECT_FOR_CREDENTIALS);\n\n    config_->stats().oauth_unauthorized_rq_.inc();\n\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n\n  // At this point, we *are* on /_oauth. We believe this request comes from the authorization\n  // server and we expect the query strings to contain the information required to get the access\n  // token\n  const auto query_parameters = Http::Utility::parseQueryString(path_str);\n  if (query_parameters.find(queryParamsError()) != query_parameters.end()) {\n    sendUnauthorizedResponse();\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n\n  // if the data we need is not present on the URL, stop execution\n  if (query_parameters.find(queryParamsCode()) == query_parameters.end() ||\n      query_parameters.find(queryParamsState()) == query_parameters.end()) {\n    sendUnauthorizedResponse();\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n\n  auth_code_ = query_parameters.at(queryParamsCode());\n  state_ = Http::Utility::PercentEncoding::decode(query_parameters.at(queryParamsState()));\n\n  Http::Utility::Url state_url;\n  if (!state_url.initialize(state_, false)) {\n    sendUnauthorizedResponse();\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n\n  Formatter::FormatterImpl formatter(config_->redirectUri());\n  const auto redirect_uri = formatter.format(headers, *Http::ResponseHeaderMapImpl::create(),\n                                             *Http::ResponseTrailerMapImpl::create(),\n                                             decoder_callbacks_->streamInfo(), \"\");\n  oauth_client_->asyncGetAccessToken(auth_code_, config_->clientId(), config_->clientSecret(),\n                                     redirect_uri);\n\n  // pause while we await the next step from the OAuth server\n  return Http::FilterHeadersStatus::StopAllIterationAndBuffer;\n}\n\n// Defines a sequence of checks determining whether we should initiate a new OAuth flow or skip to\n// the next filter in the chain.\nbool OAuth2Filter::canSkipOAuth(Http::RequestHeaderMap& headers) const {\n  // We can skip OAuth if the supplied HMAC cookie is valid. Apply the OAuth details as headers\n  // if we successfully validate the cookie.\n  validator_->setParams(headers, config_->tokenSecret());\n  if (validator_->isValid()) {\n    config_->stats().oauth_success_.inc();\n    if (config_->forwardBearerToken() && !validator_->token().empty()) {\n      setBearerToken(headers, validator_->token());\n    }\n    return true;\n  }\n\n  for (const auto& matcher : config_->passThroughMatchers()) {\n    if (matcher.matchesHeaders(headers)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Modifies the state of the filter by adding response headers to the decoder_callbacks\n */\nHttp::FilterHeadersStatus OAuth2Filter::signOutUser(const Http::RequestHeaderMap& headers) {\n  Http::ResponseHeaderMapPtr response_headers{Http::createHeaderMap<Http::ResponseHeaderMapImpl>(\n      {{Http::Headers::get().Status, std::to_string(enumToInt(Http::Code::Found))}})};\n\n  const std::string new_path = absl::StrCat(Http::Utility::getScheme(headers), \"://\", host_, \"/\");\n  response_headers->addReferenceKey(\n      Http::Headers::get().SetCookie,\n      fmt::format(SignoutCookieValue, config_->cookieNames().oauth_hmac_));\n  response_headers->addReferenceKey(\n      Http::Headers::get().SetCookie,\n      fmt::format(SignoutBearerTokenValue, config_->cookieNames().bearer_token_));\n  response_headers->addReferenceKey(Http::Headers::get().SetCookie, SignoutIdTokenValue);\n  response_headers->addReferenceKey(Http::Headers::get().SetCookie, SignoutRefreshTokenValue);\n  response_headers->setLocation(new_path);\n  decoder_callbacks_->encodeHeaders(std::move(response_headers), true, SIGN_OUT);\n\n  return Http::FilterHeadersStatus::StopIteration;\n}\n\nvoid OAuth2Filter::onGetAccessTokenSuccess(const std::string& access_code,\n                                           const std::string& id_token,\n                                           const std::string& refresh_token,\n                                           std::chrono::seconds expires_in) {\n  access_token_ = access_code;\n  id_token_ = id_token;\n  refresh_token_ = refresh_token;\n\n  const auto new_epoch = time_source_.systemTime() + expires_in;\n  new_expires_ = std::to_string(\n      std::chrono::duration_cast<std::chrono::seconds>(new_epoch.time_since_epoch()).count());\n\n  finishFlow();\n}\n\nvoid OAuth2Filter::finishFlow() {\n  std::string token_payload;\n  if (config_->forwardBearerToken()) {\n    token_payload = absl::StrCat(host_, new_expires_, access_token_, id_token_, refresh_token_);\n  } else {\n    token_payload = absl::StrCat(host_, new_expires_);\n  }\n\n  auto& crypto_util = Envoy::Common::Crypto::UtilitySingleton::get();\n\n  auto token_secret = config_->tokenSecret();\n  std::vector<uint8_t> token_secret_vec(token_secret.begin(), token_secret.end());\n  const std::string pre_encoded_token =\n      Hex::encode(crypto_util.getSha256Hmac(token_secret_vec, token_payload));\n  std::string encoded_token;\n  absl::Base64Escape(pre_encoded_token, &encoded_token);\n\n  // We use HTTP Only cookies for the HMAC and Expiry.\n  const std::string cookie_tail = fmt::format(CookieTailFormatString, new_expires_);\n  const std::string cookie_tail_http_only =\n      fmt::format(CookieTailHttpOnlyFormatString, new_expires_);\n\n  // At this point we have all of the pieces needed to authorize a user.\n  // Now, we construct a redirect request to return the user to their\n  // previous state and additionally set the OAuth cookies in browser.\n  // The redirection should result in successfully passing this filter.\n  Http::ResponseHeaderMapPtr response_headers{Http::createHeaderMap<Http::ResponseHeaderMapImpl>(\n      {{Http::Headers::get().Status, std::to_string(enumToInt(Http::Code::Found))}})};\n\n  const CookieNames& cookie_names = config_->cookieNames();\n\n  response_headers->addReferenceKey(\n      Http::Headers::get().SetCookie,\n      absl::StrCat(cookie_names.oauth_hmac_, \"=\", encoded_token, cookie_tail_http_only));\n  response_headers->addReferenceKey(\n      Http::Headers::get().SetCookie,\n      absl::StrCat(cookie_names.oauth_expires_, \"=\", new_expires_, cookie_tail_http_only));\n\n  // If opted-in, we also create a new Bearer cookie for the authorization token provided by the\n  // auth server.\n  if (config_->forwardBearerToken()) {\n    response_headers->addReferenceKey(\n        Http::Headers::get().SetCookie,\n        absl::StrCat(cookie_names.bearer_token_, \"=\", access_token_, cookie_tail));\n    if (id_token_ != EMPTY_STRING) {\n      response_headers->addReferenceKey(Http::Headers::get().SetCookie,\n                                        absl::StrCat(\"IdToken=\", id_token_, cookie_tail));\n    }\n\n    if (refresh_token_ != EMPTY_STRING) {\n      response_headers->addReferenceKey(Http::Headers::get().SetCookie,\n                                        absl::StrCat(\"RefreshToken=\", refresh_token_, cookie_tail));\n    }\n  }\n\n  response_headers->setLocation(state_);\n\n  decoder_callbacks_->encodeHeaders(std::move(response_headers), true, REDIRECT_LOGGED_IN);\n  config_->stats().oauth_success_.inc();\n}\n\nvoid OAuth2Filter::sendUnauthorizedResponse() {\n  config_->stats().oauth_failure_.inc();\n  decoder_callbacks_->sendLocalReply(Http::Code::Unauthorized, UnauthorizedBodyMessage, nullptr,\n                                     absl::nullopt, EMPTY_STRING);\n}\n\n} // namespace Oauth2\n} // namespace HttpFilters\n} // namespace Extensions\n} // namespace Envoy\n", "#pragma once\n\n#include <memory>\n#include <string>\n#include <vector>\n\n#include \"envoy/common/callback.h\"\n#include \"envoy/common/matchers.h\"\n#include \"envoy/config/core/v3/http_uri.pb.h\"\n#include \"envoy/extensions/filters/http/oauth2/v3/oauth.pb.h\"\n#include \"envoy/http/header_map.h\"\n#include \"envoy/server/filter_config.h\"\n#include \"envoy/stats/stats_macros.h\"\n#include \"envoy/stream_info/stream_info.h\"\n#include \"envoy/upstream/cluster_manager.h\"\n\n#include \"source/common/common/assert.h\"\n#include \"source/common/common/matchers.h\"\n#include \"source/common/config/datasource.h\"\n#include \"source/common/formatter/substitution_formatter.h\"\n#include \"source/common/http/header_map_impl.h\"\n#include \"source/common/http/header_utility.h\"\n#include \"source/common/http/rest_api_fetcher.h\"\n#include \"source/common/http/utility.h\"\n#include \"source/extensions/filters/http/common/pass_through_filter.h\"\n#include \"source/extensions/filters/http/oauth2/oauth.h\"\n#include \"source/extensions/filters/http/oauth2/oauth_client.h\"\n\n#include \"absl/strings/str_split.h\"\n#include \"absl/strings/string_view.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace HttpFilters {\nnamespace Oauth2 {\n\nclass OAuth2Client;\n\n// Helper class used to fetch secrets (usually from SDS).\nclass SecretReader {\npublic:\n  virtual ~SecretReader() = default;\n  virtual const std::string& clientSecret() const PURE;\n  virtual const std::string& tokenSecret() const PURE;\n};\n\nclass SDSSecretReader : public SecretReader {\npublic:\n  SDSSecretReader(Secret::GenericSecretConfigProviderSharedPtr client_secret_provider,\n                  Secret::GenericSecretConfigProviderSharedPtr token_secret_provider, Api::Api& api)\n      : update_callback_client_(readAndWatchSecret(client_secret_, client_secret_provider, api)),\n        update_callback_token_(readAndWatchSecret(token_secret_, token_secret_provider, api)) {}\n\n  const std::string& clientSecret() const override { return client_secret_; }\n\n  const std::string& tokenSecret() const override { return token_secret_; }\n\nprivate:\n  Envoy::Common::CallbackHandlePtr\n  readAndWatchSecret(std::string& value,\n                     Secret::GenericSecretConfigProviderSharedPtr& secret_provider, Api::Api& api) {\n    const auto* secret = secret_provider->secret();\n    if (secret != nullptr) {\n      value = Config::DataSource::read(secret->secret(), true, api);\n    }\n\n    return secret_provider->addUpdateCallback([secret_provider, &api, &value]() {\n      const auto* secret = secret_provider->secret();\n      if (secret != nullptr) {\n        value = Config::DataSource::read(secret->secret(), true, api);\n      }\n    });\n  }\n\n  std::string client_secret_;\n  std::string token_secret_;\n\n  Envoy::Common::CallbackHandlePtr update_callback_client_;\n  Envoy::Common::CallbackHandlePtr update_callback_token_;\n};\n\n/**\n * All stats for the OAuth filter. @see stats_macros.h\n */\n#define ALL_OAUTH_FILTER_STATS(COUNTER)                                                            \\\n  COUNTER(oauth_unauthorized_rq)                                                                   \\\n  COUNTER(oauth_failure)                                                                           \\\n  COUNTER(oauth_success)\n\n/**\n * Wrapper struct filter stats. @see stats_macros.h\n */\nstruct FilterStats {\n  ALL_OAUTH_FILTER_STATS(GENERATE_COUNTER_STRUCT)\n};\n\n/**\n * Helper structure to hold custom cookie names.\n */\nstruct CookieNames {\n  CookieNames(const envoy::extensions::filters::http::oauth2::v3::OAuth2Credentials::CookieNames&\n                  cookie_names)\n      : CookieNames(cookie_names.bearer_token(), cookie_names.oauth_hmac(),\n                    cookie_names.oauth_expires()) {}\n\n  CookieNames(const std::string& bearer_token, const std::string& oauth_hmac,\n              const std::string& oauth_expires)\n      : bearer_token_(bearer_token.empty() ? \"BearerToken\" : bearer_token),\n        oauth_hmac_(oauth_hmac.empty() ? \"OauthHMAC\" : oauth_hmac),\n        oauth_expires_(oauth_expires.empty() ? \"OauthExpires\" : oauth_expires) {}\n\n  const std::string bearer_token_;\n  const std::string oauth_hmac_;\n  const std::string oauth_expires_;\n};\n\n/**\n * This class encapsulates all data needed for the filter to operate so that we don't pass around\n * raw protobufs and other arbitrary data.\n */\nclass FilterConfig {\npublic:\n  FilterConfig(const envoy::extensions::filters::http::oauth2::v3::OAuth2Config& proto_config,\n               Upstream::ClusterManager& cluster_manager,\n               std::shared_ptr<SecretReader> secret_reader, Stats::Scope& scope,\n               const std::string& stats_prefix);\n  const std::string& clusterName() const { return oauth_token_endpoint_.cluster(); }\n  const std::string& clientId() const { return client_id_; }\n  bool forwardBearerToken() const { return forward_bearer_token_; }\n  const std::vector<Http::HeaderUtility::HeaderData>& passThroughMatchers() const {\n    return pass_through_header_matchers_;\n  }\n\n  const envoy::config::core::v3::HttpUri& oauthTokenEndpoint() const {\n    return oauth_token_endpoint_;\n  }\n  const std::string& authorizationEndpoint() const { return authorization_endpoint_; }\n  const std::string& redirectUri() const { return redirect_uri_; }\n  const Matchers::PathMatcher& redirectPathMatcher() const { return redirect_matcher_; }\n  const Matchers::PathMatcher& signoutPath() const { return signout_path_; }\n  std::string clientSecret() const { return secret_reader_->clientSecret(); }\n  std::string tokenSecret() const { return secret_reader_->tokenSecret(); }\n  FilterStats& stats() { return stats_; }\n  const std::string& encodedAuthScopes() const { return encoded_auth_scopes_; }\n  const std::string& encodedResourceQueryParams() const { return encoded_resource_query_params_; }\n  const CookieNames& cookieNames() const { return cookie_names_; }\n\nprivate:\n  static FilterStats generateStats(const std::string& prefix, Stats::Scope& scope);\n\n  const envoy::config::core::v3::HttpUri oauth_token_endpoint_;\n  const std::string authorization_endpoint_;\n  const std::string client_id_;\n  const std::string redirect_uri_;\n  const Matchers::PathMatcher redirect_matcher_;\n  const Matchers::PathMatcher signout_path_;\n  std::shared_ptr<SecretReader> secret_reader_;\n  FilterStats stats_;\n  const std::string encoded_auth_scopes_;\n  const std::string encoded_resource_query_params_;\n  const bool forward_bearer_token_ : 1;\n  const std::vector<Http::HeaderUtility::HeaderData> pass_through_header_matchers_;\n  const CookieNames cookie_names_;\n};\n\nusing FilterConfigSharedPtr = std::shared_ptr<FilterConfig>;\n\n/**\n * An OAuth cookie validator:\n * 1. extracts cookies from a request\n * 2. HMAC/encodes the values\n * 3. Compares the result to the cookie HMAC\n * 4. Checks that the `expires` value is valid relative to current time\n *\n * Required components:\n * - header map\n * - secret\n */\nclass CookieValidator {\npublic:\n  virtual ~CookieValidator() = default;\n  virtual const std::string& token() const PURE;\n  virtual void setParams(const Http::RequestHeaderMap& headers, const std::string& secret) PURE;\n  virtual bool isValid() const PURE;\n};\n\nclass OAuth2CookieValidator : public CookieValidator {\npublic:\n  explicit OAuth2CookieValidator(TimeSource& time_source, const CookieNames& cookie_names)\n      : time_source_(time_source), cookie_names_(cookie_names) {}\n\n  const std::string& token() const override { return token_; }\n  void setParams(const Http::RequestHeaderMap& headers, const std::string& secret) override;\n  bool isValid() const override;\n  bool hmacIsValid() const;\n  bool timestampIsValid() const;\n\nprivate:\n  std::string token_;\n  std::string id_token_;\n  std::string refresh_token_;\n  std::string expires_;\n  std::string hmac_;\n  std::vector<uint8_t> secret_;\n  absl::string_view host_;\n  TimeSource& time_source_;\n  const CookieNames cookie_names_;\n};\n\n/**\n * The filter is the primary entry point for the OAuth workflow. Its responsibilities are to\n * receive incoming requests and decide at what state of the OAuth workflow they are in. Logic\n * beyond that is broken into component classes.\n */\nclass OAuth2Filter : public Http::PassThroughDecoderFilter, public FilterCallbacks {\npublic:\n  OAuth2Filter(FilterConfigSharedPtr config, std::unique_ptr<OAuth2Client>&& oauth_client,\n               TimeSource& time_source);\n\n  // Http::PassThroughDecoderFilter\n  Http::FilterHeadersStatus decodeHeaders(Http::RequestHeaderMap& headers, bool) override;\n\n  // FilterCallbacks\n  void onGetAccessTokenSuccess(const std::string& access_code, const std::string& id_token,\n                               const std::string& refresh_token,\n                               std::chrono::seconds expires_in) override;\n  // a catch-all function used for request failures. we don't retry, as a user can simply refresh\n  // the page in the case of a network blip.\n  void sendUnauthorizedResponse() override;\n\n  void finishFlow();\n\nprivate:\n  friend class OAuth2Test;\n\n  std::shared_ptr<CookieValidator> validator_;\n\n  // wrap up some of these in a UserData struct or something...\n  std::string auth_code_;\n  std::string access_token_; // TODO - see if we can avoid this being a member variable\n  std::string id_token_;\n  std::string refresh_token_;\n  std::string new_expires_;\n  absl::string_view host_;\n  std::string state_;\n  Http::RequestHeaderMap* request_headers_{nullptr};\n\n  std::unique_ptr<OAuth2Client> oauth_client_;\n  FilterConfigSharedPtr config_;\n  TimeSource& time_source_;\n\n  // Determines whether or not the current request can skip the entire OAuth flow (HMAC is valid,\n  // connection is mTLS, etc.)\n  bool canSkipOAuth(Http::RequestHeaderMap& headers) const;\n\n  Http::FilterHeadersStatus signOutUser(const Http::RequestHeaderMap& headers);\n\n  const std::string& bearerPrefix() const;\n};\n\n} // namespace Oauth2\n} // namespace HttpFilters\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"source/extensions/filters/http/oauth2/oauth_client.h\"\n\n#include <chrono>\n\n#include \"envoy/http/async_client.h\"\n#include \"envoy/http/message.h\"\n#include \"envoy/upstream/cluster_manager.h\"\n\n#include \"source/common/common/empty_string.h\"\n#include \"source/common/common/fmt.h\"\n#include \"source/common/common/logger.h\"\n#include \"source/common/http/message_impl.h\"\n#include \"source/common/http/utility.h\"\n#include \"source/common/protobuf/message_validator_impl.h\"\n#include \"source/common/protobuf/utility.h\"\n#include \"source/extensions/filters/http/oauth2/oauth_response.pb.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace HttpFilters {\nnamespace Oauth2 {\n\nnamespace {\nconstexpr const char* GetAccessTokenBodyFormatString =\n    \"grant_type=authorization_code&code={0}&client_id={1}&client_secret={2}&redirect_uri={3}\";\n\n} // namespace\n\nvoid OAuth2ClientImpl::asyncGetAccessToken(const std::string& auth_code,\n                                           const std::string& client_id, const std::string& secret,\n                                           const std::string& cb_url) {\n  const auto encoded_client_id = Http::Utility::PercentEncoding::encode(client_id, \":/=&?\");\n  const auto encoded_secret = Http::Utility::PercentEncoding::encode(secret, \":/=&?\");\n  const auto encoded_cb_url = Http::Utility::PercentEncoding::encode(cb_url, \":/=&?\");\n\n  Http::RequestMessagePtr request = createPostRequest();\n  const std::string body = fmt::format(GetAccessTokenBodyFormatString, auth_code, encoded_client_id,\n                                       encoded_secret, encoded_cb_url);\n  request->body().add(body);\n  request->headers().setContentLength(body.length());\n  ENVOY_LOG(debug, \"Dispatching OAuth request for access token.\");\n  dispatchRequest(std::move(request));\n\n  ASSERT(state_ == OAuthState::Idle);\n  state_ = OAuthState::PendingAccessToken;\n}\n\nvoid OAuth2ClientImpl::dispatchRequest(Http::RequestMessagePtr&& msg) {\n  const auto thread_local_cluster = cm_.getThreadLocalCluster(uri_.cluster());\n  if (thread_local_cluster != nullptr) {\n    in_flight_request_ = thread_local_cluster->httpAsyncClient().send(\n        std::move(msg), *this,\n        Http::AsyncClient::RequestOptions().setTimeout(\n            std::chrono::milliseconds(PROTOBUF_GET_MS_REQUIRED(uri_, timeout))));\n  } else {\n    parent_->sendUnauthorizedResponse();\n  }\n}\n\nvoid OAuth2ClientImpl::onSuccess(const Http::AsyncClient::Request&,\n                                 Http::ResponseMessagePtr&& message) {\n  in_flight_request_ = nullptr;\n\n  ASSERT(state_ == OAuthState::PendingAccessToken);\n  state_ = OAuthState::Idle;\n\n  // Check that the auth cluster returned a happy response.\n  const auto response_code = message->headers().Status()->value().getStringView();\n  if (response_code != \"200\") {\n    ENVOY_LOG(debug, \"Oauth response code: {}\", response_code);\n    ENVOY_LOG(debug, \"Oauth response body: {}\", message->bodyAsString());\n    parent_->sendUnauthorizedResponse();\n    return;\n  }\n\n  const std::string response_body = message->bodyAsString();\n\n  envoy::extensions::http_filters::oauth2::OAuthResponse response;\n  try {\n    MessageUtil::loadFromJson(response_body, response, ProtobufMessage::getNullValidationVisitor());\n  } catch (EnvoyException& e) {\n    ENVOY_LOG(debug, \"Error parsing response body, received exception: {}\", e.what());\n    ENVOY_LOG(debug, \"Response body: {}\", response_body);\n    parent_->sendUnauthorizedResponse();\n    return;\n  }\n\n  // TODO(snowp): Should this be a pgv validation instead? A more readable log\n  // message might be good enough reason to do this manually?\n  if (!response.has_access_token() || !response.has_expires_in()) {\n    ENVOY_LOG(debug, \"No access token or expiration after asyncGetAccessToken\");\n    parent_->sendUnauthorizedResponse();\n    return;\n  }\n\n  const std::string access_token{PROTOBUF_GET_WRAPPED_REQUIRED(response, access_token)};\n  const std::string id_token{PROTOBUF_GET_WRAPPED_OR_DEFAULT(response, id_token, EMPTY_STRING)};\n  const std::string refresh_token{\n      PROTOBUF_GET_WRAPPED_OR_DEFAULT(response, refresh_token, EMPTY_STRING)};\n  const std::chrono::seconds expires_in{PROTOBUF_GET_WRAPPED_REQUIRED(response, expires_in)};\n\n  parent_->onGetAccessTokenSuccess(access_token, id_token, refresh_token, expires_in);\n}\n\nvoid OAuth2ClientImpl::onFailure(const Http::AsyncClient::Request&,\n                                 Http::AsyncClient::FailureReason) {\n  ENVOY_LOG(debug, \"OAuth request failed.\");\n  in_flight_request_ = nullptr;\n  parent_->sendUnauthorizedResponse();\n}\n\n} // namespace Oauth2\n} // namespace HttpFilters\n} // namespace Extensions\n} // namespace Envoy\n", "#include <memory>\n#include <string>\n\n#include \"envoy/extensions/filters/http/oauth2/v3/oauth.pb.h\"\n#include \"envoy/extensions/filters/http/oauth2/v3/oauth.pb.validate.h\"\n#include \"envoy/http/async_client.h\"\n#include \"envoy/http/message.h\"\n\n#include \"source/common/common/macros.h\"\n#include \"source/common/http/message_impl.h\"\n#include \"source/common/protobuf/message_validator_impl.h\"\n#include \"source/common/protobuf/utility.h\"\n#include \"source/common/secret/secret_manager_impl.h\"\n#include \"source/extensions/filters/http/oauth2/filter.h\"\n\n#include \"test/mocks/http/mocks.h\"\n#include \"test/mocks/server/mocks.h\"\n#include \"test/mocks/upstream/mocks.h\"\n#include \"test/test_common/utility.h\"\n\n#include \"gmock/gmock.h\"\n#include \"gtest/gtest.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace HttpFilters {\nnamespace Oauth2 {\n\nusing testing::_;\nusing testing::NiceMock;\nusing testing::Return;\nusing testing::ReturnRef;\n\nstatic const std::string TEST_CALLBACK = \"/_oauth\";\nstatic const std::string TEST_CLIENT_ID = \"1\";\nstatic const std::string TEST_CLIENT_SECRET_ID = \"MyClientSecretKnoxID\";\nstatic const std::string TEST_TOKEN_SECRET_ID = \"MyTokenSecretKnoxID\";\nstatic const std::string TEST_DEFAULT_SCOPE = \"user\";\nstatic const std::string TEST_ENCODED_AUTH_SCOPES = \"user%20openid%20email\";\n\nnamespace {\nHttp::RegisterCustomInlineHeader<Http::CustomInlineHeaderRegistry::Type::RequestHeaders>\n    authorization_handle(Http::CustomHeaders::get().Authorization);\n}\n\nclass MockSecretReader : public SecretReader {\npublic:\n  const std::string& clientSecret() const override {\n    CONSTRUCT_ON_FIRST_USE(std::string, \"asdf_client_secret_fdsa\");\n  }\n  const std::string& tokenSecret() const override {\n    CONSTRUCT_ON_FIRST_USE(std::string, \"asdf_token_secret_fdsa\");\n  }\n};\n\nclass MockOAuth2CookieValidator : public CookieValidator {\npublic:\n  MOCK_METHOD(std::string&, username, (), (const));\n  MOCK_METHOD(std::string&, token, (), (const));\n  MOCK_METHOD(bool, isValid, (), (const));\n  MOCK_METHOD(void, setParams, (const Http::RequestHeaderMap& headers, const std::string& secret));\n};\n\nclass MockOAuth2Client : public OAuth2Client {\npublic:\n  void onSuccess(const Http::AsyncClient::Request&, Http::ResponseMessagePtr&&) override {}\n  void onFailure(const Http::AsyncClient::Request&, Http::AsyncClient::FailureReason) override {}\n  void setCallbacks(FilterCallbacks&) override {}\n  void onBeforeFinalizeUpstreamSpan(Envoy::Tracing::Span&,\n                                    const Http::ResponseHeaderMap*) override {}\n\n  MOCK_METHOD(void, asyncGetAccessToken,\n              (const std::string&, const std::string&, const std::string&, const std::string&));\n};\n\nclass OAuth2Test : public testing::Test {\npublic:\n  OAuth2Test() : request_(&cm_.thread_local_cluster_.async_client_) {\n    factory_context_.cluster_manager_.initializeClusters({\"auth.example.com\"}, {});\n    init();\n  }\n\n  void init() { init(getConfig()); }\n\n  void init(FilterConfigSharedPtr config) {\n    // Set up the OAuth client.\n    oauth_client_ = new MockOAuth2Client();\n    std::unique_ptr<OAuth2Client> oauth_client_ptr{oauth_client_};\n\n    config_ = config;\n    filter_ = std::make_shared<OAuth2Filter>(config_, std::move(oauth_client_ptr), test_time_);\n    filter_->setDecoderFilterCallbacks(decoder_callbacks_);\n    validator_ = std::make_shared<MockOAuth2CookieValidator>();\n    filter_->validator_ = validator_;\n  }\n\n  // Set up proto fields with standard config.\n  FilterConfigSharedPtr getConfig(bool forward_bearer_token = true) {\n    envoy::extensions::filters::http::oauth2::v3::OAuth2Config p;\n    auto* endpoint = p.mutable_token_endpoint();\n    endpoint->set_cluster(\"auth.example.com\");\n    endpoint->set_uri(\"auth.example.com/_oauth\");\n    endpoint->mutable_timeout()->set_seconds(1);\n    p.set_redirect_uri(\"%REQ(:scheme)%://%REQ(:authority)%\" + TEST_CALLBACK);\n    p.mutable_redirect_path_matcher()->mutable_path()->set_exact(TEST_CALLBACK);\n    p.set_authorization_endpoint(\"https://auth.example.com/oauth/authorize/\");\n    p.mutable_signout_path()->mutable_path()->set_exact(\"/_signout\");\n    p.set_forward_bearer_token(forward_bearer_token);\n    p.add_auth_scopes(\"user\");\n    p.add_auth_scopes(\"openid\");\n    p.add_auth_scopes(\"email\");\n    p.add_resources(\"oauth2-resource\");\n    p.add_resources(\"http://example.com\");\n    p.add_resources(\"https://example.com\");\n    auto* matcher = p.add_pass_through_matcher();\n    matcher->set_name(\":method\");\n    matcher->mutable_string_match()->set_exact(\"OPTIONS\");\n    auto credentials = p.mutable_credentials();\n    credentials->set_client_id(TEST_CLIENT_ID);\n    credentials->mutable_token_secret()->set_name(\"secret\");\n    credentials->mutable_hmac_secret()->set_name(\"hmac\");\n    // Skipping setting credentials.cookie_names field should give default cookie names:\n    // BearerToken, OauthHMAC, and OauthExpires.\n\n    MessageUtil::validate(p, ProtobufMessage::getStrictValidationVisitor());\n\n    // Create filter config.\n    auto secret_reader = std::make_shared<MockSecretReader>();\n    FilterConfigSharedPtr c = std::make_shared<FilterConfig>(p, factory_context_.cluster_manager_,\n                                                             secret_reader, scope_, \"test.\");\n\n    return c;\n  }\n\n  Http::AsyncClient::Callbacks* popPendingCallback() {\n    if (callbacks_.empty()) {\n      // Can't use ASSERT_* as this is not a test function\n      throw std::underflow_error(\"empty deque\");\n    }\n\n    auto callbacks = callbacks_.front();\n    callbacks_.pop_front();\n    return callbacks;\n  }\n\n  // Validates the behavior of the cookie validator.\n  void expectValidCookies(const CookieNames& cookie_names) {\n    // Set SystemTime to a fixed point so we get consistent HMAC encodings between test runs.\n    test_time_.setSystemTime(SystemTime(std::chrono::seconds(0)));\n\n    const auto expires_at_s = DateUtil::nowToSeconds(test_time_.timeSystem()) + 10;\n\n    Http::TestRequestHeaderMapImpl request_headers{\n        {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n        {Http::Headers::get().Path.get(), \"/anypath\"},\n        {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n        {Http::Headers::get().Cookie.get(),\n         fmt::format(\"{}={};version=test\", cookie_names.oauth_expires_, expires_at_s)},\n        {Http::Headers::get().Cookie.get(),\n         absl::StrCat(cookie_names.bearer_token_, \"=xyztoken;version=test\")},\n        {Http::Headers::get().Cookie.get(),\n         absl::StrCat(cookie_names.oauth_hmac_, \"=\"\n                                                \"NGQ3MzVjZGExNGM5NTFiZGJjODBkMjBmYjAyYjNiOTFjMmNjYj\"\n                                                \"IxMTUzNmNiNWU0NjQzMmMxMWUzZmE2ZWJjYg==\"\n                                                \";version=test\")},\n    };\n\n    auto cookie_validator = std::make_shared<OAuth2CookieValidator>(test_time_, cookie_names);\n    EXPECT_EQ(cookie_validator->token(), \"\");\n    cookie_validator->setParams(request_headers, \"mock-secret\");\n\n    EXPECT_TRUE(cookie_validator->hmacIsValid());\n    EXPECT_TRUE(cookie_validator->timestampIsValid());\n    EXPECT_TRUE(cookie_validator->isValid());\n\n    // If we advance time beyond 10s the timestamp should no longer be valid.\n    test_time_.advanceTimeWait(std::chrono::seconds(11));\n\n    EXPECT_FALSE(cookie_validator->timestampIsValid());\n    EXPECT_FALSE(cookie_validator->isValid());\n  }\n\n  NiceMock<Event::MockTimer>* attachmentTimeout_timer_{};\n  NiceMock<Server::Configuration::MockFactoryContext> factory_context_;\n  NiceMock<Http::MockStreamDecoderFilterCallbacks> decoder_callbacks_;\n  NiceMock<Upstream::MockClusterManager> cm_;\n  std::shared_ptr<MockOAuth2CookieValidator> validator_;\n  std::shared_ptr<OAuth2Filter> filter_;\n  MockOAuth2Client* oauth_client_;\n  FilterConfigSharedPtr config_;\n  Http::MockAsyncClientRequest request_;\n  std::deque<Http::AsyncClient::Callbacks*> callbacks_;\n  Stats::IsolatedStoreImpl scope_;\n  Event::SimulatedTimeSystem test_time_;\n};\n\n// Verifies that the OAuth SDSSecretReader correctly updates dynamic generic secret.\nTEST_F(OAuth2Test, SdsDynamicGenericSecret) {\n  NiceMock<Server::MockConfigTracker> config_tracker;\n  Secret::SecretManagerImpl secret_manager{config_tracker};\n  envoy::config::core::v3::ConfigSource config_source;\n\n  NiceMock<Server::Configuration::MockTransportSocketFactoryContext> secret_context;\n  NiceMock<LocalInfo::MockLocalInfo> local_info;\n  Api::ApiPtr api = Api::createApiForTest();\n  Stats::IsolatedStoreImpl stats;\n  NiceMock<Init::MockManager> init_manager;\n  Init::TargetHandlePtr init_handle;\n  NiceMock<Event::MockDispatcher> dispatcher;\n  EXPECT_CALL(secret_context, localInfo()).WillRepeatedly(ReturnRef(local_info));\n  EXPECT_CALL(secret_context, api()).WillRepeatedly(ReturnRef(*api));\n  EXPECT_CALL(secret_context, mainThreadDispatcher()).WillRepeatedly(ReturnRef(dispatcher));\n  EXPECT_CALL(secret_context, stats()).WillRepeatedly(ReturnRef(stats));\n  EXPECT_CALL(secret_context, initManager()).WillRepeatedly(ReturnRef(init_manager));\n  EXPECT_CALL(init_manager, add(_))\n      .WillRepeatedly(Invoke([&init_handle](const Init::Target& target) {\n        init_handle = target.createHandle(\"test\");\n      }));\n\n  auto client_secret_provider =\n      secret_manager.findOrCreateGenericSecretProvider(config_source, \"client\", secret_context);\n  auto client_callback = secret_context.cluster_manager_.subscription_factory_.callbacks_;\n  auto token_secret_provider =\n      secret_manager.findOrCreateGenericSecretProvider(config_source, \"token\", secret_context);\n  auto token_callback = secret_context.cluster_manager_.subscription_factory_.callbacks_;\n\n  SDSSecretReader secret_reader(client_secret_provider, token_secret_provider, *api);\n  EXPECT_TRUE(secret_reader.clientSecret().empty());\n  EXPECT_TRUE(secret_reader.tokenSecret().empty());\n\n  const std::string yaml_client = R\"EOF(\nname: client\ngeneric_secret:\n  secret:\n    inline_string: \"client_test\"\n)EOF\";\n\n  envoy::extensions::transport_sockets::tls::v3::Secret typed_secret;\n  TestUtility::loadFromYaml(yaml_client, typed_secret);\n  const auto decoded_resources_client = TestUtility::decodeResources({typed_secret});\n\n  client_callback->onConfigUpdate(decoded_resources_client.refvec_, \"\");\n  EXPECT_EQ(secret_reader.clientSecret(), \"client_test\");\n  EXPECT_EQ(secret_reader.tokenSecret(), \"\");\n\n  const std::string yaml_token = R\"EOF(\nname: token\ngeneric_secret:\n  secret:\n    inline_string: \"token_test\"\n)EOF\";\n  TestUtility::loadFromYaml(yaml_token, typed_secret);\n  const auto decoded_resources_token = TestUtility::decodeResources({typed_secret});\n\n  token_callback->onConfigUpdate(decoded_resources_token.refvec_, \"\");\n  EXPECT_EQ(secret_reader.clientSecret(), \"client_test\");\n  EXPECT_EQ(secret_reader.tokenSecret(), \"token_test\");\n\n  const std::string yaml_client_recheck = R\"EOF(\nname: client\ngeneric_secret:\n  secret:\n    inline_string: \"client_test_recheck\"\n)EOF\";\n  TestUtility::loadFromYaml(yaml_client_recheck, typed_secret);\n  const auto decoded_resources_client_recheck = TestUtility::decodeResources({typed_secret});\n\n  client_callback->onConfigUpdate(decoded_resources_client_recheck.refvec_, \"\");\n  EXPECT_EQ(secret_reader.clientSecret(), \"client_test_recheck\");\n  EXPECT_EQ(secret_reader.tokenSecret(), \"token_test\");\n}\n// Verifies that we fail constructing the filter if the configured cluster doesn't exist.\nTEST_F(OAuth2Test, InvalidCluster) {\n  ON_CALL(factory_context_.cluster_manager_, clusters())\n      .WillByDefault(Return(Upstream::ClusterManager::ClusterInfoMaps()));\n\n  EXPECT_THROW_WITH_MESSAGE(init(), EnvoyException,\n                            \"OAuth2 filter: unknown cluster 'auth.example.com' in config. Please \"\n                            \"specify which cluster to direct OAuth requests to.\");\n}\n\n// Verifies that the OAuth config is created with a default value for auth_scopes field when it is\n// not set in proto/yaml.\nTEST_F(OAuth2Test, DefaultAuthScope) {\n\n  // Set up proto fields with no auth scope set.\n  envoy::extensions::filters::http::oauth2::v3::OAuth2Config p;\n  auto* endpoint = p.mutable_token_endpoint();\n  endpoint->set_cluster(\"auth.example.com\");\n  endpoint->set_uri(\"auth.example.com/_oauth\");\n  endpoint->mutable_timeout()->set_seconds(1);\n  p.set_redirect_uri(\"%REQ(:scheme)%://%REQ(:authority)%\" + TEST_CALLBACK);\n  p.mutable_redirect_path_matcher()->mutable_path()->set_exact(TEST_CALLBACK);\n  p.set_authorization_endpoint(\"https://auth.example.com/oauth/authorize/\");\n  p.mutable_signout_path()->mutable_path()->set_exact(\"/_signout\");\n  p.set_forward_bearer_token(true);\n  auto* matcher = p.add_pass_through_matcher();\n  matcher->set_name(\":method\");\n  matcher->mutable_string_match()->set_exact(\"OPTIONS\");\n\n  auto credentials = p.mutable_credentials();\n  credentials->set_client_id(TEST_CLIENT_ID);\n  credentials->mutable_token_secret()->set_name(\"secret\");\n  credentials->mutable_hmac_secret()->set_name(\"hmac\");\n\n  MessageUtil::validate(p, ProtobufMessage::getStrictValidationVisitor());\n\n  // Create the OAuth config.\n  auto secret_reader = std::make_shared<MockSecretReader>();\n  FilterConfigSharedPtr test_config_;\n  test_config_ = std::make_shared<FilterConfig>(p, factory_context_.cluster_manager_, secret_reader,\n                                                scope_, \"test.\");\n\n  // Auth_scopes was not set, should return default value.\n  EXPECT_EQ(test_config_->encodedAuthScopes(), TEST_DEFAULT_SCOPE);\n\n  // resource is optional\n  EXPECT_EQ(test_config_->encodedResourceQueryParams(), \"\");\n\n  // Recreate the filter with current config and test if the scope was added\n  // as a query parameter in response headers.\n  init(test_config_);\n  Http::TestRequestHeaderMapImpl request_headers{\n      {Http::Headers::get().Path.get(), \"/not/_oauth\"},\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n      {Http::Headers::get().Scheme.get(), \"http\"},\n  };\n\n  Http::TestResponseHeaderMapImpl response_headers{\n      {Http::Headers::get().Status.get(), \"302\"},\n      {Http::Headers::get().Location.get(),\n       \"https://auth.example.com/oauth/\"\n       \"authorize/?client_id=\" +\n           TEST_CLIENT_ID + \"&scope=\" + TEST_DEFAULT_SCOPE +\n           \"&response_type=code&\"\n           \"redirect_uri=http%3A%2F%2Ftraffic.example.com%2F\"\n           \"_oauth&state=http%3A%2F%2Ftraffic.example.com%2Fnot%2F_oauth\"},\n  };\n\n  // explicitly tell the validator to fail the validation.\n  EXPECT_CALL(*validator_, setParams(_, _));\n  EXPECT_CALL(*validator_, isValid()).WillOnce(Return(false));\n\n  EXPECT_CALL(decoder_callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), true));\n\n  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,\n            filter_->decodeHeaders(request_headers, false));\n}\n\n/**\n * Scenario: The OAuth filter receives a sign out request.\n *\n * Expected behavior: the filter should redirect to the server name with cleared OAuth cookies.\n */\nTEST_F(OAuth2Test, RequestSignout) {\n  Http::TestRequestHeaderMapImpl request_headers{\n      {Http::Headers::get().Path.get(), \"/_signout\"},\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n      {Http::Headers::get().Scheme.get(), \"https\"},\n  };\n\n  Http::TestResponseHeaderMapImpl response_headers{\n      {Http::Headers::get().Status.get(), \"302\"},\n      {Http::Headers::get().SetCookie.get(),\n       \"OauthHMAC=deleted; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT\"},\n      {Http::Headers::get().SetCookie.get(),\n       \"BearerToken=deleted; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT\"},\n      {Http::Headers::get().SetCookie.get(),\n       \"IdToken=deleted; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT\"},\n      {Http::Headers::get().SetCookie.get(),\n       \"RefreshToken=deleted; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT\"},\n      {Http::Headers::get().Location.get(), \"https://traffic.example.com/\"},\n  };\n  EXPECT_CALL(decoder_callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), true));\n\n  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,\n            filter_->decodeHeaders(request_headers, false));\n}\n\n/**\n * Scenario: The OAuth filter receives a request to an arbitrary path with valid OAuth cookies\n * (cookie values and validation are mocked out)\n * In a real flow, the injected OAuth headers should be sanitized and replaced with legitimate\n * values.\n *\n * Expected behavior: the filter should let the request proceed, and sanitize the injected headers.\n */\nTEST_F(OAuth2Test, OAuthOkPass) {\n  Http::TestRequestHeaderMapImpl mock_request_headers{\n      {Http::Headers::get().Path.get(), \"/anypath\"},\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n      {Http::Headers::get().Scheme.get(), \"https\"},\n      {Http::CustomHeaders::get().Authorization.get(), \"Bearer injected_malice!\"},\n  };\n\n  Http::TestRequestHeaderMapImpl expected_headers{\n      {Http::Headers::get().Path.get(), \"/anypath\"},\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n      {Http::Headers::get().Scheme.get(), \"https\"},\n      {Http::CustomHeaders::get().Authorization.get(), \"Bearer legit_token\"},\n  };\n\n  // cookie-validation mocking\n  EXPECT_CALL(*validator_, setParams(_, _));\n  EXPECT_CALL(*validator_, isValid()).WillOnce(Return(true));\n\n  // Sanitized return reference mocking\n  std::string legit_token{\"legit_token\"};\n  EXPECT_CALL(*validator_, token()).WillRepeatedly(ReturnRef(legit_token));\n\n  EXPECT_EQ(Http::FilterHeadersStatus::Continue,\n            filter_->decodeHeaders(mock_request_headers, false));\n\n  // Ensure that existing OAuth forwarded headers got sanitized.\n  EXPECT_EQ(mock_request_headers, expected_headers);\n\n  EXPECT_EQ(scope_.counterFromString(\"test.oauth_failure\").value(), 0);\n  EXPECT_EQ(scope_.counterFromString(\"test.oauth_success\").value(), 1);\n}\n\n/**\n * Scenario: The OAuth filter receives a request to an arbitrary path with valid OAuth cookies\n * (cookie values and validation are mocked out), but with an invalid token in the Authorization\n * header and forwarding bearer token is disabled.\n *\n * Expected behavior: the filter should sanitize the Authorization header and let the request\n * proceed.\n */\nTEST_F(OAuth2Test, OAuthOkPassButInvalidToken) {\n  init(getConfig(false /* forward_bearer_token */));\n\n  Http::TestRequestHeaderMapImpl mock_request_headers{\n      {Http::Headers::get().Path.get(), \"/anypath\"},\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n      {Http::Headers::get().Scheme.get(), \"https\"},\n      {Http::CustomHeaders::get().Authorization.get(), \"Bearer injected_malice!\"},\n  };\n\n  Http::TestRequestHeaderMapImpl expected_headers{\n      {Http::Headers::get().Path.get(), \"/anypath\"},\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n      {Http::Headers::get().Scheme.get(), \"https\"},\n  };\n\n  // cookie-validation mocking\n  EXPECT_CALL(*validator_, setParams(_, _));\n  EXPECT_CALL(*validator_, isValid()).WillOnce(Return(true));\n\n  // Sanitized return reference mocking\n  std::string legit_token{\"legit_token\"};\n  EXPECT_CALL(*validator_, token()).WillRepeatedly(ReturnRef(legit_token));\n\n  EXPECT_EQ(Http::FilterHeadersStatus::Continue,\n            filter_->decodeHeaders(mock_request_headers, false));\n\n  // Ensure that existing OAuth forwarded headers got sanitized.\n  EXPECT_EQ(mock_request_headers, expected_headers);\n\n  EXPECT_EQ(scope_.counterFromString(\"test.oauth_failure\").value(), 0);\n  EXPECT_EQ(scope_.counterFromString(\"test.oauth_success\").value(), 1);\n}\n\n/**\n * Scenario: The OAuth filter receives a request without valid OAuth cookies to a non-callback URL\n * (indicating that the user needs to re-validate cookies or get 401'd).\n * This also tests both a forwarded http protocol from upstream and a plaintext connection.\n *\n * Expected behavior: the filter should redirect the user to the OAuth server with the credentials\n * in the query parameters.\n */\nTEST_F(OAuth2Test, OAuthErrorNonOAuthHttpCallback) {\n  Http::TestRequestHeaderMapImpl request_headers{\n      {Http::Headers::get().Path.get(), \"/not/_oauth\"},\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n      {Http::Headers::get().Scheme.get(), \"http\"},\n  };\n\n  Http::TestResponseHeaderMapImpl response_headers{\n      {Http::Headers::get().Status.get(), \"302\"},\n      {Http::Headers::get().Location.get(),\n       \"https://auth.example.com/oauth/\"\n       \"authorize/?client_id=\" +\n           TEST_CLIENT_ID + \"&scope=\" + TEST_ENCODED_AUTH_SCOPES +\n           \"&response_type=code&\"\n           \"redirect_uri=http%3A%2F%2Ftraffic.example.com%2F\"\n           \"_oauth&state=http%3A%2F%2Ftraffic.example.com%2Fnot%2F_oauth\"\n           \"&resource=oauth2-resource&resource=http%3A%2F%2Fexample.com\"\n           \"&resource=https%3A%2F%2Fexample.com\"},\n  };\n\n  // explicitly tell the validator to fail the validation\n  EXPECT_CALL(*validator_, setParams(_, _));\n  EXPECT_CALL(*validator_, isValid()).WillOnce(Return(false));\n\n  EXPECT_CALL(decoder_callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), true));\n\n  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,\n            filter_->decodeHeaders(request_headers, false));\n}\n\n/**\n * Scenario: The OAuth filter receives a callback request with an error code\n */\nTEST_F(OAuth2Test, OAuthErrorQueryString) {\n  Http::TestRequestHeaderMapImpl request_headers{\n      {Http::Headers::get().Path.get(), \"/_oauth?error=someerrorcode\"},\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n  };\n\n  Http::TestResponseHeaderMapImpl response_headers{\n      {Http::Headers::get().Status.get(), \"401\"},\n      {Http::Headers::get().ContentLength.get(), \"18\"}, // unauthorizedBodyMessage()\n      {Http::Headers::get().ContentType.get(), \"text/plain\"},\n  };\n\n  EXPECT_CALL(*validator_, setParams(_, _));\n  EXPECT_CALL(*validator_, isValid()).WillOnce(Return(false));\n\n  EXPECT_CALL(decoder_callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), false));\n  EXPECT_CALL(decoder_callbacks_, encodeData(_, true));\n\n  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,\n            filter_->decodeHeaders(request_headers, false));\n\n  EXPECT_EQ(scope_.counterFromString(\"test.oauth_failure\").value(), 1);\n  EXPECT_EQ(scope_.counterFromString(\"test.oauth_success\").value(), 0);\n}\n\n/**\n * Scenario: The OAuth filter requests credentials from auth.example.com which returns a\n * response without expires_in (JSON response is mocked out)\n *\n * Expected behavior: the filter should return a 401 directly to the user.\n */\nTEST_F(OAuth2Test, OAuthCallbackStartsAuthentication) {\n  Http::TestRequestHeaderMapImpl request_headers{\n      {Http::Headers::get().Path.get(), \"/_oauth?code=123&state=https://asdf&method=GET\"},\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Scheme.get(), \"https\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n  };\n\n  // Deliberately fail the HMAC Validation check.\n  EXPECT_CALL(*validator_, setParams(_, _));\n  EXPECT_CALL(*validator_, isValid()).WillOnce(Return(false));\n\n  EXPECT_CALL(*oauth_client_, asyncGetAccessToken(\"123\", TEST_CLIENT_ID, \"asdf_client_secret_fdsa\",\n                                                  \"https://traffic.example.com\" + TEST_CALLBACK));\n\n  EXPECT_EQ(Http::FilterHeadersStatus::StopAllIterationAndBuffer,\n            filter_->decodeHeaders(request_headers, false));\n}\n\n/**\n * Scenario: Protoc in opted-in to allow OPTIONS requests to pass-through. This is important as\n * POST requests initiate an OPTIONS request first in order to ensure POST is supported. During a\n * preflight request where the client Javascript initiates a remote call to a different endpoint,\n * we don't want to fail the call immediately due to browser restrictions, and use existing\n * cookies instead (OPTIONS requests do not send OAuth cookies.)\n */\nTEST_F(OAuth2Test, OAuthOptionsRequestAndContinue) {\n  Http::TestRequestHeaderMapImpl request_headers{\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Path.get(), \"/anypath\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Options},\n  };\n\n  EXPECT_CALL(*validator_, setParams(_, _));\n  EXPECT_CALL(*validator_, isValid()).WillOnce(Return(false));\n  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->decodeHeaders(request_headers, false));\n}\n\n// Validates the behavior of the cookie validator.\nTEST_F(OAuth2Test, CookieValidator) {\n  expectValidCookies(CookieNames{\"BearerToken\", \"OauthHMAC\", \"OauthExpires\"});\n}\n\n// Validates the behavior of the cookie validator with custom cookie names.\nTEST_F(OAuth2Test, CookieValidatorWithCustomNames) {\n  expectValidCookies(CookieNames{\"CustomBearerToken\", \"CustomOauthHMAC\", \"CustomOauthExpires\"});\n}\n\n// Validates the behavior of the cookie validator when the expires_at value is not a valid integer.\nTEST_F(OAuth2Test, CookieValidatorInvalidExpiresAt) {\n  Http::TestRequestHeaderMapImpl request_headers{\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Path.get(), \"/anypath\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n      {Http::Headers::get().Cookie.get(), \"OauthExpires=notanumber;version=test\"},\n      {Http::Headers::get().Cookie.get(), \"BearerToken=xyztoken;version=test\"},\n      {Http::Headers::get().Cookie.get(),\n       \"OauthHMAC=\"\n       \"M2NjZmIxYWE0NzQzOGZlZTJjMjQwMzBiZTU5OTdkN2Y0NDRhZjE5MjZiOWNhY2YzNjM0MWRmMTNkMDVmZWFlOQ==\"\n       \";version=test\"},\n  };\n\n  auto cookie_validator = std::make_shared<OAuth2CookieValidator>(\n      test_time_, CookieNames{\"BearerToken\", \"OauthHMAC\", \"OauthExpires\"});\n  cookie_validator->setParams(request_headers, \"mock-secret\");\n\n  EXPECT_TRUE(cookie_validator->hmacIsValid());\n  EXPECT_FALSE(cookie_validator->timestampIsValid());\n  EXPECT_FALSE(cookie_validator->isValid());\n}\n\n// Verify that we 401 the request if the state query param doesn't contain a valid URL.\nTEST_F(OAuth2Test, OAuthTestInvalidUrlInStateQueryParam) {\n  Http::TestRequestHeaderMapImpl request_headers{\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n      {Http::Headers::get().Path.get(),\n       \"/_oauth?code=abcdefxyz123&scope=\" + TEST_ENCODED_AUTH_SCOPES + \"&state=blah\"},\n      {Http::Headers::get().Cookie.get(), \"OauthExpires=123;version=test\"},\n      {Http::Headers::get().Cookie.get(), \"BearerToken=legit_token;version=test\"},\n      {Http::Headers::get().Cookie.get(),\n       \"OauthHMAC=\"\n       \"ZTRlMzU5N2Q4ZDIwZWE5ZTU5NTg3YTU3YTcxZTU0NDFkMzY1ZTc1NjMyODYyMj\"\n       \"RlNjMxZTJmNTZkYzRmZTM0ZQ====;version=test\"},\n  };\n\n  Http::TestRequestHeaderMapImpl expected_headers{\n      {Http::Headers::get().Status.get(), \"401\"},\n      {Http::Headers::get().ContentLength.get(), \"18\"},\n      {Http::Headers::get().ContentType.get(), \"text/plain\"},\n      // Invalid URL: we inject a few : in the middle of the URL.\n  };\n\n  // Succeed the HMAC validation.\n  EXPECT_CALL(*validator_, setParams(_, _));\n  EXPECT_CALL(*validator_, isValid()).WillOnce(Return(true));\n\n  std::string legit_token{\"legit_token\"};\n  EXPECT_CALL(*validator_, token()).WillRepeatedly(ReturnRef(legit_token));\n\n  EXPECT_CALL(decoder_callbacks_, encodeHeaders_(HeaderMapEqualRef(&expected_headers), false));\n  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,\n            filter_->decodeHeaders(request_headers, false));\n}\n\n// Verify that we 401 the request if the state query param contains the callback URL.\nTEST_F(OAuth2Test, OAuthTestCallbackUrlInStateQueryParam) {\n  Http::TestRequestHeaderMapImpl request_headers{\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n      {Http::Headers::get().Path.get(),\n       \"/_oauth?code=abcdefxyz123&scope=\" + TEST_ENCODED_AUTH_SCOPES +\n           \"&state=https%3A%2F%2Ftraffic.example.com%2F_oauth\"},\n\n      {Http::Headers::get().Cookie.get(), \"OauthExpires=123;version=test\"},\n      {Http::Headers::get().Cookie.get(), \"BearerToken=legit_token;version=test\"},\n      {Http::Headers::get().Cookie.get(),\n       \"OauthHMAC=\"\n       \"ZTRlMzU5N2Q4ZDIwZWE5ZTU5NTg3YTU3YTcxZTU0NDFkMzY1ZTc1NjMyODYyMj\"\n       \"RlNjMxZTJmNTZkYzRmZTM0ZQ====;version=test\"},\n  };\n\n  Http::TestRequestHeaderMapImpl expected_response_headers{\n      {Http::Headers::get().Status.get(), \"401\"},\n      {Http::Headers::get().ContentLength.get(), \"18\"},\n      {Http::Headers::get().ContentType.get(), \"text/plain\"},\n  };\n\n  // Succeed the HMAC validation.\n  EXPECT_CALL(*validator_, setParams(_, _));\n  EXPECT_CALL(*validator_, isValid()).WillOnce(Return(true));\n\n  std::string legit_token{\"legit_token\"};\n  EXPECT_CALL(*validator_, token()).WillRepeatedly(ReturnRef(legit_token));\n\n  EXPECT_CALL(decoder_callbacks_,\n              encodeHeaders_(HeaderMapEqualRef(&expected_response_headers), false));\n  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,\n            filter_->decodeHeaders(request_headers, false));\n\n  Http::TestRequestHeaderMapImpl final_request_headers{\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n      {Http::Headers::get().Path.get(),\n       \"/_oauth?code=abcdefxyz123&scope=\" + TEST_ENCODED_AUTH_SCOPES +\n           \"&state=https%3A%2F%2Ftraffic.example.com%2F_oauth\"},\n      {Http::Headers::get().Cookie.get(), \"OauthExpires=123;version=test\"},\n      {Http::Headers::get().Cookie.get(), \"BearerToken=legit_token;version=test\"},\n      {Http::Headers::get().Cookie.get(),\n       \"OauthHMAC=\"\n       \"ZTRlMzU5N2Q4ZDIwZWE5ZTU5NTg3YTU3YTcxZTU0NDFkMzY1ZTc1NjMyODYyMj\"\n       \"RlNjMxZTJmNTZkYzRmZTM0ZQ====;version=test\"},\n      {Http::CustomHeaders::get().Authorization.get(), \"Bearer legit_token\"},\n  };\n\n  EXPECT_EQ(request_headers, final_request_headers);\n}\n\n/**\n * Testing the Path header replacement after an OAuth success.\n *\n * Expected behavior: the passed in HeaderMap should pass the OAuth flow, but since it's during\n * a callback from the authentication server, we should first parse out the state query string\n * parameter and set it to be the new path.\n */\nTEST_F(OAuth2Test, OAuthTestUpdatePathAfterSuccess) {\n  Http::TestRequestHeaderMapImpl request_headers{\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n      {Http::Headers::get().Path.get(),\n       \"/_oauth?code=abcdefxyz123&scope=\" + TEST_ENCODED_AUTH_SCOPES +\n           \"&state=https%3A%2F%2Ftraffic.example.com%2Foriginal_path\"},\n      {Http::Headers::get().Cookie.get(), \"OauthExpires=123;version=test\"},\n      {Http::Headers::get().Cookie.get(), \"BearerToken=legit_token;version=test\"},\n      {Http::Headers::get().Cookie.get(),\n       \"OauthHMAC=\"\n       \"ZTRlMzU5N2Q4ZDIwZWE5ZTU5NTg3YTU3YTcxZTU0NDFkMzY1ZTc1NjMyODYyMj\"\n       \"RlNjMxZTJmNTZkYzRmZTM0ZQ====;version=test\"},\n  };\n\n  Http::TestRequestHeaderMapImpl expected_response_headers{\n      {Http::Headers::get().Status.get(), \"302\"},\n      {Http::Headers::get().Location.get(), \"https://traffic.example.com/original_path\"},\n  };\n\n  // Succeed the HMAC validation.\n  EXPECT_CALL(*validator_, setParams(_, _));\n  EXPECT_CALL(*validator_, isValid()).WillOnce(Return(true));\n\n  std::string legit_token{\"legit_token\"};\n  EXPECT_CALL(*validator_, token()).WillRepeatedly(ReturnRef(legit_token));\n\n  EXPECT_CALL(decoder_callbacks_,\n              encodeHeaders_(HeaderMapEqualRef(&expected_response_headers), true));\n  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->decodeHeaders(request_headers, false));\n\n  Http::TestRequestHeaderMapImpl final_request_headers{\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n      {Http::Headers::get().Path.get(),\n       \"/_oauth?code=abcdefxyz123&scope=\" + TEST_ENCODED_AUTH_SCOPES +\n           \"&state=https%3A%2F%2Ftraffic.example.com%2Foriginal_path\"},\n      {Http::Headers::get().Cookie.get(), \"OauthExpires=123;version=test\"},\n      {Http::Headers::get().Cookie.get(), \"BearerToken=legit_token;version=test\"},\n      {Http::Headers::get().Cookie.get(),\n       \"OauthHMAC=\"\n       \"ZTRlMzU5N2Q4ZDIwZWE5ZTU5NTg3YTU3YTcxZTU0NDFkMzY1ZTc1NjMyODYyMj\"\n       \"RlNjMxZTJmNTZkYzRmZTM0ZQ====;version=test\"},\n      {Http::CustomHeaders::get().Authorization.get(), \"Bearer legit_token\"},\n  };\n\n  EXPECT_EQ(request_headers, final_request_headers);\n}\n\n/**\n * Testing oauth state with query string parameters.\n *\n * Expected behavior: HTTP Utility should not strip the parameters of the original request.\n */\nTEST_F(OAuth2Test, OAuthTestFullFlowPostWithParameters) {\n  // First construct the initial request to the oauth filter with URI parameters.\n  Http::TestRequestHeaderMapImpl first_request_headers{\n      {Http::Headers::get().Path.get(), \"/test?name=admin&level=trace\"},\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Post},\n      {Http::Headers::get().Scheme.get(), \"https\"},\n  };\n\n  // This is the immediate response - a redirect to the auth cluster.\n  Http::TestResponseHeaderMapImpl first_response_headers{\n      {Http::Headers::get().Status.get(), \"302\"},\n      {Http::Headers::get().Location.get(),\n       \"https://auth.example.com/oauth/\"\n       \"authorize/?client_id=\" +\n           TEST_CLIENT_ID + \"&scope=\" + TEST_ENCODED_AUTH_SCOPES +\n           \"&response_type=code&\"\n           \"redirect_uri=https%3A%2F%2Ftraffic.example.com%2F\"\n           \"_oauth&state=https%3A%2F%2Ftraffic.example.com%2Ftest%\"\n           \"3Fname%3Dadmin%26level%3Dtrace\"\n           \"&resource=oauth2-resource&resource=http%3A%2F%2Fexample.com\"\n           \"&resource=https%3A%2F%2Fexample.com\"},\n  };\n\n  // Fail the validation to trigger the OAuth flow.\n  EXPECT_CALL(*validator_, setParams(_, _));\n  EXPECT_CALL(*validator_, isValid()).WillOnce(Return(false));\n\n  // Check that the redirect includes the escaped parameter characters, '?', '&' and '='.\n  EXPECT_CALL(decoder_callbacks_, encodeHeaders_(HeaderMapEqualRef(&first_response_headers), true));\n\n  // This represents the beginning of the OAuth filter.\n  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,\n            filter_->decodeHeaders(first_request_headers, false));\n\n  // This represents the callback request from the authorization server.\n  Http::TestRequestHeaderMapImpl second_request_headers{\n      {Http::Headers::get().Path.get(), \"/_oauth?code=123&state=https%3A%2F%2Ftraffic.example.com%\"\n                                        \"2Ftest%3Fname%3Dadmin%26level%3Dtrace\"},\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n      {Http::Headers::get().Scheme.get(), \"https\"},\n  };\n\n  // Deliberately fail the HMAC validation check.\n  EXPECT_CALL(*validator_, setParams(_, _));\n  EXPECT_CALL(*validator_, isValid()).WillOnce(Return(false));\n\n  EXPECT_CALL(*oauth_client_, asyncGetAccessToken(\"123\", TEST_CLIENT_ID, \"asdf_client_secret_fdsa\",\n                                                  \"https://traffic.example.com\" + TEST_CALLBACK));\n\n  // Invoke the callback logic. As a side effect, state_ will be populated.\n  EXPECT_EQ(Http::FilterHeadersStatus::StopAllIterationAndBuffer,\n            filter_->decodeHeaders(second_request_headers, false));\n\n  EXPECT_EQ(1, config_->stats().oauth_unauthorized_rq_.value());\n  EXPECT_EQ(config_->clusterName(), \"auth.example.com\");\n\n  // Expected response after the callback & validation is complete - verifying we kept the\n  // state and method of the original request, including the query string parameters.\n  Http::TestRequestHeaderMapImpl second_response_headers{\n      {Http::Headers::get().Status.get(), \"302\"},\n      {Http::Headers::get().SetCookie.get(),\n       \"OauthHMAC=\"\n       \"NWUzNzE5MWQwYTg0ZjA2NjIyMjVjMzk3MzY3MzMyZmE0NjZmMWI2MjI1NWFhNDhkYjQ4NDFlZmRiMTVmMTk0MQ==;\"\n       \"version=1;path=/;Max-Age=;secure;HttpOnly\"},\n      {Http::Headers::get().SetCookie.get(),\n       \"OauthExpires=;version=1;path=/;Max-Age=;secure;HttpOnly\"},\n      {Http::Headers::get().SetCookie.get(), \"BearerToken=;version=1;path=/;Max-Age=;secure\"},\n      {Http::Headers::get().Location.get(),\n       \"https://traffic.example.com/test?name=admin&level=trace\"},\n  };\n\n  EXPECT_CALL(decoder_callbacks_,\n              encodeHeaders_(HeaderMapEqualRef(&second_response_headers), true));\n\n  filter_->finishFlow();\n}\n\nTEST_F(OAuth2Test, OAuthBearerTokenFlowFromHeader) {\n  Http::TestRequestHeaderMapImpl request_headers{\n      {Http::Headers::get().Path.get(), \"/test?role=bearer\"},\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n      {Http::Headers::get().Scheme.get(), \"https\"},\n      {Http::CustomHeaders::get().Authorization.get(), \"Bearer xyz-header-token\"},\n  };\n\n  // Fail the validation.\n  EXPECT_CALL(*validator_, setParams(_, _));\n  EXPECT_CALL(*validator_, isValid()).WillOnce(Return(false));\n\n  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,\n            filter_->decodeHeaders(request_headers, false));\n}\n\nTEST_F(OAuth2Test, OAuthBearerTokenFlowFromQueryParameters) {\n  Http::TestRequestHeaderMapImpl request_headers{\n      {Http::Headers::get().Path.get(), \"/test?role=bearer&token=xyz-queryparam-token\"},\n      {Http::Headers::get().Host.get(), \"traffic.example.com\"},\n      {Http::Headers::get().Method.get(), Http::Headers::get().MethodValues.Get},\n      {Http::Headers::get().Scheme.get(), \"https\"},\n  };\n\n  // Fail the validation.\n  EXPECT_CALL(*validator_, setParams(_, _));\n  EXPECT_CALL(*validator_, isValid()).WillOnce(Return(false));\n\n  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,\n            filter_->decodeHeaders(request_headers, false));\n}\n\n} // namespace Oauth2\n} // namespace HttpFilters\n} // namespace Extensions\n} // namespace Envoy\n"], "filenames": ["source/extensions/filters/http/oauth2/filter.cc", "source/extensions/filters/http/oauth2/filter.h", "source/extensions/filters/http/oauth2/oauth_client.cc", "test/extensions/filters/http/oauth2/filter_test.cc"], "buggy_code_start_loc": [206, 246, 24, 98], "buggy_code_end_loc": [513, 261, 27, 850], "fixing_code_start_loc": [205, 245, 23, 98], "fixing_code_end_loc": [468, 258, 23, 872], "type": "CWE-306", "message": "Envoy is a cloud-native high-performance proxy. In versions prior to 1.22.1 the OAuth filter implementation does not include a mechanism for validating access tokens, so by design when the HMAC signed cookie is missing a full authentication flow should be triggered. However, the current implementation assumes that access tokens are always validated thus allowing access in the presence of any access token attached to the request. Users are advised to upgrade. There is no known workaround for this issue.", "other": {"cve": {"id": "CVE-2022-29226", "sourceIdentifier": "security-advisories@github.com", "published": "2022-06-09T20:15:08.077", "lastModified": "2022-06-16T18:44:06.580", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Envoy is a cloud-native high-performance proxy. In versions prior to 1.22.1 the OAuth filter implementation does not include a mechanism for validating access tokens, so by design when the HMAC signed cookie is missing a full authentication flow should be triggered. However, the current implementation assumes that access tokens are always validated thus allowing access in the presence of any access token attached to the request. Users are advised to upgrade. There is no known workaround for this issue."}, {"lang": "es", "value": "Envoy es un proxy de alto rendimiento nativo de la nube. En versiones anteriores a 1.22.1, la implementaci\u00f3n del filtro OAuth no incluye un mecanismo para comprobar los tokens de acceso, por lo que, por dise\u00f1o, cuando falta la cookie firmada por HMAC, deber\u00eda desencadenarse un flujo de autenticaci\u00f3n completo. Sin embargo, la implementaci\u00f3n actual asume que los tokens de acceso son siempre comprobados, permitiendo as\u00ed el acceso en presencia de cualquier token de acceso adjunto a la petici\u00f3n. Es recomendado a usuarios actualizar. No es conocida ninguna mitigaci\u00f3n para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 10.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.8}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-306"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.22.1", "matchCriteriaId": "343FE7CD-C2BF-42EE-8384-AAD008BE690D"}]}]}], "references": [{"url": "https://github.com/envoyproxy/envoy/commit/7ffda4e809dec74449ebc330cebb9d2f4ab61360", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/envoyproxy/envoy/security/advisories/GHSA-h45c-2f94-prxh", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/envoyproxy/envoy/commit/7ffda4e809dec74449ebc330cebb9d2f4ab61360"}}