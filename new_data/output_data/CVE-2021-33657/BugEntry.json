{"buggy_code": ["/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2021 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../SDL_internal.h\"\n\n/* General (mostly internal) pixel/color manipulation routines for SDL */\n\n#include \"SDL_endian.h\"\n#include \"SDL_video.h\"\n#include \"SDL_sysvideo.h\"\n#include \"SDL_blit.h\"\n#include \"SDL_pixels_c.h\"\n#include \"SDL_RLEaccel_c.h\"\n\n\n/* Lookup tables to expand partial bytes to the full 0..255 range */\n\nstatic Uint8 lookup_0[] = {\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255\n};\n\nstatic Uint8 lookup_1[] = {\n0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 255\n};\n\nstatic Uint8 lookup_2[] = {\n0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 85, 89, 93, 97, 101, 105, 109, 113, 117, 121, 125, 129, 133, 137, 141, 145, 149, 153, 157, 161, 165, 170, 174, 178, 182, 186, 190, 194, 198, 202, 206, 210, 214, 218, 222, 226, 230, 234, 238, 242, 246, 250, 255\n};\n\nstatic Uint8 lookup_3[] = {\n0, 8, 16, 24, 32, 41, 49, 57, 65, 74, 82, 90, 98, 106, 115, 123, 131, 139, 148, 156, 164, 172, 180, 189, 197, 205, 213, 222, 230, 238, 246, 255\n};\n\nstatic Uint8 lookup_4[] = {\n0, 17, 34, 51, 68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238, 255\n};\n\nstatic Uint8 lookup_5[] = {\n0, 36, 72, 109, 145, 182, 218, 255\n};\n\nstatic Uint8 lookup_6[] = {\n0, 85, 170, 255\n};\n\nstatic Uint8 lookup_7[] = {\n0, 255\n};\n\nstatic Uint8 lookup_8[] = {\n255\n};\n\nUint8* SDL_expand_byte[9] = {\n    lookup_0,\n    lookup_1,\n    lookup_2,\n    lookup_3,\n    lookup_4,\n    lookup_5,\n    lookup_6,\n    lookup_7,\n    lookup_8\n};\n\n/* Helper functions */\n\nconst char*\nSDL_GetPixelFormatName(Uint32 format)\n{\n    switch (format) {\n#define CASE(X) case X: return #X;\n    CASE(SDL_PIXELFORMAT_INDEX1LSB)\n    CASE(SDL_PIXELFORMAT_INDEX1MSB)\n    CASE(SDL_PIXELFORMAT_INDEX4LSB)\n    CASE(SDL_PIXELFORMAT_INDEX4MSB)\n    CASE(SDL_PIXELFORMAT_INDEX8)\n    CASE(SDL_PIXELFORMAT_RGB332)\n    CASE(SDL_PIXELFORMAT_RGB444)\n    CASE(SDL_PIXELFORMAT_BGR444)\n    CASE(SDL_PIXELFORMAT_RGB555)\n    CASE(SDL_PIXELFORMAT_BGR555)\n    CASE(SDL_PIXELFORMAT_ARGB4444)\n    CASE(SDL_PIXELFORMAT_RGBA4444)\n    CASE(SDL_PIXELFORMAT_ABGR4444)\n    CASE(SDL_PIXELFORMAT_BGRA4444)\n    CASE(SDL_PIXELFORMAT_ARGB1555)\n    CASE(SDL_PIXELFORMAT_RGBA5551)\n    CASE(SDL_PIXELFORMAT_ABGR1555)\n    CASE(SDL_PIXELFORMAT_BGRA5551)\n    CASE(SDL_PIXELFORMAT_RGB565)\n    CASE(SDL_PIXELFORMAT_BGR565)\n    CASE(SDL_PIXELFORMAT_RGB24)\n    CASE(SDL_PIXELFORMAT_BGR24)\n    CASE(SDL_PIXELFORMAT_RGB888)\n    CASE(SDL_PIXELFORMAT_RGBX8888)\n    CASE(SDL_PIXELFORMAT_BGR888)\n    CASE(SDL_PIXELFORMAT_BGRX8888)\n    CASE(SDL_PIXELFORMAT_ARGB8888)\n    CASE(SDL_PIXELFORMAT_RGBA8888)\n    CASE(SDL_PIXELFORMAT_ABGR8888)\n    CASE(SDL_PIXELFORMAT_BGRA8888)\n    CASE(SDL_PIXELFORMAT_ARGB2101010)\n    CASE(SDL_PIXELFORMAT_YV12)\n    CASE(SDL_PIXELFORMAT_IYUV)\n    CASE(SDL_PIXELFORMAT_YUY2)\n    CASE(SDL_PIXELFORMAT_UYVY)\n    CASE(SDL_PIXELFORMAT_YVYU)\n    CASE(SDL_PIXELFORMAT_NV12)\n    CASE(SDL_PIXELFORMAT_NV21)\n#undef CASE\n    default:\n        return \"SDL_PIXELFORMAT_UNKNOWN\";\n    }\n}\n\nSDL_bool\nSDL_PixelFormatEnumToMasks(Uint32 format, int *bpp, Uint32 * Rmask,\n                           Uint32 * Gmask, Uint32 * Bmask, Uint32 * Amask)\n{\n    Uint32 masks[4];\n\n    /* This function doesn't work with FourCC pixel formats */\n    if (SDL_ISPIXELFORMAT_FOURCC(format)) {\n        SDL_SetError(\"FOURCC pixel formats are not supported\");\n        return SDL_FALSE;\n    }\n\n    /* Initialize the values here */\n    if (SDL_BYTESPERPIXEL(format) <= 2) {\n        *bpp = SDL_BITSPERPIXEL(format);\n    } else {\n        *bpp = SDL_BYTESPERPIXEL(format) * 8;\n    }\n    *Rmask = *Gmask = *Bmask = *Amask = 0;\n\n    if (format == SDL_PIXELFORMAT_RGB24) {\n#if SDL_BYTEORDER == SDL_BIG_ENDIAN\n        *Rmask = 0x00FF0000;\n        *Gmask = 0x0000FF00;\n        *Bmask = 0x000000FF;\n#else\n        *Rmask = 0x000000FF;\n        *Gmask = 0x0000FF00;\n        *Bmask = 0x00FF0000;\n#endif\n        return SDL_TRUE;\n    }\n\n    if (format == SDL_PIXELFORMAT_BGR24) {\n#if SDL_BYTEORDER == SDL_BIG_ENDIAN\n        *Rmask = 0x000000FF;\n        *Gmask = 0x0000FF00;\n        *Bmask = 0x00FF0000;\n#else\n        *Rmask = 0x00FF0000;\n        *Gmask = 0x0000FF00;\n        *Bmask = 0x000000FF;\n#endif\n        return SDL_TRUE;\n    }\n\n    if (SDL_PIXELTYPE(format) != SDL_PIXELTYPE_PACKED8 &&\n        SDL_PIXELTYPE(format) != SDL_PIXELTYPE_PACKED16 &&\n        SDL_PIXELTYPE(format) != SDL_PIXELTYPE_PACKED32) {\n        /* Not a format that uses masks */\n        return SDL_TRUE;\n    }\n\n    switch (SDL_PIXELLAYOUT(format)) {\n    case SDL_PACKEDLAYOUT_332:\n        masks[0] = 0x00000000;\n        masks[1] = 0x000000E0;\n        masks[2] = 0x0000001C;\n        masks[3] = 0x00000003;\n        break;\n    case SDL_PACKEDLAYOUT_4444:\n        masks[0] = 0x0000F000;\n        masks[1] = 0x00000F00;\n        masks[2] = 0x000000F0;\n        masks[3] = 0x0000000F;\n        break;\n    case SDL_PACKEDLAYOUT_1555:\n        masks[0] = 0x00008000;\n        masks[1] = 0x00007C00;\n        masks[2] = 0x000003E0;\n        masks[3] = 0x0000001F;\n        break;\n    case SDL_PACKEDLAYOUT_5551:\n        masks[0] = 0x0000F800;\n        masks[1] = 0x000007C0;\n        masks[2] = 0x0000003E;\n        masks[3] = 0x00000001;\n        break;\n    case SDL_PACKEDLAYOUT_565:\n        masks[0] = 0x00000000;\n        masks[1] = 0x0000F800;\n        masks[2] = 0x000007E0;\n        masks[3] = 0x0000001F;\n        break;\n    case SDL_PACKEDLAYOUT_8888:\n        masks[0] = 0xFF000000;\n        masks[1] = 0x00FF0000;\n        masks[2] = 0x0000FF00;\n        masks[3] = 0x000000FF;\n        break;\n    case SDL_PACKEDLAYOUT_2101010:\n        masks[0] = 0xC0000000;\n        masks[1] = 0x3FF00000;\n        masks[2] = 0x000FFC00;\n        masks[3] = 0x000003FF;\n        break;\n    case SDL_PACKEDLAYOUT_1010102:\n        masks[0] = 0xFFC00000;\n        masks[1] = 0x003FF000;\n        masks[2] = 0x00000FFC;\n        masks[3] = 0x00000003;\n        break;\n    default:\n        SDL_SetError(\"Unknown pixel format\");\n        return SDL_FALSE;\n    }\n\n    switch (SDL_PIXELORDER(format)) {\n    case SDL_PACKEDORDER_XRGB:\n        *Rmask = masks[1];\n        *Gmask = masks[2];\n        *Bmask = masks[3];\n        break;\n    case SDL_PACKEDORDER_RGBX:\n        *Rmask = masks[0];\n        *Gmask = masks[1];\n        *Bmask = masks[2];\n        break;\n    case SDL_PACKEDORDER_ARGB:\n        *Amask = masks[0];\n        *Rmask = masks[1];\n        *Gmask = masks[2];\n        *Bmask = masks[3];\n        break;\n    case SDL_PACKEDORDER_RGBA:\n        *Rmask = masks[0];\n        *Gmask = masks[1];\n        *Bmask = masks[2];\n        *Amask = masks[3];\n        break;\n    case SDL_PACKEDORDER_XBGR:\n        *Bmask = masks[1];\n        *Gmask = masks[2];\n        *Rmask = masks[3];\n        break;\n    case SDL_PACKEDORDER_BGRX:\n        *Bmask = masks[0];\n        *Gmask = masks[1];\n        *Rmask = masks[2];\n        break;\n    case SDL_PACKEDORDER_BGRA:\n        *Bmask = masks[0];\n        *Gmask = masks[1];\n        *Rmask = masks[2];\n        *Amask = masks[3];\n        break;\n    case SDL_PACKEDORDER_ABGR:\n        *Amask = masks[0];\n        *Bmask = masks[1];\n        *Gmask = masks[2];\n        *Rmask = masks[3];\n        break;\n    default:\n        SDL_SetError(\"Unknown pixel format\");\n        return SDL_FALSE;\n    }\n    return SDL_TRUE;\n}\n\nUint32\nSDL_MasksToPixelFormatEnum(int bpp, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask,\n                           Uint32 Amask)\n{\n    switch (bpp) {\n    case 1:\n        /* SDL defaults to MSB ordering */\n        return SDL_PIXELFORMAT_INDEX1MSB;\n    case 4:\n        /* SDL defaults to MSB ordering */\n        return SDL_PIXELFORMAT_INDEX4MSB;\n    case 8:\n        if (Rmask == 0) {\n            return SDL_PIXELFORMAT_INDEX8;\n        }\n        if (Rmask == 0xE0 &&\n            Gmask == 0x1C &&\n            Bmask == 0x03 &&\n            Amask == 0x00) {\n            return SDL_PIXELFORMAT_RGB332;\n        }\n        break;\n    case 12:\n        if (Rmask == 0) {\n            return SDL_PIXELFORMAT_RGB444;\n        }\n        if (Rmask == 0x0F00 &&\n            Gmask == 0x00F0 &&\n            Bmask == 0x000F &&\n            Amask == 0x0000) {\n            return SDL_PIXELFORMAT_RGB444;\n        }\n        if (Rmask == 0x000F &&\n            Gmask == 0x00F0 &&\n            Bmask == 0x0F00 &&\n            Amask == 0x0000) {\n            return SDL_PIXELFORMAT_BGR444;\n        }\n        break;\n    case 15:\n        if (Rmask == 0) {\n            return SDL_PIXELFORMAT_RGB555;\n        }\n        SDL_FALLTHROUGH;\n    case 16:\n        if (Rmask == 0) {\n            return SDL_PIXELFORMAT_RGB565;\n        }\n        if (Rmask == 0x7C00 &&\n            Gmask == 0x03E0 &&\n            Bmask == 0x001F &&\n            Amask == 0x0000) {\n            return SDL_PIXELFORMAT_RGB555;\n        }\n        if (Rmask == 0x001F &&\n            Gmask == 0x03E0 &&\n            Bmask == 0x7C00 &&\n            Amask == 0x0000) {\n            return SDL_PIXELFORMAT_BGR555;\n        }\n        if (Rmask == 0x0F00 &&\n            Gmask == 0x00F0 &&\n            Bmask == 0x000F &&\n            Amask == 0xF000) {\n            return SDL_PIXELFORMAT_ARGB4444;\n        }\n        if (Rmask == 0xF000 &&\n            Gmask == 0x0F00 &&\n            Bmask == 0x00F0 &&\n            Amask == 0x000F) {\n            return SDL_PIXELFORMAT_RGBA4444;\n        }\n        if (Rmask == 0x000F &&\n            Gmask == 0x00F0 &&\n            Bmask == 0x0F00 &&\n            Amask == 0xF000) {\n            return SDL_PIXELFORMAT_ABGR4444;\n        }\n        if (Rmask == 0x00F0 &&\n            Gmask == 0x0F00 &&\n            Bmask == 0xF000 &&\n            Amask == 0x000F) {\n            return SDL_PIXELFORMAT_BGRA4444;\n        }\n        if (Rmask == 0x7C00 &&\n            Gmask == 0x03E0 &&\n            Bmask == 0x001F &&\n            Amask == 0x8000) {\n            return SDL_PIXELFORMAT_ARGB1555;\n        }\n        if (Rmask == 0xF800 &&\n            Gmask == 0x07C0 &&\n            Bmask == 0x003E &&\n            Amask == 0x0001) {\n            return SDL_PIXELFORMAT_RGBA5551;\n        }\n        if (Rmask == 0x001F &&\n            Gmask == 0x03E0 &&\n            Bmask == 0x7C00 &&\n            Amask == 0x8000) {\n            return SDL_PIXELFORMAT_ABGR1555;\n        }\n        if (Rmask == 0x003E &&\n            Gmask == 0x07C0 &&\n            Bmask == 0xF800 &&\n            Amask == 0x0001) {\n            return SDL_PIXELFORMAT_BGRA5551;\n        }\n        if (Rmask == 0xF800 &&\n            Gmask == 0x07E0 &&\n            Bmask == 0x001F &&\n            Amask == 0x0000) {\n            return SDL_PIXELFORMAT_RGB565;\n        }\n        if (Rmask == 0x001F &&\n            Gmask == 0x07E0 &&\n            Bmask == 0xF800 &&\n            Amask == 0x0000) {\n            return SDL_PIXELFORMAT_BGR565;\n        }\n        if (Rmask == 0x003F &&\n            Gmask == 0x07C0 &&\n            Bmask == 0xF800 &&\n            Amask == 0x0000) {\n            /* Technically this would be BGR556, but Witek says this works in bug 3158 */\n            return SDL_PIXELFORMAT_RGB565;\n        }\n        break;\n    case 24:\n        switch (Rmask) {\n        case 0:\n        case 0x00FF0000:\n#if SDL_BYTEORDER == SDL_BIG_ENDIAN\n            return SDL_PIXELFORMAT_RGB24;\n#else\n            return SDL_PIXELFORMAT_BGR24;\n#endif\n        case 0x000000FF:\n#if SDL_BYTEORDER == SDL_BIG_ENDIAN\n            return SDL_PIXELFORMAT_BGR24;\n#else\n            return SDL_PIXELFORMAT_RGB24;\n#endif\n        }\n    case 32:\n        if (Rmask == 0) {\n            return SDL_PIXELFORMAT_RGB888;\n        }\n        if (Rmask == 0x00FF0000 &&\n            Gmask == 0x0000FF00 &&\n            Bmask == 0x000000FF &&\n            Amask == 0x00000000) {\n            return SDL_PIXELFORMAT_RGB888;\n        }\n        if (Rmask == 0xFF000000 &&\n            Gmask == 0x00FF0000 &&\n            Bmask == 0x0000FF00 &&\n            Amask == 0x00000000) {\n            return SDL_PIXELFORMAT_RGBX8888;\n        }\n        if (Rmask == 0x000000FF &&\n            Gmask == 0x0000FF00 &&\n            Bmask == 0x00FF0000 &&\n            Amask == 0x00000000) {\n            return SDL_PIXELFORMAT_BGR888;\n        }\n        if (Rmask == 0x0000FF00 &&\n            Gmask == 0x00FF0000 &&\n            Bmask == 0xFF000000 &&\n            Amask == 0x00000000) {\n            return SDL_PIXELFORMAT_BGRX8888;\n        }\n        if (Rmask == 0x00FF0000 &&\n            Gmask == 0x0000FF00 &&\n            Bmask == 0x000000FF &&\n            Amask == 0xFF000000) {\n            return SDL_PIXELFORMAT_ARGB8888;\n        }\n        if (Rmask == 0xFF000000 &&\n            Gmask == 0x00FF0000 &&\n            Bmask == 0x0000FF00 &&\n            Amask == 0x000000FF) {\n            return SDL_PIXELFORMAT_RGBA8888;\n        }\n        if (Rmask == 0x000000FF &&\n            Gmask == 0x0000FF00 &&\n            Bmask == 0x00FF0000 &&\n            Amask == 0xFF000000) {\n            return SDL_PIXELFORMAT_ABGR8888;\n        }\n        if (Rmask == 0x0000FF00 &&\n            Gmask == 0x00FF0000 &&\n            Bmask == 0xFF000000 &&\n            Amask == 0x000000FF) {\n            return SDL_PIXELFORMAT_BGRA8888;\n        }\n        if (Rmask == 0x3FF00000 &&\n            Gmask == 0x000FFC00 &&\n            Bmask == 0x000003FF &&\n            Amask == 0xC0000000) {\n            return SDL_PIXELFORMAT_ARGB2101010;\n        }\n    }\n    return SDL_PIXELFORMAT_UNKNOWN;\n}\n\nstatic SDL_PixelFormat *formats;\nstatic SDL_SpinLock formats_lock = 0;\n\nSDL_PixelFormat *\nSDL_AllocFormat(Uint32 pixel_format)\n{\n    SDL_PixelFormat *format;\n\n    SDL_AtomicLock(&formats_lock);\n\n    /* Look it up in our list of previously allocated formats */\n    for (format = formats; format; format = format->next) {\n        if (pixel_format == format->format) {\n            ++format->refcount;\n            SDL_AtomicUnlock(&formats_lock);\n            return format;\n        }\n    }\n\n    /* Allocate an empty pixel format structure, and initialize it */\n    format = SDL_malloc(sizeof(*format));\n    if (format == NULL) {\n        SDL_AtomicUnlock(&formats_lock);\n        SDL_OutOfMemory();\n        return NULL;\n    }\n    if (SDL_InitFormat(format, pixel_format) < 0) {\n        SDL_AtomicUnlock(&formats_lock);\n        SDL_free(format);\n        SDL_InvalidParamError(\"format\");\n        return NULL;\n    }\n\n    if (!SDL_ISPIXELFORMAT_INDEXED(pixel_format)) {\n        /* Cache the RGB formats */\n        format->next = formats;\n        formats = format;\n    }\n\n    SDL_AtomicUnlock(&formats_lock);\n\n    return format;\n}\n\nint\nSDL_InitFormat(SDL_PixelFormat * format, Uint32 pixel_format)\n{\n    int bpp;\n    Uint32 Rmask, Gmask, Bmask, Amask;\n    Uint32 mask;\n\n    if (!SDL_PixelFormatEnumToMasks(pixel_format, &bpp,\n                                    &Rmask, &Gmask, &Bmask, &Amask)) {\n        return -1;\n    }\n\n    /* Set up the format */\n    SDL_zerop(format);\n    format->format = pixel_format;\n    format->BitsPerPixel = bpp;\n    format->BytesPerPixel = (bpp + 7) / 8;\n\n    format->Rmask = Rmask;\n    format->Rshift = 0;\n    format->Rloss = 8;\n    if (Rmask) {\n        for (mask = Rmask; !(mask & 0x01); mask >>= 1)\n            ++format->Rshift;\n        for (; (mask & 0x01); mask >>= 1)\n            --format->Rloss;\n    }\n\n    format->Gmask = Gmask;\n    format->Gshift = 0;\n    format->Gloss = 8;\n    if (Gmask) {\n        for (mask = Gmask; !(mask & 0x01); mask >>= 1)\n            ++format->Gshift;\n        for (; (mask & 0x01); mask >>= 1)\n            --format->Gloss;\n    }\n\n    format->Bmask = Bmask;\n    format->Bshift = 0;\n    format->Bloss = 8;\n    if (Bmask) {\n        for (mask = Bmask; !(mask & 0x01); mask >>= 1)\n            ++format->Bshift;\n        for (; (mask & 0x01); mask >>= 1)\n            --format->Bloss;\n    }\n\n    format->Amask = Amask;\n    format->Ashift = 0;\n    format->Aloss = 8;\n    if (Amask) {\n        for (mask = Amask; !(mask & 0x01); mask >>= 1)\n            ++format->Ashift;\n        for (; (mask & 0x01); mask >>= 1)\n            --format->Aloss;\n    }\n\n    format->palette = NULL;\n    format->refcount = 1;\n    format->next = NULL;\n\n    return 0;\n}\n\nvoid\nSDL_FreeFormat(SDL_PixelFormat *format)\n{\n    SDL_PixelFormat *prev;\n\n    if (!format) {\n        SDL_InvalidParamError(\"format\");\n        return;\n    }\n\n    SDL_AtomicLock(&formats_lock);\n\n    if (--format->refcount > 0) {\n        SDL_AtomicUnlock(&formats_lock);\n        return;\n    }\n\n    /* Remove this format from our list */\n    if (format == formats) {\n        formats = format->next;\n    } else if (formats) {\n        for (prev = formats; prev->next; prev = prev->next) {\n            if (prev->next == format) {\n                prev->next = format->next;\n                break;\n            }\n        }\n    }\n\n    SDL_AtomicUnlock(&formats_lock);\n\n    if (format->palette) {\n        SDL_FreePalette(format->palette);\n    }\n    SDL_free(format);\n}\n\nSDL_Palette *\nSDL_AllocPalette(int ncolors)\n{\n    SDL_Palette *palette;\n\n    /* Input validation */\n    if (ncolors < 1) {\n      SDL_InvalidParamError(\"ncolors\");\n      return NULL;\n    }\n\n    palette = (SDL_Palette *) SDL_malloc(sizeof(*palette));\n    if (!palette) {\n        SDL_OutOfMemory();\n        return NULL;\n    }\n    palette->colors =\n        (SDL_Color *) SDL_malloc(ncolors * sizeof(*palette->colors));\n    if (!palette->colors) {\n        SDL_free(palette);\n        return NULL;\n    }\n    palette->ncolors = ncolors;\n    palette->version = 1;\n    palette->refcount = 1;\n\n    SDL_memset(palette->colors, 0xFF, ncolors * sizeof(*palette->colors));\n\n    return palette;\n}\n\nint\nSDL_SetPixelFormatPalette(SDL_PixelFormat * format, SDL_Palette *palette)\n{\n    if (!format) {\n        return SDL_SetError(\"SDL_SetPixelFormatPalette() passed NULL format\");\n    }\n\n    if (palette && palette->ncolors > (1 << format->BitsPerPixel)) {\n        return SDL_SetError(\"SDL_SetPixelFormatPalette() passed a palette that doesn't match the format\");\n    }\n\n    if (format->palette == palette) {\n        return 0;\n    }\n\n    if (format->palette) {\n        SDL_FreePalette(format->palette);\n    }\n\n    format->palette = palette;\n\n    if (format->palette) {\n        ++format->palette->refcount;\n    }\n\n    return 0;\n}\n\nint\nSDL_SetPaletteColors(SDL_Palette * palette, const SDL_Color * colors,\n                     int firstcolor, int ncolors)\n{\n    int status = 0;\n\n    /* Verify the parameters */\n    if (!palette) {\n        return -1;\n    }\n    if (ncolors > (palette->ncolors - firstcolor)) {\n        ncolors = (palette->ncolors - firstcolor);\n        status = -1;\n    }\n\n    if (colors != (palette->colors + firstcolor)) {\n        SDL_memcpy(palette->colors + firstcolor, colors,\n                   ncolors * sizeof(*colors));\n    }\n    ++palette->version;\n    if (!palette->version) {\n        palette->version = 1;\n    }\n\n    return status;\n}\n\nvoid\nSDL_FreePalette(SDL_Palette * palette)\n{\n    if (!palette) {\n        SDL_InvalidParamError(\"palette\");\n        return;\n    }\n    if (--palette->refcount > 0) {\n        return;\n    }\n    SDL_free(palette->colors);\n    SDL_free(palette);\n}\n\n/*\n * Calculate an 8-bit (3 red, 3 green, 2 blue) dithered palette of colors\n */\nvoid\nSDL_DitherColors(SDL_Color * colors, int bpp)\n{\n    int i;\n    if (bpp != 8)\n        return;                 /* only 8bpp supported right now */\n\n    for (i = 0; i < 256; i++) {\n        int r, g, b;\n        /* map each bit field to the full [0, 255] interval,\n           so 0 is mapped to (0, 0, 0) and 255 to (255, 255, 255) */\n        r = i & 0xe0;\n        r |= r >> 3 | r >> 6;\n        colors[i].r = r;\n        g = (i << 3) & 0xe0;\n        g |= g >> 3 | g >> 6;\n        colors[i].g = g;\n        b = i & 0x3;\n        b |= b << 2;\n        b |= b << 4;\n        colors[i].b = b;\n        colors[i].a = SDL_ALPHA_OPAQUE;\n    }\n}\n\n/*\n * Match an RGB value to a particular palette index\n */\nUint8\nSDL_FindColor(SDL_Palette * pal, Uint8 r, Uint8 g, Uint8 b, Uint8 a)\n{\n    /* Do colorspace distance matching */\n    unsigned int smallest;\n    unsigned int distance;\n    int rd, gd, bd, ad;\n    int i;\n    Uint8 pixel = 0;\n\n    smallest = ~0;\n    for (i = 0; i < pal->ncolors; ++i) {\n        rd = pal->colors[i].r - r;\n        gd = pal->colors[i].g - g;\n        bd = pal->colors[i].b - b;\n        ad = pal->colors[i].a - a;\n        distance = (rd * rd) + (gd * gd) + (bd * bd) + (ad * ad);\n        if (distance < smallest) {\n            pixel = i;\n            if (distance == 0) {        /* Perfect match! */\n                break;\n            }\n            smallest = distance;\n        }\n    }\n    return (pixel);\n}\n\n/* Tell whether palette is opaque, and if it has an alpha_channel */\nvoid\nSDL_DetectPalette(SDL_Palette *pal, SDL_bool *is_opaque, SDL_bool *has_alpha_channel)\n{\n    int i;\n\n    {\n        SDL_bool all_opaque = SDL_TRUE;\n        for (i = 0; i < pal->ncolors; i++) {\n            Uint8 alpha_value = pal->colors[i].a;\n            if (alpha_value != SDL_ALPHA_OPAQUE) {\n                all_opaque = SDL_FALSE;\n                break;\n            }\n        }\n\n        if (all_opaque) {\n            /* Palette is opaque, with an alpha channel */\n            *is_opaque = SDL_TRUE;\n            *has_alpha_channel = SDL_TRUE;\n            return;\n        }\n    }\n\n    {\n        SDL_bool all_transparent = SDL_TRUE;\n        for (i = 0; i < pal->ncolors; i++) {\n            Uint8 alpha_value = pal->colors[i].a;\n            if (alpha_value != SDL_ALPHA_TRANSPARENT) {\n                all_transparent = SDL_FALSE;\n                break;\n            }\n        }\n\n        if (all_transparent) {\n            /* Palette is opaque, without an alpha channel */\n            *is_opaque = SDL_TRUE;\n            *has_alpha_channel = SDL_FALSE;\n            return;\n        }\n    }\n\n    /* Palette has alpha values */\n    *is_opaque = SDL_FALSE;\n    *has_alpha_channel = SDL_TRUE;\n}\n\n\n/* Find the opaque pixel value corresponding to an RGB triple */\nUint32\nSDL_MapRGB(const SDL_PixelFormat * format, Uint8 r, Uint8 g, Uint8 b)\n{\n    if (format->palette == NULL) {\n        return (r >> format->Rloss) << format->Rshift\n            | (g >> format->Gloss) << format->Gshift\n            | (b >> format->Bloss) << format->Bshift | format->Amask;\n    } else {\n        return SDL_FindColor(format->palette, r, g, b, SDL_ALPHA_OPAQUE);\n    }\n}\n\n/* Find the pixel value corresponding to an RGBA quadruple */\nUint32\nSDL_MapRGBA(const SDL_PixelFormat * format, Uint8 r, Uint8 g, Uint8 b,\n            Uint8 a)\n{\n    if (format->palette == NULL) {\n        return (r >> format->Rloss) << format->Rshift\n            | (g >> format->Gloss) << format->Gshift\n            | (b >> format->Bloss) << format->Bshift\n            | ((Uint32)(a >> format->Aloss) << format->Ashift & format->Amask);\n    } else {\n        return SDL_FindColor(format->palette, r, g, b, a);\n    }\n}\n\nvoid\nSDL_GetRGB(Uint32 pixel, const SDL_PixelFormat * format, Uint8 * r, Uint8 * g,\n           Uint8 * b)\n{\n    if (format->palette == NULL) {\n        unsigned v;\n        v = (pixel & format->Rmask) >> format->Rshift;\n        *r = SDL_expand_byte[format->Rloss][v];\n        v = (pixel & format->Gmask) >> format->Gshift;\n        *g = SDL_expand_byte[format->Gloss][v];\n        v = (pixel & format->Bmask) >> format->Bshift;\n        *b = SDL_expand_byte[format->Bloss][v];\n    } else {\n        if (pixel < (unsigned)format->palette->ncolors) {\n            *r = format->palette->colors[pixel].r;\n            *g = format->palette->colors[pixel].g;\n            *b = format->palette->colors[pixel].b;\n        } else {\n            *r = *g = *b = 0;\n        }\n    }\n}\n\nvoid\nSDL_GetRGBA(Uint32 pixel, const SDL_PixelFormat * format,\n            Uint8 * r, Uint8 * g, Uint8 * b, Uint8 * a)\n{\n    if (format->palette == NULL) {\n        unsigned v;\n        v = (pixel & format->Rmask) >> format->Rshift;\n        *r = SDL_expand_byte[format->Rloss][v];\n        v = (pixel & format->Gmask) >> format->Gshift;\n        *g = SDL_expand_byte[format->Gloss][v];\n        v = (pixel & format->Bmask) >> format->Bshift;\n        *b = SDL_expand_byte[format->Bloss][v];\n        v = (pixel & format->Amask) >> format->Ashift;\n        *a = SDL_expand_byte[format->Aloss][v];\n    } else {\n        if (pixel < (unsigned)format->palette->ncolors) {\n            *r = format->palette->colors[pixel].r;\n            *g = format->palette->colors[pixel].g;\n            *b = format->palette->colors[pixel].b;\n            *a = format->palette->colors[pixel].a;\n        } else {\n            *r = *g = *b = *a = 0;\n        }\n    }\n}\n\n/* Map from Palette to Palette */\nstatic Uint8 *\nMap1to1(SDL_Palette * src, SDL_Palette * dst, int *identical)\n{\n    Uint8 *map;\n    int i;\n\n    if (identical) {\n        if (src->ncolors <= dst->ncolors) {\n            /* If an identical palette, no need to map */\n            if (src == dst\n                ||\n                (SDL_memcmp\n                 (src->colors, dst->colors,\n                  src->ncolors * sizeof(SDL_Color)) == 0)) {\n                *identical = 1;\n                return (NULL);\n            }\n        }\n        *identical = 0;\n    }\n    map = (Uint8 *) SDL_malloc(src->ncolors);\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n    for (i = 0; i < src->ncolors; ++i) {\n        map[i] = SDL_FindColor(dst,\n                               src->colors[i].r, src->colors[i].g,\n                               src->colors[i].b, src->colors[i].a);\n    }\n    return (map);\n}\n\n/* Map from Palette to BitField */\nstatic Uint8 *\nMap1toN(SDL_PixelFormat * src, Uint8 Rmod, Uint8 Gmod, Uint8 Bmod, Uint8 Amod,\n        SDL_PixelFormat * dst)\n{\n    Uint8 *map;\n    int i;\n    int bpp;\n    SDL_Palette *pal = src->palette;\n\n    bpp = ((dst->BytesPerPixel == 3) ? 4 : dst->BytesPerPixel);\n    map = (Uint8 *) SDL_malloc(pal->ncolors * bpp);\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n\n    /* We memory copy to the pixel map so the endianness is preserved */\n    for (i = 0; i < pal->ncolors; ++i) {\n        Uint8 R = (Uint8) ((pal->colors[i].r * Rmod) / 255);\n        Uint8 G = (Uint8) ((pal->colors[i].g * Gmod) / 255);\n        Uint8 B = (Uint8) ((pal->colors[i].b * Bmod) / 255);\n        Uint8 A = (Uint8) ((pal->colors[i].a * Amod) / 255);\n        ASSEMBLE_RGBA(&map[i * bpp], dst->BytesPerPixel, dst, (Uint32)R, (Uint32)G, (Uint32)B, (Uint32)A);\n    }\n    return (map);\n}\n\n/* Map from BitField to Dithered-Palette to Palette */\nstatic Uint8 *\nMapNto1(SDL_PixelFormat * src, SDL_PixelFormat * dst, int *identical)\n{\n    /* Generate a 256 color dither palette */\n    SDL_Palette dithered;\n    SDL_Color colors[256];\n    SDL_Palette *pal = dst->palette;\n\n    dithered.ncolors = 256;\n    SDL_DitherColors(colors, 8);\n    dithered.colors = colors;\n    return (Map1to1(&dithered, pal, identical));\n}\n\nSDL_BlitMap *\nSDL_AllocBlitMap(void)\n{\n    SDL_BlitMap *map;\n\n    /* Allocate the empty map */\n    map = (SDL_BlitMap *) SDL_calloc(1, sizeof(*map));\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n    map->info.r = 0xFF;\n    map->info.g = 0xFF;\n    map->info.b = 0xFF;\n    map->info.a = 0xFF;\n\n    /* It's ready to go */\n    return (map);\n}\n\n\ntypedef struct SDL_ListNode\n{\n    void *entry;\n    struct SDL_ListNode *next;\n} SDL_ListNode;\n\nvoid\nSDL_InvalidateAllBlitMap(SDL_Surface *surface)\n{\n    SDL_ListNode *l = surface->list_blitmap;\n\n    surface->list_blitmap = NULL;\n\n    while (l) {\n        SDL_ListNode *tmp = l;\n        SDL_InvalidateMap((SDL_BlitMap *)l->entry);\n        l = l->next;\n        SDL_free(tmp);\n    }\n}\n\nstatic void SDL_ListAdd(SDL_ListNode **head, void *ent);\nstatic void SDL_ListRemove(SDL_ListNode **head, void *ent);\n\nvoid\nSDL_ListAdd(SDL_ListNode **head, void *ent)\n{\n    SDL_ListNode *node = SDL_malloc(sizeof (*node));\n\n    if (node == NULL) {\n        SDL_OutOfMemory();\n        return;\n    }\n\n    node->entry = ent;\n    node->next = *head;\n    *head = node;\n}\n\nvoid\nSDL_ListRemove(SDL_ListNode **head, void *ent)\n{\n    SDL_ListNode **ptr = head;\n\n    while (*ptr) {\n        if ((*ptr)->entry == ent) {\n            SDL_ListNode *tmp = *ptr;\n            *ptr = (*ptr)->next;\n            SDL_free(tmp);\n            return;\n        }\n        ptr = &(*ptr)->next;\n    }\n}\n\nvoid\nSDL_InvalidateMap(SDL_BlitMap * map)\n{\n    if (!map) {\n        return;\n    }\n    if (map->dst) {\n        /* Un-register from the destination surface */\n        SDL_ListRemove((SDL_ListNode **)&(map->dst->list_blitmap), map);\n    }\n    map->dst = NULL;\n    map->src_palette_version = 0;\n    map->dst_palette_version = 0;\n    SDL_free(map->info.table);\n    map->info.table = NULL;\n}\n\nint\nSDL_MapSurface(SDL_Surface * src, SDL_Surface * dst)\n{\n    SDL_PixelFormat *srcfmt;\n    SDL_PixelFormat *dstfmt;\n    SDL_BlitMap *map;\n\n    /* Clear out any previous mapping */\n    map = src->map;\n#if SDL_HAVE_RLE\n    if ((src->flags & SDL_RLEACCEL) == SDL_RLEACCEL) {\n        SDL_UnRLESurface(src, 1);\n    }\n#endif\n    SDL_InvalidateMap(map);\n\n    /* Figure out what kind of mapping we're doing */\n    map->identity = 0;\n    srcfmt = src->format;\n    dstfmt = dst->format;\n    if (SDL_ISPIXELFORMAT_INDEXED(srcfmt->format)) {\n        if (SDL_ISPIXELFORMAT_INDEXED(dstfmt->format)) {\n            /* Palette --> Palette */\n            map->info.table =\n                Map1to1(srcfmt->palette, dstfmt->palette, &map->identity);\n            if (!map->identity) {\n                if (map->info.table == NULL) {\n                    return (-1);\n                }\n            }\n            if (srcfmt->BitsPerPixel != dstfmt->BitsPerPixel)\n                map->identity = 0;\n        } else {\n            /* Palette --> BitField */\n            map->info.table =\n                Map1toN(srcfmt, src->map->info.r, src->map->info.g,\n                        src->map->info.b, src->map->info.a, dstfmt);\n            if (map->info.table == NULL) {\n                return (-1);\n            }\n        }\n    } else {\n        if (SDL_ISPIXELFORMAT_INDEXED(dstfmt->format)) {\n            /* BitField --> Palette */\n            map->info.table = MapNto1(srcfmt, dstfmt, &map->identity);\n            if (!map->identity) {\n                if (map->info.table == NULL) {\n                    return (-1);\n                }\n            }\n            map->identity = 0;  /* Don't optimize to copy */\n        } else {\n            /* BitField --> BitField */\n            if (srcfmt == dstfmt) {\n                map->identity = 1;\n            }\n        }\n    }\n\n    map->dst = dst;\n\n    if (map->dst) {\n        /* Register BlitMap to the destination surface, to be invalidated when needed */\n        SDL_ListAdd((SDL_ListNode **)&(map->dst->list_blitmap), map);\n    }\n\n    if (dstfmt->palette) {\n        map->dst_palette_version = dstfmt->palette->version;\n    } else {\n        map->dst_palette_version = 0;\n    }\n\n    if (srcfmt->palette) {\n        map->src_palette_version = srcfmt->palette->version;\n    } else {\n        map->src_palette_version = 0;\n    }\n\n    /* Choose your blitters wisely */\n    return (SDL_CalculateBlit(src));\n}\n\nvoid\nSDL_FreeBlitMap(SDL_BlitMap * map)\n{\n    if (map) {\n        SDL_InvalidateMap(map);\n        SDL_free(map);\n    }\n}\n\nvoid\nSDL_CalculateGammaRamp(float gamma, Uint16 * ramp)\n{\n    int i;\n\n    /* Input validation */\n    if (gamma < 0.0f ) {\n      SDL_InvalidParamError(\"gamma\");\n      return;\n    }\n    if (ramp == NULL) {\n      SDL_InvalidParamError(\"ramp\");\n      return;\n    }\n\n    /* 0.0 gamma is all black */\n    if (gamma == 0.0f) {\n        SDL_memset(ramp, 0, 256 * sizeof(Uint16));\n        return;\n    } else if (gamma == 1.0f) {\n        /* 1.0 gamma is identity */\n        for (i = 0; i < 256; ++i) {\n            ramp[i] = (i << 8) | i;\n        }\n        return;\n    } else {\n        /* Calculate a real gamma ramp */\n        int value;\n        gamma = 1.0f / gamma;\n        for (i = 0; i < 256; ++i) {\n            value =\n                (int) (SDL_pow((double) i / 256.0, gamma) * 65535.0 + 0.5);\n            if (value > 65535) {\n                value = 65535;\n            }\n            ramp[i] = (Uint16) value;\n        }\n    }\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n"], "fixing_code": ["/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2021 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../SDL_internal.h\"\n\n/* General (mostly internal) pixel/color manipulation routines for SDL */\n\n#include \"SDL_endian.h\"\n#include \"SDL_video.h\"\n#include \"SDL_sysvideo.h\"\n#include \"SDL_blit.h\"\n#include \"SDL_pixels_c.h\"\n#include \"SDL_RLEaccel_c.h\"\n\n\n/* Lookup tables to expand partial bytes to the full 0..255 range */\n\nstatic Uint8 lookup_0[] = {\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255\n};\n\nstatic Uint8 lookup_1[] = {\n0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 255\n};\n\nstatic Uint8 lookup_2[] = {\n0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 85, 89, 93, 97, 101, 105, 109, 113, 117, 121, 125, 129, 133, 137, 141, 145, 149, 153, 157, 161, 165, 170, 174, 178, 182, 186, 190, 194, 198, 202, 206, 210, 214, 218, 222, 226, 230, 234, 238, 242, 246, 250, 255\n};\n\nstatic Uint8 lookup_3[] = {\n0, 8, 16, 24, 32, 41, 49, 57, 65, 74, 82, 90, 98, 106, 115, 123, 131, 139, 148, 156, 164, 172, 180, 189, 197, 205, 213, 222, 230, 238, 246, 255\n};\n\nstatic Uint8 lookup_4[] = {\n0, 17, 34, 51, 68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238, 255\n};\n\nstatic Uint8 lookup_5[] = {\n0, 36, 72, 109, 145, 182, 218, 255\n};\n\nstatic Uint8 lookup_6[] = {\n0, 85, 170, 255\n};\n\nstatic Uint8 lookup_7[] = {\n0, 255\n};\n\nstatic Uint8 lookup_8[] = {\n255\n};\n\nUint8* SDL_expand_byte[9] = {\n    lookup_0,\n    lookup_1,\n    lookup_2,\n    lookup_3,\n    lookup_4,\n    lookup_5,\n    lookup_6,\n    lookup_7,\n    lookup_8\n};\n\n/* Helper functions */\n\nconst char*\nSDL_GetPixelFormatName(Uint32 format)\n{\n    switch (format) {\n#define CASE(X) case X: return #X;\n    CASE(SDL_PIXELFORMAT_INDEX1LSB)\n    CASE(SDL_PIXELFORMAT_INDEX1MSB)\n    CASE(SDL_PIXELFORMAT_INDEX4LSB)\n    CASE(SDL_PIXELFORMAT_INDEX4MSB)\n    CASE(SDL_PIXELFORMAT_INDEX8)\n    CASE(SDL_PIXELFORMAT_RGB332)\n    CASE(SDL_PIXELFORMAT_RGB444)\n    CASE(SDL_PIXELFORMAT_BGR444)\n    CASE(SDL_PIXELFORMAT_RGB555)\n    CASE(SDL_PIXELFORMAT_BGR555)\n    CASE(SDL_PIXELFORMAT_ARGB4444)\n    CASE(SDL_PIXELFORMAT_RGBA4444)\n    CASE(SDL_PIXELFORMAT_ABGR4444)\n    CASE(SDL_PIXELFORMAT_BGRA4444)\n    CASE(SDL_PIXELFORMAT_ARGB1555)\n    CASE(SDL_PIXELFORMAT_RGBA5551)\n    CASE(SDL_PIXELFORMAT_ABGR1555)\n    CASE(SDL_PIXELFORMAT_BGRA5551)\n    CASE(SDL_PIXELFORMAT_RGB565)\n    CASE(SDL_PIXELFORMAT_BGR565)\n    CASE(SDL_PIXELFORMAT_RGB24)\n    CASE(SDL_PIXELFORMAT_BGR24)\n    CASE(SDL_PIXELFORMAT_RGB888)\n    CASE(SDL_PIXELFORMAT_RGBX8888)\n    CASE(SDL_PIXELFORMAT_BGR888)\n    CASE(SDL_PIXELFORMAT_BGRX8888)\n    CASE(SDL_PIXELFORMAT_ARGB8888)\n    CASE(SDL_PIXELFORMAT_RGBA8888)\n    CASE(SDL_PIXELFORMAT_ABGR8888)\n    CASE(SDL_PIXELFORMAT_BGRA8888)\n    CASE(SDL_PIXELFORMAT_ARGB2101010)\n    CASE(SDL_PIXELFORMAT_YV12)\n    CASE(SDL_PIXELFORMAT_IYUV)\n    CASE(SDL_PIXELFORMAT_YUY2)\n    CASE(SDL_PIXELFORMAT_UYVY)\n    CASE(SDL_PIXELFORMAT_YVYU)\n    CASE(SDL_PIXELFORMAT_NV12)\n    CASE(SDL_PIXELFORMAT_NV21)\n#undef CASE\n    default:\n        return \"SDL_PIXELFORMAT_UNKNOWN\";\n    }\n}\n\nSDL_bool\nSDL_PixelFormatEnumToMasks(Uint32 format, int *bpp, Uint32 * Rmask,\n                           Uint32 * Gmask, Uint32 * Bmask, Uint32 * Amask)\n{\n    Uint32 masks[4];\n\n    /* This function doesn't work with FourCC pixel formats */\n    if (SDL_ISPIXELFORMAT_FOURCC(format)) {\n        SDL_SetError(\"FOURCC pixel formats are not supported\");\n        return SDL_FALSE;\n    }\n\n    /* Initialize the values here */\n    if (SDL_BYTESPERPIXEL(format) <= 2) {\n        *bpp = SDL_BITSPERPIXEL(format);\n    } else {\n        *bpp = SDL_BYTESPERPIXEL(format) * 8;\n    }\n    *Rmask = *Gmask = *Bmask = *Amask = 0;\n\n    if (format == SDL_PIXELFORMAT_RGB24) {\n#if SDL_BYTEORDER == SDL_BIG_ENDIAN\n        *Rmask = 0x00FF0000;\n        *Gmask = 0x0000FF00;\n        *Bmask = 0x000000FF;\n#else\n        *Rmask = 0x000000FF;\n        *Gmask = 0x0000FF00;\n        *Bmask = 0x00FF0000;\n#endif\n        return SDL_TRUE;\n    }\n\n    if (format == SDL_PIXELFORMAT_BGR24) {\n#if SDL_BYTEORDER == SDL_BIG_ENDIAN\n        *Rmask = 0x000000FF;\n        *Gmask = 0x0000FF00;\n        *Bmask = 0x00FF0000;\n#else\n        *Rmask = 0x00FF0000;\n        *Gmask = 0x0000FF00;\n        *Bmask = 0x000000FF;\n#endif\n        return SDL_TRUE;\n    }\n\n    if (SDL_PIXELTYPE(format) != SDL_PIXELTYPE_PACKED8 &&\n        SDL_PIXELTYPE(format) != SDL_PIXELTYPE_PACKED16 &&\n        SDL_PIXELTYPE(format) != SDL_PIXELTYPE_PACKED32) {\n        /* Not a format that uses masks */\n        return SDL_TRUE;\n    }\n\n    switch (SDL_PIXELLAYOUT(format)) {\n    case SDL_PACKEDLAYOUT_332:\n        masks[0] = 0x00000000;\n        masks[1] = 0x000000E0;\n        masks[2] = 0x0000001C;\n        masks[3] = 0x00000003;\n        break;\n    case SDL_PACKEDLAYOUT_4444:\n        masks[0] = 0x0000F000;\n        masks[1] = 0x00000F00;\n        masks[2] = 0x000000F0;\n        masks[3] = 0x0000000F;\n        break;\n    case SDL_PACKEDLAYOUT_1555:\n        masks[0] = 0x00008000;\n        masks[1] = 0x00007C00;\n        masks[2] = 0x000003E0;\n        masks[3] = 0x0000001F;\n        break;\n    case SDL_PACKEDLAYOUT_5551:\n        masks[0] = 0x0000F800;\n        masks[1] = 0x000007C0;\n        masks[2] = 0x0000003E;\n        masks[3] = 0x00000001;\n        break;\n    case SDL_PACKEDLAYOUT_565:\n        masks[0] = 0x00000000;\n        masks[1] = 0x0000F800;\n        masks[2] = 0x000007E0;\n        masks[3] = 0x0000001F;\n        break;\n    case SDL_PACKEDLAYOUT_8888:\n        masks[0] = 0xFF000000;\n        masks[1] = 0x00FF0000;\n        masks[2] = 0x0000FF00;\n        masks[3] = 0x000000FF;\n        break;\n    case SDL_PACKEDLAYOUT_2101010:\n        masks[0] = 0xC0000000;\n        masks[1] = 0x3FF00000;\n        masks[2] = 0x000FFC00;\n        masks[3] = 0x000003FF;\n        break;\n    case SDL_PACKEDLAYOUT_1010102:\n        masks[0] = 0xFFC00000;\n        masks[1] = 0x003FF000;\n        masks[2] = 0x00000FFC;\n        masks[3] = 0x00000003;\n        break;\n    default:\n        SDL_SetError(\"Unknown pixel format\");\n        return SDL_FALSE;\n    }\n\n    switch (SDL_PIXELORDER(format)) {\n    case SDL_PACKEDORDER_XRGB:\n        *Rmask = masks[1];\n        *Gmask = masks[2];\n        *Bmask = masks[3];\n        break;\n    case SDL_PACKEDORDER_RGBX:\n        *Rmask = masks[0];\n        *Gmask = masks[1];\n        *Bmask = masks[2];\n        break;\n    case SDL_PACKEDORDER_ARGB:\n        *Amask = masks[0];\n        *Rmask = masks[1];\n        *Gmask = masks[2];\n        *Bmask = masks[3];\n        break;\n    case SDL_PACKEDORDER_RGBA:\n        *Rmask = masks[0];\n        *Gmask = masks[1];\n        *Bmask = masks[2];\n        *Amask = masks[3];\n        break;\n    case SDL_PACKEDORDER_XBGR:\n        *Bmask = masks[1];\n        *Gmask = masks[2];\n        *Rmask = masks[3];\n        break;\n    case SDL_PACKEDORDER_BGRX:\n        *Bmask = masks[0];\n        *Gmask = masks[1];\n        *Rmask = masks[2];\n        break;\n    case SDL_PACKEDORDER_BGRA:\n        *Bmask = masks[0];\n        *Gmask = masks[1];\n        *Rmask = masks[2];\n        *Amask = masks[3];\n        break;\n    case SDL_PACKEDORDER_ABGR:\n        *Amask = masks[0];\n        *Bmask = masks[1];\n        *Gmask = masks[2];\n        *Rmask = masks[3];\n        break;\n    default:\n        SDL_SetError(\"Unknown pixel format\");\n        return SDL_FALSE;\n    }\n    return SDL_TRUE;\n}\n\nUint32\nSDL_MasksToPixelFormatEnum(int bpp, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask,\n                           Uint32 Amask)\n{\n    switch (bpp) {\n    case 1:\n        /* SDL defaults to MSB ordering */\n        return SDL_PIXELFORMAT_INDEX1MSB;\n    case 4:\n        /* SDL defaults to MSB ordering */\n        return SDL_PIXELFORMAT_INDEX4MSB;\n    case 8:\n        if (Rmask == 0) {\n            return SDL_PIXELFORMAT_INDEX8;\n        }\n        if (Rmask == 0xE0 &&\n            Gmask == 0x1C &&\n            Bmask == 0x03 &&\n            Amask == 0x00) {\n            return SDL_PIXELFORMAT_RGB332;\n        }\n        break;\n    case 12:\n        if (Rmask == 0) {\n            return SDL_PIXELFORMAT_RGB444;\n        }\n        if (Rmask == 0x0F00 &&\n            Gmask == 0x00F0 &&\n            Bmask == 0x000F &&\n            Amask == 0x0000) {\n            return SDL_PIXELFORMAT_RGB444;\n        }\n        if (Rmask == 0x000F &&\n            Gmask == 0x00F0 &&\n            Bmask == 0x0F00 &&\n            Amask == 0x0000) {\n            return SDL_PIXELFORMAT_BGR444;\n        }\n        break;\n    case 15:\n        if (Rmask == 0) {\n            return SDL_PIXELFORMAT_RGB555;\n        }\n        SDL_FALLTHROUGH;\n    case 16:\n        if (Rmask == 0) {\n            return SDL_PIXELFORMAT_RGB565;\n        }\n        if (Rmask == 0x7C00 &&\n            Gmask == 0x03E0 &&\n            Bmask == 0x001F &&\n            Amask == 0x0000) {\n            return SDL_PIXELFORMAT_RGB555;\n        }\n        if (Rmask == 0x001F &&\n            Gmask == 0x03E0 &&\n            Bmask == 0x7C00 &&\n            Amask == 0x0000) {\n            return SDL_PIXELFORMAT_BGR555;\n        }\n        if (Rmask == 0x0F00 &&\n            Gmask == 0x00F0 &&\n            Bmask == 0x000F &&\n            Amask == 0xF000) {\n            return SDL_PIXELFORMAT_ARGB4444;\n        }\n        if (Rmask == 0xF000 &&\n            Gmask == 0x0F00 &&\n            Bmask == 0x00F0 &&\n            Amask == 0x000F) {\n            return SDL_PIXELFORMAT_RGBA4444;\n        }\n        if (Rmask == 0x000F &&\n            Gmask == 0x00F0 &&\n            Bmask == 0x0F00 &&\n            Amask == 0xF000) {\n            return SDL_PIXELFORMAT_ABGR4444;\n        }\n        if (Rmask == 0x00F0 &&\n            Gmask == 0x0F00 &&\n            Bmask == 0xF000 &&\n            Amask == 0x000F) {\n            return SDL_PIXELFORMAT_BGRA4444;\n        }\n        if (Rmask == 0x7C00 &&\n            Gmask == 0x03E0 &&\n            Bmask == 0x001F &&\n            Amask == 0x8000) {\n            return SDL_PIXELFORMAT_ARGB1555;\n        }\n        if (Rmask == 0xF800 &&\n            Gmask == 0x07C0 &&\n            Bmask == 0x003E &&\n            Amask == 0x0001) {\n            return SDL_PIXELFORMAT_RGBA5551;\n        }\n        if (Rmask == 0x001F &&\n            Gmask == 0x03E0 &&\n            Bmask == 0x7C00 &&\n            Amask == 0x8000) {\n            return SDL_PIXELFORMAT_ABGR1555;\n        }\n        if (Rmask == 0x003E &&\n            Gmask == 0x07C0 &&\n            Bmask == 0xF800 &&\n            Amask == 0x0001) {\n            return SDL_PIXELFORMAT_BGRA5551;\n        }\n        if (Rmask == 0xF800 &&\n            Gmask == 0x07E0 &&\n            Bmask == 0x001F &&\n            Amask == 0x0000) {\n            return SDL_PIXELFORMAT_RGB565;\n        }\n        if (Rmask == 0x001F &&\n            Gmask == 0x07E0 &&\n            Bmask == 0xF800 &&\n            Amask == 0x0000) {\n            return SDL_PIXELFORMAT_BGR565;\n        }\n        if (Rmask == 0x003F &&\n            Gmask == 0x07C0 &&\n            Bmask == 0xF800 &&\n            Amask == 0x0000) {\n            /* Technically this would be BGR556, but Witek says this works in bug 3158 */\n            return SDL_PIXELFORMAT_RGB565;\n        }\n        break;\n    case 24:\n        switch (Rmask) {\n        case 0:\n        case 0x00FF0000:\n#if SDL_BYTEORDER == SDL_BIG_ENDIAN\n            return SDL_PIXELFORMAT_RGB24;\n#else\n            return SDL_PIXELFORMAT_BGR24;\n#endif\n        case 0x000000FF:\n#if SDL_BYTEORDER == SDL_BIG_ENDIAN\n            return SDL_PIXELFORMAT_BGR24;\n#else\n            return SDL_PIXELFORMAT_RGB24;\n#endif\n        }\n    case 32:\n        if (Rmask == 0) {\n            return SDL_PIXELFORMAT_RGB888;\n        }\n        if (Rmask == 0x00FF0000 &&\n            Gmask == 0x0000FF00 &&\n            Bmask == 0x000000FF &&\n            Amask == 0x00000000) {\n            return SDL_PIXELFORMAT_RGB888;\n        }\n        if (Rmask == 0xFF000000 &&\n            Gmask == 0x00FF0000 &&\n            Bmask == 0x0000FF00 &&\n            Amask == 0x00000000) {\n            return SDL_PIXELFORMAT_RGBX8888;\n        }\n        if (Rmask == 0x000000FF &&\n            Gmask == 0x0000FF00 &&\n            Bmask == 0x00FF0000 &&\n            Amask == 0x00000000) {\n            return SDL_PIXELFORMAT_BGR888;\n        }\n        if (Rmask == 0x0000FF00 &&\n            Gmask == 0x00FF0000 &&\n            Bmask == 0xFF000000 &&\n            Amask == 0x00000000) {\n            return SDL_PIXELFORMAT_BGRX8888;\n        }\n        if (Rmask == 0x00FF0000 &&\n            Gmask == 0x0000FF00 &&\n            Bmask == 0x000000FF &&\n            Amask == 0xFF000000) {\n            return SDL_PIXELFORMAT_ARGB8888;\n        }\n        if (Rmask == 0xFF000000 &&\n            Gmask == 0x00FF0000 &&\n            Bmask == 0x0000FF00 &&\n            Amask == 0x000000FF) {\n            return SDL_PIXELFORMAT_RGBA8888;\n        }\n        if (Rmask == 0x000000FF &&\n            Gmask == 0x0000FF00 &&\n            Bmask == 0x00FF0000 &&\n            Amask == 0xFF000000) {\n            return SDL_PIXELFORMAT_ABGR8888;\n        }\n        if (Rmask == 0x0000FF00 &&\n            Gmask == 0x00FF0000 &&\n            Bmask == 0xFF000000 &&\n            Amask == 0x000000FF) {\n            return SDL_PIXELFORMAT_BGRA8888;\n        }\n        if (Rmask == 0x3FF00000 &&\n            Gmask == 0x000FFC00 &&\n            Bmask == 0x000003FF &&\n            Amask == 0xC0000000) {\n            return SDL_PIXELFORMAT_ARGB2101010;\n        }\n    }\n    return SDL_PIXELFORMAT_UNKNOWN;\n}\n\nstatic SDL_PixelFormat *formats;\nstatic SDL_SpinLock formats_lock = 0;\n\nSDL_PixelFormat *\nSDL_AllocFormat(Uint32 pixel_format)\n{\n    SDL_PixelFormat *format;\n\n    SDL_AtomicLock(&formats_lock);\n\n    /* Look it up in our list of previously allocated formats */\n    for (format = formats; format; format = format->next) {\n        if (pixel_format == format->format) {\n            ++format->refcount;\n            SDL_AtomicUnlock(&formats_lock);\n            return format;\n        }\n    }\n\n    /* Allocate an empty pixel format structure, and initialize it */\n    format = SDL_malloc(sizeof(*format));\n    if (format == NULL) {\n        SDL_AtomicUnlock(&formats_lock);\n        SDL_OutOfMemory();\n        return NULL;\n    }\n    if (SDL_InitFormat(format, pixel_format) < 0) {\n        SDL_AtomicUnlock(&formats_lock);\n        SDL_free(format);\n        SDL_InvalidParamError(\"format\");\n        return NULL;\n    }\n\n    if (!SDL_ISPIXELFORMAT_INDEXED(pixel_format)) {\n        /* Cache the RGB formats */\n        format->next = formats;\n        formats = format;\n    }\n\n    SDL_AtomicUnlock(&formats_lock);\n\n    return format;\n}\n\nint\nSDL_InitFormat(SDL_PixelFormat * format, Uint32 pixel_format)\n{\n    int bpp;\n    Uint32 Rmask, Gmask, Bmask, Amask;\n    Uint32 mask;\n\n    if (!SDL_PixelFormatEnumToMasks(pixel_format, &bpp,\n                                    &Rmask, &Gmask, &Bmask, &Amask)) {\n        return -1;\n    }\n\n    /* Set up the format */\n    SDL_zerop(format);\n    format->format = pixel_format;\n    format->BitsPerPixel = bpp;\n    format->BytesPerPixel = (bpp + 7) / 8;\n\n    format->Rmask = Rmask;\n    format->Rshift = 0;\n    format->Rloss = 8;\n    if (Rmask) {\n        for (mask = Rmask; !(mask & 0x01); mask >>= 1)\n            ++format->Rshift;\n        for (; (mask & 0x01); mask >>= 1)\n            --format->Rloss;\n    }\n\n    format->Gmask = Gmask;\n    format->Gshift = 0;\n    format->Gloss = 8;\n    if (Gmask) {\n        for (mask = Gmask; !(mask & 0x01); mask >>= 1)\n            ++format->Gshift;\n        for (; (mask & 0x01); mask >>= 1)\n            --format->Gloss;\n    }\n\n    format->Bmask = Bmask;\n    format->Bshift = 0;\n    format->Bloss = 8;\n    if (Bmask) {\n        for (mask = Bmask; !(mask & 0x01); mask >>= 1)\n            ++format->Bshift;\n        for (; (mask & 0x01); mask >>= 1)\n            --format->Bloss;\n    }\n\n    format->Amask = Amask;\n    format->Ashift = 0;\n    format->Aloss = 8;\n    if (Amask) {\n        for (mask = Amask; !(mask & 0x01); mask >>= 1)\n            ++format->Ashift;\n        for (; (mask & 0x01); mask >>= 1)\n            --format->Aloss;\n    }\n\n    format->palette = NULL;\n    format->refcount = 1;\n    format->next = NULL;\n\n    return 0;\n}\n\nvoid\nSDL_FreeFormat(SDL_PixelFormat *format)\n{\n    SDL_PixelFormat *prev;\n\n    if (!format) {\n        SDL_InvalidParamError(\"format\");\n        return;\n    }\n\n    SDL_AtomicLock(&formats_lock);\n\n    if (--format->refcount > 0) {\n        SDL_AtomicUnlock(&formats_lock);\n        return;\n    }\n\n    /* Remove this format from our list */\n    if (format == formats) {\n        formats = format->next;\n    } else if (formats) {\n        for (prev = formats; prev->next; prev = prev->next) {\n            if (prev->next == format) {\n                prev->next = format->next;\n                break;\n            }\n        }\n    }\n\n    SDL_AtomicUnlock(&formats_lock);\n\n    if (format->palette) {\n        SDL_FreePalette(format->palette);\n    }\n    SDL_free(format);\n}\n\nSDL_Palette *\nSDL_AllocPalette(int ncolors)\n{\n    SDL_Palette *palette;\n\n    /* Input validation */\n    if (ncolors < 1) {\n      SDL_InvalidParamError(\"ncolors\");\n      return NULL;\n    }\n\n    palette = (SDL_Palette *) SDL_malloc(sizeof(*palette));\n    if (!palette) {\n        SDL_OutOfMemory();\n        return NULL;\n    }\n    palette->colors =\n        (SDL_Color *) SDL_malloc(ncolors * sizeof(*palette->colors));\n    if (!palette->colors) {\n        SDL_free(palette);\n        return NULL;\n    }\n    palette->ncolors = ncolors;\n    palette->version = 1;\n    palette->refcount = 1;\n\n    SDL_memset(palette->colors, 0xFF, ncolors * sizeof(*palette->colors));\n\n    return palette;\n}\n\nint\nSDL_SetPixelFormatPalette(SDL_PixelFormat * format, SDL_Palette *palette)\n{\n    if (!format) {\n        return SDL_SetError(\"SDL_SetPixelFormatPalette() passed NULL format\");\n    }\n\n    if (palette && palette->ncolors > (1 << format->BitsPerPixel)) {\n        return SDL_SetError(\"SDL_SetPixelFormatPalette() passed a palette that doesn't match the format\");\n    }\n\n    if (format->palette == palette) {\n        return 0;\n    }\n\n    if (format->palette) {\n        SDL_FreePalette(format->palette);\n    }\n\n    format->palette = palette;\n\n    if (format->palette) {\n        ++format->palette->refcount;\n    }\n\n    return 0;\n}\n\nint\nSDL_SetPaletteColors(SDL_Palette * palette, const SDL_Color * colors,\n                     int firstcolor, int ncolors)\n{\n    int status = 0;\n\n    /* Verify the parameters */\n    if (!palette) {\n        return -1;\n    }\n    if (ncolors > (palette->ncolors - firstcolor)) {\n        ncolors = (palette->ncolors - firstcolor);\n        status = -1;\n    }\n\n    if (colors != (palette->colors + firstcolor)) {\n        SDL_memcpy(palette->colors + firstcolor, colors,\n                   ncolors * sizeof(*colors));\n    }\n    ++palette->version;\n    if (!palette->version) {\n        palette->version = 1;\n    }\n\n    return status;\n}\n\nvoid\nSDL_FreePalette(SDL_Palette * palette)\n{\n    if (!palette) {\n        SDL_InvalidParamError(\"palette\");\n        return;\n    }\n    if (--palette->refcount > 0) {\n        return;\n    }\n    SDL_free(palette->colors);\n    SDL_free(palette);\n}\n\n/*\n * Calculate an 8-bit (3 red, 3 green, 2 blue) dithered palette of colors\n */\nvoid\nSDL_DitherColors(SDL_Color * colors, int bpp)\n{\n    int i;\n    if (bpp != 8)\n        return;                 /* only 8bpp supported right now */\n\n    for (i = 0; i < 256; i++) {\n        int r, g, b;\n        /* map each bit field to the full [0, 255] interval,\n           so 0 is mapped to (0, 0, 0) and 255 to (255, 255, 255) */\n        r = i & 0xe0;\n        r |= r >> 3 | r >> 6;\n        colors[i].r = r;\n        g = (i << 3) & 0xe0;\n        g |= g >> 3 | g >> 6;\n        colors[i].g = g;\n        b = i & 0x3;\n        b |= b << 2;\n        b |= b << 4;\n        colors[i].b = b;\n        colors[i].a = SDL_ALPHA_OPAQUE;\n    }\n}\n\n/*\n * Match an RGB value to a particular palette index\n */\nUint8\nSDL_FindColor(SDL_Palette * pal, Uint8 r, Uint8 g, Uint8 b, Uint8 a)\n{\n    /* Do colorspace distance matching */\n    unsigned int smallest;\n    unsigned int distance;\n    int rd, gd, bd, ad;\n    int i;\n    Uint8 pixel = 0;\n\n    smallest = ~0;\n    for (i = 0; i < pal->ncolors; ++i) {\n        rd = pal->colors[i].r - r;\n        gd = pal->colors[i].g - g;\n        bd = pal->colors[i].b - b;\n        ad = pal->colors[i].a - a;\n        distance = (rd * rd) + (gd * gd) + (bd * bd) + (ad * ad);\n        if (distance < smallest) {\n            pixel = i;\n            if (distance == 0) {        /* Perfect match! */\n                break;\n            }\n            smallest = distance;\n        }\n    }\n    return (pixel);\n}\n\n/* Tell whether palette is opaque, and if it has an alpha_channel */\nvoid\nSDL_DetectPalette(SDL_Palette *pal, SDL_bool *is_opaque, SDL_bool *has_alpha_channel)\n{\n    int i;\n\n    {\n        SDL_bool all_opaque = SDL_TRUE;\n        for (i = 0; i < pal->ncolors; i++) {\n            Uint8 alpha_value = pal->colors[i].a;\n            if (alpha_value != SDL_ALPHA_OPAQUE) {\n                all_opaque = SDL_FALSE;\n                break;\n            }\n        }\n\n        if (all_opaque) {\n            /* Palette is opaque, with an alpha channel */\n            *is_opaque = SDL_TRUE;\n            *has_alpha_channel = SDL_TRUE;\n            return;\n        }\n    }\n\n    {\n        SDL_bool all_transparent = SDL_TRUE;\n        for (i = 0; i < pal->ncolors; i++) {\n            Uint8 alpha_value = pal->colors[i].a;\n            if (alpha_value != SDL_ALPHA_TRANSPARENT) {\n                all_transparent = SDL_FALSE;\n                break;\n            }\n        }\n\n        if (all_transparent) {\n            /* Palette is opaque, without an alpha channel */\n            *is_opaque = SDL_TRUE;\n            *has_alpha_channel = SDL_FALSE;\n            return;\n        }\n    }\n\n    /* Palette has alpha values */\n    *is_opaque = SDL_FALSE;\n    *has_alpha_channel = SDL_TRUE;\n}\n\n\n/* Find the opaque pixel value corresponding to an RGB triple */\nUint32\nSDL_MapRGB(const SDL_PixelFormat * format, Uint8 r, Uint8 g, Uint8 b)\n{\n    if (format->palette == NULL) {\n        return (r >> format->Rloss) << format->Rshift\n            | (g >> format->Gloss) << format->Gshift\n            | (b >> format->Bloss) << format->Bshift | format->Amask;\n    } else {\n        return SDL_FindColor(format->palette, r, g, b, SDL_ALPHA_OPAQUE);\n    }\n}\n\n/* Find the pixel value corresponding to an RGBA quadruple */\nUint32\nSDL_MapRGBA(const SDL_PixelFormat * format, Uint8 r, Uint8 g, Uint8 b,\n            Uint8 a)\n{\n    if (format->palette == NULL) {\n        return (r >> format->Rloss) << format->Rshift\n            | (g >> format->Gloss) << format->Gshift\n            | (b >> format->Bloss) << format->Bshift\n            | ((Uint32)(a >> format->Aloss) << format->Ashift & format->Amask);\n    } else {\n        return SDL_FindColor(format->palette, r, g, b, a);\n    }\n}\n\nvoid\nSDL_GetRGB(Uint32 pixel, const SDL_PixelFormat * format, Uint8 * r, Uint8 * g,\n           Uint8 * b)\n{\n    if (format->palette == NULL) {\n        unsigned v;\n        v = (pixel & format->Rmask) >> format->Rshift;\n        *r = SDL_expand_byte[format->Rloss][v];\n        v = (pixel & format->Gmask) >> format->Gshift;\n        *g = SDL_expand_byte[format->Gloss][v];\n        v = (pixel & format->Bmask) >> format->Bshift;\n        *b = SDL_expand_byte[format->Bloss][v];\n    } else {\n        if (pixel < (unsigned)format->palette->ncolors) {\n            *r = format->palette->colors[pixel].r;\n            *g = format->palette->colors[pixel].g;\n            *b = format->palette->colors[pixel].b;\n        } else {\n            *r = *g = *b = 0;\n        }\n    }\n}\n\nvoid\nSDL_GetRGBA(Uint32 pixel, const SDL_PixelFormat * format,\n            Uint8 * r, Uint8 * g, Uint8 * b, Uint8 * a)\n{\n    if (format->palette == NULL) {\n        unsigned v;\n        v = (pixel & format->Rmask) >> format->Rshift;\n        *r = SDL_expand_byte[format->Rloss][v];\n        v = (pixel & format->Gmask) >> format->Gshift;\n        *g = SDL_expand_byte[format->Gloss][v];\n        v = (pixel & format->Bmask) >> format->Bshift;\n        *b = SDL_expand_byte[format->Bloss][v];\n        v = (pixel & format->Amask) >> format->Ashift;\n        *a = SDL_expand_byte[format->Aloss][v];\n    } else {\n        if (pixel < (unsigned)format->palette->ncolors) {\n            *r = format->palette->colors[pixel].r;\n            *g = format->palette->colors[pixel].g;\n            *b = format->palette->colors[pixel].b;\n            *a = format->palette->colors[pixel].a;\n        } else {\n            *r = *g = *b = *a = 0;\n        }\n    }\n}\n\n/* Map from Palette to Palette */\nstatic Uint8 *\nMap1to1(SDL_Palette * src, SDL_Palette * dst, int *identical)\n{\n    Uint8 *map;\n    int i;\n\n    if (identical) {\n        if (src->ncolors <= dst->ncolors) {\n            /* If an identical palette, no need to map */\n            if (src == dst\n                ||\n                (SDL_memcmp\n                 (src->colors, dst->colors,\n                  src->ncolors * sizeof(SDL_Color)) == 0)) {\n                *identical = 1;\n                return (NULL);\n            }\n        }\n        *identical = 0;\n    }\n    map = (Uint8 *) SDL_calloc(256, sizeof(Uint8));\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n    for (i = 0; i < src->ncolors; ++i) {\n        map[i] = SDL_FindColor(dst,\n                               src->colors[i].r, src->colors[i].g,\n                               src->colors[i].b, src->colors[i].a);\n    }\n    return (map);\n}\n\n/* Map from Palette to BitField */\nstatic Uint8 *\nMap1toN(SDL_PixelFormat * src, Uint8 Rmod, Uint8 Gmod, Uint8 Bmod, Uint8 Amod,\n        SDL_PixelFormat * dst)\n{\n    Uint8 *map;\n    int i;\n    int bpp;\n    SDL_Palette *pal = src->palette;\n\n    bpp = ((dst->BytesPerPixel == 3) ? 4 : dst->BytesPerPixel);\n    map = (Uint8 *) SDL_calloc(256, bpp);\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n\n    /* We memory copy to the pixel map so the endianness is preserved */\n    for (i = 0; i < pal->ncolors; ++i) {\n        Uint8 R = (Uint8) ((pal->colors[i].r * Rmod) / 255);\n        Uint8 G = (Uint8) ((pal->colors[i].g * Gmod) / 255);\n        Uint8 B = (Uint8) ((pal->colors[i].b * Bmod) / 255);\n        Uint8 A = (Uint8) ((pal->colors[i].a * Amod) / 255);\n        ASSEMBLE_RGBA(&map[i * bpp], dst->BytesPerPixel, dst, (Uint32)R, (Uint32)G, (Uint32)B, (Uint32)A);\n    }\n    return (map);\n}\n\n/* Map from BitField to Dithered-Palette to Palette */\nstatic Uint8 *\nMapNto1(SDL_PixelFormat * src, SDL_PixelFormat * dst, int *identical)\n{\n    /* Generate a 256 color dither palette */\n    SDL_Palette dithered;\n    SDL_Color colors[256];\n    SDL_Palette *pal = dst->palette;\n\n    dithered.ncolors = 256;\n    SDL_DitherColors(colors, 8);\n    dithered.colors = colors;\n    return (Map1to1(&dithered, pal, identical));\n}\n\nSDL_BlitMap *\nSDL_AllocBlitMap(void)\n{\n    SDL_BlitMap *map;\n\n    /* Allocate the empty map */\n    map = (SDL_BlitMap *) SDL_calloc(1, sizeof(*map));\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n    map->info.r = 0xFF;\n    map->info.g = 0xFF;\n    map->info.b = 0xFF;\n    map->info.a = 0xFF;\n\n    /* It's ready to go */\n    return (map);\n}\n\n\ntypedef struct SDL_ListNode\n{\n    void *entry;\n    struct SDL_ListNode *next;\n} SDL_ListNode;\n\nvoid\nSDL_InvalidateAllBlitMap(SDL_Surface *surface)\n{\n    SDL_ListNode *l = surface->list_blitmap;\n\n    surface->list_blitmap = NULL;\n\n    while (l) {\n        SDL_ListNode *tmp = l;\n        SDL_InvalidateMap((SDL_BlitMap *)l->entry);\n        l = l->next;\n        SDL_free(tmp);\n    }\n}\n\nstatic void SDL_ListAdd(SDL_ListNode **head, void *ent);\nstatic void SDL_ListRemove(SDL_ListNode **head, void *ent);\n\nvoid\nSDL_ListAdd(SDL_ListNode **head, void *ent)\n{\n    SDL_ListNode *node = SDL_malloc(sizeof (*node));\n\n    if (node == NULL) {\n        SDL_OutOfMemory();\n        return;\n    }\n\n    node->entry = ent;\n    node->next = *head;\n    *head = node;\n}\n\nvoid\nSDL_ListRemove(SDL_ListNode **head, void *ent)\n{\n    SDL_ListNode **ptr = head;\n\n    while (*ptr) {\n        if ((*ptr)->entry == ent) {\n            SDL_ListNode *tmp = *ptr;\n            *ptr = (*ptr)->next;\n            SDL_free(tmp);\n            return;\n        }\n        ptr = &(*ptr)->next;\n    }\n}\n\nvoid\nSDL_InvalidateMap(SDL_BlitMap * map)\n{\n    if (!map) {\n        return;\n    }\n    if (map->dst) {\n        /* Un-register from the destination surface */\n        SDL_ListRemove((SDL_ListNode **)&(map->dst->list_blitmap), map);\n    }\n    map->dst = NULL;\n    map->src_palette_version = 0;\n    map->dst_palette_version = 0;\n    SDL_free(map->info.table);\n    map->info.table = NULL;\n}\n\nint\nSDL_MapSurface(SDL_Surface * src, SDL_Surface * dst)\n{\n    SDL_PixelFormat *srcfmt;\n    SDL_PixelFormat *dstfmt;\n    SDL_BlitMap *map;\n\n    /* Clear out any previous mapping */\n    map = src->map;\n#if SDL_HAVE_RLE\n    if ((src->flags & SDL_RLEACCEL) == SDL_RLEACCEL) {\n        SDL_UnRLESurface(src, 1);\n    }\n#endif\n    SDL_InvalidateMap(map);\n\n    /* Figure out what kind of mapping we're doing */\n    map->identity = 0;\n    srcfmt = src->format;\n    dstfmt = dst->format;\n    if (SDL_ISPIXELFORMAT_INDEXED(srcfmt->format)) {\n        if (SDL_ISPIXELFORMAT_INDEXED(dstfmt->format)) {\n            /* Palette --> Palette */\n            map->info.table =\n                Map1to1(srcfmt->palette, dstfmt->palette, &map->identity);\n            if (!map->identity) {\n                if (map->info.table == NULL) {\n                    return (-1);\n                }\n            }\n            if (srcfmt->BitsPerPixel != dstfmt->BitsPerPixel)\n                map->identity = 0;\n        } else {\n            /* Palette --> BitField */\n            map->info.table =\n                Map1toN(srcfmt, src->map->info.r, src->map->info.g,\n                        src->map->info.b, src->map->info.a, dstfmt);\n            if (map->info.table == NULL) {\n                return (-1);\n            }\n        }\n    } else {\n        if (SDL_ISPIXELFORMAT_INDEXED(dstfmt->format)) {\n            /* BitField --> Palette */\n            map->info.table = MapNto1(srcfmt, dstfmt, &map->identity);\n            if (!map->identity) {\n                if (map->info.table == NULL) {\n                    return (-1);\n                }\n            }\n            map->identity = 0;  /* Don't optimize to copy */\n        } else {\n            /* BitField --> BitField */\n            if (srcfmt == dstfmt) {\n                map->identity = 1;\n            }\n        }\n    }\n\n    map->dst = dst;\n\n    if (map->dst) {\n        /* Register BlitMap to the destination surface, to be invalidated when needed */\n        SDL_ListAdd((SDL_ListNode **)&(map->dst->list_blitmap), map);\n    }\n\n    if (dstfmt->palette) {\n        map->dst_palette_version = dstfmt->palette->version;\n    } else {\n        map->dst_palette_version = 0;\n    }\n\n    if (srcfmt->palette) {\n        map->src_palette_version = srcfmt->palette->version;\n    } else {\n        map->src_palette_version = 0;\n    }\n\n    /* Choose your blitters wisely */\n    return (SDL_CalculateBlit(src));\n}\n\nvoid\nSDL_FreeBlitMap(SDL_BlitMap * map)\n{\n    if (map) {\n        SDL_InvalidateMap(map);\n        SDL_free(map);\n    }\n}\n\nvoid\nSDL_CalculateGammaRamp(float gamma, Uint16 * ramp)\n{\n    int i;\n\n    /* Input validation */\n    if (gamma < 0.0f ) {\n      SDL_InvalidParamError(\"gamma\");\n      return;\n    }\n    if (ramp == NULL) {\n      SDL_InvalidParamError(\"ramp\");\n      return;\n    }\n\n    /* 0.0 gamma is all black */\n    if (gamma == 0.0f) {\n        SDL_memset(ramp, 0, 256 * sizeof(Uint16));\n        return;\n    } else if (gamma == 1.0f) {\n        /* 1.0 gamma is identity */\n        for (i = 0; i < 256; ++i) {\n            ramp[i] = (i << 8) | i;\n        }\n        return;\n    } else {\n        /* Calculate a real gamma ramp */\n        int value;\n        gamma = 1.0f / gamma;\n        for (i = 0; i < 256; ++i) {\n            value =\n                (int) (SDL_pow((double) i / 256.0, gamma) * 65535.0 + 0.5);\n            if (value > 65535) {\n                value = 65535;\n            }\n            ramp[i] = (Uint16) value;\n        }\n    }\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n"], "filenames": ["src/video/SDL_pixels.c"], "buggy_code_start_loc": [950], "buggy_code_end_loc": [975], "fixing_code_start_loc": [950], "fixing_code_end_loc": [975], "type": "CWE-787", "message": "There is a heap overflow problem in video/SDL_pixels.c in SDL (Simple DirectMedia Layer) 2.x to 2.0.18 versions. By crafting a malicious .BMP file, an attacker can cause the application using this library to crash, denial of service or Code execution.", "other": {"cve": {"id": "CVE-2021-33657", "sourceIdentifier": "securities@openeuler.org", "published": "2022-04-01T23:15:10.363", "lastModified": "2023-05-03T12:15:15.760", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "There is a heap overflow problem in video/SDL_pixels.c in SDL (Simple DirectMedia Layer) 2.x to 2.0.18 versions. By crafting a malicious .BMP file, an attacker can cause the application using this library to crash, denial of service or Code execution."}, {"lang": "es", "value": "Se presenta un problema de desbordamiento de pila en el archivo video/SDL_pixels.c en SDL (Simple DirectMedia Layer) versiones  2.x a 2.0.18. Al dise\u00f1ar un archivo .BMP malicioso, un atacante puede causar el bloqueo de la aplicaci\u00f3n que usa esta biblioteca, una denegaci\u00f3n de servicio o una ejecuci\u00f3n de C\u00f3digo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libsdl:simple_directmedia_layer:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.0", "versionEndIncluding": "2.0.18", "matchCriteriaId": "EE7DAB0C-E8AB-4BE0-9AF1-584F0BBD810D"}]}]}], "references": [{"url": "https://github.com/libsdl-org/SDL/commit/8c91cf7dba5193f5ce12d06db1336515851c9ee9", "source": "securities@openeuler.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/02/msg00008.html", "source": "securities@openeuler.org"}, {"url": "https://security.gentoo.org/glsa/202305-17", "source": "securities@openeuler.org"}, {"url": "https://security.gentoo.org/glsa/202305-18", "source": "securities@openeuler.org"}]}, "github_commit_url": "https://github.com/libsdl-org/SDL/commit/8c91cf7dba5193f5ce12d06db1336515851c9ee9"}}