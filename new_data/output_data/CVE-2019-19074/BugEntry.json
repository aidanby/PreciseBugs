{"buggy_code": ["/*\n * Copyright (c) 2010-2011 Atheros Communications Inc.\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include \"htc.h\"\n\nstatic const char *wmi_cmd_to_name(enum wmi_cmd_id wmi_cmd)\n{\n\tswitch (wmi_cmd) {\n\tcase WMI_ECHO_CMDID:\n\t\treturn \"WMI_ECHO_CMDID\";\n\tcase WMI_ACCESS_MEMORY_CMDID:\n\t\treturn \"WMI_ACCESS_MEMORY_CMDID\";\n\tcase WMI_GET_FW_VERSION:\n\t\treturn \"WMI_GET_FW_VERSION\";\n\tcase WMI_DISABLE_INTR_CMDID:\n\t\treturn \"WMI_DISABLE_INTR_CMDID\";\n\tcase WMI_ENABLE_INTR_CMDID:\n\t\treturn \"WMI_ENABLE_INTR_CMDID\";\n\tcase WMI_ATH_INIT_CMDID:\n\t\treturn \"WMI_ATH_INIT_CMDID\";\n\tcase WMI_ABORT_TXQ_CMDID:\n\t\treturn \"WMI_ABORT_TXQ_CMDID\";\n\tcase WMI_STOP_TX_DMA_CMDID:\n\t\treturn \"WMI_STOP_TX_DMA_CMDID\";\n\tcase WMI_ABORT_TX_DMA_CMDID:\n\t\treturn \"WMI_ABORT_TX_DMA_CMDID\";\n\tcase WMI_DRAIN_TXQ_CMDID:\n\t\treturn \"WMI_DRAIN_TXQ_CMDID\";\n\tcase WMI_DRAIN_TXQ_ALL_CMDID:\n\t\treturn \"WMI_DRAIN_TXQ_ALL_CMDID\";\n\tcase WMI_START_RECV_CMDID:\n\t\treturn \"WMI_START_RECV_CMDID\";\n\tcase WMI_STOP_RECV_CMDID:\n\t\treturn \"WMI_STOP_RECV_CMDID\";\n\tcase WMI_FLUSH_RECV_CMDID:\n\t\treturn \"WMI_FLUSH_RECV_CMDID\";\n\tcase WMI_SET_MODE_CMDID:\n\t\treturn \"WMI_SET_MODE_CMDID\";\n\tcase WMI_NODE_CREATE_CMDID:\n\t\treturn \"WMI_NODE_CREATE_CMDID\";\n\tcase WMI_NODE_REMOVE_CMDID:\n\t\treturn \"WMI_NODE_REMOVE_CMDID\";\n\tcase WMI_VAP_REMOVE_CMDID:\n\t\treturn \"WMI_VAP_REMOVE_CMDID\";\n\tcase WMI_VAP_CREATE_CMDID:\n\t\treturn \"WMI_VAP_CREATE_CMDID\";\n\tcase WMI_REG_READ_CMDID:\n\t\treturn \"WMI_REG_READ_CMDID\";\n\tcase WMI_REG_WRITE_CMDID:\n\t\treturn \"WMI_REG_WRITE_CMDID\";\n\tcase WMI_REG_RMW_CMDID:\n\t\treturn \"WMI_REG_RMW_CMDID\";\n\tcase WMI_RC_STATE_CHANGE_CMDID:\n\t\treturn \"WMI_RC_STATE_CHANGE_CMDID\";\n\tcase WMI_RC_RATE_UPDATE_CMDID:\n\t\treturn \"WMI_RC_RATE_UPDATE_CMDID\";\n\tcase WMI_TARGET_IC_UPDATE_CMDID:\n\t\treturn \"WMI_TARGET_IC_UPDATE_CMDID\";\n\tcase WMI_TX_AGGR_ENABLE_CMDID:\n\t\treturn \"WMI_TX_AGGR_ENABLE_CMDID\";\n\tcase WMI_TGT_DETACH_CMDID:\n\t\treturn \"WMI_TGT_DETACH_CMDID\";\n\tcase WMI_NODE_UPDATE_CMDID:\n\t\treturn \"WMI_NODE_UPDATE_CMDID\";\n\tcase WMI_INT_STATS_CMDID:\n\t\treturn \"WMI_INT_STATS_CMDID\";\n\tcase WMI_TX_STATS_CMDID:\n\t\treturn \"WMI_TX_STATS_CMDID\";\n\tcase WMI_RX_STATS_CMDID:\n\t\treturn \"WMI_RX_STATS_CMDID\";\n\tcase WMI_BITRATE_MASK_CMDID:\n\t\treturn \"WMI_BITRATE_MASK_CMDID\";\n\t}\n\n\treturn \"Bogus\";\n}\n\nstruct wmi *ath9k_init_wmi(struct ath9k_htc_priv *priv)\n{\n\tstruct wmi *wmi;\n\n\twmi = kzalloc(sizeof(struct wmi), GFP_KERNEL);\n\tif (!wmi)\n\t\treturn NULL;\n\n\twmi->drv_priv = priv;\n\twmi->stopped = false;\n\tskb_queue_head_init(&wmi->wmi_event_queue);\n\tspin_lock_init(&wmi->wmi_lock);\n\tspin_lock_init(&wmi->event_lock);\n\tmutex_init(&wmi->op_mutex);\n\tmutex_init(&wmi->multi_write_mutex);\n\tmutex_init(&wmi->multi_rmw_mutex);\n\tinit_completion(&wmi->cmd_wait);\n\tINIT_LIST_HEAD(&wmi->pending_tx_events);\n\ttasklet_init(&wmi->wmi_event_tasklet, ath9k_wmi_event_tasklet,\n\t\t     (unsigned long)wmi);\n\n\treturn wmi;\n}\n\nvoid ath9k_deinit_wmi(struct ath9k_htc_priv *priv)\n{\n\tstruct wmi *wmi = priv->wmi;\n\n\tmutex_lock(&wmi->op_mutex);\n\twmi->stopped = true;\n\tmutex_unlock(&wmi->op_mutex);\n\n\tkfree(priv->wmi);\n}\n\nvoid ath9k_wmi_event_drain(struct ath9k_htc_priv *priv)\n{\n\tunsigned long flags;\n\n\ttasklet_kill(&priv->wmi->wmi_event_tasklet);\n\tspin_lock_irqsave(&priv->wmi->wmi_lock, flags);\n\t__skb_queue_purge(&priv->wmi->wmi_event_queue);\n\tspin_unlock_irqrestore(&priv->wmi->wmi_lock, flags);\n}\n\nvoid ath9k_wmi_event_tasklet(unsigned long data)\n{\n\tstruct wmi *wmi = (struct wmi *)data;\n\tstruct ath9k_htc_priv *priv = wmi->drv_priv;\n\tstruct wmi_cmd_hdr *hdr;\n\tvoid *wmi_event;\n\tstruct wmi_event_swba *swba;\n\tstruct sk_buff *skb = NULL;\n\tunsigned long flags;\n\tu16 cmd_id;\n\n\tdo {\n\t\tspin_lock_irqsave(&wmi->wmi_lock, flags);\n\t\tskb = __skb_dequeue(&wmi->wmi_event_queue);\n\t\tif (!skb) {\n\t\t\tspin_unlock_irqrestore(&wmi->wmi_lock, flags);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock_irqrestore(&wmi->wmi_lock, flags);\n\n\t\thdr = (struct wmi_cmd_hdr *) skb->data;\n\t\tcmd_id = be16_to_cpu(hdr->command_id);\n\t\twmi_event = skb_pull(skb, sizeof(struct wmi_cmd_hdr));\n\n\t\tswitch (cmd_id) {\n\t\tcase WMI_SWBA_EVENTID:\n\t\t\tswba = wmi_event;\n\t\t\tath9k_htc_swba(priv, swba);\n\t\t\tbreak;\n\t\tcase WMI_FATAL_EVENTID:\n\t\t\tieee80211_queue_work(wmi->drv_priv->hw,\n\t\t\t\t\t     &wmi->drv_priv->fatal_work);\n\t\t\tbreak;\n\t\tcase WMI_TXSTATUS_EVENTID:\n\t\t\tspin_lock_bh(&priv->tx.tx_lock);\n\t\t\tif (priv->tx.flags & ATH9K_HTC_OP_TX_DRAIN) {\n\t\t\t\tspin_unlock_bh(&priv->tx.tx_lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_unlock_bh(&priv->tx.tx_lock);\n\n\t\t\tath9k_htc_txstatus(priv, wmi_event);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tkfree_skb(skb);\n\t} while (1);\n}\n\nvoid ath9k_fatal_work(struct work_struct *work)\n{\n\tstruct ath9k_htc_priv *priv = container_of(work, struct ath9k_htc_priv,\n\t\t\t\t\t\t   fatal_work);\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\n\tath_dbg(common, FATAL, \"FATAL Event received, resetting device\\n\");\n\tath9k_htc_reset(priv);\n}\n\nstatic void ath9k_wmi_rsp_callback(struct wmi *wmi, struct sk_buff *skb)\n{\n\tskb_pull(skb, sizeof(struct wmi_cmd_hdr));\n\n\tif (wmi->cmd_rsp_buf != NULL && wmi->cmd_rsp_len != 0)\n\t\tmemcpy(wmi->cmd_rsp_buf, skb->data, wmi->cmd_rsp_len);\n\n\tcomplete(&wmi->cmd_wait);\n}\n\nstatic void ath9k_wmi_ctrl_rx(void *priv, struct sk_buff *skb,\n\t\t\t      enum htc_endpoint_id epid)\n{\n\tstruct wmi *wmi = priv;\n\tstruct wmi_cmd_hdr *hdr;\n\tunsigned long flags;\n\tu16 cmd_id;\n\n\tif (unlikely(wmi->stopped))\n\t\tgoto free_skb;\n\n\thdr = (struct wmi_cmd_hdr *) skb->data;\n\tcmd_id = be16_to_cpu(hdr->command_id);\n\n\tif (cmd_id & 0x1000) {\n\t\tspin_lock_irqsave(&wmi->wmi_lock, flags);\n\t\t__skb_queue_tail(&wmi->wmi_event_queue, skb);\n\t\tspin_unlock_irqrestore(&wmi->wmi_lock, flags);\n\t\ttasklet_schedule(&wmi->wmi_event_tasklet);\n\t\treturn;\n\t}\n\n\t/* Check if there has been a timeout. */\n\tspin_lock_irqsave(&wmi->wmi_lock, flags);\n\tif (be16_to_cpu(hdr->seq_no) != wmi->last_seq_id) {\n\t\tspin_unlock_irqrestore(&wmi->wmi_lock, flags);\n\t\tgoto free_skb;\n\t}\n\tspin_unlock_irqrestore(&wmi->wmi_lock, flags);\n\n\t/* WMI command response */\n\tath9k_wmi_rsp_callback(wmi, skb);\n\nfree_skb:\n\tkfree_skb(skb);\n}\n\nstatic void ath9k_wmi_ctrl_tx(void *priv, struct sk_buff *skb,\n\t\t\t      enum htc_endpoint_id epid, bool txok)\n{\n\tkfree_skb(skb);\n}\n\nint ath9k_wmi_connect(struct htc_target *htc, struct wmi *wmi,\n\t\t      enum htc_endpoint_id *wmi_ctrl_epid)\n{\n\tstruct htc_service_connreq connect;\n\tint ret;\n\n\twmi->htc = htc;\n\n\tmemset(&connect, 0, sizeof(connect));\n\n\tconnect.ep_callbacks.priv = wmi;\n\tconnect.ep_callbacks.tx = ath9k_wmi_ctrl_tx;\n\tconnect.ep_callbacks.rx = ath9k_wmi_ctrl_rx;\n\tconnect.service_id = WMI_CONTROL_SVC;\n\n\tret = htc_connect_service(htc, &connect, &wmi->ctrl_epid);\n\tif (ret)\n\t\treturn ret;\n\n\t*wmi_ctrl_epid = wmi->ctrl_epid;\n\n\treturn 0;\n}\n\nstatic int ath9k_wmi_cmd_issue(struct wmi *wmi,\n\t\t\t       struct sk_buff *skb,\n\t\t\t       enum wmi_cmd_id cmd, u16 len)\n{\n\tstruct wmi_cmd_hdr *hdr;\n\tunsigned long flags;\n\n\thdr = skb_push(skb, sizeof(struct wmi_cmd_hdr));\n\thdr->command_id = cpu_to_be16(cmd);\n\thdr->seq_no = cpu_to_be16(++wmi->tx_seq_id);\n\n\tspin_lock_irqsave(&wmi->wmi_lock, flags);\n\twmi->last_seq_id = wmi->tx_seq_id;\n\tspin_unlock_irqrestore(&wmi->wmi_lock, flags);\n\n\treturn htc_send_epid(wmi->htc, skb, wmi->ctrl_epid);\n}\n\nint ath9k_wmi_cmd(struct wmi *wmi, enum wmi_cmd_id cmd_id,\n\t\t  u8 *cmd_buf, u32 cmd_len,\n\t\t  u8 *rsp_buf, u32 rsp_len,\n\t\t  u32 timeout)\n{\n\tstruct ath_hw *ah = wmi->drv_priv->ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tu16 headroom = sizeof(struct htc_frame_hdr) +\n\t\t       sizeof(struct wmi_cmd_hdr);\n\tstruct sk_buff *skb;\n\tunsigned long time_left;\n\tint ret = 0;\n\n\tif (ah->ah_flags & AH_UNPLUGGED)\n\t\treturn 0;\n\n\tskb = alloc_skb(headroom + cmd_len, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_reserve(skb, headroom);\n\n\tif (cmd_len != 0 && cmd_buf != NULL) {\n\t\tskb_put_data(skb, cmd_buf, cmd_len);\n\t}\n\n\tmutex_lock(&wmi->op_mutex);\n\n\t/* check if wmi stopped flag is set */\n\tif (unlikely(wmi->stopped)) {\n\t\tret = -EPROTO;\n\t\tgoto out;\n\t}\n\n\t/* record the rsp buffer and length */\n\twmi->cmd_rsp_buf = rsp_buf;\n\twmi->cmd_rsp_len = rsp_len;\n\n\tret = ath9k_wmi_cmd_issue(wmi, skb, cmd_id, cmd_len);\n\tif (ret)\n\t\tgoto out;\n\n\ttime_left = wait_for_completion_timeout(&wmi->cmd_wait, timeout);\n\tif (!time_left) {\n\t\tath_dbg(common, WMI, \"Timeout waiting for WMI command: %s\\n\",\n\t\t\twmi_cmd_to_name(cmd_id));\n\t\tmutex_unlock(&wmi->op_mutex);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tmutex_unlock(&wmi->op_mutex);\n\n\treturn 0;\n\nout:\n\tath_dbg(common, WMI, \"WMI failure for: %s\\n\", wmi_cmd_to_name(cmd_id));\n\tmutex_unlock(&wmi->op_mutex);\n\tkfree_skb(skb);\n\n\treturn ret;\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2010-2011 Atheros Communications Inc.\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include \"htc.h\"\n\nstatic const char *wmi_cmd_to_name(enum wmi_cmd_id wmi_cmd)\n{\n\tswitch (wmi_cmd) {\n\tcase WMI_ECHO_CMDID:\n\t\treturn \"WMI_ECHO_CMDID\";\n\tcase WMI_ACCESS_MEMORY_CMDID:\n\t\treturn \"WMI_ACCESS_MEMORY_CMDID\";\n\tcase WMI_GET_FW_VERSION:\n\t\treturn \"WMI_GET_FW_VERSION\";\n\tcase WMI_DISABLE_INTR_CMDID:\n\t\treturn \"WMI_DISABLE_INTR_CMDID\";\n\tcase WMI_ENABLE_INTR_CMDID:\n\t\treturn \"WMI_ENABLE_INTR_CMDID\";\n\tcase WMI_ATH_INIT_CMDID:\n\t\treturn \"WMI_ATH_INIT_CMDID\";\n\tcase WMI_ABORT_TXQ_CMDID:\n\t\treturn \"WMI_ABORT_TXQ_CMDID\";\n\tcase WMI_STOP_TX_DMA_CMDID:\n\t\treturn \"WMI_STOP_TX_DMA_CMDID\";\n\tcase WMI_ABORT_TX_DMA_CMDID:\n\t\treturn \"WMI_ABORT_TX_DMA_CMDID\";\n\tcase WMI_DRAIN_TXQ_CMDID:\n\t\treturn \"WMI_DRAIN_TXQ_CMDID\";\n\tcase WMI_DRAIN_TXQ_ALL_CMDID:\n\t\treturn \"WMI_DRAIN_TXQ_ALL_CMDID\";\n\tcase WMI_START_RECV_CMDID:\n\t\treturn \"WMI_START_RECV_CMDID\";\n\tcase WMI_STOP_RECV_CMDID:\n\t\treturn \"WMI_STOP_RECV_CMDID\";\n\tcase WMI_FLUSH_RECV_CMDID:\n\t\treturn \"WMI_FLUSH_RECV_CMDID\";\n\tcase WMI_SET_MODE_CMDID:\n\t\treturn \"WMI_SET_MODE_CMDID\";\n\tcase WMI_NODE_CREATE_CMDID:\n\t\treturn \"WMI_NODE_CREATE_CMDID\";\n\tcase WMI_NODE_REMOVE_CMDID:\n\t\treturn \"WMI_NODE_REMOVE_CMDID\";\n\tcase WMI_VAP_REMOVE_CMDID:\n\t\treturn \"WMI_VAP_REMOVE_CMDID\";\n\tcase WMI_VAP_CREATE_CMDID:\n\t\treturn \"WMI_VAP_CREATE_CMDID\";\n\tcase WMI_REG_READ_CMDID:\n\t\treturn \"WMI_REG_READ_CMDID\";\n\tcase WMI_REG_WRITE_CMDID:\n\t\treturn \"WMI_REG_WRITE_CMDID\";\n\tcase WMI_REG_RMW_CMDID:\n\t\treturn \"WMI_REG_RMW_CMDID\";\n\tcase WMI_RC_STATE_CHANGE_CMDID:\n\t\treturn \"WMI_RC_STATE_CHANGE_CMDID\";\n\tcase WMI_RC_RATE_UPDATE_CMDID:\n\t\treturn \"WMI_RC_RATE_UPDATE_CMDID\";\n\tcase WMI_TARGET_IC_UPDATE_CMDID:\n\t\treturn \"WMI_TARGET_IC_UPDATE_CMDID\";\n\tcase WMI_TX_AGGR_ENABLE_CMDID:\n\t\treturn \"WMI_TX_AGGR_ENABLE_CMDID\";\n\tcase WMI_TGT_DETACH_CMDID:\n\t\treturn \"WMI_TGT_DETACH_CMDID\";\n\tcase WMI_NODE_UPDATE_CMDID:\n\t\treturn \"WMI_NODE_UPDATE_CMDID\";\n\tcase WMI_INT_STATS_CMDID:\n\t\treturn \"WMI_INT_STATS_CMDID\";\n\tcase WMI_TX_STATS_CMDID:\n\t\treturn \"WMI_TX_STATS_CMDID\";\n\tcase WMI_RX_STATS_CMDID:\n\t\treturn \"WMI_RX_STATS_CMDID\";\n\tcase WMI_BITRATE_MASK_CMDID:\n\t\treturn \"WMI_BITRATE_MASK_CMDID\";\n\t}\n\n\treturn \"Bogus\";\n}\n\nstruct wmi *ath9k_init_wmi(struct ath9k_htc_priv *priv)\n{\n\tstruct wmi *wmi;\n\n\twmi = kzalloc(sizeof(struct wmi), GFP_KERNEL);\n\tif (!wmi)\n\t\treturn NULL;\n\n\twmi->drv_priv = priv;\n\twmi->stopped = false;\n\tskb_queue_head_init(&wmi->wmi_event_queue);\n\tspin_lock_init(&wmi->wmi_lock);\n\tspin_lock_init(&wmi->event_lock);\n\tmutex_init(&wmi->op_mutex);\n\tmutex_init(&wmi->multi_write_mutex);\n\tmutex_init(&wmi->multi_rmw_mutex);\n\tinit_completion(&wmi->cmd_wait);\n\tINIT_LIST_HEAD(&wmi->pending_tx_events);\n\ttasklet_init(&wmi->wmi_event_tasklet, ath9k_wmi_event_tasklet,\n\t\t     (unsigned long)wmi);\n\n\treturn wmi;\n}\n\nvoid ath9k_deinit_wmi(struct ath9k_htc_priv *priv)\n{\n\tstruct wmi *wmi = priv->wmi;\n\n\tmutex_lock(&wmi->op_mutex);\n\twmi->stopped = true;\n\tmutex_unlock(&wmi->op_mutex);\n\n\tkfree(priv->wmi);\n}\n\nvoid ath9k_wmi_event_drain(struct ath9k_htc_priv *priv)\n{\n\tunsigned long flags;\n\n\ttasklet_kill(&priv->wmi->wmi_event_tasklet);\n\tspin_lock_irqsave(&priv->wmi->wmi_lock, flags);\n\t__skb_queue_purge(&priv->wmi->wmi_event_queue);\n\tspin_unlock_irqrestore(&priv->wmi->wmi_lock, flags);\n}\n\nvoid ath9k_wmi_event_tasklet(unsigned long data)\n{\n\tstruct wmi *wmi = (struct wmi *)data;\n\tstruct ath9k_htc_priv *priv = wmi->drv_priv;\n\tstruct wmi_cmd_hdr *hdr;\n\tvoid *wmi_event;\n\tstruct wmi_event_swba *swba;\n\tstruct sk_buff *skb = NULL;\n\tunsigned long flags;\n\tu16 cmd_id;\n\n\tdo {\n\t\tspin_lock_irqsave(&wmi->wmi_lock, flags);\n\t\tskb = __skb_dequeue(&wmi->wmi_event_queue);\n\t\tif (!skb) {\n\t\t\tspin_unlock_irqrestore(&wmi->wmi_lock, flags);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock_irqrestore(&wmi->wmi_lock, flags);\n\n\t\thdr = (struct wmi_cmd_hdr *) skb->data;\n\t\tcmd_id = be16_to_cpu(hdr->command_id);\n\t\twmi_event = skb_pull(skb, sizeof(struct wmi_cmd_hdr));\n\n\t\tswitch (cmd_id) {\n\t\tcase WMI_SWBA_EVENTID:\n\t\t\tswba = wmi_event;\n\t\t\tath9k_htc_swba(priv, swba);\n\t\t\tbreak;\n\t\tcase WMI_FATAL_EVENTID:\n\t\t\tieee80211_queue_work(wmi->drv_priv->hw,\n\t\t\t\t\t     &wmi->drv_priv->fatal_work);\n\t\t\tbreak;\n\t\tcase WMI_TXSTATUS_EVENTID:\n\t\t\tspin_lock_bh(&priv->tx.tx_lock);\n\t\t\tif (priv->tx.flags & ATH9K_HTC_OP_TX_DRAIN) {\n\t\t\t\tspin_unlock_bh(&priv->tx.tx_lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_unlock_bh(&priv->tx.tx_lock);\n\n\t\t\tath9k_htc_txstatus(priv, wmi_event);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tkfree_skb(skb);\n\t} while (1);\n}\n\nvoid ath9k_fatal_work(struct work_struct *work)\n{\n\tstruct ath9k_htc_priv *priv = container_of(work, struct ath9k_htc_priv,\n\t\t\t\t\t\t   fatal_work);\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\n\tath_dbg(common, FATAL, \"FATAL Event received, resetting device\\n\");\n\tath9k_htc_reset(priv);\n}\n\nstatic void ath9k_wmi_rsp_callback(struct wmi *wmi, struct sk_buff *skb)\n{\n\tskb_pull(skb, sizeof(struct wmi_cmd_hdr));\n\n\tif (wmi->cmd_rsp_buf != NULL && wmi->cmd_rsp_len != 0)\n\t\tmemcpy(wmi->cmd_rsp_buf, skb->data, wmi->cmd_rsp_len);\n\n\tcomplete(&wmi->cmd_wait);\n}\n\nstatic void ath9k_wmi_ctrl_rx(void *priv, struct sk_buff *skb,\n\t\t\t      enum htc_endpoint_id epid)\n{\n\tstruct wmi *wmi = priv;\n\tstruct wmi_cmd_hdr *hdr;\n\tunsigned long flags;\n\tu16 cmd_id;\n\n\tif (unlikely(wmi->stopped))\n\t\tgoto free_skb;\n\n\thdr = (struct wmi_cmd_hdr *) skb->data;\n\tcmd_id = be16_to_cpu(hdr->command_id);\n\n\tif (cmd_id & 0x1000) {\n\t\tspin_lock_irqsave(&wmi->wmi_lock, flags);\n\t\t__skb_queue_tail(&wmi->wmi_event_queue, skb);\n\t\tspin_unlock_irqrestore(&wmi->wmi_lock, flags);\n\t\ttasklet_schedule(&wmi->wmi_event_tasklet);\n\t\treturn;\n\t}\n\n\t/* Check if there has been a timeout. */\n\tspin_lock_irqsave(&wmi->wmi_lock, flags);\n\tif (be16_to_cpu(hdr->seq_no) != wmi->last_seq_id) {\n\t\tspin_unlock_irqrestore(&wmi->wmi_lock, flags);\n\t\tgoto free_skb;\n\t}\n\tspin_unlock_irqrestore(&wmi->wmi_lock, flags);\n\n\t/* WMI command response */\n\tath9k_wmi_rsp_callback(wmi, skb);\n\nfree_skb:\n\tkfree_skb(skb);\n}\n\nstatic void ath9k_wmi_ctrl_tx(void *priv, struct sk_buff *skb,\n\t\t\t      enum htc_endpoint_id epid, bool txok)\n{\n\tkfree_skb(skb);\n}\n\nint ath9k_wmi_connect(struct htc_target *htc, struct wmi *wmi,\n\t\t      enum htc_endpoint_id *wmi_ctrl_epid)\n{\n\tstruct htc_service_connreq connect;\n\tint ret;\n\n\twmi->htc = htc;\n\n\tmemset(&connect, 0, sizeof(connect));\n\n\tconnect.ep_callbacks.priv = wmi;\n\tconnect.ep_callbacks.tx = ath9k_wmi_ctrl_tx;\n\tconnect.ep_callbacks.rx = ath9k_wmi_ctrl_rx;\n\tconnect.service_id = WMI_CONTROL_SVC;\n\n\tret = htc_connect_service(htc, &connect, &wmi->ctrl_epid);\n\tif (ret)\n\t\treturn ret;\n\n\t*wmi_ctrl_epid = wmi->ctrl_epid;\n\n\treturn 0;\n}\n\nstatic int ath9k_wmi_cmd_issue(struct wmi *wmi,\n\t\t\t       struct sk_buff *skb,\n\t\t\t       enum wmi_cmd_id cmd, u16 len)\n{\n\tstruct wmi_cmd_hdr *hdr;\n\tunsigned long flags;\n\n\thdr = skb_push(skb, sizeof(struct wmi_cmd_hdr));\n\thdr->command_id = cpu_to_be16(cmd);\n\thdr->seq_no = cpu_to_be16(++wmi->tx_seq_id);\n\n\tspin_lock_irqsave(&wmi->wmi_lock, flags);\n\twmi->last_seq_id = wmi->tx_seq_id;\n\tspin_unlock_irqrestore(&wmi->wmi_lock, flags);\n\n\treturn htc_send_epid(wmi->htc, skb, wmi->ctrl_epid);\n}\n\nint ath9k_wmi_cmd(struct wmi *wmi, enum wmi_cmd_id cmd_id,\n\t\t  u8 *cmd_buf, u32 cmd_len,\n\t\t  u8 *rsp_buf, u32 rsp_len,\n\t\t  u32 timeout)\n{\n\tstruct ath_hw *ah = wmi->drv_priv->ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tu16 headroom = sizeof(struct htc_frame_hdr) +\n\t\t       sizeof(struct wmi_cmd_hdr);\n\tstruct sk_buff *skb;\n\tunsigned long time_left;\n\tint ret = 0;\n\n\tif (ah->ah_flags & AH_UNPLUGGED)\n\t\treturn 0;\n\n\tskb = alloc_skb(headroom + cmd_len, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_reserve(skb, headroom);\n\n\tif (cmd_len != 0 && cmd_buf != NULL) {\n\t\tskb_put_data(skb, cmd_buf, cmd_len);\n\t}\n\n\tmutex_lock(&wmi->op_mutex);\n\n\t/* check if wmi stopped flag is set */\n\tif (unlikely(wmi->stopped)) {\n\t\tret = -EPROTO;\n\t\tgoto out;\n\t}\n\n\t/* record the rsp buffer and length */\n\twmi->cmd_rsp_buf = rsp_buf;\n\twmi->cmd_rsp_len = rsp_len;\n\n\tret = ath9k_wmi_cmd_issue(wmi, skb, cmd_id, cmd_len);\n\tif (ret)\n\t\tgoto out;\n\n\ttime_left = wait_for_completion_timeout(&wmi->cmd_wait, timeout);\n\tif (!time_left) {\n\t\tath_dbg(common, WMI, \"Timeout waiting for WMI command: %s\\n\",\n\t\t\twmi_cmd_to_name(cmd_id));\n\t\tmutex_unlock(&wmi->op_mutex);\n\t\tkfree_skb(skb);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tmutex_unlock(&wmi->op_mutex);\n\n\treturn 0;\n\nout:\n\tath_dbg(common, WMI, \"WMI failure for: %s\\n\", wmi_cmd_to_name(cmd_id));\n\tmutex_unlock(&wmi->op_mutex);\n\tkfree_skb(skb);\n\n\treturn ret;\n}\n"], "filenames": ["drivers/net/wireless/ath/ath9k/wmi.c"], "buggy_code_start_loc": [338], "buggy_code_end_loc": [338], "fixing_code_start_loc": [339], "fixing_code_end_loc": [340], "type": "CWE-401", "message": "A memory leak in the ath9k_wmi_cmd() function in drivers/net/wireless/ath/ath9k/wmi.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption), aka CID-728c1e2a05e4.", "other": {"cve": {"id": "CVE-2019-19074", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-18T06:15:13.280", "lastModified": "2023-01-17T21:28:19.637", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A memory leak in the ath9k_wmi_cmd() function in drivers/net/wireless/ath/ath9k/wmi.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption), aka CID-728c1e2a05e4."}, {"lang": "es", "value": "Una p\u00e9rdida de memoria en la funci\u00f3n ath9k_wmi_cmd() en el archivo drivers/net/wireless/ath/ath9k/wmi.c en el kernel de Linux versiones hasta la versi\u00f3n 5.3.11, permite a atacantes causar una denegaci\u00f3n de servicio (consumo de memoria), tambi\u00e9n se conoce como CID-728c1e2a05e4."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.4.233", "matchCriteriaId": "B33AC4B6-10F8-4FE6-87EE-5FC29CD2523F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.9.233", "matchCriteriaId": "8C8067B5-99FF-47C1-81C2-C33AEADBADE9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.10", "versionEndExcluding": "4.14.192", "matchCriteriaId": "712E1CC6-B087-4811-8513-30A6E6DFAEBB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.15", "versionEndExcluding": "4.19.137", "matchCriteriaId": "924A83F4-1C2A-4B17-8E73-A155635FC9EA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.20", "versionEndExcluding": "5.4", "matchCriteriaId": "3C81B8E4-6B6E-4B60-8C86-17CEFE36F072"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-12/msg00029.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/728c1e2a05e4b5fc52fab3421dce772a806612a2", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/10/msg00032.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/10/msg00034.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/O3PSDE6PTOTVBK2YTKB2TFQP2SUBVSNF/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PY7LJMSPAGRIKABJPDKQDTXYW3L5RX2T/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20191205-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4526-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4527-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuApr2021.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/728c1e2a05e4b5fc52fab3421dce772a806612a2"}}