{"buggy_code": ["/*\n *  linux/fs/nfs/inode.c\n *\n *  Copyright (C) 1992  Rick Sladkey\n *\n *  nfs inode and superblock handling functions\n *\n *  Modularised by Alan Cox <alan@lxorguk.ukuu.org.uk>, while hacking some\n *  experimental NFS changes. Modularisation taken straight from SYS5 fs.\n *\n *  Change to nfs_read_super() to permit NFS mounts to multi-homed hosts.\n *  J.S.Peatfield@damtp.cam.ac.uk\n *\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/unistd.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs4_mount.h>\n#include <linux/lockd/bind.h>\n#include <linux/smp_lock.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/nfs_idmap.h>\n#include <linux/vfs.h>\n#include <linux/inet.h>\n#include <linux/nfs_xdr.h>\n\n#include <asm/system.h>\n#include <asm/uaccess.h>\n\n#include \"nfs4_fs.h\"\n#include \"callback.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_VFS\n\n#define NFS_64_BIT_INODE_NUMBERS_ENABLED\t1\n\n/* Default is to see 64-bit inode numbers */\nstatic int enable_ino64 = NFS_64_BIT_INODE_NUMBERS_ENABLED;\n\nstatic void nfs_invalidate_inode(struct inode *);\nstatic int nfs_update_inode(struct inode *, struct nfs_fattr *);\n\nstatic struct kmem_cache * nfs_inode_cachep;\n\nstatic inline unsigned long\nnfs_fattr_to_ino_t(struct nfs_fattr *fattr)\n{\n\treturn nfs_fileid_to_ino_t(fattr->fileid);\n}\n\n/**\n * nfs_compat_user_ino64 - returns the user-visible inode number\n * @fileid: 64-bit fileid\n *\n * This function returns a 32-bit inode number if the boot parameter\n * nfs.enable_ino64 is zero.\n */\nu64 nfs_compat_user_ino64(u64 fileid)\n{\n\tint ino;\n\n\tif (enable_ino64)\n\t\treturn fileid;\n\tino = fileid;\n\tif (sizeof(ino) < sizeof(fileid))\n\t\tino ^= fileid >> (sizeof(fileid)-sizeof(ino)) * 8;\n\treturn ino;\n}\n\nint nfs_write_inode(struct inode *inode, int sync)\n{\n\tint ret;\n\n\tif (sync) {\n\t\tret = filemap_fdatawait(inode->i_mapping);\n\t\tif (ret == 0)\n\t\t\tret = nfs_commit_inode(inode, FLUSH_SYNC);\n\t} else\n\t\tret = nfs_commit_inode(inode, 0);\n\tif (ret >= 0)\n\t\treturn 0;\n\t__mark_inode_dirty(inode, I_DIRTY_DATASYNC);\n\treturn ret;\n}\n\nvoid nfs_clear_inode(struct inode *inode)\n{\n\t/*\n\t * The following should never happen...\n\t */\n\tBUG_ON(nfs_have_writebacks(inode));\n\tBUG_ON(!list_empty(&NFS_I(inode)->open_files));\n\tnfs_zap_acl_cache(inode);\n\tnfs_access_zap_cache(inode);\n}\n\n/**\n * nfs_sync_mapping - helper to flush all mmapped dirty data to disk\n */\nint nfs_sync_mapping(struct address_space *mapping)\n{\n\tint ret;\n\n\tif (mapping->nrpages == 0)\n\t\treturn 0;\n\tunmap_mapping_range(mapping, 0, 0, 0);\n\tret = filemap_write_and_wait(mapping);\n\tif (ret != 0)\n\t\tgoto out;\n\tret = nfs_wb_all(mapping->host);\nout:\n\treturn ret;\n}\n\n/*\n * Invalidate the local caches\n */\nstatic void nfs_zap_caches_locked(struct inode *inode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tint mode = inode->i_mode;\n\n\tnfs_inc_stats(inode, NFSIOS_ATTRINVALIDATE);\n\n\tnfsi->attrtimeo = NFS_MINATTRTIMEO(inode);\n\tnfsi->attrtimeo_timestamp = jiffies;\n\n\tmemset(NFS_COOKIEVERF(inode), 0, sizeof(NFS_COOKIEVERF(inode)));\n\tif (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode))\n\t\tnfsi->cache_validity |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_DATA|NFS_INO_INVALID_ACCESS|NFS_INO_INVALID_ACL|NFS_INO_REVAL_PAGECACHE;\n\telse\n\t\tnfsi->cache_validity |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_ACCESS|NFS_INO_INVALID_ACL|NFS_INO_REVAL_PAGECACHE;\n}\n\nvoid nfs_zap_caches(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tnfs_zap_caches_locked(inode);\n\tspin_unlock(&inode->i_lock);\n}\n\nvoid nfs_zap_mapping(struct inode *inode, struct address_space *mapping)\n{\n\tif (mapping->nrpages != 0) {\n\t\tspin_lock(&inode->i_lock);\n\t\tNFS_I(inode)->cache_validity |= NFS_INO_INVALID_DATA;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n}\n\nvoid nfs_zap_acl_cache(struct inode *inode)\n{\n\tvoid (*clear_acl_cache)(struct inode *);\n\n\tclear_acl_cache = NFS_PROTO(inode)->clear_acl_cache;\n\tif (clear_acl_cache != NULL)\n\t\tclear_acl_cache(inode);\n\tspin_lock(&inode->i_lock);\n\tNFS_I(inode)->cache_validity &= ~NFS_INO_INVALID_ACL;\n\tspin_unlock(&inode->i_lock);\n}\n\nvoid nfs_invalidate_atime(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tNFS_I(inode)->cache_validity |= NFS_INO_INVALID_ATIME;\n\tspin_unlock(&inode->i_lock);\n}\n\n/*\n * Invalidate, but do not unhash, the inode.\n * NB: must be called with inode->i_lock held!\n */\nstatic void nfs_invalidate_inode(struct inode *inode)\n{\n\tset_bit(NFS_INO_STALE, &NFS_I(inode)->flags);\n\tnfs_zap_caches_locked(inode);\n}\n\nstruct nfs_find_desc {\n\tstruct nfs_fh\t\t*fh;\n\tstruct nfs_fattr\t*fattr;\n};\n\n/*\n * In NFSv3 we can have 64bit inode numbers. In order to support\n * this, and re-exported directories (also seen in NFSv2)\n * we are forced to allow 2 different inodes to have the same\n * i_ino.\n */\nstatic int\nnfs_find_actor(struct inode *inode, void *opaque)\n{\n\tstruct nfs_find_desc\t*desc = (struct nfs_find_desc *)opaque;\n\tstruct nfs_fh\t\t*fh = desc->fh;\n\tstruct nfs_fattr\t*fattr = desc->fattr;\n\n\tif (NFS_FILEID(inode) != fattr->fileid)\n\t\treturn 0;\n\tif (nfs_compare_fh(NFS_FH(inode), fh))\n\t\treturn 0;\n\tif (is_bad_inode(inode) || NFS_STALE(inode))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int\nnfs_init_locked(struct inode *inode, void *opaque)\n{\n\tstruct nfs_find_desc\t*desc = (struct nfs_find_desc *)opaque;\n\tstruct nfs_fattr\t*fattr = desc->fattr;\n\n\tset_nfs_fileid(inode, fattr->fileid);\n\tnfs_copy_fh(NFS_FH(inode), desc->fh);\n\treturn 0;\n}\n\n/* Don't use READDIRPLUS on directories that we believe are too large */\n#define NFS_LIMIT_READDIRPLUS (8*PAGE_SIZE)\n\n/*\n * This is our front-end to iget that looks up inodes by file handle\n * instead of inode number.\n */\nstruct inode *\nnfs_fhget(struct super_block *sb, struct nfs_fh *fh, struct nfs_fattr *fattr)\n{\n\tstruct nfs_find_desc desc = {\n\t\t.fh\t= fh,\n\t\t.fattr\t= fattr\n\t};\n\tstruct inode *inode = ERR_PTR(-ENOENT);\n\tunsigned long hash;\n\n\tif ((fattr->valid & NFS_ATTR_FATTR) == 0)\n\t\tgoto out_no_inode;\n\n\tif (!fattr->nlink) {\n\t\tprintk(\"NFS: Buggy server - nlink == 0!\\n\");\n\t\tgoto out_no_inode;\n\t}\n\n\thash = nfs_fattr_to_ino_t(fattr);\n\n\tinode = iget5_locked(sb, hash, nfs_find_actor, nfs_init_locked, &desc);\n\tif (inode == NULL) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tgoto out_no_inode;\n\t}\n\n\tif (inode->i_state & I_NEW) {\n\t\tstruct nfs_inode *nfsi = NFS_I(inode);\n\t\tunsigned long now = jiffies;\n\n\t\t/* We set i_ino for the few things that still rely on it,\n\t\t * such as stat(2) */\n\t\tinode->i_ino = hash;\n\n\t\t/* We can't support update_atime(), since the server will reset it */\n\t\tinode->i_flags |= S_NOATIME|S_NOCMTIME;\n\t\tinode->i_mode = fattr->mode;\n\t\t/* Why so? Because we want revalidate for devices/FIFOs, and\n\t\t * that's precisely what we have in nfs_file_inode_operations.\n\t\t */\n\t\tinode->i_op = NFS_SB(sb)->nfs_client->rpc_ops->file_inode_ops;\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tinode->i_fop = &nfs_file_operations;\n\t\t\tinode->i_data.a_ops = &nfs_file_aops;\n\t\t\tinode->i_data.backing_dev_info = &NFS_SB(sb)->backing_dev_info;\n\t\t} else if (S_ISDIR(inode->i_mode)) {\n\t\t\tinode->i_op = NFS_SB(sb)->nfs_client->rpc_ops->dir_inode_ops;\n\t\t\tinode->i_fop = &nfs_dir_operations;\n\t\t\tif (nfs_server_capable(inode, NFS_CAP_READDIRPLUS)\n\t\t\t    && fattr->size <= NFS_LIMIT_READDIRPLUS)\n\t\t\t\tset_bit(NFS_INO_ADVISE_RDPLUS, &NFS_I(inode)->flags);\n\t\t\t/* Deal with crossing mountpoints */\n\t\t\tif (!nfs_fsid_equal(&NFS_SB(sb)->fsid, &fattr->fsid)) {\n\t\t\t\tif (fattr->valid & NFS_ATTR_FATTR_V4_REFERRAL)\n\t\t\t\t\tinode->i_op = &nfs_referral_inode_operations;\n\t\t\t\telse\n\t\t\t\t\tinode->i_op = &nfs_mountpoint_inode_operations;\n\t\t\t\tinode->i_fop = NULL;\n\t\t\t\tset_bit(NFS_INO_MOUNTPOINT, &nfsi->flags);\n\t\t\t}\n\t\t} else if (S_ISLNK(inode->i_mode))\n\t\t\tinode->i_op = &nfs_symlink_inode_operations;\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode, fattr->rdev);\n\n\t\tnfsi->read_cache_jiffies = fattr->time_start;\n\t\tnfsi->attr_gencount = fattr->gencount;\n\t\tinode->i_atime = fattr->atime;\n\t\tinode->i_mtime = fattr->mtime;\n\t\tinode->i_ctime = fattr->ctime;\n\t\tif (fattr->valid & NFS_ATTR_FATTR_V4)\n\t\t\tnfsi->change_attr = fattr->change_attr;\n\t\tinode->i_size = nfs_size_to_loff_t(fattr->size);\n\t\tinode->i_nlink = fattr->nlink;\n\t\tinode->i_uid = fattr->uid;\n\t\tinode->i_gid = fattr->gid;\n\t\tif (fattr->valid & (NFS_ATTR_FATTR_V3 | NFS_ATTR_FATTR_V4)) {\n\t\t\t/*\n\t\t\t * report the blocks in 512byte units\n\t\t\t */\n\t\t\tinode->i_blocks = nfs_calc_block_size(fattr->du.nfs3.used);\n\t\t} else {\n\t\t\tinode->i_blocks = fattr->du.nfs2.blocks;\n\t\t}\n\t\tnfsi->attrtimeo = NFS_MINATTRTIMEO(inode);\n\t\tnfsi->attrtimeo_timestamp = now;\n\t\tmemset(nfsi->cookieverf, 0, sizeof(nfsi->cookieverf));\n\t\tnfsi->access_cache = RB_ROOT;\n\n\t\tunlock_new_inode(inode);\n\t} else\n\t\tnfs_refresh_inode(inode, fattr);\n\tdprintk(\"NFS: nfs_fhget(%s/%Ld ct=%d)\\n\",\n\t\tinode->i_sb->s_id,\n\t\t(long long)NFS_FILEID(inode),\n\t\tatomic_read(&inode->i_count));\n\nout:\n\treturn inode;\n\nout_no_inode:\n\tdprintk(\"nfs_fhget: iget failed with error %ld\\n\", PTR_ERR(inode));\n\tgoto out;\n}\n\n#define NFS_VALID_ATTRS (ATTR_MODE|ATTR_UID|ATTR_GID|ATTR_SIZE|ATTR_ATIME|ATTR_ATIME_SET|ATTR_MTIME|ATTR_MTIME_SET|ATTR_FILE)\n\nint\nnfs_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct nfs_fattr fattr;\n\tint error;\n\n\tnfs_inc_stats(inode, NFSIOS_VFSSETATTR);\n\n\t/* skip mode change if it's just for clearing setuid/setgid */\n\tif (attr->ia_valid & (ATTR_KILL_SUID | ATTR_KILL_SGID))\n\t\tattr->ia_valid &= ~ATTR_MODE;\n\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\tif (!S_ISREG(inode->i_mode) || attr->ia_size == i_size_read(inode))\n\t\t\tattr->ia_valid &= ~ATTR_SIZE;\n\t}\n\n\t/* Optimization: if the end result is no change, don't RPC */\n\tattr->ia_valid &= NFS_VALID_ATTRS;\n\tif ((attr->ia_valid & ~ATTR_FILE) == 0)\n\t\treturn 0;\n\n\t/* Write all dirty data */\n\tif (S_ISREG(inode->i_mode)) {\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t\tnfs_wb_all(inode);\n\t}\n\t/*\n\t * Return any delegations if we're going to change ACLs\n\t */\n\tif ((attr->ia_valid & (ATTR_MODE|ATTR_UID|ATTR_GID)) != 0)\n\t\tnfs_inode_return_delegation(inode);\n\terror = NFS_PROTO(inode)->setattr(dentry, &fattr, attr);\n\tif (error == 0)\n\t\tnfs_refresh_inode(inode, &fattr);\n\treturn error;\n}\n\n/**\n * nfs_vmtruncate - unmap mappings \"freed\" by truncate() syscall\n * @inode: inode of the file used\n * @offset: file offset to start truncating\n *\n * This is a copy of the common vmtruncate, but with the locking\n * corrected to take into account the fact that NFS requires\n * inode->i_size to be updated under the inode->i_lock.\n */\nstatic int nfs_vmtruncate(struct inode * inode, loff_t offset)\n{\n\tif (i_size_read(inode) < offset) {\n\t\tunsigned long limit;\n\n\t\tlimit = current->signal->rlim[RLIMIT_FSIZE].rlim_cur;\n\t\tif (limit != RLIM_INFINITY && offset > limit)\n\t\t\tgoto out_sig;\n\t\tif (offset > inode->i_sb->s_maxbytes)\n\t\t\tgoto out_big;\n\t\tspin_lock(&inode->i_lock);\n\t\ti_size_write(inode, offset);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\n\t\t/*\n\t\t * truncation of in-use swapfiles is disallowed - it would\n\t\t * cause subsequent swapout to scribble on the now-freed\n\t\t * blocks.\n\t\t */\n\t\tif (IS_SWAPFILE(inode))\n\t\t\treturn -ETXTBSY;\n\t\tspin_lock(&inode->i_lock);\n\t\ti_size_write(inode, offset);\n\t\tspin_unlock(&inode->i_lock);\n\n\t\t/*\n\t\t * unmap_mapping_range is called twice, first simply for\n\t\t * efficiency so that truncate_inode_pages does fewer\n\t\t * single-page unmaps.  However after this first call, and\n\t\t * before truncate_inode_pages finishes, it is possible for\n\t\t * private pages to be COWed, which remain after\n\t\t * truncate_inode_pages finishes, hence the second\n\t\t * unmap_mapping_range call must be made for correctness.\n\t\t */\n\t\tunmap_mapping_range(mapping, offset + PAGE_SIZE - 1, 0, 1);\n\t\ttruncate_inode_pages(mapping, offset);\n\t\tunmap_mapping_range(mapping, offset + PAGE_SIZE - 1, 0, 1);\n\t}\n\treturn 0;\nout_sig:\n\tsend_sig(SIGXFSZ, current, 0);\nout_big:\n\treturn -EFBIG;\n}\n\n/**\n * nfs_setattr_update_inode - Update inode metadata after a setattr call.\n * @inode: pointer to struct inode\n * @attr: pointer to struct iattr\n *\n * Note: we do this in the *proc.c in order to ensure that\n *       it works for things like exclusive creates too.\n */\nvoid nfs_setattr_update_inode(struct inode *inode, struct iattr *attr)\n{\n\tif ((attr->ia_valid & (ATTR_MODE|ATTR_UID|ATTR_GID)) != 0) {\n\t\tspin_lock(&inode->i_lock);\n\t\tif ((attr->ia_valid & ATTR_MODE) != 0) {\n\t\t\tint mode = attr->ia_mode & S_IALLUGO;\n\t\t\tmode |= inode->i_mode & ~S_IALLUGO;\n\t\t\tinode->i_mode = mode;\n\t\t}\n\t\tif ((attr->ia_valid & ATTR_UID) != 0)\n\t\t\tinode->i_uid = attr->ia_uid;\n\t\tif ((attr->ia_valid & ATTR_GID) != 0)\n\t\t\tinode->i_gid = attr->ia_gid;\n\t\tNFS_I(inode)->cache_validity |= NFS_INO_INVALID_ACCESS|NFS_INO_INVALID_ACL;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\tif ((attr->ia_valid & ATTR_SIZE) != 0) {\n\t\tnfs_inc_stats(inode, NFSIOS_SETATTRTRUNC);\n\t\tnfs_vmtruncate(inode, attr->ia_size);\n\t}\n}\n\nint nfs_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint need_atime = NFS_I(inode)->cache_validity & NFS_INO_INVALID_ATIME;\n\tint err;\n\n\t/*\n\t * Flush out writes to the server in order to update c/mtime.\n\t *\n\t * Hold the i_mutex to suspend application writes temporarily;\n\t * this prevents long-running writing applications from blocking\n\t * nfs_wb_nocommit.\n\t */\n\tif (S_ISREG(inode->i_mode)) {\n\t\tmutex_lock(&inode->i_mutex);\n\t\tnfs_wb_nocommit(inode);\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\n\t/*\n\t * We may force a getattr if the user cares about atime.\n\t *\n\t * Note that we only have to check the vfsmount flags here:\n\t *  - NFS always sets S_NOATIME by so checking it would give a\n\t *    bogus result\n\t *  - NFS never sets MS_NOATIME or MS_NODIRATIME so there is\n\t *    no point in checking those.\n\t */\n \tif ((mnt->mnt_flags & MNT_NOATIME) ||\n \t    ((mnt->mnt_flags & MNT_NODIRATIME) && S_ISDIR(inode->i_mode)))\n\t\tneed_atime = 0;\n\n\tif (need_atime)\n\t\terr = __nfs_revalidate_inode(NFS_SERVER(inode), inode);\n\telse\n\t\terr = nfs_revalidate_inode(NFS_SERVER(inode), inode);\n\tif (!err) {\n\t\tgeneric_fillattr(inode, stat);\n\t\tstat->ino = nfs_compat_user_ino64(NFS_FILEID(inode));\n\t}\n\treturn err;\n}\n\nstatic struct nfs_open_context *alloc_nfs_open_context(struct vfsmount *mnt, struct dentry *dentry, struct rpc_cred *cred)\n{\n\tstruct nfs_open_context *ctx;\n\n\tctx = kmalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (ctx != NULL) {\n\t\tctx->path.dentry = dget(dentry);\n\t\tctx->path.mnt = mntget(mnt);\n\t\tctx->cred = get_rpccred(cred);\n\t\tctx->state = NULL;\n\t\tctx->lockowner = current->files;\n\t\tctx->flags = 0;\n\t\tctx->error = 0;\n\t\tctx->dir_cookie = 0;\n\t\tatomic_set(&ctx->count, 1);\n\t}\n\treturn ctx;\n}\n\nstruct nfs_open_context *get_nfs_open_context(struct nfs_open_context *ctx)\n{\n\tif (ctx != NULL)\n\t\tatomic_inc(&ctx->count);\n\treturn ctx;\n}\n\nstatic void __put_nfs_open_context(struct nfs_open_context *ctx, int wait)\n{\n\tstruct inode *inode;\n\n\tif (ctx == NULL)\n\t\treturn;\n\n\tinode = ctx->path.dentry->d_inode;\n\tif (!atomic_dec_and_lock(&ctx->count, &inode->i_lock))\n\t\treturn;\n\tlist_del(&ctx->list);\n\tspin_unlock(&inode->i_lock);\n\tif (ctx->state != NULL) {\n\t\tif (wait)\n\t\t\tnfs4_close_sync(&ctx->path, ctx->state, ctx->mode);\n\t\telse\n\t\t\tnfs4_close_state(&ctx->path, ctx->state, ctx->mode);\n\t}\n\tif (ctx->cred != NULL)\n\t\tput_rpccred(ctx->cred);\n\tpath_put(&ctx->path);\n\tkfree(ctx);\n}\n\nvoid put_nfs_open_context(struct nfs_open_context *ctx)\n{\n\t__put_nfs_open_context(ctx, 0);\n}\n\nstatic void put_nfs_open_context_sync(struct nfs_open_context *ctx)\n{\n\t__put_nfs_open_context(ctx, 1);\n}\n\n/*\n * Ensure that mmap has a recent RPC credential for use when writing out\n * shared pages\n */\nstatic void nfs_file_set_open_context(struct file *filp, struct nfs_open_context *ctx)\n{\n\tstruct inode *inode = filp->f_path.dentry->d_inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tfilp->private_data = get_nfs_open_context(ctx);\n\tspin_lock(&inode->i_lock);\n\tlist_add(&ctx->list, &nfsi->open_files);\n\tspin_unlock(&inode->i_lock);\n}\n\n/*\n * Given an inode, search for an open context with the desired characteristics\n */\nstruct nfs_open_context *nfs_find_open_context(struct inode *inode, struct rpc_cred *cred, int mode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_open_context *pos, *ctx = NULL;\n\n\tspin_lock(&inode->i_lock);\n\tlist_for_each_entry(pos, &nfsi->open_files, list) {\n\t\tif (cred != NULL && pos->cred != cred)\n\t\t\tcontinue;\n\t\tif ((pos->mode & mode) == mode) {\n\t\t\tctx = get_nfs_open_context(pos);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn ctx;\n}\n\nstatic void nfs_file_clear_open_context(struct file *filp)\n{\n\tstruct inode *inode = filp->f_path.dentry->d_inode;\n\tstruct nfs_open_context *ctx = nfs_file_open_context(filp);\n\n\tif (ctx) {\n\t\tfilp->private_data = NULL;\n\t\tspin_lock(&inode->i_lock);\n\t\tlist_move_tail(&ctx->list, &NFS_I(inode)->open_files);\n\t\tspin_unlock(&inode->i_lock);\n\t\tput_nfs_open_context_sync(ctx);\n\t}\n}\n\n/*\n * These allocate and release file read/write context information.\n */\nint nfs_open(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct rpc_cred *cred;\n\n\tcred = rpc_lookup_cred();\n\tif (IS_ERR(cred))\n\t\treturn PTR_ERR(cred);\n\tctx = alloc_nfs_open_context(filp->f_path.mnt, filp->f_path.dentry, cred);\n\tput_rpccred(cred);\n\tif (ctx == NULL)\n\t\treturn -ENOMEM;\n\tctx->mode = filp->f_mode;\n\tnfs_file_set_open_context(filp, ctx);\n\tput_nfs_open_context(ctx);\n\treturn 0;\n}\n\nint nfs_release(struct inode *inode, struct file *filp)\n{\n\tnfs_file_clear_open_context(filp);\n\treturn 0;\n}\n\n/*\n * This function is called whenever some part of NFS notices that\n * the cached attributes have to be refreshed.\n */\nint\n__nfs_revalidate_inode(struct nfs_server *server, struct inode *inode)\n{\n\tint\t\t status = -ESTALE;\n\tstruct nfs_fattr fattr;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tdfprintk(PAGECACHE, \"NFS: revalidating (%s/%Ld)\\n\",\n\t\tinode->i_sb->s_id, (long long)NFS_FILEID(inode));\n\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\tif (NFS_STALE(inode))\n\t\tgoto out;\n\n\tif (NFS_STALE(inode))\n\t\tgoto out;\n\n\tnfs_inc_stats(inode, NFSIOS_INODEREVALIDATE);\n\tstatus = NFS_PROTO(inode)->getattr(server, NFS_FH(inode), &fattr);\n\tif (status != 0) {\n\t\tdfprintk(PAGECACHE, \"nfs_revalidate_inode: (%s/%Ld) getattr failed, error=%d\\n\",\n\t\t\t inode->i_sb->s_id,\n\t\t\t (long long)NFS_FILEID(inode), status);\n\t\tif (status == -ESTALE) {\n\t\t\tnfs_zap_caches(inode);\n\t\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\t\tset_bit(NFS_INO_STALE, &NFS_I(inode)->flags);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tstatus = nfs_refresh_inode(inode, &fattr);\n\tif (status) {\n\t\tdfprintk(PAGECACHE, \"nfs_revalidate_inode: (%s/%Ld) refresh failed, error=%d\\n\",\n\t\t\t inode->i_sb->s_id,\n\t\t\t (long long)NFS_FILEID(inode), status);\n\t\tgoto out;\n\t}\n\n\tif (nfsi->cache_validity & NFS_INO_INVALID_ACL)\n\t\tnfs_zap_acl_cache(inode);\n\n\tdfprintk(PAGECACHE, \"NFS: (%s/%Ld) revalidation complete\\n\",\n\t\tinode->i_sb->s_id,\n\t\t(long long)NFS_FILEID(inode));\n\n out:\n\treturn status;\n}\n\nint nfs_attribute_timeout(struct inode *inode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tif (nfs_have_delegation(inode, FMODE_READ))\n\t\treturn 0;\n\t/*\n\t * Special case: if the attribute timeout is set to 0, then always\n\t * \t\t treat the cache as having expired (unless holding\n\t * \t\t a delegation).\n\t */\n\tif (nfsi->attrtimeo == 0)\n\t\treturn 1;\n\treturn !time_in_range(jiffies, nfsi->read_cache_jiffies, nfsi->read_cache_jiffies + nfsi->attrtimeo);\n}\n\n/**\n * nfs_revalidate_inode - Revalidate the inode attributes\n * @server - pointer to nfs_server struct\n * @inode - pointer to inode struct\n *\n * Updates inode attribute information by retrieving the data from the server.\n */\nint nfs_revalidate_inode(struct nfs_server *server, struct inode *inode)\n{\n\tif (!(NFS_I(inode)->cache_validity & NFS_INO_INVALID_ATTR)\n\t\t\t&& !nfs_attribute_timeout(inode))\n\t\treturn NFS_STALE(inode) ? -ESTALE : 0;\n\treturn __nfs_revalidate_inode(server, inode);\n}\n\nstatic int nfs_invalidate_mapping_nolock(struct inode *inode, struct address_space *mapping)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\t\n\tif (mapping->nrpages != 0) {\n\t\tint ret = invalidate_inode_pages2(mapping);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tspin_lock(&inode->i_lock);\n\tnfsi->cache_validity &= ~NFS_INO_INVALID_DATA;\n\tif (S_ISDIR(inode->i_mode))\n\t\tmemset(nfsi->cookieverf, 0, sizeof(nfsi->cookieverf));\n\tspin_unlock(&inode->i_lock);\n\tnfs_inc_stats(inode, NFSIOS_DATAINVALIDATE);\n\tdfprintk(PAGECACHE, \"NFS: (%s/%Ld) data cache invalidated\\n\",\n\t\t\tinode->i_sb->s_id, (long long)NFS_FILEID(inode));\n\treturn 0;\n}\n\nstatic int nfs_invalidate_mapping(struct inode *inode, struct address_space *mapping)\n{\n\tint ret = 0;\n\n\tmutex_lock(&inode->i_mutex);\n\tif (NFS_I(inode)->cache_validity & NFS_INO_INVALID_DATA) {\n\t\tret = nfs_sync_mapping(mapping);\n\t\tif (ret == 0)\n\t\t\tret = nfs_invalidate_mapping_nolock(inode, mapping);\n\t}\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}\n\n/**\n * nfs_revalidate_mapping_nolock - Revalidate the pagecache\n * @inode - pointer to host inode\n * @mapping - pointer to mapping\n */\nint nfs_revalidate_mapping_nolock(struct inode *inode, struct address_space *mapping)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tint ret = 0;\n\n\tif ((nfsi->cache_validity & NFS_INO_REVAL_PAGECACHE)\n\t\t\t|| nfs_attribute_timeout(inode) || NFS_STALE(inode)) {\n\t\tret = __nfs_revalidate_inode(NFS_SERVER(inode), inode);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tif (nfsi->cache_validity & NFS_INO_INVALID_DATA)\n\t\tret = nfs_invalidate_mapping_nolock(inode, mapping);\nout:\n\treturn ret;\n}\n\n/**\n * nfs_revalidate_mapping - Revalidate the pagecache\n * @inode - pointer to host inode\n * @mapping - pointer to mapping\n *\n * This version of the function will take the inode->i_mutex and attempt to\n * flush out all dirty data if it needs to invalidate the page cache.\n */\nint nfs_revalidate_mapping(struct inode *inode, struct address_space *mapping)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tint ret = 0;\n\n\tif ((nfsi->cache_validity & NFS_INO_REVAL_PAGECACHE)\n\t\t\t|| nfs_attribute_timeout(inode) || NFS_STALE(inode)) {\n\t\tret = __nfs_revalidate_inode(NFS_SERVER(inode), inode);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tif (nfsi->cache_validity & NFS_INO_INVALID_DATA)\n\t\tret = nfs_invalidate_mapping(inode, mapping);\nout:\n\treturn ret;\n}\n\nstatic void nfs_wcc_update_inode(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tif ((fattr->valid & NFS_ATTR_WCC_V4) != 0 &&\n\t\t\tnfsi->change_attr == fattr->pre_change_attr) {\n\t\tnfsi->change_attr = fattr->change_attr;\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tnfsi->cache_validity |= NFS_INO_INVALID_DATA;\n\t}\n\t/* If we have atomic WCC data, we may update some attributes */\n\tif ((fattr->valid & NFS_ATTR_WCC) != 0) {\n\t\tif (timespec_equal(&inode->i_ctime, &fattr->pre_ctime))\n\t\t\tmemcpy(&inode->i_ctime, &fattr->ctime, sizeof(inode->i_ctime));\n\t\tif (timespec_equal(&inode->i_mtime, &fattr->pre_mtime)) {\n\t\t\tmemcpy(&inode->i_mtime, &fattr->mtime, sizeof(inode->i_mtime));\n\t\t\tif (S_ISDIR(inode->i_mode))\n\t\t\t\tnfsi->cache_validity |= NFS_INO_INVALID_DATA;\n\t\t}\n\t\tif (i_size_read(inode) == nfs_size_to_loff_t(fattr->pre_size) &&\n\t\t    nfsi->npages == 0)\n\t\t\ti_size_write(inode, nfs_size_to_loff_t(fattr->size));\n\t}\n}\n\n/**\n * nfs_check_inode_attributes - verify consistency of the inode attribute cache\n * @inode - pointer to inode\n * @fattr - updated attributes\n *\n * Verifies the attribute cache. If we have just changed the attributes,\n * so that fattr carries weak cache consistency data, then it may\n * also update the ctime/mtime/change_attribute.\n */\nstatic int nfs_check_inode_attributes(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tloff_t cur_size, new_isize;\n\tunsigned long invalid = 0;\n\n\n\t/* Has the inode gone and changed behind our back? */\n\tif (nfsi->fileid != fattr->fileid\n\t\t\t|| (inode->i_mode & S_IFMT) != (fattr->mode & S_IFMT)) {\n\t\treturn -EIO;\n\t}\n\n\tif ((fattr->valid & NFS_ATTR_FATTR_V4) != 0 &&\n\t\t\tnfsi->change_attr != fattr->change_attr)\n\t\tinvalid |= NFS_INO_INVALID_ATTR|NFS_INO_REVAL_PAGECACHE;\n\n\t/* Verify a few of the more important attributes */\n\tif (!timespec_equal(&inode->i_mtime, &fattr->mtime))\n\t\tinvalid |= NFS_INO_INVALID_ATTR|NFS_INO_REVAL_PAGECACHE;\n\n\tcur_size = i_size_read(inode);\n \tnew_isize = nfs_size_to_loff_t(fattr->size);\n\tif (cur_size != new_isize && nfsi->npages == 0)\n\t\tinvalid |= NFS_INO_INVALID_ATTR|NFS_INO_REVAL_PAGECACHE;\n\n\t/* Have any file permissions changed? */\n\tif ((inode->i_mode & S_IALLUGO) != (fattr->mode & S_IALLUGO)\n\t\t\t|| inode->i_uid != fattr->uid\n\t\t\t|| inode->i_gid != fattr->gid)\n\t\tinvalid |= NFS_INO_INVALID_ATTR | NFS_INO_INVALID_ACCESS | NFS_INO_INVALID_ACL;\n\n\t/* Has the link count changed? */\n\tif (inode->i_nlink != fattr->nlink)\n\t\tinvalid |= NFS_INO_INVALID_ATTR;\n\n\tif (!timespec_equal(&inode->i_atime, &fattr->atime))\n\t\tinvalid |= NFS_INO_INVALID_ATIME;\n\n\tif (invalid != 0)\n\t\tnfsi->cache_validity |= invalid;\n\n\tnfsi->read_cache_jiffies = fattr->time_start;\n\treturn 0;\n}\n\nstatic int nfs_ctime_need_update(const struct inode *inode, const struct nfs_fattr *fattr)\n{\n\treturn timespec_compare(&fattr->ctime, &inode->i_ctime) > 0;\n}\n\nstatic int nfs_size_need_update(const struct inode *inode, const struct nfs_fattr *fattr)\n{\n\treturn nfs_size_to_loff_t(fattr->size) > i_size_read(inode);\n}\n\nstatic atomic_long_t nfs_attr_generation_counter;\n\nstatic unsigned long nfs_read_attr_generation_counter(void)\n{\n\treturn atomic_long_read(&nfs_attr_generation_counter);\n}\n\nunsigned long nfs_inc_attr_generation_counter(void)\n{\n\treturn atomic_long_inc_return(&nfs_attr_generation_counter);\n}\n\nvoid nfs_fattr_init(struct nfs_fattr *fattr)\n{\n\tfattr->valid = 0;\n\tfattr->time_start = jiffies;\n\tfattr->gencount = nfs_inc_attr_generation_counter();\n}\n\n/**\n * nfs_inode_attrs_need_update - check if the inode attributes need updating\n * @inode - pointer to inode\n * @fattr - attributes\n *\n * Attempt to divine whether or not an RPC call reply carrying stale\n * attributes got scheduled after another call carrying updated ones.\n *\n * To do so, the function first assumes that a more recent ctime means\n * that the attributes in fattr are newer, however it also attempt to\n * catch the case where ctime either didn't change, or went backwards\n * (if someone reset the clock on the server) by looking at whether\n * or not this RPC call was started after the inode was last updated.\n * Note also the check for wraparound of 'attr_gencount'\n *\n * The function returns 'true' if it thinks the attributes in 'fattr' are\n * more recent than the ones cached in the inode.\n *\n */\nstatic int nfs_inode_attrs_need_update(const struct inode *inode, const struct nfs_fattr *fattr)\n{\n\tconst struct nfs_inode *nfsi = NFS_I(inode);\n\n\treturn ((long)fattr->gencount - (long)nfsi->attr_gencount) > 0 ||\n\t\tnfs_ctime_need_update(inode, fattr) ||\n\t\tnfs_size_need_update(inode, fattr) ||\n\t\t((long)nfsi->attr_gencount - (long)nfs_read_attr_generation_counter() > 0);\n}\n\nstatic int nfs_refresh_inode_locked(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tif (nfs_inode_attrs_need_update(inode, fattr))\n\t\treturn nfs_update_inode(inode, fattr);\n\treturn nfs_check_inode_attributes(inode, fattr);\n}\n\n/**\n * nfs_refresh_inode - try to update the inode attribute cache\n * @inode - pointer to inode\n * @fattr - updated attributes\n *\n * Check that an RPC call that returned attributes has not overlapped with\n * other recent updates of the inode metadata, then decide whether it is\n * safe to do a full update of the inode attributes, or whether just to\n * call nfs_check_inode_attributes.\n */\nint nfs_refresh_inode(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tint status;\n\n\tif ((fattr->valid & NFS_ATTR_FATTR) == 0)\n\t\treturn 0;\n\tspin_lock(&inode->i_lock);\n\tstatus = nfs_refresh_inode_locked(inode, fattr);\n\tspin_unlock(&inode->i_lock);\n\treturn status;\n}\n\nstatic int nfs_post_op_update_inode_locked(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tnfsi->cache_validity |= NFS_INO_INVALID_ATTR|NFS_INO_REVAL_PAGECACHE;\n\tif (S_ISDIR(inode->i_mode))\n\t\tnfsi->cache_validity |= NFS_INO_INVALID_DATA;\n\tif ((fattr->valid & NFS_ATTR_FATTR) == 0)\n\t\treturn 0;\n\treturn nfs_refresh_inode_locked(inode, fattr);\n}\n\n/**\n * nfs_post_op_update_inode - try to update the inode attribute cache\n * @inode - pointer to inode\n * @fattr - updated attributes\n *\n * After an operation that has changed the inode metadata, mark the\n * attribute cache as being invalid, then try to update it.\n *\n * NB: if the server didn't return any post op attributes, this\n * function will force the retrieval of attributes before the next\n * NFS request.  Thus it should be used only for operations that\n * are expected to change one or more attributes, to avoid\n * unnecessary NFS requests and trips through nfs_update_inode().\n */\nint nfs_post_op_update_inode(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tint status;\n\n\tspin_lock(&inode->i_lock);\n\tstatus = nfs_post_op_update_inode_locked(inode, fattr);\n\tspin_unlock(&inode->i_lock);\n\treturn status;\n}\n\n/**\n * nfs_post_op_update_inode_force_wcc - try to update the inode attribute cache\n * @inode - pointer to inode\n * @fattr - updated attributes\n *\n * After an operation that has changed the inode metadata, mark the\n * attribute cache as being invalid, then try to update it. Fake up\n * weak cache consistency data, if none exist.\n *\n * This function is mainly designed to be used by the ->write_done() functions.\n */\nint nfs_post_op_update_inode_force_wcc(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tint status;\n\n\tspin_lock(&inode->i_lock);\n\t/* Don't do a WCC update if these attributes are already stale */\n\tif ((fattr->valid & NFS_ATTR_FATTR) == 0 ||\n\t\t\t!nfs_inode_attrs_need_update(inode, fattr)) {\n\t\tfattr->valid &= ~(NFS_ATTR_WCC_V4|NFS_ATTR_WCC);\n\t\tgoto out_noforce;\n\t}\n\tif ((fattr->valid & NFS_ATTR_FATTR_V4) != 0 &&\n\t\t\t(fattr->valid & NFS_ATTR_WCC_V4) == 0) {\n\t\tfattr->pre_change_attr = NFS_I(inode)->change_attr;\n\t\tfattr->valid |= NFS_ATTR_WCC_V4;\n\t}\n\tif ((fattr->valid & NFS_ATTR_FATTR) != 0 &&\n\t\t\t(fattr->valid & NFS_ATTR_WCC) == 0) {\n\t\tmemcpy(&fattr->pre_ctime, &inode->i_ctime, sizeof(fattr->pre_ctime));\n\t\tmemcpy(&fattr->pre_mtime, &inode->i_mtime, sizeof(fattr->pre_mtime));\n\t\tfattr->pre_size = i_size_read(inode);\n\t\tfattr->valid |= NFS_ATTR_WCC;\n\t}\nout_noforce:\n\tstatus = nfs_post_op_update_inode_locked(inode, fattr);\n\tspin_unlock(&inode->i_lock);\n\treturn status;\n}\n\n/*\n * Many nfs protocol calls return the new file attributes after\n * an operation.  Here we update the inode to reflect the state\n * of the server's inode.\n *\n * This is a bit tricky because we have to make sure all dirty pages\n * have been sent off to the server before calling invalidate_inode_pages.\n * To make sure no other process adds more write requests while we try\n * our best to flush them, we make them sleep during the attribute refresh.\n *\n * A very similar scenario holds for the dir cache.\n */\nstatic int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tstruct nfs_server *server;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tloff_t cur_isize, new_isize;\n\tunsigned long invalid = 0;\n\tunsigned long now = jiffies;\n\n\tdfprintk(VFS, \"NFS: %s(%s/%ld ct=%d info=0x%x)\\n\",\n\t\t\t__func__, inode->i_sb->s_id, inode->i_ino,\n\t\t\tatomic_read(&inode->i_count), fattr->valid);\n\n\tif (nfsi->fileid != fattr->fileid)\n\t\tgoto out_fileid;\n\n\t/*\n\t * Make sure the inode's type hasn't changed.\n\t */\n\tif ((inode->i_mode & S_IFMT) != (fattr->mode & S_IFMT))\n\t\tgoto out_changed;\n\n\tserver = NFS_SERVER(inode);\n\t/* Update the fsid? */\n\tif (S_ISDIR(inode->i_mode) &&\n\t\t\t!nfs_fsid_equal(&server->fsid, &fattr->fsid) &&\n\t\t\t!test_bit(NFS_INO_MOUNTPOINT, &nfsi->flags))\n\t\tserver->fsid = fattr->fsid;\n\n\t/*\n\t * Update the read time so we don't revalidate too often.\n\t */\n\tnfsi->read_cache_jiffies = fattr->time_start;\n\n\tnfsi->cache_validity &= ~(NFS_INO_INVALID_ATTR | NFS_INO_INVALID_ATIME\n\t\t\t| NFS_INO_REVAL_PAGECACHE);\n\n\t/* Do atomic weak cache consistency updates */\n\tnfs_wcc_update_inode(inode, fattr);\n\n\t/* More cache consistency checks */\n\tif (!(fattr->valid & NFS_ATTR_FATTR_V4)) {\n\t\t/* NFSv2/v3: Check if the mtime agrees */\n\t\tif (!timespec_equal(&inode->i_mtime, &fattr->mtime)) {\n\t\t\tdprintk(\"NFS: mtime change on server for file %s/%ld\\n\",\n\t\t\t\t\tinode->i_sb->s_id, inode->i_ino);\n\t\t\tinvalid |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_DATA;\n\t\t\tif (S_ISDIR(inode->i_mode))\n\t\t\t\tnfs_force_lookup_revalidate(inode);\n\t\t}\n\t\t/* If ctime has changed we should definitely clear access+acl caches */\n\t\tif (!timespec_equal(&inode->i_ctime, &fattr->ctime))\n\t\t\tinvalid |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_ACCESS|NFS_INO_INVALID_ACL;\n\t} else if (nfsi->change_attr != fattr->change_attr) {\n\t\tdprintk(\"NFS: change_attr change on server for file %s/%ld\\n\",\n\t\t\t\tinode->i_sb->s_id, inode->i_ino);\n\t\tinvalid |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_DATA|NFS_INO_INVALID_ACCESS|NFS_INO_INVALID_ACL;\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tnfs_force_lookup_revalidate(inode);\n\t}\n\n\t/* Check if our cached file size is stale */\n \tnew_isize = nfs_size_to_loff_t(fattr->size);\n\tcur_isize = i_size_read(inode);\n\tif (new_isize != cur_isize) {\n\t\t/* Do we perhaps have any outstanding writes, or has\n\t\t * the file grown beyond our last write? */\n\t\tif (nfsi->npages == 0 || new_isize > cur_isize) {\n\t\t\ti_size_write(inode, new_isize);\n\t\t\tinvalid |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_DATA;\n\t\t}\n\t\tdprintk(\"NFS: isize change on server for file %s/%ld\\n\",\n\t\t\t\tinode->i_sb->s_id, inode->i_ino);\n\t}\n\n\n\tmemcpy(&inode->i_mtime, &fattr->mtime, sizeof(inode->i_mtime));\n\tmemcpy(&inode->i_ctime, &fattr->ctime, sizeof(inode->i_ctime));\n\tmemcpy(&inode->i_atime, &fattr->atime, sizeof(inode->i_atime));\n\tnfsi->change_attr = fattr->change_attr;\n\n\tif ((inode->i_mode & S_IALLUGO) != (fattr->mode & S_IALLUGO) ||\n\t    inode->i_uid != fattr->uid ||\n\t    inode->i_gid != fattr->gid)\n\t\tinvalid |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_ACCESS|NFS_INO_INVALID_ACL;\n\n\tif (inode->i_nlink != fattr->nlink)\n\t\tinvalid |= NFS_INO_INVALID_ATTR;\n\n\tinode->i_mode = fattr->mode;\n\tinode->i_nlink = fattr->nlink;\n\tinode->i_uid = fattr->uid;\n\tinode->i_gid = fattr->gid;\n\n\tif (fattr->valid & (NFS_ATTR_FATTR_V3 | NFS_ATTR_FATTR_V4)) {\n\t\t/*\n\t\t * report the blocks in 512byte units\n\t\t */\n\t\tinode->i_blocks = nfs_calc_block_size(fattr->du.nfs3.used);\n \t} else {\n \t\tinode->i_blocks = fattr->du.nfs2.blocks;\n \t}\n\n\t/* Update attrtimeo value if we're out of the unstable period */\n\tif (invalid & NFS_INO_INVALID_ATTR) {\n\t\tnfs_inc_stats(inode, NFSIOS_ATTRINVALIDATE);\n\t\tnfsi->attrtimeo = NFS_MINATTRTIMEO(inode);\n\t\tnfsi->attrtimeo_timestamp = now;\n\t\tnfsi->attr_gencount = nfs_inc_attr_generation_counter();\n\t} else {\n\t\tif (!time_in_range(now, nfsi->attrtimeo_timestamp, nfsi->attrtimeo_timestamp + nfsi->attrtimeo)) {\n\t\t\tif ((nfsi->attrtimeo <<= 1) > NFS_MAXATTRTIMEO(inode))\n\t\t\t\tnfsi->attrtimeo = NFS_MAXATTRTIMEO(inode);\n\t\t\tnfsi->attrtimeo_timestamp = now;\n\t\t}\n\t}\n\tinvalid &= ~NFS_INO_INVALID_ATTR;\n\t/* Don't invalidate the data if we were to blame */\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)\n\t\t\t\t|| S_ISLNK(inode->i_mode)))\n\t\tinvalid &= ~NFS_INO_INVALID_DATA;\n\tif (!nfs_have_delegation(inode, FMODE_READ) ||\n\t\t\t(nfsi->cache_validity & NFS_INO_REVAL_FORCED))\n\t\tnfsi->cache_validity |= invalid;\n\tnfsi->cache_validity &= ~NFS_INO_REVAL_FORCED;\n\n\treturn 0;\n out_changed:\n\t/*\n\t * Big trouble! The inode has become a different object.\n\t */\n\tprintk(KERN_DEBUG \"%s: inode %ld mode changed, %07o to %07o\\n\",\n\t\t\t__func__, inode->i_ino, inode->i_mode, fattr->mode);\n out_err:\n\t/*\n\t * No need to worry about unhashing the dentry, as the\n\t * lookup validation will know that the inode is bad.\n\t * (But we fall through to invalidate the caches.)\n\t */\n\tnfs_invalidate_inode(inode);\n\treturn -ESTALE;\n\n out_fileid:\n\tprintk(KERN_ERR \"NFS: server %s error: fileid changed\\n\"\n\t\t\"fsid %s: expected fileid 0x%Lx, got 0x%Lx\\n\",\n\t\tNFS_SERVER(inode)->nfs_client->cl_hostname, inode->i_sb->s_id,\n\t\t(long long)nfsi->fileid, (long long)fattr->fileid);\n\tgoto out_err;\n}\n\n\n#ifdef CONFIG_NFS_V4\n\n/*\n * Clean out any remaining NFSv4 state that might be left over due\n * to open() calls that passed nfs_atomic_lookup, but failed to call\n * nfs_open().\n */\nvoid nfs4_clear_inode(struct inode *inode)\n{\n\t/* If we are holding a delegation, return it! */\n\tnfs_inode_return_delegation_noreclaim(inode);\n\t/* First call standard NFS clear_inode() code */\n\tnfs_clear_inode(inode);\n}\n#endif\n\nstruct inode *nfs_alloc_inode(struct super_block *sb)\n{\n\tstruct nfs_inode *nfsi;\n\tnfsi = (struct nfs_inode *)kmem_cache_alloc(nfs_inode_cachep, GFP_KERNEL);\n\tif (!nfsi)\n\t\treturn NULL;\n\tnfsi->flags = 0UL;\n\tnfsi->cache_validity = 0UL;\n#ifdef CONFIG_NFS_V3_ACL\n\tnfsi->acl_access = ERR_PTR(-EAGAIN);\n\tnfsi->acl_default = ERR_PTR(-EAGAIN);\n#endif\n#ifdef CONFIG_NFS_V4\n\tnfsi->nfs4_acl = NULL;\n#endif /* CONFIG_NFS_V4 */\n\treturn &nfsi->vfs_inode;\n}\n\nvoid nfs_destroy_inode(struct inode *inode)\n{\n\tkmem_cache_free(nfs_inode_cachep, NFS_I(inode));\n}\n\nstatic inline void nfs4_init_once(struct nfs_inode *nfsi)\n{\n#ifdef CONFIG_NFS_V4\n\tINIT_LIST_HEAD(&nfsi->open_states);\n\tnfsi->delegation = NULL;\n\tnfsi->delegation_state = 0;\n\tinit_rwsem(&nfsi->rwsem);\n#endif\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct nfs_inode *nfsi = (struct nfs_inode *) foo;\n\n\tinode_init_once(&nfsi->vfs_inode);\n\tINIT_LIST_HEAD(&nfsi->open_files);\n\tINIT_LIST_HEAD(&nfsi->access_cache_entry_lru);\n\tINIT_LIST_HEAD(&nfsi->access_cache_inode_lru);\n\tINIT_RADIX_TREE(&nfsi->nfs_page_tree, GFP_ATOMIC);\n\tnfsi->ncommit = 0;\n\tnfsi->npages = 0;\n\tatomic_set(&nfsi->silly_count, 1);\n\tINIT_HLIST_HEAD(&nfsi->silly_list);\n\tinit_waitqueue_head(&nfsi->waitqueue);\n\tnfs4_init_once(nfsi);\n}\n\nstatic int __init nfs_init_inodecache(void)\n{\n\tnfs_inode_cachep = kmem_cache_create(\"nfs_inode_cache\",\n\t\t\t\t\t     sizeof(struct nfs_inode),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (nfs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void nfs_destroy_inodecache(void)\n{\n\tkmem_cache_destroy(nfs_inode_cachep);\n}\n\nstruct workqueue_struct *nfsiod_workqueue;\n\n/*\n * start up the nfsiod workqueue\n */\nstatic int nfsiod_start(void)\n{\n\tstruct workqueue_struct *wq;\n\tdprintk(\"RPC:       creating workqueue nfsiod\\n\");\n\twq = create_singlethread_workqueue(\"nfsiod\");\n\tif (wq == NULL)\n\t\treturn -ENOMEM;\n\tnfsiod_workqueue = wq;\n\treturn 0;\n}\n\n/*\n * Destroy the nfsiod workqueue\n */\nstatic void nfsiod_stop(void)\n{\n\tstruct workqueue_struct *wq;\n\n\twq = nfsiod_workqueue;\n\tif (wq == NULL)\n\t\treturn;\n\tnfsiod_workqueue = NULL;\n\tdestroy_workqueue(wq);\n}\n\n/*\n * Initialize NFS\n */\nstatic int __init init_nfs_fs(void)\n{\n\tint err;\n\n\terr = nfsiod_start();\n\tif (err)\n\t\tgoto out6;\n\n\terr = nfs_fs_proc_init();\n\tif (err)\n\t\tgoto out5;\n\n\terr = nfs_init_nfspagecache();\n\tif (err)\n\t\tgoto out4;\n\n\terr = nfs_init_inodecache();\n\tif (err)\n\t\tgoto out3;\n\n\terr = nfs_init_readpagecache();\n\tif (err)\n\t\tgoto out2;\n\n\terr = nfs_init_writepagecache();\n\tif (err)\n\t\tgoto out1;\n\n\terr = nfs_init_directcache();\n\tif (err)\n\t\tgoto out0;\n\n#ifdef CONFIG_PROC_FS\n\trpc_proc_register(&nfs_rpcstat);\n#endif\n\tif ((err = register_nfs_fs()) != 0)\n\t\tgoto out;\n\treturn 0;\nout:\n#ifdef CONFIG_PROC_FS\n\trpc_proc_unregister(\"nfs\");\n#endif\n\tnfs_destroy_directcache();\nout0:\n\tnfs_destroy_writepagecache();\nout1:\n\tnfs_destroy_readpagecache();\nout2:\n\tnfs_destroy_inodecache();\nout3:\n\tnfs_destroy_nfspagecache();\nout4:\n\tnfs_fs_proc_exit();\nout5:\n\tnfsiod_stop();\nout6:\n\treturn err;\n}\n\nstatic void __exit exit_nfs_fs(void)\n{\n\tnfs_destroy_directcache();\n\tnfs_destroy_writepagecache();\n\tnfs_destroy_readpagecache();\n\tnfs_destroy_inodecache();\n\tnfs_destroy_nfspagecache();\n#ifdef CONFIG_PROC_FS\n\trpc_proc_unregister(\"nfs\");\n#endif\n\tunregister_nfs_fs();\n\tnfs_fs_proc_exit();\n\tnfsiod_stop();\n}\n\n/* Not quite true; I just maintain it */\nMODULE_AUTHOR(\"Olaf Kirch <okir@monad.swb.de>\");\nMODULE_LICENSE(\"GPL\");\nmodule_param(enable_ino64, bool, 0644);\n\nmodule_init(init_nfs_fs)\nmodule_exit(exit_nfs_fs)\n", "/*\n * linux/fs/nfs/nfs4_fs.h\n *\n * Copyright (C) 2005 Trond Myklebust\n *\n * NFSv4-specific filesystem definitions and declarations\n */\n\n#ifndef __LINUX_FS_NFS_NFS4_FS_H\n#define __LINUX_FS_NFS_NFS4_FS_H\n\n#ifdef CONFIG_NFS_V4\n\nstruct idmap;\n\n/*\n * In a seqid-mutating op, this macro controls which error return\n * values trigger incrementation of the seqid.\n *\n * from rfc 3010:\n * The client MUST monotonically increment the sequence number for the\n * CLOSE, LOCK, LOCKU, OPEN, OPEN_CONFIRM, and OPEN_DOWNGRADE\n * operations.  This is true even in the event that the previous\n * operation that used the sequence number received an error.  The only\n * exception to this rule is if the previous operation received one of\n * the following errors: NFSERR_STALE_CLIENTID, NFSERR_STALE_STATEID,\n * NFSERR_BAD_STATEID, NFSERR_BAD_SEQID, NFSERR_BADXDR,\n * NFSERR_RESOURCE, NFSERR_NOFILEHANDLE.\n *\n */\n#define seqid_mutating_err(err)       \\\n(((err) != NFSERR_STALE_CLIENTID) &&  \\\n ((err) != NFSERR_STALE_STATEID)  &&  \\\n ((err) != NFSERR_BAD_STATEID)    &&  \\\n ((err) != NFSERR_BAD_SEQID)      &&  \\\n ((err) != NFSERR_BAD_XDR)        &&  \\\n ((err) != NFSERR_RESOURCE)       &&  \\\n ((err) != NFSERR_NOFILEHANDLE))\n\nenum nfs4_client_state {\n\tNFS4CLNT_MANAGER_RUNNING  = 0,\n\tNFS4CLNT_CHECK_LEASE,\n\tNFS4CLNT_LEASE_EXPIRED,\n\tNFS4CLNT_RECLAIM_REBOOT,\n\tNFS4CLNT_RECLAIM_NOGRACE,\n\tNFS4CLNT_DELEGRETURN,\n};\n\n/*\n * struct rpc_sequence ensures that RPC calls are sent in the exact\n * order that they appear on the list.\n */\nstruct rpc_sequence {\n\tstruct rpc_wait_queue\twait;\t/* RPC call delay queue */\n\tspinlock_t lock;\t\t/* Protects the list */\n\tstruct list_head list;\t\t/* Defines sequence of RPC calls */\n};\n\n#define NFS_SEQID_CONFIRMED 1\nstruct nfs_seqid_counter {\n\tstruct rpc_sequence *sequence;\n\tint flags;\n\tu32 counter;\n};\n\nstruct nfs_seqid {\n\tstruct nfs_seqid_counter *sequence;\n\tstruct list_head list;\n};\n\nstatic inline void nfs_confirm_seqid(struct nfs_seqid_counter *seqid, int status)\n{\n\tif (seqid_mutating_err(-status))\n\t\tseqid->flags |= NFS_SEQID_CONFIRMED;\n}\n\nstruct nfs_unique_id {\n\tstruct rb_node rb_node;\n\t__u64 id;\n};\n\n/*\n * NFS4 state_owners and lock_owners are simply labels for ordered\n * sequences of RPC calls. Their sole purpose is to provide once-only\n * semantics by allowing the server to identify replayed requests.\n */\nstruct nfs4_state_owner {\n\tstruct nfs_unique_id so_owner_id;\n\tstruct nfs_client    *so_client;\n\tstruct nfs_server    *so_server;\n\tstruct rb_node\t     so_client_node;\n\n\tstruct rpc_cred\t     *so_cred;\t /* Associated cred */\n\n\tspinlock_t\t     so_lock;\n\tatomic_t\t     so_count;\n\tunsigned long\t     so_flags;\n\tstruct list_head     so_states;\n\tstruct list_head     so_delegations;\n\tstruct nfs_seqid_counter so_seqid;\n\tstruct rpc_sequence  so_sequence;\n};\n\nenum {\n\tNFS_OWNER_RECLAIM_REBOOT,\n\tNFS_OWNER_RECLAIM_NOGRACE\n};\n\n/*\n * struct nfs4_state maintains the client-side state for a given\n * (state_owner,inode) tuple (OPEN) or state_owner (LOCK).\n *\n * OPEN:\n * In order to know when to OPEN_DOWNGRADE or CLOSE the state on the server,\n * we need to know how many files are open for reading or writing on a\n * given inode. This information too is stored here.\n *\n * LOCK: one nfs4_state (LOCK) to hold the lock stateid nfs4_state(OPEN)\n */\n\nstruct nfs4_lock_state {\n\tstruct list_head\tls_locks;\t/* Other lock stateids */\n\tstruct nfs4_state *\tls_state;\t/* Pointer to open state */\n\tfl_owner_t\t\tls_owner;\t/* POSIX lock owner */\n#define NFS_LOCK_INITIALIZED 1\n\tint\t\t\tls_flags;\n\tstruct nfs_seqid_counter\tls_seqid;\n\tstruct rpc_sequence\tls_sequence;\n\tstruct nfs_unique_id\tls_id;\n\tnfs4_stateid\t\tls_stateid;\n\tatomic_t\t\tls_count;\n};\n\n/* bits for nfs4_state->flags */\nenum {\n\tLK_STATE_IN_USE,\n\tNFS_DELEGATED_STATE,\t\t/* Current stateid is delegation */\n\tNFS_O_RDONLY_STATE,\t\t/* OPEN stateid has read-only state */\n\tNFS_O_WRONLY_STATE,\t\t/* OPEN stateid has write-only state */\n\tNFS_O_RDWR_STATE,\t\t/* OPEN stateid has read/write state */\n\tNFS_STATE_RECLAIM_REBOOT,\t/* OPEN stateid server rebooted */\n\tNFS_STATE_RECLAIM_NOGRACE,\t/* OPEN stateid needs to recover state */\n};\n\nstruct nfs4_state {\n\tstruct list_head open_states;\t/* List of states for the same state_owner */\n\tstruct list_head inode_states;\t/* List of states for the same inode */\n\tstruct list_head lock_states;\t/* List of subservient lock stateids */\n\n\tstruct nfs4_state_owner *owner;\t/* Pointer to the open owner */\n\tstruct inode *inode;\t\t/* Pointer to the inode */\n\n\tunsigned long flags;\t\t/* Do we hold any locks? */\n\tspinlock_t state_lock;\t\t/* Protects the lock_states list */\n\n\tseqlock_t seqlock;\t\t/* Protects the stateid/open_stateid */\n\tnfs4_stateid stateid;\t\t/* Current stateid: may be delegation */\n\tnfs4_stateid open_stateid;\t/* OPEN stateid */\n\n\t/* The following 3 fields are protected by owner->so_lock */\n\tunsigned int n_rdonly;\t\t/* Number of read-only references */\n\tunsigned int n_wronly;\t\t/* Number of write-only references */\n\tunsigned int n_rdwr;\t\t/* Number of read/write references */\n\tint state;\t\t\t/* State on the server (R,W, or RW) */\n\tatomic_t count;\n};\n\n\nstruct nfs4_exception {\n\tlong timeout;\n\tint retry;\n\tstruct nfs4_state *state;\n};\n\nstruct nfs4_state_recovery_ops {\n\tint owner_flag_bit;\n\tint state_flag_bit;\n\tint (*recover_open)(struct nfs4_state_owner *, struct nfs4_state *);\n\tint (*recover_lock)(struct nfs4_state *, struct file_lock *);\n};\n\nextern struct dentry_operations nfs4_dentry_operations;\nextern const struct inode_operations nfs4_dir_inode_operations;\n\n/* inode.c */\nextern ssize_t nfs4_getxattr(struct dentry *, const char *, void *, size_t);\nextern int nfs4_setxattr(struct dentry *, const char *, const void *, size_t, int);\nextern ssize_t nfs4_listxattr(struct dentry *, char *, size_t);\n\n\n/* nfs4proc.c */\nextern int nfs4_map_errors(int err);\nextern int nfs4_proc_setclientid(struct nfs_client *, u32, unsigned short, struct rpc_cred *);\nextern int nfs4_proc_setclientid_confirm(struct nfs_client *, struct rpc_cred *);\nextern int nfs4_proc_async_renew(struct nfs_client *, struct rpc_cred *);\nextern int nfs4_proc_renew(struct nfs_client *, struct rpc_cred *);\nextern int nfs4_do_close(struct path *path, struct nfs4_state *state, int wait);\nextern struct dentry *nfs4_atomic_open(struct inode *, struct dentry *, struct nameidata *);\nextern int nfs4_open_revalidate(struct inode *, struct dentry *, int, struct nameidata *);\nextern int nfs4_server_capabilities(struct nfs_server *server, struct nfs_fh *fhandle);\nextern int nfs4_proc_fs_locations(struct inode *dir, const struct qstr *name,\n\t\tstruct nfs4_fs_locations *fs_locations, struct page *page);\n\nextern struct nfs4_state_recovery_ops nfs4_reboot_recovery_ops;\nextern struct nfs4_state_recovery_ops nfs4_nograce_recovery_ops;\n\nextern const u32 nfs4_fattr_bitmap[2];\nextern const u32 nfs4_statfs_bitmap[2];\nextern const u32 nfs4_pathconf_bitmap[2];\nextern const u32 nfs4_fsinfo_bitmap[2];\nextern const u32 nfs4_fs_locations_bitmap[2];\n\n/* nfs4renewd.c */\nextern void nfs4_schedule_state_renewal(struct nfs_client *);\nextern void nfs4_renewd_prepare_shutdown(struct nfs_server *);\nextern void nfs4_kill_renewd(struct nfs_client *);\nextern void nfs4_renew_state(struct work_struct *);\n\n/* nfs4state.c */\nstruct rpc_cred *nfs4_get_renew_cred_locked(struct nfs_client *clp);\n\nextern struct nfs4_state_owner * nfs4_get_state_owner(struct nfs_server *, struct rpc_cred *);\nextern void nfs4_put_state_owner(struct nfs4_state_owner *);\nextern struct nfs4_state * nfs4_get_open_state(struct inode *, struct nfs4_state_owner *);\nextern void nfs4_put_open_state(struct nfs4_state *);\nextern void nfs4_close_state(struct path *, struct nfs4_state *, mode_t);\nextern void nfs4_close_sync(struct path *, struct nfs4_state *, mode_t);\nextern void nfs4_state_set_mode_locked(struct nfs4_state *, mode_t);\nextern void nfs4_schedule_state_recovery(struct nfs_client *);\nextern void nfs4_schedule_state_manager(struct nfs_client *);\nextern int nfs4_state_mark_reclaim_nograce(struct nfs_client *clp, struct nfs4_state *state);\nextern void nfs4_put_lock_state(struct nfs4_lock_state *lsp);\nextern int nfs4_set_lock_state(struct nfs4_state *state, struct file_lock *fl);\nextern void nfs4_copy_stateid(nfs4_stateid *, struct nfs4_state *, fl_owner_t);\n\nextern struct nfs_seqid *nfs_alloc_seqid(struct nfs_seqid_counter *counter);\nextern int nfs_wait_on_sequence(struct nfs_seqid *seqid, struct rpc_task *task);\nextern void nfs_increment_open_seqid(int status, struct nfs_seqid *seqid);\nextern void nfs_increment_lock_seqid(int status, struct nfs_seqid *seqid);\nextern void nfs_free_seqid(struct nfs_seqid *seqid);\n\nextern const nfs4_stateid zero_stateid;\n\n/* nfs4xdr.c */\nextern __be32 *nfs4_decode_dirent(__be32 *p, struct nfs_entry *entry, int plus);\nextern struct rpc_procinfo nfs4_procedures[];\n\nstruct nfs4_mount_data;\n\n/* callback_xdr.c */\nextern struct svc_version nfs4_callback_version1;\n\n#else\n\n#define nfs4_close_state(a, b, c) do { } while (0)\n#define nfs4_close_sync(a, b, c) do { } while (0)\n\n#endif /* CONFIG_NFS_V4 */\n#endif /* __LINUX_FS_NFS_NFS4_FS.H */\n", "/*\n *  fs/nfs/nfs4proc.c\n *\n *  Client-side procedure declarations for NFSv4.\n *\n *  Copyright (c) 2002 The Regents of the University of Michigan.\n *  All rights reserved.\n *\n *  Kendrick Smith <kmsmith@umich.edu>\n *  Andy Adamson   <andros@umich.edu>\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions\n *  are met:\n *\n *  1. Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *  2. Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *  3. Neither the name of the University nor the names of its\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED\n *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n *  DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n *  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <linux/mm.h>\n#include <linux/utsname.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/smp_lock.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n\n#include \"nfs4_fs.h\"\n#include \"delegation.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_PROC\n\n#define NFS4_POLL_RETRY_MIN\t(HZ/10)\n#define NFS4_POLL_RETRY_MAX\t(15*HZ)\n\nstruct nfs4_opendata;\nstatic int _nfs4_proc_open(struct nfs4_opendata *data);\nstatic int nfs4_do_fsinfo(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *);\nstatic int nfs4_async_handle_error(struct rpc_task *, const struct nfs_server *, struct nfs4_state *);\nstatic int _nfs4_proc_lookup(struct inode *dir, const struct qstr *name, struct nfs_fh *fhandle, struct nfs_fattr *fattr);\nstatic int _nfs4_proc_getattr(struct nfs_server *server, struct nfs_fh *fhandle, struct nfs_fattr *fattr);\n\n/* Prevent leaks of NFSv4 errors into userland */\nint nfs4_map_errors(int err)\n{\n\tif (err < -1000) {\n\t\tdprintk(\"%s could not handle NFSv4 error %d\\n\",\n\t\t\t\t__func__, -err);\n\t\treturn -EIO;\n\t}\n\treturn err;\n}\n\n/*\n * This is our standard bitmap for GETATTR requests.\n */\nconst u32 nfs4_fattr_bitmap[2] = {\n\tFATTR4_WORD0_TYPE\n\t| FATTR4_WORD0_CHANGE\n\t| FATTR4_WORD0_SIZE\n\t| FATTR4_WORD0_FSID\n\t| FATTR4_WORD0_FILEID,\n\tFATTR4_WORD1_MODE\n\t| FATTR4_WORD1_NUMLINKS\n\t| FATTR4_WORD1_OWNER\n\t| FATTR4_WORD1_OWNER_GROUP\n\t| FATTR4_WORD1_RAWDEV\n\t| FATTR4_WORD1_SPACE_USED\n\t| FATTR4_WORD1_TIME_ACCESS\n\t| FATTR4_WORD1_TIME_METADATA\n\t| FATTR4_WORD1_TIME_MODIFY\n};\n\nconst u32 nfs4_statfs_bitmap[2] = {\n\tFATTR4_WORD0_FILES_AVAIL\n\t| FATTR4_WORD0_FILES_FREE\n\t| FATTR4_WORD0_FILES_TOTAL,\n\tFATTR4_WORD1_SPACE_AVAIL\n\t| FATTR4_WORD1_SPACE_FREE\n\t| FATTR4_WORD1_SPACE_TOTAL\n};\n\nconst u32 nfs4_pathconf_bitmap[2] = {\n\tFATTR4_WORD0_MAXLINK\n\t| FATTR4_WORD0_MAXNAME,\n\t0\n};\n\nconst u32 nfs4_fsinfo_bitmap[2] = { FATTR4_WORD0_MAXFILESIZE\n\t\t\t| FATTR4_WORD0_MAXREAD\n\t\t\t| FATTR4_WORD0_MAXWRITE\n\t\t\t| FATTR4_WORD0_LEASE_TIME,\n\t\t\t0\n};\n\nconst u32 nfs4_fs_locations_bitmap[2] = {\n\tFATTR4_WORD0_TYPE\n\t| FATTR4_WORD0_CHANGE\n\t| FATTR4_WORD0_SIZE\n\t| FATTR4_WORD0_FSID\n\t| FATTR4_WORD0_FILEID\n\t| FATTR4_WORD0_FS_LOCATIONS,\n\tFATTR4_WORD1_MODE\n\t| FATTR4_WORD1_NUMLINKS\n\t| FATTR4_WORD1_OWNER\n\t| FATTR4_WORD1_OWNER_GROUP\n\t| FATTR4_WORD1_RAWDEV\n\t| FATTR4_WORD1_SPACE_USED\n\t| FATTR4_WORD1_TIME_ACCESS\n\t| FATTR4_WORD1_TIME_METADATA\n\t| FATTR4_WORD1_TIME_MODIFY\n\t| FATTR4_WORD1_MOUNTED_ON_FILEID\n};\n\nstatic void nfs4_setup_readdir(u64 cookie, __be32 *verifier, struct dentry *dentry,\n\t\tstruct nfs4_readdir_arg *readdir)\n{\n\t__be32 *start, *p;\n\n\tBUG_ON(readdir->count < 80);\n\tif (cookie > 2) {\n\t\treaddir->cookie = cookie;\n\t\tmemcpy(&readdir->verifier, verifier, sizeof(readdir->verifier));\n\t\treturn;\n\t}\n\n\treaddir->cookie = 0;\n\tmemset(&readdir->verifier, 0, sizeof(readdir->verifier));\n\tif (cookie == 2)\n\t\treturn;\n\t\n\t/*\n\t * NFSv4 servers do not return entries for '.' and '..'\n\t * Therefore, we fake these entries here.  We let '.'\n\t * have cookie 0 and '..' have cookie 1.  Note that\n\t * when talking to the server, we always send cookie 0\n\t * instead of 1 or 2.\n\t */\n\tstart = p = kmap_atomic(*readdir->pages, KM_USER0);\n\t\n\tif (cookie == 0) {\n\t\t*p++ = xdr_one;                                  /* next */\n\t\t*p++ = xdr_zero;                   /* cookie, first word */\n\t\t*p++ = xdr_one;                   /* cookie, second word */\n\t\t*p++ = xdr_one;                             /* entry len */\n\t\tmemcpy(p, \".\\0\\0\\0\", 4);                        /* entry */\n\t\tp++;\n\t\t*p++ = xdr_one;                         /* bitmap length */\n\t\t*p++ = htonl(FATTR4_WORD0_FILEID);             /* bitmap */\n\t\t*p++ = htonl(8);              /* attribute buffer length */\n\t\tp = xdr_encode_hyper(p, NFS_FILEID(dentry->d_inode));\n\t}\n\t\n\t*p++ = xdr_one;                                  /* next */\n\t*p++ = xdr_zero;                   /* cookie, first word */\n\t*p++ = xdr_two;                   /* cookie, second word */\n\t*p++ = xdr_two;                             /* entry len */\n\tmemcpy(p, \"..\\0\\0\", 4);                         /* entry */\n\tp++;\n\t*p++ = xdr_one;                         /* bitmap length */\n\t*p++ = htonl(FATTR4_WORD0_FILEID);             /* bitmap */\n\t*p++ = htonl(8);              /* attribute buffer length */\n\tp = xdr_encode_hyper(p, NFS_FILEID(dentry->d_parent->d_inode));\n\n\treaddir->pgbase = (char *)p - (char *)start;\n\treaddir->count -= readdir->pgbase;\n\tkunmap_atomic(start, KM_USER0);\n}\n\nstatic int nfs4_wait_bit_killable(void *word)\n{\n\tif (fatal_signal_pending(current))\n\t\treturn -ERESTARTSYS;\n\tschedule();\n\treturn 0;\n}\n\nstatic int nfs4_wait_clnt_recover(struct nfs_client *clp)\n{\n\tint res;\n\n\tmight_sleep();\n\n\tres = wait_on_bit(&clp->cl_state, NFS4CLNT_MANAGER_RUNNING,\n\t\t\tnfs4_wait_bit_killable, TASK_KILLABLE);\n\treturn res;\n}\n\nstatic int nfs4_delay(struct rpc_clnt *clnt, long *timeout)\n{\n\tint res = 0;\n\n\tmight_sleep();\n\n\tif (*timeout <= 0)\n\t\t*timeout = NFS4_POLL_RETRY_MIN;\n\tif (*timeout > NFS4_POLL_RETRY_MAX)\n\t\t*timeout = NFS4_POLL_RETRY_MAX;\n\tschedule_timeout_killable(*timeout);\n\tif (fatal_signal_pending(current))\n\t\tres = -ERESTARTSYS;\n\t*timeout <<= 1;\n\treturn res;\n}\n\n/* This is the error handling routine for processes that are allowed\n * to sleep.\n */\nstatic int nfs4_handle_exception(const struct nfs_server *server, int errorcode, struct nfs4_exception *exception)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_state *state = exception->state;\n\tint ret = errorcode;\n\n\texception->retry = 0;\n\tswitch(errorcode) {\n\t\tcase 0:\n\t\t\treturn 0;\n\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_OPENMODE:\n\t\t\tif (state == NULL)\n\t\t\t\tbreak;\n\t\t\tnfs4_state_mark_reclaim_nograce(clp, state);\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tnfs4_schedule_state_recovery(clp);\n\t\t\tret = nfs4_wait_clnt_recover(clp);\n\t\t\tif (ret == 0)\n\t\t\t\texception->retry = 1;\n\t\t\tbreak;\n\t\tcase -NFS4ERR_FILE_OPEN:\n\t\tcase -NFS4ERR_GRACE:\n\t\tcase -NFS4ERR_DELAY:\n\t\t\tret = nfs4_delay(server->client, &exception->timeout);\n\t\t\tif (ret != 0)\n\t\t\t\tbreak;\n\t\tcase -NFS4ERR_OLD_STATEID:\n\t\t\texception->retry = 1;\n\t}\n\t/* We failed to handle the error */\n\treturn nfs4_map_errors(ret);\n}\n\n\nstatic void renew_lease(const struct nfs_server *server, unsigned long timestamp)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tspin_lock(&clp->cl_lock);\n\tif (time_before(clp->cl_last_renewal,timestamp))\n\t\tclp->cl_last_renewal = timestamp;\n\tspin_unlock(&clp->cl_lock);\n}\n\nstatic void update_changeattr(struct inode *dir, struct nfs4_change_info *cinfo)\n{\n\tstruct nfs_inode *nfsi = NFS_I(dir);\n\n\tspin_lock(&dir->i_lock);\n\tnfsi->cache_validity |= NFS_INO_INVALID_ATTR|NFS_INO_REVAL_PAGECACHE|NFS_INO_INVALID_DATA;\n\tif (!cinfo->atomic || cinfo->before != nfsi->change_attr)\n\t\tnfs_force_lookup_revalidate(dir);\n\tnfsi->change_attr = cinfo->after;\n\tspin_unlock(&dir->i_lock);\n}\n\nstruct nfs4_opendata {\n\tstruct kref kref;\n\tstruct nfs_openargs o_arg;\n\tstruct nfs_openres o_res;\n\tstruct nfs_open_confirmargs c_arg;\n\tstruct nfs_open_confirmres c_res;\n\tstruct nfs_fattr f_attr;\n\tstruct nfs_fattr dir_attr;\n\tstruct path path;\n\tstruct dentry *dir;\n\tstruct nfs4_state_owner *owner;\n\tstruct nfs4_state *state;\n\tstruct iattr attrs;\n\tunsigned long timestamp;\n\tunsigned int rpc_done : 1;\n\tint rpc_status;\n\tint cancelled;\n};\n\n\nstatic void nfs4_init_opendata_res(struct nfs4_opendata *p)\n{\n\tp->o_res.f_attr = &p->f_attr;\n\tp->o_res.dir_attr = &p->dir_attr;\n\tp->o_res.seqid = p->o_arg.seqid;\n\tp->c_res.seqid = p->c_arg.seqid;\n\tp->o_res.server = p->o_arg.server;\n\tnfs_fattr_init(&p->f_attr);\n\tnfs_fattr_init(&p->dir_attr);\n}\n\nstatic struct nfs4_opendata *nfs4_opendata_alloc(struct path *path,\n\t\tstruct nfs4_state_owner *sp, int flags,\n\t\tconst struct iattr *attrs)\n{\n\tstruct dentry *parent = dget_parent(path->dentry);\n\tstruct inode *dir = parent->d_inode;\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs4_opendata *p;\n\n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (p == NULL)\n\t\tgoto err;\n\tp->o_arg.seqid = nfs_alloc_seqid(&sp->so_seqid);\n\tif (p->o_arg.seqid == NULL)\n\t\tgoto err_free;\n\tp->path.mnt = mntget(path->mnt);\n\tp->path.dentry = dget(path->dentry);\n\tp->dir = parent;\n\tp->owner = sp;\n\tatomic_inc(&sp->so_count);\n\tp->o_arg.fh = NFS_FH(dir);\n\tp->o_arg.open_flags = flags,\n\tp->o_arg.clientid = server->nfs_client->cl_clientid;\n\tp->o_arg.id = sp->so_owner_id.id;\n\tp->o_arg.name = &p->path.dentry->d_name;\n\tp->o_arg.server = server;\n\tp->o_arg.bitmask = server->attr_bitmask;\n\tp->o_arg.claim = NFS4_OPEN_CLAIM_NULL;\n\tif (flags & O_EXCL) {\n\t\tu32 *s = (u32 *) p->o_arg.u.verifier.data;\n\t\ts[0] = jiffies;\n\t\ts[1] = current->pid;\n\t} else if (flags & O_CREAT) {\n\t\tp->o_arg.u.attrs = &p->attrs;\n\t\tmemcpy(&p->attrs, attrs, sizeof(p->attrs));\n\t}\n\tp->c_arg.fh = &p->o_res.fh;\n\tp->c_arg.stateid = &p->o_res.stateid;\n\tp->c_arg.seqid = p->o_arg.seqid;\n\tnfs4_init_opendata_res(p);\n\tkref_init(&p->kref);\n\treturn p;\nerr_free:\n\tkfree(p);\nerr:\n\tdput(parent);\n\treturn NULL;\n}\n\nstatic void nfs4_opendata_free(struct kref *kref)\n{\n\tstruct nfs4_opendata *p = container_of(kref,\n\t\t\tstruct nfs4_opendata, kref);\n\n\tnfs_free_seqid(p->o_arg.seqid);\n\tif (p->state != NULL)\n\t\tnfs4_put_open_state(p->state);\n\tnfs4_put_state_owner(p->owner);\n\tdput(p->dir);\n\tpath_put(&p->path);\n\tkfree(p);\n}\n\nstatic void nfs4_opendata_put(struct nfs4_opendata *p)\n{\n\tif (p != NULL)\n\t\tkref_put(&p->kref, nfs4_opendata_free);\n}\n\nstatic int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}\n\nstatic int can_open_cached(struct nfs4_state *state, int mode)\n{\n\tint ret = 0;\n\tswitch (mode & (FMODE_READ|FMODE_WRITE|O_EXCL)) {\n\t\tcase FMODE_READ:\n\t\t\tret |= test_bit(NFS_O_RDONLY_STATE, &state->flags) != 0;\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tret |= test_bit(NFS_O_WRONLY_STATE, &state->flags) != 0;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tret |= test_bit(NFS_O_RDWR_STATE, &state->flags) != 0;\n\t}\n\treturn ret;\n}\n\nstatic int can_open_delegated(struct nfs_delegation *delegation, mode_t open_flags)\n{\n\tif ((delegation->type & open_flags) != open_flags)\n\t\treturn 0;\n\tif (test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags))\n\t\treturn 0;\n\tnfs_mark_delegation_referenced(delegation);\n\treturn 1;\n}\n\nstatic void update_open_stateflags(struct nfs4_state *state, mode_t open_flags)\n{\n\tswitch (open_flags) {\n\t\tcase FMODE_WRITE:\n\t\t\tstate->n_wronly++;\n\t\t\tbreak;\n\t\tcase FMODE_READ:\n\t\t\tstate->n_rdonly++;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tstate->n_rdwr++;\n\t}\n\tnfs4_state_set_mode_locked(state, state->state | open_flags);\n}\n\nstatic void nfs_set_open_stateid_locked(struct nfs4_state *state, nfs4_stateid *stateid, int open_flags)\n{\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0)\n\t\tmemcpy(state->stateid.data, stateid->data, sizeof(state->stateid.data));\n\tmemcpy(state->open_stateid.data, stateid->data, sizeof(state->open_stateid.data));\n\tswitch (open_flags) {\n\t\tcase FMODE_READ:\n\t\t\tset_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tset_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tset_bit(NFS_O_RDWR_STATE, &state->flags);\n\t}\n}\n\nstatic void nfs_set_open_stateid(struct nfs4_state *state, nfs4_stateid *stateid, int open_flags)\n{\n\twrite_seqlock(&state->seqlock);\n\tnfs_set_open_stateid_locked(state, stateid, open_flags);\n\twrite_sequnlock(&state->seqlock);\n}\n\nstatic void __update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, const nfs4_stateid *deleg_stateid, int open_flags)\n{\n\t/*\n\t * Protect the call to nfs4_state_set_mode_locked and\n\t * serialise the stateid update\n\t */\n\twrite_seqlock(&state->seqlock);\n\tif (deleg_stateid != NULL) {\n\t\tmemcpy(state->stateid.data, deleg_stateid->data, sizeof(state->stateid.data));\n\t\tset_bit(NFS_DELEGATED_STATE, &state->flags);\n\t}\n\tif (open_stateid != NULL)\n\t\tnfs_set_open_stateid_locked(state, open_stateid, open_flags);\n\twrite_sequnlock(&state->seqlock);\n\tspin_lock(&state->owner->so_lock);\n\tupdate_open_stateflags(state, open_flags);\n\tspin_unlock(&state->owner->so_lock);\n}\n\nstatic int update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, nfs4_stateid *delegation, int open_flags)\n{\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_delegation *deleg_cur;\n\tint ret = 0;\n\n\topen_flags &= (FMODE_READ|FMODE_WRITE);\n\n\trcu_read_lock();\n\tdeleg_cur = rcu_dereference(nfsi->delegation);\n\tif (deleg_cur == NULL)\n\t\tgoto no_delegation;\n\n\tspin_lock(&deleg_cur->lock);\n\tif (nfsi->delegation != deleg_cur ||\n\t    (deleg_cur->type & open_flags) != open_flags)\n\t\tgoto no_delegation_unlock;\n\n\tif (delegation == NULL)\n\t\tdelegation = &deleg_cur->stateid;\n\telse if (memcmp(deleg_cur->stateid.data, delegation->data, NFS4_STATEID_SIZE) != 0)\n\t\tgoto no_delegation_unlock;\n\n\tnfs_mark_delegation_referenced(deleg_cur);\n\t__update_open_stateid(state, open_stateid, &deleg_cur->stateid, open_flags);\n\tret = 1;\nno_delegation_unlock:\n\tspin_unlock(&deleg_cur->lock);\nno_delegation:\n\trcu_read_unlock();\n\n\tif (!ret && open_stateid != NULL) {\n\t\t__update_open_stateid(state, open_stateid, NULL, open_flags);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\n\nstatic void nfs4_return_incompatible_delegation(struct inode *inode, mode_t open_flags)\n{\n\tstruct nfs_delegation *delegation;\n\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n\tif (delegation == NULL || (delegation->type & open_flags) == open_flags) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\trcu_read_unlock();\n\tnfs_inode_return_delegation(inode);\n}\n\nstatic struct nfs4_state *nfs4_try_open_cached(struct nfs4_opendata *opendata)\n{\n\tstruct nfs4_state *state = opendata->state;\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_delegation *delegation;\n\tint open_mode = opendata->o_arg.open_flags & (FMODE_READ|FMODE_WRITE|O_EXCL);\n\tnfs4_stateid stateid;\n\tint ret = -EAGAIN;\n\n\tfor (;;) {\n\t\tif (can_open_cached(state, open_mode)) {\n\t\t\tspin_lock(&state->owner->so_lock);\n\t\t\tif (can_open_cached(state, open_mode)) {\n\t\t\t\tupdate_open_stateflags(state, open_mode);\n\t\t\t\tspin_unlock(&state->owner->so_lock);\n\t\t\t\tgoto out_return_state;\n\t\t\t}\n\t\t\tspin_unlock(&state->owner->so_lock);\n\t\t}\n\t\trcu_read_lock();\n\t\tdelegation = rcu_dereference(nfsi->delegation);\n\t\tif (delegation == NULL ||\n\t\t    !can_open_delegated(delegation, open_mode)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\t/* Save the delegation */\n\t\tmemcpy(stateid.data, delegation->stateid.data, sizeof(stateid.data));\n\t\trcu_read_unlock();\n\t\tret = nfs_may_open(state->inode, state->owner->so_cred, open_mode);\n\t\tif (ret != 0)\n\t\t\tgoto out;\n\t\tret = -EAGAIN;\n\n\t\t/* Try to update the stateid using the delegation */\n\t\tif (update_open_stateid(state, NULL, &stateid, open_mode))\n\t\t\tgoto out_return_state;\n\t}\nout:\n\treturn ERR_PTR(ret);\nout_return_state:\n\tatomic_inc(&state->count);\n\treturn state;\n}\n\nstatic struct nfs4_state *nfs4_opendata_to_nfs4_state(struct nfs4_opendata *data)\n{\n\tstruct inode *inode;\n\tstruct nfs4_state *state = NULL;\n\tstruct nfs_delegation *delegation;\n\tint ret;\n\n\tif (!data->rpc_done) {\n\t\tstate = nfs4_try_open_cached(data);\n\t\tgoto out;\n\t}\n\n\tret = -EAGAIN;\n\tif (!(data->f_attr.valid & NFS_ATTR_FATTR))\n\t\tgoto err;\n\tinode = nfs_fhget(data->dir->d_sb, &data->o_res.fh, &data->f_attr);\n\tret = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto err;\n\tret = -ENOMEM;\n\tstate = nfs4_get_open_state(inode, data->owner);\n\tif (state == NULL)\n\t\tgoto err_put_inode;\n\tif (data->o_res.delegation_type != 0) {\n\t\tint delegation_flags = 0;\n\n\t\trcu_read_lock();\n\t\tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n\t\tif (delegation)\n\t\t\tdelegation_flags = delegation->flags;\n\t\trcu_read_unlock();\n\t\tif ((delegation_flags & 1UL<<NFS_DELEGATION_NEED_RECLAIM) == 0)\n\t\t\tnfs_inode_set_delegation(state->inode,\n\t\t\t\t\tdata->owner->so_cred,\n\t\t\t\t\t&data->o_res);\n\t\telse\n\t\t\tnfs_inode_reclaim_delegation(state->inode,\n\t\t\t\t\tdata->owner->so_cred,\n\t\t\t\t\t&data->o_res);\n\t}\n\n\tupdate_open_stateid(state, &data->o_res.stateid, NULL,\n\t\t\tdata->o_arg.open_flags);\n\tiput(inode);\nout:\n\treturn state;\nerr_put_inode:\n\tiput(inode);\nerr:\n\treturn ERR_PTR(ret);\n}\n\nstatic struct nfs_open_context *nfs4_state_find_open_context(struct nfs4_state *state)\n{\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_open_context *ctx;\n\n\tspin_lock(&state->inode->i_lock);\n\tlist_for_each_entry(ctx, &nfsi->open_files, list) {\n\t\tif (ctx->state != state)\n\t\t\tcontinue;\n\t\tget_nfs_open_context(ctx);\n\t\tspin_unlock(&state->inode->i_lock);\n\t\treturn ctx;\n\t}\n\tspin_unlock(&state->inode->i_lock);\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic struct nfs4_opendata *nfs4_open_recoverdata_alloc(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs4_opendata *opendata;\n\n\topendata = nfs4_opendata_alloc(&ctx->path, state->owner, 0, NULL);\n\tif (opendata == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\topendata->state = state;\n\tatomic_inc(&state->count);\n\treturn opendata;\n}\n\nstatic int nfs4_open_recover_helper(struct nfs4_opendata *opendata, mode_t openflags, struct nfs4_state **res)\n{\n\tstruct nfs4_state *newstate;\n\tint ret;\n\n\topendata->o_arg.open_flags = openflags;\n\tmemset(&opendata->o_res, 0, sizeof(opendata->o_res));\n\tmemset(&opendata->c_res, 0, sizeof(opendata->c_res));\n\tnfs4_init_opendata_res(opendata);\n\tret = _nfs4_proc_open(opendata);\n\tif (ret != 0)\n\t\treturn ret; \n\tnewstate = nfs4_opendata_to_nfs4_state(opendata);\n\tif (IS_ERR(newstate))\n\t\treturn PTR_ERR(newstate);\n\tnfs4_close_state(&opendata->path, newstate, openflags);\n\t*res = newstate;\n\treturn 0;\n}\n\nstatic int nfs4_open_recover(struct nfs4_opendata *opendata, struct nfs4_state *state)\n{\n\tstruct nfs4_state *newstate;\n\tint ret;\n\n\t/* memory barrier prior to reading state->n_* */\n\tclear_bit(NFS_DELEGATED_STATE, &state->flags);\n\tsmp_rmb();\n\tif (state->n_rdwr != 0) {\n\t\tret = nfs4_open_recover_helper(opendata, FMODE_READ|FMODE_WRITE, &newstate);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tif (newstate != state)\n\t\t\treturn -ESTALE;\n\t}\n\tif (state->n_wronly != 0) {\n\t\tret = nfs4_open_recover_helper(opendata, FMODE_WRITE, &newstate);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tif (newstate != state)\n\t\t\treturn -ESTALE;\n\t}\n\tif (state->n_rdonly != 0) {\n\t\tret = nfs4_open_recover_helper(opendata, FMODE_READ, &newstate);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tif (newstate != state)\n\t\t\treturn -ESTALE;\n\t}\n\t/*\n\t * We may have performed cached opens for all three recoveries.\n\t * Check if we need to update the current stateid.\n\t */\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0 &&\n\t    memcmp(state->stateid.data, state->open_stateid.data, sizeof(state->stateid.data)) != 0) {\n\t\twrite_seqlock(&state->seqlock);\n\t\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0)\n\t\t\tmemcpy(state->stateid.data, state->open_stateid.data, sizeof(state->stateid.data));\n\t\twrite_sequnlock(&state->seqlock);\n\t}\n\treturn 0;\n}\n\n/*\n * OPEN_RECLAIM:\n * \treclaim state on the server after a reboot.\n */\nstatic int _nfs4_do_open_reclaim(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs_delegation *delegation;\n\tstruct nfs4_opendata *opendata;\n\tint delegation_type = 0;\n\tint status;\n\n\topendata = nfs4_open_recoverdata_alloc(ctx, state);\n\tif (IS_ERR(opendata))\n\t\treturn PTR_ERR(opendata);\n\topendata->o_arg.claim = NFS4_OPEN_CLAIM_PREVIOUS;\n\topendata->o_arg.fh = NFS_FH(state->inode);\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(state->inode)->delegation);\n\tif (delegation != NULL && test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags) != 0)\n\t\tdelegation_type = delegation->type;\n\trcu_read_unlock();\n\topendata->o_arg.u.delegation_type = delegation_type;\n\tstatus = nfs4_open_recover(opendata, state);\n\tnfs4_opendata_put(opendata);\n\treturn status;\n}\n\nstatic int nfs4_do_open_reclaim(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = _nfs4_do_open_reclaim(ctx, state);\n\t\tif (err != -NFS4ERR_DELAY)\n\t\t\tbreak;\n\t\tnfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int nfs4_open_reclaim(struct nfs4_state_owner *sp, struct nfs4_state *state)\n{\n\tstruct nfs_open_context *ctx;\n\tint ret;\n\n\tctx = nfs4_state_find_open_context(state);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\tret = nfs4_do_open_reclaim(ctx, state);\n\tput_nfs_open_context(ctx);\n\treturn ret;\n}\n\nstatic int _nfs4_open_delegation_recall(struct nfs_open_context *ctx, struct nfs4_state *state, const nfs4_stateid *stateid)\n{\n\tstruct nfs4_opendata *opendata;\n\tint ret;\n\n\topendata = nfs4_open_recoverdata_alloc(ctx, state);\n\tif (IS_ERR(opendata))\n\t\treturn PTR_ERR(opendata);\n\topendata->o_arg.claim = NFS4_OPEN_CLAIM_DELEGATE_CUR;\n\tmemcpy(opendata->o_arg.u.delegation.data, stateid->data,\n\t\t\tsizeof(opendata->o_arg.u.delegation.data));\n\tret = nfs4_open_recover(opendata, state);\n\tnfs4_opendata_put(opendata);\n\treturn ret;\n}\n\nint nfs4_open_delegation_recall(struct nfs_open_context *ctx, struct nfs4_state *state, const nfs4_stateid *stateid)\n{\n\tstruct nfs4_exception exception = { };\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tint err;\n\tdo {\n\t\terr = _nfs4_open_delegation_recall(ctx, state, stateid);\n\t\tswitch (err) {\n\t\t\tcase 0:\n\t\t\t\treturn err;\n\t\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tcase -NFS4ERR_STALE_STATEID:\n\t\t\tcase -NFS4ERR_EXPIRED:\n\t\t\t\t/* Don't recall a delegation if it was lost */\n\t\t\t\tnfs4_schedule_state_recovery(server->nfs_client);\n\t\t\t\treturn err;\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic void nfs4_open_confirm_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\n\tdata->rpc_status = task->tk_status;\n\tif (RPC_ASSASSINATED(task))\n\t\treturn;\n\tif (data->rpc_status == 0) {\n\t\tmemcpy(data->o_res.stateid.data, data->c_res.stateid.data,\n\t\t\t\tsizeof(data->o_res.stateid.data));\n\t\tnfs_confirm_seqid(&data->owner->so_seqid, 0);\n\t\trenew_lease(data->o_res.server, data->timestamp);\n\t\tdata->rpc_done = 1;\n\t}\n}\n\nstatic void nfs4_open_confirm_release(void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state *state = NULL;\n\n\t/* If this request hasn't been cancelled, do nothing */\n\tif (data->cancelled == 0)\n\t\tgoto out_free;\n\t/* In case of error, no cleanup! */\n\tif (!data->rpc_done)\n\t\tgoto out_free;\n\tstate = nfs4_opendata_to_nfs4_state(data);\n\tif (!IS_ERR(state))\n\t\tnfs4_close_state(&data->path, state, data->o_arg.open_flags);\nout_free:\n\tnfs4_opendata_put(data);\n}\n\nstatic const struct rpc_call_ops nfs4_open_confirm_ops = {\n\t.rpc_call_done = nfs4_open_confirm_done,\n\t.rpc_release = nfs4_open_confirm_release,\n};\n\n/*\n * Note: On error, nfs4_proc_open_confirm will free the struct nfs4_opendata\n */\nstatic int _nfs4_proc_open_confirm(struct nfs4_opendata *data)\n{\n\tstruct nfs_server *server = NFS_SERVER(data->dir->d_inode);\n\tstruct rpc_task *task;\n\tstruct  rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_CONFIRM],\n\t\t.rpc_argp = &data->c_arg,\n\t\t.rpc_resp = &data->c_res,\n\t\t.rpc_cred = data->owner->so_cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_open_confirm_ops,\n\t\t.callback_data = data,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tint status;\n\n\tkref_get(&data->kref);\n\tdata->rpc_done = 0;\n\tdata->rpc_status = 0;\n\tdata->timestamp = jiffies;\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tstatus = nfs4_wait_for_completion_rpc_task(task);\n\tif (status != 0) {\n\t\tdata->cancelled = 1;\n\t\tsmp_wmb();\n\t} else\n\t\tstatus = data->rpc_status;\n\trpc_put_task(task);\n\treturn status;\n}\n\nstatic void nfs4_open_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state_owner *sp = data->owner;\n\n\tif (nfs_wait_on_sequence(data->o_arg.seqid, task) != 0)\n\t\treturn;\n\t/*\n\t * Check if we still need to send an OPEN call, or if we can use\n\t * a delegation instead.\n\t */\n\tif (data->state != NULL) {\n\t\tstruct nfs_delegation *delegation;\n\n\t\tif (can_open_cached(data->state, data->o_arg.open_flags & (FMODE_READ|FMODE_WRITE|O_EXCL)))\n\t\t\tgoto out_no_action;\n\t\trcu_read_lock();\n\t\tdelegation = rcu_dereference(NFS_I(data->state->inode)->delegation);\n\t\tif (delegation != NULL &&\n\t\t    test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags) == 0) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto out_no_action;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\t/* Update sequence id. */\n\tdata->o_arg.id = sp->so_owner_id.id;\n\tdata->o_arg.clientid = sp->so_client->cl_clientid;\n\tif (data->o_arg.claim == NFS4_OPEN_CLAIM_PREVIOUS) {\n\t\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_NOATTR];\n\t\tnfs_copy_fh(&data->o_res.fh, data->o_arg.fh);\n\t}\n\tdata->timestamp = jiffies;\n\trpc_call_start(task);\n\treturn;\nout_no_action:\n\ttask->tk_action = NULL;\n\n}\n\nstatic void nfs4_open_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\n\tdata->rpc_status = task->tk_status;\n\tif (RPC_ASSASSINATED(task))\n\t\treturn;\n\tif (task->tk_status == 0) {\n\t\tswitch (data->o_res.f_attr->mode & S_IFMT) {\n\t\t\tcase S_IFREG:\n\t\t\t\tbreak;\n\t\t\tcase S_IFLNK:\n\t\t\t\tdata->rpc_status = -ELOOP;\n\t\t\t\tbreak;\n\t\t\tcase S_IFDIR:\n\t\t\t\tdata->rpc_status = -EISDIR;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdata->rpc_status = -ENOTDIR;\n\t\t}\n\t\trenew_lease(data->o_res.server, data->timestamp);\n\t\tif (!(data->o_res.rflags & NFS4_OPEN_RESULT_CONFIRM))\n\t\t\tnfs_confirm_seqid(&data->owner->so_seqid, 0);\n\t}\n\tdata->rpc_done = 1;\n}\n\nstatic void nfs4_open_release(void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state *state = NULL;\n\n\t/* If this request hasn't been cancelled, do nothing */\n\tif (data->cancelled == 0)\n\t\tgoto out_free;\n\t/* In case of error, no cleanup! */\n\tif (data->rpc_status != 0 || !data->rpc_done)\n\t\tgoto out_free;\n\t/* In case we need an open_confirm, no cleanup! */\n\tif (data->o_res.rflags & NFS4_OPEN_RESULT_CONFIRM)\n\t\tgoto out_free;\n\tstate = nfs4_opendata_to_nfs4_state(data);\n\tif (!IS_ERR(state))\n\t\tnfs4_close_state(&data->path, state, data->o_arg.open_flags);\nout_free:\n\tnfs4_opendata_put(data);\n}\n\nstatic const struct rpc_call_ops nfs4_open_ops = {\n\t.rpc_call_prepare = nfs4_open_prepare,\n\t.rpc_call_done = nfs4_open_done,\n\t.rpc_release = nfs4_open_release,\n};\n\n/*\n * Note: On error, nfs4_proc_open will free the struct nfs4_opendata\n */\nstatic int _nfs4_proc_open(struct nfs4_opendata *data)\n{\n\tstruct inode *dir = data->dir->d_inode;\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs_openargs *o_arg = &data->o_arg;\n\tstruct nfs_openres *o_res = &data->o_res;\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN],\n\t\t.rpc_argp = o_arg,\n\t\t.rpc_resp = o_res,\n\t\t.rpc_cred = data->owner->so_cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_open_ops,\n\t\t.callback_data = data,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tint status;\n\n\tkref_get(&data->kref);\n\tdata->rpc_done = 0;\n\tdata->rpc_status = 0;\n\tdata->cancelled = 0;\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tstatus = nfs4_wait_for_completion_rpc_task(task);\n\tif (status != 0) {\n\t\tdata->cancelled = 1;\n\t\tsmp_wmb();\n\t} else\n\t\tstatus = data->rpc_status;\n\trpc_put_task(task);\n\tif (status != 0 || !data->rpc_done)\n\t\treturn status;\n\n\tif (o_res->fh.size == 0)\n\t\t_nfs4_proc_lookup(dir, o_arg->name, &o_res->fh, o_res->f_attr);\n\n\tif (o_arg->open_flags & O_CREAT) {\n\t\tupdate_changeattr(dir, &o_res->cinfo);\n\t\tnfs_post_op_update_inode(dir, o_res->dir_attr);\n\t} else\n\t\tnfs_refresh_inode(dir, o_res->dir_attr);\n\tif(o_res->rflags & NFS4_OPEN_RESULT_CONFIRM) {\n\t\tstatus = _nfs4_proc_open_confirm(data);\n\t\tif (status != 0)\n\t\t\treturn status;\n\t}\n\tif (!(o_res->f_attr->valid & NFS_ATTR_FATTR))\n\t\t_nfs4_proc_getattr(server, &o_res->fh, o_res->f_attr);\n\treturn 0;\n}\n\nstatic int nfs4_recover_expired_lease(struct nfs_server *server)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tint ret;\n\n\tfor (;;) {\n\t\tret = nfs4_wait_clnt_recover(clp);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tif (!test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state) &&\n\t\t    !test_bit(NFS4CLNT_CHECK_LEASE,&clp->cl_state))\n\t\t\tbreak;\n\t\tnfs4_schedule_state_recovery(clp);\n\t}\n\treturn 0;\n}\n\n/*\n * OPEN_EXPIRED:\n * \treclaim state on the server after a network partition.\n * \tAssumes caller holds the appropriate lock\n */\nstatic int _nfs4_open_expired(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs4_opendata *opendata;\n\tint ret;\n\n\topendata = nfs4_open_recoverdata_alloc(ctx, state);\n\tif (IS_ERR(opendata))\n\t\treturn PTR_ERR(opendata);\n\tret = nfs4_open_recover(opendata, state);\n\tif (ret == -ESTALE)\n\t\td_drop(ctx->path.dentry);\n\tnfs4_opendata_put(opendata);\n\treturn ret;\n}\n\nstatic inline int nfs4_do_open_expired(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = _nfs4_open_expired(ctx, state);\n\t\tif (err == -NFS4ERR_DELAY)\n\t\t\tnfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int nfs4_open_expired(struct nfs4_state_owner *sp, struct nfs4_state *state)\n{\n\tstruct nfs_open_context *ctx;\n\tint ret;\n\n\tctx = nfs4_state_find_open_context(state);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\tret = nfs4_do_open_expired(ctx, state);\n\tput_nfs_open_context(ctx);\n\treturn ret;\n}\n\n/*\n * on an EXCLUSIVE create, the server should send back a bitmask with FATTR4-*\n * fields corresponding to attributes that were used to store the verifier.\n * Make sure we clobber those fields in the later setattr call\n */\nstatic inline void nfs4_exclusive_attrset(struct nfs4_opendata *opendata, struct iattr *sattr)\n{\n\tif ((opendata->o_res.attrset[1] & FATTR4_WORD1_TIME_ACCESS) &&\n\t    !(sattr->ia_valid & ATTR_ATIME_SET))\n\t\tsattr->ia_valid |= ATTR_ATIME;\n\n\tif ((opendata->o_res.attrset[1] & FATTR4_WORD1_TIME_MODIFY) &&\n\t    !(sattr->ia_valid & ATTR_MTIME_SET))\n\t\tsattr->ia_valid |= ATTR_MTIME;\n}\n\n/*\n * Returns a referenced nfs4_state\n */\nstatic int _nfs4_do_open(struct inode *dir, struct path *path, int flags, struct iattr *sattr, struct rpc_cred *cred, struct nfs4_state **res)\n{\n\tstruct nfs4_state_owner  *sp;\n\tstruct nfs4_state     *state = NULL;\n\tstruct nfs_server       *server = NFS_SERVER(dir);\n\tstruct nfs4_opendata *opendata;\n\tint status;\n\n\t/* Protect against reboot recovery conflicts */\n\tstatus = -ENOMEM;\n\tif (!(sp = nfs4_get_state_owner(server, cred))) {\n\t\tdprintk(\"nfs4_do_open: nfs4_get_state_owner failed!\\n\");\n\t\tgoto out_err;\n\t}\n\tstatus = nfs4_recover_expired_lease(server);\n\tif (status != 0)\n\t\tgoto err_put_state_owner;\n\tif (path->dentry->d_inode != NULL)\n\t\tnfs4_return_incompatible_delegation(path->dentry->d_inode, flags & (FMODE_READ|FMODE_WRITE));\n\tstatus = -ENOMEM;\n\topendata = nfs4_opendata_alloc(path, sp, flags, sattr);\n\tif (opendata == NULL)\n\t\tgoto err_put_state_owner;\n\n\tif (path->dentry->d_inode != NULL)\n\t\topendata->state = nfs4_get_open_state(path->dentry->d_inode, sp);\n\n\tstatus = _nfs4_proc_open(opendata);\n\tif (status != 0)\n\t\tgoto err_opendata_put;\n\n\tif (opendata->o_arg.open_flags & O_EXCL)\n\t\tnfs4_exclusive_attrset(opendata, sattr);\n\n\tstate = nfs4_opendata_to_nfs4_state(opendata);\n\tstatus = PTR_ERR(state);\n\tif (IS_ERR(state))\n\t\tgoto err_opendata_put;\n\tnfs4_opendata_put(opendata);\n\tnfs4_put_state_owner(sp);\n\t*res = state;\n\treturn 0;\nerr_opendata_put:\n\tnfs4_opendata_put(opendata);\nerr_put_state_owner:\n\tnfs4_put_state_owner(sp);\nout_err:\n\t*res = NULL;\n\treturn status;\n}\n\n\nstatic struct nfs4_state *nfs4_do_open(struct inode *dir, struct path *path, int flags, struct iattr *sattr, struct rpc_cred *cred)\n{\n\tstruct nfs4_exception exception = { };\n\tstruct nfs4_state *res;\n\tint status;\n\n\tdo {\n\t\tstatus = _nfs4_do_open(dir, path, flags, sattr, cred, &res);\n\t\tif (status == 0)\n\t\t\tbreak;\n\t\t/* NOTE: BAD_SEQID means the server and client disagree about the\n\t\t * book-keeping w.r.t. state-changing operations\n\t\t * (OPEN/CLOSE/LOCK/LOCKU...)\n\t\t * It is actually a sign of a bug on the client or on the server.\n\t\t *\n\t\t * If we receive a BAD_SEQID error in the particular case of\n\t\t * doing an OPEN, we assume that nfs_increment_open_seqid() will\n\t\t * have unhashed the old state_owner for us, and that we can\n\t\t * therefore safely retry using a new one. We should still warn\n\t\t * the user though...\n\t\t */\n\t\tif (status == -NFS4ERR_BAD_SEQID) {\n\t\t\tprintk(KERN_WARNING \"NFS: v4 server %s \"\n\t\t\t\t\t\" returned a bad sequence-id error!\\n\",\n\t\t\t\t\tNFS_SERVER(dir)->nfs_client->cl_hostname);\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * BAD_STATEID on OPEN means that the server cancelled our\n\t\t * state before it received the OPEN_CONFIRM.\n\t\t * Recover by retrying the request as per the discussion\n\t\t * on Page 181 of RFC3530.\n\t\t */\n\t\tif (status == -NFS4ERR_BAD_STATEID) {\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -EAGAIN) {\n\t\t\t/* We must have found a delegation */\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tres = ERR_PTR(nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t\tstatus, &exception));\n\t} while (exception.retry);\n\treturn res;\n}\n\nstatic int _nfs4_do_setattr(struct inode *inode, struct rpc_cred *cred,\n\t\t\t    struct nfs_fattr *fattr, struct iattr *sattr,\n\t\t\t    struct nfs4_state *state)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n        struct nfs_setattrargs  arg = {\n                .fh             = NFS_FH(inode),\n                .iap            = sattr,\n\t\t.server\t\t= server,\n\t\t.bitmask = server->attr_bitmask,\n        };\n        struct nfs_setattrres  res = {\n\t\t.fattr\t\t= fattr,\n\t\t.server\t\t= server,\n        };\n        struct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_SETATTR],\n\t\t.rpc_argp\t= &arg,\n\t\t.rpc_resp\t= &res,\n\t\t.rpc_cred\t= cred,\n        };\n\tunsigned long timestamp = jiffies;\n\tint status;\n\n\tnfs_fattr_init(fattr);\n\n\tif (nfs4_copy_delegation_stateid(&arg.stateid, inode)) {\n\t\t/* Use that stateid */\n\t} else if (state != NULL) {\n\t\tnfs4_copy_stateid(&arg.stateid, state, current->files);\n\t} else\n\t\tmemcpy(&arg.stateid, &zero_stateid, sizeof(arg.stateid));\n\n\tstatus = rpc_call_sync(server->client, &msg, 0);\n\tif (status == 0 && state != NULL)\n\t\trenew_lease(server, timestamp);\n\treturn status;\n}\n\nstatic int nfs4_do_setattr(struct inode *inode, struct rpc_cred *cred,\n\t\t\t   struct nfs_fattr *fattr, struct iattr *sattr,\n\t\t\t   struct nfs4_state *state)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs4_do_setattr(inode, cred, fattr, sattr, state),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstruct nfs4_closedata {\n\tstruct path path;\n\tstruct inode *inode;\n\tstruct nfs4_state *state;\n\tstruct nfs_closeargs arg;\n\tstruct nfs_closeres res;\n\tstruct nfs_fattr fattr;\n\tunsigned long timestamp;\n};\n\nstatic void nfs4_free_closedata(void *data)\n{\n\tstruct nfs4_closedata *calldata = data;\n\tstruct nfs4_state_owner *sp = calldata->state->owner;\n\n\tnfs4_put_open_state(calldata->state);\n\tnfs_free_seqid(calldata->arg.seqid);\n\tnfs4_put_state_owner(sp);\n\tpath_put(&calldata->path);\n\tkfree(calldata);\n}\n\nstatic void nfs4_close_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_closedata *calldata = data;\n\tstruct nfs4_state *state = calldata->state;\n\tstruct nfs_server *server = NFS_SERVER(calldata->inode);\n\n\tif (RPC_ASSASSINATED(task))\n\t\treturn;\n        /* hmm. we are done with the inode, and in the process of freeing\n\t * the state_owner. we keep this around to process errors\n\t */\n\tswitch (task->tk_status) {\n\t\tcase 0:\n\t\t\tnfs_set_open_stateid(state, &calldata->res.stateid, 0);\n\t\t\trenew_lease(server, calldata->timestamp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_OLD_STATEID:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tif (calldata->arg.open_flags == 0)\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (nfs4_async_handle_error(task, server, state) == -EAGAIN) {\n\t\t\t\trpc_restart_call(task);\n\t\t\t\treturn;\n\t\t\t}\n\t}\n\tnfs_refresh_inode(calldata->inode, calldata->res.fattr);\n}\n\nstatic void nfs4_close_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_closedata *calldata = data;\n\tstruct nfs4_state *state = calldata->state;\n\tint clear_rd, clear_wr, clear_rdwr;\n\n\tif (nfs_wait_on_sequence(calldata->arg.seqid, task) != 0)\n\t\treturn;\n\n\tclear_rd = clear_wr = clear_rdwr = 0;\n\tspin_lock(&state->owner->so_lock);\n\t/* Calculate the change in open mode */\n\tif (state->n_rdwr == 0) {\n\t\tif (state->n_rdonly == 0) {\n\t\t\tclear_rd |= test_and_clear_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tclear_rdwr |= test_and_clear_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (state->n_wronly == 0) {\n\t\t\tclear_wr |= test_and_clear_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tclear_rdwr |= test_and_clear_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t}\n\tspin_unlock(&state->owner->so_lock);\n\tif (!clear_rd && !clear_wr && !clear_rdwr) {\n\t\t/* Note: exit _without_ calling nfs4_close_done */\n\t\ttask->tk_action = NULL;\n\t\treturn;\n\t}\n\tnfs_fattr_init(calldata->res.fattr);\n\tif (test_bit(NFS_O_RDONLY_STATE, &state->flags) != 0) {\n\t\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_DOWNGRADE];\n\t\tcalldata->arg.open_flags = FMODE_READ;\n\t} else if (test_bit(NFS_O_WRONLY_STATE, &state->flags) != 0) {\n\t\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_DOWNGRADE];\n\t\tcalldata->arg.open_flags = FMODE_WRITE;\n\t}\n\tcalldata->timestamp = jiffies;\n\trpc_call_start(task);\n}\n\nstatic const struct rpc_call_ops nfs4_close_ops = {\n\t.rpc_call_prepare = nfs4_close_prepare,\n\t.rpc_call_done = nfs4_close_done,\n\t.rpc_release = nfs4_free_closedata,\n};\n\n/* \n * It is possible for data to be read/written from a mem-mapped file \n * after the sys_close call (which hits the vfs layer as a flush).\n * This means that we can't safely call nfsv4 close on a file until \n * the inode is cleared. This in turn means that we are not good\n * NFSv4 citizens - we do not indicate to the server to update the file's \n * share state even when we are done with one of the three share \n * stateid's in the inode.\n *\n * NOTE: Caller must be holding the sp->so_owner semaphore!\n */\nint nfs4_do_close(struct path *path, struct nfs4_state *state, int wait)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_closedata *calldata;\n\tstruct nfs4_state_owner *sp = state->owner;\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_CLOSE],\n\t\t.rpc_cred = state->owner->so_cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_close_ops,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tint status = -ENOMEM;\n\n\tcalldata = kmalloc(sizeof(*calldata), GFP_KERNEL);\n\tif (calldata == NULL)\n\t\tgoto out;\n\tcalldata->inode = state->inode;\n\tcalldata->state = state;\n\tcalldata->arg.fh = NFS_FH(state->inode);\n\tcalldata->arg.stateid = &state->open_stateid;\n\t/* Serialization for the sequence id */\n\tcalldata->arg.seqid = nfs_alloc_seqid(&state->owner->so_seqid);\n\tif (calldata->arg.seqid == NULL)\n\t\tgoto out_free_calldata;\n\tcalldata->arg.open_flags = 0;\n\tcalldata->arg.bitmask = server->attr_bitmask;\n\tcalldata->res.fattr = &calldata->fattr;\n\tcalldata->res.seqid = calldata->arg.seqid;\n\tcalldata->res.server = server;\n\tcalldata->path.mnt = mntget(path->mnt);\n\tcalldata->path.dentry = dget(path->dentry);\n\n\tmsg.rpc_argp = &calldata->arg,\n\tmsg.rpc_resp = &calldata->res,\n\ttask_setup_data.callback_data = calldata;\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tstatus = 0;\n\tif (wait)\n\t\tstatus = rpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn status;\nout_free_calldata:\n\tkfree(calldata);\nout:\n\tnfs4_put_open_state(state);\n\tnfs4_put_state_owner(sp);\n\treturn status;\n}\n\nstatic int nfs4_intent_set_file(struct nameidata *nd, struct path *path, struct nfs4_state *state)\n{\n\tstruct file *filp;\n\tint ret;\n\n\t/* If the open_intent is for execute, we have an extra check to make */\n\tif (nd->intent.open.flags & FMODE_EXEC) {\n\t\tret = nfs_may_open(state->inode,\n\t\t\t\tstate->owner->so_cred,\n\t\t\t\tnd->intent.open.flags);\n\t\tif (ret < 0)\n\t\t\tgoto out_close;\n\t}\n\tfilp = lookup_instantiate_filp(nd, path->dentry, NULL);\n\tif (!IS_ERR(filp)) {\n\t\tstruct nfs_open_context *ctx;\n\t\tctx = nfs_file_open_context(filp);\n\t\tctx->state = state;\n\t\treturn 0;\n\t}\n\tret = PTR_ERR(filp);\nout_close:\n\tnfs4_close_sync(path, state, nd->intent.open.flags);\n\treturn ret;\n}\n\nstruct dentry *\nnfs4_atomic_open(struct inode *dir, struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct path path = {\n\t\t.mnt = nd->path.mnt,\n\t\t.dentry = dentry,\n\t};\n\tstruct dentry *parent;\n\tstruct iattr attr;\n\tstruct rpc_cred *cred;\n\tstruct nfs4_state *state;\n\tstruct dentry *res;\n\n\tif (nd->flags & LOOKUP_CREATE) {\n\t\tattr.ia_mode = nd->intent.open.create_mode;\n\t\tattr.ia_valid = ATTR_MODE;\n\t\tif (!IS_POSIXACL(dir))\n\t\t\tattr.ia_mode &= ~current->fs->umask;\n\t} else {\n\t\tattr.ia_valid = 0;\n\t\tBUG_ON(nd->intent.open.flags & O_CREAT);\n\t}\n\n\tcred = rpc_lookup_cred();\n\tif (IS_ERR(cred))\n\t\treturn (struct dentry *)cred;\n\tparent = dentry->d_parent;\n\t/* Protect against concurrent sillydeletes */\n\tnfs_block_sillyrename(parent);\n\tstate = nfs4_do_open(dir, &path, nd->intent.open.flags, &attr, cred);\n\tput_rpccred(cred);\n\tif (IS_ERR(state)) {\n\t\tif (PTR_ERR(state) == -ENOENT) {\n\t\t\td_add(dentry, NULL);\n\t\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\t}\n\t\tnfs_unblock_sillyrename(parent);\n\t\treturn (struct dentry *)state;\n\t}\n\tres = d_add_unique(dentry, igrab(state->inode));\n\tif (res != NULL)\n\t\tpath.dentry = res;\n\tnfs_set_verifier(path.dentry, nfs_save_change_attribute(dir));\n\tnfs_unblock_sillyrename(parent);\n\tnfs4_intent_set_file(nd, &path, state);\n\treturn res;\n}\n\nint\nnfs4_open_revalidate(struct inode *dir, struct dentry *dentry, int openflags, struct nameidata *nd)\n{\n\tstruct path path = {\n\t\t.mnt = nd->path.mnt,\n\t\t.dentry = dentry,\n\t};\n\tstruct rpc_cred *cred;\n\tstruct nfs4_state *state;\n\n\tcred = rpc_lookup_cred();\n\tif (IS_ERR(cred))\n\t\treturn PTR_ERR(cred);\n\tstate = nfs4_do_open(dir, &path, openflags, NULL, cred);\n\tput_rpccred(cred);\n\tif (IS_ERR(state)) {\n\t\tswitch (PTR_ERR(state)) {\n\t\t\tcase -EPERM:\n\t\t\tcase -EACCES:\n\t\t\tcase -EDQUOT:\n\t\t\tcase -ENOSPC:\n\t\t\tcase -EROFS:\n\t\t\t\tlookup_instantiate_filp(nd, (struct dentry *)state, NULL);\n\t\t\t\treturn 1;\n\t\t\tdefault:\n\t\t\t\tgoto out_drop;\n\t\t}\n\t}\n\tif (state->inode == dentry->d_inode) {\n\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\tnfs4_intent_set_file(nd, &path, state);\n\t\treturn 1;\n\t}\n\tnfs4_close_sync(&path, state, openflags);\nout_drop:\n\td_drop(dentry);\n\treturn 0;\n}\n\n\nstatic int _nfs4_server_capabilities(struct nfs_server *server, struct nfs_fh *fhandle)\n{\n\tstruct nfs4_server_caps_res res = {};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SERVER_CAPS],\n\t\t.rpc_argp = fhandle,\n\t\t.rpc_resp = &res,\n\t};\n\tint status;\n\n\tstatus = rpc_call_sync(server->client, &msg, 0);\n\tif (status == 0) {\n\t\tmemcpy(server->attr_bitmask, res.attr_bitmask, sizeof(server->attr_bitmask));\n\t\tif (res.attr_bitmask[0] & FATTR4_WORD0_ACL)\n\t\t\tserver->caps |= NFS_CAP_ACLS;\n\t\tif (res.has_links != 0)\n\t\t\tserver->caps |= NFS_CAP_HARDLINKS;\n\t\tif (res.has_symlinks != 0)\n\t\t\tserver->caps |= NFS_CAP_SYMLINKS;\n\t\tserver->acl_bitmask = res.acl_bitmask;\n\t}\n\treturn status;\n}\n\nint nfs4_server_capabilities(struct nfs_server *server, struct nfs_fh *fhandle)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs4_server_capabilities(server, fhandle),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_lookup_root(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\tstruct nfs_fsinfo *info)\n{\n\tstruct nfs4_lookup_root_arg args = {\n\t\t.bitmask = nfs4_fattr_bitmap,\n\t};\n\tstruct nfs4_lookup_res res = {\n\t\t.server = server,\n\t\t.fattr = info->fattr,\n\t\t.fh = fhandle,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LOOKUP_ROOT],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tnfs_fattr_init(info->fattr);\n\treturn rpc_call_sync(server->client, &msg, 0);\n}\n\nstatic int nfs4_lookup_root(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\tstruct nfs_fsinfo *info)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs4_lookup_root(server, fhandle, info),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n/*\n * get the file handle for the \"/\" directory on the server\n */\nstatic int nfs4_proc_get_root(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t\t      struct nfs_fsinfo *info)\n{\n\tint status;\n\n\tstatus = nfs4_lookup_root(server, fhandle, info);\n\tif (status == 0)\n\t\tstatus = nfs4_server_capabilities(server, fhandle);\n\tif (status == 0)\n\t\tstatus = nfs4_do_fsinfo(server, fhandle, info);\n\treturn nfs4_map_errors(status);\n}\n\n/*\n * Get locations and (maybe) other attributes of a referral.\n * Note that we'll actually follow the referral later when\n * we detect fsid mismatch in inode revalidation\n */\nstatic int nfs4_get_referral(struct inode *dir, const struct qstr *name, struct nfs_fattr *fattr, struct nfs_fh *fhandle)\n{\n\tint status = -ENOMEM;\n\tstruct page *page = NULL;\n\tstruct nfs4_fs_locations *locations = NULL;\n\n\tpage = alloc_page(GFP_KERNEL);\n\tif (page == NULL)\n\t\tgoto out;\n\tlocations = kmalloc(sizeof(struct nfs4_fs_locations), GFP_KERNEL);\n\tif (locations == NULL)\n\t\tgoto out;\n\n\tstatus = nfs4_proc_fs_locations(dir, name, locations, page);\n\tif (status != 0)\n\t\tgoto out;\n\t/* Make sure server returned a different fsid for the referral */\n\tif (nfs_fsid_equal(&NFS_SERVER(dir)->fsid, &locations->fattr.fsid)) {\n\t\tdprintk(\"%s: server did not return a different fsid for a referral at %s\\n\", __func__, name->name);\n\t\tstatus = -EIO;\n\t\tgoto out;\n\t}\n\n\tmemcpy(fattr, &locations->fattr, sizeof(struct nfs_fattr));\n\tfattr->valid |= NFS_ATTR_FATTR_V4_REFERRAL;\n\tif (!fattr->mode)\n\t\tfattr->mode = S_IFDIR;\n\tmemset(fhandle, 0, sizeof(struct nfs_fh));\nout:\n\tif (page)\n\t\t__free_page(page);\n\tif (locations)\n\t\tkfree(locations);\n\treturn status;\n}\n\nstatic int _nfs4_proc_getattr(struct nfs_server *server, struct nfs_fh *fhandle, struct nfs_fattr *fattr)\n{\n\tstruct nfs4_getattr_arg args = {\n\t\t.fh = fhandle,\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct nfs4_getattr_res res = {\n\t\t.fattr = fattr,\n\t\t.server = server,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETATTR],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\t\n\tnfs_fattr_init(fattr);\n\treturn rpc_call_sync(server->client, &msg, 0);\n}\n\nstatic int nfs4_proc_getattr(struct nfs_server *server, struct nfs_fh *fhandle, struct nfs_fattr *fattr)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs4_proc_getattr(server, fhandle, fattr),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n/* \n * The file is not closed if it is opened due to the a request to change\n * the size of the file. The open call will not be needed once the\n * VFS layer lookup-intents are implemented.\n *\n * Close is called when the inode is destroyed.\n * If we haven't opened the file for O_WRONLY, we\n * need to in the size_change case to obtain a stateid.\n *\n * Got race?\n * Because OPEN is always done by name in nfsv4, it is\n * possible that we opened a different file by the same\n * name.  We can recognize this race condition, but we\n * can't do anything about it besides returning an error.\n *\n * This will be fixed with VFS changes (lookup-intent).\n */\nstatic int\nnfs4_proc_setattr(struct dentry *dentry, struct nfs_fattr *fattr,\n\t\t  struct iattr *sattr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct rpc_cred *cred = NULL;\n\tstruct nfs4_state *state = NULL;\n\tint status;\n\n\tnfs_fattr_init(fattr);\n\t\n\t/* Search for an existing open(O_WRITE) file */\n\tif (sattr->ia_valid & ATTR_FILE) {\n\t\tstruct nfs_open_context *ctx;\n\n\t\tctx = nfs_file_open_context(sattr->ia_file);\n\t\tif (ctx) {\n\t\t\tcred = ctx->cred;\n\t\t\tstate = ctx->state;\n\t\t}\n\t}\n\n\tstatus = nfs4_do_setattr(inode, cred, fattr, sattr, state);\n\tif (status == 0)\n\t\tnfs_setattr_update_inode(inode, sattr);\n\treturn status;\n}\n\nstatic int _nfs4_proc_lookupfh(struct nfs_server *server, const struct nfs_fh *dirfh,\n\t\tconst struct qstr *name, struct nfs_fh *fhandle,\n\t\tstruct nfs_fattr *fattr)\n{\n\tint\t\t       status;\n\tstruct nfs4_lookup_arg args = {\n\t\t.bitmask = server->attr_bitmask,\n\t\t.dir_fh = dirfh,\n\t\t.name = name,\n\t};\n\tstruct nfs4_lookup_res res = {\n\t\t.server = server,\n\t\t.fattr = fattr,\n\t\t.fh = fhandle,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LOOKUP],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\n\tnfs_fattr_init(fattr);\n\n\tdprintk(\"NFS call  lookupfh %s\\n\", name->name);\n\tstatus = rpc_call_sync(server->client, &msg, 0);\n\tdprintk(\"NFS reply lookupfh: %d\\n\", status);\n\treturn status;\n}\n\nstatic int nfs4_proc_lookupfh(struct nfs_server *server, struct nfs_fh *dirfh,\n\t\t\t      struct qstr *name, struct nfs_fh *fhandle,\n\t\t\t      struct nfs_fattr *fattr)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = _nfs4_proc_lookupfh(server, dirfh, name, fhandle, fattr);\n\t\t/* FIXME: !!!! */\n\t\tif (err == -NFS4ERR_MOVED) {\n\t\t\terr = -EREMOTE;\n\t\t\tbreak;\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_proc_lookup(struct inode *dir, const struct qstr *name,\n\t\tstruct nfs_fh *fhandle, struct nfs_fattr *fattr)\n{\n\tint status;\n\t\n\tdprintk(\"NFS call  lookup %s\\n\", name->name);\n\tstatus = _nfs4_proc_lookupfh(NFS_SERVER(dir), NFS_FH(dir), name, fhandle, fattr);\n\tif (status == -NFS4ERR_MOVED)\n\t\tstatus = nfs4_get_referral(dir, name, fattr, fhandle);\n\tdprintk(\"NFS reply lookup: %d\\n\", status);\n\treturn status;\n}\n\nstatic int nfs4_proc_lookup(struct inode *dir, struct qstr *name, struct nfs_fh *fhandle, struct nfs_fattr *fattr)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t_nfs4_proc_lookup(dir, name, fhandle, fattr),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_proc_access(struct inode *inode, struct nfs_access_entry *entry)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_fattr fattr;\n\tstruct nfs4_accessargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct nfs4_accessres res = {\n\t\t.server = server,\n\t\t.fattr = &fattr,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_ACCESS],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = entry->cred,\n\t};\n\tint mode = entry->mask;\n\tint status;\n\n\t/*\n\t * Determine which access bits we want to ask for...\n\t */\n\tif (mode & MAY_READ)\n\t\targs.access |= NFS4_ACCESS_READ;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tif (mode & MAY_WRITE)\n\t\t\targs.access |= NFS4_ACCESS_MODIFY | NFS4_ACCESS_EXTEND | NFS4_ACCESS_DELETE;\n\t\tif (mode & MAY_EXEC)\n\t\t\targs.access |= NFS4_ACCESS_LOOKUP;\n\t} else {\n\t\tif (mode & MAY_WRITE)\n\t\t\targs.access |= NFS4_ACCESS_MODIFY | NFS4_ACCESS_EXTEND;\n\t\tif (mode & MAY_EXEC)\n\t\t\targs.access |= NFS4_ACCESS_EXECUTE;\n\t}\n\tnfs_fattr_init(&fattr);\n\tstatus = rpc_call_sync(NFS_CLIENT(inode), &msg, 0);\n\tif (!status) {\n\t\tentry->mask = 0;\n\t\tif (res.access & NFS4_ACCESS_READ)\n\t\t\tentry->mask |= MAY_READ;\n\t\tif (res.access & (NFS4_ACCESS_MODIFY | NFS4_ACCESS_EXTEND | NFS4_ACCESS_DELETE))\n\t\t\tentry->mask |= MAY_WRITE;\n\t\tif (res.access & (NFS4_ACCESS_LOOKUP|NFS4_ACCESS_EXECUTE))\n\t\t\tentry->mask |= MAY_EXEC;\n\t\tnfs_refresh_inode(inode, &fattr);\n\t}\n\treturn status;\n}\n\nstatic int nfs4_proc_access(struct inode *inode, struct nfs_access_entry *entry)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(inode),\n\t\t\t\t_nfs4_proc_access(inode, entry),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n/*\n * TODO: For the time being, we don't try to get any attributes\n * along with any of the zero-copy operations READ, READDIR,\n * READLINK, WRITE.\n *\n * In the case of the first three, we want to put the GETATTR\n * after the read-type operation -- this is because it is hard\n * to predict the length of a GETATTR response in v4, and thus\n * align the READ data correctly.  This means that the GETATTR\n * may end up partially falling into the page cache, and we should\n * shift it into the 'tail' of the xdr_buf before processing.\n * To do this efficiently, we need to know the total length\n * of data received, which doesn't seem to be available outside\n * of the RPC layer.\n *\n * In the case of WRITE, we also want to put the GETATTR after\n * the operation -- in this case because we want to make sure\n * we get the post-operation mtime and size.  This means that\n * we can't use xdr_encode_pages() as written: we need a variant\n * of it which would leave room in the 'tail' iovec.\n *\n * Both of these changes to the XDR layer would in fact be quite\n * minor, but I decided to leave them for a subsequent patch.\n */\nstatic int _nfs4_proc_readlink(struct inode *inode, struct page *page,\n\t\tunsigned int pgbase, unsigned int pglen)\n{\n\tstruct nfs4_readlink args = {\n\t\t.fh       = NFS_FH(inode),\n\t\t.pgbase\t  = pgbase,\n\t\t.pglen    = pglen,\n\t\t.pages    = &page,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_READLINK],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = NULL,\n\t};\n\n\treturn rpc_call_sync(NFS_CLIENT(inode), &msg, 0);\n}\n\nstatic int nfs4_proc_readlink(struct inode *inode, struct page *page,\n\t\tunsigned int pgbase, unsigned int pglen)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(inode),\n\t\t\t\t_nfs4_proc_readlink(inode, page, pgbase, pglen),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n/*\n * Got race?\n * We will need to arrange for the VFS layer to provide an atomic open.\n * Until then, this create/open method is prone to inefficiency and race\n * conditions due to the lookup, create, and open VFS calls from sys_open()\n * placed on the wire.\n *\n * Given the above sorry state of affairs, I'm simply sending an OPEN.\n * The file will be opened again in the subsequent VFS open call\n * (nfs4_proc_file_open).\n *\n * The open for read will just hang around to be used by any process that\n * opens the file O_RDONLY. This will all be resolved with the VFS changes.\n */\n\nstatic int\nnfs4_proc_create(struct inode *dir, struct dentry *dentry, struct iattr *sattr,\n                 int flags, struct nameidata *nd)\n{\n\tstruct path path = {\n\t\t.mnt = nd->path.mnt,\n\t\t.dentry = dentry,\n\t};\n\tstruct nfs4_state *state;\n\tstruct rpc_cred *cred;\n\tint status = 0;\n\n\tcred = rpc_lookup_cred();\n\tif (IS_ERR(cred)) {\n\t\tstatus = PTR_ERR(cred);\n\t\tgoto out;\n\t}\n\tstate = nfs4_do_open(dir, &path, flags, sattr, cred);\n\td_drop(dentry);\n\tif (IS_ERR(state)) {\n\t\tstatus = PTR_ERR(state);\n\t\tgoto out_putcred;\n\t}\n\td_add(dentry, igrab(state->inode));\n\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\tif (flags & O_EXCL) {\n\t\tstruct nfs_fattr fattr;\n\t\tstatus = nfs4_do_setattr(state->inode, cred, &fattr, sattr, state);\n\t\tif (status == 0)\n\t\t\tnfs_setattr_update_inode(state->inode, sattr);\n\t\tnfs_post_op_update_inode(state->inode, &fattr);\n\t}\n\tif (status == 0 && (nd->flags & LOOKUP_OPEN) != 0)\n\t\tstatus = nfs4_intent_set_file(nd, &path, state);\n\telse\n\t\tnfs4_close_sync(&path, state, flags);\nout_putcred:\n\tput_rpccred(cred);\nout:\n\treturn status;\n}\n\nstatic int _nfs4_proc_remove(struct inode *dir, struct qstr *name)\n{\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs_removeargs args = {\n\t\t.fh = NFS_FH(dir),\n\t\t.name.len = name->len,\n\t\t.name.name = name->name,\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct nfs_removeres res = {\n\t\t.server = server,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_REMOVE],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tint\t\t\tstatus;\n\n\tnfs_fattr_init(&res.dir_attr);\n\tstatus = rpc_call_sync(server->client, &msg, 0);\n\tif (status == 0) {\n\t\tupdate_changeattr(dir, &res.cinfo);\n\t\tnfs_post_op_update_inode(dir, &res.dir_attr);\n\t}\n\treturn status;\n}\n\nstatic int nfs4_proc_remove(struct inode *dir, struct qstr *name)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t_nfs4_proc_remove(dir, name),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic void nfs4_proc_unlink_setup(struct rpc_message *msg, struct inode *dir)\n{\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs_removeargs *args = msg->rpc_argp;\n\tstruct nfs_removeres *res = msg->rpc_resp;\n\n\targs->bitmask = server->attr_bitmask;\n\tres->server = server;\n\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_REMOVE];\n}\n\nstatic int nfs4_proc_unlink_done(struct rpc_task *task, struct inode *dir)\n{\n\tstruct nfs_removeres *res = task->tk_msg.rpc_resp;\n\n\tif (nfs4_async_handle_error(task, res->server, NULL) == -EAGAIN)\n\t\treturn 0;\n\tupdate_changeattr(dir, &res->cinfo);\n\tnfs_post_op_update_inode(dir, &res->dir_attr);\n\treturn 1;\n}\n\nstatic int _nfs4_proc_rename(struct inode *old_dir, struct qstr *old_name,\n\t\tstruct inode *new_dir, struct qstr *new_name)\n{\n\tstruct nfs_server *server = NFS_SERVER(old_dir);\n\tstruct nfs4_rename_arg arg = {\n\t\t.old_dir = NFS_FH(old_dir),\n\t\t.new_dir = NFS_FH(new_dir),\n\t\t.old_name = old_name,\n\t\t.new_name = new_name,\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct nfs_fattr old_fattr, new_fattr;\n\tstruct nfs4_rename_res res = {\n\t\t.server = server,\n\t\t.old_fattr = &old_fattr,\n\t\t.new_fattr = &new_fattr,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_RENAME],\n\t\t.rpc_argp = &arg,\n\t\t.rpc_resp = &res,\n\t};\n\tint\t\t\tstatus;\n\t\n\tnfs_fattr_init(res.old_fattr);\n\tnfs_fattr_init(res.new_fattr);\n\tstatus = rpc_call_sync(server->client, &msg, 0);\n\n\tif (!status) {\n\t\tupdate_changeattr(old_dir, &res.old_cinfo);\n\t\tnfs_post_op_update_inode(old_dir, res.old_fattr);\n\t\tupdate_changeattr(new_dir, &res.new_cinfo);\n\t\tnfs_post_op_update_inode(new_dir, res.new_fattr);\n\t}\n\treturn status;\n}\n\nstatic int nfs4_proc_rename(struct inode *old_dir, struct qstr *old_name,\n\t\tstruct inode *new_dir, struct qstr *new_name)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(old_dir),\n\t\t\t\t_nfs4_proc_rename(old_dir, old_name,\n\t\t\t\t\tnew_dir, new_name),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_proc_link(struct inode *inode, struct inode *dir, struct qstr *name)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs4_link_arg arg = {\n\t\t.fh     = NFS_FH(inode),\n\t\t.dir_fh = NFS_FH(dir),\n\t\t.name   = name,\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct nfs_fattr fattr, dir_attr;\n\tstruct nfs4_link_res res = {\n\t\t.server = server,\n\t\t.fattr = &fattr,\n\t\t.dir_attr = &dir_attr,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LINK],\n\t\t.rpc_argp = &arg,\n\t\t.rpc_resp = &res,\n\t};\n\tint\t\t\tstatus;\n\n\tnfs_fattr_init(res.fattr);\n\tnfs_fattr_init(res.dir_attr);\n\tstatus = rpc_call_sync(server->client, &msg, 0);\n\tif (!status) {\n\t\tupdate_changeattr(dir, &res.cinfo);\n\t\tnfs_post_op_update_inode(dir, res.dir_attr);\n\t\tnfs_post_op_update_inode(inode, res.fattr);\n\t}\n\n\treturn status;\n}\n\nstatic int nfs4_proc_link(struct inode *inode, struct inode *dir, struct qstr *name)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(inode),\n\t\t\t\t_nfs4_proc_link(inode, dir, name),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstruct nfs4_createdata {\n\tstruct rpc_message msg;\n\tstruct nfs4_create_arg arg;\n\tstruct nfs4_create_res res;\n\tstruct nfs_fh fh;\n\tstruct nfs_fattr fattr;\n\tstruct nfs_fattr dir_fattr;\n};\n\nstatic struct nfs4_createdata *nfs4_alloc_createdata(struct inode *dir,\n\t\tstruct qstr *name, struct iattr *sattr, u32 ftype)\n{\n\tstruct nfs4_createdata *data;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (data != NULL) {\n\t\tstruct nfs_server *server = NFS_SERVER(dir);\n\n\t\tdata->msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_CREATE];\n\t\tdata->msg.rpc_argp = &data->arg;\n\t\tdata->msg.rpc_resp = &data->res;\n\t\tdata->arg.dir_fh = NFS_FH(dir);\n\t\tdata->arg.server = server;\n\t\tdata->arg.name = name;\n\t\tdata->arg.attrs = sattr;\n\t\tdata->arg.ftype = ftype;\n\t\tdata->arg.bitmask = server->attr_bitmask;\n\t\tdata->res.server = server;\n\t\tdata->res.fh = &data->fh;\n\t\tdata->res.fattr = &data->fattr;\n\t\tdata->res.dir_fattr = &data->dir_fattr;\n\t\tnfs_fattr_init(data->res.fattr);\n\t\tnfs_fattr_init(data->res.dir_fattr);\n\t}\n\treturn data;\n}\n\nstatic int nfs4_do_create(struct inode *dir, struct dentry *dentry, struct nfs4_createdata *data)\n{\n\tint status = rpc_call_sync(NFS_CLIENT(dir), &data->msg, 0);\n\tif (status == 0) {\n\t\tupdate_changeattr(dir, &data->res.dir_cinfo);\n\t\tnfs_post_op_update_inode(dir, data->res.dir_fattr);\n\t\tstatus = nfs_instantiate(dentry, data->res.fh, data->res.fattr);\n\t}\n\treturn status;\n}\n\nstatic void nfs4_free_createdata(struct nfs4_createdata *data)\n{\n\tkfree(data);\n}\n\nstatic int _nfs4_proc_symlink(struct inode *dir, struct dentry *dentry,\n\t\tstruct page *page, unsigned int len, struct iattr *sattr)\n{\n\tstruct nfs4_createdata *data;\n\tint status = -ENAMETOOLONG;\n\n\tif (len > NFS4_MAXPATHLEN)\n\t\tgoto out;\n\n\tstatus = -ENOMEM;\n\tdata = nfs4_alloc_createdata(dir, &dentry->d_name, sattr, NF4LNK);\n\tif (data == NULL)\n\t\tgoto out;\n\n\tdata->msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SYMLINK];\n\tdata->arg.u.symlink.pages = &page;\n\tdata->arg.u.symlink.len = len;\n\t\n\tstatus = nfs4_do_create(dir, dentry, data);\n\n\tnfs4_free_createdata(data);\nout:\n\treturn status;\n}\n\nstatic int nfs4_proc_symlink(struct inode *dir, struct dentry *dentry,\n\t\tstruct page *page, unsigned int len, struct iattr *sattr)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t_nfs4_proc_symlink(dir, dentry, page,\n\t\t\t\t\t\t\tlen, sattr),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_proc_mkdir(struct inode *dir, struct dentry *dentry,\n\t\tstruct iattr *sattr)\n{\n\tstruct nfs4_createdata *data;\n\tint status = -ENOMEM;\n\n\tdata = nfs4_alloc_createdata(dir, &dentry->d_name, sattr, NF4DIR);\n\tif (data == NULL)\n\t\tgoto out;\n\n\tstatus = nfs4_do_create(dir, dentry, data);\n\n\tnfs4_free_createdata(data);\nout:\n\treturn status;\n}\n\nstatic int nfs4_proc_mkdir(struct inode *dir, struct dentry *dentry,\n\t\tstruct iattr *sattr)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t_nfs4_proc_mkdir(dir, dentry, sattr),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_proc_readdir(struct dentry *dentry, struct rpc_cred *cred,\n                  u64 cookie, struct page *page, unsigned int count, int plus)\n{\n\tstruct inode\t\t*dir = dentry->d_inode;\n\tstruct nfs4_readdir_arg args = {\n\t\t.fh = NFS_FH(dir),\n\t\t.pages = &page,\n\t\t.pgbase = 0,\n\t\t.count = count,\n\t\t.bitmask = NFS_SERVER(dentry->d_inode)->attr_bitmask,\n\t};\n\tstruct nfs4_readdir_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_READDIR],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = cred,\n\t};\n\tint\t\t\tstatus;\n\n\tdprintk(\"%s: dentry = %s/%s, cookie = %Lu\\n\", __func__,\n\t\t\tdentry->d_parent->d_name.name,\n\t\t\tdentry->d_name.name,\n\t\t\t(unsigned long long)cookie);\n\tnfs4_setup_readdir(cookie, NFS_COOKIEVERF(dir), dentry, &args);\n\tres.pgbase = args.pgbase;\n\tstatus = rpc_call_sync(NFS_CLIENT(dir), &msg, 0);\n\tif (status == 0)\n\t\tmemcpy(NFS_COOKIEVERF(dir), res.verifier.data, NFS4_VERIFIER_SIZE);\n\n\tnfs_invalidate_atime(dir);\n\n\tdprintk(\"%s: returns %d\\n\", __func__, status);\n\treturn status;\n}\n\nstatic int nfs4_proc_readdir(struct dentry *dentry, struct rpc_cred *cred,\n                  u64 cookie, struct page *page, unsigned int count, int plus)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(dentry->d_inode),\n\t\t\t\t_nfs4_proc_readdir(dentry, cred, cookie,\n\t\t\t\t\tpage, count, plus),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_proc_mknod(struct inode *dir, struct dentry *dentry,\n\t\tstruct iattr *sattr, dev_t rdev)\n{\n\tstruct nfs4_createdata *data;\n\tint mode = sattr->ia_mode;\n\tint status = -ENOMEM;\n\n\tBUG_ON(!(sattr->ia_valid & ATTR_MODE));\n\tBUG_ON(!S_ISFIFO(mode) && !S_ISBLK(mode) && !S_ISCHR(mode) && !S_ISSOCK(mode));\n\n\tdata = nfs4_alloc_createdata(dir, &dentry->d_name, sattr, NF4SOCK);\n\tif (data == NULL)\n\t\tgoto out;\n\n\tif (S_ISFIFO(mode))\n\t\tdata->arg.ftype = NF4FIFO;\n\telse if (S_ISBLK(mode)) {\n\t\tdata->arg.ftype = NF4BLK;\n\t\tdata->arg.u.device.specdata1 = MAJOR(rdev);\n\t\tdata->arg.u.device.specdata2 = MINOR(rdev);\n\t}\n\telse if (S_ISCHR(mode)) {\n\t\tdata->arg.ftype = NF4CHR;\n\t\tdata->arg.u.device.specdata1 = MAJOR(rdev);\n\t\tdata->arg.u.device.specdata2 = MINOR(rdev);\n\t}\n\t\n\tstatus = nfs4_do_create(dir, dentry, data);\n\n\tnfs4_free_createdata(data);\nout:\n\treturn status;\n}\n\nstatic int nfs4_proc_mknod(struct inode *dir, struct dentry *dentry,\n\t\tstruct iattr *sattr, dev_t rdev)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t_nfs4_proc_mknod(dir, dentry, sattr, rdev),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_proc_statfs(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t struct nfs_fsstat *fsstat)\n{\n\tstruct nfs4_statfs_arg args = {\n\t\t.fh = fhandle,\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_STATFS],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = fsstat,\n\t};\n\n\tnfs_fattr_init(fsstat->fattr);\n\treturn rpc_call_sync(server->client, &msg, 0);\n}\n\nstatic int nfs4_proc_statfs(struct nfs_server *server, struct nfs_fh *fhandle, struct nfs_fsstat *fsstat)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs4_proc_statfs(server, fhandle, fsstat),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_do_fsinfo(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\tstruct nfs_fsinfo *fsinfo)\n{\n\tstruct nfs4_fsinfo_arg args = {\n\t\t.fh = fhandle,\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_FSINFO],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = fsinfo,\n\t};\n\n\treturn rpc_call_sync(server->client, &msg, 0);\n}\n\nstatic int nfs4_do_fsinfo(struct nfs_server *server, struct nfs_fh *fhandle, struct nfs_fsinfo *fsinfo)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs4_do_fsinfo(server, fhandle, fsinfo),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int nfs4_proc_fsinfo(struct nfs_server *server, struct nfs_fh *fhandle, struct nfs_fsinfo *fsinfo)\n{\n\tnfs_fattr_init(fsinfo->fattr);\n\treturn nfs4_do_fsinfo(server, fhandle, fsinfo);\n}\n\nstatic int _nfs4_proc_pathconf(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\tstruct nfs_pathconf *pathconf)\n{\n\tstruct nfs4_pathconf_arg args = {\n\t\t.fh = fhandle,\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_PATHCONF],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = pathconf,\n\t};\n\n\t/* None of the pathconf attributes are mandatory to implement */\n\tif ((args.bitmask[0] & nfs4_pathconf_bitmap[0]) == 0) {\n\t\tmemset(pathconf, 0, sizeof(*pathconf));\n\t\treturn 0;\n\t}\n\n\tnfs_fattr_init(pathconf->fattr);\n\treturn rpc_call_sync(server->client, &msg, 0);\n}\n\nstatic int nfs4_proc_pathconf(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\tstruct nfs_pathconf *pathconf)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs4_proc_pathconf(server, fhandle, pathconf),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int nfs4_read_done(struct rpc_task *task, struct nfs_read_data *data)\n{\n\tstruct nfs_server *server = NFS_SERVER(data->inode);\n\n\tif (nfs4_async_handle_error(task, server, data->args.context->state) == -EAGAIN) {\n\t\trpc_restart_call(task);\n\t\treturn -EAGAIN;\n\t}\n\n\tnfs_invalidate_atime(data->inode);\n\tif (task->tk_status > 0)\n\t\trenew_lease(server, data->timestamp);\n\treturn 0;\n}\n\nstatic void nfs4_proc_read_setup(struct nfs_read_data *data, struct rpc_message *msg)\n{\n\tdata->timestamp   = jiffies;\n\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_READ];\n}\n\nstatic int nfs4_write_done(struct rpc_task *task, struct nfs_write_data *data)\n{\n\tstruct inode *inode = data->inode;\n\t\n\tif (nfs4_async_handle_error(task, NFS_SERVER(inode), data->args.context->state) == -EAGAIN) {\n\t\trpc_restart_call(task);\n\t\treturn -EAGAIN;\n\t}\n\tif (task->tk_status >= 0) {\n\t\trenew_lease(NFS_SERVER(inode), data->timestamp);\n\t\tnfs_post_op_update_inode_force_wcc(inode, data->res.fattr);\n\t}\n\treturn 0;\n}\n\nstatic void nfs4_proc_write_setup(struct nfs_write_data *data, struct rpc_message *msg)\n{\n\tstruct nfs_server *server = NFS_SERVER(data->inode);\n\n\tdata->args.bitmask = server->attr_bitmask;\n\tdata->res.server = server;\n\tdata->timestamp   = jiffies;\n\n\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_WRITE];\n}\n\nstatic int nfs4_commit_done(struct rpc_task *task, struct nfs_write_data *data)\n{\n\tstruct inode *inode = data->inode;\n\t\n\tif (nfs4_async_handle_error(task, NFS_SERVER(inode), NULL) == -EAGAIN) {\n\t\trpc_restart_call(task);\n\t\treturn -EAGAIN;\n\t}\n\tnfs_refresh_inode(inode, data->res.fattr);\n\treturn 0;\n}\n\nstatic void nfs4_proc_commit_setup(struct nfs_write_data *data, struct rpc_message *msg)\n{\n\tstruct nfs_server *server = NFS_SERVER(data->inode);\n\t\n\tdata->args.bitmask = server->attr_bitmask;\n\tdata->res.server = server;\n\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_COMMIT];\n}\n\n/*\n * nfs4_proc_async_renew(): This is not one of the nfs_rpc_ops; it is a special\n * standalone procedure for queueing an asynchronous RENEW.\n */\nstatic void nfs4_renew_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs_client *clp = (struct nfs_client *)task->tk_msg.rpc_argp;\n\tunsigned long timestamp = (unsigned long)data;\n\n\tif (task->tk_status < 0) {\n\t\tswitch (task->tk_status) {\n\t\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tcase -NFS4ERR_CB_PATH_DOWN:\n\t\t\t\tnfs4_schedule_state_recovery(clp);\n\t\t}\n\t\treturn;\n\t}\n\tspin_lock(&clp->cl_lock);\n\tif (time_before(clp->cl_last_renewal,timestamp))\n\t\tclp->cl_last_renewal = timestamp;\n\tspin_unlock(&clp->cl_lock);\n}\n\nstatic const struct rpc_call_ops nfs4_renew_ops = {\n\t.rpc_call_done = nfs4_renew_done,\n};\n\nint nfs4_proc_async_renew(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_RENEW],\n\t\t.rpc_argp\t= clp,\n\t\t.rpc_cred\t= cred,\n\t};\n\n\treturn rpc_call_async(clp->cl_rpcclient, &msg, RPC_TASK_SOFT,\n\t\t\t&nfs4_renew_ops, (void *)jiffies);\n}\n\nint nfs4_proc_renew(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_RENEW],\n\t\t.rpc_argp\t= clp,\n\t\t.rpc_cred\t= cred,\n\t};\n\tunsigned long now = jiffies;\n\tint status;\n\n\tstatus = rpc_call_sync(clp->cl_rpcclient, &msg, 0);\n\tif (status < 0)\n\t\treturn status;\n\tspin_lock(&clp->cl_lock);\n\tif (time_before(clp->cl_last_renewal,now))\n\t\tclp->cl_last_renewal = now;\n\tspin_unlock(&clp->cl_lock);\n\treturn 0;\n}\n\nstatic inline int nfs4_server_supports_acls(struct nfs_server *server)\n{\n\treturn (server->caps & NFS_CAP_ACLS)\n\t\t&& (server->acl_bitmask & ACL4_SUPPORT_ALLOW_ACL)\n\t\t&& (server->acl_bitmask & ACL4_SUPPORT_DENY_ACL);\n}\n\n/* Assuming that XATTR_SIZE_MAX is a multiple of PAGE_CACHE_SIZE, and that\n * it's OK to put sizeof(void) * (XATTR_SIZE_MAX/PAGE_CACHE_SIZE) bytes on\n * the stack.\n */\n#define NFS4ACL_MAXPAGES (XATTR_SIZE_MAX >> PAGE_CACHE_SHIFT)\n\nstatic void buf_to_pages(const void *buf, size_t buflen,\n\t\tstruct page **pages, unsigned int *pgbase)\n{\n\tconst void *p = buf;\n\n\t*pgbase = offset_in_page(buf);\n\tp -= *pgbase;\n\twhile (p < buf + buflen) {\n\t\t*(pages++) = virt_to_page(p);\n\t\tp += PAGE_CACHE_SIZE;\n\t}\n}\n\nstruct nfs4_cached_acl {\n\tint cached;\n\tsize_t len;\n\tchar data[0];\n};\n\nstatic void nfs4_set_cached_acl(struct inode *inode, struct nfs4_cached_acl *acl)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tspin_lock(&inode->i_lock);\n\tkfree(nfsi->nfs4_acl);\n\tnfsi->nfs4_acl = acl;\n\tspin_unlock(&inode->i_lock);\n}\n\nstatic void nfs4_zap_acl_attr(struct inode *inode)\n{\n\tnfs4_set_cached_acl(inode, NULL);\n}\n\nstatic inline ssize_t nfs4_read_cached_acl(struct inode *inode, char *buf, size_t buflen)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs4_cached_acl *acl;\n\tint ret = -ENOENT;\n\n\tspin_lock(&inode->i_lock);\n\tacl = nfsi->nfs4_acl;\n\tif (acl == NULL)\n\t\tgoto out;\n\tif (buf == NULL) /* user is just asking for length */\n\t\tgoto out_len;\n\tif (acl->cached == 0)\n\t\tgoto out;\n\tret = -ERANGE; /* see getxattr(2) man page */\n\tif (acl->len > buflen)\n\t\tgoto out;\n\tmemcpy(buf, acl->data, acl->len);\nout_len:\n\tret = acl->len;\nout:\n\tspin_unlock(&inode->i_lock);\n\treturn ret;\n}\n\nstatic void nfs4_write_cached_acl(struct inode *inode, const char *buf, size_t acl_len)\n{\n\tstruct nfs4_cached_acl *acl;\n\n\tif (buf && acl_len <= PAGE_SIZE) {\n\t\tacl = kmalloc(sizeof(*acl) + acl_len, GFP_KERNEL);\n\t\tif (acl == NULL)\n\t\t\tgoto out;\n\t\tacl->cached = 1;\n\t\tmemcpy(acl->data, buf, acl_len);\n\t} else {\n\t\tacl = kmalloc(sizeof(*acl), GFP_KERNEL);\n\t\tif (acl == NULL)\n\t\t\tgoto out;\n\t\tacl->cached = 0;\n\t}\n\tacl->len = acl_len;\nout:\n\tnfs4_set_cached_acl(inode, acl);\n}\n\nstatic ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES];\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tsize_t resp_len = buflen;\n\tvoid *resp_buf;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &resp_len,\n\t};\n\tstruct page *localpage = NULL;\n\tint ret;\n\n\tif (buflen < PAGE_SIZE) {\n\t\t/* As long as we're doing a round trip to the server anyway,\n\t\t * let's be prepared for a page of acl data. */\n\t\tlocalpage = alloc_page(GFP_KERNEL);\n\t\tresp_buf = page_address(localpage);\n\t\tif (localpage == NULL)\n\t\t\treturn -ENOMEM;\n\t\targs.acl_pages[0] = localpage;\n\t\targs.acl_pgbase = 0;\n\t\tresp_len = args.acl_len = PAGE_SIZE;\n\t} else {\n\t\tresp_buf = buf;\n\t\tbuf_to_pages(buf, buflen, args.acl_pages, &args.acl_pgbase);\n\t}\n\tret = rpc_call_sync(NFS_CLIENT(inode), &msg, 0);\n\tif (ret)\n\t\tgoto out_free;\n\tif (resp_len > args.acl_len)\n\t\tnfs4_write_cached_acl(inode, NULL, resp_len);\n\telse\n\t\tnfs4_write_cached_acl(inode, resp_buf, resp_len);\n\tif (buf) {\n\t\tret = -ERANGE;\n\t\tif (resp_len > buflen)\n\t\t\tgoto out_free;\n\t\tif (localpage)\n\t\t\tmemcpy(buf, resp_buf, resp_len);\n\t}\n\tret = resp_len;\nout_free:\n\tif (localpage)\n\t\t__free_page(localpage);\n\treturn ret;\n}\n\nstatic ssize_t nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct nfs4_exception exception = { };\n\tssize_t ret;\n\tdo {\n\t\tret = __nfs4_get_acl_uncached(inode, buf, buflen);\n\t\tif (ret >= 0)\n\t\t\tbreak;\n\t\tret = nfs4_handle_exception(NFS_SERVER(inode), ret, &exception);\n\t} while (exception.retry);\n\treturn ret;\n}\n\nstatic ssize_t nfs4_proc_get_acl(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tint ret;\n\n\tif (!nfs4_server_supports_acls(server))\n\t\treturn -EOPNOTSUPP;\n\tret = nfs_revalidate_inode(server, inode);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (NFS_I(inode)->cache_validity & NFS_INO_INVALID_ACL)\n\t\tnfs_zap_acl_cache(inode);\n\tret = nfs4_read_cached_acl(inode, buf, buflen);\n\tif (ret != -ENOENT)\n\t\treturn ret;\n\treturn nfs4_get_acl_uncached(inode, buf, buflen);\n}\n\nstatic int __nfs4_proc_set_acl(struct inode *inode, const void *buf, size_t buflen)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct page *pages[NFS4ACL_MAXPAGES];\n\tstruct nfs_setaclargs arg = {\n\t\t.fh\t\t= NFS_FH(inode),\n\t\t.acl_pages\t= pages,\n\t\t.acl_len\t= buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_SETACL],\n\t\t.rpc_argp\t= &arg,\n\t\t.rpc_resp\t= NULL,\n\t};\n\tint ret;\n\n\tif (!nfs4_server_supports_acls(server))\n\t\treturn -EOPNOTSUPP;\n\tnfs_inode_return_delegation(inode);\n\tbuf_to_pages(buf, buflen, arg.acl_pages, &arg.acl_pgbase);\n\tret = rpc_call_sync(NFS_CLIENT(inode), &msg, 0);\n\tnfs_access_zap_cache(inode);\n\tnfs_zap_acl_cache(inode);\n\treturn ret;\n}\n\nstatic int nfs4_proc_set_acl(struct inode *inode, const void *buf, size_t buflen)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(inode),\n\t\t\t\t__nfs4_proc_set_acl(inode, buf, buflen),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int\nnfs4_async_handle_error(struct rpc_task *task, const struct nfs_server *server, struct nfs4_state *state)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\n\tif (!clp || task->tk_status >= 0)\n\t\treturn 0;\n\tswitch(task->tk_status) {\n\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_OPENMODE:\n\t\t\tif (state == NULL)\n\t\t\t\tbreak;\n\t\t\tnfs4_state_mark_reclaim_nograce(clp, state);\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\trpc_sleep_on(&clp->cl_rpcwaitq, task, NULL);\n\t\t\tnfs4_schedule_state_recovery(clp);\n\t\t\tif (test_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) == 0)\n\t\t\t\trpc_wake_up_queued_task(&clp->cl_rpcwaitq, task);\n\t\t\ttask->tk_status = 0;\n\t\t\treturn -EAGAIN;\n\t\tcase -NFS4ERR_DELAY:\n\t\t\tnfs_inc_server_stats(server, NFSIOS_DELAY);\n\t\tcase -NFS4ERR_GRACE:\n\t\t\trpc_delay(task, NFS4_POLL_RETRY_MAX);\n\t\t\ttask->tk_status = 0;\n\t\t\treturn -EAGAIN;\n\t\tcase -NFS4ERR_OLD_STATEID:\n\t\t\ttask->tk_status = 0;\n\t\t\treturn -EAGAIN;\n\t}\n\ttask->tk_status = nfs4_map_errors(task->tk_status);\n\treturn 0;\n}\n\nint nfs4_proc_setclientid(struct nfs_client *clp, u32 program, unsigned short port, struct rpc_cred *cred)\n{\n\tnfs4_verifier sc_verifier;\n\tstruct nfs4_setclientid setclientid = {\n\t\t.sc_verifier = &sc_verifier,\n\t\t.sc_prog = program,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SETCLIENTID],\n\t\t.rpc_argp = &setclientid,\n\t\t.rpc_resp = clp,\n\t\t.rpc_cred = cred,\n\t};\n\t__be32 *p;\n\tint loop = 0;\n\tint status;\n\n\tp = (__be32*)sc_verifier.data;\n\t*p++ = htonl((u32)clp->cl_boot_time.tv_sec);\n\t*p = htonl((u32)clp->cl_boot_time.tv_nsec);\n\n\tfor(;;) {\n\t\tsetclientid.sc_name_len = scnprintf(setclientid.sc_name,\n\t\t\t\tsizeof(setclientid.sc_name), \"%s/%s %s %s %u\",\n\t\t\t\tclp->cl_ipaddr,\n\t\t\t\trpc_peeraddr2str(clp->cl_rpcclient,\n\t\t\t\t\t\t\tRPC_DISPLAY_ADDR),\n\t\t\t\trpc_peeraddr2str(clp->cl_rpcclient,\n\t\t\t\t\t\t\tRPC_DISPLAY_PROTO),\n\t\t\t\tclp->cl_rpcclient->cl_auth->au_ops->au_name,\n\t\t\t\tclp->cl_id_uniquifier);\n\t\tsetclientid.sc_netid_len = scnprintf(setclientid.sc_netid,\n\t\t\t\tsizeof(setclientid.sc_netid),\n\t\t\t\trpc_peeraddr2str(clp->cl_rpcclient,\n\t\t\t\t\t\t\tRPC_DISPLAY_NETID));\n\t\tsetclientid.sc_uaddr_len = scnprintf(setclientid.sc_uaddr,\n\t\t\t\tsizeof(setclientid.sc_uaddr), \"%s.%u.%u\",\n\t\t\t\tclp->cl_ipaddr, port >> 8, port & 255);\n\n\t\tstatus = rpc_call_sync(clp->cl_rpcclient, &msg, 0);\n\t\tif (status != -NFS4ERR_CLID_INUSE)\n\t\t\tbreak;\n\t\tif (signalled())\n\t\t\tbreak;\n\t\tif (loop++ & 1)\n\t\t\tssleep(clp->cl_lease_time + 1);\n\t\telse\n\t\t\tif (++clp->cl_id_uniquifier == 0)\n\t\t\t\tbreak;\n\t}\n\treturn status;\n}\n\nstatic int _nfs4_proc_setclientid_confirm(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tstruct nfs_fsinfo fsinfo;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SETCLIENTID_CONFIRM],\n\t\t.rpc_argp = clp,\n\t\t.rpc_resp = &fsinfo,\n\t\t.rpc_cred = cred,\n\t};\n\tunsigned long now;\n\tint status;\n\n\tnow = jiffies;\n\tstatus = rpc_call_sync(clp->cl_rpcclient, &msg, 0);\n\tif (status == 0) {\n\t\tspin_lock(&clp->cl_lock);\n\t\tclp->cl_lease_time = fsinfo.lease_time * HZ;\n\t\tclp->cl_last_renewal = now;\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n\treturn status;\n}\n\nint nfs4_proc_setclientid_confirm(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tlong timeout = 0;\n\tint err;\n\tdo {\n\t\terr = _nfs4_proc_setclientid_confirm(clp, cred);\n\t\tswitch (err) {\n\t\t\tcase 0:\n\t\t\t\treturn err;\n\t\t\tcase -NFS4ERR_RESOURCE:\n\t\t\t\t/* The IBM lawyers misread another document! */\n\t\t\tcase -NFS4ERR_DELAY:\n\t\t\t\terr = nfs4_delay(clp->cl_rpcclient, &timeout);\n\t\t}\n\t} while (err == 0);\n\treturn err;\n}\n\nstruct nfs4_delegreturndata {\n\tstruct nfs4_delegreturnargs args;\n\tstruct nfs4_delegreturnres res;\n\tstruct nfs_fh fh;\n\tnfs4_stateid stateid;\n\tunsigned long timestamp;\n\tstruct nfs_fattr fattr;\n\tint rpc_status;\n};\n\nstatic void nfs4_delegreturn_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_delegreturndata *data = calldata;\n\tdata->rpc_status = task->tk_status;\n\tif (data->rpc_status == 0)\n\t\trenew_lease(data->res.server, data->timestamp);\n}\n\nstatic void nfs4_delegreturn_release(void *calldata)\n{\n\tkfree(calldata);\n}\n\nstatic const struct rpc_call_ops nfs4_delegreturn_ops = {\n\t.rpc_call_done = nfs4_delegreturn_done,\n\t.rpc_release = nfs4_delegreturn_release,\n};\n\nstatic int _nfs4_proc_delegreturn(struct inode *inode, struct rpc_cred *cred, const nfs4_stateid *stateid, int issync)\n{\n\tstruct nfs4_delegreturndata *data;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_DELEGRETURN],\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_delegreturn_ops,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tint status = 0;\n\n\tdata = kmalloc(sizeof(*data), GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\tdata->args.fhandle = &data->fh;\n\tdata->args.stateid = &data->stateid;\n\tdata->args.bitmask = server->attr_bitmask;\n\tnfs_copy_fh(&data->fh, NFS_FH(inode));\n\tmemcpy(&data->stateid, stateid, sizeof(data->stateid));\n\tdata->res.fattr = &data->fattr;\n\tdata->res.server = server;\n\tnfs_fattr_init(data->res.fattr);\n\tdata->timestamp = jiffies;\n\tdata->rpc_status = 0;\n\n\ttask_setup_data.callback_data = data;\n\tmsg.rpc_argp = &data->args,\n\tmsg.rpc_resp = &data->res,\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tif (!issync)\n\t\tgoto out;\n\tstatus = nfs4_wait_for_completion_rpc_task(task);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = data->rpc_status;\n\tif (status != 0)\n\t\tgoto out;\n\tnfs_refresh_inode(inode, &data->fattr);\nout:\n\trpc_put_task(task);\n\treturn status;\n}\n\nint nfs4_proc_delegreturn(struct inode *inode, struct rpc_cred *cred, const nfs4_stateid *stateid, int issync)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = _nfs4_proc_delegreturn(inode, cred, stateid, issync);\n\t\tswitch (err) {\n\t\t\tcase -NFS4ERR_STALE_STATEID:\n\t\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tcase 0:\n\t\t\t\treturn 0;\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n#define NFS4_LOCK_MINTIMEOUT (1 * HZ)\n#define NFS4_LOCK_MAXTIMEOUT (30 * HZ)\n\n/* \n * sleep, with exponential backoff, and retry the LOCK operation. \n */\nstatic unsigned long\nnfs4_set_lock_task_retry(unsigned long timeout)\n{\n\tschedule_timeout_killable(timeout);\n\ttimeout <<= 1;\n\tif (timeout > NFS4_LOCK_MAXTIMEOUT)\n\t\treturn NFS4_LOCK_MAXTIMEOUT;\n\treturn timeout;\n}\n\nstatic int _nfs4_proc_getlk(struct nfs4_state *state, int cmd, struct file_lock *request)\n{\n\tstruct inode *inode = state->inode;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs_lockt_args arg = {\n\t\t.fh = NFS_FH(inode),\n\t\t.fl = request,\n\t};\n\tstruct nfs_lockt_res res = {\n\t\t.denied = request,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_LOCKT],\n\t\t.rpc_argp       = &arg,\n\t\t.rpc_resp       = &res,\n\t\t.rpc_cred\t= state->owner->so_cred,\n\t};\n\tstruct nfs4_lock_state *lsp;\n\tint status;\n\n\targ.lock_owner.clientid = clp->cl_clientid;\n\tstatus = nfs4_set_lock_state(state, request);\n\tif (status != 0)\n\t\tgoto out;\n\tlsp = request->fl_u.nfs4_fl.owner;\n\targ.lock_owner.id = lsp->ls_id.id;\n\tstatus = rpc_call_sync(server->client, &msg, 0);\n\tswitch (status) {\n\t\tcase 0:\n\t\t\trequest->fl_type = F_UNLCK;\n\t\t\tbreak;\n\t\tcase -NFS4ERR_DENIED:\n\t\t\tstatus = 0;\n\t}\n\trequest->fl_ops->fl_release_private(request);\nout:\n\treturn status;\n}\n\nstatic int nfs4_proc_getlk(struct nfs4_state *state, int cmd, struct file_lock *request)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(state->inode),\n\t\t\t\t_nfs4_proc_getlk(state, cmd, request),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int do_vfs_lock(struct file *file, struct file_lock *fl)\n{\n\tint res = 0;\n\tswitch (fl->fl_flags & (FL_POSIX|FL_FLOCK)) {\n\t\tcase FL_POSIX:\n\t\t\tres = posix_lock_file_wait(file, fl);\n\t\t\tbreak;\n\t\tcase FL_FLOCK:\n\t\t\tres = flock_lock_file_wait(file, fl);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\treturn res;\n}\n\nstruct nfs4_unlockdata {\n\tstruct nfs_locku_args arg;\n\tstruct nfs_locku_res res;\n\tstruct nfs4_lock_state *lsp;\n\tstruct nfs_open_context *ctx;\n\tstruct file_lock fl;\n\tconst struct nfs_server *server;\n\tunsigned long timestamp;\n};\n\nstatic struct nfs4_unlockdata *nfs4_alloc_unlockdata(struct file_lock *fl,\n\t\tstruct nfs_open_context *ctx,\n\t\tstruct nfs4_lock_state *lsp,\n\t\tstruct nfs_seqid *seqid)\n{\n\tstruct nfs4_unlockdata *p;\n\tstruct inode *inode = lsp->ls_state->inode;\n\n\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\tif (p == NULL)\n\t\treturn NULL;\n\tp->arg.fh = NFS_FH(inode);\n\tp->arg.fl = &p->fl;\n\tp->arg.seqid = seqid;\n\tp->res.seqid = seqid;\n\tp->arg.stateid = &lsp->ls_stateid;\n\tp->lsp = lsp;\n\tatomic_inc(&lsp->ls_count);\n\t/* Ensure we don't close file until we're done freeing locks! */\n\tp->ctx = get_nfs_open_context(ctx);\n\tmemcpy(&p->fl, fl, sizeof(p->fl));\n\tp->server = NFS_SERVER(inode);\n\treturn p;\n}\n\nstatic void nfs4_locku_release_calldata(void *data)\n{\n\tstruct nfs4_unlockdata *calldata = data;\n\tnfs_free_seqid(calldata->arg.seqid);\n\tnfs4_put_lock_state(calldata->lsp);\n\tput_nfs_open_context(calldata->ctx);\n\tkfree(calldata);\n}\n\nstatic void nfs4_locku_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_unlockdata *calldata = data;\n\n\tif (RPC_ASSASSINATED(task))\n\t\treturn;\n\tswitch (task->tk_status) {\n\t\tcase 0:\n\t\t\tmemcpy(calldata->lsp->ls_stateid.data,\n\t\t\t\t\tcalldata->res.stateid.data,\n\t\t\t\t\tsizeof(calldata->lsp->ls_stateid.data));\n\t\t\trenew_lease(calldata->server, calldata->timestamp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_OLD_STATEID:\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (nfs4_async_handle_error(task, calldata->server, NULL) == -EAGAIN)\n\t\t\t\trpc_restart_call(task);\n\t}\n}\n\nstatic void nfs4_locku_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_unlockdata *calldata = data;\n\n\tif (nfs_wait_on_sequence(calldata->arg.seqid, task) != 0)\n\t\treturn;\n\tif ((calldata->lsp->ls_flags & NFS_LOCK_INITIALIZED) == 0) {\n\t\t/* Note: exit _without_ running nfs4_locku_done */\n\t\ttask->tk_action = NULL;\n\t\treturn;\n\t}\n\tcalldata->timestamp = jiffies;\n\trpc_call_start(task);\n}\n\nstatic const struct rpc_call_ops nfs4_locku_ops = {\n\t.rpc_call_prepare = nfs4_locku_prepare,\n\t.rpc_call_done = nfs4_locku_done,\n\t.rpc_release = nfs4_locku_release_calldata,\n};\n\nstatic struct rpc_task *nfs4_do_unlck(struct file_lock *fl,\n\t\tstruct nfs_open_context *ctx,\n\t\tstruct nfs4_lock_state *lsp,\n\t\tstruct nfs_seqid *seqid)\n{\n\tstruct nfs4_unlockdata *data;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LOCKU],\n\t\t.rpc_cred = ctx->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = NFS_CLIENT(lsp->ls_state->inode),\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_locku_ops,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\n\t/* Ensure this is an unlock - when canceling a lock, the\n\t * canceled lock is passed in, and it won't be an unlock.\n\t */\n\tfl->fl_type = F_UNLCK;\n\n\tdata = nfs4_alloc_unlockdata(fl, ctx, lsp, seqid);\n\tif (data == NULL) {\n\t\tnfs_free_seqid(seqid);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tmsg.rpc_argp = &data->arg,\n\tmsg.rpc_resp = &data->res,\n\ttask_setup_data.callback_data = data;\n\treturn rpc_run_task(&task_setup_data);\n}\n\nstatic int nfs4_proc_unlck(struct nfs4_state *state, int cmd, struct file_lock *request)\n{\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_seqid *seqid;\n\tstruct nfs4_lock_state *lsp;\n\tstruct rpc_task *task;\n\tint status = 0;\n\tunsigned char fl_flags = request->fl_flags;\n\n\tstatus = nfs4_set_lock_state(state, request);\n\t/* Unlock _before_ we do the RPC call */\n\trequest->fl_flags |= FL_EXISTS;\n\tdown_read(&nfsi->rwsem);\n\tif (do_vfs_lock(request->fl_file, request) == -ENOENT) {\n\t\tup_read(&nfsi->rwsem);\n\t\tgoto out;\n\t}\n\tup_read(&nfsi->rwsem);\n\tif (status != 0)\n\t\tgoto out;\n\t/* Is this a delegated lock? */\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags))\n\t\tgoto out;\n\tlsp = request->fl_u.nfs4_fl.owner;\n\tseqid = nfs_alloc_seqid(&lsp->ls_seqid);\n\tstatus = -ENOMEM;\n\tif (seqid == NULL)\n\t\tgoto out;\n\ttask = nfs4_do_unlck(request, nfs_file_open_context(request->fl_file), lsp, seqid);\n\tstatus = PTR_ERR(task);\n\tif (IS_ERR(task))\n\t\tgoto out;\n\tstatus = nfs4_wait_for_completion_rpc_task(task);\n\trpc_put_task(task);\nout:\n\trequest->fl_flags = fl_flags;\n\treturn status;\n}\n\nstruct nfs4_lockdata {\n\tstruct nfs_lock_args arg;\n\tstruct nfs_lock_res res;\n\tstruct nfs4_lock_state *lsp;\n\tstruct nfs_open_context *ctx;\n\tstruct file_lock fl;\n\tunsigned long timestamp;\n\tint rpc_status;\n\tint cancelled;\n};\n\nstatic struct nfs4_lockdata *nfs4_alloc_lockdata(struct file_lock *fl,\n\t\tstruct nfs_open_context *ctx, struct nfs4_lock_state *lsp)\n{\n\tstruct nfs4_lockdata *p;\n\tstruct inode *inode = lsp->ls_state->inode;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (p == NULL)\n\t\treturn NULL;\n\n\tp->arg.fh = NFS_FH(inode);\n\tp->arg.fl = &p->fl;\n\tp->arg.open_seqid = nfs_alloc_seqid(&lsp->ls_state->owner->so_seqid);\n\tif (p->arg.open_seqid == NULL)\n\t\tgoto out_free;\n\tp->arg.lock_seqid = nfs_alloc_seqid(&lsp->ls_seqid);\n\tif (p->arg.lock_seqid == NULL)\n\t\tgoto out_free_seqid;\n\tp->arg.lock_stateid = &lsp->ls_stateid;\n\tp->arg.lock_owner.clientid = server->nfs_client->cl_clientid;\n\tp->arg.lock_owner.id = lsp->ls_id.id;\n\tp->res.lock_seqid = p->arg.lock_seqid;\n\tp->lsp = lsp;\n\tatomic_inc(&lsp->ls_count);\n\tp->ctx = get_nfs_open_context(ctx);\n\tmemcpy(&p->fl, fl, sizeof(p->fl));\n\treturn p;\nout_free_seqid:\n\tnfs_free_seqid(p->arg.open_seqid);\nout_free:\n\tkfree(p);\n\treturn NULL;\n}\n\nstatic void nfs4_lock_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_lockdata *data = calldata;\n\tstruct nfs4_state *state = data->lsp->ls_state;\n\n\tdprintk(\"%s: begin!\\n\", __func__);\n\tif (nfs_wait_on_sequence(data->arg.lock_seqid, task) != 0)\n\t\treturn;\n\t/* Do we need to do an open_to_lock_owner? */\n\tif (!(data->arg.lock_seqid->sequence->flags & NFS_SEQID_CONFIRMED)) {\n\t\tif (nfs_wait_on_sequence(data->arg.open_seqid, task) != 0)\n\t\t\treturn;\n\t\tdata->arg.open_stateid = &state->stateid;\n\t\tdata->arg.new_lock_owner = 1;\n\t\tdata->res.open_seqid = data->arg.open_seqid;\n\t} else\n\t\tdata->arg.new_lock_owner = 0;\n\tdata->timestamp = jiffies;\n\trpc_call_start(task);\n\tdprintk(\"%s: done!, ret = %d\\n\", __func__, data->rpc_status);\n}\n\nstatic void nfs4_lock_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_lockdata *data = calldata;\n\n\tdprintk(\"%s: begin!\\n\", __func__);\n\n\tdata->rpc_status = task->tk_status;\n\tif (RPC_ASSASSINATED(task))\n\t\tgoto out;\n\tif (data->arg.new_lock_owner != 0) {\n\t\tif (data->rpc_status == 0)\n\t\t\tnfs_confirm_seqid(&data->lsp->ls_seqid, 0);\n\t\telse\n\t\t\tgoto out;\n\t}\n\tif (data->rpc_status == 0) {\n\t\tmemcpy(data->lsp->ls_stateid.data, data->res.stateid.data,\n\t\t\t\t\tsizeof(data->lsp->ls_stateid.data));\n\t\tdata->lsp->ls_flags |= NFS_LOCK_INITIALIZED;\n\t\trenew_lease(NFS_SERVER(data->ctx->path.dentry->d_inode), data->timestamp);\n\t}\nout:\n\tdprintk(\"%s: done, ret = %d!\\n\", __func__, data->rpc_status);\n}\n\nstatic void nfs4_lock_release(void *calldata)\n{\n\tstruct nfs4_lockdata *data = calldata;\n\n\tdprintk(\"%s: begin!\\n\", __func__);\n\tnfs_free_seqid(data->arg.open_seqid);\n\tif (data->cancelled != 0) {\n\t\tstruct rpc_task *task;\n\t\ttask = nfs4_do_unlck(&data->fl, data->ctx, data->lsp,\n\t\t\t\tdata->arg.lock_seqid);\n\t\tif (!IS_ERR(task))\n\t\t\trpc_put_task(task);\n\t\tdprintk(\"%s: cancelling lock!\\n\", __func__);\n\t} else\n\t\tnfs_free_seqid(data->arg.lock_seqid);\n\tnfs4_put_lock_state(data->lsp);\n\tput_nfs_open_context(data->ctx);\n\tkfree(data);\n\tdprintk(\"%s: done!\\n\", __func__);\n}\n\nstatic const struct rpc_call_ops nfs4_lock_ops = {\n\t.rpc_call_prepare = nfs4_lock_prepare,\n\t.rpc_call_done = nfs4_lock_done,\n\t.rpc_release = nfs4_lock_release,\n};\n\nstatic int _nfs4_do_setlk(struct nfs4_state *state, int cmd, struct file_lock *fl, int reclaim)\n{\n\tstruct nfs4_lockdata *data;\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LOCK],\n\t\t.rpc_cred = state->owner->so_cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = NFS_CLIENT(state->inode),\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_lock_ops,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tint ret;\n\n\tdprintk(\"%s: begin!\\n\", __func__);\n\tdata = nfs4_alloc_lockdata(fl, nfs_file_open_context(fl->fl_file),\n\t\t\tfl->fl_u.nfs4_fl.owner);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\tif (IS_SETLKW(cmd))\n\t\tdata->arg.block = 1;\n\tif (reclaim != 0)\n\t\tdata->arg.reclaim = 1;\n\tmsg.rpc_argp = &data->arg,\n\tmsg.rpc_resp = &data->res,\n\ttask_setup_data.callback_data = data;\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tret = nfs4_wait_for_completion_rpc_task(task);\n\tif (ret == 0) {\n\t\tret = data->rpc_status;\n\t\tif (ret == -NFS4ERR_DENIED)\n\t\t\tret = -EAGAIN;\n\t} else\n\t\tdata->cancelled = 1;\n\trpc_put_task(task);\n\tdprintk(\"%s: done, ret = %d!\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int nfs4_lock_reclaim(struct nfs4_state *state, struct file_lock *request)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\t/* Cache the lock if possible... */\n\t\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) != 0)\n\t\t\treturn 0;\n\t\terr = _nfs4_do_setlk(state, F_SETLK, request, 1);\n\t\tif (err != -NFS4ERR_DELAY)\n\t\t\tbreak;\n\t\tnfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int nfs4_lock_expired(struct nfs4_state *state, struct file_lock *request)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\terr = nfs4_set_lock_state(state, request);\n\tif (err != 0)\n\t\treturn err;\n\tdo {\n\t\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) != 0)\n\t\t\treturn 0;\n\t\terr = _nfs4_do_setlk(state, F_SETLK, request, 0);\n\t\tif (err != -NFS4ERR_DELAY)\n\t\t\tbreak;\n\t\tnfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_proc_setlk(struct nfs4_state *state, int cmd, struct file_lock *request)\n{\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tunsigned char fl_flags = request->fl_flags;\n\tint status;\n\n\t/* Is this a delegated open? */\n\tstatus = nfs4_set_lock_state(state, request);\n\tif (status != 0)\n\t\tgoto out;\n\trequest->fl_flags |= FL_ACCESS;\n\tstatus = do_vfs_lock(request->fl_file, request);\n\tif (status < 0)\n\t\tgoto out;\n\tdown_read(&nfsi->rwsem);\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags)) {\n\t\t/* Yes: cache locks! */\n\t\t/* ...but avoid races with delegation recall... */\n\t\trequest->fl_flags = fl_flags & ~FL_SLEEP;\n\t\tstatus = do_vfs_lock(request->fl_file, request);\n\t\tgoto out_unlock;\n\t}\n\tstatus = _nfs4_do_setlk(state, cmd, request, 0);\n\tif (status != 0)\n\t\tgoto out_unlock;\n\t/* Note: we always want to sleep here! */\n\trequest->fl_flags = fl_flags | FL_SLEEP;\n\tif (do_vfs_lock(request->fl_file, request) < 0)\n\t\tprintk(KERN_WARNING \"%s: VFS is out of sync with lock manager!\\n\", __func__);\nout_unlock:\n\tup_read(&nfsi->rwsem);\nout:\n\trequest->fl_flags = fl_flags;\n\treturn status;\n}\n\nstatic int nfs4_proc_setlk(struct nfs4_state *state, int cmd, struct file_lock *request)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(state->inode),\n\t\t\t\t_nfs4_proc_setlk(state, cmd, request),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int\nnfs4_proc_lock(struct file *filp, int cmd, struct file_lock *request)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct nfs4_state *state;\n\tunsigned long timeout = NFS4_LOCK_MINTIMEOUT;\n\tint status;\n\n\t/* verify open state */\n\tctx = nfs_file_open_context(filp);\n\tstate = ctx->state;\n\n\tif (request->fl_start < 0 || request->fl_end < 0)\n\t\treturn -EINVAL;\n\n\tif (IS_GETLK(cmd))\n\t\treturn nfs4_proc_getlk(state, F_GETLK, request);\n\n\tif (!(IS_SETLK(cmd) || IS_SETLKW(cmd)))\n\t\treturn -EINVAL;\n\n\tif (request->fl_type == F_UNLCK)\n\t\treturn nfs4_proc_unlck(state, cmd, request);\n\n\tdo {\n\t\tstatus = nfs4_proc_setlk(state, cmd, request);\n\t\tif ((status != -EAGAIN) || IS_SETLK(cmd))\n\t\t\tbreak;\n\t\ttimeout = nfs4_set_lock_task_retry(timeout);\n\t\tstatus = -ERESTARTSYS;\n\t\tif (signalled())\n\t\t\tbreak;\n\t} while(status < 0);\n\treturn status;\n}\n\nint nfs4_lock_delegation_recall(struct nfs4_state *state, struct file_lock *fl)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\terr = nfs4_set_lock_state(state, fl);\n\tif (err != 0)\n\t\tgoto out;\n\tdo {\n\t\terr = _nfs4_do_setlk(state, F_SETLK, fl, 0);\n\t\tif (err != -NFS4ERR_DELAY)\n\t\t\tbreak;\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\nout:\n\treturn err;\n}\n\n#define XATTR_NAME_NFSV4_ACL \"system.nfs4_acl\"\n\nint nfs4_setxattr(struct dentry *dentry, const char *key, const void *buf,\n\t\tsize_t buflen, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\tif (strcmp(key, XATTR_NAME_NFSV4_ACL) != 0)\n\t\treturn -EOPNOTSUPP;\n\n\treturn nfs4_proc_set_acl(inode, buf, buflen);\n}\n\n/* The getxattr man page suggests returning -ENODATA for unknown attributes,\n * and that's what we'll do for e.g. user attributes that haven't been set.\n * But we'll follow ext2/ext3's lead by returning -EOPNOTSUPP for unsupported\n * attributes in kernel-managed attribute namespaces. */\nssize_t nfs4_getxattr(struct dentry *dentry, const char *key, void *buf,\n\t\tsize_t buflen)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\tif (strcmp(key, XATTR_NAME_NFSV4_ACL) != 0)\n\t\treturn -EOPNOTSUPP;\n\n\treturn nfs4_proc_get_acl(inode, buf, buflen);\n}\n\nssize_t nfs4_listxattr(struct dentry *dentry, char *buf, size_t buflen)\n{\n\tsize_t len = strlen(XATTR_NAME_NFSV4_ACL) + 1;\n\n\tif (!nfs4_server_supports_acls(NFS_SERVER(dentry->d_inode)))\n\t\treturn 0;\n\tif (buf && buflen < len)\n\t\treturn -ERANGE;\n\tif (buf)\n\t\tmemcpy(buf, XATTR_NAME_NFSV4_ACL, len);\n\treturn len;\n}\n\nint nfs4_proc_fs_locations(struct inode *dir, const struct qstr *name,\n\t\tstruct nfs4_fs_locations *fs_locations, struct page *page)\n{\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tu32 bitmask[2] = {\n\t\t[0] = FATTR4_WORD0_FSID | FATTR4_WORD0_FS_LOCATIONS,\n\t\t[1] = FATTR4_WORD1_MOUNTED_ON_FILEID,\n\t};\n\tstruct nfs4_fs_locations_arg args = {\n\t\t.dir_fh = NFS_FH(dir),\n\t\t.name = name,\n\t\t.page = page,\n\t\t.bitmask = bitmask,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_FS_LOCATIONS],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = fs_locations,\n\t};\n\tint status;\n\n\tdprintk(\"%s: start\\n\", __func__);\n\tnfs_fattr_init(&fs_locations->fattr);\n\tfs_locations->server = server;\n\tfs_locations->nlocations = 0;\n\tstatus = rpc_call_sync(server->client, &msg, 0);\n\tdprintk(\"%s: returned status = %d\\n\", __func__, status);\n\treturn status;\n}\n\nstruct nfs4_state_recovery_ops nfs4_reboot_recovery_ops = {\n\t.owner_flag_bit = NFS_OWNER_RECLAIM_REBOOT,\n\t.state_flag_bit\t= NFS_STATE_RECLAIM_REBOOT,\n\t.recover_open\t= nfs4_open_reclaim,\n\t.recover_lock\t= nfs4_lock_reclaim,\n};\n\nstruct nfs4_state_recovery_ops nfs4_nograce_recovery_ops = {\n\t.owner_flag_bit = NFS_OWNER_RECLAIM_NOGRACE,\n\t.state_flag_bit\t= NFS_STATE_RECLAIM_NOGRACE,\n\t.recover_open\t= nfs4_open_expired,\n\t.recover_lock\t= nfs4_lock_expired,\n};\n\nstatic const struct inode_operations nfs4_file_inode_operations = {\n\t.permission\t= nfs_permission,\n\t.getattr\t= nfs_getattr,\n\t.setattr\t= nfs_setattr,\n\t.getxattr\t= nfs4_getxattr,\n\t.setxattr\t= nfs4_setxattr,\n\t.listxattr\t= nfs4_listxattr,\n};\n\nconst struct nfs_rpc_ops nfs_v4_clientops = {\n\t.version\t= 4,\t\t\t/* protocol version */\n\t.dentry_ops\t= &nfs4_dentry_operations,\n\t.dir_inode_ops\t= &nfs4_dir_inode_operations,\n\t.file_inode_ops\t= &nfs4_file_inode_operations,\n\t.getroot\t= nfs4_proc_get_root,\n\t.getattr\t= nfs4_proc_getattr,\n\t.setattr\t= nfs4_proc_setattr,\n\t.lookupfh\t= nfs4_proc_lookupfh,\n\t.lookup\t\t= nfs4_proc_lookup,\n\t.access\t\t= nfs4_proc_access,\n\t.readlink\t= nfs4_proc_readlink,\n\t.create\t\t= nfs4_proc_create,\n\t.remove\t\t= nfs4_proc_remove,\n\t.unlink_setup\t= nfs4_proc_unlink_setup,\n\t.unlink_done\t= nfs4_proc_unlink_done,\n\t.rename\t\t= nfs4_proc_rename,\n\t.link\t\t= nfs4_proc_link,\n\t.symlink\t= nfs4_proc_symlink,\n\t.mkdir\t\t= nfs4_proc_mkdir,\n\t.rmdir\t\t= nfs4_proc_remove,\n\t.readdir\t= nfs4_proc_readdir,\n\t.mknod\t\t= nfs4_proc_mknod,\n\t.statfs\t\t= nfs4_proc_statfs,\n\t.fsinfo\t\t= nfs4_proc_fsinfo,\n\t.pathconf\t= nfs4_proc_pathconf,\n\t.set_capabilities = nfs4_server_capabilities,\n\t.decode_dirent\t= nfs4_decode_dirent,\n\t.read_setup\t= nfs4_proc_read_setup,\n\t.read_done\t= nfs4_read_done,\n\t.write_setup\t= nfs4_proc_write_setup,\n\t.write_done\t= nfs4_write_done,\n\t.commit_setup\t= nfs4_proc_commit_setup,\n\t.commit_done\t= nfs4_commit_done,\n\t.lock\t\t= nfs4_proc_lock,\n\t.clear_acl_cache = nfs4_zap_acl_attr,\n};\n\n/*\n * Local variables:\n *  c-basic-offset: 8\n * End:\n */\n", "/*\n *  fs/nfs/nfs4state.c\n *\n *  Client-side XDR for NFSv4.\n *\n *  Copyright (c) 2002 The Regents of the University of Michigan.\n *  All rights reserved.\n *\n *  Kendrick Smith <kmsmith@umich.edu>\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions\n *  are met:\n *\n *  1. Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *  2. Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *  3. Neither the name of the University nor the names of its\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED\n *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n *  DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n *  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * Implementation of the NFSv4 state model.  For the time being,\n * this is minimal, but will be made much more complex in a\n * subsequent patch.\n */\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/smp_lock.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_idmap.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/bitops.h>\n\n#include \"nfs4_fs.h\"\n#include \"callback.h\"\n#include \"delegation.h\"\n#include \"internal.h\"\n\n#define OPENOWNER_POOL_SIZE\t8\n\nconst nfs4_stateid zero_stateid;\n\nstatic LIST_HEAD(nfs4_clientid_list);\n\nstatic int nfs4_init_client(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tint status = nfs4_proc_setclientid(clp, NFS4_CALLBACK,\n\t\t\tnfs_callback_tcpport, cred);\n\tif (status == 0)\n\t\tstatus = nfs4_proc_setclientid_confirm(clp, cred);\n\tif (status == 0)\n\t\tnfs4_schedule_state_renewal(clp);\n\treturn status;\n}\n\nstatic struct rpc_cred *nfs4_get_machine_cred_locked(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred = NULL;\n\n\tif (clp->cl_machine_cred != NULL)\n\t\tcred = get_rpccred(clp->cl_machine_cred);\n\treturn cred;\n}\n\nstatic void nfs4_clear_machine_cred(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\n\tspin_lock(&clp->cl_lock);\n\tcred = clp->cl_machine_cred;\n\tclp->cl_machine_cred = NULL;\n\tspin_unlock(&clp->cl_lock);\n\tif (cred != NULL)\n\t\tput_rpccred(cred);\n}\n\nstruct rpc_cred *nfs4_get_renew_cred_locked(struct nfs_client *clp)\n{\n\tstruct nfs4_state_owner *sp;\n\tstruct rb_node *pos;\n\tstruct rpc_cred *cred = NULL;\n\n\tfor (pos = rb_first(&clp->cl_state_owners); pos != NULL; pos = rb_next(pos)) {\n\t\tsp = rb_entry(pos, struct nfs4_state_owner, so_client_node);\n\t\tif (list_empty(&sp->so_states))\n\t\t\tcontinue;\n\t\tcred = get_rpccred(sp->so_cred);\n\t\tbreak;\n\t}\n\treturn cred;\n}\n\nstatic struct rpc_cred *nfs4_get_renew_cred(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\n\tspin_lock(&clp->cl_lock);\n\tcred = nfs4_get_renew_cred_locked(clp);\n\tspin_unlock(&clp->cl_lock);\n\treturn cred;\n}\n\nstatic struct rpc_cred *nfs4_get_setclientid_cred(struct nfs_client *clp)\n{\n\tstruct nfs4_state_owner *sp;\n\tstruct rb_node *pos;\n\tstruct rpc_cred *cred;\n\n\tspin_lock(&clp->cl_lock);\n\tcred = nfs4_get_machine_cred_locked(clp);\n\tif (cred != NULL)\n\t\tgoto out;\n\tpos = rb_first(&clp->cl_state_owners);\n\tif (pos != NULL) {\n\t\tsp = rb_entry(pos, struct nfs4_state_owner, so_client_node);\n\t\tcred = get_rpccred(sp->so_cred);\n\t}\nout:\n\tspin_unlock(&clp->cl_lock);\n\treturn cred;\n}\n\nstatic void nfs_alloc_unique_id(struct rb_root *root, struct nfs_unique_id *new,\n\t\t__u64 minval, int maxbits)\n{\n\tstruct rb_node **p, *parent;\n\tstruct nfs_unique_id *pos;\n\t__u64 mask = ~0ULL;\n\n\tif (maxbits < 64)\n\t\tmask = (1ULL << maxbits) - 1ULL;\n\n\t/* Ensure distribution is more or less flat */\n\tget_random_bytes(&new->id, sizeof(new->id));\n\tnew->id &= mask;\n\tif (new->id < minval)\n\t\tnew->id += minval;\nretry:\n\tp = &root->rb_node;\n\tparent = NULL;\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\tpos = rb_entry(parent, struct nfs_unique_id, rb_node);\n\n\t\tif (new->id < pos->id)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new->id > pos->id)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tgoto id_exists;\n\t}\n\trb_link_node(&new->rb_node, parent, p);\n\trb_insert_color(&new->rb_node, root);\n\treturn;\nid_exists:\n\tfor (;;) {\n\t\tnew->id++;\n\t\tif (new->id < minval || (new->id & mask) != new->id) {\n\t\t\tnew->id = minval;\n\t\t\tbreak;\n\t\t}\n\t\tparent = rb_next(parent);\n\t\tif (parent == NULL)\n\t\t\tbreak;\n\t\tpos = rb_entry(parent, struct nfs_unique_id, rb_node);\n\t\tif (new->id < pos->id)\n\t\t\tbreak;\n\t}\n\tgoto retry;\n}\n\nstatic void nfs_free_unique_id(struct rb_root *root, struct nfs_unique_id *id)\n{\n\trb_erase(&id->rb_node, root);\n}\n\nstatic struct nfs4_state_owner *\nnfs4_find_state_owner(struct nfs_server *server, struct rpc_cred *cred)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct rb_node **p = &clp->cl_state_owners.rb_node,\n\t\t       *parent = NULL;\n\tstruct nfs4_state_owner *sp, *res = NULL;\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\tsp = rb_entry(parent, struct nfs4_state_owner, so_client_node);\n\n\t\tif (server < sp->so_server) {\n\t\t\tp = &parent->rb_left;\n\t\t\tcontinue;\n\t\t}\n\t\tif (server > sp->so_server) {\n\t\t\tp = &parent->rb_right;\n\t\t\tcontinue;\n\t\t}\n\t\tif (cred < sp->so_cred)\n\t\t\tp = &parent->rb_left;\n\t\telse if (cred > sp->so_cred)\n\t\t\tp = &parent->rb_right;\n\t\telse {\n\t\t\tatomic_inc(&sp->so_count);\n\t\t\tres = sp;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic struct nfs4_state_owner *\nnfs4_insert_state_owner(struct nfs_client *clp, struct nfs4_state_owner *new)\n{\n\tstruct rb_node **p = &clp->cl_state_owners.rb_node,\n\t\t       *parent = NULL;\n\tstruct nfs4_state_owner *sp;\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\tsp = rb_entry(parent, struct nfs4_state_owner, so_client_node);\n\n\t\tif (new->so_server < sp->so_server) {\n\t\t\tp = &parent->rb_left;\n\t\t\tcontinue;\n\t\t}\n\t\tif (new->so_server > sp->so_server) {\n\t\t\tp = &parent->rb_right;\n\t\t\tcontinue;\n\t\t}\n\t\tif (new->so_cred < sp->so_cred)\n\t\t\tp = &parent->rb_left;\n\t\telse if (new->so_cred > sp->so_cred)\n\t\t\tp = &parent->rb_right;\n\t\telse {\n\t\t\tatomic_inc(&sp->so_count);\n\t\t\treturn sp;\n\t\t}\n\t}\n\tnfs_alloc_unique_id(&clp->cl_openowner_id, &new->so_owner_id, 1, 64);\n\trb_link_node(&new->so_client_node, parent, p);\n\trb_insert_color(&new->so_client_node, &clp->cl_state_owners);\n\treturn new;\n}\n\nstatic void\nnfs4_remove_state_owner(struct nfs_client *clp, struct nfs4_state_owner *sp)\n{\n\tif (!RB_EMPTY_NODE(&sp->so_client_node))\n\t\trb_erase(&sp->so_client_node, &clp->cl_state_owners);\n\tnfs_free_unique_id(&clp->cl_openowner_id, &sp->so_owner_id);\n}\n\n/*\n * nfs4_alloc_state_owner(): this is called on the OPEN or CREATE path to\n * create a new state_owner.\n *\n */\nstatic struct nfs4_state_owner *\nnfs4_alloc_state_owner(void)\n{\n\tstruct nfs4_state_owner *sp;\n\n\tsp = kzalloc(sizeof(*sp),GFP_KERNEL);\n\tif (!sp)\n\t\treturn NULL;\n\tspin_lock_init(&sp->so_lock);\n\tINIT_LIST_HEAD(&sp->so_states);\n\tINIT_LIST_HEAD(&sp->so_delegations);\n\trpc_init_wait_queue(&sp->so_sequence.wait, \"Seqid_waitqueue\");\n\tsp->so_seqid.sequence = &sp->so_sequence;\n\tspin_lock_init(&sp->so_sequence.lock);\n\tINIT_LIST_HEAD(&sp->so_sequence.list);\n\tatomic_set(&sp->so_count, 1);\n\treturn sp;\n}\n\nstatic void\nnfs4_drop_state_owner(struct nfs4_state_owner *sp)\n{\n\tif (!RB_EMPTY_NODE(&sp->so_client_node)) {\n\t\tstruct nfs_client *clp = sp->so_client;\n\n\t\tspin_lock(&clp->cl_lock);\n\t\trb_erase(&sp->so_client_node, &clp->cl_state_owners);\n\t\tRB_CLEAR_NODE(&sp->so_client_node);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n}\n\nstruct nfs4_state_owner *nfs4_get_state_owner(struct nfs_server *server, struct rpc_cred *cred)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_state_owner *sp, *new;\n\n\tspin_lock(&clp->cl_lock);\n\tsp = nfs4_find_state_owner(server, cred);\n\tspin_unlock(&clp->cl_lock);\n\tif (sp != NULL)\n\t\treturn sp;\n\tnew = nfs4_alloc_state_owner();\n\tif (new == NULL)\n\t\treturn NULL;\n\tnew->so_client = clp;\n\tnew->so_server = server;\n\tnew->so_cred = cred;\n\tspin_lock(&clp->cl_lock);\n\tsp = nfs4_insert_state_owner(clp, new);\n\tspin_unlock(&clp->cl_lock);\n\tif (sp == new)\n\t\tget_rpccred(cred);\n\telse {\n\t\trpc_destroy_wait_queue(&new->so_sequence.wait);\n\t\tkfree(new);\n\t}\n\treturn sp;\n}\n\nvoid nfs4_put_state_owner(struct nfs4_state_owner *sp)\n{\n\tstruct nfs_client *clp = sp->so_client;\n\tstruct rpc_cred *cred = sp->so_cred;\n\n\tif (!atomic_dec_and_lock(&sp->so_count, &clp->cl_lock))\n\t\treturn;\n\tnfs4_remove_state_owner(clp, sp);\n\tspin_unlock(&clp->cl_lock);\n\trpc_destroy_wait_queue(&sp->so_sequence.wait);\n\tput_rpccred(cred);\n\tkfree(sp);\n}\n\nstatic struct nfs4_state *\nnfs4_alloc_open_state(void)\n{\n\tstruct nfs4_state *state;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\tatomic_set(&state->count, 1);\n\tINIT_LIST_HEAD(&state->lock_states);\n\tspin_lock_init(&state->state_lock);\n\tseqlock_init(&state->seqlock);\n\treturn state;\n}\n\nvoid\nnfs4_state_set_mode_locked(struct nfs4_state *state, mode_t mode)\n{\n\tif (state->state == mode)\n\t\treturn;\n\t/* NB! List reordering - see the reclaim code for why.  */\n\tif ((mode & FMODE_WRITE) != (state->state & FMODE_WRITE)) {\n\t\tif (mode & FMODE_WRITE)\n\t\t\tlist_move(&state->open_states, &state->owner->so_states);\n\t\telse\n\t\t\tlist_move_tail(&state->open_states, &state->owner->so_states);\n\t}\n\tstate->state = mode;\n}\n\nstatic struct nfs4_state *\n__nfs4_find_state_byowner(struct inode *inode, struct nfs4_state_owner *owner)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs4_state *state;\n\n\tlist_for_each_entry(state, &nfsi->open_states, inode_states) {\n\t\tif (state->owner != owner)\n\t\t\tcontinue;\n\t\tif (atomic_inc_not_zero(&state->count))\n\t\t\treturn state;\n\t}\n\treturn NULL;\n}\n\nstatic void\nnfs4_free_open_state(struct nfs4_state *state)\n{\n\tkfree(state);\n}\n\nstruct nfs4_state *\nnfs4_get_open_state(struct inode *inode, struct nfs4_state_owner *owner)\n{\n\tstruct nfs4_state *state, *new;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tspin_lock(&inode->i_lock);\n\tstate = __nfs4_find_state_byowner(inode, owner);\n\tspin_unlock(&inode->i_lock);\n\tif (state)\n\t\tgoto out;\n\tnew = nfs4_alloc_open_state();\n\tspin_lock(&owner->so_lock);\n\tspin_lock(&inode->i_lock);\n\tstate = __nfs4_find_state_byowner(inode, owner);\n\tif (state == NULL && new != NULL) {\n\t\tstate = new;\n\t\tstate->owner = owner;\n\t\tatomic_inc(&owner->so_count);\n\t\tlist_add(&state->inode_states, &nfsi->open_states);\n\t\tstate->inode = igrab(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\t/* Note: The reclaim code dictates that we add stateless\n\t\t * and read-only stateids to the end of the list */\n\t\tlist_add_tail(&state->open_states, &owner->so_states);\n\t\tspin_unlock(&owner->so_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\tspin_unlock(&owner->so_lock);\n\t\tif (new)\n\t\t\tnfs4_free_open_state(new);\n\t}\nout:\n\treturn state;\n}\n\nvoid nfs4_put_open_state(struct nfs4_state *state)\n{\n\tstruct inode *inode = state->inode;\n\tstruct nfs4_state_owner *owner = state->owner;\n\n\tif (!atomic_dec_and_lock(&state->count, &owner->so_lock))\n\t\treturn;\n\tspin_lock(&inode->i_lock);\n\tlist_del(&state->inode_states);\n\tlist_del(&state->open_states);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&owner->so_lock);\n\tiput(inode);\n\tnfs4_free_open_state(state);\n\tnfs4_put_state_owner(owner);\n}\n\n/*\n * Close the current file.\n */\nstatic void __nfs4_close(struct path *path, struct nfs4_state *state, mode_t mode, int wait)\n{\n\tstruct nfs4_state_owner *owner = state->owner;\n\tint call_close = 0;\n\tint newstate;\n\n\tatomic_inc(&owner->so_count);\n\t/* Protect against nfs4_find_state() */\n\tspin_lock(&owner->so_lock);\n\tswitch (mode & (FMODE_READ | FMODE_WRITE)) {\n\t\tcase FMODE_READ:\n\t\t\tstate->n_rdonly--;\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tstate->n_wronly--;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tstate->n_rdwr--;\n\t}\n\tnewstate = FMODE_READ|FMODE_WRITE;\n\tif (state->n_rdwr == 0) {\n\t\tif (state->n_rdonly == 0) {\n\t\t\tnewstate &= ~FMODE_READ;\n\t\t\tcall_close |= test_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tcall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (state->n_wronly == 0) {\n\t\t\tnewstate &= ~FMODE_WRITE;\n\t\t\tcall_close |= test_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tcall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (newstate == 0)\n\t\t\tclear_bit(NFS_DELEGATED_STATE, &state->flags);\n\t}\n\tnfs4_state_set_mode_locked(state, newstate);\n\tspin_unlock(&owner->so_lock);\n\n\tif (!call_close) {\n\t\tnfs4_put_open_state(state);\n\t\tnfs4_put_state_owner(owner);\n\t} else\n\t\tnfs4_do_close(path, state, wait);\n}\n\nvoid nfs4_close_state(struct path *path, struct nfs4_state *state, mode_t mode)\n{\n\t__nfs4_close(path, state, mode, 0);\n}\n\nvoid nfs4_close_sync(struct path *path, struct nfs4_state *state, mode_t mode)\n{\n\t__nfs4_close(path, state, mode, 1);\n}\n\n/*\n * Search the state->lock_states for an existing lock_owner\n * that is compatible with current->files\n */\nstatic struct nfs4_lock_state *\n__nfs4_find_lock_state(struct nfs4_state *state, fl_owner_t fl_owner)\n{\n\tstruct nfs4_lock_state *pos;\n\tlist_for_each_entry(pos, &state->lock_states, ls_locks) {\n\t\tif (pos->ls_owner != fl_owner)\n\t\t\tcontinue;\n\t\tatomic_inc(&pos->ls_count);\n\t\treturn pos;\n\t}\n\treturn NULL;\n}\n\n/*\n * Return a compatible lock_state. If no initialized lock_state structure\n * exists, return an uninitialized one.\n *\n */\nstatic struct nfs4_lock_state *nfs4_alloc_lock_state(struct nfs4_state *state, fl_owner_t fl_owner)\n{\n\tstruct nfs4_lock_state *lsp;\n\tstruct nfs_client *clp = state->owner->so_client;\n\n\tlsp = kzalloc(sizeof(*lsp), GFP_KERNEL);\n\tif (lsp == NULL)\n\t\treturn NULL;\n\trpc_init_wait_queue(&lsp->ls_sequence.wait, \"lock_seqid_waitqueue\");\n\tspin_lock_init(&lsp->ls_sequence.lock);\n\tINIT_LIST_HEAD(&lsp->ls_sequence.list);\n\tlsp->ls_seqid.sequence = &lsp->ls_sequence;\n\tatomic_set(&lsp->ls_count, 1);\n\tlsp->ls_owner = fl_owner;\n\tspin_lock(&clp->cl_lock);\n\tnfs_alloc_unique_id(&clp->cl_lockowner_id, &lsp->ls_id, 1, 64);\n\tspin_unlock(&clp->cl_lock);\n\tINIT_LIST_HEAD(&lsp->ls_locks);\n\treturn lsp;\n}\n\nstatic void nfs4_free_lock_state(struct nfs4_lock_state *lsp)\n{\n\tstruct nfs_client *clp = lsp->ls_state->owner->so_client;\n\n\tspin_lock(&clp->cl_lock);\n\tnfs_free_unique_id(&clp->cl_lockowner_id, &lsp->ls_id);\n\tspin_unlock(&clp->cl_lock);\n\trpc_destroy_wait_queue(&lsp->ls_sequence.wait);\n\tkfree(lsp);\n}\n\n/*\n * Return a compatible lock_state. If no initialized lock_state structure\n * exists, return an uninitialized one.\n *\n */\nstatic struct nfs4_lock_state *nfs4_get_lock_state(struct nfs4_state *state, fl_owner_t owner)\n{\n\tstruct nfs4_lock_state *lsp, *new = NULL;\n\t\n\tfor(;;) {\n\t\tspin_lock(&state->state_lock);\n\t\tlsp = __nfs4_find_lock_state(state, owner);\n\t\tif (lsp != NULL)\n\t\t\tbreak;\n\t\tif (new != NULL) {\n\t\t\tnew->ls_state = state;\n\t\t\tlist_add(&new->ls_locks, &state->lock_states);\n\t\t\tset_bit(LK_STATE_IN_USE, &state->flags);\n\t\t\tlsp = new;\n\t\t\tnew = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&state->state_lock);\n\t\tnew = nfs4_alloc_lock_state(state, owner);\n\t\tif (new == NULL)\n\t\t\treturn NULL;\n\t}\n\tspin_unlock(&state->state_lock);\n\tif (new != NULL)\n\t\tnfs4_free_lock_state(new);\n\treturn lsp;\n}\n\n/*\n * Release reference to lock_state, and free it if we see that\n * it is no longer in use\n */\nvoid nfs4_put_lock_state(struct nfs4_lock_state *lsp)\n{\n\tstruct nfs4_state *state;\n\n\tif (lsp == NULL)\n\t\treturn;\n\tstate = lsp->ls_state;\n\tif (!atomic_dec_and_lock(&lsp->ls_count, &state->state_lock))\n\t\treturn;\n\tlist_del(&lsp->ls_locks);\n\tif (list_empty(&state->lock_states))\n\t\tclear_bit(LK_STATE_IN_USE, &state->flags);\n\tspin_unlock(&state->state_lock);\n\tnfs4_free_lock_state(lsp);\n}\n\nstatic void nfs4_fl_copy_lock(struct file_lock *dst, struct file_lock *src)\n{\n\tstruct nfs4_lock_state *lsp = src->fl_u.nfs4_fl.owner;\n\n\tdst->fl_u.nfs4_fl.owner = lsp;\n\tatomic_inc(&lsp->ls_count);\n}\n\nstatic void nfs4_fl_release_lock(struct file_lock *fl)\n{\n\tnfs4_put_lock_state(fl->fl_u.nfs4_fl.owner);\n}\n\nstatic struct file_lock_operations nfs4_fl_lock_ops = {\n\t.fl_copy_lock = nfs4_fl_copy_lock,\n\t.fl_release_private = nfs4_fl_release_lock,\n};\n\nint nfs4_set_lock_state(struct nfs4_state *state, struct file_lock *fl)\n{\n\tstruct nfs4_lock_state *lsp;\n\n\tif (fl->fl_ops != NULL)\n\t\treturn 0;\n\tlsp = nfs4_get_lock_state(state, fl->fl_owner);\n\tif (lsp == NULL)\n\t\treturn -ENOMEM;\n\tfl->fl_u.nfs4_fl.owner = lsp;\n\tfl->fl_ops = &nfs4_fl_lock_ops;\n\treturn 0;\n}\n\n/*\n * Byte-range lock aware utility to initialize the stateid of read/write\n * requests.\n */\nvoid nfs4_copy_stateid(nfs4_stateid *dst, struct nfs4_state *state, fl_owner_t fl_owner)\n{\n\tstruct nfs4_lock_state *lsp;\n\tint seq;\n\n\tdo {\n\t\tseq = read_seqbegin(&state->seqlock);\n\t\tmemcpy(dst, &state->stateid, sizeof(*dst));\n\t} while (read_seqretry(&state->seqlock, seq));\n\tif (test_bit(LK_STATE_IN_USE, &state->flags) == 0)\n\t\treturn;\n\n\tspin_lock(&state->state_lock);\n\tlsp = __nfs4_find_lock_state(state, fl_owner);\n\tif (lsp != NULL && (lsp->ls_flags & NFS_LOCK_INITIALIZED) != 0)\n\t\tmemcpy(dst, &lsp->ls_stateid, sizeof(*dst));\n\tspin_unlock(&state->state_lock);\n\tnfs4_put_lock_state(lsp);\n}\n\nstruct nfs_seqid *nfs_alloc_seqid(struct nfs_seqid_counter *counter)\n{\n\tstruct nfs_seqid *new;\n\n\tnew = kmalloc(sizeof(*new), GFP_KERNEL);\n\tif (new != NULL) {\n\t\tnew->sequence = counter;\n\t\tINIT_LIST_HEAD(&new->list);\n\t}\n\treturn new;\n}\n\nvoid nfs_free_seqid(struct nfs_seqid *seqid)\n{\n\tif (!list_empty(&seqid->list)) {\n\t\tstruct rpc_sequence *sequence = seqid->sequence->sequence;\n\n\t\tspin_lock(&sequence->lock);\n\t\tlist_del(&seqid->list);\n\t\tspin_unlock(&sequence->lock);\n\t\trpc_wake_up(&sequence->wait);\n\t}\n\tkfree(seqid);\n}\n\n/*\n * Increment the seqid if the OPEN/OPEN_DOWNGRADE/CLOSE succeeded, or\n * failed with a seqid incrementing error -\n * see comments nfs_fs.h:seqid_mutating_error()\n */\nstatic void nfs_increment_seqid(int status, struct nfs_seqid *seqid)\n{\n\tBUG_ON(list_first_entry(&seqid->sequence->sequence->list, struct nfs_seqid, list) != seqid);\n\tswitch (status) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -NFS4ERR_BAD_SEQID:\n\t\t\tif (seqid->sequence->flags & NFS_SEQID_CONFIRMED)\n\t\t\t\treturn;\n\t\t\tprintk(KERN_WARNING \"NFS: v4 server returned a bad\"\n\t\t\t\t\t\" sequence-id error on an\"\n\t\t\t\t\t\" unconfirmed sequence %p!\\n\",\n\t\t\t\t\tseqid->sequence);\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_BADXDR:\n\t\tcase -NFS4ERR_RESOURCE:\n\t\tcase -NFS4ERR_NOFILEHANDLE:\n\t\t\t/* Non-seqid mutating errors */\n\t\t\treturn;\n\t};\n\t/*\n\t * Note: no locking needed as we are guaranteed to be first\n\t * on the sequence list\n\t */\n\tseqid->sequence->counter++;\n}\n\nvoid nfs_increment_open_seqid(int status, struct nfs_seqid *seqid)\n{\n\tif (status == -NFS4ERR_BAD_SEQID) {\n\t\tstruct nfs4_state_owner *sp = container_of(seqid->sequence,\n\t\t\t\tstruct nfs4_state_owner, so_seqid);\n\t\tnfs4_drop_state_owner(sp);\n\t}\n\tnfs_increment_seqid(status, seqid);\n}\n\n/*\n * Increment the seqid if the LOCK/LOCKU succeeded, or\n * failed with a seqid incrementing error -\n * see comments nfs_fs.h:seqid_mutating_error()\n */\nvoid nfs_increment_lock_seqid(int status, struct nfs_seqid *seqid)\n{\n\tnfs_increment_seqid(status, seqid);\n}\n\nint nfs_wait_on_sequence(struct nfs_seqid *seqid, struct rpc_task *task)\n{\n\tstruct rpc_sequence *sequence = seqid->sequence->sequence;\n\tint status = 0;\n\n\tspin_lock(&sequence->lock);\n\tif (list_empty(&seqid->list))\n\t\tlist_add_tail(&seqid->list, &sequence->list);\n\tif (list_first_entry(&sequence->list, struct nfs_seqid, list) == seqid)\n\t\tgoto unlock;\n\trpc_sleep_on(&sequence->wait, task, NULL);\n\tstatus = -EAGAIN;\nunlock:\n\tspin_unlock(&sequence->lock);\n\treturn status;\n}\n\nstatic int nfs4_run_state_manager(void *);\n\nstatic void nfs4_clear_state_manager_bit(struct nfs_client *clp)\n{\n\tsmp_mb__before_clear_bit();\n\tclear_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state);\n\tsmp_mb__after_clear_bit();\n\twake_up_bit(&clp->cl_state, NFS4CLNT_MANAGER_RUNNING);\n\trpc_wake_up(&clp->cl_rpcwaitq);\n}\n\n/*\n * Schedule the nfs_client asynchronous state management routine\n */\nvoid nfs4_schedule_state_manager(struct nfs_client *clp)\n{\n\tstruct task_struct *task;\n\n\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\treturn;\n\t__module_get(THIS_MODULE);\n\tatomic_inc(&clp->cl_count);\n\ttask = kthread_run(nfs4_run_state_manager, clp, \"%s-manager\",\n\t\t\t\trpc_peeraddr2str(clp->cl_rpcclient,\n\t\t\t\t\t\t\tRPC_DISPLAY_ADDR));\n\tif (!IS_ERR(task))\n\t\treturn;\n\tnfs4_clear_state_manager_bit(clp);\n\tnfs_put_client(clp);\n\tmodule_put(THIS_MODULE);\n}\n\n/*\n * Schedule a state recovery attempt\n */\nvoid nfs4_schedule_state_recovery(struct nfs_client *clp)\n{\n\tif (!clp)\n\t\treturn;\n\tif (!test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state))\n\t\tset_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state);\n\tnfs4_schedule_state_manager(clp);\n}\n\nstatic int nfs4_state_mark_reclaim_reboot(struct nfs_client *clp, struct nfs4_state *state)\n{\n\n\tset_bit(NFS_STATE_RECLAIM_REBOOT, &state->flags);\n\t/* Don't recover state that expired before the reboot */\n\tif (test_bit(NFS_STATE_RECLAIM_NOGRACE, &state->flags)) {\n\t\tclear_bit(NFS_STATE_RECLAIM_REBOOT, &state->flags);\n\t\treturn 0;\n\t}\n\tset_bit(NFS_OWNER_RECLAIM_REBOOT, &state->owner->so_flags);\n\tset_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state);\n\treturn 1;\n}\n\nint nfs4_state_mark_reclaim_nograce(struct nfs_client *clp, struct nfs4_state *state)\n{\n\tset_bit(NFS_STATE_RECLAIM_NOGRACE, &state->flags);\n\tclear_bit(NFS_STATE_RECLAIM_REBOOT, &state->flags);\n\tset_bit(NFS_OWNER_RECLAIM_NOGRACE, &state->owner->so_flags);\n\tset_bit(NFS4CLNT_RECLAIM_NOGRACE, &clp->cl_state);\n\treturn 1;\n}\n\nstatic int nfs4_reclaim_locks(struct nfs4_state *state, const struct nfs4_state_recovery_ops *ops)\n{\n\tstruct inode *inode = state->inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct file_lock *fl;\n\tint status = 0;\n\n\tdown_write(&nfsi->rwsem);\n\tfor (fl = inode->i_flock; fl != NULL; fl = fl->fl_next) {\n\t\tif (!(fl->fl_flags & (FL_POSIX|FL_FLOCK)))\n\t\t\tcontinue;\n\t\tif (nfs_file_open_context(fl->fl_file)->state != state)\n\t\t\tcontinue;\n\t\tstatus = ops->recover_lock(state, fl);\n\t\tif (status >= 0)\n\t\t\tcontinue;\n\t\tswitch (status) {\n\t\t\tdefault:\n\t\t\t\tprintk(KERN_ERR \"%s: unhandled error %d. Zeroing state\\n\",\n\t\t\t\t\t\t__func__, status);\n\t\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tcase -NFS4ERR_NO_GRACE:\n\t\t\tcase -NFS4ERR_RECLAIM_BAD:\n\t\t\tcase -NFS4ERR_RECLAIM_CONFLICT:\n\t\t\t\t/* kill_proc(fl->fl_pid, SIGLOST, 1); */\n\t\t\t\tbreak;\n\t\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\t\tgoto out_err;\n\t\t}\n\t}\n\tup_write(&nfsi->rwsem);\n\treturn 0;\nout_err:\n\tup_write(&nfsi->rwsem);\n\treturn status;\n}\n\nstatic int nfs4_reclaim_open_state(struct nfs4_state_owner *sp, const struct nfs4_state_recovery_ops *ops)\n{\n\tstruct nfs4_state *state;\n\tstruct nfs4_lock_state *lock;\n\tint status = 0;\n\n\t/* Note: we rely on the sp->so_states list being ordered \n\t * so that we always reclaim open(O_RDWR) and/or open(O_WRITE)\n\t * states first.\n\t * This is needed to ensure that the server won't give us any\n\t * read delegations that we have to return if, say, we are\n\t * recovering after a network partition or a reboot from a\n\t * server that doesn't support a grace period.\n\t */\nrestart:\n\tspin_lock(&sp->so_lock);\n\tlist_for_each_entry(state, &sp->so_states, open_states) {\n\t\tif (!test_and_clear_bit(ops->state_flag_bit, &state->flags))\n\t\t\tcontinue;\n\t\tif (state->state == 0)\n\t\t\tcontinue;\n\t\tatomic_inc(&state->count);\n\t\tspin_unlock(&sp->so_lock);\n\t\tstatus = ops->recover_open(sp, state);\n\t\tif (status >= 0) {\n\t\t\tstatus = nfs4_reclaim_locks(state, ops);\n\t\t\tif (status >= 0) {\n\t\t\t\tlist_for_each_entry(lock, &state->lock_states, ls_locks) {\n\t\t\t\t\tif (!(lock->ls_flags & NFS_LOCK_INITIALIZED))\n\t\t\t\t\t\tprintk(\"%s: Lock reclaim failed!\\n\",\n\t\t\t\t\t\t\t__func__);\n\t\t\t\t}\n\t\t\t\tnfs4_put_open_state(state);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t}\n\t\tswitch (status) {\n\t\t\tdefault:\n\t\t\t\tprintk(KERN_ERR \"%s: unhandled error %d. Zeroing state\\n\",\n\t\t\t\t\t\t__func__, status);\n\t\t\tcase -ENOENT:\n\t\t\tcase -ESTALE:\n\t\t\t\t/*\n\t\t\t\t * Open state on this file cannot be recovered\n\t\t\t\t * All we can do is revert to using the zero stateid.\n\t\t\t\t */\n\t\t\t\tmemset(state->stateid.data, 0,\n\t\t\t\t\tsizeof(state->stateid.data));\n\t\t\t\t/* Mark the file as being 'closed' */\n\t\t\t\tstate->state = 0;\n\t\t\t\tbreak;\n\t\t\tcase -NFS4ERR_RECLAIM_BAD:\n\t\t\tcase -NFS4ERR_RECLAIM_CONFLICT:\n\t\t\t\tnfs4_state_mark_reclaim_nograce(sp->so_client, state);\n\t\t\t\tbreak;\n\t\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tcase -NFS4ERR_NO_GRACE:\n\t\t\t\tnfs4_state_mark_reclaim_nograce(sp->so_client, state);\n\t\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\t\tgoto out_err;\n\t\t}\n\t\tnfs4_put_open_state(state);\n\t\tgoto restart;\n\t}\n\tspin_unlock(&sp->so_lock);\n\treturn 0;\nout_err:\n\tnfs4_put_open_state(state);\n\treturn status;\n}\n\nstatic void nfs4_clear_open_state(struct nfs4_state *state)\n{\n\tstruct nfs4_lock_state *lock;\n\n\tclear_bit(NFS_DELEGATED_STATE, &state->flags);\n\tclear_bit(NFS_O_RDONLY_STATE, &state->flags);\n\tclear_bit(NFS_O_WRONLY_STATE, &state->flags);\n\tclear_bit(NFS_O_RDWR_STATE, &state->flags);\n\tlist_for_each_entry(lock, &state->lock_states, ls_locks) {\n\t\tlock->ls_seqid.flags = 0;\n\t\tlock->ls_flags &= ~NFS_LOCK_INITIALIZED;\n\t}\n}\n\nstatic void nfs4_state_mark_reclaim_helper(struct nfs_client *clp, int (*mark_reclaim)(struct nfs_client *clp, struct nfs4_state *state))\n{\n\tstruct nfs4_state_owner *sp;\n\tstruct rb_node *pos;\n\tstruct nfs4_state *state;\n\n\t/* Reset all sequence ids to zero */\n\tfor (pos = rb_first(&clp->cl_state_owners); pos != NULL; pos = rb_next(pos)) {\n\t\tsp = rb_entry(pos, struct nfs4_state_owner, so_client_node);\n\t\tsp->so_seqid.flags = 0;\n\t\tspin_lock(&sp->so_lock);\n\t\tlist_for_each_entry(state, &sp->so_states, open_states) {\n\t\t\tif (mark_reclaim(clp, state))\n\t\t\t\tnfs4_clear_open_state(state);\n\t\t}\n\t\tspin_unlock(&sp->so_lock);\n\t}\n}\n\nstatic void nfs4_state_start_reclaim_reboot(struct nfs_client *clp)\n{\n\t/* Mark all delegations for reclaim */\n\tnfs_delegation_mark_reclaim(clp);\n\tnfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_reboot);\n}\n\nstatic void nfs4_state_end_reclaim_reboot(struct nfs_client *clp)\n{\n\tstruct nfs4_state_owner *sp;\n\tstruct rb_node *pos;\n\tstruct nfs4_state *state;\n\n\tif (!test_and_clear_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state))\n\t\treturn;\n\n\tfor (pos = rb_first(&clp->cl_state_owners); pos != NULL; pos = rb_next(pos)) {\n\t\tsp = rb_entry(pos, struct nfs4_state_owner, so_client_node);\n\t\tspin_lock(&sp->so_lock);\n\t\tlist_for_each_entry(state, &sp->so_states, open_states) {\n\t\t\tif (!test_and_clear_bit(NFS_STATE_RECLAIM_REBOOT, &state->flags))\n\t\t\t\tcontinue;\n\t\t\tnfs4_state_mark_reclaim_nograce(clp, state);\n\t\t}\n\t\tspin_unlock(&sp->so_lock);\n\t}\n\n\tnfs_delegation_reap_unclaimed(clp);\n}\n\nstatic void nfs_delegation_clear_all(struct nfs_client *clp)\n{\n\tnfs_delegation_mark_reclaim(clp);\n\tnfs_delegation_reap_unclaimed(clp);\n}\n\nstatic void nfs4_state_start_reclaim_nograce(struct nfs_client *clp)\n{\n\tnfs_delegation_clear_all(clp);\n\tnfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_nograce);\n}\n\nstatic void nfs4_state_end_reclaim_nograce(struct nfs_client *clp)\n{\n\tclear_bit(NFS4CLNT_RECLAIM_NOGRACE, &clp->cl_state);\n}\n\nstatic void nfs4_recovery_handle_error(struct nfs_client *clp, int error)\n{\n\tswitch (error) {\n\t\tcase -NFS4ERR_CB_PATH_DOWN:\n\t\t\tnfs_handle_cb_pathdown(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tcase -NFS4ERR_LEASE_MOVED:\n\t\t\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\t\t\tnfs4_state_start_reclaim_reboot(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\t\t\tnfs4_state_start_reclaim_nograce(clp);\n\t}\n}\n\nstatic int nfs4_do_reclaim(struct nfs_client *clp, const struct nfs4_state_recovery_ops *ops)\n{\n\tstruct rb_node *pos;\n\tint status = 0;\n\nrestart:\n\tspin_lock(&clp->cl_lock);\n\tfor (pos = rb_first(&clp->cl_state_owners); pos != NULL; pos = rb_next(pos)) {\n\t\tstruct nfs4_state_owner *sp = rb_entry(pos, struct nfs4_state_owner, so_client_node);\n\t\tif (!test_and_clear_bit(ops->owner_flag_bit, &sp->so_flags))\n\t\t\tcontinue;\n\t\tatomic_inc(&sp->so_count);\n\t\tspin_unlock(&clp->cl_lock);\n\t\tstatus = nfs4_reclaim_open_state(sp, ops);\n\t\tif (status < 0) {\n\t\t\tset_bit(ops->owner_flag_bit, &sp->so_flags);\n\t\t\tnfs4_put_state_owner(sp);\n\t\t\tnfs4_recovery_handle_error(clp, status);\n\t\t\treturn status;\n\t\t}\n\t\tnfs4_put_state_owner(sp);\n\t\tgoto restart;\n\t}\n\tspin_unlock(&clp->cl_lock);\n\treturn status;\n}\n\nstatic int nfs4_check_lease(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\tint status = -NFS4ERR_EXPIRED;\n\n\t/* Is the client already known to have an expired lease? */\n\tif (test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state))\n\t\treturn 0;\n\tcred = nfs4_get_renew_cred(clp);\n\tif (cred == NULL) {\n\t\tcred = nfs4_get_setclientid_cred(clp);\n\t\tif (cred == NULL)\n\t\t\tgoto out;\n\t}\n\tstatus = nfs4_proc_renew(clp, cred);\n\tput_rpccred(cred);\nout:\n\tnfs4_recovery_handle_error(clp, status);\n\treturn status;\n}\n\nstatic int nfs4_reclaim_lease(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\tint status = -ENOENT;\n\n\tcred = nfs4_get_setclientid_cred(clp);\n\tif (cred != NULL) {\n\t\tstatus = nfs4_init_client(clp, cred);\n\t\tput_rpccred(cred);\n\t\t/* Handle case where the user hasn't set up machine creds */\n\t\tif (status == -EACCES && cred == clp->cl_machine_cred) {\n\t\t\tnfs4_clear_machine_cred(clp);\n\t\t\tstatus = -EAGAIN;\n\t\t}\n\t}\n\treturn status;\n}\n\nstatic void nfs4_state_manager(struct nfs_client *clp)\n{\n\tint status = 0;\n\n\t/* Ensure exclusive access to NFSv4 state */\n\tfor(;;) {\n\t\tif (test_and_clear_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state)) {\n\t\t\t/* We're going to have to re-establish a clientid */\n\t\t\tstatus = nfs4_reclaim_lease(clp);\n\t\t\tif (status) {\n\t\t\t\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\t\t\t\tif (status == -EAGAIN)\n\t\t\t\t\tcontinue;\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tclear_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state);\n\t\t}\n\n\t\tif (test_and_clear_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state)) {\n\t\t\tstatus = nfs4_check_lease(clp);\n\t\t\tif (status != 0)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* First recover reboot state... */\n\t\tif (test_and_clear_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state)) {\n\t\t\tstatus = nfs4_do_reclaim(clp, &nfs4_reboot_recovery_ops);\n\t\t\tif (status == -NFS4ERR_STALE_CLIENTID)\n\t\t\t\tcontinue;\n\t\t\tnfs4_state_end_reclaim_reboot(clp);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Now recover expired state... */\n\t\tif (test_and_clear_bit(NFS4CLNT_RECLAIM_NOGRACE, &clp->cl_state)) {\n\t\t\tstatus = nfs4_do_reclaim(clp, &nfs4_nograce_recovery_ops);\n\t\t\tif (status < 0) {\n\t\t\t\tset_bit(NFS4CLNT_RECLAIM_NOGRACE, &clp->cl_state);\n\t\t\t\tif (status == -NFS4ERR_STALE_CLIENTID)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (status == -NFS4ERR_EXPIRED)\n\t\t\t\t\tcontinue;\n\t\t\t\tgoto out_error;\n\t\t\t} else\n\t\t\t\tnfs4_state_end_reclaim_nograce(clp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (test_and_clear_bit(NFS4CLNT_DELEGRETURN, &clp->cl_state)) {\n\t\t\tnfs_client_return_marked_delegations(clp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnfs4_clear_state_manager_bit(clp);\n\t\t/* Did we race with an attempt to give us more work? */\n\t\tif (clp->cl_state == 0)\n\t\t\tbreak;\n\t\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\t\tbreak;\n\t}\n\treturn;\nout_error:\n\tprintk(KERN_WARNING \"Error: state manager failed on NFSv4 server %s\"\n\t\t\t\" with error %d\\n\", clp->cl_hostname, -status);\n\tif (test_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state))\n\t\tnfs4_state_end_reclaim_reboot(clp);\n\tnfs4_clear_state_manager_bit(clp);\n}\n\nstatic int nfs4_run_state_manager(void *ptr)\n{\n\tstruct nfs_client *clp = ptr;\n\n\tallow_signal(SIGKILL);\n\tnfs4_state_manager(clp);\n\tnfs_put_client(clp);\n\tmodule_put_and_exit(0);\n\treturn 0;\n}\n\n/*\n * Local variables:\n *  c-basic-offset: 8\n * End:\n */\n", "/*\n *  fs/nfs/nfs4xdr.c\n *\n *  Client-side XDR for NFSv4.\n *\n *  Copyright (c) 2002 The Regents of the University of Michigan.\n *  All rights reserved.\n *\n *  Kendrick Smith <kmsmith@umich.edu>\n *  Andy Adamson   <andros@umich.edu>\n * \n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions\n *  are met:\n *\n *  1. Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *  2. Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *  3. Neither the name of the University nor the names of its\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED\n *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n *  DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n *  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <linux/param.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/in.h>\n#include <linux/pagemap.h>\n#include <linux/proc_fs.h>\n#include <linux/kdev_t.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_idmap.h>\n#include \"nfs4_fs.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_XDR\n\n/* Mapping from NFS error code to \"errno\" error code. */\n#define errno_NFSERR_IO\t\tEIO\n\nstatic int nfs4_stat_to_errno(int);\n\n/* NFSv4 COMPOUND tags are only wanted for debugging purposes */\n#ifdef DEBUG\n#define NFS4_MAXTAGLEN\t\t20\n#else\n#define NFS4_MAXTAGLEN\t\t0\n#endif\n\n/* lock,open owner id: \n * we currently use size 2 (u64) out of (NFS4_OPAQUE_LIMIT  >> 2)\n */\n#define open_owner_id_maxsz\t(1 + 4)\n#define lock_owner_id_maxsz\t(1 + 4)\n#define decode_lockowner_maxsz\t(1 + XDR_QUADLEN(IDMAP_NAMESZ))\n#define compound_encode_hdr_maxsz\t(3 + (NFS4_MAXTAGLEN >> 2))\n#define compound_decode_hdr_maxsz\t(3 + (NFS4_MAXTAGLEN >> 2))\n#define op_encode_hdr_maxsz\t(1)\n#define op_decode_hdr_maxsz\t(2)\n#define encode_stateid_maxsz\t(XDR_QUADLEN(NFS4_STATEID_SIZE))\n#define decode_stateid_maxsz\t(XDR_QUADLEN(NFS4_STATEID_SIZE))\n#define encode_verifier_maxsz\t(XDR_QUADLEN(NFS4_VERIFIER_SIZE))\n#define decode_verifier_maxsz\t(XDR_QUADLEN(NFS4_VERIFIER_SIZE))\n#define encode_putfh_maxsz\t(op_encode_hdr_maxsz + 1 + \\\n\t\t\t\t(NFS4_FHSIZE >> 2))\n#define decode_putfh_maxsz\t(op_decode_hdr_maxsz)\n#define encode_putrootfh_maxsz\t(op_encode_hdr_maxsz)\n#define decode_putrootfh_maxsz\t(op_decode_hdr_maxsz)\n#define encode_getfh_maxsz      (op_encode_hdr_maxsz)\n#define decode_getfh_maxsz      (op_decode_hdr_maxsz + 1 + \\\n\t\t\t\t((3+NFS4_FHSIZE) >> 2))\n#define nfs4_fattr_bitmap_maxsz 3\n#define encode_getattr_maxsz    (op_encode_hdr_maxsz + nfs4_fattr_bitmap_maxsz)\n#define nfs4_name_maxsz\t\t(1 + ((3 + NFS4_MAXNAMLEN) >> 2))\n#define nfs4_path_maxsz\t\t(1 + ((3 + NFS4_MAXPATHLEN) >> 2))\n#define nfs4_owner_maxsz\t(1 + XDR_QUADLEN(IDMAP_NAMESZ))\n#define nfs4_group_maxsz\t(1 + XDR_QUADLEN(IDMAP_NAMESZ))\n/* This is based on getfattr, which uses the most attributes: */\n#define nfs4_fattr_value_maxsz\t(1 + (1 + 2 + 2 + 4 + 2 + 1 + 1 + 2 + 2 + \\\n\t\t\t\t3 + 3 + 3 + nfs4_owner_maxsz + nfs4_group_maxsz))\n#define nfs4_fattr_maxsz\t(nfs4_fattr_bitmap_maxsz + \\\n\t\t\t\tnfs4_fattr_value_maxsz)\n#define decode_getattr_maxsz    (op_decode_hdr_maxsz + nfs4_fattr_maxsz)\n#define encode_attrs_maxsz\t(nfs4_fattr_bitmap_maxsz + \\\n\t\t\t\t 1 + 2 + 1 + \\\n\t\t\t\tnfs4_owner_maxsz + \\\n\t\t\t\tnfs4_group_maxsz + \\\n\t\t\t\t4 + 4)\n#define encode_savefh_maxsz     (op_encode_hdr_maxsz)\n#define decode_savefh_maxsz     (op_decode_hdr_maxsz)\n#define encode_restorefh_maxsz  (op_encode_hdr_maxsz)\n#define decode_restorefh_maxsz  (op_decode_hdr_maxsz)\n#define encode_fsinfo_maxsz\t(encode_getattr_maxsz)\n#define decode_fsinfo_maxsz\t(op_decode_hdr_maxsz + 11)\n#define encode_renew_maxsz\t(op_encode_hdr_maxsz + 3)\n#define decode_renew_maxsz\t(op_decode_hdr_maxsz)\n#define encode_setclientid_maxsz \\\n\t\t\t\t(op_encode_hdr_maxsz + \\\n\t\t\t\tXDR_QUADLEN(NFS4_VERIFIER_SIZE) + \\\n\t\t\t\tXDR_QUADLEN(NFS4_SETCLIENTID_NAMELEN) + \\\n\t\t\t\t1 /* sc_prog */ + \\\n\t\t\t\tXDR_QUADLEN(RPCBIND_MAXNETIDLEN) + \\\n\t\t\t\tXDR_QUADLEN(RPCBIND_MAXUADDRLEN) + \\\n\t\t\t\t1) /* sc_cb_ident */\n#define decode_setclientid_maxsz \\\n\t\t\t\t(op_decode_hdr_maxsz + \\\n\t\t\t\t2 + \\\n\t\t\t\t1024) /* large value for CLID_INUSE */\n#define encode_setclientid_confirm_maxsz \\\n\t\t\t\t(op_encode_hdr_maxsz + \\\n\t\t\t\t3 + (NFS4_VERIFIER_SIZE >> 2))\n#define decode_setclientid_confirm_maxsz \\\n\t\t\t\t(op_decode_hdr_maxsz)\n#define encode_lookup_maxsz\t(op_encode_hdr_maxsz + nfs4_name_maxsz)\n#define decode_lookup_maxsz\t(op_decode_hdr_maxsz)\n#define encode_share_access_maxsz \\\n\t\t\t\t(2)\n#define encode_createmode_maxsz\t(1 + encode_attrs_maxsz)\n#define encode_opentype_maxsz\t(1 + encode_createmode_maxsz)\n#define encode_claim_null_maxsz\t(1 + nfs4_name_maxsz)\n#define encode_open_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t2 + encode_share_access_maxsz + 2 + \\\n\t\t\t\topen_owner_id_maxsz + \\\n\t\t\t\tencode_opentype_maxsz + \\\n\t\t\t\tencode_claim_null_maxsz)\n#define decode_ace_maxsz\t(3 + nfs4_owner_maxsz)\n#define decode_delegation_maxsz\t(1 + decode_stateid_maxsz + 1 + \\\n\t\t\t\tdecode_ace_maxsz)\n#define decode_change_info_maxsz\t(5)\n#define decode_open_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\tdecode_stateid_maxsz + \\\n\t\t\t\tdecode_change_info_maxsz + 1 + \\\n\t\t\t\tnfs4_fattr_bitmap_maxsz + \\\n\t\t\t\tdecode_delegation_maxsz)\n#define encode_open_confirm_maxsz \\\n\t\t\t\t(op_encode_hdr_maxsz + \\\n\t\t\t\t encode_stateid_maxsz + 1)\n#define decode_open_confirm_maxsz \\\n\t\t\t\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_stateid_maxsz)\n#define encode_open_downgrade_maxsz \\\n\t\t\t\t(op_encode_hdr_maxsz + \\\n\t\t\t\t encode_stateid_maxsz + 1 + \\\n\t\t\t\t encode_share_access_maxsz)\n#define decode_open_downgrade_maxsz \\\n\t\t\t\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_stateid_maxsz)\n#define encode_close_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t 1 + encode_stateid_maxsz)\n#define decode_close_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_stateid_maxsz)\n#define encode_setattr_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t encode_stateid_maxsz + \\\n\t\t\t\t encode_attrs_maxsz)\n#define decode_setattr_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t nfs4_fattr_bitmap_maxsz)\n#define encode_read_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t encode_stateid_maxsz + 3)\n#define decode_read_maxsz\t(op_decode_hdr_maxsz + 2)\n#define encode_readdir_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t 2 + encode_verifier_maxsz + 5)\n#define decode_readdir_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_verifier_maxsz)\n#define encode_readlink_maxsz\t(op_encode_hdr_maxsz)\n#define decode_readlink_maxsz\t(op_decode_hdr_maxsz + 1)\n#define encode_write_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t encode_stateid_maxsz + 4)\n#define decode_write_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t 2 + decode_verifier_maxsz)\n#define encode_commit_maxsz\t(op_encode_hdr_maxsz + 3)\n#define decode_commit_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_verifier_maxsz)\n#define encode_remove_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\tnfs4_name_maxsz)\n#define encode_rename_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t2 * nfs4_name_maxsz)\n#define decode_rename_maxsz\t(op_decode_hdr_maxsz + 5 + 5)\n#define encode_link_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\tnfs4_name_maxsz)\n#define decode_link_maxsz\t(op_decode_hdr_maxsz + 5)\n#define encode_lock_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t 7 + \\\n\t\t\t\t 1 + encode_stateid_maxsz + 8)\n#define decode_lock_denied_maxsz \\\n\t\t\t\t(8 + decode_lockowner_maxsz)\n#define decode_lock_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_lock_denied_maxsz)\n#define encode_lockt_maxsz\t(op_encode_hdr_maxsz + 12)\n#define decode_lockt_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_lock_denied_maxsz)\n#define encode_locku_maxsz\t(op_encode_hdr_maxsz + 3 + \\\n\t\t\t\t encode_stateid_maxsz + \\\n\t\t\t\t 4)\n#define decode_locku_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_stateid_maxsz)\n#define encode_access_maxsz\t(op_encode_hdr_maxsz + 1)\n#define decode_access_maxsz\t(op_decode_hdr_maxsz + 2)\n#define encode_symlink_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t1 + nfs4_name_maxsz + \\\n\t\t\t\t1 + \\\n\t\t\t\tnfs4_fattr_maxsz)\n#define decode_symlink_maxsz\t(op_decode_hdr_maxsz + 8)\n#define encode_create_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t1 + 2 + nfs4_name_maxsz + \\\n\t\t\t\tencode_attrs_maxsz)\n#define decode_create_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\tdecode_change_info_maxsz + \\\n\t\t\t\tnfs4_fattr_bitmap_maxsz)\n#define encode_statfs_maxsz\t(encode_getattr_maxsz)\n#define decode_statfs_maxsz\t(decode_getattr_maxsz)\n#define encode_delegreturn_maxsz (op_encode_hdr_maxsz + 4)\n#define decode_delegreturn_maxsz (op_decode_hdr_maxsz)\n#define encode_getacl_maxsz\t(encode_getattr_maxsz)\n#define decode_getacl_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t nfs4_fattr_bitmap_maxsz + 1)\n#define encode_setacl_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t encode_stateid_maxsz + 3)\n#define decode_setacl_maxsz\t(decode_setattr_maxsz)\n#define encode_fs_locations_maxsz \\\n\t\t\t\t(encode_getattr_maxsz)\n#define decode_fs_locations_maxsz \\\n\t\t\t\t(0)\n#define NFS4_enc_compound_sz\t(1024)  /* XXX: large enough? */\n#define NFS4_dec_compound_sz\t(1024)  /* XXX: large enough? */\n#define NFS4_enc_read_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_read_maxsz)\n#define NFS4_dec_read_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_read_maxsz)\n#define NFS4_enc_readlink_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_readlink_maxsz)\n#define NFS4_dec_readlink_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_readlink_maxsz)\n#define NFS4_enc_readdir_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_readdir_maxsz)\n#define NFS4_dec_readdir_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_readdir_maxsz)\n#define NFS4_enc_write_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_write_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_write_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_write_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_commit_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_commit_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_commit_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_commit_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_open_sz        (compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_savefh_maxsz + \\\n\t\t\t\tencode_open_maxsz + \\\n\t\t\t\tencode_getfh_maxsz + \\\n\t\t\t\tencode_getattr_maxsz + \\\n\t\t\t\tencode_restorefh_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_open_sz        (compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_savefh_maxsz + \\\n\t\t\t\tdecode_open_maxsz + \\\n\t\t\t\tdecode_getfh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz + \\\n\t\t\t\tdecode_restorefh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_open_confirm_sz \\\n\t\t\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t encode_open_confirm_maxsz)\n#define NFS4_dec_open_confirm_sz \\\n\t\t\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t decode_open_confirm_maxsz)\n#define NFS4_enc_open_noattr_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\t\tencode_open_maxsz + \\\n\t\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_open_noattr_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\t\tdecode_open_maxsz + \\\n\t\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_open_downgrade_sz \\\n\t\t\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t encode_open_downgrade_maxsz + \\\n\t\t\t\t encode_getattr_maxsz)\n#define NFS4_dec_open_downgrade_sz \\\n\t\t\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t decode_open_downgrade_maxsz + \\\n\t\t\t\t decode_getattr_maxsz)\n#define NFS4_enc_close_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t encode_close_maxsz + \\\n\t\t\t\t encode_getattr_maxsz)\n#define NFS4_dec_close_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t decode_close_maxsz + \\\n\t\t\t\t decode_getattr_maxsz)\n#define NFS4_enc_setattr_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t encode_setattr_maxsz + \\\n\t\t\t\t encode_getattr_maxsz)\n#define NFS4_dec_setattr_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t decode_setattr_maxsz + \\\n\t\t\t\t decode_getattr_maxsz)\n#define NFS4_enc_fsinfo_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_fsinfo_maxsz)\n#define NFS4_dec_fsinfo_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_fsinfo_maxsz)\n#define NFS4_enc_renew_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_renew_maxsz)\n#define NFS4_dec_renew_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_renew_maxsz)\n#define NFS4_enc_setclientid_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_setclientid_maxsz)\n#define NFS4_dec_setclientid_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_setclientid_maxsz)\n#define NFS4_enc_setclientid_confirm_sz \\\n\t\t\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_setclientid_confirm_maxsz + \\\n\t\t\t\tencode_putrootfh_maxsz + \\\n\t\t\t\tencode_fsinfo_maxsz)\n#define NFS4_dec_setclientid_confirm_sz \\\n\t\t\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_setclientid_confirm_maxsz + \\\n\t\t\t\tdecode_putrootfh_maxsz + \\\n\t\t\t\tdecode_fsinfo_maxsz)\n#define NFS4_enc_lock_sz        (compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_lock_maxsz)\n#define NFS4_dec_lock_sz        (compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_lock_maxsz)\n#define NFS4_enc_lockt_sz       (compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_lockt_maxsz)\n#define NFS4_dec_lockt_sz       (compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t decode_lockt_maxsz)\n#define NFS4_enc_locku_sz       (compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_locku_maxsz)\n#define NFS4_dec_locku_sz       (compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_locku_maxsz)\n#define NFS4_enc_access_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_access_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_access_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_access_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_getattr_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_getattr_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_lookup_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_lookup_maxsz + \\\n\t\t\t\tencode_getattr_maxsz + \\\n\t\t\t\tencode_getfh_maxsz)\n#define NFS4_dec_lookup_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_lookup_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz + \\\n\t\t\t\tdecode_getfh_maxsz)\n#define NFS4_enc_lookup_root_sz (compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putrootfh_maxsz + \\\n\t\t\t\tencode_getattr_maxsz + \\\n\t\t\t\tencode_getfh_maxsz)\n#define NFS4_dec_lookup_root_sz (compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putrootfh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz + \\\n\t\t\t\tdecode_getfh_maxsz)\n#define NFS4_enc_remove_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_remove_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_remove_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\top_decode_hdr_maxsz + 5 + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_rename_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_savefh_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_rename_maxsz + \\\n\t\t\t\tencode_getattr_maxsz + \\\n\t\t\t\tencode_restorefh_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_rename_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_savefh_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_rename_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz + \\\n\t\t\t\tdecode_restorefh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_link_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_savefh_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_link_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz + \\\n\t\t\t\tencode_restorefh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_dec_link_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_savefh_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_link_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz + \\\n\t\t\t\tdecode_restorefh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_symlink_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_symlink_maxsz + \\\n\t\t\t\tencode_getattr_maxsz + \\\n\t\t\t\tencode_getfh_maxsz)\n#define NFS4_dec_symlink_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_symlink_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz + \\\n\t\t\t\tdecode_getfh_maxsz)\n#define NFS4_enc_create_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_savefh_maxsz + \\\n\t\t\t\tencode_create_maxsz + \\\n\t\t\t\tencode_getfh_maxsz + \\\n\t\t\t\tencode_getattr_maxsz + \\\n\t\t\t\tencode_restorefh_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_create_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_savefh_maxsz + \\\n\t\t\t\tdecode_create_maxsz + \\\n\t\t\t\tdecode_getfh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz + \\\n\t\t\t\tdecode_restorefh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_pathconf_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_pathconf_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_statfs_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_statfs_maxsz)\n#define NFS4_dec_statfs_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_statfs_maxsz)\n#define NFS4_enc_server_caps_sz (compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_server_caps_sz (compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_delegreturn_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_delegreturn_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_delegreturn_sz (compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_delegreturn_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_getacl_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_getacl_maxsz)\n#define NFS4_dec_getacl_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_getacl_maxsz)\n#define NFS4_enc_setacl_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_setacl_maxsz)\n#define NFS4_dec_setacl_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_setacl_maxsz)\n#define NFS4_enc_fs_locations_sz \\\n\t\t\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t encode_lookup_maxsz + \\\n\t\t\t\t encode_fs_locations_maxsz)\n#define NFS4_dec_fs_locations_sz \\\n\t\t\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t decode_lookup_maxsz + \\\n\t\t\t\t decode_fs_locations_maxsz)\n\nstatic struct {\n\tunsigned int\tmode;\n\tunsigned int\tnfs2type;\n} nfs_type2fmt[] = {\n\t{ 0,\t\tNFNON\t     },\n\t{ S_IFREG,\tNFREG\t     },\n\t{ S_IFDIR,\tNFDIR\t     },\n\t{ S_IFBLK,\tNFBLK\t     },\n\t{ S_IFCHR,\tNFCHR\t     },\n\t{ S_IFLNK,\tNFLNK\t     },\n\t{ S_IFSOCK,\tNFSOCK\t     },\n\t{ S_IFIFO,\tNFFIFO\t     },\n\t{ 0,\t\tNFNON\t     },\n\t{ 0,\t\tNFNON\t     },\n};\n\nstruct compound_hdr {\n\tint32_t\t\tstatus;\n\tuint32_t\tnops;\n\tuint32_t\ttaglen;\n\tchar *\t\ttag;\n};\n\n/*\n * START OF \"GENERIC\" ENCODE ROUTINES.\n *   These may look a little ugly since they are imported from a \"generic\"\n * set of XDR encode/decode routines which are intended to be shared by\n * all of our NFSv4 implementations (OpenBSD, MacOS X...).\n *\n * If the pain of reading these is too great, it should be a straightforward\n * task to translate them into Linux-specific versions which are more\n * consistent with the style used in NFSv2/v3...\n */\n#define WRITE32(n)               *p++ = htonl(n)\n#define WRITE64(n)               do {\t\t\t\t\\\n\t*p++ = htonl((uint32_t)((n) >> 32));\t\t\t\t\\\n\t*p++ = htonl((uint32_t)(n));\t\t\t\t\t\\\n} while (0)\n#define WRITEMEM(ptr,nbytes)     do {\t\t\t\t\\\n\tp = xdr_encode_opaque_fixed(p, ptr, nbytes);\t\t\\\n} while (0)\n\n#define RESERVE_SPACE(nbytes)\tdo {\t\t\t\t\\\n\tp = xdr_reserve_space(xdr, nbytes);\t\t\t\\\n\tBUG_ON(!p);\t\t\t\t\t\t\\\n} while (0)\n\nstatic void encode_string(struct xdr_stream *xdr, unsigned int len, const char *str)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4 + len);\n\tBUG_ON(p == NULL);\n\txdr_encode_opaque(p, str, len);\n}\n\nstatic int encode_compound_hdr(struct xdr_stream *xdr, struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tdprintk(\"encode_compound: tag=%.*s\\n\", (int)hdr->taglen, hdr->tag);\n\tBUG_ON(hdr->taglen > NFS4_MAXTAGLEN);\n\tRESERVE_SPACE(12+(XDR_QUADLEN(hdr->taglen)<<2));\n\tWRITE32(hdr->taglen);\n\tWRITEMEM(hdr->tag, hdr->taglen);\n\tWRITE32(NFS4_MINOR_VERSION);\n\tWRITE32(hdr->nops);\n\treturn 0;\n}\n\nstatic void encode_nfs4_verifier(struct xdr_stream *xdr, const nfs4_verifier *verf)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, NFS4_VERIFIER_SIZE);\n\tBUG_ON(p == NULL);\n\txdr_encode_opaque_fixed(p, verf->data, NFS4_VERIFIER_SIZE);\n}\n\nstatic int encode_attrs(struct xdr_stream *xdr, const struct iattr *iap, const struct nfs_server *server)\n{\n\tchar owner_name[IDMAP_NAMESZ];\n\tchar owner_group[IDMAP_NAMESZ];\n\tint owner_namelen = 0;\n\tint owner_grouplen = 0;\n\t__be32 *p;\n\t__be32 *q;\n\tint len;\n\tuint32_t bmval0 = 0;\n\tuint32_t bmval1 = 0;\n\tint status;\n\n\t/*\n\t * We reserve enough space to write the entire attribute buffer at once.\n\t * In the worst-case, this would be\n\t *   12(bitmap) + 4(attrlen) + 8(size) + 4(mode) + 4(atime) + 4(mtime)\n\t *          = 36 bytes, plus any contribution from variable-length fields\n\t *            such as owner/group.\n\t */\n\tlen = 16;\n\n\t/* Sigh */\n\tif (iap->ia_valid & ATTR_SIZE)\n\t\tlen += 8;\n\tif (iap->ia_valid & ATTR_MODE)\n\t\tlen += 4;\n\tif (iap->ia_valid & ATTR_UID) {\n\t\towner_namelen = nfs_map_uid_to_name(server->nfs_client, iap->ia_uid, owner_name);\n\t\tif (owner_namelen < 0) {\n\t\t\tdprintk(\"nfs: couldn't resolve uid %d to string\\n\",\n\t\t\t\t\tiap->ia_uid);\n\t\t\t/* XXX */\n\t\t\tstrcpy(owner_name, \"nobody\");\n\t\t\towner_namelen = sizeof(\"nobody\") - 1;\n\t\t\t/* goto out; */\n\t\t}\n\t\tlen += 4 + (XDR_QUADLEN(owner_namelen) << 2);\n\t}\n\tif (iap->ia_valid & ATTR_GID) {\n\t\towner_grouplen = nfs_map_gid_to_group(server->nfs_client, iap->ia_gid, owner_group);\n\t\tif (owner_grouplen < 0) {\n\t\t\tdprintk(\"nfs: couldn't resolve gid %d to string\\n\",\n\t\t\t\t\tiap->ia_gid);\n\t\t\tstrcpy(owner_group, \"nobody\");\n\t\t\towner_grouplen = sizeof(\"nobody\") - 1;\n\t\t\t/* goto out; */\n\t\t}\n\t\tlen += 4 + (XDR_QUADLEN(owner_grouplen) << 2);\n\t}\n\tif (iap->ia_valid & ATTR_ATIME_SET)\n\t\tlen += 16;\n\telse if (iap->ia_valid & ATTR_ATIME)\n\t\tlen += 4;\n\tif (iap->ia_valid & ATTR_MTIME_SET)\n\t\tlen += 16;\n\telse if (iap->ia_valid & ATTR_MTIME)\n\t\tlen += 4;\n\tRESERVE_SPACE(len);\n\n\t/*\n\t * We write the bitmap length now, but leave the bitmap and the attribute\n\t * buffer length to be backfilled at the end of this routine.\n\t */\n\tWRITE32(2);\n\tq = p;\n\tp += 3;\n\n\tif (iap->ia_valid & ATTR_SIZE) {\n\t\tbmval0 |= FATTR4_WORD0_SIZE;\n\t\tWRITE64(iap->ia_size);\n\t}\n\tif (iap->ia_valid & ATTR_MODE) {\n\t\tbmval1 |= FATTR4_WORD1_MODE;\n\t\tWRITE32(iap->ia_mode & S_IALLUGO);\n\t}\n\tif (iap->ia_valid & ATTR_UID) {\n\t\tbmval1 |= FATTR4_WORD1_OWNER;\n\t\tWRITE32(owner_namelen);\n\t\tWRITEMEM(owner_name, owner_namelen);\n\t}\n\tif (iap->ia_valid & ATTR_GID) {\n\t\tbmval1 |= FATTR4_WORD1_OWNER_GROUP;\n\t\tWRITE32(owner_grouplen);\n\t\tWRITEMEM(owner_group, owner_grouplen);\n\t}\n\tif (iap->ia_valid & ATTR_ATIME_SET) {\n\t\tbmval1 |= FATTR4_WORD1_TIME_ACCESS_SET;\n\t\tWRITE32(NFS4_SET_TO_CLIENT_TIME);\n\t\tWRITE32(0);\n\t\tWRITE32(iap->ia_mtime.tv_sec);\n\t\tWRITE32(iap->ia_mtime.tv_nsec);\n\t}\n\telse if (iap->ia_valid & ATTR_ATIME) {\n\t\tbmval1 |= FATTR4_WORD1_TIME_ACCESS_SET;\n\t\tWRITE32(NFS4_SET_TO_SERVER_TIME);\n\t}\n\tif (iap->ia_valid & ATTR_MTIME_SET) {\n\t\tbmval1 |= FATTR4_WORD1_TIME_MODIFY_SET;\n\t\tWRITE32(NFS4_SET_TO_CLIENT_TIME);\n\t\tWRITE32(0);\n\t\tWRITE32(iap->ia_mtime.tv_sec);\n\t\tWRITE32(iap->ia_mtime.tv_nsec);\n\t}\n\telse if (iap->ia_valid & ATTR_MTIME) {\n\t\tbmval1 |= FATTR4_WORD1_TIME_MODIFY_SET;\n\t\tWRITE32(NFS4_SET_TO_SERVER_TIME);\n\t}\n\t\n\t/*\n\t * Now we backfill the bitmap and the attribute buffer length.\n\t */\n\tif (len != ((char *)p - (char *)q) + 4) {\n\t\tprintk(KERN_ERR \"nfs: Attr length error, %u != %Zu\\n\",\n\t\t\t\tlen, ((char *)p - (char *)q) + 4);\n\t\tBUG();\n\t}\n\tlen = (char *)p - (char *)q - 12;\n\t*q++ = htonl(bmval0);\n\t*q++ = htonl(bmval1);\n\t*q++ = htonl(len);\n\n\tstatus = 0;\n/* out: */\n\treturn status;\n}\n\nstatic int encode_access(struct xdr_stream *xdr, u32 access)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(8);\n\tWRITE32(OP_ACCESS);\n\tWRITE32(access);\n\t\n\treturn 0;\n}\n\nstatic int encode_close(struct xdr_stream *xdr, const struct nfs_closeargs *arg)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(8+NFS4_STATEID_SIZE);\n\tWRITE32(OP_CLOSE);\n\tWRITE32(arg->seqid->sequence->counter);\n\tWRITEMEM(arg->stateid->data, NFS4_STATEID_SIZE);\n\t\n\treturn 0;\n}\n\nstatic int encode_commit(struct xdr_stream *xdr, const struct nfs_writeargs *args)\n{\n\t__be32 *p;\n        \n        RESERVE_SPACE(16);\n        WRITE32(OP_COMMIT);\n        WRITE64(args->offset);\n        WRITE32(args->count);\n\n        return 0;\n}\n\nstatic int encode_create(struct xdr_stream *xdr, const struct nfs4_create_arg *create)\n{\n\t__be32 *p;\n\t\n\tRESERVE_SPACE(8);\n\tWRITE32(OP_CREATE);\n\tWRITE32(create->ftype);\n\n\tswitch (create->ftype) {\n\tcase NF4LNK:\n\t\tRESERVE_SPACE(4);\n\t\tWRITE32(create->u.symlink.len);\n\t\txdr_write_pages(xdr, create->u.symlink.pages, 0, create->u.symlink.len);\n\t\tbreak;\n\n\tcase NF4BLK: case NF4CHR:\n\t\tRESERVE_SPACE(8);\n\t\tWRITE32(create->u.device.specdata1);\n\t\tWRITE32(create->u.device.specdata2);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tRESERVE_SPACE(4 + create->name->len);\n\tWRITE32(create->name->len);\n\tWRITEMEM(create->name->name, create->name->len);\n\n\treturn encode_attrs(xdr, create->attrs, create->server);\n}\n\nstatic int encode_getattr_one(struct xdr_stream *xdr, uint32_t bitmap)\n{\n        __be32 *p;\n\n        RESERVE_SPACE(12);\n        WRITE32(OP_GETATTR);\n        WRITE32(1);\n        WRITE32(bitmap);\n        return 0;\n}\n\nstatic int encode_getattr_two(struct xdr_stream *xdr, uint32_t bm0, uint32_t bm1)\n{\n        __be32 *p;\n\n        RESERVE_SPACE(16);\n        WRITE32(OP_GETATTR);\n        WRITE32(2);\n        WRITE32(bm0);\n        WRITE32(bm1);\n        return 0;\n}\n\nstatic int encode_getfattr(struct xdr_stream *xdr, const u32* bitmask)\n{\n\treturn encode_getattr_two(xdr,\n\t\t\tbitmask[0] & nfs4_fattr_bitmap[0],\n\t\t\tbitmask[1] & nfs4_fattr_bitmap[1]);\n}\n\nstatic int encode_fsinfo(struct xdr_stream *xdr, const u32* bitmask)\n{\n\treturn encode_getattr_two(xdr, bitmask[0] & nfs4_fsinfo_bitmap[0],\n\t\t\tbitmask[1] & nfs4_fsinfo_bitmap[1]);\n}\n\nstatic int encode_fs_locations(struct xdr_stream *xdr, const u32* bitmask)\n{\n\treturn encode_getattr_two(xdr,\n\t\t\t\t  bitmask[0] & nfs4_fs_locations_bitmap[0],\n\t\t\t\t  bitmask[1] & nfs4_fs_locations_bitmap[1]);\n}\n\nstatic int encode_getfh(struct xdr_stream *xdr)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4);\n\tWRITE32(OP_GETFH);\n\n\treturn 0;\n}\n\nstatic int encode_link(struct xdr_stream *xdr, const struct qstr *name)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(8 + name->len);\n\tWRITE32(OP_LINK);\n\tWRITE32(name->len);\n\tWRITEMEM(name->name, name->len);\n\t\n\treturn 0;\n}\n\nstatic inline int nfs4_lock_type(struct file_lock *fl, int block)\n{\n\tif ((fl->fl_type & (F_RDLCK|F_WRLCK|F_UNLCK)) == F_RDLCK)\n\t\treturn block ? NFS4_READW_LT : NFS4_READ_LT;\n\treturn block ? NFS4_WRITEW_LT : NFS4_WRITE_LT;\n}\n\nstatic inline uint64_t nfs4_lock_length(struct file_lock *fl)\n{\n\tif (fl->fl_end == OFFSET_MAX)\n\t\treturn ~(uint64_t)0;\n\treturn fl->fl_end - fl->fl_start + 1;\n}\n\n/*\n * opcode,type,reclaim,offset,length,new_lock_owner = 32\n * open_seqid,open_stateid,lock_seqid,lock_owner.clientid, lock_owner.id = 40\n */\nstatic int encode_lock(struct xdr_stream *xdr, const struct nfs_lock_args *args)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(32);\n\tWRITE32(OP_LOCK);\n\tWRITE32(nfs4_lock_type(args->fl, args->block));\n\tWRITE32(args->reclaim);\n\tWRITE64(args->fl->fl_start);\n\tWRITE64(nfs4_lock_length(args->fl));\n\tWRITE32(args->new_lock_owner);\n\tif (args->new_lock_owner){\n\t\tRESERVE_SPACE(4+NFS4_STATEID_SIZE+32);\n\t\tWRITE32(args->open_seqid->sequence->counter);\n\t\tWRITEMEM(args->open_stateid->data, NFS4_STATEID_SIZE);\n\t\tWRITE32(args->lock_seqid->sequence->counter);\n\t\tWRITE64(args->lock_owner.clientid);\n\t\tWRITE32(16);\n\t\tWRITEMEM(\"lock id:\", 8);\n\t\tWRITE64(args->lock_owner.id);\n\t}\n\telse {\n\t\tRESERVE_SPACE(NFS4_STATEID_SIZE+4);\n\t\tWRITEMEM(args->lock_stateid->data, NFS4_STATEID_SIZE);\n\t\tWRITE32(args->lock_seqid->sequence->counter);\n\t}\n\n\treturn 0;\n}\n\nstatic int encode_lockt(struct xdr_stream *xdr, const struct nfs_lockt_args *args)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(52);\n\tWRITE32(OP_LOCKT);\n\tWRITE32(nfs4_lock_type(args->fl, 0));\n\tWRITE64(args->fl->fl_start);\n\tWRITE64(nfs4_lock_length(args->fl));\n\tWRITE64(args->lock_owner.clientid);\n\tWRITE32(16);\n\tWRITEMEM(\"lock id:\", 8);\n\tWRITE64(args->lock_owner.id);\n\n\treturn 0;\n}\n\nstatic int encode_locku(struct xdr_stream *xdr, const struct nfs_locku_args *args)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(12+NFS4_STATEID_SIZE+16);\n\tWRITE32(OP_LOCKU);\n\tWRITE32(nfs4_lock_type(args->fl, 0));\n\tWRITE32(args->seqid->sequence->counter);\n\tWRITEMEM(args->stateid->data, NFS4_STATEID_SIZE);\n\tWRITE64(args->fl->fl_start);\n\tWRITE64(nfs4_lock_length(args->fl));\n\n\treturn 0;\n}\n\nstatic int encode_lookup(struct xdr_stream *xdr, const struct qstr *name)\n{\n\tint len = name->len;\n\t__be32 *p;\n\n\tRESERVE_SPACE(8 + len);\n\tWRITE32(OP_LOOKUP);\n\tWRITE32(len);\n\tWRITEMEM(name->name, len);\n\n\treturn 0;\n}\n\nstatic void encode_share_access(struct xdr_stream *xdr, int open_flags)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(8);\n\tswitch (open_flags & (FMODE_READ|FMODE_WRITE)) {\n\t\tcase FMODE_READ:\n\t\t\tWRITE32(NFS4_SHARE_ACCESS_READ);\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tWRITE32(NFS4_SHARE_ACCESS_WRITE);\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tWRITE32(NFS4_SHARE_ACCESS_BOTH);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\tWRITE32(0);\t\t/* for linux, share_deny = 0 always */\n}\n\nstatic inline void encode_openhdr(struct xdr_stream *xdr, const struct nfs_openargs *arg)\n{\n\t__be32 *p;\n /*\n * opcode 4, seqid 4, share_access 4, share_deny 4, clientid 8, ownerlen 4,\n * owner 4 = 32\n */\n\tRESERVE_SPACE(8);\n\tWRITE32(OP_OPEN);\n\tWRITE32(arg->seqid->sequence->counter);\n\tencode_share_access(xdr, arg->open_flags);\n\tRESERVE_SPACE(28);\n\tWRITE64(arg->clientid);\n\tWRITE32(16);\n\tWRITEMEM(\"open id:\", 8);\n\tWRITE64(arg->id);\n}\n\nstatic inline void encode_createmode(struct xdr_stream *xdr, const struct nfs_openargs *arg)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4);\n\tswitch(arg->open_flags & O_EXCL) {\n\t\tcase 0:\n\t\t\tWRITE32(NFS4_CREATE_UNCHECKED);\n\t\t\tencode_attrs(xdr, arg->u.attrs, arg->server);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWRITE32(NFS4_CREATE_EXCLUSIVE);\n\t\t\tencode_nfs4_verifier(xdr, &arg->u.verifier);\n\t}\n}\n\nstatic void encode_opentype(struct xdr_stream *xdr, const struct nfs_openargs *arg)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4);\n\tswitch (arg->open_flags & O_CREAT) {\n\t\tcase 0:\n\t\t\tWRITE32(NFS4_OPEN_NOCREATE);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG_ON(arg->claim != NFS4_OPEN_CLAIM_NULL);\n\t\t\tWRITE32(NFS4_OPEN_CREATE);\n\t\t\tencode_createmode(xdr, arg);\n\t}\n}\n\nstatic inline void encode_delegation_type(struct xdr_stream *xdr, fmode_t delegation_type)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4);\n\tswitch (delegation_type) {\n\t\tcase 0:\n\t\t\tWRITE32(NFS4_OPEN_DELEGATE_NONE);\n\t\t\tbreak;\n\t\tcase FMODE_READ:\n\t\t\tWRITE32(NFS4_OPEN_DELEGATE_READ);\n\t\t\tbreak;\n\t\tcase FMODE_WRITE|FMODE_READ:\n\t\t\tWRITE32(NFS4_OPEN_DELEGATE_WRITE);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n}\n\nstatic inline void encode_claim_null(struct xdr_stream *xdr, const struct qstr *name)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4);\n\tWRITE32(NFS4_OPEN_CLAIM_NULL);\n\tencode_string(xdr, name->len, name->name);\n}\n\nstatic inline void encode_claim_previous(struct xdr_stream *xdr, fmode_t type)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4);\n\tWRITE32(NFS4_OPEN_CLAIM_PREVIOUS);\n\tencode_delegation_type(xdr, type);\n}\n\nstatic inline void encode_claim_delegate_cur(struct xdr_stream *xdr, const struct qstr *name, const nfs4_stateid *stateid)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4+NFS4_STATEID_SIZE);\n\tWRITE32(NFS4_OPEN_CLAIM_DELEGATE_CUR);\n\tWRITEMEM(stateid->data, NFS4_STATEID_SIZE);\n\tencode_string(xdr, name->len, name->name);\n}\n\nstatic int encode_open(struct xdr_stream *xdr, const struct nfs_openargs *arg)\n{\n\tencode_openhdr(xdr, arg);\n\tencode_opentype(xdr, arg);\n\tswitch (arg->claim) {\n\t\tcase NFS4_OPEN_CLAIM_NULL:\n\t\t\tencode_claim_null(xdr, arg->name);\n\t\t\tbreak;\n\t\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\t\t\tencode_claim_previous(xdr, arg->u.delegation_type);\n\t\t\tbreak;\n\t\tcase NFS4_OPEN_CLAIM_DELEGATE_CUR:\n\t\t\tencode_claim_delegate_cur(xdr, arg->name, &arg->u.delegation);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\treturn 0;\n}\n\nstatic int encode_open_confirm(struct xdr_stream *xdr, const struct nfs_open_confirmargs *arg)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4+NFS4_STATEID_SIZE+4);\n\tWRITE32(OP_OPEN_CONFIRM);\n\tWRITEMEM(arg->stateid->data, NFS4_STATEID_SIZE);\n\tWRITE32(arg->seqid->sequence->counter);\n\n\treturn 0;\n}\n\nstatic int encode_open_downgrade(struct xdr_stream *xdr, const struct nfs_closeargs *arg)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4+NFS4_STATEID_SIZE+4);\n\tWRITE32(OP_OPEN_DOWNGRADE);\n\tWRITEMEM(arg->stateid->data, NFS4_STATEID_SIZE);\n\tWRITE32(arg->seqid->sequence->counter);\n\tencode_share_access(xdr, arg->open_flags);\n\treturn 0;\n}\n\nstatic int\nencode_putfh(struct xdr_stream *xdr, const struct nfs_fh *fh)\n{\n\tint len = fh->size;\n\t__be32 *p;\n\n\tRESERVE_SPACE(8 + len);\n\tWRITE32(OP_PUTFH);\n\tWRITE32(len);\n\tWRITEMEM(fh->data, len);\n\n\treturn 0;\n}\n\nstatic int encode_putrootfh(struct xdr_stream *xdr)\n{\n        __be32 *p;\n        \n        RESERVE_SPACE(4);\n        WRITE32(OP_PUTROOTFH);\n\n        return 0;\n}\n\nstatic void encode_stateid(struct xdr_stream *xdr, const struct nfs_open_context *ctx)\n{\n\tnfs4_stateid stateid;\n\t__be32 *p;\n\n\tRESERVE_SPACE(NFS4_STATEID_SIZE);\n\tif (ctx->state != NULL) {\n\t\tnfs4_copy_stateid(&stateid, ctx->state, ctx->lockowner);\n\t\tWRITEMEM(stateid.data, NFS4_STATEID_SIZE);\n\t} else\n\t\tWRITEMEM(zero_stateid.data, NFS4_STATEID_SIZE);\n}\n\nstatic int encode_read(struct xdr_stream *xdr, const struct nfs_readargs *args)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4);\n\tWRITE32(OP_READ);\n\n\tencode_stateid(xdr, args->context);\n\n\tRESERVE_SPACE(12);\n\tWRITE64(args->offset);\n\tWRITE32(args->count);\n\n\treturn 0;\n}\n\nstatic int encode_readdir(struct xdr_stream *xdr, const struct nfs4_readdir_arg *readdir, struct rpc_rqst *req)\n{\n\tuint32_t attrs[2] = {\n\t\tFATTR4_WORD0_RDATTR_ERROR|FATTR4_WORD0_FILEID,\n\t\tFATTR4_WORD1_MOUNTED_ON_FILEID,\n\t};\n\t__be32 *p;\n\n\tRESERVE_SPACE(12+NFS4_VERIFIER_SIZE+20);\n\tWRITE32(OP_READDIR);\n\tWRITE64(readdir->cookie);\n\tWRITEMEM(readdir->verifier.data, NFS4_VERIFIER_SIZE);\n\tWRITE32(readdir->count >> 1);  /* We're not doing readdirplus */\n\tWRITE32(readdir->count);\n\tWRITE32(2);\n\t/* Switch to mounted_on_fileid if the server supports it */\n\tif (readdir->bitmask[1] & FATTR4_WORD1_MOUNTED_ON_FILEID)\n\t\tattrs[0] &= ~FATTR4_WORD0_FILEID;\n\telse\n\t\tattrs[1] &= ~FATTR4_WORD1_MOUNTED_ON_FILEID;\n\tWRITE32(attrs[0] & readdir->bitmask[0]);\n\tWRITE32(attrs[1] & readdir->bitmask[1]);\n\tdprintk(\"%s: cookie = %Lu, verifier = %08x:%08x, bitmap = %08x:%08x\\n\",\n\t\t\t__func__,\n\t\t\t(unsigned long long)readdir->cookie,\n\t\t\t((u32 *)readdir->verifier.data)[0],\n\t\t\t((u32 *)readdir->verifier.data)[1],\n\t\t\tattrs[0] & readdir->bitmask[0],\n\t\t\tattrs[1] & readdir->bitmask[1]);\n\n\treturn 0;\n}\n\nstatic int encode_readlink(struct xdr_stream *xdr, const struct nfs4_readlink *readlink, struct rpc_rqst *req)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4);\n\tWRITE32(OP_READLINK);\n\n\treturn 0;\n}\n\nstatic int encode_remove(struct xdr_stream *xdr, const struct qstr *name)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(8 + name->len);\n\tWRITE32(OP_REMOVE);\n\tWRITE32(name->len);\n\tWRITEMEM(name->name, name->len);\n\n\treturn 0;\n}\n\nstatic int encode_rename(struct xdr_stream *xdr, const struct qstr *oldname, const struct qstr *newname)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(8 + oldname->len);\n\tWRITE32(OP_RENAME);\n\tWRITE32(oldname->len);\n\tWRITEMEM(oldname->name, oldname->len);\n\t\n\tRESERVE_SPACE(4 + newname->len);\n\tWRITE32(newname->len);\n\tWRITEMEM(newname->name, newname->len);\n\n\treturn 0;\n}\n\nstatic int encode_renew(struct xdr_stream *xdr, const struct nfs_client *client_stateid)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(12);\n\tWRITE32(OP_RENEW);\n\tWRITE64(client_stateid->cl_clientid);\n\n\treturn 0;\n}\n\nstatic int\nencode_restorefh(struct xdr_stream *xdr)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4);\n\tWRITE32(OP_RESTOREFH);\n\n\treturn 0;\n}\n\nstatic int\nencode_setacl(struct xdr_stream *xdr, struct nfs_setaclargs *arg)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4+NFS4_STATEID_SIZE);\n\tWRITE32(OP_SETATTR);\n\tWRITEMEM(zero_stateid.data, NFS4_STATEID_SIZE);\n\tRESERVE_SPACE(2*4);\n\tWRITE32(1);\n\tWRITE32(FATTR4_WORD0_ACL);\n\tif (arg->acl_len % 4)\n\t\treturn -EINVAL;\n\tRESERVE_SPACE(4);\n\tWRITE32(arg->acl_len);\n\txdr_write_pages(xdr, arg->acl_pages, arg->acl_pgbase, arg->acl_len);\n\treturn 0;\n}\n\nstatic int\nencode_savefh(struct xdr_stream *xdr)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4);\n\tWRITE32(OP_SAVEFH);\n\n\treturn 0;\n}\n\nstatic int encode_setattr(struct xdr_stream *xdr, const struct nfs_setattrargs *arg, const struct nfs_server *server)\n{\n\tint status;\n\t__be32 *p;\n\t\n        RESERVE_SPACE(4+NFS4_STATEID_SIZE);\n        WRITE32(OP_SETATTR);\n\tWRITEMEM(arg->stateid.data, NFS4_STATEID_SIZE);\n\n        if ((status = encode_attrs(xdr, arg->iap, server)))\n\t\treturn status;\n\n        return 0;\n}\n\nstatic int encode_setclientid(struct xdr_stream *xdr, const struct nfs4_setclientid *setclientid)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4 + NFS4_VERIFIER_SIZE);\n\tWRITE32(OP_SETCLIENTID);\n\tWRITEMEM(setclientid->sc_verifier->data, NFS4_VERIFIER_SIZE);\n\n\tencode_string(xdr, setclientid->sc_name_len, setclientid->sc_name);\n\tRESERVE_SPACE(4);\n\tWRITE32(setclientid->sc_prog);\n\tencode_string(xdr, setclientid->sc_netid_len, setclientid->sc_netid);\n\tencode_string(xdr, setclientid->sc_uaddr_len, setclientid->sc_uaddr);\n\tRESERVE_SPACE(4);\n\tWRITE32(setclientid->sc_cb_ident);\n\n\treturn 0;\n}\n\nstatic int encode_setclientid_confirm(struct xdr_stream *xdr, const struct nfs_client *client_state)\n{\n        __be32 *p;\n\n        RESERVE_SPACE(12 + NFS4_VERIFIER_SIZE);\n        WRITE32(OP_SETCLIENTID_CONFIRM);\n        WRITE64(client_state->cl_clientid);\n        WRITEMEM(client_state->cl_confirm.data, NFS4_VERIFIER_SIZE);\n\n        return 0;\n}\n\nstatic int encode_write(struct xdr_stream *xdr, const struct nfs_writeargs *args)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4);\n\tWRITE32(OP_WRITE);\n\n\tencode_stateid(xdr, args->context);\n\n\tRESERVE_SPACE(16);\n\tWRITE64(args->offset);\n\tWRITE32(args->stable);\n\tWRITE32(args->count);\n\n\txdr_write_pages(xdr, args->pages, args->pgbase, args->count);\n\n\treturn 0;\n}\n\nstatic int encode_delegreturn(struct xdr_stream *xdr, const nfs4_stateid *stateid)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4+NFS4_STATEID_SIZE);\n\n\tWRITE32(OP_DELEGRETURN);\n\tWRITEMEM(stateid->data, NFS4_STATEID_SIZE);\n\treturn 0;\n\n}\n/*\n * END OF \"GENERIC\" ENCODE ROUTINES.\n */\n\n/*\n * Encode an ACCESS request\n */\nstatic int nfs4_xdr_enc_access(struct rpc_rqst *req, __be32 *p, const struct nfs4_accessargs *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 3,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fh);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = encode_access(&xdr, args->access);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = encode_getfattr(&xdr, args->bitmask);\nout:\n\treturn status;\n}\n\n/*\n * Encode LOOKUP request\n */\nstatic int nfs4_xdr_enc_lookup(struct rpc_rqst *req, __be32 *p, const struct nfs4_lookup_arg *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 4,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tif ((status = encode_putfh(&xdr, args->dir_fh)) != 0)\n\t\tgoto out;\n\tif ((status = encode_lookup(&xdr, args->name)) != 0)\n\t\tgoto out;\n\tif ((status = encode_getfh(&xdr)) != 0)\n\t\tgoto out;\n\tstatus = encode_getfattr(&xdr, args->bitmask);\nout:\n\treturn status;\n}\n\n/*\n * Encode LOOKUP_ROOT request\n */\nstatic int nfs4_xdr_enc_lookup_root(struct rpc_rqst *req, __be32 *p, const struct nfs4_lookup_root_arg *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 3,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tif ((status = encode_putrootfh(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = encode_getfh(&xdr)) == 0)\n\t\tstatus = encode_getfattr(&xdr, args->bitmask);\nout:\n\treturn status;\n}\n\n/*\n * Encode REMOVE request\n */\nstatic int nfs4_xdr_enc_remove(struct rpc_rqst *req, __be32 *p, const struct nfs_removeargs *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 3,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tif ((status = encode_putfh(&xdr, args->fh)) != 0)\n\t\tgoto out;\n\tif ((status = encode_remove(&xdr, &args->name)) != 0)\n\t\tgoto out;\n\tstatus = encode_getfattr(&xdr, args->bitmask);\nout:\n\treturn status;\n}\n\n/*\n * Encode RENAME request\n */\nstatic int nfs4_xdr_enc_rename(struct rpc_rqst *req, __be32 *p, const struct nfs4_rename_arg *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 7,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tif ((status = encode_putfh(&xdr, args->old_dir)) != 0)\n\t\tgoto out;\n\tif ((status = encode_savefh(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = encode_putfh(&xdr, args->new_dir)) != 0)\n\t\tgoto out;\n\tif ((status = encode_rename(&xdr, args->old_name, args->new_name)) != 0)\n\t\tgoto out;\n\tif ((status = encode_getfattr(&xdr, args->bitmask)) != 0)\n\t\tgoto out;\n\tif ((status = encode_restorefh(&xdr)) != 0)\n\t\tgoto out;\n\tstatus = encode_getfattr(&xdr, args->bitmask);\nout:\n\treturn status;\n}\n\n/*\n * Encode LINK request\n */\nstatic int nfs4_xdr_enc_link(struct rpc_rqst *req, __be32 *p, const struct nfs4_link_arg *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 7,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tif ((status = encode_putfh(&xdr, args->fh)) != 0)\n\t\tgoto out;\n\tif ((status = encode_savefh(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = encode_putfh(&xdr, args->dir_fh)) != 0)\n\t\tgoto out;\n\tif ((status = encode_link(&xdr, args->name)) != 0)\n\t\tgoto out;\n\tif ((status = encode_getfattr(&xdr, args->bitmask)) != 0)\n\t\tgoto out;\n\tif ((status = encode_restorefh(&xdr)) != 0)\n\t\tgoto out;\n\tstatus = encode_getfattr(&xdr, args->bitmask);\nout:\n\treturn status;\n}\n\n/*\n * Encode CREATE request\n */\nstatic int nfs4_xdr_enc_create(struct rpc_rqst *req, __be32 *p, const struct nfs4_create_arg *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 7,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tif ((status = encode_putfh(&xdr, args->dir_fh)) != 0)\n\t\tgoto out;\n\tif ((status = encode_savefh(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = encode_create(&xdr, args)) != 0)\n\t\tgoto out;\n\tif ((status = encode_getfh(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = encode_getfattr(&xdr, args->bitmask)) != 0)\n\t\tgoto out;\n\tif ((status = encode_restorefh(&xdr)) != 0)\n\t\tgoto out;\n\tstatus = encode_getfattr(&xdr, args->bitmask);\nout:\n\treturn status;\n}\n\n/*\n * Encode SYMLINK request\n */\nstatic int nfs4_xdr_enc_symlink(struct rpc_rqst *req, __be32 *p, const struct nfs4_create_arg *args)\n{\n\treturn nfs4_xdr_enc_create(req, p, args);\n}\n\n/*\n * Encode GETATTR request\n */\nstatic int nfs4_xdr_enc_getattr(struct rpc_rqst *req, __be32 *p, const struct nfs4_getattr_arg *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 2,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tif ((status = encode_putfh(&xdr, args->fh)) == 0)\n\t\tstatus = encode_getfattr(&xdr, args->bitmask);\n\treturn status;\n}\n\n/*\n * Encode a CLOSE request\n */\nstatic int nfs4_xdr_enc_close(struct rpc_rqst *req, __be32 *p, struct nfs_closeargs *args)\n{\n        struct xdr_stream xdr;\n        struct compound_hdr hdr = {\n                .nops   = 3,\n        };\n        int status;\n\n        xdr_init_encode(&xdr, &req->rq_snd_buf, p);\n        encode_compound_hdr(&xdr, &hdr);\n        status = encode_putfh(&xdr, args->fh);\n        if(status)\n                goto out;\n        status = encode_close(&xdr, args);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = encode_getfattr(&xdr, args->bitmask);\nout:\n        return status;\n}\n\n/*\n * Encode an OPEN request\n */\nstatic int nfs4_xdr_enc_open(struct rpc_rqst *req, __be32 *p, struct nfs_openargs *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 7,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fh);\n\tif (status)\n\t\tgoto out;\n\tstatus = encode_savefh(&xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = encode_open(&xdr, args);\n\tif (status)\n\t\tgoto out;\n\tstatus = encode_getfh(&xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = encode_getfattr(&xdr, args->bitmask);\n\tif (status)\n\t\tgoto out;\n\tstatus = encode_restorefh(&xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = encode_getfattr(&xdr, args->bitmask);\nout:\n\treturn status;\n}\n\n/*\n * Encode an OPEN_CONFIRM request\n */\nstatic int nfs4_xdr_enc_open_confirm(struct rpc_rqst *req, __be32 *p, struct nfs_open_confirmargs *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops   = 2,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fh);\n\tif(status)\n\t\tgoto out;\n\tstatus = encode_open_confirm(&xdr, args);\nout:\n\treturn status;\n}\n\n/*\n * Encode an OPEN request with no attributes.\n */\nstatic int nfs4_xdr_enc_open_noattr(struct rpc_rqst *req, __be32 *p, struct nfs_openargs *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops   = 3,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fh);\n\tif (status)\n\t\tgoto out;\n\tstatus = encode_open(&xdr, args);\n\tif (status)\n\t\tgoto out;\n\tstatus = encode_getfattr(&xdr, args->bitmask);\nout:\n\treturn status;\n}\n\n/*\n * Encode an OPEN_DOWNGRADE request\n */\nstatic int nfs4_xdr_enc_open_downgrade(struct rpc_rqst *req, __be32 *p, struct nfs_closeargs *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops\t= 3,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fh);\n\tif (status)\n\t\tgoto out;\n\tstatus = encode_open_downgrade(&xdr, args);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = encode_getfattr(&xdr, args->bitmask);\nout:\n\treturn status;\n}\n\n/*\n * Encode a LOCK request\n */\nstatic int nfs4_xdr_enc_lock(struct rpc_rqst *req, __be32 *p, struct nfs_lock_args *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops   = 2,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fh);\n\tif(status)\n\t\tgoto out;\n\tstatus = encode_lock(&xdr, args);\nout:\n\treturn status;\n}\n\n/*\n * Encode a LOCKT request\n */\nstatic int nfs4_xdr_enc_lockt(struct rpc_rqst *req, __be32 *p, struct nfs_lockt_args *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops   = 2,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fh);\n\tif(status)\n\t\tgoto out;\n\tstatus = encode_lockt(&xdr, args);\nout:\n\treturn status;\n}\n\n/*\n * Encode a LOCKU request\n */\nstatic int nfs4_xdr_enc_locku(struct rpc_rqst *req, __be32 *p, struct nfs_locku_args *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops   = 2,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fh);\n\tif(status)\n\t\tgoto out;\n\tstatus = encode_locku(&xdr, args);\nout:\n\treturn status;\n}\n\n/*\n * Encode a READLINK request\n */\nstatic int nfs4_xdr_enc_readlink(struct rpc_rqst *req, __be32 *p, const struct nfs4_readlink *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 2,\n\t};\n\tstruct rpc_auth *auth = req->rq_task->tk_msg.rpc_cred->cr_auth;\n\tunsigned int replen;\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fh);\n\tif(status)\n\t\tgoto out;\n\tstatus = encode_readlink(&xdr, args, req);\n\n\t/* set up reply kvec\n\t *    toplevel_status + taglen + rescount + OP_PUTFH + status\n\t *      + OP_READLINK + status + string length = 8\n\t */\n\treplen = (RPC_REPHDRSIZE + auth->au_rslack + NFS4_dec_readlink_sz) << 2;\n\txdr_inline_pages(&req->rq_rcv_buf, replen, args->pages,\n\t\t\targs->pgbase, args->pglen);\n\nout:\n\treturn status;\n}\n\n/*\n * Encode a READDIR request\n */\nstatic int nfs4_xdr_enc_readdir(struct rpc_rqst *req, __be32 *p, const struct nfs4_readdir_arg *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 2,\n\t};\n\tstruct rpc_auth *auth = req->rq_task->tk_msg.rpc_cred->cr_auth;\n\tint replen;\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fh);\n\tif(status)\n\t\tgoto out;\n\tstatus = encode_readdir(&xdr, args, req);\n\n\t/* set up reply kvec\n\t *    toplevel_status + taglen + rescount + OP_PUTFH + status\n\t *      + OP_READDIR + status + verifer(2)  = 9\n\t */\n\treplen = (RPC_REPHDRSIZE + auth->au_rslack + NFS4_dec_readdir_sz) << 2;\n\txdr_inline_pages(&req->rq_rcv_buf, replen, args->pages,\n\t\t\t args->pgbase, args->count);\n\tdprintk(\"%s: inlined page args = (%u, %p, %u, %u)\\n\",\n\t\t\t__func__, replen, args->pages,\n\t\t\targs->pgbase, args->count);\n\nout:\n\treturn status;\n}\n\n/*\n * Encode a READ request\n */\nstatic int nfs4_xdr_enc_read(struct rpc_rqst *req, __be32 *p, struct nfs_readargs *args)\n{\n\tstruct rpc_auth *auth = req->rq_task->tk_msg.rpc_cred->cr_auth;\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 2,\n\t};\n\tint replen, status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fh);\n\tif (status)\n\t\tgoto out;\n\tstatus = encode_read(&xdr, args);\n\tif (status)\n\t\tgoto out;\n\n\t/* set up reply kvec\n\t *    toplevel status + taglen=0 + rescount + OP_PUTFH + status\n\t *       + OP_READ + status + eof + datalen = 9\n\t */\n\treplen = (RPC_REPHDRSIZE + auth->au_rslack + NFS4_dec_read_sz) << 2;\n\txdr_inline_pages(&req->rq_rcv_buf, replen,\n\t\t\t args->pages, args->pgbase, args->count);\n\treq->rq_rcv_buf.flags |= XDRBUF_READ;\nout:\n\treturn status;\n}\n\n/*\n * Encode an SETATTR request\n */\nstatic int nfs4_xdr_enc_setattr(struct rpc_rqst *req, __be32 *p, struct nfs_setattrargs *args)\n\n{\n        struct xdr_stream xdr;\n        struct compound_hdr hdr = {\n                .nops   = 3,\n        };\n        int status;\n\n        xdr_init_encode(&xdr, &req->rq_snd_buf, p);\n        encode_compound_hdr(&xdr, &hdr);\n        status = encode_putfh(&xdr, args->fh);\n        if(status)\n                goto out;\n        status = encode_setattr(&xdr, args, args->server);\n        if(status)\n                goto out;\n\tstatus = encode_getfattr(&xdr, args->bitmask);\nout:\n        return status;\n}\n\n/*\n * Encode a GETACL request\n */\nstatic int\nnfs4_xdr_enc_getacl(struct rpc_rqst *req, __be32 *p,\n\t\tstruct nfs_getaclargs *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct rpc_auth *auth = req->rq_task->tk_msg.rpc_cred->cr_auth;\n\tstruct compound_hdr hdr = {\n\t\t.nops   = 2,\n\t};\n\tint replen, status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fh);\n\tif (status)\n\t\tgoto out;\n\tstatus = encode_getattr_two(&xdr, FATTR4_WORD0_ACL, 0);\n\t/* set up reply buffer: */\n\treplen = (RPC_REPHDRSIZE + auth->au_rslack + NFS4_dec_getacl_sz) << 2;\n\txdr_inline_pages(&req->rq_rcv_buf, replen,\n\t\targs->acl_pages, args->acl_pgbase, args->acl_len);\nout:\n\treturn status;\n}\n\n/*\n * Encode a WRITE request\n */\nstatic int nfs4_xdr_enc_write(struct rpc_rqst *req, __be32 *p, struct nfs_writeargs *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 3,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fh);\n\tif (status)\n\t\tgoto out;\n\tstatus = encode_write(&xdr, args);\n\tif (status)\n\t\tgoto out;\n\treq->rq_snd_buf.flags |= XDRBUF_WRITE;\n\tstatus = encode_getfattr(&xdr, args->bitmask);\nout:\n\treturn status;\n}\n\n/*\n *  a COMMIT request\n */\nstatic int nfs4_xdr_enc_commit(struct rpc_rqst *req, __be32 *p, struct nfs_writeargs *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 3,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fh);\n\tif (status)\n\t\tgoto out;\n\tstatus = encode_commit(&xdr, args);\n\tif (status)\n\t\tgoto out;\n\tstatus = encode_getfattr(&xdr, args->bitmask);\nout:\n\treturn status;\n}\n\n/*\n * FSINFO request\n */\nstatic int nfs4_xdr_enc_fsinfo(struct rpc_rqst *req, __be32 *p, struct nfs4_fsinfo_arg *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops\t= 2,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fh);\n\tif (!status)\n\t\tstatus = encode_fsinfo(&xdr, args->bitmask);\n\treturn status;\n}\n\n/*\n * a PATHCONF request\n */\nstatic int nfs4_xdr_enc_pathconf(struct rpc_rqst *req, __be32 *p, const struct nfs4_pathconf_arg *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 2,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fh);\n\tif (!status)\n\t\tstatus = encode_getattr_one(&xdr,\n\t\t\t\targs->bitmask[0] & nfs4_pathconf_bitmap[0]);\n\treturn status;\n}\n\n/*\n * a STATFS request\n */\nstatic int nfs4_xdr_enc_statfs(struct rpc_rqst *req, __be32 *p, const struct nfs4_statfs_arg *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 2,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fh);\n\tif (status == 0)\n\t\tstatus = encode_getattr_two(&xdr,\n\t\t\t\targs->bitmask[0] & nfs4_statfs_bitmap[0],\n\t\t\t\targs->bitmask[1] & nfs4_statfs_bitmap[1]);\n\treturn status;\n}\n\n/*\n * GETATTR_BITMAP request\n */\nstatic int nfs4_xdr_enc_server_caps(struct rpc_rqst *req, __be32 *p, const struct nfs_fh *fhandle)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 2,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, fhandle);\n\tif (status == 0)\n\t\tstatus = encode_getattr_one(&xdr, FATTR4_WORD0_SUPPORTED_ATTRS|\n\t\t\t\tFATTR4_WORD0_LINK_SUPPORT|\n\t\t\t\tFATTR4_WORD0_SYMLINK_SUPPORT|\n\t\t\t\tFATTR4_WORD0_ACLSUPPORT);\n\treturn status;\n}\n\n/*\n * a RENEW request\n */\nstatic int nfs4_xdr_enc_renew(struct rpc_rqst *req, __be32 *p, struct nfs_client *clp)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops\t= 1,\n\t};\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\treturn encode_renew(&xdr, clp);\n}\n\n/*\n * a SETCLIENTID request\n */\nstatic int nfs4_xdr_enc_setclientid(struct rpc_rqst *req, __be32 *p, struct nfs4_setclientid *sc)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops\t= 1,\n\t};\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\treturn encode_setclientid(&xdr, sc);\n}\n\n/*\n * a SETCLIENTID_CONFIRM request\n */\nstatic int nfs4_xdr_enc_setclientid_confirm(struct rpc_rqst *req, __be32 *p, struct nfs_client *clp)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops\t= 3,\n\t};\n\tconst u32 lease_bitmap[2] = { FATTR4_WORD0_LEASE_TIME, 0 };\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_setclientid_confirm(&xdr, clp);\n\tif (!status)\n\t\tstatus = encode_putrootfh(&xdr);\n\tif (!status)\n\t\tstatus = encode_fsinfo(&xdr, lease_bitmap);\n\treturn status;\n}\n\n/*\n * DELEGRETURN request\n */\nstatic int nfs4_xdr_enc_delegreturn(struct rpc_rqst *req, __be32 *p, const struct nfs4_delegreturnargs *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 3,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fhandle);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = encode_delegreturn(&xdr, args->stateid);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = encode_getfattr(&xdr, args->bitmask);\nout:\n\treturn status;\n}\n\n/*\n * Encode FS_LOCATIONS request\n */\nstatic int nfs4_xdr_enc_fs_locations(struct rpc_rqst *req, __be32 *p, struct nfs4_fs_locations_arg *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 3,\n\t};\n\tstruct rpc_auth *auth = req->rq_task->tk_msg.rpc_cred->cr_auth;\n\tint replen;\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tif ((status = encode_putfh(&xdr, args->dir_fh)) != 0)\n\t\tgoto out;\n\tif ((status = encode_lookup(&xdr, args->name)) != 0)\n\t\tgoto out;\n\tif ((status = encode_fs_locations(&xdr, args->bitmask)) != 0)\n\t\tgoto out;\n\t/* set up reply\n\t *   toplevel_status + OP_PUTFH + status\n\t *   + OP_LOOKUP + status + OP_GETATTR + status = 7\n\t */\n\treplen = (RPC_REPHDRSIZE + auth->au_rslack + 7) << 2;\n\txdr_inline_pages(&req->rq_rcv_buf, replen, &args->page,\n\t\t\t0, PAGE_SIZE);\nout:\n\treturn status;\n}\n\n/*\n * START OF \"GENERIC\" DECODE ROUTINES.\n *   These may look a little ugly since they are imported from a \"generic\"\n * set of XDR encode/decode routines which are intended to be shared by\n * all of our NFSv4 implementations (OpenBSD, MacOS X...).\n *\n * If the pain of reading these is too great, it should be a straightforward\n * task to translate them into Linux-specific versions which are more\n * consistent with the style used in NFSv2/v3...\n */\n#define READ32(x)         (x) = ntohl(*p++)\n#define READ64(x)         do {\t\t\t\\\n\t(x) = (u64)ntohl(*p++) << 32;\t\t\\\n\t(x) |= ntohl(*p++);\t\t\t\\\n} while (0)\n#define READTIME(x)       do {\t\t\t\\\n\tp++;\t\t\t\t\t\\\n\t(x.tv_sec) = ntohl(*p++);\t\t\\\n\t(x.tv_nsec) = ntohl(*p++);\t\t\\\n} while (0)\n#define COPYMEM(x,nbytes) do {\t\t\t\\\n\tmemcpy((x), p, nbytes);\t\t\t\\\n\tp += XDR_QUADLEN(nbytes);\t\t\\\n} while (0)\n\n#define READ_BUF(nbytes)  do { \\\n\tp = xdr_inline_decode(xdr, nbytes); \\\n\tif (unlikely(!p)) { \\\n\t\tdprintk(\"nfs: %s: prematurely hit end of receive\" \\\n\t\t\t\t\" buffer\\n\", __func__); \\\n\t\tdprintk(\"nfs: %s: xdr->p=%p, bytes=%u, xdr->end=%p\\n\", \\\n\t\t\t\t__func__, xdr->p, nbytes, xdr->end); \\\n\t\treturn -EIO; \\\n\t} \\\n} while (0)\n\nstatic int decode_opaque_inline(struct xdr_stream *xdr, unsigned int *len, char **string)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\tREAD32(*len);\n\tREAD_BUF(*len);\n\t*string = (char *)p;\n\treturn 0;\n}\n\nstatic int decode_compound_hdr(struct xdr_stream *xdr, struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tREAD_BUF(8);\n\tREAD32(hdr->status);\n\tREAD32(hdr->taglen);\n\t\n\tREAD_BUF(hdr->taglen + 4);\n\thdr->tag = (char *)p;\n\tp += XDR_QUADLEN(hdr->taglen);\n\tREAD32(hdr->nops);\n\treturn 0;\n}\n\nstatic int decode_op_hdr(struct xdr_stream *xdr, enum nfs_opnum4 expected)\n{\n\t__be32 *p;\n\tuint32_t opnum;\n\tint32_t nfserr;\n\n\tREAD_BUF(8);\n\tREAD32(opnum);\n\tif (opnum != expected) {\n\t\tdprintk(\"nfs: Server returned operation\"\n\t\t\t\" %d but we issued a request for %d\\n\",\n\t\t\t\topnum, expected);\n\t\treturn -EIO;\n\t}\n\tREAD32(nfserr);\n\tif (nfserr != NFS_OK)\n\t\treturn nfs4_stat_to_errno(nfserr);\n\treturn 0;\n}\n\n/* Dummy routine */\nstatic int decode_ace(struct xdr_stream *xdr, void *ace, struct nfs_client *clp)\n{\n\t__be32 *p;\n\tunsigned int strlen;\n\tchar *str;\n\n\tREAD_BUF(12);\n\treturn decode_opaque_inline(xdr, &strlen, &str);\n}\n\nstatic int decode_attr_bitmap(struct xdr_stream *xdr, uint32_t *bitmap)\n{\n\tuint32_t bmlen;\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\tREAD32(bmlen);\n\n\tbitmap[0] = bitmap[1] = 0;\n\tREAD_BUF((bmlen << 2));\n\tif (bmlen > 0) {\n\t\tREAD32(bitmap[0]);\n\t\tif (bmlen > 1)\n\t\t\tREAD32(bitmap[1]);\n\t}\n\treturn 0;\n}\n\nstatic inline int decode_attr_length(struct xdr_stream *xdr, uint32_t *attrlen, __be32 **savep)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\tREAD32(*attrlen);\n\t*savep = xdr->p;\n\treturn 0;\n}\n\nstatic int decode_attr_supported(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *bitmask)\n{\n\tif (likely(bitmap[0] & FATTR4_WORD0_SUPPORTED_ATTRS)) {\n\t\tdecode_attr_bitmap(xdr, bitmask);\n\t\tbitmap[0] &= ~FATTR4_WORD0_SUPPORTED_ATTRS;\n\t} else\n\t\tbitmask[0] = bitmask[1] = 0;\n\tdprintk(\"%s: bitmask=%08x:%08x\\n\", __func__, bitmask[0], bitmask[1]);\n\treturn 0;\n}\n\nstatic int decode_attr_type(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *type)\n{\n\t__be32 *p;\n\n\t*type = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_TYPE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_TYPE)) {\n\t\tREAD_BUF(4);\n\t\tREAD32(*type);\n\t\tif (*type < NF4REG || *type > NF4NAMEDATTR) {\n\t\t\tdprintk(\"%s: bad type %d\\n\", __func__, *type);\n\t\t\treturn -EIO;\n\t\t}\n\t\tbitmap[0] &= ~FATTR4_WORD0_TYPE;\n\t}\n\tdprintk(\"%s: type=0%o\\n\", __func__, nfs_type2fmt[*type].nfs2type);\n\treturn 0;\n}\n\nstatic int decode_attr_change(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *change)\n{\n\t__be32 *p;\n\n\t*change = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_CHANGE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_CHANGE)) {\n\t\tREAD_BUF(8);\n\t\tREAD64(*change);\n\t\tbitmap[0] &= ~FATTR4_WORD0_CHANGE;\n\t}\n\tdprintk(\"%s: change attribute=%Lu\\n\", __func__,\n\t\t\t(unsigned long long)*change);\n\treturn 0;\n}\n\nstatic int decode_attr_size(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *size)\n{\n\t__be32 *p;\n\n\t*size = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_SIZE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_SIZE)) {\n\t\tREAD_BUF(8);\n\t\tREAD64(*size);\n\t\tbitmap[0] &= ~FATTR4_WORD0_SIZE;\n\t}\n\tdprintk(\"%s: file size=%Lu\\n\", __func__, (unsigned long long)*size);\n\treturn 0;\n}\n\nstatic int decode_attr_link_support(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *res)\n{\n\t__be32 *p;\n\n\t*res = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_LINK_SUPPORT - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_LINK_SUPPORT)) {\n\t\tREAD_BUF(4);\n\t\tREAD32(*res);\n\t\tbitmap[0] &= ~FATTR4_WORD0_LINK_SUPPORT;\n\t}\n\tdprintk(\"%s: link support=%s\\n\", __func__, *res == 0 ? \"false\" : \"true\");\n\treturn 0;\n}\n\nstatic int decode_attr_symlink_support(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *res)\n{\n\t__be32 *p;\n\n\t*res = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_SYMLINK_SUPPORT - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_SYMLINK_SUPPORT)) {\n\t\tREAD_BUF(4);\n\t\tREAD32(*res);\n\t\tbitmap[0] &= ~FATTR4_WORD0_SYMLINK_SUPPORT;\n\t}\n\tdprintk(\"%s: symlink support=%s\\n\", __func__, *res == 0 ? \"false\" : \"true\");\n\treturn 0;\n}\n\nstatic int decode_attr_fsid(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_fsid *fsid)\n{\n\t__be32 *p;\n\n\tfsid->major = 0;\n\tfsid->minor = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_FSID - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_FSID)) {\n\t\tREAD_BUF(16);\n\t\tREAD64(fsid->major);\n\t\tREAD64(fsid->minor);\n\t\tbitmap[0] &= ~FATTR4_WORD0_FSID;\n\t}\n\tdprintk(\"%s: fsid=(0x%Lx/0x%Lx)\\n\", __func__,\n\t\t\t(unsigned long long)fsid->major,\n\t\t\t(unsigned long long)fsid->minor);\n\treturn 0;\n}\n\nstatic int decode_attr_lease_time(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *res)\n{\n\t__be32 *p;\n\n\t*res = 60;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_LEASE_TIME - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_LEASE_TIME)) {\n\t\tREAD_BUF(4);\n\t\tREAD32(*res);\n\t\tbitmap[0] &= ~FATTR4_WORD0_LEASE_TIME;\n\t}\n\tdprintk(\"%s: file size=%u\\n\", __func__, (unsigned int)*res);\n\treturn 0;\n}\n\nstatic int decode_attr_aclsupport(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *res)\n{\n\t__be32 *p;\n\n\t*res = ACL4_SUPPORT_ALLOW_ACL|ACL4_SUPPORT_DENY_ACL;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_ACLSUPPORT - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_ACLSUPPORT)) {\n\t\tREAD_BUF(4);\n\t\tREAD32(*res);\n\t\tbitmap[0] &= ~FATTR4_WORD0_ACLSUPPORT;\n\t}\n\tdprintk(\"%s: ACLs supported=%u\\n\", __func__, (unsigned int)*res);\n\treturn 0;\n}\n\nstatic int decode_attr_fileid(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *fileid)\n{\n\t__be32 *p;\n\n\t*fileid = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_FILEID - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_FILEID)) {\n\t\tREAD_BUF(8);\n\t\tREAD64(*fileid);\n\t\tbitmap[0] &= ~FATTR4_WORD0_FILEID;\n\t}\n\tdprintk(\"%s: fileid=%Lu\\n\", __func__, (unsigned long long)*fileid);\n\treturn 0;\n}\n\nstatic int decode_attr_mounted_on_fileid(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *fileid)\n{\n\t__be32 *p;\n\n\t*fileid = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_MOUNTED_ON_FILEID - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_MOUNTED_ON_FILEID)) {\n\t\tREAD_BUF(8);\n\t\tREAD64(*fileid);\n\t\tbitmap[1] &= ~FATTR4_WORD1_MOUNTED_ON_FILEID;\n\t}\n\tdprintk(\"%s: fileid=%Lu\\n\", __func__, (unsigned long long)*fileid);\n\treturn 0;\n}\n\nstatic int decode_attr_files_avail(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_FILES_AVAIL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_FILES_AVAIL)) {\n\t\tREAD_BUF(8);\n\t\tREAD64(*res);\n\t\tbitmap[0] &= ~FATTR4_WORD0_FILES_AVAIL;\n\t}\n\tdprintk(\"%s: files avail=%Lu\\n\", __func__, (unsigned long long)*res);\n\treturn status;\n}\n\nstatic int decode_attr_files_free(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_FILES_FREE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_FILES_FREE)) {\n\t\tREAD_BUF(8);\n\t\tREAD64(*res);\n\t\tbitmap[0] &= ~FATTR4_WORD0_FILES_FREE;\n\t}\n\tdprintk(\"%s: files free=%Lu\\n\", __func__, (unsigned long long)*res);\n\treturn status;\n}\n\nstatic int decode_attr_files_total(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_FILES_TOTAL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_FILES_TOTAL)) {\n\t\tREAD_BUF(8);\n\t\tREAD64(*res);\n\t\tbitmap[0] &= ~FATTR4_WORD0_FILES_TOTAL;\n\t}\n\tdprintk(\"%s: files total=%Lu\\n\", __func__, (unsigned long long)*res);\n\treturn status;\n}\n\nstatic int decode_pathname(struct xdr_stream *xdr, struct nfs4_pathname *path)\n{\n\tu32 n;\n\t__be32 *p;\n\tint status = 0;\n\n\tREAD_BUF(4);\n\tREAD32(n);\n\tif (n == 0)\n\t\tgoto root_path;\n\tdprintk(\"path \");\n\tpath->ncomponents = 0;\n\twhile (path->ncomponents < n) {\n\t\tstruct nfs4_string *component = &path->components[path->ncomponents];\n\t\tstatus = decode_opaque_inline(xdr, &component->len, &component->data);\n\t\tif (unlikely(status != 0))\n\t\t\tgoto out_eio;\n\t\tif (path->ncomponents != n)\n\t\t\tdprintk(\"/\");\n\t\tdprintk(\"%s\", component->data);\n\t\tif (path->ncomponents < NFS4_PATHNAME_MAXCOMPONENTS)\n\t\t\tpath->ncomponents++;\n\t\telse {\n\t\t\tdprintk(\"cannot parse %d components in path\\n\", n);\n\t\t\tgoto out_eio;\n\t\t}\n\t}\nout:\n\tdprintk(\"\\n\");\n\treturn status;\nroot_path:\n/* a root pathname is sent as a zero component4 */\n\tpath->ncomponents = 1;\n\tpath->components[0].len=0;\n\tpath->components[0].data=NULL;\n\tdprintk(\"path /\\n\");\n\tgoto out;\nout_eio:\n\tdprintk(\" status %d\", status);\n\tstatus = -EIO;\n\tgoto out;\n}\n\nstatic int decode_attr_fs_locations(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs4_fs_locations *res)\n{\n\tint n;\n\t__be32 *p;\n\tint status = -EIO;\n\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_FS_LOCATIONS -1U)))\n\t\tgoto out;\n\tstatus = 0;\n\tif (unlikely(!(bitmap[0] & FATTR4_WORD0_FS_LOCATIONS)))\n\t\tgoto out;\n\tdprintk(\"%s: fsroot \", __func__);\n\tstatus = decode_pathname(xdr, &res->fs_path);\n\tif (unlikely(status != 0))\n\t\tgoto out;\n\tREAD_BUF(4);\n\tREAD32(n);\n\tif (n <= 0)\n\t\tgoto out_eio;\n\tres->nlocations = 0;\n\twhile (res->nlocations < n) {\n\t\tu32 m;\n\t\tstruct nfs4_fs_location *loc = &res->locations[res->nlocations];\n\n\t\tREAD_BUF(4);\n\t\tREAD32(m);\n\n\t\tloc->nservers = 0;\n\t\tdprintk(\"%s: servers \", __func__);\n\t\twhile (loc->nservers < m) {\n\t\t\tstruct nfs4_string *server = &loc->servers[loc->nservers];\n\t\t\tstatus = decode_opaque_inline(xdr, &server->len, &server->data);\n\t\t\tif (unlikely(status != 0))\n\t\t\t\tgoto out_eio;\n\t\t\tdprintk(\"%s \", server->data);\n\t\t\tif (loc->nservers < NFS4_FS_LOCATION_MAXSERVERS)\n\t\t\t\tloc->nservers++;\n\t\t\telse {\n\t\t\t\tunsigned int i;\n\t\t\t\tdprintk(\"%s: using first %u of %u servers \"\n\t\t\t\t\t\"returned for location %u\\n\",\n\t\t\t\t\t\t__func__,\n\t\t\t\t\t\tNFS4_FS_LOCATION_MAXSERVERS,\n\t\t\t\t\t\tm, res->nlocations);\n\t\t\t\tfor (i = loc->nservers; i < m; i++) {\n\t\t\t\t\tunsigned int len;\n\t\t\t\t\tchar *data;\n\t\t\t\t\tstatus = decode_opaque_inline(xdr, &len, &data);\n\t\t\t\t\tif (unlikely(status != 0))\n\t\t\t\t\t\tgoto out_eio;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstatus = decode_pathname(xdr, &loc->rootpath);\n\t\tif (unlikely(status != 0))\n\t\t\tgoto out_eio;\n\t\tif (res->nlocations < NFS4_FS_LOCATIONS_MAXENTRIES)\n\t\t\tres->nlocations++;\n\t}\nout:\n\tdprintk(\"%s: fs_locations done, error = %d\\n\", __func__, status);\n\treturn status;\nout_eio:\n\tstatus = -EIO;\n\tgoto out;\n}\n\nstatic int decode_attr_maxfilesize(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_MAXFILESIZE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_MAXFILESIZE)) {\n\t\tREAD_BUF(8);\n\t\tREAD64(*res);\n\t\tbitmap[0] &= ~FATTR4_WORD0_MAXFILESIZE;\n\t}\n\tdprintk(\"%s: maxfilesize=%Lu\\n\", __func__, (unsigned long long)*res);\n\treturn status;\n}\n\nstatic int decode_attr_maxlink(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *maxlink)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*maxlink = 1;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_MAXLINK - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_MAXLINK)) {\n\t\tREAD_BUF(4);\n\t\tREAD32(*maxlink);\n\t\tbitmap[0] &= ~FATTR4_WORD0_MAXLINK;\n\t}\n\tdprintk(\"%s: maxlink=%u\\n\", __func__, *maxlink);\n\treturn status;\n}\n\nstatic int decode_attr_maxname(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *maxname)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*maxname = 1024;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_MAXNAME - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_MAXNAME)) {\n\t\tREAD_BUF(4);\n\t\tREAD32(*maxname);\n\t\tbitmap[0] &= ~FATTR4_WORD0_MAXNAME;\n\t}\n\tdprintk(\"%s: maxname=%u\\n\", __func__, *maxname);\n\treturn status;\n}\n\nstatic int decode_attr_maxread(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 1024;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_MAXREAD - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_MAXREAD)) {\n\t\tuint64_t maxread;\n\t\tREAD_BUF(8);\n\t\tREAD64(maxread);\n\t\tif (maxread > 0x7FFFFFFF)\n\t\t\tmaxread = 0x7FFFFFFF;\n\t\t*res = (uint32_t)maxread;\n\t\tbitmap[0] &= ~FATTR4_WORD0_MAXREAD;\n\t}\n\tdprintk(\"%s: maxread=%lu\\n\", __func__, (unsigned long)*res);\n\treturn status;\n}\n\nstatic int decode_attr_maxwrite(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 1024;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_MAXWRITE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_MAXWRITE)) {\n\t\tuint64_t maxwrite;\n\t\tREAD_BUF(8);\n\t\tREAD64(maxwrite);\n\t\tif (maxwrite > 0x7FFFFFFF)\n\t\t\tmaxwrite = 0x7FFFFFFF;\n\t\t*res = (uint32_t)maxwrite;\n\t\tbitmap[0] &= ~FATTR4_WORD0_MAXWRITE;\n\t}\n\tdprintk(\"%s: maxwrite=%lu\\n\", __func__, (unsigned long)*res);\n\treturn status;\n}\n\nstatic int decode_attr_mode(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *mode)\n{\n\t__be32 *p;\n\n\t*mode = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_MODE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_MODE)) {\n\t\tREAD_BUF(4);\n\t\tREAD32(*mode);\n\t\t*mode &= ~S_IFMT;\n\t\tbitmap[1] &= ~FATTR4_WORD1_MODE;\n\t}\n\tdprintk(\"%s: file mode=0%o\\n\", __func__, (unsigned int)*mode);\n\treturn 0;\n}\n\nstatic int decode_attr_nlink(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *nlink)\n{\n\t__be32 *p;\n\n\t*nlink = 1;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_NUMLINKS - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_NUMLINKS)) {\n\t\tREAD_BUF(4);\n\t\tREAD32(*nlink);\n\t\tbitmap[1] &= ~FATTR4_WORD1_NUMLINKS;\n\t}\n\tdprintk(\"%s: nlink=%u\\n\", __func__, (unsigned int)*nlink);\n\treturn 0;\n}\n\nstatic int decode_attr_owner(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_client *clp, uint32_t *uid)\n{\n\tuint32_t len;\n\t__be32 *p;\n\n\t*uid = -2;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_OWNER - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_OWNER)) {\n\t\tREAD_BUF(4);\n\t\tREAD32(len);\n\t\tREAD_BUF(len);\n\t\tif (len < XDR_MAX_NETOBJ) {\n\t\t\tif (nfs_map_name_to_uid(clp, (char *)p, len, uid) != 0)\n\t\t\t\tdprintk(\"%s: nfs_map_name_to_uid failed!\\n\",\n\t\t\t\t\t\t__func__);\n\t\t} else\n\t\t\tdprintk(\"%s: name too long (%u)!\\n\",\n\t\t\t\t\t__func__, len);\n\t\tbitmap[1] &= ~FATTR4_WORD1_OWNER;\n\t}\n\tdprintk(\"%s: uid=%d\\n\", __func__, (int)*uid);\n\treturn 0;\n}\n\nstatic int decode_attr_group(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_client *clp, uint32_t *gid)\n{\n\tuint32_t len;\n\t__be32 *p;\n\n\t*gid = -2;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_OWNER_GROUP - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_OWNER_GROUP)) {\n\t\tREAD_BUF(4);\n\t\tREAD32(len);\n\t\tREAD_BUF(len);\n\t\tif (len < XDR_MAX_NETOBJ) {\n\t\t\tif (nfs_map_group_to_gid(clp, (char *)p, len, gid) != 0)\n\t\t\t\tdprintk(\"%s: nfs_map_group_to_gid failed!\\n\",\n\t\t\t\t\t\t__func__);\n\t\t} else\n\t\t\tdprintk(\"%s: name too long (%u)!\\n\",\n\t\t\t\t\t__func__, len);\n\t\tbitmap[1] &= ~FATTR4_WORD1_OWNER_GROUP;\n\t}\n\tdprintk(\"%s: gid=%d\\n\", __func__, (int)*gid);\n\treturn 0;\n}\n\nstatic int decode_attr_rdev(struct xdr_stream *xdr, uint32_t *bitmap, dev_t *rdev)\n{\n\tuint32_t major = 0, minor = 0;\n\t__be32 *p;\n\n\t*rdev = MKDEV(0,0);\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_RAWDEV - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_RAWDEV)) {\n\t\tdev_t tmp;\n\n\t\tREAD_BUF(8);\n\t\tREAD32(major);\n\t\tREAD32(minor);\n\t\ttmp = MKDEV(major, minor);\n\t\tif (MAJOR(tmp) == major && MINOR(tmp) == minor)\n\t\t\t*rdev = tmp;\n\t\tbitmap[1] &= ~ FATTR4_WORD1_RAWDEV;\n\t}\n\tdprintk(\"%s: rdev=(0x%x:0x%x)\\n\", __func__, major, minor);\n\treturn 0;\n}\n\nstatic int decode_attr_space_avail(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_SPACE_AVAIL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_SPACE_AVAIL)) {\n\t\tREAD_BUF(8);\n\t\tREAD64(*res);\n\t\tbitmap[1] &= ~FATTR4_WORD1_SPACE_AVAIL;\n\t}\n\tdprintk(\"%s: space avail=%Lu\\n\", __func__, (unsigned long long)*res);\n\treturn status;\n}\n\nstatic int decode_attr_space_free(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_SPACE_FREE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_SPACE_FREE)) {\n\t\tREAD_BUF(8);\n\t\tREAD64(*res);\n\t\tbitmap[1] &= ~FATTR4_WORD1_SPACE_FREE;\n\t}\n\tdprintk(\"%s: space free=%Lu\\n\", __func__, (unsigned long long)*res);\n\treturn status;\n}\n\nstatic int decode_attr_space_total(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_SPACE_TOTAL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_SPACE_TOTAL)) {\n\t\tREAD_BUF(8);\n\t\tREAD64(*res);\n\t\tbitmap[1] &= ~FATTR4_WORD1_SPACE_TOTAL;\n\t}\n\tdprintk(\"%s: space total=%Lu\\n\", __func__, (unsigned long long)*res);\n\treturn status;\n}\n\nstatic int decode_attr_space_used(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *used)\n{\n\t__be32 *p;\n\n\t*used = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_SPACE_USED - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_SPACE_USED)) {\n\t\tREAD_BUF(8);\n\t\tREAD64(*used);\n\t\tbitmap[1] &= ~FATTR4_WORD1_SPACE_USED;\n\t}\n\tdprintk(\"%s: space used=%Lu\\n\", __func__,\n\t\t\t(unsigned long long)*used);\n\treturn 0;\n}\n\nstatic int decode_attr_time(struct xdr_stream *xdr, struct timespec *time)\n{\n\t__be32 *p;\n\tuint64_t sec;\n\tuint32_t nsec;\n\n\tREAD_BUF(12);\n\tREAD64(sec);\n\tREAD32(nsec);\n\ttime->tv_sec = (time_t)sec;\n\ttime->tv_nsec = (long)nsec;\n\treturn 0;\n}\n\nstatic int decode_attr_time_access(struct xdr_stream *xdr, uint32_t *bitmap, struct timespec *time)\n{\n\tint status = 0;\n\n\ttime->tv_sec = 0;\n\ttime->tv_nsec = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_TIME_ACCESS - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_TIME_ACCESS)) {\n\t\tstatus = decode_attr_time(xdr, time);\n\t\tbitmap[1] &= ~FATTR4_WORD1_TIME_ACCESS;\n\t}\n\tdprintk(\"%s: atime=%ld\\n\", __func__, (long)time->tv_sec);\n\treturn status;\n}\n\nstatic int decode_attr_time_metadata(struct xdr_stream *xdr, uint32_t *bitmap, struct timespec *time)\n{\n\tint status = 0;\n\n\ttime->tv_sec = 0;\n\ttime->tv_nsec = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_TIME_METADATA - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_TIME_METADATA)) {\n\t\tstatus = decode_attr_time(xdr, time);\n\t\tbitmap[1] &= ~FATTR4_WORD1_TIME_METADATA;\n\t}\n\tdprintk(\"%s: ctime=%ld\\n\", __func__, (long)time->tv_sec);\n\treturn status;\n}\n\nstatic int decode_attr_time_modify(struct xdr_stream *xdr, uint32_t *bitmap, struct timespec *time)\n{\n\tint status = 0;\n\n\ttime->tv_sec = 0;\n\ttime->tv_nsec = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_TIME_MODIFY - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_TIME_MODIFY)) {\n\t\tstatus = decode_attr_time(xdr, time);\n\t\tbitmap[1] &= ~FATTR4_WORD1_TIME_MODIFY;\n\t}\n\tdprintk(\"%s: mtime=%ld\\n\", __func__, (long)time->tv_sec);\n\treturn status;\n}\n\nstatic int verify_attr_len(struct xdr_stream *xdr, __be32 *savep, uint32_t attrlen)\n{\n\tunsigned int attrwords = XDR_QUADLEN(attrlen);\n\tunsigned int nwords = xdr->p - savep;\n\n\tif (unlikely(attrwords != nwords)) {\n\t\tdprintk(\"%s: server returned incorrect attribute length: \"\n\t\t\t\"%u %c %u\\n\",\n\t\t\t\t__func__,\n\t\t\t\tattrwords << 2,\n\t\t\t\t(attrwords < nwords) ? '<' : '>',\n\t\t\t\tnwords << 2);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int decode_change_info(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)\n{\n\t__be32 *p;\n\n\tREAD_BUF(20);\n\tREAD32(cinfo->atomic);\n\tREAD64(cinfo->before);\n\tREAD64(cinfo->after);\n\treturn 0;\n}\n\nstatic int decode_access(struct xdr_stream *xdr, struct nfs4_accessres *access)\n{\n\t__be32 *p;\n\tuint32_t supp, acc;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_ACCESS);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(8);\n\tREAD32(supp);\n\tREAD32(acc);\n\taccess->supported = supp;\n\taccess->access = acc;\n\treturn 0;\n}\n\nstatic int decode_close(struct xdr_stream *xdr, struct nfs_closeres *res)\n{\n\t__be32 *p;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_CLOSE);\n\tif (status != -EIO)\n\t\tnfs_increment_open_seqid(status, res->seqid);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(NFS4_STATEID_SIZE);\n\tCOPYMEM(res->stateid.data, NFS4_STATEID_SIZE);\n\treturn 0;\n}\n\nstatic int decode_commit(struct xdr_stream *xdr, struct nfs_writeres *res)\n{\n\t__be32 *p;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_COMMIT);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(8);\n\tCOPYMEM(res->verf->verifier, 8);\n\treturn 0;\n}\n\nstatic int decode_create(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)\n{\n\t__be32 *p;\n\tuint32_t bmlen;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_CREATE);\n\tif (status)\n\t\treturn status;\n\tif ((status = decode_change_info(xdr, cinfo)))\n\t\treturn status;\n\tREAD_BUF(4);\n\tREAD32(bmlen);\n\tREAD_BUF(bmlen << 2);\n\treturn 0;\n}\n\nstatic int decode_server_caps(struct xdr_stream *xdr, struct nfs4_server_caps_res *res)\n{\n\t__be32 *savep;\n\tuint32_t attrlen, \n\t\t bitmap[2] = {0};\n\tint status;\n\n\tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_supported(xdr, bitmap, res->attr_bitmask)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_link_support(xdr, bitmap, &res->has_links)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_symlink_support(xdr, bitmap, &res->has_symlinks)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_aclsupport(xdr, bitmap, &res->acl_bitmask)) != 0)\n\t\tgoto xdr_error;\n\tstatus = verify_attr_len(xdr, savep, attrlen);\nxdr_error:\n\tdprintk(\"%s: xdr returned %d!\\n\", __func__, -status);\n\treturn status;\n}\n\t\nstatic int decode_statfs(struct xdr_stream *xdr, struct nfs_fsstat *fsstat)\n{\n\t__be32 *savep;\n\tuint32_t attrlen, \n\t\t bitmap[2] = {0};\n\tint status;\n\t\n\tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n\t\tgoto xdr_error;\n\n\tif ((status = decode_attr_files_avail(xdr, bitmap, &fsstat->afiles)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_files_free(xdr, bitmap, &fsstat->ffiles)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_files_total(xdr, bitmap, &fsstat->tfiles)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_space_avail(xdr, bitmap, &fsstat->abytes)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_space_free(xdr, bitmap, &fsstat->fbytes)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_space_total(xdr, bitmap, &fsstat->tbytes)) != 0)\n\t\tgoto xdr_error;\n\n\tstatus = verify_attr_len(xdr, savep, attrlen);\nxdr_error:\n\tdprintk(\"%s: xdr returned %d!\\n\", __func__, -status);\n\treturn status;\n}\n\nstatic int decode_pathconf(struct xdr_stream *xdr, struct nfs_pathconf *pathconf)\n{\n\t__be32 *savep;\n\tuint32_t attrlen, \n\t\t bitmap[2] = {0};\n\tint status;\n\t\n\tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n\t\tgoto xdr_error;\n\n\tif ((status = decode_attr_maxlink(xdr, bitmap, &pathconf->max_link)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_maxname(xdr, bitmap, &pathconf->max_namelen)) != 0)\n\t\tgoto xdr_error;\n\n\tstatus = verify_attr_len(xdr, savep, attrlen);\nxdr_error:\n\tdprintk(\"%s: xdr returned %d!\\n\", __func__, -status);\n\treturn status;\n}\n\nstatic int decode_getfattr(struct xdr_stream *xdr, struct nfs_fattr *fattr, const struct nfs_server *server)\n{\n\t__be32 *savep;\n\tuint32_t attrlen,\n\t\t bitmap[2] = {0},\n\t\t type;\n\tint status, fmode = 0;\n\tuint64_t fileid;\n\n\tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n\t\tgoto xdr_error;\n\n\tfattr->bitmap[0] = bitmap[0];\n\tfattr->bitmap[1] = bitmap[1];\n\n\tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n\t\tgoto xdr_error;\n\n\n\tif ((status = decode_attr_type(xdr, bitmap, &type)) != 0)\n\t\tgoto xdr_error;\n\tfattr->type = nfs_type2fmt[type].nfs2type;\n\tfmode = nfs_type2fmt[type].mode;\n\n\tif ((status = decode_attr_change(xdr, bitmap, &fattr->change_attr)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_size(xdr, bitmap, &fattr->size)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_fsid(xdr, bitmap, &fattr->fsid)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_fileid(xdr, bitmap, &fattr->fileid)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_fs_locations(xdr, bitmap, container_of(fattr,\n\t\t\t\t\t\tstruct nfs4_fs_locations,\n\t\t\t\t\t\tfattr))) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_mode(xdr, bitmap, &fattr->mode)) != 0)\n\t\tgoto xdr_error;\n\tfattr->mode |= fmode;\n\tif ((status = decode_attr_nlink(xdr, bitmap, &fattr->nlink)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_owner(xdr, bitmap, server->nfs_client, &fattr->uid)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_group(xdr, bitmap, server->nfs_client, &fattr->gid)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_rdev(xdr, bitmap, &fattr->rdev)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_space_used(xdr, bitmap, &fattr->du.nfs3.used)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_time_access(xdr, bitmap, &fattr->atime)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_time_metadata(xdr, bitmap, &fattr->ctime)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_time_modify(xdr, bitmap, &fattr->mtime)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_mounted_on_fileid(xdr, bitmap, &fileid)) != 0)\n\t\tgoto xdr_error;\n\tif (fattr->fileid == 0 && fileid != 0)\n\t\tfattr->fileid = fileid;\n\tif ((status = verify_attr_len(xdr, savep, attrlen)) == 0)\n\t\tfattr->valid = NFS_ATTR_FATTR | NFS_ATTR_FATTR_V3 | NFS_ATTR_FATTR_V4;\nxdr_error:\n\tdprintk(\"%s: xdr returned %d\\n\", __func__, -status);\n\treturn status;\n}\n\n\nstatic int decode_fsinfo(struct xdr_stream *xdr, struct nfs_fsinfo *fsinfo)\n{\n\t__be32 *savep;\n\tuint32_t attrlen, bitmap[2];\n\tint status;\n\n\tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n\t\tgoto xdr_error;\n\n\tfsinfo->rtmult = fsinfo->wtmult = 512;\t/* ??? */\n\n\tif ((status = decode_attr_lease_time(xdr, bitmap, &fsinfo->lease_time)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_maxfilesize(xdr, bitmap, &fsinfo->maxfilesize)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_maxread(xdr, bitmap, &fsinfo->rtmax)) != 0)\n\t\tgoto xdr_error;\n\tfsinfo->rtpref = fsinfo->dtpref = fsinfo->rtmax;\n\tif ((status = decode_attr_maxwrite(xdr, bitmap, &fsinfo->wtmax)) != 0)\n\t\tgoto xdr_error;\n\tfsinfo->wtpref = fsinfo->wtmax;\n\n\tstatus = verify_attr_len(xdr, savep, attrlen);\nxdr_error:\n\tdprintk(\"%s: xdr returned %d!\\n\", __func__, -status);\n\treturn status;\n}\n\nstatic int decode_getfh(struct xdr_stream *xdr, struct nfs_fh *fh)\n{\n\t__be32 *p;\n\tuint32_t len;\n\tint status;\n\n\t/* Zero handle first to allow comparisons */\n\tmemset(fh, 0, sizeof(*fh));\n\n\tstatus = decode_op_hdr(xdr, OP_GETFH);\n\tif (status)\n\t\treturn status;\n\n\tREAD_BUF(4);\n\tREAD32(len);\n\tif (len > NFS4_FHSIZE)\n\t\treturn -EIO;\n\tfh->size = len;\n\tREAD_BUF(len);\n\tCOPYMEM(fh->data, len);\n\treturn 0;\n}\n\nstatic int decode_link(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)\n{\n\tint status;\n\t\n\tstatus = decode_op_hdr(xdr, OP_LINK);\n\tif (status)\n\t\treturn status;\n\treturn decode_change_info(xdr, cinfo);\n}\n\n/*\n * We create the owner, so we know a proper owner.id length is 4.\n */\nstatic int decode_lock_denied (struct xdr_stream *xdr, struct file_lock *fl)\n{\n\tuint64_t offset, length, clientid;\n\t__be32 *p;\n\tuint32_t namelen, type;\n\n\tREAD_BUF(32);\n\tREAD64(offset);\n\tREAD64(length);\n\tREAD32(type);\n\tif (fl != NULL) {\n\t\tfl->fl_start = (loff_t)offset;\n\t\tfl->fl_end = fl->fl_start + (loff_t)length - 1;\n\t\tif (length == ~(uint64_t)0)\n\t\t\tfl->fl_end = OFFSET_MAX;\n\t\tfl->fl_type = F_WRLCK;\n\t\tif (type & 1)\n\t\t\tfl->fl_type = F_RDLCK;\n\t\tfl->fl_pid = 0;\n\t}\n\tREAD64(clientid);\n\tREAD32(namelen);\n\tREAD_BUF(namelen);\n\treturn -NFS4ERR_DENIED;\n}\n\nstatic int decode_lock(struct xdr_stream *xdr, struct nfs_lock_res *res)\n{\n\t__be32 *p;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_LOCK);\n\tif (status == -EIO)\n\t\tgoto out;\n\tif (status == 0) {\n\t\tREAD_BUF(NFS4_STATEID_SIZE);\n\t\tCOPYMEM(res->stateid.data, NFS4_STATEID_SIZE);\n\t} else if (status == -NFS4ERR_DENIED)\n\t\tstatus = decode_lock_denied(xdr, NULL);\n\tif (res->open_seqid != NULL)\n\t\tnfs_increment_open_seqid(status, res->open_seqid);\n\tnfs_increment_lock_seqid(status, res->lock_seqid);\nout:\n\treturn status;\n}\n\nstatic int decode_lockt(struct xdr_stream *xdr, struct nfs_lockt_res *res)\n{\n\tint status;\n\tstatus = decode_op_hdr(xdr, OP_LOCKT);\n\tif (status == -NFS4ERR_DENIED)\n\t\treturn decode_lock_denied(xdr, res->denied);\n\treturn status;\n}\n\nstatic int decode_locku(struct xdr_stream *xdr, struct nfs_locku_res *res)\n{\n\t__be32 *p;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_LOCKU);\n\tif (status != -EIO)\n\t\tnfs_increment_lock_seqid(status, res->seqid);\n\tif (status == 0) {\n\t\tREAD_BUF(NFS4_STATEID_SIZE);\n\t\tCOPYMEM(res->stateid.data, NFS4_STATEID_SIZE);\n\t}\n\treturn status;\n}\n\nstatic int decode_lookup(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_LOOKUP);\n}\n\n/* This is too sick! */\nstatic int decode_space_limit(struct xdr_stream *xdr, u64 *maxsize)\n{\n        __be32 *p;\n\tuint32_t limit_type, nblocks, blocksize;\n\n\tREAD_BUF(12);\n\tREAD32(limit_type);\n\tswitch (limit_type) {\n\t\tcase 1:\n\t\t\tREAD64(*maxsize);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tREAD32(nblocks);\n\t\t\tREAD32(blocksize);\n\t\t\t*maxsize = (uint64_t)nblocks * (uint64_t)blocksize;\n\t}\n\treturn 0;\n}\n\nstatic int decode_delegation(struct xdr_stream *xdr, struct nfs_openres *res)\n{\n        __be32 *p;\n        uint32_t delegation_type;\n\n\tREAD_BUF(4);\n\tREAD32(delegation_type);\n\tif (delegation_type == NFS4_OPEN_DELEGATE_NONE) {\n\t\tres->delegation_type = 0;\n\t\treturn 0;\n\t}\n\tREAD_BUF(NFS4_STATEID_SIZE+4);\n\tCOPYMEM(res->delegation.data, NFS4_STATEID_SIZE);\n\tREAD32(res->do_recall);\n\tswitch (delegation_type) {\n\t\tcase NFS4_OPEN_DELEGATE_READ:\n\t\t\tres->delegation_type = FMODE_READ;\n\t\t\tbreak;\n\t\tcase NFS4_OPEN_DELEGATE_WRITE:\n\t\t\tres->delegation_type = FMODE_WRITE|FMODE_READ;\n\t\t\tif (decode_space_limit(xdr, &res->maxsize) < 0)\n\t\t\t\treturn -EIO;\n\t}\n\treturn decode_ace(xdr, NULL, res->server->nfs_client);\n}\n\nstatic int decode_open(struct xdr_stream *xdr, struct nfs_openres *res)\n{\n        __be32 *p;\n\tuint32_t savewords, bmlen, i;\n        int status;\n\n        status = decode_op_hdr(xdr, OP_OPEN);\n\tif (status != -EIO)\n\t\tnfs_increment_open_seqid(status, res->seqid);\n        if (status)\n                return status;\n        READ_BUF(NFS4_STATEID_SIZE);\n        COPYMEM(res->stateid.data, NFS4_STATEID_SIZE);\n\n        decode_change_info(xdr, &res->cinfo);\n\n        READ_BUF(8);\n        READ32(res->rflags);\n        READ32(bmlen);\n        if (bmlen > 10)\n                goto xdr_error;\n\n        READ_BUF(bmlen << 2);\n\tsavewords = min_t(uint32_t, bmlen, NFS4_BITMAP_SIZE);\n\tfor (i = 0; i < savewords; ++i)\n\t\tREAD32(res->attrset[i]);\n\tfor (; i < NFS4_BITMAP_SIZE; i++)\n\t\tres->attrset[i] = 0;\n\n\treturn decode_delegation(xdr, res);\nxdr_error:\n\tdprintk(\"%s: Bitmap too large! Length = %u\\n\", __func__, bmlen);\n\treturn -EIO;\n}\n\nstatic int decode_open_confirm(struct xdr_stream *xdr, struct nfs_open_confirmres *res)\n{\n        __be32 *p;\n\tint status;\n\n        status = decode_op_hdr(xdr, OP_OPEN_CONFIRM);\n\tif (status != -EIO)\n\t\tnfs_increment_open_seqid(status, res->seqid);\n        if (status)\n                return status;\n        READ_BUF(NFS4_STATEID_SIZE);\n        COPYMEM(res->stateid.data, NFS4_STATEID_SIZE);\n        return 0;\n}\n\nstatic int decode_open_downgrade(struct xdr_stream *xdr, struct nfs_closeres *res)\n{\n\t__be32 *p;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_OPEN_DOWNGRADE);\n\tif (status != -EIO)\n\t\tnfs_increment_open_seqid(status, res->seqid);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(NFS4_STATEID_SIZE);\n\tCOPYMEM(res->stateid.data, NFS4_STATEID_SIZE);\n\treturn 0;\n}\n\nstatic int decode_putfh(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_PUTFH);\n}\n\nstatic int decode_putrootfh(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_PUTROOTFH);\n}\n\nstatic int decode_read(struct xdr_stream *xdr, struct rpc_rqst *req, struct nfs_readres *res)\n{\n\tstruct kvec *iov = req->rq_rcv_buf.head;\n\t__be32 *p;\n\tuint32_t count, eof, recvd, hdrlen;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_READ);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(8);\n\tREAD32(eof);\n\tREAD32(count);\n\thdrlen = (u8 *) p - (u8 *) iov->iov_base;\n\trecvd = req->rq_rcv_buf.len - hdrlen;\n\tif (count > recvd) {\n\t\tdprintk(\"NFS: server cheating in read reply: \"\n\t\t\t\t\"count %u > recvd %u\\n\", count, recvd);\n\t\tcount = recvd;\n\t\teof = 0;\n\t}\n\txdr_read_pages(xdr, count);\n\tres->eof = eof;\n\tres->count = count;\n\treturn 0;\n}\n\nstatic int decode_readdir(struct xdr_stream *xdr, struct rpc_rqst *req, struct nfs4_readdir_res *readdir)\n{\n\tstruct xdr_buf\t*rcvbuf = &req->rq_rcv_buf;\n\tstruct page\t*page = *rcvbuf->pages;\n\tstruct kvec\t*iov = rcvbuf->head;\n\tsize_t\t\thdrlen;\n\tu32\t\trecvd, pglen = rcvbuf->page_len;\n\t__be32\t\t*end, *entry, *p, *kaddr;\n\tunsigned int\tnr = 0;\n\tint\t\tstatus;\n\n\tstatus = decode_op_hdr(xdr, OP_READDIR);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(8);\n\tCOPYMEM(readdir->verifier.data, 8);\n\tdprintk(\"%s: verifier = %08x:%08x\\n\",\n\t\t\t__func__,\n\t\t\t((u32 *)readdir->verifier.data)[0],\n\t\t\t((u32 *)readdir->verifier.data)[1]);\n\n\n\thdrlen = (char *) p - (char *) iov->iov_base;\n\trecvd = rcvbuf->len - hdrlen;\n\tif (pglen > recvd)\n\t\tpglen = recvd;\n\txdr_read_pages(xdr, pglen);\n\n\tBUG_ON(pglen + readdir->pgbase > PAGE_CACHE_SIZE);\n\tkaddr = p = kmap_atomic(page, KM_USER0);\n\tend = p + ((pglen + readdir->pgbase) >> 2);\n\tentry = p;\n\n\t/* Make sure the packet actually has a value_follows and EOF entry */\n\tif ((entry + 1) > end)\n\t\tgoto short_pkt;\n\n\tfor (; *p++; nr++) {\n\t\tu32 len, attrlen, xlen;\n\t\tif (end - p < 3)\n\t\t\tgoto short_pkt;\n\t\tdprintk(\"cookie = %Lu, \", *((unsigned long long *)p));\n\t\tp += 2;\t\t\t/* cookie */\n\t\tlen = ntohl(*p++);\t/* filename length */\n\t\tif (len > NFS4_MAXNAMLEN) {\n\t\t\tdprintk(\"NFS: giant filename in readdir (len 0x%x)\\n\",\n\t\t\t\t\tlen);\n\t\t\tgoto err_unmap;\n\t\t}\n\t\txlen = XDR_QUADLEN(len);\n\t\tif (end - p < xlen + 1)\n\t\t\tgoto short_pkt;\n\t\tdprintk(\"filename = %*s\\n\", len, (char *)p);\n\t\tp += xlen;\n\t\tlen = ntohl(*p++);\t/* bitmap length */\n\t\tif (end - p < len + 1)\n\t\t\tgoto short_pkt;\n\t\tp += len;\n\t\tattrlen = XDR_QUADLEN(ntohl(*p++));\n\t\tif (end - p < attrlen + 2)\n\t\t\tgoto short_pkt;\n\t\tp += attrlen;\t\t/* attributes */\n\t\tentry = p;\n\t}\n\t/*\n\t * Apparently some server sends responses that are a valid size, but\n\t * contain no entries, and have value_follows==0 and EOF==0. For\n\t * those, just set the EOF marker.\n\t */\n\tif (!nr && entry[1] == 0) {\n\t\tdprintk(\"NFS: readdir reply truncated!\\n\");\n\t\tentry[1] = 1;\n\t}\nout:\t\n\tkunmap_atomic(kaddr, KM_USER0);\n\treturn 0;\nshort_pkt:\n\t/*\n\t * When we get a short packet there are 2 possibilities. We can\n\t * return an error, or fix up the response to look like a valid\n\t * response and return what we have so far. If there are no\n\t * entries and the packet was short, then return -EIO. If there\n\t * are valid entries in the response, return them and pretend that\n\t * the call was successful, but incomplete. The caller can retry the\n\t * readdir starting at the last cookie.\n\t */\n\tdprintk(\"%s: short packet at entry %d\\n\", __func__, nr);\n\tentry[0] = entry[1] = 0;\n\tif (nr)\n\t\tgoto out;\nerr_unmap:\n\tkunmap_atomic(kaddr, KM_USER0);\n\treturn -errno_NFSERR_IO;\n}\n\nstatic int decode_readlink(struct xdr_stream *xdr, struct rpc_rqst *req)\n{\n\tstruct xdr_buf *rcvbuf = &req->rq_rcv_buf;\n\tstruct kvec *iov = rcvbuf->head;\n\tsize_t hdrlen;\n\tu32 len, recvd;\n\t__be32 *p;\n\tchar *kaddr;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_READLINK);\n\tif (status)\n\t\treturn status;\n\n\t/* Convert length of symlink */\n\tREAD_BUF(4);\n\tREAD32(len);\n\tif (len >= rcvbuf->page_len || len <= 0) {\n\t\tdprintk(\"nfs: server returned giant symlink!\\n\");\n\t\treturn -ENAMETOOLONG;\n\t}\n\thdrlen = (char *) xdr->p - (char *) iov->iov_base;\n\trecvd = req->rq_rcv_buf.len - hdrlen;\n\tif (recvd < len) {\n\t\tdprintk(\"NFS: server cheating in readlink reply: \"\n\t\t\t\t\"count %u > recvd %u\\n\", len, recvd);\n\t\treturn -EIO;\n\t}\n\txdr_read_pages(xdr, len);\n\t/*\n\t * The XDR encode routine has set things up so that\n\t * the link text will be copied directly into the\n\t * buffer.  We just have to do overflow-checking,\n\t * and and null-terminate the text (the VFS expects\n\t * null-termination).\n\t */\n\tkaddr = (char *)kmap_atomic(rcvbuf->pages[0], KM_USER0);\n\tkaddr[len+rcvbuf->page_base] = '\\0';\n\tkunmap_atomic(kaddr, KM_USER0);\n\treturn 0;\n}\n\nstatic int decode_remove(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)\n{\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_REMOVE);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_change_info(xdr, cinfo);\nout:\n\treturn status;\n}\n\nstatic int decode_rename(struct xdr_stream *xdr, struct nfs4_change_info *old_cinfo,\n\t      struct nfs4_change_info *new_cinfo)\n{\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_RENAME);\n\tif (status)\n\t\tgoto out;\n\tif ((status = decode_change_info(xdr, old_cinfo)))\n\t\tgoto out;\n\tstatus = decode_change_info(xdr, new_cinfo);\nout:\n\treturn status;\n}\n\nstatic int decode_renew(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_RENEW);\n}\n\nstatic int\ndecode_restorefh(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_RESTOREFH);\n}\n\nstatic int decode_getacl(struct xdr_stream *xdr, struct rpc_rqst *req,\n\t\tsize_t *acl_len)\n{\n\t__be32 *savep;\n\tuint32_t attrlen,\n\t\t bitmap[2] = {0};\n\tstruct kvec *iov = req->rq_rcv_buf.head;\n\tint status;\n\n\t*acl_len = 0;\n\tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n\t\tgoto out;\n\tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n\t\tgoto out;\n\tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n\t\tgoto out;\n\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_ACL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_ACL)) {\n\t\tsize_t hdrlen;\n\t\tu32 recvd;\n\n\t\t/* We ignore &savep and don't do consistency checks on\n\t\t * the attr length.  Let userspace figure it out.... */\n\t\thdrlen = (u8 *)xdr->p - (u8 *)iov->iov_base;\n\t\trecvd = req->rq_rcv_buf.len - hdrlen;\n\t\tif (attrlen > recvd) {\n\t\t\tdprintk(\"NFS: server cheating in getattr\"\n\t\t\t\t\t\" acl reply: attrlen %u > recvd %u\\n\",\n\t\t\t\t\tattrlen, recvd);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\txdr_read_pages(xdr, attrlen);\n\t\t*acl_len = attrlen;\n\t} else\n\t\tstatus = -EOPNOTSUPP;\n\nout:\n\treturn status;\n}\n\nstatic int\ndecode_savefh(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_SAVEFH);\n}\n\nstatic int decode_setattr(struct xdr_stream *xdr, struct nfs_setattrres *res)\n{\n\t__be32 *p;\n\tuint32_t bmlen;\n\tint status;\n\n        \n\tstatus = decode_op_hdr(xdr, OP_SETATTR);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(4);\n\tREAD32(bmlen);\n\tREAD_BUF(bmlen << 2);\n\treturn 0;\n}\n\nstatic int decode_setclientid(struct xdr_stream *xdr, struct nfs_client *clp)\n{\n\t__be32 *p;\n\tuint32_t opnum;\n\tint32_t nfserr;\n\n\tREAD_BUF(8);\n\tREAD32(opnum);\n\tif (opnum != OP_SETCLIENTID) {\n\t\tdprintk(\"nfs: decode_setclientid: Server returned operation\"\n\t\t\t       \t\" %d\\n\", opnum);\n\t\treturn -EIO;\n\t}\n\tREAD32(nfserr);\n\tif (nfserr == NFS_OK) {\n\t\tREAD_BUF(8 + NFS4_VERIFIER_SIZE);\n\t\tREAD64(clp->cl_clientid);\n\t\tCOPYMEM(clp->cl_confirm.data, NFS4_VERIFIER_SIZE);\n\t} else if (nfserr == NFSERR_CLID_INUSE) {\n\t\tuint32_t len;\n\n\t\t/* skip netid string */\n\t\tREAD_BUF(4);\n\t\tREAD32(len);\n\t\tREAD_BUF(len);\n\n\t\t/* skip uaddr string */\n\t\tREAD_BUF(4);\n\t\tREAD32(len);\n\t\tREAD_BUF(len);\n\t\treturn -NFSERR_CLID_INUSE;\n\t} else\n\t\treturn nfs4_stat_to_errno(nfserr);\n\n\treturn 0;\n}\n\nstatic int decode_setclientid_confirm(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_SETCLIENTID_CONFIRM);\n}\n\nstatic int decode_write(struct xdr_stream *xdr, struct nfs_writeres *res)\n{\n\t__be32 *p;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_WRITE);\n\tif (status)\n\t\treturn status;\n\n\tREAD_BUF(16);\n\tREAD32(res->count);\n\tREAD32(res->verf->committed);\n\tCOPYMEM(res->verf->verifier, 8);\n\treturn 0;\n}\n\nstatic int decode_delegreturn(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_DELEGRETURN);\n}\n\n/*\n * Decode OPEN_DOWNGRADE response\n */\nstatic int nfs4_xdr_dec_open_downgrade(struct rpc_rqst *rqstp, __be32 *p, struct nfs_closeres *res)\n{\n        struct xdr_stream xdr;\n        struct compound_hdr hdr;\n        int status;\n\n        xdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n        status = decode_compound_hdr(&xdr, &hdr);\n        if (status)\n                goto out;\n        status = decode_putfh(&xdr);\n        if (status)\n                goto out;\n        status = decode_open_downgrade(&xdr, res);\n\tif (status != 0)\n\t\tgoto out;\n\tdecode_getfattr(&xdr, res->fattr, res->server);\nout:\n        return status;\n}\n\n/*\n * END OF \"GENERIC\" DECODE ROUTINES.\n */\n\n/*\n * Decode ACCESS response\n */\nstatic int nfs4_xdr_dec_access(struct rpc_rqst *rqstp, __be32 *p, struct nfs4_accessres *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\t\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tif ((status = decode_compound_hdr(&xdr, &hdr)) != 0)\n\t\tgoto out;\n\tstatus = decode_putfh(&xdr);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = decode_access(&xdr, res);\n\tif (status != 0)\n\t\tgoto out;\n\tdecode_getfattr(&xdr, res->fattr, res->server);\nout:\n\treturn status;\n}\n\n/*\n * Decode LOOKUP response\n */\nstatic int nfs4_xdr_dec_lookup(struct rpc_rqst *rqstp, __be32 *p, struct nfs4_lookup_res *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\t\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tif ((status = decode_compound_hdr(&xdr, &hdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_putfh(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_lookup(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_getfh(&xdr, res->fh)) != 0)\n\t\tgoto out;\n\tstatus = decode_getfattr(&xdr, res->fattr, res->server);\nout:\n\treturn status;\n}\n\n/*\n * Decode LOOKUP_ROOT response\n */\nstatic int nfs4_xdr_dec_lookup_root(struct rpc_rqst *rqstp, __be32 *p, struct nfs4_lookup_res *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\t\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tif ((status = decode_compound_hdr(&xdr, &hdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_putrootfh(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_getfh(&xdr, res->fh)) == 0)\n\t\tstatus = decode_getfattr(&xdr, res->fattr, res->server);\nout:\n\treturn status;\n}\n\n/*\n * Decode REMOVE response\n */\nstatic int nfs4_xdr_dec_remove(struct rpc_rqst *rqstp, __be32 *p, struct nfs_removeres *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\t\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tif ((status = decode_compound_hdr(&xdr, &hdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_putfh(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_remove(&xdr, &res->cinfo)) != 0)\n\t\tgoto out;\n\tdecode_getfattr(&xdr, &res->dir_attr, res->server);\nout:\n\treturn status;\n}\n\n/*\n * Decode RENAME response\n */\nstatic int nfs4_xdr_dec_rename(struct rpc_rqst *rqstp, __be32 *p, struct nfs4_rename_res *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\t\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tif ((status = decode_compound_hdr(&xdr, &hdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_putfh(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_savefh(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_putfh(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_rename(&xdr, &res->old_cinfo, &res->new_cinfo)) != 0)\n\t\tgoto out;\n\t/* Current FH is target directory */\n\tif (decode_getfattr(&xdr, res->new_fattr, res->server) != 0)\n\t\tgoto out;\n\tif ((status = decode_restorefh(&xdr)) != 0)\n\t\tgoto out;\n\tdecode_getfattr(&xdr, res->old_fattr, res->server);\nout:\n\treturn status;\n}\n\n/*\n * Decode LINK response\n */\nstatic int nfs4_xdr_dec_link(struct rpc_rqst *rqstp, __be32 *p, struct nfs4_link_res *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\t\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tif ((status = decode_compound_hdr(&xdr, &hdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_putfh(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_savefh(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_putfh(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_link(&xdr, &res->cinfo)) != 0)\n\t\tgoto out;\n\t/*\n\t * Note order: OP_LINK leaves the directory as the current\n\t *             filehandle.\n\t */\n\tif (decode_getfattr(&xdr, res->dir_attr, res->server) != 0)\n\t\tgoto out;\n\tif ((status = decode_restorefh(&xdr)) != 0)\n\t\tgoto out;\n\tdecode_getfattr(&xdr, res->fattr, res->server);\nout:\n\treturn status;\n}\n\n/*\n * Decode CREATE response\n */\nstatic int nfs4_xdr_dec_create(struct rpc_rqst *rqstp, __be32 *p, struct nfs4_create_res *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\t\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tif ((status = decode_compound_hdr(&xdr, &hdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_putfh(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_savefh(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_create(&xdr,&res->dir_cinfo)) != 0)\n\t\tgoto out;\n\tif ((status = decode_getfh(&xdr, res->fh)) != 0)\n\t\tgoto out;\n\tif (decode_getfattr(&xdr, res->fattr, res->server) != 0)\n\t\tgoto out;\n\tif ((status = decode_restorefh(&xdr)) != 0)\n\t\tgoto out;\n\tdecode_getfattr(&xdr, res->dir_fattr, res->server);\nout:\n\treturn status;\n}\n\n/*\n * Decode SYMLINK response\n */\nstatic int nfs4_xdr_dec_symlink(struct rpc_rqst *rqstp, __be32 *p, struct nfs4_create_res *res)\n{\n\treturn nfs4_xdr_dec_create(rqstp, p, res);\n}\n\n/*\n * Decode GETATTR response\n */\nstatic int nfs4_xdr_dec_getattr(struct rpc_rqst *rqstp, __be32 *p, struct nfs4_getattr_res *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\t\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(&xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getfattr(&xdr, res->fattr, res->server);\nout:\n\treturn status;\n\n}\n\n/*\n * Encode an SETACL request\n */\nstatic int\nnfs4_xdr_enc_setacl(struct rpc_rqst *req, __be32 *p, struct nfs_setaclargs *args)\n{\n        struct xdr_stream xdr;\n        struct compound_hdr hdr = {\n                .nops   = 2,\n        };\n        int status;\n\n        xdr_init_encode(&xdr, &req->rq_snd_buf, p);\n        encode_compound_hdr(&xdr, &hdr);\n        status = encode_putfh(&xdr, args->fh);\n        if (status)\n                goto out;\n        status = encode_setacl(&xdr, args);\nout:\n        return status;\n}\n/*\n * Decode SETACL response\n */\nstatic int\nnfs4_xdr_dec_setacl(struct rpc_rqst *rqstp, __be32 *p, void *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(&xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_setattr(&xdr, res);\nout:\n\treturn status;\n}\n\n/*\n * Decode GETACL response\n */\nstatic int\nnfs4_xdr_dec_getacl(struct rpc_rqst *rqstp, __be32 *p, size_t *acl_len)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(&xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getacl(&xdr, rqstp, acl_len);\n\nout:\n\treturn status;\n}\n\n/*\n * Decode CLOSE response\n */\nstatic int nfs4_xdr_dec_close(struct rpc_rqst *rqstp, __be32 *p, struct nfs_closeres *res)\n{\n        struct xdr_stream xdr;\n        struct compound_hdr hdr;\n        int status;\n\n        xdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n        status = decode_compound_hdr(&xdr, &hdr);\n        if (status)\n                goto out;\n        status = decode_putfh(&xdr);\n        if (status)\n                goto out;\n        status = decode_close(&xdr, res);\n\tif (status != 0)\n\t\tgoto out;\n\t/*\n\t * Note: Server may do delete on close for this file\n\t * \tin which case the getattr call will fail with\n\t * \tan ESTALE error. Shouldn't be a problem,\n\t * \tthough, since fattr->valid will remain unset.\n\t */\n\tdecode_getfattr(&xdr, res->fattr, res->server);\nout:\n        return status;\n}\n\n/*\n * Decode OPEN response\n */\nstatic int nfs4_xdr_dec_open(struct rpc_rqst *rqstp, __be32 *p, struct nfs_openres *res)\n{\n        struct xdr_stream xdr;\n        struct compound_hdr hdr;\n        int status;\n\n        xdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n        status = decode_compound_hdr(&xdr, &hdr);\n        if (status)\n                goto out;\n        status = decode_putfh(&xdr);\n        if (status)\n                goto out;\n        status = decode_savefh(&xdr);\n\tif (status)\n\t\tgoto out;\n        status = decode_open(&xdr, res);\n        if (status)\n                goto out;\n\tif (decode_getfh(&xdr, &res->fh) != 0)\n\t\tgoto out;\n\tif (decode_getfattr(&xdr, res->f_attr, res->server) != 0)\n\t\tgoto out;\n\tif (decode_restorefh(&xdr) != 0)\n\t\tgoto out;\n\tdecode_getfattr(&xdr, res->dir_attr, res->server);\nout:\n        return status;\n}\n\n/*\n * Decode OPEN_CONFIRM response\n */\nstatic int nfs4_xdr_dec_open_confirm(struct rpc_rqst *rqstp, __be32 *p, struct nfs_open_confirmres *res)\n{\n        struct xdr_stream xdr;\n        struct compound_hdr hdr;\n        int status;\n\n        xdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n        status = decode_compound_hdr(&xdr, &hdr);\n        if (status)\n                goto out;\n        status = decode_putfh(&xdr);\n        if (status)\n                goto out;\n        status = decode_open_confirm(&xdr, res);\nout:\n        return status;\n}\n\n/*\n * Decode OPEN response\n */\nstatic int nfs4_xdr_dec_open_noattr(struct rpc_rqst *rqstp, __be32 *p, struct nfs_openres *res)\n{\n        struct xdr_stream xdr;\n        struct compound_hdr hdr;\n        int status;\n\n        xdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n        status = decode_compound_hdr(&xdr, &hdr);\n        if (status)\n                goto out;\n        status = decode_putfh(&xdr);\n        if (status)\n                goto out;\n        status = decode_open(&xdr, res);\n        if (status)\n                goto out;\n\tdecode_getfattr(&xdr, res->f_attr, res->server);\nout:\n        return status;\n}\n\n/*\n * Decode SETATTR response\n */\nstatic int nfs4_xdr_dec_setattr(struct rpc_rqst *rqstp, __be32 *p, struct nfs_setattrres *res)\n{\n        struct xdr_stream xdr;\n        struct compound_hdr hdr;\n        int status;\n\n        xdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n        status = decode_compound_hdr(&xdr, &hdr);\n        if (status)\n                goto out;\n        status = decode_putfh(&xdr);\n        if (status)\n                goto out;\n        status = decode_setattr(&xdr, res);\n        if (status)\n                goto out;\n\tstatus = decode_getfattr(&xdr, res->fattr, res->server);\n\tif (status == NFS4ERR_DELAY)\n\t\tstatus = 0;\nout:\n        return status;\n}\n\n/*\n * Decode LOCK response\n */\nstatic int nfs4_xdr_dec_lock(struct rpc_rqst *rqstp, __be32 *p, struct nfs_lock_res *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(&xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_lock(&xdr, res);\nout:\n\treturn status;\n}\n\n/*\n * Decode LOCKT response\n */\nstatic int nfs4_xdr_dec_lockt(struct rpc_rqst *rqstp, __be32 *p, struct nfs_lockt_res *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(&xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_lockt(&xdr, res);\nout:\n\treturn status;\n}\n\n/*\n * Decode LOCKU response\n */\nstatic int nfs4_xdr_dec_locku(struct rpc_rqst *rqstp, __be32 *p, struct nfs_locku_res *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(&xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_locku(&xdr, res);\nout:\n\treturn status;\n}\n\n/*\n * Decode READLINK response\n */\nstatic int nfs4_xdr_dec_readlink(struct rpc_rqst *rqstp, __be32 *p, void *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(&xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_readlink(&xdr, rqstp);\nout:\n\treturn status;\n}\n\n/*\n * Decode READDIR response\n */\nstatic int nfs4_xdr_dec_readdir(struct rpc_rqst *rqstp, __be32 *p, struct nfs4_readdir_res *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(&xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_readdir(&xdr, rqstp, res);\nout:\n\treturn status;\n}\n\n/*\n * Decode Read response\n */\nstatic int nfs4_xdr_dec_read(struct rpc_rqst *rqstp, __be32 *p, struct nfs_readres *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(&xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_read(&xdr, rqstp, res);\n\tif (!status)\n\t\tstatus = res->count;\nout:\n\treturn status;\n}\n\n/*\n * Decode WRITE response\n */\nstatic int nfs4_xdr_dec_write(struct rpc_rqst *rqstp, __be32 *p, struct nfs_writeres *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(&xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_write(&xdr, res);\n\tif (status)\n\t\tgoto out;\n\tdecode_getfattr(&xdr, res->fattr, res->server);\n\tif (!status)\n\t\tstatus = res->count;\nout:\n\treturn status;\n}\n\n/*\n * Decode COMMIT response\n */\nstatic int nfs4_xdr_dec_commit(struct rpc_rqst *rqstp, __be32 *p, struct nfs_writeres *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(&xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_commit(&xdr, res);\n\tif (status)\n\t\tgoto out;\n\tdecode_getfattr(&xdr, res->fattr, res->server);\nout:\n\treturn status;\n}\n\n/*\n * FSINFO request\n */\nstatic int nfs4_xdr_dec_fsinfo(struct rpc_rqst *req, __be32 *p, struct nfs_fsinfo *fsinfo)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &req->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_putfh(&xdr);\n\tif (!status)\n\t\tstatus = decode_fsinfo(&xdr, fsinfo);\n\tif (!status)\n\t\tstatus = nfs4_stat_to_errno(hdr.status);\n\treturn status;\n}\n\n/*\n * PATHCONF request\n */\nstatic int nfs4_xdr_dec_pathconf(struct rpc_rqst *req, __be32 *p, struct nfs_pathconf *pathconf)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &req->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_putfh(&xdr);\n\tif (!status)\n\t\tstatus = decode_pathconf(&xdr, pathconf);\n\treturn status;\n}\n\n/*\n * STATFS request\n */\nstatic int nfs4_xdr_dec_statfs(struct rpc_rqst *req, __be32 *p, struct nfs_fsstat *fsstat)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &req->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_putfh(&xdr);\n\tif (!status)\n\t\tstatus = decode_statfs(&xdr, fsstat);\n\treturn status;\n}\n\n/*\n * GETATTR_BITMAP request\n */\nstatic int nfs4_xdr_dec_server_caps(struct rpc_rqst *req, __be32 *p, struct nfs4_server_caps_res *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &req->rq_rcv_buf, p);\n\tif ((status = decode_compound_hdr(&xdr, &hdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_putfh(&xdr)) != 0)\n\t\tgoto out;\n\tstatus = decode_server_caps(&xdr, res);\nout:\n\treturn status;\n}\n\n/*\n * Decode RENEW response\n */\nstatic int nfs4_xdr_dec_renew(struct rpc_rqst *rqstp, __be32 *p, void *dummy)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_renew(&xdr);\n\treturn status;\n}\n\n/*\n * a SETCLIENTID request\n */\nstatic int nfs4_xdr_dec_setclientid(struct rpc_rqst *req, __be32 *p,\n\t\tstruct nfs_client *clp)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &req->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_setclientid(&xdr, clp);\n\tif (!status)\n\t\tstatus = nfs4_stat_to_errno(hdr.status);\n\treturn status;\n}\n\n/*\n * a SETCLIENTID_CONFIRM request\n */\nstatic int nfs4_xdr_dec_setclientid_confirm(struct rpc_rqst *req, __be32 *p, struct nfs_fsinfo *fsinfo)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &req->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_setclientid_confirm(&xdr);\n\tif (!status)\n\t\tstatus = decode_putrootfh(&xdr);\n\tif (!status)\n\t\tstatus = decode_fsinfo(&xdr, fsinfo);\n\tif (!status)\n\t\tstatus = nfs4_stat_to_errno(hdr.status);\n\treturn status;\n}\n\n/*\n * DELEGRETURN request\n */\nstatic int nfs4_xdr_dec_delegreturn(struct rpc_rqst *rqstp, __be32 *p, struct nfs4_delegreturnres *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = decode_putfh(&xdr);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = decode_delegreturn(&xdr);\n\tdecode_getfattr(&xdr, res->fattr, res->server);\nout:\n\treturn status;\n}\n\n/*\n * FS_LOCATIONS request\n */\nstatic int nfs4_xdr_dec_fs_locations(struct rpc_rqst *req, __be32 *p, struct nfs4_fs_locations *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &req->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (status != 0)\n\t\tgoto out;\n\tif ((status = decode_putfh(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_lookup(&xdr)) != 0)\n\t\tgoto out;\n\txdr_enter_page(&xdr, PAGE_SIZE);\n\tstatus = decode_getfattr(&xdr, &res->fattr, res->server);\nout:\n\treturn status;\n}\n\n__be32 *nfs4_decode_dirent(__be32 *p, struct nfs_entry *entry, int plus)\n{\n\tuint32_t bitmap[2] = {0};\n\tuint32_t len;\n\n\tif (!*p++) {\n\t\tif (!*p)\n\t\t\treturn ERR_PTR(-EAGAIN);\n\t\tentry->eof = 1;\n\t\treturn ERR_PTR(-EBADCOOKIE);\n\t}\n\n\tentry->prev_cookie = entry->cookie;\n\tp = xdr_decode_hyper(p, &entry->cookie);\n\tentry->len = ntohl(*p++);\n\tentry->name = (const char *) p;\n\tp += XDR_QUADLEN(entry->len);\n\n\t/*\n\t * In case the server doesn't return an inode number,\n\t * we fake one here.  (We don't use inode number 0,\n\t * since glibc seems to choke on it...)\n\t */\n\tentry->ino = 1;\n\n\tlen = ntohl(*p++);\t\t/* bitmap length */\n\tif (len-- > 0) {\n\t\tbitmap[0] = ntohl(*p++);\n\t\tif (len-- > 0) {\n\t\t\tbitmap[1] = ntohl(*p++);\n\t\t\tp += len;\n\t\t}\n\t}\n\tlen = XDR_QUADLEN(ntohl(*p++));\t/* attribute buffer length */\n\tif (len > 0) {\n\t\tif (bitmap[0] & FATTR4_WORD0_RDATTR_ERROR) {\n\t\t\tbitmap[0] &= ~FATTR4_WORD0_RDATTR_ERROR;\n\t\t\t/* Ignore the return value of rdattr_error for now */\n\t\t\tp++;\n\t\t\tlen--;\n\t\t}\n\t\tif (bitmap[0] == 0 && bitmap[1] == FATTR4_WORD1_MOUNTED_ON_FILEID)\n\t\t\txdr_decode_hyper(p, &entry->ino);\n\t\telse if (bitmap[0] == FATTR4_WORD0_FILEID)\n\t\t\txdr_decode_hyper(p, &entry->ino);\n\t\tp += len;\n\t}\n\n\tentry->eof = !p[0] && p[1];\n\treturn p;\n}\n\n/*\n * We need to translate between nfs status return values and\n * the local errno values which may not be the same.\n */\nstatic struct {\n\tint stat;\n\tint errno;\n} nfs_errtbl[] = {\n\t{ NFS4_OK,\t\t0\t\t},\n\t{ NFS4ERR_PERM,\t\t-EPERM\t\t},\n\t{ NFS4ERR_NOENT,\t-ENOENT\t\t},\n\t{ NFS4ERR_IO,\t\t-errno_NFSERR_IO},\n\t{ NFS4ERR_NXIO,\t\t-ENXIO\t\t},\n\t{ NFS4ERR_ACCESS,\t-EACCES\t\t},\n\t{ NFS4ERR_EXIST,\t-EEXIST\t\t},\n\t{ NFS4ERR_XDEV,\t\t-EXDEV\t\t},\n\t{ NFS4ERR_NOTDIR,\t-ENOTDIR\t},\n\t{ NFS4ERR_ISDIR,\t-EISDIR\t\t},\n\t{ NFS4ERR_INVAL,\t-EINVAL\t\t},\n\t{ NFS4ERR_FBIG,\t\t-EFBIG\t\t},\n\t{ NFS4ERR_NOSPC,\t-ENOSPC\t\t},\n\t{ NFS4ERR_ROFS,\t\t-EROFS\t\t},\n\t{ NFS4ERR_MLINK,\t-EMLINK\t\t},\n\t{ NFS4ERR_NAMETOOLONG,\t-ENAMETOOLONG\t},\n\t{ NFS4ERR_NOTEMPTY,\t-ENOTEMPTY\t},\n\t{ NFS4ERR_DQUOT,\t-EDQUOT\t\t},\n\t{ NFS4ERR_STALE,\t-ESTALE\t\t},\n\t{ NFS4ERR_BADHANDLE,\t-EBADHANDLE\t},\n\t{ NFS4ERR_BADOWNER,\t-EINVAL\t\t},\n\t{ NFS4ERR_BADNAME,\t-EINVAL\t\t},\n\t{ NFS4ERR_BAD_COOKIE,\t-EBADCOOKIE\t},\n\t{ NFS4ERR_NOTSUPP,\t-ENOTSUPP\t},\n\t{ NFS4ERR_TOOSMALL,\t-ETOOSMALL\t},\n\t{ NFS4ERR_SERVERFAULT,\t-ESERVERFAULT\t},\n\t{ NFS4ERR_BADTYPE,\t-EBADTYPE\t},\n\t{ NFS4ERR_LOCKED,\t-EAGAIN\t\t},\n\t{ NFS4ERR_RESOURCE,\t-EREMOTEIO\t},\n\t{ NFS4ERR_SYMLINK,\t-ELOOP\t\t},\n\t{ NFS4ERR_OP_ILLEGAL,\t-EOPNOTSUPP\t},\n\t{ NFS4ERR_DEADLOCK,\t-EDEADLK\t},\n\t{ NFS4ERR_WRONGSEC,\t-EPERM\t\t}, /* FIXME: this needs\n\t\t\t\t\t\t    * to be handled by a\n\t\t\t\t\t\t    * middle-layer.\n\t\t\t\t\t\t    */\n\t{ -1,\t\t\t-EIO\t\t}\n};\n\n/*\n * Convert an NFS error code to a local one.\n * This one is used jointly by NFSv2 and NFSv3.\n */\nstatic int\nnfs4_stat_to_errno(int stat)\n{\n\tint i;\n\tfor (i = 0; nfs_errtbl[i].stat != -1; i++) {\n\t\tif (nfs_errtbl[i].stat == stat)\n\t\t\treturn nfs_errtbl[i].errno;\n\t}\n\tif (stat <= 10000 || stat > 10100) {\n\t\t/* The server is looney tunes. */\n\t\treturn -ESERVERFAULT;\n\t}\n\t/* If we cannot translate the error, the recovery routines should\n\t * handle it.\n\t * Note: remaining NFSv4 error codes have values > 10000, so should\n\t * not conflict with native Linux error codes.\n\t */\n\treturn -stat;\n}\n\n#define PROC(proc, argtype, restype)\t\t\t\t\\\n[NFSPROC4_CLNT_##proc] = {\t\t\t\t\t\\\n\t.p_proc   = NFSPROC4_COMPOUND,\t\t\t\t\\\n\t.p_encode = (kxdrproc_t) nfs4_xdr_##argtype,\t\t\\\n\t.p_decode = (kxdrproc_t) nfs4_xdr_##restype,\t\t\\\n\t.p_arglen = NFS4_##argtype##_sz,\t\t\t\\\n\t.p_replen = NFS4_##restype##_sz,\t\t\t\\\n\t.p_statidx = NFSPROC4_CLNT_##proc,\t\t\t\\\n\t.p_name   = #proc,\t\t\t\t\t\\\n    }\n\nstruct rpc_procinfo\tnfs4_procedures[] = {\n  PROC(READ,\t\tenc_read,\tdec_read),\n  PROC(WRITE,\t\tenc_write,\tdec_write),\n  PROC(COMMIT,\t\tenc_commit,\tdec_commit),\n  PROC(OPEN,\t\tenc_open,\tdec_open),\n  PROC(OPEN_CONFIRM,\tenc_open_confirm,\tdec_open_confirm),\n  PROC(OPEN_NOATTR,\tenc_open_noattr,\tdec_open_noattr),\n  PROC(OPEN_DOWNGRADE,\tenc_open_downgrade,\tdec_open_downgrade),\n  PROC(CLOSE,\t\tenc_close,\tdec_close),\n  PROC(SETATTR,\t\tenc_setattr,\tdec_setattr),\n  PROC(FSINFO,\t\tenc_fsinfo,\tdec_fsinfo),\n  PROC(RENEW,\t\tenc_renew,\tdec_renew),\n  PROC(SETCLIENTID,\tenc_setclientid,\tdec_setclientid),\n  PROC(SETCLIENTID_CONFIRM,\tenc_setclientid_confirm,\tdec_setclientid_confirm),\n  PROC(LOCK,            enc_lock,       dec_lock),\n  PROC(LOCKT,           enc_lockt,      dec_lockt),\n  PROC(LOCKU,           enc_locku,      dec_locku),\n  PROC(ACCESS,\t\tenc_access,\tdec_access),\n  PROC(GETATTR,\t\tenc_getattr,\tdec_getattr),\n  PROC(LOOKUP,\t\tenc_lookup,\tdec_lookup),\n  PROC(LOOKUP_ROOT,\tenc_lookup_root,\tdec_lookup_root),\n  PROC(REMOVE,\t\tenc_remove,\tdec_remove),\n  PROC(RENAME,\t\tenc_rename,\tdec_rename),\n  PROC(LINK,\t\tenc_link,\tdec_link),\n  PROC(SYMLINK,\t\tenc_symlink,\tdec_symlink),\n  PROC(CREATE,\t\tenc_create,\tdec_create),\n  PROC(PATHCONF,\tenc_pathconf,\tdec_pathconf),\n  PROC(STATFS,\t\tenc_statfs,\tdec_statfs),\n  PROC(READLINK,\tenc_readlink,\tdec_readlink),\n  PROC(READDIR,\t\tenc_readdir,\tdec_readdir),\n  PROC(SERVER_CAPS,\tenc_server_caps, dec_server_caps),\n  PROC(DELEGRETURN,\tenc_delegreturn, dec_delegreturn),\n  PROC(GETACL,\t\tenc_getacl,\tdec_getacl),\n  PROC(SETACL,\t\tenc_setacl,\tdec_setacl),\n  PROC(FS_LOCATIONS,\tenc_fs_locations, dec_fs_locations),\n};\n\nstruct rpc_version\t\tnfs_version4 = {\n\t.number\t\t\t= 4,\n\t.nrprocs\t\t= ARRAY_SIZE(nfs4_procedures),\n\t.procs\t\t\t= nfs4_procedures\n};\n\n/*\n * Local variables:\n *  c-basic-offset: 8\n * End:\n */\n", "/*\n *  linux/include/linux/nfs_fs.h\n *\n *  Copyright (C) 1992  Rick Sladkey\n *\n *  OS-specific nfs filesystem definitions and declarations\n */\n\n#ifndef _LINUX_NFS_FS_H\n#define _LINUX_NFS_FS_H\n\n#include <linux/magic.h>\n\n/* Default timeout values */\n#define NFS_DEF_UDP_TIMEO\t(11)\n#define NFS_DEF_UDP_RETRANS\t(3)\n#define NFS_DEF_TCP_TIMEO\t(600)\n#define NFS_DEF_TCP_RETRANS\t(2)\n\n#define NFS_MAX_UDP_TIMEOUT\t(60*HZ)\n#define NFS_MAX_TCP_TIMEOUT\t(600*HZ)\n\n#define NFS_DEF_ACREGMIN\t(3)\n#define NFS_DEF_ACREGMAX\t(60)\n#define NFS_DEF_ACDIRMIN\t(30)\n#define NFS_DEF_ACDIRMAX\t(60)\n\n/*\n * When flushing a cluster of dirty pages, there can be different\n * strategies:\n */\n#define FLUSH_SYNC\t\t1\t/* file being synced, or contention */\n#define FLUSH_STABLE\t\t4\t/* commit to stable storage */\n#define FLUSH_LOWPRI\t\t8\t/* low priority background flush */\n#define FLUSH_HIGHPRI\t\t16\t/* high priority memory reclaim flush */\n#define FLUSH_NOCOMMIT\t\t32\t/* Don't send the NFSv3/v4 COMMIT */\n#define FLUSH_INVALIDATE\t64\t/* Invalidate the page cache */\n#define FLUSH_NOWRITEPAGE\t128\t/* Don't call writepage() */\n\n#ifdef __KERNEL__\n\n#include <linux/in.h>\n#include <linux/kref.h>\n#include <linux/mm.h>\n#include <linux/pagemap.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/wait.h>\n\n#include <linux/sunrpc/debug.h>\n#include <linux/sunrpc/auth.h>\n#include <linux/sunrpc/clnt.h>\n\n#include <linux/nfs.h>\n#include <linux/nfs2.h>\n#include <linux/nfs3.h>\n#include <linux/nfs4.h>\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs_sb.h>\n\n#include <linux/mempool.h>\n\n/*\n * These are the default flags for swap requests\n */\n#define NFS_RPC_SWAPFLAGS\t\t(RPC_TASK_SWAPPER|RPC_TASK_ROOTCREDS)\n\n/*\n * NFSv3/v4 Access mode cache entry\n */\nstruct nfs_access_entry {\n\tstruct rb_node\t\trb_node;\n\tstruct list_head\tlru;\n\tunsigned long\t\tjiffies;\n\tstruct rpc_cred *\tcred;\n\tint\t\t\tmask;\n};\n\nstruct nfs4_state;\nstruct nfs_open_context {\n\tatomic_t count;\n\tstruct path path;\n\tstruct rpc_cred *cred;\n\tstruct nfs4_state *state;\n\tfl_owner_t lockowner;\n\tint mode;\n\n\tunsigned long flags;\n#define NFS_CONTEXT_ERROR_WRITE\t\t(0)\n\tint error;\n\n\tstruct list_head list;\n\n\t__u64 dir_cookie;\n};\n\n/*\n * NFSv4 delegation\n */\nstruct nfs_delegation;\n\nstruct posix_acl;\n\n/*\n * nfs fs inode data in memory\n */\nstruct nfs_inode {\n\t/*\n\t * The 64bit 'inode number'\n\t */\n\t__u64 fileid;\n\n\t/*\n\t * NFS file handle\n\t */\n\tstruct nfs_fh\t\tfh;\n\n\t/*\n\t * Various flags\n\t */\n\tunsigned long\t\tflags;\t\t\t/* atomic bit ops */\n\tunsigned long\t\tcache_validity;\t\t/* bit mask */\n\n\t/*\n\t * read_cache_jiffies is when we started read-caching this inode.\n\t * attrtimeo is for how long the cached information is assumed\n\t * to be valid. A successful attribute revalidation doubles\n\t * attrtimeo (up to acregmax/acdirmax), a failure resets it to\n\t * acregmin/acdirmin.\n\t *\n\t * We need to revalidate the cached attrs for this inode if\n\t *\n\t *\tjiffies - read_cache_jiffies > attrtimeo\n\t */\n\tunsigned long\t\tread_cache_jiffies;\n\tunsigned long\t\tattrtimeo;\n\tunsigned long\t\tattrtimeo_timestamp;\n\t__u64\t\t\tchange_attr;\t\t/* v4 only */\n\n\tunsigned long\t\tattr_gencount;\n\t/* \"Generation counter\" for the attribute cache. This is\n\t * bumped whenever we update the metadata on the\n\t * server.\n\t */\n\tunsigned long\t\tcache_change_attribute;\n\n\tstruct rb_root\t\taccess_cache;\n\tstruct list_head\taccess_cache_entry_lru;\n\tstruct list_head\taccess_cache_inode_lru;\n#ifdef CONFIG_NFS_V3_ACL\n\tstruct posix_acl\t*acl_access;\n\tstruct posix_acl\t*acl_default;\n#endif\n\n\t/*\n\t * This is the cookie verifier used for NFSv3 readdir\n\t * operations\n\t */\n\t__be32\t\t\tcookieverf[2];\n\n\t/*\n\t * This is the list of dirty unwritten pages.\n\t */\n\tstruct radix_tree_root\tnfs_page_tree;\n\n\tunsigned long\t\tncommit,\n\t\t\t\tnpages;\n\n\t/* Open contexts for shared mmap writes */\n\tstruct list_head\topen_files;\n\n\t/* Number of in-flight sillydelete RPC calls */\n\tatomic_t\t\tsilly_count;\n\t/* List of deferred sillydelete requests */\n\tstruct hlist_head\tsilly_list;\n\twait_queue_head_t\twaitqueue;\n\n#ifdef CONFIG_NFS_V4\n\tstruct nfs4_cached_acl\t*nfs4_acl;\n        /* NFSv4 state */\n\tstruct list_head\topen_states;\n\tstruct nfs_delegation\t*delegation;\n\tfmode_t\t\t\t delegation_state;\n\tstruct rw_semaphore\trwsem;\n#endif /* CONFIG_NFS_V4*/\n\tstruct inode\t\tvfs_inode;\n};\n\n/*\n * Cache validity bit flags\n */\n#define NFS_INO_INVALID_ATTR\t0x0001\t\t/* cached attrs are invalid */\n#define NFS_INO_INVALID_DATA\t0x0002\t\t/* cached data is invalid */\n#define NFS_INO_INVALID_ATIME\t0x0004\t\t/* cached atime is invalid */\n#define NFS_INO_INVALID_ACCESS\t0x0008\t\t/* cached access cred invalid */\n#define NFS_INO_INVALID_ACL\t0x0010\t\t/* cached acls are invalid */\n#define NFS_INO_REVAL_PAGECACHE\t0x0020\t\t/* must revalidate pagecache */\n#define NFS_INO_REVAL_FORCED\t0x0040\t\t/* force revalidation ignoring a delegation */\n\n/*\n * Bit offsets in flags field\n */\n#define NFS_INO_ADVISE_RDPLUS\t(0)\t\t/* advise readdirplus */\n#define NFS_INO_STALE\t\t(1)\t\t/* possible stale inode */\n#define NFS_INO_ACL_LRU_SET\t(2)\t\t/* Inode is on the LRU list */\n#define NFS_INO_MOUNTPOINT\t(3)\t\t/* inode is remote mountpoint */\n\nstatic inline struct nfs_inode *NFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nfs_inode, vfs_inode);\n}\n\nstatic inline struct nfs_server *NFS_SB(const struct super_block *s)\n{\n\treturn (struct nfs_server *)(s->s_fs_info);\n}\n\nstatic inline struct nfs_fh *NFS_FH(const struct inode *inode)\n{\n\treturn &NFS_I(inode)->fh;\n}\n\nstatic inline struct nfs_server *NFS_SERVER(const struct inode *inode)\n{\n\treturn NFS_SB(inode->i_sb);\n}\n\nstatic inline struct rpc_clnt *NFS_CLIENT(const struct inode *inode)\n{\n\treturn NFS_SERVER(inode)->client;\n}\n\nstatic inline const struct nfs_rpc_ops *NFS_PROTO(const struct inode *inode)\n{\n\treturn NFS_SERVER(inode)->nfs_client->rpc_ops;\n}\n\nstatic inline __be32 *NFS_COOKIEVERF(const struct inode *inode)\n{\n\treturn NFS_I(inode)->cookieverf;\n}\n\nstatic inline unsigned NFS_MINATTRTIMEO(const struct inode *inode)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\treturn S_ISDIR(inode->i_mode) ? nfss->acdirmin : nfss->acregmin;\n}\n\nstatic inline unsigned NFS_MAXATTRTIMEO(const struct inode *inode)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\treturn S_ISDIR(inode->i_mode) ? nfss->acdirmax : nfss->acregmax;\n}\n\nstatic inline int NFS_STALE(const struct inode *inode)\n{\n\treturn test_bit(NFS_INO_STALE, &NFS_I(inode)->flags);\n}\n\nstatic inline __u64 NFS_FILEID(const struct inode *inode)\n{\n\treturn NFS_I(inode)->fileid;\n}\n\nstatic inline void set_nfs_fileid(struct inode *inode, __u64 fileid)\n{\n\tNFS_I(inode)->fileid = fileid;\n}\n\nstatic inline void nfs_mark_for_revalidate(struct inode *inode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tspin_lock(&inode->i_lock);\n\tnfsi->cache_validity |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_ACCESS;\n\tif (S_ISDIR(inode->i_mode))\n\t\tnfsi->cache_validity |= NFS_INO_REVAL_PAGECACHE|NFS_INO_INVALID_DATA;\n\tspin_unlock(&inode->i_lock);\n}\n\nstatic inline int nfs_server_capable(struct inode *inode, int cap)\n{\n\treturn NFS_SERVER(inode)->caps & cap;\n}\n\nstatic inline int NFS_USE_READDIRPLUS(struct inode *inode)\n{\n\treturn test_bit(NFS_INO_ADVISE_RDPLUS, &NFS_I(inode)->flags);\n}\n\nstatic inline void nfs_set_verifier(struct dentry * dentry, unsigned long verf)\n{\n\tdentry->d_time = verf;\n}\n\n/**\n * nfs_save_change_attribute - Returns the inode attribute change cookie\n * @dir - pointer to parent directory inode\n * The \"change attribute\" is updated every time we finish an operation\n * that will result in a metadata change on the server.\n */\nstatic inline unsigned long nfs_save_change_attribute(struct inode *dir)\n{\n\treturn NFS_I(dir)->cache_change_attribute;\n}\n\n/**\n * nfs_verify_change_attribute - Detects NFS remote directory changes\n * @dir - pointer to parent directory inode\n * @chattr - previously saved change attribute\n * Return \"false\" if the verifiers doesn't match the change attribute.\n * This would usually indicate that the directory contents have changed on\n * the server, and that any dentries need revalidating.\n */\nstatic inline int nfs_verify_change_attribute(struct inode *dir, unsigned long chattr)\n{\n\treturn chattr == NFS_I(dir)->cache_change_attribute;\n}\n\n/*\n * linux/fs/nfs/inode.c\n */\nextern int nfs_sync_mapping(struct address_space *mapping);\nextern void nfs_zap_mapping(struct inode *inode, struct address_space *mapping);\nextern void nfs_zap_caches(struct inode *);\nextern void nfs_invalidate_atime(struct inode *);\nextern struct inode *nfs_fhget(struct super_block *, struct nfs_fh *,\n\t\t\t\tstruct nfs_fattr *);\nextern int nfs_refresh_inode(struct inode *, struct nfs_fattr *);\nextern int nfs_post_op_update_inode(struct inode *inode, struct nfs_fattr *fattr);\nextern int nfs_post_op_update_inode_force_wcc(struct inode *inode, struct nfs_fattr *fattr);\nextern int nfs_getattr(struct vfsmount *, struct dentry *, struct kstat *);\nextern int nfs_permission(struct inode *, int);\nextern int nfs_open(struct inode *, struct file *);\nextern int nfs_release(struct inode *, struct file *);\nextern int nfs_attribute_timeout(struct inode *inode);\nextern int nfs_revalidate_inode(struct nfs_server *server, struct inode *inode);\nextern int __nfs_revalidate_inode(struct nfs_server *, struct inode *);\nextern int nfs_revalidate_mapping(struct inode *inode, struct address_space *mapping);\nextern int nfs_revalidate_mapping_nolock(struct inode *inode, struct address_space *mapping);\nextern int nfs_setattr(struct dentry *, struct iattr *);\nextern void nfs_setattr_update_inode(struct inode *inode, struct iattr *attr);\nextern struct nfs_open_context *get_nfs_open_context(struct nfs_open_context *ctx);\nextern void put_nfs_open_context(struct nfs_open_context *ctx);\nextern struct nfs_open_context *nfs_find_open_context(struct inode *inode, struct rpc_cred *cred, int mode);\nextern u64 nfs_compat_user_ino64(u64 fileid);\nextern void nfs_fattr_init(struct nfs_fattr *fattr);\n\n/* linux/net/ipv4/ipconfig.c: trims ip addr off front of name, too. */\nextern __be32 root_nfs_parse_addr(char *name); /*__init*/\nextern unsigned long nfs_inc_attr_generation_counter(void);\n\n/*\n * linux/fs/nfs/file.c\n */\nextern const struct inode_operations nfs_file_inode_operations;\n#ifdef CONFIG_NFS_V3\nextern const struct inode_operations nfs3_file_inode_operations;\n#endif /* CONFIG_NFS_V3 */\nextern const struct file_operations nfs_file_operations;\nextern const struct address_space_operations nfs_file_aops;\n\nstatic inline struct nfs_open_context *nfs_file_open_context(struct file *filp)\n{\n\treturn filp->private_data;\n}\n\nstatic inline struct rpc_cred *nfs_file_cred(struct file *file)\n{\n\tif (file != NULL) {\n\t\tstruct nfs_open_context *ctx =\n\t\t\tnfs_file_open_context(file);\n\t\tif (ctx)\n\t\t\treturn ctx->cred;\n\t}\n\treturn NULL;\n}\n\n/*\n * linux/fs/nfs/xattr.c\n */\n#ifdef CONFIG_NFS_V3_ACL\nextern ssize_t nfs3_listxattr(struct dentry *, char *, size_t);\nextern ssize_t nfs3_getxattr(struct dentry *, const char *, void *, size_t);\nextern int nfs3_setxattr(struct dentry *, const char *,\n\t\t\tconst void *, size_t, int);\nextern int nfs3_removexattr (struct dentry *, const char *name);\n#else\n# define nfs3_listxattr NULL\n# define nfs3_getxattr NULL\n# define nfs3_setxattr NULL\n# define nfs3_removexattr NULL\n#endif\n\n/*\n * linux/fs/nfs/direct.c\n */\nextern ssize_t nfs_direct_IO(int, struct kiocb *, const struct iovec *, loff_t,\n\t\t\tunsigned long);\nextern ssize_t nfs_file_direct_read(struct kiocb *iocb,\n\t\t\tconst struct iovec *iov, unsigned long nr_segs,\n\t\t\tloff_t pos);\nextern ssize_t nfs_file_direct_write(struct kiocb *iocb,\n\t\t\tconst struct iovec *iov, unsigned long nr_segs,\n\t\t\tloff_t pos);\n\n/*\n * linux/fs/nfs/dir.c\n */\nextern const struct inode_operations nfs_dir_inode_operations;\n#ifdef CONFIG_NFS_V3\nextern const struct inode_operations nfs3_dir_inode_operations;\n#endif /* CONFIG_NFS_V3 */\nextern const struct file_operations nfs_dir_operations;\nextern struct dentry_operations nfs_dentry_operations;\n\nextern void nfs_force_lookup_revalidate(struct inode *dir);\nextern int nfs_instantiate(struct dentry *dentry, struct nfs_fh *fh, struct nfs_fattr *fattr);\nextern int nfs_may_open(struct inode *inode, struct rpc_cred *cred, int openflags);\nextern void nfs_access_zap_cache(struct inode *inode);\n\n/*\n * linux/fs/nfs/symlink.c\n */\nextern const struct inode_operations nfs_symlink_inode_operations;\n\n/*\n * linux/fs/nfs/sysctl.c\n */\n#ifdef CONFIG_SYSCTL\nextern int nfs_register_sysctl(void);\nextern void nfs_unregister_sysctl(void);\n#else\n#define nfs_register_sysctl() 0\n#define nfs_unregister_sysctl() do { } while(0)\n#endif\n\n/*\n * linux/fs/nfs/namespace.c\n */\nextern const struct inode_operations nfs_mountpoint_inode_operations;\nextern const struct inode_operations nfs_referral_inode_operations;\nextern int nfs_mountpoint_expiry_timeout;\nextern void nfs_release_automount_timer(void);\n\n/*\n * linux/fs/nfs/unlink.c\n */\nextern int  nfs_async_unlink(struct inode *dir, struct dentry *dentry);\nextern void nfs_complete_unlink(struct dentry *dentry, struct inode *);\nextern void nfs_block_sillyrename(struct dentry *dentry);\nextern void nfs_unblock_sillyrename(struct dentry *dentry);\n\n/*\n * linux/fs/nfs/write.c\n */\nextern int  nfs_congestion_kb;\nextern int  nfs_writepage(struct page *page, struct writeback_control *wbc);\nextern int  nfs_writepages(struct address_space *, struct writeback_control *);\nextern int  nfs_flush_incompatible(struct file *file, struct page *page);\nextern int  nfs_updatepage(struct file *, struct page *, unsigned int, unsigned int);\nextern int nfs_writeback_done(struct rpc_task *, struct nfs_write_data *);\nextern void nfs_writedata_release(void *);\n\n/*\n * Try to write back everything synchronously (but check the\n * return value!)\n */\nextern long nfs_sync_mapping_wait(struct address_space *, struct writeback_control *, int);\nextern int nfs_wb_all(struct inode *inode);\nextern int nfs_wb_nocommit(struct inode *inode);\nextern int nfs_wb_page(struct inode *inode, struct page* page);\nextern int nfs_wb_page_cancel(struct inode *inode, struct page* page);\n#if defined(CONFIG_NFS_V3) || defined(CONFIG_NFS_V4)\nextern int  nfs_commit_inode(struct inode *, int);\nextern struct nfs_write_data *nfs_commitdata_alloc(void);\nextern void nfs_commit_free(struct nfs_write_data *wdata);\nextern void nfs_commitdata_release(void *wdata);\n#else\nstatic inline int\nnfs_commit_inode(struct inode *inode, int how)\n{\n\treturn 0;\n}\n#endif\n\nstatic inline int\nnfs_have_writebacks(struct inode *inode)\n{\n\treturn NFS_I(inode)->npages != 0;\n}\n\n/*\n * Allocate nfs_write_data structures\n */\nextern struct nfs_write_data *nfs_writedata_alloc(unsigned int npages);\n\n/*\n * linux/fs/nfs/read.c\n */\nextern int  nfs_readpage(struct file *, struct page *);\nextern int  nfs_readpages(struct file *, struct address_space *,\n\t\tstruct list_head *, unsigned);\nextern int  nfs_readpage_result(struct rpc_task *, struct nfs_read_data *);\nextern void nfs_readdata_release(void *data);\n\n/*\n * Allocate nfs_read_data structures\n */\nextern struct nfs_read_data *nfs_readdata_alloc(unsigned int npages);\n\n/*\n * linux/fs/nfs3proc.c\n */\n#ifdef CONFIG_NFS_V3_ACL\nextern struct posix_acl *nfs3_proc_getacl(struct inode *inode, int type);\nextern int nfs3_proc_setacl(struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);\nextern int nfs3_proc_set_default_acl(struct inode *dir, struct inode *inode,\n\t\tmode_t mode);\nextern void nfs3_forget_cached_acls(struct inode *inode);\n#else\nstatic inline int nfs3_proc_set_default_acl(struct inode *dir,\n\t\t\t\t\t    struct inode *inode,\n\t\t\t\t\t    mode_t mode)\n{\n\treturn 0;\n}\n\nstatic inline void nfs3_forget_cached_acls(struct inode *inode)\n{\n}\n#endif /* CONFIG_NFS_V3_ACL */\n\n/*\n * inline functions\n */\n\nstatic inline loff_t nfs_size_to_loff_t(__u64 size)\n{\n\tif (size > (__u64) OFFSET_MAX - 1)\n\t\treturn OFFSET_MAX - 1;\n\treturn (loff_t) size;\n}\n\nstatic inline ino_t\nnfs_fileid_to_ino_t(u64 fileid)\n{\n\tino_t ino = (ino_t) fileid;\n\tif (sizeof(ino_t) < sizeof(u64))\n\t\tino ^= fileid >> (sizeof(u64)-sizeof(ino_t)) * 8;\n\treturn ino;\n}\n\n/* NFS root */\n\nextern void * nfs_root_data(void);\n\n#define nfs_wait_event(clnt, wq, condition)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tint __retval = wait_event_killable(wq, condition);\t\t\\\n\t__retval;\t\t\t\t\t\t\t\\\n})\n\n#define NFS_JUKEBOX_RETRY_TIME (5 * HZ)\n\n#endif /* __KERNEL__ */\n\n/*\n * NFS debug flags\n */\n#define NFSDBG_VFS\t\t0x0001\n#define NFSDBG_DIRCACHE\t\t0x0002\n#define NFSDBG_LOOKUPCACHE\t0x0004\n#define NFSDBG_PAGECACHE\t0x0008\n#define NFSDBG_PROC\t\t0x0010\n#define NFSDBG_XDR\t\t0x0020\n#define NFSDBG_FILE\t\t0x0040\n#define NFSDBG_ROOT\t\t0x0080\n#define NFSDBG_CALLBACK\t\t0x0100\n#define NFSDBG_CLIENT\t\t0x0200\n#define NFSDBG_MOUNT\t\t0x0400\n#define NFSDBG_ALL\t\t0xFFFF\n\n#ifdef __KERNEL__\n\n/*\n * Enable debugging support for nfs client.\n * Requires RPC_DEBUG.\n */\n#ifdef RPC_DEBUG\n# define NFS_DEBUG\n#endif\n\n# undef ifdebug\n# ifdef NFS_DEBUG\n#  define ifdebug(fac)\t\tif (unlikely(nfs_debug & NFSDBG_##fac))\n# else\n#  define ifdebug(fac)\t\tif (0)\n# endif\n#endif /* __KERNEL */\n\n#endif\n", "#ifndef _LINUX_NFS_XDR_H\n#define _LINUX_NFS_XDR_H\n\n#include <linux/nfsacl.h>\n\n/*\n * To change the maximum rsize and wsize supported by the NFS client, adjust\n * NFS_MAX_FILE_IO_SIZE.  64KB is a typical maximum, but some servers can\n * support a megabyte or more.  The default is left at 4096 bytes, which is\n * reasonable for NFS over UDP.\n */\n#define NFS_MAX_FILE_IO_SIZE\t(1048576U)\n#define NFS_DEF_FILE_IO_SIZE\t(4096U)\n#define NFS_MIN_FILE_IO_SIZE\t(1024U)\n\nstruct nfs_fsid {\n\tuint64_t\t\tmajor;\n\tuint64_t\t\tminor;\n};\n\n/*\n * Helper for checking equality between 2 fsids.\n */\nstatic inline int nfs_fsid_equal(const struct nfs_fsid *a, const struct nfs_fsid *b)\n{\n\treturn a->major == b->major && a->minor == b->minor;\n}\n\nstruct nfs_fattr {\n\tunsigned short\t\tvalid;\t\t/* which fields are valid */\n\t__u64\t\t\tpre_size;\t/* pre_op_attr.size\t  */\n\tstruct timespec\t\tpre_mtime;\t/* pre_op_attr.mtime\t  */\n\tstruct timespec\t\tpre_ctime;\t/* pre_op_attr.ctime\t  */\n\tenum nfs_ftype\t\ttype;\t\t/* always use NFSv2 types */\n\t__u32\t\t\tmode;\n\t__u32\t\t\tnlink;\n\t__u32\t\t\tuid;\n\t__u32\t\t\tgid;\n\tdev_t\t\t\trdev;\n\t__u64\t\t\tsize;\n\tunion {\n\t\tstruct {\n\t\t\t__u32\tblocksize;\n\t\t\t__u32\tblocks;\n\t\t} nfs2;\n\t\tstruct {\n\t\t\t__u64\tused;\n\t\t} nfs3;\n\t} du;\n\tstruct nfs_fsid\t\tfsid;\n\t__u64\t\t\tfileid;\n\tstruct timespec\t\tatime;\n\tstruct timespec\t\tmtime;\n\tstruct timespec\t\tctime;\n\t__u32\t\t\tbitmap[2];\t/* NFSv4 returned attribute bitmap */\n\t__u64\t\t\tchange_attr;\t/* NFSv4 change attribute */\n\t__u64\t\t\tpre_change_attr;/* pre-op NFSv4 change attribute */\n\tunsigned long\t\ttime_start;\n\tunsigned long\t\tgencount;\n};\n\n#define NFS_ATTR_WCC\t\t0x0001\t\t/* pre-op WCC data    */\n#define NFS_ATTR_FATTR\t\t0x0002\t\t/* post-op attributes */\n#define NFS_ATTR_FATTR_V3\t0x0004\t\t/* NFSv3 attributes */\n#define NFS_ATTR_FATTR_V4\t0x0008\t\t/* NFSv4 change attribute */\n#define NFS_ATTR_WCC_V4\t\t0x0010\t\t/* pre-op change attribute */\n#define NFS_ATTR_FATTR_V4_REFERRAL\t0x0020\t\t/* NFSv4 referral */\n\n/*\n * Info on the file system\n */\nstruct nfs_fsinfo {\n\tstruct nfs_fattr\t*fattr; /* Post-op attributes */\n\t__u32\t\t\trtmax;\t/* max.  read transfer size */\n\t__u32\t\t\trtpref;\t/* pref. read transfer size */\n\t__u32\t\t\trtmult;\t/* reads should be multiple of this */\n\t__u32\t\t\twtmax;\t/* max.  write transfer size */\n\t__u32\t\t\twtpref;\t/* pref. write transfer size */\n\t__u32\t\t\twtmult;\t/* writes should be multiple of this */\n\t__u32\t\t\tdtpref;\t/* pref. readdir transfer size */\n\t__u64\t\t\tmaxfilesize;\n\t__u32\t\t\tlease_time; /* in seconds */\n};\n\nstruct nfs_fsstat {\n\tstruct nfs_fattr\t*fattr; /* Post-op attributes */\n\t__u64\t\t\ttbytes;\t/* total size in bytes */\n\t__u64\t\t\tfbytes;\t/* # of free bytes */\n\t__u64\t\t\tabytes;\t/* # of bytes available to user */\n\t__u64\t\t\ttfiles;\t/* # of files */\n\t__u64\t\t\tffiles;\t/* # of free files */\n\t__u64\t\t\tafiles;\t/* # of files available to user */\n};\n\nstruct nfs2_fsstat {\n\t__u32\t\t\ttsize;  /* Server transfer size */\n\t__u32\t\t\tbsize;  /* Filesystem block size */\n\t__u32\t\t\tblocks; /* No. of \"bsize\" blocks on filesystem */\n\t__u32\t\t\tbfree;  /* No. of free \"bsize\" blocks */\n\t__u32\t\t\tbavail; /* No. of available \"bsize\" blocks */\n};\n\nstruct nfs_pathconf {\n\tstruct nfs_fattr\t*fattr; /* Post-op attributes */\n\t__u32\t\t\tmax_link; /* max # of hard links */\n\t__u32\t\t\tmax_namelen; /* max name length */\n};\n\nstruct nfs4_change_info {\n\tu32\t\t\tatomic;\n\tu64\t\t\tbefore;\n\tu64\t\t\tafter;\n};\n\nstruct nfs_seqid;\n/*\n * Arguments to the open call.\n */\nstruct nfs_openargs {\n\tconst struct nfs_fh *\tfh;\n\tstruct nfs_seqid *\tseqid;\n\tint\t\t\topen_flags;\n\t__u64                   clientid;\n\t__u64                   id;\n\tunion {\n\t\tstruct iattr *  attrs;    /* UNCHECKED, GUARDED */\n\t\tnfs4_verifier   verifier; /* EXCLUSIVE */\n\t\tnfs4_stateid\tdelegation;\t\t/* CLAIM_DELEGATE_CUR */\n\t\tfmode_t\t\tdelegation_type;\t/* CLAIM_PREVIOUS */\n\t} u;\n\tconst struct qstr *\tname;\n\tconst struct nfs_server *server;\t /* Needed for ID mapping */\n\tconst u32 *\t\tbitmask;\n\t__u32\t\t\tclaim;\n};\n\nstruct nfs_openres {\n\tnfs4_stateid            stateid;\n\tstruct nfs_fh           fh;\n\tstruct nfs4_change_info\tcinfo;\n\t__u32                   rflags;\n\tstruct nfs_fattr *      f_attr;\n\tstruct nfs_fattr *      dir_attr;\n\tstruct nfs_seqid *\tseqid;\n\tconst struct nfs_server *server;\n\tfmode_t\t\t\tdelegation_type;\n\tnfs4_stateid\t\tdelegation;\n\t__u32\t\t\tdo_recall;\n\t__u64\t\t\tmaxsize;\n\t__u32\t\t\tattrset[NFS4_BITMAP_SIZE];\n};\n\n/*\n * Arguments to the open_confirm call.\n */\nstruct nfs_open_confirmargs {\n\tconst struct nfs_fh *\tfh;\n\tnfs4_stateid *\t\tstateid;\n\tstruct nfs_seqid *\tseqid;\n};\n\nstruct nfs_open_confirmres {\n\tnfs4_stateid            stateid;\n\tstruct nfs_seqid *\tseqid;\n};\n\n/*\n * Arguments to the close call.\n */\nstruct nfs_closeargs {\n\tstruct nfs_fh *         fh;\n\tnfs4_stateid *\t\tstateid;\n\tstruct nfs_seqid *\tseqid;\n\tint\t\t\topen_flags;\n\tconst u32 *\t\tbitmask;\n};\n\nstruct nfs_closeres {\n\tnfs4_stateid            stateid;\n\tstruct nfs_fattr *\tfattr;\n\tstruct nfs_seqid *\tseqid;\n\tconst struct nfs_server *server;\n};\n/*\n *  * Arguments to the lock,lockt, and locku call.\n *   */\nstruct nfs_lowner {\n\t__u64\t\t\tclientid;\n\t__u64\t\t\tid;\n};\n\nstruct nfs_lock_args {\n\tstruct nfs_fh *\t\tfh;\n\tstruct file_lock *\tfl;\n\tstruct nfs_seqid *\tlock_seqid;\n\tnfs4_stateid *\t\tlock_stateid;\n\tstruct nfs_seqid *\topen_seqid;\n\tnfs4_stateid *\t\topen_stateid;\n\tstruct nfs_lowner\tlock_owner;\n\tunsigned char\t\tblock : 1;\n\tunsigned char\t\treclaim : 1;\n\tunsigned char\t\tnew_lock_owner : 1;\n};\n\nstruct nfs_lock_res {\n\tnfs4_stateid\t\tstateid;\n\tstruct nfs_seqid *\tlock_seqid;\n\tstruct nfs_seqid *\topen_seqid;\n};\n\nstruct nfs_locku_args {\n\tstruct nfs_fh *\t\tfh;\n\tstruct file_lock *\tfl;\n\tstruct nfs_seqid *\tseqid;\n\tnfs4_stateid *\t\tstateid;\n};\n\nstruct nfs_locku_res {\n\tnfs4_stateid\t\tstateid;\n\tstruct nfs_seqid *\tseqid;\n};\n\nstruct nfs_lockt_args {\n\tstruct nfs_fh *\t\tfh;\n\tstruct file_lock *\tfl;\n\tstruct nfs_lowner\tlock_owner;\n};\n\nstruct nfs_lockt_res {\n\tstruct file_lock *\tdenied; /* LOCK, LOCKT failed */\n};\n\nstruct nfs4_delegreturnargs {\n\tconst struct nfs_fh *fhandle;\n\tconst nfs4_stateid *stateid;\n\tconst u32 * bitmask;\n};\n\nstruct nfs4_delegreturnres {\n\tstruct nfs_fattr * fattr;\n\tconst struct nfs_server *server;\n};\n\n/*\n * Arguments to the read call.\n */\nstruct nfs_readargs {\n\tstruct nfs_fh *\t\tfh;\n\tstruct nfs_open_context *context;\n\t__u64\t\t\toffset;\n\t__u32\t\t\tcount;\n\tunsigned int\t\tpgbase;\n\tstruct page **\t\tpages;\n};\n\nstruct nfs_readres {\n\tstruct nfs_fattr *\tfattr;\n\t__u32\t\t\tcount;\n\tint                     eof;\n};\n\n/*\n * Arguments to the write call.\n */\nstruct nfs_writeargs {\n\tstruct nfs_fh *\t\tfh;\n\tstruct nfs_open_context *context;\n\t__u64\t\t\toffset;\n\t__u32\t\t\tcount;\n\tenum nfs3_stable_how\tstable;\n\tunsigned int\t\tpgbase;\n\tstruct page **\t\tpages;\n\tconst u32 *\t\tbitmask;\n};\n\nstruct nfs_writeverf {\n\tenum nfs3_stable_how\tcommitted;\n\t__be32\t\t\tverifier[2];\n};\n\nstruct nfs_writeres {\n\tstruct nfs_fattr *\tfattr;\n\tstruct nfs_writeverf *\tverf;\n\t__u32\t\t\tcount;\n\tconst struct nfs_server *server;\n};\n\n/*\n * Common arguments to the unlink call\n */\nstruct nfs_removeargs {\n\tconst struct nfs_fh\t*fh;\n\tstruct qstr\t\tname;\n\tconst u32 *\t\tbitmask;\n};\n\nstruct nfs_removeres {\n\tconst struct nfs_server *server;\n\tstruct nfs4_change_info\tcinfo;\n\tstruct nfs_fattr\tdir_attr;\n};\n\n/*\n * Argument struct for decode_entry function\n */\nstruct nfs_entry {\n\t__u64\t\t\tino;\n\t__u64\t\t\tcookie,\n\t\t\t\tprev_cookie;\n\tconst char *\t\tname;\n\tunsigned int\t\tlen;\n\tint\t\t\teof;\n\tstruct nfs_fh *\t\tfh;\n\tstruct nfs_fattr *\tfattr;\n};\n\n/*\n * The following types are for NFSv2 only.\n */\nstruct nfs_sattrargs {\n\tstruct nfs_fh *\t\tfh;\n\tstruct iattr *\t\tsattr;\n};\n\nstruct nfs_diropargs {\n\tstruct nfs_fh *\t\tfh;\n\tconst char *\t\tname;\n\tunsigned int\t\tlen;\n};\n\nstruct nfs_createargs {\n\tstruct nfs_fh *\t\tfh;\n\tconst char *\t\tname;\n\tunsigned int\t\tlen;\n\tstruct iattr *\t\tsattr;\n};\n\nstruct nfs_renameargs {\n\tstruct nfs_fh *\t\tfromfh;\n\tconst char *\t\tfromname;\n\tunsigned int\t\tfromlen;\n\tstruct nfs_fh *\t\ttofh;\n\tconst char *\t\ttoname;\n\tunsigned int\t\ttolen;\n};\n\nstruct nfs_setattrargs {\n\tstruct nfs_fh *                 fh;\n\tnfs4_stateid                    stateid;\n\tstruct iattr *                  iap;\n\tconst struct nfs_server *\tserver; /* Needed for name mapping */\n\tconst u32 *\t\t\tbitmask;\n};\n\nstruct nfs_setaclargs {\n\tstruct nfs_fh *\t\t\tfh;\n\tsize_t\t\t\t\tacl_len;\n\tunsigned int\t\t\tacl_pgbase;\n\tstruct page **\t\t\tacl_pages;\n};\n\nstruct nfs_getaclargs {\n\tstruct nfs_fh *\t\t\tfh;\n\tsize_t\t\t\t\tacl_len;\n\tunsigned int\t\t\tacl_pgbase;\n\tstruct page **\t\t\tacl_pages;\n};\n\nstruct nfs_setattrres {\n\tstruct nfs_fattr *              fattr;\n\tconst struct nfs_server *\tserver;\n};\n\nstruct nfs_linkargs {\n\tstruct nfs_fh *\t\tfromfh;\n\tstruct nfs_fh *\t\ttofh;\n\tconst char *\t\ttoname;\n\tunsigned int\t\ttolen;\n};\n\nstruct nfs_symlinkargs {\n\tstruct nfs_fh *\t\tfromfh;\n\tconst char *\t\tfromname;\n\tunsigned int\t\tfromlen;\n\tstruct page **\t\tpages;\n\tunsigned int\t\tpathlen;\n\tstruct iattr *\t\tsattr;\n};\n\nstruct nfs_readdirargs {\n\tstruct nfs_fh *\t\tfh;\n\t__u32\t\t\tcookie;\n\tunsigned int\t\tcount;\n\tstruct page **\t\tpages;\n};\n\nstruct nfs3_getaclargs {\n\tstruct nfs_fh *\t\tfh;\n\tint\t\t\tmask;\n\tstruct page **\t\tpages;\n};\n\nstruct nfs3_setaclargs {\n\tstruct inode *\t\tinode;\n\tint\t\t\tmask;\n\tstruct posix_acl *\tacl_access;\n\tstruct posix_acl *\tacl_default;\n\tstruct page **\t\tpages;\n};\n\nstruct nfs_diropok {\n\tstruct nfs_fh *\t\tfh;\n\tstruct nfs_fattr *\tfattr;\n};\n\nstruct nfs_readlinkargs {\n\tstruct nfs_fh *\t\tfh;\n\tunsigned int\t\tpgbase;\n\tunsigned int\t\tpglen;\n\tstruct page **\t\tpages;\n};\n\nstruct nfs3_sattrargs {\n\tstruct nfs_fh *\t\tfh;\n\tstruct iattr *\t\tsattr;\n\tunsigned int\t\tguard;\n\tstruct timespec\t\tguardtime;\n};\n\nstruct nfs3_diropargs {\n\tstruct nfs_fh *\t\tfh;\n\tconst char *\t\tname;\n\tunsigned int\t\tlen;\n};\n\nstruct nfs3_accessargs {\n\tstruct nfs_fh *\t\tfh;\n\t__u32\t\t\taccess;\n};\n\nstruct nfs3_createargs {\n\tstruct nfs_fh *\t\tfh;\n\tconst char *\t\tname;\n\tunsigned int\t\tlen;\n\tstruct iattr *\t\tsattr;\n\tenum nfs3_createmode\tcreatemode;\n\t__be32\t\t\tverifier[2];\n};\n\nstruct nfs3_mkdirargs {\n\tstruct nfs_fh *\t\tfh;\n\tconst char *\t\tname;\n\tunsigned int\t\tlen;\n\tstruct iattr *\t\tsattr;\n};\n\nstruct nfs3_symlinkargs {\n\tstruct nfs_fh *\t\tfromfh;\n\tconst char *\t\tfromname;\n\tunsigned int\t\tfromlen;\n\tstruct page **\t\tpages;\n\tunsigned int\t\tpathlen;\n\tstruct iattr *\t\tsattr;\n};\n\nstruct nfs3_mknodargs {\n\tstruct nfs_fh *\t\tfh;\n\tconst char *\t\tname;\n\tunsigned int\t\tlen;\n\tenum nfs3_ftype\t\ttype;\n\tstruct iattr *\t\tsattr;\n\tdev_t\t\t\trdev;\n};\n\nstruct nfs3_renameargs {\n\tstruct nfs_fh *\t\tfromfh;\n\tconst char *\t\tfromname;\n\tunsigned int\t\tfromlen;\n\tstruct nfs_fh *\t\ttofh;\n\tconst char *\t\ttoname;\n\tunsigned int\t\ttolen;\n};\n\nstruct nfs3_linkargs {\n\tstruct nfs_fh *\t\tfromfh;\n\tstruct nfs_fh *\t\ttofh;\n\tconst char *\t\ttoname;\n\tunsigned int\t\ttolen;\n};\n\nstruct nfs3_readdirargs {\n\tstruct nfs_fh *\t\tfh;\n\t__u64\t\t\tcookie;\n\t__be32\t\t\tverf[2];\n\tint\t\t\tplus;\n\tunsigned int            count;\n\tstruct page **\t\tpages;\n};\n\nstruct nfs3_diropres {\n\tstruct nfs_fattr *\tdir_attr;\n\tstruct nfs_fh *\t\tfh;\n\tstruct nfs_fattr *\tfattr;\n};\n\nstruct nfs3_accessres {\n\tstruct nfs_fattr *\tfattr;\n\t__u32\t\t\taccess;\n};\n\nstruct nfs3_readlinkargs {\n\tstruct nfs_fh *\t\tfh;\n\tunsigned int\t\tpgbase;\n\tunsigned int\t\tpglen;\n\tstruct page **\t\tpages;\n};\n\nstruct nfs3_renameres {\n\tstruct nfs_fattr *\tfromattr;\n\tstruct nfs_fattr *\ttoattr;\n};\n\nstruct nfs3_linkres {\n\tstruct nfs_fattr *\tdir_attr;\n\tstruct nfs_fattr *\tfattr;\n};\n\nstruct nfs3_readdirres {\n\tstruct nfs_fattr *\tdir_attr;\n\t__be32 *\t\tverf;\n\tint\t\t\tplus;\n};\n\nstruct nfs3_getaclres {\n\tstruct nfs_fattr *\tfattr;\n\tint\t\t\tmask;\n\tunsigned int\t\tacl_access_count;\n\tunsigned int\t\tacl_default_count;\n\tstruct posix_acl *\tacl_access;\n\tstruct posix_acl *\tacl_default;\n};\n\n#ifdef CONFIG_NFS_V4\n\ntypedef u64 clientid4;\n\nstruct nfs4_accessargs {\n\tconst struct nfs_fh *\t\tfh;\n\tconst u32 *\t\t\tbitmask;\n\tu32\t\t\t\taccess;\n};\n\nstruct nfs4_accessres {\n\tconst struct nfs_server *\tserver;\n\tstruct nfs_fattr *\t\tfattr;\n\tu32\t\t\t\tsupported;\n\tu32\t\t\t\taccess;\n};\n\nstruct nfs4_create_arg {\n\tu32\t\t\t\tftype;\n\tunion {\n\t\tstruct {\n\t\t\tstruct page **\tpages;\n\t\t\tunsigned int\tlen;\n\t\t} symlink;   /* NF4LNK */\n\t\tstruct {\n\t\t\tu32\t\tspecdata1;\n\t\t\tu32\t\tspecdata2;\n\t\t} device;    /* NF4BLK, NF4CHR */\n\t} u;\n\tconst struct qstr *\t\tname;\n\tconst struct nfs_server *\tserver;\n\tconst struct iattr *\t\tattrs;\n\tconst struct nfs_fh *\t\tdir_fh;\n\tconst u32 *\t\t\tbitmask;\n};\n\nstruct nfs4_create_res {\n\tconst struct nfs_server *\tserver;\n\tstruct nfs_fh *\t\t\tfh;\n\tstruct nfs_fattr *\t\tfattr;\n\tstruct nfs4_change_info\t\tdir_cinfo;\n\tstruct nfs_fattr *\t\tdir_fattr;\n};\n\nstruct nfs4_fsinfo_arg {\n\tconst struct nfs_fh *\t\tfh;\n\tconst u32 *\t\t\tbitmask;\n};\n\nstruct nfs4_getattr_arg {\n\tconst struct nfs_fh *\t\tfh;\n\tconst u32 *\t\t\tbitmask;\n};\n\nstruct nfs4_getattr_res {\n\tconst struct nfs_server *\tserver;\n\tstruct nfs_fattr *\t\tfattr;\n};\n\nstruct nfs4_link_arg {\n\tconst struct nfs_fh *\t\tfh;\n\tconst struct nfs_fh *\t\tdir_fh;\n\tconst struct qstr *\t\tname;\n\tconst u32 *\t\t\tbitmask;\n};\n\nstruct nfs4_link_res {\n\tconst struct nfs_server *\tserver;\n\tstruct nfs_fattr *\t\tfattr;\n\tstruct nfs4_change_info\t\tcinfo;\n\tstruct nfs_fattr *\t\tdir_attr;\n};\n\n\nstruct nfs4_lookup_arg {\n\tconst struct nfs_fh *\t\tdir_fh;\n\tconst struct qstr *\t\tname;\n\tconst u32 *\t\t\tbitmask;\n};\n\nstruct nfs4_lookup_res {\n\tconst struct nfs_server *\tserver;\n\tstruct nfs_fattr *\t\tfattr;\n\tstruct nfs_fh *\t\t\tfh;\n};\n\nstruct nfs4_lookup_root_arg {\n\tconst u32 *\t\t\tbitmask;\n};\n\nstruct nfs4_pathconf_arg {\n\tconst struct nfs_fh *\t\tfh;\n\tconst u32 *\t\t\tbitmask;\n};\n\nstruct nfs4_readdir_arg {\n\tconst struct nfs_fh *\t\tfh;\n\tu64\t\t\t\tcookie;\n\tnfs4_verifier\t\t\tverifier;\n\tu32\t\t\t\tcount;\n\tstruct page **\t\t\tpages;\t/* zero-copy data */\n\tunsigned int\t\t\tpgbase;\t/* zero-copy data */\n\tconst u32 *\t\t\tbitmask;\n};\n\nstruct nfs4_readdir_res {\n\tnfs4_verifier\t\t\tverifier;\n\tunsigned int\t\t\tpgbase;\n};\n\nstruct nfs4_readlink {\n\tconst struct nfs_fh *\t\tfh;\n\tunsigned int\t\t\tpgbase;\n\tunsigned int\t\t\tpglen;   /* zero-copy data */\n\tstruct page **\t\t\tpages;   /* zero-copy data */\n};\n\nstruct nfs4_rename_arg {\n\tconst struct nfs_fh *\t\told_dir;\n\tconst struct nfs_fh *\t\tnew_dir;\n\tconst struct qstr *\t\told_name;\n\tconst struct qstr *\t\tnew_name;\n\tconst u32 *\t\t\tbitmask;\n};\n\nstruct nfs4_rename_res {\n\tconst struct nfs_server *\tserver;\n\tstruct nfs4_change_info\t\told_cinfo;\n\tstruct nfs_fattr *\t\told_fattr;\n\tstruct nfs4_change_info\t\tnew_cinfo;\n\tstruct nfs_fattr *\t\tnew_fattr;\n};\n\n#define NFS4_SETCLIENTID_NAMELEN\t(127)\nstruct nfs4_setclientid {\n\tconst nfs4_verifier *\t\tsc_verifier;\n\tunsigned int\t\t\tsc_name_len;\n\tchar\t\t\t\tsc_name[NFS4_SETCLIENTID_NAMELEN + 1];\n\tu32\t\t\t\tsc_prog;\n\tunsigned int\t\t\tsc_netid_len;\n\tchar\t\t\t\tsc_netid[RPCBIND_MAXNETIDLEN + 1];\n\tunsigned int\t\t\tsc_uaddr_len;\n\tchar\t\t\t\tsc_uaddr[RPCBIND_MAXUADDRLEN + 1];\n\tu32\t\t\t\tsc_cb_ident;\n};\n\nstruct nfs4_statfs_arg {\n\tconst struct nfs_fh *\t\tfh;\n\tconst u32 *\t\t\tbitmask;\n};\n\nstruct nfs4_server_caps_res {\n\tu32\t\t\t\tattr_bitmask[2];\n\tu32\t\t\t\tacl_bitmask;\n\tu32\t\t\t\thas_links;\n\tu32\t\t\t\thas_symlinks;\n};\n\nstruct nfs4_string {\n\tunsigned int len;\n\tchar *data;\n};\n\n#define NFS4_PATHNAME_MAXCOMPONENTS 512\nstruct nfs4_pathname {\n\tunsigned int ncomponents;\n\tstruct nfs4_string components[NFS4_PATHNAME_MAXCOMPONENTS];\n};\n\n#define NFS4_FS_LOCATION_MAXSERVERS 10\nstruct nfs4_fs_location {\n\tunsigned int nservers;\n\tstruct nfs4_string servers[NFS4_FS_LOCATION_MAXSERVERS];\n\tstruct nfs4_pathname rootpath;\n};\n\n#define NFS4_FS_LOCATIONS_MAXENTRIES 10\nstruct nfs4_fs_locations {\n\tstruct nfs_fattr fattr;\n\tconst struct nfs_server *server;\n\tstruct nfs4_pathname fs_path;\n\tint nlocations;\n\tstruct nfs4_fs_location locations[NFS4_FS_LOCATIONS_MAXENTRIES];\n};\n\nstruct nfs4_fs_locations_arg {\n\tconst struct nfs_fh *dir_fh;\n\tconst struct qstr *name;\n\tstruct page *page;\n\tconst u32 *bitmask;\n};\n\n#endif /* CONFIG_NFS_V4 */\n\nstruct nfs_page;\n\n#define NFS_PAGEVEC_SIZE\t(8U)\n\nstruct nfs_read_data {\n\tint\t\t\tflags;\n\tstruct rpc_task\t\ttask;\n\tstruct inode\t\t*inode;\n\tstruct rpc_cred\t\t*cred;\n\tstruct nfs_fattr\tfattr;\t/* fattr storage */\n\tstruct list_head\tpages;\t/* Coalesced read requests */\n\tstruct nfs_page\t\t*req;\t/* multi ops per nfs_page */\n\tstruct page\t\t**pagevec;\n\tunsigned int\t\tnpages;\t/* Max length of pagevec */\n\tstruct nfs_readargs args;\n\tstruct nfs_readres  res;\n#ifdef CONFIG_NFS_V4\n\tunsigned long\t\ttimestamp;\t/* For lease renewal */\n#endif\n\tstruct page\t\t*page_array[NFS_PAGEVEC_SIZE];\n};\n\nstruct nfs_write_data {\n\tint\t\t\tflags;\n\tstruct rpc_task\t\ttask;\n\tstruct inode\t\t*inode;\n\tstruct rpc_cred\t\t*cred;\n\tstruct nfs_fattr\tfattr;\n\tstruct nfs_writeverf\tverf;\n\tstruct list_head\tpages;\t\t/* Coalesced requests we wish to flush */\n\tstruct nfs_page\t\t*req;\t\t/* multi ops per nfs_page */\n\tstruct page\t\t**pagevec;\n\tunsigned int\t\tnpages;\t\t/* Max length of pagevec */\n\tstruct nfs_writeargs\targs;\t\t/* argument struct */\n\tstruct nfs_writeres\tres;\t\t/* result struct */\n#ifdef CONFIG_NFS_V4\n\tunsigned long\t\ttimestamp;\t/* For lease renewal */\n#endif\n\tstruct page\t\t*page_array[NFS_PAGEVEC_SIZE];\n};\n\nstruct nfs_access_entry;\n\n/*\n * RPC procedure vector for NFSv2/NFSv3 demuxing\n */\nstruct nfs_rpc_ops {\n\tu32\tversion;\t\t/* Protocol version */\n\tstruct dentry_operations *dentry_ops;\n\tconst struct inode_operations *dir_inode_ops;\n\tconst struct inode_operations *file_inode_ops;\n\n\tint\t(*getroot) (struct nfs_server *, struct nfs_fh *,\n\t\t\t    struct nfs_fsinfo *);\n\tint\t(*lookupfh)(struct nfs_server *, struct nfs_fh *,\n\t\t\t    struct qstr *, struct nfs_fh *,\n\t\t\t    struct nfs_fattr *);\n\tint\t(*getattr) (struct nfs_server *, struct nfs_fh *,\n\t\t\t    struct nfs_fattr *);\n\tint\t(*setattr) (struct dentry *, struct nfs_fattr *,\n\t\t\t    struct iattr *);\n\tint\t(*lookup)  (struct inode *, struct qstr *,\n\t\t\t    struct nfs_fh *, struct nfs_fattr *);\n\tint\t(*access)  (struct inode *, struct nfs_access_entry *);\n\tint\t(*readlink)(struct inode *, struct page *, unsigned int,\n\t\t\t    unsigned int);\n\tint\t(*create)  (struct inode *, struct dentry *,\n\t\t\t    struct iattr *, int, struct nameidata *);\n\tint\t(*remove)  (struct inode *, struct qstr *);\n\tvoid\t(*unlink_setup)  (struct rpc_message *, struct inode *dir);\n\tint\t(*unlink_done) (struct rpc_task *, struct inode *);\n\tint\t(*rename)  (struct inode *, struct qstr *,\n\t\t\t    struct inode *, struct qstr *);\n\tint\t(*link)    (struct inode *, struct inode *, struct qstr *);\n\tint\t(*symlink) (struct inode *, struct dentry *, struct page *,\n\t\t\t    unsigned int, struct iattr *);\n\tint\t(*mkdir)   (struct inode *, struct dentry *, struct iattr *);\n\tint\t(*rmdir)   (struct inode *, struct qstr *);\n\tint\t(*readdir) (struct dentry *, struct rpc_cred *,\n\t\t\t    u64, struct page *, unsigned int, int);\n\tint\t(*mknod)   (struct inode *, struct dentry *, struct iattr *,\n\t\t\t    dev_t);\n\tint\t(*statfs)  (struct nfs_server *, struct nfs_fh *,\n\t\t\t    struct nfs_fsstat *);\n\tint\t(*fsinfo)  (struct nfs_server *, struct nfs_fh *,\n\t\t\t    struct nfs_fsinfo *);\n\tint\t(*pathconf) (struct nfs_server *, struct nfs_fh *,\n\t\t\t     struct nfs_pathconf *);\n\tint\t(*set_capabilities)(struct nfs_server *, struct nfs_fh *);\n\t__be32 *(*decode_dirent)(__be32 *, struct nfs_entry *, int plus);\n\tvoid\t(*read_setup)   (struct nfs_read_data *, struct rpc_message *);\n\tint\t(*read_done)  (struct rpc_task *, struct nfs_read_data *);\n\tvoid\t(*write_setup)  (struct nfs_write_data *, struct rpc_message *);\n\tint\t(*write_done)  (struct rpc_task *, struct nfs_write_data *);\n\tvoid\t(*commit_setup) (struct nfs_write_data *, struct rpc_message *);\n\tint\t(*commit_done) (struct rpc_task *, struct nfs_write_data *);\n\tint\t(*lock)(struct file *, int, struct file_lock *);\n\tint\t(*lock_check_bounds)(const struct file_lock *);\n\tvoid\t(*clear_acl_cache)(struct inode *);\n};\n\n/*\n * \tNFS_CALL(getattr, inode, (fattr));\n * into\n *\tNFS_PROTO(inode)->getattr(fattr);\n */\n#define NFS_CALL(op, inode, args)\tNFS_PROTO(inode)->op args\n\n/*\n * Function vectors etc. for the NFS client\n */\nextern const struct nfs_rpc_ops\tnfs_v2_clientops;\nextern const struct nfs_rpc_ops\tnfs_v3_clientops;\nextern const struct nfs_rpc_ops\tnfs_v4_clientops;\nextern struct rpc_version\tnfs_version2;\nextern struct rpc_version\tnfs_version3;\nextern struct rpc_version\tnfs_version4;\n\nextern struct rpc_version\tnfsacl_version3;\nextern struct rpc_program\tnfsacl_program;\n\n#endif\n"], "fixing_code": ["/*\n *  linux/fs/nfs/inode.c\n *\n *  Copyright (C) 1992  Rick Sladkey\n *\n *  nfs inode and superblock handling functions\n *\n *  Modularised by Alan Cox <alan@lxorguk.ukuu.org.uk>, while hacking some\n *  experimental NFS changes. Modularisation taken straight from SYS5 fs.\n *\n *  Change to nfs_read_super() to permit NFS mounts to multi-homed hosts.\n *  J.S.Peatfield@damtp.cam.ac.uk\n *\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/unistd.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs4_mount.h>\n#include <linux/lockd/bind.h>\n#include <linux/smp_lock.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/nfs_idmap.h>\n#include <linux/vfs.h>\n#include <linux/inet.h>\n#include <linux/nfs_xdr.h>\n\n#include <asm/system.h>\n#include <asm/uaccess.h>\n\n#include \"nfs4_fs.h\"\n#include \"callback.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_VFS\n\n#define NFS_64_BIT_INODE_NUMBERS_ENABLED\t1\n\n/* Default is to see 64-bit inode numbers */\nstatic int enable_ino64 = NFS_64_BIT_INODE_NUMBERS_ENABLED;\n\nstatic void nfs_invalidate_inode(struct inode *);\nstatic int nfs_update_inode(struct inode *, struct nfs_fattr *);\n\nstatic struct kmem_cache * nfs_inode_cachep;\n\nstatic inline unsigned long\nnfs_fattr_to_ino_t(struct nfs_fattr *fattr)\n{\n\treturn nfs_fileid_to_ino_t(fattr->fileid);\n}\n\n/**\n * nfs_compat_user_ino64 - returns the user-visible inode number\n * @fileid: 64-bit fileid\n *\n * This function returns a 32-bit inode number if the boot parameter\n * nfs.enable_ino64 is zero.\n */\nu64 nfs_compat_user_ino64(u64 fileid)\n{\n\tint ino;\n\n\tif (enable_ino64)\n\t\treturn fileid;\n\tino = fileid;\n\tif (sizeof(ino) < sizeof(fileid))\n\t\tino ^= fileid >> (sizeof(fileid)-sizeof(ino)) * 8;\n\treturn ino;\n}\n\nint nfs_write_inode(struct inode *inode, int sync)\n{\n\tint ret;\n\n\tif (sync) {\n\t\tret = filemap_fdatawait(inode->i_mapping);\n\t\tif (ret == 0)\n\t\t\tret = nfs_commit_inode(inode, FLUSH_SYNC);\n\t} else\n\t\tret = nfs_commit_inode(inode, 0);\n\tif (ret >= 0)\n\t\treturn 0;\n\t__mark_inode_dirty(inode, I_DIRTY_DATASYNC);\n\treturn ret;\n}\n\nvoid nfs_clear_inode(struct inode *inode)\n{\n\t/*\n\t * The following should never happen...\n\t */\n\tBUG_ON(nfs_have_writebacks(inode));\n\tBUG_ON(!list_empty(&NFS_I(inode)->open_files));\n\tnfs_zap_acl_cache(inode);\n\tnfs_access_zap_cache(inode);\n}\n\n/**\n * nfs_sync_mapping - helper to flush all mmapped dirty data to disk\n */\nint nfs_sync_mapping(struct address_space *mapping)\n{\n\tint ret;\n\n\tif (mapping->nrpages == 0)\n\t\treturn 0;\n\tunmap_mapping_range(mapping, 0, 0, 0);\n\tret = filemap_write_and_wait(mapping);\n\tif (ret != 0)\n\t\tgoto out;\n\tret = nfs_wb_all(mapping->host);\nout:\n\treturn ret;\n}\n\n/*\n * Invalidate the local caches\n */\nstatic void nfs_zap_caches_locked(struct inode *inode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tint mode = inode->i_mode;\n\n\tnfs_inc_stats(inode, NFSIOS_ATTRINVALIDATE);\n\n\tnfsi->attrtimeo = NFS_MINATTRTIMEO(inode);\n\tnfsi->attrtimeo_timestamp = jiffies;\n\n\tmemset(NFS_COOKIEVERF(inode), 0, sizeof(NFS_COOKIEVERF(inode)));\n\tif (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode))\n\t\tnfsi->cache_validity |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_DATA|NFS_INO_INVALID_ACCESS|NFS_INO_INVALID_ACL|NFS_INO_REVAL_PAGECACHE;\n\telse\n\t\tnfsi->cache_validity |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_ACCESS|NFS_INO_INVALID_ACL|NFS_INO_REVAL_PAGECACHE;\n}\n\nvoid nfs_zap_caches(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tnfs_zap_caches_locked(inode);\n\tspin_unlock(&inode->i_lock);\n}\n\nvoid nfs_zap_mapping(struct inode *inode, struct address_space *mapping)\n{\n\tif (mapping->nrpages != 0) {\n\t\tspin_lock(&inode->i_lock);\n\t\tNFS_I(inode)->cache_validity |= NFS_INO_INVALID_DATA;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n}\n\nvoid nfs_zap_acl_cache(struct inode *inode)\n{\n\tvoid (*clear_acl_cache)(struct inode *);\n\n\tclear_acl_cache = NFS_PROTO(inode)->clear_acl_cache;\n\tif (clear_acl_cache != NULL)\n\t\tclear_acl_cache(inode);\n\tspin_lock(&inode->i_lock);\n\tNFS_I(inode)->cache_validity &= ~NFS_INO_INVALID_ACL;\n\tspin_unlock(&inode->i_lock);\n}\n\nvoid nfs_invalidate_atime(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tNFS_I(inode)->cache_validity |= NFS_INO_INVALID_ATIME;\n\tspin_unlock(&inode->i_lock);\n}\n\n/*\n * Invalidate, but do not unhash, the inode.\n * NB: must be called with inode->i_lock held!\n */\nstatic void nfs_invalidate_inode(struct inode *inode)\n{\n\tset_bit(NFS_INO_STALE, &NFS_I(inode)->flags);\n\tnfs_zap_caches_locked(inode);\n}\n\nstruct nfs_find_desc {\n\tstruct nfs_fh\t\t*fh;\n\tstruct nfs_fattr\t*fattr;\n};\n\n/*\n * In NFSv3 we can have 64bit inode numbers. In order to support\n * this, and re-exported directories (also seen in NFSv2)\n * we are forced to allow 2 different inodes to have the same\n * i_ino.\n */\nstatic int\nnfs_find_actor(struct inode *inode, void *opaque)\n{\n\tstruct nfs_find_desc\t*desc = (struct nfs_find_desc *)opaque;\n\tstruct nfs_fh\t\t*fh = desc->fh;\n\tstruct nfs_fattr\t*fattr = desc->fattr;\n\n\tif (NFS_FILEID(inode) != fattr->fileid)\n\t\treturn 0;\n\tif (nfs_compare_fh(NFS_FH(inode), fh))\n\t\treturn 0;\n\tif (is_bad_inode(inode) || NFS_STALE(inode))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int\nnfs_init_locked(struct inode *inode, void *opaque)\n{\n\tstruct nfs_find_desc\t*desc = (struct nfs_find_desc *)opaque;\n\tstruct nfs_fattr\t*fattr = desc->fattr;\n\n\tset_nfs_fileid(inode, fattr->fileid);\n\tnfs_copy_fh(NFS_FH(inode), desc->fh);\n\treturn 0;\n}\n\n/* Don't use READDIRPLUS on directories that we believe are too large */\n#define NFS_LIMIT_READDIRPLUS (8*PAGE_SIZE)\n\n/*\n * This is our front-end to iget that looks up inodes by file handle\n * instead of inode number.\n */\nstruct inode *\nnfs_fhget(struct super_block *sb, struct nfs_fh *fh, struct nfs_fattr *fattr)\n{\n\tstruct nfs_find_desc desc = {\n\t\t.fh\t= fh,\n\t\t.fattr\t= fattr\n\t};\n\tstruct inode *inode = ERR_PTR(-ENOENT);\n\tunsigned long hash;\n\n\tif ((fattr->valid & NFS_ATTR_FATTR) == 0)\n\t\tgoto out_no_inode;\n\n\tif (!fattr->nlink) {\n\t\tprintk(\"NFS: Buggy server - nlink == 0!\\n\");\n\t\tgoto out_no_inode;\n\t}\n\n\thash = nfs_fattr_to_ino_t(fattr);\n\n\tinode = iget5_locked(sb, hash, nfs_find_actor, nfs_init_locked, &desc);\n\tif (inode == NULL) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tgoto out_no_inode;\n\t}\n\n\tif (inode->i_state & I_NEW) {\n\t\tstruct nfs_inode *nfsi = NFS_I(inode);\n\t\tunsigned long now = jiffies;\n\n\t\t/* We set i_ino for the few things that still rely on it,\n\t\t * such as stat(2) */\n\t\tinode->i_ino = hash;\n\n\t\t/* We can't support update_atime(), since the server will reset it */\n\t\tinode->i_flags |= S_NOATIME|S_NOCMTIME;\n\t\tinode->i_mode = fattr->mode;\n\t\t/* Why so? Because we want revalidate for devices/FIFOs, and\n\t\t * that's precisely what we have in nfs_file_inode_operations.\n\t\t */\n\t\tinode->i_op = NFS_SB(sb)->nfs_client->rpc_ops->file_inode_ops;\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tinode->i_fop = &nfs_file_operations;\n\t\t\tinode->i_data.a_ops = &nfs_file_aops;\n\t\t\tinode->i_data.backing_dev_info = &NFS_SB(sb)->backing_dev_info;\n\t\t} else if (S_ISDIR(inode->i_mode)) {\n\t\t\tinode->i_op = NFS_SB(sb)->nfs_client->rpc_ops->dir_inode_ops;\n\t\t\tinode->i_fop = &nfs_dir_operations;\n\t\t\tif (nfs_server_capable(inode, NFS_CAP_READDIRPLUS)\n\t\t\t    && fattr->size <= NFS_LIMIT_READDIRPLUS)\n\t\t\t\tset_bit(NFS_INO_ADVISE_RDPLUS, &NFS_I(inode)->flags);\n\t\t\t/* Deal with crossing mountpoints */\n\t\t\tif (!nfs_fsid_equal(&NFS_SB(sb)->fsid, &fattr->fsid)) {\n\t\t\t\tif (fattr->valid & NFS_ATTR_FATTR_V4_REFERRAL)\n\t\t\t\t\tinode->i_op = &nfs_referral_inode_operations;\n\t\t\t\telse\n\t\t\t\t\tinode->i_op = &nfs_mountpoint_inode_operations;\n\t\t\t\tinode->i_fop = NULL;\n\t\t\t\tset_bit(NFS_INO_MOUNTPOINT, &nfsi->flags);\n\t\t\t}\n\t\t} else if (S_ISLNK(inode->i_mode))\n\t\t\tinode->i_op = &nfs_symlink_inode_operations;\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode, fattr->rdev);\n\n\t\tnfsi->read_cache_jiffies = fattr->time_start;\n\t\tnfsi->attr_gencount = fattr->gencount;\n\t\tinode->i_atime = fattr->atime;\n\t\tinode->i_mtime = fattr->mtime;\n\t\tinode->i_ctime = fattr->ctime;\n\t\tif (fattr->valid & NFS_ATTR_FATTR_V4)\n\t\t\tnfsi->change_attr = fattr->change_attr;\n\t\tinode->i_size = nfs_size_to_loff_t(fattr->size);\n\t\tinode->i_nlink = fattr->nlink;\n\t\tinode->i_uid = fattr->uid;\n\t\tinode->i_gid = fattr->gid;\n\t\tif (fattr->valid & (NFS_ATTR_FATTR_V3 | NFS_ATTR_FATTR_V4)) {\n\t\t\t/*\n\t\t\t * report the blocks in 512byte units\n\t\t\t */\n\t\t\tinode->i_blocks = nfs_calc_block_size(fattr->du.nfs3.used);\n\t\t} else {\n\t\t\tinode->i_blocks = fattr->du.nfs2.blocks;\n\t\t}\n\t\tnfsi->attrtimeo = NFS_MINATTRTIMEO(inode);\n\t\tnfsi->attrtimeo_timestamp = now;\n\t\tmemset(nfsi->cookieverf, 0, sizeof(nfsi->cookieverf));\n\t\tnfsi->access_cache = RB_ROOT;\n\n\t\tunlock_new_inode(inode);\n\t} else\n\t\tnfs_refresh_inode(inode, fattr);\n\tdprintk(\"NFS: nfs_fhget(%s/%Ld ct=%d)\\n\",\n\t\tinode->i_sb->s_id,\n\t\t(long long)NFS_FILEID(inode),\n\t\tatomic_read(&inode->i_count));\n\nout:\n\treturn inode;\n\nout_no_inode:\n\tdprintk(\"nfs_fhget: iget failed with error %ld\\n\", PTR_ERR(inode));\n\tgoto out;\n}\n\n#define NFS_VALID_ATTRS (ATTR_MODE|ATTR_UID|ATTR_GID|ATTR_SIZE|ATTR_ATIME|ATTR_ATIME_SET|ATTR_MTIME|ATTR_MTIME_SET|ATTR_FILE)\n\nint\nnfs_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct nfs_fattr fattr;\n\tint error;\n\n\tnfs_inc_stats(inode, NFSIOS_VFSSETATTR);\n\n\t/* skip mode change if it's just for clearing setuid/setgid */\n\tif (attr->ia_valid & (ATTR_KILL_SUID | ATTR_KILL_SGID))\n\t\tattr->ia_valid &= ~ATTR_MODE;\n\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\tif (!S_ISREG(inode->i_mode) || attr->ia_size == i_size_read(inode))\n\t\t\tattr->ia_valid &= ~ATTR_SIZE;\n\t}\n\n\t/* Optimization: if the end result is no change, don't RPC */\n\tattr->ia_valid &= NFS_VALID_ATTRS;\n\tif ((attr->ia_valid & ~ATTR_FILE) == 0)\n\t\treturn 0;\n\n\t/* Write all dirty data */\n\tif (S_ISREG(inode->i_mode)) {\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t\tnfs_wb_all(inode);\n\t}\n\t/*\n\t * Return any delegations if we're going to change ACLs\n\t */\n\tif ((attr->ia_valid & (ATTR_MODE|ATTR_UID|ATTR_GID)) != 0)\n\t\tnfs_inode_return_delegation(inode);\n\terror = NFS_PROTO(inode)->setattr(dentry, &fattr, attr);\n\tif (error == 0)\n\t\tnfs_refresh_inode(inode, &fattr);\n\treturn error;\n}\n\n/**\n * nfs_vmtruncate - unmap mappings \"freed\" by truncate() syscall\n * @inode: inode of the file used\n * @offset: file offset to start truncating\n *\n * This is a copy of the common vmtruncate, but with the locking\n * corrected to take into account the fact that NFS requires\n * inode->i_size to be updated under the inode->i_lock.\n */\nstatic int nfs_vmtruncate(struct inode * inode, loff_t offset)\n{\n\tif (i_size_read(inode) < offset) {\n\t\tunsigned long limit;\n\n\t\tlimit = current->signal->rlim[RLIMIT_FSIZE].rlim_cur;\n\t\tif (limit != RLIM_INFINITY && offset > limit)\n\t\t\tgoto out_sig;\n\t\tif (offset > inode->i_sb->s_maxbytes)\n\t\t\tgoto out_big;\n\t\tspin_lock(&inode->i_lock);\n\t\ti_size_write(inode, offset);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\n\t\t/*\n\t\t * truncation of in-use swapfiles is disallowed - it would\n\t\t * cause subsequent swapout to scribble on the now-freed\n\t\t * blocks.\n\t\t */\n\t\tif (IS_SWAPFILE(inode))\n\t\t\treturn -ETXTBSY;\n\t\tspin_lock(&inode->i_lock);\n\t\ti_size_write(inode, offset);\n\t\tspin_unlock(&inode->i_lock);\n\n\t\t/*\n\t\t * unmap_mapping_range is called twice, first simply for\n\t\t * efficiency so that truncate_inode_pages does fewer\n\t\t * single-page unmaps.  However after this first call, and\n\t\t * before truncate_inode_pages finishes, it is possible for\n\t\t * private pages to be COWed, which remain after\n\t\t * truncate_inode_pages finishes, hence the second\n\t\t * unmap_mapping_range call must be made for correctness.\n\t\t */\n\t\tunmap_mapping_range(mapping, offset + PAGE_SIZE - 1, 0, 1);\n\t\ttruncate_inode_pages(mapping, offset);\n\t\tunmap_mapping_range(mapping, offset + PAGE_SIZE - 1, 0, 1);\n\t}\n\treturn 0;\nout_sig:\n\tsend_sig(SIGXFSZ, current, 0);\nout_big:\n\treturn -EFBIG;\n}\n\n/**\n * nfs_setattr_update_inode - Update inode metadata after a setattr call.\n * @inode: pointer to struct inode\n * @attr: pointer to struct iattr\n *\n * Note: we do this in the *proc.c in order to ensure that\n *       it works for things like exclusive creates too.\n */\nvoid nfs_setattr_update_inode(struct inode *inode, struct iattr *attr)\n{\n\tif ((attr->ia_valid & (ATTR_MODE|ATTR_UID|ATTR_GID)) != 0) {\n\t\tspin_lock(&inode->i_lock);\n\t\tif ((attr->ia_valid & ATTR_MODE) != 0) {\n\t\t\tint mode = attr->ia_mode & S_IALLUGO;\n\t\t\tmode |= inode->i_mode & ~S_IALLUGO;\n\t\t\tinode->i_mode = mode;\n\t\t}\n\t\tif ((attr->ia_valid & ATTR_UID) != 0)\n\t\t\tinode->i_uid = attr->ia_uid;\n\t\tif ((attr->ia_valid & ATTR_GID) != 0)\n\t\t\tinode->i_gid = attr->ia_gid;\n\t\tNFS_I(inode)->cache_validity |= NFS_INO_INVALID_ACCESS|NFS_INO_INVALID_ACL;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\tif ((attr->ia_valid & ATTR_SIZE) != 0) {\n\t\tnfs_inc_stats(inode, NFSIOS_SETATTRTRUNC);\n\t\tnfs_vmtruncate(inode, attr->ia_size);\n\t}\n}\n\nint nfs_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint need_atime = NFS_I(inode)->cache_validity & NFS_INO_INVALID_ATIME;\n\tint err;\n\n\t/*\n\t * Flush out writes to the server in order to update c/mtime.\n\t *\n\t * Hold the i_mutex to suspend application writes temporarily;\n\t * this prevents long-running writing applications from blocking\n\t * nfs_wb_nocommit.\n\t */\n\tif (S_ISREG(inode->i_mode)) {\n\t\tmutex_lock(&inode->i_mutex);\n\t\tnfs_wb_nocommit(inode);\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\n\t/*\n\t * We may force a getattr if the user cares about atime.\n\t *\n\t * Note that we only have to check the vfsmount flags here:\n\t *  - NFS always sets S_NOATIME by so checking it would give a\n\t *    bogus result\n\t *  - NFS never sets MS_NOATIME or MS_NODIRATIME so there is\n\t *    no point in checking those.\n\t */\n \tif ((mnt->mnt_flags & MNT_NOATIME) ||\n \t    ((mnt->mnt_flags & MNT_NODIRATIME) && S_ISDIR(inode->i_mode)))\n\t\tneed_atime = 0;\n\n\tif (need_atime)\n\t\terr = __nfs_revalidate_inode(NFS_SERVER(inode), inode);\n\telse\n\t\terr = nfs_revalidate_inode(NFS_SERVER(inode), inode);\n\tif (!err) {\n\t\tgeneric_fillattr(inode, stat);\n\t\tstat->ino = nfs_compat_user_ino64(NFS_FILEID(inode));\n\t}\n\treturn err;\n}\n\nstatic struct nfs_open_context *alloc_nfs_open_context(struct vfsmount *mnt, struct dentry *dentry, struct rpc_cred *cred)\n{\n\tstruct nfs_open_context *ctx;\n\n\tctx = kmalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (ctx != NULL) {\n\t\tctx->path.dentry = dget(dentry);\n\t\tctx->path.mnt = mntget(mnt);\n\t\tctx->cred = get_rpccred(cred);\n\t\tctx->state = NULL;\n\t\tctx->lockowner = current->files;\n\t\tctx->flags = 0;\n\t\tctx->error = 0;\n\t\tctx->dir_cookie = 0;\n\t\tatomic_set(&ctx->count, 1);\n\t}\n\treturn ctx;\n}\n\nstruct nfs_open_context *get_nfs_open_context(struct nfs_open_context *ctx)\n{\n\tif (ctx != NULL)\n\t\tatomic_inc(&ctx->count);\n\treturn ctx;\n}\n\nstatic void __put_nfs_open_context(struct nfs_open_context *ctx, int wait)\n{\n\tstruct inode *inode;\n\n\tif (ctx == NULL)\n\t\treturn;\n\n\tinode = ctx->path.dentry->d_inode;\n\tif (!atomic_dec_and_lock(&ctx->count, &inode->i_lock))\n\t\treturn;\n\tlist_del(&ctx->list);\n\tspin_unlock(&inode->i_lock);\n\tif (ctx->state != NULL) {\n\t\tif (wait)\n\t\t\tnfs4_close_sync(&ctx->path, ctx->state, ctx->mode);\n\t\telse\n\t\t\tnfs4_close_state(&ctx->path, ctx->state, ctx->mode);\n\t}\n\tif (ctx->cred != NULL)\n\t\tput_rpccred(ctx->cred);\n\tpath_put(&ctx->path);\n\tkfree(ctx);\n}\n\nvoid put_nfs_open_context(struct nfs_open_context *ctx)\n{\n\t__put_nfs_open_context(ctx, 0);\n}\n\nstatic void put_nfs_open_context_sync(struct nfs_open_context *ctx)\n{\n\t__put_nfs_open_context(ctx, 1);\n}\n\n/*\n * Ensure that mmap has a recent RPC credential for use when writing out\n * shared pages\n */\nstatic void nfs_file_set_open_context(struct file *filp, struct nfs_open_context *ctx)\n{\n\tstruct inode *inode = filp->f_path.dentry->d_inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tfilp->private_data = get_nfs_open_context(ctx);\n\tspin_lock(&inode->i_lock);\n\tlist_add(&ctx->list, &nfsi->open_files);\n\tspin_unlock(&inode->i_lock);\n}\n\n/*\n * Given an inode, search for an open context with the desired characteristics\n */\nstruct nfs_open_context *nfs_find_open_context(struct inode *inode, struct rpc_cred *cred, fmode_t mode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_open_context *pos, *ctx = NULL;\n\n\tspin_lock(&inode->i_lock);\n\tlist_for_each_entry(pos, &nfsi->open_files, list) {\n\t\tif (cred != NULL && pos->cred != cred)\n\t\t\tcontinue;\n\t\tif ((pos->mode & mode) == mode) {\n\t\t\tctx = get_nfs_open_context(pos);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn ctx;\n}\n\nstatic void nfs_file_clear_open_context(struct file *filp)\n{\n\tstruct inode *inode = filp->f_path.dentry->d_inode;\n\tstruct nfs_open_context *ctx = nfs_file_open_context(filp);\n\n\tif (ctx) {\n\t\tfilp->private_data = NULL;\n\t\tspin_lock(&inode->i_lock);\n\t\tlist_move_tail(&ctx->list, &NFS_I(inode)->open_files);\n\t\tspin_unlock(&inode->i_lock);\n\t\tput_nfs_open_context_sync(ctx);\n\t}\n}\n\n/*\n * These allocate and release file read/write context information.\n */\nint nfs_open(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct rpc_cred *cred;\n\n\tcred = rpc_lookup_cred();\n\tif (IS_ERR(cred))\n\t\treturn PTR_ERR(cred);\n\tctx = alloc_nfs_open_context(filp->f_path.mnt, filp->f_path.dentry, cred);\n\tput_rpccred(cred);\n\tif (ctx == NULL)\n\t\treturn -ENOMEM;\n\tctx->mode = filp->f_mode;\n\tnfs_file_set_open_context(filp, ctx);\n\tput_nfs_open_context(ctx);\n\treturn 0;\n}\n\nint nfs_release(struct inode *inode, struct file *filp)\n{\n\tnfs_file_clear_open_context(filp);\n\treturn 0;\n}\n\n/*\n * This function is called whenever some part of NFS notices that\n * the cached attributes have to be refreshed.\n */\nint\n__nfs_revalidate_inode(struct nfs_server *server, struct inode *inode)\n{\n\tint\t\t status = -ESTALE;\n\tstruct nfs_fattr fattr;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tdfprintk(PAGECACHE, \"NFS: revalidating (%s/%Ld)\\n\",\n\t\tinode->i_sb->s_id, (long long)NFS_FILEID(inode));\n\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\tif (NFS_STALE(inode))\n\t\tgoto out;\n\n\tif (NFS_STALE(inode))\n\t\tgoto out;\n\n\tnfs_inc_stats(inode, NFSIOS_INODEREVALIDATE);\n\tstatus = NFS_PROTO(inode)->getattr(server, NFS_FH(inode), &fattr);\n\tif (status != 0) {\n\t\tdfprintk(PAGECACHE, \"nfs_revalidate_inode: (%s/%Ld) getattr failed, error=%d\\n\",\n\t\t\t inode->i_sb->s_id,\n\t\t\t (long long)NFS_FILEID(inode), status);\n\t\tif (status == -ESTALE) {\n\t\t\tnfs_zap_caches(inode);\n\t\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\t\tset_bit(NFS_INO_STALE, &NFS_I(inode)->flags);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tstatus = nfs_refresh_inode(inode, &fattr);\n\tif (status) {\n\t\tdfprintk(PAGECACHE, \"nfs_revalidate_inode: (%s/%Ld) refresh failed, error=%d\\n\",\n\t\t\t inode->i_sb->s_id,\n\t\t\t (long long)NFS_FILEID(inode), status);\n\t\tgoto out;\n\t}\n\n\tif (nfsi->cache_validity & NFS_INO_INVALID_ACL)\n\t\tnfs_zap_acl_cache(inode);\n\n\tdfprintk(PAGECACHE, \"NFS: (%s/%Ld) revalidation complete\\n\",\n\t\tinode->i_sb->s_id,\n\t\t(long long)NFS_FILEID(inode));\n\n out:\n\treturn status;\n}\n\nint nfs_attribute_timeout(struct inode *inode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tif (nfs_have_delegation(inode, FMODE_READ))\n\t\treturn 0;\n\t/*\n\t * Special case: if the attribute timeout is set to 0, then always\n\t * \t\t treat the cache as having expired (unless holding\n\t * \t\t a delegation).\n\t */\n\tif (nfsi->attrtimeo == 0)\n\t\treturn 1;\n\treturn !time_in_range(jiffies, nfsi->read_cache_jiffies, nfsi->read_cache_jiffies + nfsi->attrtimeo);\n}\n\n/**\n * nfs_revalidate_inode - Revalidate the inode attributes\n * @server - pointer to nfs_server struct\n * @inode - pointer to inode struct\n *\n * Updates inode attribute information by retrieving the data from the server.\n */\nint nfs_revalidate_inode(struct nfs_server *server, struct inode *inode)\n{\n\tif (!(NFS_I(inode)->cache_validity & NFS_INO_INVALID_ATTR)\n\t\t\t&& !nfs_attribute_timeout(inode))\n\t\treturn NFS_STALE(inode) ? -ESTALE : 0;\n\treturn __nfs_revalidate_inode(server, inode);\n}\n\nstatic int nfs_invalidate_mapping_nolock(struct inode *inode, struct address_space *mapping)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\t\n\tif (mapping->nrpages != 0) {\n\t\tint ret = invalidate_inode_pages2(mapping);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tspin_lock(&inode->i_lock);\n\tnfsi->cache_validity &= ~NFS_INO_INVALID_DATA;\n\tif (S_ISDIR(inode->i_mode))\n\t\tmemset(nfsi->cookieverf, 0, sizeof(nfsi->cookieverf));\n\tspin_unlock(&inode->i_lock);\n\tnfs_inc_stats(inode, NFSIOS_DATAINVALIDATE);\n\tdfprintk(PAGECACHE, \"NFS: (%s/%Ld) data cache invalidated\\n\",\n\t\t\tinode->i_sb->s_id, (long long)NFS_FILEID(inode));\n\treturn 0;\n}\n\nstatic int nfs_invalidate_mapping(struct inode *inode, struct address_space *mapping)\n{\n\tint ret = 0;\n\n\tmutex_lock(&inode->i_mutex);\n\tif (NFS_I(inode)->cache_validity & NFS_INO_INVALID_DATA) {\n\t\tret = nfs_sync_mapping(mapping);\n\t\tif (ret == 0)\n\t\t\tret = nfs_invalidate_mapping_nolock(inode, mapping);\n\t}\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}\n\n/**\n * nfs_revalidate_mapping_nolock - Revalidate the pagecache\n * @inode - pointer to host inode\n * @mapping - pointer to mapping\n */\nint nfs_revalidate_mapping_nolock(struct inode *inode, struct address_space *mapping)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tint ret = 0;\n\n\tif ((nfsi->cache_validity & NFS_INO_REVAL_PAGECACHE)\n\t\t\t|| nfs_attribute_timeout(inode) || NFS_STALE(inode)) {\n\t\tret = __nfs_revalidate_inode(NFS_SERVER(inode), inode);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tif (nfsi->cache_validity & NFS_INO_INVALID_DATA)\n\t\tret = nfs_invalidate_mapping_nolock(inode, mapping);\nout:\n\treturn ret;\n}\n\n/**\n * nfs_revalidate_mapping - Revalidate the pagecache\n * @inode - pointer to host inode\n * @mapping - pointer to mapping\n *\n * This version of the function will take the inode->i_mutex and attempt to\n * flush out all dirty data if it needs to invalidate the page cache.\n */\nint nfs_revalidate_mapping(struct inode *inode, struct address_space *mapping)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tint ret = 0;\n\n\tif ((nfsi->cache_validity & NFS_INO_REVAL_PAGECACHE)\n\t\t\t|| nfs_attribute_timeout(inode) || NFS_STALE(inode)) {\n\t\tret = __nfs_revalidate_inode(NFS_SERVER(inode), inode);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tif (nfsi->cache_validity & NFS_INO_INVALID_DATA)\n\t\tret = nfs_invalidate_mapping(inode, mapping);\nout:\n\treturn ret;\n}\n\nstatic void nfs_wcc_update_inode(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tif ((fattr->valid & NFS_ATTR_WCC_V4) != 0 &&\n\t\t\tnfsi->change_attr == fattr->pre_change_attr) {\n\t\tnfsi->change_attr = fattr->change_attr;\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tnfsi->cache_validity |= NFS_INO_INVALID_DATA;\n\t}\n\t/* If we have atomic WCC data, we may update some attributes */\n\tif ((fattr->valid & NFS_ATTR_WCC) != 0) {\n\t\tif (timespec_equal(&inode->i_ctime, &fattr->pre_ctime))\n\t\t\tmemcpy(&inode->i_ctime, &fattr->ctime, sizeof(inode->i_ctime));\n\t\tif (timespec_equal(&inode->i_mtime, &fattr->pre_mtime)) {\n\t\t\tmemcpy(&inode->i_mtime, &fattr->mtime, sizeof(inode->i_mtime));\n\t\t\tif (S_ISDIR(inode->i_mode))\n\t\t\t\tnfsi->cache_validity |= NFS_INO_INVALID_DATA;\n\t\t}\n\t\tif (i_size_read(inode) == nfs_size_to_loff_t(fattr->pre_size) &&\n\t\t    nfsi->npages == 0)\n\t\t\ti_size_write(inode, nfs_size_to_loff_t(fattr->size));\n\t}\n}\n\n/**\n * nfs_check_inode_attributes - verify consistency of the inode attribute cache\n * @inode - pointer to inode\n * @fattr - updated attributes\n *\n * Verifies the attribute cache. If we have just changed the attributes,\n * so that fattr carries weak cache consistency data, then it may\n * also update the ctime/mtime/change_attribute.\n */\nstatic int nfs_check_inode_attributes(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tloff_t cur_size, new_isize;\n\tunsigned long invalid = 0;\n\n\n\t/* Has the inode gone and changed behind our back? */\n\tif (nfsi->fileid != fattr->fileid\n\t\t\t|| (inode->i_mode & S_IFMT) != (fattr->mode & S_IFMT)) {\n\t\treturn -EIO;\n\t}\n\n\tif ((fattr->valid & NFS_ATTR_FATTR_V4) != 0 &&\n\t\t\tnfsi->change_attr != fattr->change_attr)\n\t\tinvalid |= NFS_INO_INVALID_ATTR|NFS_INO_REVAL_PAGECACHE;\n\n\t/* Verify a few of the more important attributes */\n\tif (!timespec_equal(&inode->i_mtime, &fattr->mtime))\n\t\tinvalid |= NFS_INO_INVALID_ATTR|NFS_INO_REVAL_PAGECACHE;\n\n\tcur_size = i_size_read(inode);\n \tnew_isize = nfs_size_to_loff_t(fattr->size);\n\tif (cur_size != new_isize && nfsi->npages == 0)\n\t\tinvalid |= NFS_INO_INVALID_ATTR|NFS_INO_REVAL_PAGECACHE;\n\n\t/* Have any file permissions changed? */\n\tif ((inode->i_mode & S_IALLUGO) != (fattr->mode & S_IALLUGO)\n\t\t\t|| inode->i_uid != fattr->uid\n\t\t\t|| inode->i_gid != fattr->gid)\n\t\tinvalid |= NFS_INO_INVALID_ATTR | NFS_INO_INVALID_ACCESS | NFS_INO_INVALID_ACL;\n\n\t/* Has the link count changed? */\n\tif (inode->i_nlink != fattr->nlink)\n\t\tinvalid |= NFS_INO_INVALID_ATTR;\n\n\tif (!timespec_equal(&inode->i_atime, &fattr->atime))\n\t\tinvalid |= NFS_INO_INVALID_ATIME;\n\n\tif (invalid != 0)\n\t\tnfsi->cache_validity |= invalid;\n\n\tnfsi->read_cache_jiffies = fattr->time_start;\n\treturn 0;\n}\n\nstatic int nfs_ctime_need_update(const struct inode *inode, const struct nfs_fattr *fattr)\n{\n\treturn timespec_compare(&fattr->ctime, &inode->i_ctime) > 0;\n}\n\nstatic int nfs_size_need_update(const struct inode *inode, const struct nfs_fattr *fattr)\n{\n\treturn nfs_size_to_loff_t(fattr->size) > i_size_read(inode);\n}\n\nstatic atomic_long_t nfs_attr_generation_counter;\n\nstatic unsigned long nfs_read_attr_generation_counter(void)\n{\n\treturn atomic_long_read(&nfs_attr_generation_counter);\n}\n\nunsigned long nfs_inc_attr_generation_counter(void)\n{\n\treturn atomic_long_inc_return(&nfs_attr_generation_counter);\n}\n\nvoid nfs_fattr_init(struct nfs_fattr *fattr)\n{\n\tfattr->valid = 0;\n\tfattr->time_start = jiffies;\n\tfattr->gencount = nfs_inc_attr_generation_counter();\n}\n\n/**\n * nfs_inode_attrs_need_update - check if the inode attributes need updating\n * @inode - pointer to inode\n * @fattr - attributes\n *\n * Attempt to divine whether or not an RPC call reply carrying stale\n * attributes got scheduled after another call carrying updated ones.\n *\n * To do so, the function first assumes that a more recent ctime means\n * that the attributes in fattr are newer, however it also attempt to\n * catch the case where ctime either didn't change, or went backwards\n * (if someone reset the clock on the server) by looking at whether\n * or not this RPC call was started after the inode was last updated.\n * Note also the check for wraparound of 'attr_gencount'\n *\n * The function returns 'true' if it thinks the attributes in 'fattr' are\n * more recent than the ones cached in the inode.\n *\n */\nstatic int nfs_inode_attrs_need_update(const struct inode *inode, const struct nfs_fattr *fattr)\n{\n\tconst struct nfs_inode *nfsi = NFS_I(inode);\n\n\treturn ((long)fattr->gencount - (long)nfsi->attr_gencount) > 0 ||\n\t\tnfs_ctime_need_update(inode, fattr) ||\n\t\tnfs_size_need_update(inode, fattr) ||\n\t\t((long)nfsi->attr_gencount - (long)nfs_read_attr_generation_counter() > 0);\n}\n\nstatic int nfs_refresh_inode_locked(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tif (nfs_inode_attrs_need_update(inode, fattr))\n\t\treturn nfs_update_inode(inode, fattr);\n\treturn nfs_check_inode_attributes(inode, fattr);\n}\n\n/**\n * nfs_refresh_inode - try to update the inode attribute cache\n * @inode - pointer to inode\n * @fattr - updated attributes\n *\n * Check that an RPC call that returned attributes has not overlapped with\n * other recent updates of the inode metadata, then decide whether it is\n * safe to do a full update of the inode attributes, or whether just to\n * call nfs_check_inode_attributes.\n */\nint nfs_refresh_inode(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tint status;\n\n\tif ((fattr->valid & NFS_ATTR_FATTR) == 0)\n\t\treturn 0;\n\tspin_lock(&inode->i_lock);\n\tstatus = nfs_refresh_inode_locked(inode, fattr);\n\tspin_unlock(&inode->i_lock);\n\treturn status;\n}\n\nstatic int nfs_post_op_update_inode_locked(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tnfsi->cache_validity |= NFS_INO_INVALID_ATTR|NFS_INO_REVAL_PAGECACHE;\n\tif (S_ISDIR(inode->i_mode))\n\t\tnfsi->cache_validity |= NFS_INO_INVALID_DATA;\n\tif ((fattr->valid & NFS_ATTR_FATTR) == 0)\n\t\treturn 0;\n\treturn nfs_refresh_inode_locked(inode, fattr);\n}\n\n/**\n * nfs_post_op_update_inode - try to update the inode attribute cache\n * @inode - pointer to inode\n * @fattr - updated attributes\n *\n * After an operation that has changed the inode metadata, mark the\n * attribute cache as being invalid, then try to update it.\n *\n * NB: if the server didn't return any post op attributes, this\n * function will force the retrieval of attributes before the next\n * NFS request.  Thus it should be used only for operations that\n * are expected to change one or more attributes, to avoid\n * unnecessary NFS requests and trips through nfs_update_inode().\n */\nint nfs_post_op_update_inode(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tint status;\n\n\tspin_lock(&inode->i_lock);\n\tstatus = nfs_post_op_update_inode_locked(inode, fattr);\n\tspin_unlock(&inode->i_lock);\n\treturn status;\n}\n\n/**\n * nfs_post_op_update_inode_force_wcc - try to update the inode attribute cache\n * @inode - pointer to inode\n * @fattr - updated attributes\n *\n * After an operation that has changed the inode metadata, mark the\n * attribute cache as being invalid, then try to update it. Fake up\n * weak cache consistency data, if none exist.\n *\n * This function is mainly designed to be used by the ->write_done() functions.\n */\nint nfs_post_op_update_inode_force_wcc(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tint status;\n\n\tspin_lock(&inode->i_lock);\n\t/* Don't do a WCC update if these attributes are already stale */\n\tif ((fattr->valid & NFS_ATTR_FATTR) == 0 ||\n\t\t\t!nfs_inode_attrs_need_update(inode, fattr)) {\n\t\tfattr->valid &= ~(NFS_ATTR_WCC_V4|NFS_ATTR_WCC);\n\t\tgoto out_noforce;\n\t}\n\tif ((fattr->valid & NFS_ATTR_FATTR_V4) != 0 &&\n\t\t\t(fattr->valid & NFS_ATTR_WCC_V4) == 0) {\n\t\tfattr->pre_change_attr = NFS_I(inode)->change_attr;\n\t\tfattr->valid |= NFS_ATTR_WCC_V4;\n\t}\n\tif ((fattr->valid & NFS_ATTR_FATTR) != 0 &&\n\t\t\t(fattr->valid & NFS_ATTR_WCC) == 0) {\n\t\tmemcpy(&fattr->pre_ctime, &inode->i_ctime, sizeof(fattr->pre_ctime));\n\t\tmemcpy(&fattr->pre_mtime, &inode->i_mtime, sizeof(fattr->pre_mtime));\n\t\tfattr->pre_size = i_size_read(inode);\n\t\tfattr->valid |= NFS_ATTR_WCC;\n\t}\nout_noforce:\n\tstatus = nfs_post_op_update_inode_locked(inode, fattr);\n\tspin_unlock(&inode->i_lock);\n\treturn status;\n}\n\n/*\n * Many nfs protocol calls return the new file attributes after\n * an operation.  Here we update the inode to reflect the state\n * of the server's inode.\n *\n * This is a bit tricky because we have to make sure all dirty pages\n * have been sent off to the server before calling invalidate_inode_pages.\n * To make sure no other process adds more write requests while we try\n * our best to flush them, we make them sleep during the attribute refresh.\n *\n * A very similar scenario holds for the dir cache.\n */\nstatic int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tstruct nfs_server *server;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tloff_t cur_isize, new_isize;\n\tunsigned long invalid = 0;\n\tunsigned long now = jiffies;\n\n\tdfprintk(VFS, \"NFS: %s(%s/%ld ct=%d info=0x%x)\\n\",\n\t\t\t__func__, inode->i_sb->s_id, inode->i_ino,\n\t\t\tatomic_read(&inode->i_count), fattr->valid);\n\n\tif (nfsi->fileid != fattr->fileid)\n\t\tgoto out_fileid;\n\n\t/*\n\t * Make sure the inode's type hasn't changed.\n\t */\n\tif ((inode->i_mode & S_IFMT) != (fattr->mode & S_IFMT))\n\t\tgoto out_changed;\n\n\tserver = NFS_SERVER(inode);\n\t/* Update the fsid? */\n\tif (S_ISDIR(inode->i_mode) &&\n\t\t\t!nfs_fsid_equal(&server->fsid, &fattr->fsid) &&\n\t\t\t!test_bit(NFS_INO_MOUNTPOINT, &nfsi->flags))\n\t\tserver->fsid = fattr->fsid;\n\n\t/*\n\t * Update the read time so we don't revalidate too often.\n\t */\n\tnfsi->read_cache_jiffies = fattr->time_start;\n\n\tnfsi->cache_validity &= ~(NFS_INO_INVALID_ATTR | NFS_INO_INVALID_ATIME\n\t\t\t| NFS_INO_REVAL_PAGECACHE);\n\n\t/* Do atomic weak cache consistency updates */\n\tnfs_wcc_update_inode(inode, fattr);\n\n\t/* More cache consistency checks */\n\tif (!(fattr->valid & NFS_ATTR_FATTR_V4)) {\n\t\t/* NFSv2/v3: Check if the mtime agrees */\n\t\tif (!timespec_equal(&inode->i_mtime, &fattr->mtime)) {\n\t\t\tdprintk(\"NFS: mtime change on server for file %s/%ld\\n\",\n\t\t\t\t\tinode->i_sb->s_id, inode->i_ino);\n\t\t\tinvalid |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_DATA;\n\t\t\tif (S_ISDIR(inode->i_mode))\n\t\t\t\tnfs_force_lookup_revalidate(inode);\n\t\t}\n\t\t/* If ctime has changed we should definitely clear access+acl caches */\n\t\tif (!timespec_equal(&inode->i_ctime, &fattr->ctime))\n\t\t\tinvalid |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_ACCESS|NFS_INO_INVALID_ACL;\n\t} else if (nfsi->change_attr != fattr->change_attr) {\n\t\tdprintk(\"NFS: change_attr change on server for file %s/%ld\\n\",\n\t\t\t\tinode->i_sb->s_id, inode->i_ino);\n\t\tinvalid |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_DATA|NFS_INO_INVALID_ACCESS|NFS_INO_INVALID_ACL;\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tnfs_force_lookup_revalidate(inode);\n\t}\n\n\t/* Check if our cached file size is stale */\n \tnew_isize = nfs_size_to_loff_t(fattr->size);\n\tcur_isize = i_size_read(inode);\n\tif (new_isize != cur_isize) {\n\t\t/* Do we perhaps have any outstanding writes, or has\n\t\t * the file grown beyond our last write? */\n\t\tif (nfsi->npages == 0 || new_isize > cur_isize) {\n\t\t\ti_size_write(inode, new_isize);\n\t\t\tinvalid |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_DATA;\n\t\t}\n\t\tdprintk(\"NFS: isize change on server for file %s/%ld\\n\",\n\t\t\t\tinode->i_sb->s_id, inode->i_ino);\n\t}\n\n\n\tmemcpy(&inode->i_mtime, &fattr->mtime, sizeof(inode->i_mtime));\n\tmemcpy(&inode->i_ctime, &fattr->ctime, sizeof(inode->i_ctime));\n\tmemcpy(&inode->i_atime, &fattr->atime, sizeof(inode->i_atime));\n\tnfsi->change_attr = fattr->change_attr;\n\n\tif ((inode->i_mode & S_IALLUGO) != (fattr->mode & S_IALLUGO) ||\n\t    inode->i_uid != fattr->uid ||\n\t    inode->i_gid != fattr->gid)\n\t\tinvalid |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_ACCESS|NFS_INO_INVALID_ACL;\n\n\tif (inode->i_nlink != fattr->nlink)\n\t\tinvalid |= NFS_INO_INVALID_ATTR;\n\n\tinode->i_mode = fattr->mode;\n\tinode->i_nlink = fattr->nlink;\n\tinode->i_uid = fattr->uid;\n\tinode->i_gid = fattr->gid;\n\n\tif (fattr->valid & (NFS_ATTR_FATTR_V3 | NFS_ATTR_FATTR_V4)) {\n\t\t/*\n\t\t * report the blocks in 512byte units\n\t\t */\n\t\tinode->i_blocks = nfs_calc_block_size(fattr->du.nfs3.used);\n \t} else {\n \t\tinode->i_blocks = fattr->du.nfs2.blocks;\n \t}\n\n\t/* Update attrtimeo value if we're out of the unstable period */\n\tif (invalid & NFS_INO_INVALID_ATTR) {\n\t\tnfs_inc_stats(inode, NFSIOS_ATTRINVALIDATE);\n\t\tnfsi->attrtimeo = NFS_MINATTRTIMEO(inode);\n\t\tnfsi->attrtimeo_timestamp = now;\n\t\tnfsi->attr_gencount = nfs_inc_attr_generation_counter();\n\t} else {\n\t\tif (!time_in_range(now, nfsi->attrtimeo_timestamp, nfsi->attrtimeo_timestamp + nfsi->attrtimeo)) {\n\t\t\tif ((nfsi->attrtimeo <<= 1) > NFS_MAXATTRTIMEO(inode))\n\t\t\t\tnfsi->attrtimeo = NFS_MAXATTRTIMEO(inode);\n\t\t\tnfsi->attrtimeo_timestamp = now;\n\t\t}\n\t}\n\tinvalid &= ~NFS_INO_INVALID_ATTR;\n\t/* Don't invalidate the data if we were to blame */\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)\n\t\t\t\t|| S_ISLNK(inode->i_mode)))\n\t\tinvalid &= ~NFS_INO_INVALID_DATA;\n\tif (!nfs_have_delegation(inode, FMODE_READ) ||\n\t\t\t(nfsi->cache_validity & NFS_INO_REVAL_FORCED))\n\t\tnfsi->cache_validity |= invalid;\n\tnfsi->cache_validity &= ~NFS_INO_REVAL_FORCED;\n\n\treturn 0;\n out_changed:\n\t/*\n\t * Big trouble! The inode has become a different object.\n\t */\n\tprintk(KERN_DEBUG \"%s: inode %ld mode changed, %07o to %07o\\n\",\n\t\t\t__func__, inode->i_ino, inode->i_mode, fattr->mode);\n out_err:\n\t/*\n\t * No need to worry about unhashing the dentry, as the\n\t * lookup validation will know that the inode is bad.\n\t * (But we fall through to invalidate the caches.)\n\t */\n\tnfs_invalidate_inode(inode);\n\treturn -ESTALE;\n\n out_fileid:\n\tprintk(KERN_ERR \"NFS: server %s error: fileid changed\\n\"\n\t\t\"fsid %s: expected fileid 0x%Lx, got 0x%Lx\\n\",\n\t\tNFS_SERVER(inode)->nfs_client->cl_hostname, inode->i_sb->s_id,\n\t\t(long long)nfsi->fileid, (long long)fattr->fileid);\n\tgoto out_err;\n}\n\n\n#ifdef CONFIG_NFS_V4\n\n/*\n * Clean out any remaining NFSv4 state that might be left over due\n * to open() calls that passed nfs_atomic_lookup, but failed to call\n * nfs_open().\n */\nvoid nfs4_clear_inode(struct inode *inode)\n{\n\t/* If we are holding a delegation, return it! */\n\tnfs_inode_return_delegation_noreclaim(inode);\n\t/* First call standard NFS clear_inode() code */\n\tnfs_clear_inode(inode);\n}\n#endif\n\nstruct inode *nfs_alloc_inode(struct super_block *sb)\n{\n\tstruct nfs_inode *nfsi;\n\tnfsi = (struct nfs_inode *)kmem_cache_alloc(nfs_inode_cachep, GFP_KERNEL);\n\tif (!nfsi)\n\t\treturn NULL;\n\tnfsi->flags = 0UL;\n\tnfsi->cache_validity = 0UL;\n#ifdef CONFIG_NFS_V3_ACL\n\tnfsi->acl_access = ERR_PTR(-EAGAIN);\n\tnfsi->acl_default = ERR_PTR(-EAGAIN);\n#endif\n#ifdef CONFIG_NFS_V4\n\tnfsi->nfs4_acl = NULL;\n#endif /* CONFIG_NFS_V4 */\n\treturn &nfsi->vfs_inode;\n}\n\nvoid nfs_destroy_inode(struct inode *inode)\n{\n\tkmem_cache_free(nfs_inode_cachep, NFS_I(inode));\n}\n\nstatic inline void nfs4_init_once(struct nfs_inode *nfsi)\n{\n#ifdef CONFIG_NFS_V4\n\tINIT_LIST_HEAD(&nfsi->open_states);\n\tnfsi->delegation = NULL;\n\tnfsi->delegation_state = 0;\n\tinit_rwsem(&nfsi->rwsem);\n#endif\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct nfs_inode *nfsi = (struct nfs_inode *) foo;\n\n\tinode_init_once(&nfsi->vfs_inode);\n\tINIT_LIST_HEAD(&nfsi->open_files);\n\tINIT_LIST_HEAD(&nfsi->access_cache_entry_lru);\n\tINIT_LIST_HEAD(&nfsi->access_cache_inode_lru);\n\tINIT_RADIX_TREE(&nfsi->nfs_page_tree, GFP_ATOMIC);\n\tnfsi->ncommit = 0;\n\tnfsi->npages = 0;\n\tatomic_set(&nfsi->silly_count, 1);\n\tINIT_HLIST_HEAD(&nfsi->silly_list);\n\tinit_waitqueue_head(&nfsi->waitqueue);\n\tnfs4_init_once(nfsi);\n}\n\nstatic int __init nfs_init_inodecache(void)\n{\n\tnfs_inode_cachep = kmem_cache_create(\"nfs_inode_cache\",\n\t\t\t\t\t     sizeof(struct nfs_inode),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (nfs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void nfs_destroy_inodecache(void)\n{\n\tkmem_cache_destroy(nfs_inode_cachep);\n}\n\nstruct workqueue_struct *nfsiod_workqueue;\n\n/*\n * start up the nfsiod workqueue\n */\nstatic int nfsiod_start(void)\n{\n\tstruct workqueue_struct *wq;\n\tdprintk(\"RPC:       creating workqueue nfsiod\\n\");\n\twq = create_singlethread_workqueue(\"nfsiod\");\n\tif (wq == NULL)\n\t\treturn -ENOMEM;\n\tnfsiod_workqueue = wq;\n\treturn 0;\n}\n\n/*\n * Destroy the nfsiod workqueue\n */\nstatic void nfsiod_stop(void)\n{\n\tstruct workqueue_struct *wq;\n\n\twq = nfsiod_workqueue;\n\tif (wq == NULL)\n\t\treturn;\n\tnfsiod_workqueue = NULL;\n\tdestroy_workqueue(wq);\n}\n\n/*\n * Initialize NFS\n */\nstatic int __init init_nfs_fs(void)\n{\n\tint err;\n\n\terr = nfsiod_start();\n\tif (err)\n\t\tgoto out6;\n\n\terr = nfs_fs_proc_init();\n\tif (err)\n\t\tgoto out5;\n\n\terr = nfs_init_nfspagecache();\n\tif (err)\n\t\tgoto out4;\n\n\terr = nfs_init_inodecache();\n\tif (err)\n\t\tgoto out3;\n\n\terr = nfs_init_readpagecache();\n\tif (err)\n\t\tgoto out2;\n\n\terr = nfs_init_writepagecache();\n\tif (err)\n\t\tgoto out1;\n\n\terr = nfs_init_directcache();\n\tif (err)\n\t\tgoto out0;\n\n#ifdef CONFIG_PROC_FS\n\trpc_proc_register(&nfs_rpcstat);\n#endif\n\tif ((err = register_nfs_fs()) != 0)\n\t\tgoto out;\n\treturn 0;\nout:\n#ifdef CONFIG_PROC_FS\n\trpc_proc_unregister(\"nfs\");\n#endif\n\tnfs_destroy_directcache();\nout0:\n\tnfs_destroy_writepagecache();\nout1:\n\tnfs_destroy_readpagecache();\nout2:\n\tnfs_destroy_inodecache();\nout3:\n\tnfs_destroy_nfspagecache();\nout4:\n\tnfs_fs_proc_exit();\nout5:\n\tnfsiod_stop();\nout6:\n\treturn err;\n}\n\nstatic void __exit exit_nfs_fs(void)\n{\n\tnfs_destroy_directcache();\n\tnfs_destroy_writepagecache();\n\tnfs_destroy_readpagecache();\n\tnfs_destroy_inodecache();\n\tnfs_destroy_nfspagecache();\n#ifdef CONFIG_PROC_FS\n\trpc_proc_unregister(\"nfs\");\n#endif\n\tunregister_nfs_fs();\n\tnfs_fs_proc_exit();\n\tnfsiod_stop();\n}\n\n/* Not quite true; I just maintain it */\nMODULE_AUTHOR(\"Olaf Kirch <okir@monad.swb.de>\");\nMODULE_LICENSE(\"GPL\");\nmodule_param(enable_ino64, bool, 0644);\n\nmodule_init(init_nfs_fs)\nmodule_exit(exit_nfs_fs)\n", "/*\n * linux/fs/nfs/nfs4_fs.h\n *\n * Copyright (C) 2005 Trond Myklebust\n *\n * NFSv4-specific filesystem definitions and declarations\n */\n\n#ifndef __LINUX_FS_NFS_NFS4_FS_H\n#define __LINUX_FS_NFS_NFS4_FS_H\n\n#ifdef CONFIG_NFS_V4\n\nstruct idmap;\n\n/*\n * In a seqid-mutating op, this macro controls which error return\n * values trigger incrementation of the seqid.\n *\n * from rfc 3010:\n * The client MUST monotonically increment the sequence number for the\n * CLOSE, LOCK, LOCKU, OPEN, OPEN_CONFIRM, and OPEN_DOWNGRADE\n * operations.  This is true even in the event that the previous\n * operation that used the sequence number received an error.  The only\n * exception to this rule is if the previous operation received one of\n * the following errors: NFSERR_STALE_CLIENTID, NFSERR_STALE_STATEID,\n * NFSERR_BAD_STATEID, NFSERR_BAD_SEQID, NFSERR_BADXDR,\n * NFSERR_RESOURCE, NFSERR_NOFILEHANDLE.\n *\n */\n#define seqid_mutating_err(err)       \\\n(((err) != NFSERR_STALE_CLIENTID) &&  \\\n ((err) != NFSERR_STALE_STATEID)  &&  \\\n ((err) != NFSERR_BAD_STATEID)    &&  \\\n ((err) != NFSERR_BAD_SEQID)      &&  \\\n ((err) != NFSERR_BAD_XDR)        &&  \\\n ((err) != NFSERR_RESOURCE)       &&  \\\n ((err) != NFSERR_NOFILEHANDLE))\n\nenum nfs4_client_state {\n\tNFS4CLNT_MANAGER_RUNNING  = 0,\n\tNFS4CLNT_CHECK_LEASE,\n\tNFS4CLNT_LEASE_EXPIRED,\n\tNFS4CLNT_RECLAIM_REBOOT,\n\tNFS4CLNT_RECLAIM_NOGRACE,\n\tNFS4CLNT_DELEGRETURN,\n};\n\n/*\n * struct rpc_sequence ensures that RPC calls are sent in the exact\n * order that they appear on the list.\n */\nstruct rpc_sequence {\n\tstruct rpc_wait_queue\twait;\t/* RPC call delay queue */\n\tspinlock_t lock;\t\t/* Protects the list */\n\tstruct list_head list;\t\t/* Defines sequence of RPC calls */\n};\n\n#define NFS_SEQID_CONFIRMED 1\nstruct nfs_seqid_counter {\n\tstruct rpc_sequence *sequence;\n\tint flags;\n\tu32 counter;\n};\n\nstruct nfs_seqid {\n\tstruct nfs_seqid_counter *sequence;\n\tstruct list_head list;\n};\n\nstatic inline void nfs_confirm_seqid(struct nfs_seqid_counter *seqid, int status)\n{\n\tif (seqid_mutating_err(-status))\n\t\tseqid->flags |= NFS_SEQID_CONFIRMED;\n}\n\nstruct nfs_unique_id {\n\tstruct rb_node rb_node;\n\t__u64 id;\n};\n\n/*\n * NFS4 state_owners and lock_owners are simply labels for ordered\n * sequences of RPC calls. Their sole purpose is to provide once-only\n * semantics by allowing the server to identify replayed requests.\n */\nstruct nfs4_state_owner {\n\tstruct nfs_unique_id so_owner_id;\n\tstruct nfs_client    *so_client;\n\tstruct nfs_server    *so_server;\n\tstruct rb_node\t     so_client_node;\n\n\tstruct rpc_cred\t     *so_cred;\t /* Associated cred */\n\n\tspinlock_t\t     so_lock;\n\tatomic_t\t     so_count;\n\tunsigned long\t     so_flags;\n\tstruct list_head     so_states;\n\tstruct list_head     so_delegations;\n\tstruct nfs_seqid_counter so_seqid;\n\tstruct rpc_sequence  so_sequence;\n};\n\nenum {\n\tNFS_OWNER_RECLAIM_REBOOT,\n\tNFS_OWNER_RECLAIM_NOGRACE\n};\n\n/*\n * struct nfs4_state maintains the client-side state for a given\n * (state_owner,inode) tuple (OPEN) or state_owner (LOCK).\n *\n * OPEN:\n * In order to know when to OPEN_DOWNGRADE or CLOSE the state on the server,\n * we need to know how many files are open for reading or writing on a\n * given inode. This information too is stored here.\n *\n * LOCK: one nfs4_state (LOCK) to hold the lock stateid nfs4_state(OPEN)\n */\n\nstruct nfs4_lock_state {\n\tstruct list_head\tls_locks;\t/* Other lock stateids */\n\tstruct nfs4_state *\tls_state;\t/* Pointer to open state */\n\tfl_owner_t\t\tls_owner;\t/* POSIX lock owner */\n#define NFS_LOCK_INITIALIZED 1\n\tint\t\t\tls_flags;\n\tstruct nfs_seqid_counter\tls_seqid;\n\tstruct rpc_sequence\tls_sequence;\n\tstruct nfs_unique_id\tls_id;\n\tnfs4_stateid\t\tls_stateid;\n\tatomic_t\t\tls_count;\n};\n\n/* bits for nfs4_state->flags */\nenum {\n\tLK_STATE_IN_USE,\n\tNFS_DELEGATED_STATE,\t\t/* Current stateid is delegation */\n\tNFS_O_RDONLY_STATE,\t\t/* OPEN stateid has read-only state */\n\tNFS_O_WRONLY_STATE,\t\t/* OPEN stateid has write-only state */\n\tNFS_O_RDWR_STATE,\t\t/* OPEN stateid has read/write state */\n\tNFS_STATE_RECLAIM_REBOOT,\t/* OPEN stateid server rebooted */\n\tNFS_STATE_RECLAIM_NOGRACE,\t/* OPEN stateid needs to recover state */\n};\n\nstruct nfs4_state {\n\tstruct list_head open_states;\t/* List of states for the same state_owner */\n\tstruct list_head inode_states;\t/* List of states for the same inode */\n\tstruct list_head lock_states;\t/* List of subservient lock stateids */\n\n\tstruct nfs4_state_owner *owner;\t/* Pointer to the open owner */\n\tstruct inode *inode;\t\t/* Pointer to the inode */\n\n\tunsigned long flags;\t\t/* Do we hold any locks? */\n\tspinlock_t state_lock;\t\t/* Protects the lock_states list */\n\n\tseqlock_t seqlock;\t\t/* Protects the stateid/open_stateid */\n\tnfs4_stateid stateid;\t\t/* Current stateid: may be delegation */\n\tnfs4_stateid open_stateid;\t/* OPEN stateid */\n\n\t/* The following 3 fields are protected by owner->so_lock */\n\tunsigned int n_rdonly;\t\t/* Number of read-only references */\n\tunsigned int n_wronly;\t\t/* Number of write-only references */\n\tunsigned int n_rdwr;\t\t/* Number of read/write references */\n\tfmode_t state;\t\t\t/* State on the server (R,W, or RW) */\n\tatomic_t count;\n};\n\n\nstruct nfs4_exception {\n\tlong timeout;\n\tint retry;\n\tstruct nfs4_state *state;\n};\n\nstruct nfs4_state_recovery_ops {\n\tint owner_flag_bit;\n\tint state_flag_bit;\n\tint (*recover_open)(struct nfs4_state_owner *, struct nfs4_state *);\n\tint (*recover_lock)(struct nfs4_state *, struct file_lock *);\n};\n\nextern struct dentry_operations nfs4_dentry_operations;\nextern const struct inode_operations nfs4_dir_inode_operations;\n\n/* inode.c */\nextern ssize_t nfs4_getxattr(struct dentry *, const char *, void *, size_t);\nextern int nfs4_setxattr(struct dentry *, const char *, const void *, size_t, int);\nextern ssize_t nfs4_listxattr(struct dentry *, char *, size_t);\n\n\n/* nfs4proc.c */\nextern int nfs4_map_errors(int err);\nextern int nfs4_proc_setclientid(struct nfs_client *, u32, unsigned short, struct rpc_cred *);\nextern int nfs4_proc_setclientid_confirm(struct nfs_client *, struct rpc_cred *);\nextern int nfs4_proc_async_renew(struct nfs_client *, struct rpc_cred *);\nextern int nfs4_proc_renew(struct nfs_client *, struct rpc_cred *);\nextern int nfs4_do_close(struct path *path, struct nfs4_state *state, int wait);\nextern struct dentry *nfs4_atomic_open(struct inode *, struct dentry *, struct nameidata *);\nextern int nfs4_open_revalidate(struct inode *, struct dentry *, int, struct nameidata *);\nextern int nfs4_server_capabilities(struct nfs_server *server, struct nfs_fh *fhandle);\nextern int nfs4_proc_fs_locations(struct inode *dir, const struct qstr *name,\n\t\tstruct nfs4_fs_locations *fs_locations, struct page *page);\n\nextern struct nfs4_state_recovery_ops nfs4_reboot_recovery_ops;\nextern struct nfs4_state_recovery_ops nfs4_nograce_recovery_ops;\n\nextern const u32 nfs4_fattr_bitmap[2];\nextern const u32 nfs4_statfs_bitmap[2];\nextern const u32 nfs4_pathconf_bitmap[2];\nextern const u32 nfs4_fsinfo_bitmap[2];\nextern const u32 nfs4_fs_locations_bitmap[2];\n\n/* nfs4renewd.c */\nextern void nfs4_schedule_state_renewal(struct nfs_client *);\nextern void nfs4_renewd_prepare_shutdown(struct nfs_server *);\nextern void nfs4_kill_renewd(struct nfs_client *);\nextern void nfs4_renew_state(struct work_struct *);\n\n/* nfs4state.c */\nstruct rpc_cred *nfs4_get_renew_cred_locked(struct nfs_client *clp);\n\nextern struct nfs4_state_owner * nfs4_get_state_owner(struct nfs_server *, struct rpc_cred *);\nextern void nfs4_put_state_owner(struct nfs4_state_owner *);\nextern struct nfs4_state * nfs4_get_open_state(struct inode *, struct nfs4_state_owner *);\nextern void nfs4_put_open_state(struct nfs4_state *);\nextern void nfs4_close_state(struct path *, struct nfs4_state *, fmode_t);\nextern void nfs4_close_sync(struct path *, struct nfs4_state *, fmode_t);\nextern void nfs4_state_set_mode_locked(struct nfs4_state *, fmode_t);\nextern void nfs4_schedule_state_recovery(struct nfs_client *);\nextern void nfs4_schedule_state_manager(struct nfs_client *);\nextern int nfs4_state_mark_reclaim_nograce(struct nfs_client *clp, struct nfs4_state *state);\nextern void nfs4_put_lock_state(struct nfs4_lock_state *lsp);\nextern int nfs4_set_lock_state(struct nfs4_state *state, struct file_lock *fl);\nextern void nfs4_copy_stateid(nfs4_stateid *, struct nfs4_state *, fl_owner_t);\n\nextern struct nfs_seqid *nfs_alloc_seqid(struct nfs_seqid_counter *counter);\nextern int nfs_wait_on_sequence(struct nfs_seqid *seqid, struct rpc_task *task);\nextern void nfs_increment_open_seqid(int status, struct nfs_seqid *seqid);\nextern void nfs_increment_lock_seqid(int status, struct nfs_seqid *seqid);\nextern void nfs_free_seqid(struct nfs_seqid *seqid);\n\nextern const nfs4_stateid zero_stateid;\n\n/* nfs4xdr.c */\nextern __be32 *nfs4_decode_dirent(__be32 *p, struct nfs_entry *entry, int plus);\nextern struct rpc_procinfo nfs4_procedures[];\n\nstruct nfs4_mount_data;\n\n/* callback_xdr.c */\nextern struct svc_version nfs4_callback_version1;\n\n#else\n\n#define nfs4_close_state(a, b, c) do { } while (0)\n#define nfs4_close_sync(a, b, c) do { } while (0)\n\n#endif /* CONFIG_NFS_V4 */\n#endif /* __LINUX_FS_NFS_NFS4_FS.H */\n", "/*\n *  fs/nfs/nfs4proc.c\n *\n *  Client-side procedure declarations for NFSv4.\n *\n *  Copyright (c) 2002 The Regents of the University of Michigan.\n *  All rights reserved.\n *\n *  Kendrick Smith <kmsmith@umich.edu>\n *  Andy Adamson   <andros@umich.edu>\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions\n *  are met:\n *\n *  1. Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *  2. Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *  3. Neither the name of the University nor the names of its\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED\n *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n *  DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n *  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <linux/mm.h>\n#include <linux/utsname.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/smp_lock.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n\n#include \"nfs4_fs.h\"\n#include \"delegation.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_PROC\n\n#define NFS4_POLL_RETRY_MIN\t(HZ/10)\n#define NFS4_POLL_RETRY_MAX\t(15*HZ)\n\nstruct nfs4_opendata;\nstatic int _nfs4_proc_open(struct nfs4_opendata *data);\nstatic int nfs4_do_fsinfo(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *);\nstatic int nfs4_async_handle_error(struct rpc_task *, const struct nfs_server *, struct nfs4_state *);\nstatic int _nfs4_proc_lookup(struct inode *dir, const struct qstr *name, struct nfs_fh *fhandle, struct nfs_fattr *fattr);\nstatic int _nfs4_proc_getattr(struct nfs_server *server, struct nfs_fh *fhandle, struct nfs_fattr *fattr);\n\n/* Prevent leaks of NFSv4 errors into userland */\nint nfs4_map_errors(int err)\n{\n\tif (err < -1000) {\n\t\tdprintk(\"%s could not handle NFSv4 error %d\\n\",\n\t\t\t\t__func__, -err);\n\t\treturn -EIO;\n\t}\n\treturn err;\n}\n\n/*\n * This is our standard bitmap for GETATTR requests.\n */\nconst u32 nfs4_fattr_bitmap[2] = {\n\tFATTR4_WORD0_TYPE\n\t| FATTR4_WORD0_CHANGE\n\t| FATTR4_WORD0_SIZE\n\t| FATTR4_WORD0_FSID\n\t| FATTR4_WORD0_FILEID,\n\tFATTR4_WORD1_MODE\n\t| FATTR4_WORD1_NUMLINKS\n\t| FATTR4_WORD1_OWNER\n\t| FATTR4_WORD1_OWNER_GROUP\n\t| FATTR4_WORD1_RAWDEV\n\t| FATTR4_WORD1_SPACE_USED\n\t| FATTR4_WORD1_TIME_ACCESS\n\t| FATTR4_WORD1_TIME_METADATA\n\t| FATTR4_WORD1_TIME_MODIFY\n};\n\nconst u32 nfs4_statfs_bitmap[2] = {\n\tFATTR4_WORD0_FILES_AVAIL\n\t| FATTR4_WORD0_FILES_FREE\n\t| FATTR4_WORD0_FILES_TOTAL,\n\tFATTR4_WORD1_SPACE_AVAIL\n\t| FATTR4_WORD1_SPACE_FREE\n\t| FATTR4_WORD1_SPACE_TOTAL\n};\n\nconst u32 nfs4_pathconf_bitmap[2] = {\n\tFATTR4_WORD0_MAXLINK\n\t| FATTR4_WORD0_MAXNAME,\n\t0\n};\n\nconst u32 nfs4_fsinfo_bitmap[2] = { FATTR4_WORD0_MAXFILESIZE\n\t\t\t| FATTR4_WORD0_MAXREAD\n\t\t\t| FATTR4_WORD0_MAXWRITE\n\t\t\t| FATTR4_WORD0_LEASE_TIME,\n\t\t\t0\n};\n\nconst u32 nfs4_fs_locations_bitmap[2] = {\n\tFATTR4_WORD0_TYPE\n\t| FATTR4_WORD0_CHANGE\n\t| FATTR4_WORD0_SIZE\n\t| FATTR4_WORD0_FSID\n\t| FATTR4_WORD0_FILEID\n\t| FATTR4_WORD0_FS_LOCATIONS,\n\tFATTR4_WORD1_MODE\n\t| FATTR4_WORD1_NUMLINKS\n\t| FATTR4_WORD1_OWNER\n\t| FATTR4_WORD1_OWNER_GROUP\n\t| FATTR4_WORD1_RAWDEV\n\t| FATTR4_WORD1_SPACE_USED\n\t| FATTR4_WORD1_TIME_ACCESS\n\t| FATTR4_WORD1_TIME_METADATA\n\t| FATTR4_WORD1_TIME_MODIFY\n\t| FATTR4_WORD1_MOUNTED_ON_FILEID\n};\n\nstatic void nfs4_setup_readdir(u64 cookie, __be32 *verifier, struct dentry *dentry,\n\t\tstruct nfs4_readdir_arg *readdir)\n{\n\t__be32 *start, *p;\n\n\tBUG_ON(readdir->count < 80);\n\tif (cookie > 2) {\n\t\treaddir->cookie = cookie;\n\t\tmemcpy(&readdir->verifier, verifier, sizeof(readdir->verifier));\n\t\treturn;\n\t}\n\n\treaddir->cookie = 0;\n\tmemset(&readdir->verifier, 0, sizeof(readdir->verifier));\n\tif (cookie == 2)\n\t\treturn;\n\t\n\t/*\n\t * NFSv4 servers do not return entries for '.' and '..'\n\t * Therefore, we fake these entries here.  We let '.'\n\t * have cookie 0 and '..' have cookie 1.  Note that\n\t * when talking to the server, we always send cookie 0\n\t * instead of 1 or 2.\n\t */\n\tstart = p = kmap_atomic(*readdir->pages, KM_USER0);\n\t\n\tif (cookie == 0) {\n\t\t*p++ = xdr_one;                                  /* next */\n\t\t*p++ = xdr_zero;                   /* cookie, first word */\n\t\t*p++ = xdr_one;                   /* cookie, second word */\n\t\t*p++ = xdr_one;                             /* entry len */\n\t\tmemcpy(p, \".\\0\\0\\0\", 4);                        /* entry */\n\t\tp++;\n\t\t*p++ = xdr_one;                         /* bitmap length */\n\t\t*p++ = htonl(FATTR4_WORD0_FILEID);             /* bitmap */\n\t\t*p++ = htonl(8);              /* attribute buffer length */\n\t\tp = xdr_encode_hyper(p, NFS_FILEID(dentry->d_inode));\n\t}\n\t\n\t*p++ = xdr_one;                                  /* next */\n\t*p++ = xdr_zero;                   /* cookie, first word */\n\t*p++ = xdr_two;                   /* cookie, second word */\n\t*p++ = xdr_two;                             /* entry len */\n\tmemcpy(p, \"..\\0\\0\", 4);                         /* entry */\n\tp++;\n\t*p++ = xdr_one;                         /* bitmap length */\n\t*p++ = htonl(FATTR4_WORD0_FILEID);             /* bitmap */\n\t*p++ = htonl(8);              /* attribute buffer length */\n\tp = xdr_encode_hyper(p, NFS_FILEID(dentry->d_parent->d_inode));\n\n\treaddir->pgbase = (char *)p - (char *)start;\n\treaddir->count -= readdir->pgbase;\n\tkunmap_atomic(start, KM_USER0);\n}\n\nstatic int nfs4_wait_bit_killable(void *word)\n{\n\tif (fatal_signal_pending(current))\n\t\treturn -ERESTARTSYS;\n\tschedule();\n\treturn 0;\n}\n\nstatic int nfs4_wait_clnt_recover(struct nfs_client *clp)\n{\n\tint res;\n\n\tmight_sleep();\n\n\tres = wait_on_bit(&clp->cl_state, NFS4CLNT_MANAGER_RUNNING,\n\t\t\tnfs4_wait_bit_killable, TASK_KILLABLE);\n\treturn res;\n}\n\nstatic int nfs4_delay(struct rpc_clnt *clnt, long *timeout)\n{\n\tint res = 0;\n\n\tmight_sleep();\n\n\tif (*timeout <= 0)\n\t\t*timeout = NFS4_POLL_RETRY_MIN;\n\tif (*timeout > NFS4_POLL_RETRY_MAX)\n\t\t*timeout = NFS4_POLL_RETRY_MAX;\n\tschedule_timeout_killable(*timeout);\n\tif (fatal_signal_pending(current))\n\t\tres = -ERESTARTSYS;\n\t*timeout <<= 1;\n\treturn res;\n}\n\n/* This is the error handling routine for processes that are allowed\n * to sleep.\n */\nstatic int nfs4_handle_exception(const struct nfs_server *server, int errorcode, struct nfs4_exception *exception)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_state *state = exception->state;\n\tint ret = errorcode;\n\n\texception->retry = 0;\n\tswitch(errorcode) {\n\t\tcase 0:\n\t\t\treturn 0;\n\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_OPENMODE:\n\t\t\tif (state == NULL)\n\t\t\t\tbreak;\n\t\t\tnfs4_state_mark_reclaim_nograce(clp, state);\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tnfs4_schedule_state_recovery(clp);\n\t\t\tret = nfs4_wait_clnt_recover(clp);\n\t\t\tif (ret == 0)\n\t\t\t\texception->retry = 1;\n\t\t\tbreak;\n\t\tcase -NFS4ERR_FILE_OPEN:\n\t\tcase -NFS4ERR_GRACE:\n\t\tcase -NFS4ERR_DELAY:\n\t\t\tret = nfs4_delay(server->client, &exception->timeout);\n\t\t\tif (ret != 0)\n\t\t\t\tbreak;\n\t\tcase -NFS4ERR_OLD_STATEID:\n\t\t\texception->retry = 1;\n\t}\n\t/* We failed to handle the error */\n\treturn nfs4_map_errors(ret);\n}\n\n\nstatic void renew_lease(const struct nfs_server *server, unsigned long timestamp)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tspin_lock(&clp->cl_lock);\n\tif (time_before(clp->cl_last_renewal,timestamp))\n\t\tclp->cl_last_renewal = timestamp;\n\tspin_unlock(&clp->cl_lock);\n}\n\nstatic void update_changeattr(struct inode *dir, struct nfs4_change_info *cinfo)\n{\n\tstruct nfs_inode *nfsi = NFS_I(dir);\n\n\tspin_lock(&dir->i_lock);\n\tnfsi->cache_validity |= NFS_INO_INVALID_ATTR|NFS_INO_REVAL_PAGECACHE|NFS_INO_INVALID_DATA;\n\tif (!cinfo->atomic || cinfo->before != nfsi->change_attr)\n\t\tnfs_force_lookup_revalidate(dir);\n\tnfsi->change_attr = cinfo->after;\n\tspin_unlock(&dir->i_lock);\n}\n\nstruct nfs4_opendata {\n\tstruct kref kref;\n\tstruct nfs_openargs o_arg;\n\tstruct nfs_openres o_res;\n\tstruct nfs_open_confirmargs c_arg;\n\tstruct nfs_open_confirmres c_res;\n\tstruct nfs_fattr f_attr;\n\tstruct nfs_fattr dir_attr;\n\tstruct path path;\n\tstruct dentry *dir;\n\tstruct nfs4_state_owner *owner;\n\tstruct nfs4_state *state;\n\tstruct iattr attrs;\n\tunsigned long timestamp;\n\tunsigned int rpc_done : 1;\n\tint rpc_status;\n\tint cancelled;\n};\n\n\nstatic void nfs4_init_opendata_res(struct nfs4_opendata *p)\n{\n\tp->o_res.f_attr = &p->f_attr;\n\tp->o_res.dir_attr = &p->dir_attr;\n\tp->o_res.seqid = p->o_arg.seqid;\n\tp->c_res.seqid = p->c_arg.seqid;\n\tp->o_res.server = p->o_arg.server;\n\tnfs_fattr_init(&p->f_attr);\n\tnfs_fattr_init(&p->dir_attr);\n}\n\nstatic struct nfs4_opendata *nfs4_opendata_alloc(struct path *path,\n\t\tstruct nfs4_state_owner *sp, fmode_t fmode, int flags,\n\t\tconst struct iattr *attrs)\n{\n\tstruct dentry *parent = dget_parent(path->dentry);\n\tstruct inode *dir = parent->d_inode;\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs4_opendata *p;\n\n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (p == NULL)\n\t\tgoto err;\n\tp->o_arg.seqid = nfs_alloc_seqid(&sp->so_seqid);\n\tif (p->o_arg.seqid == NULL)\n\t\tgoto err_free;\n\tp->path.mnt = mntget(path->mnt);\n\tp->path.dentry = dget(path->dentry);\n\tp->dir = parent;\n\tp->owner = sp;\n\tatomic_inc(&sp->so_count);\n\tp->o_arg.fh = NFS_FH(dir);\n\tp->o_arg.open_flags = flags;\n\tp->o_arg.fmode = fmode & (FMODE_READ|FMODE_WRITE);\n\tp->o_arg.clientid = server->nfs_client->cl_clientid;\n\tp->o_arg.id = sp->so_owner_id.id;\n\tp->o_arg.name = &p->path.dentry->d_name;\n\tp->o_arg.server = server;\n\tp->o_arg.bitmask = server->attr_bitmask;\n\tp->o_arg.claim = NFS4_OPEN_CLAIM_NULL;\n\tif (flags & O_EXCL) {\n\t\tu32 *s = (u32 *) p->o_arg.u.verifier.data;\n\t\ts[0] = jiffies;\n\t\ts[1] = current->pid;\n\t} else if (flags & O_CREAT) {\n\t\tp->o_arg.u.attrs = &p->attrs;\n\t\tmemcpy(&p->attrs, attrs, sizeof(p->attrs));\n\t}\n\tp->c_arg.fh = &p->o_res.fh;\n\tp->c_arg.stateid = &p->o_res.stateid;\n\tp->c_arg.seqid = p->o_arg.seqid;\n\tnfs4_init_opendata_res(p);\n\tkref_init(&p->kref);\n\treturn p;\nerr_free:\n\tkfree(p);\nerr:\n\tdput(parent);\n\treturn NULL;\n}\n\nstatic void nfs4_opendata_free(struct kref *kref)\n{\n\tstruct nfs4_opendata *p = container_of(kref,\n\t\t\tstruct nfs4_opendata, kref);\n\n\tnfs_free_seqid(p->o_arg.seqid);\n\tif (p->state != NULL)\n\t\tnfs4_put_open_state(p->state);\n\tnfs4_put_state_owner(p->owner);\n\tdput(p->dir);\n\tpath_put(&p->path);\n\tkfree(p);\n}\n\nstatic void nfs4_opendata_put(struct nfs4_opendata *p)\n{\n\tif (p != NULL)\n\t\tkref_put(&p->kref, nfs4_opendata_free);\n}\n\nstatic int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}\n\nstatic int can_open_cached(struct nfs4_state *state, fmode_t mode, int open_mode)\n{\n\tint ret = 0;\n\n\tif (open_mode & O_EXCL)\n\t\tgoto out;\n\tswitch (mode & (FMODE_READ|FMODE_WRITE)) {\n\t\tcase FMODE_READ:\n\t\t\tret |= test_bit(NFS_O_RDONLY_STATE, &state->flags) != 0;\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tret |= test_bit(NFS_O_WRONLY_STATE, &state->flags) != 0;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tret |= test_bit(NFS_O_RDWR_STATE, &state->flags) != 0;\n\t}\nout:\n\treturn ret;\n}\n\nstatic int can_open_delegated(struct nfs_delegation *delegation, fmode_t fmode)\n{\n\tif ((delegation->type & fmode) != fmode)\n\t\treturn 0;\n\tif (test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags))\n\t\treturn 0;\n\tnfs_mark_delegation_referenced(delegation);\n\treturn 1;\n}\n\nstatic void update_open_stateflags(struct nfs4_state *state, fmode_t fmode)\n{\n\tswitch (fmode) {\n\t\tcase FMODE_WRITE:\n\t\t\tstate->n_wronly++;\n\t\t\tbreak;\n\t\tcase FMODE_READ:\n\t\t\tstate->n_rdonly++;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tstate->n_rdwr++;\n\t}\n\tnfs4_state_set_mode_locked(state, state->state | fmode);\n}\n\nstatic void nfs_set_open_stateid_locked(struct nfs4_state *state, nfs4_stateid *stateid, fmode_t fmode)\n{\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0)\n\t\tmemcpy(state->stateid.data, stateid->data, sizeof(state->stateid.data));\n\tmemcpy(state->open_stateid.data, stateid->data, sizeof(state->open_stateid.data));\n\tswitch (fmode) {\n\t\tcase FMODE_READ:\n\t\t\tset_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tset_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tset_bit(NFS_O_RDWR_STATE, &state->flags);\n\t}\n}\n\nstatic void nfs_set_open_stateid(struct nfs4_state *state, nfs4_stateid *stateid, fmode_t fmode)\n{\n\twrite_seqlock(&state->seqlock);\n\tnfs_set_open_stateid_locked(state, stateid, fmode);\n\twrite_sequnlock(&state->seqlock);\n}\n\nstatic void __update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, const nfs4_stateid *deleg_stateid, fmode_t fmode)\n{\n\t/*\n\t * Protect the call to nfs4_state_set_mode_locked and\n\t * serialise the stateid update\n\t */\n\twrite_seqlock(&state->seqlock);\n\tif (deleg_stateid != NULL) {\n\t\tmemcpy(state->stateid.data, deleg_stateid->data, sizeof(state->stateid.data));\n\t\tset_bit(NFS_DELEGATED_STATE, &state->flags);\n\t}\n\tif (open_stateid != NULL)\n\t\tnfs_set_open_stateid_locked(state, open_stateid, fmode);\n\twrite_sequnlock(&state->seqlock);\n\tspin_lock(&state->owner->so_lock);\n\tupdate_open_stateflags(state, fmode);\n\tspin_unlock(&state->owner->so_lock);\n}\n\nstatic int update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, nfs4_stateid *delegation, fmode_t fmode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_delegation *deleg_cur;\n\tint ret = 0;\n\n\tfmode &= (FMODE_READ|FMODE_WRITE);\n\n\trcu_read_lock();\n\tdeleg_cur = rcu_dereference(nfsi->delegation);\n\tif (deleg_cur == NULL)\n\t\tgoto no_delegation;\n\n\tspin_lock(&deleg_cur->lock);\n\tif (nfsi->delegation != deleg_cur ||\n\t    (deleg_cur->type & fmode) != fmode)\n\t\tgoto no_delegation_unlock;\n\n\tif (delegation == NULL)\n\t\tdelegation = &deleg_cur->stateid;\n\telse if (memcmp(deleg_cur->stateid.data, delegation->data, NFS4_STATEID_SIZE) != 0)\n\t\tgoto no_delegation_unlock;\n\n\tnfs_mark_delegation_referenced(deleg_cur);\n\t__update_open_stateid(state, open_stateid, &deleg_cur->stateid, fmode);\n\tret = 1;\nno_delegation_unlock:\n\tspin_unlock(&deleg_cur->lock);\nno_delegation:\n\trcu_read_unlock();\n\n\tif (!ret && open_stateid != NULL) {\n\t\t__update_open_stateid(state, open_stateid, NULL, fmode);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\n\nstatic void nfs4_return_incompatible_delegation(struct inode *inode, fmode_t fmode)\n{\n\tstruct nfs_delegation *delegation;\n\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n\tif (delegation == NULL || (delegation->type & fmode) == fmode) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\trcu_read_unlock();\n\tnfs_inode_return_delegation(inode);\n}\n\nstatic struct nfs4_state *nfs4_try_open_cached(struct nfs4_opendata *opendata)\n{\n\tstruct nfs4_state *state = opendata->state;\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_delegation *delegation;\n\tint open_mode = opendata->o_arg.open_flags & O_EXCL;\n\tfmode_t fmode = opendata->o_arg.fmode;\n\tnfs4_stateid stateid;\n\tint ret = -EAGAIN;\n\n\tfor (;;) {\n\t\tif (can_open_cached(state, fmode, open_mode)) {\n\t\t\tspin_lock(&state->owner->so_lock);\n\t\t\tif (can_open_cached(state, fmode, open_mode)) {\n\t\t\t\tupdate_open_stateflags(state, fmode);\n\t\t\t\tspin_unlock(&state->owner->so_lock);\n\t\t\t\tgoto out_return_state;\n\t\t\t}\n\t\t\tspin_unlock(&state->owner->so_lock);\n\t\t}\n\t\trcu_read_lock();\n\t\tdelegation = rcu_dereference(nfsi->delegation);\n\t\tif (delegation == NULL ||\n\t\t    !can_open_delegated(delegation, fmode)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\t/* Save the delegation */\n\t\tmemcpy(stateid.data, delegation->stateid.data, sizeof(stateid.data));\n\t\trcu_read_unlock();\n\t\tret = nfs_may_open(state->inode, state->owner->so_cred, open_mode);\n\t\tif (ret != 0)\n\t\t\tgoto out;\n\t\tret = -EAGAIN;\n\n\t\t/* Try to update the stateid using the delegation */\n\t\tif (update_open_stateid(state, NULL, &stateid, fmode))\n\t\t\tgoto out_return_state;\n\t}\nout:\n\treturn ERR_PTR(ret);\nout_return_state:\n\tatomic_inc(&state->count);\n\treturn state;\n}\n\nstatic struct nfs4_state *nfs4_opendata_to_nfs4_state(struct nfs4_opendata *data)\n{\n\tstruct inode *inode;\n\tstruct nfs4_state *state = NULL;\n\tstruct nfs_delegation *delegation;\n\tint ret;\n\n\tif (!data->rpc_done) {\n\t\tstate = nfs4_try_open_cached(data);\n\t\tgoto out;\n\t}\n\n\tret = -EAGAIN;\n\tif (!(data->f_attr.valid & NFS_ATTR_FATTR))\n\t\tgoto err;\n\tinode = nfs_fhget(data->dir->d_sb, &data->o_res.fh, &data->f_attr);\n\tret = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto err;\n\tret = -ENOMEM;\n\tstate = nfs4_get_open_state(inode, data->owner);\n\tif (state == NULL)\n\t\tgoto err_put_inode;\n\tif (data->o_res.delegation_type != 0) {\n\t\tint delegation_flags = 0;\n\n\t\trcu_read_lock();\n\t\tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n\t\tif (delegation)\n\t\t\tdelegation_flags = delegation->flags;\n\t\trcu_read_unlock();\n\t\tif ((delegation_flags & 1UL<<NFS_DELEGATION_NEED_RECLAIM) == 0)\n\t\t\tnfs_inode_set_delegation(state->inode,\n\t\t\t\t\tdata->owner->so_cred,\n\t\t\t\t\t&data->o_res);\n\t\telse\n\t\t\tnfs_inode_reclaim_delegation(state->inode,\n\t\t\t\t\tdata->owner->so_cred,\n\t\t\t\t\t&data->o_res);\n\t}\n\n\tupdate_open_stateid(state, &data->o_res.stateid, NULL,\n\t\t\tdata->o_arg.fmode);\n\tiput(inode);\nout:\n\treturn state;\nerr_put_inode:\n\tiput(inode);\nerr:\n\treturn ERR_PTR(ret);\n}\n\nstatic struct nfs_open_context *nfs4_state_find_open_context(struct nfs4_state *state)\n{\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_open_context *ctx;\n\n\tspin_lock(&state->inode->i_lock);\n\tlist_for_each_entry(ctx, &nfsi->open_files, list) {\n\t\tif (ctx->state != state)\n\t\t\tcontinue;\n\t\tget_nfs_open_context(ctx);\n\t\tspin_unlock(&state->inode->i_lock);\n\t\treturn ctx;\n\t}\n\tspin_unlock(&state->inode->i_lock);\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic struct nfs4_opendata *nfs4_open_recoverdata_alloc(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs4_opendata *opendata;\n\n\topendata = nfs4_opendata_alloc(&ctx->path, state->owner, 0, 0, NULL);\n\tif (opendata == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\topendata->state = state;\n\tatomic_inc(&state->count);\n\treturn opendata;\n}\n\nstatic int nfs4_open_recover_helper(struct nfs4_opendata *opendata, fmode_t fmode, struct nfs4_state **res)\n{\n\tstruct nfs4_state *newstate;\n\tint ret;\n\n\topendata->o_arg.open_flags = 0;\n\topendata->o_arg.fmode = fmode;\n\tmemset(&opendata->o_res, 0, sizeof(opendata->o_res));\n\tmemset(&opendata->c_res, 0, sizeof(opendata->c_res));\n\tnfs4_init_opendata_res(opendata);\n\tret = _nfs4_proc_open(opendata);\n\tif (ret != 0)\n\t\treturn ret; \n\tnewstate = nfs4_opendata_to_nfs4_state(opendata);\n\tif (IS_ERR(newstate))\n\t\treturn PTR_ERR(newstate);\n\tnfs4_close_state(&opendata->path, newstate, fmode);\n\t*res = newstate;\n\treturn 0;\n}\n\nstatic int nfs4_open_recover(struct nfs4_opendata *opendata, struct nfs4_state *state)\n{\n\tstruct nfs4_state *newstate;\n\tint ret;\n\n\t/* memory barrier prior to reading state->n_* */\n\tclear_bit(NFS_DELEGATED_STATE, &state->flags);\n\tsmp_rmb();\n\tif (state->n_rdwr != 0) {\n\t\tret = nfs4_open_recover_helper(opendata, FMODE_READ|FMODE_WRITE, &newstate);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tif (newstate != state)\n\t\t\treturn -ESTALE;\n\t}\n\tif (state->n_wronly != 0) {\n\t\tret = nfs4_open_recover_helper(opendata, FMODE_WRITE, &newstate);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tif (newstate != state)\n\t\t\treturn -ESTALE;\n\t}\n\tif (state->n_rdonly != 0) {\n\t\tret = nfs4_open_recover_helper(opendata, FMODE_READ, &newstate);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tif (newstate != state)\n\t\t\treturn -ESTALE;\n\t}\n\t/*\n\t * We may have performed cached opens for all three recoveries.\n\t * Check if we need to update the current stateid.\n\t */\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0 &&\n\t    memcmp(state->stateid.data, state->open_stateid.data, sizeof(state->stateid.data)) != 0) {\n\t\twrite_seqlock(&state->seqlock);\n\t\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0)\n\t\t\tmemcpy(state->stateid.data, state->open_stateid.data, sizeof(state->stateid.data));\n\t\twrite_sequnlock(&state->seqlock);\n\t}\n\treturn 0;\n}\n\n/*\n * OPEN_RECLAIM:\n * \treclaim state on the server after a reboot.\n */\nstatic int _nfs4_do_open_reclaim(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs_delegation *delegation;\n\tstruct nfs4_opendata *opendata;\n\tfmode_t delegation_type = 0;\n\tint status;\n\n\topendata = nfs4_open_recoverdata_alloc(ctx, state);\n\tif (IS_ERR(opendata))\n\t\treturn PTR_ERR(opendata);\n\topendata->o_arg.claim = NFS4_OPEN_CLAIM_PREVIOUS;\n\topendata->o_arg.fh = NFS_FH(state->inode);\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(state->inode)->delegation);\n\tif (delegation != NULL && test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags) != 0)\n\t\tdelegation_type = delegation->type;\n\trcu_read_unlock();\n\topendata->o_arg.u.delegation_type = delegation_type;\n\tstatus = nfs4_open_recover(opendata, state);\n\tnfs4_opendata_put(opendata);\n\treturn status;\n}\n\nstatic int nfs4_do_open_reclaim(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = _nfs4_do_open_reclaim(ctx, state);\n\t\tif (err != -NFS4ERR_DELAY)\n\t\t\tbreak;\n\t\tnfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int nfs4_open_reclaim(struct nfs4_state_owner *sp, struct nfs4_state *state)\n{\n\tstruct nfs_open_context *ctx;\n\tint ret;\n\n\tctx = nfs4_state_find_open_context(state);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\tret = nfs4_do_open_reclaim(ctx, state);\n\tput_nfs_open_context(ctx);\n\treturn ret;\n}\n\nstatic int _nfs4_open_delegation_recall(struct nfs_open_context *ctx, struct nfs4_state *state, const nfs4_stateid *stateid)\n{\n\tstruct nfs4_opendata *opendata;\n\tint ret;\n\n\topendata = nfs4_open_recoverdata_alloc(ctx, state);\n\tif (IS_ERR(opendata))\n\t\treturn PTR_ERR(opendata);\n\topendata->o_arg.claim = NFS4_OPEN_CLAIM_DELEGATE_CUR;\n\tmemcpy(opendata->o_arg.u.delegation.data, stateid->data,\n\t\t\tsizeof(opendata->o_arg.u.delegation.data));\n\tret = nfs4_open_recover(opendata, state);\n\tnfs4_opendata_put(opendata);\n\treturn ret;\n}\n\nint nfs4_open_delegation_recall(struct nfs_open_context *ctx, struct nfs4_state *state, const nfs4_stateid *stateid)\n{\n\tstruct nfs4_exception exception = { };\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tint err;\n\tdo {\n\t\terr = _nfs4_open_delegation_recall(ctx, state, stateid);\n\t\tswitch (err) {\n\t\t\tcase 0:\n\t\t\t\treturn err;\n\t\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tcase -NFS4ERR_STALE_STATEID:\n\t\t\tcase -NFS4ERR_EXPIRED:\n\t\t\t\t/* Don't recall a delegation if it was lost */\n\t\t\t\tnfs4_schedule_state_recovery(server->nfs_client);\n\t\t\t\treturn err;\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic void nfs4_open_confirm_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\n\tdata->rpc_status = task->tk_status;\n\tif (RPC_ASSASSINATED(task))\n\t\treturn;\n\tif (data->rpc_status == 0) {\n\t\tmemcpy(data->o_res.stateid.data, data->c_res.stateid.data,\n\t\t\t\tsizeof(data->o_res.stateid.data));\n\t\tnfs_confirm_seqid(&data->owner->so_seqid, 0);\n\t\trenew_lease(data->o_res.server, data->timestamp);\n\t\tdata->rpc_done = 1;\n\t}\n}\n\nstatic void nfs4_open_confirm_release(void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state *state = NULL;\n\n\t/* If this request hasn't been cancelled, do nothing */\n\tif (data->cancelled == 0)\n\t\tgoto out_free;\n\t/* In case of error, no cleanup! */\n\tif (!data->rpc_done)\n\t\tgoto out_free;\n\tstate = nfs4_opendata_to_nfs4_state(data);\n\tif (!IS_ERR(state))\n\t\tnfs4_close_state(&data->path, state, data->o_arg.fmode);\nout_free:\n\tnfs4_opendata_put(data);\n}\n\nstatic const struct rpc_call_ops nfs4_open_confirm_ops = {\n\t.rpc_call_done = nfs4_open_confirm_done,\n\t.rpc_release = nfs4_open_confirm_release,\n};\n\n/*\n * Note: On error, nfs4_proc_open_confirm will free the struct nfs4_opendata\n */\nstatic int _nfs4_proc_open_confirm(struct nfs4_opendata *data)\n{\n\tstruct nfs_server *server = NFS_SERVER(data->dir->d_inode);\n\tstruct rpc_task *task;\n\tstruct  rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_CONFIRM],\n\t\t.rpc_argp = &data->c_arg,\n\t\t.rpc_resp = &data->c_res,\n\t\t.rpc_cred = data->owner->so_cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_open_confirm_ops,\n\t\t.callback_data = data,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tint status;\n\n\tkref_get(&data->kref);\n\tdata->rpc_done = 0;\n\tdata->rpc_status = 0;\n\tdata->timestamp = jiffies;\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tstatus = nfs4_wait_for_completion_rpc_task(task);\n\tif (status != 0) {\n\t\tdata->cancelled = 1;\n\t\tsmp_wmb();\n\t} else\n\t\tstatus = data->rpc_status;\n\trpc_put_task(task);\n\treturn status;\n}\n\nstatic void nfs4_open_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state_owner *sp = data->owner;\n\n\tif (nfs_wait_on_sequence(data->o_arg.seqid, task) != 0)\n\t\treturn;\n\t/*\n\t * Check if we still need to send an OPEN call, or if we can use\n\t * a delegation instead.\n\t */\n\tif (data->state != NULL) {\n\t\tstruct nfs_delegation *delegation;\n\n\t\tif (can_open_cached(data->state, data->o_arg.fmode, data->o_arg.open_flags))\n\t\t\tgoto out_no_action;\n\t\trcu_read_lock();\n\t\tdelegation = rcu_dereference(NFS_I(data->state->inode)->delegation);\n\t\tif (delegation != NULL &&\n\t\t    test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags) == 0) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto out_no_action;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\t/* Update sequence id. */\n\tdata->o_arg.id = sp->so_owner_id.id;\n\tdata->o_arg.clientid = sp->so_client->cl_clientid;\n\tif (data->o_arg.claim == NFS4_OPEN_CLAIM_PREVIOUS) {\n\t\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_NOATTR];\n\t\tnfs_copy_fh(&data->o_res.fh, data->o_arg.fh);\n\t}\n\tdata->timestamp = jiffies;\n\trpc_call_start(task);\n\treturn;\nout_no_action:\n\ttask->tk_action = NULL;\n\n}\n\nstatic void nfs4_open_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\n\tdata->rpc_status = task->tk_status;\n\tif (RPC_ASSASSINATED(task))\n\t\treturn;\n\tif (task->tk_status == 0) {\n\t\tswitch (data->o_res.f_attr->mode & S_IFMT) {\n\t\t\tcase S_IFREG:\n\t\t\t\tbreak;\n\t\t\tcase S_IFLNK:\n\t\t\t\tdata->rpc_status = -ELOOP;\n\t\t\t\tbreak;\n\t\t\tcase S_IFDIR:\n\t\t\t\tdata->rpc_status = -EISDIR;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdata->rpc_status = -ENOTDIR;\n\t\t}\n\t\trenew_lease(data->o_res.server, data->timestamp);\n\t\tif (!(data->o_res.rflags & NFS4_OPEN_RESULT_CONFIRM))\n\t\t\tnfs_confirm_seqid(&data->owner->so_seqid, 0);\n\t}\n\tdata->rpc_done = 1;\n}\n\nstatic void nfs4_open_release(void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state *state = NULL;\n\n\t/* If this request hasn't been cancelled, do nothing */\n\tif (data->cancelled == 0)\n\t\tgoto out_free;\n\t/* In case of error, no cleanup! */\n\tif (data->rpc_status != 0 || !data->rpc_done)\n\t\tgoto out_free;\n\t/* In case we need an open_confirm, no cleanup! */\n\tif (data->o_res.rflags & NFS4_OPEN_RESULT_CONFIRM)\n\t\tgoto out_free;\n\tstate = nfs4_opendata_to_nfs4_state(data);\n\tif (!IS_ERR(state))\n\t\tnfs4_close_state(&data->path, state, data->o_arg.fmode);\nout_free:\n\tnfs4_opendata_put(data);\n}\n\nstatic const struct rpc_call_ops nfs4_open_ops = {\n\t.rpc_call_prepare = nfs4_open_prepare,\n\t.rpc_call_done = nfs4_open_done,\n\t.rpc_release = nfs4_open_release,\n};\n\n/*\n * Note: On error, nfs4_proc_open will free the struct nfs4_opendata\n */\nstatic int _nfs4_proc_open(struct nfs4_opendata *data)\n{\n\tstruct inode *dir = data->dir->d_inode;\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs_openargs *o_arg = &data->o_arg;\n\tstruct nfs_openres *o_res = &data->o_res;\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN],\n\t\t.rpc_argp = o_arg,\n\t\t.rpc_resp = o_res,\n\t\t.rpc_cred = data->owner->so_cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_open_ops,\n\t\t.callback_data = data,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tint status;\n\n\tkref_get(&data->kref);\n\tdata->rpc_done = 0;\n\tdata->rpc_status = 0;\n\tdata->cancelled = 0;\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tstatus = nfs4_wait_for_completion_rpc_task(task);\n\tif (status != 0) {\n\t\tdata->cancelled = 1;\n\t\tsmp_wmb();\n\t} else\n\t\tstatus = data->rpc_status;\n\trpc_put_task(task);\n\tif (status != 0 || !data->rpc_done)\n\t\treturn status;\n\n\tif (o_res->fh.size == 0)\n\t\t_nfs4_proc_lookup(dir, o_arg->name, &o_res->fh, o_res->f_attr);\n\n\tif (o_arg->open_flags & O_CREAT) {\n\t\tupdate_changeattr(dir, &o_res->cinfo);\n\t\tnfs_post_op_update_inode(dir, o_res->dir_attr);\n\t} else\n\t\tnfs_refresh_inode(dir, o_res->dir_attr);\n\tif(o_res->rflags & NFS4_OPEN_RESULT_CONFIRM) {\n\t\tstatus = _nfs4_proc_open_confirm(data);\n\t\tif (status != 0)\n\t\t\treturn status;\n\t}\n\tif (!(o_res->f_attr->valid & NFS_ATTR_FATTR))\n\t\t_nfs4_proc_getattr(server, &o_res->fh, o_res->f_attr);\n\treturn 0;\n}\n\nstatic int nfs4_recover_expired_lease(struct nfs_server *server)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tint ret;\n\n\tfor (;;) {\n\t\tret = nfs4_wait_clnt_recover(clp);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tif (!test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state) &&\n\t\t    !test_bit(NFS4CLNT_CHECK_LEASE,&clp->cl_state))\n\t\t\tbreak;\n\t\tnfs4_schedule_state_recovery(clp);\n\t}\n\treturn 0;\n}\n\n/*\n * OPEN_EXPIRED:\n * \treclaim state on the server after a network partition.\n * \tAssumes caller holds the appropriate lock\n */\nstatic int _nfs4_open_expired(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs4_opendata *opendata;\n\tint ret;\n\n\topendata = nfs4_open_recoverdata_alloc(ctx, state);\n\tif (IS_ERR(opendata))\n\t\treturn PTR_ERR(opendata);\n\tret = nfs4_open_recover(opendata, state);\n\tif (ret == -ESTALE)\n\t\td_drop(ctx->path.dentry);\n\tnfs4_opendata_put(opendata);\n\treturn ret;\n}\n\nstatic inline int nfs4_do_open_expired(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = _nfs4_open_expired(ctx, state);\n\t\tif (err == -NFS4ERR_DELAY)\n\t\t\tnfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int nfs4_open_expired(struct nfs4_state_owner *sp, struct nfs4_state *state)\n{\n\tstruct nfs_open_context *ctx;\n\tint ret;\n\n\tctx = nfs4_state_find_open_context(state);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\tret = nfs4_do_open_expired(ctx, state);\n\tput_nfs_open_context(ctx);\n\treturn ret;\n}\n\n/*\n * on an EXCLUSIVE create, the server should send back a bitmask with FATTR4-*\n * fields corresponding to attributes that were used to store the verifier.\n * Make sure we clobber those fields in the later setattr call\n */\nstatic inline void nfs4_exclusive_attrset(struct nfs4_opendata *opendata, struct iattr *sattr)\n{\n\tif ((opendata->o_res.attrset[1] & FATTR4_WORD1_TIME_ACCESS) &&\n\t    !(sattr->ia_valid & ATTR_ATIME_SET))\n\t\tsattr->ia_valid |= ATTR_ATIME;\n\n\tif ((opendata->o_res.attrset[1] & FATTR4_WORD1_TIME_MODIFY) &&\n\t    !(sattr->ia_valid & ATTR_MTIME_SET))\n\t\tsattr->ia_valid |= ATTR_MTIME;\n}\n\n/*\n * Returns a referenced nfs4_state\n */\nstatic int _nfs4_do_open(struct inode *dir, struct path *path, fmode_t fmode, int flags, struct iattr *sattr, struct rpc_cred *cred, struct nfs4_state **res)\n{\n\tstruct nfs4_state_owner  *sp;\n\tstruct nfs4_state     *state = NULL;\n\tstruct nfs_server       *server = NFS_SERVER(dir);\n\tstruct nfs4_opendata *opendata;\n\tint status;\n\n\t/* Protect against reboot recovery conflicts */\n\tstatus = -ENOMEM;\n\tif (!(sp = nfs4_get_state_owner(server, cred))) {\n\t\tdprintk(\"nfs4_do_open: nfs4_get_state_owner failed!\\n\");\n\t\tgoto out_err;\n\t}\n\tstatus = nfs4_recover_expired_lease(server);\n\tif (status != 0)\n\t\tgoto err_put_state_owner;\n\tif (path->dentry->d_inode != NULL)\n\t\tnfs4_return_incompatible_delegation(path->dentry->d_inode, fmode);\n\tstatus = -ENOMEM;\n\topendata = nfs4_opendata_alloc(path, sp, fmode, flags, sattr);\n\tif (opendata == NULL)\n\t\tgoto err_put_state_owner;\n\n\tif (path->dentry->d_inode != NULL)\n\t\topendata->state = nfs4_get_open_state(path->dentry->d_inode, sp);\n\n\tstatus = _nfs4_proc_open(opendata);\n\tif (status != 0)\n\t\tgoto err_opendata_put;\n\n\tif (opendata->o_arg.open_flags & O_EXCL)\n\t\tnfs4_exclusive_attrset(opendata, sattr);\n\n\tstate = nfs4_opendata_to_nfs4_state(opendata);\n\tstatus = PTR_ERR(state);\n\tif (IS_ERR(state))\n\t\tgoto err_opendata_put;\n\tnfs4_opendata_put(opendata);\n\tnfs4_put_state_owner(sp);\n\t*res = state;\n\treturn 0;\nerr_opendata_put:\n\tnfs4_opendata_put(opendata);\nerr_put_state_owner:\n\tnfs4_put_state_owner(sp);\nout_err:\n\t*res = NULL;\n\treturn status;\n}\n\n\nstatic struct nfs4_state *nfs4_do_open(struct inode *dir, struct path *path, fmode_t fmode, int flags, struct iattr *sattr, struct rpc_cred *cred)\n{\n\tstruct nfs4_exception exception = { };\n\tstruct nfs4_state *res;\n\tint status;\n\n\tdo {\n\t\tstatus = _nfs4_do_open(dir, path, fmode, flags, sattr, cred, &res);\n\t\tif (status == 0)\n\t\t\tbreak;\n\t\t/* NOTE: BAD_SEQID means the server and client disagree about the\n\t\t * book-keeping w.r.t. state-changing operations\n\t\t * (OPEN/CLOSE/LOCK/LOCKU...)\n\t\t * It is actually a sign of a bug on the client or on the server.\n\t\t *\n\t\t * If we receive a BAD_SEQID error in the particular case of\n\t\t * doing an OPEN, we assume that nfs_increment_open_seqid() will\n\t\t * have unhashed the old state_owner for us, and that we can\n\t\t * therefore safely retry using a new one. We should still warn\n\t\t * the user though...\n\t\t */\n\t\tif (status == -NFS4ERR_BAD_SEQID) {\n\t\t\tprintk(KERN_WARNING \"NFS: v4 server %s \"\n\t\t\t\t\t\" returned a bad sequence-id error!\\n\",\n\t\t\t\t\tNFS_SERVER(dir)->nfs_client->cl_hostname);\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * BAD_STATEID on OPEN means that the server cancelled our\n\t\t * state before it received the OPEN_CONFIRM.\n\t\t * Recover by retrying the request as per the discussion\n\t\t * on Page 181 of RFC3530.\n\t\t */\n\t\tif (status == -NFS4ERR_BAD_STATEID) {\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -EAGAIN) {\n\t\t\t/* We must have found a delegation */\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tres = ERR_PTR(nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t\tstatus, &exception));\n\t} while (exception.retry);\n\treturn res;\n}\n\nstatic int _nfs4_do_setattr(struct inode *inode, struct rpc_cred *cred,\n\t\t\t    struct nfs_fattr *fattr, struct iattr *sattr,\n\t\t\t    struct nfs4_state *state)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n        struct nfs_setattrargs  arg = {\n                .fh             = NFS_FH(inode),\n                .iap            = sattr,\n\t\t.server\t\t= server,\n\t\t.bitmask = server->attr_bitmask,\n        };\n        struct nfs_setattrres  res = {\n\t\t.fattr\t\t= fattr,\n\t\t.server\t\t= server,\n        };\n        struct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_SETATTR],\n\t\t.rpc_argp\t= &arg,\n\t\t.rpc_resp\t= &res,\n\t\t.rpc_cred\t= cred,\n        };\n\tunsigned long timestamp = jiffies;\n\tint status;\n\n\tnfs_fattr_init(fattr);\n\n\tif (nfs4_copy_delegation_stateid(&arg.stateid, inode)) {\n\t\t/* Use that stateid */\n\t} else if (state != NULL) {\n\t\tnfs4_copy_stateid(&arg.stateid, state, current->files);\n\t} else\n\t\tmemcpy(&arg.stateid, &zero_stateid, sizeof(arg.stateid));\n\n\tstatus = rpc_call_sync(server->client, &msg, 0);\n\tif (status == 0 && state != NULL)\n\t\trenew_lease(server, timestamp);\n\treturn status;\n}\n\nstatic int nfs4_do_setattr(struct inode *inode, struct rpc_cred *cred,\n\t\t\t   struct nfs_fattr *fattr, struct iattr *sattr,\n\t\t\t   struct nfs4_state *state)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs4_do_setattr(inode, cred, fattr, sattr, state),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstruct nfs4_closedata {\n\tstruct path path;\n\tstruct inode *inode;\n\tstruct nfs4_state *state;\n\tstruct nfs_closeargs arg;\n\tstruct nfs_closeres res;\n\tstruct nfs_fattr fattr;\n\tunsigned long timestamp;\n};\n\nstatic void nfs4_free_closedata(void *data)\n{\n\tstruct nfs4_closedata *calldata = data;\n\tstruct nfs4_state_owner *sp = calldata->state->owner;\n\n\tnfs4_put_open_state(calldata->state);\n\tnfs_free_seqid(calldata->arg.seqid);\n\tnfs4_put_state_owner(sp);\n\tpath_put(&calldata->path);\n\tkfree(calldata);\n}\n\nstatic void nfs4_close_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_closedata *calldata = data;\n\tstruct nfs4_state *state = calldata->state;\n\tstruct nfs_server *server = NFS_SERVER(calldata->inode);\n\n\tif (RPC_ASSASSINATED(task))\n\t\treturn;\n        /* hmm. we are done with the inode, and in the process of freeing\n\t * the state_owner. we keep this around to process errors\n\t */\n\tswitch (task->tk_status) {\n\t\tcase 0:\n\t\t\tnfs_set_open_stateid(state, &calldata->res.stateid, 0);\n\t\t\trenew_lease(server, calldata->timestamp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_OLD_STATEID:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tif (calldata->arg.fmode == 0)\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (nfs4_async_handle_error(task, server, state) == -EAGAIN) {\n\t\t\t\trpc_restart_call(task);\n\t\t\t\treturn;\n\t\t\t}\n\t}\n\tnfs_refresh_inode(calldata->inode, calldata->res.fattr);\n}\n\nstatic void nfs4_close_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_closedata *calldata = data;\n\tstruct nfs4_state *state = calldata->state;\n\tint clear_rd, clear_wr, clear_rdwr;\n\n\tif (nfs_wait_on_sequence(calldata->arg.seqid, task) != 0)\n\t\treturn;\n\n\tclear_rd = clear_wr = clear_rdwr = 0;\n\tspin_lock(&state->owner->so_lock);\n\t/* Calculate the change in open mode */\n\tif (state->n_rdwr == 0) {\n\t\tif (state->n_rdonly == 0) {\n\t\t\tclear_rd |= test_and_clear_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tclear_rdwr |= test_and_clear_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (state->n_wronly == 0) {\n\t\t\tclear_wr |= test_and_clear_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tclear_rdwr |= test_and_clear_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t}\n\tspin_unlock(&state->owner->so_lock);\n\tif (!clear_rd && !clear_wr && !clear_rdwr) {\n\t\t/* Note: exit _without_ calling nfs4_close_done */\n\t\ttask->tk_action = NULL;\n\t\treturn;\n\t}\n\tnfs_fattr_init(calldata->res.fattr);\n\tif (test_bit(NFS_O_RDONLY_STATE, &state->flags) != 0) {\n\t\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_DOWNGRADE];\n\t\tcalldata->arg.fmode = FMODE_READ;\n\t} else if (test_bit(NFS_O_WRONLY_STATE, &state->flags) != 0) {\n\t\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_DOWNGRADE];\n\t\tcalldata->arg.fmode = FMODE_WRITE;\n\t}\n\tcalldata->timestamp = jiffies;\n\trpc_call_start(task);\n}\n\nstatic const struct rpc_call_ops nfs4_close_ops = {\n\t.rpc_call_prepare = nfs4_close_prepare,\n\t.rpc_call_done = nfs4_close_done,\n\t.rpc_release = nfs4_free_closedata,\n};\n\n/* \n * It is possible for data to be read/written from a mem-mapped file \n * after the sys_close call (which hits the vfs layer as a flush).\n * This means that we can't safely call nfsv4 close on a file until \n * the inode is cleared. This in turn means that we are not good\n * NFSv4 citizens - we do not indicate to the server to update the file's \n * share state even when we are done with one of the three share \n * stateid's in the inode.\n *\n * NOTE: Caller must be holding the sp->so_owner semaphore!\n */\nint nfs4_do_close(struct path *path, struct nfs4_state *state, int wait)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_closedata *calldata;\n\tstruct nfs4_state_owner *sp = state->owner;\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_CLOSE],\n\t\t.rpc_cred = state->owner->so_cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_close_ops,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tint status = -ENOMEM;\n\n\tcalldata = kmalloc(sizeof(*calldata), GFP_KERNEL);\n\tif (calldata == NULL)\n\t\tgoto out;\n\tcalldata->inode = state->inode;\n\tcalldata->state = state;\n\tcalldata->arg.fh = NFS_FH(state->inode);\n\tcalldata->arg.stateid = &state->open_stateid;\n\t/* Serialization for the sequence id */\n\tcalldata->arg.seqid = nfs_alloc_seqid(&state->owner->so_seqid);\n\tif (calldata->arg.seqid == NULL)\n\t\tgoto out_free_calldata;\n\tcalldata->arg.fmode = 0;\n\tcalldata->arg.bitmask = server->attr_bitmask;\n\tcalldata->res.fattr = &calldata->fattr;\n\tcalldata->res.seqid = calldata->arg.seqid;\n\tcalldata->res.server = server;\n\tcalldata->path.mnt = mntget(path->mnt);\n\tcalldata->path.dentry = dget(path->dentry);\n\n\tmsg.rpc_argp = &calldata->arg,\n\tmsg.rpc_resp = &calldata->res,\n\ttask_setup_data.callback_data = calldata;\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tstatus = 0;\n\tif (wait)\n\t\tstatus = rpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn status;\nout_free_calldata:\n\tkfree(calldata);\nout:\n\tnfs4_put_open_state(state);\n\tnfs4_put_state_owner(sp);\n\treturn status;\n}\n\nstatic int nfs4_intent_set_file(struct nameidata *nd, struct path *path, struct nfs4_state *state, fmode_t fmode)\n{\n\tstruct file *filp;\n\tint ret;\n\n\t/* If the open_intent is for execute, we have an extra check to make */\n\tif (fmode & FMODE_EXEC) {\n\t\tret = nfs_may_open(state->inode,\n\t\t\t\tstate->owner->so_cred,\n\t\t\t\tnd->intent.open.flags);\n\t\tif (ret < 0)\n\t\t\tgoto out_close;\n\t}\n\tfilp = lookup_instantiate_filp(nd, path->dentry, NULL);\n\tif (!IS_ERR(filp)) {\n\t\tstruct nfs_open_context *ctx;\n\t\tctx = nfs_file_open_context(filp);\n\t\tctx->state = state;\n\t\treturn 0;\n\t}\n\tret = PTR_ERR(filp);\nout_close:\n\tnfs4_close_sync(path, state, fmode & (FMODE_READ|FMODE_WRITE));\n\treturn ret;\n}\n\nstruct dentry *\nnfs4_atomic_open(struct inode *dir, struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct path path = {\n\t\t.mnt = nd->path.mnt,\n\t\t.dentry = dentry,\n\t};\n\tstruct dentry *parent;\n\tstruct iattr attr;\n\tstruct rpc_cred *cred;\n\tstruct nfs4_state *state;\n\tstruct dentry *res;\n\tfmode_t fmode = nd->intent.open.flags & (FMODE_READ | FMODE_WRITE | FMODE_EXEC);\n\n\tif (nd->flags & LOOKUP_CREATE) {\n\t\tattr.ia_mode = nd->intent.open.create_mode;\n\t\tattr.ia_valid = ATTR_MODE;\n\t\tif (!IS_POSIXACL(dir))\n\t\t\tattr.ia_mode &= ~current->fs->umask;\n\t} else {\n\t\tattr.ia_valid = 0;\n\t\tBUG_ON(nd->intent.open.flags & O_CREAT);\n\t}\n\n\tcred = rpc_lookup_cred();\n\tif (IS_ERR(cred))\n\t\treturn (struct dentry *)cred;\n\tparent = dentry->d_parent;\n\t/* Protect against concurrent sillydeletes */\n\tnfs_block_sillyrename(parent);\n\tstate = nfs4_do_open(dir, &path, fmode, nd->intent.open.flags, &attr, cred);\n\tput_rpccred(cred);\n\tif (IS_ERR(state)) {\n\t\tif (PTR_ERR(state) == -ENOENT) {\n\t\t\td_add(dentry, NULL);\n\t\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\t}\n\t\tnfs_unblock_sillyrename(parent);\n\t\treturn (struct dentry *)state;\n\t}\n\tres = d_add_unique(dentry, igrab(state->inode));\n\tif (res != NULL)\n\t\tpath.dentry = res;\n\tnfs_set_verifier(path.dentry, nfs_save_change_attribute(dir));\n\tnfs_unblock_sillyrename(parent);\n\tnfs4_intent_set_file(nd, &path, state, fmode);\n\treturn res;\n}\n\nint\nnfs4_open_revalidate(struct inode *dir, struct dentry *dentry, int openflags, struct nameidata *nd)\n{\n\tstruct path path = {\n\t\t.mnt = nd->path.mnt,\n\t\t.dentry = dentry,\n\t};\n\tstruct rpc_cred *cred;\n\tstruct nfs4_state *state;\n\tfmode_t fmode = openflags & (FMODE_READ | FMODE_WRITE);\n\n\tcred = rpc_lookup_cred();\n\tif (IS_ERR(cred))\n\t\treturn PTR_ERR(cred);\n\tstate = nfs4_do_open(dir, &path, fmode, openflags, NULL, cred);\n\tput_rpccred(cred);\n\tif (IS_ERR(state)) {\n\t\tswitch (PTR_ERR(state)) {\n\t\t\tcase -EPERM:\n\t\t\tcase -EACCES:\n\t\t\tcase -EDQUOT:\n\t\t\tcase -ENOSPC:\n\t\t\tcase -EROFS:\n\t\t\t\tlookup_instantiate_filp(nd, (struct dentry *)state, NULL);\n\t\t\t\treturn 1;\n\t\t\tdefault:\n\t\t\t\tgoto out_drop;\n\t\t}\n\t}\n\tif (state->inode == dentry->d_inode) {\n\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\tnfs4_intent_set_file(nd, &path, state, fmode);\n\t\treturn 1;\n\t}\n\tnfs4_close_sync(&path, state, fmode);\nout_drop:\n\td_drop(dentry);\n\treturn 0;\n}\n\n\nstatic int _nfs4_server_capabilities(struct nfs_server *server, struct nfs_fh *fhandle)\n{\n\tstruct nfs4_server_caps_res res = {};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SERVER_CAPS],\n\t\t.rpc_argp = fhandle,\n\t\t.rpc_resp = &res,\n\t};\n\tint status;\n\n\tstatus = rpc_call_sync(server->client, &msg, 0);\n\tif (status == 0) {\n\t\tmemcpy(server->attr_bitmask, res.attr_bitmask, sizeof(server->attr_bitmask));\n\t\tif (res.attr_bitmask[0] & FATTR4_WORD0_ACL)\n\t\t\tserver->caps |= NFS_CAP_ACLS;\n\t\tif (res.has_links != 0)\n\t\t\tserver->caps |= NFS_CAP_HARDLINKS;\n\t\tif (res.has_symlinks != 0)\n\t\t\tserver->caps |= NFS_CAP_SYMLINKS;\n\t\tserver->acl_bitmask = res.acl_bitmask;\n\t}\n\treturn status;\n}\n\nint nfs4_server_capabilities(struct nfs_server *server, struct nfs_fh *fhandle)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs4_server_capabilities(server, fhandle),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_lookup_root(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\tstruct nfs_fsinfo *info)\n{\n\tstruct nfs4_lookup_root_arg args = {\n\t\t.bitmask = nfs4_fattr_bitmap,\n\t};\n\tstruct nfs4_lookup_res res = {\n\t\t.server = server,\n\t\t.fattr = info->fattr,\n\t\t.fh = fhandle,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LOOKUP_ROOT],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tnfs_fattr_init(info->fattr);\n\treturn rpc_call_sync(server->client, &msg, 0);\n}\n\nstatic int nfs4_lookup_root(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\tstruct nfs_fsinfo *info)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs4_lookup_root(server, fhandle, info),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n/*\n * get the file handle for the \"/\" directory on the server\n */\nstatic int nfs4_proc_get_root(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t\t      struct nfs_fsinfo *info)\n{\n\tint status;\n\n\tstatus = nfs4_lookup_root(server, fhandle, info);\n\tif (status == 0)\n\t\tstatus = nfs4_server_capabilities(server, fhandle);\n\tif (status == 0)\n\t\tstatus = nfs4_do_fsinfo(server, fhandle, info);\n\treturn nfs4_map_errors(status);\n}\n\n/*\n * Get locations and (maybe) other attributes of a referral.\n * Note that we'll actually follow the referral later when\n * we detect fsid mismatch in inode revalidation\n */\nstatic int nfs4_get_referral(struct inode *dir, const struct qstr *name, struct nfs_fattr *fattr, struct nfs_fh *fhandle)\n{\n\tint status = -ENOMEM;\n\tstruct page *page = NULL;\n\tstruct nfs4_fs_locations *locations = NULL;\n\n\tpage = alloc_page(GFP_KERNEL);\n\tif (page == NULL)\n\t\tgoto out;\n\tlocations = kmalloc(sizeof(struct nfs4_fs_locations), GFP_KERNEL);\n\tif (locations == NULL)\n\t\tgoto out;\n\n\tstatus = nfs4_proc_fs_locations(dir, name, locations, page);\n\tif (status != 0)\n\t\tgoto out;\n\t/* Make sure server returned a different fsid for the referral */\n\tif (nfs_fsid_equal(&NFS_SERVER(dir)->fsid, &locations->fattr.fsid)) {\n\t\tdprintk(\"%s: server did not return a different fsid for a referral at %s\\n\", __func__, name->name);\n\t\tstatus = -EIO;\n\t\tgoto out;\n\t}\n\n\tmemcpy(fattr, &locations->fattr, sizeof(struct nfs_fattr));\n\tfattr->valid |= NFS_ATTR_FATTR_V4_REFERRAL;\n\tif (!fattr->mode)\n\t\tfattr->mode = S_IFDIR;\n\tmemset(fhandle, 0, sizeof(struct nfs_fh));\nout:\n\tif (page)\n\t\t__free_page(page);\n\tif (locations)\n\t\tkfree(locations);\n\treturn status;\n}\n\nstatic int _nfs4_proc_getattr(struct nfs_server *server, struct nfs_fh *fhandle, struct nfs_fattr *fattr)\n{\n\tstruct nfs4_getattr_arg args = {\n\t\t.fh = fhandle,\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct nfs4_getattr_res res = {\n\t\t.fattr = fattr,\n\t\t.server = server,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETATTR],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\t\n\tnfs_fattr_init(fattr);\n\treturn rpc_call_sync(server->client, &msg, 0);\n}\n\nstatic int nfs4_proc_getattr(struct nfs_server *server, struct nfs_fh *fhandle, struct nfs_fattr *fattr)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs4_proc_getattr(server, fhandle, fattr),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n/* \n * The file is not closed if it is opened due to the a request to change\n * the size of the file. The open call will not be needed once the\n * VFS layer lookup-intents are implemented.\n *\n * Close is called when the inode is destroyed.\n * If we haven't opened the file for O_WRONLY, we\n * need to in the size_change case to obtain a stateid.\n *\n * Got race?\n * Because OPEN is always done by name in nfsv4, it is\n * possible that we opened a different file by the same\n * name.  We can recognize this race condition, but we\n * can't do anything about it besides returning an error.\n *\n * This will be fixed with VFS changes (lookup-intent).\n */\nstatic int\nnfs4_proc_setattr(struct dentry *dentry, struct nfs_fattr *fattr,\n\t\t  struct iattr *sattr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct rpc_cred *cred = NULL;\n\tstruct nfs4_state *state = NULL;\n\tint status;\n\n\tnfs_fattr_init(fattr);\n\t\n\t/* Search for an existing open(O_WRITE) file */\n\tif (sattr->ia_valid & ATTR_FILE) {\n\t\tstruct nfs_open_context *ctx;\n\n\t\tctx = nfs_file_open_context(sattr->ia_file);\n\t\tif (ctx) {\n\t\t\tcred = ctx->cred;\n\t\t\tstate = ctx->state;\n\t\t}\n\t}\n\n\tstatus = nfs4_do_setattr(inode, cred, fattr, sattr, state);\n\tif (status == 0)\n\t\tnfs_setattr_update_inode(inode, sattr);\n\treturn status;\n}\n\nstatic int _nfs4_proc_lookupfh(struct nfs_server *server, const struct nfs_fh *dirfh,\n\t\tconst struct qstr *name, struct nfs_fh *fhandle,\n\t\tstruct nfs_fattr *fattr)\n{\n\tint\t\t       status;\n\tstruct nfs4_lookup_arg args = {\n\t\t.bitmask = server->attr_bitmask,\n\t\t.dir_fh = dirfh,\n\t\t.name = name,\n\t};\n\tstruct nfs4_lookup_res res = {\n\t\t.server = server,\n\t\t.fattr = fattr,\n\t\t.fh = fhandle,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LOOKUP],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\n\tnfs_fattr_init(fattr);\n\n\tdprintk(\"NFS call  lookupfh %s\\n\", name->name);\n\tstatus = rpc_call_sync(server->client, &msg, 0);\n\tdprintk(\"NFS reply lookupfh: %d\\n\", status);\n\treturn status;\n}\n\nstatic int nfs4_proc_lookupfh(struct nfs_server *server, struct nfs_fh *dirfh,\n\t\t\t      struct qstr *name, struct nfs_fh *fhandle,\n\t\t\t      struct nfs_fattr *fattr)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = _nfs4_proc_lookupfh(server, dirfh, name, fhandle, fattr);\n\t\t/* FIXME: !!!! */\n\t\tif (err == -NFS4ERR_MOVED) {\n\t\t\terr = -EREMOTE;\n\t\t\tbreak;\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_proc_lookup(struct inode *dir, const struct qstr *name,\n\t\tstruct nfs_fh *fhandle, struct nfs_fattr *fattr)\n{\n\tint status;\n\t\n\tdprintk(\"NFS call  lookup %s\\n\", name->name);\n\tstatus = _nfs4_proc_lookupfh(NFS_SERVER(dir), NFS_FH(dir), name, fhandle, fattr);\n\tif (status == -NFS4ERR_MOVED)\n\t\tstatus = nfs4_get_referral(dir, name, fattr, fhandle);\n\tdprintk(\"NFS reply lookup: %d\\n\", status);\n\treturn status;\n}\n\nstatic int nfs4_proc_lookup(struct inode *dir, struct qstr *name, struct nfs_fh *fhandle, struct nfs_fattr *fattr)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t_nfs4_proc_lookup(dir, name, fhandle, fattr),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_proc_access(struct inode *inode, struct nfs_access_entry *entry)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_fattr fattr;\n\tstruct nfs4_accessargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct nfs4_accessres res = {\n\t\t.server = server,\n\t\t.fattr = &fattr,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_ACCESS],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = entry->cred,\n\t};\n\tint mode = entry->mask;\n\tint status;\n\n\t/*\n\t * Determine which access bits we want to ask for...\n\t */\n\tif (mode & MAY_READ)\n\t\targs.access |= NFS4_ACCESS_READ;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tif (mode & MAY_WRITE)\n\t\t\targs.access |= NFS4_ACCESS_MODIFY | NFS4_ACCESS_EXTEND | NFS4_ACCESS_DELETE;\n\t\tif (mode & MAY_EXEC)\n\t\t\targs.access |= NFS4_ACCESS_LOOKUP;\n\t} else {\n\t\tif (mode & MAY_WRITE)\n\t\t\targs.access |= NFS4_ACCESS_MODIFY | NFS4_ACCESS_EXTEND;\n\t\tif (mode & MAY_EXEC)\n\t\t\targs.access |= NFS4_ACCESS_EXECUTE;\n\t}\n\tnfs_fattr_init(&fattr);\n\tstatus = rpc_call_sync(NFS_CLIENT(inode), &msg, 0);\n\tif (!status) {\n\t\tentry->mask = 0;\n\t\tif (res.access & NFS4_ACCESS_READ)\n\t\t\tentry->mask |= MAY_READ;\n\t\tif (res.access & (NFS4_ACCESS_MODIFY | NFS4_ACCESS_EXTEND | NFS4_ACCESS_DELETE))\n\t\t\tentry->mask |= MAY_WRITE;\n\t\tif (res.access & (NFS4_ACCESS_LOOKUP|NFS4_ACCESS_EXECUTE))\n\t\t\tentry->mask |= MAY_EXEC;\n\t\tnfs_refresh_inode(inode, &fattr);\n\t}\n\treturn status;\n}\n\nstatic int nfs4_proc_access(struct inode *inode, struct nfs_access_entry *entry)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(inode),\n\t\t\t\t_nfs4_proc_access(inode, entry),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n/*\n * TODO: For the time being, we don't try to get any attributes\n * along with any of the zero-copy operations READ, READDIR,\n * READLINK, WRITE.\n *\n * In the case of the first three, we want to put the GETATTR\n * after the read-type operation -- this is because it is hard\n * to predict the length of a GETATTR response in v4, and thus\n * align the READ data correctly.  This means that the GETATTR\n * may end up partially falling into the page cache, and we should\n * shift it into the 'tail' of the xdr_buf before processing.\n * To do this efficiently, we need to know the total length\n * of data received, which doesn't seem to be available outside\n * of the RPC layer.\n *\n * In the case of WRITE, we also want to put the GETATTR after\n * the operation -- in this case because we want to make sure\n * we get the post-operation mtime and size.  This means that\n * we can't use xdr_encode_pages() as written: we need a variant\n * of it which would leave room in the 'tail' iovec.\n *\n * Both of these changes to the XDR layer would in fact be quite\n * minor, but I decided to leave them for a subsequent patch.\n */\nstatic int _nfs4_proc_readlink(struct inode *inode, struct page *page,\n\t\tunsigned int pgbase, unsigned int pglen)\n{\n\tstruct nfs4_readlink args = {\n\t\t.fh       = NFS_FH(inode),\n\t\t.pgbase\t  = pgbase,\n\t\t.pglen    = pglen,\n\t\t.pages    = &page,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_READLINK],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = NULL,\n\t};\n\n\treturn rpc_call_sync(NFS_CLIENT(inode), &msg, 0);\n}\n\nstatic int nfs4_proc_readlink(struct inode *inode, struct page *page,\n\t\tunsigned int pgbase, unsigned int pglen)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(inode),\n\t\t\t\t_nfs4_proc_readlink(inode, page, pgbase, pglen),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n/*\n * Got race?\n * We will need to arrange for the VFS layer to provide an atomic open.\n * Until then, this create/open method is prone to inefficiency and race\n * conditions due to the lookup, create, and open VFS calls from sys_open()\n * placed on the wire.\n *\n * Given the above sorry state of affairs, I'm simply sending an OPEN.\n * The file will be opened again in the subsequent VFS open call\n * (nfs4_proc_file_open).\n *\n * The open for read will just hang around to be used by any process that\n * opens the file O_RDONLY. This will all be resolved with the VFS changes.\n */\n\nstatic int\nnfs4_proc_create(struct inode *dir, struct dentry *dentry, struct iattr *sattr,\n                 int flags, struct nameidata *nd)\n{\n\tstruct path path = {\n\t\t.mnt = nd->path.mnt,\n\t\t.dentry = dentry,\n\t};\n\tstruct nfs4_state *state;\n\tstruct rpc_cred *cred;\n\tfmode_t fmode = flags & (FMODE_READ | FMODE_WRITE);\n\tint status = 0;\n\n\tcred = rpc_lookup_cred();\n\tif (IS_ERR(cred)) {\n\t\tstatus = PTR_ERR(cred);\n\t\tgoto out;\n\t}\n\tstate = nfs4_do_open(dir, &path, fmode, flags, sattr, cred);\n\td_drop(dentry);\n\tif (IS_ERR(state)) {\n\t\tstatus = PTR_ERR(state);\n\t\tgoto out_putcred;\n\t}\n\td_add(dentry, igrab(state->inode));\n\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\tif (flags & O_EXCL) {\n\t\tstruct nfs_fattr fattr;\n\t\tstatus = nfs4_do_setattr(state->inode, cred, &fattr, sattr, state);\n\t\tif (status == 0)\n\t\t\tnfs_setattr_update_inode(state->inode, sattr);\n\t\tnfs_post_op_update_inode(state->inode, &fattr);\n\t}\n\tif (status == 0 && (nd->flags & LOOKUP_OPEN) != 0)\n\t\tstatus = nfs4_intent_set_file(nd, &path, state, fmode);\n\telse\n\t\tnfs4_close_sync(&path, state, fmode);\nout_putcred:\n\tput_rpccred(cred);\nout:\n\treturn status;\n}\n\nstatic int _nfs4_proc_remove(struct inode *dir, struct qstr *name)\n{\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs_removeargs args = {\n\t\t.fh = NFS_FH(dir),\n\t\t.name.len = name->len,\n\t\t.name.name = name->name,\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct nfs_removeres res = {\n\t\t.server = server,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_REMOVE],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tint\t\t\tstatus;\n\n\tnfs_fattr_init(&res.dir_attr);\n\tstatus = rpc_call_sync(server->client, &msg, 0);\n\tif (status == 0) {\n\t\tupdate_changeattr(dir, &res.cinfo);\n\t\tnfs_post_op_update_inode(dir, &res.dir_attr);\n\t}\n\treturn status;\n}\n\nstatic int nfs4_proc_remove(struct inode *dir, struct qstr *name)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t_nfs4_proc_remove(dir, name),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic void nfs4_proc_unlink_setup(struct rpc_message *msg, struct inode *dir)\n{\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs_removeargs *args = msg->rpc_argp;\n\tstruct nfs_removeres *res = msg->rpc_resp;\n\n\targs->bitmask = server->attr_bitmask;\n\tres->server = server;\n\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_REMOVE];\n}\n\nstatic int nfs4_proc_unlink_done(struct rpc_task *task, struct inode *dir)\n{\n\tstruct nfs_removeres *res = task->tk_msg.rpc_resp;\n\n\tif (nfs4_async_handle_error(task, res->server, NULL) == -EAGAIN)\n\t\treturn 0;\n\tupdate_changeattr(dir, &res->cinfo);\n\tnfs_post_op_update_inode(dir, &res->dir_attr);\n\treturn 1;\n}\n\nstatic int _nfs4_proc_rename(struct inode *old_dir, struct qstr *old_name,\n\t\tstruct inode *new_dir, struct qstr *new_name)\n{\n\tstruct nfs_server *server = NFS_SERVER(old_dir);\n\tstruct nfs4_rename_arg arg = {\n\t\t.old_dir = NFS_FH(old_dir),\n\t\t.new_dir = NFS_FH(new_dir),\n\t\t.old_name = old_name,\n\t\t.new_name = new_name,\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct nfs_fattr old_fattr, new_fattr;\n\tstruct nfs4_rename_res res = {\n\t\t.server = server,\n\t\t.old_fattr = &old_fattr,\n\t\t.new_fattr = &new_fattr,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_RENAME],\n\t\t.rpc_argp = &arg,\n\t\t.rpc_resp = &res,\n\t};\n\tint\t\t\tstatus;\n\t\n\tnfs_fattr_init(res.old_fattr);\n\tnfs_fattr_init(res.new_fattr);\n\tstatus = rpc_call_sync(server->client, &msg, 0);\n\n\tif (!status) {\n\t\tupdate_changeattr(old_dir, &res.old_cinfo);\n\t\tnfs_post_op_update_inode(old_dir, res.old_fattr);\n\t\tupdate_changeattr(new_dir, &res.new_cinfo);\n\t\tnfs_post_op_update_inode(new_dir, res.new_fattr);\n\t}\n\treturn status;\n}\n\nstatic int nfs4_proc_rename(struct inode *old_dir, struct qstr *old_name,\n\t\tstruct inode *new_dir, struct qstr *new_name)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(old_dir),\n\t\t\t\t_nfs4_proc_rename(old_dir, old_name,\n\t\t\t\t\tnew_dir, new_name),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_proc_link(struct inode *inode, struct inode *dir, struct qstr *name)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs4_link_arg arg = {\n\t\t.fh     = NFS_FH(inode),\n\t\t.dir_fh = NFS_FH(dir),\n\t\t.name   = name,\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct nfs_fattr fattr, dir_attr;\n\tstruct nfs4_link_res res = {\n\t\t.server = server,\n\t\t.fattr = &fattr,\n\t\t.dir_attr = &dir_attr,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LINK],\n\t\t.rpc_argp = &arg,\n\t\t.rpc_resp = &res,\n\t};\n\tint\t\t\tstatus;\n\n\tnfs_fattr_init(res.fattr);\n\tnfs_fattr_init(res.dir_attr);\n\tstatus = rpc_call_sync(server->client, &msg, 0);\n\tif (!status) {\n\t\tupdate_changeattr(dir, &res.cinfo);\n\t\tnfs_post_op_update_inode(dir, res.dir_attr);\n\t\tnfs_post_op_update_inode(inode, res.fattr);\n\t}\n\n\treturn status;\n}\n\nstatic int nfs4_proc_link(struct inode *inode, struct inode *dir, struct qstr *name)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(inode),\n\t\t\t\t_nfs4_proc_link(inode, dir, name),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstruct nfs4_createdata {\n\tstruct rpc_message msg;\n\tstruct nfs4_create_arg arg;\n\tstruct nfs4_create_res res;\n\tstruct nfs_fh fh;\n\tstruct nfs_fattr fattr;\n\tstruct nfs_fattr dir_fattr;\n};\n\nstatic struct nfs4_createdata *nfs4_alloc_createdata(struct inode *dir,\n\t\tstruct qstr *name, struct iattr *sattr, u32 ftype)\n{\n\tstruct nfs4_createdata *data;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (data != NULL) {\n\t\tstruct nfs_server *server = NFS_SERVER(dir);\n\n\t\tdata->msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_CREATE];\n\t\tdata->msg.rpc_argp = &data->arg;\n\t\tdata->msg.rpc_resp = &data->res;\n\t\tdata->arg.dir_fh = NFS_FH(dir);\n\t\tdata->arg.server = server;\n\t\tdata->arg.name = name;\n\t\tdata->arg.attrs = sattr;\n\t\tdata->arg.ftype = ftype;\n\t\tdata->arg.bitmask = server->attr_bitmask;\n\t\tdata->res.server = server;\n\t\tdata->res.fh = &data->fh;\n\t\tdata->res.fattr = &data->fattr;\n\t\tdata->res.dir_fattr = &data->dir_fattr;\n\t\tnfs_fattr_init(data->res.fattr);\n\t\tnfs_fattr_init(data->res.dir_fattr);\n\t}\n\treturn data;\n}\n\nstatic int nfs4_do_create(struct inode *dir, struct dentry *dentry, struct nfs4_createdata *data)\n{\n\tint status = rpc_call_sync(NFS_CLIENT(dir), &data->msg, 0);\n\tif (status == 0) {\n\t\tupdate_changeattr(dir, &data->res.dir_cinfo);\n\t\tnfs_post_op_update_inode(dir, data->res.dir_fattr);\n\t\tstatus = nfs_instantiate(dentry, data->res.fh, data->res.fattr);\n\t}\n\treturn status;\n}\n\nstatic void nfs4_free_createdata(struct nfs4_createdata *data)\n{\n\tkfree(data);\n}\n\nstatic int _nfs4_proc_symlink(struct inode *dir, struct dentry *dentry,\n\t\tstruct page *page, unsigned int len, struct iattr *sattr)\n{\n\tstruct nfs4_createdata *data;\n\tint status = -ENAMETOOLONG;\n\n\tif (len > NFS4_MAXPATHLEN)\n\t\tgoto out;\n\n\tstatus = -ENOMEM;\n\tdata = nfs4_alloc_createdata(dir, &dentry->d_name, sattr, NF4LNK);\n\tif (data == NULL)\n\t\tgoto out;\n\n\tdata->msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SYMLINK];\n\tdata->arg.u.symlink.pages = &page;\n\tdata->arg.u.symlink.len = len;\n\t\n\tstatus = nfs4_do_create(dir, dentry, data);\n\n\tnfs4_free_createdata(data);\nout:\n\treturn status;\n}\n\nstatic int nfs4_proc_symlink(struct inode *dir, struct dentry *dentry,\n\t\tstruct page *page, unsigned int len, struct iattr *sattr)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t_nfs4_proc_symlink(dir, dentry, page,\n\t\t\t\t\t\t\tlen, sattr),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_proc_mkdir(struct inode *dir, struct dentry *dentry,\n\t\tstruct iattr *sattr)\n{\n\tstruct nfs4_createdata *data;\n\tint status = -ENOMEM;\n\n\tdata = nfs4_alloc_createdata(dir, &dentry->d_name, sattr, NF4DIR);\n\tif (data == NULL)\n\t\tgoto out;\n\n\tstatus = nfs4_do_create(dir, dentry, data);\n\n\tnfs4_free_createdata(data);\nout:\n\treturn status;\n}\n\nstatic int nfs4_proc_mkdir(struct inode *dir, struct dentry *dentry,\n\t\tstruct iattr *sattr)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t_nfs4_proc_mkdir(dir, dentry, sattr),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_proc_readdir(struct dentry *dentry, struct rpc_cred *cred,\n                  u64 cookie, struct page *page, unsigned int count, int plus)\n{\n\tstruct inode\t\t*dir = dentry->d_inode;\n\tstruct nfs4_readdir_arg args = {\n\t\t.fh = NFS_FH(dir),\n\t\t.pages = &page,\n\t\t.pgbase = 0,\n\t\t.count = count,\n\t\t.bitmask = NFS_SERVER(dentry->d_inode)->attr_bitmask,\n\t};\n\tstruct nfs4_readdir_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_READDIR],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = cred,\n\t};\n\tint\t\t\tstatus;\n\n\tdprintk(\"%s: dentry = %s/%s, cookie = %Lu\\n\", __func__,\n\t\t\tdentry->d_parent->d_name.name,\n\t\t\tdentry->d_name.name,\n\t\t\t(unsigned long long)cookie);\n\tnfs4_setup_readdir(cookie, NFS_COOKIEVERF(dir), dentry, &args);\n\tres.pgbase = args.pgbase;\n\tstatus = rpc_call_sync(NFS_CLIENT(dir), &msg, 0);\n\tif (status == 0)\n\t\tmemcpy(NFS_COOKIEVERF(dir), res.verifier.data, NFS4_VERIFIER_SIZE);\n\n\tnfs_invalidate_atime(dir);\n\n\tdprintk(\"%s: returns %d\\n\", __func__, status);\n\treturn status;\n}\n\nstatic int nfs4_proc_readdir(struct dentry *dentry, struct rpc_cred *cred,\n                  u64 cookie, struct page *page, unsigned int count, int plus)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(dentry->d_inode),\n\t\t\t\t_nfs4_proc_readdir(dentry, cred, cookie,\n\t\t\t\t\tpage, count, plus),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_proc_mknod(struct inode *dir, struct dentry *dentry,\n\t\tstruct iattr *sattr, dev_t rdev)\n{\n\tstruct nfs4_createdata *data;\n\tint mode = sattr->ia_mode;\n\tint status = -ENOMEM;\n\n\tBUG_ON(!(sattr->ia_valid & ATTR_MODE));\n\tBUG_ON(!S_ISFIFO(mode) && !S_ISBLK(mode) && !S_ISCHR(mode) && !S_ISSOCK(mode));\n\n\tdata = nfs4_alloc_createdata(dir, &dentry->d_name, sattr, NF4SOCK);\n\tif (data == NULL)\n\t\tgoto out;\n\n\tif (S_ISFIFO(mode))\n\t\tdata->arg.ftype = NF4FIFO;\n\telse if (S_ISBLK(mode)) {\n\t\tdata->arg.ftype = NF4BLK;\n\t\tdata->arg.u.device.specdata1 = MAJOR(rdev);\n\t\tdata->arg.u.device.specdata2 = MINOR(rdev);\n\t}\n\telse if (S_ISCHR(mode)) {\n\t\tdata->arg.ftype = NF4CHR;\n\t\tdata->arg.u.device.specdata1 = MAJOR(rdev);\n\t\tdata->arg.u.device.specdata2 = MINOR(rdev);\n\t}\n\t\n\tstatus = nfs4_do_create(dir, dentry, data);\n\n\tnfs4_free_createdata(data);\nout:\n\treturn status;\n}\n\nstatic int nfs4_proc_mknod(struct inode *dir, struct dentry *dentry,\n\t\tstruct iattr *sattr, dev_t rdev)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t_nfs4_proc_mknod(dir, dentry, sattr, rdev),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_proc_statfs(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t struct nfs_fsstat *fsstat)\n{\n\tstruct nfs4_statfs_arg args = {\n\t\t.fh = fhandle,\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_STATFS],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = fsstat,\n\t};\n\n\tnfs_fattr_init(fsstat->fattr);\n\treturn rpc_call_sync(server->client, &msg, 0);\n}\n\nstatic int nfs4_proc_statfs(struct nfs_server *server, struct nfs_fh *fhandle, struct nfs_fsstat *fsstat)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs4_proc_statfs(server, fhandle, fsstat),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_do_fsinfo(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\tstruct nfs_fsinfo *fsinfo)\n{\n\tstruct nfs4_fsinfo_arg args = {\n\t\t.fh = fhandle,\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_FSINFO],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = fsinfo,\n\t};\n\n\treturn rpc_call_sync(server->client, &msg, 0);\n}\n\nstatic int nfs4_do_fsinfo(struct nfs_server *server, struct nfs_fh *fhandle, struct nfs_fsinfo *fsinfo)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs4_do_fsinfo(server, fhandle, fsinfo),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int nfs4_proc_fsinfo(struct nfs_server *server, struct nfs_fh *fhandle, struct nfs_fsinfo *fsinfo)\n{\n\tnfs_fattr_init(fsinfo->fattr);\n\treturn nfs4_do_fsinfo(server, fhandle, fsinfo);\n}\n\nstatic int _nfs4_proc_pathconf(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\tstruct nfs_pathconf *pathconf)\n{\n\tstruct nfs4_pathconf_arg args = {\n\t\t.fh = fhandle,\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_PATHCONF],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = pathconf,\n\t};\n\n\t/* None of the pathconf attributes are mandatory to implement */\n\tif ((args.bitmask[0] & nfs4_pathconf_bitmap[0]) == 0) {\n\t\tmemset(pathconf, 0, sizeof(*pathconf));\n\t\treturn 0;\n\t}\n\n\tnfs_fattr_init(pathconf->fattr);\n\treturn rpc_call_sync(server->client, &msg, 0);\n}\n\nstatic int nfs4_proc_pathconf(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\tstruct nfs_pathconf *pathconf)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs4_proc_pathconf(server, fhandle, pathconf),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int nfs4_read_done(struct rpc_task *task, struct nfs_read_data *data)\n{\n\tstruct nfs_server *server = NFS_SERVER(data->inode);\n\n\tif (nfs4_async_handle_error(task, server, data->args.context->state) == -EAGAIN) {\n\t\trpc_restart_call(task);\n\t\treturn -EAGAIN;\n\t}\n\n\tnfs_invalidate_atime(data->inode);\n\tif (task->tk_status > 0)\n\t\trenew_lease(server, data->timestamp);\n\treturn 0;\n}\n\nstatic void nfs4_proc_read_setup(struct nfs_read_data *data, struct rpc_message *msg)\n{\n\tdata->timestamp   = jiffies;\n\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_READ];\n}\n\nstatic int nfs4_write_done(struct rpc_task *task, struct nfs_write_data *data)\n{\n\tstruct inode *inode = data->inode;\n\t\n\tif (nfs4_async_handle_error(task, NFS_SERVER(inode), data->args.context->state) == -EAGAIN) {\n\t\trpc_restart_call(task);\n\t\treturn -EAGAIN;\n\t}\n\tif (task->tk_status >= 0) {\n\t\trenew_lease(NFS_SERVER(inode), data->timestamp);\n\t\tnfs_post_op_update_inode_force_wcc(inode, data->res.fattr);\n\t}\n\treturn 0;\n}\n\nstatic void nfs4_proc_write_setup(struct nfs_write_data *data, struct rpc_message *msg)\n{\n\tstruct nfs_server *server = NFS_SERVER(data->inode);\n\n\tdata->args.bitmask = server->attr_bitmask;\n\tdata->res.server = server;\n\tdata->timestamp   = jiffies;\n\n\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_WRITE];\n}\n\nstatic int nfs4_commit_done(struct rpc_task *task, struct nfs_write_data *data)\n{\n\tstruct inode *inode = data->inode;\n\t\n\tif (nfs4_async_handle_error(task, NFS_SERVER(inode), NULL) == -EAGAIN) {\n\t\trpc_restart_call(task);\n\t\treturn -EAGAIN;\n\t}\n\tnfs_refresh_inode(inode, data->res.fattr);\n\treturn 0;\n}\n\nstatic void nfs4_proc_commit_setup(struct nfs_write_data *data, struct rpc_message *msg)\n{\n\tstruct nfs_server *server = NFS_SERVER(data->inode);\n\t\n\tdata->args.bitmask = server->attr_bitmask;\n\tdata->res.server = server;\n\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_COMMIT];\n}\n\n/*\n * nfs4_proc_async_renew(): This is not one of the nfs_rpc_ops; it is a special\n * standalone procedure for queueing an asynchronous RENEW.\n */\nstatic void nfs4_renew_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs_client *clp = (struct nfs_client *)task->tk_msg.rpc_argp;\n\tunsigned long timestamp = (unsigned long)data;\n\n\tif (task->tk_status < 0) {\n\t\tswitch (task->tk_status) {\n\t\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tcase -NFS4ERR_CB_PATH_DOWN:\n\t\t\t\tnfs4_schedule_state_recovery(clp);\n\t\t}\n\t\treturn;\n\t}\n\tspin_lock(&clp->cl_lock);\n\tif (time_before(clp->cl_last_renewal,timestamp))\n\t\tclp->cl_last_renewal = timestamp;\n\tspin_unlock(&clp->cl_lock);\n}\n\nstatic const struct rpc_call_ops nfs4_renew_ops = {\n\t.rpc_call_done = nfs4_renew_done,\n};\n\nint nfs4_proc_async_renew(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_RENEW],\n\t\t.rpc_argp\t= clp,\n\t\t.rpc_cred\t= cred,\n\t};\n\n\treturn rpc_call_async(clp->cl_rpcclient, &msg, RPC_TASK_SOFT,\n\t\t\t&nfs4_renew_ops, (void *)jiffies);\n}\n\nint nfs4_proc_renew(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_RENEW],\n\t\t.rpc_argp\t= clp,\n\t\t.rpc_cred\t= cred,\n\t};\n\tunsigned long now = jiffies;\n\tint status;\n\n\tstatus = rpc_call_sync(clp->cl_rpcclient, &msg, 0);\n\tif (status < 0)\n\t\treturn status;\n\tspin_lock(&clp->cl_lock);\n\tif (time_before(clp->cl_last_renewal,now))\n\t\tclp->cl_last_renewal = now;\n\tspin_unlock(&clp->cl_lock);\n\treturn 0;\n}\n\nstatic inline int nfs4_server_supports_acls(struct nfs_server *server)\n{\n\treturn (server->caps & NFS_CAP_ACLS)\n\t\t&& (server->acl_bitmask & ACL4_SUPPORT_ALLOW_ACL)\n\t\t&& (server->acl_bitmask & ACL4_SUPPORT_DENY_ACL);\n}\n\n/* Assuming that XATTR_SIZE_MAX is a multiple of PAGE_CACHE_SIZE, and that\n * it's OK to put sizeof(void) * (XATTR_SIZE_MAX/PAGE_CACHE_SIZE) bytes on\n * the stack.\n */\n#define NFS4ACL_MAXPAGES (XATTR_SIZE_MAX >> PAGE_CACHE_SHIFT)\n\nstatic void buf_to_pages(const void *buf, size_t buflen,\n\t\tstruct page **pages, unsigned int *pgbase)\n{\n\tconst void *p = buf;\n\n\t*pgbase = offset_in_page(buf);\n\tp -= *pgbase;\n\twhile (p < buf + buflen) {\n\t\t*(pages++) = virt_to_page(p);\n\t\tp += PAGE_CACHE_SIZE;\n\t}\n}\n\nstruct nfs4_cached_acl {\n\tint cached;\n\tsize_t len;\n\tchar data[0];\n};\n\nstatic void nfs4_set_cached_acl(struct inode *inode, struct nfs4_cached_acl *acl)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tspin_lock(&inode->i_lock);\n\tkfree(nfsi->nfs4_acl);\n\tnfsi->nfs4_acl = acl;\n\tspin_unlock(&inode->i_lock);\n}\n\nstatic void nfs4_zap_acl_attr(struct inode *inode)\n{\n\tnfs4_set_cached_acl(inode, NULL);\n}\n\nstatic inline ssize_t nfs4_read_cached_acl(struct inode *inode, char *buf, size_t buflen)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs4_cached_acl *acl;\n\tint ret = -ENOENT;\n\n\tspin_lock(&inode->i_lock);\n\tacl = nfsi->nfs4_acl;\n\tif (acl == NULL)\n\t\tgoto out;\n\tif (buf == NULL) /* user is just asking for length */\n\t\tgoto out_len;\n\tif (acl->cached == 0)\n\t\tgoto out;\n\tret = -ERANGE; /* see getxattr(2) man page */\n\tif (acl->len > buflen)\n\t\tgoto out;\n\tmemcpy(buf, acl->data, acl->len);\nout_len:\n\tret = acl->len;\nout:\n\tspin_unlock(&inode->i_lock);\n\treturn ret;\n}\n\nstatic void nfs4_write_cached_acl(struct inode *inode, const char *buf, size_t acl_len)\n{\n\tstruct nfs4_cached_acl *acl;\n\n\tif (buf && acl_len <= PAGE_SIZE) {\n\t\tacl = kmalloc(sizeof(*acl) + acl_len, GFP_KERNEL);\n\t\tif (acl == NULL)\n\t\t\tgoto out;\n\t\tacl->cached = 1;\n\t\tmemcpy(acl->data, buf, acl_len);\n\t} else {\n\t\tacl = kmalloc(sizeof(*acl), GFP_KERNEL);\n\t\tif (acl == NULL)\n\t\t\tgoto out;\n\t\tacl->cached = 0;\n\t}\n\tacl->len = acl_len;\nout:\n\tnfs4_set_cached_acl(inode, acl);\n}\n\nstatic ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES];\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tsize_t resp_len = buflen;\n\tvoid *resp_buf;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &resp_len,\n\t};\n\tstruct page *localpage = NULL;\n\tint ret;\n\n\tif (buflen < PAGE_SIZE) {\n\t\t/* As long as we're doing a round trip to the server anyway,\n\t\t * let's be prepared for a page of acl data. */\n\t\tlocalpage = alloc_page(GFP_KERNEL);\n\t\tresp_buf = page_address(localpage);\n\t\tif (localpage == NULL)\n\t\t\treturn -ENOMEM;\n\t\targs.acl_pages[0] = localpage;\n\t\targs.acl_pgbase = 0;\n\t\tresp_len = args.acl_len = PAGE_SIZE;\n\t} else {\n\t\tresp_buf = buf;\n\t\tbuf_to_pages(buf, buflen, args.acl_pages, &args.acl_pgbase);\n\t}\n\tret = rpc_call_sync(NFS_CLIENT(inode), &msg, 0);\n\tif (ret)\n\t\tgoto out_free;\n\tif (resp_len > args.acl_len)\n\t\tnfs4_write_cached_acl(inode, NULL, resp_len);\n\telse\n\t\tnfs4_write_cached_acl(inode, resp_buf, resp_len);\n\tif (buf) {\n\t\tret = -ERANGE;\n\t\tif (resp_len > buflen)\n\t\t\tgoto out_free;\n\t\tif (localpage)\n\t\t\tmemcpy(buf, resp_buf, resp_len);\n\t}\n\tret = resp_len;\nout_free:\n\tif (localpage)\n\t\t__free_page(localpage);\n\treturn ret;\n}\n\nstatic ssize_t nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct nfs4_exception exception = { };\n\tssize_t ret;\n\tdo {\n\t\tret = __nfs4_get_acl_uncached(inode, buf, buflen);\n\t\tif (ret >= 0)\n\t\t\tbreak;\n\t\tret = nfs4_handle_exception(NFS_SERVER(inode), ret, &exception);\n\t} while (exception.retry);\n\treturn ret;\n}\n\nstatic ssize_t nfs4_proc_get_acl(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tint ret;\n\n\tif (!nfs4_server_supports_acls(server))\n\t\treturn -EOPNOTSUPP;\n\tret = nfs_revalidate_inode(server, inode);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (NFS_I(inode)->cache_validity & NFS_INO_INVALID_ACL)\n\t\tnfs_zap_acl_cache(inode);\n\tret = nfs4_read_cached_acl(inode, buf, buflen);\n\tif (ret != -ENOENT)\n\t\treturn ret;\n\treturn nfs4_get_acl_uncached(inode, buf, buflen);\n}\n\nstatic int __nfs4_proc_set_acl(struct inode *inode, const void *buf, size_t buflen)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct page *pages[NFS4ACL_MAXPAGES];\n\tstruct nfs_setaclargs arg = {\n\t\t.fh\t\t= NFS_FH(inode),\n\t\t.acl_pages\t= pages,\n\t\t.acl_len\t= buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_SETACL],\n\t\t.rpc_argp\t= &arg,\n\t\t.rpc_resp\t= NULL,\n\t};\n\tint ret;\n\n\tif (!nfs4_server_supports_acls(server))\n\t\treturn -EOPNOTSUPP;\n\tnfs_inode_return_delegation(inode);\n\tbuf_to_pages(buf, buflen, arg.acl_pages, &arg.acl_pgbase);\n\tret = rpc_call_sync(NFS_CLIENT(inode), &msg, 0);\n\tnfs_access_zap_cache(inode);\n\tnfs_zap_acl_cache(inode);\n\treturn ret;\n}\n\nstatic int nfs4_proc_set_acl(struct inode *inode, const void *buf, size_t buflen)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(inode),\n\t\t\t\t__nfs4_proc_set_acl(inode, buf, buflen),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int\nnfs4_async_handle_error(struct rpc_task *task, const struct nfs_server *server, struct nfs4_state *state)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\n\tif (!clp || task->tk_status >= 0)\n\t\treturn 0;\n\tswitch(task->tk_status) {\n\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_OPENMODE:\n\t\t\tif (state == NULL)\n\t\t\t\tbreak;\n\t\t\tnfs4_state_mark_reclaim_nograce(clp, state);\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\trpc_sleep_on(&clp->cl_rpcwaitq, task, NULL);\n\t\t\tnfs4_schedule_state_recovery(clp);\n\t\t\tif (test_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) == 0)\n\t\t\t\trpc_wake_up_queued_task(&clp->cl_rpcwaitq, task);\n\t\t\ttask->tk_status = 0;\n\t\t\treturn -EAGAIN;\n\t\tcase -NFS4ERR_DELAY:\n\t\t\tnfs_inc_server_stats(server, NFSIOS_DELAY);\n\t\tcase -NFS4ERR_GRACE:\n\t\t\trpc_delay(task, NFS4_POLL_RETRY_MAX);\n\t\t\ttask->tk_status = 0;\n\t\t\treturn -EAGAIN;\n\t\tcase -NFS4ERR_OLD_STATEID:\n\t\t\ttask->tk_status = 0;\n\t\t\treturn -EAGAIN;\n\t}\n\ttask->tk_status = nfs4_map_errors(task->tk_status);\n\treturn 0;\n}\n\nint nfs4_proc_setclientid(struct nfs_client *clp, u32 program, unsigned short port, struct rpc_cred *cred)\n{\n\tnfs4_verifier sc_verifier;\n\tstruct nfs4_setclientid setclientid = {\n\t\t.sc_verifier = &sc_verifier,\n\t\t.sc_prog = program,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SETCLIENTID],\n\t\t.rpc_argp = &setclientid,\n\t\t.rpc_resp = clp,\n\t\t.rpc_cred = cred,\n\t};\n\t__be32 *p;\n\tint loop = 0;\n\tint status;\n\n\tp = (__be32*)sc_verifier.data;\n\t*p++ = htonl((u32)clp->cl_boot_time.tv_sec);\n\t*p = htonl((u32)clp->cl_boot_time.tv_nsec);\n\n\tfor(;;) {\n\t\tsetclientid.sc_name_len = scnprintf(setclientid.sc_name,\n\t\t\t\tsizeof(setclientid.sc_name), \"%s/%s %s %s %u\",\n\t\t\t\tclp->cl_ipaddr,\n\t\t\t\trpc_peeraddr2str(clp->cl_rpcclient,\n\t\t\t\t\t\t\tRPC_DISPLAY_ADDR),\n\t\t\t\trpc_peeraddr2str(clp->cl_rpcclient,\n\t\t\t\t\t\t\tRPC_DISPLAY_PROTO),\n\t\t\t\tclp->cl_rpcclient->cl_auth->au_ops->au_name,\n\t\t\t\tclp->cl_id_uniquifier);\n\t\tsetclientid.sc_netid_len = scnprintf(setclientid.sc_netid,\n\t\t\t\tsizeof(setclientid.sc_netid),\n\t\t\t\trpc_peeraddr2str(clp->cl_rpcclient,\n\t\t\t\t\t\t\tRPC_DISPLAY_NETID));\n\t\tsetclientid.sc_uaddr_len = scnprintf(setclientid.sc_uaddr,\n\t\t\t\tsizeof(setclientid.sc_uaddr), \"%s.%u.%u\",\n\t\t\t\tclp->cl_ipaddr, port >> 8, port & 255);\n\n\t\tstatus = rpc_call_sync(clp->cl_rpcclient, &msg, 0);\n\t\tif (status != -NFS4ERR_CLID_INUSE)\n\t\t\tbreak;\n\t\tif (signalled())\n\t\t\tbreak;\n\t\tif (loop++ & 1)\n\t\t\tssleep(clp->cl_lease_time + 1);\n\t\telse\n\t\t\tif (++clp->cl_id_uniquifier == 0)\n\t\t\t\tbreak;\n\t}\n\treturn status;\n}\n\nstatic int _nfs4_proc_setclientid_confirm(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tstruct nfs_fsinfo fsinfo;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SETCLIENTID_CONFIRM],\n\t\t.rpc_argp = clp,\n\t\t.rpc_resp = &fsinfo,\n\t\t.rpc_cred = cred,\n\t};\n\tunsigned long now;\n\tint status;\n\n\tnow = jiffies;\n\tstatus = rpc_call_sync(clp->cl_rpcclient, &msg, 0);\n\tif (status == 0) {\n\t\tspin_lock(&clp->cl_lock);\n\t\tclp->cl_lease_time = fsinfo.lease_time * HZ;\n\t\tclp->cl_last_renewal = now;\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n\treturn status;\n}\n\nint nfs4_proc_setclientid_confirm(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tlong timeout = 0;\n\tint err;\n\tdo {\n\t\terr = _nfs4_proc_setclientid_confirm(clp, cred);\n\t\tswitch (err) {\n\t\t\tcase 0:\n\t\t\t\treturn err;\n\t\t\tcase -NFS4ERR_RESOURCE:\n\t\t\t\t/* The IBM lawyers misread another document! */\n\t\t\tcase -NFS4ERR_DELAY:\n\t\t\t\terr = nfs4_delay(clp->cl_rpcclient, &timeout);\n\t\t}\n\t} while (err == 0);\n\treturn err;\n}\n\nstruct nfs4_delegreturndata {\n\tstruct nfs4_delegreturnargs args;\n\tstruct nfs4_delegreturnres res;\n\tstruct nfs_fh fh;\n\tnfs4_stateid stateid;\n\tunsigned long timestamp;\n\tstruct nfs_fattr fattr;\n\tint rpc_status;\n};\n\nstatic void nfs4_delegreturn_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_delegreturndata *data = calldata;\n\tdata->rpc_status = task->tk_status;\n\tif (data->rpc_status == 0)\n\t\trenew_lease(data->res.server, data->timestamp);\n}\n\nstatic void nfs4_delegreturn_release(void *calldata)\n{\n\tkfree(calldata);\n}\n\nstatic const struct rpc_call_ops nfs4_delegreturn_ops = {\n\t.rpc_call_done = nfs4_delegreturn_done,\n\t.rpc_release = nfs4_delegreturn_release,\n};\n\nstatic int _nfs4_proc_delegreturn(struct inode *inode, struct rpc_cred *cred, const nfs4_stateid *stateid, int issync)\n{\n\tstruct nfs4_delegreturndata *data;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_DELEGRETURN],\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_delegreturn_ops,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tint status = 0;\n\n\tdata = kmalloc(sizeof(*data), GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\tdata->args.fhandle = &data->fh;\n\tdata->args.stateid = &data->stateid;\n\tdata->args.bitmask = server->attr_bitmask;\n\tnfs_copy_fh(&data->fh, NFS_FH(inode));\n\tmemcpy(&data->stateid, stateid, sizeof(data->stateid));\n\tdata->res.fattr = &data->fattr;\n\tdata->res.server = server;\n\tnfs_fattr_init(data->res.fattr);\n\tdata->timestamp = jiffies;\n\tdata->rpc_status = 0;\n\n\ttask_setup_data.callback_data = data;\n\tmsg.rpc_argp = &data->args,\n\tmsg.rpc_resp = &data->res,\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tif (!issync)\n\t\tgoto out;\n\tstatus = nfs4_wait_for_completion_rpc_task(task);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = data->rpc_status;\n\tif (status != 0)\n\t\tgoto out;\n\tnfs_refresh_inode(inode, &data->fattr);\nout:\n\trpc_put_task(task);\n\treturn status;\n}\n\nint nfs4_proc_delegreturn(struct inode *inode, struct rpc_cred *cred, const nfs4_stateid *stateid, int issync)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = _nfs4_proc_delegreturn(inode, cred, stateid, issync);\n\t\tswitch (err) {\n\t\t\tcase -NFS4ERR_STALE_STATEID:\n\t\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tcase 0:\n\t\t\t\treturn 0;\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n#define NFS4_LOCK_MINTIMEOUT (1 * HZ)\n#define NFS4_LOCK_MAXTIMEOUT (30 * HZ)\n\n/* \n * sleep, with exponential backoff, and retry the LOCK operation. \n */\nstatic unsigned long\nnfs4_set_lock_task_retry(unsigned long timeout)\n{\n\tschedule_timeout_killable(timeout);\n\ttimeout <<= 1;\n\tif (timeout > NFS4_LOCK_MAXTIMEOUT)\n\t\treturn NFS4_LOCK_MAXTIMEOUT;\n\treturn timeout;\n}\n\nstatic int _nfs4_proc_getlk(struct nfs4_state *state, int cmd, struct file_lock *request)\n{\n\tstruct inode *inode = state->inode;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs_lockt_args arg = {\n\t\t.fh = NFS_FH(inode),\n\t\t.fl = request,\n\t};\n\tstruct nfs_lockt_res res = {\n\t\t.denied = request,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_LOCKT],\n\t\t.rpc_argp       = &arg,\n\t\t.rpc_resp       = &res,\n\t\t.rpc_cred\t= state->owner->so_cred,\n\t};\n\tstruct nfs4_lock_state *lsp;\n\tint status;\n\n\targ.lock_owner.clientid = clp->cl_clientid;\n\tstatus = nfs4_set_lock_state(state, request);\n\tif (status != 0)\n\t\tgoto out;\n\tlsp = request->fl_u.nfs4_fl.owner;\n\targ.lock_owner.id = lsp->ls_id.id;\n\tstatus = rpc_call_sync(server->client, &msg, 0);\n\tswitch (status) {\n\t\tcase 0:\n\t\t\trequest->fl_type = F_UNLCK;\n\t\t\tbreak;\n\t\tcase -NFS4ERR_DENIED:\n\t\t\tstatus = 0;\n\t}\n\trequest->fl_ops->fl_release_private(request);\nout:\n\treturn status;\n}\n\nstatic int nfs4_proc_getlk(struct nfs4_state *state, int cmd, struct file_lock *request)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(state->inode),\n\t\t\t\t_nfs4_proc_getlk(state, cmd, request),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int do_vfs_lock(struct file *file, struct file_lock *fl)\n{\n\tint res = 0;\n\tswitch (fl->fl_flags & (FL_POSIX|FL_FLOCK)) {\n\t\tcase FL_POSIX:\n\t\t\tres = posix_lock_file_wait(file, fl);\n\t\t\tbreak;\n\t\tcase FL_FLOCK:\n\t\t\tres = flock_lock_file_wait(file, fl);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\treturn res;\n}\n\nstruct nfs4_unlockdata {\n\tstruct nfs_locku_args arg;\n\tstruct nfs_locku_res res;\n\tstruct nfs4_lock_state *lsp;\n\tstruct nfs_open_context *ctx;\n\tstruct file_lock fl;\n\tconst struct nfs_server *server;\n\tunsigned long timestamp;\n};\n\nstatic struct nfs4_unlockdata *nfs4_alloc_unlockdata(struct file_lock *fl,\n\t\tstruct nfs_open_context *ctx,\n\t\tstruct nfs4_lock_state *lsp,\n\t\tstruct nfs_seqid *seqid)\n{\n\tstruct nfs4_unlockdata *p;\n\tstruct inode *inode = lsp->ls_state->inode;\n\n\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\tif (p == NULL)\n\t\treturn NULL;\n\tp->arg.fh = NFS_FH(inode);\n\tp->arg.fl = &p->fl;\n\tp->arg.seqid = seqid;\n\tp->res.seqid = seqid;\n\tp->arg.stateid = &lsp->ls_stateid;\n\tp->lsp = lsp;\n\tatomic_inc(&lsp->ls_count);\n\t/* Ensure we don't close file until we're done freeing locks! */\n\tp->ctx = get_nfs_open_context(ctx);\n\tmemcpy(&p->fl, fl, sizeof(p->fl));\n\tp->server = NFS_SERVER(inode);\n\treturn p;\n}\n\nstatic void nfs4_locku_release_calldata(void *data)\n{\n\tstruct nfs4_unlockdata *calldata = data;\n\tnfs_free_seqid(calldata->arg.seqid);\n\tnfs4_put_lock_state(calldata->lsp);\n\tput_nfs_open_context(calldata->ctx);\n\tkfree(calldata);\n}\n\nstatic void nfs4_locku_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_unlockdata *calldata = data;\n\n\tif (RPC_ASSASSINATED(task))\n\t\treturn;\n\tswitch (task->tk_status) {\n\t\tcase 0:\n\t\t\tmemcpy(calldata->lsp->ls_stateid.data,\n\t\t\t\t\tcalldata->res.stateid.data,\n\t\t\t\t\tsizeof(calldata->lsp->ls_stateid.data));\n\t\t\trenew_lease(calldata->server, calldata->timestamp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_OLD_STATEID:\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (nfs4_async_handle_error(task, calldata->server, NULL) == -EAGAIN)\n\t\t\t\trpc_restart_call(task);\n\t}\n}\n\nstatic void nfs4_locku_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_unlockdata *calldata = data;\n\n\tif (nfs_wait_on_sequence(calldata->arg.seqid, task) != 0)\n\t\treturn;\n\tif ((calldata->lsp->ls_flags & NFS_LOCK_INITIALIZED) == 0) {\n\t\t/* Note: exit _without_ running nfs4_locku_done */\n\t\ttask->tk_action = NULL;\n\t\treturn;\n\t}\n\tcalldata->timestamp = jiffies;\n\trpc_call_start(task);\n}\n\nstatic const struct rpc_call_ops nfs4_locku_ops = {\n\t.rpc_call_prepare = nfs4_locku_prepare,\n\t.rpc_call_done = nfs4_locku_done,\n\t.rpc_release = nfs4_locku_release_calldata,\n};\n\nstatic struct rpc_task *nfs4_do_unlck(struct file_lock *fl,\n\t\tstruct nfs_open_context *ctx,\n\t\tstruct nfs4_lock_state *lsp,\n\t\tstruct nfs_seqid *seqid)\n{\n\tstruct nfs4_unlockdata *data;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LOCKU],\n\t\t.rpc_cred = ctx->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = NFS_CLIENT(lsp->ls_state->inode),\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_locku_ops,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\n\t/* Ensure this is an unlock - when canceling a lock, the\n\t * canceled lock is passed in, and it won't be an unlock.\n\t */\n\tfl->fl_type = F_UNLCK;\n\n\tdata = nfs4_alloc_unlockdata(fl, ctx, lsp, seqid);\n\tif (data == NULL) {\n\t\tnfs_free_seqid(seqid);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tmsg.rpc_argp = &data->arg,\n\tmsg.rpc_resp = &data->res,\n\ttask_setup_data.callback_data = data;\n\treturn rpc_run_task(&task_setup_data);\n}\n\nstatic int nfs4_proc_unlck(struct nfs4_state *state, int cmd, struct file_lock *request)\n{\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_seqid *seqid;\n\tstruct nfs4_lock_state *lsp;\n\tstruct rpc_task *task;\n\tint status = 0;\n\tunsigned char fl_flags = request->fl_flags;\n\n\tstatus = nfs4_set_lock_state(state, request);\n\t/* Unlock _before_ we do the RPC call */\n\trequest->fl_flags |= FL_EXISTS;\n\tdown_read(&nfsi->rwsem);\n\tif (do_vfs_lock(request->fl_file, request) == -ENOENT) {\n\t\tup_read(&nfsi->rwsem);\n\t\tgoto out;\n\t}\n\tup_read(&nfsi->rwsem);\n\tif (status != 0)\n\t\tgoto out;\n\t/* Is this a delegated lock? */\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags))\n\t\tgoto out;\n\tlsp = request->fl_u.nfs4_fl.owner;\n\tseqid = nfs_alloc_seqid(&lsp->ls_seqid);\n\tstatus = -ENOMEM;\n\tif (seqid == NULL)\n\t\tgoto out;\n\ttask = nfs4_do_unlck(request, nfs_file_open_context(request->fl_file), lsp, seqid);\n\tstatus = PTR_ERR(task);\n\tif (IS_ERR(task))\n\t\tgoto out;\n\tstatus = nfs4_wait_for_completion_rpc_task(task);\n\trpc_put_task(task);\nout:\n\trequest->fl_flags = fl_flags;\n\treturn status;\n}\n\nstruct nfs4_lockdata {\n\tstruct nfs_lock_args arg;\n\tstruct nfs_lock_res res;\n\tstruct nfs4_lock_state *lsp;\n\tstruct nfs_open_context *ctx;\n\tstruct file_lock fl;\n\tunsigned long timestamp;\n\tint rpc_status;\n\tint cancelled;\n};\n\nstatic struct nfs4_lockdata *nfs4_alloc_lockdata(struct file_lock *fl,\n\t\tstruct nfs_open_context *ctx, struct nfs4_lock_state *lsp)\n{\n\tstruct nfs4_lockdata *p;\n\tstruct inode *inode = lsp->ls_state->inode;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (p == NULL)\n\t\treturn NULL;\n\n\tp->arg.fh = NFS_FH(inode);\n\tp->arg.fl = &p->fl;\n\tp->arg.open_seqid = nfs_alloc_seqid(&lsp->ls_state->owner->so_seqid);\n\tif (p->arg.open_seqid == NULL)\n\t\tgoto out_free;\n\tp->arg.lock_seqid = nfs_alloc_seqid(&lsp->ls_seqid);\n\tif (p->arg.lock_seqid == NULL)\n\t\tgoto out_free_seqid;\n\tp->arg.lock_stateid = &lsp->ls_stateid;\n\tp->arg.lock_owner.clientid = server->nfs_client->cl_clientid;\n\tp->arg.lock_owner.id = lsp->ls_id.id;\n\tp->res.lock_seqid = p->arg.lock_seqid;\n\tp->lsp = lsp;\n\tatomic_inc(&lsp->ls_count);\n\tp->ctx = get_nfs_open_context(ctx);\n\tmemcpy(&p->fl, fl, sizeof(p->fl));\n\treturn p;\nout_free_seqid:\n\tnfs_free_seqid(p->arg.open_seqid);\nout_free:\n\tkfree(p);\n\treturn NULL;\n}\n\nstatic void nfs4_lock_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_lockdata *data = calldata;\n\tstruct nfs4_state *state = data->lsp->ls_state;\n\n\tdprintk(\"%s: begin!\\n\", __func__);\n\tif (nfs_wait_on_sequence(data->arg.lock_seqid, task) != 0)\n\t\treturn;\n\t/* Do we need to do an open_to_lock_owner? */\n\tif (!(data->arg.lock_seqid->sequence->flags & NFS_SEQID_CONFIRMED)) {\n\t\tif (nfs_wait_on_sequence(data->arg.open_seqid, task) != 0)\n\t\t\treturn;\n\t\tdata->arg.open_stateid = &state->stateid;\n\t\tdata->arg.new_lock_owner = 1;\n\t\tdata->res.open_seqid = data->arg.open_seqid;\n\t} else\n\t\tdata->arg.new_lock_owner = 0;\n\tdata->timestamp = jiffies;\n\trpc_call_start(task);\n\tdprintk(\"%s: done!, ret = %d\\n\", __func__, data->rpc_status);\n}\n\nstatic void nfs4_lock_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_lockdata *data = calldata;\n\n\tdprintk(\"%s: begin!\\n\", __func__);\n\n\tdata->rpc_status = task->tk_status;\n\tif (RPC_ASSASSINATED(task))\n\t\tgoto out;\n\tif (data->arg.new_lock_owner != 0) {\n\t\tif (data->rpc_status == 0)\n\t\t\tnfs_confirm_seqid(&data->lsp->ls_seqid, 0);\n\t\telse\n\t\t\tgoto out;\n\t}\n\tif (data->rpc_status == 0) {\n\t\tmemcpy(data->lsp->ls_stateid.data, data->res.stateid.data,\n\t\t\t\t\tsizeof(data->lsp->ls_stateid.data));\n\t\tdata->lsp->ls_flags |= NFS_LOCK_INITIALIZED;\n\t\trenew_lease(NFS_SERVER(data->ctx->path.dentry->d_inode), data->timestamp);\n\t}\nout:\n\tdprintk(\"%s: done, ret = %d!\\n\", __func__, data->rpc_status);\n}\n\nstatic void nfs4_lock_release(void *calldata)\n{\n\tstruct nfs4_lockdata *data = calldata;\n\n\tdprintk(\"%s: begin!\\n\", __func__);\n\tnfs_free_seqid(data->arg.open_seqid);\n\tif (data->cancelled != 0) {\n\t\tstruct rpc_task *task;\n\t\ttask = nfs4_do_unlck(&data->fl, data->ctx, data->lsp,\n\t\t\t\tdata->arg.lock_seqid);\n\t\tif (!IS_ERR(task))\n\t\t\trpc_put_task(task);\n\t\tdprintk(\"%s: cancelling lock!\\n\", __func__);\n\t} else\n\t\tnfs_free_seqid(data->arg.lock_seqid);\n\tnfs4_put_lock_state(data->lsp);\n\tput_nfs_open_context(data->ctx);\n\tkfree(data);\n\tdprintk(\"%s: done!\\n\", __func__);\n}\n\nstatic const struct rpc_call_ops nfs4_lock_ops = {\n\t.rpc_call_prepare = nfs4_lock_prepare,\n\t.rpc_call_done = nfs4_lock_done,\n\t.rpc_release = nfs4_lock_release,\n};\n\nstatic int _nfs4_do_setlk(struct nfs4_state *state, int cmd, struct file_lock *fl, int reclaim)\n{\n\tstruct nfs4_lockdata *data;\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LOCK],\n\t\t.rpc_cred = state->owner->so_cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = NFS_CLIENT(state->inode),\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_lock_ops,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tint ret;\n\n\tdprintk(\"%s: begin!\\n\", __func__);\n\tdata = nfs4_alloc_lockdata(fl, nfs_file_open_context(fl->fl_file),\n\t\t\tfl->fl_u.nfs4_fl.owner);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\tif (IS_SETLKW(cmd))\n\t\tdata->arg.block = 1;\n\tif (reclaim != 0)\n\t\tdata->arg.reclaim = 1;\n\tmsg.rpc_argp = &data->arg,\n\tmsg.rpc_resp = &data->res,\n\ttask_setup_data.callback_data = data;\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tret = nfs4_wait_for_completion_rpc_task(task);\n\tif (ret == 0) {\n\t\tret = data->rpc_status;\n\t\tif (ret == -NFS4ERR_DENIED)\n\t\t\tret = -EAGAIN;\n\t} else\n\t\tdata->cancelled = 1;\n\trpc_put_task(task);\n\tdprintk(\"%s: done, ret = %d!\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int nfs4_lock_reclaim(struct nfs4_state *state, struct file_lock *request)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\t/* Cache the lock if possible... */\n\t\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) != 0)\n\t\t\treturn 0;\n\t\terr = _nfs4_do_setlk(state, F_SETLK, request, 1);\n\t\tif (err != -NFS4ERR_DELAY)\n\t\t\tbreak;\n\t\tnfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int nfs4_lock_expired(struct nfs4_state *state, struct file_lock *request)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\terr = nfs4_set_lock_state(state, request);\n\tif (err != 0)\n\t\treturn err;\n\tdo {\n\t\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) != 0)\n\t\t\treturn 0;\n\t\terr = _nfs4_do_setlk(state, F_SETLK, request, 0);\n\t\tif (err != -NFS4ERR_DELAY)\n\t\t\tbreak;\n\t\tnfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_proc_setlk(struct nfs4_state *state, int cmd, struct file_lock *request)\n{\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tunsigned char fl_flags = request->fl_flags;\n\tint status;\n\n\t/* Is this a delegated open? */\n\tstatus = nfs4_set_lock_state(state, request);\n\tif (status != 0)\n\t\tgoto out;\n\trequest->fl_flags |= FL_ACCESS;\n\tstatus = do_vfs_lock(request->fl_file, request);\n\tif (status < 0)\n\t\tgoto out;\n\tdown_read(&nfsi->rwsem);\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags)) {\n\t\t/* Yes: cache locks! */\n\t\t/* ...but avoid races with delegation recall... */\n\t\trequest->fl_flags = fl_flags & ~FL_SLEEP;\n\t\tstatus = do_vfs_lock(request->fl_file, request);\n\t\tgoto out_unlock;\n\t}\n\tstatus = _nfs4_do_setlk(state, cmd, request, 0);\n\tif (status != 0)\n\t\tgoto out_unlock;\n\t/* Note: we always want to sleep here! */\n\trequest->fl_flags = fl_flags | FL_SLEEP;\n\tif (do_vfs_lock(request->fl_file, request) < 0)\n\t\tprintk(KERN_WARNING \"%s: VFS is out of sync with lock manager!\\n\", __func__);\nout_unlock:\n\tup_read(&nfsi->rwsem);\nout:\n\trequest->fl_flags = fl_flags;\n\treturn status;\n}\n\nstatic int nfs4_proc_setlk(struct nfs4_state *state, int cmd, struct file_lock *request)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(state->inode),\n\t\t\t\t_nfs4_proc_setlk(state, cmd, request),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int\nnfs4_proc_lock(struct file *filp, int cmd, struct file_lock *request)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct nfs4_state *state;\n\tunsigned long timeout = NFS4_LOCK_MINTIMEOUT;\n\tint status;\n\n\t/* verify open state */\n\tctx = nfs_file_open_context(filp);\n\tstate = ctx->state;\n\n\tif (request->fl_start < 0 || request->fl_end < 0)\n\t\treturn -EINVAL;\n\n\tif (IS_GETLK(cmd))\n\t\treturn nfs4_proc_getlk(state, F_GETLK, request);\n\n\tif (!(IS_SETLK(cmd) || IS_SETLKW(cmd)))\n\t\treturn -EINVAL;\n\n\tif (request->fl_type == F_UNLCK)\n\t\treturn nfs4_proc_unlck(state, cmd, request);\n\n\tdo {\n\t\tstatus = nfs4_proc_setlk(state, cmd, request);\n\t\tif ((status != -EAGAIN) || IS_SETLK(cmd))\n\t\t\tbreak;\n\t\ttimeout = nfs4_set_lock_task_retry(timeout);\n\t\tstatus = -ERESTARTSYS;\n\t\tif (signalled())\n\t\t\tbreak;\n\t} while(status < 0);\n\treturn status;\n}\n\nint nfs4_lock_delegation_recall(struct nfs4_state *state, struct file_lock *fl)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\terr = nfs4_set_lock_state(state, fl);\n\tif (err != 0)\n\t\tgoto out;\n\tdo {\n\t\terr = _nfs4_do_setlk(state, F_SETLK, fl, 0);\n\t\tif (err != -NFS4ERR_DELAY)\n\t\t\tbreak;\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\nout:\n\treturn err;\n}\n\n#define XATTR_NAME_NFSV4_ACL \"system.nfs4_acl\"\n\nint nfs4_setxattr(struct dentry *dentry, const char *key, const void *buf,\n\t\tsize_t buflen, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\tif (strcmp(key, XATTR_NAME_NFSV4_ACL) != 0)\n\t\treturn -EOPNOTSUPP;\n\n\treturn nfs4_proc_set_acl(inode, buf, buflen);\n}\n\n/* The getxattr man page suggests returning -ENODATA for unknown attributes,\n * and that's what we'll do for e.g. user attributes that haven't been set.\n * But we'll follow ext2/ext3's lead by returning -EOPNOTSUPP for unsupported\n * attributes in kernel-managed attribute namespaces. */\nssize_t nfs4_getxattr(struct dentry *dentry, const char *key, void *buf,\n\t\tsize_t buflen)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\tif (strcmp(key, XATTR_NAME_NFSV4_ACL) != 0)\n\t\treturn -EOPNOTSUPP;\n\n\treturn nfs4_proc_get_acl(inode, buf, buflen);\n}\n\nssize_t nfs4_listxattr(struct dentry *dentry, char *buf, size_t buflen)\n{\n\tsize_t len = strlen(XATTR_NAME_NFSV4_ACL) + 1;\n\n\tif (!nfs4_server_supports_acls(NFS_SERVER(dentry->d_inode)))\n\t\treturn 0;\n\tif (buf && buflen < len)\n\t\treturn -ERANGE;\n\tif (buf)\n\t\tmemcpy(buf, XATTR_NAME_NFSV4_ACL, len);\n\treturn len;\n}\n\nint nfs4_proc_fs_locations(struct inode *dir, const struct qstr *name,\n\t\tstruct nfs4_fs_locations *fs_locations, struct page *page)\n{\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tu32 bitmask[2] = {\n\t\t[0] = FATTR4_WORD0_FSID | FATTR4_WORD0_FS_LOCATIONS,\n\t\t[1] = FATTR4_WORD1_MOUNTED_ON_FILEID,\n\t};\n\tstruct nfs4_fs_locations_arg args = {\n\t\t.dir_fh = NFS_FH(dir),\n\t\t.name = name,\n\t\t.page = page,\n\t\t.bitmask = bitmask,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_FS_LOCATIONS],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = fs_locations,\n\t};\n\tint status;\n\n\tdprintk(\"%s: start\\n\", __func__);\n\tnfs_fattr_init(&fs_locations->fattr);\n\tfs_locations->server = server;\n\tfs_locations->nlocations = 0;\n\tstatus = rpc_call_sync(server->client, &msg, 0);\n\tdprintk(\"%s: returned status = %d\\n\", __func__, status);\n\treturn status;\n}\n\nstruct nfs4_state_recovery_ops nfs4_reboot_recovery_ops = {\n\t.owner_flag_bit = NFS_OWNER_RECLAIM_REBOOT,\n\t.state_flag_bit\t= NFS_STATE_RECLAIM_REBOOT,\n\t.recover_open\t= nfs4_open_reclaim,\n\t.recover_lock\t= nfs4_lock_reclaim,\n};\n\nstruct nfs4_state_recovery_ops nfs4_nograce_recovery_ops = {\n\t.owner_flag_bit = NFS_OWNER_RECLAIM_NOGRACE,\n\t.state_flag_bit\t= NFS_STATE_RECLAIM_NOGRACE,\n\t.recover_open\t= nfs4_open_expired,\n\t.recover_lock\t= nfs4_lock_expired,\n};\n\nstatic const struct inode_operations nfs4_file_inode_operations = {\n\t.permission\t= nfs_permission,\n\t.getattr\t= nfs_getattr,\n\t.setattr\t= nfs_setattr,\n\t.getxattr\t= nfs4_getxattr,\n\t.setxattr\t= nfs4_setxattr,\n\t.listxattr\t= nfs4_listxattr,\n};\n\nconst struct nfs_rpc_ops nfs_v4_clientops = {\n\t.version\t= 4,\t\t\t/* protocol version */\n\t.dentry_ops\t= &nfs4_dentry_operations,\n\t.dir_inode_ops\t= &nfs4_dir_inode_operations,\n\t.file_inode_ops\t= &nfs4_file_inode_operations,\n\t.getroot\t= nfs4_proc_get_root,\n\t.getattr\t= nfs4_proc_getattr,\n\t.setattr\t= nfs4_proc_setattr,\n\t.lookupfh\t= nfs4_proc_lookupfh,\n\t.lookup\t\t= nfs4_proc_lookup,\n\t.access\t\t= nfs4_proc_access,\n\t.readlink\t= nfs4_proc_readlink,\n\t.create\t\t= nfs4_proc_create,\n\t.remove\t\t= nfs4_proc_remove,\n\t.unlink_setup\t= nfs4_proc_unlink_setup,\n\t.unlink_done\t= nfs4_proc_unlink_done,\n\t.rename\t\t= nfs4_proc_rename,\n\t.link\t\t= nfs4_proc_link,\n\t.symlink\t= nfs4_proc_symlink,\n\t.mkdir\t\t= nfs4_proc_mkdir,\n\t.rmdir\t\t= nfs4_proc_remove,\n\t.readdir\t= nfs4_proc_readdir,\n\t.mknod\t\t= nfs4_proc_mknod,\n\t.statfs\t\t= nfs4_proc_statfs,\n\t.fsinfo\t\t= nfs4_proc_fsinfo,\n\t.pathconf\t= nfs4_proc_pathconf,\n\t.set_capabilities = nfs4_server_capabilities,\n\t.decode_dirent\t= nfs4_decode_dirent,\n\t.read_setup\t= nfs4_proc_read_setup,\n\t.read_done\t= nfs4_read_done,\n\t.write_setup\t= nfs4_proc_write_setup,\n\t.write_done\t= nfs4_write_done,\n\t.commit_setup\t= nfs4_proc_commit_setup,\n\t.commit_done\t= nfs4_commit_done,\n\t.lock\t\t= nfs4_proc_lock,\n\t.clear_acl_cache = nfs4_zap_acl_attr,\n};\n\n/*\n * Local variables:\n *  c-basic-offset: 8\n * End:\n */\n", "/*\n *  fs/nfs/nfs4state.c\n *\n *  Client-side XDR for NFSv4.\n *\n *  Copyright (c) 2002 The Regents of the University of Michigan.\n *  All rights reserved.\n *\n *  Kendrick Smith <kmsmith@umich.edu>\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions\n *  are met:\n *\n *  1. Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *  2. Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *  3. Neither the name of the University nor the names of its\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED\n *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n *  DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n *  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * Implementation of the NFSv4 state model.  For the time being,\n * this is minimal, but will be made much more complex in a\n * subsequent patch.\n */\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/smp_lock.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_idmap.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/bitops.h>\n\n#include \"nfs4_fs.h\"\n#include \"callback.h\"\n#include \"delegation.h\"\n#include \"internal.h\"\n\n#define OPENOWNER_POOL_SIZE\t8\n\nconst nfs4_stateid zero_stateid;\n\nstatic LIST_HEAD(nfs4_clientid_list);\n\nstatic int nfs4_init_client(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tint status = nfs4_proc_setclientid(clp, NFS4_CALLBACK,\n\t\t\tnfs_callback_tcpport, cred);\n\tif (status == 0)\n\t\tstatus = nfs4_proc_setclientid_confirm(clp, cred);\n\tif (status == 0)\n\t\tnfs4_schedule_state_renewal(clp);\n\treturn status;\n}\n\nstatic struct rpc_cred *nfs4_get_machine_cred_locked(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred = NULL;\n\n\tif (clp->cl_machine_cred != NULL)\n\t\tcred = get_rpccred(clp->cl_machine_cred);\n\treturn cred;\n}\n\nstatic void nfs4_clear_machine_cred(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\n\tspin_lock(&clp->cl_lock);\n\tcred = clp->cl_machine_cred;\n\tclp->cl_machine_cred = NULL;\n\tspin_unlock(&clp->cl_lock);\n\tif (cred != NULL)\n\t\tput_rpccred(cred);\n}\n\nstruct rpc_cred *nfs4_get_renew_cred_locked(struct nfs_client *clp)\n{\n\tstruct nfs4_state_owner *sp;\n\tstruct rb_node *pos;\n\tstruct rpc_cred *cred = NULL;\n\n\tfor (pos = rb_first(&clp->cl_state_owners); pos != NULL; pos = rb_next(pos)) {\n\t\tsp = rb_entry(pos, struct nfs4_state_owner, so_client_node);\n\t\tif (list_empty(&sp->so_states))\n\t\t\tcontinue;\n\t\tcred = get_rpccred(sp->so_cred);\n\t\tbreak;\n\t}\n\treturn cred;\n}\n\nstatic struct rpc_cred *nfs4_get_renew_cred(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\n\tspin_lock(&clp->cl_lock);\n\tcred = nfs4_get_renew_cred_locked(clp);\n\tspin_unlock(&clp->cl_lock);\n\treturn cred;\n}\n\nstatic struct rpc_cred *nfs4_get_setclientid_cred(struct nfs_client *clp)\n{\n\tstruct nfs4_state_owner *sp;\n\tstruct rb_node *pos;\n\tstruct rpc_cred *cred;\n\n\tspin_lock(&clp->cl_lock);\n\tcred = nfs4_get_machine_cred_locked(clp);\n\tif (cred != NULL)\n\t\tgoto out;\n\tpos = rb_first(&clp->cl_state_owners);\n\tif (pos != NULL) {\n\t\tsp = rb_entry(pos, struct nfs4_state_owner, so_client_node);\n\t\tcred = get_rpccred(sp->so_cred);\n\t}\nout:\n\tspin_unlock(&clp->cl_lock);\n\treturn cred;\n}\n\nstatic void nfs_alloc_unique_id(struct rb_root *root, struct nfs_unique_id *new,\n\t\t__u64 minval, int maxbits)\n{\n\tstruct rb_node **p, *parent;\n\tstruct nfs_unique_id *pos;\n\t__u64 mask = ~0ULL;\n\n\tif (maxbits < 64)\n\t\tmask = (1ULL << maxbits) - 1ULL;\n\n\t/* Ensure distribution is more or less flat */\n\tget_random_bytes(&new->id, sizeof(new->id));\n\tnew->id &= mask;\n\tif (new->id < minval)\n\t\tnew->id += minval;\nretry:\n\tp = &root->rb_node;\n\tparent = NULL;\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\tpos = rb_entry(parent, struct nfs_unique_id, rb_node);\n\n\t\tif (new->id < pos->id)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new->id > pos->id)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tgoto id_exists;\n\t}\n\trb_link_node(&new->rb_node, parent, p);\n\trb_insert_color(&new->rb_node, root);\n\treturn;\nid_exists:\n\tfor (;;) {\n\t\tnew->id++;\n\t\tif (new->id < minval || (new->id & mask) != new->id) {\n\t\t\tnew->id = minval;\n\t\t\tbreak;\n\t\t}\n\t\tparent = rb_next(parent);\n\t\tif (parent == NULL)\n\t\t\tbreak;\n\t\tpos = rb_entry(parent, struct nfs_unique_id, rb_node);\n\t\tif (new->id < pos->id)\n\t\t\tbreak;\n\t}\n\tgoto retry;\n}\n\nstatic void nfs_free_unique_id(struct rb_root *root, struct nfs_unique_id *id)\n{\n\trb_erase(&id->rb_node, root);\n}\n\nstatic struct nfs4_state_owner *\nnfs4_find_state_owner(struct nfs_server *server, struct rpc_cred *cred)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct rb_node **p = &clp->cl_state_owners.rb_node,\n\t\t       *parent = NULL;\n\tstruct nfs4_state_owner *sp, *res = NULL;\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\tsp = rb_entry(parent, struct nfs4_state_owner, so_client_node);\n\n\t\tif (server < sp->so_server) {\n\t\t\tp = &parent->rb_left;\n\t\t\tcontinue;\n\t\t}\n\t\tif (server > sp->so_server) {\n\t\t\tp = &parent->rb_right;\n\t\t\tcontinue;\n\t\t}\n\t\tif (cred < sp->so_cred)\n\t\t\tp = &parent->rb_left;\n\t\telse if (cred > sp->so_cred)\n\t\t\tp = &parent->rb_right;\n\t\telse {\n\t\t\tatomic_inc(&sp->so_count);\n\t\t\tres = sp;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic struct nfs4_state_owner *\nnfs4_insert_state_owner(struct nfs_client *clp, struct nfs4_state_owner *new)\n{\n\tstruct rb_node **p = &clp->cl_state_owners.rb_node,\n\t\t       *parent = NULL;\n\tstruct nfs4_state_owner *sp;\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\tsp = rb_entry(parent, struct nfs4_state_owner, so_client_node);\n\n\t\tif (new->so_server < sp->so_server) {\n\t\t\tp = &parent->rb_left;\n\t\t\tcontinue;\n\t\t}\n\t\tif (new->so_server > sp->so_server) {\n\t\t\tp = &parent->rb_right;\n\t\t\tcontinue;\n\t\t}\n\t\tif (new->so_cred < sp->so_cred)\n\t\t\tp = &parent->rb_left;\n\t\telse if (new->so_cred > sp->so_cred)\n\t\t\tp = &parent->rb_right;\n\t\telse {\n\t\t\tatomic_inc(&sp->so_count);\n\t\t\treturn sp;\n\t\t}\n\t}\n\tnfs_alloc_unique_id(&clp->cl_openowner_id, &new->so_owner_id, 1, 64);\n\trb_link_node(&new->so_client_node, parent, p);\n\trb_insert_color(&new->so_client_node, &clp->cl_state_owners);\n\treturn new;\n}\n\nstatic void\nnfs4_remove_state_owner(struct nfs_client *clp, struct nfs4_state_owner *sp)\n{\n\tif (!RB_EMPTY_NODE(&sp->so_client_node))\n\t\trb_erase(&sp->so_client_node, &clp->cl_state_owners);\n\tnfs_free_unique_id(&clp->cl_openowner_id, &sp->so_owner_id);\n}\n\n/*\n * nfs4_alloc_state_owner(): this is called on the OPEN or CREATE path to\n * create a new state_owner.\n *\n */\nstatic struct nfs4_state_owner *\nnfs4_alloc_state_owner(void)\n{\n\tstruct nfs4_state_owner *sp;\n\n\tsp = kzalloc(sizeof(*sp),GFP_KERNEL);\n\tif (!sp)\n\t\treturn NULL;\n\tspin_lock_init(&sp->so_lock);\n\tINIT_LIST_HEAD(&sp->so_states);\n\tINIT_LIST_HEAD(&sp->so_delegations);\n\trpc_init_wait_queue(&sp->so_sequence.wait, \"Seqid_waitqueue\");\n\tsp->so_seqid.sequence = &sp->so_sequence;\n\tspin_lock_init(&sp->so_sequence.lock);\n\tINIT_LIST_HEAD(&sp->so_sequence.list);\n\tatomic_set(&sp->so_count, 1);\n\treturn sp;\n}\n\nstatic void\nnfs4_drop_state_owner(struct nfs4_state_owner *sp)\n{\n\tif (!RB_EMPTY_NODE(&sp->so_client_node)) {\n\t\tstruct nfs_client *clp = sp->so_client;\n\n\t\tspin_lock(&clp->cl_lock);\n\t\trb_erase(&sp->so_client_node, &clp->cl_state_owners);\n\t\tRB_CLEAR_NODE(&sp->so_client_node);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n}\n\nstruct nfs4_state_owner *nfs4_get_state_owner(struct nfs_server *server, struct rpc_cred *cred)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_state_owner *sp, *new;\n\n\tspin_lock(&clp->cl_lock);\n\tsp = nfs4_find_state_owner(server, cred);\n\tspin_unlock(&clp->cl_lock);\n\tif (sp != NULL)\n\t\treturn sp;\n\tnew = nfs4_alloc_state_owner();\n\tif (new == NULL)\n\t\treturn NULL;\n\tnew->so_client = clp;\n\tnew->so_server = server;\n\tnew->so_cred = cred;\n\tspin_lock(&clp->cl_lock);\n\tsp = nfs4_insert_state_owner(clp, new);\n\tspin_unlock(&clp->cl_lock);\n\tif (sp == new)\n\t\tget_rpccred(cred);\n\telse {\n\t\trpc_destroy_wait_queue(&new->so_sequence.wait);\n\t\tkfree(new);\n\t}\n\treturn sp;\n}\n\nvoid nfs4_put_state_owner(struct nfs4_state_owner *sp)\n{\n\tstruct nfs_client *clp = sp->so_client;\n\tstruct rpc_cred *cred = sp->so_cred;\n\n\tif (!atomic_dec_and_lock(&sp->so_count, &clp->cl_lock))\n\t\treturn;\n\tnfs4_remove_state_owner(clp, sp);\n\tspin_unlock(&clp->cl_lock);\n\trpc_destroy_wait_queue(&sp->so_sequence.wait);\n\tput_rpccred(cred);\n\tkfree(sp);\n}\n\nstatic struct nfs4_state *\nnfs4_alloc_open_state(void)\n{\n\tstruct nfs4_state *state;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\tatomic_set(&state->count, 1);\n\tINIT_LIST_HEAD(&state->lock_states);\n\tspin_lock_init(&state->state_lock);\n\tseqlock_init(&state->seqlock);\n\treturn state;\n}\n\nvoid\nnfs4_state_set_mode_locked(struct nfs4_state *state, fmode_t fmode)\n{\n\tif (state->state == fmode)\n\t\treturn;\n\t/* NB! List reordering - see the reclaim code for why.  */\n\tif ((fmode & FMODE_WRITE) != (state->state & FMODE_WRITE)) {\n\t\tif (fmode & FMODE_WRITE)\n\t\t\tlist_move(&state->open_states, &state->owner->so_states);\n\t\telse\n\t\t\tlist_move_tail(&state->open_states, &state->owner->so_states);\n\t}\n\tstate->state = fmode;\n}\n\nstatic struct nfs4_state *\n__nfs4_find_state_byowner(struct inode *inode, struct nfs4_state_owner *owner)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs4_state *state;\n\n\tlist_for_each_entry(state, &nfsi->open_states, inode_states) {\n\t\tif (state->owner != owner)\n\t\t\tcontinue;\n\t\tif (atomic_inc_not_zero(&state->count))\n\t\t\treturn state;\n\t}\n\treturn NULL;\n}\n\nstatic void\nnfs4_free_open_state(struct nfs4_state *state)\n{\n\tkfree(state);\n}\n\nstruct nfs4_state *\nnfs4_get_open_state(struct inode *inode, struct nfs4_state_owner *owner)\n{\n\tstruct nfs4_state *state, *new;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tspin_lock(&inode->i_lock);\n\tstate = __nfs4_find_state_byowner(inode, owner);\n\tspin_unlock(&inode->i_lock);\n\tif (state)\n\t\tgoto out;\n\tnew = nfs4_alloc_open_state();\n\tspin_lock(&owner->so_lock);\n\tspin_lock(&inode->i_lock);\n\tstate = __nfs4_find_state_byowner(inode, owner);\n\tif (state == NULL && new != NULL) {\n\t\tstate = new;\n\t\tstate->owner = owner;\n\t\tatomic_inc(&owner->so_count);\n\t\tlist_add(&state->inode_states, &nfsi->open_states);\n\t\tstate->inode = igrab(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\t/* Note: The reclaim code dictates that we add stateless\n\t\t * and read-only stateids to the end of the list */\n\t\tlist_add_tail(&state->open_states, &owner->so_states);\n\t\tspin_unlock(&owner->so_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\tspin_unlock(&owner->so_lock);\n\t\tif (new)\n\t\t\tnfs4_free_open_state(new);\n\t}\nout:\n\treturn state;\n}\n\nvoid nfs4_put_open_state(struct nfs4_state *state)\n{\n\tstruct inode *inode = state->inode;\n\tstruct nfs4_state_owner *owner = state->owner;\n\n\tif (!atomic_dec_and_lock(&state->count, &owner->so_lock))\n\t\treturn;\n\tspin_lock(&inode->i_lock);\n\tlist_del(&state->inode_states);\n\tlist_del(&state->open_states);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&owner->so_lock);\n\tiput(inode);\n\tnfs4_free_open_state(state);\n\tnfs4_put_state_owner(owner);\n}\n\n/*\n * Close the current file.\n */\nstatic void __nfs4_close(struct path *path, struct nfs4_state *state, fmode_t fmode, int wait)\n{\n\tstruct nfs4_state_owner *owner = state->owner;\n\tint call_close = 0;\n\tfmode_t newstate;\n\n\tatomic_inc(&owner->so_count);\n\t/* Protect against nfs4_find_state() */\n\tspin_lock(&owner->so_lock);\n\tswitch (fmode & (FMODE_READ | FMODE_WRITE)) {\n\t\tcase FMODE_READ:\n\t\t\tstate->n_rdonly--;\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tstate->n_wronly--;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tstate->n_rdwr--;\n\t}\n\tnewstate = FMODE_READ|FMODE_WRITE;\n\tif (state->n_rdwr == 0) {\n\t\tif (state->n_rdonly == 0) {\n\t\t\tnewstate &= ~FMODE_READ;\n\t\t\tcall_close |= test_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tcall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (state->n_wronly == 0) {\n\t\t\tnewstate &= ~FMODE_WRITE;\n\t\t\tcall_close |= test_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tcall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (newstate == 0)\n\t\t\tclear_bit(NFS_DELEGATED_STATE, &state->flags);\n\t}\n\tnfs4_state_set_mode_locked(state, newstate);\n\tspin_unlock(&owner->so_lock);\n\n\tif (!call_close) {\n\t\tnfs4_put_open_state(state);\n\t\tnfs4_put_state_owner(owner);\n\t} else\n\t\tnfs4_do_close(path, state, wait);\n}\n\nvoid nfs4_close_state(struct path *path, struct nfs4_state *state, fmode_t fmode)\n{\n\t__nfs4_close(path, state, fmode, 0);\n}\n\nvoid nfs4_close_sync(struct path *path, struct nfs4_state *state, fmode_t fmode)\n{\n\t__nfs4_close(path, state, fmode, 1);\n}\n\n/*\n * Search the state->lock_states for an existing lock_owner\n * that is compatible with current->files\n */\nstatic struct nfs4_lock_state *\n__nfs4_find_lock_state(struct nfs4_state *state, fl_owner_t fl_owner)\n{\n\tstruct nfs4_lock_state *pos;\n\tlist_for_each_entry(pos, &state->lock_states, ls_locks) {\n\t\tif (pos->ls_owner != fl_owner)\n\t\t\tcontinue;\n\t\tatomic_inc(&pos->ls_count);\n\t\treturn pos;\n\t}\n\treturn NULL;\n}\n\n/*\n * Return a compatible lock_state. If no initialized lock_state structure\n * exists, return an uninitialized one.\n *\n */\nstatic struct nfs4_lock_state *nfs4_alloc_lock_state(struct nfs4_state *state, fl_owner_t fl_owner)\n{\n\tstruct nfs4_lock_state *lsp;\n\tstruct nfs_client *clp = state->owner->so_client;\n\n\tlsp = kzalloc(sizeof(*lsp), GFP_KERNEL);\n\tif (lsp == NULL)\n\t\treturn NULL;\n\trpc_init_wait_queue(&lsp->ls_sequence.wait, \"lock_seqid_waitqueue\");\n\tspin_lock_init(&lsp->ls_sequence.lock);\n\tINIT_LIST_HEAD(&lsp->ls_sequence.list);\n\tlsp->ls_seqid.sequence = &lsp->ls_sequence;\n\tatomic_set(&lsp->ls_count, 1);\n\tlsp->ls_owner = fl_owner;\n\tspin_lock(&clp->cl_lock);\n\tnfs_alloc_unique_id(&clp->cl_lockowner_id, &lsp->ls_id, 1, 64);\n\tspin_unlock(&clp->cl_lock);\n\tINIT_LIST_HEAD(&lsp->ls_locks);\n\treturn lsp;\n}\n\nstatic void nfs4_free_lock_state(struct nfs4_lock_state *lsp)\n{\n\tstruct nfs_client *clp = lsp->ls_state->owner->so_client;\n\n\tspin_lock(&clp->cl_lock);\n\tnfs_free_unique_id(&clp->cl_lockowner_id, &lsp->ls_id);\n\tspin_unlock(&clp->cl_lock);\n\trpc_destroy_wait_queue(&lsp->ls_sequence.wait);\n\tkfree(lsp);\n}\n\n/*\n * Return a compatible lock_state. If no initialized lock_state structure\n * exists, return an uninitialized one.\n *\n */\nstatic struct nfs4_lock_state *nfs4_get_lock_state(struct nfs4_state *state, fl_owner_t owner)\n{\n\tstruct nfs4_lock_state *lsp, *new = NULL;\n\t\n\tfor(;;) {\n\t\tspin_lock(&state->state_lock);\n\t\tlsp = __nfs4_find_lock_state(state, owner);\n\t\tif (lsp != NULL)\n\t\t\tbreak;\n\t\tif (new != NULL) {\n\t\t\tnew->ls_state = state;\n\t\t\tlist_add(&new->ls_locks, &state->lock_states);\n\t\t\tset_bit(LK_STATE_IN_USE, &state->flags);\n\t\t\tlsp = new;\n\t\t\tnew = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&state->state_lock);\n\t\tnew = nfs4_alloc_lock_state(state, owner);\n\t\tif (new == NULL)\n\t\t\treturn NULL;\n\t}\n\tspin_unlock(&state->state_lock);\n\tif (new != NULL)\n\t\tnfs4_free_lock_state(new);\n\treturn lsp;\n}\n\n/*\n * Release reference to lock_state, and free it if we see that\n * it is no longer in use\n */\nvoid nfs4_put_lock_state(struct nfs4_lock_state *lsp)\n{\n\tstruct nfs4_state *state;\n\n\tif (lsp == NULL)\n\t\treturn;\n\tstate = lsp->ls_state;\n\tif (!atomic_dec_and_lock(&lsp->ls_count, &state->state_lock))\n\t\treturn;\n\tlist_del(&lsp->ls_locks);\n\tif (list_empty(&state->lock_states))\n\t\tclear_bit(LK_STATE_IN_USE, &state->flags);\n\tspin_unlock(&state->state_lock);\n\tnfs4_free_lock_state(lsp);\n}\n\nstatic void nfs4_fl_copy_lock(struct file_lock *dst, struct file_lock *src)\n{\n\tstruct nfs4_lock_state *lsp = src->fl_u.nfs4_fl.owner;\n\n\tdst->fl_u.nfs4_fl.owner = lsp;\n\tatomic_inc(&lsp->ls_count);\n}\n\nstatic void nfs4_fl_release_lock(struct file_lock *fl)\n{\n\tnfs4_put_lock_state(fl->fl_u.nfs4_fl.owner);\n}\n\nstatic struct file_lock_operations nfs4_fl_lock_ops = {\n\t.fl_copy_lock = nfs4_fl_copy_lock,\n\t.fl_release_private = nfs4_fl_release_lock,\n};\n\nint nfs4_set_lock_state(struct nfs4_state *state, struct file_lock *fl)\n{\n\tstruct nfs4_lock_state *lsp;\n\n\tif (fl->fl_ops != NULL)\n\t\treturn 0;\n\tlsp = nfs4_get_lock_state(state, fl->fl_owner);\n\tif (lsp == NULL)\n\t\treturn -ENOMEM;\n\tfl->fl_u.nfs4_fl.owner = lsp;\n\tfl->fl_ops = &nfs4_fl_lock_ops;\n\treturn 0;\n}\n\n/*\n * Byte-range lock aware utility to initialize the stateid of read/write\n * requests.\n */\nvoid nfs4_copy_stateid(nfs4_stateid *dst, struct nfs4_state *state, fl_owner_t fl_owner)\n{\n\tstruct nfs4_lock_state *lsp;\n\tint seq;\n\n\tdo {\n\t\tseq = read_seqbegin(&state->seqlock);\n\t\tmemcpy(dst, &state->stateid, sizeof(*dst));\n\t} while (read_seqretry(&state->seqlock, seq));\n\tif (test_bit(LK_STATE_IN_USE, &state->flags) == 0)\n\t\treturn;\n\n\tspin_lock(&state->state_lock);\n\tlsp = __nfs4_find_lock_state(state, fl_owner);\n\tif (lsp != NULL && (lsp->ls_flags & NFS_LOCK_INITIALIZED) != 0)\n\t\tmemcpy(dst, &lsp->ls_stateid, sizeof(*dst));\n\tspin_unlock(&state->state_lock);\n\tnfs4_put_lock_state(lsp);\n}\n\nstruct nfs_seqid *nfs_alloc_seqid(struct nfs_seqid_counter *counter)\n{\n\tstruct nfs_seqid *new;\n\n\tnew = kmalloc(sizeof(*new), GFP_KERNEL);\n\tif (new != NULL) {\n\t\tnew->sequence = counter;\n\t\tINIT_LIST_HEAD(&new->list);\n\t}\n\treturn new;\n}\n\nvoid nfs_free_seqid(struct nfs_seqid *seqid)\n{\n\tif (!list_empty(&seqid->list)) {\n\t\tstruct rpc_sequence *sequence = seqid->sequence->sequence;\n\n\t\tspin_lock(&sequence->lock);\n\t\tlist_del(&seqid->list);\n\t\tspin_unlock(&sequence->lock);\n\t\trpc_wake_up(&sequence->wait);\n\t}\n\tkfree(seqid);\n}\n\n/*\n * Increment the seqid if the OPEN/OPEN_DOWNGRADE/CLOSE succeeded, or\n * failed with a seqid incrementing error -\n * see comments nfs_fs.h:seqid_mutating_error()\n */\nstatic void nfs_increment_seqid(int status, struct nfs_seqid *seqid)\n{\n\tBUG_ON(list_first_entry(&seqid->sequence->sequence->list, struct nfs_seqid, list) != seqid);\n\tswitch (status) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -NFS4ERR_BAD_SEQID:\n\t\t\tif (seqid->sequence->flags & NFS_SEQID_CONFIRMED)\n\t\t\t\treturn;\n\t\t\tprintk(KERN_WARNING \"NFS: v4 server returned a bad\"\n\t\t\t\t\t\" sequence-id error on an\"\n\t\t\t\t\t\" unconfirmed sequence %p!\\n\",\n\t\t\t\t\tseqid->sequence);\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_BADXDR:\n\t\tcase -NFS4ERR_RESOURCE:\n\t\tcase -NFS4ERR_NOFILEHANDLE:\n\t\t\t/* Non-seqid mutating errors */\n\t\t\treturn;\n\t};\n\t/*\n\t * Note: no locking needed as we are guaranteed to be first\n\t * on the sequence list\n\t */\n\tseqid->sequence->counter++;\n}\n\nvoid nfs_increment_open_seqid(int status, struct nfs_seqid *seqid)\n{\n\tif (status == -NFS4ERR_BAD_SEQID) {\n\t\tstruct nfs4_state_owner *sp = container_of(seqid->sequence,\n\t\t\t\tstruct nfs4_state_owner, so_seqid);\n\t\tnfs4_drop_state_owner(sp);\n\t}\n\tnfs_increment_seqid(status, seqid);\n}\n\n/*\n * Increment the seqid if the LOCK/LOCKU succeeded, or\n * failed with a seqid incrementing error -\n * see comments nfs_fs.h:seqid_mutating_error()\n */\nvoid nfs_increment_lock_seqid(int status, struct nfs_seqid *seqid)\n{\n\tnfs_increment_seqid(status, seqid);\n}\n\nint nfs_wait_on_sequence(struct nfs_seqid *seqid, struct rpc_task *task)\n{\n\tstruct rpc_sequence *sequence = seqid->sequence->sequence;\n\tint status = 0;\n\n\tspin_lock(&sequence->lock);\n\tif (list_empty(&seqid->list))\n\t\tlist_add_tail(&seqid->list, &sequence->list);\n\tif (list_first_entry(&sequence->list, struct nfs_seqid, list) == seqid)\n\t\tgoto unlock;\n\trpc_sleep_on(&sequence->wait, task, NULL);\n\tstatus = -EAGAIN;\nunlock:\n\tspin_unlock(&sequence->lock);\n\treturn status;\n}\n\nstatic int nfs4_run_state_manager(void *);\n\nstatic void nfs4_clear_state_manager_bit(struct nfs_client *clp)\n{\n\tsmp_mb__before_clear_bit();\n\tclear_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state);\n\tsmp_mb__after_clear_bit();\n\twake_up_bit(&clp->cl_state, NFS4CLNT_MANAGER_RUNNING);\n\trpc_wake_up(&clp->cl_rpcwaitq);\n}\n\n/*\n * Schedule the nfs_client asynchronous state management routine\n */\nvoid nfs4_schedule_state_manager(struct nfs_client *clp)\n{\n\tstruct task_struct *task;\n\n\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\treturn;\n\t__module_get(THIS_MODULE);\n\tatomic_inc(&clp->cl_count);\n\ttask = kthread_run(nfs4_run_state_manager, clp, \"%s-manager\",\n\t\t\t\trpc_peeraddr2str(clp->cl_rpcclient,\n\t\t\t\t\t\t\tRPC_DISPLAY_ADDR));\n\tif (!IS_ERR(task))\n\t\treturn;\n\tnfs4_clear_state_manager_bit(clp);\n\tnfs_put_client(clp);\n\tmodule_put(THIS_MODULE);\n}\n\n/*\n * Schedule a state recovery attempt\n */\nvoid nfs4_schedule_state_recovery(struct nfs_client *clp)\n{\n\tif (!clp)\n\t\treturn;\n\tif (!test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state))\n\t\tset_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state);\n\tnfs4_schedule_state_manager(clp);\n}\n\nstatic int nfs4_state_mark_reclaim_reboot(struct nfs_client *clp, struct nfs4_state *state)\n{\n\n\tset_bit(NFS_STATE_RECLAIM_REBOOT, &state->flags);\n\t/* Don't recover state that expired before the reboot */\n\tif (test_bit(NFS_STATE_RECLAIM_NOGRACE, &state->flags)) {\n\t\tclear_bit(NFS_STATE_RECLAIM_REBOOT, &state->flags);\n\t\treturn 0;\n\t}\n\tset_bit(NFS_OWNER_RECLAIM_REBOOT, &state->owner->so_flags);\n\tset_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state);\n\treturn 1;\n}\n\nint nfs4_state_mark_reclaim_nograce(struct nfs_client *clp, struct nfs4_state *state)\n{\n\tset_bit(NFS_STATE_RECLAIM_NOGRACE, &state->flags);\n\tclear_bit(NFS_STATE_RECLAIM_REBOOT, &state->flags);\n\tset_bit(NFS_OWNER_RECLAIM_NOGRACE, &state->owner->so_flags);\n\tset_bit(NFS4CLNT_RECLAIM_NOGRACE, &clp->cl_state);\n\treturn 1;\n}\n\nstatic int nfs4_reclaim_locks(struct nfs4_state *state, const struct nfs4_state_recovery_ops *ops)\n{\n\tstruct inode *inode = state->inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct file_lock *fl;\n\tint status = 0;\n\n\tdown_write(&nfsi->rwsem);\n\tfor (fl = inode->i_flock; fl != NULL; fl = fl->fl_next) {\n\t\tif (!(fl->fl_flags & (FL_POSIX|FL_FLOCK)))\n\t\t\tcontinue;\n\t\tif (nfs_file_open_context(fl->fl_file)->state != state)\n\t\t\tcontinue;\n\t\tstatus = ops->recover_lock(state, fl);\n\t\tif (status >= 0)\n\t\t\tcontinue;\n\t\tswitch (status) {\n\t\t\tdefault:\n\t\t\t\tprintk(KERN_ERR \"%s: unhandled error %d. Zeroing state\\n\",\n\t\t\t\t\t\t__func__, status);\n\t\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tcase -NFS4ERR_NO_GRACE:\n\t\t\tcase -NFS4ERR_RECLAIM_BAD:\n\t\t\tcase -NFS4ERR_RECLAIM_CONFLICT:\n\t\t\t\t/* kill_proc(fl->fl_pid, SIGLOST, 1); */\n\t\t\t\tbreak;\n\t\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\t\tgoto out_err;\n\t\t}\n\t}\n\tup_write(&nfsi->rwsem);\n\treturn 0;\nout_err:\n\tup_write(&nfsi->rwsem);\n\treturn status;\n}\n\nstatic int nfs4_reclaim_open_state(struct nfs4_state_owner *sp, const struct nfs4_state_recovery_ops *ops)\n{\n\tstruct nfs4_state *state;\n\tstruct nfs4_lock_state *lock;\n\tint status = 0;\n\n\t/* Note: we rely on the sp->so_states list being ordered \n\t * so that we always reclaim open(O_RDWR) and/or open(O_WRITE)\n\t * states first.\n\t * This is needed to ensure that the server won't give us any\n\t * read delegations that we have to return if, say, we are\n\t * recovering after a network partition or a reboot from a\n\t * server that doesn't support a grace period.\n\t */\nrestart:\n\tspin_lock(&sp->so_lock);\n\tlist_for_each_entry(state, &sp->so_states, open_states) {\n\t\tif (!test_and_clear_bit(ops->state_flag_bit, &state->flags))\n\t\t\tcontinue;\n\t\tif (state->state == 0)\n\t\t\tcontinue;\n\t\tatomic_inc(&state->count);\n\t\tspin_unlock(&sp->so_lock);\n\t\tstatus = ops->recover_open(sp, state);\n\t\tif (status >= 0) {\n\t\t\tstatus = nfs4_reclaim_locks(state, ops);\n\t\t\tif (status >= 0) {\n\t\t\t\tlist_for_each_entry(lock, &state->lock_states, ls_locks) {\n\t\t\t\t\tif (!(lock->ls_flags & NFS_LOCK_INITIALIZED))\n\t\t\t\t\t\tprintk(\"%s: Lock reclaim failed!\\n\",\n\t\t\t\t\t\t\t__func__);\n\t\t\t\t}\n\t\t\t\tnfs4_put_open_state(state);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t}\n\t\tswitch (status) {\n\t\t\tdefault:\n\t\t\t\tprintk(KERN_ERR \"%s: unhandled error %d. Zeroing state\\n\",\n\t\t\t\t\t\t__func__, status);\n\t\t\tcase -ENOENT:\n\t\t\tcase -ESTALE:\n\t\t\t\t/*\n\t\t\t\t * Open state on this file cannot be recovered\n\t\t\t\t * All we can do is revert to using the zero stateid.\n\t\t\t\t */\n\t\t\t\tmemset(state->stateid.data, 0,\n\t\t\t\t\tsizeof(state->stateid.data));\n\t\t\t\t/* Mark the file as being 'closed' */\n\t\t\t\tstate->state = 0;\n\t\t\t\tbreak;\n\t\t\tcase -NFS4ERR_RECLAIM_BAD:\n\t\t\tcase -NFS4ERR_RECLAIM_CONFLICT:\n\t\t\t\tnfs4_state_mark_reclaim_nograce(sp->so_client, state);\n\t\t\t\tbreak;\n\t\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tcase -NFS4ERR_NO_GRACE:\n\t\t\t\tnfs4_state_mark_reclaim_nograce(sp->so_client, state);\n\t\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\t\tgoto out_err;\n\t\t}\n\t\tnfs4_put_open_state(state);\n\t\tgoto restart;\n\t}\n\tspin_unlock(&sp->so_lock);\n\treturn 0;\nout_err:\n\tnfs4_put_open_state(state);\n\treturn status;\n}\n\nstatic void nfs4_clear_open_state(struct nfs4_state *state)\n{\n\tstruct nfs4_lock_state *lock;\n\n\tclear_bit(NFS_DELEGATED_STATE, &state->flags);\n\tclear_bit(NFS_O_RDONLY_STATE, &state->flags);\n\tclear_bit(NFS_O_WRONLY_STATE, &state->flags);\n\tclear_bit(NFS_O_RDWR_STATE, &state->flags);\n\tlist_for_each_entry(lock, &state->lock_states, ls_locks) {\n\t\tlock->ls_seqid.flags = 0;\n\t\tlock->ls_flags &= ~NFS_LOCK_INITIALIZED;\n\t}\n}\n\nstatic void nfs4_state_mark_reclaim_helper(struct nfs_client *clp, int (*mark_reclaim)(struct nfs_client *clp, struct nfs4_state *state))\n{\n\tstruct nfs4_state_owner *sp;\n\tstruct rb_node *pos;\n\tstruct nfs4_state *state;\n\n\t/* Reset all sequence ids to zero */\n\tfor (pos = rb_first(&clp->cl_state_owners); pos != NULL; pos = rb_next(pos)) {\n\t\tsp = rb_entry(pos, struct nfs4_state_owner, so_client_node);\n\t\tsp->so_seqid.flags = 0;\n\t\tspin_lock(&sp->so_lock);\n\t\tlist_for_each_entry(state, &sp->so_states, open_states) {\n\t\t\tif (mark_reclaim(clp, state))\n\t\t\t\tnfs4_clear_open_state(state);\n\t\t}\n\t\tspin_unlock(&sp->so_lock);\n\t}\n}\n\nstatic void nfs4_state_start_reclaim_reboot(struct nfs_client *clp)\n{\n\t/* Mark all delegations for reclaim */\n\tnfs_delegation_mark_reclaim(clp);\n\tnfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_reboot);\n}\n\nstatic void nfs4_state_end_reclaim_reboot(struct nfs_client *clp)\n{\n\tstruct nfs4_state_owner *sp;\n\tstruct rb_node *pos;\n\tstruct nfs4_state *state;\n\n\tif (!test_and_clear_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state))\n\t\treturn;\n\n\tfor (pos = rb_first(&clp->cl_state_owners); pos != NULL; pos = rb_next(pos)) {\n\t\tsp = rb_entry(pos, struct nfs4_state_owner, so_client_node);\n\t\tspin_lock(&sp->so_lock);\n\t\tlist_for_each_entry(state, &sp->so_states, open_states) {\n\t\t\tif (!test_and_clear_bit(NFS_STATE_RECLAIM_REBOOT, &state->flags))\n\t\t\t\tcontinue;\n\t\t\tnfs4_state_mark_reclaim_nograce(clp, state);\n\t\t}\n\t\tspin_unlock(&sp->so_lock);\n\t}\n\n\tnfs_delegation_reap_unclaimed(clp);\n}\n\nstatic void nfs_delegation_clear_all(struct nfs_client *clp)\n{\n\tnfs_delegation_mark_reclaim(clp);\n\tnfs_delegation_reap_unclaimed(clp);\n}\n\nstatic void nfs4_state_start_reclaim_nograce(struct nfs_client *clp)\n{\n\tnfs_delegation_clear_all(clp);\n\tnfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_nograce);\n}\n\nstatic void nfs4_state_end_reclaim_nograce(struct nfs_client *clp)\n{\n\tclear_bit(NFS4CLNT_RECLAIM_NOGRACE, &clp->cl_state);\n}\n\nstatic void nfs4_recovery_handle_error(struct nfs_client *clp, int error)\n{\n\tswitch (error) {\n\t\tcase -NFS4ERR_CB_PATH_DOWN:\n\t\t\tnfs_handle_cb_pathdown(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tcase -NFS4ERR_LEASE_MOVED:\n\t\t\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\t\t\tnfs4_state_start_reclaim_reboot(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\t\t\tnfs4_state_start_reclaim_nograce(clp);\n\t}\n}\n\nstatic int nfs4_do_reclaim(struct nfs_client *clp, const struct nfs4_state_recovery_ops *ops)\n{\n\tstruct rb_node *pos;\n\tint status = 0;\n\nrestart:\n\tspin_lock(&clp->cl_lock);\n\tfor (pos = rb_first(&clp->cl_state_owners); pos != NULL; pos = rb_next(pos)) {\n\t\tstruct nfs4_state_owner *sp = rb_entry(pos, struct nfs4_state_owner, so_client_node);\n\t\tif (!test_and_clear_bit(ops->owner_flag_bit, &sp->so_flags))\n\t\t\tcontinue;\n\t\tatomic_inc(&sp->so_count);\n\t\tspin_unlock(&clp->cl_lock);\n\t\tstatus = nfs4_reclaim_open_state(sp, ops);\n\t\tif (status < 0) {\n\t\t\tset_bit(ops->owner_flag_bit, &sp->so_flags);\n\t\t\tnfs4_put_state_owner(sp);\n\t\t\tnfs4_recovery_handle_error(clp, status);\n\t\t\treturn status;\n\t\t}\n\t\tnfs4_put_state_owner(sp);\n\t\tgoto restart;\n\t}\n\tspin_unlock(&clp->cl_lock);\n\treturn status;\n}\n\nstatic int nfs4_check_lease(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\tint status = -NFS4ERR_EXPIRED;\n\n\t/* Is the client already known to have an expired lease? */\n\tif (test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state))\n\t\treturn 0;\n\tcred = nfs4_get_renew_cred(clp);\n\tif (cred == NULL) {\n\t\tcred = nfs4_get_setclientid_cred(clp);\n\t\tif (cred == NULL)\n\t\t\tgoto out;\n\t}\n\tstatus = nfs4_proc_renew(clp, cred);\n\tput_rpccred(cred);\nout:\n\tnfs4_recovery_handle_error(clp, status);\n\treturn status;\n}\n\nstatic int nfs4_reclaim_lease(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\tint status = -ENOENT;\n\n\tcred = nfs4_get_setclientid_cred(clp);\n\tif (cred != NULL) {\n\t\tstatus = nfs4_init_client(clp, cred);\n\t\tput_rpccred(cred);\n\t\t/* Handle case where the user hasn't set up machine creds */\n\t\tif (status == -EACCES && cred == clp->cl_machine_cred) {\n\t\t\tnfs4_clear_machine_cred(clp);\n\t\t\tstatus = -EAGAIN;\n\t\t}\n\t}\n\treturn status;\n}\n\nstatic void nfs4_state_manager(struct nfs_client *clp)\n{\n\tint status = 0;\n\n\t/* Ensure exclusive access to NFSv4 state */\n\tfor(;;) {\n\t\tif (test_and_clear_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state)) {\n\t\t\t/* We're going to have to re-establish a clientid */\n\t\t\tstatus = nfs4_reclaim_lease(clp);\n\t\t\tif (status) {\n\t\t\t\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\t\t\t\tif (status == -EAGAIN)\n\t\t\t\t\tcontinue;\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tclear_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state);\n\t\t}\n\n\t\tif (test_and_clear_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state)) {\n\t\t\tstatus = nfs4_check_lease(clp);\n\t\t\tif (status != 0)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* First recover reboot state... */\n\t\tif (test_and_clear_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state)) {\n\t\t\tstatus = nfs4_do_reclaim(clp, &nfs4_reboot_recovery_ops);\n\t\t\tif (status == -NFS4ERR_STALE_CLIENTID)\n\t\t\t\tcontinue;\n\t\t\tnfs4_state_end_reclaim_reboot(clp);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Now recover expired state... */\n\t\tif (test_and_clear_bit(NFS4CLNT_RECLAIM_NOGRACE, &clp->cl_state)) {\n\t\t\tstatus = nfs4_do_reclaim(clp, &nfs4_nograce_recovery_ops);\n\t\t\tif (status < 0) {\n\t\t\t\tset_bit(NFS4CLNT_RECLAIM_NOGRACE, &clp->cl_state);\n\t\t\t\tif (status == -NFS4ERR_STALE_CLIENTID)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (status == -NFS4ERR_EXPIRED)\n\t\t\t\t\tcontinue;\n\t\t\t\tgoto out_error;\n\t\t\t} else\n\t\t\t\tnfs4_state_end_reclaim_nograce(clp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (test_and_clear_bit(NFS4CLNT_DELEGRETURN, &clp->cl_state)) {\n\t\t\tnfs_client_return_marked_delegations(clp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnfs4_clear_state_manager_bit(clp);\n\t\t/* Did we race with an attempt to give us more work? */\n\t\tif (clp->cl_state == 0)\n\t\t\tbreak;\n\t\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\t\tbreak;\n\t}\n\treturn;\nout_error:\n\tprintk(KERN_WARNING \"Error: state manager failed on NFSv4 server %s\"\n\t\t\t\" with error %d\\n\", clp->cl_hostname, -status);\n\tif (test_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state))\n\t\tnfs4_state_end_reclaim_reboot(clp);\n\tnfs4_clear_state_manager_bit(clp);\n}\n\nstatic int nfs4_run_state_manager(void *ptr)\n{\n\tstruct nfs_client *clp = ptr;\n\n\tallow_signal(SIGKILL);\n\tnfs4_state_manager(clp);\n\tnfs_put_client(clp);\n\tmodule_put_and_exit(0);\n\treturn 0;\n}\n\n/*\n * Local variables:\n *  c-basic-offset: 8\n * End:\n */\n", "/*\n *  fs/nfs/nfs4xdr.c\n *\n *  Client-side XDR for NFSv4.\n *\n *  Copyright (c) 2002 The Regents of the University of Michigan.\n *  All rights reserved.\n *\n *  Kendrick Smith <kmsmith@umich.edu>\n *  Andy Adamson   <andros@umich.edu>\n * \n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions\n *  are met:\n *\n *  1. Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *  2. Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *  3. Neither the name of the University nor the names of its\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED\n *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n *  DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n *  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <linux/param.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/in.h>\n#include <linux/pagemap.h>\n#include <linux/proc_fs.h>\n#include <linux/kdev_t.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_idmap.h>\n#include \"nfs4_fs.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_XDR\n\n/* Mapping from NFS error code to \"errno\" error code. */\n#define errno_NFSERR_IO\t\tEIO\n\nstatic int nfs4_stat_to_errno(int);\n\n/* NFSv4 COMPOUND tags are only wanted for debugging purposes */\n#ifdef DEBUG\n#define NFS4_MAXTAGLEN\t\t20\n#else\n#define NFS4_MAXTAGLEN\t\t0\n#endif\n\n/* lock,open owner id: \n * we currently use size 2 (u64) out of (NFS4_OPAQUE_LIMIT  >> 2)\n */\n#define open_owner_id_maxsz\t(1 + 4)\n#define lock_owner_id_maxsz\t(1 + 4)\n#define decode_lockowner_maxsz\t(1 + XDR_QUADLEN(IDMAP_NAMESZ))\n#define compound_encode_hdr_maxsz\t(3 + (NFS4_MAXTAGLEN >> 2))\n#define compound_decode_hdr_maxsz\t(3 + (NFS4_MAXTAGLEN >> 2))\n#define op_encode_hdr_maxsz\t(1)\n#define op_decode_hdr_maxsz\t(2)\n#define encode_stateid_maxsz\t(XDR_QUADLEN(NFS4_STATEID_SIZE))\n#define decode_stateid_maxsz\t(XDR_QUADLEN(NFS4_STATEID_SIZE))\n#define encode_verifier_maxsz\t(XDR_QUADLEN(NFS4_VERIFIER_SIZE))\n#define decode_verifier_maxsz\t(XDR_QUADLEN(NFS4_VERIFIER_SIZE))\n#define encode_putfh_maxsz\t(op_encode_hdr_maxsz + 1 + \\\n\t\t\t\t(NFS4_FHSIZE >> 2))\n#define decode_putfh_maxsz\t(op_decode_hdr_maxsz)\n#define encode_putrootfh_maxsz\t(op_encode_hdr_maxsz)\n#define decode_putrootfh_maxsz\t(op_decode_hdr_maxsz)\n#define encode_getfh_maxsz      (op_encode_hdr_maxsz)\n#define decode_getfh_maxsz      (op_decode_hdr_maxsz + 1 + \\\n\t\t\t\t((3+NFS4_FHSIZE) >> 2))\n#define nfs4_fattr_bitmap_maxsz 3\n#define encode_getattr_maxsz    (op_encode_hdr_maxsz + nfs4_fattr_bitmap_maxsz)\n#define nfs4_name_maxsz\t\t(1 + ((3 + NFS4_MAXNAMLEN) >> 2))\n#define nfs4_path_maxsz\t\t(1 + ((3 + NFS4_MAXPATHLEN) >> 2))\n#define nfs4_owner_maxsz\t(1 + XDR_QUADLEN(IDMAP_NAMESZ))\n#define nfs4_group_maxsz\t(1 + XDR_QUADLEN(IDMAP_NAMESZ))\n/* This is based on getfattr, which uses the most attributes: */\n#define nfs4_fattr_value_maxsz\t(1 + (1 + 2 + 2 + 4 + 2 + 1 + 1 + 2 + 2 + \\\n\t\t\t\t3 + 3 + 3 + nfs4_owner_maxsz + nfs4_group_maxsz))\n#define nfs4_fattr_maxsz\t(nfs4_fattr_bitmap_maxsz + \\\n\t\t\t\tnfs4_fattr_value_maxsz)\n#define decode_getattr_maxsz    (op_decode_hdr_maxsz + nfs4_fattr_maxsz)\n#define encode_attrs_maxsz\t(nfs4_fattr_bitmap_maxsz + \\\n\t\t\t\t 1 + 2 + 1 + \\\n\t\t\t\tnfs4_owner_maxsz + \\\n\t\t\t\tnfs4_group_maxsz + \\\n\t\t\t\t4 + 4)\n#define encode_savefh_maxsz     (op_encode_hdr_maxsz)\n#define decode_savefh_maxsz     (op_decode_hdr_maxsz)\n#define encode_restorefh_maxsz  (op_encode_hdr_maxsz)\n#define decode_restorefh_maxsz  (op_decode_hdr_maxsz)\n#define encode_fsinfo_maxsz\t(encode_getattr_maxsz)\n#define decode_fsinfo_maxsz\t(op_decode_hdr_maxsz + 11)\n#define encode_renew_maxsz\t(op_encode_hdr_maxsz + 3)\n#define decode_renew_maxsz\t(op_decode_hdr_maxsz)\n#define encode_setclientid_maxsz \\\n\t\t\t\t(op_encode_hdr_maxsz + \\\n\t\t\t\tXDR_QUADLEN(NFS4_VERIFIER_SIZE) + \\\n\t\t\t\tXDR_QUADLEN(NFS4_SETCLIENTID_NAMELEN) + \\\n\t\t\t\t1 /* sc_prog */ + \\\n\t\t\t\tXDR_QUADLEN(RPCBIND_MAXNETIDLEN) + \\\n\t\t\t\tXDR_QUADLEN(RPCBIND_MAXUADDRLEN) + \\\n\t\t\t\t1) /* sc_cb_ident */\n#define decode_setclientid_maxsz \\\n\t\t\t\t(op_decode_hdr_maxsz + \\\n\t\t\t\t2 + \\\n\t\t\t\t1024) /* large value for CLID_INUSE */\n#define encode_setclientid_confirm_maxsz \\\n\t\t\t\t(op_encode_hdr_maxsz + \\\n\t\t\t\t3 + (NFS4_VERIFIER_SIZE >> 2))\n#define decode_setclientid_confirm_maxsz \\\n\t\t\t\t(op_decode_hdr_maxsz)\n#define encode_lookup_maxsz\t(op_encode_hdr_maxsz + nfs4_name_maxsz)\n#define decode_lookup_maxsz\t(op_decode_hdr_maxsz)\n#define encode_share_access_maxsz \\\n\t\t\t\t(2)\n#define encode_createmode_maxsz\t(1 + encode_attrs_maxsz)\n#define encode_opentype_maxsz\t(1 + encode_createmode_maxsz)\n#define encode_claim_null_maxsz\t(1 + nfs4_name_maxsz)\n#define encode_open_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t2 + encode_share_access_maxsz + 2 + \\\n\t\t\t\topen_owner_id_maxsz + \\\n\t\t\t\tencode_opentype_maxsz + \\\n\t\t\t\tencode_claim_null_maxsz)\n#define decode_ace_maxsz\t(3 + nfs4_owner_maxsz)\n#define decode_delegation_maxsz\t(1 + decode_stateid_maxsz + 1 + \\\n\t\t\t\tdecode_ace_maxsz)\n#define decode_change_info_maxsz\t(5)\n#define decode_open_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\tdecode_stateid_maxsz + \\\n\t\t\t\tdecode_change_info_maxsz + 1 + \\\n\t\t\t\tnfs4_fattr_bitmap_maxsz + \\\n\t\t\t\tdecode_delegation_maxsz)\n#define encode_open_confirm_maxsz \\\n\t\t\t\t(op_encode_hdr_maxsz + \\\n\t\t\t\t encode_stateid_maxsz + 1)\n#define decode_open_confirm_maxsz \\\n\t\t\t\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_stateid_maxsz)\n#define encode_open_downgrade_maxsz \\\n\t\t\t\t(op_encode_hdr_maxsz + \\\n\t\t\t\t encode_stateid_maxsz + 1 + \\\n\t\t\t\t encode_share_access_maxsz)\n#define decode_open_downgrade_maxsz \\\n\t\t\t\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_stateid_maxsz)\n#define encode_close_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t 1 + encode_stateid_maxsz)\n#define decode_close_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_stateid_maxsz)\n#define encode_setattr_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t encode_stateid_maxsz + \\\n\t\t\t\t encode_attrs_maxsz)\n#define decode_setattr_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t nfs4_fattr_bitmap_maxsz)\n#define encode_read_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t encode_stateid_maxsz + 3)\n#define decode_read_maxsz\t(op_decode_hdr_maxsz + 2)\n#define encode_readdir_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t 2 + encode_verifier_maxsz + 5)\n#define decode_readdir_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_verifier_maxsz)\n#define encode_readlink_maxsz\t(op_encode_hdr_maxsz)\n#define decode_readlink_maxsz\t(op_decode_hdr_maxsz + 1)\n#define encode_write_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t encode_stateid_maxsz + 4)\n#define decode_write_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t 2 + decode_verifier_maxsz)\n#define encode_commit_maxsz\t(op_encode_hdr_maxsz + 3)\n#define decode_commit_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_verifier_maxsz)\n#define encode_remove_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\tnfs4_name_maxsz)\n#define encode_rename_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t2 * nfs4_name_maxsz)\n#define decode_rename_maxsz\t(op_decode_hdr_maxsz + 5 + 5)\n#define encode_link_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\tnfs4_name_maxsz)\n#define decode_link_maxsz\t(op_decode_hdr_maxsz + 5)\n#define encode_lock_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t 7 + \\\n\t\t\t\t 1 + encode_stateid_maxsz + 8)\n#define decode_lock_denied_maxsz \\\n\t\t\t\t(8 + decode_lockowner_maxsz)\n#define decode_lock_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_lock_denied_maxsz)\n#define encode_lockt_maxsz\t(op_encode_hdr_maxsz + 12)\n#define decode_lockt_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_lock_denied_maxsz)\n#define encode_locku_maxsz\t(op_encode_hdr_maxsz + 3 + \\\n\t\t\t\t encode_stateid_maxsz + \\\n\t\t\t\t 4)\n#define decode_locku_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t decode_stateid_maxsz)\n#define encode_access_maxsz\t(op_encode_hdr_maxsz + 1)\n#define decode_access_maxsz\t(op_decode_hdr_maxsz + 2)\n#define encode_symlink_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t1 + nfs4_name_maxsz + \\\n\t\t\t\t1 + \\\n\t\t\t\tnfs4_fattr_maxsz)\n#define decode_symlink_maxsz\t(op_decode_hdr_maxsz + 8)\n#define encode_create_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t1 + 2 + nfs4_name_maxsz + \\\n\t\t\t\tencode_attrs_maxsz)\n#define decode_create_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\tdecode_change_info_maxsz + \\\n\t\t\t\tnfs4_fattr_bitmap_maxsz)\n#define encode_statfs_maxsz\t(encode_getattr_maxsz)\n#define decode_statfs_maxsz\t(decode_getattr_maxsz)\n#define encode_delegreturn_maxsz (op_encode_hdr_maxsz + 4)\n#define decode_delegreturn_maxsz (op_decode_hdr_maxsz)\n#define encode_getacl_maxsz\t(encode_getattr_maxsz)\n#define decode_getacl_maxsz\t(op_decode_hdr_maxsz + \\\n\t\t\t\t nfs4_fattr_bitmap_maxsz + 1)\n#define encode_setacl_maxsz\t(op_encode_hdr_maxsz + \\\n\t\t\t\t encode_stateid_maxsz + 3)\n#define decode_setacl_maxsz\t(decode_setattr_maxsz)\n#define encode_fs_locations_maxsz \\\n\t\t\t\t(encode_getattr_maxsz)\n#define decode_fs_locations_maxsz \\\n\t\t\t\t(0)\n#define NFS4_enc_compound_sz\t(1024)  /* XXX: large enough? */\n#define NFS4_dec_compound_sz\t(1024)  /* XXX: large enough? */\n#define NFS4_enc_read_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_read_maxsz)\n#define NFS4_dec_read_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_read_maxsz)\n#define NFS4_enc_readlink_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_readlink_maxsz)\n#define NFS4_dec_readlink_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_readlink_maxsz)\n#define NFS4_enc_readdir_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_readdir_maxsz)\n#define NFS4_dec_readdir_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_readdir_maxsz)\n#define NFS4_enc_write_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_write_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_write_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_write_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_commit_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_commit_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_commit_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_commit_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_open_sz        (compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_savefh_maxsz + \\\n\t\t\t\tencode_open_maxsz + \\\n\t\t\t\tencode_getfh_maxsz + \\\n\t\t\t\tencode_getattr_maxsz + \\\n\t\t\t\tencode_restorefh_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_open_sz        (compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_savefh_maxsz + \\\n\t\t\t\tdecode_open_maxsz + \\\n\t\t\t\tdecode_getfh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz + \\\n\t\t\t\tdecode_restorefh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_open_confirm_sz \\\n\t\t\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t encode_open_confirm_maxsz)\n#define NFS4_dec_open_confirm_sz \\\n\t\t\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t decode_open_confirm_maxsz)\n#define NFS4_enc_open_noattr_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\t\tencode_open_maxsz + \\\n\t\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_open_noattr_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\t\tdecode_open_maxsz + \\\n\t\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_open_downgrade_sz \\\n\t\t\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t encode_open_downgrade_maxsz + \\\n\t\t\t\t encode_getattr_maxsz)\n#define NFS4_dec_open_downgrade_sz \\\n\t\t\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t decode_open_downgrade_maxsz + \\\n\t\t\t\t decode_getattr_maxsz)\n#define NFS4_enc_close_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t encode_close_maxsz + \\\n\t\t\t\t encode_getattr_maxsz)\n#define NFS4_dec_close_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t decode_close_maxsz + \\\n\t\t\t\t decode_getattr_maxsz)\n#define NFS4_enc_setattr_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t encode_setattr_maxsz + \\\n\t\t\t\t encode_getattr_maxsz)\n#define NFS4_dec_setattr_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t decode_setattr_maxsz + \\\n\t\t\t\t decode_getattr_maxsz)\n#define NFS4_enc_fsinfo_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_fsinfo_maxsz)\n#define NFS4_dec_fsinfo_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_fsinfo_maxsz)\n#define NFS4_enc_renew_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_renew_maxsz)\n#define NFS4_dec_renew_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_renew_maxsz)\n#define NFS4_enc_setclientid_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_setclientid_maxsz)\n#define NFS4_dec_setclientid_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_setclientid_maxsz)\n#define NFS4_enc_setclientid_confirm_sz \\\n\t\t\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_setclientid_confirm_maxsz + \\\n\t\t\t\tencode_putrootfh_maxsz + \\\n\t\t\t\tencode_fsinfo_maxsz)\n#define NFS4_dec_setclientid_confirm_sz \\\n\t\t\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_setclientid_confirm_maxsz + \\\n\t\t\t\tdecode_putrootfh_maxsz + \\\n\t\t\t\tdecode_fsinfo_maxsz)\n#define NFS4_enc_lock_sz        (compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_lock_maxsz)\n#define NFS4_dec_lock_sz        (compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_lock_maxsz)\n#define NFS4_enc_lockt_sz       (compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_lockt_maxsz)\n#define NFS4_dec_lockt_sz       (compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t decode_lockt_maxsz)\n#define NFS4_enc_locku_sz       (compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_locku_maxsz)\n#define NFS4_dec_locku_sz       (compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_locku_maxsz)\n#define NFS4_enc_access_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_access_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_access_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_access_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_getattr_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_getattr_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_lookup_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_lookup_maxsz + \\\n\t\t\t\tencode_getattr_maxsz + \\\n\t\t\t\tencode_getfh_maxsz)\n#define NFS4_dec_lookup_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_lookup_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz + \\\n\t\t\t\tdecode_getfh_maxsz)\n#define NFS4_enc_lookup_root_sz (compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putrootfh_maxsz + \\\n\t\t\t\tencode_getattr_maxsz + \\\n\t\t\t\tencode_getfh_maxsz)\n#define NFS4_dec_lookup_root_sz (compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putrootfh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz + \\\n\t\t\t\tdecode_getfh_maxsz)\n#define NFS4_enc_remove_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_remove_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_remove_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\top_decode_hdr_maxsz + 5 + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_rename_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_savefh_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_rename_maxsz + \\\n\t\t\t\tencode_getattr_maxsz + \\\n\t\t\t\tencode_restorefh_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_rename_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_savefh_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_rename_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz + \\\n\t\t\t\tdecode_restorefh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_link_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_savefh_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_link_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz + \\\n\t\t\t\tencode_restorefh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_dec_link_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_savefh_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_link_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz + \\\n\t\t\t\tdecode_restorefh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_symlink_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_symlink_maxsz + \\\n\t\t\t\tencode_getattr_maxsz + \\\n\t\t\t\tencode_getfh_maxsz)\n#define NFS4_dec_symlink_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_symlink_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz + \\\n\t\t\t\tdecode_getfh_maxsz)\n#define NFS4_enc_create_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_savefh_maxsz + \\\n\t\t\t\tencode_create_maxsz + \\\n\t\t\t\tencode_getfh_maxsz + \\\n\t\t\t\tencode_getattr_maxsz + \\\n\t\t\t\tencode_restorefh_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_create_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_savefh_maxsz + \\\n\t\t\t\tdecode_create_maxsz + \\\n\t\t\t\tdecode_getfh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz + \\\n\t\t\t\tdecode_restorefh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_pathconf_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_pathconf_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_statfs_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_statfs_maxsz)\n#define NFS4_dec_statfs_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_statfs_maxsz)\n#define NFS4_enc_server_caps_sz (compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_server_caps_sz (compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_delegreturn_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_delegreturn_maxsz + \\\n\t\t\t\tencode_getattr_maxsz)\n#define NFS4_dec_delegreturn_sz (compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_delegreturn_maxsz + \\\n\t\t\t\tdecode_getattr_maxsz)\n#define NFS4_enc_getacl_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_getacl_maxsz)\n#define NFS4_dec_getacl_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_getacl_maxsz)\n#define NFS4_enc_setacl_sz\t(compound_encode_hdr_maxsz + \\\n\t\t\t\tencode_putfh_maxsz + \\\n\t\t\t\tencode_setacl_maxsz)\n#define NFS4_dec_setacl_sz\t(compound_decode_hdr_maxsz + \\\n\t\t\t\tdecode_putfh_maxsz + \\\n\t\t\t\tdecode_setacl_maxsz)\n#define NFS4_enc_fs_locations_sz \\\n\t\t\t\t(compound_encode_hdr_maxsz + \\\n\t\t\t\t encode_putfh_maxsz + \\\n\t\t\t\t encode_lookup_maxsz + \\\n\t\t\t\t encode_fs_locations_maxsz)\n#define NFS4_dec_fs_locations_sz \\\n\t\t\t\t(compound_decode_hdr_maxsz + \\\n\t\t\t\t decode_putfh_maxsz + \\\n\t\t\t\t decode_lookup_maxsz + \\\n\t\t\t\t decode_fs_locations_maxsz)\n\nstatic struct {\n\tunsigned int\tmode;\n\tunsigned int\tnfs2type;\n} nfs_type2fmt[] = {\n\t{ 0,\t\tNFNON\t     },\n\t{ S_IFREG,\tNFREG\t     },\n\t{ S_IFDIR,\tNFDIR\t     },\n\t{ S_IFBLK,\tNFBLK\t     },\n\t{ S_IFCHR,\tNFCHR\t     },\n\t{ S_IFLNK,\tNFLNK\t     },\n\t{ S_IFSOCK,\tNFSOCK\t     },\n\t{ S_IFIFO,\tNFFIFO\t     },\n\t{ 0,\t\tNFNON\t     },\n\t{ 0,\t\tNFNON\t     },\n};\n\nstruct compound_hdr {\n\tint32_t\t\tstatus;\n\tuint32_t\tnops;\n\tuint32_t\ttaglen;\n\tchar *\t\ttag;\n};\n\n/*\n * START OF \"GENERIC\" ENCODE ROUTINES.\n *   These may look a little ugly since they are imported from a \"generic\"\n * set of XDR encode/decode routines which are intended to be shared by\n * all of our NFSv4 implementations (OpenBSD, MacOS X...).\n *\n * If the pain of reading these is too great, it should be a straightforward\n * task to translate them into Linux-specific versions which are more\n * consistent with the style used in NFSv2/v3...\n */\n#define WRITE32(n)               *p++ = htonl(n)\n#define WRITE64(n)               do {\t\t\t\t\\\n\t*p++ = htonl((uint32_t)((n) >> 32));\t\t\t\t\\\n\t*p++ = htonl((uint32_t)(n));\t\t\t\t\t\\\n} while (0)\n#define WRITEMEM(ptr,nbytes)     do {\t\t\t\t\\\n\tp = xdr_encode_opaque_fixed(p, ptr, nbytes);\t\t\\\n} while (0)\n\n#define RESERVE_SPACE(nbytes)\tdo {\t\t\t\t\\\n\tp = xdr_reserve_space(xdr, nbytes);\t\t\t\\\n\tBUG_ON(!p);\t\t\t\t\t\t\\\n} while (0)\n\nstatic void encode_string(struct xdr_stream *xdr, unsigned int len, const char *str)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4 + len);\n\tBUG_ON(p == NULL);\n\txdr_encode_opaque(p, str, len);\n}\n\nstatic int encode_compound_hdr(struct xdr_stream *xdr, struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tdprintk(\"encode_compound: tag=%.*s\\n\", (int)hdr->taglen, hdr->tag);\n\tBUG_ON(hdr->taglen > NFS4_MAXTAGLEN);\n\tRESERVE_SPACE(12+(XDR_QUADLEN(hdr->taglen)<<2));\n\tWRITE32(hdr->taglen);\n\tWRITEMEM(hdr->tag, hdr->taglen);\n\tWRITE32(NFS4_MINOR_VERSION);\n\tWRITE32(hdr->nops);\n\treturn 0;\n}\n\nstatic void encode_nfs4_verifier(struct xdr_stream *xdr, const nfs4_verifier *verf)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, NFS4_VERIFIER_SIZE);\n\tBUG_ON(p == NULL);\n\txdr_encode_opaque_fixed(p, verf->data, NFS4_VERIFIER_SIZE);\n}\n\nstatic int encode_attrs(struct xdr_stream *xdr, const struct iattr *iap, const struct nfs_server *server)\n{\n\tchar owner_name[IDMAP_NAMESZ];\n\tchar owner_group[IDMAP_NAMESZ];\n\tint owner_namelen = 0;\n\tint owner_grouplen = 0;\n\t__be32 *p;\n\t__be32 *q;\n\tint len;\n\tuint32_t bmval0 = 0;\n\tuint32_t bmval1 = 0;\n\tint status;\n\n\t/*\n\t * We reserve enough space to write the entire attribute buffer at once.\n\t * In the worst-case, this would be\n\t *   12(bitmap) + 4(attrlen) + 8(size) + 4(mode) + 4(atime) + 4(mtime)\n\t *          = 36 bytes, plus any contribution from variable-length fields\n\t *            such as owner/group.\n\t */\n\tlen = 16;\n\n\t/* Sigh */\n\tif (iap->ia_valid & ATTR_SIZE)\n\t\tlen += 8;\n\tif (iap->ia_valid & ATTR_MODE)\n\t\tlen += 4;\n\tif (iap->ia_valid & ATTR_UID) {\n\t\towner_namelen = nfs_map_uid_to_name(server->nfs_client, iap->ia_uid, owner_name);\n\t\tif (owner_namelen < 0) {\n\t\t\tdprintk(\"nfs: couldn't resolve uid %d to string\\n\",\n\t\t\t\t\tiap->ia_uid);\n\t\t\t/* XXX */\n\t\t\tstrcpy(owner_name, \"nobody\");\n\t\t\towner_namelen = sizeof(\"nobody\") - 1;\n\t\t\t/* goto out; */\n\t\t}\n\t\tlen += 4 + (XDR_QUADLEN(owner_namelen) << 2);\n\t}\n\tif (iap->ia_valid & ATTR_GID) {\n\t\towner_grouplen = nfs_map_gid_to_group(server->nfs_client, iap->ia_gid, owner_group);\n\t\tif (owner_grouplen < 0) {\n\t\t\tdprintk(\"nfs: couldn't resolve gid %d to string\\n\",\n\t\t\t\t\tiap->ia_gid);\n\t\t\tstrcpy(owner_group, \"nobody\");\n\t\t\towner_grouplen = sizeof(\"nobody\") - 1;\n\t\t\t/* goto out; */\n\t\t}\n\t\tlen += 4 + (XDR_QUADLEN(owner_grouplen) << 2);\n\t}\n\tif (iap->ia_valid & ATTR_ATIME_SET)\n\t\tlen += 16;\n\telse if (iap->ia_valid & ATTR_ATIME)\n\t\tlen += 4;\n\tif (iap->ia_valid & ATTR_MTIME_SET)\n\t\tlen += 16;\n\telse if (iap->ia_valid & ATTR_MTIME)\n\t\tlen += 4;\n\tRESERVE_SPACE(len);\n\n\t/*\n\t * We write the bitmap length now, but leave the bitmap and the attribute\n\t * buffer length to be backfilled at the end of this routine.\n\t */\n\tWRITE32(2);\n\tq = p;\n\tp += 3;\n\n\tif (iap->ia_valid & ATTR_SIZE) {\n\t\tbmval0 |= FATTR4_WORD0_SIZE;\n\t\tWRITE64(iap->ia_size);\n\t}\n\tif (iap->ia_valid & ATTR_MODE) {\n\t\tbmval1 |= FATTR4_WORD1_MODE;\n\t\tWRITE32(iap->ia_mode & S_IALLUGO);\n\t}\n\tif (iap->ia_valid & ATTR_UID) {\n\t\tbmval1 |= FATTR4_WORD1_OWNER;\n\t\tWRITE32(owner_namelen);\n\t\tWRITEMEM(owner_name, owner_namelen);\n\t}\n\tif (iap->ia_valid & ATTR_GID) {\n\t\tbmval1 |= FATTR4_WORD1_OWNER_GROUP;\n\t\tWRITE32(owner_grouplen);\n\t\tWRITEMEM(owner_group, owner_grouplen);\n\t}\n\tif (iap->ia_valid & ATTR_ATIME_SET) {\n\t\tbmval1 |= FATTR4_WORD1_TIME_ACCESS_SET;\n\t\tWRITE32(NFS4_SET_TO_CLIENT_TIME);\n\t\tWRITE32(0);\n\t\tWRITE32(iap->ia_mtime.tv_sec);\n\t\tWRITE32(iap->ia_mtime.tv_nsec);\n\t}\n\telse if (iap->ia_valid & ATTR_ATIME) {\n\t\tbmval1 |= FATTR4_WORD1_TIME_ACCESS_SET;\n\t\tWRITE32(NFS4_SET_TO_SERVER_TIME);\n\t}\n\tif (iap->ia_valid & ATTR_MTIME_SET) {\n\t\tbmval1 |= FATTR4_WORD1_TIME_MODIFY_SET;\n\t\tWRITE32(NFS4_SET_TO_CLIENT_TIME);\n\t\tWRITE32(0);\n\t\tWRITE32(iap->ia_mtime.tv_sec);\n\t\tWRITE32(iap->ia_mtime.tv_nsec);\n\t}\n\telse if (iap->ia_valid & ATTR_MTIME) {\n\t\tbmval1 |= FATTR4_WORD1_TIME_MODIFY_SET;\n\t\tWRITE32(NFS4_SET_TO_SERVER_TIME);\n\t}\n\t\n\t/*\n\t * Now we backfill the bitmap and the attribute buffer length.\n\t */\n\tif (len != ((char *)p - (char *)q) + 4) {\n\t\tprintk(KERN_ERR \"nfs: Attr length error, %u != %Zu\\n\",\n\t\t\t\tlen, ((char *)p - (char *)q) + 4);\n\t\tBUG();\n\t}\n\tlen = (char *)p - (char *)q - 12;\n\t*q++ = htonl(bmval0);\n\t*q++ = htonl(bmval1);\n\t*q++ = htonl(len);\n\n\tstatus = 0;\n/* out: */\n\treturn status;\n}\n\nstatic int encode_access(struct xdr_stream *xdr, u32 access)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(8);\n\tWRITE32(OP_ACCESS);\n\tWRITE32(access);\n\t\n\treturn 0;\n}\n\nstatic int encode_close(struct xdr_stream *xdr, const struct nfs_closeargs *arg)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(8+NFS4_STATEID_SIZE);\n\tWRITE32(OP_CLOSE);\n\tWRITE32(arg->seqid->sequence->counter);\n\tWRITEMEM(arg->stateid->data, NFS4_STATEID_SIZE);\n\t\n\treturn 0;\n}\n\nstatic int encode_commit(struct xdr_stream *xdr, const struct nfs_writeargs *args)\n{\n\t__be32 *p;\n        \n        RESERVE_SPACE(16);\n        WRITE32(OP_COMMIT);\n        WRITE64(args->offset);\n        WRITE32(args->count);\n\n        return 0;\n}\n\nstatic int encode_create(struct xdr_stream *xdr, const struct nfs4_create_arg *create)\n{\n\t__be32 *p;\n\t\n\tRESERVE_SPACE(8);\n\tWRITE32(OP_CREATE);\n\tWRITE32(create->ftype);\n\n\tswitch (create->ftype) {\n\tcase NF4LNK:\n\t\tRESERVE_SPACE(4);\n\t\tWRITE32(create->u.symlink.len);\n\t\txdr_write_pages(xdr, create->u.symlink.pages, 0, create->u.symlink.len);\n\t\tbreak;\n\n\tcase NF4BLK: case NF4CHR:\n\t\tRESERVE_SPACE(8);\n\t\tWRITE32(create->u.device.specdata1);\n\t\tWRITE32(create->u.device.specdata2);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tRESERVE_SPACE(4 + create->name->len);\n\tWRITE32(create->name->len);\n\tWRITEMEM(create->name->name, create->name->len);\n\n\treturn encode_attrs(xdr, create->attrs, create->server);\n}\n\nstatic int encode_getattr_one(struct xdr_stream *xdr, uint32_t bitmap)\n{\n        __be32 *p;\n\n        RESERVE_SPACE(12);\n        WRITE32(OP_GETATTR);\n        WRITE32(1);\n        WRITE32(bitmap);\n        return 0;\n}\n\nstatic int encode_getattr_two(struct xdr_stream *xdr, uint32_t bm0, uint32_t bm1)\n{\n        __be32 *p;\n\n        RESERVE_SPACE(16);\n        WRITE32(OP_GETATTR);\n        WRITE32(2);\n        WRITE32(bm0);\n        WRITE32(bm1);\n        return 0;\n}\n\nstatic int encode_getfattr(struct xdr_stream *xdr, const u32* bitmask)\n{\n\treturn encode_getattr_two(xdr,\n\t\t\tbitmask[0] & nfs4_fattr_bitmap[0],\n\t\t\tbitmask[1] & nfs4_fattr_bitmap[1]);\n}\n\nstatic int encode_fsinfo(struct xdr_stream *xdr, const u32* bitmask)\n{\n\treturn encode_getattr_two(xdr, bitmask[0] & nfs4_fsinfo_bitmap[0],\n\t\t\tbitmask[1] & nfs4_fsinfo_bitmap[1]);\n}\n\nstatic int encode_fs_locations(struct xdr_stream *xdr, const u32* bitmask)\n{\n\treturn encode_getattr_two(xdr,\n\t\t\t\t  bitmask[0] & nfs4_fs_locations_bitmap[0],\n\t\t\t\t  bitmask[1] & nfs4_fs_locations_bitmap[1]);\n}\n\nstatic int encode_getfh(struct xdr_stream *xdr)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4);\n\tWRITE32(OP_GETFH);\n\n\treturn 0;\n}\n\nstatic int encode_link(struct xdr_stream *xdr, const struct qstr *name)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(8 + name->len);\n\tWRITE32(OP_LINK);\n\tWRITE32(name->len);\n\tWRITEMEM(name->name, name->len);\n\t\n\treturn 0;\n}\n\nstatic inline int nfs4_lock_type(struct file_lock *fl, int block)\n{\n\tif ((fl->fl_type & (F_RDLCK|F_WRLCK|F_UNLCK)) == F_RDLCK)\n\t\treturn block ? NFS4_READW_LT : NFS4_READ_LT;\n\treturn block ? NFS4_WRITEW_LT : NFS4_WRITE_LT;\n}\n\nstatic inline uint64_t nfs4_lock_length(struct file_lock *fl)\n{\n\tif (fl->fl_end == OFFSET_MAX)\n\t\treturn ~(uint64_t)0;\n\treturn fl->fl_end - fl->fl_start + 1;\n}\n\n/*\n * opcode,type,reclaim,offset,length,new_lock_owner = 32\n * open_seqid,open_stateid,lock_seqid,lock_owner.clientid, lock_owner.id = 40\n */\nstatic int encode_lock(struct xdr_stream *xdr, const struct nfs_lock_args *args)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(32);\n\tWRITE32(OP_LOCK);\n\tWRITE32(nfs4_lock_type(args->fl, args->block));\n\tWRITE32(args->reclaim);\n\tWRITE64(args->fl->fl_start);\n\tWRITE64(nfs4_lock_length(args->fl));\n\tWRITE32(args->new_lock_owner);\n\tif (args->new_lock_owner){\n\t\tRESERVE_SPACE(4+NFS4_STATEID_SIZE+32);\n\t\tWRITE32(args->open_seqid->sequence->counter);\n\t\tWRITEMEM(args->open_stateid->data, NFS4_STATEID_SIZE);\n\t\tWRITE32(args->lock_seqid->sequence->counter);\n\t\tWRITE64(args->lock_owner.clientid);\n\t\tWRITE32(16);\n\t\tWRITEMEM(\"lock id:\", 8);\n\t\tWRITE64(args->lock_owner.id);\n\t}\n\telse {\n\t\tRESERVE_SPACE(NFS4_STATEID_SIZE+4);\n\t\tWRITEMEM(args->lock_stateid->data, NFS4_STATEID_SIZE);\n\t\tWRITE32(args->lock_seqid->sequence->counter);\n\t}\n\n\treturn 0;\n}\n\nstatic int encode_lockt(struct xdr_stream *xdr, const struct nfs_lockt_args *args)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(52);\n\tWRITE32(OP_LOCKT);\n\tWRITE32(nfs4_lock_type(args->fl, 0));\n\tWRITE64(args->fl->fl_start);\n\tWRITE64(nfs4_lock_length(args->fl));\n\tWRITE64(args->lock_owner.clientid);\n\tWRITE32(16);\n\tWRITEMEM(\"lock id:\", 8);\n\tWRITE64(args->lock_owner.id);\n\n\treturn 0;\n}\n\nstatic int encode_locku(struct xdr_stream *xdr, const struct nfs_locku_args *args)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(12+NFS4_STATEID_SIZE+16);\n\tWRITE32(OP_LOCKU);\n\tWRITE32(nfs4_lock_type(args->fl, 0));\n\tWRITE32(args->seqid->sequence->counter);\n\tWRITEMEM(args->stateid->data, NFS4_STATEID_SIZE);\n\tWRITE64(args->fl->fl_start);\n\tWRITE64(nfs4_lock_length(args->fl));\n\n\treturn 0;\n}\n\nstatic int encode_lookup(struct xdr_stream *xdr, const struct qstr *name)\n{\n\tint len = name->len;\n\t__be32 *p;\n\n\tRESERVE_SPACE(8 + len);\n\tWRITE32(OP_LOOKUP);\n\tWRITE32(len);\n\tWRITEMEM(name->name, len);\n\n\treturn 0;\n}\n\nstatic void encode_share_access(struct xdr_stream *xdr, fmode_t fmode)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(8);\n\tswitch (fmode & (FMODE_READ|FMODE_WRITE)) {\n\t\tcase FMODE_READ:\n\t\t\tWRITE32(NFS4_SHARE_ACCESS_READ);\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tWRITE32(NFS4_SHARE_ACCESS_WRITE);\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tWRITE32(NFS4_SHARE_ACCESS_BOTH);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWRITE32(0);\n\t}\n\tWRITE32(0);\t\t/* for linux, share_deny = 0 always */\n}\n\nstatic inline void encode_openhdr(struct xdr_stream *xdr, const struct nfs_openargs *arg)\n{\n\t__be32 *p;\n /*\n * opcode 4, seqid 4, share_access 4, share_deny 4, clientid 8, ownerlen 4,\n * owner 4 = 32\n */\n\tRESERVE_SPACE(8);\n\tWRITE32(OP_OPEN);\n\tWRITE32(arg->seqid->sequence->counter);\n\tencode_share_access(xdr, arg->fmode);\n\tRESERVE_SPACE(28);\n\tWRITE64(arg->clientid);\n\tWRITE32(16);\n\tWRITEMEM(\"open id:\", 8);\n\tWRITE64(arg->id);\n}\n\nstatic inline void encode_createmode(struct xdr_stream *xdr, const struct nfs_openargs *arg)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4);\n\tswitch(arg->open_flags & O_EXCL) {\n\t\tcase 0:\n\t\t\tWRITE32(NFS4_CREATE_UNCHECKED);\n\t\t\tencode_attrs(xdr, arg->u.attrs, arg->server);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWRITE32(NFS4_CREATE_EXCLUSIVE);\n\t\t\tencode_nfs4_verifier(xdr, &arg->u.verifier);\n\t}\n}\n\nstatic void encode_opentype(struct xdr_stream *xdr, const struct nfs_openargs *arg)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4);\n\tswitch (arg->open_flags & O_CREAT) {\n\t\tcase 0:\n\t\t\tWRITE32(NFS4_OPEN_NOCREATE);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG_ON(arg->claim != NFS4_OPEN_CLAIM_NULL);\n\t\t\tWRITE32(NFS4_OPEN_CREATE);\n\t\t\tencode_createmode(xdr, arg);\n\t}\n}\n\nstatic inline void encode_delegation_type(struct xdr_stream *xdr, fmode_t delegation_type)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4);\n\tswitch (delegation_type) {\n\t\tcase 0:\n\t\t\tWRITE32(NFS4_OPEN_DELEGATE_NONE);\n\t\t\tbreak;\n\t\tcase FMODE_READ:\n\t\t\tWRITE32(NFS4_OPEN_DELEGATE_READ);\n\t\t\tbreak;\n\t\tcase FMODE_WRITE|FMODE_READ:\n\t\t\tWRITE32(NFS4_OPEN_DELEGATE_WRITE);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n}\n\nstatic inline void encode_claim_null(struct xdr_stream *xdr, const struct qstr *name)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4);\n\tWRITE32(NFS4_OPEN_CLAIM_NULL);\n\tencode_string(xdr, name->len, name->name);\n}\n\nstatic inline void encode_claim_previous(struct xdr_stream *xdr, fmode_t type)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4);\n\tWRITE32(NFS4_OPEN_CLAIM_PREVIOUS);\n\tencode_delegation_type(xdr, type);\n}\n\nstatic inline void encode_claim_delegate_cur(struct xdr_stream *xdr, const struct qstr *name, const nfs4_stateid *stateid)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4+NFS4_STATEID_SIZE);\n\tWRITE32(NFS4_OPEN_CLAIM_DELEGATE_CUR);\n\tWRITEMEM(stateid->data, NFS4_STATEID_SIZE);\n\tencode_string(xdr, name->len, name->name);\n}\n\nstatic int encode_open(struct xdr_stream *xdr, const struct nfs_openargs *arg)\n{\n\tencode_openhdr(xdr, arg);\n\tencode_opentype(xdr, arg);\n\tswitch (arg->claim) {\n\t\tcase NFS4_OPEN_CLAIM_NULL:\n\t\t\tencode_claim_null(xdr, arg->name);\n\t\t\tbreak;\n\t\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\t\t\tencode_claim_previous(xdr, arg->u.delegation_type);\n\t\t\tbreak;\n\t\tcase NFS4_OPEN_CLAIM_DELEGATE_CUR:\n\t\t\tencode_claim_delegate_cur(xdr, arg->name, &arg->u.delegation);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\treturn 0;\n}\n\nstatic int encode_open_confirm(struct xdr_stream *xdr, const struct nfs_open_confirmargs *arg)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4+NFS4_STATEID_SIZE+4);\n\tWRITE32(OP_OPEN_CONFIRM);\n\tWRITEMEM(arg->stateid->data, NFS4_STATEID_SIZE);\n\tWRITE32(arg->seqid->sequence->counter);\n\n\treturn 0;\n}\n\nstatic int encode_open_downgrade(struct xdr_stream *xdr, const struct nfs_closeargs *arg)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4+NFS4_STATEID_SIZE+4);\n\tWRITE32(OP_OPEN_DOWNGRADE);\n\tWRITEMEM(arg->stateid->data, NFS4_STATEID_SIZE);\n\tWRITE32(arg->seqid->sequence->counter);\n\tencode_share_access(xdr, arg->fmode);\n\treturn 0;\n}\n\nstatic int\nencode_putfh(struct xdr_stream *xdr, const struct nfs_fh *fh)\n{\n\tint len = fh->size;\n\t__be32 *p;\n\n\tRESERVE_SPACE(8 + len);\n\tWRITE32(OP_PUTFH);\n\tWRITE32(len);\n\tWRITEMEM(fh->data, len);\n\n\treturn 0;\n}\n\nstatic int encode_putrootfh(struct xdr_stream *xdr)\n{\n        __be32 *p;\n        \n        RESERVE_SPACE(4);\n        WRITE32(OP_PUTROOTFH);\n\n        return 0;\n}\n\nstatic void encode_stateid(struct xdr_stream *xdr, const struct nfs_open_context *ctx)\n{\n\tnfs4_stateid stateid;\n\t__be32 *p;\n\n\tRESERVE_SPACE(NFS4_STATEID_SIZE);\n\tif (ctx->state != NULL) {\n\t\tnfs4_copy_stateid(&stateid, ctx->state, ctx->lockowner);\n\t\tWRITEMEM(stateid.data, NFS4_STATEID_SIZE);\n\t} else\n\t\tWRITEMEM(zero_stateid.data, NFS4_STATEID_SIZE);\n}\n\nstatic int encode_read(struct xdr_stream *xdr, const struct nfs_readargs *args)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4);\n\tWRITE32(OP_READ);\n\n\tencode_stateid(xdr, args->context);\n\n\tRESERVE_SPACE(12);\n\tWRITE64(args->offset);\n\tWRITE32(args->count);\n\n\treturn 0;\n}\n\nstatic int encode_readdir(struct xdr_stream *xdr, const struct nfs4_readdir_arg *readdir, struct rpc_rqst *req)\n{\n\tuint32_t attrs[2] = {\n\t\tFATTR4_WORD0_RDATTR_ERROR|FATTR4_WORD0_FILEID,\n\t\tFATTR4_WORD1_MOUNTED_ON_FILEID,\n\t};\n\t__be32 *p;\n\n\tRESERVE_SPACE(12+NFS4_VERIFIER_SIZE+20);\n\tWRITE32(OP_READDIR);\n\tWRITE64(readdir->cookie);\n\tWRITEMEM(readdir->verifier.data, NFS4_VERIFIER_SIZE);\n\tWRITE32(readdir->count >> 1);  /* We're not doing readdirplus */\n\tWRITE32(readdir->count);\n\tWRITE32(2);\n\t/* Switch to mounted_on_fileid if the server supports it */\n\tif (readdir->bitmask[1] & FATTR4_WORD1_MOUNTED_ON_FILEID)\n\t\tattrs[0] &= ~FATTR4_WORD0_FILEID;\n\telse\n\t\tattrs[1] &= ~FATTR4_WORD1_MOUNTED_ON_FILEID;\n\tWRITE32(attrs[0] & readdir->bitmask[0]);\n\tWRITE32(attrs[1] & readdir->bitmask[1]);\n\tdprintk(\"%s: cookie = %Lu, verifier = %08x:%08x, bitmap = %08x:%08x\\n\",\n\t\t\t__func__,\n\t\t\t(unsigned long long)readdir->cookie,\n\t\t\t((u32 *)readdir->verifier.data)[0],\n\t\t\t((u32 *)readdir->verifier.data)[1],\n\t\t\tattrs[0] & readdir->bitmask[0],\n\t\t\tattrs[1] & readdir->bitmask[1]);\n\n\treturn 0;\n}\n\nstatic int encode_readlink(struct xdr_stream *xdr, const struct nfs4_readlink *readlink, struct rpc_rqst *req)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4);\n\tWRITE32(OP_READLINK);\n\n\treturn 0;\n}\n\nstatic int encode_remove(struct xdr_stream *xdr, const struct qstr *name)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(8 + name->len);\n\tWRITE32(OP_REMOVE);\n\tWRITE32(name->len);\n\tWRITEMEM(name->name, name->len);\n\n\treturn 0;\n}\n\nstatic int encode_rename(struct xdr_stream *xdr, const struct qstr *oldname, const struct qstr *newname)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(8 + oldname->len);\n\tWRITE32(OP_RENAME);\n\tWRITE32(oldname->len);\n\tWRITEMEM(oldname->name, oldname->len);\n\t\n\tRESERVE_SPACE(4 + newname->len);\n\tWRITE32(newname->len);\n\tWRITEMEM(newname->name, newname->len);\n\n\treturn 0;\n}\n\nstatic int encode_renew(struct xdr_stream *xdr, const struct nfs_client *client_stateid)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(12);\n\tWRITE32(OP_RENEW);\n\tWRITE64(client_stateid->cl_clientid);\n\n\treturn 0;\n}\n\nstatic int\nencode_restorefh(struct xdr_stream *xdr)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4);\n\tWRITE32(OP_RESTOREFH);\n\n\treturn 0;\n}\n\nstatic int\nencode_setacl(struct xdr_stream *xdr, struct nfs_setaclargs *arg)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4+NFS4_STATEID_SIZE);\n\tWRITE32(OP_SETATTR);\n\tWRITEMEM(zero_stateid.data, NFS4_STATEID_SIZE);\n\tRESERVE_SPACE(2*4);\n\tWRITE32(1);\n\tWRITE32(FATTR4_WORD0_ACL);\n\tif (arg->acl_len % 4)\n\t\treturn -EINVAL;\n\tRESERVE_SPACE(4);\n\tWRITE32(arg->acl_len);\n\txdr_write_pages(xdr, arg->acl_pages, arg->acl_pgbase, arg->acl_len);\n\treturn 0;\n}\n\nstatic int\nencode_savefh(struct xdr_stream *xdr)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4);\n\tWRITE32(OP_SAVEFH);\n\n\treturn 0;\n}\n\nstatic int encode_setattr(struct xdr_stream *xdr, const struct nfs_setattrargs *arg, const struct nfs_server *server)\n{\n\tint status;\n\t__be32 *p;\n\t\n        RESERVE_SPACE(4+NFS4_STATEID_SIZE);\n        WRITE32(OP_SETATTR);\n\tWRITEMEM(arg->stateid.data, NFS4_STATEID_SIZE);\n\n        if ((status = encode_attrs(xdr, arg->iap, server)))\n\t\treturn status;\n\n        return 0;\n}\n\nstatic int encode_setclientid(struct xdr_stream *xdr, const struct nfs4_setclientid *setclientid)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4 + NFS4_VERIFIER_SIZE);\n\tWRITE32(OP_SETCLIENTID);\n\tWRITEMEM(setclientid->sc_verifier->data, NFS4_VERIFIER_SIZE);\n\n\tencode_string(xdr, setclientid->sc_name_len, setclientid->sc_name);\n\tRESERVE_SPACE(4);\n\tWRITE32(setclientid->sc_prog);\n\tencode_string(xdr, setclientid->sc_netid_len, setclientid->sc_netid);\n\tencode_string(xdr, setclientid->sc_uaddr_len, setclientid->sc_uaddr);\n\tRESERVE_SPACE(4);\n\tWRITE32(setclientid->sc_cb_ident);\n\n\treturn 0;\n}\n\nstatic int encode_setclientid_confirm(struct xdr_stream *xdr, const struct nfs_client *client_state)\n{\n        __be32 *p;\n\n        RESERVE_SPACE(12 + NFS4_VERIFIER_SIZE);\n        WRITE32(OP_SETCLIENTID_CONFIRM);\n        WRITE64(client_state->cl_clientid);\n        WRITEMEM(client_state->cl_confirm.data, NFS4_VERIFIER_SIZE);\n\n        return 0;\n}\n\nstatic int encode_write(struct xdr_stream *xdr, const struct nfs_writeargs *args)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4);\n\tWRITE32(OP_WRITE);\n\n\tencode_stateid(xdr, args->context);\n\n\tRESERVE_SPACE(16);\n\tWRITE64(args->offset);\n\tWRITE32(args->stable);\n\tWRITE32(args->count);\n\n\txdr_write_pages(xdr, args->pages, args->pgbase, args->count);\n\n\treturn 0;\n}\n\nstatic int encode_delegreturn(struct xdr_stream *xdr, const nfs4_stateid *stateid)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4+NFS4_STATEID_SIZE);\n\n\tWRITE32(OP_DELEGRETURN);\n\tWRITEMEM(stateid->data, NFS4_STATEID_SIZE);\n\treturn 0;\n\n}\n/*\n * END OF \"GENERIC\" ENCODE ROUTINES.\n */\n\n/*\n * Encode an ACCESS request\n */\nstatic int nfs4_xdr_enc_access(struct rpc_rqst *req, __be32 *p, const struct nfs4_accessargs *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 3,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fh);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = encode_access(&xdr, args->access);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = encode_getfattr(&xdr, args->bitmask);\nout:\n\treturn status;\n}\n\n/*\n * Encode LOOKUP request\n */\nstatic int nfs4_xdr_enc_lookup(struct rpc_rqst *req, __be32 *p, const struct nfs4_lookup_arg *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 4,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tif ((status = encode_putfh(&xdr, args->dir_fh)) != 0)\n\t\tgoto out;\n\tif ((status = encode_lookup(&xdr, args->name)) != 0)\n\t\tgoto out;\n\tif ((status = encode_getfh(&xdr)) != 0)\n\t\tgoto out;\n\tstatus = encode_getfattr(&xdr, args->bitmask);\nout:\n\treturn status;\n}\n\n/*\n * Encode LOOKUP_ROOT request\n */\nstatic int nfs4_xdr_enc_lookup_root(struct rpc_rqst *req, __be32 *p, const struct nfs4_lookup_root_arg *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 3,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tif ((status = encode_putrootfh(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = encode_getfh(&xdr)) == 0)\n\t\tstatus = encode_getfattr(&xdr, args->bitmask);\nout:\n\treturn status;\n}\n\n/*\n * Encode REMOVE request\n */\nstatic int nfs4_xdr_enc_remove(struct rpc_rqst *req, __be32 *p, const struct nfs_removeargs *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 3,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tif ((status = encode_putfh(&xdr, args->fh)) != 0)\n\t\tgoto out;\n\tif ((status = encode_remove(&xdr, &args->name)) != 0)\n\t\tgoto out;\n\tstatus = encode_getfattr(&xdr, args->bitmask);\nout:\n\treturn status;\n}\n\n/*\n * Encode RENAME request\n */\nstatic int nfs4_xdr_enc_rename(struct rpc_rqst *req, __be32 *p, const struct nfs4_rename_arg *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 7,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tif ((status = encode_putfh(&xdr, args->old_dir)) != 0)\n\t\tgoto out;\n\tif ((status = encode_savefh(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = encode_putfh(&xdr, args->new_dir)) != 0)\n\t\tgoto out;\n\tif ((status = encode_rename(&xdr, args->old_name, args->new_name)) != 0)\n\t\tgoto out;\n\tif ((status = encode_getfattr(&xdr, args->bitmask)) != 0)\n\t\tgoto out;\n\tif ((status = encode_restorefh(&xdr)) != 0)\n\t\tgoto out;\n\tstatus = encode_getfattr(&xdr, args->bitmask);\nout:\n\treturn status;\n}\n\n/*\n * Encode LINK request\n */\nstatic int nfs4_xdr_enc_link(struct rpc_rqst *req, __be32 *p, const struct nfs4_link_arg *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 7,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tif ((status = encode_putfh(&xdr, args->fh)) != 0)\n\t\tgoto out;\n\tif ((status = encode_savefh(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = encode_putfh(&xdr, args->dir_fh)) != 0)\n\t\tgoto out;\n\tif ((status = encode_link(&xdr, args->name)) != 0)\n\t\tgoto out;\n\tif ((status = encode_getfattr(&xdr, args->bitmask)) != 0)\n\t\tgoto out;\n\tif ((status = encode_restorefh(&xdr)) != 0)\n\t\tgoto out;\n\tstatus = encode_getfattr(&xdr, args->bitmask);\nout:\n\treturn status;\n}\n\n/*\n * Encode CREATE request\n */\nstatic int nfs4_xdr_enc_create(struct rpc_rqst *req, __be32 *p, const struct nfs4_create_arg *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 7,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tif ((status = encode_putfh(&xdr, args->dir_fh)) != 0)\n\t\tgoto out;\n\tif ((status = encode_savefh(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = encode_create(&xdr, args)) != 0)\n\t\tgoto out;\n\tif ((status = encode_getfh(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = encode_getfattr(&xdr, args->bitmask)) != 0)\n\t\tgoto out;\n\tif ((status = encode_restorefh(&xdr)) != 0)\n\t\tgoto out;\n\tstatus = encode_getfattr(&xdr, args->bitmask);\nout:\n\treturn status;\n}\n\n/*\n * Encode SYMLINK request\n */\nstatic int nfs4_xdr_enc_symlink(struct rpc_rqst *req, __be32 *p, const struct nfs4_create_arg *args)\n{\n\treturn nfs4_xdr_enc_create(req, p, args);\n}\n\n/*\n * Encode GETATTR request\n */\nstatic int nfs4_xdr_enc_getattr(struct rpc_rqst *req, __be32 *p, const struct nfs4_getattr_arg *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 2,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tif ((status = encode_putfh(&xdr, args->fh)) == 0)\n\t\tstatus = encode_getfattr(&xdr, args->bitmask);\n\treturn status;\n}\n\n/*\n * Encode a CLOSE request\n */\nstatic int nfs4_xdr_enc_close(struct rpc_rqst *req, __be32 *p, struct nfs_closeargs *args)\n{\n        struct xdr_stream xdr;\n        struct compound_hdr hdr = {\n                .nops   = 3,\n        };\n        int status;\n\n        xdr_init_encode(&xdr, &req->rq_snd_buf, p);\n        encode_compound_hdr(&xdr, &hdr);\n        status = encode_putfh(&xdr, args->fh);\n        if(status)\n                goto out;\n        status = encode_close(&xdr, args);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = encode_getfattr(&xdr, args->bitmask);\nout:\n        return status;\n}\n\n/*\n * Encode an OPEN request\n */\nstatic int nfs4_xdr_enc_open(struct rpc_rqst *req, __be32 *p, struct nfs_openargs *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 7,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fh);\n\tif (status)\n\t\tgoto out;\n\tstatus = encode_savefh(&xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = encode_open(&xdr, args);\n\tif (status)\n\t\tgoto out;\n\tstatus = encode_getfh(&xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = encode_getfattr(&xdr, args->bitmask);\n\tif (status)\n\t\tgoto out;\n\tstatus = encode_restorefh(&xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = encode_getfattr(&xdr, args->bitmask);\nout:\n\treturn status;\n}\n\n/*\n * Encode an OPEN_CONFIRM request\n */\nstatic int nfs4_xdr_enc_open_confirm(struct rpc_rqst *req, __be32 *p, struct nfs_open_confirmargs *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops   = 2,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fh);\n\tif(status)\n\t\tgoto out;\n\tstatus = encode_open_confirm(&xdr, args);\nout:\n\treturn status;\n}\n\n/*\n * Encode an OPEN request with no attributes.\n */\nstatic int nfs4_xdr_enc_open_noattr(struct rpc_rqst *req, __be32 *p, struct nfs_openargs *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops   = 3,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fh);\n\tif (status)\n\t\tgoto out;\n\tstatus = encode_open(&xdr, args);\n\tif (status)\n\t\tgoto out;\n\tstatus = encode_getfattr(&xdr, args->bitmask);\nout:\n\treturn status;\n}\n\n/*\n * Encode an OPEN_DOWNGRADE request\n */\nstatic int nfs4_xdr_enc_open_downgrade(struct rpc_rqst *req, __be32 *p, struct nfs_closeargs *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops\t= 3,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fh);\n\tif (status)\n\t\tgoto out;\n\tstatus = encode_open_downgrade(&xdr, args);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = encode_getfattr(&xdr, args->bitmask);\nout:\n\treturn status;\n}\n\n/*\n * Encode a LOCK request\n */\nstatic int nfs4_xdr_enc_lock(struct rpc_rqst *req, __be32 *p, struct nfs_lock_args *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops   = 2,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fh);\n\tif(status)\n\t\tgoto out;\n\tstatus = encode_lock(&xdr, args);\nout:\n\treturn status;\n}\n\n/*\n * Encode a LOCKT request\n */\nstatic int nfs4_xdr_enc_lockt(struct rpc_rqst *req, __be32 *p, struct nfs_lockt_args *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops   = 2,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fh);\n\tif(status)\n\t\tgoto out;\n\tstatus = encode_lockt(&xdr, args);\nout:\n\treturn status;\n}\n\n/*\n * Encode a LOCKU request\n */\nstatic int nfs4_xdr_enc_locku(struct rpc_rqst *req, __be32 *p, struct nfs_locku_args *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops   = 2,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fh);\n\tif(status)\n\t\tgoto out;\n\tstatus = encode_locku(&xdr, args);\nout:\n\treturn status;\n}\n\n/*\n * Encode a READLINK request\n */\nstatic int nfs4_xdr_enc_readlink(struct rpc_rqst *req, __be32 *p, const struct nfs4_readlink *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 2,\n\t};\n\tstruct rpc_auth *auth = req->rq_task->tk_msg.rpc_cred->cr_auth;\n\tunsigned int replen;\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fh);\n\tif(status)\n\t\tgoto out;\n\tstatus = encode_readlink(&xdr, args, req);\n\n\t/* set up reply kvec\n\t *    toplevel_status + taglen + rescount + OP_PUTFH + status\n\t *      + OP_READLINK + status + string length = 8\n\t */\n\treplen = (RPC_REPHDRSIZE + auth->au_rslack + NFS4_dec_readlink_sz) << 2;\n\txdr_inline_pages(&req->rq_rcv_buf, replen, args->pages,\n\t\t\targs->pgbase, args->pglen);\n\nout:\n\treturn status;\n}\n\n/*\n * Encode a READDIR request\n */\nstatic int nfs4_xdr_enc_readdir(struct rpc_rqst *req, __be32 *p, const struct nfs4_readdir_arg *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 2,\n\t};\n\tstruct rpc_auth *auth = req->rq_task->tk_msg.rpc_cred->cr_auth;\n\tint replen;\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fh);\n\tif(status)\n\t\tgoto out;\n\tstatus = encode_readdir(&xdr, args, req);\n\n\t/* set up reply kvec\n\t *    toplevel_status + taglen + rescount + OP_PUTFH + status\n\t *      + OP_READDIR + status + verifer(2)  = 9\n\t */\n\treplen = (RPC_REPHDRSIZE + auth->au_rslack + NFS4_dec_readdir_sz) << 2;\n\txdr_inline_pages(&req->rq_rcv_buf, replen, args->pages,\n\t\t\t args->pgbase, args->count);\n\tdprintk(\"%s: inlined page args = (%u, %p, %u, %u)\\n\",\n\t\t\t__func__, replen, args->pages,\n\t\t\targs->pgbase, args->count);\n\nout:\n\treturn status;\n}\n\n/*\n * Encode a READ request\n */\nstatic int nfs4_xdr_enc_read(struct rpc_rqst *req, __be32 *p, struct nfs_readargs *args)\n{\n\tstruct rpc_auth *auth = req->rq_task->tk_msg.rpc_cred->cr_auth;\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 2,\n\t};\n\tint replen, status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fh);\n\tif (status)\n\t\tgoto out;\n\tstatus = encode_read(&xdr, args);\n\tif (status)\n\t\tgoto out;\n\n\t/* set up reply kvec\n\t *    toplevel status + taglen=0 + rescount + OP_PUTFH + status\n\t *       + OP_READ + status + eof + datalen = 9\n\t */\n\treplen = (RPC_REPHDRSIZE + auth->au_rslack + NFS4_dec_read_sz) << 2;\n\txdr_inline_pages(&req->rq_rcv_buf, replen,\n\t\t\t args->pages, args->pgbase, args->count);\n\treq->rq_rcv_buf.flags |= XDRBUF_READ;\nout:\n\treturn status;\n}\n\n/*\n * Encode an SETATTR request\n */\nstatic int nfs4_xdr_enc_setattr(struct rpc_rqst *req, __be32 *p, struct nfs_setattrargs *args)\n\n{\n        struct xdr_stream xdr;\n        struct compound_hdr hdr = {\n                .nops   = 3,\n        };\n        int status;\n\n        xdr_init_encode(&xdr, &req->rq_snd_buf, p);\n        encode_compound_hdr(&xdr, &hdr);\n        status = encode_putfh(&xdr, args->fh);\n        if(status)\n                goto out;\n        status = encode_setattr(&xdr, args, args->server);\n        if(status)\n                goto out;\n\tstatus = encode_getfattr(&xdr, args->bitmask);\nout:\n        return status;\n}\n\n/*\n * Encode a GETACL request\n */\nstatic int\nnfs4_xdr_enc_getacl(struct rpc_rqst *req, __be32 *p,\n\t\tstruct nfs_getaclargs *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct rpc_auth *auth = req->rq_task->tk_msg.rpc_cred->cr_auth;\n\tstruct compound_hdr hdr = {\n\t\t.nops   = 2,\n\t};\n\tint replen, status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fh);\n\tif (status)\n\t\tgoto out;\n\tstatus = encode_getattr_two(&xdr, FATTR4_WORD0_ACL, 0);\n\t/* set up reply buffer: */\n\treplen = (RPC_REPHDRSIZE + auth->au_rslack + NFS4_dec_getacl_sz) << 2;\n\txdr_inline_pages(&req->rq_rcv_buf, replen,\n\t\targs->acl_pages, args->acl_pgbase, args->acl_len);\nout:\n\treturn status;\n}\n\n/*\n * Encode a WRITE request\n */\nstatic int nfs4_xdr_enc_write(struct rpc_rqst *req, __be32 *p, struct nfs_writeargs *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 3,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fh);\n\tif (status)\n\t\tgoto out;\n\tstatus = encode_write(&xdr, args);\n\tif (status)\n\t\tgoto out;\n\treq->rq_snd_buf.flags |= XDRBUF_WRITE;\n\tstatus = encode_getfattr(&xdr, args->bitmask);\nout:\n\treturn status;\n}\n\n/*\n *  a COMMIT request\n */\nstatic int nfs4_xdr_enc_commit(struct rpc_rqst *req, __be32 *p, struct nfs_writeargs *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 3,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fh);\n\tif (status)\n\t\tgoto out;\n\tstatus = encode_commit(&xdr, args);\n\tif (status)\n\t\tgoto out;\n\tstatus = encode_getfattr(&xdr, args->bitmask);\nout:\n\treturn status;\n}\n\n/*\n * FSINFO request\n */\nstatic int nfs4_xdr_enc_fsinfo(struct rpc_rqst *req, __be32 *p, struct nfs4_fsinfo_arg *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops\t= 2,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fh);\n\tif (!status)\n\t\tstatus = encode_fsinfo(&xdr, args->bitmask);\n\treturn status;\n}\n\n/*\n * a PATHCONF request\n */\nstatic int nfs4_xdr_enc_pathconf(struct rpc_rqst *req, __be32 *p, const struct nfs4_pathconf_arg *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 2,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fh);\n\tif (!status)\n\t\tstatus = encode_getattr_one(&xdr,\n\t\t\t\targs->bitmask[0] & nfs4_pathconf_bitmap[0]);\n\treturn status;\n}\n\n/*\n * a STATFS request\n */\nstatic int nfs4_xdr_enc_statfs(struct rpc_rqst *req, __be32 *p, const struct nfs4_statfs_arg *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 2,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fh);\n\tif (status == 0)\n\t\tstatus = encode_getattr_two(&xdr,\n\t\t\t\targs->bitmask[0] & nfs4_statfs_bitmap[0],\n\t\t\t\targs->bitmask[1] & nfs4_statfs_bitmap[1]);\n\treturn status;\n}\n\n/*\n * GETATTR_BITMAP request\n */\nstatic int nfs4_xdr_enc_server_caps(struct rpc_rqst *req, __be32 *p, const struct nfs_fh *fhandle)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 2,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, fhandle);\n\tif (status == 0)\n\t\tstatus = encode_getattr_one(&xdr, FATTR4_WORD0_SUPPORTED_ATTRS|\n\t\t\t\tFATTR4_WORD0_LINK_SUPPORT|\n\t\t\t\tFATTR4_WORD0_SYMLINK_SUPPORT|\n\t\t\t\tFATTR4_WORD0_ACLSUPPORT);\n\treturn status;\n}\n\n/*\n * a RENEW request\n */\nstatic int nfs4_xdr_enc_renew(struct rpc_rqst *req, __be32 *p, struct nfs_client *clp)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops\t= 1,\n\t};\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\treturn encode_renew(&xdr, clp);\n}\n\n/*\n * a SETCLIENTID request\n */\nstatic int nfs4_xdr_enc_setclientid(struct rpc_rqst *req, __be32 *p, struct nfs4_setclientid *sc)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops\t= 1,\n\t};\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\treturn encode_setclientid(&xdr, sc);\n}\n\n/*\n * a SETCLIENTID_CONFIRM request\n */\nstatic int nfs4_xdr_enc_setclientid_confirm(struct rpc_rqst *req, __be32 *p, struct nfs_client *clp)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops\t= 3,\n\t};\n\tconst u32 lease_bitmap[2] = { FATTR4_WORD0_LEASE_TIME, 0 };\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_setclientid_confirm(&xdr, clp);\n\tif (!status)\n\t\tstatus = encode_putrootfh(&xdr);\n\tif (!status)\n\t\tstatus = encode_fsinfo(&xdr, lease_bitmap);\n\treturn status;\n}\n\n/*\n * DELEGRETURN request\n */\nstatic int nfs4_xdr_enc_delegreturn(struct rpc_rqst *req, __be32 *p, const struct nfs4_delegreturnargs *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 3,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fhandle);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = encode_delegreturn(&xdr, args->stateid);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = encode_getfattr(&xdr, args->bitmask);\nout:\n\treturn status;\n}\n\n/*\n * Encode FS_LOCATIONS request\n */\nstatic int nfs4_xdr_enc_fs_locations(struct rpc_rqst *req, __be32 *p, struct nfs4_fs_locations_arg *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 3,\n\t};\n\tstruct rpc_auth *auth = req->rq_task->tk_msg.rpc_cred->cr_auth;\n\tint replen;\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tif ((status = encode_putfh(&xdr, args->dir_fh)) != 0)\n\t\tgoto out;\n\tif ((status = encode_lookup(&xdr, args->name)) != 0)\n\t\tgoto out;\n\tif ((status = encode_fs_locations(&xdr, args->bitmask)) != 0)\n\t\tgoto out;\n\t/* set up reply\n\t *   toplevel_status + OP_PUTFH + status\n\t *   + OP_LOOKUP + status + OP_GETATTR + status = 7\n\t */\n\treplen = (RPC_REPHDRSIZE + auth->au_rslack + 7) << 2;\n\txdr_inline_pages(&req->rq_rcv_buf, replen, &args->page,\n\t\t\t0, PAGE_SIZE);\nout:\n\treturn status;\n}\n\n/*\n * START OF \"GENERIC\" DECODE ROUTINES.\n *   These may look a little ugly since they are imported from a \"generic\"\n * set of XDR encode/decode routines which are intended to be shared by\n * all of our NFSv4 implementations (OpenBSD, MacOS X...).\n *\n * If the pain of reading these is too great, it should be a straightforward\n * task to translate them into Linux-specific versions which are more\n * consistent with the style used in NFSv2/v3...\n */\n#define READ32(x)         (x) = ntohl(*p++)\n#define READ64(x)         do {\t\t\t\\\n\t(x) = (u64)ntohl(*p++) << 32;\t\t\\\n\t(x) |= ntohl(*p++);\t\t\t\\\n} while (0)\n#define READTIME(x)       do {\t\t\t\\\n\tp++;\t\t\t\t\t\\\n\t(x.tv_sec) = ntohl(*p++);\t\t\\\n\t(x.tv_nsec) = ntohl(*p++);\t\t\\\n} while (0)\n#define COPYMEM(x,nbytes) do {\t\t\t\\\n\tmemcpy((x), p, nbytes);\t\t\t\\\n\tp += XDR_QUADLEN(nbytes);\t\t\\\n} while (0)\n\n#define READ_BUF(nbytes)  do { \\\n\tp = xdr_inline_decode(xdr, nbytes); \\\n\tif (unlikely(!p)) { \\\n\t\tdprintk(\"nfs: %s: prematurely hit end of receive\" \\\n\t\t\t\t\" buffer\\n\", __func__); \\\n\t\tdprintk(\"nfs: %s: xdr->p=%p, bytes=%u, xdr->end=%p\\n\", \\\n\t\t\t\t__func__, xdr->p, nbytes, xdr->end); \\\n\t\treturn -EIO; \\\n\t} \\\n} while (0)\n\nstatic int decode_opaque_inline(struct xdr_stream *xdr, unsigned int *len, char **string)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\tREAD32(*len);\n\tREAD_BUF(*len);\n\t*string = (char *)p;\n\treturn 0;\n}\n\nstatic int decode_compound_hdr(struct xdr_stream *xdr, struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tREAD_BUF(8);\n\tREAD32(hdr->status);\n\tREAD32(hdr->taglen);\n\t\n\tREAD_BUF(hdr->taglen + 4);\n\thdr->tag = (char *)p;\n\tp += XDR_QUADLEN(hdr->taglen);\n\tREAD32(hdr->nops);\n\treturn 0;\n}\n\nstatic int decode_op_hdr(struct xdr_stream *xdr, enum nfs_opnum4 expected)\n{\n\t__be32 *p;\n\tuint32_t opnum;\n\tint32_t nfserr;\n\n\tREAD_BUF(8);\n\tREAD32(opnum);\n\tif (opnum != expected) {\n\t\tdprintk(\"nfs: Server returned operation\"\n\t\t\t\" %d but we issued a request for %d\\n\",\n\t\t\t\topnum, expected);\n\t\treturn -EIO;\n\t}\n\tREAD32(nfserr);\n\tif (nfserr != NFS_OK)\n\t\treturn nfs4_stat_to_errno(nfserr);\n\treturn 0;\n}\n\n/* Dummy routine */\nstatic int decode_ace(struct xdr_stream *xdr, void *ace, struct nfs_client *clp)\n{\n\t__be32 *p;\n\tunsigned int strlen;\n\tchar *str;\n\n\tREAD_BUF(12);\n\treturn decode_opaque_inline(xdr, &strlen, &str);\n}\n\nstatic int decode_attr_bitmap(struct xdr_stream *xdr, uint32_t *bitmap)\n{\n\tuint32_t bmlen;\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\tREAD32(bmlen);\n\n\tbitmap[0] = bitmap[1] = 0;\n\tREAD_BUF((bmlen << 2));\n\tif (bmlen > 0) {\n\t\tREAD32(bitmap[0]);\n\t\tif (bmlen > 1)\n\t\t\tREAD32(bitmap[1]);\n\t}\n\treturn 0;\n}\n\nstatic inline int decode_attr_length(struct xdr_stream *xdr, uint32_t *attrlen, __be32 **savep)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\tREAD32(*attrlen);\n\t*savep = xdr->p;\n\treturn 0;\n}\n\nstatic int decode_attr_supported(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *bitmask)\n{\n\tif (likely(bitmap[0] & FATTR4_WORD0_SUPPORTED_ATTRS)) {\n\t\tdecode_attr_bitmap(xdr, bitmask);\n\t\tbitmap[0] &= ~FATTR4_WORD0_SUPPORTED_ATTRS;\n\t} else\n\t\tbitmask[0] = bitmask[1] = 0;\n\tdprintk(\"%s: bitmask=%08x:%08x\\n\", __func__, bitmask[0], bitmask[1]);\n\treturn 0;\n}\n\nstatic int decode_attr_type(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *type)\n{\n\t__be32 *p;\n\n\t*type = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_TYPE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_TYPE)) {\n\t\tREAD_BUF(4);\n\t\tREAD32(*type);\n\t\tif (*type < NF4REG || *type > NF4NAMEDATTR) {\n\t\t\tdprintk(\"%s: bad type %d\\n\", __func__, *type);\n\t\t\treturn -EIO;\n\t\t}\n\t\tbitmap[0] &= ~FATTR4_WORD0_TYPE;\n\t}\n\tdprintk(\"%s: type=0%o\\n\", __func__, nfs_type2fmt[*type].nfs2type);\n\treturn 0;\n}\n\nstatic int decode_attr_change(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *change)\n{\n\t__be32 *p;\n\n\t*change = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_CHANGE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_CHANGE)) {\n\t\tREAD_BUF(8);\n\t\tREAD64(*change);\n\t\tbitmap[0] &= ~FATTR4_WORD0_CHANGE;\n\t}\n\tdprintk(\"%s: change attribute=%Lu\\n\", __func__,\n\t\t\t(unsigned long long)*change);\n\treturn 0;\n}\n\nstatic int decode_attr_size(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *size)\n{\n\t__be32 *p;\n\n\t*size = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_SIZE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_SIZE)) {\n\t\tREAD_BUF(8);\n\t\tREAD64(*size);\n\t\tbitmap[0] &= ~FATTR4_WORD0_SIZE;\n\t}\n\tdprintk(\"%s: file size=%Lu\\n\", __func__, (unsigned long long)*size);\n\treturn 0;\n}\n\nstatic int decode_attr_link_support(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *res)\n{\n\t__be32 *p;\n\n\t*res = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_LINK_SUPPORT - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_LINK_SUPPORT)) {\n\t\tREAD_BUF(4);\n\t\tREAD32(*res);\n\t\tbitmap[0] &= ~FATTR4_WORD0_LINK_SUPPORT;\n\t}\n\tdprintk(\"%s: link support=%s\\n\", __func__, *res == 0 ? \"false\" : \"true\");\n\treturn 0;\n}\n\nstatic int decode_attr_symlink_support(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *res)\n{\n\t__be32 *p;\n\n\t*res = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_SYMLINK_SUPPORT - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_SYMLINK_SUPPORT)) {\n\t\tREAD_BUF(4);\n\t\tREAD32(*res);\n\t\tbitmap[0] &= ~FATTR4_WORD0_SYMLINK_SUPPORT;\n\t}\n\tdprintk(\"%s: symlink support=%s\\n\", __func__, *res == 0 ? \"false\" : \"true\");\n\treturn 0;\n}\n\nstatic int decode_attr_fsid(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_fsid *fsid)\n{\n\t__be32 *p;\n\n\tfsid->major = 0;\n\tfsid->minor = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_FSID - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_FSID)) {\n\t\tREAD_BUF(16);\n\t\tREAD64(fsid->major);\n\t\tREAD64(fsid->minor);\n\t\tbitmap[0] &= ~FATTR4_WORD0_FSID;\n\t}\n\tdprintk(\"%s: fsid=(0x%Lx/0x%Lx)\\n\", __func__,\n\t\t\t(unsigned long long)fsid->major,\n\t\t\t(unsigned long long)fsid->minor);\n\treturn 0;\n}\n\nstatic int decode_attr_lease_time(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *res)\n{\n\t__be32 *p;\n\n\t*res = 60;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_LEASE_TIME - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_LEASE_TIME)) {\n\t\tREAD_BUF(4);\n\t\tREAD32(*res);\n\t\tbitmap[0] &= ~FATTR4_WORD0_LEASE_TIME;\n\t}\n\tdprintk(\"%s: file size=%u\\n\", __func__, (unsigned int)*res);\n\treturn 0;\n}\n\nstatic int decode_attr_aclsupport(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *res)\n{\n\t__be32 *p;\n\n\t*res = ACL4_SUPPORT_ALLOW_ACL|ACL4_SUPPORT_DENY_ACL;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_ACLSUPPORT - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_ACLSUPPORT)) {\n\t\tREAD_BUF(4);\n\t\tREAD32(*res);\n\t\tbitmap[0] &= ~FATTR4_WORD0_ACLSUPPORT;\n\t}\n\tdprintk(\"%s: ACLs supported=%u\\n\", __func__, (unsigned int)*res);\n\treturn 0;\n}\n\nstatic int decode_attr_fileid(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *fileid)\n{\n\t__be32 *p;\n\n\t*fileid = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_FILEID - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_FILEID)) {\n\t\tREAD_BUF(8);\n\t\tREAD64(*fileid);\n\t\tbitmap[0] &= ~FATTR4_WORD0_FILEID;\n\t}\n\tdprintk(\"%s: fileid=%Lu\\n\", __func__, (unsigned long long)*fileid);\n\treturn 0;\n}\n\nstatic int decode_attr_mounted_on_fileid(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *fileid)\n{\n\t__be32 *p;\n\n\t*fileid = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_MOUNTED_ON_FILEID - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_MOUNTED_ON_FILEID)) {\n\t\tREAD_BUF(8);\n\t\tREAD64(*fileid);\n\t\tbitmap[1] &= ~FATTR4_WORD1_MOUNTED_ON_FILEID;\n\t}\n\tdprintk(\"%s: fileid=%Lu\\n\", __func__, (unsigned long long)*fileid);\n\treturn 0;\n}\n\nstatic int decode_attr_files_avail(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_FILES_AVAIL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_FILES_AVAIL)) {\n\t\tREAD_BUF(8);\n\t\tREAD64(*res);\n\t\tbitmap[0] &= ~FATTR4_WORD0_FILES_AVAIL;\n\t}\n\tdprintk(\"%s: files avail=%Lu\\n\", __func__, (unsigned long long)*res);\n\treturn status;\n}\n\nstatic int decode_attr_files_free(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_FILES_FREE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_FILES_FREE)) {\n\t\tREAD_BUF(8);\n\t\tREAD64(*res);\n\t\tbitmap[0] &= ~FATTR4_WORD0_FILES_FREE;\n\t}\n\tdprintk(\"%s: files free=%Lu\\n\", __func__, (unsigned long long)*res);\n\treturn status;\n}\n\nstatic int decode_attr_files_total(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_FILES_TOTAL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_FILES_TOTAL)) {\n\t\tREAD_BUF(8);\n\t\tREAD64(*res);\n\t\tbitmap[0] &= ~FATTR4_WORD0_FILES_TOTAL;\n\t}\n\tdprintk(\"%s: files total=%Lu\\n\", __func__, (unsigned long long)*res);\n\treturn status;\n}\n\nstatic int decode_pathname(struct xdr_stream *xdr, struct nfs4_pathname *path)\n{\n\tu32 n;\n\t__be32 *p;\n\tint status = 0;\n\n\tREAD_BUF(4);\n\tREAD32(n);\n\tif (n == 0)\n\t\tgoto root_path;\n\tdprintk(\"path \");\n\tpath->ncomponents = 0;\n\twhile (path->ncomponents < n) {\n\t\tstruct nfs4_string *component = &path->components[path->ncomponents];\n\t\tstatus = decode_opaque_inline(xdr, &component->len, &component->data);\n\t\tif (unlikely(status != 0))\n\t\t\tgoto out_eio;\n\t\tif (path->ncomponents != n)\n\t\t\tdprintk(\"/\");\n\t\tdprintk(\"%s\", component->data);\n\t\tif (path->ncomponents < NFS4_PATHNAME_MAXCOMPONENTS)\n\t\t\tpath->ncomponents++;\n\t\telse {\n\t\t\tdprintk(\"cannot parse %d components in path\\n\", n);\n\t\t\tgoto out_eio;\n\t\t}\n\t}\nout:\n\tdprintk(\"\\n\");\n\treturn status;\nroot_path:\n/* a root pathname is sent as a zero component4 */\n\tpath->ncomponents = 1;\n\tpath->components[0].len=0;\n\tpath->components[0].data=NULL;\n\tdprintk(\"path /\\n\");\n\tgoto out;\nout_eio:\n\tdprintk(\" status %d\", status);\n\tstatus = -EIO;\n\tgoto out;\n}\n\nstatic int decode_attr_fs_locations(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs4_fs_locations *res)\n{\n\tint n;\n\t__be32 *p;\n\tint status = -EIO;\n\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_FS_LOCATIONS -1U)))\n\t\tgoto out;\n\tstatus = 0;\n\tif (unlikely(!(bitmap[0] & FATTR4_WORD0_FS_LOCATIONS)))\n\t\tgoto out;\n\tdprintk(\"%s: fsroot \", __func__);\n\tstatus = decode_pathname(xdr, &res->fs_path);\n\tif (unlikely(status != 0))\n\t\tgoto out;\n\tREAD_BUF(4);\n\tREAD32(n);\n\tif (n <= 0)\n\t\tgoto out_eio;\n\tres->nlocations = 0;\n\twhile (res->nlocations < n) {\n\t\tu32 m;\n\t\tstruct nfs4_fs_location *loc = &res->locations[res->nlocations];\n\n\t\tREAD_BUF(4);\n\t\tREAD32(m);\n\n\t\tloc->nservers = 0;\n\t\tdprintk(\"%s: servers \", __func__);\n\t\twhile (loc->nservers < m) {\n\t\t\tstruct nfs4_string *server = &loc->servers[loc->nservers];\n\t\t\tstatus = decode_opaque_inline(xdr, &server->len, &server->data);\n\t\t\tif (unlikely(status != 0))\n\t\t\t\tgoto out_eio;\n\t\t\tdprintk(\"%s \", server->data);\n\t\t\tif (loc->nservers < NFS4_FS_LOCATION_MAXSERVERS)\n\t\t\t\tloc->nservers++;\n\t\t\telse {\n\t\t\t\tunsigned int i;\n\t\t\t\tdprintk(\"%s: using first %u of %u servers \"\n\t\t\t\t\t\"returned for location %u\\n\",\n\t\t\t\t\t\t__func__,\n\t\t\t\t\t\tNFS4_FS_LOCATION_MAXSERVERS,\n\t\t\t\t\t\tm, res->nlocations);\n\t\t\t\tfor (i = loc->nservers; i < m; i++) {\n\t\t\t\t\tunsigned int len;\n\t\t\t\t\tchar *data;\n\t\t\t\t\tstatus = decode_opaque_inline(xdr, &len, &data);\n\t\t\t\t\tif (unlikely(status != 0))\n\t\t\t\t\t\tgoto out_eio;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstatus = decode_pathname(xdr, &loc->rootpath);\n\t\tif (unlikely(status != 0))\n\t\t\tgoto out_eio;\n\t\tif (res->nlocations < NFS4_FS_LOCATIONS_MAXENTRIES)\n\t\t\tres->nlocations++;\n\t}\nout:\n\tdprintk(\"%s: fs_locations done, error = %d\\n\", __func__, status);\n\treturn status;\nout_eio:\n\tstatus = -EIO;\n\tgoto out;\n}\n\nstatic int decode_attr_maxfilesize(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_MAXFILESIZE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_MAXFILESIZE)) {\n\t\tREAD_BUF(8);\n\t\tREAD64(*res);\n\t\tbitmap[0] &= ~FATTR4_WORD0_MAXFILESIZE;\n\t}\n\tdprintk(\"%s: maxfilesize=%Lu\\n\", __func__, (unsigned long long)*res);\n\treturn status;\n}\n\nstatic int decode_attr_maxlink(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *maxlink)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*maxlink = 1;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_MAXLINK - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_MAXLINK)) {\n\t\tREAD_BUF(4);\n\t\tREAD32(*maxlink);\n\t\tbitmap[0] &= ~FATTR4_WORD0_MAXLINK;\n\t}\n\tdprintk(\"%s: maxlink=%u\\n\", __func__, *maxlink);\n\treturn status;\n}\n\nstatic int decode_attr_maxname(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *maxname)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*maxname = 1024;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_MAXNAME - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_MAXNAME)) {\n\t\tREAD_BUF(4);\n\t\tREAD32(*maxname);\n\t\tbitmap[0] &= ~FATTR4_WORD0_MAXNAME;\n\t}\n\tdprintk(\"%s: maxname=%u\\n\", __func__, *maxname);\n\treturn status;\n}\n\nstatic int decode_attr_maxread(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 1024;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_MAXREAD - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_MAXREAD)) {\n\t\tuint64_t maxread;\n\t\tREAD_BUF(8);\n\t\tREAD64(maxread);\n\t\tif (maxread > 0x7FFFFFFF)\n\t\t\tmaxread = 0x7FFFFFFF;\n\t\t*res = (uint32_t)maxread;\n\t\tbitmap[0] &= ~FATTR4_WORD0_MAXREAD;\n\t}\n\tdprintk(\"%s: maxread=%lu\\n\", __func__, (unsigned long)*res);\n\treturn status;\n}\n\nstatic int decode_attr_maxwrite(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 1024;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_MAXWRITE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_MAXWRITE)) {\n\t\tuint64_t maxwrite;\n\t\tREAD_BUF(8);\n\t\tREAD64(maxwrite);\n\t\tif (maxwrite > 0x7FFFFFFF)\n\t\t\tmaxwrite = 0x7FFFFFFF;\n\t\t*res = (uint32_t)maxwrite;\n\t\tbitmap[0] &= ~FATTR4_WORD0_MAXWRITE;\n\t}\n\tdprintk(\"%s: maxwrite=%lu\\n\", __func__, (unsigned long)*res);\n\treturn status;\n}\n\nstatic int decode_attr_mode(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *mode)\n{\n\t__be32 *p;\n\n\t*mode = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_MODE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_MODE)) {\n\t\tREAD_BUF(4);\n\t\tREAD32(*mode);\n\t\t*mode &= ~S_IFMT;\n\t\tbitmap[1] &= ~FATTR4_WORD1_MODE;\n\t}\n\tdprintk(\"%s: file mode=0%o\\n\", __func__, (unsigned int)*mode);\n\treturn 0;\n}\n\nstatic int decode_attr_nlink(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *nlink)\n{\n\t__be32 *p;\n\n\t*nlink = 1;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_NUMLINKS - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_NUMLINKS)) {\n\t\tREAD_BUF(4);\n\t\tREAD32(*nlink);\n\t\tbitmap[1] &= ~FATTR4_WORD1_NUMLINKS;\n\t}\n\tdprintk(\"%s: nlink=%u\\n\", __func__, (unsigned int)*nlink);\n\treturn 0;\n}\n\nstatic int decode_attr_owner(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_client *clp, uint32_t *uid)\n{\n\tuint32_t len;\n\t__be32 *p;\n\n\t*uid = -2;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_OWNER - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_OWNER)) {\n\t\tREAD_BUF(4);\n\t\tREAD32(len);\n\t\tREAD_BUF(len);\n\t\tif (len < XDR_MAX_NETOBJ) {\n\t\t\tif (nfs_map_name_to_uid(clp, (char *)p, len, uid) != 0)\n\t\t\t\tdprintk(\"%s: nfs_map_name_to_uid failed!\\n\",\n\t\t\t\t\t\t__func__);\n\t\t} else\n\t\t\tdprintk(\"%s: name too long (%u)!\\n\",\n\t\t\t\t\t__func__, len);\n\t\tbitmap[1] &= ~FATTR4_WORD1_OWNER;\n\t}\n\tdprintk(\"%s: uid=%d\\n\", __func__, (int)*uid);\n\treturn 0;\n}\n\nstatic int decode_attr_group(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_client *clp, uint32_t *gid)\n{\n\tuint32_t len;\n\t__be32 *p;\n\n\t*gid = -2;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_OWNER_GROUP - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_OWNER_GROUP)) {\n\t\tREAD_BUF(4);\n\t\tREAD32(len);\n\t\tREAD_BUF(len);\n\t\tif (len < XDR_MAX_NETOBJ) {\n\t\t\tif (nfs_map_group_to_gid(clp, (char *)p, len, gid) != 0)\n\t\t\t\tdprintk(\"%s: nfs_map_group_to_gid failed!\\n\",\n\t\t\t\t\t\t__func__);\n\t\t} else\n\t\t\tdprintk(\"%s: name too long (%u)!\\n\",\n\t\t\t\t\t__func__, len);\n\t\tbitmap[1] &= ~FATTR4_WORD1_OWNER_GROUP;\n\t}\n\tdprintk(\"%s: gid=%d\\n\", __func__, (int)*gid);\n\treturn 0;\n}\n\nstatic int decode_attr_rdev(struct xdr_stream *xdr, uint32_t *bitmap, dev_t *rdev)\n{\n\tuint32_t major = 0, minor = 0;\n\t__be32 *p;\n\n\t*rdev = MKDEV(0,0);\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_RAWDEV - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_RAWDEV)) {\n\t\tdev_t tmp;\n\n\t\tREAD_BUF(8);\n\t\tREAD32(major);\n\t\tREAD32(minor);\n\t\ttmp = MKDEV(major, minor);\n\t\tif (MAJOR(tmp) == major && MINOR(tmp) == minor)\n\t\t\t*rdev = tmp;\n\t\tbitmap[1] &= ~ FATTR4_WORD1_RAWDEV;\n\t}\n\tdprintk(\"%s: rdev=(0x%x:0x%x)\\n\", __func__, major, minor);\n\treturn 0;\n}\n\nstatic int decode_attr_space_avail(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_SPACE_AVAIL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_SPACE_AVAIL)) {\n\t\tREAD_BUF(8);\n\t\tREAD64(*res);\n\t\tbitmap[1] &= ~FATTR4_WORD1_SPACE_AVAIL;\n\t}\n\tdprintk(\"%s: space avail=%Lu\\n\", __func__, (unsigned long long)*res);\n\treturn status;\n}\n\nstatic int decode_attr_space_free(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_SPACE_FREE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_SPACE_FREE)) {\n\t\tREAD_BUF(8);\n\t\tREAD64(*res);\n\t\tbitmap[1] &= ~FATTR4_WORD1_SPACE_FREE;\n\t}\n\tdprintk(\"%s: space free=%Lu\\n\", __func__, (unsigned long long)*res);\n\treturn status;\n}\n\nstatic int decode_attr_space_total(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_SPACE_TOTAL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_SPACE_TOTAL)) {\n\t\tREAD_BUF(8);\n\t\tREAD64(*res);\n\t\tbitmap[1] &= ~FATTR4_WORD1_SPACE_TOTAL;\n\t}\n\tdprintk(\"%s: space total=%Lu\\n\", __func__, (unsigned long long)*res);\n\treturn status;\n}\n\nstatic int decode_attr_space_used(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *used)\n{\n\t__be32 *p;\n\n\t*used = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_SPACE_USED - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_SPACE_USED)) {\n\t\tREAD_BUF(8);\n\t\tREAD64(*used);\n\t\tbitmap[1] &= ~FATTR4_WORD1_SPACE_USED;\n\t}\n\tdprintk(\"%s: space used=%Lu\\n\", __func__,\n\t\t\t(unsigned long long)*used);\n\treturn 0;\n}\n\nstatic int decode_attr_time(struct xdr_stream *xdr, struct timespec *time)\n{\n\t__be32 *p;\n\tuint64_t sec;\n\tuint32_t nsec;\n\n\tREAD_BUF(12);\n\tREAD64(sec);\n\tREAD32(nsec);\n\ttime->tv_sec = (time_t)sec;\n\ttime->tv_nsec = (long)nsec;\n\treturn 0;\n}\n\nstatic int decode_attr_time_access(struct xdr_stream *xdr, uint32_t *bitmap, struct timespec *time)\n{\n\tint status = 0;\n\n\ttime->tv_sec = 0;\n\ttime->tv_nsec = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_TIME_ACCESS - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_TIME_ACCESS)) {\n\t\tstatus = decode_attr_time(xdr, time);\n\t\tbitmap[1] &= ~FATTR4_WORD1_TIME_ACCESS;\n\t}\n\tdprintk(\"%s: atime=%ld\\n\", __func__, (long)time->tv_sec);\n\treturn status;\n}\n\nstatic int decode_attr_time_metadata(struct xdr_stream *xdr, uint32_t *bitmap, struct timespec *time)\n{\n\tint status = 0;\n\n\ttime->tv_sec = 0;\n\ttime->tv_nsec = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_TIME_METADATA - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_TIME_METADATA)) {\n\t\tstatus = decode_attr_time(xdr, time);\n\t\tbitmap[1] &= ~FATTR4_WORD1_TIME_METADATA;\n\t}\n\tdprintk(\"%s: ctime=%ld\\n\", __func__, (long)time->tv_sec);\n\treturn status;\n}\n\nstatic int decode_attr_time_modify(struct xdr_stream *xdr, uint32_t *bitmap, struct timespec *time)\n{\n\tint status = 0;\n\n\ttime->tv_sec = 0;\n\ttime->tv_nsec = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_TIME_MODIFY - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_TIME_MODIFY)) {\n\t\tstatus = decode_attr_time(xdr, time);\n\t\tbitmap[1] &= ~FATTR4_WORD1_TIME_MODIFY;\n\t}\n\tdprintk(\"%s: mtime=%ld\\n\", __func__, (long)time->tv_sec);\n\treturn status;\n}\n\nstatic int verify_attr_len(struct xdr_stream *xdr, __be32 *savep, uint32_t attrlen)\n{\n\tunsigned int attrwords = XDR_QUADLEN(attrlen);\n\tunsigned int nwords = xdr->p - savep;\n\n\tif (unlikely(attrwords != nwords)) {\n\t\tdprintk(\"%s: server returned incorrect attribute length: \"\n\t\t\t\"%u %c %u\\n\",\n\t\t\t\t__func__,\n\t\t\t\tattrwords << 2,\n\t\t\t\t(attrwords < nwords) ? '<' : '>',\n\t\t\t\tnwords << 2);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int decode_change_info(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)\n{\n\t__be32 *p;\n\n\tREAD_BUF(20);\n\tREAD32(cinfo->atomic);\n\tREAD64(cinfo->before);\n\tREAD64(cinfo->after);\n\treturn 0;\n}\n\nstatic int decode_access(struct xdr_stream *xdr, struct nfs4_accessres *access)\n{\n\t__be32 *p;\n\tuint32_t supp, acc;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_ACCESS);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(8);\n\tREAD32(supp);\n\tREAD32(acc);\n\taccess->supported = supp;\n\taccess->access = acc;\n\treturn 0;\n}\n\nstatic int decode_close(struct xdr_stream *xdr, struct nfs_closeres *res)\n{\n\t__be32 *p;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_CLOSE);\n\tif (status != -EIO)\n\t\tnfs_increment_open_seqid(status, res->seqid);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(NFS4_STATEID_SIZE);\n\tCOPYMEM(res->stateid.data, NFS4_STATEID_SIZE);\n\treturn 0;\n}\n\nstatic int decode_commit(struct xdr_stream *xdr, struct nfs_writeres *res)\n{\n\t__be32 *p;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_COMMIT);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(8);\n\tCOPYMEM(res->verf->verifier, 8);\n\treturn 0;\n}\n\nstatic int decode_create(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)\n{\n\t__be32 *p;\n\tuint32_t bmlen;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_CREATE);\n\tif (status)\n\t\treturn status;\n\tif ((status = decode_change_info(xdr, cinfo)))\n\t\treturn status;\n\tREAD_BUF(4);\n\tREAD32(bmlen);\n\tREAD_BUF(bmlen << 2);\n\treturn 0;\n}\n\nstatic int decode_server_caps(struct xdr_stream *xdr, struct nfs4_server_caps_res *res)\n{\n\t__be32 *savep;\n\tuint32_t attrlen, \n\t\t bitmap[2] = {0};\n\tint status;\n\n\tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_supported(xdr, bitmap, res->attr_bitmask)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_link_support(xdr, bitmap, &res->has_links)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_symlink_support(xdr, bitmap, &res->has_symlinks)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_aclsupport(xdr, bitmap, &res->acl_bitmask)) != 0)\n\t\tgoto xdr_error;\n\tstatus = verify_attr_len(xdr, savep, attrlen);\nxdr_error:\n\tdprintk(\"%s: xdr returned %d!\\n\", __func__, -status);\n\treturn status;\n}\n\t\nstatic int decode_statfs(struct xdr_stream *xdr, struct nfs_fsstat *fsstat)\n{\n\t__be32 *savep;\n\tuint32_t attrlen, \n\t\t bitmap[2] = {0};\n\tint status;\n\t\n\tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n\t\tgoto xdr_error;\n\n\tif ((status = decode_attr_files_avail(xdr, bitmap, &fsstat->afiles)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_files_free(xdr, bitmap, &fsstat->ffiles)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_files_total(xdr, bitmap, &fsstat->tfiles)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_space_avail(xdr, bitmap, &fsstat->abytes)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_space_free(xdr, bitmap, &fsstat->fbytes)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_space_total(xdr, bitmap, &fsstat->tbytes)) != 0)\n\t\tgoto xdr_error;\n\n\tstatus = verify_attr_len(xdr, savep, attrlen);\nxdr_error:\n\tdprintk(\"%s: xdr returned %d!\\n\", __func__, -status);\n\treturn status;\n}\n\nstatic int decode_pathconf(struct xdr_stream *xdr, struct nfs_pathconf *pathconf)\n{\n\t__be32 *savep;\n\tuint32_t attrlen, \n\t\t bitmap[2] = {0};\n\tint status;\n\t\n\tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n\t\tgoto xdr_error;\n\n\tif ((status = decode_attr_maxlink(xdr, bitmap, &pathconf->max_link)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_maxname(xdr, bitmap, &pathconf->max_namelen)) != 0)\n\t\tgoto xdr_error;\n\n\tstatus = verify_attr_len(xdr, savep, attrlen);\nxdr_error:\n\tdprintk(\"%s: xdr returned %d!\\n\", __func__, -status);\n\treturn status;\n}\n\nstatic int decode_getfattr(struct xdr_stream *xdr, struct nfs_fattr *fattr, const struct nfs_server *server)\n{\n\t__be32 *savep;\n\tuint32_t attrlen,\n\t\t bitmap[2] = {0},\n\t\t type;\n\tint status, fmode = 0;\n\tuint64_t fileid;\n\n\tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n\t\tgoto xdr_error;\n\n\tfattr->bitmap[0] = bitmap[0];\n\tfattr->bitmap[1] = bitmap[1];\n\n\tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n\t\tgoto xdr_error;\n\n\n\tif ((status = decode_attr_type(xdr, bitmap, &type)) != 0)\n\t\tgoto xdr_error;\n\tfattr->type = nfs_type2fmt[type].nfs2type;\n\tfmode = nfs_type2fmt[type].mode;\n\n\tif ((status = decode_attr_change(xdr, bitmap, &fattr->change_attr)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_size(xdr, bitmap, &fattr->size)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_fsid(xdr, bitmap, &fattr->fsid)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_fileid(xdr, bitmap, &fattr->fileid)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_fs_locations(xdr, bitmap, container_of(fattr,\n\t\t\t\t\t\tstruct nfs4_fs_locations,\n\t\t\t\t\t\tfattr))) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_mode(xdr, bitmap, &fattr->mode)) != 0)\n\t\tgoto xdr_error;\n\tfattr->mode |= fmode;\n\tif ((status = decode_attr_nlink(xdr, bitmap, &fattr->nlink)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_owner(xdr, bitmap, server->nfs_client, &fattr->uid)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_group(xdr, bitmap, server->nfs_client, &fattr->gid)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_rdev(xdr, bitmap, &fattr->rdev)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_space_used(xdr, bitmap, &fattr->du.nfs3.used)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_time_access(xdr, bitmap, &fattr->atime)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_time_metadata(xdr, bitmap, &fattr->ctime)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_time_modify(xdr, bitmap, &fattr->mtime)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_mounted_on_fileid(xdr, bitmap, &fileid)) != 0)\n\t\tgoto xdr_error;\n\tif (fattr->fileid == 0 && fileid != 0)\n\t\tfattr->fileid = fileid;\n\tif ((status = verify_attr_len(xdr, savep, attrlen)) == 0)\n\t\tfattr->valid = NFS_ATTR_FATTR | NFS_ATTR_FATTR_V3 | NFS_ATTR_FATTR_V4;\nxdr_error:\n\tdprintk(\"%s: xdr returned %d\\n\", __func__, -status);\n\treturn status;\n}\n\n\nstatic int decode_fsinfo(struct xdr_stream *xdr, struct nfs_fsinfo *fsinfo)\n{\n\t__be32 *savep;\n\tuint32_t attrlen, bitmap[2];\n\tint status;\n\n\tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n\t\tgoto xdr_error;\n\n\tfsinfo->rtmult = fsinfo->wtmult = 512;\t/* ??? */\n\n\tif ((status = decode_attr_lease_time(xdr, bitmap, &fsinfo->lease_time)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_maxfilesize(xdr, bitmap, &fsinfo->maxfilesize)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_maxread(xdr, bitmap, &fsinfo->rtmax)) != 0)\n\t\tgoto xdr_error;\n\tfsinfo->rtpref = fsinfo->dtpref = fsinfo->rtmax;\n\tif ((status = decode_attr_maxwrite(xdr, bitmap, &fsinfo->wtmax)) != 0)\n\t\tgoto xdr_error;\n\tfsinfo->wtpref = fsinfo->wtmax;\n\n\tstatus = verify_attr_len(xdr, savep, attrlen);\nxdr_error:\n\tdprintk(\"%s: xdr returned %d!\\n\", __func__, -status);\n\treturn status;\n}\n\nstatic int decode_getfh(struct xdr_stream *xdr, struct nfs_fh *fh)\n{\n\t__be32 *p;\n\tuint32_t len;\n\tint status;\n\n\t/* Zero handle first to allow comparisons */\n\tmemset(fh, 0, sizeof(*fh));\n\n\tstatus = decode_op_hdr(xdr, OP_GETFH);\n\tif (status)\n\t\treturn status;\n\n\tREAD_BUF(4);\n\tREAD32(len);\n\tif (len > NFS4_FHSIZE)\n\t\treturn -EIO;\n\tfh->size = len;\n\tREAD_BUF(len);\n\tCOPYMEM(fh->data, len);\n\treturn 0;\n}\n\nstatic int decode_link(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)\n{\n\tint status;\n\t\n\tstatus = decode_op_hdr(xdr, OP_LINK);\n\tif (status)\n\t\treturn status;\n\treturn decode_change_info(xdr, cinfo);\n}\n\n/*\n * We create the owner, so we know a proper owner.id length is 4.\n */\nstatic int decode_lock_denied (struct xdr_stream *xdr, struct file_lock *fl)\n{\n\tuint64_t offset, length, clientid;\n\t__be32 *p;\n\tuint32_t namelen, type;\n\n\tREAD_BUF(32);\n\tREAD64(offset);\n\tREAD64(length);\n\tREAD32(type);\n\tif (fl != NULL) {\n\t\tfl->fl_start = (loff_t)offset;\n\t\tfl->fl_end = fl->fl_start + (loff_t)length - 1;\n\t\tif (length == ~(uint64_t)0)\n\t\t\tfl->fl_end = OFFSET_MAX;\n\t\tfl->fl_type = F_WRLCK;\n\t\tif (type & 1)\n\t\t\tfl->fl_type = F_RDLCK;\n\t\tfl->fl_pid = 0;\n\t}\n\tREAD64(clientid);\n\tREAD32(namelen);\n\tREAD_BUF(namelen);\n\treturn -NFS4ERR_DENIED;\n}\n\nstatic int decode_lock(struct xdr_stream *xdr, struct nfs_lock_res *res)\n{\n\t__be32 *p;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_LOCK);\n\tif (status == -EIO)\n\t\tgoto out;\n\tif (status == 0) {\n\t\tREAD_BUF(NFS4_STATEID_SIZE);\n\t\tCOPYMEM(res->stateid.data, NFS4_STATEID_SIZE);\n\t} else if (status == -NFS4ERR_DENIED)\n\t\tstatus = decode_lock_denied(xdr, NULL);\n\tif (res->open_seqid != NULL)\n\t\tnfs_increment_open_seqid(status, res->open_seqid);\n\tnfs_increment_lock_seqid(status, res->lock_seqid);\nout:\n\treturn status;\n}\n\nstatic int decode_lockt(struct xdr_stream *xdr, struct nfs_lockt_res *res)\n{\n\tint status;\n\tstatus = decode_op_hdr(xdr, OP_LOCKT);\n\tif (status == -NFS4ERR_DENIED)\n\t\treturn decode_lock_denied(xdr, res->denied);\n\treturn status;\n}\n\nstatic int decode_locku(struct xdr_stream *xdr, struct nfs_locku_res *res)\n{\n\t__be32 *p;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_LOCKU);\n\tif (status != -EIO)\n\t\tnfs_increment_lock_seqid(status, res->seqid);\n\tif (status == 0) {\n\t\tREAD_BUF(NFS4_STATEID_SIZE);\n\t\tCOPYMEM(res->stateid.data, NFS4_STATEID_SIZE);\n\t}\n\treturn status;\n}\n\nstatic int decode_lookup(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_LOOKUP);\n}\n\n/* This is too sick! */\nstatic int decode_space_limit(struct xdr_stream *xdr, u64 *maxsize)\n{\n        __be32 *p;\n\tuint32_t limit_type, nblocks, blocksize;\n\n\tREAD_BUF(12);\n\tREAD32(limit_type);\n\tswitch (limit_type) {\n\t\tcase 1:\n\t\t\tREAD64(*maxsize);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tREAD32(nblocks);\n\t\t\tREAD32(blocksize);\n\t\t\t*maxsize = (uint64_t)nblocks * (uint64_t)blocksize;\n\t}\n\treturn 0;\n}\n\nstatic int decode_delegation(struct xdr_stream *xdr, struct nfs_openres *res)\n{\n        __be32 *p;\n        uint32_t delegation_type;\n\n\tREAD_BUF(4);\n\tREAD32(delegation_type);\n\tif (delegation_type == NFS4_OPEN_DELEGATE_NONE) {\n\t\tres->delegation_type = 0;\n\t\treturn 0;\n\t}\n\tREAD_BUF(NFS4_STATEID_SIZE+4);\n\tCOPYMEM(res->delegation.data, NFS4_STATEID_SIZE);\n\tREAD32(res->do_recall);\n\tswitch (delegation_type) {\n\t\tcase NFS4_OPEN_DELEGATE_READ:\n\t\t\tres->delegation_type = FMODE_READ;\n\t\t\tbreak;\n\t\tcase NFS4_OPEN_DELEGATE_WRITE:\n\t\t\tres->delegation_type = FMODE_WRITE|FMODE_READ;\n\t\t\tif (decode_space_limit(xdr, &res->maxsize) < 0)\n\t\t\t\treturn -EIO;\n\t}\n\treturn decode_ace(xdr, NULL, res->server->nfs_client);\n}\n\nstatic int decode_open(struct xdr_stream *xdr, struct nfs_openres *res)\n{\n        __be32 *p;\n\tuint32_t savewords, bmlen, i;\n        int status;\n\n        status = decode_op_hdr(xdr, OP_OPEN);\n\tif (status != -EIO)\n\t\tnfs_increment_open_seqid(status, res->seqid);\n        if (status)\n                return status;\n        READ_BUF(NFS4_STATEID_SIZE);\n        COPYMEM(res->stateid.data, NFS4_STATEID_SIZE);\n\n        decode_change_info(xdr, &res->cinfo);\n\n        READ_BUF(8);\n        READ32(res->rflags);\n        READ32(bmlen);\n        if (bmlen > 10)\n                goto xdr_error;\n\n        READ_BUF(bmlen << 2);\n\tsavewords = min_t(uint32_t, bmlen, NFS4_BITMAP_SIZE);\n\tfor (i = 0; i < savewords; ++i)\n\t\tREAD32(res->attrset[i]);\n\tfor (; i < NFS4_BITMAP_SIZE; i++)\n\t\tres->attrset[i] = 0;\n\n\treturn decode_delegation(xdr, res);\nxdr_error:\n\tdprintk(\"%s: Bitmap too large! Length = %u\\n\", __func__, bmlen);\n\treturn -EIO;\n}\n\nstatic int decode_open_confirm(struct xdr_stream *xdr, struct nfs_open_confirmres *res)\n{\n        __be32 *p;\n\tint status;\n\n        status = decode_op_hdr(xdr, OP_OPEN_CONFIRM);\n\tif (status != -EIO)\n\t\tnfs_increment_open_seqid(status, res->seqid);\n        if (status)\n                return status;\n        READ_BUF(NFS4_STATEID_SIZE);\n        COPYMEM(res->stateid.data, NFS4_STATEID_SIZE);\n        return 0;\n}\n\nstatic int decode_open_downgrade(struct xdr_stream *xdr, struct nfs_closeres *res)\n{\n\t__be32 *p;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_OPEN_DOWNGRADE);\n\tif (status != -EIO)\n\t\tnfs_increment_open_seqid(status, res->seqid);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(NFS4_STATEID_SIZE);\n\tCOPYMEM(res->stateid.data, NFS4_STATEID_SIZE);\n\treturn 0;\n}\n\nstatic int decode_putfh(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_PUTFH);\n}\n\nstatic int decode_putrootfh(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_PUTROOTFH);\n}\n\nstatic int decode_read(struct xdr_stream *xdr, struct rpc_rqst *req, struct nfs_readres *res)\n{\n\tstruct kvec *iov = req->rq_rcv_buf.head;\n\t__be32 *p;\n\tuint32_t count, eof, recvd, hdrlen;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_READ);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(8);\n\tREAD32(eof);\n\tREAD32(count);\n\thdrlen = (u8 *) p - (u8 *) iov->iov_base;\n\trecvd = req->rq_rcv_buf.len - hdrlen;\n\tif (count > recvd) {\n\t\tdprintk(\"NFS: server cheating in read reply: \"\n\t\t\t\t\"count %u > recvd %u\\n\", count, recvd);\n\t\tcount = recvd;\n\t\teof = 0;\n\t}\n\txdr_read_pages(xdr, count);\n\tres->eof = eof;\n\tres->count = count;\n\treturn 0;\n}\n\nstatic int decode_readdir(struct xdr_stream *xdr, struct rpc_rqst *req, struct nfs4_readdir_res *readdir)\n{\n\tstruct xdr_buf\t*rcvbuf = &req->rq_rcv_buf;\n\tstruct page\t*page = *rcvbuf->pages;\n\tstruct kvec\t*iov = rcvbuf->head;\n\tsize_t\t\thdrlen;\n\tu32\t\trecvd, pglen = rcvbuf->page_len;\n\t__be32\t\t*end, *entry, *p, *kaddr;\n\tunsigned int\tnr = 0;\n\tint\t\tstatus;\n\n\tstatus = decode_op_hdr(xdr, OP_READDIR);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(8);\n\tCOPYMEM(readdir->verifier.data, 8);\n\tdprintk(\"%s: verifier = %08x:%08x\\n\",\n\t\t\t__func__,\n\t\t\t((u32 *)readdir->verifier.data)[0],\n\t\t\t((u32 *)readdir->verifier.data)[1]);\n\n\n\thdrlen = (char *) p - (char *) iov->iov_base;\n\trecvd = rcvbuf->len - hdrlen;\n\tif (pglen > recvd)\n\t\tpglen = recvd;\n\txdr_read_pages(xdr, pglen);\n\n\tBUG_ON(pglen + readdir->pgbase > PAGE_CACHE_SIZE);\n\tkaddr = p = kmap_atomic(page, KM_USER0);\n\tend = p + ((pglen + readdir->pgbase) >> 2);\n\tentry = p;\n\n\t/* Make sure the packet actually has a value_follows and EOF entry */\n\tif ((entry + 1) > end)\n\t\tgoto short_pkt;\n\n\tfor (; *p++; nr++) {\n\t\tu32 len, attrlen, xlen;\n\t\tif (end - p < 3)\n\t\t\tgoto short_pkt;\n\t\tdprintk(\"cookie = %Lu, \", *((unsigned long long *)p));\n\t\tp += 2;\t\t\t/* cookie */\n\t\tlen = ntohl(*p++);\t/* filename length */\n\t\tif (len > NFS4_MAXNAMLEN) {\n\t\t\tdprintk(\"NFS: giant filename in readdir (len 0x%x)\\n\",\n\t\t\t\t\tlen);\n\t\t\tgoto err_unmap;\n\t\t}\n\t\txlen = XDR_QUADLEN(len);\n\t\tif (end - p < xlen + 1)\n\t\t\tgoto short_pkt;\n\t\tdprintk(\"filename = %*s\\n\", len, (char *)p);\n\t\tp += xlen;\n\t\tlen = ntohl(*p++);\t/* bitmap length */\n\t\tif (end - p < len + 1)\n\t\t\tgoto short_pkt;\n\t\tp += len;\n\t\tattrlen = XDR_QUADLEN(ntohl(*p++));\n\t\tif (end - p < attrlen + 2)\n\t\t\tgoto short_pkt;\n\t\tp += attrlen;\t\t/* attributes */\n\t\tentry = p;\n\t}\n\t/*\n\t * Apparently some server sends responses that are a valid size, but\n\t * contain no entries, and have value_follows==0 and EOF==0. For\n\t * those, just set the EOF marker.\n\t */\n\tif (!nr && entry[1] == 0) {\n\t\tdprintk(\"NFS: readdir reply truncated!\\n\");\n\t\tentry[1] = 1;\n\t}\nout:\t\n\tkunmap_atomic(kaddr, KM_USER0);\n\treturn 0;\nshort_pkt:\n\t/*\n\t * When we get a short packet there are 2 possibilities. We can\n\t * return an error, or fix up the response to look like a valid\n\t * response and return what we have so far. If there are no\n\t * entries and the packet was short, then return -EIO. If there\n\t * are valid entries in the response, return them and pretend that\n\t * the call was successful, but incomplete. The caller can retry the\n\t * readdir starting at the last cookie.\n\t */\n\tdprintk(\"%s: short packet at entry %d\\n\", __func__, nr);\n\tentry[0] = entry[1] = 0;\n\tif (nr)\n\t\tgoto out;\nerr_unmap:\n\tkunmap_atomic(kaddr, KM_USER0);\n\treturn -errno_NFSERR_IO;\n}\n\nstatic int decode_readlink(struct xdr_stream *xdr, struct rpc_rqst *req)\n{\n\tstruct xdr_buf *rcvbuf = &req->rq_rcv_buf;\n\tstruct kvec *iov = rcvbuf->head;\n\tsize_t hdrlen;\n\tu32 len, recvd;\n\t__be32 *p;\n\tchar *kaddr;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_READLINK);\n\tif (status)\n\t\treturn status;\n\n\t/* Convert length of symlink */\n\tREAD_BUF(4);\n\tREAD32(len);\n\tif (len >= rcvbuf->page_len || len <= 0) {\n\t\tdprintk(\"nfs: server returned giant symlink!\\n\");\n\t\treturn -ENAMETOOLONG;\n\t}\n\thdrlen = (char *) xdr->p - (char *) iov->iov_base;\n\trecvd = req->rq_rcv_buf.len - hdrlen;\n\tif (recvd < len) {\n\t\tdprintk(\"NFS: server cheating in readlink reply: \"\n\t\t\t\t\"count %u > recvd %u\\n\", len, recvd);\n\t\treturn -EIO;\n\t}\n\txdr_read_pages(xdr, len);\n\t/*\n\t * The XDR encode routine has set things up so that\n\t * the link text will be copied directly into the\n\t * buffer.  We just have to do overflow-checking,\n\t * and and null-terminate the text (the VFS expects\n\t * null-termination).\n\t */\n\tkaddr = (char *)kmap_atomic(rcvbuf->pages[0], KM_USER0);\n\tkaddr[len+rcvbuf->page_base] = '\\0';\n\tkunmap_atomic(kaddr, KM_USER0);\n\treturn 0;\n}\n\nstatic int decode_remove(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)\n{\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_REMOVE);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_change_info(xdr, cinfo);\nout:\n\treturn status;\n}\n\nstatic int decode_rename(struct xdr_stream *xdr, struct nfs4_change_info *old_cinfo,\n\t      struct nfs4_change_info *new_cinfo)\n{\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_RENAME);\n\tif (status)\n\t\tgoto out;\n\tif ((status = decode_change_info(xdr, old_cinfo)))\n\t\tgoto out;\n\tstatus = decode_change_info(xdr, new_cinfo);\nout:\n\treturn status;\n}\n\nstatic int decode_renew(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_RENEW);\n}\n\nstatic int\ndecode_restorefh(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_RESTOREFH);\n}\n\nstatic int decode_getacl(struct xdr_stream *xdr, struct rpc_rqst *req,\n\t\tsize_t *acl_len)\n{\n\t__be32 *savep;\n\tuint32_t attrlen,\n\t\t bitmap[2] = {0};\n\tstruct kvec *iov = req->rq_rcv_buf.head;\n\tint status;\n\n\t*acl_len = 0;\n\tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n\t\tgoto out;\n\tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n\t\tgoto out;\n\tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n\t\tgoto out;\n\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_ACL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_ACL)) {\n\t\tsize_t hdrlen;\n\t\tu32 recvd;\n\n\t\t/* We ignore &savep and don't do consistency checks on\n\t\t * the attr length.  Let userspace figure it out.... */\n\t\thdrlen = (u8 *)xdr->p - (u8 *)iov->iov_base;\n\t\trecvd = req->rq_rcv_buf.len - hdrlen;\n\t\tif (attrlen > recvd) {\n\t\t\tdprintk(\"NFS: server cheating in getattr\"\n\t\t\t\t\t\" acl reply: attrlen %u > recvd %u\\n\",\n\t\t\t\t\tattrlen, recvd);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\txdr_read_pages(xdr, attrlen);\n\t\t*acl_len = attrlen;\n\t} else\n\t\tstatus = -EOPNOTSUPP;\n\nout:\n\treturn status;\n}\n\nstatic int\ndecode_savefh(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_SAVEFH);\n}\n\nstatic int decode_setattr(struct xdr_stream *xdr, struct nfs_setattrres *res)\n{\n\t__be32 *p;\n\tuint32_t bmlen;\n\tint status;\n\n        \n\tstatus = decode_op_hdr(xdr, OP_SETATTR);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(4);\n\tREAD32(bmlen);\n\tREAD_BUF(bmlen << 2);\n\treturn 0;\n}\n\nstatic int decode_setclientid(struct xdr_stream *xdr, struct nfs_client *clp)\n{\n\t__be32 *p;\n\tuint32_t opnum;\n\tint32_t nfserr;\n\n\tREAD_BUF(8);\n\tREAD32(opnum);\n\tif (opnum != OP_SETCLIENTID) {\n\t\tdprintk(\"nfs: decode_setclientid: Server returned operation\"\n\t\t\t       \t\" %d\\n\", opnum);\n\t\treturn -EIO;\n\t}\n\tREAD32(nfserr);\n\tif (nfserr == NFS_OK) {\n\t\tREAD_BUF(8 + NFS4_VERIFIER_SIZE);\n\t\tREAD64(clp->cl_clientid);\n\t\tCOPYMEM(clp->cl_confirm.data, NFS4_VERIFIER_SIZE);\n\t} else if (nfserr == NFSERR_CLID_INUSE) {\n\t\tuint32_t len;\n\n\t\t/* skip netid string */\n\t\tREAD_BUF(4);\n\t\tREAD32(len);\n\t\tREAD_BUF(len);\n\n\t\t/* skip uaddr string */\n\t\tREAD_BUF(4);\n\t\tREAD32(len);\n\t\tREAD_BUF(len);\n\t\treturn -NFSERR_CLID_INUSE;\n\t} else\n\t\treturn nfs4_stat_to_errno(nfserr);\n\n\treturn 0;\n}\n\nstatic int decode_setclientid_confirm(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_SETCLIENTID_CONFIRM);\n}\n\nstatic int decode_write(struct xdr_stream *xdr, struct nfs_writeres *res)\n{\n\t__be32 *p;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_WRITE);\n\tif (status)\n\t\treturn status;\n\n\tREAD_BUF(16);\n\tREAD32(res->count);\n\tREAD32(res->verf->committed);\n\tCOPYMEM(res->verf->verifier, 8);\n\treturn 0;\n}\n\nstatic int decode_delegreturn(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_DELEGRETURN);\n}\n\n/*\n * Decode OPEN_DOWNGRADE response\n */\nstatic int nfs4_xdr_dec_open_downgrade(struct rpc_rqst *rqstp, __be32 *p, struct nfs_closeres *res)\n{\n        struct xdr_stream xdr;\n        struct compound_hdr hdr;\n        int status;\n\n        xdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n        status = decode_compound_hdr(&xdr, &hdr);\n        if (status)\n                goto out;\n        status = decode_putfh(&xdr);\n        if (status)\n                goto out;\n        status = decode_open_downgrade(&xdr, res);\n\tif (status != 0)\n\t\tgoto out;\n\tdecode_getfattr(&xdr, res->fattr, res->server);\nout:\n        return status;\n}\n\n/*\n * END OF \"GENERIC\" DECODE ROUTINES.\n */\n\n/*\n * Decode ACCESS response\n */\nstatic int nfs4_xdr_dec_access(struct rpc_rqst *rqstp, __be32 *p, struct nfs4_accessres *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\t\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tif ((status = decode_compound_hdr(&xdr, &hdr)) != 0)\n\t\tgoto out;\n\tstatus = decode_putfh(&xdr);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = decode_access(&xdr, res);\n\tif (status != 0)\n\t\tgoto out;\n\tdecode_getfattr(&xdr, res->fattr, res->server);\nout:\n\treturn status;\n}\n\n/*\n * Decode LOOKUP response\n */\nstatic int nfs4_xdr_dec_lookup(struct rpc_rqst *rqstp, __be32 *p, struct nfs4_lookup_res *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\t\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tif ((status = decode_compound_hdr(&xdr, &hdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_putfh(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_lookup(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_getfh(&xdr, res->fh)) != 0)\n\t\tgoto out;\n\tstatus = decode_getfattr(&xdr, res->fattr, res->server);\nout:\n\treturn status;\n}\n\n/*\n * Decode LOOKUP_ROOT response\n */\nstatic int nfs4_xdr_dec_lookup_root(struct rpc_rqst *rqstp, __be32 *p, struct nfs4_lookup_res *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\t\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tif ((status = decode_compound_hdr(&xdr, &hdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_putrootfh(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_getfh(&xdr, res->fh)) == 0)\n\t\tstatus = decode_getfattr(&xdr, res->fattr, res->server);\nout:\n\treturn status;\n}\n\n/*\n * Decode REMOVE response\n */\nstatic int nfs4_xdr_dec_remove(struct rpc_rqst *rqstp, __be32 *p, struct nfs_removeres *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\t\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tif ((status = decode_compound_hdr(&xdr, &hdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_putfh(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_remove(&xdr, &res->cinfo)) != 0)\n\t\tgoto out;\n\tdecode_getfattr(&xdr, &res->dir_attr, res->server);\nout:\n\treturn status;\n}\n\n/*\n * Decode RENAME response\n */\nstatic int nfs4_xdr_dec_rename(struct rpc_rqst *rqstp, __be32 *p, struct nfs4_rename_res *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\t\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tif ((status = decode_compound_hdr(&xdr, &hdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_putfh(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_savefh(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_putfh(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_rename(&xdr, &res->old_cinfo, &res->new_cinfo)) != 0)\n\t\tgoto out;\n\t/* Current FH is target directory */\n\tif (decode_getfattr(&xdr, res->new_fattr, res->server) != 0)\n\t\tgoto out;\n\tif ((status = decode_restorefh(&xdr)) != 0)\n\t\tgoto out;\n\tdecode_getfattr(&xdr, res->old_fattr, res->server);\nout:\n\treturn status;\n}\n\n/*\n * Decode LINK response\n */\nstatic int nfs4_xdr_dec_link(struct rpc_rqst *rqstp, __be32 *p, struct nfs4_link_res *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\t\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tif ((status = decode_compound_hdr(&xdr, &hdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_putfh(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_savefh(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_putfh(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_link(&xdr, &res->cinfo)) != 0)\n\t\tgoto out;\n\t/*\n\t * Note order: OP_LINK leaves the directory as the current\n\t *             filehandle.\n\t */\n\tif (decode_getfattr(&xdr, res->dir_attr, res->server) != 0)\n\t\tgoto out;\n\tif ((status = decode_restorefh(&xdr)) != 0)\n\t\tgoto out;\n\tdecode_getfattr(&xdr, res->fattr, res->server);\nout:\n\treturn status;\n}\n\n/*\n * Decode CREATE response\n */\nstatic int nfs4_xdr_dec_create(struct rpc_rqst *rqstp, __be32 *p, struct nfs4_create_res *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\t\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tif ((status = decode_compound_hdr(&xdr, &hdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_putfh(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_savefh(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_create(&xdr,&res->dir_cinfo)) != 0)\n\t\tgoto out;\n\tif ((status = decode_getfh(&xdr, res->fh)) != 0)\n\t\tgoto out;\n\tif (decode_getfattr(&xdr, res->fattr, res->server) != 0)\n\t\tgoto out;\n\tif ((status = decode_restorefh(&xdr)) != 0)\n\t\tgoto out;\n\tdecode_getfattr(&xdr, res->dir_fattr, res->server);\nout:\n\treturn status;\n}\n\n/*\n * Decode SYMLINK response\n */\nstatic int nfs4_xdr_dec_symlink(struct rpc_rqst *rqstp, __be32 *p, struct nfs4_create_res *res)\n{\n\treturn nfs4_xdr_dec_create(rqstp, p, res);\n}\n\n/*\n * Decode GETATTR response\n */\nstatic int nfs4_xdr_dec_getattr(struct rpc_rqst *rqstp, __be32 *p, struct nfs4_getattr_res *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\t\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(&xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getfattr(&xdr, res->fattr, res->server);\nout:\n\treturn status;\n\n}\n\n/*\n * Encode an SETACL request\n */\nstatic int\nnfs4_xdr_enc_setacl(struct rpc_rqst *req, __be32 *p, struct nfs_setaclargs *args)\n{\n        struct xdr_stream xdr;\n        struct compound_hdr hdr = {\n                .nops   = 2,\n        };\n        int status;\n\n        xdr_init_encode(&xdr, &req->rq_snd_buf, p);\n        encode_compound_hdr(&xdr, &hdr);\n        status = encode_putfh(&xdr, args->fh);\n        if (status)\n                goto out;\n        status = encode_setacl(&xdr, args);\nout:\n        return status;\n}\n/*\n * Decode SETACL response\n */\nstatic int\nnfs4_xdr_dec_setacl(struct rpc_rqst *rqstp, __be32 *p, void *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(&xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_setattr(&xdr, res);\nout:\n\treturn status;\n}\n\n/*\n * Decode GETACL response\n */\nstatic int\nnfs4_xdr_dec_getacl(struct rpc_rqst *rqstp, __be32 *p, size_t *acl_len)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(&xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getacl(&xdr, rqstp, acl_len);\n\nout:\n\treturn status;\n}\n\n/*\n * Decode CLOSE response\n */\nstatic int nfs4_xdr_dec_close(struct rpc_rqst *rqstp, __be32 *p, struct nfs_closeres *res)\n{\n        struct xdr_stream xdr;\n        struct compound_hdr hdr;\n        int status;\n\n        xdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n        status = decode_compound_hdr(&xdr, &hdr);\n        if (status)\n                goto out;\n        status = decode_putfh(&xdr);\n        if (status)\n                goto out;\n        status = decode_close(&xdr, res);\n\tif (status != 0)\n\t\tgoto out;\n\t/*\n\t * Note: Server may do delete on close for this file\n\t * \tin which case the getattr call will fail with\n\t * \tan ESTALE error. Shouldn't be a problem,\n\t * \tthough, since fattr->valid will remain unset.\n\t */\n\tdecode_getfattr(&xdr, res->fattr, res->server);\nout:\n        return status;\n}\n\n/*\n * Decode OPEN response\n */\nstatic int nfs4_xdr_dec_open(struct rpc_rqst *rqstp, __be32 *p, struct nfs_openres *res)\n{\n        struct xdr_stream xdr;\n        struct compound_hdr hdr;\n        int status;\n\n        xdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n        status = decode_compound_hdr(&xdr, &hdr);\n        if (status)\n                goto out;\n        status = decode_putfh(&xdr);\n        if (status)\n                goto out;\n        status = decode_savefh(&xdr);\n\tif (status)\n\t\tgoto out;\n        status = decode_open(&xdr, res);\n        if (status)\n                goto out;\n\tif (decode_getfh(&xdr, &res->fh) != 0)\n\t\tgoto out;\n\tif (decode_getfattr(&xdr, res->f_attr, res->server) != 0)\n\t\tgoto out;\n\tif (decode_restorefh(&xdr) != 0)\n\t\tgoto out;\n\tdecode_getfattr(&xdr, res->dir_attr, res->server);\nout:\n        return status;\n}\n\n/*\n * Decode OPEN_CONFIRM response\n */\nstatic int nfs4_xdr_dec_open_confirm(struct rpc_rqst *rqstp, __be32 *p, struct nfs_open_confirmres *res)\n{\n        struct xdr_stream xdr;\n        struct compound_hdr hdr;\n        int status;\n\n        xdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n        status = decode_compound_hdr(&xdr, &hdr);\n        if (status)\n                goto out;\n        status = decode_putfh(&xdr);\n        if (status)\n                goto out;\n        status = decode_open_confirm(&xdr, res);\nout:\n        return status;\n}\n\n/*\n * Decode OPEN response\n */\nstatic int nfs4_xdr_dec_open_noattr(struct rpc_rqst *rqstp, __be32 *p, struct nfs_openres *res)\n{\n        struct xdr_stream xdr;\n        struct compound_hdr hdr;\n        int status;\n\n        xdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n        status = decode_compound_hdr(&xdr, &hdr);\n        if (status)\n                goto out;\n        status = decode_putfh(&xdr);\n        if (status)\n                goto out;\n        status = decode_open(&xdr, res);\n        if (status)\n                goto out;\n\tdecode_getfattr(&xdr, res->f_attr, res->server);\nout:\n        return status;\n}\n\n/*\n * Decode SETATTR response\n */\nstatic int nfs4_xdr_dec_setattr(struct rpc_rqst *rqstp, __be32 *p, struct nfs_setattrres *res)\n{\n        struct xdr_stream xdr;\n        struct compound_hdr hdr;\n        int status;\n\n        xdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n        status = decode_compound_hdr(&xdr, &hdr);\n        if (status)\n                goto out;\n        status = decode_putfh(&xdr);\n        if (status)\n                goto out;\n        status = decode_setattr(&xdr, res);\n        if (status)\n                goto out;\n\tstatus = decode_getfattr(&xdr, res->fattr, res->server);\n\tif (status == NFS4ERR_DELAY)\n\t\tstatus = 0;\nout:\n        return status;\n}\n\n/*\n * Decode LOCK response\n */\nstatic int nfs4_xdr_dec_lock(struct rpc_rqst *rqstp, __be32 *p, struct nfs_lock_res *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(&xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_lock(&xdr, res);\nout:\n\treturn status;\n}\n\n/*\n * Decode LOCKT response\n */\nstatic int nfs4_xdr_dec_lockt(struct rpc_rqst *rqstp, __be32 *p, struct nfs_lockt_res *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(&xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_lockt(&xdr, res);\nout:\n\treturn status;\n}\n\n/*\n * Decode LOCKU response\n */\nstatic int nfs4_xdr_dec_locku(struct rpc_rqst *rqstp, __be32 *p, struct nfs_locku_res *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(&xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_locku(&xdr, res);\nout:\n\treturn status;\n}\n\n/*\n * Decode READLINK response\n */\nstatic int nfs4_xdr_dec_readlink(struct rpc_rqst *rqstp, __be32 *p, void *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(&xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_readlink(&xdr, rqstp);\nout:\n\treturn status;\n}\n\n/*\n * Decode READDIR response\n */\nstatic int nfs4_xdr_dec_readdir(struct rpc_rqst *rqstp, __be32 *p, struct nfs4_readdir_res *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(&xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_readdir(&xdr, rqstp, res);\nout:\n\treturn status;\n}\n\n/*\n * Decode Read response\n */\nstatic int nfs4_xdr_dec_read(struct rpc_rqst *rqstp, __be32 *p, struct nfs_readres *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(&xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_read(&xdr, rqstp, res);\n\tif (!status)\n\t\tstatus = res->count;\nout:\n\treturn status;\n}\n\n/*\n * Decode WRITE response\n */\nstatic int nfs4_xdr_dec_write(struct rpc_rqst *rqstp, __be32 *p, struct nfs_writeres *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(&xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_write(&xdr, res);\n\tif (status)\n\t\tgoto out;\n\tdecode_getfattr(&xdr, res->fattr, res->server);\n\tif (!status)\n\t\tstatus = res->count;\nout:\n\treturn status;\n}\n\n/*\n * Decode COMMIT response\n */\nstatic int nfs4_xdr_dec_commit(struct rpc_rqst *rqstp, __be32 *p, struct nfs_writeres *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(&xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_commit(&xdr, res);\n\tif (status)\n\t\tgoto out;\n\tdecode_getfattr(&xdr, res->fattr, res->server);\nout:\n\treturn status;\n}\n\n/*\n * FSINFO request\n */\nstatic int nfs4_xdr_dec_fsinfo(struct rpc_rqst *req, __be32 *p, struct nfs_fsinfo *fsinfo)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &req->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_putfh(&xdr);\n\tif (!status)\n\t\tstatus = decode_fsinfo(&xdr, fsinfo);\n\tif (!status)\n\t\tstatus = nfs4_stat_to_errno(hdr.status);\n\treturn status;\n}\n\n/*\n * PATHCONF request\n */\nstatic int nfs4_xdr_dec_pathconf(struct rpc_rqst *req, __be32 *p, struct nfs_pathconf *pathconf)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &req->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_putfh(&xdr);\n\tif (!status)\n\t\tstatus = decode_pathconf(&xdr, pathconf);\n\treturn status;\n}\n\n/*\n * STATFS request\n */\nstatic int nfs4_xdr_dec_statfs(struct rpc_rqst *req, __be32 *p, struct nfs_fsstat *fsstat)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &req->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_putfh(&xdr);\n\tif (!status)\n\t\tstatus = decode_statfs(&xdr, fsstat);\n\treturn status;\n}\n\n/*\n * GETATTR_BITMAP request\n */\nstatic int nfs4_xdr_dec_server_caps(struct rpc_rqst *req, __be32 *p, struct nfs4_server_caps_res *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &req->rq_rcv_buf, p);\n\tif ((status = decode_compound_hdr(&xdr, &hdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_putfh(&xdr)) != 0)\n\t\tgoto out;\n\tstatus = decode_server_caps(&xdr, res);\nout:\n\treturn status;\n}\n\n/*\n * Decode RENEW response\n */\nstatic int nfs4_xdr_dec_renew(struct rpc_rqst *rqstp, __be32 *p, void *dummy)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_renew(&xdr);\n\treturn status;\n}\n\n/*\n * a SETCLIENTID request\n */\nstatic int nfs4_xdr_dec_setclientid(struct rpc_rqst *req, __be32 *p,\n\t\tstruct nfs_client *clp)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &req->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_setclientid(&xdr, clp);\n\tif (!status)\n\t\tstatus = nfs4_stat_to_errno(hdr.status);\n\treturn status;\n}\n\n/*\n * a SETCLIENTID_CONFIRM request\n */\nstatic int nfs4_xdr_dec_setclientid_confirm(struct rpc_rqst *req, __be32 *p, struct nfs_fsinfo *fsinfo)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &req->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_setclientid_confirm(&xdr);\n\tif (!status)\n\t\tstatus = decode_putrootfh(&xdr);\n\tif (!status)\n\t\tstatus = decode_fsinfo(&xdr, fsinfo);\n\tif (!status)\n\t\tstatus = nfs4_stat_to_errno(hdr.status);\n\treturn status;\n}\n\n/*\n * DELEGRETURN request\n */\nstatic int nfs4_xdr_dec_delegreturn(struct rpc_rqst *rqstp, __be32 *p, struct nfs4_delegreturnres *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = decode_putfh(&xdr);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = decode_delegreturn(&xdr);\n\tdecode_getfattr(&xdr, res->fattr, res->server);\nout:\n\treturn status;\n}\n\n/*\n * FS_LOCATIONS request\n */\nstatic int nfs4_xdr_dec_fs_locations(struct rpc_rqst *req, __be32 *p, struct nfs4_fs_locations *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &req->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (status != 0)\n\t\tgoto out;\n\tif ((status = decode_putfh(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_lookup(&xdr)) != 0)\n\t\tgoto out;\n\txdr_enter_page(&xdr, PAGE_SIZE);\n\tstatus = decode_getfattr(&xdr, &res->fattr, res->server);\nout:\n\treturn status;\n}\n\n__be32 *nfs4_decode_dirent(__be32 *p, struct nfs_entry *entry, int plus)\n{\n\tuint32_t bitmap[2] = {0};\n\tuint32_t len;\n\n\tif (!*p++) {\n\t\tif (!*p)\n\t\t\treturn ERR_PTR(-EAGAIN);\n\t\tentry->eof = 1;\n\t\treturn ERR_PTR(-EBADCOOKIE);\n\t}\n\n\tentry->prev_cookie = entry->cookie;\n\tp = xdr_decode_hyper(p, &entry->cookie);\n\tentry->len = ntohl(*p++);\n\tentry->name = (const char *) p;\n\tp += XDR_QUADLEN(entry->len);\n\n\t/*\n\t * In case the server doesn't return an inode number,\n\t * we fake one here.  (We don't use inode number 0,\n\t * since glibc seems to choke on it...)\n\t */\n\tentry->ino = 1;\n\n\tlen = ntohl(*p++);\t\t/* bitmap length */\n\tif (len-- > 0) {\n\t\tbitmap[0] = ntohl(*p++);\n\t\tif (len-- > 0) {\n\t\t\tbitmap[1] = ntohl(*p++);\n\t\t\tp += len;\n\t\t}\n\t}\n\tlen = XDR_QUADLEN(ntohl(*p++));\t/* attribute buffer length */\n\tif (len > 0) {\n\t\tif (bitmap[0] & FATTR4_WORD0_RDATTR_ERROR) {\n\t\t\tbitmap[0] &= ~FATTR4_WORD0_RDATTR_ERROR;\n\t\t\t/* Ignore the return value of rdattr_error for now */\n\t\t\tp++;\n\t\t\tlen--;\n\t\t}\n\t\tif (bitmap[0] == 0 && bitmap[1] == FATTR4_WORD1_MOUNTED_ON_FILEID)\n\t\t\txdr_decode_hyper(p, &entry->ino);\n\t\telse if (bitmap[0] == FATTR4_WORD0_FILEID)\n\t\t\txdr_decode_hyper(p, &entry->ino);\n\t\tp += len;\n\t}\n\n\tentry->eof = !p[0] && p[1];\n\treturn p;\n}\n\n/*\n * We need to translate between nfs status return values and\n * the local errno values which may not be the same.\n */\nstatic struct {\n\tint stat;\n\tint errno;\n} nfs_errtbl[] = {\n\t{ NFS4_OK,\t\t0\t\t},\n\t{ NFS4ERR_PERM,\t\t-EPERM\t\t},\n\t{ NFS4ERR_NOENT,\t-ENOENT\t\t},\n\t{ NFS4ERR_IO,\t\t-errno_NFSERR_IO},\n\t{ NFS4ERR_NXIO,\t\t-ENXIO\t\t},\n\t{ NFS4ERR_ACCESS,\t-EACCES\t\t},\n\t{ NFS4ERR_EXIST,\t-EEXIST\t\t},\n\t{ NFS4ERR_XDEV,\t\t-EXDEV\t\t},\n\t{ NFS4ERR_NOTDIR,\t-ENOTDIR\t},\n\t{ NFS4ERR_ISDIR,\t-EISDIR\t\t},\n\t{ NFS4ERR_INVAL,\t-EINVAL\t\t},\n\t{ NFS4ERR_FBIG,\t\t-EFBIG\t\t},\n\t{ NFS4ERR_NOSPC,\t-ENOSPC\t\t},\n\t{ NFS4ERR_ROFS,\t\t-EROFS\t\t},\n\t{ NFS4ERR_MLINK,\t-EMLINK\t\t},\n\t{ NFS4ERR_NAMETOOLONG,\t-ENAMETOOLONG\t},\n\t{ NFS4ERR_NOTEMPTY,\t-ENOTEMPTY\t},\n\t{ NFS4ERR_DQUOT,\t-EDQUOT\t\t},\n\t{ NFS4ERR_STALE,\t-ESTALE\t\t},\n\t{ NFS4ERR_BADHANDLE,\t-EBADHANDLE\t},\n\t{ NFS4ERR_BADOWNER,\t-EINVAL\t\t},\n\t{ NFS4ERR_BADNAME,\t-EINVAL\t\t},\n\t{ NFS4ERR_BAD_COOKIE,\t-EBADCOOKIE\t},\n\t{ NFS4ERR_NOTSUPP,\t-ENOTSUPP\t},\n\t{ NFS4ERR_TOOSMALL,\t-ETOOSMALL\t},\n\t{ NFS4ERR_SERVERFAULT,\t-ESERVERFAULT\t},\n\t{ NFS4ERR_BADTYPE,\t-EBADTYPE\t},\n\t{ NFS4ERR_LOCKED,\t-EAGAIN\t\t},\n\t{ NFS4ERR_RESOURCE,\t-EREMOTEIO\t},\n\t{ NFS4ERR_SYMLINK,\t-ELOOP\t\t},\n\t{ NFS4ERR_OP_ILLEGAL,\t-EOPNOTSUPP\t},\n\t{ NFS4ERR_DEADLOCK,\t-EDEADLK\t},\n\t{ NFS4ERR_WRONGSEC,\t-EPERM\t\t}, /* FIXME: this needs\n\t\t\t\t\t\t    * to be handled by a\n\t\t\t\t\t\t    * middle-layer.\n\t\t\t\t\t\t    */\n\t{ -1,\t\t\t-EIO\t\t}\n};\n\n/*\n * Convert an NFS error code to a local one.\n * This one is used jointly by NFSv2 and NFSv3.\n */\nstatic int\nnfs4_stat_to_errno(int stat)\n{\n\tint i;\n\tfor (i = 0; nfs_errtbl[i].stat != -1; i++) {\n\t\tif (nfs_errtbl[i].stat == stat)\n\t\t\treturn nfs_errtbl[i].errno;\n\t}\n\tif (stat <= 10000 || stat > 10100) {\n\t\t/* The server is looney tunes. */\n\t\treturn -ESERVERFAULT;\n\t}\n\t/* If we cannot translate the error, the recovery routines should\n\t * handle it.\n\t * Note: remaining NFSv4 error codes have values > 10000, so should\n\t * not conflict with native Linux error codes.\n\t */\n\treturn -stat;\n}\n\n#define PROC(proc, argtype, restype)\t\t\t\t\\\n[NFSPROC4_CLNT_##proc] = {\t\t\t\t\t\\\n\t.p_proc   = NFSPROC4_COMPOUND,\t\t\t\t\\\n\t.p_encode = (kxdrproc_t) nfs4_xdr_##argtype,\t\t\\\n\t.p_decode = (kxdrproc_t) nfs4_xdr_##restype,\t\t\\\n\t.p_arglen = NFS4_##argtype##_sz,\t\t\t\\\n\t.p_replen = NFS4_##restype##_sz,\t\t\t\\\n\t.p_statidx = NFSPROC4_CLNT_##proc,\t\t\t\\\n\t.p_name   = #proc,\t\t\t\t\t\\\n    }\n\nstruct rpc_procinfo\tnfs4_procedures[] = {\n  PROC(READ,\t\tenc_read,\tdec_read),\n  PROC(WRITE,\t\tenc_write,\tdec_write),\n  PROC(COMMIT,\t\tenc_commit,\tdec_commit),\n  PROC(OPEN,\t\tenc_open,\tdec_open),\n  PROC(OPEN_CONFIRM,\tenc_open_confirm,\tdec_open_confirm),\n  PROC(OPEN_NOATTR,\tenc_open_noattr,\tdec_open_noattr),\n  PROC(OPEN_DOWNGRADE,\tenc_open_downgrade,\tdec_open_downgrade),\n  PROC(CLOSE,\t\tenc_close,\tdec_close),\n  PROC(SETATTR,\t\tenc_setattr,\tdec_setattr),\n  PROC(FSINFO,\t\tenc_fsinfo,\tdec_fsinfo),\n  PROC(RENEW,\t\tenc_renew,\tdec_renew),\n  PROC(SETCLIENTID,\tenc_setclientid,\tdec_setclientid),\n  PROC(SETCLIENTID_CONFIRM,\tenc_setclientid_confirm,\tdec_setclientid_confirm),\n  PROC(LOCK,            enc_lock,       dec_lock),\n  PROC(LOCKT,           enc_lockt,      dec_lockt),\n  PROC(LOCKU,           enc_locku,      dec_locku),\n  PROC(ACCESS,\t\tenc_access,\tdec_access),\n  PROC(GETATTR,\t\tenc_getattr,\tdec_getattr),\n  PROC(LOOKUP,\t\tenc_lookup,\tdec_lookup),\n  PROC(LOOKUP_ROOT,\tenc_lookup_root,\tdec_lookup_root),\n  PROC(REMOVE,\t\tenc_remove,\tdec_remove),\n  PROC(RENAME,\t\tenc_rename,\tdec_rename),\n  PROC(LINK,\t\tenc_link,\tdec_link),\n  PROC(SYMLINK,\t\tenc_symlink,\tdec_symlink),\n  PROC(CREATE,\t\tenc_create,\tdec_create),\n  PROC(PATHCONF,\tenc_pathconf,\tdec_pathconf),\n  PROC(STATFS,\t\tenc_statfs,\tdec_statfs),\n  PROC(READLINK,\tenc_readlink,\tdec_readlink),\n  PROC(READDIR,\t\tenc_readdir,\tdec_readdir),\n  PROC(SERVER_CAPS,\tenc_server_caps, dec_server_caps),\n  PROC(DELEGRETURN,\tenc_delegreturn, dec_delegreturn),\n  PROC(GETACL,\t\tenc_getacl,\tdec_getacl),\n  PROC(SETACL,\t\tenc_setacl,\tdec_setacl),\n  PROC(FS_LOCATIONS,\tenc_fs_locations, dec_fs_locations),\n};\n\nstruct rpc_version\t\tnfs_version4 = {\n\t.number\t\t\t= 4,\n\t.nrprocs\t\t= ARRAY_SIZE(nfs4_procedures),\n\t.procs\t\t\t= nfs4_procedures\n};\n\n/*\n * Local variables:\n *  c-basic-offset: 8\n * End:\n */\n", "/*\n *  linux/include/linux/nfs_fs.h\n *\n *  Copyright (C) 1992  Rick Sladkey\n *\n *  OS-specific nfs filesystem definitions and declarations\n */\n\n#ifndef _LINUX_NFS_FS_H\n#define _LINUX_NFS_FS_H\n\n#include <linux/magic.h>\n\n/* Default timeout values */\n#define NFS_DEF_UDP_TIMEO\t(11)\n#define NFS_DEF_UDP_RETRANS\t(3)\n#define NFS_DEF_TCP_TIMEO\t(600)\n#define NFS_DEF_TCP_RETRANS\t(2)\n\n#define NFS_MAX_UDP_TIMEOUT\t(60*HZ)\n#define NFS_MAX_TCP_TIMEOUT\t(600*HZ)\n\n#define NFS_DEF_ACREGMIN\t(3)\n#define NFS_DEF_ACREGMAX\t(60)\n#define NFS_DEF_ACDIRMIN\t(30)\n#define NFS_DEF_ACDIRMAX\t(60)\n\n/*\n * When flushing a cluster of dirty pages, there can be different\n * strategies:\n */\n#define FLUSH_SYNC\t\t1\t/* file being synced, or contention */\n#define FLUSH_STABLE\t\t4\t/* commit to stable storage */\n#define FLUSH_LOWPRI\t\t8\t/* low priority background flush */\n#define FLUSH_HIGHPRI\t\t16\t/* high priority memory reclaim flush */\n#define FLUSH_NOCOMMIT\t\t32\t/* Don't send the NFSv3/v4 COMMIT */\n#define FLUSH_INVALIDATE\t64\t/* Invalidate the page cache */\n#define FLUSH_NOWRITEPAGE\t128\t/* Don't call writepage() */\n\n#ifdef __KERNEL__\n\n#include <linux/in.h>\n#include <linux/kref.h>\n#include <linux/mm.h>\n#include <linux/pagemap.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/wait.h>\n\n#include <linux/sunrpc/debug.h>\n#include <linux/sunrpc/auth.h>\n#include <linux/sunrpc/clnt.h>\n\n#include <linux/nfs.h>\n#include <linux/nfs2.h>\n#include <linux/nfs3.h>\n#include <linux/nfs4.h>\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs_sb.h>\n\n#include <linux/mempool.h>\n\n/*\n * These are the default flags for swap requests\n */\n#define NFS_RPC_SWAPFLAGS\t\t(RPC_TASK_SWAPPER|RPC_TASK_ROOTCREDS)\n\n/*\n * NFSv3/v4 Access mode cache entry\n */\nstruct nfs_access_entry {\n\tstruct rb_node\t\trb_node;\n\tstruct list_head\tlru;\n\tunsigned long\t\tjiffies;\n\tstruct rpc_cred *\tcred;\n\tint\t\t\tmask;\n};\n\nstruct nfs4_state;\nstruct nfs_open_context {\n\tatomic_t count;\n\tstruct path path;\n\tstruct rpc_cred *cred;\n\tstruct nfs4_state *state;\n\tfl_owner_t lockowner;\n\tfmode_t mode;\n\n\tunsigned long flags;\n#define NFS_CONTEXT_ERROR_WRITE\t\t(0)\n\tint error;\n\n\tstruct list_head list;\n\n\t__u64 dir_cookie;\n};\n\n/*\n * NFSv4 delegation\n */\nstruct nfs_delegation;\n\nstruct posix_acl;\n\n/*\n * nfs fs inode data in memory\n */\nstruct nfs_inode {\n\t/*\n\t * The 64bit 'inode number'\n\t */\n\t__u64 fileid;\n\n\t/*\n\t * NFS file handle\n\t */\n\tstruct nfs_fh\t\tfh;\n\n\t/*\n\t * Various flags\n\t */\n\tunsigned long\t\tflags;\t\t\t/* atomic bit ops */\n\tunsigned long\t\tcache_validity;\t\t/* bit mask */\n\n\t/*\n\t * read_cache_jiffies is when we started read-caching this inode.\n\t * attrtimeo is for how long the cached information is assumed\n\t * to be valid. A successful attribute revalidation doubles\n\t * attrtimeo (up to acregmax/acdirmax), a failure resets it to\n\t * acregmin/acdirmin.\n\t *\n\t * We need to revalidate the cached attrs for this inode if\n\t *\n\t *\tjiffies - read_cache_jiffies > attrtimeo\n\t */\n\tunsigned long\t\tread_cache_jiffies;\n\tunsigned long\t\tattrtimeo;\n\tunsigned long\t\tattrtimeo_timestamp;\n\t__u64\t\t\tchange_attr;\t\t/* v4 only */\n\n\tunsigned long\t\tattr_gencount;\n\t/* \"Generation counter\" for the attribute cache. This is\n\t * bumped whenever we update the metadata on the\n\t * server.\n\t */\n\tunsigned long\t\tcache_change_attribute;\n\n\tstruct rb_root\t\taccess_cache;\n\tstruct list_head\taccess_cache_entry_lru;\n\tstruct list_head\taccess_cache_inode_lru;\n#ifdef CONFIG_NFS_V3_ACL\n\tstruct posix_acl\t*acl_access;\n\tstruct posix_acl\t*acl_default;\n#endif\n\n\t/*\n\t * This is the cookie verifier used for NFSv3 readdir\n\t * operations\n\t */\n\t__be32\t\t\tcookieverf[2];\n\n\t/*\n\t * This is the list of dirty unwritten pages.\n\t */\n\tstruct radix_tree_root\tnfs_page_tree;\n\n\tunsigned long\t\tncommit,\n\t\t\t\tnpages;\n\n\t/* Open contexts for shared mmap writes */\n\tstruct list_head\topen_files;\n\n\t/* Number of in-flight sillydelete RPC calls */\n\tatomic_t\t\tsilly_count;\n\t/* List of deferred sillydelete requests */\n\tstruct hlist_head\tsilly_list;\n\twait_queue_head_t\twaitqueue;\n\n#ifdef CONFIG_NFS_V4\n\tstruct nfs4_cached_acl\t*nfs4_acl;\n        /* NFSv4 state */\n\tstruct list_head\topen_states;\n\tstruct nfs_delegation\t*delegation;\n\tfmode_t\t\t\t delegation_state;\n\tstruct rw_semaphore\trwsem;\n#endif /* CONFIG_NFS_V4*/\n\tstruct inode\t\tvfs_inode;\n};\n\n/*\n * Cache validity bit flags\n */\n#define NFS_INO_INVALID_ATTR\t0x0001\t\t/* cached attrs are invalid */\n#define NFS_INO_INVALID_DATA\t0x0002\t\t/* cached data is invalid */\n#define NFS_INO_INVALID_ATIME\t0x0004\t\t/* cached atime is invalid */\n#define NFS_INO_INVALID_ACCESS\t0x0008\t\t/* cached access cred invalid */\n#define NFS_INO_INVALID_ACL\t0x0010\t\t/* cached acls are invalid */\n#define NFS_INO_REVAL_PAGECACHE\t0x0020\t\t/* must revalidate pagecache */\n#define NFS_INO_REVAL_FORCED\t0x0040\t\t/* force revalidation ignoring a delegation */\n\n/*\n * Bit offsets in flags field\n */\n#define NFS_INO_ADVISE_RDPLUS\t(0)\t\t/* advise readdirplus */\n#define NFS_INO_STALE\t\t(1)\t\t/* possible stale inode */\n#define NFS_INO_ACL_LRU_SET\t(2)\t\t/* Inode is on the LRU list */\n#define NFS_INO_MOUNTPOINT\t(3)\t\t/* inode is remote mountpoint */\n\nstatic inline struct nfs_inode *NFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nfs_inode, vfs_inode);\n}\n\nstatic inline struct nfs_server *NFS_SB(const struct super_block *s)\n{\n\treturn (struct nfs_server *)(s->s_fs_info);\n}\n\nstatic inline struct nfs_fh *NFS_FH(const struct inode *inode)\n{\n\treturn &NFS_I(inode)->fh;\n}\n\nstatic inline struct nfs_server *NFS_SERVER(const struct inode *inode)\n{\n\treturn NFS_SB(inode->i_sb);\n}\n\nstatic inline struct rpc_clnt *NFS_CLIENT(const struct inode *inode)\n{\n\treturn NFS_SERVER(inode)->client;\n}\n\nstatic inline const struct nfs_rpc_ops *NFS_PROTO(const struct inode *inode)\n{\n\treturn NFS_SERVER(inode)->nfs_client->rpc_ops;\n}\n\nstatic inline __be32 *NFS_COOKIEVERF(const struct inode *inode)\n{\n\treturn NFS_I(inode)->cookieverf;\n}\n\nstatic inline unsigned NFS_MINATTRTIMEO(const struct inode *inode)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\treturn S_ISDIR(inode->i_mode) ? nfss->acdirmin : nfss->acregmin;\n}\n\nstatic inline unsigned NFS_MAXATTRTIMEO(const struct inode *inode)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\treturn S_ISDIR(inode->i_mode) ? nfss->acdirmax : nfss->acregmax;\n}\n\nstatic inline int NFS_STALE(const struct inode *inode)\n{\n\treturn test_bit(NFS_INO_STALE, &NFS_I(inode)->flags);\n}\n\nstatic inline __u64 NFS_FILEID(const struct inode *inode)\n{\n\treturn NFS_I(inode)->fileid;\n}\n\nstatic inline void set_nfs_fileid(struct inode *inode, __u64 fileid)\n{\n\tNFS_I(inode)->fileid = fileid;\n}\n\nstatic inline void nfs_mark_for_revalidate(struct inode *inode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tspin_lock(&inode->i_lock);\n\tnfsi->cache_validity |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_ACCESS;\n\tif (S_ISDIR(inode->i_mode))\n\t\tnfsi->cache_validity |= NFS_INO_REVAL_PAGECACHE|NFS_INO_INVALID_DATA;\n\tspin_unlock(&inode->i_lock);\n}\n\nstatic inline int nfs_server_capable(struct inode *inode, int cap)\n{\n\treturn NFS_SERVER(inode)->caps & cap;\n}\n\nstatic inline int NFS_USE_READDIRPLUS(struct inode *inode)\n{\n\treturn test_bit(NFS_INO_ADVISE_RDPLUS, &NFS_I(inode)->flags);\n}\n\nstatic inline void nfs_set_verifier(struct dentry * dentry, unsigned long verf)\n{\n\tdentry->d_time = verf;\n}\n\n/**\n * nfs_save_change_attribute - Returns the inode attribute change cookie\n * @dir - pointer to parent directory inode\n * The \"change attribute\" is updated every time we finish an operation\n * that will result in a metadata change on the server.\n */\nstatic inline unsigned long nfs_save_change_attribute(struct inode *dir)\n{\n\treturn NFS_I(dir)->cache_change_attribute;\n}\n\n/**\n * nfs_verify_change_attribute - Detects NFS remote directory changes\n * @dir - pointer to parent directory inode\n * @chattr - previously saved change attribute\n * Return \"false\" if the verifiers doesn't match the change attribute.\n * This would usually indicate that the directory contents have changed on\n * the server, and that any dentries need revalidating.\n */\nstatic inline int nfs_verify_change_attribute(struct inode *dir, unsigned long chattr)\n{\n\treturn chattr == NFS_I(dir)->cache_change_attribute;\n}\n\n/*\n * linux/fs/nfs/inode.c\n */\nextern int nfs_sync_mapping(struct address_space *mapping);\nextern void nfs_zap_mapping(struct inode *inode, struct address_space *mapping);\nextern void nfs_zap_caches(struct inode *);\nextern void nfs_invalidate_atime(struct inode *);\nextern struct inode *nfs_fhget(struct super_block *, struct nfs_fh *,\n\t\t\t\tstruct nfs_fattr *);\nextern int nfs_refresh_inode(struct inode *, struct nfs_fattr *);\nextern int nfs_post_op_update_inode(struct inode *inode, struct nfs_fattr *fattr);\nextern int nfs_post_op_update_inode_force_wcc(struct inode *inode, struct nfs_fattr *fattr);\nextern int nfs_getattr(struct vfsmount *, struct dentry *, struct kstat *);\nextern int nfs_permission(struct inode *, int);\nextern int nfs_open(struct inode *, struct file *);\nextern int nfs_release(struct inode *, struct file *);\nextern int nfs_attribute_timeout(struct inode *inode);\nextern int nfs_revalidate_inode(struct nfs_server *server, struct inode *inode);\nextern int __nfs_revalidate_inode(struct nfs_server *, struct inode *);\nextern int nfs_revalidate_mapping(struct inode *inode, struct address_space *mapping);\nextern int nfs_revalidate_mapping_nolock(struct inode *inode, struct address_space *mapping);\nextern int nfs_setattr(struct dentry *, struct iattr *);\nextern void nfs_setattr_update_inode(struct inode *inode, struct iattr *attr);\nextern struct nfs_open_context *get_nfs_open_context(struct nfs_open_context *ctx);\nextern void put_nfs_open_context(struct nfs_open_context *ctx);\nextern struct nfs_open_context *nfs_find_open_context(struct inode *inode, struct rpc_cred *cred, fmode_t mode);\nextern u64 nfs_compat_user_ino64(u64 fileid);\nextern void nfs_fattr_init(struct nfs_fattr *fattr);\n\n/* linux/net/ipv4/ipconfig.c: trims ip addr off front of name, too. */\nextern __be32 root_nfs_parse_addr(char *name); /*__init*/\nextern unsigned long nfs_inc_attr_generation_counter(void);\n\n/*\n * linux/fs/nfs/file.c\n */\nextern const struct inode_operations nfs_file_inode_operations;\n#ifdef CONFIG_NFS_V3\nextern const struct inode_operations nfs3_file_inode_operations;\n#endif /* CONFIG_NFS_V3 */\nextern const struct file_operations nfs_file_operations;\nextern const struct address_space_operations nfs_file_aops;\n\nstatic inline struct nfs_open_context *nfs_file_open_context(struct file *filp)\n{\n\treturn filp->private_data;\n}\n\nstatic inline struct rpc_cred *nfs_file_cred(struct file *file)\n{\n\tif (file != NULL) {\n\t\tstruct nfs_open_context *ctx =\n\t\t\tnfs_file_open_context(file);\n\t\tif (ctx)\n\t\t\treturn ctx->cred;\n\t}\n\treturn NULL;\n}\n\n/*\n * linux/fs/nfs/xattr.c\n */\n#ifdef CONFIG_NFS_V3_ACL\nextern ssize_t nfs3_listxattr(struct dentry *, char *, size_t);\nextern ssize_t nfs3_getxattr(struct dentry *, const char *, void *, size_t);\nextern int nfs3_setxattr(struct dentry *, const char *,\n\t\t\tconst void *, size_t, int);\nextern int nfs3_removexattr (struct dentry *, const char *name);\n#else\n# define nfs3_listxattr NULL\n# define nfs3_getxattr NULL\n# define nfs3_setxattr NULL\n# define nfs3_removexattr NULL\n#endif\n\n/*\n * linux/fs/nfs/direct.c\n */\nextern ssize_t nfs_direct_IO(int, struct kiocb *, const struct iovec *, loff_t,\n\t\t\tunsigned long);\nextern ssize_t nfs_file_direct_read(struct kiocb *iocb,\n\t\t\tconst struct iovec *iov, unsigned long nr_segs,\n\t\t\tloff_t pos);\nextern ssize_t nfs_file_direct_write(struct kiocb *iocb,\n\t\t\tconst struct iovec *iov, unsigned long nr_segs,\n\t\t\tloff_t pos);\n\n/*\n * linux/fs/nfs/dir.c\n */\nextern const struct inode_operations nfs_dir_inode_operations;\n#ifdef CONFIG_NFS_V3\nextern const struct inode_operations nfs3_dir_inode_operations;\n#endif /* CONFIG_NFS_V3 */\nextern const struct file_operations nfs_dir_operations;\nextern struct dentry_operations nfs_dentry_operations;\n\nextern void nfs_force_lookup_revalidate(struct inode *dir);\nextern int nfs_instantiate(struct dentry *dentry, struct nfs_fh *fh, struct nfs_fattr *fattr);\nextern int nfs_may_open(struct inode *inode, struct rpc_cred *cred, int openflags);\nextern void nfs_access_zap_cache(struct inode *inode);\n\n/*\n * linux/fs/nfs/symlink.c\n */\nextern const struct inode_operations nfs_symlink_inode_operations;\n\n/*\n * linux/fs/nfs/sysctl.c\n */\n#ifdef CONFIG_SYSCTL\nextern int nfs_register_sysctl(void);\nextern void nfs_unregister_sysctl(void);\n#else\n#define nfs_register_sysctl() 0\n#define nfs_unregister_sysctl() do { } while(0)\n#endif\n\n/*\n * linux/fs/nfs/namespace.c\n */\nextern const struct inode_operations nfs_mountpoint_inode_operations;\nextern const struct inode_operations nfs_referral_inode_operations;\nextern int nfs_mountpoint_expiry_timeout;\nextern void nfs_release_automount_timer(void);\n\n/*\n * linux/fs/nfs/unlink.c\n */\nextern int  nfs_async_unlink(struct inode *dir, struct dentry *dentry);\nextern void nfs_complete_unlink(struct dentry *dentry, struct inode *);\nextern void nfs_block_sillyrename(struct dentry *dentry);\nextern void nfs_unblock_sillyrename(struct dentry *dentry);\n\n/*\n * linux/fs/nfs/write.c\n */\nextern int  nfs_congestion_kb;\nextern int  nfs_writepage(struct page *page, struct writeback_control *wbc);\nextern int  nfs_writepages(struct address_space *, struct writeback_control *);\nextern int  nfs_flush_incompatible(struct file *file, struct page *page);\nextern int  nfs_updatepage(struct file *, struct page *, unsigned int, unsigned int);\nextern int nfs_writeback_done(struct rpc_task *, struct nfs_write_data *);\nextern void nfs_writedata_release(void *);\n\n/*\n * Try to write back everything synchronously (but check the\n * return value!)\n */\nextern long nfs_sync_mapping_wait(struct address_space *, struct writeback_control *, int);\nextern int nfs_wb_all(struct inode *inode);\nextern int nfs_wb_nocommit(struct inode *inode);\nextern int nfs_wb_page(struct inode *inode, struct page* page);\nextern int nfs_wb_page_cancel(struct inode *inode, struct page* page);\n#if defined(CONFIG_NFS_V3) || defined(CONFIG_NFS_V4)\nextern int  nfs_commit_inode(struct inode *, int);\nextern struct nfs_write_data *nfs_commitdata_alloc(void);\nextern void nfs_commit_free(struct nfs_write_data *wdata);\nextern void nfs_commitdata_release(void *wdata);\n#else\nstatic inline int\nnfs_commit_inode(struct inode *inode, int how)\n{\n\treturn 0;\n}\n#endif\n\nstatic inline int\nnfs_have_writebacks(struct inode *inode)\n{\n\treturn NFS_I(inode)->npages != 0;\n}\n\n/*\n * Allocate nfs_write_data structures\n */\nextern struct nfs_write_data *nfs_writedata_alloc(unsigned int npages);\n\n/*\n * linux/fs/nfs/read.c\n */\nextern int  nfs_readpage(struct file *, struct page *);\nextern int  nfs_readpages(struct file *, struct address_space *,\n\t\tstruct list_head *, unsigned);\nextern int  nfs_readpage_result(struct rpc_task *, struct nfs_read_data *);\nextern void nfs_readdata_release(void *data);\n\n/*\n * Allocate nfs_read_data structures\n */\nextern struct nfs_read_data *nfs_readdata_alloc(unsigned int npages);\n\n/*\n * linux/fs/nfs3proc.c\n */\n#ifdef CONFIG_NFS_V3_ACL\nextern struct posix_acl *nfs3_proc_getacl(struct inode *inode, int type);\nextern int nfs3_proc_setacl(struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);\nextern int nfs3_proc_set_default_acl(struct inode *dir, struct inode *inode,\n\t\tmode_t mode);\nextern void nfs3_forget_cached_acls(struct inode *inode);\n#else\nstatic inline int nfs3_proc_set_default_acl(struct inode *dir,\n\t\t\t\t\t    struct inode *inode,\n\t\t\t\t\t    mode_t mode)\n{\n\treturn 0;\n}\n\nstatic inline void nfs3_forget_cached_acls(struct inode *inode)\n{\n}\n#endif /* CONFIG_NFS_V3_ACL */\n\n/*\n * inline functions\n */\n\nstatic inline loff_t nfs_size_to_loff_t(__u64 size)\n{\n\tif (size > (__u64) OFFSET_MAX - 1)\n\t\treturn OFFSET_MAX - 1;\n\treturn (loff_t) size;\n}\n\nstatic inline ino_t\nnfs_fileid_to_ino_t(u64 fileid)\n{\n\tino_t ino = (ino_t) fileid;\n\tif (sizeof(ino_t) < sizeof(u64))\n\t\tino ^= fileid >> (sizeof(u64)-sizeof(ino_t)) * 8;\n\treturn ino;\n}\n\n/* NFS root */\n\nextern void * nfs_root_data(void);\n\n#define nfs_wait_event(clnt, wq, condition)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tint __retval = wait_event_killable(wq, condition);\t\t\\\n\t__retval;\t\t\t\t\t\t\t\\\n})\n\n#define NFS_JUKEBOX_RETRY_TIME (5 * HZ)\n\n#endif /* __KERNEL__ */\n\n/*\n * NFS debug flags\n */\n#define NFSDBG_VFS\t\t0x0001\n#define NFSDBG_DIRCACHE\t\t0x0002\n#define NFSDBG_LOOKUPCACHE\t0x0004\n#define NFSDBG_PAGECACHE\t0x0008\n#define NFSDBG_PROC\t\t0x0010\n#define NFSDBG_XDR\t\t0x0020\n#define NFSDBG_FILE\t\t0x0040\n#define NFSDBG_ROOT\t\t0x0080\n#define NFSDBG_CALLBACK\t\t0x0100\n#define NFSDBG_CLIENT\t\t0x0200\n#define NFSDBG_MOUNT\t\t0x0400\n#define NFSDBG_ALL\t\t0xFFFF\n\n#ifdef __KERNEL__\n\n/*\n * Enable debugging support for nfs client.\n * Requires RPC_DEBUG.\n */\n#ifdef RPC_DEBUG\n# define NFS_DEBUG\n#endif\n\n# undef ifdebug\n# ifdef NFS_DEBUG\n#  define ifdebug(fac)\t\tif (unlikely(nfs_debug & NFSDBG_##fac))\n# else\n#  define ifdebug(fac)\t\tif (0)\n# endif\n#endif /* __KERNEL */\n\n#endif\n", "#ifndef _LINUX_NFS_XDR_H\n#define _LINUX_NFS_XDR_H\n\n#include <linux/nfsacl.h>\n\n/*\n * To change the maximum rsize and wsize supported by the NFS client, adjust\n * NFS_MAX_FILE_IO_SIZE.  64KB is a typical maximum, but some servers can\n * support a megabyte or more.  The default is left at 4096 bytes, which is\n * reasonable for NFS over UDP.\n */\n#define NFS_MAX_FILE_IO_SIZE\t(1048576U)\n#define NFS_DEF_FILE_IO_SIZE\t(4096U)\n#define NFS_MIN_FILE_IO_SIZE\t(1024U)\n\nstruct nfs_fsid {\n\tuint64_t\t\tmajor;\n\tuint64_t\t\tminor;\n};\n\n/*\n * Helper for checking equality between 2 fsids.\n */\nstatic inline int nfs_fsid_equal(const struct nfs_fsid *a, const struct nfs_fsid *b)\n{\n\treturn a->major == b->major && a->minor == b->minor;\n}\n\nstruct nfs_fattr {\n\tunsigned short\t\tvalid;\t\t/* which fields are valid */\n\t__u64\t\t\tpre_size;\t/* pre_op_attr.size\t  */\n\tstruct timespec\t\tpre_mtime;\t/* pre_op_attr.mtime\t  */\n\tstruct timespec\t\tpre_ctime;\t/* pre_op_attr.ctime\t  */\n\tenum nfs_ftype\t\ttype;\t\t/* always use NFSv2 types */\n\t__u32\t\t\tmode;\n\t__u32\t\t\tnlink;\n\t__u32\t\t\tuid;\n\t__u32\t\t\tgid;\n\tdev_t\t\t\trdev;\n\t__u64\t\t\tsize;\n\tunion {\n\t\tstruct {\n\t\t\t__u32\tblocksize;\n\t\t\t__u32\tblocks;\n\t\t} nfs2;\n\t\tstruct {\n\t\t\t__u64\tused;\n\t\t} nfs3;\n\t} du;\n\tstruct nfs_fsid\t\tfsid;\n\t__u64\t\t\tfileid;\n\tstruct timespec\t\tatime;\n\tstruct timespec\t\tmtime;\n\tstruct timespec\t\tctime;\n\t__u32\t\t\tbitmap[2];\t/* NFSv4 returned attribute bitmap */\n\t__u64\t\t\tchange_attr;\t/* NFSv4 change attribute */\n\t__u64\t\t\tpre_change_attr;/* pre-op NFSv4 change attribute */\n\tunsigned long\t\ttime_start;\n\tunsigned long\t\tgencount;\n};\n\n#define NFS_ATTR_WCC\t\t0x0001\t\t/* pre-op WCC data    */\n#define NFS_ATTR_FATTR\t\t0x0002\t\t/* post-op attributes */\n#define NFS_ATTR_FATTR_V3\t0x0004\t\t/* NFSv3 attributes */\n#define NFS_ATTR_FATTR_V4\t0x0008\t\t/* NFSv4 change attribute */\n#define NFS_ATTR_WCC_V4\t\t0x0010\t\t/* pre-op change attribute */\n#define NFS_ATTR_FATTR_V4_REFERRAL\t0x0020\t\t/* NFSv4 referral */\n\n/*\n * Info on the file system\n */\nstruct nfs_fsinfo {\n\tstruct nfs_fattr\t*fattr; /* Post-op attributes */\n\t__u32\t\t\trtmax;\t/* max.  read transfer size */\n\t__u32\t\t\trtpref;\t/* pref. read transfer size */\n\t__u32\t\t\trtmult;\t/* reads should be multiple of this */\n\t__u32\t\t\twtmax;\t/* max.  write transfer size */\n\t__u32\t\t\twtpref;\t/* pref. write transfer size */\n\t__u32\t\t\twtmult;\t/* writes should be multiple of this */\n\t__u32\t\t\tdtpref;\t/* pref. readdir transfer size */\n\t__u64\t\t\tmaxfilesize;\n\t__u32\t\t\tlease_time; /* in seconds */\n};\n\nstruct nfs_fsstat {\n\tstruct nfs_fattr\t*fattr; /* Post-op attributes */\n\t__u64\t\t\ttbytes;\t/* total size in bytes */\n\t__u64\t\t\tfbytes;\t/* # of free bytes */\n\t__u64\t\t\tabytes;\t/* # of bytes available to user */\n\t__u64\t\t\ttfiles;\t/* # of files */\n\t__u64\t\t\tffiles;\t/* # of free files */\n\t__u64\t\t\tafiles;\t/* # of files available to user */\n};\n\nstruct nfs2_fsstat {\n\t__u32\t\t\ttsize;  /* Server transfer size */\n\t__u32\t\t\tbsize;  /* Filesystem block size */\n\t__u32\t\t\tblocks; /* No. of \"bsize\" blocks on filesystem */\n\t__u32\t\t\tbfree;  /* No. of free \"bsize\" blocks */\n\t__u32\t\t\tbavail; /* No. of available \"bsize\" blocks */\n};\n\nstruct nfs_pathconf {\n\tstruct nfs_fattr\t*fattr; /* Post-op attributes */\n\t__u32\t\t\tmax_link; /* max # of hard links */\n\t__u32\t\t\tmax_namelen; /* max name length */\n};\n\nstruct nfs4_change_info {\n\tu32\t\t\tatomic;\n\tu64\t\t\tbefore;\n\tu64\t\t\tafter;\n};\n\nstruct nfs_seqid;\n/*\n * Arguments to the open call.\n */\nstruct nfs_openargs {\n\tconst struct nfs_fh *\tfh;\n\tstruct nfs_seqid *\tseqid;\n\tint\t\t\topen_flags;\n\tfmode_t\t\t\tfmode;\n\t__u64                   clientid;\n\t__u64                   id;\n\tunion {\n\t\tstruct iattr *  attrs;    /* UNCHECKED, GUARDED */\n\t\tnfs4_verifier   verifier; /* EXCLUSIVE */\n\t\tnfs4_stateid\tdelegation;\t\t/* CLAIM_DELEGATE_CUR */\n\t\tfmode_t\t\tdelegation_type;\t/* CLAIM_PREVIOUS */\n\t} u;\n\tconst struct qstr *\tname;\n\tconst struct nfs_server *server;\t /* Needed for ID mapping */\n\tconst u32 *\t\tbitmask;\n\t__u32\t\t\tclaim;\n};\n\nstruct nfs_openres {\n\tnfs4_stateid            stateid;\n\tstruct nfs_fh           fh;\n\tstruct nfs4_change_info\tcinfo;\n\t__u32                   rflags;\n\tstruct nfs_fattr *      f_attr;\n\tstruct nfs_fattr *      dir_attr;\n\tstruct nfs_seqid *\tseqid;\n\tconst struct nfs_server *server;\n\tfmode_t\t\t\tdelegation_type;\n\tnfs4_stateid\t\tdelegation;\n\t__u32\t\t\tdo_recall;\n\t__u64\t\t\tmaxsize;\n\t__u32\t\t\tattrset[NFS4_BITMAP_SIZE];\n};\n\n/*\n * Arguments to the open_confirm call.\n */\nstruct nfs_open_confirmargs {\n\tconst struct nfs_fh *\tfh;\n\tnfs4_stateid *\t\tstateid;\n\tstruct nfs_seqid *\tseqid;\n};\n\nstruct nfs_open_confirmres {\n\tnfs4_stateid            stateid;\n\tstruct nfs_seqid *\tseqid;\n};\n\n/*\n * Arguments to the close call.\n */\nstruct nfs_closeargs {\n\tstruct nfs_fh *         fh;\n\tnfs4_stateid *\t\tstateid;\n\tstruct nfs_seqid *\tseqid;\n\tfmode_t\t\t\tfmode;\n\tconst u32 *\t\tbitmask;\n};\n\nstruct nfs_closeres {\n\tnfs4_stateid            stateid;\n\tstruct nfs_fattr *\tfattr;\n\tstruct nfs_seqid *\tseqid;\n\tconst struct nfs_server *server;\n};\n/*\n *  * Arguments to the lock,lockt, and locku call.\n *   */\nstruct nfs_lowner {\n\t__u64\t\t\tclientid;\n\t__u64\t\t\tid;\n};\n\nstruct nfs_lock_args {\n\tstruct nfs_fh *\t\tfh;\n\tstruct file_lock *\tfl;\n\tstruct nfs_seqid *\tlock_seqid;\n\tnfs4_stateid *\t\tlock_stateid;\n\tstruct nfs_seqid *\topen_seqid;\n\tnfs4_stateid *\t\topen_stateid;\n\tstruct nfs_lowner\tlock_owner;\n\tunsigned char\t\tblock : 1;\n\tunsigned char\t\treclaim : 1;\n\tunsigned char\t\tnew_lock_owner : 1;\n};\n\nstruct nfs_lock_res {\n\tnfs4_stateid\t\tstateid;\n\tstruct nfs_seqid *\tlock_seqid;\n\tstruct nfs_seqid *\topen_seqid;\n};\n\nstruct nfs_locku_args {\n\tstruct nfs_fh *\t\tfh;\n\tstruct file_lock *\tfl;\n\tstruct nfs_seqid *\tseqid;\n\tnfs4_stateid *\t\tstateid;\n};\n\nstruct nfs_locku_res {\n\tnfs4_stateid\t\tstateid;\n\tstruct nfs_seqid *\tseqid;\n};\n\nstruct nfs_lockt_args {\n\tstruct nfs_fh *\t\tfh;\n\tstruct file_lock *\tfl;\n\tstruct nfs_lowner\tlock_owner;\n};\n\nstruct nfs_lockt_res {\n\tstruct file_lock *\tdenied; /* LOCK, LOCKT failed */\n};\n\nstruct nfs4_delegreturnargs {\n\tconst struct nfs_fh *fhandle;\n\tconst nfs4_stateid *stateid;\n\tconst u32 * bitmask;\n};\n\nstruct nfs4_delegreturnres {\n\tstruct nfs_fattr * fattr;\n\tconst struct nfs_server *server;\n};\n\n/*\n * Arguments to the read call.\n */\nstruct nfs_readargs {\n\tstruct nfs_fh *\t\tfh;\n\tstruct nfs_open_context *context;\n\t__u64\t\t\toffset;\n\t__u32\t\t\tcount;\n\tunsigned int\t\tpgbase;\n\tstruct page **\t\tpages;\n};\n\nstruct nfs_readres {\n\tstruct nfs_fattr *\tfattr;\n\t__u32\t\t\tcount;\n\tint                     eof;\n};\n\n/*\n * Arguments to the write call.\n */\nstruct nfs_writeargs {\n\tstruct nfs_fh *\t\tfh;\n\tstruct nfs_open_context *context;\n\t__u64\t\t\toffset;\n\t__u32\t\t\tcount;\n\tenum nfs3_stable_how\tstable;\n\tunsigned int\t\tpgbase;\n\tstruct page **\t\tpages;\n\tconst u32 *\t\tbitmask;\n};\n\nstruct nfs_writeverf {\n\tenum nfs3_stable_how\tcommitted;\n\t__be32\t\t\tverifier[2];\n};\n\nstruct nfs_writeres {\n\tstruct nfs_fattr *\tfattr;\n\tstruct nfs_writeverf *\tverf;\n\t__u32\t\t\tcount;\n\tconst struct nfs_server *server;\n};\n\n/*\n * Common arguments to the unlink call\n */\nstruct nfs_removeargs {\n\tconst struct nfs_fh\t*fh;\n\tstruct qstr\t\tname;\n\tconst u32 *\t\tbitmask;\n};\n\nstruct nfs_removeres {\n\tconst struct nfs_server *server;\n\tstruct nfs4_change_info\tcinfo;\n\tstruct nfs_fattr\tdir_attr;\n};\n\n/*\n * Argument struct for decode_entry function\n */\nstruct nfs_entry {\n\t__u64\t\t\tino;\n\t__u64\t\t\tcookie,\n\t\t\t\tprev_cookie;\n\tconst char *\t\tname;\n\tunsigned int\t\tlen;\n\tint\t\t\teof;\n\tstruct nfs_fh *\t\tfh;\n\tstruct nfs_fattr *\tfattr;\n};\n\n/*\n * The following types are for NFSv2 only.\n */\nstruct nfs_sattrargs {\n\tstruct nfs_fh *\t\tfh;\n\tstruct iattr *\t\tsattr;\n};\n\nstruct nfs_diropargs {\n\tstruct nfs_fh *\t\tfh;\n\tconst char *\t\tname;\n\tunsigned int\t\tlen;\n};\n\nstruct nfs_createargs {\n\tstruct nfs_fh *\t\tfh;\n\tconst char *\t\tname;\n\tunsigned int\t\tlen;\n\tstruct iattr *\t\tsattr;\n};\n\nstruct nfs_renameargs {\n\tstruct nfs_fh *\t\tfromfh;\n\tconst char *\t\tfromname;\n\tunsigned int\t\tfromlen;\n\tstruct nfs_fh *\t\ttofh;\n\tconst char *\t\ttoname;\n\tunsigned int\t\ttolen;\n};\n\nstruct nfs_setattrargs {\n\tstruct nfs_fh *                 fh;\n\tnfs4_stateid                    stateid;\n\tstruct iattr *                  iap;\n\tconst struct nfs_server *\tserver; /* Needed for name mapping */\n\tconst u32 *\t\t\tbitmask;\n};\n\nstruct nfs_setaclargs {\n\tstruct nfs_fh *\t\t\tfh;\n\tsize_t\t\t\t\tacl_len;\n\tunsigned int\t\t\tacl_pgbase;\n\tstruct page **\t\t\tacl_pages;\n};\n\nstruct nfs_getaclargs {\n\tstruct nfs_fh *\t\t\tfh;\n\tsize_t\t\t\t\tacl_len;\n\tunsigned int\t\t\tacl_pgbase;\n\tstruct page **\t\t\tacl_pages;\n};\n\nstruct nfs_setattrres {\n\tstruct nfs_fattr *              fattr;\n\tconst struct nfs_server *\tserver;\n};\n\nstruct nfs_linkargs {\n\tstruct nfs_fh *\t\tfromfh;\n\tstruct nfs_fh *\t\ttofh;\n\tconst char *\t\ttoname;\n\tunsigned int\t\ttolen;\n};\n\nstruct nfs_symlinkargs {\n\tstruct nfs_fh *\t\tfromfh;\n\tconst char *\t\tfromname;\n\tunsigned int\t\tfromlen;\n\tstruct page **\t\tpages;\n\tunsigned int\t\tpathlen;\n\tstruct iattr *\t\tsattr;\n};\n\nstruct nfs_readdirargs {\n\tstruct nfs_fh *\t\tfh;\n\t__u32\t\t\tcookie;\n\tunsigned int\t\tcount;\n\tstruct page **\t\tpages;\n};\n\nstruct nfs3_getaclargs {\n\tstruct nfs_fh *\t\tfh;\n\tint\t\t\tmask;\n\tstruct page **\t\tpages;\n};\n\nstruct nfs3_setaclargs {\n\tstruct inode *\t\tinode;\n\tint\t\t\tmask;\n\tstruct posix_acl *\tacl_access;\n\tstruct posix_acl *\tacl_default;\n\tstruct page **\t\tpages;\n};\n\nstruct nfs_diropok {\n\tstruct nfs_fh *\t\tfh;\n\tstruct nfs_fattr *\tfattr;\n};\n\nstruct nfs_readlinkargs {\n\tstruct nfs_fh *\t\tfh;\n\tunsigned int\t\tpgbase;\n\tunsigned int\t\tpglen;\n\tstruct page **\t\tpages;\n};\n\nstruct nfs3_sattrargs {\n\tstruct nfs_fh *\t\tfh;\n\tstruct iattr *\t\tsattr;\n\tunsigned int\t\tguard;\n\tstruct timespec\t\tguardtime;\n};\n\nstruct nfs3_diropargs {\n\tstruct nfs_fh *\t\tfh;\n\tconst char *\t\tname;\n\tunsigned int\t\tlen;\n};\n\nstruct nfs3_accessargs {\n\tstruct nfs_fh *\t\tfh;\n\t__u32\t\t\taccess;\n};\n\nstruct nfs3_createargs {\n\tstruct nfs_fh *\t\tfh;\n\tconst char *\t\tname;\n\tunsigned int\t\tlen;\n\tstruct iattr *\t\tsattr;\n\tenum nfs3_createmode\tcreatemode;\n\t__be32\t\t\tverifier[2];\n};\n\nstruct nfs3_mkdirargs {\n\tstruct nfs_fh *\t\tfh;\n\tconst char *\t\tname;\n\tunsigned int\t\tlen;\n\tstruct iattr *\t\tsattr;\n};\n\nstruct nfs3_symlinkargs {\n\tstruct nfs_fh *\t\tfromfh;\n\tconst char *\t\tfromname;\n\tunsigned int\t\tfromlen;\n\tstruct page **\t\tpages;\n\tunsigned int\t\tpathlen;\n\tstruct iattr *\t\tsattr;\n};\n\nstruct nfs3_mknodargs {\n\tstruct nfs_fh *\t\tfh;\n\tconst char *\t\tname;\n\tunsigned int\t\tlen;\n\tenum nfs3_ftype\t\ttype;\n\tstruct iattr *\t\tsattr;\n\tdev_t\t\t\trdev;\n};\n\nstruct nfs3_renameargs {\n\tstruct nfs_fh *\t\tfromfh;\n\tconst char *\t\tfromname;\n\tunsigned int\t\tfromlen;\n\tstruct nfs_fh *\t\ttofh;\n\tconst char *\t\ttoname;\n\tunsigned int\t\ttolen;\n};\n\nstruct nfs3_linkargs {\n\tstruct nfs_fh *\t\tfromfh;\n\tstruct nfs_fh *\t\ttofh;\n\tconst char *\t\ttoname;\n\tunsigned int\t\ttolen;\n};\n\nstruct nfs3_readdirargs {\n\tstruct nfs_fh *\t\tfh;\n\t__u64\t\t\tcookie;\n\t__be32\t\t\tverf[2];\n\tint\t\t\tplus;\n\tunsigned int            count;\n\tstruct page **\t\tpages;\n};\n\nstruct nfs3_diropres {\n\tstruct nfs_fattr *\tdir_attr;\n\tstruct nfs_fh *\t\tfh;\n\tstruct nfs_fattr *\tfattr;\n};\n\nstruct nfs3_accessres {\n\tstruct nfs_fattr *\tfattr;\n\t__u32\t\t\taccess;\n};\n\nstruct nfs3_readlinkargs {\n\tstruct nfs_fh *\t\tfh;\n\tunsigned int\t\tpgbase;\n\tunsigned int\t\tpglen;\n\tstruct page **\t\tpages;\n};\n\nstruct nfs3_renameres {\n\tstruct nfs_fattr *\tfromattr;\n\tstruct nfs_fattr *\ttoattr;\n};\n\nstruct nfs3_linkres {\n\tstruct nfs_fattr *\tdir_attr;\n\tstruct nfs_fattr *\tfattr;\n};\n\nstruct nfs3_readdirres {\n\tstruct nfs_fattr *\tdir_attr;\n\t__be32 *\t\tverf;\n\tint\t\t\tplus;\n};\n\nstruct nfs3_getaclres {\n\tstruct nfs_fattr *\tfattr;\n\tint\t\t\tmask;\n\tunsigned int\t\tacl_access_count;\n\tunsigned int\t\tacl_default_count;\n\tstruct posix_acl *\tacl_access;\n\tstruct posix_acl *\tacl_default;\n};\n\n#ifdef CONFIG_NFS_V4\n\ntypedef u64 clientid4;\n\nstruct nfs4_accessargs {\n\tconst struct nfs_fh *\t\tfh;\n\tconst u32 *\t\t\tbitmask;\n\tu32\t\t\t\taccess;\n};\n\nstruct nfs4_accessres {\n\tconst struct nfs_server *\tserver;\n\tstruct nfs_fattr *\t\tfattr;\n\tu32\t\t\t\tsupported;\n\tu32\t\t\t\taccess;\n};\n\nstruct nfs4_create_arg {\n\tu32\t\t\t\tftype;\n\tunion {\n\t\tstruct {\n\t\t\tstruct page **\tpages;\n\t\t\tunsigned int\tlen;\n\t\t} symlink;   /* NF4LNK */\n\t\tstruct {\n\t\t\tu32\t\tspecdata1;\n\t\t\tu32\t\tspecdata2;\n\t\t} device;    /* NF4BLK, NF4CHR */\n\t} u;\n\tconst struct qstr *\t\tname;\n\tconst struct nfs_server *\tserver;\n\tconst struct iattr *\t\tattrs;\n\tconst struct nfs_fh *\t\tdir_fh;\n\tconst u32 *\t\t\tbitmask;\n};\n\nstruct nfs4_create_res {\n\tconst struct nfs_server *\tserver;\n\tstruct nfs_fh *\t\t\tfh;\n\tstruct nfs_fattr *\t\tfattr;\n\tstruct nfs4_change_info\t\tdir_cinfo;\n\tstruct nfs_fattr *\t\tdir_fattr;\n};\n\nstruct nfs4_fsinfo_arg {\n\tconst struct nfs_fh *\t\tfh;\n\tconst u32 *\t\t\tbitmask;\n};\n\nstruct nfs4_getattr_arg {\n\tconst struct nfs_fh *\t\tfh;\n\tconst u32 *\t\t\tbitmask;\n};\n\nstruct nfs4_getattr_res {\n\tconst struct nfs_server *\tserver;\n\tstruct nfs_fattr *\t\tfattr;\n};\n\nstruct nfs4_link_arg {\n\tconst struct nfs_fh *\t\tfh;\n\tconst struct nfs_fh *\t\tdir_fh;\n\tconst struct qstr *\t\tname;\n\tconst u32 *\t\t\tbitmask;\n};\n\nstruct nfs4_link_res {\n\tconst struct nfs_server *\tserver;\n\tstruct nfs_fattr *\t\tfattr;\n\tstruct nfs4_change_info\t\tcinfo;\n\tstruct nfs_fattr *\t\tdir_attr;\n};\n\n\nstruct nfs4_lookup_arg {\n\tconst struct nfs_fh *\t\tdir_fh;\n\tconst struct qstr *\t\tname;\n\tconst u32 *\t\t\tbitmask;\n};\n\nstruct nfs4_lookup_res {\n\tconst struct nfs_server *\tserver;\n\tstruct nfs_fattr *\t\tfattr;\n\tstruct nfs_fh *\t\t\tfh;\n};\n\nstruct nfs4_lookup_root_arg {\n\tconst u32 *\t\t\tbitmask;\n};\n\nstruct nfs4_pathconf_arg {\n\tconst struct nfs_fh *\t\tfh;\n\tconst u32 *\t\t\tbitmask;\n};\n\nstruct nfs4_readdir_arg {\n\tconst struct nfs_fh *\t\tfh;\n\tu64\t\t\t\tcookie;\n\tnfs4_verifier\t\t\tverifier;\n\tu32\t\t\t\tcount;\n\tstruct page **\t\t\tpages;\t/* zero-copy data */\n\tunsigned int\t\t\tpgbase;\t/* zero-copy data */\n\tconst u32 *\t\t\tbitmask;\n};\n\nstruct nfs4_readdir_res {\n\tnfs4_verifier\t\t\tverifier;\n\tunsigned int\t\t\tpgbase;\n};\n\nstruct nfs4_readlink {\n\tconst struct nfs_fh *\t\tfh;\n\tunsigned int\t\t\tpgbase;\n\tunsigned int\t\t\tpglen;   /* zero-copy data */\n\tstruct page **\t\t\tpages;   /* zero-copy data */\n};\n\nstruct nfs4_rename_arg {\n\tconst struct nfs_fh *\t\told_dir;\n\tconst struct nfs_fh *\t\tnew_dir;\n\tconst struct qstr *\t\told_name;\n\tconst struct qstr *\t\tnew_name;\n\tconst u32 *\t\t\tbitmask;\n};\n\nstruct nfs4_rename_res {\n\tconst struct nfs_server *\tserver;\n\tstruct nfs4_change_info\t\told_cinfo;\n\tstruct nfs_fattr *\t\told_fattr;\n\tstruct nfs4_change_info\t\tnew_cinfo;\n\tstruct nfs_fattr *\t\tnew_fattr;\n};\n\n#define NFS4_SETCLIENTID_NAMELEN\t(127)\nstruct nfs4_setclientid {\n\tconst nfs4_verifier *\t\tsc_verifier;\n\tunsigned int\t\t\tsc_name_len;\n\tchar\t\t\t\tsc_name[NFS4_SETCLIENTID_NAMELEN + 1];\n\tu32\t\t\t\tsc_prog;\n\tunsigned int\t\t\tsc_netid_len;\n\tchar\t\t\t\tsc_netid[RPCBIND_MAXNETIDLEN + 1];\n\tunsigned int\t\t\tsc_uaddr_len;\n\tchar\t\t\t\tsc_uaddr[RPCBIND_MAXUADDRLEN + 1];\n\tu32\t\t\t\tsc_cb_ident;\n};\n\nstruct nfs4_statfs_arg {\n\tconst struct nfs_fh *\t\tfh;\n\tconst u32 *\t\t\tbitmask;\n};\n\nstruct nfs4_server_caps_res {\n\tu32\t\t\t\tattr_bitmask[2];\n\tu32\t\t\t\tacl_bitmask;\n\tu32\t\t\t\thas_links;\n\tu32\t\t\t\thas_symlinks;\n};\n\nstruct nfs4_string {\n\tunsigned int len;\n\tchar *data;\n};\n\n#define NFS4_PATHNAME_MAXCOMPONENTS 512\nstruct nfs4_pathname {\n\tunsigned int ncomponents;\n\tstruct nfs4_string components[NFS4_PATHNAME_MAXCOMPONENTS];\n};\n\n#define NFS4_FS_LOCATION_MAXSERVERS 10\nstruct nfs4_fs_location {\n\tunsigned int nservers;\n\tstruct nfs4_string servers[NFS4_FS_LOCATION_MAXSERVERS];\n\tstruct nfs4_pathname rootpath;\n};\n\n#define NFS4_FS_LOCATIONS_MAXENTRIES 10\nstruct nfs4_fs_locations {\n\tstruct nfs_fattr fattr;\n\tconst struct nfs_server *server;\n\tstruct nfs4_pathname fs_path;\n\tint nlocations;\n\tstruct nfs4_fs_location locations[NFS4_FS_LOCATIONS_MAXENTRIES];\n};\n\nstruct nfs4_fs_locations_arg {\n\tconst struct nfs_fh *dir_fh;\n\tconst struct qstr *name;\n\tstruct page *page;\n\tconst u32 *bitmask;\n};\n\n#endif /* CONFIG_NFS_V4 */\n\nstruct nfs_page;\n\n#define NFS_PAGEVEC_SIZE\t(8U)\n\nstruct nfs_read_data {\n\tint\t\t\tflags;\n\tstruct rpc_task\t\ttask;\n\tstruct inode\t\t*inode;\n\tstruct rpc_cred\t\t*cred;\n\tstruct nfs_fattr\tfattr;\t/* fattr storage */\n\tstruct list_head\tpages;\t/* Coalesced read requests */\n\tstruct nfs_page\t\t*req;\t/* multi ops per nfs_page */\n\tstruct page\t\t**pagevec;\n\tunsigned int\t\tnpages;\t/* Max length of pagevec */\n\tstruct nfs_readargs args;\n\tstruct nfs_readres  res;\n#ifdef CONFIG_NFS_V4\n\tunsigned long\t\ttimestamp;\t/* For lease renewal */\n#endif\n\tstruct page\t\t*page_array[NFS_PAGEVEC_SIZE];\n};\n\nstruct nfs_write_data {\n\tint\t\t\tflags;\n\tstruct rpc_task\t\ttask;\n\tstruct inode\t\t*inode;\n\tstruct rpc_cred\t\t*cred;\n\tstruct nfs_fattr\tfattr;\n\tstruct nfs_writeverf\tverf;\n\tstruct list_head\tpages;\t\t/* Coalesced requests we wish to flush */\n\tstruct nfs_page\t\t*req;\t\t/* multi ops per nfs_page */\n\tstruct page\t\t**pagevec;\n\tunsigned int\t\tnpages;\t\t/* Max length of pagevec */\n\tstruct nfs_writeargs\targs;\t\t/* argument struct */\n\tstruct nfs_writeres\tres;\t\t/* result struct */\n#ifdef CONFIG_NFS_V4\n\tunsigned long\t\ttimestamp;\t/* For lease renewal */\n#endif\n\tstruct page\t\t*page_array[NFS_PAGEVEC_SIZE];\n};\n\nstruct nfs_access_entry;\n\n/*\n * RPC procedure vector for NFSv2/NFSv3 demuxing\n */\nstruct nfs_rpc_ops {\n\tu32\tversion;\t\t/* Protocol version */\n\tstruct dentry_operations *dentry_ops;\n\tconst struct inode_operations *dir_inode_ops;\n\tconst struct inode_operations *file_inode_ops;\n\n\tint\t(*getroot) (struct nfs_server *, struct nfs_fh *,\n\t\t\t    struct nfs_fsinfo *);\n\tint\t(*lookupfh)(struct nfs_server *, struct nfs_fh *,\n\t\t\t    struct qstr *, struct nfs_fh *,\n\t\t\t    struct nfs_fattr *);\n\tint\t(*getattr) (struct nfs_server *, struct nfs_fh *,\n\t\t\t    struct nfs_fattr *);\n\tint\t(*setattr) (struct dentry *, struct nfs_fattr *,\n\t\t\t    struct iattr *);\n\tint\t(*lookup)  (struct inode *, struct qstr *,\n\t\t\t    struct nfs_fh *, struct nfs_fattr *);\n\tint\t(*access)  (struct inode *, struct nfs_access_entry *);\n\tint\t(*readlink)(struct inode *, struct page *, unsigned int,\n\t\t\t    unsigned int);\n\tint\t(*create)  (struct inode *, struct dentry *,\n\t\t\t    struct iattr *, int, struct nameidata *);\n\tint\t(*remove)  (struct inode *, struct qstr *);\n\tvoid\t(*unlink_setup)  (struct rpc_message *, struct inode *dir);\n\tint\t(*unlink_done) (struct rpc_task *, struct inode *);\n\tint\t(*rename)  (struct inode *, struct qstr *,\n\t\t\t    struct inode *, struct qstr *);\n\tint\t(*link)    (struct inode *, struct inode *, struct qstr *);\n\tint\t(*symlink) (struct inode *, struct dentry *, struct page *,\n\t\t\t    unsigned int, struct iattr *);\n\tint\t(*mkdir)   (struct inode *, struct dentry *, struct iattr *);\n\tint\t(*rmdir)   (struct inode *, struct qstr *);\n\tint\t(*readdir) (struct dentry *, struct rpc_cred *,\n\t\t\t    u64, struct page *, unsigned int, int);\n\tint\t(*mknod)   (struct inode *, struct dentry *, struct iattr *,\n\t\t\t    dev_t);\n\tint\t(*statfs)  (struct nfs_server *, struct nfs_fh *,\n\t\t\t    struct nfs_fsstat *);\n\tint\t(*fsinfo)  (struct nfs_server *, struct nfs_fh *,\n\t\t\t    struct nfs_fsinfo *);\n\tint\t(*pathconf) (struct nfs_server *, struct nfs_fh *,\n\t\t\t     struct nfs_pathconf *);\n\tint\t(*set_capabilities)(struct nfs_server *, struct nfs_fh *);\n\t__be32 *(*decode_dirent)(__be32 *, struct nfs_entry *, int plus);\n\tvoid\t(*read_setup)   (struct nfs_read_data *, struct rpc_message *);\n\tint\t(*read_done)  (struct rpc_task *, struct nfs_read_data *);\n\tvoid\t(*write_setup)  (struct nfs_write_data *, struct rpc_message *);\n\tint\t(*write_done)  (struct rpc_task *, struct nfs_write_data *);\n\tvoid\t(*commit_setup) (struct nfs_write_data *, struct rpc_message *);\n\tint\t(*commit_done) (struct rpc_task *, struct nfs_write_data *);\n\tint\t(*lock)(struct file *, int, struct file_lock *);\n\tint\t(*lock_check_bounds)(const struct file_lock *);\n\tvoid\t(*clear_acl_cache)(struct inode *);\n};\n\n/*\n * \tNFS_CALL(getattr, inode, (fattr));\n * into\n *\tNFS_PROTO(inode)->getattr(fattr);\n */\n#define NFS_CALL(op, inode, args)\tNFS_PROTO(inode)->op args\n\n/*\n * Function vectors etc. for the NFS client\n */\nextern const struct nfs_rpc_ops\tnfs_v2_clientops;\nextern const struct nfs_rpc_ops\tnfs_v3_clientops;\nextern const struct nfs_rpc_ops\tnfs_v4_clientops;\nextern struct rpc_version\tnfs_version2;\nextern struct rpc_version\tnfs_version3;\nextern struct rpc_version\tnfs_version4;\n\nextern struct rpc_version\tnfsacl_version3;\nextern struct rpc_program\tnfsacl_program;\n\n#endif\n"], "filenames": ["fs/nfs/inode.c", "fs/nfs/nfs4_fs.h", "fs/nfs/nfs4proc.c", "fs/nfs/nfs4state.c", "fs/nfs/nfs4xdr.c", "include/linux/nfs_fs.h", "include/linux/nfs_xdr.h"], "buggy_code_start_loc": [595, 164, 326, 366, 956, 86, 122], "buggy_code_end_loc": [596, 229, 2019, 509, 1116, 346, 175], "fixing_code_start_loc": [595, 164, 326, 366, 956, 86, 123], "fixing_code_end_loc": [596, 229, 2029, 509, 1116, 346, 176], "type": "NVD-CWE-noinfo", "message": "The encode_share_access function in fs/nfs/nfs4xdr.c in the Linux kernel before 2.6.29 allows local users to cause a denial of service (BUG and system crash) by using the mknod system call with a pathname on an NFSv4 filesystem.", "other": {"cve": {"id": "CVE-2011-4324", "sourceIdentifier": "secalert@redhat.com", "published": "2012-06-21T23:55:02.363", "lastModified": "2023-02-13T00:21:00.273", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The encode_share_access function in fs/nfs/nfs4xdr.c in the Linux kernel before 2.6.29 allows local users to cause a denial of service (BUG and system crash) by using the mknod system call with a pathname on an NFSv4 filesystem."}, {"lang": "es", "value": "La funci\u00f3n de encode_share_access fs/nfs/nfs4xdr.c en versiones del kernel de Linux anteriores a v2.6.29 permite a usuarios locales provocar una denegaci\u00f3n de servicio (ca\u00edda del sistema) mediante el uso de la llamada al sistema 'mknod' con una ruta de acceso en un sistema de archivos NFSv4."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.6.28.10", "matchCriteriaId": "6E29A038-1FE8-42C7-9788-BDBD1136F6AC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.28:*:*:*:*:*:*:*", "matchCriteriaId": "26BD805F-08EB-42EC-BC54-26A7278E5089"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.28.1:*:*:*:*:*:*:*", "matchCriteriaId": "217715A5-E69D-45C0-B8E4-5681528C651B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.28.2:*:*:*:*:*:*:*", "matchCriteriaId": "A87AD66C-4321-4459-8556-3B0BA38C493A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.28.3:*:*:*:*:*:*:*", "matchCriteriaId": "87A347E0-9C0B-4674-9363-3C36DA27AC45"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.28.4:*:*:*:*:*:*:*", "matchCriteriaId": "8E0F3DF0-6BD0-4560-9A13-C6493939D8B0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.28.5:*:*:*:*:*:*:*", "matchCriteriaId": "D4BE1DF7-99CB-416B-B6F9-EC40FBD7D1C6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.28.6:*:*:*:*:*:*:*", "matchCriteriaId": "B93AF773-FBB4-4A4A-ADD5-ADA40C24CD36"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.28.7:*:*:*:*:*:*:*", "matchCriteriaId": "38A55F08-88A9-42D5-A2B1-8B8C0D6DED09"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.28.8:*:*:*:*:*:*:*", "matchCriteriaId": "3975EC77-D33D-4167-91BE-08237C3EE9D0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.28.9:*:*:*:*:*:*:*", "matchCriteriaId": "0A0F2534-C267-43D9-8365-C00CD979B052"}]}]}], "references": [{"url": "http://ftp.osuosl.org/pub/linux/kernel/v2.6/ChangeLog-2.6.29", "source": "secalert@redhat.com"}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=dc0b027dfadfcb8a5504f7d8052754bf8d501ab9", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2012/02/06/3", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=755440", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9"}}