{"buggy_code": ["/*\r\n * FreeRTOS Kernel V10.4.2\r\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n * this software and associated documentation files (the \"Software\"), to deal in\r\n * the Software without restriction, including without limitation the rights to\r\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\r\n * the Software, and to permit persons to whom the Software is furnished to do so,\r\n * subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\r\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\r\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n * https://www.FreeRTOS.org\r\n * https://github.com/FreeRTOS\r\n *\r\n */\r\n\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining\r\n * all the API functions to use the MPU wrappers.  That should only be done when\r\n * task.h is included from an application file. */\r\n#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE\r\n\r\n#include \"FreeRTOS.h\"\r\n#include \"task.h\"\r\n#include \"queue.h\"\r\n\r\n#if ( configUSE_CO_ROUTINES == 1 )\r\n    #include \"croutine.h\"\r\n#endif\r\n\r\n/* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified\r\n * because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined\r\n * for the header files above, but not in this file, in order to generate the\r\n * correct privileged Vs unprivileged linkage and placement. */\r\n#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */\r\n\r\n\r\n/* Constants used with the cRxLock and cTxLock structure members. */\r\n#define queueUNLOCKED             ( ( int8_t ) -1 )\r\n#define queueLOCKED_UNMODIFIED    ( ( int8_t ) 0 )\r\n#define queueINT8_MAX             ( ( int8_t ) 127 )\r\n\r\n/* When the Queue_t structure is used to represent a base queue its pcHead and\r\n * pcTail members are used as pointers into the queue storage area.  When the\r\n * Queue_t structure is used to represent a mutex pcHead and pcTail pointers are\r\n * not necessary, and the pcHead pointer is set to NULL to indicate that the\r\n * structure instead holds a pointer to the mutex holder (if any).  Map alternative\r\n * names to the pcHead and structure member to ensure the readability of the code\r\n * is maintained.  The QueuePointers_t and SemaphoreData_t types are used to form\r\n * a union as their usage is mutually exclusive dependent on what the queue is\r\n * being used for. */\r\n#define uxQueueType               pcHead\r\n#define queueQUEUE_IS_MUTEX       NULL\r\n\r\ntypedef struct QueuePointers\r\n{\r\n    int8_t * pcTail;     /*< Points to the byte at the end of the queue storage area.  Once more byte is allocated than necessary to store the queue items, this is used as a marker. */\r\n    int8_t * pcReadFrom; /*< Points to the last place that a queued item was read from when the structure is used as a queue. */\r\n} QueuePointers_t;\r\n\r\ntypedef struct SemaphoreData\r\n{\r\n    TaskHandle_t xMutexHolder;        /*< The handle of the task that holds the mutex. */\r\n    UBaseType_t uxRecursiveCallCount; /*< Maintains a count of the number of times a recursive mutex has been recursively 'taken' when the structure is used as a mutex. */\r\n} SemaphoreData_t;\r\n\r\n/* Semaphores do not actually store or copy data, so have an item size of\r\n * zero. */\r\n#define queueSEMAPHORE_QUEUE_ITEM_LENGTH    ( ( UBaseType_t ) 0 )\r\n#define queueMUTEX_GIVE_BLOCK_TIME          ( ( TickType_t ) 0U )\r\n\r\n#if ( configUSE_PREEMPTION == 0 )\r\n\r\n/* If the cooperative scheduler is being used then a yield should not be\r\n * performed just because a higher priority task has been woken. */\r\n    #define queueYIELD_IF_USING_PREEMPTION()\r\n#else\r\n    #define queueYIELD_IF_USING_PREEMPTION()    portYIELD_WITHIN_API()\r\n#endif\r\n\r\n/*\r\n * Definition of the queue used by the scheduler.\r\n * Items are queued by copy, not reference.  See the following link for the\r\n * rationale: https://www.FreeRTOS.org/Embedded-RTOS-Queues.html\r\n */\r\ntypedef struct QueueDefinition /* The old naming convention is used to prevent breaking kernel aware debuggers. */\r\n{\r\n    int8_t * pcHead;           /*< Points to the beginning of the queue storage area. */\r\n    int8_t * pcWriteTo;        /*< Points to the free next place in the storage area. */\r\n\r\n    union\r\n    {\r\n        QueuePointers_t xQueue;     /*< Data required exclusively when this structure is used as a queue. */\r\n        SemaphoreData_t xSemaphore; /*< Data required exclusively when this structure is used as a semaphore. */\r\n    } u;\r\n\r\n    List_t xTasksWaitingToSend;             /*< List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. */\r\n    List_t xTasksWaitingToReceive;          /*< List of tasks that are blocked waiting to read from this queue.  Stored in priority order. */\r\n\r\n    volatile UBaseType_t uxMessagesWaiting; /*< The number of items currently in the queue. */\r\n    UBaseType_t uxLength;                   /*< The length of the queue defined as the number of items it will hold, not the number of bytes. */\r\n    UBaseType_t uxItemSize;                 /*< The size of each items that the queue will hold. */\r\n\r\n    volatile int8_t cRxLock;                /*< Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */\r\n    volatile int8_t cTxLock;                /*< Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */\r\n\r\n    #if ( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )\r\n        uint8_t ucStaticallyAllocated; /*< Set to pdTRUE if the memory used by the queue was statically allocated to ensure no attempt is made to free the memory. */\r\n    #endif\r\n\r\n    #if ( configUSE_QUEUE_SETS == 1 )\r\n        struct QueueDefinition * pxQueueSetContainer;\r\n    #endif\r\n\r\n    #if ( configUSE_TRACE_FACILITY == 1 )\r\n        UBaseType_t uxQueueNumber;\r\n        uint8_t ucQueueType;\r\n    #endif\r\n} xQUEUE;\r\n\r\n/* The old xQUEUE name is maintained above then typedefed to the new Queue_t\r\n * name below to enable the use of older kernel aware debuggers. */\r\ntypedef xQUEUE Queue_t;\r\n\r\n/*-----------------------------------------------------------*/\r\n\r\n/*\r\n * The queue registry is just a means for kernel aware debuggers to locate\r\n * queue structures.  It has no other purpose so is an optional component.\r\n */\r\n#if ( configQUEUE_REGISTRY_SIZE > 0 )\r\n\r\n/* The type stored within the queue registry array.  This allows a name\r\n * to be assigned to each queue making kernel aware debugging a little\r\n * more user friendly. */\r\n    typedef struct QUEUE_REGISTRY_ITEM\r\n    {\r\n        const char * pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\r\n        QueueHandle_t xHandle;\r\n    } xQueueRegistryItem;\r\n\r\n/* The old xQueueRegistryItem name is maintained above then typedefed to the\r\n * new xQueueRegistryItem name below to enable the use of older kernel aware\r\n * debuggers. */\r\n    typedef xQueueRegistryItem QueueRegistryItem_t;\r\n\r\n/* The queue registry is simply an array of QueueRegistryItem_t structures.\r\n * The pcQueueName member of a structure being NULL is indicative of the\r\n * array position being vacant. */\r\n    PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];\r\n\r\n#endif /* configQUEUE_REGISTRY_SIZE */\r\n\r\n/*\r\n * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not\r\n * prevent an ISR from adding or removing items to the queue, but does prevent\r\n * an ISR from removing tasks from the queue event lists.  If an ISR finds a\r\n * queue is locked it will instead increment the appropriate queue lock count\r\n * to indicate that a task may require unblocking.  When the queue in unlocked\r\n * these lock counts are inspected, and the appropriate action taken.\r\n */\r\nstatic void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;\r\n\r\n/*\r\n * Uses a critical section to determine if there is any data in a queue.\r\n *\r\n * @return pdTRUE if the queue contains no items, otherwise pdFALSE.\r\n */\r\nstatic BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue ) PRIVILEGED_FUNCTION;\r\n\r\n/*\r\n * Uses a critical section to determine if there is any space in a queue.\r\n *\r\n * @return pdTRUE if there is no space, otherwise pdFALSE;\r\n */\r\nstatic BaseType_t prvIsQueueFull( const Queue_t * pxQueue ) PRIVILEGED_FUNCTION;\r\n\r\n/*\r\n * Copies an item into the queue, either at the front of the queue or the\r\n * back of the queue.\r\n */\r\nstatic BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,\r\n                                      const void * pvItemToQueue,\r\n                                      const BaseType_t xPosition ) PRIVILEGED_FUNCTION;\r\n\r\n/*\r\n * Copies an item out of a queue.\r\n */\r\nstatic void prvCopyDataFromQueue( Queue_t * const pxQueue,\r\n                                  void * const pvBuffer ) PRIVILEGED_FUNCTION;\r\n\r\n#if ( configUSE_QUEUE_SETS == 1 )\r\n\r\n/*\r\n * Checks to see if a queue is a member of a queue set, and if so, notifies\r\n * the queue set that the queue contains data.\r\n */\r\n    static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;\r\n#endif\r\n\r\n/*\r\n * Called after a Queue_t structure has been allocated either statically or\r\n * dynamically to fill in the structure's members.\r\n */\r\nstatic void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,\r\n                                   const UBaseType_t uxItemSize,\r\n                                   uint8_t * pucQueueStorage,\r\n                                   const uint8_t ucQueueType,\r\n                                   Queue_t * pxNewQueue ) PRIVILEGED_FUNCTION;\r\n\r\n/*\r\n * Mutexes are a special type of queue.  When a mutex is created, first the\r\n * queue is created, then prvInitialiseMutex() is called to configure the queue\r\n * as a mutex.\r\n */\r\n#if ( configUSE_MUTEXES == 1 )\r\n    static void prvInitialiseMutex( Queue_t * pxNewQueue ) PRIVILEGED_FUNCTION;\r\n#endif\r\n\r\n#if ( configUSE_MUTEXES == 1 )\r\n\r\n/*\r\n * If a task waiting for a mutex causes the mutex holder to inherit a\r\n * priority, but the waiting task times out, then the holder should\r\n * disinherit the priority - but only down to the highest priority of any\r\n * other tasks that are waiting for the same mutex.  This function returns\r\n * that priority.\r\n */\r\n    static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;\r\n#endif\r\n/*-----------------------------------------------------------*/\r\n\r\n/*\r\n * Macro to mark a queue as locked.  Locking a queue prevents an ISR from\r\n * accessing the queue event lists.\r\n */\r\n#define prvLockQueue( pxQueue )                            \\\r\n    taskENTER_CRITICAL();                                  \\\r\n    {                                                      \\\r\n        if( ( pxQueue )->cRxLock == queueUNLOCKED )        \\\r\n        {                                                  \\\r\n            ( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED; \\\r\n        }                                                  \\\r\n        if( ( pxQueue )->cTxLock == queueUNLOCKED )        \\\r\n        {                                                  \\\r\n            ( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED; \\\r\n        }                                                  \\\r\n    }                                                      \\\r\n    taskEXIT_CRITICAL()\r\n/*-----------------------------------------------------------*/\r\n\r\nBaseType_t xQueueGenericReset( QueueHandle_t xQueue,\r\n                               BaseType_t xNewQueue )\r\n{\r\n    Queue_t * const pxQueue = xQueue;\r\n\r\n    configASSERT( pxQueue );\r\n\r\n    taskENTER_CRITICAL();\r\n    {\r\n        pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */\r\n        pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;\r\n        pxQueue->pcWriteTo = pxQueue->pcHead;\r\n        pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */\r\n        pxQueue->cRxLock = queueUNLOCKED;\r\n        pxQueue->cTxLock = queueUNLOCKED;\r\n\r\n        if( xNewQueue == pdFALSE )\r\n        {\r\n            /* If there are tasks blocked waiting to read from the queue, then\r\n             * the tasks will remain blocked as after this function exits the queue\r\n             * will still be empty.  If there are tasks blocked waiting to write to\r\n             * the queue, then one should be unblocked as after this function exits\r\n             * it will be possible to write to it. */\r\n            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )\r\n            {\r\n                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )\r\n                {\r\n                    queueYIELD_IF_USING_PREEMPTION();\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n        else\r\n        {\r\n            /* Ensure the event queues start in the correct state. */\r\n            vListInitialise( &( pxQueue->xTasksWaitingToSend ) );\r\n            vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );\r\n        }\r\n    }\r\n    taskEXIT_CRITICAL();\r\n\r\n    /* A value is returned for calling semantic consistency with previous\r\n     * versions. */\r\n    return pdPASS;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configSUPPORT_STATIC_ALLOCATION == 1 )\r\n\r\n    QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength,\r\n                                             const UBaseType_t uxItemSize,\r\n                                             uint8_t * pucQueueStorage,\r\n                                             StaticQueue_t * pxStaticQueue,\r\n                                             const uint8_t ucQueueType )\r\n    {\r\n        Queue_t * pxNewQueue;\r\n\r\n        configASSERT( uxQueueLength > ( UBaseType_t ) 0 );\r\n\r\n        /* The StaticQueue_t structure and the queue storage area must be\r\n         * supplied. */\r\n        configASSERT( pxStaticQueue != NULL );\r\n\r\n        /* A queue storage area should be provided if the item size is not 0, and\r\n         * should not be provided if the item size is 0. */\r\n        configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );\r\n        configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );\r\n\r\n        #if ( configASSERT_DEFINED == 1 )\r\n            {\r\n                /* Sanity check that the size of the structure used to declare a\r\n                 * variable of type StaticQueue_t or StaticSemaphore_t equals the size of\r\n                 * the real queue and semaphore structures. */\r\n                volatile size_t xSize = sizeof( StaticQueue_t );\r\n                configASSERT( xSize == sizeof( Queue_t ) );\r\n                ( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */\r\n            }\r\n        #endif /* configASSERT_DEFINED */\r\n\r\n        /* The address of a statically allocated queue was passed in, use it.\r\n         * The address of a statically allocated storage area was also passed in\r\n         * but is already set. */\r\n        pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */\r\n\r\n        if( pxNewQueue != NULL )\r\n        {\r\n            #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\r\n                {\r\n                    /* Queues can be allocated wither statically or dynamically, so\r\n                     * note this queue was allocated statically in case the queue is\r\n                     * later deleted. */\r\n                    pxNewQueue->ucStaticallyAllocated = pdTRUE;\r\n                }\r\n            #endif /* configSUPPORT_DYNAMIC_ALLOCATION */\r\n\r\n            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );\r\n        }\r\n        else\r\n        {\r\n            traceQUEUE_CREATE_FAILED( ucQueueType );\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n\r\n        return pxNewQueue;\r\n    }\r\n\r\n#endif /* configSUPPORT_STATIC_ALLOCATION */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\r\n\r\n    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,\r\n                                       const UBaseType_t uxItemSize,\r\n                                       const uint8_t ucQueueType )\r\n    {\r\n        Queue_t * pxNewQueue;\r\n        size_t xQueueSizeInBytes;\r\n        uint8_t * pucQueueStorage;\r\n\r\n        configASSERT( uxQueueLength > ( UBaseType_t ) 0 );\r\n\r\n        /* Allocate enough space to hold the maximum number of items that\r\n         * can be in the queue at any time.  It is valid for uxItemSize to be\r\n         * zero in the case the queue is used as a semaphore. */\r\n        xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */\r\n\r\n        /* Check for multiplication overflow. */\r\n        configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );\r\n\r\n        /* Allocate the queue and storage area.  Justification for MISRA\r\n         * deviation as follows:  pvPortMalloc() always ensures returned memory\r\n         * blocks are aligned per the requirements of the MCU stack.  In this case\r\n         * pvPortMalloc() must return a pointer that is guaranteed to meet the\r\n         * alignment requirements of the Queue_t structure - which in this case\r\n         * is an int8_t *.  Therefore, whenever the stack alignment requirements\r\n         * are greater than or equal to the pointer to char requirements the cast\r\n         * is safe.  In other cases alignment requirements are not strict (one or\r\n         * two bytes). */\r\n        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */\r\n\r\n        if( pxNewQueue != NULL )\r\n        {\r\n            /* Jump past the queue structure to find the location of the queue\r\n             * storage area. */\r\n            pucQueueStorage = ( uint8_t * ) pxNewQueue;\r\n            pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */\r\n\r\n            #if ( configSUPPORT_STATIC_ALLOCATION == 1 )\r\n                {\r\n                    /* Queues can be created either statically or dynamically, so\r\n                     * note this task was created dynamically in case it is later\r\n                     * deleted. */\r\n                    pxNewQueue->ucStaticallyAllocated = pdFALSE;\r\n                }\r\n            #endif /* configSUPPORT_STATIC_ALLOCATION */\r\n\r\n            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );\r\n        }\r\n        else\r\n        {\r\n            traceQUEUE_CREATE_FAILED( ucQueueType );\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n\r\n        return pxNewQueue;\r\n    }\r\n\r\n#endif /* configSUPPORT_STATIC_ALLOCATION */\r\n/*-----------------------------------------------------------*/\r\n\r\nstatic void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,\r\n                                   const UBaseType_t uxItemSize,\r\n                                   uint8_t * pucQueueStorage,\r\n                                   const uint8_t ucQueueType,\r\n                                   Queue_t * pxNewQueue )\r\n{\r\n    /* Remove compiler warnings about unused parameters should\r\n     * configUSE_TRACE_FACILITY not be set to 1. */\r\n    ( void ) ucQueueType;\r\n\r\n    if( uxItemSize == ( UBaseType_t ) 0 )\r\n    {\r\n        /* No RAM was allocated for the queue storage area, but PC head cannot\r\n         * be set to NULL because NULL is used as a key to say the queue is used as\r\n         * a mutex.  Therefore just set pcHead to point to the queue as a benign\r\n         * value that is known to be within the memory map. */\r\n        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;\r\n    }\r\n    else\r\n    {\r\n        /* Set the head to the start of the queue storage area. */\r\n        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;\r\n    }\r\n\r\n    /* Initialise the queue members as described where the queue type is\r\n     * defined. */\r\n    pxNewQueue->uxLength = uxQueueLength;\r\n    pxNewQueue->uxItemSize = uxItemSize;\r\n    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );\r\n\r\n    #if ( configUSE_TRACE_FACILITY == 1 )\r\n        {\r\n            pxNewQueue->ucQueueType = ucQueueType;\r\n        }\r\n    #endif /* configUSE_TRACE_FACILITY */\r\n\r\n    #if ( configUSE_QUEUE_SETS == 1 )\r\n        {\r\n            pxNewQueue->pxQueueSetContainer = NULL;\r\n        }\r\n    #endif /* configUSE_QUEUE_SETS */\r\n\r\n    traceQUEUE_CREATE( pxNewQueue );\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_MUTEXES == 1 )\r\n\r\n    static void prvInitialiseMutex( Queue_t * pxNewQueue )\r\n    {\r\n        if( pxNewQueue != NULL )\r\n        {\r\n            /* The queue create function will set all the queue structure members\r\n            * correctly for a generic queue, but this function is creating a\r\n            * mutex.  Overwrite those members that need to be set differently -\r\n            * in particular the information required for priority inheritance. */\r\n            pxNewQueue->u.xSemaphore.xMutexHolder = NULL;\r\n            pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;\r\n\r\n            /* In case this is a recursive mutex. */\r\n            pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;\r\n\r\n            traceCREATE_MUTEX( pxNewQueue );\r\n\r\n            /* Start with the semaphore in the expected state. */\r\n            ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );\r\n        }\r\n        else\r\n        {\r\n            traceCREATE_MUTEX_FAILED();\r\n        }\r\n    }\r\n\r\n#endif /* configUSE_MUTEXES */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )\r\n\r\n    QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )\r\n    {\r\n        QueueHandle_t xNewQueue;\r\n        const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;\r\n\r\n        xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );\r\n        prvInitialiseMutex( ( Queue_t * ) xNewQueue );\r\n\r\n        return xNewQueue;\r\n    }\r\n\r\n#endif /* configUSE_MUTEXES */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )\r\n\r\n    QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType,\r\n                                           StaticQueue_t * pxStaticQueue )\r\n    {\r\n        QueueHandle_t xNewQueue;\r\n        const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;\r\n\r\n        /* Prevent compiler warnings about unused parameters if\r\n         * configUSE_TRACE_FACILITY does not equal 1. */\r\n        ( void ) ucQueueType;\r\n\r\n        xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );\r\n        prvInitialiseMutex( ( Queue_t * ) xNewQueue );\r\n\r\n        return xNewQueue;\r\n    }\r\n\r\n#endif /* configUSE_MUTEXES */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )\r\n\r\n    TaskHandle_t xQueueGetMutexHolder( QueueHandle_t xSemaphore )\r\n    {\r\n        TaskHandle_t pxReturn;\r\n        Queue_t * const pxSemaphore = ( Queue_t * ) xSemaphore;\r\n\r\n        /* This function is called by xSemaphoreGetMutexHolder(), and should not\r\n         * be called directly.  Note:  This is a good way of determining if the\r\n         * calling task is the mutex holder, but not a good way of determining the\r\n         * identity of the mutex holder, as the holder may change between the\r\n         * following critical section exiting and the function returning. */\r\n        taskENTER_CRITICAL();\r\n        {\r\n            if( pxSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )\r\n            {\r\n                pxReturn = pxSemaphore->u.xSemaphore.xMutexHolder;\r\n            }\r\n            else\r\n            {\r\n                pxReturn = NULL;\r\n            }\r\n        }\r\n        taskEXIT_CRITICAL();\r\n\r\n        return pxReturn;\r\n    } /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */\r\n\r\n#endif /* if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) ) */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )\r\n\r\n    TaskHandle_t xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore )\r\n    {\r\n        TaskHandle_t pxReturn;\r\n\r\n        configASSERT( xSemaphore );\r\n\r\n        /* Mutexes cannot be used in interrupt service routines, so the mutex\r\n         * holder should not change in an ISR, and therefore a critical section is\r\n         * not required here. */\r\n        if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )\r\n        {\r\n            pxReturn = ( ( Queue_t * ) xSemaphore )->u.xSemaphore.xMutexHolder;\r\n        }\r\n        else\r\n        {\r\n            pxReturn = NULL;\r\n        }\r\n\r\n        return pxReturn;\r\n    } /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */\r\n\r\n#endif /* if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) ) */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_RECURSIVE_MUTEXES == 1 )\r\n\r\n    BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )\r\n    {\r\n        BaseType_t xReturn;\r\n        Queue_t * const pxMutex = ( Queue_t * ) xMutex;\r\n\r\n        configASSERT( pxMutex );\r\n\r\n        /* If this is the task that holds the mutex then xMutexHolder will not\r\n         * change outside of this task.  If this task does not hold the mutex then\r\n         * pxMutexHolder can never coincidentally equal the tasks handle, and as\r\n         * this is the only condition we are interested in it does not matter if\r\n         * pxMutexHolder is accessed simultaneously by another task.  Therefore no\r\n         * mutual exclusion is required to test the pxMutexHolder variable. */\r\n        if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )\r\n        {\r\n            traceGIVE_MUTEX_RECURSIVE( pxMutex );\r\n\r\n            /* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to\r\n             * the task handle, therefore no underflow check is required.  Also,\r\n             * uxRecursiveCallCount is only modified by the mutex holder, and as\r\n             * there can only be one, no mutual exclusion is required to modify the\r\n             * uxRecursiveCallCount member. */\r\n            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;\r\n\r\n            /* Has the recursive call count unwound to 0? */\r\n            if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )\r\n            {\r\n                /* Return the mutex.  This will automatically unblock any other\r\n                 * task that might be waiting to access the mutex. */\r\n                ( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n\r\n            xReturn = pdPASS;\r\n        }\r\n        else\r\n        {\r\n            /* The mutex cannot be given because the calling task is not the\r\n             * holder. */\r\n            xReturn = pdFAIL;\r\n\r\n            traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );\r\n        }\r\n\r\n        return xReturn;\r\n    }\r\n\r\n#endif /* configUSE_RECURSIVE_MUTEXES */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_RECURSIVE_MUTEXES == 1 )\r\n\r\n    BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex,\r\n                                         TickType_t xTicksToWait )\r\n    {\r\n        BaseType_t xReturn;\r\n        Queue_t * const pxMutex = ( Queue_t * ) xMutex;\r\n\r\n        configASSERT( pxMutex );\r\n\r\n        /* Comments regarding mutual exclusion as per those within\r\n         * xQueueGiveMutexRecursive(). */\r\n\r\n        traceTAKE_MUTEX_RECURSIVE( pxMutex );\r\n\r\n        if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )\r\n        {\r\n            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;\r\n            xReturn = pdPASS;\r\n        }\r\n        else\r\n        {\r\n            xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );\r\n\r\n            /* pdPASS will only be returned if the mutex was successfully\r\n             * obtained.  The calling task may have entered the Blocked state\r\n             * before reaching here. */\r\n            if( xReturn != pdFAIL )\r\n            {\r\n                ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;\r\n            }\r\n            else\r\n            {\r\n                traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );\r\n            }\r\n        }\r\n\r\n        return xReturn;\r\n    }\r\n\r\n#endif /* configUSE_RECURSIVE_MUTEXES */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )\r\n\r\n    QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount,\r\n                                                       const UBaseType_t uxInitialCount,\r\n                                                       StaticQueue_t * pxStaticQueue )\r\n    {\r\n        QueueHandle_t xHandle;\r\n\r\n        configASSERT( uxMaxCount != 0 );\r\n        configASSERT( uxInitialCount <= uxMaxCount );\r\n\r\n        xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStaticQueue, queueQUEUE_TYPE_COUNTING_SEMAPHORE );\r\n\r\n        if( xHandle != NULL )\r\n        {\r\n            ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;\r\n\r\n            traceCREATE_COUNTING_SEMAPHORE();\r\n        }\r\n        else\r\n        {\r\n            traceCREATE_COUNTING_SEMAPHORE_FAILED();\r\n        }\r\n\r\n        return xHandle;\r\n    }\r\n\r\n#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )\r\n\r\n    QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount,\r\n                                                 const UBaseType_t uxInitialCount )\r\n    {\r\n        QueueHandle_t xHandle;\r\n\r\n        configASSERT( uxMaxCount != 0 );\r\n        configASSERT( uxInitialCount <= uxMaxCount );\r\n\r\n        xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );\r\n\r\n        if( xHandle != NULL )\r\n        {\r\n            ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;\r\n\r\n            traceCREATE_COUNTING_SEMAPHORE();\r\n        }\r\n        else\r\n        {\r\n            traceCREATE_COUNTING_SEMAPHORE_FAILED();\r\n        }\r\n\r\n        return xHandle;\r\n    }\r\n\r\n#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */\r\n/*-----------------------------------------------------------*/\r\n\r\nBaseType_t xQueueGenericSend( QueueHandle_t xQueue,\r\n                              const void * const pvItemToQueue,\r\n                              TickType_t xTicksToWait,\r\n                              const BaseType_t xCopyPosition )\r\n{\r\n    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;\r\n    TimeOut_t xTimeOut;\r\n    Queue_t * const pxQueue = xQueue;\r\n\r\n    configASSERT( pxQueue );\r\n    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );\r\n    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );\r\n    #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )\r\n        {\r\n            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );\r\n        }\r\n    #endif\r\n\r\n    /*lint -save -e904 This function relaxes the coding standard somewhat to\r\n     * allow return statements within the function itself.  This is done in the\r\n     * interest of execution time efficiency. */\r\n    for( ; ; )\r\n    {\r\n        taskENTER_CRITICAL();\r\n        {\r\n            /* Is there room on the queue now?  The running task must be the\r\n             * highest priority task wanting to access the queue.  If the head item\r\n             * in the queue is to be overwritten then it does not matter if the\r\n             * queue is full. */\r\n            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )\r\n            {\r\n                traceQUEUE_SEND( pxQueue );\r\n\r\n                #if ( configUSE_QUEUE_SETS == 1 )\r\n                    {\r\n                        const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;\r\n\r\n                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );\r\n\r\n                        if( pxQueue->pxQueueSetContainer != NULL )\r\n                        {\r\n                            if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )\r\n                            {\r\n                                /* Do not notify the queue set as an existing item\r\n                                 * was overwritten in the queue so the number of items\r\n                                 * in the queue has not changed. */\r\n                                mtCOVERAGE_TEST_MARKER();\r\n                            }\r\n                            else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )\r\n                            {\r\n                                /* The queue is a member of a queue set, and posting\r\n                                 * to the queue set caused a higher priority task to\r\n                                 * unblock. A context switch is required. */\r\n                                queueYIELD_IF_USING_PREEMPTION();\r\n                            }\r\n                            else\r\n                            {\r\n                                mtCOVERAGE_TEST_MARKER();\r\n                            }\r\n                        }\r\n                        else\r\n                        {\r\n                            /* If there was a task waiting for data to arrive on the\r\n                             * queue then unblock it now. */\r\n                            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )\r\n                            {\r\n                                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )\r\n                                {\r\n                                    /* The unblocked task has a priority higher than\r\n                                     * our own so yield immediately.  Yes it is ok to\r\n                                     * do this from within the critical section - the\r\n                                     * kernel takes care of that. */\r\n                                    queueYIELD_IF_USING_PREEMPTION();\r\n                                }\r\n                                else\r\n                                {\r\n                                    mtCOVERAGE_TEST_MARKER();\r\n                                }\r\n                            }\r\n                            else if( xYieldRequired != pdFALSE )\r\n                            {\r\n                                /* This path is a special case that will only get\r\n                                 * executed if the task was holding multiple mutexes\r\n                                 * and the mutexes were given back in an order that is\r\n                                 * different to that in which they were taken. */\r\n                                queueYIELD_IF_USING_PREEMPTION();\r\n                            }\r\n                            else\r\n                            {\r\n                                mtCOVERAGE_TEST_MARKER();\r\n                            }\r\n                        }\r\n                    }\r\n                #else /* configUSE_QUEUE_SETS */\r\n                    {\r\n                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );\r\n\r\n                        /* If there was a task waiting for data to arrive on the\r\n                         * queue then unblock it now. */\r\n                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )\r\n                        {\r\n                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )\r\n                            {\r\n                                /* The unblocked task has a priority higher than\r\n                                 * our own so yield immediately.  Yes it is ok to do\r\n                                 * this from within the critical section - the kernel\r\n                                 * takes care of that. */\r\n                                queueYIELD_IF_USING_PREEMPTION();\r\n                            }\r\n                            else\r\n                            {\r\n                                mtCOVERAGE_TEST_MARKER();\r\n                            }\r\n                        }\r\n                        else if( xYieldRequired != pdFALSE )\r\n                        {\r\n                            /* This path is a special case that will only get\r\n                             * executed if the task was holding multiple mutexes and\r\n                             * the mutexes were given back in an order that is\r\n                             * different to that in which they were taken. */\r\n                            queueYIELD_IF_USING_PREEMPTION();\r\n                        }\r\n                        else\r\n                        {\r\n                            mtCOVERAGE_TEST_MARKER();\r\n                        }\r\n                    }\r\n                #endif /* configUSE_QUEUE_SETS */\r\n\r\n                taskEXIT_CRITICAL();\r\n                return pdPASS;\r\n            }\r\n            else\r\n            {\r\n                if( xTicksToWait == ( TickType_t ) 0 )\r\n                {\r\n                    /* The queue was full and no block time is specified (or\r\n                     * the block time has expired) so leave now. */\r\n                    taskEXIT_CRITICAL();\r\n\r\n                    /* Return to the original privilege level before exiting\r\n                     * the function. */\r\n                    traceQUEUE_SEND_FAILED( pxQueue );\r\n                    return errQUEUE_FULL;\r\n                }\r\n                else if( xEntryTimeSet == pdFALSE )\r\n                {\r\n                    /* The queue was full and a block time was specified so\r\n                     * configure the timeout structure. */\r\n                    vTaskInternalSetTimeOutState( &xTimeOut );\r\n                    xEntryTimeSet = pdTRUE;\r\n                }\r\n                else\r\n                {\r\n                    /* Entry time was already set. */\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n        }\r\n        taskEXIT_CRITICAL();\r\n\r\n        /* Interrupts and other tasks can send to and receive from the queue\r\n         * now the critical section has been exited. */\r\n\r\n        vTaskSuspendAll();\r\n        prvLockQueue( pxQueue );\r\n\r\n        /* Update the timeout state to see if it has expired yet. */\r\n        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )\r\n        {\r\n            if( prvIsQueueFull( pxQueue ) != pdFALSE )\r\n            {\r\n                traceBLOCKING_ON_QUEUE_SEND( pxQueue );\r\n                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );\r\n\r\n                /* Unlocking the queue means queue events can effect the\r\n                 * event list.  It is possible that interrupts occurring now\r\n                 * remove this task from the event list again - but as the\r\n                 * scheduler is suspended the task will go onto the pending\r\n                 * ready last instead of the actual ready list. */\r\n                prvUnlockQueue( pxQueue );\r\n\r\n                /* Resuming the scheduler will move tasks from the pending\r\n                 * ready list into the ready list - so it is feasible that this\r\n                 * task is already in a ready list before it yields - in which\r\n                 * case the yield will not cause a context switch unless there\r\n                 * is also a higher priority task in the pending ready list. */\r\n                if( xTaskResumeAll() == pdFALSE )\r\n                {\r\n                    portYIELD_WITHIN_API();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                /* Try again. */\r\n                prvUnlockQueue( pxQueue );\r\n                ( void ) xTaskResumeAll();\r\n            }\r\n        }\r\n        else\r\n        {\r\n            /* The timeout has expired. */\r\n            prvUnlockQueue( pxQueue );\r\n            ( void ) xTaskResumeAll();\r\n\r\n            traceQUEUE_SEND_FAILED( pxQueue );\r\n            return errQUEUE_FULL;\r\n        }\r\n    } /*lint -restore */\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nBaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,\r\n                                     const void * const pvItemToQueue,\r\n                                     BaseType_t * const pxHigherPriorityTaskWoken,\r\n                                     const BaseType_t xCopyPosition )\r\n{\r\n    BaseType_t xReturn;\r\n    UBaseType_t uxSavedInterruptStatus;\r\n    Queue_t * const pxQueue = xQueue;\r\n\r\n    configASSERT( pxQueue );\r\n    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );\r\n    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );\r\n\r\n    /* RTOS ports that support interrupt nesting have the concept of a maximum\r\n     * system call (or maximum API call) interrupt priority.  Interrupts that are\r\n     * above the maximum system call priority are kept permanently enabled, even\r\n     * when the RTOS kernel is in a critical section, but cannot make any calls to\r\n     * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h\r\n     * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion\r\n     * failure if a FreeRTOS API function is called from an interrupt that has been\r\n     * assigned a priority above the configured maximum system call priority.\r\n     * Only FreeRTOS functions that end in FromISR can be called from interrupts\r\n     * that have been assigned a priority at or (logically) below the maximum\r\n     * system call interrupt priority.  FreeRTOS maintains a separate interrupt\r\n     * safe API to ensure interrupt entry is as fast and as simple as possible.\r\n     * More information (albeit Cortex-M specific) is provided on the following\r\n     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */\r\n    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();\r\n\r\n    /* Similar to xQueueGenericSend, except without blocking if there is no room\r\n     * in the queue.  Also don't directly wake a task that was blocked on a queue\r\n     * read, instead return a flag to say whether a context switch is required or\r\n     * not (i.e. has a task with a higher priority than us been woken by this\r\n     * post). */\r\n    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();\r\n    {\r\n        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )\r\n        {\r\n            const int8_t cTxLock = pxQueue->cTxLock;\r\n            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;\r\n\r\n            traceQUEUE_SEND_FROM_ISR( pxQueue );\r\n\r\n            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a\r\n             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result\r\n             *  in a task disinheriting a priority and prvCopyDataToQueue() can be\r\n             *  called here even though the disinherit function does not check if\r\n             *  the scheduler is suspended before accessing the ready lists. */\r\n            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );\r\n\r\n            /* The event list is not altered if the queue is locked.  This will\r\n             * be done when the queue is unlocked later. */\r\n            if( cTxLock == queueUNLOCKED )\r\n            {\r\n                #if ( configUSE_QUEUE_SETS == 1 )\r\n                    {\r\n                        if( pxQueue->pxQueueSetContainer != NULL )\r\n                        {\r\n                            if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )\r\n                            {\r\n                                /* Do not notify the queue set as an existing item\r\n                                 * was overwritten in the queue so the number of items\r\n                                 * in the queue has not changed. */\r\n                                mtCOVERAGE_TEST_MARKER();\r\n                            }\r\n                            else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )\r\n                            {\r\n                                /* The queue is a member of a queue set, and posting\r\n                                 * to the queue set caused a higher priority task to\r\n                                 * unblock.  A context switch is required. */\r\n                                if( pxHigherPriorityTaskWoken != NULL )\r\n                                {\r\n                                    *pxHigherPriorityTaskWoken = pdTRUE;\r\n                                }\r\n                                else\r\n                                {\r\n                                    mtCOVERAGE_TEST_MARKER();\r\n                                }\r\n                            }\r\n                            else\r\n                            {\r\n                                mtCOVERAGE_TEST_MARKER();\r\n                            }\r\n                        }\r\n                        else\r\n                        {\r\n                            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )\r\n                            {\r\n                                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )\r\n                                {\r\n                                    /* The task waiting has a higher priority so\r\n                                     *  record that a context switch is required. */\r\n                                    if( pxHigherPriorityTaskWoken != NULL )\r\n                                    {\r\n                                        *pxHigherPriorityTaskWoken = pdTRUE;\r\n                                    }\r\n                                    else\r\n                                    {\r\n                                        mtCOVERAGE_TEST_MARKER();\r\n                                    }\r\n                                }\r\n                                else\r\n                                {\r\n                                    mtCOVERAGE_TEST_MARKER();\r\n                                }\r\n                            }\r\n                            else\r\n                            {\r\n                                mtCOVERAGE_TEST_MARKER();\r\n                            }\r\n                        }\r\n                    }\r\n                #else /* configUSE_QUEUE_SETS */\r\n                    {\r\n                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )\r\n                        {\r\n                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )\r\n                            {\r\n                                /* The task waiting has a higher priority so record that a\r\n                                 * context switch is required. */\r\n                                if( pxHigherPriorityTaskWoken != NULL )\r\n                                {\r\n                                    *pxHigherPriorityTaskWoken = pdTRUE;\r\n                                }\r\n                                else\r\n                                {\r\n                                    mtCOVERAGE_TEST_MARKER();\r\n                                }\r\n                            }\r\n                            else\r\n                            {\r\n                                mtCOVERAGE_TEST_MARKER();\r\n                            }\r\n                        }\r\n                        else\r\n                        {\r\n                            mtCOVERAGE_TEST_MARKER();\r\n                        }\r\n\r\n                        /* Not used in this path. */\r\n                        ( void ) uxPreviousMessagesWaiting;\r\n                    }\r\n                #endif /* configUSE_QUEUE_SETS */\r\n            }\r\n            else\r\n            {\r\n                /* Increment the lock count so the task that unlocks the queue\r\n                 * knows that data was posted while it was locked. */\r\n                configASSERT( cTxLock != queueINT8_MAX );\r\n\r\n                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );\r\n            }\r\n\r\n            xReturn = pdPASS;\r\n        }\r\n        else\r\n        {\r\n            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );\r\n            xReturn = errQUEUE_FULL;\r\n        }\r\n    }\r\n    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );\r\n\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nBaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,\r\n                              BaseType_t * const pxHigherPriorityTaskWoken )\r\n{\r\n    BaseType_t xReturn;\r\n    UBaseType_t uxSavedInterruptStatus;\r\n    Queue_t * const pxQueue = xQueue;\r\n\r\n    /* Similar to xQueueGenericSendFromISR() but used with semaphores where the\r\n     * item size is 0.  Don't directly wake a task that was blocked on a queue\r\n     * read, instead return a flag to say whether a context switch is required or\r\n     * not (i.e. has a task with a higher priority than us been woken by this\r\n     * post). */\r\n\r\n    configASSERT( pxQueue );\r\n\r\n    /* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()\r\n     * if the item size is not 0. */\r\n    configASSERT( pxQueue->uxItemSize == 0 );\r\n\r\n    /* Normally a mutex would not be given from an interrupt, especially if\r\n     * there is a mutex holder, as priority inheritance makes no sense for an\r\n     * interrupts, only tasks. */\r\n    configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );\r\n\r\n    /* RTOS ports that support interrupt nesting have the concept of a maximum\r\n     * system call (or maximum API call) interrupt priority.  Interrupts that are\r\n     * above the maximum system call priority are kept permanently enabled, even\r\n     * when the RTOS kernel is in a critical section, but cannot make any calls to\r\n     * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h\r\n     * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion\r\n     * failure if a FreeRTOS API function is called from an interrupt that has been\r\n     * assigned a priority above the configured maximum system call priority.\r\n     * Only FreeRTOS functions that end in FromISR can be called from interrupts\r\n     * that have been assigned a priority at or (logically) below the maximum\r\n     * system call interrupt priority.  FreeRTOS maintains a separate interrupt\r\n     * safe API to ensure interrupt entry is as fast and as simple as possible.\r\n     * More information (albeit Cortex-M specific) is provided on the following\r\n     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */\r\n    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();\r\n\r\n    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();\r\n    {\r\n        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;\r\n\r\n        /* When the queue is used to implement a semaphore no data is ever\r\n         * moved through the queue but it is still valid to see if the queue 'has\r\n         * space'. */\r\n        if( uxMessagesWaiting < pxQueue->uxLength )\r\n        {\r\n            const int8_t cTxLock = pxQueue->cTxLock;\r\n\r\n            traceQUEUE_SEND_FROM_ISR( pxQueue );\r\n\r\n            /* A task can only have an inherited priority if it is a mutex\r\n             * holder - and if there is a mutex holder then the mutex cannot be\r\n             * given from an ISR.  As this is the ISR version of the function it\r\n             * can be assumed there is no mutex holder and no need to determine if\r\n             * priority disinheritance is needed.  Simply increase the count of\r\n             * messages (semaphores) available. */\r\n            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;\r\n\r\n            /* The event list is not altered if the queue is locked.  This will\r\n             * be done when the queue is unlocked later. */\r\n            if( cTxLock == queueUNLOCKED )\r\n            {\r\n                #if ( configUSE_QUEUE_SETS == 1 )\r\n                    {\r\n                        if( pxQueue->pxQueueSetContainer != NULL )\r\n                        {\r\n                            if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )\r\n                            {\r\n                                /* The semaphore is a member of a queue set, and\r\n                                 * posting to the queue set caused a higher priority\r\n                                 * task to unblock.  A context switch is required. */\r\n                                if( pxHigherPriorityTaskWoken != NULL )\r\n                                {\r\n                                    *pxHigherPriorityTaskWoken = pdTRUE;\r\n                                }\r\n                                else\r\n                                {\r\n                                    mtCOVERAGE_TEST_MARKER();\r\n                                }\r\n                            }\r\n                            else\r\n                            {\r\n                                mtCOVERAGE_TEST_MARKER();\r\n                            }\r\n                        }\r\n                        else\r\n                        {\r\n                            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )\r\n                            {\r\n                                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )\r\n                                {\r\n                                    /* The task waiting has a higher priority so\r\n                                     *  record that a context switch is required. */\r\n                                    if( pxHigherPriorityTaskWoken != NULL )\r\n                                    {\r\n                                        *pxHigherPriorityTaskWoken = pdTRUE;\r\n                                    }\r\n                                    else\r\n                                    {\r\n                                        mtCOVERAGE_TEST_MARKER();\r\n                                    }\r\n                                }\r\n                                else\r\n                                {\r\n                                    mtCOVERAGE_TEST_MARKER();\r\n                                }\r\n                            }\r\n                            else\r\n                            {\r\n                                mtCOVERAGE_TEST_MARKER();\r\n                            }\r\n                        }\r\n                    }\r\n                #else /* configUSE_QUEUE_SETS */\r\n                    {\r\n                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )\r\n                        {\r\n                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )\r\n                            {\r\n                                /* The task waiting has a higher priority so record that a\r\n                                 * context switch is required. */\r\n                                if( pxHigherPriorityTaskWoken != NULL )\r\n                                {\r\n                                    *pxHigherPriorityTaskWoken = pdTRUE;\r\n                                }\r\n                                else\r\n                                {\r\n                                    mtCOVERAGE_TEST_MARKER();\r\n                                }\r\n                            }\r\n                            else\r\n                            {\r\n                                mtCOVERAGE_TEST_MARKER();\r\n                            }\r\n                        }\r\n                        else\r\n                        {\r\n                            mtCOVERAGE_TEST_MARKER();\r\n                        }\r\n                    }\r\n                #endif /* configUSE_QUEUE_SETS */\r\n            }\r\n            else\r\n            {\r\n                /* Increment the lock count so the task that unlocks the queue\r\n                 * knows that data was posted while it was locked. */\r\n                configASSERT( cTxLock != queueINT8_MAX );\r\n\r\n                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );\r\n            }\r\n\r\n            xReturn = pdPASS;\r\n        }\r\n        else\r\n        {\r\n            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );\r\n            xReturn = errQUEUE_FULL;\r\n        }\r\n    }\r\n    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );\r\n\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nBaseType_t xQueueReceive( QueueHandle_t xQueue,\r\n                          void * const pvBuffer,\r\n                          TickType_t xTicksToWait )\r\n{\r\n    BaseType_t xEntryTimeSet = pdFALSE;\r\n    TimeOut_t xTimeOut;\r\n    Queue_t * const pxQueue = xQueue;\r\n\r\n    /* Check the pointer is not NULL. */\r\n    configASSERT( ( pxQueue ) );\r\n\r\n    /* The buffer into which data is received can only be NULL if the data size\r\n     * is zero (so no data is copied into the buffer). */\r\n    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );\r\n\r\n    /* Cannot block if the scheduler is suspended. */\r\n    #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )\r\n        {\r\n            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );\r\n        }\r\n    #endif\r\n\r\n    /*lint -save -e904  This function relaxes the coding standard somewhat to\r\n     * allow return statements within the function itself.  This is done in the\r\n     * interest of execution time efficiency. */\r\n    for( ; ; )\r\n    {\r\n        taskENTER_CRITICAL();\r\n        {\r\n            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;\r\n\r\n            /* Is there data in the queue now?  To be running the calling task\r\n             * must be the highest priority task wanting to access the queue. */\r\n            if( uxMessagesWaiting > ( UBaseType_t ) 0 )\r\n            {\r\n                /* Data available, remove one item. */\r\n                prvCopyDataFromQueue( pxQueue, pvBuffer );\r\n                traceQUEUE_RECEIVE( pxQueue );\r\n                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;\r\n\r\n                /* There is now space in the queue, were any tasks waiting to\r\n                 * post to the queue?  If so, unblock the highest priority waiting\r\n                 * task. */\r\n                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )\r\n                {\r\n                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )\r\n                    {\r\n                        queueYIELD_IF_USING_PREEMPTION();\r\n                    }\r\n                    else\r\n                    {\r\n                        mtCOVERAGE_TEST_MARKER();\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n\r\n                taskEXIT_CRITICAL();\r\n                return pdPASS;\r\n            }\r\n            else\r\n            {\r\n                if( xTicksToWait == ( TickType_t ) 0 )\r\n                {\r\n                    /* The queue was empty and no block time is specified (or\r\n                     * the block time has expired) so leave now. */\r\n                    taskEXIT_CRITICAL();\r\n                    traceQUEUE_RECEIVE_FAILED( pxQueue );\r\n                    return errQUEUE_EMPTY;\r\n                }\r\n                else if( xEntryTimeSet == pdFALSE )\r\n                {\r\n                    /* The queue was empty and a block time was specified so\r\n                     * configure the timeout structure. */\r\n                    vTaskInternalSetTimeOutState( &xTimeOut );\r\n                    xEntryTimeSet = pdTRUE;\r\n                }\r\n                else\r\n                {\r\n                    /* Entry time was already set. */\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n        }\r\n        taskEXIT_CRITICAL();\r\n\r\n        /* Interrupts and other tasks can send to and receive from the queue\r\n         * now the critical section has been exited. */\r\n\r\n        vTaskSuspendAll();\r\n        prvLockQueue( pxQueue );\r\n\r\n        /* Update the timeout state to see if it has expired yet. */\r\n        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )\r\n        {\r\n            /* The timeout has not expired.  If the queue is still empty place\r\n             * the task on the list of tasks waiting to receive from the queue. */\r\n            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )\r\n            {\r\n                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );\r\n                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );\r\n                prvUnlockQueue( pxQueue );\r\n\r\n                if( xTaskResumeAll() == pdFALSE )\r\n                {\r\n                    portYIELD_WITHIN_API();\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                /* The queue contains data again.  Loop back to try and read the\r\n                 * data. */\r\n                prvUnlockQueue( pxQueue );\r\n                ( void ) xTaskResumeAll();\r\n            }\r\n        }\r\n        else\r\n        {\r\n            /* Timed out.  If there is no data in the queue exit, otherwise loop\r\n             * back and attempt to read the data. */\r\n            prvUnlockQueue( pxQueue );\r\n            ( void ) xTaskResumeAll();\r\n\r\n            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )\r\n            {\r\n                traceQUEUE_RECEIVE_FAILED( pxQueue );\r\n                return errQUEUE_EMPTY;\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n    } /*lint -restore */\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nBaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,\r\n                                TickType_t xTicksToWait )\r\n{\r\n    BaseType_t xEntryTimeSet = pdFALSE;\r\n    TimeOut_t xTimeOut;\r\n    Queue_t * const pxQueue = xQueue;\r\n\r\n    #if ( configUSE_MUTEXES == 1 )\r\n        BaseType_t xInheritanceOccurred = pdFALSE;\r\n    #endif\r\n\r\n    /* Check the queue pointer is not NULL. */\r\n    configASSERT( ( pxQueue ) );\r\n\r\n    /* Check this really is a semaphore, in which case the item size will be\r\n     * 0. */\r\n    configASSERT( pxQueue->uxItemSize == 0 );\r\n\r\n    /* Cannot block if the scheduler is suspended. */\r\n    #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )\r\n        {\r\n            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );\r\n        }\r\n    #endif\r\n\r\n    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return\r\n     * statements within the function itself.  This is done in the interest\r\n     * of execution time efficiency. */\r\n    for( ; ; )\r\n    {\r\n        taskENTER_CRITICAL();\r\n        {\r\n            /* Semaphores are queues with an item size of 0, and where the\r\n             * number of messages in the queue is the semaphore's count value. */\r\n            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;\r\n\r\n            /* Is there data in the queue now?  To be running the calling task\r\n             * must be the highest priority task wanting to access the queue. */\r\n            if( uxSemaphoreCount > ( UBaseType_t ) 0 )\r\n            {\r\n                traceQUEUE_RECEIVE( pxQueue );\r\n\r\n                /* Semaphores are queues with a data size of zero and where the\r\n                 * messages waiting is the semaphore's count.  Reduce the count. */\r\n                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;\r\n\r\n                #if ( configUSE_MUTEXES == 1 )\r\n                    {\r\n                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )\r\n                        {\r\n                            /* Record the information required to implement\r\n                             * priority inheritance should it become necessary. */\r\n                            pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();\r\n                        }\r\n                        else\r\n                        {\r\n                            mtCOVERAGE_TEST_MARKER();\r\n                        }\r\n                    }\r\n                #endif /* configUSE_MUTEXES */\r\n\r\n                /* Check to see if other tasks are blocked waiting to give the\r\n                 * semaphore, and if so, unblock the highest priority such task. */\r\n                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )\r\n                {\r\n                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )\r\n                    {\r\n                        queueYIELD_IF_USING_PREEMPTION();\r\n                    }\r\n                    else\r\n                    {\r\n                        mtCOVERAGE_TEST_MARKER();\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n\r\n                taskEXIT_CRITICAL();\r\n                return pdPASS;\r\n            }\r\n            else\r\n            {\r\n                if( xTicksToWait == ( TickType_t ) 0 )\r\n                {\r\n                    /* For inheritance to have occurred there must have been an\r\n                     * initial timeout, and an adjusted timeout cannot become 0, as\r\n                     * if it were 0 the function would have exited. */\r\n                    #if ( configUSE_MUTEXES == 1 )\r\n                        {\r\n                            configASSERT( xInheritanceOccurred == pdFALSE );\r\n                        }\r\n                    #endif /* configUSE_MUTEXES */\r\n\r\n                    /* The semaphore count was 0 and no block time is specified\r\n                     * (or the block time has expired) so exit now. */\r\n                    taskEXIT_CRITICAL();\r\n                    traceQUEUE_RECEIVE_FAILED( pxQueue );\r\n                    return errQUEUE_EMPTY;\r\n                }\r\n                else if( xEntryTimeSet == pdFALSE )\r\n                {\r\n                    /* The semaphore count was 0 and a block time was specified\r\n                     * so configure the timeout structure ready to block. */\r\n                    vTaskInternalSetTimeOutState( &xTimeOut );\r\n                    xEntryTimeSet = pdTRUE;\r\n                }\r\n                else\r\n                {\r\n                    /* Entry time was already set. */\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n        }\r\n        taskEXIT_CRITICAL();\r\n\r\n        /* Interrupts and other tasks can give to and take from the semaphore\r\n         * now the critical section has been exited. */\r\n\r\n        vTaskSuspendAll();\r\n        prvLockQueue( pxQueue );\r\n\r\n        /* Update the timeout state to see if it has expired yet. */\r\n        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )\r\n        {\r\n            /* A block time is specified and not expired.  If the semaphore\r\n             * count is 0 then enter the Blocked state to wait for a semaphore to\r\n             * become available.  As semaphores are implemented with queues the\r\n             * queue being empty is equivalent to the semaphore count being 0. */\r\n            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )\r\n            {\r\n                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );\r\n\r\n                #if ( configUSE_MUTEXES == 1 )\r\n                    {\r\n                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )\r\n                        {\r\n                            taskENTER_CRITICAL();\r\n                            {\r\n                                xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );\r\n                            }\r\n                            taskEXIT_CRITICAL();\r\n                        }\r\n                        else\r\n                        {\r\n                            mtCOVERAGE_TEST_MARKER();\r\n                        }\r\n                    }\r\n                #endif /* if ( configUSE_MUTEXES == 1 ) */\r\n\r\n                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );\r\n                prvUnlockQueue( pxQueue );\r\n\r\n                if( xTaskResumeAll() == pdFALSE )\r\n                {\r\n                    portYIELD_WITHIN_API();\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                /* There was no timeout and the semaphore count was not 0, so\r\n                 * attempt to take the semaphore again. */\r\n                prvUnlockQueue( pxQueue );\r\n                ( void ) xTaskResumeAll();\r\n            }\r\n        }\r\n        else\r\n        {\r\n            /* Timed out. */\r\n            prvUnlockQueue( pxQueue );\r\n            ( void ) xTaskResumeAll();\r\n\r\n            /* If the semaphore count is 0 exit now as the timeout has\r\n             * expired.  Otherwise return to attempt to take the semaphore that is\r\n             * known to be available.  As semaphores are implemented by queues the\r\n             * queue being empty is equivalent to the semaphore count being 0. */\r\n            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )\r\n            {\r\n                #if ( configUSE_MUTEXES == 1 )\r\n                    {\r\n                        /* xInheritanceOccurred could only have be set if\r\n                         * pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to\r\n                         * test the mutex type again to check it is actually a mutex. */\r\n                        if( xInheritanceOccurred != pdFALSE )\r\n                        {\r\n                            taskENTER_CRITICAL();\r\n                            {\r\n                                UBaseType_t uxHighestWaitingPriority;\r\n\r\n                                /* This task blocking on the mutex caused another\r\n                                 * task to inherit this task's priority.  Now this task\r\n                                 * has timed out the priority should be disinherited\r\n                                 * again, but only as low as the next highest priority\r\n                                 * task that is waiting for the same mutex. */\r\n                                uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );\r\n                                vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );\r\n                            }\r\n                            taskEXIT_CRITICAL();\r\n                        }\r\n                    }\r\n                #endif /* configUSE_MUTEXES */\r\n\r\n                traceQUEUE_RECEIVE_FAILED( pxQueue );\r\n                return errQUEUE_EMPTY;\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n    } /*lint -restore */\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nBaseType_t xQueuePeek( QueueHandle_t xQueue,\r\n                       void * const pvBuffer,\r\n                       TickType_t xTicksToWait )\r\n{\r\n    BaseType_t xEntryTimeSet = pdFALSE;\r\n    TimeOut_t xTimeOut;\r\n    int8_t * pcOriginalReadPosition;\r\n    Queue_t * const pxQueue = xQueue;\r\n\r\n    /* Check the pointer is not NULL. */\r\n    configASSERT( ( pxQueue ) );\r\n\r\n    /* The buffer into which data is received can only be NULL if the data size\r\n     * is zero (so no data is copied into the buffer. */\r\n    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );\r\n\r\n    /* Cannot block if the scheduler is suspended. */\r\n    #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )\r\n        {\r\n            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );\r\n        }\r\n    #endif\r\n\r\n    /*lint -save -e904  This function relaxes the coding standard somewhat to\r\n     * allow return statements within the function itself.  This is done in the\r\n     * interest of execution time efficiency. */\r\n    for( ; ; )\r\n    {\r\n        taskENTER_CRITICAL();\r\n        {\r\n            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;\r\n\r\n            /* Is there data in the queue now?  To be running the calling task\r\n             * must be the highest priority task wanting to access the queue. */\r\n            if( uxMessagesWaiting > ( UBaseType_t ) 0 )\r\n            {\r\n                /* Remember the read position so it can be reset after the data\r\n                 * is read from the queue as this function is only peeking the\r\n                 * data, not removing it. */\r\n                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;\r\n\r\n                prvCopyDataFromQueue( pxQueue, pvBuffer );\r\n                traceQUEUE_PEEK( pxQueue );\r\n\r\n                /* The data is not being removed, so reset the read pointer. */\r\n                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;\r\n\r\n                /* The data is being left in the queue, so see if there are\r\n                 * any other tasks waiting for the data. */\r\n                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )\r\n                {\r\n                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )\r\n                    {\r\n                        /* The task waiting has a higher priority than this task. */\r\n                        queueYIELD_IF_USING_PREEMPTION();\r\n                    }\r\n                    else\r\n                    {\r\n                        mtCOVERAGE_TEST_MARKER();\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n\r\n                taskEXIT_CRITICAL();\r\n                return pdPASS;\r\n            }\r\n            else\r\n            {\r\n                if( xTicksToWait == ( TickType_t ) 0 )\r\n                {\r\n                    /* The queue was empty and no block time is specified (or\r\n                     * the block time has expired) so leave now. */\r\n                    taskEXIT_CRITICAL();\r\n                    traceQUEUE_PEEK_FAILED( pxQueue );\r\n                    return errQUEUE_EMPTY;\r\n                }\r\n                else if( xEntryTimeSet == pdFALSE )\r\n                {\r\n                    /* The queue was empty and a block time was specified so\r\n                     * configure the timeout structure ready to enter the blocked\r\n                     * state. */\r\n                    vTaskInternalSetTimeOutState( &xTimeOut );\r\n                    xEntryTimeSet = pdTRUE;\r\n                }\r\n                else\r\n                {\r\n                    /* Entry time was already set. */\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n        }\r\n        taskEXIT_CRITICAL();\r\n\r\n        /* Interrupts and other tasks can send to and receive from the queue\r\n         * now the critical section has been exited. */\r\n\r\n        vTaskSuspendAll();\r\n        prvLockQueue( pxQueue );\r\n\r\n        /* Update the timeout state to see if it has expired yet. */\r\n        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )\r\n        {\r\n            /* Timeout has not expired yet, check to see if there is data in the\r\n            * queue now, and if not enter the Blocked state to wait for data. */\r\n            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )\r\n            {\r\n                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );\r\n                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );\r\n                prvUnlockQueue( pxQueue );\r\n\r\n                if( xTaskResumeAll() == pdFALSE )\r\n                {\r\n                    portYIELD_WITHIN_API();\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                /* There is data in the queue now, so don't enter the blocked\r\n                 * state, instead return to try and obtain the data. */\r\n                prvUnlockQueue( pxQueue );\r\n                ( void ) xTaskResumeAll();\r\n            }\r\n        }\r\n        else\r\n        {\r\n            /* The timeout has expired.  If there is still no data in the queue\r\n             * exit, otherwise go back and try to read the data again. */\r\n            prvUnlockQueue( pxQueue );\r\n            ( void ) xTaskResumeAll();\r\n\r\n            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )\r\n            {\r\n                traceQUEUE_PEEK_FAILED( pxQueue );\r\n                return errQUEUE_EMPTY;\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n    } /*lint -restore */\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nBaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,\r\n                                 void * const pvBuffer,\r\n                                 BaseType_t * const pxHigherPriorityTaskWoken )\r\n{\r\n    BaseType_t xReturn;\r\n    UBaseType_t uxSavedInterruptStatus;\r\n    Queue_t * const pxQueue = xQueue;\r\n\r\n    configASSERT( pxQueue );\r\n    configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );\r\n\r\n    /* RTOS ports that support interrupt nesting have the concept of a maximum\r\n     * system call (or maximum API call) interrupt priority.  Interrupts that are\r\n     * above the maximum system call priority are kept permanently enabled, even\r\n     * when the RTOS kernel is in a critical section, but cannot make any calls to\r\n     * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h\r\n     * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion\r\n     * failure if a FreeRTOS API function is called from an interrupt that has been\r\n     * assigned a priority above the configured maximum system call priority.\r\n     * Only FreeRTOS functions that end in FromISR can be called from interrupts\r\n     * that have been assigned a priority at or (logically) below the maximum\r\n     * system call interrupt priority.  FreeRTOS maintains a separate interrupt\r\n     * safe API to ensure interrupt entry is as fast and as simple as possible.\r\n     * More information (albeit Cortex-M specific) is provided on the following\r\n     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */\r\n    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();\r\n\r\n    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();\r\n    {\r\n        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;\r\n\r\n        /* Cannot block in an ISR, so check there is data available. */\r\n        if( uxMessagesWaiting > ( UBaseType_t ) 0 )\r\n        {\r\n            const int8_t cRxLock = pxQueue->cRxLock;\r\n\r\n            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );\r\n\r\n            prvCopyDataFromQueue( pxQueue, pvBuffer );\r\n            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;\r\n\r\n            /* If the queue is locked the event list will not be modified.\r\n             * Instead update the lock count so the task that unlocks the queue\r\n             * will know that an ISR has removed data while the queue was\r\n             * locked. */\r\n            if( cRxLock == queueUNLOCKED )\r\n            {\r\n                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )\r\n                {\r\n                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )\r\n                    {\r\n                        /* The task waiting has a higher priority than us so\r\n                         * force a context switch. */\r\n                        if( pxHigherPriorityTaskWoken != NULL )\r\n                        {\r\n                            *pxHigherPriorityTaskWoken = pdTRUE;\r\n                        }\r\n                        else\r\n                        {\r\n                            mtCOVERAGE_TEST_MARKER();\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        mtCOVERAGE_TEST_MARKER();\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                /* Increment the lock count so the task that unlocks the queue\r\n                 * knows that data was removed while it was locked. */\r\n                configASSERT( cRxLock != queueINT8_MAX );\r\n\r\n                pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );\r\n            }\r\n\r\n            xReturn = pdPASS;\r\n        }\r\n        else\r\n        {\r\n            xReturn = pdFAIL;\r\n            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );\r\n        }\r\n    }\r\n    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );\r\n\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nBaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,\r\n                              void * const pvBuffer )\r\n{\r\n    BaseType_t xReturn;\r\n    UBaseType_t uxSavedInterruptStatus;\r\n    int8_t * pcOriginalReadPosition;\r\n    Queue_t * const pxQueue = xQueue;\r\n\r\n    configASSERT( pxQueue );\r\n    configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );\r\n    configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */\r\n\r\n    /* RTOS ports that support interrupt nesting have the concept of a maximum\r\n     * system call (or maximum API call) interrupt priority.  Interrupts that are\r\n     * above the maximum system call priority are kept permanently enabled, even\r\n     * when the RTOS kernel is in a critical section, but cannot make any calls to\r\n     * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h\r\n     * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion\r\n     * failure if a FreeRTOS API function is called from an interrupt that has been\r\n     * assigned a priority above the configured maximum system call priority.\r\n     * Only FreeRTOS functions that end in FromISR can be called from interrupts\r\n     * that have been assigned a priority at or (logically) below the maximum\r\n     * system call interrupt priority.  FreeRTOS maintains a separate interrupt\r\n     * safe API to ensure interrupt entry is as fast and as simple as possible.\r\n     * More information (albeit Cortex-M specific) is provided on the following\r\n     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */\r\n    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();\r\n\r\n    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();\r\n    {\r\n        /* Cannot block in an ISR, so check there is data available. */\r\n        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )\r\n        {\r\n            traceQUEUE_PEEK_FROM_ISR( pxQueue );\r\n\r\n            /* Remember the read position so it can be reset as nothing is\r\n             * actually being removed from the queue. */\r\n            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;\r\n            prvCopyDataFromQueue( pxQueue, pvBuffer );\r\n            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;\r\n\r\n            xReturn = pdPASS;\r\n        }\r\n        else\r\n        {\r\n            xReturn = pdFAIL;\r\n            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );\r\n        }\r\n    }\r\n    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );\r\n\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nUBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )\r\n{\r\n    UBaseType_t uxReturn;\r\n\r\n    configASSERT( xQueue );\r\n\r\n    taskENTER_CRITICAL();\r\n    {\r\n        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;\r\n    }\r\n    taskEXIT_CRITICAL();\r\n\r\n    return uxReturn;\r\n} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */\r\n/*-----------------------------------------------------------*/\r\n\r\nUBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )\r\n{\r\n    UBaseType_t uxReturn;\r\n    Queue_t * const pxQueue = xQueue;\r\n\r\n    configASSERT( pxQueue );\r\n\r\n    taskENTER_CRITICAL();\r\n    {\r\n        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;\r\n    }\r\n    taskEXIT_CRITICAL();\r\n\r\n    return uxReturn;\r\n} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */\r\n/*-----------------------------------------------------------*/\r\n\r\nUBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )\r\n{\r\n    UBaseType_t uxReturn;\r\n    Queue_t * const pxQueue = xQueue;\r\n\r\n    configASSERT( pxQueue );\r\n    uxReturn = pxQueue->uxMessagesWaiting;\r\n\r\n    return uxReturn;\r\n} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */\r\n/*-----------------------------------------------------------*/\r\n\r\nvoid vQueueDelete( QueueHandle_t xQueue )\r\n{\r\n    Queue_t * const pxQueue = xQueue;\r\n\r\n    configASSERT( pxQueue );\r\n    traceQUEUE_DELETE( pxQueue );\r\n\r\n    #if ( configQUEUE_REGISTRY_SIZE > 0 )\r\n        {\r\n            vQueueUnregisterQueue( pxQueue );\r\n        }\r\n    #endif\r\n\r\n    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )\r\n        {\r\n            /* The queue can only have been allocated dynamically - free it\r\n             * again. */\r\n            vPortFree( pxQueue );\r\n        }\r\n    #elif ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )\r\n        {\r\n            /* The queue could have been allocated statically or dynamically, so\r\n             * check before attempting to free the memory. */\r\n            if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )\r\n            {\r\n                vPortFree( pxQueue );\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n    #else /* if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) ) */\r\n        {\r\n            /* The queue must have been statically allocated, so is not going to be\r\n             * deleted.  Avoid compiler warnings about the unused parameter. */\r\n            ( void ) pxQueue;\r\n        }\r\n    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_TRACE_FACILITY == 1 )\r\n\r\n    UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )\r\n    {\r\n        return ( ( Queue_t * ) xQueue )->uxQueueNumber;\r\n    }\r\n\r\n#endif /* configUSE_TRACE_FACILITY */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_TRACE_FACILITY == 1 )\r\n\r\n    void vQueueSetQueueNumber( QueueHandle_t xQueue,\r\n                               UBaseType_t uxQueueNumber )\r\n    {\r\n        ( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;\r\n    }\r\n\r\n#endif /* configUSE_TRACE_FACILITY */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_TRACE_FACILITY == 1 )\r\n\r\n    uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )\r\n    {\r\n        return ( ( Queue_t * ) xQueue )->ucQueueType;\r\n    }\r\n\r\n#endif /* configUSE_TRACE_FACILITY */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_MUTEXES == 1 )\r\n\r\n    static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )\r\n    {\r\n        UBaseType_t uxHighestPriorityOfWaitingTasks;\r\n\r\n        /* If a task waiting for a mutex causes the mutex holder to inherit a\r\n         * priority, but the waiting task times out, then the holder should\r\n         * disinherit the priority - but only down to the highest priority of any\r\n         * other tasks that are waiting for the same mutex.  For this purpose,\r\n         * return the priority of the highest priority task that is waiting for the\r\n         * mutex. */\r\n        if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )\r\n        {\r\n            uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );\r\n        }\r\n        else\r\n        {\r\n            uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;\r\n        }\r\n\r\n        return uxHighestPriorityOfWaitingTasks;\r\n    }\r\n\r\n#endif /* configUSE_MUTEXES */\r\n/*-----------------------------------------------------------*/\r\n\r\nstatic BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,\r\n                                      const void * pvItemToQueue,\r\n                                      const BaseType_t xPosition )\r\n{\r\n    BaseType_t xReturn = pdFALSE;\r\n    UBaseType_t uxMessagesWaiting;\r\n\r\n    /* This function is called from a critical section. */\r\n\r\n    uxMessagesWaiting = pxQueue->uxMessagesWaiting;\r\n\r\n    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )\r\n    {\r\n        #if ( configUSE_MUTEXES == 1 )\r\n            {\r\n                if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )\r\n                {\r\n                    /* The mutex is no longer being held. */\r\n                    xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );\r\n                    pxQueue->u.xSemaphore.xMutexHolder = NULL;\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n        #endif /* configUSE_MUTEXES */\r\n    }\r\n    else if( xPosition == queueSEND_TO_BACK )\r\n    {\r\n        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */\r\n        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */\r\n\r\n        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */\r\n        {\r\n            pxQueue->pcWriteTo = pxQueue->pcHead;\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n    }\r\n    else\r\n    {\r\n        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */\r\n        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;\r\n\r\n        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */\r\n        {\r\n            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n\r\n        if( xPosition == queueOVERWRITE )\r\n        {\r\n            if( uxMessagesWaiting > ( UBaseType_t ) 0 )\r\n            {\r\n                /* An item is not being added but overwritten, so subtract\r\n                 * one from the recorded number of items in the queue so when\r\n                 * one is added again below the number of recorded items remains\r\n                 * correct. */\r\n                --uxMessagesWaiting;\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n    }\r\n\r\n    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;\r\n\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nstatic void prvCopyDataFromQueue( Queue_t * const pxQueue,\r\n                                  void * const pvBuffer )\r\n{\r\n    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )\r\n    {\r\n        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */\r\n\r\n        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */\r\n        {\r\n            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n\r\n        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */\r\n    }\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nstatic void prvUnlockQueue( Queue_t * const pxQueue )\r\n{\r\n    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */\r\n\r\n    /* The lock counts contains the number of extra data items placed or\r\n     * removed from the queue while the queue was locked.  When a queue is\r\n     * locked items can be added or removed, but the event lists cannot be\r\n     * updated. */\r\n    taskENTER_CRITICAL();\r\n    {\r\n        int8_t cTxLock = pxQueue->cTxLock;\r\n\r\n        /* See if data was added to the queue while it was locked. */\r\n        while( cTxLock > queueLOCKED_UNMODIFIED )\r\n        {\r\n            /* Data was posted while the queue was locked.  Are any tasks\r\n             * blocked waiting for data to become available? */\r\n            #if ( configUSE_QUEUE_SETS == 1 )\r\n                {\r\n                    if( pxQueue->pxQueueSetContainer != NULL )\r\n                    {\r\n                        if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )\r\n                        {\r\n                            /* The queue is a member of a queue set, and posting to\r\n                             * the queue set caused a higher priority task to unblock.\r\n                             * A context switch is required. */\r\n                            vTaskMissedYield();\r\n                        }\r\n                        else\r\n                        {\r\n                            mtCOVERAGE_TEST_MARKER();\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        /* Tasks that are removed from the event list will get\r\n                         * added to the pending ready list as the scheduler is still\r\n                         * suspended. */\r\n                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )\r\n                        {\r\n                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )\r\n                            {\r\n                                /* The task waiting has a higher priority so record that a\r\n                                 * context switch is required. */\r\n                                vTaskMissedYield();\r\n                            }\r\n                            else\r\n                            {\r\n                                mtCOVERAGE_TEST_MARKER();\r\n                            }\r\n                        }\r\n                        else\r\n                        {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            #else /* configUSE_QUEUE_SETS */\r\n                {\r\n                    /* Tasks that are removed from the event list will get added to\r\n                     * the pending ready list as the scheduler is still suspended. */\r\n                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )\r\n                    {\r\n                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )\r\n                        {\r\n                            /* The task waiting has a higher priority so record that\r\n                             * a context switch is required. */\r\n                            vTaskMissedYield();\r\n                        }\r\n                        else\r\n                        {\r\n                            mtCOVERAGE_TEST_MARKER();\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        break;\r\n                    }\r\n                }\r\n            #endif /* configUSE_QUEUE_SETS */\r\n\r\n            --cTxLock;\r\n        }\r\n\r\n        pxQueue->cTxLock = queueUNLOCKED;\r\n    }\r\n    taskEXIT_CRITICAL();\r\n\r\n    /* Do the same for the Rx lock. */\r\n    taskENTER_CRITICAL();\r\n    {\r\n        int8_t cRxLock = pxQueue->cRxLock;\r\n\r\n        while( cRxLock > queueLOCKED_UNMODIFIED )\r\n        {\r\n            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )\r\n            {\r\n                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )\r\n                {\r\n                    vTaskMissedYield();\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n\r\n                --cRxLock;\r\n            }\r\n            else\r\n            {\r\n                break;\r\n            }\r\n        }\r\n\r\n        pxQueue->cRxLock = queueUNLOCKED;\r\n    }\r\n    taskEXIT_CRITICAL();\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nstatic BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )\r\n{\r\n    BaseType_t xReturn;\r\n\r\n    taskENTER_CRITICAL();\r\n    {\r\n        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )\r\n        {\r\n            xReturn = pdTRUE;\r\n        }\r\n        else\r\n        {\r\n            xReturn = pdFALSE;\r\n        }\r\n    }\r\n    taskEXIT_CRITICAL();\r\n\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nBaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )\r\n{\r\n    BaseType_t xReturn;\r\n    Queue_t * const pxQueue = xQueue;\r\n\r\n    configASSERT( pxQueue );\r\n\r\n    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )\r\n    {\r\n        xReturn = pdTRUE;\r\n    }\r\n    else\r\n    {\r\n        xReturn = pdFALSE;\r\n    }\r\n\r\n    return xReturn;\r\n} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */\r\n/*-----------------------------------------------------------*/\r\n\r\nstatic BaseType_t prvIsQueueFull( const Queue_t * pxQueue )\r\n{\r\n    BaseType_t xReturn;\r\n\r\n    taskENTER_CRITICAL();\r\n    {\r\n        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )\r\n        {\r\n            xReturn = pdTRUE;\r\n        }\r\n        else\r\n        {\r\n            xReturn = pdFALSE;\r\n        }\r\n    }\r\n    taskEXIT_CRITICAL();\r\n\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nBaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )\r\n{\r\n    BaseType_t xReturn;\r\n    Queue_t * const pxQueue = xQueue;\r\n\r\n    configASSERT( pxQueue );\r\n\r\n    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )\r\n    {\r\n        xReturn = pdTRUE;\r\n    }\r\n    else\r\n    {\r\n        xReturn = pdFALSE;\r\n    }\r\n\r\n    return xReturn;\r\n} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_CO_ROUTINES == 1 )\r\n\r\n    BaseType_t xQueueCRSend( QueueHandle_t xQueue,\r\n                             const void * pvItemToQueue,\r\n                             TickType_t xTicksToWait )\r\n    {\r\n        BaseType_t xReturn;\r\n        Queue_t * const pxQueue = xQueue;\r\n\r\n        /* If the queue is already full we may have to block.  A critical section\r\n         * is required to prevent an interrupt removing something from the queue\r\n         * between the check to see if the queue is full and blocking on the queue. */\r\n        portDISABLE_INTERRUPTS();\r\n        {\r\n            if( prvIsQueueFull( pxQueue ) != pdFALSE )\r\n            {\r\n                /* The queue is full - do we want to block or just leave without\r\n                 * posting? */\r\n                if( xTicksToWait > ( TickType_t ) 0 )\r\n                {\r\n                    /* As this is called from a coroutine we cannot block directly, but\r\n                     * return indicating that we need to block. */\r\n                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );\r\n                    portENABLE_INTERRUPTS();\r\n                    return errQUEUE_BLOCKED;\r\n                }\r\n                else\r\n                {\r\n                    portENABLE_INTERRUPTS();\r\n                    return errQUEUE_FULL;\r\n                }\r\n            }\r\n        }\r\n        portENABLE_INTERRUPTS();\r\n\r\n        portDISABLE_INTERRUPTS();\r\n        {\r\n            if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )\r\n            {\r\n                /* There is room in the queue, copy the data into the queue. */\r\n                prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );\r\n                xReturn = pdPASS;\r\n\r\n                /* Were any co-routines waiting for data to become available? */\r\n                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )\r\n                {\r\n                    /* In this instance the co-routine could be placed directly\r\n                     * into the ready list as we are within a critical section.\r\n                     * Instead the same pending ready list mechanism is used as if\r\n                     * the event were caused from within an interrupt. */\r\n                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )\r\n                    {\r\n                        /* The co-routine waiting has a higher priority so record\r\n                         * that a yield might be appropriate. */\r\n                        xReturn = errQUEUE_YIELD;\r\n                    }\r\n                    else\r\n                    {\r\n                        mtCOVERAGE_TEST_MARKER();\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                xReturn = errQUEUE_FULL;\r\n            }\r\n        }\r\n        portENABLE_INTERRUPTS();\r\n\r\n        return xReturn;\r\n    }\r\n\r\n#endif /* configUSE_CO_ROUTINES */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_CO_ROUTINES == 1 )\r\n\r\n    BaseType_t xQueueCRReceive( QueueHandle_t xQueue,\r\n                                void * pvBuffer,\r\n                                TickType_t xTicksToWait )\r\n    {\r\n        BaseType_t xReturn;\r\n        Queue_t * const pxQueue = xQueue;\r\n\r\n        /* If the queue is already empty we may have to block.  A critical section\r\n         * is required to prevent an interrupt adding something to the queue\r\n         * between the check to see if the queue is empty and blocking on the queue. */\r\n        portDISABLE_INTERRUPTS();\r\n        {\r\n            if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )\r\n            {\r\n                /* There are no messages in the queue, do we want to block or just\r\n                 * leave with nothing? */\r\n                if( xTicksToWait > ( TickType_t ) 0 )\r\n                {\r\n                    /* As this is a co-routine we cannot block directly, but return\r\n                     * indicating that we need to block. */\r\n                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );\r\n                    portENABLE_INTERRUPTS();\r\n                    return errQUEUE_BLOCKED;\r\n                }\r\n                else\r\n                {\r\n                    portENABLE_INTERRUPTS();\r\n                    return errQUEUE_FULL;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n        portENABLE_INTERRUPTS();\r\n\r\n        portDISABLE_INTERRUPTS();\r\n        {\r\n            if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )\r\n            {\r\n                /* Data is available from the queue. */\r\n                pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;\r\n\r\n                if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )\r\n                {\r\n                    pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n\r\n                --( pxQueue->uxMessagesWaiting );\r\n                ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );\r\n\r\n                xReturn = pdPASS;\r\n\r\n                /* Were any co-routines waiting for space to become available? */\r\n                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )\r\n                {\r\n                    /* In this instance the co-routine could be placed directly\r\n                     * into the ready list as we are within a critical section.\r\n                     * Instead the same pending ready list mechanism is used as if\r\n                     * the event were caused from within an interrupt. */\r\n                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )\r\n                    {\r\n                        xReturn = errQUEUE_YIELD;\r\n                    }\r\n                    else\r\n                    {\r\n                        mtCOVERAGE_TEST_MARKER();\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                xReturn = pdFAIL;\r\n            }\r\n        }\r\n        portENABLE_INTERRUPTS();\r\n\r\n        return xReturn;\r\n    }\r\n\r\n#endif /* configUSE_CO_ROUTINES */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_CO_ROUTINES == 1 )\r\n\r\n    BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue,\r\n                                    const void * pvItemToQueue,\r\n                                    BaseType_t xCoRoutinePreviouslyWoken )\r\n    {\r\n        Queue_t * const pxQueue = xQueue;\r\n\r\n        /* Cannot block within an ISR so if there is no space on the queue then\r\n         * exit without doing anything. */\r\n        if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )\r\n        {\r\n            prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );\r\n\r\n            /* We only want to wake one co-routine per ISR, so check that a\r\n             * co-routine has not already been woken. */\r\n            if( xCoRoutinePreviouslyWoken == pdFALSE )\r\n            {\r\n                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )\r\n                {\r\n                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )\r\n                    {\r\n                        return pdTRUE;\r\n                    }\r\n                    else\r\n                    {\r\n                        mtCOVERAGE_TEST_MARKER();\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n\r\n        return xCoRoutinePreviouslyWoken;\r\n    }\r\n\r\n#endif /* configUSE_CO_ROUTINES */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_CO_ROUTINES == 1 )\r\n\r\n    BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue,\r\n                                       void * pvBuffer,\r\n                                       BaseType_t * pxCoRoutineWoken )\r\n    {\r\n        BaseType_t xReturn;\r\n        Queue_t * const pxQueue = xQueue;\r\n\r\n        /* We cannot block from an ISR, so check there is data available. If\r\n         * not then just leave without doing anything. */\r\n        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )\r\n        {\r\n            /* Copy the data from the queue. */\r\n            pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;\r\n\r\n            if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )\r\n            {\r\n                pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n\r\n            --( pxQueue->uxMessagesWaiting );\r\n            ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );\r\n\r\n            if( ( *pxCoRoutineWoken ) == pdFALSE )\r\n            {\r\n                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )\r\n                {\r\n                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )\r\n                    {\r\n                        *pxCoRoutineWoken = pdTRUE;\r\n                    }\r\n                    else\r\n                    {\r\n                        mtCOVERAGE_TEST_MARKER();\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n\r\n            xReturn = pdPASS;\r\n        }\r\n        else\r\n        {\r\n            xReturn = pdFAIL;\r\n        }\r\n\r\n        return xReturn;\r\n    }\r\n\r\n#endif /* configUSE_CO_ROUTINES */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configQUEUE_REGISTRY_SIZE > 0 )\r\n\r\n    void vQueueAddToRegistry( QueueHandle_t xQueue,\r\n                              const char * pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\r\n    {\r\n        UBaseType_t ux;\r\n\r\n        /* See if there is an empty space in the registry.  A NULL name denotes\r\n         * a free slot. */\r\n        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )\r\n        {\r\n            if( xQueueRegistry[ ux ].pcQueueName == NULL )\r\n            {\r\n                /* Store the information on this queue. */\r\n                xQueueRegistry[ ux ].pcQueueName = pcQueueName;\r\n                xQueueRegistry[ ux ].xHandle = xQueue;\r\n\r\n                traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );\r\n                break;\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n    }\r\n\r\n#endif /* configQUEUE_REGISTRY_SIZE */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configQUEUE_REGISTRY_SIZE > 0 )\r\n\r\n    const char * pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\r\n    {\r\n        UBaseType_t ux;\r\n        const char * pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\r\n\r\n        /* Note there is nothing here to protect against another task adding or\r\n         * removing entries from the registry while it is being searched. */\r\n\r\n        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )\r\n        {\r\n            if( xQueueRegistry[ ux ].xHandle == xQueue )\r\n            {\r\n                pcReturn = xQueueRegistry[ ux ].pcQueueName;\r\n                break;\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n\r\n        return pcReturn;\r\n    } /*lint !e818 xQueue cannot be a pointer to const because it is a typedef. */\r\n\r\n#endif /* configQUEUE_REGISTRY_SIZE */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configQUEUE_REGISTRY_SIZE > 0 )\r\n\r\n    void vQueueUnregisterQueue( QueueHandle_t xQueue )\r\n    {\r\n        UBaseType_t ux;\r\n\r\n        /* See if the handle of the queue being unregistered in actually in the\r\n         * registry. */\r\n        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )\r\n        {\r\n            if( xQueueRegistry[ ux ].xHandle == xQueue )\r\n            {\r\n                /* Set the name to NULL to show that this slot if free again. */\r\n                xQueueRegistry[ ux ].pcQueueName = NULL;\r\n\r\n                /* Set the handle to NULL to ensure the same queue handle cannot\r\n                 * appear in the registry twice if it is added, removed, then\r\n                 * added again. */\r\n                xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;\r\n                break;\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n    } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */\r\n\r\n#endif /* configQUEUE_REGISTRY_SIZE */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_TIMERS == 1 )\r\n\r\n    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,\r\n                                         TickType_t xTicksToWait,\r\n                                         const BaseType_t xWaitIndefinitely )\r\n    {\r\n        Queue_t * const pxQueue = xQueue;\r\n\r\n        /* This function should not be called by application code hence the\r\n         * 'Restricted' in its name.  It is not part of the public API.  It is\r\n         * designed for use by kernel code, and has special calling requirements.\r\n         * It can result in vListInsert() being called on a list that can only\r\n         * possibly ever have one item in it, so the list will be fast, but even\r\n         * so it should be called with the scheduler locked and not from a critical\r\n         * section. */\r\n\r\n        /* Only do anything if there are no messages in the queue.  This function\r\n         *  will not actually cause the task to block, just place it on a blocked\r\n         *  list.  It will not block until the scheduler is unlocked - at which\r\n         *  time a yield will be performed.  If an item is added to the queue while\r\n         *  the queue is locked, and the calling task blocks on the queue, then the\r\n         *  calling task will be immediately unblocked when the queue is unlocked. */\r\n        prvLockQueue( pxQueue );\r\n\r\n        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )\r\n        {\r\n            /* There is nothing in the queue, block for the specified period. */\r\n            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n\r\n        prvUnlockQueue( pxQueue );\r\n    }\r\n\r\n#endif /* configUSE_TIMERS */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( ( configUSE_QUEUE_SETS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )\r\n\r\n    QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength )\r\n    {\r\n        QueueSetHandle_t pxQueue;\r\n\r\n        pxQueue = xQueueGenericCreate( uxEventQueueLength, ( UBaseType_t ) sizeof( Queue_t * ), queueQUEUE_TYPE_SET );\r\n\r\n        return pxQueue;\r\n    }\r\n\r\n#endif /* configUSE_QUEUE_SETS */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_QUEUE_SETS == 1 )\r\n\r\n    BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore,\r\n                               QueueSetHandle_t xQueueSet )\r\n    {\r\n        BaseType_t xReturn;\r\n\r\n        taskENTER_CRITICAL();\r\n        {\r\n            if( ( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer != NULL )\r\n            {\r\n                /* Cannot add a queue/semaphore to more than one queue set. */\r\n                xReturn = pdFAIL;\r\n            }\r\n            else if( ( ( Queue_t * ) xQueueOrSemaphore )->uxMessagesWaiting != ( UBaseType_t ) 0 )\r\n            {\r\n                /* Cannot add a queue/semaphore to a queue set if there are already\r\n                 * items in the queue/semaphore. */\r\n                xReturn = pdFAIL;\r\n            }\r\n            else\r\n            {\r\n                ( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer = xQueueSet;\r\n                xReturn = pdPASS;\r\n            }\r\n        }\r\n        taskEXIT_CRITICAL();\r\n\r\n        return xReturn;\r\n    }\r\n\r\n#endif /* configUSE_QUEUE_SETS */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_QUEUE_SETS == 1 )\r\n\r\n    BaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore,\r\n                                    QueueSetHandle_t xQueueSet )\r\n    {\r\n        BaseType_t xReturn;\r\n        Queue_t * const pxQueueOrSemaphore = ( Queue_t * ) xQueueOrSemaphore;\r\n\r\n        if( pxQueueOrSemaphore->pxQueueSetContainer != xQueueSet )\r\n        {\r\n            /* The queue was not a member of the set. */\r\n            xReturn = pdFAIL;\r\n        }\r\n        else if( pxQueueOrSemaphore->uxMessagesWaiting != ( UBaseType_t ) 0 )\r\n        {\r\n            /* It is dangerous to remove a queue from a set when the queue is\r\n             * not empty because the queue set will still hold pending events for\r\n             * the queue. */\r\n            xReturn = pdFAIL;\r\n        }\r\n        else\r\n        {\r\n            taskENTER_CRITICAL();\r\n            {\r\n                /* The queue is no longer contained in the set. */\r\n                pxQueueOrSemaphore->pxQueueSetContainer = NULL;\r\n            }\r\n            taskEXIT_CRITICAL();\r\n            xReturn = pdPASS;\r\n        }\r\n\r\n        return xReturn;\r\n    } /*lint !e818 xQueueSet could not be declared as pointing to const as it is a typedef. */\r\n\r\n#endif /* configUSE_QUEUE_SETS */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_QUEUE_SETS == 1 )\r\n\r\n    QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet,\r\n                                                TickType_t const xTicksToWait )\r\n    {\r\n        QueueSetMemberHandle_t xReturn = NULL;\r\n\r\n        ( void ) xQueueReceive( ( QueueHandle_t ) xQueueSet, &xReturn, xTicksToWait ); /*lint !e961 Casting from one typedef to another is not redundant. */\r\n        return xReturn;\r\n    }\r\n\r\n#endif /* configUSE_QUEUE_SETS */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_QUEUE_SETS == 1 )\r\n\r\n    QueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet )\r\n    {\r\n        QueueSetMemberHandle_t xReturn = NULL;\r\n\r\n        ( void ) xQueueReceiveFromISR( ( QueueHandle_t ) xQueueSet, &xReturn, NULL ); /*lint !e961 Casting from one typedef to another is not redundant. */\r\n        return xReturn;\r\n    }\r\n\r\n#endif /* configUSE_QUEUE_SETS */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_QUEUE_SETS == 1 )\r\n\r\n    static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue )\r\n    {\r\n        Queue_t * pxQueueSetContainer = pxQueue->pxQueueSetContainer;\r\n        BaseType_t xReturn = pdFALSE;\r\n\r\n        /* This function must be called form a critical section. */\r\n\r\n        configASSERT( pxQueueSetContainer );\r\n        configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );\r\n\r\n        if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )\r\n        {\r\n            const int8_t cTxLock = pxQueueSetContainer->cTxLock;\r\n\r\n            traceQUEUE_SET_SEND( pxQueueSetContainer );\r\n\r\n            /* The data copied is the handle of the queue that contains data. */\r\n            xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, queueSEND_TO_BACK );\r\n\r\n            if( cTxLock == queueUNLOCKED )\r\n            {\r\n                if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )\r\n                {\r\n                    if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )\r\n                    {\r\n                        /* The task waiting has a higher priority. */\r\n                        xReturn = pdTRUE;\r\n                    }\r\n                    else\r\n                    {\r\n                        mtCOVERAGE_TEST_MARKER();\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                configASSERT( cTxLock != queueINT8_MAX );\r\n\r\n                pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );\r\n            }\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n\r\n        return xReturn;\r\n    }\r\n\r\n#endif /* configUSE_QUEUE_SETS */\r\n"], "fixing_code": ["/*\r\n * FreeRTOS Kernel V10.4.2\r\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n * this software and associated documentation files (the \"Software\"), to deal in\r\n * the Software without restriction, including without limitation the rights to\r\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\r\n * the Software, and to permit persons to whom the Software is furnished to do so,\r\n * subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\r\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\r\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n * https://www.FreeRTOS.org\r\n * https://github.com/FreeRTOS\r\n *\r\n */\r\n\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining\r\n * all the API functions to use the MPU wrappers.  That should only be done when\r\n * task.h is included from an application file. */\r\n#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE\r\n\r\n#include \"FreeRTOS.h\"\r\n#include \"task.h\"\r\n#include \"queue.h\"\r\n\r\n#if ( configUSE_CO_ROUTINES == 1 )\r\n    #include \"croutine.h\"\r\n#endif\r\n\r\n/* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified\r\n * because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined\r\n * for the header files above, but not in this file, in order to generate the\r\n * correct privileged Vs unprivileged linkage and placement. */\r\n#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */\r\n\r\n\r\n/* Constants used with the cRxLock and cTxLock structure members. */\r\n#define queueUNLOCKED             ( ( int8_t ) -1 )\r\n#define queueLOCKED_UNMODIFIED    ( ( int8_t ) 0 )\r\n#define queueINT8_MAX             ( ( int8_t ) 127 )\r\n\r\n/* When the Queue_t structure is used to represent a base queue its pcHead and\r\n * pcTail members are used as pointers into the queue storage area.  When the\r\n * Queue_t structure is used to represent a mutex pcHead and pcTail pointers are\r\n * not necessary, and the pcHead pointer is set to NULL to indicate that the\r\n * structure instead holds a pointer to the mutex holder (if any).  Map alternative\r\n * names to the pcHead and structure member to ensure the readability of the code\r\n * is maintained.  The QueuePointers_t and SemaphoreData_t types are used to form\r\n * a union as their usage is mutually exclusive dependent on what the queue is\r\n * being used for. */\r\n#define uxQueueType               pcHead\r\n#define queueQUEUE_IS_MUTEX       NULL\r\n\r\ntypedef struct QueuePointers\r\n{\r\n    int8_t * pcTail;     /*< Points to the byte at the end of the queue storage area.  Once more byte is allocated than necessary to store the queue items, this is used as a marker. */\r\n    int8_t * pcReadFrom; /*< Points to the last place that a queued item was read from when the structure is used as a queue. */\r\n} QueuePointers_t;\r\n\r\ntypedef struct SemaphoreData\r\n{\r\n    TaskHandle_t xMutexHolder;        /*< The handle of the task that holds the mutex. */\r\n    UBaseType_t uxRecursiveCallCount; /*< Maintains a count of the number of times a recursive mutex has been recursively 'taken' when the structure is used as a mutex. */\r\n} SemaphoreData_t;\r\n\r\n/* Semaphores do not actually store or copy data, so have an item size of\r\n * zero. */\r\n#define queueSEMAPHORE_QUEUE_ITEM_LENGTH    ( ( UBaseType_t ) 0 )\r\n#define queueMUTEX_GIVE_BLOCK_TIME          ( ( TickType_t ) 0U )\r\n\r\n#if ( configUSE_PREEMPTION == 0 )\r\n\r\n/* If the cooperative scheduler is being used then a yield should not be\r\n * performed just because a higher priority task has been woken. */\r\n    #define queueYIELD_IF_USING_PREEMPTION()\r\n#else\r\n    #define queueYIELD_IF_USING_PREEMPTION()    portYIELD_WITHIN_API()\r\n#endif\r\n\r\n/*\r\n * Definition of the queue used by the scheduler.\r\n * Items are queued by copy, not reference.  See the following link for the\r\n * rationale: https://www.FreeRTOS.org/Embedded-RTOS-Queues.html\r\n */\r\ntypedef struct QueueDefinition /* The old naming convention is used to prevent breaking kernel aware debuggers. */\r\n{\r\n    int8_t * pcHead;           /*< Points to the beginning of the queue storage area. */\r\n    int8_t * pcWriteTo;        /*< Points to the free next place in the storage area. */\r\n\r\n    union\r\n    {\r\n        QueuePointers_t xQueue;     /*< Data required exclusively when this structure is used as a queue. */\r\n        SemaphoreData_t xSemaphore; /*< Data required exclusively when this structure is used as a semaphore. */\r\n    } u;\r\n\r\n    List_t xTasksWaitingToSend;             /*< List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. */\r\n    List_t xTasksWaitingToReceive;          /*< List of tasks that are blocked waiting to read from this queue.  Stored in priority order. */\r\n\r\n    volatile UBaseType_t uxMessagesWaiting; /*< The number of items currently in the queue. */\r\n    UBaseType_t uxLength;                   /*< The length of the queue defined as the number of items it will hold, not the number of bytes. */\r\n    UBaseType_t uxItemSize;                 /*< The size of each items that the queue will hold. */\r\n\r\n    volatile int8_t cRxLock;                /*< Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */\r\n    volatile int8_t cTxLock;                /*< Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */\r\n\r\n    #if ( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )\r\n        uint8_t ucStaticallyAllocated; /*< Set to pdTRUE if the memory used by the queue was statically allocated to ensure no attempt is made to free the memory. */\r\n    #endif\r\n\r\n    #if ( configUSE_QUEUE_SETS == 1 )\r\n        struct QueueDefinition * pxQueueSetContainer;\r\n    #endif\r\n\r\n    #if ( configUSE_TRACE_FACILITY == 1 )\r\n        UBaseType_t uxQueueNumber;\r\n        uint8_t ucQueueType;\r\n    #endif\r\n} xQUEUE;\r\n\r\n/* The old xQUEUE name is maintained above then typedefed to the new Queue_t\r\n * name below to enable the use of older kernel aware debuggers. */\r\ntypedef xQUEUE Queue_t;\r\n\r\n/*-----------------------------------------------------------*/\r\n\r\n/*\r\n * The queue registry is just a means for kernel aware debuggers to locate\r\n * queue structures.  It has no other purpose so is an optional component.\r\n */\r\n#if ( configQUEUE_REGISTRY_SIZE > 0 )\r\n\r\n/* The type stored within the queue registry array.  This allows a name\r\n * to be assigned to each queue making kernel aware debugging a little\r\n * more user friendly. */\r\n    typedef struct QUEUE_REGISTRY_ITEM\r\n    {\r\n        const char * pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\r\n        QueueHandle_t xHandle;\r\n    } xQueueRegistryItem;\r\n\r\n/* The old xQueueRegistryItem name is maintained above then typedefed to the\r\n * new xQueueRegistryItem name below to enable the use of older kernel aware\r\n * debuggers. */\r\n    typedef xQueueRegistryItem QueueRegistryItem_t;\r\n\r\n/* The queue registry is simply an array of QueueRegistryItem_t structures.\r\n * The pcQueueName member of a structure being NULL is indicative of the\r\n * array position being vacant. */\r\n    PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];\r\n\r\n#endif /* configQUEUE_REGISTRY_SIZE */\r\n\r\n/*\r\n * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not\r\n * prevent an ISR from adding or removing items to the queue, but does prevent\r\n * an ISR from removing tasks from the queue event lists.  If an ISR finds a\r\n * queue is locked it will instead increment the appropriate queue lock count\r\n * to indicate that a task may require unblocking.  When the queue in unlocked\r\n * these lock counts are inspected, and the appropriate action taken.\r\n */\r\nstatic void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;\r\n\r\n/*\r\n * Uses a critical section to determine if there is any data in a queue.\r\n *\r\n * @return pdTRUE if the queue contains no items, otherwise pdFALSE.\r\n */\r\nstatic BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue ) PRIVILEGED_FUNCTION;\r\n\r\n/*\r\n * Uses a critical section to determine if there is any space in a queue.\r\n *\r\n * @return pdTRUE if there is no space, otherwise pdFALSE;\r\n */\r\nstatic BaseType_t prvIsQueueFull( const Queue_t * pxQueue ) PRIVILEGED_FUNCTION;\r\n\r\n/*\r\n * Copies an item into the queue, either at the front of the queue or the\r\n * back of the queue.\r\n */\r\nstatic BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,\r\n                                      const void * pvItemToQueue,\r\n                                      const BaseType_t xPosition ) PRIVILEGED_FUNCTION;\r\n\r\n/*\r\n * Copies an item out of a queue.\r\n */\r\nstatic void prvCopyDataFromQueue( Queue_t * const pxQueue,\r\n                                  void * const pvBuffer ) PRIVILEGED_FUNCTION;\r\n\r\n#if ( configUSE_QUEUE_SETS == 1 )\r\n\r\n/*\r\n * Checks to see if a queue is a member of a queue set, and if so, notifies\r\n * the queue set that the queue contains data.\r\n */\r\n    static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;\r\n#endif\r\n\r\n/*\r\n * Called after a Queue_t structure has been allocated either statically or\r\n * dynamically to fill in the structure's members.\r\n */\r\nstatic void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,\r\n                                   const UBaseType_t uxItemSize,\r\n                                   uint8_t * pucQueueStorage,\r\n                                   const uint8_t ucQueueType,\r\n                                   Queue_t * pxNewQueue ) PRIVILEGED_FUNCTION;\r\n\r\n/*\r\n * Mutexes are a special type of queue.  When a mutex is created, first the\r\n * queue is created, then prvInitialiseMutex() is called to configure the queue\r\n * as a mutex.\r\n */\r\n#if ( configUSE_MUTEXES == 1 )\r\n    static void prvInitialiseMutex( Queue_t * pxNewQueue ) PRIVILEGED_FUNCTION;\r\n#endif\r\n\r\n#if ( configUSE_MUTEXES == 1 )\r\n\r\n/*\r\n * If a task waiting for a mutex causes the mutex holder to inherit a\r\n * priority, but the waiting task times out, then the holder should\r\n * disinherit the priority - but only down to the highest priority of any\r\n * other tasks that are waiting for the same mutex.  This function returns\r\n * that priority.\r\n */\r\n    static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;\r\n#endif\r\n/*-----------------------------------------------------------*/\r\n\r\n/*\r\n * Macro to mark a queue as locked.  Locking a queue prevents an ISR from\r\n * accessing the queue event lists.\r\n */\r\n#define prvLockQueue( pxQueue )                            \\\r\n    taskENTER_CRITICAL();                                  \\\r\n    {                                                      \\\r\n        if( ( pxQueue )->cRxLock == queueUNLOCKED )        \\\r\n        {                                                  \\\r\n            ( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED; \\\r\n        }                                                  \\\r\n        if( ( pxQueue )->cTxLock == queueUNLOCKED )        \\\r\n        {                                                  \\\r\n            ( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED; \\\r\n        }                                                  \\\r\n    }                                                      \\\r\n    taskEXIT_CRITICAL()\r\n/*-----------------------------------------------------------*/\r\n\r\nBaseType_t xQueueGenericReset( QueueHandle_t xQueue,\r\n                               BaseType_t xNewQueue )\r\n{\r\n    Queue_t * const pxQueue = xQueue;\r\n\r\n    configASSERT( pxQueue );\r\n\r\n    taskENTER_CRITICAL();\r\n    {\r\n        pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */\r\n        pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;\r\n        pxQueue->pcWriteTo = pxQueue->pcHead;\r\n        pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */\r\n        pxQueue->cRxLock = queueUNLOCKED;\r\n        pxQueue->cTxLock = queueUNLOCKED;\r\n\r\n        if( xNewQueue == pdFALSE )\r\n        {\r\n            /* If there are tasks blocked waiting to read from the queue, then\r\n             * the tasks will remain blocked as after this function exits the queue\r\n             * will still be empty.  If there are tasks blocked waiting to write to\r\n             * the queue, then one should be unblocked as after this function exits\r\n             * it will be possible to write to it. */\r\n            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )\r\n            {\r\n                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )\r\n                {\r\n                    queueYIELD_IF_USING_PREEMPTION();\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n        else\r\n        {\r\n            /* Ensure the event queues start in the correct state. */\r\n            vListInitialise( &( pxQueue->xTasksWaitingToSend ) );\r\n            vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );\r\n        }\r\n    }\r\n    taskEXIT_CRITICAL();\r\n\r\n    /* A value is returned for calling semantic consistency with previous\r\n     * versions. */\r\n    return pdPASS;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configSUPPORT_STATIC_ALLOCATION == 1 )\r\n\r\n    QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength,\r\n                                             const UBaseType_t uxItemSize,\r\n                                             uint8_t * pucQueueStorage,\r\n                                             StaticQueue_t * pxStaticQueue,\r\n                                             const uint8_t ucQueueType )\r\n    {\r\n        Queue_t * pxNewQueue;\r\n\r\n        configASSERT( uxQueueLength > ( UBaseType_t ) 0 );\r\n\r\n        /* The StaticQueue_t structure and the queue storage area must be\r\n         * supplied. */\r\n        configASSERT( pxStaticQueue != NULL );\r\n\r\n        /* A queue storage area should be provided if the item size is not 0, and\r\n         * should not be provided if the item size is 0. */\r\n        configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );\r\n        configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );\r\n\r\n        #if ( configASSERT_DEFINED == 1 )\r\n            {\r\n                /* Sanity check that the size of the structure used to declare a\r\n                 * variable of type StaticQueue_t or StaticSemaphore_t equals the size of\r\n                 * the real queue and semaphore structures. */\r\n                volatile size_t xSize = sizeof( StaticQueue_t );\r\n                configASSERT( xSize == sizeof( Queue_t ) );\r\n                ( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */\r\n            }\r\n        #endif /* configASSERT_DEFINED */\r\n\r\n        /* The address of a statically allocated queue was passed in, use it.\r\n         * The address of a statically allocated storage area was also passed in\r\n         * but is already set. */\r\n        pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */\r\n\r\n        if( pxNewQueue != NULL )\r\n        {\r\n            #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\r\n                {\r\n                    /* Queues can be allocated wither statically or dynamically, so\r\n                     * note this queue was allocated statically in case the queue is\r\n                     * later deleted. */\r\n                    pxNewQueue->ucStaticallyAllocated = pdTRUE;\r\n                }\r\n            #endif /* configSUPPORT_DYNAMIC_ALLOCATION */\r\n\r\n            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );\r\n        }\r\n        else\r\n        {\r\n            traceQUEUE_CREATE_FAILED( ucQueueType );\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n\r\n        return pxNewQueue;\r\n    }\r\n\r\n#endif /* configSUPPORT_STATIC_ALLOCATION */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\r\n\r\n    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,\r\n                                       const UBaseType_t uxItemSize,\r\n                                       const uint8_t ucQueueType )\r\n    {\r\n        Queue_t * pxNewQueue;\r\n        size_t xQueueSizeInBytes;\r\n        uint8_t * pucQueueStorage;\r\n\r\n        configASSERT( uxQueueLength > ( UBaseType_t ) 0 );\r\n\r\n        /* Allocate enough space to hold the maximum number of items that\r\n         * can be in the queue at any time.  It is valid for uxItemSize to be\r\n         * zero in the case the queue is used as a semaphore. */\r\n        xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */\r\n\r\n        /* Check for multiplication overflow. */\r\n        configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );\r\n\r\n        /* Check for addition overflow. */\r\n        configASSERT( ( sizeof( Queue_t ) + xQueueSizeInBytes ) >  xQueueSizeInBytes );\r\n\r\n        /* Allocate the queue and storage area.  Justification for MISRA\r\n         * deviation as follows:  pvPortMalloc() always ensures returned memory\r\n         * blocks are aligned per the requirements of the MCU stack.  In this case\r\n         * pvPortMalloc() must return a pointer that is guaranteed to meet the\r\n         * alignment requirements of the Queue_t structure - which in this case\r\n         * is an int8_t *.  Therefore, whenever the stack alignment requirements\r\n         * are greater than or equal to the pointer to char requirements the cast\r\n         * is safe.  In other cases alignment requirements are not strict (one or\r\n         * two bytes). */\r\n        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */\r\n\r\n        if( pxNewQueue != NULL )\r\n        {\r\n            /* Jump past the queue structure to find the location of the queue\r\n             * storage area. */\r\n            pucQueueStorage = ( uint8_t * ) pxNewQueue;\r\n            pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */\r\n\r\n            #if ( configSUPPORT_STATIC_ALLOCATION == 1 )\r\n                {\r\n                    /* Queues can be created either statically or dynamically, so\r\n                     * note this task was created dynamically in case it is later\r\n                     * deleted. */\r\n                    pxNewQueue->ucStaticallyAllocated = pdFALSE;\r\n                }\r\n            #endif /* configSUPPORT_STATIC_ALLOCATION */\r\n\r\n            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );\r\n        }\r\n        else\r\n        {\r\n            traceQUEUE_CREATE_FAILED( ucQueueType );\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n\r\n        return pxNewQueue;\r\n    }\r\n\r\n#endif /* configSUPPORT_STATIC_ALLOCATION */\r\n/*-----------------------------------------------------------*/\r\n\r\nstatic void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,\r\n                                   const UBaseType_t uxItemSize,\r\n                                   uint8_t * pucQueueStorage,\r\n                                   const uint8_t ucQueueType,\r\n                                   Queue_t * pxNewQueue )\r\n{\r\n    /* Remove compiler warnings about unused parameters should\r\n     * configUSE_TRACE_FACILITY not be set to 1. */\r\n    ( void ) ucQueueType;\r\n\r\n    if( uxItemSize == ( UBaseType_t ) 0 )\r\n    {\r\n        /* No RAM was allocated for the queue storage area, but PC head cannot\r\n         * be set to NULL because NULL is used as a key to say the queue is used as\r\n         * a mutex.  Therefore just set pcHead to point to the queue as a benign\r\n         * value that is known to be within the memory map. */\r\n        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;\r\n    }\r\n    else\r\n    {\r\n        /* Set the head to the start of the queue storage area. */\r\n        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;\r\n    }\r\n\r\n    /* Initialise the queue members as described where the queue type is\r\n     * defined. */\r\n    pxNewQueue->uxLength = uxQueueLength;\r\n    pxNewQueue->uxItemSize = uxItemSize;\r\n    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );\r\n\r\n    #if ( configUSE_TRACE_FACILITY == 1 )\r\n        {\r\n            pxNewQueue->ucQueueType = ucQueueType;\r\n        }\r\n    #endif /* configUSE_TRACE_FACILITY */\r\n\r\n    #if ( configUSE_QUEUE_SETS == 1 )\r\n        {\r\n            pxNewQueue->pxQueueSetContainer = NULL;\r\n        }\r\n    #endif /* configUSE_QUEUE_SETS */\r\n\r\n    traceQUEUE_CREATE( pxNewQueue );\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_MUTEXES == 1 )\r\n\r\n    static void prvInitialiseMutex( Queue_t * pxNewQueue )\r\n    {\r\n        if( pxNewQueue != NULL )\r\n        {\r\n            /* The queue create function will set all the queue structure members\r\n            * correctly for a generic queue, but this function is creating a\r\n            * mutex.  Overwrite those members that need to be set differently -\r\n            * in particular the information required for priority inheritance. */\r\n            pxNewQueue->u.xSemaphore.xMutexHolder = NULL;\r\n            pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;\r\n\r\n            /* In case this is a recursive mutex. */\r\n            pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;\r\n\r\n            traceCREATE_MUTEX( pxNewQueue );\r\n\r\n            /* Start with the semaphore in the expected state. */\r\n            ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );\r\n        }\r\n        else\r\n        {\r\n            traceCREATE_MUTEX_FAILED();\r\n        }\r\n    }\r\n\r\n#endif /* configUSE_MUTEXES */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )\r\n\r\n    QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )\r\n    {\r\n        QueueHandle_t xNewQueue;\r\n        const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;\r\n\r\n        xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );\r\n        prvInitialiseMutex( ( Queue_t * ) xNewQueue );\r\n\r\n        return xNewQueue;\r\n    }\r\n\r\n#endif /* configUSE_MUTEXES */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )\r\n\r\n    QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType,\r\n                                           StaticQueue_t * pxStaticQueue )\r\n    {\r\n        QueueHandle_t xNewQueue;\r\n        const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;\r\n\r\n        /* Prevent compiler warnings about unused parameters if\r\n         * configUSE_TRACE_FACILITY does not equal 1. */\r\n        ( void ) ucQueueType;\r\n\r\n        xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );\r\n        prvInitialiseMutex( ( Queue_t * ) xNewQueue );\r\n\r\n        return xNewQueue;\r\n    }\r\n\r\n#endif /* configUSE_MUTEXES */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )\r\n\r\n    TaskHandle_t xQueueGetMutexHolder( QueueHandle_t xSemaphore )\r\n    {\r\n        TaskHandle_t pxReturn;\r\n        Queue_t * const pxSemaphore = ( Queue_t * ) xSemaphore;\r\n\r\n        /* This function is called by xSemaphoreGetMutexHolder(), and should not\r\n         * be called directly.  Note:  This is a good way of determining if the\r\n         * calling task is the mutex holder, but not a good way of determining the\r\n         * identity of the mutex holder, as the holder may change between the\r\n         * following critical section exiting and the function returning. */\r\n        taskENTER_CRITICAL();\r\n        {\r\n            if( pxSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )\r\n            {\r\n                pxReturn = pxSemaphore->u.xSemaphore.xMutexHolder;\r\n            }\r\n            else\r\n            {\r\n                pxReturn = NULL;\r\n            }\r\n        }\r\n        taskEXIT_CRITICAL();\r\n\r\n        return pxReturn;\r\n    } /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */\r\n\r\n#endif /* if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) ) */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )\r\n\r\n    TaskHandle_t xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore )\r\n    {\r\n        TaskHandle_t pxReturn;\r\n\r\n        configASSERT( xSemaphore );\r\n\r\n        /* Mutexes cannot be used in interrupt service routines, so the mutex\r\n         * holder should not change in an ISR, and therefore a critical section is\r\n         * not required here. */\r\n        if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )\r\n        {\r\n            pxReturn = ( ( Queue_t * ) xSemaphore )->u.xSemaphore.xMutexHolder;\r\n        }\r\n        else\r\n        {\r\n            pxReturn = NULL;\r\n        }\r\n\r\n        return pxReturn;\r\n    } /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */\r\n\r\n#endif /* if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) ) */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_RECURSIVE_MUTEXES == 1 )\r\n\r\n    BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )\r\n    {\r\n        BaseType_t xReturn;\r\n        Queue_t * const pxMutex = ( Queue_t * ) xMutex;\r\n\r\n        configASSERT( pxMutex );\r\n\r\n        /* If this is the task that holds the mutex then xMutexHolder will not\r\n         * change outside of this task.  If this task does not hold the mutex then\r\n         * pxMutexHolder can never coincidentally equal the tasks handle, and as\r\n         * this is the only condition we are interested in it does not matter if\r\n         * pxMutexHolder is accessed simultaneously by another task.  Therefore no\r\n         * mutual exclusion is required to test the pxMutexHolder variable. */\r\n        if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )\r\n        {\r\n            traceGIVE_MUTEX_RECURSIVE( pxMutex );\r\n\r\n            /* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to\r\n             * the task handle, therefore no underflow check is required.  Also,\r\n             * uxRecursiveCallCount is only modified by the mutex holder, and as\r\n             * there can only be one, no mutual exclusion is required to modify the\r\n             * uxRecursiveCallCount member. */\r\n            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;\r\n\r\n            /* Has the recursive call count unwound to 0? */\r\n            if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )\r\n            {\r\n                /* Return the mutex.  This will automatically unblock any other\r\n                 * task that might be waiting to access the mutex. */\r\n                ( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n\r\n            xReturn = pdPASS;\r\n        }\r\n        else\r\n        {\r\n            /* The mutex cannot be given because the calling task is not the\r\n             * holder. */\r\n            xReturn = pdFAIL;\r\n\r\n            traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );\r\n        }\r\n\r\n        return xReturn;\r\n    }\r\n\r\n#endif /* configUSE_RECURSIVE_MUTEXES */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_RECURSIVE_MUTEXES == 1 )\r\n\r\n    BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex,\r\n                                         TickType_t xTicksToWait )\r\n    {\r\n        BaseType_t xReturn;\r\n        Queue_t * const pxMutex = ( Queue_t * ) xMutex;\r\n\r\n        configASSERT( pxMutex );\r\n\r\n        /* Comments regarding mutual exclusion as per those within\r\n         * xQueueGiveMutexRecursive(). */\r\n\r\n        traceTAKE_MUTEX_RECURSIVE( pxMutex );\r\n\r\n        if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )\r\n        {\r\n            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;\r\n            xReturn = pdPASS;\r\n        }\r\n        else\r\n        {\r\n            xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );\r\n\r\n            /* pdPASS will only be returned if the mutex was successfully\r\n             * obtained.  The calling task may have entered the Blocked state\r\n             * before reaching here. */\r\n            if( xReturn != pdFAIL )\r\n            {\r\n                ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;\r\n            }\r\n            else\r\n            {\r\n                traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );\r\n            }\r\n        }\r\n\r\n        return xReturn;\r\n    }\r\n\r\n#endif /* configUSE_RECURSIVE_MUTEXES */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )\r\n\r\n    QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount,\r\n                                                       const UBaseType_t uxInitialCount,\r\n                                                       StaticQueue_t * pxStaticQueue )\r\n    {\r\n        QueueHandle_t xHandle;\r\n\r\n        configASSERT( uxMaxCount != 0 );\r\n        configASSERT( uxInitialCount <= uxMaxCount );\r\n\r\n        xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStaticQueue, queueQUEUE_TYPE_COUNTING_SEMAPHORE );\r\n\r\n        if( xHandle != NULL )\r\n        {\r\n            ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;\r\n\r\n            traceCREATE_COUNTING_SEMAPHORE();\r\n        }\r\n        else\r\n        {\r\n            traceCREATE_COUNTING_SEMAPHORE_FAILED();\r\n        }\r\n\r\n        return xHandle;\r\n    }\r\n\r\n#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )\r\n\r\n    QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount,\r\n                                                 const UBaseType_t uxInitialCount )\r\n    {\r\n        QueueHandle_t xHandle;\r\n\r\n        configASSERT( uxMaxCount != 0 );\r\n        configASSERT( uxInitialCount <= uxMaxCount );\r\n\r\n        xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );\r\n\r\n        if( xHandle != NULL )\r\n        {\r\n            ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;\r\n\r\n            traceCREATE_COUNTING_SEMAPHORE();\r\n        }\r\n        else\r\n        {\r\n            traceCREATE_COUNTING_SEMAPHORE_FAILED();\r\n        }\r\n\r\n        return xHandle;\r\n    }\r\n\r\n#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */\r\n/*-----------------------------------------------------------*/\r\n\r\nBaseType_t xQueueGenericSend( QueueHandle_t xQueue,\r\n                              const void * const pvItemToQueue,\r\n                              TickType_t xTicksToWait,\r\n                              const BaseType_t xCopyPosition )\r\n{\r\n    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;\r\n    TimeOut_t xTimeOut;\r\n    Queue_t * const pxQueue = xQueue;\r\n\r\n    configASSERT( pxQueue );\r\n    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );\r\n    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );\r\n    #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )\r\n        {\r\n            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );\r\n        }\r\n    #endif\r\n\r\n    /*lint -save -e904 This function relaxes the coding standard somewhat to\r\n     * allow return statements within the function itself.  This is done in the\r\n     * interest of execution time efficiency. */\r\n    for( ; ; )\r\n    {\r\n        taskENTER_CRITICAL();\r\n        {\r\n            /* Is there room on the queue now?  The running task must be the\r\n             * highest priority task wanting to access the queue.  If the head item\r\n             * in the queue is to be overwritten then it does not matter if the\r\n             * queue is full. */\r\n            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )\r\n            {\r\n                traceQUEUE_SEND( pxQueue );\r\n\r\n                #if ( configUSE_QUEUE_SETS == 1 )\r\n                    {\r\n                        const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;\r\n\r\n                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );\r\n\r\n                        if( pxQueue->pxQueueSetContainer != NULL )\r\n                        {\r\n                            if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )\r\n                            {\r\n                                /* Do not notify the queue set as an existing item\r\n                                 * was overwritten in the queue so the number of items\r\n                                 * in the queue has not changed. */\r\n                                mtCOVERAGE_TEST_MARKER();\r\n                            }\r\n                            else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )\r\n                            {\r\n                                /* The queue is a member of a queue set, and posting\r\n                                 * to the queue set caused a higher priority task to\r\n                                 * unblock. A context switch is required. */\r\n                                queueYIELD_IF_USING_PREEMPTION();\r\n                            }\r\n                            else\r\n                            {\r\n                                mtCOVERAGE_TEST_MARKER();\r\n                            }\r\n                        }\r\n                        else\r\n                        {\r\n                            /* If there was a task waiting for data to arrive on the\r\n                             * queue then unblock it now. */\r\n                            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )\r\n                            {\r\n                                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )\r\n                                {\r\n                                    /* The unblocked task has a priority higher than\r\n                                     * our own so yield immediately.  Yes it is ok to\r\n                                     * do this from within the critical section - the\r\n                                     * kernel takes care of that. */\r\n                                    queueYIELD_IF_USING_PREEMPTION();\r\n                                }\r\n                                else\r\n                                {\r\n                                    mtCOVERAGE_TEST_MARKER();\r\n                                }\r\n                            }\r\n                            else if( xYieldRequired != pdFALSE )\r\n                            {\r\n                                /* This path is a special case that will only get\r\n                                 * executed if the task was holding multiple mutexes\r\n                                 * and the mutexes were given back in an order that is\r\n                                 * different to that in which they were taken. */\r\n                                queueYIELD_IF_USING_PREEMPTION();\r\n                            }\r\n                            else\r\n                            {\r\n                                mtCOVERAGE_TEST_MARKER();\r\n                            }\r\n                        }\r\n                    }\r\n                #else /* configUSE_QUEUE_SETS */\r\n                    {\r\n                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );\r\n\r\n                        /* If there was a task waiting for data to arrive on the\r\n                         * queue then unblock it now. */\r\n                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )\r\n                        {\r\n                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )\r\n                            {\r\n                                /* The unblocked task has a priority higher than\r\n                                 * our own so yield immediately.  Yes it is ok to do\r\n                                 * this from within the critical section - the kernel\r\n                                 * takes care of that. */\r\n                                queueYIELD_IF_USING_PREEMPTION();\r\n                            }\r\n                            else\r\n                            {\r\n                                mtCOVERAGE_TEST_MARKER();\r\n                            }\r\n                        }\r\n                        else if( xYieldRequired != pdFALSE )\r\n                        {\r\n                            /* This path is a special case that will only get\r\n                             * executed if the task was holding multiple mutexes and\r\n                             * the mutexes were given back in an order that is\r\n                             * different to that in which they were taken. */\r\n                            queueYIELD_IF_USING_PREEMPTION();\r\n                        }\r\n                        else\r\n                        {\r\n                            mtCOVERAGE_TEST_MARKER();\r\n                        }\r\n                    }\r\n                #endif /* configUSE_QUEUE_SETS */\r\n\r\n                taskEXIT_CRITICAL();\r\n                return pdPASS;\r\n            }\r\n            else\r\n            {\r\n                if( xTicksToWait == ( TickType_t ) 0 )\r\n                {\r\n                    /* The queue was full and no block time is specified (or\r\n                     * the block time has expired) so leave now. */\r\n                    taskEXIT_CRITICAL();\r\n\r\n                    /* Return to the original privilege level before exiting\r\n                     * the function. */\r\n                    traceQUEUE_SEND_FAILED( pxQueue );\r\n                    return errQUEUE_FULL;\r\n                }\r\n                else if( xEntryTimeSet == pdFALSE )\r\n                {\r\n                    /* The queue was full and a block time was specified so\r\n                     * configure the timeout structure. */\r\n                    vTaskInternalSetTimeOutState( &xTimeOut );\r\n                    xEntryTimeSet = pdTRUE;\r\n                }\r\n                else\r\n                {\r\n                    /* Entry time was already set. */\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n        }\r\n        taskEXIT_CRITICAL();\r\n\r\n        /* Interrupts and other tasks can send to and receive from the queue\r\n         * now the critical section has been exited. */\r\n\r\n        vTaskSuspendAll();\r\n        prvLockQueue( pxQueue );\r\n\r\n        /* Update the timeout state to see if it has expired yet. */\r\n        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )\r\n        {\r\n            if( prvIsQueueFull( pxQueue ) != pdFALSE )\r\n            {\r\n                traceBLOCKING_ON_QUEUE_SEND( pxQueue );\r\n                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );\r\n\r\n                /* Unlocking the queue means queue events can effect the\r\n                 * event list.  It is possible that interrupts occurring now\r\n                 * remove this task from the event list again - but as the\r\n                 * scheduler is suspended the task will go onto the pending\r\n                 * ready last instead of the actual ready list. */\r\n                prvUnlockQueue( pxQueue );\r\n\r\n                /* Resuming the scheduler will move tasks from the pending\r\n                 * ready list into the ready list - so it is feasible that this\r\n                 * task is already in a ready list before it yields - in which\r\n                 * case the yield will not cause a context switch unless there\r\n                 * is also a higher priority task in the pending ready list. */\r\n                if( xTaskResumeAll() == pdFALSE )\r\n                {\r\n                    portYIELD_WITHIN_API();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                /* Try again. */\r\n                prvUnlockQueue( pxQueue );\r\n                ( void ) xTaskResumeAll();\r\n            }\r\n        }\r\n        else\r\n        {\r\n            /* The timeout has expired. */\r\n            prvUnlockQueue( pxQueue );\r\n            ( void ) xTaskResumeAll();\r\n\r\n            traceQUEUE_SEND_FAILED( pxQueue );\r\n            return errQUEUE_FULL;\r\n        }\r\n    } /*lint -restore */\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nBaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,\r\n                                     const void * const pvItemToQueue,\r\n                                     BaseType_t * const pxHigherPriorityTaskWoken,\r\n                                     const BaseType_t xCopyPosition )\r\n{\r\n    BaseType_t xReturn;\r\n    UBaseType_t uxSavedInterruptStatus;\r\n    Queue_t * const pxQueue = xQueue;\r\n\r\n    configASSERT( pxQueue );\r\n    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );\r\n    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );\r\n\r\n    /* RTOS ports that support interrupt nesting have the concept of a maximum\r\n     * system call (or maximum API call) interrupt priority.  Interrupts that are\r\n     * above the maximum system call priority are kept permanently enabled, even\r\n     * when the RTOS kernel is in a critical section, but cannot make any calls to\r\n     * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h\r\n     * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion\r\n     * failure if a FreeRTOS API function is called from an interrupt that has been\r\n     * assigned a priority above the configured maximum system call priority.\r\n     * Only FreeRTOS functions that end in FromISR can be called from interrupts\r\n     * that have been assigned a priority at or (logically) below the maximum\r\n     * system call interrupt priority.  FreeRTOS maintains a separate interrupt\r\n     * safe API to ensure interrupt entry is as fast and as simple as possible.\r\n     * More information (albeit Cortex-M specific) is provided on the following\r\n     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */\r\n    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();\r\n\r\n    /* Similar to xQueueGenericSend, except without blocking if there is no room\r\n     * in the queue.  Also don't directly wake a task that was blocked on a queue\r\n     * read, instead return a flag to say whether a context switch is required or\r\n     * not (i.e. has a task with a higher priority than us been woken by this\r\n     * post). */\r\n    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();\r\n    {\r\n        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )\r\n        {\r\n            const int8_t cTxLock = pxQueue->cTxLock;\r\n            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;\r\n\r\n            traceQUEUE_SEND_FROM_ISR( pxQueue );\r\n\r\n            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a\r\n             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result\r\n             *  in a task disinheriting a priority and prvCopyDataToQueue() can be\r\n             *  called here even though the disinherit function does not check if\r\n             *  the scheduler is suspended before accessing the ready lists. */\r\n            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );\r\n\r\n            /* The event list is not altered if the queue is locked.  This will\r\n             * be done when the queue is unlocked later. */\r\n            if( cTxLock == queueUNLOCKED )\r\n            {\r\n                #if ( configUSE_QUEUE_SETS == 1 )\r\n                    {\r\n                        if( pxQueue->pxQueueSetContainer != NULL )\r\n                        {\r\n                            if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )\r\n                            {\r\n                                /* Do not notify the queue set as an existing item\r\n                                 * was overwritten in the queue so the number of items\r\n                                 * in the queue has not changed. */\r\n                                mtCOVERAGE_TEST_MARKER();\r\n                            }\r\n                            else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )\r\n                            {\r\n                                /* The queue is a member of a queue set, and posting\r\n                                 * to the queue set caused a higher priority task to\r\n                                 * unblock.  A context switch is required. */\r\n                                if( pxHigherPriorityTaskWoken != NULL )\r\n                                {\r\n                                    *pxHigherPriorityTaskWoken = pdTRUE;\r\n                                }\r\n                                else\r\n                                {\r\n                                    mtCOVERAGE_TEST_MARKER();\r\n                                }\r\n                            }\r\n                            else\r\n                            {\r\n                                mtCOVERAGE_TEST_MARKER();\r\n                            }\r\n                        }\r\n                        else\r\n                        {\r\n                            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )\r\n                            {\r\n                                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )\r\n                                {\r\n                                    /* The task waiting has a higher priority so\r\n                                     *  record that a context switch is required. */\r\n                                    if( pxHigherPriorityTaskWoken != NULL )\r\n                                    {\r\n                                        *pxHigherPriorityTaskWoken = pdTRUE;\r\n                                    }\r\n                                    else\r\n                                    {\r\n                                        mtCOVERAGE_TEST_MARKER();\r\n                                    }\r\n                                }\r\n                                else\r\n                                {\r\n                                    mtCOVERAGE_TEST_MARKER();\r\n                                }\r\n                            }\r\n                            else\r\n                            {\r\n                                mtCOVERAGE_TEST_MARKER();\r\n                            }\r\n                        }\r\n                    }\r\n                #else /* configUSE_QUEUE_SETS */\r\n                    {\r\n                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )\r\n                        {\r\n                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )\r\n                            {\r\n                                /* The task waiting has a higher priority so record that a\r\n                                 * context switch is required. */\r\n                                if( pxHigherPriorityTaskWoken != NULL )\r\n                                {\r\n                                    *pxHigherPriorityTaskWoken = pdTRUE;\r\n                                }\r\n                                else\r\n                                {\r\n                                    mtCOVERAGE_TEST_MARKER();\r\n                                }\r\n                            }\r\n                            else\r\n                            {\r\n                                mtCOVERAGE_TEST_MARKER();\r\n                            }\r\n                        }\r\n                        else\r\n                        {\r\n                            mtCOVERAGE_TEST_MARKER();\r\n                        }\r\n\r\n                        /* Not used in this path. */\r\n                        ( void ) uxPreviousMessagesWaiting;\r\n                    }\r\n                #endif /* configUSE_QUEUE_SETS */\r\n            }\r\n            else\r\n            {\r\n                /* Increment the lock count so the task that unlocks the queue\r\n                 * knows that data was posted while it was locked. */\r\n                configASSERT( cTxLock != queueINT8_MAX );\r\n\r\n                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );\r\n            }\r\n\r\n            xReturn = pdPASS;\r\n        }\r\n        else\r\n        {\r\n            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );\r\n            xReturn = errQUEUE_FULL;\r\n        }\r\n    }\r\n    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );\r\n\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nBaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,\r\n                              BaseType_t * const pxHigherPriorityTaskWoken )\r\n{\r\n    BaseType_t xReturn;\r\n    UBaseType_t uxSavedInterruptStatus;\r\n    Queue_t * const pxQueue = xQueue;\r\n\r\n    /* Similar to xQueueGenericSendFromISR() but used with semaphores where the\r\n     * item size is 0.  Don't directly wake a task that was blocked on a queue\r\n     * read, instead return a flag to say whether a context switch is required or\r\n     * not (i.e. has a task with a higher priority than us been woken by this\r\n     * post). */\r\n\r\n    configASSERT( pxQueue );\r\n\r\n    /* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()\r\n     * if the item size is not 0. */\r\n    configASSERT( pxQueue->uxItemSize == 0 );\r\n\r\n    /* Normally a mutex would not be given from an interrupt, especially if\r\n     * there is a mutex holder, as priority inheritance makes no sense for an\r\n     * interrupts, only tasks. */\r\n    configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );\r\n\r\n    /* RTOS ports that support interrupt nesting have the concept of a maximum\r\n     * system call (or maximum API call) interrupt priority.  Interrupts that are\r\n     * above the maximum system call priority are kept permanently enabled, even\r\n     * when the RTOS kernel is in a critical section, but cannot make any calls to\r\n     * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h\r\n     * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion\r\n     * failure if a FreeRTOS API function is called from an interrupt that has been\r\n     * assigned a priority above the configured maximum system call priority.\r\n     * Only FreeRTOS functions that end in FromISR can be called from interrupts\r\n     * that have been assigned a priority at or (logically) below the maximum\r\n     * system call interrupt priority.  FreeRTOS maintains a separate interrupt\r\n     * safe API to ensure interrupt entry is as fast and as simple as possible.\r\n     * More information (albeit Cortex-M specific) is provided on the following\r\n     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */\r\n    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();\r\n\r\n    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();\r\n    {\r\n        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;\r\n\r\n        /* When the queue is used to implement a semaphore no data is ever\r\n         * moved through the queue but it is still valid to see if the queue 'has\r\n         * space'. */\r\n        if( uxMessagesWaiting < pxQueue->uxLength )\r\n        {\r\n            const int8_t cTxLock = pxQueue->cTxLock;\r\n\r\n            traceQUEUE_SEND_FROM_ISR( pxQueue );\r\n\r\n            /* A task can only have an inherited priority if it is a mutex\r\n             * holder - and if there is a mutex holder then the mutex cannot be\r\n             * given from an ISR.  As this is the ISR version of the function it\r\n             * can be assumed there is no mutex holder and no need to determine if\r\n             * priority disinheritance is needed.  Simply increase the count of\r\n             * messages (semaphores) available. */\r\n            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;\r\n\r\n            /* The event list is not altered if the queue is locked.  This will\r\n             * be done when the queue is unlocked later. */\r\n            if( cTxLock == queueUNLOCKED )\r\n            {\r\n                #if ( configUSE_QUEUE_SETS == 1 )\r\n                    {\r\n                        if( pxQueue->pxQueueSetContainer != NULL )\r\n                        {\r\n                            if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )\r\n                            {\r\n                                /* The semaphore is a member of a queue set, and\r\n                                 * posting to the queue set caused a higher priority\r\n                                 * task to unblock.  A context switch is required. */\r\n                                if( pxHigherPriorityTaskWoken != NULL )\r\n                                {\r\n                                    *pxHigherPriorityTaskWoken = pdTRUE;\r\n                                }\r\n                                else\r\n                                {\r\n                                    mtCOVERAGE_TEST_MARKER();\r\n                                }\r\n                            }\r\n                            else\r\n                            {\r\n                                mtCOVERAGE_TEST_MARKER();\r\n                            }\r\n                        }\r\n                        else\r\n                        {\r\n                            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )\r\n                            {\r\n                                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )\r\n                                {\r\n                                    /* The task waiting has a higher priority so\r\n                                     *  record that a context switch is required. */\r\n                                    if( pxHigherPriorityTaskWoken != NULL )\r\n                                    {\r\n                                        *pxHigherPriorityTaskWoken = pdTRUE;\r\n                                    }\r\n                                    else\r\n                                    {\r\n                                        mtCOVERAGE_TEST_MARKER();\r\n                                    }\r\n                                }\r\n                                else\r\n                                {\r\n                                    mtCOVERAGE_TEST_MARKER();\r\n                                }\r\n                            }\r\n                            else\r\n                            {\r\n                                mtCOVERAGE_TEST_MARKER();\r\n                            }\r\n                        }\r\n                    }\r\n                #else /* configUSE_QUEUE_SETS */\r\n                    {\r\n                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )\r\n                        {\r\n                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )\r\n                            {\r\n                                /* The task waiting has a higher priority so record that a\r\n                                 * context switch is required. */\r\n                                if( pxHigherPriorityTaskWoken != NULL )\r\n                                {\r\n                                    *pxHigherPriorityTaskWoken = pdTRUE;\r\n                                }\r\n                                else\r\n                                {\r\n                                    mtCOVERAGE_TEST_MARKER();\r\n                                }\r\n                            }\r\n                            else\r\n                            {\r\n                                mtCOVERAGE_TEST_MARKER();\r\n                            }\r\n                        }\r\n                        else\r\n                        {\r\n                            mtCOVERAGE_TEST_MARKER();\r\n                        }\r\n                    }\r\n                #endif /* configUSE_QUEUE_SETS */\r\n            }\r\n            else\r\n            {\r\n                /* Increment the lock count so the task that unlocks the queue\r\n                 * knows that data was posted while it was locked. */\r\n                configASSERT( cTxLock != queueINT8_MAX );\r\n\r\n                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );\r\n            }\r\n\r\n            xReturn = pdPASS;\r\n        }\r\n        else\r\n        {\r\n            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );\r\n            xReturn = errQUEUE_FULL;\r\n        }\r\n    }\r\n    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );\r\n\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nBaseType_t xQueueReceive( QueueHandle_t xQueue,\r\n                          void * const pvBuffer,\r\n                          TickType_t xTicksToWait )\r\n{\r\n    BaseType_t xEntryTimeSet = pdFALSE;\r\n    TimeOut_t xTimeOut;\r\n    Queue_t * const pxQueue = xQueue;\r\n\r\n    /* Check the pointer is not NULL. */\r\n    configASSERT( ( pxQueue ) );\r\n\r\n    /* The buffer into which data is received can only be NULL if the data size\r\n     * is zero (so no data is copied into the buffer). */\r\n    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );\r\n\r\n    /* Cannot block if the scheduler is suspended. */\r\n    #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )\r\n        {\r\n            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );\r\n        }\r\n    #endif\r\n\r\n    /*lint -save -e904  This function relaxes the coding standard somewhat to\r\n     * allow return statements within the function itself.  This is done in the\r\n     * interest of execution time efficiency. */\r\n    for( ; ; )\r\n    {\r\n        taskENTER_CRITICAL();\r\n        {\r\n            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;\r\n\r\n            /* Is there data in the queue now?  To be running the calling task\r\n             * must be the highest priority task wanting to access the queue. */\r\n            if( uxMessagesWaiting > ( UBaseType_t ) 0 )\r\n            {\r\n                /* Data available, remove one item. */\r\n                prvCopyDataFromQueue( pxQueue, pvBuffer );\r\n                traceQUEUE_RECEIVE( pxQueue );\r\n                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;\r\n\r\n                /* There is now space in the queue, were any tasks waiting to\r\n                 * post to the queue?  If so, unblock the highest priority waiting\r\n                 * task. */\r\n                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )\r\n                {\r\n                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )\r\n                    {\r\n                        queueYIELD_IF_USING_PREEMPTION();\r\n                    }\r\n                    else\r\n                    {\r\n                        mtCOVERAGE_TEST_MARKER();\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n\r\n                taskEXIT_CRITICAL();\r\n                return pdPASS;\r\n            }\r\n            else\r\n            {\r\n                if( xTicksToWait == ( TickType_t ) 0 )\r\n                {\r\n                    /* The queue was empty and no block time is specified (or\r\n                     * the block time has expired) so leave now. */\r\n                    taskEXIT_CRITICAL();\r\n                    traceQUEUE_RECEIVE_FAILED( pxQueue );\r\n                    return errQUEUE_EMPTY;\r\n                }\r\n                else if( xEntryTimeSet == pdFALSE )\r\n                {\r\n                    /* The queue was empty and a block time was specified so\r\n                     * configure the timeout structure. */\r\n                    vTaskInternalSetTimeOutState( &xTimeOut );\r\n                    xEntryTimeSet = pdTRUE;\r\n                }\r\n                else\r\n                {\r\n                    /* Entry time was already set. */\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n        }\r\n        taskEXIT_CRITICAL();\r\n\r\n        /* Interrupts and other tasks can send to and receive from the queue\r\n         * now the critical section has been exited. */\r\n\r\n        vTaskSuspendAll();\r\n        prvLockQueue( pxQueue );\r\n\r\n        /* Update the timeout state to see if it has expired yet. */\r\n        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )\r\n        {\r\n            /* The timeout has not expired.  If the queue is still empty place\r\n             * the task on the list of tasks waiting to receive from the queue. */\r\n            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )\r\n            {\r\n                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );\r\n                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );\r\n                prvUnlockQueue( pxQueue );\r\n\r\n                if( xTaskResumeAll() == pdFALSE )\r\n                {\r\n                    portYIELD_WITHIN_API();\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                /* The queue contains data again.  Loop back to try and read the\r\n                 * data. */\r\n                prvUnlockQueue( pxQueue );\r\n                ( void ) xTaskResumeAll();\r\n            }\r\n        }\r\n        else\r\n        {\r\n            /* Timed out.  If there is no data in the queue exit, otherwise loop\r\n             * back and attempt to read the data. */\r\n            prvUnlockQueue( pxQueue );\r\n            ( void ) xTaskResumeAll();\r\n\r\n            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )\r\n            {\r\n                traceQUEUE_RECEIVE_FAILED( pxQueue );\r\n                return errQUEUE_EMPTY;\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n    } /*lint -restore */\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nBaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,\r\n                                TickType_t xTicksToWait )\r\n{\r\n    BaseType_t xEntryTimeSet = pdFALSE;\r\n    TimeOut_t xTimeOut;\r\n    Queue_t * const pxQueue = xQueue;\r\n\r\n    #if ( configUSE_MUTEXES == 1 )\r\n        BaseType_t xInheritanceOccurred = pdFALSE;\r\n    #endif\r\n\r\n    /* Check the queue pointer is not NULL. */\r\n    configASSERT( ( pxQueue ) );\r\n\r\n    /* Check this really is a semaphore, in which case the item size will be\r\n     * 0. */\r\n    configASSERT( pxQueue->uxItemSize == 0 );\r\n\r\n    /* Cannot block if the scheduler is suspended. */\r\n    #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )\r\n        {\r\n            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );\r\n        }\r\n    #endif\r\n\r\n    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return\r\n     * statements within the function itself.  This is done in the interest\r\n     * of execution time efficiency. */\r\n    for( ; ; )\r\n    {\r\n        taskENTER_CRITICAL();\r\n        {\r\n            /* Semaphores are queues with an item size of 0, and where the\r\n             * number of messages in the queue is the semaphore's count value. */\r\n            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;\r\n\r\n            /* Is there data in the queue now?  To be running the calling task\r\n             * must be the highest priority task wanting to access the queue. */\r\n            if( uxSemaphoreCount > ( UBaseType_t ) 0 )\r\n            {\r\n                traceQUEUE_RECEIVE( pxQueue );\r\n\r\n                /* Semaphores are queues with a data size of zero and where the\r\n                 * messages waiting is the semaphore's count.  Reduce the count. */\r\n                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;\r\n\r\n                #if ( configUSE_MUTEXES == 1 )\r\n                    {\r\n                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )\r\n                        {\r\n                            /* Record the information required to implement\r\n                             * priority inheritance should it become necessary. */\r\n                            pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();\r\n                        }\r\n                        else\r\n                        {\r\n                            mtCOVERAGE_TEST_MARKER();\r\n                        }\r\n                    }\r\n                #endif /* configUSE_MUTEXES */\r\n\r\n                /* Check to see if other tasks are blocked waiting to give the\r\n                 * semaphore, and if so, unblock the highest priority such task. */\r\n                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )\r\n                {\r\n                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )\r\n                    {\r\n                        queueYIELD_IF_USING_PREEMPTION();\r\n                    }\r\n                    else\r\n                    {\r\n                        mtCOVERAGE_TEST_MARKER();\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n\r\n                taskEXIT_CRITICAL();\r\n                return pdPASS;\r\n            }\r\n            else\r\n            {\r\n                if( xTicksToWait == ( TickType_t ) 0 )\r\n                {\r\n                    /* For inheritance to have occurred there must have been an\r\n                     * initial timeout, and an adjusted timeout cannot become 0, as\r\n                     * if it were 0 the function would have exited. */\r\n                    #if ( configUSE_MUTEXES == 1 )\r\n                        {\r\n                            configASSERT( xInheritanceOccurred == pdFALSE );\r\n                        }\r\n                    #endif /* configUSE_MUTEXES */\r\n\r\n                    /* The semaphore count was 0 and no block time is specified\r\n                     * (or the block time has expired) so exit now. */\r\n                    taskEXIT_CRITICAL();\r\n                    traceQUEUE_RECEIVE_FAILED( pxQueue );\r\n                    return errQUEUE_EMPTY;\r\n                }\r\n                else if( xEntryTimeSet == pdFALSE )\r\n                {\r\n                    /* The semaphore count was 0 and a block time was specified\r\n                     * so configure the timeout structure ready to block. */\r\n                    vTaskInternalSetTimeOutState( &xTimeOut );\r\n                    xEntryTimeSet = pdTRUE;\r\n                }\r\n                else\r\n                {\r\n                    /* Entry time was already set. */\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n        }\r\n        taskEXIT_CRITICAL();\r\n\r\n        /* Interrupts and other tasks can give to and take from the semaphore\r\n         * now the critical section has been exited. */\r\n\r\n        vTaskSuspendAll();\r\n        prvLockQueue( pxQueue );\r\n\r\n        /* Update the timeout state to see if it has expired yet. */\r\n        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )\r\n        {\r\n            /* A block time is specified and not expired.  If the semaphore\r\n             * count is 0 then enter the Blocked state to wait for a semaphore to\r\n             * become available.  As semaphores are implemented with queues the\r\n             * queue being empty is equivalent to the semaphore count being 0. */\r\n            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )\r\n            {\r\n                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );\r\n\r\n                #if ( configUSE_MUTEXES == 1 )\r\n                    {\r\n                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )\r\n                        {\r\n                            taskENTER_CRITICAL();\r\n                            {\r\n                                xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );\r\n                            }\r\n                            taskEXIT_CRITICAL();\r\n                        }\r\n                        else\r\n                        {\r\n                            mtCOVERAGE_TEST_MARKER();\r\n                        }\r\n                    }\r\n                #endif /* if ( configUSE_MUTEXES == 1 ) */\r\n\r\n                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );\r\n                prvUnlockQueue( pxQueue );\r\n\r\n                if( xTaskResumeAll() == pdFALSE )\r\n                {\r\n                    portYIELD_WITHIN_API();\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                /* There was no timeout and the semaphore count was not 0, so\r\n                 * attempt to take the semaphore again. */\r\n                prvUnlockQueue( pxQueue );\r\n                ( void ) xTaskResumeAll();\r\n            }\r\n        }\r\n        else\r\n        {\r\n            /* Timed out. */\r\n            prvUnlockQueue( pxQueue );\r\n            ( void ) xTaskResumeAll();\r\n\r\n            /* If the semaphore count is 0 exit now as the timeout has\r\n             * expired.  Otherwise return to attempt to take the semaphore that is\r\n             * known to be available.  As semaphores are implemented by queues the\r\n             * queue being empty is equivalent to the semaphore count being 0. */\r\n            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )\r\n            {\r\n                #if ( configUSE_MUTEXES == 1 )\r\n                    {\r\n                        /* xInheritanceOccurred could only have be set if\r\n                         * pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to\r\n                         * test the mutex type again to check it is actually a mutex. */\r\n                        if( xInheritanceOccurred != pdFALSE )\r\n                        {\r\n                            taskENTER_CRITICAL();\r\n                            {\r\n                                UBaseType_t uxHighestWaitingPriority;\r\n\r\n                                /* This task blocking on the mutex caused another\r\n                                 * task to inherit this task's priority.  Now this task\r\n                                 * has timed out the priority should be disinherited\r\n                                 * again, but only as low as the next highest priority\r\n                                 * task that is waiting for the same mutex. */\r\n                                uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );\r\n                                vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );\r\n                            }\r\n                            taskEXIT_CRITICAL();\r\n                        }\r\n                    }\r\n                #endif /* configUSE_MUTEXES */\r\n\r\n                traceQUEUE_RECEIVE_FAILED( pxQueue );\r\n                return errQUEUE_EMPTY;\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n    } /*lint -restore */\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nBaseType_t xQueuePeek( QueueHandle_t xQueue,\r\n                       void * const pvBuffer,\r\n                       TickType_t xTicksToWait )\r\n{\r\n    BaseType_t xEntryTimeSet = pdFALSE;\r\n    TimeOut_t xTimeOut;\r\n    int8_t * pcOriginalReadPosition;\r\n    Queue_t * const pxQueue = xQueue;\r\n\r\n    /* Check the pointer is not NULL. */\r\n    configASSERT( ( pxQueue ) );\r\n\r\n    /* The buffer into which data is received can only be NULL if the data size\r\n     * is zero (so no data is copied into the buffer. */\r\n    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );\r\n\r\n    /* Cannot block if the scheduler is suspended. */\r\n    #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )\r\n        {\r\n            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );\r\n        }\r\n    #endif\r\n\r\n    /*lint -save -e904  This function relaxes the coding standard somewhat to\r\n     * allow return statements within the function itself.  This is done in the\r\n     * interest of execution time efficiency. */\r\n    for( ; ; )\r\n    {\r\n        taskENTER_CRITICAL();\r\n        {\r\n            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;\r\n\r\n            /* Is there data in the queue now?  To be running the calling task\r\n             * must be the highest priority task wanting to access the queue. */\r\n            if( uxMessagesWaiting > ( UBaseType_t ) 0 )\r\n            {\r\n                /* Remember the read position so it can be reset after the data\r\n                 * is read from the queue as this function is only peeking the\r\n                 * data, not removing it. */\r\n                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;\r\n\r\n                prvCopyDataFromQueue( pxQueue, pvBuffer );\r\n                traceQUEUE_PEEK( pxQueue );\r\n\r\n                /* The data is not being removed, so reset the read pointer. */\r\n                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;\r\n\r\n                /* The data is being left in the queue, so see if there are\r\n                 * any other tasks waiting for the data. */\r\n                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )\r\n                {\r\n                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )\r\n                    {\r\n                        /* The task waiting has a higher priority than this task. */\r\n                        queueYIELD_IF_USING_PREEMPTION();\r\n                    }\r\n                    else\r\n                    {\r\n                        mtCOVERAGE_TEST_MARKER();\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n\r\n                taskEXIT_CRITICAL();\r\n                return pdPASS;\r\n            }\r\n            else\r\n            {\r\n                if( xTicksToWait == ( TickType_t ) 0 )\r\n                {\r\n                    /* The queue was empty and no block time is specified (or\r\n                     * the block time has expired) so leave now. */\r\n                    taskEXIT_CRITICAL();\r\n                    traceQUEUE_PEEK_FAILED( pxQueue );\r\n                    return errQUEUE_EMPTY;\r\n                }\r\n                else if( xEntryTimeSet == pdFALSE )\r\n                {\r\n                    /* The queue was empty and a block time was specified so\r\n                     * configure the timeout structure ready to enter the blocked\r\n                     * state. */\r\n                    vTaskInternalSetTimeOutState( &xTimeOut );\r\n                    xEntryTimeSet = pdTRUE;\r\n                }\r\n                else\r\n                {\r\n                    /* Entry time was already set. */\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n        }\r\n        taskEXIT_CRITICAL();\r\n\r\n        /* Interrupts and other tasks can send to and receive from the queue\r\n         * now the critical section has been exited. */\r\n\r\n        vTaskSuspendAll();\r\n        prvLockQueue( pxQueue );\r\n\r\n        /* Update the timeout state to see if it has expired yet. */\r\n        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )\r\n        {\r\n            /* Timeout has not expired yet, check to see if there is data in the\r\n            * queue now, and if not enter the Blocked state to wait for data. */\r\n            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )\r\n            {\r\n                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );\r\n                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );\r\n                prvUnlockQueue( pxQueue );\r\n\r\n                if( xTaskResumeAll() == pdFALSE )\r\n                {\r\n                    portYIELD_WITHIN_API();\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                /* There is data in the queue now, so don't enter the blocked\r\n                 * state, instead return to try and obtain the data. */\r\n                prvUnlockQueue( pxQueue );\r\n                ( void ) xTaskResumeAll();\r\n            }\r\n        }\r\n        else\r\n        {\r\n            /* The timeout has expired.  If there is still no data in the queue\r\n             * exit, otherwise go back and try to read the data again. */\r\n            prvUnlockQueue( pxQueue );\r\n            ( void ) xTaskResumeAll();\r\n\r\n            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )\r\n            {\r\n                traceQUEUE_PEEK_FAILED( pxQueue );\r\n                return errQUEUE_EMPTY;\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n    } /*lint -restore */\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nBaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,\r\n                                 void * const pvBuffer,\r\n                                 BaseType_t * const pxHigherPriorityTaskWoken )\r\n{\r\n    BaseType_t xReturn;\r\n    UBaseType_t uxSavedInterruptStatus;\r\n    Queue_t * const pxQueue = xQueue;\r\n\r\n    configASSERT( pxQueue );\r\n    configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );\r\n\r\n    /* RTOS ports that support interrupt nesting have the concept of a maximum\r\n     * system call (or maximum API call) interrupt priority.  Interrupts that are\r\n     * above the maximum system call priority are kept permanently enabled, even\r\n     * when the RTOS kernel is in a critical section, but cannot make any calls to\r\n     * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h\r\n     * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion\r\n     * failure if a FreeRTOS API function is called from an interrupt that has been\r\n     * assigned a priority above the configured maximum system call priority.\r\n     * Only FreeRTOS functions that end in FromISR can be called from interrupts\r\n     * that have been assigned a priority at or (logically) below the maximum\r\n     * system call interrupt priority.  FreeRTOS maintains a separate interrupt\r\n     * safe API to ensure interrupt entry is as fast and as simple as possible.\r\n     * More information (albeit Cortex-M specific) is provided on the following\r\n     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */\r\n    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();\r\n\r\n    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();\r\n    {\r\n        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;\r\n\r\n        /* Cannot block in an ISR, so check there is data available. */\r\n        if( uxMessagesWaiting > ( UBaseType_t ) 0 )\r\n        {\r\n            const int8_t cRxLock = pxQueue->cRxLock;\r\n\r\n            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );\r\n\r\n            prvCopyDataFromQueue( pxQueue, pvBuffer );\r\n            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;\r\n\r\n            /* If the queue is locked the event list will not be modified.\r\n             * Instead update the lock count so the task that unlocks the queue\r\n             * will know that an ISR has removed data while the queue was\r\n             * locked. */\r\n            if( cRxLock == queueUNLOCKED )\r\n            {\r\n                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )\r\n                {\r\n                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )\r\n                    {\r\n                        /* The task waiting has a higher priority than us so\r\n                         * force a context switch. */\r\n                        if( pxHigherPriorityTaskWoken != NULL )\r\n                        {\r\n                            *pxHigherPriorityTaskWoken = pdTRUE;\r\n                        }\r\n                        else\r\n                        {\r\n                            mtCOVERAGE_TEST_MARKER();\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        mtCOVERAGE_TEST_MARKER();\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                /* Increment the lock count so the task that unlocks the queue\r\n                 * knows that data was removed while it was locked. */\r\n                configASSERT( cRxLock != queueINT8_MAX );\r\n\r\n                pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );\r\n            }\r\n\r\n            xReturn = pdPASS;\r\n        }\r\n        else\r\n        {\r\n            xReturn = pdFAIL;\r\n            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );\r\n        }\r\n    }\r\n    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );\r\n\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nBaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,\r\n                              void * const pvBuffer )\r\n{\r\n    BaseType_t xReturn;\r\n    UBaseType_t uxSavedInterruptStatus;\r\n    int8_t * pcOriginalReadPosition;\r\n    Queue_t * const pxQueue = xQueue;\r\n\r\n    configASSERT( pxQueue );\r\n    configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );\r\n    configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */\r\n\r\n    /* RTOS ports that support interrupt nesting have the concept of a maximum\r\n     * system call (or maximum API call) interrupt priority.  Interrupts that are\r\n     * above the maximum system call priority are kept permanently enabled, even\r\n     * when the RTOS kernel is in a critical section, but cannot make any calls to\r\n     * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h\r\n     * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion\r\n     * failure if a FreeRTOS API function is called from an interrupt that has been\r\n     * assigned a priority above the configured maximum system call priority.\r\n     * Only FreeRTOS functions that end in FromISR can be called from interrupts\r\n     * that have been assigned a priority at or (logically) below the maximum\r\n     * system call interrupt priority.  FreeRTOS maintains a separate interrupt\r\n     * safe API to ensure interrupt entry is as fast and as simple as possible.\r\n     * More information (albeit Cortex-M specific) is provided on the following\r\n     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */\r\n    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();\r\n\r\n    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();\r\n    {\r\n        /* Cannot block in an ISR, so check there is data available. */\r\n        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )\r\n        {\r\n            traceQUEUE_PEEK_FROM_ISR( pxQueue );\r\n\r\n            /* Remember the read position so it can be reset as nothing is\r\n             * actually being removed from the queue. */\r\n            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;\r\n            prvCopyDataFromQueue( pxQueue, pvBuffer );\r\n            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;\r\n\r\n            xReturn = pdPASS;\r\n        }\r\n        else\r\n        {\r\n            xReturn = pdFAIL;\r\n            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );\r\n        }\r\n    }\r\n    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );\r\n\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nUBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )\r\n{\r\n    UBaseType_t uxReturn;\r\n\r\n    configASSERT( xQueue );\r\n\r\n    taskENTER_CRITICAL();\r\n    {\r\n        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;\r\n    }\r\n    taskEXIT_CRITICAL();\r\n\r\n    return uxReturn;\r\n} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */\r\n/*-----------------------------------------------------------*/\r\n\r\nUBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )\r\n{\r\n    UBaseType_t uxReturn;\r\n    Queue_t * const pxQueue = xQueue;\r\n\r\n    configASSERT( pxQueue );\r\n\r\n    taskENTER_CRITICAL();\r\n    {\r\n        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;\r\n    }\r\n    taskEXIT_CRITICAL();\r\n\r\n    return uxReturn;\r\n} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */\r\n/*-----------------------------------------------------------*/\r\n\r\nUBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )\r\n{\r\n    UBaseType_t uxReturn;\r\n    Queue_t * const pxQueue = xQueue;\r\n\r\n    configASSERT( pxQueue );\r\n    uxReturn = pxQueue->uxMessagesWaiting;\r\n\r\n    return uxReturn;\r\n} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */\r\n/*-----------------------------------------------------------*/\r\n\r\nvoid vQueueDelete( QueueHandle_t xQueue )\r\n{\r\n    Queue_t * const pxQueue = xQueue;\r\n\r\n    configASSERT( pxQueue );\r\n    traceQUEUE_DELETE( pxQueue );\r\n\r\n    #if ( configQUEUE_REGISTRY_SIZE > 0 )\r\n        {\r\n            vQueueUnregisterQueue( pxQueue );\r\n        }\r\n    #endif\r\n\r\n    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )\r\n        {\r\n            /* The queue can only have been allocated dynamically - free it\r\n             * again. */\r\n            vPortFree( pxQueue );\r\n        }\r\n    #elif ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )\r\n        {\r\n            /* The queue could have been allocated statically or dynamically, so\r\n             * check before attempting to free the memory. */\r\n            if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )\r\n            {\r\n                vPortFree( pxQueue );\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n    #else /* if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) ) */\r\n        {\r\n            /* The queue must have been statically allocated, so is not going to be\r\n             * deleted.  Avoid compiler warnings about the unused parameter. */\r\n            ( void ) pxQueue;\r\n        }\r\n    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_TRACE_FACILITY == 1 )\r\n\r\n    UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )\r\n    {\r\n        return ( ( Queue_t * ) xQueue )->uxQueueNumber;\r\n    }\r\n\r\n#endif /* configUSE_TRACE_FACILITY */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_TRACE_FACILITY == 1 )\r\n\r\n    void vQueueSetQueueNumber( QueueHandle_t xQueue,\r\n                               UBaseType_t uxQueueNumber )\r\n    {\r\n        ( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;\r\n    }\r\n\r\n#endif /* configUSE_TRACE_FACILITY */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_TRACE_FACILITY == 1 )\r\n\r\n    uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )\r\n    {\r\n        return ( ( Queue_t * ) xQueue )->ucQueueType;\r\n    }\r\n\r\n#endif /* configUSE_TRACE_FACILITY */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_MUTEXES == 1 )\r\n\r\n    static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )\r\n    {\r\n        UBaseType_t uxHighestPriorityOfWaitingTasks;\r\n\r\n        /* If a task waiting for a mutex causes the mutex holder to inherit a\r\n         * priority, but the waiting task times out, then the holder should\r\n         * disinherit the priority - but only down to the highest priority of any\r\n         * other tasks that are waiting for the same mutex.  For this purpose,\r\n         * return the priority of the highest priority task that is waiting for the\r\n         * mutex. */\r\n        if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )\r\n        {\r\n            uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );\r\n        }\r\n        else\r\n        {\r\n            uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;\r\n        }\r\n\r\n        return uxHighestPriorityOfWaitingTasks;\r\n    }\r\n\r\n#endif /* configUSE_MUTEXES */\r\n/*-----------------------------------------------------------*/\r\n\r\nstatic BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,\r\n                                      const void * pvItemToQueue,\r\n                                      const BaseType_t xPosition )\r\n{\r\n    BaseType_t xReturn = pdFALSE;\r\n    UBaseType_t uxMessagesWaiting;\r\n\r\n    /* This function is called from a critical section. */\r\n\r\n    uxMessagesWaiting = pxQueue->uxMessagesWaiting;\r\n\r\n    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )\r\n    {\r\n        #if ( configUSE_MUTEXES == 1 )\r\n            {\r\n                if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )\r\n                {\r\n                    /* The mutex is no longer being held. */\r\n                    xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );\r\n                    pxQueue->u.xSemaphore.xMutexHolder = NULL;\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n        #endif /* configUSE_MUTEXES */\r\n    }\r\n    else if( xPosition == queueSEND_TO_BACK )\r\n    {\r\n        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */\r\n        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */\r\n\r\n        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */\r\n        {\r\n            pxQueue->pcWriteTo = pxQueue->pcHead;\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n    }\r\n    else\r\n    {\r\n        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */\r\n        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;\r\n\r\n        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */\r\n        {\r\n            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n\r\n        if( xPosition == queueOVERWRITE )\r\n        {\r\n            if( uxMessagesWaiting > ( UBaseType_t ) 0 )\r\n            {\r\n                /* An item is not being added but overwritten, so subtract\r\n                 * one from the recorded number of items in the queue so when\r\n                 * one is added again below the number of recorded items remains\r\n                 * correct. */\r\n                --uxMessagesWaiting;\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n    }\r\n\r\n    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;\r\n\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nstatic void prvCopyDataFromQueue( Queue_t * const pxQueue,\r\n                                  void * const pvBuffer )\r\n{\r\n    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )\r\n    {\r\n        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */\r\n\r\n        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */\r\n        {\r\n            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n\r\n        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */\r\n    }\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nstatic void prvUnlockQueue( Queue_t * const pxQueue )\r\n{\r\n    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */\r\n\r\n    /* The lock counts contains the number of extra data items placed or\r\n     * removed from the queue while the queue was locked.  When a queue is\r\n     * locked items can be added or removed, but the event lists cannot be\r\n     * updated. */\r\n    taskENTER_CRITICAL();\r\n    {\r\n        int8_t cTxLock = pxQueue->cTxLock;\r\n\r\n        /* See if data was added to the queue while it was locked. */\r\n        while( cTxLock > queueLOCKED_UNMODIFIED )\r\n        {\r\n            /* Data was posted while the queue was locked.  Are any tasks\r\n             * blocked waiting for data to become available? */\r\n            #if ( configUSE_QUEUE_SETS == 1 )\r\n                {\r\n                    if( pxQueue->pxQueueSetContainer != NULL )\r\n                    {\r\n                        if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )\r\n                        {\r\n                            /* The queue is a member of a queue set, and posting to\r\n                             * the queue set caused a higher priority task to unblock.\r\n                             * A context switch is required. */\r\n                            vTaskMissedYield();\r\n                        }\r\n                        else\r\n                        {\r\n                            mtCOVERAGE_TEST_MARKER();\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        /* Tasks that are removed from the event list will get\r\n                         * added to the pending ready list as the scheduler is still\r\n                         * suspended. */\r\n                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )\r\n                        {\r\n                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )\r\n                            {\r\n                                /* The task waiting has a higher priority so record that a\r\n                                 * context switch is required. */\r\n                                vTaskMissedYield();\r\n                            }\r\n                            else\r\n                            {\r\n                                mtCOVERAGE_TEST_MARKER();\r\n                            }\r\n                        }\r\n                        else\r\n                        {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            #else /* configUSE_QUEUE_SETS */\r\n                {\r\n                    /* Tasks that are removed from the event list will get added to\r\n                     * the pending ready list as the scheduler is still suspended. */\r\n                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )\r\n                    {\r\n                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )\r\n                        {\r\n                            /* The task waiting has a higher priority so record that\r\n                             * a context switch is required. */\r\n                            vTaskMissedYield();\r\n                        }\r\n                        else\r\n                        {\r\n                            mtCOVERAGE_TEST_MARKER();\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        break;\r\n                    }\r\n                }\r\n            #endif /* configUSE_QUEUE_SETS */\r\n\r\n            --cTxLock;\r\n        }\r\n\r\n        pxQueue->cTxLock = queueUNLOCKED;\r\n    }\r\n    taskEXIT_CRITICAL();\r\n\r\n    /* Do the same for the Rx lock. */\r\n    taskENTER_CRITICAL();\r\n    {\r\n        int8_t cRxLock = pxQueue->cRxLock;\r\n\r\n        while( cRxLock > queueLOCKED_UNMODIFIED )\r\n        {\r\n            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )\r\n            {\r\n                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )\r\n                {\r\n                    vTaskMissedYield();\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n\r\n                --cRxLock;\r\n            }\r\n            else\r\n            {\r\n                break;\r\n            }\r\n        }\r\n\r\n        pxQueue->cRxLock = queueUNLOCKED;\r\n    }\r\n    taskEXIT_CRITICAL();\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nstatic BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )\r\n{\r\n    BaseType_t xReturn;\r\n\r\n    taskENTER_CRITICAL();\r\n    {\r\n        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )\r\n        {\r\n            xReturn = pdTRUE;\r\n        }\r\n        else\r\n        {\r\n            xReturn = pdFALSE;\r\n        }\r\n    }\r\n    taskEXIT_CRITICAL();\r\n\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nBaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )\r\n{\r\n    BaseType_t xReturn;\r\n    Queue_t * const pxQueue = xQueue;\r\n\r\n    configASSERT( pxQueue );\r\n\r\n    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )\r\n    {\r\n        xReturn = pdTRUE;\r\n    }\r\n    else\r\n    {\r\n        xReturn = pdFALSE;\r\n    }\r\n\r\n    return xReturn;\r\n} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */\r\n/*-----------------------------------------------------------*/\r\n\r\nstatic BaseType_t prvIsQueueFull( const Queue_t * pxQueue )\r\n{\r\n    BaseType_t xReturn;\r\n\r\n    taskENTER_CRITICAL();\r\n    {\r\n        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )\r\n        {\r\n            xReturn = pdTRUE;\r\n        }\r\n        else\r\n        {\r\n            xReturn = pdFALSE;\r\n        }\r\n    }\r\n    taskEXIT_CRITICAL();\r\n\r\n    return xReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nBaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )\r\n{\r\n    BaseType_t xReturn;\r\n    Queue_t * const pxQueue = xQueue;\r\n\r\n    configASSERT( pxQueue );\r\n\r\n    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )\r\n    {\r\n        xReturn = pdTRUE;\r\n    }\r\n    else\r\n    {\r\n        xReturn = pdFALSE;\r\n    }\r\n\r\n    return xReturn;\r\n} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_CO_ROUTINES == 1 )\r\n\r\n    BaseType_t xQueueCRSend( QueueHandle_t xQueue,\r\n                             const void * pvItemToQueue,\r\n                             TickType_t xTicksToWait )\r\n    {\r\n        BaseType_t xReturn;\r\n        Queue_t * const pxQueue = xQueue;\r\n\r\n        /* If the queue is already full we may have to block.  A critical section\r\n         * is required to prevent an interrupt removing something from the queue\r\n         * between the check to see if the queue is full and blocking on the queue. */\r\n        portDISABLE_INTERRUPTS();\r\n        {\r\n            if( prvIsQueueFull( pxQueue ) != pdFALSE )\r\n            {\r\n                /* The queue is full - do we want to block or just leave without\r\n                 * posting? */\r\n                if( xTicksToWait > ( TickType_t ) 0 )\r\n                {\r\n                    /* As this is called from a coroutine we cannot block directly, but\r\n                     * return indicating that we need to block. */\r\n                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );\r\n                    portENABLE_INTERRUPTS();\r\n                    return errQUEUE_BLOCKED;\r\n                }\r\n                else\r\n                {\r\n                    portENABLE_INTERRUPTS();\r\n                    return errQUEUE_FULL;\r\n                }\r\n            }\r\n        }\r\n        portENABLE_INTERRUPTS();\r\n\r\n        portDISABLE_INTERRUPTS();\r\n        {\r\n            if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )\r\n            {\r\n                /* There is room in the queue, copy the data into the queue. */\r\n                prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );\r\n                xReturn = pdPASS;\r\n\r\n                /* Were any co-routines waiting for data to become available? */\r\n                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )\r\n                {\r\n                    /* In this instance the co-routine could be placed directly\r\n                     * into the ready list as we are within a critical section.\r\n                     * Instead the same pending ready list mechanism is used as if\r\n                     * the event were caused from within an interrupt. */\r\n                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )\r\n                    {\r\n                        /* The co-routine waiting has a higher priority so record\r\n                         * that a yield might be appropriate. */\r\n                        xReturn = errQUEUE_YIELD;\r\n                    }\r\n                    else\r\n                    {\r\n                        mtCOVERAGE_TEST_MARKER();\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                xReturn = errQUEUE_FULL;\r\n            }\r\n        }\r\n        portENABLE_INTERRUPTS();\r\n\r\n        return xReturn;\r\n    }\r\n\r\n#endif /* configUSE_CO_ROUTINES */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_CO_ROUTINES == 1 )\r\n\r\n    BaseType_t xQueueCRReceive( QueueHandle_t xQueue,\r\n                                void * pvBuffer,\r\n                                TickType_t xTicksToWait )\r\n    {\r\n        BaseType_t xReturn;\r\n        Queue_t * const pxQueue = xQueue;\r\n\r\n        /* If the queue is already empty we may have to block.  A critical section\r\n         * is required to prevent an interrupt adding something to the queue\r\n         * between the check to see if the queue is empty and blocking on the queue. */\r\n        portDISABLE_INTERRUPTS();\r\n        {\r\n            if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )\r\n            {\r\n                /* There are no messages in the queue, do we want to block or just\r\n                 * leave with nothing? */\r\n                if( xTicksToWait > ( TickType_t ) 0 )\r\n                {\r\n                    /* As this is a co-routine we cannot block directly, but return\r\n                     * indicating that we need to block. */\r\n                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );\r\n                    portENABLE_INTERRUPTS();\r\n                    return errQUEUE_BLOCKED;\r\n                }\r\n                else\r\n                {\r\n                    portENABLE_INTERRUPTS();\r\n                    return errQUEUE_FULL;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n        portENABLE_INTERRUPTS();\r\n\r\n        portDISABLE_INTERRUPTS();\r\n        {\r\n            if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )\r\n            {\r\n                /* Data is available from the queue. */\r\n                pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;\r\n\r\n                if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )\r\n                {\r\n                    pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n\r\n                --( pxQueue->uxMessagesWaiting );\r\n                ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );\r\n\r\n                xReturn = pdPASS;\r\n\r\n                /* Were any co-routines waiting for space to become available? */\r\n                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )\r\n                {\r\n                    /* In this instance the co-routine could be placed directly\r\n                     * into the ready list as we are within a critical section.\r\n                     * Instead the same pending ready list mechanism is used as if\r\n                     * the event were caused from within an interrupt. */\r\n                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )\r\n                    {\r\n                        xReturn = errQUEUE_YIELD;\r\n                    }\r\n                    else\r\n                    {\r\n                        mtCOVERAGE_TEST_MARKER();\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                xReturn = pdFAIL;\r\n            }\r\n        }\r\n        portENABLE_INTERRUPTS();\r\n\r\n        return xReturn;\r\n    }\r\n\r\n#endif /* configUSE_CO_ROUTINES */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_CO_ROUTINES == 1 )\r\n\r\n    BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue,\r\n                                    const void * pvItemToQueue,\r\n                                    BaseType_t xCoRoutinePreviouslyWoken )\r\n    {\r\n        Queue_t * const pxQueue = xQueue;\r\n\r\n        /* Cannot block within an ISR so if there is no space on the queue then\r\n         * exit without doing anything. */\r\n        if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )\r\n        {\r\n            prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );\r\n\r\n            /* We only want to wake one co-routine per ISR, so check that a\r\n             * co-routine has not already been woken. */\r\n            if( xCoRoutinePreviouslyWoken == pdFALSE )\r\n            {\r\n                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )\r\n                {\r\n                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )\r\n                    {\r\n                        return pdTRUE;\r\n                    }\r\n                    else\r\n                    {\r\n                        mtCOVERAGE_TEST_MARKER();\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n\r\n        return xCoRoutinePreviouslyWoken;\r\n    }\r\n\r\n#endif /* configUSE_CO_ROUTINES */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_CO_ROUTINES == 1 )\r\n\r\n    BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue,\r\n                                       void * pvBuffer,\r\n                                       BaseType_t * pxCoRoutineWoken )\r\n    {\r\n        BaseType_t xReturn;\r\n        Queue_t * const pxQueue = xQueue;\r\n\r\n        /* We cannot block from an ISR, so check there is data available. If\r\n         * not then just leave without doing anything. */\r\n        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )\r\n        {\r\n            /* Copy the data from the queue. */\r\n            pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;\r\n\r\n            if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )\r\n            {\r\n                pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n\r\n            --( pxQueue->uxMessagesWaiting );\r\n            ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );\r\n\r\n            if( ( *pxCoRoutineWoken ) == pdFALSE )\r\n            {\r\n                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )\r\n                {\r\n                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )\r\n                    {\r\n                        *pxCoRoutineWoken = pdTRUE;\r\n                    }\r\n                    else\r\n                    {\r\n                        mtCOVERAGE_TEST_MARKER();\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n\r\n            xReturn = pdPASS;\r\n        }\r\n        else\r\n        {\r\n            xReturn = pdFAIL;\r\n        }\r\n\r\n        return xReturn;\r\n    }\r\n\r\n#endif /* configUSE_CO_ROUTINES */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configQUEUE_REGISTRY_SIZE > 0 )\r\n\r\n    void vQueueAddToRegistry( QueueHandle_t xQueue,\r\n                              const char * pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\r\n    {\r\n        UBaseType_t ux;\r\n\r\n        /* See if there is an empty space in the registry.  A NULL name denotes\r\n         * a free slot. */\r\n        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )\r\n        {\r\n            if( xQueueRegistry[ ux ].pcQueueName == NULL )\r\n            {\r\n                /* Store the information on this queue. */\r\n                xQueueRegistry[ ux ].pcQueueName = pcQueueName;\r\n                xQueueRegistry[ ux ].xHandle = xQueue;\r\n\r\n                traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );\r\n                break;\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n    }\r\n\r\n#endif /* configQUEUE_REGISTRY_SIZE */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configQUEUE_REGISTRY_SIZE > 0 )\r\n\r\n    const char * pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\r\n    {\r\n        UBaseType_t ux;\r\n        const char * pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\r\n\r\n        /* Note there is nothing here to protect against another task adding or\r\n         * removing entries from the registry while it is being searched. */\r\n\r\n        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )\r\n        {\r\n            if( xQueueRegistry[ ux ].xHandle == xQueue )\r\n            {\r\n                pcReturn = xQueueRegistry[ ux ].pcQueueName;\r\n                break;\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n\r\n        return pcReturn;\r\n    } /*lint !e818 xQueue cannot be a pointer to const because it is a typedef. */\r\n\r\n#endif /* configQUEUE_REGISTRY_SIZE */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configQUEUE_REGISTRY_SIZE > 0 )\r\n\r\n    void vQueueUnregisterQueue( QueueHandle_t xQueue )\r\n    {\r\n        UBaseType_t ux;\r\n\r\n        /* See if the handle of the queue being unregistered in actually in the\r\n         * registry. */\r\n        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )\r\n        {\r\n            if( xQueueRegistry[ ux ].xHandle == xQueue )\r\n            {\r\n                /* Set the name to NULL to show that this slot if free again. */\r\n                xQueueRegistry[ ux ].pcQueueName = NULL;\r\n\r\n                /* Set the handle to NULL to ensure the same queue handle cannot\r\n                 * appear in the registry twice if it is added, removed, then\r\n                 * added again. */\r\n                xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;\r\n                break;\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n    } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */\r\n\r\n#endif /* configQUEUE_REGISTRY_SIZE */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_TIMERS == 1 )\r\n\r\n    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,\r\n                                         TickType_t xTicksToWait,\r\n                                         const BaseType_t xWaitIndefinitely )\r\n    {\r\n        Queue_t * const pxQueue = xQueue;\r\n\r\n        /* This function should not be called by application code hence the\r\n         * 'Restricted' in its name.  It is not part of the public API.  It is\r\n         * designed for use by kernel code, and has special calling requirements.\r\n         * It can result in vListInsert() being called on a list that can only\r\n         * possibly ever have one item in it, so the list will be fast, but even\r\n         * so it should be called with the scheduler locked and not from a critical\r\n         * section. */\r\n\r\n        /* Only do anything if there are no messages in the queue.  This function\r\n         *  will not actually cause the task to block, just place it on a blocked\r\n         *  list.  It will not block until the scheduler is unlocked - at which\r\n         *  time a yield will be performed.  If an item is added to the queue while\r\n         *  the queue is locked, and the calling task blocks on the queue, then the\r\n         *  calling task will be immediately unblocked when the queue is unlocked. */\r\n        prvLockQueue( pxQueue );\r\n\r\n        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )\r\n        {\r\n            /* There is nothing in the queue, block for the specified period. */\r\n            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n\r\n        prvUnlockQueue( pxQueue );\r\n    }\r\n\r\n#endif /* configUSE_TIMERS */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( ( configUSE_QUEUE_SETS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )\r\n\r\n    QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength )\r\n    {\r\n        QueueSetHandle_t pxQueue;\r\n\r\n        pxQueue = xQueueGenericCreate( uxEventQueueLength, ( UBaseType_t ) sizeof( Queue_t * ), queueQUEUE_TYPE_SET );\r\n\r\n        return pxQueue;\r\n    }\r\n\r\n#endif /* configUSE_QUEUE_SETS */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_QUEUE_SETS == 1 )\r\n\r\n    BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore,\r\n                               QueueSetHandle_t xQueueSet )\r\n    {\r\n        BaseType_t xReturn;\r\n\r\n        taskENTER_CRITICAL();\r\n        {\r\n            if( ( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer != NULL )\r\n            {\r\n                /* Cannot add a queue/semaphore to more than one queue set. */\r\n                xReturn = pdFAIL;\r\n            }\r\n            else if( ( ( Queue_t * ) xQueueOrSemaphore )->uxMessagesWaiting != ( UBaseType_t ) 0 )\r\n            {\r\n                /* Cannot add a queue/semaphore to a queue set if there are already\r\n                 * items in the queue/semaphore. */\r\n                xReturn = pdFAIL;\r\n            }\r\n            else\r\n            {\r\n                ( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer = xQueueSet;\r\n                xReturn = pdPASS;\r\n            }\r\n        }\r\n        taskEXIT_CRITICAL();\r\n\r\n        return xReturn;\r\n    }\r\n\r\n#endif /* configUSE_QUEUE_SETS */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_QUEUE_SETS == 1 )\r\n\r\n    BaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore,\r\n                                    QueueSetHandle_t xQueueSet )\r\n    {\r\n        BaseType_t xReturn;\r\n        Queue_t * const pxQueueOrSemaphore = ( Queue_t * ) xQueueOrSemaphore;\r\n\r\n        if( pxQueueOrSemaphore->pxQueueSetContainer != xQueueSet )\r\n        {\r\n            /* The queue was not a member of the set. */\r\n            xReturn = pdFAIL;\r\n        }\r\n        else if( pxQueueOrSemaphore->uxMessagesWaiting != ( UBaseType_t ) 0 )\r\n        {\r\n            /* It is dangerous to remove a queue from a set when the queue is\r\n             * not empty because the queue set will still hold pending events for\r\n             * the queue. */\r\n            xReturn = pdFAIL;\r\n        }\r\n        else\r\n        {\r\n            taskENTER_CRITICAL();\r\n            {\r\n                /* The queue is no longer contained in the set. */\r\n                pxQueueOrSemaphore->pxQueueSetContainer = NULL;\r\n            }\r\n            taskEXIT_CRITICAL();\r\n            xReturn = pdPASS;\r\n        }\r\n\r\n        return xReturn;\r\n    } /*lint !e818 xQueueSet could not be declared as pointing to const as it is a typedef. */\r\n\r\n#endif /* configUSE_QUEUE_SETS */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_QUEUE_SETS == 1 )\r\n\r\n    QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet,\r\n                                                TickType_t const xTicksToWait )\r\n    {\r\n        QueueSetMemberHandle_t xReturn = NULL;\r\n\r\n        ( void ) xQueueReceive( ( QueueHandle_t ) xQueueSet, &xReturn, xTicksToWait ); /*lint !e961 Casting from one typedef to another is not redundant. */\r\n        return xReturn;\r\n    }\r\n\r\n#endif /* configUSE_QUEUE_SETS */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_QUEUE_SETS == 1 )\r\n\r\n    QueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet )\r\n    {\r\n        QueueSetMemberHandle_t xReturn = NULL;\r\n\r\n        ( void ) xQueueReceiveFromISR( ( QueueHandle_t ) xQueueSet, &xReturn, NULL ); /*lint !e961 Casting from one typedef to another is not redundant. */\r\n        return xReturn;\r\n    }\r\n\r\n#endif /* configUSE_QUEUE_SETS */\r\n/*-----------------------------------------------------------*/\r\n\r\n#if ( configUSE_QUEUE_SETS == 1 )\r\n\r\n    static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue )\r\n    {\r\n        Queue_t * pxQueueSetContainer = pxQueue->pxQueueSetContainer;\r\n        BaseType_t xReturn = pdFALSE;\r\n\r\n        /* This function must be called form a critical section. */\r\n\r\n        configASSERT( pxQueueSetContainer );\r\n        configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );\r\n\r\n        if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )\r\n        {\r\n            const int8_t cTxLock = pxQueueSetContainer->cTxLock;\r\n\r\n            traceQUEUE_SET_SEND( pxQueueSetContainer );\r\n\r\n            /* The data copied is the handle of the queue that contains data. */\r\n            xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, queueSEND_TO_BACK );\r\n\r\n            if( cTxLock == queueUNLOCKED )\r\n            {\r\n                if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )\r\n                {\r\n                    if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )\r\n                    {\r\n                        /* The task waiting has a higher priority. */\r\n                        xReturn = pdTRUE;\r\n                    }\r\n                    else\r\n                    {\r\n                        mtCOVERAGE_TEST_MARKER();\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                configASSERT( cTxLock != queueINT8_MAX );\r\n\r\n                pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );\r\n            }\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n\r\n        return xReturn;\r\n    }\r\n\r\n#endif /* configUSE_QUEUE_SETS */\r\n"], "filenames": ["queue.c"], "buggy_code_start_loc": [398], "buggy_code_end_loc": [398], "fixing_code_start_loc": [399], "fixing_code_end_loc": [402], "type": "CWE-190", "message": "The kernel in Amazon Web Services FreeRTOS before 10.4.3 has an integer overflow in queue.c for queue creation.", "other": {"cve": {"id": "CVE-2021-31571", "sourceIdentifier": "cve@mitre.org", "published": "2021-04-22T18:15:08.520", "lastModified": "2021-06-02T18:34:27.147", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The kernel in Amazon Web Services FreeRTOS before 10.4.3 has an integer overflow in queue.c for queue creation."}, {"lang": "es", "value": "El kernel en Amazon Web Services FreeRTOS versiones anteriores a 10.4.3, presenta un desbordamiento de enteros en el archivo queue.c para una creaci\u00f3n de cola"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:amazon:freertos:*:*:*:*:*:*:*:*", "versionEndExcluding": "10.4.3", "matchCriteriaId": "6F5312AF-71BB-4289-BAB4-CE5931098CCD"}]}]}], "references": [{"url": "https://github.com/FreeRTOS/FreeRTOS-Kernel/commit/47338393f1f79558f6144213409f09f81d7c4837", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FreeRTOS/FreeRTOS-Kernel/commit/47338393f1f79558f6144213409f09f81d7c4837"}}