{"buggy_code": ["/* Library for accessing X3F Files\n----------------------------------------------------------------\nBSD-style License\n----------------------------------------------------------------\n\n* Copyright (c) 2010, Roland Karlsson (roland@proxel.se)\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without\n* modification, are permitted provided that the following conditions are met:\n*     * Redistributions of source code must retain the above copyright\n*       notice, this list of conditions and the following disclaimer.\n*     * Redistributions in binary form must reproduce the above copyright\n*       notice, this list of conditions and the following disclaimer in the\n*       documentation and/or other materials provided with the distribution.\n*     * Neither the name of the organization nor the\n*       names of its contributors may be used to endorse or promote products\n*       derived from this software without specific prior written permission.\n*\n* THIS SOFTWARE IS PROVIDED BY ROLAND KARLSSON ''AS IS'' AND ANY\n* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n* DISCLAIMED. IN NO EVENT SHALL ROLAND KARLSSON BE LIABLE FOR ANY\n* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n*/\n\n#include \"../../internal/libraw_cxx_defs.h\"\n\n#if defined __sun && defined DS\n#undef DS\n#endif\n#ifdef ID\n#undef ID /* used in x3f utils */\n#endif\n\n#include \"../../internal/x3f_tools.h\"\n\n/* extern */ int legacy_offset = 0;\n/* extern */ bool_t auto_legacy_offset = 1;\n\n/* --------------------------------------------------------------------- */\n/* Reading and writing - assuming little endian in the file              */\n/* --------------------------------------------------------------------- */\n\nstatic int x3f_get1(LibRaw_abstract_datastream *f)\n{\n  /* Little endian file */\n  return f->get_char();\n}\n\nstatic int x3f_sget2(uchar *s) { return s[0] | s[1] << 8; }\n\nstatic int x3f_get2(LibRaw_abstract_datastream *f)\n{\n  uchar str[2] = {0xff, 0xff};\n  f->read(str, 1, 2);\n  return x3f_sget2(str);\n}\n\nunsigned x3f_sget4(uchar *s)\n{\n  return s[0] | s[1] << 8 | s[2] << 16 | s[3] << 24;\n}\n\nunsigned x3f_get4(LibRaw_abstract_datastream *f)\n{\n  uchar str[4] = {0xff, 0xff, 0xff, 0xff};\n  f->read(str, 1, 4);\n  return x3f_sget4(str);\n}\n\n#define FREE(P)                                                                \\\n  do                                                                           \\\n  {                                                                            \\\n    free(P);                                                                   \\\n    (P) = NULL;                                                                \\\n  } while (0)\n\n#define PUT_GET_N(_buffer, _size, _file, _func)                                \\\n  do                                                                           \\\n  {                                                                            \\\n    int _left = _size;                                                         \\\n    while (_left != 0)                                                         \\\n    {                                                                          \\\n      int _cur = _file->_func(_buffer, 1, _left);                              \\\n      if (_cur == 0)                                                           \\\n      {                                                                        \\\n        throw LIBRAW_EXCEPTION_IO_CORRUPT;                                     \\\n      }                                                                        \\\n      _left -= _cur;                                                           \\\n    }                                                                          \\\n  } while (0)\n\n#define GET1(_v)                                                               \\\n  do                                                                           \\\n  {                                                                            \\\n    (_v) = x3f_get1(I->input.file);                                            \\\n  } while (0)\n#define GET2(_v)                                                               \\\n  do                                                                           \\\n  {                                                                            \\\n    (_v) = x3f_get2(I->input.file);                                            \\\n  } while (0)\n#define GET4(_v)                                                               \\\n  do                                                                           \\\n  {                                                                            \\\n    (_v) = x3f_get4(I->input.file);                                            \\\n  } while (0)\n\n#define GET4F(_v)                                                              \\\n  do                                                                           \\\n  {                                                                            \\\n    union {                                                                    \\\n      int32_t i;                                                               \\\n      float f;                                                                 \\\n    } _tmp;                                                                    \\\n    _tmp.i = x3f_get4(I->input.file);                                          \\\n    (_v) = _tmp.f;                                                             \\\n  } while (0)\n\n#define GETN(_v, _s) PUT_GET_N(_v, _s, I->input.file, read)\n\n#define GET_TABLE(_T, _GETX, _NUM, _TYPE)                                      \\\n  do                                                                           \\\n  {                                                                            \\\n    int _i;                                                                    \\\n    (_T).size = (_NUM);                                                        \\\n    (_T).element =                                                             \\\n        (_TYPE *)realloc((_T).element, (_NUM) * sizeof((_T).element[0]));      \\\n    for (_i = 0; _i < (_T).size; _i++)                                         \\\n      _GETX((_T).element[_i]);                                                 \\\n  } while (0)\n\n#define GET_PROPERTY_TABLE(_T, _NUM)                                           \\\n  do                                                                           \\\n  {                                                                            \\\n    int _i;                                                                    \\\n    (_T).size = (_NUM);                                                        \\\n    (_T).element = (x3f_property_t *)realloc(                                  \\\n        (_T).element, (_NUM) * sizeof((_T).element[0]));                       \\\n    for (_i = 0; _i < (_T).size; _i++)                                         \\\n    {                                                                          \\\n      GET4((_T).element[_i].name_offset);                                      \\\n      GET4((_T).element[_i].value_offset);                                     \\\n    }                                                                          \\\n  } while (0)\n\n#define GET_TRUE_HUFF_TABLE(_T)                                                \\\n  do                                                                           \\\n  {                                                                            \\\n    int _i;                                                                    \\\n    (_T).element = NULL;                                                       \\\n    for (_i = 0;; _i++)                                                        \\\n    {                                                                          \\\n      (_T).size = _i + 1;                                                      \\\n      (_T).element = (x3f_true_huffman_element_t *)realloc(                    \\\n          (_T).element, (_i + 1) * sizeof((_T).element[0]));                   \\\n      GET1((_T).element[_i].code_size);                                        \\\n      GET1((_T).element[_i].code);                                             \\\n      if ((_T).element[_i].code_size == 0)                                     \\\n        break;                                                                 \\\n    }                                                                          \\\n  } while (0)\n\n/* --------------------------------------------------------------------- */\n/* Allocating Huffman tree help data                                   */\n/* --------------------------------------------------------------------- */\n\nstatic void cleanup_huffman_tree(x3f_hufftree_t *HTP) { free(HTP->nodes); }\n\nstatic void new_huffman_tree(x3f_hufftree_t *HTP, int bits)\n{\n  int leaves = 1 << bits;\n\n  HTP->free_node_index = 0;\n  HTP->total_node_index = HUF_TREE_MAX_NODES(leaves);\n  HTP->nodes = (x3f_huffnode_t *)calloc(1, HUF_TREE_MAX_NODES(leaves) *\n                                               sizeof(x3f_huffnode_t));\n}\n\n/* --------------------------------------------------------------------- */\n/* Allocating TRUE engine RAW help data                                  */\n/* --------------------------------------------------------------------- */\n\nstatic void cleanup_true(x3f_true_t **TRUP)\n{\n  x3f_true_t *TRU = *TRUP;\n\n  if (TRU == NULL)\n    return;\n\n  FREE(TRU->table.element);\n  FREE(TRU->plane_size.element);\n  cleanup_huffman_tree(&TRU->tree);\n  FREE(TRU->x3rgb16.buf);\n\n  FREE(TRU);\n\n  *TRUP = NULL;\n}\n\nstatic x3f_true_t *new_true(x3f_true_t **TRUP)\n{\n  x3f_true_t *TRU = (x3f_true_t *)calloc(1, sizeof(x3f_true_t));\n\n  cleanup_true(TRUP);\n\n  TRU->table.size = 0;\n  TRU->table.element = NULL;\n  TRU->plane_size.size = 0;\n  TRU->plane_size.element = NULL;\n  TRU->tree.nodes = NULL;\n  TRU->x3rgb16.data = NULL;\n  TRU->x3rgb16.buf = NULL;\n\n  *TRUP = TRU;\n\n  return TRU;\n}\n\nstatic void cleanup_quattro(x3f_quattro_t **QP)\n{\n  x3f_quattro_t *Q = *QP;\n\n  if (Q == NULL)\n    return;\n\n  FREE(Q->top16.buf);\n  FREE(Q);\n\n  *QP = NULL;\n}\n\nstatic x3f_quattro_t *new_quattro(x3f_quattro_t **QP)\n{\n  x3f_quattro_t *Q = (x3f_quattro_t *)calloc(1, sizeof(x3f_quattro_t));\n  int i;\n\n  cleanup_quattro(QP);\n\n  for (i = 0; i < TRUE_PLANES; i++)\n  {\n    Q->plane[i].columns = 0;\n    Q->plane[i].rows = 0;\n  }\n\n  Q->unknown = 0;\n\n  Q->top16.data = NULL;\n  Q->top16.buf = NULL;\n\n  *QP = Q;\n\n  return Q;\n}\n\n/* --------------------------------------------------------------------- */\n/* Allocating Huffman engine help data                                   */\n/* --------------------------------------------------------------------- */\n\nstatic void cleanup_huffman(x3f_huffman_t **HUFP)\n{\n  x3f_huffman_t *HUF = *HUFP;\n\n  if (HUF == NULL)\n    return;\n\n  FREE(HUF->mapping.element);\n  FREE(HUF->table.element);\n  cleanup_huffman_tree(&HUF->tree);\n  FREE(HUF->row_offsets.element);\n  FREE(HUF->rgb8.buf);\n  FREE(HUF->x3rgb16.buf);\n  FREE(HUF);\n\n  *HUFP = NULL;\n}\n\nstatic x3f_huffman_t *new_huffman(x3f_huffman_t **HUFP)\n{\n  x3f_huffman_t *HUF = (x3f_huffman_t *)calloc(1, sizeof(x3f_huffman_t));\n\n  cleanup_huffman(HUFP);\n\n  /* Set all not read data block pointers to NULL */\n  HUF->mapping.size = 0;\n  HUF->mapping.element = NULL;\n  HUF->table.size = 0;\n  HUF->table.element = NULL;\n  HUF->tree.nodes = NULL;\n  HUF->row_offsets.size = 0;\n  HUF->row_offsets.element = NULL;\n  HUF->rgb8.data = NULL;\n  HUF->rgb8.buf = NULL;\n  HUF->x3rgb16.data = NULL;\n  HUF->x3rgb16.buf = NULL;\n\n  *HUFP = HUF;\n\n  return HUF;\n}\n\n/* --------------------------------------------------------------------- */\n/* Creating a new x3f structure from file                                */\n/* --------------------------------------------------------------------- */\n\n/* extern */ x3f_t *x3f_new_from_file(LibRaw_abstract_datastream *infile)\n{\n  if (!infile)\n    return NULL;\n  INT64 fsize = infile->size();\n  x3f_t *x3f = (x3f_t *)calloc(1, sizeof(x3f_t));\n  if (!x3f)\n    throw LIBRAW_EXCEPTION_ALLOC;\n  try\n  {\n    x3f_info_t *I = NULL;\n    x3f_header_t *H = NULL;\n    x3f_directory_section_t *DS = NULL;\n    int i, d;\n\n    I = &x3f->info;\n    I->error = NULL;\n    I->input.file = infile;\n    I->output.file = NULL;\n\n    /* Read file header */\n    H = &x3f->header;\n    infile->seek(0, SEEK_SET);\n    GET4(H->identifier);\n\n    if (H->identifier != X3F_FOVb)\n    {\n      free(x3f);\n      return NULL;\n    }\n\n    GET4(H->version);\n    GETN(H->unique_identifier, SIZE_UNIQUE_IDENTIFIER);\n    /* TODO: the meaning of the rest of the header for version >= 4.0 (Quattro)\n     * is unknown */\n    if (H->version < X3F_VERSION_4_0)\n    {\n      GET4(H->mark_bits);\n      GET4(H->columns);\n      GET4(H->rows);\n      GET4(H->rotation);\n      if (H->version >= X3F_VERSION_2_1)\n      {\n        int num_ext_data =\n            H->version >= X3F_VERSION_3_0 ? NUM_EXT_DATA_3_0 : NUM_EXT_DATA_2_1;\n\n        GETN(H->white_balance, SIZE_WHITE_BALANCE);\n        if (H->version >= X3F_VERSION_2_3)\n          GETN(H->color_mode, SIZE_COLOR_MODE);\n        GETN(H->extended_types, num_ext_data);\n        for (i = 0; i < num_ext_data; i++)\n          GET4F(H->extended_data[i]);\n      }\n    }\n\n    /* Go to the beginning of the directory */\n    infile->seek(-4, SEEK_END);\n    infile->seek(x3f_get4(infile), SEEK_SET);\n\n    /* Read the directory header */\n    DS = &x3f->directory_section;\n    GET4(DS->identifier);\n    GET4(DS->version);\n    GET4(DS->num_directory_entries);\n\n    if (DS->num_directory_entries > 50)\n      goto _err; // too much direntries, most likely broken file\n\n    if (DS->num_directory_entries > 0)\n    {\n      size_t size = DS->num_directory_entries * sizeof(x3f_directory_entry_t);\n      DS->directory_entry = (x3f_directory_entry_t *)calloc(1, size);\n    }\n\n    /* Traverse the directory */\n    for (d = 0; d < DS->num_directory_entries; d++)\n    {\n      x3f_directory_entry_t *DE = &DS->directory_entry[d];\n      x3f_directory_entry_header_t *DEH = &DE->header;\n      uint32_t save_dir_pos;\n\n      /* Read the directory entry info */\n      GET4(DE->input.offset);\n      GET4(DE->input.size);\n      if (DE->input.offset + DE->input.size > fsize * 2)\n        goto _err;\n\n      DE->output.offset = 0;\n      DE->output.size = 0;\n\n      GET4(DE->type);\n\n      /* Save current pos and go to the entry */\n      save_dir_pos = infile->tell();\n      infile->seek(DE->input.offset, SEEK_SET);\n\n      /* Read the type independent part of the entry header */\n      DEH = &DE->header;\n      GET4(DEH->identifier);\n      GET4(DEH->version);\n\n      /* NOTE - the tests below could be made on DE->type instead */\n\n      if (DEH->identifier == X3F_SECp)\n      {\n        x3f_property_list_t *PL = &DEH->data_subsection.property_list;\n        if (!PL)\n          goto _err;\n        /* Read the property part of the header */\n        GET4(PL->num_properties);\n        GET4(PL->character_format);\n        GET4(PL->reserved);\n        GET4(PL->total_length);\n\n        /* Set all not read data block pointers to NULL */\n        PL->data = NULL;\n        PL->data_size = 0;\n      }\n\n      if (DEH->identifier == X3F_SECi)\n      {\n        x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n        if (!ID)\n          goto _err;\n        /* Read the image part of the header */\n        GET4(ID->type);\n        GET4(ID->format);\n        ID->type_format = (ID->type << 16) + (ID->format);\n        GET4(ID->columns);\n        GET4(ID->rows);\n        GET4(ID->row_stride);\n\n        /* Set all not read data block pointers to NULL */\n        ID->huffman = NULL;\n\n        ID->data = NULL;\n        ID->data_size = 0;\n      }\n\n      if (DEH->identifier == X3F_SECc)\n      {\n        x3f_camf_t *CAMF = &DEH->data_subsection.camf;\n        if (!CAMF)\n          goto _err;\n        /* Read the CAMF part of the header */\n        GET4(CAMF->type);\n        GET4(CAMF->tN.val0);\n        GET4(CAMF->tN.val1);\n        GET4(CAMF->tN.val2);\n        GET4(CAMF->tN.val3);\n\n        /* Set all not read data block pointers to NULL */\n        CAMF->data = NULL;\n        CAMF->data_size = 0;\n\n        /* Set all not allocated help pointers to NULL */\n        CAMF->table.element = NULL;\n        CAMF->table.size = 0;\n        CAMF->tree.nodes = NULL;\n        CAMF->decoded_data = NULL;\n        CAMF->decoded_data_size = 0;\n        CAMF->entry_table.element = NULL;\n        CAMF->entry_table.size = 0;\n      }\n\n      /* Reset the file pointer back to the directory */\n      infile->seek(save_dir_pos, SEEK_SET);\n    }\n\n    return x3f;\n  _err:\n    if (x3f)\n    {\n      DS = &x3f->directory_section;\n      if (DS && DS->directory_entry)\n        free(DS->directory_entry);\n      free(x3f);\n    }\n    return NULL;\n  }\n  catch (...)\n  {\n    x3f_directory_section_t *DS = &x3f->directory_section;\n    if (DS && DS->directory_entry)\n      free(DS->directory_entry);\n    free(x3f);\n    return NULL;\n  }\n}\n\n/* --------------------------------------------------------------------- */\n/* Clean up an x3f structure                                             */\n/* --------------------------------------------------------------------- */\n\nstatic void free_camf_entry(camf_entry_t *entry)\n{\n  FREE(entry->property_name);\n  FREE(entry->property_value);\n  FREE(entry->matrix_decoded);\n  FREE(entry->matrix_dim_entry);\n}\n\n/* extern */ x3f_return_t x3f_delete(x3f_t *x3f)\n{\n  x3f_directory_section_t *DS;\n  int d;\n\n  if (x3f == NULL)\n    return X3F_ARGUMENT_ERROR;\n\n  DS = &x3f->directory_section;\n  if (DS->num_directory_entries > 50)\n    return X3F_ARGUMENT_ERROR;\n\n  for (d = 0; d < DS->num_directory_entries; d++)\n  {\n    x3f_directory_entry_t *DE = &DS->directory_entry[d];\n    x3f_directory_entry_header_t *DEH = &DE->header;\n    if (DEH->identifier == X3F_SECp)\n    {\n      x3f_property_list_t *PL = &DEH->data_subsection.property_list;\n      if (PL)\n      {\n        int i;\n      }\n      FREE(PL->property_table.element);\n      FREE(PL->data);\n    }\n\n    if (DEH->identifier == X3F_SECi)\n    {\n      x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\n      if (ID)\n      {\n        cleanup_huffman(&ID->huffman);\n        cleanup_true(&ID->tru);\n        cleanup_quattro(&ID->quattro);\n        FREE(ID->data);\n      }\n    }\n\n    if (DEH->identifier == X3F_SECc)\n    {\n      x3f_camf_t *CAMF = &DEH->data_subsection.camf;\n      int i;\n      if (CAMF)\n      {\n        FREE(CAMF->data);\n        FREE(CAMF->table.element);\n        cleanup_huffman_tree(&CAMF->tree);\n        FREE(CAMF->decoded_data);\n        for (i = 0; i < CAMF->entry_table.size; i++)\n        {\n          free_camf_entry(&CAMF->entry_table.element[i]);\n        }\n      }\n      FREE(CAMF->entry_table.element);\n    }\n  }\n\n  FREE(DS->directory_entry);\n  FREE(x3f);\n\n  return X3F_OK;\n}\n\n/* --------------------------------------------------------------------- */\n/* Getting a reference to a directory entry                              */\n/* --------------------------------------------------------------------- */\n\n/* TODO: all those only get the first instance */\n\nstatic x3f_directory_entry_t *x3f_get(x3f_t *x3f, uint32_t type,\n                                      uint32_t image_type)\n{\n  x3f_directory_section_t *DS;\n  int d;\n\n  if (x3f == NULL)\n    return NULL;\n\n  DS = &x3f->directory_section;\n\n  for (d = 0; d < DS->num_directory_entries; d++)\n  {\n    x3f_directory_entry_t *DE = &DS->directory_entry[d];\n    x3f_directory_entry_header_t *DEH = &DE->header;\n\n    if (DEH->identifier == type)\n    {\n      switch (DEH->identifier)\n      {\n      case X3F_SECi:\n      {\n        x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\n        if (ID->type_format == image_type)\n          return DE;\n      }\n      break;\n      default:\n        return DE;\n      }\n    }\n  }\n\n  return NULL;\n}\n\n/* extern */ x3f_directory_entry_t *x3f_get_raw(x3f_t *x3f)\n{\n  x3f_directory_entry_t *DE;\n\n  if ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_HUFFMAN_X530)) != NULL)\n    return DE;\n\n  if ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_HUFFMAN_10BIT)) != NULL)\n    return DE;\n\n  if ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_TRUE)) != NULL)\n    return DE;\n\n  if ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_MERRILL)) != NULL)\n    return DE;\n\n  if ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_QUATTRO)) != NULL)\n    return DE;\n\n  if ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_SDQ)) != NULL)\n    return DE;\n\n  if ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_SDQH)) != NULL)\n    return DE;\n  if ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_SDQH2)) != NULL)\n    return DE;\n\n  return NULL;\n}\n\n/* extern */ x3f_directory_entry_t *x3f_get_thumb_plain(x3f_t *x3f)\n{\n  return x3f_get(x3f, X3F_SECi, X3F_IMAGE_THUMB_PLAIN);\n}\n\n/* extern */ x3f_directory_entry_t *x3f_get_thumb_huffman(x3f_t *x3f)\n{\n  return x3f_get(x3f, X3F_SECi, X3F_IMAGE_THUMB_HUFFMAN);\n}\n\n/* extern */ x3f_directory_entry_t *x3f_get_thumb_jpeg(x3f_t *x3f)\n{\n  return x3f_get(x3f, X3F_SECi, X3F_IMAGE_THUMB_JPEG);\n}\n\n/* extern */ x3f_directory_entry_t *x3f_get_camf(x3f_t *x3f)\n{\n  return x3f_get(x3f, X3F_SECc, 0);\n}\n\n/* extern */ x3f_directory_entry_t *x3f_get_prop(x3f_t *x3f)\n{\n  return x3f_get(x3f, X3F_SECp, 0);\n}\n\n/* For some obscure reason, the bit numbering is weird. It is\n   generally some kind of \"big endian\" style - e.g. the bit 7 is the\n   first in a byte and bit 31 first in a 4 byte int. For patterns in\n   the huffman pattern table, bit 27 is the first bit and bit 26 the\n   next one. */\n\n#define PATTERN_BIT_POS(_len, _bit) ((_len) - (_bit)-1)\n#define MEMORY_BIT_POS(_bit) PATTERN_BIT_POS(8, _bit)\n\n/* --------------------------------------------------------------------- */\n/* Huffman Decode                                                        */\n/* --------------------------------------------------------------------- */\n\n/* Make the huffman tree */\n\n#ifdef DBG_PRNT\nstatic char *display_code(int length, uint32_t code, char *buffer)\n{\n  int i;\n\n  for (i = 0; i < length; i++)\n  {\n    int pos = PATTERN_BIT_POS(length, i);\n    buffer[i] = ((code >> pos) & 1) == 0 ? '0' : '1';\n  }\n\n  buffer[i] = 0;\n\n  return buffer;\n}\n#endif\n\nstatic x3f_huffnode_t *new_node(x3f_hufftree_t *tree)\n{\n\tif (tree->free_node_index >= tree->total_node_index)\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n  x3f_huffnode_t *t = &tree->nodes[tree->free_node_index];\n\n  t->branch[0] = NULL;\n  t->branch[1] = NULL;\n  t->leaf = UNDEFINED_LEAF;\n\n  tree->free_node_index++;\n\n  return t;\n}\n\nstatic void add_code_to_tree(x3f_hufftree_t *tree, int length, uint32_t code,\n                             uint32_t value)\n{\n  int i;\n\n  x3f_huffnode_t *t = tree->nodes;\n\n  for (i = 0; i < length; i++)\n  {\n    int pos = PATTERN_BIT_POS(length, i);\n    int bit = (code >> pos) & 1;\n    x3f_huffnode_t *t_next = t->branch[bit];\n\n    if (t_next == NULL)\n      t_next = t->branch[bit] = new_node(tree);\n\n    t = t_next;\n  }\n\n  t->leaf = value;\n}\n\nstatic void populate_true_huffman_tree(x3f_hufftree_t *tree,\n                                       x3f_true_huffman_t *table)\n{\n  int i;\n\n  new_node(tree);\n\n  for (i = 0; i < table->size; i++)\n  {\n    x3f_true_huffman_element_t *element = &table->element[i];\n    uint32_t length = element->code_size;\n\n    if (length != 0)\n    {\n      /* add_code_to_tree wants the code right adjusted */\n      uint32_t code = ((element->code) >> (8 - length)) & 0xff;\n      uint32_t value = i;\n\n      add_code_to_tree(tree, length, code, value);\n\n#ifdef DBG_PRNT\n      {\n        char buffer[100];\n\n        x3f_printf(DEBUG, \"H %5d : %5x : %5d : %02x %08x (%08x) (%s)\\n\", i, i,\n                   value, length, code, value,\n                   display_code(length, code, buffer));\n      }\n#endif\n    }\n  }\n}\n\nstatic void populate_huffman_tree(x3f_hufftree_t *tree, x3f_table32_t *table,\n                                  x3f_table16_t *mapping)\n{\n  int i;\n\n  new_node(tree);\n\n  for (i = 0; i < table->size; i++)\n  {\n    uint32_t element = table->element[i];\n\n    if (element != 0)\n    {\n      uint32_t length = HUF_TREE_GET_LENGTH(element);\n      uint32_t code = HUF_TREE_GET_CODE(element);\n      uint32_t value;\n\n      /* If we have a valid mapping table - then the value from the\n         mapping table shall be used. Otherwise we use the current\n         index in the table as value. */\n      if (table->size == mapping->size)\n        value = mapping->element[i];\n      else\n        value = i;\n\n      add_code_to_tree(tree, length, code, value);\n\n#ifdef DBG_PRNT\n      {\n        char buffer[100];\n\n        x3f_printf(DEBUG, \"H %5d : %5x : %5d : %02x %08x (%08x) (%s)\\n\", i, i,\n                   value, length, code, element,\n                   display_code(length, code, buffer));\n      }\n#endif\n    }\n  }\n}\n\n#ifdef DBG_PRNT\nstatic void print_huffman_tree(x3f_huffnode_t *t, int length, uint32_t code)\n{\n  char buf1[100];\n  char buf2[100];\n\n  x3f_printf(DEBUG, \"%*s (%s,%s) %s (%s)\\n\", length,\n             length < 1 ? \"-\" : (code & 1) ? \"1\" : \"0\",\n             t->branch[0] == NULL ? \"-\" : \"0\", t->branch[1] == NULL ? \"-\" : \"1\",\n             t->leaf == UNDEFINED_LEAF ? \"-\"\n                                       : (sprintf(buf1, \"%x\", t->leaf), buf1),\n             display_code(length, code, buf2));\n\n  code = code << 1;\n  if (t->branch[0])\n    print_huffman_tree(t->branch[0], length + 1, code + 0);\n  if (t->branch[1])\n    print_huffman_tree(t->branch[1], length + 1, code + 1);\n}\n#endif\n\n/* Help machinery for reading bits in a memory */\n\ntypedef struct bit_state_s\n{\n  uint8_t *next_address;\n  uint8_t bit_offset;\n  uint8_t bits[8];\n} bit_state_t;\n\nstatic void set_bit_state(bit_state_t *BS, uint8_t *address)\n{\n  BS->next_address = address;\n  BS->bit_offset = 8;\n}\n\nstatic uint8_t get_bit(bit_state_t *BS)\n{\n  if (BS->bit_offset == 8)\n  {\n    uint8_t byte = *BS->next_address;\n    int i;\n\n    for (i = 7; i >= 0; i--)\n    {\n      BS->bits[i] = byte & 1;\n      byte = byte >> 1;\n    }\n    BS->next_address++;\n    BS->bit_offset = 0;\n  }\n\n  return BS->bits[BS->bit_offset++];\n}\n\n/* Decode use the TRUE algorithm */\n\nstatic int32_t get_true_diff(bit_state_t *BS, x3f_hufftree_t *HTP)\n{\n  int32_t diff;\n  x3f_huffnode_t *node = &HTP->nodes[0];\n  uint8_t bits;\n\n  while (node->branch[0] != NULL || node->branch[1] != NULL)\n  {\n    uint8_t bit = get_bit(BS);\n    x3f_huffnode_t *new_node = node->branch[bit];\n\n    node = new_node;\n    if (node == NULL)\n    {\n      /* TODO: Shouldn't this be treated as a fatal error? */\n      return 0;\n    }\n  }\n\n  bits = node->leaf;\n\n  if (bits == 0)\n    diff = 0;\n  else\n  {\n    uint8_t first_bit = get_bit(BS);\n    int i;\n\n    diff = first_bit;\n\n    for (i = 1; i < bits; i++)\n      diff = (diff << 1) + get_bit(BS);\n\n    if (first_bit == 0)\n      diff -= (1 << bits) - 1;\n  }\n\n  return diff;\n}\n\n/* This code (that decodes one of the X3F color planes, really is a\n   decoding of a compression algorithm suited for Bayer CFA data. In\n   Bayer CFA the data is divided into 2x2 squares that represents\n   (R,G1,G2,B) data. Those four positions are (in this compression)\n   treated as one data stream each, where you store the differences to\n   previous data in the stream. The reason for this is, of course,\n   that the date is more often than not near to the next data in a\n   stream that represents the same color. */\n\n/* TODO: write more about the compression */\n\nstatic void true_decode_one_color(x3f_image_data_t *ID, int color)\n{\n  x3f_true_t *TRU = ID->tru;\n  x3f_quattro_t *Q = ID->quattro;\n  uint32_t seed = TRU->seed[color]; /* TODO : Is this correct ? */\n  int row;\n\n  x3f_hufftree_t *tree = &TRU->tree;\n  bit_state_t BS;\n\n  int32_t row_start_acc[2][2];\n  uint32_t rows = ID->rows;\n  uint32_t cols = ID->columns;\n  x3f_area16_t *area = &TRU->x3rgb16;\n  uint16_t *dst = area->data + color;\n\n  set_bit_state(&BS, TRU->plane_address[color]);\n\n  row_start_acc[0][0] = seed;\n  row_start_acc[0][1] = seed;\n  row_start_acc[1][0] = seed;\n  row_start_acc[1][1] = seed;\n\n  if (ID->type_format == X3F_IMAGE_RAW_QUATTRO ||\n      ID->type_format == X3F_IMAGE_RAW_SDQ ||\n      ID->type_format == X3F_IMAGE_RAW_SDQH ||\n      ID->type_format == X3F_IMAGE_RAW_SDQH2)\n  {\n    rows = Q->plane[color].rows;\n    cols = Q->plane[color].columns;\n\n    if (Q->quattro_layout && color == 2)\n    {\n      area = &Q->top16;\n      dst = area->data;\n    }\n  }\n  else\n  {\n  }\n\n  if (rows != area->rows || cols < area->columns)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  for (row = 0; row < rows; row++)\n  {\n    int col;\n    bool_t odd_row = row & 1;\n    int32_t acc[2];\n\n    for (col = 0; col < cols; col++)\n    {\n      bool_t odd_col = col & 1;\n      int32_t diff = get_true_diff(&BS, tree);\n      int32_t prev = col < 2 ? row_start_acc[odd_row][odd_col] : acc[odd_col];\n      int32_t value = prev + diff;\n\n      acc[odd_col] = value;\n      if (col < 2)\n        row_start_acc[odd_row][odd_col] = value;\n\n      /* Discard additional data at the right for binned Quattro plane 2 */\n      if (col >= area->columns)\n        continue;\n\n      *dst = value;\n      dst += area->channels;\n    }\n  }\n}\n\nstatic void true_decode(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n  int color;\n\n  for (color = 0; color < 3; color++)\n  {\n    true_decode_one_color(ID, color);\n  }\n}\n\n/* Decode use the huffman tree */\n\nstatic int32_t get_huffman_diff(bit_state_t *BS, x3f_hufftree_t *HTP)\n{\n  int32_t diff;\n  x3f_huffnode_t *node = &HTP->nodes[0];\n\n  while (node->branch[0] != NULL || node->branch[1] != NULL)\n  {\n    uint8_t bit = get_bit(BS);\n    x3f_huffnode_t *new_node = node->branch[bit];\n\n    node = new_node;\n    if (node == NULL)\n    {\n      /* TODO: Shouldn't this be treated as a fatal error? */\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n      return 0;\n    }\n  }\n\n  diff = node->leaf;\n\n  return diff;\n}\n\nstatic void huffman_decode_row(x3f_info_t *I, x3f_directory_entry_t *DE,\n                               int bits, int row, int offset, int *minimum)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n  x3f_huffman_t *HUF = ID->huffman;\n\n  int16_t c[3] = {(int16_t)offset, (int16_t)offset, (int16_t)offset};\n  int col;\n  bit_state_t BS;\n\n  if (HUF->row_offsets.element[row] > ID->data_size - 1)\n\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  set_bit_state(&BS, (uint8_t *)ID->data + HUF->row_offsets.element[row]);\n\n  for (col = 0; col < ID->columns; col++)\n  {\n    int color;\n\n    for (color = 0; color < 3; color++)\n    {\n      uint16_t c_fix;\n\n      c[color] += get_huffman_diff(&BS, &HUF->tree);\n      if (c[color] < 0)\n      {\n        c_fix = 0;\n        if (c[color] < *minimum)\n          *minimum = c[color];\n      }\n      else\n      {\n        c_fix = c[color];\n      }\n\n      switch (ID->type_format)\n      {\n      case X3F_IMAGE_RAW_HUFFMAN_X530:\n      case X3F_IMAGE_RAW_HUFFMAN_10BIT:\n        HUF->x3rgb16.data[3 * (row * ID->columns + col) + color] =\n            (uint16_t)c_fix;\n        break;\n      case X3F_IMAGE_THUMB_HUFFMAN:\n        HUF->rgb8.data[3 * (row * ID->columns + col) + color] = (uint8_t)c_fix;\n        break;\n      default:\n        /* TODO: Shouldn't this be treated as a fatal error? */\n        throw LIBRAW_EXCEPTION_IO_CORRUPT;\n      }\n    }\n  }\n}\n\nstatic void huffman_decode(x3f_info_t *I, x3f_directory_entry_t *DE, int bits)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\n  int row;\n  int minimum = 0;\n  int offset = legacy_offset;\n\n  for (row = 0; row < ID->rows; row++)\n    huffman_decode_row(I, DE, bits, row, offset, &minimum);\n\n  if (auto_legacy_offset && minimum < 0)\n  {\n    offset = -minimum;\n    for (row = 0; row < ID->rows; row++)\n      huffman_decode_row(I, DE, bits, row, offset, &minimum);\n  }\n}\n\nstatic int32_t get_simple_diff(x3f_huffman_t *HUF, uint16_t index)\n{\n  if (HUF->mapping.size == 0)\n    return index;\n  else\n    return HUF->mapping.element[index];\n}\n\nstatic void simple_decode_row(x3f_info_t *I, x3f_directory_entry_t *DE,\n                              int bits, int row, int row_stride)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n  x3f_huffman_t *HUF = ID->huffman;\n\n  uint32_t *data = (uint32_t *)((unsigned char *)ID->data + row * row_stride);\n\n  uint16_t c[3] = {0, 0, 0};\n  int col;\n\n  uint32_t mask = 0;\n\n  switch (bits)\n  {\n  case 8:\n    mask = 0x0ff;\n    break;\n  case 9:\n    mask = 0x1ff;\n    break;\n  case 10:\n    mask = 0x3ff;\n    break;\n  case 11:\n    mask = 0x7ff;\n    break;\n  case 12:\n    mask = 0xfff;\n    break;\n  default:\n    mask = 0;\n    /* TODO: Shouldn't this be treated as a fatal error? */\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n    break;\n  }\n\n  for (col = 0; col < ID->columns; col++)\n  {\n    int color;\n    uint32_t val = data[col];\n\n    for (color = 0; color < 3; color++)\n    {\n      uint16_t c_fix;\n      c[color] += get_simple_diff(HUF, (val >> (color * bits)) & mask);\n\n      switch (ID->type_format)\n      {\n      case X3F_IMAGE_RAW_HUFFMAN_X530:\n      case X3F_IMAGE_RAW_HUFFMAN_10BIT:\n        c_fix = (int16_t)c[color] > 0 ? c[color] : 0;\n\n        HUF->x3rgb16.data[3 * (row * ID->columns + col) + color] = c_fix;\n        break;\n      case X3F_IMAGE_THUMB_HUFFMAN:\n        c_fix = (int8_t)c[color] > 0 ? c[color] : 0;\n\n        HUF->rgb8.data[3 * (row * ID->columns + col) + color] = c_fix;\n        break;\n      default:\n        /* TODO: Shouldn't this be treated as a fatal error? */\n        throw LIBRAW_EXCEPTION_IO_CORRUPT;\n      }\n    }\n  }\n}\n\nstatic void simple_decode(x3f_info_t *I, x3f_directory_entry_t *DE, int bits,\n                          int row_stride)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\n  int row;\n\n  for (row = 0; row < ID->rows; row++)\n    simple_decode_row(I, DE, bits, row, row_stride);\n}\n\n/* --------------------------------------------------------------------- */\n/* Loading the data in a directory entry                                 */\n/* --------------------------------------------------------------------- */\n\n/* First you set the offset to where to start reading the data ... */\n\nstatic void read_data_set_offset(x3f_info_t *I, x3f_directory_entry_t *DE,\n                                 uint32_t header_size)\n{\n  uint32_t i_off = DE->input.offset + header_size;\n\n  I->input.file->seek(i_off, SEEK_SET);\n}\n\n/* ... then you read the data, block for block */\n\nstatic uint32_t read_data_block(void **data, x3f_info_t *I,\n                                x3f_directory_entry_t *DE, uint32_t footer)\n{\n  INT64 fpos = I->input.file->tell();\n  uint32_t size = DE->input.size + DE->input.offset - fpos - footer;\n\n  if (fpos + size > I->input.file->size())\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  *data = (void *)malloc(size);\n\n  GETN(*data, size);\n\n  return size;\n}\n\nstatic uint32_t data_block_size(void **data, x3f_info_t *I,\n                                x3f_directory_entry_t *DE, uint32_t footer)\n{\n  uint32_t size =\n      DE->input.size + DE->input.offset - I->input.file->tell() - footer;\n  return size;\n}\n\nstatic void x3f_load_image_verbatim(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n  if (!ID->data_size)\n    ID->data_size = read_data_block(&ID->data, I, DE, 0);\n}\n\nstatic int32_t x3f_load_image_verbatim_size(x3f_info_t *I,\n                                            x3f_directory_entry_t *DE)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n  return data_block_size(&ID->data, I, DE, 0);\n}\n\nstatic void x3f_load_property_list(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_property_list_t *PL = &DEH->data_subsection.property_list;\n  int i;\n\n  read_data_set_offset(I, DE, X3F_PROPERTY_LIST_HEADER_SIZE);\n\n  GET_PROPERTY_TABLE(PL->property_table, PL->num_properties);\n\n  if (!PL->data_size)\n    PL->data_size = read_data_block(&PL->data, I, DE, 0);\n  uint32_t maxoffset = PL->data_size / sizeof(utf16_t) -\n                       2; // at least 2 chars, value + terminating 0x0000\n\n  for (i = 0; i < PL->num_properties; i++)\n  {\n    x3f_property_t *P = &PL->property_table.element[i];\n    if (P->name_offset > maxoffset || P->value_offset > maxoffset)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n    P->name = ((utf16_t *)PL->data + P->name_offset);\n    P->value = ((utf16_t *)PL->data + P->value_offset);\n  }\n}\n\nstatic void x3f_load_true(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n  x3f_true_t *TRU = new_true(&ID->tru);\n  x3f_quattro_t *Q = NULL;\n  int i;\n\n  if (ID->type_format == X3F_IMAGE_RAW_QUATTRO ||\n      ID->type_format == X3F_IMAGE_RAW_SDQ ||\n      ID->type_format == X3F_IMAGE_RAW_SDQH ||\n      ID->type_format == X3F_IMAGE_RAW_SDQH2)\n  {\n    Q = new_quattro(&ID->quattro);\n\n    for (i = 0; i < TRUE_PLANES; i++)\n    {\n      GET2(Q->plane[i].columns);\n      GET2(Q->plane[i].rows);\n    }\n\n    if (Q->plane[0].rows == ID->rows / 2)\n    {\n      Q->quattro_layout = 1;\n    }\n    else if (Q->plane[0].rows == ID->rows)\n    {\n      Q->quattro_layout = 0;\n    }\n    else\n    {\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n    }\n  }\n\n  /* Read TRUE header data */\n  GET2(TRU->seed[0]);\n  GET2(TRU->seed[1]);\n  GET2(TRU->seed[2]);\n  GET2(TRU->unknown);\n  GET_TRUE_HUFF_TABLE(TRU->table);\n\n  if (ID->type_format == X3F_IMAGE_RAW_QUATTRO ||\n      ID->type_format == X3F_IMAGE_RAW_SDQ ||\n      ID->type_format == X3F_IMAGE_RAW_SDQH ||\n      ID->type_format == X3F_IMAGE_RAW_SDQH2)\n  {\n    GET4(Q->unknown);\n  }\n\n  GET_TABLE(TRU->plane_size, GET4, TRUE_PLANES, uint32_t);\n\n  /* Read image data */\n  if (!ID->data_size)\n    ID->data_size = read_data_block(&ID->data, I, DE, 0);\n\n  /* TODO: can it be fewer than 8 bits? Maybe taken from TRU->table? */\n  new_huffman_tree(&TRU->tree, 8);\n\n  populate_true_huffman_tree(&TRU->tree, &TRU->table);\n\n#ifdef DBG_PRNT\n  print_huffman_tree(TRU->tree.nodes, 0, 0);\n#endif\n\n  TRU->plane_address[0] = (uint8_t *)ID->data;\n  for (i = 1; i < TRUE_PLANES; i++)\n    TRU->plane_address[i] = TRU->plane_address[i - 1] +\n                            (((TRU->plane_size.element[i - 1] + 15) / 16) * 16);\n\n  if ((ID->type_format == X3F_IMAGE_RAW_QUATTRO ||\n       ID->type_format == X3F_IMAGE_RAW_SDQ ||\n       ID->type_format == X3F_IMAGE_RAW_SDQH ||\n       ID->type_format == X3F_IMAGE_RAW_SDQH2) &&\n      Q->quattro_layout)\n  {\n    uint32_t columns = Q->plane[0].columns;\n    uint32_t rows = Q->plane[0].rows;\n    uint32_t channels = 3;\n    uint32_t size = columns * rows * channels;\n\n    TRU->x3rgb16.columns = columns;\n    TRU->x3rgb16.rows = rows;\n    TRU->x3rgb16.channels = channels;\n    TRU->x3rgb16.row_stride = columns * channels;\n    TRU->x3rgb16.buf = malloc(sizeof(uint16_t) * size);\n    TRU->x3rgb16.data = (uint16_t *)TRU->x3rgb16.buf;\n\n    columns = Q->plane[2].columns;\n    rows = Q->plane[2].rows;\n    channels = 1;\n    size = columns * rows * channels;\n\n    Q->top16.columns = columns;\n    Q->top16.rows = rows;\n    Q->top16.channels = channels;\n    Q->top16.row_stride = columns * channels;\n    Q->top16.buf = malloc(sizeof(uint16_t) * size);\n    Q->top16.data = (uint16_t *)Q->top16.buf;\n  }\n  else\n  {\n    uint32_t size = ID->columns * ID->rows * 3;\n\n    TRU->x3rgb16.columns = ID->columns;\n    TRU->x3rgb16.rows = ID->rows;\n    TRU->x3rgb16.channels = 3;\n    TRU->x3rgb16.row_stride = ID->columns * 3;\n    TRU->x3rgb16.buf = malloc(sizeof(uint16_t) * size);\n    TRU->x3rgb16.data = (uint16_t *)TRU->x3rgb16.buf;\n  }\n\n  true_decode(I, DE);\n}\n\nstatic void x3f_load_huffman_compressed(x3f_info_t *I,\n                                        x3f_directory_entry_t *DE, int bits,\n                                        int use_map_table)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n  x3f_huffman_t *HUF = ID->huffman;\n  int table_size = 1 << bits;\n  int row_offsets_size = ID->rows * sizeof(HUF->row_offsets.element[0]);\n\n  GET_TABLE(HUF->table, GET4, table_size, uint32_t);\n\n  if (!ID->data_size)\n    ID->data_size = read_data_block(&ID->data, I, DE, row_offsets_size);\n\n  GET_TABLE(HUF->row_offsets, GET4, ID->rows, uint32_t);\n\n  new_huffman_tree(&HUF->tree, bits);\n  populate_huffman_tree(&HUF->tree, &HUF->table, &HUF->mapping);\n\n  huffman_decode(I, DE, bits);\n}\n\nstatic void x3f_load_huffman_not_compressed(x3f_info_t *I,\n                                            x3f_directory_entry_t *DE, int bits,\n                                            int use_map_table, int row_stride)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\n  if (!ID->data_size)\n    ID->data_size = read_data_block(&ID->data, I, DE, 0);\n\n  simple_decode(I, DE, bits, row_stride);\n}\n\nstatic void x3f_load_huffman(x3f_info_t *I, x3f_directory_entry_t *DE, int bits,\n                             int use_map_table, int row_stride)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n  x3f_huffman_t *HUF = new_huffman(&ID->huffman);\n  uint32_t size;\n\n  if (use_map_table)\n  {\n    int table_size = 1 << bits;\n\n    GET_TABLE(HUF->mapping, GET2, table_size, uint16_t);\n  }\n\n  switch (ID->type_format)\n  {\n  case X3F_IMAGE_RAW_HUFFMAN_X530:\n  case X3F_IMAGE_RAW_HUFFMAN_10BIT:\n    size = ID->columns * ID->rows * 3;\n    HUF->x3rgb16.columns = ID->columns;\n    HUF->x3rgb16.rows = ID->rows;\n    HUF->x3rgb16.channels = 3;\n    HUF->x3rgb16.row_stride = ID->columns * 3;\n    HUF->x3rgb16.buf = malloc(sizeof(uint16_t) * size);\n    HUF->x3rgb16.data = (uint16_t *)HUF->x3rgb16.buf;\n    break;\n  case X3F_IMAGE_THUMB_HUFFMAN:\n    size = ID->columns * ID->rows * 3;\n    HUF->rgb8.columns = ID->columns;\n    HUF->rgb8.rows = ID->rows;\n    HUF->rgb8.channels = 3;\n    HUF->rgb8.row_stride = ID->columns * 3;\n    HUF->rgb8.buf = malloc(sizeof(uint8_t) * size);\n    HUF->rgb8.data = (uint8_t *)HUF->rgb8.buf;\n    break;\n  default:\n    /* TODO: Shouldn't this be treated as a fatal error? */\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  }\n\n  if (row_stride == 0)\n    return x3f_load_huffman_compressed(I, DE, bits, use_map_table);\n  else\n    return x3f_load_huffman_not_compressed(I, DE, bits, use_map_table,\n                                           row_stride);\n}\n\nstatic void x3f_load_pixmap(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n  x3f_load_image_verbatim(I, DE);\n}\n\nstatic uint32_t x3f_load_pixmap_size(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n  return x3f_load_image_verbatim_size(I, DE);\n}\n\nstatic void x3f_load_jpeg(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n  x3f_load_image_verbatim(I, DE);\n}\n\nstatic uint32_t x3f_load_jpeg_size(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n  return x3f_load_image_verbatim_size(I, DE);\n}\n\nstatic void x3f_load_image(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\n  read_data_set_offset(I, DE, X3F_IMAGE_HEADER_SIZE);\n\n  switch (ID->type_format)\n  {\n  case X3F_IMAGE_RAW_TRUE:\n  case X3F_IMAGE_RAW_MERRILL:\n  case X3F_IMAGE_RAW_QUATTRO:\n  case X3F_IMAGE_RAW_SDQ:\n  case X3F_IMAGE_RAW_SDQH:\n  case X3F_IMAGE_RAW_SDQH2:\n    x3f_load_true(I, DE);\n    break;\n  case X3F_IMAGE_RAW_HUFFMAN_X530:\n  case X3F_IMAGE_RAW_HUFFMAN_10BIT:\n    x3f_load_huffman(I, DE, 10, 1, ID->row_stride);\n    break;\n  case X3F_IMAGE_THUMB_PLAIN:\n    x3f_load_pixmap(I, DE);\n    break;\n  case X3F_IMAGE_THUMB_HUFFMAN:\n    x3f_load_huffman(I, DE, 8, 0, ID->row_stride);\n    break;\n  case X3F_IMAGE_THUMB_JPEG:\n    x3f_load_jpeg(I, DE);\n    break;\n  default:\n    /* TODO: Shouldn't this be treated as a fatal error? */\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  }\n}\n\n// Used only for thumbnail size estimation\nstatic uint32_t x3f_load_image_size(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\n  read_data_set_offset(I, DE, X3F_IMAGE_HEADER_SIZE);\n\n  switch (ID->type_format)\n  {\n  case X3F_IMAGE_THUMB_PLAIN:\n    return x3f_load_pixmap_size(I, DE);\n  case X3F_IMAGE_THUMB_JPEG:\n    return x3f_load_jpeg_size(I, DE);\n    break;\n  default:\n    return 0;\n  }\n}\n\nstatic void x3f_load_camf_decode_type2(x3f_camf_t *CAMF)\n{\n  uint32_t key = CAMF->t2.crypt_key;\n  int i;\n\n  CAMF->decoded_data_size = CAMF->data_size;\n  CAMF->decoded_data = malloc(CAMF->decoded_data_size);\n\n  for (i = 0; i < CAMF->data_size; i++)\n  {\n    uint8_t old, _new;\n    uint32_t tmp;\n\n    old = ((uint8_t *)CAMF->data)[i];\n    key = (key * 1597 + 51749) % 244944;\n    tmp = (uint32_t)(key * ((int64_t)301593171) >> 24);\n    _new = (uint8_t)(old ^ (uint8_t)(((((key << 8) - tmp) >> 1) + tmp) >> 17));\n    ((uint8_t *)CAMF->decoded_data)[i] = _new;\n  }\n}\n\n/* NOTE: the unpacking in this code is in big respects identical to\n   true_decode_one_color(). The difference is in the output you\n   build. It might be possible to make some parts shared. NOTE ALSO:\n   This means that the meta data is obfuscated using an image\n   compression algorithm. */\n\nstatic void camf_decode_type4(x3f_camf_t *CAMF)\n{\n  uint32_t seed = CAMF->t4.decode_bias;\n  int row;\n\n  uint8_t *dst;\n  uint32_t dst_size = CAMF->t4.decoded_data_size;\n  uint8_t *dst_end;\n\n  bool_t odd_dst = 0;\n\n  x3f_hufftree_t *tree = &CAMF->tree;\n  bit_state_t BS;\n\n  int32_t row_start_acc[2][2];\n  uint32_t rows = CAMF->t4.block_count;\n  uint32_t cols = CAMF->t4.block_size;\n\n  CAMF->decoded_data_size = dst_size;\n\n  CAMF->decoded_data = malloc(CAMF->decoded_data_size);\n  memset(CAMF->decoded_data, 0, CAMF->decoded_data_size);\n\n  dst = (uint8_t *)CAMF->decoded_data;\n  dst_end = dst + dst_size;\n\n  set_bit_state(&BS, CAMF->decoding_start);\n\n  row_start_acc[0][0] = seed;\n  row_start_acc[0][1] = seed;\n  row_start_acc[1][0] = seed;\n  row_start_acc[1][1] = seed;\n\n  for (row = 0; row < rows; row++)\n  {\n    int col;\n    bool_t odd_row = row & 1;\n    int32_t acc[2];\n\n    /* We loop through all the columns and the rows. But the actual\n       data is smaller than that, so we break the loop when reaching\n       the end. */\n    for (col = 0; col < cols; col++)\n    {\n      bool_t odd_col = col & 1;\n      int32_t diff = get_true_diff(&BS, tree);\n      int32_t prev = col < 2 ? row_start_acc[odd_row][odd_col] : acc[odd_col];\n      int32_t value = prev + diff;\n\n      acc[odd_col] = value;\n      if (col < 2)\n        row_start_acc[odd_row][odd_col] = value;\n\n      switch (odd_dst)\n      {\n      case 0:\n        *dst++ = (uint8_t)((value >> 4) & 0xff);\n\n        if (dst >= dst_end)\n        {\n          goto ready;\n        }\n\n        *dst = (uint8_t)((value << 4) & 0xf0);\n        break;\n      case 1:\n        *dst++ |= (uint8_t)((value >> 8) & 0x0f);\n\n        if (dst >= dst_end)\n        {\n          goto ready;\n        }\n\n        *dst++ = (uint8_t)((value << 0) & 0xff);\n\n        if (dst >= dst_end)\n        {\n          goto ready;\n        }\n\n        break;\n      }\n\n      odd_dst = !odd_dst;\n    } /* end col */\n  }   /* end row */\n\nready:;\n}\n\nstatic void x3f_load_camf_decode_type4(x3f_camf_t *CAMF)\n{\n  int i;\n  uint8_t *p;\n  x3f_true_huffman_element_t *element = NULL;\n\n  for (i = 0, p = (uint8_t *)CAMF->data; *p != 0; i++)\n  {\n    /* TODO: Is this too expensive ??*/\n    element = (x3f_true_huffman_element_t *)realloc(element,\n                                                    (i + 1) * sizeof(*element));\n\n    element[i].code_size = *p++;\n    element[i].code = *p++;\n  }\n\n  CAMF->table.size = i;\n  CAMF->table.element = element;\n\n  /* TODO: where does the values 28 and 32 come from? */\n#define CAMF_T4_DATA_SIZE_OFFSET 28\n#define CAMF_T4_DATA_OFFSET 32\n  CAMF->decoding_size =\n      *(uint32_t *)((unsigned char *)CAMF->data + CAMF_T4_DATA_SIZE_OFFSET);\n  CAMF->decoding_start = (uint8_t *)CAMF->data + CAMF_T4_DATA_OFFSET;\n\n  /* TODO: can it be fewer than 8 bits? Maybe taken from TRU->table? */\n  new_huffman_tree(&CAMF->tree, 8);\n\n  populate_true_huffman_tree(&CAMF->tree, &CAMF->table);\n\n#ifdef DBG_PRNT\n  print_huffman_tree(CAMF->tree.nodes, 0, 0);\n#endif\n\n  camf_decode_type4(CAMF);\n}\n\nstatic void camf_decode_type5(x3f_camf_t *CAMF)\n{\n  int32_t acc = CAMF->t5.decode_bias;\n\n  uint8_t *dst;\n\n  x3f_hufftree_t *tree = &CAMF->tree;\n  bit_state_t BS;\n\n  int32_t i;\n\n  CAMF->decoded_data_size = CAMF->t5.decoded_data_size;\n  CAMF->decoded_data = malloc(CAMF->decoded_data_size);\n\n  dst = (uint8_t *)CAMF->decoded_data;\n\n  set_bit_state(&BS, CAMF->decoding_start);\n\n  for (i = 0; i < CAMF->decoded_data_size; i++)\n  {\n    int32_t diff = get_true_diff(&BS, tree);\n\n    acc = acc + diff;\n    *dst++ = (uint8_t)(acc & 0xff);\n  }\n}\n\nstatic void x3f_load_camf_decode_type5(x3f_camf_t *CAMF)\n{\n  int i;\n  uint8_t *p;\n  x3f_true_huffman_element_t *element = NULL;\n\n  for (i = 0, p = (uint8_t *)CAMF->data; *p != 0; i++)\n  {\n    /* TODO: Is this too expensive ??*/\n    element = (x3f_true_huffman_element_t *)realloc(element,\n                                                    (i + 1) * sizeof(*element));\n\n    element[i].code_size = *p++;\n    element[i].code = *p++;\n  }\n\n  CAMF->table.size = i;\n  CAMF->table.element = element;\n\n  /* TODO: where does the values 28 and 32 come from? */\n#define CAMF_T5_DATA_SIZE_OFFSET 28\n#define CAMF_T5_DATA_OFFSET 32\n  CAMF->decoding_size =\n      *(uint32_t *)((uint8_t *)CAMF->data + CAMF_T5_DATA_SIZE_OFFSET);\n  CAMF->decoding_start = (uint8_t *)CAMF->data + CAMF_T5_DATA_OFFSET;\n\n  /* TODO: can it be fewer than 8 bits? Maybe taken from TRU->table? */\n  new_huffman_tree(&CAMF->tree, 8);\n\n  populate_true_huffman_tree(&CAMF->tree, &CAMF->table);\n\n#ifdef DBG_PRNT\n  print_huffman_tree(CAMF->tree.nodes, 0, 0);\n#endif\n\n  camf_decode_type5(CAMF);\n}\n\nstatic void x3f_setup_camf_text_entry(camf_entry_t *entry)\n{\n  entry->text_size = *(uint32_t *)entry->value_address;\n  entry->text = (char *)entry->value_address + 4;\n}\n\nstatic void x3f_setup_camf_property_entry(camf_entry_t *entry)\n{\n  int i;\n  uint8_t *e = (uint8_t *)entry->entry;\n  uint8_t *v = (uint8_t *)entry->value_address;\n  uint32_t num = entry->property_num = *(uint32_t *)v;\n  uint32_t off = *(uint32_t *)(v + 4);\n\n  entry->property_name = (char **)malloc(num * sizeof(uint8_t *));\n  entry->property_value = (uint8_t **)malloc(num * sizeof(uint8_t *));\n\n  for (i = 0; i < num; i++)\n  {\n    uint32_t name_off = off + *(uint32_t *)(v + 8 + 8 * i);\n    uint32_t value_off = off + *(uint32_t *)(v + 8 + 8 * i + 4);\n\n    entry->property_name[i] = (char *)(e + name_off);\n    entry->property_value[i] = e + value_off;\n  }\n}\n\nstatic void set_matrix_element_info(uint32_t type, uint32_t *size,\n                                    matrix_type_t *decoded_type)\n{\n  switch (type)\n  {\n  case 0:\n    *size = 2;\n    *decoded_type = M_INT; /* known to be true */\n    break;\n  case 1:\n    *size = 4;\n    *decoded_type = M_UINT; /* TODO: unknown ???? */\n    break;\n  case 2:\n    *size = 4;\n    *decoded_type = M_UINT; /* TODO: unknown ???? */\n    break;\n  case 3:\n    *size = 4;\n    *decoded_type = M_FLOAT; /* known to be true */\n    break;\n  case 5:\n    *size = 1;\n    *decoded_type = M_UINT; /* TODO: unknown ???? */\n    break;\n  case 6:\n    *size = 2;\n    *decoded_type = M_UINT; /* TODO: unknown ???? */\n    break;\n  default:\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  }\n}\n\nstatic void get_matrix_copy(camf_entry_t *entry)\n{\n  uint32_t element_size = entry->matrix_element_size;\n  uint32_t elements = entry->matrix_elements;\n  int i, size = (entry->matrix_decoded_type == M_FLOAT ? sizeof(double)\n                                                       : sizeof(uint32_t)) *\n                elements;\n\n  entry->matrix_decoded = malloc(size);\n\n  switch (element_size)\n  {\n  case 4:\n    switch (entry->matrix_decoded_type)\n    {\n    case M_INT:\n    case M_UINT:\n      memcpy(entry->matrix_decoded, entry->matrix_data, size);\n      break;\n    case M_FLOAT:\n      for (i = 0; i < elements; i++)\n        ((double *)entry->matrix_decoded)[i] =\n            (double)((float *)entry->matrix_data)[i];\n      break;\n    default:\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n    }\n    break;\n  case 2:\n    switch (entry->matrix_decoded_type)\n    {\n    case M_INT:\n      for (i = 0; i < elements; i++)\n        ((int32_t *)entry->matrix_decoded)[i] =\n            (int32_t)((int16_t *)entry->matrix_data)[i];\n      break;\n    case M_UINT:\n      for (i = 0; i < elements; i++)\n        ((uint32_t *)entry->matrix_decoded)[i] =\n            (uint32_t)((uint16_t *)entry->matrix_data)[i];\n      break;\n    default:\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n    }\n    break;\n  case 1:\n    switch (entry->matrix_decoded_type)\n    {\n    case M_INT:\n      for (i = 0; i < elements; i++)\n        ((int32_t *)entry->matrix_decoded)[i] =\n            (int32_t)((int8_t *)entry->matrix_data)[i];\n      break;\n    case M_UINT:\n      for (i = 0; i < elements; i++)\n        ((uint32_t *)entry->matrix_decoded)[i] =\n            (uint32_t)((uint8_t *)entry->matrix_data)[i];\n      break;\n    default:\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n    }\n    break;\n  default:\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  }\n}\n\nstatic void x3f_setup_camf_matrix_entry(camf_entry_t *entry)\n{\n  int i;\n  int totalsize = 1;\n\n  uint8_t *e = (uint8_t *)entry->entry;\n  uint8_t *v = (uint8_t *)entry->value_address;\n  uint32_t type = entry->matrix_type = *(uint32_t *)(v + 0);\n  uint32_t dim = entry->matrix_dim = *(uint32_t *)(v + 4);\n  uint32_t off = entry->matrix_data_off = *(uint32_t *)(v + 8);\n  camf_dim_entry_t *dentry = entry->matrix_dim_entry =\n      (camf_dim_entry_t *)malloc(dim * sizeof(camf_dim_entry_t));\n\n  for (i = 0; i < dim; i++)\n  {\n    uint32_t size = dentry[i].size = *(uint32_t *)(v + 12 + 12 * i + 0);\n    dentry[i].name_offset = *(uint32_t *)(v + 12 + 12 * i + 4);\n    dentry[i].n = *(uint32_t *)(v + 12 + 12 * i + 8);\n    dentry[i].name = (char *)(e + dentry[i].name_offset);\n\n    if (dentry[i].n != i)\n    {\n    }\n\n    totalsize *= size;\n  }\n\n  set_matrix_element_info(type, &entry->matrix_element_size,\n                          &entry->matrix_decoded_type);\n  entry->matrix_data = (void *)(e + off);\n\n  entry->matrix_elements = totalsize;\n  entry->matrix_used_space = entry->entry_size - off;\n\n  /* This estimate only works for matrices above a certain size */\n  entry->matrix_estimated_element_size = entry->matrix_used_space / totalsize;\n\n  get_matrix_copy(entry);\n}\n\nstatic void x3f_setup_camf_entries(x3f_camf_t *CAMF)\n{\n  uint8_t *p = (uint8_t *)CAMF->decoded_data;\n  uint8_t *end = p + CAMF->decoded_data_size;\n  camf_entry_t *entry = NULL;\n  int i;\n\n  for (i = 0; p < end; i++)\n  {\n    uint32_t *p4 = (uint32_t *)p;\n\n    switch (*p4)\n    {\n    case X3F_CMbP:\n    case X3F_CMbT:\n    case X3F_CMbM:\n      break;\n    default:\n      goto stop;\n    }\n\n    /* TODO: lots of realloc - may be inefficient */\n    entry = (camf_entry_t *)realloc(entry, (i + 1) * sizeof(camf_entry_t));\n\n    /* Pointer */\n    entry[i].entry = p;\n\n    /* Header */\n    entry[i].id = *p4++;\n    entry[i].version = *p4++;\n    entry[i].entry_size = *p4++;\n    entry[i].name_offset = *p4++;\n    entry[i].value_offset = *p4++;\n\n    /* Compute adresses and sizes */\n    entry[i].name_address = (char *)(p + entry[i].name_offset);\n    entry[i].value_address = p + entry[i].value_offset;\n    entry[i].name_size = entry[i].value_offset - entry[i].name_offset;\n    entry[i].value_size = entry[i].entry_size - entry[i].value_offset;\n\n    entry[i].text_size = 0;\n    entry[i].text = NULL;\n    entry[i].property_num = 0;\n    entry[i].property_name = NULL;\n    entry[i].property_value = NULL;\n    entry[i].matrix_type = 0;\n    entry[i].matrix_dim = 0;\n    entry[i].matrix_data_off = 0;\n    entry[i].matrix_data = NULL;\n    entry[i].matrix_dim_entry = NULL;\n\n    entry[i].matrix_decoded = NULL;\n\n    switch (entry[i].id)\n    {\n    case X3F_CMbP:\n      x3f_setup_camf_property_entry(&entry[i]);\n      break;\n    case X3F_CMbT:\n      x3f_setup_camf_text_entry(&entry[i]);\n      break;\n    case X3F_CMbM:\n      x3f_setup_camf_matrix_entry(&entry[i]);\n      break;\n    }\n\n    p += entry[i].entry_size;\n  }\n\nstop:\n\n  CAMF->entry_table.size = i;\n  CAMF->entry_table.element = entry;\n}\n\nstatic void x3f_load_camf(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_camf_t *CAMF = &DEH->data_subsection.camf;\n\n  read_data_set_offset(I, DE, X3F_CAMF_HEADER_SIZE);\n\n  if (!CAMF->data_size)\n    CAMF->data_size = read_data_block(&CAMF->data, I, DE, 0);\n\n  switch (CAMF->type)\n  {\n  case 2: /* Older SD9-SD14 */\n    x3f_load_camf_decode_type2(CAMF);\n    break;\n  case 4: /* TRUE ... Merrill */\n    x3f_load_camf_decode_type4(CAMF);\n    break;\n  case 5: /* Quattro ... */\n    x3f_load_camf_decode_type5(CAMF);\n    break;\n  default:\n    /* TODO: Shouldn't this be treated as a fatal error? */\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  }\n\n  if (CAMF->decoded_data != NULL)\n    x3f_setup_camf_entries(CAMF);\n  else\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n}\n\n/* extern */ x3f_return_t x3f_load_data(x3f_t *x3f, x3f_directory_entry_t *DE)\n{\n  x3f_info_t *I = &x3f->info;\n\n  if (DE == NULL)\n    return X3F_ARGUMENT_ERROR;\n\n  switch (DE->header.identifier)\n  {\n  case X3F_SECp:\n    x3f_load_property_list(I, DE);\n    break;\n  case X3F_SECi:\n    x3f_load_image(I, DE);\n    break;\n  case X3F_SECc:\n    x3f_load_camf(I, DE);\n    break;\n  default:\n    return X3F_INTERNAL_ERROR;\n  }\n  return X3F_OK;\n}\n\n/* extern */ int64_t x3f_load_data_size(x3f_t *x3f, x3f_directory_entry_t *DE)\n{\n  x3f_info_t *I = &x3f->info;\n\n  if (DE == NULL)\n    return -1;\n\n  switch (DE->header.identifier)\n  {\n  case X3F_SECi:\n    return x3f_load_image_size(I, DE);\n  default:\n    return 0;\n  }\n}\n\n/* extern */ x3f_return_t x3f_load_image_block(x3f_t *x3f,\n                                               x3f_directory_entry_t *DE)\n{\n  x3f_info_t *I = &x3f->info;\n\n  if (DE == NULL)\n    return X3F_ARGUMENT_ERROR;\n\n  switch (DE->header.identifier)\n  {\n  case X3F_SECi:\n    read_data_set_offset(I, DE, X3F_IMAGE_HEADER_SIZE);\n    x3f_load_image_verbatim(I, DE);\n    break;\n  default:\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n    return X3F_INTERNAL_ERROR;\n  }\n\n  return X3F_OK;\n}\n\n/* --------------------------------------------------------------------- */\n/* The End                                                               */\n/* --------------------------------------------------------------------- */\n"], "fixing_code": ["/* Library for accessing X3F Files\n----------------------------------------------------------------\nBSD-style License\n----------------------------------------------------------------\n\n* Copyright (c) 2010, Roland Karlsson (roland@proxel.se)\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without\n* modification, are permitted provided that the following conditions are met:\n*     * Redistributions of source code must retain the above copyright\n*       notice, this list of conditions and the following disclaimer.\n*     * Redistributions in binary form must reproduce the above copyright\n*       notice, this list of conditions and the following disclaimer in the\n*       documentation and/or other materials provided with the distribution.\n*     * Neither the name of the organization nor the\n*       names of its contributors may be used to endorse or promote products\n*       derived from this software without specific prior written permission.\n*\n* THIS SOFTWARE IS PROVIDED BY ROLAND KARLSSON ''AS IS'' AND ANY\n* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n* DISCLAIMED. IN NO EVENT SHALL ROLAND KARLSSON BE LIABLE FOR ANY\n* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n*/\n\n#include \"../../internal/libraw_cxx_defs.h\"\n\n#if defined __sun && defined DS\n#undef DS\n#endif\n#ifdef ID\n#undef ID /* used in x3f utils */\n#endif\n\n#include \"../../internal/x3f_tools.h\"\n\n/* extern */ int legacy_offset = 0;\n/* extern */ bool_t auto_legacy_offset = 1;\n\n/* --------------------------------------------------------------------- */\n/* Reading and writing - assuming little endian in the file              */\n/* --------------------------------------------------------------------- */\n\nstatic int x3f_get1(LibRaw_abstract_datastream *f)\n{\n  /* Little endian file */\n  return f->get_char();\n}\n\nstatic int x3f_sget2(uchar *s) { return s[0] | s[1] << 8; }\n\nstatic int x3f_get2(LibRaw_abstract_datastream *f)\n{\n  uchar str[2] = {0xff, 0xff};\n  f->read(str, 1, 2);\n  return x3f_sget2(str);\n}\n\nunsigned x3f_sget4(uchar *s)\n{\n  return s[0] | s[1] << 8 | s[2] << 16 | s[3] << 24;\n}\n\nunsigned x3f_get4(LibRaw_abstract_datastream *f)\n{\n  uchar str[4] = {0xff, 0xff, 0xff, 0xff};\n  f->read(str, 1, 4);\n  return x3f_sget4(str);\n}\n\n#define FREE(P)                                                                \\\n  do                                                                           \\\n  {                                                                            \\\n    free(P);                                                                   \\\n    (P) = NULL;                                                                \\\n  } while (0)\n\n#define PUT_GET_N(_buffer, _size, _file, _func)                                \\\n  do                                                                           \\\n  {                                                                            \\\n    int _left = _size;                                                         \\\n    while (_left != 0)                                                         \\\n    {                                                                          \\\n      int _cur = _file->_func(_buffer, 1, _left);                              \\\n      if (_cur == 0)                                                           \\\n      {                                                                        \\\n        throw LIBRAW_EXCEPTION_IO_CORRUPT;                                     \\\n      }                                                                        \\\n      _left -= _cur;                                                           \\\n    }                                                                          \\\n  } while (0)\n\n#define GET1(_v)                                                               \\\n  do                                                                           \\\n  {                                                                            \\\n    (_v) = x3f_get1(I->input.file);                                            \\\n  } while (0)\n#define GET2(_v)                                                               \\\n  do                                                                           \\\n  {                                                                            \\\n    (_v) = x3f_get2(I->input.file);                                            \\\n  } while (0)\n#define GET4(_v)                                                               \\\n  do                                                                           \\\n  {                                                                            \\\n    (_v) = x3f_get4(I->input.file);                                            \\\n  } while (0)\n\n#define GET4F(_v)                                                              \\\n  do                                                                           \\\n  {                                                                            \\\n    union {                                                                    \\\n      int32_t i;                                                               \\\n      float f;                                                                 \\\n    } _tmp;                                                                    \\\n    _tmp.i = x3f_get4(I->input.file);                                          \\\n    (_v) = _tmp.f;                                                             \\\n  } while (0)\n\n#define GETN(_v, _s) PUT_GET_N(_v, _s, I->input.file, read)\n\n#define GET_TABLE(_T, _GETX, _NUM, _TYPE)                                      \\\n  do                                                                           \\\n  {                                                                            \\\n    int _i;                                                                    \\\n    (_T).size = (_NUM);                                                        \\\n    (_T).element =                                                             \\\n        (_TYPE *)realloc((_T).element, (_NUM) * sizeof((_T).element[0]));      \\\n    for (_i = 0; _i < (_T).size; _i++)                                         \\\n      _GETX((_T).element[_i]);                                                 \\\n  } while (0)\n\n#define GET_PROPERTY_TABLE(_T, _NUM)                                           \\\n  do                                                                           \\\n  {                                                                            \\\n    int _i;                                                                    \\\n    (_T).size = (_NUM);                                                        \\\n    (_T).element = (x3f_property_t *)realloc(                                  \\\n        (_T).element, (_NUM) * sizeof((_T).element[0]));                       \\\n    for (_i = 0; _i < (_T).size; _i++)                                         \\\n    {                                                                          \\\n      GET4((_T).element[_i].name_offset);                                      \\\n      GET4((_T).element[_i].value_offset);                                     \\\n    }                                                                          \\\n  } while (0)\n\n#define GET_TRUE_HUFF_TABLE(_T)                                                \\\n  do                                                                           \\\n  {                                                                            \\\n    int _i;                                                                    \\\n    (_T).element = NULL;                                                       \\\n    for (_i = 0;; _i++)                                                        \\\n    {                                                                          \\\n      (_T).size = _i + 1;                                                      \\\n      (_T).element = (x3f_true_huffman_element_t *)realloc(                    \\\n          (_T).element, (_i + 1) * sizeof((_T).element[0]));                   \\\n      GET1((_T).element[_i].code_size);                                        \\\n      GET1((_T).element[_i].code);                                             \\\n      if ((_T).element[_i].code_size == 0)                                     \\\n        break;                                                                 \\\n    }                                                                          \\\n  } while (0)\n\n/* --------------------------------------------------------------------- */\n/* Allocating Huffman tree help data                                   */\n/* --------------------------------------------------------------------- */\n\nstatic void cleanup_huffman_tree(x3f_hufftree_t *HTP) { free(HTP->nodes); }\n\nstatic void new_huffman_tree(x3f_hufftree_t *HTP, int bits)\n{\n  int leaves = 1 << bits;\n\n  HTP->free_node_index = 0;\n  HTP->total_node_index = HUF_TREE_MAX_NODES(leaves);\n  HTP->nodes = (x3f_huffnode_t *)calloc(1, HUF_TREE_MAX_NODES(leaves) *\n                                               sizeof(x3f_huffnode_t));\n}\n\n/* --------------------------------------------------------------------- */\n/* Allocating TRUE engine RAW help data                                  */\n/* --------------------------------------------------------------------- */\n\nstatic void cleanup_true(x3f_true_t **TRUP)\n{\n  x3f_true_t *TRU = *TRUP;\n\n  if (TRU == NULL)\n    return;\n\n  FREE(TRU->table.element);\n  FREE(TRU->plane_size.element);\n  cleanup_huffman_tree(&TRU->tree);\n  FREE(TRU->x3rgb16.buf);\n\n  FREE(TRU);\n\n  *TRUP = NULL;\n}\n\nstatic x3f_true_t *new_true(x3f_true_t **TRUP)\n{\n  x3f_true_t *TRU = (x3f_true_t *)calloc(1, sizeof(x3f_true_t));\n\n  cleanup_true(TRUP);\n\n  TRU->table.size = 0;\n  TRU->table.element = NULL;\n  TRU->plane_size.size = 0;\n  TRU->plane_size.element = NULL;\n  TRU->tree.nodes = NULL;\n  TRU->x3rgb16.data = NULL;\n  TRU->x3rgb16.buf = NULL;\n\n  *TRUP = TRU;\n\n  return TRU;\n}\n\nstatic void cleanup_quattro(x3f_quattro_t **QP)\n{\n  x3f_quattro_t *Q = *QP;\n\n  if (Q == NULL)\n    return;\n\n  FREE(Q->top16.buf);\n  FREE(Q);\n\n  *QP = NULL;\n}\n\nstatic x3f_quattro_t *new_quattro(x3f_quattro_t **QP)\n{\n  x3f_quattro_t *Q = (x3f_quattro_t *)calloc(1, sizeof(x3f_quattro_t));\n  int i;\n\n  cleanup_quattro(QP);\n\n  for (i = 0; i < TRUE_PLANES; i++)\n  {\n    Q->plane[i].columns = 0;\n    Q->plane[i].rows = 0;\n  }\n\n  Q->unknown = 0;\n\n  Q->top16.data = NULL;\n  Q->top16.buf = NULL;\n\n  *QP = Q;\n\n  return Q;\n}\n\n/* --------------------------------------------------------------------- */\n/* Allocating Huffman engine help data                                   */\n/* --------------------------------------------------------------------- */\n\nstatic void cleanup_huffman(x3f_huffman_t **HUFP)\n{\n  x3f_huffman_t *HUF = *HUFP;\n\n  if (HUF == NULL)\n    return;\n\n  FREE(HUF->mapping.element);\n  FREE(HUF->table.element);\n  cleanup_huffman_tree(&HUF->tree);\n  FREE(HUF->row_offsets.element);\n  FREE(HUF->rgb8.buf);\n  FREE(HUF->x3rgb16.buf);\n  FREE(HUF);\n\n  *HUFP = NULL;\n}\n\nstatic x3f_huffman_t *new_huffman(x3f_huffman_t **HUFP)\n{\n  x3f_huffman_t *HUF = (x3f_huffman_t *)calloc(1, sizeof(x3f_huffman_t));\n\n  cleanup_huffman(HUFP);\n\n  /* Set all not read data block pointers to NULL */\n  HUF->mapping.size = 0;\n  HUF->mapping.element = NULL;\n  HUF->table.size = 0;\n  HUF->table.element = NULL;\n  HUF->tree.nodes = NULL;\n  HUF->row_offsets.size = 0;\n  HUF->row_offsets.element = NULL;\n  HUF->rgb8.data = NULL;\n  HUF->rgb8.buf = NULL;\n  HUF->x3rgb16.data = NULL;\n  HUF->x3rgb16.buf = NULL;\n\n  *HUFP = HUF;\n\n  return HUF;\n}\n\n/* --------------------------------------------------------------------- */\n/* Creating a new x3f structure from file                                */\n/* --------------------------------------------------------------------- */\n\n/* extern */ x3f_t *x3f_new_from_file(LibRaw_abstract_datastream *infile)\n{\n  if (!infile)\n    return NULL;\n  INT64 fsize = infile->size();\n  x3f_t *x3f = (x3f_t *)calloc(1, sizeof(x3f_t));\n  if (!x3f)\n    throw LIBRAW_EXCEPTION_ALLOC;\n  try\n  {\n    x3f_info_t *I = NULL;\n    x3f_header_t *H = NULL;\n    x3f_directory_section_t *DS = NULL;\n    int i, d;\n\n    I = &x3f->info;\n    I->error = NULL;\n    I->input.file = infile;\n    I->output.file = NULL;\n\n    /* Read file header */\n    H = &x3f->header;\n    infile->seek(0, SEEK_SET);\n    GET4(H->identifier);\n\n    if (H->identifier != X3F_FOVb)\n    {\n      free(x3f);\n      return NULL;\n    }\n\n    GET4(H->version);\n    GETN(H->unique_identifier, SIZE_UNIQUE_IDENTIFIER);\n    /* TODO: the meaning of the rest of the header for version >= 4.0 (Quattro)\n     * is unknown */\n    if (H->version < X3F_VERSION_4_0)\n    {\n      GET4(H->mark_bits);\n      GET4(H->columns);\n      GET4(H->rows);\n      GET4(H->rotation);\n      if (H->version >= X3F_VERSION_2_1)\n      {\n        int num_ext_data =\n            H->version >= X3F_VERSION_3_0 ? NUM_EXT_DATA_3_0 : NUM_EXT_DATA_2_1;\n\n        GETN(H->white_balance, SIZE_WHITE_BALANCE);\n        if (H->version >= X3F_VERSION_2_3)\n          GETN(H->color_mode, SIZE_COLOR_MODE);\n        GETN(H->extended_types, num_ext_data);\n        for (i = 0; i < num_ext_data; i++)\n          GET4F(H->extended_data[i]);\n      }\n    }\n\n    /* Go to the beginning of the directory */\n    infile->seek(-4, SEEK_END);\n    infile->seek(x3f_get4(infile), SEEK_SET);\n\n    /* Read the directory header */\n    DS = &x3f->directory_section;\n    GET4(DS->identifier);\n    GET4(DS->version);\n    GET4(DS->num_directory_entries);\n\n    if (DS->num_directory_entries > 50)\n      goto _err; // too much direntries, most likely broken file\n\n    if (DS->num_directory_entries > 0)\n    {\n      size_t size = DS->num_directory_entries * sizeof(x3f_directory_entry_t);\n      DS->directory_entry = (x3f_directory_entry_t *)calloc(1, size);\n    }\n\n    /* Traverse the directory */\n    for (d = 0; d < DS->num_directory_entries; d++)\n    {\n      x3f_directory_entry_t *DE = &DS->directory_entry[d];\n      x3f_directory_entry_header_t *DEH = &DE->header;\n      uint32_t save_dir_pos;\n\n      /* Read the directory entry info */\n      GET4(DE->input.offset);\n      GET4(DE->input.size);\n      if (DE->input.offset + DE->input.size > fsize * 2)\n        goto _err;\n\n      DE->output.offset = 0;\n      DE->output.size = 0;\n\n      GET4(DE->type);\n\n      /* Save current pos and go to the entry */\n      save_dir_pos = infile->tell();\n      infile->seek(DE->input.offset, SEEK_SET);\n\n      /* Read the type independent part of the entry header */\n      DEH = &DE->header;\n      GET4(DEH->identifier);\n      GET4(DEH->version);\n\n      /* NOTE - the tests below could be made on DE->type instead */\n\n      if (DEH->identifier == X3F_SECp)\n      {\n        x3f_property_list_t *PL = &DEH->data_subsection.property_list;\n        if (!PL)\n          goto _err;\n        /* Read the property part of the header */\n        GET4(PL->num_properties);\n        GET4(PL->character_format);\n        GET4(PL->reserved);\n        GET4(PL->total_length);\n\n        /* Set all not read data block pointers to NULL */\n        PL->data = NULL;\n        PL->data_size = 0;\n      }\n\n      if (DEH->identifier == X3F_SECi)\n      {\n        x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n        if (!ID)\n          goto _err;\n        /* Read the image part of the header */\n        GET4(ID->type);\n        GET4(ID->format);\n        ID->type_format = (ID->type << 16) + (ID->format);\n        GET4(ID->columns);\n        GET4(ID->rows);\n        GET4(ID->row_stride);\n\n        /* Set all not read data block pointers to NULL */\n        ID->huffman = NULL;\n\n        ID->data = NULL;\n        ID->data_size = 0;\n      }\n\n      if (DEH->identifier == X3F_SECc)\n      {\n        x3f_camf_t *CAMF = &DEH->data_subsection.camf;\n        if (!CAMF)\n          goto _err;\n        /* Read the CAMF part of the header */\n        GET4(CAMF->type);\n        GET4(CAMF->tN.val0);\n        GET4(CAMF->tN.val1);\n        GET4(CAMF->tN.val2);\n        GET4(CAMF->tN.val3);\n\n        /* Set all not read data block pointers to NULL */\n        CAMF->data = NULL;\n        CAMF->data_size = 0;\n\n        /* Set all not allocated help pointers to NULL */\n        CAMF->table.element = NULL;\n        CAMF->table.size = 0;\n        CAMF->tree.nodes = NULL;\n        CAMF->decoded_data = NULL;\n        CAMF->decoded_data_size = 0;\n        CAMF->entry_table.element = NULL;\n        CAMF->entry_table.size = 0;\n      }\n\n      /* Reset the file pointer back to the directory */\n      infile->seek(save_dir_pos, SEEK_SET);\n    }\n\n    return x3f;\n  _err:\n    if (x3f)\n    {\n      DS = &x3f->directory_section;\n      if (DS && DS->directory_entry)\n        free(DS->directory_entry);\n      free(x3f);\n    }\n    return NULL;\n  }\n  catch (...)\n  {\n    x3f_directory_section_t *DS = &x3f->directory_section;\n    if (DS && DS->directory_entry)\n      free(DS->directory_entry);\n    free(x3f);\n    return NULL;\n  }\n}\n\n/* --------------------------------------------------------------------- */\n/* Clean up an x3f structure                                             */\n/* --------------------------------------------------------------------- */\n\nstatic void free_camf_entry(camf_entry_t *entry)\n{\n  FREE(entry->property_name);\n  FREE(entry->property_value);\n  FREE(entry->matrix_decoded);\n  FREE(entry->matrix_dim_entry);\n}\n\n/* extern */ x3f_return_t x3f_delete(x3f_t *x3f)\n{\n  x3f_directory_section_t *DS;\n  int d;\n\n  if (x3f == NULL)\n    return X3F_ARGUMENT_ERROR;\n\n  DS = &x3f->directory_section;\n  if (DS->num_directory_entries > 50)\n    return X3F_ARGUMENT_ERROR;\n\n  for (d = 0; d < DS->num_directory_entries; d++)\n  {\n    x3f_directory_entry_t *DE = &DS->directory_entry[d];\n    x3f_directory_entry_header_t *DEH = &DE->header;\n    if (DEH->identifier == X3F_SECp)\n    {\n      x3f_property_list_t *PL = &DEH->data_subsection.property_list;\n      if (PL)\n      {\n        int i;\n      }\n      FREE(PL->property_table.element);\n      FREE(PL->data);\n    }\n\n    if (DEH->identifier == X3F_SECi)\n    {\n      x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\n      if (ID)\n      {\n        cleanup_huffman(&ID->huffman);\n        cleanup_true(&ID->tru);\n        cleanup_quattro(&ID->quattro);\n        FREE(ID->data);\n      }\n    }\n\n    if (DEH->identifier == X3F_SECc)\n    {\n      x3f_camf_t *CAMF = &DEH->data_subsection.camf;\n      int i;\n      if (CAMF)\n      {\n        FREE(CAMF->data);\n        FREE(CAMF->table.element);\n        cleanup_huffman_tree(&CAMF->tree);\n        FREE(CAMF->decoded_data);\n        for (i = 0; i < CAMF->entry_table.size; i++)\n        {\n          free_camf_entry(&CAMF->entry_table.element[i]);\n        }\n      }\n      FREE(CAMF->entry_table.element);\n    }\n  }\n\n  FREE(DS->directory_entry);\n  FREE(x3f);\n\n  return X3F_OK;\n}\n\n/* --------------------------------------------------------------------- */\n/* Getting a reference to a directory entry                              */\n/* --------------------------------------------------------------------- */\n\n/* TODO: all those only get the first instance */\n\nstatic x3f_directory_entry_t *x3f_get(x3f_t *x3f, uint32_t type,\n                                      uint32_t image_type)\n{\n  x3f_directory_section_t *DS;\n  int d;\n\n  if (x3f == NULL)\n    return NULL;\n\n  DS = &x3f->directory_section;\n\n  for (d = 0; d < DS->num_directory_entries; d++)\n  {\n    x3f_directory_entry_t *DE = &DS->directory_entry[d];\n    x3f_directory_entry_header_t *DEH = &DE->header;\n\n    if (DEH->identifier == type)\n    {\n      switch (DEH->identifier)\n      {\n      case X3F_SECi:\n      {\n        x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\n        if (ID->type_format == image_type)\n          return DE;\n      }\n      break;\n      default:\n        return DE;\n      }\n    }\n  }\n\n  return NULL;\n}\n\n/* extern */ x3f_directory_entry_t *x3f_get_raw(x3f_t *x3f)\n{\n  x3f_directory_entry_t *DE;\n\n  if ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_HUFFMAN_X530)) != NULL)\n    return DE;\n\n  if ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_HUFFMAN_10BIT)) != NULL)\n    return DE;\n\n  if ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_TRUE)) != NULL)\n    return DE;\n\n  if ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_MERRILL)) != NULL)\n    return DE;\n\n  if ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_QUATTRO)) != NULL)\n    return DE;\n\n  if ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_SDQ)) != NULL)\n    return DE;\n\n  if ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_SDQH)) != NULL)\n    return DE;\n  if ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_SDQH2)) != NULL)\n    return DE;\n\n  return NULL;\n}\n\n/* extern */ x3f_directory_entry_t *x3f_get_thumb_plain(x3f_t *x3f)\n{\n  return x3f_get(x3f, X3F_SECi, X3F_IMAGE_THUMB_PLAIN);\n}\n\n/* extern */ x3f_directory_entry_t *x3f_get_thumb_huffman(x3f_t *x3f)\n{\n  return x3f_get(x3f, X3F_SECi, X3F_IMAGE_THUMB_HUFFMAN);\n}\n\n/* extern */ x3f_directory_entry_t *x3f_get_thumb_jpeg(x3f_t *x3f)\n{\n  return x3f_get(x3f, X3F_SECi, X3F_IMAGE_THUMB_JPEG);\n}\n\n/* extern */ x3f_directory_entry_t *x3f_get_camf(x3f_t *x3f)\n{\n  return x3f_get(x3f, X3F_SECc, 0);\n}\n\n/* extern */ x3f_directory_entry_t *x3f_get_prop(x3f_t *x3f)\n{\n  return x3f_get(x3f, X3F_SECp, 0);\n}\n\n/* For some obscure reason, the bit numbering is weird. It is\n   generally some kind of \"big endian\" style - e.g. the bit 7 is the\n   first in a byte and bit 31 first in a 4 byte int. For patterns in\n   the huffman pattern table, bit 27 is the first bit and bit 26 the\n   next one. */\n\n#define PATTERN_BIT_POS(_len, _bit) ((_len) - (_bit)-1)\n#define MEMORY_BIT_POS(_bit) PATTERN_BIT_POS(8, _bit)\n\n/* --------------------------------------------------------------------- */\n/* Huffman Decode                                                        */\n/* --------------------------------------------------------------------- */\n\n/* Make the huffman tree */\n\n#ifdef DBG_PRNT\nstatic char *display_code(int length, uint32_t code, char *buffer)\n{\n  int i;\n\n  for (i = 0; i < length; i++)\n  {\n    int pos = PATTERN_BIT_POS(length, i);\n    buffer[i] = ((code >> pos) & 1) == 0 ? '0' : '1';\n  }\n\n  buffer[i] = 0;\n\n  return buffer;\n}\n#endif\n\nstatic x3f_huffnode_t *new_node(x3f_hufftree_t *tree)\n{\n\tif (tree->free_node_index >= tree->total_node_index)\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n  x3f_huffnode_t *t = &tree->nodes[tree->free_node_index];\n\n  t->branch[0] = NULL;\n  t->branch[1] = NULL;\n  t->leaf = UNDEFINED_LEAF;\n\n  tree->free_node_index++;\n\n  return t;\n}\n\nstatic void add_code_to_tree(x3f_hufftree_t *tree, int length, uint32_t code,\n                             uint32_t value)\n{\n  int i;\n\n  x3f_huffnode_t *t = tree->nodes;\n\n  for (i = 0; i < length; i++)\n  {\n    int pos = PATTERN_BIT_POS(length, i);\n    int bit = (code >> pos) & 1;\n    x3f_huffnode_t *t_next = t->branch[bit];\n\n    if (t_next == NULL)\n      t_next = t->branch[bit] = new_node(tree);\n\n    t = t_next;\n  }\n\n  t->leaf = value;\n}\n\nstatic void populate_true_huffman_tree(x3f_hufftree_t *tree,\n                                       x3f_true_huffman_t *table)\n{\n  int i;\n\n  new_node(tree);\n\n  for (i = 0; i < table->size; i++)\n  {\n    x3f_true_huffman_element_t *element = &table->element[i];\n    uint32_t length = element->code_size;\n\n    if (length != 0)\n    {\n      /* add_code_to_tree wants the code right adjusted */\n      uint32_t code = ((element->code) >> (8 - length)) & 0xff;\n      uint32_t value = i;\n\n      add_code_to_tree(tree, length, code, value);\n\n#ifdef DBG_PRNT\n      {\n        char buffer[100];\n\n        x3f_printf(DEBUG, \"H %5d : %5x : %5d : %02x %08x (%08x) (%s)\\n\", i, i,\n                   value, length, code, value,\n                   display_code(length, code, buffer));\n      }\n#endif\n    }\n  }\n}\n\nstatic void populate_huffman_tree(x3f_hufftree_t *tree, x3f_table32_t *table,\n                                  x3f_table16_t *mapping)\n{\n  int i;\n\n  new_node(tree);\n\n  for (i = 0; i < table->size; i++)\n  {\n    uint32_t element = table->element[i];\n\n    if (element != 0)\n    {\n      uint32_t length = HUF_TREE_GET_LENGTH(element);\n      uint32_t code = HUF_TREE_GET_CODE(element);\n      uint32_t value;\n\n      /* If we have a valid mapping table - then the value from the\n         mapping table shall be used. Otherwise we use the current\n         index in the table as value. */\n      if (table->size == mapping->size)\n        value = mapping->element[i];\n      else\n        value = i;\n\n      add_code_to_tree(tree, length, code, value);\n\n#ifdef DBG_PRNT\n      {\n        char buffer[100];\n\n        x3f_printf(DEBUG, \"H %5d : %5x : %5d : %02x %08x (%08x) (%s)\\n\", i, i,\n                   value, length, code, element,\n                   display_code(length, code, buffer));\n      }\n#endif\n    }\n  }\n}\n\n#ifdef DBG_PRNT\nstatic void print_huffman_tree(x3f_huffnode_t *t, int length, uint32_t code)\n{\n  char buf1[100];\n  char buf2[100];\n\n  x3f_printf(DEBUG, \"%*s (%s,%s) %s (%s)\\n\", length,\n             length < 1 ? \"-\" : (code & 1) ? \"1\" : \"0\",\n             t->branch[0] == NULL ? \"-\" : \"0\", t->branch[1] == NULL ? \"-\" : \"1\",\n             t->leaf == UNDEFINED_LEAF ? \"-\"\n                                       : (sprintf(buf1, \"%x\", t->leaf), buf1),\n             display_code(length, code, buf2));\n\n  code = code << 1;\n  if (t->branch[0])\n    print_huffman_tree(t->branch[0], length + 1, code + 0);\n  if (t->branch[1])\n    print_huffman_tree(t->branch[1], length + 1, code + 1);\n}\n#endif\n\n/* Help machinery for reading bits in a memory */\n\ntypedef struct bit_state_s\n{\n  uint8_t *next_address;\n  uint8_t bit_offset;\n  uint8_t bits[8];\n} bit_state_t;\n\nstatic void set_bit_state(bit_state_t *BS, uint8_t *address)\n{\n  BS->next_address = address;\n  BS->bit_offset = 8;\n}\n\nstatic uint8_t get_bit(bit_state_t *BS)\n{\n  if (BS->bit_offset == 8)\n  {\n    uint8_t byte = *BS->next_address;\n    int i;\n\n    for (i = 7; i >= 0; i--)\n    {\n      BS->bits[i] = byte & 1;\n      byte = byte >> 1;\n    }\n    BS->next_address++;\n    BS->bit_offset = 0;\n  }\n\n  return BS->bits[BS->bit_offset++];\n}\n\n/* Decode use the TRUE algorithm */\n\nstatic int32_t get_true_diff(bit_state_t *BS, x3f_hufftree_t *HTP)\n{\n  int32_t diff;\n  x3f_huffnode_t *node = &HTP->nodes[0];\n  uint8_t bits;\n\n  while (node->branch[0] != NULL || node->branch[1] != NULL)\n  {\n    uint8_t bit = get_bit(BS);\n    x3f_huffnode_t *new_node = node->branch[bit];\n\n    node = new_node;\n    if (node == NULL)\n    {\n      /* TODO: Shouldn't this be treated as a fatal error? */\n      return 0;\n    }\n  }\n\n  bits = node->leaf;\n\n  if (bits == 0)\n    diff = 0;\n  else\n  {\n    uint8_t first_bit = get_bit(BS);\n    int i;\n\n    diff = first_bit;\n\n    for (i = 1; i < bits; i++)\n      diff = (diff << 1) + get_bit(BS);\n\n    if (first_bit == 0)\n      diff -= (1 << bits) - 1;\n  }\n\n  return diff;\n}\n\n/* This code (that decodes one of the X3F color planes, really is a\n   decoding of a compression algorithm suited for Bayer CFA data. In\n   Bayer CFA the data is divided into 2x2 squares that represents\n   (R,G1,G2,B) data. Those four positions are (in this compression)\n   treated as one data stream each, where you store the differences to\n   previous data in the stream. The reason for this is, of course,\n   that the date is more often than not near to the next data in a\n   stream that represents the same color. */\n\n/* TODO: write more about the compression */\n\nstatic void true_decode_one_color(x3f_image_data_t *ID, int color)\n{\n  x3f_true_t *TRU = ID->tru;\n  x3f_quattro_t *Q = ID->quattro;\n  uint32_t seed = TRU->seed[color]; /* TODO : Is this correct ? */\n  int row;\n\n  x3f_hufftree_t *tree = &TRU->tree;\n  bit_state_t BS;\n\n  int32_t row_start_acc[2][2];\n  uint32_t rows = ID->rows;\n  uint32_t cols = ID->columns;\n  x3f_area16_t *area = &TRU->x3rgb16;\n  uint16_t *dst = area->data + color;\n\n  set_bit_state(&BS, TRU->plane_address[color]);\n\n  row_start_acc[0][0] = seed;\n  row_start_acc[0][1] = seed;\n  row_start_acc[1][0] = seed;\n  row_start_acc[1][1] = seed;\n\n  if (ID->type_format == X3F_IMAGE_RAW_QUATTRO ||\n      ID->type_format == X3F_IMAGE_RAW_SDQ ||\n      ID->type_format == X3F_IMAGE_RAW_SDQH ||\n      ID->type_format == X3F_IMAGE_RAW_SDQH2)\n  {\n    rows = Q->plane[color].rows;\n    cols = Q->plane[color].columns;\n\n    if (Q->quattro_layout && color == 2)\n    {\n      area = &Q->top16;\n      dst = area->data;\n    }\n  }\n  else\n  {\n  }\n\n  if (rows != area->rows || cols < area->columns)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  for (row = 0; row < rows; row++)\n  {\n    int col;\n    bool_t odd_row = row & 1;\n    int32_t acc[2];\n\n    for (col = 0; col < cols; col++)\n    {\n      bool_t odd_col = col & 1;\n      int32_t diff = get_true_diff(&BS, tree);\n      int32_t prev = col < 2 ? row_start_acc[odd_row][odd_col] : acc[odd_col];\n      int32_t value = prev + diff;\n\n      acc[odd_col] = value;\n      if (col < 2)\n        row_start_acc[odd_row][odd_col] = value;\n\n      /* Discard additional data at the right for binned Quattro plane 2 */\n      if (col >= area->columns)\n        continue;\n\n      *dst = value;\n      dst += area->channels;\n    }\n  }\n}\n\nstatic void true_decode(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n  int color;\n\n  for (color = 0; color < 3; color++)\n  {\n    true_decode_one_color(ID, color);\n  }\n}\n\n/* Decode use the huffman tree */\n\nstatic int32_t get_huffman_diff(bit_state_t *BS, x3f_hufftree_t *HTP)\n{\n  int32_t diff;\n  x3f_huffnode_t *node = &HTP->nodes[0];\n\n  while (node->branch[0] != NULL || node->branch[1] != NULL)\n  {\n    uint8_t bit = get_bit(BS);\n    x3f_huffnode_t *new_node = node->branch[bit];\n\n    node = new_node;\n    if (node == NULL)\n    {\n      /* TODO: Shouldn't this be treated as a fatal error? */\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n      return 0;\n    }\n  }\n\n  diff = node->leaf;\n\n  return diff;\n}\n\nstatic void huffman_decode_row(x3f_info_t *I, x3f_directory_entry_t *DE,\n                               int bits, int row, int offset, int *minimum)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n  x3f_huffman_t *HUF = ID->huffman;\n\n  int16_t c[3] = {(int16_t)offset, (int16_t)offset, (int16_t)offset};\n  int col;\n  bit_state_t BS;\n\n  if (HUF->row_offsets.element[row] > ID->data_size - 1)\n\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  set_bit_state(&BS, (uint8_t *)ID->data + HUF->row_offsets.element[row]);\n\n  for (col = 0; col < ID->columns; col++)\n  {\n    int color;\n\n    for (color = 0; color < 3; color++)\n    {\n      uint16_t c_fix;\n\n      c[color] += get_huffman_diff(&BS, &HUF->tree);\n      if (c[color] < 0)\n      {\n        c_fix = 0;\n        if (c[color] < *minimum)\n          *minimum = c[color];\n      }\n      else\n      {\n        c_fix = c[color];\n      }\n\n      switch (ID->type_format)\n      {\n      case X3F_IMAGE_RAW_HUFFMAN_X530:\n      case X3F_IMAGE_RAW_HUFFMAN_10BIT:\n        HUF->x3rgb16.data[3 * (row * ID->columns + col) + color] =\n            (uint16_t)c_fix;\n        break;\n      case X3F_IMAGE_THUMB_HUFFMAN:\n        HUF->rgb8.data[3 * (row * ID->columns + col) + color] = (uint8_t)c_fix;\n        break;\n      default:\n        /* TODO: Shouldn't this be treated as a fatal error? */\n        throw LIBRAW_EXCEPTION_IO_CORRUPT;\n      }\n    }\n  }\n}\n\nstatic void huffman_decode(x3f_info_t *I, x3f_directory_entry_t *DE, int bits)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\n  int row;\n  int minimum = 0;\n  int offset = legacy_offset;\n\n  for (row = 0; row < ID->rows; row++)\n    huffman_decode_row(I, DE, bits, row, offset, &minimum);\n\n  if (auto_legacy_offset && minimum < 0)\n  {\n    offset = -minimum;\n    for (row = 0; row < ID->rows; row++)\n      huffman_decode_row(I, DE, bits, row, offset, &minimum);\n  }\n}\n\nstatic int32_t get_simple_diff(x3f_huffman_t *HUF, uint16_t index)\n{\n  if (HUF->mapping.size == 0)\n    return index;\n  else\n    return HUF->mapping.element[index];\n}\n\nstatic void simple_decode_row(x3f_info_t *I, x3f_directory_entry_t *DE,\n                              int bits, int row, int row_stride)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n  x3f_huffman_t *HUF = ID->huffman;\n\n  if (row*row_stride > ID->data_size - (ID->columns*sizeof(uint32_t)))\n\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  uint32_t *data = (uint32_t *)((unsigned char *)ID->data + row * row_stride);\n\n  uint16_t c[3] = {0, 0, 0};\n  int col;\n\n  uint32_t mask = 0;\n\n  switch (bits)\n  {\n  case 8:\n    mask = 0x0ff;\n    break;\n  case 9:\n    mask = 0x1ff;\n    break;\n  case 10:\n    mask = 0x3ff;\n    break;\n  case 11:\n    mask = 0x7ff;\n    break;\n  case 12:\n    mask = 0xfff;\n    break;\n  default:\n    mask = 0;\n    /* TODO: Shouldn't this be treated as a fatal error? */\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n    break;\n  }\n\n  for (col = 0; col < ID->columns; col++)\n  {\n    int color;\n    uint32_t val = data[col];\n\n    for (color = 0; color < 3; color++)\n    {\n      uint16_t c_fix;\n      c[color] += get_simple_diff(HUF, (val >> (color * bits)) & mask);\n\n      switch (ID->type_format)\n      {\n      case X3F_IMAGE_RAW_HUFFMAN_X530:\n      case X3F_IMAGE_RAW_HUFFMAN_10BIT:\n        c_fix = (int16_t)c[color] > 0 ? c[color] : 0;\n\n        HUF->x3rgb16.data[3 * (row * ID->columns + col) + color] = c_fix;\n        break;\n      case X3F_IMAGE_THUMB_HUFFMAN:\n        c_fix = (int8_t)c[color] > 0 ? c[color] : 0;\n\n        HUF->rgb8.data[3 * (row * ID->columns + col) + color] = c_fix;\n        break;\n      default:\n        /* TODO: Shouldn't this be treated as a fatal error? */\n        throw LIBRAW_EXCEPTION_IO_CORRUPT;\n      }\n    }\n  }\n}\n\nstatic void simple_decode(x3f_info_t *I, x3f_directory_entry_t *DE, int bits,\n                          int row_stride)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\n  int row;\n\n  for (row = 0; row < ID->rows; row++)\n    simple_decode_row(I, DE, bits, row, row_stride);\n}\n\n/* --------------------------------------------------------------------- */\n/* Loading the data in a directory entry                                 */\n/* --------------------------------------------------------------------- */\n\n/* First you set the offset to where to start reading the data ... */\n\nstatic void read_data_set_offset(x3f_info_t *I, x3f_directory_entry_t *DE,\n                                 uint32_t header_size)\n{\n  uint32_t i_off = DE->input.offset + header_size;\n\n  I->input.file->seek(i_off, SEEK_SET);\n}\n\n/* ... then you read the data, block for block */\n\nstatic uint32_t read_data_block(void **data, x3f_info_t *I,\n                                x3f_directory_entry_t *DE, uint32_t footer)\n{\n  INT64 fpos = I->input.file->tell();\n  uint32_t size = DE->input.size + DE->input.offset - fpos - footer;\n\n  if (fpos + size > I->input.file->size())\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  *data = (void *)malloc(size);\n\n  GETN(*data, size);\n\n  return size;\n}\n\nstatic uint32_t data_block_size(void **data, x3f_info_t *I,\n                                x3f_directory_entry_t *DE, uint32_t footer)\n{\n  uint32_t size =\n      DE->input.size + DE->input.offset - I->input.file->tell() - footer;\n  return size;\n}\n\nstatic void x3f_load_image_verbatim(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n  if (!ID->data_size)\n    ID->data_size = read_data_block(&ID->data, I, DE, 0);\n}\n\nstatic int32_t x3f_load_image_verbatim_size(x3f_info_t *I,\n                                            x3f_directory_entry_t *DE)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n  return data_block_size(&ID->data, I, DE, 0);\n}\n\nstatic void x3f_load_property_list(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_property_list_t *PL = &DEH->data_subsection.property_list;\n  int i;\n\n  read_data_set_offset(I, DE, X3F_PROPERTY_LIST_HEADER_SIZE);\n\n  GET_PROPERTY_TABLE(PL->property_table, PL->num_properties);\n\n  if (!PL->data_size)\n    PL->data_size = read_data_block(&PL->data, I, DE, 0);\n  uint32_t maxoffset = PL->data_size / sizeof(utf16_t) -\n                       2; // at least 2 chars, value + terminating 0x0000\n\n  for (i = 0; i < PL->num_properties; i++)\n  {\n    x3f_property_t *P = &PL->property_table.element[i];\n    if (P->name_offset > maxoffset || P->value_offset > maxoffset)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n    P->name = ((utf16_t *)PL->data + P->name_offset);\n    P->value = ((utf16_t *)PL->data + P->value_offset);\n  }\n}\n\nstatic void x3f_load_true(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n  x3f_true_t *TRU = new_true(&ID->tru);\n  x3f_quattro_t *Q = NULL;\n  int i;\n\n  if (ID->type_format == X3F_IMAGE_RAW_QUATTRO ||\n      ID->type_format == X3F_IMAGE_RAW_SDQ ||\n      ID->type_format == X3F_IMAGE_RAW_SDQH ||\n      ID->type_format == X3F_IMAGE_RAW_SDQH2)\n  {\n    Q = new_quattro(&ID->quattro);\n\n    for (i = 0; i < TRUE_PLANES; i++)\n    {\n      GET2(Q->plane[i].columns);\n      GET2(Q->plane[i].rows);\n    }\n\n    if (Q->plane[0].rows == ID->rows / 2)\n    {\n      Q->quattro_layout = 1;\n    }\n    else if (Q->plane[0].rows == ID->rows)\n    {\n      Q->quattro_layout = 0;\n    }\n    else\n    {\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n    }\n  }\n\n  /* Read TRUE header data */\n  GET2(TRU->seed[0]);\n  GET2(TRU->seed[1]);\n  GET2(TRU->seed[2]);\n  GET2(TRU->unknown);\n  GET_TRUE_HUFF_TABLE(TRU->table);\n\n  if (ID->type_format == X3F_IMAGE_RAW_QUATTRO ||\n      ID->type_format == X3F_IMAGE_RAW_SDQ ||\n      ID->type_format == X3F_IMAGE_RAW_SDQH ||\n      ID->type_format == X3F_IMAGE_RAW_SDQH2)\n  {\n    GET4(Q->unknown);\n  }\n\n  GET_TABLE(TRU->plane_size, GET4, TRUE_PLANES, uint32_t);\n\n  /* Read image data */\n  if (!ID->data_size)\n    ID->data_size = read_data_block(&ID->data, I, DE, 0);\n\n  /* TODO: can it be fewer than 8 bits? Maybe taken from TRU->table? */\n  new_huffman_tree(&TRU->tree, 8);\n\n  populate_true_huffman_tree(&TRU->tree, &TRU->table);\n\n#ifdef DBG_PRNT\n  print_huffman_tree(TRU->tree.nodes, 0, 0);\n#endif\n\n  TRU->plane_address[0] = (uint8_t *)ID->data;\n  for (i = 1; i < TRUE_PLANES; i++)\n    TRU->plane_address[i] = TRU->plane_address[i - 1] +\n                            (((TRU->plane_size.element[i - 1] + 15) / 16) * 16);\n\n  if ((ID->type_format == X3F_IMAGE_RAW_QUATTRO ||\n       ID->type_format == X3F_IMAGE_RAW_SDQ ||\n       ID->type_format == X3F_IMAGE_RAW_SDQH ||\n       ID->type_format == X3F_IMAGE_RAW_SDQH2) &&\n      Q->quattro_layout)\n  {\n    uint32_t columns = Q->plane[0].columns;\n    uint32_t rows = Q->plane[0].rows;\n    uint32_t channels = 3;\n    uint32_t size = columns * rows * channels;\n\n    TRU->x3rgb16.columns = columns;\n    TRU->x3rgb16.rows = rows;\n    TRU->x3rgb16.channels = channels;\n    TRU->x3rgb16.row_stride = columns * channels;\n    TRU->x3rgb16.buf = malloc(sizeof(uint16_t) * size);\n    TRU->x3rgb16.data = (uint16_t *)TRU->x3rgb16.buf;\n\n    columns = Q->plane[2].columns;\n    rows = Q->plane[2].rows;\n    channels = 1;\n    size = columns * rows * channels;\n\n    Q->top16.columns = columns;\n    Q->top16.rows = rows;\n    Q->top16.channels = channels;\n    Q->top16.row_stride = columns * channels;\n    Q->top16.buf = malloc(sizeof(uint16_t) * size);\n    Q->top16.data = (uint16_t *)Q->top16.buf;\n  }\n  else\n  {\n    uint32_t size = ID->columns * ID->rows * 3;\n\n    TRU->x3rgb16.columns = ID->columns;\n    TRU->x3rgb16.rows = ID->rows;\n    TRU->x3rgb16.channels = 3;\n    TRU->x3rgb16.row_stride = ID->columns * 3;\n    TRU->x3rgb16.buf = malloc(sizeof(uint16_t) * size);\n    TRU->x3rgb16.data = (uint16_t *)TRU->x3rgb16.buf;\n  }\n\n  true_decode(I, DE);\n}\n\nstatic void x3f_load_huffman_compressed(x3f_info_t *I,\n                                        x3f_directory_entry_t *DE, int bits,\n                                        int use_map_table)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n  x3f_huffman_t *HUF = ID->huffman;\n  int table_size = 1 << bits;\n  int row_offsets_size = ID->rows * sizeof(HUF->row_offsets.element[0]);\n\n  GET_TABLE(HUF->table, GET4, table_size, uint32_t);\n\n  if (!ID->data_size)\n    ID->data_size = read_data_block(&ID->data, I, DE, row_offsets_size);\n\n  GET_TABLE(HUF->row_offsets, GET4, ID->rows, uint32_t);\n\n  new_huffman_tree(&HUF->tree, bits);\n  populate_huffman_tree(&HUF->tree, &HUF->table, &HUF->mapping);\n\n  huffman_decode(I, DE, bits);\n}\n\nstatic void x3f_load_huffman_not_compressed(x3f_info_t *I,\n                                            x3f_directory_entry_t *DE, int bits,\n                                            int use_map_table, int row_stride)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\n  if (!ID->data_size)\n    ID->data_size = read_data_block(&ID->data, I, DE, 0);\n\n  simple_decode(I, DE, bits, row_stride);\n}\n\nstatic void x3f_load_huffman(x3f_info_t *I, x3f_directory_entry_t *DE, int bits,\n                             int use_map_table, int row_stride)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n  x3f_huffman_t *HUF = new_huffman(&ID->huffman);\n  uint32_t size;\n\n  if (use_map_table)\n  {\n    int table_size = 1 << bits;\n\n    GET_TABLE(HUF->mapping, GET2, table_size, uint16_t);\n  }\n\n  switch (ID->type_format)\n  {\n  case X3F_IMAGE_RAW_HUFFMAN_X530:\n  case X3F_IMAGE_RAW_HUFFMAN_10BIT:\n    size = ID->columns * ID->rows * 3;\n    HUF->x3rgb16.columns = ID->columns;\n    HUF->x3rgb16.rows = ID->rows;\n    HUF->x3rgb16.channels = 3;\n    HUF->x3rgb16.row_stride = ID->columns * 3;\n    HUF->x3rgb16.buf = malloc(sizeof(uint16_t) * size);\n    HUF->x3rgb16.data = (uint16_t *)HUF->x3rgb16.buf;\n    break;\n  case X3F_IMAGE_THUMB_HUFFMAN:\n    size = ID->columns * ID->rows * 3;\n    HUF->rgb8.columns = ID->columns;\n    HUF->rgb8.rows = ID->rows;\n    HUF->rgb8.channels = 3;\n    HUF->rgb8.row_stride = ID->columns * 3;\n    HUF->rgb8.buf = malloc(sizeof(uint8_t) * size);\n    HUF->rgb8.data = (uint8_t *)HUF->rgb8.buf;\n    break;\n  default:\n    /* TODO: Shouldn't this be treated as a fatal error? */\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  }\n\n  if (row_stride == 0)\n    return x3f_load_huffman_compressed(I, DE, bits, use_map_table);\n  else\n    return x3f_load_huffman_not_compressed(I, DE, bits, use_map_table,\n                                           row_stride);\n}\n\nstatic void x3f_load_pixmap(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n  x3f_load_image_verbatim(I, DE);\n}\n\nstatic uint32_t x3f_load_pixmap_size(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n  return x3f_load_image_verbatim_size(I, DE);\n}\n\nstatic void x3f_load_jpeg(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n  x3f_load_image_verbatim(I, DE);\n}\n\nstatic uint32_t x3f_load_jpeg_size(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n  return x3f_load_image_verbatim_size(I, DE);\n}\n\nstatic void x3f_load_image(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\n  read_data_set_offset(I, DE, X3F_IMAGE_HEADER_SIZE);\n\n  switch (ID->type_format)\n  {\n  case X3F_IMAGE_RAW_TRUE:\n  case X3F_IMAGE_RAW_MERRILL:\n  case X3F_IMAGE_RAW_QUATTRO:\n  case X3F_IMAGE_RAW_SDQ:\n  case X3F_IMAGE_RAW_SDQH:\n  case X3F_IMAGE_RAW_SDQH2:\n    x3f_load_true(I, DE);\n    break;\n  case X3F_IMAGE_RAW_HUFFMAN_X530:\n  case X3F_IMAGE_RAW_HUFFMAN_10BIT:\n    x3f_load_huffman(I, DE, 10, 1, ID->row_stride);\n    break;\n  case X3F_IMAGE_THUMB_PLAIN:\n    x3f_load_pixmap(I, DE);\n    break;\n  case X3F_IMAGE_THUMB_HUFFMAN:\n    x3f_load_huffman(I, DE, 8, 0, ID->row_stride);\n    break;\n  case X3F_IMAGE_THUMB_JPEG:\n    x3f_load_jpeg(I, DE);\n    break;\n  default:\n    /* TODO: Shouldn't this be treated as a fatal error? */\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  }\n}\n\n// Used only for thumbnail size estimation\nstatic uint32_t x3f_load_image_size(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\n  read_data_set_offset(I, DE, X3F_IMAGE_HEADER_SIZE);\n\n  switch (ID->type_format)\n  {\n  case X3F_IMAGE_THUMB_PLAIN:\n    return x3f_load_pixmap_size(I, DE);\n  case X3F_IMAGE_THUMB_JPEG:\n    return x3f_load_jpeg_size(I, DE);\n    break;\n  default:\n    return 0;\n  }\n}\n\nstatic void x3f_load_camf_decode_type2(x3f_camf_t *CAMF)\n{\n  uint32_t key = CAMF->t2.crypt_key;\n  int i;\n\n  CAMF->decoded_data_size = CAMF->data_size;\n  CAMF->decoded_data = malloc(CAMF->decoded_data_size);\n\n  for (i = 0; i < CAMF->data_size; i++)\n  {\n    uint8_t old, _new;\n    uint32_t tmp;\n\n    old = ((uint8_t *)CAMF->data)[i];\n    key = (key * 1597 + 51749) % 244944;\n    tmp = (uint32_t)(key * ((int64_t)301593171) >> 24);\n    _new = (uint8_t)(old ^ (uint8_t)(((((key << 8) - tmp) >> 1) + tmp) >> 17));\n    ((uint8_t *)CAMF->decoded_data)[i] = _new;\n  }\n}\n\n/* NOTE: the unpacking in this code is in big respects identical to\n   true_decode_one_color(). The difference is in the output you\n   build. It might be possible to make some parts shared. NOTE ALSO:\n   This means that the meta data is obfuscated using an image\n   compression algorithm. */\n\nstatic void camf_decode_type4(x3f_camf_t *CAMF)\n{\n  uint32_t seed = CAMF->t4.decode_bias;\n  int row;\n\n  uint8_t *dst;\n  uint32_t dst_size = CAMF->t4.decoded_data_size;\n  uint8_t *dst_end;\n\n  bool_t odd_dst = 0;\n\n  x3f_hufftree_t *tree = &CAMF->tree;\n  bit_state_t BS;\n\n  int32_t row_start_acc[2][2];\n  uint32_t rows = CAMF->t4.block_count;\n  uint32_t cols = CAMF->t4.block_size;\n\n  CAMF->decoded_data_size = dst_size;\n\n  CAMF->decoded_data = malloc(CAMF->decoded_data_size);\n  memset(CAMF->decoded_data, 0, CAMF->decoded_data_size);\n\n  dst = (uint8_t *)CAMF->decoded_data;\n  dst_end = dst + dst_size;\n\n  set_bit_state(&BS, CAMF->decoding_start);\n\n  row_start_acc[0][0] = seed;\n  row_start_acc[0][1] = seed;\n  row_start_acc[1][0] = seed;\n  row_start_acc[1][1] = seed;\n\n  for (row = 0; row < rows; row++)\n  {\n    int col;\n    bool_t odd_row = row & 1;\n    int32_t acc[2];\n\n    /* We loop through all the columns and the rows. But the actual\n       data is smaller than that, so we break the loop when reaching\n       the end. */\n    for (col = 0; col < cols; col++)\n    {\n      bool_t odd_col = col & 1;\n      int32_t diff = get_true_diff(&BS, tree);\n      int32_t prev = col < 2 ? row_start_acc[odd_row][odd_col] : acc[odd_col];\n      int32_t value = prev + diff;\n\n      acc[odd_col] = value;\n      if (col < 2)\n        row_start_acc[odd_row][odd_col] = value;\n\n      switch (odd_dst)\n      {\n      case 0:\n        *dst++ = (uint8_t)((value >> 4) & 0xff);\n\n        if (dst >= dst_end)\n        {\n          goto ready;\n        }\n\n        *dst = (uint8_t)((value << 4) & 0xf0);\n        break;\n      case 1:\n        *dst++ |= (uint8_t)((value >> 8) & 0x0f);\n\n        if (dst >= dst_end)\n        {\n          goto ready;\n        }\n\n        *dst++ = (uint8_t)((value << 0) & 0xff);\n\n        if (dst >= dst_end)\n        {\n          goto ready;\n        }\n\n        break;\n      }\n\n      odd_dst = !odd_dst;\n    } /* end col */\n  }   /* end row */\n\nready:;\n}\n\nstatic void x3f_load_camf_decode_type4(x3f_camf_t *CAMF)\n{\n  int i;\n  uint8_t *p;\n  x3f_true_huffman_element_t *element = NULL;\n\n  for (i = 0, p = (uint8_t *)CAMF->data; *p != 0; i++)\n  {\n    /* TODO: Is this too expensive ??*/\n    element = (x3f_true_huffman_element_t *)realloc(element,\n                                                    (i + 1) * sizeof(*element));\n\n    element[i].code_size = *p++;\n    element[i].code = *p++;\n  }\n\n  CAMF->table.size = i;\n  CAMF->table.element = element;\n\n  /* TODO: where does the values 28 and 32 come from? */\n#define CAMF_T4_DATA_SIZE_OFFSET 28\n#define CAMF_T4_DATA_OFFSET 32\n  CAMF->decoding_size =\n      *(uint32_t *)((unsigned char *)CAMF->data + CAMF_T4_DATA_SIZE_OFFSET);\n  CAMF->decoding_start = (uint8_t *)CAMF->data + CAMF_T4_DATA_OFFSET;\n\n  /* TODO: can it be fewer than 8 bits? Maybe taken from TRU->table? */\n  new_huffman_tree(&CAMF->tree, 8);\n\n  populate_true_huffman_tree(&CAMF->tree, &CAMF->table);\n\n#ifdef DBG_PRNT\n  print_huffman_tree(CAMF->tree.nodes, 0, 0);\n#endif\n\n  camf_decode_type4(CAMF);\n}\n\nstatic void camf_decode_type5(x3f_camf_t *CAMF)\n{\n  int32_t acc = CAMF->t5.decode_bias;\n\n  uint8_t *dst;\n\n  x3f_hufftree_t *tree = &CAMF->tree;\n  bit_state_t BS;\n\n  int32_t i;\n\n  CAMF->decoded_data_size = CAMF->t5.decoded_data_size;\n  CAMF->decoded_data = malloc(CAMF->decoded_data_size);\n\n  dst = (uint8_t *)CAMF->decoded_data;\n\n  set_bit_state(&BS, CAMF->decoding_start);\n\n  for (i = 0; i < CAMF->decoded_data_size; i++)\n  {\n    int32_t diff = get_true_diff(&BS, tree);\n\n    acc = acc + diff;\n    *dst++ = (uint8_t)(acc & 0xff);\n  }\n}\n\nstatic void x3f_load_camf_decode_type5(x3f_camf_t *CAMF)\n{\n  int i;\n  uint8_t *p;\n  x3f_true_huffman_element_t *element = NULL;\n\n  for (i = 0, p = (uint8_t *)CAMF->data; *p != 0; i++)\n  {\n    /* TODO: Is this too expensive ??*/\n    element = (x3f_true_huffman_element_t *)realloc(element,\n                                                    (i + 1) * sizeof(*element));\n\n    element[i].code_size = *p++;\n    element[i].code = *p++;\n  }\n\n  CAMF->table.size = i;\n  CAMF->table.element = element;\n\n  /* TODO: where does the values 28 and 32 come from? */\n#define CAMF_T5_DATA_SIZE_OFFSET 28\n#define CAMF_T5_DATA_OFFSET 32\n  CAMF->decoding_size =\n      *(uint32_t *)((uint8_t *)CAMF->data + CAMF_T5_DATA_SIZE_OFFSET);\n  CAMF->decoding_start = (uint8_t *)CAMF->data + CAMF_T5_DATA_OFFSET;\n\n  /* TODO: can it be fewer than 8 bits? Maybe taken from TRU->table? */\n  new_huffman_tree(&CAMF->tree, 8);\n\n  populate_true_huffman_tree(&CAMF->tree, &CAMF->table);\n\n#ifdef DBG_PRNT\n  print_huffman_tree(CAMF->tree.nodes, 0, 0);\n#endif\n\n  camf_decode_type5(CAMF);\n}\n\nstatic void x3f_setup_camf_text_entry(camf_entry_t *entry)\n{\n  entry->text_size = *(uint32_t *)entry->value_address;\n  entry->text = (char *)entry->value_address + 4;\n}\n\nstatic void x3f_setup_camf_property_entry(camf_entry_t *entry)\n{\n  int i;\n  uint8_t *e = (uint8_t *)entry->entry;\n  uint8_t *v = (uint8_t *)entry->value_address;\n  uint32_t num = entry->property_num = *(uint32_t *)v;\n  uint32_t off = *(uint32_t *)(v + 4);\n\n  entry->property_name = (char **)malloc(num * sizeof(uint8_t *));\n  entry->property_value = (uint8_t **)malloc(num * sizeof(uint8_t *));\n\n  for (i = 0; i < num; i++)\n  {\n    uint32_t name_off = off + *(uint32_t *)(v + 8 + 8 * i);\n    uint32_t value_off = off + *(uint32_t *)(v + 8 + 8 * i + 4);\n\n    entry->property_name[i] = (char *)(e + name_off);\n    entry->property_value[i] = e + value_off;\n  }\n}\n\nstatic void set_matrix_element_info(uint32_t type, uint32_t *size,\n                                    matrix_type_t *decoded_type)\n{\n  switch (type)\n  {\n  case 0:\n    *size = 2;\n    *decoded_type = M_INT; /* known to be true */\n    break;\n  case 1:\n    *size = 4;\n    *decoded_type = M_UINT; /* TODO: unknown ???? */\n    break;\n  case 2:\n    *size = 4;\n    *decoded_type = M_UINT; /* TODO: unknown ???? */\n    break;\n  case 3:\n    *size = 4;\n    *decoded_type = M_FLOAT; /* known to be true */\n    break;\n  case 5:\n    *size = 1;\n    *decoded_type = M_UINT; /* TODO: unknown ???? */\n    break;\n  case 6:\n    *size = 2;\n    *decoded_type = M_UINT; /* TODO: unknown ???? */\n    break;\n  default:\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  }\n}\n\nstatic void get_matrix_copy(camf_entry_t *entry)\n{\n  uint32_t element_size = entry->matrix_element_size;\n  uint32_t elements = entry->matrix_elements;\n  int i, size = (entry->matrix_decoded_type == M_FLOAT ? sizeof(double)\n                                                       : sizeof(uint32_t)) *\n                elements;\n\n  entry->matrix_decoded = malloc(size);\n\n  switch (element_size)\n  {\n  case 4:\n    switch (entry->matrix_decoded_type)\n    {\n    case M_INT:\n    case M_UINT:\n      memcpy(entry->matrix_decoded, entry->matrix_data, size);\n      break;\n    case M_FLOAT:\n      for (i = 0; i < elements; i++)\n        ((double *)entry->matrix_decoded)[i] =\n            (double)((float *)entry->matrix_data)[i];\n      break;\n    default:\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n    }\n    break;\n  case 2:\n    switch (entry->matrix_decoded_type)\n    {\n    case M_INT:\n      for (i = 0; i < elements; i++)\n        ((int32_t *)entry->matrix_decoded)[i] =\n            (int32_t)((int16_t *)entry->matrix_data)[i];\n      break;\n    case M_UINT:\n      for (i = 0; i < elements; i++)\n        ((uint32_t *)entry->matrix_decoded)[i] =\n            (uint32_t)((uint16_t *)entry->matrix_data)[i];\n      break;\n    default:\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n    }\n    break;\n  case 1:\n    switch (entry->matrix_decoded_type)\n    {\n    case M_INT:\n      for (i = 0; i < elements; i++)\n        ((int32_t *)entry->matrix_decoded)[i] =\n            (int32_t)((int8_t *)entry->matrix_data)[i];\n      break;\n    case M_UINT:\n      for (i = 0; i < elements; i++)\n        ((uint32_t *)entry->matrix_decoded)[i] =\n            (uint32_t)((uint8_t *)entry->matrix_data)[i];\n      break;\n    default:\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n    }\n    break;\n  default:\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  }\n}\n\nstatic void x3f_setup_camf_matrix_entry(camf_entry_t *entry)\n{\n  int i;\n  int totalsize = 1;\n\n  uint8_t *e = (uint8_t *)entry->entry;\n  uint8_t *v = (uint8_t *)entry->value_address;\n  uint32_t type = entry->matrix_type = *(uint32_t *)(v + 0);\n  uint32_t dim = entry->matrix_dim = *(uint32_t *)(v + 4);\n  uint32_t off = entry->matrix_data_off = *(uint32_t *)(v + 8);\n  camf_dim_entry_t *dentry = entry->matrix_dim_entry =\n      (camf_dim_entry_t *)malloc(dim * sizeof(camf_dim_entry_t));\n\n  for (i = 0; i < dim; i++)\n  {\n    uint32_t size = dentry[i].size = *(uint32_t *)(v + 12 + 12 * i + 0);\n    dentry[i].name_offset = *(uint32_t *)(v + 12 + 12 * i + 4);\n    dentry[i].n = *(uint32_t *)(v + 12 + 12 * i + 8);\n    dentry[i].name = (char *)(e + dentry[i].name_offset);\n\n    if (dentry[i].n != i)\n    {\n    }\n\n    totalsize *= size;\n  }\n\n  set_matrix_element_info(type, &entry->matrix_element_size,\n                          &entry->matrix_decoded_type);\n  entry->matrix_data = (void *)(e + off);\n\n  entry->matrix_elements = totalsize;\n  entry->matrix_used_space = entry->entry_size - off;\n\n  /* This estimate only works for matrices above a certain size */\n  entry->matrix_estimated_element_size = entry->matrix_used_space / totalsize;\n\n  get_matrix_copy(entry);\n}\n\nstatic void x3f_setup_camf_entries(x3f_camf_t *CAMF)\n{\n  uint8_t *p = (uint8_t *)CAMF->decoded_data;\n  uint8_t *end = p + CAMF->decoded_data_size;\n  camf_entry_t *entry = NULL;\n  int i;\n\n  for (i = 0; p < end; i++)\n  {\n    uint32_t *p4 = (uint32_t *)p;\n\n    switch (*p4)\n    {\n    case X3F_CMbP:\n    case X3F_CMbT:\n    case X3F_CMbM:\n      break;\n    default:\n      goto stop;\n    }\n\n    /* TODO: lots of realloc - may be inefficient */\n    entry = (camf_entry_t *)realloc(entry, (i + 1) * sizeof(camf_entry_t));\n\n    /* Pointer */\n    entry[i].entry = p;\n\n    /* Header */\n    entry[i].id = *p4++;\n    entry[i].version = *p4++;\n    entry[i].entry_size = *p4++;\n    entry[i].name_offset = *p4++;\n    entry[i].value_offset = *p4++;\n\n    /* Compute adresses and sizes */\n    entry[i].name_address = (char *)(p + entry[i].name_offset);\n    entry[i].value_address = p + entry[i].value_offset;\n    entry[i].name_size = entry[i].value_offset - entry[i].name_offset;\n    entry[i].value_size = entry[i].entry_size - entry[i].value_offset;\n\n    entry[i].text_size = 0;\n    entry[i].text = NULL;\n    entry[i].property_num = 0;\n    entry[i].property_name = NULL;\n    entry[i].property_value = NULL;\n    entry[i].matrix_type = 0;\n    entry[i].matrix_dim = 0;\n    entry[i].matrix_data_off = 0;\n    entry[i].matrix_data = NULL;\n    entry[i].matrix_dim_entry = NULL;\n\n    entry[i].matrix_decoded = NULL;\n\n    switch (entry[i].id)\n    {\n    case X3F_CMbP:\n      x3f_setup_camf_property_entry(&entry[i]);\n      break;\n    case X3F_CMbT:\n      x3f_setup_camf_text_entry(&entry[i]);\n      break;\n    case X3F_CMbM:\n      x3f_setup_camf_matrix_entry(&entry[i]);\n      break;\n    }\n\n    p += entry[i].entry_size;\n  }\n\nstop:\n\n  CAMF->entry_table.size = i;\n  CAMF->entry_table.element = entry;\n}\n\nstatic void x3f_load_camf(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_camf_t *CAMF = &DEH->data_subsection.camf;\n\n  read_data_set_offset(I, DE, X3F_CAMF_HEADER_SIZE);\n\n  if (!CAMF->data_size)\n    CAMF->data_size = read_data_block(&CAMF->data, I, DE, 0);\n\n  switch (CAMF->type)\n  {\n  case 2: /* Older SD9-SD14 */\n    x3f_load_camf_decode_type2(CAMF);\n    break;\n  case 4: /* TRUE ... Merrill */\n    x3f_load_camf_decode_type4(CAMF);\n    break;\n  case 5: /* Quattro ... */\n    x3f_load_camf_decode_type5(CAMF);\n    break;\n  default:\n    /* TODO: Shouldn't this be treated as a fatal error? */\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  }\n\n  if (CAMF->decoded_data != NULL)\n    x3f_setup_camf_entries(CAMF);\n  else\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n}\n\n/* extern */ x3f_return_t x3f_load_data(x3f_t *x3f, x3f_directory_entry_t *DE)\n{\n  x3f_info_t *I = &x3f->info;\n\n  if (DE == NULL)\n    return X3F_ARGUMENT_ERROR;\n\n  switch (DE->header.identifier)\n  {\n  case X3F_SECp:\n    x3f_load_property_list(I, DE);\n    break;\n  case X3F_SECi:\n    x3f_load_image(I, DE);\n    break;\n  case X3F_SECc:\n    x3f_load_camf(I, DE);\n    break;\n  default:\n    return X3F_INTERNAL_ERROR;\n  }\n  return X3F_OK;\n}\n\n/* extern */ int64_t x3f_load_data_size(x3f_t *x3f, x3f_directory_entry_t *DE)\n{\n  x3f_info_t *I = &x3f->info;\n\n  if (DE == NULL)\n    return -1;\n\n  switch (DE->header.identifier)\n  {\n  case X3F_SECi:\n    return x3f_load_image_size(I, DE);\n  default:\n    return 0;\n  }\n}\n\n/* extern */ x3f_return_t x3f_load_image_block(x3f_t *x3f,\n                                               x3f_directory_entry_t *DE)\n{\n  x3f_info_t *I = &x3f->info;\n\n  if (DE == NULL)\n    return X3F_ARGUMENT_ERROR;\n\n  switch (DE->header.identifier)\n  {\n  case X3F_SECi:\n    read_data_set_offset(I, DE, X3F_IMAGE_HEADER_SIZE);\n    x3f_load_image_verbatim(I, DE);\n    break;\n  default:\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n    return X3F_INTERNAL_ERROR;\n  }\n\n  return X3F_OK;\n}\n\n/* --------------------------------------------------------------------- */\n/* The End                                                               */\n/* --------------------------------------------------------------------- */\n"], "filenames": ["src/x3f/x3f_utils_patched.cpp"], "buggy_code_start_loc": [1124], "buggy_code_end_loc": [1124], "fixing_code_start_loc": [1125], "fixing_code_end_loc": [1127], "type": "CWE-125", "message": "In LibRaw, an out-of-bounds read vulnerability exists within the \"simple_decode_row()\" function (libraw\\src\\x3f\\x3f_utils_patched.cpp) which can be triggered via an image with a large row_stride field.", "other": {"cve": {"id": "CVE-2020-35532", "sourceIdentifier": "secalert@redhat.com", "published": "2022-09-01T18:15:08.870", "lastModified": "2022-09-29T16:29:46.417", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In LibRaw, an out-of-bounds read vulnerability exists within the \"simple_decode_row()\" function (libraw\\src\\x3f\\x3f_utils_patched.cpp) which can be triggered via an image with a large row_stride field."}, {"lang": "es", "value": "En LibRaw, se presenta una vulnerabilidad de lectura fuera de l\u00edmites dentro de la funci\u00f3n \"simple_decode_row()\" (libraw\\src\\x3f\\x3f_utils_patched.cpp) que puede desencadenarse por medio de una imagen con un campo row_stride grande"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.20.0:-:*:*:*:*:*:*", "matchCriteriaId": "E00F0C8F-11AC-42B2-8D85-27028B41EBF3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.20.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "B4B8669B-CE7F-47D2-9111-E7787EAD6E7E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.20.1:*:*:*:*:*:*:*", "matchCriteriaId": "8269B02E-558F-4AA5-9EEA-87226A3D1816"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.20.2:*:*:*:*:*:*:*", "matchCriteriaId": "06DBABB8-8921-4E8B-B9E5-FFE6CCE79EB9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.21.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "36C296E2-1899-457B-9EB2-916A33E383C2"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/LibRaw/LibRaw/commit/5ab45b085898e379fedc6b113e2e82a890602b1e", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/LibRaw/LibRaw/issues/271", "source": "secalert@redhat.com", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/09/msg00024.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LibRaw/LibRaw/commit/5ab45b085898e379fedc6b113e2e82a890602b1e"}}