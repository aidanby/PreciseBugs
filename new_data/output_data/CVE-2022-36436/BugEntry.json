{"buggy_code": ["import unittest\n\nfrom vncap.vnc.protocol import VNCServerAuthenticator\n\nclass DummyTransport(object):\n\n    buf = \"\"\n    lost = False\n\n    def write(self, data):\n        self.buf += data\n\n    def loseConnection(self):\n        self.lost = True\n\nclass TestVNCServerAuthenticator(unittest.TestCase):\n\n    def setUp(self):\n        self.p = VNCServerAuthenticator(\"password\", {})\n        self.t = DummyTransport()\n        self.p.makeConnection(self.t)\n\n    def test_trivial(self):\n        pass\n\n    def test_connectionMade(self):\n        self.assertEqual(self.t.buf, \"RFB 003.008\\n\")\n\n    def test_check_version(self):\n        self.t.buf = \"\"\n        self.p.check_version(\"RFB 003.008\\n\")\n        self.assertEqual(self.t.buf, \"\\x02\\x01\\x02\")\n\n    def test_check_invalid_version(self):\n        self.t.buf = \"\"\n        self.p.check_version(\"RFB 002.000\\n\")\n        self.assertTrue(self.t.lost)\n", "from os import urandom\n\nfrom twisted.internet import reactor\nfrom twisted.internet.defer import Deferred\nfrom twisted.protocols.stateful import StatefulProtocol\nfrom twisted.python import log\n\nfrom vncap.vnc.d3des import generate_response\n\ndef check_password(challenge, response, password):\n    password = password.ljust(8, \"\\x00\")[:8]\n    return generate_response(password, challenge) == response\n\n(\n    STATE_VERSION,\n    STATE_SECURITY_TYPES,\n    STATE_AUTHENTICATION,\n    STATE_RESULT,\n    STATE_CONNECTED\n) = range(5)\n\nclass VNCAuthenticator(StatefulProtocol):\n    \"\"\"\n    Base class for VNC protocols.\n\n    This protocol isn't interesting on its own; subclass it to make a server\n    or client.\n    \"\"\"\n\n    VERSION = \"RFB 003.008\\n\"\n\n    def __init__(self, password):\n        self.password = password\n        self.authentication_d = Deferred()\n\n    def authenticated(self):\n        \"\"\"\n        Switch to proxy mode.\n        \"\"\"\n\n        log.msg(\"Successfully authenticated %s!\" % self)\n        self.transport.pauseProducing()\n        reactor.callLater(0, self.authentication_d.callback, self)\n\nclass VNCServerAuthenticator(VNCAuthenticator):\n    \"\"\"\n    Trivial server protocol which can authenticate VNC clients.\n\n    This protocol is lacking lots of things, like support for older VNC\n    protocols.\n    \"\"\"\n\n    def __init__(self, password, options):\n        VNCAuthenticator.__init__(self, password)\n        self.options = options\n\n        if 'password' in options:\n            self.password = options['password']\n\n    def connectionMade(self):\n        log.msg(\"Received incoming connection\")\n        self.transport.write(self.VERSION)\n\n    def getInitialState(self):\n        self.verify_ip()\n        return self.check_version, 12\n\n    def check_version(self, version):\n        \"\"\"\n        Determine the client's version and decide whether to continue the\n        handshake.\n        \"\"\"\n\n        if version == self.VERSION:\n            log.msg(\"Client version %s is valid\" % version.strip())\n            # Hardcoded: 2 security types: None and VNC Auth.\n            self.transport.write(\"\\x02\\x01\\x02\")\n            return self.select_security_type, 1\n        else:\n            log.err(\"Can't handle VNC version %r\" % version)\n            self.transport.loseConnection()\n\n    def select_security_type(self, security_type):\n        \"\"\"\n        Choose the security type that the client wants.\n        \"\"\"\n\n        security_type = ord(security_type)\n\n        if security_type == 2:\n            # VNC authentication. Issue our challenge.\n            self.challenge = urandom(16)\n            self.transport.write(self.challenge)\n\n            return self.vnc_authentication_result, 16\n        elif security_type == 1:\n            # No authentication. Just move to the SecurityResult.\n            self.authenticated()\n        else:\n            log.err(\"Couldn't agree on an authentication scheme!\")\n            self.transport.loseConnection()\n\n    def vnc_authentication_result(self, response):\n        log.msg(\"Doing VNC auth, buf %r\" % response)\n\n        if check_password(self.challenge, response, self.password):\n            self.authenticated()\n        else:\n            log.err(\"Failed VNC auth!\")\n            self.transport.loseConnection()\n\n    def verify_ip(self):\n        if 'ip' in self.options:\n            if self.options['ip'] != self.transport.getPeer().host:\n                log.err(\"Failed to verify client IP\")\n                self.transport.loseConnection()\n            else:\n                log.msg(\"Verified client IP\")\n\n    def authenticated(self):\n        log.msg(\"Successfully authenticated a client!\")\n        # Send a u32 0, for success.\n        self.transport.write(\"\\x00\\x00\\x00\\x00\")\n        VNCAuthenticator.authenticated(self)\n\nclass VNCClientAuthenticator(VNCAuthenticator):\n    \"\"\"\n    Trivial client protocol which can authenticate itself to a VNC server.\n\n    This protocol is lacking lots of things, like support for older VNC\n    protocols.\n    \"\"\"\n\n    def getInitialState(self):\n        return self.check_version, 12\n\n    def check_version(self, version):\n        if version == self.VERSION:\n            log.msg(\"Server version %s is valid\" % version.strip())\n            self.transport.write(self.VERSION)\n            return self.count_security_types, 1\n        else:\n            log.err(\"Can't handle VNC version %r\" % version)\n            self.transport.loseConnection()\n\n    def count_security_types(self, data):\n        count = ord(data)\n\n        if not count:\n            log.err(\"Server wouldn't give us any security types!\")\n            self.transport.loseConnection()\n\n        return self.pick_security_type, count\n\n    def pick_security_type(self, data):\n        \"\"\"\n        Ascertain whether the server supports any security types we might\n        want.\n        \"\"\"\n\n        security_types = set(ord(i) for i in data)\n        log.msg(\"Available authentication methods: %s\"\n            % \", \".join(hex(i) for i in security_types))\n\n        if 2 in security_types:\n            log.msg(\"Choosing VNC authentication...\")\n            self.transport.write(\"\\x02\")\n            return self.vnc_authentication, 16\n        elif 1 in security_types:\n            log.msg(\"Choosing no authentication...\")\n            self.transport.write(\"\\x01\")\n            return self.security_result, 4\n        else:\n            log.err(\"Couldn't agree on an authentication scheme!\")\n            self.transport.loseConnection()\n\n    def vnc_authentication(self, challenge):\n        # Take in 16 bytes, encrypt with 3DES using the password as the key,\n        # and send the response.\n\n        response = generate_response(self.password, challenge)\n        self.transport.write(response)\n\n        return self.security_result, 4\n\n    def security_result(self, data):\n        if data == \"\\x00\\x00\\x00\\x00\":\n            # Success!\n            log.msg(\"Successfully authenticated to the server!\")\n            self.authenticated()\n        else:\n            log.err(\"Failed security result!\")\n            self.transport.loseConnection()\n"], "fixing_code": ["import unittest\n\nfrom vncap.vnc.protocol import VNCServerAuthenticator\n\nclass DummyTransport(object):\n\n    buf = \"\"\n    lost = False\n\n    def write(self, data):\n        self.buf += data\n\n    def loseConnection(self):\n        self.lost = True\n\n    def pauseProducing(self):\n        pass\n\nclass TestVNCServerAuthenticator(unittest.TestCase):\n\n    def setUp(self):\n        self.p = VNCServerAuthenticator(\"password\", {})\n        self.t = DummyTransport()\n        self.p.makeConnection(self.t)\n\n    def test_trivial(self):\n        pass\n\n    def test_connectionMade(self):\n        self.assertEqual(self.t.buf, \"RFB 003.008\\n\")\n\n    def test_check_version(self):\n        self.t.buf = \"\"\n        self.p.check_version(\"RFB 003.008\\n\")\n        self.assertEqual(self.t.buf, \"\\x01\\x02\")\n\n    def test_check_invalid_version(self):\n        self.t.buf = \"\"\n        self.p.check_version(\"RFB 002.000\\n\")\n        self.assertTrue(self.t.lost)\n\n    def test_select_security_type_none(self):\n        self.t.buf = \"\"\n        self.p.select_security_type(\"\\x01\")\n        self.assertTrue(self.t.lost)\n\n    def test_select_security_type_vnc_auth(self):\n        self.t.buf = \"\"\n        self.p.select_security_type(\"\\x02\")\n        self.assertFalse(self.t.lost)\n        self.assertEqual(len(self.t.buf), 16)\n", "from os import urandom\n\nfrom twisted.internet import reactor\nfrom twisted.internet.defer import Deferred\nfrom twisted.protocols.stateful import StatefulProtocol\nfrom twisted.python import log\n\nfrom vncap.vnc.d3des import generate_response\n\ndef check_password(challenge, response, password):\n    password = password.ljust(8, \"\\x00\")[:8]\n    return generate_response(password, challenge) == response\n\n(\n    STATE_VERSION,\n    STATE_SECURITY_TYPES,\n    STATE_AUTHENTICATION,\n    STATE_RESULT,\n    STATE_CONNECTED\n) = range(5)\n\nclass VNCAuthenticator(StatefulProtocol):\n    \"\"\"\n    Base class for VNC protocols.\n\n    This protocol isn't interesting on its own; subclass it to make a server\n    or client.\n    \"\"\"\n\n    VERSION = \"RFB 003.008\\n\"\n\n    def __init__(self, password):\n        self.password = password\n        self.authentication_d = Deferred()\n\n    def authenticated(self):\n        \"\"\"\n        Switch to proxy mode.\n        \"\"\"\n\n        log.msg(\"Successfully authenticated %s!\" % self)\n        self.transport.pauseProducing()\n        reactor.callLater(0, self.authentication_d.callback, self)\n\nclass VNCServerAuthenticator(VNCAuthenticator):\n    \"\"\"\n    Trivial server protocol which can authenticate VNC clients.\n\n    This protocol is lacking lots of things, like support for older VNC\n    protocols.\n    \"\"\"\n\n    def __init__(self, password, options):\n        VNCAuthenticator.__init__(self, password)\n        self.options = options\n\n        if 'password' in options:\n            self.password = options['password']\n\n    def connectionMade(self):\n        log.msg(\"Received incoming connection\")\n        self.transport.write(self.VERSION)\n\n    def getInitialState(self):\n        self.verify_ip()\n        return self.check_version, 12\n\n    def check_version(self, version):\n        \"\"\"\n        Determine the client's version and decide whether to continue the\n        handshake.\n        \"\"\"\n\n        if version == self.VERSION:\n            log.msg(\"Client version %s is valid\" % version.strip())\n            # Hardcoded: 1 security type: VNC Auth.\n            self.transport.write(\"\\x01\\x02\")\n            return self.select_security_type, 1\n        else:\n            log.err(\"Can't handle VNC version %r\" % version)\n            self.transport.loseConnection()\n\n    def select_security_type(self, security_type):\n        \"\"\"\n        Choose the security type that the client wants.\n        \"\"\"\n\n        security_type = ord(security_type)\n\n        if security_type == 2:\n            # VNC authentication. Issue our challenge.\n            self.challenge = urandom(16)\n            self.transport.write(self.challenge)\n\n            return self.vnc_authentication_result, 16\n        else:\n            log.err(\"Couldn't agree on an authentication scheme!\")\n            self.transport.loseConnection()\n\n    def vnc_authentication_result(self, response):\n        log.msg(\"Doing VNC auth, buf %r\" % response)\n\n        if check_password(self.challenge, response, self.password):\n            self.authenticated()\n        else:\n            log.err(\"Failed VNC auth!\")\n            self.transport.loseConnection()\n\n    def verify_ip(self):\n        if 'ip' in self.options:\n            if self.options['ip'] != self.transport.getPeer().host:\n                log.err(\"Failed to verify client IP\")\n                self.transport.loseConnection()\n            else:\n                log.msg(\"Verified client IP\")\n\n    def authenticated(self):\n        log.msg(\"Successfully authenticated a client!\")\n        # Send a u32 0, for success.\n        self.transport.write(\"\\x00\\x00\\x00\\x00\")\n        VNCAuthenticator.authenticated(self)\n\nclass VNCClientAuthenticator(VNCAuthenticator):\n    \"\"\"\n    Trivial client protocol which can authenticate itself to a VNC server.\n\n    This protocol is lacking lots of things, like support for older VNC\n    protocols.\n    \"\"\"\n\n    def getInitialState(self):\n        return self.check_version, 12\n\n    def check_version(self, version):\n        if version == self.VERSION:\n            log.msg(\"Server version %s is valid\" % version.strip())\n            self.transport.write(self.VERSION)\n            return self.count_security_types, 1\n        else:\n            log.err(\"Can't handle VNC version %r\" % version)\n            self.transport.loseConnection()\n\n    def count_security_types(self, data):\n        count = ord(data)\n\n        if not count:\n            log.err(\"Server wouldn't give us any security types!\")\n            self.transport.loseConnection()\n\n        return self.pick_security_type, count\n\n    def pick_security_type(self, data):\n        \"\"\"\n        Ascertain whether the server supports any security types we might\n        want.\n        \"\"\"\n\n        security_types = set(ord(i) for i in data)\n        log.msg(\"Available authentication methods: %s\"\n            % \", \".join(hex(i) for i in security_types))\n\n        if 2 in security_types:\n            log.msg(\"Choosing VNC authentication...\")\n            self.transport.write(\"\\x02\")\n            return self.vnc_authentication, 16\n        elif 1 in security_types:\n            log.msg(\"Choosing no authentication...\")\n            self.transport.write(\"\\x01\")\n            return self.security_result, 4\n        else:\n            log.err(\"Couldn't agree on an authentication scheme!\")\n            self.transport.loseConnection()\n\n    def vnc_authentication(self, challenge):\n        # Take in 16 bytes, encrypt with 3DES using the password as the key,\n        # and send the response.\n\n        response = generate_response(self.password, challenge)\n        self.transport.write(response)\n\n        return self.security_result, 4\n\n    def security_result(self, data):\n        if data == \"\\x00\\x00\\x00\\x00\":\n            # Success!\n            log.msg(\"Successfully authenticated to the server!\")\n            self.authenticated()\n        else:\n            log.err(\"Failed security result!\")\n            self.transport.loseConnection()\n"], "filenames": ["vncap/tests/test_protocol.py", "vncap/vnc/protocol.py"], "buggy_code_start_loc": [14, 76], "buggy_code_end_loc": [37, 99], "fixing_code_start_loc": [15, 76], "fixing_code_end_loc": [52, 95], "type": "CWE-287", "message": "OSU Open Source Lab VNCAuthProxy through 1.1.1 is affected by an vncap/vnc/protocol.py VNCServerAuthenticator authentication-bypass vulnerability that could allow a malicious actor to gain unauthorized access to a VNC session or to disconnect a legitimate user from a VNC session. A remote attacker with network access to the proxy server could leverage this vulnerability to connect to VNC servers protected by the proxy server without providing any authentication credentials. Exploitation of this issue requires that the proxy server is currently accepting connections for the target VNC server.", "other": {"cve": {"id": "CVE-2022-36436", "sourceIdentifier": "cve@mitre.org", "published": "2022-09-14T11:15:49.567", "lastModified": "2022-09-16T03:00:00.797", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OSU Open Source Lab VNCAuthProxy through 1.1.1 is affected by an vncap/vnc/protocol.py VNCServerAuthenticator authentication-bypass vulnerability that could allow a malicious actor to gain unauthorized access to a VNC session or to disconnect a legitimate user from a VNC session. A remote attacker with network access to the proxy server could leverage this vulnerability to connect to VNC servers protected by the proxy server without providing any authentication credentials. Exploitation of this issue requires that the proxy server is currently accepting connections for the target VNC server."}, {"lang": "es", "value": "OSU Open Source Lab VNCAuthProxy versiones hasta 1.1.1, est\u00e1 afectado por una vulnerabilidad de omisi\u00f3n de autenticaci\u00f3n en el archivo vncap/vnc/protocol.py VNCServerAuthenticator que podr\u00eda permitir a un actor malicioso conseguir acceso no autorizado a una sesi\u00f3n VNC o desconectar a un usuario leg\u00edtimo de una sesi\u00f3n VNC. Un atacante remoto con acceso a la red del servidor proxy podr\u00eda aprovechar esta vulnerabilidad para conectarse a servidores VNC protegidos por el servidor proxy sin proporcionar ninguna credencial de autenticaci\u00f3n. Una explotaci\u00f3n de este problema requiere que el servidor proxy est\u00e9 aceptando conexiones para el servidor VNC objetivo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:osuosl:twisted_vnc_authentication_proxy:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.0", "matchCriteriaId": "DA00DF11-4523-48CD-BA7F-CB23F00D620D"}]}]}], "references": [{"url": "https://cert.grnet.gr/en/blog/cve-2022-36436-twisted-vnc-authentication-proxy-authentication-bypass/", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/osuosl/twisted_vncauthproxy/commit/edc149af29242178091b2d6fcd42c3ef0851644b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/osuosl/twisted_vncauthproxy/tree/release/1.1.1", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://pypi.org/project/VNCAuthProxy/", "source": "cve@mitre.org", "tags": ["Product", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/osuosl/twisted_vncauthproxy/commit/edc149af29242178091b2d6fcd42c3ef0851644b"}}