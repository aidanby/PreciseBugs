{"buggy_code": ["/*\n * Copyright (C) 1996-2023 The Squid Software Foundation and contributors\n *\n * Squid software is distributed under GPLv2+ license and includes\n * contributions from numerous individuals and organizations.\n * Please see the COPYING and CONTRIBUTORS files for details.\n */\n\n#include \"squid.h\"\n#include \"anyp/PortCfg.h\"\n#include \"client_side.h\"\n#include \"comm.h\"\n#include \"comm/Read.h\"\n#include \"debug/Stream.h\"\n#include \"error/SysErrorDetail.h\"\n#include \"fd.h\"\n#include \"fde.h\"\n#include \"http/Stream.h\"\n#include \"LogTags.h\"\n#include \"MasterXaction.h\"\n#include \"servers/Server.h\"\n#include \"SquidConfig.h\"\n#include \"StatCounters.h\"\n#include \"tools.h\"\n\nServer::Server(const MasterXaction::Pointer &xact) :\n    AsyncJob(\"::Server\"), // kids overwrite\n    clientConnection(xact->tcpClient),\n    transferProtocol(xact->squidPort->transport),\n    port(xact->squidPort),\n    receivedFirstByte_(false)\n{\n    clientConnection->leaveOrphanage();\n}\n\nbool\nServer::doneAll() const\n{\n    // servers are not done while the connection is open\n    return !Comm::IsConnOpen(clientConnection) &&\n           BodyProducer::doneAll();\n}\n\nvoid\nServer::start()\n{\n    // TODO: shuffle activity from ConnStateData\n}\n\nvoid\nServer::swanSong()\n{\n    if (Comm::IsConnOpen(clientConnection))\n        clientConnection->close();\n\n    BodyProducer::swanSong();\n}\n\nvoid\nServer::stopReading()\n{\n    if (reading()) {\n        Comm::ReadCancel(clientConnection->fd, reader);\n        reader = nullptr;\n    }\n}\n\n/// Prepare inBuf for I/O. This method balances several conflicting desires:\n/// 1. Do not read too few bytes at a time.\n/// 2. Do not waste too much buffer space.\n/// 3. Do not [re]allocate or memmove the buffer too much.\n/// 4. Obey Config.maxRequestBufferSize limit.\nvoid\nServer::maybeMakeSpaceAvailable()\n{\n    // The hard-coded parameters are arbitrary but seem reasonable.\n    // A careful study of Squid I/O and parsing patterns is needed to tune them.\n    SBufReservationRequirements requirements;\n    requirements.minSpace = 1024; // smaller I/Os are not worth their overhead\n    requirements.idealSpace = CLIENT_REQ_BUF_SZ; // we expect few larger I/Os\n    requirements.maxCapacity = Config.maxRequestBufferSize;\n    requirements.allowShared = true; // allow because inBuf is used immediately\n    inBuf.reserve(requirements);\n    if (!inBuf.spaceSize())\n        debugs(33, 4, \"request buffer full: client_request_buffer_max_size=\" << Config.maxRequestBufferSize);\n}\n\nvoid\nServer::readSomeData()\n{\n    if (reading())\n        return;\n\n    debugs(33, 4, clientConnection << \": reading request...\");\n\n    // we can only read if there is more than 1 byte of space free\n    if (Config.maxRequestBufferSize - inBuf.length() < 2)\n        return;\n\n    typedef CommCbMemFunT<Server, CommIoCbParams> Dialer;\n    reader = JobCallback(33, 5, Dialer, this, Server::doClientRead);\n    Comm::Read(clientConnection, reader);\n}\n\nvoid\nServer::doClientRead(const CommIoCbParams &io)\n{\n    debugs(33,5, io.conn);\n    Must(reading());\n    reader = nullptr;\n\n    /* Bail out quickly on Comm::ERR_CLOSING - close handlers will tidy up */\n    if (io.flag == Comm::ERR_CLOSING) {\n        debugs(33,5, io.conn << \" closing Bailout.\");\n        return;\n    }\n\n    assert(Comm::IsConnOpen(clientConnection));\n    assert(io.conn->fd == clientConnection->fd);\n\n    /*\n     * Don't reset the timeout value here. The value should be\n     * counting Config.Timeout.request and applies to the request\n     * as a whole, not individual read() calls.\n     * Plus, it breaks our lame *HalfClosed() detection\n     */\n\n    maybeMakeSpaceAvailable();\n    CommIoCbParams rd(this); // will be expanded with ReadNow results\n    rd.conn = io.conn;\n    switch (Comm::ReadNow(rd, inBuf)) {\n    case Comm::INPROGRESS:\n\n        if (inBuf.isEmpty())\n            debugs(33, 2, io.conn << \": no data to process, \" << xstrerr(rd.xerrno));\n        readSomeData();\n        return;\n\n    case Comm::OK:\n        statCounter.client_http.kbytes_in += rd.size;\n        if (!receivedFirstByte_)\n            receivedFirstByte();\n        // may comm_close or setReplyToError\n        if (!handleReadData())\n            return;\n\n        /* Continue to process previously read data */\n        break;\n\n    case Comm::ENDFILE: // close detected by 0-byte read\n        debugs(33, 5, io.conn << \" closed?\");\n\n        if (shouldCloseOnEof()) {\n            LogTagsErrors lte;\n            lte.aborted = true;\n            terminateAll(ERR_CLIENT_GONE, lte);\n            return;\n        }\n\n        /* It might be half-closed, we can't tell */\n        fd_table[io.conn->fd].flags.socket_eof = true;\n        commMarkHalfClosed(io.conn->fd);\n        fd_note(io.conn->fd, \"half-closed\");\n\n        /* There is one more close check at the end, to detect aborted\n         * (partial) requests. At this point we can't tell if the request\n         * is partial.\n         */\n\n        /* Continue to process previously read data */\n        break;\n\n    // case Comm::COMM_ERROR:\n    default: // no other flags should ever occur\n        debugs(33, 2, io.conn << \": got flag \" << rd.flag << \"; \" << xstrerr(rd.xerrno));\n        LogTagsErrors lte;\n        lte.timedout = rd.xerrno == ETIMEDOUT;\n        lte.aborted = !lte.timedout; // intentionally true for zero rd.xerrno\n        terminateAll(Error(ERR_CLIENT_GONE, SysErrorDetail::NewIfAny(rd.xerrno)), lte);\n        return;\n    }\n\n    afterClientRead();\n}\n\n/** callback handling the Comm::Write completion\n *\n * Will call afterClientWrite(size_t) to sync the I/O state.\n * Then writeSomeData() to initiate any followup writes that\n * could be immediately done.\n */\nvoid\nServer::clientWriteDone(const CommIoCbParams &io)\n{\n    debugs(33,5, io.conn);\n    Must(writer != nullptr);\n    writer = nullptr;\n\n    /* Bail out quickly on Comm::ERR_CLOSING - close handlers will tidy up */\n    if (io.flag == Comm::ERR_CLOSING || !Comm::IsConnOpen(clientConnection)) {\n        debugs(33,5, io.conn << \" closing Bailout.\");\n        return;\n    }\n\n    Must(io.conn->fd == clientConnection->fd);\n\n    if (io.flag && pipeline.front())\n        pipeline.front()->initiateClose(\"write failure\");\n\n    afterClientWrite(io.size); // update state\n    writeSomeData(); // maybe schedules another write\n}\n\n"], "fixing_code": ["/*\n * Copyright (C) 1996-2023 The Squid Software Foundation and contributors\n *\n * Squid software is distributed under GPLv2+ license and includes\n * contributions from numerous individuals and organizations.\n * Please see the COPYING and CONTRIBUTORS files for details.\n */\n\n#include \"squid.h\"\n#include \"anyp/PortCfg.h\"\n#include \"client_side.h\"\n#include \"comm.h\"\n#include \"comm/Read.h\"\n#include \"debug/Stream.h\"\n#include \"error/SysErrorDetail.h\"\n#include \"fd.h\"\n#include \"fde.h\"\n#include \"http/Stream.h\"\n#include \"LogTags.h\"\n#include \"MasterXaction.h\"\n#include \"servers/Server.h\"\n#include \"SquidConfig.h\"\n#include \"StatCounters.h\"\n#include \"tools.h\"\n\nServer::Server(const MasterXaction::Pointer &xact) :\n    AsyncJob(\"::Server\"), // kids overwrite\n    clientConnection(xact->tcpClient),\n    transferProtocol(xact->squidPort->transport),\n    port(xact->squidPort),\n    receivedFirstByte_(false)\n{\n    clientConnection->leaveOrphanage();\n}\n\nbool\nServer::doneAll() const\n{\n    // servers are not done while the connection is open\n    return !Comm::IsConnOpen(clientConnection) &&\n           BodyProducer::doneAll();\n}\n\nvoid\nServer::start()\n{\n    // TODO: shuffle activity from ConnStateData\n}\n\nvoid\nServer::swanSong()\n{\n    if (Comm::IsConnOpen(clientConnection))\n        clientConnection->close();\n\n    BodyProducer::swanSong();\n}\n\nvoid\nServer::stopReading()\n{\n    if (reading()) {\n        Comm::ReadCancel(clientConnection->fd, reader);\n        reader = nullptr;\n    }\n}\n\n/// Prepare inBuf for I/O. This method balances several conflicting desires:\n/// 1. Do not read too few bytes at a time.\n/// 2. Do not waste too much buffer space.\n/// 3. Do not [re]allocate or memmove the buffer too much.\n/// 4. Obey Config.maxRequestBufferSize limit.\nvoid\nServer::maybeMakeSpaceAvailable()\n{\n    // The hard-coded parameters are arbitrary but seem reasonable.\n    // A careful study of Squid I/O and parsing patterns is needed to tune them.\n    SBufReservationRequirements requirements;\n    requirements.minSpace = 1024; // smaller I/Os are not worth their overhead\n    requirements.idealSpace = CLIENT_REQ_BUF_SZ; // we expect few larger I/Os\n    requirements.maxCapacity = Config.maxRequestBufferSize;\n    requirements.allowShared = true; // allow because inBuf is used immediately\n    inBuf.reserve(requirements);\n    if (!inBuf.spaceSize())\n        debugs(33, 4, \"request buffer full: client_request_buffer_max_size=\" << Config.maxRequestBufferSize);\n}\n\nvoid\nServer::readSomeData()\n{\n    if (reading())\n        return;\n\n    debugs(33, 4, clientConnection << \": reading request...\");\n\n    // we can only read if there is more than 1 byte of space free\n    if (Config.maxRequestBufferSize - inBuf.length() < 2)\n        return;\n\n    typedef CommCbMemFunT<Server, CommIoCbParams> Dialer;\n    reader = JobCallback(33, 5, Dialer, this, Server::doClientRead);\n    Comm::Read(clientConnection, reader);\n}\n\nvoid\nServer::doClientRead(const CommIoCbParams &io)\n{\n    debugs(33,5, io.conn);\n    Must(reading());\n    reader = nullptr;\n\n    /* Bail out quickly on Comm::ERR_CLOSING - close handlers will tidy up */\n    if (io.flag == Comm::ERR_CLOSING) {\n        debugs(33,5, io.conn << \" closing Bailout.\");\n        return;\n    }\n\n    assert(Comm::IsConnOpen(clientConnection));\n    assert(io.conn->fd == clientConnection->fd);\n\n    /*\n     * Don't reset the timeout value here. The value should be\n     * counting Config.Timeout.request and applies to the request\n     * as a whole, not individual read() calls.\n     * Plus, it breaks our lame *HalfClosed() detection\n     */\n\n    maybeMakeSpaceAvailable();\n    CommIoCbParams rd(this); // will be expanded with ReadNow results\n    rd.conn = io.conn;\n    switch (Comm::ReadNow(rd, inBuf)) {\n    case Comm::INPROGRESS:\n\n        if (inBuf.isEmpty())\n            debugs(33, 2, io.conn << \": no data to process, \" << xstrerr(rd.xerrno));\n        readSomeData();\n        return;\n\n    case Comm::OK:\n        statCounter.client_http.kbytes_in += rd.size;\n        if (!receivedFirstByte_)\n            receivedFirstByte();\n        // may comm_close or setReplyToError\n        if (!handleReadData())\n            return;\n\n        /* Continue to process previously read data */\n        break;\n\n    case Comm::ENDFILE: // close detected by 0-byte read\n        debugs(33, 5, io.conn << \" closed?\");\n\n        if (shouldCloseOnEof()) {\n            LogTagsErrors lte;\n            lte.aborted = true;\n            terminateAll(ERR_CLIENT_GONE, lte);\n            return;\n        }\n\n        /* It might be half-closed, we can't tell */\n        fd_table[io.conn->fd].flags.socket_eof = true;\n        commMarkHalfClosed(io.conn->fd);\n        fd_note(io.conn->fd, \"half-closed\");\n\n        /* There is one more close check at the end, to detect aborted\n         * (partial) requests. At this point we can't tell if the request\n         * is partial.\n         */\n\n        /* Continue to process previously read data */\n        break;\n\n    // case Comm::COMM_ERROR:\n    default: // no other flags should ever occur\n        debugs(33, 2, io.conn << \": got flag \" << rd.flag << \"; \" << xstrerr(rd.xerrno));\n        LogTagsErrors lte;\n        lte.timedout = rd.xerrno == ETIMEDOUT;\n        lte.aborted = !lte.timedout; // intentionally true for zero rd.xerrno\n        terminateAll(Error(ERR_CLIENT_GONE, SysErrorDetail::NewIfAny(rd.xerrno)), lte);\n        return;\n    }\n\n    afterClientRead();\n}\n\n/** callback handling the Comm::Write completion\n *\n * Will call afterClientWrite(size_t) to sync the I/O state.\n * Then writeSomeData() to initiate any followup writes that\n * could be immediately done.\n */\nvoid\nServer::clientWriteDone(const CommIoCbParams &io)\n{\n    debugs(33,5, io.conn);\n    Must(writer != nullptr);\n    writer = nullptr;\n\n    /* Bail out quickly on Comm::ERR_CLOSING - close handlers will tidy up */\n    if (io.flag == Comm::ERR_CLOSING || !Comm::IsConnOpen(clientConnection)) {\n        debugs(33,5, io.conn << \" closing Bailout.\");\n        return;\n    }\n\n    Must(io.conn->fd == clientConnection->fd);\n\n    if (io.flag) {\n        debugs(33, 2, \"bailing after a write failure: \" << xstrerr(io.xerrno));\n        LogTagsErrors lte;\n        lte.timedout = io.xerrno == ETIMEDOUT;\n        lte.aborted = !lte.timedout; // intentionally true for zero io.xerrno\n        terminateAll(Error(ERR_WRITE_ERROR, SysErrorDetail::NewIfAny(io.xerrno)), lte);\n        return;\n    }\n\n    afterClientWrite(io.size); // update state\n    writeSomeData(); // maybe schedules another write\n}\n\n"], "filenames": ["src/servers/Server.cc"], "buggy_code_start_loc": [207], "buggy_code_end_loc": [209], "fixing_code_start_loc": [207], "fixing_code_end_loc": [215], "type": "CWE-672", "message": "Squid is a caching proxy for the Web. Due to an expired pointer reference bug, Squid prior to version 6.6 is vulnerable to a Denial of Service attack against Cache Manager error responses. This problem allows a trusted client to perform Denial of Service when generating error pages for Client Manager reports. Squid older than 5.0.5 have not been tested and should be assumed to be vulnerable. All Squid-5.x up to and including 5.9 are vulnerable. All Squid-6.x up to and including 6.5 are vulnerable. This bug is fixed by Squid version 6.6. In addition, patches addressing this problem for the stable releases can be found in Squid's patch archives. As a workaround, prevent access to Cache Manager using Squid's main access control: `http_access deny manager`.", "other": {"cve": {"id": "CVE-2024-23638", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-24T00:15:08.573", "lastModified": "2024-02-08T10:15:14.500", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Squid is a caching proxy for the Web. Due to an expired pointer reference bug, Squid prior to version 6.6 is vulnerable to a Denial of Service attack against Cache Manager error responses. This problem allows a trusted client to perform Denial of Service when generating error pages for Client Manager reports. Squid older than 5.0.5 have not been tested and should be assumed to be vulnerable. All Squid-5.x up to and including 5.9 are vulnerable. All Squid-6.x up to and including 6.5 are vulnerable. This bug is fixed by Squid version 6.6. In addition, patches addressing this problem for the stable releases can be found in Squid's patch archives. As a workaround, prevent access to Cache Manager using Squid's main access control: `http_access deny manager`."}, {"lang": "es", "value": "Squid es un proxy de almacenamiento en cach\u00e9 para la Web. Debido a un error de referencia de puntero caducado, Squid anterior a la versi\u00f3n 6.6 es vulnerable a un ataque de denegaci\u00f3n de servicio contra las respuestas de error del Administrador de Cach\u00e9. Este problema permite que un cliente confiable realice una Denegaci\u00f3n de Servicio al generar p\u00e1ginas de error para los informes de Client Manager. Los calamares mayores de 5.0.5 no han sido probados y se debe suponer que son vulnerables. Todos los Squid-5.x hasta 5.9 includa, son vulnerables. Todos los Squid-6.x hasta 6.5 includa, son vulnerables. Este error se solucion\u00f3 con la versi\u00f3n 6.6 de Squid. Adem\u00e1s, los parches que solucionan este problema para las versiones estables se pueden encontrar en los archivos de parches de Squid. Como workaround, evite el acceso al Administrador de cach\u00e9 utilizando el control de acceso principal de Squid: `http_access deny manager`."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-672"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-825"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:squid-cache:squid:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0", "versionEndIncluding": "5.9", "matchCriteriaId": "A3D67FB6-14F1-40C3-B636-ADDF38F94FA9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:squid-cache:squid:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.0", "versionEndExcluding": "6.6", "matchCriteriaId": "434DE988-6D70-4BAE-8A1A-D07871424517"}]}]}], "references": [{"url": "http://www.squid-cache.org/Versions/v5/SQUID-2023_11.patch", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch"]}, {"url": "http://www.squid-cache.org/Versions/v6/SQUID-2023_11.patch", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch"]}, {"url": "https://github.com/squid-cache/squid/commit/290ae202883ac28a48867079c2fb34c40efd382b", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/squid-cache/squid/commit/e8118a7381213f5cfcdeb4cec1d2d854bfd261c8", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/squid-cache/squid/security/advisories/GHSA-j49p-553x-48rx", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://megamansec.github.io/Squid-Security-Audit/stream-assert.html", "source": "security-advisories@github.com", "tags": ["Exploit"]}, {"url": "https://security.netapp.com/advisory/ntap-20240208-0010/", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/squid-cache/squid/commit/290ae202883ac28a48867079c2fb34c40efd382b"}}