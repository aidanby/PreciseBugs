{"buggy_code": ["/**********************************************************************\n  regparse.c -  Oniguruma (regular expression library)\n**********************************************************************/\n/*-\n * Copyright (c) 2002-2016  K.Kosako  <sndgk393 AT ybb DOT ne DOT jp>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n#include \"regparse.h\"\n#include \"st.h\"\n\n#ifdef DEBUG_NODE_FREE\n#include <stdio.h>\n#endif\n\n#define WARN_BUFSIZE    256\n\n#define CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS\n\n\nOnigSyntaxType OnigSyntaxRuby = {\n  (( SYN_GNU_REGEX_OP | ONIG_SYN_OP_QMARK_NON_GREEDY |\n     ONIG_SYN_OP_ESC_OCTAL3 | ONIG_SYN_OP_ESC_X_HEX2 |\n     ONIG_SYN_OP_ESC_X_BRACE_HEX8 | ONIG_SYN_OP_ESC_O_BRACE_OCTAL |\n     ONIG_SYN_OP_ESC_CONTROL_CHARS |\n     ONIG_SYN_OP_ESC_C_CONTROL )\n   & ~ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END )\n  , ( ONIG_SYN_OP2_QMARK_GROUP_EFFECT |\n      ONIG_SYN_OP2_OPTION_RUBY |\n      ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP | ONIG_SYN_OP2_ESC_K_NAMED_BACKREF |\n      ONIG_SYN_OP2_ESC_G_SUBEXP_CALL |\n      ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY  |\n      ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT |\n      ONIG_SYN_OP2_PLUS_POSSESSIVE_REPEAT |\n      ONIG_SYN_OP2_CCLASS_SET_OP | ONIG_SYN_OP2_ESC_CAPITAL_C_BAR_CONTROL |\n      ONIG_SYN_OP2_ESC_CAPITAL_M_BAR_META | ONIG_SYN_OP2_ESC_V_VTAB |\n      ONIG_SYN_OP2_ESC_H_XDIGIT )\n  , ( SYN_GNU_REGEX_BV | \n      ONIG_SYN_ALLOW_INTERVAL_LOW_ABBREV |\n      ONIG_SYN_DIFFERENT_LEN_ALT_LOOK_BEHIND |\n      ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP |\n      ONIG_SYN_ALLOW_MULTIPLEX_DEFINITION_NAME |\n      ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY |\n      ONIG_SYN_WARN_CC_OP_NOT_ESCAPED |\n      ONIG_SYN_WARN_REDUNDANT_NESTED_REPEAT )\n  , ONIG_OPTION_NONE\n  ,\n  {\n      (OnigCodePoint )'\\\\'                       /* esc */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* anychar '.'  */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* anytime '*'  */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* zero or one time '?' */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* one or more time '+' */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* anychar anytime */\n  }\n};\n\nOnigSyntaxType*  OnigDefaultSyntax = ONIG_SYNTAX_RUBY;\n\nextern void onig_null_warn(const char* s ARG_UNUSED) { }\n\n#ifdef DEFAULT_WARN_FUNCTION\nstatic OnigWarnFunc onig_warn = (OnigWarnFunc )DEFAULT_WARN_FUNCTION;\n#else\nstatic OnigWarnFunc onig_warn = onig_null_warn;\n#endif\n\n#ifdef DEFAULT_VERB_WARN_FUNCTION\nstatic OnigWarnFunc onig_verb_warn = (OnigWarnFunc )DEFAULT_VERB_WARN_FUNCTION;\n#else\nstatic OnigWarnFunc onig_verb_warn = onig_null_warn;\n#endif\n\nextern void onig_set_warn_func(OnigWarnFunc f)\n{\n  onig_warn = f;\n}\n\nextern void onig_set_verb_warn_func(OnigWarnFunc f)\n{\n  onig_verb_warn = f;\n}\n\nextern void\nonig_warning(const char* s)\n{\n  if (onig_warn == onig_null_warn) return ;\n\n  (*onig_warn)(s);\n}\n\n#define DEFAULT_MAX_CAPTURE_NUM   32767\n\nstatic int MaxCaptureNum = DEFAULT_MAX_CAPTURE_NUM;\n\nextern int\nonig_set_capture_num_limit(int num)\n{\n  if (num < 0) return -1;\n\n  MaxCaptureNum = num;\n  return 0;\n}\n\nstatic unsigned int ParseDepthLimit = DEFAULT_PARSE_DEPTH_LIMIT;\n\nextern unsigned int\nonig_get_parse_depth_limit(void)\n{\n  return ParseDepthLimit;\n}\n\nextern int\nonig_set_parse_depth_limit(unsigned int depth)\n{\n  if (depth == 0)\n    ParseDepthLimit = DEFAULT_PARSE_DEPTH_LIMIT;\n  else\n    ParseDepthLimit = depth;\n  return 0;\n}\n\n\nstatic void\nbbuf_free(BBuf* bbuf)\n{\n  if (IS_NOT_NULL(bbuf)) {\n    if (IS_NOT_NULL(bbuf->p)) xfree(bbuf->p);\n    xfree(bbuf);\n  }\n}\n\nstatic int\nbbuf_clone(BBuf** rto, BBuf* from)\n{\n  int r;\n  BBuf *to;\n\n  *rto = to = (BBuf* )xmalloc(sizeof(BBuf));\n  CHECK_NULL_RETURN_MEMERR(to);\n  r = BBUF_INIT(to, from->alloc);\n  if (r != 0) return r;\n  to->used = from->used;\n  xmemcpy(to->p, from->p, from->used);\n  return 0;\n}\n\n#define BACKREF_REL_TO_ABS(rel_no, env) \\\n  ((env)->num_mem + 1 + (rel_no))\n\n#define ONOFF(v,f,negative)    (negative) ? ((v) &= ~(f)) : ((v) |= (f))\n\n#define MBCODE_START_POS(enc) \\\n  (OnigCodePoint )(ONIGENC_MBC_MINLEN(enc) > 1 ? 0 : 0x80)\n\n#define SET_ALL_MULTI_BYTE_RANGE(enc, pbuf) \\\n  add_code_range_to_buf(pbuf, MBCODE_START_POS(enc), ~((OnigCodePoint )0))\n\n#define ADD_ALL_MULTI_BYTE_RANGE(enc, mbuf) do {\\\n  if (! ONIGENC_IS_SINGLEBYTE(enc)) {\\\n    r = SET_ALL_MULTI_BYTE_RANGE(enc, &(mbuf));\\\n    if (r) return r;\\\n  }\\\n} while (0)\n\n\n#define BITSET_IS_EMPTY(bs,empty) do {\\\n  int i;\\\n  empty = 1;\\\n  for (i = 0; i < (int )BITSET_SIZE; i++) {\\\n    if ((bs)[i] != 0) {\\\n      empty = 0; break;\\\n    }\\\n  }\\\n} while (0)\n\nstatic void\nbitset_set_range(BitSetRef bs, int from, int to)\n{\n  int i;\n  for (i = from; i <= to && i < SINGLE_BYTE_SIZE; i++) {\n    BITSET_SET_BIT(bs, i);\n  }\n}\n\n#if 0\nstatic void\nbitset_set_all(BitSetRef bs)\n{\n  int i;\n  for (i = 0; i < BITSET_SIZE; i++) { bs[i] = ~((Bits )0); }\n}\n#endif\n\nstatic void\nbitset_invert(BitSetRef bs)\n{\n  int i;\n  for (i = 0; i < (int )BITSET_SIZE; i++) { bs[i] = ~(bs[i]); }\n}\n\nstatic void\nbitset_invert_to(BitSetRef from, BitSetRef to)\n{\n  int i;\n  for (i = 0; i < (int )BITSET_SIZE; i++) { to[i] = ~(from[i]); }\n}\n\nstatic void\nbitset_and(BitSetRef dest, BitSetRef bs)\n{\n  int i;\n  for (i = 0; i < (int )BITSET_SIZE; i++) { dest[i] &= bs[i]; }\n}\n\nstatic void\nbitset_or(BitSetRef dest, BitSetRef bs)\n{\n  int i;\n  for (i = 0; i < (int )BITSET_SIZE; i++) { dest[i] |= bs[i]; }\n}\n\nstatic void\nbitset_copy(BitSetRef dest, BitSetRef bs)\n{\n  int i;\n  for (i = 0; i < (int )BITSET_SIZE; i++) { dest[i] = bs[i]; }\n}\n\nextern int\nonig_strncmp(const UChar* s1, const UChar* s2, int n)\n{\n  int x;\n\n  while (n-- > 0) {\n    x = *s2++ - *s1++;\n    if (x) return x;\n  }\n  return 0;\n}\n\nextern void\nonig_strcpy(UChar* dest, const UChar* src, const UChar* end)\n{\n  int len = end - src;\n  if (len > 0) {\n    xmemcpy(dest, src, len);\n    dest[len] = (UChar )0;\n  }\n}\n\n#ifdef USE_NAMED_GROUP\nstatic UChar*\nstrdup_with_null(OnigEncoding enc, UChar* s, UChar* end)\n{\n  int slen, term_len, i;\n  UChar *r;\n\n  slen = end - s;\n  term_len = ONIGENC_MBC_MINLEN(enc);\n\n  r = (UChar* )xmalloc(slen + term_len);\n  CHECK_NULL_RETURN(r);\n  xmemcpy(r, s, slen);\n\n  for (i = 0; i < term_len; i++)\n    r[slen + i] = (UChar )0;\n\n  return r;\n}\n#endif\n\n/* scan pattern methods */\n#define PEND_VALUE   0\n\n#define PFETCH_READY  UChar* pfetch_prev\n#define PEND         (p < end ?  0 : 1)\n#define PUNFETCH     p = pfetch_prev\n#define PINC       do { \\\n  pfetch_prev = p; \\\n  p += ONIGENC_MBC_ENC_LEN(enc, p); \\\n} while (0)\n#define PFETCH(c)  do { \\\n  c = ONIGENC_MBC_TO_CODE(enc, p, end); \\\n  pfetch_prev = p; \\\n  p += ONIGENC_MBC_ENC_LEN(enc, p); \\\n} while (0)\n\n#define PINC_S     do { \\\n  p += ONIGENC_MBC_ENC_LEN(enc, p); \\\n} while (0)\n#define PFETCH_S(c) do { \\\n  c = ONIGENC_MBC_TO_CODE(enc, p, end); \\\n  p += ONIGENC_MBC_ENC_LEN(enc, p); \\\n} while (0)\n\n#define PPEEK        (p < end ? ONIGENC_MBC_TO_CODE(enc, p, end) : PEND_VALUE)\n#define PPEEK_IS(c)  (PPEEK == (OnigCodePoint )c)\n\nstatic UChar*\nstrcat_capa(UChar* dest, UChar* dest_end, const UChar* src, const UChar* src_end,\n\t      int capa)\n{\n  UChar* r;\n\n  if (dest)\n    r = (UChar* )xrealloc(dest, capa + 1);\n  else\n    r = (UChar* )xmalloc(capa + 1);\n\n  CHECK_NULL_RETURN(r);\n  onig_strcpy(r + (dest_end - dest), src, src_end);\n  return r;\n}\n\n/* dest on static area */\nstatic UChar*\nstrcat_capa_from_static(UChar* dest, UChar* dest_end,\n\t\t\tconst UChar* src, const UChar* src_end, int capa)\n{\n  UChar* r;\n\n  r = (UChar* )xmalloc(capa + 1);\n  CHECK_NULL_RETURN(r);\n  onig_strcpy(r, dest, dest_end);\n  onig_strcpy(r + (dest_end - dest), src, src_end);\n  return r;\n}\n\n\n#ifdef USE_ST_LIBRARY\n\ntypedef struct {\n  UChar* s;\n  UChar* end;\n} st_str_end_key;\n\nstatic int\nstr_end_cmp(st_str_end_key* x, st_str_end_key* y)\n{\n  UChar *p, *q;\n  int c;\n\n  if ((x->end - x->s) != (y->end - y->s))\n    return 1;\n\n  p = x->s;\n  q = y->s;\n  while (p < x->end) {\n    c = (int )*p - (int )*q;\n    if (c != 0) return c;\n\n    p++; q++;\n  }\n\n  return 0;\n}\n\nstatic int\nstr_end_hash(st_str_end_key* x)\n{\n  UChar *p;\n  int val = 0;\n\n  p = x->s;\n  while (p < x->end) {\n    val = val * 997 + (int )*p++;\n  }\n\n  return val + (val >> 5);\n}\n\nextern hash_table_type*\nonig_st_init_strend_table_with_size(int size)\n{\n  static struct st_hash_type hashType = {\n    str_end_cmp,\n    str_end_hash,\n  };\n\n  return (hash_table_type* )\n           onig_st_init_table_with_size(&hashType, size);\n}\n\nextern int\nonig_st_lookup_strend(hash_table_type* table, const UChar* str_key,\n\t\t      const UChar* end_key, hash_data_type *value)\n{\n  st_str_end_key key;\n\n  key.s   = (UChar* )str_key;\n  key.end = (UChar* )end_key;\n\n  return onig_st_lookup(table, (st_data_t )(&key), value);\n}\n\nextern int\nonig_st_insert_strend(hash_table_type* table, const UChar* str_key,\n\t\t      const UChar* end_key, hash_data_type value)\n{\n  st_str_end_key* key;\n  int result;\n\n  key = (st_str_end_key* )xmalloc(sizeof(st_str_end_key));\n  key->s   = (UChar* )str_key;\n  key->end = (UChar* )end_key;\n  result = onig_st_insert(table, (st_data_t )key, value);\n  if (result) {\n    xfree(key);\n  }\n  return result;\n}\n\n#endif /* USE_ST_LIBRARY */\n\n\n#ifdef USE_NAMED_GROUP\n\n#define INIT_NAME_BACKREFS_ALLOC_NUM   8\n\ntypedef struct {\n  UChar* name;\n  int    name_len;   /* byte length */\n  int    back_num;   /* number of backrefs */\n  int    back_alloc;\n  int    back_ref1;\n  int*   back_refs;\n} NameEntry;\n\n#ifdef USE_ST_LIBRARY\n\ntypedef st_table  NameTable;\ntypedef st_data_t HashDataType;   /* 1.6 st.h doesn't define st_data_t type */\n\n#define NAMEBUF_SIZE    24\n#define NAMEBUF_SIZE_1  25\n\n#ifdef ONIG_DEBUG\nstatic int\ni_print_name_entry(UChar* key, NameEntry* e, void* arg)\n{\n  int i;\n  FILE* fp = (FILE* )arg;\n\n  fprintf(fp, \"%s: \", e->name);\n  if (e->back_num == 0)\n    fputs(\"-\", fp);\n  else if (e->back_num == 1)\n    fprintf(fp, \"%d\", e->back_ref1);\n  else {\n    for (i = 0; i < e->back_num; i++) {\n      if (i > 0) fprintf(fp, \", \");\n      fprintf(fp, \"%d\", e->back_refs[i]);\n    }\n  }\n  fputs(\"\\n\", fp);\n  return ST_CONTINUE;\n}\n\nextern int\nonig_print_names(FILE* fp, regex_t* reg)\n{\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    fprintf(fp, \"name table\\n\");\n    onig_st_foreach(t, i_print_name_entry, (HashDataType )fp);\n    fputs(\"\\n\", fp);\n  }\n  return 0;\n}\n#endif /* ONIG_DEBUG */\n\nstatic int\ni_free_name_entry(UChar* key, NameEntry* e, void* arg ARG_UNUSED)\n{\n  xfree(e->name);\n  if (IS_NOT_NULL(e->back_refs)) xfree(e->back_refs);\n  xfree(key);\n  xfree(e);\n  return ST_DELETE;\n}\n\nstatic int\nnames_clear(regex_t* reg)\n{\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    onig_st_foreach(t, i_free_name_entry, 0);\n  }\n  return 0;\n}\n\nextern int\nonig_names_free(regex_t* reg)\n{\n  int r;\n  NameTable* t;\n\n  r = names_clear(reg);\n  if (r) return r;\n\n  t = (NameTable* )reg->name_table;\n  if (IS_NOT_NULL(t)) onig_st_free_table(t);\n  reg->name_table = (void* )NULL;\n  return 0;\n}\n\nstatic NameEntry*\nname_find(regex_t* reg, const UChar* name, const UChar* name_end)\n{\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  e = (NameEntry* )NULL;\n  if (IS_NOT_NULL(t)) {\n    onig_st_lookup_strend(t, name, name_end, (HashDataType* )((void* )(&e)));\n  }\n  return e;\n}\n\ntypedef struct {\n  int (*func)(const UChar*, const UChar*,int,int*,regex_t*,void*);\n  regex_t* reg;\n  void* arg;\n  int ret;\n  OnigEncoding enc;\n} INamesArg;\n\nstatic int\ni_names(UChar* key ARG_UNUSED, NameEntry* e, INamesArg* arg)\n{\n  int r = (*(arg->func))(e->name,\n                         e->name + e->name_len,\n                         e->back_num,\n\t\t\t (e->back_num > 1 ? e->back_refs : &(e->back_ref1)),\n\t\t\t arg->reg, arg->arg);\n  if (r != 0) {\n    arg->ret = r;\n    return ST_STOP;\n  }\n  return ST_CONTINUE;\n}\n\nextern int\nonig_foreach_name(regex_t* reg,\n  int (*func)(const UChar*, const UChar*,int,int*,regex_t*,void*), void* arg)\n{\n  INamesArg narg;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  narg.ret = 0;\n  if (IS_NOT_NULL(t)) {\n    narg.func = func;\n    narg.reg  = reg;\n    narg.arg  = arg;\n    narg.enc  = reg->enc; /* should be pattern encoding. */\n    onig_st_foreach(t, i_names, (HashDataType )&narg);\n  }\n  return narg.ret;\n}\n\nstatic int\ni_renumber_name(UChar* key ARG_UNUSED, NameEntry* e, GroupNumRemap* map)\n{\n  int i;\n\n  if (e->back_num > 1) {\n    for (i = 0; i < e->back_num; i++) {\n      e->back_refs[i] = map[e->back_refs[i]].new_val;\n    }\n  }\n  else if (e->back_num == 1) {\n    e->back_ref1 = map[e->back_ref1].new_val;\n  }\n\n  return ST_CONTINUE;\n}\n\nextern int\nonig_renumber_name_table(regex_t* reg, GroupNumRemap* map)\n{\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    onig_st_foreach(t, i_renumber_name, (HashDataType )map);\n  }\n  return 0;\n}\n\n\nextern int\nonig_number_of_names(regex_t* reg)\n{\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t))\n    return t->num_entries;\n  else\n    return 0;\n}\n\n#else  /* USE_ST_LIBRARY */\n\n#define INIT_NAMES_ALLOC_NUM    8\n\ntypedef struct {\n  NameEntry* e;\n  int        num;\n  int        alloc;\n} NameTable;\n\n#ifdef ONIG_DEBUG\nextern int\nonig_print_names(FILE* fp, regex_t* reg)\n{\n  int i, j;\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t) && t->num > 0) {\n    fprintf(fp, \"name table\\n\");\n    for (i = 0; i < t->num; i++) {\n      e = &(t->e[i]);\n      fprintf(fp, \"%s: \", e->name);\n      if (e->back_num == 0) {\n        fputs(\"-\", fp);\n      }\n      else if (e->back_num == 1) {\n        fprintf(fp, \"%d\", e->back_ref1);\n      }\n      else {\n        for (j = 0; j < e->back_num; j++) {\n          if (j > 0) fprintf(fp, \", \");\n          fprintf(fp, \"%d\", e->back_refs[j]);\n        }\n      }\n      fputs(\"\\n\", fp);\n    }\n    fputs(\"\\n\", fp);\n  }\n  return 0;\n}\n#endif\n\nstatic int\nnames_clear(regex_t* reg)\n{\n  int i;\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    for (i = 0; i < t->num; i++) {\n      e = &(t->e[i]);\n      if (IS_NOT_NULL(e->name)) {\n        xfree(e->name);\n        e->name       = NULL;\n        e->name_len   = 0;\n        e->back_num   = 0;\n        e->back_alloc = 0;\n        if (IS_NOT_NULL(e->back_refs)) xfree(e->back_refs);\n        e->back_refs = (int* )NULL;\n      }\n    }\n    if (IS_NOT_NULL(t->e)) {\n      xfree(t->e);\n      t->e = NULL;\n    }\n    t->num = 0;\n  }\n  return 0;\n}\n\nextern int\nonig_names_free(regex_t* reg)\n{\n  int r;\n  NameTable* t;\n\n  r = names_clear(reg);\n  if (r) return r;\n\n  t = (NameTable* )reg->name_table;\n  if (IS_NOT_NULL(t)) xfree(t);\n  reg->name_table = NULL;\n  return 0;\n}\n\nstatic NameEntry*\nname_find(regex_t* reg, UChar* name, UChar* name_end)\n{\n  int i, len;\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    len = name_end - name;\n    for (i = 0; i < t->num; i++) {\n      e = &(t->e[i]);\n      if (len == e->name_len && onig_strncmp(name, e->name, len) == 0)\n        return e;\n    }\n  }\n  return (NameEntry* )NULL;\n}\n\nextern int\nonig_foreach_name(regex_t* reg,\n  int (*func)(const UChar*, const UChar*,int,int*,regex_t*,void*), void* arg)\n{\n  int i, r;\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    for (i = 0; i < t->num; i++) {\n      e = &(t->e[i]);\n      r = (*func)(e->name, e->name + e->name_len, e->back_num,\n                  (e->back_num > 1 ? e->back_refs : &(e->back_ref1)),\n                  reg, arg);\n      if (r != 0) return r;\n    }\n  }\n  return 0;\n}\n\nextern int\nonig_number_of_names(regex_t* reg)\n{\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t))\n    return t->num;\n  else\n    return 0;\n}\n\n#endif /* else USE_ST_LIBRARY */\n\nstatic int\nname_add(regex_t* reg, UChar* name, UChar* name_end, int backref, ScanEnv* env)\n{\n  int alloc;\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (name_end - name <= 0)\n    return ONIGERR_EMPTY_GROUP_NAME;\n\n  e = name_find(reg, name, name_end);\n  if (IS_NULL(e)) {\n#ifdef USE_ST_LIBRARY\n    if (IS_NULL(t)) {\n      t = onig_st_init_strend_table_with_size(5);\n      reg->name_table = (void* )t;\n    }\n    e = (NameEntry* )xmalloc(sizeof(NameEntry));\n    CHECK_NULL_RETURN_MEMERR(e);\n\n    e->name = strdup_with_null(reg->enc, name, name_end);\n    if (IS_NULL(e->name)) {\n      xfree(e);  return ONIGERR_MEMORY;\n    }\n    onig_st_insert_strend(t, e->name, (e->name + (name_end - name)),\n                          (HashDataType )e);\n\n    e->name_len   = name_end - name;\n    e->back_num   = 0;\n    e->back_alloc = 0;\n    e->back_refs  = (int* )NULL;\n\n#else\n\n    if (IS_NULL(t)) {\n      alloc = INIT_NAMES_ALLOC_NUM;\n      t = (NameTable* )xmalloc(sizeof(NameTable));\n      CHECK_NULL_RETURN_MEMERR(t);\n      t->e     = NULL;\n      t->alloc = 0;\n      t->num   = 0;\n\n      t->e = (NameEntry* )xmalloc(sizeof(NameEntry) * alloc);\n      if (IS_NULL(t->e)) {\n        xfree(t);\n        return ONIGERR_MEMORY;\n      }\n      t->alloc = alloc;\n      reg->name_table = t;\n      goto clear;\n    }\n    else if (t->num == t->alloc) {\n      int i;\n\n      alloc = t->alloc * 2;\n      t->e = (NameEntry* )xrealloc(t->e, sizeof(NameEntry) * alloc);\n      CHECK_NULL_RETURN_MEMERR(t->e);\n      t->alloc = alloc;\n\n    clear:\n      for (i = t->num; i < t->alloc; i++) {\n        t->e[i].name       = NULL;\n        t->e[i].name_len   = 0;\n        t->e[i].back_num   = 0;\n        t->e[i].back_alloc = 0;\n        t->e[i].back_refs  = (int* )NULL;\n      }\n    }\n    e = &(t->e[t->num]);\n    t->num++;\n    e->name = strdup_with_null(reg->enc, name, name_end);\n    if (IS_NULL(e->name)) return ONIGERR_MEMORY;\n    e->name_len = name_end - name;\n#endif\n  }\n\n  if (e->back_num >= 1 &&\n      ! IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_MULTIPLEX_DEFINITION_NAME)) {\n    onig_scan_env_set_error_string(env, ONIGERR_MULTIPLEX_DEFINED_NAME,\n                                   name, name_end);\n    return ONIGERR_MULTIPLEX_DEFINED_NAME;\n  }\n\n  e->back_num++;\n  if (e->back_num == 1) {\n    e->back_ref1 = backref;\n  }\n  else {\n    if (e->back_num == 2) {\n      alloc = INIT_NAME_BACKREFS_ALLOC_NUM;\n      e->back_refs = (int* )xmalloc(sizeof(int) * alloc);\n      CHECK_NULL_RETURN_MEMERR(e->back_refs);\n      e->back_alloc = alloc;\n      e->back_refs[0] = e->back_ref1;\n      e->back_refs[1] = backref;\n    }\n    else {\n      if (e->back_num > e->back_alloc) {\n        alloc = e->back_alloc * 2;\n        e->back_refs = (int* )xrealloc(e->back_refs, sizeof(int) * alloc);\n        CHECK_NULL_RETURN_MEMERR(e->back_refs);\n        e->back_alloc = alloc;\n      }\n      e->back_refs[e->back_num - 1] = backref;\n    }\n  }\n\n  return 0;\n}\n\nextern int\nonig_name_to_group_numbers(regex_t* reg, const UChar* name,\n\t\t\t   const UChar* name_end, int** nums)\n{\n  NameEntry* e = name_find(reg, name, name_end);\n\n  if (IS_NULL(e)) return ONIGERR_UNDEFINED_NAME_REFERENCE;\n\n  switch (e->back_num) {\n  case 0:\n    break;\n  case 1:\n    *nums = &(e->back_ref1);\n    break;\n  default:\n    *nums = e->back_refs;\n    break;\n  }\n  return e->back_num;\n}\n\nextern int\nonig_name_to_backref_number(regex_t* reg, const UChar* name,\n\t\t\t    const UChar* name_end, OnigRegion *region)\n{\n  int i, n, *nums;\n\n  n = onig_name_to_group_numbers(reg, name, name_end, &nums);\n  if (n < 0)\n    return n;\n  else if (n == 0)\n    return ONIGERR_PARSER_BUG;\n  else if (n == 1)\n    return nums[0];\n  else {\n    if (IS_NOT_NULL(region)) {\n      for (i = n - 1; i >= 0; i--) {\n        if (region->beg[nums[i]] != ONIG_REGION_NOTPOS)\n          return nums[i];\n      }\n    }\n    return nums[n - 1];\n  }\n}\n\n#else /* USE_NAMED_GROUP */\n\nextern int\nonig_name_to_group_numbers(regex_t* reg, const UChar* name,\n\t\t\t   const UChar* name_end, int** nums)\n{\n  return ONIG_NO_SUPPORT_CONFIG;\n}\n\nextern int\nonig_name_to_backref_number(regex_t* reg, const UChar* name,\n\t\t\t    const UChar* name_end, OnigRegion* region)\n{\n  return ONIG_NO_SUPPORT_CONFIG;\n}\n\nextern int\nonig_foreach_name(regex_t* reg,\n  int (*func)(const UChar*, const UChar*,int,int*,regex_t*,void*), void* arg)\n{\n  return ONIG_NO_SUPPORT_CONFIG;\n}\n\nextern int\nonig_number_of_names(regex_t* reg)\n{\n  return 0;\n}\n#endif /* else USE_NAMED_GROUP */\n\nextern int\nonig_noname_group_capture_is_active(regex_t* reg)\n{\n  if (ONIG_IS_OPTION_ON(reg->options, ONIG_OPTION_DONT_CAPTURE_GROUP))\n    return 0;\n\n#ifdef USE_NAMED_GROUP\n  if (onig_number_of_names(reg) > 0 &&\n      IS_SYNTAX_BV(reg->syntax, ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP) &&\n      !ONIG_IS_OPTION_ON(reg->options, ONIG_OPTION_CAPTURE_GROUP)) {\n    return 0;\n  }\n#endif\n\n  return 1;\n}\n\n\n#define INIT_SCANENV_MEMNODES_ALLOC_SIZE   16\n\nstatic void\nscan_env_clear(ScanEnv* env)\n{\n  int i;\n\n  BIT_STATUS_CLEAR(env->capture_history);\n  BIT_STATUS_CLEAR(env->bt_mem_start);\n  BIT_STATUS_CLEAR(env->bt_mem_end);\n  BIT_STATUS_CLEAR(env->backrefed_mem);\n  env->error      = (UChar* )NULL;\n  env->error_end  = (UChar* )NULL;\n  env->num_call   = 0;\n  env->num_mem    = 0;\n#ifdef USE_NAMED_GROUP\n  env->num_named  = 0;\n#endif\n  env->mem_alloc         = 0;\n  env->mem_nodes_dynamic = (Node** )NULL;\n\n  for (i = 0; i < SCANENV_MEMNODES_SIZE; i++)\n    env->mem_nodes_static[i] = NULL_NODE;\n\n#ifdef USE_COMBINATION_EXPLOSION_CHECK\n  env->num_comb_exp_check  = 0;\n  env->comb_exp_max_regnum = 0;\n  env->curr_max_regnum     = 0;\n  env->has_recursion       = 0;\n#endif\n  env->parse_depth         = 0;\n}\n\nstatic int\nscan_env_add_mem_entry(ScanEnv* env)\n{\n  int i, need, alloc;\n  Node** p;\n\n  need = env->num_mem + 1;\n  if (need > MaxCaptureNum && MaxCaptureNum != 0)\n    return ONIGERR_TOO_MANY_CAPTURES;\n\n  if (need >= SCANENV_MEMNODES_SIZE) {\n    if (env->mem_alloc <= need) {\n      if (IS_NULL(env->mem_nodes_dynamic)) {\n        alloc = INIT_SCANENV_MEMNODES_ALLOC_SIZE;\n        p = (Node** )xmalloc(sizeof(Node*) * alloc);\n        xmemcpy(p, env->mem_nodes_static,\n                sizeof(Node*) * SCANENV_MEMNODES_SIZE);\n      }\n      else {\n        alloc = env->mem_alloc * 2;\n        p = (Node** )xrealloc(env->mem_nodes_dynamic, sizeof(Node*) * alloc);\n      }\n      CHECK_NULL_RETURN_MEMERR(p);\n\n      for (i = env->num_mem + 1; i < alloc; i++)\n        p[i] = NULL_NODE;\n\n      env->mem_nodes_dynamic = p;\n      env->mem_alloc = alloc;\n    }\n  }\n\n  env->num_mem++;\n  return env->num_mem;\n}\n\nstatic int\nscan_env_set_mem_node(ScanEnv* env, int num, Node* node)\n{\n  if (env->num_mem >= num)\n    SCANENV_MEM_NODES(env)[num] = node;\n  else\n    return ONIGERR_PARSER_BUG;\n  return 0;\n}\n\nextern void\nonig_node_free(Node* node)\n{\n start:\n  if (IS_NULL(node)) return ;\n\n#ifdef DEBUG_NODE_FREE\n  fprintf(stderr, \"onig_node_free: %p\\n\", node);\n#endif\n\n  switch (NTYPE(node)) {\n  case NT_STR:\n    if (NSTR(node)->capa != 0 &&\n\tIS_NOT_NULL(NSTR(node)->s) && NSTR(node)->s != NSTR(node)->buf) {\n      xfree(NSTR(node)->s);\n    }\n    break;\n\n  case NT_LIST:\n  case NT_ALT:\n    onig_node_free(NCAR(node));\n    {\n      Node* next_node = NCDR(node);\n\n      xfree(node);\n      node = next_node;\n      goto start;\n    }\n    break;\n\n  case NT_CCLASS:\n    {\n      CClassNode* cc = NCCLASS(node);\n\n      if (IS_NCCLASS_SHARE(cc)) return ;\n      if (cc->mbuf)\n        bbuf_free(cc->mbuf);\n    }\n    break;\n\n  case NT_QTFR:\n    if (NQTFR(node)->target)\n      onig_node_free(NQTFR(node)->target);\n    break;\n\n  case NT_ENCLOSE:\n    if (NENCLOSE(node)->target)\n      onig_node_free(NENCLOSE(node)->target);\n    break;\n\n  case NT_BREF:\n    if (IS_NOT_NULL(NBREF(node)->back_dynamic))\n      xfree(NBREF(node)->back_dynamic);\n    break;\n\n  case NT_ANCHOR:\n    if (NANCHOR(node)->target)\n      onig_node_free(NANCHOR(node)->target);\n    break;\n  }\n\n  xfree(node);\n}\n\nstatic Node*\nnode_new(void)\n{\n  Node* node;\n\n  node = (Node* )xmalloc(sizeof(Node));\n  /* xmemset(node, 0, sizeof(Node)); */\n#ifdef DEBUG_NODE_FREE\n  fprintf(stderr, \"node_new: %p\\n\", node);\n#endif\n  return node;\n}\n\n\nstatic void\ninitialize_cclass(CClassNode* cc)\n{\n  BITSET_CLEAR(cc->bs);\n  /* cc->base.flags = 0; */\n  cc->flags = 0;\n  cc->mbuf  = NULL;\n}\n\nstatic Node*\nnode_new_cclass(void)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_CCLASS);\n  initialize_cclass(NCCLASS(node));\n  return node;\n}\n\nstatic Node*\nnode_new_ctype(int type, int not)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_CTYPE);\n  NCTYPE(node)->ctype = type;\n  NCTYPE(node)->not   = not;\n  return node;\n}\n\nstatic Node*\nnode_new_anychar(void)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_CANY);\n  return node;\n}\n\nstatic Node*\nnode_new_list(Node* left, Node* right)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_LIST);\n  NCAR(node)  = left;\n  NCDR(node) = right;\n  return node;\n}\n\nextern Node*\nonig_node_new_list(Node* left, Node* right)\n{\n  return node_new_list(left, right);\n}\n\nextern Node*\nonig_node_list_add(Node* list, Node* x)\n{\n  Node *n;\n\n  n = onig_node_new_list(x, NULL);\n  if (IS_NULL(n)) return NULL_NODE;\n\n  if (IS_NOT_NULL(list)) {\n    while (IS_NOT_NULL(NCDR(list)))\n      list = NCDR(list);\n\n    NCDR(list) = n;\n  }\n\n  return n;\n}\n\nextern Node*\nonig_node_new_alt(Node* left, Node* right)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_ALT);\n  NCAR(node)  = left;\n  NCDR(node) = right;\n  return node;\n}\n\nextern Node*\nonig_node_new_anchor(int type)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_ANCHOR);\n  NANCHOR(node)->type     = type;\n  NANCHOR(node)->target   = NULL;\n  NANCHOR(node)->char_len = -1;\n  return node;\n}\n\nstatic Node*\nnode_new_backref(int back_num, int* backrefs, int by_name,\n#ifdef USE_BACKREF_WITH_LEVEL\n\t\t int exist_level, int nest_level,\n#endif\n\t\t ScanEnv* env)\n{\n  int i;\n  Node* node = node_new();\n\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_BREF);\n  NBREF(node)->state    = 0;\n  NBREF(node)->back_num = back_num;\n  NBREF(node)->back_dynamic = (int* )NULL;\n  if (by_name != 0)\n    NBREF(node)->state |= NST_NAME_REF;\n\n#ifdef USE_BACKREF_WITH_LEVEL\n  if (exist_level != 0) {\n    NBREF(node)->state |= NST_NEST_LEVEL;\n    NBREF(node)->nest_level  = nest_level;\n  }\n#endif\n\n  for (i = 0; i < back_num; i++) {\n    if (backrefs[i] <= env->num_mem &&\n        IS_NULL(SCANENV_MEM_NODES(env)[backrefs[i]])) {\n      NBREF(node)->state |= NST_RECURSION;   /* /...(\\1).../ */\n      break;\n    }\n  }\n\n  if (back_num <= NODE_BACKREFS_SIZE) {\n    for (i = 0; i < back_num; i++)\n      NBREF(node)->back_static[i] = backrefs[i];\n  }\n  else {\n    int* p = (int* )xmalloc(sizeof(int) * back_num);\n    if (IS_NULL(p)) {\n      onig_node_free(node);\n      return NULL;\n    }\n    NBREF(node)->back_dynamic = p;\n    for (i = 0; i < back_num; i++)\n      p[i] = backrefs[i];\n  }\n  return node;\n}\n\n#ifdef USE_SUBEXP_CALL\nstatic Node*\nnode_new_call(UChar* name, UChar* name_end, int gnum)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_CALL);\n  NCALL(node)->state     = 0;\n  NCALL(node)->target    = NULL_NODE;\n  NCALL(node)->name      = name;\n  NCALL(node)->name_end  = name_end;\n  NCALL(node)->group_num = gnum;  /* call by number if gnum != 0 */\n  return node;\n}\n#endif\n\nstatic Node*\nnode_new_quantifier(int lower, int upper, int by_number)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_QTFR);\n  NQTFR(node)->state  = 0;\n  NQTFR(node)->target = NULL;\n  NQTFR(node)->lower  = lower;\n  NQTFR(node)->upper  = upper;\n  NQTFR(node)->greedy = 1;\n  NQTFR(node)->target_empty_info = NQ_TARGET_ISNOT_EMPTY;\n  NQTFR(node)->head_exact        = NULL_NODE;\n  NQTFR(node)->next_head_exact   = NULL_NODE;\n  NQTFR(node)->is_refered        = 0;\n  if (by_number != 0)\n    NQTFR(node)->state |= NST_BY_NUMBER;\n\n#ifdef USE_COMBINATION_EXPLOSION_CHECK\n  NQTFR(node)->comb_exp_check_num = 0;\n#endif\n\n  return node;\n}\n\nstatic Node*\nnode_new_enclose(int type)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_ENCLOSE);\n  NENCLOSE(node)->type      = type;\n  NENCLOSE(node)->state     =  0;\n  NENCLOSE(node)->regnum    =  0;\n  NENCLOSE(node)->option    =  0;\n  NENCLOSE(node)->target    = NULL;\n  NENCLOSE(node)->call_addr = -1;\n  NENCLOSE(node)->opt_count =  0;\n  return node;\n}\n\nextern Node*\nonig_node_new_enclose(int type)\n{\n  return node_new_enclose(type);\n}\n\nstatic Node*\nnode_new_enclose_memory(OnigOptionType option, int is_named)\n{\n  Node* node = node_new_enclose(ENCLOSE_MEMORY);\n  CHECK_NULL_RETURN(node);\n  if (is_named != 0)\n    SET_ENCLOSE_STATUS(node, NST_NAMED_GROUP);\n\n#ifdef USE_SUBEXP_CALL\n  NENCLOSE(node)->option = option;\n#endif\n  return node;\n}\n\nstatic Node*\nnode_new_option(OnigOptionType option)\n{\n  Node* node = node_new_enclose(ENCLOSE_OPTION);\n  CHECK_NULL_RETURN(node);\n  NENCLOSE(node)->option = option;\n  return node;\n}\n\nextern int\nonig_node_str_cat(Node* node, const UChar* s, const UChar* end)\n{\n  int addlen = end - s;\n\n  if (addlen > 0) {\n    int len  = NSTR(node)->end - NSTR(node)->s;\n\n    if (NSTR(node)->capa > 0 || (len + addlen > NODE_STR_BUF_SIZE - 1)) {\n      UChar* p;\n      int capa = len + addlen + NODE_STR_MARGIN;\n\n      if (capa <= NSTR(node)->capa) {\n        onig_strcpy(NSTR(node)->s + len, s, end);\n      }\n      else {\n        if (NSTR(node)->s == NSTR(node)->buf)\n          p = strcat_capa_from_static(NSTR(node)->s, NSTR(node)->end,\n                                      s, end, capa);\n        else\n          p = strcat_capa(NSTR(node)->s, NSTR(node)->end, s, end, capa);\n\n        CHECK_NULL_RETURN_MEMERR(p);\n        NSTR(node)->s    = p;\n        NSTR(node)->capa = capa;\n      }\n    }\n    else {\n      onig_strcpy(NSTR(node)->s + len, s, end);\n    }\n    NSTR(node)->end = NSTR(node)->s + len + addlen;\n  }\n\n  return 0;\n}\n\nextern int\nonig_node_str_set(Node* node, const UChar* s, const UChar* end)\n{\n  onig_node_str_clear(node);\n  return onig_node_str_cat(node, s, end);\n}\n\nstatic int\nnode_str_cat_char(Node* node, UChar c)\n{\n  UChar s[1];\n\n  s[0] = c;\n  return onig_node_str_cat(node, s, s + 1);\n}\n\nextern void\nonig_node_conv_to_str_node(Node* node, int flag)\n{\n  SET_NTYPE(node, NT_STR);\n  NSTR(node)->flag = flag;\n  NSTR(node)->capa = 0;\n  NSTR(node)->s    = NSTR(node)->buf;\n  NSTR(node)->end  = NSTR(node)->buf;\n}\n\nextern void\nonig_node_str_clear(Node* node)\n{\n  if (NSTR(node)->capa != 0 &&\n      IS_NOT_NULL(NSTR(node)->s) && NSTR(node)->s != NSTR(node)->buf) {\n    xfree(NSTR(node)->s);\n  }\n\n  NSTR(node)->capa = 0;\n  NSTR(node)->flag = 0;\n  NSTR(node)->s    = NSTR(node)->buf;\n  NSTR(node)->end  = NSTR(node)->buf;\n}\n\nstatic Node*\nnode_new_str(const UChar* s, const UChar* end)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_STR);\n  NSTR(node)->capa = 0;\n  NSTR(node)->flag = 0;\n  NSTR(node)->s    = NSTR(node)->buf;\n  NSTR(node)->end  = NSTR(node)->buf;\n  if (onig_node_str_cat(node, s, end)) {\n    onig_node_free(node);\n    return NULL;\n  }\n  return node;\n}\n\nextern Node*\nonig_node_new_str(const UChar* s, const UChar* end)\n{\n  return node_new_str(s, end);\n}\n\nstatic Node*\nnode_new_str_raw(UChar* s, UChar* end)\n{\n  Node* node = node_new_str(s, end);\n  NSTRING_SET_RAW(node);\n  return node;\n}\n\nstatic Node*\nnode_new_empty(void)\n{\n  return node_new_str(NULL, NULL);\n}\n\nstatic Node*\nnode_new_str_raw_char(UChar c)\n{\n  UChar p[1];\n\n  p[0] = c;\n  return node_new_str_raw(p, p + 1);\n}\n\nstatic Node*\nstr_node_split_last_char(StrNode* sn, OnigEncoding enc)\n{\n  const UChar *p;\n  Node* n = NULL_NODE;\n\n  if (sn->end > sn->s) {\n    p = onigenc_get_prev_char_head(enc, sn->s, sn->end);\n    if (p && p > sn->s) { /* can be split. */\n      n = node_new_str(p, sn->end);\n      if ((sn->flag & NSTR_RAW) != 0)\n        NSTRING_SET_RAW(n);\n\n      sn->end = (UChar* )p;\n    }\n  }\n  return n;\n}\n\nstatic int\nstr_node_can_be_split(StrNode* sn, OnigEncoding enc)\n{\n  if (sn->end > sn->s) {\n    return ((enclen(enc, sn->s) < sn->end - sn->s)  ?  1 : 0);\n  }\n  return 0;\n}\n\n#ifdef USE_PAD_TO_SHORT_BYTE_CHAR\nstatic int\nnode_str_head_pad(StrNode* sn, int num, UChar val)\n{\n  UChar buf[NODE_STR_BUF_SIZE];\n  int i, len;\n\n  len = sn->end - sn->s;\n  onig_strcpy(buf, sn->s, sn->end);\n  onig_strcpy(&(sn->s[num]), buf, buf + len);\n  sn->end += num;\n\n  for (i = 0; i < num; i++) {\n    sn->s[i] = val;\n  }\n}\n#endif\n\nextern int\nonig_scan_unsigned_number(UChar** src, const UChar* end, OnigEncoding enc)\n{\n  unsigned int num, val;\n  OnigCodePoint c;\n  UChar* p = *src;\n  PFETCH_READY;\n\n  num = 0;\n  while (!PEND) {\n    PFETCH(c);\n    if (ONIGENC_IS_CODE_DIGIT(enc, c)) {\n      val = (unsigned int )DIGITVAL(c);\n      if ((INT_MAX_LIMIT - val) / 10UL < num)\n        return -1;  /* overflow */\n\n      num = num * 10 + val;\n    }\n    else {\n      PUNFETCH;\n      break;\n    }\n  }\n  *src = p;\n  return num;\n}\n\nstatic int\nscan_unsigned_hexadecimal_number(UChar** src, UChar* end, int maxlen,\n\t\t\t\t OnigEncoding enc)\n{\n  OnigCodePoint c;\n  unsigned int num, val;\n  UChar* p = *src;\n  PFETCH_READY;\n\n  num = 0;\n  while (! PEND && maxlen-- != 0) {\n    PFETCH(c);\n    if (ONIGENC_IS_CODE_XDIGIT(enc, c)) {\n      val = (unsigned int )XDIGITVAL(enc,c);\n      if ((INT_MAX_LIMIT - val) / 16UL < num)\n        return -1;  /* overflow */\n\n      num = (num << 4) + XDIGITVAL(enc,c);\n    }\n    else {\n      PUNFETCH;\n      break;\n    }\n  }\n  *src = p;\n  return num;\n}\n\nstatic int\nscan_unsigned_octal_number(UChar** src, UChar* end, int maxlen,\n\t\t\t   OnigEncoding enc)\n{\n  OnigCodePoint c;\n  unsigned int num, val;\n  UChar* p = *src;\n  PFETCH_READY;\n\n  num = 0;\n  while (!PEND && maxlen-- != 0) {\n    PFETCH(c);\n    if (ONIGENC_IS_CODE_DIGIT(enc, c) && c < '8') {\n      val = ODIGITVAL(c);\n      if ((INT_MAX_LIMIT - val) / 8UL < num)\n        return -1;  /* overflow */\n\n      num = (num << 3) + val;\n    }\n    else {\n      PUNFETCH;\n      break;\n    }\n  }\n  *src = p;\n  return num;\n}\n\n\n#define BBUF_WRITE_CODE_POINT(bbuf,pos,code) \\\n    BBUF_WRITE(bbuf, pos, &(code), SIZE_CODE_POINT)\n\n/* data format:\n     [n][from-1][to-1][from-2][to-2] ... [from-n][to-n]\n     (all data size is OnigCodePoint)\n */\nstatic int\nnew_code_range(BBuf** pbuf)\n{\n#define INIT_MULTI_BYTE_RANGE_SIZE  (SIZE_CODE_POINT * 5)\n  int r;\n  OnigCodePoint n;\n  BBuf* bbuf;\n\n  bbuf = *pbuf = (BBuf* )xmalloc(sizeof(BBuf));\n  CHECK_NULL_RETURN_MEMERR(*pbuf);\n  r = BBUF_INIT(*pbuf, INIT_MULTI_BYTE_RANGE_SIZE);\n  if (r) return r;\n\n  n = 0;\n  BBUF_WRITE_CODE_POINT(bbuf, 0, n);\n  return 0;\n}\n\nstatic int\nadd_code_range_to_buf(BBuf** pbuf, OnigCodePoint from, OnigCodePoint to)\n{\n  int r, inc_n, pos;\n  int low, high, bound, x;\n  OnigCodePoint n, *data;\n  BBuf* bbuf;\n\n  if (from > to) {\n    n = from; from = to; to = n;\n  }\n\n  if (IS_NULL(*pbuf)) {\n    r = new_code_range(pbuf);\n    if (r) return r;\n    bbuf = *pbuf;\n    n = 0;\n  }\n  else {\n    bbuf = *pbuf;\n    GET_CODE_POINT(n, bbuf->p);\n  }\n  data = (OnigCodePoint* )(bbuf->p);\n  data++;\n\n  for (low = 0, bound = n; low < bound; ) {\n    x = (low + bound) >> 1;\n    if (from > data[x*2 + 1])\n      low = x + 1;\n    else\n      bound = x;\n  }\n\n  high = (to == ~((OnigCodePoint )0)) ? n : low;\n  for (bound = n; high < bound; ) {\n    x = (high + bound) >> 1;\n    if (to + 1 >= data[x*2])\n      high = x + 1;\n    else\n      bound = x;\n  }\n\n  inc_n = low + 1 - high;\n  if (n + inc_n > ONIG_MAX_MULTI_BYTE_RANGES_NUM)\n    return ONIGERR_TOO_MANY_MULTI_BYTE_RANGES;\n\n  if (inc_n != 1) {\n    if (from > data[low*2])\n      from = data[low*2];\n    if (to < data[(high - 1)*2 + 1])\n      to = data[(high - 1)*2 + 1];\n  }\n\n  if (inc_n != 0 && (OnigCodePoint )high < n) {\n    int from_pos = SIZE_CODE_POINT * (1 + high * 2);\n    int to_pos   = SIZE_CODE_POINT * (1 + (low + 1) * 2);\n    int size = (n - high) * 2 * SIZE_CODE_POINT;\n\n    if (inc_n > 0) {\n      BBUF_MOVE_RIGHT(bbuf, from_pos, to_pos, size);\n    }\n    else {\n      BBUF_MOVE_LEFT_REDUCE(bbuf, from_pos, to_pos);\n    }\n  }\n\n  pos = SIZE_CODE_POINT * (1 + low * 2);\n  BBUF_ENSURE_SIZE(bbuf, pos + SIZE_CODE_POINT * 2);\n  BBUF_WRITE_CODE_POINT(bbuf, pos, from);\n  BBUF_WRITE_CODE_POINT(bbuf, pos + SIZE_CODE_POINT, to);\n  n += inc_n;\n  BBUF_WRITE_CODE_POINT(bbuf, 0, n);\n\n  return 0;\n}\n\nstatic int\nadd_code_range(BBuf** pbuf, ScanEnv* env, OnigCodePoint from, OnigCodePoint to)\n{\n  if (from > to) {\n    if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n      return 0;\n    else\n      return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n  }\n\n  return add_code_range_to_buf(pbuf, from, to);\n}\n\nstatic int\nnot_code_range_buf(OnigEncoding enc, BBuf* bbuf, BBuf** pbuf)\n{\n  int r, i, n;\n  OnigCodePoint pre, from, *data, to = 0;\n\n  *pbuf = (BBuf* )NULL;\n  if (IS_NULL(bbuf)) {\n  set_all:\n    return SET_ALL_MULTI_BYTE_RANGE(enc, pbuf);\n  }\n\n  data = (OnigCodePoint* )(bbuf->p);\n  GET_CODE_POINT(n, data);\n  data++;\n  if (n <= 0) goto set_all;\n\n  r = 0;\n  pre = MBCODE_START_POS(enc);\n  for (i = 0; i < n; i++) {\n    from = data[i*2];\n    to   = data[i*2+1];\n    if (pre <= from - 1) {\n      r = add_code_range_to_buf(pbuf, pre, from - 1);\n      if (r != 0) return r;\n    }\n    if (to == ~((OnigCodePoint )0)) break;\n    pre = to + 1;\n  }\n  if (to < ~((OnigCodePoint )0)) {\n    r = add_code_range_to_buf(pbuf, to + 1, ~((OnigCodePoint )0));\n  }\n  return r;\n}\n\n#define SWAP_BBUF_NOT(bbuf1, not1, bbuf2, not2) do {\\\n  BBuf *tbuf; \\\n  int  tnot; \\\n  tnot = not1;  not1  = not2;  not2  = tnot; \\\n  tbuf = bbuf1; bbuf1 = bbuf2; bbuf2 = tbuf; \\\n} while (0)\n\nstatic int\nor_code_range_buf(OnigEncoding enc, BBuf* bbuf1, int not1,\n                  BBuf* bbuf2, int not2, BBuf** pbuf)\n{\n  int r;\n  OnigCodePoint i, n1, *data1;\n  OnigCodePoint from, to;\n\n  *pbuf = (BBuf* )NULL;\n  if (IS_NULL(bbuf1) && IS_NULL(bbuf2)) {\n    if (not1 != 0 || not2 != 0)\n      return SET_ALL_MULTI_BYTE_RANGE(enc, pbuf);\n    return 0;\n  }\n\n  r = 0;\n  if (IS_NULL(bbuf2))\n    SWAP_BBUF_NOT(bbuf1, not1, bbuf2, not2);\n\n  if (IS_NULL(bbuf1)) {\n    if (not1 != 0) {\n      return SET_ALL_MULTI_BYTE_RANGE(enc, pbuf);\n    }\n    else {\n      if (not2 == 0) {\n        return bbuf_clone(pbuf, bbuf2);\n      }\n      else {\n        return not_code_range_buf(enc, bbuf2, pbuf);\n      }\n    }\n  }\n\n  if (not1 != 0)\n    SWAP_BBUF_NOT(bbuf1, not1, bbuf2, not2);\n\n  data1 = (OnigCodePoint* )(bbuf1->p);\n  GET_CODE_POINT(n1, data1);\n  data1++;\n\n  if (not2 == 0 && not1 == 0) { /* 1 OR 2 */\n    r = bbuf_clone(pbuf, bbuf2);\n  }\n  else if (not1 == 0) { /* 1 OR (not 2) */\n    r = not_code_range_buf(enc, bbuf2, pbuf);\n  }\n  if (r != 0) return r;\n\n  for (i = 0; i < n1; i++) {\n    from = data1[i*2];\n    to   = data1[i*2+1];\n    r = add_code_range_to_buf(pbuf, from, to);\n    if (r != 0) return r;\n  }\n  return 0;\n}\n\nstatic int\nand_code_range1(BBuf** pbuf, OnigCodePoint from1, OnigCodePoint to1,\n\t        OnigCodePoint* data, int n)\n{\n  int i, r;\n  OnigCodePoint from2, to2;\n\n  for (i = 0; i < n; i++) {\n    from2 = data[i*2];\n    to2   = data[i*2+1];\n    if (from2 < from1) {\n      if (to2 < from1) continue;\n      else {\n        from1 = to2 + 1;\n      }\n    }\n    else if (from2 <= to1) {\n      if (to2 < to1) {\n        if (from1 <= from2 - 1) {\n          r = add_code_range_to_buf(pbuf, from1, from2-1);\n          if (r != 0) return r;\n        }\n        from1 = to2 + 1;\n      }\n      else {\n        to1 = from2 - 1;\n      }\n    }\n    else {\n      from1 = from2;\n    }\n    if (from1 > to1) break;\n  }\n  if (from1 <= to1) {\n    r = add_code_range_to_buf(pbuf, from1, to1);\n    if (r != 0) return r;\n  }\n  return 0;\n}\n\nstatic int\nand_code_range_buf(BBuf* bbuf1, int not1, BBuf* bbuf2, int not2, BBuf** pbuf)\n{\n  int r;\n  OnigCodePoint i, j, n1, n2, *data1, *data2;\n  OnigCodePoint from, to, from1, to1, from2, to2;\n\n  *pbuf = (BBuf* )NULL;\n  if (IS_NULL(bbuf1)) {\n    if (not1 != 0 && IS_NOT_NULL(bbuf2)) /* not1 != 0 -> not2 == 0 */\n      return bbuf_clone(pbuf, bbuf2);\n    return 0;\n  }\n  else if (IS_NULL(bbuf2)) {\n    if (not2 != 0)\n      return bbuf_clone(pbuf, bbuf1);\n    return 0;\n  }\n\n  if (not1 != 0)\n    SWAP_BBUF_NOT(bbuf1, not1, bbuf2, not2);\n\n  data1 = (OnigCodePoint* )(bbuf1->p);\n  data2 = (OnigCodePoint* )(bbuf2->p);\n  GET_CODE_POINT(n1, data1);\n  GET_CODE_POINT(n2, data2);\n  data1++;\n  data2++;\n\n  if (not2 == 0 && not1 == 0) { /* 1 AND 2 */\n    for (i = 0; i < n1; i++) {\n      from1 = data1[i*2];\n      to1   = data1[i*2+1];\n      for (j = 0; j < n2; j++) {\n        from2 = data2[j*2];\n        to2   = data2[j*2+1];\n        if (from2 > to1) break;\n        if (to2 < from1) continue;\n        from = MAX(from1, from2);\n        to   = MIN(to1, to2);\n        r = add_code_range_to_buf(pbuf, from, to);\n        if (r != 0) return r;\n      }\n    }\n  }\n  else if (not1 == 0) { /* 1 AND (not 2) */\n    for (i = 0; i < n1; i++) {\n      from1 = data1[i*2];\n      to1   = data1[i*2+1];\n      r = and_code_range1(pbuf, from1, to1, data2, n2);\n      if (r != 0) return r;\n    }\n  }\n\n  return 0;\n}\n\nstatic int\nand_cclass(CClassNode* dest, CClassNode* cc, OnigEncoding enc)\n{\n  int r, not1, not2;\n  BBuf *buf1, *buf2, *pbuf;\n  BitSetRef bsr1, bsr2;\n  BitSet bs1, bs2;\n\n  not1 = IS_NCCLASS_NOT(dest);\n  bsr1 = dest->bs;\n  buf1 = dest->mbuf;\n  not2 = IS_NCCLASS_NOT(cc);\n  bsr2 = cc->bs;\n  buf2 = cc->mbuf;\n\n  if (not1 != 0) {\n    bitset_invert_to(bsr1, bs1);\n    bsr1 = bs1;\n  }\n  if (not2 != 0) {\n    bitset_invert_to(bsr2, bs2);\n    bsr2 = bs2;\n  }\n  bitset_and(bsr1, bsr2);\n  if (bsr1 != dest->bs) {\n    bitset_copy(dest->bs, bsr1);\n    bsr1 = dest->bs;\n  }\n  if (not1 != 0) {\n    bitset_invert(dest->bs);\n  }\n\n  if (! ONIGENC_IS_SINGLEBYTE(enc)) {\n    if (not1 != 0 && not2 != 0) {\n      r = or_code_range_buf(enc, buf1, 0, buf2, 0, &pbuf);\n    }\n    else {\n      r = and_code_range_buf(buf1, not1, buf2, not2, &pbuf);\n      if (r == 0 && not1 != 0) {\n        BBuf *tbuf;\n        r = not_code_range_buf(enc, pbuf, &tbuf);\n        if (r != 0) {\n          bbuf_free(pbuf);\n          return r;\n        }\n        bbuf_free(pbuf);\n        pbuf = tbuf;\n      }\n    }\n    if (r != 0) return r;\n\n    dest->mbuf = pbuf;\n    bbuf_free(buf1);\n    return r;\n  }\n  return 0;\n}\n\nstatic int\nor_cclass(CClassNode* dest, CClassNode* cc, OnigEncoding enc)\n{\n  int r, not1, not2;\n  BBuf *buf1, *buf2, *pbuf;\n  BitSetRef bsr1, bsr2;\n  BitSet bs1, bs2;\n\n  not1 = IS_NCCLASS_NOT(dest);\n  bsr1 = dest->bs;\n  buf1 = dest->mbuf;\n  not2 = IS_NCCLASS_NOT(cc);\n  bsr2 = cc->bs;\n  buf2 = cc->mbuf;\n\n  if (not1 != 0) {\n    bitset_invert_to(bsr1, bs1);\n    bsr1 = bs1;\n  }\n  if (not2 != 0) {\n    bitset_invert_to(bsr2, bs2);\n    bsr2 = bs2;\n  }\n  bitset_or(bsr1, bsr2);\n  if (bsr1 != dest->bs) {\n    bitset_copy(dest->bs, bsr1);\n    bsr1 = dest->bs;\n  }\n  if (not1 != 0) {\n    bitset_invert(dest->bs);\n  }\n\n  if (! ONIGENC_IS_SINGLEBYTE(enc)) {\n    if (not1 != 0 && not2 != 0) {\n      r = and_code_range_buf(buf1, 0, buf2, 0, &pbuf);\n    }\n    else {\n      r = or_code_range_buf(enc, buf1, not1, buf2, not2, &pbuf);\n      if (r == 0 && not1 != 0) {\n        BBuf *tbuf;\n        r = not_code_range_buf(enc, pbuf, &tbuf);\n        if (r != 0) {\n          bbuf_free(pbuf);\n          return r;\n        }\n        bbuf_free(pbuf);\n        pbuf = tbuf;\n      }\n    }\n    if (r != 0) return r;\n\n    dest->mbuf = pbuf;\n    bbuf_free(buf1);\n    return r;\n  }\n  else\n    return 0;\n}\n\nstatic OnigCodePoint\nconv_backslash_value(OnigCodePoint c, ScanEnv* env)\n{\n  if (IS_SYNTAX_OP(env->syntax, ONIG_SYN_OP_ESC_CONTROL_CHARS)) {\n    switch (c) {\n    case 'n': return '\\n';\n    case 't': return '\\t';\n    case 'r': return '\\r';\n    case 'f': return '\\f';\n    case 'a': return '\\007';\n    case 'b': return '\\010';\n    case 'e': return '\\033';\n    case 'v':\n      if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ESC_V_VTAB))\n\treturn '\\v';\n      break;\n\n    default:\n      break;\n    }\n  }\n  return c;\n}\n\nstatic int\nis_invalid_quantifier_target(Node* node)\n{\n  switch (NTYPE(node)) {\n  case NT_ANCHOR:\n    return 1;\n    break;\n\n  case NT_ENCLOSE:\n    /* allow enclosed elements */\n    /* return is_invalid_quantifier_target(NENCLOSE(node)->target); */\n    break;\n\n  case NT_LIST:\n    do {\n      if (! is_invalid_quantifier_target(NCAR(node))) return 0;\n    } while (IS_NOT_NULL(node = NCDR(node)));\n    return 0;\n    break;\n\n  case NT_ALT:\n    do {\n      if (is_invalid_quantifier_target(NCAR(node))) return 1;\n    } while (IS_NOT_NULL(node = NCDR(node)));\n    break;\n\n  default:\n    break;\n  }\n  return 0;\n}\n\n/* ?:0, *:1, +:2, ??:3, *?:4, +?:5 */\nstatic int\npopular_quantifier_num(QtfrNode* q)\n{\n  if (q->greedy) {\n    if (q->lower == 0) {\n      if (q->upper == 1) return 0;\n      else if (IS_REPEAT_INFINITE(q->upper)) return 1;\n    }\n    else if (q->lower == 1) {\n      if (IS_REPEAT_INFINITE(q->upper)) return 2;\n    }\n  }\n  else {\n    if (q->lower == 0) {\n      if (q->upper == 1) return 3;\n      else if (IS_REPEAT_INFINITE(q->upper)) return 4;\n    }\n    else if (q->lower == 1) {\n      if (IS_REPEAT_INFINITE(q->upper)) return 5;\n    }\n  }\n  return -1;\n}\n\n\nenum ReduceType {\n  RQ_ASIS = 0, /* as is */\n  RQ_DEL  = 1, /* delete parent */\n  RQ_A,        /* to '*'    */\n  RQ_AQ,       /* to '*?'   */\n  RQ_QQ,       /* to '??'   */\n  RQ_P_QQ,     /* to '+)??' */\n  RQ_PQ_Q      /* to '+?)?' */\n};\n\nstatic enum ReduceType ReduceTypeTable[6][6] = {\n  {RQ_DEL,  RQ_A,    RQ_A,   RQ_QQ,   RQ_AQ,   RQ_ASIS}, /* '?'  */\n  {RQ_DEL,  RQ_DEL,  RQ_DEL, RQ_P_QQ, RQ_P_QQ, RQ_DEL},  /* '*'  */\n  {RQ_A,    RQ_A,    RQ_DEL, RQ_ASIS, RQ_P_QQ, RQ_DEL},  /* '+'  */\n  {RQ_DEL,  RQ_AQ,   RQ_AQ,  RQ_DEL,  RQ_AQ,   RQ_AQ},   /* '??' */\n  {RQ_DEL,  RQ_DEL,  RQ_DEL, RQ_DEL,  RQ_DEL,  RQ_DEL},  /* '*?' */\n  {RQ_ASIS, RQ_PQ_Q, RQ_DEL, RQ_AQ,   RQ_AQ,   RQ_DEL}   /* '+?' */\n};\n\nextern void\nonig_reduce_nested_quantifier(Node* pnode, Node* cnode)\n{\n  int pnum, cnum;\n  QtfrNode *p, *c;\n\n  p = NQTFR(pnode);\n  c = NQTFR(cnode);\n  pnum = popular_quantifier_num(p);\n  cnum = popular_quantifier_num(c);\n  if (pnum < 0 || cnum < 0) return ;\n\n  switch(ReduceTypeTable[cnum][pnum]) {\n  case RQ_DEL:\n    *pnode = *cnode;\n    break;\n  case RQ_A:\n    p->target = c->target;\n    p->lower  = 0;  p->upper = REPEAT_INFINITE;  p->greedy = 1;\n    break;\n  case RQ_AQ:\n    p->target = c->target;\n    p->lower  = 0;  p->upper = REPEAT_INFINITE;  p->greedy = 0;\n    break;\n  case RQ_QQ:\n    p->target = c->target;\n    p->lower  = 0;  p->upper = 1;  p->greedy = 0;\n    break;\n  case RQ_P_QQ:\n    p->target = cnode;\n    p->lower  = 0;  p->upper = 1;  p->greedy = 0;\n    c->lower  = 1;  c->upper = REPEAT_INFINITE;  c->greedy = 1;\n    return ;\n    break;\n  case RQ_PQ_Q:\n    p->target = cnode;\n    p->lower  = 0;  p->upper = 1;  p->greedy = 1;\n    c->lower  = 1;  c->upper = REPEAT_INFINITE;  c->greedy = 0;\n    return ;\n    break;\n  case RQ_ASIS:\n    p->target = cnode;\n    return ;\n    break;\n  }\n\n  c->target = NULL_NODE;\n  onig_node_free(cnode);\n}\n\n\nenum TokenSyms {\n  TK_EOT      = 0,   /* end of token */\n  TK_RAW_BYTE = 1,\n  TK_CHAR,\n  TK_STRING,\n  TK_CODE_POINT,\n  TK_ANYCHAR,\n  TK_CHAR_TYPE,\n  TK_BACKREF,\n  TK_CALL,\n  TK_ANCHOR,\n  TK_OP_REPEAT,\n  TK_INTERVAL,\n  TK_ANYCHAR_ANYTIME,  /* SQL '%' == .* */\n  TK_ALT,\n  TK_SUBEXP_OPEN,\n  TK_SUBEXP_CLOSE,\n  TK_CC_OPEN,\n  TK_QUOTE_OPEN,\n  TK_CHAR_PROPERTY,    /* \\p{...}, \\P{...} */\n  /* in cc */\n  TK_CC_CLOSE,\n  TK_CC_RANGE,\n  TK_POSIX_BRACKET_OPEN,\n  TK_CC_AND,             /* && */\n  TK_CC_CC_OPEN          /* [ */\n};\n\ntypedef struct {\n  enum TokenSyms type;\n  int escaped;\n  int base;   /* is number: 8, 16 (used in [....]) */\n  UChar* backp;\n  union {\n    UChar* s;\n    int   c;\n    OnigCodePoint code;\n    int   anchor;\n    int   subtype;\n    struct {\n      int lower;\n      int upper;\n      int greedy;\n      int possessive;\n    } repeat;\n    struct {\n      int  num;\n      int  ref1;\n      int* refs;\n      int  by_name;\n#ifdef USE_BACKREF_WITH_LEVEL\n      int  exist_level;\n      int  level;   /* \\k<name+n> */\n#endif\n    } backref;\n    struct {\n      UChar* name;\n      UChar* name_end;\n      int    gnum;\n    } call;\n    struct {\n      int ctype;\n      int not;\n    } prop;\n  } u;\n} OnigToken;\n\n\nstatic int\nfetch_range_quantifier(UChar** src, UChar* end, OnigToken* tok, ScanEnv* env)\n{\n  int low, up, syn_allow, non_low = 0;\n  int r = 0;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n  UChar* p = *src;\n  PFETCH_READY;\n\n  syn_allow = IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_INVALID_INTERVAL);\n\n  if (PEND) {\n    if (syn_allow)\n      return 1;  /* \"....{\" : OK! */\n    else\n      return ONIGERR_END_PATTERN_AT_LEFT_BRACE;  /* \"....{\" syntax error */\n  }\n\n  if (! syn_allow) {\n    c = PPEEK;\n    if (c == ')' || c == '(' || c == '|') {\n      return ONIGERR_END_PATTERN_AT_LEFT_BRACE;\n    }\n  }\n\n  low = onig_scan_unsigned_number(&p, end, env->enc);\n  if (low < 0) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;\n  if (low > ONIG_MAX_REPEAT_NUM)\n    return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;\n\n  if (p == *src) { /* can't read low */\n    if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_INTERVAL_LOW_ABBREV)) {\n      /* allow {,n} as {0,n} */\n      low = 0;\n      non_low = 1;\n    }\n    else\n      goto invalid;\n  }\n\n  if (PEND) goto invalid;\n  PFETCH(c);\n  if (c == ',') {\n    UChar* prev = p;\n    up = onig_scan_unsigned_number(&p, end, env->enc);\n    if (up < 0) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;\n    if (up > ONIG_MAX_REPEAT_NUM)\n      return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;\n\n    if (p == prev) {\n      if (non_low != 0)\n        goto invalid;\n      up = REPEAT_INFINITE;  /* {n,} : {n,infinite} */\n    }\n  }\n  else {\n    if (non_low != 0)\n      goto invalid;\n\n    PUNFETCH;\n    up = low;  /* {n} : exact n times */\n    r = 2;     /* fixed */\n  }\n\n  if (PEND) goto invalid;\n  PFETCH(c);\n  if (IS_SYNTAX_OP(env->syntax, ONIG_SYN_OP_ESC_BRACE_INTERVAL)) {\n    if (c != MC_ESC(env->syntax)) goto invalid;\n    PFETCH(c);\n  }\n  if (c != '}') goto invalid;\n\n  if (!IS_REPEAT_INFINITE(up) && low > up) {\n    return ONIGERR_UPPER_SMALLER_THAN_LOWER_IN_REPEAT_RANGE;\n  }\n\n  tok->type = TK_INTERVAL;\n  tok->u.repeat.lower = low;\n  tok->u.repeat.upper = up;\n  *src = p;\n  return r; /* 0: normal {n,m}, 2: fixed {n} */\n\n invalid:\n  if (syn_allow) {\n    /* *src = p; */ /* !!! Don't do this line !!! */\n    return 1;  /* OK */\n  }\n  else\n    return ONIGERR_INVALID_REPEAT_RANGE_PATTERN;\n}\n\n/* \\M-, \\C-, \\c, or \\... */\nstatic int\nfetch_escaped_value(UChar** src, UChar* end, ScanEnv* env, OnigCodePoint* val)\n{\n  int v;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n  UChar* p = *src;\n\n  if (PEND) return ONIGERR_END_PATTERN_AT_ESCAPE;\n\n  PFETCH_S(c);\n  switch (c) {\n  case 'M':\n    if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ESC_CAPITAL_M_BAR_META)) {\n      if (PEND) return ONIGERR_END_PATTERN_AT_META;\n      PFETCH_S(c);\n      if (c != '-') return ONIGERR_META_CODE_SYNTAX;\n      if (PEND) return ONIGERR_END_PATTERN_AT_META;\n      PFETCH_S(c);\n      if (c == MC_ESC(env->syntax)) {\n        v = fetch_escaped_value(&p, end, env, &c);\n        if (v < 0) return v;\n      }\n      c = ((c & 0xff) | 0x80);\n    }\n    else\n      goto backslash;\n    break;\n\n  case 'C':\n    if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ESC_CAPITAL_C_BAR_CONTROL)) {\n      if (PEND) return ONIGERR_END_PATTERN_AT_CONTROL;\n      PFETCH_S(c);\n      if (c != '-') return ONIGERR_CONTROL_CODE_SYNTAX;\n      goto control;\n    }\n    else\n      goto backslash;\n\n  case 'c':\n    if (IS_SYNTAX_OP(env->syntax, ONIG_SYN_OP_ESC_C_CONTROL)) {\n    control:\n      if (PEND) return ONIGERR_END_PATTERN_AT_CONTROL;\n      PFETCH_S(c);\n      if (c == '?') {\n        c = 0177;\n      }\n      else {\n        if (c == MC_ESC(env->syntax)) {\n          v = fetch_escaped_value(&p, end, env, &c);\n          if (v < 0) return v;\n        }\n        c &= 0x9f;\n      }\n      break;\n    }\n    /* fall through */\n\n  default:\n    {\n    backslash:\n      c = conv_backslash_value(c, env);\n    }\n    break;\n  }\n\n  *src = p;\n  *val = c;\n  return 0;\n}\n\nstatic int fetch_token(OnigToken* tok, UChar** src, UChar* end, ScanEnv* env);\n\nstatic OnigCodePoint\nget_name_end_code_point(OnigCodePoint start)\n{\n  switch (start) {\n  case '<':  return (OnigCodePoint )'>'; break;\n  case '\\'': return (OnigCodePoint )'\\''; break;\n  default:\n    break;\n  }\n\n  return (OnigCodePoint )0;\n}\n\n#ifdef USE_NAMED_GROUP\n#ifdef USE_BACKREF_WITH_LEVEL\n/*\n   \\k<name+n>, \\k<name-n>\n   \\k<num+n>,  \\k<num-n>\n   \\k<-num+n>, \\k<-num-n>\n*/\nstatic int\nfetch_name_with_level(OnigCodePoint start_code, UChar** src, UChar* end,\n\t\t      UChar** rname_end, ScanEnv* env,\n\t\t      int* rback_num, int* rlevel)\n{\n  int r, sign, is_num, exist_level;\n  OnigCodePoint end_code;\n  OnigCodePoint c = 0;\n  OnigEncoding enc = env->enc;\n  UChar *name_end;\n  UChar *pnum_head;\n  UChar *p = *src;\n  PFETCH_READY;\n\n  *rback_num = 0;\n  is_num = exist_level = 0;\n  sign = 1;\n  pnum_head = *src;\n\n  end_code = get_name_end_code_point(start_code);\n\n  name_end = end;\n  r = 0;\n  if (PEND) {\n    return ONIGERR_EMPTY_GROUP_NAME;\n  }\n  else {\n    PFETCH(c);\n    if (c == end_code)\n      return ONIGERR_EMPTY_GROUP_NAME;\n\n    if (ONIGENC_IS_CODE_DIGIT(enc, c)) {\n      is_num = 1;\n    }\n    else if (c == '-') {\n      is_num = 2;\n      sign = -1;\n      pnum_head = p;\n    }\n    else if (!ONIGENC_IS_CODE_WORD(enc, c)) {\n      r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n    }\n  }\n\n  while (!PEND) {\n    name_end = p;\n    PFETCH(c);\n    if (c == end_code || c == ')' || c == '+' || c == '-') {\n      if (is_num == 2) \tr = ONIGERR_INVALID_GROUP_NAME;\n      break;\n    }\n\n    if (is_num != 0) {\n      if (ONIGENC_IS_CODE_DIGIT(enc, c)) {\n        is_num = 1;\n      }\n      else {\n        r = ONIGERR_INVALID_GROUP_NAME;\n        is_num = 0;\n      }\n    }\n    else if (!ONIGENC_IS_CODE_WORD(enc, c)) {\n      r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n    }\n  }\n\n  if (r == 0 && c != end_code) {\n    if (c == '+' || c == '-') {\n      int level;\n      int flag = (c == '-' ? -1 : 1);\n\n      if (PEND) {\n\tr = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n\tgoto end;\n      }\n      PFETCH(c);\n      if (! ONIGENC_IS_CODE_DIGIT(enc, c)) goto err;\n      PUNFETCH;\n      level = onig_scan_unsigned_number(&p, end, enc);\n      if (level < 0) return ONIGERR_TOO_BIG_NUMBER;\n      *rlevel = (level * flag);\n      exist_level = 1;\n\n      if (!PEND) {\n\tPFETCH(c);\n\tif (c == end_code)\n\t  goto end;\n      }\n    }\n\n  err:\n    r = ONIGERR_INVALID_GROUP_NAME;\n    name_end = end;\n  }\n\n end:\n  if (r == 0) {\n    if (is_num != 0) {\n      *rback_num = onig_scan_unsigned_number(&pnum_head, name_end, enc);\n      if (*rback_num < 0) return ONIGERR_TOO_BIG_NUMBER;\n      else if (*rback_num == 0) goto err;\n\n      *rback_num *= sign;\n    }\n\n    *rname_end = name_end;\n    *src = p;\n    return (exist_level ? 1 : 0);\n  }\n  else {\n    onig_scan_env_set_error_string(env, r, *src, name_end);\n    return r;\n  }\n}\n#endif /* USE_BACKREF_WITH_LEVEL */\n\n/*\n  ref: 0 -> define name    (don't allow number name)\n       1 -> reference name (allow number name)\n*/\nstatic int\nfetch_name(OnigCodePoint start_code, UChar** src, UChar* end,\n\t   UChar** rname_end, ScanEnv* env, int* rback_num, int ref)\n{\n  int r, is_num, sign;\n  OnigCodePoint end_code;\n  OnigCodePoint c = 0;\n  OnigEncoding enc = env->enc;\n  UChar *name_end;\n  UChar *pnum_head;\n  UChar *p = *src;\n\n  *rback_num = 0;\n\n  end_code = get_name_end_code_point(start_code);\n\n  name_end = end;\n  pnum_head = *src;\n  r = 0;\n  is_num = 0;\n  sign = 1;\n  if (PEND) {\n    return ONIGERR_EMPTY_GROUP_NAME;\n  }\n  else {\n    PFETCH_S(c);\n    if (c == end_code)\n      return ONIGERR_EMPTY_GROUP_NAME;\n\n    if (ONIGENC_IS_CODE_DIGIT(enc, c)) {\n      if (ref == 1)\n        is_num = 1;\n      else {\n        r = ONIGERR_INVALID_GROUP_NAME;\n        is_num = 0;\n      }\n    }\n    else if (c == '-') {\n      if (ref == 1) {\n        is_num = 2;\n        sign = -1;\n        pnum_head = p;\n      }\n      else {\n        r = ONIGERR_INVALID_GROUP_NAME;\n        is_num = 0;\n      }\n    }\n    else if (!ONIGENC_IS_CODE_WORD(enc, c)) {\n      r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n    }\n  }\n\n  if (r == 0) {\n    while (!PEND) {\n      name_end = p;\n      PFETCH_S(c);\n      if (c == end_code || c == ')') {\n        if (is_num == 2) \tr = ONIGERR_INVALID_GROUP_NAME;\n        break;\n      }\n\n      if (is_num != 0) {\n        if (ONIGENC_IS_CODE_DIGIT(enc, c)) {\n          is_num = 1;\n        }\n        else {\n          if (!ONIGENC_IS_CODE_WORD(enc, c))\n            r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n          else\n            r = ONIGERR_INVALID_GROUP_NAME;\n          is_num = 0;\n        }\n      }\n      else {\n        if (!ONIGENC_IS_CODE_WORD(enc, c)) {\n          r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n        }\n      }\n    }\n\n    if (c != end_code) {\n      r = ONIGERR_INVALID_GROUP_NAME;\n      name_end = end;\n    }\n\n    if (is_num != 0) {\n      *rback_num = onig_scan_unsigned_number(&pnum_head, name_end, enc);\n      if (*rback_num < 0) return ONIGERR_TOO_BIG_NUMBER;\n      else if (*rback_num == 0) {\n        r = ONIGERR_INVALID_GROUP_NAME;\n        goto err;\n      }\n\n      *rback_num *= sign;\n    }\n\n    *rname_end = name_end;\n    *src = p;\n    return 0;\n  }\n  else {\n    while (!PEND) {\n      name_end = p;\n      PFETCH_S(c);\n      if (c == end_code || c == ')')\n        break;\n    }\n    if (PEND)\n      name_end = end;\n\n  err:\n    onig_scan_env_set_error_string(env, r, *src, name_end);\n    return r;\n  }\n}\n#else\nstatic int\nfetch_name(OnigCodePoint start_code, UChar** src, UChar* end,\n\t   UChar** rname_end, ScanEnv* env, int* rback_num, int ref)\n{\n  int r, is_num, sign;\n  OnigCodePoint end_code;\n  OnigCodePoint c = 0;\n  UChar *name_end;\n  OnigEncoding enc = env->enc;\n  UChar *pnum_head;\n  UChar *p = *src;\n  PFETCH_READY;\n\n  *rback_num = 0;\n\n  end_code = get_name_end_code_point(start_code);\n\n  *rname_end = name_end = end;\n  r = 0;\n  pnum_head = *src;\n  is_num = 0;\n  sign = 1;\n\n  if (PEND) {\n    return ONIGERR_EMPTY_GROUP_NAME;\n  }\n  else {\n    PFETCH(c);\n    if (c == end_code)\n      return ONIGERR_EMPTY_GROUP_NAME;\n\n    if (ONIGENC_IS_CODE_DIGIT(enc, c)) {\n      is_num = 1;\n    }\n    else if (c == '-') {\n      is_num = 2;\n      sign = -1;\n      pnum_head = p;\n    }\n    else {\n      r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n    }\n  }\n\n  while (!PEND) {\n    name_end = p;\n\n    PFETCH(c);\n    if (c == end_code || c == ')') break;\n    if (! ONIGENC_IS_CODE_DIGIT(enc, c))\n      r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n  }\n  if (r == 0 && c != end_code) {\n    r = ONIGERR_INVALID_GROUP_NAME;\n    name_end = end;\n  }\n\n  if (r == 0) {\n    *rback_num = onig_scan_unsigned_number(&pnum_head, name_end, enc);\n    if (*rback_num < 0) return ONIGERR_TOO_BIG_NUMBER;\n    else if (*rback_num == 0) {\n      r = ONIGERR_INVALID_GROUP_NAME;\n      goto err;\n    }\n    *rback_num *= sign;\n\n    *rname_end = name_end;\n    *src = p;\n    return 0;\n  }\n  else {\n  err:\n    onig_scan_env_set_error_string(env, r, *src, name_end);\n    return r;\n  }\n}\n#endif /* USE_NAMED_GROUP */\n\nstatic void\nCC_ESC_WARN(ScanEnv* env, UChar *c)\n{\n  if (onig_warn == onig_null_warn) return ;\n\n  if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_WARN_CC_OP_NOT_ESCAPED) &&\n      IS_SYNTAX_BV(env->syntax, ONIG_SYN_BACKSLASH_ESCAPE_IN_CC)) {\n    UChar buf[WARN_BUFSIZE];\n    onig_snprintf_with_pattern(buf, WARN_BUFSIZE, env->enc,\n\t\tenv->pattern, env->pattern_end,\n                (UChar* )\"character class has '%s' without escape\", c);\n    (*onig_warn)((char* )buf);\n  }\n}\n\nstatic void\nCLOSE_BRACKET_WITHOUT_ESC_WARN(ScanEnv* env, UChar* c)\n{\n  if (onig_warn == onig_null_warn) return ;\n\n  if (IS_SYNTAX_BV((env)->syntax, ONIG_SYN_WARN_CC_OP_NOT_ESCAPED)) {\n    UChar buf[WARN_BUFSIZE];\n    onig_snprintf_with_pattern(buf, WARN_BUFSIZE, (env)->enc,\n\t\t(env)->pattern, (env)->pattern_end,\n\t\t(UChar* )\"regular expression has '%s' without escape\", c);\n    (*onig_warn)((char* )buf);\n  }\n}\n\nstatic UChar*\nfind_str_position(OnigCodePoint s[], int n, UChar* from, UChar* to,\n\t\t  UChar **next, OnigEncoding enc)\n{\n  int i;\n  OnigCodePoint x;\n  UChar *q;\n  UChar *p = from;\n  \n  while (p < to) {\n    x = ONIGENC_MBC_TO_CODE(enc, p, to);\n    q = p + enclen(enc, p);\n    if (x == s[0]) {\n      for (i = 1; i < n && q < to; i++) {\n        x = ONIGENC_MBC_TO_CODE(enc, q, to);\n        if (x != s[i]) break;\n        q += enclen(enc, q);\n      }\n      if (i >= n) {\n        if (IS_NOT_NULL(next))\n          *next = q;\n        return p;\n      }\n    }\n    p = q;\n  }\n  return NULL_UCHARP;\n}\n\nstatic int\nstr_exist_check_with_esc(OnigCodePoint s[], int n, UChar* from, UChar* to,\n\t\t OnigCodePoint bad, OnigEncoding enc, OnigSyntaxType* syn)\n{\n  int i, in_esc;\n  OnigCodePoint x;\n  UChar *q;\n  UChar *p = from;\n\n  in_esc = 0;\n  while (p < to) {\n    if (in_esc) {\n      in_esc = 0;\n      p += enclen(enc, p);\n    }\n    else {\n      x = ONIGENC_MBC_TO_CODE(enc, p, to);\n      q = p + enclen(enc, p);\n      if (x == s[0]) {\n        for (i = 1; i < n && q < to; i++) {\n          x = ONIGENC_MBC_TO_CODE(enc, q, to);\n          if (x != s[i]) break;\n          q += enclen(enc, q);\n        }\n        if (i >= n) return 1;\n        p += enclen(enc, p);\n      }\n      else {\n        x = ONIGENC_MBC_TO_CODE(enc, p, to);\n        if (x == bad) return 0;\n        else if (x == MC_ESC(syn)) in_esc = 1;\n        p = q;\n      }\n    }\n  }\n  return 0;\n}\n\nstatic int\nfetch_token_in_cc(OnigToken* tok, UChar** src, UChar* end, ScanEnv* env)\n{\n  int num;\n  OnigCodePoint c, c2;\n  OnigSyntaxType* syn = env->syntax;\n  OnigEncoding enc = env->enc;\n  UChar* prev;\n  UChar* p = *src;\n  PFETCH_READY;\n\n  if (PEND) {\n    tok->type = TK_EOT;\n    return tok->type;\n  }\n\n  PFETCH(c);\n  tok->type = TK_CHAR;\n  tok->base = 0;\n  tok->u.c  = c;\n  tok->escaped = 0;\n\n  if (c == ']') {\n    tok->type = TK_CC_CLOSE;\n  }\n  else if (c == '-') {\n    tok->type = TK_CC_RANGE;\n  }\n  else if (c == MC_ESC(syn)) {\n    if (! IS_SYNTAX_BV(syn, ONIG_SYN_BACKSLASH_ESCAPE_IN_CC))\n      goto end;\n\n    if (PEND) return ONIGERR_END_PATTERN_AT_ESCAPE;\n\n    PFETCH(c);\n    tok->escaped = 1;\n    tok->u.c = c;\n    switch (c) {\n    case 'w':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;\n      tok->u.prop.not   = 0;\n      break;\n    case 'W':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;\n      tok->u.prop.not   = 1;\n      break;\n    case 'd':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;\n      tok->u.prop.not   = 0;\n      break;\n    case 'D':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;\n      tok->u.prop.not   = 1;\n      break;\n    case 's':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;\n      tok->u.prop.not   = 0;\n      break;\n    case 'S':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;\n      tok->u.prop.not   = 1;\n      break;\n    case 'h':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;\n      tok->u.prop.not   = 0;\n      break;\n    case 'H':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'p':\n    case 'P':\n      if (PEND) break;\n\n      c2 = PPEEK;\n      if (c2 == '{' &&\n          IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY)) {\n        PINC;\n        tok->type = TK_CHAR_PROPERTY;\n        tok->u.prop.not = (c == 'P' ? 1 : 0);\n\n        if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT)) {\n          PFETCH(c2);\n          if (c2 == '^') {\n            tok->u.prop.not = (tok->u.prop.not == 0 ? 1 : 0);\n          }\n          else\n            PUNFETCH;\n        }\n      }\n      break;\n\n    case 'o':\n      if (PEND) break;\n\n      prev = p;\n      if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_O_BRACE_OCTAL)) {\n        PINC;\n        num = scan_unsigned_octal_number(&p, end, 11, enc);\n        if (num < 0) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n        if (!PEND) {\n          c2 = PPEEK;\n          if (ONIGENC_IS_CODE_DIGIT(enc, c2))\n            return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;\n        }\n\n        if (p > prev + enclen(enc, prev) && !PEND && (PPEEK_IS('}'))) {\n          PINC;\n          tok->type   = TK_CODE_POINT;\n          tok->base   = 8;\n          tok->u.code = (OnigCodePoint )num;\n        }\n        else {\n          /* can't read nothing or invalid format */\n          p = prev;\n        }\n      }\n      break;\n\n    case 'x':\n      if (PEND) break;\n\n      prev = p;\n      if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_BRACE_HEX8)) {\n        PINC;\n        num = scan_unsigned_hexadecimal_number(&p, end, 8, enc);\n        if (num < 0) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n        if (!PEND) {\n          c2 = PPEEK;\n          if (ONIGENC_IS_CODE_XDIGIT(enc, c2))\n            return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;\n        }\n\n        if (p > prev + enclen(enc, prev) && !PEND && (PPEEK_IS('}'))) {\n          PINC;\n          tok->type   = TK_CODE_POINT;\n          tok->base   = 16;\n          tok->u.code = (OnigCodePoint )num;\n        }\n        else {\n          /* can't read nothing or invalid format */\n          p = prev;\n        }\n      }\n      else if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_HEX2)) {\n        num = scan_unsigned_hexadecimal_number(&p, end, 2, enc);\n        if (num < 0) return ONIGERR_TOO_BIG_NUMBER;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type = TK_RAW_BYTE;\n        tok->base = 16;\n        tok->u.c  = num;\n      }\n      break;\n\n    case 'u':\n      if (PEND) break;\n\n      prev = p;\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_U_HEX4)) {\n        num = scan_unsigned_hexadecimal_number(&p, end, 4, enc);\n        if (num < 0) return ONIGERR_TOO_BIG_NUMBER;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type   = TK_CODE_POINT;\n        tok->base   = 16;\n        tok->u.code = (OnigCodePoint )num;\n      }\n      break;\n\n    case '0':\n    case '1': case '2': case '3': case '4': case '5': case '6': case '7':\n      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_OCTAL3)) {\n        PUNFETCH;\n        prev = p;\n        num = scan_unsigned_octal_number(&p, end, 3, enc);\n        if (num < 0 || num >= 256) return ONIGERR_TOO_BIG_NUMBER;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type = TK_RAW_BYTE;\n        tok->base = 8;\n        tok->u.c  = num;\n      }\n      break;\n\n    default:\n      PUNFETCH;\n      num = fetch_escaped_value(&p, end, env, &c2);\n      if (num < 0) return num;\n      if (tok->u.c != c2) {\n        tok->u.code = c2;\n        tok->type   = TK_CODE_POINT;\n      }\n      break;\n    }\n  }\n  else if (c == '[') {\n    if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_POSIX_BRACKET) && (PPEEK_IS(':'))) {\n      OnigCodePoint send[] = { (OnigCodePoint )':', (OnigCodePoint )']' };\n      tok->backp = p; /* point at '[' is read */\n      PINC;\n      if (str_exist_check_with_esc(send, 2, p, end,\n                                   (OnigCodePoint )']', enc, syn)) {\n        tok->type = TK_POSIX_BRACKET_OPEN;\n      }\n      else {\n        PUNFETCH;\n        goto cc_in_cc;\n      }\n    }\n    else {\n    cc_in_cc:\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_CCLASS_SET_OP)) {\n        tok->type = TK_CC_CC_OPEN;\n      }\n      else {\n        CC_ESC_WARN(env, (UChar* )\"[\");\n      }\n    }\n  }\n  else if (c == '&') {\n    if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_CCLASS_SET_OP) &&\n        !PEND && (PPEEK_IS('&'))) {\n      PINC;\n      tok->type = TK_CC_AND;\n    }\n  }\n\n end:\n  *src = p;\n  return tok->type;\n}\n\nstatic int\nfetch_token(OnigToken* tok, UChar** src, UChar* end, ScanEnv* env)\n{\n  int r, num;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n  OnigSyntaxType* syn = env->syntax;\n  UChar* prev;\n  UChar* p = *src;\n  PFETCH_READY;\n\n start:\n  if (PEND) {\n    tok->type = TK_EOT;\n    return tok->type;\n  }\n\n  tok->type  = TK_STRING;\n  tok->base  = 0;\n  tok->backp = p;\n\n  PFETCH(c);\n  if (IS_MC_ESC_CODE(c, syn)) {\n    if (PEND) return ONIGERR_END_PATTERN_AT_ESCAPE;\n\n    tok->backp = p;\n    PFETCH(c);\n\n    tok->u.c = c;\n    tok->escaped = 1;\n    switch (c) {\n    case '*':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_ASTERISK_ZERO_INF)) break;\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = REPEAT_INFINITE;\n      goto greedy_check;\n      break;\n\n    case '+':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_PLUS_ONE_INF)) break;\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 1;\n      tok->u.repeat.upper = REPEAT_INFINITE;\n      goto greedy_check;\n      break;\n\n    case '?':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_QMARK_ZERO_ONE)) break;\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = 1;\n    greedy_check:\n      if (!PEND && PPEEK_IS('?') &&\n\t  IS_SYNTAX_OP(syn, ONIG_SYN_OP_QMARK_NON_GREEDY)) {\n        PFETCH(c);\n        tok->u.repeat.greedy     = 0;\n        tok->u.repeat.possessive = 0;\n      }\n      else {\n      possessive_check:\n        if (!PEND && PPEEK_IS('+') &&\n            ((IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_PLUS_POSSESSIVE_REPEAT) &&\n              tok->type != TK_INTERVAL)  ||\n             (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_PLUS_POSSESSIVE_INTERVAL) &&\n              tok->type == TK_INTERVAL))) {\n          PFETCH(c);\n          tok->u.repeat.greedy     = 1;\n          tok->u.repeat.possessive = 1;\n        }\n        else {\n          tok->u.repeat.greedy     = 1;\n          tok->u.repeat.possessive = 0;\n        }\n      }\n      break;\n\n    case '{':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_BRACE_INTERVAL)) break;\n      r = fetch_range_quantifier(&p, end, tok, env);\n      if (r < 0) return r;  /* error */\n      if (r == 0) goto greedy_check;\n      else if (r == 2) { /* {n} */\n        if (IS_SYNTAX_BV(syn, ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY))\n          goto possessive_check;\n\n        goto greedy_check;\n      }\n      /* r == 1 : normal char */\n      break;\n\n    case '|':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_VBAR_ALT)) break;\n      tok->type = TK_ALT;\n      break;\n\n    case '(':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_OPEN;\n      break;\n\n    case ')':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_CLOSE;\n      break;\n\n    case 'w':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_W_WORD)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'W':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_W_WORD)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'b':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_B_WORD_BOUND)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor = ANCHOR_WORD_BOUND;\n      break;\n\n    case 'B':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_B_WORD_BOUND)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor = ANCHOR_NOT_WORD_BOUND;\n      break;\n\n#ifdef USE_WORD_BEGIN_END\n    case '<':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor = ANCHOR_WORD_BEGIN;\n      break;\n\n    case '>':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor = ANCHOR_WORD_END;\n      break;\n#endif\n\n    case 's':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_S_WHITE_SPACE)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'S':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_S_WHITE_SPACE)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'd':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_D_DIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'D':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_D_DIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'h':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'H':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'A':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;\n    begin_buf:\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = ANCHOR_BEGIN_BUF;\n      break;\n\n    case 'Z':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = ANCHOR_SEMI_END_BUF;\n      break;\n\n    case 'z':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;\n    end_buf:\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = ANCHOR_END_BUF;\n      break;\n\n    case 'G':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_CAPITAL_G_BEGIN_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = ANCHOR_BEGIN_POSITION;\n      break;\n\n    case '`':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR)) break;\n      goto begin_buf;\n      break;\n\n    case '\\'':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR)) break;\n      goto end_buf;\n      break;\n\n    case 'o':\n      if (PEND) break;\n\n      prev = p;\n      if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_O_BRACE_OCTAL)) {\n        PINC;\n        num = scan_unsigned_octal_number(&p, end, 11, enc);\n        if (num < 0) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n        if (!PEND) {\n          if (ONIGENC_IS_CODE_DIGIT(enc, PPEEK))\n            return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;\n        }\n\n        if ((p > prev + enclen(enc, prev)) && !PEND && PPEEK_IS('}')) {\n          PINC;\n          tok->type   = TK_CODE_POINT;\n          tok->u.code = (OnigCodePoint )num;\n        }\n        else {\n          /* can't read nothing or invalid format */\n          p = prev;\n        }\n      }\n      break;\n\n    case 'x':\n      if (PEND) break;\n\n      prev = p;\n      if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_BRACE_HEX8)) {\n        PINC;\n        num = scan_unsigned_hexadecimal_number(&p, end, 8, enc);\n        if (num < 0) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n        if (!PEND) {\n          if (ONIGENC_IS_CODE_XDIGIT(enc, PPEEK))\n            return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;\n        }\n\n        if ((p > prev + enclen(enc, prev)) && !PEND && PPEEK_IS('}')) {\n          PINC;\n          tok->type   = TK_CODE_POINT;\n          tok->u.code = (OnigCodePoint )num;\n        }\n        else {\n          /* can't read nothing or invalid format */\n          p = prev;\n        }\n      }\n      else if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_HEX2)) {\n        num = scan_unsigned_hexadecimal_number(&p, end, 2, enc);\n        if (num < 0) return ONIGERR_TOO_BIG_NUMBER;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type = TK_RAW_BYTE;\n        tok->base = 16;\n        tok->u.c  = num;\n      }\n      break;\n\n    case 'u':\n      if (PEND) break;\n\n      prev = p;\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_U_HEX4)) {\n        num = scan_unsigned_hexadecimal_number(&p, end, 4, enc);\n        if (num < 0) return ONIGERR_TOO_BIG_NUMBER;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type   = TK_CODE_POINT;\n        tok->base   = 16;\n        tok->u.code = (OnigCodePoint )num;\n      }\n      break;\n\n    case '1': case '2': case '3': case '4':\n    case '5': case '6': case '7': case '8': case '9':\n      PUNFETCH;\n      prev = p;\n      num = onig_scan_unsigned_number(&p, end, enc);\n      if (num < 0 || num > ONIG_MAX_BACKREF_NUM) {\n        goto skip_backref;\n      }\n\n      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_DECIMAL_BACKREF) && \n          (num <= env->num_mem || num <= 9)) { /* This spec. from GNU regex */\n        if (IS_SYNTAX_BV(syn, ONIG_SYN_STRICT_CHECK_BACKREF)) {\n          if (num > env->num_mem || IS_NULL(SCANENV_MEM_NODES(env)[num]))\n            return ONIGERR_INVALID_BACKREF;\n        }\n\n        tok->type = TK_BACKREF;\n        tok->u.backref.num     = 1;\n        tok->u.backref.ref1    = num;\n        tok->u.backref.by_name = 0;\n#ifdef USE_BACKREF_WITH_LEVEL\n        tok->u.backref.exist_level = 0;\n#endif\n        break;\n      }\n\n    skip_backref:\n      if (c == '8' || c == '9') {\n        /* normal char */\n        p = prev; PINC;\n        break;\n      }\n\n      p = prev;\n      /* fall through */\n    case '0':\n      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_OCTAL3)) {\n        prev = p;\n        num = scan_unsigned_octal_number(&p, end, (c == '0' ? 2:3), enc);\n        if (num < 0 || num >= 256) return ONIGERR_TOO_BIG_NUMBER;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type = TK_RAW_BYTE;\n        tok->base = 8;\n        tok->u.c  = num;\n      }\n      else if (c != '0') {\n        PINC;\n      }\n      break;\n\n#ifdef USE_NAMED_GROUP\n    case 'k':\n      if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_K_NAMED_BACKREF)) {\n        PFETCH(c);\n        if (c == '<' || c == '\\'') {\n          UChar* name_end;\n          int* backs;\n          int back_num;\n\n          prev = p;\n\n#ifdef USE_BACKREF_WITH_LEVEL\n          name_end = NULL_UCHARP; /* no need. escape gcc warning. */\n          r = fetch_name_with_level((OnigCodePoint )c, &p, end, &name_end,\n                                    env, &back_num, &tok->u.backref.level);\n          if (r == 1) tok->u.backref.exist_level = 1;\n          else        tok->u.backref.exist_level = 0;\n#else\n          r = fetch_name(&p, end, &name_end, env, &back_num, 1);\n#endif\n          if (r < 0) return r;\n\n          if (back_num != 0) {\n            if (back_num < 0) {\n              back_num = BACKREF_REL_TO_ABS(back_num, env);\n              if (back_num <= 0)\n                return ONIGERR_INVALID_BACKREF;\n            }\n\n            if (IS_SYNTAX_BV(syn, ONIG_SYN_STRICT_CHECK_BACKREF)) {\n              if (back_num > env->num_mem ||\n                  IS_NULL(SCANENV_MEM_NODES(env)[back_num]))\n                return ONIGERR_INVALID_BACKREF;\n            }\n            tok->type = TK_BACKREF;\n            tok->u.backref.by_name = 0;\n            tok->u.backref.num  = 1;\n            tok->u.backref.ref1 = back_num;\n          }\n          else {\n            num = onig_name_to_group_numbers(env->reg, prev, name_end, &backs);\n            if (num <= 0) {\n              onig_scan_env_set_error_string(env,\n                        ONIGERR_UNDEFINED_NAME_REFERENCE, prev, name_end);\n              return ONIGERR_UNDEFINED_NAME_REFERENCE;\n            }\n            if (IS_SYNTAX_BV(syn, ONIG_SYN_STRICT_CHECK_BACKREF)) {\n              int i;\n              for (i = 0; i < num; i++) {\n                if (backs[i] > env->num_mem ||\n                    IS_NULL(SCANENV_MEM_NODES(env)[backs[i]]))\n                  return ONIGERR_INVALID_BACKREF;\n              }\n            }\n\n            tok->type = TK_BACKREF;\n            tok->u.backref.by_name = 1;\n            if (num == 1) {\n              tok->u.backref.num  = 1;\n              tok->u.backref.ref1 = backs[0];\n            }\n            else {\n              tok->u.backref.num  = num;\n              tok->u.backref.refs = backs;\n            }\n          }\n        }\n        else\n          PUNFETCH;\n      }\n      break;\n#endif\n\n#ifdef USE_SUBEXP_CALL\n    case 'g':\n      if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_G_SUBEXP_CALL)) {\n        PFETCH(c);\n        if (c == '<' || c == '\\'') {\n          int gnum;\n          UChar* name_end;\n\n          prev = p;\n          r = fetch_name((OnigCodePoint )c, &p, end, &name_end, env, &gnum, 1);\n          if (r < 0) return r;\n\n          tok->type = TK_CALL;\n          tok->u.call.name     = prev;\n          tok->u.call.name_end = name_end;\n          tok->u.call.gnum     = gnum;\n        }\n        else\n          PUNFETCH;\n      }\n      break;\n#endif\n\n    case 'Q':\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_Q_QUOTE)) {\n        tok->type = TK_QUOTE_OPEN;\n      }\n      break;\n\n    case 'p':\n    case 'P':\n      if (!PEND && PPEEK_IS('{') &&\n          IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY)) {\n        PINC;\n        tok->type = TK_CHAR_PROPERTY;\n        tok->u.prop.not = (c == 'P' ? 1 : 0);\n\n        if (!PEND &&\n            IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT)) {\n          PFETCH(c);\n          if (c == '^') {\n            tok->u.prop.not = (tok->u.prop.not == 0 ? 1 : 0);\n          }\n          else\n            PUNFETCH;\n        }\n      }\n      break;\n\n    default:\n      {\n        OnigCodePoint c2;\n\n        PUNFETCH;\n        num = fetch_escaped_value(&p, end, env, &c2);\n        if (num < 0) return num;\n        /* set_raw: */\n        if (tok->u.c != c2) {\n          tok->type = TK_CODE_POINT;\n          tok->u.code = c2;\n        }\n        else { /* string */\n          p = tok->backp + enclen(enc, tok->backp);\n\t}\n      }\n      break;\n    }\n  }\n  else {\n    tok->u.c = c;\n    tok->escaped = 0;\n\n#ifdef USE_VARIABLE_META_CHARS\n    if ((c != ONIG_INEFFECTIVE_META_CHAR) &&\n        IS_SYNTAX_OP(syn, ONIG_SYN_OP_VARIABLE_META_CHARACTERS)) {\n      if (c == MC_ANYCHAR(syn))\n        goto any_char;\n      else if (c == MC_ANYTIME(syn))\n        goto anytime;\n      else if (c == MC_ZERO_OR_ONE_TIME(syn))\n        goto zero_or_one_time;\n      else if (c == MC_ONE_OR_MORE_TIME(syn))\n        goto one_or_more_time;\n      else if (c == MC_ANYCHAR_ANYTIME(syn)) {\n        tok->type = TK_ANYCHAR_ANYTIME;\n        goto out;\n      }\n    }\n#endif\n\n    switch (c) {\n    case '.':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_DOT_ANYCHAR)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    any_char:\n#endif\n      tok->type = TK_ANYCHAR;\n      break;\n\n    case '*':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ASTERISK_ZERO_INF)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    anytime:\n#endif\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = REPEAT_INFINITE;\n      goto greedy_check;\n      break;\n\n    case '+':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_PLUS_ONE_INF)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    one_or_more_time:\n#endif\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 1;\n      tok->u.repeat.upper = REPEAT_INFINITE;\n      goto greedy_check;\n      break;\n\n    case '?':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_QMARK_ZERO_ONE)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    zero_or_one_time:\n#endif\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = 1;\n      goto greedy_check;\n      break;\n\n    case '{':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_BRACE_INTERVAL)) break;\n      r = fetch_range_quantifier(&p, end, tok, env);\n      if (r < 0) return r;  /* error */\n      if (r == 0) goto greedy_check;\n      else if (r == 2) { /* {n} */\n        if (IS_SYNTAX_BV(syn, ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY))\n          goto possessive_check;\n\n        goto greedy_check;\n      }\n      /* r == 1 : normal char */\n      break;\n\n    case '|':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_VBAR_ALT)) break;\n      tok->type = TK_ALT;\n      break;\n\n    case '(':\n      if (!PEND && PPEEK_IS('?') &&\n          IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_QMARK_GROUP_EFFECT)) {\n        PINC;\n        if (!PEND && PPEEK_IS('#')) {\n          PFETCH(c);\n          while (1) {\n            if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n            PFETCH(c);\n            if (c == MC_ESC(syn)) {\n              if (!PEND) PFETCH(c);\n            }\n            else {\n              if (c == ')') break;\n            }\n          }\n          goto start;\n        }\n        PUNFETCH;\n      }\n\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_OPEN;\n      break;\n\n    case ')':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_CLOSE;\n      break;\n\n    case '^':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LINE_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = (IS_SINGLELINE(env->option)\n\t\t\t? ANCHOR_BEGIN_BUF : ANCHOR_BEGIN_LINE);\n      break;\n\n    case '$':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LINE_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = (IS_SINGLELINE(env->option)\n\t\t\t? ANCHOR_SEMI_END_BUF : ANCHOR_END_LINE);\n      break;\n\n    case '[':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_BRACKET_CC)) break;\n      tok->type = TK_CC_OPEN;\n      break;\n\n    case ']':\n      if (*src > env->pattern)   /* /].../ is allowed. */\n        CLOSE_BRACKET_WITHOUT_ESC_WARN(env, (UChar* )\"]\");\n      break;\n\n    case '#':\n      if (IS_EXTEND(env->option)) {\n        while (!PEND) {\n          PFETCH(c);\n          if (ONIGENC_IS_CODE_NEWLINE(enc, c))\n            break;\n        }\n        goto start;\n        break;\n      }\n      break;\n\n    case ' ': case '\\t': case '\\n': case '\\r': case '\\f':\n      if (IS_EXTEND(env->option))\n        goto start;\n      break;\n\n    default:\n      /* string */\n      break;\n    }\n  }\n\n#ifdef USE_VARIABLE_META_CHARS\n out:\n#endif\n  *src = p;\n  return tok->type;\n}\n\nstatic int\nadd_ctype_to_cc_by_range(CClassNode* cc, int ctype ARG_UNUSED, int not,\n\t\t\t OnigEncoding enc ARG_UNUSED,\n                         OnigCodePoint sb_out, const OnigCodePoint mbr[])\n{\n  int i, r;\n  OnigCodePoint j;\n\n  int n = ONIGENC_CODE_RANGE_NUM(mbr);\n\n  if (not == 0) {\n    for (i = 0; i < n; i++) {\n      for (j  = ONIGENC_CODE_RANGE_FROM(mbr, i);\n           j <= ONIGENC_CODE_RANGE_TO(mbr, i); j++) {\n        if (j >= sb_out) {\n          if (j > ONIGENC_CODE_RANGE_FROM(mbr, i)) {\n            r = add_code_range_to_buf(&(cc->mbuf), j,\n                                      ONIGENC_CODE_RANGE_TO(mbr, i));\n            if (r != 0) return r;\n            i++;\n          }\n\n          goto sb_end;\n        }\n        BITSET_SET_BIT(cc->bs, j);\n      }\n    }\n\n  sb_end:\n    for ( ; i < n; i++) {\n      r = add_code_range_to_buf(&(cc->mbuf),\n                                ONIGENC_CODE_RANGE_FROM(mbr, i),\n                                ONIGENC_CODE_RANGE_TO(mbr, i));\n      if (r != 0) return r;\n    }\n  }\n  else {\n    OnigCodePoint prev = 0;\n\n    for (i = 0; i < n; i++) {\n      for (j = prev;\n\t   j < ONIGENC_CODE_RANGE_FROM(mbr, i); j++) {\n        if (j >= sb_out) {\n          goto sb_end2;\n        }\n        BITSET_SET_BIT(cc->bs, j);\n      }\n      prev = ONIGENC_CODE_RANGE_TO(mbr, i) + 1;\n    }\n    for (j = prev; j < sb_out; j++) {\n      BITSET_SET_BIT(cc->bs, j);\n    }\n\n  sb_end2:\n    prev = sb_out;\n\n    for (i = 0; i < n; i++) {\n      if (prev < ONIGENC_CODE_RANGE_FROM(mbr, i)) {\n        r = add_code_range_to_buf(&(cc->mbuf), prev,\n                                  ONIGENC_CODE_RANGE_FROM(mbr, i) - 1);\n        if (r != 0) return r;\n      }\n      prev = ONIGENC_CODE_RANGE_TO(mbr, i) + 1;\n    }\n    if (prev < 0x7fffffff) {\n      r = add_code_range_to_buf(&(cc->mbuf), prev, 0x7fffffff);\n      if (r != 0) return r;\n    }\n  }\n\n  return 0;\n}\n\nstatic int\nadd_ctype_to_cc(CClassNode* cc, int ctype, int not, ScanEnv* env)\n{\n  int c, r;\n  const OnigCodePoint *ranges;\n  OnigCodePoint sb_out;\n  OnigEncoding enc = env->enc;\n\n  r = ONIGENC_GET_CTYPE_CODE_RANGE(enc, ctype, &sb_out, &ranges);\n  if (r == 0) {\n    return add_ctype_to_cc_by_range(cc, ctype, not, env->enc, sb_out, ranges);\n  }\n  else if (r != ONIG_NO_SUPPORT_CONFIG) {\n    return r;\n  }\n\n  r = 0;\n  switch (ctype) {\n  case ONIGENC_CTYPE_ALPHA:\n  case ONIGENC_CTYPE_BLANK:\n  case ONIGENC_CTYPE_CNTRL:\n  case ONIGENC_CTYPE_DIGIT:\n  case ONIGENC_CTYPE_LOWER:\n  case ONIGENC_CTYPE_PUNCT:\n  case ONIGENC_CTYPE_SPACE:\n  case ONIGENC_CTYPE_UPPER:\n  case ONIGENC_CTYPE_XDIGIT:\n  case ONIGENC_CTYPE_ASCII:\n  case ONIGENC_CTYPE_ALNUM:\n    if (not != 0) {\n      for (c = 0; c < SINGLE_BYTE_SIZE; c++) {\n        if (! ONIGENC_IS_CODE_CTYPE(enc, (OnigCodePoint )c, ctype))\n          BITSET_SET_BIT(cc->bs, c);\n      }\n      ADD_ALL_MULTI_BYTE_RANGE(enc, cc->mbuf);\n    }\n    else {\n      for (c = 0; c < SINGLE_BYTE_SIZE; c++) {\n        if (ONIGENC_IS_CODE_CTYPE(enc, (OnigCodePoint )c, ctype))\n          BITSET_SET_BIT(cc->bs, c);\n      }\n    }\n    break;\n\n  case ONIGENC_CTYPE_GRAPH:\n  case ONIGENC_CTYPE_PRINT:\n    if (not != 0) {\n      for (c = 0; c < SINGLE_BYTE_SIZE; c++) {\n        if (! ONIGENC_IS_CODE_CTYPE(enc, (OnigCodePoint )c, ctype))\n          BITSET_SET_BIT(cc->bs, c);\n      }\n    }\n    else {\n      for (c = 0; c < SINGLE_BYTE_SIZE; c++) {\n        if (ONIGENC_IS_CODE_CTYPE(enc, (OnigCodePoint )c, ctype))\n          BITSET_SET_BIT(cc->bs, c);\n      }\n      ADD_ALL_MULTI_BYTE_RANGE(enc, cc->mbuf);\n    }\n    break;\n\n  case ONIGENC_CTYPE_WORD:\n    if (not == 0) {\n      for (c = 0; c < SINGLE_BYTE_SIZE; c++) {\n        if (IS_CODE_SB_WORD(enc, c)) BITSET_SET_BIT(cc->bs, c);\n      }\n      ADD_ALL_MULTI_BYTE_RANGE(enc, cc->mbuf);\n    }\n    else {\n      for (c = 0; c < SINGLE_BYTE_SIZE; c++) {\n        if ((ONIGENC_CODE_TO_MBCLEN(enc, c) > 0) /* check invalid code point */\n            && ! ONIGENC_IS_CODE_WORD(enc, c))\n          BITSET_SET_BIT(cc->bs, c);\n      }\n    }\n    break;\n\n  default:\n    return ONIGERR_PARSER_BUG;\n    break;\n  }\n\n  return r;\n}\n\nstatic int\nparse_posix_bracket(CClassNode* cc, UChar** src, UChar* end, ScanEnv* env)\n{\n#define POSIX_BRACKET_CHECK_LIMIT_LENGTH  20\n#define POSIX_BRACKET_NAME_MIN_LEN         4\n\n  static PosixBracketEntryType PBS[] = {\n    { (UChar* )\"alnum\",  ONIGENC_CTYPE_ALNUM,  5 },\n    { (UChar* )\"alpha\",  ONIGENC_CTYPE_ALPHA,  5 },\n    { (UChar* )\"blank\",  ONIGENC_CTYPE_BLANK,  5 },\n    { (UChar* )\"cntrl\",  ONIGENC_CTYPE_CNTRL,  5 },\n    { (UChar* )\"digit\",  ONIGENC_CTYPE_DIGIT,  5 },\n    { (UChar* )\"graph\",  ONIGENC_CTYPE_GRAPH,  5 },\n    { (UChar* )\"lower\",  ONIGENC_CTYPE_LOWER,  5 },\n    { (UChar* )\"print\",  ONIGENC_CTYPE_PRINT,  5 },\n    { (UChar* )\"punct\",  ONIGENC_CTYPE_PUNCT,  5 },\n    { (UChar* )\"space\",  ONIGENC_CTYPE_SPACE,  5 },\n    { (UChar* )\"upper\",  ONIGENC_CTYPE_UPPER,  5 },\n    { (UChar* )\"xdigit\", ONIGENC_CTYPE_XDIGIT, 6 },\n    { (UChar* )\"ascii\",  ONIGENC_CTYPE_ASCII,  5 },\n    { (UChar* )\"word\",   ONIGENC_CTYPE_WORD,   4 },\n    { (UChar* )NULL,     -1, 0 }\n  };\n\n  PosixBracketEntryType *pb;\n  int not, i, r;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n  UChar *p = *src;\n\n  if (PPEEK_IS('^')) {\n    PINC_S;\n    not = 1;\n  }\n  else\n    not = 0;\n\n  if (onigenc_strlen(enc, p, end) < POSIX_BRACKET_NAME_MIN_LEN + 3)\n    goto not_posix_bracket;\n\n  for (pb = PBS; IS_NOT_NULL(pb->name); pb++) {\n    if (onigenc_with_ascii_strncmp(enc, p, end, pb->name, pb->len) == 0) {\n      p = (UChar* )onigenc_step(enc, p, end, pb->len);\n      if (onigenc_with_ascii_strncmp(enc, p, end, (UChar* )\":]\", 2) != 0)\n        return ONIGERR_INVALID_POSIX_BRACKET_TYPE;\n\n      r = add_ctype_to_cc(cc, pb->ctype, not, env);\n      if (r != 0) return r;\n\n      PINC_S; PINC_S;\n      *src = p;\n      return 0;\n    }\n  }\n\n not_posix_bracket:\n  c = 0;\n  i = 0;\n  while (!PEND && ((c = PPEEK) != ':') && c != ']') {\n    PINC_S;\n    if (++i > POSIX_BRACKET_CHECK_LIMIT_LENGTH) break;\n  }\n  if (c == ':' && ! PEND) {\n    PINC_S;\n    if (! PEND) {\n      PFETCH_S(c);\n      if (c == ']')\n        return ONIGERR_INVALID_POSIX_BRACKET_TYPE;\n    }\n  }\n\n  return 1;  /* 1: is not POSIX bracket, but no error. */\n}\n\nstatic int\nfetch_char_property_to_ctype(UChar** src, UChar* end, ScanEnv* env)\n{\n  int r;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n  UChar *prev, *start, *p = *src;\n\n  r = 0;\n  start = prev = p;\n\n  while (!PEND) {\n    prev = p;\n    PFETCH_S(c);\n    if (c == '}') {\n      r = ONIGENC_PROPERTY_NAME_TO_CTYPE(enc, start, prev);\n      if (r < 0) break;\n\n      *src = p;\n      return r;\n    }\n    else if (c == '(' || c == ')' || c == '{' || c == '|') {\n      r = ONIGERR_INVALID_CHAR_PROPERTY_NAME;\n      break;\n    }\n  }\n\n  onig_scan_env_set_error_string(env, r, *src, prev);\n  return r;\n}\n\nstatic int\nparse_char_property(Node** np, OnigToken* tok, UChar** src, UChar* end,\n\t\t    ScanEnv* env)\n{\n  int r, ctype;\n  CClassNode* cc;\n\n  ctype = fetch_char_property_to_ctype(src, end, env);\n  if (ctype < 0) return ctype;\n\n  *np = node_new_cclass();\n  CHECK_NULL_RETURN_MEMERR(*np);\n  cc = NCCLASS(*np);\n  r = add_ctype_to_cc(cc, ctype, 0, env);\n  if (r != 0) return r;\n  if (tok->u.prop.not != 0) NCCLASS_SET_NOT(cc);\n\n  return 0;\n}\n\n\nenum CCSTATE {\n  CCS_VALUE,\n  CCS_RANGE,\n  CCS_COMPLETE,\n  CCS_START\n};\n\nenum CCVALTYPE {\n  CCV_SB,\n  CCV_CODE_POINT,\n  CCV_CLASS\n};\n\nstatic int\nnext_state_class(CClassNode* cc, OnigCodePoint* vs, enum CCVALTYPE* type,\n\t\t enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n\n  if (*state == CCS_RANGE)\n    return ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE;\n\n  if (*state == CCS_VALUE && *type != CCV_CLASS) {\n    if (*type == CCV_SB)\n      BITSET_SET_BIT(cc->bs, (int )(*vs));\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *vs, *vs);\n      if (r < 0) return r;\n    }\n  }\n\n  *state = CCS_VALUE;\n  *type  = CCV_CLASS;\n  return 0;\n}\n\nstatic int\nnext_state_val(CClassNode* cc, OnigCodePoint *vs, OnigCodePoint v,\n\t       int* vs_israw, int v_israw,\n\t       enum CCVALTYPE intype, enum CCVALTYPE* type,\n\t       enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n\n  switch (*state) {\n  case CCS_VALUE:\n    if (*type == CCV_SB) {\n      if (*vs > 0xff)\n          return ONIGERR_INVALID_CODE_POINT_VALUE;\n\n      BITSET_SET_BIT(cc->bs, (int )(*vs));\n    }\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *vs, *vs);\n      if (r < 0) return r;\n    }\n    break;\n\n  case CCS_RANGE:\n    if (intype == *type) {\n      if (intype == CCV_SB) {\n        if (*vs > 0xff || v > 0xff)\n          return ONIGERR_INVALID_CODE_POINT_VALUE;\n\n        if (*vs > v) {\n          if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n            goto ccs_range_end;\n          else\n            return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n        }\n        bitset_set_range(cc->bs, (int )*vs, (int )v);\n      }\n      else {\n        r = add_code_range(&(cc->mbuf), env, *vs, v);\n        if (r < 0) return r;\n      }\n    }\n    else {\n#if 0\n      if (intype == CCV_CODE_POINT && *type == CCV_SB) {\n#endif\n        if (*vs > v) {\n          if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n            goto ccs_range_end;\n          else\n            return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n        }\n        bitset_set_range(cc->bs, (int )*vs, (int )(v < 0xff ? v : 0xff));\n        r = add_code_range(&(cc->mbuf), env, (OnigCodePoint )*vs, v);\n        if (r < 0) return r;\n#if 0\n      }\n      else\n        return ONIGERR_MISMATCH_CODE_LENGTH_IN_CLASS_RANGE;\n#endif\n    }\n  ccs_range_end:\n    *state = CCS_COMPLETE;\n    break;\n\n  case CCS_COMPLETE:\n  case CCS_START:\n    *state = CCS_VALUE;\n    break;\n\n  default:\n    break;\n  }\n\n  *vs_israw = v_israw;\n  *vs       = v;\n  *type     = intype;\n  return 0;\n}\n\nstatic int\ncode_exist_check(OnigCodePoint c, UChar* from, UChar* end, int ignore_escaped,\n\t\t ScanEnv* env)\n{\n  int in_esc;\n  OnigCodePoint code;\n  OnigEncoding enc = env->enc;\n  UChar* p = from;\n\n  in_esc = 0;\n  while (! PEND) {\n    if (ignore_escaped && in_esc) {\n      in_esc = 0;\n    }\n    else {\n      PFETCH_S(code);\n      if (code == c) return 1;\n      if (code == MC_ESC(env->syntax)) in_esc = 1;\n    }\n  }\n  return 0;\n}\n\nstatic int\nparse_char_class(Node** np, OnigToken* tok, UChar** src, UChar* end,\n\t\t ScanEnv* env)\n{\n  int r, neg, len, fetched, and_start;\n  OnigCodePoint v, vs;\n  UChar *p;\n  Node* node;\n  CClassNode *cc, *prev_cc;\n  CClassNode work_cc;\n\n  enum CCSTATE state;\n  enum CCVALTYPE val_type, in_type;\n  int val_israw, in_israw;\n\n  *np = NULL_NODE;\n  env->parse_depth++;\n  if (env->parse_depth > ParseDepthLimit)\n    return ONIGERR_PARSE_DEPTH_LIMIT_OVER;\n  prev_cc = (CClassNode* )NULL;\n  r = fetch_token_in_cc(tok, src, end, env);\n  if (r == TK_CHAR && tok->u.c == '^' && tok->escaped == 0) {\n    neg = 1;\n    r = fetch_token_in_cc(tok, src, end, env);\n  }\n  else {\n    neg = 0;\n  }\n\n  if (r < 0) return r;\n  if (r == TK_CC_CLOSE) {\n    if (! code_exist_check((OnigCodePoint )']',\n                           *src, env->pattern_end, 1, env))\n      return ONIGERR_EMPTY_CHAR_CLASS;\n\n    CC_ESC_WARN(env, (UChar* )\"]\");\n    r = tok->type = TK_CHAR;  /* allow []...] */\n  }\n\n  *np = node = node_new_cclass();\n  CHECK_NULL_RETURN_MEMERR(node);\n  cc = NCCLASS(node);\n\n  and_start = 0;\n  state = CCS_START;\n  p = *src;\n  while (r != TK_CC_CLOSE) {\n    fetched = 0;\n    switch (r) {\n    case TK_CHAR:\n    any_char_in:\n      len = ONIGENC_CODE_TO_MBCLEN(env->enc, tok->u.c);\n      if (len > 1) {\n        in_type = CCV_CODE_POINT;\n      }\n      else if (len < 0) {\n        r = len;\n        goto err;\n      }\n      else {\n        /* sb_char: */\n        in_type = CCV_SB;\n      }\n      v = (OnigCodePoint )tok->u.c;\n      in_israw = 0;\n      goto val_entry2;\n      break;\n\n    case TK_RAW_BYTE:\n      /* tok->base != 0 : octal or hexadec. */\n      if (! ONIGENC_IS_SINGLEBYTE(env->enc) && tok->base != 0) {\n        UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];\n        UChar* bufe = buf + ONIGENC_CODE_TO_MBC_MAXLEN;\n        UChar* psave = p;\n        int i, base = tok->base;\n\n        buf[0] = tok->u.c;\n        for (i = 1; i < ONIGENC_MBC_MAXLEN(env->enc); i++) {\n          r = fetch_token_in_cc(tok, &p, end, env);\n          if (r < 0) goto err;\n          if (r != TK_RAW_BYTE || tok->base != base) {\n            fetched = 1;\n            break;\n          }\n          buf[i] = tok->u.c;\n        }\n\n        if (i < ONIGENC_MBC_MINLEN(env->enc)) {\n          r = ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;\n          goto err;\n        }\n\n        len = enclen(env->enc, buf);\n        if (i < len) {\n          r = ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;\n          goto err;\n        }\n        else if (i > len) { /* fetch back */\n          p = psave;\n          for (i = 1; i < len; i++) {\n            r = fetch_token_in_cc(tok, &p, end, env);\n          }\n          fetched = 0;\n        }\n\n        if (i == 1) {\n          v = (OnigCodePoint )buf[0];\n          goto raw_single;\n        }\n        else {\n          v = ONIGENC_MBC_TO_CODE(env->enc, buf, bufe);\n          in_type = CCV_CODE_POINT;\n        }\n      }\n      else {\n        v = (OnigCodePoint )tok->u.c;\n      raw_single:\n        in_type = CCV_SB;\n      }\n      in_israw = 1;\n      goto val_entry2;\n      break;\n\n    case TK_CODE_POINT:\n      v = tok->u.code;\n      in_israw = 1;\n    val_entry:\n      len = ONIGENC_CODE_TO_MBCLEN(env->enc, v);\n      if (len < 0) {\n        r = len;\n        goto err;\n      }\n      in_type = (len == 1 ? CCV_SB : CCV_CODE_POINT);\n    val_entry2:\n      r = next_state_val(cc, &vs, v, &val_israw, in_israw, in_type, &val_type,\n\t\t\t &state, env);\n      if (r != 0) goto err;\n      break;\n\n    case TK_POSIX_BRACKET_OPEN:\n      r = parse_posix_bracket(cc, &p, end, env);\n      if (r < 0) goto err;\n      if (r == 1) {  /* is not POSIX bracket */\n        CC_ESC_WARN(env, (UChar* )\"[\");\n        p = tok->backp;\n        v = (OnigCodePoint )tok->u.c;\n        in_israw = 0;\n        goto val_entry;\n      }\n      goto next_class;\n      break;\n\n    case TK_CHAR_TYPE:\n      r = add_ctype_to_cc(cc, tok->u.prop.ctype, tok->u.prop.not, env);\n      if (r != 0) return r;\n\n    next_class:\n      r = next_state_class(cc, &vs, &val_type, &state, env);\n      if (r != 0) goto err;\n      break;\n\n    case TK_CHAR_PROPERTY:\n      {\n        int ctype;\n\n        ctype = fetch_char_property_to_ctype(&p, end, env);\n        if (ctype < 0) return ctype;\n        r = add_ctype_to_cc(cc, ctype, tok->u.prop.not, env);\n        if (r != 0) return r;\n        goto next_class;\n      }\n      break;\n\n    case TK_CC_RANGE:\n      if (state == CCS_VALUE) {\n        r = fetch_token_in_cc(tok, &p, end, env);\n        if (r < 0) goto err;\n        fetched = 1;\n        if (r == TK_CC_CLOSE) { /* allow [x-] */\n        range_end_val:\n          v = (OnigCodePoint )'-';\n          in_israw = 0;\n          goto val_entry;\n        }\n        else if (r == TK_CC_AND) {\n          CC_ESC_WARN(env, (UChar* )\"-\");\n          goto range_end_val;\n        }\n        state = CCS_RANGE;\n      }\n      else if (state == CCS_START) {\n        /* [-xa] is allowed */\n        v = (OnigCodePoint )tok->u.c;\n        in_israw = 0;\n\n        r = fetch_token_in_cc(tok, &p, end, env);\n        if (r < 0) goto err;\n        fetched = 1;\n        /* [--x] or [a&&-x] is warned. */\n        if (r == TK_CC_RANGE || and_start != 0)\n          CC_ESC_WARN(env, (UChar* )\"-\");\n\n        goto val_entry;\n      }\n      else if (state == CCS_RANGE) {\n        CC_ESC_WARN(env, (UChar* )\"-\");\n        goto any_char_in;  /* [!--x] is allowed */\n      }\n      else { /* CCS_COMPLETE */\n        r = fetch_token_in_cc(tok, &p, end, env);\n        if (r < 0) goto err;\n        fetched = 1;\n        if (r == TK_CC_CLOSE) goto range_end_val; /* allow [a-b-] */\n        else if (r == TK_CC_AND) {\n          CC_ESC_WARN(env, (UChar* )\"-\");\n          goto range_end_val;\n        }\n\t\n        if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_DOUBLE_RANGE_OP_IN_CC)) {\n          CC_ESC_WARN(env, (UChar* )\"-\");\n          goto range_end_val;   /* [0-9-a] is allowed as [0-9\\-a] */\n        }\n        r = ONIGERR_UNMATCHED_RANGE_SPECIFIER_IN_CHAR_CLASS;\n        goto err;\n      }\n      break;\n\n    case TK_CC_CC_OPEN: /* [ */\n      {\n        Node *anode;\n        CClassNode* acc;\n\n        r = parse_char_class(&anode, tok, &p, end, env);\n        if (r != 0) {\n          onig_node_free(anode);\n          goto cc_open_err;\n        }\n        acc = NCCLASS(anode);\n        r = or_cclass(cc, acc, env->enc);\n\n        onig_node_free(anode);\n      cc_open_err:\n        if (r != 0) goto err;\n      }\n      break;\n\n    case TK_CC_AND: /* && */\n      {\n        if (state == CCS_VALUE) {\n          r = next_state_val(cc, &vs, 0, &val_israw, 0, val_type,\n                             &val_type, &state, env);\n          if (r != 0) goto err;\n        }\n        /* initialize local variables */\n        and_start = 1;\n        state = CCS_START;\n\n        if (IS_NOT_NULL(prev_cc)) {\n          r = and_cclass(prev_cc, cc, env->enc);\n          if (r != 0) goto err;\n          bbuf_free(cc->mbuf);\n        }\n        else {\n          prev_cc = cc;\n          cc = &work_cc;\n        }\n        initialize_cclass(cc);\n      }\n      break;\n\n    case TK_EOT:\n      r = ONIGERR_PREMATURE_END_OF_CHAR_CLASS;\n      goto err;\n      break;\n    default:\n      r = ONIGERR_PARSER_BUG;\n      goto err;\n      break;\n    }\n\n    if (fetched)\n      r = tok->type;\n    else {\n      r = fetch_token_in_cc(tok, &p, end, env);\n      if (r < 0) goto err;\n    }\n  }\n\n  if (state == CCS_VALUE) {\n    r = next_state_val(cc, &vs, 0, &val_israw, 0, val_type,\n\t\t       &val_type, &state, env);\n    if (r != 0) goto err;\n  }\n\n  if (IS_NOT_NULL(prev_cc)) {\n    r = and_cclass(prev_cc, cc, env->enc);\n    if (r != 0) goto err;\n    bbuf_free(cc->mbuf);\n    cc = prev_cc;\n  }\n\n  if (neg != 0)\n    NCCLASS_SET_NOT(cc);\n  else\n    NCCLASS_CLEAR_NOT(cc);\n  if (IS_NCCLASS_NOT(cc) &&\n      IS_SYNTAX_BV(env->syntax, ONIG_SYN_NOT_NEWLINE_IN_NEGATIVE_CC)) {\n    int is_empty;\n\n    is_empty = (IS_NULL(cc->mbuf) ? 1 : 0);\n    if (is_empty != 0)\n      BITSET_IS_EMPTY(cc->bs, is_empty);\n\n    if (is_empty == 0) {\n#define NEWLINE_CODE    0x0a\n\n      if (ONIGENC_IS_CODE_NEWLINE(env->enc, NEWLINE_CODE)) {\n        if (ONIGENC_CODE_TO_MBCLEN(env->enc, NEWLINE_CODE) == 1)\n          BITSET_SET_BIT(cc->bs, NEWLINE_CODE);\n        else\n          add_code_range(&(cc->mbuf), env, NEWLINE_CODE, NEWLINE_CODE);\n      }\n    }\n  }\n  *src = p;\n  env->parse_depth--;\n  return 0;\n\n err:\n  if (cc != NCCLASS(*np))\n    bbuf_free(cc->mbuf);\n  return r;\n}\n\nstatic int parse_subexp(Node** top, OnigToken* tok, int term,\n\t\t\tUChar** src, UChar* end, ScanEnv* env);\n\nstatic int\nparse_enclose(Node** np, OnigToken* tok, int term, UChar** src, UChar* end,\n\t      ScanEnv* env)\n{\n  int r, num;\n  Node *target;\n  OnigOptionType option;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n\n#ifdef USE_NAMED_GROUP\n  int list_capture;\n#endif\n\n  UChar* p = *src;\n  PFETCH_READY;\n\n  *np = NULL;\n  if (PEND) return ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS;\n\n  option = env->option;\n  if (PPEEK_IS('?') &&\n      IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_GROUP_EFFECT)) {\n    PINC;\n    if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n\n    PFETCH(c);\n    switch (c) {\n    case ':':   /* (?:...) grouping only */\n    group:\n      r = fetch_token(tok, &p, end, env);\n      if (r < 0) return r;\n      r = parse_subexp(np, tok, term, &p, end, env);\n      if (r < 0) return r;\n      *src = p;\n      return 1; /* group */\n      break;\n\n    case '=':\n      *np = onig_node_new_anchor(ANCHOR_PREC_READ);\n      break;\n    case '!':  /*         preceding read */\n      *np = onig_node_new_anchor(ANCHOR_PREC_READ_NOT);\n      break;\n    case '>':            /* (?>...) stop backtrack */\n      *np = node_new_enclose(ENCLOSE_STOP_BACKTRACK);\n      break;\n\n#ifdef USE_NAMED_GROUP\n    case '\\'':\n      if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP)) {\n        goto named_group1;\n      }\n      else\n        return ONIGERR_UNDEFINED_GROUP_OPTION;\n      break;\n#endif\n\n    case '<':   /* look behind (?<=...), (?<!...) */\n      if (PEND) return ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS;\n      PFETCH(c);\n      if (c == '=')\n        *np = onig_node_new_anchor(ANCHOR_LOOK_BEHIND);\n      else if (c == '!')\n        *np = onig_node_new_anchor(ANCHOR_LOOK_BEHIND_NOT);\n#ifdef USE_NAMED_GROUP\n      else {\n        if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP)) {\n          UChar *name;\n          UChar *name_end;\n\n          PUNFETCH;\n          c = '<';\n\n        named_group1:\n          list_capture = 0;\n\n        named_group2:\n          name = p;\n          r = fetch_name((OnigCodePoint )c, &p, end, &name_end, env, &num, 0);\n          if (r < 0) return r;\n\n          num = scan_env_add_mem_entry(env);\n          if (num < 0) return num;\n          if (list_capture != 0 && num >= (int )BIT_STATUS_BITS_NUM)\n            return ONIGERR_GROUP_NUMBER_OVER_FOR_CAPTURE_HISTORY;\n\n          r = name_add(env->reg, name, name_end, num, env);\n          if (r != 0) return r;\n          *np = node_new_enclose_memory(env->option, 1);\n          CHECK_NULL_RETURN_MEMERR(*np);\n          NENCLOSE(*np)->regnum = num;\n          if (list_capture != 0)\n            BIT_STATUS_ON_AT_SIMPLE(env->capture_history, num);\n          env->num_named++;\n        }\n        else {\n          return ONIGERR_UNDEFINED_GROUP_OPTION;\n        }\n      }\n#else\n      else {\n        return ONIGERR_UNDEFINED_GROUP_OPTION;\n      }\n#endif\n      break;\n\n    case '@':\n      if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ATMARK_CAPTURE_HISTORY)) {\n#ifdef USE_NAMED_GROUP\n        if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP)) {\n          PFETCH(c);\n          if (c == '<' || c == '\\'') {\n            list_capture = 1;\n            goto named_group2; /* (?@<name>...) */\n          }\n          PUNFETCH;\n        }\n#endif\n        *np = node_new_enclose_memory(env->option, 0);\n        CHECK_NULL_RETURN_MEMERR(*np);\n        num = scan_env_add_mem_entry(env);\n        if (num < 0) {\n          return num;\n        }\n        else if (num >= (int )BIT_STATUS_BITS_NUM) {\n          return ONIGERR_GROUP_NUMBER_OVER_FOR_CAPTURE_HISTORY;\n        }\n        NENCLOSE(*np)->regnum = num;\n        BIT_STATUS_ON_AT_SIMPLE(env->capture_history, num);\n      }\n      else {\n        return ONIGERR_UNDEFINED_GROUP_OPTION;\n      }\n      break;\n\n#ifdef USE_POSIXLINE_OPTION\n    case 'p':\n#endif\n    case '-': case 'i': case 'm': case 's': case 'x':\n      {\n        int neg = 0;\n\n        while (1) {\n          switch (c) {\n          case ':':\n          case ')':\n            break;\n\n          case '-':  neg = 1; break;\n          case 'x':  ONOFF(option, ONIG_OPTION_EXTEND,     neg); break;\n          case 'i':  ONOFF(option, ONIG_OPTION_IGNORECASE, neg); break;\n          case 's':\n            if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_PERL)) {\n              ONOFF(option, ONIG_OPTION_MULTILINE,  neg);\n            }\n            else\n              return ONIGERR_UNDEFINED_GROUP_OPTION;\n            break;\n\n          case 'm':\n            if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_PERL)) {\n              ONOFF(option, ONIG_OPTION_SINGLELINE, (neg == 0 ? 1 : 0));\n            }\n            else if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_RUBY)) {\n              ONOFF(option, ONIG_OPTION_MULTILINE,  neg);\n            }\n            else\n              return ONIGERR_UNDEFINED_GROUP_OPTION;\n            break;\n#ifdef USE_POSIXLINE_OPTION\n          case 'p':\n            ONOFF(option, ONIG_OPTION_MULTILINE|ONIG_OPTION_SINGLELINE, neg);\n            break;\n#endif\n          default:\n            return ONIGERR_UNDEFINED_GROUP_OPTION;\n          }\n\n          if (c == ')') {\n            *np = node_new_option(option);\n            CHECK_NULL_RETURN_MEMERR(*np);\n            *src = p;\n            return 2; /* option only */\n          }\n          else if (c == ':') {\n            OnigOptionType prev = env->option;\n\n            env->option     = option;\n            r = fetch_token(tok, &p, end, env);\n            if (r < 0) return r;\n            r = parse_subexp(&target, tok, term, &p, end, env);\n            env->option = prev;\n            if (r < 0) {\n              onig_node_free(target);\n              return r;\n            }\n            *np = node_new_option(option);\n            CHECK_NULL_RETURN_MEMERR(*np);\n            NENCLOSE(*np)->target = target;\n            *src = p;\n            return 0;\n          }\n\n          if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n          PFETCH(c);\n        }\n      }\n      break;\n\n    default:\n      return ONIGERR_UNDEFINED_GROUP_OPTION;\n    }\n  }\n  else {\n    if (ONIG_IS_OPTION_ON(env->option, ONIG_OPTION_DONT_CAPTURE_GROUP))\n      goto group;\n\n    *np = node_new_enclose_memory(env->option, 0);\n    CHECK_NULL_RETURN_MEMERR(*np);\n    num = scan_env_add_mem_entry(env);\n    if (num < 0) return num;\n    NENCLOSE(*np)->regnum = num;\n  }\n\n  CHECK_NULL_RETURN_MEMERR(*np);\n  r = fetch_token(tok, &p, end, env);\n  if (r < 0) return r;\n  r = parse_subexp(&target, tok, term, &p, end, env);\n  if (r < 0) {\n    onig_node_free(target);\n    return r;\n  }\n\n  if (NTYPE(*np) == NT_ANCHOR)\n    NANCHOR(*np)->target = target;\n  else {\n    NENCLOSE(*np)->target = target;\n    if (NENCLOSE(*np)->type == ENCLOSE_MEMORY) {\n      /* Don't move this to previous of parse_subexp() */\n      r = scan_env_set_mem_node(env, NENCLOSE(*np)->regnum, *np);\n      if (r != 0) return r;\n    }\n  }\n\n  *src = p;\n  return 0;\n}\n\nstatic const char* PopularQStr[] = {\n  \"?\", \"*\", \"+\", \"??\", \"*?\", \"+?\"\n};\n\nstatic const char* ReduceQStr[] = {\n  \"\", \"\", \"*\", \"*?\", \"??\", \"+ and ??\", \"+? and ?\"\n};\n\nstatic int\nset_quantifier(Node* qnode, Node* target, int group, ScanEnv* env)\n{\n  QtfrNode* qn;\n\n  qn = NQTFR(qnode);\n  if (qn->lower == 1 && qn->upper == 1) {\n    return 1;\n  }\n\n  switch (NTYPE(target)) {\n  case NT_STR:\n    if (! group) {\n      StrNode* sn = NSTR(target);\n      if (str_node_can_be_split(sn, env->enc)) {\n        Node* n = str_node_split_last_char(sn, env->enc);\n        if (IS_NOT_NULL(n)) {\n          qn->target = n;\n          return 2;\n        }\n      }\n    }\n    break;\n\n  case NT_QTFR:\n    { /* check redundant double repeat. */\n      /* verbose warn (?:.?)? etc... but not warn (.?)? etc... */\n      QtfrNode* qnt   = NQTFR(target);\n      int nestq_num   = popular_quantifier_num(qn);\n      int targetq_num = popular_quantifier_num(qnt);\n\n#ifdef USE_WARNING_REDUNDANT_NESTED_REPEAT_OPERATOR\n      if (!IS_QUANTIFIER_BY_NUMBER(qn) && !IS_QUANTIFIER_BY_NUMBER(qnt) &&\n          IS_SYNTAX_BV(env->syntax, ONIG_SYN_WARN_REDUNDANT_NESTED_REPEAT)) {\n        UChar buf[WARN_BUFSIZE];\n\n        switch(ReduceTypeTable[targetq_num][nestq_num]) {\n        case RQ_ASIS:\n          break;\n\n        case RQ_DEL:\n          if (onig_verb_warn != onig_null_warn) {\n            onig_snprintf_with_pattern(buf, WARN_BUFSIZE, env->enc,\n                                  env->pattern, env->pattern_end,\n                                  (UChar* )\"redundant nested repeat operator\");\n            (*onig_verb_warn)((char* )buf);\n          }\n          goto warn_exit;\n          break;\n\n        default:\n          if (onig_verb_warn != onig_null_warn) {\n            onig_snprintf_with_pattern(buf, WARN_BUFSIZE, env->enc,\n                                       env->pattern, env->pattern_end,\n            (UChar* )\"nested repeat operator %s and %s was replaced with '%s'\",\n            PopularQStr[targetq_num], PopularQStr[nestq_num],\n            ReduceQStr[ReduceTypeTable[targetq_num][nestq_num]]);\n            (*onig_verb_warn)((char* )buf);\n          }\n          goto warn_exit;\n          break;\n        }\n      }\n\n    warn_exit:\n#endif\n      if (targetq_num >= 0) {\n        if (nestq_num >= 0) {\n          onig_reduce_nested_quantifier(qnode, target);\n          goto q_exit;\n        }\n        else if (targetq_num == 1 || targetq_num == 2) { /* * or + */\n          /* (?:a*){n,m}, (?:a+){n,m} => (?:a*){n,n}, (?:a+){n,n} */\n          if (! IS_REPEAT_INFINITE(qn->upper) && qn->upper > 1 && qn->greedy) {\n            qn->upper = (qn->lower == 0 ? 1 : qn->lower);\n          }\n        }\n      }\n    }\n    break;\n\n  default:\n    break;\n  }\n\n  qn->target = target;\n q_exit:\n  return 0;\n}\n\n\n#ifndef CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS\nstatic int\nclear_not_flag_cclass(CClassNode* cc, OnigEncoding enc)\n{\n  BBuf *tbuf;\n  int r;\n\n  if (IS_NCCLASS_NOT(cc)) {\n    bitset_invert(cc->bs);\n\n    if (! ONIGENC_IS_SINGLEBYTE(enc)) {\n      r = not_code_range_buf(enc, cc->mbuf, &tbuf);\n      if (r != 0) return r;\n\n      bbuf_free(cc->mbuf);\n      cc->mbuf = tbuf;\n    }\n\n    NCCLASS_CLEAR_NOT(cc);\n  }\n\n  return 0;\n}\n#endif /* CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS */\n\ntypedef struct {\n  ScanEnv*    env;\n  CClassNode* cc;\n  Node*       alt_root;\n  Node**      ptail;\n} IApplyCaseFoldArg;\n\nstatic int\ni_apply_case_fold(OnigCodePoint from, OnigCodePoint to[],\n\t\t  int to_len, void* arg)\n{\n  IApplyCaseFoldArg* iarg;\n  ScanEnv* env;\n  CClassNode* cc;\n  BitSetRef bs;\n\n  iarg = (IApplyCaseFoldArg* )arg;\n  env = iarg->env;\n  cc  = iarg->cc;\n  bs = cc->bs;\n\n  if (to_len == 1) {\n    int is_in = onig_is_code_in_cc(env->enc, from, cc);\n#ifdef CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS\n    if ((is_in != 0 && !IS_NCCLASS_NOT(cc)) ||\n        (is_in == 0 &&  IS_NCCLASS_NOT(cc))) {\n      if (ONIGENC_MBC_MINLEN(env->enc) > 1 || *to >= SINGLE_BYTE_SIZE) {\n        add_code_range(&(cc->mbuf), env, *to, *to);\n      }\n      else {\n        BITSET_SET_BIT(bs, *to);\n      }\n    }\n#else\n    if (is_in != 0) {\n      if (ONIGENC_MBC_MINLEN(env->enc) > 1 || *to >= SINGLE_BYTE_SIZE) {\n        if (IS_NCCLASS_NOT(cc)) clear_not_flag_cclass(cc, env->enc);\n        add_code_range(&(cc->mbuf), env, *to, *to);\n      }\n      else {\n        if (IS_NCCLASS_NOT(cc)) {\n          BITSET_CLEAR_BIT(bs, *to);\n        }\n        else\n          BITSET_SET_BIT(bs, *to);\n      }\n    }\n#endif /* CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS */\n  }\n  else {\n    int r, i, len;\n    UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];\n    Node *snode = NULL_NODE;\n\n    if (onig_is_code_in_cc(env->enc, from, cc)\n#ifdef CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS\n\t&& !IS_NCCLASS_NOT(cc)\n#endif\n        ) {\n      for (i = 0; i < to_len; i++) {\n        len = ONIGENC_CODE_TO_MBC(env->enc, to[i], buf);\n        if (i == 0) {\n          snode = onig_node_new_str(buf, buf + len);\n          CHECK_NULL_RETURN_MEMERR(snode);\n\n          /* char-class expanded multi-char only\n             compare with string folded at match time. */\n          NSTRING_SET_AMBIG(snode);\n        }\n        else {\n          r = onig_node_str_cat(snode, buf, buf + len);\n          if (r < 0) {\n            onig_node_free(snode);\n            return r;\n          }\n        }\n      }\n\n      *(iarg->ptail) = onig_node_new_alt(snode, NULL_NODE);\n      CHECK_NULL_RETURN_MEMERR(*(iarg->ptail));\n      iarg->ptail = &(NCDR((*(iarg->ptail))));\n    }\n  }\n\n  return 0;\n}\n\nstatic int\nparse_exp(Node** np, OnigToken* tok, int term,\n\t  UChar** src, UChar* end, ScanEnv* env)\n{\n  int r, len, group = 0;\n  Node* qn;\n  Node** targetp;\n\n  *np = NULL;\n  if (tok->type == (enum TokenSyms )term)\n    goto end_of_token;\n\n  switch (tok->type) {\n  case TK_ALT:\n  case TK_EOT:\n  end_of_token:\n  *np = node_new_empty();\n  return tok->type;\n  break;\n\n  case TK_SUBEXP_OPEN:\n    r = parse_enclose(np, tok, TK_SUBEXP_CLOSE, src, end, env);\n    if (r < 0) return r;\n    if (r == 1) group = 1;\n    else if (r == 2) { /* option only */\n      Node* target;\n      OnigOptionType prev = env->option;\n\n      env->option = NENCLOSE(*np)->option;\n      r = fetch_token(tok, src, end, env);\n      if (r < 0) return r;\n      r = parse_subexp(&target, tok, term, src, end, env);\n      env->option = prev;\n      if (r < 0) {\n        onig_node_free(target);\n        return r;\n      }\n      NENCLOSE(*np)->target = target;\t\n      return tok->type;\n    }\n    break;\n\n  case TK_SUBEXP_CLOSE:\n    if (! IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_UNMATCHED_CLOSE_SUBEXP))\n      return ONIGERR_UNMATCHED_CLOSE_PARENTHESIS;\n\n    if (tok->escaped) goto tk_raw_byte;\n    else goto tk_byte;\n    break;\n\n  case TK_STRING:\n  tk_byte:\n    {\n      *np = node_new_str(tok->backp, *src);\n      CHECK_NULL_RETURN_MEMERR(*np);\n\n      while (1) {\n        r = fetch_token(tok, src, end, env);\n        if (r < 0) return r;\n        if (r != TK_STRING) break;\n\n        r = onig_node_str_cat(*np, tok->backp, *src);\n        if (r < 0) return r;\n      }\n\n    string_end:\n      targetp = np;\n      goto repeat;\n    }\n    break;\n\n  case TK_RAW_BYTE:\n  tk_raw_byte:\n    {\n      *np = node_new_str_raw_char((UChar )tok->u.c);\n      CHECK_NULL_RETURN_MEMERR(*np);\n      len = 1;\n      while (1) {\n        if (len >= ONIGENC_MBC_MINLEN(env->enc)) {\n          if (len == enclen(env->enc, NSTR(*np)->s)) {//should not enclen_end()\n            r = fetch_token(tok, src, end, env);\n            NSTRING_CLEAR_RAW(*np);\n            goto string_end;\n          }\n        }\n\n        r = fetch_token(tok, src, end, env);\n        if (r < 0) return r;\n        if (r != TK_RAW_BYTE) {\n          /* Don't use this, it is wrong for little endian encodings. */\n#ifdef USE_PAD_TO_SHORT_BYTE_CHAR\n          int rem;\n          if (len < ONIGENC_MBC_MINLEN(env->enc)) {\n            rem = ONIGENC_MBC_MINLEN(env->enc) - len;\n            (void )node_str_head_pad(NSTR(*np), rem, (UChar )0);\n            if (len + rem == enclen(env->enc, NSTR(*np)->s)) {\n              NSTRING_CLEAR_RAW(*np);\n              goto string_end;\n            }\n          }\n#endif\n          return ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;\n        }\n\n        r = node_str_cat_char(*np, (UChar )tok->u.c);\n        if (r < 0) return r;\n\n        len++;\n      }\n    }\n    break;\n\n  case TK_CODE_POINT:\n    {\n      UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];\n      int num = ONIGENC_CODE_TO_MBC(env->enc, tok->u.code, buf);\n      if (num < 0) return num;\n#ifdef NUMBERED_CHAR_IS_NOT_CASE_AMBIG\n      *np = node_new_str_raw(buf, buf + num);\n#else\n      *np = node_new_str(buf, buf + num);\n#endif\n      CHECK_NULL_RETURN_MEMERR(*np);\n    }\n    break;\n\n  case TK_QUOTE_OPEN:\n    {\n      OnigCodePoint end_op[2];\n      UChar *qstart, *qend, *nextp;\n\n      end_op[0] = (OnigCodePoint )MC_ESC(env->syntax);\n      end_op[1] = (OnigCodePoint )'E';\n      qstart = *src;\n      qend = find_str_position(end_op, 2, qstart, end, &nextp, env->enc);\n      if (IS_NULL(qend)) {\n        nextp = qend = end;\n      }\n      *np = node_new_str(qstart, qend);\n      CHECK_NULL_RETURN_MEMERR(*np);\n      *src = nextp;\n    }\n    break;\n\n  case TK_CHAR_TYPE:\n    {\n      switch (tok->u.prop.ctype) {\n      case ONIGENC_CTYPE_WORD:\n        *np = node_new_ctype(tok->u.prop.ctype, tok->u.prop.not);\n        CHECK_NULL_RETURN_MEMERR(*np);\n        break;\n\n      case ONIGENC_CTYPE_SPACE:\n      case ONIGENC_CTYPE_DIGIT:\n      case ONIGENC_CTYPE_XDIGIT:\n        {\n          CClassNode* cc;\n\n          *np = node_new_cclass();\n          CHECK_NULL_RETURN_MEMERR(*np);\n          cc = NCCLASS(*np);\n          add_ctype_to_cc(cc, tok->u.prop.ctype, 0, env);\n          if (tok->u.prop.not != 0) NCCLASS_SET_NOT(cc);\n        }\n        break;\n\n      default:\n        return ONIGERR_PARSER_BUG;\n        break;\n      }\n    }\n    break;\n\n  case TK_CHAR_PROPERTY:\n    r = parse_char_property(np, tok, src, end, env);\n    if (r != 0) return r;\n    break;\n\n  case TK_CC_OPEN:\n    {\n      CClassNode* cc;\n\n      r = parse_char_class(np, tok, src, end, env);\n      if (r != 0) return r;\n\n      cc = NCCLASS(*np);\n      if (IS_IGNORECASE(env->option)) {\n        IApplyCaseFoldArg iarg;\n\n        iarg.env      = env;\n        iarg.cc       = cc;\n        iarg.alt_root = NULL_NODE;\n        iarg.ptail    = &(iarg.alt_root);\n\n        r = ONIGENC_APPLY_ALL_CASE_FOLD(env->enc, env->case_fold_flag,\n                                        i_apply_case_fold, &iarg);\n        if (r != 0) {\n          onig_node_free(iarg.alt_root);\n          return r;\n        }\n        if (IS_NOT_NULL(iarg.alt_root)) {\n          Node* work = onig_node_new_alt(*np, iarg.alt_root);\n          if (IS_NULL(work)) {\n            onig_node_free(iarg.alt_root);\n            return ONIGERR_MEMORY;\n          }\n          *np = work;\n        }\n      }\n    }\n    break;\n\n  case TK_ANYCHAR:\n    *np = node_new_anychar();\n    CHECK_NULL_RETURN_MEMERR(*np);\n    break;\n\n  case TK_ANYCHAR_ANYTIME:\n    *np = node_new_anychar();\n    CHECK_NULL_RETURN_MEMERR(*np);\n    qn = node_new_quantifier(0, REPEAT_INFINITE, 0);\n    CHECK_NULL_RETURN_MEMERR(qn);\n    NQTFR(qn)->target = *np;\n    *np = qn;\n    break;\n\n  case TK_BACKREF:\n    len = tok->u.backref.num;\n    *np = node_new_backref(len,\n                  (len > 1 ? tok->u.backref.refs : &(tok->u.backref.ref1)),\n                  tok->u.backref.by_name,\n#ifdef USE_BACKREF_WITH_LEVEL\n\t\t\t   tok->u.backref.exist_level,\n\t\t\t   tok->u.backref.level,\n#endif\n\t\t\t   env);\n    CHECK_NULL_RETURN_MEMERR(*np);\n    break;\n\n#ifdef USE_SUBEXP_CALL\n  case TK_CALL:\n    {\n      int gnum = tok->u.call.gnum;\n\n      if (gnum < 0) {\n        gnum = BACKREF_REL_TO_ABS(gnum, env);\n        if (gnum <= 0)\n          return ONIGERR_INVALID_BACKREF;\n      }\n      *np = node_new_call(tok->u.call.name, tok->u.call.name_end, gnum);\n      CHECK_NULL_RETURN_MEMERR(*np);\n      env->num_call++;\n    }\n    break;\n#endif\n\n  case TK_ANCHOR:\n    *np = onig_node_new_anchor(tok->u.anchor);\n    break;\n\n  case TK_OP_REPEAT:\n  case TK_INTERVAL:\n    if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_CONTEXT_INDEP_REPEAT_OPS)) {\n      if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_CONTEXT_INVALID_REPEAT_OPS))\n        return ONIGERR_TARGET_OF_REPEAT_OPERATOR_NOT_SPECIFIED;\n      else\n        *np = node_new_empty();\n    }\n    else {\n      goto tk_byte;\n    }\n    break;\n\n  default:\n    return ONIGERR_PARSER_BUG;\n    break;\n  }\n\n  {\n    targetp = np;\n\n  re_entry:\n    r = fetch_token(tok, src, end, env);\n    if (r < 0) return r;\n\n  repeat:\n    if (r == TK_OP_REPEAT || r == TK_INTERVAL) {\n      if (is_invalid_quantifier_target(*targetp))\n        return ONIGERR_TARGET_OF_REPEAT_OPERATOR_INVALID;\n\n      qn = node_new_quantifier(tok->u.repeat.lower, tok->u.repeat.upper,\n                               (r == TK_INTERVAL ? 1 : 0));\n      CHECK_NULL_RETURN_MEMERR(qn);\n      NQTFR(qn)->greedy = tok->u.repeat.greedy;\n      r = set_quantifier(qn, *targetp, group, env);\n      if (r < 0) {\n        onig_node_free(qn);\n        return r;\n      }\n\n      if (tok->u.repeat.possessive != 0) {\n        Node* en;\n        en = node_new_enclose(ENCLOSE_STOP_BACKTRACK);\n        if (IS_NULL(en)) {\n          onig_node_free(qn);\n          return ONIGERR_MEMORY;\n        }\n        NENCLOSE(en)->target = qn;\n        qn = en;\n      }\n\n      if (r == 0) {\n        *targetp = qn;\n      }\n      else if (r == 1) {\n        onig_node_free(qn);\n      }\n      else if (r == 2) { /* split case: /abc+/ */\n        Node *tmp;\n\n        *targetp = node_new_list(*targetp, NULL);\n        if (IS_NULL(*targetp)) {\n          onig_node_free(qn);\n          return ONIGERR_MEMORY;\n        }\n        tmp = NCDR(*targetp) = node_new_list(qn, NULL);\n        if (IS_NULL(tmp)) {\n          onig_node_free(qn);\n          return ONIGERR_MEMORY;\n        }\n        targetp = &(NCAR(tmp));\n      }\n      goto re_entry;\n    }\n  }\n\n  return r;\n}\n\nstatic int\nparse_branch(Node** top, OnigToken* tok, int term,\n\t     UChar** src, UChar* end, ScanEnv* env)\n{\n  int r;\n  Node *node, **headp;\n\n  *top = NULL;\n  r = parse_exp(&node, tok, term, src, end, env);\n  if (r < 0) {\n    onig_node_free(node);\n    return r;\n  }\n\n  if (r == TK_EOT || r == term || r == TK_ALT) {\n    *top = node;\n  }\n  else {\n    *top  = node_new_list(node, NULL);\n    headp = &(NCDR(*top));\n    while (r != TK_EOT && r != term && r != TK_ALT) {\n      r = parse_exp(&node, tok, term, src, end, env);\n      if (r < 0) {\n        onig_node_free(node);\n        return r;\n      }\n\n      if (NTYPE(node) == NT_LIST) {\n        *headp = node;\n        while (IS_NOT_NULL(NCDR(node))) node = NCDR(node);\n        headp = &(NCDR(node));\n      }\n      else {\n        *headp = node_new_list(node, NULL);\n        headp = &(NCDR(*headp));\n      }\n    }\n  }\n\n  return r;\n}\n\n/* term_tok: TK_EOT or TK_SUBEXP_CLOSE */\nstatic int\nparse_subexp(Node** top, OnigToken* tok, int term,\n\t     UChar** src, UChar* end, ScanEnv* env)\n{\n  int r;\n  Node *node, **headp;\n\n  *top = NULL;\n  env->parse_depth++;\n  if (env->parse_depth > ParseDepthLimit)\n    return ONIGERR_PARSE_DEPTH_LIMIT_OVER;\n  r = parse_branch(&node, tok, term, src, end, env);\n  if (r < 0) {\n    onig_node_free(node);\n    return r;\n  }\n\n  if (r == term) {\n    *top = node;\n  }\n  else if (r == TK_ALT) {\n    *top  = onig_node_new_alt(node, NULL);\n    headp = &(NCDR(*top));\n    while (r == TK_ALT) {\n      r = fetch_token(tok, src, end, env);\n      if (r < 0) return r;\n      r = parse_branch(&node, tok, term, src, end, env);\n      if (r < 0) {\n        onig_node_free(node);\n        return r;\n      }\n      *headp = onig_node_new_alt(node, NULL);\n      headp = &(NCDR(*headp));\n    }\n\n    if (tok->type != (enum TokenSyms )term)\n      goto err;\n  }\n  else {\n    onig_node_free(node);\n  err:\n    if (term == TK_SUBEXP_CLOSE)\n      return ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS;\n    else\n      return ONIGERR_PARSER_BUG;\n  }\n\n  env->parse_depth--;\n  return r;\n}\n\nstatic int\nparse_regexp(Node** top, UChar** src, UChar* end, ScanEnv* env)\n{\n  int r;\n  OnigToken tok;\n\n  r = fetch_token(&tok, src, end, env);\n  if (r < 0) return r;\n  r = parse_subexp(top, &tok, TK_EOT, src, end, env);\n  if (r < 0) return r;\n  return 0;\n}\n\nextern int\nonig_parse_make_tree(Node** root, const UChar* pattern, const UChar* end,\n\t\t     regex_t* reg, ScanEnv* env)\n{\n  int r;\n  UChar* p;\n\n#ifdef USE_NAMED_GROUP\n  names_clear(reg);\n#endif\n\n  scan_env_clear(env);\n  env->option         = reg->options;\n  env->case_fold_flag = reg->case_fold_flag;\n  env->enc            = reg->enc;\n  env->syntax         = reg->syntax;\n  env->pattern        = (UChar* )pattern;\n  env->pattern_end    = (UChar* )end;\n  env->reg            = reg;\n\n  *root = NULL;\n\n  if (! ONIGENC_IS_VALID_MBC_STRING(env->enc, pattern, end))\n    return ONIGERR_INVALID_WIDE_CHAR_VALUE;\n\n  p = (UChar* )pattern;\n  r = parse_regexp(root, &p, (UChar* )end, env);\n  reg->num_mem = env->num_mem;\n  return r;\n}\n\nextern void\nonig_scan_env_set_error_string(ScanEnv* env, int ecode ARG_UNUSED,\n\t\t\t\tUChar* arg, UChar* arg_end)\n{\n  env->error     = arg;\n  env->error_end = arg_end;\n}\n"], "fixing_code": ["/**********************************************************************\n  regparse.c -  Oniguruma (regular expression library)\n**********************************************************************/\n/*-\n * Copyright (c) 2002-2016  K.Kosako  <sndgk393 AT ybb DOT ne DOT jp>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n#include \"regparse.h\"\n#include \"st.h\"\n\n#ifdef DEBUG_NODE_FREE\n#include <stdio.h>\n#endif\n\n#define WARN_BUFSIZE    256\n\n#define CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS\n\n\nOnigSyntaxType OnigSyntaxRuby = {\n  (( SYN_GNU_REGEX_OP | ONIG_SYN_OP_QMARK_NON_GREEDY |\n     ONIG_SYN_OP_ESC_OCTAL3 | ONIG_SYN_OP_ESC_X_HEX2 |\n     ONIG_SYN_OP_ESC_X_BRACE_HEX8 | ONIG_SYN_OP_ESC_O_BRACE_OCTAL |\n     ONIG_SYN_OP_ESC_CONTROL_CHARS |\n     ONIG_SYN_OP_ESC_C_CONTROL )\n   & ~ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END )\n  , ( ONIG_SYN_OP2_QMARK_GROUP_EFFECT |\n      ONIG_SYN_OP2_OPTION_RUBY |\n      ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP | ONIG_SYN_OP2_ESC_K_NAMED_BACKREF |\n      ONIG_SYN_OP2_ESC_G_SUBEXP_CALL |\n      ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY  |\n      ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT |\n      ONIG_SYN_OP2_PLUS_POSSESSIVE_REPEAT |\n      ONIG_SYN_OP2_CCLASS_SET_OP | ONIG_SYN_OP2_ESC_CAPITAL_C_BAR_CONTROL |\n      ONIG_SYN_OP2_ESC_CAPITAL_M_BAR_META | ONIG_SYN_OP2_ESC_V_VTAB |\n      ONIG_SYN_OP2_ESC_H_XDIGIT )\n  , ( SYN_GNU_REGEX_BV | \n      ONIG_SYN_ALLOW_INTERVAL_LOW_ABBREV |\n      ONIG_SYN_DIFFERENT_LEN_ALT_LOOK_BEHIND |\n      ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP |\n      ONIG_SYN_ALLOW_MULTIPLEX_DEFINITION_NAME |\n      ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY |\n      ONIG_SYN_WARN_CC_OP_NOT_ESCAPED |\n      ONIG_SYN_WARN_REDUNDANT_NESTED_REPEAT )\n  , ONIG_OPTION_NONE\n  ,\n  {\n      (OnigCodePoint )'\\\\'                       /* esc */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* anychar '.'  */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* anytime '*'  */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* zero or one time '?' */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* one or more time '+' */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* anychar anytime */\n  }\n};\n\nOnigSyntaxType*  OnigDefaultSyntax = ONIG_SYNTAX_RUBY;\n\nextern void onig_null_warn(const char* s ARG_UNUSED) { }\n\n#ifdef DEFAULT_WARN_FUNCTION\nstatic OnigWarnFunc onig_warn = (OnigWarnFunc )DEFAULT_WARN_FUNCTION;\n#else\nstatic OnigWarnFunc onig_warn = onig_null_warn;\n#endif\n\n#ifdef DEFAULT_VERB_WARN_FUNCTION\nstatic OnigWarnFunc onig_verb_warn = (OnigWarnFunc )DEFAULT_VERB_WARN_FUNCTION;\n#else\nstatic OnigWarnFunc onig_verb_warn = onig_null_warn;\n#endif\n\nextern void onig_set_warn_func(OnigWarnFunc f)\n{\n  onig_warn = f;\n}\n\nextern void onig_set_verb_warn_func(OnigWarnFunc f)\n{\n  onig_verb_warn = f;\n}\n\nextern void\nonig_warning(const char* s)\n{\n  if (onig_warn == onig_null_warn) return ;\n\n  (*onig_warn)(s);\n}\n\n#define DEFAULT_MAX_CAPTURE_NUM   32767\n\nstatic int MaxCaptureNum = DEFAULT_MAX_CAPTURE_NUM;\n\nextern int\nonig_set_capture_num_limit(int num)\n{\n  if (num < 0) return -1;\n\n  MaxCaptureNum = num;\n  return 0;\n}\n\nstatic unsigned int ParseDepthLimit = DEFAULT_PARSE_DEPTH_LIMIT;\n\nextern unsigned int\nonig_get_parse_depth_limit(void)\n{\n  return ParseDepthLimit;\n}\n\nextern int\nonig_set_parse_depth_limit(unsigned int depth)\n{\n  if (depth == 0)\n    ParseDepthLimit = DEFAULT_PARSE_DEPTH_LIMIT;\n  else\n    ParseDepthLimit = depth;\n  return 0;\n}\n\n\nstatic void\nbbuf_free(BBuf* bbuf)\n{\n  if (IS_NOT_NULL(bbuf)) {\n    if (IS_NOT_NULL(bbuf->p)) xfree(bbuf->p);\n    xfree(bbuf);\n  }\n}\n\nstatic int\nbbuf_clone(BBuf** rto, BBuf* from)\n{\n  int r;\n  BBuf *to;\n\n  *rto = to = (BBuf* )xmalloc(sizeof(BBuf));\n  CHECK_NULL_RETURN_MEMERR(to);\n  r = BBUF_INIT(to, from->alloc);\n  if (r != 0) return r;\n  to->used = from->used;\n  xmemcpy(to->p, from->p, from->used);\n  return 0;\n}\n\n#define BACKREF_REL_TO_ABS(rel_no, env) \\\n  ((env)->num_mem + 1 + (rel_no))\n\n#define ONOFF(v,f,negative)    (negative) ? ((v) &= ~(f)) : ((v) |= (f))\n\n#define MBCODE_START_POS(enc) \\\n  (OnigCodePoint )(ONIGENC_MBC_MINLEN(enc) > 1 ? 0 : 0x80)\n\n#define SET_ALL_MULTI_BYTE_RANGE(enc, pbuf) \\\n  add_code_range_to_buf(pbuf, MBCODE_START_POS(enc), ~((OnigCodePoint )0))\n\n#define ADD_ALL_MULTI_BYTE_RANGE(enc, mbuf) do {\\\n  if (! ONIGENC_IS_SINGLEBYTE(enc)) {\\\n    r = SET_ALL_MULTI_BYTE_RANGE(enc, &(mbuf));\\\n    if (r) return r;\\\n  }\\\n} while (0)\n\n\n#define BITSET_IS_EMPTY(bs,empty) do {\\\n  int i;\\\n  empty = 1;\\\n  for (i = 0; i < (int )BITSET_SIZE; i++) {\\\n    if ((bs)[i] != 0) {\\\n      empty = 0; break;\\\n    }\\\n  }\\\n} while (0)\n\nstatic void\nbitset_set_range(BitSetRef bs, int from, int to)\n{\n  int i;\n  for (i = from; i <= to && i < SINGLE_BYTE_SIZE; i++) {\n    BITSET_SET_BIT(bs, i);\n  }\n}\n\n#if 0\nstatic void\nbitset_set_all(BitSetRef bs)\n{\n  int i;\n  for (i = 0; i < BITSET_SIZE; i++) { bs[i] = ~((Bits )0); }\n}\n#endif\n\nstatic void\nbitset_invert(BitSetRef bs)\n{\n  int i;\n  for (i = 0; i < (int )BITSET_SIZE; i++) { bs[i] = ~(bs[i]); }\n}\n\nstatic void\nbitset_invert_to(BitSetRef from, BitSetRef to)\n{\n  int i;\n  for (i = 0; i < (int )BITSET_SIZE; i++) { to[i] = ~(from[i]); }\n}\n\nstatic void\nbitset_and(BitSetRef dest, BitSetRef bs)\n{\n  int i;\n  for (i = 0; i < (int )BITSET_SIZE; i++) { dest[i] &= bs[i]; }\n}\n\nstatic void\nbitset_or(BitSetRef dest, BitSetRef bs)\n{\n  int i;\n  for (i = 0; i < (int )BITSET_SIZE; i++) { dest[i] |= bs[i]; }\n}\n\nstatic void\nbitset_copy(BitSetRef dest, BitSetRef bs)\n{\n  int i;\n  for (i = 0; i < (int )BITSET_SIZE; i++) { dest[i] = bs[i]; }\n}\n\nextern int\nonig_strncmp(const UChar* s1, const UChar* s2, int n)\n{\n  int x;\n\n  while (n-- > 0) {\n    x = *s2++ - *s1++;\n    if (x) return x;\n  }\n  return 0;\n}\n\nextern void\nonig_strcpy(UChar* dest, const UChar* src, const UChar* end)\n{\n  int len = end - src;\n  if (len > 0) {\n    xmemcpy(dest, src, len);\n    dest[len] = (UChar )0;\n  }\n}\n\n#ifdef USE_NAMED_GROUP\nstatic UChar*\nstrdup_with_null(OnigEncoding enc, UChar* s, UChar* end)\n{\n  int slen, term_len, i;\n  UChar *r;\n\n  slen = end - s;\n  term_len = ONIGENC_MBC_MINLEN(enc);\n\n  r = (UChar* )xmalloc(slen + term_len);\n  CHECK_NULL_RETURN(r);\n  xmemcpy(r, s, slen);\n\n  for (i = 0; i < term_len; i++)\n    r[slen + i] = (UChar )0;\n\n  return r;\n}\n#endif\n\n/* scan pattern methods */\n#define PEND_VALUE   0\n\n#define PFETCH_READY  UChar* pfetch_prev\n#define PEND         (p < end ?  0 : 1)\n#define PUNFETCH     p = pfetch_prev\n#define PINC       do { \\\n  pfetch_prev = p; \\\n  p += ONIGENC_MBC_ENC_LEN(enc, p); \\\n} while (0)\n#define PFETCH(c)  do { \\\n  c = ONIGENC_MBC_TO_CODE(enc, p, end); \\\n  pfetch_prev = p; \\\n  p += ONIGENC_MBC_ENC_LEN(enc, p); \\\n} while (0)\n\n#define PINC_S     do { \\\n  p += ONIGENC_MBC_ENC_LEN(enc, p); \\\n} while (0)\n#define PFETCH_S(c) do { \\\n  c = ONIGENC_MBC_TO_CODE(enc, p, end); \\\n  p += ONIGENC_MBC_ENC_LEN(enc, p); \\\n} while (0)\n\n#define PPEEK        (p < end ? ONIGENC_MBC_TO_CODE(enc, p, end) : PEND_VALUE)\n#define PPEEK_IS(c)  (PPEEK == (OnigCodePoint )c)\n\nstatic UChar*\nstrcat_capa(UChar* dest, UChar* dest_end, const UChar* src, const UChar* src_end,\n\t      int capa)\n{\n  UChar* r;\n\n  if (dest)\n    r = (UChar* )xrealloc(dest, capa + 1);\n  else\n    r = (UChar* )xmalloc(capa + 1);\n\n  CHECK_NULL_RETURN(r);\n  onig_strcpy(r + (dest_end - dest), src, src_end);\n  return r;\n}\n\n/* dest on static area */\nstatic UChar*\nstrcat_capa_from_static(UChar* dest, UChar* dest_end,\n\t\t\tconst UChar* src, const UChar* src_end, int capa)\n{\n  UChar* r;\n\n  r = (UChar* )xmalloc(capa + 1);\n  CHECK_NULL_RETURN(r);\n  onig_strcpy(r, dest, dest_end);\n  onig_strcpy(r + (dest_end - dest), src, src_end);\n  return r;\n}\n\n\n#ifdef USE_ST_LIBRARY\n\ntypedef struct {\n  UChar* s;\n  UChar* end;\n} st_str_end_key;\n\nstatic int\nstr_end_cmp(st_str_end_key* x, st_str_end_key* y)\n{\n  UChar *p, *q;\n  int c;\n\n  if ((x->end - x->s) != (y->end - y->s))\n    return 1;\n\n  p = x->s;\n  q = y->s;\n  while (p < x->end) {\n    c = (int )*p - (int )*q;\n    if (c != 0) return c;\n\n    p++; q++;\n  }\n\n  return 0;\n}\n\nstatic int\nstr_end_hash(st_str_end_key* x)\n{\n  UChar *p;\n  int val = 0;\n\n  p = x->s;\n  while (p < x->end) {\n    val = val * 997 + (int )*p++;\n  }\n\n  return val + (val >> 5);\n}\n\nextern hash_table_type*\nonig_st_init_strend_table_with_size(int size)\n{\n  static struct st_hash_type hashType = {\n    str_end_cmp,\n    str_end_hash,\n  };\n\n  return (hash_table_type* )\n           onig_st_init_table_with_size(&hashType, size);\n}\n\nextern int\nonig_st_lookup_strend(hash_table_type* table, const UChar* str_key,\n\t\t      const UChar* end_key, hash_data_type *value)\n{\n  st_str_end_key key;\n\n  key.s   = (UChar* )str_key;\n  key.end = (UChar* )end_key;\n\n  return onig_st_lookup(table, (st_data_t )(&key), value);\n}\n\nextern int\nonig_st_insert_strend(hash_table_type* table, const UChar* str_key,\n\t\t      const UChar* end_key, hash_data_type value)\n{\n  st_str_end_key* key;\n  int result;\n\n  key = (st_str_end_key* )xmalloc(sizeof(st_str_end_key));\n  key->s   = (UChar* )str_key;\n  key->end = (UChar* )end_key;\n  result = onig_st_insert(table, (st_data_t )key, value);\n  if (result) {\n    xfree(key);\n  }\n  return result;\n}\n\n#endif /* USE_ST_LIBRARY */\n\n\n#ifdef USE_NAMED_GROUP\n\n#define INIT_NAME_BACKREFS_ALLOC_NUM   8\n\ntypedef struct {\n  UChar* name;\n  int    name_len;   /* byte length */\n  int    back_num;   /* number of backrefs */\n  int    back_alloc;\n  int    back_ref1;\n  int*   back_refs;\n} NameEntry;\n\n#ifdef USE_ST_LIBRARY\n\ntypedef st_table  NameTable;\ntypedef st_data_t HashDataType;   /* 1.6 st.h doesn't define st_data_t type */\n\n#define NAMEBUF_SIZE    24\n#define NAMEBUF_SIZE_1  25\n\n#ifdef ONIG_DEBUG\nstatic int\ni_print_name_entry(UChar* key, NameEntry* e, void* arg)\n{\n  int i;\n  FILE* fp = (FILE* )arg;\n\n  fprintf(fp, \"%s: \", e->name);\n  if (e->back_num == 0)\n    fputs(\"-\", fp);\n  else if (e->back_num == 1)\n    fprintf(fp, \"%d\", e->back_ref1);\n  else {\n    for (i = 0; i < e->back_num; i++) {\n      if (i > 0) fprintf(fp, \", \");\n      fprintf(fp, \"%d\", e->back_refs[i]);\n    }\n  }\n  fputs(\"\\n\", fp);\n  return ST_CONTINUE;\n}\n\nextern int\nonig_print_names(FILE* fp, regex_t* reg)\n{\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    fprintf(fp, \"name table\\n\");\n    onig_st_foreach(t, i_print_name_entry, (HashDataType )fp);\n    fputs(\"\\n\", fp);\n  }\n  return 0;\n}\n#endif /* ONIG_DEBUG */\n\nstatic int\ni_free_name_entry(UChar* key, NameEntry* e, void* arg ARG_UNUSED)\n{\n  xfree(e->name);\n  if (IS_NOT_NULL(e->back_refs)) xfree(e->back_refs);\n  xfree(key);\n  xfree(e);\n  return ST_DELETE;\n}\n\nstatic int\nnames_clear(regex_t* reg)\n{\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    onig_st_foreach(t, i_free_name_entry, 0);\n  }\n  return 0;\n}\n\nextern int\nonig_names_free(regex_t* reg)\n{\n  int r;\n  NameTable* t;\n\n  r = names_clear(reg);\n  if (r) return r;\n\n  t = (NameTable* )reg->name_table;\n  if (IS_NOT_NULL(t)) onig_st_free_table(t);\n  reg->name_table = (void* )NULL;\n  return 0;\n}\n\nstatic NameEntry*\nname_find(regex_t* reg, const UChar* name, const UChar* name_end)\n{\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  e = (NameEntry* )NULL;\n  if (IS_NOT_NULL(t)) {\n    onig_st_lookup_strend(t, name, name_end, (HashDataType* )((void* )(&e)));\n  }\n  return e;\n}\n\ntypedef struct {\n  int (*func)(const UChar*, const UChar*,int,int*,regex_t*,void*);\n  regex_t* reg;\n  void* arg;\n  int ret;\n  OnigEncoding enc;\n} INamesArg;\n\nstatic int\ni_names(UChar* key ARG_UNUSED, NameEntry* e, INamesArg* arg)\n{\n  int r = (*(arg->func))(e->name,\n                         e->name + e->name_len,\n                         e->back_num,\n\t\t\t (e->back_num > 1 ? e->back_refs : &(e->back_ref1)),\n\t\t\t arg->reg, arg->arg);\n  if (r != 0) {\n    arg->ret = r;\n    return ST_STOP;\n  }\n  return ST_CONTINUE;\n}\n\nextern int\nonig_foreach_name(regex_t* reg,\n  int (*func)(const UChar*, const UChar*,int,int*,regex_t*,void*), void* arg)\n{\n  INamesArg narg;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  narg.ret = 0;\n  if (IS_NOT_NULL(t)) {\n    narg.func = func;\n    narg.reg  = reg;\n    narg.arg  = arg;\n    narg.enc  = reg->enc; /* should be pattern encoding. */\n    onig_st_foreach(t, i_names, (HashDataType )&narg);\n  }\n  return narg.ret;\n}\n\nstatic int\ni_renumber_name(UChar* key ARG_UNUSED, NameEntry* e, GroupNumRemap* map)\n{\n  int i;\n\n  if (e->back_num > 1) {\n    for (i = 0; i < e->back_num; i++) {\n      e->back_refs[i] = map[e->back_refs[i]].new_val;\n    }\n  }\n  else if (e->back_num == 1) {\n    e->back_ref1 = map[e->back_ref1].new_val;\n  }\n\n  return ST_CONTINUE;\n}\n\nextern int\nonig_renumber_name_table(regex_t* reg, GroupNumRemap* map)\n{\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    onig_st_foreach(t, i_renumber_name, (HashDataType )map);\n  }\n  return 0;\n}\n\n\nextern int\nonig_number_of_names(regex_t* reg)\n{\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t))\n    return t->num_entries;\n  else\n    return 0;\n}\n\n#else  /* USE_ST_LIBRARY */\n\n#define INIT_NAMES_ALLOC_NUM    8\n\ntypedef struct {\n  NameEntry* e;\n  int        num;\n  int        alloc;\n} NameTable;\n\n#ifdef ONIG_DEBUG\nextern int\nonig_print_names(FILE* fp, regex_t* reg)\n{\n  int i, j;\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t) && t->num > 0) {\n    fprintf(fp, \"name table\\n\");\n    for (i = 0; i < t->num; i++) {\n      e = &(t->e[i]);\n      fprintf(fp, \"%s: \", e->name);\n      if (e->back_num == 0) {\n        fputs(\"-\", fp);\n      }\n      else if (e->back_num == 1) {\n        fprintf(fp, \"%d\", e->back_ref1);\n      }\n      else {\n        for (j = 0; j < e->back_num; j++) {\n          if (j > 0) fprintf(fp, \", \");\n          fprintf(fp, \"%d\", e->back_refs[j]);\n        }\n      }\n      fputs(\"\\n\", fp);\n    }\n    fputs(\"\\n\", fp);\n  }\n  return 0;\n}\n#endif\n\nstatic int\nnames_clear(regex_t* reg)\n{\n  int i;\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    for (i = 0; i < t->num; i++) {\n      e = &(t->e[i]);\n      if (IS_NOT_NULL(e->name)) {\n        xfree(e->name);\n        e->name       = NULL;\n        e->name_len   = 0;\n        e->back_num   = 0;\n        e->back_alloc = 0;\n        if (IS_NOT_NULL(e->back_refs)) xfree(e->back_refs);\n        e->back_refs = (int* )NULL;\n      }\n    }\n    if (IS_NOT_NULL(t->e)) {\n      xfree(t->e);\n      t->e = NULL;\n    }\n    t->num = 0;\n  }\n  return 0;\n}\n\nextern int\nonig_names_free(regex_t* reg)\n{\n  int r;\n  NameTable* t;\n\n  r = names_clear(reg);\n  if (r) return r;\n\n  t = (NameTable* )reg->name_table;\n  if (IS_NOT_NULL(t)) xfree(t);\n  reg->name_table = NULL;\n  return 0;\n}\n\nstatic NameEntry*\nname_find(regex_t* reg, UChar* name, UChar* name_end)\n{\n  int i, len;\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    len = name_end - name;\n    for (i = 0; i < t->num; i++) {\n      e = &(t->e[i]);\n      if (len == e->name_len && onig_strncmp(name, e->name, len) == 0)\n        return e;\n    }\n  }\n  return (NameEntry* )NULL;\n}\n\nextern int\nonig_foreach_name(regex_t* reg,\n  int (*func)(const UChar*, const UChar*,int,int*,regex_t*,void*), void* arg)\n{\n  int i, r;\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    for (i = 0; i < t->num; i++) {\n      e = &(t->e[i]);\n      r = (*func)(e->name, e->name + e->name_len, e->back_num,\n                  (e->back_num > 1 ? e->back_refs : &(e->back_ref1)),\n                  reg, arg);\n      if (r != 0) return r;\n    }\n  }\n  return 0;\n}\n\nextern int\nonig_number_of_names(regex_t* reg)\n{\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t))\n    return t->num;\n  else\n    return 0;\n}\n\n#endif /* else USE_ST_LIBRARY */\n\nstatic int\nname_add(regex_t* reg, UChar* name, UChar* name_end, int backref, ScanEnv* env)\n{\n  int alloc;\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (name_end - name <= 0)\n    return ONIGERR_EMPTY_GROUP_NAME;\n\n  e = name_find(reg, name, name_end);\n  if (IS_NULL(e)) {\n#ifdef USE_ST_LIBRARY\n    if (IS_NULL(t)) {\n      t = onig_st_init_strend_table_with_size(5);\n      reg->name_table = (void* )t;\n    }\n    e = (NameEntry* )xmalloc(sizeof(NameEntry));\n    CHECK_NULL_RETURN_MEMERR(e);\n\n    e->name = strdup_with_null(reg->enc, name, name_end);\n    if (IS_NULL(e->name)) {\n      xfree(e);  return ONIGERR_MEMORY;\n    }\n    onig_st_insert_strend(t, e->name, (e->name + (name_end - name)),\n                          (HashDataType )e);\n\n    e->name_len   = name_end - name;\n    e->back_num   = 0;\n    e->back_alloc = 0;\n    e->back_refs  = (int* )NULL;\n\n#else\n\n    if (IS_NULL(t)) {\n      alloc = INIT_NAMES_ALLOC_NUM;\n      t = (NameTable* )xmalloc(sizeof(NameTable));\n      CHECK_NULL_RETURN_MEMERR(t);\n      t->e     = NULL;\n      t->alloc = 0;\n      t->num   = 0;\n\n      t->e = (NameEntry* )xmalloc(sizeof(NameEntry) * alloc);\n      if (IS_NULL(t->e)) {\n        xfree(t);\n        return ONIGERR_MEMORY;\n      }\n      t->alloc = alloc;\n      reg->name_table = t;\n      goto clear;\n    }\n    else if (t->num == t->alloc) {\n      int i;\n\n      alloc = t->alloc * 2;\n      t->e = (NameEntry* )xrealloc(t->e, sizeof(NameEntry) * alloc);\n      CHECK_NULL_RETURN_MEMERR(t->e);\n      t->alloc = alloc;\n\n    clear:\n      for (i = t->num; i < t->alloc; i++) {\n        t->e[i].name       = NULL;\n        t->e[i].name_len   = 0;\n        t->e[i].back_num   = 0;\n        t->e[i].back_alloc = 0;\n        t->e[i].back_refs  = (int* )NULL;\n      }\n    }\n    e = &(t->e[t->num]);\n    t->num++;\n    e->name = strdup_with_null(reg->enc, name, name_end);\n    if (IS_NULL(e->name)) return ONIGERR_MEMORY;\n    e->name_len = name_end - name;\n#endif\n  }\n\n  if (e->back_num >= 1 &&\n      ! IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_MULTIPLEX_DEFINITION_NAME)) {\n    onig_scan_env_set_error_string(env, ONIGERR_MULTIPLEX_DEFINED_NAME,\n                                   name, name_end);\n    return ONIGERR_MULTIPLEX_DEFINED_NAME;\n  }\n\n  e->back_num++;\n  if (e->back_num == 1) {\n    e->back_ref1 = backref;\n  }\n  else {\n    if (e->back_num == 2) {\n      alloc = INIT_NAME_BACKREFS_ALLOC_NUM;\n      e->back_refs = (int* )xmalloc(sizeof(int) * alloc);\n      CHECK_NULL_RETURN_MEMERR(e->back_refs);\n      e->back_alloc = alloc;\n      e->back_refs[0] = e->back_ref1;\n      e->back_refs[1] = backref;\n    }\n    else {\n      if (e->back_num > e->back_alloc) {\n        alloc = e->back_alloc * 2;\n        e->back_refs = (int* )xrealloc(e->back_refs, sizeof(int) * alloc);\n        CHECK_NULL_RETURN_MEMERR(e->back_refs);\n        e->back_alloc = alloc;\n      }\n      e->back_refs[e->back_num - 1] = backref;\n    }\n  }\n\n  return 0;\n}\n\nextern int\nonig_name_to_group_numbers(regex_t* reg, const UChar* name,\n\t\t\t   const UChar* name_end, int** nums)\n{\n  NameEntry* e = name_find(reg, name, name_end);\n\n  if (IS_NULL(e)) return ONIGERR_UNDEFINED_NAME_REFERENCE;\n\n  switch (e->back_num) {\n  case 0:\n    break;\n  case 1:\n    *nums = &(e->back_ref1);\n    break;\n  default:\n    *nums = e->back_refs;\n    break;\n  }\n  return e->back_num;\n}\n\nextern int\nonig_name_to_backref_number(regex_t* reg, const UChar* name,\n\t\t\t    const UChar* name_end, OnigRegion *region)\n{\n  int i, n, *nums;\n\n  n = onig_name_to_group_numbers(reg, name, name_end, &nums);\n  if (n < 0)\n    return n;\n  else if (n == 0)\n    return ONIGERR_PARSER_BUG;\n  else if (n == 1)\n    return nums[0];\n  else {\n    if (IS_NOT_NULL(region)) {\n      for (i = n - 1; i >= 0; i--) {\n        if (region->beg[nums[i]] != ONIG_REGION_NOTPOS)\n          return nums[i];\n      }\n    }\n    return nums[n - 1];\n  }\n}\n\n#else /* USE_NAMED_GROUP */\n\nextern int\nonig_name_to_group_numbers(regex_t* reg, const UChar* name,\n\t\t\t   const UChar* name_end, int** nums)\n{\n  return ONIG_NO_SUPPORT_CONFIG;\n}\n\nextern int\nonig_name_to_backref_number(regex_t* reg, const UChar* name,\n\t\t\t    const UChar* name_end, OnigRegion* region)\n{\n  return ONIG_NO_SUPPORT_CONFIG;\n}\n\nextern int\nonig_foreach_name(regex_t* reg,\n  int (*func)(const UChar*, const UChar*,int,int*,regex_t*,void*), void* arg)\n{\n  return ONIG_NO_SUPPORT_CONFIG;\n}\n\nextern int\nonig_number_of_names(regex_t* reg)\n{\n  return 0;\n}\n#endif /* else USE_NAMED_GROUP */\n\nextern int\nonig_noname_group_capture_is_active(regex_t* reg)\n{\n  if (ONIG_IS_OPTION_ON(reg->options, ONIG_OPTION_DONT_CAPTURE_GROUP))\n    return 0;\n\n#ifdef USE_NAMED_GROUP\n  if (onig_number_of_names(reg) > 0 &&\n      IS_SYNTAX_BV(reg->syntax, ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP) &&\n      !ONIG_IS_OPTION_ON(reg->options, ONIG_OPTION_CAPTURE_GROUP)) {\n    return 0;\n  }\n#endif\n\n  return 1;\n}\n\n\n#define INIT_SCANENV_MEMNODES_ALLOC_SIZE   16\n\nstatic void\nscan_env_clear(ScanEnv* env)\n{\n  int i;\n\n  BIT_STATUS_CLEAR(env->capture_history);\n  BIT_STATUS_CLEAR(env->bt_mem_start);\n  BIT_STATUS_CLEAR(env->bt_mem_end);\n  BIT_STATUS_CLEAR(env->backrefed_mem);\n  env->error      = (UChar* )NULL;\n  env->error_end  = (UChar* )NULL;\n  env->num_call   = 0;\n  env->num_mem    = 0;\n#ifdef USE_NAMED_GROUP\n  env->num_named  = 0;\n#endif\n  env->mem_alloc         = 0;\n  env->mem_nodes_dynamic = (Node** )NULL;\n\n  for (i = 0; i < SCANENV_MEMNODES_SIZE; i++)\n    env->mem_nodes_static[i] = NULL_NODE;\n\n#ifdef USE_COMBINATION_EXPLOSION_CHECK\n  env->num_comb_exp_check  = 0;\n  env->comb_exp_max_regnum = 0;\n  env->curr_max_regnum     = 0;\n  env->has_recursion       = 0;\n#endif\n  env->parse_depth         = 0;\n}\n\nstatic int\nscan_env_add_mem_entry(ScanEnv* env)\n{\n  int i, need, alloc;\n  Node** p;\n\n  need = env->num_mem + 1;\n  if (need > MaxCaptureNum && MaxCaptureNum != 0)\n    return ONIGERR_TOO_MANY_CAPTURES;\n\n  if (need >= SCANENV_MEMNODES_SIZE) {\n    if (env->mem_alloc <= need) {\n      if (IS_NULL(env->mem_nodes_dynamic)) {\n        alloc = INIT_SCANENV_MEMNODES_ALLOC_SIZE;\n        p = (Node** )xmalloc(sizeof(Node*) * alloc);\n        xmemcpy(p, env->mem_nodes_static,\n                sizeof(Node*) * SCANENV_MEMNODES_SIZE);\n      }\n      else {\n        alloc = env->mem_alloc * 2;\n        p = (Node** )xrealloc(env->mem_nodes_dynamic, sizeof(Node*) * alloc);\n      }\n      CHECK_NULL_RETURN_MEMERR(p);\n\n      for (i = env->num_mem + 1; i < alloc; i++)\n        p[i] = NULL_NODE;\n\n      env->mem_nodes_dynamic = p;\n      env->mem_alloc = alloc;\n    }\n  }\n\n  env->num_mem++;\n  return env->num_mem;\n}\n\nstatic int\nscan_env_set_mem_node(ScanEnv* env, int num, Node* node)\n{\n  if (env->num_mem >= num)\n    SCANENV_MEM_NODES(env)[num] = node;\n  else\n    return ONIGERR_PARSER_BUG;\n  return 0;\n}\n\nextern void\nonig_node_free(Node* node)\n{\n start:\n  if (IS_NULL(node)) return ;\n\n#ifdef DEBUG_NODE_FREE\n  fprintf(stderr, \"onig_node_free: %p\\n\", node);\n#endif\n\n  switch (NTYPE(node)) {\n  case NT_STR:\n    if (NSTR(node)->capa != 0 &&\n\tIS_NOT_NULL(NSTR(node)->s) && NSTR(node)->s != NSTR(node)->buf) {\n      xfree(NSTR(node)->s);\n    }\n    break;\n\n  case NT_LIST:\n  case NT_ALT:\n    onig_node_free(NCAR(node));\n    {\n      Node* next_node = NCDR(node);\n\n      xfree(node);\n      node = next_node;\n      goto start;\n    }\n    break;\n\n  case NT_CCLASS:\n    {\n      CClassNode* cc = NCCLASS(node);\n\n      if (IS_NCCLASS_SHARE(cc)) return ;\n      if (cc->mbuf)\n        bbuf_free(cc->mbuf);\n    }\n    break;\n\n  case NT_QTFR:\n    if (NQTFR(node)->target)\n      onig_node_free(NQTFR(node)->target);\n    break;\n\n  case NT_ENCLOSE:\n    if (NENCLOSE(node)->target)\n      onig_node_free(NENCLOSE(node)->target);\n    break;\n\n  case NT_BREF:\n    if (IS_NOT_NULL(NBREF(node)->back_dynamic))\n      xfree(NBREF(node)->back_dynamic);\n    break;\n\n  case NT_ANCHOR:\n    if (NANCHOR(node)->target)\n      onig_node_free(NANCHOR(node)->target);\n    break;\n  }\n\n  xfree(node);\n}\n\nstatic Node*\nnode_new(void)\n{\n  Node* node;\n\n  node = (Node* )xmalloc(sizeof(Node));\n  /* xmemset(node, 0, sizeof(Node)); */\n#ifdef DEBUG_NODE_FREE\n  fprintf(stderr, \"node_new: %p\\n\", node);\n#endif\n  return node;\n}\n\n\nstatic void\ninitialize_cclass(CClassNode* cc)\n{\n  BITSET_CLEAR(cc->bs);\n  /* cc->base.flags = 0; */\n  cc->flags = 0;\n  cc->mbuf  = NULL;\n}\n\nstatic Node*\nnode_new_cclass(void)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_CCLASS);\n  initialize_cclass(NCCLASS(node));\n  return node;\n}\n\nstatic Node*\nnode_new_ctype(int type, int not)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_CTYPE);\n  NCTYPE(node)->ctype = type;\n  NCTYPE(node)->not   = not;\n  return node;\n}\n\nstatic Node*\nnode_new_anychar(void)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_CANY);\n  return node;\n}\n\nstatic Node*\nnode_new_list(Node* left, Node* right)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_LIST);\n  NCAR(node)  = left;\n  NCDR(node) = right;\n  return node;\n}\n\nextern Node*\nonig_node_new_list(Node* left, Node* right)\n{\n  return node_new_list(left, right);\n}\n\nextern Node*\nonig_node_list_add(Node* list, Node* x)\n{\n  Node *n;\n\n  n = onig_node_new_list(x, NULL);\n  if (IS_NULL(n)) return NULL_NODE;\n\n  if (IS_NOT_NULL(list)) {\n    while (IS_NOT_NULL(NCDR(list)))\n      list = NCDR(list);\n\n    NCDR(list) = n;\n  }\n\n  return n;\n}\n\nextern Node*\nonig_node_new_alt(Node* left, Node* right)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_ALT);\n  NCAR(node)  = left;\n  NCDR(node) = right;\n  return node;\n}\n\nextern Node*\nonig_node_new_anchor(int type)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_ANCHOR);\n  NANCHOR(node)->type     = type;\n  NANCHOR(node)->target   = NULL;\n  NANCHOR(node)->char_len = -1;\n  return node;\n}\n\nstatic Node*\nnode_new_backref(int back_num, int* backrefs, int by_name,\n#ifdef USE_BACKREF_WITH_LEVEL\n\t\t int exist_level, int nest_level,\n#endif\n\t\t ScanEnv* env)\n{\n  int i;\n  Node* node = node_new();\n\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_BREF);\n  NBREF(node)->state    = 0;\n  NBREF(node)->back_num = back_num;\n  NBREF(node)->back_dynamic = (int* )NULL;\n  if (by_name != 0)\n    NBREF(node)->state |= NST_NAME_REF;\n\n#ifdef USE_BACKREF_WITH_LEVEL\n  if (exist_level != 0) {\n    NBREF(node)->state |= NST_NEST_LEVEL;\n    NBREF(node)->nest_level  = nest_level;\n  }\n#endif\n\n  for (i = 0; i < back_num; i++) {\n    if (backrefs[i] <= env->num_mem &&\n        IS_NULL(SCANENV_MEM_NODES(env)[backrefs[i]])) {\n      NBREF(node)->state |= NST_RECURSION;   /* /...(\\1).../ */\n      break;\n    }\n  }\n\n  if (back_num <= NODE_BACKREFS_SIZE) {\n    for (i = 0; i < back_num; i++)\n      NBREF(node)->back_static[i] = backrefs[i];\n  }\n  else {\n    int* p = (int* )xmalloc(sizeof(int) * back_num);\n    if (IS_NULL(p)) {\n      onig_node_free(node);\n      return NULL;\n    }\n    NBREF(node)->back_dynamic = p;\n    for (i = 0; i < back_num; i++)\n      p[i] = backrefs[i];\n  }\n  return node;\n}\n\n#ifdef USE_SUBEXP_CALL\nstatic Node*\nnode_new_call(UChar* name, UChar* name_end, int gnum)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_CALL);\n  NCALL(node)->state     = 0;\n  NCALL(node)->target    = NULL_NODE;\n  NCALL(node)->name      = name;\n  NCALL(node)->name_end  = name_end;\n  NCALL(node)->group_num = gnum;  /* call by number if gnum != 0 */\n  return node;\n}\n#endif\n\nstatic Node*\nnode_new_quantifier(int lower, int upper, int by_number)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_QTFR);\n  NQTFR(node)->state  = 0;\n  NQTFR(node)->target = NULL;\n  NQTFR(node)->lower  = lower;\n  NQTFR(node)->upper  = upper;\n  NQTFR(node)->greedy = 1;\n  NQTFR(node)->target_empty_info = NQ_TARGET_ISNOT_EMPTY;\n  NQTFR(node)->head_exact        = NULL_NODE;\n  NQTFR(node)->next_head_exact   = NULL_NODE;\n  NQTFR(node)->is_refered        = 0;\n  if (by_number != 0)\n    NQTFR(node)->state |= NST_BY_NUMBER;\n\n#ifdef USE_COMBINATION_EXPLOSION_CHECK\n  NQTFR(node)->comb_exp_check_num = 0;\n#endif\n\n  return node;\n}\n\nstatic Node*\nnode_new_enclose(int type)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_ENCLOSE);\n  NENCLOSE(node)->type      = type;\n  NENCLOSE(node)->state     =  0;\n  NENCLOSE(node)->regnum    =  0;\n  NENCLOSE(node)->option    =  0;\n  NENCLOSE(node)->target    = NULL;\n  NENCLOSE(node)->call_addr = -1;\n  NENCLOSE(node)->opt_count =  0;\n  return node;\n}\n\nextern Node*\nonig_node_new_enclose(int type)\n{\n  return node_new_enclose(type);\n}\n\nstatic Node*\nnode_new_enclose_memory(OnigOptionType option, int is_named)\n{\n  Node* node = node_new_enclose(ENCLOSE_MEMORY);\n  CHECK_NULL_RETURN(node);\n  if (is_named != 0)\n    SET_ENCLOSE_STATUS(node, NST_NAMED_GROUP);\n\n#ifdef USE_SUBEXP_CALL\n  NENCLOSE(node)->option = option;\n#endif\n  return node;\n}\n\nstatic Node*\nnode_new_option(OnigOptionType option)\n{\n  Node* node = node_new_enclose(ENCLOSE_OPTION);\n  CHECK_NULL_RETURN(node);\n  NENCLOSE(node)->option = option;\n  return node;\n}\n\nextern int\nonig_node_str_cat(Node* node, const UChar* s, const UChar* end)\n{\n  int addlen = end - s;\n\n  if (addlen > 0) {\n    int len  = NSTR(node)->end - NSTR(node)->s;\n\n    if (NSTR(node)->capa > 0 || (len + addlen > NODE_STR_BUF_SIZE - 1)) {\n      UChar* p;\n      int capa = len + addlen + NODE_STR_MARGIN;\n\n      if (capa <= NSTR(node)->capa) {\n        onig_strcpy(NSTR(node)->s + len, s, end);\n      }\n      else {\n        if (NSTR(node)->s == NSTR(node)->buf)\n          p = strcat_capa_from_static(NSTR(node)->s, NSTR(node)->end,\n                                      s, end, capa);\n        else\n          p = strcat_capa(NSTR(node)->s, NSTR(node)->end, s, end, capa);\n\n        CHECK_NULL_RETURN_MEMERR(p);\n        NSTR(node)->s    = p;\n        NSTR(node)->capa = capa;\n      }\n    }\n    else {\n      onig_strcpy(NSTR(node)->s + len, s, end);\n    }\n    NSTR(node)->end = NSTR(node)->s + len + addlen;\n  }\n\n  return 0;\n}\n\nextern int\nonig_node_str_set(Node* node, const UChar* s, const UChar* end)\n{\n  onig_node_str_clear(node);\n  return onig_node_str_cat(node, s, end);\n}\n\nstatic int\nnode_str_cat_char(Node* node, UChar c)\n{\n  UChar s[1];\n\n  s[0] = c;\n  return onig_node_str_cat(node, s, s + 1);\n}\n\nextern void\nonig_node_conv_to_str_node(Node* node, int flag)\n{\n  SET_NTYPE(node, NT_STR);\n  NSTR(node)->flag = flag;\n  NSTR(node)->capa = 0;\n  NSTR(node)->s    = NSTR(node)->buf;\n  NSTR(node)->end  = NSTR(node)->buf;\n}\n\nextern void\nonig_node_str_clear(Node* node)\n{\n  if (NSTR(node)->capa != 0 &&\n      IS_NOT_NULL(NSTR(node)->s) && NSTR(node)->s != NSTR(node)->buf) {\n    xfree(NSTR(node)->s);\n  }\n\n  NSTR(node)->capa = 0;\n  NSTR(node)->flag = 0;\n  NSTR(node)->s    = NSTR(node)->buf;\n  NSTR(node)->end  = NSTR(node)->buf;\n}\n\nstatic Node*\nnode_new_str(const UChar* s, const UChar* end)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_STR);\n  NSTR(node)->capa = 0;\n  NSTR(node)->flag = 0;\n  NSTR(node)->s    = NSTR(node)->buf;\n  NSTR(node)->end  = NSTR(node)->buf;\n  if (onig_node_str_cat(node, s, end)) {\n    onig_node_free(node);\n    return NULL;\n  }\n  return node;\n}\n\nextern Node*\nonig_node_new_str(const UChar* s, const UChar* end)\n{\n  return node_new_str(s, end);\n}\n\nstatic Node*\nnode_new_str_raw(UChar* s, UChar* end)\n{\n  Node* node = node_new_str(s, end);\n  NSTRING_SET_RAW(node);\n  return node;\n}\n\nstatic Node*\nnode_new_empty(void)\n{\n  return node_new_str(NULL, NULL);\n}\n\nstatic Node*\nnode_new_str_raw_char(UChar c)\n{\n  UChar p[1];\n\n  p[0] = c;\n  return node_new_str_raw(p, p + 1);\n}\n\nstatic Node*\nstr_node_split_last_char(StrNode* sn, OnigEncoding enc)\n{\n  const UChar *p;\n  Node* n = NULL_NODE;\n\n  if (sn->end > sn->s) {\n    p = onigenc_get_prev_char_head(enc, sn->s, sn->end);\n    if (p && p > sn->s) { /* can be split. */\n      n = node_new_str(p, sn->end);\n      if ((sn->flag & NSTR_RAW) != 0)\n        NSTRING_SET_RAW(n);\n\n      sn->end = (UChar* )p;\n    }\n  }\n  return n;\n}\n\nstatic int\nstr_node_can_be_split(StrNode* sn, OnigEncoding enc)\n{\n  if (sn->end > sn->s) {\n    return ((enclen(enc, sn->s) < sn->end - sn->s)  ?  1 : 0);\n  }\n  return 0;\n}\n\n#ifdef USE_PAD_TO_SHORT_BYTE_CHAR\nstatic int\nnode_str_head_pad(StrNode* sn, int num, UChar val)\n{\n  UChar buf[NODE_STR_BUF_SIZE];\n  int i, len;\n\n  len = sn->end - sn->s;\n  onig_strcpy(buf, sn->s, sn->end);\n  onig_strcpy(&(sn->s[num]), buf, buf + len);\n  sn->end += num;\n\n  for (i = 0; i < num; i++) {\n    sn->s[i] = val;\n  }\n}\n#endif\n\nextern int\nonig_scan_unsigned_number(UChar** src, const UChar* end, OnigEncoding enc)\n{\n  unsigned int num, val;\n  OnigCodePoint c;\n  UChar* p = *src;\n  PFETCH_READY;\n\n  num = 0;\n  while (!PEND) {\n    PFETCH(c);\n    if (ONIGENC_IS_CODE_DIGIT(enc, c)) {\n      val = (unsigned int )DIGITVAL(c);\n      if ((INT_MAX_LIMIT - val) / 10UL < num)\n        return -1;  /* overflow */\n\n      num = num * 10 + val;\n    }\n    else {\n      PUNFETCH;\n      break;\n    }\n  }\n  *src = p;\n  return num;\n}\n\nstatic int\nscan_unsigned_hexadecimal_number(UChar** src, UChar* end, int maxlen,\n\t\t\t\t OnigEncoding enc)\n{\n  OnigCodePoint c;\n  unsigned int num, val;\n  UChar* p = *src;\n  PFETCH_READY;\n\n  num = 0;\n  while (! PEND && maxlen-- != 0) {\n    PFETCH(c);\n    if (ONIGENC_IS_CODE_XDIGIT(enc, c)) {\n      val = (unsigned int )XDIGITVAL(enc,c);\n      if ((INT_MAX_LIMIT - val) / 16UL < num)\n        return -1;  /* overflow */\n\n      num = (num << 4) + XDIGITVAL(enc,c);\n    }\n    else {\n      PUNFETCH;\n      break;\n    }\n  }\n  *src = p;\n  return num;\n}\n\nstatic int\nscan_unsigned_octal_number(UChar** src, UChar* end, int maxlen,\n\t\t\t   OnigEncoding enc)\n{\n  OnigCodePoint c;\n  unsigned int num, val;\n  UChar* p = *src;\n  PFETCH_READY;\n\n  num = 0;\n  while (!PEND && maxlen-- != 0) {\n    PFETCH(c);\n    if (ONIGENC_IS_CODE_DIGIT(enc, c) && c < '8') {\n      val = ODIGITVAL(c);\n      if ((INT_MAX_LIMIT - val) / 8UL < num)\n        return -1;  /* overflow */\n\n      num = (num << 3) + val;\n    }\n    else {\n      PUNFETCH;\n      break;\n    }\n  }\n  *src = p;\n  return num;\n}\n\n\n#define BBUF_WRITE_CODE_POINT(bbuf,pos,code) \\\n    BBUF_WRITE(bbuf, pos, &(code), SIZE_CODE_POINT)\n\n/* data format:\n     [n][from-1][to-1][from-2][to-2] ... [from-n][to-n]\n     (all data size is OnigCodePoint)\n */\nstatic int\nnew_code_range(BBuf** pbuf)\n{\n#define INIT_MULTI_BYTE_RANGE_SIZE  (SIZE_CODE_POINT * 5)\n  int r;\n  OnigCodePoint n;\n  BBuf* bbuf;\n\n  bbuf = *pbuf = (BBuf* )xmalloc(sizeof(BBuf));\n  CHECK_NULL_RETURN_MEMERR(*pbuf);\n  r = BBUF_INIT(*pbuf, INIT_MULTI_BYTE_RANGE_SIZE);\n  if (r) return r;\n\n  n = 0;\n  BBUF_WRITE_CODE_POINT(bbuf, 0, n);\n  return 0;\n}\n\nstatic int\nadd_code_range_to_buf(BBuf** pbuf, OnigCodePoint from, OnigCodePoint to)\n{\n  int r, inc_n, pos;\n  int low, high, bound, x;\n  OnigCodePoint n, *data;\n  BBuf* bbuf;\n\n  if (from > to) {\n    n = from; from = to; to = n;\n  }\n\n  if (IS_NULL(*pbuf)) {\n    r = new_code_range(pbuf);\n    if (r) return r;\n    bbuf = *pbuf;\n    n = 0;\n  }\n  else {\n    bbuf = *pbuf;\n    GET_CODE_POINT(n, bbuf->p);\n  }\n  data = (OnigCodePoint* )(bbuf->p);\n  data++;\n\n  for (low = 0, bound = n; low < bound; ) {\n    x = (low + bound) >> 1;\n    if (from > data[x*2 + 1])\n      low = x + 1;\n    else\n      bound = x;\n  }\n\n  high = (to == ~((OnigCodePoint )0)) ? n : low;\n  for (bound = n; high < bound; ) {\n    x = (high + bound) >> 1;\n    if (to + 1 >= data[x*2])\n      high = x + 1;\n    else\n      bound = x;\n  }\n\n  inc_n = low + 1 - high;\n  if (n + inc_n > ONIG_MAX_MULTI_BYTE_RANGES_NUM)\n    return ONIGERR_TOO_MANY_MULTI_BYTE_RANGES;\n\n  if (inc_n != 1) {\n    if (from > data[low*2])\n      from = data[low*2];\n    if (to < data[(high - 1)*2 + 1])\n      to = data[(high - 1)*2 + 1];\n  }\n\n  if (inc_n != 0 && (OnigCodePoint )high < n) {\n    int from_pos = SIZE_CODE_POINT * (1 + high * 2);\n    int to_pos   = SIZE_CODE_POINT * (1 + (low + 1) * 2);\n    int size = (n - high) * 2 * SIZE_CODE_POINT;\n\n    if (inc_n > 0) {\n      BBUF_MOVE_RIGHT(bbuf, from_pos, to_pos, size);\n    }\n    else {\n      BBUF_MOVE_LEFT_REDUCE(bbuf, from_pos, to_pos);\n    }\n  }\n\n  pos = SIZE_CODE_POINT * (1 + low * 2);\n  BBUF_ENSURE_SIZE(bbuf, pos + SIZE_CODE_POINT * 2);\n  BBUF_WRITE_CODE_POINT(bbuf, pos, from);\n  BBUF_WRITE_CODE_POINT(bbuf, pos + SIZE_CODE_POINT, to);\n  n += inc_n;\n  BBUF_WRITE_CODE_POINT(bbuf, 0, n);\n\n  return 0;\n}\n\nstatic int\nadd_code_range(BBuf** pbuf, ScanEnv* env, OnigCodePoint from, OnigCodePoint to)\n{\n  if (from > to) {\n    if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n      return 0;\n    else\n      return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n  }\n\n  return add_code_range_to_buf(pbuf, from, to);\n}\n\nstatic int\nnot_code_range_buf(OnigEncoding enc, BBuf* bbuf, BBuf** pbuf)\n{\n  int r, i, n;\n  OnigCodePoint pre, from, *data, to = 0;\n\n  *pbuf = (BBuf* )NULL;\n  if (IS_NULL(bbuf)) {\n  set_all:\n    return SET_ALL_MULTI_BYTE_RANGE(enc, pbuf);\n  }\n\n  data = (OnigCodePoint* )(bbuf->p);\n  GET_CODE_POINT(n, data);\n  data++;\n  if (n <= 0) goto set_all;\n\n  r = 0;\n  pre = MBCODE_START_POS(enc);\n  for (i = 0; i < n; i++) {\n    from = data[i*2];\n    to   = data[i*2+1];\n    if (pre <= from - 1) {\n      r = add_code_range_to_buf(pbuf, pre, from - 1);\n      if (r != 0) return r;\n    }\n    if (to == ~((OnigCodePoint )0)) break;\n    pre = to + 1;\n  }\n  if (to < ~((OnigCodePoint )0)) {\n    r = add_code_range_to_buf(pbuf, to + 1, ~((OnigCodePoint )0));\n  }\n  return r;\n}\n\n#define SWAP_BBUF_NOT(bbuf1, not1, bbuf2, not2) do {\\\n  BBuf *tbuf; \\\n  int  tnot; \\\n  tnot = not1;  not1  = not2;  not2  = tnot; \\\n  tbuf = bbuf1; bbuf1 = bbuf2; bbuf2 = tbuf; \\\n} while (0)\n\nstatic int\nor_code_range_buf(OnigEncoding enc, BBuf* bbuf1, int not1,\n                  BBuf* bbuf2, int not2, BBuf** pbuf)\n{\n  int r;\n  OnigCodePoint i, n1, *data1;\n  OnigCodePoint from, to;\n\n  *pbuf = (BBuf* )NULL;\n  if (IS_NULL(bbuf1) && IS_NULL(bbuf2)) {\n    if (not1 != 0 || not2 != 0)\n      return SET_ALL_MULTI_BYTE_RANGE(enc, pbuf);\n    return 0;\n  }\n\n  r = 0;\n  if (IS_NULL(bbuf2))\n    SWAP_BBUF_NOT(bbuf1, not1, bbuf2, not2);\n\n  if (IS_NULL(bbuf1)) {\n    if (not1 != 0) {\n      return SET_ALL_MULTI_BYTE_RANGE(enc, pbuf);\n    }\n    else {\n      if (not2 == 0) {\n        return bbuf_clone(pbuf, bbuf2);\n      }\n      else {\n        return not_code_range_buf(enc, bbuf2, pbuf);\n      }\n    }\n  }\n\n  if (not1 != 0)\n    SWAP_BBUF_NOT(bbuf1, not1, bbuf2, not2);\n\n  data1 = (OnigCodePoint* )(bbuf1->p);\n  GET_CODE_POINT(n1, data1);\n  data1++;\n\n  if (not2 == 0 && not1 == 0) { /* 1 OR 2 */\n    r = bbuf_clone(pbuf, bbuf2);\n  }\n  else if (not1 == 0) { /* 1 OR (not 2) */\n    r = not_code_range_buf(enc, bbuf2, pbuf);\n  }\n  if (r != 0) return r;\n\n  for (i = 0; i < n1; i++) {\n    from = data1[i*2];\n    to   = data1[i*2+1];\n    r = add_code_range_to_buf(pbuf, from, to);\n    if (r != 0) return r;\n  }\n  return 0;\n}\n\nstatic int\nand_code_range1(BBuf** pbuf, OnigCodePoint from1, OnigCodePoint to1,\n\t        OnigCodePoint* data, int n)\n{\n  int i, r;\n  OnigCodePoint from2, to2;\n\n  for (i = 0; i < n; i++) {\n    from2 = data[i*2];\n    to2   = data[i*2+1];\n    if (from2 < from1) {\n      if (to2 < from1) continue;\n      else {\n        from1 = to2 + 1;\n      }\n    }\n    else if (from2 <= to1) {\n      if (to2 < to1) {\n        if (from1 <= from2 - 1) {\n          r = add_code_range_to_buf(pbuf, from1, from2-1);\n          if (r != 0) return r;\n        }\n        from1 = to2 + 1;\n      }\n      else {\n        to1 = from2 - 1;\n      }\n    }\n    else {\n      from1 = from2;\n    }\n    if (from1 > to1) break;\n  }\n  if (from1 <= to1) {\n    r = add_code_range_to_buf(pbuf, from1, to1);\n    if (r != 0) return r;\n  }\n  return 0;\n}\n\nstatic int\nand_code_range_buf(BBuf* bbuf1, int not1, BBuf* bbuf2, int not2, BBuf** pbuf)\n{\n  int r;\n  OnigCodePoint i, j, n1, n2, *data1, *data2;\n  OnigCodePoint from, to, from1, to1, from2, to2;\n\n  *pbuf = (BBuf* )NULL;\n  if (IS_NULL(bbuf1)) {\n    if (not1 != 0 && IS_NOT_NULL(bbuf2)) /* not1 != 0 -> not2 == 0 */\n      return bbuf_clone(pbuf, bbuf2);\n    return 0;\n  }\n  else if (IS_NULL(bbuf2)) {\n    if (not2 != 0)\n      return bbuf_clone(pbuf, bbuf1);\n    return 0;\n  }\n\n  if (not1 != 0)\n    SWAP_BBUF_NOT(bbuf1, not1, bbuf2, not2);\n\n  data1 = (OnigCodePoint* )(bbuf1->p);\n  data2 = (OnigCodePoint* )(bbuf2->p);\n  GET_CODE_POINT(n1, data1);\n  GET_CODE_POINT(n2, data2);\n  data1++;\n  data2++;\n\n  if (not2 == 0 && not1 == 0) { /* 1 AND 2 */\n    for (i = 0; i < n1; i++) {\n      from1 = data1[i*2];\n      to1   = data1[i*2+1];\n      for (j = 0; j < n2; j++) {\n        from2 = data2[j*2];\n        to2   = data2[j*2+1];\n        if (from2 > to1) break;\n        if (to2 < from1) continue;\n        from = MAX(from1, from2);\n        to   = MIN(to1, to2);\n        r = add_code_range_to_buf(pbuf, from, to);\n        if (r != 0) return r;\n      }\n    }\n  }\n  else if (not1 == 0) { /* 1 AND (not 2) */\n    for (i = 0; i < n1; i++) {\n      from1 = data1[i*2];\n      to1   = data1[i*2+1];\n      r = and_code_range1(pbuf, from1, to1, data2, n2);\n      if (r != 0) return r;\n    }\n  }\n\n  return 0;\n}\n\nstatic int\nand_cclass(CClassNode* dest, CClassNode* cc, OnigEncoding enc)\n{\n  int r, not1, not2;\n  BBuf *buf1, *buf2, *pbuf;\n  BitSetRef bsr1, bsr2;\n  BitSet bs1, bs2;\n\n  not1 = IS_NCCLASS_NOT(dest);\n  bsr1 = dest->bs;\n  buf1 = dest->mbuf;\n  not2 = IS_NCCLASS_NOT(cc);\n  bsr2 = cc->bs;\n  buf2 = cc->mbuf;\n\n  if (not1 != 0) {\n    bitset_invert_to(bsr1, bs1);\n    bsr1 = bs1;\n  }\n  if (not2 != 0) {\n    bitset_invert_to(bsr2, bs2);\n    bsr2 = bs2;\n  }\n  bitset_and(bsr1, bsr2);\n  if (bsr1 != dest->bs) {\n    bitset_copy(dest->bs, bsr1);\n    bsr1 = dest->bs;\n  }\n  if (not1 != 0) {\n    bitset_invert(dest->bs);\n  }\n\n  if (! ONIGENC_IS_SINGLEBYTE(enc)) {\n    if (not1 != 0 && not2 != 0) {\n      r = or_code_range_buf(enc, buf1, 0, buf2, 0, &pbuf);\n    }\n    else {\n      r = and_code_range_buf(buf1, not1, buf2, not2, &pbuf);\n      if (r == 0 && not1 != 0) {\n        BBuf *tbuf;\n        r = not_code_range_buf(enc, pbuf, &tbuf);\n        if (r != 0) {\n          bbuf_free(pbuf);\n          return r;\n        }\n        bbuf_free(pbuf);\n        pbuf = tbuf;\n      }\n    }\n    if (r != 0) return r;\n\n    dest->mbuf = pbuf;\n    bbuf_free(buf1);\n    return r;\n  }\n  return 0;\n}\n\nstatic int\nor_cclass(CClassNode* dest, CClassNode* cc, OnigEncoding enc)\n{\n  int r, not1, not2;\n  BBuf *buf1, *buf2, *pbuf;\n  BitSetRef bsr1, bsr2;\n  BitSet bs1, bs2;\n\n  not1 = IS_NCCLASS_NOT(dest);\n  bsr1 = dest->bs;\n  buf1 = dest->mbuf;\n  not2 = IS_NCCLASS_NOT(cc);\n  bsr2 = cc->bs;\n  buf2 = cc->mbuf;\n\n  if (not1 != 0) {\n    bitset_invert_to(bsr1, bs1);\n    bsr1 = bs1;\n  }\n  if (not2 != 0) {\n    bitset_invert_to(bsr2, bs2);\n    bsr2 = bs2;\n  }\n  bitset_or(bsr1, bsr2);\n  if (bsr1 != dest->bs) {\n    bitset_copy(dest->bs, bsr1);\n    bsr1 = dest->bs;\n  }\n  if (not1 != 0) {\n    bitset_invert(dest->bs);\n  }\n\n  if (! ONIGENC_IS_SINGLEBYTE(enc)) {\n    if (not1 != 0 && not2 != 0) {\n      r = and_code_range_buf(buf1, 0, buf2, 0, &pbuf);\n    }\n    else {\n      r = or_code_range_buf(enc, buf1, not1, buf2, not2, &pbuf);\n      if (r == 0 && not1 != 0) {\n        BBuf *tbuf;\n        r = not_code_range_buf(enc, pbuf, &tbuf);\n        if (r != 0) {\n          bbuf_free(pbuf);\n          return r;\n        }\n        bbuf_free(pbuf);\n        pbuf = tbuf;\n      }\n    }\n    if (r != 0) return r;\n\n    dest->mbuf = pbuf;\n    bbuf_free(buf1);\n    return r;\n  }\n  else\n    return 0;\n}\n\nstatic OnigCodePoint\nconv_backslash_value(OnigCodePoint c, ScanEnv* env)\n{\n  if (IS_SYNTAX_OP(env->syntax, ONIG_SYN_OP_ESC_CONTROL_CHARS)) {\n    switch (c) {\n    case 'n': return '\\n';\n    case 't': return '\\t';\n    case 'r': return '\\r';\n    case 'f': return '\\f';\n    case 'a': return '\\007';\n    case 'b': return '\\010';\n    case 'e': return '\\033';\n    case 'v':\n      if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ESC_V_VTAB))\n\treturn '\\v';\n      break;\n\n    default:\n      break;\n    }\n  }\n  return c;\n}\n\nstatic int\nis_invalid_quantifier_target(Node* node)\n{\n  switch (NTYPE(node)) {\n  case NT_ANCHOR:\n    return 1;\n    break;\n\n  case NT_ENCLOSE:\n    /* allow enclosed elements */\n    /* return is_invalid_quantifier_target(NENCLOSE(node)->target); */\n    break;\n\n  case NT_LIST:\n    do {\n      if (! is_invalid_quantifier_target(NCAR(node))) return 0;\n    } while (IS_NOT_NULL(node = NCDR(node)));\n    return 0;\n    break;\n\n  case NT_ALT:\n    do {\n      if (is_invalid_quantifier_target(NCAR(node))) return 1;\n    } while (IS_NOT_NULL(node = NCDR(node)));\n    break;\n\n  default:\n    break;\n  }\n  return 0;\n}\n\n/* ?:0, *:1, +:2, ??:3, *?:4, +?:5 */\nstatic int\npopular_quantifier_num(QtfrNode* q)\n{\n  if (q->greedy) {\n    if (q->lower == 0) {\n      if (q->upper == 1) return 0;\n      else if (IS_REPEAT_INFINITE(q->upper)) return 1;\n    }\n    else if (q->lower == 1) {\n      if (IS_REPEAT_INFINITE(q->upper)) return 2;\n    }\n  }\n  else {\n    if (q->lower == 0) {\n      if (q->upper == 1) return 3;\n      else if (IS_REPEAT_INFINITE(q->upper)) return 4;\n    }\n    else if (q->lower == 1) {\n      if (IS_REPEAT_INFINITE(q->upper)) return 5;\n    }\n  }\n  return -1;\n}\n\n\nenum ReduceType {\n  RQ_ASIS = 0, /* as is */\n  RQ_DEL  = 1, /* delete parent */\n  RQ_A,        /* to '*'    */\n  RQ_AQ,       /* to '*?'   */\n  RQ_QQ,       /* to '??'   */\n  RQ_P_QQ,     /* to '+)??' */\n  RQ_PQ_Q      /* to '+?)?' */\n};\n\nstatic enum ReduceType ReduceTypeTable[6][6] = {\n  {RQ_DEL,  RQ_A,    RQ_A,   RQ_QQ,   RQ_AQ,   RQ_ASIS}, /* '?'  */\n  {RQ_DEL,  RQ_DEL,  RQ_DEL, RQ_P_QQ, RQ_P_QQ, RQ_DEL},  /* '*'  */\n  {RQ_A,    RQ_A,    RQ_DEL, RQ_ASIS, RQ_P_QQ, RQ_DEL},  /* '+'  */\n  {RQ_DEL,  RQ_AQ,   RQ_AQ,  RQ_DEL,  RQ_AQ,   RQ_AQ},   /* '??' */\n  {RQ_DEL,  RQ_DEL,  RQ_DEL, RQ_DEL,  RQ_DEL,  RQ_DEL},  /* '*?' */\n  {RQ_ASIS, RQ_PQ_Q, RQ_DEL, RQ_AQ,   RQ_AQ,   RQ_DEL}   /* '+?' */\n};\n\nextern void\nonig_reduce_nested_quantifier(Node* pnode, Node* cnode)\n{\n  int pnum, cnum;\n  QtfrNode *p, *c;\n\n  p = NQTFR(pnode);\n  c = NQTFR(cnode);\n  pnum = popular_quantifier_num(p);\n  cnum = popular_quantifier_num(c);\n  if (pnum < 0 || cnum < 0) return ;\n\n  switch(ReduceTypeTable[cnum][pnum]) {\n  case RQ_DEL:\n    *pnode = *cnode;\n    break;\n  case RQ_A:\n    p->target = c->target;\n    p->lower  = 0;  p->upper = REPEAT_INFINITE;  p->greedy = 1;\n    break;\n  case RQ_AQ:\n    p->target = c->target;\n    p->lower  = 0;  p->upper = REPEAT_INFINITE;  p->greedy = 0;\n    break;\n  case RQ_QQ:\n    p->target = c->target;\n    p->lower  = 0;  p->upper = 1;  p->greedy = 0;\n    break;\n  case RQ_P_QQ:\n    p->target = cnode;\n    p->lower  = 0;  p->upper = 1;  p->greedy = 0;\n    c->lower  = 1;  c->upper = REPEAT_INFINITE;  c->greedy = 1;\n    return ;\n    break;\n  case RQ_PQ_Q:\n    p->target = cnode;\n    p->lower  = 0;  p->upper = 1;  p->greedy = 1;\n    c->lower  = 1;  c->upper = REPEAT_INFINITE;  c->greedy = 0;\n    return ;\n    break;\n  case RQ_ASIS:\n    p->target = cnode;\n    return ;\n    break;\n  }\n\n  c->target = NULL_NODE;\n  onig_node_free(cnode);\n}\n\n\nenum TokenSyms {\n  TK_EOT      = 0,   /* end of token */\n  TK_RAW_BYTE = 1,\n  TK_CHAR,\n  TK_STRING,\n  TK_CODE_POINT,\n  TK_ANYCHAR,\n  TK_CHAR_TYPE,\n  TK_BACKREF,\n  TK_CALL,\n  TK_ANCHOR,\n  TK_OP_REPEAT,\n  TK_INTERVAL,\n  TK_ANYCHAR_ANYTIME,  /* SQL '%' == .* */\n  TK_ALT,\n  TK_SUBEXP_OPEN,\n  TK_SUBEXP_CLOSE,\n  TK_CC_OPEN,\n  TK_QUOTE_OPEN,\n  TK_CHAR_PROPERTY,    /* \\p{...}, \\P{...} */\n  /* in cc */\n  TK_CC_CLOSE,\n  TK_CC_RANGE,\n  TK_POSIX_BRACKET_OPEN,\n  TK_CC_AND,             /* && */\n  TK_CC_CC_OPEN          /* [ */\n};\n\ntypedef struct {\n  enum TokenSyms type;\n  int escaped;\n  int base;   /* is number: 8, 16 (used in [....]) */\n  UChar* backp;\n  union {\n    UChar* s;\n    int   c;\n    OnigCodePoint code;\n    int   anchor;\n    int   subtype;\n    struct {\n      int lower;\n      int upper;\n      int greedy;\n      int possessive;\n    } repeat;\n    struct {\n      int  num;\n      int  ref1;\n      int* refs;\n      int  by_name;\n#ifdef USE_BACKREF_WITH_LEVEL\n      int  exist_level;\n      int  level;   /* \\k<name+n> */\n#endif\n    } backref;\n    struct {\n      UChar* name;\n      UChar* name_end;\n      int    gnum;\n    } call;\n    struct {\n      int ctype;\n      int not;\n    } prop;\n  } u;\n} OnigToken;\n\n\nstatic int\nfetch_range_quantifier(UChar** src, UChar* end, OnigToken* tok, ScanEnv* env)\n{\n  int low, up, syn_allow, non_low = 0;\n  int r = 0;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n  UChar* p = *src;\n  PFETCH_READY;\n\n  syn_allow = IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_INVALID_INTERVAL);\n\n  if (PEND) {\n    if (syn_allow)\n      return 1;  /* \"....{\" : OK! */\n    else\n      return ONIGERR_END_PATTERN_AT_LEFT_BRACE;  /* \"....{\" syntax error */\n  }\n\n  if (! syn_allow) {\n    c = PPEEK;\n    if (c == ')' || c == '(' || c == '|') {\n      return ONIGERR_END_PATTERN_AT_LEFT_BRACE;\n    }\n  }\n\n  low = onig_scan_unsigned_number(&p, end, env->enc);\n  if (low < 0) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;\n  if (low > ONIG_MAX_REPEAT_NUM)\n    return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;\n\n  if (p == *src) { /* can't read low */\n    if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_INTERVAL_LOW_ABBREV)) {\n      /* allow {,n} as {0,n} */\n      low = 0;\n      non_low = 1;\n    }\n    else\n      goto invalid;\n  }\n\n  if (PEND) goto invalid;\n  PFETCH(c);\n  if (c == ',') {\n    UChar* prev = p;\n    up = onig_scan_unsigned_number(&p, end, env->enc);\n    if (up < 0) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;\n    if (up > ONIG_MAX_REPEAT_NUM)\n      return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;\n\n    if (p == prev) {\n      if (non_low != 0)\n        goto invalid;\n      up = REPEAT_INFINITE;  /* {n,} : {n,infinite} */\n    }\n  }\n  else {\n    if (non_low != 0)\n      goto invalid;\n\n    PUNFETCH;\n    up = low;  /* {n} : exact n times */\n    r = 2;     /* fixed */\n  }\n\n  if (PEND) goto invalid;\n  PFETCH(c);\n  if (IS_SYNTAX_OP(env->syntax, ONIG_SYN_OP_ESC_BRACE_INTERVAL)) {\n    if (c != MC_ESC(env->syntax)) goto invalid;\n    PFETCH(c);\n  }\n  if (c != '}') goto invalid;\n\n  if (!IS_REPEAT_INFINITE(up) && low > up) {\n    return ONIGERR_UPPER_SMALLER_THAN_LOWER_IN_REPEAT_RANGE;\n  }\n\n  tok->type = TK_INTERVAL;\n  tok->u.repeat.lower = low;\n  tok->u.repeat.upper = up;\n  *src = p;\n  return r; /* 0: normal {n,m}, 2: fixed {n} */\n\n invalid:\n  if (syn_allow) {\n    /* *src = p; */ /* !!! Don't do this line !!! */\n    return 1;  /* OK */\n  }\n  else\n    return ONIGERR_INVALID_REPEAT_RANGE_PATTERN;\n}\n\n/* \\M-, \\C-, \\c, or \\... */\nstatic int\nfetch_escaped_value(UChar** src, UChar* end, ScanEnv* env, OnigCodePoint* val)\n{\n  int v;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n  UChar* p = *src;\n\n  if (PEND) return ONIGERR_END_PATTERN_AT_ESCAPE;\n\n  PFETCH_S(c);\n  switch (c) {\n  case 'M':\n    if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ESC_CAPITAL_M_BAR_META)) {\n      if (PEND) return ONIGERR_END_PATTERN_AT_META;\n      PFETCH_S(c);\n      if (c != '-') return ONIGERR_META_CODE_SYNTAX;\n      if (PEND) return ONIGERR_END_PATTERN_AT_META;\n      PFETCH_S(c);\n      if (c == MC_ESC(env->syntax)) {\n        v = fetch_escaped_value(&p, end, env, &c);\n        if (v < 0) return v;\n      }\n      c = ((c & 0xff) | 0x80);\n    }\n    else\n      goto backslash;\n    break;\n\n  case 'C':\n    if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ESC_CAPITAL_C_BAR_CONTROL)) {\n      if (PEND) return ONIGERR_END_PATTERN_AT_CONTROL;\n      PFETCH_S(c);\n      if (c != '-') return ONIGERR_CONTROL_CODE_SYNTAX;\n      goto control;\n    }\n    else\n      goto backslash;\n\n  case 'c':\n    if (IS_SYNTAX_OP(env->syntax, ONIG_SYN_OP_ESC_C_CONTROL)) {\n    control:\n      if (PEND) return ONIGERR_END_PATTERN_AT_CONTROL;\n      PFETCH_S(c);\n      if (c == '?') {\n        c = 0177;\n      }\n      else {\n        if (c == MC_ESC(env->syntax)) {\n          v = fetch_escaped_value(&p, end, env, &c);\n          if (v < 0) return v;\n        }\n        c &= 0x9f;\n      }\n      break;\n    }\n    /* fall through */\n\n  default:\n    {\n    backslash:\n      c = conv_backslash_value(c, env);\n    }\n    break;\n  }\n\n  *src = p;\n  *val = c;\n  return 0;\n}\n\nstatic int fetch_token(OnigToken* tok, UChar** src, UChar* end, ScanEnv* env);\n\nstatic OnigCodePoint\nget_name_end_code_point(OnigCodePoint start)\n{\n  switch (start) {\n  case '<':  return (OnigCodePoint )'>'; break;\n  case '\\'': return (OnigCodePoint )'\\''; break;\n  default:\n    break;\n  }\n\n  return (OnigCodePoint )0;\n}\n\n#ifdef USE_NAMED_GROUP\n#ifdef USE_BACKREF_WITH_LEVEL\n/*\n   \\k<name+n>, \\k<name-n>\n   \\k<num+n>,  \\k<num-n>\n   \\k<-num+n>, \\k<-num-n>\n*/\nstatic int\nfetch_name_with_level(OnigCodePoint start_code, UChar** src, UChar* end,\n\t\t      UChar** rname_end, ScanEnv* env,\n\t\t      int* rback_num, int* rlevel)\n{\n  int r, sign, is_num, exist_level;\n  OnigCodePoint end_code;\n  OnigCodePoint c = 0;\n  OnigEncoding enc = env->enc;\n  UChar *name_end;\n  UChar *pnum_head;\n  UChar *p = *src;\n  PFETCH_READY;\n\n  *rback_num = 0;\n  is_num = exist_level = 0;\n  sign = 1;\n  pnum_head = *src;\n\n  end_code = get_name_end_code_point(start_code);\n\n  name_end = end;\n  r = 0;\n  if (PEND) {\n    return ONIGERR_EMPTY_GROUP_NAME;\n  }\n  else {\n    PFETCH(c);\n    if (c == end_code)\n      return ONIGERR_EMPTY_GROUP_NAME;\n\n    if (ONIGENC_IS_CODE_DIGIT(enc, c)) {\n      is_num = 1;\n    }\n    else if (c == '-') {\n      is_num = 2;\n      sign = -1;\n      pnum_head = p;\n    }\n    else if (!ONIGENC_IS_CODE_WORD(enc, c)) {\n      r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n    }\n  }\n\n  while (!PEND) {\n    name_end = p;\n    PFETCH(c);\n    if (c == end_code || c == ')' || c == '+' || c == '-') {\n      if (is_num == 2) \tr = ONIGERR_INVALID_GROUP_NAME;\n      break;\n    }\n\n    if (is_num != 0) {\n      if (ONIGENC_IS_CODE_DIGIT(enc, c)) {\n        is_num = 1;\n      }\n      else {\n        r = ONIGERR_INVALID_GROUP_NAME;\n        is_num = 0;\n      }\n    }\n    else if (!ONIGENC_IS_CODE_WORD(enc, c)) {\n      r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n    }\n  }\n\n  if (r == 0 && c != end_code) {\n    if (c == '+' || c == '-') {\n      int level;\n      int flag = (c == '-' ? -1 : 1);\n\n      if (PEND) {\n\tr = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n\tgoto end;\n      }\n      PFETCH(c);\n      if (! ONIGENC_IS_CODE_DIGIT(enc, c)) goto err;\n      PUNFETCH;\n      level = onig_scan_unsigned_number(&p, end, enc);\n      if (level < 0) return ONIGERR_TOO_BIG_NUMBER;\n      *rlevel = (level * flag);\n      exist_level = 1;\n\n      if (!PEND) {\n\tPFETCH(c);\n\tif (c == end_code)\n\t  goto end;\n      }\n    }\n\n  err:\n    r = ONIGERR_INVALID_GROUP_NAME;\n    name_end = end;\n  }\n\n end:\n  if (r == 0) {\n    if (is_num != 0) {\n      *rback_num = onig_scan_unsigned_number(&pnum_head, name_end, enc);\n      if (*rback_num < 0) return ONIGERR_TOO_BIG_NUMBER;\n      else if (*rback_num == 0) goto err;\n\n      *rback_num *= sign;\n    }\n\n    *rname_end = name_end;\n    *src = p;\n    return (exist_level ? 1 : 0);\n  }\n  else {\n    onig_scan_env_set_error_string(env, r, *src, name_end);\n    return r;\n  }\n}\n#endif /* USE_BACKREF_WITH_LEVEL */\n\n/*\n  ref: 0 -> define name    (don't allow number name)\n       1 -> reference name (allow number name)\n*/\nstatic int\nfetch_name(OnigCodePoint start_code, UChar** src, UChar* end,\n\t   UChar** rname_end, ScanEnv* env, int* rback_num, int ref)\n{\n  int r, is_num, sign;\n  OnigCodePoint end_code;\n  OnigCodePoint c = 0;\n  OnigEncoding enc = env->enc;\n  UChar *name_end;\n  UChar *pnum_head;\n  UChar *p = *src;\n\n  *rback_num = 0;\n\n  end_code = get_name_end_code_point(start_code);\n\n  name_end = end;\n  pnum_head = *src;\n  r = 0;\n  is_num = 0;\n  sign = 1;\n  if (PEND) {\n    return ONIGERR_EMPTY_GROUP_NAME;\n  }\n  else {\n    PFETCH_S(c);\n    if (c == end_code)\n      return ONIGERR_EMPTY_GROUP_NAME;\n\n    if (ONIGENC_IS_CODE_DIGIT(enc, c)) {\n      if (ref == 1)\n        is_num = 1;\n      else {\n        r = ONIGERR_INVALID_GROUP_NAME;\n        is_num = 0;\n      }\n    }\n    else if (c == '-') {\n      if (ref == 1) {\n        is_num = 2;\n        sign = -1;\n        pnum_head = p;\n      }\n      else {\n        r = ONIGERR_INVALID_GROUP_NAME;\n        is_num = 0;\n      }\n    }\n    else if (!ONIGENC_IS_CODE_WORD(enc, c)) {\n      r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n    }\n  }\n\n  if (r == 0) {\n    while (!PEND) {\n      name_end = p;\n      PFETCH_S(c);\n      if (c == end_code || c == ')') {\n        if (is_num == 2) \tr = ONIGERR_INVALID_GROUP_NAME;\n        break;\n      }\n\n      if (is_num != 0) {\n        if (ONIGENC_IS_CODE_DIGIT(enc, c)) {\n          is_num = 1;\n        }\n        else {\n          if (!ONIGENC_IS_CODE_WORD(enc, c))\n            r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n          else\n            r = ONIGERR_INVALID_GROUP_NAME;\n          is_num = 0;\n        }\n      }\n      else {\n        if (!ONIGENC_IS_CODE_WORD(enc, c)) {\n          r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n        }\n      }\n    }\n\n    if (c != end_code) {\n      r = ONIGERR_INVALID_GROUP_NAME;\n      name_end = end;\n    }\n\n    if (is_num != 0) {\n      *rback_num = onig_scan_unsigned_number(&pnum_head, name_end, enc);\n      if (*rback_num < 0) return ONIGERR_TOO_BIG_NUMBER;\n      else if (*rback_num == 0) {\n        r = ONIGERR_INVALID_GROUP_NAME;\n        goto err;\n      }\n\n      *rback_num *= sign;\n    }\n\n    *rname_end = name_end;\n    *src = p;\n    return 0;\n  }\n  else {\n    while (!PEND) {\n      name_end = p;\n      PFETCH_S(c);\n      if (c == end_code || c == ')')\n        break;\n    }\n    if (PEND)\n      name_end = end;\n\n  err:\n    onig_scan_env_set_error_string(env, r, *src, name_end);\n    return r;\n  }\n}\n#else\nstatic int\nfetch_name(OnigCodePoint start_code, UChar** src, UChar* end,\n\t   UChar** rname_end, ScanEnv* env, int* rback_num, int ref)\n{\n  int r, is_num, sign;\n  OnigCodePoint end_code;\n  OnigCodePoint c = 0;\n  UChar *name_end;\n  OnigEncoding enc = env->enc;\n  UChar *pnum_head;\n  UChar *p = *src;\n  PFETCH_READY;\n\n  *rback_num = 0;\n\n  end_code = get_name_end_code_point(start_code);\n\n  *rname_end = name_end = end;\n  r = 0;\n  pnum_head = *src;\n  is_num = 0;\n  sign = 1;\n\n  if (PEND) {\n    return ONIGERR_EMPTY_GROUP_NAME;\n  }\n  else {\n    PFETCH(c);\n    if (c == end_code)\n      return ONIGERR_EMPTY_GROUP_NAME;\n\n    if (ONIGENC_IS_CODE_DIGIT(enc, c)) {\n      is_num = 1;\n    }\n    else if (c == '-') {\n      is_num = 2;\n      sign = -1;\n      pnum_head = p;\n    }\n    else {\n      r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n    }\n  }\n\n  while (!PEND) {\n    name_end = p;\n\n    PFETCH(c);\n    if (c == end_code || c == ')') break;\n    if (! ONIGENC_IS_CODE_DIGIT(enc, c))\n      r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n  }\n  if (r == 0 && c != end_code) {\n    r = ONIGERR_INVALID_GROUP_NAME;\n    name_end = end;\n  }\n\n  if (r == 0) {\n    *rback_num = onig_scan_unsigned_number(&pnum_head, name_end, enc);\n    if (*rback_num < 0) return ONIGERR_TOO_BIG_NUMBER;\n    else if (*rback_num == 0) {\n      r = ONIGERR_INVALID_GROUP_NAME;\n      goto err;\n    }\n    *rback_num *= sign;\n\n    *rname_end = name_end;\n    *src = p;\n    return 0;\n  }\n  else {\n  err:\n    onig_scan_env_set_error_string(env, r, *src, name_end);\n    return r;\n  }\n}\n#endif /* USE_NAMED_GROUP */\n\nstatic void\nCC_ESC_WARN(ScanEnv* env, UChar *c)\n{\n  if (onig_warn == onig_null_warn) return ;\n\n  if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_WARN_CC_OP_NOT_ESCAPED) &&\n      IS_SYNTAX_BV(env->syntax, ONIG_SYN_BACKSLASH_ESCAPE_IN_CC)) {\n    UChar buf[WARN_BUFSIZE];\n    onig_snprintf_with_pattern(buf, WARN_BUFSIZE, env->enc,\n\t\tenv->pattern, env->pattern_end,\n                (UChar* )\"character class has '%s' without escape\", c);\n    (*onig_warn)((char* )buf);\n  }\n}\n\nstatic void\nCLOSE_BRACKET_WITHOUT_ESC_WARN(ScanEnv* env, UChar* c)\n{\n  if (onig_warn == onig_null_warn) return ;\n\n  if (IS_SYNTAX_BV((env)->syntax, ONIG_SYN_WARN_CC_OP_NOT_ESCAPED)) {\n    UChar buf[WARN_BUFSIZE];\n    onig_snprintf_with_pattern(buf, WARN_BUFSIZE, (env)->enc,\n\t\t(env)->pattern, (env)->pattern_end,\n\t\t(UChar* )\"regular expression has '%s' without escape\", c);\n    (*onig_warn)((char* )buf);\n  }\n}\n\nstatic UChar*\nfind_str_position(OnigCodePoint s[], int n, UChar* from, UChar* to,\n\t\t  UChar **next, OnigEncoding enc)\n{\n  int i;\n  OnigCodePoint x;\n  UChar *q;\n  UChar *p = from;\n  \n  while (p < to) {\n    x = ONIGENC_MBC_TO_CODE(enc, p, to);\n    q = p + enclen(enc, p);\n    if (x == s[0]) {\n      for (i = 1; i < n && q < to; i++) {\n        x = ONIGENC_MBC_TO_CODE(enc, q, to);\n        if (x != s[i]) break;\n        q += enclen(enc, q);\n      }\n      if (i >= n) {\n        if (IS_NOT_NULL(next))\n          *next = q;\n        return p;\n      }\n    }\n    p = q;\n  }\n  return NULL_UCHARP;\n}\n\nstatic int\nstr_exist_check_with_esc(OnigCodePoint s[], int n, UChar* from, UChar* to,\n\t\t OnigCodePoint bad, OnigEncoding enc, OnigSyntaxType* syn)\n{\n  int i, in_esc;\n  OnigCodePoint x;\n  UChar *q;\n  UChar *p = from;\n\n  in_esc = 0;\n  while (p < to) {\n    if (in_esc) {\n      in_esc = 0;\n      p += enclen(enc, p);\n    }\n    else {\n      x = ONIGENC_MBC_TO_CODE(enc, p, to);\n      q = p + enclen(enc, p);\n      if (x == s[0]) {\n        for (i = 1; i < n && q < to; i++) {\n          x = ONIGENC_MBC_TO_CODE(enc, q, to);\n          if (x != s[i]) break;\n          q += enclen(enc, q);\n        }\n        if (i >= n) return 1;\n        p += enclen(enc, p);\n      }\n      else {\n        x = ONIGENC_MBC_TO_CODE(enc, p, to);\n        if (x == bad) return 0;\n        else if (x == MC_ESC(syn)) in_esc = 1;\n        p = q;\n      }\n    }\n  }\n  return 0;\n}\n\nstatic int\nfetch_token_in_cc(OnigToken* tok, UChar** src, UChar* end, ScanEnv* env)\n{\n  int num;\n  OnigCodePoint c, c2;\n  OnigSyntaxType* syn = env->syntax;\n  OnigEncoding enc = env->enc;\n  UChar* prev;\n  UChar* p = *src;\n  PFETCH_READY;\n\n  if (PEND) {\n    tok->type = TK_EOT;\n    return tok->type;\n  }\n\n  PFETCH(c);\n  tok->type = TK_CHAR;\n  tok->base = 0;\n  tok->u.c  = c;\n  tok->escaped = 0;\n\n  if (c == ']') {\n    tok->type = TK_CC_CLOSE;\n  }\n  else if (c == '-') {\n    tok->type = TK_CC_RANGE;\n  }\n  else if (c == MC_ESC(syn)) {\n    if (! IS_SYNTAX_BV(syn, ONIG_SYN_BACKSLASH_ESCAPE_IN_CC))\n      goto end;\n\n    if (PEND) return ONIGERR_END_PATTERN_AT_ESCAPE;\n\n    PFETCH(c);\n    tok->escaped = 1;\n    tok->u.c = c;\n    switch (c) {\n    case 'w':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;\n      tok->u.prop.not   = 0;\n      break;\n    case 'W':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;\n      tok->u.prop.not   = 1;\n      break;\n    case 'd':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;\n      tok->u.prop.not   = 0;\n      break;\n    case 'D':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;\n      tok->u.prop.not   = 1;\n      break;\n    case 's':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;\n      tok->u.prop.not   = 0;\n      break;\n    case 'S':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;\n      tok->u.prop.not   = 1;\n      break;\n    case 'h':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;\n      tok->u.prop.not   = 0;\n      break;\n    case 'H':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'p':\n    case 'P':\n      if (PEND) break;\n\n      c2 = PPEEK;\n      if (c2 == '{' &&\n          IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY)) {\n        PINC;\n        tok->type = TK_CHAR_PROPERTY;\n        tok->u.prop.not = (c == 'P' ? 1 : 0);\n\n        if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT)) {\n          PFETCH(c2);\n          if (c2 == '^') {\n            tok->u.prop.not = (tok->u.prop.not == 0 ? 1 : 0);\n          }\n          else\n            PUNFETCH;\n        }\n      }\n      break;\n\n    case 'o':\n      if (PEND) break;\n\n      prev = p;\n      if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_O_BRACE_OCTAL)) {\n        PINC;\n        num = scan_unsigned_octal_number(&p, end, 11, enc);\n        if (num < 0) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n        if (!PEND) {\n          c2 = PPEEK;\n          if (ONIGENC_IS_CODE_DIGIT(enc, c2))\n            return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;\n        }\n\n        if (p > prev + enclen(enc, prev) && !PEND && (PPEEK_IS('}'))) {\n          PINC;\n          tok->type   = TK_CODE_POINT;\n          tok->base   = 8;\n          tok->u.code = (OnigCodePoint )num;\n        }\n        else {\n          /* can't read nothing or invalid format */\n          p = prev;\n        }\n      }\n      break;\n\n    case 'x':\n      if (PEND) break;\n\n      prev = p;\n      if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_BRACE_HEX8)) {\n        PINC;\n        num = scan_unsigned_hexadecimal_number(&p, end, 8, enc);\n        if (num < 0) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n        if (!PEND) {\n          c2 = PPEEK;\n          if (ONIGENC_IS_CODE_XDIGIT(enc, c2))\n            return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;\n        }\n\n        if (p > prev + enclen(enc, prev) && !PEND && (PPEEK_IS('}'))) {\n          PINC;\n          tok->type   = TK_CODE_POINT;\n          tok->base   = 16;\n          tok->u.code = (OnigCodePoint )num;\n        }\n        else {\n          /* can't read nothing or invalid format */\n          p = prev;\n        }\n      }\n      else if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_HEX2)) {\n        num = scan_unsigned_hexadecimal_number(&p, end, 2, enc);\n        if (num < 0) return ONIGERR_TOO_BIG_NUMBER;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type = TK_RAW_BYTE;\n        tok->base = 16;\n        tok->u.c  = num;\n      }\n      break;\n\n    case 'u':\n      if (PEND) break;\n\n      prev = p;\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_U_HEX4)) {\n        num = scan_unsigned_hexadecimal_number(&p, end, 4, enc);\n        if (num < 0) return ONIGERR_TOO_BIG_NUMBER;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type   = TK_CODE_POINT;\n        tok->base   = 16;\n        tok->u.code = (OnigCodePoint )num;\n      }\n      break;\n\n    case '0':\n    case '1': case '2': case '3': case '4': case '5': case '6': case '7':\n      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_OCTAL3)) {\n        PUNFETCH;\n        prev = p;\n        num = scan_unsigned_octal_number(&p, end, 3, enc);\n        if (num < 0 || num >= 256) return ONIGERR_TOO_BIG_NUMBER;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type = TK_RAW_BYTE;\n        tok->base = 8;\n        tok->u.c  = num;\n      }\n      break;\n\n    default:\n      PUNFETCH;\n      num = fetch_escaped_value(&p, end, env, &c2);\n      if (num < 0) return num;\n      if (tok->u.c != c2) {\n        tok->u.code = c2;\n        tok->type   = TK_CODE_POINT;\n      }\n      break;\n    }\n  }\n  else if (c == '[') {\n    if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_POSIX_BRACKET) && (PPEEK_IS(':'))) {\n      OnigCodePoint send[] = { (OnigCodePoint )':', (OnigCodePoint )']' };\n      tok->backp = p; /* point at '[' is read */\n      PINC;\n      if (str_exist_check_with_esc(send, 2, p, end,\n                                   (OnigCodePoint )']', enc, syn)) {\n        tok->type = TK_POSIX_BRACKET_OPEN;\n      }\n      else {\n        PUNFETCH;\n        goto cc_in_cc;\n      }\n    }\n    else {\n    cc_in_cc:\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_CCLASS_SET_OP)) {\n        tok->type = TK_CC_CC_OPEN;\n      }\n      else {\n        CC_ESC_WARN(env, (UChar* )\"[\");\n      }\n    }\n  }\n  else if (c == '&') {\n    if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_CCLASS_SET_OP) &&\n        !PEND && (PPEEK_IS('&'))) {\n      PINC;\n      tok->type = TK_CC_AND;\n    }\n  }\n\n end:\n  *src = p;\n  return tok->type;\n}\n\nstatic int\nfetch_token(OnigToken* tok, UChar** src, UChar* end, ScanEnv* env)\n{\n  int r, num;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n  OnigSyntaxType* syn = env->syntax;\n  UChar* prev;\n  UChar* p = *src;\n  PFETCH_READY;\n\n start:\n  if (PEND) {\n    tok->type = TK_EOT;\n    return tok->type;\n  }\n\n  tok->type  = TK_STRING;\n  tok->base  = 0;\n  tok->backp = p;\n\n  PFETCH(c);\n  if (IS_MC_ESC_CODE(c, syn)) {\n    if (PEND) return ONIGERR_END_PATTERN_AT_ESCAPE;\n\n    tok->backp = p;\n    PFETCH(c);\n\n    tok->u.c = c;\n    tok->escaped = 1;\n    switch (c) {\n    case '*':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_ASTERISK_ZERO_INF)) break;\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = REPEAT_INFINITE;\n      goto greedy_check;\n      break;\n\n    case '+':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_PLUS_ONE_INF)) break;\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 1;\n      tok->u.repeat.upper = REPEAT_INFINITE;\n      goto greedy_check;\n      break;\n\n    case '?':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_QMARK_ZERO_ONE)) break;\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = 1;\n    greedy_check:\n      if (!PEND && PPEEK_IS('?') &&\n\t  IS_SYNTAX_OP(syn, ONIG_SYN_OP_QMARK_NON_GREEDY)) {\n        PFETCH(c);\n        tok->u.repeat.greedy     = 0;\n        tok->u.repeat.possessive = 0;\n      }\n      else {\n      possessive_check:\n        if (!PEND && PPEEK_IS('+') &&\n            ((IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_PLUS_POSSESSIVE_REPEAT) &&\n              tok->type != TK_INTERVAL)  ||\n             (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_PLUS_POSSESSIVE_INTERVAL) &&\n              tok->type == TK_INTERVAL))) {\n          PFETCH(c);\n          tok->u.repeat.greedy     = 1;\n          tok->u.repeat.possessive = 1;\n        }\n        else {\n          tok->u.repeat.greedy     = 1;\n          tok->u.repeat.possessive = 0;\n        }\n      }\n      break;\n\n    case '{':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_BRACE_INTERVAL)) break;\n      r = fetch_range_quantifier(&p, end, tok, env);\n      if (r < 0) return r;  /* error */\n      if (r == 0) goto greedy_check;\n      else if (r == 2) { /* {n} */\n        if (IS_SYNTAX_BV(syn, ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY))\n          goto possessive_check;\n\n        goto greedy_check;\n      }\n      /* r == 1 : normal char */\n      break;\n\n    case '|':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_VBAR_ALT)) break;\n      tok->type = TK_ALT;\n      break;\n\n    case '(':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_OPEN;\n      break;\n\n    case ')':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_CLOSE;\n      break;\n\n    case 'w':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_W_WORD)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'W':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_W_WORD)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'b':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_B_WORD_BOUND)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor = ANCHOR_WORD_BOUND;\n      break;\n\n    case 'B':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_B_WORD_BOUND)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor = ANCHOR_NOT_WORD_BOUND;\n      break;\n\n#ifdef USE_WORD_BEGIN_END\n    case '<':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor = ANCHOR_WORD_BEGIN;\n      break;\n\n    case '>':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor = ANCHOR_WORD_END;\n      break;\n#endif\n\n    case 's':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_S_WHITE_SPACE)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'S':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_S_WHITE_SPACE)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'd':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_D_DIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'D':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_D_DIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'h':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'H':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'A':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;\n    begin_buf:\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = ANCHOR_BEGIN_BUF;\n      break;\n\n    case 'Z':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = ANCHOR_SEMI_END_BUF;\n      break;\n\n    case 'z':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;\n    end_buf:\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = ANCHOR_END_BUF;\n      break;\n\n    case 'G':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_CAPITAL_G_BEGIN_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = ANCHOR_BEGIN_POSITION;\n      break;\n\n    case '`':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR)) break;\n      goto begin_buf;\n      break;\n\n    case '\\'':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR)) break;\n      goto end_buf;\n      break;\n\n    case 'o':\n      if (PEND) break;\n\n      prev = p;\n      if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_O_BRACE_OCTAL)) {\n        PINC;\n        num = scan_unsigned_octal_number(&p, end, 11, enc);\n        if (num < 0) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n        if (!PEND) {\n          if (ONIGENC_IS_CODE_DIGIT(enc, PPEEK))\n            return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;\n        }\n\n        if ((p > prev + enclen(enc, prev)) && !PEND && PPEEK_IS('}')) {\n          PINC;\n          tok->type   = TK_CODE_POINT;\n          tok->u.code = (OnigCodePoint )num;\n        }\n        else {\n          /* can't read nothing or invalid format */\n          p = prev;\n        }\n      }\n      break;\n\n    case 'x':\n      if (PEND) break;\n\n      prev = p;\n      if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_BRACE_HEX8)) {\n        PINC;\n        num = scan_unsigned_hexadecimal_number(&p, end, 8, enc);\n        if (num < 0) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n        if (!PEND) {\n          if (ONIGENC_IS_CODE_XDIGIT(enc, PPEEK))\n            return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;\n        }\n\n        if ((p > prev + enclen(enc, prev)) && !PEND && PPEEK_IS('}')) {\n          PINC;\n          tok->type   = TK_CODE_POINT;\n          tok->u.code = (OnigCodePoint )num;\n        }\n        else {\n          /* can't read nothing or invalid format */\n          p = prev;\n        }\n      }\n      else if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_HEX2)) {\n        num = scan_unsigned_hexadecimal_number(&p, end, 2, enc);\n        if (num < 0) return ONIGERR_TOO_BIG_NUMBER;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type = TK_RAW_BYTE;\n        tok->base = 16;\n        tok->u.c  = num;\n      }\n      break;\n\n    case 'u':\n      if (PEND) break;\n\n      prev = p;\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_U_HEX4)) {\n        num = scan_unsigned_hexadecimal_number(&p, end, 4, enc);\n        if (num < 0) return ONIGERR_TOO_BIG_NUMBER;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type   = TK_CODE_POINT;\n        tok->base   = 16;\n        tok->u.code = (OnigCodePoint )num;\n      }\n      break;\n\n    case '1': case '2': case '3': case '4':\n    case '5': case '6': case '7': case '8': case '9':\n      PUNFETCH;\n      prev = p;\n      num = onig_scan_unsigned_number(&p, end, enc);\n      if (num < 0 || num > ONIG_MAX_BACKREF_NUM) {\n        goto skip_backref;\n      }\n\n      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_DECIMAL_BACKREF) && \n          (num <= env->num_mem || num <= 9)) { /* This spec. from GNU regex */\n        if (IS_SYNTAX_BV(syn, ONIG_SYN_STRICT_CHECK_BACKREF)) {\n          if (num > env->num_mem || IS_NULL(SCANENV_MEM_NODES(env)[num]))\n            return ONIGERR_INVALID_BACKREF;\n        }\n\n        tok->type = TK_BACKREF;\n        tok->u.backref.num     = 1;\n        tok->u.backref.ref1    = num;\n        tok->u.backref.by_name = 0;\n#ifdef USE_BACKREF_WITH_LEVEL\n        tok->u.backref.exist_level = 0;\n#endif\n        break;\n      }\n\n    skip_backref:\n      if (c == '8' || c == '9') {\n        /* normal char */\n        p = prev; PINC;\n        break;\n      }\n\n      p = prev;\n      /* fall through */\n    case '0':\n      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_OCTAL3)) {\n        prev = p;\n        num = scan_unsigned_octal_number(&p, end, (c == '0' ? 2:3), enc);\n        if (num < 0 || num >= 256) return ONIGERR_TOO_BIG_NUMBER;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type = TK_RAW_BYTE;\n        tok->base = 8;\n        tok->u.c  = num;\n      }\n      else if (c != '0') {\n        PINC;\n      }\n      break;\n\n#ifdef USE_NAMED_GROUP\n    case 'k':\n      if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_K_NAMED_BACKREF)) {\n        PFETCH(c);\n        if (c == '<' || c == '\\'') {\n          UChar* name_end;\n          int* backs;\n          int back_num;\n\n          prev = p;\n\n#ifdef USE_BACKREF_WITH_LEVEL\n          name_end = NULL_UCHARP; /* no need. escape gcc warning. */\n          r = fetch_name_with_level((OnigCodePoint )c, &p, end, &name_end,\n                                    env, &back_num, &tok->u.backref.level);\n          if (r == 1) tok->u.backref.exist_level = 1;\n          else        tok->u.backref.exist_level = 0;\n#else\n          r = fetch_name(&p, end, &name_end, env, &back_num, 1);\n#endif\n          if (r < 0) return r;\n\n          if (back_num != 0) {\n            if (back_num < 0) {\n              back_num = BACKREF_REL_TO_ABS(back_num, env);\n              if (back_num <= 0)\n                return ONIGERR_INVALID_BACKREF;\n            }\n\n            if (IS_SYNTAX_BV(syn, ONIG_SYN_STRICT_CHECK_BACKREF)) {\n              if (back_num > env->num_mem ||\n                  IS_NULL(SCANENV_MEM_NODES(env)[back_num]))\n                return ONIGERR_INVALID_BACKREF;\n            }\n            tok->type = TK_BACKREF;\n            tok->u.backref.by_name = 0;\n            tok->u.backref.num  = 1;\n            tok->u.backref.ref1 = back_num;\n          }\n          else {\n            num = onig_name_to_group_numbers(env->reg, prev, name_end, &backs);\n            if (num <= 0) {\n              onig_scan_env_set_error_string(env,\n                        ONIGERR_UNDEFINED_NAME_REFERENCE, prev, name_end);\n              return ONIGERR_UNDEFINED_NAME_REFERENCE;\n            }\n            if (IS_SYNTAX_BV(syn, ONIG_SYN_STRICT_CHECK_BACKREF)) {\n              int i;\n              for (i = 0; i < num; i++) {\n                if (backs[i] > env->num_mem ||\n                    IS_NULL(SCANENV_MEM_NODES(env)[backs[i]]))\n                  return ONIGERR_INVALID_BACKREF;\n              }\n            }\n\n            tok->type = TK_BACKREF;\n            tok->u.backref.by_name = 1;\n            if (num == 1) {\n              tok->u.backref.num  = 1;\n              tok->u.backref.ref1 = backs[0];\n            }\n            else {\n              tok->u.backref.num  = num;\n              tok->u.backref.refs = backs;\n            }\n          }\n        }\n        else\n          PUNFETCH;\n      }\n      break;\n#endif\n\n#ifdef USE_SUBEXP_CALL\n    case 'g':\n      if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_G_SUBEXP_CALL)) {\n        PFETCH(c);\n        if (c == '<' || c == '\\'') {\n          int gnum;\n          UChar* name_end;\n\n          prev = p;\n          r = fetch_name((OnigCodePoint )c, &p, end, &name_end, env, &gnum, 1);\n          if (r < 0) return r;\n\n          tok->type = TK_CALL;\n          tok->u.call.name     = prev;\n          tok->u.call.name_end = name_end;\n          tok->u.call.gnum     = gnum;\n        }\n        else\n          PUNFETCH;\n      }\n      break;\n#endif\n\n    case 'Q':\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_Q_QUOTE)) {\n        tok->type = TK_QUOTE_OPEN;\n      }\n      break;\n\n    case 'p':\n    case 'P':\n      if (!PEND && PPEEK_IS('{') &&\n          IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY)) {\n        PINC;\n        tok->type = TK_CHAR_PROPERTY;\n        tok->u.prop.not = (c == 'P' ? 1 : 0);\n\n        if (!PEND &&\n            IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT)) {\n          PFETCH(c);\n          if (c == '^') {\n            tok->u.prop.not = (tok->u.prop.not == 0 ? 1 : 0);\n          }\n          else\n            PUNFETCH;\n        }\n      }\n      break;\n\n    default:\n      {\n        OnigCodePoint c2;\n\n        PUNFETCH;\n        num = fetch_escaped_value(&p, end, env, &c2);\n        if (num < 0) return num;\n        /* set_raw: */\n        if (tok->u.c != c2) {\n          tok->type = TK_CODE_POINT;\n          tok->u.code = c2;\n        }\n        else { /* string */\n          p = tok->backp + enclen(enc, tok->backp);\n\t}\n      }\n      break;\n    }\n  }\n  else {\n    tok->u.c = c;\n    tok->escaped = 0;\n\n#ifdef USE_VARIABLE_META_CHARS\n    if ((c != ONIG_INEFFECTIVE_META_CHAR) &&\n        IS_SYNTAX_OP(syn, ONIG_SYN_OP_VARIABLE_META_CHARACTERS)) {\n      if (c == MC_ANYCHAR(syn))\n        goto any_char;\n      else if (c == MC_ANYTIME(syn))\n        goto anytime;\n      else if (c == MC_ZERO_OR_ONE_TIME(syn))\n        goto zero_or_one_time;\n      else if (c == MC_ONE_OR_MORE_TIME(syn))\n        goto one_or_more_time;\n      else if (c == MC_ANYCHAR_ANYTIME(syn)) {\n        tok->type = TK_ANYCHAR_ANYTIME;\n        goto out;\n      }\n    }\n#endif\n\n    switch (c) {\n    case '.':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_DOT_ANYCHAR)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    any_char:\n#endif\n      tok->type = TK_ANYCHAR;\n      break;\n\n    case '*':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ASTERISK_ZERO_INF)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    anytime:\n#endif\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = REPEAT_INFINITE;\n      goto greedy_check;\n      break;\n\n    case '+':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_PLUS_ONE_INF)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    one_or_more_time:\n#endif\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 1;\n      tok->u.repeat.upper = REPEAT_INFINITE;\n      goto greedy_check;\n      break;\n\n    case '?':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_QMARK_ZERO_ONE)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    zero_or_one_time:\n#endif\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = 1;\n      goto greedy_check;\n      break;\n\n    case '{':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_BRACE_INTERVAL)) break;\n      r = fetch_range_quantifier(&p, end, tok, env);\n      if (r < 0) return r;  /* error */\n      if (r == 0) goto greedy_check;\n      else if (r == 2) { /* {n} */\n        if (IS_SYNTAX_BV(syn, ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY))\n          goto possessive_check;\n\n        goto greedy_check;\n      }\n      /* r == 1 : normal char */\n      break;\n\n    case '|':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_VBAR_ALT)) break;\n      tok->type = TK_ALT;\n      break;\n\n    case '(':\n      if (!PEND && PPEEK_IS('?') &&\n          IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_QMARK_GROUP_EFFECT)) {\n        PINC;\n        if (!PEND && PPEEK_IS('#')) {\n          PFETCH(c);\n          while (1) {\n            if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n            PFETCH(c);\n            if (c == MC_ESC(syn)) {\n              if (!PEND) PFETCH(c);\n            }\n            else {\n              if (c == ')') break;\n            }\n          }\n          goto start;\n        }\n        PUNFETCH;\n      }\n\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_OPEN;\n      break;\n\n    case ')':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_CLOSE;\n      break;\n\n    case '^':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LINE_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = (IS_SINGLELINE(env->option)\n\t\t\t? ANCHOR_BEGIN_BUF : ANCHOR_BEGIN_LINE);\n      break;\n\n    case '$':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LINE_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.subtype = (IS_SINGLELINE(env->option)\n\t\t\t? ANCHOR_SEMI_END_BUF : ANCHOR_END_LINE);\n      break;\n\n    case '[':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_BRACKET_CC)) break;\n      tok->type = TK_CC_OPEN;\n      break;\n\n    case ']':\n      if (*src > env->pattern)   /* /].../ is allowed. */\n        CLOSE_BRACKET_WITHOUT_ESC_WARN(env, (UChar* )\"]\");\n      break;\n\n    case '#':\n      if (IS_EXTEND(env->option)) {\n        while (!PEND) {\n          PFETCH(c);\n          if (ONIGENC_IS_CODE_NEWLINE(enc, c))\n            break;\n        }\n        goto start;\n        break;\n      }\n      break;\n\n    case ' ': case '\\t': case '\\n': case '\\r': case '\\f':\n      if (IS_EXTEND(env->option))\n        goto start;\n      break;\n\n    default:\n      /* string */\n      break;\n    }\n  }\n\n#ifdef USE_VARIABLE_META_CHARS\n out:\n#endif\n  *src = p;\n  return tok->type;\n}\n\nstatic int\nadd_ctype_to_cc_by_range(CClassNode* cc, int ctype ARG_UNUSED, int not,\n\t\t\t OnigEncoding enc ARG_UNUSED,\n                         OnigCodePoint sb_out, const OnigCodePoint mbr[])\n{\n  int i, r;\n  OnigCodePoint j;\n\n  int n = ONIGENC_CODE_RANGE_NUM(mbr);\n\n  if (not == 0) {\n    for (i = 0; i < n; i++) {\n      for (j  = ONIGENC_CODE_RANGE_FROM(mbr, i);\n           j <= ONIGENC_CODE_RANGE_TO(mbr, i); j++) {\n        if (j >= sb_out) {\n          if (j > ONIGENC_CODE_RANGE_FROM(mbr, i)) {\n            r = add_code_range_to_buf(&(cc->mbuf), j,\n                                      ONIGENC_CODE_RANGE_TO(mbr, i));\n            if (r != 0) return r;\n            i++;\n          }\n\n          goto sb_end;\n        }\n        BITSET_SET_BIT(cc->bs, j);\n      }\n    }\n\n  sb_end:\n    for ( ; i < n; i++) {\n      r = add_code_range_to_buf(&(cc->mbuf),\n                                ONIGENC_CODE_RANGE_FROM(mbr, i),\n                                ONIGENC_CODE_RANGE_TO(mbr, i));\n      if (r != 0) return r;\n    }\n  }\n  else {\n    OnigCodePoint prev = 0;\n\n    for (i = 0; i < n; i++) {\n      for (j = prev;\n\t   j < ONIGENC_CODE_RANGE_FROM(mbr, i); j++) {\n        if (j >= sb_out) {\n          goto sb_end2;\n        }\n        BITSET_SET_BIT(cc->bs, j);\n      }\n      prev = ONIGENC_CODE_RANGE_TO(mbr, i) + 1;\n    }\n    for (j = prev; j < sb_out; j++) {\n      BITSET_SET_BIT(cc->bs, j);\n    }\n\n  sb_end2:\n    prev = sb_out;\n\n    for (i = 0; i < n; i++) {\n      if (prev < ONIGENC_CODE_RANGE_FROM(mbr, i)) {\n        r = add_code_range_to_buf(&(cc->mbuf), prev,\n                                  ONIGENC_CODE_RANGE_FROM(mbr, i) - 1);\n        if (r != 0) return r;\n      }\n      prev = ONIGENC_CODE_RANGE_TO(mbr, i) + 1;\n    }\n    if (prev < 0x7fffffff) {\n      r = add_code_range_to_buf(&(cc->mbuf), prev, 0x7fffffff);\n      if (r != 0) return r;\n    }\n  }\n\n  return 0;\n}\n\nstatic int\nadd_ctype_to_cc(CClassNode* cc, int ctype, int not, ScanEnv* env)\n{\n  int c, r;\n  const OnigCodePoint *ranges;\n  OnigCodePoint sb_out;\n  OnigEncoding enc = env->enc;\n\n  r = ONIGENC_GET_CTYPE_CODE_RANGE(enc, ctype, &sb_out, &ranges);\n  if (r == 0) {\n    return add_ctype_to_cc_by_range(cc, ctype, not, env->enc, sb_out, ranges);\n  }\n  else if (r != ONIG_NO_SUPPORT_CONFIG) {\n    return r;\n  }\n\n  r = 0;\n  switch (ctype) {\n  case ONIGENC_CTYPE_ALPHA:\n  case ONIGENC_CTYPE_BLANK:\n  case ONIGENC_CTYPE_CNTRL:\n  case ONIGENC_CTYPE_DIGIT:\n  case ONIGENC_CTYPE_LOWER:\n  case ONIGENC_CTYPE_PUNCT:\n  case ONIGENC_CTYPE_SPACE:\n  case ONIGENC_CTYPE_UPPER:\n  case ONIGENC_CTYPE_XDIGIT:\n  case ONIGENC_CTYPE_ASCII:\n  case ONIGENC_CTYPE_ALNUM:\n    if (not != 0) {\n      for (c = 0; c < SINGLE_BYTE_SIZE; c++) {\n        if (! ONIGENC_IS_CODE_CTYPE(enc, (OnigCodePoint )c, ctype))\n          BITSET_SET_BIT(cc->bs, c);\n      }\n      ADD_ALL_MULTI_BYTE_RANGE(enc, cc->mbuf);\n    }\n    else {\n      for (c = 0; c < SINGLE_BYTE_SIZE; c++) {\n        if (ONIGENC_IS_CODE_CTYPE(enc, (OnigCodePoint )c, ctype))\n          BITSET_SET_BIT(cc->bs, c);\n      }\n    }\n    break;\n\n  case ONIGENC_CTYPE_GRAPH:\n  case ONIGENC_CTYPE_PRINT:\n    if (not != 0) {\n      for (c = 0; c < SINGLE_BYTE_SIZE; c++) {\n        if (! ONIGENC_IS_CODE_CTYPE(enc, (OnigCodePoint )c, ctype))\n          BITSET_SET_BIT(cc->bs, c);\n      }\n    }\n    else {\n      for (c = 0; c < SINGLE_BYTE_SIZE; c++) {\n        if (ONIGENC_IS_CODE_CTYPE(enc, (OnigCodePoint )c, ctype))\n          BITSET_SET_BIT(cc->bs, c);\n      }\n      ADD_ALL_MULTI_BYTE_RANGE(enc, cc->mbuf);\n    }\n    break;\n\n  case ONIGENC_CTYPE_WORD:\n    if (not == 0) {\n      for (c = 0; c < SINGLE_BYTE_SIZE; c++) {\n        if (IS_CODE_SB_WORD(enc, c)) BITSET_SET_BIT(cc->bs, c);\n      }\n      ADD_ALL_MULTI_BYTE_RANGE(enc, cc->mbuf);\n    }\n    else {\n      for (c = 0; c < SINGLE_BYTE_SIZE; c++) {\n        if ((ONIGENC_CODE_TO_MBCLEN(enc, c) > 0) /* check invalid code point */\n            && ! ONIGENC_IS_CODE_WORD(enc, c))\n          BITSET_SET_BIT(cc->bs, c);\n      }\n    }\n    break;\n\n  default:\n    return ONIGERR_PARSER_BUG;\n    break;\n  }\n\n  return r;\n}\n\nstatic int\nparse_posix_bracket(CClassNode* cc, UChar** src, UChar* end, ScanEnv* env)\n{\n#define POSIX_BRACKET_CHECK_LIMIT_LENGTH  20\n#define POSIX_BRACKET_NAME_MIN_LEN         4\n\n  static PosixBracketEntryType PBS[] = {\n    { (UChar* )\"alnum\",  ONIGENC_CTYPE_ALNUM,  5 },\n    { (UChar* )\"alpha\",  ONIGENC_CTYPE_ALPHA,  5 },\n    { (UChar* )\"blank\",  ONIGENC_CTYPE_BLANK,  5 },\n    { (UChar* )\"cntrl\",  ONIGENC_CTYPE_CNTRL,  5 },\n    { (UChar* )\"digit\",  ONIGENC_CTYPE_DIGIT,  5 },\n    { (UChar* )\"graph\",  ONIGENC_CTYPE_GRAPH,  5 },\n    { (UChar* )\"lower\",  ONIGENC_CTYPE_LOWER,  5 },\n    { (UChar* )\"print\",  ONIGENC_CTYPE_PRINT,  5 },\n    { (UChar* )\"punct\",  ONIGENC_CTYPE_PUNCT,  5 },\n    { (UChar* )\"space\",  ONIGENC_CTYPE_SPACE,  5 },\n    { (UChar* )\"upper\",  ONIGENC_CTYPE_UPPER,  5 },\n    { (UChar* )\"xdigit\", ONIGENC_CTYPE_XDIGIT, 6 },\n    { (UChar* )\"ascii\",  ONIGENC_CTYPE_ASCII,  5 },\n    { (UChar* )\"word\",   ONIGENC_CTYPE_WORD,   4 },\n    { (UChar* )NULL,     -1, 0 }\n  };\n\n  PosixBracketEntryType *pb;\n  int not, i, r;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n  UChar *p = *src;\n\n  if (PPEEK_IS('^')) {\n    PINC_S;\n    not = 1;\n  }\n  else\n    not = 0;\n\n  if (onigenc_strlen(enc, p, end) < POSIX_BRACKET_NAME_MIN_LEN + 3)\n    goto not_posix_bracket;\n\n  for (pb = PBS; IS_NOT_NULL(pb->name); pb++) {\n    if (onigenc_with_ascii_strncmp(enc, p, end, pb->name, pb->len) == 0) {\n      p = (UChar* )onigenc_step(enc, p, end, pb->len);\n      if (onigenc_with_ascii_strncmp(enc, p, end, (UChar* )\":]\", 2) != 0)\n        return ONIGERR_INVALID_POSIX_BRACKET_TYPE;\n\n      r = add_ctype_to_cc(cc, pb->ctype, not, env);\n      if (r != 0) return r;\n\n      PINC_S; PINC_S;\n      *src = p;\n      return 0;\n    }\n  }\n\n not_posix_bracket:\n  c = 0;\n  i = 0;\n  while (!PEND && ((c = PPEEK) != ':') && c != ']') {\n    PINC_S;\n    if (++i > POSIX_BRACKET_CHECK_LIMIT_LENGTH) break;\n  }\n  if (c == ':' && ! PEND) {\n    PINC_S;\n    if (! PEND) {\n      PFETCH_S(c);\n      if (c == ']')\n        return ONIGERR_INVALID_POSIX_BRACKET_TYPE;\n    }\n  }\n\n  return 1;  /* 1: is not POSIX bracket, but no error. */\n}\n\nstatic int\nfetch_char_property_to_ctype(UChar** src, UChar* end, ScanEnv* env)\n{\n  int r;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n  UChar *prev, *start, *p = *src;\n\n  r = 0;\n  start = prev = p;\n\n  while (!PEND) {\n    prev = p;\n    PFETCH_S(c);\n    if (c == '}') {\n      r = ONIGENC_PROPERTY_NAME_TO_CTYPE(enc, start, prev);\n      if (r < 0) break;\n\n      *src = p;\n      return r;\n    }\n    else if (c == '(' || c == ')' || c == '{' || c == '|') {\n      r = ONIGERR_INVALID_CHAR_PROPERTY_NAME;\n      break;\n    }\n  }\n\n  onig_scan_env_set_error_string(env, r, *src, prev);\n  return r;\n}\n\nstatic int\nparse_char_property(Node** np, OnigToken* tok, UChar** src, UChar* end,\n\t\t    ScanEnv* env)\n{\n  int r, ctype;\n  CClassNode* cc;\n\n  ctype = fetch_char_property_to_ctype(src, end, env);\n  if (ctype < 0) return ctype;\n\n  *np = node_new_cclass();\n  CHECK_NULL_RETURN_MEMERR(*np);\n  cc = NCCLASS(*np);\n  r = add_ctype_to_cc(cc, ctype, 0, env);\n  if (r != 0) return r;\n  if (tok->u.prop.not != 0) NCCLASS_SET_NOT(cc);\n\n  return 0;\n}\n\n\nenum CCSTATE {\n  CCS_VALUE,\n  CCS_RANGE,\n  CCS_COMPLETE,\n  CCS_START\n};\n\nenum CCVALTYPE {\n  CCV_SB,\n  CCV_CODE_POINT,\n  CCV_CLASS\n};\n\nstatic int\nnext_state_class(CClassNode* cc, OnigCodePoint* vs, enum CCVALTYPE* type,\n\t\t enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n\n  if (*state == CCS_RANGE)\n    return ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE;\n\n  if (*state == CCS_VALUE && *type != CCV_CLASS) {\n    if (*type == CCV_SB)\n      BITSET_SET_BIT(cc->bs, (int )(*vs));\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *vs, *vs);\n      if (r < 0) return r;\n    }\n  }\n\n  if (*state != CCS_START)\n    *state = CCS_VALUE;\n\n  *type  = CCV_CLASS;\n  return 0;\n}\n\nstatic int\nnext_state_val(CClassNode* cc, OnigCodePoint *vs, OnigCodePoint v,\n\t       int* vs_israw, int v_israw,\n\t       enum CCVALTYPE intype, enum CCVALTYPE* type,\n\t       enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n\n  switch (*state) {\n  case CCS_VALUE:\n    if (*type == CCV_SB) {\n      if (*vs > 0xff)\n          return ONIGERR_INVALID_CODE_POINT_VALUE;\n\n      BITSET_SET_BIT(cc->bs, (int )(*vs));\n    }\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *vs, *vs);\n      if (r < 0) return r;\n    }\n    break;\n\n  case CCS_RANGE:\n    if (intype == *type) {\n      if (intype == CCV_SB) {\n        if (*vs > 0xff || v > 0xff)\n          return ONIGERR_INVALID_CODE_POINT_VALUE;\n\n        if (*vs > v) {\n          if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n            goto ccs_range_end;\n          else\n            return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n        }\n        bitset_set_range(cc->bs, (int )*vs, (int )v);\n      }\n      else {\n        r = add_code_range(&(cc->mbuf), env, *vs, v);\n        if (r < 0) return r;\n      }\n    }\n    else {\n#if 0\n      if (intype == CCV_CODE_POINT && *type == CCV_SB) {\n#endif\n        if (*vs > v) {\n          if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n            goto ccs_range_end;\n          else\n            return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n        }\n        bitset_set_range(cc->bs, (int )*vs, (int )(v < 0xff ? v : 0xff));\n        r = add_code_range(&(cc->mbuf), env, (OnigCodePoint )*vs, v);\n        if (r < 0) return r;\n#if 0\n      }\n      else\n        return ONIGERR_MISMATCH_CODE_LENGTH_IN_CLASS_RANGE;\n#endif\n    }\n  ccs_range_end:\n    *state = CCS_COMPLETE;\n    break;\n\n  case CCS_COMPLETE:\n  case CCS_START:\n    *state = CCS_VALUE;\n    break;\n\n  default:\n    break;\n  }\n\n  *vs_israw = v_israw;\n  *vs       = v;\n  *type     = intype;\n  return 0;\n}\n\nstatic int\ncode_exist_check(OnigCodePoint c, UChar* from, UChar* end, int ignore_escaped,\n\t\t ScanEnv* env)\n{\n  int in_esc;\n  OnigCodePoint code;\n  OnigEncoding enc = env->enc;\n  UChar* p = from;\n\n  in_esc = 0;\n  while (! PEND) {\n    if (ignore_escaped && in_esc) {\n      in_esc = 0;\n    }\n    else {\n      PFETCH_S(code);\n      if (code == c) return 1;\n      if (code == MC_ESC(env->syntax)) in_esc = 1;\n    }\n  }\n  return 0;\n}\n\nstatic int\nparse_char_class(Node** np, OnigToken* tok, UChar** src, UChar* end,\n\t\t ScanEnv* env)\n{\n  int r, neg, len, fetched, and_start;\n  OnigCodePoint v, vs;\n  UChar *p;\n  Node* node;\n  CClassNode *cc, *prev_cc;\n  CClassNode work_cc;\n\n  enum CCSTATE state;\n  enum CCVALTYPE val_type, in_type;\n  int val_israw, in_israw;\n\n  *np = NULL_NODE;\n  env->parse_depth++;\n  if (env->parse_depth > ParseDepthLimit)\n    return ONIGERR_PARSE_DEPTH_LIMIT_OVER;\n  prev_cc = (CClassNode* )NULL;\n  r = fetch_token_in_cc(tok, src, end, env);\n  if (r == TK_CHAR && tok->u.c == '^' && tok->escaped == 0) {\n    neg = 1;\n    r = fetch_token_in_cc(tok, src, end, env);\n  }\n  else {\n    neg = 0;\n  }\n\n  if (r < 0) return r;\n  if (r == TK_CC_CLOSE) {\n    if (! code_exist_check((OnigCodePoint )']',\n                           *src, env->pattern_end, 1, env))\n      return ONIGERR_EMPTY_CHAR_CLASS;\n\n    CC_ESC_WARN(env, (UChar* )\"]\");\n    r = tok->type = TK_CHAR;  /* allow []...] */\n  }\n\n  *np = node = node_new_cclass();\n  CHECK_NULL_RETURN_MEMERR(node);\n  cc = NCCLASS(node);\n\n  and_start = 0;\n  state = CCS_START;\n  p = *src;\n  while (r != TK_CC_CLOSE) {\n    fetched = 0;\n    switch (r) {\n    case TK_CHAR:\n    any_char_in:\n      len = ONIGENC_CODE_TO_MBCLEN(env->enc, tok->u.c);\n      if (len > 1) {\n        in_type = CCV_CODE_POINT;\n      }\n      else if (len < 0) {\n        r = len;\n        goto err;\n      }\n      else {\n        /* sb_char: */\n        in_type = CCV_SB;\n      }\n      v = (OnigCodePoint )tok->u.c;\n      in_israw = 0;\n      goto val_entry2;\n      break;\n\n    case TK_RAW_BYTE:\n      /* tok->base != 0 : octal or hexadec. */\n      if (! ONIGENC_IS_SINGLEBYTE(env->enc) && tok->base != 0) {\n        UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];\n        UChar* bufe = buf + ONIGENC_CODE_TO_MBC_MAXLEN;\n        UChar* psave = p;\n        int i, base = tok->base;\n\n        buf[0] = tok->u.c;\n        for (i = 1; i < ONIGENC_MBC_MAXLEN(env->enc); i++) {\n          r = fetch_token_in_cc(tok, &p, end, env);\n          if (r < 0) goto err;\n          if (r != TK_RAW_BYTE || tok->base != base) {\n            fetched = 1;\n            break;\n          }\n          buf[i] = tok->u.c;\n        }\n\n        if (i < ONIGENC_MBC_MINLEN(env->enc)) {\n          r = ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;\n          goto err;\n        }\n\n        len = enclen(env->enc, buf);\n        if (i < len) {\n          r = ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;\n          goto err;\n        }\n        else if (i > len) { /* fetch back */\n          p = psave;\n          for (i = 1; i < len; i++) {\n            r = fetch_token_in_cc(tok, &p, end, env);\n          }\n          fetched = 0;\n        }\n\n        if (i == 1) {\n          v = (OnigCodePoint )buf[0];\n          goto raw_single;\n        }\n        else {\n          v = ONIGENC_MBC_TO_CODE(env->enc, buf, bufe);\n          in_type = CCV_CODE_POINT;\n        }\n      }\n      else {\n        v = (OnigCodePoint )tok->u.c;\n      raw_single:\n        in_type = CCV_SB;\n      }\n      in_israw = 1;\n      goto val_entry2;\n      break;\n\n    case TK_CODE_POINT:\n      v = tok->u.code;\n      in_israw = 1;\n    val_entry:\n      len = ONIGENC_CODE_TO_MBCLEN(env->enc, v);\n      if (len < 0) {\n        r = len;\n        goto err;\n      }\n      in_type = (len == 1 ? CCV_SB : CCV_CODE_POINT);\n    val_entry2:\n      r = next_state_val(cc, &vs, v, &val_israw, in_israw, in_type, &val_type,\n\t\t\t &state, env);\n      if (r != 0) goto err;\n      break;\n\n    case TK_POSIX_BRACKET_OPEN:\n      r = parse_posix_bracket(cc, &p, end, env);\n      if (r < 0) goto err;\n      if (r == 1) {  /* is not POSIX bracket */\n        CC_ESC_WARN(env, (UChar* )\"[\");\n        p = tok->backp;\n        v = (OnigCodePoint )tok->u.c;\n        in_israw = 0;\n        goto val_entry;\n      }\n      goto next_class;\n      break;\n\n    case TK_CHAR_TYPE:\n      r = add_ctype_to_cc(cc, tok->u.prop.ctype, tok->u.prop.not, env);\n      if (r != 0) return r;\n\n    next_class:\n      r = next_state_class(cc, &vs, &val_type, &state, env);\n      if (r != 0) goto err;\n      break;\n\n    case TK_CHAR_PROPERTY:\n      {\n        int ctype;\n\n        ctype = fetch_char_property_to_ctype(&p, end, env);\n        if (ctype < 0) return ctype;\n        r = add_ctype_to_cc(cc, ctype, tok->u.prop.not, env);\n        if (r != 0) return r;\n        goto next_class;\n      }\n      break;\n\n    case TK_CC_RANGE:\n      if (state == CCS_VALUE) {\n        r = fetch_token_in_cc(tok, &p, end, env);\n        if (r < 0) goto err;\n        fetched = 1;\n        if (r == TK_CC_CLOSE) { /* allow [x-] */\n        range_end_val:\n          v = (OnigCodePoint )'-';\n          in_israw = 0;\n          goto val_entry;\n        }\n        else if (r == TK_CC_AND) {\n          CC_ESC_WARN(env, (UChar* )\"-\");\n          goto range_end_val;\n        }\n        state = CCS_RANGE;\n      }\n      else if (state == CCS_START) {\n        /* [-xa] is allowed */\n        v = (OnigCodePoint )tok->u.c;\n        in_israw = 0;\n\n        r = fetch_token_in_cc(tok, &p, end, env);\n        if (r < 0) goto err;\n        fetched = 1;\n        /* [--x] or [a&&-x] is warned. */\n        if (r == TK_CC_RANGE || and_start != 0)\n          CC_ESC_WARN(env, (UChar* )\"-\");\n\n        goto val_entry;\n      }\n      else if (state == CCS_RANGE) {\n        CC_ESC_WARN(env, (UChar* )\"-\");\n        goto any_char_in;  /* [!--x] is allowed */\n      }\n      else { /* CCS_COMPLETE */\n        r = fetch_token_in_cc(tok, &p, end, env);\n        if (r < 0) goto err;\n        fetched = 1;\n        if (r == TK_CC_CLOSE) goto range_end_val; /* allow [a-b-] */\n        else if (r == TK_CC_AND) {\n          CC_ESC_WARN(env, (UChar* )\"-\");\n          goto range_end_val;\n        }\n\t\n        if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_DOUBLE_RANGE_OP_IN_CC)) {\n          CC_ESC_WARN(env, (UChar* )\"-\");\n          goto range_end_val;   /* [0-9-a] is allowed as [0-9\\-a] */\n        }\n        r = ONIGERR_UNMATCHED_RANGE_SPECIFIER_IN_CHAR_CLASS;\n        goto err;\n      }\n      break;\n\n    case TK_CC_CC_OPEN: /* [ */\n      {\n        Node *anode;\n        CClassNode* acc;\n\n        r = parse_char_class(&anode, tok, &p, end, env);\n        if (r != 0) {\n          onig_node_free(anode);\n          goto cc_open_err;\n        }\n        acc = NCCLASS(anode);\n        r = or_cclass(cc, acc, env->enc);\n\n        onig_node_free(anode);\n      cc_open_err:\n        if (r != 0) goto err;\n      }\n      break;\n\n    case TK_CC_AND: /* && */\n      {\n        if (state == CCS_VALUE) {\n          r = next_state_val(cc, &vs, 0, &val_israw, 0, val_type,\n                             &val_type, &state, env);\n          if (r != 0) goto err;\n        }\n        /* initialize local variables */\n        and_start = 1;\n        state = CCS_START;\n\n        if (IS_NOT_NULL(prev_cc)) {\n          r = and_cclass(prev_cc, cc, env->enc);\n          if (r != 0) goto err;\n          bbuf_free(cc->mbuf);\n        }\n        else {\n          prev_cc = cc;\n          cc = &work_cc;\n        }\n        initialize_cclass(cc);\n      }\n      break;\n\n    case TK_EOT:\n      r = ONIGERR_PREMATURE_END_OF_CHAR_CLASS;\n      goto err;\n      break;\n    default:\n      r = ONIGERR_PARSER_BUG;\n      goto err;\n      break;\n    }\n\n    if (fetched)\n      r = tok->type;\n    else {\n      r = fetch_token_in_cc(tok, &p, end, env);\n      if (r < 0) goto err;\n    }\n  }\n\n  if (state == CCS_VALUE) {\n    r = next_state_val(cc, &vs, 0, &val_israw, 0, val_type,\n\t\t       &val_type, &state, env);\n    if (r != 0) goto err;\n  }\n\n  if (IS_NOT_NULL(prev_cc)) {\n    r = and_cclass(prev_cc, cc, env->enc);\n    if (r != 0) goto err;\n    bbuf_free(cc->mbuf);\n    cc = prev_cc;\n  }\n\n  if (neg != 0)\n    NCCLASS_SET_NOT(cc);\n  else\n    NCCLASS_CLEAR_NOT(cc);\n  if (IS_NCCLASS_NOT(cc) &&\n      IS_SYNTAX_BV(env->syntax, ONIG_SYN_NOT_NEWLINE_IN_NEGATIVE_CC)) {\n    int is_empty;\n\n    is_empty = (IS_NULL(cc->mbuf) ? 1 : 0);\n    if (is_empty != 0)\n      BITSET_IS_EMPTY(cc->bs, is_empty);\n\n    if (is_empty == 0) {\n#define NEWLINE_CODE    0x0a\n\n      if (ONIGENC_IS_CODE_NEWLINE(env->enc, NEWLINE_CODE)) {\n        if (ONIGENC_CODE_TO_MBCLEN(env->enc, NEWLINE_CODE) == 1)\n          BITSET_SET_BIT(cc->bs, NEWLINE_CODE);\n        else\n          add_code_range(&(cc->mbuf), env, NEWLINE_CODE, NEWLINE_CODE);\n      }\n    }\n  }\n  *src = p;\n  env->parse_depth--;\n  return 0;\n\n err:\n  if (cc != NCCLASS(*np))\n    bbuf_free(cc->mbuf);\n  return r;\n}\n\nstatic int parse_subexp(Node** top, OnigToken* tok, int term,\n\t\t\tUChar** src, UChar* end, ScanEnv* env);\n\nstatic int\nparse_enclose(Node** np, OnigToken* tok, int term, UChar** src, UChar* end,\n\t      ScanEnv* env)\n{\n  int r, num;\n  Node *target;\n  OnigOptionType option;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n\n#ifdef USE_NAMED_GROUP\n  int list_capture;\n#endif\n\n  UChar* p = *src;\n  PFETCH_READY;\n\n  *np = NULL;\n  if (PEND) return ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS;\n\n  option = env->option;\n  if (PPEEK_IS('?') &&\n      IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_GROUP_EFFECT)) {\n    PINC;\n    if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n\n    PFETCH(c);\n    switch (c) {\n    case ':':   /* (?:...) grouping only */\n    group:\n      r = fetch_token(tok, &p, end, env);\n      if (r < 0) return r;\n      r = parse_subexp(np, tok, term, &p, end, env);\n      if (r < 0) return r;\n      *src = p;\n      return 1; /* group */\n      break;\n\n    case '=':\n      *np = onig_node_new_anchor(ANCHOR_PREC_READ);\n      break;\n    case '!':  /*         preceding read */\n      *np = onig_node_new_anchor(ANCHOR_PREC_READ_NOT);\n      break;\n    case '>':            /* (?>...) stop backtrack */\n      *np = node_new_enclose(ENCLOSE_STOP_BACKTRACK);\n      break;\n\n#ifdef USE_NAMED_GROUP\n    case '\\'':\n      if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP)) {\n        goto named_group1;\n      }\n      else\n        return ONIGERR_UNDEFINED_GROUP_OPTION;\n      break;\n#endif\n\n    case '<':   /* look behind (?<=...), (?<!...) */\n      if (PEND) return ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS;\n      PFETCH(c);\n      if (c == '=')\n        *np = onig_node_new_anchor(ANCHOR_LOOK_BEHIND);\n      else if (c == '!')\n        *np = onig_node_new_anchor(ANCHOR_LOOK_BEHIND_NOT);\n#ifdef USE_NAMED_GROUP\n      else {\n        if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP)) {\n          UChar *name;\n          UChar *name_end;\n\n          PUNFETCH;\n          c = '<';\n\n        named_group1:\n          list_capture = 0;\n\n        named_group2:\n          name = p;\n          r = fetch_name((OnigCodePoint )c, &p, end, &name_end, env, &num, 0);\n          if (r < 0) return r;\n\n          num = scan_env_add_mem_entry(env);\n          if (num < 0) return num;\n          if (list_capture != 0 && num >= (int )BIT_STATUS_BITS_NUM)\n            return ONIGERR_GROUP_NUMBER_OVER_FOR_CAPTURE_HISTORY;\n\n          r = name_add(env->reg, name, name_end, num, env);\n          if (r != 0) return r;\n          *np = node_new_enclose_memory(env->option, 1);\n          CHECK_NULL_RETURN_MEMERR(*np);\n          NENCLOSE(*np)->regnum = num;\n          if (list_capture != 0)\n            BIT_STATUS_ON_AT_SIMPLE(env->capture_history, num);\n          env->num_named++;\n        }\n        else {\n          return ONIGERR_UNDEFINED_GROUP_OPTION;\n        }\n      }\n#else\n      else {\n        return ONIGERR_UNDEFINED_GROUP_OPTION;\n      }\n#endif\n      break;\n\n    case '@':\n      if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ATMARK_CAPTURE_HISTORY)) {\n#ifdef USE_NAMED_GROUP\n        if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP)) {\n          PFETCH(c);\n          if (c == '<' || c == '\\'') {\n            list_capture = 1;\n            goto named_group2; /* (?@<name>...) */\n          }\n          PUNFETCH;\n        }\n#endif\n        *np = node_new_enclose_memory(env->option, 0);\n        CHECK_NULL_RETURN_MEMERR(*np);\n        num = scan_env_add_mem_entry(env);\n        if (num < 0) {\n          return num;\n        }\n        else if (num >= (int )BIT_STATUS_BITS_NUM) {\n          return ONIGERR_GROUP_NUMBER_OVER_FOR_CAPTURE_HISTORY;\n        }\n        NENCLOSE(*np)->regnum = num;\n        BIT_STATUS_ON_AT_SIMPLE(env->capture_history, num);\n      }\n      else {\n        return ONIGERR_UNDEFINED_GROUP_OPTION;\n      }\n      break;\n\n#ifdef USE_POSIXLINE_OPTION\n    case 'p':\n#endif\n    case '-': case 'i': case 'm': case 's': case 'x':\n      {\n        int neg = 0;\n\n        while (1) {\n          switch (c) {\n          case ':':\n          case ')':\n            break;\n\n          case '-':  neg = 1; break;\n          case 'x':  ONOFF(option, ONIG_OPTION_EXTEND,     neg); break;\n          case 'i':  ONOFF(option, ONIG_OPTION_IGNORECASE, neg); break;\n          case 's':\n            if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_PERL)) {\n              ONOFF(option, ONIG_OPTION_MULTILINE,  neg);\n            }\n            else\n              return ONIGERR_UNDEFINED_GROUP_OPTION;\n            break;\n\n          case 'm':\n            if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_PERL)) {\n              ONOFF(option, ONIG_OPTION_SINGLELINE, (neg == 0 ? 1 : 0));\n            }\n            else if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_RUBY)) {\n              ONOFF(option, ONIG_OPTION_MULTILINE,  neg);\n            }\n            else\n              return ONIGERR_UNDEFINED_GROUP_OPTION;\n            break;\n#ifdef USE_POSIXLINE_OPTION\n          case 'p':\n            ONOFF(option, ONIG_OPTION_MULTILINE|ONIG_OPTION_SINGLELINE, neg);\n            break;\n#endif\n          default:\n            return ONIGERR_UNDEFINED_GROUP_OPTION;\n          }\n\n          if (c == ')') {\n            *np = node_new_option(option);\n            CHECK_NULL_RETURN_MEMERR(*np);\n            *src = p;\n            return 2; /* option only */\n          }\n          else if (c == ':') {\n            OnigOptionType prev = env->option;\n\n            env->option     = option;\n            r = fetch_token(tok, &p, end, env);\n            if (r < 0) return r;\n            r = parse_subexp(&target, tok, term, &p, end, env);\n            env->option = prev;\n            if (r < 0) {\n              onig_node_free(target);\n              return r;\n            }\n            *np = node_new_option(option);\n            CHECK_NULL_RETURN_MEMERR(*np);\n            NENCLOSE(*np)->target = target;\n            *src = p;\n            return 0;\n          }\n\n          if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n          PFETCH(c);\n        }\n      }\n      break;\n\n    default:\n      return ONIGERR_UNDEFINED_GROUP_OPTION;\n    }\n  }\n  else {\n    if (ONIG_IS_OPTION_ON(env->option, ONIG_OPTION_DONT_CAPTURE_GROUP))\n      goto group;\n\n    *np = node_new_enclose_memory(env->option, 0);\n    CHECK_NULL_RETURN_MEMERR(*np);\n    num = scan_env_add_mem_entry(env);\n    if (num < 0) return num;\n    NENCLOSE(*np)->regnum = num;\n  }\n\n  CHECK_NULL_RETURN_MEMERR(*np);\n  r = fetch_token(tok, &p, end, env);\n  if (r < 0) return r;\n  r = parse_subexp(&target, tok, term, &p, end, env);\n  if (r < 0) {\n    onig_node_free(target);\n    return r;\n  }\n\n  if (NTYPE(*np) == NT_ANCHOR)\n    NANCHOR(*np)->target = target;\n  else {\n    NENCLOSE(*np)->target = target;\n    if (NENCLOSE(*np)->type == ENCLOSE_MEMORY) {\n      /* Don't move this to previous of parse_subexp() */\n      r = scan_env_set_mem_node(env, NENCLOSE(*np)->regnum, *np);\n      if (r != 0) return r;\n    }\n  }\n\n  *src = p;\n  return 0;\n}\n\nstatic const char* PopularQStr[] = {\n  \"?\", \"*\", \"+\", \"??\", \"*?\", \"+?\"\n};\n\nstatic const char* ReduceQStr[] = {\n  \"\", \"\", \"*\", \"*?\", \"??\", \"+ and ??\", \"+? and ?\"\n};\n\nstatic int\nset_quantifier(Node* qnode, Node* target, int group, ScanEnv* env)\n{\n  QtfrNode* qn;\n\n  qn = NQTFR(qnode);\n  if (qn->lower == 1 && qn->upper == 1) {\n    return 1;\n  }\n\n  switch (NTYPE(target)) {\n  case NT_STR:\n    if (! group) {\n      StrNode* sn = NSTR(target);\n      if (str_node_can_be_split(sn, env->enc)) {\n        Node* n = str_node_split_last_char(sn, env->enc);\n        if (IS_NOT_NULL(n)) {\n          qn->target = n;\n          return 2;\n        }\n      }\n    }\n    break;\n\n  case NT_QTFR:\n    { /* check redundant double repeat. */\n      /* verbose warn (?:.?)? etc... but not warn (.?)? etc... */\n      QtfrNode* qnt   = NQTFR(target);\n      int nestq_num   = popular_quantifier_num(qn);\n      int targetq_num = popular_quantifier_num(qnt);\n\n#ifdef USE_WARNING_REDUNDANT_NESTED_REPEAT_OPERATOR\n      if (!IS_QUANTIFIER_BY_NUMBER(qn) && !IS_QUANTIFIER_BY_NUMBER(qnt) &&\n          IS_SYNTAX_BV(env->syntax, ONIG_SYN_WARN_REDUNDANT_NESTED_REPEAT)) {\n        UChar buf[WARN_BUFSIZE];\n\n        switch(ReduceTypeTable[targetq_num][nestq_num]) {\n        case RQ_ASIS:\n          break;\n\n        case RQ_DEL:\n          if (onig_verb_warn != onig_null_warn) {\n            onig_snprintf_with_pattern(buf, WARN_BUFSIZE, env->enc,\n                                  env->pattern, env->pattern_end,\n                                  (UChar* )\"redundant nested repeat operator\");\n            (*onig_verb_warn)((char* )buf);\n          }\n          goto warn_exit;\n          break;\n\n        default:\n          if (onig_verb_warn != onig_null_warn) {\n            onig_snprintf_with_pattern(buf, WARN_BUFSIZE, env->enc,\n                                       env->pattern, env->pattern_end,\n            (UChar* )\"nested repeat operator %s and %s was replaced with '%s'\",\n            PopularQStr[targetq_num], PopularQStr[nestq_num],\n            ReduceQStr[ReduceTypeTable[targetq_num][nestq_num]]);\n            (*onig_verb_warn)((char* )buf);\n          }\n          goto warn_exit;\n          break;\n        }\n      }\n\n    warn_exit:\n#endif\n      if (targetq_num >= 0) {\n        if (nestq_num >= 0) {\n          onig_reduce_nested_quantifier(qnode, target);\n          goto q_exit;\n        }\n        else if (targetq_num == 1 || targetq_num == 2) { /* * or + */\n          /* (?:a*){n,m}, (?:a+){n,m} => (?:a*){n,n}, (?:a+){n,n} */\n          if (! IS_REPEAT_INFINITE(qn->upper) && qn->upper > 1 && qn->greedy) {\n            qn->upper = (qn->lower == 0 ? 1 : qn->lower);\n          }\n        }\n      }\n    }\n    break;\n\n  default:\n    break;\n  }\n\n  qn->target = target;\n q_exit:\n  return 0;\n}\n\n\n#ifndef CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS\nstatic int\nclear_not_flag_cclass(CClassNode* cc, OnigEncoding enc)\n{\n  BBuf *tbuf;\n  int r;\n\n  if (IS_NCCLASS_NOT(cc)) {\n    bitset_invert(cc->bs);\n\n    if (! ONIGENC_IS_SINGLEBYTE(enc)) {\n      r = not_code_range_buf(enc, cc->mbuf, &tbuf);\n      if (r != 0) return r;\n\n      bbuf_free(cc->mbuf);\n      cc->mbuf = tbuf;\n    }\n\n    NCCLASS_CLEAR_NOT(cc);\n  }\n\n  return 0;\n}\n#endif /* CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS */\n\ntypedef struct {\n  ScanEnv*    env;\n  CClassNode* cc;\n  Node*       alt_root;\n  Node**      ptail;\n} IApplyCaseFoldArg;\n\nstatic int\ni_apply_case_fold(OnigCodePoint from, OnigCodePoint to[],\n\t\t  int to_len, void* arg)\n{\n  IApplyCaseFoldArg* iarg;\n  ScanEnv* env;\n  CClassNode* cc;\n  BitSetRef bs;\n\n  iarg = (IApplyCaseFoldArg* )arg;\n  env = iarg->env;\n  cc  = iarg->cc;\n  bs = cc->bs;\n\n  if (to_len == 1) {\n    int is_in = onig_is_code_in_cc(env->enc, from, cc);\n#ifdef CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS\n    if ((is_in != 0 && !IS_NCCLASS_NOT(cc)) ||\n        (is_in == 0 &&  IS_NCCLASS_NOT(cc))) {\n      if (ONIGENC_MBC_MINLEN(env->enc) > 1 || *to >= SINGLE_BYTE_SIZE) {\n        add_code_range(&(cc->mbuf), env, *to, *to);\n      }\n      else {\n        BITSET_SET_BIT(bs, *to);\n      }\n    }\n#else\n    if (is_in != 0) {\n      if (ONIGENC_MBC_MINLEN(env->enc) > 1 || *to >= SINGLE_BYTE_SIZE) {\n        if (IS_NCCLASS_NOT(cc)) clear_not_flag_cclass(cc, env->enc);\n        add_code_range(&(cc->mbuf), env, *to, *to);\n      }\n      else {\n        if (IS_NCCLASS_NOT(cc)) {\n          BITSET_CLEAR_BIT(bs, *to);\n        }\n        else\n          BITSET_SET_BIT(bs, *to);\n      }\n    }\n#endif /* CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS */\n  }\n  else {\n    int r, i, len;\n    UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];\n    Node *snode = NULL_NODE;\n\n    if (onig_is_code_in_cc(env->enc, from, cc)\n#ifdef CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS\n\t&& !IS_NCCLASS_NOT(cc)\n#endif\n        ) {\n      for (i = 0; i < to_len; i++) {\n        len = ONIGENC_CODE_TO_MBC(env->enc, to[i], buf);\n        if (i == 0) {\n          snode = onig_node_new_str(buf, buf + len);\n          CHECK_NULL_RETURN_MEMERR(snode);\n\n          /* char-class expanded multi-char only\n             compare with string folded at match time. */\n          NSTRING_SET_AMBIG(snode);\n        }\n        else {\n          r = onig_node_str_cat(snode, buf, buf + len);\n          if (r < 0) {\n            onig_node_free(snode);\n            return r;\n          }\n        }\n      }\n\n      *(iarg->ptail) = onig_node_new_alt(snode, NULL_NODE);\n      CHECK_NULL_RETURN_MEMERR(*(iarg->ptail));\n      iarg->ptail = &(NCDR((*(iarg->ptail))));\n    }\n  }\n\n  return 0;\n}\n\nstatic int\nparse_exp(Node** np, OnigToken* tok, int term,\n\t  UChar** src, UChar* end, ScanEnv* env)\n{\n  int r, len, group = 0;\n  Node* qn;\n  Node** targetp;\n\n  *np = NULL;\n  if (tok->type == (enum TokenSyms )term)\n    goto end_of_token;\n\n  switch (tok->type) {\n  case TK_ALT:\n  case TK_EOT:\n  end_of_token:\n  *np = node_new_empty();\n  return tok->type;\n  break;\n\n  case TK_SUBEXP_OPEN:\n    r = parse_enclose(np, tok, TK_SUBEXP_CLOSE, src, end, env);\n    if (r < 0) return r;\n    if (r == 1) group = 1;\n    else if (r == 2) { /* option only */\n      Node* target;\n      OnigOptionType prev = env->option;\n\n      env->option = NENCLOSE(*np)->option;\n      r = fetch_token(tok, src, end, env);\n      if (r < 0) return r;\n      r = parse_subexp(&target, tok, term, src, end, env);\n      env->option = prev;\n      if (r < 0) {\n        onig_node_free(target);\n        return r;\n      }\n      NENCLOSE(*np)->target = target;\t\n      return tok->type;\n    }\n    break;\n\n  case TK_SUBEXP_CLOSE:\n    if (! IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_UNMATCHED_CLOSE_SUBEXP))\n      return ONIGERR_UNMATCHED_CLOSE_PARENTHESIS;\n\n    if (tok->escaped) goto tk_raw_byte;\n    else goto tk_byte;\n    break;\n\n  case TK_STRING:\n  tk_byte:\n    {\n      *np = node_new_str(tok->backp, *src);\n      CHECK_NULL_RETURN_MEMERR(*np);\n\n      while (1) {\n        r = fetch_token(tok, src, end, env);\n        if (r < 0) return r;\n        if (r != TK_STRING) break;\n\n        r = onig_node_str_cat(*np, tok->backp, *src);\n        if (r < 0) return r;\n      }\n\n    string_end:\n      targetp = np;\n      goto repeat;\n    }\n    break;\n\n  case TK_RAW_BYTE:\n  tk_raw_byte:\n    {\n      *np = node_new_str_raw_char((UChar )tok->u.c);\n      CHECK_NULL_RETURN_MEMERR(*np);\n      len = 1;\n      while (1) {\n        if (len >= ONIGENC_MBC_MINLEN(env->enc)) {\n          if (len == enclen(env->enc, NSTR(*np)->s)) {//should not enclen_end()\n            r = fetch_token(tok, src, end, env);\n            NSTRING_CLEAR_RAW(*np);\n            goto string_end;\n          }\n        }\n\n        r = fetch_token(tok, src, end, env);\n        if (r < 0) return r;\n        if (r != TK_RAW_BYTE) {\n          /* Don't use this, it is wrong for little endian encodings. */\n#ifdef USE_PAD_TO_SHORT_BYTE_CHAR\n          int rem;\n          if (len < ONIGENC_MBC_MINLEN(env->enc)) {\n            rem = ONIGENC_MBC_MINLEN(env->enc) - len;\n            (void )node_str_head_pad(NSTR(*np), rem, (UChar )0);\n            if (len + rem == enclen(env->enc, NSTR(*np)->s)) {\n              NSTRING_CLEAR_RAW(*np);\n              goto string_end;\n            }\n          }\n#endif\n          return ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;\n        }\n\n        r = node_str_cat_char(*np, (UChar )tok->u.c);\n        if (r < 0) return r;\n\n        len++;\n      }\n    }\n    break;\n\n  case TK_CODE_POINT:\n    {\n      UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];\n      int num = ONIGENC_CODE_TO_MBC(env->enc, tok->u.code, buf);\n      if (num < 0) return num;\n#ifdef NUMBERED_CHAR_IS_NOT_CASE_AMBIG\n      *np = node_new_str_raw(buf, buf + num);\n#else\n      *np = node_new_str(buf, buf + num);\n#endif\n      CHECK_NULL_RETURN_MEMERR(*np);\n    }\n    break;\n\n  case TK_QUOTE_OPEN:\n    {\n      OnigCodePoint end_op[2];\n      UChar *qstart, *qend, *nextp;\n\n      end_op[0] = (OnigCodePoint )MC_ESC(env->syntax);\n      end_op[1] = (OnigCodePoint )'E';\n      qstart = *src;\n      qend = find_str_position(end_op, 2, qstart, end, &nextp, env->enc);\n      if (IS_NULL(qend)) {\n        nextp = qend = end;\n      }\n      *np = node_new_str(qstart, qend);\n      CHECK_NULL_RETURN_MEMERR(*np);\n      *src = nextp;\n    }\n    break;\n\n  case TK_CHAR_TYPE:\n    {\n      switch (tok->u.prop.ctype) {\n      case ONIGENC_CTYPE_WORD:\n        *np = node_new_ctype(tok->u.prop.ctype, tok->u.prop.not);\n        CHECK_NULL_RETURN_MEMERR(*np);\n        break;\n\n      case ONIGENC_CTYPE_SPACE:\n      case ONIGENC_CTYPE_DIGIT:\n      case ONIGENC_CTYPE_XDIGIT:\n        {\n          CClassNode* cc;\n\n          *np = node_new_cclass();\n          CHECK_NULL_RETURN_MEMERR(*np);\n          cc = NCCLASS(*np);\n          add_ctype_to_cc(cc, tok->u.prop.ctype, 0, env);\n          if (tok->u.prop.not != 0) NCCLASS_SET_NOT(cc);\n        }\n        break;\n\n      default:\n        return ONIGERR_PARSER_BUG;\n        break;\n      }\n    }\n    break;\n\n  case TK_CHAR_PROPERTY:\n    r = parse_char_property(np, tok, src, end, env);\n    if (r != 0) return r;\n    break;\n\n  case TK_CC_OPEN:\n    {\n      CClassNode* cc;\n\n      r = parse_char_class(np, tok, src, end, env);\n      if (r != 0) return r;\n\n      cc = NCCLASS(*np);\n      if (IS_IGNORECASE(env->option)) {\n        IApplyCaseFoldArg iarg;\n\n        iarg.env      = env;\n        iarg.cc       = cc;\n        iarg.alt_root = NULL_NODE;\n        iarg.ptail    = &(iarg.alt_root);\n\n        r = ONIGENC_APPLY_ALL_CASE_FOLD(env->enc, env->case_fold_flag,\n                                        i_apply_case_fold, &iarg);\n        if (r != 0) {\n          onig_node_free(iarg.alt_root);\n          return r;\n        }\n        if (IS_NOT_NULL(iarg.alt_root)) {\n          Node* work = onig_node_new_alt(*np, iarg.alt_root);\n          if (IS_NULL(work)) {\n            onig_node_free(iarg.alt_root);\n            return ONIGERR_MEMORY;\n          }\n          *np = work;\n        }\n      }\n    }\n    break;\n\n  case TK_ANYCHAR:\n    *np = node_new_anychar();\n    CHECK_NULL_RETURN_MEMERR(*np);\n    break;\n\n  case TK_ANYCHAR_ANYTIME:\n    *np = node_new_anychar();\n    CHECK_NULL_RETURN_MEMERR(*np);\n    qn = node_new_quantifier(0, REPEAT_INFINITE, 0);\n    CHECK_NULL_RETURN_MEMERR(qn);\n    NQTFR(qn)->target = *np;\n    *np = qn;\n    break;\n\n  case TK_BACKREF:\n    len = tok->u.backref.num;\n    *np = node_new_backref(len,\n                  (len > 1 ? tok->u.backref.refs : &(tok->u.backref.ref1)),\n                  tok->u.backref.by_name,\n#ifdef USE_BACKREF_WITH_LEVEL\n\t\t\t   tok->u.backref.exist_level,\n\t\t\t   tok->u.backref.level,\n#endif\n\t\t\t   env);\n    CHECK_NULL_RETURN_MEMERR(*np);\n    break;\n\n#ifdef USE_SUBEXP_CALL\n  case TK_CALL:\n    {\n      int gnum = tok->u.call.gnum;\n\n      if (gnum < 0) {\n        gnum = BACKREF_REL_TO_ABS(gnum, env);\n        if (gnum <= 0)\n          return ONIGERR_INVALID_BACKREF;\n      }\n      *np = node_new_call(tok->u.call.name, tok->u.call.name_end, gnum);\n      CHECK_NULL_RETURN_MEMERR(*np);\n      env->num_call++;\n    }\n    break;\n#endif\n\n  case TK_ANCHOR:\n    *np = onig_node_new_anchor(tok->u.anchor);\n    break;\n\n  case TK_OP_REPEAT:\n  case TK_INTERVAL:\n    if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_CONTEXT_INDEP_REPEAT_OPS)) {\n      if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_CONTEXT_INVALID_REPEAT_OPS))\n        return ONIGERR_TARGET_OF_REPEAT_OPERATOR_NOT_SPECIFIED;\n      else\n        *np = node_new_empty();\n    }\n    else {\n      goto tk_byte;\n    }\n    break;\n\n  default:\n    return ONIGERR_PARSER_BUG;\n    break;\n  }\n\n  {\n    targetp = np;\n\n  re_entry:\n    r = fetch_token(tok, src, end, env);\n    if (r < 0) return r;\n\n  repeat:\n    if (r == TK_OP_REPEAT || r == TK_INTERVAL) {\n      if (is_invalid_quantifier_target(*targetp))\n        return ONIGERR_TARGET_OF_REPEAT_OPERATOR_INVALID;\n\n      qn = node_new_quantifier(tok->u.repeat.lower, tok->u.repeat.upper,\n                               (r == TK_INTERVAL ? 1 : 0));\n      CHECK_NULL_RETURN_MEMERR(qn);\n      NQTFR(qn)->greedy = tok->u.repeat.greedy;\n      r = set_quantifier(qn, *targetp, group, env);\n      if (r < 0) {\n        onig_node_free(qn);\n        return r;\n      }\n\n      if (tok->u.repeat.possessive != 0) {\n        Node* en;\n        en = node_new_enclose(ENCLOSE_STOP_BACKTRACK);\n        if (IS_NULL(en)) {\n          onig_node_free(qn);\n          return ONIGERR_MEMORY;\n        }\n        NENCLOSE(en)->target = qn;\n        qn = en;\n      }\n\n      if (r == 0) {\n        *targetp = qn;\n      }\n      else if (r == 1) {\n        onig_node_free(qn);\n      }\n      else if (r == 2) { /* split case: /abc+/ */\n        Node *tmp;\n\n        *targetp = node_new_list(*targetp, NULL);\n        if (IS_NULL(*targetp)) {\n          onig_node_free(qn);\n          return ONIGERR_MEMORY;\n        }\n        tmp = NCDR(*targetp) = node_new_list(qn, NULL);\n        if (IS_NULL(tmp)) {\n          onig_node_free(qn);\n          return ONIGERR_MEMORY;\n        }\n        targetp = &(NCAR(tmp));\n      }\n      goto re_entry;\n    }\n  }\n\n  return r;\n}\n\nstatic int\nparse_branch(Node** top, OnigToken* tok, int term,\n\t     UChar** src, UChar* end, ScanEnv* env)\n{\n  int r;\n  Node *node, **headp;\n\n  *top = NULL;\n  r = parse_exp(&node, tok, term, src, end, env);\n  if (r < 0) {\n    onig_node_free(node);\n    return r;\n  }\n\n  if (r == TK_EOT || r == term || r == TK_ALT) {\n    *top = node;\n  }\n  else {\n    *top  = node_new_list(node, NULL);\n    headp = &(NCDR(*top));\n    while (r != TK_EOT && r != term && r != TK_ALT) {\n      r = parse_exp(&node, tok, term, src, end, env);\n      if (r < 0) {\n        onig_node_free(node);\n        return r;\n      }\n\n      if (NTYPE(node) == NT_LIST) {\n        *headp = node;\n        while (IS_NOT_NULL(NCDR(node))) node = NCDR(node);\n        headp = &(NCDR(node));\n      }\n      else {\n        *headp = node_new_list(node, NULL);\n        headp = &(NCDR(*headp));\n      }\n    }\n  }\n\n  return r;\n}\n\n/* term_tok: TK_EOT or TK_SUBEXP_CLOSE */\nstatic int\nparse_subexp(Node** top, OnigToken* tok, int term,\n\t     UChar** src, UChar* end, ScanEnv* env)\n{\n  int r;\n  Node *node, **headp;\n\n  *top = NULL;\n  env->parse_depth++;\n  if (env->parse_depth > ParseDepthLimit)\n    return ONIGERR_PARSE_DEPTH_LIMIT_OVER;\n  r = parse_branch(&node, tok, term, src, end, env);\n  if (r < 0) {\n    onig_node_free(node);\n    return r;\n  }\n\n  if (r == term) {\n    *top = node;\n  }\n  else if (r == TK_ALT) {\n    *top  = onig_node_new_alt(node, NULL);\n    headp = &(NCDR(*top));\n    while (r == TK_ALT) {\n      r = fetch_token(tok, src, end, env);\n      if (r < 0) return r;\n      r = parse_branch(&node, tok, term, src, end, env);\n      if (r < 0) {\n        onig_node_free(node);\n        return r;\n      }\n      *headp = onig_node_new_alt(node, NULL);\n      headp = &(NCDR(*headp));\n    }\n\n    if (tok->type != (enum TokenSyms )term)\n      goto err;\n  }\n  else {\n    onig_node_free(node);\n  err:\n    if (term == TK_SUBEXP_CLOSE)\n      return ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS;\n    else\n      return ONIGERR_PARSER_BUG;\n  }\n\n  env->parse_depth--;\n  return r;\n}\n\nstatic int\nparse_regexp(Node** top, UChar** src, UChar* end, ScanEnv* env)\n{\n  int r;\n  OnigToken tok;\n\n  r = fetch_token(&tok, src, end, env);\n  if (r < 0) return r;\n  r = parse_subexp(top, &tok, TK_EOT, src, end, env);\n  if (r < 0) return r;\n  return 0;\n}\n\nextern int\nonig_parse_make_tree(Node** root, const UChar* pattern, const UChar* end,\n\t\t     regex_t* reg, ScanEnv* env)\n{\n  int r;\n  UChar* p;\n\n#ifdef USE_NAMED_GROUP\n  names_clear(reg);\n#endif\n\n  scan_env_clear(env);\n  env->option         = reg->options;\n  env->case_fold_flag = reg->case_fold_flag;\n  env->enc            = reg->enc;\n  env->syntax         = reg->syntax;\n  env->pattern        = (UChar* )pattern;\n  env->pattern_end    = (UChar* )end;\n  env->reg            = reg;\n\n  *root = NULL;\n\n  if (! ONIGENC_IS_VALID_MBC_STRING(env->enc, pattern, end))\n    return ONIGERR_INVALID_WIDE_CHAR_VALUE;\n\n  p = (UChar* )pattern;\n  r = parse_regexp(root, &p, (UChar* )end, env);\n  reg->num_mem = env->num_mem;\n  return r;\n}\n\nextern void\nonig_scan_env_set_error_string(ScanEnv* env, int ecode ARG_UNUSED,\n\t\t\t\tUChar* arg, UChar* arg_end)\n{\n  env->error     = arg;\n  env->error_end = arg_end;\n}\n"], "filenames": ["src/regparse.c"], "buggy_code_start_loc": [4084], "buggy_code_end_loc": [4085], "fixing_code_start_loc": [4084], "fixing_code_end_loc": [4087], "type": "CWE-787", "message": "An issue was discovered in Oniguruma 6.2.0, as used in Oniguruma-mod in Ruby through 2.4.1 and mbstring in PHP through 7.1.5. A heap out-of-bounds write occurs in bitset_set_range() during regular expression compilation due to an uninitialized variable from an incorrect state transition. An incorrect state transition in parse_char_class() could create an execution path that leaves a critical local variable uninitialized until it's used as an index, resulting in an out-of-bounds write memory corruption.", "other": {"cve": {"id": "CVE-2017-9228", "sourceIdentifier": "cve@mitre.org", "published": "2017-05-24T15:29:00.370", "lastModified": "2022-07-20T16:34:30.863", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in Oniguruma 6.2.0, as used in Oniguruma-mod in Ruby through 2.4.1 and mbstring in PHP through 7.1.5. A heap out-of-bounds write occurs in bitset_set_range() during regular expression compilation due to an uninitialized variable from an incorrect state transition. An incorrect state transition in parse_char_class() could create an execution path that leaves a critical local variable uninitialized until it's used as an index, resulting in an out-of-bounds write memory corruption."}, {"lang": "es", "value": "Se descubri\u00f3 un problema en Oniguruma versi\u00f3n 6.2.0, tal como es usado en Oniguruma-mod en Ruby hasta la versi\u00f3n  2.4.1 y mbstring en PHP hasta la versi\u00f3n 7.1.5. Se produce una escritura fuera del l\u00edmite de la pila en bitset_set_range() durante la compilaci\u00f3n de expresiones regulares debido a una variable no inicializada de una transici\u00f3n de estado incorrecta. Una transici\u00f3n de estado incorrecta en parse_char_class() podr\u00eda dise\u00f1ar una ruta (path) de ejecuci\u00f3n que deje una variable local cr\u00edtica sin inicializar hasta que se utilice como un \u00edndice, resultando en una corrupci\u00f3n de memoria de escritura fuera de los l\u00edmites."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oniguruma_project:oniguruma:6.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "71A9EC32-B30C-40DF-9937-654BC977DCC4"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.6.0", "versionEndExcluding": "5.6.31", "matchCriteriaId": "00E9E5A8-4C71-471D-97E9-FDE368D1EB71"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0", "versionEndExcluding": "7.0.21", "matchCriteriaId": "ABE3BCB8-C2C7-4E44-A4D2-AA1DAE9555DB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.1.0", "versionEndExcluding": "7.1.7", "matchCriteriaId": "5799FA9F-8C0B-4B86-9D2C-558DFF64AA6C"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2018:1296", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/kkos/oniguruma/commit/3b63d12038c8d8fc278e81c942fa9bec7c704c8b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/kkos/oniguruma/issues/60", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/kkos/oniguruma/commit/3b63d12038c8d8fc278e81c942fa9bec7c704c8b"}}