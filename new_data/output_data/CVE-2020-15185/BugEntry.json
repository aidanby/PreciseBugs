{"buggy_code": ["/*\nCopyright The Helm Authors.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage downloader\n\nimport (\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"helm.sh/helm/v3/internal/test/ensure\"\n\t\"helm.sh/helm/v3/pkg/cli\"\n\t\"helm.sh/helm/v3/pkg/getter\"\n\t\"helm.sh/helm/v3/pkg/repo\"\n\t\"helm.sh/helm/v3/pkg/repo/repotest\"\n)\n\nconst (\n\trepoConfig = \"testdata/repositories.yaml\"\n\trepoCache  = \"testdata/repository\"\n)\n\nfunc TestResolveChartRef(t *testing.T) {\n\ttests := []struct {\n\t\tname, ref, expect, version string\n\t\tfail                       bool\n\t}{\n\t\t{name: \"full URL\", ref: \"http://example.com/foo-1.2.3.tgz\", expect: \"http://example.com/foo-1.2.3.tgz\"},\n\t\t{name: \"full URL, HTTPS\", ref: \"https://example.com/foo-1.2.3.tgz\", expect: \"https://example.com/foo-1.2.3.tgz\"},\n\t\t{name: \"full URL, with authentication\", ref: \"http://username:password@example.com/foo-1.2.3.tgz\", expect: \"http://username:password@example.com/foo-1.2.3.tgz\"},\n\t\t{name: \"reference, testing repo\", ref: \"testing/alpine\", expect: \"http://example.com/alpine-1.2.3.tgz\"},\n\t\t{name: \"reference, version, testing repo\", ref: \"testing/alpine\", version: \"0.2.0\", expect: \"http://example.com/alpine-0.2.0.tgz\"},\n\t\t{name: \"reference, version, malformed repo\", ref: \"malformed/alpine\", version: \"1.2.3\", expect: \"http://dl.example.com/alpine-1.2.3.tgz\"},\n\t\t{name: \"reference, querystring repo\", ref: \"testing-querystring/alpine\", expect: \"http://example.com/alpine-1.2.3.tgz?key=value\"},\n\t\t{name: \"reference, testing-relative repo\", ref: \"testing-relative/foo\", expect: \"http://example.com/helm/charts/foo-1.2.3.tgz\"},\n\t\t{name: \"reference, testing-relative repo\", ref: \"testing-relative/bar\", expect: \"http://example.com/helm/bar-1.2.3.tgz\"},\n\t\t{name: \"reference, testing-relative-trailing-slash repo\", ref: \"testing-relative-trailing-slash/foo\", expect: \"http://example.com/helm/charts/foo-1.2.3.tgz\"},\n\t\t{name: \"reference, testing-relative-trailing-slash repo\", ref: \"testing-relative-trailing-slash/bar\", expect: \"http://example.com/helm/bar-1.2.3.tgz\"},\n\t\t{name: \"full URL, HTTPS, irrelevant version\", ref: \"https://example.com/foo-1.2.3.tgz\", version: \"0.1.0\", expect: \"https://example.com/foo-1.2.3.tgz\", fail: true},\n\t\t{name: \"full URL, file\", ref: \"file:///foo-1.2.3.tgz\", fail: true},\n\t\t{name: \"invalid\", ref: \"invalid-1.2.3\", fail: true},\n\t\t{name: \"not found\", ref: \"nosuchthing/invalid-1.2.3\", fail: true},\n\t}\n\n\tc := ChartDownloader{\n\t\tOut:              os.Stderr,\n\t\tRepositoryConfig: repoConfig,\n\t\tRepositoryCache:  repoCache,\n\t\tGetters: getter.All(&cli.EnvSettings{\n\t\t\tRepositoryConfig: repoConfig,\n\t\t\tRepositoryCache:  repoCache,\n\t\t}),\n\t}\n\n\tfor _, tt := range tests {\n\t\tu, err := c.ResolveChartVersion(tt.ref, tt.version)\n\t\tif err != nil {\n\t\t\tif tt.fail {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tt.Errorf(\"%s: failed with error %s\", tt.name, err)\n\t\t\tcontinue\n\t\t}\n\t\tif got := u.String(); got != tt.expect {\n\t\t\tt.Errorf(\"%s: expected %s, got %s\", tt.name, tt.expect, got)\n\t\t}\n\t}\n}\n\nfunc TestResolveChartOpts(t *testing.T) {\n\ttests := []struct {\n\t\tname, ref, version string\n\t\texpect             []getter.Option\n\t}{\n\t\t{\n\t\t\tname: \"repo with CA-file\",\n\t\t\tref:  \"testing-ca-file/foo\",\n\t\t\texpect: []getter.Option{\n\t\t\t\tgetter.WithURL(\"https://example.com/foo-1.2.3.tgz\"),\n\t\t\t\tgetter.WithTLSClientConfig(\"cert\", \"key\", \"ca\"),\n\t\t\t},\n\t\t},\n\t}\n\n\tc := ChartDownloader{\n\t\tOut:              os.Stderr,\n\t\tRepositoryConfig: repoConfig,\n\t\tRepositoryCache:  repoCache,\n\t\tGetters: getter.All(&cli.EnvSettings{\n\t\t\tRepositoryConfig: repoConfig,\n\t\t\tRepositoryCache:  repoCache,\n\t\t}),\n\t}\n\n\t// snapshot options\n\tsnapshotOpts := c.Options\n\n\tfor _, tt := range tests {\n\t\t// reset chart downloader options for each test case\n\t\tc.Options = snapshotOpts\n\n\t\texpect, err := getter.NewHTTPGetter(tt.expect...)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"%s: failed to setup http client: %s\", tt.name, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tu, err := c.ResolveChartVersion(tt.ref, tt.version)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"%s: failed with error %s\", tt.name, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgot, err := getter.NewHTTPGetter(\n\t\t\tappend(\n\t\t\t\tc.Options,\n\t\t\t\tgetter.WithURL(u.String()),\n\t\t\t)...,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"%s: failed to create http client: %s\", tt.name, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif *(got.(*getter.HTTPGetter)) != *(expect.(*getter.HTTPGetter)) {\n\t\t\tt.Errorf(\"%s: expected %s, got %s\", tt.name, expect, got)\n\t\t}\n\t}\n}\n\nfunc TestVerifyChart(t *testing.T) {\n\tv, err := VerifyChart(\"testdata/signtest-0.1.0.tgz\", \"testdata/helm-test-key.pub\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// The verification is tested at length in the provenance package. Here,\n\t// we just want a quick sanity check that the v is not empty.\n\tif len(v.FileHash) == 0 {\n\t\tt.Error(\"Digest missing\")\n\t}\n}\n\nfunc TestIsTar(t *testing.T) {\n\ttests := map[string]bool{\n\t\t\"foo.tgz\":           true,\n\t\t\"foo/bar/baz.tgz\":   true,\n\t\t\"foo-1.2.3.4.5.tgz\": true,\n\t\t\"foo.tar.gz\":        false, // for our purposes\n\t\t\"foo.tgz.1\":         false,\n\t\t\"footgz\":            false,\n\t}\n\n\tfor src, expect := range tests {\n\t\tif isTar(src) != expect {\n\t\t\tt.Errorf(\"%q should be %t\", src, expect)\n\t\t}\n\t}\n}\n\nfunc TestDownloadTo(t *testing.T) {\n\t// Set up a fake repo with basic auth enabled\n\tsrv, err := repotest.NewTempServerWithCleanup(t, \"testdata/*.tgz*\")\n\tsrv.Stop()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tsrv.WithMiddleware(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tusername, password, ok := r.BasicAuth()\n\t\tif !ok || username != \"username\" || password != \"password\" {\n\t\t\tt.Errorf(\"Expected request to use basic auth and for username == 'username' and password == 'password', got '%v', '%s', '%s'\", ok, username, password)\n\t\t}\n\t}))\n\tsrv.Start()\n\tdefer srv.Stop()\n\tif err := srv.CreateIndex(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := srv.LinkIndices(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tc := ChartDownloader{\n\t\tOut:              os.Stderr,\n\t\tVerify:           VerifyAlways,\n\t\tKeyring:          \"testdata/helm-test-key.pub\",\n\t\tRepositoryConfig: repoConfig,\n\t\tRepositoryCache:  repoCache,\n\t\tGetters: getter.All(&cli.EnvSettings{\n\t\t\tRepositoryConfig: repoConfig,\n\t\t\tRepositoryCache:  repoCache,\n\t\t}),\n\t\tOptions: []getter.Option{\n\t\t\tgetter.WithBasicAuth(\"username\", \"password\"),\n\t\t},\n\t}\n\tcname := \"/signtest-0.1.0.tgz\"\n\tdest := srv.Root()\n\twhere, v, err := c.DownloadTo(srv.URL()+cname, \"\", dest)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif expect := filepath.Join(dest, cname); where != expect {\n\t\tt.Errorf(\"Expected download to %s, got %s\", expect, where)\n\t}\n\n\tif v.FileHash == \"\" {\n\t\tt.Error(\"File hash was empty, but verification is required.\")\n\t}\n\n\tif _, err := os.Stat(filepath.Join(dest, cname)); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestDownloadTo_TLS(t *testing.T) {\n\t// Set up mock server w/ tls enabled\n\tsrv, err := repotest.NewTempServerWithCleanup(t, \"testdata/*.tgz*\")\n\tsrv.Stop()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tsrv.StartTLS()\n\tdefer srv.Stop()\n\tif err := srv.CreateIndex(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := srv.LinkIndices(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\trepoConfig := filepath.Join(srv.Root(), \"repositories.yaml\")\n\trepoCache := srv.Root()\n\n\tc := ChartDownloader{\n\t\tOut:              os.Stderr,\n\t\tVerify:           VerifyAlways,\n\t\tKeyring:          \"testdata/helm-test-key.pub\",\n\t\tRepositoryConfig: repoConfig,\n\t\tRepositoryCache:  repoCache,\n\t\tGetters: getter.All(&cli.EnvSettings{\n\t\t\tRepositoryConfig: repoConfig,\n\t\t\tRepositoryCache:  repoCache,\n\t\t}),\n\t\tOptions: []getter.Option{},\n\t}\n\tcname := \"test/signtest\"\n\tdest := srv.Root()\n\twhere, v, err := c.DownloadTo(cname, \"\", dest)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttarget := filepath.Join(dest, \"signtest-0.1.0.tgz\")\n\tif expect := target; where != expect {\n\t\tt.Errorf(\"Expected download to %s, got %s\", expect, where)\n\t}\n\n\tif v.FileHash == \"\" {\n\t\tt.Error(\"File hash was empty, but verification is required.\")\n\t}\n\n\tif _, err := os.Stat(target); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestDownloadTo_VerifyLater(t *testing.T) {\n\tdefer ensure.HelmHome(t)()\n\n\tdest := ensure.TempDir(t)\n\n\t// Set up a fake repo\n\tsrv, err := repotest.NewTempServerWithCleanup(t, \"testdata/*.tgz*\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer srv.Stop()\n\tif err := srv.LinkIndices(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tc := ChartDownloader{\n\t\tOut:              os.Stderr,\n\t\tVerify:           VerifyLater,\n\t\tRepositoryConfig: repoConfig,\n\t\tRepositoryCache:  repoCache,\n\t\tGetters: getter.All(&cli.EnvSettings{\n\t\t\tRepositoryConfig: repoConfig,\n\t\t\tRepositoryCache:  repoCache,\n\t\t}),\n\t}\n\tcname := \"/signtest-0.1.0.tgz\"\n\twhere, _, err := c.DownloadTo(srv.URL()+cname, \"\", dest)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif expect := filepath.Join(dest, cname); where != expect {\n\t\tt.Errorf(\"Expected download to %s, got %s\", expect, where)\n\t}\n\n\tif _, err := os.Stat(filepath.Join(dest, cname)); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif _, err := os.Stat(filepath.Join(dest, cname+\".prov\")); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestScanReposForURL(t *testing.T) {\n\tc := ChartDownloader{\n\t\tOut:              os.Stderr,\n\t\tVerify:           VerifyLater,\n\t\tRepositoryConfig: repoConfig,\n\t\tRepositoryCache:  repoCache,\n\t\tGetters: getter.All(&cli.EnvSettings{\n\t\t\tRepositoryConfig: repoConfig,\n\t\t\tRepositoryCache:  repoCache,\n\t\t}),\n\t}\n\n\tu := \"http://example.com/alpine-0.2.0.tgz\"\n\trf, err := repo.LoadFile(repoConfig)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tentry, err := c.scanReposForURL(u, rf)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif entry.Name != \"testing\" {\n\t\tt.Errorf(\"Unexpected repo %q for URL %q\", entry.Name, u)\n\t}\n\n\t// A lookup failure should produce an ErrNoOwnerRepo\n\tu = \"https://no.such.repo/foo/bar-1.23.4.tgz\"\n\tif _, err = c.scanReposForURL(u, rf); err != ErrNoOwnerRepo {\n\t\tt.Fatalf(\"expected ErrNoOwnerRepo, got %v\", err)\n\t}\n}\n", "/*\nCopyright The Helm Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage repo\n\nimport (\n\t\"bytes\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/Masterminds/semver/v3\"\n\t\"github.com/pkg/errors\"\n\t\"sigs.k8s.io/yaml\"\n\n\t\"helm.sh/helm/v3/internal/fileutil\"\n\t\"helm.sh/helm/v3/internal/urlutil\"\n\t\"helm.sh/helm/v3/pkg/chart\"\n\t\"helm.sh/helm/v3/pkg/chart/loader\"\n\t\"helm.sh/helm/v3/pkg/provenance\"\n)\n\nvar indexPath = \"index.yaml\"\n\n// APIVersionV1 is the v1 API version for index and repository files.\nconst APIVersionV1 = \"v1\"\n\nvar (\n\t// ErrNoAPIVersion indicates that an API version was not specified.\n\tErrNoAPIVersion = errors.New(\"no API version specified\")\n\t// ErrNoChartVersion indicates that a chart with the given version is not found.\n\tErrNoChartVersion = errors.New(\"no chart version found\")\n\t// ErrNoChartName indicates that a chart with the given name is not found.\n\tErrNoChartName = errors.New(\"no chart name found\")\n)\n\n// ChartVersions is a list of versioned chart references.\n// Implements a sorter on Version.\ntype ChartVersions []*ChartVersion\n\n// Len returns the length.\nfunc (c ChartVersions) Len() int { return len(c) }\n\n// Swap swaps the position of two items in the versions slice.\nfunc (c ChartVersions) Swap(i, j int) { c[i], c[j] = c[j], c[i] }\n\n// Less returns true if the version of entry a is less than the version of entry b.\nfunc (c ChartVersions) Less(a, b int) bool {\n\t// Failed parse pushes to the back.\n\ti, err := semver.NewVersion(c[a].Version)\n\tif err != nil {\n\t\treturn true\n\t}\n\tj, err := semver.NewVersion(c[b].Version)\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn i.LessThan(j)\n}\n\n// IndexFile represents the index file in a chart repository\ntype IndexFile struct {\n\tAPIVersion string                   `json:\"apiVersion\"`\n\tGenerated  time.Time                `json:\"generated\"`\n\tEntries    map[string]ChartVersions `json:\"entries\"`\n\tPublicKeys []string                 `json:\"publicKeys,omitempty\"`\n}\n\n// NewIndexFile initializes an index.\nfunc NewIndexFile() *IndexFile {\n\treturn &IndexFile{\n\t\tAPIVersion: APIVersionV1,\n\t\tGenerated:  time.Now(),\n\t\tEntries:    map[string]ChartVersions{},\n\t\tPublicKeys: []string{},\n\t}\n}\n\n// LoadIndexFile takes a file at the given path and returns an IndexFile object\nfunc LoadIndexFile(path string) (*IndexFile, error) {\n\tb, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn loadIndex(b)\n}\n\n// Add adds a file to the index\n// This can leave the index in an unsorted state\nfunc (i IndexFile) Add(md *chart.Metadata, filename, baseURL, digest string) {\n\tu := filename\n\tif baseURL != \"\" {\n\t\tvar err error\n\t\t_, file := filepath.Split(filename)\n\t\tu, err = urlutil.URLJoin(baseURL, file)\n\t\tif err != nil {\n\t\t\tu = path.Join(baseURL, file)\n\t\t}\n\t}\n\tcr := &ChartVersion{\n\t\tURLs:     []string{u},\n\t\tMetadata: md,\n\t\tDigest:   digest,\n\t\tCreated:  time.Now(),\n\t}\n\tif ee, ok := i.Entries[md.Name]; !ok {\n\t\ti.Entries[md.Name] = ChartVersions{cr}\n\t} else {\n\t\ti.Entries[md.Name] = append(ee, cr)\n\t}\n}\n\n// Has returns true if the index has an entry for a chart with the given name and exact version.\nfunc (i IndexFile) Has(name, version string) bool {\n\t_, err := i.Get(name, version)\n\treturn err == nil\n}\n\n// SortEntries sorts the entries by version in descending order.\n//\n// In canonical form, the individual version records should be sorted so that\n// the most recent release for every version is in the 0th slot in the\n// Entries.ChartVersions array. That way, tooling can predict the newest\n// version without needing to parse SemVers.\nfunc (i IndexFile) SortEntries() {\n\tfor _, versions := range i.Entries {\n\t\tsort.Sort(sort.Reverse(versions))\n\t}\n}\n\n// Get returns the ChartVersion for the given name.\n//\n// If version is empty, this will return the chart with the latest stable version,\n// prerelease versions will be skipped.\nfunc (i IndexFile) Get(name, version string) (*ChartVersion, error) {\n\tvs, ok := i.Entries[name]\n\tif !ok {\n\t\treturn nil, ErrNoChartName\n\t}\n\tif len(vs) == 0 {\n\t\treturn nil, ErrNoChartVersion\n\t}\n\n\tvar constraint *semver.Constraints\n\tif version == \"\" {\n\t\tconstraint, _ = semver.NewConstraint(\"*\")\n\t} else {\n\t\tvar err error\n\t\tconstraint, err = semver.NewConstraint(version)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// when customer input exact version, check whether have exact match one first\n\tif len(version) != 0 {\n\t\tfor _, ver := range vs {\n\t\t\tif version == ver.Version {\n\t\t\t\treturn ver, nil\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, ver := range vs {\n\t\ttest, err := semver.NewVersion(ver.Version)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tif constraint.Check(test) {\n\t\t\treturn ver, nil\n\t\t}\n\t}\n\treturn nil, errors.Errorf(\"no chart version found for %s-%s\", name, version)\n}\n\n// WriteFile writes an index file to the given destination path.\n//\n// The mode on the file is set to 'mode'.\nfunc (i IndexFile) WriteFile(dest string, mode os.FileMode) error {\n\tb, err := yaml.Marshal(i)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn fileutil.AtomicWriteFile(dest, bytes.NewReader(b), mode)\n}\n\n// Merge merges the given index file into this index.\n//\n// This merges by name and version.\n//\n// If one of the entries in the given index does _not_ already exist, it is added.\n// In all other cases, the existing record is preserved.\n//\n// This can leave the index in an unsorted state\nfunc (i *IndexFile) Merge(f *IndexFile) {\n\tfor _, cvs := range f.Entries {\n\t\tfor _, cv := range cvs {\n\t\t\tif !i.Has(cv.Name, cv.Version) {\n\t\t\t\te := i.Entries[cv.Name]\n\t\t\t\ti.Entries[cv.Name] = append(e, cv)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// ChartVersion represents a chart entry in the IndexFile\ntype ChartVersion struct {\n\t*chart.Metadata\n\tURLs    []string  `json:\"urls\"`\n\tCreated time.Time `json:\"created,omitempty\"`\n\tRemoved bool      `json:\"removed,omitempty\"`\n\tDigest  string    `json:\"digest,omitempty\"`\n}\n\n// IndexDirectory reads a (flat) directory and generates an index.\n//\n// It indexes only charts that have been packaged (*.tgz).\n//\n// The index returned will be in an unsorted state\nfunc IndexDirectory(dir, baseURL string) (*IndexFile, error) {\n\tarchives, err := filepath.Glob(filepath.Join(dir, \"*.tgz\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tmoreArchives, err := filepath.Glob(filepath.Join(dir, \"**/*.tgz\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tarchives = append(archives, moreArchives...)\n\n\tindex := NewIndexFile()\n\tfor _, arch := range archives {\n\t\tfname, err := filepath.Rel(dir, arch)\n\t\tif err != nil {\n\t\t\treturn index, err\n\t\t}\n\n\t\tvar parentDir string\n\t\tparentDir, fname = filepath.Split(fname)\n\t\t// filepath.Split appends an extra slash to the end of parentDir. We want to strip that out.\n\t\tparentDir = strings.TrimSuffix(parentDir, string(os.PathSeparator))\n\t\tparentURL, err := urlutil.URLJoin(baseURL, parentDir)\n\t\tif err != nil {\n\t\t\tparentURL = path.Join(baseURL, parentDir)\n\t\t}\n\n\t\tc, err := loader.Load(arch)\n\t\tif err != nil {\n\t\t\t// Assume this is not a chart.\n\t\t\tcontinue\n\t\t}\n\t\thash, err := provenance.DigestFile(arch)\n\t\tif err != nil {\n\t\t\treturn index, err\n\t\t}\n\t\tindex.Add(c.Metadata, fname, parentURL, hash)\n\t}\n\treturn index, nil\n}\n\n// loadIndex loads an index file and does minimal validity checking.\n//\n// This will fail if API Version is not set (ErrNoAPIVersion) or if the unmarshal fails.\nfunc loadIndex(data []byte) (*IndexFile, error) {\n\ti := &IndexFile{}\n\tif err := yaml.Unmarshal(data, i); err != nil {\n\t\treturn i, err\n\t}\n\ti.SortEntries()\n\tif i.APIVersion == \"\" {\n\t\treturn i, ErrNoAPIVersion\n\t}\n\treturn i, nil\n}\n", "/*\nCopyright The Helm Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage repo\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"helm.sh/helm/v3/pkg/cli\"\n\t\"helm.sh/helm/v3/pkg/getter\"\n\t\"helm.sh/helm/v3/pkg/helmpath\"\n\n\t\"helm.sh/helm/v3/pkg/chart\"\n)\n\nconst (\n\ttestfile          = \"testdata/local-index.yaml\"\n\tunorderedTestfile = \"testdata/local-index-unordered.yaml\"\n\ttestRepo          = \"test-repo\"\n)\n\nfunc TestIndexFile(t *testing.T) {\n\ti := NewIndexFile()\n\ti.Add(&chart.Metadata{Name: \"clipper\", Version: \"0.1.0\"}, \"clipper-0.1.0.tgz\", \"http://example.com/charts\", \"sha256:1234567890\")\n\ti.Add(&chart.Metadata{Name: \"cutter\", Version: \"0.1.1\"}, \"cutter-0.1.1.tgz\", \"http://example.com/charts\", \"sha256:1234567890abc\")\n\ti.Add(&chart.Metadata{Name: \"cutter\", Version: \"0.1.0\"}, \"cutter-0.1.0.tgz\", \"http://example.com/charts\", \"sha256:1234567890abc\")\n\ti.Add(&chart.Metadata{Name: \"cutter\", Version: \"0.2.0\"}, \"cutter-0.2.0.tgz\", \"http://example.com/charts\", \"sha256:1234567890abc\")\n\ti.Add(&chart.Metadata{Name: \"setter\", Version: \"0.1.9+alpha\"}, \"setter-0.1.9+alpha.tgz\", \"http://example.com/charts\", \"sha256:1234567890abc\")\n\ti.Add(&chart.Metadata{Name: \"setter\", Version: \"0.1.9+beta\"}, \"setter-0.1.9+beta.tgz\", \"http://example.com/charts\", \"sha256:1234567890abc\")\n\n\ti.SortEntries()\n\n\tif i.APIVersion != APIVersionV1 {\n\t\tt.Error(\"Expected API version v1\")\n\t}\n\n\tif len(i.Entries) != 3 {\n\t\tt.Errorf(\"Expected 3 charts. Got %d\", len(i.Entries))\n\t}\n\n\tif i.Entries[\"clipper\"][0].Name != \"clipper\" {\n\t\tt.Errorf(\"Expected clipper, got %s\", i.Entries[\"clipper\"][0].Name)\n\t}\n\n\tif len(i.Entries[\"cutter\"]) != 3 {\n\t\tt.Error(\"Expected three cutters.\")\n\t}\n\n\t// Test that the sort worked. 0.2 should be at the first index for Cutter.\n\tif v := i.Entries[\"cutter\"][0].Version; v != \"0.2.0\" {\n\t\tt.Errorf(\"Unexpected first version: %s\", v)\n\t}\n\n\tcv, err := i.Get(\"setter\", \"0.1.9\")\n\tif err == nil && !strings.Contains(cv.Metadata.Version, \"0.1.9\") {\n\t\tt.Errorf(\"Unexpected version: %s\", cv.Metadata.Version)\n\t}\n\n\tcv, err = i.Get(\"setter\", \"0.1.9+alpha\")\n\tif err != nil || cv.Metadata.Version != \"0.1.9+alpha\" {\n\t\tt.Errorf(\"Expected version: 0.1.9+alpha\")\n\t}\n}\n\nfunc TestLoadIndex(t *testing.T) {\n\tb, err := ioutil.ReadFile(testfile)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ti, err := loadIndex(b)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tverifyLocalIndex(t, i)\n}\n\nfunc TestLoadIndexFile(t *testing.T) {\n\ti, err := LoadIndexFile(testfile)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tverifyLocalIndex(t, i)\n}\n\nfunc TestLoadUnorderedIndex(t *testing.T) {\n\tb, err := ioutil.ReadFile(unorderedTestfile)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ti, err := loadIndex(b)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tverifyLocalIndex(t, i)\n}\n\nfunc TestMerge(t *testing.T) {\n\tind1 := NewIndexFile()\n\tind1.Add(&chart.Metadata{\n\t\tName:    \"dreadnought\",\n\t\tVersion: \"0.1.0\",\n\t}, \"dreadnought-0.1.0.tgz\", \"http://example.com\", \"aaaa\")\n\n\tind2 := NewIndexFile()\n\tind2.Add(&chart.Metadata{\n\t\tName:    \"dreadnought\",\n\t\tVersion: \"0.2.0\",\n\t}, \"dreadnought-0.2.0.tgz\", \"http://example.com\", \"aaaabbbb\")\n\tind2.Add(&chart.Metadata{\n\t\tName:    \"doughnut\",\n\t\tVersion: \"0.2.0\",\n\t}, \"doughnut-0.2.0.tgz\", \"http://example.com\", \"ccccbbbb\")\n\n\tind1.Merge(ind2)\n\n\tif len(ind1.Entries) != 2 {\n\t\tt.Errorf(\"Expected 2 entries, got %d\", len(ind1.Entries))\n\t\tvs := ind1.Entries[\"dreadnought\"]\n\t\tif len(vs) != 2 {\n\t\t\tt.Errorf(\"Expected 2 versions, got %d\", len(vs))\n\t\t}\n\t\tv := vs[0]\n\t\tif v.Version != \"0.2.0\" {\n\t\t\tt.Errorf(\"Expected %q version to be 0.2.0, got %s\", v.Name, v.Version)\n\t\t}\n\t}\n\n}\n\nfunc TestDownloadIndexFile(t *testing.T) {\n\tt.Run(\"should  download index file\", func(t *testing.T) {\n\t\tsrv, err := startLocalServerForTests(nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer srv.Close()\n\n\t\tr, err := NewChartRepository(&Entry{\n\t\t\tName: testRepo,\n\t\t\tURL:  srv.URL,\n\t\t}, getter.All(&cli.EnvSettings{}))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Problem creating chart repository from %s: %v\", testRepo, err)\n\t\t}\n\n\t\tidx, err := r.DownloadIndexFile()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to download index file to %s: %#v\", idx, err)\n\t\t}\n\n\t\tif _, err := os.Stat(idx); err != nil {\n\t\t\tt.Fatalf(\"error finding created index file: %#v\", err)\n\t\t}\n\n\t\tb, err := ioutil.ReadFile(idx)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"error reading index file: %#v\", err)\n\t\t}\n\n\t\ti, err := loadIndex(b)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Index %q failed to parse: %s\", testfile, err)\n\t\t}\n\t\tverifyLocalIndex(t, i)\n\n\t\t// Check that charts file is also created\n\t\tidx = filepath.Join(r.CachePath, helmpath.CacheChartsFile(r.Config.Name))\n\t\tif _, err := os.Stat(idx); err != nil {\n\t\t\tt.Fatalf(\"error finding created charts file: %#v\", err)\n\t\t}\n\n\t\tb, err = ioutil.ReadFile(idx)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"error reading charts file: %#v\", err)\n\t\t}\n\t\tverifyLocalChartsFile(t, b, i)\n\t})\n\n\tt.Run(\"should not decode the path in the repo url while downloading index\", func(t *testing.T) {\n\t\tchartRepoURLPath := \"/some%2Fpath/test\"\n\t\tfileBytes, err := ioutil.ReadFile(\"testdata/local-index.yaml\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\thandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tif r.URL.RawPath == chartRepoURLPath+\"/index.yaml\" {\n\t\t\t\tw.Write(fileBytes)\n\t\t\t}\n\t\t})\n\t\tsrv, err := startLocalServerForTests(handler)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer srv.Close()\n\n\t\tr, err := NewChartRepository(&Entry{\n\t\t\tName: testRepo,\n\t\t\tURL:  srv.URL + chartRepoURLPath,\n\t\t}, getter.All(&cli.EnvSettings{}))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Problem creating chart repository from %s: %v\", testRepo, err)\n\t\t}\n\n\t\tidx, err := r.DownloadIndexFile()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to download index file to %s: %#v\", idx, err)\n\t\t}\n\n\t\tif _, err := os.Stat(idx); err != nil {\n\t\t\tt.Fatalf(\"error finding created index file: %#v\", err)\n\t\t}\n\n\t\tb, err := ioutil.ReadFile(idx)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"error reading index file: %#v\", err)\n\t\t}\n\n\t\ti, err := loadIndex(b)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Index %q failed to parse: %s\", testfile, err)\n\t\t}\n\t\tverifyLocalIndex(t, i)\n\n\t\t// Check that charts file is also created\n\t\tidx = filepath.Join(r.CachePath, helmpath.CacheChartsFile(r.Config.Name))\n\t\tif _, err := os.Stat(idx); err != nil {\n\t\t\tt.Fatalf(\"error finding created charts file: %#v\", err)\n\t\t}\n\n\t\tb, err = ioutil.ReadFile(idx)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"error reading charts file: %#v\", err)\n\t\t}\n\t\tverifyLocalChartsFile(t, b, i)\n\t})\n}\n\nfunc verifyLocalIndex(t *testing.T, i *IndexFile) {\n\tnumEntries := len(i.Entries)\n\tif numEntries != 3 {\n\t\tt.Errorf(\"Expected 3 entries in index file but got %d\", numEntries)\n\t}\n\n\talpine, ok := i.Entries[\"alpine\"]\n\tif !ok {\n\t\tt.Fatalf(\"'alpine' section not found.\")\n\t}\n\n\tif l := len(alpine); l != 1 {\n\t\tt.Fatalf(\"'alpine' should have 1 chart, got %d\", l)\n\t}\n\n\tnginx, ok := i.Entries[\"nginx\"]\n\tif !ok || len(nginx) != 2 {\n\t\tt.Fatalf(\"Expected 2 nginx entries\")\n\t}\n\n\texpects := []*ChartVersion{\n\t\t{\n\t\t\tMetadata: &chart.Metadata{\n\t\t\t\tName:        \"alpine\",\n\t\t\t\tDescription: \"string\",\n\t\t\t\tVersion:     \"1.0.0\",\n\t\t\t\tKeywords:    []string{\"linux\", \"alpine\", \"small\", \"sumtin\"},\n\t\t\t\tHome:        \"https://github.com/something\",\n\t\t\t},\n\t\t\tURLs: []string{\n\t\t\t\t\"https://kubernetes-charts.storage.googleapis.com/alpine-1.0.0.tgz\",\n\t\t\t\t\"http://storage2.googleapis.com/kubernetes-charts/alpine-1.0.0.tgz\",\n\t\t\t},\n\t\t\tDigest: \"sha256:1234567890abcdef\",\n\t\t},\n\t\t{\n\t\t\tMetadata: &chart.Metadata{\n\t\t\t\tName:        \"nginx\",\n\t\t\t\tDescription: \"string\",\n\t\t\t\tVersion:     \"0.2.0\",\n\t\t\t\tKeywords:    []string{\"popular\", \"web server\", \"proxy\"},\n\t\t\t\tHome:        \"https://github.com/something/else\",\n\t\t\t},\n\t\t\tURLs: []string{\n\t\t\t\t\"https://kubernetes-charts.storage.googleapis.com/nginx-0.2.0.tgz\",\n\t\t\t},\n\t\t\tDigest: \"sha256:1234567890abcdef\",\n\t\t},\n\t\t{\n\t\t\tMetadata: &chart.Metadata{\n\t\t\t\tName:        \"nginx\",\n\t\t\t\tDescription: \"string\",\n\t\t\t\tVersion:     \"0.1.0\",\n\t\t\t\tKeywords:    []string{\"popular\", \"web server\", \"proxy\"},\n\t\t\t\tHome:        \"https://github.com/something\",\n\t\t\t},\n\t\t\tURLs: []string{\n\t\t\t\t\"https://kubernetes-charts.storage.googleapis.com/nginx-0.1.0.tgz\",\n\t\t\t},\n\t\t\tDigest: \"sha256:1234567890abcdef\",\n\t\t},\n\t}\n\ttests := []*ChartVersion{alpine[0], nginx[0], nginx[1]}\n\n\tfor i, tt := range tests {\n\t\texpect := expects[i]\n\t\tif tt.Name != expect.Name {\n\t\t\tt.Errorf(\"Expected name %q, got %q\", expect.Name, tt.Name)\n\t\t}\n\t\tif tt.Description != expect.Description {\n\t\t\tt.Errorf(\"Expected description %q, got %q\", expect.Description, tt.Description)\n\t\t}\n\t\tif tt.Version != expect.Version {\n\t\t\tt.Errorf(\"Expected version %q, got %q\", expect.Version, tt.Version)\n\t\t}\n\t\tif tt.Digest != expect.Digest {\n\t\t\tt.Errorf(\"Expected digest %q, got %q\", expect.Digest, tt.Digest)\n\t\t}\n\t\tif tt.Home != expect.Home {\n\t\t\tt.Errorf(\"Expected home %q, got %q\", expect.Home, tt.Home)\n\t\t}\n\n\t\tfor i, url := range tt.URLs {\n\t\t\tif url != expect.URLs[i] {\n\t\t\t\tt.Errorf(\"Expected URL %q, got %q\", expect.URLs[i], url)\n\t\t\t}\n\t\t}\n\t\tfor i, kw := range tt.Keywords {\n\t\t\tif kw != expect.Keywords[i] {\n\t\t\t\tt.Errorf(\"Expected keywords %q, got %q\", expect.Keywords[i], kw)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc verifyLocalChartsFile(t *testing.T, chartsContent []byte, indexContent *IndexFile) {\n\tvar expected, real []string\n\tfor chart := range indexContent.Entries {\n\t\texpected = append(expected, chart)\n\t}\n\tsort.Strings(expected)\n\n\tscanner := bufio.NewScanner(bytes.NewReader(chartsContent))\n\tfor scanner.Scan() {\n\t\treal = append(real, scanner.Text())\n\t}\n\tsort.Strings(real)\n\n\tif strings.Join(expected, \" \") != strings.Join(real, \" \") {\n\t\tt.Errorf(\"Cached charts file content unexpected. Expected:\\n%s\\ngot:\\n%s\", expected, real)\n\t}\n}\n\nfunc TestIndexDirectory(t *testing.T) {\n\tdir := \"testdata/repository\"\n\tindex, err := IndexDirectory(dir, \"http://localhost:8080\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif l := len(index.Entries); l != 3 {\n\t\tt.Fatalf(\"Expected 3 entries, got %d\", l)\n\t}\n\n\t// Other things test the entry generation more thoroughly. We just test a\n\t// few fields.\n\n\tcorpus := []struct{ chartName, downloadLink string }{\n\t\t{\"frobnitz\", \"http://localhost:8080/frobnitz-1.2.3.tgz\"},\n\t\t{\"zarthal\", \"http://localhost:8080/universe/zarthal-1.0.0.tgz\"},\n\t}\n\n\tfor _, test := range corpus {\n\t\tcname := test.chartName\n\t\tfrobs, ok := index.Entries[cname]\n\t\tif !ok {\n\t\t\tt.Fatalf(\"Could not read chart %s\", cname)\n\t\t}\n\n\t\tfrob := frobs[0]\n\t\tif frob.Digest == \"\" {\n\t\t\tt.Errorf(\"Missing digest of file %s.\", frob.Name)\n\t\t}\n\t\tif frob.URLs[0] != test.downloadLink {\n\t\t\tt.Errorf(\"Unexpected URLs: %v\", frob.URLs)\n\t\t}\n\t\tif frob.Name != cname {\n\t\t\tt.Errorf(\"Expected %q, got %q\", cname, frob.Name)\n\t\t}\n\t}\n}\n\nfunc TestIndexAdd(t *testing.T) {\n\ti := NewIndexFile()\n\ti.Add(&chart.Metadata{Name: \"clipper\", Version: \"0.1.0\"}, \"clipper-0.1.0.tgz\", \"http://example.com/charts\", \"sha256:1234567890\")\n\n\tif i.Entries[\"clipper\"][0].URLs[0] != \"http://example.com/charts/clipper-0.1.0.tgz\" {\n\t\tt.Errorf(\"Expected http://example.com/charts/clipper-0.1.0.tgz, got %s\", i.Entries[\"clipper\"][0].URLs[0])\n\t}\n\n\ti.Add(&chart.Metadata{Name: \"alpine\", Version: \"0.1.0\"}, \"/home/charts/alpine-0.1.0.tgz\", \"http://example.com/charts\", \"sha256:1234567890\")\n\n\tif i.Entries[\"alpine\"][0].URLs[0] != \"http://example.com/charts/alpine-0.1.0.tgz\" {\n\t\tt.Errorf(\"Expected http://example.com/charts/alpine-0.1.0.tgz, got %s\", i.Entries[\"alpine\"][0].URLs[0])\n\t}\n\n\ti.Add(&chart.Metadata{Name: \"deis\", Version: \"0.1.0\"}, \"/home/charts/deis-0.1.0.tgz\", \"http://example.com/charts/\", \"sha256:1234567890\")\n\n\tif i.Entries[\"deis\"][0].URLs[0] != \"http://example.com/charts/deis-0.1.0.tgz\" {\n\t\tt.Errorf(\"Expected http://example.com/charts/deis-0.1.0.tgz, got %s\", i.Entries[\"deis\"][0].URLs[0])\n\t}\n}\n\nfunc TestIndexWrite(t *testing.T) {\n\ti := NewIndexFile()\n\ti.Add(&chart.Metadata{Name: \"clipper\", Version: \"0.1.0\"}, \"clipper-0.1.0.tgz\", \"http://example.com/charts\", \"sha256:1234567890\")\n\tdir, err := ioutil.TempDir(\"\", \"helm-tmp\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.RemoveAll(dir)\n\ttestpath := filepath.Join(dir, \"test\")\n\ti.WriteFile(testpath, 0600)\n\n\tgot, err := ioutil.ReadFile(testpath)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !strings.Contains(string(got), \"clipper-0.1.0.tgz\") {\n\t\tt.Fatal(\"Index files doesn't contain expected content\")\n\t}\n}\n"], "fixing_code": ["/*\nCopyright The Helm Authors.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage downloader\n\nimport (\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"helm.sh/helm/v3/internal/test/ensure\"\n\t\"helm.sh/helm/v3/pkg/cli\"\n\t\"helm.sh/helm/v3/pkg/getter\"\n\t\"helm.sh/helm/v3/pkg/repo\"\n\t\"helm.sh/helm/v3/pkg/repo/repotest\"\n)\n\nconst (\n\trepoConfig = \"testdata/repositories.yaml\"\n\trepoCache  = \"testdata/repository\"\n)\n\nfunc TestResolveChartRef(t *testing.T) {\n\ttests := []struct {\n\t\tname, ref, expect, version string\n\t\tfail                       bool\n\t}{\n\t\t{name: \"full URL\", ref: \"http://example.com/foo-1.2.3.tgz\", expect: \"http://example.com/foo-1.2.3.tgz\"},\n\t\t{name: \"full URL, HTTPS\", ref: \"https://example.com/foo-1.2.3.tgz\", expect: \"https://example.com/foo-1.2.3.tgz\"},\n\t\t{name: \"full URL, with authentication\", ref: \"http://username:password@example.com/foo-1.2.3.tgz\", expect: \"http://username:password@example.com/foo-1.2.3.tgz\"},\n\t\t{name: \"reference, testing repo\", ref: \"testing/alpine\", expect: \"http://example.com/alpine-1.2.3.tgz\"},\n\t\t{name: \"reference, version, testing repo\", ref: \"testing/alpine\", version: \"0.2.0\", expect: \"http://example.com/alpine-0.2.0.tgz\"},\n\t\t{name: \"reference, version, malformed repo\", ref: \"malformed/alpine\", version: \"1.2.3\", expect: \"http://dl.example.com/alpine-1.2.3.tgz\"},\n\t\t{name: \"reference, querystring repo\", ref: \"testing-querystring/alpine\", expect: \"http://example.com/alpine-1.2.3.tgz?key=value\"},\n\t\t{name: \"reference, testing-relative repo\", ref: \"testing-relative/foo\", expect: \"http://example.com/helm/charts/foo-1.2.3.tgz\"},\n\t\t{name: \"reference, testing-relative repo\", ref: \"testing-relative/bar\", expect: \"http://example.com/helm/bar-1.2.3.tgz\"},\n\t\t{name: \"reference, testing-relative-trailing-slash repo\", ref: \"testing-relative-trailing-slash/foo\", expect: \"http://example.com/helm/charts/foo-1.2.3.tgz\"},\n\t\t{name: \"reference, testing-relative-trailing-slash repo\", ref: \"testing-relative-trailing-slash/bar\", expect: \"http://example.com/helm/bar-1.2.3.tgz\"},\n\t\t{name: \"full URL, HTTPS, irrelevant version\", ref: \"https://example.com/foo-1.2.3.tgz\", version: \"0.1.0\", expect: \"https://example.com/foo-1.2.3.tgz\", fail: true},\n\t\t{name: \"full URL, file\", ref: \"file:///foo-1.2.3.tgz\", fail: true},\n\t\t{name: \"invalid\", ref: \"invalid-1.2.3\", fail: true},\n\t\t{name: \"not found\", ref: \"nosuchthing/invalid-1.2.3\", fail: true},\n\t}\n\n\tc := ChartDownloader{\n\t\tOut:              os.Stderr,\n\t\tRepositoryConfig: repoConfig,\n\t\tRepositoryCache:  repoCache,\n\t\tGetters: getter.All(&cli.EnvSettings{\n\t\t\tRepositoryConfig: repoConfig,\n\t\t\tRepositoryCache:  repoCache,\n\t\t}),\n\t}\n\n\tfor _, tt := range tests {\n\t\tu, err := c.ResolveChartVersion(tt.ref, tt.version)\n\t\tif err != nil {\n\t\t\tif tt.fail {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tt.Errorf(\"%s: failed with error %q\", tt.name, err)\n\t\t\tcontinue\n\t\t}\n\t\tif got := u.String(); got != tt.expect {\n\t\t\tt.Errorf(\"%s: expected %s, got %s\", tt.name, tt.expect, got)\n\t\t}\n\t}\n}\n\nfunc TestResolveChartOpts(t *testing.T) {\n\ttests := []struct {\n\t\tname, ref, version string\n\t\texpect             []getter.Option\n\t}{\n\t\t{\n\t\t\tname: \"repo with CA-file\",\n\t\t\tref:  \"testing-ca-file/foo\",\n\t\t\texpect: []getter.Option{\n\t\t\t\tgetter.WithURL(\"https://example.com/foo-1.2.3.tgz\"),\n\t\t\t\tgetter.WithTLSClientConfig(\"cert\", \"key\", \"ca\"),\n\t\t\t},\n\t\t},\n\t}\n\n\tc := ChartDownloader{\n\t\tOut:              os.Stderr,\n\t\tRepositoryConfig: repoConfig,\n\t\tRepositoryCache:  repoCache,\n\t\tGetters: getter.All(&cli.EnvSettings{\n\t\t\tRepositoryConfig: repoConfig,\n\t\t\tRepositoryCache:  repoCache,\n\t\t}),\n\t}\n\n\t// snapshot options\n\tsnapshotOpts := c.Options\n\n\tfor _, tt := range tests {\n\t\t// reset chart downloader options for each test case\n\t\tc.Options = snapshotOpts\n\n\t\texpect, err := getter.NewHTTPGetter(tt.expect...)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"%s: failed to setup http client: %s\", tt.name, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tu, err := c.ResolveChartVersion(tt.ref, tt.version)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"%s: failed with error %s\", tt.name, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgot, err := getter.NewHTTPGetter(\n\t\t\tappend(\n\t\t\t\tc.Options,\n\t\t\t\tgetter.WithURL(u.String()),\n\t\t\t)...,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"%s: failed to create http client: %s\", tt.name, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif *(got.(*getter.HTTPGetter)) != *(expect.(*getter.HTTPGetter)) {\n\t\t\tt.Errorf(\"%s: expected %s, got %s\", tt.name, expect, got)\n\t\t}\n\t}\n}\n\nfunc TestVerifyChart(t *testing.T) {\n\tv, err := VerifyChart(\"testdata/signtest-0.1.0.tgz\", \"testdata/helm-test-key.pub\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// The verification is tested at length in the provenance package. Here,\n\t// we just want a quick sanity check that the v is not empty.\n\tif len(v.FileHash) == 0 {\n\t\tt.Error(\"Digest missing\")\n\t}\n}\n\nfunc TestIsTar(t *testing.T) {\n\ttests := map[string]bool{\n\t\t\"foo.tgz\":           true,\n\t\t\"foo/bar/baz.tgz\":   true,\n\t\t\"foo-1.2.3.4.5.tgz\": true,\n\t\t\"foo.tar.gz\":        false, // for our purposes\n\t\t\"foo.tgz.1\":         false,\n\t\t\"footgz\":            false,\n\t}\n\n\tfor src, expect := range tests {\n\t\tif isTar(src) != expect {\n\t\t\tt.Errorf(\"%q should be %t\", src, expect)\n\t\t}\n\t}\n}\n\nfunc TestDownloadTo(t *testing.T) {\n\t// Set up a fake repo with basic auth enabled\n\tsrv, err := repotest.NewTempServerWithCleanup(t, \"testdata/*.tgz*\")\n\tsrv.Stop()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tsrv.WithMiddleware(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tusername, password, ok := r.BasicAuth()\n\t\tif !ok || username != \"username\" || password != \"password\" {\n\t\t\tt.Errorf(\"Expected request to use basic auth and for username == 'username' and password == 'password', got '%v', '%s', '%s'\", ok, username, password)\n\t\t}\n\t}))\n\tsrv.Start()\n\tdefer srv.Stop()\n\tif err := srv.CreateIndex(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := srv.LinkIndices(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tc := ChartDownloader{\n\t\tOut:              os.Stderr,\n\t\tVerify:           VerifyAlways,\n\t\tKeyring:          \"testdata/helm-test-key.pub\",\n\t\tRepositoryConfig: repoConfig,\n\t\tRepositoryCache:  repoCache,\n\t\tGetters: getter.All(&cli.EnvSettings{\n\t\t\tRepositoryConfig: repoConfig,\n\t\t\tRepositoryCache:  repoCache,\n\t\t}),\n\t\tOptions: []getter.Option{\n\t\t\tgetter.WithBasicAuth(\"username\", \"password\"),\n\t\t},\n\t}\n\tcname := \"/signtest-0.1.0.tgz\"\n\tdest := srv.Root()\n\twhere, v, err := c.DownloadTo(srv.URL()+cname, \"\", dest)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif expect := filepath.Join(dest, cname); where != expect {\n\t\tt.Errorf(\"Expected download to %s, got %s\", expect, where)\n\t}\n\n\tif v.FileHash == \"\" {\n\t\tt.Error(\"File hash was empty, but verification is required.\")\n\t}\n\n\tif _, err := os.Stat(filepath.Join(dest, cname)); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestDownloadTo_TLS(t *testing.T) {\n\t// Set up mock server w/ tls enabled\n\tsrv, err := repotest.NewTempServerWithCleanup(t, \"testdata/*.tgz*\")\n\tsrv.Stop()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tsrv.StartTLS()\n\tdefer srv.Stop()\n\tif err := srv.CreateIndex(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := srv.LinkIndices(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\trepoConfig := filepath.Join(srv.Root(), \"repositories.yaml\")\n\trepoCache := srv.Root()\n\n\tc := ChartDownloader{\n\t\tOut:              os.Stderr,\n\t\tVerify:           VerifyAlways,\n\t\tKeyring:          \"testdata/helm-test-key.pub\",\n\t\tRepositoryConfig: repoConfig,\n\t\tRepositoryCache:  repoCache,\n\t\tGetters: getter.All(&cli.EnvSettings{\n\t\t\tRepositoryConfig: repoConfig,\n\t\t\tRepositoryCache:  repoCache,\n\t\t}),\n\t\tOptions: []getter.Option{},\n\t}\n\tcname := \"test/signtest\"\n\tdest := srv.Root()\n\twhere, v, err := c.DownloadTo(cname, \"\", dest)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttarget := filepath.Join(dest, \"signtest-0.1.0.tgz\")\n\tif expect := target; where != expect {\n\t\tt.Errorf(\"Expected download to %s, got %s\", expect, where)\n\t}\n\n\tif v.FileHash == \"\" {\n\t\tt.Error(\"File hash was empty, but verification is required.\")\n\t}\n\n\tif _, err := os.Stat(target); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestDownloadTo_VerifyLater(t *testing.T) {\n\tdefer ensure.HelmHome(t)()\n\n\tdest := ensure.TempDir(t)\n\n\t// Set up a fake repo\n\tsrv, err := repotest.NewTempServerWithCleanup(t, \"testdata/*.tgz*\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer srv.Stop()\n\tif err := srv.LinkIndices(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tc := ChartDownloader{\n\t\tOut:              os.Stderr,\n\t\tVerify:           VerifyLater,\n\t\tRepositoryConfig: repoConfig,\n\t\tRepositoryCache:  repoCache,\n\t\tGetters: getter.All(&cli.EnvSettings{\n\t\t\tRepositoryConfig: repoConfig,\n\t\t\tRepositoryCache:  repoCache,\n\t\t}),\n\t}\n\tcname := \"/signtest-0.1.0.tgz\"\n\twhere, _, err := c.DownloadTo(srv.URL()+cname, \"\", dest)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif expect := filepath.Join(dest, cname); where != expect {\n\t\tt.Errorf(\"Expected download to %s, got %s\", expect, where)\n\t}\n\n\tif _, err := os.Stat(filepath.Join(dest, cname)); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif _, err := os.Stat(filepath.Join(dest, cname+\".prov\")); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestScanReposForURL(t *testing.T) {\n\tc := ChartDownloader{\n\t\tOut:              os.Stderr,\n\t\tVerify:           VerifyLater,\n\t\tRepositoryConfig: repoConfig,\n\t\tRepositoryCache:  repoCache,\n\t\tGetters: getter.All(&cli.EnvSettings{\n\t\t\tRepositoryConfig: repoConfig,\n\t\t\tRepositoryCache:  repoCache,\n\t\t}),\n\t}\n\n\tu := \"http://example.com/alpine-0.2.0.tgz\"\n\trf, err := repo.LoadFile(repoConfig)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tentry, err := c.scanReposForURL(u, rf)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif entry.Name != \"testing\" {\n\t\tt.Errorf(\"Unexpected repo %q for URL %q\", entry.Name, u)\n\t}\n\n\t// A lookup failure should produce an ErrNoOwnerRepo\n\tu = \"https://no.such.repo/foo/bar-1.23.4.tgz\"\n\tif _, err = c.scanReposForURL(u, rf); err != ErrNoOwnerRepo {\n\t\tt.Fatalf(\"expected ErrNoOwnerRepo, got %v\", err)\n\t}\n}\n", "/*\nCopyright The Helm Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage repo\n\nimport (\n\t\"bytes\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/Masterminds/semver/v3\"\n\t\"github.com/pkg/errors\"\n\t\"sigs.k8s.io/yaml\"\n\n\t\"helm.sh/helm/v3/internal/fileutil\"\n\t\"helm.sh/helm/v3/internal/urlutil\"\n\t\"helm.sh/helm/v3/pkg/chart\"\n\t\"helm.sh/helm/v3/pkg/chart/loader\"\n\t\"helm.sh/helm/v3/pkg/provenance\"\n)\n\nvar indexPath = \"index.yaml\"\n\n// APIVersionV1 is the v1 API version for index and repository files.\nconst APIVersionV1 = \"v1\"\n\nvar (\n\t// ErrNoAPIVersion indicates that an API version was not specified.\n\tErrNoAPIVersion = errors.New(\"no API version specified\")\n\t// ErrNoChartVersion indicates that a chart with the given version is not found.\n\tErrNoChartVersion = errors.New(\"no chart version found\")\n\t// ErrNoChartName indicates that a chart with the given name is not found.\n\tErrNoChartName = errors.New(\"no chart name found\")\n)\n\n// ChartVersions is a list of versioned chart references.\n// Implements a sorter on Version.\ntype ChartVersions []*ChartVersion\n\n// Len returns the length.\nfunc (c ChartVersions) Len() int { return len(c) }\n\n// Swap swaps the position of two items in the versions slice.\nfunc (c ChartVersions) Swap(i, j int) { c[i], c[j] = c[j], c[i] }\n\n// Less returns true if the version of entry a is less than the version of entry b.\nfunc (c ChartVersions) Less(a, b int) bool {\n\t// Failed parse pushes to the back.\n\ti, err := semver.NewVersion(c[a].Version)\n\tif err != nil {\n\t\treturn true\n\t}\n\tj, err := semver.NewVersion(c[b].Version)\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn i.LessThan(j)\n}\n\n// IndexFile represents the index file in a chart repository\ntype IndexFile struct {\n\tAPIVersion string                   `json:\"apiVersion\"`\n\tGenerated  time.Time                `json:\"generated\"`\n\tEntries    map[string]ChartVersions `json:\"entries\"`\n\tPublicKeys []string                 `json:\"publicKeys,omitempty\"`\n}\n\n// NewIndexFile initializes an index.\nfunc NewIndexFile() *IndexFile {\n\treturn &IndexFile{\n\t\tAPIVersion: APIVersionV1,\n\t\tGenerated:  time.Now(),\n\t\tEntries:    map[string]ChartVersions{},\n\t\tPublicKeys: []string{},\n\t}\n}\n\n// LoadIndexFile takes a file at the given path and returns an IndexFile object\nfunc LoadIndexFile(path string) (*IndexFile, error) {\n\tb, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn loadIndex(b)\n}\n\n// Add adds a file to the index\n// This can leave the index in an unsorted state\nfunc (i IndexFile) Add(md *chart.Metadata, filename, baseURL, digest string) {\n\tu := filename\n\tif baseURL != \"\" {\n\t\tvar err error\n\t\t_, file := filepath.Split(filename)\n\t\tu, err = urlutil.URLJoin(baseURL, file)\n\t\tif err != nil {\n\t\t\tu = path.Join(baseURL, file)\n\t\t}\n\t}\n\tcr := &ChartVersion{\n\t\tURLs:     []string{u},\n\t\tMetadata: md,\n\t\tDigest:   digest,\n\t\tCreated:  time.Now(),\n\t}\n\tif ee, ok := i.Entries[md.Name]; !ok {\n\t\ti.Entries[md.Name] = ChartVersions{cr}\n\t} else {\n\t\ti.Entries[md.Name] = append(ee, cr)\n\t}\n}\n\n// Has returns true if the index has an entry for a chart with the given name and exact version.\nfunc (i IndexFile) Has(name, version string) bool {\n\t_, err := i.Get(name, version)\n\treturn err == nil\n}\n\n// SortEntries sorts the entries by version in descending order.\n//\n// In canonical form, the individual version records should be sorted so that\n// the most recent release for every version is in the 0th slot in the\n// Entries.ChartVersions array. That way, tooling can predict the newest\n// version without needing to parse SemVers.\nfunc (i IndexFile) SortEntries() {\n\tfor _, versions := range i.Entries {\n\t\tsort.Sort(sort.Reverse(versions))\n\t}\n}\n\n// Get returns the ChartVersion for the given name.\n//\n// If version is empty, this will return the chart with the latest stable version,\n// prerelease versions will be skipped.\nfunc (i IndexFile) Get(name, version string) (*ChartVersion, error) {\n\tvs, ok := i.Entries[name]\n\tif !ok {\n\t\treturn nil, ErrNoChartName\n\t}\n\tif len(vs) == 0 {\n\t\treturn nil, ErrNoChartVersion\n\t}\n\n\tvar constraint *semver.Constraints\n\tif version == \"\" {\n\t\tconstraint, _ = semver.NewConstraint(\"*\")\n\t} else {\n\t\tvar err error\n\t\tconstraint, err = semver.NewConstraint(version)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// when customer input exact version, check whether have exact match one first\n\tif len(version) != 0 {\n\t\tfor _, ver := range vs {\n\t\t\tif version == ver.Version {\n\t\t\t\treturn ver, nil\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, ver := range vs {\n\t\ttest, err := semver.NewVersion(ver.Version)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tif constraint.Check(test) {\n\t\t\treturn ver, nil\n\t\t}\n\t}\n\treturn nil, errors.Errorf(\"no chart version found for %s-%s\", name, version)\n}\n\n// WriteFile writes an index file to the given destination path.\n//\n// The mode on the file is set to 'mode'.\nfunc (i IndexFile) WriteFile(dest string, mode os.FileMode) error {\n\tb, err := yaml.Marshal(i)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn fileutil.AtomicWriteFile(dest, bytes.NewReader(b), mode)\n}\n\n// Merge merges the given index file into this index.\n//\n// This merges by name and version.\n//\n// If one of the entries in the given index does _not_ already exist, it is added.\n// In all other cases, the existing record is preserved.\n//\n// This can leave the index in an unsorted state\nfunc (i *IndexFile) Merge(f *IndexFile) {\n\tfor _, cvs := range f.Entries {\n\t\tfor _, cv := range cvs {\n\t\t\tif !i.Has(cv.Name, cv.Version) {\n\t\t\t\te := i.Entries[cv.Name]\n\t\t\t\ti.Entries[cv.Name] = append(e, cv)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// ChartVersion represents a chart entry in the IndexFile\ntype ChartVersion struct {\n\t*chart.Metadata\n\tURLs    []string  `json:\"urls\"`\n\tCreated time.Time `json:\"created,omitempty\"`\n\tRemoved bool      `json:\"removed,omitempty\"`\n\tDigest  string    `json:\"digest,omitempty\"`\n\n\t// ChecksumDeprecated is deprecated in Helm 3, and therefore ignored. Helm 3 replaced\n\t// this with Digest. However, with a strict YAML parser enabled, a field must be\n\t// present on the struct for backwards compatibility.\n\tChecksumDeprecated string `json:\"checksum,omitempty\"`\n\n\t// EngineDeprecated is deprecated in Helm 3, and therefore ignored. However, with a strict\n\t// YAML parser enabled, this field must be present.\n\tEngineDeprecated string `json:\"engine,omitempty\"`\n\n\t// TillerVersionDeprecated is deprecated in Helm 3, and therefore ignored. However, with a strict\n\t// YAML parser enabled, this field must be present.\n\tTillerVersionDeprecated string `json:\"tillerVersion,omitempty\"`\n\n\t// URLDeprecated is deprectaed in Helm 3, superseded by URLs. It is ignored. However,\n\t// with a strict YAML parser enabled, this must be present on the struct.\n\tURLDeprecated string `json:\"url,omitempty\"`\n}\n\n// IndexDirectory reads a (flat) directory and generates an index.\n//\n// It indexes only charts that have been packaged (*.tgz).\n//\n// The index returned will be in an unsorted state\nfunc IndexDirectory(dir, baseURL string) (*IndexFile, error) {\n\tarchives, err := filepath.Glob(filepath.Join(dir, \"*.tgz\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tmoreArchives, err := filepath.Glob(filepath.Join(dir, \"**/*.tgz\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tarchives = append(archives, moreArchives...)\n\n\tindex := NewIndexFile()\n\tfor _, arch := range archives {\n\t\tfname, err := filepath.Rel(dir, arch)\n\t\tif err != nil {\n\t\t\treturn index, err\n\t\t}\n\n\t\tvar parentDir string\n\t\tparentDir, fname = filepath.Split(fname)\n\t\t// filepath.Split appends an extra slash to the end of parentDir. We want to strip that out.\n\t\tparentDir = strings.TrimSuffix(parentDir, string(os.PathSeparator))\n\t\tparentURL, err := urlutil.URLJoin(baseURL, parentDir)\n\t\tif err != nil {\n\t\t\tparentURL = path.Join(baseURL, parentDir)\n\t\t}\n\n\t\tc, err := loader.Load(arch)\n\t\tif err != nil {\n\t\t\t// Assume this is not a chart.\n\t\t\tcontinue\n\t\t}\n\t\thash, err := provenance.DigestFile(arch)\n\t\tif err != nil {\n\t\t\treturn index, err\n\t\t}\n\t\tindex.Add(c.Metadata, fname, parentURL, hash)\n\t}\n\treturn index, nil\n}\n\n// loadIndex loads an index file and does minimal validity checking.\n//\n// This will fail if API Version is not set (ErrNoAPIVersion) or if the unmarshal fails.\nfunc loadIndex(data []byte) (*IndexFile, error) {\n\ti := &IndexFile{}\n\tif err := yaml.UnmarshalStrict(data, i); err != nil {\n\t\treturn i, err\n\t}\n\ti.SortEntries()\n\tif i.APIVersion == \"\" {\n\t\treturn i, ErrNoAPIVersion\n\t}\n\treturn i, nil\n}\n", "/*\nCopyright The Helm Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage repo\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"helm.sh/helm/v3/pkg/cli\"\n\t\"helm.sh/helm/v3/pkg/getter\"\n\t\"helm.sh/helm/v3/pkg/helmpath\"\n\n\t\"helm.sh/helm/v3/pkg/chart\"\n)\n\nconst (\n\ttestfile          = \"testdata/local-index.yaml\"\n\tunorderedTestfile = \"testdata/local-index-unordered.yaml\"\n\ttestRepo          = \"test-repo\"\n)\n\nfunc TestIndexFile(t *testing.T) {\n\ti := NewIndexFile()\n\ti.Add(&chart.Metadata{Name: \"clipper\", Version: \"0.1.0\"}, \"clipper-0.1.0.tgz\", \"http://example.com/charts\", \"sha256:1234567890\")\n\ti.Add(&chart.Metadata{Name: \"cutter\", Version: \"0.1.1\"}, \"cutter-0.1.1.tgz\", \"http://example.com/charts\", \"sha256:1234567890abc\")\n\ti.Add(&chart.Metadata{Name: \"cutter\", Version: \"0.1.0\"}, \"cutter-0.1.0.tgz\", \"http://example.com/charts\", \"sha256:1234567890abc\")\n\ti.Add(&chart.Metadata{Name: \"cutter\", Version: \"0.2.0\"}, \"cutter-0.2.0.tgz\", \"http://example.com/charts\", \"sha256:1234567890abc\")\n\ti.Add(&chart.Metadata{Name: \"setter\", Version: \"0.1.9+alpha\"}, \"setter-0.1.9+alpha.tgz\", \"http://example.com/charts\", \"sha256:1234567890abc\")\n\ti.Add(&chart.Metadata{Name: \"setter\", Version: \"0.1.9+beta\"}, \"setter-0.1.9+beta.tgz\", \"http://example.com/charts\", \"sha256:1234567890abc\")\n\n\ti.SortEntries()\n\n\tif i.APIVersion != APIVersionV1 {\n\t\tt.Error(\"Expected API version v1\")\n\t}\n\n\tif len(i.Entries) != 3 {\n\t\tt.Errorf(\"Expected 3 charts. Got %d\", len(i.Entries))\n\t}\n\n\tif i.Entries[\"clipper\"][0].Name != \"clipper\" {\n\t\tt.Errorf(\"Expected clipper, got %s\", i.Entries[\"clipper\"][0].Name)\n\t}\n\n\tif len(i.Entries[\"cutter\"]) != 3 {\n\t\tt.Error(\"Expected three cutters.\")\n\t}\n\n\t// Test that the sort worked. 0.2 should be at the first index for Cutter.\n\tif v := i.Entries[\"cutter\"][0].Version; v != \"0.2.0\" {\n\t\tt.Errorf(\"Unexpected first version: %s\", v)\n\t}\n\n\tcv, err := i.Get(\"setter\", \"0.1.9\")\n\tif err == nil && !strings.Contains(cv.Metadata.Version, \"0.1.9\") {\n\t\tt.Errorf(\"Unexpected version: %s\", cv.Metadata.Version)\n\t}\n\n\tcv, err = i.Get(\"setter\", \"0.1.9+alpha\")\n\tif err != nil || cv.Metadata.Version != \"0.1.9+alpha\" {\n\t\tt.Errorf(\"Expected version: 0.1.9+alpha\")\n\t}\n}\n\nfunc TestLoadIndex(t *testing.T) {\n\tb, err := ioutil.ReadFile(testfile)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ti, err := loadIndex(b)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tverifyLocalIndex(t, i)\n}\n\nconst indexWithDuplicates = `\napiVersion: v1\nentries:\n  nginx:\n    - urls:\n        - https://kubernetes-charts.storage.googleapis.com/nginx-0.2.0.tgz\n      name: nginx\n      description: string\n      version: 0.2.0\n      home: https://github.com/something/else\n      digest: \"sha256:1234567890abcdef\"\n  nginx:\n    - urls:\n        - https://kubernetes-charts.storage.googleapis.com/alpine-1.0.0.tgz\n        - http://storage2.googleapis.com/kubernetes-charts/alpine-1.0.0.tgz\n      name: alpine\n      description: string\n      version: 1.0.0\n      home: https://github.com/something\n      digest: \"sha256:1234567890abcdef\"\n`\n\n// TestLoadIndex_Duplicates is a regression to make sure that we don't non-deterministically allow duplicate packages.\nfunc TestLoadIndex_Duplicates(t *testing.T) {\n\tif _, err := loadIndex([]byte(indexWithDuplicates)); err == nil {\n\t\tt.Errorf(\"Expected an error when duplicate entries are present\")\n\t}\n}\n\nfunc TestLoadIndexFile(t *testing.T) {\n\ti, err := LoadIndexFile(testfile)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tverifyLocalIndex(t, i)\n}\n\nfunc TestLoadUnorderedIndex(t *testing.T) {\n\tb, err := ioutil.ReadFile(unorderedTestfile)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ti, err := loadIndex(b)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tverifyLocalIndex(t, i)\n}\n\nfunc TestMerge(t *testing.T) {\n\tind1 := NewIndexFile()\n\tind1.Add(&chart.Metadata{\n\t\tName:    \"dreadnought\",\n\t\tVersion: \"0.1.0\",\n\t}, \"dreadnought-0.1.0.tgz\", \"http://example.com\", \"aaaa\")\n\n\tind2 := NewIndexFile()\n\tind2.Add(&chart.Metadata{\n\t\tName:    \"dreadnought\",\n\t\tVersion: \"0.2.0\",\n\t}, \"dreadnought-0.2.0.tgz\", \"http://example.com\", \"aaaabbbb\")\n\tind2.Add(&chart.Metadata{\n\t\tName:    \"doughnut\",\n\t\tVersion: \"0.2.0\",\n\t}, \"doughnut-0.2.0.tgz\", \"http://example.com\", \"ccccbbbb\")\n\n\tind1.Merge(ind2)\n\n\tif len(ind1.Entries) != 2 {\n\t\tt.Errorf(\"Expected 2 entries, got %d\", len(ind1.Entries))\n\t\tvs := ind1.Entries[\"dreadnought\"]\n\t\tif len(vs) != 2 {\n\t\t\tt.Errorf(\"Expected 2 versions, got %d\", len(vs))\n\t\t}\n\t\tv := vs[0]\n\t\tif v.Version != \"0.2.0\" {\n\t\t\tt.Errorf(\"Expected %q version to be 0.2.0, got %s\", v.Name, v.Version)\n\t\t}\n\t}\n\n}\n\nfunc TestDownloadIndexFile(t *testing.T) {\n\tt.Run(\"should  download index file\", func(t *testing.T) {\n\t\tsrv, err := startLocalServerForTests(nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer srv.Close()\n\n\t\tr, err := NewChartRepository(&Entry{\n\t\t\tName: testRepo,\n\t\t\tURL:  srv.URL,\n\t\t}, getter.All(&cli.EnvSettings{}))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Problem creating chart repository from %s: %v\", testRepo, err)\n\t\t}\n\n\t\tidx, err := r.DownloadIndexFile()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to download index file to %s: %#v\", idx, err)\n\t\t}\n\n\t\tif _, err := os.Stat(idx); err != nil {\n\t\t\tt.Fatalf(\"error finding created index file: %#v\", err)\n\t\t}\n\n\t\tb, err := ioutil.ReadFile(idx)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"error reading index file: %#v\", err)\n\t\t}\n\n\t\ti, err := loadIndex(b)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Index %q failed to parse: %s\", testfile, err)\n\t\t}\n\t\tverifyLocalIndex(t, i)\n\n\t\t// Check that charts file is also created\n\t\tidx = filepath.Join(r.CachePath, helmpath.CacheChartsFile(r.Config.Name))\n\t\tif _, err := os.Stat(idx); err != nil {\n\t\t\tt.Fatalf(\"error finding created charts file: %#v\", err)\n\t\t}\n\n\t\tb, err = ioutil.ReadFile(idx)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"error reading charts file: %#v\", err)\n\t\t}\n\t\tverifyLocalChartsFile(t, b, i)\n\t})\n\n\tt.Run(\"should not decode the path in the repo url while downloading index\", func(t *testing.T) {\n\t\tchartRepoURLPath := \"/some%2Fpath/test\"\n\t\tfileBytes, err := ioutil.ReadFile(\"testdata/local-index.yaml\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\thandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tif r.URL.RawPath == chartRepoURLPath+\"/index.yaml\" {\n\t\t\t\tw.Write(fileBytes)\n\t\t\t}\n\t\t})\n\t\tsrv, err := startLocalServerForTests(handler)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer srv.Close()\n\n\t\tr, err := NewChartRepository(&Entry{\n\t\t\tName: testRepo,\n\t\t\tURL:  srv.URL + chartRepoURLPath,\n\t\t}, getter.All(&cli.EnvSettings{}))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Problem creating chart repository from %s: %v\", testRepo, err)\n\t\t}\n\n\t\tidx, err := r.DownloadIndexFile()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to download index file to %s: %#v\", idx, err)\n\t\t}\n\n\t\tif _, err := os.Stat(idx); err != nil {\n\t\t\tt.Fatalf(\"error finding created index file: %#v\", err)\n\t\t}\n\n\t\tb, err := ioutil.ReadFile(idx)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"error reading index file: %#v\", err)\n\t\t}\n\n\t\ti, err := loadIndex(b)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Index %q failed to parse: %s\", testfile, err)\n\t\t}\n\t\tverifyLocalIndex(t, i)\n\n\t\t// Check that charts file is also created\n\t\tidx = filepath.Join(r.CachePath, helmpath.CacheChartsFile(r.Config.Name))\n\t\tif _, err := os.Stat(idx); err != nil {\n\t\t\tt.Fatalf(\"error finding created charts file: %#v\", err)\n\t\t}\n\n\t\tb, err = ioutil.ReadFile(idx)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"error reading charts file: %#v\", err)\n\t\t}\n\t\tverifyLocalChartsFile(t, b, i)\n\t})\n}\n\nfunc verifyLocalIndex(t *testing.T, i *IndexFile) {\n\tnumEntries := len(i.Entries)\n\tif numEntries != 3 {\n\t\tt.Errorf(\"Expected 3 entries in index file but got %d\", numEntries)\n\t}\n\n\talpine, ok := i.Entries[\"alpine\"]\n\tif !ok {\n\t\tt.Fatalf(\"'alpine' section not found.\")\n\t}\n\n\tif l := len(alpine); l != 1 {\n\t\tt.Fatalf(\"'alpine' should have 1 chart, got %d\", l)\n\t}\n\n\tnginx, ok := i.Entries[\"nginx\"]\n\tif !ok || len(nginx) != 2 {\n\t\tt.Fatalf(\"Expected 2 nginx entries\")\n\t}\n\n\texpects := []*ChartVersion{\n\t\t{\n\t\t\tMetadata: &chart.Metadata{\n\t\t\t\tName:        \"alpine\",\n\t\t\t\tDescription: \"string\",\n\t\t\t\tVersion:     \"1.0.0\",\n\t\t\t\tKeywords:    []string{\"linux\", \"alpine\", \"small\", \"sumtin\"},\n\t\t\t\tHome:        \"https://github.com/something\",\n\t\t\t},\n\t\t\tURLs: []string{\n\t\t\t\t\"https://kubernetes-charts.storage.googleapis.com/alpine-1.0.0.tgz\",\n\t\t\t\t\"http://storage2.googleapis.com/kubernetes-charts/alpine-1.0.0.tgz\",\n\t\t\t},\n\t\t\tDigest: \"sha256:1234567890abcdef\",\n\t\t},\n\t\t{\n\t\t\tMetadata: &chart.Metadata{\n\t\t\t\tName:        \"nginx\",\n\t\t\t\tDescription: \"string\",\n\t\t\t\tVersion:     \"0.2.0\",\n\t\t\t\tKeywords:    []string{\"popular\", \"web server\", \"proxy\"},\n\t\t\t\tHome:        \"https://github.com/something/else\",\n\t\t\t},\n\t\t\tURLs: []string{\n\t\t\t\t\"https://kubernetes-charts.storage.googleapis.com/nginx-0.2.0.tgz\",\n\t\t\t},\n\t\t\tDigest: \"sha256:1234567890abcdef\",\n\t\t},\n\t\t{\n\t\t\tMetadata: &chart.Metadata{\n\t\t\t\tName:        \"nginx\",\n\t\t\t\tDescription: \"string\",\n\t\t\t\tVersion:     \"0.1.0\",\n\t\t\t\tKeywords:    []string{\"popular\", \"web server\", \"proxy\"},\n\t\t\t\tHome:        \"https://github.com/something\",\n\t\t\t},\n\t\t\tURLs: []string{\n\t\t\t\t\"https://kubernetes-charts.storage.googleapis.com/nginx-0.1.0.tgz\",\n\t\t\t},\n\t\t\tDigest: \"sha256:1234567890abcdef\",\n\t\t},\n\t}\n\ttests := []*ChartVersion{alpine[0], nginx[0], nginx[1]}\n\n\tfor i, tt := range tests {\n\t\texpect := expects[i]\n\t\tif tt.Name != expect.Name {\n\t\t\tt.Errorf(\"Expected name %q, got %q\", expect.Name, tt.Name)\n\t\t}\n\t\tif tt.Description != expect.Description {\n\t\t\tt.Errorf(\"Expected description %q, got %q\", expect.Description, tt.Description)\n\t\t}\n\t\tif tt.Version != expect.Version {\n\t\t\tt.Errorf(\"Expected version %q, got %q\", expect.Version, tt.Version)\n\t\t}\n\t\tif tt.Digest != expect.Digest {\n\t\t\tt.Errorf(\"Expected digest %q, got %q\", expect.Digest, tt.Digest)\n\t\t}\n\t\tif tt.Home != expect.Home {\n\t\t\tt.Errorf(\"Expected home %q, got %q\", expect.Home, tt.Home)\n\t\t}\n\n\t\tfor i, url := range tt.URLs {\n\t\t\tif url != expect.URLs[i] {\n\t\t\t\tt.Errorf(\"Expected URL %q, got %q\", expect.URLs[i], url)\n\t\t\t}\n\t\t}\n\t\tfor i, kw := range tt.Keywords {\n\t\t\tif kw != expect.Keywords[i] {\n\t\t\t\tt.Errorf(\"Expected keywords %q, got %q\", expect.Keywords[i], kw)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc verifyLocalChartsFile(t *testing.T, chartsContent []byte, indexContent *IndexFile) {\n\tvar expected, real []string\n\tfor chart := range indexContent.Entries {\n\t\texpected = append(expected, chart)\n\t}\n\tsort.Strings(expected)\n\n\tscanner := bufio.NewScanner(bytes.NewReader(chartsContent))\n\tfor scanner.Scan() {\n\t\treal = append(real, scanner.Text())\n\t}\n\tsort.Strings(real)\n\n\tif strings.Join(expected, \" \") != strings.Join(real, \" \") {\n\t\tt.Errorf(\"Cached charts file content unexpected. Expected:\\n%s\\ngot:\\n%s\", expected, real)\n\t}\n}\n\nfunc TestIndexDirectory(t *testing.T) {\n\tdir := \"testdata/repository\"\n\tindex, err := IndexDirectory(dir, \"http://localhost:8080\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif l := len(index.Entries); l != 3 {\n\t\tt.Fatalf(\"Expected 3 entries, got %d\", l)\n\t}\n\n\t// Other things test the entry generation more thoroughly. We just test a\n\t// few fields.\n\n\tcorpus := []struct{ chartName, downloadLink string }{\n\t\t{\"frobnitz\", \"http://localhost:8080/frobnitz-1.2.3.tgz\"},\n\t\t{\"zarthal\", \"http://localhost:8080/universe/zarthal-1.0.0.tgz\"},\n\t}\n\n\tfor _, test := range corpus {\n\t\tcname := test.chartName\n\t\tfrobs, ok := index.Entries[cname]\n\t\tif !ok {\n\t\t\tt.Fatalf(\"Could not read chart %s\", cname)\n\t\t}\n\n\t\tfrob := frobs[0]\n\t\tif frob.Digest == \"\" {\n\t\t\tt.Errorf(\"Missing digest of file %s.\", frob.Name)\n\t\t}\n\t\tif frob.URLs[0] != test.downloadLink {\n\t\t\tt.Errorf(\"Unexpected URLs: %v\", frob.URLs)\n\t\t}\n\t\tif frob.Name != cname {\n\t\t\tt.Errorf(\"Expected %q, got %q\", cname, frob.Name)\n\t\t}\n\t}\n}\n\nfunc TestIndexAdd(t *testing.T) {\n\ti := NewIndexFile()\n\ti.Add(&chart.Metadata{Name: \"clipper\", Version: \"0.1.0\"}, \"clipper-0.1.0.tgz\", \"http://example.com/charts\", \"sha256:1234567890\")\n\n\tif i.Entries[\"clipper\"][0].URLs[0] != \"http://example.com/charts/clipper-0.1.0.tgz\" {\n\t\tt.Errorf(\"Expected http://example.com/charts/clipper-0.1.0.tgz, got %s\", i.Entries[\"clipper\"][0].URLs[0])\n\t}\n\n\ti.Add(&chart.Metadata{Name: \"alpine\", Version: \"0.1.0\"}, \"/home/charts/alpine-0.1.0.tgz\", \"http://example.com/charts\", \"sha256:1234567890\")\n\n\tif i.Entries[\"alpine\"][0].URLs[0] != \"http://example.com/charts/alpine-0.1.0.tgz\" {\n\t\tt.Errorf(\"Expected http://example.com/charts/alpine-0.1.0.tgz, got %s\", i.Entries[\"alpine\"][0].URLs[0])\n\t}\n\n\ti.Add(&chart.Metadata{Name: \"deis\", Version: \"0.1.0\"}, \"/home/charts/deis-0.1.0.tgz\", \"http://example.com/charts/\", \"sha256:1234567890\")\n\n\tif i.Entries[\"deis\"][0].URLs[0] != \"http://example.com/charts/deis-0.1.0.tgz\" {\n\t\tt.Errorf(\"Expected http://example.com/charts/deis-0.1.0.tgz, got %s\", i.Entries[\"deis\"][0].URLs[0])\n\t}\n}\n\nfunc TestIndexWrite(t *testing.T) {\n\ti := NewIndexFile()\n\ti.Add(&chart.Metadata{Name: \"clipper\", Version: \"0.1.0\"}, \"clipper-0.1.0.tgz\", \"http://example.com/charts\", \"sha256:1234567890\")\n\tdir, err := ioutil.TempDir(\"\", \"helm-tmp\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.RemoveAll(dir)\n\ttestpath := filepath.Join(dir, \"test\")\n\ti.WriteFile(testpath, 0600)\n\n\tgot, err := ioutil.ReadFile(testpath)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !strings.Contains(string(got), \"clipper-0.1.0.tgz\") {\n\t\tt.Fatal(\"Index files doesn't contain expected content\")\n\t}\n}\n"], "filenames": ["pkg/downloader/chart_downloader_test.go", "pkg/repo/index.go", "pkg/repo/index_test.go"], "buggy_code_start_loc": [74, 230, 97], "buggy_code_end_loc": [75, 285, 97], "fixing_code_start_loc": [74, 231, 98], "fixing_code_end_loc": [75, 302, 127], "type": "NVD-CWE-Other", "message": "In Helm before versions 2.16.11 and 3.3.2, a Helm repository can contain duplicates of the same chart, with the last one always used. If a repository is compromised, this lowers the level of access that an attacker needs to inject a bad chart into a repository. To perform this attack, an attacker must have write access to the index file (which can occur during a MITM attack on a non-SSL connection). This issue has been patched in Helm 3.3.2 and 2.16.11. A possible workaround is to manually review the index file in the Helm repository cache before installing software.", "other": {"cve": {"id": "CVE-2020-15185", "sourceIdentifier": "security-advisories@github.com", "published": "2020-09-17T22:15:12.443", "lastModified": "2022-08-05T19:31:23.850", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Helm before versions 2.16.11 and 3.3.2, a Helm repository can contain duplicates of the same chart, with the last one always used. If a repository is compromised, this lowers the level of access that an attacker needs to inject a bad chart into a repository. To perform this attack, an attacker must have write access to the index file (which can occur during a MITM attack on a non-SSL connection). This issue has been patched in Helm 3.3.2 and 2.16.11. A possible workaround is to manually review the index file in the Helm repository cache before installing software."}, {"lang": "es", "value": "En Helm versiones anteriores a 2.16.11 y 3.3.2, un repositorio de Helm puede contener duplicados del mismo gr\u00e1fico, y siempre se usa el \u00faltimo.&#xa0;Si un repositorio est\u00e1 comprometido, esto reduce el nivel de acceso que necesita un atacante para inyectar un gr\u00e1fico incorrecto en un repositorio.&#xa0;Para llevar a cabo este ataque, un atacante necesita tener acceso de escritura al archivo de index (lo que puede ocurrir durante un ataque MITM en una conexi\u00f3n no SSL).&#xa0;Este problema ha sido corregido en Helm versiones 3.3.2 y 2.16.11.&#xa0;Una posible soluci\u00f3n es revisar manualmente el archivo  index en la cach\u00e9 del repositorio de Helm antes de instalar el software"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 2.7, "baseSeverity": "LOW"}, "exploitabilityScore": 1.2, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 2.2, "baseSeverity": "LOW"}, "exploitabilityScore": 0.7, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-694"}, {"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:helm:helm:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.16.11", "matchCriteriaId": "455BCCE5-1D43-4E59-9591-E84B52DAAF0B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:helm:helm:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "3.3.2", "matchCriteriaId": "B462D769-3FC0-4079-8B48-863F013662EF"}]}]}], "references": [{"url": "https://github.com/helm/helm/commit/055dd41cbe53ce131ab0357524a7f6729e6e40dc", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/helm/helm/security/advisories/GHSA-jm56-5h66-w453", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/helm/helm/commit/055dd41cbe53ce131ab0357524a7f6729e6e40dc"}}