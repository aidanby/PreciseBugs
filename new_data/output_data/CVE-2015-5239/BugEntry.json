{"buggy_code": ["/*\n * QEMU VNC display driver\n *\n * Copyright (C) 2006 Anthony Liguori <anthony@codemonkey.ws>\n * Copyright (C) 2006 Fabrice Bellard\n * Copyright (C) 2009 Red Hat, Inc\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"vnc.h\"\n#include \"vnc-jobs.h\"\n#include \"trace.h\"\n#include \"sysemu/sysemu.h\"\n#include \"qemu/sockets.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/acl.h\"\n#include \"qapi/qmp/types.h\"\n#include \"qmp-commands.h\"\n#include \"qemu/osdep.h\"\n#include \"ui/input.h\"\n#include \"qapi-event.h\"\n\n#define VNC_REFRESH_INTERVAL_BASE GUI_REFRESH_INTERVAL_DEFAULT\n#define VNC_REFRESH_INTERVAL_INC  50\n#define VNC_REFRESH_INTERVAL_MAX  GUI_REFRESH_INTERVAL_IDLE\nstatic const struct timeval VNC_REFRESH_STATS = { 0, 500000 };\nstatic const struct timeval VNC_REFRESH_LOSSY = { 2, 0 };\n\n#include \"vnc_keysym.h\"\n#include \"d3des.h\"\n\nstatic VncDisplay *vnc_display; /* needed for info vnc */\n\nstatic int vnc_cursor_define(VncState *vs);\nstatic void vnc_release_modifiers(VncState *vs);\n\nstatic void vnc_set_share_mode(VncState *vs, VncShareMode mode)\n{\n#ifdef _VNC_DEBUG\n    static const char *mn[] = {\n        [0]                           = \"undefined\",\n        [VNC_SHARE_MODE_CONNECTING]   = \"connecting\",\n        [VNC_SHARE_MODE_SHARED]       = \"shared\",\n        [VNC_SHARE_MODE_EXCLUSIVE]    = \"exclusive\",\n        [VNC_SHARE_MODE_DISCONNECTED] = \"disconnected\",\n    };\n    fprintf(stderr, \"%s/%d: %s -> %s\\n\", __func__,\n            vs->csock, mn[vs->share_mode], mn[mode]);\n#endif\n\n    if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) {\n        vs->vd->num_exclusive--;\n    }\n    vs->share_mode = mode;\n    if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) {\n        vs->vd->num_exclusive++;\n    }\n}\n\nstatic char *addr_to_string(const char *format,\n                            struct sockaddr_storage *sa,\n                            socklen_t salen) {\n    char *addr;\n    char host[NI_MAXHOST];\n    char serv[NI_MAXSERV];\n    int err;\n    size_t addrlen;\n\n    if ((err = getnameinfo((struct sockaddr *)sa, salen,\n                           host, sizeof(host),\n                           serv, sizeof(serv),\n                           NI_NUMERICHOST | NI_NUMERICSERV)) != 0) {\n        VNC_DEBUG(\"Cannot resolve address %d: %s\\n\",\n                  err, gai_strerror(err));\n        return NULL;\n    }\n\n    /* Enough for the existing format + the 2 vars we're\n     * substituting in. */\n    addrlen = strlen(format) + strlen(host) + strlen(serv);\n    addr = g_malloc(addrlen + 1);\n    snprintf(addr, addrlen, format, host, serv);\n    addr[addrlen] = '\\0';\n\n    return addr;\n}\n\n\nchar *vnc_socket_local_addr(const char *format, int fd) {\n    struct sockaddr_storage sa;\n    socklen_t salen;\n\n    salen = sizeof(sa);\n    if (getsockname(fd, (struct sockaddr*)&sa, &salen) < 0)\n        return NULL;\n\n    return addr_to_string(format, &sa, salen);\n}\n\nchar *vnc_socket_remote_addr(const char *format, int fd) {\n    struct sockaddr_storage sa;\n    socklen_t salen;\n\n    salen = sizeof(sa);\n    if (getpeername(fd, (struct sockaddr*)&sa, &salen) < 0)\n        return NULL;\n\n    return addr_to_string(format, &sa, salen);\n}\n\nstatic VncBasicInfo *vnc_basic_info_get(struct sockaddr_storage *sa,\n                                        socklen_t salen)\n{\n    VncBasicInfo *info;\n    char host[NI_MAXHOST];\n    char serv[NI_MAXSERV];\n    int err;\n\n    if ((err = getnameinfo((struct sockaddr *)sa, salen,\n                           host, sizeof(host),\n                           serv, sizeof(serv),\n                           NI_NUMERICHOST | NI_NUMERICSERV)) != 0) {\n        VNC_DEBUG(\"Cannot resolve address %d: %s\\n\",\n                  err, gai_strerror(err));\n        return NULL;\n    }\n\n    info = g_malloc0(sizeof(VncBasicInfo));\n    info->host = g_strdup(host);\n    info->service = g_strdup(serv);\n    info->family = inet_netfamily(sa->ss_family);\n    return info;\n}\n\nstatic VncBasicInfo *vnc_basic_info_get_from_server_addr(int fd)\n{\n    struct sockaddr_storage sa;\n    socklen_t salen;\n\n    salen = sizeof(sa);\n    if (getsockname(fd, (struct sockaddr*)&sa, &salen) < 0) {\n        return NULL;\n    }\n\n    return vnc_basic_info_get(&sa, salen);\n}\n\nstatic VncBasicInfo *vnc_basic_info_get_from_remote_addr(int fd)\n{\n    struct sockaddr_storage sa;\n    socklen_t salen;\n\n    salen = sizeof(sa);\n    if (getpeername(fd, (struct sockaddr*)&sa, &salen) < 0) {\n        return NULL;\n    }\n\n    return vnc_basic_info_get(&sa, salen);\n}\n\nstatic const char *vnc_auth_name(VncDisplay *vd) {\n    switch (vd->auth) {\n    case VNC_AUTH_INVALID:\n        return \"invalid\";\n    case VNC_AUTH_NONE:\n        return \"none\";\n    case VNC_AUTH_VNC:\n        return \"vnc\";\n    case VNC_AUTH_RA2:\n        return \"ra2\";\n    case VNC_AUTH_RA2NE:\n        return \"ra2ne\";\n    case VNC_AUTH_TIGHT:\n        return \"tight\";\n    case VNC_AUTH_ULTRA:\n        return \"ultra\";\n    case VNC_AUTH_TLS:\n        return \"tls\";\n    case VNC_AUTH_VENCRYPT:\n#ifdef CONFIG_VNC_TLS\n        switch (vd->subauth) {\n        case VNC_AUTH_VENCRYPT_PLAIN:\n            return \"vencrypt+plain\";\n        case VNC_AUTH_VENCRYPT_TLSNONE:\n            return \"vencrypt+tls+none\";\n        case VNC_AUTH_VENCRYPT_TLSVNC:\n            return \"vencrypt+tls+vnc\";\n        case VNC_AUTH_VENCRYPT_TLSPLAIN:\n            return \"vencrypt+tls+plain\";\n        case VNC_AUTH_VENCRYPT_X509NONE:\n            return \"vencrypt+x509+none\";\n        case VNC_AUTH_VENCRYPT_X509VNC:\n            return \"vencrypt+x509+vnc\";\n        case VNC_AUTH_VENCRYPT_X509PLAIN:\n            return \"vencrypt+x509+plain\";\n        case VNC_AUTH_VENCRYPT_TLSSASL:\n            return \"vencrypt+tls+sasl\";\n        case VNC_AUTH_VENCRYPT_X509SASL:\n            return \"vencrypt+x509+sasl\";\n        default:\n            return \"vencrypt\";\n        }\n#else\n        return \"vencrypt\";\n#endif\n    case VNC_AUTH_SASL:\n        return \"sasl\";\n    }\n    return \"unknown\";\n}\n\nstatic VncServerInfo *vnc_server_info_get(void)\n{\n    VncServerInfo *info;\n    VncBasicInfo *bi = vnc_basic_info_get_from_server_addr(vnc_display->lsock);\n    if (!bi) {\n        return NULL;\n    }\n\n    info = g_malloc(sizeof(*info));\n    info->base = bi;\n    info->has_auth = true;\n    info->auth = g_strdup(vnc_auth_name(vnc_display));\n    return info;\n}\n\nstatic void vnc_client_cache_auth(VncState *client)\n{\n    if (!client->info) {\n        return;\n    }\n\n#ifdef CONFIG_VNC_TLS\n    if (client->tls.session &&\n        client->tls.dname) {\n        client->info->has_x509_dname = true;\n        client->info->x509_dname = g_strdup(client->tls.dname);\n    }\n#endif\n#ifdef CONFIG_VNC_SASL\n    if (client->sasl.conn &&\n        client->sasl.username) {\n        client->info->has_sasl_username = true;\n        client->info->sasl_username = g_strdup(client->sasl.username);\n    }\n#endif\n}\n\nstatic void vnc_client_cache_addr(VncState *client)\n{\n    VncBasicInfo *bi = vnc_basic_info_get_from_remote_addr(client->csock);\n\n    if (bi) {\n        client->info = g_malloc0(sizeof(*client->info));\n        client->info->base = bi;\n    }\n}\n\nstatic void vnc_qmp_event(VncState *vs, QAPIEvent event)\n{\n    VncServerInfo *si;\n\n    if (!vs->info) {\n        return;\n    }\n    g_assert(vs->info->base);\n\n    si = vnc_server_info_get();\n    if (!si) {\n        return;\n    }\n\n    switch (event) {\n    case QAPI_EVENT_VNC_CONNECTED:\n        qapi_event_send_vnc_connected(si, vs->info->base, &error_abort);\n        break;\n    case QAPI_EVENT_VNC_INITIALIZED:\n        qapi_event_send_vnc_initialized(si, vs->info, &error_abort);\n        break;\n    case QAPI_EVENT_VNC_DISCONNECTED:\n        qapi_event_send_vnc_disconnected(si, vs->info, &error_abort);\n        break;\n    default:\n        break;\n    }\n\n    qapi_free_VncServerInfo(si);\n}\n\nstatic VncClientInfo *qmp_query_vnc_client(const VncState *client)\n{\n    struct sockaddr_storage sa;\n    socklen_t salen = sizeof(sa);\n    char host[NI_MAXHOST];\n    char serv[NI_MAXSERV];\n    VncClientInfo *info;\n\n    if (getpeername(client->csock, (struct sockaddr *)&sa, &salen) < 0) {\n        return NULL;\n    }\n\n    if (getnameinfo((struct sockaddr *)&sa, salen,\n                    host, sizeof(host),\n                    serv, sizeof(serv),\n                    NI_NUMERICHOST | NI_NUMERICSERV) < 0) {\n        return NULL;\n    }\n\n    info = g_malloc0(sizeof(*info));\n    info->base = g_malloc0(sizeof(*info->base));\n    info->base->host = g_strdup(host);\n    info->base->service = g_strdup(serv);\n    info->base->family = inet_netfamily(sa.ss_family);\n\n#ifdef CONFIG_VNC_TLS\n    if (client->tls.session && client->tls.dname) {\n        info->has_x509_dname = true;\n        info->x509_dname = g_strdup(client->tls.dname);\n    }\n#endif\n#ifdef CONFIG_VNC_SASL\n    if (client->sasl.conn && client->sasl.username) {\n        info->has_sasl_username = true;\n        info->sasl_username = g_strdup(client->sasl.username);\n    }\n#endif\n\n    return info;\n}\n\nVncInfo *qmp_query_vnc(Error **errp)\n{\n    VncInfo *info = g_malloc0(sizeof(*info));\n\n    if (vnc_display == NULL || vnc_display->display == NULL) {\n        info->enabled = false;\n    } else {\n        VncClientInfoList *cur_item = NULL;\n        struct sockaddr_storage sa;\n        socklen_t salen = sizeof(sa);\n        char host[NI_MAXHOST];\n        char serv[NI_MAXSERV];\n        VncState *client;\n\n        info->enabled = true;\n\n        /* for compatibility with the original command */\n        info->has_clients = true;\n\n        QTAILQ_FOREACH(client, &vnc_display->clients, next) {\n            VncClientInfoList *cinfo = g_malloc0(sizeof(*info));\n            cinfo->value = qmp_query_vnc_client(client);\n\n            /* XXX: waiting for the qapi to support GSList */\n            if (!cur_item) {\n                info->clients = cur_item = cinfo;\n            } else {\n                cur_item->next = cinfo;\n                cur_item = cinfo;\n            }\n        }\n\n        if (vnc_display->lsock == -1) {\n            return info;\n        }\n\n        if (getsockname(vnc_display->lsock, (struct sockaddr *)&sa,\n                        &salen) == -1) {\n            error_set(errp, QERR_UNDEFINED_ERROR);\n            goto out_error;\n        }\n\n        if (getnameinfo((struct sockaddr *)&sa, salen,\n                        host, sizeof(host),\n                        serv, sizeof(serv),\n                        NI_NUMERICHOST | NI_NUMERICSERV) < 0) {\n            error_set(errp, QERR_UNDEFINED_ERROR);\n            goto out_error;\n        }\n\n        info->has_host = true;\n        info->host = g_strdup(host);\n\n        info->has_service = true;\n        info->service = g_strdup(serv);\n\n        info->has_family = true;\n        info->family = inet_netfamily(sa.ss_family);\n\n        info->has_auth = true;\n        info->auth = g_strdup(vnc_auth_name(vnc_display));\n    }\n\n    return info;\n\nout_error:\n    qapi_free_VncInfo(info);\n    return NULL;\n}\n\n/* TODO\n   1) Get the queue working for IO.\n   2) there is some weirdness when using the -S option (the screen is grey\n      and not totally invalidated\n   3) resolutions > 1024\n*/\n\nstatic int vnc_update_client(VncState *vs, int has_dirty, bool sync);\nstatic void vnc_disconnect_start(VncState *vs);\n\nstatic void vnc_colordepth(VncState *vs);\nstatic void framebuffer_update_request(VncState *vs, int incremental,\n                                       int x_position, int y_position,\n                                       int w, int h);\nstatic void vnc_refresh(DisplayChangeListener *dcl);\nstatic int vnc_refresh_server_surface(VncDisplay *vd);\n\nstatic void vnc_dpy_update(DisplayChangeListener *dcl,\n                           int x, int y, int w, int h)\n{\n    VncDisplay *vd = container_of(dcl, VncDisplay, dcl);\n    struct VncSurface *s = &vd->guest;\n    int width = surface_width(vd->ds);\n    int height = surface_height(vd->ds);\n\n    /* this is needed this to ensure we updated all affected\n     * blocks if x % VNC_DIRTY_PIXELS_PER_BIT != 0 */\n    w += (x % VNC_DIRTY_PIXELS_PER_BIT);\n    x -= (x % VNC_DIRTY_PIXELS_PER_BIT);\n\n    x = MIN(x, width);\n    y = MIN(y, height);\n    w = MIN(x + w, width) - x;\n    h = MIN(y + h, height);\n\n    for (; y < h; y++) {\n        bitmap_set(s->dirty[y], x / VNC_DIRTY_PIXELS_PER_BIT,\n                   DIV_ROUND_UP(w, VNC_DIRTY_PIXELS_PER_BIT));\n    }\n}\n\nvoid vnc_framebuffer_update(VncState *vs, int x, int y, int w, int h,\n                            int32_t encoding)\n{\n    vnc_write_u16(vs, x);\n    vnc_write_u16(vs, y);\n    vnc_write_u16(vs, w);\n    vnc_write_u16(vs, h);\n\n    vnc_write_s32(vs, encoding);\n}\n\nvoid buffer_reserve(Buffer *buffer, size_t len)\n{\n    if ((buffer->capacity - buffer->offset) < len) {\n        buffer->capacity += (len + 1024);\n        buffer->buffer = g_realloc(buffer->buffer, buffer->capacity);\n        if (buffer->buffer == NULL) {\n            fprintf(stderr, \"vnc: out of memory\\n\");\n            exit(1);\n        }\n    }\n}\n\nstatic int buffer_empty(Buffer *buffer)\n{\n    return buffer->offset == 0;\n}\n\nuint8_t *buffer_end(Buffer *buffer)\n{\n    return buffer->buffer + buffer->offset;\n}\n\nvoid buffer_reset(Buffer *buffer)\n{\n        buffer->offset = 0;\n}\n\nvoid buffer_free(Buffer *buffer)\n{\n    g_free(buffer->buffer);\n    buffer->offset = 0;\n    buffer->capacity = 0;\n    buffer->buffer = NULL;\n}\n\nvoid buffer_append(Buffer *buffer, const void *data, size_t len)\n{\n    memcpy(buffer->buffer + buffer->offset, data, len);\n    buffer->offset += len;\n}\n\nvoid buffer_advance(Buffer *buf, size_t len)\n{\n    memmove(buf->buffer, buf->buffer + len,\n            (buf->offset - len));\n    buf->offset -= len;\n}\n\nstatic void vnc_desktop_resize(VncState *vs)\n{\n    DisplaySurface *ds = vs->vd->ds;\n\n    if (vs->csock == -1 || !vnc_has_feature(vs, VNC_FEATURE_RESIZE)) {\n        return;\n    }\n    if (vs->client_width == surface_width(ds) &&\n        vs->client_height == surface_height(ds)) {\n        return;\n    }\n    vs->client_width = surface_width(ds);\n    vs->client_height = surface_height(ds);\n    vnc_lock_output(vs);\n    vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n    vnc_write_u8(vs, 0);\n    vnc_write_u16(vs, 1); /* number of rects */\n    vnc_framebuffer_update(vs, 0, 0, vs->client_width, vs->client_height,\n                           VNC_ENCODING_DESKTOPRESIZE);\n    vnc_unlock_output(vs);\n    vnc_flush(vs);\n}\n\nstatic void vnc_abort_display_jobs(VncDisplay *vd)\n{\n    VncState *vs;\n\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        vnc_lock_output(vs);\n        vs->abort = true;\n        vnc_unlock_output(vs);\n    }\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        vnc_jobs_join(vs);\n    }\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        vnc_lock_output(vs);\n        vs->abort = false;\n        vnc_unlock_output(vs);\n    }\n}\n\nint vnc_server_fb_stride(VncDisplay *vd)\n{\n    return pixman_image_get_stride(vd->server);\n}\n\nvoid *vnc_server_fb_ptr(VncDisplay *vd, int x, int y)\n{\n    uint8_t *ptr;\n\n    ptr  = (uint8_t *)pixman_image_get_data(vd->server);\n    ptr += y * vnc_server_fb_stride(vd);\n    ptr += x * VNC_SERVER_FB_BYTES;\n    return ptr;\n}\n/* this sets only the visible pixels of a dirty bitmap */\n#define VNC_SET_VISIBLE_PIXELS_DIRTY(bitmap, w, h) {\\\n        int y;\\\n        memset(bitmap, 0x00, sizeof(bitmap));\\\n        for (y = 0; y < h; y++) {\\\n            bitmap_set(bitmap[y], 0,\\\n                       DIV_ROUND_UP(w, VNC_DIRTY_PIXELS_PER_BIT));\\\n        } \\\n    }\n\nstatic void vnc_dpy_switch(DisplayChangeListener *dcl,\n                           DisplaySurface *surface)\n{\n    VncDisplay *vd = container_of(dcl, VncDisplay, dcl);\n    VncState *vs;\n\n    vnc_abort_display_jobs(vd);\n\n    /* server surface */\n    qemu_pixman_image_unref(vd->server);\n    vd->ds = surface;\n    vd->server = pixman_image_create_bits(VNC_SERVER_FB_FORMAT,\n                                          surface_width(vd->ds),\n                                          surface_height(vd->ds),\n                                          NULL, 0);\n\n    /* guest surface */\n#if 0 /* FIXME */\n    if (ds_get_bytes_per_pixel(ds) != vd->guest.ds->pf.bytes_per_pixel)\n        console_color_init(ds);\n#endif\n    qemu_pixman_image_unref(vd->guest.fb);\n    vd->guest.fb = pixman_image_ref(surface->image);\n    vd->guest.format = surface->format;\n    VNC_SET_VISIBLE_PIXELS_DIRTY(vd->guest.dirty,\n                                 surface_width(vd->ds),\n                                 surface_height(vd->ds));\n\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        vnc_colordepth(vs);\n        vnc_desktop_resize(vs);\n        if (vs->vd->cursor) {\n            vnc_cursor_define(vs);\n        }\n        VNC_SET_VISIBLE_PIXELS_DIRTY(vs->dirty,\n                                     surface_width(vd->ds),\n                                     surface_height(vd->ds));\n    }\n}\n\n/* fastest code */\nstatic void vnc_write_pixels_copy(VncState *vs,\n                                  void *pixels, int size)\n{\n    vnc_write(vs, pixels, size);\n}\n\n/* slowest but generic code. */\nvoid vnc_convert_pixel(VncState *vs, uint8_t *buf, uint32_t v)\n{\n    uint8_t r, g, b;\n\n#if VNC_SERVER_FB_FORMAT == PIXMAN_FORMAT(32, PIXMAN_TYPE_ARGB, 0, 8, 8, 8)\n    r = (((v & 0x00ff0000) >> 16) << vs->client_pf.rbits) >> 8;\n    g = (((v & 0x0000ff00) >>  8) << vs->client_pf.gbits) >> 8;\n    b = (((v & 0x000000ff) >>  0) << vs->client_pf.bbits) >> 8;\n#else\n# error need some bits here if you change VNC_SERVER_FB_FORMAT\n#endif\n    v = (r << vs->client_pf.rshift) |\n        (g << vs->client_pf.gshift) |\n        (b << vs->client_pf.bshift);\n    switch (vs->client_pf.bytes_per_pixel) {\n    case 1:\n        buf[0] = v;\n        break;\n    case 2:\n        if (vs->client_be) {\n            buf[0] = v >> 8;\n            buf[1] = v;\n        } else {\n            buf[1] = v >> 8;\n            buf[0] = v;\n        }\n        break;\n    default:\n    case 4:\n        if (vs->client_be) {\n            buf[0] = v >> 24;\n            buf[1] = v >> 16;\n            buf[2] = v >> 8;\n            buf[3] = v;\n        } else {\n            buf[3] = v >> 24;\n            buf[2] = v >> 16;\n            buf[1] = v >> 8;\n            buf[0] = v;\n        }\n        break;\n    }\n}\n\nstatic void vnc_write_pixels_generic(VncState *vs,\n                                     void *pixels1, int size)\n{\n    uint8_t buf[4];\n\n    if (VNC_SERVER_FB_BYTES == 4) {\n        uint32_t *pixels = pixels1;\n        int n, i;\n        n = size >> 2;\n        for (i = 0; i < n; i++) {\n            vnc_convert_pixel(vs, buf, pixels[i]);\n            vnc_write(vs, buf, vs->client_pf.bytes_per_pixel);\n        }\n    }\n}\n\nint vnc_raw_send_framebuffer_update(VncState *vs, int x, int y, int w, int h)\n{\n    int i;\n    uint8_t *row;\n    VncDisplay *vd = vs->vd;\n\n    row = vnc_server_fb_ptr(vd, x, y);\n    for (i = 0; i < h; i++) {\n        vs->write_pixels(vs, row, w * VNC_SERVER_FB_BYTES);\n        row += vnc_server_fb_stride(vd);\n    }\n    return 1;\n}\n\nint vnc_send_framebuffer_update(VncState *vs, int x, int y, int w, int h)\n{\n    int n = 0;\n\n    switch(vs->vnc_encoding) {\n        case VNC_ENCODING_ZLIB:\n            n = vnc_zlib_send_framebuffer_update(vs, x, y, w, h);\n            break;\n        case VNC_ENCODING_HEXTILE:\n            vnc_framebuffer_update(vs, x, y, w, h, VNC_ENCODING_HEXTILE);\n            n = vnc_hextile_send_framebuffer_update(vs, x, y, w, h);\n            break;\n        case VNC_ENCODING_TIGHT:\n            n = vnc_tight_send_framebuffer_update(vs, x, y, w, h);\n            break;\n        case VNC_ENCODING_TIGHT_PNG:\n            n = vnc_tight_png_send_framebuffer_update(vs, x, y, w, h);\n            break;\n        case VNC_ENCODING_ZRLE:\n            n = vnc_zrle_send_framebuffer_update(vs, x, y, w, h);\n            break;\n        case VNC_ENCODING_ZYWRLE:\n            n = vnc_zywrle_send_framebuffer_update(vs, x, y, w, h);\n            break;\n        default:\n            vnc_framebuffer_update(vs, x, y, w, h, VNC_ENCODING_RAW);\n            n = vnc_raw_send_framebuffer_update(vs, x, y, w, h);\n            break;\n    }\n    return n;\n}\n\nstatic void vnc_copy(VncState *vs, int src_x, int src_y, int dst_x, int dst_y, int w, int h)\n{\n    /* send bitblit op to the vnc client */\n    vnc_lock_output(vs);\n    vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n    vnc_write_u8(vs, 0);\n    vnc_write_u16(vs, 1); /* number of rects */\n    vnc_framebuffer_update(vs, dst_x, dst_y, w, h, VNC_ENCODING_COPYRECT);\n    vnc_write_u16(vs, src_x);\n    vnc_write_u16(vs, src_y);\n    vnc_unlock_output(vs);\n    vnc_flush(vs);\n}\n\nstatic void vnc_dpy_copy(DisplayChangeListener *dcl,\n                         int src_x, int src_y,\n                         int dst_x, int dst_y, int w, int h)\n{\n    VncDisplay *vd = container_of(dcl, VncDisplay, dcl);\n    VncState *vs, *vn;\n    uint8_t *src_row;\n    uint8_t *dst_row;\n    int i, x, y, pitch, inc, w_lim, s;\n    int cmp_bytes;\n\n    vnc_refresh_server_surface(vd);\n    QTAILQ_FOREACH_SAFE(vs, &vd->clients, next, vn) {\n        if (vnc_has_feature(vs, VNC_FEATURE_COPYRECT)) {\n            vs->force_update = 1;\n            vnc_update_client(vs, 1, true);\n            /* vs might be free()ed here */\n        }\n    }\n\n    /* do bitblit op on the local surface too */\n    pitch = vnc_server_fb_stride(vd);\n    src_row = vnc_server_fb_ptr(vd, src_x, src_y);\n    dst_row = vnc_server_fb_ptr(vd, dst_x, dst_y);\n    y = dst_y;\n    inc = 1;\n    if (dst_y > src_y) {\n        /* copy backwards */\n        src_row += pitch * (h-1);\n        dst_row += pitch * (h-1);\n        pitch = -pitch;\n        y = dst_y + h - 1;\n        inc = -1;\n    }\n    w_lim = w - (VNC_DIRTY_PIXELS_PER_BIT - (dst_x % VNC_DIRTY_PIXELS_PER_BIT));\n    if (w_lim < 0) {\n        w_lim = w;\n    } else {\n        w_lim = w - (w_lim % VNC_DIRTY_PIXELS_PER_BIT);\n    }\n    for (i = 0; i < h; i++) {\n        for (x = 0; x <= w_lim;\n                x += s, src_row += cmp_bytes, dst_row += cmp_bytes) {\n            if (x == w_lim) {\n                if ((s = w - w_lim) == 0)\n                    break;\n            } else if (!x) {\n                s = (VNC_DIRTY_PIXELS_PER_BIT -\n                    (dst_x % VNC_DIRTY_PIXELS_PER_BIT));\n                s = MIN(s, w_lim);\n            } else {\n                s = VNC_DIRTY_PIXELS_PER_BIT;\n            }\n            cmp_bytes = s * VNC_SERVER_FB_BYTES;\n            if (memcmp(src_row, dst_row, cmp_bytes) == 0)\n                continue;\n            memmove(dst_row, src_row, cmp_bytes);\n            QTAILQ_FOREACH(vs, &vd->clients, next) {\n                if (!vnc_has_feature(vs, VNC_FEATURE_COPYRECT)) {\n                    set_bit(((x + dst_x) / VNC_DIRTY_PIXELS_PER_BIT),\n                            vs->dirty[y]);\n                }\n            }\n        }\n        src_row += pitch - w * VNC_SERVER_FB_BYTES;\n        dst_row += pitch - w * VNC_SERVER_FB_BYTES;\n        y += inc;\n    }\n\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        if (vnc_has_feature(vs, VNC_FEATURE_COPYRECT)) {\n            vnc_copy(vs, src_x, src_y, dst_x, dst_y, w, h);\n        }\n    }\n}\n\nstatic void vnc_mouse_set(DisplayChangeListener *dcl,\n                          int x, int y, int visible)\n{\n    /* can we ask the client(s) to move the pointer ??? */\n}\n\nstatic int vnc_cursor_define(VncState *vs)\n{\n    QEMUCursor *c = vs->vd->cursor;\n    int isize;\n\n    if (vnc_has_feature(vs, VNC_FEATURE_RICH_CURSOR)) {\n        vnc_lock_output(vs);\n        vnc_write_u8(vs,  VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n        vnc_write_u8(vs,  0);  /*  padding     */\n        vnc_write_u16(vs, 1);  /*  # of rects  */\n        vnc_framebuffer_update(vs, c->hot_x, c->hot_y, c->width, c->height,\n                               VNC_ENCODING_RICH_CURSOR);\n        isize = c->width * c->height * vs->client_pf.bytes_per_pixel;\n        vnc_write_pixels_generic(vs, c->data, isize);\n        vnc_write(vs, vs->vd->cursor_mask, vs->vd->cursor_msize);\n        vnc_unlock_output(vs);\n        return 0;\n    }\n    return -1;\n}\n\nstatic void vnc_dpy_cursor_define(DisplayChangeListener *dcl,\n                                  QEMUCursor *c)\n{\n    VncDisplay *vd = vnc_display;\n    VncState *vs;\n\n    cursor_put(vd->cursor);\n    g_free(vd->cursor_mask);\n\n    vd->cursor = c;\n    cursor_get(vd->cursor);\n    vd->cursor_msize = cursor_get_mono_bpl(c) * c->height;\n    vd->cursor_mask = g_malloc0(vd->cursor_msize);\n    cursor_get_mono_mask(c, 0, vd->cursor_mask);\n\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        vnc_cursor_define(vs);\n    }\n}\n\nstatic int find_and_clear_dirty_height(struct VncState *vs,\n                                       int y, int last_x, int x, int height)\n{\n    int h;\n\n    for (h = 1; h < (height - y); h++) {\n        if (!test_bit(last_x, vs->dirty[y + h])) {\n            break;\n        }\n        bitmap_clear(vs->dirty[y + h], last_x, x - last_x);\n    }\n\n    return h;\n}\n\nstatic int vnc_update_client(VncState *vs, int has_dirty, bool sync)\n{\n    if (vs->need_update && vs->csock != -1) {\n        VncDisplay *vd = vs->vd;\n        VncJob *job;\n        int y;\n        int height, width;\n        int n = 0;\n\n        if (vs->output.offset && !vs->audio_cap && !vs->force_update)\n            /* kernel send buffers are full -> drop frames to throttle */\n            return 0;\n\n        if (!has_dirty && !vs->audio_cap && !vs->force_update)\n            return 0;\n\n        /*\n         * Send screen updates to the vnc client using the server\n         * surface and server dirty map.  guest surface updates\n         * happening in parallel don't disturb us, the next pass will\n         * send them to the client.\n         */\n        job = vnc_job_new(vs);\n\n        height = MIN(pixman_image_get_height(vd->server), vs->client_height);\n        width = MIN(pixman_image_get_width(vd->server), vs->client_width);\n\n        y = 0;\n        for (;;) {\n            int x, h;\n            unsigned long x2;\n            unsigned long offset = find_next_bit((unsigned long *) &vs->dirty,\n                                                 height * VNC_DIRTY_BPL(vs),\n                                                 y * VNC_DIRTY_BPL(vs));\n            if (offset == height * VNC_DIRTY_BPL(vs)) {\n                /* no more dirty bits */\n                break;\n            }\n            y = offset / VNC_DIRTY_BPL(vs);\n            x = offset % VNC_DIRTY_BPL(vs);\n            x2 = find_next_zero_bit((unsigned long *) &vs->dirty[y],\n                                    VNC_DIRTY_BPL(vs), x);\n            bitmap_clear(vs->dirty[y], x, x2 - x);\n            h = find_and_clear_dirty_height(vs, y, x, x2, height);\n            x2 = MIN(x2, width / VNC_DIRTY_PIXELS_PER_BIT);\n            if (x2 > x) {\n                n += vnc_job_add_rect(job, x * VNC_DIRTY_PIXELS_PER_BIT, y,\n                                      (x2 - x) * VNC_DIRTY_PIXELS_PER_BIT, h);\n            }\n        }\n\n        vnc_job_push(job);\n        if (sync) {\n            vnc_jobs_join(vs);\n        }\n        vs->force_update = 0;\n        return n;\n    }\n\n    if (vs->csock == -1) {\n        vnc_disconnect_finish(vs);\n    } else if (sync) {\n        vnc_jobs_join(vs);\n    }\n\n    return 0;\n}\n\n/* audio */\nstatic void audio_capture_notify(void *opaque, audcnotification_e cmd)\n{\n    VncState *vs = opaque;\n\n    switch (cmd) {\n    case AUD_CNOTIFY_DISABLE:\n        vnc_lock_output(vs);\n        vnc_write_u8(vs, VNC_MSG_SERVER_QEMU);\n        vnc_write_u8(vs, VNC_MSG_SERVER_QEMU_AUDIO);\n        vnc_write_u16(vs, VNC_MSG_SERVER_QEMU_AUDIO_END);\n        vnc_unlock_output(vs);\n        vnc_flush(vs);\n        break;\n\n    case AUD_CNOTIFY_ENABLE:\n        vnc_lock_output(vs);\n        vnc_write_u8(vs, VNC_MSG_SERVER_QEMU);\n        vnc_write_u8(vs, VNC_MSG_SERVER_QEMU_AUDIO);\n        vnc_write_u16(vs, VNC_MSG_SERVER_QEMU_AUDIO_BEGIN);\n        vnc_unlock_output(vs);\n        vnc_flush(vs);\n        break;\n    }\n}\n\nstatic void audio_capture_destroy(void *opaque)\n{\n}\n\nstatic void audio_capture(void *opaque, void *buf, int size)\n{\n    VncState *vs = opaque;\n\n    vnc_lock_output(vs);\n    vnc_write_u8(vs, VNC_MSG_SERVER_QEMU);\n    vnc_write_u8(vs, VNC_MSG_SERVER_QEMU_AUDIO);\n    vnc_write_u16(vs, VNC_MSG_SERVER_QEMU_AUDIO_DATA);\n    vnc_write_u32(vs, size);\n    vnc_write(vs, buf, size);\n    vnc_unlock_output(vs);\n    vnc_flush(vs);\n}\n\nstatic void audio_add(VncState *vs)\n{\n    struct audio_capture_ops ops;\n\n    if (vs->audio_cap) {\n        error_report(\"audio already running\");\n        return;\n    }\n\n    ops.notify = audio_capture_notify;\n    ops.destroy = audio_capture_destroy;\n    ops.capture = audio_capture;\n\n    vs->audio_cap = AUD_add_capture(&vs->as, &ops, vs);\n    if (!vs->audio_cap) {\n        error_report(\"Failed to add audio capture\");\n    }\n}\n\nstatic void audio_del(VncState *vs)\n{\n    if (vs->audio_cap) {\n        AUD_del_capture(vs->audio_cap, vs);\n        vs->audio_cap = NULL;\n    }\n}\n\nstatic void vnc_disconnect_start(VncState *vs)\n{\n    if (vs->csock == -1)\n        return;\n    vnc_set_share_mode(vs, VNC_SHARE_MODE_DISCONNECTED);\n    qemu_set_fd_handler2(vs->csock, NULL, NULL, NULL, NULL);\n    closesocket(vs->csock);\n    vs->csock = -1;\n}\n\nvoid vnc_disconnect_finish(VncState *vs)\n{\n    int i;\n\n    vnc_jobs_join(vs); /* Wait encoding jobs */\n\n    vnc_lock_output(vs);\n    vnc_qmp_event(vs, QAPI_EVENT_VNC_DISCONNECTED);\n\n    buffer_free(&vs->input);\n    buffer_free(&vs->output);\n#ifdef CONFIG_VNC_WS\n    buffer_free(&vs->ws_input);\n    buffer_free(&vs->ws_output);\n#endif /* CONFIG_VNC_WS */\n\n    qapi_free_VncClientInfo(vs->info);\n\n    vnc_zlib_clear(vs);\n    vnc_tight_clear(vs);\n    vnc_zrle_clear(vs);\n\n#ifdef CONFIG_VNC_TLS\n    vnc_tls_client_cleanup(vs);\n#endif /* CONFIG_VNC_TLS */\n#ifdef CONFIG_VNC_SASL\n    vnc_sasl_client_cleanup(vs);\n#endif /* CONFIG_VNC_SASL */\n    audio_del(vs);\n    vnc_release_modifiers(vs);\n\n    if (vs->initialized) {\n        QTAILQ_REMOVE(&vs->vd->clients, vs, next);\n        qemu_remove_mouse_mode_change_notifier(&vs->mouse_mode_notifier);\n    }\n\n    if (vs->vd->lock_key_sync)\n        qemu_remove_led_event_handler(vs->led);\n    vnc_unlock_output(vs);\n\n    qemu_mutex_destroy(&vs->output_mutex);\n    if (vs->bh != NULL) {\n        qemu_bh_delete(vs->bh);\n    }\n    buffer_free(&vs->jobs_buffer);\n\n    for (i = 0; i < VNC_STAT_ROWS; ++i) {\n        g_free(vs->lossy_rect[i]);\n    }\n    g_free(vs->lossy_rect);\n    g_free(vs);\n}\n\nint vnc_client_io_error(VncState *vs, int ret, int last_errno)\n{\n    if (ret == 0 || ret == -1) {\n        if (ret == -1) {\n            switch (last_errno) {\n                case EINTR:\n                case EAGAIN:\n#ifdef _WIN32\n                case WSAEWOULDBLOCK:\n#endif\n                    return 0;\n                default:\n                    break;\n            }\n        }\n\n        VNC_DEBUG(\"Closing down client sock: ret %d, errno %d\\n\",\n                  ret, ret < 0 ? last_errno : 0);\n        vnc_disconnect_start(vs);\n\n        return 0;\n    }\n    return ret;\n}\n\n\nvoid vnc_client_error(VncState *vs)\n{\n    VNC_DEBUG(\"Closing down client sock: protocol error\\n\");\n    vnc_disconnect_start(vs);\n}\n\n#ifdef CONFIG_VNC_TLS\nstatic long vnc_client_write_tls(gnutls_session_t *session,\n                                 const uint8_t *data,\n                                 size_t datalen)\n{\n    long ret = gnutls_write(*session, data, datalen);\n    if (ret < 0) {\n        if (ret == GNUTLS_E_AGAIN) {\n            errno = EAGAIN;\n        } else {\n            errno = EIO;\n        }\n        ret = -1;\n    }\n    return ret;\n}\n#endif /* CONFIG_VNC_TLS */\n\n/*\n * Called to write a chunk of data to the client socket. The data may\n * be the raw data, or may have already been encoded by SASL.\n * The data will be written either straight onto the socket, or\n * written via the GNUTLS wrappers, if TLS/SSL encryption is enabled\n *\n * NB, it is theoretically possible to have 2 layers of encryption,\n * both SASL, and this TLS layer. It is highly unlikely in practice\n * though, since SASL encryption will typically be a no-op if TLS\n * is active\n *\n * Returns the number of bytes written, which may be less than\n * the requested 'datalen' if the socket would block. Returns\n * -1 on error, and disconnects the client socket.\n */\nlong vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t datalen)\n{\n    long ret;\n#ifdef CONFIG_VNC_TLS\n    if (vs->tls.session) {\n        ret = vnc_client_write_tls(&vs->tls.session, data, datalen);\n    } else {\n#ifdef CONFIG_VNC_WS\n        if (vs->ws_tls.session) {\n            ret = vnc_client_write_tls(&vs->ws_tls.session, data, datalen);\n        } else\n#endif /* CONFIG_VNC_WS */\n#endif /* CONFIG_VNC_TLS */\n        {\n            ret = send(vs->csock, (const void *)data, datalen, 0);\n        }\n#ifdef CONFIG_VNC_TLS\n    }\n#endif /* CONFIG_VNC_TLS */\n    VNC_DEBUG(\"Wrote wire %p %zd -> %ld\\n\", data, datalen, ret);\n    return vnc_client_io_error(vs, ret, socket_error());\n}\n\n\n/*\n * Called to write buffered data to the client socket, when not\n * using any SASL SSF encryption layers. Will write as much data\n * as possible without blocking. If all buffered data is written,\n * will switch the FD poll() handler back to read monitoring.\n *\n * Returns the number of bytes written, which may be less than\n * the buffered output data if the socket would block. Returns\n * -1 on error, and disconnects the client socket.\n */\nstatic long vnc_client_write_plain(VncState *vs)\n{\n    long ret;\n\n#ifdef CONFIG_VNC_SASL\n    VNC_DEBUG(\"Write Plain: Pending output %p size %zd offset %zd. Wait SSF %d\\n\",\n              vs->output.buffer, vs->output.capacity, vs->output.offset,\n              vs->sasl.waitWriteSSF);\n\n    if (vs->sasl.conn &&\n        vs->sasl.runSSF &&\n        vs->sasl.waitWriteSSF) {\n        ret = vnc_client_write_buf(vs, vs->output.buffer, vs->sasl.waitWriteSSF);\n        if (ret)\n            vs->sasl.waitWriteSSF -= ret;\n    } else\n#endif /* CONFIG_VNC_SASL */\n        ret = vnc_client_write_buf(vs, vs->output.buffer, vs->output.offset);\n    if (!ret)\n        return 0;\n\n    buffer_advance(&vs->output, ret);\n\n    if (vs->output.offset == 0) {\n        qemu_set_fd_handler2(vs->csock, NULL, vnc_client_read, NULL, vs);\n    }\n\n    return ret;\n}\n\n\n/*\n * First function called whenever there is data to be written to\n * the client socket. Will delegate actual work according to whether\n * SASL SSF layers are enabled (thus requiring encryption calls)\n */\nstatic void vnc_client_write_locked(void *opaque)\n{\n    VncState *vs = opaque;\n\n#ifdef CONFIG_VNC_SASL\n    if (vs->sasl.conn &&\n        vs->sasl.runSSF &&\n        !vs->sasl.waitWriteSSF) {\n        vnc_client_write_sasl(vs);\n    } else\n#endif /* CONFIG_VNC_SASL */\n    {\n#ifdef CONFIG_VNC_WS\n        if (vs->encode_ws) {\n            vnc_client_write_ws(vs);\n        } else\n#endif /* CONFIG_VNC_WS */\n        {\n            vnc_client_write_plain(vs);\n        }\n    }\n}\n\nvoid vnc_client_write(void *opaque)\n{\n    VncState *vs = opaque;\n\n    vnc_lock_output(vs);\n    if (vs->output.offset\n#ifdef CONFIG_VNC_WS\n            || vs->ws_output.offset\n#endif\n            ) {\n        vnc_client_write_locked(opaque);\n    } else if (vs->csock != -1) {\n        qemu_set_fd_handler2(vs->csock, NULL, vnc_client_read, NULL, vs);\n    }\n    vnc_unlock_output(vs);\n}\n\nvoid vnc_read_when(VncState *vs, VncReadEvent *func, size_t expecting)\n{\n    vs->read_handler = func;\n    vs->read_handler_expect = expecting;\n}\n\n#ifdef CONFIG_VNC_TLS\nstatic long vnc_client_read_tls(gnutls_session_t *session, uint8_t *data,\n                                size_t datalen)\n{\n    long ret = gnutls_read(*session, data, datalen);\n    if (ret < 0) {\n        if (ret == GNUTLS_E_AGAIN) {\n            errno = EAGAIN;\n        } else {\n            errno = EIO;\n        }\n        ret = -1;\n    }\n    return ret;\n}\n#endif /* CONFIG_VNC_TLS */\n\n/*\n * Called to read a chunk of data from the client socket. The data may\n * be the raw data, or may need to be further decoded by SASL.\n * The data will be read either straight from to the socket, or\n * read via the GNUTLS wrappers, if TLS/SSL encryption is enabled\n *\n * NB, it is theoretically possible to have 2 layers of encryption,\n * both SASL, and this TLS layer. It is highly unlikely in practice\n * though, since SASL encryption will typically be a no-op if TLS\n * is active\n *\n * Returns the number of bytes read, which may be less than\n * the requested 'datalen' if the socket would block. Returns\n * -1 on error, and disconnects the client socket.\n */\nlong vnc_client_read_buf(VncState *vs, uint8_t *data, size_t datalen)\n{\n    long ret;\n#ifdef CONFIG_VNC_TLS\n    if (vs->tls.session) {\n        ret = vnc_client_read_tls(&vs->tls.session, data, datalen);\n    } else {\n#ifdef CONFIG_VNC_WS\n        if (vs->ws_tls.session) {\n            ret = vnc_client_read_tls(&vs->ws_tls.session, data, datalen);\n        } else\n#endif /* CONFIG_VNC_WS */\n#endif /* CONFIG_VNC_TLS */\n        {\n            ret = qemu_recv(vs->csock, data, datalen, 0);\n        }\n#ifdef CONFIG_VNC_TLS\n    }\n#endif /* CONFIG_VNC_TLS */\n    VNC_DEBUG(\"Read wire %p %zd -> %ld\\n\", data, datalen, ret);\n    return vnc_client_io_error(vs, ret, socket_error());\n}\n\n\n/*\n * Called to read data from the client socket to the input buffer,\n * when not using any SASL SSF encryption layers. Will read as much\n * data as possible without blocking.\n *\n * Returns the number of bytes read. Returns -1 on error, and\n * disconnects the client socket.\n */\nstatic long vnc_client_read_plain(VncState *vs)\n{\n    int ret;\n    VNC_DEBUG(\"Read plain %p size %zd offset %zd\\n\",\n              vs->input.buffer, vs->input.capacity, vs->input.offset);\n    buffer_reserve(&vs->input, 4096);\n    ret = vnc_client_read_buf(vs, buffer_end(&vs->input), 4096);\n    if (!ret)\n        return 0;\n    vs->input.offset += ret;\n    return ret;\n}\n\nstatic void vnc_jobs_bh(void *opaque)\n{\n    VncState *vs = opaque;\n\n    vnc_jobs_consume_buffer(vs);\n}\n\n/*\n * First function called whenever there is more data to be read from\n * the client socket. Will delegate actual work according to whether\n * SASL SSF layers are enabled (thus requiring decryption calls)\n */\nvoid vnc_client_read(void *opaque)\n{\n    VncState *vs = opaque;\n    long ret;\n\n#ifdef CONFIG_VNC_SASL\n    if (vs->sasl.conn && vs->sasl.runSSF)\n        ret = vnc_client_read_sasl(vs);\n    else\n#endif /* CONFIG_VNC_SASL */\n#ifdef CONFIG_VNC_WS\n        if (vs->encode_ws) {\n            ret = vnc_client_read_ws(vs);\n            if (ret == -1) {\n                vnc_disconnect_start(vs);\n                return;\n            } else if (ret == -2) {\n                vnc_client_error(vs);\n                return;\n            }\n        } else\n#endif /* CONFIG_VNC_WS */\n        {\n        ret = vnc_client_read_plain(vs);\n        }\n    if (!ret) {\n        if (vs->csock == -1)\n            vnc_disconnect_finish(vs);\n        return;\n    }\n\n    while (vs->read_handler && vs->input.offset >= vs->read_handler_expect) {\n        size_t len = vs->read_handler_expect;\n        int ret;\n\n        ret = vs->read_handler(vs, vs->input.buffer, len);\n        if (vs->csock == -1) {\n            vnc_disconnect_finish(vs);\n            return;\n        }\n\n        if (!ret) {\n            buffer_advance(&vs->input, len);\n        } else {\n            vs->read_handler_expect = ret;\n        }\n    }\n}\n\nvoid vnc_write(VncState *vs, const void *data, size_t len)\n{\n    buffer_reserve(&vs->output, len);\n\n    if (vs->csock != -1 && buffer_empty(&vs->output)) {\n        qemu_set_fd_handler2(vs->csock, NULL, vnc_client_read, vnc_client_write, vs);\n    }\n\n    buffer_append(&vs->output, data, len);\n}\n\nvoid vnc_write_s32(VncState *vs, int32_t value)\n{\n    vnc_write_u32(vs, *(uint32_t *)&value);\n}\n\nvoid vnc_write_u32(VncState *vs, uint32_t value)\n{\n    uint8_t buf[4];\n\n    buf[0] = (value >> 24) & 0xFF;\n    buf[1] = (value >> 16) & 0xFF;\n    buf[2] = (value >>  8) & 0xFF;\n    buf[3] = value & 0xFF;\n\n    vnc_write(vs, buf, 4);\n}\n\nvoid vnc_write_u16(VncState *vs, uint16_t value)\n{\n    uint8_t buf[2];\n\n    buf[0] = (value >> 8) & 0xFF;\n    buf[1] = value & 0xFF;\n\n    vnc_write(vs, buf, 2);\n}\n\nvoid vnc_write_u8(VncState *vs, uint8_t value)\n{\n    vnc_write(vs, (char *)&value, 1);\n}\n\nvoid vnc_flush(VncState *vs)\n{\n    vnc_lock_output(vs);\n    if (vs->csock != -1 && (vs->output.offset\n#ifdef CONFIG_VNC_WS\n                || vs->ws_output.offset\n#endif\n                )) {\n        vnc_client_write_locked(vs);\n    }\n    vnc_unlock_output(vs);\n}\n\nstatic uint8_t read_u8(uint8_t *data, size_t offset)\n{\n    return data[offset];\n}\n\nstatic uint16_t read_u16(uint8_t *data, size_t offset)\n{\n    return ((data[offset] & 0xFF) << 8) | (data[offset + 1] & 0xFF);\n}\n\nstatic int32_t read_s32(uint8_t *data, size_t offset)\n{\n    return (int32_t)((data[offset] << 24) | (data[offset + 1] << 16) |\n                     (data[offset + 2] << 8) | data[offset + 3]);\n}\n\nuint32_t read_u32(uint8_t *data, size_t offset)\n{\n    return ((data[offset] << 24) | (data[offset + 1] << 16) |\n            (data[offset + 2] << 8) | data[offset + 3]);\n}\n\nstatic void client_cut_text(VncState *vs, size_t len, uint8_t *text)\n{\n}\n\nstatic void check_pointer_type_change(Notifier *notifier, void *data)\n{\n    VncState *vs = container_of(notifier, VncState, mouse_mode_notifier);\n    int absolute = qemu_input_is_absolute();\n\n    if (vnc_has_feature(vs, VNC_FEATURE_POINTER_TYPE_CHANGE) && vs->absolute != absolute) {\n        vnc_lock_output(vs);\n        vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n        vnc_write_u8(vs, 0);\n        vnc_write_u16(vs, 1);\n        vnc_framebuffer_update(vs, absolute, 0,\n                               surface_width(vs->vd->ds),\n                               surface_height(vs->vd->ds),\n                               VNC_ENCODING_POINTER_TYPE_CHANGE);\n        vnc_unlock_output(vs);\n        vnc_flush(vs);\n    }\n    vs->absolute = absolute;\n}\n\nstatic void pointer_event(VncState *vs, int button_mask, int x, int y)\n{\n    static uint32_t bmap[INPUT_BUTTON_MAX] = {\n        [INPUT_BUTTON_LEFT]       = 0x01,\n        [INPUT_BUTTON_MIDDLE]     = 0x02,\n        [INPUT_BUTTON_RIGHT]      = 0x04,\n        [INPUT_BUTTON_WHEEL_UP]   = 0x08,\n        [INPUT_BUTTON_WHEEL_DOWN] = 0x10,\n    };\n    QemuConsole *con = vs->vd->dcl.con;\n    int width = surface_width(vs->vd->ds);\n    int height = surface_height(vs->vd->ds);\n\n    if (vs->last_bmask != button_mask) {\n        qemu_input_update_buttons(con, bmap, vs->last_bmask, button_mask);\n        vs->last_bmask = button_mask;\n    }\n\n    if (vs->absolute) {\n        qemu_input_queue_abs(con, INPUT_AXIS_X, x, width);\n        qemu_input_queue_abs(con, INPUT_AXIS_Y, y, height);\n    } else if (vnc_has_feature(vs, VNC_FEATURE_POINTER_TYPE_CHANGE)) {\n        qemu_input_queue_rel(con, INPUT_AXIS_X, x - 0x7FFF);\n        qemu_input_queue_rel(con, INPUT_AXIS_Y, y - 0x7FFF);\n    } else {\n        if (vs->last_x != -1) {\n            qemu_input_queue_rel(con, INPUT_AXIS_X, x - vs->last_x);\n            qemu_input_queue_rel(con, INPUT_AXIS_Y, y - vs->last_y);\n        }\n        vs->last_x = x;\n        vs->last_y = y;\n    }\n    qemu_input_event_sync();\n}\n\nstatic void reset_keys(VncState *vs)\n{\n    int i;\n    for(i = 0; i < 256; i++) {\n        if (vs->modifiers_state[i]) {\n            qemu_input_event_send_key_number(vs->vd->dcl.con, i, false);\n            vs->modifiers_state[i] = 0;\n        }\n    }\n}\n\nstatic void press_key(VncState *vs, int keysym)\n{\n    int keycode = keysym2scancode(vs->vd->kbd_layout, keysym) & SCANCODE_KEYMASK;\n    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, true);\n    qemu_input_event_send_key_delay(0);\n    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, false);\n    qemu_input_event_send_key_delay(0);\n}\n\nstatic int current_led_state(VncState *vs)\n{\n    int ledstate = 0;\n\n    if (vs->modifiers_state[0x46]) {\n        ledstate |= QEMU_SCROLL_LOCK_LED;\n    }\n    if (vs->modifiers_state[0x45]) {\n        ledstate |= QEMU_NUM_LOCK_LED;\n    }\n    if (vs->modifiers_state[0x3a]) {\n        ledstate |= QEMU_CAPS_LOCK_LED;\n    }\n\n    return ledstate;\n}\n\nstatic void vnc_led_state_change(VncState *vs)\n{\n    int ledstate = 0;\n\n    if (!vnc_has_feature(vs, VNC_FEATURE_LED_STATE)) {\n        return;\n    }\n\n    ledstate = current_led_state(vs);\n    vnc_lock_output(vs);\n    vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n    vnc_write_u8(vs, 0);\n    vnc_write_u16(vs, 1);\n    vnc_framebuffer_update(vs, 0, 0, 1, 1, VNC_ENCODING_LED_STATE);\n    vnc_write_u8(vs, ledstate);\n    vnc_unlock_output(vs);\n    vnc_flush(vs);\n}\n\nstatic void kbd_leds(void *opaque, int ledstate)\n{\n    VncState *vs = opaque;\n    int caps, num, scr;\n    bool has_changed = (ledstate != current_led_state(vs));\n\n    trace_vnc_key_guest_leds((ledstate & QEMU_CAPS_LOCK_LED),\n                             (ledstate & QEMU_NUM_LOCK_LED),\n                             (ledstate & QEMU_SCROLL_LOCK_LED));\n\n    caps = ledstate & QEMU_CAPS_LOCK_LED ? 1 : 0;\n    num  = ledstate & QEMU_NUM_LOCK_LED  ? 1 : 0;\n    scr  = ledstate & QEMU_SCROLL_LOCK_LED ? 1 : 0;\n\n    if (vs->modifiers_state[0x3a] != caps) {\n        vs->modifiers_state[0x3a] = caps;\n    }\n    if (vs->modifiers_state[0x45] != num) {\n        vs->modifiers_state[0x45] = num;\n    }\n    if (vs->modifiers_state[0x46] != scr) {\n        vs->modifiers_state[0x46] = scr;\n    }\n\n    /* Sending the current led state message to the client */\n    if (has_changed) {\n        vnc_led_state_change(vs);\n    }\n}\n\nstatic void do_key_event(VncState *vs, int down, int keycode, int sym)\n{\n    /* QEMU console switch */\n    switch(keycode) {\n    case 0x2a:                          /* Left Shift */\n    case 0x36:                          /* Right Shift */\n    case 0x1d:                          /* Left CTRL */\n    case 0x9d:                          /* Right CTRL */\n    case 0x38:                          /* Left ALT */\n    case 0xb8:                          /* Right ALT */\n        if (down)\n            vs->modifiers_state[keycode] = 1;\n        else\n            vs->modifiers_state[keycode] = 0;\n        break;\n    case 0x02 ... 0x0a: /* '1' to '9' keys */\n        if (down && vs->modifiers_state[0x1d] && vs->modifiers_state[0x38]) {\n            /* Reset the modifiers sent to the current console */\n            reset_keys(vs);\n            console_select(keycode - 0x02);\n            return;\n        }\n        break;\n    case 0x3a:                        /* CapsLock */\n    case 0x45:                        /* NumLock */\n        if (down)\n            vs->modifiers_state[keycode] ^= 1;\n        break;\n    }\n\n    /* Turn off the lock state sync logic if the client support the led\n       state extension.\n    */\n    if (down && vs->vd->lock_key_sync &&\n        !vnc_has_feature(vs, VNC_FEATURE_LED_STATE) &&\n        keycode_is_keypad(vs->vd->kbd_layout, keycode)) {\n        /* If the numlock state needs to change then simulate an additional\n           keypress before sending this one.  This will happen if the user\n           toggles numlock away from the VNC window.\n        */\n        if (keysym_is_numlock(vs->vd->kbd_layout, sym & 0xFFFF)) {\n            if (!vs->modifiers_state[0x45]) {\n                trace_vnc_key_sync_numlock(true);\n                vs->modifiers_state[0x45] = 1;\n                press_key(vs, 0xff7f);\n            }\n        } else {\n            if (vs->modifiers_state[0x45]) {\n                trace_vnc_key_sync_numlock(false);\n                vs->modifiers_state[0x45] = 0;\n                press_key(vs, 0xff7f);\n            }\n        }\n    }\n\n    if (down && vs->vd->lock_key_sync &&\n        !vnc_has_feature(vs, VNC_FEATURE_LED_STATE) &&\n        ((sym >= 'A' && sym <= 'Z') || (sym >= 'a' && sym <= 'z'))) {\n        /* If the capslock state needs to change then simulate an additional\n           keypress before sending this one.  This will happen if the user\n           toggles capslock away from the VNC window.\n        */\n        int uppercase = !!(sym >= 'A' && sym <= 'Z');\n        int shift = !!(vs->modifiers_state[0x2a] | vs->modifiers_state[0x36]);\n        int capslock = !!(vs->modifiers_state[0x3a]);\n        if (capslock) {\n            if (uppercase == shift) {\n                trace_vnc_key_sync_capslock(false);\n                vs->modifiers_state[0x3a] = 0;\n                press_key(vs, 0xffe5);\n            }\n        } else {\n            if (uppercase != shift) {\n                trace_vnc_key_sync_capslock(true);\n                vs->modifiers_state[0x3a] = 1;\n                press_key(vs, 0xffe5);\n            }\n        }\n    }\n\n    if (qemu_console_is_graphic(NULL)) {\n        qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, down);\n    } else {\n        bool numlock = vs->modifiers_state[0x45];\n        bool control = (vs->modifiers_state[0x1d] ||\n                        vs->modifiers_state[0x9d]);\n        /* QEMU console emulation */\n        if (down) {\n            switch (keycode) {\n            case 0x2a:                          /* Left Shift */\n            case 0x36:                          /* Right Shift */\n            case 0x1d:                          /* Left CTRL */\n            case 0x9d:                          /* Right CTRL */\n            case 0x38:                          /* Left ALT */\n            case 0xb8:                          /* Right ALT */\n                break;\n            case 0xc8:\n                kbd_put_keysym(QEMU_KEY_UP);\n                break;\n            case 0xd0:\n                kbd_put_keysym(QEMU_KEY_DOWN);\n                break;\n            case 0xcb:\n                kbd_put_keysym(QEMU_KEY_LEFT);\n                break;\n            case 0xcd:\n                kbd_put_keysym(QEMU_KEY_RIGHT);\n                break;\n            case 0xd3:\n                kbd_put_keysym(QEMU_KEY_DELETE);\n                break;\n            case 0xc7:\n                kbd_put_keysym(QEMU_KEY_HOME);\n                break;\n            case 0xcf:\n                kbd_put_keysym(QEMU_KEY_END);\n                break;\n            case 0xc9:\n                kbd_put_keysym(QEMU_KEY_PAGEUP);\n                break;\n            case 0xd1:\n                kbd_put_keysym(QEMU_KEY_PAGEDOWN);\n                break;\n\n            case 0x47:\n                kbd_put_keysym(numlock ? '7' : QEMU_KEY_HOME);\n                break;\n            case 0x48:\n                kbd_put_keysym(numlock ? '8' : QEMU_KEY_UP);\n                break;\n            case 0x49:\n                kbd_put_keysym(numlock ? '9' : QEMU_KEY_PAGEUP);\n                break;\n            case 0x4b:\n                kbd_put_keysym(numlock ? '4' : QEMU_KEY_LEFT);\n                break;\n            case 0x4c:\n                kbd_put_keysym('5');\n                break;\n            case 0x4d:\n                kbd_put_keysym(numlock ? '6' : QEMU_KEY_RIGHT);\n                break;\n            case 0x4f:\n                kbd_put_keysym(numlock ? '1' : QEMU_KEY_END);\n                break;\n            case 0x50:\n                kbd_put_keysym(numlock ? '2' : QEMU_KEY_DOWN);\n                break;\n            case 0x51:\n                kbd_put_keysym(numlock ? '3' : QEMU_KEY_PAGEDOWN);\n                break;\n            case 0x52:\n                kbd_put_keysym('0');\n                break;\n            case 0x53:\n                kbd_put_keysym(numlock ? '.' : QEMU_KEY_DELETE);\n                break;\n\n            case 0xb5:\n                kbd_put_keysym('/');\n                break;\n            case 0x37:\n                kbd_put_keysym('*');\n                break;\n            case 0x4a:\n                kbd_put_keysym('-');\n                break;\n            case 0x4e:\n                kbd_put_keysym('+');\n                break;\n            case 0x9c:\n                kbd_put_keysym('\\n');\n                break;\n\n            default:\n                if (control) {\n                    kbd_put_keysym(sym & 0x1f);\n                } else {\n                    kbd_put_keysym(sym);\n                }\n                break;\n            }\n        }\n    }\n}\n\nstatic void vnc_release_modifiers(VncState *vs)\n{\n    static const int keycodes[] = {\n        /* shift, control, alt keys, both left & right */\n        0x2a, 0x36, 0x1d, 0x9d, 0x38, 0xb8,\n    };\n    int i, keycode;\n\n    if (!qemu_console_is_graphic(NULL)) {\n        return;\n    }\n    for (i = 0; i < ARRAY_SIZE(keycodes); i++) {\n        keycode = keycodes[i];\n        if (!vs->modifiers_state[keycode]) {\n            continue;\n        }\n        qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, false);\n    }\n}\n\nstatic const char *code2name(int keycode)\n{\n    return QKeyCode_lookup[qemu_input_key_number_to_qcode(keycode)];\n}\n\nstatic void key_event(VncState *vs, int down, uint32_t sym)\n{\n    int keycode;\n    int lsym = sym;\n\n    if (lsym >= 'A' && lsym <= 'Z' && qemu_console_is_graphic(NULL)) {\n        lsym = lsym - 'A' + 'a';\n    }\n\n    keycode = keysym2scancode(vs->vd->kbd_layout, lsym & 0xFFFF) & SCANCODE_KEYMASK;\n    trace_vnc_key_event_map(down, sym, keycode, code2name(keycode));\n    do_key_event(vs, down, keycode, sym);\n}\n\nstatic void ext_key_event(VncState *vs, int down,\n                          uint32_t sym, uint16_t keycode)\n{\n    /* if the user specifies a keyboard layout, always use it */\n    if (keyboard_layout) {\n        key_event(vs, down, sym);\n    } else {\n        trace_vnc_key_event_ext(down, sym, keycode, code2name(keycode));\n        do_key_event(vs, down, keycode, sym);\n    }\n}\n\nstatic void framebuffer_update_request(VncState *vs, int incremental,\n                                       int x_position, int y_position,\n                                       int w, int h)\n{\n    int i;\n    const size_t width = surface_width(vs->vd->ds) / VNC_DIRTY_PIXELS_PER_BIT;\n    const size_t height = surface_height(vs->vd->ds);\n\n    if (y_position > height) {\n        y_position = height;\n    }\n    if (y_position + h >= height) {\n        h = height - y_position;\n    }\n\n    vs->need_update = 1;\n    if (!incremental) {\n        vs->force_update = 1;\n        for (i = 0; i < h; i++) {\n            bitmap_set(vs->dirty[y_position + i], 0, width);\n            bitmap_clear(vs->dirty[y_position + i], width,\n                         VNC_DIRTY_BITS - width);\n        }\n    }\n}\n\nstatic void send_ext_key_event_ack(VncState *vs)\n{\n    vnc_lock_output(vs);\n    vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n    vnc_write_u8(vs, 0);\n    vnc_write_u16(vs, 1);\n    vnc_framebuffer_update(vs, 0, 0,\n                           surface_width(vs->vd->ds),\n                           surface_height(vs->vd->ds),\n                           VNC_ENCODING_EXT_KEY_EVENT);\n    vnc_unlock_output(vs);\n    vnc_flush(vs);\n}\n\nstatic void send_ext_audio_ack(VncState *vs)\n{\n    vnc_lock_output(vs);\n    vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n    vnc_write_u8(vs, 0);\n    vnc_write_u16(vs, 1);\n    vnc_framebuffer_update(vs, 0, 0,\n                           surface_width(vs->vd->ds),\n                           surface_height(vs->vd->ds),\n                           VNC_ENCODING_AUDIO);\n    vnc_unlock_output(vs);\n    vnc_flush(vs);\n}\n\nstatic void set_encodings(VncState *vs, int32_t *encodings, size_t n_encodings)\n{\n    int i;\n    unsigned int enc = 0;\n\n    vs->features = 0;\n    vs->vnc_encoding = 0;\n    vs->tight.compression = 9;\n    vs->tight.quality = -1; /* Lossless by default */\n    vs->absolute = -1;\n\n    /*\n     * Start from the end because the encodings are sent in order of preference.\n     * This way the preferred encoding (first encoding defined in the array)\n     * will be set at the end of the loop.\n     */\n    for (i = n_encodings - 1; i >= 0; i--) {\n        enc = encodings[i];\n        switch (enc) {\n        case VNC_ENCODING_RAW:\n            vs->vnc_encoding = enc;\n            break;\n        case VNC_ENCODING_COPYRECT:\n            vs->features |= VNC_FEATURE_COPYRECT_MASK;\n            break;\n        case VNC_ENCODING_HEXTILE:\n            vs->features |= VNC_FEATURE_HEXTILE_MASK;\n            vs->vnc_encoding = enc;\n            break;\n        case VNC_ENCODING_TIGHT:\n            vs->features |= VNC_FEATURE_TIGHT_MASK;\n            vs->vnc_encoding = enc;\n            break;\n#ifdef CONFIG_VNC_PNG\n        case VNC_ENCODING_TIGHT_PNG:\n            vs->features |= VNC_FEATURE_TIGHT_PNG_MASK;\n            vs->vnc_encoding = enc;\n            break;\n#endif\n        case VNC_ENCODING_ZLIB:\n            vs->features |= VNC_FEATURE_ZLIB_MASK;\n            vs->vnc_encoding = enc;\n            break;\n        case VNC_ENCODING_ZRLE:\n            vs->features |= VNC_FEATURE_ZRLE_MASK;\n            vs->vnc_encoding = enc;\n            break;\n        case VNC_ENCODING_ZYWRLE:\n            vs->features |= VNC_FEATURE_ZYWRLE_MASK;\n            vs->vnc_encoding = enc;\n            break;\n        case VNC_ENCODING_DESKTOPRESIZE:\n            vs->features |= VNC_FEATURE_RESIZE_MASK;\n            break;\n        case VNC_ENCODING_POINTER_TYPE_CHANGE:\n            vs->features |= VNC_FEATURE_POINTER_TYPE_CHANGE_MASK;\n            break;\n        case VNC_ENCODING_RICH_CURSOR:\n            vs->features |= VNC_FEATURE_RICH_CURSOR_MASK;\n            break;\n        case VNC_ENCODING_EXT_KEY_EVENT:\n            send_ext_key_event_ack(vs);\n            break;\n        case VNC_ENCODING_AUDIO:\n            send_ext_audio_ack(vs);\n            break;\n        case VNC_ENCODING_WMVi:\n            vs->features |= VNC_FEATURE_WMVI_MASK;\n            break;\n        case VNC_ENCODING_LED_STATE:\n            vs->features |= VNC_FEATURE_LED_STATE_MASK;\n            break;\n        case VNC_ENCODING_COMPRESSLEVEL0 ... VNC_ENCODING_COMPRESSLEVEL0 + 9:\n            vs->tight.compression = (enc & 0x0F);\n            break;\n        case VNC_ENCODING_QUALITYLEVEL0 ... VNC_ENCODING_QUALITYLEVEL0 + 9:\n            if (vs->vd->lossy) {\n                vs->tight.quality = (enc & 0x0F);\n            }\n            break;\n        default:\n            VNC_DEBUG(\"Unknown encoding: %d (0x%.8x): %d\\n\", i, enc, enc);\n            break;\n        }\n    }\n    vnc_desktop_resize(vs);\n    check_pointer_type_change(&vs->mouse_mode_notifier, NULL);\n    vnc_led_state_change(vs);\n}\n\nstatic void set_pixel_conversion(VncState *vs)\n{\n    pixman_format_code_t fmt = qemu_pixman_get_format(&vs->client_pf);\n\n    if (fmt == VNC_SERVER_FB_FORMAT) {\n        vs->write_pixels = vnc_write_pixels_copy;\n        vnc_hextile_set_pixel_conversion(vs, 0);\n    } else {\n        vs->write_pixels = vnc_write_pixels_generic;\n        vnc_hextile_set_pixel_conversion(vs, 1);\n    }\n}\n\nstatic void set_pixel_format(VncState *vs,\n                             int bits_per_pixel, int depth,\n                             int big_endian_flag, int true_color_flag,\n                             int red_max, int green_max, int blue_max,\n                             int red_shift, int green_shift, int blue_shift)\n{\n    if (!true_color_flag) {\n        vnc_client_error(vs);\n        return;\n    }\n\n    vs->client_pf.rmax = red_max;\n    vs->client_pf.rbits = hweight_long(red_max);\n    vs->client_pf.rshift = red_shift;\n    vs->client_pf.rmask = red_max << red_shift;\n    vs->client_pf.gmax = green_max;\n    vs->client_pf.gbits = hweight_long(green_max);\n    vs->client_pf.gshift = green_shift;\n    vs->client_pf.gmask = green_max << green_shift;\n    vs->client_pf.bmax = blue_max;\n    vs->client_pf.bbits = hweight_long(blue_max);\n    vs->client_pf.bshift = blue_shift;\n    vs->client_pf.bmask = blue_max << blue_shift;\n    vs->client_pf.bits_per_pixel = bits_per_pixel;\n    vs->client_pf.bytes_per_pixel = bits_per_pixel / 8;\n    vs->client_pf.depth = bits_per_pixel == 32 ? 24 : bits_per_pixel;\n    vs->client_be = big_endian_flag;\n\n    set_pixel_conversion(vs);\n\n    graphic_hw_invalidate(NULL);\n    graphic_hw_update(NULL);\n}\n\nstatic void pixel_format_message (VncState *vs) {\n    char pad[3] = { 0, 0, 0 };\n\n    vs->client_pf = qemu_default_pixelformat(32);\n\n    vnc_write_u8(vs, vs->client_pf.bits_per_pixel); /* bits-per-pixel */\n    vnc_write_u8(vs, vs->client_pf.depth); /* depth */\n\n#ifdef HOST_WORDS_BIGENDIAN\n    vnc_write_u8(vs, 1);             /* big-endian-flag */\n#else\n    vnc_write_u8(vs, 0);             /* big-endian-flag */\n#endif\n    vnc_write_u8(vs, 1);             /* true-color-flag */\n    vnc_write_u16(vs, vs->client_pf.rmax);     /* red-max */\n    vnc_write_u16(vs, vs->client_pf.gmax);     /* green-max */\n    vnc_write_u16(vs, vs->client_pf.bmax);     /* blue-max */\n    vnc_write_u8(vs, vs->client_pf.rshift);    /* red-shift */\n    vnc_write_u8(vs, vs->client_pf.gshift);    /* green-shift */\n    vnc_write_u8(vs, vs->client_pf.bshift);    /* blue-shift */\n    vnc_write(vs, pad, 3);           /* padding */\n\n    vnc_hextile_set_pixel_conversion(vs, 0);\n    vs->write_pixels = vnc_write_pixels_copy;\n}\n\nstatic void vnc_colordepth(VncState *vs)\n{\n    if (vnc_has_feature(vs, VNC_FEATURE_WMVI)) {\n        /* Sending a WMVi message to notify the client*/\n        vnc_lock_output(vs);\n        vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n        vnc_write_u8(vs, 0);\n        vnc_write_u16(vs, 1); /* number of rects */\n        vnc_framebuffer_update(vs, 0, 0,\n                               surface_width(vs->vd->ds),\n                               surface_height(vs->vd->ds),\n                               VNC_ENCODING_WMVi);\n        pixel_format_message(vs);\n        vnc_unlock_output(vs);\n        vnc_flush(vs);\n    } else {\n        set_pixel_conversion(vs);\n    }\n}\n\nstatic int protocol_client_msg(VncState *vs, uint8_t *data, size_t len)\n{\n    int i;\n    uint16_t limit;\n    VncDisplay *vd = vs->vd;\n\n    if (data[0] > 3) {\n        update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);\n    }\n\n    switch (data[0]) {\n    case VNC_MSG_CLIENT_SET_PIXEL_FORMAT:\n        if (len == 1)\n            return 20;\n\n        set_pixel_format(vs, read_u8(data, 4), read_u8(data, 5),\n                         read_u8(data, 6), read_u8(data, 7),\n                         read_u16(data, 8), read_u16(data, 10),\n                         read_u16(data, 12), read_u8(data, 14),\n                         read_u8(data, 15), read_u8(data, 16));\n        break;\n    case VNC_MSG_CLIENT_SET_ENCODINGS:\n        if (len == 1)\n            return 4;\n\n        if (len == 4) {\n            limit = read_u16(data, 2);\n            if (limit > 0)\n                return 4 + (limit * 4);\n        } else\n            limit = read_u16(data, 2);\n\n        for (i = 0; i < limit; i++) {\n            int32_t val = read_s32(data, 4 + (i * 4));\n            memcpy(data + 4 + (i * 4), &val, sizeof(val));\n        }\n\n        set_encodings(vs, (int32_t *)(data + 4), limit);\n        break;\n    case VNC_MSG_CLIENT_FRAMEBUFFER_UPDATE_REQUEST:\n        if (len == 1)\n            return 10;\n\n        framebuffer_update_request(vs,\n                                   read_u8(data, 1), read_u16(data, 2), read_u16(data, 4),\n                                   read_u16(data, 6), read_u16(data, 8));\n        break;\n    case VNC_MSG_CLIENT_KEY_EVENT:\n        if (len == 1)\n            return 8;\n\n        key_event(vs, read_u8(data, 1), read_u32(data, 4));\n        break;\n    case VNC_MSG_CLIENT_POINTER_EVENT:\n        if (len == 1)\n            return 6;\n\n        pointer_event(vs, read_u8(data, 1), read_u16(data, 2), read_u16(data, 4));\n        break;\n    case VNC_MSG_CLIENT_CUT_TEXT:\n        if (len == 1)\n            return 8;\n\n        if (len == 8) {\n            uint32_t dlen = read_u32(data, 4);\n            if (dlen > 0)\n                return 8 + dlen;\n        }\n\n        client_cut_text(vs, read_u32(data, 4), data + 8);\n        break;\n    case VNC_MSG_CLIENT_QEMU:\n        if (len == 1)\n            return 2;\n\n        switch (read_u8(data, 1)) {\n        case VNC_MSG_CLIENT_QEMU_EXT_KEY_EVENT:\n            if (len == 2)\n                return 12;\n\n            ext_key_event(vs, read_u16(data, 2),\n                          read_u32(data, 4), read_u32(data, 8));\n            break;\n        case VNC_MSG_CLIENT_QEMU_AUDIO:\n            if (len == 2)\n                return 4;\n\n            switch (read_u16 (data, 2)) {\n            case VNC_MSG_CLIENT_QEMU_AUDIO_ENABLE:\n                audio_add(vs);\n                break;\n            case VNC_MSG_CLIENT_QEMU_AUDIO_DISABLE:\n                audio_del(vs);\n                break;\n            case VNC_MSG_CLIENT_QEMU_AUDIO_SET_FORMAT:\n                if (len == 4)\n                    return 10;\n                switch (read_u8(data, 4)) {\n                case 0: vs->as.fmt = AUD_FMT_U8; break;\n                case 1: vs->as.fmt = AUD_FMT_S8; break;\n                case 2: vs->as.fmt = AUD_FMT_U16; break;\n                case 3: vs->as.fmt = AUD_FMT_S16; break;\n                case 4: vs->as.fmt = AUD_FMT_U32; break;\n                case 5: vs->as.fmt = AUD_FMT_S32; break;\n                default:\n                    printf(\"Invalid audio format %d\\n\", read_u8(data, 4));\n                    vnc_client_error(vs);\n                    break;\n                }\n                vs->as.nchannels = read_u8(data, 5);\n                if (vs->as.nchannels != 1 && vs->as.nchannels != 2) {\n                    printf(\"Invalid audio channel coount %d\\n\",\n                           read_u8(data, 5));\n                    vnc_client_error(vs);\n                    break;\n                }\n                vs->as.freq = read_u32(data, 6);\n                break;\n            default:\n                printf (\"Invalid audio message %d\\n\", read_u8(data, 4));\n                vnc_client_error(vs);\n                break;\n            }\n            break;\n\n        default:\n            printf(\"Msg: %d\\n\", read_u16(data, 0));\n            vnc_client_error(vs);\n            break;\n        }\n        break;\n    default:\n        printf(\"Msg: %d\\n\", data[0]);\n        vnc_client_error(vs);\n        break;\n    }\n\n    vnc_read_when(vs, protocol_client_msg, 1);\n    return 0;\n}\n\nstatic int protocol_client_init(VncState *vs, uint8_t *data, size_t len)\n{\n    char buf[1024];\n    VncShareMode mode;\n    int size;\n\n    mode = data[0] ? VNC_SHARE_MODE_SHARED : VNC_SHARE_MODE_EXCLUSIVE;\n    switch (vs->vd->share_policy) {\n    case VNC_SHARE_POLICY_IGNORE:\n        /*\n         * Ignore the shared flag.  Nothing to do here.\n         *\n         * Doesn't conform to the rfb spec but is traditional qemu\n         * behavior, thus left here as option for compatibility\n         * reasons.\n         */\n        break;\n    case VNC_SHARE_POLICY_ALLOW_EXCLUSIVE:\n        /*\n         * Policy: Allow clients ask for exclusive access.\n         *\n         * Implementation: When a client asks for exclusive access,\n         * disconnect all others. Shared connects are allowed as long\n         * as no exclusive connection exists.\n         *\n         * This is how the rfb spec suggests to handle the shared flag.\n         */\n        if (mode == VNC_SHARE_MODE_EXCLUSIVE) {\n            VncState *client;\n            QTAILQ_FOREACH(client, &vs->vd->clients, next) {\n                if (vs == client) {\n                    continue;\n                }\n                if (client->share_mode != VNC_SHARE_MODE_EXCLUSIVE &&\n                    client->share_mode != VNC_SHARE_MODE_SHARED) {\n                    continue;\n                }\n                vnc_disconnect_start(client);\n            }\n        }\n        if (mode == VNC_SHARE_MODE_SHARED) {\n            if (vs->vd->num_exclusive > 0) {\n                vnc_disconnect_start(vs);\n                return 0;\n            }\n        }\n        break;\n    case VNC_SHARE_POLICY_FORCE_SHARED:\n        /*\n         * Policy: Shared connects only.\n         * Implementation: Disallow clients asking for exclusive access.\n         *\n         * Useful for shared desktop sessions where you don't want\n         * someone forgetting to say -shared when running the vnc\n         * client disconnect everybody else.\n         */\n        if (mode == VNC_SHARE_MODE_EXCLUSIVE) {\n            vnc_disconnect_start(vs);\n            return 0;\n        }\n        break;\n    }\n    vnc_set_share_mode(vs, mode);\n\n    vs->client_width = surface_width(vs->vd->ds);\n    vs->client_height = surface_height(vs->vd->ds);\n    vnc_write_u16(vs, vs->client_width);\n    vnc_write_u16(vs, vs->client_height);\n\n    pixel_format_message(vs);\n\n    if (qemu_name)\n        size = snprintf(buf, sizeof(buf), \"QEMU (%s)\", qemu_name);\n    else\n        size = snprintf(buf, sizeof(buf), \"QEMU\");\n\n    vnc_write_u32(vs, size);\n    vnc_write(vs, buf, size);\n    vnc_flush(vs);\n\n    vnc_client_cache_auth(vs);\n    vnc_qmp_event(vs, QAPI_EVENT_VNC_INITIALIZED);\n\n    vnc_read_when(vs, protocol_client_msg, 1);\n\n    return 0;\n}\n\nvoid start_client_init(VncState *vs)\n{\n    vnc_read_when(vs, protocol_client_init, 1);\n}\n\nstatic void make_challenge(VncState *vs)\n{\n    int i;\n\n    srand(time(NULL)+getpid()+getpid()*987654+rand());\n\n    for (i = 0 ; i < sizeof(vs->challenge) ; i++)\n        vs->challenge[i] = (int) (256.0*rand()/(RAND_MAX+1.0));\n}\n\nstatic int protocol_client_auth_vnc(VncState *vs, uint8_t *data, size_t len)\n{\n    unsigned char response[VNC_AUTH_CHALLENGE_SIZE];\n    int i, j, pwlen;\n    unsigned char key[8];\n    time_t now = time(NULL);\n\n    if (!vs->vd->password) {\n        VNC_DEBUG(\"No password configured on server\");\n        goto reject;\n    }\n    if (vs->vd->expires < now) {\n        VNC_DEBUG(\"Password is expired\");\n        goto reject;\n    }\n\n    memcpy(response, vs->challenge, VNC_AUTH_CHALLENGE_SIZE);\n\n    /* Calculate the expected challenge response */\n    pwlen = strlen(vs->vd->password);\n    for (i=0; i<sizeof(key); i++)\n        key[i] = i<pwlen ? vs->vd->password[i] : 0;\n    deskey(key, EN0);\n    for (j = 0; j < VNC_AUTH_CHALLENGE_SIZE; j += 8)\n        des(response+j, response+j);\n\n    /* Compare expected vs actual challenge response */\n    if (memcmp(response, data, VNC_AUTH_CHALLENGE_SIZE) != 0) {\n        VNC_DEBUG(\"Client challenge response did not match\\n\");\n        goto reject;\n    } else {\n        VNC_DEBUG(\"Accepting VNC challenge response\\n\");\n        vnc_write_u32(vs, 0); /* Accept auth */\n        vnc_flush(vs);\n\n        start_client_init(vs);\n    }\n    return 0;\n\nreject:\n    vnc_write_u32(vs, 1); /* Reject auth */\n    if (vs->minor >= 8) {\n        static const char err[] = \"Authentication failed\";\n        vnc_write_u32(vs, sizeof(err));\n        vnc_write(vs, err, sizeof(err));\n    }\n    vnc_flush(vs);\n    vnc_client_error(vs);\n    return 0;\n}\n\nvoid start_auth_vnc(VncState *vs)\n{\n    make_challenge(vs);\n    /* Send client a 'random' challenge */\n    vnc_write(vs, vs->challenge, sizeof(vs->challenge));\n    vnc_flush(vs);\n\n    vnc_read_when(vs, protocol_client_auth_vnc, sizeof(vs->challenge));\n}\n\n\nstatic int protocol_client_auth(VncState *vs, uint8_t *data, size_t len)\n{\n    /* We only advertise 1 auth scheme at a time, so client\n     * must pick the one we sent. Verify this */\n    if (data[0] != vs->auth) { /* Reject auth */\n       VNC_DEBUG(\"Reject auth %d because it didn't match advertized\\n\", (int)data[0]);\n       vnc_write_u32(vs, 1);\n       if (vs->minor >= 8) {\n           static const char err[] = \"Authentication failed\";\n           vnc_write_u32(vs, sizeof(err));\n           vnc_write(vs, err, sizeof(err));\n       }\n       vnc_client_error(vs);\n    } else { /* Accept requested auth */\n       VNC_DEBUG(\"Client requested auth %d\\n\", (int)data[0]);\n       switch (vs->auth) {\n       case VNC_AUTH_NONE:\n           VNC_DEBUG(\"Accept auth none\\n\");\n           if (vs->minor >= 8) {\n               vnc_write_u32(vs, 0); /* Accept auth completion */\n               vnc_flush(vs);\n           }\n           start_client_init(vs);\n           break;\n\n       case VNC_AUTH_VNC:\n           VNC_DEBUG(\"Start VNC auth\\n\");\n           start_auth_vnc(vs);\n           break;\n\n#ifdef CONFIG_VNC_TLS\n       case VNC_AUTH_VENCRYPT:\n           VNC_DEBUG(\"Accept VeNCrypt auth\\n\");\n           start_auth_vencrypt(vs);\n           break;\n#endif /* CONFIG_VNC_TLS */\n\n#ifdef CONFIG_VNC_SASL\n       case VNC_AUTH_SASL:\n           VNC_DEBUG(\"Accept SASL auth\\n\");\n           start_auth_sasl(vs);\n           break;\n#endif /* CONFIG_VNC_SASL */\n\n       default: /* Should not be possible, but just in case */\n           VNC_DEBUG(\"Reject auth %d server code bug\\n\", vs->auth);\n           vnc_write_u8(vs, 1);\n           if (vs->minor >= 8) {\n               static const char err[] = \"Authentication failed\";\n               vnc_write_u32(vs, sizeof(err));\n               vnc_write(vs, err, sizeof(err));\n           }\n           vnc_client_error(vs);\n       }\n    }\n    return 0;\n}\n\nstatic int protocol_version(VncState *vs, uint8_t *version, size_t len)\n{\n    char local[13];\n\n    memcpy(local, version, 12);\n    local[12] = 0;\n\n    if (sscanf(local, \"RFB %03d.%03d\\n\", &vs->major, &vs->minor) != 2) {\n        VNC_DEBUG(\"Malformed protocol version %s\\n\", local);\n        vnc_client_error(vs);\n        return 0;\n    }\n    VNC_DEBUG(\"Client request protocol version %d.%d\\n\", vs->major, vs->minor);\n    if (vs->major != 3 ||\n        (vs->minor != 3 &&\n         vs->minor != 4 &&\n         vs->minor != 5 &&\n         vs->minor != 7 &&\n         vs->minor != 8)) {\n        VNC_DEBUG(\"Unsupported client version\\n\");\n        vnc_write_u32(vs, VNC_AUTH_INVALID);\n        vnc_flush(vs);\n        vnc_client_error(vs);\n        return 0;\n    }\n    /* Some broken clients report v3.4 or v3.5, which spec requires to be treated\n     * as equivalent to v3.3 by servers\n     */\n    if (vs->minor == 4 || vs->minor == 5)\n        vs->minor = 3;\n\n    if (vs->minor == 3) {\n        if (vs->auth == VNC_AUTH_NONE) {\n            VNC_DEBUG(\"Tell client auth none\\n\");\n            vnc_write_u32(vs, vs->auth);\n            vnc_flush(vs);\n            start_client_init(vs);\n       } else if (vs->auth == VNC_AUTH_VNC) {\n            VNC_DEBUG(\"Tell client VNC auth\\n\");\n            vnc_write_u32(vs, vs->auth);\n            vnc_flush(vs);\n            start_auth_vnc(vs);\n       } else {\n            VNC_DEBUG(\"Unsupported auth %d for protocol 3.3\\n\", vs->auth);\n            vnc_write_u32(vs, VNC_AUTH_INVALID);\n            vnc_flush(vs);\n            vnc_client_error(vs);\n       }\n    } else {\n        VNC_DEBUG(\"Telling client we support auth %d\\n\", vs->auth);\n        vnc_write_u8(vs, 1); /* num auth */\n        vnc_write_u8(vs, vs->auth);\n        vnc_read_when(vs, protocol_client_auth, 1);\n        vnc_flush(vs);\n    }\n\n    return 0;\n}\n\nstatic VncRectStat *vnc_stat_rect(VncDisplay *vd, int x, int y)\n{\n    struct VncSurface *vs = &vd->guest;\n\n    return &vs->stats[y / VNC_STAT_RECT][x / VNC_STAT_RECT];\n}\n\nvoid vnc_sent_lossy_rect(VncState *vs, int x, int y, int w, int h)\n{\n    int i, j;\n\n    w = (x + w) / VNC_STAT_RECT;\n    h = (y + h) / VNC_STAT_RECT;\n    x /= VNC_STAT_RECT;\n    y /= VNC_STAT_RECT;\n\n    for (j = y; j <= h; j++) {\n        for (i = x; i <= w; i++) {\n            vs->lossy_rect[j][i] = 1;\n        }\n    }\n}\n\nstatic int vnc_refresh_lossy_rect(VncDisplay *vd, int x, int y)\n{\n    VncState *vs;\n    int sty = y / VNC_STAT_RECT;\n    int stx = x / VNC_STAT_RECT;\n    int has_dirty = 0;\n\n    y = y / VNC_STAT_RECT * VNC_STAT_RECT;\n    x = x / VNC_STAT_RECT * VNC_STAT_RECT;\n\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        int j;\n\n        /* kernel send buffers are full -> refresh later */\n        if (vs->output.offset) {\n            continue;\n        }\n\n        if (!vs->lossy_rect[sty][stx]) {\n            continue;\n        }\n\n        vs->lossy_rect[sty][stx] = 0;\n        for (j = 0; j < VNC_STAT_RECT; ++j) {\n            bitmap_set(vs->dirty[y + j],\n                       x / VNC_DIRTY_PIXELS_PER_BIT,\n                       VNC_STAT_RECT / VNC_DIRTY_PIXELS_PER_BIT);\n        }\n        has_dirty++;\n    }\n\n    return has_dirty;\n}\n\nstatic int vnc_update_stats(VncDisplay *vd,  struct timeval * tv)\n{\n    int width = pixman_image_get_width(vd->guest.fb);\n    int height = pixman_image_get_height(vd->guest.fb);\n    int x, y;\n    struct timeval res;\n    int has_dirty = 0;\n\n    for (y = 0; y < height; y += VNC_STAT_RECT) {\n        for (x = 0; x < width; x += VNC_STAT_RECT) {\n            VncRectStat *rect = vnc_stat_rect(vd, x, y);\n\n            rect->updated = false;\n        }\n    }\n\n    qemu_timersub(tv, &VNC_REFRESH_STATS, &res);\n\n    if (timercmp(&vd->guest.last_freq_check, &res, >)) {\n        return has_dirty;\n    }\n    vd->guest.last_freq_check = *tv;\n\n    for (y = 0; y < height; y += VNC_STAT_RECT) {\n        for (x = 0; x < width; x += VNC_STAT_RECT) {\n            VncRectStat *rect= vnc_stat_rect(vd, x, y);\n            int count = ARRAY_SIZE(rect->times);\n            struct timeval min, max;\n\n            if (!timerisset(&rect->times[count - 1])) {\n                continue ;\n            }\n\n            max = rect->times[(rect->idx + count - 1) % count];\n            qemu_timersub(tv, &max, &res);\n\n            if (timercmp(&res, &VNC_REFRESH_LOSSY, >)) {\n                rect->freq = 0;\n                has_dirty += vnc_refresh_lossy_rect(vd, x, y);\n                memset(rect->times, 0, sizeof (rect->times));\n                continue ;\n            }\n\n            min = rect->times[rect->idx];\n            max = rect->times[(rect->idx + count - 1) % count];\n            qemu_timersub(&max, &min, &res);\n\n            rect->freq = res.tv_sec + res.tv_usec / 1000000.;\n            rect->freq /= count;\n            rect->freq = 1. / rect->freq;\n        }\n    }\n    return has_dirty;\n}\n\ndouble vnc_update_freq(VncState *vs, int x, int y, int w, int h)\n{\n    int i, j;\n    double total = 0;\n    int num = 0;\n\n    x =  (x / VNC_STAT_RECT) * VNC_STAT_RECT;\n    y =  (y / VNC_STAT_RECT) * VNC_STAT_RECT;\n\n    for (j = y; j <= y + h; j += VNC_STAT_RECT) {\n        for (i = x; i <= x + w; i += VNC_STAT_RECT) {\n            total += vnc_stat_rect(vs->vd, i, j)->freq;\n            num++;\n        }\n    }\n\n    if (num) {\n        return total / num;\n    } else {\n        return 0;\n    }\n}\n\nstatic void vnc_rect_updated(VncDisplay *vd, int x, int y, struct timeval * tv)\n{\n    VncRectStat *rect;\n\n    rect = vnc_stat_rect(vd, x, y);\n    if (rect->updated) {\n        return ;\n    }\n    rect->times[rect->idx] = *tv;\n    rect->idx = (rect->idx + 1) % ARRAY_SIZE(rect->times);\n    rect->updated = true;\n}\n\nstatic int vnc_refresh_server_surface(VncDisplay *vd)\n{\n    int width = pixman_image_get_width(vd->guest.fb);\n    int height = pixman_image_get_height(vd->guest.fb);\n    int y;\n    uint8_t *guest_row0 = NULL, *server_row0;\n    int guest_stride = 0, server_stride;\n    int cmp_bytes;\n    VncState *vs;\n    int has_dirty = 0;\n    pixman_image_t *tmpbuf = NULL;\n\n    struct timeval tv = { 0, 0 };\n\n    if (!vd->non_adaptive) {\n        gettimeofday(&tv, NULL);\n        has_dirty = vnc_update_stats(vd, &tv);\n    }\n\n    /*\n     * Walk through the guest dirty map.\n     * Check and copy modified bits from guest to server surface.\n     * Update server dirty map.\n     */\n    cmp_bytes = VNC_DIRTY_PIXELS_PER_BIT * VNC_SERVER_FB_BYTES;\n    if (cmp_bytes > vnc_server_fb_stride(vd)) {\n        cmp_bytes = vnc_server_fb_stride(vd);\n    }\n    if (vd->guest.format != VNC_SERVER_FB_FORMAT) {\n        int width = pixman_image_get_width(vd->server);\n        tmpbuf = qemu_pixman_linebuf_create(VNC_SERVER_FB_FORMAT, width);\n    } else {\n        guest_row0 = (uint8_t *)pixman_image_get_data(vd->guest.fb);\n        guest_stride = pixman_image_get_stride(vd->guest.fb);\n    }\n    server_row0 = (uint8_t *)pixman_image_get_data(vd->server);\n    server_stride = pixman_image_get_stride(vd->server);\n\n    y = 0;\n    for (;;) {\n        int x;\n        uint8_t *guest_ptr, *server_ptr;\n        unsigned long offset = find_next_bit((unsigned long *) &vd->guest.dirty,\n                                             height * VNC_DIRTY_BPL(&vd->guest),\n                                             y * VNC_DIRTY_BPL(&vd->guest));\n        if (offset == height * VNC_DIRTY_BPL(&vd->guest)) {\n            /* no more dirty bits */\n            break;\n        }\n        y = offset / VNC_DIRTY_BPL(&vd->guest);\n        x = offset % VNC_DIRTY_BPL(&vd->guest);\n\n        server_ptr = server_row0 + y * server_stride + x * cmp_bytes;\n\n        if (vd->guest.format != VNC_SERVER_FB_FORMAT) {\n            qemu_pixman_linebuf_fill(tmpbuf, vd->guest.fb, width, 0, y);\n            guest_ptr = (uint8_t *)pixman_image_get_data(tmpbuf);\n        } else {\n            guest_ptr = guest_row0 + y * guest_stride;\n        }\n        guest_ptr += x * cmp_bytes;\n\n        for (; x < DIV_ROUND_UP(width, VNC_DIRTY_PIXELS_PER_BIT);\n             x++, guest_ptr += cmp_bytes, server_ptr += cmp_bytes) {\n            if (!test_and_clear_bit(x, vd->guest.dirty[y])) {\n                continue;\n            }\n            if (memcmp(server_ptr, guest_ptr, cmp_bytes) == 0) {\n                continue;\n            }\n            memcpy(server_ptr, guest_ptr, cmp_bytes);\n            if (!vd->non_adaptive) {\n                vnc_rect_updated(vd, x * VNC_DIRTY_PIXELS_PER_BIT,\n                                 y, &tv);\n            }\n            QTAILQ_FOREACH(vs, &vd->clients, next) {\n                set_bit(x, vs->dirty[y]);\n            }\n            has_dirty++;\n        }\n\n        y++;\n    }\n    qemu_pixman_image_unref(tmpbuf);\n    return has_dirty;\n}\n\nstatic void vnc_refresh(DisplayChangeListener *dcl)\n{\n    VncDisplay *vd = container_of(dcl, VncDisplay, dcl);\n    VncState *vs, *vn;\n    int has_dirty, rects = 0;\n\n    graphic_hw_update(NULL);\n\n    if (vnc_trylock_display(vd)) {\n        update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);\n        return;\n    }\n\n    has_dirty = vnc_refresh_server_surface(vd);\n    vnc_unlock_display(vd);\n\n    QTAILQ_FOREACH_SAFE(vs, &vd->clients, next, vn) {\n        rects += vnc_update_client(vs, has_dirty, false);\n        /* vs might be free()ed here */\n    }\n\n    if (QTAILQ_EMPTY(&vd->clients)) {\n        update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_MAX);\n        return;\n    }\n\n    if (has_dirty && rects) {\n        vd->dcl.update_interval /= 2;\n        if (vd->dcl.update_interval < VNC_REFRESH_INTERVAL_BASE) {\n            vd->dcl.update_interval = VNC_REFRESH_INTERVAL_BASE;\n        }\n    } else {\n        vd->dcl.update_interval += VNC_REFRESH_INTERVAL_INC;\n        if (vd->dcl.update_interval > VNC_REFRESH_INTERVAL_MAX) {\n            vd->dcl.update_interval = VNC_REFRESH_INTERVAL_MAX;\n        }\n    }\n}\n\nstatic void vnc_connect(VncDisplay *vd, int csock,\n                        bool skipauth, bool websocket)\n{\n    VncState *vs = g_malloc0(sizeof(VncState));\n    int i;\n\n    vs->csock = csock;\n\n    if (skipauth) {\n\tvs->auth = VNC_AUTH_NONE;\n#ifdef CONFIG_VNC_TLS\n\tvs->subauth = VNC_AUTH_INVALID;\n#endif\n    } else {\n\tvs->auth = vd->auth;\n#ifdef CONFIG_VNC_TLS\n\tvs->subauth = vd->subauth;\n#endif\n    }\n\n    vs->lossy_rect = g_malloc0(VNC_STAT_ROWS * sizeof (*vs->lossy_rect));\n    for (i = 0; i < VNC_STAT_ROWS; ++i) {\n        vs->lossy_rect[i] = g_malloc0(VNC_STAT_COLS * sizeof (uint8_t));\n    }\n\n    VNC_DEBUG(\"New client on socket %d\\n\", csock);\n    update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);\n    qemu_set_nonblock(vs->csock);\n#ifdef CONFIG_VNC_WS\n    if (websocket) {\n        vs->websocket = 1;\n#ifdef CONFIG_VNC_TLS\n        if (vd->tls.x509cert) {\n            qemu_set_fd_handler2(vs->csock, NULL, vncws_tls_handshake_peek,\n                                 NULL, vs);\n        } else\n#endif /* CONFIG_VNC_TLS */\n        {\n            qemu_set_fd_handler2(vs->csock, NULL, vncws_handshake_read,\n                                 NULL, vs);\n        }\n    } else\n#endif /* CONFIG_VNC_WS */\n    {\n        qemu_set_fd_handler2(vs->csock, NULL, vnc_client_read, NULL, vs);\n    }\n\n    vnc_client_cache_addr(vs);\n    vnc_qmp_event(vs, QAPI_EVENT_VNC_CONNECTED);\n    vnc_set_share_mode(vs, VNC_SHARE_MODE_CONNECTING);\n\n    vs->vd = vd;\n\n#ifdef CONFIG_VNC_WS\n    if (!vs->websocket)\n#endif\n    {\n        vnc_init_state(vs);\n    }\n}\n\nvoid vnc_init_state(VncState *vs)\n{\n    vs->initialized = true;\n    VncDisplay *vd = vs->vd;\n\n    vs->last_x = -1;\n    vs->last_y = -1;\n\n    vs->as.freq = 44100;\n    vs->as.nchannels = 2;\n    vs->as.fmt = AUD_FMT_S16;\n    vs->as.endianness = 0;\n\n    qemu_mutex_init(&vs->output_mutex);\n    vs->bh = qemu_bh_new(vnc_jobs_bh, vs);\n\n    QTAILQ_INSERT_HEAD(&vd->clients, vs, next);\n\n    graphic_hw_update(NULL);\n\n    vnc_write(vs, \"RFB 003.008\\n\", 12);\n    vnc_flush(vs);\n    vnc_read_when(vs, protocol_version, 12);\n    reset_keys(vs);\n    if (vs->vd->lock_key_sync)\n        vs->led = qemu_add_led_event_handler(kbd_leds, vs);\n\n    vs->mouse_mode_notifier.notify = check_pointer_type_change;\n    qemu_add_mouse_mode_change_notifier(&vs->mouse_mode_notifier);\n\n    /* vs might be free()ed here */\n}\n\nstatic void vnc_listen_read(void *opaque, bool websocket)\n{\n    VncDisplay *vs = opaque;\n    struct sockaddr_in addr;\n    socklen_t addrlen = sizeof(addr);\n    int csock;\n\n    /* Catch-up */\n    graphic_hw_update(NULL);\n#ifdef CONFIG_VNC_WS\n    if (websocket) {\n        csock = qemu_accept(vs->lwebsock, (struct sockaddr *)&addr, &addrlen);\n    } else\n#endif /* CONFIG_VNC_WS */\n    {\n        csock = qemu_accept(vs->lsock, (struct sockaddr *)&addr, &addrlen);\n    }\n\n    if (csock != -1) {\n        vnc_connect(vs, csock, false, websocket);\n    }\n}\n\nstatic void vnc_listen_regular_read(void *opaque)\n{\n    vnc_listen_read(opaque, false);\n}\n\n#ifdef CONFIG_VNC_WS\nstatic void vnc_listen_websocket_read(void *opaque)\n{\n    vnc_listen_read(opaque, true);\n}\n#endif /* CONFIG_VNC_WS */\n\nstatic const DisplayChangeListenerOps dcl_ops = {\n    .dpy_name          = \"vnc\",\n    .dpy_refresh       = vnc_refresh,\n    .dpy_gfx_copy      = vnc_dpy_copy,\n    .dpy_gfx_update    = vnc_dpy_update,\n    .dpy_gfx_switch    = vnc_dpy_switch,\n    .dpy_mouse_set     = vnc_mouse_set,\n    .dpy_cursor_define = vnc_dpy_cursor_define,\n};\n\nvoid vnc_display_init(DisplayState *ds)\n{\n    VncDisplay *vs = g_malloc0(sizeof(*vs));\n\n    vnc_display = vs;\n\n    vs->lsock = -1;\n#ifdef CONFIG_VNC_WS\n    vs->lwebsock = -1;\n#endif\n\n    QTAILQ_INIT(&vs->clients);\n    vs->expires = TIME_MAX;\n\n    if (keyboard_layout) {\n        trace_vnc_key_map_init(keyboard_layout);\n        vs->kbd_layout = init_keyboard_layout(name2keysym, keyboard_layout);\n    } else {\n        vs->kbd_layout = init_keyboard_layout(name2keysym, \"en-us\");\n    }\n\n    if (!vs->kbd_layout)\n        exit(1);\n\n    qemu_mutex_init(&vs->mutex);\n    vnc_start_worker_thread();\n\n    vs->dcl.ops = &dcl_ops;\n    register_displaychangelistener(&vs->dcl);\n}\n\n\nstatic void vnc_display_close(DisplayState *ds)\n{\n    VncDisplay *vs = vnc_display;\n\n    if (!vs)\n        return;\n    g_free(vs->display);\n    vs->display = NULL;\n    if (vs->lsock != -1) {\n        qemu_set_fd_handler2(vs->lsock, NULL, NULL, NULL, NULL);\n        close(vs->lsock);\n        vs->lsock = -1;\n    }\n#ifdef CONFIG_VNC_WS\n    g_free(vs->ws_display);\n    vs->ws_display = NULL;\n    if (vs->lwebsock != -1) {\n        qemu_set_fd_handler2(vs->lwebsock, NULL, NULL, NULL, NULL);\n        close(vs->lwebsock);\n        vs->lwebsock = -1;\n    }\n#endif /* CONFIG_VNC_WS */\n    vs->auth = VNC_AUTH_INVALID;\n#ifdef CONFIG_VNC_TLS\n    vs->subauth = VNC_AUTH_INVALID;\n    vs->tls.x509verify = 0;\n#endif\n}\n\nint vnc_display_password(DisplayState *ds, const char *password)\n{\n    VncDisplay *vs = vnc_display;\n\n    if (!vs) {\n        return -EINVAL;\n    }\n    if (vs->auth == VNC_AUTH_NONE) {\n        error_printf_unless_qmp(\"If you want use passwords please enable \"\n                                \"password auth using '-vnc ${dpy},password'.\");\n        return -EINVAL;\n    }\n\n    g_free(vs->password);\n    vs->password = g_strdup(password);\n\n    return 0;\n}\n\nint vnc_display_pw_expire(DisplayState *ds, time_t expires)\n{\n    VncDisplay *vs = vnc_display;\n\n    if (!vs) {\n        return -EINVAL;\n    }\n\n    vs->expires = expires;\n    return 0;\n}\n\nchar *vnc_display_local_addr(DisplayState *ds)\n{\n    VncDisplay *vs = vnc_display;\n    \n    return vnc_socket_local_addr(\"%s:%s\", vs->lsock);\n}\n\nvoid vnc_display_open(DisplayState *ds, const char *display, Error **errp)\n{\n    VncDisplay *vs = vnc_display;\n    const char *options;\n    int password = 0;\n    int reverse = 0;\n#ifdef CONFIG_VNC_TLS\n    int tls = 0, x509 = 0;\n#endif\n#ifdef CONFIG_VNC_SASL\n    int sasl = 0;\n    int saslErr;\n#endif\n#if defined(CONFIG_VNC_TLS) || defined(CONFIG_VNC_SASL)\n    int acl = 0;\n#endif\n    int lock_key_sync = 1;\n\n    if (!vnc_display) {\n        error_setg(errp, \"VNC display not active\");\n        return;\n    }\n    vnc_display_close(ds);\n    if (strcmp(display, \"none\") == 0)\n        return;\n\n    vs->display = g_strdup(display);\n    vs->share_policy = VNC_SHARE_POLICY_ALLOW_EXCLUSIVE;\n\n    options = display;\n    while ((options = strchr(options, ','))) {\n        options++;\n        if (strncmp(options, \"password\", 8) == 0) {\n            if (fips_get_state()) {\n                error_setg(errp,\n                           \"VNC password auth disabled due to FIPS mode, \"\n                           \"consider using the VeNCrypt or SASL authentication \"\n                           \"methods as an alternative\");\n                goto fail;\n            }\n            password = 1; /* Require password auth */\n        } else if (strncmp(options, \"reverse\", 7) == 0) {\n            reverse = 1;\n        } else if (strncmp(options, \"no-lock-key-sync\", 16) == 0) {\n            lock_key_sync = 0;\n#ifdef CONFIG_VNC_SASL\n        } else if (strncmp(options, \"sasl\", 4) == 0) {\n            sasl = 1; /* Require SASL auth */\n#endif\n#ifdef CONFIG_VNC_WS\n        } else if (strncmp(options, \"websocket\", 9) == 0) {\n            char *start, *end;\n            vs->websocket = 1;\n\n            /* Check for 'websocket=<port>' */\n            start = strchr(options, '=');\n            end = strchr(options, ',');\n            if (start && (!end || (start < end))) {\n                int len = end ? end-(start+1) : strlen(start+1);\n                if (len < 6) {\n                    /* extract the host specification from display */\n                    char  *host = NULL, *port = NULL, *host_end = NULL;\n                    port = g_strndup(start + 1, len);\n\n                    /* ipv6 hosts have colons */\n                    end = strchr(display, ',');\n                    host_end = g_strrstr_len(display, end - display, \":\");\n\n                    if (host_end) {\n                        host = g_strndup(display, host_end - display + 1);\n                    } else {\n                        host = g_strndup(\":\", 1);\n                    }\n                    vs->ws_display = g_strconcat(host, port, NULL);\n                    g_free(host);\n                    g_free(port);\n                }\n            }\n#endif /* CONFIG_VNC_WS */\n#ifdef CONFIG_VNC_TLS\n        } else if (strncmp(options, \"tls\", 3) == 0) {\n            tls = 1; /* Require TLS */\n        } else if (strncmp(options, \"x509\", 4) == 0) {\n            char *start, *end;\n            x509 = 1; /* Require x509 certificates */\n            if (strncmp(options, \"x509verify\", 10) == 0)\n                vs->tls.x509verify = 1; /* ...and verify client certs */\n\n            /* Now check for 'x509=/some/path' postfix\n             * and use that to setup x509 certificate/key paths */\n            start = strchr(options, '=');\n            end = strchr(options, ',');\n            if (start && (!end || (start < end))) {\n                int len = end ? end-(start+1) : strlen(start+1);\n                char *path = g_strndup(start + 1, len);\n\n                VNC_DEBUG(\"Trying certificate path '%s'\\n\", path);\n                if (vnc_tls_set_x509_creds_dir(vs, path) < 0) {\n                    error_setg(errp, \"Failed to find x509 certificates/keys in %s\", path);\n                    g_free(path);\n                    goto fail;\n                }\n                g_free(path);\n            } else {\n                error_setg(errp, \"No certificate path provided\");\n                goto fail;\n            }\n#endif\n#if defined(CONFIG_VNC_TLS) || defined(CONFIG_VNC_SASL)\n        } else if (strncmp(options, \"acl\", 3) == 0) {\n            acl = 1;\n#endif\n        } else if (strncmp(options, \"lossy\", 5) == 0) {\n#ifdef CONFIG_VNC_JPEG\n            vs->lossy = true;\n#endif\n        } else if (strncmp(options, \"non-adaptive\", 12) == 0) {\n            vs->non_adaptive = true;\n        } else if (strncmp(options, \"share=\", 6) == 0) {\n            if (strncmp(options+6, \"ignore\", 6) == 0) {\n                vs->share_policy = VNC_SHARE_POLICY_IGNORE;\n            } else if (strncmp(options+6, \"allow-exclusive\", 15) == 0) {\n                vs->share_policy = VNC_SHARE_POLICY_ALLOW_EXCLUSIVE;\n            } else if (strncmp(options+6, \"force-shared\", 12) == 0) {\n                vs->share_policy = VNC_SHARE_POLICY_FORCE_SHARED;\n            } else {\n                error_setg(errp, \"unknown vnc share= option\");\n                goto fail;\n            }\n        }\n    }\n\n    /* adaptive updates are only used with tight encoding and\n     * if lossy updates are enabled so we can disable all the\n     * calculations otherwise */\n    if (!vs->lossy) {\n        vs->non_adaptive = true;\n    }\n\n#ifdef CONFIG_VNC_TLS\n    if (acl && x509 && vs->tls.x509verify) {\n        if (!(vs->tls.acl = qemu_acl_init(\"vnc.x509dname\"))) {\n            fprintf(stderr, \"Failed to create x509 dname ACL\\n\");\n            exit(1);\n        }\n    }\n#endif\n#ifdef CONFIG_VNC_SASL\n    if (acl && sasl) {\n        if (!(vs->sasl.acl = qemu_acl_init(\"vnc.username\"))) {\n            fprintf(stderr, \"Failed to create username ACL\\n\");\n            exit(1);\n        }\n    }\n#endif\n\n    /*\n     * Combinations we support here:\n     *\n     *  - no-auth                (clear text, no auth)\n     *  - password               (clear text, weak auth)\n     *  - sasl                   (encrypt, good auth *IF* using Kerberos via GSSAPI)\n     *  - tls                    (encrypt, weak anonymous creds, no auth)\n     *  - tls + password         (encrypt, weak anonymous creds, weak auth)\n     *  - tls + sasl             (encrypt, weak anonymous creds, good auth)\n     *  - tls + x509             (encrypt, good x509 creds, no auth)\n     *  - tls + x509 + password  (encrypt, good x509 creds, weak auth)\n     *  - tls + x509 + sasl      (encrypt, good x509 creds, good auth)\n     *\n     * NB1. TLS is a stackable auth scheme.\n     * NB2. the x509 schemes have option to validate a client cert dname\n     */\n    if (password) {\n#ifdef CONFIG_VNC_TLS\n        if (tls) {\n            vs->auth = VNC_AUTH_VENCRYPT;\n            if (x509) {\n                VNC_DEBUG(\"Initializing VNC server with x509 password auth\\n\");\n                vs->subauth = VNC_AUTH_VENCRYPT_X509VNC;\n            } else {\n                VNC_DEBUG(\"Initializing VNC server with TLS password auth\\n\");\n                vs->subauth = VNC_AUTH_VENCRYPT_TLSVNC;\n            }\n        } else {\n#endif /* CONFIG_VNC_TLS */\n            VNC_DEBUG(\"Initializing VNC server with password auth\\n\");\n            vs->auth = VNC_AUTH_VNC;\n#ifdef CONFIG_VNC_TLS\n            vs->subauth = VNC_AUTH_INVALID;\n        }\n#endif /* CONFIG_VNC_TLS */\n#ifdef CONFIG_VNC_SASL\n    } else if (sasl) {\n#ifdef CONFIG_VNC_TLS\n        if (tls) {\n            vs->auth = VNC_AUTH_VENCRYPT;\n            if (x509) {\n                VNC_DEBUG(\"Initializing VNC server with x509 SASL auth\\n\");\n                vs->subauth = VNC_AUTH_VENCRYPT_X509SASL;\n            } else {\n                VNC_DEBUG(\"Initializing VNC server with TLS SASL auth\\n\");\n                vs->subauth = VNC_AUTH_VENCRYPT_TLSSASL;\n            }\n        } else {\n#endif /* CONFIG_VNC_TLS */\n            VNC_DEBUG(\"Initializing VNC server with SASL auth\\n\");\n            vs->auth = VNC_AUTH_SASL;\n#ifdef CONFIG_VNC_TLS\n            vs->subauth = VNC_AUTH_INVALID;\n        }\n#endif /* CONFIG_VNC_TLS */\n#endif /* CONFIG_VNC_SASL */\n    } else {\n#ifdef CONFIG_VNC_TLS\n        if (tls) {\n            vs->auth = VNC_AUTH_VENCRYPT;\n            if (x509) {\n                VNC_DEBUG(\"Initializing VNC server with x509 no auth\\n\");\n                vs->subauth = VNC_AUTH_VENCRYPT_X509NONE;\n            } else {\n                VNC_DEBUG(\"Initializing VNC server with TLS no auth\\n\");\n                vs->subauth = VNC_AUTH_VENCRYPT_TLSNONE;\n            }\n        } else {\n#endif\n            VNC_DEBUG(\"Initializing VNC server with no auth\\n\");\n            vs->auth = VNC_AUTH_NONE;\n#ifdef CONFIG_VNC_TLS\n            vs->subauth = VNC_AUTH_INVALID;\n        }\n#endif\n    }\n\n#ifdef CONFIG_VNC_SASL\n    if ((saslErr = sasl_server_init(NULL, \"qemu\")) != SASL_OK) {\n        error_setg(errp, \"Failed to initialize SASL auth: %s\",\n                   sasl_errstring(saslErr, NULL, NULL));\n        goto fail;\n    }\n#endif\n    vs->lock_key_sync = lock_key_sync;\n\n    if (reverse) {\n        /* connect to viewer */\n        int csock;\n        vs->lsock = -1;\n#ifdef CONFIG_VNC_WS\n        vs->lwebsock = -1;\n#endif\n        if (strncmp(display, \"unix:\", 5) == 0) {\n            csock = unix_connect(display+5, errp);\n        } else {\n            csock = inet_connect(display, errp);\n        }\n        if (csock < 0) {\n            goto fail;\n        }\n        vnc_connect(vs, csock, false, false);\n    } else {\n        /* listen for connects */\n        char *dpy;\n        dpy = g_malloc(256);\n        if (strncmp(display, \"unix:\", 5) == 0) {\n            pstrcpy(dpy, 256, \"unix:\");\n            vs->lsock = unix_listen(display+5, dpy+5, 256-5, errp);\n        } else {\n            vs->lsock = inet_listen(display, dpy, 256,\n                                    SOCK_STREAM, 5900, errp);\n            if (vs->lsock < 0) {\n                g_free(dpy);\n                goto fail;\n            }\n#ifdef CONFIG_VNC_WS\n            if (vs->websocket) {\n                if (vs->ws_display) {\n                    vs->lwebsock = inet_listen(vs->ws_display, NULL, 256,\n                        SOCK_STREAM, 0, errp);\n                } else {\n                    vs->lwebsock = inet_listen(vs->display, NULL, 256,\n                        SOCK_STREAM, 5700, errp);\n                }\n\n                if (vs->lwebsock < 0) {\n                    if (vs->lsock) {\n                        close(vs->lsock);\n                        vs->lsock = -1;\n                    }\n                    g_free(dpy);\n                    goto fail;\n                }\n            }\n#endif /* CONFIG_VNC_WS */\n        }\n        g_free(vs->display);\n        vs->display = dpy;\n        qemu_set_fd_handler2(vs->lsock, NULL,\n                vnc_listen_regular_read, NULL, vs);\n#ifdef CONFIG_VNC_WS\n        if (vs->websocket) {\n            qemu_set_fd_handler2(vs->lwebsock, NULL,\n                    vnc_listen_websocket_read, NULL, vs);\n        }\n#endif /* CONFIG_VNC_WS */\n    }\n    return;\n\nfail:\n    g_free(vs->display);\n    vs->display = NULL;\n#ifdef CONFIG_VNC_WS\n    g_free(vs->ws_display);\n    vs->ws_display = NULL;\n#endif /* CONFIG_VNC_WS */\n}\n\nvoid vnc_display_add_client(DisplayState *ds, int csock, bool skipauth)\n{\n    VncDisplay *vs = vnc_display;\n\n    vnc_connect(vs, csock, skipauth, false);\n}\n"], "fixing_code": ["/*\n * QEMU VNC display driver\n *\n * Copyright (C) 2006 Anthony Liguori <anthony@codemonkey.ws>\n * Copyright (C) 2006 Fabrice Bellard\n * Copyright (C) 2009 Red Hat, Inc\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"vnc.h\"\n#include \"vnc-jobs.h\"\n#include \"trace.h\"\n#include \"sysemu/sysemu.h\"\n#include \"qemu/sockets.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/acl.h\"\n#include \"qapi/qmp/types.h\"\n#include \"qmp-commands.h\"\n#include \"qemu/osdep.h\"\n#include \"ui/input.h\"\n#include \"qapi-event.h\"\n\n#define VNC_REFRESH_INTERVAL_BASE GUI_REFRESH_INTERVAL_DEFAULT\n#define VNC_REFRESH_INTERVAL_INC  50\n#define VNC_REFRESH_INTERVAL_MAX  GUI_REFRESH_INTERVAL_IDLE\nstatic const struct timeval VNC_REFRESH_STATS = { 0, 500000 };\nstatic const struct timeval VNC_REFRESH_LOSSY = { 2, 0 };\n\n#include \"vnc_keysym.h\"\n#include \"d3des.h\"\n\nstatic VncDisplay *vnc_display; /* needed for info vnc */\n\nstatic int vnc_cursor_define(VncState *vs);\nstatic void vnc_release_modifiers(VncState *vs);\n\nstatic void vnc_set_share_mode(VncState *vs, VncShareMode mode)\n{\n#ifdef _VNC_DEBUG\n    static const char *mn[] = {\n        [0]                           = \"undefined\",\n        [VNC_SHARE_MODE_CONNECTING]   = \"connecting\",\n        [VNC_SHARE_MODE_SHARED]       = \"shared\",\n        [VNC_SHARE_MODE_EXCLUSIVE]    = \"exclusive\",\n        [VNC_SHARE_MODE_DISCONNECTED] = \"disconnected\",\n    };\n    fprintf(stderr, \"%s/%d: %s -> %s\\n\", __func__,\n            vs->csock, mn[vs->share_mode], mn[mode]);\n#endif\n\n    if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) {\n        vs->vd->num_exclusive--;\n    }\n    vs->share_mode = mode;\n    if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) {\n        vs->vd->num_exclusive++;\n    }\n}\n\nstatic char *addr_to_string(const char *format,\n                            struct sockaddr_storage *sa,\n                            socklen_t salen) {\n    char *addr;\n    char host[NI_MAXHOST];\n    char serv[NI_MAXSERV];\n    int err;\n    size_t addrlen;\n\n    if ((err = getnameinfo((struct sockaddr *)sa, salen,\n                           host, sizeof(host),\n                           serv, sizeof(serv),\n                           NI_NUMERICHOST | NI_NUMERICSERV)) != 0) {\n        VNC_DEBUG(\"Cannot resolve address %d: %s\\n\",\n                  err, gai_strerror(err));\n        return NULL;\n    }\n\n    /* Enough for the existing format + the 2 vars we're\n     * substituting in. */\n    addrlen = strlen(format) + strlen(host) + strlen(serv);\n    addr = g_malloc(addrlen + 1);\n    snprintf(addr, addrlen, format, host, serv);\n    addr[addrlen] = '\\0';\n\n    return addr;\n}\n\n\nchar *vnc_socket_local_addr(const char *format, int fd) {\n    struct sockaddr_storage sa;\n    socklen_t salen;\n\n    salen = sizeof(sa);\n    if (getsockname(fd, (struct sockaddr*)&sa, &salen) < 0)\n        return NULL;\n\n    return addr_to_string(format, &sa, salen);\n}\n\nchar *vnc_socket_remote_addr(const char *format, int fd) {\n    struct sockaddr_storage sa;\n    socklen_t salen;\n\n    salen = sizeof(sa);\n    if (getpeername(fd, (struct sockaddr*)&sa, &salen) < 0)\n        return NULL;\n\n    return addr_to_string(format, &sa, salen);\n}\n\nstatic VncBasicInfo *vnc_basic_info_get(struct sockaddr_storage *sa,\n                                        socklen_t salen)\n{\n    VncBasicInfo *info;\n    char host[NI_MAXHOST];\n    char serv[NI_MAXSERV];\n    int err;\n\n    if ((err = getnameinfo((struct sockaddr *)sa, salen,\n                           host, sizeof(host),\n                           serv, sizeof(serv),\n                           NI_NUMERICHOST | NI_NUMERICSERV)) != 0) {\n        VNC_DEBUG(\"Cannot resolve address %d: %s\\n\",\n                  err, gai_strerror(err));\n        return NULL;\n    }\n\n    info = g_malloc0(sizeof(VncBasicInfo));\n    info->host = g_strdup(host);\n    info->service = g_strdup(serv);\n    info->family = inet_netfamily(sa->ss_family);\n    return info;\n}\n\nstatic VncBasicInfo *vnc_basic_info_get_from_server_addr(int fd)\n{\n    struct sockaddr_storage sa;\n    socklen_t salen;\n\n    salen = sizeof(sa);\n    if (getsockname(fd, (struct sockaddr*)&sa, &salen) < 0) {\n        return NULL;\n    }\n\n    return vnc_basic_info_get(&sa, salen);\n}\n\nstatic VncBasicInfo *vnc_basic_info_get_from_remote_addr(int fd)\n{\n    struct sockaddr_storage sa;\n    socklen_t salen;\n\n    salen = sizeof(sa);\n    if (getpeername(fd, (struct sockaddr*)&sa, &salen) < 0) {\n        return NULL;\n    }\n\n    return vnc_basic_info_get(&sa, salen);\n}\n\nstatic const char *vnc_auth_name(VncDisplay *vd) {\n    switch (vd->auth) {\n    case VNC_AUTH_INVALID:\n        return \"invalid\";\n    case VNC_AUTH_NONE:\n        return \"none\";\n    case VNC_AUTH_VNC:\n        return \"vnc\";\n    case VNC_AUTH_RA2:\n        return \"ra2\";\n    case VNC_AUTH_RA2NE:\n        return \"ra2ne\";\n    case VNC_AUTH_TIGHT:\n        return \"tight\";\n    case VNC_AUTH_ULTRA:\n        return \"ultra\";\n    case VNC_AUTH_TLS:\n        return \"tls\";\n    case VNC_AUTH_VENCRYPT:\n#ifdef CONFIG_VNC_TLS\n        switch (vd->subauth) {\n        case VNC_AUTH_VENCRYPT_PLAIN:\n            return \"vencrypt+plain\";\n        case VNC_AUTH_VENCRYPT_TLSNONE:\n            return \"vencrypt+tls+none\";\n        case VNC_AUTH_VENCRYPT_TLSVNC:\n            return \"vencrypt+tls+vnc\";\n        case VNC_AUTH_VENCRYPT_TLSPLAIN:\n            return \"vencrypt+tls+plain\";\n        case VNC_AUTH_VENCRYPT_X509NONE:\n            return \"vencrypt+x509+none\";\n        case VNC_AUTH_VENCRYPT_X509VNC:\n            return \"vencrypt+x509+vnc\";\n        case VNC_AUTH_VENCRYPT_X509PLAIN:\n            return \"vencrypt+x509+plain\";\n        case VNC_AUTH_VENCRYPT_TLSSASL:\n            return \"vencrypt+tls+sasl\";\n        case VNC_AUTH_VENCRYPT_X509SASL:\n            return \"vencrypt+x509+sasl\";\n        default:\n            return \"vencrypt\";\n        }\n#else\n        return \"vencrypt\";\n#endif\n    case VNC_AUTH_SASL:\n        return \"sasl\";\n    }\n    return \"unknown\";\n}\n\nstatic VncServerInfo *vnc_server_info_get(void)\n{\n    VncServerInfo *info;\n    VncBasicInfo *bi = vnc_basic_info_get_from_server_addr(vnc_display->lsock);\n    if (!bi) {\n        return NULL;\n    }\n\n    info = g_malloc(sizeof(*info));\n    info->base = bi;\n    info->has_auth = true;\n    info->auth = g_strdup(vnc_auth_name(vnc_display));\n    return info;\n}\n\nstatic void vnc_client_cache_auth(VncState *client)\n{\n    if (!client->info) {\n        return;\n    }\n\n#ifdef CONFIG_VNC_TLS\n    if (client->tls.session &&\n        client->tls.dname) {\n        client->info->has_x509_dname = true;\n        client->info->x509_dname = g_strdup(client->tls.dname);\n    }\n#endif\n#ifdef CONFIG_VNC_SASL\n    if (client->sasl.conn &&\n        client->sasl.username) {\n        client->info->has_sasl_username = true;\n        client->info->sasl_username = g_strdup(client->sasl.username);\n    }\n#endif\n}\n\nstatic void vnc_client_cache_addr(VncState *client)\n{\n    VncBasicInfo *bi = vnc_basic_info_get_from_remote_addr(client->csock);\n\n    if (bi) {\n        client->info = g_malloc0(sizeof(*client->info));\n        client->info->base = bi;\n    }\n}\n\nstatic void vnc_qmp_event(VncState *vs, QAPIEvent event)\n{\n    VncServerInfo *si;\n\n    if (!vs->info) {\n        return;\n    }\n    g_assert(vs->info->base);\n\n    si = vnc_server_info_get();\n    if (!si) {\n        return;\n    }\n\n    switch (event) {\n    case QAPI_EVENT_VNC_CONNECTED:\n        qapi_event_send_vnc_connected(si, vs->info->base, &error_abort);\n        break;\n    case QAPI_EVENT_VNC_INITIALIZED:\n        qapi_event_send_vnc_initialized(si, vs->info, &error_abort);\n        break;\n    case QAPI_EVENT_VNC_DISCONNECTED:\n        qapi_event_send_vnc_disconnected(si, vs->info, &error_abort);\n        break;\n    default:\n        break;\n    }\n\n    qapi_free_VncServerInfo(si);\n}\n\nstatic VncClientInfo *qmp_query_vnc_client(const VncState *client)\n{\n    struct sockaddr_storage sa;\n    socklen_t salen = sizeof(sa);\n    char host[NI_MAXHOST];\n    char serv[NI_MAXSERV];\n    VncClientInfo *info;\n\n    if (getpeername(client->csock, (struct sockaddr *)&sa, &salen) < 0) {\n        return NULL;\n    }\n\n    if (getnameinfo((struct sockaddr *)&sa, salen,\n                    host, sizeof(host),\n                    serv, sizeof(serv),\n                    NI_NUMERICHOST | NI_NUMERICSERV) < 0) {\n        return NULL;\n    }\n\n    info = g_malloc0(sizeof(*info));\n    info->base = g_malloc0(sizeof(*info->base));\n    info->base->host = g_strdup(host);\n    info->base->service = g_strdup(serv);\n    info->base->family = inet_netfamily(sa.ss_family);\n\n#ifdef CONFIG_VNC_TLS\n    if (client->tls.session && client->tls.dname) {\n        info->has_x509_dname = true;\n        info->x509_dname = g_strdup(client->tls.dname);\n    }\n#endif\n#ifdef CONFIG_VNC_SASL\n    if (client->sasl.conn && client->sasl.username) {\n        info->has_sasl_username = true;\n        info->sasl_username = g_strdup(client->sasl.username);\n    }\n#endif\n\n    return info;\n}\n\nVncInfo *qmp_query_vnc(Error **errp)\n{\n    VncInfo *info = g_malloc0(sizeof(*info));\n\n    if (vnc_display == NULL || vnc_display->display == NULL) {\n        info->enabled = false;\n    } else {\n        VncClientInfoList *cur_item = NULL;\n        struct sockaddr_storage sa;\n        socklen_t salen = sizeof(sa);\n        char host[NI_MAXHOST];\n        char serv[NI_MAXSERV];\n        VncState *client;\n\n        info->enabled = true;\n\n        /* for compatibility with the original command */\n        info->has_clients = true;\n\n        QTAILQ_FOREACH(client, &vnc_display->clients, next) {\n            VncClientInfoList *cinfo = g_malloc0(sizeof(*info));\n            cinfo->value = qmp_query_vnc_client(client);\n\n            /* XXX: waiting for the qapi to support GSList */\n            if (!cur_item) {\n                info->clients = cur_item = cinfo;\n            } else {\n                cur_item->next = cinfo;\n                cur_item = cinfo;\n            }\n        }\n\n        if (vnc_display->lsock == -1) {\n            return info;\n        }\n\n        if (getsockname(vnc_display->lsock, (struct sockaddr *)&sa,\n                        &salen) == -1) {\n            error_set(errp, QERR_UNDEFINED_ERROR);\n            goto out_error;\n        }\n\n        if (getnameinfo((struct sockaddr *)&sa, salen,\n                        host, sizeof(host),\n                        serv, sizeof(serv),\n                        NI_NUMERICHOST | NI_NUMERICSERV) < 0) {\n            error_set(errp, QERR_UNDEFINED_ERROR);\n            goto out_error;\n        }\n\n        info->has_host = true;\n        info->host = g_strdup(host);\n\n        info->has_service = true;\n        info->service = g_strdup(serv);\n\n        info->has_family = true;\n        info->family = inet_netfamily(sa.ss_family);\n\n        info->has_auth = true;\n        info->auth = g_strdup(vnc_auth_name(vnc_display));\n    }\n\n    return info;\n\nout_error:\n    qapi_free_VncInfo(info);\n    return NULL;\n}\n\n/* TODO\n   1) Get the queue working for IO.\n   2) there is some weirdness when using the -S option (the screen is grey\n      and not totally invalidated\n   3) resolutions > 1024\n*/\n\nstatic int vnc_update_client(VncState *vs, int has_dirty, bool sync);\nstatic void vnc_disconnect_start(VncState *vs);\n\nstatic void vnc_colordepth(VncState *vs);\nstatic void framebuffer_update_request(VncState *vs, int incremental,\n                                       int x_position, int y_position,\n                                       int w, int h);\nstatic void vnc_refresh(DisplayChangeListener *dcl);\nstatic int vnc_refresh_server_surface(VncDisplay *vd);\n\nstatic void vnc_dpy_update(DisplayChangeListener *dcl,\n                           int x, int y, int w, int h)\n{\n    VncDisplay *vd = container_of(dcl, VncDisplay, dcl);\n    struct VncSurface *s = &vd->guest;\n    int width = surface_width(vd->ds);\n    int height = surface_height(vd->ds);\n\n    /* this is needed this to ensure we updated all affected\n     * blocks if x % VNC_DIRTY_PIXELS_PER_BIT != 0 */\n    w += (x % VNC_DIRTY_PIXELS_PER_BIT);\n    x -= (x % VNC_DIRTY_PIXELS_PER_BIT);\n\n    x = MIN(x, width);\n    y = MIN(y, height);\n    w = MIN(x + w, width) - x;\n    h = MIN(y + h, height);\n\n    for (; y < h; y++) {\n        bitmap_set(s->dirty[y], x / VNC_DIRTY_PIXELS_PER_BIT,\n                   DIV_ROUND_UP(w, VNC_DIRTY_PIXELS_PER_BIT));\n    }\n}\n\nvoid vnc_framebuffer_update(VncState *vs, int x, int y, int w, int h,\n                            int32_t encoding)\n{\n    vnc_write_u16(vs, x);\n    vnc_write_u16(vs, y);\n    vnc_write_u16(vs, w);\n    vnc_write_u16(vs, h);\n\n    vnc_write_s32(vs, encoding);\n}\n\nvoid buffer_reserve(Buffer *buffer, size_t len)\n{\n    if ((buffer->capacity - buffer->offset) < len) {\n        buffer->capacity += (len + 1024);\n        buffer->buffer = g_realloc(buffer->buffer, buffer->capacity);\n        if (buffer->buffer == NULL) {\n            fprintf(stderr, \"vnc: out of memory\\n\");\n            exit(1);\n        }\n    }\n}\n\nstatic int buffer_empty(Buffer *buffer)\n{\n    return buffer->offset == 0;\n}\n\nuint8_t *buffer_end(Buffer *buffer)\n{\n    return buffer->buffer + buffer->offset;\n}\n\nvoid buffer_reset(Buffer *buffer)\n{\n        buffer->offset = 0;\n}\n\nvoid buffer_free(Buffer *buffer)\n{\n    g_free(buffer->buffer);\n    buffer->offset = 0;\n    buffer->capacity = 0;\n    buffer->buffer = NULL;\n}\n\nvoid buffer_append(Buffer *buffer, const void *data, size_t len)\n{\n    memcpy(buffer->buffer + buffer->offset, data, len);\n    buffer->offset += len;\n}\n\nvoid buffer_advance(Buffer *buf, size_t len)\n{\n    memmove(buf->buffer, buf->buffer + len,\n            (buf->offset - len));\n    buf->offset -= len;\n}\n\nstatic void vnc_desktop_resize(VncState *vs)\n{\n    DisplaySurface *ds = vs->vd->ds;\n\n    if (vs->csock == -1 || !vnc_has_feature(vs, VNC_FEATURE_RESIZE)) {\n        return;\n    }\n    if (vs->client_width == surface_width(ds) &&\n        vs->client_height == surface_height(ds)) {\n        return;\n    }\n    vs->client_width = surface_width(ds);\n    vs->client_height = surface_height(ds);\n    vnc_lock_output(vs);\n    vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n    vnc_write_u8(vs, 0);\n    vnc_write_u16(vs, 1); /* number of rects */\n    vnc_framebuffer_update(vs, 0, 0, vs->client_width, vs->client_height,\n                           VNC_ENCODING_DESKTOPRESIZE);\n    vnc_unlock_output(vs);\n    vnc_flush(vs);\n}\n\nstatic void vnc_abort_display_jobs(VncDisplay *vd)\n{\n    VncState *vs;\n\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        vnc_lock_output(vs);\n        vs->abort = true;\n        vnc_unlock_output(vs);\n    }\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        vnc_jobs_join(vs);\n    }\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        vnc_lock_output(vs);\n        vs->abort = false;\n        vnc_unlock_output(vs);\n    }\n}\n\nint vnc_server_fb_stride(VncDisplay *vd)\n{\n    return pixman_image_get_stride(vd->server);\n}\n\nvoid *vnc_server_fb_ptr(VncDisplay *vd, int x, int y)\n{\n    uint8_t *ptr;\n\n    ptr  = (uint8_t *)pixman_image_get_data(vd->server);\n    ptr += y * vnc_server_fb_stride(vd);\n    ptr += x * VNC_SERVER_FB_BYTES;\n    return ptr;\n}\n/* this sets only the visible pixels of a dirty bitmap */\n#define VNC_SET_VISIBLE_PIXELS_DIRTY(bitmap, w, h) {\\\n        int y;\\\n        memset(bitmap, 0x00, sizeof(bitmap));\\\n        for (y = 0; y < h; y++) {\\\n            bitmap_set(bitmap[y], 0,\\\n                       DIV_ROUND_UP(w, VNC_DIRTY_PIXELS_PER_BIT));\\\n        } \\\n    }\n\nstatic void vnc_dpy_switch(DisplayChangeListener *dcl,\n                           DisplaySurface *surface)\n{\n    VncDisplay *vd = container_of(dcl, VncDisplay, dcl);\n    VncState *vs;\n\n    vnc_abort_display_jobs(vd);\n\n    /* server surface */\n    qemu_pixman_image_unref(vd->server);\n    vd->ds = surface;\n    vd->server = pixman_image_create_bits(VNC_SERVER_FB_FORMAT,\n                                          surface_width(vd->ds),\n                                          surface_height(vd->ds),\n                                          NULL, 0);\n\n    /* guest surface */\n#if 0 /* FIXME */\n    if (ds_get_bytes_per_pixel(ds) != vd->guest.ds->pf.bytes_per_pixel)\n        console_color_init(ds);\n#endif\n    qemu_pixman_image_unref(vd->guest.fb);\n    vd->guest.fb = pixman_image_ref(surface->image);\n    vd->guest.format = surface->format;\n    VNC_SET_VISIBLE_PIXELS_DIRTY(vd->guest.dirty,\n                                 surface_width(vd->ds),\n                                 surface_height(vd->ds));\n\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        vnc_colordepth(vs);\n        vnc_desktop_resize(vs);\n        if (vs->vd->cursor) {\n            vnc_cursor_define(vs);\n        }\n        VNC_SET_VISIBLE_PIXELS_DIRTY(vs->dirty,\n                                     surface_width(vd->ds),\n                                     surface_height(vd->ds));\n    }\n}\n\n/* fastest code */\nstatic void vnc_write_pixels_copy(VncState *vs,\n                                  void *pixels, int size)\n{\n    vnc_write(vs, pixels, size);\n}\n\n/* slowest but generic code. */\nvoid vnc_convert_pixel(VncState *vs, uint8_t *buf, uint32_t v)\n{\n    uint8_t r, g, b;\n\n#if VNC_SERVER_FB_FORMAT == PIXMAN_FORMAT(32, PIXMAN_TYPE_ARGB, 0, 8, 8, 8)\n    r = (((v & 0x00ff0000) >> 16) << vs->client_pf.rbits) >> 8;\n    g = (((v & 0x0000ff00) >>  8) << vs->client_pf.gbits) >> 8;\n    b = (((v & 0x000000ff) >>  0) << vs->client_pf.bbits) >> 8;\n#else\n# error need some bits here if you change VNC_SERVER_FB_FORMAT\n#endif\n    v = (r << vs->client_pf.rshift) |\n        (g << vs->client_pf.gshift) |\n        (b << vs->client_pf.bshift);\n    switch (vs->client_pf.bytes_per_pixel) {\n    case 1:\n        buf[0] = v;\n        break;\n    case 2:\n        if (vs->client_be) {\n            buf[0] = v >> 8;\n            buf[1] = v;\n        } else {\n            buf[1] = v >> 8;\n            buf[0] = v;\n        }\n        break;\n    default:\n    case 4:\n        if (vs->client_be) {\n            buf[0] = v >> 24;\n            buf[1] = v >> 16;\n            buf[2] = v >> 8;\n            buf[3] = v;\n        } else {\n            buf[3] = v >> 24;\n            buf[2] = v >> 16;\n            buf[1] = v >> 8;\n            buf[0] = v;\n        }\n        break;\n    }\n}\n\nstatic void vnc_write_pixels_generic(VncState *vs,\n                                     void *pixels1, int size)\n{\n    uint8_t buf[4];\n\n    if (VNC_SERVER_FB_BYTES == 4) {\n        uint32_t *pixels = pixels1;\n        int n, i;\n        n = size >> 2;\n        for (i = 0; i < n; i++) {\n            vnc_convert_pixel(vs, buf, pixels[i]);\n            vnc_write(vs, buf, vs->client_pf.bytes_per_pixel);\n        }\n    }\n}\n\nint vnc_raw_send_framebuffer_update(VncState *vs, int x, int y, int w, int h)\n{\n    int i;\n    uint8_t *row;\n    VncDisplay *vd = vs->vd;\n\n    row = vnc_server_fb_ptr(vd, x, y);\n    for (i = 0; i < h; i++) {\n        vs->write_pixels(vs, row, w * VNC_SERVER_FB_BYTES);\n        row += vnc_server_fb_stride(vd);\n    }\n    return 1;\n}\n\nint vnc_send_framebuffer_update(VncState *vs, int x, int y, int w, int h)\n{\n    int n = 0;\n\n    switch(vs->vnc_encoding) {\n        case VNC_ENCODING_ZLIB:\n            n = vnc_zlib_send_framebuffer_update(vs, x, y, w, h);\n            break;\n        case VNC_ENCODING_HEXTILE:\n            vnc_framebuffer_update(vs, x, y, w, h, VNC_ENCODING_HEXTILE);\n            n = vnc_hextile_send_framebuffer_update(vs, x, y, w, h);\n            break;\n        case VNC_ENCODING_TIGHT:\n            n = vnc_tight_send_framebuffer_update(vs, x, y, w, h);\n            break;\n        case VNC_ENCODING_TIGHT_PNG:\n            n = vnc_tight_png_send_framebuffer_update(vs, x, y, w, h);\n            break;\n        case VNC_ENCODING_ZRLE:\n            n = vnc_zrle_send_framebuffer_update(vs, x, y, w, h);\n            break;\n        case VNC_ENCODING_ZYWRLE:\n            n = vnc_zywrle_send_framebuffer_update(vs, x, y, w, h);\n            break;\n        default:\n            vnc_framebuffer_update(vs, x, y, w, h, VNC_ENCODING_RAW);\n            n = vnc_raw_send_framebuffer_update(vs, x, y, w, h);\n            break;\n    }\n    return n;\n}\n\nstatic void vnc_copy(VncState *vs, int src_x, int src_y, int dst_x, int dst_y, int w, int h)\n{\n    /* send bitblit op to the vnc client */\n    vnc_lock_output(vs);\n    vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n    vnc_write_u8(vs, 0);\n    vnc_write_u16(vs, 1); /* number of rects */\n    vnc_framebuffer_update(vs, dst_x, dst_y, w, h, VNC_ENCODING_COPYRECT);\n    vnc_write_u16(vs, src_x);\n    vnc_write_u16(vs, src_y);\n    vnc_unlock_output(vs);\n    vnc_flush(vs);\n}\n\nstatic void vnc_dpy_copy(DisplayChangeListener *dcl,\n                         int src_x, int src_y,\n                         int dst_x, int dst_y, int w, int h)\n{\n    VncDisplay *vd = container_of(dcl, VncDisplay, dcl);\n    VncState *vs, *vn;\n    uint8_t *src_row;\n    uint8_t *dst_row;\n    int i, x, y, pitch, inc, w_lim, s;\n    int cmp_bytes;\n\n    vnc_refresh_server_surface(vd);\n    QTAILQ_FOREACH_SAFE(vs, &vd->clients, next, vn) {\n        if (vnc_has_feature(vs, VNC_FEATURE_COPYRECT)) {\n            vs->force_update = 1;\n            vnc_update_client(vs, 1, true);\n            /* vs might be free()ed here */\n        }\n    }\n\n    /* do bitblit op on the local surface too */\n    pitch = vnc_server_fb_stride(vd);\n    src_row = vnc_server_fb_ptr(vd, src_x, src_y);\n    dst_row = vnc_server_fb_ptr(vd, dst_x, dst_y);\n    y = dst_y;\n    inc = 1;\n    if (dst_y > src_y) {\n        /* copy backwards */\n        src_row += pitch * (h-1);\n        dst_row += pitch * (h-1);\n        pitch = -pitch;\n        y = dst_y + h - 1;\n        inc = -1;\n    }\n    w_lim = w - (VNC_DIRTY_PIXELS_PER_BIT - (dst_x % VNC_DIRTY_PIXELS_PER_BIT));\n    if (w_lim < 0) {\n        w_lim = w;\n    } else {\n        w_lim = w - (w_lim % VNC_DIRTY_PIXELS_PER_BIT);\n    }\n    for (i = 0; i < h; i++) {\n        for (x = 0; x <= w_lim;\n                x += s, src_row += cmp_bytes, dst_row += cmp_bytes) {\n            if (x == w_lim) {\n                if ((s = w - w_lim) == 0)\n                    break;\n            } else if (!x) {\n                s = (VNC_DIRTY_PIXELS_PER_BIT -\n                    (dst_x % VNC_DIRTY_PIXELS_PER_BIT));\n                s = MIN(s, w_lim);\n            } else {\n                s = VNC_DIRTY_PIXELS_PER_BIT;\n            }\n            cmp_bytes = s * VNC_SERVER_FB_BYTES;\n            if (memcmp(src_row, dst_row, cmp_bytes) == 0)\n                continue;\n            memmove(dst_row, src_row, cmp_bytes);\n            QTAILQ_FOREACH(vs, &vd->clients, next) {\n                if (!vnc_has_feature(vs, VNC_FEATURE_COPYRECT)) {\n                    set_bit(((x + dst_x) / VNC_DIRTY_PIXELS_PER_BIT),\n                            vs->dirty[y]);\n                }\n            }\n        }\n        src_row += pitch - w * VNC_SERVER_FB_BYTES;\n        dst_row += pitch - w * VNC_SERVER_FB_BYTES;\n        y += inc;\n    }\n\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        if (vnc_has_feature(vs, VNC_FEATURE_COPYRECT)) {\n            vnc_copy(vs, src_x, src_y, dst_x, dst_y, w, h);\n        }\n    }\n}\n\nstatic void vnc_mouse_set(DisplayChangeListener *dcl,\n                          int x, int y, int visible)\n{\n    /* can we ask the client(s) to move the pointer ??? */\n}\n\nstatic int vnc_cursor_define(VncState *vs)\n{\n    QEMUCursor *c = vs->vd->cursor;\n    int isize;\n\n    if (vnc_has_feature(vs, VNC_FEATURE_RICH_CURSOR)) {\n        vnc_lock_output(vs);\n        vnc_write_u8(vs,  VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n        vnc_write_u8(vs,  0);  /*  padding     */\n        vnc_write_u16(vs, 1);  /*  # of rects  */\n        vnc_framebuffer_update(vs, c->hot_x, c->hot_y, c->width, c->height,\n                               VNC_ENCODING_RICH_CURSOR);\n        isize = c->width * c->height * vs->client_pf.bytes_per_pixel;\n        vnc_write_pixels_generic(vs, c->data, isize);\n        vnc_write(vs, vs->vd->cursor_mask, vs->vd->cursor_msize);\n        vnc_unlock_output(vs);\n        return 0;\n    }\n    return -1;\n}\n\nstatic void vnc_dpy_cursor_define(DisplayChangeListener *dcl,\n                                  QEMUCursor *c)\n{\n    VncDisplay *vd = vnc_display;\n    VncState *vs;\n\n    cursor_put(vd->cursor);\n    g_free(vd->cursor_mask);\n\n    vd->cursor = c;\n    cursor_get(vd->cursor);\n    vd->cursor_msize = cursor_get_mono_bpl(c) * c->height;\n    vd->cursor_mask = g_malloc0(vd->cursor_msize);\n    cursor_get_mono_mask(c, 0, vd->cursor_mask);\n\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        vnc_cursor_define(vs);\n    }\n}\n\nstatic int find_and_clear_dirty_height(struct VncState *vs,\n                                       int y, int last_x, int x, int height)\n{\n    int h;\n\n    for (h = 1; h < (height - y); h++) {\n        if (!test_bit(last_x, vs->dirty[y + h])) {\n            break;\n        }\n        bitmap_clear(vs->dirty[y + h], last_x, x - last_x);\n    }\n\n    return h;\n}\n\nstatic int vnc_update_client(VncState *vs, int has_dirty, bool sync)\n{\n    if (vs->need_update && vs->csock != -1) {\n        VncDisplay *vd = vs->vd;\n        VncJob *job;\n        int y;\n        int height, width;\n        int n = 0;\n\n        if (vs->output.offset && !vs->audio_cap && !vs->force_update)\n            /* kernel send buffers are full -> drop frames to throttle */\n            return 0;\n\n        if (!has_dirty && !vs->audio_cap && !vs->force_update)\n            return 0;\n\n        /*\n         * Send screen updates to the vnc client using the server\n         * surface and server dirty map.  guest surface updates\n         * happening in parallel don't disturb us, the next pass will\n         * send them to the client.\n         */\n        job = vnc_job_new(vs);\n\n        height = MIN(pixman_image_get_height(vd->server), vs->client_height);\n        width = MIN(pixman_image_get_width(vd->server), vs->client_width);\n\n        y = 0;\n        for (;;) {\n            int x, h;\n            unsigned long x2;\n            unsigned long offset = find_next_bit((unsigned long *) &vs->dirty,\n                                                 height * VNC_DIRTY_BPL(vs),\n                                                 y * VNC_DIRTY_BPL(vs));\n            if (offset == height * VNC_DIRTY_BPL(vs)) {\n                /* no more dirty bits */\n                break;\n            }\n            y = offset / VNC_DIRTY_BPL(vs);\n            x = offset % VNC_DIRTY_BPL(vs);\n            x2 = find_next_zero_bit((unsigned long *) &vs->dirty[y],\n                                    VNC_DIRTY_BPL(vs), x);\n            bitmap_clear(vs->dirty[y], x, x2 - x);\n            h = find_and_clear_dirty_height(vs, y, x, x2, height);\n            x2 = MIN(x2, width / VNC_DIRTY_PIXELS_PER_BIT);\n            if (x2 > x) {\n                n += vnc_job_add_rect(job, x * VNC_DIRTY_PIXELS_PER_BIT, y,\n                                      (x2 - x) * VNC_DIRTY_PIXELS_PER_BIT, h);\n            }\n        }\n\n        vnc_job_push(job);\n        if (sync) {\n            vnc_jobs_join(vs);\n        }\n        vs->force_update = 0;\n        return n;\n    }\n\n    if (vs->csock == -1) {\n        vnc_disconnect_finish(vs);\n    } else if (sync) {\n        vnc_jobs_join(vs);\n    }\n\n    return 0;\n}\n\n/* audio */\nstatic void audio_capture_notify(void *opaque, audcnotification_e cmd)\n{\n    VncState *vs = opaque;\n\n    switch (cmd) {\n    case AUD_CNOTIFY_DISABLE:\n        vnc_lock_output(vs);\n        vnc_write_u8(vs, VNC_MSG_SERVER_QEMU);\n        vnc_write_u8(vs, VNC_MSG_SERVER_QEMU_AUDIO);\n        vnc_write_u16(vs, VNC_MSG_SERVER_QEMU_AUDIO_END);\n        vnc_unlock_output(vs);\n        vnc_flush(vs);\n        break;\n\n    case AUD_CNOTIFY_ENABLE:\n        vnc_lock_output(vs);\n        vnc_write_u8(vs, VNC_MSG_SERVER_QEMU);\n        vnc_write_u8(vs, VNC_MSG_SERVER_QEMU_AUDIO);\n        vnc_write_u16(vs, VNC_MSG_SERVER_QEMU_AUDIO_BEGIN);\n        vnc_unlock_output(vs);\n        vnc_flush(vs);\n        break;\n    }\n}\n\nstatic void audio_capture_destroy(void *opaque)\n{\n}\n\nstatic void audio_capture(void *opaque, void *buf, int size)\n{\n    VncState *vs = opaque;\n\n    vnc_lock_output(vs);\n    vnc_write_u8(vs, VNC_MSG_SERVER_QEMU);\n    vnc_write_u8(vs, VNC_MSG_SERVER_QEMU_AUDIO);\n    vnc_write_u16(vs, VNC_MSG_SERVER_QEMU_AUDIO_DATA);\n    vnc_write_u32(vs, size);\n    vnc_write(vs, buf, size);\n    vnc_unlock_output(vs);\n    vnc_flush(vs);\n}\n\nstatic void audio_add(VncState *vs)\n{\n    struct audio_capture_ops ops;\n\n    if (vs->audio_cap) {\n        error_report(\"audio already running\");\n        return;\n    }\n\n    ops.notify = audio_capture_notify;\n    ops.destroy = audio_capture_destroy;\n    ops.capture = audio_capture;\n\n    vs->audio_cap = AUD_add_capture(&vs->as, &ops, vs);\n    if (!vs->audio_cap) {\n        error_report(\"Failed to add audio capture\");\n    }\n}\n\nstatic void audio_del(VncState *vs)\n{\n    if (vs->audio_cap) {\n        AUD_del_capture(vs->audio_cap, vs);\n        vs->audio_cap = NULL;\n    }\n}\n\nstatic void vnc_disconnect_start(VncState *vs)\n{\n    if (vs->csock == -1)\n        return;\n    vnc_set_share_mode(vs, VNC_SHARE_MODE_DISCONNECTED);\n    qemu_set_fd_handler2(vs->csock, NULL, NULL, NULL, NULL);\n    closesocket(vs->csock);\n    vs->csock = -1;\n}\n\nvoid vnc_disconnect_finish(VncState *vs)\n{\n    int i;\n\n    vnc_jobs_join(vs); /* Wait encoding jobs */\n\n    vnc_lock_output(vs);\n    vnc_qmp_event(vs, QAPI_EVENT_VNC_DISCONNECTED);\n\n    buffer_free(&vs->input);\n    buffer_free(&vs->output);\n#ifdef CONFIG_VNC_WS\n    buffer_free(&vs->ws_input);\n    buffer_free(&vs->ws_output);\n#endif /* CONFIG_VNC_WS */\n\n    qapi_free_VncClientInfo(vs->info);\n\n    vnc_zlib_clear(vs);\n    vnc_tight_clear(vs);\n    vnc_zrle_clear(vs);\n\n#ifdef CONFIG_VNC_TLS\n    vnc_tls_client_cleanup(vs);\n#endif /* CONFIG_VNC_TLS */\n#ifdef CONFIG_VNC_SASL\n    vnc_sasl_client_cleanup(vs);\n#endif /* CONFIG_VNC_SASL */\n    audio_del(vs);\n    vnc_release_modifiers(vs);\n\n    if (vs->initialized) {\n        QTAILQ_REMOVE(&vs->vd->clients, vs, next);\n        qemu_remove_mouse_mode_change_notifier(&vs->mouse_mode_notifier);\n    }\n\n    if (vs->vd->lock_key_sync)\n        qemu_remove_led_event_handler(vs->led);\n    vnc_unlock_output(vs);\n\n    qemu_mutex_destroy(&vs->output_mutex);\n    if (vs->bh != NULL) {\n        qemu_bh_delete(vs->bh);\n    }\n    buffer_free(&vs->jobs_buffer);\n\n    for (i = 0; i < VNC_STAT_ROWS; ++i) {\n        g_free(vs->lossy_rect[i]);\n    }\n    g_free(vs->lossy_rect);\n    g_free(vs);\n}\n\nint vnc_client_io_error(VncState *vs, int ret, int last_errno)\n{\n    if (ret == 0 || ret == -1) {\n        if (ret == -1) {\n            switch (last_errno) {\n                case EINTR:\n                case EAGAIN:\n#ifdef _WIN32\n                case WSAEWOULDBLOCK:\n#endif\n                    return 0;\n                default:\n                    break;\n            }\n        }\n\n        VNC_DEBUG(\"Closing down client sock: ret %d, errno %d\\n\",\n                  ret, ret < 0 ? last_errno : 0);\n        vnc_disconnect_start(vs);\n\n        return 0;\n    }\n    return ret;\n}\n\n\nvoid vnc_client_error(VncState *vs)\n{\n    VNC_DEBUG(\"Closing down client sock: protocol error\\n\");\n    vnc_disconnect_start(vs);\n}\n\n#ifdef CONFIG_VNC_TLS\nstatic long vnc_client_write_tls(gnutls_session_t *session,\n                                 const uint8_t *data,\n                                 size_t datalen)\n{\n    long ret = gnutls_write(*session, data, datalen);\n    if (ret < 0) {\n        if (ret == GNUTLS_E_AGAIN) {\n            errno = EAGAIN;\n        } else {\n            errno = EIO;\n        }\n        ret = -1;\n    }\n    return ret;\n}\n#endif /* CONFIG_VNC_TLS */\n\n/*\n * Called to write a chunk of data to the client socket. The data may\n * be the raw data, or may have already been encoded by SASL.\n * The data will be written either straight onto the socket, or\n * written via the GNUTLS wrappers, if TLS/SSL encryption is enabled\n *\n * NB, it is theoretically possible to have 2 layers of encryption,\n * both SASL, and this TLS layer. It is highly unlikely in practice\n * though, since SASL encryption will typically be a no-op if TLS\n * is active\n *\n * Returns the number of bytes written, which may be less than\n * the requested 'datalen' if the socket would block. Returns\n * -1 on error, and disconnects the client socket.\n */\nlong vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t datalen)\n{\n    long ret;\n#ifdef CONFIG_VNC_TLS\n    if (vs->tls.session) {\n        ret = vnc_client_write_tls(&vs->tls.session, data, datalen);\n    } else {\n#ifdef CONFIG_VNC_WS\n        if (vs->ws_tls.session) {\n            ret = vnc_client_write_tls(&vs->ws_tls.session, data, datalen);\n        } else\n#endif /* CONFIG_VNC_WS */\n#endif /* CONFIG_VNC_TLS */\n        {\n            ret = send(vs->csock, (const void *)data, datalen, 0);\n        }\n#ifdef CONFIG_VNC_TLS\n    }\n#endif /* CONFIG_VNC_TLS */\n    VNC_DEBUG(\"Wrote wire %p %zd -> %ld\\n\", data, datalen, ret);\n    return vnc_client_io_error(vs, ret, socket_error());\n}\n\n\n/*\n * Called to write buffered data to the client socket, when not\n * using any SASL SSF encryption layers. Will write as much data\n * as possible without blocking. If all buffered data is written,\n * will switch the FD poll() handler back to read monitoring.\n *\n * Returns the number of bytes written, which may be less than\n * the buffered output data if the socket would block. Returns\n * -1 on error, and disconnects the client socket.\n */\nstatic long vnc_client_write_plain(VncState *vs)\n{\n    long ret;\n\n#ifdef CONFIG_VNC_SASL\n    VNC_DEBUG(\"Write Plain: Pending output %p size %zd offset %zd. Wait SSF %d\\n\",\n              vs->output.buffer, vs->output.capacity, vs->output.offset,\n              vs->sasl.waitWriteSSF);\n\n    if (vs->sasl.conn &&\n        vs->sasl.runSSF &&\n        vs->sasl.waitWriteSSF) {\n        ret = vnc_client_write_buf(vs, vs->output.buffer, vs->sasl.waitWriteSSF);\n        if (ret)\n            vs->sasl.waitWriteSSF -= ret;\n    } else\n#endif /* CONFIG_VNC_SASL */\n        ret = vnc_client_write_buf(vs, vs->output.buffer, vs->output.offset);\n    if (!ret)\n        return 0;\n\n    buffer_advance(&vs->output, ret);\n\n    if (vs->output.offset == 0) {\n        qemu_set_fd_handler2(vs->csock, NULL, vnc_client_read, NULL, vs);\n    }\n\n    return ret;\n}\n\n\n/*\n * First function called whenever there is data to be written to\n * the client socket. Will delegate actual work according to whether\n * SASL SSF layers are enabled (thus requiring encryption calls)\n */\nstatic void vnc_client_write_locked(void *opaque)\n{\n    VncState *vs = opaque;\n\n#ifdef CONFIG_VNC_SASL\n    if (vs->sasl.conn &&\n        vs->sasl.runSSF &&\n        !vs->sasl.waitWriteSSF) {\n        vnc_client_write_sasl(vs);\n    } else\n#endif /* CONFIG_VNC_SASL */\n    {\n#ifdef CONFIG_VNC_WS\n        if (vs->encode_ws) {\n            vnc_client_write_ws(vs);\n        } else\n#endif /* CONFIG_VNC_WS */\n        {\n            vnc_client_write_plain(vs);\n        }\n    }\n}\n\nvoid vnc_client_write(void *opaque)\n{\n    VncState *vs = opaque;\n\n    vnc_lock_output(vs);\n    if (vs->output.offset\n#ifdef CONFIG_VNC_WS\n            || vs->ws_output.offset\n#endif\n            ) {\n        vnc_client_write_locked(opaque);\n    } else if (vs->csock != -1) {\n        qemu_set_fd_handler2(vs->csock, NULL, vnc_client_read, NULL, vs);\n    }\n    vnc_unlock_output(vs);\n}\n\nvoid vnc_read_when(VncState *vs, VncReadEvent *func, size_t expecting)\n{\n    vs->read_handler = func;\n    vs->read_handler_expect = expecting;\n}\n\n#ifdef CONFIG_VNC_TLS\nstatic long vnc_client_read_tls(gnutls_session_t *session, uint8_t *data,\n                                size_t datalen)\n{\n    long ret = gnutls_read(*session, data, datalen);\n    if (ret < 0) {\n        if (ret == GNUTLS_E_AGAIN) {\n            errno = EAGAIN;\n        } else {\n            errno = EIO;\n        }\n        ret = -1;\n    }\n    return ret;\n}\n#endif /* CONFIG_VNC_TLS */\n\n/*\n * Called to read a chunk of data from the client socket. The data may\n * be the raw data, or may need to be further decoded by SASL.\n * The data will be read either straight from to the socket, or\n * read via the GNUTLS wrappers, if TLS/SSL encryption is enabled\n *\n * NB, it is theoretically possible to have 2 layers of encryption,\n * both SASL, and this TLS layer. It is highly unlikely in practice\n * though, since SASL encryption will typically be a no-op if TLS\n * is active\n *\n * Returns the number of bytes read, which may be less than\n * the requested 'datalen' if the socket would block. Returns\n * -1 on error, and disconnects the client socket.\n */\nlong vnc_client_read_buf(VncState *vs, uint8_t *data, size_t datalen)\n{\n    long ret;\n#ifdef CONFIG_VNC_TLS\n    if (vs->tls.session) {\n        ret = vnc_client_read_tls(&vs->tls.session, data, datalen);\n    } else {\n#ifdef CONFIG_VNC_WS\n        if (vs->ws_tls.session) {\n            ret = vnc_client_read_tls(&vs->ws_tls.session, data, datalen);\n        } else\n#endif /* CONFIG_VNC_WS */\n#endif /* CONFIG_VNC_TLS */\n        {\n            ret = qemu_recv(vs->csock, data, datalen, 0);\n        }\n#ifdef CONFIG_VNC_TLS\n    }\n#endif /* CONFIG_VNC_TLS */\n    VNC_DEBUG(\"Read wire %p %zd -> %ld\\n\", data, datalen, ret);\n    return vnc_client_io_error(vs, ret, socket_error());\n}\n\n\n/*\n * Called to read data from the client socket to the input buffer,\n * when not using any SASL SSF encryption layers. Will read as much\n * data as possible without blocking.\n *\n * Returns the number of bytes read. Returns -1 on error, and\n * disconnects the client socket.\n */\nstatic long vnc_client_read_plain(VncState *vs)\n{\n    int ret;\n    VNC_DEBUG(\"Read plain %p size %zd offset %zd\\n\",\n              vs->input.buffer, vs->input.capacity, vs->input.offset);\n    buffer_reserve(&vs->input, 4096);\n    ret = vnc_client_read_buf(vs, buffer_end(&vs->input), 4096);\n    if (!ret)\n        return 0;\n    vs->input.offset += ret;\n    return ret;\n}\n\nstatic void vnc_jobs_bh(void *opaque)\n{\n    VncState *vs = opaque;\n\n    vnc_jobs_consume_buffer(vs);\n}\n\n/*\n * First function called whenever there is more data to be read from\n * the client socket. Will delegate actual work according to whether\n * SASL SSF layers are enabled (thus requiring decryption calls)\n */\nvoid vnc_client_read(void *opaque)\n{\n    VncState *vs = opaque;\n    long ret;\n\n#ifdef CONFIG_VNC_SASL\n    if (vs->sasl.conn && vs->sasl.runSSF)\n        ret = vnc_client_read_sasl(vs);\n    else\n#endif /* CONFIG_VNC_SASL */\n#ifdef CONFIG_VNC_WS\n        if (vs->encode_ws) {\n            ret = vnc_client_read_ws(vs);\n            if (ret == -1) {\n                vnc_disconnect_start(vs);\n                return;\n            } else if (ret == -2) {\n                vnc_client_error(vs);\n                return;\n            }\n        } else\n#endif /* CONFIG_VNC_WS */\n        {\n        ret = vnc_client_read_plain(vs);\n        }\n    if (!ret) {\n        if (vs->csock == -1)\n            vnc_disconnect_finish(vs);\n        return;\n    }\n\n    while (vs->read_handler && vs->input.offset >= vs->read_handler_expect) {\n        size_t len = vs->read_handler_expect;\n        int ret;\n\n        ret = vs->read_handler(vs, vs->input.buffer, len);\n        if (vs->csock == -1) {\n            vnc_disconnect_finish(vs);\n            return;\n        }\n\n        if (!ret) {\n            buffer_advance(&vs->input, len);\n        } else {\n            vs->read_handler_expect = ret;\n        }\n    }\n}\n\nvoid vnc_write(VncState *vs, const void *data, size_t len)\n{\n    buffer_reserve(&vs->output, len);\n\n    if (vs->csock != -1 && buffer_empty(&vs->output)) {\n        qemu_set_fd_handler2(vs->csock, NULL, vnc_client_read, vnc_client_write, vs);\n    }\n\n    buffer_append(&vs->output, data, len);\n}\n\nvoid vnc_write_s32(VncState *vs, int32_t value)\n{\n    vnc_write_u32(vs, *(uint32_t *)&value);\n}\n\nvoid vnc_write_u32(VncState *vs, uint32_t value)\n{\n    uint8_t buf[4];\n\n    buf[0] = (value >> 24) & 0xFF;\n    buf[1] = (value >> 16) & 0xFF;\n    buf[2] = (value >>  8) & 0xFF;\n    buf[3] = value & 0xFF;\n\n    vnc_write(vs, buf, 4);\n}\n\nvoid vnc_write_u16(VncState *vs, uint16_t value)\n{\n    uint8_t buf[2];\n\n    buf[0] = (value >> 8) & 0xFF;\n    buf[1] = value & 0xFF;\n\n    vnc_write(vs, buf, 2);\n}\n\nvoid vnc_write_u8(VncState *vs, uint8_t value)\n{\n    vnc_write(vs, (char *)&value, 1);\n}\n\nvoid vnc_flush(VncState *vs)\n{\n    vnc_lock_output(vs);\n    if (vs->csock != -1 && (vs->output.offset\n#ifdef CONFIG_VNC_WS\n                || vs->ws_output.offset\n#endif\n                )) {\n        vnc_client_write_locked(vs);\n    }\n    vnc_unlock_output(vs);\n}\n\nstatic uint8_t read_u8(uint8_t *data, size_t offset)\n{\n    return data[offset];\n}\n\nstatic uint16_t read_u16(uint8_t *data, size_t offset)\n{\n    return ((data[offset] & 0xFF) << 8) | (data[offset + 1] & 0xFF);\n}\n\nstatic int32_t read_s32(uint8_t *data, size_t offset)\n{\n    return (int32_t)((data[offset] << 24) | (data[offset + 1] << 16) |\n                     (data[offset + 2] << 8) | data[offset + 3]);\n}\n\nuint32_t read_u32(uint8_t *data, size_t offset)\n{\n    return ((data[offset] << 24) | (data[offset + 1] << 16) |\n            (data[offset + 2] << 8) | data[offset + 3]);\n}\n\nstatic void client_cut_text(VncState *vs, size_t len, uint8_t *text)\n{\n}\n\nstatic void check_pointer_type_change(Notifier *notifier, void *data)\n{\n    VncState *vs = container_of(notifier, VncState, mouse_mode_notifier);\n    int absolute = qemu_input_is_absolute();\n\n    if (vnc_has_feature(vs, VNC_FEATURE_POINTER_TYPE_CHANGE) && vs->absolute != absolute) {\n        vnc_lock_output(vs);\n        vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n        vnc_write_u8(vs, 0);\n        vnc_write_u16(vs, 1);\n        vnc_framebuffer_update(vs, absolute, 0,\n                               surface_width(vs->vd->ds),\n                               surface_height(vs->vd->ds),\n                               VNC_ENCODING_POINTER_TYPE_CHANGE);\n        vnc_unlock_output(vs);\n        vnc_flush(vs);\n    }\n    vs->absolute = absolute;\n}\n\nstatic void pointer_event(VncState *vs, int button_mask, int x, int y)\n{\n    static uint32_t bmap[INPUT_BUTTON_MAX] = {\n        [INPUT_BUTTON_LEFT]       = 0x01,\n        [INPUT_BUTTON_MIDDLE]     = 0x02,\n        [INPUT_BUTTON_RIGHT]      = 0x04,\n        [INPUT_BUTTON_WHEEL_UP]   = 0x08,\n        [INPUT_BUTTON_WHEEL_DOWN] = 0x10,\n    };\n    QemuConsole *con = vs->vd->dcl.con;\n    int width = surface_width(vs->vd->ds);\n    int height = surface_height(vs->vd->ds);\n\n    if (vs->last_bmask != button_mask) {\n        qemu_input_update_buttons(con, bmap, vs->last_bmask, button_mask);\n        vs->last_bmask = button_mask;\n    }\n\n    if (vs->absolute) {\n        qemu_input_queue_abs(con, INPUT_AXIS_X, x, width);\n        qemu_input_queue_abs(con, INPUT_AXIS_Y, y, height);\n    } else if (vnc_has_feature(vs, VNC_FEATURE_POINTER_TYPE_CHANGE)) {\n        qemu_input_queue_rel(con, INPUT_AXIS_X, x - 0x7FFF);\n        qemu_input_queue_rel(con, INPUT_AXIS_Y, y - 0x7FFF);\n    } else {\n        if (vs->last_x != -1) {\n            qemu_input_queue_rel(con, INPUT_AXIS_X, x - vs->last_x);\n            qemu_input_queue_rel(con, INPUT_AXIS_Y, y - vs->last_y);\n        }\n        vs->last_x = x;\n        vs->last_y = y;\n    }\n    qemu_input_event_sync();\n}\n\nstatic void reset_keys(VncState *vs)\n{\n    int i;\n    for(i = 0; i < 256; i++) {\n        if (vs->modifiers_state[i]) {\n            qemu_input_event_send_key_number(vs->vd->dcl.con, i, false);\n            vs->modifiers_state[i] = 0;\n        }\n    }\n}\n\nstatic void press_key(VncState *vs, int keysym)\n{\n    int keycode = keysym2scancode(vs->vd->kbd_layout, keysym) & SCANCODE_KEYMASK;\n    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, true);\n    qemu_input_event_send_key_delay(0);\n    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, false);\n    qemu_input_event_send_key_delay(0);\n}\n\nstatic int current_led_state(VncState *vs)\n{\n    int ledstate = 0;\n\n    if (vs->modifiers_state[0x46]) {\n        ledstate |= QEMU_SCROLL_LOCK_LED;\n    }\n    if (vs->modifiers_state[0x45]) {\n        ledstate |= QEMU_NUM_LOCK_LED;\n    }\n    if (vs->modifiers_state[0x3a]) {\n        ledstate |= QEMU_CAPS_LOCK_LED;\n    }\n\n    return ledstate;\n}\n\nstatic void vnc_led_state_change(VncState *vs)\n{\n    int ledstate = 0;\n\n    if (!vnc_has_feature(vs, VNC_FEATURE_LED_STATE)) {\n        return;\n    }\n\n    ledstate = current_led_state(vs);\n    vnc_lock_output(vs);\n    vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n    vnc_write_u8(vs, 0);\n    vnc_write_u16(vs, 1);\n    vnc_framebuffer_update(vs, 0, 0, 1, 1, VNC_ENCODING_LED_STATE);\n    vnc_write_u8(vs, ledstate);\n    vnc_unlock_output(vs);\n    vnc_flush(vs);\n}\n\nstatic void kbd_leds(void *opaque, int ledstate)\n{\n    VncState *vs = opaque;\n    int caps, num, scr;\n    bool has_changed = (ledstate != current_led_state(vs));\n\n    trace_vnc_key_guest_leds((ledstate & QEMU_CAPS_LOCK_LED),\n                             (ledstate & QEMU_NUM_LOCK_LED),\n                             (ledstate & QEMU_SCROLL_LOCK_LED));\n\n    caps = ledstate & QEMU_CAPS_LOCK_LED ? 1 : 0;\n    num  = ledstate & QEMU_NUM_LOCK_LED  ? 1 : 0;\n    scr  = ledstate & QEMU_SCROLL_LOCK_LED ? 1 : 0;\n\n    if (vs->modifiers_state[0x3a] != caps) {\n        vs->modifiers_state[0x3a] = caps;\n    }\n    if (vs->modifiers_state[0x45] != num) {\n        vs->modifiers_state[0x45] = num;\n    }\n    if (vs->modifiers_state[0x46] != scr) {\n        vs->modifiers_state[0x46] = scr;\n    }\n\n    /* Sending the current led state message to the client */\n    if (has_changed) {\n        vnc_led_state_change(vs);\n    }\n}\n\nstatic void do_key_event(VncState *vs, int down, int keycode, int sym)\n{\n    /* QEMU console switch */\n    switch(keycode) {\n    case 0x2a:                          /* Left Shift */\n    case 0x36:                          /* Right Shift */\n    case 0x1d:                          /* Left CTRL */\n    case 0x9d:                          /* Right CTRL */\n    case 0x38:                          /* Left ALT */\n    case 0xb8:                          /* Right ALT */\n        if (down)\n            vs->modifiers_state[keycode] = 1;\n        else\n            vs->modifiers_state[keycode] = 0;\n        break;\n    case 0x02 ... 0x0a: /* '1' to '9' keys */\n        if (down && vs->modifiers_state[0x1d] && vs->modifiers_state[0x38]) {\n            /* Reset the modifiers sent to the current console */\n            reset_keys(vs);\n            console_select(keycode - 0x02);\n            return;\n        }\n        break;\n    case 0x3a:                        /* CapsLock */\n    case 0x45:                        /* NumLock */\n        if (down)\n            vs->modifiers_state[keycode] ^= 1;\n        break;\n    }\n\n    /* Turn off the lock state sync logic if the client support the led\n       state extension.\n    */\n    if (down && vs->vd->lock_key_sync &&\n        !vnc_has_feature(vs, VNC_FEATURE_LED_STATE) &&\n        keycode_is_keypad(vs->vd->kbd_layout, keycode)) {\n        /* If the numlock state needs to change then simulate an additional\n           keypress before sending this one.  This will happen if the user\n           toggles numlock away from the VNC window.\n        */\n        if (keysym_is_numlock(vs->vd->kbd_layout, sym & 0xFFFF)) {\n            if (!vs->modifiers_state[0x45]) {\n                trace_vnc_key_sync_numlock(true);\n                vs->modifiers_state[0x45] = 1;\n                press_key(vs, 0xff7f);\n            }\n        } else {\n            if (vs->modifiers_state[0x45]) {\n                trace_vnc_key_sync_numlock(false);\n                vs->modifiers_state[0x45] = 0;\n                press_key(vs, 0xff7f);\n            }\n        }\n    }\n\n    if (down && vs->vd->lock_key_sync &&\n        !vnc_has_feature(vs, VNC_FEATURE_LED_STATE) &&\n        ((sym >= 'A' && sym <= 'Z') || (sym >= 'a' && sym <= 'z'))) {\n        /* If the capslock state needs to change then simulate an additional\n           keypress before sending this one.  This will happen if the user\n           toggles capslock away from the VNC window.\n        */\n        int uppercase = !!(sym >= 'A' && sym <= 'Z');\n        int shift = !!(vs->modifiers_state[0x2a] | vs->modifiers_state[0x36]);\n        int capslock = !!(vs->modifiers_state[0x3a]);\n        if (capslock) {\n            if (uppercase == shift) {\n                trace_vnc_key_sync_capslock(false);\n                vs->modifiers_state[0x3a] = 0;\n                press_key(vs, 0xffe5);\n            }\n        } else {\n            if (uppercase != shift) {\n                trace_vnc_key_sync_capslock(true);\n                vs->modifiers_state[0x3a] = 1;\n                press_key(vs, 0xffe5);\n            }\n        }\n    }\n\n    if (qemu_console_is_graphic(NULL)) {\n        qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, down);\n    } else {\n        bool numlock = vs->modifiers_state[0x45];\n        bool control = (vs->modifiers_state[0x1d] ||\n                        vs->modifiers_state[0x9d]);\n        /* QEMU console emulation */\n        if (down) {\n            switch (keycode) {\n            case 0x2a:                          /* Left Shift */\n            case 0x36:                          /* Right Shift */\n            case 0x1d:                          /* Left CTRL */\n            case 0x9d:                          /* Right CTRL */\n            case 0x38:                          /* Left ALT */\n            case 0xb8:                          /* Right ALT */\n                break;\n            case 0xc8:\n                kbd_put_keysym(QEMU_KEY_UP);\n                break;\n            case 0xd0:\n                kbd_put_keysym(QEMU_KEY_DOWN);\n                break;\n            case 0xcb:\n                kbd_put_keysym(QEMU_KEY_LEFT);\n                break;\n            case 0xcd:\n                kbd_put_keysym(QEMU_KEY_RIGHT);\n                break;\n            case 0xd3:\n                kbd_put_keysym(QEMU_KEY_DELETE);\n                break;\n            case 0xc7:\n                kbd_put_keysym(QEMU_KEY_HOME);\n                break;\n            case 0xcf:\n                kbd_put_keysym(QEMU_KEY_END);\n                break;\n            case 0xc9:\n                kbd_put_keysym(QEMU_KEY_PAGEUP);\n                break;\n            case 0xd1:\n                kbd_put_keysym(QEMU_KEY_PAGEDOWN);\n                break;\n\n            case 0x47:\n                kbd_put_keysym(numlock ? '7' : QEMU_KEY_HOME);\n                break;\n            case 0x48:\n                kbd_put_keysym(numlock ? '8' : QEMU_KEY_UP);\n                break;\n            case 0x49:\n                kbd_put_keysym(numlock ? '9' : QEMU_KEY_PAGEUP);\n                break;\n            case 0x4b:\n                kbd_put_keysym(numlock ? '4' : QEMU_KEY_LEFT);\n                break;\n            case 0x4c:\n                kbd_put_keysym('5');\n                break;\n            case 0x4d:\n                kbd_put_keysym(numlock ? '6' : QEMU_KEY_RIGHT);\n                break;\n            case 0x4f:\n                kbd_put_keysym(numlock ? '1' : QEMU_KEY_END);\n                break;\n            case 0x50:\n                kbd_put_keysym(numlock ? '2' : QEMU_KEY_DOWN);\n                break;\n            case 0x51:\n                kbd_put_keysym(numlock ? '3' : QEMU_KEY_PAGEDOWN);\n                break;\n            case 0x52:\n                kbd_put_keysym('0');\n                break;\n            case 0x53:\n                kbd_put_keysym(numlock ? '.' : QEMU_KEY_DELETE);\n                break;\n\n            case 0xb5:\n                kbd_put_keysym('/');\n                break;\n            case 0x37:\n                kbd_put_keysym('*');\n                break;\n            case 0x4a:\n                kbd_put_keysym('-');\n                break;\n            case 0x4e:\n                kbd_put_keysym('+');\n                break;\n            case 0x9c:\n                kbd_put_keysym('\\n');\n                break;\n\n            default:\n                if (control) {\n                    kbd_put_keysym(sym & 0x1f);\n                } else {\n                    kbd_put_keysym(sym);\n                }\n                break;\n            }\n        }\n    }\n}\n\nstatic void vnc_release_modifiers(VncState *vs)\n{\n    static const int keycodes[] = {\n        /* shift, control, alt keys, both left & right */\n        0x2a, 0x36, 0x1d, 0x9d, 0x38, 0xb8,\n    };\n    int i, keycode;\n\n    if (!qemu_console_is_graphic(NULL)) {\n        return;\n    }\n    for (i = 0; i < ARRAY_SIZE(keycodes); i++) {\n        keycode = keycodes[i];\n        if (!vs->modifiers_state[keycode]) {\n            continue;\n        }\n        qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, false);\n    }\n}\n\nstatic const char *code2name(int keycode)\n{\n    return QKeyCode_lookup[qemu_input_key_number_to_qcode(keycode)];\n}\n\nstatic void key_event(VncState *vs, int down, uint32_t sym)\n{\n    int keycode;\n    int lsym = sym;\n\n    if (lsym >= 'A' && lsym <= 'Z' && qemu_console_is_graphic(NULL)) {\n        lsym = lsym - 'A' + 'a';\n    }\n\n    keycode = keysym2scancode(vs->vd->kbd_layout, lsym & 0xFFFF) & SCANCODE_KEYMASK;\n    trace_vnc_key_event_map(down, sym, keycode, code2name(keycode));\n    do_key_event(vs, down, keycode, sym);\n}\n\nstatic void ext_key_event(VncState *vs, int down,\n                          uint32_t sym, uint16_t keycode)\n{\n    /* if the user specifies a keyboard layout, always use it */\n    if (keyboard_layout) {\n        key_event(vs, down, sym);\n    } else {\n        trace_vnc_key_event_ext(down, sym, keycode, code2name(keycode));\n        do_key_event(vs, down, keycode, sym);\n    }\n}\n\nstatic void framebuffer_update_request(VncState *vs, int incremental,\n                                       int x_position, int y_position,\n                                       int w, int h)\n{\n    int i;\n    const size_t width = surface_width(vs->vd->ds) / VNC_DIRTY_PIXELS_PER_BIT;\n    const size_t height = surface_height(vs->vd->ds);\n\n    if (y_position > height) {\n        y_position = height;\n    }\n    if (y_position + h >= height) {\n        h = height - y_position;\n    }\n\n    vs->need_update = 1;\n    if (!incremental) {\n        vs->force_update = 1;\n        for (i = 0; i < h; i++) {\n            bitmap_set(vs->dirty[y_position + i], 0, width);\n            bitmap_clear(vs->dirty[y_position + i], width,\n                         VNC_DIRTY_BITS - width);\n        }\n    }\n}\n\nstatic void send_ext_key_event_ack(VncState *vs)\n{\n    vnc_lock_output(vs);\n    vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n    vnc_write_u8(vs, 0);\n    vnc_write_u16(vs, 1);\n    vnc_framebuffer_update(vs, 0, 0,\n                           surface_width(vs->vd->ds),\n                           surface_height(vs->vd->ds),\n                           VNC_ENCODING_EXT_KEY_EVENT);\n    vnc_unlock_output(vs);\n    vnc_flush(vs);\n}\n\nstatic void send_ext_audio_ack(VncState *vs)\n{\n    vnc_lock_output(vs);\n    vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n    vnc_write_u8(vs, 0);\n    vnc_write_u16(vs, 1);\n    vnc_framebuffer_update(vs, 0, 0,\n                           surface_width(vs->vd->ds),\n                           surface_height(vs->vd->ds),\n                           VNC_ENCODING_AUDIO);\n    vnc_unlock_output(vs);\n    vnc_flush(vs);\n}\n\nstatic void set_encodings(VncState *vs, int32_t *encodings, size_t n_encodings)\n{\n    int i;\n    unsigned int enc = 0;\n\n    vs->features = 0;\n    vs->vnc_encoding = 0;\n    vs->tight.compression = 9;\n    vs->tight.quality = -1; /* Lossless by default */\n    vs->absolute = -1;\n\n    /*\n     * Start from the end because the encodings are sent in order of preference.\n     * This way the preferred encoding (first encoding defined in the array)\n     * will be set at the end of the loop.\n     */\n    for (i = n_encodings - 1; i >= 0; i--) {\n        enc = encodings[i];\n        switch (enc) {\n        case VNC_ENCODING_RAW:\n            vs->vnc_encoding = enc;\n            break;\n        case VNC_ENCODING_COPYRECT:\n            vs->features |= VNC_FEATURE_COPYRECT_MASK;\n            break;\n        case VNC_ENCODING_HEXTILE:\n            vs->features |= VNC_FEATURE_HEXTILE_MASK;\n            vs->vnc_encoding = enc;\n            break;\n        case VNC_ENCODING_TIGHT:\n            vs->features |= VNC_FEATURE_TIGHT_MASK;\n            vs->vnc_encoding = enc;\n            break;\n#ifdef CONFIG_VNC_PNG\n        case VNC_ENCODING_TIGHT_PNG:\n            vs->features |= VNC_FEATURE_TIGHT_PNG_MASK;\n            vs->vnc_encoding = enc;\n            break;\n#endif\n        case VNC_ENCODING_ZLIB:\n            vs->features |= VNC_FEATURE_ZLIB_MASK;\n            vs->vnc_encoding = enc;\n            break;\n        case VNC_ENCODING_ZRLE:\n            vs->features |= VNC_FEATURE_ZRLE_MASK;\n            vs->vnc_encoding = enc;\n            break;\n        case VNC_ENCODING_ZYWRLE:\n            vs->features |= VNC_FEATURE_ZYWRLE_MASK;\n            vs->vnc_encoding = enc;\n            break;\n        case VNC_ENCODING_DESKTOPRESIZE:\n            vs->features |= VNC_FEATURE_RESIZE_MASK;\n            break;\n        case VNC_ENCODING_POINTER_TYPE_CHANGE:\n            vs->features |= VNC_FEATURE_POINTER_TYPE_CHANGE_MASK;\n            break;\n        case VNC_ENCODING_RICH_CURSOR:\n            vs->features |= VNC_FEATURE_RICH_CURSOR_MASK;\n            break;\n        case VNC_ENCODING_EXT_KEY_EVENT:\n            send_ext_key_event_ack(vs);\n            break;\n        case VNC_ENCODING_AUDIO:\n            send_ext_audio_ack(vs);\n            break;\n        case VNC_ENCODING_WMVi:\n            vs->features |= VNC_FEATURE_WMVI_MASK;\n            break;\n        case VNC_ENCODING_LED_STATE:\n            vs->features |= VNC_FEATURE_LED_STATE_MASK;\n            break;\n        case VNC_ENCODING_COMPRESSLEVEL0 ... VNC_ENCODING_COMPRESSLEVEL0 + 9:\n            vs->tight.compression = (enc & 0x0F);\n            break;\n        case VNC_ENCODING_QUALITYLEVEL0 ... VNC_ENCODING_QUALITYLEVEL0 + 9:\n            if (vs->vd->lossy) {\n                vs->tight.quality = (enc & 0x0F);\n            }\n            break;\n        default:\n            VNC_DEBUG(\"Unknown encoding: %d (0x%.8x): %d\\n\", i, enc, enc);\n            break;\n        }\n    }\n    vnc_desktop_resize(vs);\n    check_pointer_type_change(&vs->mouse_mode_notifier, NULL);\n    vnc_led_state_change(vs);\n}\n\nstatic void set_pixel_conversion(VncState *vs)\n{\n    pixman_format_code_t fmt = qemu_pixman_get_format(&vs->client_pf);\n\n    if (fmt == VNC_SERVER_FB_FORMAT) {\n        vs->write_pixels = vnc_write_pixels_copy;\n        vnc_hextile_set_pixel_conversion(vs, 0);\n    } else {\n        vs->write_pixels = vnc_write_pixels_generic;\n        vnc_hextile_set_pixel_conversion(vs, 1);\n    }\n}\n\nstatic void set_pixel_format(VncState *vs,\n                             int bits_per_pixel, int depth,\n                             int big_endian_flag, int true_color_flag,\n                             int red_max, int green_max, int blue_max,\n                             int red_shift, int green_shift, int blue_shift)\n{\n    if (!true_color_flag) {\n        vnc_client_error(vs);\n        return;\n    }\n\n    vs->client_pf.rmax = red_max;\n    vs->client_pf.rbits = hweight_long(red_max);\n    vs->client_pf.rshift = red_shift;\n    vs->client_pf.rmask = red_max << red_shift;\n    vs->client_pf.gmax = green_max;\n    vs->client_pf.gbits = hweight_long(green_max);\n    vs->client_pf.gshift = green_shift;\n    vs->client_pf.gmask = green_max << green_shift;\n    vs->client_pf.bmax = blue_max;\n    vs->client_pf.bbits = hweight_long(blue_max);\n    vs->client_pf.bshift = blue_shift;\n    vs->client_pf.bmask = blue_max << blue_shift;\n    vs->client_pf.bits_per_pixel = bits_per_pixel;\n    vs->client_pf.bytes_per_pixel = bits_per_pixel / 8;\n    vs->client_pf.depth = bits_per_pixel == 32 ? 24 : bits_per_pixel;\n    vs->client_be = big_endian_flag;\n\n    set_pixel_conversion(vs);\n\n    graphic_hw_invalidate(NULL);\n    graphic_hw_update(NULL);\n}\n\nstatic void pixel_format_message (VncState *vs) {\n    char pad[3] = { 0, 0, 0 };\n\n    vs->client_pf = qemu_default_pixelformat(32);\n\n    vnc_write_u8(vs, vs->client_pf.bits_per_pixel); /* bits-per-pixel */\n    vnc_write_u8(vs, vs->client_pf.depth); /* depth */\n\n#ifdef HOST_WORDS_BIGENDIAN\n    vnc_write_u8(vs, 1);             /* big-endian-flag */\n#else\n    vnc_write_u8(vs, 0);             /* big-endian-flag */\n#endif\n    vnc_write_u8(vs, 1);             /* true-color-flag */\n    vnc_write_u16(vs, vs->client_pf.rmax);     /* red-max */\n    vnc_write_u16(vs, vs->client_pf.gmax);     /* green-max */\n    vnc_write_u16(vs, vs->client_pf.bmax);     /* blue-max */\n    vnc_write_u8(vs, vs->client_pf.rshift);    /* red-shift */\n    vnc_write_u8(vs, vs->client_pf.gshift);    /* green-shift */\n    vnc_write_u8(vs, vs->client_pf.bshift);    /* blue-shift */\n    vnc_write(vs, pad, 3);           /* padding */\n\n    vnc_hextile_set_pixel_conversion(vs, 0);\n    vs->write_pixels = vnc_write_pixels_copy;\n}\n\nstatic void vnc_colordepth(VncState *vs)\n{\n    if (vnc_has_feature(vs, VNC_FEATURE_WMVI)) {\n        /* Sending a WMVi message to notify the client*/\n        vnc_lock_output(vs);\n        vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n        vnc_write_u8(vs, 0);\n        vnc_write_u16(vs, 1); /* number of rects */\n        vnc_framebuffer_update(vs, 0, 0,\n                               surface_width(vs->vd->ds),\n                               surface_height(vs->vd->ds),\n                               VNC_ENCODING_WMVi);\n        pixel_format_message(vs);\n        vnc_unlock_output(vs);\n        vnc_flush(vs);\n    } else {\n        set_pixel_conversion(vs);\n    }\n}\n\nstatic int protocol_client_msg(VncState *vs, uint8_t *data, size_t len)\n{\n    int i;\n    uint16_t limit;\n    VncDisplay *vd = vs->vd;\n\n    if (data[0] > 3) {\n        update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);\n    }\n\n    switch (data[0]) {\n    case VNC_MSG_CLIENT_SET_PIXEL_FORMAT:\n        if (len == 1)\n            return 20;\n\n        set_pixel_format(vs, read_u8(data, 4), read_u8(data, 5),\n                         read_u8(data, 6), read_u8(data, 7),\n                         read_u16(data, 8), read_u16(data, 10),\n                         read_u16(data, 12), read_u8(data, 14),\n                         read_u8(data, 15), read_u8(data, 16));\n        break;\n    case VNC_MSG_CLIENT_SET_ENCODINGS:\n        if (len == 1)\n            return 4;\n\n        if (len == 4) {\n            limit = read_u16(data, 2);\n            if (limit > 0)\n                return 4 + (limit * 4);\n        } else\n            limit = read_u16(data, 2);\n\n        for (i = 0; i < limit; i++) {\n            int32_t val = read_s32(data, 4 + (i * 4));\n            memcpy(data + 4 + (i * 4), &val, sizeof(val));\n        }\n\n        set_encodings(vs, (int32_t *)(data + 4), limit);\n        break;\n    case VNC_MSG_CLIENT_FRAMEBUFFER_UPDATE_REQUEST:\n        if (len == 1)\n            return 10;\n\n        framebuffer_update_request(vs,\n                                   read_u8(data, 1), read_u16(data, 2), read_u16(data, 4),\n                                   read_u16(data, 6), read_u16(data, 8));\n        break;\n    case VNC_MSG_CLIENT_KEY_EVENT:\n        if (len == 1)\n            return 8;\n\n        key_event(vs, read_u8(data, 1), read_u32(data, 4));\n        break;\n    case VNC_MSG_CLIENT_POINTER_EVENT:\n        if (len == 1)\n            return 6;\n\n        pointer_event(vs, read_u8(data, 1), read_u16(data, 2), read_u16(data, 4));\n        break;\n    case VNC_MSG_CLIENT_CUT_TEXT:\n        if (len == 1) {\n            return 8;\n        }\n        if (len == 8) {\n            uint32_t dlen = read_u32(data, 4);\n            if (dlen > (1 << 20)) {\n                error_report(\"vnc: client_cut_text msg payload has %u bytes\"\n                             \" which exceeds our limit of 1MB.\", dlen);\n                vnc_client_error(vs);\n                break;\n            }\n            if (dlen > 0) {\n                return 8 + dlen;\n            }\n        }\n\n        client_cut_text(vs, read_u32(data, 4), data + 8);\n        break;\n    case VNC_MSG_CLIENT_QEMU:\n        if (len == 1)\n            return 2;\n\n        switch (read_u8(data, 1)) {\n        case VNC_MSG_CLIENT_QEMU_EXT_KEY_EVENT:\n            if (len == 2)\n                return 12;\n\n            ext_key_event(vs, read_u16(data, 2),\n                          read_u32(data, 4), read_u32(data, 8));\n            break;\n        case VNC_MSG_CLIENT_QEMU_AUDIO:\n            if (len == 2)\n                return 4;\n\n            switch (read_u16 (data, 2)) {\n            case VNC_MSG_CLIENT_QEMU_AUDIO_ENABLE:\n                audio_add(vs);\n                break;\n            case VNC_MSG_CLIENT_QEMU_AUDIO_DISABLE:\n                audio_del(vs);\n                break;\n            case VNC_MSG_CLIENT_QEMU_AUDIO_SET_FORMAT:\n                if (len == 4)\n                    return 10;\n                switch (read_u8(data, 4)) {\n                case 0: vs->as.fmt = AUD_FMT_U8; break;\n                case 1: vs->as.fmt = AUD_FMT_S8; break;\n                case 2: vs->as.fmt = AUD_FMT_U16; break;\n                case 3: vs->as.fmt = AUD_FMT_S16; break;\n                case 4: vs->as.fmt = AUD_FMT_U32; break;\n                case 5: vs->as.fmt = AUD_FMT_S32; break;\n                default:\n                    printf(\"Invalid audio format %d\\n\", read_u8(data, 4));\n                    vnc_client_error(vs);\n                    break;\n                }\n                vs->as.nchannels = read_u8(data, 5);\n                if (vs->as.nchannels != 1 && vs->as.nchannels != 2) {\n                    printf(\"Invalid audio channel coount %d\\n\",\n                           read_u8(data, 5));\n                    vnc_client_error(vs);\n                    break;\n                }\n                vs->as.freq = read_u32(data, 6);\n                break;\n            default:\n                printf (\"Invalid audio message %d\\n\", read_u8(data, 4));\n                vnc_client_error(vs);\n                break;\n            }\n            break;\n\n        default:\n            printf(\"Msg: %d\\n\", read_u16(data, 0));\n            vnc_client_error(vs);\n            break;\n        }\n        break;\n    default:\n        printf(\"Msg: %d\\n\", data[0]);\n        vnc_client_error(vs);\n        break;\n    }\n\n    vnc_read_when(vs, protocol_client_msg, 1);\n    return 0;\n}\n\nstatic int protocol_client_init(VncState *vs, uint8_t *data, size_t len)\n{\n    char buf[1024];\n    VncShareMode mode;\n    int size;\n\n    mode = data[0] ? VNC_SHARE_MODE_SHARED : VNC_SHARE_MODE_EXCLUSIVE;\n    switch (vs->vd->share_policy) {\n    case VNC_SHARE_POLICY_IGNORE:\n        /*\n         * Ignore the shared flag.  Nothing to do here.\n         *\n         * Doesn't conform to the rfb spec but is traditional qemu\n         * behavior, thus left here as option for compatibility\n         * reasons.\n         */\n        break;\n    case VNC_SHARE_POLICY_ALLOW_EXCLUSIVE:\n        /*\n         * Policy: Allow clients ask for exclusive access.\n         *\n         * Implementation: When a client asks for exclusive access,\n         * disconnect all others. Shared connects are allowed as long\n         * as no exclusive connection exists.\n         *\n         * This is how the rfb spec suggests to handle the shared flag.\n         */\n        if (mode == VNC_SHARE_MODE_EXCLUSIVE) {\n            VncState *client;\n            QTAILQ_FOREACH(client, &vs->vd->clients, next) {\n                if (vs == client) {\n                    continue;\n                }\n                if (client->share_mode != VNC_SHARE_MODE_EXCLUSIVE &&\n                    client->share_mode != VNC_SHARE_MODE_SHARED) {\n                    continue;\n                }\n                vnc_disconnect_start(client);\n            }\n        }\n        if (mode == VNC_SHARE_MODE_SHARED) {\n            if (vs->vd->num_exclusive > 0) {\n                vnc_disconnect_start(vs);\n                return 0;\n            }\n        }\n        break;\n    case VNC_SHARE_POLICY_FORCE_SHARED:\n        /*\n         * Policy: Shared connects only.\n         * Implementation: Disallow clients asking for exclusive access.\n         *\n         * Useful for shared desktop sessions where you don't want\n         * someone forgetting to say -shared when running the vnc\n         * client disconnect everybody else.\n         */\n        if (mode == VNC_SHARE_MODE_EXCLUSIVE) {\n            vnc_disconnect_start(vs);\n            return 0;\n        }\n        break;\n    }\n    vnc_set_share_mode(vs, mode);\n\n    vs->client_width = surface_width(vs->vd->ds);\n    vs->client_height = surface_height(vs->vd->ds);\n    vnc_write_u16(vs, vs->client_width);\n    vnc_write_u16(vs, vs->client_height);\n\n    pixel_format_message(vs);\n\n    if (qemu_name)\n        size = snprintf(buf, sizeof(buf), \"QEMU (%s)\", qemu_name);\n    else\n        size = snprintf(buf, sizeof(buf), \"QEMU\");\n\n    vnc_write_u32(vs, size);\n    vnc_write(vs, buf, size);\n    vnc_flush(vs);\n\n    vnc_client_cache_auth(vs);\n    vnc_qmp_event(vs, QAPI_EVENT_VNC_INITIALIZED);\n\n    vnc_read_when(vs, protocol_client_msg, 1);\n\n    return 0;\n}\n\nvoid start_client_init(VncState *vs)\n{\n    vnc_read_when(vs, protocol_client_init, 1);\n}\n\nstatic void make_challenge(VncState *vs)\n{\n    int i;\n\n    srand(time(NULL)+getpid()+getpid()*987654+rand());\n\n    for (i = 0 ; i < sizeof(vs->challenge) ; i++)\n        vs->challenge[i] = (int) (256.0*rand()/(RAND_MAX+1.0));\n}\n\nstatic int protocol_client_auth_vnc(VncState *vs, uint8_t *data, size_t len)\n{\n    unsigned char response[VNC_AUTH_CHALLENGE_SIZE];\n    int i, j, pwlen;\n    unsigned char key[8];\n    time_t now = time(NULL);\n\n    if (!vs->vd->password) {\n        VNC_DEBUG(\"No password configured on server\");\n        goto reject;\n    }\n    if (vs->vd->expires < now) {\n        VNC_DEBUG(\"Password is expired\");\n        goto reject;\n    }\n\n    memcpy(response, vs->challenge, VNC_AUTH_CHALLENGE_SIZE);\n\n    /* Calculate the expected challenge response */\n    pwlen = strlen(vs->vd->password);\n    for (i=0; i<sizeof(key); i++)\n        key[i] = i<pwlen ? vs->vd->password[i] : 0;\n    deskey(key, EN0);\n    for (j = 0; j < VNC_AUTH_CHALLENGE_SIZE; j += 8)\n        des(response+j, response+j);\n\n    /* Compare expected vs actual challenge response */\n    if (memcmp(response, data, VNC_AUTH_CHALLENGE_SIZE) != 0) {\n        VNC_DEBUG(\"Client challenge response did not match\\n\");\n        goto reject;\n    } else {\n        VNC_DEBUG(\"Accepting VNC challenge response\\n\");\n        vnc_write_u32(vs, 0); /* Accept auth */\n        vnc_flush(vs);\n\n        start_client_init(vs);\n    }\n    return 0;\n\nreject:\n    vnc_write_u32(vs, 1); /* Reject auth */\n    if (vs->minor >= 8) {\n        static const char err[] = \"Authentication failed\";\n        vnc_write_u32(vs, sizeof(err));\n        vnc_write(vs, err, sizeof(err));\n    }\n    vnc_flush(vs);\n    vnc_client_error(vs);\n    return 0;\n}\n\nvoid start_auth_vnc(VncState *vs)\n{\n    make_challenge(vs);\n    /* Send client a 'random' challenge */\n    vnc_write(vs, vs->challenge, sizeof(vs->challenge));\n    vnc_flush(vs);\n\n    vnc_read_when(vs, protocol_client_auth_vnc, sizeof(vs->challenge));\n}\n\n\nstatic int protocol_client_auth(VncState *vs, uint8_t *data, size_t len)\n{\n    /* We only advertise 1 auth scheme at a time, so client\n     * must pick the one we sent. Verify this */\n    if (data[0] != vs->auth) { /* Reject auth */\n       VNC_DEBUG(\"Reject auth %d because it didn't match advertized\\n\", (int)data[0]);\n       vnc_write_u32(vs, 1);\n       if (vs->minor >= 8) {\n           static const char err[] = \"Authentication failed\";\n           vnc_write_u32(vs, sizeof(err));\n           vnc_write(vs, err, sizeof(err));\n       }\n       vnc_client_error(vs);\n    } else { /* Accept requested auth */\n       VNC_DEBUG(\"Client requested auth %d\\n\", (int)data[0]);\n       switch (vs->auth) {\n       case VNC_AUTH_NONE:\n           VNC_DEBUG(\"Accept auth none\\n\");\n           if (vs->minor >= 8) {\n               vnc_write_u32(vs, 0); /* Accept auth completion */\n               vnc_flush(vs);\n           }\n           start_client_init(vs);\n           break;\n\n       case VNC_AUTH_VNC:\n           VNC_DEBUG(\"Start VNC auth\\n\");\n           start_auth_vnc(vs);\n           break;\n\n#ifdef CONFIG_VNC_TLS\n       case VNC_AUTH_VENCRYPT:\n           VNC_DEBUG(\"Accept VeNCrypt auth\\n\");\n           start_auth_vencrypt(vs);\n           break;\n#endif /* CONFIG_VNC_TLS */\n\n#ifdef CONFIG_VNC_SASL\n       case VNC_AUTH_SASL:\n           VNC_DEBUG(\"Accept SASL auth\\n\");\n           start_auth_sasl(vs);\n           break;\n#endif /* CONFIG_VNC_SASL */\n\n       default: /* Should not be possible, but just in case */\n           VNC_DEBUG(\"Reject auth %d server code bug\\n\", vs->auth);\n           vnc_write_u8(vs, 1);\n           if (vs->minor >= 8) {\n               static const char err[] = \"Authentication failed\";\n               vnc_write_u32(vs, sizeof(err));\n               vnc_write(vs, err, sizeof(err));\n           }\n           vnc_client_error(vs);\n       }\n    }\n    return 0;\n}\n\nstatic int protocol_version(VncState *vs, uint8_t *version, size_t len)\n{\n    char local[13];\n\n    memcpy(local, version, 12);\n    local[12] = 0;\n\n    if (sscanf(local, \"RFB %03d.%03d\\n\", &vs->major, &vs->minor) != 2) {\n        VNC_DEBUG(\"Malformed protocol version %s\\n\", local);\n        vnc_client_error(vs);\n        return 0;\n    }\n    VNC_DEBUG(\"Client request protocol version %d.%d\\n\", vs->major, vs->minor);\n    if (vs->major != 3 ||\n        (vs->minor != 3 &&\n         vs->minor != 4 &&\n         vs->minor != 5 &&\n         vs->minor != 7 &&\n         vs->minor != 8)) {\n        VNC_DEBUG(\"Unsupported client version\\n\");\n        vnc_write_u32(vs, VNC_AUTH_INVALID);\n        vnc_flush(vs);\n        vnc_client_error(vs);\n        return 0;\n    }\n    /* Some broken clients report v3.4 or v3.5, which spec requires to be treated\n     * as equivalent to v3.3 by servers\n     */\n    if (vs->minor == 4 || vs->minor == 5)\n        vs->minor = 3;\n\n    if (vs->minor == 3) {\n        if (vs->auth == VNC_AUTH_NONE) {\n            VNC_DEBUG(\"Tell client auth none\\n\");\n            vnc_write_u32(vs, vs->auth);\n            vnc_flush(vs);\n            start_client_init(vs);\n       } else if (vs->auth == VNC_AUTH_VNC) {\n            VNC_DEBUG(\"Tell client VNC auth\\n\");\n            vnc_write_u32(vs, vs->auth);\n            vnc_flush(vs);\n            start_auth_vnc(vs);\n       } else {\n            VNC_DEBUG(\"Unsupported auth %d for protocol 3.3\\n\", vs->auth);\n            vnc_write_u32(vs, VNC_AUTH_INVALID);\n            vnc_flush(vs);\n            vnc_client_error(vs);\n       }\n    } else {\n        VNC_DEBUG(\"Telling client we support auth %d\\n\", vs->auth);\n        vnc_write_u8(vs, 1); /* num auth */\n        vnc_write_u8(vs, vs->auth);\n        vnc_read_when(vs, protocol_client_auth, 1);\n        vnc_flush(vs);\n    }\n\n    return 0;\n}\n\nstatic VncRectStat *vnc_stat_rect(VncDisplay *vd, int x, int y)\n{\n    struct VncSurface *vs = &vd->guest;\n\n    return &vs->stats[y / VNC_STAT_RECT][x / VNC_STAT_RECT];\n}\n\nvoid vnc_sent_lossy_rect(VncState *vs, int x, int y, int w, int h)\n{\n    int i, j;\n\n    w = (x + w) / VNC_STAT_RECT;\n    h = (y + h) / VNC_STAT_RECT;\n    x /= VNC_STAT_RECT;\n    y /= VNC_STAT_RECT;\n\n    for (j = y; j <= h; j++) {\n        for (i = x; i <= w; i++) {\n            vs->lossy_rect[j][i] = 1;\n        }\n    }\n}\n\nstatic int vnc_refresh_lossy_rect(VncDisplay *vd, int x, int y)\n{\n    VncState *vs;\n    int sty = y / VNC_STAT_RECT;\n    int stx = x / VNC_STAT_RECT;\n    int has_dirty = 0;\n\n    y = y / VNC_STAT_RECT * VNC_STAT_RECT;\n    x = x / VNC_STAT_RECT * VNC_STAT_RECT;\n\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        int j;\n\n        /* kernel send buffers are full -> refresh later */\n        if (vs->output.offset) {\n            continue;\n        }\n\n        if (!vs->lossy_rect[sty][stx]) {\n            continue;\n        }\n\n        vs->lossy_rect[sty][stx] = 0;\n        for (j = 0; j < VNC_STAT_RECT; ++j) {\n            bitmap_set(vs->dirty[y + j],\n                       x / VNC_DIRTY_PIXELS_PER_BIT,\n                       VNC_STAT_RECT / VNC_DIRTY_PIXELS_PER_BIT);\n        }\n        has_dirty++;\n    }\n\n    return has_dirty;\n}\n\nstatic int vnc_update_stats(VncDisplay *vd,  struct timeval * tv)\n{\n    int width = pixman_image_get_width(vd->guest.fb);\n    int height = pixman_image_get_height(vd->guest.fb);\n    int x, y;\n    struct timeval res;\n    int has_dirty = 0;\n\n    for (y = 0; y < height; y += VNC_STAT_RECT) {\n        for (x = 0; x < width; x += VNC_STAT_RECT) {\n            VncRectStat *rect = vnc_stat_rect(vd, x, y);\n\n            rect->updated = false;\n        }\n    }\n\n    qemu_timersub(tv, &VNC_REFRESH_STATS, &res);\n\n    if (timercmp(&vd->guest.last_freq_check, &res, >)) {\n        return has_dirty;\n    }\n    vd->guest.last_freq_check = *tv;\n\n    for (y = 0; y < height; y += VNC_STAT_RECT) {\n        for (x = 0; x < width; x += VNC_STAT_RECT) {\n            VncRectStat *rect= vnc_stat_rect(vd, x, y);\n            int count = ARRAY_SIZE(rect->times);\n            struct timeval min, max;\n\n            if (!timerisset(&rect->times[count - 1])) {\n                continue ;\n            }\n\n            max = rect->times[(rect->idx + count - 1) % count];\n            qemu_timersub(tv, &max, &res);\n\n            if (timercmp(&res, &VNC_REFRESH_LOSSY, >)) {\n                rect->freq = 0;\n                has_dirty += vnc_refresh_lossy_rect(vd, x, y);\n                memset(rect->times, 0, sizeof (rect->times));\n                continue ;\n            }\n\n            min = rect->times[rect->idx];\n            max = rect->times[(rect->idx + count - 1) % count];\n            qemu_timersub(&max, &min, &res);\n\n            rect->freq = res.tv_sec + res.tv_usec / 1000000.;\n            rect->freq /= count;\n            rect->freq = 1. / rect->freq;\n        }\n    }\n    return has_dirty;\n}\n\ndouble vnc_update_freq(VncState *vs, int x, int y, int w, int h)\n{\n    int i, j;\n    double total = 0;\n    int num = 0;\n\n    x =  (x / VNC_STAT_RECT) * VNC_STAT_RECT;\n    y =  (y / VNC_STAT_RECT) * VNC_STAT_RECT;\n\n    for (j = y; j <= y + h; j += VNC_STAT_RECT) {\n        for (i = x; i <= x + w; i += VNC_STAT_RECT) {\n            total += vnc_stat_rect(vs->vd, i, j)->freq;\n            num++;\n        }\n    }\n\n    if (num) {\n        return total / num;\n    } else {\n        return 0;\n    }\n}\n\nstatic void vnc_rect_updated(VncDisplay *vd, int x, int y, struct timeval * tv)\n{\n    VncRectStat *rect;\n\n    rect = vnc_stat_rect(vd, x, y);\n    if (rect->updated) {\n        return ;\n    }\n    rect->times[rect->idx] = *tv;\n    rect->idx = (rect->idx + 1) % ARRAY_SIZE(rect->times);\n    rect->updated = true;\n}\n\nstatic int vnc_refresh_server_surface(VncDisplay *vd)\n{\n    int width = pixman_image_get_width(vd->guest.fb);\n    int height = pixman_image_get_height(vd->guest.fb);\n    int y;\n    uint8_t *guest_row0 = NULL, *server_row0;\n    int guest_stride = 0, server_stride;\n    int cmp_bytes;\n    VncState *vs;\n    int has_dirty = 0;\n    pixman_image_t *tmpbuf = NULL;\n\n    struct timeval tv = { 0, 0 };\n\n    if (!vd->non_adaptive) {\n        gettimeofday(&tv, NULL);\n        has_dirty = vnc_update_stats(vd, &tv);\n    }\n\n    /*\n     * Walk through the guest dirty map.\n     * Check and copy modified bits from guest to server surface.\n     * Update server dirty map.\n     */\n    cmp_bytes = VNC_DIRTY_PIXELS_PER_BIT * VNC_SERVER_FB_BYTES;\n    if (cmp_bytes > vnc_server_fb_stride(vd)) {\n        cmp_bytes = vnc_server_fb_stride(vd);\n    }\n    if (vd->guest.format != VNC_SERVER_FB_FORMAT) {\n        int width = pixman_image_get_width(vd->server);\n        tmpbuf = qemu_pixman_linebuf_create(VNC_SERVER_FB_FORMAT, width);\n    } else {\n        guest_row0 = (uint8_t *)pixman_image_get_data(vd->guest.fb);\n        guest_stride = pixman_image_get_stride(vd->guest.fb);\n    }\n    server_row0 = (uint8_t *)pixman_image_get_data(vd->server);\n    server_stride = pixman_image_get_stride(vd->server);\n\n    y = 0;\n    for (;;) {\n        int x;\n        uint8_t *guest_ptr, *server_ptr;\n        unsigned long offset = find_next_bit((unsigned long *) &vd->guest.dirty,\n                                             height * VNC_DIRTY_BPL(&vd->guest),\n                                             y * VNC_DIRTY_BPL(&vd->guest));\n        if (offset == height * VNC_DIRTY_BPL(&vd->guest)) {\n            /* no more dirty bits */\n            break;\n        }\n        y = offset / VNC_DIRTY_BPL(&vd->guest);\n        x = offset % VNC_DIRTY_BPL(&vd->guest);\n\n        server_ptr = server_row0 + y * server_stride + x * cmp_bytes;\n\n        if (vd->guest.format != VNC_SERVER_FB_FORMAT) {\n            qemu_pixman_linebuf_fill(tmpbuf, vd->guest.fb, width, 0, y);\n            guest_ptr = (uint8_t *)pixman_image_get_data(tmpbuf);\n        } else {\n            guest_ptr = guest_row0 + y * guest_stride;\n        }\n        guest_ptr += x * cmp_bytes;\n\n        for (; x < DIV_ROUND_UP(width, VNC_DIRTY_PIXELS_PER_BIT);\n             x++, guest_ptr += cmp_bytes, server_ptr += cmp_bytes) {\n            if (!test_and_clear_bit(x, vd->guest.dirty[y])) {\n                continue;\n            }\n            if (memcmp(server_ptr, guest_ptr, cmp_bytes) == 0) {\n                continue;\n            }\n            memcpy(server_ptr, guest_ptr, cmp_bytes);\n            if (!vd->non_adaptive) {\n                vnc_rect_updated(vd, x * VNC_DIRTY_PIXELS_PER_BIT,\n                                 y, &tv);\n            }\n            QTAILQ_FOREACH(vs, &vd->clients, next) {\n                set_bit(x, vs->dirty[y]);\n            }\n            has_dirty++;\n        }\n\n        y++;\n    }\n    qemu_pixman_image_unref(tmpbuf);\n    return has_dirty;\n}\n\nstatic void vnc_refresh(DisplayChangeListener *dcl)\n{\n    VncDisplay *vd = container_of(dcl, VncDisplay, dcl);\n    VncState *vs, *vn;\n    int has_dirty, rects = 0;\n\n    graphic_hw_update(NULL);\n\n    if (vnc_trylock_display(vd)) {\n        update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);\n        return;\n    }\n\n    has_dirty = vnc_refresh_server_surface(vd);\n    vnc_unlock_display(vd);\n\n    QTAILQ_FOREACH_SAFE(vs, &vd->clients, next, vn) {\n        rects += vnc_update_client(vs, has_dirty, false);\n        /* vs might be free()ed here */\n    }\n\n    if (QTAILQ_EMPTY(&vd->clients)) {\n        update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_MAX);\n        return;\n    }\n\n    if (has_dirty && rects) {\n        vd->dcl.update_interval /= 2;\n        if (vd->dcl.update_interval < VNC_REFRESH_INTERVAL_BASE) {\n            vd->dcl.update_interval = VNC_REFRESH_INTERVAL_BASE;\n        }\n    } else {\n        vd->dcl.update_interval += VNC_REFRESH_INTERVAL_INC;\n        if (vd->dcl.update_interval > VNC_REFRESH_INTERVAL_MAX) {\n            vd->dcl.update_interval = VNC_REFRESH_INTERVAL_MAX;\n        }\n    }\n}\n\nstatic void vnc_connect(VncDisplay *vd, int csock,\n                        bool skipauth, bool websocket)\n{\n    VncState *vs = g_malloc0(sizeof(VncState));\n    int i;\n\n    vs->csock = csock;\n\n    if (skipauth) {\n\tvs->auth = VNC_AUTH_NONE;\n#ifdef CONFIG_VNC_TLS\n\tvs->subauth = VNC_AUTH_INVALID;\n#endif\n    } else {\n\tvs->auth = vd->auth;\n#ifdef CONFIG_VNC_TLS\n\tvs->subauth = vd->subauth;\n#endif\n    }\n\n    vs->lossy_rect = g_malloc0(VNC_STAT_ROWS * sizeof (*vs->lossy_rect));\n    for (i = 0; i < VNC_STAT_ROWS; ++i) {\n        vs->lossy_rect[i] = g_malloc0(VNC_STAT_COLS * sizeof (uint8_t));\n    }\n\n    VNC_DEBUG(\"New client on socket %d\\n\", csock);\n    update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);\n    qemu_set_nonblock(vs->csock);\n#ifdef CONFIG_VNC_WS\n    if (websocket) {\n        vs->websocket = 1;\n#ifdef CONFIG_VNC_TLS\n        if (vd->tls.x509cert) {\n            qemu_set_fd_handler2(vs->csock, NULL, vncws_tls_handshake_peek,\n                                 NULL, vs);\n        } else\n#endif /* CONFIG_VNC_TLS */\n        {\n            qemu_set_fd_handler2(vs->csock, NULL, vncws_handshake_read,\n                                 NULL, vs);\n        }\n    } else\n#endif /* CONFIG_VNC_WS */\n    {\n        qemu_set_fd_handler2(vs->csock, NULL, vnc_client_read, NULL, vs);\n    }\n\n    vnc_client_cache_addr(vs);\n    vnc_qmp_event(vs, QAPI_EVENT_VNC_CONNECTED);\n    vnc_set_share_mode(vs, VNC_SHARE_MODE_CONNECTING);\n\n    vs->vd = vd;\n\n#ifdef CONFIG_VNC_WS\n    if (!vs->websocket)\n#endif\n    {\n        vnc_init_state(vs);\n    }\n}\n\nvoid vnc_init_state(VncState *vs)\n{\n    vs->initialized = true;\n    VncDisplay *vd = vs->vd;\n\n    vs->last_x = -1;\n    vs->last_y = -1;\n\n    vs->as.freq = 44100;\n    vs->as.nchannels = 2;\n    vs->as.fmt = AUD_FMT_S16;\n    vs->as.endianness = 0;\n\n    qemu_mutex_init(&vs->output_mutex);\n    vs->bh = qemu_bh_new(vnc_jobs_bh, vs);\n\n    QTAILQ_INSERT_HEAD(&vd->clients, vs, next);\n\n    graphic_hw_update(NULL);\n\n    vnc_write(vs, \"RFB 003.008\\n\", 12);\n    vnc_flush(vs);\n    vnc_read_when(vs, protocol_version, 12);\n    reset_keys(vs);\n    if (vs->vd->lock_key_sync)\n        vs->led = qemu_add_led_event_handler(kbd_leds, vs);\n\n    vs->mouse_mode_notifier.notify = check_pointer_type_change;\n    qemu_add_mouse_mode_change_notifier(&vs->mouse_mode_notifier);\n\n    /* vs might be free()ed here */\n}\n\nstatic void vnc_listen_read(void *opaque, bool websocket)\n{\n    VncDisplay *vs = opaque;\n    struct sockaddr_in addr;\n    socklen_t addrlen = sizeof(addr);\n    int csock;\n\n    /* Catch-up */\n    graphic_hw_update(NULL);\n#ifdef CONFIG_VNC_WS\n    if (websocket) {\n        csock = qemu_accept(vs->lwebsock, (struct sockaddr *)&addr, &addrlen);\n    } else\n#endif /* CONFIG_VNC_WS */\n    {\n        csock = qemu_accept(vs->lsock, (struct sockaddr *)&addr, &addrlen);\n    }\n\n    if (csock != -1) {\n        vnc_connect(vs, csock, false, websocket);\n    }\n}\n\nstatic void vnc_listen_regular_read(void *opaque)\n{\n    vnc_listen_read(opaque, false);\n}\n\n#ifdef CONFIG_VNC_WS\nstatic void vnc_listen_websocket_read(void *opaque)\n{\n    vnc_listen_read(opaque, true);\n}\n#endif /* CONFIG_VNC_WS */\n\nstatic const DisplayChangeListenerOps dcl_ops = {\n    .dpy_name          = \"vnc\",\n    .dpy_refresh       = vnc_refresh,\n    .dpy_gfx_copy      = vnc_dpy_copy,\n    .dpy_gfx_update    = vnc_dpy_update,\n    .dpy_gfx_switch    = vnc_dpy_switch,\n    .dpy_mouse_set     = vnc_mouse_set,\n    .dpy_cursor_define = vnc_dpy_cursor_define,\n};\n\nvoid vnc_display_init(DisplayState *ds)\n{\n    VncDisplay *vs = g_malloc0(sizeof(*vs));\n\n    vnc_display = vs;\n\n    vs->lsock = -1;\n#ifdef CONFIG_VNC_WS\n    vs->lwebsock = -1;\n#endif\n\n    QTAILQ_INIT(&vs->clients);\n    vs->expires = TIME_MAX;\n\n    if (keyboard_layout) {\n        trace_vnc_key_map_init(keyboard_layout);\n        vs->kbd_layout = init_keyboard_layout(name2keysym, keyboard_layout);\n    } else {\n        vs->kbd_layout = init_keyboard_layout(name2keysym, \"en-us\");\n    }\n\n    if (!vs->kbd_layout)\n        exit(1);\n\n    qemu_mutex_init(&vs->mutex);\n    vnc_start_worker_thread();\n\n    vs->dcl.ops = &dcl_ops;\n    register_displaychangelistener(&vs->dcl);\n}\n\n\nstatic void vnc_display_close(DisplayState *ds)\n{\n    VncDisplay *vs = vnc_display;\n\n    if (!vs)\n        return;\n    g_free(vs->display);\n    vs->display = NULL;\n    if (vs->lsock != -1) {\n        qemu_set_fd_handler2(vs->lsock, NULL, NULL, NULL, NULL);\n        close(vs->lsock);\n        vs->lsock = -1;\n    }\n#ifdef CONFIG_VNC_WS\n    g_free(vs->ws_display);\n    vs->ws_display = NULL;\n    if (vs->lwebsock != -1) {\n        qemu_set_fd_handler2(vs->lwebsock, NULL, NULL, NULL, NULL);\n        close(vs->lwebsock);\n        vs->lwebsock = -1;\n    }\n#endif /* CONFIG_VNC_WS */\n    vs->auth = VNC_AUTH_INVALID;\n#ifdef CONFIG_VNC_TLS\n    vs->subauth = VNC_AUTH_INVALID;\n    vs->tls.x509verify = 0;\n#endif\n}\n\nint vnc_display_password(DisplayState *ds, const char *password)\n{\n    VncDisplay *vs = vnc_display;\n\n    if (!vs) {\n        return -EINVAL;\n    }\n    if (vs->auth == VNC_AUTH_NONE) {\n        error_printf_unless_qmp(\"If you want use passwords please enable \"\n                                \"password auth using '-vnc ${dpy},password'.\");\n        return -EINVAL;\n    }\n\n    g_free(vs->password);\n    vs->password = g_strdup(password);\n\n    return 0;\n}\n\nint vnc_display_pw_expire(DisplayState *ds, time_t expires)\n{\n    VncDisplay *vs = vnc_display;\n\n    if (!vs) {\n        return -EINVAL;\n    }\n\n    vs->expires = expires;\n    return 0;\n}\n\nchar *vnc_display_local_addr(DisplayState *ds)\n{\n    VncDisplay *vs = vnc_display;\n    \n    return vnc_socket_local_addr(\"%s:%s\", vs->lsock);\n}\n\nvoid vnc_display_open(DisplayState *ds, const char *display, Error **errp)\n{\n    VncDisplay *vs = vnc_display;\n    const char *options;\n    int password = 0;\n    int reverse = 0;\n#ifdef CONFIG_VNC_TLS\n    int tls = 0, x509 = 0;\n#endif\n#ifdef CONFIG_VNC_SASL\n    int sasl = 0;\n    int saslErr;\n#endif\n#if defined(CONFIG_VNC_TLS) || defined(CONFIG_VNC_SASL)\n    int acl = 0;\n#endif\n    int lock_key_sync = 1;\n\n    if (!vnc_display) {\n        error_setg(errp, \"VNC display not active\");\n        return;\n    }\n    vnc_display_close(ds);\n    if (strcmp(display, \"none\") == 0)\n        return;\n\n    vs->display = g_strdup(display);\n    vs->share_policy = VNC_SHARE_POLICY_ALLOW_EXCLUSIVE;\n\n    options = display;\n    while ((options = strchr(options, ','))) {\n        options++;\n        if (strncmp(options, \"password\", 8) == 0) {\n            if (fips_get_state()) {\n                error_setg(errp,\n                           \"VNC password auth disabled due to FIPS mode, \"\n                           \"consider using the VeNCrypt or SASL authentication \"\n                           \"methods as an alternative\");\n                goto fail;\n            }\n            password = 1; /* Require password auth */\n        } else if (strncmp(options, \"reverse\", 7) == 0) {\n            reverse = 1;\n        } else if (strncmp(options, \"no-lock-key-sync\", 16) == 0) {\n            lock_key_sync = 0;\n#ifdef CONFIG_VNC_SASL\n        } else if (strncmp(options, \"sasl\", 4) == 0) {\n            sasl = 1; /* Require SASL auth */\n#endif\n#ifdef CONFIG_VNC_WS\n        } else if (strncmp(options, \"websocket\", 9) == 0) {\n            char *start, *end;\n            vs->websocket = 1;\n\n            /* Check for 'websocket=<port>' */\n            start = strchr(options, '=');\n            end = strchr(options, ',');\n            if (start && (!end || (start < end))) {\n                int len = end ? end-(start+1) : strlen(start+1);\n                if (len < 6) {\n                    /* extract the host specification from display */\n                    char  *host = NULL, *port = NULL, *host_end = NULL;\n                    port = g_strndup(start + 1, len);\n\n                    /* ipv6 hosts have colons */\n                    end = strchr(display, ',');\n                    host_end = g_strrstr_len(display, end - display, \":\");\n\n                    if (host_end) {\n                        host = g_strndup(display, host_end - display + 1);\n                    } else {\n                        host = g_strndup(\":\", 1);\n                    }\n                    vs->ws_display = g_strconcat(host, port, NULL);\n                    g_free(host);\n                    g_free(port);\n                }\n            }\n#endif /* CONFIG_VNC_WS */\n#ifdef CONFIG_VNC_TLS\n        } else if (strncmp(options, \"tls\", 3) == 0) {\n            tls = 1; /* Require TLS */\n        } else if (strncmp(options, \"x509\", 4) == 0) {\n            char *start, *end;\n            x509 = 1; /* Require x509 certificates */\n            if (strncmp(options, \"x509verify\", 10) == 0)\n                vs->tls.x509verify = 1; /* ...and verify client certs */\n\n            /* Now check for 'x509=/some/path' postfix\n             * and use that to setup x509 certificate/key paths */\n            start = strchr(options, '=');\n            end = strchr(options, ',');\n            if (start && (!end || (start < end))) {\n                int len = end ? end-(start+1) : strlen(start+1);\n                char *path = g_strndup(start + 1, len);\n\n                VNC_DEBUG(\"Trying certificate path '%s'\\n\", path);\n                if (vnc_tls_set_x509_creds_dir(vs, path) < 0) {\n                    error_setg(errp, \"Failed to find x509 certificates/keys in %s\", path);\n                    g_free(path);\n                    goto fail;\n                }\n                g_free(path);\n            } else {\n                error_setg(errp, \"No certificate path provided\");\n                goto fail;\n            }\n#endif\n#if defined(CONFIG_VNC_TLS) || defined(CONFIG_VNC_SASL)\n        } else if (strncmp(options, \"acl\", 3) == 0) {\n            acl = 1;\n#endif\n        } else if (strncmp(options, \"lossy\", 5) == 0) {\n#ifdef CONFIG_VNC_JPEG\n            vs->lossy = true;\n#endif\n        } else if (strncmp(options, \"non-adaptive\", 12) == 0) {\n            vs->non_adaptive = true;\n        } else if (strncmp(options, \"share=\", 6) == 0) {\n            if (strncmp(options+6, \"ignore\", 6) == 0) {\n                vs->share_policy = VNC_SHARE_POLICY_IGNORE;\n            } else if (strncmp(options+6, \"allow-exclusive\", 15) == 0) {\n                vs->share_policy = VNC_SHARE_POLICY_ALLOW_EXCLUSIVE;\n            } else if (strncmp(options+6, \"force-shared\", 12) == 0) {\n                vs->share_policy = VNC_SHARE_POLICY_FORCE_SHARED;\n            } else {\n                error_setg(errp, \"unknown vnc share= option\");\n                goto fail;\n            }\n        }\n    }\n\n    /* adaptive updates are only used with tight encoding and\n     * if lossy updates are enabled so we can disable all the\n     * calculations otherwise */\n    if (!vs->lossy) {\n        vs->non_adaptive = true;\n    }\n\n#ifdef CONFIG_VNC_TLS\n    if (acl && x509 && vs->tls.x509verify) {\n        if (!(vs->tls.acl = qemu_acl_init(\"vnc.x509dname\"))) {\n            fprintf(stderr, \"Failed to create x509 dname ACL\\n\");\n            exit(1);\n        }\n    }\n#endif\n#ifdef CONFIG_VNC_SASL\n    if (acl && sasl) {\n        if (!(vs->sasl.acl = qemu_acl_init(\"vnc.username\"))) {\n            fprintf(stderr, \"Failed to create username ACL\\n\");\n            exit(1);\n        }\n    }\n#endif\n\n    /*\n     * Combinations we support here:\n     *\n     *  - no-auth                (clear text, no auth)\n     *  - password               (clear text, weak auth)\n     *  - sasl                   (encrypt, good auth *IF* using Kerberos via GSSAPI)\n     *  - tls                    (encrypt, weak anonymous creds, no auth)\n     *  - tls + password         (encrypt, weak anonymous creds, weak auth)\n     *  - tls + sasl             (encrypt, weak anonymous creds, good auth)\n     *  - tls + x509             (encrypt, good x509 creds, no auth)\n     *  - tls + x509 + password  (encrypt, good x509 creds, weak auth)\n     *  - tls + x509 + sasl      (encrypt, good x509 creds, good auth)\n     *\n     * NB1. TLS is a stackable auth scheme.\n     * NB2. the x509 schemes have option to validate a client cert dname\n     */\n    if (password) {\n#ifdef CONFIG_VNC_TLS\n        if (tls) {\n            vs->auth = VNC_AUTH_VENCRYPT;\n            if (x509) {\n                VNC_DEBUG(\"Initializing VNC server with x509 password auth\\n\");\n                vs->subauth = VNC_AUTH_VENCRYPT_X509VNC;\n            } else {\n                VNC_DEBUG(\"Initializing VNC server with TLS password auth\\n\");\n                vs->subauth = VNC_AUTH_VENCRYPT_TLSVNC;\n            }\n        } else {\n#endif /* CONFIG_VNC_TLS */\n            VNC_DEBUG(\"Initializing VNC server with password auth\\n\");\n            vs->auth = VNC_AUTH_VNC;\n#ifdef CONFIG_VNC_TLS\n            vs->subauth = VNC_AUTH_INVALID;\n        }\n#endif /* CONFIG_VNC_TLS */\n#ifdef CONFIG_VNC_SASL\n    } else if (sasl) {\n#ifdef CONFIG_VNC_TLS\n        if (tls) {\n            vs->auth = VNC_AUTH_VENCRYPT;\n            if (x509) {\n                VNC_DEBUG(\"Initializing VNC server with x509 SASL auth\\n\");\n                vs->subauth = VNC_AUTH_VENCRYPT_X509SASL;\n            } else {\n                VNC_DEBUG(\"Initializing VNC server with TLS SASL auth\\n\");\n                vs->subauth = VNC_AUTH_VENCRYPT_TLSSASL;\n            }\n        } else {\n#endif /* CONFIG_VNC_TLS */\n            VNC_DEBUG(\"Initializing VNC server with SASL auth\\n\");\n            vs->auth = VNC_AUTH_SASL;\n#ifdef CONFIG_VNC_TLS\n            vs->subauth = VNC_AUTH_INVALID;\n        }\n#endif /* CONFIG_VNC_TLS */\n#endif /* CONFIG_VNC_SASL */\n    } else {\n#ifdef CONFIG_VNC_TLS\n        if (tls) {\n            vs->auth = VNC_AUTH_VENCRYPT;\n            if (x509) {\n                VNC_DEBUG(\"Initializing VNC server with x509 no auth\\n\");\n                vs->subauth = VNC_AUTH_VENCRYPT_X509NONE;\n            } else {\n                VNC_DEBUG(\"Initializing VNC server with TLS no auth\\n\");\n                vs->subauth = VNC_AUTH_VENCRYPT_TLSNONE;\n            }\n        } else {\n#endif\n            VNC_DEBUG(\"Initializing VNC server with no auth\\n\");\n            vs->auth = VNC_AUTH_NONE;\n#ifdef CONFIG_VNC_TLS\n            vs->subauth = VNC_AUTH_INVALID;\n        }\n#endif\n    }\n\n#ifdef CONFIG_VNC_SASL\n    if ((saslErr = sasl_server_init(NULL, \"qemu\")) != SASL_OK) {\n        error_setg(errp, \"Failed to initialize SASL auth: %s\",\n                   sasl_errstring(saslErr, NULL, NULL));\n        goto fail;\n    }\n#endif\n    vs->lock_key_sync = lock_key_sync;\n\n    if (reverse) {\n        /* connect to viewer */\n        int csock;\n        vs->lsock = -1;\n#ifdef CONFIG_VNC_WS\n        vs->lwebsock = -1;\n#endif\n        if (strncmp(display, \"unix:\", 5) == 0) {\n            csock = unix_connect(display+5, errp);\n        } else {\n            csock = inet_connect(display, errp);\n        }\n        if (csock < 0) {\n            goto fail;\n        }\n        vnc_connect(vs, csock, false, false);\n    } else {\n        /* listen for connects */\n        char *dpy;\n        dpy = g_malloc(256);\n        if (strncmp(display, \"unix:\", 5) == 0) {\n            pstrcpy(dpy, 256, \"unix:\");\n            vs->lsock = unix_listen(display+5, dpy+5, 256-5, errp);\n        } else {\n            vs->lsock = inet_listen(display, dpy, 256,\n                                    SOCK_STREAM, 5900, errp);\n            if (vs->lsock < 0) {\n                g_free(dpy);\n                goto fail;\n            }\n#ifdef CONFIG_VNC_WS\n            if (vs->websocket) {\n                if (vs->ws_display) {\n                    vs->lwebsock = inet_listen(vs->ws_display, NULL, 256,\n                        SOCK_STREAM, 0, errp);\n                } else {\n                    vs->lwebsock = inet_listen(vs->display, NULL, 256,\n                        SOCK_STREAM, 5700, errp);\n                }\n\n                if (vs->lwebsock < 0) {\n                    if (vs->lsock) {\n                        close(vs->lsock);\n                        vs->lsock = -1;\n                    }\n                    g_free(dpy);\n                    goto fail;\n                }\n            }\n#endif /* CONFIG_VNC_WS */\n        }\n        g_free(vs->display);\n        vs->display = dpy;\n        qemu_set_fd_handler2(vs->lsock, NULL,\n                vnc_listen_regular_read, NULL, vs);\n#ifdef CONFIG_VNC_WS\n        if (vs->websocket) {\n            qemu_set_fd_handler2(vs->lwebsock, NULL,\n                    vnc_listen_websocket_read, NULL, vs);\n        }\n#endif /* CONFIG_VNC_WS */\n    }\n    return;\n\nfail:\n    g_free(vs->display);\n    vs->display = NULL;\n#ifdef CONFIG_VNC_WS\n    g_free(vs->ws_display);\n    vs->ws_display = NULL;\n#endif /* CONFIG_VNC_WS */\n}\n\nvoid vnc_display_add_client(DisplayState *ds, int csock, bool skipauth)\n{\n    VncDisplay *vs = vnc_display;\n\n    vnc_connect(vs, csock, skipauth, false);\n}\n"], "filenames": ["ui/vnc.c"], "buggy_code_start_loc": [2168], "buggy_code_end_loc": [2174], "fixing_code_start_loc": [2168], "fixing_code_end_loc": [2182], "type": "CWE-835", "message": "Integer overflow in the VNC display driver in QEMU before 2.1.0 allows attachers to cause a denial of service (process crash) via a CLIENT_CUT_TEXT message, which triggers an infinite loop.", "other": {"cve": {"id": "CVE-2015-5239", "sourceIdentifier": "secalert@redhat.com", "published": "2020-01-23T20:15:11.887", "lastModified": "2022-06-05T02:32:52.737", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Integer overflow in the VNC display driver in QEMU before 2.1.0 allows attachers to cause a denial of service (process crash) via a CLIENT_CUT_TEXT message, which triggers an infinite loop."}, {"lang": "es", "value": "Un desbordamiento de enteros en el controlador de pantalla VNC en QEMU versiones anteriores a 2.1.0, permite a atacantes causar una denegaci\u00f3n de servicio (bloqueo del proceso) mediante un mensaje CLIENT_CUT_TEXT, que desencadena un bucle infinito."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:qemu:qemu:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.0", "matchCriteriaId": "0641572C-797F-49A4-9B2C-B83E48EB905A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:21:*:*:*:*:*:*:*", "matchCriteriaId": "56BDB5A0-0839-4A20-A003-B8CD56F48171"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:22:*:*:*:*:*:*:*", "matchCriteriaId": "253C303A-E577-4488-93E6-68A8DD942C38"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:23:*:*:*:*:*:*:*", "matchCriteriaId": "E79AB8DD-C907-4038-A931-1A5A4CFB6A5B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B6B7CAD7-9D4E-4FDB-88E3-1E583210A01F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:15.04:*:*:*:*:*:*:*", "matchCriteriaId": "F38D3B7E-8429-473F-BB31-FC3583EE5A5B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:suse:linux_enterprise_debuginfo:11:sp3:*:*:*:*:*:*", "matchCriteriaId": "58D3B6FD-B474-4B09-B644-A8634A629280"}, {"vulnerable": true, "criteria": "cpe:2.3:a:suse:linux_enterprise_debuginfo:11:sp4:*:*:*:*:*:*", "matchCriteriaId": "F892F1B0-514C-42F7-90AE-12ACDFDC1033"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_desktop:11:sp3:*:*:*:*:*:*", "matchCriteriaId": "3ED68ADD-BBDA-4485-BC76-58F011D72311"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_desktop:11:sp4:*:*:*:*:*:*", "matchCriteriaId": "17D4B6F2-514D-4BC2-B2C5-4E2FCCAC594C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_desktop:12:*:*:*:*:*:*:*", "matchCriteriaId": "F1EB0F28-F23A-4969-8A3E-66DA2EFA40C3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:11:sp3:*:*:*:*:*:*", "matchCriteriaId": "8B072472-B463-4647-885D-E40B0115C810"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:11:sp4:*:*:*:*:*:*", "matchCriteriaId": "55C5561F-BE86-4EEA-99D4-8697F8BD9DFE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:12:*:*:*:*:*:*:*", "matchCriteriaId": "F922115C-1907-4F65-9F23-3E63A8BCD4A7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_software_development_kit:11:sp3:*:*:*:*:*:*", "matchCriteriaId": "2F7F8866-DEAD-44D1-AB10-21EE611AA026"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_software_development_kit:11:sp4:*:*:*:*:*:*", "matchCriteriaId": "D41A798E-0D69-43C7-9A63-1E5921138EAC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_software_development_kit:12:*:*:*:*:*:*:*", "matchCriteriaId": "DB2A1559-651C-46B0-B436-8E03DC8A60D2"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:arista:eos:4.12:*:*:*:*:*:*:*", "matchCriteriaId": "FDDF9823-D999-41A4-BB7B-A63C00ACE11B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:arista:eos:4.13:*:*:*:*:*:*:*", "matchCriteriaId": "51F7426A-46F7-4BE0-806F-F4598C8B0426"}, {"vulnerable": true, "criteria": "cpe:2.3:o:arista:eos:4.14:*:*:*:*:*:*:*", "matchCriteriaId": "E7F71EBA-27AC-464B-8708-4E8971BC75A7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:arista:eos:4.15:*:*:*:*:*:*:*", "matchCriteriaId": "8705CF80-DEFC-4425-8E23-D98FFD678157"}]}]}], "references": [{"url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-October/168077.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-October/168646.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-October/168671.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-10/msg00026.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-11/msg00005.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-11/msg00011.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2015/09/02/7", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2745-1", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/qemu/qemu/commit/f9a70e79391f6d7c2a912d785239ee8effc1922d", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.arista.com/en/support/advisories-notices/security-advisories/1188-security-advisory-14", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/qemu/qemu/commit/f9a70e79391f6d7c2a912d785239ee8effc1922d"}}