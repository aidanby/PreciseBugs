{"buggy_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.rendering.internal.macro.context;\n\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Singleton;\n\nimport org.xwiki.bridge.DocumentModelBridge;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.rendering.async.internal.AbstractExecutedContentMacro;\nimport org.xwiki.rendering.async.internal.block.BlockAsyncRendererConfiguration;\nimport org.xwiki.rendering.block.Block;\nimport org.xwiki.rendering.block.MetaDataBlock;\nimport org.xwiki.rendering.block.XDOM;\nimport org.xwiki.rendering.listener.MetaData;\nimport org.xwiki.rendering.macro.MacroExecutionException;\nimport org.xwiki.rendering.macro.context.ContextMacroParameters;\nimport org.xwiki.rendering.macro.context.TransformationContextMode;\nimport org.xwiki.rendering.macro.descriptor.DefaultContentDescriptor;\nimport org.xwiki.rendering.transformation.MacroTransformationContext;\nimport org.xwiki.rendering.transformation.TransformationContext;\nimport org.xwiki.rendering.transformation.TransformationManager;\nimport org.xwiki.security.authorization.AccessDeniedException;\nimport org.xwiki.security.authorization.AuthorizationManager;\nimport org.xwiki.security.authorization.Right;\n\n/**\n * Execute the macro's content in the context of another document's reference.\n * \n * @version $Id$\n * @since 3.0M1\n */\n@Component\n@Named(\"context\")\n@Singleton\npublic class ContextMacro extends AbstractExecutedContentMacro<ContextMacroParameters>\n{\n    /**\n     * The description of the macro.\n     */\n    private static final String DESCRIPTION = \"Executes content in the context of the passed document\";\n\n    /**\n     * The description of the macro content.\n     */\n    private static final String CONTENT_DESCRIPTION = \"The content to execute\";\n\n    @Inject\n    private AuthorizationManager authorizationManager;\n\n    @Inject\n    private TransformationManager transformationManager;\n\n    @Inject\n    @Named(\"macro\")\n    private DocumentReferenceResolver<String> macroReferenceResolver;\n\n    /**\n     * Create and initialize the descriptor of the macro.\n     */\n    public ContextMacro()\n    {\n        super(\"Context\", DESCRIPTION, new DefaultContentDescriptor(CONTENT_DESCRIPTION, true, Block.LIST_BLOCK_TYPE),\n            ContextMacroParameters.class);\n\n        // The Context macro must execute early since it can contain include macros which can bring stuff like headings\n        // for other macros (TOC macro, etc). Make it the same priority as the Include macro.\n        setPriority(10);\n        setDefaultCategories(Set.of(DEFAULT_CATEGORY_DEVELOPMENT));\n    }\n\n    private void checkAccess(DocumentReference currentAuthor, DocumentReference referencedDocReference)\n        throws MacroExecutionException\n    {\n        // Current author must have view right on the target document to use it as context document\n        try {\n            this.authorizationManager.checkAccess(Right.VIEW, currentAuthor, referencedDocReference);\n        } catch (AccessDeniedException e) {\n            throw new MacroExecutionException(\"Author [\" + currentAuthor\n                + \"] is not allowed to access target document [\" + referencedDocReference + \"]\", e);\n        }\n    }\n\n    private XDOM getXDOM(DocumentReference referencedDocReference, ContextMacroParameters parameters)\n        throws MacroExecutionException\n    {\n        try {\n            if (parameters.getTransformationContext() == TransformationContextMode.DOCUMENT\n                || parameters.getTransformationContext() == TransformationContextMode.TRANSFORMATIONS) {\n                // Apply the transformations but with a Transformation Context having the XDOM of the passed\n                // document so that macros execute on the passed document's XDOM (e.g. the TOC macro will generate\n                // the toc for the passed document instead of the current document).\n                DocumentModelBridge referencedDoc =\n                    this.documentAccessBridge.getTranslatedDocumentInstance(referencedDocReference);\n                XDOM referencedXDOM = referencedDoc.getXDOM();\n\n                if (parameters.getTransformationContext() == TransformationContextMode.TRANSFORMATIONS) {\n                    // Get the XDOM from the referenced doc but with Transformations applied so that all macro are\n                    // executed and contribute XDOM elements.\n                    // IMPORTANT: This can be dangerous since it means executing macros, and thus also script macros\n                    // defined in the referenced document. To be used with caution.\n                    TransformationContext referencedTxContext =\n                        new TransformationContext(referencedXDOM, referencedDoc.getSyntax());\n                    this.transformationManager.performTransformations(referencedXDOM, referencedTxContext);\n                }\n\n                return referencedXDOM;\n            }\n        } catch (Exception e) {\n            throw new MacroExecutionException(\"Failed to resolve the XDOM to use in the transformation\", e);\n        }\n\n        return null;\n    }\n\n    @Override\n    public List<Block> execute(ContextMacroParameters parameters, String content, MacroTransformationContext context)\n        throws MacroExecutionException\n    {\n        if (parameters.getDocument() == null) {\n            throw new MacroExecutionException(\"You must specify a 'document' parameter pointing to the document to \"\n                + \"set in the context as the current document.\");\n        }\n\n        DocumentReference currentAuthor = this.documentAccessBridge.getCurrentAuthorReference();\n        DocumentReference referencedDocReference =\n            this.macroReferenceResolver.resolve(parameters.getDocument(), context.getCurrentMacroBlock());\n\n        // Make sure the author is allowed to use the target document\n        checkAccess(currentAuthor, referencedDocReference);\n\n        MetaData metadata = new MetaData();\n        metadata.addMetaData(MetaData.SOURCE, parameters.getDocument());\n        metadata.addMetaData(MetaData.BASE, parameters.getDocument());\n\n        XDOM xdom = this.parser.parse(content, context, false, metadata, context.isInline());\n\n        if (xdom.getChildren().isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        // Reuse the very generic async rendering framework (even if we don't do async and caching) since it's taking\n        // care of many other things\n        BlockAsyncRendererConfiguration configuration = createBlockAsyncRendererConfiguration(null, xdom, context);\n\n        Map<String, Object> backupObjects = new HashMap<>();\n        try {\n            // Switch the context document\n            this.documentAccessBridge.pushDocumentInContext(backupObjects, referencedDocReference);\n\n            // Configure the Transformation Context XDOM depending on the mode asked.\n            configuration.setXDOM(getXDOM(referencedDocReference, parameters));\n\n            // Execute the content\n            Block result = this.executor.execute(configuration);\n\n            // Keep metadata so that the result stay associated to context properties when inserted in the parent XDOM\n            return Arrays.asList((Block) new MetaDataBlock(result.getChildren(), xdom.getMetaData()));\n        } catch (Exception e) {\n            throw new MacroExecutionException(\"Failed start the execution of the macro\", e);\n        } finally {\n            // Restore the context document\n            this.documentAccessBridge.popDocumentFromContext(backupObjects);\n        }\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.rendering.internal.macro.context;\n\nimport java.util.Arrays;\nimport java.util.Collections;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.ArgumentCaptor;\nimport org.xwiki.bridge.DocumentAccessBridge;\nimport org.xwiki.bridge.DocumentModelBridge;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.properties.BeanDescriptor;\nimport org.xwiki.properties.BeanManager;\nimport org.xwiki.rendering.async.internal.block.BlockAsyncRendererConfiguration;\nimport org.xwiki.rendering.async.internal.block.BlockAsyncRendererExecutor;\nimport org.xwiki.rendering.block.MacroBlock;\nimport org.xwiki.rendering.block.WordBlock;\nimport org.xwiki.rendering.block.XDOM;\nimport org.xwiki.rendering.listener.MetaData;\nimport org.xwiki.rendering.macro.MacroContentParser;\nimport org.xwiki.rendering.macro.MacroExecutionException;\nimport org.xwiki.rendering.macro.context.ContextMacroParameters;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.transformation.MacroTransformationContext;\nimport org.xwiki.security.authorization.AccessDeniedException;\nimport org.xwiki.security.authorization.AuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.test.TestEnvironment;\nimport org.xwiki.test.annotation.ComponentList;\nimport org.xwiki.test.junit5.mockito.ComponentTest;\nimport org.xwiki.test.junit5.mockito.InjectMockComponents;\nimport org.xwiki.test.junit5.mockito.MockComponent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.ArgumentMatchers.same;\nimport static org.mockito.Mockito.doThrow;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n/**\n * Unit tests for {@link ContextMacro}.\n *\n * @version $Id$\n * @since 8.3RC1\n */\n@ComponentTest\n@ComponentList(TestEnvironment.class)\nclass ContextMacroTest\n{\n    private static final DocumentReference AUTHOR = new DocumentReference(\"wiki\", \"XWiki\", \"author\");\n\n    private static final DocumentReference TARGET_REFERENCE = new DocumentReference(\"wiki\", \"space\", \"target\");\n\n    private static final DocumentReference SOURCE_REFERENCE = new DocumentReference(\"wiki\", \"space\", \"source\");\n\n    @Inject\n    protected BlockAsyncRendererExecutor executor;\n\n    @MockComponent\n    private DocumentAccessBridge dab;\n\n    @MockComponent\n    private BeanManager beanManager;\n\n    @MockComponent\n    private MacroContentParser parser;\n\n    @MockComponent\n    private AuthorizationManager authorization;\n\n    @MockComponent\n    @Named(\"macro\")\n    private DocumentReferenceResolver<String> macroReferenceResolver;\n\n    @MockComponent\n    protected DocumentReferenceResolver<String> resolver;\n\n    @InjectMockComponents\n    private ContextMacro macro;\n\n    @BeforeEach\n    public void beforeEach() throws Exception\n    {\n        // Macro Descriptor set up\n        BeanDescriptor descriptor = mock(BeanDescriptor.class);\n        when(descriptor.getProperties()).thenReturn(Collections.emptyList());\n        when(this.beanManager.getBeanDescriptor(any())).thenReturn(descriptor);\n\n        when(this.dab.getCurrentAuthorReference()).thenReturn(AUTHOR);\n\n        when(this.macroReferenceResolver.resolve(eq(\"target\"), any())).thenReturn(TARGET_REFERENCE);\n        when(this.resolver.resolve(\"source\")).thenReturn(SOURCE_REFERENCE);\n    }\n\n    @Test\n    void executeWhenNoDocumentSpecified() throws Exception\n    {\n        ContextMacroParameters parameters = new ContextMacroParameters();\n\n        try {\n            this.macro.execute(parameters, \"\", new MacroTransformationContext());\n            fail(\"Should have thrown an exception\");\n        } catch (MacroExecutionException expected) {\n            assertEquals(\"You must specify a 'document' parameter pointing to the document to set in the \"\n                + \"context as the current document.\", expected.getMessage());\n        }\n    }\n\n    @Test\n    void executeWithReferencedDocumentNotViewableByTheAuthor() throws Exception\n    {\n        MacroTransformationContext macroContext = new MacroTransformationContext();\n        MacroBlock macroBlock = new MacroBlock(\"context\", Collections.emptyMap(), false);\n        macroContext.setCurrentMacroBlock(macroBlock);\n\n        doThrow(AccessDeniedException.class).when(this.authorization).checkAccess(Right.VIEW, AUTHOR, TARGET_REFERENCE);\n\n        ContextMacroParameters parameters = new ContextMacroParameters();\n        parameters.setDocument(\"target\");\n\n        try {\n            this.macro.execute(parameters, \"\", macroContext);\n            fail(\"Should have thrown an exception\");\n        } catch (MacroExecutionException expected) {\n            assertEquals(\"Author [wiki:XWiki.author] is not allowed to access target document [wiki:space.target]\",\n                expected.getMessage());\n        }\n    }\n\n    @Test\n    void executeOk() throws Exception\n    {\n        MacroBlock macroBlock = new MacroBlock(\"context\", Collections.<String, String>emptyMap(), false);\n        MetaData metadata = new MetaData();\n        metadata.addMetaData(MetaData.SOURCE, \"source\");\n        XDOM xdom = new XDOM(Arrays.asList(macroBlock), metadata);\n        MacroTransformationContext macroContext = new MacroTransformationContext();\n        macroContext.setSyntax(Syntax.XWIKI_2_0);\n        macroContext.setCurrentMacroBlock(macroBlock);\n\n        DocumentModelBridge dmb = mock(DocumentModelBridge.class);\n        when(this.dab.getTranslatedDocumentInstance(TARGET_REFERENCE)).thenReturn(dmb);\n\n        when(this.parser.parse(eq(\"\"), same(macroContext), eq(false), any(MetaData.class), eq(false))).thenReturn(xdom);\n\n        ContextMacroParameters parameters = new ContextMacroParameters();\n        parameters.setDocument(\"target\");\n\n        when(this.executor.execute(any())).thenReturn(new WordBlock(\"result\"));\n\n        this.macro.execute(parameters, \"\", macroContext);\n\n        ArgumentCaptor<BlockAsyncRendererConfiguration> configurationCaptor =\n            ArgumentCaptor.forClass(BlockAsyncRendererConfiguration.class);\n        verify(this.executor).execute(configurationCaptor.capture());\n\n        BlockAsyncRendererConfiguration configuration = configurationCaptor.getValue();\n        assertEquals(AUTHOR, configuration.getSecureAuthorReference());\n        assertEquals(SOURCE_REFERENCE, configuration.getSecureDocumentReference());\n    }\n}\n"], "fixing_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.rendering.internal.macro.context;\n\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Singleton;\n\nimport org.xwiki.bridge.DocumentModelBridge;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.rendering.async.internal.AbstractExecutedContentMacro;\nimport org.xwiki.rendering.async.internal.block.BlockAsyncRendererConfiguration;\nimport org.xwiki.rendering.block.Block;\nimport org.xwiki.rendering.block.MetaDataBlock;\nimport org.xwiki.rendering.block.XDOM;\nimport org.xwiki.rendering.listener.MetaData;\nimport org.xwiki.rendering.macro.MacroExecutionException;\nimport org.xwiki.rendering.macro.context.ContextMacroParameters;\nimport org.xwiki.rendering.macro.context.TransformationContextMode;\nimport org.xwiki.rendering.macro.descriptor.DefaultContentDescriptor;\nimport org.xwiki.rendering.transformation.MacroTransformationContext;\nimport org.xwiki.rendering.transformation.TransformationContext;\nimport org.xwiki.rendering.transformation.TransformationManager;\nimport org.xwiki.security.authorization.AccessDeniedException;\nimport org.xwiki.security.authorization.AuthorizationManager;\nimport org.xwiki.security.authorization.Right;\n\n/**\n * Execute the macro's content in the context of another document's reference.\n * \n * @version $Id$\n * @since 3.0M1\n */\n@Component\n@Named(\"context\")\n@Singleton\npublic class ContextMacro extends AbstractExecutedContentMacro<ContextMacroParameters>\n{\n    /**\n     * The description of the macro.\n     */\n    private static final String DESCRIPTION = \"Executes content in the context of the passed document\";\n\n    /**\n     * The description of the macro content.\n     */\n    private static final String CONTENT_DESCRIPTION = \"The content to execute\";\n\n    @Inject\n    private AuthorizationManager authorizationManager;\n\n    @Inject\n    private TransformationManager transformationManager;\n\n    @Inject\n    @Named(\"macro\")\n    private DocumentReferenceResolver<String> macroReferenceResolver;\n\n    /**\n     * Create and initialize the descriptor of the macro.\n     */\n    public ContextMacro()\n    {\n        super(\"Context\", DESCRIPTION, new DefaultContentDescriptor(CONTENT_DESCRIPTION, true, Block.LIST_BLOCK_TYPE),\n            ContextMacroParameters.class);\n\n        // The Context macro must execute early since it can contain include macros which can bring stuff like headings\n        // for other macros (TOC macro, etc). Make it the same priority as the Include macro.\n        setPriority(10);\n        setDefaultCategories(Set.of(DEFAULT_CATEGORY_DEVELOPMENT));\n    }\n\n    private void checkAccess(DocumentReference currentAuthor, DocumentReference referencedDocReference)\n        throws MacroExecutionException\n    {\n        // Current author must have view right on the target document to use it as context document\n        try {\n            this.authorizationManager.checkAccess(Right.VIEW, currentAuthor, referencedDocReference);\n        } catch (AccessDeniedException e) {\n            throw new MacroExecutionException(\"Author [\" + currentAuthor\n                + \"] is not allowed to access target document [\" + referencedDocReference + \"]\", e);\n        }\n    }\n\n    private XDOM getXDOM(DocumentReference referencedDocReference, ContextMacroParameters parameters)\n        throws MacroExecutionException\n    {\n        try {\n            if (parameters.getTransformationContext() == TransformationContextMode.DOCUMENT\n                || parameters.getTransformationContext() == TransformationContextMode.TRANSFORMATIONS) {\n                // Apply the transformations but with a Transformation Context having the XDOM of the passed\n                // document so that macros execute on the passed document's XDOM (e.g. the TOC macro will generate\n                // the toc for the passed document instead of the current document).\n                DocumentModelBridge referencedDoc =\n                    this.documentAccessBridge.getTranslatedDocumentInstance(referencedDocReference);\n                XDOM referencedXDOM = referencedDoc.getXDOM();\n\n                if (parameters.getTransformationContext() == TransformationContextMode.TRANSFORMATIONS) {\n                    // Get the XDOM from the referenced doc but with Transformations applied so that all macro are\n                    // executed and contribute XDOM elements.\n                    // IMPORTANT: This can be dangerous since it means executing macros, and thus also script macros\n                    // defined in the referenced document. To be used with caution.\n                    TransformationContext referencedTxContext =\n                        new TransformationContext(referencedXDOM, referencedDoc.getSyntax());\n                    this.transformationManager.performTransformations(referencedXDOM, referencedTxContext);\n                }\n\n                return referencedXDOM;\n            }\n        } catch (Exception e) {\n            throw new MacroExecutionException(\"Failed to resolve the XDOM to use in the transformation\", e);\n        }\n\n        return null;\n    }\n\n    @Override\n    public List<Block> execute(ContextMacroParameters parameters, String content, MacroTransformationContext context)\n        throws MacroExecutionException\n    {\n        if (parameters.getDocument() == null) {\n            throw new MacroExecutionException(\"You must specify a 'document' parameter pointing to the document to \"\n                + \"set in the context as the current document.\");\n        }\n\n        DocumentReference currentAuthor = this.documentAccessBridge.getCurrentAuthorReference();\n        DocumentReference referencedDocReference =\n            this.macroReferenceResolver.resolve(parameters.getDocument(), context.getCurrentMacroBlock());\n\n        // Make sure the author is allowed to use the target document\n        checkAccess(currentAuthor, referencedDocReference);\n\n        MetaData metadata = new MetaData();\n        metadata.addMetaData(MetaData.SOURCE, parameters.getDocument());\n        metadata.addMetaData(MetaData.BASE, parameters.getDocument());\n\n        XDOM xdom = this.parser.parse(content, context, false, metadata, context.isInline());\n\n        if (xdom.getChildren().isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        // Reuse the very generic async rendering framework (even if we don't do async and caching) since it's taking\n        // care of many other things\n        BlockAsyncRendererConfiguration configuration = createBlockAsyncRendererConfiguration(null, xdom, context);\n        configuration.setAsyncAllowed(false);\n        configuration.setCacheAllowed(false);\n\n        Map<String, Object> backupObjects = new HashMap<>();\n        try {\n            // Switch the context document\n            this.documentAccessBridge.pushDocumentInContext(backupObjects, referencedDocReference);\n\n            // Configure the Transformation Context XDOM depending on the mode asked.\n            configuration.setXDOM(getXDOM(referencedDocReference, parameters));\n\n            // Execute the content\n            Block result = this.executor.execute(configuration);\n\n            // Keep metadata so that the result stay associated to context properties when inserted in the parent XDOM\n            return Arrays.asList((Block) new MetaDataBlock(result.getChildren(), xdom.getMetaData()));\n        } catch (Exception e) {\n            throw new MacroExecutionException(\"Failed start the execution of the macro\", e);\n        } finally {\n            // Restore the context document\n            this.documentAccessBridge.popDocumentFromContext(backupObjects);\n        }\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.rendering.internal.macro.context;\n\nimport java.util.Arrays;\nimport java.util.Collections;\n\nimport javax.inject.Named;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.ArgumentCaptor;\nimport org.xwiki.bridge.DocumentAccessBridge;\nimport org.xwiki.bridge.DocumentModelBridge;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.properties.BeanDescriptor;\nimport org.xwiki.properties.BeanManager;\nimport org.xwiki.rendering.async.internal.block.BlockAsyncRendererConfiguration;\nimport org.xwiki.rendering.async.internal.block.BlockAsyncRendererExecutor;\nimport org.xwiki.rendering.block.MacroBlock;\nimport org.xwiki.rendering.block.WordBlock;\nimport org.xwiki.rendering.block.XDOM;\nimport org.xwiki.rendering.listener.MetaData;\nimport org.xwiki.rendering.macro.MacroContentParser;\nimport org.xwiki.rendering.macro.MacroExecutionException;\nimport org.xwiki.rendering.macro.context.ContextMacroParameters;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.transformation.MacroTransformationContext;\nimport org.xwiki.security.authorization.AccessDeniedException;\nimport org.xwiki.security.authorization.AuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.test.TestEnvironment;\nimport org.xwiki.test.annotation.ComponentList;\nimport org.xwiki.test.junit5.mockito.ComponentTest;\nimport org.xwiki.test.junit5.mockito.InjectComponentManager;\nimport org.xwiki.test.junit5.mockito.InjectMockComponents;\nimport org.xwiki.test.junit5.mockito.MockComponent;\nimport org.xwiki.test.mockito.MockitoComponentManager;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.ArgumentMatchers.same;\nimport static org.mockito.Mockito.doThrow;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n/**\n * Unit tests for {@link ContextMacro}.\n *\n * @version $Id$\n * @since 8.3RC1\n */\n@ComponentTest\n@ComponentList(TestEnvironment.class)\nclass ContextMacroTest\n{\n    private static final DocumentReference AUTHOR = new DocumentReference(\"wiki\", \"XWiki\", \"author\");\n\n    private static final DocumentReference TARGET_REFERENCE = new DocumentReference(\"wiki\", \"space\", \"target\");\n\n    private static final DocumentReference SOURCE_REFERENCE = new DocumentReference(\"wiki\", \"space\", \"source\");\n\n    @MockComponent\n    private DocumentAccessBridge dab;\n\n    @MockComponent\n    private BeanManager beanManager;\n\n    @MockComponent\n    private MacroContentParser parser;\n\n    @MockComponent\n    private AuthorizationManager authorization;\n\n    @MockComponent\n    @Named(\"macro\")\n    private DocumentReferenceResolver<String> macroReferenceResolver;\n\n    @MockComponent\n    private DocumentReferenceResolver<String> resolver;\n\n    @InjectMockComponents\n    private ContextMacro macro;\n\n    @InjectComponentManager\n    private MockitoComponentManager componentManager;\n\n    private BlockAsyncRendererExecutor executor;\n\n    @BeforeEach\n    public void beforeEach() throws Exception\n    {\n        // Macro Descriptor set up\n        BeanDescriptor descriptor = mock(BeanDescriptor.class);\n        when(descriptor.getProperties()).thenReturn(Collections.emptyList());\n        when(this.beanManager.getBeanDescriptor(any())).thenReturn(descriptor);\n\n        when(this.dab.getCurrentAuthorReference()).thenReturn(AUTHOR);\n\n        when(this.macroReferenceResolver.resolve(eq(\"target\"), any())).thenReturn(TARGET_REFERENCE);\n        when(this.resolver.resolve(\"source\")).thenReturn(SOURCE_REFERENCE);\n\n        this.executor = this.componentManager.getInstance(BlockAsyncRendererExecutor.class);\n    }\n\n    @Test\n    void executeWhenNoDocumentSpecified() throws Exception\n    {\n        ContextMacroParameters parameters = new ContextMacroParameters();\n\n        try {\n            this.macro.execute(parameters, \"\", new MacroTransformationContext());\n            fail(\"Should have thrown an exception\");\n        } catch (MacroExecutionException expected) {\n            assertEquals(\"You must specify a 'document' parameter pointing to the document to set in the \"\n                + \"context as the current document.\", expected.getMessage());\n        }\n    }\n\n    @Test\n    void executeWithReferencedDocumentNotViewableByTheAuthor() throws Exception\n    {\n        MacroTransformationContext macroContext = new MacroTransformationContext();\n        MacroBlock macroBlock = new MacroBlock(\"context\", Collections.emptyMap(), false);\n        macroContext.setCurrentMacroBlock(macroBlock);\n\n        doThrow(AccessDeniedException.class).when(this.authorization).checkAccess(Right.VIEW, AUTHOR, TARGET_REFERENCE);\n\n        ContextMacroParameters parameters = new ContextMacroParameters();\n        parameters.setDocument(\"target\");\n\n        try {\n            this.macro.execute(parameters, \"\", macroContext);\n            fail(\"Should have thrown an exception\");\n        } catch (MacroExecutionException expected) {\n            assertEquals(\"Author [wiki:XWiki.author] is not allowed to access target document [wiki:space.target]\",\n                expected.getMessage());\n        }\n    }\n\n    @Test\n    void executeOk() throws Exception\n    {\n        MacroBlock macroBlock = new MacroBlock(\"context\", Collections.<String, String>emptyMap(), false);\n        MetaData metadata = new MetaData();\n        metadata.addMetaData(MetaData.SOURCE, \"source\");\n        XDOM xdom = new XDOM(Arrays.asList(macroBlock), metadata);\n        MacroTransformationContext macroContext = new MacroTransformationContext();\n        macroContext.setSyntax(Syntax.XWIKI_2_0);\n        macroContext.setCurrentMacroBlock(macroBlock);\n\n        DocumentModelBridge dmb = mock(DocumentModelBridge.class);\n        when(this.dab.getTranslatedDocumentInstance(TARGET_REFERENCE)).thenReturn(dmb);\n\n        when(this.parser.parse(eq(\"\"), same(macroContext), eq(false), any(MetaData.class), eq(false))).thenReturn(xdom);\n\n        ContextMacroParameters parameters = new ContextMacroParameters();\n        parameters.setDocument(\"target\");\n\n        when(this.executor.execute(any())).thenReturn(new WordBlock(\"result\"));\n\n        this.macro.execute(parameters, \"\", macroContext);\n\n        ArgumentCaptor<BlockAsyncRendererConfiguration> configurationCaptor =\n            ArgumentCaptor.forClass(BlockAsyncRendererConfiguration.class);\n        verify(this.executor).execute(configurationCaptor.capture());\n\n        BlockAsyncRendererConfiguration configuration = configurationCaptor.getValue();\n        assertEquals(AUTHOR, configuration.getSecureAuthorReference());\n        assertEquals(SOURCE_REFERENCE, configuration.getSecureDocumentReference());\n    }\n}\n"], "filenames": ["xwiki-platform-core/xwiki-platform-rendering/xwiki-platform-rendering-macros/xwiki-platform-rendering-macro-context/src/main/java/org/xwiki/rendering/internal/macro/context/ContextMacro.java", "xwiki-platform-core/xwiki-platform-rendering/xwiki-platform-rendering-macros/xwiki-platform-rendering-macro-context/src/test/java/org/xwiki/rendering/internal/macro/context/ContextMacroTest.java"], "buggy_code_start_loc": [171, 25], "buggy_code_end_loc": [171, 119], "fixing_code_start_loc": [172, 24], "fixing_code_end_loc": [174, 125], "type": "CWE-863", "message": "XWiki Platform is a generic wiki platform. Starting in version 3.0-milestone-1, it's possible to execute a script with the right of another user, provided the target user does not have programming right. The problem has been patched in XWiki 14.8-rc-1, 14.4.5, and 13.10.10. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2023-26056", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-02T19:15:10.957", "lastModified": "2023-03-13T16:15:29.717", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "XWiki Platform is a generic wiki platform. Starting in version 3.0-milestone-1, it's possible to execute a script with the right of another user, provided the target user does not have programming right. The problem has been patched in XWiki 14.8-rc-1, 14.4.5, and 13.10.10. There are no known workarounds for this issue."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-863"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.1", "versionEndExcluding": "13.10.10", "matchCriteriaId": "D1595259-D265-4602-95D3-C6C8F83EBEF6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:*:*:*:*:*:*:*:*", "versionStartIncluding": "14.0", "versionEndExcluding": "14.4.5", "matchCriteriaId": "DD91ED5A-574E-416A-B503-04D5EBD7FCB5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:*:*:*:*:*:*:*:*", "versionStartIncluding": "14.5", "versionEndExcluding": "14.8", "matchCriteriaId": "DD83BA23-29DC-4430-A6DF-02D03BDFC983"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:3.0:milestone1:*:*:*:*:*:*", "matchCriteriaId": "7BEE764B-ED54-43D8-9748-DE57B5F1D701"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:3.0:milestone2:*:*:*:*:*:*", "matchCriteriaId": "90C4A1EA-8B6A-4FE8-985B-EB924DA3A826"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:3.0:milestone3:*:*:*:*:*:*", "matchCriteriaId": "A45A230D-909F-42D3-836D-95660805B094"}]}]}], "references": [{"url": "https://github.com/xwiki/xwiki-platform/commit/4b75f212c2dd2dfc5fb5726c7830c6dbc9a425c6", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/xwiki/xwiki-platform/commit/bd34ad6710ed72304304a3d5fec38b7cc050ef3b", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/xwiki/xwiki-platform/commit/dd3f4735b41971b3afc3f3aedf6664b4e8be4894", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/xwiki/xwiki-platform/security/advisories/GHSA-859x-p6jp-rc2w", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}, {"url": "https://jira.xwiki.org/browse/XWIKI-19856", "source": "security-advisories@github.com", "tags": ["Exploit", "Issue Tracking", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/xwiki/xwiki-platform/commit/4b75f212c2dd2dfc5fb5726c7830c6dbc9a425c6"}}