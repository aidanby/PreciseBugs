{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * buffer.c: functions for dealing with the buffer structure\n */\n\n/*\n * The buffer list is a double linked list of all buffers.\n * Each buffer can be in one of these states:\n * never loaded: BF_NEVERLOADED is set, only the file name is valid\n *   not loaded: b_ml.ml_mfp == NULL, no memfile allocated\n *\t hidden: b_nwindows == 0, loaded but not displayed in a window\n *\t normal: loaded and displayed in a window\n *\n * Instead of storing file names all over the place, each file name is\n * stored in the buffer list. It can be referenced by a number.\n *\n * The current implementation remembers all file names ever used.\n */\n\n#include \"vim.h\"\n\n\n#ifdef FEAT_EVAL\n// Determines how deeply nested %{} blocks will be evaluated in statusline.\n# define MAX_STL_EVAL_DEPTH 100\n#endif\n\nstatic void\tenter_buffer(buf_T *buf);\nstatic void\tbuflist_getfpos(void);\nstatic char_u\t*buflist_match(regmatch_T *rmp, buf_T *buf, int ignore_case);\nstatic char_u\t*fname_match(regmatch_T *rmp, char_u *name, int ignore_case);\n#ifdef UNIX\nstatic buf_T\t*buflist_findname_stat(char_u *ffname, stat_T *st);\nstatic int\totherfile_buf(buf_T *buf, char_u *ffname, stat_T *stp);\nstatic int\tbuf_same_ino(buf_T *buf, stat_T *stp);\n#else\nstatic int\totherfile_buf(buf_T *buf, char_u *ffname);\n#endif\nstatic int\tvalue_changed(char_u *str, char_u **last);\nstatic int\tappend_arg_number(win_T *wp, char_u *buf, int buflen, int add_file);\nstatic void\tfree_buffer(buf_T *);\nstatic void\tfree_buffer_stuff(buf_T *buf, int free_options);\nstatic void\tclear_wininfo(buf_T *buf);\n\n#ifdef UNIX\n# define dev_T dev_t\n#else\n# define dev_T unsigned\n#endif\n\n#define FOR_ALL_BUFS_FROM_LAST(buf) \\\n    for ((buf) = lastbuf; (buf) != NULL; (buf) = (buf)->b_prev)\n\n#if defined(FEAT_QUICKFIX)\nstatic char *msg_loclist = N_(\"[Location List]\");\nstatic char *msg_qflist = N_(\"[Quickfix List]\");\n#endif\n\n// Number of times free_buffer() was called.\nstatic int\tbuf_free_count = 0;\n\nstatic int\ttop_file_num = 1;\t// highest file number\nstatic garray_T buf_reuse = GA_EMPTY;\t// file numbers to recycle\n\n/*\n * Return the highest possible buffer number.\n */\n    int\nget_highest_fnum(void)\n{\n    return top_file_num - 1;\n}\n\n/*\n * Read data from buffer for retrying.\n */\n    static int\nread_buffer(\n    int\t\tread_stdin,\t    // read file from stdin, otherwise fifo\n    exarg_T\t*eap,\t\t    // for forced 'ff' and 'fenc' or NULL\n    int\t\tflags)\t\t    // extra flags for readfile()\n{\n    int\t\tretval = OK;\n    linenr_T\tline_count;\n\n    // Read from the buffer which the text is already filled in and append at\n    // the end.  This makes it possible to retry when 'fileformat' or\n    // 'fileencoding' was guessed wrong.\n    line_count = curbuf->b_ml.ml_line_count;\n    retval = readfile(\n\t    read_stdin ? NULL : curbuf->b_ffname,\n\t    read_stdin ? NULL : curbuf->b_fname,\n\t    line_count, (linenr_T)0, (linenr_T)MAXLNUM, eap,\n\t    flags | READ_BUFFER);\n    if (retval == OK)\n    {\n\t// Delete the binary lines.\n\twhile (--line_count >= 0)\n\t    ml_delete((linenr_T)1);\n    }\n    else\n    {\n\t// Delete the converted lines.\n\twhile (curbuf->b_ml.ml_line_count > line_count)\n\t    ml_delete(line_count);\n    }\n    // Put the cursor on the first line.\n    curwin->w_cursor.lnum = 1;\n    curwin->w_cursor.col = 0;\n\n    if (read_stdin)\n    {\n\t// Set or reset 'modified' before executing autocommands, so that\n\t// it can be changed there.\n\tif (!readonlymode && !BUFEMPTY())\n\t    changed();\n\telse if (retval == OK)\n\t    unchanged(curbuf, FALSE, TRUE);\n\n\tif (retval == OK)\n\t{\n#ifdef FEAT_EVAL\n\t    apply_autocmds_retval(EVENT_STDINREADPOST, NULL, NULL, FALSE,\n\t\t\t\t\t\t\t      curbuf, &retval);\n#else\n\t    apply_autocmds(EVENT_STDINREADPOST, NULL, NULL, FALSE, curbuf);\n#endif\n\t}\n    }\n    return retval;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Ensure buffer \"buf\" is loaded.  Does not trigger the swap-exists action.\n */\n    void\nbuffer_ensure_loaded(buf_T *buf)\n{\n    if (buf->b_ml.ml_mfp == NULL)\n    {\n\taco_save_T\taco;\n\n\taucmd_prepbuf(&aco, buf);\n\tif (swap_exists_action != SEA_READONLY)\n\t    swap_exists_action = SEA_NONE;\n\topen_buffer(FALSE, NULL, 0);\n\taucmd_restbuf(&aco);\n    }\n}\n#endif\n\n/*\n * Open current buffer, that is: open the memfile and read the file into\n * memory.\n * Return FAIL for failure, OK otherwise.\n */\n    int\nopen_buffer(\n    int\t\tread_stdin,\t    // read file from stdin\n    exarg_T\t*eap,\t\t    // for forced 'ff' and 'fenc' or NULL\n    int\t\tflags)\t\t    // extra flags for readfile()\n{\n    int\t\tretval = OK;\n    bufref_T\told_curbuf;\n#ifdef FEAT_SYN_HL\n    long\told_tw = curbuf->b_p_tw;\n#endif\n    int\t\tread_fifo = FALSE;\n\n    // The 'readonly' flag is only set when BF_NEVERLOADED is being reset.\n    // When re-entering the same buffer, it should not change, because the\n    // user may have reset the flag by hand.\n    if (readonlymode && curbuf->b_ffname != NULL\n\t\t\t\t\t&& (curbuf->b_flags & BF_NEVERLOADED))\n\tcurbuf->b_p_ro = TRUE;\n\n    if (ml_open(curbuf) == FAIL)\n    {\n\t// There MUST be a memfile, otherwise we can't do anything\n\t// If we can't create one for the current buffer, take another buffer\n\tclose_buffer(NULL, curbuf, 0, FALSE, FALSE);\n\tFOR_ALL_BUFFERS(curbuf)\n\t    if (curbuf->b_ml.ml_mfp != NULL)\n\t\tbreak;\n\t// If there is no memfile at all, exit.\n\t// This is OK, since there are no changes to lose.\n\tif (curbuf == NULL)\n\t{\n\t    emsg(_(e_cannot_allocate_any_buffer_exiting));\n\n\t    // Don't try to do any saving, with \"curbuf\" NULL almost nothing\n\t    // will work.\n\t    v_dying = 2;\n\t    getout(2);\n\t}\n\n\temsg(_(e_cannot_allocate_buffer_using_other_one));\n\tenter_buffer(curbuf);\n#ifdef FEAT_SYN_HL\n\tif (old_tw != curbuf->b_p_tw)\n\t    check_colorcolumn(curwin);\n#endif\n\treturn FAIL;\n    }\n\n    // The autocommands in readfile() may change the buffer, but only AFTER\n    // reading the file.\n    set_bufref(&old_curbuf, curbuf);\n    modified_was_set = FALSE;\n\n    // mark cursor position as being invalid\n    curwin->w_valid = 0;\n\n    if (curbuf->b_ffname != NULL\n#ifdef FEAT_NETBEANS_INTG\n\t    && netbeansReadFile\n#endif\n       )\n    {\n\tint old_msg_silent = msg_silent;\n#ifdef UNIX\n\tint save_bin = curbuf->b_p_bin;\n\tint perm;\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\tint oldFire = netbeansFireChanges;\n\n\tnetbeansFireChanges = 0;\n#endif\n#ifdef UNIX\n\tperm = mch_getperm(curbuf->b_ffname);\n\tif (perm >= 0 && (S_ISFIFO(perm)\n\t\t      || S_ISSOCK(perm)\n# ifdef OPEN_CHR_FILES\n\t\t      || (S_ISCHR(perm) && is_dev_fd_file(curbuf->b_ffname))\n# endif\n\t\t    ))\n\t\tread_fifo = TRUE;\n\tif (read_fifo)\n\t    curbuf->b_p_bin = TRUE;\n#endif\n\tif (shortmess(SHM_FILEINFO))\n\t    msg_silent = 1;\n\tretval = readfile(curbuf->b_ffname, curbuf->b_fname,\n\t\t  (linenr_T)0, (linenr_T)0, (linenr_T)MAXLNUM, eap,\n\t\t  flags | READ_NEW | (read_fifo ? READ_FIFO : 0));\n#ifdef UNIX\n\tif (read_fifo)\n\t{\n\t    curbuf->b_p_bin = save_bin;\n\t    if (retval == OK)\n\t\tretval = read_buffer(FALSE, eap, flags);\n\t}\n#endif\n\tmsg_silent = old_msg_silent;\n#ifdef FEAT_NETBEANS_INTG\n\tnetbeansFireChanges = oldFire;\n#endif\n\t// Help buffer is filtered.\n\tif (bt_help(curbuf))\n\t    fix_help_buffer();\n    }\n    else if (read_stdin)\n    {\n\tint\tsave_bin = curbuf->b_p_bin;\n\n\t// First read the text in binary mode into the buffer.\n\t// Then read from that same buffer and append at the end.  This makes\n\t// it possible to retry when 'fileformat' or 'fileencoding' was\n\t// guessed wrong.\n\tcurbuf->b_p_bin = TRUE;\n\tretval = readfile(NULL, NULL, (linenr_T)0,\n\t\t  (linenr_T)0, (linenr_T)MAXLNUM, NULL,\n\t\t  flags | (READ_NEW + READ_STDIN));\n\tcurbuf->b_p_bin = save_bin;\n\tif (retval == OK)\n\t    retval = read_buffer(TRUE, eap, flags);\n    }\n\n    // if first time loading this buffer, init b_chartab[]\n    if (curbuf->b_flags & BF_NEVERLOADED)\n    {\n\t(void)buf_init_chartab(curbuf, FALSE);\n\tparse_cino(curbuf);\n    }\n\n    // Set/reset the Changed flag first, autocmds may change the buffer.\n    // Apply the automatic commands, before processing the modelines.\n    // So the modelines have priority over autocommands.\n    //\n    // When reading stdin, the buffer contents always needs writing, so set\n    // the changed flag.  Unless in readonly mode: \"ls | gview -\".\n    // When interrupted and 'cpoptions' contains 'i' set changed flag.\n    if ((got_int && vim_strchr(p_cpo, CPO_INTMOD) != NULL)\n\t\t|| modified_was_set\t// \":set modified\" used in autocmd\n#ifdef FEAT_EVAL\n\t\t|| (aborting() && vim_strchr(p_cpo, CPO_INTMOD) != NULL)\n#endif\n       )\n\tchanged();\n    else if (retval == OK && !read_stdin && !read_fifo)\n\tunchanged(curbuf, FALSE, TRUE);\n    save_file_ff(curbuf);\t\t// keep this fileformat\n\n    // Set last_changedtick to avoid triggering a TextChanged autocommand right\n    // after it was added.\n    curbuf->b_last_changedtick = CHANGEDTICK(curbuf);\n    curbuf->b_last_changedtick_i = CHANGEDTICK(curbuf);\n    curbuf->b_last_changedtick_pum = CHANGEDTICK(curbuf);\n\n    // require \"!\" to overwrite the file, because it wasn't read completely\n#ifdef FEAT_EVAL\n    if (aborting())\n#else\n    if (got_int)\n#endif\n\tcurbuf->b_flags |= BF_READERR;\n\n#ifdef FEAT_FOLDING\n    // Need to update automatic folding.  Do this before the autocommands,\n    // they may use the fold info.\n    foldUpdateAll(curwin);\n#endif\n\n    // need to set w_topline, unless some autocommand already did that.\n    if (!(curwin->w_valid & VALID_TOPLINE))\n    {\n\tcurwin->w_topline = 1;\n#ifdef FEAT_DIFF\n\tcurwin->w_topfill = 0;\n#endif\n    }\n#ifdef FEAT_EVAL\n    apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf, &retval);\n#else\n    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n#endif\n\n    if (retval == OK)\n    {\n\t// The autocommands may have changed the current buffer.  Apply the\n\t// modelines to the correct buffer, if it still exists and is loaded.\n\tif (bufref_valid(&old_curbuf) && old_curbuf.br_buf->b_ml.ml_mfp != NULL)\n\t{\n\t    aco_save_T\taco;\n\n\t    // Go to the buffer that was opened.\n\t    aucmd_prepbuf(&aco, old_curbuf.br_buf);\n\t    do_modelines(0);\n\t    curbuf->b_flags &= ~(BF_CHECK_RO | BF_NEVERLOADED);\n\n\t    if ((flags & READ_NOWINENTER) == 0)\n#ifdef FEAT_EVAL\n\t\tapply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL, FALSE,\n\t\t\t\t\t\t\t      curbuf, &retval);\n#else\n\t\tapply_autocmds(EVENT_BUFWINENTER, NULL, NULL, FALSE, curbuf);\n#endif\n\n\t    // restore curwin/curbuf and a few other things\n\t    aucmd_restbuf(&aco);\n\t}\n    }\n\n    return retval;\n}\n\n/*\n * Store \"buf\" in \"bufref\" and set the free count.\n */\n    void\nset_bufref(bufref_T *bufref, buf_T *buf)\n{\n    bufref->br_buf = buf;\n    bufref->br_fnum = buf == NULL ? 0 : buf->b_fnum;\n    bufref->br_buf_free_count = buf_free_count;\n}\n\n/*\n * Return TRUE if \"bufref->br_buf\" points to the same buffer as when\n * set_bufref() was called and it is a valid buffer.\n * Only goes through the buffer list if buf_free_count changed.\n * Also checks if b_fnum is still the same, a :bwipe followed by :new might get\n * the same allocated memory, but it's a different buffer.\n */\n    int\nbufref_valid(bufref_T *bufref)\n{\n    return bufref->br_buf_free_count == buf_free_count\n\t? TRUE : buf_valid(bufref->br_buf)\n\t\t\t\t  && bufref->br_fnum == bufref->br_buf->b_fnum;\n}\n\n/*\n * Return TRUE if \"buf\" points to a valid buffer (in the buffer list).\n * This can be slow if there are many buffers, prefer using bufref_valid().\n */\n    int\nbuf_valid(buf_T *buf)\n{\n    buf_T\t*bp;\n\n    // Assume that we more often have a recent buffer, start with the last\n    // one.\n    FOR_ALL_BUFS_FROM_LAST(bp)\n\tif (bp == buf)\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * A hash table used to quickly lookup a buffer by its number.\n */\nstatic hashtab_T buf_hashtab;\n\n    static void\nbuf_hashtab_add(buf_T *buf)\n{\n    sprintf((char *)buf->b_key, \"%x\", buf->b_fnum);\n    if (hash_add(&buf_hashtab, buf->b_key) == FAIL)\n\temsg(_(e_buffer_cannot_be_registered));\n}\n\n    static void\nbuf_hashtab_remove(buf_T *buf)\n{\n    hashitem_T *hi = hash_find(&buf_hashtab, buf->b_key);\n\n    if (!HASHITEM_EMPTY(hi))\n\thash_remove(&buf_hashtab, hi);\n}\n\n/*\n * Return TRUE when buffer \"buf\" can be unloaded.\n * Give an error message and return FALSE when the buffer is locked or the\n * screen is being redrawn and the buffer is in a window.\n */\n    static int\ncan_unload_buffer(buf_T *buf)\n{\n    int\t    can_unload = !buf->b_locked;\n\n    if (can_unload && updating_screen)\n    {\n\twin_T\t*wp;\n\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_buffer == buf)\n\t    {\n\t\tcan_unload = FALSE;\n\t\tbreak;\n\t    }\n    }\n    if (!can_unload)\n\tsemsg(_(e_attempt_to_delete_buffer_that_is_in_use_str), buf->b_fname);\n    return can_unload;\n}\n\n/*\n * Close the link to a buffer.\n * \"action\" is used when there is no longer a window for the buffer.\n * It can be:\n * 0\t\t\tbuffer becomes hidden\n * DOBUF_UNLOAD\t\tbuffer is unloaded\n * DOBUF_DELETE\t\tbuffer is unloaded and removed from buffer list\n * DOBUF_WIPE\t\tbuffer is unloaded and really deleted\n * DOBUF_WIPE_REUSE\tidem, and add to buf_reuse list\n * When doing all but the first one on the current buffer, the caller should\n * get a new buffer very soon!\n *\n * The 'bufhidden' option can force freeing and deleting.\n *\n * When \"abort_if_last\" is TRUE then do not close the buffer if autocommands\n * cause there to be only one window with this buffer.  e.g. when \":quit\" is\n * supposed to close the window but autocommands close all other windows.\n *\n * When \"ignore_abort\" is TRUE don't abort even when aborting() returns TRUE.\n *\n * Return TRUE when we got to the end and b_nwindows was decremented.\n */\n    int\nclose_buffer(\n    win_T\t*win,\t\t// if not NULL, set b_last_cursor\n    buf_T\t*buf,\n    int\t\taction,\n    int\t\tabort_if_last,\n    int\t\tignore_abort)\n{\n    int\t\tis_curbuf;\n    int\t\tnwindows;\n    bufref_T\tbufref;\n    int\t\tis_curwin = (curwin != NULL && curwin->w_buffer == buf);\n    win_T\t*the_curwin = curwin;\n    tabpage_T\t*the_curtab = curtab;\n    int\t\tunload_buf = (action != 0);\n    int\t\twipe_buf = (action == DOBUF_WIPE || action == DOBUF_WIPE_REUSE);\n    int\t\tdel_buf = (action == DOBUF_DEL || wipe_buf);\n\n    CHECK_CURBUF;\n\n    // Force unloading or deleting when 'bufhidden' says so.\n    // The caller must take care of NOT deleting/freeing when 'bufhidden' is\n    // \"hide\" (otherwise we could never free or delete a buffer).\n    if (buf->b_p_bh[0] == 'd')\t\t// 'bufhidden' == \"delete\"\n    {\n\tdel_buf = TRUE;\n\tunload_buf = TRUE;\n    }\n    else if (buf->b_p_bh[0] == 'w')\t// 'bufhidden' == \"wipe\"\n    {\n\tdel_buf = TRUE;\n\tunload_buf = TRUE;\n\twipe_buf = TRUE;\n    }\n    else if (buf->b_p_bh[0] == 'u')\t// 'bufhidden' == \"unload\"\n\tunload_buf = TRUE;\n\n#ifdef FEAT_TERMINAL\n    if (bt_terminal(buf) && (buf->b_nwindows == 1 || del_buf))\n    {\n\tCHECK_CURBUF;\n\tif (term_job_running(buf->b_term))\n\t{\n\t    if (wipe_buf || unload_buf)\n\t    {\n\t\tif (!can_unload_buffer(buf))\n\t\t    return FALSE;\n\n\t\t// Wiping out or unloading a terminal buffer kills the job.\n\t\tfree_terminal(buf);\n\t    }\n\t    else\n\t    {\n\t\t// The job keeps running, hide the buffer.\n\t\tdel_buf = FALSE;\n\t\tunload_buf = FALSE;\n\t    }\n\t}\n\telse if (buf->b_p_bh[0] == 'h' && !del_buf)\n\t{\n\t    // Hide a terminal buffer.\n\t    unload_buf = FALSE;\n\t}\n\telse\n\t{\n\t    // A terminal buffer is wiped out if the job has finished.\n\t    del_buf = TRUE;\n\t    unload_buf = TRUE;\n\t    wipe_buf = TRUE;\n\t}\n\tCHECK_CURBUF;\n    }\n#endif\n\n    // Disallow deleting the buffer when it is locked (already being closed or\n    // halfway a command that relies on it). Unloading is allowed.\n    if ((del_buf || wipe_buf) && !can_unload_buffer(buf))\n\treturn FALSE;\n\n    // check no autocommands closed the window\n    if (win != NULL && win_valid_any_tab(win))\n    {\n\t// Set b_last_cursor when closing the last window for the buffer.\n\t// Remember the last cursor position and window options of the buffer.\n\t// This used to be only for the current window, but then options like\n\t// 'foldmethod' may be lost with a \":only\" command.\n\tif (buf->b_nwindows == 1)\n\t    set_last_cursor(win);\n\tbuflist_setfpos(buf, win,\n\t\t    win->w_cursor.lnum == 1 ? 0 : win->w_cursor.lnum,\n\t\t    win->w_cursor.col, TRUE);\n    }\n\n    set_bufref(&bufref, buf);\n\n    // When the buffer is no longer in a window, trigger BufWinLeave\n    if (buf->b_nwindows == 1)\n    {\n\t++buf->b_locked;\n\t++buf->b_locked_split;\n\tif (apply_autocmds(EVENT_BUFWINLEAVE, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t  FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t{\n\t    // Autocommands deleted the buffer.\naucmd_abort:\n\t    emsg(_(e_autocommands_caused_command_to_abort));\n\t    return FALSE;\n\t}\n\t--buf->b_locked;\n\t--buf->b_locked_split;\n\tif (abort_if_last && one_window())\n\t    // Autocommands made this the only window.\n\t    goto aucmd_abort;\n\n\t// When the buffer becomes hidden, but is not unloaded, trigger\n\t// BufHidden\n\tif (!unload_buf)\n\t{\n\t    ++buf->b_locked;\n\t    ++buf->b_locked_split;\n\t    if (apply_autocmds(EVENT_BUFHIDDEN, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t  FALSE, buf)\n\t\t    && !bufref_valid(&bufref))\n\t\t// Autocommands deleted the buffer.\n\t\tgoto aucmd_abort;\n\t    --buf->b_locked;\n\t    --buf->b_locked_split;\n\t    if (abort_if_last && one_window())\n\t\t// Autocommands made this the only window.\n\t\tgoto aucmd_abort;\n\t}\n#ifdef FEAT_EVAL\n\t// autocmds may abort script processing\n\tif (!ignore_abort && aborting())\n\t    return FALSE;\n#endif\n    }\n\n    // If the buffer was in curwin and the window has changed, go back to that\n    // window, if it still exists.  This avoids that \":edit x\" triggering a\n    // \"tabnext\" BufUnload autocmd leaves a window behind without a buffer.\n    if (is_curwin && curwin != the_curwin &&  win_valid_any_tab(the_curwin))\n    {\n\tblock_autocmds();\n\tgoto_tabpage_win(the_curtab, the_curwin);\n\tunblock_autocmds();\n    }\n\n    nwindows = buf->b_nwindows;\n\n    // decrease the link count from windows (unless not in any window)\n    if (buf->b_nwindows > 0)\n\t--buf->b_nwindows;\n\n#ifdef FEAT_DIFF\n    if (diffopt_hiddenoff() && !unload_buf && buf->b_nwindows == 0)\n\tdiff_buf_delete(buf);\t// Clear 'diff' for hidden buffer.\n#endif\n\n    // Return when a window is displaying the buffer or when it's not\n    // unloaded.\n    if (buf->b_nwindows > 0 || !unload_buf)\n\treturn FALSE;\n\n    // Always remove the buffer when there is no file name.\n    if (buf->b_ffname == NULL)\n\tdel_buf = TRUE;\n\n    // When closing the current buffer stop Visual mode before freeing\n    // anything.\n    if (buf == curbuf && VIsual_active\n#if defined(EXITFREE)\n\t    && !entered_free_all_mem\n#endif\n\t    )\n\tend_visual_mode();\n\n    // Free all things allocated for this buffer.\n    // Also calls the \"BufDelete\" autocommands when del_buf is TRUE.\n    //\n    // Remember if we are closing the current buffer.  Restore the number of\n    // windows, so that autocommands in buf_freeall() don't get confused.\n    is_curbuf = (buf == curbuf);\n    buf->b_nwindows = nwindows;\n\n    buf_freeall(buf, (del_buf ? BFA_DEL : 0)\n\t\t   + (wipe_buf ? BFA_WIPE : 0)\n\t\t   + (ignore_abort ? BFA_IGNORE_ABORT : 0));\n\n    // Autocommands may have deleted the buffer.\n    if (!bufref_valid(&bufref))\n\treturn FALSE;\n#ifdef FEAT_EVAL\n    // autocmds may abort script processing\n    if (!ignore_abort && aborting())\n\treturn FALSE;\n#endif\n\n    // It's possible that autocommands change curbuf to the one being deleted.\n    // This might cause the previous curbuf to be deleted unexpectedly.  But\n    // in some cases it's OK to delete the curbuf, because a new one is\n    // obtained anyway.  Therefore only return if curbuf changed to the\n    // deleted buffer.\n    if (buf == curbuf && !is_curbuf)\n\treturn FALSE;\n\n    if (win_valid_any_tab(win) && win->w_buffer == buf)\n\twin->w_buffer = NULL;  // make sure we don't use the buffer now\n\n    // Autocommands may have opened or closed windows for this buffer.\n    // Decrement the count for the close we do here.\n    if (buf->b_nwindows > 0)\n\t--buf->b_nwindows;\n\n    /*\n     * Remove the buffer from the list.\n     */\n    if (wipe_buf)\n    {\n\t// Do not wipe out the buffer if it is used in a window.\n\tif (buf->b_nwindows > 0)\n\t    return FALSE;\n\n\tif (action == DOBUF_WIPE_REUSE)\n\t{\n\t    // we can re-use this buffer number, store it\n\t    if (buf_reuse.ga_itemsize == 0)\n\t\tga_init2(&buf_reuse, sizeof(int), 50);\n\t    if (ga_grow(&buf_reuse, 1) == OK)\n\t\t((int *)buf_reuse.ga_data)[buf_reuse.ga_len++] = buf->b_fnum;\n\t}\n\tif (buf->b_sfname != buf->b_ffname)\n\t    VIM_CLEAR(buf->b_sfname);\n\telse\n\t    buf->b_sfname = NULL;\n\tVIM_CLEAR(buf->b_ffname);\n\tif (buf->b_prev == NULL)\n\t    firstbuf = buf->b_next;\n\telse\n\t    buf->b_prev->b_next = buf->b_next;\n\tif (buf->b_next == NULL)\n\t    lastbuf = buf->b_prev;\n\telse\n\t    buf->b_next->b_prev = buf->b_prev;\n\tfree_buffer(buf);\n    }\n    else\n    {\n\tif (del_buf)\n\t{\n\t    // Free all internal variables and reset option values, to make\n\t    // \":bdel\" compatible with Vim 5.7.\n\t    free_buffer_stuff(buf, TRUE);\n\n\t    // Make it look like a new buffer.\n\t    buf->b_flags = BF_CHECK_RO | BF_NEVERLOADED;\n\n\t    // Init the options when loaded again.\n\t    buf->b_p_initialized = FALSE;\n\t}\n\tbuf_clear_file(buf);\n\tif (del_buf)\n\t    buf->b_p_bl = FALSE;\n    }\n    // NOTE: at this point \"curbuf\" may be invalid!\n    return TRUE;\n}\n\n/*\n * Make buffer not contain a file.\n */\n    void\nbuf_clear_file(buf_T *buf)\n{\n    buf->b_ml.ml_line_count = 1;\n    unchanged(buf, TRUE, TRUE);\n    buf->b_shortname = FALSE;\n    buf->b_p_eol = TRUE;\n    buf->b_start_eol = TRUE;\n    buf->b_p_bomb = FALSE;\n    buf->b_start_bomb = FALSE;\n    buf->b_ml.ml_mfp = NULL;\n    buf->b_ml.ml_flags = ML_EMPTY;\t\t// empty buffer\n#ifdef FEAT_NETBEANS_INTG\n    netbeans_deleted_all_lines(buf);\n#endif\n}\n\n/*\n * buf_freeall() - free all things allocated for a buffer that are related to\n * the file.  Careful: get here with \"curwin\" NULL when exiting.\n * flags:\n * BFA_DEL\t     buffer is going to be deleted\n * BFA_WIPE\t     buffer is going to be wiped out\n * BFA_KEEP_UNDO     do not free undo information\n * BFA_IGNORE_ABORT  don't abort even when aborting() returns TRUE\n */\n    void\nbuf_freeall(buf_T *buf, int flags)\n{\n    int\t\tis_curbuf = (buf == curbuf);\n    bufref_T\tbufref;\n    int\t\tis_curwin = (curwin != NULL && curwin->w_buffer == buf);\n    win_T\t*the_curwin = curwin;\n    tabpage_T\t*the_curtab = curtab;\n\n    // Make sure the buffer isn't closed by autocommands.\n    ++buf->b_locked;\n    ++buf->b_locked_split;\n    set_bufref(&bufref, buf);\n    if (buf->b_ml.ml_mfp != NULL)\n    {\n\tif (apply_autocmds(EVENT_BUFUNLOAD, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t  FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t    // autocommands deleted the buffer\n\t    return;\n    }\n    if ((flags & BFA_DEL) && buf->b_p_bl)\n    {\n\tif (apply_autocmds(EVENT_BUFDELETE, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t   FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t    // autocommands deleted the buffer\n\t    return;\n    }\n    if (flags & BFA_WIPE)\n    {\n\tif (apply_autocmds(EVENT_BUFWIPEOUT, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t  FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t    // autocommands deleted the buffer\n\t    return;\n    }\n    --buf->b_locked;\n    --buf->b_locked_split;\n\n    // If the buffer was in curwin and the window has changed, go back to that\n    // window, if it still exists.  This avoids that \":edit x\" triggering a\n    // \"tabnext\" BufUnload autocmd leaves a window behind without a buffer.\n    if (is_curwin && curwin != the_curwin &&  win_valid_any_tab(the_curwin))\n    {\n\tblock_autocmds();\n\tgoto_tabpage_win(the_curtab, the_curwin);\n\tunblock_autocmds();\n    }\n\n#ifdef FEAT_EVAL\n    // autocmds may abort script processing\n    if ((flags & BFA_IGNORE_ABORT) == 0 && aborting())\n\treturn;\n#endif\n\n    // It's possible that autocommands change curbuf to the one being deleted.\n    // This might cause curbuf to be deleted unexpectedly.  But in some cases\n    // it's OK to delete the curbuf, because a new one is obtained anyway.\n    // Therefore only return if curbuf changed to the deleted buffer.\n    if (buf == curbuf && !is_curbuf)\n\treturn;\n#ifdef FEAT_DIFF\n    diff_buf_delete(buf);\t    // Can't use 'diff' for unloaded buffer.\n#endif\n#ifdef FEAT_SYN_HL\n    // Remove any ownsyntax, unless exiting.\n    if (curwin != NULL && curwin->w_buffer == buf)\n\treset_synblock(curwin);\n#endif\n\n#ifdef FEAT_FOLDING\n    // No folds in an empty buffer.\n    {\n\twin_T\t\t*win;\n\ttabpage_T\t*tp;\n\n\tFOR_ALL_TAB_WINDOWS(tp, win)\n\t    if (win->w_buffer == buf)\n\t\tclearFolding(win);\n    }\n#endif\n\n#ifdef FEAT_TCL\n    tcl_buffer_free(buf);\n#endif\n    ml_close(buf, TRUE);\t    // close and delete the memline/memfile\n    buf->b_ml.ml_line_count = 0;    // no lines in buffer\n    if ((flags & BFA_KEEP_UNDO) == 0)\n    {\n\tu_blockfree(buf);\t    // free the memory allocated for undo\n\tu_clearall(buf);\t    // reset all undo information\n    }\n#ifdef FEAT_SYN_HL\n    syntax_clear(&buf->b_s);\t    // reset syntax info\n#endif\n#ifdef FEAT_PROP_POPUP\n    clear_buf_prop_types(buf);\n#endif\n    buf->b_flags &= ~BF_READERR;    // a read error is no longer relevant\n}\n\n/*\n * Free a buffer structure and the things it contains related to the buffer\n * itself (not the file, that must have been done already).\n */\n    static void\nfree_buffer(buf_T *buf)\n{\n    ++buf_free_count;\n    free_buffer_stuff(buf, TRUE);\n#ifdef FEAT_EVAL\n    // b:changedtick uses an item in buf_T, remove it now\n    dictitem_remove(buf->b_vars, (dictitem_T *)&buf->b_ct_di);\n    unref_var_dict(buf->b_vars);\n    remove_listeners(buf);\n#endif\n#ifdef FEAT_LUA\n    lua_buffer_free(buf);\n#endif\n#ifdef FEAT_MZSCHEME\n    mzscheme_buffer_free(buf);\n#endif\n#ifdef FEAT_PERL\n    perl_buf_free(buf);\n#endif\n#ifdef FEAT_PYTHON\n    python_buffer_free(buf);\n#endif\n#ifdef FEAT_PYTHON3\n    python3_buffer_free(buf);\n#endif\n#ifdef FEAT_RUBY\n    ruby_buffer_free(buf);\n#endif\n#ifdef FEAT_JOB_CHANNEL\n    channel_buffer_free(buf);\n#endif\n#ifdef FEAT_TERMINAL\n    free_terminal(buf);\n#endif\n#ifdef FEAT_JOB_CHANNEL\n    vim_free(buf->b_prompt_text);\n    free_callback(&buf->b_prompt_callback);\n    free_callback(&buf->b_prompt_interrupt);\n#endif\n\n    buf_hashtab_remove(buf);\n\n    aubuflocal_remove(buf);\n\n    if (autocmd_busy)\n    {\n\t// Do not free the buffer structure while autocommands are executing,\n\t// it's still needed. Free it when autocmd_busy is reset.\n\tbuf->b_next = au_pending_free_buf;\n\tau_pending_free_buf = buf;\n    }\n    else\n    {\n\tvim_free(buf);\n\tif (curbuf == buf)\n\t    curbuf = NULL;  // make clear it's not to be used\n    }\n}\n\n/*\n * Initializes b:changedtick.\n */\n    static void\ninit_changedtick(buf_T *buf)\n{\n    dictitem_T *di = (dictitem_T *)&buf->b_ct_di;\n\n    di->di_flags = DI_FLAGS_FIX | DI_FLAGS_RO;\n    di->di_tv.v_type = VAR_NUMBER;\n    di->di_tv.v_lock = VAR_FIXED;\n    di->di_tv.vval.v_number = 0;\n\n#ifdef FEAT_EVAL\n    STRCPY(buf->b_ct_di.di_key, \"changedtick\");\n    (void)dict_add(buf->b_vars, di);\n#endif\n}\n\n/*\n * Free stuff in the buffer for \":bdel\" and when wiping out the buffer.\n */\n    static void\nfree_buffer_stuff(\n    buf_T\t*buf,\n    int\t\tfree_options)\t\t// free options as well\n{\n    if (free_options)\n    {\n\tclear_wininfo(buf);\t\t// including window-local options\n\tfree_buf_options(buf, TRUE);\n#ifdef FEAT_SPELL\n\tga_clear(&buf->b_s.b_langp);\n#endif\n    }\n#ifdef FEAT_EVAL\n    {\n\tvarnumber_T tick = CHANGEDTICK(buf);\n\n\tvars_clear(&buf->b_vars->dv_hashtab); // free all buffer variables\n\thash_init(&buf->b_vars->dv_hashtab);\n\tinit_changedtick(buf);\n\tCHANGEDTICK(buf) = tick;\n\tremove_listeners(buf);\n    }\n#endif\n    uc_clear(&buf->b_ucmds);\t\t// clear local user commands\n#ifdef FEAT_SIGNS\n    buf_delete_signs(buf, (char_u *)\"*\");\t// delete any signs\n#endif\n#ifdef FEAT_NETBEANS_INTG\n    netbeans_file_killed(buf);\n#endif\n    map_clear_int(buf, MAP_ALL_MODES, TRUE, FALSE);  // clear local mappings\n    map_clear_int(buf, MAP_ALL_MODES, TRUE, TRUE);   // clear local abbrevs\n    VIM_CLEAR(buf->b_start_fenc);\n}\n\n/*\n * Free one wininfo_T.\n */\n    void\nfree_wininfo(wininfo_T *wip)\n{\n    if (wip->wi_optset)\n    {\n\tclear_winopt(&wip->wi_opt);\n#ifdef FEAT_FOLDING\n\tdeleteFoldRecurse(&wip->wi_folds);\n#endif\n    }\n    vim_free(wip);\n}\n\n/*\n * Free the b_wininfo list for buffer \"buf\".\n */\n    static void\nclear_wininfo(buf_T *buf)\n{\n    wininfo_T\t*wip;\n\n    while (buf->b_wininfo != NULL)\n    {\n\twip = buf->b_wininfo;\n\tbuf->b_wininfo = wip->wi_next;\n\tfree_wininfo(wip);\n    }\n}\n\n/*\n * Go to another buffer.  Handles the result of the ATTENTION dialog.\n */\n    void\ngoto_buffer(\n    exarg_T\t*eap,\n    int\t\tstart,\n    int\t\tdir,\n    int\t\tcount)\n{\n    bufref_T\told_curbuf;\n    int\t\tsave_sea = swap_exists_action;\n\n    set_bufref(&old_curbuf, curbuf);\n\n    if (swap_exists_action == SEA_NONE)\n\tswap_exists_action = SEA_DIALOG;\n    (void)do_buffer(*eap->cmd == 's' ? DOBUF_SPLIT : DOBUF_GOTO,\n\t\t\t\t\t     start, dir, count, eap->forceit);\n    if (swap_exists_action == SEA_QUIT && *eap->cmd == 's')\n    {\n#if defined(FEAT_EVAL)\n\tcleanup_T   cs;\n\n\t// Reset the error/interrupt/exception state here so that\n\t// aborting() returns FALSE when closing a window.\n\tenter_cleanup(&cs);\n#endif\n\n\t// Quitting means closing the split window, nothing else.\n\twin_close(curwin, TRUE);\n\tswap_exists_action = save_sea;\n\tswap_exists_did_quit = TRUE;\n\n#if defined(FEAT_EVAL)\n\t// Restore the error/interrupt/exception state if not discarded by a\n\t// new aborting error, interrupt, or uncaught exception.\n\tleave_cleanup(&cs);\n#endif\n    }\n    else\n\thandle_swap_exists(&old_curbuf);\n}\n\n/*\n * Handle the situation of swap_exists_action being set.\n * It is allowed for \"old_curbuf\" to be NULL or invalid.\n */\n    void\nhandle_swap_exists(bufref_T *old_curbuf)\n{\n#if defined(FEAT_EVAL)\n    cleanup_T\tcs;\n#endif\n#ifdef FEAT_SYN_HL\n    long\told_tw = curbuf->b_p_tw;\n#endif\n    buf_T\t*buf;\n\n    if (swap_exists_action == SEA_QUIT)\n    {\n#if defined(FEAT_EVAL)\n\t// Reset the error/interrupt/exception state here so that\n\t// aborting() returns FALSE when closing a buffer.\n\tenter_cleanup(&cs);\n#endif\n\n\t// User selected Quit at ATTENTION prompt.  Go back to previous\n\t// buffer.  If that buffer is gone or the same as the current one,\n\t// open a new, empty buffer.\n\tswap_exists_action = SEA_NONE;\t// don't want it again\n\tswap_exists_did_quit = TRUE;\n\tclose_buffer(curwin, curbuf, DOBUF_UNLOAD, FALSE, FALSE);\n\tif (old_curbuf == NULL || !bufref_valid(old_curbuf)\n\t\t\t\t\t      || old_curbuf->br_buf == curbuf)\n\t{\n\t    // Block autocommands here because curwin->w_buffer is NULL.\n\t    block_autocmds();\n\t    buf = buflist_new(NULL, NULL, 1L, BLN_CURBUF | BLN_LISTED);\n\t    unblock_autocmds();\n\t}\n\telse\n\t    buf = old_curbuf->br_buf;\n\tif (buf != NULL)\n\t{\n\t    int old_msg_silent = msg_silent;\n\n\t    if (shortmess(SHM_FILEINFO))\n\t\tmsg_silent = 1;  // prevent fileinfo message\n\t    enter_buffer(buf);\n\t    // restore msg_silent, so that the command line will be shown\n\t    msg_silent = old_msg_silent;\n\n#ifdef FEAT_SYN_HL\n\t    if (old_tw != curbuf->b_p_tw)\n\t\tcheck_colorcolumn(curwin);\n#endif\n\t}\n\t// If \"old_curbuf\" is NULL we are in big trouble here...\n\n#if defined(FEAT_EVAL)\n\t// Restore the error/interrupt/exception state if not discarded by a\n\t// new aborting error, interrupt, or uncaught exception.\n\tleave_cleanup(&cs);\n#endif\n    }\n    else if (swap_exists_action == SEA_RECOVER)\n    {\n#if defined(FEAT_EVAL)\n\t// Reset the error/interrupt/exception state here so that\n\t// aborting() returns FALSE when closing a buffer.\n\tenter_cleanup(&cs);\n#endif\n\n\t// User selected Recover at ATTENTION prompt.\n\tmsg_scroll = TRUE;\n\tml_recover(FALSE);\n\tmsg_puts(\"\\n\");\t// don't overwrite the last message\n\tcmdline_row = msg_row;\n\tdo_modelines(0);\n\n#if defined(FEAT_EVAL)\n\t// Restore the error/interrupt/exception state if not discarded by a\n\t// new aborting error, interrupt, or uncaught exception.\n\tleave_cleanup(&cs);\n#endif\n    }\n    swap_exists_action = SEA_NONE;\n}\n\n/*\n * Make the current buffer empty.\n * Used when it is wiped out and it's the last buffer.\n */\n    static int\nempty_curbuf(\n    int close_others,\n    int forceit,\n    int action)\n{\n    int\t    retval;\n    buf_T   *buf = curbuf;\n    bufref_T bufref;\n\n    if (action == DOBUF_UNLOAD)\n    {\n\temsg(_(e_cannot_unload_last_buffer));\n\treturn FAIL;\n    }\n\n    set_bufref(&bufref, buf);\n    if (close_others)\n\t// Close any other windows on this buffer, then make it empty.\n\tclose_windows(buf, TRUE);\n\n    setpcmark();\n    retval = do_ecmd(0, NULL, NULL, NULL, ECMD_ONE,\n\t\t\t\t\t  forceit ? ECMD_FORCEIT : 0, curwin);\n\n    // do_ecmd() may create a new buffer, then we have to delete\n    // the old one.  But do_ecmd() may have done that already, check\n    // if the buffer still exists.\n    if (buf != curbuf && bufref_valid(&bufref) && buf->b_nwindows == 0)\n\tclose_buffer(NULL, buf, action, FALSE, FALSE);\n    if (!close_others)\n\tneed_fileinfo = FALSE;\n    return retval;\n}\n\n/*\n * Implementation of the commands for the buffer list.\n *\n * action == DOBUF_GOTO\t    go to specified buffer\n * action == DOBUF_SPLIT    split window and go to specified buffer\n * action == DOBUF_UNLOAD   unload specified buffer(s)\n * action == DOBUF_DEL\t    delete specified buffer(s) from buffer list\n * action == DOBUF_WIPE\t    delete specified buffer(s) really\n * action == DOBUF_WIPE_REUSE idem, and add number to \"buf_reuse\"\n *\n * start == DOBUF_CURRENT   go to \"count\" buffer from current buffer\n * start == DOBUF_FIRST\t    go to \"count\" buffer from first buffer\n * start == DOBUF_LAST\t    go to \"count\" buffer from last buffer\n * start == DOBUF_MOD\t    go to \"count\" modified buffer from current buffer\n *\n * Return FAIL or OK.\n */\n    static int\ndo_buffer_ext(\n    int\t\taction,\n    int\t\tstart,\n    int\t\tdir,\t\t// FORWARD or BACKWARD\n    int\t\tcount,\t\t// buffer number or number of buffers\n    int\t\tflags)\t\t// DOBUF_FORCEIT etc.\n{\n    buf_T\t*buf;\n    buf_T\t*bp;\n    int\t\tunload = (action == DOBUF_UNLOAD || action == DOBUF_DEL\n\t\t\t|| action == DOBUF_WIPE || action == DOBUF_WIPE_REUSE);\n\n    switch (start)\n    {\n\tcase DOBUF_FIRST:   buf = firstbuf; break;\n\tcase DOBUF_LAST:    buf = lastbuf;  break;\n\tdefault:\t    buf = curbuf;   break;\n    }\n    if (start == DOBUF_MOD)\t    // find next modified buffer\n    {\n\twhile (count-- > 0)\n\t{\n\t    do\n\t    {\n\t\tbuf = buf->b_next;\n\t\tif (buf == NULL)\n\t\t    buf = firstbuf;\n\t    }\n\t    while (buf != curbuf && !bufIsChanged(buf));\n\t}\n\tif (!bufIsChanged(buf))\n\t{\n\t    emsg(_(e_no_modified_buffer_found));\n\t    return FAIL;\n\t}\n    }\n    else if (start == DOBUF_FIRST && count) // find specified buffer number\n    {\n\twhile (buf != NULL && buf->b_fnum != count)\n\t    buf = buf->b_next;\n    }\n    else\n    {\n\tbp = NULL;\n\twhile (count > 0 || (!unload && !buf->b_p_bl && bp != buf))\n\t{\n\t    // remember the buffer where we start, we come back there when all\n\t    // buffers are unlisted.\n\t    if (bp == NULL)\n\t\tbp = buf;\n\t    if (dir == FORWARD)\n\t    {\n\t\tbuf = buf->b_next;\n\t\tif (buf == NULL)\n\t\t    buf = firstbuf;\n\t    }\n\t    else\n\t    {\n\t\tbuf = buf->b_prev;\n\t\tif (buf == NULL)\n\t\t    buf = lastbuf;\n\t    }\n\t    // don't count unlisted buffers\n\t    if (unload || buf->b_p_bl)\n\t    {\n\t\t --count;\n\t\t bp = NULL;\t// use this buffer as new starting point\n\t    }\n\t    if (bp == buf)\n\t    {\n\t\t// back where we started, didn't find anything.\n\t\temsg(_(e_there_is_no_listed_buffer));\n\t\treturn FAIL;\n\t    }\n\t}\n    }\n\n    if (buf == NULL)\t    // could not find it\n    {\n\tif (start == DOBUF_FIRST)\n\t{\n\t    // don't warn when deleting\n\t    if (!unload)\n\t\tsemsg(_(e_buffer_nr_does_not_exist), count);\n\t}\n\telse if (dir == FORWARD)\n\t    emsg(_(e_cannot_go_beyond_last_buffer));\n\telse\n\t    emsg(_(e_cannot_go_before_first_buffer));\n\treturn FAIL;\n    }\n#ifdef FEAT_PROP_POPUP\n    if ((flags & DOBUF_NOPOPUP) && bt_popup(buf)\n# ifdef FEAT_TERMINAL\n\t\t\t\t&& !bt_terminal(buf)\n#endif\n       )\n\treturn OK;\n#endif\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * delete buffer \"buf\" from memory and/or the list\n     */\n    if (unload)\n    {\n\tint\tforward;\n\tbufref_T bufref;\n\n\tif (!can_unload_buffer(buf))\n\t    return FAIL;\n\n\tset_bufref(&bufref, buf);\n\n\t// When unloading or deleting a buffer that's already unloaded and\n\t// unlisted: fail silently.\n\tif (action != DOBUF_WIPE && action != DOBUF_WIPE_REUSE\n\t\t\t\t   && buf->b_ml.ml_mfp == NULL && !buf->b_p_bl)\n\t    return FAIL;\n\n\tif ((flags & DOBUF_FORCEIT) == 0 && bufIsChanged(buf))\n\t{\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t    if ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t    {\n\t\tdialog_changed(buf, FALSE);\n\t\tif (!bufref_valid(&bufref))\n\t\t    // Autocommand deleted buffer, oops!  It's not changed\n\t\t    // now.\n\t\t    return FAIL;\n\t\t// If it's still changed fail silently, the dialog already\n\t\t// mentioned why it fails.\n\t\tif (bufIsChanged(buf))\n\t\t    return FAIL;\n\t    }\n\t    else\n#endif\n\t    {\n\t\tsemsg(_(e_no_write_since_last_change_for_buffer_nr_add_bang_to_override),\n\t\t\t\t\t\t\t\t buf->b_fnum);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t// When closing the current buffer stop Visual mode.\n\tif (buf == curbuf && VIsual_active)\n\t    end_visual_mode();\n\n\t// If deleting the last (listed) buffer, make it empty.\n\t// The last (listed) buffer cannot be unloaded.\n\tFOR_ALL_BUFFERS(bp)\n\t    if (bp->b_p_bl && bp != buf)\n\t\tbreak;\n\tif (bp == NULL && buf == curbuf)\n\t    return empty_curbuf(TRUE, (flags & DOBUF_FORCEIT), action);\n\n\t// If the deleted buffer is the current one, close the current window\n\t// (unless it's the only window).  Repeat this so long as we end up in\n\t// a window with this buffer.\n\twhile (buf == curbuf\n\t\t   && !(curwin->w_closing || curwin->w_buffer->b_locked > 0)\n\t\t   && (!ONE_WINDOW || first_tabpage->tp_next != NULL))\n\t{\n\t    if (win_close(curwin, FALSE) == FAIL)\n\t\tbreak;\n\t}\n\n\t// If the buffer to be deleted is not the current one, delete it here.\n\tif (buf != curbuf)\n\t{\n\t    close_windows(buf, FALSE);\n\t    if (buf != curbuf && bufref_valid(&bufref) && buf->b_nwindows <= 0)\n\t\t    close_buffer(NULL, buf, action, FALSE, FALSE);\n\t    return OK;\n\t}\n\n\t/*\n\t * Deleting the current buffer: Need to find another buffer to go to.\n\t * There should be another, otherwise it would have been handled\n\t * above.  However, autocommands may have deleted all buffers.\n\t * First use au_new_curbuf.br_buf, if it is valid.\n\t * Then prefer the buffer we most recently visited.\n\t * Else try to find one that is loaded, after the current buffer,\n\t * then before the current buffer.\n\t * Finally use any buffer.\n\t */\n\tbuf = NULL;\t// selected buffer\n\tbp = NULL;\t// used when no loaded buffer found\n\tif (au_new_curbuf.br_buf != NULL && bufref_valid(&au_new_curbuf))\n\t    buf = au_new_curbuf.br_buf;\n\telse if (curwin->w_jumplistlen > 0)\n\t{\n\t    int     jumpidx;\n\n\t    jumpidx = curwin->w_jumplistidx - 1;\n\t    if (jumpidx < 0)\n\t\tjumpidx = curwin->w_jumplistlen - 1;\n\n\t    forward = jumpidx;\n\t    while (jumpidx != curwin->w_jumplistidx)\n\t    {\n\t\tbuf = buflist_findnr(curwin->w_jumplist[jumpidx].fmark.fnum);\n\t\tif (buf != NULL)\n\t\t{\n\t\t    // Skip current and unlisted bufs.  Also skip a quickfix\n\t\t    // buffer, it might be deleted soon.\n\t\t    if (buf == curbuf || !buf->b_p_bl\n#if defined(FEAT_QUICKFIX)\n\t\t\t    || bt_quickfix(buf)\n#endif\n\t\t\t    )\n\t\t\tbuf = NULL;\n\t\t    else if (buf->b_ml.ml_mfp == NULL)\n\t\t    {\n\t\t\t// skip unloaded buf, but may keep it for later\n\t\t\tif (bp == NULL)\n\t\t\t    bp = buf;\n\t\t\tbuf = NULL;\n\t\t    }\n\t\t}\n\t\tif (buf != NULL)   // found a valid buffer: stop searching\n\t\t    break;\n\t\t// advance to older entry in jump list\n\t\tif (!jumpidx && curwin->w_jumplistidx == curwin->w_jumplistlen)\n\t\t    break;\n\t\tif (--jumpidx < 0)\n\t\t    jumpidx = curwin->w_jumplistlen - 1;\n\t\tif (jumpidx == forward)\t\t// List exhausted for sure\n\t\t    break;\n\t    }\n\t}\n\n\tif (buf == NULL)\t// No previous buffer, Try 2'nd approach\n\t{\n\t    forward = TRUE;\n\t    buf = curbuf->b_next;\n\t    for (;;)\n\t    {\n\t\tif (buf == NULL)\n\t\t{\n\t\t    if (!forward)\t// tried both directions\n\t\t\tbreak;\n\t\t    buf = curbuf->b_prev;\n\t\t    forward = FALSE;\n\t\t    continue;\n\t\t}\n\t\t// in non-help buffer, try to skip help buffers, and vv\n\t\tif (buf->b_help == curbuf->b_help && buf->b_p_bl\n#if defined(FEAT_QUICKFIX)\n\t\t\t    && !bt_quickfix(buf)\n#endif\n\t\t\t   )\n\t\t{\n\t\t    if (buf->b_ml.ml_mfp != NULL)   // found loaded buffer\n\t\t\tbreak;\n\t\t    if (bp == NULL)\t// remember unloaded buf for later\n\t\t\tbp = buf;\n\t\t}\n\t\tif (forward)\n\t\t    buf = buf->b_next;\n\t\telse\n\t\t    buf = buf->b_prev;\n\t    }\n\t}\n\tif (buf == NULL)\t// No loaded buffer, use unloaded one\n\t    buf = bp;\n\tif (buf == NULL)\t// No loaded buffer, find listed one\n\t{\n\t    FOR_ALL_BUFFERS(buf)\n\t\tif (buf->b_p_bl && buf != curbuf\n#if defined(FEAT_QUICKFIX)\n\t\t\t    && !bt_quickfix(buf)\n#endif\n\t\t       )\n\t\t    break;\n\t}\n\tif (buf == NULL)\t// Still no buffer, just take one\n\t{\n\t    if (curbuf->b_next != NULL)\n\t\tbuf = curbuf->b_next;\n\t    else\n\t\tbuf = curbuf->b_prev;\n#if defined(FEAT_QUICKFIX)\n\t    if (bt_quickfix(buf))\n\t\tbuf = NULL;\n#endif\n\t}\n    }\n\n    if (buf == NULL)\n    {\n\t// Autocommands must have wiped out all other buffers.  Only option\n\t// now is to make the current buffer empty.\n\treturn empty_curbuf(FALSE, (flags & DOBUF_FORCEIT), action);\n    }\n\n    /*\n     * make \"buf\" the current buffer\n     */\n    if (action == DOBUF_SPLIT)\t    // split window first\n    {\n\t// If 'switchbuf' contains \"useopen\": jump to first window containing\n\t// \"buf\" if one exists\n\tif ((swb_flags & SWB_USEOPEN) && buf_jump_open_win(buf))\n\t    return OK;\n\t// If 'switchbuf' contains \"usetab\": jump to first window in any tab\n\t// page containing \"buf\" if one exists\n\tif ((swb_flags & SWB_USETAB) && buf_jump_open_tab(buf))\n\t    return OK;\n\tif (win_split(0, 0) == FAIL)\n\t    return FAIL;\n    }\n\n    // go to current buffer - nothing to do\n    if (buf == curbuf)\n\treturn OK;\n\n    // Check if the current buffer may be abandoned.\n    if (action == DOBUF_GOTO && !can_abandon(curbuf, (flags & DOBUF_FORCEIT)))\n    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\tif ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t{\n\t    bufref_T bufref;\n\n\t    set_bufref(&bufref, buf);\n\t    dialog_changed(curbuf, FALSE);\n\t    if (!bufref_valid(&bufref))\n\t\t// Autocommand deleted buffer, oops!\n\t\treturn FAIL;\n\t}\n\tif (bufIsChanged(curbuf))\n#endif\n\t{\n\t    no_write_message();\n\t    return FAIL;\n\t}\n    }\n\n    // Go to the other buffer.\n    set_curbuf(buf, action);\n\n    if (action == DOBUF_SPLIT)\n\tRESET_BINDING(curwin);\t// reset 'scrollbind' and 'cursorbind'\n\n#if defined(FEAT_EVAL)\n    if (aborting())\t    // autocmds may abort script processing\n\treturn FAIL;\n#endif\n\n    return OK;\n}\n\n    int\ndo_buffer(\n    int\t\taction,\n    int\t\tstart,\n    int\t\tdir,\t\t// FORWARD or BACKWARD\n    int\t\tcount,\t\t// buffer number or number of buffers\n    int\t\tforceit)\t// TRUE when using !\n{\n    return do_buffer_ext(action, start, dir, count,\n\t\t\t\t\t\t  forceit ? DOBUF_FORCEIT : 0);\n}\n\n/*\n * do_bufdel() - delete or unload buffer(s)\n *\n * addr_count == 0: \":bdel\" - delete current buffer\n * addr_count == 1: \":N bdel\" or \":bdel N [N ..]\" - first delete\n *\t\t    buffer \"end_bnr\", then any other arguments.\n * addr_count == 2: \":N,N bdel\" - delete buffers in range\n *\n * command can be DOBUF_UNLOAD (\":bunload\"), DOBUF_WIPE (\":bwipeout\") or\n * DOBUF_DEL (\":bdel\")\n *\n * Returns error message or NULL\n */\n    char *\ndo_bufdel(\n    int\t\tcommand,\n    char_u\t*arg,\t\t// pointer to extra arguments\n    int\t\taddr_count,\n    int\t\tstart_bnr,\t// first buffer number in a range\n    int\t\tend_bnr,\t// buffer nr or last buffer nr in a range\n    int\t\tforceit)\n{\n    int\t\tdo_current = 0;\t// delete current buffer?\n    int\t\tdeleted = 0;\t// number of buffers deleted\n    char\t*errormsg = NULL; // return value\n    int\t\tbnr;\t\t// buffer number\n    char_u\t*p;\n\n    if (addr_count == 0)\n    {\n\t(void)do_buffer(command, DOBUF_CURRENT, FORWARD, 0, forceit);\n    }\n    else\n    {\n\tif (addr_count == 2)\n\t{\n\t    if (*arg)\t\t// both range and argument is not allowed\n\t\treturn ex_errmsg(e_trailing_characters_str, arg);\n\t    bnr = start_bnr;\n\t}\n\telse\t// addr_count == 1\n\t    bnr = end_bnr;\n\n\tfor ( ;!got_int; ui_breakcheck())\n\t{\n\t    // Delete the current buffer last, otherwise when the\n\t    // current buffer is deleted, the next buffer becomes\n\t    // the current one and will be loaded, which may then\n\t    // also be deleted, etc.\n\t    if (bnr == curbuf->b_fnum)\n\t\tdo_current = bnr;\n\t    else if (do_buffer_ext(command, DOBUF_FIRST, FORWARD, bnr,\n\t\t\t  DOBUF_NOPOPUP | (forceit ? DOBUF_FORCEIT : 0)) == OK)\n\t\t++deleted;\n\n\t    // find next buffer number to delete/unload\n\t    if (addr_count == 2)\n\t    {\n\t\tif (++bnr > end_bnr)\n\t\t    break;\n\t    }\n\t    else    // addr_count == 1\n\t    {\n\t\targ = skipwhite(arg);\n\t\tif (*arg == NUL)\n\t\t    break;\n\t\tif (!VIM_ISDIGIT(*arg))\n\t\t{\n\t\t    p = skiptowhite_esc(arg);\n\t\t    bnr = buflist_findpat(arg, p,\n\t\t\t  command == DOBUF_WIPE || command == DOBUF_WIPE_REUSE,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\t\t    if (bnr < 0)\t    // failed\n\t\t\tbreak;\n\t\t    arg = p;\n\t\t}\n\t\telse\n\t\t    bnr = getdigits(&arg);\n\t    }\n\t}\n\tif (!got_int && do_current && do_buffer(command, DOBUF_FIRST,\n\t\t\t\t\t  FORWARD, do_current, forceit) == OK)\n\t    ++deleted;\n\n\tif (deleted == 0)\n\t{\n\t    if (command == DOBUF_UNLOAD)\n\t\tSTRCPY(IObuff, _(e_no_buffers_were_unloaded));\n\t    else if (command == DOBUF_DEL)\n\t\tSTRCPY(IObuff, _(e_no_buffers_were_deleted));\n\t    else\n\t\tSTRCPY(IObuff, _(e_no_buffers_were_wiped_out));\n\t    errormsg = (char *)IObuff;\n\t}\n\telse if (deleted >= p_report)\n\t{\n\t    if (command == DOBUF_UNLOAD)\n\t\tsmsg(NGETTEXT(\"%d buffer unloaded\",\n\t\t\t    \"%d buffers unloaded\", deleted), deleted);\n\t    else if (command == DOBUF_DEL)\n\t\tsmsg(NGETTEXT(\"%d buffer deleted\",\n\t\t\t    \"%d buffers deleted\", deleted), deleted);\n\t    else\n\t\tsmsg(NGETTEXT(\"%d buffer wiped out\",\n\t\t\t    \"%d buffers wiped out\", deleted), deleted);\n\t}\n    }\n\n\n    return errormsg;\n}\n\n/*\n * Set current buffer to \"buf\".  Executes autocommands and closes current\n * buffer.  \"action\" tells how to close the current buffer:\n * DOBUF_GOTO\t    free or hide it\n * DOBUF_SPLIT\t    nothing\n * DOBUF_UNLOAD\t    unload it\n * DOBUF_DEL\t    delete it\n * DOBUF_WIPE\t    wipe it out\n * DOBUF_WIPE_REUSE wipe it out and add to \"buf_reuse\"\n */\n    void\nset_curbuf(buf_T *buf, int action)\n{\n    buf_T\t*prevbuf;\n    int\t\tunload = (action == DOBUF_UNLOAD || action == DOBUF_DEL\n\t\t\t|| action == DOBUF_WIPE || action == DOBUF_WIPE_REUSE);\n#ifdef FEAT_SYN_HL\n    long\told_tw = curbuf->b_p_tw;\n#endif\n    bufref_T\tnewbufref;\n    bufref_T\tprevbufref;\n    int\t\tvalid;\n\n    setpcmark();\n    if ((cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\tcurwin->w_alt_fnum = curbuf->b_fnum; // remember alternate file\n    buflist_altfpos(curwin);\t\t\t // remember curpos\n\n    // Don't restart Select mode after switching to another buffer.\n    VIsual_reselect = FALSE;\n\n    // close_windows() or apply_autocmds() may change curbuf and wipe out \"buf\"\n    prevbuf = curbuf;\n    set_bufref(&prevbufref, prevbuf);\n    set_bufref(&newbufref, buf);\n\n    // Autocommands may delete the current buffer and/or the buffer we want to\n    // go to.  In those cases don't close the buffer.\n    if (!apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf)\n\t    || (bufref_valid(&prevbufref)\n\t\t&& bufref_valid(&newbufref)\n#ifdef FEAT_EVAL\n\t\t&& !aborting()\n#endif\n\t       ))\n    {\n#ifdef FEAT_SYN_HL\n\tif (prevbuf == curwin->w_buffer)\n\t    reset_synblock(curwin);\n#endif\n\tif (unload)\n\t    close_windows(prevbuf, FALSE);\n#if defined(FEAT_EVAL)\n\tif (bufref_valid(&prevbufref) && !aborting())\n#else\n\tif (bufref_valid(&prevbufref))\n#endif\n\t{\n\t    win_T  *previouswin = curwin;\n\n\t    // Do not sync when in Insert mode and the buffer is open in\n\t    // another window, might be a timer doing something in another\n\t    // window.\n\t    if (prevbuf == curbuf\n\t\t    && ((State & MODE_INSERT) == 0 || curbuf->b_nwindows <= 1))\n\t\tu_sync(FALSE);\n\t    close_buffer(prevbuf == curwin->w_buffer ? curwin : NULL, prevbuf,\n\t\t    unload ? action : (action == DOBUF_GOTO\n\t\t\t&& !buf_hide(prevbuf)\n\t\t\t&& !bufIsChanged(prevbuf)) ? DOBUF_UNLOAD : 0,\n\t\t    FALSE, FALSE);\n\t    if (curwin != previouswin && win_valid(previouswin))\n\t      // autocommands changed curwin, Grr!\n\t      curwin = previouswin;\n\t}\n    }\n    // An autocommand may have deleted \"buf\", already entered it (e.g., when\n    // it did \":bunload\") or aborted the script processing.\n    // If curwin->w_buffer is null, enter_buffer() will make it valid again\n    valid = buf_valid(buf);\n    if ((valid && buf != curbuf\n#ifdef FEAT_EVAL\n\t\t&& !aborting()\n#endif\n\t) || curwin->w_buffer == NULL)\n    {\n\t// If the buffer is not valid but curwin->w_buffer is NULL we must\n\t// enter some buffer.  Using the last one is hopefully OK.\n\tif (!valid)\n\t    enter_buffer(lastbuf);\n\telse\n\t    enter_buffer(buf);\n#ifdef FEAT_SYN_HL\n\tif (old_tw != curbuf->b_p_tw)\n\t    check_colorcolumn(curwin);\n#endif\n    }\n}\n\n/*\n * Enter a new current buffer.\n * Old curbuf must have been abandoned already!  This also means \"curbuf\" may\n * be pointing to freed memory.\n */\n    static void\nenter_buffer(buf_T *buf)\n{\n    // Get the buffer in the current window.\n    curwin->w_buffer = buf;\n    curbuf = buf;\n    ++curbuf->b_nwindows;\n\n    // Copy buffer and window local option values.  Not for a help buffer.\n    buf_copy_options(buf, BCO_ENTER | BCO_NOHELP);\n    if (!buf->b_help)\n\tget_winopts(buf);\n#ifdef FEAT_FOLDING\n    else\n\t// Remove all folds in the window.\n\tclearFolding(curwin);\n    foldUpdateAll(curwin);\t// update folds (later).\n#endif\n\n#ifdef FEAT_DIFF\n    if (curwin->w_p_diff)\n\tdiff_buf_add(curbuf);\n#endif\n\n#ifdef FEAT_SYN_HL\n    curwin->w_s = &(curbuf->b_s);\n#endif\n\n    // Cursor on first line by default.\n    curwin->w_cursor.lnum = 1;\n    curwin->w_cursor.col = 0;\n    curwin->w_cursor.coladd = 0;\n    curwin->w_set_curswant = TRUE;\n    curwin->w_topline_was_set = FALSE;\n\n    // mark cursor position as being invalid\n    curwin->w_valid = 0;\n\n    buflist_setfpos(curbuf, curwin, curbuf->b_last_cursor.lnum,\n\t\t\t\t\t      curbuf->b_last_cursor.col, TRUE);\n\n    // Make sure the buffer is loaded.\n    if (curbuf->b_ml.ml_mfp == NULL)\t// need to load the file\n    {\n\t// If there is no filetype, allow for detecting one.  Esp. useful for\n\t// \":ball\" used in an autocommand.  If there already is a filetype we\n\t// might prefer to keep it.\n\tif (*curbuf->b_p_ft == NUL)\n\t    did_filetype = FALSE;\n\n\topen_buffer(FALSE, NULL, 0);\n    }\n    else\n    {\n\tif (!msg_silent && !shortmess(SHM_FILEINFO))\n\t    need_fileinfo = TRUE;\t// display file info after redraw\n\n\t// check if file changed\n\t(void)buf_check_timestamp(curbuf, FALSE);\n\n\tcurwin->w_topline = 1;\n#ifdef FEAT_DIFF\n\tcurwin->w_topfill = 0;\n#endif\n\tapply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_BUFWINENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    // If autocommands did not change the cursor position, restore cursor lnum\n    // and possibly cursor col.\n    if (curwin->w_cursor.lnum == 1 && inindent(0))\n\tbuflist_getfpos();\n\n    check_arg_idx(curwin);\t\t// check for valid arg_idx\n    maketitle();\n\t// when autocmds didn't change it\n    if (curwin->w_topline == 1 && !curwin->w_topline_was_set)\n\tscroll_cursor_halfway(FALSE);\t// redisplay at correct position\n\n#ifdef FEAT_NETBEANS_INTG\n    // Send fileOpened event because we've changed buffers.\n    netbeans_file_activated(curbuf);\n#endif\n\n    // Change directories when the 'acd' option is set.\n    DO_AUTOCHDIR;\n\n#ifdef FEAT_KEYMAP\n    if (curbuf->b_kmap_state & KEYMAP_INIT)\n\t(void)keymap_init();\n#endif\n#ifdef FEAT_SPELL\n    // May need to set the spell language.  Can only do this after the buffer\n    // has been properly setup.\n    if (!curbuf->b_help && curwin->w_p_spell && *curwin->w_s->b_p_spl != NUL)\n\t(void)did_set_spelllang(curwin);\n#endif\n#ifdef FEAT_VIMINFO\n    curbuf->b_last_used = vim_time();\n#endif\n\n    redraw_later(NOT_VALID);\n}\n\n#if defined(FEAT_AUTOCHDIR) || defined(PROTO)\n/*\n * Change to the directory of the current buffer.\n * Don't do this while still starting up.\n */\n    void\ndo_autochdir(void)\n{\n    if ((starting == 0 || test_autochdir)\n\t    && curbuf->b_ffname != NULL\n\t    && vim_chdirfile(curbuf->b_ffname, \"auto\") == OK)\n    {\n\tshorten_fnames(TRUE);\n\tlast_chdir_reason = \"autochdir\";\n    }\n}\n#endif\n\n    void\nno_write_message(void)\n{\n#ifdef FEAT_TERMINAL\n    if (term_job_running(curbuf->b_term))\n\temsg(_(e_job_still_running_add_bang_to_end_the_job));\n    else\n#endif\n\temsg(_(e_no_write_since_last_change_add_bang_to_override));\n}\n\n    void\nno_write_message_nobang(buf_T *buf UNUSED)\n{\n#ifdef FEAT_TERMINAL\n    if (term_job_running(buf->b_term))\n\temsg(_(e_job_still_running));\n    else\n#endif\n\temsg(_(e_no_write_since_last_change));\n}\n\n/*\n * functions for dealing with the buffer list\n */\n\n/*\n * Return TRUE if the current buffer is empty, unnamed, unmodified and used in\n * only one window.  That means it can be re-used.\n */\n    int\ncurbuf_reusable(void)\n{\n    return (curbuf != NULL\n\t&& curbuf->b_ffname == NULL\n\t&& curbuf->b_nwindows <= 1\n\t&& (curbuf->b_ml.ml_mfp == NULL || BUFEMPTY())\n#if defined(FEAT_QUICKFIX)\n\t&& !bt_quickfix(curbuf)\n#endif\n\t&& !curbufIsChanged());\n}\n\n/*\n * Add a file name to the buffer list.  Return a pointer to the buffer.\n * If the same file name already exists return a pointer to that buffer.\n * If it does not exist, or if fname == NULL, a new entry is created.\n * If (flags & BLN_CURBUF) is TRUE, may use current buffer.\n * If (flags & BLN_LISTED) is TRUE, add new buffer to buffer list.\n * If (flags & BLN_DUMMY) is TRUE, don't count it as a real buffer.\n * If (flags & BLN_NEW) is TRUE, don't use an existing buffer.\n * If (flags & BLN_NOOPT) is TRUE, don't copy options from the current buffer\n *\t\t\t\t    if the buffer already exists.\n * If (flags & BLN_REUSE) is TRUE, may use buffer number from \"buf_reuse\".\n * This is the ONLY way to create a new buffer.\n */\n    buf_T *\nbuflist_new(\n    char_u\t*ffname_arg,\t// full path of fname or relative\n    char_u\t*sfname_arg,\t// short fname or NULL\n    linenr_T\tlnum,\t\t// preferred cursor line\n    int\t\tflags)\t\t// BLN_ defines\n{\n    char_u\t*ffname = ffname_arg;\n    char_u\t*sfname = sfname_arg;\n    buf_T\t*buf;\n#ifdef UNIX\n    stat_T\tst;\n#endif\n\n    if (top_file_num == 1)\n\thash_init(&buf_hashtab);\n\n    fname_expand(curbuf, &ffname, &sfname);\t// will allocate ffname\n\n    /*\n     * If the file name already exists in the list, update the entry.\n     */\n#ifdef UNIX\n    // On Unix we can use inode numbers when the file exists.  Works better\n    // for hard links.\n    if (sfname == NULL || mch_stat((char *)sfname, &st) < 0)\n\tst.st_dev = (dev_T)-1;\n#endif\n    if (ffname != NULL && !(flags & (BLN_DUMMY | BLN_NEW)) && (buf =\n#ifdef UNIX\n\t\tbuflist_findname_stat(ffname, &st)\n#else\n\t\tbuflist_findname(ffname)\n#endif\n\t\t) != NULL)\n    {\n\tvim_free(ffname);\n\tif (lnum != 0)\n\t    buflist_setfpos(buf, (flags & BLN_NOCURWIN) ? NULL : curwin,\n\t\t\t\t\t\t      lnum, (colnr_T)0, FALSE);\n\n\tif ((flags & BLN_NOOPT) == 0)\n\t    // copy the options now, if 'cpo' doesn't have 's' and not done\n\t    // already\n\t    buf_copy_options(buf, 0);\n\n\tif ((flags & BLN_LISTED) && !buf->b_p_bl)\n\t{\n\t    bufref_T bufref;\n\n\t    buf->b_p_bl = TRUE;\n\t    set_bufref(&bufref, buf);\n\t    if (!(flags & BLN_DUMMY))\n\t    {\n\t\tif (apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, buf)\n\t\t\t&& !bufref_valid(&bufref))\n\t\t    return NULL;\n\t    }\n\t}\n\treturn buf;\n    }\n\n    /*\n     * If the current buffer has no name and no contents, use the current\n     * buffer.\tOtherwise: Need to allocate a new buffer structure.\n     *\n     * This is the ONLY place where a new buffer structure is allocated!\n     * (A spell file buffer is allocated in spell.c, but that's not a normal\n     * buffer.)\n     */\n    buf = NULL;\n    if ((flags & BLN_CURBUF) && curbuf_reusable())\n    {\n\tbuf = curbuf;\n\t// It's like this buffer is deleted.  Watch out for autocommands that\n\t// change curbuf!  If that happens, allocate a new buffer anyway.\n\tbuf_freeall(buf, BFA_WIPE | BFA_DEL);\n\tif (buf != curbuf)   // autocommands deleted the buffer!\n\t    return NULL;\n#ifdef FEAT_EVAL\n\tif (aborting())\t\t// autocmds may abort script processing\n\t{\n\t    vim_free(ffname);\n\t    return NULL;\n\t}\n#endif\n    }\n    if (buf != curbuf || curbuf == NULL)\n    {\n\tbuf = ALLOC_CLEAR_ONE(buf_T);\n\tif (buf == NULL)\n\t{\n\t    vim_free(ffname);\n\t    return NULL;\n\t}\n#ifdef FEAT_EVAL\n\t// init b: variables\n\tbuf->b_vars = dict_alloc_id(aid_newbuf_bvars);\n\tif (buf->b_vars == NULL)\n\t{\n\t    vim_free(ffname);\n\t    vim_free(buf);\n\t    return NULL;\n\t}\n\tinit_var_dict(buf->b_vars, &buf->b_bufvar, VAR_SCOPE);\n#endif\n\tinit_changedtick(buf);\n    }\n\n    if (ffname != NULL)\n    {\n\tbuf->b_ffname = ffname;\n\tbuf->b_sfname = vim_strsave(sfname);\n    }\n\n    clear_wininfo(buf);\n    buf->b_wininfo = ALLOC_CLEAR_ONE(wininfo_T);\n\n    if ((ffname != NULL && (buf->b_ffname == NULL || buf->b_sfname == NULL))\n\t    || buf->b_wininfo == NULL)\n    {\n\tif (buf->b_sfname != buf->b_ffname)\n\t    VIM_CLEAR(buf->b_sfname);\n\telse\n\t    buf->b_sfname = NULL;\n\tVIM_CLEAR(buf->b_ffname);\n\tif (buf != curbuf)\n\t    free_buffer(buf);\n\treturn NULL;\n    }\n\n    if (buf == curbuf)\n    {\n\tfree_buffer_stuff(buf, FALSE);\t// delete local variables et al.\n\n\t// Init the options.\n\tbuf->b_p_initialized = FALSE;\n\tbuf_copy_options(buf, BCO_ENTER);\n\n#ifdef FEAT_KEYMAP\n\t// need to reload lmaps and set b:keymap_name\n\tcurbuf->b_kmap_state |= KEYMAP_INIT;\n#endif\n    }\n    else\n    {\n\t// put the new buffer at the end of the buffer list\n\tbuf->b_next = NULL;\n\tif (firstbuf == NULL)\t\t// buffer list is empty\n\t{\n\t    buf->b_prev = NULL;\n\t    firstbuf = buf;\n\t}\n\telse\t\t\t\t// append new buffer at end of list\n\t{\n\t    lastbuf->b_next = buf;\n\t    buf->b_prev = lastbuf;\n\t}\n\tlastbuf = buf;\n\n\tif ((flags & BLN_REUSE) && buf_reuse.ga_len > 0)\n\t{\n\t    // Recycle a previously used buffer number.  Used for buffers which\n\t    // are normally hidden, e.g. in a popup window.  Avoids that the\n\t    // buffer number grows rapidly.\n\t    --buf_reuse.ga_len;\n\t    buf->b_fnum = ((int *)buf_reuse.ga_data)[buf_reuse.ga_len];\n\n\t    // Move buffer to the right place in the buffer list.\n\t    while (buf->b_prev != NULL && buf->b_fnum < buf->b_prev->b_fnum)\n\t    {\n\t\tbuf_T\t*prev = buf->b_prev;\n\n\t\tprev->b_next = buf->b_next;\n\t\tif (prev->b_next != NULL)\n\t\t    prev->b_next->b_prev = prev;\n\t\tbuf->b_next = prev;\n\t\tbuf->b_prev = prev->b_prev;\n\t\tif (buf->b_prev != NULL)\n\t\t    buf->b_prev->b_next = buf;\n\t\tprev->b_prev = buf;\n\t\tif (lastbuf == buf)\n\t\t    lastbuf = prev;\n\t\tif (firstbuf == prev)\n\t\t    firstbuf = buf;\n\t    }\n\t}\n\telse\n\t    buf->b_fnum = top_file_num++;\n\tif (top_file_num < 0)\t\t// wrap around (may cause duplicates)\n\t{\n\t    emsg(_(\"W14: Warning: List of file names overflow\"));\n\t    if (emsg_silent == 0 && !in_assert_fails)\n\t    {\n\t\tout_flush();\n\t\tui_delay(3001L, TRUE);\t// make sure it is noticed\n\t    }\n\t    top_file_num = 1;\n\t}\n\tbuf_hashtab_add(buf);\n\n\t// Always copy the options from the current buffer.\n\tbuf_copy_options(buf, BCO_ALWAYS);\n    }\n\n    buf->b_wininfo->wi_fpos.lnum = lnum;\n    buf->b_wininfo->wi_win = curwin;\n\n#ifdef FEAT_SYN_HL\n    hash_init(&buf->b_s.b_keywtab);\n    hash_init(&buf->b_s.b_keywtab_ic);\n#endif\n\n    buf->b_fname = buf->b_sfname;\n#ifdef UNIX\n    if (st.st_dev == (dev_T)-1)\n\tbuf->b_dev_valid = FALSE;\n    else\n    {\n\tbuf->b_dev_valid = TRUE;\n\tbuf->b_dev = st.st_dev;\n\tbuf->b_ino = st.st_ino;\n    }\n#endif\n    buf->b_u_synced = TRUE;\n    buf->b_flags = BF_CHECK_RO | BF_NEVERLOADED;\n    if (flags & BLN_DUMMY)\n\tbuf->b_flags |= BF_DUMMY;\n    buf_clear_file(buf);\n    clrallmarks(buf);\t\t\t// clear marks\n    fmarks_check_names(buf);\t\t// check file marks for this file\n    buf->b_p_bl = (flags & BLN_LISTED) ? TRUE : FALSE;\t// init 'buflisted'\n    if (!(flags & BLN_DUMMY))\n    {\n\tbufref_T bufref;\n\n\t// Tricky: these autocommands may change the buffer list.  They could\n\t// also split the window with re-using the one empty buffer. This may\n\t// result in unexpectedly losing the empty buffer.\n\tset_bufref(&bufref, buf);\n\tif (apply_autocmds(EVENT_BUFNEW, NULL, NULL, FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t    return NULL;\n\tif (flags & BLN_LISTED)\n\t{\n\t    if (apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, buf)\n\t\t    && !bufref_valid(&bufref))\n\t\treturn NULL;\n\t}\n#ifdef FEAT_EVAL\n\tif (aborting())\t\t// autocmds may abort script processing\n\t    return NULL;\n#endif\n    }\n\n    return buf;\n}\n\n/*\n * Free the memory for the options of a buffer.\n * If \"free_p_ff\" is TRUE also free 'fileformat', 'buftype' and\n * 'fileencoding'.\n */\n    void\nfree_buf_options(\n    buf_T\t*buf,\n    int\t\tfree_p_ff)\n{\n    if (free_p_ff)\n    {\n\tclear_string_option(&buf->b_p_fenc);\n\tclear_string_option(&buf->b_p_ff);\n\tclear_string_option(&buf->b_p_bh);\n\tclear_string_option(&buf->b_p_bt);\n    }\n#ifdef FEAT_FIND_ID\n    clear_string_option(&buf->b_p_def);\n    clear_string_option(&buf->b_p_inc);\n# ifdef FEAT_EVAL\n    clear_string_option(&buf->b_p_inex);\n# endif\n#endif\n#if defined(FEAT_EVAL)\n    clear_string_option(&buf->b_p_inde);\n    clear_string_option(&buf->b_p_indk);\n#endif\n#if defined(FEAT_BEVAL) && defined(FEAT_EVAL)\n    clear_string_option(&buf->b_p_bexpr);\n#endif\n#if defined(FEAT_CRYPT)\n    clear_string_option(&buf->b_p_cm);\n#endif\n    clear_string_option(&buf->b_p_fp);\n#if defined(FEAT_EVAL)\n    clear_string_option(&buf->b_p_fex);\n#endif\n#ifdef FEAT_CRYPT\n# ifdef FEAT_SODIUM\n    if ((buf->b_p_key != NULL) && (*buf->b_p_key != NUL) &&\n\t\t\t\t(crypt_get_method_nr(buf) == CRYPT_M_SOD))\n\tcrypt_sodium_munlock(buf->b_p_key, STRLEN(buf->b_p_key));\n# endif\n    clear_string_option(&buf->b_p_key);\n#endif\n    clear_string_option(&buf->b_p_kp);\n    clear_string_option(&buf->b_p_mps);\n    clear_string_option(&buf->b_p_fo);\n    clear_string_option(&buf->b_p_flp);\n    clear_string_option(&buf->b_p_isk);\n#ifdef FEAT_VARTABS\n    clear_string_option(&buf->b_p_vsts);\n    vim_free(buf->b_p_vsts_nopaste);\n    buf->b_p_vsts_nopaste = NULL;\n    VIM_CLEAR(buf->b_p_vsts_array);\n    clear_string_option(&buf->b_p_vts);\n    VIM_CLEAR(buf->b_p_vts_array);\n#endif\n#ifdef FEAT_KEYMAP\n    clear_string_option(&buf->b_p_keymap);\n    keymap_clear(&buf->b_kmap_ga);\n    ga_clear(&buf->b_kmap_ga);\n#endif\n    clear_string_option(&buf->b_p_com);\n#ifdef FEAT_FOLDING\n    clear_string_option(&buf->b_p_cms);\n#endif\n    clear_string_option(&buf->b_p_nf);\n#ifdef FEAT_SYN_HL\n    clear_string_option(&buf->b_p_syn);\n    clear_string_option(&buf->b_s.b_syn_isk);\n#endif\n#ifdef FEAT_SPELL\n    clear_string_option(&buf->b_s.b_p_spc);\n    clear_string_option(&buf->b_s.b_p_spf);\n    vim_regfree(buf->b_s.b_cap_prog);\n    buf->b_s.b_cap_prog = NULL;\n    clear_string_option(&buf->b_s.b_p_spl);\n    clear_string_option(&buf->b_s.b_p_spo);\n#endif\n#ifdef FEAT_SEARCHPATH\n    clear_string_option(&buf->b_p_sua);\n#endif\n    clear_string_option(&buf->b_p_ft);\n    clear_string_option(&buf->b_p_cink);\n    clear_string_option(&buf->b_p_cino);\n    clear_string_option(&buf->b_p_cinsd);\n    clear_string_option(&buf->b_p_cinw);\n    clear_string_option(&buf->b_p_cpt);\n#ifdef FEAT_COMPL_FUNC\n    clear_string_option(&buf->b_p_cfu);\n    free_callback(&buf->b_cfu_cb);\n    clear_string_option(&buf->b_p_ofu);\n    free_callback(&buf->b_ofu_cb);\n    clear_string_option(&buf->b_p_tsrfu);\n    free_callback(&buf->b_tsrfu_cb);\n#endif\n#ifdef FEAT_QUICKFIX\n    clear_string_option(&buf->b_p_gp);\n    clear_string_option(&buf->b_p_mp);\n    clear_string_option(&buf->b_p_efm);\n#endif\n    clear_string_option(&buf->b_p_ep);\n    clear_string_option(&buf->b_p_path);\n    clear_string_option(&buf->b_p_tags);\n    clear_string_option(&buf->b_p_tc);\n#ifdef FEAT_EVAL\n    clear_string_option(&buf->b_p_tfu);\n    free_callback(&buf->b_tfu_cb);\n#endif\n    clear_string_option(&buf->b_p_dict);\n    clear_string_option(&buf->b_p_tsr);\n#ifdef FEAT_TEXTOBJ\n    clear_string_option(&buf->b_p_qe);\n#endif\n    buf->b_p_ar = -1;\n    buf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n    clear_string_option(&buf->b_p_lw);\n    clear_string_option(&buf->b_p_bkc);\n    clear_string_option(&buf->b_p_menc);\n}\n\n/*\n * Get alternate file \"n\".\n * Set linenr to \"lnum\" or altfpos.lnum if \"lnum\" == 0.\n *\tAlso set cursor column to altfpos.col if 'startofline' is not set.\n * if (options & GETF_SETMARK) call setpcmark()\n * if (options & GETF_ALT) we are jumping to an alternate file.\n * if (options & GETF_SWITCH) respect 'switchbuf' settings when jumping\n *\n * Return FAIL for failure, OK for success.\n */\n    int\nbuflist_getfile(\n    int\t\tn,\n    linenr_T\tlnum,\n    int\t\toptions,\n    int\t\tforceit)\n{\n    buf_T\t*buf;\n    win_T\t*wp = NULL;\n    pos_T\t*fpos;\n    colnr_T\tcol;\n\n    buf = buflist_findnr(n);\n    if (buf == NULL)\n    {\n\tif ((options & GETF_ALT) && n == 0)\n\t    emsg(_(e_no_alternate_file));\n\telse\n\t    semsg(_(e_buffer_nr_not_found), n);\n\treturn FAIL;\n    }\n\n    // if alternate file is the current buffer, nothing to do\n    if (buf == curbuf)\n\treturn OK;\n\n    if (text_locked())\n    {\n\ttext_locked_msg();\n\treturn FAIL;\n    }\n    if (curbuf_locked())\n\treturn FAIL;\n\n    // altfpos may be changed by getfile(), get it now\n    if (lnum == 0)\n    {\n\tfpos = buflist_findfpos(buf);\n\tlnum = fpos->lnum;\n\tcol = fpos->col;\n    }\n    else\n\tcol = 0;\n\n    if (options & GETF_SWITCH)\n    {\n\t// If 'switchbuf' contains \"useopen\": jump to first window containing\n\t// \"buf\" if one exists\n\tif (swb_flags & SWB_USEOPEN)\n\t    wp = buf_jump_open_win(buf);\n\n\t// If 'switchbuf' contains \"usetab\": jump to first window in any tab\n\t// page containing \"buf\" if one exists\n\tif (wp == NULL && (swb_flags & SWB_USETAB))\n\t    wp = buf_jump_open_tab(buf);\n\n\t// If 'switchbuf' contains \"split\", \"vsplit\" or \"newtab\" and the\n\t// current buffer isn't empty: open new tab or window\n\tif (wp == NULL && (swb_flags & (SWB_VSPLIT | SWB_SPLIT | SWB_NEWTAB))\n\t\t\t\t\t\t\t       && !BUFEMPTY())\n\t{\n\t    if (swb_flags & SWB_NEWTAB)\n\t\ttabpage_new();\n\t    else if (win_split(0, (swb_flags & SWB_VSPLIT) ? WSP_VERT : 0)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\treturn FAIL;\n\t    RESET_BINDING(curwin);\n\t}\n    }\n\n    ++RedrawingDisabled;\n    if (GETFILE_SUCCESS(getfile(buf->b_fnum, NULL, NULL,\n\t\t\t\t     (options & GETF_SETMARK), lnum, forceit)))\n    {\n\t--RedrawingDisabled;\n\n\t// cursor is at to BOL and w_cursor.lnum is checked due to getfile()\n\tif (!p_sol && col != 0)\n\t{\n\t    curwin->w_cursor.col = col;\n\t    check_cursor_col();\n\t    curwin->w_cursor.coladd = 0;\n\t    curwin->w_set_curswant = TRUE;\n\t}\n\treturn OK;\n    }\n    --RedrawingDisabled;\n    return FAIL;\n}\n\n/*\n * go to the last know line number for the current buffer\n */\n    static void\nbuflist_getfpos(void)\n{\n    pos_T\t*fpos;\n\n    fpos = buflist_findfpos(curbuf);\n\n    curwin->w_cursor.lnum = fpos->lnum;\n    check_cursor_lnum();\n\n    if (p_sol)\n\tcurwin->w_cursor.col = 0;\n    else\n    {\n\tcurwin->w_cursor.col = fpos->col;\n\tcheck_cursor_col();\n\tcurwin->w_cursor.coladd = 0;\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n#if defined(FEAT_QUICKFIX) || defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Find file in buffer list by name (it has to be for the current window).\n * Returns NULL if not found.\n */\n    buf_T *\nbuflist_findname_exp(char_u *fname)\n{\n    char_u\t*ffname;\n    buf_T\t*buf = NULL;\n\n    // First make the name into a full path name\n    ffname = FullName_save(fname,\n#ifdef UNIX\n\t    TRUE\t    // force expansion, get rid of symbolic links\n#else\n\t    FALSE\n#endif\n\t    );\n    if (ffname != NULL)\n    {\n\tbuf = buflist_findname(ffname);\n\tvim_free(ffname);\n    }\n    return buf;\n}\n#endif\n\n/*\n * Find file in buffer list by name (it has to be for the current window).\n * \"ffname\" must have a full path.\n * Skips dummy buffers.\n * Returns NULL if not found.\n */\n    buf_T *\nbuflist_findname(char_u *ffname)\n{\n#ifdef UNIX\n    stat_T\tst;\n\n    if (mch_stat((char *)ffname, &st) < 0)\n\tst.st_dev = (dev_T)-1;\n    return buflist_findname_stat(ffname, &st);\n}\n\n/*\n * Same as buflist_findname(), but pass the stat structure to avoid getting it\n * twice for the same file.\n * Returns NULL if not found.\n */\n    static buf_T *\nbuflist_findname_stat(\n    char_u\t*ffname,\n    stat_T\t*stp)\n{\n#endif\n    buf_T\t*buf;\n\n    // Start at the last buffer, expect to find a match sooner.\n    FOR_ALL_BUFS_FROM_LAST(buf)\n\tif ((buf->b_flags & BF_DUMMY) == 0 && !otherfile_buf(buf, ffname\n#ifdef UNIX\n\t\t    , stp\n#endif\n\t\t    ))\n\t    return buf;\n    return NULL;\n}\n\n/*\n * Find file in buffer list by a regexp pattern.\n * Return fnum of the found buffer.\n * Return < 0 for error.\n */\n    int\nbuflist_findpat(\n    char_u\t*pattern,\n    char_u\t*pattern_end,\t// pointer to first char after pattern\n    int\t\tunlisted,\t// find unlisted buffers\n    int\t\tdiffmode UNUSED, // find diff-mode buffers only\n    int\t\tcurtab_only)\t// find buffers in current tab only\n{\n    buf_T\t*buf;\n    int\t\tmatch = -1;\n    int\t\tfind_listed;\n    char_u\t*pat;\n    char_u\t*patend;\n    int\t\tattempt;\n    char_u\t*p;\n    int\t\ttoggledollar;\n\n    // \"%\" is current file, \"%%\" or \"#\" is alternate file\n    if ((pattern_end == pattern + 1 && (*pattern == '%' || *pattern == '#'))\n\t    || (in_vim9script() && pattern_end == pattern + 2\n\t\t\t\t    && pattern[0] == '%' && pattern[1] == '%'))\n    {\n\tif (*pattern == '#' || pattern_end == pattern + 2)\n\t    match = curwin->w_alt_fnum;\n\telse\n\t    match = curbuf->b_fnum;\n#ifdef FEAT_DIFF\n\tif (diffmode && !diff_mode_buf(buflist_findnr(match)))\n\t    match = -1;\n#endif\n    }\n\n    /*\n     * Try four ways of matching a listed buffer:\n     * attempt == 0: without '^' or '$' (at any position)\n     * attempt == 1: with '^' at start (only at position 0)\n     * attempt == 2: with '$' at end (only match at end)\n     * attempt == 3: with '^' at start and '$' at end (only full match)\n     * Repeat this for finding an unlisted buffer if there was no matching\n     * listed buffer.\n     */\n    else\n    {\n\tpat = file_pat_to_reg_pat(pattern, pattern_end, NULL, FALSE);\n\tif (pat == NULL)\n\t    return -1;\n\tpatend = pat + STRLEN(pat) - 1;\n\ttoggledollar = (patend > pat && *patend == '$');\n\n\t// First try finding a listed buffer.  If not found and \"unlisted\"\n\t// is TRUE, try finding an unlisted buffer.\n\tfind_listed = TRUE;\n\tfor (;;)\n\t{\n\t    for (attempt = 0; attempt <= 3; ++attempt)\n\t    {\n\t\tregmatch_T\tregmatch;\n\n\t\t// may add '^' and '$'\n\t\tif (toggledollar)\n\t\t    *patend = (attempt < 2) ? NUL : '$'; // add/remove '$'\n\t\tp = pat;\n\t\tif (*p == '^' && !(attempt & 1))\t // add/remove '^'\n\t\t    ++p;\n\t\tregmatch.regprog = vim_regcomp(p, magic_isset() ? RE_MAGIC : 0);\n\n\t\tFOR_ALL_BUFS_FROM_LAST(buf)\n\t\t{\n\t\t    if (regmatch.regprog == NULL)\n\t\t    {\n\t\t\t// invalid pattern, possibly after switching engine\n\t\t\tvim_free(pat);\n\t\t\treturn -1;\n\t\t    }\n\t\t    if (buf->b_p_bl == find_listed\n#ifdef FEAT_DIFF\n\t\t\t    && (!diffmode || diff_mode_buf(buf))\n#endif\n\t\t\t    && buflist_match(&regmatch, buf, FALSE) != NULL)\n\t\t    {\n\t\t\tif (curtab_only)\n\t\t\t{\n\t\t\t    // Ignore the match if the buffer is not open in\n\t\t\t    // the current tab.\n\t\t\t    win_T\t*wp;\n\n\t\t\t    FOR_ALL_WINDOWS(wp)\n\t\t\t\tif (wp->w_buffer == buf)\n\t\t\t\t    break;\n\t\t\t    if (wp == NULL)\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (match >= 0)\t\t// already found a match\n\t\t\t{\n\t\t\t    match = -2;\n\t\t\t    break;\n\t\t\t}\n\t\t\tmatch = buf->b_fnum;\t// remember first match\n\t\t    }\n\t\t}\n\n\t\tvim_regfree(regmatch.regprog);\n\t\tif (match >= 0)\t\t\t// found one match\n\t\t    break;\n\t    }\n\n\t    // Only search for unlisted buffers if there was no match with\n\t    // a listed buffer.\n\t    if (!unlisted || !find_listed || match != -1)\n\t\tbreak;\n\t    find_listed = FALSE;\n\t}\n\n\tvim_free(pat);\n    }\n\n    if (match == -2)\n\tsemsg(_(e_more_than_one_match_for_str), pattern);\n    else if (match < 0)\n\tsemsg(_(e_no_matching_buffer_for_str), pattern);\n    return match;\n}\n\n#ifdef FEAT_VIMINFO\ntypedef struct {\n    buf_T   *buf;\n    char_u  *match;\n} bufmatch_T;\n#endif\n\n/*\n * Find all buffer names that match.\n * For command line expansion of \":buf\" and \":sbuf\".\n * Return OK if matches found, FAIL otherwise.\n */\n    int\nExpandBufnames(\n    char_u\t*pat,\n    int\t\t*num_file,\n    char_u\t***file,\n    int\t\toptions)\n{\n    int\t\tcount = 0;\n    buf_T\t*buf;\n    int\t\tround;\n    char_u\t*p;\n    int\t\tattempt;\n    char_u\t*patc = NULL;\n#ifdef FEAT_VIMINFO\n    bufmatch_T\t*matches = NULL;\n#endif\n    int\t\tfuzzy;\n    fuzmatch_str_T  *fuzmatch = NULL;\n\n    *num_file = 0;\t\t    // return values in case of FAIL\n    *file = NULL;\n\n#ifdef FEAT_DIFF\n    if ((options & BUF_DIFF_FILTER) && !curwin->w_p_diff)\n\treturn FAIL;\n#endif\n\n    fuzzy = cmdline_fuzzy_complete(pat);\n\n    // Make a copy of \"pat\" and change \"^\" to \"\\(^\\|[\\/]\\)\" (if doing regular\n    // expression matching)\n    if (!fuzzy)\n    {\n\tif (*pat == '^')\n\t{\n\t    patc = alloc(STRLEN(pat) + 11);\n\t    if (patc == NULL)\n\t\treturn FAIL;\n\t    STRCPY(patc, \"\\\\(^\\\\|[\\\\/]\\\\)\");\n\t    STRCPY(patc + 11, pat + 1);\n\t}\n\telse\n\t    patc = pat;\n    }\n\n    // attempt == 0: try match with    '\\<', match at start of word\n    // attempt == 1: try match without '\\<', match anywhere\n    for (attempt = 0; attempt <= (fuzzy ? 0 : 1); ++attempt)\n    {\n\tregmatch_T\tregmatch;\n\tint\t\tscore = 0;\n\n\tif (!fuzzy)\n\t{\n\t    if (attempt > 0 && patc == pat)\n\t\tbreak;\t// there was no anchor, no need to try again\n\t    regmatch.regprog = vim_regcomp(patc + attempt * 11, RE_MAGIC);\n\t}\n\n\t// round == 1: Count the matches.\n\t// round == 2: Build the array to keep the matches.\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    count = 0;\n\t    FOR_ALL_BUFFERS(buf)\n\t    {\n\t\tif (!buf->b_p_bl)\t// skip unlisted buffers\n\t\t    continue;\n#ifdef FEAT_DIFF\n\t\tif (options & BUF_DIFF_FILTER)\n\t\t    // Skip buffers not suitable for\n\t\t    // :diffget or :diffput completion.\n\t\t    if (buf == curbuf || !diff_mode_buf(buf))\n\t\t\tcontinue;\n#endif\n\n\t\tif (!fuzzy)\n\t\t{\n\t\t    if (regmatch.regprog == NULL)\n\t\t    {\n\t\t\t// invalid pattern, possibly after recompiling\n\t\t\tif (patc != pat)\n\t\t\t    vim_free(patc);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    p = buflist_match(&regmatch, buf, p_wic);\n\t\t}\n\t\telse\n\t\t{\n\t\t    p = NULL;\n\t\t    // first try matching with the short file name\n\t\t    if ((score = fuzzy_match_str(buf->b_sfname, pat)) != 0)\n\t\t\tp = buf->b_sfname;\n\t\t    if (p == NULL)\n\t\t    {\n\t\t\t// next try matching with the full path file name\n\t\t\tif ((score = fuzzy_match_str(buf->b_ffname, pat)) != 0)\n\t\t\t    p = buf->b_ffname;\n\t\t    }\n\t\t}\n\n\t\tif (p == NULL)\n\t\t    continue;\n\n\t\tif (round == 1)\n\t\t{\n\t\t    ++count;\n\t\t    continue;\n\t\t}\n\n\t\tif (options & WILD_HOME_REPLACE)\n\t\t    p = home_replace_save(buf, p);\n\t\telse\n\t\t    p = vim_strsave(p);\n\n\t\tif (!fuzzy)\n\t\t{\n#ifdef FEAT_VIMINFO\n\t\t    if (matches != NULL)\n\t\t    {\n\t\t\tmatches[count].buf = buf;\n\t\t\tmatches[count].match = p;\n\t\t\tcount++;\n\t\t    }\n\t\t    else\n#endif\n\t\t\t(*file)[count++] = p;\n\t\t}\n\t\telse\n\t\t{\n\t\t    fuzmatch[count].idx = count;\n\t\t    fuzmatch[count].str = p;\n\t\t    fuzmatch[count].score = score;\n\t\t    count++;\n\t\t}\n\t    }\n\t    if (count == 0)\t// no match found, break here\n\t\tbreak;\n\t    if (round == 1)\n\t    {\n\t\tif (!fuzzy)\n\t\t{\n\t\t    *file = ALLOC_MULT(char_u *, count);\n\t\t    if (*file == NULL)\n\t\t    {\n\t\t\tvim_regfree(regmatch.regprog);\n\t\t\tif (patc != pat)\n\t\t\t    vim_free(patc);\n\t\t\treturn FAIL;\n\t\t    }\n#ifdef FEAT_VIMINFO\n\t\t    if (options & WILD_BUFLASTUSED)\n\t\t\tmatches = ALLOC_MULT(bufmatch_T, count);\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    fuzmatch = ALLOC_MULT(fuzmatch_str_T, count);\n\t\t    if (fuzmatch == NULL)\n\t\t    {\n\t\t\t*num_file = 0;\n\t\t\t*file = NULL;\n\t\t\treturn FAIL;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tif (!fuzzy)\n\t{\n\t    vim_regfree(regmatch.regprog);\n\t    if (count)\t\t// match(es) found, break here\n\t\tbreak;\n\t}\n    }\n\n    if (!fuzzy && patc != pat)\n\tvim_free(patc);\n\n#ifdef FEAT_VIMINFO\n    if (!fuzzy)\n    {\n\tif (matches != NULL)\n\t{\n\t    int i;\n\t    if (count > 1)\n\t\tqsort(matches, count, sizeof(bufmatch_T), buf_compare);\n\t    // if the current buffer is first in the list, place it at the end\n\t    if (matches[0].buf == curbuf)\n\t    {\n\t\tfor (i = 1; i < count; i++)\n\t\t    (*file)[i-1] = matches[i].match;\n\t\t(*file)[count-1] = matches[0].match;\n\t    }\n\t    else\n\t    {\n\t\tfor (i = 0; i < count; i++)\n\t\t    (*file)[i] = matches[i].match;\n\t    }\n\t    vim_free(matches);\n\t}\n    }\n    else\n    {\n\tif (fuzzymatches_to_strmatches(fuzmatch, file, count, FALSE) == FAIL)\n\t    return FAIL;\n    }\n#endif\n\n    *num_file = count;\n    return (count == 0 ? FAIL : OK);\n}\n\n/*\n * Check for a match on the file name for buffer \"buf\" with regprog \"prog\".\n * Note that rmp->regprog may become NULL when switching regexp engine.\n */\n    static char_u *\nbuflist_match(\n    regmatch_T\t*rmp,\n    buf_T\t*buf,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match;\n\n    // First try the short file name, then the long file name.\n    match = fname_match(rmp, buf->b_sfname, ignore_case);\n    if (match == NULL && rmp->regprog != NULL)\n\tmatch = fname_match(rmp, buf->b_ffname, ignore_case);\n\n    return match;\n}\n\n/*\n * Try matching the regexp in \"rmp->regprog\" with file name \"name\".\n * Note that rmp->regprog may become NULL when switching regexp engine.\n * Return \"name\" when there is a match, NULL when not.\n */\n    static char_u *\nfname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    // extra check for valid arguments\n    if (name != NULL && rmp->regprog != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse if (rmp->regprog != NULL)\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}\n\n/*\n * Find a file in the buffer list by buffer number.\n */\n    buf_T *\nbuflist_findnr(int nr)\n{\n    char_u\tkey[VIM_SIZEOF_INT * 2 + 1];\n    hashitem_T\t*hi;\n\n    if (nr == 0)\n\tnr = curwin->w_alt_fnum;\n    sprintf((char *)key, \"%x\", nr);\n    hi = hash_find(&buf_hashtab, key);\n\n    if (!HASHITEM_EMPTY(hi))\n\treturn (buf_T *)(hi->hi_key\n\t\t\t     - ((unsigned)(curbuf->b_key - (char_u *)curbuf)));\n    return NULL;\n}\n\n/*\n * Get name of file 'n' in the buffer list.\n * When the file has no name an empty string is returned.\n * home_replace() is used to shorten the file name (used for marks).\n * Returns a pointer to allocated memory, of NULL when failed.\n */\n    char_u *\nbuflist_nr2name(\n    int\t\tn,\n    int\t\tfullname,\n    int\t\thelptail)\t// for help buffers return tail only\n{\n    buf_T\t*buf;\n\n    buf = buflist_findnr(n);\n    if (buf == NULL)\n\treturn NULL;\n    return home_replace_save(helptail ? buf : NULL,\n\t\t\t\t     fullname ? buf->b_ffname : buf->b_fname);\n}\n\n/*\n * Set the \"lnum\" and \"col\" for the buffer \"buf\" and the current window.\n * When \"copy_options\" is TRUE save the local window option values.\n * When \"lnum\" is 0 only do the options.\n */\n    void\nbuflist_setfpos(\n    buf_T\t*buf,\n    win_T\t*win,\t\t// may be NULL when using :badd\n    linenr_T\tlnum,\n    colnr_T\tcol,\n    int\t\tcopy_options)\n{\n    wininfo_T\t*wip;\n\n    FOR_ALL_BUF_WININFO(buf, wip)\n\tif (wip->wi_win == win)\n\t    break;\n    if (wip == NULL)\n    {\n\t// allocate a new entry\n\twip = ALLOC_CLEAR_ONE(wininfo_T);\n\tif (wip == NULL)\n\t    return;\n\twip->wi_win = win;\n\tif (lnum == 0)\t\t// set lnum even when it's 0\n\t    lnum = 1;\n    }\n    else\n    {\n\t// remove the entry from the list\n\tif (wip->wi_prev)\n\t    wip->wi_prev->wi_next = wip->wi_next;\n\telse\n\t    buf->b_wininfo = wip->wi_next;\n\tif (wip->wi_next)\n\t    wip->wi_next->wi_prev = wip->wi_prev;\n\tif (copy_options && wip->wi_optset)\n\t{\n\t    clear_winopt(&wip->wi_opt);\n#ifdef FEAT_FOLDING\n\t    deleteFoldRecurse(&wip->wi_folds);\n#endif\n\t}\n    }\n    if (lnum != 0)\n    {\n\twip->wi_fpos.lnum = lnum;\n\twip->wi_fpos.col = col;\n    }\n    if (win != NULL)\n\twip->wi_changelistidx = win->w_changelistidx;\n    if (copy_options && win != NULL)\n    {\n\t// Save the window-specific option values.\n\tcopy_winopt(&win->w_onebuf_opt, &wip->wi_opt);\n#ifdef FEAT_FOLDING\n\twip->wi_fold_manual = win->w_fold_manual;\n\tcloneFoldGrowArray(&win->w_folds, &wip->wi_folds);\n#endif\n\twip->wi_optset = TRUE;\n    }\n\n    // insert the entry in front of the list\n    wip->wi_next = buf->b_wininfo;\n    buf->b_wininfo = wip;\n    wip->wi_prev = NULL;\n    if (wip->wi_next)\n\twip->wi_next->wi_prev = wip;\n}\n\n#ifdef FEAT_DIFF\n/*\n * Return TRUE when \"wip\" has 'diff' set and the diff is only for another tab\n * page.  That's because a diff is local to a tab page.\n */\n    static int\nwininfo_other_tab_diff(wininfo_T *wip)\n{\n    win_T\t*wp;\n\n    if (wip->wi_opt.wo_diff)\n    {\n\tFOR_ALL_WINDOWS(wp)\n\t    // return FALSE when it's a window in the current tab page, thus\n\t    // the buffer was in diff mode here\n\t    if (wip->wi_win == wp)\n\t\treturn FALSE;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n#endif\n\n/*\n * Find info for the current window in buffer \"buf\".\n * If not found, return the info for the most recently used window.\n * When \"need_options\" is TRUE skip entries where wi_optset is FALSE.\n * When \"skip_diff_buffer\" is TRUE avoid windows with 'diff' set that is in\n * another tab page.\n * Returns NULL when there isn't any info.\n */\n    static wininfo_T *\nfind_wininfo(\n    buf_T\t*buf,\n    int\t\tneed_options,\n    int\t\tskip_diff_buffer UNUSED)\n{\n    wininfo_T\t*wip;\n\n    FOR_ALL_BUF_WININFO(buf, wip)\n\tif (wip->wi_win == curwin\n#ifdef FEAT_DIFF\n\t\t&& (!skip_diff_buffer || !wininfo_other_tab_diff(wip))\n#endif\n\n\t\t&& (!need_options || wip->wi_optset))\n\t    break;\n\n    // If no wininfo for curwin, use the first in the list (that doesn't have\n    // 'diff' set and is in another tab page).\n    // If \"need_options\" is TRUE skip entries that don't have options set,\n    // unless the window is editing \"buf\", so we can copy from the window\n    // itself.\n    if (wip == NULL)\n    {\n#ifdef FEAT_DIFF\n\tif (skip_diff_buffer)\n\t{\n\t    FOR_ALL_BUF_WININFO(buf, wip)\n\t\tif (!wininfo_other_tab_diff(wip)\n\t\t\t&& (!need_options || wip->wi_optset\n\t\t\t    || (wip->wi_win != NULL\n\t\t\t\t\t     && wip->wi_win->w_buffer == buf)))\n\t\t    break;\n\t}\n\telse\n#endif\n\t    wip = buf->b_wininfo;\n    }\n    return wip;\n}\n\n/*\n * Reset the local window options to the values last used in this window.\n * If the buffer wasn't used in this window before, use the values from\n * the most recently used window.  If the values were never set, use the\n * global values for the window.\n */\n    void\nget_winopts(buf_T *buf)\n{\n    wininfo_T\t*wip;\n\n    clear_winopt(&curwin->w_onebuf_opt);\n#ifdef FEAT_FOLDING\n    clearFolding(curwin);\n#endif\n\n    wip = find_wininfo(buf, TRUE, TRUE);\n    if (wip != NULL && wip->wi_win != NULL\n\t    && wip->wi_win != curwin && wip->wi_win->w_buffer == buf)\n    {\n\t// The buffer is currently displayed in the window: use the actual\n\t// option values instead of the saved (possibly outdated) values.\n\twin_T *wp = wip->wi_win;\n\n\tcopy_winopt(&wp->w_onebuf_opt, &curwin->w_onebuf_opt);\n#ifdef FEAT_FOLDING\n\tcurwin->w_fold_manual = wp->w_fold_manual;\n\tcurwin->w_foldinvalid = TRUE;\n\tcloneFoldGrowArray(&wp->w_folds, &curwin->w_folds);\n#endif\n    }\n    else if (wip != NULL && wip->wi_optset)\n    {\n\t// the buffer was displayed in the current window earlier\n\tcopy_winopt(&wip->wi_opt, &curwin->w_onebuf_opt);\n#ifdef FEAT_FOLDING\n\tcurwin->w_fold_manual = wip->wi_fold_manual;\n\tcurwin->w_foldinvalid = TRUE;\n\tcloneFoldGrowArray(&wip->wi_folds, &curwin->w_folds);\n#endif\n    }\n    else\n\tcopy_winopt(&curwin->w_allbuf_opt, &curwin->w_onebuf_opt);\n    if (wip != NULL)\n\tcurwin->w_changelistidx = wip->wi_changelistidx;\n\n#ifdef FEAT_FOLDING\n    // Set 'foldlevel' to 'foldlevelstart' if it's not negative.\n    if (p_fdls >= 0)\n\tcurwin->w_p_fdl = p_fdls;\n#endif\n    after_copy_winopt(curwin);\n}\n\n/*\n * Find the position (lnum and col) for the buffer 'buf' for the current\n * window.\n * Returns a pointer to no_position if no position is found.\n */\n    pos_T *\nbuflist_findfpos(buf_T *buf)\n{\n    wininfo_T\t*wip;\n    static pos_T no_position = {1, 0, 0};\n\n    wip = find_wininfo(buf, FALSE, FALSE);\n    if (wip != NULL)\n\treturn &(wip->wi_fpos);\n    else\n\treturn &no_position;\n}\n\n/*\n * Find the lnum for the buffer 'buf' for the current window.\n */\n    linenr_T\nbuflist_findlnum(buf_T *buf)\n{\n    return buflist_findfpos(buf)->lnum;\n}\n\n/*\n * List all known file names (for :files and :buffers command).\n */\n    void\nbuflist_list(exarg_T *eap)\n{\n    buf_T\t*buf = firstbuf;\n    int\t\tlen;\n    int\t\ti;\n    int\t\tro_char;\n    int\t\tchanged_char;\n#ifdef FEAT_TERMINAL\n    int\t\tjob_running;\n    int\t\tjob_none_open;\n#endif\n\n#ifdef FEAT_VIMINFO\n    garray_T\tbuflist;\n    buf_T\t**buflist_data = NULL, **p;\n\n    if (vim_strchr(eap->arg, 't'))\n    {\n\tga_init2(&buflist, sizeof(buf_T *), 50);\n\tFOR_ALL_BUFFERS(buf)\n\t{\n\t    if (ga_grow(&buflist, 1) == OK)\n\t\t((buf_T **)buflist.ga_data)[buflist.ga_len++] = buf;\n\t}\n\n\tqsort(buflist.ga_data, (size_t)buflist.ga_len,\n\t\tsizeof(buf_T *), buf_compare);\n\n\tbuflist_data = (buf_T **)buflist.ga_data;\n\tbuf = *buflist_data;\n    }\n    p = buflist_data;\n\n    for (; buf != NULL && !got_int; buf = buflist_data != NULL\n\t    ? (++p < buflist_data + buflist.ga_len ? *p : NULL)\n\t    : buf->b_next)\n#else\n    for (buf = firstbuf; buf != NULL && !got_int; buf = buf->b_next)\n#endif\n    {\n#ifdef FEAT_TERMINAL\n\tjob_running = term_job_running(buf->b_term);\n\tjob_none_open = term_none_open(buf->b_term);\n#endif\n\t// skip unlisted buffers, unless ! was used\n\tif ((!buf->b_p_bl && !eap->forceit && !vim_strchr(eap->arg, 'u'))\n\t\t|| (vim_strchr(eap->arg, 'u') && buf->b_p_bl)\n\t\t|| (vim_strchr(eap->arg, '+')\n\t\t\t&& ((buf->b_flags & BF_READERR) || !bufIsChanged(buf)))\n\t\t|| (vim_strchr(eap->arg, 'a')\n\t\t\t&& (buf->b_ml.ml_mfp == NULL || buf->b_nwindows == 0))\n\t\t|| (vim_strchr(eap->arg, 'h')\n\t\t\t&& (buf->b_ml.ml_mfp == NULL || buf->b_nwindows != 0))\n#ifdef FEAT_TERMINAL\n\t\t|| (vim_strchr(eap->arg, 'R')\n\t\t\t&& (!job_running || (job_running && job_none_open)))\n\t\t|| (vim_strchr(eap->arg, '?')\n\t\t\t&& (!job_running || (job_running && !job_none_open)))\n\t\t|| (vim_strchr(eap->arg, 'F')\n\t\t\t&& (job_running || buf->b_term == NULL))\n#endif\n\t\t|| (vim_strchr(eap->arg, '-') && buf->b_p_ma)\n\t\t|| (vim_strchr(eap->arg, '=') && !buf->b_p_ro)\n\t\t|| (vim_strchr(eap->arg, 'x') && !(buf->b_flags & BF_READERR))\n\t\t|| (vim_strchr(eap->arg, '%') && buf != curbuf)\n\t\t|| (vim_strchr(eap->arg, '#')\n\t\t      && (buf == curbuf || curwin->w_alt_fnum != buf->b_fnum)))\n\t    continue;\n\tif (buf_spname(buf) != NULL)\n\t    vim_strncpy(NameBuff, buf_spname(buf), MAXPATHL - 1);\n\telse\n\t    home_replace(buf, buf->b_fname, NameBuff, MAXPATHL, TRUE);\n\tif (message_filtered(NameBuff))\n\t    continue;\n\n\tchanged_char = (buf->b_flags & BF_READERR) ? 'x'\n\t\t\t\t\t     : (bufIsChanged(buf) ? '+' : ' ');\n#ifdef FEAT_TERMINAL\n\tif (job_running)\n\t{\n\t    if (job_none_open)\n\t\tro_char = '?';\n\t    else\n\t\tro_char = 'R';\n\t    changed_char = ' ';  // bufIsChanged() returns TRUE to avoid\n\t\t\t\t // closing, but it's not actually changed.\n\t}\n\telse if (buf->b_term != NULL)\n\t    ro_char = 'F';\n\telse\n#endif\n\t    ro_char = !buf->b_p_ma ? '-' : (buf->b_p_ro ? '=' : ' ');\n\n\tmsg_putchar('\\n');\n\tlen = vim_snprintf((char *)IObuff, IOSIZE - 20, \"%3d%c%c%c%c%c \\\"%s\\\"\",\n\t\tbuf->b_fnum,\n\t\tbuf->b_p_bl ? ' ' : 'u',\n\t\tbuf == curbuf ? '%' :\n\t\t\t(curwin->w_alt_fnum == buf->b_fnum ? '#' : ' '),\n\t\tbuf->b_ml.ml_mfp == NULL ? ' ' :\n\t\t\t(buf->b_nwindows == 0 ? 'h' : 'a'),\n\t\tro_char,\n\t\tchanged_char,\n\t\tNameBuff);\n\tif (len > IOSIZE - 20)\n\t    len = IOSIZE - 20;\n\n\t// put \"line 999\" in column 40 or after the file name\n\ti = 40 - vim_strsize(IObuff);\n\tdo\n\t    IObuff[len++] = ' ';\n\twhile (--i > 0 && len < IOSIZE - 18);\n#ifdef FEAT_VIMINFO\n\tif (vim_strchr(eap->arg, 't') && buf->b_last_used)\n\t    add_time(IObuff + len, (size_t)(IOSIZE - len), buf->b_last_used);\n\telse\n#endif\n\t    vim_snprintf((char *)IObuff + len, (size_t)(IOSIZE - len),\n\t\t    _(\"line %ld\"), buf == curbuf ? curwin->w_cursor.lnum\n\t\t\t\t\t       : (long)buflist_findlnum(buf));\n\tmsg_outtrans(IObuff);\n\tout_flush();\t    // output one line at a time\n\tui_breakcheck();\n    }\n\n#ifdef FEAT_VIMINFO\n    if (buflist_data)\n\tga_clear(&buflist);\n#endif\n}\n\n/*\n * Get file name and line number for file 'fnum'.\n * Used by DoOneCmd() for translating '%' and '#'.\n * Used by insert_reg() and cmdline_paste() for '#' register.\n * Return FAIL if not found, OK for success.\n */\n    int\nbuflist_name_nr(\n    int\t\tfnum,\n    char_u\t**fname,\n    linenr_T\t*lnum)\n{\n    buf_T\t*buf;\n\n    buf = buflist_findnr(fnum);\n    if (buf == NULL || buf->b_fname == NULL)\n\treturn FAIL;\n\n    *fname = buf->b_fname;\n    *lnum = buflist_findlnum(buf);\n\n    return OK;\n}\n\n/*\n * Set the file name for \"buf\"' to \"ffname_arg\", short file name to\n * \"sfname_arg\".\n * The file name with the full path is also remembered, for when :cd is used.\n * Returns FAIL for failure (file name already in use by other buffer)\n *\tOK otherwise.\n */\n    int\nsetfname(\n    buf_T\t*buf,\n    char_u\t*ffname_arg,\n    char_u\t*sfname_arg,\n    int\t\tmessage)\t// give message when buffer already exists\n{\n    char_u\t*ffname = ffname_arg;\n    char_u\t*sfname = sfname_arg;\n    buf_T\t*obuf = NULL;\n#ifdef UNIX\n    stat_T\tst;\n#endif\n\n    if (ffname == NULL || *ffname == NUL)\n    {\n\t// Removing the name.\n\tif (buf->b_sfname != buf->b_ffname)\n\t    VIM_CLEAR(buf->b_sfname);\n\telse\n\t    buf->b_sfname = NULL;\n\tVIM_CLEAR(buf->b_ffname);\n#ifdef UNIX\n\tst.st_dev = (dev_T)-1;\n#endif\n    }\n    else\n    {\n\tfname_expand(buf, &ffname, &sfname); // will allocate ffname\n\tif (ffname == NULL)\t\t    // out of memory\n\t    return FAIL;\n\n\t/*\n\t * If the file name is already used in another buffer:\n\t * - if the buffer is loaded, fail\n\t * - if the buffer is not loaded, delete it from the list\n\t */\n#ifdef UNIX\n\tif (mch_stat((char *)ffname, &st) < 0)\n\t    st.st_dev = (dev_T)-1;\n#endif\n\tif (!(buf->b_flags & BF_DUMMY))\n#ifdef UNIX\n\t    obuf = buflist_findname_stat(ffname, &st);\n#else\n\t    obuf = buflist_findname(ffname);\n#endif\n\tif (obuf != NULL && obuf != buf)\n\t{\n\t    win_T\t*win;\n\t    tabpage_T   *tab;\n\t    int\t\tin_use = FALSE;\n\n\t    // during startup a window may use a buffer that is not loaded yet\n\t    FOR_ALL_TAB_WINDOWS(tab, win)\n\t\tif (win->w_buffer == obuf)\n\t\t    in_use = TRUE;\n\n\t    // it's loaded or used in a window, fail\n\t    if (obuf->b_ml.ml_mfp != NULL || in_use)\n\t    {\n\t\tif (message)\n\t\t    emsg(_(e_buffer_with_this_name_already_exists));\n\t\tvim_free(ffname);\n\t\treturn FAIL;\n\t    }\n\t    // delete from the list\n\t    close_buffer(NULL, obuf, DOBUF_WIPE, FALSE, FALSE);\n\t}\n\tsfname = vim_strsave(sfname);\n\tif (ffname == NULL || sfname == NULL)\n\t{\n\t    vim_free(sfname);\n\t    vim_free(ffname);\n\t    return FAIL;\n\t}\n#ifdef USE_FNAME_CASE\n\tfname_case(sfname, 0);    // set correct case for short file name\n#endif\n\tif (buf->b_sfname != buf->b_ffname)\n\t    vim_free(buf->b_sfname);\n\tvim_free(buf->b_ffname);\n\tbuf->b_ffname = ffname;\n\tbuf->b_sfname = sfname;\n    }\n    buf->b_fname = buf->b_sfname;\n#ifdef UNIX\n    if (st.st_dev == (dev_T)-1)\n\tbuf->b_dev_valid = FALSE;\n    else\n    {\n\tbuf->b_dev_valid = TRUE;\n\tbuf->b_dev = st.st_dev;\n\tbuf->b_ino = st.st_ino;\n    }\n#endif\n\n    buf->b_shortname = FALSE;\n\n    buf_name_changed(buf);\n    return OK;\n}\n\n/*\n * Crude way of changing the name of a buffer.  Use with care!\n * The name should be relative to the current directory.\n */\n    void\nbuf_set_name(int fnum, char_u *name)\n{\n    buf_T\t*buf;\n\n    buf = buflist_findnr(fnum);\n    if (buf != NULL)\n    {\n\tif (buf->b_sfname != buf->b_ffname)\n\t    vim_free(buf->b_sfname);\n\tvim_free(buf->b_ffname);\n\tbuf->b_ffname = vim_strsave(name);\n\tbuf->b_sfname = NULL;\n\t// Allocate ffname and expand into full path.  Also resolves .lnk\n\t// files on Win32.\n\tfname_expand(buf, &buf->b_ffname, &buf->b_sfname);\n\tbuf->b_fname = buf->b_sfname;\n    }\n}\n\n/*\n * Take care of what needs to be done when the name of buffer \"buf\" has\n * changed.\n */\n    void\nbuf_name_changed(buf_T *buf)\n{\n    /*\n     * If the file name changed, also change the name of the swapfile\n     */\n    if (buf->b_ml.ml_mfp != NULL)\n\tml_setname(buf);\n\n#ifdef FEAT_TERMINAL\n    if (buf->b_term != NULL)\n\tterm_clear_status_text(buf->b_term);\n#endif\n\n    if (curwin->w_buffer == buf)\n\tcheck_arg_idx(curwin);\t// check file name for arg list\n    maketitle();\t\t// set window title\n    status_redraw_all();\t// status lines need to be redrawn\n    fmarks_check_names(buf);\t// check named file marks\n    ml_timestamp(buf);\t\t// reset timestamp\n}\n\n/*\n * set alternate file name for current window\n *\n * Used by do_one_cmd(), do_write() and do_ecmd().\n * Return the buffer.\n */\n    buf_T *\nsetaltfname(\n    char_u\t*ffname,\n    char_u\t*sfname,\n    linenr_T\tlnum)\n{\n    buf_T\t*buf;\n\n    // Create a buffer.  'buflisted' is not set if it's a new buffer\n    buf = buflist_new(ffname, sfname, lnum, 0);\n    if (buf != NULL && (cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\tcurwin->w_alt_fnum = buf->b_fnum;\n    return buf;\n}\n\n/*\n * Get alternate file name for current window.\n * Return NULL if there isn't any, and give error message if requested.\n */\n    char_u  *\ngetaltfname(\n    int\t\terrmsg)\t\t// give error message\n{\n    char_u\t*fname;\n    linenr_T\tdummy;\n\n    if (buflist_name_nr(0, &fname, &dummy) == FAIL)\n    {\n\tif (errmsg)\n\t    emsg(_(e_no_alternate_file));\n\treturn NULL;\n    }\n    return fname;\n}\n\n/*\n * Add a file name to the buflist and return its number.\n * Uses same flags as buflist_new(), except BLN_DUMMY.\n *\n * used by qf_init(), main() and doarglist()\n */\n    int\nbuflist_add(char_u *fname, int flags)\n{\n    buf_T\t*buf;\n\n    buf = buflist_new(fname, NULL, (linenr_T)0, flags);\n    if (buf != NULL)\n\treturn buf->b_fnum;\n    return 0;\n}\n\n#if defined(BACKSLASH_IN_FILENAME) || defined(PROTO)\n/*\n * Adjust slashes in file names.  Called after 'shellslash' was set.\n */\n    void\nbuflist_slash_adjust(void)\n{\n    buf_T\t*bp;\n\n    FOR_ALL_BUFFERS(bp)\n    {\n\tif (bp->b_ffname != NULL)\n\t    slash_adjust(bp->b_ffname);\n\tif (bp->b_sfname != NULL)\n\t    slash_adjust(bp->b_sfname);\n    }\n}\n#endif\n\n/*\n * Set alternate cursor position for the current buffer and window \"win\".\n * Also save the local window option values.\n */\n    void\nbuflist_altfpos(win_T *win)\n{\n    buflist_setfpos(curbuf, win, win->w_cursor.lnum, win->w_cursor.col, TRUE);\n}\n\n/*\n * Return TRUE if 'ffname' is not the same file as current file.\n * Fname must have a full path (expanded by mch_FullName()).\n */\n    int\notherfile(char_u *ffname)\n{\n    return otherfile_buf(curbuf, ffname\n#ifdef UNIX\n\t    , NULL\n#endif\n\t    );\n}\n\n    static int\notherfile_buf(\n    buf_T\t\t*buf,\n    char_u\t\t*ffname\n#ifdef UNIX\n    , stat_T\t\t*stp\n#endif\n    )\n{\n    // no name is different\n    if (ffname == NULL || *ffname == NUL || buf->b_ffname == NULL)\n\treturn TRUE;\n    if (fnamecmp(ffname, buf->b_ffname) == 0)\n\treturn FALSE;\n#ifdef UNIX\n    {\n\tstat_T\t    st;\n\n\t// If no stat_T given, get it now\n\tif (stp == NULL)\n\t{\n\t    if (!buf->b_dev_valid || mch_stat((char *)ffname, &st) < 0)\n\t\tst.st_dev = (dev_T)-1;\n\t    stp = &st;\n\t}\n\t// Use dev/ino to check if the files are the same, even when the names\n\t// are different (possible with links).  Still need to compare the\n\t// name above, for when the file doesn't exist yet.\n\t// Problem: The dev/ino changes when a file is deleted (and created\n\t// again) and remains the same when renamed/moved.  We don't want to\n\t// mch_stat() each buffer each time, that would be too slow.  Get the\n\t// dev/ino again when they appear to match, but not when they appear\n\t// to be different: Could skip a buffer when it's actually the same\n\t// file.\n\tif (buf_same_ino(buf, stp))\n\t{\n\t    buf_setino(buf);\n\t    if (buf_same_ino(buf, stp))\n\t\treturn FALSE;\n\t}\n    }\n#endif\n    return TRUE;\n}\n\n#if defined(UNIX) || defined(PROTO)\n/*\n * Set inode and device number for a buffer.\n * Must always be called when b_fname is changed!.\n */\n    void\nbuf_setino(buf_T *buf)\n{\n    stat_T\tst;\n\n    if (buf->b_fname != NULL && mch_stat((char *)buf->b_fname, &st) >= 0)\n    {\n\tbuf->b_dev_valid = TRUE;\n\tbuf->b_dev = st.st_dev;\n\tbuf->b_ino = st.st_ino;\n    }\n    else\n\tbuf->b_dev_valid = FALSE;\n}\n\n/*\n * Return TRUE if dev/ino in buffer \"buf\" matches with \"stp\".\n */\n    static int\nbuf_same_ino(\n    buf_T\t*buf,\n    stat_T\t*stp)\n{\n    return (buf->b_dev_valid\n\t    && stp->st_dev == buf->b_dev\n\t    && stp->st_ino == buf->b_ino);\n}\n#endif\n\n/*\n * Print info about the current buffer.\n */\n    void\nfileinfo(\n    int fullname,\t    // when non-zero print full path\n    int shorthelp,\n    int\tdont_truncate)\n{\n    char_u\t*name;\n    int\t\tn;\n    char\t*p;\n    char\t*buffer;\n    size_t\tlen;\n\n    buffer = alloc(IOSIZE);\n    if (buffer == NULL)\n\treturn;\n\n    if (fullname > 1)\t    // 2 CTRL-G: include buffer number\n    {\n\tvim_snprintf(buffer, IOSIZE, \"buf %d: \", curbuf->b_fnum);\n\tp = buffer + STRLEN(buffer);\n    }\n    else\n\tp = buffer;\n\n    *p++ = '\"';\n    if (buf_spname(curbuf) != NULL)\n\tvim_strncpy((char_u *)p, buf_spname(curbuf), IOSIZE - (p - buffer) - 1);\n    else\n    {\n\tif (!fullname && curbuf->b_fname != NULL)\n\t    name = curbuf->b_fname;\n\telse\n\t    name = curbuf->b_ffname;\n\thome_replace(shorthelp ? curbuf : NULL, name, (char_u *)p,\n\t\t\t\t\t  (int)(IOSIZE - (p - buffer)), TRUE);\n    }\n\n    vim_snprintf_add(buffer, IOSIZE, \"\\\"%s%s%s%s%s%s\",\n\t    curbufIsChanged() ? (shortmess(SHM_MOD)\n\t\t\t\t\t  ?  \" [+]\" : _(\" [Modified]\")) : \" \",\n\t    (curbuf->b_flags & BF_NOTEDITED)\n#ifdef FEAT_QUICKFIX\n\t\t    && !bt_dontwrite(curbuf)\n#endif\n\t\t\t\t\t? _(\"[Not edited]\") : \"\",\n\t    (curbuf->b_flags & BF_NEW)\n#ifdef FEAT_QUICKFIX\n\t\t    && !bt_dontwrite(curbuf)\n#endif\n\t\t\t\t\t   ? new_file_message() : \"\",\n\t    (curbuf->b_flags & BF_READERR) ? _(\"[Read errors]\") : \"\",\n\t    curbuf->b_p_ro ? (shortmess(SHM_RO) ? _(\"[RO]\")\n\t\t\t\t\t\t      : _(\"[readonly]\")) : \"\",\n\t    (curbufIsChanged() || (curbuf->b_flags & BF_WRITE_MASK)\n\t\t\t\t\t\t\t  || curbuf->b_p_ro) ?\n\t\t\t\t\t\t\t\t    \" \" : \"\");\n    // With 32 bit longs and more than 21,474,836 lines multiplying by 100\n    // causes an overflow, thus for large numbers divide instead.\n    if (curwin->w_cursor.lnum > 1000000L)\n\tn = (int)(((long)curwin->w_cursor.lnum) /\n\t\t\t\t   ((long)curbuf->b_ml.ml_line_count / 100L));\n    else\n\tn = (int)(((long)curwin->w_cursor.lnum * 100L) /\n\t\t\t\t\t    (long)curbuf->b_ml.ml_line_count);\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\tvim_snprintf_add(buffer, IOSIZE, \"%s\", _(no_lines_msg));\n#ifdef FEAT_CMDL_INFO\n    else if (p_ru)\n\t// Current line and column are already on the screen -- webb\n\tvim_snprintf_add(buffer, IOSIZE,\n\t\tNGETTEXT(\"%ld line --%d%%--\", \"%ld lines --%d%%--\",\n\t\t\t\t\t\t   curbuf->b_ml.ml_line_count),\n\t\t(long)curbuf->b_ml.ml_line_count, n);\n#endif\n    else\n    {\n\tvim_snprintf_add(buffer, IOSIZE,\n\t\t_(\"line %ld of %ld --%d%%-- col \"),\n\t\t(long)curwin->w_cursor.lnum,\n\t\t(long)curbuf->b_ml.ml_line_count,\n\t\tn);\n\tvalidate_virtcol();\n\tlen = STRLEN(buffer);\n\tcol_print((char_u *)buffer + len, IOSIZE - len,\n\t\t   (int)curwin->w_cursor.col + 1, (int)curwin->w_virtcol + 1);\n    }\n\n    (void)append_arg_number(curwin, (char_u *)buffer, IOSIZE,\n\t\t\t\t\t\t\t !shortmess(SHM_FILE));\n\n    if (dont_truncate)\n    {\n\t// Temporarily set msg_scroll to avoid the message being truncated.\n\t// First call msg_start() to get the message in the right place.\n\tmsg_start();\n\tn = msg_scroll;\n\tmsg_scroll = TRUE;\n\tmsg(buffer);\n\tmsg_scroll = n;\n    }\n    else\n    {\n\tp = msg_trunc_attr(buffer, FALSE, 0);\n\tif (restart_edit != 0 || (msg_scrolled && !need_wait_return))\n\t    // Need to repeat the message after redrawing when:\n\t    // - When restart_edit is set (otherwise there will be a delay\n\t    //   before redrawing).\n\t    // - When the screen was scrolled but there is no wait-return\n\t    //   prompt.\n\t    set_keep_msg((char_u *)p, 0);\n    }\n\n    vim_free(buffer);\n}\n\n    void\ncol_print(\n    char_u  *buf,\n    size_t  buflen,\n    int\t    col,\n    int\t    vcol)\n{\n    if (col == vcol)\n\tvim_snprintf((char *)buf, buflen, \"%d\", col);\n    else\n\tvim_snprintf((char *)buf, buflen, \"%d-%d\", col, vcol);\n}\n\nstatic char_u *lasttitle = NULL;\nstatic char_u *lasticon = NULL;\n\n/*\n * Put the file name in the title bar and icon of the window.\n */\n    void\nmaketitle(void)\n{\n    char_u\t*p;\n    char_u\t*title_str = NULL;\n    char_u\t*icon_str = NULL;\n    int\t\tmaxlen = 0;\n    int\t\tlen;\n    int\t\tmustset;\n    char_u\tbuf[IOSIZE];\n    int\t\toff;\n\n    if (!redrawing())\n    {\n\t// Postpone updating the title when 'lazyredraw' is set.\n\tneed_maketitle = TRUE;\n\treturn;\n    }\n\n    need_maketitle = FALSE;\n    if (!p_title && !p_icon && lasttitle == NULL && lasticon == NULL)\n\treturn;  // nothing to do\n\n    if (p_title)\n    {\n\tif (p_titlelen > 0)\n\t{\n\t    maxlen = p_titlelen * Columns / 100;\n\t    if (maxlen < 10)\n\t\tmaxlen = 10;\n\t}\n\n\ttitle_str = buf;\n\tif (*p_titlestring != NUL)\n\t{\n#ifdef FEAT_STL_OPT\n\t    if (stl_syntax & STL_IN_TITLE)\n\t    {\n\t\tint\tuse_sandbox = FALSE;\n\t\tint\tcalled_emsg_before = called_emsg;\n\n# ifdef FEAT_EVAL\n\t\tuse_sandbox = was_set_insecurely((char_u *)\"titlestring\", 0);\n# endif\n\t\tbuild_stl_str_hl(curwin, title_str, sizeof(buf),\n\t\t\t\t\t      p_titlestring, use_sandbox,\n\t\t\t\t\t      0, maxlen, NULL, NULL);\n\t\tif (called_emsg > called_emsg_before)\n\t\t    set_string_option_direct((char_u *)\"titlestring\", -1,\n\t\t\t\t\t   (char_u *)\"\", OPT_FREE, SID_ERROR);\n\t    }\n\t    else\n#endif\n\t\ttitle_str = p_titlestring;\n\t}\n\telse\n\t{\n\t    // format: \"fname + (path) (1 of 2) - VIM\"\n\n#define SPACE_FOR_FNAME (IOSIZE - 100)\n#define SPACE_FOR_DIR   (IOSIZE - 20)\n#define SPACE_FOR_ARGNR (IOSIZE - 10)  // at least room for \" - VIM\"\n\t    if (curbuf->b_fname == NULL)\n\t\tvim_strncpy(buf, (char_u *)_(\"[No Name]\"), SPACE_FOR_FNAME);\n#ifdef FEAT_TERMINAL\n\t    else if (curbuf->b_term != NULL)\n\t    {\n\t\tvim_strncpy(buf, term_get_status_text(curbuf->b_term),\n\t\t\t\t\t\t\t      SPACE_FOR_FNAME);\n\t    }\n#endif\n\t    else\n\t    {\n\t\tp = transstr(gettail(curbuf->b_fname));\n\t\tvim_strncpy(buf, p, SPACE_FOR_FNAME);\n\t\tvim_free(p);\n\t    }\n\n#ifdef FEAT_TERMINAL\n\t    if (curbuf->b_term == NULL)\n#endif\n\t\tswitch (bufIsChanged(curbuf)\n\t\t\t+ (curbuf->b_p_ro * 2)\n\t\t\t+ (!curbuf->b_p_ma * 4))\n\t\t{\n\t\t    case 1: STRCAT(buf, \" +\"); break;\n\t\t    case 2: STRCAT(buf, \" =\"); break;\n\t\t    case 3: STRCAT(buf, \" =+\"); break;\n\t\t    case 4:\n\t\t    case 6: STRCAT(buf, \" -\"); break;\n\t\t    case 5:\n\t\t    case 7: STRCAT(buf, \" -+\"); break;\n\t\t}\n\n\t    if (curbuf->b_fname != NULL\n#ifdef FEAT_TERMINAL\n\t\t    && curbuf->b_term == NULL\n#endif\n\t\t    )\n\t    {\n\t\t// Get path of file, replace home dir with ~\n\t\toff = (int)STRLEN(buf);\n\t\tbuf[off++] = ' ';\n\t\tbuf[off++] = '(';\n\t\thome_replace(curbuf, curbuf->b_ffname,\n\t\t\t\t\tbuf + off, SPACE_FOR_DIR - off, TRUE);\n#ifdef BACKSLASH_IN_FILENAME\n\t\t// avoid \"c:/name\" to be reduced to \"c\"\n\t\tif (isalpha(buf[off]) && buf[off + 1] == ':')\n\t\t    off += 2;\n#endif\n\t\t// remove the file name\n\t\tp = gettail_sep(buf + off);\n\t\tif (p == buf + off)\n\t\t{\n\t\t    // must be a help buffer\n\t\t    vim_strncpy(buf + off, (char_u *)_(\"help\"),\n\t\t\t\t\t   (size_t)(SPACE_FOR_DIR - off - 1));\n\t\t}\n\t\telse\n\t\t    *p = NUL;\n\n\t\t// Translate unprintable chars and concatenate.  Keep some\n\t\t// room for the server name.  When there is no room (very long\n\t\t// file name) use (...).\n\t\tif (off < SPACE_FOR_DIR)\n\t\t{\n\t\t    p = transstr(buf + off);\n\t\t    vim_strncpy(buf + off, p, (size_t)(SPACE_FOR_DIR - off));\n\t\t    vim_free(p);\n\t\t}\n\t\telse\n\t\t{\n\t\t    vim_strncpy(buf + off, (char_u *)\"...\",\n\t\t\t\t\t     (size_t)(SPACE_FOR_ARGNR - off));\n\t\t}\n\t\tSTRCAT(buf, \")\");\n\t    }\n\n\t    append_arg_number(curwin, buf, SPACE_FOR_ARGNR, FALSE);\n\n#if defined(FEAT_CLIENTSERVER)\n\t    if (serverName != NULL)\n\t    {\n\t\tSTRCAT(buf, \" - \");\n\t\tvim_strcat(buf, serverName, IOSIZE);\n\t    }\n\t    else\n#endif\n\t\tSTRCAT(buf, \" - VIM\");\n\n\t    if (maxlen > 0)\n\t    {\n\t\t// make it shorter by removing a bit in the middle\n\t\tif (vim_strsize(buf) > maxlen)\n\t\t    trunc_string(buf, buf, maxlen, IOSIZE);\n\t    }\n\t}\n    }\n    mustset = value_changed(title_str, &lasttitle);\n\n    if (p_icon)\n    {\n\ticon_str = buf;\n\tif (*p_iconstring != NUL)\n\t{\n#ifdef FEAT_STL_OPT\n\t    if (stl_syntax & STL_IN_ICON)\n\t    {\n\t\tint\tuse_sandbox = FALSE;\n\t\tint\tcalled_emsg_before = called_emsg;\n\n# ifdef FEAT_EVAL\n\t\tuse_sandbox = was_set_insecurely((char_u *)\"iconstring\", 0);\n# endif\n\t\tbuild_stl_str_hl(curwin, icon_str, sizeof(buf),\n\t\t\t\t\t\t    p_iconstring, use_sandbox,\n\t\t\t\t\t\t    0, 0, NULL, NULL);\n\t\tif (called_emsg > called_emsg_before)\n\t\t    set_string_option_direct((char_u *)\"iconstring\", -1,\n\t\t\t\t\t   (char_u *)\"\", OPT_FREE, SID_ERROR);\n\t    }\n\t    else\n#endif\n\t\ticon_str = p_iconstring;\n\t}\n\telse\n\t{\n\t    if (buf_spname(curbuf) != NULL)\n\t\tp = buf_spname(curbuf);\n\t    else\t\t    // use file name only in icon\n\t\tp = gettail(curbuf->b_ffname);\n\t    *icon_str = NUL;\n\t    // Truncate name at 100 bytes.\n\t    len = (int)STRLEN(p);\n\t    if (len > 100)\n\t    {\n\t\tlen -= 100;\n\t\tif (has_mbyte)\n\t\t    len += (*mb_tail_off)(p, p + len) + 1;\n\t\tp += len;\n\t    }\n\t    STRCPY(icon_str, p);\n\t    trans_characters(icon_str, IOSIZE);\n\t}\n    }\n\n    mustset |= value_changed(icon_str, &lasticon);\n\n    if (mustset)\n\tresettitle();\n}\n\n/*\n * Used for title and icon: Check if \"str\" differs from \"*last\".  Set \"*last\"\n * from \"str\" if it does.\n * Return TRUE if resettitle() is to be called.\n */\n    static int\nvalue_changed(char_u *str, char_u **last)\n{\n    if ((str == NULL) != (*last == NULL)\n\t    || (str != NULL && *last != NULL && STRCMP(str, *last) != 0))\n    {\n\tvim_free(*last);\n\tif (str == NULL)\n\t{\n\t    *last = NULL;\n\t    mch_restore_title(\n\t\t  last == &lasttitle ? SAVE_RESTORE_TITLE : SAVE_RESTORE_ICON);\n\t}\n\telse\n\t{\n\t    *last = vim_strsave(str);\n\t    return TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n/*\n * Put current window title back (used after calling a shell)\n */\n    void\nresettitle(void)\n{\n    mch_settitle(lasttitle, lasticon);\n}\n\n# if defined(EXITFREE) || defined(PROTO)\n    void\nfree_titles(void)\n{\n    vim_free(lasttitle);\n    vim_free(lasticon);\n}\n# endif\n\n\n#if defined(FEAT_STL_OPT) || defined(FEAT_GUI_TABLINE) || defined(PROTO)\n\n/*\n * Used for building in the status line.\n */\ntypedef struct\n{\n    char_u\t*stl_start;\n    int\t\tstl_minwid;\n    int\t\tstl_maxwid;\n    enum {\n\tNormal,\n\tEmpty,\n\tGroup,\n\tMiddle,\n\tHighlight,\n\tTabPage,\n\tTrunc\n    }\t\tstl_type;\n} stl_item_T;\n\nstatic size_t\t\tstl_items_len = 20; // Initial value, grows as needed.\nstatic stl_item_T      *stl_items = NULL;\nstatic int\t       *stl_groupitem = NULL;\nstatic stl_hlrec_T     *stl_hltab = NULL;\nstatic stl_hlrec_T     *stl_tabtab = NULL;\n\n/*\n * Build a string from the status line items in \"fmt\".\n * Return length of string in screen cells.\n *\n * Normally works for window \"wp\", except when working for 'tabline' then it\n * is \"curwin\".\n *\n * Items are drawn interspersed with the text that surrounds it\n * Specials: %-<wid>(xxx%) => group, %= => middle marker, %< => truncation\n * Item: %-<minwid>.<maxwid><itemch> All but <itemch> are optional\n *\n * If maxwidth is not zero, the string will be filled at any middle marker\n * or truncated if too long, fillchar is used for all whitespace.\n */\n    int\nbuild_stl_str_hl(\n    win_T\t*wp,\n    char_u\t*out,\t\t// buffer to write into != NameBuff\n    size_t\toutlen,\t\t// length of out[]\n    char_u\t*fmt,\n    int\t\tuse_sandbox UNUSED, // \"fmt\" was set insecurely, use sandbox\n    int\t\tfillchar,\n    int\t\tmaxwidth,\n    stl_hlrec_T **hltab,\t// return: HL attributes (can be NULL)\n    stl_hlrec_T **tabtab)\t// return: tab page nrs (can be NULL)\n{\n    linenr_T\tlnum;\n    size_t\tlen;\n    char_u\t*p;\n    char_u\t*s;\n    char_u\t*t;\n    int\t\tbyteval;\n#ifdef FEAT_EVAL\n    win_T\t*save_curwin;\n    buf_T\t*save_curbuf;\n    int\t\tsave_VIsual_active;\n#endif\n    int\t\tempty_line;\n    colnr_T\tvirtcol;\n    long\tl;\n    long\tn;\n    int\t\tprevchar_isflag;\n    int\t\tprevchar_isitem;\n    int\t\titemisflag;\n    int\t\tfillable;\n    char_u\t*str;\n    long\tnum;\n    int\t\twidth;\n    int\t\titemcnt;\n    int\t\tcuritem;\n    int\t\tgroup_end_userhl;\n    int\t\tgroup_start_userhl;\n    int\t\tgroupdepth;\n#ifdef FEAT_EVAL\n    int\t\tevaldepth;\n#endif\n    int\t\tminwid;\n    int\t\tmaxwid;\n    int\t\tzeropad;\n    char_u\tbase;\n    char_u\topt;\n#define TMPLEN 70\n    char_u\tbuf_tmp[TMPLEN];\n    char_u\twin_tmp[TMPLEN];\n    char_u\t*usefmt = fmt;\n    stl_hlrec_T *sp;\n    int\t\tsave_must_redraw = must_redraw;\n    int\t\tsave_redr_type = curwin->w_redr_type;\n    int\t\tsave_KeyTyped = KeyTyped;\n\n    if (stl_items == NULL)\n    {\n\tstl_items = ALLOC_MULT(stl_item_T, stl_items_len);\n\tstl_groupitem = ALLOC_MULT(int, stl_items_len);\n\n\t// Allocate one more, because the last element is used to indicate the\n\t// end of the list.\n\tstl_hltab  = ALLOC_MULT(stl_hlrec_T, stl_items_len + 1);\n\tstl_tabtab = ALLOC_MULT(stl_hlrec_T, stl_items_len + 1);\n    }\n\n#ifdef FEAT_EVAL\n    /*\n     * When the format starts with \"%!\" then evaluate it as an expression and\n     * use the result as the actual format string.\n     */\n    if (fmt[0] == '%' && fmt[1] == '!')\n    {\n\ttypval_T\ttv;\n\n\ttv.v_type = VAR_NUMBER;\n\ttv.vval.v_number = wp->w_id;\n\tset_var((char_u *)\"g:statusline_winid\", &tv, FALSE);\n\n\tusefmt = eval_to_string_safe(fmt + 2, use_sandbox, FALSE);\n\tif (usefmt == NULL)\n\t    usefmt = fmt;\n\n\tdo_unlet((char_u *)\"g:statusline_winid\", TRUE);\n    }\n#endif\n\n    if (fillchar == 0)\n\tfillchar = ' ';\n\n    // The cursor in windows other than the current one isn't always\n    // up-to-date, esp. because of autocommands and timers.\n    lnum = wp->w_cursor.lnum;\n    if (lnum > wp->w_buffer->b_ml.ml_line_count)\n    {\n\tlnum = wp->w_buffer->b_ml.ml_line_count;\n\twp->w_cursor.lnum = lnum;\n    }\n\n    // Get line & check if empty (cursorpos will show \"0-1\").  Note that\n    // p will become invalid when getting another buffer line.\n    p = ml_get_buf(wp->w_buffer, lnum, FALSE);\n    empty_line = (*p == NUL);\n\n    // Get the byte value now, in case we need it below. This is more efficient\n    // than making a copy of the line.\n    len = STRLEN(p);\n    if (wp->w_cursor.col > (colnr_T)len)\n    {\n\t// Line may have changed since checking the cursor column, or the lnum\n\t// was adjusted above.\n\twp->w_cursor.col = (colnr_T)len;\n\twp->w_cursor.coladd = 0;\n\tbyteval = 0;\n    }\n    else\n\tbyteval = (*mb_ptr2char)(p + wp->w_cursor.col);\n\n    groupdepth = 0;\n#ifdef FEAT_EVAL\n    evaldepth = 0;\n#endif\n    p = out;\n    curitem = 0;\n    prevchar_isflag = TRUE;\n    prevchar_isitem = FALSE;\n    for (s = usefmt; *s; )\n    {\n\tif (curitem == (int)stl_items_len)\n\t{\n\t    size_t\tnew_len = stl_items_len * 3 / 2;\n\t    stl_item_T\t*new_items;\n\t    int\t\t*new_groupitem;\n\t    stl_hlrec_T\t*new_hlrec;\n\n\t    new_items = vim_realloc(stl_items, sizeof(stl_item_T) * new_len);\n\t    if (new_items == NULL)\n\t\tbreak;\n\t    stl_items = new_items;\n\t    new_groupitem = vim_realloc(stl_groupitem, sizeof(int) * new_len);\n\t    if (new_groupitem == NULL)\n\t\tbreak;\n\t    stl_groupitem = new_groupitem;\n\t    new_hlrec = vim_realloc(stl_hltab,\n\t\t\t\t\t  sizeof(stl_hlrec_T) * (new_len + 1));\n\t    if (new_hlrec == NULL)\n\t\tbreak;\n\t    stl_hltab = new_hlrec;\n\t    new_hlrec = vim_realloc(stl_tabtab,\n\t\t\t\t\t  sizeof(stl_hlrec_T) * (new_len + 1));\n\t    if (new_hlrec == NULL)\n\t\tbreak;\n\t    stl_tabtab = new_hlrec;\n\t    stl_items_len = new_len;\n\t}\n\n\tif (*s != NUL && *s != '%')\n\t    prevchar_isflag = prevchar_isitem = FALSE;\n\n\t/*\n\t * Handle up to the next '%' or the end.\n\t */\n\twhile (*s != NUL && *s != '%' && p + 1 < out + outlen)\n\t    *p++ = *s++;\n\tif (*s == NUL || p + 1 >= out + outlen)\n\t    break;\n\n\t/*\n\t * Handle one '%' item.\n\t */\n\ts++;\n\tif (*s == NUL)  // ignore trailing %\n\t    break;\n\tif (*s == '%')\n\t{\n\t    if (p + 1 >= out + outlen)\n\t\tbreak;\n\t    *p++ = *s++;\n\t    prevchar_isflag = prevchar_isitem = FALSE;\n\t    continue;\n\t}\n\tif (*s == STL_MIDDLEMARK)\n\t{\n\t    s++;\n\t    if (groupdepth > 0)\n\t\tcontinue;\n\t    stl_items[curitem].stl_type = Middle;\n\t    stl_items[curitem++].stl_start = p;\n\t    continue;\n\t}\n\tif (*s == STL_TRUNCMARK)\n\t{\n\t    s++;\n\t    stl_items[curitem].stl_type = Trunc;\n\t    stl_items[curitem++].stl_start = p;\n\t    continue;\n\t}\n\tif (*s == ')')\n\t{\n\t    s++;\n\t    if (groupdepth < 1)\n\t\tcontinue;\n\t    groupdepth--;\n\n\t    t = stl_items[stl_groupitem[groupdepth]].stl_start;\n\t    *p = NUL;\n\t    l = vim_strsize(t);\n\t    if (curitem > stl_groupitem[groupdepth] + 1\n\t\t    && stl_items[stl_groupitem[groupdepth]].stl_minwid == 0)\n\t    {\n\t\t// remove group if all items are empty and highlight group\n\t\t// doesn't change\n\t\tgroup_start_userhl = group_end_userhl = 0;\n\t\tfor (n = stl_groupitem[groupdepth] - 1; n >= 0; n--)\n\t\t{\n\t\t    if (stl_items[n].stl_type == Highlight)\n\t\t    {\n\t\t\tgroup_start_userhl = group_end_userhl =\n\t\t\t\t\t\t       stl_items[n].stl_minwid;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tfor (n = stl_groupitem[groupdepth] + 1; n < curitem; n++)\n\t\t{\n\t\t    if (stl_items[n].stl_type == Normal)\n\t\t\tbreak;\n\t\t    if (stl_items[n].stl_type == Highlight)\n\t\t\tgroup_end_userhl = stl_items[n].stl_minwid;\n\t\t}\n\t\tif (n == curitem && group_start_userhl == group_end_userhl)\n\t\t{\n\t\t    // empty group\n\t\t    p = t;\n\t\t    l = 0;\n\t\t    for (n = stl_groupitem[groupdepth] + 1; n < curitem; n++)\n\t\t    {\n\t\t\t// do not use the highlighting from the removed group\n\t\t\tif (stl_items[n].stl_type == Highlight)\n\t\t\t    stl_items[n].stl_type = Empty;\n\t\t\t// adjust the start position of TabPage to the next\n\t\t\t// item position\n\t\t\tif (stl_items[n].stl_type == TabPage)\n\t\t\t    stl_items[n].stl_start = p;\n\t\t    }\n\t\t}\n\t    }\n\t    if (l > stl_items[stl_groupitem[groupdepth]].stl_maxwid)\n\t    {\n\t\t// truncate, remove n bytes of text at the start\n\t\tif (has_mbyte)\n\t\t{\n\t\t    // Find the first character that should be included.\n\t\t    n = 0;\n\t\t    while (l >= stl_items[stl_groupitem[groupdepth]].stl_maxwid)\n\t\t    {\n\t\t\tl -= ptr2cells(t + n);\n\t\t\tn += (*mb_ptr2len)(t + n);\n\t\t    }\n\t\t}\n\t\telse\n\t\t    n = (long)(p - t) - stl_items[stl_groupitem[groupdepth]]\n\t\t\t\t\t\t\t       .stl_maxwid + 1;\n\n\t\t*t = '<';\n\t\tmch_memmove(t + 1, t + n, (size_t)(p - (t + n)));\n\t\tp = p - n + 1;\n\n\t\t// Fill up space left over by half a double-wide char.\n\t\twhile (++l < stl_items[stl_groupitem[groupdepth]].stl_minwid)\n\t\t    MB_CHAR2BYTES(fillchar, p);\n\n\t\t// correct the start of the items for the truncation\n\t\tfor (l = stl_groupitem[groupdepth] + 1; l < curitem; l++)\n\t\t{\n\t\t    // Minus one for the leading '<' added above.\n\t\t    stl_items[l].stl_start -= n - 1;\n\t\t    if (stl_items[l].stl_start < t)\n\t\t\tstl_items[l].stl_start = t;\n\t\t}\n\t    }\n\t    else if (abs(stl_items[stl_groupitem[groupdepth]].stl_minwid) > l)\n\t    {\n\t\t// fill\n\t\tn = stl_items[stl_groupitem[groupdepth]].stl_minwid;\n\t\tif (n < 0)\n\t\t{\n\t\t    // fill by appending characters\n\t\t    n = 0 - n;\n\t\t    while (l++ < n && p + 1 < out + outlen)\n\t\t\tMB_CHAR2BYTES(fillchar, p);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // fill by inserting characters\n\t\t    l = (n - l) * MB_CHAR2LEN(fillchar);\n\t\t    mch_memmove(t + l, t, (size_t)(p - t));\n\t\t    if (p + l >= out + outlen)\n\t\t\tl = (long)((out + outlen) - p - 1);\n\t\t    p += l;\n\t\t    for (n = stl_groupitem[groupdepth] + 1; n < curitem; n++)\n\t\t\tstl_items[n].stl_start += l;\n\t\t    for ( ; l > 0; l--)\n\t\t\tMB_CHAR2BYTES(fillchar, t);\n\t\t}\n\t    }\n\t    continue;\n\t}\n\tminwid = 0;\n\tmaxwid = 9999;\n\tzeropad = FALSE;\n\tl = 1;\n\tif (*s == '0')\n\t{\n\t    s++;\n\t    zeropad = TRUE;\n\t}\n\tif (*s == '-')\n\t{\n\t    s++;\n\t    l = -1;\n\t}\n\tif (VIM_ISDIGIT(*s))\n\t{\n\t    minwid = (int)getdigits(&s);\n\t    if (minwid < 0)\t// overflow\n\t\tminwid = 0;\n\t}\n\tif (*s == STL_USER_HL)\n\t{\n\t    stl_items[curitem].stl_type = Highlight;\n\t    stl_items[curitem].stl_start = p;\n\t    stl_items[curitem].stl_minwid = minwid > 9 ? 1 : minwid;\n\t    s++;\n\t    curitem++;\n\t    continue;\n\t}\n\tif (*s == STL_TABPAGENR || *s == STL_TABCLOSENR)\n\t{\n\t    if (*s == STL_TABCLOSENR)\n\t    {\n\t\tif (minwid == 0)\n\t\t{\n\t\t    // %X ends the close label, go back to the previously\n\t\t    // define tab label nr.\n\t\t    for (n = curitem - 1; n >= 0; --n)\n\t\t\tif (stl_items[n].stl_type == TabPage\n\t\t\t\t\t       && stl_items[n].stl_minwid >= 0)\n\t\t\t{\n\t\t\t    minwid = stl_items[n].stl_minwid;\n\t\t\t    break;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t    // close nrs are stored as negative values\n\t\t    minwid = - minwid;\n\t    }\n\t    stl_items[curitem].stl_type = TabPage;\n\t    stl_items[curitem].stl_start = p;\n\t    stl_items[curitem].stl_minwid = minwid;\n\t    s++;\n\t    curitem++;\n\t    continue;\n\t}\n\tif (*s == '.')\n\t{\n\t    s++;\n\t    if (VIM_ISDIGIT(*s))\n\t    {\n\t\tmaxwid = (int)getdigits(&s);\n\t\tif (maxwid <= 0)\t// overflow\n\t\t    maxwid = 50;\n\t    }\n\t}\n\tminwid = (minwid > 50 ? 50 : minwid) * l;\n\tif (*s == '(')\n\t{\n\t    stl_groupitem[groupdepth++] = curitem;\n\t    stl_items[curitem].stl_type = Group;\n\t    stl_items[curitem].stl_start = p;\n\t    stl_items[curitem].stl_minwid = minwid;\n\t    stl_items[curitem].stl_maxwid = maxwid;\n\t    s++;\n\t    curitem++;\n\t    continue;\n\t}\n#ifdef FEAT_EVAL\n\t// Denotes end of expanded %{} block\n\tif (*s == '}' && evaldepth > 0)\n\t{\n\t    s++;\n\t    evaldepth--;\n\t    continue;\n\t}\n#endif\n\tif (vim_strchr(STL_ALL, *s) == NULL)\n\t{\n\t    s++;\n\t    continue;\n\t}\n\topt = *s++;\n\n\t// OK - now for the real work\n\tbase = 'D';\n\titemisflag = FALSE;\n\tfillable = TRUE;\n\tnum = -1;\n\tstr = NULL;\n\tswitch (opt)\n\t{\n\tcase STL_FILEPATH:\n\tcase STL_FULLPATH:\n\tcase STL_FILENAME:\n\t    fillable = FALSE;\t// don't change ' ' to fillchar\n\t    if (buf_spname(wp->w_buffer) != NULL)\n\t\tvim_strncpy(NameBuff, buf_spname(wp->w_buffer), MAXPATHL - 1);\n\t    else\n\t    {\n\t\tt = (opt == STL_FULLPATH) ? wp->w_buffer->b_ffname\n\t\t\t\t\t  : wp->w_buffer->b_fname;\n\t\thome_replace(wp->w_buffer, t, NameBuff, MAXPATHL, TRUE);\n\t    }\n\t    trans_characters(NameBuff, MAXPATHL);\n\t    if (opt != STL_FILENAME)\n\t\tstr = NameBuff;\n\t    else\n\t\tstr = gettail(NameBuff);\n\t    break;\n\n\tcase STL_VIM_EXPR: // '{'\n\t{\n#ifdef FEAT_EVAL\n\t    char_u *block_start = s - 1;\n#endif\n\t    int reevaluate = (*s == '%');\n\n\t    if (reevaluate)\n\t\ts++;\n\t    itemisflag = TRUE;\n\t    t = p;\n\t    while ((*s != '}' || (reevaluate && s[-1] != '%'))\n\t\t\t\t\t  && *s != NUL && p + 1 < out + outlen)\n\t\t*p++ = *s++;\n\t    if (*s != '}')\t// missing '}' or out of space\n\t\tbreak;\n\t    s++;\n\t    if (reevaluate)\n\t\tp[-1] = 0; // remove the % at the end of %{% expr %}\n\t    else\n\t\t*p = 0;\n\t    p = t;\n#ifdef FEAT_EVAL\n\t    vim_snprintf((char *)buf_tmp, sizeof(buf_tmp),\n\t\t\t\t\t\t\t \"%d\", curbuf->b_fnum);\n\t    set_internal_string_var((char_u *)\"g:actual_curbuf\", buf_tmp);\n\t    vim_snprintf((char *)win_tmp, sizeof(win_tmp), \"%d\", curwin->w_id);\n\t    set_internal_string_var((char_u *)\"g:actual_curwin\", win_tmp);\n\n\t    save_curbuf = curbuf;\n\t    save_curwin = curwin;\n\t    save_VIsual_active = VIsual_active;\n\t    curwin = wp;\n\t    curbuf = wp->w_buffer;\n\t    // Visual mode is only valid in the current window.\n\t    if (curwin != save_curwin)\n\t\tVIsual_active = FALSE;\n\n\t    str = eval_to_string_safe(p, use_sandbox, FALSE);\n\n\t    curwin = save_curwin;\n\t    curbuf = save_curbuf;\n\t    VIsual_active = save_VIsual_active;\n\t    do_unlet((char_u *)\"g:actual_curbuf\", TRUE);\n\t    do_unlet((char_u *)\"g:actual_curwin\", TRUE);\n\n\t    if (str != NULL && *str != 0)\n\t    {\n\t\tif (*skipdigits(str) == NUL)\n\t\t{\n\t\t    num = atoi((char *)str);\n\t\t    VIM_CLEAR(str);\n\t\t    itemisflag = FALSE;\n\t\t}\n\t    }\n\n\t    // If the output of the expression needs to be evaluated\n\t    // replace the %{} block with the result of evaluation\n\t    if (reevaluate && str != NULL && *str != 0\n\t\t    && strchr((const char *)str, '%') != NULL\n\t\t    && evaldepth < MAX_STL_EVAL_DEPTH)\n\t    {\n\t\tsize_t parsed_usefmt = (size_t)(block_start - usefmt);\n\t\tsize_t str_length = strlen((const char *)str);\n\t\tsize_t fmt_length = strlen((const char *)s);\n\t\tsize_t new_fmt_len = parsed_usefmt\n\t\t\t\t\t\t + str_length + fmt_length + 3;\n\t\tchar_u *new_fmt = (char_u *)alloc(new_fmt_len * sizeof(char_u));\n\t\tchar_u *new_fmt_p = new_fmt;\n\n\t\tnew_fmt_p = (char_u *)memcpy(new_fmt_p, usefmt, parsed_usefmt)\n\t\t\t\t\t\t\t       + parsed_usefmt;\n\t\tnew_fmt_p = (char_u *)memcpy(new_fmt_p , str, str_length)\n\t\t\t\t\t\t\t\t  + str_length;\n\t\tnew_fmt_p = (char_u *)memcpy(new_fmt_p, \"%}\", 2) + 2;\n\t\tnew_fmt_p = (char_u *)memcpy(new_fmt_p , s, fmt_length)\n\t\t\t\t\t\t\t\t  + fmt_length;\n\t\t*new_fmt_p = 0;\n\t\tnew_fmt_p = NULL;\n\n\t\tif (usefmt != fmt)\n\t\t    vim_free(usefmt);\n\t\tVIM_CLEAR(str);\n\t\tusefmt = new_fmt;\n\t\ts = usefmt + parsed_usefmt;\n\t\tevaldepth++;\n\t\tcontinue;\n\t    }\n#endif\n\t    break;\n\t}\n\tcase STL_LINE:\n\t    num = (wp->w_buffer->b_ml.ml_flags & ML_EMPTY)\n\t\t  ? 0L : (long)(wp->w_cursor.lnum);\n\t    break;\n\n\tcase STL_NUMLINES:\n\t    num = wp->w_buffer->b_ml.ml_line_count;\n\t    break;\n\n\tcase STL_COLUMN:\n\t    num = (State & MODE_INSERT) == 0 && empty_line\n\t\t\t\t\t       ? 0 : (int)wp->w_cursor.col + 1;\n\t    break;\n\n\tcase STL_VIRTCOL:\n\tcase STL_VIRTCOL_ALT:\n\t    virtcol = wp->w_virtcol + 1;\n\t    // Don't display %V if it's the same as %c.\n\t    if (opt == STL_VIRTCOL_ALT\n\t\t    && (virtcol == (colnr_T)((State & MODE_INSERT) == 0\n\t\t\t       && empty_line ? 0 : (int)wp->w_cursor.col + 1)))\n\t\tbreak;\n\t    num = (long)virtcol;\n\t    break;\n\n\tcase STL_PERCENTAGE:\n\t    num = (int)(((long)wp->w_cursor.lnum * 100L) /\n\t\t\t(long)wp->w_buffer->b_ml.ml_line_count);\n\t    break;\n\n\tcase STL_ALTPERCENT:\n\t    str = buf_tmp;\n\t    get_rel_pos(wp, str, TMPLEN);\n\t    break;\n\n\tcase STL_ARGLISTSTAT:\n\t    fillable = FALSE;\n\t    buf_tmp[0] = 0;\n\t    if (append_arg_number(wp, buf_tmp, (int)sizeof(buf_tmp), FALSE))\n\t\tstr = buf_tmp;\n\t    break;\n\n\tcase STL_KEYMAP:\n\t    fillable = FALSE;\n\t    if (get_keymap_str(wp, (char_u *)\"<%s>\", buf_tmp, TMPLEN))\n\t\tstr = buf_tmp;\n\t    break;\n\tcase STL_PAGENUM:\n#if defined(FEAT_PRINTER) || defined(FEAT_GUI_TABLINE)\n\t    num = printer_page_num;\n#else\n\t    num = 0;\n#endif\n\t    break;\n\n\tcase STL_BUFNO:\n\t    num = wp->w_buffer->b_fnum;\n\t    break;\n\n\tcase STL_OFFSET_X:\n\t    base = 'X';\n\t    // FALLTHROUGH\n\tcase STL_OFFSET:\n#ifdef FEAT_BYTEOFF\n\t    l = ml_find_line_or_offset(wp->w_buffer, wp->w_cursor.lnum, NULL);\n\t    num = (wp->w_buffer->b_ml.ml_flags & ML_EMPTY) || l < 0\n\t\t       ? 0L : l + 1 + ((State & MODE_INSERT) == 0 && empty_line\n\t\t\t\t? 0 : (int)wp->w_cursor.col);\n#endif\n\t    break;\n\n\tcase STL_BYTEVAL_X:\n\t    base = 'X';\n\t    // FALLTHROUGH\n\tcase STL_BYTEVAL:\n\t    num = byteval;\n\t    if (num == NL)\n\t\tnum = 0;\n\t    else if (num == CAR && get_fileformat(wp->w_buffer) == EOL_MAC)\n\t\tnum = NL;\n\t    break;\n\n\tcase STL_ROFLAG:\n\tcase STL_ROFLAG_ALT:\n\t    itemisflag = TRUE;\n\t    if (wp->w_buffer->b_p_ro)\n\t\tstr = (char_u *)((opt == STL_ROFLAG_ALT) ? \",RO\" : _(\"[RO]\"));\n\t    break;\n\n\tcase STL_HELPFLAG:\n\tcase STL_HELPFLAG_ALT:\n\t    itemisflag = TRUE;\n\t    if (wp->w_buffer->b_help)\n\t\tstr = (char_u *)((opt == STL_HELPFLAG_ALT) ? \",HLP\"\n\t\t\t\t\t\t\t       : _(\"[Help]\"));\n\t    break;\n\n\tcase STL_FILETYPE:\n\t    if (*wp->w_buffer->b_p_ft != NUL\n\t\t    && STRLEN(wp->w_buffer->b_p_ft) < TMPLEN - 3)\n\t    {\n\t\tvim_snprintf((char *)buf_tmp, sizeof(buf_tmp), \"[%s]\",\n\t\t\t\t\t\t\twp->w_buffer->b_p_ft);\n\t\tstr = buf_tmp;\n\t    }\n\t    break;\n\n\tcase STL_FILETYPE_ALT:\n\t    itemisflag = TRUE;\n\t    if (*wp->w_buffer->b_p_ft != NUL\n\t\t    && STRLEN(wp->w_buffer->b_p_ft) < TMPLEN - 2)\n\t    {\n\t\tvim_snprintf((char *)buf_tmp, sizeof(buf_tmp), \",%s\",\n\t\t\t\t\t\t\twp->w_buffer->b_p_ft);\n\t\tfor (t = buf_tmp; *t != 0; t++)\n\t\t    *t = TOUPPER_LOC(*t);\n\t\tstr = buf_tmp;\n\t    }\n\t    break;\n\n#if defined(FEAT_QUICKFIX)\n\tcase STL_PREVIEWFLAG:\n\tcase STL_PREVIEWFLAG_ALT:\n\t    itemisflag = TRUE;\n\t    if (wp->w_p_pvw)\n\t\tstr = (char_u *)((opt == STL_PREVIEWFLAG_ALT) ? \",PRV\"\n\t\t\t\t\t\t\t    : _(\"[Preview]\"));\n\t    break;\n\n\tcase STL_QUICKFIX:\n\t    if (bt_quickfix(wp->w_buffer))\n\t\tstr = (char_u *)(wp->w_llist_ref\n\t\t\t    ? _(msg_loclist)\n\t\t\t    : _(msg_qflist));\n\t    break;\n#endif\n\n\tcase STL_MODIFIED:\n\tcase STL_MODIFIED_ALT:\n\t    itemisflag = TRUE;\n\t    switch ((opt == STL_MODIFIED_ALT)\n\t\t    + bufIsChanged(wp->w_buffer) * 2\n\t\t    + (!wp->w_buffer->b_p_ma) * 4)\n\t    {\n\t\tcase 2: str = (char_u *)\"[+]\"; break;\n\t\tcase 3: str = (char_u *)\",+\"; break;\n\t\tcase 4: str = (char_u *)\"[-]\"; break;\n\t\tcase 5: str = (char_u *)\",-\"; break;\n\t\tcase 6: str = (char_u *)\"[+-]\"; break;\n\t\tcase 7: str = (char_u *)\",+-\"; break;\n\t    }\n\t    break;\n\n\tcase STL_HIGHLIGHT:\n\t    t = s;\n\t    while (*s != '#' && *s != NUL)\n\t\t++s;\n\t    if (*s == '#')\n\t    {\n\t\tstl_items[curitem].stl_type = Highlight;\n\t\tstl_items[curitem].stl_start = p;\n\t\tstl_items[curitem].stl_minwid = -syn_namen2id(t, (int)(s - t));\n\t\tcuritem++;\n\t    }\n\t    if (*s != NUL)\n\t\t++s;\n\t    continue;\n\t}\n\n\tstl_items[curitem].stl_start = p;\n\tstl_items[curitem].stl_type = Normal;\n\tif (str != NULL && *str)\n\t{\n\t    t = str;\n\t    if (itemisflag)\n\t    {\n\t\tif ((t[0] && t[1])\n\t\t\t&& ((!prevchar_isitem && *t == ',')\n\t\t\t      || (prevchar_isflag && *t == ' ')))\n\t\t    t++;\n\t\tprevchar_isflag = TRUE;\n\t    }\n\t    l = vim_strsize(t);\n\t    if (l > 0)\n\t\tprevchar_isitem = TRUE;\n\t    if (l > maxwid)\n\t    {\n\t\twhile (l >= maxwid)\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\tl -= ptr2cells(t);\n\t\t\tt += (*mb_ptr2len)(t);\n\t\t    }\n\t\t    else\n\t\t\tl -= byte2cells(*t++);\n\t\tif (p + 1 >= out + outlen)\n\t\t    break;\n\t\t*p++ = '<';\n\t    }\n\t    if (minwid > 0)\n\t    {\n\t\tfor (; l < minwid && p + 1 < out + outlen; l++)\n\t\t{\n\t\t    // Don't put a \"-\" in front of a digit.\n\t\t    if (l + 1 == minwid && fillchar == '-' && VIM_ISDIGIT(*t))\n\t\t\t*p++ = ' ';\n\t\t    else\n\t\t\tMB_CHAR2BYTES(fillchar, p);\n\t\t}\n\t\tminwid = 0;\n\t    }\n\t    else\n\t\tminwid *= -1;\n\t    for (; *t && p + 1 < out + outlen; t++)\n\t    {\n\t\t// Change a space by fillchar, unless fillchar is '-' and a\n\t\t// digit follows.\n\t\tif (fillable && *t == ' '\n\t\t\t\t&& (!VIM_ISDIGIT(*(t + 1)) || fillchar != '-'))\n\t\t    MB_CHAR2BYTES(fillchar, p);\n\t\telse\n\t\t    *p++ = *t;\n\t    }\n\t    for (; l < minwid && p + 1 < out + outlen; l++)\n\t\tMB_CHAR2BYTES(fillchar, p);\n\t}\n\telse if (num >= 0)\n\t{\n\t    int nbase = (base == 'D' ? 10 : (base == 'O' ? 8 : 16));\n\t    char_u nstr[20];\n\n\t    if (p + 20 >= out + outlen)\n\t\tbreak;\t\t// not sufficient space\n\t    prevchar_isitem = TRUE;\n\t    t = nstr;\n\t    if (opt == STL_VIRTCOL_ALT)\n\t    {\n\t\t*t++ = '-';\n\t\tminwid--;\n\t    }\n\t    *t++ = '%';\n\t    if (zeropad)\n\t\t*t++ = '0';\n\t    *t++ = '*';\n\t    *t++ = nbase == 16 ? base : (char_u)(nbase == 8 ? 'o' : 'd');\n\t    *t = 0;\n\n\t    for (n = num, l = 1; n >= nbase; n /= nbase)\n\t\tl++;\n\t    if (opt == STL_VIRTCOL_ALT)\n\t\tl++;\n\t    if (l > maxwid)\n\t    {\n\t\tl += 2;\n\t\tn = l - maxwid;\n\t\twhile (l-- > maxwid)\n\t\t    num /= nbase;\n\t\t*t++ = '>';\n\t\t*t++ = '%';\n\t\t*t = t[-3];\n\t\t*++t = 0;\n\t\tvim_snprintf((char *)p, outlen - (p - out), (char *)nstr,\n\t\t\t\t\t\t\t\t   0, num, n);\n\t    }\n\t    else\n\t\tvim_snprintf((char *)p, outlen - (p - out), (char *)nstr,\n\t\t\t\t\t\t\t\t minwid, num);\n\t    p += STRLEN(p);\n\t}\n\telse\n\t    stl_items[curitem].stl_type = Empty;\n\n\tif (opt == STL_VIM_EXPR)\n\t    vim_free(str);\n\n\tif (num >= 0 || (!itemisflag && str && *str))\n\t    prevchar_isflag = FALSE;\t    // Item not NULL, but not a flag\n\tcuritem++;\n    }\n    *p = NUL;\n    itemcnt = curitem;\n\n#ifdef FEAT_EVAL\n    if (usefmt != fmt)\n\tvim_free(usefmt);\n#endif\n\n    width = vim_strsize(out);\n    if (maxwidth > 0 && width > maxwidth)\n    {\n\t// Result is too long, must truncate somewhere.\n\tl = 0;\n\tif (itemcnt == 0)\n\t    s = out;\n\telse\n\t{\n\t    for ( ; l < itemcnt; l++)\n\t\tif (stl_items[l].stl_type == Trunc)\n\t\t{\n\t\t    // Truncate at %< item.\n\t\t    s = stl_items[l].stl_start;\n\t\t    break;\n\t\t}\n\t    if (l == itemcnt)\n\t    {\n\t\t// No %< item, truncate first item.\n\t\ts = stl_items[0].stl_start;\n\t\tl = 0;\n\t    }\n\t}\n\n\tif (width - vim_strsize(s) >= maxwidth)\n\t{\n\t    // Truncation mark is beyond max length\n\t    if (has_mbyte)\n\t    {\n\t\ts = out;\n\t\twidth = 0;\n\t\tfor (;;)\n\t\t{\n\t\t    width += ptr2cells(s);\n\t\t    if (width >= maxwidth)\n\t\t\tbreak;\n\t\t    s += (*mb_ptr2len)(s);\n\t\t}\n\t\t// Fill up for half a double-wide character.\n\t\twhile (++width < maxwidth)\n\t\t    MB_CHAR2BYTES(fillchar, s);\n\t    }\n\t    else\n\t\ts = out + maxwidth - 1;\n\t    for (l = 0; l < itemcnt; l++)\n\t\tif (stl_items[l].stl_start > s)\n\t\t    break;\n\t    itemcnt = l;\n\t    *s++ = '>';\n\t    *s = 0;\n\t}\n\telse\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tn = 0;\n\t\twhile (width >= maxwidth)\n\t\t{\n\t\t    width -= ptr2cells(s + n);\n\t\t    n += (*mb_ptr2len)(s + n);\n\t\t}\n\t    }\n\t    else\n\t\tn = width - maxwidth + 1;\n\t    p = s + n;\n\t    STRMOVE(s + 1, p);\n\t    *s = '<';\n\n\t    // Fill up for half a double-wide character.\n\t    while (++width < maxwidth)\n\t    {\n\t\ts = s + STRLEN(s);\n\t\tMB_CHAR2BYTES(fillchar, s);\n\t\t*s = NUL;\n\t    }\n\n\t    --n;\t// count the '<'\n\t    for (; l < itemcnt; l++)\n\t    {\n\t\tif (stl_items[l].stl_start - n >= s)\n\t\t    stl_items[l].stl_start -= n;\n\t\telse\n\t\t    stl_items[l].stl_start = s;\n\t    }\n\t}\n\twidth = maxwidth;\n    }\n    else if (width < maxwidth && STRLEN(out) + maxwidth - width + 1 < outlen)\n    {\n\t// Apply STL_MIDDLE if any\n\tfor (l = 0; l < itemcnt; l++)\n\t    if (stl_items[l].stl_type == Middle)\n\t\tbreak;\n\tif (l < itemcnt)\n\t{\n\t    int middlelength = (maxwidth - width) * MB_CHAR2LEN(fillchar);\n\t    p = stl_items[l].stl_start + middlelength;\n\t    STRMOVE(p, stl_items[l].stl_start);\n\t    for (s = stl_items[l].stl_start; s < p;)\n\t\tMB_CHAR2BYTES(fillchar, s);\n\t    for (l++; l < itemcnt; l++)\n\t\tstl_items[l].stl_start += middlelength;\n\t    width = maxwidth;\n\t}\n    }\n\n    // Store the info about highlighting.\n    if (hltab != NULL)\n    {\n\t*hltab = stl_hltab;\n\tsp = stl_hltab;\n\tfor (l = 0; l < itemcnt; l++)\n\t{\n\t    if (stl_items[l].stl_type == Highlight)\n\t    {\n\t\tsp->start = stl_items[l].stl_start;\n\t\tsp->userhl = stl_items[l].stl_minwid;\n\t\tsp++;\n\t    }\n\t}\n\tsp->start = NULL;\n\tsp->userhl = 0;\n    }\n\n    // Store the info about tab pages labels.\n    if (tabtab != NULL)\n    {\n\t*tabtab = stl_tabtab;\n\tsp = stl_tabtab;\n\tfor (l = 0; l < itemcnt; l++)\n\t{\n\t    if (stl_items[l].stl_type == TabPage)\n\t    {\n\t\tsp->start = stl_items[l].stl_start;\n\t\tsp->userhl = stl_items[l].stl_minwid;\n\t\tsp++;\n\t    }\n\t}\n\tsp->start = NULL;\n\tsp->userhl = 0;\n    }\n\n    // When inside update_screen we do not want redrawing a statusline, ruler,\n    // title, etc. to trigger another redraw, it may cause an endless loop.\n    if (updating_screen)\n    {\n\tmust_redraw = save_must_redraw;\n\tcurwin->w_redr_type = save_redr_type;\n    }\n\n    // A user function may reset KeyTyped, restore it.\n    KeyTyped = save_KeyTyped;\n\n    return width;\n}\n#endif // FEAT_STL_OPT\n\n#if defined(FEAT_STL_OPT) || defined(FEAT_CMDL_INFO) \\\n\t    || defined(FEAT_GUI_TABLINE) || defined(PROTO)\n/*\n * Get relative cursor position in window into \"buf[buflen]\", in the form 99%,\n * using \"Top\", \"Bot\" or \"All\" when appropriate.\n */\n    void\nget_rel_pos(\n    win_T\t*wp,\n    char_u\t*buf,\n    int\t\tbuflen)\n{\n    long\tabove; // number of lines above window\n    long\tbelow; // number of lines below window\n\n    if (buflen < 3) // need at least 3 chars for writing\n\treturn;\n    above = wp->w_topline - 1;\n#ifdef FEAT_DIFF\n    above += diff_check_fill(wp, wp->w_topline) - wp->w_topfill;\n    if (wp->w_topline == 1 && wp->w_topfill >= 1)\n\tabove = 0;  // All buffer lines are displayed and there is an\n\t\t    // indication of filler lines, that can be considered\n\t\t    // seeing all lines.\n#endif\n    below = wp->w_buffer->b_ml.ml_line_count - wp->w_botline + 1;\n    if (below <= 0)\n\tvim_strncpy(buf, (char_u *)(above == 0 ? _(\"All\") : _(\"Bot\")),\n\t\t\t\t\t\t\t(size_t)(buflen - 1));\n    else if (above <= 0)\n\tvim_strncpy(buf, (char_u *)_(\"Top\"), (size_t)(buflen - 1));\n    else\n\tvim_snprintf((char *)buf, (size_t)buflen, \"%2d%%\", above > 1000000L\n\t\t\t\t    ? (int)(above / ((above + below) / 100L))\n\t\t\t\t    : (int)(above * 100L / (above + below)));\n}\n#endif\n\n/*\n * Append (file 2 of 8) to \"buf[buflen]\", if editing more than one file.\n * Return TRUE if it was appended.\n */\n    static int\nappend_arg_number(\n    win_T\t*wp,\n    char_u\t*buf,\n    int\t\tbuflen,\n    int\t\tadd_file)\t// Add \"file\" before the arg number\n{\n    char_u\t*p;\n\n    if (ARGCOUNT <= 1)\t\t// nothing to do\n\treturn FALSE;\n\n    p = buf + STRLEN(buf);\t// go to the end of the buffer\n    if (p - buf + 35 >= buflen)\t// getting too long\n\treturn FALSE;\n    *p++ = ' ';\n    *p++ = '(';\n    if (add_file)\n    {\n\tSTRCPY(p, \"file \");\n\tp += 5;\n    }\n    vim_snprintf((char *)p, (size_t)(buflen - (p - buf)),\n\t\twp->w_arg_idx_invalid ? \"(%d) of %d)\"\n\t\t\t\t  : \"%d of %d)\", wp->w_arg_idx + 1, ARGCOUNT);\n    return TRUE;\n}\n\n/*\n * If fname is not a full path, make it a full path.\n * Returns pointer to allocated memory (NULL for failure).\n */\n    char_u  *\nfix_fname(char_u  *fname)\n{\n    /*\n     * Force expanding the path always for Unix, because symbolic links may\n     * mess up the full path name, even though it starts with a '/'.\n     * Also expand when there is \"..\" in the file name, try to remove it,\n     * because \"c:/src/../README\" is equal to \"c:/README\".\n     * Similarly \"c:/src//file\" is equal to \"c:/src/file\".\n     * For MS-Windows also expand names like \"longna~1\" to \"longname\".\n     */\n#ifdef UNIX\n    return FullName_save(fname, TRUE);\n#else\n    if (!vim_isAbsName(fname)\n\t    || strstr((char *)fname, \"..\") != NULL\n\t    || strstr((char *)fname, \"//\") != NULL\n# ifdef BACKSLASH_IN_FILENAME\n\t    || strstr((char *)fname, \"\\\\\\\\\") != NULL\n# endif\n# if defined(MSWIN)\n\t    || vim_strchr(fname, '~') != NULL\n# endif\n\t    )\n\treturn FullName_save(fname, FALSE);\n\n    fname = vim_strsave(fname);\n\n# ifdef USE_FNAME_CASE\n    if (fname != NULL)\n\tfname_case(fname, 0);\t// set correct case for file name\n# endif\n\n    return fname;\n#endif\n}\n\n/*\n * Make \"*ffname\" a full file name, set \"*sfname\" to \"*ffname\" if not NULL.\n * \"*ffname\" becomes a pointer to allocated memory (or NULL).\n * When resolving a link both \"*sfname\" and \"*ffname\" will point to the same\n * allocated memory.\n * The \"*ffname\" and \"*sfname\" pointer values on call will not be freed.\n * Note that the resulting \"*ffname\" pointer should be considered not allocated.\n */\n    void\nfname_expand(\n    buf_T\t*buf UNUSED,\n    char_u\t**ffname,\n    char_u\t**sfname)\n{\n    if (*ffname == NULL)\t    // no file name given, nothing to do\n\treturn;\n    if (*sfname == NULL)\t    // no short file name given, use ffname\n\t*sfname = *ffname;\n    *ffname = fix_fname(*ffname);   // expand to full path\n\n#ifdef FEAT_SHORTCUT\n    if (!buf->b_p_bin)\n    {\n\tchar_u  *rfname;\n\n\t// If the file name is a shortcut file, use the file it links to.\n\trfname = mch_resolve_path(*ffname, FALSE);\n\tif (rfname != NULL)\n\t{\n\t    vim_free(*ffname);\n\t    *ffname = rfname;\n\t    *sfname = rfname;\n\t}\n    }\n#endif\n}\n\n/*\n * Open a window for a number of buffers.\n */\n    void\nex_buffer_all(exarg_T *eap)\n{\n    buf_T\t*buf;\n    win_T\t*wp, *wpnext;\n    int\t\tsplit_ret = OK;\n    int\t\tp_ea_save;\n    int\t\topen_wins = 0;\n    int\t\tr;\n    int\t\tcount;\t\t// Maximum number of windows to open.\n    int\t\tall;\t\t// When TRUE also load inactive buffers.\n    int\t\thad_tab = cmdmod.cmod_tab;\n    tabpage_T\t*tpnext;\n\n    if (eap->addr_count == 0)\t// make as many windows as possible\n\tcount = 9999;\n    else\n\tcount = eap->line2;\t// make as many windows as specified\n    if (eap->cmdidx == CMD_unhide || eap->cmdidx == CMD_sunhide)\n\tall = FALSE;\n    else\n\tall = TRUE;\n\n    setpcmark();\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * Close superfluous windows (two windows for the same buffer).\n     * Also close windows that are not full-width.\n     */\n    if (had_tab > 0)\n\tgoto_tabpage_tp(first_tabpage, TRUE, TRUE);\n    for (;;)\n    {\n\ttpnext = curtab->tp_next;\n\tfor (wp = firstwin; wp != NULL; wp = wpnext)\n\t{\n\t    wpnext = wp->w_next;\n\t    if ((wp->w_buffer->b_nwindows > 1\n\t\t\t|| ((cmdmod.cmod_split & WSP_VERT)\n\t\t\t    ? wp->w_height + wp->w_status_height < Rows - p_ch\n\t\t\t\t\t\t\t     - tabline_height()\n\t\t\t    : wp->w_width != Columns)\n\t\t\t|| (had_tab > 0 && wp != firstwin))\n\t\t    && !ONE_WINDOW\n\t\t    && !(wp->w_closing || wp->w_buffer->b_locked > 0)\n\t\t    && !win_unlisted(wp))\n\t    {\n\t\tif (win_close(wp, FALSE) == FAIL)\n\t\t    break;\n\t\t// Just in case an autocommand does something strange with\n\t\t// windows: start all over...\n\t\twpnext = firstwin;\n\t\ttpnext = first_tabpage;\n\t\topen_wins = 0;\n\t    }\n\t    else\n\t\t++open_wins;\n\t}\n\n\t// Without the \":tab\" modifier only do the current tab page.\n\tif (had_tab == 0 || tpnext == NULL)\n\t    break;\n\tgoto_tabpage_tp(tpnext, TRUE, TRUE);\n    }\n\n    /*\n     * Go through the buffer list.  When a buffer doesn't have a window yet,\n     * open one.  Otherwise move the window to the right position.\n     * Watch out for autocommands that delete buffers or windows!\n     */\n    // Don't execute Win/Buf Enter/Leave autocommands here.\n    ++autocmd_no_enter;\n    win_enter(lastwin, FALSE);\n    ++autocmd_no_leave;\n    for (buf = firstbuf; buf != NULL && open_wins < count; buf = buf->b_next)\n    {\n\t// Check if this buffer needs a window\n\tif ((!all && buf->b_ml.ml_mfp == NULL) || !buf->b_p_bl)\n\t    continue;\n\n\tif (had_tab != 0)\n\t{\n\t    // With the \":tab\" modifier don't move the window.\n\t    if (buf->b_nwindows > 0)\n\t\twp = lastwin;\t    // buffer has a window, skip it\n\t    else\n\t\twp = NULL;\n\t}\n\telse\n\t{\n\t    // Check if this buffer already has a window\n\t    FOR_ALL_WINDOWS(wp)\n\t\tif (wp->w_buffer == buf)\n\t\t    break;\n\t    // If the buffer already has a window, move it\n\t    if (wp != NULL)\n\t\twin_move_after(wp, curwin);\n\t}\n\n\tif (wp == NULL && split_ret == OK)\n\t{\n\t    bufref_T\tbufref;\n\n\t    set_bufref(&bufref, buf);\n\n\t    // Split the window and put the buffer in it\n\t    p_ea_save = p_ea;\n\t    p_ea = TRUE;\t\t// use space from all windows\n\t    split_ret = win_split(0, WSP_ROOM | WSP_BELOW);\n\t    ++open_wins;\n\t    p_ea = p_ea_save;\n\t    if (split_ret == FAIL)\n\t\tcontinue;\n\n\t    // Open the buffer in this window.\n\t    swap_exists_action = SEA_DIALOG;\n\t    set_curbuf(buf, DOBUF_GOTO);\n\t    if (!bufref_valid(&bufref))\n\t    {\n\t\t// autocommands deleted the buffer!!!\n\t\tswap_exists_action = SEA_NONE;\n\t\tbreak;\n\t    }\n\t    if (swap_exists_action == SEA_QUIT)\n\t    {\n#if defined(FEAT_EVAL)\n\t\tcleanup_T   cs;\n\n\t\t// Reset the error/interrupt/exception state here so that\n\t\t// aborting() returns FALSE when closing a window.\n\t\tenter_cleanup(&cs);\n#endif\n\n\t\t// User selected Quit at ATTENTION prompt; close this window.\n\t\twin_close(curwin, TRUE);\n\t\t--open_wins;\n\t\tswap_exists_action = SEA_NONE;\n\t\tswap_exists_did_quit = TRUE;\n\n#if defined(FEAT_EVAL)\n\t\t// Restore the error/interrupt/exception state if not\n\t\t// discarded by a new aborting error, interrupt, or uncaught\n\t\t// exception.\n\t\tleave_cleanup(&cs);\n#endif\n\t    }\n\t    else\n\t\thandle_swap_exists(NULL);\n\t}\n\n\tui_breakcheck();\n\tif (got_int)\n\t{\n\t    (void)vgetc();\t// only break the file loading, not the rest\n\t    break;\n\t}\n#ifdef FEAT_EVAL\n\t// Autocommands deleted the buffer or aborted script processing!!!\n\tif (aborting())\n\t    break;\n#endif\n\t// When \":tab\" was used open a new tab for a new window repeatedly.\n\tif (had_tab > 0 && tabpage_index(NULL) <= p_tpm)\n\t    cmdmod.cmod_tab = 9999;\n    }\n    --autocmd_no_enter;\n    win_enter(firstwin, FALSE);\t\t// back to first window\n    --autocmd_no_leave;\n\n    /*\n     * Close superfluous windows.\n     */\n    for (wp = lastwin; open_wins > count; )\n    {\n\tr = (buf_hide(wp->w_buffer) || !bufIsChanged(wp->w_buffer)\n\t\t\t\t     || autowrite(wp->w_buffer, FALSE) == OK);\n\tif (!win_valid(wp))\n\t{\n\t    // BufWrite Autocommands made the window invalid, start over\n\t    wp = lastwin;\n\t}\n\telse if (r)\n\t{\n\t    win_close(wp, !buf_hide(wp->w_buffer));\n\t    --open_wins;\n\t    wp = lastwin;\n\t}\n\telse\n\t{\n\t    wp = wp->w_prev;\n\t    if (wp == NULL)\n\t\tbreak;\n\t}\n    }\n}\n\n\nstatic int  chk_modeline(linenr_T, int);\n\n/*\n * do_modelines() - process mode lines for the current file\n *\n * \"flags\" can be:\n * OPT_WINONLY\t    only set options local to window\n * OPT_NOWIN\t    don't set options local to window\n *\n * Returns immediately if the \"ml\" option isn't set.\n */\n    void\ndo_modelines(int flags)\n{\n    linenr_T\tlnum;\n    int\t\tnmlines;\n    static int\tentered = 0;\n\n    if (!curbuf->b_p_ml || (nmlines = (int)p_mls) == 0)\n\treturn;\n\n    // Disallow recursive entry here.  Can happen when executing a modeline\n    // triggers an autocommand, which reloads modelines with a \":do\".\n    if (entered)\n\treturn;\n\n    ++entered;\n    for (lnum = 1; curbuf->b_p_ml && lnum <= curbuf->b_ml.ml_line_count && lnum <= nmlines;\n\t\t\t\t\t\t\t\t       ++lnum)\n\tif (chk_modeline(lnum, flags) == FAIL)\n\t    nmlines = 0;\n\n    for (lnum = curbuf->b_ml.ml_line_count; curbuf->b_p_ml && lnum > 0 && lnum > nmlines\n\t\t       && lnum > curbuf->b_ml.ml_line_count - nmlines; --lnum)\n\tif (chk_modeline(lnum, flags) == FAIL)\n\t    nmlines = 0;\n    --entered;\n}\n\n#include \"version.h\"\t\t// for version number\n\n/*\n * chk_modeline() - check a single line for a mode string\n * Return FAIL if an error encountered.\n */\n    static int\nchk_modeline(\n    linenr_T\tlnum,\n    int\t\tflags)\t\t// Same as for do_modelines().\n{\n    char_u\t*s;\n    char_u\t*e;\n    char_u\t*linecopy;\t\t// local copy of any modeline found\n    int\t\tprev;\n    int\t\tvers;\n    int\t\tend;\n    int\t\tretval = OK;\n    sctx_T\tsave_current_sctx;\n\n    ESTACK_CHECK_DECLARATION\n\n    prev = -1;\n    for (s = ml_get(lnum); *s != NUL; ++s)\n    {\n\tif (prev == -1 || vim_isspace(prev))\n\t{\n\t    if ((prev != -1 && STRNCMP(s, \"ex:\", (size_t)3) == 0)\n\t\t    || STRNCMP(s, \"vi:\", (size_t)3) == 0)\n\t\tbreak;\n\t    // Accept both \"vim\" and \"Vim\".\n\t    if ((s[0] == 'v' || s[0] == 'V') && s[1] == 'i' && s[2] == 'm')\n\t    {\n\t\tif (s[3] == '<' || s[3] == '=' || s[3] == '>')\n\t\t    e = s + 4;\n\t\telse\n\t\t    e = s + 3;\n\t\tvers = getdigits(&e);\n\t\tif (*e == ':'\n\t\t\t&& (s[0] != 'V'\n\t\t\t\t  || STRNCMP(skipwhite(e + 1), \"set\", 3) == 0)\n\t\t\t&& (s[3] == ':'\n\t\t\t    || (VIM_VERSION_100 >= vers && isdigit(s[3]))\n\t\t\t    || (VIM_VERSION_100 < vers && s[3] == '<')\n\t\t\t    || (VIM_VERSION_100 > vers && s[3] == '>')\n\t\t\t    || (VIM_VERSION_100 == vers && s[3] == '=')))\n\t\t    break;\n\t    }\n\t}\n\tprev = *s;\n    }\n\n    if (*s)\n    {\n\tdo\t\t\t\t// skip over \"ex:\", \"vi:\" or \"vim:\"\n\t    ++s;\n\twhile (s[-1] != ':');\n\n\ts = linecopy = vim_strsave(s);\t// copy the line, it will change\n\tif (linecopy == NULL)\n\t    return FAIL;\n\n\t// prepare for emsg()\n\testack_push(ETYPE_MODELINE, (char_u *)\"modelines\", lnum);\n\tESTACK_CHECK_SETUP\n\n\tend = FALSE;\n\twhile (end == FALSE)\n\t{\n\t    s = skipwhite(s);\n\t    if (*s == NUL)\n\t\tbreak;\n\n\t    /*\n\t     * Find end of set command: ':' or end of line.\n\t     * Skip over \"\\:\", replacing it with \":\".\n\t     */\n\t    for (e = s; *e != ':' && *e != NUL; ++e)\n\t\tif (e[0] == '\\\\' && e[1] == ':')\n\t\t    STRMOVE(e, e + 1);\n\t    if (*e == NUL)\n\t\tend = TRUE;\n\n\t    /*\n\t     * If there is a \"set\" command, require a terminating ':' and\n\t     * ignore the stuff after the ':'.\n\t     * \"vi:set opt opt opt: foo\" -- foo not interpreted\n\t     * \"vi:opt opt opt: foo\" -- foo interpreted\n\t     * Accept \"se\" for compatibility with Elvis.\n\t     */\n\t    if (STRNCMP(s, \"set \", (size_t)4) == 0\n\t\t    || STRNCMP(s, \"se \", (size_t)3) == 0)\n\t    {\n\t\tif (*e != ':')\t\t// no terminating ':'?\n\t\t    break;\n\t\tend = TRUE;\n\t\ts = vim_strchr(s, ' ') + 1;\n\t    }\n\t    *e = NUL;\t\t\t// truncate the set command\n\n\t    if (*s != NUL)\t\t// skip over an empty \"::\"\n\t    {\n\t\tint secure_save = secure;\n\n\t\tsave_current_sctx = current_sctx;\n\t\tcurrent_sctx.sc_version = 1;\n#ifdef FEAT_EVAL\n\t\tcurrent_sctx.sc_sid = SID_MODELINE;\n\t\tcurrent_sctx.sc_seq = 0;\n\t\tcurrent_sctx.sc_lnum = lnum;\n#endif\n\n\t\t// Make sure no risky things are executed as a side effect.\n\t\tsecure = 1;\n\n\t\tretval = do_set(s, OPT_MODELINE | OPT_LOCAL | flags);\n\n\t\tsecure = secure_save;\n\t\tcurrent_sctx = save_current_sctx;\n\t\tif (retval == FAIL)\t\t// stop if error found\n\t\t    break;\n\t    }\n\t    s = e + 1;\t\t\t// advance to next part\n\t}\n\n\tESTACK_CHECK_NOW\n\testack_pop();\n\tvim_free(linecopy);\n    }\n    return retval;\n}\n\n/*\n * Return TRUE if \"buf\" is a normal buffer, 'buftype' is empty.\n */\n    int\nbt_normal(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt[0] == NUL;\n}\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n/*\n * Return TRUE if \"buf\" is the quickfix buffer.\n */\n    int\nbt_quickfix(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt[0] == 'q';\n}\n#endif\n\n#if defined(FEAT_TERMINAL) || defined(PROTO)\n/*\n * Return TRUE if \"buf\" is a terminal buffer.\n */\n    int\nbt_terminal(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt[0] == 't';\n}\n#endif\n\n/*\n * Return TRUE if \"buf\" is a help buffer.\n */\n    int\nbt_help(buf_T *buf)\n{\n    return buf != NULL && buf->b_help;\n}\n\n/*\n * Return TRUE if \"buf\" is a prompt buffer.\n */\n    int\nbt_prompt(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt[0] == 'p' && buf->b_p_bt[1] == 'r';\n}\n\n#if defined(FEAT_PROP_POPUP) || defined(PROTO)\n/*\n * Return TRUE if \"buf\" is a buffer for a popup window.\n */\n    int\nbt_popup(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt != NULL\n\t&& buf->b_p_bt[0] == 'p' && buf->b_p_bt[1] == 'o';\n}\n#endif\n\n/*\n * Return TRUE if \"buf\" is a \"nofile\", \"acwrite\", \"terminal\" or \"prompt\"\n * buffer.  This means the buffer name is not a file name.\n */\n    int\nbt_nofilename(buf_T *buf)\n{\n    return buf != NULL && ((buf->b_p_bt[0] == 'n' && buf->b_p_bt[2] == 'f')\n\t    || buf->b_p_bt[0] == 'a'\n\t    || buf->b_p_bt[0] == 't'\n\t    || buf->b_p_bt[0] == 'p');\n}\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n/*\n * Return TRUE if \"buf\" has 'buftype' set to \"nofile\".\n */\n    int\nbt_nofile(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt[0] == 'n' && buf->b_p_bt[2] == 'f';\n}\n#endif\n\n/*\n * Return TRUE if \"buf\" is a \"nowrite\", \"nofile\", \"terminal\" or \"prompt\"\n * buffer.\n */\n    int\nbt_dontwrite(buf_T *buf)\n{\n    return buf != NULL && (buf->b_p_bt[0] == 'n'\n\t\t || buf->b_p_bt[0] == 't'\n\t\t || buf->b_p_bt[0] == 'p');\n}\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n    int\nbt_dontwrite_msg(buf_T *buf)\n{\n    if (bt_dontwrite(buf))\n    {\n\temsg(_(e_cannot_write_buftype_option_is_set));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n#endif\n\n/*\n * Return TRUE if the buffer should be hidden, according to 'hidden', \":hide\"\n * and 'bufhidden'.\n */\n    int\nbuf_hide(buf_T *buf)\n{\n    // 'bufhidden' overrules 'hidden' and \":hide\", check it first\n    switch (buf->b_p_bh[0])\n    {\n\tcase 'u':\t\t    // \"unload\"\n\tcase 'w':\t\t    // \"wipe\"\n\tcase 'd': return FALSE;\t    // \"delete\"\n\tcase 'h': return TRUE;\t    // \"hide\"\n    }\n    return (p_hid || (cmdmod.cmod_flags & CMOD_HIDE));\n}\n\n/*\n * Return special buffer name.\n * Returns NULL when the buffer has a normal file name.\n */\n    char_u *\nbuf_spname(buf_T *buf)\n{\n#if defined(FEAT_QUICKFIX)\n    if (bt_quickfix(buf))\n    {\n\t/*\n\t * Differentiate between the quickfix and location list buffers using\n\t * the buffer number stored in the global quickfix stack.\n\t */\n\tif (buf->b_fnum == qf_stack_get_bufnr())\n\t    return (char_u *)_(msg_qflist);\n\telse\n\t    return (char_u *)_(msg_loclist);\n    }\n#endif\n\n    // There is no _file_ when 'buftype' is \"nofile\", b_sfname\n    // contains the name as specified by the user.\n    if (bt_nofilename(buf))\n    {\n#ifdef FEAT_TERMINAL\n\tif (buf->b_term != NULL)\n\t    return term_get_status_text(buf->b_term);\n#endif\n\tif (buf->b_fname != NULL)\n\t    return buf->b_fname;\n#ifdef FEAT_JOB_CHANNEL\n\tif (bt_prompt(buf))\n\t    return (char_u *)_(\"[Prompt]\");\n#endif\n#ifdef FEAT_PROP_POPUP\n\tif (bt_popup(buf))\n\t    return (char_u *)_(\"[Popup]\");\n#endif\n\treturn (char_u *)_(\"[Scratch]\");\n    }\n\n    if (buf->b_fname == NULL)\n\treturn buf_get_fname(buf);\n    return NULL;\n}\n\n/*\n * Get \"buf->b_fname\", use \"[No Name]\" if it is NULL.\n */\n    char_u *\nbuf_get_fname(buf_T *buf)\n{\n    if (buf->b_fname == NULL)\n\treturn (char_u *)_(\"[No Name]\");\n    return buf->b_fname;\n}\n\n/*\n * Set 'buflisted' for curbuf to \"on\" and trigger autocommands if it changed.\n */\n    void\nset_buflisted(int on)\n{\n    if (on != curbuf->b_p_bl)\n    {\n\tcurbuf->b_p_bl = on;\n\tif (on)\n\t    apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, curbuf);\n\telse\n\t    apply_autocmds(EVENT_BUFDELETE, NULL, NULL, FALSE, curbuf);\n    }\n}\n\n/*\n * Read the file for \"buf\" again and check if the contents changed.\n * Return TRUE if it changed or this could not be checked.\n */\n    int\nbuf_contents_changed(buf_T *buf)\n{\n    buf_T\t*newbuf;\n    int\t\tdiffer = TRUE;\n    linenr_T\tlnum;\n    aco_save_T\taco;\n    exarg_T\tea;\n\n    // Allocate a buffer without putting it in the buffer list.\n    newbuf = buflist_new(NULL, NULL, (linenr_T)1, BLN_DUMMY);\n    if (newbuf == NULL)\n\treturn TRUE;\n\n    // Force the 'fileencoding' and 'fileformat' to be equal.\n    if (prep_exarg(&ea, buf) == FAIL)\n    {\n\twipe_buffer(newbuf, FALSE);\n\treturn TRUE;\n    }\n\n    // set curwin/curbuf to buf and save a few things\n    aucmd_prepbuf(&aco, newbuf);\n\n    if (ml_open(curbuf) == OK\n\t    && readfile(buf->b_ffname, buf->b_fname,\n\t\t\t\t  (linenr_T)0, (linenr_T)0, (linenr_T)MAXLNUM,\n\t\t\t\t\t    &ea, READ_NEW | READ_DUMMY) == OK)\n    {\n\t// compare the two files line by line\n\tif (buf->b_ml.ml_line_count == curbuf->b_ml.ml_line_count)\n\t{\n\t    differ = FALSE;\n\t    for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum)\n\t\tif (STRCMP(ml_get_buf(buf, lnum, FALSE), ml_get(lnum)) != 0)\n\t\t{\n\t\t    differ = TRUE;\n\t\t    break;\n\t\t}\n\t}\n    }\n    vim_free(ea.cmd);\n\n    // restore curwin/curbuf and a few other things\n    aucmd_restbuf(&aco);\n\n    if (curbuf != newbuf)\t// safety check\n\twipe_buffer(newbuf, FALSE);\n\n    return differ;\n}\n\n/*\n * Wipe out a buffer and decrement the last buffer number if it was used for\n * this buffer.  Call this to wipe out a temp buffer that does not contain any\n * marks.\n */\n    void\nwipe_buffer(\n    buf_T\t*buf,\n    int\t\taucmd)\t    // When TRUE trigger autocommands.\n{\n    if (buf->b_fnum == top_file_num - 1)\n\t--top_file_num;\n\n    if (!aucmd)\t\t    // Don't trigger BufDelete autocommands here.\n\tblock_autocmds();\n\n    close_buffer(NULL, buf, DOBUF_WIPE, FALSE, TRUE);\n\n    if (!aucmd)\n\tunblock_autocmds();\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * ex_getln.c: Functions for entering and editing an Ex command line.\n */\n\n#include \"vim.h\"\n\n#ifndef MAX\n# define MAX(x,y) ((x) > (y) ? (x) : (y))\n#endif\n\n// Return value when handling keys in command-line mode.\n#define CMDLINE_NOT_CHANGED\t1\n#define CMDLINE_CHANGED\t\t2\n#define GOTO_NORMAL_MODE\t3\n#define PROCESS_NEXT_KEY\t4\n\n// The current cmdline_info.  It is initialized in getcmdline() and after that\n// used by other functions.  When invoking getcmdline() recursively it needs\n// to be saved with save_cmdline() and restored with restore_cmdline().\nstatic cmdline_info_T ccline;\n\n#ifdef FEAT_EVAL\nstatic int\tnew_cmdpos;\t// position set by set_cmdline_pos()\n#endif\n\nstatic int\textra_char = NUL;  // extra character to display when redrawing\n\t\t\t\t   // the command line\nstatic int\textra_char_shift;\n\n#ifdef FEAT_RIGHTLEFT\nstatic int\tcmd_hkmap = 0;\t// Hebrew mapping during command line\n#endif\n\nstatic char_u\t*getcmdline_int(int firstc, long count, int indent, int clear_ccline);\nstatic int\tcmdline_charsize(int idx);\nstatic void\tset_cmdspos(void);\nstatic void\tset_cmdspos_cursor(void);\nstatic void\tcorrect_cmdspos(int idx, int cells);\nstatic void\talloc_cmdbuff(int len);\nstatic void\tdraw_cmdline(int start, int len);\nstatic void\tsave_cmdline(cmdline_info_T *ccp);\nstatic void\trestore_cmdline(cmdline_info_T *ccp);\nstatic int\tcmdline_paste(int regname, int literally, int remcr);\nstatic void\tredrawcmdprompt(void);\nstatic int\tccheck_abbr(int);\n#ifdef FEAT_SEARCH_EXTRA\nstatic int\tempty_pattern_magic(char_u *pat, size_t len, magic_T magic_val);\n#endif\n\n#ifdef FEAT_CMDWIN\nstatic int\topen_cmdwin(void);\n\nstatic int\tcedit_key INIT(= -1);\t// key value of 'cedit' option\n#endif\n\n\n    static void\ntrigger_cmd_autocmd(int typechar, int evt)\n{\n    char_u\ttypestr[2];\n\n    typestr[0] = typechar;\n    typestr[1] = NUL;\n    apply_autocmds(evt, typestr, typestr, FALSE, curbuf);\n}\n\n/*\n * Abandon the command line.\n */\n    static void\nabandon_cmdline(void)\n{\n    VIM_CLEAR(ccline.cmdbuff);\n    if (msg_scrolled == 0)\n\tcompute_cmdrow();\n    msg(\"\");\n    redraw_cmdline = TRUE;\n}\n\n#ifdef FEAT_SEARCH_EXTRA\n/*\n * Guess that the pattern matches everything.  Only finds specific cases, such\n * as a trailing \\|, which can happen while typing a pattern.\n */\n    static int\nempty_pattern(char_u *p, int delim)\n{\n    size_t\tn = STRLEN(p);\n    magic_T\tmagic_val = MAGIC_ON;\n\n    if (n > 0)\n\t(void) skip_regexp_ex(p, delim, magic_isset(), NULL, NULL, &magic_val);\n    else\n\treturn TRUE;\n\n    return empty_pattern_magic(p, n, magic_val);\n}\n\n    static int\nempty_pattern_magic(char_u *p, size_t len, magic_T magic_val)\n{\n    // remove trailing \\v and the like\n    while (len >= 2 && p[len - 2] == '\\\\'\n\t\t\t&& vim_strchr((char_u *)\"mMvVcCZ\", p[len - 1]) != NULL)\n       len -= 2;\n\n    // true, if the pattern is empty, or the pattern ends with \\| and magic is\n    // set (or it ends with '|' and very magic is set)\n    return len == 0 || (len > 1\n\t    && ((p[len - 2] == '\\\\'\n\t\t\t\t && p[len - 1] == '|' && magic_val == MAGIC_ON)\n\t\t|| (p[len - 2] != '\\\\'\n\t\t\t     && p[len - 1] == '|' && magic_val == MAGIC_ALL)));\n}\n\n// Struct to store the viewstate during 'incsearch' highlighting.\ntypedef struct {\n    colnr_T\tvs_curswant;\n    colnr_T\tvs_leftcol;\n    linenr_T\tvs_topline;\n# ifdef FEAT_DIFF\n    int\t\tvs_topfill;\n# endif\n    linenr_T\tvs_botline;\n    linenr_T\tvs_empty_rows;\n} viewstate_T;\n\n    static void\nsave_viewstate(viewstate_T *vs)\n{\n    vs->vs_curswant = curwin->w_curswant;\n    vs->vs_leftcol = curwin->w_leftcol;\n    vs->vs_topline = curwin->w_topline;\n# ifdef FEAT_DIFF\n    vs->vs_topfill = curwin->w_topfill;\n# endif\n    vs->vs_botline = curwin->w_botline;\n    vs->vs_empty_rows = curwin->w_empty_rows;\n}\n\n    static void\nrestore_viewstate(viewstate_T *vs)\n{\n    curwin->w_curswant = vs->vs_curswant;\n    curwin->w_leftcol = vs->vs_leftcol;\n    curwin->w_topline = vs->vs_topline;\n# ifdef FEAT_DIFF\n    curwin->w_topfill = vs->vs_topfill;\n# endif\n    curwin->w_botline = vs->vs_botline;\n    curwin->w_empty_rows = vs->vs_empty_rows;\n}\n\n// Struct to store the state of 'incsearch' highlighting.\ntypedef struct {\n    pos_T\tsearch_start;\t// where 'incsearch' starts searching\n    pos_T\tsave_cursor;\n    int\t\twinid;\t\t// window where this state is valid\n    viewstate_T\tinit_viewstate;\n    viewstate_T\told_viewstate;\n    pos_T\tmatch_start;\n    pos_T\tmatch_end;\n    int\t\tdid_incsearch;\n    int\t\tincsearch_postponed;\n    optmagic_T\tmagic_overruled_save;\n} incsearch_state_T;\n\n    static void\ninit_incsearch_state(incsearch_state_T *is_state)\n{\n    is_state->winid = curwin->w_id;\n    is_state->match_start = curwin->w_cursor;\n    is_state->did_incsearch = FALSE;\n    is_state->incsearch_postponed = FALSE;\n    is_state->magic_overruled_save = magic_overruled;\n    CLEAR_POS(&is_state->match_end);\n    is_state->save_cursor = curwin->w_cursor;  // may be restored later\n    is_state->search_start = curwin->w_cursor;\n    save_viewstate(&is_state->init_viewstate);\n    save_viewstate(&is_state->old_viewstate);\n}\n\n/*\n * First move cursor to end of match, then to the start.  This\n * moves the whole match onto the screen when 'nowrap' is set.\n */\n    static void\nset_search_match(pos_T *t)\n{\n    t->lnum += search_match_lines;\n    t->col = search_match_endcol;\n    if (t->lnum > curbuf->b_ml.ml_line_count)\n    {\n\tt->lnum = curbuf->b_ml.ml_line_count;\n\tcoladvance((colnr_T)MAXCOL);\n    }\n}\n\n/*\n * Return TRUE when 'incsearch' highlighting is to be done.\n * Sets search_first_line and search_last_line to the address range.\n * May change the last search pattern.\n */\n    static int\ndo_incsearch_highlighting(\n\tint\t\t    firstc,\n\tint\t\t    *search_delim,\n\tincsearch_state_T   *is_state,\n\tint\t\t    *skiplen,\n\tint\t\t    *patlen)\n{\n    char_u\t*cmd;\n    cmdmod_T\tdummy_cmdmod;\n    char_u\t*p;\n    int\t\tdelim_optional = FALSE;\n    int\t\tdelim;\n    char_u\t*end;\n    char\t*dummy;\n    exarg_T\tea;\n    pos_T\tsave_cursor;\n    int\t\tuse_last_pat;\n    int\t\tretval = FALSE;\n    magic_T     magic = 0;\n\n    *skiplen = 0;\n    *patlen = ccline.cmdlen;\n\n    if (!p_is || cmd_silent)\n\treturn FALSE;\n\n    // by default search all lines\n    search_first_line = 0;\n    search_last_line = MAXLNUM;\n\n    if (firstc == '/' || firstc == '?')\n    {\n\t*search_delim = firstc;\n\treturn TRUE;\n    }\n    if (firstc != ':')\n\treturn FALSE;\n\n    ++emsg_off;\n    CLEAR_FIELD(ea);\n    ea.line1 = 1;\n    ea.line2 = 1;\n    ea.cmd = ccline.cmdbuff;\n    ea.addr_type = ADDR_LINES;\n\n    CLEAR_FIELD(dummy_cmdmod);\n    parse_command_modifiers(&ea, &dummy, &dummy_cmdmod, TRUE);\n\n    cmd = skip_range(ea.cmd, TRUE, NULL);\n    if (vim_strchr((char_u *)\"sgvl\", *cmd) == NULL)\n\tgoto theend;\n\n    // Skip over \"substitute\" to find the pattern separator.\n    for (p = cmd; ASCII_ISALPHA(*p); ++p)\n\t;\n    if (*skipwhite(p) == NUL)\n\tgoto theend;\n\n    if (STRNCMP(cmd, \"substitute\", p - cmd) == 0\n\t    || STRNCMP(cmd, \"smagic\", p - cmd) == 0\n\t    || STRNCMP(cmd, \"snomagic\", MAX(p - cmd, 3)) == 0\n\t    || STRNCMP(cmd, \"vglobal\", p - cmd) == 0)\n    {\n\tif (*cmd == 's' && cmd[1] == 'm')\n\t    magic_overruled = OPTION_MAGIC_ON;\n\telse if (*cmd == 's' && cmd[1] == 'n')\n\t    magic_overruled = OPTION_MAGIC_OFF;\n    }\n    else if (STRNCMP(cmd, \"sort\", MAX(p - cmd, 3)) == 0)\n    {\n\t// skip over ! and flags\n\tif (*p == '!')\n\t    p = skipwhite(p + 1);\n\twhile (ASCII_ISALPHA(*(p = skipwhite(p))))\n\t    ++p;\n\tif (*p == NUL)\n\t    goto theend;\n    }\n    else if (STRNCMP(cmd, \"vimgrep\", MAX(p - cmd, 3)) == 0\n\t|| STRNCMP(cmd, \"vimgrepadd\", MAX(p - cmd, 8)) == 0\n\t|| STRNCMP(cmd, \"lvimgrep\", MAX(p - cmd, 2)) == 0\n\t|| STRNCMP(cmd, \"lvimgrepadd\", MAX(p - cmd, 9)) == 0\n\t|| STRNCMP(cmd, \"global\", p - cmd) == 0)\n    {\n\t// skip over \"!\"\n\tif (*p == '!')\n\t{\n\t    p++;\n\t    if (*skipwhite(p) == NUL)\n\t\tgoto theend;\n\t}\n\tif (*cmd != 'g')\n\t    delim_optional = TRUE;\n    }\n    else\n\tgoto theend;\n\n    p = skipwhite(p);\n    delim = (delim_optional && vim_isIDc(*p)) ? ' ' : *p++;\n    *search_delim = delim;\n    end = skip_regexp_ex(p, delim, magic_isset(), NULL, NULL, &magic);\n\n    use_last_pat = end == p && *end == delim;\n\n    if (end == p && !use_last_pat)\n\tgoto theend;\n\n    // Don't do 'hlsearch' highlighting if the pattern matches everything.\n    if (!use_last_pat)\n    {\n\tchar c = *end;\n\tint  empty;\n\n\t*end = NUL;\n\tempty = empty_pattern_magic(p, STRLEN(p), magic);\n\t*end = c;\n\tif (empty)\n\t    goto theend;\n    }\n\n    // found a non-empty pattern or //\n    *skiplen = (int)(p - ccline.cmdbuff);\n    *patlen = (int)(end - p);\n\n    // parse the address range\n    save_cursor = curwin->w_cursor;\n    curwin->w_cursor = is_state->search_start;\n    parse_cmd_address(&ea, &dummy, TRUE);\n    if (ea.addr_count > 0)\n    {\n\t// Allow for reverse match.\n\tif (ea.line2 < ea.line1)\n\t{\n\t    search_first_line = ea.line2;\n\t    search_last_line = ea.line1;\n\t}\n\telse\n\t{\n\t    search_first_line = ea.line1;\n\t    search_last_line = ea.line2;\n\t}\n    }\n    else if (cmd[0] == 's' && cmd[1] != 'o')\n    {\n\t// :s defaults to the current line\n\tsearch_first_line = curwin->w_cursor.lnum;\n\tsearch_last_line = curwin->w_cursor.lnum;\n    }\n\n    curwin->w_cursor = save_cursor;\n    retval = TRUE;\ntheend:\n    --emsg_off;\n    return retval;\n}\n\n    static void\nfinish_incsearch_highlighting(\n\tint gotesc,\n\tincsearch_state_T *is_state,\n\tint call_update_screen)\n{\n    if (is_state->did_incsearch)\n    {\n\tis_state->did_incsearch = FALSE;\n\tif (gotesc)\n\t    curwin->w_cursor = is_state->save_cursor;\n\telse\n\t{\n\t    if (!EQUAL_POS(is_state->save_cursor, is_state->search_start))\n\t    {\n\t\t// put the '\" mark at the original position\n\t\tcurwin->w_cursor = is_state->save_cursor;\n\t\tsetpcmark();\n\t    }\n\t    curwin->w_cursor = is_state->search_start;\n\t}\n\trestore_viewstate(&is_state->old_viewstate);\n\thighlight_match = FALSE;\n\n\t// by default search all lines\n\tsearch_first_line = 0;\n\tsearch_last_line = MAXLNUM;\n\n\tmagic_overruled = is_state->magic_overruled_save;\n\n\tvalidate_cursor();\t// needed for TAB\n\tredraw_all_later(SOME_VALID);\n\tif (call_update_screen)\n\t    update_screen(SOME_VALID);\n    }\n}\n\n/*\n * Do 'incsearch' highlighting if desired.\n */\n    static void\nmay_do_incsearch_highlighting(\n\tint\t\t    firstc,\n\tlong\t\t    count,\n\tincsearch_state_T   *is_state)\n{\n    int\t\tskiplen, patlen;\n    int\t\tfound;  // do_search() result\n    pos_T\tend_pos;\n#ifdef FEAT_RELTIME\n    proftime_T\ttm;\n    searchit_arg_T sia;\n#endif\n    int\t\tnext_char;\n    int\t\tuse_last_pat;\n    int\t\tdid_do_incsearch = is_state->did_incsearch;\n    int\t\tsearch_delim;\n\n    // Parsing range may already set the last search pattern.\n    // NOTE: must call restore_last_search_pattern() before returning!\n    save_last_search_pattern();\n\n    if (!do_incsearch_highlighting(firstc, &search_delim, is_state,\n\t\t\t\t\t\t\t    &skiplen, &patlen))\n    {\n\trestore_last_search_pattern();\n\tfinish_incsearch_highlighting(FALSE, is_state, TRUE);\n\tif (did_do_incsearch && vpeekc() == NUL)\n\t    // may have skipped a redraw, do it now\n\t    redrawcmd();\n\treturn;\n    }\n\n    // If there is a character waiting, search and redraw later.\n    if (char_avail())\n    {\n\trestore_last_search_pattern();\n\tis_state->incsearch_postponed = TRUE;\n\treturn;\n    }\n    is_state->incsearch_postponed = FALSE;\n\n    if (search_first_line == 0)\n\t// start at the original cursor position\n\tcurwin->w_cursor = is_state->search_start;\n    else if (search_first_line > curbuf->b_ml.ml_line_count)\n    {\n\t// start after the last line\n\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\tcurwin->w_cursor.col = MAXCOL;\n    }\n    else\n    {\n\t// start at the first line in the range\n\tcurwin->w_cursor.lnum = search_first_line;\n\tcurwin->w_cursor.col = 0;\n    }\n\n    // Use the previous pattern for \":s//\".\n    next_char = ccline.cmdbuff[skiplen + patlen];\n    use_last_pat = patlen == 0 && skiplen > 0\n\t\t\t\t   && ccline.cmdbuff[skiplen - 1] == next_char;\n\n    // If there is no pattern, don't do anything.\n    if (patlen == 0 && !use_last_pat)\n    {\n\tfound = 0;\n\tset_no_hlsearch(TRUE); // turn off previous highlight\n\tredraw_all_later(SOME_VALID);\n    }\n    else\n    {\n\tint search_flags = SEARCH_OPT + SEARCH_NOOF + SEARCH_PEEK;\n\n\tcursor_off();\t// so the user knows we're busy\n\tout_flush();\n\t++emsg_off;\t// so it doesn't beep if bad expr\n#ifdef FEAT_RELTIME\n\t// Set the time limit to half a second.\n\tprofile_setlimit(500L, &tm);\n#endif\n\tif (!p_hls)\n\t    search_flags += SEARCH_KEEP;\n\tif (search_first_line != 0)\n\t    search_flags += SEARCH_START;\n\tccline.cmdbuff[skiplen + patlen] = NUL;\n#ifdef FEAT_RELTIME\n\tCLEAR_FIELD(sia);\n\tsia.sa_tm = &tm;\n#endif\n\tfound = do_search(NULL, firstc == ':' ? '/' : firstc, search_delim,\n\t\t\t\t ccline.cmdbuff + skiplen, count, search_flags,\n#ifdef FEAT_RELTIME\n\t\t&sia\n#else\n\t\tNULL\n#endif\n\t\t);\n\tccline.cmdbuff[skiplen + patlen] = next_char;\n\t--emsg_off;\n\n\tif (curwin->w_cursor.lnum < search_first_line\n\t\t|| curwin->w_cursor.lnum > search_last_line)\n\t{\n\t    // match outside of address range\n\t    found = 0;\n\t    curwin->w_cursor = is_state->search_start;\n\t}\n\n\t// if interrupted while searching, behave like it failed\n\tif (got_int)\n\t{\n\t    (void)vpeekc();\t// remove <C-C> from input stream\n\t    got_int = FALSE;\t// don't abandon the command line\n\t    found = 0;\n\t}\n\telse if (char_avail())\n\t    // cancelled searching because a char was typed\n\t    is_state->incsearch_postponed = TRUE;\n    }\n    if (found != 0)\n\thighlight_match = TRUE;\t\t// highlight position\n    else\n\thighlight_match = FALSE;\t// remove highlight\n\n    // First restore the old curwin values, so the screen is positioned in the\n    // same way as the actual search command.\n    restore_viewstate(&is_state->old_viewstate);\n    changed_cline_bef_curs();\n    update_topline();\n\n    if (found != 0)\n    {\n\tpos_T\t    save_pos = curwin->w_cursor;\n\n\tis_state->match_start = curwin->w_cursor;\n\tset_search_match(&curwin->w_cursor);\n\tvalidate_cursor();\n\tend_pos = curwin->w_cursor;\n\tis_state->match_end = end_pos;\n\tcurwin->w_cursor = save_pos;\n    }\n    else\n\tend_pos = curwin->w_cursor; // shutup gcc 4\n\n    // Disable 'hlsearch' highlighting if the pattern matches everything.\n    // Avoids a flash when typing \"foo\\|\".\n    if (!use_last_pat)\n    {\n\tnext_char = ccline.cmdbuff[skiplen + patlen];\n\tccline.cmdbuff[skiplen + patlen] = NUL;\n\tif (empty_pattern(ccline.cmdbuff + skiplen, search_delim)\n\t\t\t\t\t\t\t       && !no_hlsearch)\n\t{\n\t    redraw_all_later(SOME_VALID);\n\t    set_no_hlsearch(TRUE);\n\t}\n\tccline.cmdbuff[skiplen + patlen] = next_char;\n    }\n\n    validate_cursor();\n    // May redraw the status line to show the cursor position.\n    if (p_ru && curwin->w_status_height > 0)\n\tcurwin->w_redr_status = TRUE;\n\n    update_screen(SOME_VALID);\n    highlight_match = FALSE;\n    restore_last_search_pattern();\n\n    // Leave it at the end to make CTRL-R CTRL-W work.  But not when beyond the\n    // end of the pattern, e.g. for \":s/pat/\".\n    if (ccline.cmdbuff[skiplen + patlen] != NUL)\n\tcurwin->w_cursor = is_state->search_start;\n    else if (found != 0)\n\tcurwin->w_cursor = end_pos;\n\n    msg_starthere();\n    redrawcmdline();\n    is_state->did_incsearch = TRUE;\n}\n\n/*\n * May adjust 'incsearch' highlighting for typing CTRL-G and CTRL-T, go to next\n * or previous match.\n * Returns FAIL when jumping to cmdline_not_changed;\n */\n    static int\nmay_adjust_incsearch_highlighting(\n\tint\t\t\tfirstc,\n\tlong\t\t\tcount,\n\tincsearch_state_T\t*is_state,\n\tint\t\t\tc)\n{\n    int\t    skiplen, patlen;\n    pos_T   t;\n    char_u  *pat;\n    int\t    search_flags = SEARCH_NOOF;\n    int\t    i;\n    int\t    save;\n    int\t    search_delim;\n\n    // Parsing range may already set the last search pattern.\n    // NOTE: must call restore_last_search_pattern() before returning!\n    save_last_search_pattern();\n\n    if (!do_incsearch_highlighting(firstc, &search_delim, is_state,\n\t\t\t\t\t\t\t    &skiplen, &patlen))\n    {\n\trestore_last_search_pattern();\n\treturn OK;\n    }\n    if (patlen == 0 && ccline.cmdbuff[skiplen] == NUL)\n    {\n\trestore_last_search_pattern();\n\treturn FAIL;\n    }\n\n    if (search_delim == ccline.cmdbuff[skiplen])\n    {\n\tpat = last_search_pattern();\n\tif (pat == NULL)\n\t{\n\t    restore_last_search_pattern();\n\t    return FAIL;\n\t}\n\tskiplen = 0;\n\tpatlen = (int)STRLEN(pat);\n    }\n    else\n\tpat = ccline.cmdbuff + skiplen;\n\n    cursor_off();\n    out_flush();\n    if (c == Ctrl_G)\n    {\n\tt = is_state->match_end;\n\tif (LT_POS(is_state->match_start, is_state->match_end))\n\t    // Start searching at the end of the match not at the beginning of\n\t    // the next column.\n\t    (void)decl(&t);\n\tsearch_flags += SEARCH_COL;\n    }\n    else\n\tt = is_state->match_start;\n    if (!p_hls)\n\tsearch_flags += SEARCH_KEEP;\n    ++emsg_off;\n    save = pat[patlen];\n    pat[patlen] = NUL;\n    i = searchit(curwin, curbuf, &t, NULL,\n\t\t c == Ctrl_G ? FORWARD : BACKWARD,\n\t\t pat, count, search_flags, RE_SEARCH, NULL);\n    --emsg_off;\n    pat[patlen] = save;\n    if (i)\n    {\n\tis_state->search_start = is_state->match_start;\n\tis_state->match_end = t;\n\tis_state->match_start = t;\n\tif (c == Ctrl_T && firstc != '?')\n\t{\n\t    // Move just before the current match, so that when nv_search\n\t    // finishes the cursor will be put back on the match.\n\t    is_state->search_start = t;\n\t    (void)decl(&is_state->search_start);\n\t}\n\telse if (c == Ctrl_G && firstc == '?')\n\t{\n\t    // Move just after the current match, so that when nv_search\n\t    // finishes the cursor will be put back on the match.\n\t    is_state->search_start = t;\n\t    (void)incl(&is_state->search_start);\n\t}\n\tif (LT_POS(t, is_state->search_start) && c == Ctrl_G)\n\t{\n\t    // wrap around\n\t    is_state->search_start = t;\n\t    if (firstc == '?')\n\t\t(void)incl(&is_state->search_start);\n\t    else\n\t\t(void)decl(&is_state->search_start);\n\t}\n\n\tset_search_match(&is_state->match_end);\n\tcurwin->w_cursor = is_state->match_start;\n\tchanged_cline_bef_curs();\n\tupdate_topline();\n\tvalidate_cursor();\n\thighlight_match = TRUE;\n\tsave_viewstate(&is_state->old_viewstate);\n\tupdate_screen(NOT_VALID);\n\thighlight_match = FALSE;\n\tredrawcmdline();\n\tcurwin->w_cursor = is_state->match_end;\n    }\n    else\n\tvim_beep(BO_ERROR);\n    restore_last_search_pattern();\n    return FAIL;\n}\n\n/*\n * When CTRL-L typed: add character from the match to the pattern.\n * May set \"*c\" to the added character.\n * Return OK when jumping to cmdline_not_changed.\n */\n    static int\nmay_add_char_to_search(int firstc, int *c, incsearch_state_T *is_state)\n{\n    int\t\tskiplen, patlen, search_delim;\n\n    // Parsing range may already set the last search pattern.\n    // NOTE: must call restore_last_search_pattern() before returning!\n    save_last_search_pattern();\n\n    if (!do_incsearch_highlighting(firstc, &search_delim, is_state,\n\t\t\t\t\t\t\t    &skiplen, &patlen))\n    {\n\trestore_last_search_pattern();\n\treturn FAIL;\n    }\n    restore_last_search_pattern();\n\n    // Add a character from under the cursor for 'incsearch'.\n    if (is_state->did_incsearch)\n    {\n\tcurwin->w_cursor = is_state->match_end;\n\t*c = gchar_cursor();\n\tif (*c != NUL)\n\t{\n\t    // If 'ignorecase' and 'smartcase' are set and the\n\t    // command line has no uppercase characters, convert\n\t    // the character to lowercase.\n\t    if (p_ic && p_scs && !pat_has_uppercase(ccline.cmdbuff + skiplen))\n\t\t*c = MB_TOLOWER(*c);\n\t    if (*c == search_delim || vim_strchr((char_u *)(\n\t\t\t     magic_isset() ? \"\\\\~^$.*[\" : \"\\\\^$\"), *c) != NULL)\n\t    {\n\t\t// put a backslash before special characters\n\t\tstuffcharReadbuff(*c);\n\t\t*c = '\\\\';\n\t    }\n\t    // add any composing characters\n\t    if (mb_char2len(*c) != mb_ptr2len(ml_get_cursor()))\n\t    {\n\t\tint save_c = *c;\n\n\t\twhile (mb_char2len(*c) != mb_ptr2len(ml_get_cursor()))\n\t\t{\n\t\t    curwin->w_cursor.col += mb_char2len(*c);\n\t\t    *c = gchar_cursor();\n\t\t    stuffcharReadbuff(*c);\n\t\t}\n\t\t*c = save_c;\n\t    }\n\t    return FAIL;\n\t}\n    }\n    return OK;\n}\n#endif\n\n#ifdef FEAT_ARABIC\n/*\n * Return TRUE if the command line has an Arabic character at or after \"start\"\n * for \"len\" bytes.\n */\n    static int\ncmdline_has_arabic(int start, int len)\n{\n    int\t    j;\n    int\t    mb_l;\n    int\t    u8c;\n    char_u  *p;\n    int\t    u8cc[MAX_MCO];\n\n    if (!enc_utf8)\n\treturn FALSE;\n\n    for (j = start; j < start + len; j += mb_l)\n    {\n\tp = ccline.cmdbuff + j;\n\tu8c = utfc_ptr2char_len(p, u8cc, start + len - j);\n\tmb_l = utfc_ptr2len_len(p, start + len - j);\n\tif (ARABIC_CHAR(u8c))\n\t    return TRUE;\n    }\n    return FALSE;\n}\n#endif\n\n    void\ncmdline_init(void)\n{\n    CLEAR_FIELD(ccline);\n}\n\n/*\n * Handle the backslash key pressed in the command-line mode.  CTRL-\\ CTRL-N\n * goes to Normal mode, CTRL-\\ CTRL-G goes to Insert mode when 'insertmode' is\n * set, CTRL-\\ e prompts for an expression.\n */\n    static int\ncmdline_handle_backslash_key(int c, int *gotesc)\n{\n    ++no_mapping;\n    ++allow_keys;\n    c = plain_vgetc();\n    --no_mapping;\n    --allow_keys;\n\n    // CTRL-\\ e doesn't work when obtaining an expression, unless it\n    // is in a mapping.\n    if (c != Ctrl_N && c != Ctrl_G && (c != 'e'\n\t\t|| (ccline.cmdfirstc == '=' && KeyTyped)\n#ifdef FEAT_EVAL\n\t\t|| cmdline_star > 0\n#endif\n\t\t))\n    {\n\tvungetc(c);\n\treturn PROCESS_NEXT_KEY;\n    }\n\n#ifdef FEAT_EVAL\n    if (c == 'e')\n    {\n\tchar_u\t*p = NULL;\n\tint\tlen;\n\n\t/*\n\t * Replace the command line with the result of an expression.\n\t * Need to save and restore the current command line, to be\n\t * able to enter a new one...\n\t */\n\tif (ccline.cmdpos == ccline.cmdlen)\n\t    new_cmdpos = 99999;\t// keep it at the end\n\telse\n\t    new_cmdpos = ccline.cmdpos;\n\n\tc = get_expr_register();\n\tif (c == '=')\n\t{\n\t    // Need to save and restore ccline.  And set \"textlock\"\n\t    // to avoid nasty things like going to another buffer when\n\t    // evaluating an expression.\n\t    ++textlock;\n\t    p = get_expr_line();\n\t    --textlock;\n\n\t    if (p != NULL)\n\t    {\n\t\tlen = (int)STRLEN(p);\n\t\tif (realloc_cmdbuff(len + 1) == OK)\n\t\t{\n\t\t    ccline.cmdlen = len;\n\t\t    STRCPY(ccline.cmdbuff, p);\n\t\t    vim_free(p);\n\n\t\t    // Restore the cursor or use the position set with\n\t\t    // set_cmdline_pos().\n\t\t    if (new_cmdpos > ccline.cmdlen)\n\t\t\tccline.cmdpos = ccline.cmdlen;\n\t\t    else\n\t\t\tccline.cmdpos = new_cmdpos;\n\n\t\t    KeyTyped = FALSE;\t// Don't do p_wc completion.\n\t\t    redrawcmd();\n\t\t    return CMDLINE_CHANGED;\n\t\t}\n\t\tvim_free(p);\n\t    }\n\t}\n\tbeep_flush();\n\tgot_int = FALSE;\t// don't abandon the command line\n\tdid_emsg = FALSE;\n\temsg_on_display = FALSE;\n\tredrawcmd();\n\treturn CMDLINE_NOT_CHANGED;\n    }\n#endif\n\n    if (c == Ctrl_G && p_im && restart_edit == 0)\n\trestart_edit = 'a';\n    *gotesc = TRUE;\t// will free ccline.cmdbuff after putting it\n\t\t\t// in history\n    return GOTO_NORMAL_MODE;\n}\n\n/*\n * Completion for 'wildchar' or 'wildcharm' key.\n * - hitting <ESC> twice means: abandon command line.\n * - wildcard expansion is only done when the 'wildchar' key is really\n *   typed, not when it comes from a macro\n * Returns CMDLINE_CHANGED if command line is changed or CMDLINE_NOT_CHANGED.\n */\n    static int\ncmdline_wildchar_complete(\n\tint\t\tc,\n\tint\t\tescape,\n\tint\t\t*did_wild_list,\n\tint\t\t*wim_index_p,\n\texpand_T\t*xp,\n\tint\t\t*gotesc)\n{\n    int\t\twim_index = *wim_index_p;\n    int\t\tres;\n    int\t\tj;\n    int\t\toptions = WILD_NO_BEEP;\n\n    if (wim_flags[wim_index] & WIM_BUFLASTUSED)\n\toptions |= WILD_BUFLASTUSED;\n    if (xp->xp_numfiles > 0)   // typed p_wc at least twice\n    {\n\t// if 'wildmode' contains \"list\" may still need to list\n\tif (xp->xp_numfiles > 1\n\t\t&& !*did_wild_list\n\t\t&& ((wim_flags[wim_index] & WIM_LIST)\n#ifdef FEAT_WILDMENU\n\t\t    || (p_wmnu && (wim_flags[wim_index] & WIM_FULL) != 0)\n#endif\n\t\t    ))\n\t{\n#ifdef FEAT_WILDMENU\n\t    (void)showmatches(xp,\n\t\t    p_wmnu && ((wim_flags[wim_index] & WIM_LIST) == 0));\n#else\n\t    (void)showmatches(xp, FALSE);\n#endif\n\t    redrawcmd();\n\t    *did_wild_list = TRUE;\n\t}\n\tif (wim_flags[wim_index] & WIM_LONGEST)\n\t    res = nextwild(xp, WILD_LONGEST, options, escape);\n\telse if (wim_flags[wim_index] & WIM_FULL)\n\t    res = nextwild(xp, WILD_NEXT, options, escape);\n\telse\n\t    res = OK;\t    // don't insert 'wildchar' now\n    }\n    else\t\t    // typed p_wc first time\n    {\n\twim_index = 0;\n\tj = ccline.cmdpos;\n\t// if 'wildmode' first contains \"longest\", get longest\n\t// common part\n\tif (wim_flags[0] & WIM_LONGEST)\n\t    res = nextwild(xp, WILD_LONGEST, options, escape);\n\telse\n\t    res = nextwild(xp, WILD_EXPAND_KEEP, options, escape);\n\n\t// if interrupted while completing, behave like it failed\n\tif (got_int)\n\t{\n\t    (void)vpeekc();\t// remove <C-C> from input stream\n\t    got_int = FALSE;\t// don't abandon the command line\n\t    (void)ExpandOne(xp, NULL, NULL, 0, WILD_FREE);\n#ifdef FEAT_WILDMENU\n\t    xp->xp_context = EXPAND_NOTHING;\n#endif\n\t    *wim_index_p = wim_index;\n\t    return CMDLINE_CHANGED;\n\t}\n\n\t// when more than one match, and 'wildmode' first contains\n\t// \"list\", or no change and 'wildmode' contains \"longest,list\",\n\t// list all matches\n\tif (res == OK && xp->xp_numfiles > 1)\n\t{\n\t    // a \"longest\" that didn't do anything is skipped (but not\n\t    // \"list:longest\")\n\t    if (wim_flags[0] == WIM_LONGEST && ccline.cmdpos == j)\n\t\twim_index = 1;\n\t    if ((wim_flags[wim_index] & WIM_LIST)\n#ifdef FEAT_WILDMENU\n\t\t    || (p_wmnu && (wim_flags[wim_index] & WIM_FULL) != 0)\n#endif\n\t       )\n\t    {\n\t\tif (!(wim_flags[0] & WIM_LONGEST))\n\t\t{\n#ifdef FEAT_WILDMENU\n\t\t    int p_wmnu_save = p_wmnu;\n\t\t    p_wmnu = 0;\n#endif\n\t\t    // remove match\n\t\t    nextwild(xp, WILD_PREV, 0, escape);\n#ifdef FEAT_WILDMENU\n\t\t    p_wmnu = p_wmnu_save;\n#endif\n\t\t}\n#ifdef FEAT_WILDMENU\n\t\t(void)showmatches(xp, p_wmnu\n\t\t\t&& ((wim_flags[wim_index] & WIM_LIST) == 0));\n#else\n\t\t(void)showmatches(xp, FALSE);\n#endif\n\t\tredrawcmd();\n\t\t*did_wild_list = TRUE;\n\t\tif (wim_flags[wim_index] & WIM_LONGEST)\n\t\t    nextwild(xp, WILD_LONGEST, options, escape);\n\t\telse if (wim_flags[wim_index] & WIM_FULL)\n\t\t    nextwild(xp, WILD_NEXT, options, escape);\n\t    }\n\t    else\n\t\tvim_beep(BO_WILD);\n\t}\n#ifdef FEAT_WILDMENU\n\telse if (xp->xp_numfiles == -1)\n\t    xp->xp_context = EXPAND_NOTHING;\n#endif\n    }\n    if (wim_index < 3)\n\t++wim_index;\n    if (c == ESC)\n\t*gotesc = TRUE;\n\n    *wim_index_p = wim_index;\n    return (res == OK) ? CMDLINE_CHANGED : CMDLINE_NOT_CHANGED;\n}\n\n/*\n * Handle backspace, delete and CTRL-W keys in the command-line mode.\n * Returns:\n *  CMDLINE_NOT_CHANGED - if the command line is not changed\n *  CMDLINE_CHANGED - if the command line is changed\n *  GOTO_NORMAL_MODE - go back to normal mode\n */\n    static int\ncmdline_erase_chars(\n\tint c,\n\tint indent\n#ifdef FEAT_SEARCH_EXTRA\n\t, incsearch_state_T *isp\n#endif\n\t)\n{\n    int\t\ti;\n    int\t\tj;\n\n    if (c == K_KDEL)\n\tc = K_DEL;\n\n    /*\n     * Delete current character is the same as backspace on next\n     * character, except at end of line.\n     */\n    if (c == K_DEL && ccline.cmdpos != ccline.cmdlen)\n\t++ccline.cmdpos;\n    if (has_mbyte && c == K_DEL)\n\tccline.cmdpos += mb_off_next(ccline.cmdbuff,\n\t\tccline.cmdbuff + ccline.cmdpos);\n    if (ccline.cmdpos > 0)\n    {\n\tchar_u *p;\n\n\tj = ccline.cmdpos;\n\tp = ccline.cmdbuff + j;\n\tif (has_mbyte)\n\t{\n\t    p = mb_prevptr(ccline.cmdbuff, p);\n\t    if (c == Ctrl_W)\n\t    {\n\t\twhile (p > ccline.cmdbuff && vim_isspace(*p))\n\t\t    p = mb_prevptr(ccline.cmdbuff, p);\n\t\ti = mb_get_class(p);\n\t\twhile (p > ccline.cmdbuff && mb_get_class(p) == i)\n\t\t    p = mb_prevptr(ccline.cmdbuff, p);\n\t\tif (mb_get_class(p) != i)\n\t\t    p += (*mb_ptr2len)(p);\n\t    }\n\t}\n\telse if (c == Ctrl_W)\n\t{\n\t    while (p > ccline.cmdbuff && vim_isspace(p[-1]))\n\t\t--p;\n\t    if (p > ccline.cmdbuff)\n\t    {\n\t\ti = vim_iswordc(p[-1]);\n\t\twhile (p > ccline.cmdbuff && !vim_isspace(p[-1])\n\t\t\t&& vim_iswordc(p[-1]) == i)\n\t\t    --p;\n\t    }\n\t}\n\telse\n\t    --p;\n\tccline.cmdpos = (int)(p - ccline.cmdbuff);\n\tccline.cmdlen -= j - ccline.cmdpos;\n\ti = ccline.cmdpos;\n\twhile (i < ccline.cmdlen)\n\t    ccline.cmdbuff[i++] = ccline.cmdbuff[j++];\n\n\t// Truncate at the end, required for multi-byte chars.\n\tccline.cmdbuff[ccline.cmdlen] = NUL;\n#ifdef FEAT_SEARCH_EXTRA\n\tif (ccline.cmdlen == 0)\n\t{\n\t    isp->search_start = isp->save_cursor;\n\t    // save view settings, so that the screen\n\t    // won't be restored at the wrong position\n\t    isp->old_viewstate = isp->init_viewstate;\n\t}\n#endif\n\tredrawcmd();\n    }\n    else if (ccline.cmdlen == 0 && c != Ctrl_W\n\t    && ccline.cmdprompt == NULL && indent == 0)\n    {\n\t// In ex and debug mode it doesn't make sense to return.\n\tif (exmode_active\n#ifdef FEAT_EVAL\n\t\t|| ccline.cmdfirstc == '>'\n#endif\n\t   )\n\t    return CMDLINE_NOT_CHANGED;\n\n\tVIM_CLEAR(ccline.cmdbuff);\t// no commandline to return\n\tif (!cmd_silent)\n\t{\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmdmsg_rl)\n\t\tmsg_col = Columns;\n\t    else\n#endif\n\t\tmsg_col = 0;\n\t    msg_putchar(' ');\t\t// delete ':'\n\t}\n#ifdef FEAT_SEARCH_EXTRA\n\tif (ccline.cmdlen == 0)\n\t    isp->search_start = isp->save_cursor;\n#endif\n\tredraw_cmdline = TRUE;\n\treturn GOTO_NORMAL_MODE;\n    }\n    return CMDLINE_CHANGED;\n}\n\n/*\n * Handle the CTRL-^ key in the command-line mode and toggle the use of the\n * language :lmap mappings and/or Input Method.\n */\n    static void\ncmdline_toggle_langmap(long *b_im_ptr)\n{\n    if (map_to_exists_mode((char_u *)\"\", MODE_LANGMAP, FALSE))\n    {\n\t// \":lmap\" mappings exists, toggle use of mappings.\n\tState ^= MODE_LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n\tim_set_active(FALSE);\t// Disable input method\n#endif\n\tif (b_im_ptr != NULL)\n\t{\n\t    if (State & MODE_LANGMAP)\n\t\t*b_im_ptr = B_IMODE_LMAP;\n\t    else\n\t\t*b_im_ptr = B_IMODE_NONE;\n\t}\n    }\n#ifdef HAVE_INPUT_METHOD\n    else\n    {\n\t// There are no \":lmap\" mappings, toggle IM.  When\n\t// 'imdisable' is set don't try getting the status, it's\n\t// always off.\n\tif ((p_imdisable && b_im_ptr != NULL)\n\t\t? *b_im_ptr == B_IMODE_IM : im_get_status())\n\t{\n\t    im_set_active(FALSE);\t// Disable input method\n\t    if (b_im_ptr != NULL)\n\t\t*b_im_ptr = B_IMODE_NONE;\n\t}\n\telse\n\t{\n\t    im_set_active(TRUE);\t// Enable input method\n\t    if (b_im_ptr != NULL)\n\t\t*b_im_ptr = B_IMODE_IM;\n\t}\n    }\n#endif\n    if (b_im_ptr != NULL)\n    {\n\tif (b_im_ptr == &curbuf->b_p_iminsert)\n\t    set_iminsert_global();\n\telse\n\t    set_imsearch_global();\n    }\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t// may show different cursor shape\n#endif\n#if defined(FEAT_KEYMAP)\n    // Show/unshow value of 'keymap' in status lines later.\n    status_redraw_curbuf();\n#endif\n}\n\n/*\n * Handle the CTRL-R key in the command-line mode and insert the contents of a\n * numbered or named register.\n */\n    static int\ncmdline_insert_reg(int *gotesc UNUSED)\n{\n    int\t\ti;\n    int\t\tc;\n\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t// disallow scrolling here\n#endif\n    putcmdline('\"', TRUE);\n    ++no_mapping;\n    ++allow_keys;\n    i = c = plain_vgetc();\t// CTRL-R <char>\n    if (i == Ctrl_O)\n\ti = Ctrl_R;\t\t// CTRL-R CTRL-O == CTRL-R CTRL-R\n    if (i == Ctrl_R)\n\tc = plain_vgetc();\t// CTRL-R CTRL-R <char>\n    extra_char = NUL;\n    --no_mapping;\n    --allow_keys;\n#ifdef FEAT_EVAL\n    /*\n     * Insert the result of an expression.\n     * Need to save the current command line, to be able to enter\n     * a new one...\n     */\n    new_cmdpos = -1;\n    if (c == '=')\n    {\n\tif (ccline.cmdfirstc == '='  // can't do this recursively\n\t\t|| cmdline_star > 0) // or when typing a password\n\t{\n\t    beep_flush();\n\t    c = ESC;\n\t}\n\telse\n\t    c = get_expr_register();\n    }\n#endif\n    if (c != ESC)\t    // use ESC to cancel inserting register\n    {\n\tcmdline_paste(c, i == Ctrl_R, FALSE);\n\n#ifdef FEAT_EVAL\n\t// When there was a serious error abort getting the\n\t// command line.\n\tif (aborting())\n\t{\n\t    *gotesc = TRUE;  // will free ccline.cmdbuff after\n\t    // putting it in history\n\t    return GOTO_NORMAL_MODE;\n\t}\n#endif\n\tKeyTyped = FALSE;\t// Don't do p_wc completion.\n#ifdef FEAT_EVAL\n\tif (new_cmdpos >= 0)\n\t{\n\t    // set_cmdline_pos() was used\n\t    if (new_cmdpos > ccline.cmdlen)\n\t\tccline.cmdpos = ccline.cmdlen;\n\t    else\n\t\tccline.cmdpos = new_cmdpos;\n\t}\n#endif\n    }\n    // remove the double quote\n    redrawcmd();\n\n    // The text has been stuffed, the command line didn't change yet.\n    return CMDLINE_NOT_CHANGED;\n}\n\n/*\n * Handle the Left and Right mouse clicks in the command-line mode.\n */\n    static void\ncmdline_left_right_mouse(int c, int *ignore_drag_release)\n{\n    if (c == K_LEFTRELEASE || c == K_RIGHTRELEASE)\n\t*ignore_drag_release = TRUE;\n    else\n\t*ignore_drag_release = FALSE;\n# ifdef FEAT_GUI\n    // When GUI is active, also move when 'mouse' is empty\n    if (!gui.in_use)\n# endif\n\tif (!mouse_has(MOUSE_COMMAND))\n\t    return;\n# ifdef FEAT_CLIPBOARD\n    if (mouse_row < cmdline_row && clip_star.available)\n    {\n\tint\t    button, is_click, is_drag;\n\n\t/*\n\t * Handle modeless selection.\n\t */\n\tbutton = get_mouse_button(KEY2TERMCAP1(c),\n\t\t&is_click, &is_drag);\n\tif (mouse_model_popup() && button == MOUSE_LEFT\n\t\t&& (mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    // Translate shift-left to right button.\n\t    button = MOUSE_RIGHT;\n\t    mod_mask &= ~MOD_MASK_SHIFT;\n\t}\n\tclip_modeless(button, is_click, is_drag);\n\treturn;\n    }\n# endif\n\n    set_cmdspos();\n    for (ccline.cmdpos = 0; ccline.cmdpos < ccline.cmdlen;\n\t    ++ccline.cmdpos)\n    {\n\tint\ti;\n\n\ti = cmdline_charsize(ccline.cmdpos);\n\tif (mouse_row <= cmdline_row + ccline.cmdspos / Columns\n\t\t&& mouse_col < ccline.cmdspos % Columns + i)\n\t    break;\n\tif (has_mbyte)\n\t{\n\t    // Count \">\" for double-wide char that doesn't fit.\n\t    correct_cmdspos(ccline.cmdpos, i);\n\t    ccline.cmdpos += (*mb_ptr2len)(ccline.cmdbuff\n\t\t    + ccline.cmdpos) - 1;\n\t}\n\tccline.cmdspos += i;\n    }\n}\n\n/*\n * Handle the Up, Down, Page Up, Page down, CTRL-N and CTRL-P key in the\n * command-line mode. The pressed key is in 'c'.\n * Returns:\n *  CMDLINE_NOT_CHANGED - if the command line is not changed\n *  CMDLINE_CHANGED - if the command line is changed\n *  GOTO_NORMAL_MODE - go back to normal mode\n */\n    static int\ncmdline_browse_history(\n\tint\tc,\n\tint\tfirstc,\n\tchar_u\t**curcmdstr,\n\tint\thistype,\n\tint\t*hiscnt_p,\n\texpand_T *xp)\n{\n    int\t\ti;\n    int\t\tj;\n    char_u\t*lookfor = *curcmdstr;\n    int\t\thiscnt = *hiscnt_p;\n    int\t\tres;\n\n    if (get_hislen() == 0 || firstc == NUL)\t// no history\n\treturn CMDLINE_NOT_CHANGED;\n\n    i = hiscnt;\n\n    // save current command string so it can be restored later\n    if (lookfor == NULL)\n    {\n\tif ((lookfor = vim_strsave(ccline.cmdbuff)) == NULL)\n\t    return CMDLINE_NOT_CHANGED;\n\tlookfor[ccline.cmdpos] = NUL;\n    }\n\n    j = (int)STRLEN(lookfor);\n    for (;;)\n    {\n\t// one step backwards\n\tif (c == K_UP|| c == K_S_UP || c == Ctrl_P\n\t\t|| c == K_PAGEUP || c == K_KPAGEUP)\n\t{\n\t    if (hiscnt == get_hislen())\t// first time\n\t\thiscnt = *get_hisidx(histype);\n\t    else if (hiscnt == 0 && *get_hisidx(histype)\n\t\t    != get_hislen() - 1)\n\t\thiscnt = get_hislen() - 1;\n\t    else if (hiscnt != *get_hisidx(histype) + 1)\n\t\t--hiscnt;\n\t    else\t\t\t// at top of list\n\t    {\n\t\thiscnt = i;\n\t\tbreak;\n\t    }\n\t}\n\telse    // one step forwards\n\t{\n\t    // on last entry, clear the line\n\t    if (hiscnt == *get_hisidx(histype))\n\t    {\n\t\thiscnt = get_hislen();\n\t\tbreak;\n\t    }\n\n\t    // not on a history line, nothing to do\n\t    if (hiscnt == get_hislen())\n\t\tbreak;\n\t    if (hiscnt == get_hislen() - 1)   // wrap around\n\t\thiscnt = 0;\n\t    else\n\t\t++hiscnt;\n\t}\n\tif (hiscnt < 0 || get_histentry(histype)[hiscnt].hisstr\n\t\t== NULL)\n\t{\n\t    hiscnt = i;\n\t    break;\n\t}\n\tif ((c != K_UP && c != K_DOWN)\n\t\t|| hiscnt == i\n\t\t|| STRNCMP(get_histentry(histype)[hiscnt].hisstr,\n\t\t    lookfor, (size_t)j) == 0)\n\t    break;\n    }\n\n    if (hiscnt != i)\t// jumped to other entry\n    {\n\tchar_u\t*p;\n\tint\t\tlen;\n\tint\t\told_firstc;\n\n\tVIM_CLEAR(ccline.cmdbuff);\n\txp->xp_context = EXPAND_NOTHING;\n\tif (hiscnt == get_hislen())\n\t    p = lookfor;\t// back to the old one\n\telse\n\t    p = get_histentry(histype)[hiscnt].hisstr;\n\n\tif (histype == HIST_SEARCH\n\t\t&& p != lookfor\n\t\t&& (old_firstc = p[STRLEN(p) + 1]) != firstc)\n\t{\n\t    // Correct for the separator character used when\n\t    // adding the history entry vs the one used now.\n\t    // First loop: count length.\n\t    // Second loop: copy the characters.\n\t    for (i = 0; i <= 1; ++i)\n\t    {\n\t\tlen = 0;\n\t\tfor (j = 0; p[j] != NUL; ++j)\n\t\t{\n\t\t    // Replace old sep with new sep, unless it is\n\t\t    // escaped.\n\t\t    if (p[j] == old_firstc\n\t\t\t    && (j == 0 || p[j - 1] != '\\\\'))\n\t\t    {\n\t\t\tif (i > 0)\n\t\t\t    ccline.cmdbuff[len] = firstc;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Escape new sep, unless it is already\n\t\t\t// escaped.\n\t\t\tif (p[j] == firstc\n\t\t\t\t&& (j == 0 || p[j - 1] != '\\\\'))\n\t\t\t{\n\t\t\t    if (i > 0)\n\t\t\t\tccline.cmdbuff[len] = '\\\\';\n\t\t\t    ++len;\n\t\t\t}\n\t\t\tif (i > 0)\n\t\t\t    ccline.cmdbuff[len] = p[j];\n\t\t    }\n\t\t    ++len;\n\t\t}\n\t\tif (i == 0)\n\t\t{\n\t\t    alloc_cmdbuff(len);\n\t\t    if (ccline.cmdbuff == NULL)\n\t\t    {\n\t\t\tres = GOTO_NORMAL_MODE;\n\t\t\tgoto done;\n\t\t    }\n\t\t}\n\t    }\n\t    ccline.cmdbuff[len] = NUL;\n\t}\n\telse\n\t{\n\t    alloc_cmdbuff((int)STRLEN(p));\n\t    if (ccline.cmdbuff == NULL)\n\t    {\n\t\tres = GOTO_NORMAL_MODE;\n\t\tgoto done;\n\t    }\n\t    STRCPY(ccline.cmdbuff, p);\n\t}\n\n\tccline.cmdpos = ccline.cmdlen = (int)STRLEN(ccline.cmdbuff);\n\tredrawcmd();\n\tres = CMDLINE_CHANGED;\n\tgoto done;\n    }\n    beep_flush();\n    res = CMDLINE_NOT_CHANGED;\n\ndone:\n    *curcmdstr = lookfor;\n    *hiscnt_p = hiscnt;\n    return res;\n}\n\n/*\n * Initialize the current command-line info.\n */\n    static int\ninit_ccline(int firstc, int indent)\n{\n    ccline.overstrike = FALSE;\t\t    // always start in insert mode\n\n    /*\n     * set some variables for redrawcmd()\n     */\n    ccline.cmdfirstc = (firstc == '@' ? 0 : firstc);\n    ccline.cmdindent = (firstc > 0 ? indent : 0);\n\n    // alloc initial ccline.cmdbuff\n    alloc_cmdbuff(indent + 50);\n    if (ccline.cmdbuff == NULL)\n\treturn FAIL;\n    ccline.cmdlen = ccline.cmdpos = 0;\n    ccline.cmdbuff[0] = NUL;\n    sb_text_start_cmdline();\n\n    // autoindent for :insert and :append\n    if (firstc <= 0)\n    {\n\tvim_memset(ccline.cmdbuff, ' ', indent);\n\tccline.cmdbuff[indent] = NUL;\n\tccline.cmdpos = indent;\n\tccline.cmdspos = indent;\n\tccline.cmdlen = indent;\n    }\n\n    return OK;\n}\n\n/*\n * getcmdline() - accept a command line starting with firstc.\n *\n * firstc == ':'\t    get \":\" command line.\n * firstc == '/' or '?'\t    get search pattern\n * firstc == '='\t    get expression\n * firstc == '@'\t    get text for input() function\n * firstc == '>'\t    get text for debug mode\n * firstc == NUL\t    get text for :insert command\n * firstc == -1\t\t    like NUL, and break on CTRL-C\n *\n * The line is collected in ccline.cmdbuff, which is reallocated to fit the\n * command line.\n *\n * Careful: getcmdline() can be called recursively!\n *\n * Return pointer to allocated string if there is a commandline, NULL\n * otherwise.\n */\n    char_u *\ngetcmdline(\n    int\t\t  firstc,\n    long\t  count,\t// only used for incremental search\n    int\t\t  indent,\t// indent for inside conditionals\n    getline_opt_T do_concat UNUSED)\n{\n    return getcmdline_int(firstc, count, indent, TRUE);\n}\n\n    static char_u *\ngetcmdline_int(\n    int\t\tfirstc,\n    long\tcount UNUSED,\t// only used for incremental search\n    int\t\tindent,\t\t// indent for inside conditionals\n    int\t\tclear_ccline)\t// clear ccline first\n{\n    static int\tdepth = 0;\t    // call depth\n    int\t\tc;\n    int\t\ti;\n    int\t\tj;\n    int\t\tgotesc = FALSE;\t\t// TRUE when <ESC> just typed\n    int\t\tdo_abbr;\t\t// when TRUE check for abbr.\n    char_u\t*lookfor = NULL;\t// string to match\n    int\t\thiscnt;\t\t\t// current history line in use\n    int\t\thistype;\t\t// history type to be used\n#ifdef FEAT_SEARCH_EXTRA\n    incsearch_state_T\tis_state;\n#endif\n    int\t\tdid_wild_list = FALSE;\t// did wild_list() recently\n    int\t\twim_index = 0;\t\t// index in wim_flags[]\n    int\t\tres;\n    int\t\tsave_msg_scroll = msg_scroll;\n    int\t\tsave_State = State;\t// remember State when called\n    int\t\tsome_key_typed = FALSE;\t// one of the keys was typed\n    // mouse drag and release events are ignored, unless they are\n    // preceded with a mouse down event\n    int\t\tignore_drag_release = TRUE;\n#ifdef FEAT_EVAL\n    int\t\tbreak_ctrl_c = FALSE;\n#endif\n    expand_T\txpc;\n    long\t*b_im_ptr = NULL;\n    cmdline_info_T save_ccline;\n    int\t\tdid_save_ccline = FALSE;\n    int\t\tcmdline_type;\n    int\t\twild_type;\n\n    // one recursion level deeper\n    ++depth;\n\n    if (ccline.cmdbuff != NULL)\n    {\n\t// Being called recursively.  Since ccline is global, we need to save\n\t// the current buffer and restore it when returning.\n\tsave_cmdline(&save_ccline);\n\tdid_save_ccline = TRUE;\n    }\n    if (clear_ccline)\n\tCLEAR_FIELD(ccline);\n\n#ifdef FEAT_EVAL\n    if (firstc == -1)\n    {\n\tfirstc = NUL;\n\tbreak_ctrl_c = TRUE;\n    }\n#endif\n#ifdef FEAT_RIGHTLEFT\n    // start without Hebrew mapping for a command line\n    if (firstc == ':' || firstc == '=' || firstc == '>')\n\tcmd_hkmap = 0;\n#endif\n\n#ifdef FEAT_SEARCH_EXTRA\n    init_incsearch_state(&is_state);\n#endif\n\n    if (init_ccline(firstc, indent) != OK)\n\tgoto theend;\t// out of memory\n\n    if (depth == 50)\n    {\n\t// Somehow got into a loop recursively calling getcmdline(), bail out.\n\temsg(_(e_command_too_recursive));\n\tgoto theend;\n    }\n\n    ExpandInit(&xpc);\n    ccline.xpc = &xpc;\n\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl && *curwin->w_p_rlc == 's'\n\t\t\t\t\t  && (firstc == '/' || firstc == '?'))\n\tcmdmsg_rl = TRUE;\n    else\n\tcmdmsg_rl = FALSE;\n#endif\n\n    redir_off = TRUE;\t\t// don't redirect the typed command\n    if (!cmd_silent)\n    {\n\ti = msg_scrolled;\n\tmsg_scrolled = 0;\t\t// avoid wait_return message\n\tgotocmdline(TRUE);\n\tmsg_scrolled += i;\n\tredrawcmdprompt();\t\t// draw prompt or indent\n\tset_cmdspos();\n    }\n    xpc.xp_context = EXPAND_NOTHING;\n    xpc.xp_backslash = XP_BS_NONE;\n#ifndef BACKSLASH_IN_FILENAME\n    xpc.xp_shell = FALSE;\n#endif\n\n#if defined(FEAT_EVAL)\n    if (ccline.input_fn)\n    {\n\txpc.xp_context = ccline.xp_context;\n\txpc.xp_pattern = ccline.cmdbuff;\n\txpc.xp_arg = ccline.xp_arg;\n    }\n#endif\n\n    /*\n     * Avoid scrolling when called by a recursive do_cmdline(), e.g. when\n     * doing \":@0\" when register 0 doesn't contain a CR.\n     */\n    msg_scroll = FALSE;\n\n    State = MODE_CMDLINE;\n\n    if (firstc == '/' || firstc == '?' || firstc == '@')\n    {\n\t// Use \":lmap\" mappings for search pattern and input().\n\tif (curbuf->b_p_imsearch == B_IMODE_USE_INSERT)\n\t    b_im_ptr = &curbuf->b_p_iminsert;\n\telse\n\t    b_im_ptr = &curbuf->b_p_imsearch;\n\tif (*b_im_ptr == B_IMODE_LMAP)\n\t    State |= MODE_LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n\tim_set_active(*b_im_ptr == B_IMODE_IM);\n#endif\n    }\n#ifdef HAVE_INPUT_METHOD\n    else if (p_imcmdline)\n\tim_set_active(TRUE);\n#endif\n\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n\n    // When inside an autocommand for writing \"exiting\" may be set and\n    // terminal mode set to cooked.  Need to set raw mode here then.\n    settmode(TMODE_RAW);\n\n    // Trigger CmdlineEnter autocommands.\n    cmdline_type = firstc == NUL ? '-' : firstc;\n    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINEENTER);\n#ifdef FEAT_EVAL\n    if (!debug_mode)\n\tmay_trigger_modechanged();\n#endif\n\n    init_history();\n    hiscnt = get_hislen();\t// set hiscnt to impossible history value\n    histype = hist_char2type(firstc);\n\n#ifdef FEAT_DIGRAPHS\n    do_digraph(-1);\t\t// init digraph typeahead\n#endif\n\n    // If something above caused an error, reset the flags, we do want to type\n    // and execute commands. Display may be messed up a bit.\n    if (did_emsg)\n\tredrawcmd();\n\n#ifdef FEAT_STL_OPT\n    // Redraw the statusline in case it uses the current mode using the mode()\n    // function.\n    if (!cmd_silent && msg_scrolled == 0)\n    {\n\tint\tfound_one = FALSE;\n\twin_T\t*wp;\n\n\tFOR_ALL_WINDOWS(wp)\n\t    if (*p_stl != NUL || *wp->w_p_stl != NUL)\n\t    {\n\t\twp->w_redr_status = TRUE;\n\t\tfound_one = TRUE;\n\t    }\n\tif (found_one)\n\t    redraw_statuslines();\n    }\n#endif\n\n    did_emsg = FALSE;\n    got_int = FALSE;\n\n    /*\n     * Collect the command string, handling editing keys.\n     */\n    for (;;)\n    {\n\tint trigger_cmdlinechanged = TRUE;\n\tint end_wildmenu;\n\n\tredir_off = TRUE;\t// Don't redirect the typed command.\n\t\t\t\t// Repeated, because a \":redir\" inside\n\t\t\t\t// completion may switch it on.\n#ifdef USE_ON_FLY_SCROLL\n\tdont_scroll = FALSE;\t// allow scrolling here\n#endif\n\tquit_more = FALSE;\t// reset after CTRL-D which had a more-prompt\n\n\tdid_emsg = FALSE;\t// There can't really be a reason why an error\n\t\t\t\t// that occurs while typing a command should\n\t\t\t\t// cause the command not to be executed.\n\n\t// Trigger SafeState if nothing is pending.\n\tmay_trigger_safestate(xpc.xp_numfiles <= 0);\n\n\t// Get a character.  Ignore K_IGNORE and K_NOP, they should not do\n\t// anything, such as stop completion.\n\tdo\n\t{\n\t    cursorcmd();\t\t// set the cursor on the right spot\n\t    c = safe_vgetc();\n\t} while (c == K_IGNORE || c == K_NOP);\n\n\tif (c == K_COMMAND || c == K_SCRIPT_COMMAND)\n\t{\n\t    int\t    clen = ccline.cmdlen;\n\n\t    if (do_cmdkey_command(c, DOCMD_NOWAIT) == OK)\n\t    {\n\t\tif (clen == ccline.cmdlen)\n\t\t    trigger_cmdlinechanged = FALSE;\n\t\tgoto cmdline_changed;\n\t    }\n\t}\n\n\tif (KeyTyped)\n\t{\n\t    some_key_typed = TRUE;\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmd_hkmap)\n\t\tc = hkmap(c);\n\t    if (cmdmsg_rl && !KeyStuffed)\n\t    {\n\t\t// Invert horizontal movements and operations.  Only when\n\t\t// typed by the user directly, not when the result of a\n\t\t// mapping.\n\t\tswitch (c)\n\t\t{\n\t\t    case K_RIGHT:   c = K_LEFT; break;\n\t\t    case K_S_RIGHT: c = K_S_LEFT; break;\n\t\t    case K_C_RIGHT: c = K_C_LEFT; break;\n\t\t    case K_LEFT:    c = K_RIGHT; break;\n\t\t    case K_S_LEFT:  c = K_S_RIGHT; break;\n\t\t    case K_C_LEFT:  c = K_C_RIGHT; break;\n\t\t}\n\t    }\n#endif\n\t}\n\n\t/*\n\t * Ignore got_int when CTRL-C was typed here.\n\t * Don't ignore it in :global, we really need to break then, e.g., for\n\t * \":g/pat/normal /pat\" (without the <CR>).\n\t * Don't ignore it for the input() function.\n\t */\n\tif ((c == Ctrl_C\n#ifdef UNIX\n\t\t|| c == intr_char\n#endif\n\t\t\t\t)\n#if defined(FEAT_EVAL) || defined(FEAT_CRYPT)\n\t\t&& firstc != '@'\n#endif\n#ifdef FEAT_EVAL\n\t\t&& !break_ctrl_c\n#endif\n\t\t&& !global_busy)\n\t    got_int = FALSE;\n\n\t// free old command line when finished moving around in the history\n\t// list\n\tif (lookfor != NULL\n\t\t&& c != K_S_DOWN && c != K_S_UP\n\t\t&& c != K_DOWN && c != K_UP\n\t\t&& c != K_PAGEDOWN && c != K_PAGEUP\n\t\t&& c != K_KPAGEDOWN && c != K_KPAGEUP\n\t\t&& c != K_LEFT && c != K_RIGHT\n\t\t&& (xpc.xp_numfiles > 0 || (c != Ctrl_P && c != Ctrl_N)))\n\t    VIM_CLEAR(lookfor);\n\n\t/*\n\t * When there are matching completions to select <S-Tab> works like\n\t * CTRL-P (unless 'wc' is <S-Tab>).\n\t */\n\tif (c != p_wc && c == K_S_TAB && xpc.xp_numfiles > 0)\n\t    c = Ctrl_P;\n\n#ifdef FEAT_WILDMENU\n\tif (p_wmnu)\n\t    c = wildmenu_translate_key(&ccline, c, &xpc, did_wild_list);\n\n\tif (cmdline_pum_active())\n\t{\n\t    // Ctrl-Y: Accept the current selection and close the popup menu.\n\t    // Ctrl-E: cancel the cmdline popup menu and return the original\n\t    // text.\n\t    if (c == Ctrl_E || c == Ctrl_Y)\n\t    {\n\t\twild_type = (c == Ctrl_E) ? WILD_CANCEL : WILD_APPLY;\n\t\tif (nextwild(&xpc, wild_type, WILD_NO_BEEP,\n\t\t\t\t\t\t\tfirstc != '@') == FAIL)\n\t\t    break;\n\t\tc = Ctrl_E;\n\t    }\n\t}\n#endif\n\n\t// The wildmenu is cleared if the pressed key is not used for\n\t// navigating the wild menu (i.e. the key is not 'wildchar' or\n\t// 'wildcharm' or Ctrl-N or Ctrl-P or Ctrl-A or Ctrl-L).\n\t// If the popup menu is displayed, then PageDown and PageUp keys are\n\t// also used to navigate the menu.\n\tend_wildmenu = (!(c == p_wc && KeyTyped) && c != p_wcm\n\t\t&& c != Ctrl_N && c != Ctrl_P && c != Ctrl_A && c != Ctrl_L);\n#ifdef FEAT_WILDMENU\n\tend_wildmenu = end_wildmenu && (!cmdline_pum_active() ||\n\t\t\t    (c != K_PAGEDOWN && c != K_PAGEUP\n\t\t\t     && c != K_KPAGEDOWN && c != K_KPAGEUP));\n#endif\n\n\t// free expanded names when finished walking through matches\n\tif (end_wildmenu)\n\t{\n#ifdef FEAT_WILDMENU\n\t    if (cmdline_pum_active())\n\t\tcmdline_pum_remove();\n#endif\n\t    if (xpc.xp_numfiles != -1)\n\t\t(void)ExpandOne(&xpc, NULL, NULL, 0, WILD_FREE);\n\t    did_wild_list = FALSE;\n#ifdef FEAT_WILDMENU\n\t    if (!p_wmnu || (c != K_UP && c != K_DOWN))\n#endif\n\t\txpc.xp_context = EXPAND_NOTHING;\n\t    wim_index = 0;\n#ifdef FEAT_WILDMENU\n\t    wildmenu_cleanup(&ccline);\n#endif\n\t}\n\n#ifdef FEAT_WILDMENU\n\tif (p_wmnu)\n\t    c = wildmenu_process_key(&ccline, c, &xpc);\n#endif\n\n\t// CTRL-\\ CTRL-N goes to Normal mode, CTRL-\\ CTRL-G goes to Insert\n\t// mode when 'insertmode' is set, CTRL-\\ e prompts for an expression.\n\tif (c == Ctrl_BSL)\n\t{\n\t    res = cmdline_handle_backslash_key(c, &gotesc);\n\t    if (res == CMDLINE_CHANGED)\n\t\tgoto cmdline_changed;\n\t    else if (res == CMDLINE_NOT_CHANGED)\n\t\tgoto cmdline_not_changed;\n\t    else if (res == GOTO_NORMAL_MODE)\n\t\tgoto returncmd;\t\t// back to cmd mode\n\t    c = Ctrl_BSL;\t\t// backslash key not processed by\n\t\t\t\t\t// cmdline_handle_backslash_key()\n\t}\n\n#ifdef FEAT_CMDWIN\n\tif (c == cedit_key || c == K_CMDWIN)\n\t{\n\t    // TODO: why is ex_normal_busy checked here?\n\t    if ((c == K_CMDWIN || ex_normal_busy == 0) && got_int == FALSE)\n\t    {\n\t\t/*\n\t\t * Open a window to edit the command line (and history).\n\t\t */\n\t\tc = open_cmdwin();\n\t\tsome_key_typed = TRUE;\n\t    }\n\t}\n# ifdef FEAT_DIGRAPHS\n\telse\n# endif\n#endif\n#ifdef FEAT_DIGRAPHS\n\t    c = do_digraph(c);\n#endif\n\n\tif (c == '\\n' || c == '\\r' || c == K_KENTER || (c == ESC\n\t\t\t&& (!KeyTyped || vim_strchr(p_cpo, CPO_ESC) != NULL)))\n\t{\n\t    // In Ex mode a backslash escapes a newline.\n\t    if (exmode_active\n\t\t    && c != ESC\n\t\t    && ccline.cmdpos == ccline.cmdlen\n\t\t    && ccline.cmdpos > 0\n\t\t    && ccline.cmdbuff[ccline.cmdpos - 1] == '\\\\')\n\t    {\n\t\tif (c == K_KENTER)\n\t\t    c = '\\n';\n\t    }\n\t    else\n\t    {\n\t\tgotesc = FALSE;\t// Might have typed ESC previously, don't\n\t\t\t\t// truncate the cmdline now.\n\t\tif (ccheck_abbr(c + ABBR_OFF))\n\t\t    goto cmdline_changed;\n\t\tif (!cmd_silent)\n\t\t{\n\t\t    windgoto(msg_row, 0);\n\t\t    out_flush();\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n\n\t// Completion for 'wildchar' or 'wildcharm' key.\n\tif ((c == p_wc && !gotesc && KeyTyped) || c == p_wcm)\n\t{\n\t    res = cmdline_wildchar_complete(c, firstc != '@', &did_wild_list,\n\t\t    &wim_index, &xpc, &gotesc);\n\t    if (res == CMDLINE_CHANGED)\n\t\tgoto cmdline_changed;\n\t}\n\n\tgotesc = FALSE;\n\n\t// <S-Tab> goes to last match, in a clumsy way\n\tif (c == K_S_TAB && KeyTyped)\n\t{\n\t    if (nextwild(&xpc, WILD_EXPAND_KEEP, 0, firstc != '@') == OK)\n\t    {\n\t\tif (xpc.xp_numfiles > 1)\n\t\t{\n#ifdef FEAT_WILDMENU\n\t\t    // Trigger the popup menu when wildoptions=pum\n\t\t    showmatches(&xpc, p_wmnu\n\t\t\t    && ((wim_flags[wim_index] & WIM_LIST) == 0));\n#else\n\t\t    (void)showmatches(&xpc, FALSE);\n#endif\n\t\t}\n\t\tif (nextwild(&xpc, WILD_PREV, 0, firstc != '@') == OK\n\t\t\t&& nextwild(&xpc, WILD_PREV, 0, firstc != '@') == OK)\n\t\t    goto cmdline_changed;\n\t    }\n\t}\n\n\tif (c == NUL || c == K_ZERO)\t    // NUL is stored as NL\n\t    c = NL;\n\n\tdo_abbr = TRUE;\t\t// default: check for abbreviation\n\n\t/*\n\t * Big switch for a typed command line character.\n\t */\n\tswitch (c)\n\t{\n\tcase K_BS:\n\tcase Ctrl_H:\n\tcase K_DEL:\n\tcase K_KDEL:\n\tcase Ctrl_W:\n\t    res = cmdline_erase_chars(c, indent\n#ifdef FEAT_SEARCH_EXTRA\n\t\t    , &is_state\n#endif\n\t\t    );\n\t    if (res == CMDLINE_NOT_CHANGED)\n\t\tgoto cmdline_not_changed;\n\t    else if (res == GOTO_NORMAL_MODE)\n\t\tgoto returncmd;\t\t// back to cmd mode\n\t    goto cmdline_changed;\n\n\tcase K_INS:\n\tcase K_KINS:\n\t\tccline.overstrike = !ccline.overstrike;\n#ifdef CURSOR_SHAPE\n\t\tui_cursor_shape();\t// may show different cursor shape\n#endif\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_HAT:\n\t\tcmdline_toggle_langmap(b_im_ptr);\n\t\tgoto cmdline_not_changed;\n\n//\tcase '@':   only in very old vi\n\tcase Ctrl_U:\n\t\t// delete all characters left of the cursor\n\t\tj = ccline.cmdpos;\n\t\tccline.cmdlen -= j;\n\t\ti = ccline.cmdpos = 0;\n\t\twhile (i < ccline.cmdlen)\n\t\t    ccline.cmdbuff[i++] = ccline.cmdbuff[j++];\n\t\t// Truncate at the end, required for multi-byte chars.\n\t\tccline.cmdbuff[ccline.cmdlen] = NUL;\n#ifdef FEAT_SEARCH_EXTRA\n\t\tif (ccline.cmdlen == 0)\n\t\t    is_state.search_start = is_state.save_cursor;\n#endif\n\t\tredrawcmd();\n\t\tgoto cmdline_changed;\n\n#ifdef FEAT_CLIPBOARD\n\tcase Ctrl_Y:\n\t\t// Copy the modeless selection, if there is one.\n\t\tif (clip_star.state != SELECT_CLEARED)\n\t\t{\n\t\t    if (clip_star.state == SELECT_DONE)\n\t\t\tclip_copy_modeless_selection(TRUE);\n\t\t    goto cmdline_not_changed;\n\t\t}\n\t\tbreak;\n#endif\n\n\tcase ESC:\t// get here if p_wc != ESC or when ESC typed twice\n\tcase Ctrl_C:\n\t\t// In exmode it doesn't make sense to return.  Except when\n\t\t// \":normal\" runs out of characters.\n\t\tif (exmode_active\n\t\t\t       && (ex_normal_busy == 0 || typebuf.tb_len > 0))\n\t\t    goto cmdline_not_changed;\n\n\t\tgotesc = TRUE;\t\t// will free ccline.cmdbuff after\n\t\t\t\t\t// putting it in history\n\t\tgoto returncmd;\t\t// back to cmd mode\n\n\tcase Ctrl_R:\t\t\t// insert register\n\t\tres = cmdline_insert_reg(&gotesc);\n\t\tif (res == CMDLINE_NOT_CHANGED)\n\t\t    goto cmdline_not_changed;\n\t\telse if (res == GOTO_NORMAL_MODE)\n\t\t    goto returncmd;\n\t\tgoto cmdline_changed;\n\n\tcase Ctrl_D:\n\t\tif (showmatches(&xpc, FALSE) == EXPAND_NOTHING)\n\t\t    break;\t// Use ^D as normal char instead\n\n\t\tredrawcmd();\n\t\tcontinue;\t// don't do incremental search now\n\n\tcase K_RIGHT:\n\tcase K_S_RIGHT:\n\tcase K_C_RIGHT:\n\t\tdo\n\t\t{\n\t\t    if (ccline.cmdpos >= ccline.cmdlen)\n\t\t\tbreak;\n\t\t    i = cmdline_charsize(ccline.cmdpos);\n\t\t    if (KeyTyped && ccline.cmdspos + i >= Columns * Rows)\n\t\t\tbreak;\n\t\t    ccline.cmdspos += i;\n\t\t    if (has_mbyte)\n\t\t\tccline.cmdpos += (*mb_ptr2len)(ccline.cmdbuff\n\t\t\t\t\t\t\t     + ccline.cmdpos);\n\t\t    else\n\t\t\t++ccline.cmdpos;\n\t\t}\n\t\twhile ((c == K_S_RIGHT || c == K_C_RIGHT\n\t\t\t       || (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL)))\n\t\t\t&& ccline.cmdbuff[ccline.cmdpos] != ' ');\n\t\tif (has_mbyte)\n\t\t    set_cmdspos_cursor();\n\t\tgoto cmdline_not_changed;\n\n\tcase K_LEFT:\n\tcase K_S_LEFT:\n\tcase K_C_LEFT:\n\t\tif (ccline.cmdpos == 0)\n\t\t    goto cmdline_not_changed;\n\t\tdo\n\t\t{\n\t\t    --ccline.cmdpos;\n\t\t    if (has_mbyte)\t// move to first byte of char\n\t\t\tccline.cmdpos -= (*mb_head_off)(ccline.cmdbuff,\n\t\t\t\t\t      ccline.cmdbuff + ccline.cmdpos);\n\t\t    ccline.cmdspos -= cmdline_charsize(ccline.cmdpos);\n\t\t}\n\t\twhile (ccline.cmdpos > 0\n\t\t\t&& (c == K_S_LEFT || c == K_C_LEFT\n\t\t\t       || (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL)))\n\t\t\t&& ccline.cmdbuff[ccline.cmdpos - 1] != ' ');\n\t\tif (has_mbyte)\n\t\t    set_cmdspos_cursor();\n\t\tgoto cmdline_not_changed;\n\n\tcase K_IGNORE:\n\t\t// Ignore mouse event or open_cmdwin() result.\n\t\tgoto cmdline_not_changed;\n\n#ifdef FEAT_GUI_MSWIN\n\t    // On MS-Windows ignore <M-F4>, we get it when closing the window\n\t    // was cancelled.\n\tcase K_F4:\n\t    if (mod_mask == MOD_MASK_ALT)\n\t    {\n\t\tredrawcmd();\t    // somehow the cmdline is cleared\n\t\tgoto cmdline_not_changed;\n\t    }\n\t    break;\n#endif\n\n\tcase K_MIDDLEDRAG:\n\tcase K_MIDDLERELEASE:\n\t\tgoto cmdline_not_changed;\t// Ignore mouse\n\n\tcase K_MIDDLEMOUSE:\n# ifdef FEAT_GUI\n\t\t// When GUI is active, also paste when 'mouse' is empty\n\t\tif (!gui.in_use)\n# endif\n\t\t    if (!mouse_has(MOUSE_COMMAND))\n\t\t\tgoto cmdline_not_changed;   // Ignore mouse\n# ifdef FEAT_CLIPBOARD\n\t\tif (clip_star.available)\n\t\t    cmdline_paste('*', TRUE, TRUE);\n\t\telse\n# endif\n\t\t    cmdline_paste(0, TRUE, TRUE);\n\t\tredrawcmd();\n\t\tgoto cmdline_changed;\n\n# ifdef FEAT_DND\n\tcase K_DROP:\n\t\tcmdline_paste('~', TRUE, FALSE);\n\t\tredrawcmd();\n\t\tgoto cmdline_changed;\n# endif\n\n\tcase K_LEFTDRAG:\n\tcase K_LEFTRELEASE:\n\tcase K_RIGHTDRAG:\n\tcase K_RIGHTRELEASE:\n\t\t// Ignore drag and release events when the button-down wasn't\n\t\t// seen before.\n\t\tif (ignore_drag_release)\n\t\t    goto cmdline_not_changed;\n\t\t// FALLTHROUGH\n\tcase K_LEFTMOUSE:\n\tcase K_RIGHTMOUSE:\n\t\tcmdline_left_right_mouse(c, &ignore_drag_release);\n\t\tgoto cmdline_not_changed;\n\n\t// Mouse scroll wheel: ignored here\n\tcase K_MOUSEDOWN:\n\tcase K_MOUSEUP:\n\tcase K_MOUSELEFT:\n\tcase K_MOUSERIGHT:\n\t// Alternate buttons ignored here\n\tcase K_X1MOUSE:\n\tcase K_X1DRAG:\n\tcase K_X1RELEASE:\n\tcase K_X2MOUSE:\n\tcase K_X2DRAG:\n\tcase K_X2RELEASE:\n\tcase K_MOUSEMOVE:\n\t\tgoto cmdline_not_changed;\n\n#ifdef FEAT_GUI\n\tcase K_LEFTMOUSE_NM:\t// mousefocus click, ignored\n\tcase K_LEFTRELEASE_NM:\n\t\tgoto cmdline_not_changed;\n\n\tcase K_VER_SCROLLBAR:\n\t\tif (msg_scrolled == 0)\n\t\t{\n\t\t    gui_do_scroll();\n\t\t    redrawcmd();\n\t\t}\n\t\tgoto cmdline_not_changed;\n\n\tcase K_HOR_SCROLLBAR:\n\t\tif (msg_scrolled == 0)\n\t\t{\n\t\t    gui_do_horiz_scroll(scrollbar_value, FALSE);\n\t\t    redrawcmd();\n\t\t}\n\t\tgoto cmdline_not_changed;\n#endif\n#ifdef FEAT_GUI_TABLINE\n\tcase K_TABLINE:\n\tcase K_TABMENU:\n\t\t// Don't want to change any tabs here.  Make sure the same tab\n\t\t// is still selected.\n\t\tif (gui_use_tabline())\n\t\t    gui_mch_set_curtab(tabpage_index(curtab));\n\t\tgoto cmdline_not_changed;\n#endif\n\n\tcase K_SELECT:\t    // end of Select mode mapping - ignore\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_B:\t    // begin of command line\n\tcase K_HOME:\n\tcase K_KHOME:\n\tcase K_S_HOME:\n\tcase K_C_HOME:\n\t\tccline.cmdpos = 0;\n\t\tset_cmdspos();\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_E:\t    // end of command line\n\tcase K_END:\n\tcase K_KEND:\n\tcase K_S_END:\n\tcase K_C_END:\n\t\tccline.cmdpos = ccline.cmdlen;\n\t\tset_cmdspos_cursor();\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_A:\t    // all matches\n#ifdef FEAT_WILDMENU\n\t\tif (cmdline_pum_active())\n\t\t    // As Ctrl-A completes all the matches, close the popup\n\t\t    // menu (if present)\n\t\t    cmdline_pum_cleanup(&ccline);\n#endif\n\t\tif (nextwild(&xpc, WILD_ALL, 0, firstc != '@') == FAIL)\n\t\t    break;\n\t\txpc.xp_context = EXPAND_NOTHING;\n\t\tdid_wild_list = FALSE;\n\t\tgoto cmdline_changed;\n\n\tcase Ctrl_L:\n#ifdef FEAT_SEARCH_EXTRA\n\t\tif (may_add_char_to_search(firstc, &c, &is_state) == OK)\n\t\t    goto cmdline_not_changed;\n#endif\n\n\t\t// completion: longest common part\n\t\tif (nextwild(&xpc, WILD_LONGEST, 0, firstc != '@') == FAIL)\n\t\t    break;\n\t\tgoto cmdline_changed;\n\n\tcase Ctrl_N:\t    // next match\n\tcase Ctrl_P:\t    // previous match\n\t\tif (xpc.xp_numfiles > 0)\n\t\t{\n\t\t    wild_type = (c == Ctrl_P) ? WILD_PREV : WILD_NEXT;\n\t\t    if (nextwild(&xpc, wild_type, 0, firstc != '@') == FAIL)\n\t\t\tbreak;\n\t\t    goto cmdline_not_changed;\n\t\t}\n\t\t// FALLTHROUGH\n\tcase K_UP:\n\tcase K_DOWN:\n\tcase K_S_UP:\n\tcase K_S_DOWN:\n\tcase K_PAGEUP:\n\tcase K_KPAGEUP:\n\tcase K_PAGEDOWN:\n\tcase K_KPAGEDOWN:\n#ifdef FEAT_WILDMENU\n\t\tif (cmdline_pum_active()\n\t\t\t&& (c == K_PAGEUP || c == K_PAGEDOWN ||\n\t\t\t    c == K_KPAGEUP || c == K_KPAGEDOWN))\n\t\t{\n\t\t    // If the popup menu is displayed, then PageUp and PageDown\n\t\t    // are used to scroll the menu.\n\t\t    wild_type = WILD_PAGEUP;\n\t\t    if (c == K_PAGEDOWN || c == K_KPAGEDOWN)\n\t\t\twild_type = WILD_PAGEDOWN;\n\t\t    if (nextwild(&xpc, wild_type, 0, firstc != '@') == FAIL)\n\t\t\tbreak;\n\t\t    goto cmdline_not_changed;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    res = cmdline_browse_history(c, firstc, &lookfor, histype,\n\t\t\t    &hiscnt, &xpc);\n\t\t    if (res == CMDLINE_CHANGED)\n\t\t\tgoto cmdline_changed;\n\t\t    else if (res == GOTO_NORMAL_MODE)\n\t\t\tgoto returncmd;\n\t\t}\n\t\tgoto cmdline_not_changed;\n\n#ifdef FEAT_SEARCH_EXTRA\n\tcase Ctrl_G:\t    // next match\n\tcase Ctrl_T:\t    // previous match\n\t\tif (may_adjust_incsearch_highlighting(\n\t\t\t\t\t  firstc, count, &is_state, c) == FAIL)\n\t\t    goto cmdline_not_changed;\n\t\tbreak;\n#endif\n\n\tcase Ctrl_V:\n\tcase Ctrl_Q:\n\t\t{\n\t\t    ignore_drag_release = TRUE;\n\t\t    putcmdline('^', TRUE);\n\n\t\t    // Get next (two) character(s).  Do not change any\n\t\t    // modifyOtherKeys ESC sequence to a normal key for\n\t\t    // CTRL-SHIFT-V.\n\t\t    c = get_literal(mod_mask & MOD_MASK_SHIFT);\n\n\t\t    do_abbr = FALSE;\t    // don't do abbreviation now\n\t\t    extra_char = NUL;\n\t\t    // may need to remove ^ when composing char was typed\n\t\t    if (enc_utf8 && utf_iscomposing(c) && !cmd_silent)\n\t\t    {\n\t\t\tdraw_cmdline(ccline.cmdpos,\n\t\t\t\t\t\tccline.cmdlen - ccline.cmdpos);\n\t\t\tmsg_putchar(' ');\n\t\t\tcursorcmd();\n\t\t    }\n\t\t}\n\n\t\tbreak;\n\n#ifdef FEAT_DIGRAPHS\n\tcase Ctrl_K:\n\t\tignore_drag_release = TRUE;\n\t\tputcmdline('?', TRUE);\n# ifdef USE_ON_FLY_SCROLL\n\t\tdont_scroll = TRUE;\t    // disallow scrolling here\n# endif\n\t\tc = get_digraph(TRUE);\n\t\textra_char = NUL;\n\t\tif (c != NUL)\n\t\t    break;\n\n\t\tredrawcmd();\n\t\tgoto cmdline_not_changed;\n#endif // FEAT_DIGRAPHS\n\n#ifdef FEAT_RIGHTLEFT\n\tcase Ctrl__:\t    // CTRL-_: switch language mode\n\t\tif (!p_ari)\n\t\t    break;\n\t\tcmd_hkmap = !cmd_hkmap;\n\t\tgoto cmdline_not_changed;\n#endif\n\n\tcase K_PS:\n\t\tbracketed_paste(PASTE_CMDLINE, FALSE, NULL);\n\t\tgoto cmdline_changed;\n\n\tdefault:\n#ifdef UNIX\n\t\tif (c == intr_char)\n\t\t{\n\t\t    gotesc = TRUE;\t// will free ccline.cmdbuff after\n\t\t\t\t\t// putting it in history\n\t\t    goto returncmd;\t// back to Normal mode\n\t\t}\n#endif\n\t\t/*\n\t\t * Normal character with no special meaning.  Just set mod_mask\n\t\t * to 0x0 so that typing Shift-Space in the GUI doesn't enter\n\t\t * the string <S-Space>.  This should only happen after ^V.\n\t\t */\n\t\tif (!IS_SPECIAL(c))\n\t\t    mod_mask = 0x0;\n\t\tbreak;\n\t}\n\t/*\n\t * End of switch on command line character.\n\t * We come here if we have a normal character.\n\t */\n\n\tif (do_abbr && (IS_SPECIAL(c) || !vim_iswordc(c))\n\t\t&& (ccheck_abbr(\n\t\t\t// Add ABBR_OFF for characters above 0x100, this is\n\t\t\t// what check_abbr() expects.\n\t\t\t\t(has_mbyte && c >= 0x100) ? (c + ABBR_OFF) : c)\n\t\t    || c == Ctrl_RSB))\n\t    goto cmdline_changed;\n\n\t/*\n\t * put the character in the command line\n\t */\n\tif (IS_SPECIAL(c) || mod_mask != 0)\n\t    put_on_cmdline(get_special_key_name(c, mod_mask), -1, TRUE);\n\telse\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tj = (*mb_char2bytes)(c, IObuff);\n\t\tIObuff[j] = NUL;\t// exclude composing chars\n\t\tput_on_cmdline(IObuff, j, TRUE);\n\t    }\n\t    else\n\t    {\n\t\tIObuff[0] = c;\n\t\tput_on_cmdline(IObuff, 1, TRUE);\n\t    }\n\t}\n\tgoto cmdline_changed;\n\n/*\n * This part implements incremental searches for \"/\" and \"?\"\n * Jump to cmdline_not_changed when a character has been read but the command\n * line did not change. Then we only search and redraw if something changed in\n * the past.\n * Jump to cmdline_changed when the command line did change.\n * (Sorry for the goto's, I know it is ugly).\n */\ncmdline_not_changed:\n#ifdef FEAT_SEARCH_EXTRA\n\tif (!is_state.incsearch_postponed)\n\t    continue;\n#endif\n\ncmdline_changed:\n#ifdef FEAT_SEARCH_EXTRA\n\t// If the window changed incremental search state is not valid.\n\tif (is_state.winid != curwin->w_id)\n\t    init_incsearch_state(&is_state);\n#endif\n\tif (trigger_cmdlinechanged)\n\t    // Trigger CmdlineChanged autocommands.\n\t    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINECHANGED);\n\n#ifdef FEAT_SEARCH_EXTRA\n\tif (xpc.xp_context == EXPAND_NOTHING && (KeyTyped || vpeekc() == NUL))\n\t    may_do_incsearch_highlighting(firstc, count, &is_state);\n#endif\n\n#ifdef FEAT_RIGHTLEFT\n\tif (cmdmsg_rl\n# ifdef FEAT_ARABIC\n\t\t|| (p_arshape && !p_tbidi\n\t\t\t\t       && cmdline_has_arabic(0, ccline.cmdlen))\n# endif\n\t\t)\n\t    // Always redraw the whole command line to fix shaping and\n\t    // right-left typing.  Not efficient, but it works.\n\t    // Do it only when there are no characters left to read\n\t    // to avoid useless intermediate redraws.\n\t    if (vpeekc() == NUL)\n\t\tredrawcmd();\n#endif\n    }\n\nreturncmd:\n\n#ifdef FEAT_RIGHTLEFT\n    cmdmsg_rl = FALSE;\n#endif\n\n    ExpandCleanup(&xpc);\n    ccline.xpc = NULL;\n\n#ifdef FEAT_SEARCH_EXTRA\n    finish_incsearch_highlighting(gotesc, &is_state, FALSE);\n#endif\n\n    if (ccline.cmdbuff != NULL)\n    {\n\t/*\n\t * Put line in history buffer (\":\" and \"=\" only when it was typed).\n\t */\n\tif (ccline.cmdlen && firstc != NUL\n\t\t&& (some_key_typed || histype == HIST_SEARCH))\n\t{\n\t    add_to_history(histype, ccline.cmdbuff, TRUE,\n\t\t\t\t       histype == HIST_SEARCH ? firstc : NUL);\n\t    if (firstc == ':')\n\t    {\n\t\tvim_free(new_last_cmdline);\n\t\tnew_last_cmdline = vim_strsave(ccline.cmdbuff);\n\t    }\n\t}\n\n\tif (gotesc)\n\t    abandon_cmdline();\n    }\n\n    /*\n     * If the screen was shifted up, redraw the whole screen (later).\n     * If the line is too long, clear it, so ruler and shown command do\n     * not get printed in the middle of it.\n     */\n    msg_check();\n    msg_scroll = save_msg_scroll;\n    redir_off = FALSE;\n\n    // When the command line was typed, no need for a wait-return prompt.\n    if (some_key_typed)\n\tneed_wait_return = FALSE;\n\n    // Trigger CmdlineLeave autocommands.\n    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINELEAVE);\n\n    State = save_State;\n\n#ifdef FEAT_EVAL\n    if (!debug_mode)\n\tmay_trigger_modechanged();\n#endif\n\n#ifdef HAVE_INPUT_METHOD\n    if (b_im_ptr != NULL && *b_im_ptr != B_IMODE_LMAP)\n\tim_save_status(b_im_ptr);\n    im_set_active(FALSE);\n#endif\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n    sb_text_end_cmdline();\n\ntheend:\n    {\n\tchar_u *p = ccline.cmdbuff;\n\n\t--depth;\n\tif (did_save_ccline)\n\t    restore_cmdline(&save_ccline);\n\telse\n\t    ccline.cmdbuff = NULL;\n\treturn p;\n    }\n}\n\n#if (defined(FEAT_CRYPT) || defined(FEAT_EVAL)) || defined(PROTO)\n/*\n * Get a command line with a prompt.\n * This is prepared to be called recursively from getcmdline() (e.g. by\n * f_input() when evaluating an expression from CTRL-R =).\n * Returns the command line in allocated memory, or NULL.\n */\n    char_u *\ngetcmdline_prompt(\n    int\t\tfirstc,\n    char_u\t*prompt,\t// command line prompt\n    int\t\tattr,\t\t// attributes for prompt\n    int\t\txp_context,\t// type of expansion\n    char_u\t*xp_arg)\t// user-defined expansion argument\n{\n    char_u\t\t*s;\n    cmdline_info_T\tsave_ccline;\n    int\t\t\tdid_save_ccline = FALSE;\n    int\t\t\tmsg_col_save = msg_col;\n    int\t\t\tmsg_silent_save = msg_silent;\n\n    if (ccline.cmdbuff != NULL)\n    {\n\t// Save the values of the current cmdline and restore them below.\n\tsave_cmdline(&save_ccline);\n\tdid_save_ccline = TRUE;\n    }\n\n    CLEAR_FIELD(ccline);\n    ccline.cmdprompt = prompt;\n    ccline.cmdattr = attr;\n# ifdef FEAT_EVAL\n    ccline.xp_context = xp_context;\n    ccline.xp_arg = xp_arg;\n    ccline.input_fn = (firstc == '@');\n# endif\n    msg_silent = 0;\n    s = getcmdline_int(firstc, 1L, 0, FALSE);\n\n    if (did_save_ccline)\n\trestore_cmdline(&save_ccline);\n\n    msg_silent = msg_silent_save;\n    // Restore msg_col, the prompt from input() may have changed it.\n    // But only if called recursively and the commandline is therefore being\n    // restored to an old one; if not, the input() prompt stays on the screen,\n    // so we need its modified msg_col left intact.\n    if (ccline.cmdbuff != NULL)\n\tmsg_col = msg_col_save;\n\n    return s;\n}\n#endif\n\n/*\n * Read the 'wildmode' option, fill wim_flags[].\n */\n    int\ncheck_opt_wim(void)\n{\n    char_u\tnew_wim_flags[4];\n    char_u\t*p;\n    int\t\ti;\n    int\t\tidx = 0;\n\n    for (i = 0; i < 4; ++i)\n\tnew_wim_flags[i] = 0;\n\n    for (p = p_wim; *p; ++p)\n    {\n\tfor (i = 0; ASCII_ISALPHA(p[i]); ++i)\n\t    ;\n\tif (p[i] != NUL && p[i] != ',' && p[i] != ':')\n\t    return FAIL;\n\tif (i == 7 && STRNCMP(p, \"longest\", 7) == 0)\n\t    new_wim_flags[idx] |= WIM_LONGEST;\n\telse if (i == 4 && STRNCMP(p, \"full\", 4) == 0)\n\t    new_wim_flags[idx] |= WIM_FULL;\n\telse if (i == 4 && STRNCMP(p, \"list\", 4) == 0)\n\t    new_wim_flags[idx] |= WIM_LIST;\n\telse if (i == 8 && STRNCMP(p, \"lastused\", 8) == 0)\n\t    new_wim_flags[idx] |= WIM_BUFLASTUSED;\n\telse\n\t    return FAIL;\n\tp += i;\n\tif (*p == NUL)\n\t    break;\n\tif (*p == ',')\n\t{\n\t    if (idx == 3)\n\t\treturn FAIL;\n\t    ++idx;\n\t}\n    }\n\n    // fill remaining entries with last flag\n    while (idx < 3)\n    {\n\tnew_wim_flags[idx + 1] = new_wim_flags[idx];\n\t++idx;\n    }\n\n    // only when there are no errors, wim_flags[] is changed\n    for (i = 0; i < 4; ++i)\n\twim_flags[i] = new_wim_flags[i];\n    return OK;\n}\n\n/*\n * Return TRUE when the text must not be changed and we can't switch to\n * another window or buffer.  TRUE when editing the command line, evaluating\n * 'balloonexpr', etc.\n */\n    int\ntext_locked(void)\n{\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n\treturn TRUE;\n#endif\n    return textlock != 0;\n}\n\n/*\n * Give an error message for a command that isn't allowed while the cmdline\n * window is open or editing the cmdline in another way.\n */\n    void\ntext_locked_msg(void)\n{\n    emsg(_(get_text_locked_msg()));\n}\n\n    char *\nget_text_locked_msg(void)\n{\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n\treturn e_invalid_in_cmdline_window;\n#endif\n    return e_not_allowed_to_change_text_or_change_window;\n}\n\n/*\n * Check if \"curbuf_lock\" or \"allbuf_lock\" is set and return TRUE when it is\n * and give an error message.\n */\n    int\ncurbuf_locked(void)\n{\n    if (curbuf_lock > 0)\n    {\n\temsg(_(e_not_allowed_to_edit_another_buffer_now));\n\treturn TRUE;\n    }\n    return allbuf_locked();\n}\n\n/*\n * Check if \"allbuf_lock\" is set and return TRUE when it is and give an error\n * message.\n */\n    int\nallbuf_locked(void)\n{\n    if (allbuf_lock > 0)\n    {\n\temsg(_(e_not_allowed_to_change_buffer_information_now));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n    static int\ncmdline_charsize(int idx)\n{\n#if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\n    if (cmdline_star > 0)\t    // showing '*', always 1 position\n\treturn 1;\n#endif\n    return ptr2cells(ccline.cmdbuff + idx);\n}\n\n/*\n * Compute the offset of the cursor on the command line for the prompt and\n * indent.\n */\n    static void\nset_cmdspos(void)\n{\n    if (ccline.cmdfirstc != NUL)\n\tccline.cmdspos = 1 + ccline.cmdindent;\n    else\n\tccline.cmdspos = 0 + ccline.cmdindent;\n}\n\n/*\n * Compute the screen position for the cursor on the command line.\n */\n    static void\nset_cmdspos_cursor(void)\n{\n    int\t\ti, m, c;\n\n    set_cmdspos();\n    if (KeyTyped)\n    {\n\tm = Columns * Rows;\n\tif (m < 0)\t// overflow, Columns or Rows at weird value\n\t    m = MAXCOL;\n    }\n    else\n\tm = MAXCOL;\n    for (i = 0; i < ccline.cmdlen && i < ccline.cmdpos; ++i)\n    {\n\tc = cmdline_charsize(i);\n\t// Count \">\" for double-wide multi-byte char that doesn't fit.\n\tif (has_mbyte)\n\t    correct_cmdspos(i, c);\n\t// If the cmdline doesn't fit, show cursor on last visible char.\n\t// Don't move the cursor itself, so we can still append.\n\tif ((ccline.cmdspos += c) >= m)\n\t{\n\t    ccline.cmdspos -= c;\n\t    break;\n\t}\n\tif (has_mbyte)\n\t    i += (*mb_ptr2len)(ccline.cmdbuff + i) - 1;\n    }\n}\n\n/*\n * Check if the character at \"idx\", which is \"cells\" wide, is a multi-byte\n * character that doesn't fit, so that a \">\" must be displayed.\n */\n    static void\ncorrect_cmdspos(int idx, int cells)\n{\n    if ((*mb_ptr2len)(ccline.cmdbuff + idx) > 1\n\t\t&& (*mb_ptr2cells)(ccline.cmdbuff + idx) > 1\n\t\t&& ccline.cmdspos % Columns + cells > Columns)\n\tccline.cmdspos++;\n}\n\n/*\n * Get an Ex command line for the \":\" command.\n */\n    char_u *\ngetexline(\n    int\t\tc,\t\t// normally ':', NUL for \":append\"\n    void\t*cookie UNUSED,\n    int\t\tindent,\t\t// indent for inside conditionals\n    getline_opt_T options)\n{\n    // When executing a register, remove ':' that's in front of each line.\n    if (exec_from_reg && vpeekc() == ':')\n\t(void)vgetc();\n    return getcmdline(c, 1L, indent, options);\n}\n\n/*\n * Get an Ex command line for Ex mode.\n * In Ex mode we only use the OS supplied line editing features and no\n * mappings or abbreviations.\n * Returns a string in allocated memory or NULL.\n */\n    char_u *\ngetexmodeline(\n    int\t\tpromptc,\t// normally ':', NUL for \":append\" and '?' for\n\t\t\t\t// :s prompt\n    void\t*cookie UNUSED,\n    int\t\tindent,\t\t// indent for inside conditionals\n    getline_opt_T options UNUSED)\n{\n    garray_T\tline_ga;\n    char_u\t*pend;\n    int\t\tstartcol = 0;\n    int\t\tc1 = 0;\n    int\t\tescaped = FALSE;\t// CTRL-V typed\n    int\t\tvcol = 0;\n    char_u\t*p;\n    int\t\tprev_char;\n    int\t\tlen;\n\n    // Switch cursor on now.  This avoids that it happens after the \"\\n\", which\n    // confuses the system function that computes tabstops.\n    cursor_on();\n\n    // always start in column 0; write a newline if necessary\n    compute_cmdrow();\n    if ((msg_col || msg_didout) && promptc != '?')\n\tmsg_putchar('\\n');\n    if (promptc == ':')\n    {\n\t// indent that is only displayed, not in the line itself\n\tif (p_prompt)\n\t    msg_putchar(':');\n\twhile (indent-- > 0)\n\t    msg_putchar(' ');\n\tstartcol = msg_col;\n    }\n\n    ga_init2(&line_ga, 1, 30);\n\n    // autoindent for :insert and :append is in the line itself\n    if (promptc <= 0)\n    {\n\tvcol = indent;\n\twhile (indent >= 8)\n\t{\n\t    ga_append(&line_ga, TAB);\n\t    msg_puts(\"        \");\n\t    indent -= 8;\n\t}\n\twhile (indent-- > 0)\n\t{\n\t    ga_append(&line_ga, ' ');\n\t    msg_putchar(' ');\n\t}\n    }\n    ++no_mapping;\n    ++allow_keys;\n\n    /*\n     * Get the line, one character at a time.\n     */\n    got_int = FALSE;\n    while (!got_int)\n    {\n\tlong    sw;\n\tchar_u *s;\n\n\tif (ga_grow(&line_ga, 40) == FAIL)\n\t    break;\n\n\t/*\n\t * Get one character at a time.\n\t */\n\tprev_char = c1;\n\n\t// Check for a \":normal\" command and no more characters left.\n\tif (ex_normal_busy > 0 && typebuf.tb_len == 0)\n\t    c1 = '\\n';\n\telse\n\t    c1 = vgetc();\n\n\t/*\n\t * Handle line editing.\n\t * Previously this was left to the system, putting the terminal in\n\t * cooked mode, but then CTRL-D and CTRL-T can't be used properly.\n\t */\n\tif (got_int)\n\t{\n\t    msg_putchar('\\n');\n\t    break;\n\t}\n\n\tif (c1 == K_PS)\n\t{\n\t    bracketed_paste(PASTE_EX, FALSE, &line_ga);\n\t    goto redraw;\n\t}\n\n\tif (!escaped)\n\t{\n\t    // CR typed means \"enter\", which is NL\n\t    if (c1 == '\\r')\n\t\tc1 = '\\n';\n\n\t    if (c1 == BS || c1 == K_BS\n\t\t\t  || c1 == DEL || c1 == K_DEL || c1 == K_KDEL)\n\t    {\n\t\tif (line_ga.ga_len > 0)\n\t\t{\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\tp = (char_u *)line_ga.ga_data;\n\t\t\tp[line_ga.ga_len] = NUL;\n\t\t\tlen = (*mb_head_off)(p, p + line_ga.ga_len - 1) + 1;\n\t\t\tline_ga.ga_len -= len;\n\t\t    }\n\t\t    else\n\t\t\t--line_ga.ga_len;\n\t\t    goto redraw;\n\t\t}\n\t\tcontinue;\n\t    }\n\n\t    if (c1 == Ctrl_U)\n\t    {\n\t\tmsg_col = startcol;\n\t\tmsg_clr_eos();\n\t\tline_ga.ga_len = 0;\n\t\tgoto redraw;\n\t    }\n\n\t    if (c1 == Ctrl_T)\n\t    {\n\t\tsw = get_sw_value(curbuf);\n\t\tp = (char_u *)line_ga.ga_data;\n\t\tp[line_ga.ga_len] = NUL;\n\t\tindent = get_indent_str(p, 8, FALSE);\n\t\tindent += sw - indent % sw;\nadd_indent:\n\t\twhile (get_indent_str(p, 8, FALSE) < indent)\n\t\t{\n\t\t    (void)ga_grow(&line_ga, 2);  // one more for the NUL\n\t\t    p = (char_u *)line_ga.ga_data;\n\t\t    s = skipwhite(p);\n\t\t    mch_memmove(s + 1, s, line_ga.ga_len - (s - p) + 1);\n\t\t    *s = ' ';\n\t\t    ++line_ga.ga_len;\n\t\t}\nredraw:\n\t\t// redraw the line\n\t\tmsg_col = startcol;\n\t\tvcol = 0;\n\t\tp = (char_u *)line_ga.ga_data;\n\t\tp[line_ga.ga_len] = NUL;\n\t\twhile (p < (char_u *)line_ga.ga_data + line_ga.ga_len)\n\t\t{\n\t\t    if (*p == TAB)\n\t\t    {\n\t\t\tdo\n\t\t\t    msg_putchar(' ');\n\t\t\twhile (++vcol % 8);\n\t\t\t++p;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tlen = mb_ptr2len(p);\n\t\t\tmsg_outtrans_len(p, len);\n\t\t\tvcol += ptr2cells(p);\n\t\t\tp += len;\n\t\t    }\n\t\t}\n\t\tmsg_clr_eos();\n\t\twindgoto(msg_row, msg_col);\n\t\tcontinue;\n\t    }\n\n\t    if (c1 == Ctrl_D)\n\t    {\n\t\t// Delete one shiftwidth.\n\t\tp = (char_u *)line_ga.ga_data;\n\t\tif (prev_char == '0' || prev_char == '^')\n\t\t{\n\t\t    if (prev_char == '^')\n\t\t\tex_keep_indent = TRUE;\n\t\t    indent = 0;\n\t\t    p[--line_ga.ga_len] = NUL;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[line_ga.ga_len] = NUL;\n\t\t    indent = get_indent_str(p, 8, FALSE);\n\t\t    if (indent > 0)\n\t\t    {\n\t\t\t--indent;\n\t\t\tindent -= indent % get_sw_value(curbuf);\n\t\t    }\n\t\t}\n\t\twhile (get_indent_str(p, 8, FALSE) > indent)\n\t\t{\n\t\t    s = skipwhite(p);\n\t\t    mch_memmove(s - 1, s, line_ga.ga_len - (s - p) + 1);\n\t\t    --line_ga.ga_len;\n\t\t}\n\t\tgoto add_indent;\n\t    }\n\n\t    if (c1 == Ctrl_V || c1 == Ctrl_Q)\n\t    {\n\t\tescaped = TRUE;\n\t\tcontinue;\n\t    }\n\n\t    // Ignore special key codes: mouse movement, K_IGNORE, etc.\n\t    if (IS_SPECIAL(c1))\n\t\tcontinue;\n\t}\n\n\tif (IS_SPECIAL(c1))\n\t    c1 = '?';\n\tif (has_mbyte)\n\t    len = (*mb_char2bytes)(c1,\n\t\t\t\t  (char_u *)line_ga.ga_data + line_ga.ga_len);\n\telse\n\t{\n\t    len = 1;\n\t    ((char_u *)line_ga.ga_data)[line_ga.ga_len] = c1;\n\t}\n\tif (c1 == '\\n')\n\t    msg_putchar('\\n');\n\telse if (c1 == TAB)\n\t{\n\t    // Don't use chartabsize(), 'ts' can be different\n\t    do\n\t\tmsg_putchar(' ');\n\t    while (++vcol % 8);\n\t}\n\telse\n\t{\n\t    msg_outtrans_len(\n\t\t     ((char_u *)line_ga.ga_data) + line_ga.ga_len, len);\n\t    vcol += char2cells(c1);\n\t}\n\tline_ga.ga_len += len;\n\tescaped = FALSE;\n\n\twindgoto(msg_row, msg_col);\n\tpend = (char_u *)(line_ga.ga_data) + line_ga.ga_len;\n\n\t// We are done when a NL is entered, but not when it comes after an\n\t// odd number of backslashes, that results in a NUL.\n\tif (line_ga.ga_len > 0 && pend[-1] == '\\n')\n\t{\n\t    int bcount = 0;\n\n\t    while (line_ga.ga_len - 2 >= bcount && pend[-2 - bcount] == '\\\\')\n\t\t++bcount;\n\n\t    if (bcount > 0)\n\t    {\n\t\t// Halve the number of backslashes: \"\\NL\" -> \"NUL\", \"\\\\NL\" ->\n\t\t// \"\\NL\", etc.\n\t\tline_ga.ga_len -= (bcount + 1) / 2;\n\t\tpend -= (bcount + 1) / 2;\n\t\tpend[-1] = '\\n';\n\t    }\n\n\t    if ((bcount & 1) == 0)\n\t    {\n\t\t--line_ga.ga_len;\n\t\t--pend;\n\t\t*pend = NUL;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    --no_mapping;\n    --allow_keys;\n\n    // make following messages go to the next line\n    msg_didout = FALSE;\n    msg_col = 0;\n    if (msg_row < Rows - 1)\n\t++msg_row;\n    emsg_on_display = FALSE;\t\t// don't want ui_delay()\n\n    if (got_int)\n\tga_clear(&line_ga);\n\n    return (char_u *)line_ga.ga_data;\n}\n\n# if defined(MCH_CURSOR_SHAPE) || defined(FEAT_GUI) \\\n\t|| defined(FEAT_MOUSESHAPE) || defined(PROTO)\n/*\n * Return TRUE if ccline.overstrike is on.\n */\n    int\ncmdline_overstrike(void)\n{\n    return ccline.overstrike;\n}\n\n/*\n * Return TRUE if the cursor is at the end of the cmdline.\n */\n    int\ncmdline_at_end(void)\n{\n    return (ccline.cmdpos >= ccline.cmdlen);\n}\n#endif\n\n#if (defined(FEAT_XIM) && (defined(FEAT_GUI_GTK))) || defined(PROTO)\n/*\n * Return the virtual column number at the current cursor position.\n * This is used by the IM code to obtain the start of the preedit string.\n */\n    colnr_T\ncmdline_getvcol_cursor(void)\n{\n    if (ccline.cmdbuff == NULL || ccline.cmdpos > ccline.cmdlen)\n\treturn MAXCOL;\n\n    if (has_mbyte)\n    {\n\tcolnr_T\tcol;\n\tint\ti = 0;\n\n\tfor (col = 0; i < ccline.cmdpos; ++col)\n\t    i += (*mb_ptr2len)(ccline.cmdbuff + i);\n\n\treturn col;\n    }\n    else\n\treturn ccline.cmdpos;\n}\n#endif\n\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n/*\n * If part of the command line is an IM preedit string, redraw it with\n * IM feedback attributes.  The cursor position is restored after drawing.\n */\n    static void\nredrawcmd_preedit(void)\n{\n    if ((State & MODE_CMDLINE)\n\t    && xic != NULL\n\t    // && im_get_status()  doesn't work when using SCIM\n\t    && !p_imdisable\n\t    && im_is_preediting())\n    {\n\tint\tcmdpos = 0;\n\tint\tcmdspos;\n\tint\told_row;\n\tint\told_col;\n\tcolnr_T\tcol;\n\n\told_row = msg_row;\n\told_col = msg_col;\n\tcmdspos = ((ccline.cmdfirstc != NUL) ? 1 : 0) + ccline.cmdindent;\n\n\tif (has_mbyte)\n\t{\n\t    for (col = 0; col < preedit_start_col\n\t\t\t  && cmdpos < ccline.cmdlen; ++col)\n\t    {\n\t\tcmdspos += (*mb_ptr2cells)(ccline.cmdbuff + cmdpos);\n\t\tcmdpos  += (*mb_ptr2len)(ccline.cmdbuff + cmdpos);\n\t    }\n\t}\n\telse\n\t{\n\t    cmdspos += preedit_start_col;\n\t    cmdpos  += preedit_start_col;\n\t}\n\n\tmsg_row = cmdline_row + (cmdspos / (int)Columns);\n\tmsg_col = cmdspos % (int)Columns;\n\tif (msg_row >= Rows)\n\t    msg_row = Rows - 1;\n\n\tfor (col = 0; cmdpos < ccline.cmdlen; ++col)\n\t{\n\t    int char_len;\n\t    int char_attr;\n\n\t    char_attr = im_get_feedback_attr(col);\n\t    if (char_attr < 0)\n\t\tbreak; // end of preedit string\n\n\t    if (has_mbyte)\n\t\tchar_len = (*mb_ptr2len)(ccline.cmdbuff + cmdpos);\n\t    else\n\t\tchar_len = 1;\n\n\t    msg_outtrans_len_attr(ccline.cmdbuff + cmdpos, char_len, char_attr);\n\t    cmdpos += char_len;\n\t}\n\n\tmsg_row = old_row;\n\tmsg_col = old_col;\n    }\n}\n#endif // FEAT_XIM && FEAT_GUI_GTK\n\n/*\n * Allocate a new command line buffer.\n * Assigns the new buffer to ccline.cmdbuff and ccline.cmdbufflen.\n */\n    static void\nalloc_cmdbuff(int len)\n{\n    /*\n     * give some extra space to avoid having to allocate all the time\n     */\n    if (len < 80)\n\tlen = 100;\n    else\n\tlen += 20;\n\n    ccline.cmdbuff = alloc(len);    // caller should check for out-of-memory\n    ccline.cmdbufflen = len;\n}\n\n/*\n * Re-allocate the command line to length len + something extra.\n * return FAIL for failure, OK otherwise\n */\n    int\nrealloc_cmdbuff(int len)\n{\n    char_u\t*p;\n\n    if (len < ccline.cmdbufflen)\n\treturn OK;\t\t\t// no need to resize\n\n    p = ccline.cmdbuff;\n    alloc_cmdbuff(len);\t\t\t// will get some more\n    if (ccline.cmdbuff == NULL)\t\t// out of memory\n    {\n\tccline.cmdbuff = p;\t\t// keep the old one\n\treturn FAIL;\n    }\n    // There isn't always a NUL after the command, but it may need to be\n    // there, thus copy up to the NUL and add a NUL.\n    mch_memmove(ccline.cmdbuff, p, (size_t)ccline.cmdlen);\n    ccline.cmdbuff[ccline.cmdlen] = NUL;\n    vim_free(p);\n\n    if (ccline.xpc != NULL\n\t    && ccline.xpc->xp_pattern != NULL\n\t    && ccline.xpc->xp_context != EXPAND_NOTHING\n\t    && ccline.xpc->xp_context != EXPAND_UNSUCCESSFUL)\n    {\n\tint i = (int)(ccline.xpc->xp_pattern - p);\n\n\t// If xp_pattern points inside the old cmdbuff it needs to be adjusted\n\t// to point into the newly allocated memory.\n\tif (i >= 0 && i <= ccline.cmdlen)\n\t    ccline.xpc->xp_pattern = ccline.cmdbuff + i;\n    }\n\n    return OK;\n}\n\n#if defined(FEAT_ARABIC) || defined(PROTO)\nstatic char_u\t*arshape_buf = NULL;\n\n# if defined(EXITFREE) || defined(PROTO)\n    void\nfree_arshape_buf(void)\n{\n    vim_free(arshape_buf);\n}\n# endif\n#endif\n\n/*\n * Draw part of the cmdline at the current cursor position.  But draw stars\n * when cmdline_star is TRUE.\n */\n    static void\ndraw_cmdline(int start, int len)\n{\n#if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\n    int\t\ti;\n\n    if (cmdline_star > 0)\n\tfor (i = 0; i < len; ++i)\n\t{\n\t    msg_putchar('*');\n\t    if (has_mbyte)\n\t\ti += (*mb_ptr2len)(ccline.cmdbuff + start + i) - 1;\n\t}\n    else\n#endif\n#ifdef FEAT_ARABIC\n\tif (p_arshape && !p_tbidi && cmdline_has_arabic(start, len))\n    {\n\tstatic int\tbuflen = 0;\n\tchar_u\t\t*p;\n\tint\t\tj;\n\tint\t\tnewlen = 0;\n\tint\t\tmb_l;\n\tint\t\tpc, pc1 = 0;\n\tint\t\tprev_c = 0;\n\tint\t\tprev_c1 = 0;\n\tint\t\tu8c;\n\tint\t\tu8cc[MAX_MCO];\n\tint\t\tnc = 0;\n\n\t/*\n\t * Do arabic shaping into a temporary buffer.  This is very\n\t * inefficient!\n\t */\n\tif (len * 2 + 2 > buflen)\n\t{\n\t    // Re-allocate the buffer.  We keep it around to avoid a lot of\n\t    // alloc()/free() calls.\n\t    vim_free(arshape_buf);\n\t    buflen = len * 2 + 2;\n\t    arshape_buf = alloc(buflen);\n\t    if (arshape_buf == NULL)\n\t\treturn;\t// out of memory\n\t}\n\n\tif (utf_iscomposing(utf_ptr2char(ccline.cmdbuff + start)))\n\t{\n\t    // Prepend a space to draw the leading composing char on.\n\t    arshape_buf[0] = ' ';\n\t    newlen = 1;\n\t}\n\n\tfor (j = start; j < start + len; j += mb_l)\n\t{\n\t    p = ccline.cmdbuff + j;\n\t    u8c = utfc_ptr2char_len(p, u8cc, start + len - j);\n\t    mb_l = utfc_ptr2len_len(p, start + len - j);\n\t    if (ARABIC_CHAR(u8c))\n\t    {\n\t\t// Do Arabic shaping.\n\t\tif (cmdmsg_rl)\n\t\t{\n\t\t    // displaying from right to left\n\t\t    pc = prev_c;\n\t\t    pc1 = prev_c1;\n\t\t    prev_c1 = u8cc[0];\n\t\t    if (j + mb_l >= start + len)\n\t\t\tnc = NUL;\n\t\t    else\n\t\t\tnc = utf_ptr2char(p + mb_l);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // displaying from left to right\n\t\t    if (j + mb_l >= start + len)\n\t\t\tpc = NUL;\n\t\t    else\n\t\t    {\n\t\t\tint\tpcc[MAX_MCO];\n\n\t\t\tpc = utfc_ptr2char_len(p + mb_l, pcc,\n\t\t\t\t\t\t      start + len - j - mb_l);\n\t\t\tpc1 = pcc[0];\n\t\t    }\n\t\t    nc = prev_c;\n\t\t}\n\t\tprev_c = u8c;\n\n\t\tu8c = arabic_shape(u8c, NULL, &u8cc[0], pc, pc1, nc);\n\n\t\tnewlen += (*mb_char2bytes)(u8c, arshape_buf + newlen);\n\t\tif (u8cc[0] != 0)\n\t\t{\n\t\t    newlen += (*mb_char2bytes)(u8cc[0], arshape_buf + newlen);\n\t\t    if (u8cc[1] != 0)\n\t\t\tnewlen += (*mb_char2bytes)(u8cc[1],\n\t\t\t\t\t\t\tarshape_buf + newlen);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tprev_c = u8c;\n\t\tmch_memmove(arshape_buf + newlen, p, mb_l);\n\t\tnewlen += mb_l;\n\t    }\n\t}\n\n\tmsg_outtrans_len(arshape_buf, newlen);\n    }\n    else\n#endif\n\tmsg_outtrans_len(ccline.cmdbuff + start, len);\n}\n\n/*\n * Put a character on the command line.  Shifts the following text to the\n * right when \"shift\" is TRUE.  Used for CTRL-V, CTRL-K, etc.\n * \"c\" must be printable (fit in one display cell)!\n */\n    void\nputcmdline(int c, int shift)\n{\n    if (cmd_silent)\n\treturn;\n    msg_no_more = TRUE;\n    msg_putchar(c);\n    if (shift)\n\tdraw_cmdline(ccline.cmdpos, ccline.cmdlen - ccline.cmdpos);\n    msg_no_more = FALSE;\n    cursorcmd();\n    extra_char = c;\n    extra_char_shift = shift;\n}\n\n/*\n * Undo a putcmdline(c, FALSE).\n */\n    void\nunputcmdline(void)\n{\n    if (cmd_silent)\n\treturn;\n    msg_no_more = TRUE;\n    if (ccline.cmdlen == ccline.cmdpos)\n\tmsg_putchar(' ');\n    else if (has_mbyte)\n\tdraw_cmdline(ccline.cmdpos,\n\t\t\t       (*mb_ptr2len)(ccline.cmdbuff + ccline.cmdpos));\n    else\n\tdraw_cmdline(ccline.cmdpos, 1);\n    msg_no_more = FALSE;\n    cursorcmd();\n    extra_char = NUL;\n}\n\n/*\n * Put the given string, of the given length, onto the command line.\n * If len is -1, then STRLEN() is used to calculate the length.\n * If 'redraw' is TRUE then the new part of the command line, and the remaining\n * part will be redrawn, otherwise it will not.  If this function is called\n * twice in a row, then 'redraw' should be FALSE and redrawcmd() should be\n * called afterwards.\n */\n    int\nput_on_cmdline(char_u *str, int len, int redraw)\n{\n    int\t\tretval;\n    int\t\ti;\n    int\t\tm;\n    int\t\tc;\n\n    if (len < 0)\n\tlen = (int)STRLEN(str);\n\n    // Check if ccline.cmdbuff needs to be longer\n    if (ccline.cmdlen + len + 1 >= ccline.cmdbufflen)\n\tretval = realloc_cmdbuff(ccline.cmdlen + len + 1);\n    else\n\tretval = OK;\n    if (retval == OK)\n    {\n\tif (!ccline.overstrike)\n\t{\n\t    mch_memmove(ccline.cmdbuff + ccline.cmdpos + len,\n\t\t\t\t\t       ccline.cmdbuff + ccline.cmdpos,\n\t\t\t\t     (size_t)(ccline.cmdlen - ccline.cmdpos));\n\t    ccline.cmdlen += len;\n\t}\n\telse\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\t// Count nr of characters in the new string.\n\t\tm = 0;\n\t\tfor (i = 0; i < len; i += (*mb_ptr2len)(str + i))\n\t\t    ++m;\n\t\t// Count nr of bytes in cmdline that are overwritten by these\n\t\t// characters.\n\t\tfor (i = ccline.cmdpos; i < ccline.cmdlen && m > 0;\n\t\t\t\t i += (*mb_ptr2len)(ccline.cmdbuff + i))\n\t\t    --m;\n\t\tif (i < ccline.cmdlen)\n\t\t{\n\t\t    mch_memmove(ccline.cmdbuff + ccline.cmdpos + len,\n\t\t\t    ccline.cmdbuff + i, (size_t)(ccline.cmdlen - i));\n\t\t    ccline.cmdlen += ccline.cmdpos + len - i;\n\t\t}\n\t\telse\n\t\t    ccline.cmdlen = ccline.cmdpos + len;\n\t    }\n\t    else if (ccline.cmdpos + len > ccline.cmdlen)\n\t\tccline.cmdlen = ccline.cmdpos + len;\n\t}\n\tmch_memmove(ccline.cmdbuff + ccline.cmdpos, str, (size_t)len);\n\tccline.cmdbuff[ccline.cmdlen] = NUL;\n\n\tif (enc_utf8)\n\t{\n\t    // When the inserted text starts with a composing character,\n\t    // backup to the character before it.  There could be two of them.\n\t    i = 0;\n\t    c = utf_ptr2char(ccline.cmdbuff + ccline.cmdpos);\n\t    while (ccline.cmdpos > 0 && utf_iscomposing(c))\n\t    {\n\t\ti = (*mb_head_off)(ccline.cmdbuff,\n\t\t\t\t      ccline.cmdbuff + ccline.cmdpos - 1) + 1;\n\t\tccline.cmdpos -= i;\n\t\tlen += i;\n\t\tc = utf_ptr2char(ccline.cmdbuff + ccline.cmdpos);\n\t    }\n#ifdef FEAT_ARABIC\n\t    if (i == 0 && ccline.cmdpos > 0 && arabic_maycombine(c))\n\t    {\n\t\t// Check the previous character for Arabic combining pair.\n\t\ti = (*mb_head_off)(ccline.cmdbuff,\n\t\t\t\t      ccline.cmdbuff + ccline.cmdpos - 1) + 1;\n\t\tif (arabic_combine(utf_ptr2char(ccline.cmdbuff\n\t\t\t\t\t\t     + ccline.cmdpos - i), c))\n\t\t{\n\t\t    ccline.cmdpos -= i;\n\t\t    len += i;\n\t\t}\n\t\telse\n\t\t    i = 0;\n\t    }\n#endif\n\t    if (i != 0)\n\t    {\n\t\t// Also backup the cursor position.\n\t\ti = ptr2cells(ccline.cmdbuff + ccline.cmdpos);\n\t\tccline.cmdspos -= i;\n\t\tmsg_col -= i;\n\t\tif (msg_col < 0)\n\t\t{\n\t\t    msg_col += Columns;\n\t\t    --msg_row;\n\t\t}\n\t    }\n\t}\n\n\tif (redraw && !cmd_silent)\n\t{\n\t    msg_no_more = TRUE;\n\t    i = cmdline_row;\n\t    cursorcmd();\n\t    draw_cmdline(ccline.cmdpos, ccline.cmdlen - ccline.cmdpos);\n\t    // Avoid clearing the rest of the line too often.\n\t    if (cmdline_row != i || ccline.overstrike)\n\t\tmsg_clr_eos();\n\t    msg_no_more = FALSE;\n\t}\n\tif (KeyTyped)\n\t{\n\t    m = Columns * Rows;\n\t    if (m < 0)\t// overflow, Columns or Rows at weird value\n\t\tm = MAXCOL;\n\t}\n\telse\n\t    m = MAXCOL;\n\tfor (i = 0; i < len; ++i)\n\t{\n\t    c = cmdline_charsize(ccline.cmdpos);\n\t    // count \">\" for a double-wide char that doesn't fit.\n\t    if (has_mbyte)\n\t\tcorrect_cmdspos(ccline.cmdpos, c);\n\t    // Stop cursor at the end of the screen, but do increment the\n\t    // insert position, so that entering a very long command\n\t    // works, even though you can't see it.\n\t    if (ccline.cmdspos + c < m)\n\t\tccline.cmdspos += c;\n\n\t    if (has_mbyte)\n\t    {\n\t\tc = (*mb_ptr2len)(ccline.cmdbuff + ccline.cmdpos) - 1;\n\t\tif (c > len - i - 1)\n\t\t    c = len - i - 1;\n\t\tccline.cmdpos += c;\n\t\ti += c;\n\t    }\n\t    ++ccline.cmdpos;\n\t}\n    }\n    if (redraw)\n\tmsg_check();\n    return retval;\n}\n\nstatic cmdline_info_T\tprev_ccline;\nstatic int\t\tprev_ccline_used = FALSE;\n\n/*\n * Save ccline, because obtaining the \"=\" register may execute \"normal :cmd\"\n * and overwrite it.  But get_cmdline_str() may need it, thus make it\n * available globally in prev_ccline.\n */\n    static void\nsave_cmdline(cmdline_info_T *ccp)\n{\n    if (!prev_ccline_used)\n    {\n\tCLEAR_FIELD(prev_ccline);\n\tprev_ccline_used = TRUE;\n    }\n    *ccp = prev_ccline;\n    prev_ccline = ccline;\n    ccline.cmdbuff = NULL;  // signal that ccline is not in use\n}\n\n/*\n * Restore ccline after it has been saved with save_cmdline().\n */\n    static void\nrestore_cmdline(cmdline_info_T *ccp)\n{\n    ccline = prev_ccline;\n    prev_ccline = *ccp;\n}\n\n/*\n * Paste a yank register into the command line.\n * Used by CTRL-R command in command-line mode.\n * insert_reg() can't be used here, because special characters from the\n * register contents will be interpreted as commands.\n *\n * Return FAIL for failure, OK otherwise.\n */\n    static int\ncmdline_paste(\n    int regname,\n    int literally,\t// Insert text literally instead of \"as typed\"\n    int remcr)\t\t// remove trailing CR\n{\n    long\t\ti;\n    char_u\t\t*arg;\n    char_u\t\t*p;\n    int\t\t\tallocated;\n\n    // check for valid regname; also accept special characters for CTRL-R in\n    // the command line\n    if (regname != Ctrl_F && regname != Ctrl_P && regname != Ctrl_W\n\t    && regname != Ctrl_A && regname != Ctrl_L\n\t    && !valid_yank_reg(regname, FALSE))\n\treturn FAIL;\n\n    // A register containing CTRL-R can cause an endless loop.  Allow using\n    // CTRL-C to break the loop.\n    line_breakcheck();\n    if (got_int)\n\treturn FAIL;\n\n#ifdef FEAT_CLIPBOARD\n    regname = may_get_selection(regname);\n#endif\n\n    // Need to set \"textlock\" to avoid nasty things like going to another\n    // buffer when evaluating an expression.\n    ++textlock;\n    i = get_spec_reg(regname, &arg, &allocated, TRUE);\n    --textlock;\n\n    if (i)\n    {\n\t// Got the value of a special register in \"arg\".\n\tif (arg == NULL)\n\t    return FAIL;\n\n\t// When 'incsearch' is set and CTRL-R CTRL-W used: skip the duplicate\n\t// part of the word.\n\tp = arg;\n\tif (p_is && regname == Ctrl_W)\n\t{\n\t    char_u  *w;\n\t    int\t    len;\n\n\t    // Locate start of last word in the cmd buffer.\n\t    for (w = ccline.cmdbuff + ccline.cmdpos; w > ccline.cmdbuff; )\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    len = (*mb_head_off)(ccline.cmdbuff, w - 1) + 1;\n\t\t    if (!vim_iswordc(mb_ptr2char(w - len)))\n\t\t\tbreak;\n\t\t    w -= len;\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (!vim_iswordc(w[-1]))\n\t\t\tbreak;\n\t\t    --w;\n\t\t}\n\t    }\n\t    len = (int)((ccline.cmdbuff + ccline.cmdpos) - w);\n\t    if (p_ic ? STRNICMP(w, arg, len) == 0 : STRNCMP(w, arg, len) == 0)\n\t\tp += len;\n\t}\n\n\tcmdline_paste_str(p, literally);\n\tif (allocated)\n\t    vim_free(arg);\n\treturn OK;\n    }\n\n    return cmdline_paste_reg(regname, literally, remcr);\n}\n\n/*\n * Put a string on the command line.\n * When \"literally\" is TRUE, insert literally.\n * When \"literally\" is FALSE, insert as typed, but don't leave the command\n * line.\n */\n    void\ncmdline_paste_str(char_u *s, int literally)\n{\n    int\t\tc, cv;\n\n    if (literally)\n\tput_on_cmdline(s, -1, TRUE);\n    else\n\twhile (*s != NUL)\n\t{\n\t    cv = *s;\n\t    if (cv == Ctrl_V && s[1])\n\t\t++s;\n\t    if (has_mbyte)\n\t\tc = mb_cptr2char_adv(&s);\n\t    else\n\t\tc = *s++;\n\t    if (cv == Ctrl_V || c == ESC || c == Ctrl_C\n\t\t    || c == CAR || c == NL || c == Ctrl_L\n#ifdef UNIX\n\t\t    || c == intr_char\n#endif\n\t\t    || (c == Ctrl_BSL && *s == Ctrl_N))\n\t\tstuffcharReadbuff(Ctrl_V);\n\t    stuffcharReadbuff(c);\n\t}\n}\n\n/*\n * This function is called when the screen size changes and with incremental\n * search and in other situations where the command line may have been\n * overwritten.\n */\n    void\nredrawcmdline(void)\n{\n    redrawcmdline_ex(TRUE);\n}\n\n/*\n * When \"do_compute_cmdrow\" is TRUE the command line is redrawn at the bottom.\n * If FALSE cmdline_row is used, which should redraw in the same place.\n */\n    void\nredrawcmdline_ex(int do_compute_cmdrow)\n{\n    if (cmd_silent)\n\treturn;\n    need_wait_return = FALSE;\n    if (do_compute_cmdrow)\n\tcompute_cmdrow();\n    redrawcmd();\n    cursorcmd();\n}\n\n    static void\nredrawcmdprompt(void)\n{\n    int\t\ti;\n\n    if (cmd_silent)\n\treturn;\n    if (ccline.cmdfirstc != NUL)\n\tmsg_putchar(ccline.cmdfirstc);\n    if (ccline.cmdprompt != NULL)\n    {\n\tmsg_puts_attr((char *)ccline.cmdprompt, ccline.cmdattr);\n\tccline.cmdindent = msg_col + (msg_row - cmdline_row) * Columns;\n\t// do the reverse of set_cmdspos()\n\tif (ccline.cmdfirstc != NUL)\n\t    --ccline.cmdindent;\n    }\n    else\n\tfor (i = ccline.cmdindent; i > 0; --i)\n\t    msg_putchar(' ');\n}\n\n/*\n * Redraw what is currently on the command line.\n */\n    void\nredrawcmd(void)\n{\n    if (cmd_silent)\n\treturn;\n\n    // when 'incsearch' is set there may be no command line while redrawing\n    if (ccline.cmdbuff == NULL)\n    {\n\twindgoto(cmdline_row, 0);\n\tmsg_clr_eos();\n\treturn;\n    }\n\n    msg_start();\n    redrawcmdprompt();\n\n    // Don't use more prompt, truncate the cmdline if it doesn't fit.\n    msg_no_more = TRUE;\n    draw_cmdline(0, ccline.cmdlen);\n    msg_clr_eos();\n    msg_no_more = FALSE;\n\n    set_cmdspos_cursor();\n    if (extra_char != NUL)\n\tputcmdline(extra_char, extra_char_shift);\n\n    /*\n     * An emsg() before may have set msg_scroll. This is used in normal mode,\n     * in cmdline mode we can reset them now.\n     */\n    msg_scroll = FALSE;\t\t// next message overwrites cmdline\n\n    // Typing ':' at the more prompt may set skip_redraw.  We don't want this\n    // in cmdline mode\n    skip_redraw = FALSE;\n}\n\n    void\ncompute_cmdrow(void)\n{\n    if (exmode_active || msg_scrolled != 0)\n\tcmdline_row = Rows - 1;\n    else\n\tcmdline_row = W_WINROW(lastwin) + lastwin->w_height\n\t\t\t\t\t\t    + lastwin->w_status_height;\n}\n\n    void\ncursorcmd(void)\n{\n    if (cmd_silent)\n\treturn;\n\n#ifdef FEAT_RIGHTLEFT\n    if (cmdmsg_rl)\n    {\n\tmsg_row = cmdline_row  + (ccline.cmdspos / (int)(Columns - 1));\n\tmsg_col = (int)Columns - (ccline.cmdspos % (int)(Columns - 1)) - 1;\n\tif (msg_row <= 0)\n\t    msg_row = Rows - 1;\n    }\n    else\n#endif\n    {\n\tmsg_row = cmdline_row + (ccline.cmdspos / (int)Columns);\n\tmsg_col = ccline.cmdspos % (int)Columns;\n\tif (msg_row >= Rows)\n\t    msg_row = Rows - 1;\n    }\n\n    windgoto(msg_row, msg_col);\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n    if (p_imst == IM_ON_THE_SPOT)\n\tredrawcmd_preedit();\n#endif\n#ifdef MCH_CURSOR_SHAPE\n    mch_update_cursor();\n#endif\n}\n\n    void\ngotocmdline(int clr)\n{\n    msg_start();\n#ifdef FEAT_RIGHTLEFT\n    if (cmdmsg_rl)\n\tmsg_col = Columns - 1;\n    else\n#endif\n\tmsg_col = 0;\t    // always start in column 0\n    if (clr)\t\t    // clear the bottom line(s)\n\tmsg_clr_eos();\t    // will reset clear_cmdline\n    windgoto(cmdline_row, 0);\n}\n\n/*\n * Check the word in front of the cursor for an abbreviation.\n * Called when the non-id character \"c\" has been entered.\n * When an abbreviation is recognized it is removed from the text with\n * backspaces and the replacement string is inserted, followed by \"c\".\n */\n    static int\nccheck_abbr(int c)\n{\n    int spos = 0;\n\n    if (p_paste || no_abbr)\t    // no abbreviations or in paste mode\n\treturn FALSE;\n\n    // Do not consider '<,'> be part of the mapping, skip leading whitespace.\n    // Actually accepts any mark.\n    while (VIM_ISWHITE(ccline.cmdbuff[spos]) && spos < ccline.cmdlen)\n\tspos++;\n    if (ccline.cmdlen - spos > 5\n\t    && ccline.cmdbuff[spos] == '\\''\n\t    && ccline.cmdbuff[spos + 2] == ','\n\t    && ccline.cmdbuff[spos + 3] == '\\'')\n\tspos += 5;\n    else\n\t// check abbreviation from the beginning of the commandline\n\tspos = 0;\n\n    return check_abbr(c, ccline.cmdbuff, ccline.cmdpos, spos);\n}\n\n/*\n * Escape special characters in \"fname\", depending on \"what\":\n * VSE_NONE: for when used as a file name argument after a Vim command.\n * VSE_SHELL: for a shell command.\n * VSE_BUFFER: for the \":buffer\" command.\n * Returns the result in allocated memory.\n */\n    char_u *\nvim_strsave_fnameescape(char_u *fname, int what)\n{\n    char_u\t*p;\n#ifdef BACKSLASH_IN_FILENAME\n    char_u\tbuf[20];\n    int\t\tj = 0;\n\n    // Don't escape '[', '{' and '!' if they are in 'isfname' and for the\n    // \":buffer\" command.\n    for (p = what == VSE_BUFFER ? BUFFER_ESC_CHARS : PATH_ESC_CHARS;\n\t\t\t\t\t\t\t\t*p != NUL; ++p)\n\tif ((*p != '[' && *p != '{' && *p != '!') || !vim_isfilec(*p))\n\t    buf[j++] = *p;\n    buf[j] = NUL;\n    p = vim_strsave_escaped(fname, buf);\n#else\n    p = vim_strsave_escaped(fname, what == VSE_SHELL ? SHELL_ESC_CHARS\n\t\t    : what == VSE_BUFFER ? BUFFER_ESC_CHARS : PATH_ESC_CHARS);\n    if (what == VSE_SHELL && csh_like_shell() && p != NULL)\n    {\n\tchar_u\t    *s;\n\n\t// For csh and similar shells need to put two backslashes before '!'.\n\t// One is taken by Vim, one by the shell.\n\ts = vim_strsave_escaped(p, (char_u *)\"!\");\n\tvim_free(p);\n\tp = s;\n    }\n#endif\n\n    // '>' and '+' are special at the start of some commands, e.g. \":edit\" and\n    // \":write\".  \"cd -\" has a special meaning.\n    if (p != NULL && (*p == '>' || *p == '+' || (*p == '-' && p[1] == NUL)))\n\tescape_fname(&p);\n\n    return p;\n}\n\n/*\n * Put a backslash before the file name in \"pp\", which is in allocated memory.\n */\n    void\nescape_fname(char_u **pp)\n{\n    char_u\t*p;\n\n    p = alloc(STRLEN(*pp) + 2);\n    if (p != NULL)\n    {\n\tp[0] = '\\\\';\n\tSTRCPY(p + 1, *pp);\n\tvim_free(*pp);\n\t*pp = p;\n    }\n}\n\n/*\n * For each file name in files[num_files]:\n * If 'orig_pat' starts with \"~/\", replace the home directory with \"~\".\n */\n    void\ntilde_replace(\n    char_u  *orig_pat,\n    int\t    num_files,\n    char_u  **files)\n{\n    int\t    i;\n    char_u  *p;\n\n    if (orig_pat[0] == '~' && vim_ispathsep(orig_pat[1]))\n    {\n\tfor (i = 0; i < num_files; ++i)\n\t{\n\t    p = home_replace_save(NULL, files[i]);\n\t    if (p != NULL)\n\t    {\n\t\tvim_free(files[i]);\n\t\tfiles[i] = p;\n\t    }\n\t}\n    }\n}\n\n/*\n * Get a pointer to the current command line info.\n */\n    cmdline_info_T *\nget_cmdline_info(void)\n{\n    return &ccline;\n}\n\n#if defined(FEAT_EVAL) || defined(FEAT_CMDWIN) || defined(PROTO)\n/*\n * Get pointer to the command line info to use. save_ccline() may clear\n * ccline and put the previous value in prev_ccline.\n */\n    static cmdline_info_T *\nget_ccline_ptr(void)\n{\n    if ((State & MODE_CMDLINE) == 0)\n\treturn NULL;\n    if (ccline.cmdbuff != NULL)\n\treturn &ccline;\n    if (prev_ccline_used && prev_ccline.cmdbuff != NULL)\n\treturn &prev_ccline;\n    return NULL;\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Get the current command line in allocated memory.\n * Only works when the command line is being edited.\n * Returns NULL when something is wrong.\n */\n    static char_u *\nget_cmdline_str(void)\n{\n    cmdline_info_T *p;\n\n    if (cmdline_star > 0)\n\treturn NULL;\n    p = get_ccline_ptr();\n    if (p == NULL)\n\treturn NULL;\n    return vim_strnsave(p->cmdbuff, p->cmdlen);\n}\n\n/*\n * Get the current command-line completion type.\n */\n    static char_u *\nget_cmdline_completion(void)\n{\n    cmdline_info_T *p;\n\n    if (cmdline_star > 0)\n\treturn NULL;\n\n    p = get_ccline_ptr();\n    if (p != NULL && p->xpc != NULL)\n    {\n\tchar_u *cmd_compl;\n\n\tset_expand_context(p->xpc);\n\n\tcmd_compl = cmdcomplete_type_to_str(p->xpc->xp_context);\n\tif (cmd_compl != NULL)\n\t    return vim_strsave(cmd_compl);\n    }\n\n    return NULL;\n}\n\n/*\n * \"getcmdcompltype()\" function\n */\n    void\nf_getcmdcompltype(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = get_cmdline_completion();\n}\n\n/*\n * \"getcmdline()\" function\n */\n    void\nf_getcmdline(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = get_cmdline_str();\n}\n\n/*\n * \"getcmdpos()\" function\n */\n    void\nf_getcmdpos(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    cmdline_info_T *p = get_ccline_ptr();\n\n    rettv->vval.v_number = 0;\n    if (p != NULL)\n    rettv->vval.v_number = p->cmdpos + 1;\n}\n\n/*\n * Get the command line cursor screen position.\n */\n    static int\nget_cmdline_screen_pos(void)\n{\n    cmdline_info_T *p = get_ccline_ptr();\n\n    if (p == NULL)\n\treturn -1;\n    return p->cmdspos;\n}\n\n/*\n * \"getcmdscreenpos()\" function\n */\n    void\nf_getcmdscreenpos(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->vval.v_number = get_cmdline_screen_pos() + 1;\n}\n\n/*\n * Set the command line byte position to \"pos\".  Zero is the first position.\n * Only works when the command line is being edited.\n * Returns 1 when failed, 0 when OK.\n */\n    static int\nset_cmdline_pos(\n    int\t\tpos)\n{\n    cmdline_info_T *p = get_ccline_ptr();\n\n    if (p == NULL)\n\treturn 1;\n\n    // The position is not set directly but after CTRL-\\ e or CTRL-R = has\n    // changed the command line.\n    if (pos < 0)\n\tnew_cmdpos = 0;\n    else\n\tnew_cmdpos = pos;\n    return 0;\n}\n\n/*\n * \"setcmdpos()\" function\n */\n    void\nf_setcmdpos(typval_T *argvars, typval_T *rettv)\n{\n    int\t\tpos;\n\n    if (in_vim9script() && check_for_number_arg(argvars, 0) == FAIL)\n\treturn;\n\n    pos = (int)tv_get_number(&argvars[0]) - 1;\n    if (pos >= 0)\n\trettv->vval.v_number = set_cmdline_pos(pos);\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(FEAT_CMDWIN)\n/*\n * Get the current command-line type.\n * Returns ':' or '/' or '?' or '@' or '>' or '-'\n * Only works when the command line is being edited.\n * Returns NUL when something is wrong.\n */\n    static int\nget_cmdline_type(void)\n{\n    cmdline_info_T *p = get_ccline_ptr();\n\n    if (p == NULL)\n\treturn NUL;\n    if (p->cmdfirstc == NUL)\n\treturn\n# ifdef FEAT_EVAL\n\t    (p->input_fn) ? '@' :\n# endif\n\t    '-';\n    return p->cmdfirstc;\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * \"getcmdtype()\" function\n */\n    void\nf_getcmdtype(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = alloc(2);\n    if (rettv->vval.v_string != NULL)\n    {\n\trettv->vval.v_string[0] = get_cmdline_type();\n\trettv->vval.v_string[1] = NUL;\n    }\n}\n\n#endif\n\n/*\n * Return the first character of the current command line.\n */\n    int\nget_cmdline_firstc(void)\n{\n    return ccline.cmdfirstc;\n}\n\n/*\n * Get indices \"num1,num2\" that specify a range within a list (not a range of\n * text lines in a buffer!) from a string.  Used for \":history\" and \":clist\".\n * Returns OK if parsed successfully, otherwise FAIL.\n */\n    int\nget_list_range(char_u **str, int *num1, int *num2)\n{\n    int\t\tlen;\n    int\t\tfirst = FALSE;\n    varnumber_T\tnum;\n\n    *str = skipwhite(*str);\n    if (**str == '-' || vim_isdigit(**str))  // parse \"from\" part of range\n    {\n\tvim_str2nr(*str, NULL, &len, 0, &num, NULL, 0, FALSE);\n\t*str += len;\n\t*num1 = (int)num;\n\tfirst = TRUE;\n    }\n    *str = skipwhite(*str);\n    if (**str == ',')\t\t\t// parse \"to\" part of range\n    {\n\t*str = skipwhite(*str + 1);\n\tvim_str2nr(*str, NULL, &len, 0, &num, NULL, 0, FALSE);\n\tif (len > 0)\n\t{\n\t    *num2 = (int)num;\n\t    *str = skipwhite(*str + len);\n\t}\n\telse if (!first)\t\t// no number given at all\n\t    return FAIL;\n    }\n    else if (first)\t\t\t// only one number given\n\t*num2 = *num1;\n    return OK;\n}\n\n#if defined(FEAT_CMDWIN) || defined(PROTO)\n/*\n * Check value of 'cedit' and set cedit_key.\n * Returns NULL if value is OK, error message otherwise.\n */\n    char *\ncheck_cedit(void)\n{\n    int n;\n\n    if (*p_cedit == NUL)\n\tcedit_key = -1;\n    else\n    {\n\tn = string_to_key(p_cedit, FALSE);\n\tif (vim_isprintc(n))\n\t    return e_invalid_argument;\n\tcedit_key = n;\n    }\n    return NULL;\n}\n\n/*\n * Open a window on the current command line and history.  Allow editing in\n * the window.  Returns when the window is closed.\n * Returns:\n *\tCR\t if the command is to be executed\n *\tCtrl_C\t if it is to be abandoned\n *\tK_IGNORE if editing continues\n */\n    static int\nopen_cmdwin(void)\n{\n    bufref_T\t\told_curbuf;\n    win_T\t\t*old_curwin = curwin;\n    bufref_T\t\tbufref;\n    win_T\t\t*wp;\n    int\t\t\ti;\n    linenr_T\t\tlnum;\n    int\t\t\thisttype;\n    garray_T\t\twinsizes;\n    int\t\t\tsave_restart_edit = restart_edit;\n    int\t\t\tsave_State = State;\n    int\t\t\tsave_exmode = exmode_active;\n#ifdef FEAT_RIGHTLEFT\n    int\t\t\tsave_cmdmsg_rl = cmdmsg_rl;\n#endif\n#ifdef FEAT_FOLDING\n    int\t\t\tsave_KeyTyped;\n#endif\n\n    // Can't do this recursively.  Can't do it when typing a password.\n    if (cmdwin_type != 0\n# if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\n\t    || cmdline_star > 0\n# endif\n\t    )\n    {\n\tbeep_flush();\n\treturn K_IGNORE;\n    }\n    set_bufref(&old_curbuf, curbuf);\n\n    // Save current window sizes.\n    win_size_save(&winsizes);\n\n    // When using completion in Insert mode with <C-R>=<C-F> one can open the\n    // command line window, but we don't want the popup menu then.\n    pum_undisplay();\n\n    // don't use a new tab page\n    cmdmod.cmod_tab = 0;\n    cmdmod.cmod_flags |= CMOD_NOSWAPFILE;\n\n    // Create a window for the command-line buffer.\n    if (win_split((int)p_cwh, WSP_BOT) == FAIL)\n    {\n\tbeep_flush();\n\tga_clear(&winsizes);\n\treturn K_IGNORE;\n    }\n    // Don't let quitting the More prompt make this fail.\n    got_int = FALSE;\n\n    // Set \"cmdwin_type\" before any autocommands may mess things up.\n    cmdwin_type = get_cmdline_type();\n\n    // Create the command-line buffer empty.\n    if (do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE, NULL) == FAIL)\n    {\n\t// Some autocommand messed it up?\n\twin_close(curwin, TRUE);\n\tga_clear(&winsizes);\n\tcmdwin_type = 0;\n\treturn Ctrl_C;\n    }\n\n    apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);\n    (void)setfname(curbuf, (char_u *)_(\"[Command Line]\"), NULL, TRUE);\n    apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);\n    set_option_value_give_err((char_u *)\"bt\",\n\t\t\t\t\t    0L, (char_u *)\"nofile\", OPT_LOCAL);\n    curbuf->b_p_ma = TRUE;\n#ifdef FEAT_FOLDING\n    curwin->w_p_fen = FALSE;\n#endif\n# ifdef FEAT_RIGHTLEFT\n    curwin->w_p_rl = cmdmsg_rl;\n    cmdmsg_rl = FALSE;\n# endif\n    RESET_BINDING(curwin);\n\n    // Don't allow switching to another buffer.\n    ++curbuf_lock;\n\n    // Showing the prompt may have set need_wait_return, reset it.\n    need_wait_return = FALSE;\n\n    histtype = hist_char2type(cmdwin_type);\n    if (histtype == HIST_CMD || histtype == HIST_DEBUG)\n    {\n\tif (p_wc == TAB)\n\t{\n\t    add_map((char_u *)\"<buffer> <Tab> <C-X><C-V>\", MODE_INSERT);\n\t    add_map((char_u *)\"<buffer> <Tab> a<C-X><C-V>\", MODE_NORMAL);\n\t}\n\tset_option_value_give_err((char_u *)\"ft\",\n\t\t\t\t\t       0L, (char_u *)\"vim\", OPT_LOCAL);\n    }\n    --curbuf_lock;\n\n    // Reset 'textwidth' after setting 'filetype' (the Vim filetype plugin\n    // sets 'textwidth' to 78).\n    curbuf->b_p_tw = 0;\n\n    // Fill the buffer with the history.\n    init_history();\n    if (get_hislen() > 0)\n    {\n\ti = *get_hisidx(histtype);\n\tif (i >= 0)\n\t{\n\t    lnum = 0;\n\t    do\n\t    {\n\t\tif (++i == get_hislen())\n\t\t    i = 0;\n\t\tif (get_histentry(histtype)[i].hisstr != NULL)\n\t\t    ml_append(lnum++, get_histentry(histtype)[i].hisstr,\n\t\t\t\t\t\t\t   (colnr_T)0, FALSE);\n\t    }\n\t    while (i != *get_hisidx(histtype));\n\t}\n    }\n\n    // Replace the empty last line with the current command-line and put the\n    // cursor there.\n    ml_replace(curbuf->b_ml.ml_line_count, ccline.cmdbuff, TRUE);\n    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n    curwin->w_cursor.col = ccline.cmdpos;\n    changed_line_abv_curs();\n    invalidate_botline();\n    redraw_later(SOME_VALID);\n\n    // No Ex mode here!\n    exmode_active = 0;\n\n    State = MODE_NORMAL;\n    setmouse();\n\n    // Reset here so it can be set by a CmdWinEnter autocommand.\n    cmdwin_result = 0;\n\n    // Trigger CmdwinEnter autocommands.\n    trigger_cmd_autocmd(cmdwin_type, EVENT_CMDWINENTER);\n    if (restart_edit != 0)\t// autocmd with \":startinsert\"\n\tstuffcharReadbuff(K_NOP);\n\n    i = RedrawingDisabled;\n    RedrawingDisabled = 0;\n\n    /*\n     * Call the main loop until <CR> or CTRL-C is typed.\n     */\n    main_loop(TRUE, FALSE);\n\n    RedrawingDisabled = i;\n\n# ifdef FEAT_FOLDING\n    save_KeyTyped = KeyTyped;\n# endif\n\n    // Trigger CmdwinLeave autocommands.\n    trigger_cmd_autocmd(cmdwin_type, EVENT_CMDWINLEAVE);\n\n# ifdef FEAT_FOLDING\n    // Restore KeyTyped in case it is modified by autocommands\n    KeyTyped = save_KeyTyped;\n# endif\n\n    cmdwin_type = 0;\n    exmode_active = save_exmode;\n\n    // Safety check: The old window or buffer was deleted: It's a bug when\n    // this happens!\n    if (!win_valid(old_curwin) || !bufref_valid(&old_curbuf))\n    {\n\tcmdwin_result = Ctrl_C;\n\temsg(_(e_active_window_or_buffer_deleted));\n    }\n    else\n    {\n# if defined(FEAT_EVAL)\n\t// autocmds may abort script processing\n\tif (aborting() && cmdwin_result != K_IGNORE)\n\t    cmdwin_result = Ctrl_C;\n# endif\n\t// Set the new command line from the cmdline buffer.\n\tvim_free(ccline.cmdbuff);\n\tif (cmdwin_result == K_XF1 || cmdwin_result == K_XF2) // :qa[!] typed\n\t{\n\t    char *p = (cmdwin_result == K_XF2) ? \"qa\" : \"qa!\";\n\n\t    if (histtype == HIST_CMD)\n\t    {\n\t\t// Execute the command directly.\n\t\tccline.cmdbuff = vim_strsave((char_u *)p);\n\t\tcmdwin_result = CAR;\n\t    }\n\t    else\n\t    {\n\t\t// First need to cancel what we were doing.\n\t\tccline.cmdbuff = NULL;\n\t\tstuffcharReadbuff(':');\n\t\tstuffReadbuff((char_u *)p);\n\t\tstuffcharReadbuff(CAR);\n\t    }\n\t}\n\telse if (cmdwin_result == K_XF2)\t// :qa typed\n\t{\n\t    ccline.cmdbuff = vim_strsave((char_u *)\"qa\");\n\t    cmdwin_result = CAR;\n\t}\n\telse if (cmdwin_result == Ctrl_C)\n\t{\n\t    // :q or :close, don't execute any command\n\t    // and don't modify the cmd window.\n\t    ccline.cmdbuff = NULL;\n\t}\n\telse\n\t    ccline.cmdbuff = vim_strsave(ml_get_curline());\n\tif (ccline.cmdbuff == NULL)\n\t{\n\t    ccline.cmdbuff = vim_strsave((char_u *)\"\");\n\t    ccline.cmdlen = 0;\n\t    ccline.cmdbufflen = 1;\n\t    ccline.cmdpos = 0;\n\t    cmdwin_result = Ctrl_C;\n\t}\n\telse\n\t{\n\t    ccline.cmdlen = (int)STRLEN(ccline.cmdbuff);\n\t    ccline.cmdbufflen = ccline.cmdlen + 1;\n\t    ccline.cmdpos = curwin->w_cursor.col;\n\t    if (ccline.cmdpos > ccline.cmdlen)\n\t\tccline.cmdpos = ccline.cmdlen;\n\t    if (cmdwin_result == K_IGNORE)\n\t    {\n\t\tset_cmdspos_cursor();\n\t\tredrawcmd();\n\t    }\n\t}\n\n# ifdef FEAT_CONCEAL\n\t// Avoid command-line window first character being concealed.\n\tcurwin->w_p_cole = 0;\n# endif\n\t// First go back to the original window.\n\twp = curwin;\n\tset_bufref(&bufref, curbuf);\n\twin_goto(old_curwin);\n\n\t// win_goto() may trigger an autocommand that already closes the\n\t// cmdline window.\n\tif (win_valid(wp) && wp != curwin)\n\t    win_close(wp, TRUE);\n\n\t// win_close() may have already wiped the buffer when 'bh' is\n\t// set to 'wipe', autocommands may have closed other windows\n\tif (bufref_valid(&bufref) && bufref.br_buf != curbuf)\n\t    close_buffer(NULL, bufref.br_buf, DOBUF_WIPE, FALSE, FALSE);\n\n\t// Restore window sizes.\n\twin_size_restore(&winsizes);\n    }\n\n    ga_clear(&winsizes);\n    restart_edit = save_restart_edit;\n# ifdef FEAT_RIGHTLEFT\n    cmdmsg_rl = save_cmdmsg_rl;\n# endif\n\n    State = save_State;\n    setmouse();\n\n    return cmdwin_result;\n}\n\n/*\n * Return TRUE if in the cmdwin, not editing the command line.\n */\n    int\nis_in_cmdwin(void)\n{\n    return cmdwin_type != 0 && get_cmdline_type() == NUL;\n}\n#endif // FEAT_CMDWIN\n\n/*\n * Used for commands that either take a simple command string argument, or:\n *\tcmd << endmarker\n *\t  {script}\n *\tendmarker\n * Returns a pointer to allocated memory with {script} or NULL.\n */\n    char_u *\nscript_get(exarg_T *eap UNUSED, char_u *cmd UNUSED)\n{\n#ifdef FEAT_EVAL\n    list_T\t*l;\n    listitem_T\t*li;\n    char_u\t*s;\n    garray_T\tga;\n\n    if (cmd[0] != '<' || cmd[1] != '<' || eap->getline == NULL)\n\treturn NULL;\n    cmd += 2;\n\n    l = heredoc_get(eap, cmd, TRUE, FALSE);\n    if (l == NULL)\n\treturn NULL;\n\n    ga_init2(&ga, 1, 0x400);\n\n    FOR_ALL_LIST_ITEMS(l, li)\n    {\n\ts = tv_get_string(&li->li_tv);\n\tga_concat(&ga, s);\n\tga_append(&ga, '\\n');\n    }\n    ga_append(&ga, NUL);\n\n    list_free(l);\n    return (char_u *)ga.ga_data;\n#else\n    return NULL;\n#endif\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * This function is used by f_input() and f_inputdialog() functions. The third\n * argument to f_input() specifies the type of completion to use at the\n * prompt. The third argument to f_inputdialog() specifies the value to return\n * when the user cancels the prompt.\n */\n    void\nget_user_input(\n    typval_T\t*argvars,\n    typval_T\t*rettv,\n    int\t\tinputdialog,\n    int\t\tsecret)\n{\n    char_u\t*prompt;\n    char_u\t*p = NULL;\n    int\t\tc;\n    char_u\tbuf[NUMBUFLEN];\n    int\t\tcmd_silent_save = cmd_silent;\n    char_u\t*defstr = (char_u *)\"\";\n    int\t\txp_type = EXPAND_NOTHING;\n    char_u\t*xp_arg = NULL;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n    if (input_busy)\n\treturn;  // this doesn't work recursively.\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_string_arg(argvars, 1) == FAIL\n\t\t|| (argvars[1].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_string_arg(argvars, 2) == FAIL)))\n\treturn;\n\n    prompt = tv_get_string_chk(&argvars[0]);\n\n#ifdef NO_CONSOLE_INPUT\n    // While starting up, there is no place to enter text. When running tests\n    // with --not-a-term we assume feedkeys() will be used.\n    if (no_console_input() && !is_not_a_term())\n\treturn;\n#endif\n\n    cmd_silent = FALSE;\t\t// Want to see the prompt.\n    if (prompt != NULL)\n    {\n\t// Only the part of the message after the last NL is considered as\n\t// prompt for the command line\n\tp = vim_strrchr(prompt, '\\n');\n\tif (p == NULL)\n\t    p = prompt;\n\telse\n\t{\n\t    ++p;\n\t    c = *p;\n\t    *p = NUL;\n\t    msg_start();\n\t    msg_clr_eos();\n\t    msg_puts_attr((char *)prompt, get_echo_attr());\n\t    msg_didout = FALSE;\n\t    msg_starthere();\n\t    *p = c;\n\t}\n\tcmdline_row = msg_row;\n\n\tif (argvars[1].v_type != VAR_UNKNOWN)\n\t{\n\t    defstr = tv_get_string_buf_chk(&argvars[1], buf);\n\t    if (defstr != NULL)\n\t\tstuffReadbuffSpec(defstr);\n\n\t    if (!inputdialog && argvars[2].v_type != VAR_UNKNOWN)\n\t    {\n\t\tchar_u\t*xp_name;\n\t\tint\txp_namelen;\n\t\tlong\targt = 0;\n\n\t\t// input() with a third argument: completion\n\t\trettv->vval.v_string = NULL;\n\n\t\txp_name = tv_get_string_buf_chk(&argvars[2], buf);\n\t\tif (xp_name == NULL)\n\t\t    return;\n\n\t\txp_namelen = (int)STRLEN(xp_name);\n\n\t\tif (parse_compl_arg(xp_name, xp_namelen, &xp_type, &argt,\n\t\t\t\t\t\t\t     &xp_arg) == FAIL)\n\t\t    return;\n\t    }\n\t}\n\n\tif (defstr != NULL)\n\t{\n\t    int save_ex_normal_busy = ex_normal_busy;\n\t    int save_vgetc_busy = vgetc_busy;\n\t    int save_input_busy = input_busy;\n\n\t    input_busy |= vgetc_busy;\n\t    ex_normal_busy = 0;\n\t    vgetc_busy = 0;\n\t    rettv->vval.v_string =\n\t\tgetcmdline_prompt(secret ? NUL : '@', p, get_echo_attr(),\n\t\t\t\t\t\t\t      xp_type, xp_arg);\n\t    ex_normal_busy = save_ex_normal_busy;\n\t    vgetc_busy = save_vgetc_busy;\n\t    input_busy = save_input_busy;\n\t}\n\tif (inputdialog && rettv->vval.v_string == NULL\n\t\t&& argvars[1].v_type != VAR_UNKNOWN\n\t\t&& argvars[2].v_type != VAR_UNKNOWN)\n\t    rettv->vval.v_string = vim_strsave(tv_get_string_buf(\n\t\t\t\t\t\t\t   &argvars[2], buf));\n\n\tvim_free(xp_arg);\n\n\t// since the user typed this, no need to wait for return\n\tneed_wait_return = FALSE;\n\tmsg_didout = FALSE;\n    }\n    cmd_silent = cmd_silent_save;\n}\n#endif\n", "/* ex_getln.c */\nvoid cmdline_init(void);\nchar_u *getcmdline(int firstc, long count, int indent, getline_opt_T do_concat);\nchar_u *getcmdline_prompt(int firstc, char_u *prompt, int attr, int xp_context, char_u *xp_arg);\nint check_opt_wim(void);\nvoid text_locked_msg(void);\nchar *get_text_locked_msg(void);\nint text_locked(void);\nint curbuf_locked(void);\nint allbuf_locked(void);\nchar_u *getexline(int c, void *cookie, int indent, getline_opt_T options);\nchar_u *getexmodeline(int promptc, void *cookie, int indent, getline_opt_T options);\nint cmdline_overstrike(void);\nint cmdline_at_end(void);\ncolnr_T cmdline_getvcol_cursor(void);\nint realloc_cmdbuff(int len);\nvoid free_arshape_buf(void);\nvoid putcmdline(int c, int shift);\nvoid unputcmdline(void);\nint put_on_cmdline(char_u *str, int len, int redraw);\nvoid cmdline_paste_str(char_u *s, int literally);\nvoid redrawcmdline(void);\nvoid redrawcmdline_ex(int do_compute_cmdrow);\nvoid redrawcmd(void);\nvoid compute_cmdrow(void);\nvoid cursorcmd(void);\nvoid gotocmdline(int clr);\nchar_u *vim_strsave_fnameescape(char_u *fname, int what);\nvoid escape_fname(char_u **pp);\nvoid tilde_replace(char_u *orig_pat, int num_files, char_u **files);\ncmdline_info_T *get_cmdline_info(void);\nvoid f_getcmdcompltype(typval_T *argvars, typval_T *rettv);\nvoid f_getcmdline(typval_T *argvars, typval_T *rettv);\nvoid f_getcmdpos(typval_T *argvars, typval_T *rettv);\nvoid f_setcmdpos(typval_T *argvars, typval_T *rettv);\nvoid f_getcmdscreenpos(typval_T *argvars, typval_T *rettv);\nvoid f_getcmdtype(typval_T *argvars, typval_T *rettv);\nint get_cmdline_firstc(void);\nint get_list_range(char_u **str, int *num1, int *num2);\nchar *check_cedit(void);\nint is_in_cmdwin(void);\nchar_u *script_get(exarg_T *eap, char_u *cmd);\nvoid get_user_input(typval_T *argvars, typval_T *rettv, int inputdialog, int secret);\n/* vim: set ft=c : */\n", "\" Tests for the substitute (:s) command\n\nsource shared.vim\nsource check.vim\n\nfunc Test_multiline_subst()\n  enew!\n  call append(0, [\"1 aa\",\n\t      \\ \"bb\",\n\t      \\ \"cc\",\n\t      \\ \"2 dd\",\n\t      \\ \"ee\",\n\t      \\ \"3 ef\",\n\t      \\ \"gh\",\n\t      \\ \"4 ij\",\n\t      \\ \"5 a8\",\n\t      \\ \"8b c9\",\n\t      \\ \"9d\",\n\t      \\ \"6 e7\",\n\t      \\ \"77f\",\n\t      \\ \"xxxxx\"])\n\n  1\n  \" test if replacing a line break works with a back reference\n  /^1/,/^2/s/\\n\\(.\\)/ \\1/\n  \" test if inserting a line break works with a back reference\n  /^3/,/^4/s/\\(.\\)$/\\r\\1/\n  \" test if replacing a line break with another line break works\n  /^5/,/^6/s/\\(\\_d\\{3}\\)/x\\1x/\n  call assert_equal('1 aa bb cc 2 dd ee', getline(1))\n  call assert_equal('3 e', getline(2))\n  call assert_equal('f', getline(3))\n  call assert_equal('g', getline(4))\n  call assert_equal('h', getline(5))\n  call assert_equal('4 i', getline(6))\n  call assert_equal('j', getline(7))\n  call assert_equal('5 ax8', getline(8))\n  call assert_equal('8xb cx9', getline(9))\n  call assert_equal('9xd', getline(10))\n  call assert_equal('6 ex7', getline(11))\n  call assert_equal('7x7f', getline(12))\n  call assert_equal('xxxxx', getline(13))\n  enew!\nendfunc\n\nfunc Test_substitute_variants()\n  \" Validate that all the 2-/3-letter variants which embed the flags into the\n  \" command name actually work.\n  enew!\n  let ln = 'Testing string'\n  let variants = [\n\t\\ { 'cmd': ':s/Test/test/c', 'exp': 'testing string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/foo/bar/ce', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/cg', 'exp': 'Tesring srring', 'prompt': 'a' },\n\t\\ { 'cmd': ':s/t/r/ci', 'exp': 'resting string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/t/r/cI', 'exp': 'Tesring string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/t/r/c', 'exp': 'Testing string', 'prompt': 'n' },\n\t\\ { 'cmd': ':s/t/r/cn', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/cp', 'exp': 'Tesring string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/t/r/cl', 'exp': 'Tesring string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/t/r/gc', 'exp': 'Tesring srring', 'prompt': 'a' },\n\t\\ { 'cmd': ':s/i/I/gc', 'exp': 'TestIng string', 'prompt': 'l' },\n\t\\ { 'cmd': ':s/foo/bar/ge', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/g', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s/t/r/gi', 'exp': 'resring srring' },\n\t\\ { 'cmd': ':s/t/r/gI', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s/t/r/gn', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/gp', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s/t/r/gl', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s//r/gr', 'exp': 'Testr strr' },\n\t\\ { 'cmd': ':s/t/r/ic', 'exp': 'resting string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/foo/bar/ie', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/i', 'exp': 'resting string' },\n\t\\ { 'cmd': ':s/t/r/iI', 'exp': 'Tesring string' },\n\t\\ { 'cmd': ':s/t/r/in', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/ip', 'exp': 'resting string' },\n\t\\ { 'cmd': ':s//r/ir', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s/t/r/Ic', 'exp': 'Tesring string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/foo/bar/Ie', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/Ig', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s/t/r/Ii', 'exp': 'resting string' },\n\t\\ { 'cmd': ':s/t/r/I', 'exp': 'Tesring string' },\n\t\\ { 'cmd': ':s/t/r/Ip', 'exp': 'Tesring string' },\n\t\\ { 'cmd': ':s/t/r/Il', 'exp': 'Tesring string' },\n\t\\ { 'cmd': ':s//r/Ir', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/rc', 'exp': 'Testr string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s//r/rg', 'exp': 'Testr strr' },\n\t\\ { 'cmd': ':s//r/ri', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/rI', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/rn', 'exp': 'Testing string' },\n\t\\ { 'cmd': ':s//r/rp', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/rl', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/r', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s/i/I/gc', 'exp': 'Testing string', 'prompt': 'q' },\n\t\\]\n\n  for var in variants\n    for run in [1, 2]\n      let cmd = var.cmd\n      if run == 2 && cmd =~ \"/.*/.*/.\"\n\t\" Change  :s/from/to/{flags}  to  :s{flags}\n\tlet cmd = substitute(cmd, '/.*/', '', '')\n      endif\n      call setline(1, [ln])\n      let msg = printf('using \"%s\"', cmd)\n      let @/='ing'\n      let v:errmsg = ''\n      call feedkeys(cmd . \"\\<CR>\" . get(var, 'prompt', ''), 'ntx')\n      \" No error should exist (matters for testing e flag)\n      call assert_equal('', v:errmsg, msg)\n      call assert_equal(var.exp, getline('.'), msg)\n    endfor\n  endfor\nendfunc\n\n\" Test the l, p, # flags.\nfunc Test_substitute_flags_lp()\n  new\n  call setline(1, \"abc\\tdef\\<C-h>ghi\")\n\n  let a = execute('s/a/a/p')\n  call assert_equal(\"\\nabc     def^Hghi\", a)\n\n  let a = execute('s/a/a/l')\n  call assert_equal(\"\\nabc^Idef^Hghi$\", a)\n\n  let a = execute('s/a/a/#')\n  call assert_equal(\"\\n  1 abc     def^Hghi\", a)\n\n  let a = execute('s/a/a/p#')\n  call assert_equal(\"\\n  1 abc     def^Hghi\", a)\n\n  let a = execute('s/a/a/l#')\n  call assert_equal(\"\\n  1 abc^Idef^Hghi$\", a)\n\n  let a = execute('s/a/a/')\n  call assert_equal(\"\", a)\n\n  bwipe!\nendfunc\n\nfunc Test_substitute_repeat()\n  \" This caused an invalid memory access.\n  split Xfile\n  s/^/x\n  call feedkeys(\"Qsc\\<CR>y\", 'tx')\n  bwipe!\nendfunc\n\n\" Test %s/\\n// which is implemented as a special case to use a\n\" more efficient join rather than doing a regular substitution.\nfunc Test_substitute_join()\n  new\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//')\n  call assert_equal(\"\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//g')\n  call assert_equal(\"\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//p')\n  call assert_equal(\"\\nfoo     barbar^Hfoo\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//l')\n  call assert_equal(\"\\nfoo^Ibarbar^Hfoo$\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//#')\n  call assert_equal(\"\\n  1 foo     barbar^Hfoo\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, ['foo', 'bar', 'baz', 'qux'])\n  call execute('1,2s/\\n//')\n  call assert_equal(['foobarbaz', 'qux'], getline(1, '$'))\n\n  bwipe!\nendfunc\n\nfunc Test_substitute_count()\n  new\n  call setline(1, ['foo foo', 'foo foo', 'foo foo', 'foo foo', 'foo foo'])\n  2\n\n  s/foo/bar/3\n  call assert_equal(['foo foo', 'bar foo', 'bar foo', 'bar foo', 'foo foo'],\n  \\                 getline(1, '$'))\n\n  call assert_fails('s/foo/bar/0', 'E939:')\n\n  call setline(1, ['foo foo', 'foo foo', 'foo foo', 'foo foo', 'foo foo'])\n  2,4s/foo/bar/ 10\n  call assert_equal(['foo foo', 'foo foo', 'foo foo', 'bar foo', 'bar foo'],\n        \\           getline(1, '$'))\n\n  bwipe!\nendfunc\n\n\" Test substitute 'n' flag (report number of matches, do not substitute).\nfunc Test_substitute_flag_n()\n  new\n  let lines = ['foo foo', 'foo foo', 'foo foo', 'foo foo', 'foo foo']\n  call setline(1, lines)\n\n  call assert_equal(\"\\n3 matches on 3 lines\", execute('2,4s/foo/bar/n'))\n  call assert_equal(\"\\n6 matches on 3 lines\", execute('2,4s/foo/bar/gn'))\n\n  \" c flag (confirm) should be ignored when using n flag.\n  call assert_equal(\"\\n3 matches on 3 lines\", execute('2,4s/foo/bar/nc'))\n\n  \" No substitution should have been done.\n  call assert_equal(lines, getline(1, '$'))\n\n  %delete _\n  call setline(1, ['A', 'Bar', 'Baz'])\n  call assert_equal(\"\\n1 match on 1 line\", execute('s/\\nB\\@=//gn'))\n\n  bwipe!\nendfunc\n\nfunc Test_substitute_errors()\n  new\n  call setline(1, 'foobar')\n\n  call assert_fails('s/FOO/bar/', 'E486:')\n  call assert_fails('s/foo/bar/@', 'E488:')\n  call assert_fails('s/\\(/bar/', 'E54:')\n  call assert_fails('s afooabara', 'E146:')\n  call assert_fails('s\\\\a', 'E10:')\n\n  setl nomodifiable\n  call assert_fails('s/foo/bar/', 'E21:')\n\n  call assert_fails(\"let s=substitute([], 'a', 'A', 'g')\", 'E730:')\n  call assert_fails(\"let s=substitute('abcda', [], 'A', 'g')\", 'E730:')\n  call assert_fails(\"let s=substitute('abcda', 'a', [], 'g')\", 'E730:')\n  call assert_fails(\"let s=substitute('abcda', 'a', 'A', [])\", 'E730:')\n  call assert_fails(\"let s=substitute('abc', '\\\\%(', 'A', 'g')\", 'E53:')\n\n  bwipe!\nendfunc\n\n\" Test for *sub-replace-special* and *sub-replace-expression* on substitute().\nfunc Test_sub_replace_1()\n  \" Run the tests with 'magic' on\n  set magic\n  set cpo&\n  call assert_equal('AA', substitute('A', 'A', '&&', ''))\n  call assert_equal('&', substitute('B', 'B', '\\&', ''))\n  call assert_equal('C123456789987654321', substitute('C123456789', 'C\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)', '\\0\\9\\8\\7\\6\\5\\4\\3\\2\\1', ''))\n  call assert_equal('d', substitute('D', 'D', 'd', ''))\n  call assert_equal('~', substitute('E', 'E', '~', ''))\n  call assert_equal('~', substitute('F', 'F', '\\~', ''))\n  call assert_equal('Gg', substitute('G', 'G', '\\ugg', ''))\n  call assert_equal('Hh', substitute('H', 'H', '\\Uh\\Eh', ''))\n  call assert_equal('iI', substitute('I', 'I', '\\lII', ''))\n  call assert_equal('jJ', substitute('J', 'J', '\\LJ\\EJ', ''))\n  call assert_equal('Kk', substitute('K', 'K', '\\Uk\\ek', ''))\n  call assert_equal(\"l\\<C-V>\\<C-M>l\",\n\t\t\t\\ substitute('lLl', 'L', \"\\<C-V>\\<C-M>\", ''))\n  call assert_equal(\"m\\<C-M>m\", substitute('mMm', 'M', '\\r', ''))\n  call assert_equal(\"n\\<C-V>\\<C-M>n\",\n\t\t\t\\ substitute('nNn', 'N', \"\\\\\\<C-V>\\<C-M>\", ''))\n  call assert_equal(\"o\\no\", substitute('oOo', 'O', '\\n', ''))\n  call assert_equal(\"p\\<C-H>p\", substitute('pPp', 'P', '\\b', ''))\n  call assert_equal(\"q\\tq\", substitute('qQq', 'Q', '\\t', ''))\n  call assert_equal('r\\r', substitute('rRr', 'R', '\\\\', ''))\n  call assert_equal('scs', substitute('sSs', 'S', '\\c', ''))\n  call assert_equal(\"u\\nu\", substitute('uUu', 'U', \"\\n\", ''))\n  call assert_equal(\"v\\<C-H>v\", substitute('vVv', 'V', \"\\b\", ''))\n  call assert_equal(\"w\\\\w\", substitute('wWw', 'W', \"\\\\\", ''))\n  call assert_equal(\"x\\<C-M>x\", substitute('xXx', 'X', \"\\r\", ''))\n  call assert_equal(\"YyyY\", substitute('Y', 'Y', '\\L\\uyYy\\l\\EY', ''))\n  call assert_equal(\"zZZz\", substitute('Z', 'Z', '\\U\\lZzZ\\u\\Ez', ''))\n  \" \\v or \\V after $\n  call assert_equal('abxx', substitute('abcd', 'xy$\\v|cd$', 'xx', ''))\n  call assert_equal('abxx', substitute('abcd', 'xy$\\V\\|cd\\$', 'xx', ''))\nendfunc\n\nfunc Test_sub_replace_2()\n  \" Run the tests with 'magic' off\n  set nomagic\n  set cpo&\n  call assert_equal('AA', substitute('A', 'A', '&&', ''))\n  call assert_equal('&', substitute('B', 'B', '\\&', ''))\n  call assert_equal('C123456789987654321', substitute('C123456789', 'C\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)', '\\0\\9\\8\\7\\6\\5\\4\\3\\2\\1', ''))\n  call assert_equal('d', substitute('D', 'D', 'd', ''))\n  call assert_equal('~', substitute('E', 'E', '~', ''))\n  call assert_equal('~', substitute('F', 'F', '\\~', ''))\n  call assert_equal('Gg', substitute('G', 'G', '\\ugg', ''))\n  call assert_equal('Hh', substitute('H', 'H', '\\Uh\\Eh', ''))\n  call assert_equal('iI', substitute('I', 'I', '\\lII', ''))\n  call assert_equal('jJ', substitute('J', 'J', '\\LJ\\EJ', ''))\n  call assert_equal('Kk', substitute('K', 'K', '\\Uk\\ek', ''))\n  call assert_equal(\"l\\<C-V>\\<C-M>l\",\n\t\t\t\\ substitute('lLl', 'L', \"\\<C-V>\\<C-M>\", ''))\n  call assert_equal(\"m\\<C-M>m\", substitute('mMm', 'M', '\\r', ''))\n  call assert_equal(\"n\\<C-V>\\<C-M>n\",\n\t\t\t\\ substitute('nNn', 'N', \"\\\\\\<C-V>\\<C-M>\", ''))\n  call assert_equal(\"o\\no\", substitute('oOo', 'O', '\\n', ''))\n  call assert_equal(\"p\\<C-H>p\", substitute('pPp', 'P', '\\b', ''))\n  call assert_equal(\"q\\tq\", substitute('qQq', 'Q', '\\t', ''))\n  call assert_equal('r\\r', substitute('rRr', 'R', '\\\\', ''))\n  call assert_equal('scs', substitute('sSs', 'S', '\\c', ''))\n  call assert_equal(\"t\\<C-M>t\", substitute('tTt', 'T', \"\\r\", ''))\n  call assert_equal(\"u\\nu\", substitute('uUu', 'U', \"\\n\", ''))\n  call assert_equal(\"v\\<C-H>v\", substitute('vVv', 'V', \"\\b\", ''))\n  call assert_equal('w\\w', substitute('wWw', 'W', \"\\\\\", ''))\n  call assert_equal('XxxX', substitute('X', 'X', '\\L\\uxXx\\l\\EX', ''))\n  call assert_equal('yYYy', substitute('Y', 'Y', '\\U\\lYyY\\u\\Ey', ''))\nendfunc\n\nfunc Test_sub_replace_3()\n  set magic&\n  set cpo&\n  call assert_equal('a\\a', substitute('aAa', 'A', '\\=\"\\\\\"', ''))\n  call assert_equal('b\\\\b', substitute('bBb', 'B', '\\=\"\\\\\\\\\"', ''))\n  call assert_equal(\"c\\rc\", substitute('cCc', 'C', \"\\\\=\\\"\\r\\\"\", ''))\n  call assert_equal(\"d\\\\\\rd\", substitute('dDd', 'D', \"\\\\=\\\"\\\\\\\\\\r\\\"\", ''))\n  call assert_equal(\"e\\\\\\\\\\re\", substitute('eEe', 'E', \"\\\\=\\\"\\\\\\\\\\\\\\\\\\r\\\"\", ''))\n  call assert_equal('f\\rf', substitute('fFf', 'F', '\\=\"\\\\r\"', ''))\n  call assert_equal('j\\nj', substitute('jJj', 'J', '\\=\"\\\\n\"', ''))\n  call assert_equal(\"k\\<C-M>k\", substitute('kKk', 'K', '\\=\"\\r\"', ''))\n  call assert_equal(\"l\\nl\", substitute('lLl', 'L', '\\=\"\\n\"', ''))\nendfunc\n\n\" Test for submatch() on substitute().\nfunc Test_sub_replace_4()\n  set magic&\n  set cpo&\n  call assert_equal('a\\a', substitute('aAa', 'A',\n\t\t\\ '\\=substitute(submatch(0), \".\", \"\\\\\", \"\")', ''))\n  call assert_equal('b\\b', substitute('bBb', 'B',\n\t\t\\ '\\=substitute(submatch(0), \".\", \"\\\\\\\\\", \"\")', ''))\n  call assert_equal(\"c\\<C-V>\\<C-M>c\", substitute('cCc', 'C', '\\=substitute(submatch(0), \".\", \"\\<C-V>\\<C-M>\", \"\")', ''))\n  call assert_equal(\"d\\<C-V>\\<C-M>d\", substitute('dDd', 'D', '\\=substitute(submatch(0), \".\", \"\\\\\\<C-V>\\<C-M>\", \"\")', ''))\n  call assert_equal(\"e\\\\\\<C-V>\\<C-M>e\", substitute('eEe', 'E', '\\=substitute(submatch(0), \".\", \"\\\\\\\\\\<C-V>\\<C-M>\", \"\")', ''))\n  call assert_equal(\"f\\<C-M>f\", substitute('fFf', 'F', '\\=substitute(submatch(0), \".\", \"\\\\r\", \"\")', ''))\n  call assert_equal(\"j\\nj\", substitute('jJj', 'J', '\\=substitute(submatch(0), \".\", \"\\\\n\", \"\")', ''))\n  call assert_equal(\"k\\rk\", substitute('kKk', 'K', '\\=substitute(submatch(0), \".\", \"\\r\", \"\")', ''))\n  call assert_equal(\"l\\nl\", substitute('lLl', 'L', '\\=substitute(submatch(0), \".\", \"\\n\", \"\")', ''))\nendfunc\n\nfunc Test_sub_replace_5()\n  set magic&\n  set cpo&\n  call assert_equal('A123456789987654321', substitute('A123456789',\n\t\t\\ 'A\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)',\n\t\t\\ '\\=submatch(0) . submatch(9) . submatch(8) . ' .\n\t\t\\ 'submatch(7) . submatch(6) . submatch(5) . ' .\n\t\t\\ 'submatch(4) . submatch(3) . submatch(2) . submatch(1)',\n\t\t\\ ''))\n   call assert_equal(\"[['A123456789'], ['9'], ['8'], ['7'], ['6'], \" .\n\t\t\\ \"['5'], ['4'], ['3'], ['2'], ['1']]\",\n\t\t\\ substitute('A123456789',\n\t\t\\ 'A\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)',\n\t\t\\ '\\=string([submatch(0, 1), submatch(9, 1), ' .\n\t\t\\ 'submatch(8, 1), 7->submatch(1), submatch(6, 1), ' .\n\t\t\\ 'submatch(5, 1), submatch(4, 1), submatch(3, 1), ' .\n\t\t\\ 'submatch(2, 1), submatch(1, 1)])',\n\t\t\\ ''))\nendfunc\n\nfunc Test_sub_replace_6()\n  set magic&\n  set cpo+=/\n  call assert_equal('a', substitute('A', 'A', 'a', ''))\n  call assert_equal('%', substitute('B', 'B', '%', ''))\n  set cpo-=/\n  call assert_equal('c', substitute('C', 'C', 'c', ''))\n  call assert_equal('%', substitute('D', 'D', '%', ''))\nendfunc\n\nfunc Test_sub_replace_7()\n  set magic&\n  set cpo&\n  call assert_equal('A\u0016A', substitute('A\u0016A', 'A.', '\\=submatch(0)', ''))\n  call assert_equal(\"B\\nB\", substitute(\"B\\nB\", 'B.', '\\=submatch(0)', ''))\n  call assert_equal(\"['B\\n']B\", substitute(\"B\\nB\", 'B.', '\\=string(submatch(0, 1))', ''))\n  call assert_equal('-abab', substitute('-bb', '\\zeb', 'a', 'g'))\n  call assert_equal('c-cbcbc', substitute('-bb', '\\ze', 'c', 'g'))\nendfunc\n\n\" Test for *:s%* on :substitute.\nfunc Test_sub_replace_8()\n  new\n  set magic&\n  set cpo&\n  $put =',,X'\n  s/\\(^\\|,\\)\\ze\\(,\\|X\\)/\\1N/g\n  call assert_equal('N,,NX', getline(\"$\"))\n  $put =',,Y'\n  let cmd = ':s/\\(^\\|,\\)\\ze\\(,\\|Y\\)/\\1N/gc'\n  call feedkeys(cmd . \"\\<CR>a\", \"xt\")\n  call assert_equal('N,,NY', getline(\"$\"))\n  :$put =',,Z'\n  let cmd = ':s/\\(^\\|,\\)\\ze\\(,\\|Z\\)/\\1N/gc'\n  call feedkeys(cmd . \"\\<CR>yy\", \"xt\")\n  call assert_equal('N,,NZ', getline(\"$\"))\n  enew! | close\nendfunc\n\nfunc Test_sub_replace_9()\n  new\n  set magic&\n  set cpo&\n  $put ='xxx'\n  call feedkeys(\":s/x/X/gc\\<CR>yyq\", \"xt\")\n  call assert_equal('XXx', getline(\"$\"))\n  enew! | close\nendfunc\n\nfunc Test_sub_replace_10()\n   set magic&\n   set cpo&\n   call assert_equal('a1a2a3a', substitute('123', '\\zs', 'a', 'g'))\n   call assert_equal('aaa', substitute('123', '\\zs.', 'a', 'g'))\n   call assert_equal('1a2a3a', substitute('123', '.\\zs', 'a', 'g'))\n   call assert_equal('a1a2a3a', substitute('123', '\\ze', 'a', 'g'))\n   call assert_equal('a1a2a3', substitute('123', '\\ze.', 'a', 'g'))\n   call assert_equal('aaa', substitute('123', '.\\ze', 'a', 'g'))\n   call assert_equal('aa2a3a', substitute('123', '1\\|\\ze', 'a', 'g'))\n   call assert_equal('1aaa', substitute('123', '1\\zs\\|[23]', 'a', 'g'))\nendfunc\n\nfunc SubReplacer(text, submatches)\n  return a:text .. a:submatches[0] .. a:text\nendfunc\nfunc SubReplacer20(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, submatches)\n  return a:t3 .. a:submatches[0] .. a:t11\nendfunc\n\nfunc Test_substitute_partial()\n   call assert_equal('1foo2foo3', substitute('123', '2', function('SubReplacer', ['foo']), 'g'))\n\n   \" 19 arguments plus one is just OK\n   let Replacer = function('SubReplacer20', repeat(['foo'], 19))\n   call assert_equal('1foo2foo3', substitute('123', '2', Replacer, 'g'))\n\n   \" 20 arguments plus one is too many\n   let Replacer = function('SubReplacer20', repeat(['foo'], 20))\n   call assert_fails(\"call substitute('123', '2', Replacer, 'g')\", 'E118:')\nendfunc\n\nfunc Test_substitute_float()\n  CheckFeature float\n\n  call assert_equal('number 1.23', substitute('number ', '$', { -> 1.23 }, ''))\n  vim9 assert_equal('number 1.23', substitute('number ', '$', () => 1.23, ''))\nendfunc\n\n\" Tests for *sub-replace-special* and *sub-replace-expression* on :substitute.\n\n\" Execute a list of :substitute command tests\nfunc Run_SubCmd_Tests(tests)\n  enew!\n  for t in a:tests\n    let start = line('.') + 1\n    let end = start + len(t[2]) - 1\n    \" TODO: why is there a one second delay the first time we get here?\n    exe \"normal o\" . t[0]\n    call cursor(start, 1)\n    exe t[1]\n    call assert_equal(t[2], getline(start, end), t[1])\n  endfor\n  enew!\nendfunc\n\nfunc Test_sub_cmd_1()\n  set magic\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [['A', 's/A/&&/', ['AA']],\n\t      \\ ['B', 's/B/\\&/', ['&']],\n\t      \\ ['C123456789', 's/C\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)/\\0\\9\\8\\7\\6\\5\\4\\3\\2\\1/', ['C123456789987654321']],\n\t      \\ ['D', 's/D/d/', ['d']],\n\t      \\ ['E', 's/E/~/', ['d']],\n\t      \\ ['F', 's/F/\\~/', ['~']],\n\t      \\ ['G', 's/G/\\ugg/', ['Gg']],\n\t      \\ ['H', 's/H/\\Uh\\Eh/', ['Hh']],\n\t      \\ ['I', 's/I/\\lII/', ['iI']],\n\t      \\ ['J', 's/J/\\LJ\\EJ/', ['jJ']],\n\t      \\ ['K', 's/K/\\Uk\\ek/', ['Kk']],\n\t      \\ ['lLl', \"s/L/\\<C-V>\\<C-M>/\", [\"l\\<C-V>\", 'l']],\n\t      \\ ['mMm', 's/M/\\r/', ['m', 'm']],\n\t      \\ ['nNn', \"s/N/\\\\\\<C-V>\\<C-M>/\", [\"n\\<C-V>\", 'n']],\n\t      \\ ['oOo', 's/O/\\n/', [\"o\\no\"]],\n\t      \\ ['pPp', 's/P/\\b/', [\"p\\<C-H>p\"]],\n\t      \\ ['qQq', 's/Q/\\t/', [\"q\\tq\"]],\n\t      \\ ['rRr', 's/R/\\\\/', ['r\\r']],\n\t      \\ ['sSs', 's/S/\\c/', ['scs']],\n\t      \\ ['tTt', \"s/T/\\<C-V>\\<C-J>/\", [\"t\\<C-V>\\<C-J>t\"]],\n\t      \\ ['U', 's/U/\\L\\uuUu\\l\\EU/', ['UuuU']],\n\t      \\ ['V', 's/V/\\U\\lVvV\\u\\Ev/', ['vVVv']]\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\nfunc Test_sub_cmd_2()\n  set nomagic\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [['A', 's/A/&&/', ['&&']],\n\t      \\ ['B', 's/B/\\&/', ['B']],\n\t      \\ ['C123456789', 's/\\mC\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)/\\0\\9\\8\\7\\6\\5\\4\\3\\2\\1/', ['C123456789987654321']],\n\t      \\ ['D', 's/D/d/', ['d']],\n\t      \\ ['E', 's/E/~/', ['~']],\n\t      \\ ['F', 's/F/\\~/', ['~']],\n\t      \\ ['G', 's/G/\\ugg/', ['Gg']],\n\t      \\ ['H', 's/H/\\Uh\\Eh/', ['Hh']],\n\t      \\ ['I', 's/I/\\lII/', ['iI']],\n\t      \\ ['J', 's/J/\\LJ\\EJ/', ['jJ']],\n\t      \\ ['K', 's/K/\\Uk\\ek/', ['Kk']],\n\t      \\ ['lLl', \"s/L/\\<C-V>\\<C-M>/\", [\"l\\<C-V>\", 'l']],\n\t      \\ ['mMm', 's/M/\\r/', ['m', 'm']],\n\t      \\ ['nNn', \"s/N/\\\\\\<C-V>\\<C-M>/\", [\"n\\<C-V>\", 'n']],\n\t      \\ ['oOo', 's/O/\\n/', [\"o\\no\"]],\n\t      \\ ['pPp', 's/P/\\b/', [\"p\\<C-H>p\"]],\n\t      \\ ['qQq', 's/Q/\\t/', [\"q\\tq\"]],\n\t      \\ ['rRr', 's/R/\\\\/', ['r\\r']],\n\t      \\ ['sSs', 's/S/\\c/', ['scs']],\n\t      \\ ['tTt', \"s/T/\\<C-V>\\<C-J>/\", [\"t\\<C-V>\\<C-J>t\"]],\n\t      \\ ['U', 's/U/\\L\\uuUu\\l\\EU/', ['UuuU']],\n\t      \\ ['V', 's/V/\\U\\lVvV\\u\\Ev/', ['vVVv']]\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\nfunc Test_sub_cmd_3()\n  set nomagic\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [['aAa', \"s/A/\\\\='\\\\'/\", ['a\\a']],\n\t      \\ ['bBb', \"s/B/\\\\='\\\\\\\\'/\", ['b\\\\b']],\n\t      \\ ['cCc', \"s/C/\\\\='\\<C-V>\\<C-M>'/\", [\"c\\<C-V>\", 'c']],\n\t      \\ ['dDd', \"s/D/\\\\='\\\\\\<C-V>\\<C-M>'/\", [\"d\\\\\\<C-V>\", 'd']],\n\t      \\ ['eEe', \"s/E/\\\\='\\\\\\\\\\<C-V>\\<C-M>'/\", [\"e\\\\\\\\\\<C-V>\", 'e']],\n\t      \\ ['fFf', \"s/F/\\\\='\\r'/\", ['f', 'f']],\n\t      \\ ['gGg', \"s/G/\\\\='\\<C-V>\\<C-J>'/\", [\"g\\<C-V>\", 'g']],\n\t      \\ ['hHh', \"s/H/\\\\='\\\\\\<C-V>\\<C-J>'/\", [\"h\\\\\\<C-V>\", 'h']],\n\t      \\ ['iIi', \"s/I/\\\\='\\\\\\\\\\<C-V>\\<C-J>'/\", [\"i\\\\\\\\\\<C-V>\", 'i']],\n\t      \\ ['jJj', \"s/J/\\\\='\\n'/\", ['j', 'j']],\n\t      \\ ['kKk', 's/K/\\=\"\\r\"/', ['k', 'k']],\n\t      \\ ['lLl', 's/L/\\=\"\\n\"/', ['l', 'l']]\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\n\" Test for submatch() on :substitute.\nfunc Test_sub_cmd_4()\n  set magic&\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [ ['aAa', \"s/A/\\\\=substitute(submatch(0), '.', '\\\\', '')/\",\n\t      \\\t\t\t\t['a\\a']],\n\t      \\ ['bBb', \"s/B/\\\\=substitute(submatch(0), '.', '\\\\', '')/\",\n\t      \\\t\t\t\t['b\\b']],\n\t      \\ ['cCc', \"s/C/\\\\=substitute(submatch(0), '.', '\\<C-V>\\<C-M>', '')/\",\n\t      \\\t\t\t\t[\"c\\<C-V>\", 'c']],\n\t      \\ ['dDd', \"s/D/\\\\=substitute(submatch(0), '.', '\\\\\\<C-V>\\<C-M>', '')/\",\n\t      \\\t\t\t\t[\"d\\<C-V>\", 'd']],\n\t      \\ ['eEe', \"s/E/\\\\=substitute(submatch(0), '.', '\\\\\\\\\\<C-V>\\<C-M>', '')/\",\n\t      \\\t\t\t\t[\"e\\\\\\<C-V>\", 'e']],\n\t      \\ ['fFf', \"s/F/\\\\=substitute(submatch(0), '.', '\\\\r', '')/\",\n\t      \\\t\t\t\t['f', 'f']],\n\t      \\ ['gGg', 's/G/\\=substitute(submatch(0), \".\", \"\\<C-V>\\<C-J>\", \"\")/',\n\t      \\\t\t\t\t[\"g\\<C-V>\", 'g']],\n\t      \\ ['hHh', 's/H/\\=substitute(submatch(0), \".\", \"\\\\\\<C-V>\\<C-J>\", \"\")/',\n\t      \\\t\t\t\t[\"h\\<C-V>\", 'h']],\n\t      \\ ['iIi', 's/I/\\=substitute(submatch(0), \".\", \"\\\\\\\\\\<C-V>\\<C-J>\", \"\")/',\n\t      \\\t\t\t\t[\"i\\\\\\<C-V>\", 'i']],\n\t      \\ ['jJj', \"s/J/\\\\=substitute(submatch(0), '.', '\\\\n', '')/\",\n\t      \\\t\t\t\t['j', 'j']],\n\t      \\ ['kKk', \"s/K/\\\\=substitute(submatch(0), '.', '\\\\r', '')/\",\n\t      \\\t\t\t\t['k', 'k']],\n\t      \\ ['lLl', \"s/L/\\\\=substitute(submatch(0), '.', '\\\\n', '')/\",\n\t      \\\t\t\t\t['l', 'l']],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\nfunc Test_sub_cmd_5()\n  set magic&\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [ ['A123456789', 's/A\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)/\\=submatch(0) . submatch(9) . submatch(8) . submatch(7) . submatch(6) . submatch(5) . submatch(4) . submatch(3) . submatch(2) . submatch(1)/', ['A123456789987654321']],\n\t      \\ ['B123456789', 's/B\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)/\\=string([submatch(0, 1), submatch(9, 1), submatch(8, 1), submatch(7, 1), submatch(6, 1), submatch(5, 1), submatch(4, 1), submatch(3, 1), submatch(2, 1), submatch(1, 1)])/', [\"[['B123456789'], ['9'], ['8'], ['7'], ['6'], ['5'], ['4'], ['3'], ['2'], ['1']]\"]],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\n\" Test for *:s%* on :substitute.\nfunc Test_sub_cmd_6()\n  set magic&\n  set cpo+=/\n\n  \" List entry format: [input, cmd, output]\n  let tests = [ ['A', 's/A/a/', ['a']],\n\t      \\ ['B', 's/B/%/', ['a']],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\n\n  set cpo-=/\n  let tests = [ ['C', 's/C/c/', ['c']],\n\t      \\ ['D', 's/D/%/', ['%']],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\n\n  set cpo&\nendfunc\n\n\" Test for :s replacing \\n with  line break.\nfunc Test_sub_cmd_7()\n  set magic&\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [ [\"A\\<C-V>\\<C-M>A\", 's/A./\\=submatch(0)/', ['A', 'A']],\n\t      \\ [\"B\\<C-V>\\<C-J>B\", 's/B./\\=submatch(0)/', ['B', 'B']],\n\t      \\ [\"C\\<C-V>\\<C-J>C\", 's/C./\\=strtrans(string(submatch(0, 1)))/', [strtrans(\"['C\\<C-J>']C\")]],\n\t      \\ [\"D\\<C-V>\\<C-J>\\nD\", 's/D.\\nD/\\=strtrans(string(submatch(0, 1)))/', [strtrans(\"['D\\<C-J>', 'D']\")]],\n\t      \\ [\"E\\<C-V>\\<C-J>\\n\\<C-V>\\<C-J>\\n\\<C-V>\\<C-J>\\n\\<C-V>\\<C-J>\\n\\<C-V>\\<C-J>E\", 's/E\\_.\\{-}E/\\=strtrans(string(submatch(0, 1)))/', [strtrans(\"['E\\<C-J>', '\\<C-J>', '\\<C-J>', '\\<C-J>', '\\<C-J>E']\")]],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\n\n  exe \"normal oQ\\nQ\\<Esc>k\"\n  call assert_fails('s/Q[^\\n]Q/\\=submatch(0).\"foobar\"/', 'E486:')\n  enew!\nendfunc\n\nfunc TitleString()\n  let check = 'foo' =~ 'bar'\n  return \"\"\nendfunc\n\nfunc Test_sub_cmd_8()\n  set titlestring=%{TitleString()}\n\n  enew!\n  call append(0, ['', 'test_one', 'test_two'])\n  call cursor(1,1)\n  /^test_one/s/.*/\\=\"foo\\nbar\"/\n  call assert_equal('foo', getline(2))\n  call assert_equal('bar', getline(3))\n  call feedkeys(':/^test_two/s/.*/\\=\"foo\\nbar\"/c', \"t\")\n  call feedkeys(\"\\<CR>y\", \"xt\")\n  call assert_equal('foo', getline(4))\n  call assert_equal('bar', getline(5))\n\n  enew!\n  set titlestring&\nendfunc\n\nfunc Test_sub_cmd_9()\n  new\n  let input = ['1 aaa', '2 aaa', '3 aaa']\n  call setline(1, input)\n  func Foo()\n    return submatch(0)\n  endfunc\n  %s/aaa/\\=Foo()/gn\n  call assert_equal(input, getline(1, '$'))\n  call assert_equal(1, &modifiable)\n\n  delfunc Foo\n  bw!\nendfunc\n\nfunc Test_nocatch_sub_failure_handling()\n  \" normal error results in all replacements \n  func Foo()\n    foobar\n  endfunc\n  new\n  call setline(1, ['1 aaa', '2 aaa', '3 aaa'])\n  %s/aaa/\\=Foo()/g\n  call assert_equal(['1 0', '2 0', '3 0'], getline(1, 3))\n\n  \" Trow without try-catch causes abort after the first line.\n  \" We cannot test this, since it would stop executing the test script.\n\n  \" try/catch does not result in any changes\n  func! Foo()\n    throw 'error'\n  endfunc\n  call setline(1, ['1 aaa', '2 aaa', '3 aaa'])\n  let error_caught = 0\n  try\n    %s/aaa/\\=Foo()/g\n  catch\n    let error_caught = 1\n  endtry\n  call assert_equal(1, error_caught)\n  call assert_equal(['1 aaa', '2 aaa', '3 aaa'], getline(1, 3))\n\n  \" Same, but using \"n\" flag so that \"sandbox\" gets set\n  call setline(1, ['1 aaa', '2 aaa', '3 aaa'])\n  let error_caught = 0\n  try\n    %s/aaa/\\=Foo()/gn\n  catch\n    let error_caught = 1\n  endtry\n  call assert_equal(1, error_caught)\n  call assert_equal(['1 aaa', '2 aaa', '3 aaa'], getline(1, 3))\n\n  delfunc Foo\n  bwipe!\nendfunc\n\n\" Test \":s/pat/sub/\" with different ~s in sub.\nfunc Test_replace_with_tilde()\n  new\n  \" Set the last replace string to empty\n  s/^$//\n  call append(0, ['- Bug in \"vPPPP\" on this text:'])\n  normal gg\n  s/u/~u~/\n  call assert_equal('- Bug in \"vPPPP\" on this text:', getline(1))\n  s/i/~u~/\n  call assert_equal('- Bug uuun \"vPPPP\" on this text:', getline(1))\n  s/o/~~~/\n  call assert_equal('- Bug uuun \"vPPPP\" uuuuuuuuun this text:', getline(1))\n  close!\nendfunc\n\nfunc Test_replace_keeppatterns()\n  new\n  a\nfoobar\n\nsubstitute foo asdf\n\none two\n.\n\n  normal gg\n  /^substitute\n  s/foo/bar/\n  call assert_equal('foo', @/)\n  call assert_equal('substitute bar asdf', getline('.'))\n\n  /^substitute\n  keeppatterns s/asdf/xyz/\n  call assert_equal('^substitute', @/)\n  call assert_equal('substitute bar xyz', getline('.'))\n\n  exe \"normal /bar /e\\<CR>\"\n  call assert_equal(15, col('.'))\n  normal -\n  keeppatterns /xyz\n  call assert_equal('bar ', @/)\n  call assert_equal('substitute bar xyz', getline('.'))\n  exe \"normal 0dn\"\n  call assert_equal('xyz', getline('.'))\n\n  close!\nendfunc\n\nfunc Test_sub_beyond_end()\n  new\n  call setline(1, '#')\n  let @/ = '^#\\n\\zs'\n  s///e\n  call assert_equal('#', getline(1))\n  bwipe!\nendfunc\n\n\" Test for repeating last substitution using :~ and :&r\nfunc Test_repeat_last_sub()\n  new\n  call setline(1, ['blue green yellow orange white'])\n  s/blue/red/\n  let @/ = 'yellow'\n  ~\n  let @/ = 'white'\n  :&r\n  let @/ = 'green'\n  s//gray\n  call assert_equal('red gray red orange red', getline(1))\n  close!\nendfunc\n\n\" Test for Vi compatible substitution:\n\"     \\/{string}/, \\?{string}? and \\&{string}&\nfunc Test_sub_vi_compatibility()\n  new\n  call setline(1, ['blue green yellow orange blue'])\n  let @/ = 'orange'\n  s\\/white/\n  let @/ = 'blue'\n  s\\?amber?\n  let @/ = 'white'\n  s\\&green&\n  call assert_equal('amber green yellow white green', getline(1))\n  close!\n\n  call assert_fails('vim9cmd s\\/white/', 'E1270:')\n  call assert_fails('vim9cmd s\\?white?', 'E1270:')\n  call assert_fails('vim9cmd s\\&white&', 'E1270:')\nendfunc\n\n\" Test for substitute with the new text longer than the original text\nfunc Test_sub_expand_text()\n  new\n  call setline(1, 'abcabcabcabcabcabcabcabc')\n  s/b/\\=repeat('B', 10)/g\n  call assert_equal(repeat('aBBBBBBBBBBc', 8), getline(1))\n  close!\nendfunc\n\n\" Test for command failures when the last substitute pattern is not set.\nfunc Test_sub_with_no_last_pat()\n  let lines =<< trim [SCRIPT]\n    call assert_fails('~', 'E33:')\n    call assert_fails('s//abc/g', 'E35:')\n    call assert_fails('s\\/bar', 'E35:')\n    call assert_fails('s\\&bar&', 'E33:')\n    call writefile(v:errors, 'Xresult')\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript')\n  if RunVim([], [], '--clean -S Xscript')\n    call assert_equal([], readfile('Xresult'))\n  endif\n\n  let lines =<< trim [SCRIPT]\n    set cpo+=/\n    call assert_fails('s/abc/%/', 'E33:')\n    call writefile(v:errors, 'Xresult')\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript')\n  if RunVim([], [], '--clean -S Xscript')\n    call assert_equal([], readfile('Xresult'))\n  endif\n\n  call delete('Xscript')\n  call delete('Xresult')\nendfunc\n\nfunc Test_substitute()\n  call assert_equal('a\uff11a\uff12a\uff13a', substitute('\uff11\uff12\uff13', '\\zs', 'a', 'g'))\n  \" Substitute with special keys\n  call assert_equal(\"a\\<End>c\", substitute('abc', \"a.c\", \"a\\<End>c\", ''))\nendfunc\n\nfunc Test_substitute_expr()\n  let g:val = 'XXX'\n  call assert_equal('XXX', substitute('yyy', 'y*', '\\=g:val', ''))\n  call assert_equal('XXX', substitute('yyy', 'y*', {-> g:val}, ''))\n  call assert_equal(\"-\\u1b \\uf2-\", substitute(\"-%1b %f2-\", '%\\(\\x\\x\\)',\n\t\t\t   \\ '\\=nr2char(\"0x\" . submatch(1))', 'g'))\n  call assert_equal(\"-\\u1b \\uf2-\", substitute(\"-%1b %f2-\", '%\\(\\x\\x\\)',\n\t\t\t   \\ {-> nr2char(\"0x\" . submatch(1))}, 'g'))\n\n  call assert_equal('231', substitute('123', '\\(.\\)\\(.\\)\\(.\\)',\n\t\\ {-> submatch(2) . submatch(3) . submatch(1)}, ''))\n\n  func Recurse()\n    return substitute('yyy', 'y\\(.\\)y', {-> submatch(1)}, '')\n  endfunc\n  \" recursive call works\n  call assert_equal('-y-x-', substitute('xxx', 'x\\(.\\)x', {-> '-' . Recurse() . '-' . submatch(1) . '-'}, ''))\n\n  call assert_fails(\"let s=submatch([])\", 'E745:')\n  call assert_fails(\"let s=submatch(2, [])\", 'E745:')\nendfunc\n\nfunc Test_invalid_submatch()\n  \" This was causing invalid memory access in Vim-7.4.2232 and older\n  call assert_fails(\"call substitute('x', '.', {-> submatch(10)}, '')\", 'E935:')\n  call assert_fails('eval submatch(-1)', 'E935:')\n  call assert_equal('', submatch(0))\n  call assert_equal('', submatch(1))\n  call assert_equal([], submatch(0, 1))\n  call assert_equal([], submatch(1, 1))\nendfunc\n\nfunc Test_submatch_list_concatenate()\n  let pat = 'A\\(.\\)'\n  let Rep = {-> string([submatch(0, 1)] + [[submatch(1)]])}\n  call substitute('A1', pat, Rep, '')->assert_equal(\"[['A1'], ['1']]\")\nendfunc\n\nfunc Test_substitute_expr_arg()\n  call assert_equal('123456789-123456789=', substitute('123456789',\n\t\\ '\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)',\n\t\\ {m -> m[0] . '-' . m[1] . m[2] . m[3] . m[4] . m[5] . m[6] . m[7] . m[8] . m[9] . '='}, ''))\n\n  call assert_equal('123456-123456=789', substitute('123456789',\n\t\\ '\\(.\\)\\(.\\)\\(.\\)\\(a*\\)\\(n*\\)\\(.\\)\\(.\\)\\(.\\)\\(x*\\)',\n\t\\ {m -> m[0] . '-' . m[1] . m[2] . m[3] . m[4] . m[5] . m[6] . m[7] . m[8] . m[9] . '='}, ''))\n\n  call assert_equal('123456789-123456789x=', substitute('123456789',\n\t\\ '\\(.\\)\\(.\\)\\(.*\\)',\n\t\\ {m -> m[0] . '-' . m[1] . m[2] . m[3] . 'x' . m[4] . m[5] . m[6] . m[7] . m[8] . m[9] . '='}, ''))\n\n  call assert_fails(\"call substitute('xxx', '.', {m -> string(add(m, 'x'))}, '')\", 'E742:')\n  call assert_fails(\"call substitute('xxx', '.', {m -> string(insert(m, 'x'))}, '')\", 'E742:')\n  call assert_fails(\"call substitute('xxx', '.', {m -> string(extend(m, ['x']))}, '')\", 'E742:')\n  call assert_fails(\"call substitute('xxx', '.', {m -> string(remove(m, 1))}, '')\", 'E742:')\nendfunc\n\n\" Test for using a function to supply the substitute string\nfunc Test_substitute_using_func()\n  func Xfunc()\n    return '1234'\n  endfunc\n  call assert_equal('a1234f', substitute('abcdef', 'b..e',\n        \\ function(\"Xfunc\"), ''))\n  delfunc Xfunc\nendfunc\n\n\" Test for using submatch() with a multiline match\nfunc Test_substitute_multiline_submatch()\n  new\n  call setline(1, ['line1', 'line2', 'line3', 'line4'])\n  %s/^line1\\(\\_.\\+\\)line4$/\\=submatch(1)/\n  call assert_equal(['', 'line2', 'line3', ''], getline(1, '$'))\n  close!\nendfunc\n\nfunc Test_substitute_skipped_range()\n  new\n  if 0\n    /1/5/2/2/\\n\n  endif\n  call assert_equal([0, 1, 1, 0, 1], getcurpos())\n  bwipe!\nendfunc\n\n\" Test using the 'gdefault' option (when on, flag 'g' is default on).\nfunc Test_substitute_gdefault()\n  new\n\n  \" First check without 'gdefault'\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/\n  call assert_equal('FOO bar foo', getline(1))\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/g\n  call assert_equal('FOO bar FOO', getline(1))\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/gg\n  call assert_equal('FOO bar foo', getline(1))\n\n  \" Then check with 'gdefault'\n  set gdefault\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/\n  call assert_equal('FOO bar FOO', getline(1))\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/g\n  call assert_equal('FOO bar foo', getline(1))\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/gg\n  call assert_equal('FOO bar FOO', getline(1))\n\n  \" Setting 'compatible' should reset 'gdefault'\n  call assert_equal(1, &gdefault)\n  set compatible\n  call assert_equal(0, &gdefault)\n  set nocompatible\n  call assert_equal(0, &gdefault)\n\n  bw!\nendfunc\n\n\" This was using \"old_sub\" after it was freed.\nfunc Test_using_old_sub()\n  set compatible maxfuncdepth=10\n  new\n  call setline(1, 'some text.')\n  func Repl()\n    ~\n    s/\n  endfunc\n  silent!  s/\\%')/\\=Repl()\n\n  delfunc Repl\n  bwipe!\n  set nocompatible\nendfunc\n\n\" This was switching windows in between computing the length and using it.\nfunc Test_sub_change_window()\n  silent! lfile\n  sil! norm o0000000000000000000000000000000000000000000000000000\n  func Repl()\n    lopen\n  endfunc\n  silent!  s/\\%')/\\=Repl()\n  bwipe!\n  bwipe!\n  delfunc Repl\nendfunc\n\n\" This was undoign a change in between computing the length and using it.\nfunc Do_Test_sub_undo_change()\n  new\n  norm o0000000000000000000000000000000000000000000000000000\n  silent! s/\\%')/\\=Repl()\n  bwipe!\nendfunc\n\nfunc Test_sub_undo_change()\n  func Repl()\n    silent! norm g-\n  endfunc\n  call Do_Test_sub_undo_change()\n\n  func! Repl()\n    silent earlier\n  endfunc\n  call Do_Test_sub_undo_change()\n\n  delfunc Repl\nendfunc\n\n\" Test for the 2-letter and 3-letter :substitute commands\nfunc Test_substitute_short_cmd()\n  new\n  call setline(1, ['one', 'one one one'])\n  s/one/two\n  call cursor(2, 1)\n\n  \" :sc\n  call feedkeys(\":sc\\<CR>y\", 'xt')\n  call assert_equal('two one one', getline(2))\n\n  \" :scg\n  call setline(2, 'one one one')\n  call feedkeys(\":scg\\<CR>nyq\", 'xt')\n  call assert_equal('one two one', getline(2))\n\n  \" :sci\n  call setline(2, 'ONE One onE')\n  call feedkeys(\":sci\\<CR>y\", 'xt')\n  call assert_equal('two One onE', getline(2))\n\n  \" :scI\n  set ignorecase\n  call setline(2, 'ONE One one')\n  call feedkeys(\":scI\\<CR>y\", 'xt')\n  call assert_equal('ONE One two', getline(2))\n  set ignorecase&\n\n  \" :scn\n  call setline(2, 'one one one')\n  let t = execute('scn')->split(\"\\n\")\n  call assert_equal(['1 match on 1 line'], t)\n  call assert_equal('one one one', getline(2))\n\n  \" :scp\n  call setline(2, \"\\tone one one\")\n  redir => output\n  call feedkeys(\":scp\\<CR>y\", 'xt')\n  redir END\n  call assert_equal('        two one one', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo one one\", getline(2))\n\n  \" :scl\n  call setline(2, \"\\tone one one\")\n  redir => output\n  call feedkeys(\":scl\\<CR>y\", 'xt')\n  redir END\n  call assert_equal(\"^Itwo one one$\", output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo one one\", getline(2))\n\n  \" :sgc\n  call setline(2, 'one one one one one')\n  call feedkeys(\":sgc\\<CR>nyyq\", 'xt')\n  call assert_equal('one two two one one', getline(2))\n\n  \" :sg\n  call setline(2, 'one one one')\n  sg\n  call assert_equal('two two two', getline(2))\n\n  \" :sgi\n  call setline(2, 'ONE One onE')\n  sgi\n  call assert_equal('two two two', getline(2))\n\n  \" :sgI\n  set ignorecase\n  call setline(2, 'ONE One one')\n  sgI\n  call assert_equal('ONE One two', getline(2))\n  set ignorecase&\n\n  \" :sgn\n  call setline(2, 'one one one')\n  let t = execute('sgn')->split(\"\\n\")\n  call assert_equal(['3 matches on 1 line'], t)\n  call assert_equal('one one one', getline(2))\n\n  \" :sgp\n  call setline(2, \"\\tone one one\")\n  redir => output\n  sgp\n  redir END\n  call assert_equal('        two two two', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo two two\", getline(2))\n\n  \" :sgl\n  call setline(2, \"\\tone one one\")\n  redir => output\n  sgl\n  redir END\n  call assert_equal(\"^Itwo two two$\", output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo two two\", getline(2))\n\n  \" :sgr\n  call setline(2, \"one one one\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sgr\n  call assert_equal('xyz xyz xyz', getline(2))\n\n  \" :sic\n  call cursor(1, 1)\n  s/one/two/e\n  call setline(2, \"ONE One one\")\n  call cursor(2, 1)\n  call feedkeys(\":sic\\<CR>y\", 'xt')\n  call assert_equal('two One one', getline(2))\n\n  \" :si\n  call setline(2, \"ONE One one\")\n  si\n  call assert_equal('two One one', getline(2))\n\n  \" :siI\n  call setline(2, \"ONE One one\")\n  siI\n  call assert_equal('ONE One two', getline(2))\n\n  \" :sin\n  call setline(2, 'ONE One onE')\n  let t = execute('sin')->split(\"\\n\")\n  call assert_equal(['1 match on 1 line'], t)\n  call assert_equal('ONE One onE', getline(2))\n\n  \" :sip\n  call setline(2, \"\\tONE One onE\")\n  redir => output\n  sip\n  redir END\n  call assert_equal('        two One onE', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo One onE\", getline(2))\n\n  \" :sir\n  call setline(2, \"ONE One onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sir\n  call assert_equal('xyz One onE', getline(2))\n\n  \" :sIc\n  call cursor(1, 1)\n  s/one/two/e\n  call setline(2, \"ONE One one\")\n  call cursor(2, 1)\n  call feedkeys(\":sIc\\<CR>y\", 'xt')\n  call assert_equal('ONE One two', getline(2))\n\n  \" :sIg\n  call setline(2, \"ONE one onE one\")\n  sIg\n  call assert_equal('ONE two onE two', getline(2))\n\n  \" :sIi\n  call setline(2, \"ONE One one\")\n  sIi\n  call assert_equal('two One one', getline(2))\n\n  \" :sI\n  call setline(2, \"ONE One one\")\n  sI\n  call assert_equal('ONE One two', getline(2))\n\n  \" :sIn\n  call setline(2, 'ONE One one')\n  let t = execute('sIn')->split(\"\\n\")\n  call assert_equal(['1 match on 1 line'], t)\n  call assert_equal('ONE One one', getline(2))\n\n  \" :sIp\n  call setline(2, \"\\tONE One one\")\n  redir => output\n  sIp\n  redir END\n  call assert_equal('        ONE One two', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\tONE One two\", getline(2))\n\n  \" :sIl\n  call setline(2, \"\\tONE onE one\")\n  redir => output\n  sIl\n  redir END\n  call assert_equal(\"^IONE onE two$\", output->split(\"\\n\")[-1])\n  call assert_equal(\"\\tONE onE two\", getline(2))\n\n  \" :sIr\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sIr\n  call assert_equal('ONE xyz onE', getline(2))\n\n  \" :src\n  call setline(2, \"ONE one one\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  call feedkeys(\":src\\<CR>y\", 'xt')\n  call assert_equal('ONE xyz one', getline(2))\n\n  \" :srg\n  call setline(2, \"one one one\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  srg\n  call assert_equal('xyz xyz xyz', getline(2))\n\n  \" :sri\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sri\n  call assert_equal('xyz one onE', getline(2))\n\n  \" :srI\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  srI\n  call assert_equal('ONE xyz onE', getline(2))\n\n  \" :srn\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  let t = execute('srn')->split(\"\\n\")\n  call assert_equal(['1 match on 1 line'], t)\n  call assert_equal('ONE one onE', getline(2))\n\n  \" :srp\n  call setline(2, \"\\tONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  redir => output\n  srp\n  redir END\n  call assert_equal('        ONE xyz onE', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\tONE xyz onE\", getline(2))\n\n  \" :srl\n  call setline(2, \"\\tONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  redir => output\n  srl\n  redir END\n  call assert_equal(\"^IONE xyz onE$\", output->split(\"\\n\")[-1])\n  call assert_equal(\"\\tONE xyz onE\", getline(2))\n\n  \" :sr\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sr\n  call assert_equal('ONE xyz onE', getline(2))\n\n  \" :sce\n  s/abc/xyz/e\n  call assert_fails(\"sc\", 'E486:')\n  sce\n  \" :sge\n  call assert_fails(\"sg\", 'E486:')\n  sge\n  \" :sie\n  call assert_fails(\"si\", 'E486:')\n  sie\n  \" :sIe\n  call assert_fails(\"sI\", 'E486:')\n  sIe\n\n  bw!\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    5042,\n/**/\n    5041,\n/**/\n    5040,\n/**/\n    5039,\n/**/\n    5038,\n/**/\n    5037,\n/**/\n    5036,\n/**/\n    5035,\n/**/\n    5034,\n/**/\n    5033,\n/**/\n    5032,\n/**/\n    5031,\n/**/\n    5030,\n/**/\n    5029,\n/**/\n    5028,\n/**/\n    5027,\n/**/\n    5026,\n/**/\n    5025,\n/**/\n    5024,\n/**/\n    5023,\n/**/\n    5022,\n/**/\n    5021,\n/**/\n    5020,\n/**/\n    5019,\n/**/\n    5018,\n/**/\n    5017,\n/**/\n    5016,\n/**/\n    5015,\n/**/\n    5014,\n/**/\n    5013,\n/**/\n    5012,\n/**/\n    5011,\n/**/\n    5010,\n/**/\n    5009,\n/**/\n    5008,\n/**/\n    5007,\n/**/\n    5006,\n/**/\n    5005,\n/**/\n    5004,\n/**/\n    5003,\n/**/\n    5002,\n/**/\n    5001,\n/**/\n    5000,\n/**/\n    4999,\n/**/\n    4998,\n/**/\n    4997,\n/**/\n    4996,\n/**/\n    4995,\n/**/\n    4994,\n/**/\n    4993,\n/**/\n    4992,\n/**/\n    4991,\n/**/\n    4990,\n/**/\n    4989,\n/**/\n    4988,\n/**/\n    4987,\n/**/\n    4986,\n/**/\n    4985,\n/**/\n    4984,\n/**/\n    4983,\n/**/\n    4982,\n/**/\n    4981,\n/**/\n    4980,\n/**/\n    4979,\n/**/\n    4978,\n/**/\n    4977,\n/**/\n    4976,\n/**/\n    4975,\n/**/\n    4974,\n/**/\n    4973,\n/**/\n    4972,\n/**/\n    4971,\n/**/\n    4970,\n/**/\n    4969,\n/**/\n    4968,\n/**/\n    4967,\n/**/\n    4966,\n/**/\n    4965,\n/**/\n    4964,\n/**/\n    4963,\n/**/\n    4962,\n/**/\n    4961,\n/**/\n    4960,\n/**/\n    4959,\n/**/\n    4958,\n/**/\n    4957,\n/**/\n    4956,\n/**/\n    4955,\n/**/\n    4954,\n/**/\n    4953,\n/**/\n    4952,\n/**/\n    4951,\n/**/\n    4950,\n/**/\n    4949,\n/**/\n    4948,\n/**/\n    4947,\n/**/\n    4946,\n/**/\n    4945,\n/**/\n    4944,\n/**/\n    4943,\n/**/\n    4942,\n/**/\n    4941,\n/**/\n    4940,\n/**/\n    4939,\n/**/\n    4938,\n/**/\n    4937,\n/**/\n    4936,\n/**/\n    4935,\n/**/\n    4934,\n/**/\n    4933,\n/**/\n    4932,\n/**/\n    4931,\n/**/\n    4930,\n/**/\n    4929,\n/**/\n    4928,\n/**/\n    4927,\n/**/\n    4926,\n/**/\n    4925,\n/**/\n    4924,\n/**/\n    4923,\n/**/\n    4922,\n/**/\n    4921,\n/**/\n    4920,\n/**/\n    4919,\n/**/\n    4918,\n/**/\n    4917,\n/**/\n    4916,\n/**/\n    4915,\n/**/\n    4914,\n/**/\n    4913,\n/**/\n    4912,\n/**/\n    4911,\n/**/\n    4910,\n/**/\n    4909,\n/**/\n    4908,\n/**/\n    4907,\n/**/\n    4906,\n/**/\n    4905,\n/**/\n    4904,\n/**/\n    4903,\n/**/\n    4902,\n/**/\n    4901,\n/**/\n    4900,\n/**/\n    4899,\n/**/\n    4898,\n/**/\n    4897,\n/**/\n    4896,\n/**/\n    4895,\n/**/\n    4894,\n/**/\n    4893,\n/**/\n    4892,\n/**/\n    4891,\n/**/\n    4890,\n/**/\n    4889,\n/**/\n    4888,\n/**/\n    4887,\n/**/\n    4886,\n/**/\n    4885,\n/**/\n    4884,\n/**/\n    4883,\n/**/\n    4882,\n/**/\n    4881,\n/**/\n    4880,\n/**/\n    4879,\n/**/\n    4878,\n/**/\n    4877,\n/**/\n    4876,\n/**/\n    4875,\n/**/\n    4874,\n/**/\n    4873,\n/**/\n    4872,\n/**/\n    4871,\n/**/\n    4870,\n/**/\n    4869,\n/**/\n    4868,\n/**/\n    4867,\n/**/\n    4866,\n/**/\n    4865,\n/**/\n    4864,\n/**/\n    4863,\n/**/\n    4862,\n/**/\n    4861,\n/**/\n    4860,\n/**/\n    4859,\n/**/\n    4858,\n/**/\n    4857,\n/**/\n    4856,\n/**/\n    4855,\n/**/\n    4854,\n/**/\n    4853,\n/**/\n    4852,\n/**/\n    4851,\n/**/\n    4850,\n/**/\n    4849,\n/**/\n    4848,\n/**/\n    4847,\n/**/\n    4846,\n/**/\n    4845,\n/**/\n    4844,\n/**/\n    4843,\n/**/\n    4842,\n/**/\n    4841,\n/**/\n    4840,\n/**/\n    4839,\n/**/\n    4838,\n/**/\n    4837,\n/**/\n    4836,\n/**/\n    4835,\n/**/\n    4834,\n/**/\n    4833,\n/**/\n    4832,\n/**/\n    4831,\n/**/\n    4830,\n/**/\n    4829,\n/**/\n    4828,\n/**/\n    4827,\n/**/\n    4826,\n/**/\n    4825,\n/**/\n    4824,\n/**/\n    4823,\n/**/\n    4822,\n/**/\n    4821,\n/**/\n    4820,\n/**/\n    4819,\n/**/\n    4818,\n/**/\n    4817,\n/**/\n    4816,\n/**/\n    4815,\n/**/\n    4814,\n/**/\n    4813,\n/**/\n    4812,\n/**/\n    4811,\n/**/\n    4810,\n/**/\n    4809,\n/**/\n    4808,\n/**/\n    4807,\n/**/\n    4806,\n/**/\n    4805,\n/**/\n    4804,\n/**/\n    4803,\n/**/\n    4802,\n/**/\n    4801,\n/**/\n    4800,\n/**/\n    4799,\n/**/\n    4798,\n/**/\n    4797,\n/**/\n    4796,\n/**/\n    4795,\n/**/\n    4794,\n/**/\n    4793,\n/**/\n    4792,\n/**/\n    4791,\n/**/\n    4790,\n/**/\n    4789,\n/**/\n    4788,\n/**/\n    4787,\n/**/\n    4786,\n/**/\n    4785,\n/**/\n    4784,\n/**/\n    4783,\n/**/\n    4782,\n/**/\n    4781,\n/**/\n    4780,\n/**/\n    4779,\n/**/\n    4778,\n/**/\n    4777,\n/**/\n    4776,\n/**/\n    4775,\n/**/\n    4774,\n/**/\n    4773,\n/**/\n    4772,\n/**/\n    4771,\n/**/\n    4770,\n/**/\n    4769,\n/**/\n    4768,\n/**/\n    4767,\n/**/\n    4766,\n/**/\n    4765,\n/**/\n    4764,\n/**/\n    4763,\n/**/\n    4762,\n/**/\n    4761,\n/**/\n    4760,\n/**/\n    4759,\n/**/\n    4758,\n/**/\n    4757,\n/**/\n    4756,\n/**/\n    4755,\n/**/\n    4754,\n/**/\n    4753,\n/**/\n    4752,\n/**/\n    4751,\n/**/\n    4750,\n/**/\n    4749,\n/**/\n    4748,\n/**/\n    4747,\n/**/\n    4746,\n/**/\n    4745,\n/**/\n    4744,\n/**/\n    4743,\n/**/\n    4742,\n/**/\n    4741,\n/**/\n    4740,\n/**/\n    4739,\n/**/\n    4738,\n/**/\n    4737,\n/**/\n    4736,\n/**/\n    4735,\n/**/\n    4734,\n/**/\n    4733,\n/**/\n    4732,\n/**/\n    4731,\n/**/\n    4730,\n/**/\n    4729,\n/**/\n    4728,\n/**/\n    4727,\n/**/\n    4726,\n/**/\n    4725,\n/**/\n    4724,\n/**/\n    4723,\n/**/\n    4722,\n/**/\n    4721,\n/**/\n    4720,\n/**/\n    4719,\n/**/\n    4718,\n/**/\n    4717,\n/**/\n    4716,\n/**/\n    4715,\n/**/\n    4714,\n/**/\n    4713,\n/**/\n    4712,\n/**/\n    4711,\n/**/\n    4710,\n/**/\n    4709,\n/**/\n    4708,\n/**/\n    4707,\n/**/\n    4706,\n/**/\n    4705,\n/**/\n    4704,\n/**/\n    4703,\n/**/\n    4702,\n/**/\n    4701,\n/**/\n    4700,\n/**/\n    4699,\n/**/\n    4698,\n/**/\n    4697,\n/**/\n    4696,\n/**/\n    4695,\n/**/\n    4694,\n/**/\n    4693,\n/**/\n    4692,\n/**/\n    4691,\n/**/\n    4690,\n/**/\n    4689,\n/**/\n    4688,\n/**/\n    4687,\n/**/\n    4686,\n/**/\n    4685,\n/**/\n    4684,\n/**/\n    4683,\n/**/\n    4682,\n/**/\n    4681,\n/**/\n    4680,\n/**/\n    4679,\n/**/\n    4678,\n/**/\n    4677,\n/**/\n    4676,\n/**/\n    4675,\n/**/\n    4674,\n/**/\n    4673,\n/**/\n    4672,\n/**/\n    4671,\n/**/\n    4670,\n/**/\n    4669,\n/**/\n    4668,\n/**/\n    4667,\n/**/\n    4666,\n/**/\n    4665,\n/**/\n    4664,\n/**/\n    4663,\n/**/\n    4662,\n/**/\n    4661,\n/**/\n    4660,\n/**/\n    4659,\n/**/\n    4658,\n/**/\n    4657,\n/**/\n    4656,\n/**/\n    4655,\n/**/\n    4654,\n/**/\n    4653,\n/**/\n    4652,\n/**/\n    4651,\n/**/\n    4650,\n/**/\n    4649,\n/**/\n    4648,\n/**/\n    4647,\n/**/\n    4646,\n/**/\n    4645,\n/**/\n    4644,\n/**/\n    4643,\n/**/\n    4642,\n/**/\n    4641,\n/**/\n    4640,\n/**/\n    4639,\n/**/\n    4638,\n/**/\n    4637,\n/**/\n    4636,\n/**/\n    4635,\n/**/\n    4634,\n/**/\n    4633,\n/**/\n    4632,\n/**/\n    4631,\n/**/\n    4630,\n/**/\n    4629,\n/**/\n    4628,\n/**/\n    4627,\n/**/\n    4626,\n/**/\n    4625,\n/**/\n    4624,\n/**/\n    4623,\n/**/\n    4622,\n/**/\n    4621,\n/**/\n    4620,\n/**/\n    4619,\n/**/\n    4618,\n/**/\n    4617,\n/**/\n    4616,\n/**/\n    4615,\n/**/\n    4614,\n/**/\n    4613,\n/**/\n    4612,\n/**/\n    4611,\n/**/\n    4610,\n/**/\n    4609,\n/**/\n    4608,\n/**/\n    4607,\n/**/\n    4606,\n/**/\n    4605,\n/**/\n    4604,\n/**/\n    4603,\n/**/\n    4602,\n/**/\n    4601,\n/**/\n    4600,\n/**/\n    4599,\n/**/\n    4598,\n/**/\n    4597,\n/**/\n    4596,\n/**/\n    4595,\n/**/\n    4594,\n/**/\n    4593,\n/**/\n    4592,\n/**/\n    4591,\n/**/\n    4590,\n/**/\n    4589,\n/**/\n    4588,\n/**/\n    4587,\n/**/\n    4586,\n/**/\n    4585,\n/**/\n    4584,\n/**/\n    4583,\n/**/\n    4582,\n/**/\n    4581,\n/**/\n    4580,\n/**/\n    4579,\n/**/\n    4578,\n/**/\n    4577,\n/**/\n    4576,\n/**/\n    4575,\n/**/\n    4574,\n/**/\n    4573,\n/**/\n    4572,\n/**/\n    4571,\n/**/\n    4570,\n/**/\n    4569,\n/**/\n    4568,\n/**/\n    4567,\n/**/\n    4566,\n/**/\n    4565,\n/**/\n    4564,\n/**/\n    4563,\n/**/\n    4562,\n/**/\n    4561,\n/**/\n    4560,\n/**/\n    4559,\n/**/\n    4558,\n/**/\n    4557,\n/**/\n    4556,\n/**/\n    4555,\n/**/\n    4554,\n/**/\n    4553,\n/**/\n    4552,\n/**/\n    4551,\n/**/\n    4550,\n/**/\n    4549,\n/**/\n    4548,\n/**/\n    4547,\n/**/\n    4546,\n/**/\n    4545,\n/**/\n    4544,\n/**/\n    4543,\n/**/\n    4542,\n/**/\n    4541,\n/**/\n    4540,\n/**/\n    4539,\n/**/\n    4538,\n/**/\n    4537,\n/**/\n    4536,\n/**/\n    4535,\n/**/\n    4534,\n/**/\n    4533,\n/**/\n    4532,\n/**/\n    4531,\n/**/\n    4530,\n/**/\n    4529,\n/**/\n    4528,\n/**/\n    4527,\n/**/\n    4526,\n/**/\n    4525,\n/**/\n    4524,\n/**/\n    4523,\n/**/\n    4522,\n/**/\n    4521,\n/**/\n    4520,\n/**/\n    4519,\n/**/\n    4518,\n/**/\n    4517,\n/**/\n    4516,\n/**/\n    4515,\n/**/\n    4514,\n/**/\n    4513,\n/**/\n    4512,\n/**/\n    4511,\n/**/\n    4510,\n/**/\n    4509,\n/**/\n    4508,\n/**/\n    4507,\n/**/\n    4506,\n/**/\n    4505,\n/**/\n    4504,\n/**/\n    4503,\n/**/\n    4502,\n/**/\n    4501,\n/**/\n    4500,\n/**/\n    4499,\n/**/\n    4498,\n/**/\n    4497,\n/**/\n    4496,\n/**/\n    4495,\n/**/\n    4494,\n/**/\n    4493,\n/**/\n    4492,\n/**/\n    4491,\n/**/\n    4490,\n/**/\n    4489,\n/**/\n    4488,\n/**/\n    4487,\n/**/\n    4486,\n/**/\n    4485,\n/**/\n    4484,\n/**/\n    4483,\n/**/\n    4482,\n/**/\n    4481,\n/**/\n    4480,\n/**/\n    4479,\n/**/\n    4478,\n/**/\n    4477,\n/**/\n    4476,\n/**/\n    4475,\n/**/\n    4474,\n/**/\n    4473,\n/**/\n    4472,\n/**/\n    4471,\n/**/\n    4470,\n/**/\n    4469,\n/**/\n    4468,\n/**/\n    4467,\n/**/\n    4466,\n/**/\n    4465,\n/**/\n    4464,\n/**/\n    4463,\n/**/\n    4462,\n/**/\n    4461,\n/**/\n    4460,\n/**/\n    4459,\n/**/\n    4458,\n/**/\n    4457,\n/**/\n    4456,\n/**/\n    4455,\n/**/\n    4454,\n/**/\n    4453,\n/**/\n    4452,\n/**/\n    4451,\n/**/\n    4450,\n/**/\n    4449,\n/**/\n    4448,\n/**/\n    4447,\n/**/\n    4446,\n/**/\n    4445,\n/**/\n    4444,\n/**/\n    4443,\n/**/\n    4442,\n/**/\n    4441,\n/**/\n    4440,\n/**/\n    4439,\n/**/\n    4438,\n/**/\n    4437,\n/**/\n    4436,\n/**/\n    4435,\n/**/\n    4434,\n/**/\n    4433,\n/**/\n    4432,\n/**/\n    4431,\n/**/\n    4430,\n/**/\n    4429,\n/**/\n    4428,\n/**/\n    4427,\n/**/\n    4426,\n/**/\n    4425,\n/**/\n    4424,\n/**/\n    4423,\n/**/\n    4422,\n/**/\n    4421,\n/**/\n    4420,\n/**/\n    4419,\n/**/\n    4418,\n/**/\n    4417,\n/**/\n    4416,\n/**/\n    4415,\n/**/\n    4414,\n/**/\n    4413,\n/**/\n    4412,\n/**/\n    4411,\n/**/\n    4410,\n/**/\n    4409,\n/**/\n    4408,\n/**/\n    4407,\n/**/\n    4406,\n/**/\n    4405,\n/**/\n    4404,\n/**/\n    4403,\n/**/\n    4402,\n/**/\n    4401,\n/**/\n    4400,\n/**/\n    4399,\n/**/\n    4398,\n/**/\n    4397,\n/**/\n    4396,\n/**/\n    4395,\n/**/\n    4394,\n/**/\n    4393,\n/**/\n    4392,\n/**/\n    4391,\n/**/\n    4390,\n/**/\n    4389,\n/**/\n    4388,\n/**/\n    4387,\n/**/\n    4386,\n/**/\n    4385,\n/**/\n    4384,\n/**/\n    4383,\n/**/\n    4382,\n/**/\n    4381,\n/**/\n    4380,\n/**/\n    4379,\n/**/\n    4378,\n/**/\n    4377,\n/**/\n    4376,\n/**/\n    4375,\n/**/\n    4374,\n/**/\n    4373,\n/**/\n    4372,\n/**/\n    4371,\n/**/\n    4370,\n/**/\n    4369,\n/**/\n    4368,\n/**/\n    4367,\n/**/\n    4366,\n/**/\n    4365,\n/**/\n    4364,\n/**/\n    4363,\n/**/\n    4362,\n/**/\n    4361,\n/**/\n    4360,\n/**/\n    4359,\n/**/\n    4358,\n/**/\n    4357,\n/**/\n    4356,\n/**/\n    4355,\n/**/\n    4354,\n/**/\n    4353,\n/**/\n    4352,\n/**/\n    4351,\n/**/\n    4350,\n/**/\n    4349,\n/**/\n    4348,\n/**/\n    4347,\n/**/\n    4346,\n/**/\n    4345,\n/**/\n    4344,\n/**/\n    4343,\n/**/\n    4342,\n/**/\n    4341,\n/**/\n    4340,\n/**/\n    4339,\n/**/\n    4338,\n/**/\n    4337,\n/**/\n    4336,\n/**/\n    4335,\n/**/\n    4334,\n/**/\n    4333,\n/**/\n    4332,\n/**/\n    4331,\n/**/\n    4330,\n/**/\n    4329,\n/**/\n    4328,\n/**/\n    4327,\n/**/\n    4326,\n/**/\n    4325,\n/**/\n    4324,\n/**/\n    4323,\n/**/\n    4322,\n/**/\n    4321,\n/**/\n    4320,\n/**/\n    4319,\n/**/\n    4318,\n/**/\n    4317,\n/**/\n    4316,\n/**/\n    4315,\n/**/\n    4314,\n/**/\n    4313,\n/**/\n    4312,\n/**/\n    4311,\n/**/\n    4310,\n/**/\n    4309,\n/**/\n    4308,\n/**/\n    4307,\n/**/\n    4306,\n/**/\n    4305,\n/**/\n    4304,\n/**/\n    4303,\n/**/\n    4302,\n/**/\n    4301,\n/**/\n    4300,\n/**/\n    4299,\n/**/\n    4298,\n/**/\n    4297,\n/**/\n    4296,\n/**/\n    4295,\n/**/\n    4294,\n/**/\n    4293,\n/**/\n    4292,\n/**/\n    4291,\n/**/\n    4290,\n/**/\n    4289,\n/**/\n    4288,\n/**/\n    4287,\n/**/\n    4286,\n/**/\n    4285,\n/**/\n    4284,\n/**/\n    4283,\n/**/\n    4282,\n/**/\n    4281,\n/**/\n    4280,\n/**/\n    4279,\n/**/\n    4278,\n/**/\n    4277,\n/**/\n    4276,\n/**/\n    4275,\n/**/\n    4274,\n/**/\n    4273,\n/**/\n    4272,\n/**/\n    4271,\n/**/\n    4270,\n/**/\n    4269,\n/**/\n    4268,\n/**/\n    4267,\n/**/\n    4266,\n/**/\n    4265,\n/**/\n    4264,\n/**/\n    4263,\n/**/\n    4262,\n/**/\n    4261,\n/**/\n    4260,\n/**/\n    4259,\n/**/\n    4258,\n/**/\n    4257,\n/**/\n    4256,\n/**/\n    4255,\n/**/\n    4254,\n/**/\n    4253,\n/**/\n    4252,\n/**/\n    4251,\n/**/\n    4250,\n/**/\n    4249,\n/**/\n    4248,\n/**/\n    4247,\n/**/\n    4246,\n/**/\n    4245,\n/**/\n    4244,\n/**/\n    4243,\n/**/\n    4242,\n/**/\n    4241,\n/**/\n    4240,\n/**/\n    4239,\n/**/\n    4238,\n/**/\n    4237,\n/**/\n    4236,\n/**/\n    4235,\n/**/\n    4234,\n/**/\n    4233,\n/**/\n    4232,\n/**/\n    4231,\n/**/\n    4230,\n/**/\n    4229,\n/**/\n    4228,\n/**/\n    4227,\n/**/\n    4226,\n/**/\n    4225,\n/**/\n    4224,\n/**/\n    4223,\n/**/\n    4222,\n/**/\n    4221,\n/**/\n    4220,\n/**/\n    4219,\n/**/\n    4218,\n/**/\n    4217,\n/**/\n    4216,\n/**/\n    4215,\n/**/\n    4214,\n/**/\n    4213,\n/**/\n    4212,\n/**/\n    4211,\n/**/\n    4210,\n/**/\n    4209,\n/**/\n    4208,\n/**/\n    4207,\n/**/\n    4206,\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read a list of people who contributed.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\nstatic void cmd_with_count(char *cmd, char_u *bufp, size_t bufsize, long Prenum);\nstatic void win_init(win_T *newp, win_T *oldp, int flags);\nstatic void win_init_some(win_T *newp, win_T *oldp);\nstatic void frame_comp_pos(frame_T *topfrp, int *row, int *col);\nstatic void frame_setheight(frame_T *curfrp, int height);\nstatic void frame_setwidth(frame_T *curfrp, int width);\nstatic void win_exchange(long);\nstatic void win_rotate(int, int);\nstatic void win_totop(int size, int flags);\nstatic void win_equal_rec(win_T *next_curwin, int current, frame_T *topfr, int dir, int col, int row, int width, int height);\nstatic void trigger_winclosed(win_T *win);\nstatic win_T *win_free_mem(win_T *win, int *dirp, tabpage_T *tp);\nstatic frame_T *win_altframe(win_T *win, tabpage_T *tp);\nstatic tabpage_T *alt_tabpage(void);\nstatic win_T *frame2win(frame_T *frp);\nstatic int frame_has_win(frame_T *frp, win_T *wp);\nstatic void frame_new_height(frame_T *topfrp, int height, int topfirst, int wfh);\nstatic int frame_fixed_height(frame_T *frp);\nstatic int frame_fixed_width(frame_T *frp);\nstatic void frame_add_statusline(frame_T *frp);\nstatic void frame_new_width(frame_T *topfrp, int width, int leftfirst, int wfw);\nstatic void frame_add_vsep(frame_T *frp);\nstatic int frame_minwidth(frame_T *topfrp, win_T *next_curwin);\nstatic void frame_fix_width(win_T *wp);\nstatic int win_alloc_firstwin(win_T *oldwin);\nstatic void new_frame(win_T *wp);\nstatic tabpage_T *alloc_tabpage(void);\nstatic int leave_tabpage(buf_T *new_curbuf, int trigger_leave_autocmds);\nstatic void enter_tabpage(tabpage_T *tp, buf_T *old_curbuf, int trigger_enter_autocmds, int trigger_leave_autocmds);\nstatic void frame_fix_height(win_T *wp);\nstatic int frame_minheight(frame_T *topfrp, win_T *next_curwin);\nstatic int may_open_tabpage(void);\nstatic int win_enter_ext(win_T *wp, int flags);\nstatic void win_free(win_T *wp, tabpage_T *tp);\nstatic void win_append(win_T *after, win_T *wp);\nstatic void frame_append(frame_T *after, frame_T *frp);\nstatic void frame_insert(frame_T *before, frame_T *frp);\nstatic void frame_remove(frame_T *frp);\nstatic void win_goto_ver(int up, long count);\nstatic void win_goto_hor(int left, long count);\nstatic void frame_add_height(frame_T *frp, int n);\nstatic void last_status_rec(frame_T *fr, int statusline);\n\nstatic void make_snapshot_rec(frame_T *fr, frame_T **frp);\nstatic void clear_snapshot(tabpage_T *tp, int idx);\nstatic void clear_snapshot_rec(frame_T *fr);\nstatic int check_snapshot_rec(frame_T *sn, frame_T *fr);\nstatic win_T *restore_snapshot_rec(frame_T *sn, frame_T *fr);\nstatic win_T *get_snapshot_curwin(int idx);\n\nstatic int frame_check_height(frame_T *topfrp, int height);\nstatic int frame_check_width(frame_T *topfrp, int width);\n\nstatic win_T *win_alloc(win_T *after, int hidden);\n\n#define NOWIN\t\t((win_T *)-1)\t// non-existing window\n\n#define ROWS_AVAIL (Rows - p_ch - tabline_height())\n\n// flags for win_enter_ext()\n#define WEE_UNDO_SYNC\t\t\t0x01\n#define WEE_CURWIN_INVALID\t\t0x02\n#define WEE_TRIGGER_NEW_AUTOCMDS\t0x04\n#define WEE_TRIGGER_ENTER_AUTOCMDS\t0x08\n#define WEE_TRIGGER_LEAVE_AUTOCMDS\t0x10\n#define WEE_ALLOW_PARSE_MESSAGES\t0x20\n\nstatic char *m_onlyone = N_(\"Already only one window\");\n\n// When non-zero splitting a window is forbidden.  Used to avoid that nasty\n// autocommands mess up the window structure.\nstatic int split_disallowed = 0;\n\n// #define WIN_DEBUG\n#ifdef WIN_DEBUG\n/*\n * Call this method to log the current window layout.\n */\n    static void\nlog_frame_layout(frame_T *frame)\n{\n    ch_log(NULL, \"layout %s, wi: %d, he: %d, wwi: %d, whe: %d, id: %d\",\n\t    frame->fr_layout == FR_LEAF ? \"LEAF\"\n\t\t\t\t  : frame->fr_layout == FR_ROW ? \"ROW\" : \"COL\",\n\t    frame->fr_width,\n\t    frame->fr_height,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_width,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_height,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_id);\n    if (frame->fr_child != NULL)\n    {\n\tch_log(NULL, \"children\");\n\tlog_frame_layout(frame->fr_child);\n\tif (frame->fr_next != NULL)\n\t    ch_log(NULL, \"END of children\");\n    }\n    if (frame->fr_next != NULL)\n\tlog_frame_layout(frame->fr_next);\n}\n#endif\n\n/*\n * Return the current window, unless in the cmdline window and \"prevwin\" is\n * set, then return \"prevwin\".\n */\n    win_T *\nprevwin_curwin(void)\n{\n    return\n#ifdef FEAT_CMDWIN\n\t// In cmdwin, the alternative buffer should be used.\n\tis_in_cmdwin() && prevwin != NULL ? prevwin :\n#endif\n\tcurwin;\n}\n\n/*\n * All CTRL-W window commands are handled here, called from normal_cmd().\n */\n    void\ndo_window(\n    int\t\tnchar,\n    long\tPrenum,\n    int\t\txchar)\t    // extra char from \":wincmd gx\" or NUL\n{\n    long\tPrenum1;\n    win_T\t*wp;\n#if defined(FEAT_SEARCHPATH) || defined(FEAT_FIND_ID)\n    char_u\t*ptr;\n    linenr_T    lnum = -1;\n#endif\n#ifdef FEAT_FIND_ID\n    int\t\ttype = FIND_DEFINE;\n    int\t\tlen;\n#endif\n    char_u\tcbuf[40];\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n#ifdef FEAT_CMDWIN\n# define CHECK_CMDWIN \\\n    do { \\\n\tif (cmdwin_type != 0) \\\n\t{ \\\n\t    emsg(_(e_invalid_in_cmdline_window)); \\\n\t    return; \\\n\t} \\\n    } while (0)\n#else\n# define CHECK_CMDWIN do { /**/ } while (0)\n#endif\n\n    Prenum1 = Prenum == 0 ? 1 : Prenum;\n\n    switch (nchar)\n    {\n// split current window in two parts, horizontally\n    case 'S':\n    case Ctrl_S:\n    case 's':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n#ifdef FEAT_QUICKFIX\n\t\t// When splitting the quickfix window open a new buffer in it,\n\t\t// don't replicate the quickfix buffer.\n\t\tif (bt_quickfix(curbuf))\n\t\t    goto newwindow;\n#endif\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\t(void)win_split((int)Prenum, 0);\n\t\tbreak;\n\n// split current window in two parts, vertically\n    case Ctrl_V:\n    case 'v':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n#ifdef FEAT_QUICKFIX\n\t\t// When splitting the quickfix window open a new buffer in it,\n\t\t// don't replicate the quickfix buffer.\n\t\tif (bt_quickfix(curbuf))\n\t\t    goto newwindow;\n#endif\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\t(void)win_split((int)Prenum, WSP_VERT);\n\t\tbreak;\n\n// split current window and edit alternate file\n    case Ctrl_HAT:\n    case '^':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\n\t\tif (buflist_findnr(Prenum == 0\n\t\t\t\t\t? curwin->w_alt_fnum : Prenum) == NULL)\n\t\t{\n\t\t    if (Prenum == 0)\n\t\t\temsg(_(e_no_alternate_file));\n\t\t    else\n\t\t\tsemsg(_(e_buffer_nr_not_found), Prenum);\n\t\t    break;\n\t\t}\n\n\t\tif (!curbuf_locked() && win_split(0, 0) == OK)\n\t\t    (void)buflist_getfile(\n\t\t\t    Prenum == 0 ? curwin->w_alt_fnum : Prenum,\n\t\t\t    (linenr_T)0, GETF_ALT, FALSE);\n\t\tbreak;\n\n// open new window\n    case Ctrl_N:\n    case 'n':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n#ifdef FEAT_QUICKFIX\nnewwindow:\n#endif\n\t\tif (Prenum)\n\t\t    // window height\n\t\t    vim_snprintf((char *)cbuf, sizeof(cbuf) - 5, \"%ld\", Prenum);\n\t\telse\n\t\t    cbuf[0] = NUL;\n#if defined(FEAT_QUICKFIX)\n\t\tif (nchar == 'v' || nchar == Ctrl_V)\n\t\t    STRCAT(cbuf, \"v\");\n#endif\n\t\tSTRCAT(cbuf, \"new\");\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// quit current window\n    case Ctrl_Q:\n    case 'q':\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"quit\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// close current window\n    case Ctrl_C:\n    case 'c':\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"close\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n#if defined(FEAT_QUICKFIX)\n// close preview window\n    case Ctrl_Z:\n    case 'z':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tdo_cmdline_cmd((char_u *)\"pclose\");\n\t\tbreak;\n\n// cursor to preview window\n    case 'P':\n\t\tFOR_ALL_WINDOWS(wp)\n\t\t    if (wp->w_p_pvw)\n\t\t\tbreak;\n\t\tif (wp == NULL)\n\t\t    emsg(_(e_there_is_no_preview_window));\n\t\telse\n\t\t    win_goto(wp);\n\t\tbreak;\n#endif\n\n// close all but current window\n    case Ctrl_O:\n    case 'o':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"only\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// cursor to next window with wrap around\n    case Ctrl_W:\n    case 'w':\n// cursor to previous window with wrap around\n    case 'W':\n\t\tCHECK_CMDWIN;\n\t\tif (ONE_WINDOW && Prenum != 1)\t// just one window\n\t\t    beep_flush();\n\t\telse\n\t\t{\n\t\t    if (Prenum)\t\t\t// go to specified window\n\t\t    {\n\t\t\tfor (wp = firstwin; --Prenum > 0; )\n\t\t\t{\n\t\t\t    if (wp->w_next == NULL)\n\t\t\t\tbreak;\n\t\t\t    else\n\t\t\t\twp = wp->w_next;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (nchar == 'W')\t    // go to previous window\n\t\t\t{\n\t\t\t    wp = curwin->w_prev;\n\t\t\t    if (wp == NULL)\n\t\t\t\twp = lastwin;\t    // wrap around\n\t\t\t}\n\t\t\telse\t\t\t    // go to next window\n\t\t\t{\n\t\t\t    wp = curwin->w_next;\n\t\t\t    if (wp == NULL)\n\t\t\t\twp = firstwin;\t    // wrap around\n\t\t\t}\n\t\t    }\n\t\t    win_goto(wp);\n\t\t}\n\t\tbreak;\n\n// cursor to window below\n    case 'j':\n    case K_DOWN:\n    case Ctrl_J:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_ver(FALSE, Prenum1);\n\t\tbreak;\n\n// cursor to window above\n    case 'k':\n    case K_UP:\n    case Ctrl_K:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_ver(TRUE, Prenum1);\n\t\tbreak;\n\n// cursor to left window\n    case 'h':\n    case K_LEFT:\n    case Ctrl_H:\n    case K_BS:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_hor(TRUE, Prenum1);\n\t\tbreak;\n\n// cursor to right window\n    case 'l':\n    case K_RIGHT:\n    case Ctrl_L:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_hor(FALSE, Prenum1);\n\t\tbreak;\n\n// move window to new tab page\n    case 'T':\n\t\tCHECK_CMDWIN;\n\t\tif (one_window())\n\t\t    msg(_(m_onlyone));\n\t\telse\n\t\t{\n\t\t    tabpage_T\t*oldtab = curtab;\n\t\t    tabpage_T\t*newtab;\n\n\t\t    // First create a new tab with the window, then go back to\n\t\t    // the old tab and close the window there.\n\t\t    wp = curwin;\n\t\t    if (win_new_tabpage((int)Prenum) == OK\n\t\t\t\t\t\t     && valid_tabpage(oldtab))\n\t\t    {\n\t\t\tnewtab = curtab;\n\t\t\tgoto_tabpage_tp(oldtab, TRUE, TRUE);\n\t\t\tif (curwin == wp)\n\t\t\t    win_close(curwin, FALSE);\n\t\t\tif (valid_tabpage(newtab))\n\t\t\t    goto_tabpage_tp(newtab, TRUE, TRUE);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n// cursor to top-left window\n    case 't':\n    case Ctrl_T:\n\t\twin_goto(firstwin);\n\t\tbreak;\n\n// cursor to bottom-right window\n    case 'b':\n    case Ctrl_B:\n\t\twin_goto(lastwin);\n\t\tbreak;\n\n// cursor to last accessed (previous) window\n    case 'p':\n    case Ctrl_P:\n\t\tif (!win_valid(prevwin))\n\t\t    beep_flush();\n\t\telse\n\t\t    win_goto(prevwin);\n\t\tbreak;\n\n// exchange current and next window\n    case 'x':\n    case Ctrl_X:\n\t\tCHECK_CMDWIN;\n\t\twin_exchange(Prenum);\n\t\tbreak;\n\n// rotate windows downwards\n    case Ctrl_R:\n    case 'r':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\twin_rotate(FALSE, (int)Prenum1);    // downwards\n\t\tbreak;\n\n// rotate windows upwards\n    case 'R':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\twin_rotate(TRUE, (int)Prenum1);\t    // upwards\n\t\tbreak;\n\n// move window to the very top/bottom/left/right\n    case 'K':\n    case 'J':\n    case 'H':\n    case 'L':\n\t\tCHECK_CMDWIN;\n\t\twin_totop((int)Prenum,\n\t\t\t((nchar == 'H' || nchar == 'L') ? WSP_VERT : 0)\n\t\t\t| ((nchar == 'H' || nchar == 'K') ? WSP_TOP : WSP_BOT));\n\t\tbreak;\n\n// make all windows the same height\n    case '=':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_equal(NULL, FALSE, 'b');\n\t\tbreak;\n\n// increase current window height\n    case '+':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(curwin->w_height + (int)Prenum1);\n\t\tbreak;\n\n// decrease current window height\n    case '-':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(curwin->w_height - (int)Prenum1);\n\t\tbreak;\n\n// set current window height\n    case Ctrl__:\n    case '_':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(Prenum ? (int)Prenum : 9999);\n\t\tbreak;\n\n// increase current window width\n    case '>':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(curwin->w_width + (int)Prenum1);\n\t\tbreak;\n\n// decrease current window width\n    case '<':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(curwin->w_width - (int)Prenum1);\n\t\tbreak;\n\n// set current window width\n    case '|':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(Prenum != 0 ? (int)Prenum : 9999);\n\t\tbreak;\n\n// jump to tag and split window if tag exists (in preview window)\n#if defined(FEAT_QUICKFIX)\n    case '}':\n\t\tCHECK_CMDWIN;\n\t\tif (Prenum)\n\t\t    g_do_tagpreview = Prenum;\n\t\telse\n\t\t    g_do_tagpreview = p_pvh;\n#endif\n\t\t// FALLTHROUGH\n    case ']':\n    case Ctrl_RSB:\n\t\tCHECK_CMDWIN;\n\t\t// keep Visual mode, can select words to use as a tag\n\t\tif (Prenum)\n\t\t    postponed_split = Prenum;\n\t\telse\n\t\t    postponed_split = -1;\n#ifdef FEAT_QUICKFIX\n\t\tif (nchar != '}')\n\t\t    g_do_tagpreview = 0;\n#endif\n\n\t\t// Execute the command right here, required when \"wincmd ]\"\n\t\t// was used in a function.\n\t\tdo_nv_ident(Ctrl_RSB, NUL);\n\t\tbreak;\n\n#ifdef FEAT_SEARCHPATH\n// edit file name under cursor in a new window\n    case 'f':\n    case 'F':\n    case Ctrl_F:\nwingotofile:\n\t\tCHECK_CMDWIN;\n\n\t\tptr = grab_file_name(Prenum1, &lnum);\n\t\tif (ptr != NULL)\n\t\t{\n\t\t    tabpage_T\t*oldtab = curtab;\n\t\t    win_T\t*oldwin = curwin;\n# ifdef FEAT_GUI\n\t\t    need_mouse_correct = TRUE;\n# endif\n\t\t    setpcmark();\n\t\t    if (win_split(0, 0) == OK)\n\t\t    {\n\t\t\tRESET_BINDING(curwin);\n\t\t\tif (do_ecmd(0, ptr, NULL, NULL, ECMD_LASTL,\n\t\t\t\t\t\t   ECMD_HIDE, NULL) == FAIL)\n\t\t\t{\n\t\t\t    // Failed to open the file, close the window\n\t\t\t    // opened for it.\n\t\t\t    win_close(curwin, FALSE);\n\t\t\t    goto_tabpage_win(oldtab, oldwin);\n\t\t\t}\n\t\t\telse if (nchar == 'F' && lnum >= 0)\n\t\t\t{\n\t\t\t    curwin->w_cursor.lnum = lnum;\n\t\t\t    check_cursor_lnum();\n\t\t\t    beginline(BL_SOL | BL_FIX);\n\t\t\t}\n\t\t    }\n\t\t    vim_free(ptr);\n\t\t}\n\t\tbreak;\n#endif\n\n#ifdef FEAT_FIND_ID\n// Go to the first occurrence of the identifier under cursor along path in a\n// new window -- webb\n    case 'i':\t\t\t    // Go to any match\n    case Ctrl_I:\n\t\ttype = FIND_ANY;\n\t\t// FALLTHROUGH\n    case 'd':\t\t\t    // Go to definition, using 'define'\n    case Ctrl_D:\n\t\tCHECK_CMDWIN;\n\t\tif ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\t\t    break;\n\n\t\t// Make a copy, if the line was changed it will be freed.\n\t\tptr = vim_strnsave(ptr, len);\n\t\tif (ptr == NULL)\n\t\t    break;\n\n\t\tfind_pattern_in_path(ptr, 0, len, TRUE,\n\t\t\tPrenum == 0 ? TRUE : FALSE, type,\n\t\t\tPrenum1, ACTION_SPLIT, (linenr_T)1, (linenr_T)MAXLNUM);\n\t\tvim_free(ptr);\n\t\tcurwin->w_set_curswant = TRUE;\n\t\tbreak;\n#endif\n\n// Quickfix window only: view the result under the cursor in a new split.\n#if defined(FEAT_QUICKFIX)\n    case K_KENTER:\n    case CAR:\n\t\tif (bt_quickfix(curbuf))\n\t\t    qf_view_result(TRUE);\n\t\tbreak;\n#endif\n\n// CTRL-W g  extended commands\n    case 'g':\n    case Ctrl_G:\n\t\tCHECK_CMDWIN;\n#ifdef USE_ON_FLY_SCROLL\n\t\tdont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\t\t++no_mapping;\n\t\t++allow_keys;   // no mapping for xchar, but allow key codes\n\t\tif (xchar == NUL)\n\t\t    xchar = plain_vgetc();\n\t\tLANGMAP_ADJUST(xchar, TRUE);\n\t\t--no_mapping;\n\t\t--allow_keys;\n#ifdef FEAT_CMDL_INFO\n\t\t(void)add_to_showcmd(xchar);\n#endif\n\t\tswitch (xchar)\n\t\t{\n#if defined(FEAT_QUICKFIX)\n\t\t    case '}':\n\t\t\txchar = Ctrl_RSB;\n\t\t\tif (Prenum)\n\t\t\t    g_do_tagpreview = Prenum;\n\t\t\telse\n\t\t\t    g_do_tagpreview = p_pvh;\n#endif\n\t\t\t// FALLTHROUGH\n\t\t    case ']':\n\t\t    case Ctrl_RSB:\n\t\t\t// keep Visual mode, can select words to use as a tag\n\t\t\tif (Prenum)\n\t\t\t    postponed_split = Prenum;\n\t\t\telse\n\t\t\t    postponed_split = -1;\n\n\t\t\t// Execute the command right here, required when\n\t\t\t// \"wincmd g}\" was used in a function.\n\t\t\tdo_nv_ident('g', xchar);\n\t\t\tbreak;\n\n#ifdef FEAT_SEARCHPATH\n\t\t    case 'f':\t    // CTRL-W gf: \"gf\" in a new tab page\n\t\t    case 'F':\t    // CTRL-W gF: \"gF\" in a new tab page\n\t\t\tcmdmod.cmod_tab = tabpage_index(curtab) + 1;\n\t\t\tnchar = xchar;\n\t\t\tgoto wingotofile;\n#endif\n\t\t    case 't':\t    // CTRL-W gt: go to next tab page\n\t\t\tgoto_tabpage((int)Prenum);\n\t\t\tbreak;\n\n\t\t    case 'T':\t    // CTRL-W gT: go to previous tab page\n\t\t\tgoto_tabpage(-(int)Prenum1);\n\t\t\tbreak;\n\n\t\t    case TAB:\t    // CTRL-W g<Tab>: go to last used tab page\n\t\t\tif (goto_tabpage_lastused() == FAIL)\n\t\t\t    beep_flush();\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tbeep_flush();\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n    default:\tbeep_flush();\n\t\tbreak;\n    }\n}\n\n/*\n * Figure out the address type for \":wincmd\".\n */\n    void\nget_wincmd_addr_type(char_u *arg, exarg_T *eap)\n{\n    switch (*arg)\n    {\n    case 'S':\n    case Ctrl_S:\n    case 's':\n    case Ctrl_N:\n    case 'n':\n    case 'j':\n    case Ctrl_J:\n    case 'k':\n    case Ctrl_K:\n    case 'T':\n    case Ctrl_R:\n    case 'r':\n    case 'R':\n    case 'K':\n    case 'J':\n    case '+':\n    case '-':\n    case Ctrl__:\n    case '_':\n    case '|':\n    case ']':\n    case Ctrl_RSB:\n    case 'g':\n    case Ctrl_G:\n    case Ctrl_V:\n    case 'v':\n    case 'h':\n    case Ctrl_H:\n    case 'l':\n    case Ctrl_L:\n    case 'H':\n    case 'L':\n    case '>':\n    case '<':\n#if defined(FEAT_QUICKFIX)\n    case '}':\n#endif\n#ifdef FEAT_SEARCHPATH\n    case 'f':\n    case 'F':\n    case Ctrl_F:\n#endif\n#ifdef FEAT_FIND_ID\n    case 'i':\n    case Ctrl_I:\n    case 'd':\n    case Ctrl_D:\n#endif\n\t\t// window size or any count\n\t\teap->addr_type = ADDR_OTHER;\n\t\tbreak;\n\n    case Ctrl_HAT:\n    case '^':\n\t\t// buffer number\n\t\teap->addr_type = ADDR_BUFFERS;\n\t\tbreak;\n\n    case Ctrl_Q:\n    case 'q':\n    case Ctrl_C:\n    case 'c':\n    case Ctrl_O:\n    case 'o':\n    case Ctrl_W:\n    case 'w':\n    case 'W':\n    case 'x':\n    case Ctrl_X:\n\t\t// window number\n\t\teap->addr_type = ADDR_WINDOWS;\n\t\tbreak;\n\n#if defined(FEAT_QUICKFIX)\n    case Ctrl_Z:\n    case 'z':\n    case 'P':\n#endif\n    case 't':\n    case Ctrl_T:\n    case 'b':\n    case Ctrl_B:\n    case 'p':\n    case Ctrl_P:\n    case '=':\n    case CAR:\n\t\t// no count\n\t\teap->addr_type = ADDR_NONE;\n\t\tbreak;\n    }\n}\n\n    static void\ncmd_with_count(\n    char\t*cmd,\n    char_u\t*bufp,\n    size_t\tbufsize,\n    long\tPrenum)\n{\n    if (Prenum > 0)\n\tvim_snprintf((char *)bufp, bufsize, \"%s %ld\", cmd, Prenum);\n    else\n\tSTRCPY(bufp, cmd);\n}\n\n/*\n * If \"split_disallowed\" is set give an error and return FAIL.\n * Otherwise return OK.\n */\n    static int\ncheck_split_disallowed()\n{\n    if (split_disallowed > 0)\n    {\n\temsg(_(e_cant_split_window_while_closing_another));\n\treturn FAIL;\n    }\n    if (curwin->w_buffer->b_locked_split)\n    {\n\temsg(_(e_cannot_split_window_when_closing_buffer));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * split the current window, implements CTRL-W s and :split\n *\n * \"size\" is the height or width for the new window, 0 to use half of current\n * height or width.\n *\n * \"flags\":\n * WSP_ROOM: require enough room for new window\n * WSP_VERT: vertical split.\n * WSP_TOP:  open window at the top-left of the shell (help window).\n * WSP_BOT:  open window at the bottom-right of the shell (quickfix window).\n * WSP_HELP: creating the help window, keep layout snapshot\n *\n * return FAIL for failure, OK otherwise\n */\n    int\nwin_split(int size, int flags)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn FAIL;\n\n    if (check_split_disallowed() == FAIL)\n\treturn FAIL;\n\n    // When the \":tab\" modifier was used open a new tab page instead.\n    if (may_open_tabpage() == OK)\n\treturn OK;\n\n    // Add flags from \":vertical\", \":topleft\" and \":botright\".\n    flags |= cmdmod.cmod_split;\n    if ((flags & WSP_TOP) && (flags & WSP_BOT))\n    {\n\temsg(_(e_cant_split_topleft_and_botright_at_the_same_time));\n\treturn FAIL;\n    }\n\n    // When creating the help window make a snapshot of the window layout.\n    // Otherwise clear the snapshot, it's now invalid.\n    if (flags & WSP_HELP)\n\tmake_snapshot(SNAP_HELP_IDX);\n    else\n\tclear_snapshot(curtab, SNAP_HELP_IDX);\n\n    return win_split_ins(size, flags, NULL, 0);\n}\n\n/*\n * When \"new_wp\" is NULL: split the current window in two.\n * When \"new_wp\" is not NULL: insert this window at the far\n * top/left/right/bottom.\n * return FAIL for failure, OK otherwise\n */\n    int\nwin_split_ins(\n    int\t\tsize,\n    int\t\tflags,\n    win_T\t*new_wp,\n    int\t\tdir)\n{\n    win_T\t*wp = new_wp;\n    win_T\t*oldwin;\n    int\t\tnew_size = size;\n    int\t\ti;\n    int\t\tneed_status = 0;\n    int\t\tdo_equal = FALSE;\n    int\t\tneeded;\n    int\t\tavailable;\n    int\t\toldwin_height = 0;\n    int\t\tlayout;\n    frame_T\t*frp, *curfrp, *frp2, *prevfrp;\n    int\t\tbefore;\n    int\t\tminheight;\n    int\t\twmh1;\n    int\t\tdid_set_fraction = FALSE;\n\n    if (flags & WSP_TOP)\n\toldwin = firstwin;\n    else if (flags & WSP_BOT)\n\toldwin = lastwin;\n    else\n\toldwin = curwin;\n\n    // add a status line when p_ls == 1 and splitting the first window\n    if (ONE_WINDOW && p_ls == 1 && oldwin->w_status_height == 0)\n    {\n\tif (VISIBLE_HEIGHT(oldwin) <= p_wmh && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\tneed_status = STATUS_HEIGHT;\n    }\n\n#ifdef FEAT_GUI\n    // May be needed for the scrollbars that are going to change.\n    if (gui.in_use)\n\tout_flush();\n#endif\n\n    if (flags & WSP_VERT)\n    {\n\tint\twmw1;\n\tint\tminwidth;\n\n\tlayout = FR_ROW;\n\n\t/*\n\t * Check if we are able to split the current window and compute its\n\t * width.\n\t */\n\t// Current window requires at least 1 space.\n\twmw1 = (p_wmw == 0 ? 1 : p_wmw);\n\tneeded = wmw1 + 1;\n\tif (flags & WSP_ROOM)\n\t    needed += p_wiw - wmw1;\n\tif (flags & (WSP_BOT | WSP_TOP))\n\t{\n\t    minwidth = frame_minwidth(topframe, NOWIN);\n\t    available = topframe->fr_width;\n\t    needed += minwidth;\n\t}\n\telse if (p_ea)\n\t{\n\t    minwidth = frame_minwidth(oldwin->w_frame, NOWIN);\n\t    prevfrp = oldwin->w_frame;\n\t    for (frp = oldwin->w_frame->fr_parent; frp != NULL;\n\t\t\t\t\t\t\tfrp = frp->fr_parent)\n\t    {\n\t\tif (frp->fr_layout == FR_ROW)\n\t\t    FOR_ALL_FRAMES(frp2, frp->fr_child)\n\t\t\tif (frp2 != prevfrp)\n\t\t\t    minwidth += frame_minwidth(frp2, NOWIN);\n\t\tprevfrp = frp;\n\t    }\n\t    available = topframe->fr_width;\n\t    needed += minwidth;\n\t}\n\telse\n\t{\n\t    minwidth = frame_minwidth(oldwin->w_frame, NOWIN);\n\t    available = oldwin->w_frame->fr_width;\n\t    needed += minwidth;\n\t}\n\tif (available < needed && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\tif (new_size == 0)\n\t    new_size = oldwin->w_width / 2;\n\tif (new_size > available - minwidth - 1)\n\t    new_size = available - minwidth - 1;\n\tif (new_size < wmw1)\n\t    new_size = wmw1;\n\n\t// if it doesn't fit in the current window, need win_equal()\n\tif (oldwin->w_width - new_size - 1 < p_wmw)\n\t    do_equal = TRUE;\n\n\t// We don't like to take lines for the new window from a\n\t// 'winfixwidth' window.  Take them from a window to the left or right\n\t// instead, if possible. Add one for the separator.\n\tif (oldwin->w_p_wfw)\n\t    win_setwidth_win(oldwin->w_width + new_size + 1, oldwin);\n\n\t// Only make all windows the same width if one of them (except oldwin)\n\t// is wider than one of the split windows.\n\tif (!do_equal && p_ea && size == 0 && *p_ead != 'v'\n\t\t\t\t\t && oldwin->w_frame->fr_parent != NULL)\n\t{\n\t    frp = oldwin->w_frame->fr_parent->fr_child;\n\t    while (frp != NULL)\n\t    {\n\t\tif (frp->fr_win != oldwin && frp->fr_win != NULL\n\t\t\t&& (frp->fr_win->w_width > new_size\n\t\t\t    || frp->fr_win->w_width > oldwin->w_width\n\t\t\t\t\t\t\t      - new_size - 1))\n\t\t{\n\t\t    do_equal = TRUE;\n\t\t    break;\n\t\t}\n\t\tfrp = frp->fr_next;\n\t    }\n\t}\n    }\n    else\n    {\n\tlayout = FR_COL;\n\n\t/*\n\t * Check if we are able to split the current window and compute its\n\t * height.\n\t */\n\t// Current window requires at least 1 space.\n\twmh1 = (p_wmh == 0 ? 1 : p_wmh) + WINBAR_HEIGHT(curwin);\n\tneeded = wmh1 + STATUS_HEIGHT;\n\tif (flags & WSP_ROOM)\n\t    needed += p_wh - wmh1;\n\tif (flags & (WSP_BOT | WSP_TOP))\n\t{\n\t    minheight = frame_minheight(topframe, NOWIN) + need_status;\n\t    available = topframe->fr_height;\n\t    needed += minheight;\n\t}\n\telse if (p_ea)\n\t{\n\t    minheight = frame_minheight(oldwin->w_frame, NOWIN) + need_status;\n\t    prevfrp = oldwin->w_frame;\n\t    for (frp = oldwin->w_frame->fr_parent; frp != NULL;\n\t\t\t\t\t\t\tfrp = frp->fr_parent)\n\t    {\n\t\tif (frp->fr_layout == FR_COL)\n\t\t    FOR_ALL_FRAMES(frp2, frp->fr_child)\n\t\t\tif (frp2 != prevfrp)\n\t\t\t    minheight += frame_minheight(frp2, NOWIN);\n\t\tprevfrp = frp;\n\t    }\n\t    available = topframe->fr_height;\n\t    needed += minheight;\n\t}\n\telse\n\t{\n\t    minheight = frame_minheight(oldwin->w_frame, NOWIN) + need_status;\n\t    available = oldwin->w_frame->fr_height;\n\t    needed += minheight;\n\t}\n\tif (available < needed && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\toldwin_height = oldwin->w_height;\n\tif (need_status)\n\t{\n\t    oldwin->w_status_height = STATUS_HEIGHT;\n\t    oldwin_height -= STATUS_HEIGHT;\n\t}\n\tif (new_size == 0)\n\t    new_size = oldwin_height / 2;\n\tif (new_size > available - minheight - STATUS_HEIGHT)\n\t    new_size = available - minheight - STATUS_HEIGHT;\n\tif (new_size < wmh1)\n\t    new_size = wmh1;\n\n\t// if it doesn't fit in the current window, need win_equal()\n\tif (oldwin_height - new_size - STATUS_HEIGHT < p_wmh)\n\t    do_equal = TRUE;\n\n\t// We don't like to take lines for the new window from a\n\t// 'winfixheight' window.  Take them from a window above or below\n\t// instead, if possible.\n\tif (oldwin->w_p_wfh)\n\t{\n\t    // Set w_fraction now so that the cursor keeps the same relative\n\t    // vertical position using the old height.\n\t    set_fraction(oldwin);\n\t    did_set_fraction = TRUE;\n\n\t    win_setheight_win(oldwin->w_height + new_size + STATUS_HEIGHT,\n\t\t\t\t\t\t\t\t      oldwin);\n\t    oldwin_height = oldwin->w_height;\n\t    if (need_status)\n\t\toldwin_height -= STATUS_HEIGHT;\n\t}\n\n\t// Only make all windows the same height if one of them (except oldwin)\n\t// is higher than one of the split windows.\n\tif (!do_equal && p_ea && size == 0 && *p_ead != 'h'\n\t   && oldwin->w_frame->fr_parent != NULL)\n\t{\n\t    frp = oldwin->w_frame->fr_parent->fr_child;\n\t    while (frp != NULL)\n\t    {\n\t\tif (frp->fr_win != oldwin && frp->fr_win != NULL\n\t\t\t&& (frp->fr_win->w_height > new_size\n\t\t\t    || frp->fr_win->w_height > oldwin_height - new_size\n\t\t\t\t\t\t\t      - STATUS_HEIGHT))\n\t\t{\n\t\t    do_equal = TRUE;\n\t\t    break;\n\t\t}\n\t\tfrp = frp->fr_next;\n\t    }\n\t}\n    }\n\n    /*\n     * allocate new window structure and link it in the window list\n     */\n    if ((flags & WSP_TOP) == 0\n\t    && ((flags & WSP_BOT)\n\t\t|| (flags & WSP_BELOW)\n\t\t|| (!(flags & WSP_ABOVE)\n\t\t    && ( (flags & WSP_VERT) ? p_spr : p_sb))))\n    {\n\t// new window below/right of current one\n\tif (new_wp == NULL)\n\t    wp = win_alloc(oldwin, FALSE);\n\telse\n\t    win_append(oldwin, wp);\n    }\n    else\n    {\n\tif (new_wp == NULL)\n\t    wp = win_alloc(oldwin->w_prev, FALSE);\n\telse\n\t    win_append(oldwin->w_prev, wp);\n    }\n\n    if (new_wp == NULL)\n    {\n\tif (wp == NULL)\n\t    return FAIL;\n\n\tnew_frame(wp);\n\tif (wp->w_frame == NULL)\n\t{\n\t    win_free(wp, NULL);\n\t    return FAIL;\n\t}\n\n\t// make the contents of the new window the same as the current one\n\twin_init(wp, curwin, flags);\n    }\n\n    /*\n     * Reorganise the tree of frames to insert the new window.\n     */\n    if (flags & (WSP_TOP | WSP_BOT))\n    {\n\tif ((topframe->fr_layout == FR_COL && (flags & WSP_VERT) == 0)\n\t    || (topframe->fr_layout == FR_ROW && (flags & WSP_VERT) != 0))\n\t{\n\t    curfrp = topframe->fr_child;\n\t    if (flags & WSP_BOT)\n\t\twhile (curfrp->fr_next != NULL)\n\t\t    curfrp = curfrp->fr_next;\n\t}\n\telse\n\t    curfrp = topframe;\n\tbefore = (flags & WSP_TOP);\n    }\n    else\n    {\n\tcurfrp = oldwin->w_frame;\n\tif (flags & WSP_BELOW)\n\t    before = FALSE;\n\telse if (flags & WSP_ABOVE)\n\t    before = TRUE;\n\telse if (flags & WSP_VERT)\n\t    before = !p_spr;\n\telse\n\t    before = !p_sb;\n    }\n    if (curfrp->fr_parent == NULL || curfrp->fr_parent->fr_layout != layout)\n    {\n\t// Need to create a new frame in the tree to make a branch.\n\tfrp = ALLOC_CLEAR_ONE(frame_T);\n\t*frp = *curfrp;\n\tcurfrp->fr_layout = layout;\n\tfrp->fr_parent = curfrp;\n\tfrp->fr_next = NULL;\n\tfrp->fr_prev = NULL;\n\tcurfrp->fr_child = frp;\n\tcurfrp->fr_win = NULL;\n\tcurfrp = frp;\n\tif (frp->fr_win != NULL)\n\t    oldwin->w_frame = frp;\n\telse\n\t    FOR_ALL_FRAMES(frp, frp->fr_child)\n\t\tfrp->fr_parent = curfrp;\n    }\n\n    if (new_wp == NULL)\n\tfrp = wp->w_frame;\n    else\n\tfrp = new_wp->w_frame;\n    frp->fr_parent = curfrp->fr_parent;\n\n    // Insert the new frame at the right place in the frame list.\n    if (before)\n\tframe_insert(curfrp, frp);\n    else\n\tframe_append(curfrp, frp);\n\n    // Set w_fraction now so that the cursor keeps the same relative\n    // vertical position.\n    if (!did_set_fraction)\n\tset_fraction(oldwin);\n    wp->w_fraction = oldwin->w_fraction;\n\n    if (flags & WSP_VERT)\n    {\n\twp->w_p_scr = curwin->w_p_scr;\n\n\tif (need_status)\n\t{\n\t    win_new_height(oldwin, oldwin->w_height - 1);\n\t    oldwin->w_status_height = need_status;\n\t}\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    // set height and row of new window to full height\n\t    wp->w_winrow = tabline_height();\n\t    win_new_height(wp, curfrp->fr_height - (p_ls > 0)\n\t\t\t\t\t\t\t  - WINBAR_HEIGHT(wp));\n\t    wp->w_status_height = (p_ls > 0);\n\t}\n\telse\n\t{\n\t    // height and row of new window is same as current window\n\t    wp->w_winrow = oldwin->w_winrow;\n\t    win_new_height(wp, VISIBLE_HEIGHT(oldwin));\n\t    wp->w_status_height = oldwin->w_status_height;\n\t}\n\tfrp->fr_height = curfrp->fr_height;\n\n\t// \"new_size\" of the current window goes to the new window, use\n\t// one column for the vertical separator\n\twin_new_width(wp, new_size);\n\tif (before)\n\t    wp->w_vsep_width = 1;\n\telse\n\t{\n\t    wp->w_vsep_width = oldwin->w_vsep_width;\n\t    oldwin->w_vsep_width = 1;\n\t}\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    if (flags & WSP_BOT)\n\t\tframe_add_vsep(curfrp);\n\t    // Set width of neighbor frame\n\t    frame_new_width(curfrp, curfrp->fr_width\n\t\t     - (new_size + ((flags & WSP_TOP) != 0)), flags & WSP_TOP,\n\t\t\t\t\t\t\t\t       FALSE);\n\t}\n\telse\n\t    win_new_width(oldwin, oldwin->w_width - (new_size + 1));\n\tif (before)\t// new window left of current one\n\t{\n\t    wp->w_wincol = oldwin->w_wincol;\n\t    oldwin->w_wincol += new_size + 1;\n\t}\n\telse\t\t// new window right of current one\n\t    wp->w_wincol = oldwin->w_wincol + oldwin->w_width + 1;\n\tframe_fix_width(oldwin);\n\tframe_fix_width(wp);\n    }\n    else\n    {\n\t// width and column of new window is same as current window\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    wp->w_wincol = 0;\n\t    win_new_width(wp, Columns);\n\t    wp->w_vsep_width = 0;\n\t}\n\telse\n\t{\n\t    wp->w_wincol = oldwin->w_wincol;\n\t    win_new_width(wp, oldwin->w_width);\n\t    wp->w_vsep_width = oldwin->w_vsep_width;\n\t}\n\tfrp->fr_width = curfrp->fr_width;\n\n\t// \"new_size\" of the current window goes to the new window, use\n\t// one row for the status line\n\twin_new_height(wp, new_size);\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    int new_fr_height = curfrp->fr_height - new_size\n\t\t\t\t\t\t\t  + WINBAR_HEIGHT(wp) ;\n\n\t    if (!((flags & WSP_BOT) && p_ls == 0))\n\t\tnew_fr_height -= STATUS_HEIGHT;\n\t    frame_new_height(curfrp, new_fr_height, flags & WSP_TOP, FALSE);\n\t}\n\telse\n\t    win_new_height(oldwin, oldwin_height - (new_size + STATUS_HEIGHT));\n\tif (before)\t// new window above current one\n\t{\n\t    wp->w_winrow = oldwin->w_winrow;\n\t    wp->w_status_height = STATUS_HEIGHT;\n\t    oldwin->w_winrow += wp->w_height + STATUS_HEIGHT;\n\t}\n\telse\t\t// new window below current one\n\t{\n\t    wp->w_winrow = oldwin->w_winrow + VISIBLE_HEIGHT(oldwin)\n\t\t\t\t\t\t\t       + STATUS_HEIGHT;\n\t    wp->w_status_height = oldwin->w_status_height;\n\t    if (!(flags & WSP_BOT))\n\t\toldwin->w_status_height = STATUS_HEIGHT;\n\t}\n\tif (flags & WSP_BOT)\n\t    frame_add_statusline(curfrp);\n\tframe_fix_height(wp);\n\tframe_fix_height(oldwin);\n    }\n\n    if (flags & (WSP_TOP | WSP_BOT))\n\t(void)win_comp_pos();\n\n     // Both windows need redrawing.  Update all status lines, in case they\n     // show something related to the window count or position.\n    redraw_win_later(wp, NOT_VALID);\n    redraw_win_later(oldwin, NOT_VALID);\n    status_redraw_all();\n\n    if (need_status)\n    {\n\tmsg_row = Rows - 1;\n\tmsg_col = sc_col;\n\tmsg_clr_eos_force();\t// Old command/ruler may still be there\n\tcomp_col();\n\tmsg_row = Rows - 1;\n\tmsg_col = 0;\t// put position back at start of line\n    }\n\n    /*\n     * equalize the window sizes.\n     */\n    if (do_equal || dir != 0)\n\twin_equal(wp, TRUE,\n\t\t(flags & WSP_VERT) ? (dir == 'v' ? 'b' : 'h')\n\t\t: dir == 'h' ? 'b' : 'v');\n\n    // Don't change the window height/width to 'winheight' / 'winwidth' if a\n    // size was given.\n    if (flags & WSP_VERT)\n    {\n\ti = p_wiw;\n\tif (size != 0)\n\t    p_wiw = size;\n\n# ifdef FEAT_GUI\n\t// When 'guioptions' includes 'L' or 'R' may have to add scrollbars.\n\tif (gui.in_use)\n\t    gui_init_which_components(NULL);\n# endif\n    }\n    else\n    {\n\ti = p_wh;\n\tif (size != 0)\n\t    p_wh = size;\n    }\n\n    /*\n     * make the new window the current window\n     */\n    (void)win_enter_ext(wp, WEE_TRIGGER_NEW_AUTOCMDS\n\t\t    | WEE_TRIGGER_ENTER_AUTOCMDS | WEE_TRIGGER_LEAVE_AUTOCMDS);\n    if (flags & WSP_VERT)\n\tp_wiw = i;\n    else\n\tp_wh = i;\n\n    return OK;\n}\n\n\n/*\n * Initialize window \"newp\" from window \"oldp\".\n * Used when splitting a window and when creating a new tab page.\n * The windows will both edit the same buffer.\n * WSP_NEWLOC may be specified in flags to prevent the location list from\n * being copied.\n */\n    static void\nwin_init(win_T *newp, win_T *oldp, int flags UNUSED)\n{\n    int\t\ti;\n\n    newp->w_buffer = oldp->w_buffer;\n#ifdef FEAT_SYN_HL\n    newp->w_s = &(oldp->w_buffer->b_s);\n#endif\n    oldp->w_buffer->b_nwindows++;\n    newp->w_cursor = oldp->w_cursor;\n    newp->w_valid = 0;\n    newp->w_curswant = oldp->w_curswant;\n    newp->w_set_curswant = oldp->w_set_curswant;\n    newp->w_topline = oldp->w_topline;\n#ifdef FEAT_DIFF\n    newp->w_topfill = oldp->w_topfill;\n#endif\n    newp->w_leftcol = oldp->w_leftcol;\n    newp->w_pcmark = oldp->w_pcmark;\n    newp->w_prev_pcmark = oldp->w_prev_pcmark;\n    newp->w_alt_fnum = oldp->w_alt_fnum;\n    newp->w_wrow = oldp->w_wrow;\n    newp->w_fraction = oldp->w_fraction;\n    newp->w_prev_fraction_row = oldp->w_prev_fraction_row;\n    copy_jumplist(oldp, newp);\n#ifdef FEAT_QUICKFIX\n    if (flags & WSP_NEWLOC)\n    {\n\t// Don't copy the location list.\n\tnewp->w_llist = NULL;\n\tnewp->w_llist_ref = NULL;\n    }\n    else\n\tcopy_loclist_stack(oldp, newp);\n#endif\n    newp->w_localdir = (oldp->w_localdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(oldp->w_localdir);\n    newp->w_prevdir = (oldp->w_prevdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(oldp->w_prevdir);\n\n    // copy tagstack and folds\n    for (i = 0; i < oldp->w_tagstacklen; i++)\n    {\n\ttaggy_T\t*tag = &newp->w_tagstack[i];\n\t*tag = oldp->w_tagstack[i];\n\tif (tag->tagname != NULL)\n\t    tag->tagname = vim_strsave(tag->tagname);\n\tif (tag->user_data != NULL)\n\t    tag->user_data = vim_strsave(tag->user_data);\n    }\n    newp->w_tagstackidx = oldp->w_tagstackidx;\n    newp->w_tagstacklen = oldp->w_tagstacklen;\n\n    // Keep same changelist position in new window.\n    newp->w_changelistidx = oldp->w_changelistidx;\n\n#ifdef FEAT_FOLDING\n    copyFoldingState(oldp, newp);\n#endif\n\n    win_init_some(newp, oldp);\n#ifdef FEAT_TERMINAL\n    term_update_wincolor(newp);\n#endif\n}\n\n/*\n * Initialize window \"newp\" from window \"old\".\n * Only the essential things are copied.\n */\n    static void\nwin_init_some(win_T *newp, win_T *oldp)\n{\n    // Use the same argument list.\n    newp->w_alist = oldp->w_alist;\n    ++newp->w_alist->al_refcount;\n    newp->w_arg_idx = oldp->w_arg_idx;\n\n    // copy options from existing window\n    win_copy_options(oldp, newp);\n}\n\n/*\n * Return TRUE if \"win\" is a global popup or a popup in the current tab page.\n */\n    int\nwin_valid_popup(win_T *win UNUSED)\n{\n#ifdef FEAT_PROP_POPUP\n    win_T\t*wp;\n\n    FOR_ALL_POPUPWINS(wp)\n\tif (wp == win)\n\t    return TRUE;\n    FOR_ALL_POPUPWINS_IN_TAB(curtab, wp)\n\tif (wp == win)\n\t    return TRUE;\n#endif\n    return FALSE;\n}\n\n/*\n * Check if \"win\" is a pointer to an existing window in the current tab page.\n */\n    int\nwin_valid(win_T *win)\n{\n    win_T\t*wp;\n\n    if (win == NULL)\n\treturn FALSE;\n    FOR_ALL_WINDOWS(wp)\n\tif (wp == win)\n\t    return TRUE;\n    return win_valid_popup(win);\n}\n\n/*\n * Find window \"id\" in the current tab page.\n * Also find popup windows.\n * Return NULL if not found.\n */\n    win_T *\nwin_find_by_id(int id)\n{\n    win_T   *wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_id == id)\n\t    return wp;\n#ifdef FEAT_PROP_POPUP\n    FOR_ALL_POPUPWINS(wp)\n\tif (wp->w_id == id)\n\t    return wp;\n    FOR_ALL_POPUPWINS_IN_TAB(curtab, wp)\n\tif (wp->w_id == id)\n\t    return wp;\n#endif\n    return NULL;\n}\n\n/*\n * Check if \"win\" is a pointer to an existing window in any tab page.\n */\n    int\nwin_valid_any_tab(win_T *win)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    if (win == NULL)\n\treturn FALSE;\n    FOR_ALL_TABPAGES(tp)\n    {\n\tFOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t{\n\t    if (wp == win)\n\t\treturn TRUE;\n\t}\n#ifdef FEAT_PROP_POPUP\n\tFOR_ALL_POPUPWINS_IN_TAB(tp, wp)\n\t    if (wp == win)\n\t\treturn TRUE;\n#endif\n    }\n    return win_valid_popup(win);\n}\n\n/*\n * Return the number of windows.\n */\n    int\nwin_count(void)\n{\n    win_T\t*wp;\n    int\t\tcount = 0;\n\n    FOR_ALL_WINDOWS(wp)\n\t++count;\n    return count;\n}\n\n/*\n * Make \"count\" windows on the screen.\n * Return actual number of windows on the screen.\n * Must be called when there is just one window, filling the whole screen\n * (excluding the command line).\n */\n    int\nmake_windows(\n    int\t\tcount,\n    int\t\tvertical UNUSED)  // split windows vertically if TRUE\n{\n    int\t\tmaxcount;\n    int\t\ttodo;\n\n    if (vertical)\n    {\n\t// Each window needs at least 'winminwidth' lines and a separator\n\t// column.\n\tmaxcount = (curwin->w_width + curwin->w_vsep_width\n\t\t\t\t\t     - (p_wiw - p_wmw)) / (p_wmw + 1);\n    }\n    else\n    {\n\t// Each window needs at least 'winminheight' lines and a status line.\n\tmaxcount = (VISIBLE_HEIGHT(curwin) + curwin->w_status_height\n\t\t\t\t  - (p_wh - p_wmh)) / (p_wmh + STATUS_HEIGHT);\n    }\n\n    if (maxcount < 2)\n\tmaxcount = 2;\n    if (count > maxcount)\n\tcount = maxcount;\n\n    /*\n     * add status line now, otherwise first window will be too big\n     */\n    if (count > 1)\n\tlast_status(TRUE);\n\n    /*\n     * Don't execute autocommands while creating the windows.  Must do that\n     * when putting the buffers in the windows.\n     */\n    block_autocmds();\n\n    // todo is number of windows left to create\n    for (todo = count - 1; todo > 0; --todo)\n\tif (vertical)\n\t{\n\t    if (win_split(curwin->w_width - (curwin->w_width - todo)\n\t\t\t/ (todo + 1) - 1, WSP_VERT | WSP_ABOVE) == FAIL)\n\t\tbreak;\n\t}\n\telse\n\t{\n\t    if (win_split(curwin->w_height - (curwin->w_height - todo\n\t\t\t    * STATUS_HEIGHT) / (todo + 1)\n\t\t\t- STATUS_HEIGHT, WSP_ABOVE) == FAIL)\n\t\tbreak;\n\t}\n\n    unblock_autocmds();\n\n    // return actual number of windows\n    return (count - todo);\n}\n\n/*\n * Exchange current and next window\n */\n    static void\nwin_exchange(long Prenum)\n{\n    frame_T\t*frp;\n    frame_T\t*frp2;\n    win_T\t*wp;\n    win_T\t*wp2;\n    int\t\ttemp;\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (ONE_WINDOW)\t    // just one window\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * find window to exchange with\n     */\n    if (Prenum)\n    {\n\tfrp = curwin->w_frame->fr_parent->fr_child;\n\twhile (frp != NULL && --Prenum > 0)\n\t    frp = frp->fr_next;\n    }\n    else if (curwin->w_frame->fr_next != NULL)\t// Swap with next\n\tfrp = curwin->w_frame->fr_next;\n    else    // Swap last window in row/col with previous\n\tfrp = curwin->w_frame->fr_prev;\n\n    // We can only exchange a window with another window, not with a frame\n    // containing windows.\n    if (frp == NULL || frp->fr_win == NULL || frp->fr_win == curwin)\n\treturn;\n    wp = frp->fr_win;\n\n/*\n * 1. remove curwin from the list. Remember after which window it was in wp2\n * 2. insert curwin before wp in the list\n * if wp != wp2\n *    3. remove wp from the list\n *    4. insert wp after wp2\n * 5. exchange the status line height and vsep width.\n */\n    wp2 = curwin->w_prev;\n    frp2 = curwin->w_frame->fr_prev;\n    if (wp->w_prev != curwin)\n    {\n\twin_remove(curwin, NULL);\n\tframe_remove(curwin->w_frame);\n\twin_append(wp->w_prev, curwin);\n\tframe_insert(frp, curwin->w_frame);\n    }\n    if (wp != wp2)\n    {\n\twin_remove(wp, NULL);\n\tframe_remove(wp->w_frame);\n\twin_append(wp2, wp);\n\tif (frp2 == NULL)\n\t    frame_insert(wp->w_frame->fr_parent->fr_child, wp->w_frame);\n\telse\n\t    frame_append(frp2, wp->w_frame);\n    }\n    temp = curwin->w_status_height;\n    curwin->w_status_height = wp->w_status_height;\n    wp->w_status_height = temp;\n    temp = curwin->w_vsep_width;\n    curwin->w_vsep_width = wp->w_vsep_width;\n    wp->w_vsep_width = temp;\n\n    frame_fix_height(curwin);\n    frame_fix_height(wp);\n    frame_fix_width(curwin);\n    frame_fix_width(wp);\n\n    (void)win_comp_pos();\t\t// recompute window positions\n\n    if (wp->w_buffer != curbuf)\n\treset_VIsual_and_resel();\n    else if (VIsual_active)\n\twp->w_cursor = curwin->w_cursor;\n\n    win_enter(wp, TRUE);\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * rotate windows: if upwards TRUE the second window becomes the first one\n *\t\t   if upwards FALSE the first window becomes the second one\n */\n    static void\nwin_rotate(int upwards, int count)\n{\n    win_T\t*wp1;\n    win_T\t*wp2;\n    frame_T\t*frp;\n    int\t\tn;\n\n    if (ONE_WINDOW)\t\t// nothing to do\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    // Check if all frames in this row/col have one window.\n    FOR_ALL_FRAMES(frp, curwin->w_frame->fr_parent->fr_child)\n\tif (frp->fr_win == NULL)\n\t{\n\t    emsg(_(e_cannot_rotate_when_another_window_is_split));\n\t    return;\n\t}\n\n    while (count--)\n    {\n\tif (upwards)\t\t// first window becomes last window\n\t{\n\t    // remove first window/frame from the list\n\t    frp = curwin->w_frame->fr_parent->fr_child;\n\t    wp1 = frp->fr_win;\n\t    win_remove(wp1, NULL);\n\t    frame_remove(frp);\n\n\t    // find last frame and append removed window/frame after it\n\t    for ( ; frp->fr_next != NULL; frp = frp->fr_next)\n\t\t;\n\t    win_append(frp->fr_win, wp1);\n\t    frame_append(frp, wp1->w_frame);\n\n\t    wp2 = frp->fr_win;\t\t// previously last window\n\t}\n\telse\t\t\t// last window becomes first window\n\t{\n\t    // find last window/frame in the list and remove it\n\t    for (frp = curwin->w_frame; frp->fr_next != NULL;\n\t\t\t\t\t\t\t   frp = frp->fr_next)\n\t\t;\n\t    wp1 = frp->fr_win;\n\t    wp2 = wp1->w_prev;\t\t    // will become last window\n\t    win_remove(wp1, NULL);\n\t    frame_remove(frp);\n\n\t    // append the removed window/frame before the first in the list\n\t    win_append(frp->fr_parent->fr_child->fr_win->w_prev, wp1);\n\t    frame_insert(frp->fr_parent->fr_child, frp);\n\t}\n\n\t// exchange status height and vsep width of old and new last window\n\tn = wp2->w_status_height;\n\twp2->w_status_height = wp1->w_status_height;\n\twp1->w_status_height = n;\n\tframe_fix_height(wp1);\n\tframe_fix_height(wp2);\n\tn = wp2->w_vsep_width;\n\twp2->w_vsep_width = wp1->w_vsep_width;\n\twp1->w_vsep_width = n;\n\tframe_fix_width(wp1);\n\tframe_fix_width(wp2);\n\n\t// recompute w_winrow and w_wincol for all windows\n\t(void)win_comp_pos();\n    }\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Move the current window to the very top/bottom/left/right of the screen.\n */\n    static void\nwin_totop(int size, int flags)\n{\n    int\t\tdir;\n    int\t\theight = curwin->w_height;\n\n    if (ONE_WINDOW)\n    {\n\tbeep_flush();\n\treturn;\n    }\n    if (check_split_disallowed() == FAIL)\n\treturn;\n\n    // Remove the window and frame from the tree of frames.\n    (void)winframe_remove(curwin, &dir, NULL);\n    win_remove(curwin, NULL);\n    last_status(FALSE);\t    // may need to remove last status line\n    (void)win_comp_pos();   // recompute window positions\n\n    // Split a window on the desired side and put the window there.\n    (void)win_split_ins(size, flags, curwin, dir);\n    if (!(flags & WSP_VERT))\n    {\n\twin_setheight(height);\n\tif (p_ea)\n\t    win_equal(curwin, TRUE, 'v');\n    }\n\n#if defined(FEAT_GUI)\n    // When 'guioptions' includes 'L' or 'R' may have to remove or add\n    // scrollbars.  Have to update them anyway.\n    gui_may_update_scrollbars();\n#endif\n}\n\n/*\n * Move window \"win1\" to below/right of \"win2\" and make \"win1\" the current\n * window.  Only works within the same frame!\n */\n    void\nwin_move_after(win_T *win1, win_T *win2)\n{\n    int\t\theight;\n\n    // check if the arguments are reasonable\n    if (win1 == win2)\n\treturn;\n\n    // check if there is something to do\n    if (win2->w_next != win1)\n    {\n\tif (win1->w_frame->fr_parent != win2->w_frame->fr_parent)\n\t{\n\t    iemsg(\"INTERNAL: trying to move a window into another frame\");\n\t    return;\n\t}\n\n\t// may need to move the status line/vertical separator of the last\n\t// window\n\tif (win1 == lastwin)\n\t{\n\t    height = win1->w_prev->w_status_height;\n\t    win1->w_prev->w_status_height = win1->w_status_height;\n\t    win1->w_status_height = height;\n\t    if (win1->w_prev->w_vsep_width == 1)\n\t    {\n\t\t// Remove the vertical separator from the last-but-one window,\n\t\t// add it to the last window.  Adjust the frame widths.\n\t\twin1->w_prev->w_vsep_width = 0;\n\t\twin1->w_prev->w_frame->fr_width -= 1;\n\t\twin1->w_vsep_width = 1;\n\t\twin1->w_frame->fr_width += 1;\n\t    }\n\t}\n\telse if (win2 == lastwin)\n\t{\n\t    height = win1->w_status_height;\n\t    win1->w_status_height = win2->w_status_height;\n\t    win2->w_status_height = height;\n\t    if (win1->w_vsep_width == 1)\n\t    {\n\t\t// Remove the vertical separator from win1, add it to the last\n\t\t// window, win2.  Adjust the frame widths.\n\t\twin2->w_vsep_width = 1;\n\t\twin2->w_frame->fr_width += 1;\n\t\twin1->w_vsep_width = 0;\n\t\twin1->w_frame->fr_width -= 1;\n\t    }\n\t}\n\twin_remove(win1, NULL);\n\tframe_remove(win1->w_frame);\n\twin_append(win2, win1);\n\tframe_append(win2->w_frame, win1->w_frame);\n\n\t(void)win_comp_pos();\t// recompute w_winrow for all windows\n\tredraw_later(NOT_VALID);\n    }\n    win_enter(win1, FALSE);\n}\n\n/*\n * Make all windows the same height.\n * 'next_curwin' will soon be the current window, make sure it has enough\n * rows.\n */\n    void\nwin_equal(\n    win_T\t*next_curwin,\t// pointer to current window to be or NULL\n    int\t\tcurrent,\t// do only frame with current window\n    int\t\tdir)\t\t// 'v' for vertically, 'h' for horizontally,\n\t\t\t\t// 'b' for both, 0 for using p_ead\n{\n    if (dir == 0)\n\tdir = *p_ead;\n    win_equal_rec(next_curwin == NULL ? curwin : next_curwin, current,\n\t\t      topframe, dir, 0, tabline_height(),\n\t\t\t\t\t   (int)Columns, topframe->fr_height);\n}\n\n/*\n * Set a frame to a new position and height, spreading the available room\n * equally over contained frames.\n * The window \"next_curwin\" (if not NULL) should at least get the size from\n * 'winheight' and 'winwidth' if possible.\n */\n    static void\nwin_equal_rec(\n    win_T\t*next_curwin,\t// pointer to current window to be or NULL\n    int\t\tcurrent,\t// do only frame with current window\n    frame_T\t*topfr,\t\t// frame to set size off\n    int\t\tdir,\t\t// 'v', 'h' or 'b', see win_equal()\n    int\t\tcol,\t\t// horizontal position for frame\n    int\t\trow,\t\t// vertical position for frame\n    int\t\twidth,\t\t// new width of frame\n    int\t\theight)\t\t// new height of frame\n{\n    int\t\tn, m;\n    int\t\textra_sep = 0;\n    int\t\twincount, totwincount = 0;\n    frame_T\t*fr;\n    int\t\tnext_curwin_size = 0;\n    int\t\troom = 0;\n    int\t\tnew_size;\n    int\t\thas_next_curwin = 0;\n    int\t\thnc;\n\n    if (topfr->fr_layout == FR_LEAF)\n    {\n\t// Set the width/height of this frame.\n\t// Redraw when size or position changes\n\tif (topfr->fr_height != height || topfr->fr_win->w_winrow != row\n\t\t|| topfr->fr_width != width || topfr->fr_win->w_wincol != col\n\t   )\n\t{\n\t    topfr->fr_win->w_winrow = row;\n\t    frame_new_height(topfr, height, FALSE, FALSE);\n\t    topfr->fr_win->w_wincol = col;\n\t    frame_new_width(topfr, width, FALSE, FALSE);\n\t    redraw_all_later(NOT_VALID);\n\t}\n    }\n    else if (topfr->fr_layout == FR_ROW)\n    {\n\ttopfr->fr_width = width;\n\ttopfr->fr_height = height;\n\n\tif (dir != 'v')\t\t\t// equalize frame widths\n\t{\n\t    // Compute the maximum number of windows horizontally in this\n\t    // frame.\n\t    n = frame_minwidth(topfr, NOWIN);\n\t    // add one for the rightmost window, it doesn't have a separator\n\t    if (col + width == Columns)\n\t\textra_sep = 1;\n\t    else\n\t\textra_sep = 0;\n\t    totwincount = (n + extra_sep) / (p_wmw + 1);\n\t    has_next_curwin = frame_has_win(topfr, next_curwin);\n\n\t    /*\n\t     * Compute width for \"next_curwin\" window and room available for\n\t     * other windows.\n\t     * \"m\" is the minimal width when counting p_wiw for \"next_curwin\".\n\t     */\n\t    m = frame_minwidth(topfr, next_curwin);\n\t    room = width - m;\n\t    if (room < 0)\n\t    {\n\t\tnext_curwin_size = p_wiw + room;\n\t\troom = 0;\n\t    }\n\t    else\n\t    {\n\t\tnext_curwin_size = -1;\n\t\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t\t{\n\t\t    // If 'winfixwidth' set keep the window width if\n\t\t    // possible.\n\t\t    // Watch out for this window being the next_curwin.\n\t\t    if (frame_fixed_width(fr))\n\t\t    {\n\t\t\tn = frame_minwidth(fr, NOWIN);\n\t\t\tnew_size = fr->fr_width;\n\t\t\tif (frame_has_win(fr, next_curwin))\n\t\t\t{\n\t\t\t    room += p_wiw - p_wmw;\n\t\t\t    next_curwin_size = 0;\n\t\t\t    if (new_size < p_wiw)\n\t\t\t\tnew_size = p_wiw;\n\t\t\t}\n\t\t\telse\n\t\t\t    // These windows don't use up room.\n\t\t\t    totwincount -= (n + (fr->fr_next == NULL\n\t\t\t\t\t      ? extra_sep : 0)) / (p_wmw + 1);\n\t\t\troom -= new_size - n;\n\t\t\tif (room < 0)\n\t\t\t{\n\t\t\t    new_size += room;\n\t\t\t    room = 0;\n\t\t\t}\n\t\t\tfr->fr_newwidth = new_size;\n\t\t    }\n\t\t}\n\t\tif (next_curwin_size == -1)\n\t\t{\n\t\t    if (!has_next_curwin)\n\t\t\tnext_curwin_size = 0;\n\t\t    else if (totwincount > 1\n\t\t\t    && (room + (totwincount - 2))\n\t\t\t\t\t\t  / (totwincount - 1) > p_wiw)\n\t\t    {\n\t\t\t// Can make all windows wider than 'winwidth', spread\n\t\t\t// the room equally.\n\t\t\tnext_curwin_size = (room + p_wiw\n\t\t\t\t\t    + (totwincount - 1) * p_wmw\n\t\t\t\t\t    + (totwincount - 1)) / totwincount;\n\t\t\troom -= next_curwin_size - p_wiw;\n\t\t    }\n\t\t    else\n\t\t\tnext_curwin_size = p_wiw;\n\t\t}\n\t    }\n\n\t    if (has_next_curwin)\n\t\t--totwincount;\t\t// don't count curwin\n\t}\n\n\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t{\n\t    wincount = 1;\n\t    if (fr->fr_next == NULL)\n\t\t// last frame gets all that remains (avoid roundoff error)\n\t\tnew_size = width;\n\t    else if (dir == 'v')\n\t\tnew_size = fr->fr_width;\n\t    else if (frame_fixed_width(fr))\n\t    {\n\t\tnew_size = fr->fr_newwidth;\n\t\twincount = 0;\t    // doesn't count as a sizeable window\n\t    }\n\t    else\n\t    {\n\t\t// Compute the maximum number of windows horiz. in \"fr\".\n\t\tn = frame_minwidth(fr, NOWIN);\n\t\twincount = (n + (fr->fr_next == NULL ? extra_sep : 0))\n\t\t\t\t\t\t\t\t/ (p_wmw + 1);\n\t\tm = frame_minwidth(fr, next_curwin);\n\t\tif (has_next_curwin)\n\t\t    hnc = frame_has_win(fr, next_curwin);\n\t\telse\n\t\t    hnc = FALSE;\n\t\tif (hnc)\t    // don't count next_curwin\n\t\t    --wincount;\n\t\tif (totwincount == 0)\n\t\t    new_size = room;\n\t\telse\n\t\t    new_size = (wincount * room + ((unsigned)totwincount >> 1))\n\t\t\t\t\t\t\t\t/ totwincount;\n\t\tif (hnc)\t    // add next_curwin size\n\t\t{\n\t\t    next_curwin_size -= p_wiw - (m - n);\n\t\t    new_size += next_curwin_size;\n\t\t    room -= new_size - next_curwin_size;\n\t\t}\n\t\telse\n\t\t    room -= new_size;\n\t\tnew_size += n;\n\t    }\n\n\t    // Skip frame that is full width when splitting or closing a\n\t    // window, unless equalizing all frames.\n\t    if (!current || dir != 'v' || topfr->fr_parent != NULL\n\t\t    || (new_size != fr->fr_width)\n\t\t    || frame_has_win(fr, next_curwin))\n\t\twin_equal_rec(next_curwin, current, fr, dir, col, row,\n\t\t\t\t\t\t\t    new_size, height);\n\t    col += new_size;\n\t    width -= new_size;\n\t    totwincount -= wincount;\n\t}\n    }\n    else // topfr->fr_layout == FR_COL\n    {\n\ttopfr->fr_width = width;\n\ttopfr->fr_height = height;\n\n\tif (dir != 'h')\t\t\t// equalize frame heights\n\t{\n\t    // Compute maximum number of windows vertically in this frame.\n\t    n = frame_minheight(topfr, NOWIN);\n\t    // add one for the bottom window if it doesn't have a statusline\n\t    if (row + height == cmdline_row && p_ls == 0)\n\t\textra_sep = 1;\n\t    else\n\t\textra_sep = 0;\n\t    totwincount = (n + extra_sep) / (p_wmh + 1);\n\t    has_next_curwin = frame_has_win(topfr, next_curwin);\n\n\t    /*\n\t     * Compute height for \"next_curwin\" window and room available for\n\t     * other windows.\n\t     * \"m\" is the minimal height when counting p_wh for \"next_curwin\".\n\t     */\n\t    m = frame_minheight(topfr, next_curwin);\n\t    room = height - m;\n\t    if (room < 0)\n\t    {\n\t\t// The room is less than 'winheight', use all space for the\n\t\t// current window.\n\t\tnext_curwin_size = p_wh + room;\n\t\troom = 0;\n\t    }\n\t    else\n\t    {\n\t\tnext_curwin_size = -1;\n\t\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t\t{\n\t\t    // If 'winfixheight' set keep the window height if\n\t\t    // possible.\n\t\t    // Watch out for this window being the next_curwin.\n\t\t    if (frame_fixed_height(fr))\n\t\t    {\n\t\t\tn = frame_minheight(fr, NOWIN);\n\t\t\tnew_size = fr->fr_height;\n\t\t\tif (frame_has_win(fr, next_curwin))\n\t\t\t{\n\t\t\t    room += p_wh - p_wmh;\n\t\t\t    next_curwin_size = 0;\n\t\t\t    if (new_size < p_wh)\n\t\t\t\tnew_size = p_wh;\n\t\t\t}\n\t\t\telse\n\t\t\t    // These windows don't use up room.\n\t\t\t    totwincount -= (n + (fr->fr_next == NULL\n\t\t\t\t\t      ? extra_sep : 0)) / (p_wmh + 1);\n\t\t\troom -= new_size - n;\n\t\t\tif (room < 0)\n\t\t\t{\n\t\t\t    new_size += room;\n\t\t\t    room = 0;\n\t\t\t}\n\t\t\tfr->fr_newheight = new_size;\n\t\t    }\n\t\t}\n\t\tif (next_curwin_size == -1)\n\t\t{\n\t\t    if (!has_next_curwin)\n\t\t\tnext_curwin_size = 0;\n\t\t    else if (totwincount > 1\n\t\t\t    && (room + (totwincount - 2))\n\t\t\t\t\t\t   / (totwincount - 1) > p_wh)\n\t\t    {\n\t\t\t// can make all windows higher than 'winheight',\n\t\t\t// spread the room equally.\n\t\t\tnext_curwin_size = (room + p_wh\n\t\t\t\t\t   + (totwincount - 1) * p_wmh\n\t\t\t\t\t   + (totwincount - 1)) / totwincount;\n\t\t\troom -= next_curwin_size - p_wh;\n\t\t    }\n\t\t    else\n\t\t\tnext_curwin_size = p_wh;\n\t\t}\n\t    }\n\n\t    if (has_next_curwin)\n\t\t--totwincount;\t\t// don't count curwin\n\t}\n\n\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t{\n\t    wincount = 1;\n\t    if (fr->fr_next == NULL)\n\t\t// last frame gets all that remains (avoid roundoff error)\n\t\tnew_size = height;\n\t    else if (dir == 'h')\n\t\tnew_size = fr->fr_height;\n\t    else if (frame_fixed_height(fr))\n\t    {\n\t\tnew_size = fr->fr_newheight;\n\t\twincount = 0;\t    // doesn't count as a sizeable window\n\t    }\n\t    else\n\t    {\n\t\t// Compute the maximum number of windows vert. in \"fr\".\n\t\tn = frame_minheight(fr, NOWIN);\n\t\twincount = (n + (fr->fr_next == NULL ? extra_sep : 0))\n\t\t\t\t\t\t\t\t/ (p_wmh + 1);\n\t\tm = frame_minheight(fr, next_curwin);\n\t\tif (has_next_curwin)\n\t\t    hnc = frame_has_win(fr, next_curwin);\n\t\telse\n\t\t    hnc = FALSE;\n\t\tif (hnc)\t    // don't count next_curwin\n\t\t    --wincount;\n\t\tif (totwincount == 0)\n\t\t    new_size = room;\n\t\telse\n\t\t    new_size = (wincount * room + ((unsigned)totwincount >> 1))\n\t\t\t\t\t\t\t\t/ totwincount;\n\t\tif (hnc)\t    // add next_curwin size\n\t\t{\n\t\t    next_curwin_size -= p_wh - (m - n);\n\t\t    new_size += next_curwin_size;\n\t\t    room -= new_size - next_curwin_size;\n\t\t}\n\t\telse\n\t\t    room -= new_size;\n\t\tnew_size += n;\n\t    }\n\t    // Skip frame that is full width when splitting or closing a\n\t    // window, unless equalizing all frames.\n\t    if (!current || dir != 'h' || topfr->fr_parent != NULL\n\t\t    || (new_size != fr->fr_height)\n\t\t    || frame_has_win(fr, next_curwin))\n\t\twin_equal_rec(next_curwin, current, fr, dir, col, row,\n\t\t\t\t\t\t\t     width, new_size);\n\t    row += new_size;\n\t    height -= new_size;\n\t    totwincount -= wincount;\n\t}\n    }\n}\n\n#ifdef FEAT_JOB_CHANNEL\n    static void\nleaving_window(win_T *win)\n{\n    // Only matters for a prompt window.\n    if (!bt_prompt(win->w_buffer))\n\treturn;\n\n    // When leaving a prompt window stop Insert mode and perhaps restart\n    // it when entering that window again.\n    win->w_buffer->b_prompt_insert = restart_edit;\n    if (restart_edit != 0 && mode_displayed)\n\tclear_cmdline = TRUE;\t\t// unshow mode later\n    restart_edit = NUL;\n\n    // When leaving the window (or closing the window) was done from a\n    // callback we need to break out of the Insert mode loop and restart Insert\n    // mode when entering the window again.\n    if (State & MODE_INSERT)\n    {\n\tstop_insert_mode = TRUE;\n\tif (win->w_buffer->b_prompt_insert == NUL)\n\t    win->w_buffer->b_prompt_insert = 'A';\n    }\n}\n\n    void\nentering_window(win_T *win)\n{\n    // Only matters for a prompt window.\n    if (!bt_prompt(win->w_buffer))\n\treturn;\n\n    // When switching to a prompt buffer that was in Insert mode, don't stop\n    // Insert mode, it may have been set in leaving_window().\n    if (win->w_buffer->b_prompt_insert != NUL)\n\tstop_insert_mode = FALSE;\n\n    // When entering the prompt window restart Insert mode if we were in Insert\n    // mode when we left it and not already in Insert mode.\n    if ((State & MODE_INSERT) == 0)\n\trestart_edit = win->w_buffer->b_prompt_insert;\n}\n#endif\n\n    static void\nwin_init_empty(win_T *wp)\n{\n    redraw_win_later(wp, NOT_VALID);\n    wp->w_lines_valid = 0;\n    wp->w_cursor.lnum = 1;\n    wp->w_curswant = wp->w_cursor.col = 0;\n    wp->w_cursor.coladd = 0;\n    wp->w_pcmark.lnum = 1;\t// pcmark not cleared but set to line 1\n    wp->w_pcmark.col = 0;\n    wp->w_prev_pcmark.lnum = 0;\n    wp->w_prev_pcmark.col = 0;\n    wp->w_topline = 1;\n#ifdef FEAT_DIFF\n    wp->w_topfill = 0;\n#endif\n    wp->w_botline = 2;\n#if defined(FEAT_SYN_HL) || defined(FEAT_SPELL)\n    wp->w_s = &wp->w_buffer->b_s;\n#endif\n#ifdef FEAT_TERMINAL\n    term_reset_wincolor(wp);\n#endif\n}\n\n/*\n * Init the current window \"curwin\".\n * Called when a new file is being edited.\n */\n    void\ncurwin_init(void)\n{\n    win_init_empty(curwin);\n}\n\n/*\n * Close all windows for buffer \"buf\".\n */\n    void\nclose_windows(\n    buf_T\t*buf,\n    int\t\tkeep_curwin)\t    // don't close \"curwin\"\n{\n    win_T\t*wp;\n    tabpage_T   *tp, *nexttp;\n    int\t\th = tabline_height();\n    int\t\tcount = tabpage_index(NULL);\n\n    ++RedrawingDisabled;\n\n    for (wp = firstwin; wp != NULL && !ONE_WINDOW; )\n    {\n\tif (wp->w_buffer == buf && (!keep_curwin || wp != curwin)\n\t\t&& !(wp->w_closing || wp->w_buffer->b_locked > 0))\n\t{\n\t    if (win_close(wp, FALSE) == FAIL)\n\t\t// If closing the window fails give up, to avoid looping\n\t\t// forever.\n\t\tbreak;\n\n\t    // Start all over, autocommands may change the window layout.\n\t    wp = firstwin;\n\t}\n\telse\n\t    wp = wp->w_next;\n    }\n\n    // Also check windows in other tab pages.\n    for (tp = first_tabpage; tp != NULL; tp = nexttp)\n    {\n\tnexttp = tp->tp_next;\n\tif (tp != curtab)\n\t    FOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t\tif (wp->w_buffer == buf\n\t\t    && !(wp->w_closing || wp->w_buffer->b_locked > 0))\n\t\t{\n\t\t    win_close_othertab(wp, FALSE, tp);\n\n\t\t    // Start all over, the tab page may be closed and\n\t\t    // autocommands may change the window layout.\n\t\t    nexttp = first_tabpage;\n\t\t    break;\n\t\t}\n    }\n\n    --RedrawingDisabled;\n\n    if (count != tabpage_index(NULL))\n\tapply_autocmds(EVENT_TABCLOSED, NULL, NULL, FALSE, curbuf);\n\n    redraw_tabline = TRUE;\n    if (h != tabline_height())\n\tshell_new_rows();\n}\n\n/*\n * Return TRUE if the current window is the only window that exists (ignoring\n * \"aucmd_win\").\n * Returns FALSE if there is a window, possibly in another tab page.\n */\n    static int\nlast_window(void)\n{\n    return (one_window() && first_tabpage->tp_next == NULL);\n}\n\n/*\n * Return TRUE if there is only one window other than \"aucmd_win\" in the\n * current tab page.\n */\n    int\none_window(void)\n{\n    win_T\t*wp;\n    int\t\tseen_one = FALSE;\n\n    FOR_ALL_WINDOWS(wp)\n    {\n\tif (wp != aucmd_win)\n\t{\n\t    if (seen_one)\n\t\treturn FALSE;\n\t    seen_one = TRUE;\n\t}\n    }\n    return TRUE;\n}\n\n/*\n * Close the possibly last window in a tab page.\n * Returns TRUE when the window was closed already.\n */\n    static int\nclose_last_window_tabpage(\n    win_T\t*win,\n    int\t\tfree_buf,\n    tabpage_T   *prev_curtab)\n{\n    if (ONE_WINDOW)\n    {\n\tbuf_T\t*old_curbuf = curbuf;\n\n\t/*\n\t * Closing the last window in a tab page.  First go to another tab\n\t * page and then close the window and the tab page.  This avoids that\n\t * curwin and curtab are invalid while we are freeing memory, they may\n\t * be used in GUI events.\n\t * Don't trigger autocommands yet, they may use wrong values, so do\n\t * that below.\n\t */\n\tgoto_tabpage_tp(alt_tabpage(), FALSE, TRUE);\n\tredraw_tabline = TRUE;\n\n\t// Safety check: Autocommands may have closed the window when jumping\n\t// to the other tab page.\n\tif (valid_tabpage(prev_curtab) && prev_curtab->tp_firstwin == win)\n\t{\n\t    int\t    h = tabline_height();\n\n\t    win_close_othertab(win, free_buf, prev_curtab);\n\t    if (h != tabline_height())\n\t\tshell_new_rows();\n\t}\n#ifdef FEAT_JOB_CHANNEL\n\tentering_window(curwin);\n#endif\n\t// Since goto_tabpage_tp above did not trigger *Enter autocommands, do\n\t// that now.\n\tapply_autocmds(EVENT_TABCLOSED, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\tif (old_curbuf != curbuf)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Close the buffer of \"win\" and unload it if \"action\" is DOBUF_UNLOAD.\n * \"action\" can also be zero (do nothing) or DOBUF_WIPE.\n * \"abort_if_last\" is passed to close_buffer(): abort closing if all other\n * windows are closed.\n */\n    static void\nwin_close_buffer(win_T *win, int action, int abort_if_last)\n{\n#ifdef FEAT_SYN_HL\n    // Free independent synblock before the buffer is freed.\n    if (win->w_buffer != NULL)\n\treset_synblock(win);\n#endif\n\n#ifdef FEAT_QUICKFIX\n    // When a quickfix/location list window is closed and the buffer is\n    // displayed in only one window, then unlist the buffer.\n    if (win->w_buffer != NULL && bt_quickfix(win->w_buffer)\n\t\t\t\t\t&& win->w_buffer->b_nwindows == 1)\n\twin->w_buffer->b_p_bl = FALSE;\n#endif\n\n    // Close the link to the buffer.\n    if (win->w_buffer != NULL)\n    {\n\tbufref_T    bufref;\n\n\tset_bufref(&bufref, curbuf);\n\twin->w_closing = TRUE;\n\tclose_buffer(win, win->w_buffer, action, abort_if_last, TRUE);\n\tif (win_valid_any_tab(win))\n\t    win->w_closing = FALSE;\n\t// Make sure curbuf is valid. It can become invalid if 'bufhidden' is\n\t// \"wipe\".\n\tif (!bufref_valid(&bufref))\n\t    curbuf = firstbuf;\n    }\n}\n\n/*\n * Close window \"win\".  Only works for the current tab page.\n * If \"free_buf\" is TRUE related buffer may be unloaded.\n *\n * Called by :quit, :close, :xit, :wq and findtag().\n * Returns FAIL when the window was not closed.\n */\n    int\nwin_close(win_T *win, int free_buf)\n{\n    win_T\t*wp;\n    int\t\tother_buffer = FALSE;\n    int\t\tclose_curwin = FALSE;\n    int\t\tdir;\n    int\t\thelp_window = FALSE;\n    tabpage_T   *prev_curtab = curtab;\n    frame_T\t*win_frame = win->w_frame->fr_parent;\n#ifdef FEAT_DIFF\n    int\t\thad_diffmode = win->w_p_diff;\n#endif\n#ifdef MESSAGE_QUEUE\n    int\t\tdid_decrement = FALSE;\n#endif\n\n#if defined(FEAT_TERMINAL) && defined(FEAT_PROP_POPUP)\n    // Can close a popup window with a terminal if the job has finished.\n    if (may_close_term_popup() == OK)\n\treturn OK;\n#endif\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn FAIL;\n\n    if (last_window())\n    {\n\temsg(_(e_cannot_close_last_window));\n\treturn FAIL;\n    }\n\n    if (win->w_closing || (win->w_buffer != NULL\n\t\t\t\t\t       && win->w_buffer->b_locked > 0))\n\treturn FAIL; // window is already being closed\n    if (win_unlisted(win))\n    {\n\temsg(_(e_cannot_close_autocmd_or_popup_window));\n\treturn FAIL;\n    }\n    if ((firstwin == aucmd_win || lastwin == aucmd_win) && one_window())\n    {\n\temsg(_(e_cannot_close_window_only_autocmd_window_would_remain));\n\treturn FAIL;\n    }\n\n    // When closing the last window in a tab page first go to another tab page\n    // and then close the window and the tab page to avoid that curwin and\n    // curtab are invalid while we are freeing memory.\n    if (close_last_window_tabpage(win, free_buf, prev_curtab))\n      return FAIL;\n\n    // When closing the help window, try restoring a snapshot after closing\n    // the window.  Otherwise clear the snapshot, it's now invalid.\n    if (bt_help(win->w_buffer))\n\thelp_window = TRUE;\n    else\n\tclear_snapshot(curtab, SNAP_HELP_IDX);\n\n    if (win == curwin)\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tleaving_window(curwin);\n#endif\n\t/*\n\t * Guess which window is going to be the new current window.\n\t * This may change because of the autocommands (sigh).\n\t */\n\twp = frame2win(win_altframe(win, NULL));\n\n\t/*\n\t * Be careful: If autocommands delete the window or cause this window\n\t * to be the last one left, return now.\n\t */\n\tif (wp->w_buffer != curbuf)\n\t{\n\t    other_buffer = TRUE;\n\t    win->w_closing = TRUE;\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    if (!win_valid(win))\n\t\treturn FAIL;\n\t    win->w_closing = FALSE;\n\t    if (last_window())\n\t\treturn FAIL;\n\t}\n\twin->w_closing = TRUE;\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (!win_valid(win))\n\t    return FAIL;\n\twin->w_closing = FALSE;\n\tif (last_window())\n\t    return FAIL;\n#ifdef FEAT_EVAL\n\t// autocmds may abort script processing\n\tif (aborting())\n\t    return FAIL;\n#endif\n    }\n\n#ifdef FEAT_GUI\n    // Avoid trouble with scrollbars that are going to be deleted in\n    // win_free().\n    if (gui.in_use)\n\tout_flush();\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    if (popup_win_closed(win) && !win_valid(win))\n\treturn FAIL;\n#endif\n\n    // Trigger WinClosed just before starting to free window-related resources.\n    trigger_winclosed(win);\n    // autocmd may have freed the window already.\n    if (!win_valid_any_tab(win))\n\treturn OK;\n\n    win_close_buffer(win, free_buf ? DOBUF_UNLOAD : 0, TRUE);\n\n    if (only_one_window() && win_valid(win) && win->w_buffer == NULL\n\t    && (last_window() || curtab != prev_curtab\n\t\t|| close_last_window_tabpage(win, free_buf, prev_curtab)))\n    {\n\t// Autocommands have closed all windows, quit now.  Restore\n\t// curwin->w_buffer, otherwise writing viminfo may fail.\n\tif (curwin->w_buffer == NULL)\n\t    curwin->w_buffer = curbuf;\n\tgetout(0);\n    }\n\n    // Autocommands may have moved to another tab page.\n    if (curtab != prev_curtab && win_valid_any_tab(win)\n\t\t\t\t\t\t      && win->w_buffer == NULL)\n    {\n\t// Need to close the window anyway, since the buffer is NULL.\n\twin_close_othertab(win, FALSE, prev_curtab);\n\treturn FAIL;\n    }\n\n    // Autocommands may have closed the window already or closed the only\n    // other window.\n    if (!win_valid(win) || last_window()\n\t    || close_last_window_tabpage(win, free_buf, prev_curtab))\n\treturn FAIL;\n\n    // Now we are really going to close the window.  Disallow any autocommand\n    // to split a window to avoid trouble.\n    // Also bail out of parse_queued_messages() to avoid it tries to update the\n    // screen.\n    ++split_disallowed;\n#ifdef MESSAGE_QUEUE\n    ++dont_parse_messages;\n#endif\n\n    // Free the memory used for the window and get the window that received\n    // the screen space.\n    wp = win_free_mem(win, &dir, NULL);\n\n    if (help_window)\n    {\n\t// Closing the help window moves the cursor back to the current window\n\t// of the snapshot.\n\twin_T *prev_win = get_snapshot_curwin(SNAP_HELP_IDX);\n\n\tif (win_valid(prev_win))\n\t    wp = prev_win;\n    }\n\n    // Make sure curwin isn't invalid.  It can cause severe trouble when\n    // printing an error message.  For win_equal() curbuf needs to be valid\n    // too.\n    if (win == curwin)\n    {\n\tcurwin = wp;\n#ifdef FEAT_QUICKFIX\n\tif (wp->w_p_pvw || bt_quickfix(wp->w_buffer))\n\t{\n\t    /*\n\t     * If the cursor goes to the preview or the quickfix window, try\n\t     * finding another window to go to.\n\t     */\n\t    for (;;)\n\t    {\n\t\tif (wp->w_next == NULL)\n\t\t    wp = firstwin;\n\t\telse\n\t\t    wp = wp->w_next;\n\t\tif (wp == curwin)\n\t\t    break;\n\t\tif (!wp->w_p_pvw && !bt_quickfix(wp->w_buffer))\n\t\t{\n\t\t    curwin = wp;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n#endif\n\tcurbuf = curwin->w_buffer;\n\tclose_curwin = TRUE;\n\n\t// The cursor position may be invalid if the buffer changed after last\n\t// using the window.\n\tcheck_cursor();\n    }\n    if (p_ea && (*p_ead == 'b' || *p_ead == dir))\n\t// If the frame of the closed window contains the new current window,\n\t// only resize that frame.  Otherwise resize all windows.\n\twin_equal(curwin, curwin->w_frame->fr_parent == win_frame, dir);\n    else\n\twin_comp_pos();\n    if (close_curwin)\n    {\n\t// Pass WEE_ALLOW_PARSE_MESSAGES to decrement dont_parse_messages\n\t// before autocommands.\n#ifdef MESSAGE_QUEUE\n\tdid_decrement =\n#else\n\t(void)\n#endif\n\t    win_enter_ext(wp,\n\t\tWEE_CURWIN_INVALID | WEE_TRIGGER_ENTER_AUTOCMDS\n\t\t      | WEE_TRIGGER_LEAVE_AUTOCMDS | WEE_ALLOW_PARSE_MESSAGES);\n\tif (other_buffer)\n\t    // careful: after this wp and win may be invalid!\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    --split_disallowed;\n#ifdef MESSAGE_QUEUE\n    if (!did_decrement)\n\t--dont_parse_messages;\n#endif\n\n    /*\n     * If last window has a status line now and we don't want one,\n     * remove the status line.\n     */\n    last_status(FALSE);\n\n    // After closing the help window, try restoring the window layout from\n    // before it was opened.\n    if (help_window)\n\trestore_snapshot(SNAP_HELP_IDX, close_curwin);\n\n#ifdef FEAT_DIFF\n    // If the window had 'diff' set and now there is only one window left in\n    // the tab page with 'diff' set, and \"closeoff\" is in 'diffopt', then\n    // execute \":diffoff!\".\n    if (diffopt_closeoff() && had_diffmode && curtab == prev_curtab)\n    {\n\tint\tdiffcount = 0;\n\twin_T\t*dwin;\n\n\tFOR_ALL_WINDOWS(dwin)\n\t    if (dwin->w_p_diff)\n\t\t++diffcount;\n\tif (diffcount == 1)\n\t    do_cmdline_cmd((char_u *)\"diffoff!\");\n    }\n#endif\n\n#if defined(FEAT_GUI)\n    // When 'guioptions' includes 'L' or 'R' may have to remove scrollbars.\n    if (gui.in_use && !win_hasvertsplit())\n\tgui_init_which_components(NULL);\n#endif\n\n    redraw_all_later(NOT_VALID);\n    return OK;\n}\n\n    static void\ntrigger_winclosed(win_T *win)\n{\n    static int\trecursive = FALSE;\n    char_u\twinid[NUMBUFLEN];\n\n    if (recursive)\n\treturn;\n    recursive = TRUE;\n    vim_snprintf((char *)winid, sizeof(winid), \"%d\", win->w_id);\n    apply_autocmds(EVENT_WINCLOSED, winid, winid, FALSE, win->w_buffer);\n    recursive = FALSE;\n}\n\n/*\n * Trigger WinScrolled for \"curwin\" if needed.\n */\n    void\nmay_trigger_winscrolled(void)\n{\n    win_T\t    *wp = curwin;\n    static int\t    recursive = FALSE;\n    char_u\t    winid[NUMBUFLEN];\n\n    if (recursive || !has_winscrolled())\n\treturn;\n\n    if (wp->w_last_topline != wp->w_topline\n\t    || wp->w_last_leftcol != wp->w_leftcol\n\t    || wp->w_last_width != wp->w_width\n\t    || wp->w_last_height != wp->w_height)\n    {\n\tvim_snprintf((char *)winid, sizeof(winid), \"%d\", wp->w_id);\n\n\trecursive = TRUE;\n\tapply_autocmds(EVENT_WINSCROLLED, winid, winid, FALSE, wp->w_buffer);\n\trecursive = FALSE;\n\n\t// an autocmd may close the window, \"wp\" may be invalid now\n\tif (win_valid_any_tab(wp))\n\t{\n\t    wp->w_last_topline = wp->w_topline;\n\t    wp->w_last_leftcol = wp->w_leftcol;\n\t    wp->w_last_width = wp->w_width;\n\t    wp->w_last_height = wp->w_height;\n\t}\n    }\n}\n\n/*\n * Close window \"win\" in tab page \"tp\", which is not the current tab page.\n * This may be the last window in that tab page and result in closing the tab,\n * thus \"tp\" may become invalid!\n * Caller must check if buffer is hidden and whether the tabline needs to be\n * updated.\n */\n    void\nwin_close_othertab(win_T *win, int free_buf, tabpage_T *tp)\n{\n    win_T\t*wp;\n    int\t\tdir;\n    tabpage_T   *ptp = NULL;\n    int\t\tfree_tp = FALSE;\n\n    // Get here with win->w_buffer == NULL when win_close() detects the tab\n    // page changed.\n    if (win->w_closing || (win->w_buffer != NULL\n\t\t\t\t\t       && win->w_buffer->b_locked > 0))\n\treturn; // window is already being closed\n\n    // Trigger WinClosed just before starting to free window-related resources.\n    trigger_winclosed(win);\n    // autocmd may have freed the window already.\n    if (!win_valid_any_tab(win))\n\treturn;\n\n    if (win->w_buffer != NULL)\n\t// Close the link to the buffer.\n\tclose_buffer(win, win->w_buffer, free_buf ? DOBUF_UNLOAD : 0,\n\t\t\t\t\t\t\t\t FALSE, TRUE);\n\n    // Careful: Autocommands may have closed the tab page or made it the\n    // current tab page.\n    for (ptp = first_tabpage; ptp != NULL && ptp != tp; ptp = ptp->tp_next)\n\t;\n    if (ptp == NULL || tp == curtab)\n    {\n\t// If the buffer was removed from the window we have to give it any\n\t// buffer.\n\tif (win_valid_any_tab(win) && win->w_buffer == NULL)\n\t{\n\t    win->w_buffer = firstbuf;\n\t    ++firstbuf->b_nwindows;\n\t    win_init_empty(win);\n\t}\n\treturn;\n    }\n\n    // Autocommands may have closed the window already.\n    for (wp = tp->tp_firstwin; wp != NULL && wp != win; wp = wp->w_next)\n\t;\n    if (wp == NULL)\n\treturn;\n\n    // When closing the last window in a tab page remove the tab page.\n    if (tp->tp_firstwin == tp->tp_lastwin)\n    {\n\tif (tp == first_tabpage)\n\t    first_tabpage = tp->tp_next;\n\telse\n\t{\n\t    for (ptp = first_tabpage; ptp != NULL && ptp->tp_next != tp;\n\t\t\t\t\t\t\t   ptp = ptp->tp_next)\n\t\t;\n\t    if (ptp == NULL)\n\t    {\n\t\tinternal_error(\"win_close_othertab()\");\n\t\treturn;\n\t    }\n\t    ptp->tp_next = tp->tp_next;\n\t}\n\tfree_tp = TRUE;\n    }\n\n    // Free the memory used for the window.\n    win_free_mem(win, &dir, tp);\n\n    if (free_tp)\n\tfree_tabpage(tp);\n}\n\n/*\n * Free the memory used for a window.\n * Returns a pointer to the window that got the freed up space.\n */\n    static win_T *\nwin_free_mem(\n    win_T\t*win,\n    int\t\t*dirp,\t\t// set to 'v' or 'h' for direction if 'ea'\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    frame_T\t*frp;\n    win_T\t*wp;\n    tabpage_T\t*win_tp = tp == NULL ? curtab : tp;\n\n    // Remove the window and its frame from the tree of frames.\n    frp = win->w_frame;\n    wp = winframe_remove(win, dirp, tp);\n    vim_free(frp);\n    win_free(win, tp);\n\n    // When deleting the current window in the tab, select a new current\n    // window.\n    if (win == win_tp->tp_curwin)\n\twin_tp->tp_curwin = wp;\n\n    return wp;\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nwin_free_all(void)\n{\n    int\t\tdummy;\n\n#ifdef FEAT_CMDWIN\n    // avoid an error for switching tabpage with the cmdline window open\n    cmdwin_type = 0;\n#endif\n    while (first_tabpage->tp_next != NULL)\n\ttabpage_close(TRUE);\n\n    if (aucmd_win != NULL)\n    {\n\t(void)win_free_mem(aucmd_win, &dummy, NULL);\n\taucmd_win = NULL;\n    }\n\n    while (firstwin != NULL)\n\t(void)win_free_mem(firstwin, &dummy, NULL);\n\n    // No window should be used after this. Set curwin to NULL to crash\n    // instead of using freed memory.\n    curwin = NULL;\n}\n#endif\n\n/*\n * Remove a window and its frame from the tree of frames.\n * Returns a pointer to the window that got the freed up space.\n */\n    win_T *\nwinframe_remove(\n    win_T\t*win,\n    int\t\t*dirp UNUSED,\t// set to 'v' or 'h' for direction if 'ea'\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    frame_T\t*frp, *frp2, *frp3;\n    frame_T\t*frp_close = win->w_frame;\n    win_T\t*wp;\n\n    /*\n     * If there is only one window there is nothing to remove.\n     */\n    if (tp == NULL ? ONE_WINDOW : tp->tp_firstwin == tp->tp_lastwin)\n\treturn NULL;\n\n    /*\n     * Remove the window from its frame.\n     */\n    frp2 = win_altframe(win, tp);\n    wp = frame2win(frp2);\n\n    // Remove this frame from the list of frames.\n    frame_remove(frp_close);\n\n    if (frp_close->fr_parent->fr_layout == FR_COL)\n    {\n\t// When 'winfixheight' is set, try to find another frame in the column\n\t// (as close to the closed frame as possible) to distribute the height\n\t// to.\n\tif (frp2->fr_win != NULL && frp2->fr_win->w_p_wfh)\n\t{\n\t    frp = frp_close->fr_prev;\n\t    frp3 = frp_close->fr_next;\n\t    while (frp != NULL || frp3 != NULL)\n\t    {\n\t\tif (frp != NULL)\n\t\t{\n\t\t    if (!frame_fixed_height(frp))\n\t\t    {\n\t\t\tfrp2 = frp;\n\t\t\twp = frame2win(frp2);\n\t\t\tbreak;\n\t\t    }\n\t\t    frp = frp->fr_prev;\n\t\t}\n\t\tif (frp3 != NULL)\n\t\t{\n\t\t    if (frp3->fr_win != NULL && !frp3->fr_win->w_p_wfh)\n\t\t    {\n\t\t\tfrp2 = frp3;\n\t\t\twp = frp3->fr_win;\n\t\t\tbreak;\n\t\t    }\n\t\t    frp3 = frp3->fr_next;\n\t\t}\n\t    }\n\t}\n\tframe_new_height(frp2, frp2->fr_height + frp_close->fr_height,\n\t\t\t    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);\n\t*dirp = 'v';\n    }\n    else\n    {\n\t// When 'winfixwidth' is set, try to find another frame in the column\n\t// (as close to the closed frame as possible) to distribute the width\n\t// to.\n\tif (frp2->fr_win != NULL && frp2->fr_win->w_p_wfw)\n\t{\n\t    frp = frp_close->fr_prev;\n\t    frp3 = frp_close->fr_next;\n\t    while (frp != NULL || frp3 != NULL)\n\t    {\n\t\tif (frp != NULL)\n\t\t{\n\t\t    if (!frame_fixed_width(frp))\n\t\t    {\n\t\t\tfrp2 = frp;\n\t\t\twp = frame2win(frp2);\n\t\t\tbreak;\n\t\t    }\n\t\t    frp = frp->fr_prev;\n\t\t}\n\t\tif (frp3 != NULL)\n\t\t{\n\t\t    if (frp3->fr_win != NULL && !frp3->fr_win->w_p_wfw)\n\t\t    {\n\t\t\tfrp2 = frp3;\n\t\t\twp = frp3->fr_win;\n\t\t\tbreak;\n\t\t    }\n\t\t    frp3 = frp3->fr_next;\n\t\t}\n\t    }\n\t}\n\tframe_new_width(frp2, frp2->fr_width + frp_close->fr_width,\n\t\t\t    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);\n\t*dirp = 'h';\n    }\n\n    // If rows/columns go to a window below/right its positions need to be\n    // updated.  Can only be done after the sizes have been updated.\n    if (frp2 == frp_close->fr_next)\n    {\n\tint row = win->w_winrow;\n\tint col = win->w_wincol;\n\n\tframe_comp_pos(frp2, &row, &col);\n    }\n\n    if (frp2->fr_next == NULL && frp2->fr_prev == NULL)\n    {\n\t// There is no other frame in this list, move its info to the parent\n\t// and remove it.\n\tfrp2->fr_parent->fr_layout = frp2->fr_layout;\n\tfrp2->fr_parent->fr_child = frp2->fr_child;\n\tFOR_ALL_FRAMES(frp, frp2->fr_child)\n\t    frp->fr_parent = frp2->fr_parent;\n\tfrp2->fr_parent->fr_win = frp2->fr_win;\n\tif (frp2->fr_win != NULL)\n\t    frp2->fr_win->w_frame = frp2->fr_parent;\n\tfrp = frp2->fr_parent;\n\tif (topframe->fr_child == frp2)\n\t    topframe->fr_child = frp;\n\tvim_free(frp2);\n\n\tfrp2 = frp->fr_parent;\n\tif (frp2 != NULL && frp2->fr_layout == frp->fr_layout)\n\t{\n\t    // The frame above the parent has the same layout, have to merge\n\t    // the frames into this list.\n\t    if (frp2->fr_child == frp)\n\t\tfrp2->fr_child = frp->fr_child;\n\t    frp->fr_child->fr_prev = frp->fr_prev;\n\t    if (frp->fr_prev != NULL)\n\t\tfrp->fr_prev->fr_next = frp->fr_child;\n\t    for (frp3 = frp->fr_child; ; frp3 = frp3->fr_next)\n\t    {\n\t\tfrp3->fr_parent = frp2;\n\t\tif (frp3->fr_next == NULL)\n\t\t{\n\t\t    frp3->fr_next = frp->fr_next;\n\t\t    if (frp->fr_next != NULL)\n\t\t\tfrp->fr_next->fr_prev = frp3;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (topframe->fr_child == frp)\n\t\ttopframe->fr_child = frp2;\n\t    vim_free(frp);\n\t}\n    }\n\n    return wp;\n}\n\n/*\n * Return a pointer to the frame that will receive the empty screen space that\n * is left over after \"win\" is closed.\n *\n * If 'splitbelow' or 'splitright' is set, the space goes above or to the left\n * by default.  Otherwise, the free space goes below or to the right.  The\n * result is that opening a window and then immediately closing it will\n * preserve the initial window layout.  The 'wfh' and 'wfw' settings are\n * respected when possible.\n */\n    static frame_T *\nwin_altframe(\n    win_T\t*win,\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    frame_T\t*frp;\n    frame_T\t*other_fr, *target_fr;\n\n    if (tp == NULL ? ONE_WINDOW : tp->tp_firstwin == tp->tp_lastwin)\n\treturn alt_tabpage()->tp_curwin->w_frame;\n\n    frp = win->w_frame;\n\n    if (frp->fr_prev == NULL)\n\treturn frp->fr_next;\n    if (frp->fr_next == NULL)\n\treturn frp->fr_prev;\n\n    // By default the next window will get the space that was abandoned by this\n    // window\n    target_fr = frp->fr_next;\n    other_fr  = frp->fr_prev;\n\n    // If this is part of a column of windows and 'splitbelow' is true then the\n    // previous window will get the space.\n    if (frp->fr_parent != NULL && frp->fr_parent->fr_layout == FR_COL && p_sb)\n    {\n\ttarget_fr = frp->fr_prev;\n\tother_fr  = frp->fr_next;\n    }\n\n    // If this is part of a row of windows, and 'splitright' is true then the\n    // previous window will get the space.\n    if (frp->fr_parent != NULL && frp->fr_parent->fr_layout == FR_ROW && p_spr)\n    {\n\ttarget_fr = frp->fr_prev;\n\tother_fr  = frp->fr_next;\n    }\n\n    // If 'wfh' or 'wfw' is set for the target and not for the alternate\n    // window, reverse the selection.\n    if (frp->fr_parent != NULL && frp->fr_parent->fr_layout == FR_ROW)\n    {\n\tif (frame_fixed_width(target_fr) && !frame_fixed_width(other_fr))\n\t    target_fr = other_fr;\n    }\n    else\n    {\n\tif (frame_fixed_height(target_fr) && !frame_fixed_height(other_fr))\n\t    target_fr = other_fr;\n    }\n\n    return target_fr;\n}\n\n/*\n * Return the tabpage that will be used if the current one is closed.\n */\n    static tabpage_T *\nalt_tabpage(void)\n{\n    tabpage_T\t*tp;\n\n    // Use the next tab page if possible.\n    if (curtab->tp_next != NULL)\n\treturn curtab->tp_next;\n\n    // Find the last but one tab page.\n    for (tp = first_tabpage; tp->tp_next != curtab; tp = tp->tp_next)\n\t;\n    return tp;\n}\n\n/*\n * Find the left-upper window in frame \"frp\".\n */\n    static win_T *\nframe2win(frame_T *frp)\n{\n    while (frp->fr_win == NULL)\n\tfrp = frp->fr_child;\n    return frp->fr_win;\n}\n\n/*\n * Return TRUE if frame \"frp\" contains window \"wp\".\n */\n    static int\nframe_has_win(frame_T *frp, win_T *wp)\n{\n    frame_T\t*p;\n\n    if (frp->fr_layout == FR_LEAF)\n\treturn frp->fr_win == wp;\n\n    FOR_ALL_FRAMES(p, frp->fr_child)\n\tif (frame_has_win(p, wp))\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Set a new height for a frame.  Recursively sets the height for contained\n * frames and windows.  Caller must take care of positions.\n */\n    static void\nframe_new_height(\n    frame_T\t*topfrp,\n    int\t\theight,\n    int\t\ttopfirst,\t// resize topmost contained frame first\n    int\t\twfh)\t\t// obey 'winfixheight' when there is a choice;\n\t\t\t\t// may cause the height not to be set\n{\n    frame_T\t*frp;\n    int\t\textra_lines;\n    int\t\th;\n\n    if (topfrp->fr_win != NULL)\n    {\n\t// Simple case: just one window.\n\twin_new_height(topfrp->fr_win,\n\t\t\t\t    height - topfrp->fr_win->w_status_height\n\t\t\t\t\t      - WINBAR_HEIGHT(topfrp->fr_win));\n    }\n    else if (topfrp->fr_layout == FR_ROW)\n    {\n\tdo\n\t{\n\t    // All frames in this row get the same new height.\n\t    FOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    {\n\t\tframe_new_height(frp, height, topfirst, wfh);\n\t\tif (frp->fr_height > height)\n\t\t{\n\t\t    // Could not fit the windows, make the whole row higher.\n\t\t    height = frp->fr_height;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\twhile (frp != NULL);\n    }\n    else    // fr_layout == FR_COL\n    {\n\t// Complicated case: Resize a column of frames.  Resize the bottom\n\t// frame first, frames above that when needed.\n\n\tfrp = topfrp->fr_child;\n\tif (wfh)\n\t    // Advance past frames with one window with 'wfh' set.\n\t    while (frame_fixed_height(frp))\n\t    {\n\t\tfrp = frp->fr_next;\n\t\tif (frp == NULL)\n\t\t    return;\t    // no frame without 'wfh', give up\n\t    }\n\tif (!topfirst)\n\t{\n\t    // Find the bottom frame of this column\n\t    while (frp->fr_next != NULL)\n\t\tfrp = frp->fr_next;\n\t    if (wfh)\n\t\t// Advance back for frames with one window with 'wfh' set.\n\t\twhile (frame_fixed_height(frp))\n\t\t    frp = frp->fr_prev;\n\t}\n\n\textra_lines = height - topfrp->fr_height;\n\tif (extra_lines < 0)\n\t{\n\t    // reduce height of contained frames, bottom or top frame first\n\t    while (frp != NULL)\n\t    {\n\t\th = frame_minheight(frp, NULL);\n\t\tif (frp->fr_height + extra_lines < h)\n\t\t{\n\t\t    extra_lines += frp->fr_height - h;\n\t\t    frame_new_height(frp, h, topfirst, wfh);\n\t\t}\n\t\telse\n\t\t{\n\t\t    frame_new_height(frp, frp->fr_height + extra_lines,\n\t\t\t\t\t\t\t       topfirst, wfh);\n\t\t    break;\n\t\t}\n\t\tif (topfirst)\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_next;\n\t\t    while (wfh && frp != NULL && frame_fixed_height(frp));\n\t\t}\n\t\telse\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_prev;\n\t\t    while (wfh && frp != NULL && frame_fixed_height(frp));\n\t\t}\n\t\t// Increase \"height\" if we could not reduce enough frames.\n\t\tif (frp == NULL)\n\t\t    height -= extra_lines;\n\t    }\n\t}\n\telse if (extra_lines > 0)\n\t{\n\t    // increase height of bottom or top frame\n\t    frame_new_height(frp, frp->fr_height + extra_lines, topfirst, wfh);\n\t}\n    }\n    topfrp->fr_height = height;\n}\n\n/*\n * Return TRUE if height of frame \"frp\" should not be changed because of\n * the 'winfixheight' option.\n */\n    static int\nframe_fixed_height(frame_T *frp)\n{\n    // frame with one window: fixed height if 'winfixheight' set.\n    if (frp->fr_win != NULL)\n\treturn frp->fr_win->w_p_wfh;\n\n    if (frp->fr_layout == FR_ROW)\n    {\n\t// The frame is fixed height if one of the frames in the row is fixed\n\t// height.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    if (frame_fixed_height(frp))\n\t\treturn TRUE;\n\treturn FALSE;\n    }\n\n    // frp->fr_layout == FR_COL: The frame is fixed height if all of the\n    // frames in the row are fixed height.\n    FOR_ALL_FRAMES(frp, frp->fr_child)\n\tif (!frame_fixed_height(frp))\n\t    return FALSE;\n    return TRUE;\n}\n\n/*\n * Return TRUE if width of frame \"frp\" should not be changed because of\n * the 'winfixwidth' option.\n */\n    static int\nframe_fixed_width(frame_T *frp)\n{\n    // frame with one window: fixed width if 'winfixwidth' set.\n    if (frp->fr_win != NULL)\n\treturn frp->fr_win->w_p_wfw;\n\n    if (frp->fr_layout == FR_COL)\n    {\n\t// The frame is fixed width if one of the frames in the row is fixed\n\t// width.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    if (frame_fixed_width(frp))\n\t\treturn TRUE;\n\treturn FALSE;\n    }\n\n    // frp->fr_layout == FR_ROW: The frame is fixed width if all of the\n    // frames in the row are fixed width.\n    FOR_ALL_FRAMES(frp, frp->fr_child)\n\tif (!frame_fixed_width(frp))\n\t    return FALSE;\n    return TRUE;\n}\n\n/*\n * Add a status line to windows at the bottom of \"frp\".\n * Note: Does not check if there is room!\n */\n    static void\nframe_add_statusline(frame_T *frp)\n{\n    win_T\t*wp;\n\n    if (frp->fr_layout == FR_LEAF)\n    {\n\twp = frp->fr_win;\n\tif (wp->w_status_height == 0)\n\t{\n\t    if (wp->w_height > 0)\t// don't make it negative\n\t\t--wp->w_height;\n\t    wp->w_status_height = STATUS_HEIGHT;\n\t}\n    }\n    else if (frp->fr_layout == FR_ROW)\n    {\n\t// Handle all the frames in the row.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    frame_add_statusline(frp);\n    }\n    else // frp->fr_layout == FR_COL\n    {\n\t// Only need to handle the last frame in the column.\n\tfor (frp = frp->fr_child; frp->fr_next != NULL; frp = frp->fr_next)\n\t    ;\n\tframe_add_statusline(frp);\n    }\n}\n\n/*\n * Set width of a frame.  Handles recursively going through contained frames.\n * May remove separator line for windows at the right side (for win_close()).\n */\n    static void\nframe_new_width(\n    frame_T\t*topfrp,\n    int\t\twidth,\n    int\t\tleftfirst,\t// resize leftmost contained frame first\n    int\t\twfw)\t\t// obey 'winfixwidth' when there is a choice;\n\t\t\t\t// may cause the width not to be set\n{\n    frame_T\t*frp;\n    int\t\textra_cols;\n    int\t\tw;\n    win_T\t*wp;\n\n    if (topfrp->fr_layout == FR_LEAF)\n    {\n\t// Simple case: just one window.\n\twp = topfrp->fr_win;\n\t// Find out if there are any windows right of this one.\n\tfor (frp = topfrp; frp->fr_parent != NULL; frp = frp->fr_parent)\n\t    if (frp->fr_parent->fr_layout == FR_ROW && frp->fr_next != NULL)\n\t\tbreak;\n\tif (frp->fr_parent == NULL)\n\t    wp->w_vsep_width = 0;\n\twin_new_width(wp, width - wp->w_vsep_width);\n    }\n    else if (topfrp->fr_layout == FR_COL)\n    {\n\tdo\n\t{\n\t    // All frames in this column get the same new width.\n\t    FOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    {\n\t\tframe_new_width(frp, width, leftfirst, wfw);\n\t\tif (frp->fr_width > width)\n\t\t{\n\t\t    // Could not fit the windows, make whole column wider.\n\t\t    width = frp->fr_width;\n\t\t    break;\n\t\t}\n\t    }\n\t} while (frp != NULL);\n    }\n    else    // fr_layout == FR_ROW\n    {\n\t// Complicated case: Resize a row of frames.  Resize the rightmost\n\t// frame first, frames left of it when needed.\n\n\tfrp = topfrp->fr_child;\n\tif (wfw)\n\t    // Advance past frames with one window with 'wfw' set.\n\t    while (frame_fixed_width(frp))\n\t    {\n\t\tfrp = frp->fr_next;\n\t\tif (frp == NULL)\n\t\t    return;\t    // no frame without 'wfw', give up\n\t    }\n\tif (!leftfirst)\n\t{\n\t    // Find the rightmost frame of this row\n\t    while (frp->fr_next != NULL)\n\t\tfrp = frp->fr_next;\n\t    if (wfw)\n\t\t// Advance back for frames with one window with 'wfw' set.\n\t\twhile (frame_fixed_width(frp))\n\t\t    frp = frp->fr_prev;\n\t}\n\n\textra_cols = width - topfrp->fr_width;\n\tif (extra_cols < 0)\n\t{\n\t    // reduce frame width, rightmost frame first\n\t    while (frp != NULL)\n\t    {\n\t\tw = frame_minwidth(frp, NULL);\n\t\tif (frp->fr_width + extra_cols < w)\n\t\t{\n\t\t    extra_cols += frp->fr_width - w;\n\t\t    frame_new_width(frp, w, leftfirst, wfw);\n\t\t}\n\t\telse\n\t\t{\n\t\t    frame_new_width(frp, frp->fr_width + extra_cols,\n\t\t\t\t\t\t\t      leftfirst, wfw);\n\t\t    break;\n\t\t}\n\t\tif (leftfirst)\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_next;\n\t\t    while (wfw && frp != NULL && frame_fixed_width(frp));\n\t\t}\n\t\telse\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_prev;\n\t\t    while (wfw && frp != NULL && frame_fixed_width(frp));\n\t\t}\n\t\t// Increase \"width\" if we could not reduce enough frames.\n\t\tif (frp == NULL)\n\t\t    width -= extra_cols;\n\t    }\n\t}\n\telse if (extra_cols > 0)\n\t{\n\t    // increase width of rightmost frame\n\t    frame_new_width(frp, frp->fr_width + extra_cols, leftfirst, wfw);\n\t}\n    }\n    topfrp->fr_width = width;\n}\n\n/*\n * Add the vertical separator to windows at the right side of \"frp\".\n * Note: Does not check if there is room!\n */\n    static void\nframe_add_vsep(frame_T *frp)\n{\n    win_T\t*wp;\n\n    if (frp->fr_layout == FR_LEAF)\n    {\n\twp = frp->fr_win;\n\tif (wp->w_vsep_width == 0)\n\t{\n\t    if (wp->w_width > 0)\t// don't make it negative\n\t\t--wp->w_width;\n\t    wp->w_vsep_width = 1;\n\t}\n    }\n    else if (frp->fr_layout == FR_COL)\n    {\n\t// Handle all the frames in the column.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    frame_add_vsep(frp);\n    }\n    else // frp->fr_layout == FR_ROW\n    {\n\t// Only need to handle the last frame in the row.\n\tfrp = frp->fr_child;\n\twhile (frp->fr_next != NULL)\n\t    frp = frp->fr_next;\n\tframe_add_vsep(frp);\n    }\n}\n\n/*\n * Set frame width from the window it contains.\n */\n    static void\nframe_fix_width(win_T *wp)\n{\n    wp->w_frame->fr_width = wp->w_width + wp->w_vsep_width;\n}\n\n/*\n * Set frame height from the window it contains.\n */\n    static void\nframe_fix_height(win_T *wp)\n{\n    wp->w_frame->fr_height = VISIBLE_HEIGHT(wp) + wp->w_status_height;\n}\n\n/*\n * Compute the minimal height for frame \"topfrp\".\n * Uses the 'winminheight' option.\n * When \"next_curwin\" isn't NULL, use p_wh for this window.\n * When \"next_curwin\" is NOWIN, don't use at least one line for the current\n * window.\n */\n    static int\nframe_minheight(frame_T *topfrp, win_T *next_curwin)\n{\n    frame_T\t*frp;\n    int\t\tm;\n    int\t\tn;\n\n    if (topfrp->fr_win != NULL)\n    {\n\tif (topfrp->fr_win == next_curwin)\n\t    m = p_wh + topfrp->fr_win->w_status_height;\n\telse\n\t{\n\t    // window: minimal height of the window plus status line\n\t    m = p_wmh + topfrp->fr_win->w_status_height;\n\t    if (topfrp->fr_win == curwin && next_curwin == NULL)\n\t    {\n\t\t// Current window is minimal one line high and WinBar is\n\t\t// visible.\n\t\tif (p_wmh == 0)\n\t\t    ++m;\n\t\tm += WINBAR_HEIGHT(curwin);\n\t    }\n\t}\n    }\n    else if (topfrp->fr_layout == FR_ROW)\n    {\n\t// get the minimal height from each frame in this row\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    n = frame_minheight(frp, next_curwin);\n\t    if (n > m)\n\t\tm = n;\n\t}\n    }\n    else\n    {\n\t// Add up the minimal heights for all frames in this column.\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    m += frame_minheight(frp, next_curwin);\n    }\n\n    return m;\n}\n\n/*\n * Compute the minimal width for frame \"topfrp\".\n * When \"next_curwin\" isn't NULL, use p_wiw for this window.\n * When \"next_curwin\" is NOWIN, don't use at least one column for the current\n * window.\n */\n    static int\nframe_minwidth(\n    frame_T\t*topfrp,\n    win_T\t*next_curwin)\t// use p_wh and p_wiw for next_curwin\n{\n    frame_T\t*frp;\n    int\t\tm, n;\n\n    if (topfrp->fr_win != NULL)\n    {\n\tif (topfrp->fr_win == next_curwin)\n\t    m = p_wiw + topfrp->fr_win->w_vsep_width;\n\telse\n\t{\n\t    // window: minimal width of the window plus separator column\n\t    m = p_wmw + topfrp->fr_win->w_vsep_width;\n\t    // Current window is minimal one column wide\n\t    if (p_wmw == 0 && topfrp->fr_win == curwin && next_curwin == NULL)\n\t\t++m;\n\t}\n    }\n    else if (topfrp->fr_layout == FR_COL)\n    {\n\t// get the minimal width from each frame in this column\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    n = frame_minwidth(frp, next_curwin);\n\t    if (n > m)\n\t\tm = n;\n\t}\n    }\n    else\n    {\n\t// Add up the minimal widths for all frames in this row.\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    m += frame_minwidth(frp, next_curwin);\n    }\n\n    return m;\n}\n\n\n/*\n * Try to close all windows except current one.\n * Buffers in the other windows become hidden if 'hidden' is set, or '!' is\n * used and the buffer was modified.\n *\n * Used by \":bdel\" and \":only\".\n */\n    void\nclose_others(\n    int\t\tmessage,\n    int\t\tforceit)\t    // always hide all other windows\n{\n    win_T\t*wp;\n    win_T\t*nextwp;\n    int\t\tr;\n\n    if (one_window())\n    {\n\tif (message && !autocmd_busy)\n\t    msg(_(m_onlyone));\n\treturn;\n    }\n\n    // Be very careful here: autocommands may change the window layout.\n    for (wp = firstwin; win_valid(wp); wp = nextwp)\n    {\n\tnextwp = wp->w_next;\n\tif (wp != curwin)\t\t// don't close current window\n\t{\n\n\t    // Check if it's allowed to abandon this window\n\t    r = can_abandon(wp->w_buffer, forceit);\n\t    if (!win_valid(wp))\t\t// autocommands messed wp up\n\t    {\n\t\tnextwp = firstwin;\n\t\tcontinue;\n\t    }\n\t    if (!r)\n\t    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t\tif (message && (p_confirm\n\t\t\t     || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t\t{\n\t\t    dialog_changed(wp->w_buffer, FALSE);\n\t\t    if (!win_valid(wp))\t\t// autocommands messed wp up\n\t\t    {\n\t\t\tnextwp = firstwin;\n\t\t\tcontinue;\n\t\t    }\n\t\t}\n\t\tif (bufIsChanged(wp->w_buffer))\n#endif\n\t\t    continue;\n\t    }\n\t    win_close(wp, !buf_hide(wp->w_buffer)\n\t\t\t\t\t       && !bufIsChanged(wp->w_buffer));\n\t}\n    }\n\n    if (message && !ONE_WINDOW)\n\temsg(_(e_other_window_contains_changes));\n}\n\n/*\n * Allocate the first window and put an empty buffer in it.\n * Called from main().\n * Return FAIL when something goes wrong (out of memory).\n */\n    int\nwin_alloc_first(void)\n{\n    if (win_alloc_firstwin(NULL) == FAIL)\n\treturn FAIL;\n\n    first_tabpage = alloc_tabpage();\n    if (first_tabpage == NULL)\n\treturn FAIL;\n    first_tabpage->tp_topframe = topframe;\n    curtab = first_tabpage;\n    curtab->tp_firstwin = firstwin;\n    curtab->tp_lastwin = lastwin;\n    curtab->tp_curwin = curwin;\n\n    return OK;\n}\n\n/*\n * Allocate and init a window that is not a regular window.\n * This can only be done after the first window is fully initialized, thus it\n * can't be in win_alloc_first().\n */\n    win_T *\nwin_alloc_popup_win(void)\n{\n    win_T *wp;\n\n    wp = win_alloc(NULL, TRUE);\n    if (wp != NULL)\n    {\n\t// We need to initialize options with something, using the current\n\t// window makes most sense.\n\twin_init_some(wp, curwin);\n\n\tRESET_BINDING(wp);\n\tnew_frame(wp);\n    }\n    return wp;\n}\n\n/*\n * Initialize window \"wp\" to display buffer \"buf\".\n */\n    void\nwin_init_popup_win(win_T *wp, buf_T *buf)\n{\n    wp->w_buffer = buf;\n    ++buf->b_nwindows;\n    win_init_empty(wp); // set cursor and topline to safe values\n\n    // Make sure w_localdir and globaldir are NULL to avoid a chdir() in\n    // win_enter_ext().\n    VIM_CLEAR(wp->w_localdir);\n}\n\n/*\n * Allocate the first window or the first window in a new tab page.\n * When \"oldwin\" is NULL create an empty buffer for it.\n * When \"oldwin\" is not NULL copy info from it to the new window.\n * Return FAIL when something goes wrong (out of memory).\n */\n    static int\nwin_alloc_firstwin(win_T *oldwin)\n{\n    curwin = win_alloc(NULL, FALSE);\n    if (curwin == NULL)\n\treturn FAIL;\n    if (oldwin == NULL)\n    {\n\t// Very first window, need to create an empty buffer for it and\n\t// initialize from scratch.\n\tcurbuf = buflist_new(NULL, NULL, 1L, BLN_LISTED);\n\tif (curwin == NULL || curbuf == NULL)\n\t    return FAIL;\n\tcurwin->w_buffer = curbuf;\n#ifdef FEAT_SYN_HL\n\tcurwin->w_s = &(curbuf->b_s);\n#endif\n\tcurbuf->b_nwindows = 1;\t// there is one window\n\tcurwin->w_alist = &global_alist;\n\tcurwin_init();\t\t// init current window\n    }\n    else\n    {\n\t// First window in new tab page, initialize it from \"oldwin\".\n\twin_init(curwin, oldwin, 0);\n\n\t// We don't want cursor- and scroll-binding in the first window.\n\tRESET_BINDING(curwin);\n    }\n\n    new_frame(curwin);\n    if (curwin->w_frame == NULL)\n\treturn FAIL;\n    topframe = curwin->w_frame;\n    topframe->fr_width = Columns;\n    topframe->fr_height = Rows - p_ch;\n\n    return OK;\n}\n\n/*\n * Create a frame for window \"wp\".\n */\n    static void\nnew_frame(win_T *wp)\n{\n    frame_T *frp = ALLOC_CLEAR_ONE(frame_T);\n\n    wp->w_frame = frp;\n    if (frp != NULL)\n    {\n\tfrp->fr_layout = FR_LEAF;\n\tfrp->fr_win = wp;\n    }\n}\n\n/*\n * Initialize the window and frame size to the maximum.\n */\n    void\nwin_init_size(void)\n{\n    firstwin->w_height = ROWS_AVAIL;\n    topframe->fr_height = ROWS_AVAIL;\n    firstwin->w_width = Columns;\n    topframe->fr_width = Columns;\n}\n\n/*\n * Allocate a new tabpage_T and init the values.\n * Returns NULL when out of memory.\n */\n    static tabpage_T *\nalloc_tabpage(void)\n{\n    tabpage_T\t*tp;\n# ifdef FEAT_GUI\n    int\t\ti;\n# endif\n\n\n    tp = ALLOC_CLEAR_ONE(tabpage_T);\n    if (tp == NULL)\n\treturn NULL;\n\n# ifdef FEAT_EVAL\n    // init t: variables\n    tp->tp_vars = dict_alloc_id(aid_newtabpage_tvars);\n    if (tp->tp_vars == NULL)\n    {\n\tvim_free(tp);\n\treturn NULL;\n    }\n    init_var_dict(tp->tp_vars, &tp->tp_winvar, VAR_SCOPE);\n# endif\n\n# ifdef FEAT_GUI\n    for (i = 0; i < 3; i++)\n\ttp->tp_prev_which_scrollbars[i] = -1;\n# endif\n# ifdef FEAT_DIFF\n    tp->tp_diff_invalid = TRUE;\n# endif\n    tp->tp_ch_used = p_ch;\n\n    return tp;\n}\n\n    void\nfree_tabpage(tabpage_T *tp)\n{\n    int idx;\n\n# ifdef FEAT_DIFF\n    diff_clear(tp);\n# endif\n# ifdef FEAT_PROP_POPUP\n    while (tp->tp_first_popupwin != NULL)\n\tpopup_close_tabpage(tp, tp->tp_first_popupwin->w_id, TRUE);\n#endif\n    for (idx = 0; idx < SNAP_COUNT; ++idx)\n\tclear_snapshot(tp, idx);\n#ifdef FEAT_EVAL\n    vars_clear(&tp->tp_vars->dv_hashtab);\t// free all t: variables\n    hash_init(&tp->tp_vars->dv_hashtab);\n    unref_var_dict(tp->tp_vars);\n#endif\n\n    if (tp == lastused_tabpage)\n\tlastused_tabpage = NULL;\n\n    vim_free(tp->tp_localdir);\n    vim_free(tp->tp_prevdir);\n\n#ifdef FEAT_PYTHON\n    python_tabpage_free(tp);\n#endif\n\n#ifdef FEAT_PYTHON3\n    python3_tabpage_free(tp);\n#endif\n\n    vim_free(tp);\n}\n\n/*\n * Create a new Tab page with one window.\n * It will edit the current buffer, like after \":split\".\n * When \"after\" is 0 put it just after the current Tab page.\n * Otherwise put it just before tab page \"after\".\n * Return FAIL or OK.\n */\n    int\nwin_new_tabpage(int after)\n{\n    tabpage_T\t*tp = curtab;\n    tabpage_T\t*prev_tp = curtab;\n    tabpage_T\t*newtp;\n    int\t\tn;\n\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n    {\n\temsg(_(e_invalid_in_cmdline_window));\n\treturn FAIL;\n    }\n#endif\n\n    newtp = alloc_tabpage();\n    if (newtp == NULL)\n\treturn FAIL;\n\n    // Remember the current windows in this Tab page.\n    if (leave_tabpage(curbuf, TRUE) == FAIL)\n    {\n\tvim_free(newtp);\n\treturn FAIL;\n    }\n    curtab = newtp;\n\n    newtp->tp_localdir = (tp->tp_localdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(tp->tp_localdir);\n    // Create a new empty window.\n    if (win_alloc_firstwin(tp->tp_curwin) == OK)\n    {\n\t// Make the new Tab page the new topframe.\n\tif (after == 1)\n\t{\n\t    // New tab page becomes the first one.\n\t    newtp->tp_next = first_tabpage;\n\t    first_tabpage = newtp;\n\t}\n\telse\n\t{\n\t    if (after > 0)\n\t    {\n\t\t// Put new tab page before tab page \"after\".\n\t\tn = 2;\n\t\tfor (tp = first_tabpage; tp->tp_next != NULL\n\t\t\t\t\t       && n < after; tp = tp->tp_next)\n\t\t    ++n;\n\t    }\n\t    newtp->tp_next = tp->tp_next;\n\t    tp->tp_next = newtp;\n\t}\n\tnewtp->tp_firstwin = newtp->tp_lastwin = newtp->tp_curwin = curwin;\n\n\twin_init_size();\n\tfirstwin->w_winrow = tabline_height();\n\twin_comp_scroll(curwin);\n\n\tnewtp->tp_topframe = topframe;\n\tlast_status(FALSE);\n\n\tlastused_tabpage = prev_tp;\n\n#if defined(FEAT_GUI)\n\t// When 'guioptions' includes 'L' or 'R' may have to remove or add\n\t// scrollbars.  Have to update them anyway.\n\tgui_may_update_scrollbars();\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\tentering_window(curwin);\n#endif\n\n\tredraw_all_later(NOT_VALID);\n\tapply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABNEW, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\treturn OK;\n    }\n\n    // Failed, get back the previous Tab page\n    enter_tabpage(curtab, curbuf, TRUE, TRUE);\n    return FAIL;\n}\n\n/*\n * Open a new tab page if \":tab cmd\" was used.  It will edit the same buffer,\n * like with \":split\".\n * Returns OK if a new tab page was created, FAIL otherwise.\n */\n    static int\nmay_open_tabpage(void)\n{\n    int\t\tn = (cmdmod.cmod_tab == 0)\n\t\t\t\t       ? postponed_split_tab : cmdmod.cmod_tab;\n\n    if (n != 0)\n    {\n\tcmdmod.cmod_tab = 0;\t    // reset it to avoid doing it twice\n\tpostponed_split_tab = 0;\n\treturn win_new_tabpage(n);\n    }\n    return FAIL;\n}\n\n/*\n * Create up to \"maxcount\" tabpages with empty windows.\n * Returns the number of resulting tab pages.\n */\n    int\nmake_tabpages(int maxcount)\n{\n    int\t\tcount = maxcount;\n    int\t\ttodo;\n\n    // Limit to 'tabpagemax' tabs.\n    if (count > p_tpm)\n\tcount = p_tpm;\n\n    /*\n     * Don't execute autocommands while creating the tab pages.  Must do that\n     * when putting the buffers in the windows.\n     */\n    block_autocmds();\n\n    for (todo = count - 1; todo > 0; --todo)\n\tif (win_new_tabpage(0) == FAIL)\n\t    break;\n\n    unblock_autocmds();\n\n    // return actual number of tab pages\n    return (count - todo);\n}\n\n/*\n * Return TRUE when \"tpc\" points to a valid tab page.\n */\n    int\nvalid_tabpage(tabpage_T *tpc)\n{\n    tabpage_T\t*tp;\n\n    FOR_ALL_TABPAGES(tp)\n\tif (tp == tpc)\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Return TRUE when \"tpc\" points to a valid tab page and at least one window is\n * valid.\n */\n    int\nvalid_tabpage_win(tabpage_T *tpc)\n{\n    tabpage_T\t*tp;\n    win_T\t*wp;\n\n    FOR_ALL_TABPAGES(tp)\n    {\n\tif (tp == tpc)\n\t{\n\t    FOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t    {\n\t\tif (win_valid_any_tab(wp))\n\t\t    return TRUE;\n\t    }\n\t    return FALSE;\n\t}\n    }\n    // shouldn't happen\n    return FALSE;\n}\n\n/*\n * Close tabpage \"tab\", assuming it has no windows in it.\n * There must be another tabpage or this will crash.\n */\n    void\nclose_tabpage(tabpage_T *tab)\n{\n    tabpage_T\t*ptp;\n\n    if (tab == first_tabpage)\n    {\n\tfirst_tabpage = tab->tp_next;\n\tptp = first_tabpage;\n    }\n    else\n    {\n\tfor (ptp = first_tabpage; ptp != NULL && ptp->tp_next != tab;\n\t\t\t\t\t\t\t    ptp = ptp->tp_next)\n\t    ;\n\tassert(ptp != NULL);\n\tptp->tp_next = tab->tp_next;\n    }\n\n    goto_tabpage_tp(ptp, FALSE, FALSE);\n    free_tabpage(tab);\n}\n\n/*\n * Find tab page \"n\" (first one is 1).  Returns NULL when not found.\n */\n    tabpage_T *\nfind_tabpage(int n)\n{\n    tabpage_T\t*tp;\n    int\t\ti = 1;\n\n    if (n == 0)\n\treturn curtab;\n\n    for (tp = first_tabpage; tp != NULL && i != n; tp = tp->tp_next)\n\t++i;\n    return tp;\n}\n\n/*\n * Get index of tab page \"tp\".  First one has index 1.\n * When not found returns number of tab pages plus one.\n */\n    int\ntabpage_index(tabpage_T *ftp)\n{\n    int\t\ti = 1;\n    tabpage_T\t*tp;\n\n    for (tp = first_tabpage; tp != NULL && tp != ftp; tp = tp->tp_next)\n\t++i;\n    return i;\n}\n\n/*\n * Prepare for leaving the current tab page.\n * When autocommands change \"curtab\" we don't leave the tab page and return\n * FAIL.\n * Careful: When OK is returned need to get a new tab page very very soon!\n */\n    static int\nleave_tabpage(\n    buf_T\t*new_curbuf UNUSED,    // what is going to be the new curbuf,\n\t\t\t\t       // NULL if unknown\n    int\t\ttrigger_leave_autocmds UNUSED)\n{\n    tabpage_T\t*tp = curtab;\n\n#ifdef FEAT_JOB_CHANNEL\n    leaving_window(curwin);\n#endif\n    reset_VIsual_and_resel();\t// stop Visual mode\n    if (trigger_leave_autocmds)\n    {\n\tif (new_curbuf != curbuf)\n\t{\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    if (curtab != tp)\n\t\treturn FAIL;\n\t}\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (curtab != tp)\n\t    return FAIL;\n\tapply_autocmds(EVENT_TABLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (curtab != tp)\n\t    return FAIL;\n    }\n#if defined(FEAT_GUI)\n    // Remove the scrollbars.  They may be added back later.\n    if (gui.in_use)\n\tgui_remove_scrollbars();\n#endif\n    tp->tp_curwin = curwin;\n    tp->tp_prevwin = prevwin;\n    tp->tp_firstwin = firstwin;\n    tp->tp_lastwin = lastwin;\n    tp->tp_old_Rows = Rows;\n    if (tp->tp_old_Columns != -1)\n\ttp->tp_old_Columns = Columns;\n    firstwin = NULL;\n    lastwin = NULL;\n    return OK;\n}\n\n/*\n * Start using tab page \"tp\".\n * Only to be used after leave_tabpage() or freeing the current tab page.\n * Only trigger *Enter autocommands when trigger_enter_autocmds is TRUE.\n * Only trigger *Leave autocommands when trigger_leave_autocmds is TRUE.\n */\n    static void\nenter_tabpage(\n    tabpage_T\t*tp,\n    buf_T\t*old_curbuf UNUSED,\n    int\t\ttrigger_enter_autocmds,\n    int\t\ttrigger_leave_autocmds)\n{\n    int\t\trow;\n    int\t\told_off = tp->tp_firstwin->w_winrow;\n    win_T\t*next_prevwin = tp->tp_prevwin;\n    tabpage_T\t*last_tab = curtab;\n\n    curtab = tp;\n    firstwin = tp->tp_firstwin;\n    lastwin = tp->tp_lastwin;\n    topframe = tp->tp_topframe;\n\n    // We would like doing the TabEnter event first, but we don't have a\n    // valid current window yet, which may break some commands.\n    // This triggers autocommands, thus may make \"tp\" invalid.\n    (void)win_enter_ext(tp->tp_curwin, WEE_CURWIN_INVALID\n\t\t  | (trigger_enter_autocmds ? WEE_TRIGGER_ENTER_AUTOCMDS : 0)\n\t\t  | (trigger_leave_autocmds ? WEE_TRIGGER_LEAVE_AUTOCMDS : 0));\n    prevwin = next_prevwin;\n\n    last_status(FALSE);\t\t// status line may appear or disappear\n    row = win_comp_pos();\t// recompute w_winrow for all windows\n#ifdef FEAT_DIFF\n    diff_need_scrollbind = TRUE;\n#endif\n\n    // The tabpage line may have appeared or disappeared, may need to resize\n    // the frames for that.  When the Vim window was resized need to update\n    // frame sizes too.  Use the stored value of p_ch, so that it can be\n    // different for each tab page.\n    if (p_ch != curtab->tp_ch_used)\n\tclear_cmdline = TRUE;\n    p_ch = curtab->tp_ch_used;\n\n    // When cmdheight is changed in a tab page with '<C-w>-', cmdline_row is\n    // changed but p_ch and tp_ch_used are not changed. Thus we also need to\n    // check cmdline_row.\n    if ((row < cmdline_row) && (cmdline_row <= Rows - p_ch))\n\tclear_cmdline = TRUE;\n\n    if (curtab->tp_old_Rows != Rows || (old_off != firstwin->w_winrow\n#ifdef FEAT_GUI_TABLINE\n\t\t\t    && !gui_use_tabline()\n#endif\n\t\t))\n\tshell_new_rows();\n    if (curtab->tp_old_Columns != Columns)\n    {\n\tif (starting == 0)\n\t{\n\t    shell_new_columns();\t// update window widths\n\t    curtab->tp_old_Columns = Columns;\n\t}\n\telse\n\t    curtab->tp_old_Columns = -1;  // update window widths later\n    }\n\n    lastused_tabpage = last_tab;\n\n#if defined(FEAT_GUI)\n    // When 'guioptions' includes 'L' or 'R' may have to remove or add\n    // scrollbars.  Have to update them anyway.\n    gui_may_update_scrollbars();\n#endif\n\n    // Apply autocommands after updating the display, when 'rows' and\n    // 'columns' have been set correctly.\n    if (trigger_enter_autocmds)\n    {\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\tif (old_curbuf != curbuf)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Go to tab page \"n\".  For \":tab N\" and \"Ngt\".\n * When \"n\" is 9999 go to the last tab page.\n */\n    void\ngoto_tabpage(int n)\n{\n    tabpage_T\t*tp = NULL;  // shut up compiler\n    tabpage_T\t*ttp;\n    int\t\ti;\n\n    if (text_locked())\n    {\n\t// Not allowed when editing the command line.\n\ttext_locked_msg();\n\treturn;\n    }\n\n    // If there is only one it can't work.\n    if (first_tabpage->tp_next == NULL)\n    {\n\tif (n > 1)\n\t    beep_flush();\n\treturn;\n    }\n\n    if (n == 0)\n    {\n\t// No count, go to next tab page, wrap around end.\n\tif (curtab->tp_next == NULL)\n\t    tp = first_tabpage;\n\telse\n\t    tp = curtab->tp_next;\n    }\n    else if (n < 0)\n    {\n\t// \"gT\": go to previous tab page, wrap around end.  \"N gT\" repeats\n\t// this N times.\n\tttp = curtab;\n\tfor (i = n; i < 0; ++i)\n\t{\n\t    for (tp = first_tabpage; tp->tp_next != ttp && tp->tp_next != NULL;\n\t\t    tp = tp->tp_next)\n\t\t;\n\t    ttp = tp;\n\t}\n    }\n    else if (n == 9999)\n    {\n\t// Go to last tab page.\n\tfor (tp = first_tabpage; tp->tp_next != NULL; tp = tp->tp_next)\n\t    ;\n    }\n    else\n    {\n\t// Go to tab page \"n\".\n\ttp = find_tabpage(n);\n\tif (tp == NULL)\n\t{\n\t    beep_flush();\n\t    return;\n\t}\n    }\n\n    goto_tabpage_tp(tp, TRUE, TRUE);\n\n#ifdef FEAT_GUI_TABLINE\n    if (gui_use_tabline())\n\tgui_mch_set_curtab(tabpage_index(curtab));\n#endif\n}\n\n/*\n * Go to tabpage \"tp\".\n * Only trigger *Enter autocommands when trigger_enter_autocmds is TRUE.\n * Only trigger *Leave autocommands when trigger_leave_autocmds is TRUE.\n * Note: doesn't update the GUI tab.\n */\n    void\ngoto_tabpage_tp(\n    tabpage_T\t*tp,\n    int\t\ttrigger_enter_autocmds,\n    int\t\ttrigger_leave_autocmds)\n{\n    if (trigger_enter_autocmds || trigger_leave_autocmds)\n\tCHECK_CMDWIN;\n\n    // Don't repeat a message in another tab page.\n    set_keep_msg(NULL, 0);\n\n    if (tp != curtab && leave_tabpage(tp->tp_curwin->w_buffer,\n\t\t\t\t\ttrigger_leave_autocmds) == OK)\n    {\n\tif (valid_tabpage(tp))\n\t    enter_tabpage(tp, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n\telse\n\t    enter_tabpage(curtab, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n    }\n}\n\n/*\n * Go to the last accessed tab page, if there is one.\n * Return OK or FAIL\n */\n    int\ngoto_tabpage_lastused(void)\n{\n    if (valid_tabpage(lastused_tabpage))\n    {\n\tgoto_tabpage_tp(lastused_tabpage, TRUE, TRUE);\n\treturn OK;\n    }\n    return FAIL;\n}\n\n/*\n * Enter window \"wp\" in tab page \"tp\".\n * Also updates the GUI tab.\n */\n    void\ngoto_tabpage_win(tabpage_T *tp, win_T *wp)\n{\n    goto_tabpage_tp(tp, TRUE, TRUE);\n    if (curtab == tp && win_valid(wp))\n    {\n\twin_enter(wp, TRUE);\n# ifdef FEAT_GUI_TABLINE\n\tif (gui_use_tabline())\n\t    gui_mch_set_curtab(tabpage_index(curtab));\n# endif\n    }\n}\n\n/*\n * Move the current tab page to after tab page \"nr\".\n */\n    void\ntabpage_move(int nr)\n{\n    int\t\tn = 1;\n    tabpage_T\t*tp, *tp_dst;\n\n    if (first_tabpage->tp_next == NULL)\n\treturn;\n\n    for (tp = first_tabpage; tp->tp_next != NULL && n < nr; tp = tp->tp_next)\n\t++n;\n\n    if (tp == curtab || (nr > 0 && tp->tp_next != NULL\n\t\t\t\t\t\t    && tp->tp_next == curtab))\n\treturn;\n\n    tp_dst = tp;\n\n    // Remove the current tab page from the list of tab pages.\n    if (curtab == first_tabpage)\n\tfirst_tabpage = curtab->tp_next;\n    else\n    {\n\tFOR_ALL_TABPAGES(tp)\n\t    if (tp->tp_next == curtab)\n\t\tbreak;\n\tif (tp == NULL)\t// \"cannot happen\"\n\t    return;\n\ttp->tp_next = curtab->tp_next;\n    }\n\n    // Re-insert it at the specified position.\n    if (nr <= 0)\n    {\n\tcurtab->tp_next = first_tabpage;\n\tfirst_tabpage = curtab;\n    }\n    else\n    {\n\tcurtab->tp_next = tp_dst->tp_next;\n\ttp_dst->tp_next = curtab;\n    }\n\n    // Need to redraw the tabline.  Tab page contents doesn't change.\n    redraw_tabline = TRUE;\n}\n\n\n/*\n * Go to another window.\n * When jumping to another buffer, stop Visual mode.  Do this before\n * changing windows so we can yank the selection into the '*' register.\n * When jumping to another window on the same buffer, adjust its cursor\n * position to keep the same Visual area.\n */\n    void\nwin_goto(win_T *wp)\n{\n#ifdef FEAT_CONCEAL\n    win_T\t*owp = curwin;\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (popup_is_popup(wp))\n    {\n\temsg(_(e_not_allowed_to_enter_popup_window));\n\treturn;\n    }\n#endif\n    if (text_locked())\n    {\n\tbeep_flush();\n\ttext_locked_msg();\n\treturn;\n    }\n    if (curbuf_locked())\n\treturn;\n\n    if (wp->w_buffer != curbuf)\n\treset_VIsual_and_resel();\n    else if (VIsual_active)\n\twp->w_cursor = curwin->w_cursor;\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n    win_enter(wp, TRUE);\n\n#ifdef FEAT_CONCEAL\n    // Conceal cursor line in previous window, unconceal in current window.\n    if (win_valid(owp) && owp->w_p_cole > 0 && !msg_scrolled)\n\tredrawWinline(owp, owp->w_cursor.lnum);\n    if (curwin->w_p_cole > 0 && !msg_scrolled)\n\tneed_cursor_line_redraw = TRUE;\n#endif\n}\n\n#if defined(FEAT_PERL) || defined(PROTO)\n/*\n * Find window number \"winnr\" (counting top to bottom).\n */\n    win_T *\nwin_find_nr(int winnr)\n{\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (--winnr == 0)\n\t    break;\n    return wp;\n}\n#endif\n\n#if ((defined(FEAT_PYTHON) || defined(FEAT_PYTHON3))) || defined(PROTO)\n/*\n * Find the tabpage for window \"win\".\n */\n    tabpage_T *\nwin_find_tabpage(win_T *win)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t    if (wp == win)\n\t\treturn tp;\n    return NULL;\n}\n#endif\n\n/*\n * Get the above or below neighbor window of the specified window.\n *   up - TRUE for the above neighbor\n *   count - nth neighbor window\n * Returns the specified window if the neighbor is not found.\n */\n    win_T *\nwin_vert_neighbor(tabpage_T *tp, win_T *wp, int up, long count)\n{\n    frame_T\t*fr;\n    frame_T\t*nfr;\n    frame_T\t*foundfr;\n\n#ifdef FEAT_PROP_POPUP\n    if (popup_is_popup(wp))\n\t// popups don't have neighbors.\n\treturn NULL;\n#endif\n    foundfr = wp->w_frame;\n    while (count--)\n    {\n\t/*\n\t * First go upwards in the tree of frames until we find a upwards or\n\t * downwards neighbor.\n\t */\n\tfr = foundfr;\n\tfor (;;)\n\t{\n\t    if (fr == tp->tp_topframe)\n\t\tgoto end;\n\t    if (up)\n\t\tnfr = fr->fr_prev;\n\t    else\n\t\tnfr = fr->fr_next;\n\t    if (fr->fr_parent->fr_layout == FR_COL && nfr != NULL)\n\t\tbreak;\n\t    fr = fr->fr_parent;\n\t}\n\n\t/*\n\t * Now go downwards to find the bottom or top frame in it.\n\t */\n\tfor (;;)\n\t{\n\t    if (nfr->fr_layout == FR_LEAF)\n\t    {\n\t\tfoundfr = nfr;\n\t\tbreak;\n\t    }\n\t    fr = nfr->fr_child;\n\t    if (nfr->fr_layout == FR_ROW)\n\t    {\n\t\t// Find the frame at the cursor row.\n\t\twhile (fr->fr_next != NULL\n\t\t\t&& frame2win(fr)->w_wincol + fr->fr_width\n\t\t\t\t\t <= wp->w_wincol + wp->w_wcol)\n\t\t    fr = fr->fr_next;\n\t    }\n\t    if (nfr->fr_layout == FR_COL && up)\n\t\twhile (fr->fr_next != NULL)\n\t\t    fr = fr->fr_next;\n\t    nfr = fr;\n\t}\n    }\nend:\n    return foundfr != NULL ? foundfr->fr_win : NULL;\n}\n\n/*\n * Move to window above or below \"count\" times.\n */\n    static void\nwin_goto_ver(\n    int\t\tup,\t\t// TRUE to go to win above\n    long\tcount)\n{\n    win_T\t*win;\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n#endif\n    win = win_vert_neighbor(curtab, curwin, up, count);\n    if (win != NULL)\n\twin_goto(win);\n}\n\n/*\n * Get the left or right neighbor window of the specified window.\n *   left - TRUE for the left neighbor\n *   count - nth neighbor window\n * Returns the specified window if the neighbor is not found.\n */\n    win_T *\nwin_horz_neighbor(tabpage_T *tp, win_T *wp, int left, long count)\n{\n    frame_T\t*fr;\n    frame_T\t*nfr;\n    frame_T\t*foundfr;\n\n#ifdef FEAT_PROP_POPUP\n    if (popup_is_popup(wp))\n\t// popups don't have neighbors.\n\treturn NULL;\n#endif\n    foundfr = wp->w_frame;\n    while (count--)\n    {\n\t/*\n\t * First go upwards in the tree of frames until we find a left or\n\t * right neighbor.\n\t */\n\tfr = foundfr;\n\tfor (;;)\n\t{\n\t    if (fr == tp->tp_topframe)\n\t\tgoto end;\n\t    if (left)\n\t\tnfr = fr->fr_prev;\n\t    else\n\t\tnfr = fr->fr_next;\n\t    if (fr->fr_parent->fr_layout == FR_ROW && nfr != NULL)\n\t\tbreak;\n\t    fr = fr->fr_parent;\n\t}\n\n\t/*\n\t * Now go downwards to find the leftmost or rightmost frame in it.\n\t */\n\tfor (;;)\n\t{\n\t    if (nfr->fr_layout == FR_LEAF)\n\t    {\n\t\tfoundfr = nfr;\n\t\tbreak;\n\t    }\n\t    fr = nfr->fr_child;\n\t    if (nfr->fr_layout == FR_COL)\n\t    {\n\t\t// Find the frame at the cursor row.\n\t\twhile (fr->fr_next != NULL\n\t\t\t&& frame2win(fr)->w_winrow + fr->fr_height\n\t\t\t\t\t <= wp->w_winrow + wp->w_wrow)\n\t\t    fr = fr->fr_next;\n\t    }\n\t    if (nfr->fr_layout == FR_ROW && left)\n\t\twhile (fr->fr_next != NULL)\n\t\t    fr = fr->fr_next;\n\t    nfr = fr;\n\t}\n    }\nend:\n    return foundfr != NULL ? foundfr->fr_win : NULL;\n}\n\n/*\n * Move to left or right window.\n */\n    static void\nwin_goto_hor(\n    int\t\tleft,\t\t// TRUE to go to left win\n    long\tcount)\n{\n    win_T\t*win;\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n#endif\n    win = win_horz_neighbor(curtab, curwin, left, count);\n    if (win != NULL)\n\twin_goto(win);\n}\n\n/*\n * Make window \"wp\" the current window.\n */\n    void\nwin_enter(win_T *wp, int undo_sync)\n{\n    (void)win_enter_ext(wp, (undo_sync ? WEE_UNDO_SYNC : 0)\n\t\t    | WEE_TRIGGER_ENTER_AUTOCMDS | WEE_TRIGGER_LEAVE_AUTOCMDS);\n}\n\n/*\n * Used after making another window the current one: change directory if\n * needed.\n */\n    static void\nfix_current_dir(void)\n{\n    if (curwin->w_localdir != NULL || curtab->tp_localdir != NULL)\n    {\n\tchar_u\t*dirname;\n\n\t// Window or tab has a local directory: Save current directory as\n\t// global directory (unless that was done already) and change to the\n\t// local directory.\n\tif (globaldir == NULL)\n\t{\n\t    char_u\tcwd[MAXPATHL];\n\n\t    if (mch_dirname(cwd, MAXPATHL) == OK)\n\t\tglobaldir = vim_strsave(cwd);\n\t}\n\tif (curwin->w_localdir != NULL)\n\t    dirname = curwin->w_localdir;\n\telse\n\t    dirname = curtab->tp_localdir;\n\n\tif (mch_chdir((char *)dirname) == 0)\n\t{\n\t    last_chdir_reason = NULL;\n\t    shorten_fnames(TRUE);\n\t}\n    }\n    else if (globaldir != NULL)\n    {\n\t// Window doesn't have a local directory and we are not in the global\n\t// directory: Change to the global directory.\n\tvim_ignored = mch_chdir((char *)globaldir);\n\tVIM_CLEAR(globaldir);\n\tlast_chdir_reason = NULL;\n\tshorten_fnames(TRUE);\n    }\n}\n\n/*\n * Make window \"wp\" the current window.\n * Can be called with \"flags\" containing WEE_CURWIN_INVALID, which means that\n * curwin has just been closed and isn't valid.\n * Returns TRUE when dont_parse_messages was decremented.\n */\n    static int\nwin_enter_ext(win_T *wp, int flags)\n{\n    int\t\tother_buffer = FALSE;\n    int\t\tcurwin_invalid = (flags & WEE_CURWIN_INVALID);\n    int\t\tdid_decrement = FALSE;\n\n    if (wp == curwin && !curwin_invalid)\t// nothing to do\n\treturn FALSE;\n\n#ifdef FEAT_JOB_CHANNEL\n    if (!curwin_invalid)\n\tleaving_window(curwin);\n#endif\n\n    if (!curwin_invalid && (flags & WEE_TRIGGER_LEAVE_AUTOCMDS))\n    {\n\t/*\n\t * Be careful: If autocommands delete the window, return now.\n\t */\n\tif (wp->w_buffer != curbuf)\n\t{\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    other_buffer = TRUE;\n\t    if (!win_valid(wp))\n\t\treturn FALSE;\n\t}\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (!win_valid(wp))\n\t    return FALSE;\n#ifdef FEAT_EVAL\n\t// autocmds may abort script processing\n\tif (aborting())\n\t    return FALSE;\n#endif\n    }\n\n    // sync undo before leaving the current buffer\n    if ((flags & WEE_UNDO_SYNC) && curbuf != wp->w_buffer)\n\tu_sync(FALSE);\n\n    // Might need to scroll the old window before switching, e.g., when the\n    // cursor was moved.\n    update_topline();\n\n    // may have to copy the buffer options when 'cpo' contains 'S'\n    if (wp->w_buffer != curbuf)\n\tbuf_copy_options(wp->w_buffer, BCO_ENTER | BCO_NOHELP);\n    if (!curwin_invalid)\n    {\n\tprevwin = curwin;\t// remember for CTRL-W p\n\tcurwin->w_redr_status = TRUE;\n    }\n    curwin = wp;\n    curbuf = wp->w_buffer;\n    check_cursor();\n    if (!virtual_active())\n\tcurwin->w_cursor.coladd = 0;\n    changed_line_abv_curs();\t// assume cursor position needs updating\n\n    // Now it is OK to parse messages again, which may be needed in\n    // autocommands.\n#ifdef MESSAGE_QUEUE\n    if (flags & WEE_ALLOW_PARSE_MESSAGES)\n    {\n\t--dont_parse_messages;\n\tdid_decrement = TRUE;\n    }\n#endif\n\n    fix_current_dir();\n\n#ifdef FEAT_JOB_CHANNEL\n    entering_window(curwin);\n#endif\n    // Careful: autocommands may close the window and make \"wp\" invalid\n    if (flags & WEE_TRIGGER_NEW_AUTOCMDS)\n\tapply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);\n    if (flags & WEE_TRIGGER_ENTER_AUTOCMDS)\n    {\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tif (other_buffer)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    maketitle();\n    curwin->w_redr_status = TRUE;\n#ifdef FEAT_TERMINAL\n    if (bt_terminal(curwin->w_buffer))\n\t// terminal is likely in another mode\n\tredraw_mode = TRUE;\n#endif\n    redraw_tabline = TRUE;\n    if (restart_edit)\n\tredraw_later(VALID);\t// causes status line redraw\n\n    // set window height to desired minimal value\n    if (curwin->w_height < p_wh && !curwin->w_p_wfh\n#ifdef FEAT_PROP_POPUP\n\t    && !popup_is_popup(curwin)\n#endif\n\t    )\n\twin_setheight((int)p_wh);\n    else if (curwin->w_height == 0)\n\twin_setheight(1);\n\n    // set window width to desired minimal value\n    if (curwin->w_width < p_wiw && !curwin->w_p_wfw)\n\twin_setwidth((int)p_wiw);\n\n    setmouse();\t\t\t// in case jumped to/from help buffer\n\n    // Change directories when the 'acd' option is set.\n    DO_AUTOCHDIR;\n\n    return did_decrement;\n}\n\n/*\n * Jump to the first open window that contains buffer \"buf\", if one exists.\n * Returns a pointer to the window found, otherwise NULL.\n */\n    win_T *\nbuf_jump_open_win(buf_T *buf)\n{\n    win_T\t*wp = NULL;\n\n    if (curwin->w_buffer == buf)\n\twp = curwin;\n    else\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_buffer == buf)\n\t\tbreak;\n    if (wp != NULL)\n\twin_enter(wp, FALSE);\n    return wp;\n}\n\n/*\n * Jump to the first open window in any tab page that contains buffer \"buf\",\n * if one exists. First search in the windows present in the current tab page.\n * Returns a pointer to the window found, otherwise NULL.\n */\n    win_T *\nbuf_jump_open_tab(buf_T *buf)\n{\n    win_T\t*wp = buf_jump_open_win(buf);\n    tabpage_T\t*tp;\n\n    if (wp != NULL)\n\treturn wp;\n\n    FOR_ALL_TABPAGES(tp)\n\tif (tp != curtab)\n\t{\n\t    FOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t\tif (wp->w_buffer == buf)\n\t\t    break;\n\t    if (wp != NULL)\n\t    {\n\t\tgoto_tabpage_win(tp, wp);\n\t\tif (curwin != wp)\n\t\t    wp = NULL;\t// something went wrong\n\t\tbreak;\n\t    }\n\t}\n    return wp;\n}\n\nstatic int last_win_id = LOWEST_WIN_ID - 1;\n\n/*\n * Allocate a window structure and link it in the window list when \"hidden\" is\n * FALSE.\n */\n    static win_T *\nwin_alloc(win_T *after UNUSED, int hidden UNUSED)\n{\n    win_T\t*new_wp;\n\n    /*\n     * allocate window structure and linesizes arrays\n     */\n    new_wp = ALLOC_CLEAR_ONE(win_T);\n    if (new_wp == NULL)\n\treturn NULL;\n\n    if (win_alloc_lines(new_wp) == FAIL)\n    {\n\tvim_free(new_wp);\n\treturn NULL;\n    }\n\n    new_wp->w_id = ++last_win_id;\n\n#ifdef FEAT_EVAL\n    // init w: variables\n    new_wp->w_vars = dict_alloc_id(aid_newwin_wvars);\n    if (new_wp->w_vars == NULL)\n    {\n\twin_free_lsize(new_wp);\n\tvim_free(new_wp);\n\treturn NULL;\n    }\n    init_var_dict(new_wp->w_vars, &new_wp->w_winvar, VAR_SCOPE);\n#endif\n\n    // Don't execute autocommands while the window is not properly\n    // initialized yet.  gui_create_scrollbar() may trigger a FocusGained\n    // event.\n    block_autocmds();\n\n    /*\n     * link the window in the window list\n     */\n    if (!hidden)\n\twin_append(after, new_wp);\n    new_wp->w_wincol = 0;\n    new_wp->w_width = Columns;\n\n    // position the display and the cursor at the top of the file.\n    new_wp->w_topline = 1;\n#ifdef FEAT_DIFF\n    new_wp->w_topfill = 0;\n#endif\n    new_wp->w_botline = 2;\n    new_wp->w_cursor.lnum = 1;\n    new_wp->w_scbind_pos = 1;\n\n    // use global option value for global-local options\n    new_wp->w_p_so = -1;\n    new_wp->w_p_siso = -1;\n\n    // We won't calculate w_fraction until resizing the window\n    new_wp->w_fraction = 0;\n    new_wp->w_prev_fraction_row = -1;\n\n#ifdef FEAT_GUI\n    if (gui.in_use)\n    {\n\tgui_create_scrollbar(&new_wp->w_scrollbars[SBAR_LEFT],\n\t\tSBAR_LEFT, new_wp);\n\tgui_create_scrollbar(&new_wp->w_scrollbars[SBAR_RIGHT],\n\t\tSBAR_RIGHT, new_wp);\n    }\n#endif\n#ifdef FEAT_FOLDING\n    foldInitWin(new_wp);\n#endif\n    unblock_autocmds();\n#ifdef FEAT_SEARCH_EXTRA\n    new_wp->w_match_head = NULL;\n    new_wp->w_next_match_id = 4;\n#endif\n    return new_wp;\n}\n\n/*\n * Remove window 'wp' from the window list and free the structure.\n */\n    static void\nwin_free(\n    win_T\t*wp,\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    int\t\ti;\n    buf_T\t*buf;\n    wininfo_T\t*wip;\n\n#ifdef FEAT_FOLDING\n    clearFolding(wp);\n#endif\n\n    // reduce the reference count to the argument list.\n    alist_unlink(wp->w_alist);\n\n    // Don't execute autocommands while the window is halfway being deleted.\n    // gui_mch_destroy_scrollbar() may trigger a FocusGained event.\n    block_autocmds();\n\n#ifdef FEAT_LUA\n    lua_window_free(wp);\n#endif\n\n#ifdef FEAT_MZSCHEME\n    mzscheme_window_free(wp);\n#endif\n\n#ifdef FEAT_PERL\n    perl_win_free(wp);\n#endif\n\n#ifdef FEAT_PYTHON\n    python_window_free(wp);\n#endif\n\n#ifdef FEAT_PYTHON3\n    python3_window_free(wp);\n#endif\n\n#ifdef FEAT_TCL\n    tcl_window_free(wp);\n#endif\n\n#ifdef FEAT_RUBY\n    ruby_window_free(wp);\n#endif\n\n    clear_winopt(&wp->w_onebuf_opt);\n    clear_winopt(&wp->w_allbuf_opt);\n\n    vim_free(wp->w_lcs_chars.multispace);\n\n#ifdef FEAT_EVAL\n    vars_clear(&wp->w_vars->dv_hashtab);\t// free all w: variables\n    hash_init(&wp->w_vars->dv_hashtab);\n    unref_var_dict(wp->w_vars);\n#endif\n\n    {\n\ttabpage_T\t*ttp;\n\n\tif (prevwin == wp)\n\t    prevwin = NULL;\n\tFOR_ALL_TABPAGES(ttp)\n\t    if (ttp->tp_prevwin == wp)\n\t\tttp->tp_prevwin = NULL;\n    }\n    win_free_lsize(wp);\n\n    for (i = 0; i < wp->w_tagstacklen; ++i)\n    {\n\tvim_free(wp->w_tagstack[i].tagname);\n\tvim_free(wp->w_tagstack[i].user_data);\n    }\n    vim_free(wp->w_localdir);\n    vim_free(wp->w_prevdir);\n\n    // Remove the window from the b_wininfo lists, it may happen that the\n    // freed memory is re-used for another window.\n    FOR_ALL_BUFFERS(buf)\n\tFOR_ALL_BUF_WININFO(buf, wip)\n\t    if (wip->wi_win == wp)\n\t    {\n\t\twininfo_T\t*wip2;\n\n\t\t// If there already is an entry with \"wi_win\" set to NULL it\n\t\t// must be removed, it would never be used.\n\t\t// Skip \"wip\" itself, otherwise Coverity complains.\n\t\tfor (wip2 = buf->b_wininfo; wip2 != NULL; wip2 = wip2->wi_next)\n\t\t    if (wip2 != wip && wip2->wi_win == NULL)\n\t\t    {\n\t\t\tif (wip2->wi_next != NULL)\n\t\t\t    wip2->wi_next->wi_prev = wip2->wi_prev;\n\t\t\tif (wip2->wi_prev == NULL)\n\t\t\t    buf->b_wininfo = wip2->wi_next;\n\t\t\telse\n\t\t\t    wip2->wi_prev->wi_next = wip2->wi_next;\n\t\t\tfree_wininfo(wip2);\n\t\t\tbreak;\n\t\t    }\n\n\t\twip->wi_win = NULL;\n\t    }\n\n#ifdef FEAT_SEARCH_EXTRA\n    clear_matches(wp);\n#endif\n\n    free_jumplist(wp);\n\n#ifdef FEAT_QUICKFIX\n    qf_free_all(wp);\n#endif\n\n#ifdef FEAT_GUI\n    if (gui.in_use)\n    {\n\tgui_mch_destroy_scrollbar(&wp->w_scrollbars[SBAR_LEFT]);\n\tgui_mch_destroy_scrollbar(&wp->w_scrollbars[SBAR_RIGHT]);\n    }\n#endif // FEAT_GUI\n\n#ifdef FEAT_MENU\n    remove_winbar(wp);\n#endif\n#ifdef FEAT_PROP_POPUP\n    free_callback(&wp->w_close_cb);\n    free_callback(&wp->w_filter_cb);\n    for (i = 0; i < 4; ++i)\n\tVIM_CLEAR(wp->w_border_highlight[i]);\n    vim_free(wp->w_scrollbar_highlight);\n    vim_free(wp->w_thumb_highlight);\n    vim_free(wp->w_popup_title);\n    list_unref(wp->w_popup_mask);\n    vim_free(wp->w_popup_mask_cells);\n#endif\n\n#ifdef FEAT_SYN_HL\n    vim_free(wp->w_p_cc_cols);\n#endif\n\n    if (win_valid_any_tab(wp))\n\twin_remove(wp, tp);\n    if (autocmd_busy)\n    {\n\twp->w_next = au_pending_free_win;\n\tau_pending_free_win = wp;\n    }\n    else\n\tvim_free(wp);\n\n    unblock_autocmds();\n}\n\n/*\n * Return TRUE if \"wp\" is not in the list of windows: the autocmd window or a\n * popup window.\n */\n    int\nwin_unlisted(win_T *wp)\n{\n    return wp == aucmd_win || WIN_IS_POPUP(wp);\n}\n\n#if defined(FEAT_PROP_POPUP) || defined(PROTO)\n/*\n * Free a popup window.  This does not take the window out of the window list\n * and assumes there is only one toplevel frame, no split.\n */\n    void\nwin_free_popup(win_T *win)\n{\n    if (win->w_buffer != NULL)\n    {\n\tif (bt_popup(win->w_buffer))\n\t    win_close_buffer(win, DOBUF_WIPE_REUSE, FALSE);\n\telse\n\t    close_buffer(win, win->w_buffer, 0, FALSE, FALSE);\n    }\n# if defined(FEAT_TIMERS)\n    if (win->w_popup_timer != NULL)\n\tstop_timer(win->w_popup_timer);\n# endif\n    vim_free(win->w_frame);\n    win_free(win, NULL);\n}\n#endif\n\n/*\n * Append window \"wp\" in the window list after window \"after\".\n */\n    static void\nwin_append(win_T *after, win_T *wp)\n{\n    win_T\t*before;\n\n    if (after == NULL)\t    // after NULL is in front of the first\n\tbefore = firstwin;\n    else\n\tbefore = after->w_next;\n\n    wp->w_next = before;\n    wp->w_prev = after;\n    if (after == NULL)\n\tfirstwin = wp;\n    else\n\tafter->w_next = wp;\n    if (before == NULL)\n\tlastwin = wp;\n    else\n\tbefore->w_prev = wp;\n}\n\n/*\n * Remove a window from the window list.\n */\n    void\nwin_remove(\n    win_T\t*wp,\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    if (wp->w_prev != NULL)\n\twp->w_prev->w_next = wp->w_next;\n    else if (tp == NULL)\n\tfirstwin = curtab->tp_firstwin = wp->w_next;\n    else\n\ttp->tp_firstwin = wp->w_next;\n\n    if (wp->w_next != NULL)\n\twp->w_next->w_prev = wp->w_prev;\n    else if (tp == NULL)\n\tlastwin = curtab->tp_lastwin = wp->w_prev;\n    else\n\ttp->tp_lastwin = wp->w_prev;\n}\n\n/*\n * Append frame \"frp\" in a frame list after frame \"after\".\n */\n    static void\nframe_append(frame_T *after, frame_T *frp)\n{\n    frp->fr_next = after->fr_next;\n    after->fr_next = frp;\n    if (frp->fr_next != NULL)\n\tfrp->fr_next->fr_prev = frp;\n    frp->fr_prev = after;\n}\n\n/*\n * Insert frame \"frp\" in a frame list before frame \"before\".\n */\n    static void\nframe_insert(frame_T *before, frame_T *frp)\n{\n    frp->fr_next = before;\n    frp->fr_prev = before->fr_prev;\n    before->fr_prev = frp;\n    if (frp->fr_prev != NULL)\n\tfrp->fr_prev->fr_next = frp;\n    else\n\tfrp->fr_parent->fr_child = frp;\n}\n\n/*\n * Remove a frame from a frame list.\n */\n    static void\nframe_remove(frame_T *frp)\n{\n    if (frp->fr_prev != NULL)\n\tfrp->fr_prev->fr_next = frp->fr_next;\n    else\n\tfrp->fr_parent->fr_child = frp->fr_next;\n    if (frp->fr_next != NULL)\n\tfrp->fr_next->fr_prev = frp->fr_prev;\n}\n\n/*\n * Allocate w_lines[] for window \"wp\".\n * Return FAIL for failure, OK for success.\n */\n    int\nwin_alloc_lines(win_T *wp)\n{\n    wp->w_lines_valid = 0;\n    wp->w_lines = ALLOC_CLEAR_MULT(wline_T, Rows);\n    if (wp->w_lines == NULL)\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * free lsize arrays for a window\n */\n    void\nwin_free_lsize(win_T *wp)\n{\n    // TODO: why would wp be NULL here?\n    if (wp != NULL)\n\tVIM_CLEAR(wp->w_lines);\n}\n\n/*\n * Called from win_new_shellsize() after Rows changed.\n * This only does the current tab page, others must be done when made active.\n */\n    void\nshell_new_rows(void)\n{\n    int\t\th = (int)ROWS_AVAIL;\n\n    if (firstwin == NULL)\t// not initialized yet\n\treturn;\n    if (h < frame_minheight(topframe, NULL))\n\th = frame_minheight(topframe, NULL);\n\n    // First try setting the heights of windows with 'winfixheight'.  If\n    // that doesn't result in the right height, forget about that option.\n    frame_new_height(topframe, h, FALSE, TRUE);\n    if (!frame_check_height(topframe, h))\n\tframe_new_height(topframe, h, FALSE, FALSE);\n\n    (void)win_comp_pos();\t\t// recompute w_winrow and w_wincol\n    compute_cmdrow();\n    curtab->tp_ch_used = p_ch;\n\n#if 0\n    // Disabled: don't want making the screen smaller make a window larger.\n    if (p_ea)\n\twin_equal(curwin, FALSE, 'v');\n#endif\n}\n\n/*\n * Called from win_new_shellsize() after Columns changed.\n */\n    void\nshell_new_columns(void)\n{\n    if (firstwin == NULL)\t// not initialized yet\n\treturn;\n\n    // First try setting the widths of windows with 'winfixwidth'.  If that\n    // doesn't result in the right width, forget about that option.\n    frame_new_width(topframe, (int)Columns, FALSE, TRUE);\n    if (!frame_check_width(topframe, Columns))\n\tframe_new_width(topframe, (int)Columns, FALSE, FALSE);\n\n    (void)win_comp_pos();\t\t// recompute w_winrow and w_wincol\n#if 0\n    // Disabled: don't want making the screen smaller make a window larger.\n    if (p_ea)\n\twin_equal(curwin, FALSE, 'h');\n#endif\n}\n\n#if defined(FEAT_CMDWIN) || defined(PROTO)\n/*\n * Save the size of all windows in \"gap\".\n */\n    void\nwin_size_save(garray_T *gap)\n\n{\n    win_T\t*wp;\n\n    ga_init2(gap, sizeof(int), 1);\n    if (ga_grow(gap, win_count() * 2 + 1) == OK)\n    {\n\t// first entry is value of 'lines'\n\t((int *)gap->ga_data)[gap->ga_len++] = Rows;\n\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    ((int *)gap->ga_data)[gap->ga_len++] =\n\t\t\t\t\t       wp->w_width + wp->w_vsep_width;\n\t    ((int *)gap->ga_data)[gap->ga_len++] = wp->w_height;\n\t}\n    }\n}\n\n/*\n * Restore window sizes, but only if the number of windows is still the same\n * and 'lines' didn't change.\n * Does not free the growarray.\n */\n    void\nwin_size_restore(garray_T *gap)\n{\n    win_T\t*wp;\n    int\t\ti, j;\n\n    if (win_count() * 2 + 1 == gap->ga_len\n\t    && ((int *)gap->ga_data)[0] == Rows)\n    {\n\t// The order matters, because frames contain other frames, but it's\n\t// difficult to get right. The easy way out is to do it twice.\n\tfor (j = 0; j < 2; ++j)\n\t{\n\t    i = 1;\n\t    FOR_ALL_WINDOWS(wp)\n\t    {\n\t\tframe_setwidth(wp->w_frame, ((int *)gap->ga_data)[i++]);\n\t\twin_setheight_win(((int *)gap->ga_data)[i++], wp);\n\t    }\n\t}\n\t// recompute the window positions\n\t(void)win_comp_pos();\n    }\n}\n#endif // FEAT_CMDWIN\n\n/*\n * Update the position for all windows, using the width and height of the\n * frames.\n * Returns the row just after the last window.\n */\n    int\nwin_comp_pos(void)\n{\n    int\t\trow = tabline_height();\n    int\t\tcol = 0;\n\n    frame_comp_pos(topframe, &row, &col);\n    return row;\n}\n\n/*\n * Update the position of the windows in frame \"topfrp\", using the width and\n * height of the frames.\n * \"*row\" and \"*col\" are the top-left position of the frame.  They are updated\n * to the bottom-right position plus one.\n */\n    static void\nframe_comp_pos(frame_T *topfrp, int *row, int *col)\n{\n    win_T\t*wp;\n    frame_T\t*frp;\n    int\t\tstartcol;\n    int\t\tstartrow;\n    int\t\th;\n\n    wp = topfrp->fr_win;\n    if (wp != NULL)\n    {\n\tif (wp->w_winrow != *row || wp->w_wincol != *col)\n\t{\n\t    // position changed, redraw\n\t    wp->w_winrow = *row;\n\t    wp->w_wincol = *col;\n\t    redraw_win_later(wp, NOT_VALID);\n\t    wp->w_redr_status = TRUE;\n\t}\n\t// WinBar will not show if the window height is zero\n\th = VISIBLE_HEIGHT(wp) + wp->w_status_height;\n\t*row += h > topfrp->fr_height ? topfrp->fr_height : h;\n\t*col += wp->w_width + wp->w_vsep_width;\n    }\n    else\n    {\n\tstartrow = *row;\n\tstartcol = *col;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    if (topfrp->fr_layout == FR_ROW)\n\t\t*row = startrow;\t// all frames are at the same row\n\t    else\n\t\t*col = startcol;\t// all frames are at the same col\n\t    frame_comp_pos(frp, row, col);\n\t}\n    }\n}\n\n/*\n * Make the current window show at least one line and one column.\n */\n    void\nwin_ensure_size()\n{\n    if (curwin->w_height == 0)\n\twin_setheight(1);\n    if (curwin->w_width == 0)\n\twin_setwidth(1);\n}\n\n/*\n * Set current window height and take care of repositioning other windows to\n * fit around it.\n */\n    void\nwin_setheight(int height)\n{\n    win_setheight_win(height, curwin);\n}\n\n/*\n * Set the window height of window \"win\" and take care of repositioning other\n * windows to fit around it.\n */\n    void\nwin_setheight_win(int height, win_T *win)\n{\n    int\t\trow;\n\n    if (win == curwin)\n    {\n\t// Always keep current window at least one line high, even when\n\t// 'winminheight' is zero.\n\tif (height < p_wmh)\n\t    height = p_wmh;\n\tif (height == 0)\n\t    height = 1;\n\theight += WINBAR_HEIGHT(curwin);\n    }\n\n    frame_setheight(win->w_frame, height + win->w_status_height);\n\n    // recompute the window positions\n    row = win_comp_pos();\n\n    /*\n     * If there is extra space created between the last window and the command\n     * line, clear it.\n     */\n    if (full_screen && msg_scrolled == 0 && row < cmdline_row)\n\tscreen_fill(row, cmdline_row, 0, (int)Columns, ' ', ' ', 0);\n    cmdline_row = row;\n    msg_row = row;\n    msg_col = 0;\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Set the height of a frame to \"height\" and take care that all frames and\n * windows inside it are resized.  Also resize frames on the left and right if\n * the are in the same FR_ROW frame.\n *\n * Strategy:\n * If the frame is part of a FR_COL frame, try fitting the frame in that\n * frame.  If that doesn't work (the FR_COL frame is too small), recursively\n * go to containing frames to resize them and make room.\n * If the frame is part of a FR_ROW frame, all frames must be resized as well.\n * Check for the minimal height of the FR_ROW frame.\n * At the top level we can also use change the command line height.\n */\n    static void\nframe_setheight(frame_T *curfrp, int height)\n{\n    int\t\troom;\t\t// total number of lines available\n    int\t\ttake;\t\t// number of lines taken from other windows\n    int\t\troom_cmdline;\t// lines available from cmdline\n    int\t\trun;\n    frame_T\t*frp;\n    int\t\th;\n    int\t\troom_reserved;\n\n    // If the height already is the desired value, nothing to do.\n    if (curfrp->fr_height == height)\n\treturn;\n\n    if (curfrp->fr_parent == NULL)\n    {\n\t// topframe: can only change the command line\n\tif (height > ROWS_AVAIL)\n\t    height = ROWS_AVAIL;\n\tif (height > 0)\n\t    frame_new_height(curfrp, height, FALSE, FALSE);\n    }\n    else if (curfrp->fr_parent->fr_layout == FR_ROW)\n    {\n\t// Row of frames: Also need to resize frames left and right of this\n\t// one.  First check for the minimal height of these.\n\th = frame_minheight(curfrp->fr_parent, NULL);\n\tif (height < h)\n\t    height = h;\n\tframe_setheight(curfrp->fr_parent, height);\n    }\n    else\n    {\n\t/*\n\t * Column of frames: try to change only frames in this column.\n\t */\n\t/*\n\t * Do this twice:\n\t * 1: compute room available, if it's not enough try resizing the\n\t *    containing frame.\n\t * 2: compute the room available and adjust the height to it.\n\t * Try not to reduce the height of a window with 'winfixheight' set.\n\t */\n\tfor (run = 1; run <= 2; ++run)\n\t{\n\t    room = 0;\n\t    room_reserved = 0;\n\t    FOR_ALL_FRAMES(frp, curfrp->fr_parent->fr_child)\n\t    {\n\t\tif (frp != curfrp\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfh)\n\t\t    room_reserved += frp->fr_height;\n\t\troom += frp->fr_height;\n\t\tif (frp != curfrp)\n\t\t    room -= frame_minheight(frp, NULL);\n\t    }\n\t    if (curfrp->fr_width != Columns)\n\t\troom_cmdline = 0;\n\t    else\n\t    {\n\t\troom_cmdline = Rows - p_ch - (lastwin->w_winrow\n\t\t\t\t\t\t+ VISIBLE_HEIGHT(lastwin)\n\t\t\t\t\t\t+ lastwin->w_status_height);\n\t\tif (room_cmdline < 0)\n\t\t    room_cmdline = 0;\n\t    }\n\n\t    if (height <= room + room_cmdline)\n\t\tbreak;\n\t    if (run == 2 || curfrp->fr_width == Columns)\n\t    {\n\t\theight = room + room_cmdline;\n\t\tbreak;\n\t    }\n\t    frame_setheight(curfrp->fr_parent, height\n\t\t+ frame_minheight(curfrp->fr_parent, NOWIN) - (int)p_wmh - 1);\n\t}\n\n\t/*\n\t * Compute the number of lines we will take from others frames (can be\n\t * negative!).\n\t */\n\ttake = height - curfrp->fr_height;\n\n\t// If there is not enough room, also reduce the height of a window\n\t// with 'winfixheight' set.\n\tif (height > room + room_cmdline - room_reserved)\n\t    room_reserved = room + room_cmdline - height;\n\t// If there is only a 'winfixheight' window and making the\n\t// window smaller, need to make the other window taller.\n\tif (take < 0 && room - curfrp->fr_height < room_reserved)\n\t    room_reserved = 0;\n\n\tif (take > 0 && room_cmdline > 0)\n\t{\n\t    // use lines from cmdline first\n\t    if (take < room_cmdline)\n\t\troom_cmdline = take;\n\t    take -= room_cmdline;\n\t    topframe->fr_height += room_cmdline;\n\t}\n\n\t/*\n\t * set the current frame to the new height\n\t */\n\tframe_new_height(curfrp, height, FALSE, FALSE);\n\n\t/*\n\t * First take lines from the frames after the current frame.  If\n\t * that is not enough, takes lines from frames above the current\n\t * frame.\n\t */\n\tfor (run = 0; run < 2; ++run)\n\t{\n\t    if (run == 0)\n\t\tfrp = curfrp->fr_next;\t// 1st run: start with next window\n\t    else\n\t\tfrp = curfrp->fr_prev;\t// 2nd run: start with prev window\n\t    while (frp != NULL && take != 0)\n\t    {\n\t\th = frame_minheight(frp, NULL);\n\t\tif (room_reserved > 0\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfh)\n\t\t{\n\t\t    if (room_reserved >= frp->fr_height)\n\t\t\troom_reserved -= frp->fr_height;\n\t\t    else\n\t\t    {\n\t\t\tif (frp->fr_height - room_reserved > take)\n\t\t\t    room_reserved = frp->fr_height - take;\n\t\t\ttake -= frp->fr_height - room_reserved;\n\t\t\tframe_new_height(frp, room_reserved, FALSE, FALSE);\n\t\t\troom_reserved = 0;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (frp->fr_height - take < h)\n\t\t    {\n\t\t\ttake -= frp->fr_height - h;\n\t\t\tframe_new_height(frp, h, FALSE, FALSE);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tframe_new_height(frp, frp->fr_height - take,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\t\t\ttake = 0;\n\t\t    }\n\t\t}\n\t\tif (run == 0)\n\t\t    frp = frp->fr_next;\n\t\telse\n\t\t    frp = frp->fr_prev;\n\t    }\n\t}\n    }\n}\n\n/*\n * Set current window width and take care of repositioning other windows to\n * fit around it.\n */\n    void\nwin_setwidth(int width)\n{\n    win_setwidth_win(width, curwin);\n}\n\n    void\nwin_setwidth_win(int width, win_T *wp)\n{\n    // Always keep current window at least one column wide, even when\n    // 'winminwidth' is zero.\n    if (wp == curwin)\n    {\n\tif (width < p_wmw)\n\t    width = p_wmw;\n\tif (width == 0)\n\t    width = 1;\n    }\n    else if (width < 0)\n\twidth = 0;\n\n    frame_setwidth(wp->w_frame, width + wp->w_vsep_width);\n\n    // recompute the window positions\n    (void)win_comp_pos();\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Set the width of a frame to \"width\" and take care that all frames and\n * windows inside it are resized.  Also resize frames above and below if the\n * are in the same FR_ROW frame.\n *\n * Strategy is similar to frame_setheight().\n */\n    static void\nframe_setwidth(frame_T *curfrp, int width)\n{\n    int\t\troom;\t\t// total number of lines available\n    int\t\ttake;\t\t// number of lines taken from other windows\n    int\t\trun;\n    frame_T\t*frp;\n    int\t\tw;\n    int\t\troom_reserved;\n\n    // If the width already is the desired value, nothing to do.\n    if (curfrp->fr_width == width)\n\treturn;\n\n    if (curfrp->fr_parent == NULL)\n\t// topframe: can't change width\n\treturn;\n\n    if (curfrp->fr_parent->fr_layout == FR_COL)\n    {\n\t// Column of frames: Also need to resize frames above and below of\n\t// this one.  First check for the minimal width of these.\n\tw = frame_minwidth(curfrp->fr_parent, NULL);\n\tif (width < w)\n\t    width = w;\n\tframe_setwidth(curfrp->fr_parent, width);\n    }\n    else\n    {\n\t/*\n\t * Row of frames: try to change only frames in this row.\n\t *\n\t * Do this twice:\n\t * 1: compute room available, if it's not enough try resizing the\n\t *    containing frame.\n\t * 2: compute the room available and adjust the width to it.\n\t */\n\tfor (run = 1; run <= 2; ++run)\n\t{\n\t    room = 0;\n\t    room_reserved = 0;\n\t    FOR_ALL_FRAMES(frp, curfrp->fr_parent->fr_child)\n\t    {\n\t\tif (frp != curfrp\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfw)\n\t\t    room_reserved += frp->fr_width;\n\t\troom += frp->fr_width;\n\t\tif (frp != curfrp)\n\t\t    room -= frame_minwidth(frp, NULL);\n\t    }\n\n\t    if (width <= room)\n\t\tbreak;\n\t    if (run == 2 || curfrp->fr_height >= ROWS_AVAIL)\n\t    {\n\t\twidth = room;\n\t\tbreak;\n\t    }\n\t    frame_setwidth(curfrp->fr_parent, width\n\t\t + frame_minwidth(curfrp->fr_parent, NOWIN) - (int)p_wmw - 1);\n\t}\n\n\t/*\n\t * Compute the number of lines we will take from others frames (can be\n\t * negative!).\n\t */\n\ttake = width - curfrp->fr_width;\n\n\t// If there is not enough room, also reduce the width of a window\n\t// with 'winfixwidth' set.\n\tif (width > room - room_reserved)\n\t    room_reserved = room - width;\n\t// If there is only a 'winfixwidth' window and making the\n\t// window smaller, need to make the other window narrower.\n\tif (take < 0 && room - curfrp->fr_width < room_reserved)\n\t    room_reserved = 0;\n\n\t/*\n\t * set the current frame to the new width\n\t */\n\tframe_new_width(curfrp, width, FALSE, FALSE);\n\n\t/*\n\t * First take lines from the frames right of the current frame.  If\n\t * that is not enough, takes lines from frames left of the current\n\t * frame.\n\t */\n\tfor (run = 0; run < 2; ++run)\n\t{\n\t    if (run == 0)\n\t\tfrp = curfrp->fr_next;\t// 1st run: start with next window\n\t    else\n\t\tfrp = curfrp->fr_prev;\t// 2nd run: start with prev window\n\t    while (frp != NULL && take != 0)\n\t    {\n\t\tw = frame_minwidth(frp, NULL);\n\t\tif (room_reserved > 0\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfw)\n\t\t{\n\t\t    if (room_reserved >= frp->fr_width)\n\t\t\troom_reserved -= frp->fr_width;\n\t\t    else\n\t\t    {\n\t\t\tif (frp->fr_width - room_reserved > take)\n\t\t\t    room_reserved = frp->fr_width - take;\n\t\t\ttake -= frp->fr_width - room_reserved;\n\t\t\tframe_new_width(frp, room_reserved, FALSE, FALSE);\n\t\t\troom_reserved = 0;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (frp->fr_width - take < w)\n\t\t    {\n\t\t\ttake -= frp->fr_width - w;\n\t\t\tframe_new_width(frp, w, FALSE, FALSE);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tframe_new_width(frp, frp->fr_width - take,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\t\t\ttake = 0;\n\t\t    }\n\t\t}\n\t\tif (run == 0)\n\t\t    frp = frp->fr_next;\n\t\telse\n\t\t    frp = frp->fr_prev;\n\t    }\n\t}\n    }\n}\n\n/*\n * Check 'winminheight' for a valid value and reduce it if needed.\n */\n    void\nwin_setminheight(void)\n{\n    int\t\troom;\n    int\t\tneeded;\n    int\t\tfirst = TRUE;\n\n    // loop until there is a 'winminheight' that is possible\n    while (p_wmh > 0)\n    {\n\troom = Rows - p_ch;\n\tneeded = min_rows() - 1;  // 1 was added for the cmdline\n\tif (room >= needed)\n\t    break;\n\t--p_wmh;\n\tif (first)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    first = FALSE;\n\t}\n    }\n}\n\n/*\n * Check 'winminwidth' for a valid value and reduce it if needed.\n */\n    void\nwin_setminwidth(void)\n{\n    int\t\troom;\n    int\t\tneeded;\n    int\t\tfirst = TRUE;\n\n    // loop until there is a 'winminheight' that is possible\n    while (p_wmw > 0)\n    {\n\troom = Columns;\n\tneeded = frame_minwidth(topframe, NULL);\n\tif (room >= needed)\n\t    break;\n\t--p_wmw;\n\tif (first)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    first = FALSE;\n\t}\n    }\n}\n\n/*\n * Status line of dragwin is dragged \"offset\" lines down (negative is up).\n */\n    void\nwin_drag_status_line(win_T *dragwin, int offset)\n{\n    frame_T\t*curfr;\n    frame_T\t*fr;\n    int\t\troom;\n    int\t\trow;\n    int\t\tup;\t// if TRUE, drag status line up, otherwise down\n    int\t\tn;\n\n    fr = dragwin->w_frame;\n    curfr = fr;\n    if (fr != topframe)\t\t// more than one window\n    {\n\tfr = fr->fr_parent;\n\t// When the parent frame is not a column of frames, its parent should\n\t// be.\n\tif (fr->fr_layout != FR_COL)\n\t{\n\t    curfr = fr;\n\t    if (fr != topframe)\t// only a row of windows, may drag statusline\n\t\tfr = fr->fr_parent;\n\t}\n    }\n\n    // If this is the last frame in a column, may want to resize the parent\n    // frame instead (go two up to skip a row of frames).\n    while (curfr != topframe && curfr->fr_next == NULL)\n    {\n\tif (fr != topframe)\n\t    fr = fr->fr_parent;\n\tcurfr = fr;\n\tif (fr != topframe)\n\t    fr = fr->fr_parent;\n    }\n\n    if (offset < 0) // drag up\n    {\n\tup = TRUE;\n\toffset = -offset;\n\t// sum up the room of the current frame and above it\n\tif (fr == curfr)\n\t{\n\t    // only one window\n\t    room = fr->fr_height - frame_minheight(fr, NULL);\n\t}\n\telse\n\t{\n\t    room = 0;\n\t    for (fr = fr->fr_child; ; fr = fr->fr_next)\n\t    {\n\t\troom += fr->fr_height - frame_minheight(fr, NULL);\n\t\tif (fr == curfr)\n\t\t    break;\n\t    }\n\t}\n\tfr = curfr->fr_next;\t\t// put fr at frame that grows\n    }\n    else    // drag down\n    {\n\tup = FALSE;\n\t/*\n\t * Only dragging the last status line can reduce p_ch.\n\t */\n\troom = Rows - cmdline_row;\n\tif (curfr->fr_next == NULL)\n\t    room -= 1;\n\telse\n\t    room -= p_ch;\n\tif (room < 0)\n\t    room = 0;\n\t// sum up the room of frames below of the current one\n\tFOR_ALL_FRAMES(fr, curfr->fr_next)\n\t    room += fr->fr_height - frame_minheight(fr, NULL);\n\tfr = curfr;\t\t\t// put fr at window that grows\n    }\n\n    if (room < offset)\t\t// Not enough room\n\toffset = room;\t\t// Move as far as we can\n    if (offset <= 0)\n\treturn;\n\n    /*\n     * Grow frame fr by \"offset\" lines.\n     * Doesn't happen when dragging the last status line up.\n     */\n    if (fr != NULL)\n\tframe_new_height(fr, fr->fr_height + offset, up, FALSE);\n\n    if (up)\n\tfr = curfr;\t\t// current frame gets smaller\n    else\n\tfr = curfr->fr_next;\t// next frame gets smaller\n\n    /*\n     * Now make the other frames smaller.\n     */\n    while (fr != NULL && offset > 0)\n    {\n\tn = frame_minheight(fr, NULL);\n\tif (fr->fr_height - offset <= n)\n\t{\n\t    offset -= fr->fr_height - n;\n\t    frame_new_height(fr, n, !up, FALSE);\n\t}\n\telse\n\t{\n\t    frame_new_height(fr, fr->fr_height - offset, !up, FALSE);\n\t    break;\n\t}\n\tif (up)\n\t    fr = fr->fr_prev;\n\telse\n\t    fr = fr->fr_next;\n    }\n    row = win_comp_pos();\n    screen_fill(row, cmdline_row, 0, (int)Columns, ' ', ' ', 0);\n    cmdline_row = row;\n    p_ch = Rows - cmdline_row;\n    if (p_ch < 1)\n\tp_ch = 1;\n    curtab->tp_ch_used = p_ch;\n    redraw_all_later(SOME_VALID);\n    showmode();\n}\n\n/*\n * Separator line of dragwin is dragged \"offset\" lines right (negative is left).\n */\n    void\nwin_drag_vsep_line(win_T *dragwin, int offset)\n{\n    frame_T\t*curfr;\n    frame_T\t*fr;\n    int\t\troom;\n    int\t\tleft;\t// if TRUE, drag separator line left, otherwise right\n    int\t\tn;\n\n    fr = dragwin->w_frame;\n    if (fr == topframe)\t\t// only one window (cannot happen?)\n\treturn;\n    curfr = fr;\n    fr = fr->fr_parent;\n    // When the parent frame is not a row of frames, its parent should be.\n    if (fr->fr_layout != FR_ROW)\n    {\n\tif (fr == topframe)\t// only a column of windows (cannot happen?)\n\t    return;\n\tcurfr = fr;\n\tfr = fr->fr_parent;\n    }\n\n    // If this is the last frame in a row, may want to resize a parent\n    // frame instead.\n    while (curfr->fr_next == NULL)\n    {\n\tif (fr == topframe)\n\t    break;\n\tcurfr = fr;\n\tfr = fr->fr_parent;\n\tif (fr != topframe)\n\t{\n\t    curfr = fr;\n\t    fr = fr->fr_parent;\n\t}\n    }\n\n    if (offset < 0) // drag left\n    {\n\tleft = TRUE;\n\toffset = -offset;\n\t// sum up the room of the current frame and left of it\n\troom = 0;\n\tfor (fr = fr->fr_child; ; fr = fr->fr_next)\n\t{\n\t    room += fr->fr_width - frame_minwidth(fr, NULL);\n\t    if (fr == curfr)\n\t\tbreak;\n\t}\n\tfr = curfr->fr_next;\t\t// put fr at frame that grows\n    }\n    else    // drag right\n    {\n\tleft = FALSE;\n\t// sum up the room of frames right of the current one\n\troom = 0;\n\tFOR_ALL_FRAMES(fr, curfr->fr_next)\n\t    room += fr->fr_width - frame_minwidth(fr, NULL);\n\tfr = curfr;\t\t\t// put fr at window that grows\n    }\n\n    if (room < offset)\t\t// Not enough room\n\toffset = room;\t\t// Move as far as we can\n    if (offset <= 0)\t\t// No room at all, quit.\n\treturn;\n    if (fr == NULL)\n\t// This can happen when calling win_move_separator() on the rightmost\n\t// window.  Just don't do anything.\n\treturn;\t\t\t\n\n    // grow frame fr by offset lines\n    frame_new_width(fr, fr->fr_width + offset, left, FALSE);\n\n    // shrink other frames: current and at the left or at the right\n    if (left)\n\tfr = curfr;\t\t// current frame gets smaller\n    else\n\tfr = curfr->fr_next;\t// next frame gets smaller\n\n    while (fr != NULL && offset > 0)\n    {\n\tn = frame_minwidth(fr, NULL);\n\tif (fr->fr_width - offset <= n)\n\t{\n\t    offset -= fr->fr_width - n;\n\t    frame_new_width(fr, n, !left, FALSE);\n\t}\n\telse\n\t{\n\t    frame_new_width(fr, fr->fr_width - offset, !left, FALSE);\n\t    break;\n\t}\n\tif (left)\n\t    fr = fr->fr_prev;\n\telse\n\t    fr = fr->fr_next;\n    }\n    (void)win_comp_pos();\n    redraw_all_later(NOT_VALID);\n}\n\n#define FRACTION_MULT\t16384L\n\n/*\n * Set wp->w_fraction for the current w_wrow and w_height.\n * Has no effect when the window is less than two lines.\n */\n    void\nset_fraction(win_T *wp)\n{\n    if (wp->w_height > 1)\n\t// When cursor is in the first line the percentage is computed as if\n\t// it's halfway that line.  Thus with two lines it is 25%, with three\n\t// lines 17%, etc.  Similarly for the last line: 75%, 83%, etc.\n\twp->w_fraction = ((long)wp->w_wrow * FRACTION_MULT\n\t\t\t\t     + FRACTION_MULT / 2) / (long)wp->w_height;\n}\n\n/*\n * Set the height of a window.\n * \"height\" excludes any window toolbar.\n * This takes care of the things inside the window, not what happens to the\n * window position, the frame or to other windows.\n */\n    void\nwin_new_height(win_T *wp, int height)\n{\n    int\t\tprev_height = wp->w_height;\n\n    // Don't want a negative height.  Happens when splitting a tiny window.\n    // Will equalize heights soon to fix it.\n    if (height < 0)\n\theight = 0;\n    if (wp->w_height == height)\n\treturn;\t    // nothing to do\n\n    if (wp->w_height > 0)\n    {\n\tif (wp == curwin)\n\t    // w_wrow needs to be valid. When setting 'laststatus' this may\n\t    // call win_new_height() recursively.\n\t    validate_cursor();\n\tif (wp->w_height != prev_height)\n\t    return;  // Recursive call already changed the size, bail out here\n\t\t     //\tto avoid the following to mess things up.\n\tif (wp->w_wrow != wp->w_prev_fraction_row)\n\t    set_fraction(wp);\n    }\n\n    wp->w_height = height;\n    wp->w_skipcol = 0;\n\n    // There is no point in adjusting the scroll position when exiting.  Some\n    // values might be invalid.\n    if (!exiting)\n\tscroll_to_fraction(wp, prev_height);\n}\n\n    void\nscroll_to_fraction(win_T *wp, int prev_height)\n{\n    linenr_T\tlnum;\n    int\t\tsline, line_size;\n    int\t\theight = wp->w_height;\n\n    // Don't change w_topline in any of these cases:\n    // - window height is 0\n    // - 'scrollbind' is set and this isn't the current window\n    // - window height is sufficient to display the whole buffer and first line\n    //   is visible.\n    if (height > 0\n\t   && (!wp->w_p_scb || wp == curwin)\n\t   && (height < wp->w_buffer->b_ml.ml_line_count || wp->w_topline > 1))\n    {\n\t/*\n\t * Find a value for w_topline that shows the cursor at the same\n\t * relative position in the window as before (more or less).\n\t */\n\tlnum = wp->w_cursor.lnum;\n\tif (lnum < 1)\t\t// can happen when starting up\n\t    lnum = 1;\n\twp->w_wrow = ((long)wp->w_fraction * (long)height - 1L)\n\t\t\t\t\t\t\t       / FRACTION_MULT;\n\tline_size = plines_win_col(wp, lnum, (long)(wp->w_cursor.col)) - 1;\n\tsline = wp->w_wrow - line_size;\n\n\tif (sline >= 0)\n\t{\n\t    // Make sure the whole cursor line is visible, if possible.\n\t    int rows = plines_win(wp, lnum, FALSE);\n\n\t    if (sline > wp->w_height - rows)\n\t    {\n\t\tsline = wp->w_height - rows;\n\t\twp->w_wrow -= rows - line_size;\n\t    }\n\t}\n\n\tif (sline < 0)\n\t{\n\t    /*\n\t     * Cursor line would go off top of screen if w_wrow was this high.\n\t     * Make cursor line the first line in the window.  If not enough\n\t     * room use w_skipcol;\n\t     */\n\t    wp->w_wrow = line_size;\n\t    if (wp->w_wrow >= wp->w_height\n\t\t\t\t       && (wp->w_width - win_col_off(wp)) > 0)\n\t    {\n\t\twp->w_skipcol += wp->w_width - win_col_off(wp);\n\t\t--wp->w_wrow;\n\t\twhile (wp->w_wrow >= wp->w_height)\n\t\t{\n\t\t    wp->w_skipcol += wp->w_width - win_col_off(wp)\n\t\t\t\t\t\t\t   + win_col_off2(wp);\n\t\t    --wp->w_wrow;\n\t\t}\n\t    }\n\t}\n\telse if (sline > 0)\n\t{\n\t    while (sline > 0 && lnum > 1)\n\t    {\n#ifdef FEAT_FOLDING\n\t\thasFoldingWin(wp, lnum, &lnum, NULL, TRUE, NULL);\n\t\tif (lnum == 1)\n\t\t{\n\t\t    // first line in buffer is folded\n\t\t    line_size = 1;\n\t\t    --sline;\n\t\t    break;\n\t\t}\n#endif\n\t\t--lnum;\n#ifdef FEAT_DIFF\n\t\tif (lnum == wp->w_topline)\n\t\t    line_size = plines_win_nofill(wp, lnum, TRUE)\n\t\t\t\t\t\t\t      + wp->w_topfill;\n\t\telse\n#endif\n\t\t    line_size = plines_win(wp, lnum, TRUE);\n\t\tsline -= line_size;\n\t    }\n\n\t    if (sline < 0)\n\t    {\n\t\t/*\n\t\t * Line we want at top would go off top of screen.  Use next\n\t\t * line instead.\n\t\t */\n#ifdef FEAT_FOLDING\n\t\thasFoldingWin(wp, lnum, NULL, &lnum, TRUE, NULL);\n#endif\n\t\tlnum++;\n\t\twp->w_wrow -= line_size + sline;\n\t    }\n\t    else if (sline > 0)\n\t    {\n\t\t// First line of file reached, use that as topline.\n\t\tlnum = 1;\n\t\twp->w_wrow -= sline;\n\t    }\n\t}\n\tset_topline(wp, lnum);\n    }\n\n    if (wp == curwin)\n    {\n\tif (get_scrolloff_value())\n\t    update_topline();\n\tcurs_columns(FALSE);\t// validate w_wrow\n    }\n    if (prev_height > 0)\n\twp->w_prev_fraction_row = wp->w_wrow;\n\n    win_comp_scroll(wp);\n    redraw_win_later(wp, SOME_VALID);\n    wp->w_redr_status = TRUE;\n    invalidate_botline_win(wp);\n}\n\n/*\n * Set the width of a window.\n */\n    void\nwin_new_width(win_T *wp, int width)\n{\n    wp->w_width = width;\n    wp->w_lines_valid = 0;\n    changed_line_abv_curs_win(wp);\n    invalidate_botline_win(wp);\n    if (wp == curwin)\n    {\n\tupdate_topline();\n\tcurs_columns(TRUE);\t// validate w_wrow\n    }\n    redraw_win_later(wp, NOT_VALID);\n    wp->w_redr_status = TRUE;\n}\n\n    void\nwin_comp_scroll(win_T *wp)\n{\n#if defined(FEAT_EVAL)\n    int old_w_p_scr = wp->w_p_scr;\n#endif\n\n    wp->w_p_scr = ((unsigned)wp->w_height >> 1);\n    if (wp->w_p_scr == 0)\n\twp->w_p_scr = 1;\n#if defined(FEAT_EVAL)\n    if (wp->w_p_scr != old_w_p_scr)\n    {\n\t// Used by \"verbose set scroll\".\n\twp->w_p_script_ctx[WV_SCROLL].sc_sid = SID_WINLAYOUT;\n\twp->w_p_script_ctx[WV_SCROLL].sc_lnum = 0;\n    }\n#endif\n}\n\n/*\n * command_height: called whenever p_ch has been changed\n */\n    void\ncommand_height(void)\n{\n    int\t\th;\n    frame_T\t*frp;\n    int\t\told_p_ch = curtab->tp_ch_used;\n\n    // Use the value of p_ch that we remembered.  This is needed for when the\n    // GUI starts up, we can't be sure in what order things happen.  And when\n    // p_ch was changed in another tab page.\n    curtab->tp_ch_used = p_ch;\n\n    // Find bottom frame with width of screen.\n    frp = lastwin->w_frame;\n    while (frp->fr_width != Columns && frp->fr_parent != NULL)\n\tfrp = frp->fr_parent;\n\n    // Avoid changing the height of a window with 'winfixheight' set.\n    while (frp->fr_prev != NULL && frp->fr_layout == FR_LEAF\n\t\t\t\t\t\t      && frp->fr_win->w_p_wfh)\n\tfrp = frp->fr_prev;\n\n    if (starting != NO_SCREEN)\n    {\n\tcmdline_row = Rows - p_ch;\n\n\tif (p_ch > old_p_ch)\t\t    // p_ch got bigger\n\t{\n\t    while (p_ch > old_p_ch)\n\t    {\n\t\tif (frp == NULL)\n\t\t{\n\t\t    emsg(_(e_not_enough_room));\n\t\t    p_ch = old_p_ch;\n\t\t    curtab->tp_ch_used = p_ch;\n\t\t    cmdline_row = Rows - p_ch;\n\t\t    break;\n\t\t}\n\t\th = frp->fr_height - frame_minheight(frp, NULL);\n\t\tif (h > p_ch - old_p_ch)\n\t\t    h = p_ch - old_p_ch;\n\t\told_p_ch += h;\n\t\tframe_add_height(frp, -h);\n\t\tfrp = frp->fr_prev;\n\t    }\n\n\t    // Recompute window positions.\n\t    (void)win_comp_pos();\n\n\t    // clear the lines added to cmdline\n\t    if (full_screen)\n\t\tscreen_fill(cmdline_row, (int)Rows, 0,\n\t\t\t\t\t\t   (int)Columns, ' ', ' ', 0);\n\t    msg_row = cmdline_row;\n\t    redraw_cmdline = TRUE;\n\t    return;\n\t}\n\n\tif (msg_row < cmdline_row)\n\t    msg_row = cmdline_row;\n\tredraw_cmdline = TRUE;\n    }\n    frame_add_height(frp, (int)(old_p_ch - p_ch));\n\n    // Recompute window positions.\n    if (frp != lastwin->w_frame)\n\t(void)win_comp_pos();\n}\n\n/*\n * Resize frame \"frp\" to be \"n\" lines higher (negative for less high).\n * Also resize the frames it is contained in.\n */\n    static void\nframe_add_height(frame_T *frp, int n)\n{\n    frame_new_height(frp, frp->fr_height + n, FALSE, FALSE);\n    for (;;)\n    {\n\tfrp = frp->fr_parent;\n\tif (frp == NULL)\n\t    break;\n\tfrp->fr_height += n;\n    }\n}\n\n/*\n * Add or remove a status line for the bottom window(s), according to the\n * value of 'laststatus'.\n */\n    void\nlast_status(\n    int\t\tmorewin)\t// pretend there are two or more windows\n{\n    // Don't make a difference between horizontal or vertical split.\n    last_status_rec(topframe, (p_ls == 2\n\t\t\t  || (p_ls == 1 && (morewin || !ONE_WINDOW))));\n}\n\n    static void\nlast_status_rec(frame_T *fr, int statusline)\n{\n    frame_T\t*fp;\n    win_T\t*wp;\n\n    if (fr->fr_layout == FR_LEAF)\n    {\n\twp = fr->fr_win;\n\tif (wp->w_status_height != 0 && !statusline)\n\t{\n\t    // remove status line\n\t    win_new_height(wp, wp->w_height + 1);\n\t    wp->w_status_height = 0;\n\t    comp_col();\n\t}\n\telse if (wp->w_status_height == 0 && statusline)\n\t{\n\t    // Find a frame to take a line from.\n\t    fp = fr;\n\t    while (fp->fr_height <= frame_minheight(fp, NULL))\n\t    {\n\t\tif (fp == topframe)\n\t\t{\n\t\t    emsg(_(e_not_enough_room));\n\t\t    return;\n\t\t}\n\t\t// In a column of frames: go to frame above.  If already at\n\t\t// the top or in a row of frames: go to parent.\n\t\tif (fp->fr_parent->fr_layout == FR_COL && fp->fr_prev != NULL)\n\t\t    fp = fp->fr_prev;\n\t\telse\n\t\t    fp = fp->fr_parent;\n\t    }\n\t    wp->w_status_height = 1;\n\t    if (fp != fr)\n\t    {\n\t\tframe_new_height(fp, fp->fr_height - 1, FALSE, FALSE);\n\t\tframe_fix_height(wp);\n\t\t(void)win_comp_pos();\n\t    }\n\t    else\n\t\twin_new_height(wp, wp->w_height - 1);\n\t    comp_col();\n\t    redraw_all_later(SOME_VALID);\n\t}\n    }\n    else if (fr->fr_layout == FR_ROW)\n    {\n\t// vertically split windows, set status line for each one\n\tFOR_ALL_FRAMES(fp, fr->fr_child)\n\t    last_status_rec(fp, statusline);\n    }\n    else\n    {\n\t// horizontally split window, set status line for last one\n\tfor (fp = fr->fr_child; fp->fr_next != NULL; fp = fp->fr_next)\n\t    ;\n\tlast_status_rec(fp, statusline);\n    }\n}\n\n/*\n * Return the number of lines used by the tab page line.\n */\n    int\ntabline_height(void)\n{\n#ifdef FEAT_GUI_TABLINE\n    // When the GUI has the tabline then this always returns zero.\n    if (gui_use_tabline())\n\treturn 0;\n#endif\n    switch (p_stal)\n    {\n\tcase 0: return 0;\n\tcase 1: return (first_tabpage->tp_next == NULL) ? 0 : 1;\n    }\n    return 1;\n}\n\n/*\n * Return the minimal number of rows that is needed on the screen to display\n * the current number of windows.\n */\n    int\nmin_rows(void)\n{\n    int\t\ttotal;\n    tabpage_T\t*tp;\n    int\t\tn;\n\n    if (firstwin == NULL)\t// not initialized yet\n\treturn MIN_LINES;\n\n    total = 0;\n    FOR_ALL_TABPAGES(tp)\n    {\n\tn = frame_minheight(tp->tp_topframe, NULL);\n\tif (total < n)\n\t    total = n;\n    }\n    total += tabline_height();\n    total += 1;\t\t// count the room for the command line\n    return total;\n}\n\n/*\n * Return TRUE if there is only one window and only one tab page, not\n * counting a help or preview window, unless it is the current window.\n * Does not count unlisted windows.\n */\n    int\nonly_one_window(void)\n{\n    int\t\tcount = 0;\n    win_T\t*wp;\n\n#if defined(FEAT_PROP_POPUP)\n    // If the current window is a popup then there always is another window.\n    if (popup_is_popup(curwin))\n\treturn FALSE;\n#endif\n\n    // If there is another tab page there always is another window.\n    if (first_tabpage->tp_next != NULL)\n\treturn FALSE;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_buffer != NULL\n\t\t&& (!((bt_help(wp->w_buffer) && !bt_help(curbuf))\n# ifdef FEAT_QUICKFIX\n\t\t    || wp->w_p_pvw\n# endif\n\t     ) || wp == curwin) && wp != aucmd_win)\n\t    ++count;\n    return (count <= 1);\n}\n\n/*\n * Correct the cursor line number in other windows.  Used after changing the\n * current buffer, and before applying autocommands.\n * When \"do_curwin\" is TRUE, also check current window.\n */\n    void\ncheck_lnums(int do_curwin)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif ((do_curwin || wp != curwin) && wp->w_buffer == curbuf)\n\t{\n\t    // save the original cursor position and topline\n\t    wp->w_save_cursor.w_cursor_save = wp->w_cursor;\n\t    wp->w_save_cursor.w_topline_save = wp->w_topline;\n\n\t    if (wp->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\twp->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    if (wp->w_topline > curbuf->b_ml.ml_line_count)\n\t\twp->w_topline = curbuf->b_ml.ml_line_count;\n\n\t    // save the corrected cursor position and topline\n\t    wp->w_save_cursor.w_cursor_corr = wp->w_cursor;\n\t    wp->w_save_cursor.w_topline_corr = wp->w_topline;\n\t}\n}\n\n/*\n * Reset cursor and topline to its stored values from check_lnums().\n * check_lnums() must have been called first!\n */\n    void\nreset_lnums()\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif (wp->w_buffer == curbuf)\n\t{\n\t    // Restore the value if the autocommand didn't change it.\n\t    if (EQUAL_POS(wp->w_save_cursor.w_cursor_corr, wp->w_cursor))\n\t\twp->w_cursor = wp->w_save_cursor.w_cursor_save;\n\t    if (wp->w_save_cursor.w_topline_corr == wp->w_topline)\n\t\twp->w_topline = wp->w_save_cursor.w_topline_save;\n\t}\n}\n\n/*\n * A snapshot of the window sizes, to restore them after closing the help\n * window.\n * Only these fields are used:\n * fr_layout\n * fr_width\n * fr_height\n * fr_next\n * fr_child\n * fr_win (only valid for the old curwin, NULL otherwise)\n */\n\n/*\n * Create a snapshot of the current frame sizes.\n */\n    void\nmake_snapshot(int idx)\n{\n    clear_snapshot(curtab, idx);\n    make_snapshot_rec(topframe, &curtab->tp_snapshot[idx]);\n}\n\n    static void\nmake_snapshot_rec(frame_T *fr, frame_T **frp)\n{\n    *frp = ALLOC_CLEAR_ONE(frame_T);\n    if (*frp == NULL)\n\treturn;\n    (*frp)->fr_layout = fr->fr_layout;\n    (*frp)->fr_width = fr->fr_width;\n    (*frp)->fr_height = fr->fr_height;\n    if (fr->fr_next != NULL)\n\tmake_snapshot_rec(fr->fr_next, &((*frp)->fr_next));\n    if (fr->fr_child != NULL)\n\tmake_snapshot_rec(fr->fr_child, &((*frp)->fr_child));\n    if (fr->fr_layout == FR_LEAF && fr->fr_win == curwin)\n\t(*frp)->fr_win = curwin;\n}\n\n/*\n * Remove any existing snapshot.\n */\n    static void\nclear_snapshot(tabpage_T *tp, int idx)\n{\n    clear_snapshot_rec(tp->tp_snapshot[idx]);\n    tp->tp_snapshot[idx] = NULL;\n}\n\n    static void\nclear_snapshot_rec(frame_T *fr)\n{\n    if (fr != NULL)\n    {\n\tclear_snapshot_rec(fr->fr_next);\n\tclear_snapshot_rec(fr->fr_child);\n\tvim_free(fr);\n    }\n}\n\n/*\n * Traverse a snapshot to find the previous curwin.\n */\n    static win_T *\nget_snapshot_curwin_rec(frame_T *ft)\n{\n    win_T\t*wp;\n\n    if (ft->fr_next != NULL)\n    {\n\tif ((wp = get_snapshot_curwin_rec(ft->fr_next)) != NULL)\n\t    return wp;\n    }\n    if (ft->fr_child != NULL)\n    {\n\tif ((wp = get_snapshot_curwin_rec(ft->fr_child)) != NULL)\n\t    return wp;\n    }\n\n    return ft->fr_win;\n}\n\n/*\n * Return the current window stored in the snapshot or NULL.\n */\n    static win_T *\nget_snapshot_curwin(int idx)\n{\n    if (curtab->tp_snapshot[idx] == NULL)\n\treturn NULL;\n\n    return get_snapshot_curwin_rec(curtab->tp_snapshot[idx]);\n}\n\n/*\n * Restore a previously created snapshot, if there is any.\n * This is only done if the screen size didn't change and the window layout is\n * still the same.\n */\n    void\nrestore_snapshot(\n    int\t\tidx,\n    int\t\tclose_curwin)\t    // closing current window\n{\n    win_T\t*wp;\n\n    if (curtab->tp_snapshot[idx] != NULL\n\t    && curtab->tp_snapshot[idx]->fr_width == topframe->fr_width\n\t    && curtab->tp_snapshot[idx]->fr_height == topframe->fr_height\n\t    && check_snapshot_rec(curtab->tp_snapshot[idx], topframe) == OK)\n    {\n\twp = restore_snapshot_rec(curtab->tp_snapshot[idx], topframe);\n\twin_comp_pos();\n\tif (wp != NULL && close_curwin)\n\t    win_goto(wp);\n\tredraw_all_later(NOT_VALID);\n    }\n    clear_snapshot(curtab, idx);\n}\n\n/*\n * Check if frames \"sn\" and \"fr\" have the same layout, same following frames\n * and same children.  And the window pointer is valid.\n */\n    static int\ncheck_snapshot_rec(frame_T *sn, frame_T *fr)\n{\n    if (sn->fr_layout != fr->fr_layout\n\t    || (sn->fr_next == NULL) != (fr->fr_next == NULL)\n\t    || (sn->fr_child == NULL) != (fr->fr_child == NULL)\n\t    || (sn->fr_next != NULL\n\t\t&& check_snapshot_rec(sn->fr_next, fr->fr_next) == FAIL)\n\t    || (sn->fr_child != NULL\n\t\t&& check_snapshot_rec(sn->fr_child, fr->fr_child) == FAIL)\n\t    || (sn->fr_win != NULL && !win_valid(sn->fr_win)))\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Copy the size of snapshot frame \"sn\" to frame \"fr\".  Do the same for all\n * following frames and children.\n * Returns a pointer to the old current window, or NULL.\n */\n    static win_T *\nrestore_snapshot_rec(frame_T *sn, frame_T *fr)\n{\n    win_T\t*wp = NULL;\n    win_T\t*wp2;\n\n    fr->fr_height = sn->fr_height;\n    fr->fr_width = sn->fr_width;\n    if (fr->fr_layout == FR_LEAF)\n    {\n\tframe_new_height(fr, fr->fr_height, FALSE, FALSE);\n\tframe_new_width(fr, fr->fr_width, FALSE, FALSE);\n\twp = sn->fr_win;\n    }\n    if (sn->fr_next != NULL)\n    {\n\twp2 = restore_snapshot_rec(sn->fr_next, fr->fr_next);\n\tif (wp2 != NULL)\n\t    wp = wp2;\n    }\n    if (sn->fr_child != NULL)\n    {\n\twp2 = restore_snapshot_rec(sn->fr_child, fr->fr_child);\n\tif (wp2 != NULL)\n\t    wp = wp2;\n    }\n    return wp;\n}\n\n#if defined(FEAT_GUI) || defined(PROTO)\n/*\n * Return TRUE if there is any vertically split window.\n */\n    int\nwin_hasvertsplit(void)\n{\n    frame_T\t*fr;\n\n    if (topframe->fr_layout == FR_ROW)\n\treturn TRUE;\n\n    if (topframe->fr_layout == FR_COL)\n\tFOR_ALL_FRAMES(fr, topframe->fr_child)\n\t    if (fr->fr_layout == FR_ROW)\n\t\treturn TRUE;\n\n    return FALSE;\n}\n#endif\n\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) || defined(PROTO)\n    int\nget_win_number(win_T *wp, win_T *first_win)\n{\n    int\t\ti = 1;\n    win_T\t*w;\n\n    for (w = first_win; w != NULL && w != wp; w = W_NEXT(w))\n\t++i;\n\n    if (w == NULL)\n\treturn 0;\n    else\n\treturn i;\n}\n\n    int\nget_tab_number(tabpage_T *tp UNUSED)\n{\n    int\t\ti = 1;\n    tabpage_T\t*t;\n\n    for (t = first_tabpage; t != NULL && t != tp; t = t->tp_next)\n\t++i;\n\n    if (t == NULL)\n\treturn 0;\n    else\n\treturn i;\n}\n#endif\n\n/*\n * Return TRUE if \"topfrp\" and its children are at the right height.\n */\n    static int\nframe_check_height(frame_T *topfrp, int height)\n{\n    frame_T *frp;\n\n    if (topfrp->fr_height != height)\n\treturn FALSE;\n\n    if (topfrp->fr_layout == FR_ROW)\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    if (frp->fr_height != height)\n\t\treturn FALSE;\n\n    return TRUE;\n}\n\n/*\n * Return TRUE if \"topfrp\" and its children are at the right width.\n */\n    static int\nframe_check_width(frame_T *topfrp, int width)\n{\n    frame_T *frp;\n\n    if (topfrp->fr_width != width)\n\treturn FALSE;\n\n    if (topfrp->fr_layout == FR_COL)\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    if (frp->fr_width != width)\n\t\treturn FALSE;\n\n    return TRUE;\n}\n\n#if defined(FEAT_SYN_HL) || defined(PROTO)\n/*\n * Simple int comparison function for use with qsort()\n */\n    static int\nint_cmp(const void *a, const void *b)\n{\n    return *(const int *)a - *(const int *)b;\n}\n\n/*\n * Handle setting 'colorcolumn' or 'textwidth' in window \"wp\".\n * Returns error message, NULL if it's OK.\n */\n    char *\ncheck_colorcolumn(win_T *wp)\n{\n    char_u\t*s;\n    int\t\tcol;\n    int\t\tcount = 0;\n    int\t\tcolor_cols[256];\n    int\t\ti;\n    int\t\tj = 0;\n\n    if (wp->w_buffer == NULL)\n\treturn NULL;  // buffer was closed\n\n    for (s = wp->w_p_cc; *s != NUL && count < 255;)\n    {\n\tif (*s == '-' || *s == '+')\n\t{\n\t    // -N and +N: add to 'textwidth'\n\t    col = (*s == '-') ? -1 : 1;\n\t    ++s;\n\t    if (!VIM_ISDIGIT(*s))\n\t\treturn e_invalid_argument;\n\t    col = col * getdigits(&s);\n\t    if (wp->w_buffer->b_p_tw == 0)\n\t\tgoto skip;  // 'textwidth' not set, skip this item\n\t    col += wp->w_buffer->b_p_tw;\n\t    if (col < 0)\n\t\tgoto skip;\n\t}\n\telse if (VIM_ISDIGIT(*s))\n\t    col = getdigits(&s);\n\telse\n\t    return e_invalid_argument;\n\tcolor_cols[count++] = col - 1;  // 1-based to 0-based\nskip:\n\tif (*s == NUL)\n\t    break;\n\tif (*s != ',')\n\t    return e_invalid_argument;\n\tif (*++s == NUL)\n\t    return e_invalid_argument;  // illegal trailing comma as in \"set cc=80,\"\n    }\n\n    vim_free(wp->w_p_cc_cols);\n    if (count == 0)\n\twp->w_p_cc_cols = NULL;\n    else\n    {\n\twp->w_p_cc_cols = ALLOC_MULT(int, count + 1);\n\tif (wp->w_p_cc_cols != NULL)\n\t{\n\t    // sort the columns for faster usage on screen redraw inside\n\t    // win_line()\n\t    qsort(color_cols, count, sizeof(int), int_cmp);\n\n\t    for (i = 0; i < count; ++i)\n\t\t// skip duplicates\n\t\tif (j == 0 || wp->w_p_cc_cols[j - 1] != color_cols[i])\n\t\t    wp->w_p_cc_cols[j++] = color_cols[i];\n\t    wp->w_p_cc_cols[j] = -1;  // end marker\n\t}\n    }\n\n    return NULL;  // no error\n}\n#endif\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * buffer.c: functions for dealing with the buffer structure\n */\n\n/*\n * The buffer list is a double linked list of all buffers.\n * Each buffer can be in one of these states:\n * never loaded: BF_NEVERLOADED is set, only the file name is valid\n *   not loaded: b_ml.ml_mfp == NULL, no memfile allocated\n *\t hidden: b_nwindows == 0, loaded but not displayed in a window\n *\t normal: loaded and displayed in a window\n *\n * Instead of storing file names all over the place, each file name is\n * stored in the buffer list. It can be referenced by a number.\n *\n * The current implementation remembers all file names ever used.\n */\n\n#include \"vim.h\"\n\n\n#ifdef FEAT_EVAL\n// Determines how deeply nested %{} blocks will be evaluated in statusline.\n# define MAX_STL_EVAL_DEPTH 100\n#endif\n\nstatic void\tenter_buffer(buf_T *buf);\nstatic void\tbuflist_getfpos(void);\nstatic char_u\t*buflist_match(regmatch_T *rmp, buf_T *buf, int ignore_case);\nstatic char_u\t*fname_match(regmatch_T *rmp, char_u *name, int ignore_case);\n#ifdef UNIX\nstatic buf_T\t*buflist_findname_stat(char_u *ffname, stat_T *st);\nstatic int\totherfile_buf(buf_T *buf, char_u *ffname, stat_T *stp);\nstatic int\tbuf_same_ino(buf_T *buf, stat_T *stp);\n#else\nstatic int\totherfile_buf(buf_T *buf, char_u *ffname);\n#endif\nstatic int\tvalue_changed(char_u *str, char_u **last);\nstatic int\tappend_arg_number(win_T *wp, char_u *buf, int buflen, int add_file);\nstatic void\tfree_buffer(buf_T *);\nstatic void\tfree_buffer_stuff(buf_T *buf, int free_options);\nstatic void\tclear_wininfo(buf_T *buf);\n\n#ifdef UNIX\n# define dev_T dev_t\n#else\n# define dev_T unsigned\n#endif\n\n#define FOR_ALL_BUFS_FROM_LAST(buf) \\\n    for ((buf) = lastbuf; (buf) != NULL; (buf) = (buf)->b_prev)\n\n#if defined(FEAT_QUICKFIX)\nstatic char *msg_loclist = N_(\"[Location List]\");\nstatic char *msg_qflist = N_(\"[Quickfix List]\");\n#endif\n\n// Number of times free_buffer() was called.\nstatic int\tbuf_free_count = 0;\n\nstatic int\ttop_file_num = 1;\t// highest file number\nstatic garray_T buf_reuse = GA_EMPTY;\t// file numbers to recycle\n\n/*\n * Return the highest possible buffer number.\n */\n    int\nget_highest_fnum(void)\n{\n    return top_file_num - 1;\n}\n\n/*\n * Read data from buffer for retrying.\n */\n    static int\nread_buffer(\n    int\t\tread_stdin,\t    // read file from stdin, otherwise fifo\n    exarg_T\t*eap,\t\t    // for forced 'ff' and 'fenc' or NULL\n    int\t\tflags)\t\t    // extra flags for readfile()\n{\n    int\t\tretval = OK;\n    linenr_T\tline_count;\n\n    // Read from the buffer which the text is already filled in and append at\n    // the end.  This makes it possible to retry when 'fileformat' or\n    // 'fileencoding' was guessed wrong.\n    line_count = curbuf->b_ml.ml_line_count;\n    retval = readfile(\n\t    read_stdin ? NULL : curbuf->b_ffname,\n\t    read_stdin ? NULL : curbuf->b_fname,\n\t    line_count, (linenr_T)0, (linenr_T)MAXLNUM, eap,\n\t    flags | READ_BUFFER);\n    if (retval == OK)\n    {\n\t// Delete the binary lines.\n\twhile (--line_count >= 0)\n\t    ml_delete((linenr_T)1);\n    }\n    else\n    {\n\t// Delete the converted lines.\n\twhile (curbuf->b_ml.ml_line_count > line_count)\n\t    ml_delete(line_count);\n    }\n    // Put the cursor on the first line.\n    curwin->w_cursor.lnum = 1;\n    curwin->w_cursor.col = 0;\n\n    if (read_stdin)\n    {\n\t// Set or reset 'modified' before executing autocommands, so that\n\t// it can be changed there.\n\tif (!readonlymode && !BUFEMPTY())\n\t    changed();\n\telse if (retval == OK)\n\t    unchanged(curbuf, FALSE, TRUE);\n\n\tif (retval == OK)\n\t{\n#ifdef FEAT_EVAL\n\t    apply_autocmds_retval(EVENT_STDINREADPOST, NULL, NULL, FALSE,\n\t\t\t\t\t\t\t      curbuf, &retval);\n#else\n\t    apply_autocmds(EVENT_STDINREADPOST, NULL, NULL, FALSE, curbuf);\n#endif\n\t}\n    }\n    return retval;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Ensure buffer \"buf\" is loaded.  Does not trigger the swap-exists action.\n */\n    void\nbuffer_ensure_loaded(buf_T *buf)\n{\n    if (buf->b_ml.ml_mfp == NULL)\n    {\n\taco_save_T\taco;\n\n\taucmd_prepbuf(&aco, buf);\n\tif (swap_exists_action != SEA_READONLY)\n\t    swap_exists_action = SEA_NONE;\n\topen_buffer(FALSE, NULL, 0);\n\taucmd_restbuf(&aco);\n    }\n}\n#endif\n\n/*\n * Open current buffer, that is: open the memfile and read the file into\n * memory.\n * Return FAIL for failure, OK otherwise.\n */\n    int\nopen_buffer(\n    int\t\tread_stdin,\t    // read file from stdin\n    exarg_T\t*eap,\t\t    // for forced 'ff' and 'fenc' or NULL\n    int\t\tflags)\t\t    // extra flags for readfile()\n{\n    int\t\tretval = OK;\n    bufref_T\told_curbuf;\n#ifdef FEAT_SYN_HL\n    long\told_tw = curbuf->b_p_tw;\n#endif\n    int\t\tread_fifo = FALSE;\n\n    // The 'readonly' flag is only set when BF_NEVERLOADED is being reset.\n    // When re-entering the same buffer, it should not change, because the\n    // user may have reset the flag by hand.\n    if (readonlymode && curbuf->b_ffname != NULL\n\t\t\t\t\t&& (curbuf->b_flags & BF_NEVERLOADED))\n\tcurbuf->b_p_ro = TRUE;\n\n    if (ml_open(curbuf) == FAIL)\n    {\n\t// There MUST be a memfile, otherwise we can't do anything\n\t// If we can't create one for the current buffer, take another buffer\n\tclose_buffer(NULL, curbuf, 0, FALSE, FALSE);\n\tFOR_ALL_BUFFERS(curbuf)\n\t    if (curbuf->b_ml.ml_mfp != NULL)\n\t\tbreak;\n\t// If there is no memfile at all, exit.\n\t// This is OK, since there are no changes to lose.\n\tif (curbuf == NULL)\n\t{\n\t    emsg(_(e_cannot_allocate_any_buffer_exiting));\n\n\t    // Don't try to do any saving, with \"curbuf\" NULL almost nothing\n\t    // will work.\n\t    v_dying = 2;\n\t    getout(2);\n\t}\n\n\temsg(_(e_cannot_allocate_buffer_using_other_one));\n\tenter_buffer(curbuf);\n#ifdef FEAT_SYN_HL\n\tif (old_tw != curbuf->b_p_tw)\n\t    check_colorcolumn(curwin);\n#endif\n\treturn FAIL;\n    }\n\n    // The autocommands in readfile() may change the buffer, but only AFTER\n    // reading the file.\n    set_bufref(&old_curbuf, curbuf);\n    modified_was_set = FALSE;\n\n    // mark cursor position as being invalid\n    curwin->w_valid = 0;\n\n    if (curbuf->b_ffname != NULL\n#ifdef FEAT_NETBEANS_INTG\n\t    && netbeansReadFile\n#endif\n       )\n    {\n\tint old_msg_silent = msg_silent;\n#ifdef UNIX\n\tint save_bin = curbuf->b_p_bin;\n\tint perm;\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\tint oldFire = netbeansFireChanges;\n\n\tnetbeansFireChanges = 0;\n#endif\n#ifdef UNIX\n\tperm = mch_getperm(curbuf->b_ffname);\n\tif (perm >= 0 && (S_ISFIFO(perm)\n\t\t      || S_ISSOCK(perm)\n# ifdef OPEN_CHR_FILES\n\t\t      || (S_ISCHR(perm) && is_dev_fd_file(curbuf->b_ffname))\n# endif\n\t\t    ))\n\t\tread_fifo = TRUE;\n\tif (read_fifo)\n\t    curbuf->b_p_bin = TRUE;\n#endif\n\tif (shortmess(SHM_FILEINFO))\n\t    msg_silent = 1;\n\tretval = readfile(curbuf->b_ffname, curbuf->b_fname,\n\t\t  (linenr_T)0, (linenr_T)0, (linenr_T)MAXLNUM, eap,\n\t\t  flags | READ_NEW | (read_fifo ? READ_FIFO : 0));\n#ifdef UNIX\n\tif (read_fifo)\n\t{\n\t    curbuf->b_p_bin = save_bin;\n\t    if (retval == OK)\n\t\tretval = read_buffer(FALSE, eap, flags);\n\t}\n#endif\n\tmsg_silent = old_msg_silent;\n#ifdef FEAT_NETBEANS_INTG\n\tnetbeansFireChanges = oldFire;\n#endif\n\t// Help buffer is filtered.\n\tif (bt_help(curbuf))\n\t    fix_help_buffer();\n    }\n    else if (read_stdin)\n    {\n\tint\tsave_bin = curbuf->b_p_bin;\n\n\t// First read the text in binary mode into the buffer.\n\t// Then read from that same buffer and append at the end.  This makes\n\t// it possible to retry when 'fileformat' or 'fileencoding' was\n\t// guessed wrong.\n\tcurbuf->b_p_bin = TRUE;\n\tretval = readfile(NULL, NULL, (linenr_T)0,\n\t\t  (linenr_T)0, (linenr_T)MAXLNUM, NULL,\n\t\t  flags | (READ_NEW + READ_STDIN));\n\tcurbuf->b_p_bin = save_bin;\n\tif (retval == OK)\n\t    retval = read_buffer(TRUE, eap, flags);\n    }\n\n    // if first time loading this buffer, init b_chartab[]\n    if (curbuf->b_flags & BF_NEVERLOADED)\n    {\n\t(void)buf_init_chartab(curbuf, FALSE);\n\tparse_cino(curbuf);\n    }\n\n    // Set/reset the Changed flag first, autocmds may change the buffer.\n    // Apply the automatic commands, before processing the modelines.\n    // So the modelines have priority over autocommands.\n    //\n    // When reading stdin, the buffer contents always needs writing, so set\n    // the changed flag.  Unless in readonly mode: \"ls | gview -\".\n    // When interrupted and 'cpoptions' contains 'i' set changed flag.\n    if ((got_int && vim_strchr(p_cpo, CPO_INTMOD) != NULL)\n\t\t|| modified_was_set\t// \":set modified\" used in autocmd\n#ifdef FEAT_EVAL\n\t\t|| (aborting() && vim_strchr(p_cpo, CPO_INTMOD) != NULL)\n#endif\n       )\n\tchanged();\n    else if (retval == OK && !read_stdin && !read_fifo)\n\tunchanged(curbuf, FALSE, TRUE);\n    save_file_ff(curbuf);\t\t// keep this fileformat\n\n    // Set last_changedtick to avoid triggering a TextChanged autocommand right\n    // after it was added.\n    curbuf->b_last_changedtick = CHANGEDTICK(curbuf);\n    curbuf->b_last_changedtick_i = CHANGEDTICK(curbuf);\n    curbuf->b_last_changedtick_pum = CHANGEDTICK(curbuf);\n\n    // require \"!\" to overwrite the file, because it wasn't read completely\n#ifdef FEAT_EVAL\n    if (aborting())\n#else\n    if (got_int)\n#endif\n\tcurbuf->b_flags |= BF_READERR;\n\n#ifdef FEAT_FOLDING\n    // Need to update automatic folding.  Do this before the autocommands,\n    // they may use the fold info.\n    foldUpdateAll(curwin);\n#endif\n\n    // need to set w_topline, unless some autocommand already did that.\n    if (!(curwin->w_valid & VALID_TOPLINE))\n    {\n\tcurwin->w_topline = 1;\n#ifdef FEAT_DIFF\n\tcurwin->w_topfill = 0;\n#endif\n    }\n#ifdef FEAT_EVAL\n    apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf, &retval);\n#else\n    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n#endif\n\n    if (retval == OK)\n    {\n\t// The autocommands may have changed the current buffer.  Apply the\n\t// modelines to the correct buffer, if it still exists and is loaded.\n\tif (bufref_valid(&old_curbuf) && old_curbuf.br_buf->b_ml.ml_mfp != NULL)\n\t{\n\t    aco_save_T\taco;\n\n\t    // Go to the buffer that was opened.\n\t    aucmd_prepbuf(&aco, old_curbuf.br_buf);\n\t    do_modelines(0);\n\t    curbuf->b_flags &= ~(BF_CHECK_RO | BF_NEVERLOADED);\n\n\t    if ((flags & READ_NOWINENTER) == 0)\n#ifdef FEAT_EVAL\n\t\tapply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL, FALSE,\n\t\t\t\t\t\t\t      curbuf, &retval);\n#else\n\t\tapply_autocmds(EVENT_BUFWINENTER, NULL, NULL, FALSE, curbuf);\n#endif\n\n\t    // restore curwin/curbuf and a few other things\n\t    aucmd_restbuf(&aco);\n\t}\n    }\n\n    return retval;\n}\n\n/*\n * Store \"buf\" in \"bufref\" and set the free count.\n */\n    void\nset_bufref(bufref_T *bufref, buf_T *buf)\n{\n    bufref->br_buf = buf;\n    bufref->br_fnum = buf == NULL ? 0 : buf->b_fnum;\n    bufref->br_buf_free_count = buf_free_count;\n}\n\n/*\n * Return TRUE if \"bufref->br_buf\" points to the same buffer as when\n * set_bufref() was called and it is a valid buffer.\n * Only goes through the buffer list if buf_free_count changed.\n * Also checks if b_fnum is still the same, a :bwipe followed by :new might get\n * the same allocated memory, but it's a different buffer.\n */\n    int\nbufref_valid(bufref_T *bufref)\n{\n    return bufref->br_buf_free_count == buf_free_count\n\t? TRUE : buf_valid(bufref->br_buf)\n\t\t\t\t  && bufref->br_fnum == bufref->br_buf->b_fnum;\n}\n\n/*\n * Return TRUE if \"buf\" points to a valid buffer (in the buffer list).\n * This can be slow if there are many buffers, prefer using bufref_valid().\n */\n    int\nbuf_valid(buf_T *buf)\n{\n    buf_T\t*bp;\n\n    // Assume that we more often have a recent buffer, start with the last\n    // one.\n    FOR_ALL_BUFS_FROM_LAST(bp)\n\tif (bp == buf)\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * A hash table used to quickly lookup a buffer by its number.\n */\nstatic hashtab_T buf_hashtab;\n\n    static void\nbuf_hashtab_add(buf_T *buf)\n{\n    sprintf((char *)buf->b_key, \"%x\", buf->b_fnum);\n    if (hash_add(&buf_hashtab, buf->b_key) == FAIL)\n\temsg(_(e_buffer_cannot_be_registered));\n}\n\n    static void\nbuf_hashtab_remove(buf_T *buf)\n{\n    hashitem_T *hi = hash_find(&buf_hashtab, buf->b_key);\n\n    if (!HASHITEM_EMPTY(hi))\n\thash_remove(&buf_hashtab, hi);\n}\n\n/*\n * Return TRUE when buffer \"buf\" can be unloaded.\n * Give an error message and return FALSE when the buffer is locked or the\n * screen is being redrawn and the buffer is in a window.\n */\n    static int\ncan_unload_buffer(buf_T *buf)\n{\n    int\t    can_unload = !buf->b_locked;\n\n    if (can_unload && updating_screen)\n    {\n\twin_T\t*wp;\n\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_buffer == buf)\n\t    {\n\t\tcan_unload = FALSE;\n\t\tbreak;\n\t    }\n    }\n    if (!can_unload)\n\tsemsg(_(e_attempt_to_delete_buffer_that_is_in_use_str), buf->b_fname);\n    return can_unload;\n}\n\n/*\n * Close the link to a buffer.\n * \"action\" is used when there is no longer a window for the buffer.\n * It can be:\n * 0\t\t\tbuffer becomes hidden\n * DOBUF_UNLOAD\t\tbuffer is unloaded\n * DOBUF_DELETE\t\tbuffer is unloaded and removed from buffer list\n * DOBUF_WIPE\t\tbuffer is unloaded and really deleted\n * DOBUF_WIPE_REUSE\tidem, and add to buf_reuse list\n * When doing all but the first one on the current buffer, the caller should\n * get a new buffer very soon!\n *\n * The 'bufhidden' option can force freeing and deleting.\n *\n * When \"abort_if_last\" is TRUE then do not close the buffer if autocommands\n * cause there to be only one window with this buffer.  e.g. when \":quit\" is\n * supposed to close the window but autocommands close all other windows.\n *\n * When \"ignore_abort\" is TRUE don't abort even when aborting() returns TRUE.\n *\n * Return TRUE when we got to the end and b_nwindows was decremented.\n */\n    int\nclose_buffer(\n    win_T\t*win,\t\t// if not NULL, set b_last_cursor\n    buf_T\t*buf,\n    int\t\taction,\n    int\t\tabort_if_last,\n    int\t\tignore_abort)\n{\n    int\t\tis_curbuf;\n    int\t\tnwindows;\n    bufref_T\tbufref;\n    int\t\tis_curwin = (curwin != NULL && curwin->w_buffer == buf);\n    win_T\t*the_curwin = curwin;\n    tabpage_T\t*the_curtab = curtab;\n    int\t\tunload_buf = (action != 0);\n    int\t\twipe_buf = (action == DOBUF_WIPE || action == DOBUF_WIPE_REUSE);\n    int\t\tdel_buf = (action == DOBUF_DEL || wipe_buf);\n\n    CHECK_CURBUF;\n\n    // Force unloading or deleting when 'bufhidden' says so.\n    // The caller must take care of NOT deleting/freeing when 'bufhidden' is\n    // \"hide\" (otherwise we could never free or delete a buffer).\n    if (buf->b_p_bh[0] == 'd')\t\t// 'bufhidden' == \"delete\"\n    {\n\tdel_buf = TRUE;\n\tunload_buf = TRUE;\n    }\n    else if (buf->b_p_bh[0] == 'w')\t// 'bufhidden' == \"wipe\"\n    {\n\tdel_buf = TRUE;\n\tunload_buf = TRUE;\n\twipe_buf = TRUE;\n    }\n    else if (buf->b_p_bh[0] == 'u')\t// 'bufhidden' == \"unload\"\n\tunload_buf = TRUE;\n\n#ifdef FEAT_TERMINAL\n    if (bt_terminal(buf) && (buf->b_nwindows == 1 || del_buf))\n    {\n\tCHECK_CURBUF;\n\tif (term_job_running(buf->b_term))\n\t{\n\t    if (wipe_buf || unload_buf)\n\t    {\n\t\tif (!can_unload_buffer(buf))\n\t\t    return FALSE;\n\n\t\t// Wiping out or unloading a terminal buffer kills the job.\n\t\tfree_terminal(buf);\n\t    }\n\t    else\n\t    {\n\t\t// The job keeps running, hide the buffer.\n\t\tdel_buf = FALSE;\n\t\tunload_buf = FALSE;\n\t    }\n\t}\n\telse if (buf->b_p_bh[0] == 'h' && !del_buf)\n\t{\n\t    // Hide a terminal buffer.\n\t    unload_buf = FALSE;\n\t}\n\telse\n\t{\n\t    // A terminal buffer is wiped out if the job has finished.\n\t    del_buf = TRUE;\n\t    unload_buf = TRUE;\n\t    wipe_buf = TRUE;\n\t}\n\tCHECK_CURBUF;\n    }\n#endif\n\n    // Disallow deleting the buffer when it is locked (already being closed or\n    // halfway a command that relies on it). Unloading is allowed.\n    if ((del_buf || wipe_buf) && !can_unload_buffer(buf))\n\treturn FALSE;\n\n    // check no autocommands closed the window\n    if (win != NULL && win_valid_any_tab(win))\n    {\n\t// Set b_last_cursor when closing the last window for the buffer.\n\t// Remember the last cursor position and window options of the buffer.\n\t// This used to be only for the current window, but then options like\n\t// 'foldmethod' may be lost with a \":only\" command.\n\tif (buf->b_nwindows == 1)\n\t    set_last_cursor(win);\n\tbuflist_setfpos(buf, win,\n\t\t    win->w_cursor.lnum == 1 ? 0 : win->w_cursor.lnum,\n\t\t    win->w_cursor.col, TRUE);\n    }\n\n    set_bufref(&bufref, buf);\n\n    // When the buffer is no longer in a window, trigger BufWinLeave\n    if (buf->b_nwindows == 1)\n    {\n\t++buf->b_locked;\n\t++buf->b_locked_split;\n\tif (apply_autocmds(EVENT_BUFWINLEAVE, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t  FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t{\n\t    // Autocommands deleted the buffer.\naucmd_abort:\n\t    emsg(_(e_autocommands_caused_command_to_abort));\n\t    return FALSE;\n\t}\n\t--buf->b_locked;\n\t--buf->b_locked_split;\n\tif (abort_if_last && one_window())\n\t    // Autocommands made this the only window.\n\t    goto aucmd_abort;\n\n\t// When the buffer becomes hidden, but is not unloaded, trigger\n\t// BufHidden\n\tif (!unload_buf)\n\t{\n\t    ++buf->b_locked;\n\t    ++buf->b_locked_split;\n\t    if (apply_autocmds(EVENT_BUFHIDDEN, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t  FALSE, buf)\n\t\t    && !bufref_valid(&bufref))\n\t\t// Autocommands deleted the buffer.\n\t\tgoto aucmd_abort;\n\t    --buf->b_locked;\n\t    --buf->b_locked_split;\n\t    if (abort_if_last && one_window())\n\t\t// Autocommands made this the only window.\n\t\tgoto aucmd_abort;\n\t}\n#ifdef FEAT_EVAL\n\t// autocmds may abort script processing\n\tif (!ignore_abort && aborting())\n\t    return FALSE;\n#endif\n    }\n\n    // If the buffer was in curwin and the window has changed, go back to that\n    // window, if it still exists.  This avoids that \":edit x\" triggering a\n    // \"tabnext\" BufUnload autocmd leaves a window behind without a buffer.\n    if (is_curwin && curwin != the_curwin &&  win_valid_any_tab(the_curwin))\n    {\n\tblock_autocmds();\n\tgoto_tabpage_win(the_curtab, the_curwin);\n\tunblock_autocmds();\n    }\n\n    nwindows = buf->b_nwindows;\n\n    // decrease the link count from windows (unless not in any window)\n    if (buf->b_nwindows > 0)\n\t--buf->b_nwindows;\n\n#ifdef FEAT_DIFF\n    if (diffopt_hiddenoff() && !unload_buf && buf->b_nwindows == 0)\n\tdiff_buf_delete(buf);\t// Clear 'diff' for hidden buffer.\n#endif\n\n    // Return when a window is displaying the buffer or when it's not\n    // unloaded.\n    if (buf->b_nwindows > 0 || !unload_buf)\n\treturn FALSE;\n\n    // Always remove the buffer when there is no file name.\n    if (buf->b_ffname == NULL)\n\tdel_buf = TRUE;\n\n    // When closing the current buffer stop Visual mode before freeing\n    // anything.\n    if (buf == curbuf && VIsual_active\n#if defined(EXITFREE)\n\t    && !entered_free_all_mem\n#endif\n\t    )\n\tend_visual_mode();\n\n    // Free all things allocated for this buffer.\n    // Also calls the \"BufDelete\" autocommands when del_buf is TRUE.\n    //\n    // Remember if we are closing the current buffer.  Restore the number of\n    // windows, so that autocommands in buf_freeall() don't get confused.\n    is_curbuf = (buf == curbuf);\n    buf->b_nwindows = nwindows;\n\n    buf_freeall(buf, (del_buf ? BFA_DEL : 0)\n\t\t   + (wipe_buf ? BFA_WIPE : 0)\n\t\t   + (ignore_abort ? BFA_IGNORE_ABORT : 0));\n\n    // Autocommands may have deleted the buffer.\n    if (!bufref_valid(&bufref))\n\treturn FALSE;\n#ifdef FEAT_EVAL\n    // autocmds may abort script processing\n    if (!ignore_abort && aborting())\n\treturn FALSE;\n#endif\n\n    // It's possible that autocommands change curbuf to the one being deleted.\n    // This might cause the previous curbuf to be deleted unexpectedly.  But\n    // in some cases it's OK to delete the curbuf, because a new one is\n    // obtained anyway.  Therefore only return if curbuf changed to the\n    // deleted buffer.\n    if (buf == curbuf && !is_curbuf)\n\treturn FALSE;\n\n    if (win_valid_any_tab(win) && win->w_buffer == buf)\n\twin->w_buffer = NULL;  // make sure we don't use the buffer now\n\n    // Autocommands may have opened or closed windows for this buffer.\n    // Decrement the count for the close we do here.\n    if (buf->b_nwindows > 0)\n\t--buf->b_nwindows;\n\n    /*\n     * Remove the buffer from the list.\n     */\n    if (wipe_buf)\n    {\n\t// Do not wipe out the buffer if it is used in a window.\n\tif (buf->b_nwindows > 0)\n\t    return FALSE;\n\n\tif (action == DOBUF_WIPE_REUSE)\n\t{\n\t    // we can re-use this buffer number, store it\n\t    if (buf_reuse.ga_itemsize == 0)\n\t\tga_init2(&buf_reuse, sizeof(int), 50);\n\t    if (ga_grow(&buf_reuse, 1) == OK)\n\t\t((int *)buf_reuse.ga_data)[buf_reuse.ga_len++] = buf->b_fnum;\n\t}\n\tif (buf->b_sfname != buf->b_ffname)\n\t    VIM_CLEAR(buf->b_sfname);\n\telse\n\t    buf->b_sfname = NULL;\n\tVIM_CLEAR(buf->b_ffname);\n\tif (buf->b_prev == NULL)\n\t    firstbuf = buf->b_next;\n\telse\n\t    buf->b_prev->b_next = buf->b_next;\n\tif (buf->b_next == NULL)\n\t    lastbuf = buf->b_prev;\n\telse\n\t    buf->b_next->b_prev = buf->b_prev;\n\tfree_buffer(buf);\n    }\n    else\n    {\n\tif (del_buf)\n\t{\n\t    // Free all internal variables and reset option values, to make\n\t    // \":bdel\" compatible with Vim 5.7.\n\t    free_buffer_stuff(buf, TRUE);\n\n\t    // Make it look like a new buffer.\n\t    buf->b_flags = BF_CHECK_RO | BF_NEVERLOADED;\n\n\t    // Init the options when loaded again.\n\t    buf->b_p_initialized = FALSE;\n\t}\n\tbuf_clear_file(buf);\n\tif (del_buf)\n\t    buf->b_p_bl = FALSE;\n    }\n    // NOTE: at this point \"curbuf\" may be invalid!\n    return TRUE;\n}\n\n/*\n * Make buffer not contain a file.\n */\n    void\nbuf_clear_file(buf_T *buf)\n{\n    buf->b_ml.ml_line_count = 1;\n    unchanged(buf, TRUE, TRUE);\n    buf->b_shortname = FALSE;\n    buf->b_p_eol = TRUE;\n    buf->b_start_eol = TRUE;\n    buf->b_p_bomb = FALSE;\n    buf->b_start_bomb = FALSE;\n    buf->b_ml.ml_mfp = NULL;\n    buf->b_ml.ml_flags = ML_EMPTY;\t\t// empty buffer\n#ifdef FEAT_NETBEANS_INTG\n    netbeans_deleted_all_lines(buf);\n#endif\n}\n\n/*\n * buf_freeall() - free all things allocated for a buffer that are related to\n * the file.  Careful: get here with \"curwin\" NULL when exiting.\n * flags:\n * BFA_DEL\t     buffer is going to be deleted\n * BFA_WIPE\t     buffer is going to be wiped out\n * BFA_KEEP_UNDO     do not free undo information\n * BFA_IGNORE_ABORT  don't abort even when aborting() returns TRUE\n */\n    void\nbuf_freeall(buf_T *buf, int flags)\n{\n    int\t\tis_curbuf = (buf == curbuf);\n    bufref_T\tbufref;\n    int\t\tis_curwin = (curwin != NULL && curwin->w_buffer == buf);\n    win_T\t*the_curwin = curwin;\n    tabpage_T\t*the_curtab = curtab;\n\n    // Make sure the buffer isn't closed by autocommands.\n    ++buf->b_locked;\n    ++buf->b_locked_split;\n    set_bufref(&bufref, buf);\n    if (buf->b_ml.ml_mfp != NULL)\n    {\n\tif (apply_autocmds(EVENT_BUFUNLOAD, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t  FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t    // autocommands deleted the buffer\n\t    return;\n    }\n    if ((flags & BFA_DEL) && buf->b_p_bl)\n    {\n\tif (apply_autocmds(EVENT_BUFDELETE, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t   FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t    // autocommands deleted the buffer\n\t    return;\n    }\n    if (flags & BFA_WIPE)\n    {\n\tif (apply_autocmds(EVENT_BUFWIPEOUT, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t  FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t    // autocommands deleted the buffer\n\t    return;\n    }\n    --buf->b_locked;\n    --buf->b_locked_split;\n\n    // If the buffer was in curwin and the window has changed, go back to that\n    // window, if it still exists.  This avoids that \":edit x\" triggering a\n    // \"tabnext\" BufUnload autocmd leaves a window behind without a buffer.\n    if (is_curwin && curwin != the_curwin &&  win_valid_any_tab(the_curwin))\n    {\n\tblock_autocmds();\n\tgoto_tabpage_win(the_curtab, the_curwin);\n\tunblock_autocmds();\n    }\n\n#ifdef FEAT_EVAL\n    // autocmds may abort script processing\n    if ((flags & BFA_IGNORE_ABORT) == 0 && aborting())\n\treturn;\n#endif\n\n    // It's possible that autocommands change curbuf to the one being deleted.\n    // This might cause curbuf to be deleted unexpectedly.  But in some cases\n    // it's OK to delete the curbuf, because a new one is obtained anyway.\n    // Therefore only return if curbuf changed to the deleted buffer.\n    if (buf == curbuf && !is_curbuf)\n\treturn;\n#ifdef FEAT_DIFF\n    diff_buf_delete(buf);\t    // Can't use 'diff' for unloaded buffer.\n#endif\n#ifdef FEAT_SYN_HL\n    // Remove any ownsyntax, unless exiting.\n    if (curwin != NULL && curwin->w_buffer == buf)\n\treset_synblock(curwin);\n#endif\n\n#ifdef FEAT_FOLDING\n    // No folds in an empty buffer.\n    {\n\twin_T\t\t*win;\n\ttabpage_T\t*tp;\n\n\tFOR_ALL_TAB_WINDOWS(tp, win)\n\t    if (win->w_buffer == buf)\n\t\tclearFolding(win);\n    }\n#endif\n\n#ifdef FEAT_TCL\n    tcl_buffer_free(buf);\n#endif\n    ml_close(buf, TRUE);\t    // close and delete the memline/memfile\n    buf->b_ml.ml_line_count = 0;    // no lines in buffer\n    if ((flags & BFA_KEEP_UNDO) == 0)\n    {\n\tu_blockfree(buf);\t    // free the memory allocated for undo\n\tu_clearall(buf);\t    // reset all undo information\n    }\n#ifdef FEAT_SYN_HL\n    syntax_clear(&buf->b_s);\t    // reset syntax info\n#endif\n#ifdef FEAT_PROP_POPUP\n    clear_buf_prop_types(buf);\n#endif\n    buf->b_flags &= ~BF_READERR;    // a read error is no longer relevant\n}\n\n/*\n * Free a buffer structure and the things it contains related to the buffer\n * itself (not the file, that must have been done already).\n */\n    static void\nfree_buffer(buf_T *buf)\n{\n    ++buf_free_count;\n    free_buffer_stuff(buf, TRUE);\n#ifdef FEAT_EVAL\n    // b:changedtick uses an item in buf_T, remove it now\n    dictitem_remove(buf->b_vars, (dictitem_T *)&buf->b_ct_di);\n    unref_var_dict(buf->b_vars);\n    remove_listeners(buf);\n#endif\n#ifdef FEAT_LUA\n    lua_buffer_free(buf);\n#endif\n#ifdef FEAT_MZSCHEME\n    mzscheme_buffer_free(buf);\n#endif\n#ifdef FEAT_PERL\n    perl_buf_free(buf);\n#endif\n#ifdef FEAT_PYTHON\n    python_buffer_free(buf);\n#endif\n#ifdef FEAT_PYTHON3\n    python3_buffer_free(buf);\n#endif\n#ifdef FEAT_RUBY\n    ruby_buffer_free(buf);\n#endif\n#ifdef FEAT_JOB_CHANNEL\n    channel_buffer_free(buf);\n#endif\n#ifdef FEAT_TERMINAL\n    free_terminal(buf);\n#endif\n#ifdef FEAT_JOB_CHANNEL\n    vim_free(buf->b_prompt_text);\n    free_callback(&buf->b_prompt_callback);\n    free_callback(&buf->b_prompt_interrupt);\n#endif\n\n    buf_hashtab_remove(buf);\n\n    aubuflocal_remove(buf);\n\n    if (autocmd_busy)\n    {\n\t// Do not free the buffer structure while autocommands are executing,\n\t// it's still needed. Free it when autocmd_busy is reset.\n\tbuf->b_next = au_pending_free_buf;\n\tau_pending_free_buf = buf;\n    }\n    else\n    {\n\tvim_free(buf);\n\tif (curbuf == buf)\n\t    curbuf = NULL;  // make clear it's not to be used\n    }\n}\n\n/*\n * Initializes b:changedtick.\n */\n    static void\ninit_changedtick(buf_T *buf)\n{\n    dictitem_T *di = (dictitem_T *)&buf->b_ct_di;\n\n    di->di_flags = DI_FLAGS_FIX | DI_FLAGS_RO;\n    di->di_tv.v_type = VAR_NUMBER;\n    di->di_tv.v_lock = VAR_FIXED;\n    di->di_tv.vval.v_number = 0;\n\n#ifdef FEAT_EVAL\n    STRCPY(buf->b_ct_di.di_key, \"changedtick\");\n    (void)dict_add(buf->b_vars, di);\n#endif\n}\n\n/*\n * Free stuff in the buffer for \":bdel\" and when wiping out the buffer.\n */\n    static void\nfree_buffer_stuff(\n    buf_T\t*buf,\n    int\t\tfree_options)\t\t// free options as well\n{\n    if (free_options)\n    {\n\tclear_wininfo(buf);\t\t// including window-local options\n\tfree_buf_options(buf, TRUE);\n#ifdef FEAT_SPELL\n\tga_clear(&buf->b_s.b_langp);\n#endif\n    }\n#ifdef FEAT_EVAL\n    {\n\tvarnumber_T tick = CHANGEDTICK(buf);\n\n\tvars_clear(&buf->b_vars->dv_hashtab); // free all buffer variables\n\thash_init(&buf->b_vars->dv_hashtab);\n\tinit_changedtick(buf);\n\tCHANGEDTICK(buf) = tick;\n\tremove_listeners(buf);\n    }\n#endif\n    uc_clear(&buf->b_ucmds);\t\t// clear local user commands\n#ifdef FEAT_SIGNS\n    buf_delete_signs(buf, (char_u *)\"*\");\t// delete any signs\n#endif\n#ifdef FEAT_NETBEANS_INTG\n    netbeans_file_killed(buf);\n#endif\n    map_clear_int(buf, MAP_ALL_MODES, TRUE, FALSE);  // clear local mappings\n    map_clear_int(buf, MAP_ALL_MODES, TRUE, TRUE);   // clear local abbrevs\n    VIM_CLEAR(buf->b_start_fenc);\n}\n\n/*\n * Free one wininfo_T.\n */\n    void\nfree_wininfo(wininfo_T *wip)\n{\n    if (wip->wi_optset)\n    {\n\tclear_winopt(&wip->wi_opt);\n#ifdef FEAT_FOLDING\n\tdeleteFoldRecurse(&wip->wi_folds);\n#endif\n    }\n    vim_free(wip);\n}\n\n/*\n * Free the b_wininfo list for buffer \"buf\".\n */\n    static void\nclear_wininfo(buf_T *buf)\n{\n    wininfo_T\t*wip;\n\n    while (buf->b_wininfo != NULL)\n    {\n\twip = buf->b_wininfo;\n\tbuf->b_wininfo = wip->wi_next;\n\tfree_wininfo(wip);\n    }\n}\n\n/*\n * Go to another buffer.  Handles the result of the ATTENTION dialog.\n */\n    void\ngoto_buffer(\n    exarg_T\t*eap,\n    int\t\tstart,\n    int\t\tdir,\n    int\t\tcount)\n{\n    bufref_T\told_curbuf;\n    int\t\tsave_sea = swap_exists_action;\n\n    set_bufref(&old_curbuf, curbuf);\n\n    if (swap_exists_action == SEA_NONE)\n\tswap_exists_action = SEA_DIALOG;\n    (void)do_buffer(*eap->cmd == 's' ? DOBUF_SPLIT : DOBUF_GOTO,\n\t\t\t\t\t     start, dir, count, eap->forceit);\n    if (swap_exists_action == SEA_QUIT && *eap->cmd == 's')\n    {\n#if defined(FEAT_EVAL)\n\tcleanup_T   cs;\n\n\t// Reset the error/interrupt/exception state here so that\n\t// aborting() returns FALSE when closing a window.\n\tenter_cleanup(&cs);\n#endif\n\n\t// Quitting means closing the split window, nothing else.\n\twin_close(curwin, TRUE);\n\tswap_exists_action = save_sea;\n\tswap_exists_did_quit = TRUE;\n\n#if defined(FEAT_EVAL)\n\t// Restore the error/interrupt/exception state if not discarded by a\n\t// new aborting error, interrupt, or uncaught exception.\n\tleave_cleanup(&cs);\n#endif\n    }\n    else\n\thandle_swap_exists(&old_curbuf);\n}\n\n/*\n * Handle the situation of swap_exists_action being set.\n * It is allowed for \"old_curbuf\" to be NULL or invalid.\n */\n    void\nhandle_swap_exists(bufref_T *old_curbuf)\n{\n#if defined(FEAT_EVAL)\n    cleanup_T\tcs;\n#endif\n#ifdef FEAT_SYN_HL\n    long\told_tw = curbuf->b_p_tw;\n#endif\n    buf_T\t*buf;\n\n    if (swap_exists_action == SEA_QUIT)\n    {\n#if defined(FEAT_EVAL)\n\t// Reset the error/interrupt/exception state here so that\n\t// aborting() returns FALSE when closing a buffer.\n\tenter_cleanup(&cs);\n#endif\n\n\t// User selected Quit at ATTENTION prompt.  Go back to previous\n\t// buffer.  If that buffer is gone or the same as the current one,\n\t// open a new, empty buffer.\n\tswap_exists_action = SEA_NONE;\t// don't want it again\n\tswap_exists_did_quit = TRUE;\n\tclose_buffer(curwin, curbuf, DOBUF_UNLOAD, FALSE, FALSE);\n\tif (old_curbuf == NULL || !bufref_valid(old_curbuf)\n\t\t\t\t\t      || old_curbuf->br_buf == curbuf)\n\t{\n\t    // Block autocommands here because curwin->w_buffer is NULL.\n\t    block_autocmds();\n\t    buf = buflist_new(NULL, NULL, 1L, BLN_CURBUF | BLN_LISTED);\n\t    unblock_autocmds();\n\t}\n\telse\n\t    buf = old_curbuf->br_buf;\n\tif (buf != NULL)\n\t{\n\t    int old_msg_silent = msg_silent;\n\n\t    if (shortmess(SHM_FILEINFO))\n\t\tmsg_silent = 1;  // prevent fileinfo message\n\t    enter_buffer(buf);\n\t    // restore msg_silent, so that the command line will be shown\n\t    msg_silent = old_msg_silent;\n\n#ifdef FEAT_SYN_HL\n\t    if (old_tw != curbuf->b_p_tw)\n\t\tcheck_colorcolumn(curwin);\n#endif\n\t}\n\t// If \"old_curbuf\" is NULL we are in big trouble here...\n\n#if defined(FEAT_EVAL)\n\t// Restore the error/interrupt/exception state if not discarded by a\n\t// new aborting error, interrupt, or uncaught exception.\n\tleave_cleanup(&cs);\n#endif\n    }\n    else if (swap_exists_action == SEA_RECOVER)\n    {\n#if defined(FEAT_EVAL)\n\t// Reset the error/interrupt/exception state here so that\n\t// aborting() returns FALSE when closing a buffer.\n\tenter_cleanup(&cs);\n#endif\n\n\t// User selected Recover at ATTENTION prompt.\n\tmsg_scroll = TRUE;\n\tml_recover(FALSE);\n\tmsg_puts(\"\\n\");\t// don't overwrite the last message\n\tcmdline_row = msg_row;\n\tdo_modelines(0);\n\n#if defined(FEAT_EVAL)\n\t// Restore the error/interrupt/exception state if not discarded by a\n\t// new aborting error, interrupt, or uncaught exception.\n\tleave_cleanup(&cs);\n#endif\n    }\n    swap_exists_action = SEA_NONE;\n}\n\n/*\n * Make the current buffer empty.\n * Used when it is wiped out and it's the last buffer.\n */\n    static int\nempty_curbuf(\n    int close_others,\n    int forceit,\n    int action)\n{\n    int\t    retval;\n    buf_T   *buf = curbuf;\n    bufref_T bufref;\n\n    if (action == DOBUF_UNLOAD)\n    {\n\temsg(_(e_cannot_unload_last_buffer));\n\treturn FAIL;\n    }\n\n    set_bufref(&bufref, buf);\n    if (close_others)\n\t// Close any other windows on this buffer, then make it empty.\n\tclose_windows(buf, TRUE);\n\n    setpcmark();\n    retval = do_ecmd(0, NULL, NULL, NULL, ECMD_ONE,\n\t\t\t\t\t  forceit ? ECMD_FORCEIT : 0, curwin);\n\n    // do_ecmd() may create a new buffer, then we have to delete\n    // the old one.  But do_ecmd() may have done that already, check\n    // if the buffer still exists.\n    if (buf != curbuf && bufref_valid(&bufref) && buf->b_nwindows == 0)\n\tclose_buffer(NULL, buf, action, FALSE, FALSE);\n    if (!close_others)\n\tneed_fileinfo = FALSE;\n    return retval;\n}\n\n/*\n * Implementation of the commands for the buffer list.\n *\n * action == DOBUF_GOTO\t    go to specified buffer\n * action == DOBUF_SPLIT    split window and go to specified buffer\n * action == DOBUF_UNLOAD   unload specified buffer(s)\n * action == DOBUF_DEL\t    delete specified buffer(s) from buffer list\n * action == DOBUF_WIPE\t    delete specified buffer(s) really\n * action == DOBUF_WIPE_REUSE idem, and add number to \"buf_reuse\"\n *\n * start == DOBUF_CURRENT   go to \"count\" buffer from current buffer\n * start == DOBUF_FIRST\t    go to \"count\" buffer from first buffer\n * start == DOBUF_LAST\t    go to \"count\" buffer from last buffer\n * start == DOBUF_MOD\t    go to \"count\" modified buffer from current buffer\n *\n * Return FAIL or OK.\n */\n    static int\ndo_buffer_ext(\n    int\t\taction,\n    int\t\tstart,\n    int\t\tdir,\t\t// FORWARD or BACKWARD\n    int\t\tcount,\t\t// buffer number or number of buffers\n    int\t\tflags)\t\t// DOBUF_FORCEIT etc.\n{\n    buf_T\t*buf;\n    buf_T\t*bp;\n    int\t\tunload = (action == DOBUF_UNLOAD || action == DOBUF_DEL\n\t\t\t|| action == DOBUF_WIPE || action == DOBUF_WIPE_REUSE);\n\n    switch (start)\n    {\n\tcase DOBUF_FIRST:   buf = firstbuf; break;\n\tcase DOBUF_LAST:    buf = lastbuf;  break;\n\tdefault:\t    buf = curbuf;   break;\n    }\n    if (start == DOBUF_MOD)\t    // find next modified buffer\n    {\n\twhile (count-- > 0)\n\t{\n\t    do\n\t    {\n\t\tbuf = buf->b_next;\n\t\tif (buf == NULL)\n\t\t    buf = firstbuf;\n\t    }\n\t    while (buf != curbuf && !bufIsChanged(buf));\n\t}\n\tif (!bufIsChanged(buf))\n\t{\n\t    emsg(_(e_no_modified_buffer_found));\n\t    return FAIL;\n\t}\n    }\n    else if (start == DOBUF_FIRST && count) // find specified buffer number\n    {\n\twhile (buf != NULL && buf->b_fnum != count)\n\t    buf = buf->b_next;\n    }\n    else\n    {\n\tbp = NULL;\n\twhile (count > 0 || (!unload && !buf->b_p_bl && bp != buf))\n\t{\n\t    // remember the buffer where we start, we come back there when all\n\t    // buffers are unlisted.\n\t    if (bp == NULL)\n\t\tbp = buf;\n\t    if (dir == FORWARD)\n\t    {\n\t\tbuf = buf->b_next;\n\t\tif (buf == NULL)\n\t\t    buf = firstbuf;\n\t    }\n\t    else\n\t    {\n\t\tbuf = buf->b_prev;\n\t\tif (buf == NULL)\n\t\t    buf = lastbuf;\n\t    }\n\t    // don't count unlisted buffers\n\t    if (unload || buf->b_p_bl)\n\t    {\n\t\t --count;\n\t\t bp = NULL;\t// use this buffer as new starting point\n\t    }\n\t    if (bp == buf)\n\t    {\n\t\t// back where we started, didn't find anything.\n\t\temsg(_(e_there_is_no_listed_buffer));\n\t\treturn FAIL;\n\t    }\n\t}\n    }\n\n    if (buf == NULL)\t    // could not find it\n    {\n\tif (start == DOBUF_FIRST)\n\t{\n\t    // don't warn when deleting\n\t    if (!unload)\n\t\tsemsg(_(e_buffer_nr_does_not_exist), count);\n\t}\n\telse if (dir == FORWARD)\n\t    emsg(_(e_cannot_go_beyond_last_buffer));\n\telse\n\t    emsg(_(e_cannot_go_before_first_buffer));\n\treturn FAIL;\n    }\n#ifdef FEAT_PROP_POPUP\n    if ((flags & DOBUF_NOPOPUP) && bt_popup(buf)\n# ifdef FEAT_TERMINAL\n\t\t\t\t&& !bt_terminal(buf)\n#endif\n       )\n\treturn OK;\n#endif\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * delete buffer \"buf\" from memory and/or the list\n     */\n    if (unload)\n    {\n\tint\tforward;\n\tbufref_T bufref;\n\n\tif (!can_unload_buffer(buf))\n\t    return FAIL;\n\n\tset_bufref(&bufref, buf);\n\n\t// When unloading or deleting a buffer that's already unloaded and\n\t// unlisted: fail silently.\n\tif (action != DOBUF_WIPE && action != DOBUF_WIPE_REUSE\n\t\t\t\t   && buf->b_ml.ml_mfp == NULL && !buf->b_p_bl)\n\t    return FAIL;\n\n\tif ((flags & DOBUF_FORCEIT) == 0 && bufIsChanged(buf))\n\t{\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t    if ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t    {\n\t\tdialog_changed(buf, FALSE);\n\t\tif (!bufref_valid(&bufref))\n\t\t    // Autocommand deleted buffer, oops!  It's not changed\n\t\t    // now.\n\t\t    return FAIL;\n\t\t// If it's still changed fail silently, the dialog already\n\t\t// mentioned why it fails.\n\t\tif (bufIsChanged(buf))\n\t\t    return FAIL;\n\t    }\n\t    else\n#endif\n\t    {\n\t\tsemsg(_(e_no_write_since_last_change_for_buffer_nr_add_bang_to_override),\n\t\t\t\t\t\t\t\t buf->b_fnum);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t// When closing the current buffer stop Visual mode.\n\tif (buf == curbuf && VIsual_active)\n\t    end_visual_mode();\n\n\t// If deleting the last (listed) buffer, make it empty.\n\t// The last (listed) buffer cannot be unloaded.\n\tFOR_ALL_BUFFERS(bp)\n\t    if (bp->b_p_bl && bp != buf)\n\t\tbreak;\n\tif (bp == NULL && buf == curbuf)\n\t    return empty_curbuf(TRUE, (flags & DOBUF_FORCEIT), action);\n\n\t// If the deleted buffer is the current one, close the current window\n\t// (unless it's the only window).  Repeat this so long as we end up in\n\t// a window with this buffer.\n\twhile (buf == curbuf\n\t\t   && !(curwin->w_closing || curwin->w_buffer->b_locked > 0)\n\t\t   && (!ONE_WINDOW || first_tabpage->tp_next != NULL))\n\t{\n\t    if (win_close(curwin, FALSE) == FAIL)\n\t\tbreak;\n\t}\n\n\t// If the buffer to be deleted is not the current one, delete it here.\n\tif (buf != curbuf)\n\t{\n\t    close_windows(buf, FALSE);\n\t    if (buf != curbuf && bufref_valid(&bufref) && buf->b_nwindows <= 0)\n\t\t    close_buffer(NULL, buf, action, FALSE, FALSE);\n\t    return OK;\n\t}\n\n\t/*\n\t * Deleting the current buffer: Need to find another buffer to go to.\n\t * There should be another, otherwise it would have been handled\n\t * above.  However, autocommands may have deleted all buffers.\n\t * First use au_new_curbuf.br_buf, if it is valid.\n\t * Then prefer the buffer we most recently visited.\n\t * Else try to find one that is loaded, after the current buffer,\n\t * then before the current buffer.\n\t * Finally use any buffer.\n\t */\n\tbuf = NULL;\t// selected buffer\n\tbp = NULL;\t// used when no loaded buffer found\n\tif (au_new_curbuf.br_buf != NULL && bufref_valid(&au_new_curbuf))\n\t    buf = au_new_curbuf.br_buf;\n\telse if (curwin->w_jumplistlen > 0)\n\t{\n\t    int     jumpidx;\n\n\t    jumpidx = curwin->w_jumplistidx - 1;\n\t    if (jumpidx < 0)\n\t\tjumpidx = curwin->w_jumplistlen - 1;\n\n\t    forward = jumpidx;\n\t    while (jumpidx != curwin->w_jumplistidx)\n\t    {\n\t\tbuf = buflist_findnr(curwin->w_jumplist[jumpidx].fmark.fnum);\n\t\tif (buf != NULL)\n\t\t{\n\t\t    // Skip current and unlisted bufs.  Also skip a quickfix\n\t\t    // buffer, it might be deleted soon.\n\t\t    if (buf == curbuf || !buf->b_p_bl\n#if defined(FEAT_QUICKFIX)\n\t\t\t    || bt_quickfix(buf)\n#endif\n\t\t\t    )\n\t\t\tbuf = NULL;\n\t\t    else if (buf->b_ml.ml_mfp == NULL)\n\t\t    {\n\t\t\t// skip unloaded buf, but may keep it for later\n\t\t\tif (bp == NULL)\n\t\t\t    bp = buf;\n\t\t\tbuf = NULL;\n\t\t    }\n\t\t}\n\t\tif (buf != NULL)   // found a valid buffer: stop searching\n\t\t    break;\n\t\t// advance to older entry in jump list\n\t\tif (!jumpidx && curwin->w_jumplistidx == curwin->w_jumplistlen)\n\t\t    break;\n\t\tif (--jumpidx < 0)\n\t\t    jumpidx = curwin->w_jumplistlen - 1;\n\t\tif (jumpidx == forward)\t\t// List exhausted for sure\n\t\t    break;\n\t    }\n\t}\n\n\tif (buf == NULL)\t// No previous buffer, Try 2'nd approach\n\t{\n\t    forward = TRUE;\n\t    buf = curbuf->b_next;\n\t    for (;;)\n\t    {\n\t\tif (buf == NULL)\n\t\t{\n\t\t    if (!forward)\t// tried both directions\n\t\t\tbreak;\n\t\t    buf = curbuf->b_prev;\n\t\t    forward = FALSE;\n\t\t    continue;\n\t\t}\n\t\t// in non-help buffer, try to skip help buffers, and vv\n\t\tif (buf->b_help == curbuf->b_help && buf->b_p_bl\n#if defined(FEAT_QUICKFIX)\n\t\t\t    && !bt_quickfix(buf)\n#endif\n\t\t\t   )\n\t\t{\n\t\t    if (buf->b_ml.ml_mfp != NULL)   // found loaded buffer\n\t\t\tbreak;\n\t\t    if (bp == NULL)\t// remember unloaded buf for later\n\t\t\tbp = buf;\n\t\t}\n\t\tif (forward)\n\t\t    buf = buf->b_next;\n\t\telse\n\t\t    buf = buf->b_prev;\n\t    }\n\t}\n\tif (buf == NULL)\t// No loaded buffer, use unloaded one\n\t    buf = bp;\n\tif (buf == NULL)\t// No loaded buffer, find listed one\n\t{\n\t    FOR_ALL_BUFFERS(buf)\n\t\tif (buf->b_p_bl && buf != curbuf\n#if defined(FEAT_QUICKFIX)\n\t\t\t    && !bt_quickfix(buf)\n#endif\n\t\t       )\n\t\t    break;\n\t}\n\tif (buf == NULL)\t// Still no buffer, just take one\n\t{\n\t    if (curbuf->b_next != NULL)\n\t\tbuf = curbuf->b_next;\n\t    else\n\t\tbuf = curbuf->b_prev;\n#if defined(FEAT_QUICKFIX)\n\t    if (bt_quickfix(buf))\n\t\tbuf = NULL;\n#endif\n\t}\n    }\n\n    if (buf == NULL)\n    {\n\t// Autocommands must have wiped out all other buffers.  Only option\n\t// now is to make the current buffer empty.\n\treturn empty_curbuf(FALSE, (flags & DOBUF_FORCEIT), action);\n    }\n\n    /*\n     * make \"buf\" the current buffer\n     */\n    if (action == DOBUF_SPLIT)\t    // split window first\n    {\n\t// If 'switchbuf' contains \"useopen\": jump to first window containing\n\t// \"buf\" if one exists\n\tif ((swb_flags & SWB_USEOPEN) && buf_jump_open_win(buf))\n\t    return OK;\n\t// If 'switchbuf' contains \"usetab\": jump to first window in any tab\n\t// page containing \"buf\" if one exists\n\tif ((swb_flags & SWB_USETAB) && buf_jump_open_tab(buf))\n\t    return OK;\n\tif (win_split(0, 0) == FAIL)\n\t    return FAIL;\n    }\n\n    // go to current buffer - nothing to do\n    if (buf == curbuf)\n\treturn OK;\n\n    // Check if the current buffer may be abandoned.\n    if (action == DOBUF_GOTO && !can_abandon(curbuf, (flags & DOBUF_FORCEIT)))\n    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\tif ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t{\n\t    bufref_T bufref;\n\n\t    set_bufref(&bufref, buf);\n\t    dialog_changed(curbuf, FALSE);\n\t    if (!bufref_valid(&bufref))\n\t\t// Autocommand deleted buffer, oops!\n\t\treturn FAIL;\n\t}\n\tif (bufIsChanged(curbuf))\n#endif\n\t{\n\t    no_write_message();\n\t    return FAIL;\n\t}\n    }\n\n    // Go to the other buffer.\n    set_curbuf(buf, action);\n\n    if (action == DOBUF_SPLIT)\n\tRESET_BINDING(curwin);\t// reset 'scrollbind' and 'cursorbind'\n\n#if defined(FEAT_EVAL)\n    if (aborting())\t    // autocmds may abort script processing\n\treturn FAIL;\n#endif\n\n    return OK;\n}\n\n    int\ndo_buffer(\n    int\t\taction,\n    int\t\tstart,\n    int\t\tdir,\t\t// FORWARD or BACKWARD\n    int\t\tcount,\t\t// buffer number or number of buffers\n    int\t\tforceit)\t// TRUE when using !\n{\n    return do_buffer_ext(action, start, dir, count,\n\t\t\t\t\t\t  forceit ? DOBUF_FORCEIT : 0);\n}\n\n/*\n * do_bufdel() - delete or unload buffer(s)\n *\n * addr_count == 0: \":bdel\" - delete current buffer\n * addr_count == 1: \":N bdel\" or \":bdel N [N ..]\" - first delete\n *\t\t    buffer \"end_bnr\", then any other arguments.\n * addr_count == 2: \":N,N bdel\" - delete buffers in range\n *\n * command can be DOBUF_UNLOAD (\":bunload\"), DOBUF_WIPE (\":bwipeout\") or\n * DOBUF_DEL (\":bdel\")\n *\n * Returns error message or NULL\n */\n    char *\ndo_bufdel(\n    int\t\tcommand,\n    char_u\t*arg,\t\t// pointer to extra arguments\n    int\t\taddr_count,\n    int\t\tstart_bnr,\t// first buffer number in a range\n    int\t\tend_bnr,\t// buffer nr or last buffer nr in a range\n    int\t\tforceit)\n{\n    int\t\tdo_current = 0;\t// delete current buffer?\n    int\t\tdeleted = 0;\t// number of buffers deleted\n    char\t*errormsg = NULL; // return value\n    int\t\tbnr;\t\t// buffer number\n    char_u\t*p;\n\n    if (addr_count == 0)\n    {\n\t(void)do_buffer(command, DOBUF_CURRENT, FORWARD, 0, forceit);\n    }\n    else\n    {\n\tif (addr_count == 2)\n\t{\n\t    if (*arg)\t\t// both range and argument is not allowed\n\t\treturn ex_errmsg(e_trailing_characters_str, arg);\n\t    bnr = start_bnr;\n\t}\n\telse\t// addr_count == 1\n\t    bnr = end_bnr;\n\n\tfor ( ;!got_int; ui_breakcheck())\n\t{\n\t    // Delete the current buffer last, otherwise when the\n\t    // current buffer is deleted, the next buffer becomes\n\t    // the current one and will be loaded, which may then\n\t    // also be deleted, etc.\n\t    if (bnr == curbuf->b_fnum)\n\t\tdo_current = bnr;\n\t    else if (do_buffer_ext(command, DOBUF_FIRST, FORWARD, bnr,\n\t\t\t  DOBUF_NOPOPUP | (forceit ? DOBUF_FORCEIT : 0)) == OK)\n\t\t++deleted;\n\n\t    // find next buffer number to delete/unload\n\t    if (addr_count == 2)\n\t    {\n\t\tif (++bnr > end_bnr)\n\t\t    break;\n\t    }\n\t    else    // addr_count == 1\n\t    {\n\t\targ = skipwhite(arg);\n\t\tif (*arg == NUL)\n\t\t    break;\n\t\tif (!VIM_ISDIGIT(*arg))\n\t\t{\n\t\t    p = skiptowhite_esc(arg);\n\t\t    bnr = buflist_findpat(arg, p,\n\t\t\t  command == DOBUF_WIPE || command == DOBUF_WIPE_REUSE,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\t\t    if (bnr < 0)\t    // failed\n\t\t\tbreak;\n\t\t    arg = p;\n\t\t}\n\t\telse\n\t\t    bnr = getdigits(&arg);\n\t    }\n\t}\n\tif (!got_int && do_current && do_buffer(command, DOBUF_FIRST,\n\t\t\t\t\t  FORWARD, do_current, forceit) == OK)\n\t    ++deleted;\n\n\tif (deleted == 0)\n\t{\n\t    if (command == DOBUF_UNLOAD)\n\t\tSTRCPY(IObuff, _(e_no_buffers_were_unloaded));\n\t    else if (command == DOBUF_DEL)\n\t\tSTRCPY(IObuff, _(e_no_buffers_were_deleted));\n\t    else\n\t\tSTRCPY(IObuff, _(e_no_buffers_were_wiped_out));\n\t    errormsg = (char *)IObuff;\n\t}\n\telse if (deleted >= p_report)\n\t{\n\t    if (command == DOBUF_UNLOAD)\n\t\tsmsg(NGETTEXT(\"%d buffer unloaded\",\n\t\t\t    \"%d buffers unloaded\", deleted), deleted);\n\t    else if (command == DOBUF_DEL)\n\t\tsmsg(NGETTEXT(\"%d buffer deleted\",\n\t\t\t    \"%d buffers deleted\", deleted), deleted);\n\t    else\n\t\tsmsg(NGETTEXT(\"%d buffer wiped out\",\n\t\t\t    \"%d buffers wiped out\", deleted), deleted);\n\t}\n    }\n\n\n    return errormsg;\n}\n\n/*\n * Set current buffer to \"buf\".  Executes autocommands and closes current\n * buffer.  \"action\" tells how to close the current buffer:\n * DOBUF_GOTO\t    free or hide it\n * DOBUF_SPLIT\t    nothing\n * DOBUF_UNLOAD\t    unload it\n * DOBUF_DEL\t    delete it\n * DOBUF_WIPE\t    wipe it out\n * DOBUF_WIPE_REUSE wipe it out and add to \"buf_reuse\"\n */\n    void\nset_curbuf(buf_T *buf, int action)\n{\n    buf_T\t*prevbuf;\n    int\t\tunload = (action == DOBUF_UNLOAD || action == DOBUF_DEL\n\t\t\t|| action == DOBUF_WIPE || action == DOBUF_WIPE_REUSE);\n#ifdef FEAT_SYN_HL\n    long\told_tw = curbuf->b_p_tw;\n#endif\n    bufref_T\tnewbufref;\n    bufref_T\tprevbufref;\n    int\t\tvalid;\n\n    setpcmark();\n    if ((cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\tcurwin->w_alt_fnum = curbuf->b_fnum; // remember alternate file\n    buflist_altfpos(curwin);\t\t\t // remember curpos\n\n    // Don't restart Select mode after switching to another buffer.\n    VIsual_reselect = FALSE;\n\n    // close_windows() or apply_autocmds() may change curbuf and wipe out \"buf\"\n    prevbuf = curbuf;\n    set_bufref(&prevbufref, prevbuf);\n    set_bufref(&newbufref, buf);\n\n    // Autocommands may delete the current buffer and/or the buffer we want to\n    // go to.  In those cases don't close the buffer.\n    if (!apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf)\n\t    || (bufref_valid(&prevbufref)\n\t\t&& bufref_valid(&newbufref)\n#ifdef FEAT_EVAL\n\t\t&& !aborting()\n#endif\n\t       ))\n    {\n#ifdef FEAT_SYN_HL\n\tif (prevbuf == curwin->w_buffer)\n\t    reset_synblock(curwin);\n#endif\n\tif (unload)\n\t    close_windows(prevbuf, FALSE);\n#if defined(FEAT_EVAL)\n\tif (bufref_valid(&prevbufref) && !aborting())\n#else\n\tif (bufref_valid(&prevbufref))\n#endif\n\t{\n\t    win_T  *previouswin = curwin;\n\n\t    // Do not sync when in Insert mode and the buffer is open in\n\t    // another window, might be a timer doing something in another\n\t    // window.\n\t    if (prevbuf == curbuf\n\t\t    && ((State & MODE_INSERT) == 0 || curbuf->b_nwindows <= 1))\n\t\tu_sync(FALSE);\n\t    close_buffer(prevbuf == curwin->w_buffer ? curwin : NULL, prevbuf,\n\t\t    unload ? action : (action == DOBUF_GOTO\n\t\t\t&& !buf_hide(prevbuf)\n\t\t\t&& !bufIsChanged(prevbuf)) ? DOBUF_UNLOAD : 0,\n\t\t    FALSE, FALSE);\n\t    if (curwin != previouswin && win_valid(previouswin))\n\t      // autocommands changed curwin, Grr!\n\t      curwin = previouswin;\n\t}\n    }\n    // An autocommand may have deleted \"buf\", already entered it (e.g., when\n    // it did \":bunload\") or aborted the script processing.\n    // If curwin->w_buffer is null, enter_buffer() will make it valid again\n    valid = buf_valid(buf);\n    if ((valid && buf != curbuf\n#ifdef FEAT_EVAL\n\t\t&& !aborting()\n#endif\n\t) || curwin->w_buffer == NULL)\n    {\n\t// If the buffer is not valid but curwin->w_buffer is NULL we must\n\t// enter some buffer.  Using the last one is hopefully OK.\n\tif (!valid)\n\t    enter_buffer(lastbuf);\n\telse\n\t    enter_buffer(buf);\n#ifdef FEAT_SYN_HL\n\tif (old_tw != curbuf->b_p_tw)\n\t    check_colorcolumn(curwin);\n#endif\n    }\n}\n\n/*\n * Enter a new current buffer.\n * Old curbuf must have been abandoned already!  This also means \"curbuf\" may\n * be pointing to freed memory.\n */\n    static void\nenter_buffer(buf_T *buf)\n{\n    // Get the buffer in the current window.\n    curwin->w_buffer = buf;\n    curbuf = buf;\n    ++curbuf->b_nwindows;\n\n    // Copy buffer and window local option values.  Not for a help buffer.\n    buf_copy_options(buf, BCO_ENTER | BCO_NOHELP);\n    if (!buf->b_help)\n\tget_winopts(buf);\n#ifdef FEAT_FOLDING\n    else\n\t// Remove all folds in the window.\n\tclearFolding(curwin);\n    foldUpdateAll(curwin);\t// update folds (later).\n#endif\n\n#ifdef FEAT_DIFF\n    if (curwin->w_p_diff)\n\tdiff_buf_add(curbuf);\n#endif\n\n#ifdef FEAT_SYN_HL\n    curwin->w_s = &(curbuf->b_s);\n#endif\n\n    // Cursor on first line by default.\n    curwin->w_cursor.lnum = 1;\n    curwin->w_cursor.col = 0;\n    curwin->w_cursor.coladd = 0;\n    curwin->w_set_curswant = TRUE;\n    curwin->w_topline_was_set = FALSE;\n\n    // mark cursor position as being invalid\n    curwin->w_valid = 0;\n\n    buflist_setfpos(curbuf, curwin, curbuf->b_last_cursor.lnum,\n\t\t\t\t\t      curbuf->b_last_cursor.col, TRUE);\n\n    // Make sure the buffer is loaded.\n    if (curbuf->b_ml.ml_mfp == NULL)\t// need to load the file\n    {\n\t// If there is no filetype, allow for detecting one.  Esp. useful for\n\t// \":ball\" used in an autocommand.  If there already is a filetype we\n\t// might prefer to keep it.\n\tif (*curbuf->b_p_ft == NUL)\n\t    did_filetype = FALSE;\n\n\topen_buffer(FALSE, NULL, 0);\n    }\n    else\n    {\n\tif (!msg_silent && !shortmess(SHM_FILEINFO))\n\t    need_fileinfo = TRUE;\t// display file info after redraw\n\n\t// check if file changed\n\t(void)buf_check_timestamp(curbuf, FALSE);\n\n\tcurwin->w_topline = 1;\n#ifdef FEAT_DIFF\n\tcurwin->w_topfill = 0;\n#endif\n\tapply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_BUFWINENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    // If autocommands did not change the cursor position, restore cursor lnum\n    // and possibly cursor col.\n    if (curwin->w_cursor.lnum == 1 && inindent(0))\n\tbuflist_getfpos();\n\n    check_arg_idx(curwin);\t\t// check for valid arg_idx\n    maketitle();\n\t// when autocmds didn't change it\n    if (curwin->w_topline == 1 && !curwin->w_topline_was_set)\n\tscroll_cursor_halfway(FALSE);\t// redisplay at correct position\n\n#ifdef FEAT_NETBEANS_INTG\n    // Send fileOpened event because we've changed buffers.\n    netbeans_file_activated(curbuf);\n#endif\n\n    // Change directories when the 'acd' option is set.\n    DO_AUTOCHDIR;\n\n#ifdef FEAT_KEYMAP\n    if (curbuf->b_kmap_state & KEYMAP_INIT)\n\t(void)keymap_init();\n#endif\n#ifdef FEAT_SPELL\n    // May need to set the spell language.  Can only do this after the buffer\n    // has been properly setup.\n    if (!curbuf->b_help && curwin->w_p_spell && *curwin->w_s->b_p_spl != NUL)\n\t(void)did_set_spelllang(curwin);\n#endif\n#ifdef FEAT_VIMINFO\n    curbuf->b_last_used = vim_time();\n#endif\n\n    redraw_later(NOT_VALID);\n}\n\n#if defined(FEAT_AUTOCHDIR) || defined(PROTO)\n/*\n * Change to the directory of the current buffer.\n * Don't do this while still starting up.\n */\n    void\ndo_autochdir(void)\n{\n    if ((starting == 0 || test_autochdir)\n\t    && curbuf->b_ffname != NULL\n\t    && vim_chdirfile(curbuf->b_ffname, \"auto\") == OK)\n    {\n\tshorten_fnames(TRUE);\n\tlast_chdir_reason = \"autochdir\";\n    }\n}\n#endif\n\n    void\nno_write_message(void)\n{\n#ifdef FEAT_TERMINAL\n    if (term_job_running(curbuf->b_term))\n\temsg(_(e_job_still_running_add_bang_to_end_the_job));\n    else\n#endif\n\temsg(_(e_no_write_since_last_change_add_bang_to_override));\n}\n\n    void\nno_write_message_nobang(buf_T *buf UNUSED)\n{\n#ifdef FEAT_TERMINAL\n    if (term_job_running(buf->b_term))\n\temsg(_(e_job_still_running));\n    else\n#endif\n\temsg(_(e_no_write_since_last_change));\n}\n\n/*\n * functions for dealing with the buffer list\n */\n\n/*\n * Return TRUE if the current buffer is empty, unnamed, unmodified and used in\n * only one window.  That means it can be re-used.\n */\n    int\ncurbuf_reusable(void)\n{\n    return (curbuf != NULL\n\t&& curbuf->b_ffname == NULL\n\t&& curbuf->b_nwindows <= 1\n\t&& (curbuf->b_ml.ml_mfp == NULL || BUFEMPTY())\n#if defined(FEAT_QUICKFIX)\n\t&& !bt_quickfix(curbuf)\n#endif\n\t&& !curbufIsChanged());\n}\n\n/*\n * Add a file name to the buffer list.  Return a pointer to the buffer.\n * If the same file name already exists return a pointer to that buffer.\n * If it does not exist, or if fname == NULL, a new entry is created.\n * If (flags & BLN_CURBUF) is TRUE, may use current buffer.\n * If (flags & BLN_LISTED) is TRUE, add new buffer to buffer list.\n * If (flags & BLN_DUMMY) is TRUE, don't count it as a real buffer.\n * If (flags & BLN_NEW) is TRUE, don't use an existing buffer.\n * If (flags & BLN_NOOPT) is TRUE, don't copy options from the current buffer\n *\t\t\t\t    if the buffer already exists.\n * If (flags & BLN_REUSE) is TRUE, may use buffer number from \"buf_reuse\".\n * This is the ONLY way to create a new buffer.\n */\n    buf_T *\nbuflist_new(\n    char_u\t*ffname_arg,\t// full path of fname or relative\n    char_u\t*sfname_arg,\t// short fname or NULL\n    linenr_T\tlnum,\t\t// preferred cursor line\n    int\t\tflags)\t\t// BLN_ defines\n{\n    char_u\t*ffname = ffname_arg;\n    char_u\t*sfname = sfname_arg;\n    buf_T\t*buf;\n#ifdef UNIX\n    stat_T\tst;\n#endif\n\n    if (top_file_num == 1)\n\thash_init(&buf_hashtab);\n\n    fname_expand(curbuf, &ffname, &sfname);\t// will allocate ffname\n\n    /*\n     * If the file name already exists in the list, update the entry.\n     */\n#ifdef UNIX\n    // On Unix we can use inode numbers when the file exists.  Works better\n    // for hard links.\n    if (sfname == NULL || mch_stat((char *)sfname, &st) < 0)\n\tst.st_dev = (dev_T)-1;\n#endif\n    if (ffname != NULL && !(flags & (BLN_DUMMY | BLN_NEW)) && (buf =\n#ifdef UNIX\n\t\tbuflist_findname_stat(ffname, &st)\n#else\n\t\tbuflist_findname(ffname)\n#endif\n\t\t) != NULL)\n    {\n\tvim_free(ffname);\n\tif (lnum != 0)\n\t    buflist_setfpos(buf, (flags & BLN_NOCURWIN) ? NULL : curwin,\n\t\t\t\t\t\t      lnum, (colnr_T)0, FALSE);\n\n\tif ((flags & BLN_NOOPT) == 0)\n\t    // copy the options now, if 'cpo' doesn't have 's' and not done\n\t    // already\n\t    buf_copy_options(buf, 0);\n\n\tif ((flags & BLN_LISTED) && !buf->b_p_bl)\n\t{\n\t    bufref_T bufref;\n\n\t    buf->b_p_bl = TRUE;\n\t    set_bufref(&bufref, buf);\n\t    if (!(flags & BLN_DUMMY))\n\t    {\n\t\tif (apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, buf)\n\t\t\t&& !bufref_valid(&bufref))\n\t\t    return NULL;\n\t    }\n\t}\n\treturn buf;\n    }\n\n    /*\n     * If the current buffer has no name and no contents, use the current\n     * buffer.\tOtherwise: Need to allocate a new buffer structure.\n     *\n     * This is the ONLY place where a new buffer structure is allocated!\n     * (A spell file buffer is allocated in spell.c, but that's not a normal\n     * buffer.)\n     */\n    buf = NULL;\n    if ((flags & BLN_CURBUF) && curbuf_reusable())\n    {\n\tbuf = curbuf;\n\t// It's like this buffer is deleted.  Watch out for autocommands that\n\t// change curbuf!  If that happens, allocate a new buffer anyway.\n\tbuf_freeall(buf, BFA_WIPE | BFA_DEL);\n\tif (buf != curbuf)   // autocommands deleted the buffer!\n\t    return NULL;\n#ifdef FEAT_EVAL\n\tif (aborting())\t\t// autocmds may abort script processing\n\t{\n\t    vim_free(ffname);\n\t    return NULL;\n\t}\n#endif\n    }\n    if (buf != curbuf || curbuf == NULL)\n    {\n\tbuf = ALLOC_CLEAR_ONE(buf_T);\n\tif (buf == NULL)\n\t{\n\t    vim_free(ffname);\n\t    return NULL;\n\t}\n#ifdef FEAT_EVAL\n\t// init b: variables\n\tbuf->b_vars = dict_alloc_id(aid_newbuf_bvars);\n\tif (buf->b_vars == NULL)\n\t{\n\t    vim_free(ffname);\n\t    vim_free(buf);\n\t    return NULL;\n\t}\n\tinit_var_dict(buf->b_vars, &buf->b_bufvar, VAR_SCOPE);\n#endif\n\tinit_changedtick(buf);\n    }\n\n    if (ffname != NULL)\n    {\n\tbuf->b_ffname = ffname;\n\tbuf->b_sfname = vim_strsave(sfname);\n    }\n\n    clear_wininfo(buf);\n    buf->b_wininfo = ALLOC_CLEAR_ONE(wininfo_T);\n\n    if ((ffname != NULL && (buf->b_ffname == NULL || buf->b_sfname == NULL))\n\t    || buf->b_wininfo == NULL)\n    {\n\tif (buf->b_sfname != buf->b_ffname)\n\t    VIM_CLEAR(buf->b_sfname);\n\telse\n\t    buf->b_sfname = NULL;\n\tVIM_CLEAR(buf->b_ffname);\n\tif (buf != curbuf)\n\t    free_buffer(buf);\n\treturn NULL;\n    }\n\n    if (buf == curbuf)\n    {\n\tfree_buffer_stuff(buf, FALSE);\t// delete local variables et al.\n\n\t// Init the options.\n\tbuf->b_p_initialized = FALSE;\n\tbuf_copy_options(buf, BCO_ENTER);\n\n#ifdef FEAT_KEYMAP\n\t// need to reload lmaps and set b:keymap_name\n\tcurbuf->b_kmap_state |= KEYMAP_INIT;\n#endif\n    }\n    else\n    {\n\t// put the new buffer at the end of the buffer list\n\tbuf->b_next = NULL;\n\tif (firstbuf == NULL)\t\t// buffer list is empty\n\t{\n\t    buf->b_prev = NULL;\n\t    firstbuf = buf;\n\t}\n\telse\t\t\t\t// append new buffer at end of list\n\t{\n\t    lastbuf->b_next = buf;\n\t    buf->b_prev = lastbuf;\n\t}\n\tlastbuf = buf;\n\n\tif ((flags & BLN_REUSE) && buf_reuse.ga_len > 0)\n\t{\n\t    // Recycle a previously used buffer number.  Used for buffers which\n\t    // are normally hidden, e.g. in a popup window.  Avoids that the\n\t    // buffer number grows rapidly.\n\t    --buf_reuse.ga_len;\n\t    buf->b_fnum = ((int *)buf_reuse.ga_data)[buf_reuse.ga_len];\n\n\t    // Move buffer to the right place in the buffer list.\n\t    while (buf->b_prev != NULL && buf->b_fnum < buf->b_prev->b_fnum)\n\t    {\n\t\tbuf_T\t*prev = buf->b_prev;\n\n\t\tprev->b_next = buf->b_next;\n\t\tif (prev->b_next != NULL)\n\t\t    prev->b_next->b_prev = prev;\n\t\tbuf->b_next = prev;\n\t\tbuf->b_prev = prev->b_prev;\n\t\tif (buf->b_prev != NULL)\n\t\t    buf->b_prev->b_next = buf;\n\t\tprev->b_prev = buf;\n\t\tif (lastbuf == buf)\n\t\t    lastbuf = prev;\n\t\tif (firstbuf == prev)\n\t\t    firstbuf = buf;\n\t    }\n\t}\n\telse\n\t    buf->b_fnum = top_file_num++;\n\tif (top_file_num < 0)\t\t// wrap around (may cause duplicates)\n\t{\n\t    emsg(_(\"W14: Warning: List of file names overflow\"));\n\t    if (emsg_silent == 0 && !in_assert_fails)\n\t    {\n\t\tout_flush();\n\t\tui_delay(3001L, TRUE);\t// make sure it is noticed\n\t    }\n\t    top_file_num = 1;\n\t}\n\tbuf_hashtab_add(buf);\n\n\t// Always copy the options from the current buffer.\n\tbuf_copy_options(buf, BCO_ALWAYS);\n    }\n\n    buf->b_wininfo->wi_fpos.lnum = lnum;\n    buf->b_wininfo->wi_win = curwin;\n\n#ifdef FEAT_SYN_HL\n    hash_init(&buf->b_s.b_keywtab);\n    hash_init(&buf->b_s.b_keywtab_ic);\n#endif\n\n    buf->b_fname = buf->b_sfname;\n#ifdef UNIX\n    if (st.st_dev == (dev_T)-1)\n\tbuf->b_dev_valid = FALSE;\n    else\n    {\n\tbuf->b_dev_valid = TRUE;\n\tbuf->b_dev = st.st_dev;\n\tbuf->b_ino = st.st_ino;\n    }\n#endif\n    buf->b_u_synced = TRUE;\n    buf->b_flags = BF_CHECK_RO | BF_NEVERLOADED;\n    if (flags & BLN_DUMMY)\n\tbuf->b_flags |= BF_DUMMY;\n    buf_clear_file(buf);\n    clrallmarks(buf);\t\t\t// clear marks\n    fmarks_check_names(buf);\t\t// check file marks for this file\n    buf->b_p_bl = (flags & BLN_LISTED) ? TRUE : FALSE;\t// init 'buflisted'\n    if (!(flags & BLN_DUMMY))\n    {\n\tbufref_T bufref;\n\n\t// Tricky: these autocommands may change the buffer list.  They could\n\t// also split the window with re-using the one empty buffer. This may\n\t// result in unexpectedly losing the empty buffer.\n\tset_bufref(&bufref, buf);\n\tif (apply_autocmds(EVENT_BUFNEW, NULL, NULL, FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t    return NULL;\n\tif (flags & BLN_LISTED)\n\t{\n\t    if (apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, buf)\n\t\t    && !bufref_valid(&bufref))\n\t\treturn NULL;\n\t}\n#ifdef FEAT_EVAL\n\tif (aborting())\t\t// autocmds may abort script processing\n\t    return NULL;\n#endif\n    }\n\n    return buf;\n}\n\n/*\n * Free the memory for the options of a buffer.\n * If \"free_p_ff\" is TRUE also free 'fileformat', 'buftype' and\n * 'fileencoding'.\n */\n    void\nfree_buf_options(\n    buf_T\t*buf,\n    int\t\tfree_p_ff)\n{\n    if (free_p_ff)\n    {\n\tclear_string_option(&buf->b_p_fenc);\n\tclear_string_option(&buf->b_p_ff);\n\tclear_string_option(&buf->b_p_bh);\n\tclear_string_option(&buf->b_p_bt);\n    }\n#ifdef FEAT_FIND_ID\n    clear_string_option(&buf->b_p_def);\n    clear_string_option(&buf->b_p_inc);\n# ifdef FEAT_EVAL\n    clear_string_option(&buf->b_p_inex);\n# endif\n#endif\n#if defined(FEAT_EVAL)\n    clear_string_option(&buf->b_p_inde);\n    clear_string_option(&buf->b_p_indk);\n#endif\n#if defined(FEAT_BEVAL) && defined(FEAT_EVAL)\n    clear_string_option(&buf->b_p_bexpr);\n#endif\n#if defined(FEAT_CRYPT)\n    clear_string_option(&buf->b_p_cm);\n#endif\n    clear_string_option(&buf->b_p_fp);\n#if defined(FEAT_EVAL)\n    clear_string_option(&buf->b_p_fex);\n#endif\n#ifdef FEAT_CRYPT\n# ifdef FEAT_SODIUM\n    if ((buf->b_p_key != NULL) && (*buf->b_p_key != NUL) &&\n\t\t\t\t(crypt_get_method_nr(buf) == CRYPT_M_SOD))\n\tcrypt_sodium_munlock(buf->b_p_key, STRLEN(buf->b_p_key));\n# endif\n    clear_string_option(&buf->b_p_key);\n#endif\n    clear_string_option(&buf->b_p_kp);\n    clear_string_option(&buf->b_p_mps);\n    clear_string_option(&buf->b_p_fo);\n    clear_string_option(&buf->b_p_flp);\n    clear_string_option(&buf->b_p_isk);\n#ifdef FEAT_VARTABS\n    clear_string_option(&buf->b_p_vsts);\n    vim_free(buf->b_p_vsts_nopaste);\n    buf->b_p_vsts_nopaste = NULL;\n    VIM_CLEAR(buf->b_p_vsts_array);\n    clear_string_option(&buf->b_p_vts);\n    VIM_CLEAR(buf->b_p_vts_array);\n#endif\n#ifdef FEAT_KEYMAP\n    clear_string_option(&buf->b_p_keymap);\n    keymap_clear(&buf->b_kmap_ga);\n    ga_clear(&buf->b_kmap_ga);\n#endif\n    clear_string_option(&buf->b_p_com);\n#ifdef FEAT_FOLDING\n    clear_string_option(&buf->b_p_cms);\n#endif\n    clear_string_option(&buf->b_p_nf);\n#ifdef FEAT_SYN_HL\n    clear_string_option(&buf->b_p_syn);\n    clear_string_option(&buf->b_s.b_syn_isk);\n#endif\n#ifdef FEAT_SPELL\n    clear_string_option(&buf->b_s.b_p_spc);\n    clear_string_option(&buf->b_s.b_p_spf);\n    vim_regfree(buf->b_s.b_cap_prog);\n    buf->b_s.b_cap_prog = NULL;\n    clear_string_option(&buf->b_s.b_p_spl);\n    clear_string_option(&buf->b_s.b_p_spo);\n#endif\n#ifdef FEAT_SEARCHPATH\n    clear_string_option(&buf->b_p_sua);\n#endif\n    clear_string_option(&buf->b_p_ft);\n    clear_string_option(&buf->b_p_cink);\n    clear_string_option(&buf->b_p_cino);\n    clear_string_option(&buf->b_p_cinsd);\n    clear_string_option(&buf->b_p_cinw);\n    clear_string_option(&buf->b_p_cpt);\n#ifdef FEAT_COMPL_FUNC\n    clear_string_option(&buf->b_p_cfu);\n    free_callback(&buf->b_cfu_cb);\n    clear_string_option(&buf->b_p_ofu);\n    free_callback(&buf->b_ofu_cb);\n    clear_string_option(&buf->b_p_tsrfu);\n    free_callback(&buf->b_tsrfu_cb);\n#endif\n#ifdef FEAT_QUICKFIX\n    clear_string_option(&buf->b_p_gp);\n    clear_string_option(&buf->b_p_mp);\n    clear_string_option(&buf->b_p_efm);\n#endif\n    clear_string_option(&buf->b_p_ep);\n    clear_string_option(&buf->b_p_path);\n    clear_string_option(&buf->b_p_tags);\n    clear_string_option(&buf->b_p_tc);\n#ifdef FEAT_EVAL\n    clear_string_option(&buf->b_p_tfu);\n    free_callback(&buf->b_tfu_cb);\n#endif\n    clear_string_option(&buf->b_p_dict);\n    clear_string_option(&buf->b_p_tsr);\n#ifdef FEAT_TEXTOBJ\n    clear_string_option(&buf->b_p_qe);\n#endif\n    buf->b_p_ar = -1;\n    buf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n    clear_string_option(&buf->b_p_lw);\n    clear_string_option(&buf->b_p_bkc);\n    clear_string_option(&buf->b_p_menc);\n}\n\n/*\n * Get alternate file \"n\".\n * Set linenr to \"lnum\" or altfpos.lnum if \"lnum\" == 0.\n *\tAlso set cursor column to altfpos.col if 'startofline' is not set.\n * if (options & GETF_SETMARK) call setpcmark()\n * if (options & GETF_ALT) we are jumping to an alternate file.\n * if (options & GETF_SWITCH) respect 'switchbuf' settings when jumping\n *\n * Return FAIL for failure, OK for success.\n */\n    int\nbuflist_getfile(\n    int\t\tn,\n    linenr_T\tlnum,\n    int\t\toptions,\n    int\t\tforceit)\n{\n    buf_T\t*buf;\n    win_T\t*wp = NULL;\n    pos_T\t*fpos;\n    colnr_T\tcol;\n\n    buf = buflist_findnr(n);\n    if (buf == NULL)\n    {\n\tif ((options & GETF_ALT) && n == 0)\n\t    emsg(_(e_no_alternate_file));\n\telse\n\t    semsg(_(e_buffer_nr_not_found), n);\n\treturn FAIL;\n    }\n\n    // if alternate file is the current buffer, nothing to do\n    if (buf == curbuf)\n\treturn OK;\n\n    if (text_or_buf_locked())\n\treturn FAIL;\n\n    // altfpos may be changed by getfile(), get it now\n    if (lnum == 0)\n    {\n\tfpos = buflist_findfpos(buf);\n\tlnum = fpos->lnum;\n\tcol = fpos->col;\n    }\n    else\n\tcol = 0;\n\n    if (options & GETF_SWITCH)\n    {\n\t// If 'switchbuf' contains \"useopen\": jump to first window containing\n\t// \"buf\" if one exists\n\tif (swb_flags & SWB_USEOPEN)\n\t    wp = buf_jump_open_win(buf);\n\n\t// If 'switchbuf' contains \"usetab\": jump to first window in any tab\n\t// page containing \"buf\" if one exists\n\tif (wp == NULL && (swb_flags & SWB_USETAB))\n\t    wp = buf_jump_open_tab(buf);\n\n\t// If 'switchbuf' contains \"split\", \"vsplit\" or \"newtab\" and the\n\t// current buffer isn't empty: open new tab or window\n\tif (wp == NULL && (swb_flags & (SWB_VSPLIT | SWB_SPLIT | SWB_NEWTAB))\n\t\t\t\t\t\t\t       && !BUFEMPTY())\n\t{\n\t    if (swb_flags & SWB_NEWTAB)\n\t\ttabpage_new();\n\t    else if (win_split(0, (swb_flags & SWB_VSPLIT) ? WSP_VERT : 0)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\treturn FAIL;\n\t    RESET_BINDING(curwin);\n\t}\n    }\n\n    ++RedrawingDisabled;\n    if (GETFILE_SUCCESS(getfile(buf->b_fnum, NULL, NULL,\n\t\t\t\t     (options & GETF_SETMARK), lnum, forceit)))\n    {\n\t--RedrawingDisabled;\n\n\t// cursor is at to BOL and w_cursor.lnum is checked due to getfile()\n\tif (!p_sol && col != 0)\n\t{\n\t    curwin->w_cursor.col = col;\n\t    check_cursor_col();\n\t    curwin->w_cursor.coladd = 0;\n\t    curwin->w_set_curswant = TRUE;\n\t}\n\treturn OK;\n    }\n    --RedrawingDisabled;\n    return FAIL;\n}\n\n/*\n * go to the last know line number for the current buffer\n */\n    static void\nbuflist_getfpos(void)\n{\n    pos_T\t*fpos;\n\n    fpos = buflist_findfpos(curbuf);\n\n    curwin->w_cursor.lnum = fpos->lnum;\n    check_cursor_lnum();\n\n    if (p_sol)\n\tcurwin->w_cursor.col = 0;\n    else\n    {\n\tcurwin->w_cursor.col = fpos->col;\n\tcheck_cursor_col();\n\tcurwin->w_cursor.coladd = 0;\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n#if defined(FEAT_QUICKFIX) || defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Find file in buffer list by name (it has to be for the current window).\n * Returns NULL if not found.\n */\n    buf_T *\nbuflist_findname_exp(char_u *fname)\n{\n    char_u\t*ffname;\n    buf_T\t*buf = NULL;\n\n    // First make the name into a full path name\n    ffname = FullName_save(fname,\n#ifdef UNIX\n\t    TRUE\t    // force expansion, get rid of symbolic links\n#else\n\t    FALSE\n#endif\n\t    );\n    if (ffname != NULL)\n    {\n\tbuf = buflist_findname(ffname);\n\tvim_free(ffname);\n    }\n    return buf;\n}\n#endif\n\n/*\n * Find file in buffer list by name (it has to be for the current window).\n * \"ffname\" must have a full path.\n * Skips dummy buffers.\n * Returns NULL if not found.\n */\n    buf_T *\nbuflist_findname(char_u *ffname)\n{\n#ifdef UNIX\n    stat_T\tst;\n\n    if (mch_stat((char *)ffname, &st) < 0)\n\tst.st_dev = (dev_T)-1;\n    return buflist_findname_stat(ffname, &st);\n}\n\n/*\n * Same as buflist_findname(), but pass the stat structure to avoid getting it\n * twice for the same file.\n * Returns NULL if not found.\n */\n    static buf_T *\nbuflist_findname_stat(\n    char_u\t*ffname,\n    stat_T\t*stp)\n{\n#endif\n    buf_T\t*buf;\n\n    // Start at the last buffer, expect to find a match sooner.\n    FOR_ALL_BUFS_FROM_LAST(buf)\n\tif ((buf->b_flags & BF_DUMMY) == 0 && !otherfile_buf(buf, ffname\n#ifdef UNIX\n\t\t    , stp\n#endif\n\t\t    ))\n\t    return buf;\n    return NULL;\n}\n\n/*\n * Find file in buffer list by a regexp pattern.\n * Return fnum of the found buffer.\n * Return < 0 for error.\n */\n    int\nbuflist_findpat(\n    char_u\t*pattern,\n    char_u\t*pattern_end,\t// pointer to first char after pattern\n    int\t\tunlisted,\t// find unlisted buffers\n    int\t\tdiffmode UNUSED, // find diff-mode buffers only\n    int\t\tcurtab_only)\t// find buffers in current tab only\n{\n    buf_T\t*buf;\n    int\t\tmatch = -1;\n    int\t\tfind_listed;\n    char_u\t*pat;\n    char_u\t*patend;\n    int\t\tattempt;\n    char_u\t*p;\n    int\t\ttoggledollar;\n\n    // \"%\" is current file, \"%%\" or \"#\" is alternate file\n    if ((pattern_end == pattern + 1 && (*pattern == '%' || *pattern == '#'))\n\t    || (in_vim9script() && pattern_end == pattern + 2\n\t\t\t\t    && pattern[0] == '%' && pattern[1] == '%'))\n    {\n\tif (*pattern == '#' || pattern_end == pattern + 2)\n\t    match = curwin->w_alt_fnum;\n\telse\n\t    match = curbuf->b_fnum;\n#ifdef FEAT_DIFF\n\tif (diffmode && !diff_mode_buf(buflist_findnr(match)))\n\t    match = -1;\n#endif\n    }\n\n    /*\n     * Try four ways of matching a listed buffer:\n     * attempt == 0: without '^' or '$' (at any position)\n     * attempt == 1: with '^' at start (only at position 0)\n     * attempt == 2: with '$' at end (only match at end)\n     * attempt == 3: with '^' at start and '$' at end (only full match)\n     * Repeat this for finding an unlisted buffer if there was no matching\n     * listed buffer.\n     */\n    else\n    {\n\tpat = file_pat_to_reg_pat(pattern, pattern_end, NULL, FALSE);\n\tif (pat == NULL)\n\t    return -1;\n\tpatend = pat + STRLEN(pat) - 1;\n\ttoggledollar = (patend > pat && *patend == '$');\n\n\t// First try finding a listed buffer.  If not found and \"unlisted\"\n\t// is TRUE, try finding an unlisted buffer.\n\tfind_listed = TRUE;\n\tfor (;;)\n\t{\n\t    for (attempt = 0; attempt <= 3; ++attempt)\n\t    {\n\t\tregmatch_T\tregmatch;\n\n\t\t// may add '^' and '$'\n\t\tif (toggledollar)\n\t\t    *patend = (attempt < 2) ? NUL : '$'; // add/remove '$'\n\t\tp = pat;\n\t\tif (*p == '^' && !(attempt & 1))\t // add/remove '^'\n\t\t    ++p;\n\t\tregmatch.regprog = vim_regcomp(p, magic_isset() ? RE_MAGIC : 0);\n\n\t\tFOR_ALL_BUFS_FROM_LAST(buf)\n\t\t{\n\t\t    if (regmatch.regprog == NULL)\n\t\t    {\n\t\t\t// invalid pattern, possibly after switching engine\n\t\t\tvim_free(pat);\n\t\t\treturn -1;\n\t\t    }\n\t\t    if (buf->b_p_bl == find_listed\n#ifdef FEAT_DIFF\n\t\t\t    && (!diffmode || diff_mode_buf(buf))\n#endif\n\t\t\t    && buflist_match(&regmatch, buf, FALSE) != NULL)\n\t\t    {\n\t\t\tif (curtab_only)\n\t\t\t{\n\t\t\t    // Ignore the match if the buffer is not open in\n\t\t\t    // the current tab.\n\t\t\t    win_T\t*wp;\n\n\t\t\t    FOR_ALL_WINDOWS(wp)\n\t\t\t\tif (wp->w_buffer == buf)\n\t\t\t\t    break;\n\t\t\t    if (wp == NULL)\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (match >= 0)\t\t// already found a match\n\t\t\t{\n\t\t\t    match = -2;\n\t\t\t    break;\n\t\t\t}\n\t\t\tmatch = buf->b_fnum;\t// remember first match\n\t\t    }\n\t\t}\n\n\t\tvim_regfree(regmatch.regprog);\n\t\tif (match >= 0)\t\t\t// found one match\n\t\t    break;\n\t    }\n\n\t    // Only search for unlisted buffers if there was no match with\n\t    // a listed buffer.\n\t    if (!unlisted || !find_listed || match != -1)\n\t\tbreak;\n\t    find_listed = FALSE;\n\t}\n\n\tvim_free(pat);\n    }\n\n    if (match == -2)\n\tsemsg(_(e_more_than_one_match_for_str), pattern);\n    else if (match < 0)\n\tsemsg(_(e_no_matching_buffer_for_str), pattern);\n    return match;\n}\n\n#ifdef FEAT_VIMINFO\ntypedef struct {\n    buf_T   *buf;\n    char_u  *match;\n} bufmatch_T;\n#endif\n\n/*\n * Find all buffer names that match.\n * For command line expansion of \":buf\" and \":sbuf\".\n * Return OK if matches found, FAIL otherwise.\n */\n    int\nExpandBufnames(\n    char_u\t*pat,\n    int\t\t*num_file,\n    char_u\t***file,\n    int\t\toptions)\n{\n    int\t\tcount = 0;\n    buf_T\t*buf;\n    int\t\tround;\n    char_u\t*p;\n    int\t\tattempt;\n    char_u\t*patc = NULL;\n#ifdef FEAT_VIMINFO\n    bufmatch_T\t*matches = NULL;\n#endif\n    int\t\tfuzzy;\n    fuzmatch_str_T  *fuzmatch = NULL;\n\n    *num_file = 0;\t\t    // return values in case of FAIL\n    *file = NULL;\n\n#ifdef FEAT_DIFF\n    if ((options & BUF_DIFF_FILTER) && !curwin->w_p_diff)\n\treturn FAIL;\n#endif\n\n    fuzzy = cmdline_fuzzy_complete(pat);\n\n    // Make a copy of \"pat\" and change \"^\" to \"\\(^\\|[\\/]\\)\" (if doing regular\n    // expression matching)\n    if (!fuzzy)\n    {\n\tif (*pat == '^')\n\t{\n\t    patc = alloc(STRLEN(pat) + 11);\n\t    if (patc == NULL)\n\t\treturn FAIL;\n\t    STRCPY(patc, \"\\\\(^\\\\|[\\\\/]\\\\)\");\n\t    STRCPY(patc + 11, pat + 1);\n\t}\n\telse\n\t    patc = pat;\n    }\n\n    // attempt == 0: try match with    '\\<', match at start of word\n    // attempt == 1: try match without '\\<', match anywhere\n    for (attempt = 0; attempt <= (fuzzy ? 0 : 1); ++attempt)\n    {\n\tregmatch_T\tregmatch;\n\tint\t\tscore = 0;\n\n\tif (!fuzzy)\n\t{\n\t    if (attempt > 0 && patc == pat)\n\t\tbreak;\t// there was no anchor, no need to try again\n\t    regmatch.regprog = vim_regcomp(patc + attempt * 11, RE_MAGIC);\n\t}\n\n\t// round == 1: Count the matches.\n\t// round == 2: Build the array to keep the matches.\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    count = 0;\n\t    FOR_ALL_BUFFERS(buf)\n\t    {\n\t\tif (!buf->b_p_bl)\t// skip unlisted buffers\n\t\t    continue;\n#ifdef FEAT_DIFF\n\t\tif (options & BUF_DIFF_FILTER)\n\t\t    // Skip buffers not suitable for\n\t\t    // :diffget or :diffput completion.\n\t\t    if (buf == curbuf || !diff_mode_buf(buf))\n\t\t\tcontinue;\n#endif\n\n\t\tif (!fuzzy)\n\t\t{\n\t\t    if (regmatch.regprog == NULL)\n\t\t    {\n\t\t\t// invalid pattern, possibly after recompiling\n\t\t\tif (patc != pat)\n\t\t\t    vim_free(patc);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    p = buflist_match(&regmatch, buf, p_wic);\n\t\t}\n\t\telse\n\t\t{\n\t\t    p = NULL;\n\t\t    // first try matching with the short file name\n\t\t    if ((score = fuzzy_match_str(buf->b_sfname, pat)) != 0)\n\t\t\tp = buf->b_sfname;\n\t\t    if (p == NULL)\n\t\t    {\n\t\t\t// next try matching with the full path file name\n\t\t\tif ((score = fuzzy_match_str(buf->b_ffname, pat)) != 0)\n\t\t\t    p = buf->b_ffname;\n\t\t    }\n\t\t}\n\n\t\tif (p == NULL)\n\t\t    continue;\n\n\t\tif (round == 1)\n\t\t{\n\t\t    ++count;\n\t\t    continue;\n\t\t}\n\n\t\tif (options & WILD_HOME_REPLACE)\n\t\t    p = home_replace_save(buf, p);\n\t\telse\n\t\t    p = vim_strsave(p);\n\n\t\tif (!fuzzy)\n\t\t{\n#ifdef FEAT_VIMINFO\n\t\t    if (matches != NULL)\n\t\t    {\n\t\t\tmatches[count].buf = buf;\n\t\t\tmatches[count].match = p;\n\t\t\tcount++;\n\t\t    }\n\t\t    else\n#endif\n\t\t\t(*file)[count++] = p;\n\t\t}\n\t\telse\n\t\t{\n\t\t    fuzmatch[count].idx = count;\n\t\t    fuzmatch[count].str = p;\n\t\t    fuzmatch[count].score = score;\n\t\t    count++;\n\t\t}\n\t    }\n\t    if (count == 0)\t// no match found, break here\n\t\tbreak;\n\t    if (round == 1)\n\t    {\n\t\tif (!fuzzy)\n\t\t{\n\t\t    *file = ALLOC_MULT(char_u *, count);\n\t\t    if (*file == NULL)\n\t\t    {\n\t\t\tvim_regfree(regmatch.regprog);\n\t\t\tif (patc != pat)\n\t\t\t    vim_free(patc);\n\t\t\treturn FAIL;\n\t\t    }\n#ifdef FEAT_VIMINFO\n\t\t    if (options & WILD_BUFLASTUSED)\n\t\t\tmatches = ALLOC_MULT(bufmatch_T, count);\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    fuzmatch = ALLOC_MULT(fuzmatch_str_T, count);\n\t\t    if (fuzmatch == NULL)\n\t\t    {\n\t\t\t*num_file = 0;\n\t\t\t*file = NULL;\n\t\t\treturn FAIL;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tif (!fuzzy)\n\t{\n\t    vim_regfree(regmatch.regprog);\n\t    if (count)\t\t// match(es) found, break here\n\t\tbreak;\n\t}\n    }\n\n    if (!fuzzy && patc != pat)\n\tvim_free(patc);\n\n#ifdef FEAT_VIMINFO\n    if (!fuzzy)\n    {\n\tif (matches != NULL)\n\t{\n\t    int i;\n\t    if (count > 1)\n\t\tqsort(matches, count, sizeof(bufmatch_T), buf_compare);\n\t    // if the current buffer is first in the list, place it at the end\n\t    if (matches[0].buf == curbuf)\n\t    {\n\t\tfor (i = 1; i < count; i++)\n\t\t    (*file)[i-1] = matches[i].match;\n\t\t(*file)[count-1] = matches[0].match;\n\t    }\n\t    else\n\t    {\n\t\tfor (i = 0; i < count; i++)\n\t\t    (*file)[i] = matches[i].match;\n\t    }\n\t    vim_free(matches);\n\t}\n    }\n    else\n    {\n\tif (fuzzymatches_to_strmatches(fuzmatch, file, count, FALSE) == FAIL)\n\t    return FAIL;\n    }\n#endif\n\n    *num_file = count;\n    return (count == 0 ? FAIL : OK);\n}\n\n/*\n * Check for a match on the file name for buffer \"buf\" with regprog \"prog\".\n * Note that rmp->regprog may become NULL when switching regexp engine.\n */\n    static char_u *\nbuflist_match(\n    regmatch_T\t*rmp,\n    buf_T\t*buf,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match;\n\n    // First try the short file name, then the long file name.\n    match = fname_match(rmp, buf->b_sfname, ignore_case);\n    if (match == NULL && rmp->regprog != NULL)\n\tmatch = fname_match(rmp, buf->b_ffname, ignore_case);\n\n    return match;\n}\n\n/*\n * Try matching the regexp in \"rmp->regprog\" with file name \"name\".\n * Note that rmp->regprog may become NULL when switching regexp engine.\n * Return \"name\" when there is a match, NULL when not.\n */\n    static char_u *\nfname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    // extra check for valid arguments\n    if (name != NULL && rmp->regprog != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse if (rmp->regprog != NULL)\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}\n\n/*\n * Find a file in the buffer list by buffer number.\n */\n    buf_T *\nbuflist_findnr(int nr)\n{\n    char_u\tkey[VIM_SIZEOF_INT * 2 + 1];\n    hashitem_T\t*hi;\n\n    if (nr == 0)\n\tnr = curwin->w_alt_fnum;\n    sprintf((char *)key, \"%x\", nr);\n    hi = hash_find(&buf_hashtab, key);\n\n    if (!HASHITEM_EMPTY(hi))\n\treturn (buf_T *)(hi->hi_key\n\t\t\t     - ((unsigned)(curbuf->b_key - (char_u *)curbuf)));\n    return NULL;\n}\n\n/*\n * Get name of file 'n' in the buffer list.\n * When the file has no name an empty string is returned.\n * home_replace() is used to shorten the file name (used for marks).\n * Returns a pointer to allocated memory, of NULL when failed.\n */\n    char_u *\nbuflist_nr2name(\n    int\t\tn,\n    int\t\tfullname,\n    int\t\thelptail)\t// for help buffers return tail only\n{\n    buf_T\t*buf;\n\n    buf = buflist_findnr(n);\n    if (buf == NULL)\n\treturn NULL;\n    return home_replace_save(helptail ? buf : NULL,\n\t\t\t\t     fullname ? buf->b_ffname : buf->b_fname);\n}\n\n/*\n * Set the \"lnum\" and \"col\" for the buffer \"buf\" and the current window.\n * When \"copy_options\" is TRUE save the local window option values.\n * When \"lnum\" is 0 only do the options.\n */\n    void\nbuflist_setfpos(\n    buf_T\t*buf,\n    win_T\t*win,\t\t// may be NULL when using :badd\n    linenr_T\tlnum,\n    colnr_T\tcol,\n    int\t\tcopy_options)\n{\n    wininfo_T\t*wip;\n\n    FOR_ALL_BUF_WININFO(buf, wip)\n\tif (wip->wi_win == win)\n\t    break;\n    if (wip == NULL)\n    {\n\t// allocate a new entry\n\twip = ALLOC_CLEAR_ONE(wininfo_T);\n\tif (wip == NULL)\n\t    return;\n\twip->wi_win = win;\n\tif (lnum == 0)\t\t// set lnum even when it's 0\n\t    lnum = 1;\n    }\n    else\n    {\n\t// remove the entry from the list\n\tif (wip->wi_prev)\n\t    wip->wi_prev->wi_next = wip->wi_next;\n\telse\n\t    buf->b_wininfo = wip->wi_next;\n\tif (wip->wi_next)\n\t    wip->wi_next->wi_prev = wip->wi_prev;\n\tif (copy_options && wip->wi_optset)\n\t{\n\t    clear_winopt(&wip->wi_opt);\n#ifdef FEAT_FOLDING\n\t    deleteFoldRecurse(&wip->wi_folds);\n#endif\n\t}\n    }\n    if (lnum != 0)\n    {\n\twip->wi_fpos.lnum = lnum;\n\twip->wi_fpos.col = col;\n    }\n    if (win != NULL)\n\twip->wi_changelistidx = win->w_changelistidx;\n    if (copy_options && win != NULL)\n    {\n\t// Save the window-specific option values.\n\tcopy_winopt(&win->w_onebuf_opt, &wip->wi_opt);\n#ifdef FEAT_FOLDING\n\twip->wi_fold_manual = win->w_fold_manual;\n\tcloneFoldGrowArray(&win->w_folds, &wip->wi_folds);\n#endif\n\twip->wi_optset = TRUE;\n    }\n\n    // insert the entry in front of the list\n    wip->wi_next = buf->b_wininfo;\n    buf->b_wininfo = wip;\n    wip->wi_prev = NULL;\n    if (wip->wi_next)\n\twip->wi_next->wi_prev = wip;\n}\n\n#ifdef FEAT_DIFF\n/*\n * Return TRUE when \"wip\" has 'diff' set and the diff is only for another tab\n * page.  That's because a diff is local to a tab page.\n */\n    static int\nwininfo_other_tab_diff(wininfo_T *wip)\n{\n    win_T\t*wp;\n\n    if (wip->wi_opt.wo_diff)\n    {\n\tFOR_ALL_WINDOWS(wp)\n\t    // return FALSE when it's a window in the current tab page, thus\n\t    // the buffer was in diff mode here\n\t    if (wip->wi_win == wp)\n\t\treturn FALSE;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n#endif\n\n/*\n * Find info for the current window in buffer \"buf\".\n * If not found, return the info for the most recently used window.\n * When \"need_options\" is TRUE skip entries where wi_optset is FALSE.\n * When \"skip_diff_buffer\" is TRUE avoid windows with 'diff' set that is in\n * another tab page.\n * Returns NULL when there isn't any info.\n */\n    static wininfo_T *\nfind_wininfo(\n    buf_T\t*buf,\n    int\t\tneed_options,\n    int\t\tskip_diff_buffer UNUSED)\n{\n    wininfo_T\t*wip;\n\n    FOR_ALL_BUF_WININFO(buf, wip)\n\tif (wip->wi_win == curwin\n#ifdef FEAT_DIFF\n\t\t&& (!skip_diff_buffer || !wininfo_other_tab_diff(wip))\n#endif\n\n\t\t&& (!need_options || wip->wi_optset))\n\t    break;\n\n    // If no wininfo for curwin, use the first in the list (that doesn't have\n    // 'diff' set and is in another tab page).\n    // If \"need_options\" is TRUE skip entries that don't have options set,\n    // unless the window is editing \"buf\", so we can copy from the window\n    // itself.\n    if (wip == NULL)\n    {\n#ifdef FEAT_DIFF\n\tif (skip_diff_buffer)\n\t{\n\t    FOR_ALL_BUF_WININFO(buf, wip)\n\t\tif (!wininfo_other_tab_diff(wip)\n\t\t\t&& (!need_options || wip->wi_optset\n\t\t\t    || (wip->wi_win != NULL\n\t\t\t\t\t     && wip->wi_win->w_buffer == buf)))\n\t\t    break;\n\t}\n\telse\n#endif\n\t    wip = buf->b_wininfo;\n    }\n    return wip;\n}\n\n/*\n * Reset the local window options to the values last used in this window.\n * If the buffer wasn't used in this window before, use the values from\n * the most recently used window.  If the values were never set, use the\n * global values for the window.\n */\n    void\nget_winopts(buf_T *buf)\n{\n    wininfo_T\t*wip;\n\n    clear_winopt(&curwin->w_onebuf_opt);\n#ifdef FEAT_FOLDING\n    clearFolding(curwin);\n#endif\n\n    wip = find_wininfo(buf, TRUE, TRUE);\n    if (wip != NULL && wip->wi_win != NULL\n\t    && wip->wi_win != curwin && wip->wi_win->w_buffer == buf)\n    {\n\t// The buffer is currently displayed in the window: use the actual\n\t// option values instead of the saved (possibly outdated) values.\n\twin_T *wp = wip->wi_win;\n\n\tcopy_winopt(&wp->w_onebuf_opt, &curwin->w_onebuf_opt);\n#ifdef FEAT_FOLDING\n\tcurwin->w_fold_manual = wp->w_fold_manual;\n\tcurwin->w_foldinvalid = TRUE;\n\tcloneFoldGrowArray(&wp->w_folds, &curwin->w_folds);\n#endif\n    }\n    else if (wip != NULL && wip->wi_optset)\n    {\n\t// the buffer was displayed in the current window earlier\n\tcopy_winopt(&wip->wi_opt, &curwin->w_onebuf_opt);\n#ifdef FEAT_FOLDING\n\tcurwin->w_fold_manual = wip->wi_fold_manual;\n\tcurwin->w_foldinvalid = TRUE;\n\tcloneFoldGrowArray(&wip->wi_folds, &curwin->w_folds);\n#endif\n    }\n    else\n\tcopy_winopt(&curwin->w_allbuf_opt, &curwin->w_onebuf_opt);\n    if (wip != NULL)\n\tcurwin->w_changelistidx = wip->wi_changelistidx;\n\n#ifdef FEAT_FOLDING\n    // Set 'foldlevel' to 'foldlevelstart' if it's not negative.\n    if (p_fdls >= 0)\n\tcurwin->w_p_fdl = p_fdls;\n#endif\n    after_copy_winopt(curwin);\n}\n\n/*\n * Find the position (lnum and col) for the buffer 'buf' for the current\n * window.\n * Returns a pointer to no_position if no position is found.\n */\n    pos_T *\nbuflist_findfpos(buf_T *buf)\n{\n    wininfo_T\t*wip;\n    static pos_T no_position = {1, 0, 0};\n\n    wip = find_wininfo(buf, FALSE, FALSE);\n    if (wip != NULL)\n\treturn &(wip->wi_fpos);\n    else\n\treturn &no_position;\n}\n\n/*\n * Find the lnum for the buffer 'buf' for the current window.\n */\n    linenr_T\nbuflist_findlnum(buf_T *buf)\n{\n    return buflist_findfpos(buf)->lnum;\n}\n\n/*\n * List all known file names (for :files and :buffers command).\n */\n    void\nbuflist_list(exarg_T *eap)\n{\n    buf_T\t*buf = firstbuf;\n    int\t\tlen;\n    int\t\ti;\n    int\t\tro_char;\n    int\t\tchanged_char;\n#ifdef FEAT_TERMINAL\n    int\t\tjob_running;\n    int\t\tjob_none_open;\n#endif\n\n#ifdef FEAT_VIMINFO\n    garray_T\tbuflist;\n    buf_T\t**buflist_data = NULL, **p;\n\n    if (vim_strchr(eap->arg, 't'))\n    {\n\tga_init2(&buflist, sizeof(buf_T *), 50);\n\tFOR_ALL_BUFFERS(buf)\n\t{\n\t    if (ga_grow(&buflist, 1) == OK)\n\t\t((buf_T **)buflist.ga_data)[buflist.ga_len++] = buf;\n\t}\n\n\tqsort(buflist.ga_data, (size_t)buflist.ga_len,\n\t\tsizeof(buf_T *), buf_compare);\n\n\tbuflist_data = (buf_T **)buflist.ga_data;\n\tbuf = *buflist_data;\n    }\n    p = buflist_data;\n\n    for (; buf != NULL && !got_int; buf = buflist_data != NULL\n\t    ? (++p < buflist_data + buflist.ga_len ? *p : NULL)\n\t    : buf->b_next)\n#else\n    for (buf = firstbuf; buf != NULL && !got_int; buf = buf->b_next)\n#endif\n    {\n#ifdef FEAT_TERMINAL\n\tjob_running = term_job_running(buf->b_term);\n\tjob_none_open = term_none_open(buf->b_term);\n#endif\n\t// skip unlisted buffers, unless ! was used\n\tif ((!buf->b_p_bl && !eap->forceit && !vim_strchr(eap->arg, 'u'))\n\t\t|| (vim_strchr(eap->arg, 'u') && buf->b_p_bl)\n\t\t|| (vim_strchr(eap->arg, '+')\n\t\t\t&& ((buf->b_flags & BF_READERR) || !bufIsChanged(buf)))\n\t\t|| (vim_strchr(eap->arg, 'a')\n\t\t\t&& (buf->b_ml.ml_mfp == NULL || buf->b_nwindows == 0))\n\t\t|| (vim_strchr(eap->arg, 'h')\n\t\t\t&& (buf->b_ml.ml_mfp == NULL || buf->b_nwindows != 0))\n#ifdef FEAT_TERMINAL\n\t\t|| (vim_strchr(eap->arg, 'R')\n\t\t\t&& (!job_running || (job_running && job_none_open)))\n\t\t|| (vim_strchr(eap->arg, '?')\n\t\t\t&& (!job_running || (job_running && !job_none_open)))\n\t\t|| (vim_strchr(eap->arg, 'F')\n\t\t\t&& (job_running || buf->b_term == NULL))\n#endif\n\t\t|| (vim_strchr(eap->arg, '-') && buf->b_p_ma)\n\t\t|| (vim_strchr(eap->arg, '=') && !buf->b_p_ro)\n\t\t|| (vim_strchr(eap->arg, 'x') && !(buf->b_flags & BF_READERR))\n\t\t|| (vim_strchr(eap->arg, '%') && buf != curbuf)\n\t\t|| (vim_strchr(eap->arg, '#')\n\t\t      && (buf == curbuf || curwin->w_alt_fnum != buf->b_fnum)))\n\t    continue;\n\tif (buf_spname(buf) != NULL)\n\t    vim_strncpy(NameBuff, buf_spname(buf), MAXPATHL - 1);\n\telse\n\t    home_replace(buf, buf->b_fname, NameBuff, MAXPATHL, TRUE);\n\tif (message_filtered(NameBuff))\n\t    continue;\n\n\tchanged_char = (buf->b_flags & BF_READERR) ? 'x'\n\t\t\t\t\t     : (bufIsChanged(buf) ? '+' : ' ');\n#ifdef FEAT_TERMINAL\n\tif (job_running)\n\t{\n\t    if (job_none_open)\n\t\tro_char = '?';\n\t    else\n\t\tro_char = 'R';\n\t    changed_char = ' ';  // bufIsChanged() returns TRUE to avoid\n\t\t\t\t // closing, but it's not actually changed.\n\t}\n\telse if (buf->b_term != NULL)\n\t    ro_char = 'F';\n\telse\n#endif\n\t    ro_char = !buf->b_p_ma ? '-' : (buf->b_p_ro ? '=' : ' ');\n\n\tmsg_putchar('\\n');\n\tlen = vim_snprintf((char *)IObuff, IOSIZE - 20, \"%3d%c%c%c%c%c \\\"%s\\\"\",\n\t\tbuf->b_fnum,\n\t\tbuf->b_p_bl ? ' ' : 'u',\n\t\tbuf == curbuf ? '%' :\n\t\t\t(curwin->w_alt_fnum == buf->b_fnum ? '#' : ' '),\n\t\tbuf->b_ml.ml_mfp == NULL ? ' ' :\n\t\t\t(buf->b_nwindows == 0 ? 'h' : 'a'),\n\t\tro_char,\n\t\tchanged_char,\n\t\tNameBuff);\n\tif (len > IOSIZE - 20)\n\t    len = IOSIZE - 20;\n\n\t// put \"line 999\" in column 40 or after the file name\n\ti = 40 - vim_strsize(IObuff);\n\tdo\n\t    IObuff[len++] = ' ';\n\twhile (--i > 0 && len < IOSIZE - 18);\n#ifdef FEAT_VIMINFO\n\tif (vim_strchr(eap->arg, 't') && buf->b_last_used)\n\t    add_time(IObuff + len, (size_t)(IOSIZE - len), buf->b_last_used);\n\telse\n#endif\n\t    vim_snprintf((char *)IObuff + len, (size_t)(IOSIZE - len),\n\t\t    _(\"line %ld\"), buf == curbuf ? curwin->w_cursor.lnum\n\t\t\t\t\t       : (long)buflist_findlnum(buf));\n\tmsg_outtrans(IObuff);\n\tout_flush();\t    // output one line at a time\n\tui_breakcheck();\n    }\n\n#ifdef FEAT_VIMINFO\n    if (buflist_data)\n\tga_clear(&buflist);\n#endif\n}\n\n/*\n * Get file name and line number for file 'fnum'.\n * Used by DoOneCmd() for translating '%' and '#'.\n * Used by insert_reg() and cmdline_paste() for '#' register.\n * Return FAIL if not found, OK for success.\n */\n    int\nbuflist_name_nr(\n    int\t\tfnum,\n    char_u\t**fname,\n    linenr_T\t*lnum)\n{\n    buf_T\t*buf;\n\n    buf = buflist_findnr(fnum);\n    if (buf == NULL || buf->b_fname == NULL)\n\treturn FAIL;\n\n    *fname = buf->b_fname;\n    *lnum = buflist_findlnum(buf);\n\n    return OK;\n}\n\n/*\n * Set the file name for \"buf\"' to \"ffname_arg\", short file name to\n * \"sfname_arg\".\n * The file name with the full path is also remembered, for when :cd is used.\n * Returns FAIL for failure (file name already in use by other buffer)\n *\tOK otherwise.\n */\n    int\nsetfname(\n    buf_T\t*buf,\n    char_u\t*ffname_arg,\n    char_u\t*sfname_arg,\n    int\t\tmessage)\t// give message when buffer already exists\n{\n    char_u\t*ffname = ffname_arg;\n    char_u\t*sfname = sfname_arg;\n    buf_T\t*obuf = NULL;\n#ifdef UNIX\n    stat_T\tst;\n#endif\n\n    if (ffname == NULL || *ffname == NUL)\n    {\n\t// Removing the name.\n\tif (buf->b_sfname != buf->b_ffname)\n\t    VIM_CLEAR(buf->b_sfname);\n\telse\n\t    buf->b_sfname = NULL;\n\tVIM_CLEAR(buf->b_ffname);\n#ifdef UNIX\n\tst.st_dev = (dev_T)-1;\n#endif\n    }\n    else\n    {\n\tfname_expand(buf, &ffname, &sfname); // will allocate ffname\n\tif (ffname == NULL)\t\t    // out of memory\n\t    return FAIL;\n\n\t/*\n\t * If the file name is already used in another buffer:\n\t * - if the buffer is loaded, fail\n\t * - if the buffer is not loaded, delete it from the list\n\t */\n#ifdef UNIX\n\tif (mch_stat((char *)ffname, &st) < 0)\n\t    st.st_dev = (dev_T)-1;\n#endif\n\tif (!(buf->b_flags & BF_DUMMY))\n#ifdef UNIX\n\t    obuf = buflist_findname_stat(ffname, &st);\n#else\n\t    obuf = buflist_findname(ffname);\n#endif\n\tif (obuf != NULL && obuf != buf)\n\t{\n\t    win_T\t*win;\n\t    tabpage_T   *tab;\n\t    int\t\tin_use = FALSE;\n\n\t    // during startup a window may use a buffer that is not loaded yet\n\t    FOR_ALL_TAB_WINDOWS(tab, win)\n\t\tif (win->w_buffer == obuf)\n\t\t    in_use = TRUE;\n\n\t    // it's loaded or used in a window, fail\n\t    if (obuf->b_ml.ml_mfp != NULL || in_use)\n\t    {\n\t\tif (message)\n\t\t    emsg(_(e_buffer_with_this_name_already_exists));\n\t\tvim_free(ffname);\n\t\treturn FAIL;\n\t    }\n\t    // delete from the list\n\t    close_buffer(NULL, obuf, DOBUF_WIPE, FALSE, FALSE);\n\t}\n\tsfname = vim_strsave(sfname);\n\tif (ffname == NULL || sfname == NULL)\n\t{\n\t    vim_free(sfname);\n\t    vim_free(ffname);\n\t    return FAIL;\n\t}\n#ifdef USE_FNAME_CASE\n\tfname_case(sfname, 0);    // set correct case for short file name\n#endif\n\tif (buf->b_sfname != buf->b_ffname)\n\t    vim_free(buf->b_sfname);\n\tvim_free(buf->b_ffname);\n\tbuf->b_ffname = ffname;\n\tbuf->b_sfname = sfname;\n    }\n    buf->b_fname = buf->b_sfname;\n#ifdef UNIX\n    if (st.st_dev == (dev_T)-1)\n\tbuf->b_dev_valid = FALSE;\n    else\n    {\n\tbuf->b_dev_valid = TRUE;\n\tbuf->b_dev = st.st_dev;\n\tbuf->b_ino = st.st_ino;\n    }\n#endif\n\n    buf->b_shortname = FALSE;\n\n    buf_name_changed(buf);\n    return OK;\n}\n\n/*\n * Crude way of changing the name of a buffer.  Use with care!\n * The name should be relative to the current directory.\n */\n    void\nbuf_set_name(int fnum, char_u *name)\n{\n    buf_T\t*buf;\n\n    buf = buflist_findnr(fnum);\n    if (buf != NULL)\n    {\n\tif (buf->b_sfname != buf->b_ffname)\n\t    vim_free(buf->b_sfname);\n\tvim_free(buf->b_ffname);\n\tbuf->b_ffname = vim_strsave(name);\n\tbuf->b_sfname = NULL;\n\t// Allocate ffname and expand into full path.  Also resolves .lnk\n\t// files on Win32.\n\tfname_expand(buf, &buf->b_ffname, &buf->b_sfname);\n\tbuf->b_fname = buf->b_sfname;\n    }\n}\n\n/*\n * Take care of what needs to be done when the name of buffer \"buf\" has\n * changed.\n */\n    void\nbuf_name_changed(buf_T *buf)\n{\n    /*\n     * If the file name changed, also change the name of the swapfile\n     */\n    if (buf->b_ml.ml_mfp != NULL)\n\tml_setname(buf);\n\n#ifdef FEAT_TERMINAL\n    if (buf->b_term != NULL)\n\tterm_clear_status_text(buf->b_term);\n#endif\n\n    if (curwin->w_buffer == buf)\n\tcheck_arg_idx(curwin);\t// check file name for arg list\n    maketitle();\t\t// set window title\n    status_redraw_all();\t// status lines need to be redrawn\n    fmarks_check_names(buf);\t// check named file marks\n    ml_timestamp(buf);\t\t// reset timestamp\n}\n\n/*\n * set alternate file name for current window\n *\n * Used by do_one_cmd(), do_write() and do_ecmd().\n * Return the buffer.\n */\n    buf_T *\nsetaltfname(\n    char_u\t*ffname,\n    char_u\t*sfname,\n    linenr_T\tlnum)\n{\n    buf_T\t*buf;\n\n    // Create a buffer.  'buflisted' is not set if it's a new buffer\n    buf = buflist_new(ffname, sfname, lnum, 0);\n    if (buf != NULL && (cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\tcurwin->w_alt_fnum = buf->b_fnum;\n    return buf;\n}\n\n/*\n * Get alternate file name for current window.\n * Return NULL if there isn't any, and give error message if requested.\n */\n    char_u  *\ngetaltfname(\n    int\t\terrmsg)\t\t// give error message\n{\n    char_u\t*fname;\n    linenr_T\tdummy;\n\n    if (buflist_name_nr(0, &fname, &dummy) == FAIL)\n    {\n\tif (errmsg)\n\t    emsg(_(e_no_alternate_file));\n\treturn NULL;\n    }\n    return fname;\n}\n\n/*\n * Add a file name to the buflist and return its number.\n * Uses same flags as buflist_new(), except BLN_DUMMY.\n *\n * used by qf_init(), main() and doarglist()\n */\n    int\nbuflist_add(char_u *fname, int flags)\n{\n    buf_T\t*buf;\n\n    buf = buflist_new(fname, NULL, (linenr_T)0, flags);\n    if (buf != NULL)\n\treturn buf->b_fnum;\n    return 0;\n}\n\n#if defined(BACKSLASH_IN_FILENAME) || defined(PROTO)\n/*\n * Adjust slashes in file names.  Called after 'shellslash' was set.\n */\n    void\nbuflist_slash_adjust(void)\n{\n    buf_T\t*bp;\n\n    FOR_ALL_BUFFERS(bp)\n    {\n\tif (bp->b_ffname != NULL)\n\t    slash_adjust(bp->b_ffname);\n\tif (bp->b_sfname != NULL)\n\t    slash_adjust(bp->b_sfname);\n    }\n}\n#endif\n\n/*\n * Set alternate cursor position for the current buffer and window \"win\".\n * Also save the local window option values.\n */\n    void\nbuflist_altfpos(win_T *win)\n{\n    buflist_setfpos(curbuf, win, win->w_cursor.lnum, win->w_cursor.col, TRUE);\n}\n\n/*\n * Return TRUE if 'ffname' is not the same file as current file.\n * Fname must have a full path (expanded by mch_FullName()).\n */\n    int\notherfile(char_u *ffname)\n{\n    return otherfile_buf(curbuf, ffname\n#ifdef UNIX\n\t    , NULL\n#endif\n\t    );\n}\n\n    static int\notherfile_buf(\n    buf_T\t\t*buf,\n    char_u\t\t*ffname\n#ifdef UNIX\n    , stat_T\t\t*stp\n#endif\n    )\n{\n    // no name is different\n    if (ffname == NULL || *ffname == NUL || buf->b_ffname == NULL)\n\treturn TRUE;\n    if (fnamecmp(ffname, buf->b_ffname) == 0)\n\treturn FALSE;\n#ifdef UNIX\n    {\n\tstat_T\t    st;\n\n\t// If no stat_T given, get it now\n\tif (stp == NULL)\n\t{\n\t    if (!buf->b_dev_valid || mch_stat((char *)ffname, &st) < 0)\n\t\tst.st_dev = (dev_T)-1;\n\t    stp = &st;\n\t}\n\t// Use dev/ino to check if the files are the same, even when the names\n\t// are different (possible with links).  Still need to compare the\n\t// name above, for when the file doesn't exist yet.\n\t// Problem: The dev/ino changes when a file is deleted (and created\n\t// again) and remains the same when renamed/moved.  We don't want to\n\t// mch_stat() each buffer each time, that would be too slow.  Get the\n\t// dev/ino again when they appear to match, but not when they appear\n\t// to be different: Could skip a buffer when it's actually the same\n\t// file.\n\tif (buf_same_ino(buf, stp))\n\t{\n\t    buf_setino(buf);\n\t    if (buf_same_ino(buf, stp))\n\t\treturn FALSE;\n\t}\n    }\n#endif\n    return TRUE;\n}\n\n#if defined(UNIX) || defined(PROTO)\n/*\n * Set inode and device number for a buffer.\n * Must always be called when b_fname is changed!.\n */\n    void\nbuf_setino(buf_T *buf)\n{\n    stat_T\tst;\n\n    if (buf->b_fname != NULL && mch_stat((char *)buf->b_fname, &st) >= 0)\n    {\n\tbuf->b_dev_valid = TRUE;\n\tbuf->b_dev = st.st_dev;\n\tbuf->b_ino = st.st_ino;\n    }\n    else\n\tbuf->b_dev_valid = FALSE;\n}\n\n/*\n * Return TRUE if dev/ino in buffer \"buf\" matches with \"stp\".\n */\n    static int\nbuf_same_ino(\n    buf_T\t*buf,\n    stat_T\t*stp)\n{\n    return (buf->b_dev_valid\n\t    && stp->st_dev == buf->b_dev\n\t    && stp->st_ino == buf->b_ino);\n}\n#endif\n\n/*\n * Print info about the current buffer.\n */\n    void\nfileinfo(\n    int fullname,\t    // when non-zero print full path\n    int shorthelp,\n    int\tdont_truncate)\n{\n    char_u\t*name;\n    int\t\tn;\n    char\t*p;\n    char\t*buffer;\n    size_t\tlen;\n\n    buffer = alloc(IOSIZE);\n    if (buffer == NULL)\n\treturn;\n\n    if (fullname > 1)\t    // 2 CTRL-G: include buffer number\n    {\n\tvim_snprintf(buffer, IOSIZE, \"buf %d: \", curbuf->b_fnum);\n\tp = buffer + STRLEN(buffer);\n    }\n    else\n\tp = buffer;\n\n    *p++ = '\"';\n    if (buf_spname(curbuf) != NULL)\n\tvim_strncpy((char_u *)p, buf_spname(curbuf), IOSIZE - (p - buffer) - 1);\n    else\n    {\n\tif (!fullname && curbuf->b_fname != NULL)\n\t    name = curbuf->b_fname;\n\telse\n\t    name = curbuf->b_ffname;\n\thome_replace(shorthelp ? curbuf : NULL, name, (char_u *)p,\n\t\t\t\t\t  (int)(IOSIZE - (p - buffer)), TRUE);\n    }\n\n    vim_snprintf_add(buffer, IOSIZE, \"\\\"%s%s%s%s%s%s\",\n\t    curbufIsChanged() ? (shortmess(SHM_MOD)\n\t\t\t\t\t  ?  \" [+]\" : _(\" [Modified]\")) : \" \",\n\t    (curbuf->b_flags & BF_NOTEDITED)\n#ifdef FEAT_QUICKFIX\n\t\t    && !bt_dontwrite(curbuf)\n#endif\n\t\t\t\t\t? _(\"[Not edited]\") : \"\",\n\t    (curbuf->b_flags & BF_NEW)\n#ifdef FEAT_QUICKFIX\n\t\t    && !bt_dontwrite(curbuf)\n#endif\n\t\t\t\t\t   ? new_file_message() : \"\",\n\t    (curbuf->b_flags & BF_READERR) ? _(\"[Read errors]\") : \"\",\n\t    curbuf->b_p_ro ? (shortmess(SHM_RO) ? _(\"[RO]\")\n\t\t\t\t\t\t      : _(\"[readonly]\")) : \"\",\n\t    (curbufIsChanged() || (curbuf->b_flags & BF_WRITE_MASK)\n\t\t\t\t\t\t\t  || curbuf->b_p_ro) ?\n\t\t\t\t\t\t\t\t    \" \" : \"\");\n    // With 32 bit longs and more than 21,474,836 lines multiplying by 100\n    // causes an overflow, thus for large numbers divide instead.\n    if (curwin->w_cursor.lnum > 1000000L)\n\tn = (int)(((long)curwin->w_cursor.lnum) /\n\t\t\t\t   ((long)curbuf->b_ml.ml_line_count / 100L));\n    else\n\tn = (int)(((long)curwin->w_cursor.lnum * 100L) /\n\t\t\t\t\t    (long)curbuf->b_ml.ml_line_count);\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\tvim_snprintf_add(buffer, IOSIZE, \"%s\", _(no_lines_msg));\n#ifdef FEAT_CMDL_INFO\n    else if (p_ru)\n\t// Current line and column are already on the screen -- webb\n\tvim_snprintf_add(buffer, IOSIZE,\n\t\tNGETTEXT(\"%ld line --%d%%--\", \"%ld lines --%d%%--\",\n\t\t\t\t\t\t   curbuf->b_ml.ml_line_count),\n\t\t(long)curbuf->b_ml.ml_line_count, n);\n#endif\n    else\n    {\n\tvim_snprintf_add(buffer, IOSIZE,\n\t\t_(\"line %ld of %ld --%d%%-- col \"),\n\t\t(long)curwin->w_cursor.lnum,\n\t\t(long)curbuf->b_ml.ml_line_count,\n\t\tn);\n\tvalidate_virtcol();\n\tlen = STRLEN(buffer);\n\tcol_print((char_u *)buffer + len, IOSIZE - len,\n\t\t   (int)curwin->w_cursor.col + 1, (int)curwin->w_virtcol + 1);\n    }\n\n    (void)append_arg_number(curwin, (char_u *)buffer, IOSIZE,\n\t\t\t\t\t\t\t !shortmess(SHM_FILE));\n\n    if (dont_truncate)\n    {\n\t// Temporarily set msg_scroll to avoid the message being truncated.\n\t// First call msg_start() to get the message in the right place.\n\tmsg_start();\n\tn = msg_scroll;\n\tmsg_scroll = TRUE;\n\tmsg(buffer);\n\tmsg_scroll = n;\n    }\n    else\n    {\n\tp = msg_trunc_attr(buffer, FALSE, 0);\n\tif (restart_edit != 0 || (msg_scrolled && !need_wait_return))\n\t    // Need to repeat the message after redrawing when:\n\t    // - When restart_edit is set (otherwise there will be a delay\n\t    //   before redrawing).\n\t    // - When the screen was scrolled but there is no wait-return\n\t    //   prompt.\n\t    set_keep_msg((char_u *)p, 0);\n    }\n\n    vim_free(buffer);\n}\n\n    void\ncol_print(\n    char_u  *buf,\n    size_t  buflen,\n    int\t    col,\n    int\t    vcol)\n{\n    if (col == vcol)\n\tvim_snprintf((char *)buf, buflen, \"%d\", col);\n    else\n\tvim_snprintf((char *)buf, buflen, \"%d-%d\", col, vcol);\n}\n\nstatic char_u *lasttitle = NULL;\nstatic char_u *lasticon = NULL;\n\n/*\n * Put the file name in the title bar and icon of the window.\n */\n    void\nmaketitle(void)\n{\n    char_u\t*p;\n    char_u\t*title_str = NULL;\n    char_u\t*icon_str = NULL;\n    int\t\tmaxlen = 0;\n    int\t\tlen;\n    int\t\tmustset;\n    char_u\tbuf[IOSIZE];\n    int\t\toff;\n\n    if (!redrawing())\n    {\n\t// Postpone updating the title when 'lazyredraw' is set.\n\tneed_maketitle = TRUE;\n\treturn;\n    }\n\n    need_maketitle = FALSE;\n    if (!p_title && !p_icon && lasttitle == NULL && lasticon == NULL)\n\treturn;  // nothing to do\n\n    if (p_title)\n    {\n\tif (p_titlelen > 0)\n\t{\n\t    maxlen = p_titlelen * Columns / 100;\n\t    if (maxlen < 10)\n\t\tmaxlen = 10;\n\t}\n\n\ttitle_str = buf;\n\tif (*p_titlestring != NUL)\n\t{\n#ifdef FEAT_STL_OPT\n\t    if (stl_syntax & STL_IN_TITLE)\n\t    {\n\t\tint\tuse_sandbox = FALSE;\n\t\tint\tcalled_emsg_before = called_emsg;\n\n# ifdef FEAT_EVAL\n\t\tuse_sandbox = was_set_insecurely((char_u *)\"titlestring\", 0);\n# endif\n\t\tbuild_stl_str_hl(curwin, title_str, sizeof(buf),\n\t\t\t\t\t      p_titlestring, use_sandbox,\n\t\t\t\t\t      0, maxlen, NULL, NULL);\n\t\tif (called_emsg > called_emsg_before)\n\t\t    set_string_option_direct((char_u *)\"titlestring\", -1,\n\t\t\t\t\t   (char_u *)\"\", OPT_FREE, SID_ERROR);\n\t    }\n\t    else\n#endif\n\t\ttitle_str = p_titlestring;\n\t}\n\telse\n\t{\n\t    // format: \"fname + (path) (1 of 2) - VIM\"\n\n#define SPACE_FOR_FNAME (IOSIZE - 100)\n#define SPACE_FOR_DIR   (IOSIZE - 20)\n#define SPACE_FOR_ARGNR (IOSIZE - 10)  // at least room for \" - VIM\"\n\t    if (curbuf->b_fname == NULL)\n\t\tvim_strncpy(buf, (char_u *)_(\"[No Name]\"), SPACE_FOR_FNAME);\n#ifdef FEAT_TERMINAL\n\t    else if (curbuf->b_term != NULL)\n\t    {\n\t\tvim_strncpy(buf, term_get_status_text(curbuf->b_term),\n\t\t\t\t\t\t\t      SPACE_FOR_FNAME);\n\t    }\n#endif\n\t    else\n\t    {\n\t\tp = transstr(gettail(curbuf->b_fname));\n\t\tvim_strncpy(buf, p, SPACE_FOR_FNAME);\n\t\tvim_free(p);\n\t    }\n\n#ifdef FEAT_TERMINAL\n\t    if (curbuf->b_term == NULL)\n#endif\n\t\tswitch (bufIsChanged(curbuf)\n\t\t\t+ (curbuf->b_p_ro * 2)\n\t\t\t+ (!curbuf->b_p_ma * 4))\n\t\t{\n\t\t    case 1: STRCAT(buf, \" +\"); break;\n\t\t    case 2: STRCAT(buf, \" =\"); break;\n\t\t    case 3: STRCAT(buf, \" =+\"); break;\n\t\t    case 4:\n\t\t    case 6: STRCAT(buf, \" -\"); break;\n\t\t    case 5:\n\t\t    case 7: STRCAT(buf, \" -+\"); break;\n\t\t}\n\n\t    if (curbuf->b_fname != NULL\n#ifdef FEAT_TERMINAL\n\t\t    && curbuf->b_term == NULL\n#endif\n\t\t    )\n\t    {\n\t\t// Get path of file, replace home dir with ~\n\t\toff = (int)STRLEN(buf);\n\t\tbuf[off++] = ' ';\n\t\tbuf[off++] = '(';\n\t\thome_replace(curbuf, curbuf->b_ffname,\n\t\t\t\t\tbuf + off, SPACE_FOR_DIR - off, TRUE);\n#ifdef BACKSLASH_IN_FILENAME\n\t\t// avoid \"c:/name\" to be reduced to \"c\"\n\t\tif (isalpha(buf[off]) && buf[off + 1] == ':')\n\t\t    off += 2;\n#endif\n\t\t// remove the file name\n\t\tp = gettail_sep(buf + off);\n\t\tif (p == buf + off)\n\t\t{\n\t\t    // must be a help buffer\n\t\t    vim_strncpy(buf + off, (char_u *)_(\"help\"),\n\t\t\t\t\t   (size_t)(SPACE_FOR_DIR - off - 1));\n\t\t}\n\t\telse\n\t\t    *p = NUL;\n\n\t\t// Translate unprintable chars and concatenate.  Keep some\n\t\t// room for the server name.  When there is no room (very long\n\t\t// file name) use (...).\n\t\tif (off < SPACE_FOR_DIR)\n\t\t{\n\t\t    p = transstr(buf + off);\n\t\t    vim_strncpy(buf + off, p, (size_t)(SPACE_FOR_DIR - off));\n\t\t    vim_free(p);\n\t\t}\n\t\telse\n\t\t{\n\t\t    vim_strncpy(buf + off, (char_u *)\"...\",\n\t\t\t\t\t     (size_t)(SPACE_FOR_ARGNR - off));\n\t\t}\n\t\tSTRCAT(buf, \")\");\n\t    }\n\n\t    append_arg_number(curwin, buf, SPACE_FOR_ARGNR, FALSE);\n\n#if defined(FEAT_CLIENTSERVER)\n\t    if (serverName != NULL)\n\t    {\n\t\tSTRCAT(buf, \" - \");\n\t\tvim_strcat(buf, serverName, IOSIZE);\n\t    }\n\t    else\n#endif\n\t\tSTRCAT(buf, \" - VIM\");\n\n\t    if (maxlen > 0)\n\t    {\n\t\t// make it shorter by removing a bit in the middle\n\t\tif (vim_strsize(buf) > maxlen)\n\t\t    trunc_string(buf, buf, maxlen, IOSIZE);\n\t    }\n\t}\n    }\n    mustset = value_changed(title_str, &lasttitle);\n\n    if (p_icon)\n    {\n\ticon_str = buf;\n\tif (*p_iconstring != NUL)\n\t{\n#ifdef FEAT_STL_OPT\n\t    if (stl_syntax & STL_IN_ICON)\n\t    {\n\t\tint\tuse_sandbox = FALSE;\n\t\tint\tcalled_emsg_before = called_emsg;\n\n# ifdef FEAT_EVAL\n\t\tuse_sandbox = was_set_insecurely((char_u *)\"iconstring\", 0);\n# endif\n\t\tbuild_stl_str_hl(curwin, icon_str, sizeof(buf),\n\t\t\t\t\t\t    p_iconstring, use_sandbox,\n\t\t\t\t\t\t    0, 0, NULL, NULL);\n\t\tif (called_emsg > called_emsg_before)\n\t\t    set_string_option_direct((char_u *)\"iconstring\", -1,\n\t\t\t\t\t   (char_u *)\"\", OPT_FREE, SID_ERROR);\n\t    }\n\t    else\n#endif\n\t\ticon_str = p_iconstring;\n\t}\n\telse\n\t{\n\t    if (buf_spname(curbuf) != NULL)\n\t\tp = buf_spname(curbuf);\n\t    else\t\t    // use file name only in icon\n\t\tp = gettail(curbuf->b_ffname);\n\t    *icon_str = NUL;\n\t    // Truncate name at 100 bytes.\n\t    len = (int)STRLEN(p);\n\t    if (len > 100)\n\t    {\n\t\tlen -= 100;\n\t\tif (has_mbyte)\n\t\t    len += (*mb_tail_off)(p, p + len) + 1;\n\t\tp += len;\n\t    }\n\t    STRCPY(icon_str, p);\n\t    trans_characters(icon_str, IOSIZE);\n\t}\n    }\n\n    mustset |= value_changed(icon_str, &lasticon);\n\n    if (mustset)\n\tresettitle();\n}\n\n/*\n * Used for title and icon: Check if \"str\" differs from \"*last\".  Set \"*last\"\n * from \"str\" if it does.\n * Return TRUE if resettitle() is to be called.\n */\n    static int\nvalue_changed(char_u *str, char_u **last)\n{\n    if ((str == NULL) != (*last == NULL)\n\t    || (str != NULL && *last != NULL && STRCMP(str, *last) != 0))\n    {\n\tvim_free(*last);\n\tif (str == NULL)\n\t{\n\t    *last = NULL;\n\t    mch_restore_title(\n\t\t  last == &lasttitle ? SAVE_RESTORE_TITLE : SAVE_RESTORE_ICON);\n\t}\n\telse\n\t{\n\t    *last = vim_strsave(str);\n\t    return TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n/*\n * Put current window title back (used after calling a shell)\n */\n    void\nresettitle(void)\n{\n    mch_settitle(lasttitle, lasticon);\n}\n\n# if defined(EXITFREE) || defined(PROTO)\n    void\nfree_titles(void)\n{\n    vim_free(lasttitle);\n    vim_free(lasticon);\n}\n# endif\n\n\n#if defined(FEAT_STL_OPT) || defined(FEAT_GUI_TABLINE) || defined(PROTO)\n\n/*\n * Used for building in the status line.\n */\ntypedef struct\n{\n    char_u\t*stl_start;\n    int\t\tstl_minwid;\n    int\t\tstl_maxwid;\n    enum {\n\tNormal,\n\tEmpty,\n\tGroup,\n\tMiddle,\n\tHighlight,\n\tTabPage,\n\tTrunc\n    }\t\tstl_type;\n} stl_item_T;\n\nstatic size_t\t\tstl_items_len = 20; // Initial value, grows as needed.\nstatic stl_item_T      *stl_items = NULL;\nstatic int\t       *stl_groupitem = NULL;\nstatic stl_hlrec_T     *stl_hltab = NULL;\nstatic stl_hlrec_T     *stl_tabtab = NULL;\n\n/*\n * Build a string from the status line items in \"fmt\".\n * Return length of string in screen cells.\n *\n * Normally works for window \"wp\", except when working for 'tabline' then it\n * is \"curwin\".\n *\n * Items are drawn interspersed with the text that surrounds it\n * Specials: %-<wid>(xxx%) => group, %= => middle marker, %< => truncation\n * Item: %-<minwid>.<maxwid><itemch> All but <itemch> are optional\n *\n * If maxwidth is not zero, the string will be filled at any middle marker\n * or truncated if too long, fillchar is used for all whitespace.\n */\n    int\nbuild_stl_str_hl(\n    win_T\t*wp,\n    char_u\t*out,\t\t// buffer to write into != NameBuff\n    size_t\toutlen,\t\t// length of out[]\n    char_u\t*fmt,\n    int\t\tuse_sandbox UNUSED, // \"fmt\" was set insecurely, use sandbox\n    int\t\tfillchar,\n    int\t\tmaxwidth,\n    stl_hlrec_T **hltab,\t// return: HL attributes (can be NULL)\n    stl_hlrec_T **tabtab)\t// return: tab page nrs (can be NULL)\n{\n    linenr_T\tlnum;\n    size_t\tlen;\n    char_u\t*p;\n    char_u\t*s;\n    char_u\t*t;\n    int\t\tbyteval;\n#ifdef FEAT_EVAL\n    win_T\t*save_curwin;\n    buf_T\t*save_curbuf;\n    int\t\tsave_VIsual_active;\n#endif\n    int\t\tempty_line;\n    colnr_T\tvirtcol;\n    long\tl;\n    long\tn;\n    int\t\tprevchar_isflag;\n    int\t\tprevchar_isitem;\n    int\t\titemisflag;\n    int\t\tfillable;\n    char_u\t*str;\n    long\tnum;\n    int\t\twidth;\n    int\t\titemcnt;\n    int\t\tcuritem;\n    int\t\tgroup_end_userhl;\n    int\t\tgroup_start_userhl;\n    int\t\tgroupdepth;\n#ifdef FEAT_EVAL\n    int\t\tevaldepth;\n#endif\n    int\t\tminwid;\n    int\t\tmaxwid;\n    int\t\tzeropad;\n    char_u\tbase;\n    char_u\topt;\n#define TMPLEN 70\n    char_u\tbuf_tmp[TMPLEN];\n    char_u\twin_tmp[TMPLEN];\n    char_u\t*usefmt = fmt;\n    stl_hlrec_T *sp;\n    int\t\tsave_must_redraw = must_redraw;\n    int\t\tsave_redr_type = curwin->w_redr_type;\n    int\t\tsave_KeyTyped = KeyTyped;\n\n    if (stl_items == NULL)\n    {\n\tstl_items = ALLOC_MULT(stl_item_T, stl_items_len);\n\tstl_groupitem = ALLOC_MULT(int, stl_items_len);\n\n\t// Allocate one more, because the last element is used to indicate the\n\t// end of the list.\n\tstl_hltab  = ALLOC_MULT(stl_hlrec_T, stl_items_len + 1);\n\tstl_tabtab = ALLOC_MULT(stl_hlrec_T, stl_items_len + 1);\n    }\n\n#ifdef FEAT_EVAL\n    /*\n     * When the format starts with \"%!\" then evaluate it as an expression and\n     * use the result as the actual format string.\n     */\n    if (fmt[0] == '%' && fmt[1] == '!')\n    {\n\ttypval_T\ttv;\n\n\ttv.v_type = VAR_NUMBER;\n\ttv.vval.v_number = wp->w_id;\n\tset_var((char_u *)\"g:statusline_winid\", &tv, FALSE);\n\n\tusefmt = eval_to_string_safe(fmt + 2, use_sandbox, FALSE);\n\tif (usefmt == NULL)\n\t    usefmt = fmt;\n\n\tdo_unlet((char_u *)\"g:statusline_winid\", TRUE);\n    }\n#endif\n\n    if (fillchar == 0)\n\tfillchar = ' ';\n\n    // The cursor in windows other than the current one isn't always\n    // up-to-date, esp. because of autocommands and timers.\n    lnum = wp->w_cursor.lnum;\n    if (lnum > wp->w_buffer->b_ml.ml_line_count)\n    {\n\tlnum = wp->w_buffer->b_ml.ml_line_count;\n\twp->w_cursor.lnum = lnum;\n    }\n\n    // Get line & check if empty (cursorpos will show \"0-1\").  Note that\n    // p will become invalid when getting another buffer line.\n    p = ml_get_buf(wp->w_buffer, lnum, FALSE);\n    empty_line = (*p == NUL);\n\n    // Get the byte value now, in case we need it below. This is more efficient\n    // than making a copy of the line.\n    len = STRLEN(p);\n    if (wp->w_cursor.col > (colnr_T)len)\n    {\n\t// Line may have changed since checking the cursor column, or the lnum\n\t// was adjusted above.\n\twp->w_cursor.col = (colnr_T)len;\n\twp->w_cursor.coladd = 0;\n\tbyteval = 0;\n    }\n    else\n\tbyteval = (*mb_ptr2char)(p + wp->w_cursor.col);\n\n    groupdepth = 0;\n#ifdef FEAT_EVAL\n    evaldepth = 0;\n#endif\n    p = out;\n    curitem = 0;\n    prevchar_isflag = TRUE;\n    prevchar_isitem = FALSE;\n    for (s = usefmt; *s; )\n    {\n\tif (curitem == (int)stl_items_len)\n\t{\n\t    size_t\tnew_len = stl_items_len * 3 / 2;\n\t    stl_item_T\t*new_items;\n\t    int\t\t*new_groupitem;\n\t    stl_hlrec_T\t*new_hlrec;\n\n\t    new_items = vim_realloc(stl_items, sizeof(stl_item_T) * new_len);\n\t    if (new_items == NULL)\n\t\tbreak;\n\t    stl_items = new_items;\n\t    new_groupitem = vim_realloc(stl_groupitem, sizeof(int) * new_len);\n\t    if (new_groupitem == NULL)\n\t\tbreak;\n\t    stl_groupitem = new_groupitem;\n\t    new_hlrec = vim_realloc(stl_hltab,\n\t\t\t\t\t  sizeof(stl_hlrec_T) * (new_len + 1));\n\t    if (new_hlrec == NULL)\n\t\tbreak;\n\t    stl_hltab = new_hlrec;\n\t    new_hlrec = vim_realloc(stl_tabtab,\n\t\t\t\t\t  sizeof(stl_hlrec_T) * (new_len + 1));\n\t    if (new_hlrec == NULL)\n\t\tbreak;\n\t    stl_tabtab = new_hlrec;\n\t    stl_items_len = new_len;\n\t}\n\n\tif (*s != NUL && *s != '%')\n\t    prevchar_isflag = prevchar_isitem = FALSE;\n\n\t/*\n\t * Handle up to the next '%' or the end.\n\t */\n\twhile (*s != NUL && *s != '%' && p + 1 < out + outlen)\n\t    *p++ = *s++;\n\tif (*s == NUL || p + 1 >= out + outlen)\n\t    break;\n\n\t/*\n\t * Handle one '%' item.\n\t */\n\ts++;\n\tif (*s == NUL)  // ignore trailing %\n\t    break;\n\tif (*s == '%')\n\t{\n\t    if (p + 1 >= out + outlen)\n\t\tbreak;\n\t    *p++ = *s++;\n\t    prevchar_isflag = prevchar_isitem = FALSE;\n\t    continue;\n\t}\n\tif (*s == STL_MIDDLEMARK)\n\t{\n\t    s++;\n\t    if (groupdepth > 0)\n\t\tcontinue;\n\t    stl_items[curitem].stl_type = Middle;\n\t    stl_items[curitem++].stl_start = p;\n\t    continue;\n\t}\n\tif (*s == STL_TRUNCMARK)\n\t{\n\t    s++;\n\t    stl_items[curitem].stl_type = Trunc;\n\t    stl_items[curitem++].stl_start = p;\n\t    continue;\n\t}\n\tif (*s == ')')\n\t{\n\t    s++;\n\t    if (groupdepth < 1)\n\t\tcontinue;\n\t    groupdepth--;\n\n\t    t = stl_items[stl_groupitem[groupdepth]].stl_start;\n\t    *p = NUL;\n\t    l = vim_strsize(t);\n\t    if (curitem > stl_groupitem[groupdepth] + 1\n\t\t    && stl_items[stl_groupitem[groupdepth]].stl_minwid == 0)\n\t    {\n\t\t// remove group if all items are empty and highlight group\n\t\t// doesn't change\n\t\tgroup_start_userhl = group_end_userhl = 0;\n\t\tfor (n = stl_groupitem[groupdepth] - 1; n >= 0; n--)\n\t\t{\n\t\t    if (stl_items[n].stl_type == Highlight)\n\t\t    {\n\t\t\tgroup_start_userhl = group_end_userhl =\n\t\t\t\t\t\t       stl_items[n].stl_minwid;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tfor (n = stl_groupitem[groupdepth] + 1; n < curitem; n++)\n\t\t{\n\t\t    if (stl_items[n].stl_type == Normal)\n\t\t\tbreak;\n\t\t    if (stl_items[n].stl_type == Highlight)\n\t\t\tgroup_end_userhl = stl_items[n].stl_minwid;\n\t\t}\n\t\tif (n == curitem && group_start_userhl == group_end_userhl)\n\t\t{\n\t\t    // empty group\n\t\t    p = t;\n\t\t    l = 0;\n\t\t    for (n = stl_groupitem[groupdepth] + 1; n < curitem; n++)\n\t\t    {\n\t\t\t// do not use the highlighting from the removed group\n\t\t\tif (stl_items[n].stl_type == Highlight)\n\t\t\t    stl_items[n].stl_type = Empty;\n\t\t\t// adjust the start position of TabPage to the next\n\t\t\t// item position\n\t\t\tif (stl_items[n].stl_type == TabPage)\n\t\t\t    stl_items[n].stl_start = p;\n\t\t    }\n\t\t}\n\t    }\n\t    if (l > stl_items[stl_groupitem[groupdepth]].stl_maxwid)\n\t    {\n\t\t// truncate, remove n bytes of text at the start\n\t\tif (has_mbyte)\n\t\t{\n\t\t    // Find the first character that should be included.\n\t\t    n = 0;\n\t\t    while (l >= stl_items[stl_groupitem[groupdepth]].stl_maxwid)\n\t\t    {\n\t\t\tl -= ptr2cells(t + n);\n\t\t\tn += (*mb_ptr2len)(t + n);\n\t\t    }\n\t\t}\n\t\telse\n\t\t    n = (long)(p - t) - stl_items[stl_groupitem[groupdepth]]\n\t\t\t\t\t\t\t       .stl_maxwid + 1;\n\n\t\t*t = '<';\n\t\tmch_memmove(t + 1, t + n, (size_t)(p - (t + n)));\n\t\tp = p - n + 1;\n\n\t\t// Fill up space left over by half a double-wide char.\n\t\twhile (++l < stl_items[stl_groupitem[groupdepth]].stl_minwid)\n\t\t    MB_CHAR2BYTES(fillchar, p);\n\n\t\t// correct the start of the items for the truncation\n\t\tfor (l = stl_groupitem[groupdepth] + 1; l < curitem; l++)\n\t\t{\n\t\t    // Minus one for the leading '<' added above.\n\t\t    stl_items[l].stl_start -= n - 1;\n\t\t    if (stl_items[l].stl_start < t)\n\t\t\tstl_items[l].stl_start = t;\n\t\t}\n\t    }\n\t    else if (abs(stl_items[stl_groupitem[groupdepth]].stl_minwid) > l)\n\t    {\n\t\t// fill\n\t\tn = stl_items[stl_groupitem[groupdepth]].stl_minwid;\n\t\tif (n < 0)\n\t\t{\n\t\t    // fill by appending characters\n\t\t    n = 0 - n;\n\t\t    while (l++ < n && p + 1 < out + outlen)\n\t\t\tMB_CHAR2BYTES(fillchar, p);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // fill by inserting characters\n\t\t    l = (n - l) * MB_CHAR2LEN(fillchar);\n\t\t    mch_memmove(t + l, t, (size_t)(p - t));\n\t\t    if (p + l >= out + outlen)\n\t\t\tl = (long)((out + outlen) - p - 1);\n\t\t    p += l;\n\t\t    for (n = stl_groupitem[groupdepth] + 1; n < curitem; n++)\n\t\t\tstl_items[n].stl_start += l;\n\t\t    for ( ; l > 0; l--)\n\t\t\tMB_CHAR2BYTES(fillchar, t);\n\t\t}\n\t    }\n\t    continue;\n\t}\n\tminwid = 0;\n\tmaxwid = 9999;\n\tzeropad = FALSE;\n\tl = 1;\n\tif (*s == '0')\n\t{\n\t    s++;\n\t    zeropad = TRUE;\n\t}\n\tif (*s == '-')\n\t{\n\t    s++;\n\t    l = -1;\n\t}\n\tif (VIM_ISDIGIT(*s))\n\t{\n\t    minwid = (int)getdigits(&s);\n\t    if (minwid < 0)\t// overflow\n\t\tminwid = 0;\n\t}\n\tif (*s == STL_USER_HL)\n\t{\n\t    stl_items[curitem].stl_type = Highlight;\n\t    stl_items[curitem].stl_start = p;\n\t    stl_items[curitem].stl_minwid = minwid > 9 ? 1 : minwid;\n\t    s++;\n\t    curitem++;\n\t    continue;\n\t}\n\tif (*s == STL_TABPAGENR || *s == STL_TABCLOSENR)\n\t{\n\t    if (*s == STL_TABCLOSENR)\n\t    {\n\t\tif (minwid == 0)\n\t\t{\n\t\t    // %X ends the close label, go back to the previously\n\t\t    // define tab label nr.\n\t\t    for (n = curitem - 1; n >= 0; --n)\n\t\t\tif (stl_items[n].stl_type == TabPage\n\t\t\t\t\t       && stl_items[n].stl_minwid >= 0)\n\t\t\t{\n\t\t\t    minwid = stl_items[n].stl_minwid;\n\t\t\t    break;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t    // close nrs are stored as negative values\n\t\t    minwid = - minwid;\n\t    }\n\t    stl_items[curitem].stl_type = TabPage;\n\t    stl_items[curitem].stl_start = p;\n\t    stl_items[curitem].stl_minwid = minwid;\n\t    s++;\n\t    curitem++;\n\t    continue;\n\t}\n\tif (*s == '.')\n\t{\n\t    s++;\n\t    if (VIM_ISDIGIT(*s))\n\t    {\n\t\tmaxwid = (int)getdigits(&s);\n\t\tif (maxwid <= 0)\t// overflow\n\t\t    maxwid = 50;\n\t    }\n\t}\n\tminwid = (minwid > 50 ? 50 : minwid) * l;\n\tif (*s == '(')\n\t{\n\t    stl_groupitem[groupdepth++] = curitem;\n\t    stl_items[curitem].stl_type = Group;\n\t    stl_items[curitem].stl_start = p;\n\t    stl_items[curitem].stl_minwid = minwid;\n\t    stl_items[curitem].stl_maxwid = maxwid;\n\t    s++;\n\t    curitem++;\n\t    continue;\n\t}\n#ifdef FEAT_EVAL\n\t// Denotes end of expanded %{} block\n\tif (*s == '}' && evaldepth > 0)\n\t{\n\t    s++;\n\t    evaldepth--;\n\t    continue;\n\t}\n#endif\n\tif (vim_strchr(STL_ALL, *s) == NULL)\n\t{\n\t    s++;\n\t    continue;\n\t}\n\topt = *s++;\n\n\t// OK - now for the real work\n\tbase = 'D';\n\titemisflag = FALSE;\n\tfillable = TRUE;\n\tnum = -1;\n\tstr = NULL;\n\tswitch (opt)\n\t{\n\tcase STL_FILEPATH:\n\tcase STL_FULLPATH:\n\tcase STL_FILENAME:\n\t    fillable = FALSE;\t// don't change ' ' to fillchar\n\t    if (buf_spname(wp->w_buffer) != NULL)\n\t\tvim_strncpy(NameBuff, buf_spname(wp->w_buffer), MAXPATHL - 1);\n\t    else\n\t    {\n\t\tt = (opt == STL_FULLPATH) ? wp->w_buffer->b_ffname\n\t\t\t\t\t  : wp->w_buffer->b_fname;\n\t\thome_replace(wp->w_buffer, t, NameBuff, MAXPATHL, TRUE);\n\t    }\n\t    trans_characters(NameBuff, MAXPATHL);\n\t    if (opt != STL_FILENAME)\n\t\tstr = NameBuff;\n\t    else\n\t\tstr = gettail(NameBuff);\n\t    break;\n\n\tcase STL_VIM_EXPR: // '{'\n\t{\n#ifdef FEAT_EVAL\n\t    char_u *block_start = s - 1;\n#endif\n\t    int reevaluate = (*s == '%');\n\n\t    if (reevaluate)\n\t\ts++;\n\t    itemisflag = TRUE;\n\t    t = p;\n\t    while ((*s != '}' || (reevaluate && s[-1] != '%'))\n\t\t\t\t\t  && *s != NUL && p + 1 < out + outlen)\n\t\t*p++ = *s++;\n\t    if (*s != '}')\t// missing '}' or out of space\n\t\tbreak;\n\t    s++;\n\t    if (reevaluate)\n\t\tp[-1] = 0; // remove the % at the end of %{% expr %}\n\t    else\n\t\t*p = 0;\n\t    p = t;\n#ifdef FEAT_EVAL\n\t    vim_snprintf((char *)buf_tmp, sizeof(buf_tmp),\n\t\t\t\t\t\t\t \"%d\", curbuf->b_fnum);\n\t    set_internal_string_var((char_u *)\"g:actual_curbuf\", buf_tmp);\n\t    vim_snprintf((char *)win_tmp, sizeof(win_tmp), \"%d\", curwin->w_id);\n\t    set_internal_string_var((char_u *)\"g:actual_curwin\", win_tmp);\n\n\t    save_curbuf = curbuf;\n\t    save_curwin = curwin;\n\t    save_VIsual_active = VIsual_active;\n\t    curwin = wp;\n\t    curbuf = wp->w_buffer;\n\t    // Visual mode is only valid in the current window.\n\t    if (curwin != save_curwin)\n\t\tVIsual_active = FALSE;\n\n\t    str = eval_to_string_safe(p, use_sandbox, FALSE);\n\n\t    curwin = save_curwin;\n\t    curbuf = save_curbuf;\n\t    VIsual_active = save_VIsual_active;\n\t    do_unlet((char_u *)\"g:actual_curbuf\", TRUE);\n\t    do_unlet((char_u *)\"g:actual_curwin\", TRUE);\n\n\t    if (str != NULL && *str != 0)\n\t    {\n\t\tif (*skipdigits(str) == NUL)\n\t\t{\n\t\t    num = atoi((char *)str);\n\t\t    VIM_CLEAR(str);\n\t\t    itemisflag = FALSE;\n\t\t}\n\t    }\n\n\t    // If the output of the expression needs to be evaluated\n\t    // replace the %{} block with the result of evaluation\n\t    if (reevaluate && str != NULL && *str != 0\n\t\t    && strchr((const char *)str, '%') != NULL\n\t\t    && evaldepth < MAX_STL_EVAL_DEPTH)\n\t    {\n\t\tsize_t parsed_usefmt = (size_t)(block_start - usefmt);\n\t\tsize_t str_length = strlen((const char *)str);\n\t\tsize_t fmt_length = strlen((const char *)s);\n\t\tsize_t new_fmt_len = parsed_usefmt\n\t\t\t\t\t\t + str_length + fmt_length + 3;\n\t\tchar_u *new_fmt = (char_u *)alloc(new_fmt_len * sizeof(char_u));\n\t\tchar_u *new_fmt_p = new_fmt;\n\n\t\tnew_fmt_p = (char_u *)memcpy(new_fmt_p, usefmt, parsed_usefmt)\n\t\t\t\t\t\t\t       + parsed_usefmt;\n\t\tnew_fmt_p = (char_u *)memcpy(new_fmt_p , str, str_length)\n\t\t\t\t\t\t\t\t  + str_length;\n\t\tnew_fmt_p = (char_u *)memcpy(new_fmt_p, \"%}\", 2) + 2;\n\t\tnew_fmt_p = (char_u *)memcpy(new_fmt_p , s, fmt_length)\n\t\t\t\t\t\t\t\t  + fmt_length;\n\t\t*new_fmt_p = 0;\n\t\tnew_fmt_p = NULL;\n\n\t\tif (usefmt != fmt)\n\t\t    vim_free(usefmt);\n\t\tVIM_CLEAR(str);\n\t\tusefmt = new_fmt;\n\t\ts = usefmt + parsed_usefmt;\n\t\tevaldepth++;\n\t\tcontinue;\n\t    }\n#endif\n\t    break;\n\t}\n\tcase STL_LINE:\n\t    num = (wp->w_buffer->b_ml.ml_flags & ML_EMPTY)\n\t\t  ? 0L : (long)(wp->w_cursor.lnum);\n\t    break;\n\n\tcase STL_NUMLINES:\n\t    num = wp->w_buffer->b_ml.ml_line_count;\n\t    break;\n\n\tcase STL_COLUMN:\n\t    num = (State & MODE_INSERT) == 0 && empty_line\n\t\t\t\t\t       ? 0 : (int)wp->w_cursor.col + 1;\n\t    break;\n\n\tcase STL_VIRTCOL:\n\tcase STL_VIRTCOL_ALT:\n\t    virtcol = wp->w_virtcol + 1;\n\t    // Don't display %V if it's the same as %c.\n\t    if (opt == STL_VIRTCOL_ALT\n\t\t    && (virtcol == (colnr_T)((State & MODE_INSERT) == 0\n\t\t\t       && empty_line ? 0 : (int)wp->w_cursor.col + 1)))\n\t\tbreak;\n\t    num = (long)virtcol;\n\t    break;\n\n\tcase STL_PERCENTAGE:\n\t    num = (int)(((long)wp->w_cursor.lnum * 100L) /\n\t\t\t(long)wp->w_buffer->b_ml.ml_line_count);\n\t    break;\n\n\tcase STL_ALTPERCENT:\n\t    str = buf_tmp;\n\t    get_rel_pos(wp, str, TMPLEN);\n\t    break;\n\n\tcase STL_ARGLISTSTAT:\n\t    fillable = FALSE;\n\t    buf_tmp[0] = 0;\n\t    if (append_arg_number(wp, buf_tmp, (int)sizeof(buf_tmp), FALSE))\n\t\tstr = buf_tmp;\n\t    break;\n\n\tcase STL_KEYMAP:\n\t    fillable = FALSE;\n\t    if (get_keymap_str(wp, (char_u *)\"<%s>\", buf_tmp, TMPLEN))\n\t\tstr = buf_tmp;\n\t    break;\n\tcase STL_PAGENUM:\n#if defined(FEAT_PRINTER) || defined(FEAT_GUI_TABLINE)\n\t    num = printer_page_num;\n#else\n\t    num = 0;\n#endif\n\t    break;\n\n\tcase STL_BUFNO:\n\t    num = wp->w_buffer->b_fnum;\n\t    break;\n\n\tcase STL_OFFSET_X:\n\t    base = 'X';\n\t    // FALLTHROUGH\n\tcase STL_OFFSET:\n#ifdef FEAT_BYTEOFF\n\t    l = ml_find_line_or_offset(wp->w_buffer, wp->w_cursor.lnum, NULL);\n\t    num = (wp->w_buffer->b_ml.ml_flags & ML_EMPTY) || l < 0\n\t\t       ? 0L : l + 1 + ((State & MODE_INSERT) == 0 && empty_line\n\t\t\t\t? 0 : (int)wp->w_cursor.col);\n#endif\n\t    break;\n\n\tcase STL_BYTEVAL_X:\n\t    base = 'X';\n\t    // FALLTHROUGH\n\tcase STL_BYTEVAL:\n\t    num = byteval;\n\t    if (num == NL)\n\t\tnum = 0;\n\t    else if (num == CAR && get_fileformat(wp->w_buffer) == EOL_MAC)\n\t\tnum = NL;\n\t    break;\n\n\tcase STL_ROFLAG:\n\tcase STL_ROFLAG_ALT:\n\t    itemisflag = TRUE;\n\t    if (wp->w_buffer->b_p_ro)\n\t\tstr = (char_u *)((opt == STL_ROFLAG_ALT) ? \",RO\" : _(\"[RO]\"));\n\t    break;\n\n\tcase STL_HELPFLAG:\n\tcase STL_HELPFLAG_ALT:\n\t    itemisflag = TRUE;\n\t    if (wp->w_buffer->b_help)\n\t\tstr = (char_u *)((opt == STL_HELPFLAG_ALT) ? \",HLP\"\n\t\t\t\t\t\t\t       : _(\"[Help]\"));\n\t    break;\n\n\tcase STL_FILETYPE:\n\t    if (*wp->w_buffer->b_p_ft != NUL\n\t\t    && STRLEN(wp->w_buffer->b_p_ft) < TMPLEN - 3)\n\t    {\n\t\tvim_snprintf((char *)buf_tmp, sizeof(buf_tmp), \"[%s]\",\n\t\t\t\t\t\t\twp->w_buffer->b_p_ft);\n\t\tstr = buf_tmp;\n\t    }\n\t    break;\n\n\tcase STL_FILETYPE_ALT:\n\t    itemisflag = TRUE;\n\t    if (*wp->w_buffer->b_p_ft != NUL\n\t\t    && STRLEN(wp->w_buffer->b_p_ft) < TMPLEN - 2)\n\t    {\n\t\tvim_snprintf((char *)buf_tmp, sizeof(buf_tmp), \",%s\",\n\t\t\t\t\t\t\twp->w_buffer->b_p_ft);\n\t\tfor (t = buf_tmp; *t != 0; t++)\n\t\t    *t = TOUPPER_LOC(*t);\n\t\tstr = buf_tmp;\n\t    }\n\t    break;\n\n#if defined(FEAT_QUICKFIX)\n\tcase STL_PREVIEWFLAG:\n\tcase STL_PREVIEWFLAG_ALT:\n\t    itemisflag = TRUE;\n\t    if (wp->w_p_pvw)\n\t\tstr = (char_u *)((opt == STL_PREVIEWFLAG_ALT) ? \",PRV\"\n\t\t\t\t\t\t\t    : _(\"[Preview]\"));\n\t    break;\n\n\tcase STL_QUICKFIX:\n\t    if (bt_quickfix(wp->w_buffer))\n\t\tstr = (char_u *)(wp->w_llist_ref\n\t\t\t    ? _(msg_loclist)\n\t\t\t    : _(msg_qflist));\n\t    break;\n#endif\n\n\tcase STL_MODIFIED:\n\tcase STL_MODIFIED_ALT:\n\t    itemisflag = TRUE;\n\t    switch ((opt == STL_MODIFIED_ALT)\n\t\t    + bufIsChanged(wp->w_buffer) * 2\n\t\t    + (!wp->w_buffer->b_p_ma) * 4)\n\t    {\n\t\tcase 2: str = (char_u *)\"[+]\"; break;\n\t\tcase 3: str = (char_u *)\",+\"; break;\n\t\tcase 4: str = (char_u *)\"[-]\"; break;\n\t\tcase 5: str = (char_u *)\",-\"; break;\n\t\tcase 6: str = (char_u *)\"[+-]\"; break;\n\t\tcase 7: str = (char_u *)\",+-\"; break;\n\t    }\n\t    break;\n\n\tcase STL_HIGHLIGHT:\n\t    t = s;\n\t    while (*s != '#' && *s != NUL)\n\t\t++s;\n\t    if (*s == '#')\n\t    {\n\t\tstl_items[curitem].stl_type = Highlight;\n\t\tstl_items[curitem].stl_start = p;\n\t\tstl_items[curitem].stl_minwid = -syn_namen2id(t, (int)(s - t));\n\t\tcuritem++;\n\t    }\n\t    if (*s != NUL)\n\t\t++s;\n\t    continue;\n\t}\n\n\tstl_items[curitem].stl_start = p;\n\tstl_items[curitem].stl_type = Normal;\n\tif (str != NULL && *str)\n\t{\n\t    t = str;\n\t    if (itemisflag)\n\t    {\n\t\tif ((t[0] && t[1])\n\t\t\t&& ((!prevchar_isitem && *t == ',')\n\t\t\t      || (prevchar_isflag && *t == ' ')))\n\t\t    t++;\n\t\tprevchar_isflag = TRUE;\n\t    }\n\t    l = vim_strsize(t);\n\t    if (l > 0)\n\t\tprevchar_isitem = TRUE;\n\t    if (l > maxwid)\n\t    {\n\t\twhile (l >= maxwid)\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\tl -= ptr2cells(t);\n\t\t\tt += (*mb_ptr2len)(t);\n\t\t    }\n\t\t    else\n\t\t\tl -= byte2cells(*t++);\n\t\tif (p + 1 >= out + outlen)\n\t\t    break;\n\t\t*p++ = '<';\n\t    }\n\t    if (minwid > 0)\n\t    {\n\t\tfor (; l < minwid && p + 1 < out + outlen; l++)\n\t\t{\n\t\t    // Don't put a \"-\" in front of a digit.\n\t\t    if (l + 1 == minwid && fillchar == '-' && VIM_ISDIGIT(*t))\n\t\t\t*p++ = ' ';\n\t\t    else\n\t\t\tMB_CHAR2BYTES(fillchar, p);\n\t\t}\n\t\tminwid = 0;\n\t    }\n\t    else\n\t\tminwid *= -1;\n\t    for (; *t && p + 1 < out + outlen; t++)\n\t    {\n\t\t// Change a space by fillchar, unless fillchar is '-' and a\n\t\t// digit follows.\n\t\tif (fillable && *t == ' '\n\t\t\t\t&& (!VIM_ISDIGIT(*(t + 1)) || fillchar != '-'))\n\t\t    MB_CHAR2BYTES(fillchar, p);\n\t\telse\n\t\t    *p++ = *t;\n\t    }\n\t    for (; l < minwid && p + 1 < out + outlen; l++)\n\t\tMB_CHAR2BYTES(fillchar, p);\n\t}\n\telse if (num >= 0)\n\t{\n\t    int nbase = (base == 'D' ? 10 : (base == 'O' ? 8 : 16));\n\t    char_u nstr[20];\n\n\t    if (p + 20 >= out + outlen)\n\t\tbreak;\t\t// not sufficient space\n\t    prevchar_isitem = TRUE;\n\t    t = nstr;\n\t    if (opt == STL_VIRTCOL_ALT)\n\t    {\n\t\t*t++ = '-';\n\t\tminwid--;\n\t    }\n\t    *t++ = '%';\n\t    if (zeropad)\n\t\t*t++ = '0';\n\t    *t++ = '*';\n\t    *t++ = nbase == 16 ? base : (char_u)(nbase == 8 ? 'o' : 'd');\n\t    *t = 0;\n\n\t    for (n = num, l = 1; n >= nbase; n /= nbase)\n\t\tl++;\n\t    if (opt == STL_VIRTCOL_ALT)\n\t\tl++;\n\t    if (l > maxwid)\n\t    {\n\t\tl += 2;\n\t\tn = l - maxwid;\n\t\twhile (l-- > maxwid)\n\t\t    num /= nbase;\n\t\t*t++ = '>';\n\t\t*t++ = '%';\n\t\t*t = t[-3];\n\t\t*++t = 0;\n\t\tvim_snprintf((char *)p, outlen - (p - out), (char *)nstr,\n\t\t\t\t\t\t\t\t   0, num, n);\n\t    }\n\t    else\n\t\tvim_snprintf((char *)p, outlen - (p - out), (char *)nstr,\n\t\t\t\t\t\t\t\t minwid, num);\n\t    p += STRLEN(p);\n\t}\n\telse\n\t    stl_items[curitem].stl_type = Empty;\n\n\tif (opt == STL_VIM_EXPR)\n\t    vim_free(str);\n\n\tif (num >= 0 || (!itemisflag && str && *str))\n\t    prevchar_isflag = FALSE;\t    // Item not NULL, but not a flag\n\tcuritem++;\n    }\n    *p = NUL;\n    itemcnt = curitem;\n\n#ifdef FEAT_EVAL\n    if (usefmt != fmt)\n\tvim_free(usefmt);\n#endif\n\n    width = vim_strsize(out);\n    if (maxwidth > 0 && width > maxwidth)\n    {\n\t// Result is too long, must truncate somewhere.\n\tl = 0;\n\tif (itemcnt == 0)\n\t    s = out;\n\telse\n\t{\n\t    for ( ; l < itemcnt; l++)\n\t\tif (stl_items[l].stl_type == Trunc)\n\t\t{\n\t\t    // Truncate at %< item.\n\t\t    s = stl_items[l].stl_start;\n\t\t    break;\n\t\t}\n\t    if (l == itemcnt)\n\t    {\n\t\t// No %< item, truncate first item.\n\t\ts = stl_items[0].stl_start;\n\t\tl = 0;\n\t    }\n\t}\n\n\tif (width - vim_strsize(s) >= maxwidth)\n\t{\n\t    // Truncation mark is beyond max length\n\t    if (has_mbyte)\n\t    {\n\t\ts = out;\n\t\twidth = 0;\n\t\tfor (;;)\n\t\t{\n\t\t    width += ptr2cells(s);\n\t\t    if (width >= maxwidth)\n\t\t\tbreak;\n\t\t    s += (*mb_ptr2len)(s);\n\t\t}\n\t\t// Fill up for half a double-wide character.\n\t\twhile (++width < maxwidth)\n\t\t    MB_CHAR2BYTES(fillchar, s);\n\t    }\n\t    else\n\t\ts = out + maxwidth - 1;\n\t    for (l = 0; l < itemcnt; l++)\n\t\tif (stl_items[l].stl_start > s)\n\t\t    break;\n\t    itemcnt = l;\n\t    *s++ = '>';\n\t    *s = 0;\n\t}\n\telse\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tn = 0;\n\t\twhile (width >= maxwidth)\n\t\t{\n\t\t    width -= ptr2cells(s + n);\n\t\t    n += (*mb_ptr2len)(s + n);\n\t\t}\n\t    }\n\t    else\n\t\tn = width - maxwidth + 1;\n\t    p = s + n;\n\t    STRMOVE(s + 1, p);\n\t    *s = '<';\n\n\t    // Fill up for half a double-wide character.\n\t    while (++width < maxwidth)\n\t    {\n\t\ts = s + STRLEN(s);\n\t\tMB_CHAR2BYTES(fillchar, s);\n\t\t*s = NUL;\n\t    }\n\n\t    --n;\t// count the '<'\n\t    for (; l < itemcnt; l++)\n\t    {\n\t\tif (stl_items[l].stl_start - n >= s)\n\t\t    stl_items[l].stl_start -= n;\n\t\telse\n\t\t    stl_items[l].stl_start = s;\n\t    }\n\t}\n\twidth = maxwidth;\n    }\n    else if (width < maxwidth && STRLEN(out) + maxwidth - width + 1 < outlen)\n    {\n\t// Apply STL_MIDDLE if any\n\tfor (l = 0; l < itemcnt; l++)\n\t    if (stl_items[l].stl_type == Middle)\n\t\tbreak;\n\tif (l < itemcnt)\n\t{\n\t    int middlelength = (maxwidth - width) * MB_CHAR2LEN(fillchar);\n\t    p = stl_items[l].stl_start + middlelength;\n\t    STRMOVE(p, stl_items[l].stl_start);\n\t    for (s = stl_items[l].stl_start; s < p;)\n\t\tMB_CHAR2BYTES(fillchar, s);\n\t    for (l++; l < itemcnt; l++)\n\t\tstl_items[l].stl_start += middlelength;\n\t    width = maxwidth;\n\t}\n    }\n\n    // Store the info about highlighting.\n    if (hltab != NULL)\n    {\n\t*hltab = stl_hltab;\n\tsp = stl_hltab;\n\tfor (l = 0; l < itemcnt; l++)\n\t{\n\t    if (stl_items[l].stl_type == Highlight)\n\t    {\n\t\tsp->start = stl_items[l].stl_start;\n\t\tsp->userhl = stl_items[l].stl_minwid;\n\t\tsp++;\n\t    }\n\t}\n\tsp->start = NULL;\n\tsp->userhl = 0;\n    }\n\n    // Store the info about tab pages labels.\n    if (tabtab != NULL)\n    {\n\t*tabtab = stl_tabtab;\n\tsp = stl_tabtab;\n\tfor (l = 0; l < itemcnt; l++)\n\t{\n\t    if (stl_items[l].stl_type == TabPage)\n\t    {\n\t\tsp->start = stl_items[l].stl_start;\n\t\tsp->userhl = stl_items[l].stl_minwid;\n\t\tsp++;\n\t    }\n\t}\n\tsp->start = NULL;\n\tsp->userhl = 0;\n    }\n\n    // When inside update_screen we do not want redrawing a statusline, ruler,\n    // title, etc. to trigger another redraw, it may cause an endless loop.\n    if (updating_screen)\n    {\n\tmust_redraw = save_must_redraw;\n\tcurwin->w_redr_type = save_redr_type;\n    }\n\n    // A user function may reset KeyTyped, restore it.\n    KeyTyped = save_KeyTyped;\n\n    return width;\n}\n#endif // FEAT_STL_OPT\n\n#if defined(FEAT_STL_OPT) || defined(FEAT_CMDL_INFO) \\\n\t    || defined(FEAT_GUI_TABLINE) || defined(PROTO)\n/*\n * Get relative cursor position in window into \"buf[buflen]\", in the form 99%,\n * using \"Top\", \"Bot\" or \"All\" when appropriate.\n */\n    void\nget_rel_pos(\n    win_T\t*wp,\n    char_u\t*buf,\n    int\t\tbuflen)\n{\n    long\tabove; // number of lines above window\n    long\tbelow; // number of lines below window\n\n    if (buflen < 3) // need at least 3 chars for writing\n\treturn;\n    above = wp->w_topline - 1;\n#ifdef FEAT_DIFF\n    above += diff_check_fill(wp, wp->w_topline) - wp->w_topfill;\n    if (wp->w_topline == 1 && wp->w_topfill >= 1)\n\tabove = 0;  // All buffer lines are displayed and there is an\n\t\t    // indication of filler lines, that can be considered\n\t\t    // seeing all lines.\n#endif\n    below = wp->w_buffer->b_ml.ml_line_count - wp->w_botline + 1;\n    if (below <= 0)\n\tvim_strncpy(buf, (char_u *)(above == 0 ? _(\"All\") : _(\"Bot\")),\n\t\t\t\t\t\t\t(size_t)(buflen - 1));\n    else if (above <= 0)\n\tvim_strncpy(buf, (char_u *)_(\"Top\"), (size_t)(buflen - 1));\n    else\n\tvim_snprintf((char *)buf, (size_t)buflen, \"%2d%%\", above > 1000000L\n\t\t\t\t    ? (int)(above / ((above + below) / 100L))\n\t\t\t\t    : (int)(above * 100L / (above + below)));\n}\n#endif\n\n/*\n * Append (file 2 of 8) to \"buf[buflen]\", if editing more than one file.\n * Return TRUE if it was appended.\n */\n    static int\nappend_arg_number(\n    win_T\t*wp,\n    char_u\t*buf,\n    int\t\tbuflen,\n    int\t\tadd_file)\t// Add \"file\" before the arg number\n{\n    char_u\t*p;\n\n    if (ARGCOUNT <= 1)\t\t// nothing to do\n\treturn FALSE;\n\n    p = buf + STRLEN(buf);\t// go to the end of the buffer\n    if (p - buf + 35 >= buflen)\t// getting too long\n\treturn FALSE;\n    *p++ = ' ';\n    *p++ = '(';\n    if (add_file)\n    {\n\tSTRCPY(p, \"file \");\n\tp += 5;\n    }\n    vim_snprintf((char *)p, (size_t)(buflen - (p - buf)),\n\t\twp->w_arg_idx_invalid ? \"(%d) of %d)\"\n\t\t\t\t  : \"%d of %d)\", wp->w_arg_idx + 1, ARGCOUNT);\n    return TRUE;\n}\n\n/*\n * If fname is not a full path, make it a full path.\n * Returns pointer to allocated memory (NULL for failure).\n */\n    char_u  *\nfix_fname(char_u  *fname)\n{\n    /*\n     * Force expanding the path always for Unix, because symbolic links may\n     * mess up the full path name, even though it starts with a '/'.\n     * Also expand when there is \"..\" in the file name, try to remove it,\n     * because \"c:/src/../README\" is equal to \"c:/README\".\n     * Similarly \"c:/src//file\" is equal to \"c:/src/file\".\n     * For MS-Windows also expand names like \"longna~1\" to \"longname\".\n     */\n#ifdef UNIX\n    return FullName_save(fname, TRUE);\n#else\n    if (!vim_isAbsName(fname)\n\t    || strstr((char *)fname, \"..\") != NULL\n\t    || strstr((char *)fname, \"//\") != NULL\n# ifdef BACKSLASH_IN_FILENAME\n\t    || strstr((char *)fname, \"\\\\\\\\\") != NULL\n# endif\n# if defined(MSWIN)\n\t    || vim_strchr(fname, '~') != NULL\n# endif\n\t    )\n\treturn FullName_save(fname, FALSE);\n\n    fname = vim_strsave(fname);\n\n# ifdef USE_FNAME_CASE\n    if (fname != NULL)\n\tfname_case(fname, 0);\t// set correct case for file name\n# endif\n\n    return fname;\n#endif\n}\n\n/*\n * Make \"*ffname\" a full file name, set \"*sfname\" to \"*ffname\" if not NULL.\n * \"*ffname\" becomes a pointer to allocated memory (or NULL).\n * When resolving a link both \"*sfname\" and \"*ffname\" will point to the same\n * allocated memory.\n * The \"*ffname\" and \"*sfname\" pointer values on call will not be freed.\n * Note that the resulting \"*ffname\" pointer should be considered not allocated.\n */\n    void\nfname_expand(\n    buf_T\t*buf UNUSED,\n    char_u\t**ffname,\n    char_u\t**sfname)\n{\n    if (*ffname == NULL)\t    // no file name given, nothing to do\n\treturn;\n    if (*sfname == NULL)\t    // no short file name given, use ffname\n\t*sfname = *ffname;\n    *ffname = fix_fname(*ffname);   // expand to full path\n\n#ifdef FEAT_SHORTCUT\n    if (!buf->b_p_bin)\n    {\n\tchar_u  *rfname;\n\n\t// If the file name is a shortcut file, use the file it links to.\n\trfname = mch_resolve_path(*ffname, FALSE);\n\tif (rfname != NULL)\n\t{\n\t    vim_free(*ffname);\n\t    *ffname = rfname;\n\t    *sfname = rfname;\n\t}\n    }\n#endif\n}\n\n/*\n * Open a window for a number of buffers.\n */\n    void\nex_buffer_all(exarg_T *eap)\n{\n    buf_T\t*buf;\n    win_T\t*wp, *wpnext;\n    int\t\tsplit_ret = OK;\n    int\t\tp_ea_save;\n    int\t\topen_wins = 0;\n    int\t\tr;\n    int\t\tcount;\t\t// Maximum number of windows to open.\n    int\t\tall;\t\t// When TRUE also load inactive buffers.\n    int\t\thad_tab = cmdmod.cmod_tab;\n    tabpage_T\t*tpnext;\n\n    if (eap->addr_count == 0)\t// make as many windows as possible\n\tcount = 9999;\n    else\n\tcount = eap->line2;\t// make as many windows as specified\n    if (eap->cmdidx == CMD_unhide || eap->cmdidx == CMD_sunhide)\n\tall = FALSE;\n    else\n\tall = TRUE;\n\n    setpcmark();\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * Close superfluous windows (two windows for the same buffer).\n     * Also close windows that are not full-width.\n     */\n    if (had_tab > 0)\n\tgoto_tabpage_tp(first_tabpage, TRUE, TRUE);\n    for (;;)\n    {\n\ttpnext = curtab->tp_next;\n\tfor (wp = firstwin; wp != NULL; wp = wpnext)\n\t{\n\t    wpnext = wp->w_next;\n\t    if ((wp->w_buffer->b_nwindows > 1\n\t\t\t|| ((cmdmod.cmod_split & WSP_VERT)\n\t\t\t    ? wp->w_height + wp->w_status_height < Rows - p_ch\n\t\t\t\t\t\t\t     - tabline_height()\n\t\t\t    : wp->w_width != Columns)\n\t\t\t|| (had_tab > 0 && wp != firstwin))\n\t\t    && !ONE_WINDOW\n\t\t    && !(wp->w_closing || wp->w_buffer->b_locked > 0)\n\t\t    && !win_unlisted(wp))\n\t    {\n\t\tif (win_close(wp, FALSE) == FAIL)\n\t\t    break;\n\t\t// Just in case an autocommand does something strange with\n\t\t// windows: start all over...\n\t\twpnext = firstwin;\n\t\ttpnext = first_tabpage;\n\t\topen_wins = 0;\n\t    }\n\t    else\n\t\t++open_wins;\n\t}\n\n\t// Without the \":tab\" modifier only do the current tab page.\n\tif (had_tab == 0 || tpnext == NULL)\n\t    break;\n\tgoto_tabpage_tp(tpnext, TRUE, TRUE);\n    }\n\n    /*\n     * Go through the buffer list.  When a buffer doesn't have a window yet,\n     * open one.  Otherwise move the window to the right position.\n     * Watch out for autocommands that delete buffers or windows!\n     */\n    // Don't execute Win/Buf Enter/Leave autocommands here.\n    ++autocmd_no_enter;\n    win_enter(lastwin, FALSE);\n    ++autocmd_no_leave;\n    for (buf = firstbuf; buf != NULL && open_wins < count; buf = buf->b_next)\n    {\n\t// Check if this buffer needs a window\n\tif ((!all && buf->b_ml.ml_mfp == NULL) || !buf->b_p_bl)\n\t    continue;\n\n\tif (had_tab != 0)\n\t{\n\t    // With the \":tab\" modifier don't move the window.\n\t    if (buf->b_nwindows > 0)\n\t\twp = lastwin;\t    // buffer has a window, skip it\n\t    else\n\t\twp = NULL;\n\t}\n\telse\n\t{\n\t    // Check if this buffer already has a window\n\t    FOR_ALL_WINDOWS(wp)\n\t\tif (wp->w_buffer == buf)\n\t\t    break;\n\t    // If the buffer already has a window, move it\n\t    if (wp != NULL)\n\t\twin_move_after(wp, curwin);\n\t}\n\n\tif (wp == NULL && split_ret == OK)\n\t{\n\t    bufref_T\tbufref;\n\n\t    set_bufref(&bufref, buf);\n\n\t    // Split the window and put the buffer in it\n\t    p_ea_save = p_ea;\n\t    p_ea = TRUE;\t\t// use space from all windows\n\t    split_ret = win_split(0, WSP_ROOM | WSP_BELOW);\n\t    ++open_wins;\n\t    p_ea = p_ea_save;\n\t    if (split_ret == FAIL)\n\t\tcontinue;\n\n\t    // Open the buffer in this window.\n\t    swap_exists_action = SEA_DIALOG;\n\t    set_curbuf(buf, DOBUF_GOTO);\n\t    if (!bufref_valid(&bufref))\n\t    {\n\t\t// autocommands deleted the buffer!!!\n\t\tswap_exists_action = SEA_NONE;\n\t\tbreak;\n\t    }\n\t    if (swap_exists_action == SEA_QUIT)\n\t    {\n#if defined(FEAT_EVAL)\n\t\tcleanup_T   cs;\n\n\t\t// Reset the error/interrupt/exception state here so that\n\t\t// aborting() returns FALSE when closing a window.\n\t\tenter_cleanup(&cs);\n#endif\n\n\t\t// User selected Quit at ATTENTION prompt; close this window.\n\t\twin_close(curwin, TRUE);\n\t\t--open_wins;\n\t\tswap_exists_action = SEA_NONE;\n\t\tswap_exists_did_quit = TRUE;\n\n#if defined(FEAT_EVAL)\n\t\t// Restore the error/interrupt/exception state if not\n\t\t// discarded by a new aborting error, interrupt, or uncaught\n\t\t// exception.\n\t\tleave_cleanup(&cs);\n#endif\n\t    }\n\t    else\n\t\thandle_swap_exists(NULL);\n\t}\n\n\tui_breakcheck();\n\tif (got_int)\n\t{\n\t    (void)vgetc();\t// only break the file loading, not the rest\n\t    break;\n\t}\n#ifdef FEAT_EVAL\n\t// Autocommands deleted the buffer or aborted script processing!!!\n\tif (aborting())\n\t    break;\n#endif\n\t// When \":tab\" was used open a new tab for a new window repeatedly.\n\tif (had_tab > 0 && tabpage_index(NULL) <= p_tpm)\n\t    cmdmod.cmod_tab = 9999;\n    }\n    --autocmd_no_enter;\n    win_enter(firstwin, FALSE);\t\t// back to first window\n    --autocmd_no_leave;\n\n    /*\n     * Close superfluous windows.\n     */\n    for (wp = lastwin; open_wins > count; )\n    {\n\tr = (buf_hide(wp->w_buffer) || !bufIsChanged(wp->w_buffer)\n\t\t\t\t     || autowrite(wp->w_buffer, FALSE) == OK);\n\tif (!win_valid(wp))\n\t{\n\t    // BufWrite Autocommands made the window invalid, start over\n\t    wp = lastwin;\n\t}\n\telse if (r)\n\t{\n\t    win_close(wp, !buf_hide(wp->w_buffer));\n\t    --open_wins;\n\t    wp = lastwin;\n\t}\n\telse\n\t{\n\t    wp = wp->w_prev;\n\t    if (wp == NULL)\n\t\tbreak;\n\t}\n    }\n}\n\n\nstatic int  chk_modeline(linenr_T, int);\n\n/*\n * do_modelines() - process mode lines for the current file\n *\n * \"flags\" can be:\n * OPT_WINONLY\t    only set options local to window\n * OPT_NOWIN\t    don't set options local to window\n *\n * Returns immediately if the \"ml\" option isn't set.\n */\n    void\ndo_modelines(int flags)\n{\n    linenr_T\tlnum;\n    int\t\tnmlines;\n    static int\tentered = 0;\n\n    if (!curbuf->b_p_ml || (nmlines = (int)p_mls) == 0)\n\treturn;\n\n    // Disallow recursive entry here.  Can happen when executing a modeline\n    // triggers an autocommand, which reloads modelines with a \":do\".\n    if (entered)\n\treturn;\n\n    ++entered;\n    for (lnum = 1; curbuf->b_p_ml && lnum <= curbuf->b_ml.ml_line_count && lnum <= nmlines;\n\t\t\t\t\t\t\t\t       ++lnum)\n\tif (chk_modeline(lnum, flags) == FAIL)\n\t    nmlines = 0;\n\n    for (lnum = curbuf->b_ml.ml_line_count; curbuf->b_p_ml && lnum > 0 && lnum > nmlines\n\t\t       && lnum > curbuf->b_ml.ml_line_count - nmlines; --lnum)\n\tif (chk_modeline(lnum, flags) == FAIL)\n\t    nmlines = 0;\n    --entered;\n}\n\n#include \"version.h\"\t\t// for version number\n\n/*\n * chk_modeline() - check a single line for a mode string\n * Return FAIL if an error encountered.\n */\n    static int\nchk_modeline(\n    linenr_T\tlnum,\n    int\t\tflags)\t\t// Same as for do_modelines().\n{\n    char_u\t*s;\n    char_u\t*e;\n    char_u\t*linecopy;\t\t// local copy of any modeline found\n    int\t\tprev;\n    int\t\tvers;\n    int\t\tend;\n    int\t\tretval = OK;\n    sctx_T\tsave_current_sctx;\n\n    ESTACK_CHECK_DECLARATION\n\n    prev = -1;\n    for (s = ml_get(lnum); *s != NUL; ++s)\n    {\n\tif (prev == -1 || vim_isspace(prev))\n\t{\n\t    if ((prev != -1 && STRNCMP(s, \"ex:\", (size_t)3) == 0)\n\t\t    || STRNCMP(s, \"vi:\", (size_t)3) == 0)\n\t\tbreak;\n\t    // Accept both \"vim\" and \"Vim\".\n\t    if ((s[0] == 'v' || s[0] == 'V') && s[1] == 'i' && s[2] == 'm')\n\t    {\n\t\tif (s[3] == '<' || s[3] == '=' || s[3] == '>')\n\t\t    e = s + 4;\n\t\telse\n\t\t    e = s + 3;\n\t\tvers = getdigits(&e);\n\t\tif (*e == ':'\n\t\t\t&& (s[0] != 'V'\n\t\t\t\t  || STRNCMP(skipwhite(e + 1), \"set\", 3) == 0)\n\t\t\t&& (s[3] == ':'\n\t\t\t    || (VIM_VERSION_100 >= vers && isdigit(s[3]))\n\t\t\t    || (VIM_VERSION_100 < vers && s[3] == '<')\n\t\t\t    || (VIM_VERSION_100 > vers && s[3] == '>')\n\t\t\t    || (VIM_VERSION_100 == vers && s[3] == '=')))\n\t\t    break;\n\t    }\n\t}\n\tprev = *s;\n    }\n\n    if (*s)\n    {\n\tdo\t\t\t\t// skip over \"ex:\", \"vi:\" or \"vim:\"\n\t    ++s;\n\twhile (s[-1] != ':');\n\n\ts = linecopy = vim_strsave(s);\t// copy the line, it will change\n\tif (linecopy == NULL)\n\t    return FAIL;\n\n\t// prepare for emsg()\n\testack_push(ETYPE_MODELINE, (char_u *)\"modelines\", lnum);\n\tESTACK_CHECK_SETUP\n\n\tend = FALSE;\n\twhile (end == FALSE)\n\t{\n\t    s = skipwhite(s);\n\t    if (*s == NUL)\n\t\tbreak;\n\n\t    /*\n\t     * Find end of set command: ':' or end of line.\n\t     * Skip over \"\\:\", replacing it with \":\".\n\t     */\n\t    for (e = s; *e != ':' && *e != NUL; ++e)\n\t\tif (e[0] == '\\\\' && e[1] == ':')\n\t\t    STRMOVE(e, e + 1);\n\t    if (*e == NUL)\n\t\tend = TRUE;\n\n\t    /*\n\t     * If there is a \"set\" command, require a terminating ':' and\n\t     * ignore the stuff after the ':'.\n\t     * \"vi:set opt opt opt: foo\" -- foo not interpreted\n\t     * \"vi:opt opt opt: foo\" -- foo interpreted\n\t     * Accept \"se\" for compatibility with Elvis.\n\t     */\n\t    if (STRNCMP(s, \"set \", (size_t)4) == 0\n\t\t    || STRNCMP(s, \"se \", (size_t)3) == 0)\n\t    {\n\t\tif (*e != ':')\t\t// no terminating ':'?\n\t\t    break;\n\t\tend = TRUE;\n\t\ts = vim_strchr(s, ' ') + 1;\n\t    }\n\t    *e = NUL;\t\t\t// truncate the set command\n\n\t    if (*s != NUL)\t\t// skip over an empty \"::\"\n\t    {\n\t\tint secure_save = secure;\n\n\t\tsave_current_sctx = current_sctx;\n\t\tcurrent_sctx.sc_version = 1;\n#ifdef FEAT_EVAL\n\t\tcurrent_sctx.sc_sid = SID_MODELINE;\n\t\tcurrent_sctx.sc_seq = 0;\n\t\tcurrent_sctx.sc_lnum = lnum;\n#endif\n\n\t\t// Make sure no risky things are executed as a side effect.\n\t\tsecure = 1;\n\n\t\tretval = do_set(s, OPT_MODELINE | OPT_LOCAL | flags);\n\n\t\tsecure = secure_save;\n\t\tcurrent_sctx = save_current_sctx;\n\t\tif (retval == FAIL)\t\t// stop if error found\n\t\t    break;\n\t    }\n\t    s = e + 1;\t\t\t// advance to next part\n\t}\n\n\tESTACK_CHECK_NOW\n\testack_pop();\n\tvim_free(linecopy);\n    }\n    return retval;\n}\n\n/*\n * Return TRUE if \"buf\" is a normal buffer, 'buftype' is empty.\n */\n    int\nbt_normal(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt[0] == NUL;\n}\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n/*\n * Return TRUE if \"buf\" is the quickfix buffer.\n */\n    int\nbt_quickfix(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt[0] == 'q';\n}\n#endif\n\n#if defined(FEAT_TERMINAL) || defined(PROTO)\n/*\n * Return TRUE if \"buf\" is a terminal buffer.\n */\n    int\nbt_terminal(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt[0] == 't';\n}\n#endif\n\n/*\n * Return TRUE if \"buf\" is a help buffer.\n */\n    int\nbt_help(buf_T *buf)\n{\n    return buf != NULL && buf->b_help;\n}\n\n/*\n * Return TRUE if \"buf\" is a prompt buffer.\n */\n    int\nbt_prompt(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt[0] == 'p' && buf->b_p_bt[1] == 'r';\n}\n\n#if defined(FEAT_PROP_POPUP) || defined(PROTO)\n/*\n * Return TRUE if \"buf\" is a buffer for a popup window.\n */\n    int\nbt_popup(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt != NULL\n\t&& buf->b_p_bt[0] == 'p' && buf->b_p_bt[1] == 'o';\n}\n#endif\n\n/*\n * Return TRUE if \"buf\" is a \"nofile\", \"acwrite\", \"terminal\" or \"prompt\"\n * buffer.  This means the buffer name is not a file name.\n */\n    int\nbt_nofilename(buf_T *buf)\n{\n    return buf != NULL && ((buf->b_p_bt[0] == 'n' && buf->b_p_bt[2] == 'f')\n\t    || buf->b_p_bt[0] == 'a'\n\t    || buf->b_p_bt[0] == 't'\n\t    || buf->b_p_bt[0] == 'p');\n}\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n/*\n * Return TRUE if \"buf\" has 'buftype' set to \"nofile\".\n */\n    int\nbt_nofile(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt[0] == 'n' && buf->b_p_bt[2] == 'f';\n}\n#endif\n\n/*\n * Return TRUE if \"buf\" is a \"nowrite\", \"nofile\", \"terminal\" or \"prompt\"\n * buffer.\n */\n    int\nbt_dontwrite(buf_T *buf)\n{\n    return buf != NULL && (buf->b_p_bt[0] == 'n'\n\t\t || buf->b_p_bt[0] == 't'\n\t\t || buf->b_p_bt[0] == 'p');\n}\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n    int\nbt_dontwrite_msg(buf_T *buf)\n{\n    if (bt_dontwrite(buf))\n    {\n\temsg(_(e_cannot_write_buftype_option_is_set));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n#endif\n\n/*\n * Return TRUE if the buffer should be hidden, according to 'hidden', \":hide\"\n * and 'bufhidden'.\n */\n    int\nbuf_hide(buf_T *buf)\n{\n    // 'bufhidden' overrules 'hidden' and \":hide\", check it first\n    switch (buf->b_p_bh[0])\n    {\n\tcase 'u':\t\t    // \"unload\"\n\tcase 'w':\t\t    // \"wipe\"\n\tcase 'd': return FALSE;\t    // \"delete\"\n\tcase 'h': return TRUE;\t    // \"hide\"\n    }\n    return (p_hid || (cmdmod.cmod_flags & CMOD_HIDE));\n}\n\n/*\n * Return special buffer name.\n * Returns NULL when the buffer has a normal file name.\n */\n    char_u *\nbuf_spname(buf_T *buf)\n{\n#if defined(FEAT_QUICKFIX)\n    if (bt_quickfix(buf))\n    {\n\t/*\n\t * Differentiate between the quickfix and location list buffers using\n\t * the buffer number stored in the global quickfix stack.\n\t */\n\tif (buf->b_fnum == qf_stack_get_bufnr())\n\t    return (char_u *)_(msg_qflist);\n\telse\n\t    return (char_u *)_(msg_loclist);\n    }\n#endif\n\n    // There is no _file_ when 'buftype' is \"nofile\", b_sfname\n    // contains the name as specified by the user.\n    if (bt_nofilename(buf))\n    {\n#ifdef FEAT_TERMINAL\n\tif (buf->b_term != NULL)\n\t    return term_get_status_text(buf->b_term);\n#endif\n\tif (buf->b_fname != NULL)\n\t    return buf->b_fname;\n#ifdef FEAT_JOB_CHANNEL\n\tif (bt_prompt(buf))\n\t    return (char_u *)_(\"[Prompt]\");\n#endif\n#ifdef FEAT_PROP_POPUP\n\tif (bt_popup(buf))\n\t    return (char_u *)_(\"[Popup]\");\n#endif\n\treturn (char_u *)_(\"[Scratch]\");\n    }\n\n    if (buf->b_fname == NULL)\n\treturn buf_get_fname(buf);\n    return NULL;\n}\n\n/*\n * Get \"buf->b_fname\", use \"[No Name]\" if it is NULL.\n */\n    char_u *\nbuf_get_fname(buf_T *buf)\n{\n    if (buf->b_fname == NULL)\n\treturn (char_u *)_(\"[No Name]\");\n    return buf->b_fname;\n}\n\n/*\n * Set 'buflisted' for curbuf to \"on\" and trigger autocommands if it changed.\n */\n    void\nset_buflisted(int on)\n{\n    if (on != curbuf->b_p_bl)\n    {\n\tcurbuf->b_p_bl = on;\n\tif (on)\n\t    apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, curbuf);\n\telse\n\t    apply_autocmds(EVENT_BUFDELETE, NULL, NULL, FALSE, curbuf);\n    }\n}\n\n/*\n * Read the file for \"buf\" again and check if the contents changed.\n * Return TRUE if it changed or this could not be checked.\n */\n    int\nbuf_contents_changed(buf_T *buf)\n{\n    buf_T\t*newbuf;\n    int\t\tdiffer = TRUE;\n    linenr_T\tlnum;\n    aco_save_T\taco;\n    exarg_T\tea;\n\n    // Allocate a buffer without putting it in the buffer list.\n    newbuf = buflist_new(NULL, NULL, (linenr_T)1, BLN_DUMMY);\n    if (newbuf == NULL)\n\treturn TRUE;\n\n    // Force the 'fileencoding' and 'fileformat' to be equal.\n    if (prep_exarg(&ea, buf) == FAIL)\n    {\n\twipe_buffer(newbuf, FALSE);\n\treturn TRUE;\n    }\n\n    // set curwin/curbuf to buf and save a few things\n    aucmd_prepbuf(&aco, newbuf);\n\n    if (ml_open(curbuf) == OK\n\t    && readfile(buf->b_ffname, buf->b_fname,\n\t\t\t\t  (linenr_T)0, (linenr_T)0, (linenr_T)MAXLNUM,\n\t\t\t\t\t    &ea, READ_NEW | READ_DUMMY) == OK)\n    {\n\t// compare the two files line by line\n\tif (buf->b_ml.ml_line_count == curbuf->b_ml.ml_line_count)\n\t{\n\t    differ = FALSE;\n\t    for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum)\n\t\tif (STRCMP(ml_get_buf(buf, lnum, FALSE), ml_get(lnum)) != 0)\n\t\t{\n\t\t    differ = TRUE;\n\t\t    break;\n\t\t}\n\t}\n    }\n    vim_free(ea.cmd);\n\n    // restore curwin/curbuf and a few other things\n    aucmd_restbuf(&aco);\n\n    if (curbuf != newbuf)\t// safety check\n\twipe_buffer(newbuf, FALSE);\n\n    return differ;\n}\n\n/*\n * Wipe out a buffer and decrement the last buffer number if it was used for\n * this buffer.  Call this to wipe out a temp buffer that does not contain any\n * marks.\n */\n    void\nwipe_buffer(\n    buf_T\t*buf,\n    int\t\taucmd)\t    // When TRUE trigger autocommands.\n{\n    if (buf->b_fnum == top_file_num - 1)\n\t--top_file_num;\n\n    if (!aucmd)\t\t    // Don't trigger BufDelete autocommands here.\n\tblock_autocmds();\n\n    close_buffer(NULL, buf, DOBUF_WIPE, FALSE, TRUE);\n\n    if (!aucmd)\n\tunblock_autocmds();\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * ex_getln.c: Functions for entering and editing an Ex command line.\n */\n\n#include \"vim.h\"\n\n#ifndef MAX\n# define MAX(x,y) ((x) > (y) ? (x) : (y))\n#endif\n\n// Return value when handling keys in command-line mode.\n#define CMDLINE_NOT_CHANGED\t1\n#define CMDLINE_CHANGED\t\t2\n#define GOTO_NORMAL_MODE\t3\n#define PROCESS_NEXT_KEY\t4\n\n// The current cmdline_info.  It is initialized in getcmdline() and after that\n// used by other functions.  When invoking getcmdline() recursively it needs\n// to be saved with save_cmdline() and restored with restore_cmdline().\nstatic cmdline_info_T ccline;\n\n#ifdef FEAT_EVAL\nstatic int\tnew_cmdpos;\t// position set by set_cmdline_pos()\n#endif\n\nstatic int\textra_char = NUL;  // extra character to display when redrawing\n\t\t\t\t   // the command line\nstatic int\textra_char_shift;\n\n#ifdef FEAT_RIGHTLEFT\nstatic int\tcmd_hkmap = 0;\t// Hebrew mapping during command line\n#endif\n\nstatic char_u\t*getcmdline_int(int firstc, long count, int indent, int clear_ccline);\nstatic int\tcmdline_charsize(int idx);\nstatic void\tset_cmdspos(void);\nstatic void\tset_cmdspos_cursor(void);\nstatic void\tcorrect_cmdspos(int idx, int cells);\nstatic void\talloc_cmdbuff(int len);\nstatic void\tdraw_cmdline(int start, int len);\nstatic void\tsave_cmdline(cmdline_info_T *ccp);\nstatic void\trestore_cmdline(cmdline_info_T *ccp);\nstatic int\tcmdline_paste(int regname, int literally, int remcr);\nstatic void\tredrawcmdprompt(void);\nstatic int\tccheck_abbr(int);\n#ifdef FEAT_SEARCH_EXTRA\nstatic int\tempty_pattern_magic(char_u *pat, size_t len, magic_T magic_val);\n#endif\n\n#ifdef FEAT_CMDWIN\nstatic int\topen_cmdwin(void);\n\nstatic int\tcedit_key INIT(= -1);\t// key value of 'cedit' option\n#endif\n\n\n    static void\ntrigger_cmd_autocmd(int typechar, int evt)\n{\n    char_u\ttypestr[2];\n\n    typestr[0] = typechar;\n    typestr[1] = NUL;\n    apply_autocmds(evt, typestr, typestr, FALSE, curbuf);\n}\n\n/*\n * Abandon the command line.\n */\n    static void\nabandon_cmdline(void)\n{\n    VIM_CLEAR(ccline.cmdbuff);\n    if (msg_scrolled == 0)\n\tcompute_cmdrow();\n    msg(\"\");\n    redraw_cmdline = TRUE;\n}\n\n#ifdef FEAT_SEARCH_EXTRA\n/*\n * Guess that the pattern matches everything.  Only finds specific cases, such\n * as a trailing \\|, which can happen while typing a pattern.\n */\n    static int\nempty_pattern(char_u *p, int delim)\n{\n    size_t\tn = STRLEN(p);\n    magic_T\tmagic_val = MAGIC_ON;\n\n    if (n > 0)\n\t(void) skip_regexp_ex(p, delim, magic_isset(), NULL, NULL, &magic_val);\n    else\n\treturn TRUE;\n\n    return empty_pattern_magic(p, n, magic_val);\n}\n\n    static int\nempty_pattern_magic(char_u *p, size_t len, magic_T magic_val)\n{\n    // remove trailing \\v and the like\n    while (len >= 2 && p[len - 2] == '\\\\'\n\t\t\t&& vim_strchr((char_u *)\"mMvVcCZ\", p[len - 1]) != NULL)\n       len -= 2;\n\n    // true, if the pattern is empty, or the pattern ends with \\| and magic is\n    // set (or it ends with '|' and very magic is set)\n    return len == 0 || (len > 1\n\t    && ((p[len - 2] == '\\\\'\n\t\t\t\t && p[len - 1] == '|' && magic_val == MAGIC_ON)\n\t\t|| (p[len - 2] != '\\\\'\n\t\t\t     && p[len - 1] == '|' && magic_val == MAGIC_ALL)));\n}\n\n// Struct to store the viewstate during 'incsearch' highlighting.\ntypedef struct {\n    colnr_T\tvs_curswant;\n    colnr_T\tvs_leftcol;\n    linenr_T\tvs_topline;\n# ifdef FEAT_DIFF\n    int\t\tvs_topfill;\n# endif\n    linenr_T\tvs_botline;\n    linenr_T\tvs_empty_rows;\n} viewstate_T;\n\n    static void\nsave_viewstate(viewstate_T *vs)\n{\n    vs->vs_curswant = curwin->w_curswant;\n    vs->vs_leftcol = curwin->w_leftcol;\n    vs->vs_topline = curwin->w_topline;\n# ifdef FEAT_DIFF\n    vs->vs_topfill = curwin->w_topfill;\n# endif\n    vs->vs_botline = curwin->w_botline;\n    vs->vs_empty_rows = curwin->w_empty_rows;\n}\n\n    static void\nrestore_viewstate(viewstate_T *vs)\n{\n    curwin->w_curswant = vs->vs_curswant;\n    curwin->w_leftcol = vs->vs_leftcol;\n    curwin->w_topline = vs->vs_topline;\n# ifdef FEAT_DIFF\n    curwin->w_topfill = vs->vs_topfill;\n# endif\n    curwin->w_botline = vs->vs_botline;\n    curwin->w_empty_rows = vs->vs_empty_rows;\n}\n\n// Struct to store the state of 'incsearch' highlighting.\ntypedef struct {\n    pos_T\tsearch_start;\t// where 'incsearch' starts searching\n    pos_T\tsave_cursor;\n    int\t\twinid;\t\t// window where this state is valid\n    viewstate_T\tinit_viewstate;\n    viewstate_T\told_viewstate;\n    pos_T\tmatch_start;\n    pos_T\tmatch_end;\n    int\t\tdid_incsearch;\n    int\t\tincsearch_postponed;\n    optmagic_T\tmagic_overruled_save;\n} incsearch_state_T;\n\n    static void\ninit_incsearch_state(incsearch_state_T *is_state)\n{\n    is_state->winid = curwin->w_id;\n    is_state->match_start = curwin->w_cursor;\n    is_state->did_incsearch = FALSE;\n    is_state->incsearch_postponed = FALSE;\n    is_state->magic_overruled_save = magic_overruled;\n    CLEAR_POS(&is_state->match_end);\n    is_state->save_cursor = curwin->w_cursor;  // may be restored later\n    is_state->search_start = curwin->w_cursor;\n    save_viewstate(&is_state->init_viewstate);\n    save_viewstate(&is_state->old_viewstate);\n}\n\n/*\n * First move cursor to end of match, then to the start.  This\n * moves the whole match onto the screen when 'nowrap' is set.\n */\n    static void\nset_search_match(pos_T *t)\n{\n    t->lnum += search_match_lines;\n    t->col = search_match_endcol;\n    if (t->lnum > curbuf->b_ml.ml_line_count)\n    {\n\tt->lnum = curbuf->b_ml.ml_line_count;\n\tcoladvance((colnr_T)MAXCOL);\n    }\n}\n\n/*\n * Return TRUE when 'incsearch' highlighting is to be done.\n * Sets search_first_line and search_last_line to the address range.\n * May change the last search pattern.\n */\n    static int\ndo_incsearch_highlighting(\n\tint\t\t    firstc,\n\tint\t\t    *search_delim,\n\tincsearch_state_T   *is_state,\n\tint\t\t    *skiplen,\n\tint\t\t    *patlen)\n{\n    char_u\t*cmd;\n    cmdmod_T\tdummy_cmdmod;\n    char_u\t*p;\n    int\t\tdelim_optional = FALSE;\n    int\t\tdelim;\n    char_u\t*end;\n    char\t*dummy;\n    exarg_T\tea;\n    pos_T\tsave_cursor;\n    int\t\tuse_last_pat;\n    int\t\tretval = FALSE;\n    magic_T     magic = 0;\n\n    *skiplen = 0;\n    *patlen = ccline.cmdlen;\n\n    if (!p_is || cmd_silent)\n\treturn FALSE;\n\n    // by default search all lines\n    search_first_line = 0;\n    search_last_line = MAXLNUM;\n\n    if (firstc == '/' || firstc == '?')\n    {\n\t*search_delim = firstc;\n\treturn TRUE;\n    }\n    if (firstc != ':')\n\treturn FALSE;\n\n    ++emsg_off;\n    CLEAR_FIELD(ea);\n    ea.line1 = 1;\n    ea.line2 = 1;\n    ea.cmd = ccline.cmdbuff;\n    ea.addr_type = ADDR_LINES;\n\n    CLEAR_FIELD(dummy_cmdmod);\n    parse_command_modifiers(&ea, &dummy, &dummy_cmdmod, TRUE);\n\n    cmd = skip_range(ea.cmd, TRUE, NULL);\n    if (vim_strchr((char_u *)\"sgvl\", *cmd) == NULL)\n\tgoto theend;\n\n    // Skip over \"substitute\" to find the pattern separator.\n    for (p = cmd; ASCII_ISALPHA(*p); ++p)\n\t;\n    if (*skipwhite(p) == NUL)\n\tgoto theend;\n\n    if (STRNCMP(cmd, \"substitute\", p - cmd) == 0\n\t    || STRNCMP(cmd, \"smagic\", p - cmd) == 0\n\t    || STRNCMP(cmd, \"snomagic\", MAX(p - cmd, 3)) == 0\n\t    || STRNCMP(cmd, \"vglobal\", p - cmd) == 0)\n    {\n\tif (*cmd == 's' && cmd[1] == 'm')\n\t    magic_overruled = OPTION_MAGIC_ON;\n\telse if (*cmd == 's' && cmd[1] == 'n')\n\t    magic_overruled = OPTION_MAGIC_OFF;\n    }\n    else if (STRNCMP(cmd, \"sort\", MAX(p - cmd, 3)) == 0)\n    {\n\t// skip over ! and flags\n\tif (*p == '!')\n\t    p = skipwhite(p + 1);\n\twhile (ASCII_ISALPHA(*(p = skipwhite(p))))\n\t    ++p;\n\tif (*p == NUL)\n\t    goto theend;\n    }\n    else if (STRNCMP(cmd, \"vimgrep\", MAX(p - cmd, 3)) == 0\n\t|| STRNCMP(cmd, \"vimgrepadd\", MAX(p - cmd, 8)) == 0\n\t|| STRNCMP(cmd, \"lvimgrep\", MAX(p - cmd, 2)) == 0\n\t|| STRNCMP(cmd, \"lvimgrepadd\", MAX(p - cmd, 9)) == 0\n\t|| STRNCMP(cmd, \"global\", p - cmd) == 0)\n    {\n\t// skip over \"!\"\n\tif (*p == '!')\n\t{\n\t    p++;\n\t    if (*skipwhite(p) == NUL)\n\t\tgoto theend;\n\t}\n\tif (*cmd != 'g')\n\t    delim_optional = TRUE;\n    }\n    else\n\tgoto theend;\n\n    p = skipwhite(p);\n    delim = (delim_optional && vim_isIDc(*p)) ? ' ' : *p++;\n    *search_delim = delim;\n    end = skip_regexp_ex(p, delim, magic_isset(), NULL, NULL, &magic);\n\n    use_last_pat = end == p && *end == delim;\n\n    if (end == p && !use_last_pat)\n\tgoto theend;\n\n    // Don't do 'hlsearch' highlighting if the pattern matches everything.\n    if (!use_last_pat)\n    {\n\tchar c = *end;\n\tint  empty;\n\n\t*end = NUL;\n\tempty = empty_pattern_magic(p, STRLEN(p), magic);\n\t*end = c;\n\tif (empty)\n\t    goto theend;\n    }\n\n    // found a non-empty pattern or //\n    *skiplen = (int)(p - ccline.cmdbuff);\n    *patlen = (int)(end - p);\n\n    // parse the address range\n    save_cursor = curwin->w_cursor;\n    curwin->w_cursor = is_state->search_start;\n    parse_cmd_address(&ea, &dummy, TRUE);\n    if (ea.addr_count > 0)\n    {\n\t// Allow for reverse match.\n\tif (ea.line2 < ea.line1)\n\t{\n\t    search_first_line = ea.line2;\n\t    search_last_line = ea.line1;\n\t}\n\telse\n\t{\n\t    search_first_line = ea.line1;\n\t    search_last_line = ea.line2;\n\t}\n    }\n    else if (cmd[0] == 's' && cmd[1] != 'o')\n    {\n\t// :s defaults to the current line\n\tsearch_first_line = curwin->w_cursor.lnum;\n\tsearch_last_line = curwin->w_cursor.lnum;\n    }\n\n    curwin->w_cursor = save_cursor;\n    retval = TRUE;\ntheend:\n    --emsg_off;\n    return retval;\n}\n\n    static void\nfinish_incsearch_highlighting(\n\tint gotesc,\n\tincsearch_state_T *is_state,\n\tint call_update_screen)\n{\n    if (is_state->did_incsearch)\n    {\n\tis_state->did_incsearch = FALSE;\n\tif (gotesc)\n\t    curwin->w_cursor = is_state->save_cursor;\n\telse\n\t{\n\t    if (!EQUAL_POS(is_state->save_cursor, is_state->search_start))\n\t    {\n\t\t// put the '\" mark at the original position\n\t\tcurwin->w_cursor = is_state->save_cursor;\n\t\tsetpcmark();\n\t    }\n\t    curwin->w_cursor = is_state->search_start;\n\t}\n\trestore_viewstate(&is_state->old_viewstate);\n\thighlight_match = FALSE;\n\n\t// by default search all lines\n\tsearch_first_line = 0;\n\tsearch_last_line = MAXLNUM;\n\n\tmagic_overruled = is_state->magic_overruled_save;\n\n\tvalidate_cursor();\t// needed for TAB\n\tredraw_all_later(SOME_VALID);\n\tif (call_update_screen)\n\t    update_screen(SOME_VALID);\n    }\n}\n\n/*\n * Do 'incsearch' highlighting if desired.\n */\n    static void\nmay_do_incsearch_highlighting(\n\tint\t\t    firstc,\n\tlong\t\t    count,\n\tincsearch_state_T   *is_state)\n{\n    int\t\tskiplen, patlen;\n    int\t\tfound;  // do_search() result\n    pos_T\tend_pos;\n#ifdef FEAT_RELTIME\n    proftime_T\ttm;\n    searchit_arg_T sia;\n#endif\n    int\t\tnext_char;\n    int\t\tuse_last_pat;\n    int\t\tdid_do_incsearch = is_state->did_incsearch;\n    int\t\tsearch_delim;\n\n    // Parsing range may already set the last search pattern.\n    // NOTE: must call restore_last_search_pattern() before returning!\n    save_last_search_pattern();\n\n    if (!do_incsearch_highlighting(firstc, &search_delim, is_state,\n\t\t\t\t\t\t\t    &skiplen, &patlen))\n    {\n\trestore_last_search_pattern();\n\tfinish_incsearch_highlighting(FALSE, is_state, TRUE);\n\tif (did_do_incsearch && vpeekc() == NUL)\n\t    // may have skipped a redraw, do it now\n\t    redrawcmd();\n\treturn;\n    }\n\n    // If there is a character waiting, search and redraw later.\n    if (char_avail())\n    {\n\trestore_last_search_pattern();\n\tis_state->incsearch_postponed = TRUE;\n\treturn;\n    }\n    is_state->incsearch_postponed = FALSE;\n\n    if (search_first_line == 0)\n\t// start at the original cursor position\n\tcurwin->w_cursor = is_state->search_start;\n    else if (search_first_line > curbuf->b_ml.ml_line_count)\n    {\n\t// start after the last line\n\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\tcurwin->w_cursor.col = MAXCOL;\n    }\n    else\n    {\n\t// start at the first line in the range\n\tcurwin->w_cursor.lnum = search_first_line;\n\tcurwin->w_cursor.col = 0;\n    }\n\n    // Use the previous pattern for \":s//\".\n    next_char = ccline.cmdbuff[skiplen + patlen];\n    use_last_pat = patlen == 0 && skiplen > 0\n\t\t\t\t   && ccline.cmdbuff[skiplen - 1] == next_char;\n\n    // If there is no pattern, don't do anything.\n    if (patlen == 0 && !use_last_pat)\n    {\n\tfound = 0;\n\tset_no_hlsearch(TRUE); // turn off previous highlight\n\tredraw_all_later(SOME_VALID);\n    }\n    else\n    {\n\tint search_flags = SEARCH_OPT + SEARCH_NOOF + SEARCH_PEEK;\n\n\tcursor_off();\t// so the user knows we're busy\n\tout_flush();\n\t++emsg_off;\t// so it doesn't beep if bad expr\n#ifdef FEAT_RELTIME\n\t// Set the time limit to half a second.\n\tprofile_setlimit(500L, &tm);\n#endif\n\tif (!p_hls)\n\t    search_flags += SEARCH_KEEP;\n\tif (search_first_line != 0)\n\t    search_flags += SEARCH_START;\n\tccline.cmdbuff[skiplen + patlen] = NUL;\n#ifdef FEAT_RELTIME\n\tCLEAR_FIELD(sia);\n\tsia.sa_tm = &tm;\n#endif\n\tfound = do_search(NULL, firstc == ':' ? '/' : firstc, search_delim,\n\t\t\t\t ccline.cmdbuff + skiplen, count, search_flags,\n#ifdef FEAT_RELTIME\n\t\t&sia\n#else\n\t\tNULL\n#endif\n\t\t);\n\tccline.cmdbuff[skiplen + patlen] = next_char;\n\t--emsg_off;\n\n\tif (curwin->w_cursor.lnum < search_first_line\n\t\t|| curwin->w_cursor.lnum > search_last_line)\n\t{\n\t    // match outside of address range\n\t    found = 0;\n\t    curwin->w_cursor = is_state->search_start;\n\t}\n\n\t// if interrupted while searching, behave like it failed\n\tif (got_int)\n\t{\n\t    (void)vpeekc();\t// remove <C-C> from input stream\n\t    got_int = FALSE;\t// don't abandon the command line\n\t    found = 0;\n\t}\n\telse if (char_avail())\n\t    // cancelled searching because a char was typed\n\t    is_state->incsearch_postponed = TRUE;\n    }\n    if (found != 0)\n\thighlight_match = TRUE;\t\t// highlight position\n    else\n\thighlight_match = FALSE;\t// remove highlight\n\n    // First restore the old curwin values, so the screen is positioned in the\n    // same way as the actual search command.\n    restore_viewstate(&is_state->old_viewstate);\n    changed_cline_bef_curs();\n    update_topline();\n\n    if (found != 0)\n    {\n\tpos_T\t    save_pos = curwin->w_cursor;\n\n\tis_state->match_start = curwin->w_cursor;\n\tset_search_match(&curwin->w_cursor);\n\tvalidate_cursor();\n\tend_pos = curwin->w_cursor;\n\tis_state->match_end = end_pos;\n\tcurwin->w_cursor = save_pos;\n    }\n    else\n\tend_pos = curwin->w_cursor; // shutup gcc 4\n\n    // Disable 'hlsearch' highlighting if the pattern matches everything.\n    // Avoids a flash when typing \"foo\\|\".\n    if (!use_last_pat)\n    {\n\tnext_char = ccline.cmdbuff[skiplen + patlen];\n\tccline.cmdbuff[skiplen + patlen] = NUL;\n\tif (empty_pattern(ccline.cmdbuff + skiplen, search_delim)\n\t\t\t\t\t\t\t       && !no_hlsearch)\n\t{\n\t    redraw_all_later(SOME_VALID);\n\t    set_no_hlsearch(TRUE);\n\t}\n\tccline.cmdbuff[skiplen + patlen] = next_char;\n    }\n\n    validate_cursor();\n    // May redraw the status line to show the cursor position.\n    if (p_ru && curwin->w_status_height > 0)\n\tcurwin->w_redr_status = TRUE;\n\n    update_screen(SOME_VALID);\n    highlight_match = FALSE;\n    restore_last_search_pattern();\n\n    // Leave it at the end to make CTRL-R CTRL-W work.  But not when beyond the\n    // end of the pattern, e.g. for \":s/pat/\".\n    if (ccline.cmdbuff[skiplen + patlen] != NUL)\n\tcurwin->w_cursor = is_state->search_start;\n    else if (found != 0)\n\tcurwin->w_cursor = end_pos;\n\n    msg_starthere();\n    redrawcmdline();\n    is_state->did_incsearch = TRUE;\n}\n\n/*\n * May adjust 'incsearch' highlighting for typing CTRL-G and CTRL-T, go to next\n * or previous match.\n * Returns FAIL when jumping to cmdline_not_changed;\n */\n    static int\nmay_adjust_incsearch_highlighting(\n\tint\t\t\tfirstc,\n\tlong\t\t\tcount,\n\tincsearch_state_T\t*is_state,\n\tint\t\t\tc)\n{\n    int\t    skiplen, patlen;\n    pos_T   t;\n    char_u  *pat;\n    int\t    search_flags = SEARCH_NOOF;\n    int\t    i;\n    int\t    save;\n    int\t    search_delim;\n\n    // Parsing range may already set the last search pattern.\n    // NOTE: must call restore_last_search_pattern() before returning!\n    save_last_search_pattern();\n\n    if (!do_incsearch_highlighting(firstc, &search_delim, is_state,\n\t\t\t\t\t\t\t    &skiplen, &patlen))\n    {\n\trestore_last_search_pattern();\n\treturn OK;\n    }\n    if (patlen == 0 && ccline.cmdbuff[skiplen] == NUL)\n    {\n\trestore_last_search_pattern();\n\treturn FAIL;\n    }\n\n    if (search_delim == ccline.cmdbuff[skiplen])\n    {\n\tpat = last_search_pattern();\n\tif (pat == NULL)\n\t{\n\t    restore_last_search_pattern();\n\t    return FAIL;\n\t}\n\tskiplen = 0;\n\tpatlen = (int)STRLEN(pat);\n    }\n    else\n\tpat = ccline.cmdbuff + skiplen;\n\n    cursor_off();\n    out_flush();\n    if (c == Ctrl_G)\n    {\n\tt = is_state->match_end;\n\tif (LT_POS(is_state->match_start, is_state->match_end))\n\t    // Start searching at the end of the match not at the beginning of\n\t    // the next column.\n\t    (void)decl(&t);\n\tsearch_flags += SEARCH_COL;\n    }\n    else\n\tt = is_state->match_start;\n    if (!p_hls)\n\tsearch_flags += SEARCH_KEEP;\n    ++emsg_off;\n    save = pat[patlen];\n    pat[patlen] = NUL;\n    i = searchit(curwin, curbuf, &t, NULL,\n\t\t c == Ctrl_G ? FORWARD : BACKWARD,\n\t\t pat, count, search_flags, RE_SEARCH, NULL);\n    --emsg_off;\n    pat[patlen] = save;\n    if (i)\n    {\n\tis_state->search_start = is_state->match_start;\n\tis_state->match_end = t;\n\tis_state->match_start = t;\n\tif (c == Ctrl_T && firstc != '?')\n\t{\n\t    // Move just before the current match, so that when nv_search\n\t    // finishes the cursor will be put back on the match.\n\t    is_state->search_start = t;\n\t    (void)decl(&is_state->search_start);\n\t}\n\telse if (c == Ctrl_G && firstc == '?')\n\t{\n\t    // Move just after the current match, so that when nv_search\n\t    // finishes the cursor will be put back on the match.\n\t    is_state->search_start = t;\n\t    (void)incl(&is_state->search_start);\n\t}\n\tif (LT_POS(t, is_state->search_start) && c == Ctrl_G)\n\t{\n\t    // wrap around\n\t    is_state->search_start = t;\n\t    if (firstc == '?')\n\t\t(void)incl(&is_state->search_start);\n\t    else\n\t\t(void)decl(&is_state->search_start);\n\t}\n\n\tset_search_match(&is_state->match_end);\n\tcurwin->w_cursor = is_state->match_start;\n\tchanged_cline_bef_curs();\n\tupdate_topline();\n\tvalidate_cursor();\n\thighlight_match = TRUE;\n\tsave_viewstate(&is_state->old_viewstate);\n\tupdate_screen(NOT_VALID);\n\thighlight_match = FALSE;\n\tredrawcmdline();\n\tcurwin->w_cursor = is_state->match_end;\n    }\n    else\n\tvim_beep(BO_ERROR);\n    restore_last_search_pattern();\n    return FAIL;\n}\n\n/*\n * When CTRL-L typed: add character from the match to the pattern.\n * May set \"*c\" to the added character.\n * Return OK when jumping to cmdline_not_changed.\n */\n    static int\nmay_add_char_to_search(int firstc, int *c, incsearch_state_T *is_state)\n{\n    int\t\tskiplen, patlen, search_delim;\n\n    // Parsing range may already set the last search pattern.\n    // NOTE: must call restore_last_search_pattern() before returning!\n    save_last_search_pattern();\n\n    if (!do_incsearch_highlighting(firstc, &search_delim, is_state,\n\t\t\t\t\t\t\t    &skiplen, &patlen))\n    {\n\trestore_last_search_pattern();\n\treturn FAIL;\n    }\n    restore_last_search_pattern();\n\n    // Add a character from under the cursor for 'incsearch'.\n    if (is_state->did_incsearch)\n    {\n\tcurwin->w_cursor = is_state->match_end;\n\t*c = gchar_cursor();\n\tif (*c != NUL)\n\t{\n\t    // If 'ignorecase' and 'smartcase' are set and the\n\t    // command line has no uppercase characters, convert\n\t    // the character to lowercase.\n\t    if (p_ic && p_scs && !pat_has_uppercase(ccline.cmdbuff + skiplen))\n\t\t*c = MB_TOLOWER(*c);\n\t    if (*c == search_delim || vim_strchr((char_u *)(\n\t\t\t     magic_isset() ? \"\\\\~^$.*[\" : \"\\\\^$\"), *c) != NULL)\n\t    {\n\t\t// put a backslash before special characters\n\t\tstuffcharReadbuff(*c);\n\t\t*c = '\\\\';\n\t    }\n\t    // add any composing characters\n\t    if (mb_char2len(*c) != mb_ptr2len(ml_get_cursor()))\n\t    {\n\t\tint save_c = *c;\n\n\t\twhile (mb_char2len(*c) != mb_ptr2len(ml_get_cursor()))\n\t\t{\n\t\t    curwin->w_cursor.col += mb_char2len(*c);\n\t\t    *c = gchar_cursor();\n\t\t    stuffcharReadbuff(*c);\n\t\t}\n\t\t*c = save_c;\n\t    }\n\t    return FAIL;\n\t}\n    }\n    return OK;\n}\n#endif\n\n#ifdef FEAT_ARABIC\n/*\n * Return TRUE if the command line has an Arabic character at or after \"start\"\n * for \"len\" bytes.\n */\n    static int\ncmdline_has_arabic(int start, int len)\n{\n    int\t    j;\n    int\t    mb_l;\n    int\t    u8c;\n    char_u  *p;\n    int\t    u8cc[MAX_MCO];\n\n    if (!enc_utf8)\n\treturn FALSE;\n\n    for (j = start; j < start + len; j += mb_l)\n    {\n\tp = ccline.cmdbuff + j;\n\tu8c = utfc_ptr2char_len(p, u8cc, start + len - j);\n\tmb_l = utfc_ptr2len_len(p, start + len - j);\n\tif (ARABIC_CHAR(u8c))\n\t    return TRUE;\n    }\n    return FALSE;\n}\n#endif\n\n    void\ncmdline_init(void)\n{\n    CLEAR_FIELD(ccline);\n}\n\n/*\n * Handle the backslash key pressed in the command-line mode.  CTRL-\\ CTRL-N\n * goes to Normal mode, CTRL-\\ CTRL-G goes to Insert mode when 'insertmode' is\n * set, CTRL-\\ e prompts for an expression.\n */\n    static int\ncmdline_handle_backslash_key(int c, int *gotesc)\n{\n    ++no_mapping;\n    ++allow_keys;\n    c = plain_vgetc();\n    --no_mapping;\n    --allow_keys;\n\n    // CTRL-\\ e doesn't work when obtaining an expression, unless it\n    // is in a mapping.\n    if (c != Ctrl_N && c != Ctrl_G && (c != 'e'\n\t\t|| (ccline.cmdfirstc == '=' && KeyTyped)\n#ifdef FEAT_EVAL\n\t\t|| cmdline_star > 0\n#endif\n\t\t))\n    {\n\tvungetc(c);\n\treturn PROCESS_NEXT_KEY;\n    }\n\n#ifdef FEAT_EVAL\n    if (c == 'e')\n    {\n\tchar_u\t*p = NULL;\n\tint\tlen;\n\n\t/*\n\t * Replace the command line with the result of an expression.\n\t * Need to save and restore the current command line, to be\n\t * able to enter a new one...\n\t */\n\tif (ccline.cmdpos == ccline.cmdlen)\n\t    new_cmdpos = 99999;\t// keep it at the end\n\telse\n\t    new_cmdpos = ccline.cmdpos;\n\n\tc = get_expr_register();\n\tif (c == '=')\n\t{\n\t    // Need to save and restore ccline.  And set \"textlock\"\n\t    // to avoid nasty things like going to another buffer when\n\t    // evaluating an expression.\n\t    ++textlock;\n\t    p = get_expr_line();\n\t    --textlock;\n\n\t    if (p != NULL)\n\t    {\n\t\tlen = (int)STRLEN(p);\n\t\tif (realloc_cmdbuff(len + 1) == OK)\n\t\t{\n\t\t    ccline.cmdlen = len;\n\t\t    STRCPY(ccline.cmdbuff, p);\n\t\t    vim_free(p);\n\n\t\t    // Restore the cursor or use the position set with\n\t\t    // set_cmdline_pos().\n\t\t    if (new_cmdpos > ccline.cmdlen)\n\t\t\tccline.cmdpos = ccline.cmdlen;\n\t\t    else\n\t\t\tccline.cmdpos = new_cmdpos;\n\n\t\t    KeyTyped = FALSE;\t// Don't do p_wc completion.\n\t\t    redrawcmd();\n\t\t    return CMDLINE_CHANGED;\n\t\t}\n\t\tvim_free(p);\n\t    }\n\t}\n\tbeep_flush();\n\tgot_int = FALSE;\t// don't abandon the command line\n\tdid_emsg = FALSE;\n\temsg_on_display = FALSE;\n\tredrawcmd();\n\treturn CMDLINE_NOT_CHANGED;\n    }\n#endif\n\n    if (c == Ctrl_G && p_im && restart_edit == 0)\n\trestart_edit = 'a';\n    *gotesc = TRUE;\t// will free ccline.cmdbuff after putting it\n\t\t\t// in history\n    return GOTO_NORMAL_MODE;\n}\n\n/*\n * Completion for 'wildchar' or 'wildcharm' key.\n * - hitting <ESC> twice means: abandon command line.\n * - wildcard expansion is only done when the 'wildchar' key is really\n *   typed, not when it comes from a macro\n * Returns CMDLINE_CHANGED if command line is changed or CMDLINE_NOT_CHANGED.\n */\n    static int\ncmdline_wildchar_complete(\n\tint\t\tc,\n\tint\t\tescape,\n\tint\t\t*did_wild_list,\n\tint\t\t*wim_index_p,\n\texpand_T\t*xp,\n\tint\t\t*gotesc)\n{\n    int\t\twim_index = *wim_index_p;\n    int\t\tres;\n    int\t\tj;\n    int\t\toptions = WILD_NO_BEEP;\n\n    if (wim_flags[wim_index] & WIM_BUFLASTUSED)\n\toptions |= WILD_BUFLASTUSED;\n    if (xp->xp_numfiles > 0)   // typed p_wc at least twice\n    {\n\t// if 'wildmode' contains \"list\" may still need to list\n\tif (xp->xp_numfiles > 1\n\t\t&& !*did_wild_list\n\t\t&& ((wim_flags[wim_index] & WIM_LIST)\n#ifdef FEAT_WILDMENU\n\t\t    || (p_wmnu && (wim_flags[wim_index] & WIM_FULL) != 0)\n#endif\n\t\t    ))\n\t{\n#ifdef FEAT_WILDMENU\n\t    (void)showmatches(xp,\n\t\t    p_wmnu && ((wim_flags[wim_index] & WIM_LIST) == 0));\n#else\n\t    (void)showmatches(xp, FALSE);\n#endif\n\t    redrawcmd();\n\t    *did_wild_list = TRUE;\n\t}\n\tif (wim_flags[wim_index] & WIM_LONGEST)\n\t    res = nextwild(xp, WILD_LONGEST, options, escape);\n\telse if (wim_flags[wim_index] & WIM_FULL)\n\t    res = nextwild(xp, WILD_NEXT, options, escape);\n\telse\n\t    res = OK;\t    // don't insert 'wildchar' now\n    }\n    else\t\t    // typed p_wc first time\n    {\n\twim_index = 0;\n\tj = ccline.cmdpos;\n\t// if 'wildmode' first contains \"longest\", get longest\n\t// common part\n\tif (wim_flags[0] & WIM_LONGEST)\n\t    res = nextwild(xp, WILD_LONGEST, options, escape);\n\telse\n\t    res = nextwild(xp, WILD_EXPAND_KEEP, options, escape);\n\n\t// if interrupted while completing, behave like it failed\n\tif (got_int)\n\t{\n\t    (void)vpeekc();\t// remove <C-C> from input stream\n\t    got_int = FALSE;\t// don't abandon the command line\n\t    (void)ExpandOne(xp, NULL, NULL, 0, WILD_FREE);\n#ifdef FEAT_WILDMENU\n\t    xp->xp_context = EXPAND_NOTHING;\n#endif\n\t    *wim_index_p = wim_index;\n\t    return CMDLINE_CHANGED;\n\t}\n\n\t// when more than one match, and 'wildmode' first contains\n\t// \"list\", or no change and 'wildmode' contains \"longest,list\",\n\t// list all matches\n\tif (res == OK && xp->xp_numfiles > 1)\n\t{\n\t    // a \"longest\" that didn't do anything is skipped (but not\n\t    // \"list:longest\")\n\t    if (wim_flags[0] == WIM_LONGEST && ccline.cmdpos == j)\n\t\twim_index = 1;\n\t    if ((wim_flags[wim_index] & WIM_LIST)\n#ifdef FEAT_WILDMENU\n\t\t    || (p_wmnu && (wim_flags[wim_index] & WIM_FULL) != 0)\n#endif\n\t       )\n\t    {\n\t\tif (!(wim_flags[0] & WIM_LONGEST))\n\t\t{\n#ifdef FEAT_WILDMENU\n\t\t    int p_wmnu_save = p_wmnu;\n\t\t    p_wmnu = 0;\n#endif\n\t\t    // remove match\n\t\t    nextwild(xp, WILD_PREV, 0, escape);\n#ifdef FEAT_WILDMENU\n\t\t    p_wmnu = p_wmnu_save;\n#endif\n\t\t}\n#ifdef FEAT_WILDMENU\n\t\t(void)showmatches(xp, p_wmnu\n\t\t\t&& ((wim_flags[wim_index] & WIM_LIST) == 0));\n#else\n\t\t(void)showmatches(xp, FALSE);\n#endif\n\t\tredrawcmd();\n\t\t*did_wild_list = TRUE;\n\t\tif (wim_flags[wim_index] & WIM_LONGEST)\n\t\t    nextwild(xp, WILD_LONGEST, options, escape);\n\t\telse if (wim_flags[wim_index] & WIM_FULL)\n\t\t    nextwild(xp, WILD_NEXT, options, escape);\n\t    }\n\t    else\n\t\tvim_beep(BO_WILD);\n\t}\n#ifdef FEAT_WILDMENU\n\telse if (xp->xp_numfiles == -1)\n\t    xp->xp_context = EXPAND_NOTHING;\n#endif\n    }\n    if (wim_index < 3)\n\t++wim_index;\n    if (c == ESC)\n\t*gotesc = TRUE;\n\n    *wim_index_p = wim_index;\n    return (res == OK) ? CMDLINE_CHANGED : CMDLINE_NOT_CHANGED;\n}\n\n/*\n * Handle backspace, delete and CTRL-W keys in the command-line mode.\n * Returns:\n *  CMDLINE_NOT_CHANGED - if the command line is not changed\n *  CMDLINE_CHANGED - if the command line is changed\n *  GOTO_NORMAL_MODE - go back to normal mode\n */\n    static int\ncmdline_erase_chars(\n\tint c,\n\tint indent\n#ifdef FEAT_SEARCH_EXTRA\n\t, incsearch_state_T *isp\n#endif\n\t)\n{\n    int\t\ti;\n    int\t\tj;\n\n    if (c == K_KDEL)\n\tc = K_DEL;\n\n    /*\n     * Delete current character is the same as backspace on next\n     * character, except at end of line.\n     */\n    if (c == K_DEL && ccline.cmdpos != ccline.cmdlen)\n\t++ccline.cmdpos;\n    if (has_mbyte && c == K_DEL)\n\tccline.cmdpos += mb_off_next(ccline.cmdbuff,\n\t\tccline.cmdbuff + ccline.cmdpos);\n    if (ccline.cmdpos > 0)\n    {\n\tchar_u *p;\n\n\tj = ccline.cmdpos;\n\tp = ccline.cmdbuff + j;\n\tif (has_mbyte)\n\t{\n\t    p = mb_prevptr(ccline.cmdbuff, p);\n\t    if (c == Ctrl_W)\n\t    {\n\t\twhile (p > ccline.cmdbuff && vim_isspace(*p))\n\t\t    p = mb_prevptr(ccline.cmdbuff, p);\n\t\ti = mb_get_class(p);\n\t\twhile (p > ccline.cmdbuff && mb_get_class(p) == i)\n\t\t    p = mb_prevptr(ccline.cmdbuff, p);\n\t\tif (mb_get_class(p) != i)\n\t\t    p += (*mb_ptr2len)(p);\n\t    }\n\t}\n\telse if (c == Ctrl_W)\n\t{\n\t    while (p > ccline.cmdbuff && vim_isspace(p[-1]))\n\t\t--p;\n\t    if (p > ccline.cmdbuff)\n\t    {\n\t\ti = vim_iswordc(p[-1]);\n\t\twhile (p > ccline.cmdbuff && !vim_isspace(p[-1])\n\t\t\t&& vim_iswordc(p[-1]) == i)\n\t\t    --p;\n\t    }\n\t}\n\telse\n\t    --p;\n\tccline.cmdpos = (int)(p - ccline.cmdbuff);\n\tccline.cmdlen -= j - ccline.cmdpos;\n\ti = ccline.cmdpos;\n\twhile (i < ccline.cmdlen)\n\t    ccline.cmdbuff[i++] = ccline.cmdbuff[j++];\n\n\t// Truncate at the end, required for multi-byte chars.\n\tccline.cmdbuff[ccline.cmdlen] = NUL;\n#ifdef FEAT_SEARCH_EXTRA\n\tif (ccline.cmdlen == 0)\n\t{\n\t    isp->search_start = isp->save_cursor;\n\t    // save view settings, so that the screen\n\t    // won't be restored at the wrong position\n\t    isp->old_viewstate = isp->init_viewstate;\n\t}\n#endif\n\tredrawcmd();\n    }\n    else if (ccline.cmdlen == 0 && c != Ctrl_W\n\t    && ccline.cmdprompt == NULL && indent == 0)\n    {\n\t// In ex and debug mode it doesn't make sense to return.\n\tif (exmode_active\n#ifdef FEAT_EVAL\n\t\t|| ccline.cmdfirstc == '>'\n#endif\n\t   )\n\t    return CMDLINE_NOT_CHANGED;\n\n\tVIM_CLEAR(ccline.cmdbuff);\t// no commandline to return\n\tif (!cmd_silent)\n\t{\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmdmsg_rl)\n\t\tmsg_col = Columns;\n\t    else\n#endif\n\t\tmsg_col = 0;\n\t    msg_putchar(' ');\t\t// delete ':'\n\t}\n#ifdef FEAT_SEARCH_EXTRA\n\tif (ccline.cmdlen == 0)\n\t    isp->search_start = isp->save_cursor;\n#endif\n\tredraw_cmdline = TRUE;\n\treturn GOTO_NORMAL_MODE;\n    }\n    return CMDLINE_CHANGED;\n}\n\n/*\n * Handle the CTRL-^ key in the command-line mode and toggle the use of the\n * language :lmap mappings and/or Input Method.\n */\n    static void\ncmdline_toggle_langmap(long *b_im_ptr)\n{\n    if (map_to_exists_mode((char_u *)\"\", MODE_LANGMAP, FALSE))\n    {\n\t// \":lmap\" mappings exists, toggle use of mappings.\n\tState ^= MODE_LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n\tim_set_active(FALSE);\t// Disable input method\n#endif\n\tif (b_im_ptr != NULL)\n\t{\n\t    if (State & MODE_LANGMAP)\n\t\t*b_im_ptr = B_IMODE_LMAP;\n\t    else\n\t\t*b_im_ptr = B_IMODE_NONE;\n\t}\n    }\n#ifdef HAVE_INPUT_METHOD\n    else\n    {\n\t// There are no \":lmap\" mappings, toggle IM.  When\n\t// 'imdisable' is set don't try getting the status, it's\n\t// always off.\n\tif ((p_imdisable && b_im_ptr != NULL)\n\t\t? *b_im_ptr == B_IMODE_IM : im_get_status())\n\t{\n\t    im_set_active(FALSE);\t// Disable input method\n\t    if (b_im_ptr != NULL)\n\t\t*b_im_ptr = B_IMODE_NONE;\n\t}\n\telse\n\t{\n\t    im_set_active(TRUE);\t// Enable input method\n\t    if (b_im_ptr != NULL)\n\t\t*b_im_ptr = B_IMODE_IM;\n\t}\n    }\n#endif\n    if (b_im_ptr != NULL)\n    {\n\tif (b_im_ptr == &curbuf->b_p_iminsert)\n\t    set_iminsert_global();\n\telse\n\t    set_imsearch_global();\n    }\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t// may show different cursor shape\n#endif\n#if defined(FEAT_KEYMAP)\n    // Show/unshow value of 'keymap' in status lines later.\n    status_redraw_curbuf();\n#endif\n}\n\n/*\n * Handle the CTRL-R key in the command-line mode and insert the contents of a\n * numbered or named register.\n */\n    static int\ncmdline_insert_reg(int *gotesc UNUSED)\n{\n    int\t\ti;\n    int\t\tc;\n\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t// disallow scrolling here\n#endif\n    putcmdline('\"', TRUE);\n    ++no_mapping;\n    ++allow_keys;\n    i = c = plain_vgetc();\t// CTRL-R <char>\n    if (i == Ctrl_O)\n\ti = Ctrl_R;\t\t// CTRL-R CTRL-O == CTRL-R CTRL-R\n    if (i == Ctrl_R)\n\tc = plain_vgetc();\t// CTRL-R CTRL-R <char>\n    extra_char = NUL;\n    --no_mapping;\n    --allow_keys;\n#ifdef FEAT_EVAL\n    /*\n     * Insert the result of an expression.\n     * Need to save the current command line, to be able to enter\n     * a new one...\n     */\n    new_cmdpos = -1;\n    if (c == '=')\n    {\n\tif (ccline.cmdfirstc == '='  // can't do this recursively\n\t\t|| cmdline_star > 0) // or when typing a password\n\t{\n\t    beep_flush();\n\t    c = ESC;\n\t}\n\telse\n\t    c = get_expr_register();\n    }\n#endif\n    if (c != ESC)\t    // use ESC to cancel inserting register\n    {\n\tcmdline_paste(c, i == Ctrl_R, FALSE);\n\n#ifdef FEAT_EVAL\n\t// When there was a serious error abort getting the\n\t// command line.\n\tif (aborting())\n\t{\n\t    *gotesc = TRUE;  // will free ccline.cmdbuff after\n\t    // putting it in history\n\t    return GOTO_NORMAL_MODE;\n\t}\n#endif\n\tKeyTyped = FALSE;\t// Don't do p_wc completion.\n#ifdef FEAT_EVAL\n\tif (new_cmdpos >= 0)\n\t{\n\t    // set_cmdline_pos() was used\n\t    if (new_cmdpos > ccline.cmdlen)\n\t\tccline.cmdpos = ccline.cmdlen;\n\t    else\n\t\tccline.cmdpos = new_cmdpos;\n\t}\n#endif\n    }\n    // remove the double quote\n    redrawcmd();\n\n    // The text has been stuffed, the command line didn't change yet.\n    return CMDLINE_NOT_CHANGED;\n}\n\n/*\n * Handle the Left and Right mouse clicks in the command-line mode.\n */\n    static void\ncmdline_left_right_mouse(int c, int *ignore_drag_release)\n{\n    if (c == K_LEFTRELEASE || c == K_RIGHTRELEASE)\n\t*ignore_drag_release = TRUE;\n    else\n\t*ignore_drag_release = FALSE;\n# ifdef FEAT_GUI\n    // When GUI is active, also move when 'mouse' is empty\n    if (!gui.in_use)\n# endif\n\tif (!mouse_has(MOUSE_COMMAND))\n\t    return;\n# ifdef FEAT_CLIPBOARD\n    if (mouse_row < cmdline_row && clip_star.available)\n    {\n\tint\t    button, is_click, is_drag;\n\n\t/*\n\t * Handle modeless selection.\n\t */\n\tbutton = get_mouse_button(KEY2TERMCAP1(c),\n\t\t&is_click, &is_drag);\n\tif (mouse_model_popup() && button == MOUSE_LEFT\n\t\t&& (mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    // Translate shift-left to right button.\n\t    button = MOUSE_RIGHT;\n\t    mod_mask &= ~MOD_MASK_SHIFT;\n\t}\n\tclip_modeless(button, is_click, is_drag);\n\treturn;\n    }\n# endif\n\n    set_cmdspos();\n    for (ccline.cmdpos = 0; ccline.cmdpos < ccline.cmdlen;\n\t    ++ccline.cmdpos)\n    {\n\tint\ti;\n\n\ti = cmdline_charsize(ccline.cmdpos);\n\tif (mouse_row <= cmdline_row + ccline.cmdspos / Columns\n\t\t&& mouse_col < ccline.cmdspos % Columns + i)\n\t    break;\n\tif (has_mbyte)\n\t{\n\t    // Count \">\" for double-wide char that doesn't fit.\n\t    correct_cmdspos(ccline.cmdpos, i);\n\t    ccline.cmdpos += (*mb_ptr2len)(ccline.cmdbuff\n\t\t    + ccline.cmdpos) - 1;\n\t}\n\tccline.cmdspos += i;\n    }\n}\n\n/*\n * Handle the Up, Down, Page Up, Page down, CTRL-N and CTRL-P key in the\n * command-line mode. The pressed key is in 'c'.\n * Returns:\n *  CMDLINE_NOT_CHANGED - if the command line is not changed\n *  CMDLINE_CHANGED - if the command line is changed\n *  GOTO_NORMAL_MODE - go back to normal mode\n */\n    static int\ncmdline_browse_history(\n\tint\tc,\n\tint\tfirstc,\n\tchar_u\t**curcmdstr,\n\tint\thistype,\n\tint\t*hiscnt_p,\n\texpand_T *xp)\n{\n    int\t\ti;\n    int\t\tj;\n    char_u\t*lookfor = *curcmdstr;\n    int\t\thiscnt = *hiscnt_p;\n    int\t\tres;\n\n    if (get_hislen() == 0 || firstc == NUL)\t// no history\n\treturn CMDLINE_NOT_CHANGED;\n\n    i = hiscnt;\n\n    // save current command string so it can be restored later\n    if (lookfor == NULL)\n    {\n\tif ((lookfor = vim_strsave(ccline.cmdbuff)) == NULL)\n\t    return CMDLINE_NOT_CHANGED;\n\tlookfor[ccline.cmdpos] = NUL;\n    }\n\n    j = (int)STRLEN(lookfor);\n    for (;;)\n    {\n\t// one step backwards\n\tif (c == K_UP|| c == K_S_UP || c == Ctrl_P\n\t\t|| c == K_PAGEUP || c == K_KPAGEUP)\n\t{\n\t    if (hiscnt == get_hislen())\t// first time\n\t\thiscnt = *get_hisidx(histype);\n\t    else if (hiscnt == 0 && *get_hisidx(histype)\n\t\t    != get_hislen() - 1)\n\t\thiscnt = get_hislen() - 1;\n\t    else if (hiscnt != *get_hisidx(histype) + 1)\n\t\t--hiscnt;\n\t    else\t\t\t// at top of list\n\t    {\n\t\thiscnt = i;\n\t\tbreak;\n\t    }\n\t}\n\telse    // one step forwards\n\t{\n\t    // on last entry, clear the line\n\t    if (hiscnt == *get_hisidx(histype))\n\t    {\n\t\thiscnt = get_hislen();\n\t\tbreak;\n\t    }\n\n\t    // not on a history line, nothing to do\n\t    if (hiscnt == get_hislen())\n\t\tbreak;\n\t    if (hiscnt == get_hislen() - 1)   // wrap around\n\t\thiscnt = 0;\n\t    else\n\t\t++hiscnt;\n\t}\n\tif (hiscnt < 0 || get_histentry(histype)[hiscnt].hisstr\n\t\t== NULL)\n\t{\n\t    hiscnt = i;\n\t    break;\n\t}\n\tif ((c != K_UP && c != K_DOWN)\n\t\t|| hiscnt == i\n\t\t|| STRNCMP(get_histentry(histype)[hiscnt].hisstr,\n\t\t    lookfor, (size_t)j) == 0)\n\t    break;\n    }\n\n    if (hiscnt != i)\t// jumped to other entry\n    {\n\tchar_u\t*p;\n\tint\t\tlen;\n\tint\t\told_firstc;\n\n\tVIM_CLEAR(ccline.cmdbuff);\n\txp->xp_context = EXPAND_NOTHING;\n\tif (hiscnt == get_hislen())\n\t    p = lookfor;\t// back to the old one\n\telse\n\t    p = get_histentry(histype)[hiscnt].hisstr;\n\n\tif (histype == HIST_SEARCH\n\t\t&& p != lookfor\n\t\t&& (old_firstc = p[STRLEN(p) + 1]) != firstc)\n\t{\n\t    // Correct for the separator character used when\n\t    // adding the history entry vs the one used now.\n\t    // First loop: count length.\n\t    // Second loop: copy the characters.\n\t    for (i = 0; i <= 1; ++i)\n\t    {\n\t\tlen = 0;\n\t\tfor (j = 0; p[j] != NUL; ++j)\n\t\t{\n\t\t    // Replace old sep with new sep, unless it is\n\t\t    // escaped.\n\t\t    if (p[j] == old_firstc\n\t\t\t    && (j == 0 || p[j - 1] != '\\\\'))\n\t\t    {\n\t\t\tif (i > 0)\n\t\t\t    ccline.cmdbuff[len] = firstc;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Escape new sep, unless it is already\n\t\t\t// escaped.\n\t\t\tif (p[j] == firstc\n\t\t\t\t&& (j == 0 || p[j - 1] != '\\\\'))\n\t\t\t{\n\t\t\t    if (i > 0)\n\t\t\t\tccline.cmdbuff[len] = '\\\\';\n\t\t\t    ++len;\n\t\t\t}\n\t\t\tif (i > 0)\n\t\t\t    ccline.cmdbuff[len] = p[j];\n\t\t    }\n\t\t    ++len;\n\t\t}\n\t\tif (i == 0)\n\t\t{\n\t\t    alloc_cmdbuff(len);\n\t\t    if (ccline.cmdbuff == NULL)\n\t\t    {\n\t\t\tres = GOTO_NORMAL_MODE;\n\t\t\tgoto done;\n\t\t    }\n\t\t}\n\t    }\n\t    ccline.cmdbuff[len] = NUL;\n\t}\n\telse\n\t{\n\t    alloc_cmdbuff((int)STRLEN(p));\n\t    if (ccline.cmdbuff == NULL)\n\t    {\n\t\tres = GOTO_NORMAL_MODE;\n\t\tgoto done;\n\t    }\n\t    STRCPY(ccline.cmdbuff, p);\n\t}\n\n\tccline.cmdpos = ccline.cmdlen = (int)STRLEN(ccline.cmdbuff);\n\tredrawcmd();\n\tres = CMDLINE_CHANGED;\n\tgoto done;\n    }\n    beep_flush();\n    res = CMDLINE_NOT_CHANGED;\n\ndone:\n    *curcmdstr = lookfor;\n    *hiscnt_p = hiscnt;\n    return res;\n}\n\n/*\n * Initialize the current command-line info.\n */\n    static int\ninit_ccline(int firstc, int indent)\n{\n    ccline.overstrike = FALSE;\t\t    // always start in insert mode\n\n    /*\n     * set some variables for redrawcmd()\n     */\n    ccline.cmdfirstc = (firstc == '@' ? 0 : firstc);\n    ccline.cmdindent = (firstc > 0 ? indent : 0);\n\n    // alloc initial ccline.cmdbuff\n    alloc_cmdbuff(indent + 50);\n    if (ccline.cmdbuff == NULL)\n\treturn FAIL;\n    ccline.cmdlen = ccline.cmdpos = 0;\n    ccline.cmdbuff[0] = NUL;\n    sb_text_start_cmdline();\n\n    // autoindent for :insert and :append\n    if (firstc <= 0)\n    {\n\tvim_memset(ccline.cmdbuff, ' ', indent);\n\tccline.cmdbuff[indent] = NUL;\n\tccline.cmdpos = indent;\n\tccline.cmdspos = indent;\n\tccline.cmdlen = indent;\n    }\n\n    return OK;\n}\n\n/*\n * getcmdline() - accept a command line starting with firstc.\n *\n * firstc == ':'\t    get \":\" command line.\n * firstc == '/' or '?'\t    get search pattern\n * firstc == '='\t    get expression\n * firstc == '@'\t    get text for input() function\n * firstc == '>'\t    get text for debug mode\n * firstc == NUL\t    get text for :insert command\n * firstc == -1\t\t    like NUL, and break on CTRL-C\n *\n * The line is collected in ccline.cmdbuff, which is reallocated to fit the\n * command line.\n *\n * Careful: getcmdline() can be called recursively!\n *\n * Return pointer to allocated string if there is a commandline, NULL\n * otherwise.\n */\n    char_u *\ngetcmdline(\n    int\t\t  firstc,\n    long\t  count,\t// only used for incremental search\n    int\t\t  indent,\t// indent for inside conditionals\n    getline_opt_T do_concat UNUSED)\n{\n    return getcmdline_int(firstc, count, indent, TRUE);\n}\n\n    static char_u *\ngetcmdline_int(\n    int\t\tfirstc,\n    long\tcount UNUSED,\t// only used for incremental search\n    int\t\tindent,\t\t// indent for inside conditionals\n    int\t\tclear_ccline)\t// clear ccline first\n{\n    static int\tdepth = 0;\t    // call depth\n    int\t\tc;\n    int\t\ti;\n    int\t\tj;\n    int\t\tgotesc = FALSE;\t\t// TRUE when <ESC> just typed\n    int\t\tdo_abbr;\t\t// when TRUE check for abbr.\n    char_u\t*lookfor = NULL;\t// string to match\n    int\t\thiscnt;\t\t\t// current history line in use\n    int\t\thistype;\t\t// history type to be used\n#ifdef FEAT_SEARCH_EXTRA\n    incsearch_state_T\tis_state;\n#endif\n    int\t\tdid_wild_list = FALSE;\t// did wild_list() recently\n    int\t\twim_index = 0;\t\t// index in wim_flags[]\n    int\t\tres;\n    int\t\tsave_msg_scroll = msg_scroll;\n    int\t\tsave_State = State;\t// remember State when called\n    int\t\tsome_key_typed = FALSE;\t// one of the keys was typed\n    // mouse drag and release events are ignored, unless they are\n    // preceded with a mouse down event\n    int\t\tignore_drag_release = TRUE;\n#ifdef FEAT_EVAL\n    int\t\tbreak_ctrl_c = FALSE;\n#endif\n    expand_T\txpc;\n    long\t*b_im_ptr = NULL;\n    cmdline_info_T save_ccline;\n    int\t\tdid_save_ccline = FALSE;\n    int\t\tcmdline_type;\n    int\t\twild_type;\n\n    // one recursion level deeper\n    ++depth;\n\n    if (ccline.cmdbuff != NULL)\n    {\n\t// Being called recursively.  Since ccline is global, we need to save\n\t// the current buffer and restore it when returning.\n\tsave_cmdline(&save_ccline);\n\tdid_save_ccline = TRUE;\n    }\n    if (clear_ccline)\n\tCLEAR_FIELD(ccline);\n\n#ifdef FEAT_EVAL\n    if (firstc == -1)\n    {\n\tfirstc = NUL;\n\tbreak_ctrl_c = TRUE;\n    }\n#endif\n#ifdef FEAT_RIGHTLEFT\n    // start without Hebrew mapping for a command line\n    if (firstc == ':' || firstc == '=' || firstc == '>')\n\tcmd_hkmap = 0;\n#endif\n\n#ifdef FEAT_SEARCH_EXTRA\n    init_incsearch_state(&is_state);\n#endif\n\n    if (init_ccline(firstc, indent) != OK)\n\tgoto theend;\t// out of memory\n\n    if (depth == 50)\n    {\n\t// Somehow got into a loop recursively calling getcmdline(), bail out.\n\temsg(_(e_command_too_recursive));\n\tgoto theend;\n    }\n\n    ExpandInit(&xpc);\n    ccline.xpc = &xpc;\n\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl && *curwin->w_p_rlc == 's'\n\t\t\t\t\t  && (firstc == '/' || firstc == '?'))\n\tcmdmsg_rl = TRUE;\n    else\n\tcmdmsg_rl = FALSE;\n#endif\n\n    redir_off = TRUE;\t\t// don't redirect the typed command\n    if (!cmd_silent)\n    {\n\ti = msg_scrolled;\n\tmsg_scrolled = 0;\t\t// avoid wait_return message\n\tgotocmdline(TRUE);\n\tmsg_scrolled += i;\n\tredrawcmdprompt();\t\t// draw prompt or indent\n\tset_cmdspos();\n    }\n    xpc.xp_context = EXPAND_NOTHING;\n    xpc.xp_backslash = XP_BS_NONE;\n#ifndef BACKSLASH_IN_FILENAME\n    xpc.xp_shell = FALSE;\n#endif\n\n#if defined(FEAT_EVAL)\n    if (ccline.input_fn)\n    {\n\txpc.xp_context = ccline.xp_context;\n\txpc.xp_pattern = ccline.cmdbuff;\n\txpc.xp_arg = ccline.xp_arg;\n    }\n#endif\n\n    /*\n     * Avoid scrolling when called by a recursive do_cmdline(), e.g. when\n     * doing \":@0\" when register 0 doesn't contain a CR.\n     */\n    msg_scroll = FALSE;\n\n    State = MODE_CMDLINE;\n\n    if (firstc == '/' || firstc == '?' || firstc == '@')\n    {\n\t// Use \":lmap\" mappings for search pattern and input().\n\tif (curbuf->b_p_imsearch == B_IMODE_USE_INSERT)\n\t    b_im_ptr = &curbuf->b_p_iminsert;\n\telse\n\t    b_im_ptr = &curbuf->b_p_imsearch;\n\tif (*b_im_ptr == B_IMODE_LMAP)\n\t    State |= MODE_LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n\tim_set_active(*b_im_ptr == B_IMODE_IM);\n#endif\n    }\n#ifdef HAVE_INPUT_METHOD\n    else if (p_imcmdline)\n\tim_set_active(TRUE);\n#endif\n\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n\n    // When inside an autocommand for writing \"exiting\" may be set and\n    // terminal mode set to cooked.  Need to set raw mode here then.\n    settmode(TMODE_RAW);\n\n    // Trigger CmdlineEnter autocommands.\n    cmdline_type = firstc == NUL ? '-' : firstc;\n    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINEENTER);\n#ifdef FEAT_EVAL\n    if (!debug_mode)\n\tmay_trigger_modechanged();\n#endif\n\n    init_history();\n    hiscnt = get_hislen();\t// set hiscnt to impossible history value\n    histype = hist_char2type(firstc);\n\n#ifdef FEAT_DIGRAPHS\n    do_digraph(-1);\t\t// init digraph typeahead\n#endif\n\n    // If something above caused an error, reset the flags, we do want to type\n    // and execute commands. Display may be messed up a bit.\n    if (did_emsg)\n\tredrawcmd();\n\n#ifdef FEAT_STL_OPT\n    // Redraw the statusline in case it uses the current mode using the mode()\n    // function.\n    if (!cmd_silent && msg_scrolled == 0)\n    {\n\tint\tfound_one = FALSE;\n\twin_T\t*wp;\n\n\tFOR_ALL_WINDOWS(wp)\n\t    if (*p_stl != NUL || *wp->w_p_stl != NUL)\n\t    {\n\t\twp->w_redr_status = TRUE;\n\t\tfound_one = TRUE;\n\t    }\n\tif (found_one)\n\t    redraw_statuslines();\n    }\n#endif\n\n    did_emsg = FALSE;\n    got_int = FALSE;\n\n    /*\n     * Collect the command string, handling editing keys.\n     */\n    for (;;)\n    {\n\tint trigger_cmdlinechanged = TRUE;\n\tint end_wildmenu;\n\n\tredir_off = TRUE;\t// Don't redirect the typed command.\n\t\t\t\t// Repeated, because a \":redir\" inside\n\t\t\t\t// completion may switch it on.\n#ifdef USE_ON_FLY_SCROLL\n\tdont_scroll = FALSE;\t// allow scrolling here\n#endif\n\tquit_more = FALSE;\t// reset after CTRL-D which had a more-prompt\n\n\tdid_emsg = FALSE;\t// There can't really be a reason why an error\n\t\t\t\t// that occurs while typing a command should\n\t\t\t\t// cause the command not to be executed.\n\n\t// Trigger SafeState if nothing is pending.\n\tmay_trigger_safestate(xpc.xp_numfiles <= 0);\n\n\t// Get a character.  Ignore K_IGNORE and K_NOP, they should not do\n\t// anything, such as stop completion.\n\tdo\n\t{\n\t    cursorcmd();\t\t// set the cursor on the right spot\n\t    c = safe_vgetc();\n\t} while (c == K_IGNORE || c == K_NOP);\n\n\tif (c == K_COMMAND || c == K_SCRIPT_COMMAND)\n\t{\n\t    int\t    clen = ccline.cmdlen;\n\n\t    if (do_cmdkey_command(c, DOCMD_NOWAIT) == OK)\n\t    {\n\t\tif (clen == ccline.cmdlen)\n\t\t    trigger_cmdlinechanged = FALSE;\n\t\tgoto cmdline_changed;\n\t    }\n\t}\n\n\tif (KeyTyped)\n\t{\n\t    some_key_typed = TRUE;\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmd_hkmap)\n\t\tc = hkmap(c);\n\t    if (cmdmsg_rl && !KeyStuffed)\n\t    {\n\t\t// Invert horizontal movements and operations.  Only when\n\t\t// typed by the user directly, not when the result of a\n\t\t// mapping.\n\t\tswitch (c)\n\t\t{\n\t\t    case K_RIGHT:   c = K_LEFT; break;\n\t\t    case K_S_RIGHT: c = K_S_LEFT; break;\n\t\t    case K_C_RIGHT: c = K_C_LEFT; break;\n\t\t    case K_LEFT:    c = K_RIGHT; break;\n\t\t    case K_S_LEFT:  c = K_S_RIGHT; break;\n\t\t    case K_C_LEFT:  c = K_C_RIGHT; break;\n\t\t}\n\t    }\n#endif\n\t}\n\n\t/*\n\t * Ignore got_int when CTRL-C was typed here.\n\t * Don't ignore it in :global, we really need to break then, e.g., for\n\t * \":g/pat/normal /pat\" (without the <CR>).\n\t * Don't ignore it for the input() function.\n\t */\n\tif ((c == Ctrl_C\n#ifdef UNIX\n\t\t|| c == intr_char\n#endif\n\t\t\t\t)\n#if defined(FEAT_EVAL) || defined(FEAT_CRYPT)\n\t\t&& firstc != '@'\n#endif\n#ifdef FEAT_EVAL\n\t\t&& !break_ctrl_c\n#endif\n\t\t&& !global_busy)\n\t    got_int = FALSE;\n\n\t// free old command line when finished moving around in the history\n\t// list\n\tif (lookfor != NULL\n\t\t&& c != K_S_DOWN && c != K_S_UP\n\t\t&& c != K_DOWN && c != K_UP\n\t\t&& c != K_PAGEDOWN && c != K_PAGEUP\n\t\t&& c != K_KPAGEDOWN && c != K_KPAGEUP\n\t\t&& c != K_LEFT && c != K_RIGHT\n\t\t&& (xpc.xp_numfiles > 0 || (c != Ctrl_P && c != Ctrl_N)))\n\t    VIM_CLEAR(lookfor);\n\n\t/*\n\t * When there are matching completions to select <S-Tab> works like\n\t * CTRL-P (unless 'wc' is <S-Tab>).\n\t */\n\tif (c != p_wc && c == K_S_TAB && xpc.xp_numfiles > 0)\n\t    c = Ctrl_P;\n\n#ifdef FEAT_WILDMENU\n\tif (p_wmnu)\n\t    c = wildmenu_translate_key(&ccline, c, &xpc, did_wild_list);\n\n\tif (cmdline_pum_active())\n\t{\n\t    // Ctrl-Y: Accept the current selection and close the popup menu.\n\t    // Ctrl-E: cancel the cmdline popup menu and return the original\n\t    // text.\n\t    if (c == Ctrl_E || c == Ctrl_Y)\n\t    {\n\t\twild_type = (c == Ctrl_E) ? WILD_CANCEL : WILD_APPLY;\n\t\tif (nextwild(&xpc, wild_type, WILD_NO_BEEP,\n\t\t\t\t\t\t\tfirstc != '@') == FAIL)\n\t\t    break;\n\t\tc = Ctrl_E;\n\t    }\n\t}\n#endif\n\n\t// The wildmenu is cleared if the pressed key is not used for\n\t// navigating the wild menu (i.e. the key is not 'wildchar' or\n\t// 'wildcharm' or Ctrl-N or Ctrl-P or Ctrl-A or Ctrl-L).\n\t// If the popup menu is displayed, then PageDown and PageUp keys are\n\t// also used to navigate the menu.\n\tend_wildmenu = (!(c == p_wc && KeyTyped) && c != p_wcm\n\t\t&& c != Ctrl_N && c != Ctrl_P && c != Ctrl_A && c != Ctrl_L);\n#ifdef FEAT_WILDMENU\n\tend_wildmenu = end_wildmenu && (!cmdline_pum_active() ||\n\t\t\t    (c != K_PAGEDOWN && c != K_PAGEUP\n\t\t\t     && c != K_KPAGEDOWN && c != K_KPAGEUP));\n#endif\n\n\t// free expanded names when finished walking through matches\n\tif (end_wildmenu)\n\t{\n#ifdef FEAT_WILDMENU\n\t    if (cmdline_pum_active())\n\t\tcmdline_pum_remove();\n#endif\n\t    if (xpc.xp_numfiles != -1)\n\t\t(void)ExpandOne(&xpc, NULL, NULL, 0, WILD_FREE);\n\t    did_wild_list = FALSE;\n#ifdef FEAT_WILDMENU\n\t    if (!p_wmnu || (c != K_UP && c != K_DOWN))\n#endif\n\t\txpc.xp_context = EXPAND_NOTHING;\n\t    wim_index = 0;\n#ifdef FEAT_WILDMENU\n\t    wildmenu_cleanup(&ccline);\n#endif\n\t}\n\n#ifdef FEAT_WILDMENU\n\tif (p_wmnu)\n\t    c = wildmenu_process_key(&ccline, c, &xpc);\n#endif\n\n\t// CTRL-\\ CTRL-N goes to Normal mode, CTRL-\\ CTRL-G goes to Insert\n\t// mode when 'insertmode' is set, CTRL-\\ e prompts for an expression.\n\tif (c == Ctrl_BSL)\n\t{\n\t    res = cmdline_handle_backslash_key(c, &gotesc);\n\t    if (res == CMDLINE_CHANGED)\n\t\tgoto cmdline_changed;\n\t    else if (res == CMDLINE_NOT_CHANGED)\n\t\tgoto cmdline_not_changed;\n\t    else if (res == GOTO_NORMAL_MODE)\n\t\tgoto returncmd;\t\t// back to cmd mode\n\t    c = Ctrl_BSL;\t\t// backslash key not processed by\n\t\t\t\t\t// cmdline_handle_backslash_key()\n\t}\n\n#ifdef FEAT_CMDWIN\n\tif (c == cedit_key || c == K_CMDWIN)\n\t{\n\t    // TODO: why is ex_normal_busy checked here?\n\t    if ((c == K_CMDWIN || ex_normal_busy == 0) && got_int == FALSE)\n\t    {\n\t\t/*\n\t\t * Open a window to edit the command line (and history).\n\t\t */\n\t\tc = open_cmdwin();\n\t\tsome_key_typed = TRUE;\n\t    }\n\t}\n# ifdef FEAT_DIGRAPHS\n\telse\n# endif\n#endif\n#ifdef FEAT_DIGRAPHS\n\t    c = do_digraph(c);\n#endif\n\n\tif (c == '\\n' || c == '\\r' || c == K_KENTER || (c == ESC\n\t\t\t&& (!KeyTyped || vim_strchr(p_cpo, CPO_ESC) != NULL)))\n\t{\n\t    // In Ex mode a backslash escapes a newline.\n\t    if (exmode_active\n\t\t    && c != ESC\n\t\t    && ccline.cmdpos == ccline.cmdlen\n\t\t    && ccline.cmdpos > 0\n\t\t    && ccline.cmdbuff[ccline.cmdpos - 1] == '\\\\')\n\t    {\n\t\tif (c == K_KENTER)\n\t\t    c = '\\n';\n\t    }\n\t    else\n\t    {\n\t\tgotesc = FALSE;\t// Might have typed ESC previously, don't\n\t\t\t\t// truncate the cmdline now.\n\t\tif (ccheck_abbr(c + ABBR_OFF))\n\t\t    goto cmdline_changed;\n\t\tif (!cmd_silent)\n\t\t{\n\t\t    windgoto(msg_row, 0);\n\t\t    out_flush();\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n\n\t// Completion for 'wildchar' or 'wildcharm' key.\n\tif ((c == p_wc && !gotesc && KeyTyped) || c == p_wcm)\n\t{\n\t    res = cmdline_wildchar_complete(c, firstc != '@', &did_wild_list,\n\t\t    &wim_index, &xpc, &gotesc);\n\t    if (res == CMDLINE_CHANGED)\n\t\tgoto cmdline_changed;\n\t}\n\n\tgotesc = FALSE;\n\n\t// <S-Tab> goes to last match, in a clumsy way\n\tif (c == K_S_TAB && KeyTyped)\n\t{\n\t    if (nextwild(&xpc, WILD_EXPAND_KEEP, 0, firstc != '@') == OK)\n\t    {\n\t\tif (xpc.xp_numfiles > 1)\n\t\t{\n#ifdef FEAT_WILDMENU\n\t\t    // Trigger the popup menu when wildoptions=pum\n\t\t    showmatches(&xpc, p_wmnu\n\t\t\t    && ((wim_flags[wim_index] & WIM_LIST) == 0));\n#else\n\t\t    (void)showmatches(&xpc, FALSE);\n#endif\n\t\t}\n\t\tif (nextwild(&xpc, WILD_PREV, 0, firstc != '@') == OK\n\t\t\t&& nextwild(&xpc, WILD_PREV, 0, firstc != '@') == OK)\n\t\t    goto cmdline_changed;\n\t    }\n\t}\n\n\tif (c == NUL || c == K_ZERO)\t    // NUL is stored as NL\n\t    c = NL;\n\n\tdo_abbr = TRUE;\t\t// default: check for abbreviation\n\n\t/*\n\t * Big switch for a typed command line character.\n\t */\n\tswitch (c)\n\t{\n\tcase K_BS:\n\tcase Ctrl_H:\n\tcase K_DEL:\n\tcase K_KDEL:\n\tcase Ctrl_W:\n\t    res = cmdline_erase_chars(c, indent\n#ifdef FEAT_SEARCH_EXTRA\n\t\t    , &is_state\n#endif\n\t\t    );\n\t    if (res == CMDLINE_NOT_CHANGED)\n\t\tgoto cmdline_not_changed;\n\t    else if (res == GOTO_NORMAL_MODE)\n\t\tgoto returncmd;\t\t// back to cmd mode\n\t    goto cmdline_changed;\n\n\tcase K_INS:\n\tcase K_KINS:\n\t\tccline.overstrike = !ccline.overstrike;\n#ifdef CURSOR_SHAPE\n\t\tui_cursor_shape();\t// may show different cursor shape\n#endif\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_HAT:\n\t\tcmdline_toggle_langmap(b_im_ptr);\n\t\tgoto cmdline_not_changed;\n\n//\tcase '@':   only in very old vi\n\tcase Ctrl_U:\n\t\t// delete all characters left of the cursor\n\t\tj = ccline.cmdpos;\n\t\tccline.cmdlen -= j;\n\t\ti = ccline.cmdpos = 0;\n\t\twhile (i < ccline.cmdlen)\n\t\t    ccline.cmdbuff[i++] = ccline.cmdbuff[j++];\n\t\t// Truncate at the end, required for multi-byte chars.\n\t\tccline.cmdbuff[ccline.cmdlen] = NUL;\n#ifdef FEAT_SEARCH_EXTRA\n\t\tif (ccline.cmdlen == 0)\n\t\t    is_state.search_start = is_state.save_cursor;\n#endif\n\t\tredrawcmd();\n\t\tgoto cmdline_changed;\n\n#ifdef FEAT_CLIPBOARD\n\tcase Ctrl_Y:\n\t\t// Copy the modeless selection, if there is one.\n\t\tif (clip_star.state != SELECT_CLEARED)\n\t\t{\n\t\t    if (clip_star.state == SELECT_DONE)\n\t\t\tclip_copy_modeless_selection(TRUE);\n\t\t    goto cmdline_not_changed;\n\t\t}\n\t\tbreak;\n#endif\n\n\tcase ESC:\t// get here if p_wc != ESC or when ESC typed twice\n\tcase Ctrl_C:\n\t\t// In exmode it doesn't make sense to return.  Except when\n\t\t// \":normal\" runs out of characters.\n\t\tif (exmode_active\n\t\t\t       && (ex_normal_busy == 0 || typebuf.tb_len > 0))\n\t\t    goto cmdline_not_changed;\n\n\t\tgotesc = TRUE;\t\t// will free ccline.cmdbuff after\n\t\t\t\t\t// putting it in history\n\t\tgoto returncmd;\t\t// back to cmd mode\n\n\tcase Ctrl_R:\t\t\t// insert register\n\t\tres = cmdline_insert_reg(&gotesc);\n\t\tif (res == CMDLINE_NOT_CHANGED)\n\t\t    goto cmdline_not_changed;\n\t\telse if (res == GOTO_NORMAL_MODE)\n\t\t    goto returncmd;\n\t\tgoto cmdline_changed;\n\n\tcase Ctrl_D:\n\t\tif (showmatches(&xpc, FALSE) == EXPAND_NOTHING)\n\t\t    break;\t// Use ^D as normal char instead\n\n\t\tredrawcmd();\n\t\tcontinue;\t// don't do incremental search now\n\n\tcase K_RIGHT:\n\tcase K_S_RIGHT:\n\tcase K_C_RIGHT:\n\t\tdo\n\t\t{\n\t\t    if (ccline.cmdpos >= ccline.cmdlen)\n\t\t\tbreak;\n\t\t    i = cmdline_charsize(ccline.cmdpos);\n\t\t    if (KeyTyped && ccline.cmdspos + i >= Columns * Rows)\n\t\t\tbreak;\n\t\t    ccline.cmdspos += i;\n\t\t    if (has_mbyte)\n\t\t\tccline.cmdpos += (*mb_ptr2len)(ccline.cmdbuff\n\t\t\t\t\t\t\t     + ccline.cmdpos);\n\t\t    else\n\t\t\t++ccline.cmdpos;\n\t\t}\n\t\twhile ((c == K_S_RIGHT || c == K_C_RIGHT\n\t\t\t       || (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL)))\n\t\t\t&& ccline.cmdbuff[ccline.cmdpos] != ' ');\n\t\tif (has_mbyte)\n\t\t    set_cmdspos_cursor();\n\t\tgoto cmdline_not_changed;\n\n\tcase K_LEFT:\n\tcase K_S_LEFT:\n\tcase K_C_LEFT:\n\t\tif (ccline.cmdpos == 0)\n\t\t    goto cmdline_not_changed;\n\t\tdo\n\t\t{\n\t\t    --ccline.cmdpos;\n\t\t    if (has_mbyte)\t// move to first byte of char\n\t\t\tccline.cmdpos -= (*mb_head_off)(ccline.cmdbuff,\n\t\t\t\t\t      ccline.cmdbuff + ccline.cmdpos);\n\t\t    ccline.cmdspos -= cmdline_charsize(ccline.cmdpos);\n\t\t}\n\t\twhile (ccline.cmdpos > 0\n\t\t\t&& (c == K_S_LEFT || c == K_C_LEFT\n\t\t\t       || (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL)))\n\t\t\t&& ccline.cmdbuff[ccline.cmdpos - 1] != ' ');\n\t\tif (has_mbyte)\n\t\t    set_cmdspos_cursor();\n\t\tgoto cmdline_not_changed;\n\n\tcase K_IGNORE:\n\t\t// Ignore mouse event or open_cmdwin() result.\n\t\tgoto cmdline_not_changed;\n\n#ifdef FEAT_GUI_MSWIN\n\t    // On MS-Windows ignore <M-F4>, we get it when closing the window\n\t    // was cancelled.\n\tcase K_F4:\n\t    if (mod_mask == MOD_MASK_ALT)\n\t    {\n\t\tredrawcmd();\t    // somehow the cmdline is cleared\n\t\tgoto cmdline_not_changed;\n\t    }\n\t    break;\n#endif\n\n\tcase K_MIDDLEDRAG:\n\tcase K_MIDDLERELEASE:\n\t\tgoto cmdline_not_changed;\t// Ignore mouse\n\n\tcase K_MIDDLEMOUSE:\n# ifdef FEAT_GUI\n\t\t// When GUI is active, also paste when 'mouse' is empty\n\t\tif (!gui.in_use)\n# endif\n\t\t    if (!mouse_has(MOUSE_COMMAND))\n\t\t\tgoto cmdline_not_changed;   // Ignore mouse\n# ifdef FEAT_CLIPBOARD\n\t\tif (clip_star.available)\n\t\t    cmdline_paste('*', TRUE, TRUE);\n\t\telse\n# endif\n\t\t    cmdline_paste(0, TRUE, TRUE);\n\t\tredrawcmd();\n\t\tgoto cmdline_changed;\n\n# ifdef FEAT_DND\n\tcase K_DROP:\n\t\tcmdline_paste('~', TRUE, FALSE);\n\t\tredrawcmd();\n\t\tgoto cmdline_changed;\n# endif\n\n\tcase K_LEFTDRAG:\n\tcase K_LEFTRELEASE:\n\tcase K_RIGHTDRAG:\n\tcase K_RIGHTRELEASE:\n\t\t// Ignore drag and release events when the button-down wasn't\n\t\t// seen before.\n\t\tif (ignore_drag_release)\n\t\t    goto cmdline_not_changed;\n\t\t// FALLTHROUGH\n\tcase K_LEFTMOUSE:\n\tcase K_RIGHTMOUSE:\n\t\tcmdline_left_right_mouse(c, &ignore_drag_release);\n\t\tgoto cmdline_not_changed;\n\n\t// Mouse scroll wheel: ignored here\n\tcase K_MOUSEDOWN:\n\tcase K_MOUSEUP:\n\tcase K_MOUSELEFT:\n\tcase K_MOUSERIGHT:\n\t// Alternate buttons ignored here\n\tcase K_X1MOUSE:\n\tcase K_X1DRAG:\n\tcase K_X1RELEASE:\n\tcase K_X2MOUSE:\n\tcase K_X2DRAG:\n\tcase K_X2RELEASE:\n\tcase K_MOUSEMOVE:\n\t\tgoto cmdline_not_changed;\n\n#ifdef FEAT_GUI\n\tcase K_LEFTMOUSE_NM:\t// mousefocus click, ignored\n\tcase K_LEFTRELEASE_NM:\n\t\tgoto cmdline_not_changed;\n\n\tcase K_VER_SCROLLBAR:\n\t\tif (msg_scrolled == 0)\n\t\t{\n\t\t    gui_do_scroll();\n\t\t    redrawcmd();\n\t\t}\n\t\tgoto cmdline_not_changed;\n\n\tcase K_HOR_SCROLLBAR:\n\t\tif (msg_scrolled == 0)\n\t\t{\n\t\t    gui_do_horiz_scroll(scrollbar_value, FALSE);\n\t\t    redrawcmd();\n\t\t}\n\t\tgoto cmdline_not_changed;\n#endif\n#ifdef FEAT_GUI_TABLINE\n\tcase K_TABLINE:\n\tcase K_TABMENU:\n\t\t// Don't want to change any tabs here.  Make sure the same tab\n\t\t// is still selected.\n\t\tif (gui_use_tabline())\n\t\t    gui_mch_set_curtab(tabpage_index(curtab));\n\t\tgoto cmdline_not_changed;\n#endif\n\n\tcase K_SELECT:\t    // end of Select mode mapping - ignore\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_B:\t    // begin of command line\n\tcase K_HOME:\n\tcase K_KHOME:\n\tcase K_S_HOME:\n\tcase K_C_HOME:\n\t\tccline.cmdpos = 0;\n\t\tset_cmdspos();\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_E:\t    // end of command line\n\tcase K_END:\n\tcase K_KEND:\n\tcase K_S_END:\n\tcase K_C_END:\n\t\tccline.cmdpos = ccline.cmdlen;\n\t\tset_cmdspos_cursor();\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_A:\t    // all matches\n#ifdef FEAT_WILDMENU\n\t\tif (cmdline_pum_active())\n\t\t    // As Ctrl-A completes all the matches, close the popup\n\t\t    // menu (if present)\n\t\t    cmdline_pum_cleanup(&ccline);\n#endif\n\t\tif (nextwild(&xpc, WILD_ALL, 0, firstc != '@') == FAIL)\n\t\t    break;\n\t\txpc.xp_context = EXPAND_NOTHING;\n\t\tdid_wild_list = FALSE;\n\t\tgoto cmdline_changed;\n\n\tcase Ctrl_L:\n#ifdef FEAT_SEARCH_EXTRA\n\t\tif (may_add_char_to_search(firstc, &c, &is_state) == OK)\n\t\t    goto cmdline_not_changed;\n#endif\n\n\t\t// completion: longest common part\n\t\tif (nextwild(&xpc, WILD_LONGEST, 0, firstc != '@') == FAIL)\n\t\t    break;\n\t\tgoto cmdline_changed;\n\n\tcase Ctrl_N:\t    // next match\n\tcase Ctrl_P:\t    // previous match\n\t\tif (xpc.xp_numfiles > 0)\n\t\t{\n\t\t    wild_type = (c == Ctrl_P) ? WILD_PREV : WILD_NEXT;\n\t\t    if (nextwild(&xpc, wild_type, 0, firstc != '@') == FAIL)\n\t\t\tbreak;\n\t\t    goto cmdline_not_changed;\n\t\t}\n\t\t// FALLTHROUGH\n\tcase K_UP:\n\tcase K_DOWN:\n\tcase K_S_UP:\n\tcase K_S_DOWN:\n\tcase K_PAGEUP:\n\tcase K_KPAGEUP:\n\tcase K_PAGEDOWN:\n\tcase K_KPAGEDOWN:\n#ifdef FEAT_WILDMENU\n\t\tif (cmdline_pum_active()\n\t\t\t&& (c == K_PAGEUP || c == K_PAGEDOWN ||\n\t\t\t    c == K_KPAGEUP || c == K_KPAGEDOWN))\n\t\t{\n\t\t    // If the popup menu is displayed, then PageUp and PageDown\n\t\t    // are used to scroll the menu.\n\t\t    wild_type = WILD_PAGEUP;\n\t\t    if (c == K_PAGEDOWN || c == K_KPAGEDOWN)\n\t\t\twild_type = WILD_PAGEDOWN;\n\t\t    if (nextwild(&xpc, wild_type, 0, firstc != '@') == FAIL)\n\t\t\tbreak;\n\t\t    goto cmdline_not_changed;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    res = cmdline_browse_history(c, firstc, &lookfor, histype,\n\t\t\t    &hiscnt, &xpc);\n\t\t    if (res == CMDLINE_CHANGED)\n\t\t\tgoto cmdline_changed;\n\t\t    else if (res == GOTO_NORMAL_MODE)\n\t\t\tgoto returncmd;\n\t\t}\n\t\tgoto cmdline_not_changed;\n\n#ifdef FEAT_SEARCH_EXTRA\n\tcase Ctrl_G:\t    // next match\n\tcase Ctrl_T:\t    // previous match\n\t\tif (may_adjust_incsearch_highlighting(\n\t\t\t\t\t  firstc, count, &is_state, c) == FAIL)\n\t\t    goto cmdline_not_changed;\n\t\tbreak;\n#endif\n\n\tcase Ctrl_V:\n\tcase Ctrl_Q:\n\t\t{\n\t\t    ignore_drag_release = TRUE;\n\t\t    putcmdline('^', TRUE);\n\n\t\t    // Get next (two) character(s).  Do not change any\n\t\t    // modifyOtherKeys ESC sequence to a normal key for\n\t\t    // CTRL-SHIFT-V.\n\t\t    c = get_literal(mod_mask & MOD_MASK_SHIFT);\n\n\t\t    do_abbr = FALSE;\t    // don't do abbreviation now\n\t\t    extra_char = NUL;\n\t\t    // may need to remove ^ when composing char was typed\n\t\t    if (enc_utf8 && utf_iscomposing(c) && !cmd_silent)\n\t\t    {\n\t\t\tdraw_cmdline(ccline.cmdpos,\n\t\t\t\t\t\tccline.cmdlen - ccline.cmdpos);\n\t\t\tmsg_putchar(' ');\n\t\t\tcursorcmd();\n\t\t    }\n\t\t}\n\n\t\tbreak;\n\n#ifdef FEAT_DIGRAPHS\n\tcase Ctrl_K:\n\t\tignore_drag_release = TRUE;\n\t\tputcmdline('?', TRUE);\n# ifdef USE_ON_FLY_SCROLL\n\t\tdont_scroll = TRUE;\t    // disallow scrolling here\n# endif\n\t\tc = get_digraph(TRUE);\n\t\textra_char = NUL;\n\t\tif (c != NUL)\n\t\t    break;\n\n\t\tredrawcmd();\n\t\tgoto cmdline_not_changed;\n#endif // FEAT_DIGRAPHS\n\n#ifdef FEAT_RIGHTLEFT\n\tcase Ctrl__:\t    // CTRL-_: switch language mode\n\t\tif (!p_ari)\n\t\t    break;\n\t\tcmd_hkmap = !cmd_hkmap;\n\t\tgoto cmdline_not_changed;\n#endif\n\n\tcase K_PS:\n\t\tbracketed_paste(PASTE_CMDLINE, FALSE, NULL);\n\t\tgoto cmdline_changed;\n\n\tdefault:\n#ifdef UNIX\n\t\tif (c == intr_char)\n\t\t{\n\t\t    gotesc = TRUE;\t// will free ccline.cmdbuff after\n\t\t\t\t\t// putting it in history\n\t\t    goto returncmd;\t// back to Normal mode\n\t\t}\n#endif\n\t\t/*\n\t\t * Normal character with no special meaning.  Just set mod_mask\n\t\t * to 0x0 so that typing Shift-Space in the GUI doesn't enter\n\t\t * the string <S-Space>.  This should only happen after ^V.\n\t\t */\n\t\tif (!IS_SPECIAL(c))\n\t\t    mod_mask = 0x0;\n\t\tbreak;\n\t}\n\t/*\n\t * End of switch on command line character.\n\t * We come here if we have a normal character.\n\t */\n\n\tif (do_abbr && (IS_SPECIAL(c) || !vim_iswordc(c))\n\t\t&& (ccheck_abbr(\n\t\t\t// Add ABBR_OFF for characters above 0x100, this is\n\t\t\t// what check_abbr() expects.\n\t\t\t\t(has_mbyte && c >= 0x100) ? (c + ABBR_OFF) : c)\n\t\t    || c == Ctrl_RSB))\n\t    goto cmdline_changed;\n\n\t/*\n\t * put the character in the command line\n\t */\n\tif (IS_SPECIAL(c) || mod_mask != 0)\n\t    put_on_cmdline(get_special_key_name(c, mod_mask), -1, TRUE);\n\telse\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tj = (*mb_char2bytes)(c, IObuff);\n\t\tIObuff[j] = NUL;\t// exclude composing chars\n\t\tput_on_cmdline(IObuff, j, TRUE);\n\t    }\n\t    else\n\t    {\n\t\tIObuff[0] = c;\n\t\tput_on_cmdline(IObuff, 1, TRUE);\n\t    }\n\t}\n\tgoto cmdline_changed;\n\n/*\n * This part implements incremental searches for \"/\" and \"?\"\n * Jump to cmdline_not_changed when a character has been read but the command\n * line did not change. Then we only search and redraw if something changed in\n * the past.\n * Jump to cmdline_changed when the command line did change.\n * (Sorry for the goto's, I know it is ugly).\n */\ncmdline_not_changed:\n#ifdef FEAT_SEARCH_EXTRA\n\tif (!is_state.incsearch_postponed)\n\t    continue;\n#endif\n\ncmdline_changed:\n#ifdef FEAT_SEARCH_EXTRA\n\t// If the window changed incremental search state is not valid.\n\tif (is_state.winid != curwin->w_id)\n\t    init_incsearch_state(&is_state);\n#endif\n\tif (trigger_cmdlinechanged)\n\t    // Trigger CmdlineChanged autocommands.\n\t    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINECHANGED);\n\n#ifdef FEAT_SEARCH_EXTRA\n\tif (xpc.xp_context == EXPAND_NOTHING && (KeyTyped || vpeekc() == NUL))\n\t    may_do_incsearch_highlighting(firstc, count, &is_state);\n#endif\n\n#ifdef FEAT_RIGHTLEFT\n\tif (cmdmsg_rl\n# ifdef FEAT_ARABIC\n\t\t|| (p_arshape && !p_tbidi\n\t\t\t\t       && cmdline_has_arabic(0, ccline.cmdlen))\n# endif\n\t\t)\n\t    // Always redraw the whole command line to fix shaping and\n\t    // right-left typing.  Not efficient, but it works.\n\t    // Do it only when there are no characters left to read\n\t    // to avoid useless intermediate redraws.\n\t    if (vpeekc() == NUL)\n\t\tredrawcmd();\n#endif\n    }\n\nreturncmd:\n\n#ifdef FEAT_RIGHTLEFT\n    cmdmsg_rl = FALSE;\n#endif\n\n    ExpandCleanup(&xpc);\n    ccline.xpc = NULL;\n\n#ifdef FEAT_SEARCH_EXTRA\n    finish_incsearch_highlighting(gotesc, &is_state, FALSE);\n#endif\n\n    if (ccline.cmdbuff != NULL)\n    {\n\t/*\n\t * Put line in history buffer (\":\" and \"=\" only when it was typed).\n\t */\n\tif (ccline.cmdlen && firstc != NUL\n\t\t&& (some_key_typed || histype == HIST_SEARCH))\n\t{\n\t    add_to_history(histype, ccline.cmdbuff, TRUE,\n\t\t\t\t       histype == HIST_SEARCH ? firstc : NUL);\n\t    if (firstc == ':')\n\t    {\n\t\tvim_free(new_last_cmdline);\n\t\tnew_last_cmdline = vim_strsave(ccline.cmdbuff);\n\t    }\n\t}\n\n\tif (gotesc)\n\t    abandon_cmdline();\n    }\n\n    /*\n     * If the screen was shifted up, redraw the whole screen (later).\n     * If the line is too long, clear it, so ruler and shown command do\n     * not get printed in the middle of it.\n     */\n    msg_check();\n    msg_scroll = save_msg_scroll;\n    redir_off = FALSE;\n\n    // When the command line was typed, no need for a wait-return prompt.\n    if (some_key_typed)\n\tneed_wait_return = FALSE;\n\n    // Trigger CmdlineLeave autocommands.\n    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINELEAVE);\n\n    State = save_State;\n\n#ifdef FEAT_EVAL\n    if (!debug_mode)\n\tmay_trigger_modechanged();\n#endif\n\n#ifdef HAVE_INPUT_METHOD\n    if (b_im_ptr != NULL && *b_im_ptr != B_IMODE_LMAP)\n\tim_save_status(b_im_ptr);\n    im_set_active(FALSE);\n#endif\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n    sb_text_end_cmdline();\n\ntheend:\n    {\n\tchar_u *p = ccline.cmdbuff;\n\n\t--depth;\n\tif (did_save_ccline)\n\t    restore_cmdline(&save_ccline);\n\telse\n\t    ccline.cmdbuff = NULL;\n\treturn p;\n    }\n}\n\n#if (defined(FEAT_CRYPT) || defined(FEAT_EVAL)) || defined(PROTO)\n/*\n * Get a command line with a prompt.\n * This is prepared to be called recursively from getcmdline() (e.g. by\n * f_input() when evaluating an expression from CTRL-R =).\n * Returns the command line in allocated memory, or NULL.\n */\n    char_u *\ngetcmdline_prompt(\n    int\t\tfirstc,\n    char_u\t*prompt,\t// command line prompt\n    int\t\tattr,\t\t// attributes for prompt\n    int\t\txp_context,\t// type of expansion\n    char_u\t*xp_arg)\t// user-defined expansion argument\n{\n    char_u\t\t*s;\n    cmdline_info_T\tsave_ccline;\n    int\t\t\tdid_save_ccline = FALSE;\n    int\t\t\tmsg_col_save = msg_col;\n    int\t\t\tmsg_silent_save = msg_silent;\n\n    if (ccline.cmdbuff != NULL)\n    {\n\t// Save the values of the current cmdline and restore them below.\n\tsave_cmdline(&save_ccline);\n\tdid_save_ccline = TRUE;\n    }\n\n    CLEAR_FIELD(ccline);\n    ccline.cmdprompt = prompt;\n    ccline.cmdattr = attr;\n# ifdef FEAT_EVAL\n    ccline.xp_context = xp_context;\n    ccline.xp_arg = xp_arg;\n    ccline.input_fn = (firstc == '@');\n# endif\n    msg_silent = 0;\n    s = getcmdline_int(firstc, 1L, 0, FALSE);\n\n    if (did_save_ccline)\n\trestore_cmdline(&save_ccline);\n\n    msg_silent = msg_silent_save;\n    // Restore msg_col, the prompt from input() may have changed it.\n    // But only if called recursively and the commandline is therefore being\n    // restored to an old one; if not, the input() prompt stays on the screen,\n    // so we need its modified msg_col left intact.\n    if (ccline.cmdbuff != NULL)\n\tmsg_col = msg_col_save;\n\n    return s;\n}\n#endif\n\n/*\n * Read the 'wildmode' option, fill wim_flags[].\n */\n    int\ncheck_opt_wim(void)\n{\n    char_u\tnew_wim_flags[4];\n    char_u\t*p;\n    int\t\ti;\n    int\t\tidx = 0;\n\n    for (i = 0; i < 4; ++i)\n\tnew_wim_flags[i] = 0;\n\n    for (p = p_wim; *p; ++p)\n    {\n\tfor (i = 0; ASCII_ISALPHA(p[i]); ++i)\n\t    ;\n\tif (p[i] != NUL && p[i] != ',' && p[i] != ':')\n\t    return FAIL;\n\tif (i == 7 && STRNCMP(p, \"longest\", 7) == 0)\n\t    new_wim_flags[idx] |= WIM_LONGEST;\n\telse if (i == 4 && STRNCMP(p, \"full\", 4) == 0)\n\t    new_wim_flags[idx] |= WIM_FULL;\n\telse if (i == 4 && STRNCMP(p, \"list\", 4) == 0)\n\t    new_wim_flags[idx] |= WIM_LIST;\n\telse if (i == 8 && STRNCMP(p, \"lastused\", 8) == 0)\n\t    new_wim_flags[idx] |= WIM_BUFLASTUSED;\n\telse\n\t    return FAIL;\n\tp += i;\n\tif (*p == NUL)\n\t    break;\n\tif (*p == ',')\n\t{\n\t    if (idx == 3)\n\t\treturn FAIL;\n\t    ++idx;\n\t}\n    }\n\n    // fill remaining entries with last flag\n    while (idx < 3)\n    {\n\tnew_wim_flags[idx + 1] = new_wim_flags[idx];\n\t++idx;\n    }\n\n    // only when there are no errors, wim_flags[] is changed\n    for (i = 0; i < 4; ++i)\n\twim_flags[i] = new_wim_flags[i];\n    return OK;\n}\n\n/*\n * Return TRUE when the text must not be changed and we can't switch to\n * another window or buffer.  TRUE when editing the command line, evaluating\n * 'balloonexpr', etc.\n */\n    int\ntext_locked(void)\n{\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n\treturn TRUE;\n#endif\n    return textlock != 0;\n}\n\n/*\n * Give an error message for a command that isn't allowed while the cmdline\n * window is open or editing the cmdline in another way.\n */\n    void\ntext_locked_msg(void)\n{\n    emsg(_(get_text_locked_msg()));\n}\n\n    char *\nget_text_locked_msg(void)\n{\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n\treturn e_invalid_in_cmdline_window;\n#endif\n    return e_not_allowed_to_change_text_or_change_window;\n}\n\n/*\n * Check for text, window or buffer locked.\n * Give an error message and return TRUE if something is locked.\n */\n    int\ntext_or_buf_locked(void)\n{\n    if (text_locked())\n    {\n\ttext_locked_msg();\n\treturn TRUE;\n    }\n    return curbuf_locked();\n}\n\n/*\n * Check if \"curbuf_lock\" or \"allbuf_lock\" is set and return TRUE when it is\n * and give an error message.\n */\n    int\ncurbuf_locked(void)\n{\n    if (curbuf_lock > 0)\n    {\n\temsg(_(e_not_allowed_to_edit_another_buffer_now));\n\treturn TRUE;\n    }\n    return allbuf_locked();\n}\n\n/*\n * Check if \"allbuf_lock\" is set and return TRUE when it is and give an error\n * message.\n */\n    int\nallbuf_locked(void)\n{\n    if (allbuf_lock > 0)\n    {\n\temsg(_(e_not_allowed_to_change_buffer_information_now));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n    static int\ncmdline_charsize(int idx)\n{\n#if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\n    if (cmdline_star > 0)\t    // showing '*', always 1 position\n\treturn 1;\n#endif\n    return ptr2cells(ccline.cmdbuff + idx);\n}\n\n/*\n * Compute the offset of the cursor on the command line for the prompt and\n * indent.\n */\n    static void\nset_cmdspos(void)\n{\n    if (ccline.cmdfirstc != NUL)\n\tccline.cmdspos = 1 + ccline.cmdindent;\n    else\n\tccline.cmdspos = 0 + ccline.cmdindent;\n}\n\n/*\n * Compute the screen position for the cursor on the command line.\n */\n    static void\nset_cmdspos_cursor(void)\n{\n    int\t\ti, m, c;\n\n    set_cmdspos();\n    if (KeyTyped)\n    {\n\tm = Columns * Rows;\n\tif (m < 0)\t// overflow, Columns or Rows at weird value\n\t    m = MAXCOL;\n    }\n    else\n\tm = MAXCOL;\n    for (i = 0; i < ccline.cmdlen && i < ccline.cmdpos; ++i)\n    {\n\tc = cmdline_charsize(i);\n\t// Count \">\" for double-wide multi-byte char that doesn't fit.\n\tif (has_mbyte)\n\t    correct_cmdspos(i, c);\n\t// If the cmdline doesn't fit, show cursor on last visible char.\n\t// Don't move the cursor itself, so we can still append.\n\tif ((ccline.cmdspos += c) >= m)\n\t{\n\t    ccline.cmdspos -= c;\n\t    break;\n\t}\n\tif (has_mbyte)\n\t    i += (*mb_ptr2len)(ccline.cmdbuff + i) - 1;\n    }\n}\n\n/*\n * Check if the character at \"idx\", which is \"cells\" wide, is a multi-byte\n * character that doesn't fit, so that a \">\" must be displayed.\n */\n    static void\ncorrect_cmdspos(int idx, int cells)\n{\n    if ((*mb_ptr2len)(ccline.cmdbuff + idx) > 1\n\t\t&& (*mb_ptr2cells)(ccline.cmdbuff + idx) > 1\n\t\t&& ccline.cmdspos % Columns + cells > Columns)\n\tccline.cmdspos++;\n}\n\n/*\n * Get an Ex command line for the \":\" command.\n */\n    char_u *\ngetexline(\n    int\t\tc,\t\t// normally ':', NUL for \":append\"\n    void\t*cookie UNUSED,\n    int\t\tindent,\t\t// indent for inside conditionals\n    getline_opt_T options)\n{\n    // When executing a register, remove ':' that's in front of each line.\n    if (exec_from_reg && vpeekc() == ':')\n\t(void)vgetc();\n    return getcmdline(c, 1L, indent, options);\n}\n\n/*\n * Get an Ex command line for Ex mode.\n * In Ex mode we only use the OS supplied line editing features and no\n * mappings or abbreviations.\n * Returns a string in allocated memory or NULL.\n */\n    char_u *\ngetexmodeline(\n    int\t\tpromptc,\t// normally ':', NUL for \":append\" and '?' for\n\t\t\t\t// :s prompt\n    void\t*cookie UNUSED,\n    int\t\tindent,\t\t// indent for inside conditionals\n    getline_opt_T options UNUSED)\n{\n    garray_T\tline_ga;\n    char_u\t*pend;\n    int\t\tstartcol = 0;\n    int\t\tc1 = 0;\n    int\t\tescaped = FALSE;\t// CTRL-V typed\n    int\t\tvcol = 0;\n    char_u\t*p;\n    int\t\tprev_char;\n    int\t\tlen;\n\n    // Switch cursor on now.  This avoids that it happens after the \"\\n\", which\n    // confuses the system function that computes tabstops.\n    cursor_on();\n\n    // always start in column 0; write a newline if necessary\n    compute_cmdrow();\n    if ((msg_col || msg_didout) && promptc != '?')\n\tmsg_putchar('\\n');\n    if (promptc == ':')\n    {\n\t// indent that is only displayed, not in the line itself\n\tif (p_prompt)\n\t    msg_putchar(':');\n\twhile (indent-- > 0)\n\t    msg_putchar(' ');\n\tstartcol = msg_col;\n    }\n\n    ga_init2(&line_ga, 1, 30);\n\n    // autoindent for :insert and :append is in the line itself\n    if (promptc <= 0)\n    {\n\tvcol = indent;\n\twhile (indent >= 8)\n\t{\n\t    ga_append(&line_ga, TAB);\n\t    msg_puts(\"        \");\n\t    indent -= 8;\n\t}\n\twhile (indent-- > 0)\n\t{\n\t    ga_append(&line_ga, ' ');\n\t    msg_putchar(' ');\n\t}\n    }\n    ++no_mapping;\n    ++allow_keys;\n\n    /*\n     * Get the line, one character at a time.\n     */\n    got_int = FALSE;\n    while (!got_int)\n    {\n\tlong    sw;\n\tchar_u *s;\n\n\tif (ga_grow(&line_ga, 40) == FAIL)\n\t    break;\n\n\t/*\n\t * Get one character at a time.\n\t */\n\tprev_char = c1;\n\n\t// Check for a \":normal\" command and no more characters left.\n\tif (ex_normal_busy > 0 && typebuf.tb_len == 0)\n\t    c1 = '\\n';\n\telse\n\t    c1 = vgetc();\n\n\t/*\n\t * Handle line editing.\n\t * Previously this was left to the system, putting the terminal in\n\t * cooked mode, but then CTRL-D and CTRL-T can't be used properly.\n\t */\n\tif (got_int)\n\t{\n\t    msg_putchar('\\n');\n\t    break;\n\t}\n\n\tif (c1 == K_PS)\n\t{\n\t    bracketed_paste(PASTE_EX, FALSE, &line_ga);\n\t    goto redraw;\n\t}\n\n\tif (!escaped)\n\t{\n\t    // CR typed means \"enter\", which is NL\n\t    if (c1 == '\\r')\n\t\tc1 = '\\n';\n\n\t    if (c1 == BS || c1 == K_BS\n\t\t\t  || c1 == DEL || c1 == K_DEL || c1 == K_KDEL)\n\t    {\n\t\tif (line_ga.ga_len > 0)\n\t\t{\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\tp = (char_u *)line_ga.ga_data;\n\t\t\tp[line_ga.ga_len] = NUL;\n\t\t\tlen = (*mb_head_off)(p, p + line_ga.ga_len - 1) + 1;\n\t\t\tline_ga.ga_len -= len;\n\t\t    }\n\t\t    else\n\t\t\t--line_ga.ga_len;\n\t\t    goto redraw;\n\t\t}\n\t\tcontinue;\n\t    }\n\n\t    if (c1 == Ctrl_U)\n\t    {\n\t\tmsg_col = startcol;\n\t\tmsg_clr_eos();\n\t\tline_ga.ga_len = 0;\n\t\tgoto redraw;\n\t    }\n\n\t    if (c1 == Ctrl_T)\n\t    {\n\t\tsw = get_sw_value(curbuf);\n\t\tp = (char_u *)line_ga.ga_data;\n\t\tp[line_ga.ga_len] = NUL;\n\t\tindent = get_indent_str(p, 8, FALSE);\n\t\tindent += sw - indent % sw;\nadd_indent:\n\t\twhile (get_indent_str(p, 8, FALSE) < indent)\n\t\t{\n\t\t    (void)ga_grow(&line_ga, 2);  // one more for the NUL\n\t\t    p = (char_u *)line_ga.ga_data;\n\t\t    s = skipwhite(p);\n\t\t    mch_memmove(s + 1, s, line_ga.ga_len - (s - p) + 1);\n\t\t    *s = ' ';\n\t\t    ++line_ga.ga_len;\n\t\t}\nredraw:\n\t\t// redraw the line\n\t\tmsg_col = startcol;\n\t\tvcol = 0;\n\t\tp = (char_u *)line_ga.ga_data;\n\t\tp[line_ga.ga_len] = NUL;\n\t\twhile (p < (char_u *)line_ga.ga_data + line_ga.ga_len)\n\t\t{\n\t\t    if (*p == TAB)\n\t\t    {\n\t\t\tdo\n\t\t\t    msg_putchar(' ');\n\t\t\twhile (++vcol % 8);\n\t\t\t++p;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tlen = mb_ptr2len(p);\n\t\t\tmsg_outtrans_len(p, len);\n\t\t\tvcol += ptr2cells(p);\n\t\t\tp += len;\n\t\t    }\n\t\t}\n\t\tmsg_clr_eos();\n\t\twindgoto(msg_row, msg_col);\n\t\tcontinue;\n\t    }\n\n\t    if (c1 == Ctrl_D)\n\t    {\n\t\t// Delete one shiftwidth.\n\t\tp = (char_u *)line_ga.ga_data;\n\t\tif (prev_char == '0' || prev_char == '^')\n\t\t{\n\t\t    if (prev_char == '^')\n\t\t\tex_keep_indent = TRUE;\n\t\t    indent = 0;\n\t\t    p[--line_ga.ga_len] = NUL;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[line_ga.ga_len] = NUL;\n\t\t    indent = get_indent_str(p, 8, FALSE);\n\t\t    if (indent > 0)\n\t\t    {\n\t\t\t--indent;\n\t\t\tindent -= indent % get_sw_value(curbuf);\n\t\t    }\n\t\t}\n\t\twhile (get_indent_str(p, 8, FALSE) > indent)\n\t\t{\n\t\t    s = skipwhite(p);\n\t\t    mch_memmove(s - 1, s, line_ga.ga_len - (s - p) + 1);\n\t\t    --line_ga.ga_len;\n\t\t}\n\t\tgoto add_indent;\n\t    }\n\n\t    if (c1 == Ctrl_V || c1 == Ctrl_Q)\n\t    {\n\t\tescaped = TRUE;\n\t\tcontinue;\n\t    }\n\n\t    // Ignore special key codes: mouse movement, K_IGNORE, etc.\n\t    if (IS_SPECIAL(c1))\n\t\tcontinue;\n\t}\n\n\tif (IS_SPECIAL(c1))\n\t    c1 = '?';\n\tif (has_mbyte)\n\t    len = (*mb_char2bytes)(c1,\n\t\t\t\t  (char_u *)line_ga.ga_data + line_ga.ga_len);\n\telse\n\t{\n\t    len = 1;\n\t    ((char_u *)line_ga.ga_data)[line_ga.ga_len] = c1;\n\t}\n\tif (c1 == '\\n')\n\t    msg_putchar('\\n');\n\telse if (c1 == TAB)\n\t{\n\t    // Don't use chartabsize(), 'ts' can be different\n\t    do\n\t\tmsg_putchar(' ');\n\t    while (++vcol % 8);\n\t}\n\telse\n\t{\n\t    msg_outtrans_len(\n\t\t     ((char_u *)line_ga.ga_data) + line_ga.ga_len, len);\n\t    vcol += char2cells(c1);\n\t}\n\tline_ga.ga_len += len;\n\tescaped = FALSE;\n\n\twindgoto(msg_row, msg_col);\n\tpend = (char_u *)(line_ga.ga_data) + line_ga.ga_len;\n\n\t// We are done when a NL is entered, but not when it comes after an\n\t// odd number of backslashes, that results in a NUL.\n\tif (line_ga.ga_len > 0 && pend[-1] == '\\n')\n\t{\n\t    int bcount = 0;\n\n\t    while (line_ga.ga_len - 2 >= bcount && pend[-2 - bcount] == '\\\\')\n\t\t++bcount;\n\n\t    if (bcount > 0)\n\t    {\n\t\t// Halve the number of backslashes: \"\\NL\" -> \"NUL\", \"\\\\NL\" ->\n\t\t// \"\\NL\", etc.\n\t\tline_ga.ga_len -= (bcount + 1) / 2;\n\t\tpend -= (bcount + 1) / 2;\n\t\tpend[-1] = '\\n';\n\t    }\n\n\t    if ((bcount & 1) == 0)\n\t    {\n\t\t--line_ga.ga_len;\n\t\t--pend;\n\t\t*pend = NUL;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    --no_mapping;\n    --allow_keys;\n\n    // make following messages go to the next line\n    msg_didout = FALSE;\n    msg_col = 0;\n    if (msg_row < Rows - 1)\n\t++msg_row;\n    emsg_on_display = FALSE;\t\t// don't want ui_delay()\n\n    if (got_int)\n\tga_clear(&line_ga);\n\n    return (char_u *)line_ga.ga_data;\n}\n\n# if defined(MCH_CURSOR_SHAPE) || defined(FEAT_GUI) \\\n\t|| defined(FEAT_MOUSESHAPE) || defined(PROTO)\n/*\n * Return TRUE if ccline.overstrike is on.\n */\n    int\ncmdline_overstrike(void)\n{\n    return ccline.overstrike;\n}\n\n/*\n * Return TRUE if the cursor is at the end of the cmdline.\n */\n    int\ncmdline_at_end(void)\n{\n    return (ccline.cmdpos >= ccline.cmdlen);\n}\n#endif\n\n#if (defined(FEAT_XIM) && (defined(FEAT_GUI_GTK))) || defined(PROTO)\n/*\n * Return the virtual column number at the current cursor position.\n * This is used by the IM code to obtain the start of the preedit string.\n */\n    colnr_T\ncmdline_getvcol_cursor(void)\n{\n    if (ccline.cmdbuff == NULL || ccline.cmdpos > ccline.cmdlen)\n\treturn MAXCOL;\n\n    if (has_mbyte)\n    {\n\tcolnr_T\tcol;\n\tint\ti = 0;\n\n\tfor (col = 0; i < ccline.cmdpos; ++col)\n\t    i += (*mb_ptr2len)(ccline.cmdbuff + i);\n\n\treturn col;\n    }\n    else\n\treturn ccline.cmdpos;\n}\n#endif\n\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n/*\n * If part of the command line is an IM preedit string, redraw it with\n * IM feedback attributes.  The cursor position is restored after drawing.\n */\n    static void\nredrawcmd_preedit(void)\n{\n    if ((State & MODE_CMDLINE)\n\t    && xic != NULL\n\t    // && im_get_status()  doesn't work when using SCIM\n\t    && !p_imdisable\n\t    && im_is_preediting())\n    {\n\tint\tcmdpos = 0;\n\tint\tcmdspos;\n\tint\told_row;\n\tint\told_col;\n\tcolnr_T\tcol;\n\n\told_row = msg_row;\n\told_col = msg_col;\n\tcmdspos = ((ccline.cmdfirstc != NUL) ? 1 : 0) + ccline.cmdindent;\n\n\tif (has_mbyte)\n\t{\n\t    for (col = 0; col < preedit_start_col\n\t\t\t  && cmdpos < ccline.cmdlen; ++col)\n\t    {\n\t\tcmdspos += (*mb_ptr2cells)(ccline.cmdbuff + cmdpos);\n\t\tcmdpos  += (*mb_ptr2len)(ccline.cmdbuff + cmdpos);\n\t    }\n\t}\n\telse\n\t{\n\t    cmdspos += preedit_start_col;\n\t    cmdpos  += preedit_start_col;\n\t}\n\n\tmsg_row = cmdline_row + (cmdspos / (int)Columns);\n\tmsg_col = cmdspos % (int)Columns;\n\tif (msg_row >= Rows)\n\t    msg_row = Rows - 1;\n\n\tfor (col = 0; cmdpos < ccline.cmdlen; ++col)\n\t{\n\t    int char_len;\n\t    int char_attr;\n\n\t    char_attr = im_get_feedback_attr(col);\n\t    if (char_attr < 0)\n\t\tbreak; // end of preedit string\n\n\t    if (has_mbyte)\n\t\tchar_len = (*mb_ptr2len)(ccline.cmdbuff + cmdpos);\n\t    else\n\t\tchar_len = 1;\n\n\t    msg_outtrans_len_attr(ccline.cmdbuff + cmdpos, char_len, char_attr);\n\t    cmdpos += char_len;\n\t}\n\n\tmsg_row = old_row;\n\tmsg_col = old_col;\n    }\n}\n#endif // FEAT_XIM && FEAT_GUI_GTK\n\n/*\n * Allocate a new command line buffer.\n * Assigns the new buffer to ccline.cmdbuff and ccline.cmdbufflen.\n */\n    static void\nalloc_cmdbuff(int len)\n{\n    /*\n     * give some extra space to avoid having to allocate all the time\n     */\n    if (len < 80)\n\tlen = 100;\n    else\n\tlen += 20;\n\n    ccline.cmdbuff = alloc(len);    // caller should check for out-of-memory\n    ccline.cmdbufflen = len;\n}\n\n/*\n * Re-allocate the command line to length len + something extra.\n * return FAIL for failure, OK otherwise\n */\n    int\nrealloc_cmdbuff(int len)\n{\n    char_u\t*p;\n\n    if (len < ccline.cmdbufflen)\n\treturn OK;\t\t\t// no need to resize\n\n    p = ccline.cmdbuff;\n    alloc_cmdbuff(len);\t\t\t// will get some more\n    if (ccline.cmdbuff == NULL)\t\t// out of memory\n    {\n\tccline.cmdbuff = p;\t\t// keep the old one\n\treturn FAIL;\n    }\n    // There isn't always a NUL after the command, but it may need to be\n    // there, thus copy up to the NUL and add a NUL.\n    mch_memmove(ccline.cmdbuff, p, (size_t)ccline.cmdlen);\n    ccline.cmdbuff[ccline.cmdlen] = NUL;\n    vim_free(p);\n\n    if (ccline.xpc != NULL\n\t    && ccline.xpc->xp_pattern != NULL\n\t    && ccline.xpc->xp_context != EXPAND_NOTHING\n\t    && ccline.xpc->xp_context != EXPAND_UNSUCCESSFUL)\n    {\n\tint i = (int)(ccline.xpc->xp_pattern - p);\n\n\t// If xp_pattern points inside the old cmdbuff it needs to be adjusted\n\t// to point into the newly allocated memory.\n\tif (i >= 0 && i <= ccline.cmdlen)\n\t    ccline.xpc->xp_pattern = ccline.cmdbuff + i;\n    }\n\n    return OK;\n}\n\n#if defined(FEAT_ARABIC) || defined(PROTO)\nstatic char_u\t*arshape_buf = NULL;\n\n# if defined(EXITFREE) || defined(PROTO)\n    void\nfree_arshape_buf(void)\n{\n    vim_free(arshape_buf);\n}\n# endif\n#endif\n\n/*\n * Draw part of the cmdline at the current cursor position.  But draw stars\n * when cmdline_star is TRUE.\n */\n    static void\ndraw_cmdline(int start, int len)\n{\n#if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\n    int\t\ti;\n\n    if (cmdline_star > 0)\n\tfor (i = 0; i < len; ++i)\n\t{\n\t    msg_putchar('*');\n\t    if (has_mbyte)\n\t\ti += (*mb_ptr2len)(ccline.cmdbuff + start + i) - 1;\n\t}\n    else\n#endif\n#ifdef FEAT_ARABIC\n\tif (p_arshape && !p_tbidi && cmdline_has_arabic(start, len))\n    {\n\tstatic int\tbuflen = 0;\n\tchar_u\t\t*p;\n\tint\t\tj;\n\tint\t\tnewlen = 0;\n\tint\t\tmb_l;\n\tint\t\tpc, pc1 = 0;\n\tint\t\tprev_c = 0;\n\tint\t\tprev_c1 = 0;\n\tint\t\tu8c;\n\tint\t\tu8cc[MAX_MCO];\n\tint\t\tnc = 0;\n\n\t/*\n\t * Do arabic shaping into a temporary buffer.  This is very\n\t * inefficient!\n\t */\n\tif (len * 2 + 2 > buflen)\n\t{\n\t    // Re-allocate the buffer.  We keep it around to avoid a lot of\n\t    // alloc()/free() calls.\n\t    vim_free(arshape_buf);\n\t    buflen = len * 2 + 2;\n\t    arshape_buf = alloc(buflen);\n\t    if (arshape_buf == NULL)\n\t\treturn;\t// out of memory\n\t}\n\n\tif (utf_iscomposing(utf_ptr2char(ccline.cmdbuff + start)))\n\t{\n\t    // Prepend a space to draw the leading composing char on.\n\t    arshape_buf[0] = ' ';\n\t    newlen = 1;\n\t}\n\n\tfor (j = start; j < start + len; j += mb_l)\n\t{\n\t    p = ccline.cmdbuff + j;\n\t    u8c = utfc_ptr2char_len(p, u8cc, start + len - j);\n\t    mb_l = utfc_ptr2len_len(p, start + len - j);\n\t    if (ARABIC_CHAR(u8c))\n\t    {\n\t\t// Do Arabic shaping.\n\t\tif (cmdmsg_rl)\n\t\t{\n\t\t    // displaying from right to left\n\t\t    pc = prev_c;\n\t\t    pc1 = prev_c1;\n\t\t    prev_c1 = u8cc[0];\n\t\t    if (j + mb_l >= start + len)\n\t\t\tnc = NUL;\n\t\t    else\n\t\t\tnc = utf_ptr2char(p + mb_l);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // displaying from left to right\n\t\t    if (j + mb_l >= start + len)\n\t\t\tpc = NUL;\n\t\t    else\n\t\t    {\n\t\t\tint\tpcc[MAX_MCO];\n\n\t\t\tpc = utfc_ptr2char_len(p + mb_l, pcc,\n\t\t\t\t\t\t      start + len - j - mb_l);\n\t\t\tpc1 = pcc[0];\n\t\t    }\n\t\t    nc = prev_c;\n\t\t}\n\t\tprev_c = u8c;\n\n\t\tu8c = arabic_shape(u8c, NULL, &u8cc[0], pc, pc1, nc);\n\n\t\tnewlen += (*mb_char2bytes)(u8c, arshape_buf + newlen);\n\t\tif (u8cc[0] != 0)\n\t\t{\n\t\t    newlen += (*mb_char2bytes)(u8cc[0], arshape_buf + newlen);\n\t\t    if (u8cc[1] != 0)\n\t\t\tnewlen += (*mb_char2bytes)(u8cc[1],\n\t\t\t\t\t\t\tarshape_buf + newlen);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tprev_c = u8c;\n\t\tmch_memmove(arshape_buf + newlen, p, mb_l);\n\t\tnewlen += mb_l;\n\t    }\n\t}\n\n\tmsg_outtrans_len(arshape_buf, newlen);\n    }\n    else\n#endif\n\tmsg_outtrans_len(ccline.cmdbuff + start, len);\n}\n\n/*\n * Put a character on the command line.  Shifts the following text to the\n * right when \"shift\" is TRUE.  Used for CTRL-V, CTRL-K, etc.\n * \"c\" must be printable (fit in one display cell)!\n */\n    void\nputcmdline(int c, int shift)\n{\n    if (cmd_silent)\n\treturn;\n    msg_no_more = TRUE;\n    msg_putchar(c);\n    if (shift)\n\tdraw_cmdline(ccline.cmdpos, ccline.cmdlen - ccline.cmdpos);\n    msg_no_more = FALSE;\n    cursorcmd();\n    extra_char = c;\n    extra_char_shift = shift;\n}\n\n/*\n * Undo a putcmdline(c, FALSE).\n */\n    void\nunputcmdline(void)\n{\n    if (cmd_silent)\n\treturn;\n    msg_no_more = TRUE;\n    if (ccline.cmdlen == ccline.cmdpos)\n\tmsg_putchar(' ');\n    else if (has_mbyte)\n\tdraw_cmdline(ccline.cmdpos,\n\t\t\t       (*mb_ptr2len)(ccline.cmdbuff + ccline.cmdpos));\n    else\n\tdraw_cmdline(ccline.cmdpos, 1);\n    msg_no_more = FALSE;\n    cursorcmd();\n    extra_char = NUL;\n}\n\n/*\n * Put the given string, of the given length, onto the command line.\n * If len is -1, then STRLEN() is used to calculate the length.\n * If 'redraw' is TRUE then the new part of the command line, and the remaining\n * part will be redrawn, otherwise it will not.  If this function is called\n * twice in a row, then 'redraw' should be FALSE and redrawcmd() should be\n * called afterwards.\n */\n    int\nput_on_cmdline(char_u *str, int len, int redraw)\n{\n    int\t\tretval;\n    int\t\ti;\n    int\t\tm;\n    int\t\tc;\n\n    if (len < 0)\n\tlen = (int)STRLEN(str);\n\n    // Check if ccline.cmdbuff needs to be longer\n    if (ccline.cmdlen + len + 1 >= ccline.cmdbufflen)\n\tretval = realloc_cmdbuff(ccline.cmdlen + len + 1);\n    else\n\tretval = OK;\n    if (retval == OK)\n    {\n\tif (!ccline.overstrike)\n\t{\n\t    mch_memmove(ccline.cmdbuff + ccline.cmdpos + len,\n\t\t\t\t\t       ccline.cmdbuff + ccline.cmdpos,\n\t\t\t\t     (size_t)(ccline.cmdlen - ccline.cmdpos));\n\t    ccline.cmdlen += len;\n\t}\n\telse\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\t// Count nr of characters in the new string.\n\t\tm = 0;\n\t\tfor (i = 0; i < len; i += (*mb_ptr2len)(str + i))\n\t\t    ++m;\n\t\t// Count nr of bytes in cmdline that are overwritten by these\n\t\t// characters.\n\t\tfor (i = ccline.cmdpos; i < ccline.cmdlen && m > 0;\n\t\t\t\t i += (*mb_ptr2len)(ccline.cmdbuff + i))\n\t\t    --m;\n\t\tif (i < ccline.cmdlen)\n\t\t{\n\t\t    mch_memmove(ccline.cmdbuff + ccline.cmdpos + len,\n\t\t\t    ccline.cmdbuff + i, (size_t)(ccline.cmdlen - i));\n\t\t    ccline.cmdlen += ccline.cmdpos + len - i;\n\t\t}\n\t\telse\n\t\t    ccline.cmdlen = ccline.cmdpos + len;\n\t    }\n\t    else if (ccline.cmdpos + len > ccline.cmdlen)\n\t\tccline.cmdlen = ccline.cmdpos + len;\n\t}\n\tmch_memmove(ccline.cmdbuff + ccline.cmdpos, str, (size_t)len);\n\tccline.cmdbuff[ccline.cmdlen] = NUL;\n\n\tif (enc_utf8)\n\t{\n\t    // When the inserted text starts with a composing character,\n\t    // backup to the character before it.  There could be two of them.\n\t    i = 0;\n\t    c = utf_ptr2char(ccline.cmdbuff + ccline.cmdpos);\n\t    while (ccline.cmdpos > 0 && utf_iscomposing(c))\n\t    {\n\t\ti = (*mb_head_off)(ccline.cmdbuff,\n\t\t\t\t      ccline.cmdbuff + ccline.cmdpos - 1) + 1;\n\t\tccline.cmdpos -= i;\n\t\tlen += i;\n\t\tc = utf_ptr2char(ccline.cmdbuff + ccline.cmdpos);\n\t    }\n#ifdef FEAT_ARABIC\n\t    if (i == 0 && ccline.cmdpos > 0 && arabic_maycombine(c))\n\t    {\n\t\t// Check the previous character for Arabic combining pair.\n\t\ti = (*mb_head_off)(ccline.cmdbuff,\n\t\t\t\t      ccline.cmdbuff + ccline.cmdpos - 1) + 1;\n\t\tif (arabic_combine(utf_ptr2char(ccline.cmdbuff\n\t\t\t\t\t\t     + ccline.cmdpos - i), c))\n\t\t{\n\t\t    ccline.cmdpos -= i;\n\t\t    len += i;\n\t\t}\n\t\telse\n\t\t    i = 0;\n\t    }\n#endif\n\t    if (i != 0)\n\t    {\n\t\t// Also backup the cursor position.\n\t\ti = ptr2cells(ccline.cmdbuff + ccline.cmdpos);\n\t\tccline.cmdspos -= i;\n\t\tmsg_col -= i;\n\t\tif (msg_col < 0)\n\t\t{\n\t\t    msg_col += Columns;\n\t\t    --msg_row;\n\t\t}\n\t    }\n\t}\n\n\tif (redraw && !cmd_silent)\n\t{\n\t    msg_no_more = TRUE;\n\t    i = cmdline_row;\n\t    cursorcmd();\n\t    draw_cmdline(ccline.cmdpos, ccline.cmdlen - ccline.cmdpos);\n\t    // Avoid clearing the rest of the line too often.\n\t    if (cmdline_row != i || ccline.overstrike)\n\t\tmsg_clr_eos();\n\t    msg_no_more = FALSE;\n\t}\n\tif (KeyTyped)\n\t{\n\t    m = Columns * Rows;\n\t    if (m < 0)\t// overflow, Columns or Rows at weird value\n\t\tm = MAXCOL;\n\t}\n\telse\n\t    m = MAXCOL;\n\tfor (i = 0; i < len; ++i)\n\t{\n\t    c = cmdline_charsize(ccline.cmdpos);\n\t    // count \">\" for a double-wide char that doesn't fit.\n\t    if (has_mbyte)\n\t\tcorrect_cmdspos(ccline.cmdpos, c);\n\t    // Stop cursor at the end of the screen, but do increment the\n\t    // insert position, so that entering a very long command\n\t    // works, even though you can't see it.\n\t    if (ccline.cmdspos + c < m)\n\t\tccline.cmdspos += c;\n\n\t    if (has_mbyte)\n\t    {\n\t\tc = (*mb_ptr2len)(ccline.cmdbuff + ccline.cmdpos) - 1;\n\t\tif (c > len - i - 1)\n\t\t    c = len - i - 1;\n\t\tccline.cmdpos += c;\n\t\ti += c;\n\t    }\n\t    ++ccline.cmdpos;\n\t}\n    }\n    if (redraw)\n\tmsg_check();\n    return retval;\n}\n\nstatic cmdline_info_T\tprev_ccline;\nstatic int\t\tprev_ccline_used = FALSE;\n\n/*\n * Save ccline, because obtaining the \"=\" register may execute \"normal :cmd\"\n * and overwrite it.  But get_cmdline_str() may need it, thus make it\n * available globally in prev_ccline.\n */\n    static void\nsave_cmdline(cmdline_info_T *ccp)\n{\n    if (!prev_ccline_used)\n    {\n\tCLEAR_FIELD(prev_ccline);\n\tprev_ccline_used = TRUE;\n    }\n    *ccp = prev_ccline;\n    prev_ccline = ccline;\n    ccline.cmdbuff = NULL;  // signal that ccline is not in use\n}\n\n/*\n * Restore ccline after it has been saved with save_cmdline().\n */\n    static void\nrestore_cmdline(cmdline_info_T *ccp)\n{\n    ccline = prev_ccline;\n    prev_ccline = *ccp;\n}\n\n/*\n * Paste a yank register into the command line.\n * Used by CTRL-R command in command-line mode.\n * insert_reg() can't be used here, because special characters from the\n * register contents will be interpreted as commands.\n *\n * Return FAIL for failure, OK otherwise.\n */\n    static int\ncmdline_paste(\n    int regname,\n    int literally,\t// Insert text literally instead of \"as typed\"\n    int remcr)\t\t// remove trailing CR\n{\n    long\t\ti;\n    char_u\t\t*arg;\n    char_u\t\t*p;\n    int\t\t\tallocated;\n\n    // check for valid regname; also accept special characters for CTRL-R in\n    // the command line\n    if (regname != Ctrl_F && regname != Ctrl_P && regname != Ctrl_W\n\t    && regname != Ctrl_A && regname != Ctrl_L\n\t    && !valid_yank_reg(regname, FALSE))\n\treturn FAIL;\n\n    // A register containing CTRL-R can cause an endless loop.  Allow using\n    // CTRL-C to break the loop.\n    line_breakcheck();\n    if (got_int)\n\treturn FAIL;\n\n#ifdef FEAT_CLIPBOARD\n    regname = may_get_selection(regname);\n#endif\n\n    // Need to set \"textlock\" to avoid nasty things like going to another\n    // buffer when evaluating an expression.\n    ++textlock;\n    i = get_spec_reg(regname, &arg, &allocated, TRUE);\n    --textlock;\n\n    if (i)\n    {\n\t// Got the value of a special register in \"arg\".\n\tif (arg == NULL)\n\t    return FAIL;\n\n\t// When 'incsearch' is set and CTRL-R CTRL-W used: skip the duplicate\n\t// part of the word.\n\tp = arg;\n\tif (p_is && regname == Ctrl_W)\n\t{\n\t    char_u  *w;\n\t    int\t    len;\n\n\t    // Locate start of last word in the cmd buffer.\n\t    for (w = ccline.cmdbuff + ccline.cmdpos; w > ccline.cmdbuff; )\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    len = (*mb_head_off)(ccline.cmdbuff, w - 1) + 1;\n\t\t    if (!vim_iswordc(mb_ptr2char(w - len)))\n\t\t\tbreak;\n\t\t    w -= len;\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (!vim_iswordc(w[-1]))\n\t\t\tbreak;\n\t\t    --w;\n\t\t}\n\t    }\n\t    len = (int)((ccline.cmdbuff + ccline.cmdpos) - w);\n\t    if (p_ic ? STRNICMP(w, arg, len) == 0 : STRNCMP(w, arg, len) == 0)\n\t\tp += len;\n\t}\n\n\tcmdline_paste_str(p, literally);\n\tif (allocated)\n\t    vim_free(arg);\n\treturn OK;\n    }\n\n    return cmdline_paste_reg(regname, literally, remcr);\n}\n\n/*\n * Put a string on the command line.\n * When \"literally\" is TRUE, insert literally.\n * When \"literally\" is FALSE, insert as typed, but don't leave the command\n * line.\n */\n    void\ncmdline_paste_str(char_u *s, int literally)\n{\n    int\t\tc, cv;\n\n    if (literally)\n\tput_on_cmdline(s, -1, TRUE);\n    else\n\twhile (*s != NUL)\n\t{\n\t    cv = *s;\n\t    if (cv == Ctrl_V && s[1])\n\t\t++s;\n\t    if (has_mbyte)\n\t\tc = mb_cptr2char_adv(&s);\n\t    else\n\t\tc = *s++;\n\t    if (cv == Ctrl_V || c == ESC || c == Ctrl_C\n\t\t    || c == CAR || c == NL || c == Ctrl_L\n#ifdef UNIX\n\t\t    || c == intr_char\n#endif\n\t\t    || (c == Ctrl_BSL && *s == Ctrl_N))\n\t\tstuffcharReadbuff(Ctrl_V);\n\t    stuffcharReadbuff(c);\n\t}\n}\n\n/*\n * This function is called when the screen size changes and with incremental\n * search and in other situations where the command line may have been\n * overwritten.\n */\n    void\nredrawcmdline(void)\n{\n    redrawcmdline_ex(TRUE);\n}\n\n/*\n * When \"do_compute_cmdrow\" is TRUE the command line is redrawn at the bottom.\n * If FALSE cmdline_row is used, which should redraw in the same place.\n */\n    void\nredrawcmdline_ex(int do_compute_cmdrow)\n{\n    if (cmd_silent)\n\treturn;\n    need_wait_return = FALSE;\n    if (do_compute_cmdrow)\n\tcompute_cmdrow();\n    redrawcmd();\n    cursorcmd();\n}\n\n    static void\nredrawcmdprompt(void)\n{\n    int\t\ti;\n\n    if (cmd_silent)\n\treturn;\n    if (ccline.cmdfirstc != NUL)\n\tmsg_putchar(ccline.cmdfirstc);\n    if (ccline.cmdprompt != NULL)\n    {\n\tmsg_puts_attr((char *)ccline.cmdprompt, ccline.cmdattr);\n\tccline.cmdindent = msg_col + (msg_row - cmdline_row) * Columns;\n\t// do the reverse of set_cmdspos()\n\tif (ccline.cmdfirstc != NUL)\n\t    --ccline.cmdindent;\n    }\n    else\n\tfor (i = ccline.cmdindent; i > 0; --i)\n\t    msg_putchar(' ');\n}\n\n/*\n * Redraw what is currently on the command line.\n */\n    void\nredrawcmd(void)\n{\n    if (cmd_silent)\n\treturn;\n\n    // when 'incsearch' is set there may be no command line while redrawing\n    if (ccline.cmdbuff == NULL)\n    {\n\twindgoto(cmdline_row, 0);\n\tmsg_clr_eos();\n\treturn;\n    }\n\n    msg_start();\n    redrawcmdprompt();\n\n    // Don't use more prompt, truncate the cmdline if it doesn't fit.\n    msg_no_more = TRUE;\n    draw_cmdline(0, ccline.cmdlen);\n    msg_clr_eos();\n    msg_no_more = FALSE;\n\n    set_cmdspos_cursor();\n    if (extra_char != NUL)\n\tputcmdline(extra_char, extra_char_shift);\n\n    /*\n     * An emsg() before may have set msg_scroll. This is used in normal mode,\n     * in cmdline mode we can reset them now.\n     */\n    msg_scroll = FALSE;\t\t// next message overwrites cmdline\n\n    // Typing ':' at the more prompt may set skip_redraw.  We don't want this\n    // in cmdline mode\n    skip_redraw = FALSE;\n}\n\n    void\ncompute_cmdrow(void)\n{\n    if (exmode_active || msg_scrolled != 0)\n\tcmdline_row = Rows - 1;\n    else\n\tcmdline_row = W_WINROW(lastwin) + lastwin->w_height\n\t\t\t\t\t\t    + lastwin->w_status_height;\n}\n\n    void\ncursorcmd(void)\n{\n    if (cmd_silent)\n\treturn;\n\n#ifdef FEAT_RIGHTLEFT\n    if (cmdmsg_rl)\n    {\n\tmsg_row = cmdline_row  + (ccline.cmdspos / (int)(Columns - 1));\n\tmsg_col = (int)Columns - (ccline.cmdspos % (int)(Columns - 1)) - 1;\n\tif (msg_row <= 0)\n\t    msg_row = Rows - 1;\n    }\n    else\n#endif\n    {\n\tmsg_row = cmdline_row + (ccline.cmdspos / (int)Columns);\n\tmsg_col = ccline.cmdspos % (int)Columns;\n\tif (msg_row >= Rows)\n\t    msg_row = Rows - 1;\n    }\n\n    windgoto(msg_row, msg_col);\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n    if (p_imst == IM_ON_THE_SPOT)\n\tredrawcmd_preedit();\n#endif\n#ifdef MCH_CURSOR_SHAPE\n    mch_update_cursor();\n#endif\n}\n\n    void\ngotocmdline(int clr)\n{\n    msg_start();\n#ifdef FEAT_RIGHTLEFT\n    if (cmdmsg_rl)\n\tmsg_col = Columns - 1;\n    else\n#endif\n\tmsg_col = 0;\t    // always start in column 0\n    if (clr)\t\t    // clear the bottom line(s)\n\tmsg_clr_eos();\t    // will reset clear_cmdline\n    windgoto(cmdline_row, 0);\n}\n\n/*\n * Check the word in front of the cursor for an abbreviation.\n * Called when the non-id character \"c\" has been entered.\n * When an abbreviation is recognized it is removed from the text with\n * backspaces and the replacement string is inserted, followed by \"c\".\n */\n    static int\nccheck_abbr(int c)\n{\n    int spos = 0;\n\n    if (p_paste || no_abbr)\t    // no abbreviations or in paste mode\n\treturn FALSE;\n\n    // Do not consider '<,'> be part of the mapping, skip leading whitespace.\n    // Actually accepts any mark.\n    while (VIM_ISWHITE(ccline.cmdbuff[spos]) && spos < ccline.cmdlen)\n\tspos++;\n    if (ccline.cmdlen - spos > 5\n\t    && ccline.cmdbuff[spos] == '\\''\n\t    && ccline.cmdbuff[spos + 2] == ','\n\t    && ccline.cmdbuff[spos + 3] == '\\'')\n\tspos += 5;\n    else\n\t// check abbreviation from the beginning of the commandline\n\tspos = 0;\n\n    return check_abbr(c, ccline.cmdbuff, ccline.cmdpos, spos);\n}\n\n/*\n * Escape special characters in \"fname\", depending on \"what\":\n * VSE_NONE: for when used as a file name argument after a Vim command.\n * VSE_SHELL: for a shell command.\n * VSE_BUFFER: for the \":buffer\" command.\n * Returns the result in allocated memory.\n */\n    char_u *\nvim_strsave_fnameescape(char_u *fname, int what)\n{\n    char_u\t*p;\n#ifdef BACKSLASH_IN_FILENAME\n    char_u\tbuf[20];\n    int\t\tj = 0;\n\n    // Don't escape '[', '{' and '!' if they are in 'isfname' and for the\n    // \":buffer\" command.\n    for (p = what == VSE_BUFFER ? BUFFER_ESC_CHARS : PATH_ESC_CHARS;\n\t\t\t\t\t\t\t\t*p != NUL; ++p)\n\tif ((*p != '[' && *p != '{' && *p != '!') || !vim_isfilec(*p))\n\t    buf[j++] = *p;\n    buf[j] = NUL;\n    p = vim_strsave_escaped(fname, buf);\n#else\n    p = vim_strsave_escaped(fname, what == VSE_SHELL ? SHELL_ESC_CHARS\n\t\t    : what == VSE_BUFFER ? BUFFER_ESC_CHARS : PATH_ESC_CHARS);\n    if (what == VSE_SHELL && csh_like_shell() && p != NULL)\n    {\n\tchar_u\t    *s;\n\n\t// For csh and similar shells need to put two backslashes before '!'.\n\t// One is taken by Vim, one by the shell.\n\ts = vim_strsave_escaped(p, (char_u *)\"!\");\n\tvim_free(p);\n\tp = s;\n    }\n#endif\n\n    // '>' and '+' are special at the start of some commands, e.g. \":edit\" and\n    // \":write\".  \"cd -\" has a special meaning.\n    if (p != NULL && (*p == '>' || *p == '+' || (*p == '-' && p[1] == NUL)))\n\tescape_fname(&p);\n\n    return p;\n}\n\n/*\n * Put a backslash before the file name in \"pp\", which is in allocated memory.\n */\n    void\nescape_fname(char_u **pp)\n{\n    char_u\t*p;\n\n    p = alloc(STRLEN(*pp) + 2);\n    if (p != NULL)\n    {\n\tp[0] = '\\\\';\n\tSTRCPY(p + 1, *pp);\n\tvim_free(*pp);\n\t*pp = p;\n    }\n}\n\n/*\n * For each file name in files[num_files]:\n * If 'orig_pat' starts with \"~/\", replace the home directory with \"~\".\n */\n    void\ntilde_replace(\n    char_u  *orig_pat,\n    int\t    num_files,\n    char_u  **files)\n{\n    int\t    i;\n    char_u  *p;\n\n    if (orig_pat[0] == '~' && vim_ispathsep(orig_pat[1]))\n    {\n\tfor (i = 0; i < num_files; ++i)\n\t{\n\t    p = home_replace_save(NULL, files[i]);\n\t    if (p != NULL)\n\t    {\n\t\tvim_free(files[i]);\n\t\tfiles[i] = p;\n\t    }\n\t}\n    }\n}\n\n/*\n * Get a pointer to the current command line info.\n */\n    cmdline_info_T *\nget_cmdline_info(void)\n{\n    return &ccline;\n}\n\n#if defined(FEAT_EVAL) || defined(FEAT_CMDWIN) || defined(PROTO)\n/*\n * Get pointer to the command line info to use. save_ccline() may clear\n * ccline and put the previous value in prev_ccline.\n */\n    static cmdline_info_T *\nget_ccline_ptr(void)\n{\n    if ((State & MODE_CMDLINE) == 0)\n\treturn NULL;\n    if (ccline.cmdbuff != NULL)\n\treturn &ccline;\n    if (prev_ccline_used && prev_ccline.cmdbuff != NULL)\n\treturn &prev_ccline;\n    return NULL;\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Get the current command line in allocated memory.\n * Only works when the command line is being edited.\n * Returns NULL when something is wrong.\n */\n    static char_u *\nget_cmdline_str(void)\n{\n    cmdline_info_T *p;\n\n    if (cmdline_star > 0)\n\treturn NULL;\n    p = get_ccline_ptr();\n    if (p == NULL)\n\treturn NULL;\n    return vim_strnsave(p->cmdbuff, p->cmdlen);\n}\n\n/*\n * Get the current command-line completion type.\n */\n    static char_u *\nget_cmdline_completion(void)\n{\n    cmdline_info_T *p;\n\n    if (cmdline_star > 0)\n\treturn NULL;\n\n    p = get_ccline_ptr();\n    if (p != NULL && p->xpc != NULL)\n    {\n\tchar_u *cmd_compl;\n\n\tset_expand_context(p->xpc);\n\n\tcmd_compl = cmdcomplete_type_to_str(p->xpc->xp_context);\n\tif (cmd_compl != NULL)\n\t    return vim_strsave(cmd_compl);\n    }\n\n    return NULL;\n}\n\n/*\n * \"getcmdcompltype()\" function\n */\n    void\nf_getcmdcompltype(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = get_cmdline_completion();\n}\n\n/*\n * \"getcmdline()\" function\n */\n    void\nf_getcmdline(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = get_cmdline_str();\n}\n\n/*\n * \"getcmdpos()\" function\n */\n    void\nf_getcmdpos(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    cmdline_info_T *p = get_ccline_ptr();\n\n    rettv->vval.v_number = 0;\n    if (p != NULL)\n    rettv->vval.v_number = p->cmdpos + 1;\n}\n\n/*\n * Get the command line cursor screen position.\n */\n    static int\nget_cmdline_screen_pos(void)\n{\n    cmdline_info_T *p = get_ccline_ptr();\n\n    if (p == NULL)\n\treturn -1;\n    return p->cmdspos;\n}\n\n/*\n * \"getcmdscreenpos()\" function\n */\n    void\nf_getcmdscreenpos(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->vval.v_number = get_cmdline_screen_pos() + 1;\n}\n\n/*\n * Set the command line byte position to \"pos\".  Zero is the first position.\n * Only works when the command line is being edited.\n * Returns 1 when failed, 0 when OK.\n */\n    static int\nset_cmdline_pos(\n    int\t\tpos)\n{\n    cmdline_info_T *p = get_ccline_ptr();\n\n    if (p == NULL)\n\treturn 1;\n\n    // The position is not set directly but after CTRL-\\ e or CTRL-R = has\n    // changed the command line.\n    if (pos < 0)\n\tnew_cmdpos = 0;\n    else\n\tnew_cmdpos = pos;\n    return 0;\n}\n\n/*\n * \"setcmdpos()\" function\n */\n    void\nf_setcmdpos(typval_T *argvars, typval_T *rettv)\n{\n    int\t\tpos;\n\n    if (in_vim9script() && check_for_number_arg(argvars, 0) == FAIL)\n\treturn;\n\n    pos = (int)tv_get_number(&argvars[0]) - 1;\n    if (pos >= 0)\n\trettv->vval.v_number = set_cmdline_pos(pos);\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(FEAT_CMDWIN)\n/*\n * Get the current command-line type.\n * Returns ':' or '/' or '?' or '@' or '>' or '-'\n * Only works when the command line is being edited.\n * Returns NUL when something is wrong.\n */\n    static int\nget_cmdline_type(void)\n{\n    cmdline_info_T *p = get_ccline_ptr();\n\n    if (p == NULL)\n\treturn NUL;\n    if (p->cmdfirstc == NUL)\n\treturn\n# ifdef FEAT_EVAL\n\t    (p->input_fn) ? '@' :\n# endif\n\t    '-';\n    return p->cmdfirstc;\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * \"getcmdtype()\" function\n */\n    void\nf_getcmdtype(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = alloc(2);\n    if (rettv->vval.v_string != NULL)\n    {\n\trettv->vval.v_string[0] = get_cmdline_type();\n\trettv->vval.v_string[1] = NUL;\n    }\n}\n\n#endif\n\n/*\n * Return the first character of the current command line.\n */\n    int\nget_cmdline_firstc(void)\n{\n    return ccline.cmdfirstc;\n}\n\n/*\n * Get indices \"num1,num2\" that specify a range within a list (not a range of\n * text lines in a buffer!) from a string.  Used for \":history\" and \":clist\".\n * Returns OK if parsed successfully, otherwise FAIL.\n */\n    int\nget_list_range(char_u **str, int *num1, int *num2)\n{\n    int\t\tlen;\n    int\t\tfirst = FALSE;\n    varnumber_T\tnum;\n\n    *str = skipwhite(*str);\n    if (**str == '-' || vim_isdigit(**str))  // parse \"from\" part of range\n    {\n\tvim_str2nr(*str, NULL, &len, 0, &num, NULL, 0, FALSE);\n\t*str += len;\n\t*num1 = (int)num;\n\tfirst = TRUE;\n    }\n    *str = skipwhite(*str);\n    if (**str == ',')\t\t\t// parse \"to\" part of range\n    {\n\t*str = skipwhite(*str + 1);\n\tvim_str2nr(*str, NULL, &len, 0, &num, NULL, 0, FALSE);\n\tif (len > 0)\n\t{\n\t    *num2 = (int)num;\n\t    *str = skipwhite(*str + len);\n\t}\n\telse if (!first)\t\t// no number given at all\n\t    return FAIL;\n    }\n    else if (first)\t\t\t// only one number given\n\t*num2 = *num1;\n    return OK;\n}\n\n#if defined(FEAT_CMDWIN) || defined(PROTO)\n/*\n * Check value of 'cedit' and set cedit_key.\n * Returns NULL if value is OK, error message otherwise.\n */\n    char *\ncheck_cedit(void)\n{\n    int n;\n\n    if (*p_cedit == NUL)\n\tcedit_key = -1;\n    else\n    {\n\tn = string_to_key(p_cedit, FALSE);\n\tif (vim_isprintc(n))\n\t    return e_invalid_argument;\n\tcedit_key = n;\n    }\n    return NULL;\n}\n\n/*\n * Open a window on the current command line and history.  Allow editing in\n * the window.  Returns when the window is closed.\n * Returns:\n *\tCR\t if the command is to be executed\n *\tCtrl_C\t if it is to be abandoned\n *\tK_IGNORE if editing continues\n */\n    static int\nopen_cmdwin(void)\n{\n    bufref_T\t\told_curbuf;\n    win_T\t\t*old_curwin = curwin;\n    bufref_T\t\tbufref;\n    win_T\t\t*wp;\n    int\t\t\ti;\n    linenr_T\t\tlnum;\n    int\t\t\thisttype;\n    garray_T\t\twinsizes;\n    int\t\t\tsave_restart_edit = restart_edit;\n    int\t\t\tsave_State = State;\n    int\t\t\tsave_exmode = exmode_active;\n#ifdef FEAT_RIGHTLEFT\n    int\t\t\tsave_cmdmsg_rl = cmdmsg_rl;\n#endif\n#ifdef FEAT_FOLDING\n    int\t\t\tsave_KeyTyped;\n#endif\n\n    // Can't do this when text or buffer is locked.\n    if (text_or_buf_locked())\n\treturn K_IGNORE;\n\n    // Can't do this recursively.  Can't do it when typing a password.\n    if (cmdwin_type != 0\n# if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\n\t    || cmdline_star > 0\n# endif\n\t    )\n    {\n\tbeep_flush();\n\treturn K_IGNORE;\n    }\n    set_bufref(&old_curbuf, curbuf);\n\n    // Save current window sizes.\n    win_size_save(&winsizes);\n\n    // When using completion in Insert mode with <C-R>=<C-F> one can open the\n    // command line window, but we don't want the popup menu then.\n    pum_undisplay();\n\n    // don't use a new tab page\n    cmdmod.cmod_tab = 0;\n    cmdmod.cmod_flags |= CMOD_NOSWAPFILE;\n\n    // Create a window for the command-line buffer.\n    if (win_split((int)p_cwh, WSP_BOT) == FAIL)\n    {\n\tbeep_flush();\n\tga_clear(&winsizes);\n\treturn K_IGNORE;\n    }\n    // Don't let quitting the More prompt make this fail.\n    got_int = FALSE;\n\n    // Set \"cmdwin_type\" before any autocommands may mess things up.\n    cmdwin_type = get_cmdline_type();\n\n    // Create the command-line buffer empty.\n    if (do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE, NULL) == FAIL)\n    {\n\t// Some autocommand messed it up?\n\twin_close(curwin, TRUE);\n\tga_clear(&winsizes);\n\tcmdwin_type = 0;\n\treturn Ctrl_C;\n    }\n\n    apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);\n    (void)setfname(curbuf, (char_u *)_(\"[Command Line]\"), NULL, TRUE);\n    apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);\n    set_option_value_give_err((char_u *)\"bt\",\n\t\t\t\t\t    0L, (char_u *)\"nofile\", OPT_LOCAL);\n    curbuf->b_p_ma = TRUE;\n#ifdef FEAT_FOLDING\n    curwin->w_p_fen = FALSE;\n#endif\n# ifdef FEAT_RIGHTLEFT\n    curwin->w_p_rl = cmdmsg_rl;\n    cmdmsg_rl = FALSE;\n# endif\n    RESET_BINDING(curwin);\n\n    // Don't allow switching to another buffer.\n    ++curbuf_lock;\n\n    // Showing the prompt may have set need_wait_return, reset it.\n    need_wait_return = FALSE;\n\n    histtype = hist_char2type(cmdwin_type);\n    if (histtype == HIST_CMD || histtype == HIST_DEBUG)\n    {\n\tif (p_wc == TAB)\n\t{\n\t    add_map((char_u *)\"<buffer> <Tab> <C-X><C-V>\", MODE_INSERT);\n\t    add_map((char_u *)\"<buffer> <Tab> a<C-X><C-V>\", MODE_NORMAL);\n\t}\n\tset_option_value_give_err((char_u *)\"ft\",\n\t\t\t\t\t       0L, (char_u *)\"vim\", OPT_LOCAL);\n    }\n    --curbuf_lock;\n\n    // Reset 'textwidth' after setting 'filetype' (the Vim filetype plugin\n    // sets 'textwidth' to 78).\n    curbuf->b_p_tw = 0;\n\n    // Fill the buffer with the history.\n    init_history();\n    if (get_hislen() > 0)\n    {\n\ti = *get_hisidx(histtype);\n\tif (i >= 0)\n\t{\n\t    lnum = 0;\n\t    do\n\t    {\n\t\tif (++i == get_hislen())\n\t\t    i = 0;\n\t\tif (get_histentry(histtype)[i].hisstr != NULL)\n\t\t    ml_append(lnum++, get_histentry(histtype)[i].hisstr,\n\t\t\t\t\t\t\t   (colnr_T)0, FALSE);\n\t    }\n\t    while (i != *get_hisidx(histtype));\n\t}\n    }\n\n    // Replace the empty last line with the current command-line and put the\n    // cursor there.\n    ml_replace(curbuf->b_ml.ml_line_count, ccline.cmdbuff, TRUE);\n    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n    curwin->w_cursor.col = ccline.cmdpos;\n    changed_line_abv_curs();\n    invalidate_botline();\n    redraw_later(SOME_VALID);\n\n    // No Ex mode here!\n    exmode_active = 0;\n\n    State = MODE_NORMAL;\n    setmouse();\n\n    // Reset here so it can be set by a CmdWinEnter autocommand.\n    cmdwin_result = 0;\n\n    // Trigger CmdwinEnter autocommands.\n    trigger_cmd_autocmd(cmdwin_type, EVENT_CMDWINENTER);\n    if (restart_edit != 0)\t// autocmd with \":startinsert\"\n\tstuffcharReadbuff(K_NOP);\n\n    i = RedrawingDisabled;\n    RedrawingDisabled = 0;\n\n    /*\n     * Call the main loop until <CR> or CTRL-C is typed.\n     */\n    main_loop(TRUE, FALSE);\n\n    RedrawingDisabled = i;\n\n# ifdef FEAT_FOLDING\n    save_KeyTyped = KeyTyped;\n# endif\n\n    // Trigger CmdwinLeave autocommands.\n    trigger_cmd_autocmd(cmdwin_type, EVENT_CMDWINLEAVE);\n\n# ifdef FEAT_FOLDING\n    // Restore KeyTyped in case it is modified by autocommands\n    KeyTyped = save_KeyTyped;\n# endif\n\n    cmdwin_type = 0;\n    exmode_active = save_exmode;\n\n    // Safety check: The old window or buffer was deleted: It's a bug when\n    // this happens!\n    if (!win_valid(old_curwin) || !bufref_valid(&old_curbuf))\n    {\n\tcmdwin_result = Ctrl_C;\n\temsg(_(e_active_window_or_buffer_deleted));\n    }\n    else\n    {\n# if defined(FEAT_EVAL)\n\t// autocmds may abort script processing\n\tif (aborting() && cmdwin_result != K_IGNORE)\n\t    cmdwin_result = Ctrl_C;\n# endif\n\t// Set the new command line from the cmdline buffer.\n\tvim_free(ccline.cmdbuff);\n\tif (cmdwin_result == K_XF1 || cmdwin_result == K_XF2) // :qa[!] typed\n\t{\n\t    char *p = (cmdwin_result == K_XF2) ? \"qa\" : \"qa!\";\n\n\t    if (histtype == HIST_CMD)\n\t    {\n\t\t// Execute the command directly.\n\t\tccline.cmdbuff = vim_strsave((char_u *)p);\n\t\tcmdwin_result = CAR;\n\t    }\n\t    else\n\t    {\n\t\t// First need to cancel what we were doing.\n\t\tccline.cmdbuff = NULL;\n\t\tstuffcharReadbuff(':');\n\t\tstuffReadbuff((char_u *)p);\n\t\tstuffcharReadbuff(CAR);\n\t    }\n\t}\n\telse if (cmdwin_result == K_XF2)\t// :qa typed\n\t{\n\t    ccline.cmdbuff = vim_strsave((char_u *)\"qa\");\n\t    cmdwin_result = CAR;\n\t}\n\telse if (cmdwin_result == Ctrl_C)\n\t{\n\t    // :q or :close, don't execute any command\n\t    // and don't modify the cmd window.\n\t    ccline.cmdbuff = NULL;\n\t}\n\telse\n\t    ccline.cmdbuff = vim_strsave(ml_get_curline());\n\tif (ccline.cmdbuff == NULL)\n\t{\n\t    ccline.cmdbuff = vim_strsave((char_u *)\"\");\n\t    ccline.cmdlen = 0;\n\t    ccline.cmdbufflen = 1;\n\t    ccline.cmdpos = 0;\n\t    cmdwin_result = Ctrl_C;\n\t}\n\telse\n\t{\n\t    ccline.cmdlen = (int)STRLEN(ccline.cmdbuff);\n\t    ccline.cmdbufflen = ccline.cmdlen + 1;\n\t    ccline.cmdpos = curwin->w_cursor.col;\n\t    if (ccline.cmdpos > ccline.cmdlen)\n\t\tccline.cmdpos = ccline.cmdlen;\n\t    if (cmdwin_result == K_IGNORE)\n\t    {\n\t\tset_cmdspos_cursor();\n\t\tredrawcmd();\n\t    }\n\t}\n\n# ifdef FEAT_CONCEAL\n\t// Avoid command-line window first character being concealed.\n\tcurwin->w_p_cole = 0;\n# endif\n\t// First go back to the original window.\n\twp = curwin;\n\tset_bufref(&bufref, curbuf);\n\twin_goto(old_curwin);\n\n\t// win_goto() may trigger an autocommand that already closes the\n\t// cmdline window.\n\tif (win_valid(wp) && wp != curwin)\n\t    win_close(wp, TRUE);\n\n\t// win_close() may have already wiped the buffer when 'bh' is\n\t// set to 'wipe', autocommands may have closed other windows\n\tif (bufref_valid(&bufref) && bufref.br_buf != curbuf)\n\t    close_buffer(NULL, bufref.br_buf, DOBUF_WIPE, FALSE, FALSE);\n\n\t// Restore window sizes.\n\twin_size_restore(&winsizes);\n    }\n\n    ga_clear(&winsizes);\n    restart_edit = save_restart_edit;\n# ifdef FEAT_RIGHTLEFT\n    cmdmsg_rl = save_cmdmsg_rl;\n# endif\n\n    State = save_State;\n    setmouse();\n\n    return cmdwin_result;\n}\n\n/*\n * Return TRUE if in the cmdwin, not editing the command line.\n */\n    int\nis_in_cmdwin(void)\n{\n    return cmdwin_type != 0 && get_cmdline_type() == NUL;\n}\n#endif // FEAT_CMDWIN\n\n/*\n * Used for commands that either take a simple command string argument, or:\n *\tcmd << endmarker\n *\t  {script}\n *\tendmarker\n * Returns a pointer to allocated memory with {script} or NULL.\n */\n    char_u *\nscript_get(exarg_T *eap UNUSED, char_u *cmd UNUSED)\n{\n#ifdef FEAT_EVAL\n    list_T\t*l;\n    listitem_T\t*li;\n    char_u\t*s;\n    garray_T\tga;\n\n    if (cmd[0] != '<' || cmd[1] != '<' || eap->getline == NULL)\n\treturn NULL;\n    cmd += 2;\n\n    l = heredoc_get(eap, cmd, TRUE, FALSE);\n    if (l == NULL)\n\treturn NULL;\n\n    ga_init2(&ga, 1, 0x400);\n\n    FOR_ALL_LIST_ITEMS(l, li)\n    {\n\ts = tv_get_string(&li->li_tv);\n\tga_concat(&ga, s);\n\tga_append(&ga, '\\n');\n    }\n    ga_append(&ga, NUL);\n\n    list_free(l);\n    return (char_u *)ga.ga_data;\n#else\n    return NULL;\n#endif\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * This function is used by f_input() and f_inputdialog() functions. The third\n * argument to f_input() specifies the type of completion to use at the\n * prompt. The third argument to f_inputdialog() specifies the value to return\n * when the user cancels the prompt.\n */\n    void\nget_user_input(\n    typval_T\t*argvars,\n    typval_T\t*rettv,\n    int\t\tinputdialog,\n    int\t\tsecret)\n{\n    char_u\t*prompt;\n    char_u\t*p = NULL;\n    int\t\tc;\n    char_u\tbuf[NUMBUFLEN];\n    int\t\tcmd_silent_save = cmd_silent;\n    char_u\t*defstr = (char_u *)\"\";\n    int\t\txp_type = EXPAND_NOTHING;\n    char_u\t*xp_arg = NULL;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n    if (input_busy)\n\treturn;  // this doesn't work recursively.\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_string_arg(argvars, 1) == FAIL\n\t\t|| (argvars[1].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_string_arg(argvars, 2) == FAIL)))\n\treturn;\n\n    prompt = tv_get_string_chk(&argvars[0]);\n\n#ifdef NO_CONSOLE_INPUT\n    // While starting up, there is no place to enter text. When running tests\n    // with --not-a-term we assume feedkeys() will be used.\n    if (no_console_input() && !is_not_a_term())\n\treturn;\n#endif\n\n    cmd_silent = FALSE;\t\t// Want to see the prompt.\n    if (prompt != NULL)\n    {\n\t// Only the part of the message after the last NL is considered as\n\t// prompt for the command line\n\tp = vim_strrchr(prompt, '\\n');\n\tif (p == NULL)\n\t    p = prompt;\n\telse\n\t{\n\t    ++p;\n\t    c = *p;\n\t    *p = NUL;\n\t    msg_start();\n\t    msg_clr_eos();\n\t    msg_puts_attr((char *)prompt, get_echo_attr());\n\t    msg_didout = FALSE;\n\t    msg_starthere();\n\t    *p = c;\n\t}\n\tcmdline_row = msg_row;\n\n\tif (argvars[1].v_type != VAR_UNKNOWN)\n\t{\n\t    defstr = tv_get_string_buf_chk(&argvars[1], buf);\n\t    if (defstr != NULL)\n\t\tstuffReadbuffSpec(defstr);\n\n\t    if (!inputdialog && argvars[2].v_type != VAR_UNKNOWN)\n\t    {\n\t\tchar_u\t*xp_name;\n\t\tint\txp_namelen;\n\t\tlong\targt = 0;\n\n\t\t// input() with a third argument: completion\n\t\trettv->vval.v_string = NULL;\n\n\t\txp_name = tv_get_string_buf_chk(&argvars[2], buf);\n\t\tif (xp_name == NULL)\n\t\t    return;\n\n\t\txp_namelen = (int)STRLEN(xp_name);\n\n\t\tif (parse_compl_arg(xp_name, xp_namelen, &xp_type, &argt,\n\t\t\t\t\t\t\t     &xp_arg) == FAIL)\n\t\t    return;\n\t    }\n\t}\n\n\tif (defstr != NULL)\n\t{\n\t    int save_ex_normal_busy = ex_normal_busy;\n\t    int save_vgetc_busy = vgetc_busy;\n\t    int save_input_busy = input_busy;\n\n\t    input_busy |= vgetc_busy;\n\t    ex_normal_busy = 0;\n\t    vgetc_busy = 0;\n\t    rettv->vval.v_string =\n\t\tgetcmdline_prompt(secret ? NUL : '@', p, get_echo_attr(),\n\t\t\t\t\t\t\t      xp_type, xp_arg);\n\t    ex_normal_busy = save_ex_normal_busy;\n\t    vgetc_busy = save_vgetc_busy;\n\t    input_busy = save_input_busy;\n\t}\n\tif (inputdialog && rettv->vval.v_string == NULL\n\t\t&& argvars[1].v_type != VAR_UNKNOWN\n\t\t&& argvars[2].v_type != VAR_UNKNOWN)\n\t    rettv->vval.v_string = vim_strsave(tv_get_string_buf(\n\t\t\t\t\t\t\t   &argvars[2], buf));\n\n\tvim_free(xp_arg);\n\n\t// since the user typed this, no need to wait for return\n\tneed_wait_return = FALSE;\n\tmsg_didout = FALSE;\n    }\n    cmd_silent = cmd_silent_save;\n}\n#endif\n", "/* ex_getln.c */\nvoid cmdline_init(void);\nchar_u *getcmdline(int firstc, long count, int indent, getline_opt_T do_concat);\nchar_u *getcmdline_prompt(int firstc, char_u *prompt, int attr, int xp_context, char_u *xp_arg);\nint check_opt_wim(void);\nint text_locked(void);\nvoid text_locked_msg(void);\nchar *get_text_locked_msg(void);\nint text_or_buf_locked(void);\nint curbuf_locked(void);\nint allbuf_locked(void);\nchar_u *getexline(int c, void *cookie, int indent, getline_opt_T options);\nchar_u *getexmodeline(int promptc, void *cookie, int indent, getline_opt_T options);\nint cmdline_overstrike(void);\nint cmdline_at_end(void);\ncolnr_T cmdline_getvcol_cursor(void);\nint realloc_cmdbuff(int len);\nvoid free_arshape_buf(void);\nvoid putcmdline(int c, int shift);\nvoid unputcmdline(void);\nint put_on_cmdline(char_u *str, int len, int redraw);\nvoid cmdline_paste_str(char_u *s, int literally);\nvoid redrawcmdline(void);\nvoid redrawcmdline_ex(int do_compute_cmdrow);\nvoid redrawcmd(void);\nvoid compute_cmdrow(void);\nvoid cursorcmd(void);\nvoid gotocmdline(int clr);\nchar_u *vim_strsave_fnameescape(char_u *fname, int what);\nvoid escape_fname(char_u **pp);\nvoid tilde_replace(char_u *orig_pat, int num_files, char_u **files);\ncmdline_info_T *get_cmdline_info(void);\nvoid f_getcmdcompltype(typval_T *argvars, typval_T *rettv);\nvoid f_getcmdline(typval_T *argvars, typval_T *rettv);\nvoid f_getcmdpos(typval_T *argvars, typval_T *rettv);\nvoid f_getcmdscreenpos(typval_T *argvars, typval_T *rettv);\nvoid f_setcmdpos(typval_T *argvars, typval_T *rettv);\nvoid f_getcmdtype(typval_T *argvars, typval_T *rettv);\nint get_cmdline_firstc(void);\nint get_list_range(char_u **str, int *num1, int *num2);\nchar *check_cedit(void);\nint is_in_cmdwin(void);\nchar_u *script_get(exarg_T *eap, char_u *cmd);\nvoid get_user_input(typval_T *argvars, typval_T *rettv, int inputdialog, int secret);\n/* vim: set ft=c : */\n", "\" Tests for the substitute (:s) command\n\nsource shared.vim\nsource check.vim\n\nfunc Test_multiline_subst()\n  enew!\n  call append(0, [\"1 aa\",\n\t      \\ \"bb\",\n\t      \\ \"cc\",\n\t      \\ \"2 dd\",\n\t      \\ \"ee\",\n\t      \\ \"3 ef\",\n\t      \\ \"gh\",\n\t      \\ \"4 ij\",\n\t      \\ \"5 a8\",\n\t      \\ \"8b c9\",\n\t      \\ \"9d\",\n\t      \\ \"6 e7\",\n\t      \\ \"77f\",\n\t      \\ \"xxxxx\"])\n\n  1\n  \" test if replacing a line break works with a back reference\n  /^1/,/^2/s/\\n\\(.\\)/ \\1/\n  \" test if inserting a line break works with a back reference\n  /^3/,/^4/s/\\(.\\)$/\\r\\1/\n  \" test if replacing a line break with another line break works\n  /^5/,/^6/s/\\(\\_d\\{3}\\)/x\\1x/\n  call assert_equal('1 aa bb cc 2 dd ee', getline(1))\n  call assert_equal('3 e', getline(2))\n  call assert_equal('f', getline(3))\n  call assert_equal('g', getline(4))\n  call assert_equal('h', getline(5))\n  call assert_equal('4 i', getline(6))\n  call assert_equal('j', getline(7))\n  call assert_equal('5 ax8', getline(8))\n  call assert_equal('8xb cx9', getline(9))\n  call assert_equal('9xd', getline(10))\n  call assert_equal('6 ex7', getline(11))\n  call assert_equal('7x7f', getline(12))\n  call assert_equal('xxxxx', getline(13))\n  enew!\nendfunc\n\nfunc Test_substitute_variants()\n  \" Validate that all the 2-/3-letter variants which embed the flags into the\n  \" command name actually work.\n  enew!\n  let ln = 'Testing string'\n  let variants = [\n\t\\ { 'cmd': ':s/Test/test/c', 'exp': 'testing string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/foo/bar/ce', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/cg', 'exp': 'Tesring srring', 'prompt': 'a' },\n\t\\ { 'cmd': ':s/t/r/ci', 'exp': 'resting string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/t/r/cI', 'exp': 'Tesring string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/t/r/c', 'exp': 'Testing string', 'prompt': 'n' },\n\t\\ { 'cmd': ':s/t/r/cn', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/cp', 'exp': 'Tesring string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/t/r/cl', 'exp': 'Tesring string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/t/r/gc', 'exp': 'Tesring srring', 'prompt': 'a' },\n\t\\ { 'cmd': ':s/i/I/gc', 'exp': 'TestIng string', 'prompt': 'l' },\n\t\\ { 'cmd': ':s/foo/bar/ge', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/g', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s/t/r/gi', 'exp': 'resring srring' },\n\t\\ { 'cmd': ':s/t/r/gI', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s/t/r/gn', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/gp', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s/t/r/gl', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s//r/gr', 'exp': 'Testr strr' },\n\t\\ { 'cmd': ':s/t/r/ic', 'exp': 'resting string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/foo/bar/ie', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/i', 'exp': 'resting string' },\n\t\\ { 'cmd': ':s/t/r/iI', 'exp': 'Tesring string' },\n\t\\ { 'cmd': ':s/t/r/in', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/ip', 'exp': 'resting string' },\n\t\\ { 'cmd': ':s//r/ir', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s/t/r/Ic', 'exp': 'Tesring string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/foo/bar/Ie', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/Ig', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s/t/r/Ii', 'exp': 'resting string' },\n\t\\ { 'cmd': ':s/t/r/I', 'exp': 'Tesring string' },\n\t\\ { 'cmd': ':s/t/r/Ip', 'exp': 'Tesring string' },\n\t\\ { 'cmd': ':s/t/r/Il', 'exp': 'Tesring string' },\n\t\\ { 'cmd': ':s//r/Ir', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/rc', 'exp': 'Testr string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s//r/rg', 'exp': 'Testr strr' },\n\t\\ { 'cmd': ':s//r/ri', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/rI', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/rn', 'exp': 'Testing string' },\n\t\\ { 'cmd': ':s//r/rp', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/rl', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/r', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s/i/I/gc', 'exp': 'Testing string', 'prompt': 'q' },\n\t\\]\n\n  for var in variants\n    for run in [1, 2]\n      let cmd = var.cmd\n      if run == 2 && cmd =~ \"/.*/.*/.\"\n\t\" Change  :s/from/to/{flags}  to  :s{flags}\n\tlet cmd = substitute(cmd, '/.*/', '', '')\n      endif\n      call setline(1, [ln])\n      let msg = printf('using \"%s\"', cmd)\n      let @/='ing'\n      let v:errmsg = ''\n      call feedkeys(cmd . \"\\<CR>\" . get(var, 'prompt', ''), 'ntx')\n      \" No error should exist (matters for testing e flag)\n      call assert_equal('', v:errmsg, msg)\n      call assert_equal(var.exp, getline('.'), msg)\n    endfor\n  endfor\nendfunc\n\n\" Test the l, p, # flags.\nfunc Test_substitute_flags_lp()\n  new\n  call setline(1, \"abc\\tdef\\<C-h>ghi\")\n\n  let a = execute('s/a/a/p')\n  call assert_equal(\"\\nabc     def^Hghi\", a)\n\n  let a = execute('s/a/a/l')\n  call assert_equal(\"\\nabc^Idef^Hghi$\", a)\n\n  let a = execute('s/a/a/#')\n  call assert_equal(\"\\n  1 abc     def^Hghi\", a)\n\n  let a = execute('s/a/a/p#')\n  call assert_equal(\"\\n  1 abc     def^Hghi\", a)\n\n  let a = execute('s/a/a/l#')\n  call assert_equal(\"\\n  1 abc^Idef^Hghi$\", a)\n\n  let a = execute('s/a/a/')\n  call assert_equal(\"\", a)\n\n  bwipe!\nendfunc\n\nfunc Test_substitute_repeat()\n  \" This caused an invalid memory access.\n  split Xfile\n  s/^/x\n  call feedkeys(\"Qsc\\<CR>y\", 'tx')\n  bwipe!\nendfunc\n\n\" Test %s/\\n// which is implemented as a special case to use a\n\" more efficient join rather than doing a regular substitution.\nfunc Test_substitute_join()\n  new\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//')\n  call assert_equal(\"\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//g')\n  call assert_equal(\"\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//p')\n  call assert_equal(\"\\nfoo     barbar^Hfoo\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//l')\n  call assert_equal(\"\\nfoo^Ibarbar^Hfoo$\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//#')\n  call assert_equal(\"\\n  1 foo     barbar^Hfoo\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, ['foo', 'bar', 'baz', 'qux'])\n  call execute('1,2s/\\n//')\n  call assert_equal(['foobarbaz', 'qux'], getline(1, '$'))\n\n  bwipe!\nendfunc\n\nfunc Test_substitute_count()\n  new\n  call setline(1, ['foo foo', 'foo foo', 'foo foo', 'foo foo', 'foo foo'])\n  2\n\n  s/foo/bar/3\n  call assert_equal(['foo foo', 'bar foo', 'bar foo', 'bar foo', 'foo foo'],\n  \\                 getline(1, '$'))\n\n  call assert_fails('s/foo/bar/0', 'E939:')\n\n  call setline(1, ['foo foo', 'foo foo', 'foo foo', 'foo foo', 'foo foo'])\n  2,4s/foo/bar/ 10\n  call assert_equal(['foo foo', 'foo foo', 'foo foo', 'bar foo', 'bar foo'],\n        \\           getline(1, '$'))\n\n  bwipe!\nendfunc\n\n\" Test substitute 'n' flag (report number of matches, do not substitute).\nfunc Test_substitute_flag_n()\n  new\n  let lines = ['foo foo', 'foo foo', 'foo foo', 'foo foo', 'foo foo']\n  call setline(1, lines)\n\n  call assert_equal(\"\\n3 matches on 3 lines\", execute('2,4s/foo/bar/n'))\n  call assert_equal(\"\\n6 matches on 3 lines\", execute('2,4s/foo/bar/gn'))\n\n  \" c flag (confirm) should be ignored when using n flag.\n  call assert_equal(\"\\n3 matches on 3 lines\", execute('2,4s/foo/bar/nc'))\n\n  \" No substitution should have been done.\n  call assert_equal(lines, getline(1, '$'))\n\n  %delete _\n  call setline(1, ['A', 'Bar', 'Baz'])\n  call assert_equal(\"\\n1 match on 1 line\", execute('s/\\nB\\@=//gn'))\n\n  bwipe!\nendfunc\n\nfunc Test_substitute_errors()\n  new\n  call setline(1, 'foobar')\n\n  call assert_fails('s/FOO/bar/', 'E486:')\n  call assert_fails('s/foo/bar/@', 'E488:')\n  call assert_fails('s/\\(/bar/', 'E54:')\n  call assert_fails('s afooabara', 'E146:')\n  call assert_fails('s\\\\a', 'E10:')\n\n  setl nomodifiable\n  call assert_fails('s/foo/bar/', 'E21:')\n\n  call assert_fails(\"let s=substitute([], 'a', 'A', 'g')\", 'E730:')\n  call assert_fails(\"let s=substitute('abcda', [], 'A', 'g')\", 'E730:')\n  call assert_fails(\"let s=substitute('abcda', 'a', [], 'g')\", 'E730:')\n  call assert_fails(\"let s=substitute('abcda', 'a', 'A', [])\", 'E730:')\n  call assert_fails(\"let s=substitute('abc', '\\\\%(', 'A', 'g')\", 'E53:')\n\n  bwipe!\nendfunc\n\n\" Test for *sub-replace-special* and *sub-replace-expression* on substitute().\nfunc Test_sub_replace_1()\n  \" Run the tests with 'magic' on\n  set magic\n  set cpo&\n  call assert_equal('AA', substitute('A', 'A', '&&', ''))\n  call assert_equal('&', substitute('B', 'B', '\\&', ''))\n  call assert_equal('C123456789987654321', substitute('C123456789', 'C\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)', '\\0\\9\\8\\7\\6\\5\\4\\3\\2\\1', ''))\n  call assert_equal('d', substitute('D', 'D', 'd', ''))\n  call assert_equal('~', substitute('E', 'E', '~', ''))\n  call assert_equal('~', substitute('F', 'F', '\\~', ''))\n  call assert_equal('Gg', substitute('G', 'G', '\\ugg', ''))\n  call assert_equal('Hh', substitute('H', 'H', '\\Uh\\Eh', ''))\n  call assert_equal('iI', substitute('I', 'I', '\\lII', ''))\n  call assert_equal('jJ', substitute('J', 'J', '\\LJ\\EJ', ''))\n  call assert_equal('Kk', substitute('K', 'K', '\\Uk\\ek', ''))\n  call assert_equal(\"l\\<C-V>\\<C-M>l\",\n\t\t\t\\ substitute('lLl', 'L', \"\\<C-V>\\<C-M>\", ''))\n  call assert_equal(\"m\\<C-M>m\", substitute('mMm', 'M', '\\r', ''))\n  call assert_equal(\"n\\<C-V>\\<C-M>n\",\n\t\t\t\\ substitute('nNn', 'N', \"\\\\\\<C-V>\\<C-M>\", ''))\n  call assert_equal(\"o\\no\", substitute('oOo', 'O', '\\n', ''))\n  call assert_equal(\"p\\<C-H>p\", substitute('pPp', 'P', '\\b', ''))\n  call assert_equal(\"q\\tq\", substitute('qQq', 'Q', '\\t', ''))\n  call assert_equal('r\\r', substitute('rRr', 'R', '\\\\', ''))\n  call assert_equal('scs', substitute('sSs', 'S', '\\c', ''))\n  call assert_equal(\"u\\nu\", substitute('uUu', 'U', \"\\n\", ''))\n  call assert_equal(\"v\\<C-H>v\", substitute('vVv', 'V', \"\\b\", ''))\n  call assert_equal(\"w\\\\w\", substitute('wWw', 'W', \"\\\\\", ''))\n  call assert_equal(\"x\\<C-M>x\", substitute('xXx', 'X', \"\\r\", ''))\n  call assert_equal(\"YyyY\", substitute('Y', 'Y', '\\L\\uyYy\\l\\EY', ''))\n  call assert_equal(\"zZZz\", substitute('Z', 'Z', '\\U\\lZzZ\\u\\Ez', ''))\n  \" \\v or \\V after $\n  call assert_equal('abxx', substitute('abcd', 'xy$\\v|cd$', 'xx', ''))\n  call assert_equal('abxx', substitute('abcd', 'xy$\\V\\|cd\\$', 'xx', ''))\nendfunc\n\nfunc Test_sub_replace_2()\n  \" Run the tests with 'magic' off\n  set nomagic\n  set cpo&\n  call assert_equal('AA', substitute('A', 'A', '&&', ''))\n  call assert_equal('&', substitute('B', 'B', '\\&', ''))\n  call assert_equal('C123456789987654321', substitute('C123456789', 'C\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)', '\\0\\9\\8\\7\\6\\5\\4\\3\\2\\1', ''))\n  call assert_equal('d', substitute('D', 'D', 'd', ''))\n  call assert_equal('~', substitute('E', 'E', '~', ''))\n  call assert_equal('~', substitute('F', 'F', '\\~', ''))\n  call assert_equal('Gg', substitute('G', 'G', '\\ugg', ''))\n  call assert_equal('Hh', substitute('H', 'H', '\\Uh\\Eh', ''))\n  call assert_equal('iI', substitute('I', 'I', '\\lII', ''))\n  call assert_equal('jJ', substitute('J', 'J', '\\LJ\\EJ', ''))\n  call assert_equal('Kk', substitute('K', 'K', '\\Uk\\ek', ''))\n  call assert_equal(\"l\\<C-V>\\<C-M>l\",\n\t\t\t\\ substitute('lLl', 'L', \"\\<C-V>\\<C-M>\", ''))\n  call assert_equal(\"m\\<C-M>m\", substitute('mMm', 'M', '\\r', ''))\n  call assert_equal(\"n\\<C-V>\\<C-M>n\",\n\t\t\t\\ substitute('nNn', 'N', \"\\\\\\<C-V>\\<C-M>\", ''))\n  call assert_equal(\"o\\no\", substitute('oOo', 'O', '\\n', ''))\n  call assert_equal(\"p\\<C-H>p\", substitute('pPp', 'P', '\\b', ''))\n  call assert_equal(\"q\\tq\", substitute('qQq', 'Q', '\\t', ''))\n  call assert_equal('r\\r', substitute('rRr', 'R', '\\\\', ''))\n  call assert_equal('scs', substitute('sSs', 'S', '\\c', ''))\n  call assert_equal(\"t\\<C-M>t\", substitute('tTt', 'T', \"\\r\", ''))\n  call assert_equal(\"u\\nu\", substitute('uUu', 'U', \"\\n\", ''))\n  call assert_equal(\"v\\<C-H>v\", substitute('vVv', 'V', \"\\b\", ''))\n  call assert_equal('w\\w', substitute('wWw', 'W', \"\\\\\", ''))\n  call assert_equal('XxxX', substitute('X', 'X', '\\L\\uxXx\\l\\EX', ''))\n  call assert_equal('yYYy', substitute('Y', 'Y', '\\U\\lYyY\\u\\Ey', ''))\nendfunc\n\nfunc Test_sub_replace_3()\n  set magic&\n  set cpo&\n  call assert_equal('a\\a', substitute('aAa', 'A', '\\=\"\\\\\"', ''))\n  call assert_equal('b\\\\b', substitute('bBb', 'B', '\\=\"\\\\\\\\\"', ''))\n  call assert_equal(\"c\\rc\", substitute('cCc', 'C', \"\\\\=\\\"\\r\\\"\", ''))\n  call assert_equal(\"d\\\\\\rd\", substitute('dDd', 'D', \"\\\\=\\\"\\\\\\\\\\r\\\"\", ''))\n  call assert_equal(\"e\\\\\\\\\\re\", substitute('eEe', 'E', \"\\\\=\\\"\\\\\\\\\\\\\\\\\\r\\\"\", ''))\n  call assert_equal('f\\rf', substitute('fFf', 'F', '\\=\"\\\\r\"', ''))\n  call assert_equal('j\\nj', substitute('jJj', 'J', '\\=\"\\\\n\"', ''))\n  call assert_equal(\"k\\<C-M>k\", substitute('kKk', 'K', '\\=\"\\r\"', ''))\n  call assert_equal(\"l\\nl\", substitute('lLl', 'L', '\\=\"\\n\"', ''))\nendfunc\n\n\" Test for submatch() on substitute().\nfunc Test_sub_replace_4()\n  set magic&\n  set cpo&\n  call assert_equal('a\\a', substitute('aAa', 'A',\n\t\t\\ '\\=substitute(submatch(0), \".\", \"\\\\\", \"\")', ''))\n  call assert_equal('b\\b', substitute('bBb', 'B',\n\t\t\\ '\\=substitute(submatch(0), \".\", \"\\\\\\\\\", \"\")', ''))\n  call assert_equal(\"c\\<C-V>\\<C-M>c\", substitute('cCc', 'C', '\\=substitute(submatch(0), \".\", \"\\<C-V>\\<C-M>\", \"\")', ''))\n  call assert_equal(\"d\\<C-V>\\<C-M>d\", substitute('dDd', 'D', '\\=substitute(submatch(0), \".\", \"\\\\\\<C-V>\\<C-M>\", \"\")', ''))\n  call assert_equal(\"e\\\\\\<C-V>\\<C-M>e\", substitute('eEe', 'E', '\\=substitute(submatch(0), \".\", \"\\\\\\\\\\<C-V>\\<C-M>\", \"\")', ''))\n  call assert_equal(\"f\\<C-M>f\", substitute('fFf', 'F', '\\=substitute(submatch(0), \".\", \"\\\\r\", \"\")', ''))\n  call assert_equal(\"j\\nj\", substitute('jJj', 'J', '\\=substitute(submatch(0), \".\", \"\\\\n\", \"\")', ''))\n  call assert_equal(\"k\\rk\", substitute('kKk', 'K', '\\=substitute(submatch(0), \".\", \"\\r\", \"\")', ''))\n  call assert_equal(\"l\\nl\", substitute('lLl', 'L', '\\=substitute(submatch(0), \".\", \"\\n\", \"\")', ''))\nendfunc\n\nfunc Test_sub_replace_5()\n  set magic&\n  set cpo&\n  call assert_equal('A123456789987654321', substitute('A123456789',\n\t\t\\ 'A\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)',\n\t\t\\ '\\=submatch(0) . submatch(9) . submatch(8) . ' .\n\t\t\\ 'submatch(7) . submatch(6) . submatch(5) . ' .\n\t\t\\ 'submatch(4) . submatch(3) . submatch(2) . submatch(1)',\n\t\t\\ ''))\n   call assert_equal(\"[['A123456789'], ['9'], ['8'], ['7'], ['6'], \" .\n\t\t\\ \"['5'], ['4'], ['3'], ['2'], ['1']]\",\n\t\t\\ substitute('A123456789',\n\t\t\\ 'A\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)',\n\t\t\\ '\\=string([submatch(0, 1), submatch(9, 1), ' .\n\t\t\\ 'submatch(8, 1), 7->submatch(1), submatch(6, 1), ' .\n\t\t\\ 'submatch(5, 1), submatch(4, 1), submatch(3, 1), ' .\n\t\t\\ 'submatch(2, 1), submatch(1, 1)])',\n\t\t\\ ''))\nendfunc\n\nfunc Test_sub_replace_6()\n  set magic&\n  set cpo+=/\n  call assert_equal('a', substitute('A', 'A', 'a', ''))\n  call assert_equal('%', substitute('B', 'B', '%', ''))\n  set cpo-=/\n  call assert_equal('c', substitute('C', 'C', 'c', ''))\n  call assert_equal('%', substitute('D', 'D', '%', ''))\nendfunc\n\nfunc Test_sub_replace_7()\n  set magic&\n  set cpo&\n  call assert_equal('A\u0016A', substitute('A\u0016A', 'A.', '\\=submatch(0)', ''))\n  call assert_equal(\"B\\nB\", substitute(\"B\\nB\", 'B.', '\\=submatch(0)', ''))\n  call assert_equal(\"['B\\n']B\", substitute(\"B\\nB\", 'B.', '\\=string(submatch(0, 1))', ''))\n  call assert_equal('-abab', substitute('-bb', '\\zeb', 'a', 'g'))\n  call assert_equal('c-cbcbc', substitute('-bb', '\\ze', 'c', 'g'))\nendfunc\n\n\" Test for *:s%* on :substitute.\nfunc Test_sub_replace_8()\n  new\n  set magic&\n  set cpo&\n  $put =',,X'\n  s/\\(^\\|,\\)\\ze\\(,\\|X\\)/\\1N/g\n  call assert_equal('N,,NX', getline(\"$\"))\n  $put =',,Y'\n  let cmd = ':s/\\(^\\|,\\)\\ze\\(,\\|Y\\)/\\1N/gc'\n  call feedkeys(cmd . \"\\<CR>a\", \"xt\")\n  call assert_equal('N,,NY', getline(\"$\"))\n  :$put =',,Z'\n  let cmd = ':s/\\(^\\|,\\)\\ze\\(,\\|Z\\)/\\1N/gc'\n  call feedkeys(cmd . \"\\<CR>yy\", \"xt\")\n  call assert_equal('N,,NZ', getline(\"$\"))\n  enew! | close\nendfunc\n\nfunc Test_sub_replace_9()\n  new\n  set magic&\n  set cpo&\n  $put ='xxx'\n  call feedkeys(\":s/x/X/gc\\<CR>yyq\", \"xt\")\n  call assert_equal('XXx', getline(\"$\"))\n  enew! | close\nendfunc\n\nfunc Test_sub_replace_10()\n   set magic&\n   set cpo&\n   call assert_equal('a1a2a3a', substitute('123', '\\zs', 'a', 'g'))\n   call assert_equal('aaa', substitute('123', '\\zs.', 'a', 'g'))\n   call assert_equal('1a2a3a', substitute('123', '.\\zs', 'a', 'g'))\n   call assert_equal('a1a2a3a', substitute('123', '\\ze', 'a', 'g'))\n   call assert_equal('a1a2a3', substitute('123', '\\ze.', 'a', 'g'))\n   call assert_equal('aaa', substitute('123', '.\\ze', 'a', 'g'))\n   call assert_equal('aa2a3a', substitute('123', '1\\|\\ze', 'a', 'g'))\n   call assert_equal('1aaa', substitute('123', '1\\zs\\|[23]', 'a', 'g'))\nendfunc\n\nfunc SubReplacer(text, submatches)\n  return a:text .. a:submatches[0] .. a:text\nendfunc\nfunc SubReplacer20(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, submatches)\n  return a:t3 .. a:submatches[0] .. a:t11\nendfunc\n\nfunc Test_substitute_partial()\n   call assert_equal('1foo2foo3', substitute('123', '2', function('SubReplacer', ['foo']), 'g'))\n\n   \" 19 arguments plus one is just OK\n   let Replacer = function('SubReplacer20', repeat(['foo'], 19))\n   call assert_equal('1foo2foo3', substitute('123', '2', Replacer, 'g'))\n\n   \" 20 arguments plus one is too many\n   let Replacer = function('SubReplacer20', repeat(['foo'], 20))\n   call assert_fails(\"call substitute('123', '2', Replacer, 'g')\", 'E118:')\nendfunc\n\nfunc Test_substitute_float()\n  CheckFeature float\n\n  call assert_equal('number 1.23', substitute('number ', '$', { -> 1.23 }, ''))\n  vim9 assert_equal('number 1.23', substitute('number ', '$', () => 1.23, ''))\nendfunc\n\n\" Tests for *sub-replace-special* and *sub-replace-expression* on :substitute.\n\n\" Execute a list of :substitute command tests\nfunc Run_SubCmd_Tests(tests)\n  enew!\n  for t in a:tests\n    let start = line('.') + 1\n    let end = start + len(t[2]) - 1\n    \" TODO: why is there a one second delay the first time we get here?\n    exe \"normal o\" . t[0]\n    call cursor(start, 1)\n    exe t[1]\n    call assert_equal(t[2], getline(start, end), t[1])\n  endfor\n  enew!\nendfunc\n\nfunc Test_sub_cmd_1()\n  set magic\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [['A', 's/A/&&/', ['AA']],\n\t      \\ ['B', 's/B/\\&/', ['&']],\n\t      \\ ['C123456789', 's/C\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)/\\0\\9\\8\\7\\6\\5\\4\\3\\2\\1/', ['C123456789987654321']],\n\t      \\ ['D', 's/D/d/', ['d']],\n\t      \\ ['E', 's/E/~/', ['d']],\n\t      \\ ['F', 's/F/\\~/', ['~']],\n\t      \\ ['G', 's/G/\\ugg/', ['Gg']],\n\t      \\ ['H', 's/H/\\Uh\\Eh/', ['Hh']],\n\t      \\ ['I', 's/I/\\lII/', ['iI']],\n\t      \\ ['J', 's/J/\\LJ\\EJ/', ['jJ']],\n\t      \\ ['K', 's/K/\\Uk\\ek/', ['Kk']],\n\t      \\ ['lLl', \"s/L/\\<C-V>\\<C-M>/\", [\"l\\<C-V>\", 'l']],\n\t      \\ ['mMm', 's/M/\\r/', ['m', 'm']],\n\t      \\ ['nNn', \"s/N/\\\\\\<C-V>\\<C-M>/\", [\"n\\<C-V>\", 'n']],\n\t      \\ ['oOo', 's/O/\\n/', [\"o\\no\"]],\n\t      \\ ['pPp', 's/P/\\b/', [\"p\\<C-H>p\"]],\n\t      \\ ['qQq', 's/Q/\\t/', [\"q\\tq\"]],\n\t      \\ ['rRr', 's/R/\\\\/', ['r\\r']],\n\t      \\ ['sSs', 's/S/\\c/', ['scs']],\n\t      \\ ['tTt', \"s/T/\\<C-V>\\<C-J>/\", [\"t\\<C-V>\\<C-J>t\"]],\n\t      \\ ['U', 's/U/\\L\\uuUu\\l\\EU/', ['UuuU']],\n\t      \\ ['V', 's/V/\\U\\lVvV\\u\\Ev/', ['vVVv']]\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\nfunc Test_sub_cmd_2()\n  set nomagic\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [['A', 's/A/&&/', ['&&']],\n\t      \\ ['B', 's/B/\\&/', ['B']],\n\t      \\ ['C123456789', 's/\\mC\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)/\\0\\9\\8\\7\\6\\5\\4\\3\\2\\1/', ['C123456789987654321']],\n\t      \\ ['D', 's/D/d/', ['d']],\n\t      \\ ['E', 's/E/~/', ['~']],\n\t      \\ ['F', 's/F/\\~/', ['~']],\n\t      \\ ['G', 's/G/\\ugg/', ['Gg']],\n\t      \\ ['H', 's/H/\\Uh\\Eh/', ['Hh']],\n\t      \\ ['I', 's/I/\\lII/', ['iI']],\n\t      \\ ['J', 's/J/\\LJ\\EJ/', ['jJ']],\n\t      \\ ['K', 's/K/\\Uk\\ek/', ['Kk']],\n\t      \\ ['lLl', \"s/L/\\<C-V>\\<C-M>/\", [\"l\\<C-V>\", 'l']],\n\t      \\ ['mMm', 's/M/\\r/', ['m', 'm']],\n\t      \\ ['nNn', \"s/N/\\\\\\<C-V>\\<C-M>/\", [\"n\\<C-V>\", 'n']],\n\t      \\ ['oOo', 's/O/\\n/', [\"o\\no\"]],\n\t      \\ ['pPp', 's/P/\\b/', [\"p\\<C-H>p\"]],\n\t      \\ ['qQq', 's/Q/\\t/', [\"q\\tq\"]],\n\t      \\ ['rRr', 's/R/\\\\/', ['r\\r']],\n\t      \\ ['sSs', 's/S/\\c/', ['scs']],\n\t      \\ ['tTt', \"s/T/\\<C-V>\\<C-J>/\", [\"t\\<C-V>\\<C-J>t\"]],\n\t      \\ ['U', 's/U/\\L\\uuUu\\l\\EU/', ['UuuU']],\n\t      \\ ['V', 's/V/\\U\\lVvV\\u\\Ev/', ['vVVv']]\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\nfunc Test_sub_cmd_3()\n  set nomagic\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [['aAa', \"s/A/\\\\='\\\\'/\", ['a\\a']],\n\t      \\ ['bBb', \"s/B/\\\\='\\\\\\\\'/\", ['b\\\\b']],\n\t      \\ ['cCc', \"s/C/\\\\='\\<C-V>\\<C-M>'/\", [\"c\\<C-V>\", 'c']],\n\t      \\ ['dDd', \"s/D/\\\\='\\\\\\<C-V>\\<C-M>'/\", [\"d\\\\\\<C-V>\", 'd']],\n\t      \\ ['eEe', \"s/E/\\\\='\\\\\\\\\\<C-V>\\<C-M>'/\", [\"e\\\\\\\\\\<C-V>\", 'e']],\n\t      \\ ['fFf', \"s/F/\\\\='\\r'/\", ['f', 'f']],\n\t      \\ ['gGg', \"s/G/\\\\='\\<C-V>\\<C-J>'/\", [\"g\\<C-V>\", 'g']],\n\t      \\ ['hHh', \"s/H/\\\\='\\\\\\<C-V>\\<C-J>'/\", [\"h\\\\\\<C-V>\", 'h']],\n\t      \\ ['iIi', \"s/I/\\\\='\\\\\\\\\\<C-V>\\<C-J>'/\", [\"i\\\\\\\\\\<C-V>\", 'i']],\n\t      \\ ['jJj', \"s/J/\\\\='\\n'/\", ['j', 'j']],\n\t      \\ ['kKk', 's/K/\\=\"\\r\"/', ['k', 'k']],\n\t      \\ ['lLl', 's/L/\\=\"\\n\"/', ['l', 'l']]\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\n\" Test for submatch() on :substitute.\nfunc Test_sub_cmd_4()\n  set magic&\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [ ['aAa', \"s/A/\\\\=substitute(submatch(0), '.', '\\\\', '')/\",\n\t      \\\t\t\t\t['a\\a']],\n\t      \\ ['bBb', \"s/B/\\\\=substitute(submatch(0), '.', '\\\\', '')/\",\n\t      \\\t\t\t\t['b\\b']],\n\t      \\ ['cCc', \"s/C/\\\\=substitute(submatch(0), '.', '\\<C-V>\\<C-M>', '')/\",\n\t      \\\t\t\t\t[\"c\\<C-V>\", 'c']],\n\t      \\ ['dDd', \"s/D/\\\\=substitute(submatch(0), '.', '\\\\\\<C-V>\\<C-M>', '')/\",\n\t      \\\t\t\t\t[\"d\\<C-V>\", 'd']],\n\t      \\ ['eEe', \"s/E/\\\\=substitute(submatch(0), '.', '\\\\\\\\\\<C-V>\\<C-M>', '')/\",\n\t      \\\t\t\t\t[\"e\\\\\\<C-V>\", 'e']],\n\t      \\ ['fFf', \"s/F/\\\\=substitute(submatch(0), '.', '\\\\r', '')/\",\n\t      \\\t\t\t\t['f', 'f']],\n\t      \\ ['gGg', 's/G/\\=substitute(submatch(0), \".\", \"\\<C-V>\\<C-J>\", \"\")/',\n\t      \\\t\t\t\t[\"g\\<C-V>\", 'g']],\n\t      \\ ['hHh', 's/H/\\=substitute(submatch(0), \".\", \"\\\\\\<C-V>\\<C-J>\", \"\")/',\n\t      \\\t\t\t\t[\"h\\<C-V>\", 'h']],\n\t      \\ ['iIi', 's/I/\\=substitute(submatch(0), \".\", \"\\\\\\\\\\<C-V>\\<C-J>\", \"\")/',\n\t      \\\t\t\t\t[\"i\\\\\\<C-V>\", 'i']],\n\t      \\ ['jJj', \"s/J/\\\\=substitute(submatch(0), '.', '\\\\n', '')/\",\n\t      \\\t\t\t\t['j', 'j']],\n\t      \\ ['kKk', \"s/K/\\\\=substitute(submatch(0), '.', '\\\\r', '')/\",\n\t      \\\t\t\t\t['k', 'k']],\n\t      \\ ['lLl', \"s/L/\\\\=substitute(submatch(0), '.', '\\\\n', '')/\",\n\t      \\\t\t\t\t['l', 'l']],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\nfunc Test_sub_cmd_5()\n  set magic&\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [ ['A123456789', 's/A\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)/\\=submatch(0) . submatch(9) . submatch(8) . submatch(7) . submatch(6) . submatch(5) . submatch(4) . submatch(3) . submatch(2) . submatch(1)/', ['A123456789987654321']],\n\t      \\ ['B123456789', 's/B\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)/\\=string([submatch(0, 1), submatch(9, 1), submatch(8, 1), submatch(7, 1), submatch(6, 1), submatch(5, 1), submatch(4, 1), submatch(3, 1), submatch(2, 1), submatch(1, 1)])/', [\"[['B123456789'], ['9'], ['8'], ['7'], ['6'], ['5'], ['4'], ['3'], ['2'], ['1']]\"]],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\n\" Test for *:s%* on :substitute.\nfunc Test_sub_cmd_6()\n  set magic&\n  set cpo+=/\n\n  \" List entry format: [input, cmd, output]\n  let tests = [ ['A', 's/A/a/', ['a']],\n\t      \\ ['B', 's/B/%/', ['a']],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\n\n  set cpo-=/\n  let tests = [ ['C', 's/C/c/', ['c']],\n\t      \\ ['D', 's/D/%/', ['%']],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\n\n  set cpo&\nendfunc\n\n\" Test for :s replacing \\n with  line break.\nfunc Test_sub_cmd_7()\n  set magic&\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [ [\"A\\<C-V>\\<C-M>A\", 's/A./\\=submatch(0)/', ['A', 'A']],\n\t      \\ [\"B\\<C-V>\\<C-J>B\", 's/B./\\=submatch(0)/', ['B', 'B']],\n\t      \\ [\"C\\<C-V>\\<C-J>C\", 's/C./\\=strtrans(string(submatch(0, 1)))/', [strtrans(\"['C\\<C-J>']C\")]],\n\t      \\ [\"D\\<C-V>\\<C-J>\\nD\", 's/D.\\nD/\\=strtrans(string(submatch(0, 1)))/', [strtrans(\"['D\\<C-J>', 'D']\")]],\n\t      \\ [\"E\\<C-V>\\<C-J>\\n\\<C-V>\\<C-J>\\n\\<C-V>\\<C-J>\\n\\<C-V>\\<C-J>\\n\\<C-V>\\<C-J>E\", 's/E\\_.\\{-}E/\\=strtrans(string(submatch(0, 1)))/', [strtrans(\"['E\\<C-J>', '\\<C-J>', '\\<C-J>', '\\<C-J>', '\\<C-J>E']\")]],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\n\n  exe \"normal oQ\\nQ\\<Esc>k\"\n  call assert_fails('s/Q[^\\n]Q/\\=submatch(0).\"foobar\"/', 'E486:')\n  enew!\nendfunc\n\nfunc TitleString()\n  let check = 'foo' =~ 'bar'\n  return \"\"\nendfunc\n\nfunc Test_sub_cmd_8()\n  set titlestring=%{TitleString()}\n\n  enew!\n  call append(0, ['', 'test_one', 'test_two'])\n  call cursor(1,1)\n  /^test_one/s/.*/\\=\"foo\\nbar\"/\n  call assert_equal('foo', getline(2))\n  call assert_equal('bar', getline(3))\n  call feedkeys(':/^test_two/s/.*/\\=\"foo\\nbar\"/c', \"t\")\n  call feedkeys(\"\\<CR>y\", \"xt\")\n  call assert_equal('foo', getline(4))\n  call assert_equal('bar', getline(5))\n\n  enew!\n  set titlestring&\nendfunc\n\nfunc Test_sub_cmd_9()\n  new\n  let input = ['1 aaa', '2 aaa', '3 aaa']\n  call setline(1, input)\n  func Foo()\n    return submatch(0)\n  endfunc\n  %s/aaa/\\=Foo()/gn\n  call assert_equal(input, getline(1, '$'))\n  call assert_equal(1, &modifiable)\n\n  delfunc Foo\n  bw!\nendfunc\n\nfunc Test_nocatch_sub_failure_handling()\n  \" normal error results in all replacements \n  func Foo()\n    foobar\n  endfunc\n  new\n  call setline(1, ['1 aaa', '2 aaa', '3 aaa'])\n  %s/aaa/\\=Foo()/g\n  call assert_equal(['1 0', '2 0', '3 0'], getline(1, 3))\n\n  \" Trow without try-catch causes abort after the first line.\n  \" We cannot test this, since it would stop executing the test script.\n\n  \" try/catch does not result in any changes\n  func! Foo()\n    throw 'error'\n  endfunc\n  call setline(1, ['1 aaa', '2 aaa', '3 aaa'])\n  let error_caught = 0\n  try\n    %s/aaa/\\=Foo()/g\n  catch\n    let error_caught = 1\n  endtry\n  call assert_equal(1, error_caught)\n  call assert_equal(['1 aaa', '2 aaa', '3 aaa'], getline(1, 3))\n\n  \" Same, but using \"n\" flag so that \"sandbox\" gets set\n  call setline(1, ['1 aaa', '2 aaa', '3 aaa'])\n  let error_caught = 0\n  try\n    %s/aaa/\\=Foo()/gn\n  catch\n    let error_caught = 1\n  endtry\n  call assert_equal(1, error_caught)\n  call assert_equal(['1 aaa', '2 aaa', '3 aaa'], getline(1, 3))\n\n  delfunc Foo\n  bwipe!\nendfunc\n\n\" Test \":s/pat/sub/\" with different ~s in sub.\nfunc Test_replace_with_tilde()\n  new\n  \" Set the last replace string to empty\n  s/^$//\n  call append(0, ['- Bug in \"vPPPP\" on this text:'])\n  normal gg\n  s/u/~u~/\n  call assert_equal('- Bug in \"vPPPP\" on this text:', getline(1))\n  s/i/~u~/\n  call assert_equal('- Bug uuun \"vPPPP\" on this text:', getline(1))\n  s/o/~~~/\n  call assert_equal('- Bug uuun \"vPPPP\" uuuuuuuuun this text:', getline(1))\n  close!\nendfunc\n\nfunc Test_replace_keeppatterns()\n  new\n  a\nfoobar\n\nsubstitute foo asdf\n\none two\n.\n\n  normal gg\n  /^substitute\n  s/foo/bar/\n  call assert_equal('foo', @/)\n  call assert_equal('substitute bar asdf', getline('.'))\n\n  /^substitute\n  keeppatterns s/asdf/xyz/\n  call assert_equal('^substitute', @/)\n  call assert_equal('substitute bar xyz', getline('.'))\n\n  exe \"normal /bar /e\\<CR>\"\n  call assert_equal(15, col('.'))\n  normal -\n  keeppatterns /xyz\n  call assert_equal('bar ', @/)\n  call assert_equal('substitute bar xyz', getline('.'))\n  exe \"normal 0dn\"\n  call assert_equal('xyz', getline('.'))\n\n  close!\nendfunc\n\nfunc Test_sub_beyond_end()\n  new\n  call setline(1, '#')\n  let @/ = '^#\\n\\zs'\n  s///e\n  call assert_equal('#', getline(1))\n  bwipe!\nendfunc\n\n\" Test for repeating last substitution using :~ and :&r\nfunc Test_repeat_last_sub()\n  new\n  call setline(1, ['blue green yellow orange white'])\n  s/blue/red/\n  let @/ = 'yellow'\n  ~\n  let @/ = 'white'\n  :&r\n  let @/ = 'green'\n  s//gray\n  call assert_equal('red gray red orange red', getline(1))\n  close!\nendfunc\n\n\" Test for Vi compatible substitution:\n\"     \\/{string}/, \\?{string}? and \\&{string}&\nfunc Test_sub_vi_compatibility()\n  new\n  call setline(1, ['blue green yellow orange blue'])\n  let @/ = 'orange'\n  s\\/white/\n  let @/ = 'blue'\n  s\\?amber?\n  let @/ = 'white'\n  s\\&green&\n  call assert_equal('amber green yellow white green', getline(1))\n  close!\n\n  call assert_fails('vim9cmd s\\/white/', 'E1270:')\n  call assert_fails('vim9cmd s\\?white?', 'E1270:')\n  call assert_fails('vim9cmd s\\&white&', 'E1270:')\nendfunc\n\n\" Test for substitute with the new text longer than the original text\nfunc Test_sub_expand_text()\n  new\n  call setline(1, 'abcabcabcabcabcabcabcabc')\n  s/b/\\=repeat('B', 10)/g\n  call assert_equal(repeat('aBBBBBBBBBBc', 8), getline(1))\n  close!\nendfunc\n\n\" Test for command failures when the last substitute pattern is not set.\nfunc Test_sub_with_no_last_pat()\n  let lines =<< trim [SCRIPT]\n    call assert_fails('~', 'E33:')\n    call assert_fails('s//abc/g', 'E35:')\n    call assert_fails('s\\/bar', 'E35:')\n    call assert_fails('s\\&bar&', 'E33:')\n    call writefile(v:errors, 'Xresult')\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript')\n  if RunVim([], [], '--clean -S Xscript')\n    call assert_equal([], readfile('Xresult'))\n  endif\n\n  let lines =<< trim [SCRIPT]\n    set cpo+=/\n    call assert_fails('s/abc/%/', 'E33:')\n    call writefile(v:errors, 'Xresult')\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript')\n  if RunVim([], [], '--clean -S Xscript')\n    call assert_equal([], readfile('Xresult'))\n  endif\n\n  call delete('Xscript')\n  call delete('Xresult')\nendfunc\n\nfunc Test_substitute()\n  call assert_equal('a\uff11a\uff12a\uff13a', substitute('\uff11\uff12\uff13', '\\zs', 'a', 'g'))\n  \" Substitute with special keys\n  call assert_equal(\"a\\<End>c\", substitute('abc', \"a.c\", \"a\\<End>c\", ''))\nendfunc\n\nfunc Test_substitute_expr()\n  let g:val = 'XXX'\n  call assert_equal('XXX', substitute('yyy', 'y*', '\\=g:val', ''))\n  call assert_equal('XXX', substitute('yyy', 'y*', {-> g:val}, ''))\n  call assert_equal(\"-\\u1b \\uf2-\", substitute(\"-%1b %f2-\", '%\\(\\x\\x\\)',\n\t\t\t   \\ '\\=nr2char(\"0x\" . submatch(1))', 'g'))\n  call assert_equal(\"-\\u1b \\uf2-\", substitute(\"-%1b %f2-\", '%\\(\\x\\x\\)',\n\t\t\t   \\ {-> nr2char(\"0x\" . submatch(1))}, 'g'))\n\n  call assert_equal('231', substitute('123', '\\(.\\)\\(.\\)\\(.\\)',\n\t\\ {-> submatch(2) . submatch(3) . submatch(1)}, ''))\n\n  func Recurse()\n    return substitute('yyy', 'y\\(.\\)y', {-> submatch(1)}, '')\n  endfunc\n  \" recursive call works\n  call assert_equal('-y-x-', substitute('xxx', 'x\\(.\\)x', {-> '-' . Recurse() . '-' . submatch(1) . '-'}, ''))\n\n  call assert_fails(\"let s=submatch([])\", 'E745:')\n  call assert_fails(\"let s=submatch(2, [])\", 'E745:')\nendfunc\n\nfunc Test_invalid_submatch()\n  \" This was causing invalid memory access in Vim-7.4.2232 and older\n  call assert_fails(\"call substitute('x', '.', {-> submatch(10)}, '')\", 'E935:')\n  call assert_fails('eval submatch(-1)', 'E935:')\n  call assert_equal('', submatch(0))\n  call assert_equal('', submatch(1))\n  call assert_equal([], submatch(0, 1))\n  call assert_equal([], submatch(1, 1))\nendfunc\n\nfunc Test_submatch_list_concatenate()\n  let pat = 'A\\(.\\)'\n  let Rep = {-> string([submatch(0, 1)] + [[submatch(1)]])}\n  call substitute('A1', pat, Rep, '')->assert_equal(\"[['A1'], ['1']]\")\nendfunc\n\nfunc Test_substitute_expr_arg()\n  call assert_equal('123456789-123456789=', substitute('123456789',\n\t\\ '\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)',\n\t\\ {m -> m[0] . '-' . m[1] . m[2] . m[3] . m[4] . m[5] . m[6] . m[7] . m[8] . m[9] . '='}, ''))\n\n  call assert_equal('123456-123456=789', substitute('123456789',\n\t\\ '\\(.\\)\\(.\\)\\(.\\)\\(a*\\)\\(n*\\)\\(.\\)\\(.\\)\\(.\\)\\(x*\\)',\n\t\\ {m -> m[0] . '-' . m[1] . m[2] . m[3] . m[4] . m[5] . m[6] . m[7] . m[8] . m[9] . '='}, ''))\n\n  call assert_equal('123456789-123456789x=', substitute('123456789',\n\t\\ '\\(.\\)\\(.\\)\\(.*\\)',\n\t\\ {m -> m[0] . '-' . m[1] . m[2] . m[3] . 'x' . m[4] . m[5] . m[6] . m[7] . m[8] . m[9] . '='}, ''))\n\n  call assert_fails(\"call substitute('xxx', '.', {m -> string(add(m, 'x'))}, '')\", 'E742:')\n  call assert_fails(\"call substitute('xxx', '.', {m -> string(insert(m, 'x'))}, '')\", 'E742:')\n  call assert_fails(\"call substitute('xxx', '.', {m -> string(extend(m, ['x']))}, '')\", 'E742:')\n  call assert_fails(\"call substitute('xxx', '.', {m -> string(remove(m, 1))}, '')\", 'E742:')\nendfunc\n\n\" Test for using a function to supply the substitute string\nfunc Test_substitute_using_func()\n  func Xfunc()\n    return '1234'\n  endfunc\n  call assert_equal('a1234f', substitute('abcdef', 'b..e',\n        \\ function(\"Xfunc\"), ''))\n  delfunc Xfunc\nendfunc\n\n\" Test for using submatch() with a multiline match\nfunc Test_substitute_multiline_submatch()\n  new\n  call setline(1, ['line1', 'line2', 'line3', 'line4'])\n  %s/^line1\\(\\_.\\+\\)line4$/\\=submatch(1)/\n  call assert_equal(['', 'line2', 'line3', ''], getline(1, '$'))\n  close!\nendfunc\n\nfunc Test_substitute_skipped_range()\n  new\n  if 0\n    /1/5/2/2/\\n\n  endif\n  call assert_equal([0, 1, 1, 0, 1], getcurpos())\n  bwipe!\nendfunc\n\n\" Test using the 'gdefault' option (when on, flag 'g' is default on).\nfunc Test_substitute_gdefault()\n  new\n\n  \" First check without 'gdefault'\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/\n  call assert_equal('FOO bar foo', getline(1))\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/g\n  call assert_equal('FOO bar FOO', getline(1))\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/gg\n  call assert_equal('FOO bar foo', getline(1))\n\n  \" Then check with 'gdefault'\n  set gdefault\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/\n  call assert_equal('FOO bar FOO', getline(1))\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/g\n  call assert_equal('FOO bar foo', getline(1))\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/gg\n  call assert_equal('FOO bar FOO', getline(1))\n\n  \" Setting 'compatible' should reset 'gdefault'\n  call assert_equal(1, &gdefault)\n  set compatible\n  call assert_equal(0, &gdefault)\n  set nocompatible\n  call assert_equal(0, &gdefault)\n\n  bw!\nendfunc\n\n\" This was using \"old_sub\" after it was freed.\nfunc Test_using_old_sub()\n  set compatible maxfuncdepth=10\n  new\n  call setline(1, 'some text.')\n  func Repl()\n    ~\n    s/\n  endfunc\n  silent!  s/\\%')/\\=Repl()\n\n  delfunc Repl\n  bwipe!\n  set nocompatible\nendfunc\n\n\" This was switching windows in between computing the length and using it.\nfunc Test_sub_change_window()\n  silent! lfile\n  sil! norm o0000000000000000000000000000000000000000000000000000\n  func Repl()\n    lopen\n  endfunc\n  silent!  s/\\%')/\\=Repl()\n  bwipe!\n  bwipe!\n  delfunc Repl\nendfunc\n\n\" This was undoign a change in between computing the length and using it.\nfunc Do_Test_sub_undo_change()\n  new\n  norm o0000000000000000000000000000000000000000000000000000\n  silent! s/\\%')/\\=Repl()\n  bwipe!\nendfunc\n\nfunc Test_sub_undo_change()\n  func Repl()\n    silent! norm g-\n  endfunc\n  call Do_Test_sub_undo_change()\n\n  func! Repl()\n    silent earlier\n  endfunc\n  call Do_Test_sub_undo_change()\n\n  delfunc Repl\nendfunc\n\n\" This was opening a command line window from the expression\nfunc Test_sub_open_cmdline_win()\n  \" the error only happens in a very specific setup, run a new Vim instance to\n  \" get a clean starting point.\n  let lines =<< trim [SCRIPT]\n    norm o0000000000000000000000000000000000000000000000000000\n    func Replace()\n      norm q/\n    endfunc\n    s/\\%')/\\=Replace()\n    redir >Xresult\n    messages\n    redir END\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript')\n  if RunVim([], [], '-u NONE -S Xscript')\n    let messages = readfile('Xresult')\n    call assert_match('E565: Not allowed to change text or change window', messages[3])\n  endif\n\n  call delete('Xscript')\n  call delete('Xresult')\nendfunc\n\n\" Test for the 2-letter and 3-letter :substitute commands\nfunc Test_substitute_short_cmd()\n  new\n  call setline(1, ['one', 'one one one'])\n  s/one/two\n  call cursor(2, 1)\n\n  \" :sc\n  call feedkeys(\":sc\\<CR>y\", 'xt')\n  call assert_equal('two one one', getline(2))\n\n  \" :scg\n  call setline(2, 'one one one')\n  call feedkeys(\":scg\\<CR>nyq\", 'xt')\n  call assert_equal('one two one', getline(2))\n\n  \" :sci\n  call setline(2, 'ONE One onE')\n  call feedkeys(\":sci\\<CR>y\", 'xt')\n  call assert_equal('two One onE', getline(2))\n\n  \" :scI\n  set ignorecase\n  call setline(2, 'ONE One one')\n  call feedkeys(\":scI\\<CR>y\", 'xt')\n  call assert_equal('ONE One two', getline(2))\n  set ignorecase&\n\n  \" :scn\n  call setline(2, 'one one one')\n  let t = execute('scn')->split(\"\\n\")\n  call assert_equal(['1 match on 1 line'], t)\n  call assert_equal('one one one', getline(2))\n\n  \" :scp\n  call setline(2, \"\\tone one one\")\n  redir => output\n  call feedkeys(\":scp\\<CR>y\", 'xt')\n  redir END\n  call assert_equal('        two one one', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo one one\", getline(2))\n\n  \" :scl\n  call setline(2, \"\\tone one one\")\n  redir => output\n  call feedkeys(\":scl\\<CR>y\", 'xt')\n  redir END\n  call assert_equal(\"^Itwo one one$\", output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo one one\", getline(2))\n\n  \" :sgc\n  call setline(2, 'one one one one one')\n  call feedkeys(\":sgc\\<CR>nyyq\", 'xt')\n  call assert_equal('one two two one one', getline(2))\n\n  \" :sg\n  call setline(2, 'one one one')\n  sg\n  call assert_equal('two two two', getline(2))\n\n  \" :sgi\n  call setline(2, 'ONE One onE')\n  sgi\n  call assert_equal('two two two', getline(2))\n\n  \" :sgI\n  set ignorecase\n  call setline(2, 'ONE One one')\n  sgI\n  call assert_equal('ONE One two', getline(2))\n  set ignorecase&\n\n  \" :sgn\n  call setline(2, 'one one one')\n  let t = execute('sgn')->split(\"\\n\")\n  call assert_equal(['3 matches on 1 line'], t)\n  call assert_equal('one one one', getline(2))\n\n  \" :sgp\n  call setline(2, \"\\tone one one\")\n  redir => output\n  sgp\n  redir END\n  call assert_equal('        two two two', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo two two\", getline(2))\n\n  \" :sgl\n  call setline(2, \"\\tone one one\")\n  redir => output\n  sgl\n  redir END\n  call assert_equal(\"^Itwo two two$\", output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo two two\", getline(2))\n\n  \" :sgr\n  call setline(2, \"one one one\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sgr\n  call assert_equal('xyz xyz xyz', getline(2))\n\n  \" :sic\n  call cursor(1, 1)\n  s/one/two/e\n  call setline(2, \"ONE One one\")\n  call cursor(2, 1)\n  call feedkeys(\":sic\\<CR>y\", 'xt')\n  call assert_equal('two One one', getline(2))\n\n  \" :si\n  call setline(2, \"ONE One one\")\n  si\n  call assert_equal('two One one', getline(2))\n\n  \" :siI\n  call setline(2, \"ONE One one\")\n  siI\n  call assert_equal('ONE One two', getline(2))\n\n  \" :sin\n  call setline(2, 'ONE One onE')\n  let t = execute('sin')->split(\"\\n\")\n  call assert_equal(['1 match on 1 line'], t)\n  call assert_equal('ONE One onE', getline(2))\n\n  \" :sip\n  call setline(2, \"\\tONE One onE\")\n  redir => output\n  sip\n  redir END\n  call assert_equal('        two One onE', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo One onE\", getline(2))\n\n  \" :sir\n  call setline(2, \"ONE One onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sir\n  call assert_equal('xyz One onE', getline(2))\n\n  \" :sIc\n  call cursor(1, 1)\n  s/one/two/e\n  call setline(2, \"ONE One one\")\n  call cursor(2, 1)\n  call feedkeys(\":sIc\\<CR>y\", 'xt')\n  call assert_equal('ONE One two', getline(2))\n\n  \" :sIg\n  call setline(2, \"ONE one onE one\")\n  sIg\n  call assert_equal('ONE two onE two', getline(2))\n\n  \" :sIi\n  call setline(2, \"ONE One one\")\n  sIi\n  call assert_equal('two One one', getline(2))\n\n  \" :sI\n  call setline(2, \"ONE One one\")\n  sI\n  call assert_equal('ONE One two', getline(2))\n\n  \" :sIn\n  call setline(2, 'ONE One one')\n  let t = execute('sIn')->split(\"\\n\")\n  call assert_equal(['1 match on 1 line'], t)\n  call assert_equal('ONE One one', getline(2))\n\n  \" :sIp\n  call setline(2, \"\\tONE One one\")\n  redir => output\n  sIp\n  redir END\n  call assert_equal('        ONE One two', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\tONE One two\", getline(2))\n\n  \" :sIl\n  call setline(2, \"\\tONE onE one\")\n  redir => output\n  sIl\n  redir END\n  call assert_equal(\"^IONE onE two$\", output->split(\"\\n\")[-1])\n  call assert_equal(\"\\tONE onE two\", getline(2))\n\n  \" :sIr\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sIr\n  call assert_equal('ONE xyz onE', getline(2))\n\n  \" :src\n  call setline(2, \"ONE one one\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  call feedkeys(\":src\\<CR>y\", 'xt')\n  call assert_equal('ONE xyz one', getline(2))\n\n  \" :srg\n  call setline(2, \"one one one\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  srg\n  call assert_equal('xyz xyz xyz', getline(2))\n\n  \" :sri\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sri\n  call assert_equal('xyz one onE', getline(2))\n\n  \" :srI\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  srI\n  call assert_equal('ONE xyz onE', getline(2))\n\n  \" :srn\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  let t = execute('srn')->split(\"\\n\")\n  call assert_equal(['1 match on 1 line'], t)\n  call assert_equal('ONE one onE', getline(2))\n\n  \" :srp\n  call setline(2, \"\\tONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  redir => output\n  srp\n  redir END\n  call assert_equal('        ONE xyz onE', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\tONE xyz onE\", getline(2))\n\n  \" :srl\n  call setline(2, \"\\tONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  redir => output\n  srl\n  redir END\n  call assert_equal(\"^IONE xyz onE$\", output->split(\"\\n\")[-1])\n  call assert_equal(\"\\tONE xyz onE\", getline(2))\n\n  \" :sr\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sr\n  call assert_equal('ONE xyz onE', getline(2))\n\n  \" :sce\n  s/abc/xyz/e\n  call assert_fails(\"sc\", 'E486:')\n  sce\n  \" :sge\n  call assert_fails(\"sg\", 'E486:')\n  sge\n  \" :sie\n  call assert_fails(\"si\", 'E486:')\n  sie\n  \" :sIe\n  call assert_fails(\"sI\", 'E486:')\n  sIe\n\n  bw!\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    5043,\n/**/\n    5042,\n/**/\n    5041,\n/**/\n    5040,\n/**/\n    5039,\n/**/\n    5038,\n/**/\n    5037,\n/**/\n    5036,\n/**/\n    5035,\n/**/\n    5034,\n/**/\n    5033,\n/**/\n    5032,\n/**/\n    5031,\n/**/\n    5030,\n/**/\n    5029,\n/**/\n    5028,\n/**/\n    5027,\n/**/\n    5026,\n/**/\n    5025,\n/**/\n    5024,\n/**/\n    5023,\n/**/\n    5022,\n/**/\n    5021,\n/**/\n    5020,\n/**/\n    5019,\n/**/\n    5018,\n/**/\n    5017,\n/**/\n    5016,\n/**/\n    5015,\n/**/\n    5014,\n/**/\n    5013,\n/**/\n    5012,\n/**/\n    5011,\n/**/\n    5010,\n/**/\n    5009,\n/**/\n    5008,\n/**/\n    5007,\n/**/\n    5006,\n/**/\n    5005,\n/**/\n    5004,\n/**/\n    5003,\n/**/\n    5002,\n/**/\n    5001,\n/**/\n    5000,\n/**/\n    4999,\n/**/\n    4998,\n/**/\n    4997,\n/**/\n    4996,\n/**/\n    4995,\n/**/\n    4994,\n/**/\n    4993,\n/**/\n    4992,\n/**/\n    4991,\n/**/\n    4990,\n/**/\n    4989,\n/**/\n    4988,\n/**/\n    4987,\n/**/\n    4986,\n/**/\n    4985,\n/**/\n    4984,\n/**/\n    4983,\n/**/\n    4982,\n/**/\n    4981,\n/**/\n    4980,\n/**/\n    4979,\n/**/\n    4978,\n/**/\n    4977,\n/**/\n    4976,\n/**/\n    4975,\n/**/\n    4974,\n/**/\n    4973,\n/**/\n    4972,\n/**/\n    4971,\n/**/\n    4970,\n/**/\n    4969,\n/**/\n    4968,\n/**/\n    4967,\n/**/\n    4966,\n/**/\n    4965,\n/**/\n    4964,\n/**/\n    4963,\n/**/\n    4962,\n/**/\n    4961,\n/**/\n    4960,\n/**/\n    4959,\n/**/\n    4958,\n/**/\n    4957,\n/**/\n    4956,\n/**/\n    4955,\n/**/\n    4954,\n/**/\n    4953,\n/**/\n    4952,\n/**/\n    4951,\n/**/\n    4950,\n/**/\n    4949,\n/**/\n    4948,\n/**/\n    4947,\n/**/\n    4946,\n/**/\n    4945,\n/**/\n    4944,\n/**/\n    4943,\n/**/\n    4942,\n/**/\n    4941,\n/**/\n    4940,\n/**/\n    4939,\n/**/\n    4938,\n/**/\n    4937,\n/**/\n    4936,\n/**/\n    4935,\n/**/\n    4934,\n/**/\n    4933,\n/**/\n    4932,\n/**/\n    4931,\n/**/\n    4930,\n/**/\n    4929,\n/**/\n    4928,\n/**/\n    4927,\n/**/\n    4926,\n/**/\n    4925,\n/**/\n    4924,\n/**/\n    4923,\n/**/\n    4922,\n/**/\n    4921,\n/**/\n    4920,\n/**/\n    4919,\n/**/\n    4918,\n/**/\n    4917,\n/**/\n    4916,\n/**/\n    4915,\n/**/\n    4914,\n/**/\n    4913,\n/**/\n    4912,\n/**/\n    4911,\n/**/\n    4910,\n/**/\n    4909,\n/**/\n    4908,\n/**/\n    4907,\n/**/\n    4906,\n/**/\n    4905,\n/**/\n    4904,\n/**/\n    4903,\n/**/\n    4902,\n/**/\n    4901,\n/**/\n    4900,\n/**/\n    4899,\n/**/\n    4898,\n/**/\n    4897,\n/**/\n    4896,\n/**/\n    4895,\n/**/\n    4894,\n/**/\n    4893,\n/**/\n    4892,\n/**/\n    4891,\n/**/\n    4890,\n/**/\n    4889,\n/**/\n    4888,\n/**/\n    4887,\n/**/\n    4886,\n/**/\n    4885,\n/**/\n    4884,\n/**/\n    4883,\n/**/\n    4882,\n/**/\n    4881,\n/**/\n    4880,\n/**/\n    4879,\n/**/\n    4878,\n/**/\n    4877,\n/**/\n    4876,\n/**/\n    4875,\n/**/\n    4874,\n/**/\n    4873,\n/**/\n    4872,\n/**/\n    4871,\n/**/\n    4870,\n/**/\n    4869,\n/**/\n    4868,\n/**/\n    4867,\n/**/\n    4866,\n/**/\n    4865,\n/**/\n    4864,\n/**/\n    4863,\n/**/\n    4862,\n/**/\n    4861,\n/**/\n    4860,\n/**/\n    4859,\n/**/\n    4858,\n/**/\n    4857,\n/**/\n    4856,\n/**/\n    4855,\n/**/\n    4854,\n/**/\n    4853,\n/**/\n    4852,\n/**/\n    4851,\n/**/\n    4850,\n/**/\n    4849,\n/**/\n    4848,\n/**/\n    4847,\n/**/\n    4846,\n/**/\n    4845,\n/**/\n    4844,\n/**/\n    4843,\n/**/\n    4842,\n/**/\n    4841,\n/**/\n    4840,\n/**/\n    4839,\n/**/\n    4838,\n/**/\n    4837,\n/**/\n    4836,\n/**/\n    4835,\n/**/\n    4834,\n/**/\n    4833,\n/**/\n    4832,\n/**/\n    4831,\n/**/\n    4830,\n/**/\n    4829,\n/**/\n    4828,\n/**/\n    4827,\n/**/\n    4826,\n/**/\n    4825,\n/**/\n    4824,\n/**/\n    4823,\n/**/\n    4822,\n/**/\n    4821,\n/**/\n    4820,\n/**/\n    4819,\n/**/\n    4818,\n/**/\n    4817,\n/**/\n    4816,\n/**/\n    4815,\n/**/\n    4814,\n/**/\n    4813,\n/**/\n    4812,\n/**/\n    4811,\n/**/\n    4810,\n/**/\n    4809,\n/**/\n    4808,\n/**/\n    4807,\n/**/\n    4806,\n/**/\n    4805,\n/**/\n    4804,\n/**/\n    4803,\n/**/\n    4802,\n/**/\n    4801,\n/**/\n    4800,\n/**/\n    4799,\n/**/\n    4798,\n/**/\n    4797,\n/**/\n    4796,\n/**/\n    4795,\n/**/\n    4794,\n/**/\n    4793,\n/**/\n    4792,\n/**/\n    4791,\n/**/\n    4790,\n/**/\n    4789,\n/**/\n    4788,\n/**/\n    4787,\n/**/\n    4786,\n/**/\n    4785,\n/**/\n    4784,\n/**/\n    4783,\n/**/\n    4782,\n/**/\n    4781,\n/**/\n    4780,\n/**/\n    4779,\n/**/\n    4778,\n/**/\n    4777,\n/**/\n    4776,\n/**/\n    4775,\n/**/\n    4774,\n/**/\n    4773,\n/**/\n    4772,\n/**/\n    4771,\n/**/\n    4770,\n/**/\n    4769,\n/**/\n    4768,\n/**/\n    4767,\n/**/\n    4766,\n/**/\n    4765,\n/**/\n    4764,\n/**/\n    4763,\n/**/\n    4762,\n/**/\n    4761,\n/**/\n    4760,\n/**/\n    4759,\n/**/\n    4758,\n/**/\n    4757,\n/**/\n    4756,\n/**/\n    4755,\n/**/\n    4754,\n/**/\n    4753,\n/**/\n    4752,\n/**/\n    4751,\n/**/\n    4750,\n/**/\n    4749,\n/**/\n    4748,\n/**/\n    4747,\n/**/\n    4746,\n/**/\n    4745,\n/**/\n    4744,\n/**/\n    4743,\n/**/\n    4742,\n/**/\n    4741,\n/**/\n    4740,\n/**/\n    4739,\n/**/\n    4738,\n/**/\n    4737,\n/**/\n    4736,\n/**/\n    4735,\n/**/\n    4734,\n/**/\n    4733,\n/**/\n    4732,\n/**/\n    4731,\n/**/\n    4730,\n/**/\n    4729,\n/**/\n    4728,\n/**/\n    4727,\n/**/\n    4726,\n/**/\n    4725,\n/**/\n    4724,\n/**/\n    4723,\n/**/\n    4722,\n/**/\n    4721,\n/**/\n    4720,\n/**/\n    4719,\n/**/\n    4718,\n/**/\n    4717,\n/**/\n    4716,\n/**/\n    4715,\n/**/\n    4714,\n/**/\n    4713,\n/**/\n    4712,\n/**/\n    4711,\n/**/\n    4710,\n/**/\n    4709,\n/**/\n    4708,\n/**/\n    4707,\n/**/\n    4706,\n/**/\n    4705,\n/**/\n    4704,\n/**/\n    4703,\n/**/\n    4702,\n/**/\n    4701,\n/**/\n    4700,\n/**/\n    4699,\n/**/\n    4698,\n/**/\n    4697,\n/**/\n    4696,\n/**/\n    4695,\n/**/\n    4694,\n/**/\n    4693,\n/**/\n    4692,\n/**/\n    4691,\n/**/\n    4690,\n/**/\n    4689,\n/**/\n    4688,\n/**/\n    4687,\n/**/\n    4686,\n/**/\n    4685,\n/**/\n    4684,\n/**/\n    4683,\n/**/\n    4682,\n/**/\n    4681,\n/**/\n    4680,\n/**/\n    4679,\n/**/\n    4678,\n/**/\n    4677,\n/**/\n    4676,\n/**/\n    4675,\n/**/\n    4674,\n/**/\n    4673,\n/**/\n    4672,\n/**/\n    4671,\n/**/\n    4670,\n/**/\n    4669,\n/**/\n    4668,\n/**/\n    4667,\n/**/\n    4666,\n/**/\n    4665,\n/**/\n    4664,\n/**/\n    4663,\n/**/\n    4662,\n/**/\n    4661,\n/**/\n    4660,\n/**/\n    4659,\n/**/\n    4658,\n/**/\n    4657,\n/**/\n    4656,\n/**/\n    4655,\n/**/\n    4654,\n/**/\n    4653,\n/**/\n    4652,\n/**/\n    4651,\n/**/\n    4650,\n/**/\n    4649,\n/**/\n    4648,\n/**/\n    4647,\n/**/\n    4646,\n/**/\n    4645,\n/**/\n    4644,\n/**/\n    4643,\n/**/\n    4642,\n/**/\n    4641,\n/**/\n    4640,\n/**/\n    4639,\n/**/\n    4638,\n/**/\n    4637,\n/**/\n    4636,\n/**/\n    4635,\n/**/\n    4634,\n/**/\n    4633,\n/**/\n    4632,\n/**/\n    4631,\n/**/\n    4630,\n/**/\n    4629,\n/**/\n    4628,\n/**/\n    4627,\n/**/\n    4626,\n/**/\n    4625,\n/**/\n    4624,\n/**/\n    4623,\n/**/\n    4622,\n/**/\n    4621,\n/**/\n    4620,\n/**/\n    4619,\n/**/\n    4618,\n/**/\n    4617,\n/**/\n    4616,\n/**/\n    4615,\n/**/\n    4614,\n/**/\n    4613,\n/**/\n    4612,\n/**/\n    4611,\n/**/\n    4610,\n/**/\n    4609,\n/**/\n    4608,\n/**/\n    4607,\n/**/\n    4606,\n/**/\n    4605,\n/**/\n    4604,\n/**/\n    4603,\n/**/\n    4602,\n/**/\n    4601,\n/**/\n    4600,\n/**/\n    4599,\n/**/\n    4598,\n/**/\n    4597,\n/**/\n    4596,\n/**/\n    4595,\n/**/\n    4594,\n/**/\n    4593,\n/**/\n    4592,\n/**/\n    4591,\n/**/\n    4590,\n/**/\n    4589,\n/**/\n    4588,\n/**/\n    4587,\n/**/\n    4586,\n/**/\n    4585,\n/**/\n    4584,\n/**/\n    4583,\n/**/\n    4582,\n/**/\n    4581,\n/**/\n    4580,\n/**/\n    4579,\n/**/\n    4578,\n/**/\n    4577,\n/**/\n    4576,\n/**/\n    4575,\n/**/\n    4574,\n/**/\n    4573,\n/**/\n    4572,\n/**/\n    4571,\n/**/\n    4570,\n/**/\n    4569,\n/**/\n    4568,\n/**/\n    4567,\n/**/\n    4566,\n/**/\n    4565,\n/**/\n    4564,\n/**/\n    4563,\n/**/\n    4562,\n/**/\n    4561,\n/**/\n    4560,\n/**/\n    4559,\n/**/\n    4558,\n/**/\n    4557,\n/**/\n    4556,\n/**/\n    4555,\n/**/\n    4554,\n/**/\n    4553,\n/**/\n    4552,\n/**/\n    4551,\n/**/\n    4550,\n/**/\n    4549,\n/**/\n    4548,\n/**/\n    4547,\n/**/\n    4546,\n/**/\n    4545,\n/**/\n    4544,\n/**/\n    4543,\n/**/\n    4542,\n/**/\n    4541,\n/**/\n    4540,\n/**/\n    4539,\n/**/\n    4538,\n/**/\n    4537,\n/**/\n    4536,\n/**/\n    4535,\n/**/\n    4534,\n/**/\n    4533,\n/**/\n    4532,\n/**/\n    4531,\n/**/\n    4530,\n/**/\n    4529,\n/**/\n    4528,\n/**/\n    4527,\n/**/\n    4526,\n/**/\n    4525,\n/**/\n    4524,\n/**/\n    4523,\n/**/\n    4522,\n/**/\n    4521,\n/**/\n    4520,\n/**/\n    4519,\n/**/\n    4518,\n/**/\n    4517,\n/**/\n    4516,\n/**/\n    4515,\n/**/\n    4514,\n/**/\n    4513,\n/**/\n    4512,\n/**/\n    4511,\n/**/\n    4510,\n/**/\n    4509,\n/**/\n    4508,\n/**/\n    4507,\n/**/\n    4506,\n/**/\n    4505,\n/**/\n    4504,\n/**/\n    4503,\n/**/\n    4502,\n/**/\n    4501,\n/**/\n    4500,\n/**/\n    4499,\n/**/\n    4498,\n/**/\n    4497,\n/**/\n    4496,\n/**/\n    4495,\n/**/\n    4494,\n/**/\n    4493,\n/**/\n    4492,\n/**/\n    4491,\n/**/\n    4490,\n/**/\n    4489,\n/**/\n    4488,\n/**/\n    4487,\n/**/\n    4486,\n/**/\n    4485,\n/**/\n    4484,\n/**/\n    4483,\n/**/\n    4482,\n/**/\n    4481,\n/**/\n    4480,\n/**/\n    4479,\n/**/\n    4478,\n/**/\n    4477,\n/**/\n    4476,\n/**/\n    4475,\n/**/\n    4474,\n/**/\n    4473,\n/**/\n    4472,\n/**/\n    4471,\n/**/\n    4470,\n/**/\n    4469,\n/**/\n    4468,\n/**/\n    4467,\n/**/\n    4466,\n/**/\n    4465,\n/**/\n    4464,\n/**/\n    4463,\n/**/\n    4462,\n/**/\n    4461,\n/**/\n    4460,\n/**/\n    4459,\n/**/\n    4458,\n/**/\n    4457,\n/**/\n    4456,\n/**/\n    4455,\n/**/\n    4454,\n/**/\n    4453,\n/**/\n    4452,\n/**/\n    4451,\n/**/\n    4450,\n/**/\n    4449,\n/**/\n    4448,\n/**/\n    4447,\n/**/\n    4446,\n/**/\n    4445,\n/**/\n    4444,\n/**/\n    4443,\n/**/\n    4442,\n/**/\n    4441,\n/**/\n    4440,\n/**/\n    4439,\n/**/\n    4438,\n/**/\n    4437,\n/**/\n    4436,\n/**/\n    4435,\n/**/\n    4434,\n/**/\n    4433,\n/**/\n    4432,\n/**/\n    4431,\n/**/\n    4430,\n/**/\n    4429,\n/**/\n    4428,\n/**/\n    4427,\n/**/\n    4426,\n/**/\n    4425,\n/**/\n    4424,\n/**/\n    4423,\n/**/\n    4422,\n/**/\n    4421,\n/**/\n    4420,\n/**/\n    4419,\n/**/\n    4418,\n/**/\n    4417,\n/**/\n    4416,\n/**/\n    4415,\n/**/\n    4414,\n/**/\n    4413,\n/**/\n    4412,\n/**/\n    4411,\n/**/\n    4410,\n/**/\n    4409,\n/**/\n    4408,\n/**/\n    4407,\n/**/\n    4406,\n/**/\n    4405,\n/**/\n    4404,\n/**/\n    4403,\n/**/\n    4402,\n/**/\n    4401,\n/**/\n    4400,\n/**/\n    4399,\n/**/\n    4398,\n/**/\n    4397,\n/**/\n    4396,\n/**/\n    4395,\n/**/\n    4394,\n/**/\n    4393,\n/**/\n    4392,\n/**/\n    4391,\n/**/\n    4390,\n/**/\n    4389,\n/**/\n    4388,\n/**/\n    4387,\n/**/\n    4386,\n/**/\n    4385,\n/**/\n    4384,\n/**/\n    4383,\n/**/\n    4382,\n/**/\n    4381,\n/**/\n    4380,\n/**/\n    4379,\n/**/\n    4378,\n/**/\n    4377,\n/**/\n    4376,\n/**/\n    4375,\n/**/\n    4374,\n/**/\n    4373,\n/**/\n    4372,\n/**/\n    4371,\n/**/\n    4370,\n/**/\n    4369,\n/**/\n    4368,\n/**/\n    4367,\n/**/\n    4366,\n/**/\n    4365,\n/**/\n    4364,\n/**/\n    4363,\n/**/\n    4362,\n/**/\n    4361,\n/**/\n    4360,\n/**/\n    4359,\n/**/\n    4358,\n/**/\n    4357,\n/**/\n    4356,\n/**/\n    4355,\n/**/\n    4354,\n/**/\n    4353,\n/**/\n    4352,\n/**/\n    4351,\n/**/\n    4350,\n/**/\n    4349,\n/**/\n    4348,\n/**/\n    4347,\n/**/\n    4346,\n/**/\n    4345,\n/**/\n    4344,\n/**/\n    4343,\n/**/\n    4342,\n/**/\n    4341,\n/**/\n    4340,\n/**/\n    4339,\n/**/\n    4338,\n/**/\n    4337,\n/**/\n    4336,\n/**/\n    4335,\n/**/\n    4334,\n/**/\n    4333,\n/**/\n    4332,\n/**/\n    4331,\n/**/\n    4330,\n/**/\n    4329,\n/**/\n    4328,\n/**/\n    4327,\n/**/\n    4326,\n/**/\n    4325,\n/**/\n    4324,\n/**/\n    4323,\n/**/\n    4322,\n/**/\n    4321,\n/**/\n    4320,\n/**/\n    4319,\n/**/\n    4318,\n/**/\n    4317,\n/**/\n    4316,\n/**/\n    4315,\n/**/\n    4314,\n/**/\n    4313,\n/**/\n    4312,\n/**/\n    4311,\n/**/\n    4310,\n/**/\n    4309,\n/**/\n    4308,\n/**/\n    4307,\n/**/\n    4306,\n/**/\n    4305,\n/**/\n    4304,\n/**/\n    4303,\n/**/\n    4302,\n/**/\n    4301,\n/**/\n    4300,\n/**/\n    4299,\n/**/\n    4298,\n/**/\n    4297,\n/**/\n    4296,\n/**/\n    4295,\n/**/\n    4294,\n/**/\n    4293,\n/**/\n    4292,\n/**/\n    4291,\n/**/\n    4290,\n/**/\n    4289,\n/**/\n    4288,\n/**/\n    4287,\n/**/\n    4286,\n/**/\n    4285,\n/**/\n    4284,\n/**/\n    4283,\n/**/\n    4282,\n/**/\n    4281,\n/**/\n    4280,\n/**/\n    4279,\n/**/\n    4278,\n/**/\n    4277,\n/**/\n    4276,\n/**/\n    4275,\n/**/\n    4274,\n/**/\n    4273,\n/**/\n    4272,\n/**/\n    4271,\n/**/\n    4270,\n/**/\n    4269,\n/**/\n    4268,\n/**/\n    4267,\n/**/\n    4266,\n/**/\n    4265,\n/**/\n    4264,\n/**/\n    4263,\n/**/\n    4262,\n/**/\n    4261,\n/**/\n    4260,\n/**/\n    4259,\n/**/\n    4258,\n/**/\n    4257,\n/**/\n    4256,\n/**/\n    4255,\n/**/\n    4254,\n/**/\n    4253,\n/**/\n    4252,\n/**/\n    4251,\n/**/\n    4250,\n/**/\n    4249,\n/**/\n    4248,\n/**/\n    4247,\n/**/\n    4246,\n/**/\n    4245,\n/**/\n    4244,\n/**/\n    4243,\n/**/\n    4242,\n/**/\n    4241,\n/**/\n    4240,\n/**/\n    4239,\n/**/\n    4238,\n/**/\n    4237,\n/**/\n    4236,\n/**/\n    4235,\n/**/\n    4234,\n/**/\n    4233,\n/**/\n    4232,\n/**/\n    4231,\n/**/\n    4230,\n/**/\n    4229,\n/**/\n    4228,\n/**/\n    4227,\n/**/\n    4226,\n/**/\n    4225,\n/**/\n    4224,\n/**/\n    4223,\n/**/\n    4222,\n/**/\n    4221,\n/**/\n    4220,\n/**/\n    4219,\n/**/\n    4218,\n/**/\n    4217,\n/**/\n    4216,\n/**/\n    4215,\n/**/\n    4214,\n/**/\n    4213,\n/**/\n    4212,\n/**/\n    4211,\n/**/\n    4210,\n/**/\n    4209,\n/**/\n    4208,\n/**/\n    4207,\n/**/\n    4206,\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read a list of people who contributed.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\nstatic void cmd_with_count(char *cmd, char_u *bufp, size_t bufsize, long Prenum);\nstatic void win_init(win_T *newp, win_T *oldp, int flags);\nstatic void win_init_some(win_T *newp, win_T *oldp);\nstatic void frame_comp_pos(frame_T *topfrp, int *row, int *col);\nstatic void frame_setheight(frame_T *curfrp, int height);\nstatic void frame_setwidth(frame_T *curfrp, int width);\nstatic void win_exchange(long);\nstatic void win_rotate(int, int);\nstatic void win_totop(int size, int flags);\nstatic void win_equal_rec(win_T *next_curwin, int current, frame_T *topfr, int dir, int col, int row, int width, int height);\nstatic void trigger_winclosed(win_T *win);\nstatic win_T *win_free_mem(win_T *win, int *dirp, tabpage_T *tp);\nstatic frame_T *win_altframe(win_T *win, tabpage_T *tp);\nstatic tabpage_T *alt_tabpage(void);\nstatic win_T *frame2win(frame_T *frp);\nstatic int frame_has_win(frame_T *frp, win_T *wp);\nstatic void frame_new_height(frame_T *topfrp, int height, int topfirst, int wfh);\nstatic int frame_fixed_height(frame_T *frp);\nstatic int frame_fixed_width(frame_T *frp);\nstatic void frame_add_statusline(frame_T *frp);\nstatic void frame_new_width(frame_T *topfrp, int width, int leftfirst, int wfw);\nstatic void frame_add_vsep(frame_T *frp);\nstatic int frame_minwidth(frame_T *topfrp, win_T *next_curwin);\nstatic void frame_fix_width(win_T *wp);\nstatic int win_alloc_firstwin(win_T *oldwin);\nstatic void new_frame(win_T *wp);\nstatic tabpage_T *alloc_tabpage(void);\nstatic int leave_tabpage(buf_T *new_curbuf, int trigger_leave_autocmds);\nstatic void enter_tabpage(tabpage_T *tp, buf_T *old_curbuf, int trigger_enter_autocmds, int trigger_leave_autocmds);\nstatic void frame_fix_height(win_T *wp);\nstatic int frame_minheight(frame_T *topfrp, win_T *next_curwin);\nstatic int may_open_tabpage(void);\nstatic int win_enter_ext(win_T *wp, int flags);\nstatic void win_free(win_T *wp, tabpage_T *tp);\nstatic void win_append(win_T *after, win_T *wp);\nstatic void frame_append(frame_T *after, frame_T *frp);\nstatic void frame_insert(frame_T *before, frame_T *frp);\nstatic void frame_remove(frame_T *frp);\nstatic void win_goto_ver(int up, long count);\nstatic void win_goto_hor(int left, long count);\nstatic void frame_add_height(frame_T *frp, int n);\nstatic void last_status_rec(frame_T *fr, int statusline);\n\nstatic void make_snapshot_rec(frame_T *fr, frame_T **frp);\nstatic void clear_snapshot(tabpage_T *tp, int idx);\nstatic void clear_snapshot_rec(frame_T *fr);\nstatic int check_snapshot_rec(frame_T *sn, frame_T *fr);\nstatic win_T *restore_snapshot_rec(frame_T *sn, frame_T *fr);\nstatic win_T *get_snapshot_curwin(int idx);\n\nstatic int frame_check_height(frame_T *topfrp, int height);\nstatic int frame_check_width(frame_T *topfrp, int width);\n\nstatic win_T *win_alloc(win_T *after, int hidden);\n\n#define NOWIN\t\t((win_T *)-1)\t// non-existing window\n\n#define ROWS_AVAIL (Rows - p_ch - tabline_height())\n\n// flags for win_enter_ext()\n#define WEE_UNDO_SYNC\t\t\t0x01\n#define WEE_CURWIN_INVALID\t\t0x02\n#define WEE_TRIGGER_NEW_AUTOCMDS\t0x04\n#define WEE_TRIGGER_ENTER_AUTOCMDS\t0x08\n#define WEE_TRIGGER_LEAVE_AUTOCMDS\t0x10\n#define WEE_ALLOW_PARSE_MESSAGES\t0x20\n\nstatic char *m_onlyone = N_(\"Already only one window\");\n\n// When non-zero splitting a window is forbidden.  Used to avoid that nasty\n// autocommands mess up the window structure.\nstatic int split_disallowed = 0;\n\n// #define WIN_DEBUG\n#ifdef WIN_DEBUG\n/*\n * Call this method to log the current window layout.\n */\n    static void\nlog_frame_layout(frame_T *frame)\n{\n    ch_log(NULL, \"layout %s, wi: %d, he: %d, wwi: %d, whe: %d, id: %d\",\n\t    frame->fr_layout == FR_LEAF ? \"LEAF\"\n\t\t\t\t  : frame->fr_layout == FR_ROW ? \"ROW\" : \"COL\",\n\t    frame->fr_width,\n\t    frame->fr_height,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_width,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_height,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_id);\n    if (frame->fr_child != NULL)\n    {\n\tch_log(NULL, \"children\");\n\tlog_frame_layout(frame->fr_child);\n\tif (frame->fr_next != NULL)\n\t    ch_log(NULL, \"END of children\");\n    }\n    if (frame->fr_next != NULL)\n\tlog_frame_layout(frame->fr_next);\n}\n#endif\n\n/*\n * Return the current window, unless in the cmdline window and \"prevwin\" is\n * set, then return \"prevwin\".\n */\n    win_T *\nprevwin_curwin(void)\n{\n    return\n#ifdef FEAT_CMDWIN\n\t// In cmdwin, the alternative buffer should be used.\n\tis_in_cmdwin() && prevwin != NULL ? prevwin :\n#endif\n\tcurwin;\n}\n\n/*\n * All CTRL-W window commands are handled here, called from normal_cmd().\n */\n    void\ndo_window(\n    int\t\tnchar,\n    long\tPrenum,\n    int\t\txchar)\t    // extra char from \":wincmd gx\" or NUL\n{\n    long\tPrenum1;\n    win_T\t*wp;\n#if defined(FEAT_SEARCHPATH) || defined(FEAT_FIND_ID)\n    char_u\t*ptr;\n    linenr_T    lnum = -1;\n#endif\n#ifdef FEAT_FIND_ID\n    int\t\ttype = FIND_DEFINE;\n    int\t\tlen;\n#endif\n    char_u\tcbuf[40];\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n#ifdef FEAT_CMDWIN\n# define CHECK_CMDWIN \\\n    do { \\\n\tif (cmdwin_type != 0) \\\n\t{ \\\n\t    emsg(_(e_invalid_in_cmdline_window)); \\\n\t    return; \\\n\t} \\\n    } while (0)\n#else\n# define CHECK_CMDWIN do { /**/ } while (0)\n#endif\n\n    Prenum1 = Prenum == 0 ? 1 : Prenum;\n\n    switch (nchar)\n    {\n// split current window in two parts, horizontally\n    case 'S':\n    case Ctrl_S:\n    case 's':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n#ifdef FEAT_QUICKFIX\n\t\t// When splitting the quickfix window open a new buffer in it,\n\t\t// don't replicate the quickfix buffer.\n\t\tif (bt_quickfix(curbuf))\n\t\t    goto newwindow;\n#endif\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\t(void)win_split((int)Prenum, 0);\n\t\tbreak;\n\n// split current window in two parts, vertically\n    case Ctrl_V:\n    case 'v':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n#ifdef FEAT_QUICKFIX\n\t\t// When splitting the quickfix window open a new buffer in it,\n\t\t// don't replicate the quickfix buffer.\n\t\tif (bt_quickfix(curbuf))\n\t\t    goto newwindow;\n#endif\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\t(void)win_split((int)Prenum, WSP_VERT);\n\t\tbreak;\n\n// split current window and edit alternate file\n    case Ctrl_HAT:\n    case '^':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\n\t\tif (buflist_findnr(Prenum == 0\n\t\t\t\t\t? curwin->w_alt_fnum : Prenum) == NULL)\n\t\t{\n\t\t    if (Prenum == 0)\n\t\t\temsg(_(e_no_alternate_file));\n\t\t    else\n\t\t\tsemsg(_(e_buffer_nr_not_found), Prenum);\n\t\t    break;\n\t\t}\n\n\t\tif (!curbuf_locked() && win_split(0, 0) == OK)\n\t\t    (void)buflist_getfile(\n\t\t\t    Prenum == 0 ? curwin->w_alt_fnum : Prenum,\n\t\t\t    (linenr_T)0, GETF_ALT, FALSE);\n\t\tbreak;\n\n// open new window\n    case Ctrl_N:\n    case 'n':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n#ifdef FEAT_QUICKFIX\nnewwindow:\n#endif\n\t\tif (Prenum)\n\t\t    // window height\n\t\t    vim_snprintf((char *)cbuf, sizeof(cbuf) - 5, \"%ld\", Prenum);\n\t\telse\n\t\t    cbuf[0] = NUL;\n#if defined(FEAT_QUICKFIX)\n\t\tif (nchar == 'v' || nchar == Ctrl_V)\n\t\t    STRCAT(cbuf, \"v\");\n#endif\n\t\tSTRCAT(cbuf, \"new\");\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// quit current window\n    case Ctrl_Q:\n    case 'q':\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"quit\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// close current window\n    case Ctrl_C:\n    case 'c':\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"close\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n#if defined(FEAT_QUICKFIX)\n// close preview window\n    case Ctrl_Z:\n    case 'z':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tdo_cmdline_cmd((char_u *)\"pclose\");\n\t\tbreak;\n\n// cursor to preview window\n    case 'P':\n\t\tFOR_ALL_WINDOWS(wp)\n\t\t    if (wp->w_p_pvw)\n\t\t\tbreak;\n\t\tif (wp == NULL)\n\t\t    emsg(_(e_there_is_no_preview_window));\n\t\telse\n\t\t    win_goto(wp);\n\t\tbreak;\n#endif\n\n// close all but current window\n    case Ctrl_O:\n    case 'o':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"only\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// cursor to next window with wrap around\n    case Ctrl_W:\n    case 'w':\n// cursor to previous window with wrap around\n    case 'W':\n\t\tCHECK_CMDWIN;\n\t\tif (ONE_WINDOW && Prenum != 1)\t// just one window\n\t\t    beep_flush();\n\t\telse\n\t\t{\n\t\t    if (Prenum)\t\t\t// go to specified window\n\t\t    {\n\t\t\tfor (wp = firstwin; --Prenum > 0; )\n\t\t\t{\n\t\t\t    if (wp->w_next == NULL)\n\t\t\t\tbreak;\n\t\t\t    else\n\t\t\t\twp = wp->w_next;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (nchar == 'W')\t    // go to previous window\n\t\t\t{\n\t\t\t    wp = curwin->w_prev;\n\t\t\t    if (wp == NULL)\n\t\t\t\twp = lastwin;\t    // wrap around\n\t\t\t}\n\t\t\telse\t\t\t    // go to next window\n\t\t\t{\n\t\t\t    wp = curwin->w_next;\n\t\t\t    if (wp == NULL)\n\t\t\t\twp = firstwin;\t    // wrap around\n\t\t\t}\n\t\t    }\n\t\t    win_goto(wp);\n\t\t}\n\t\tbreak;\n\n// cursor to window below\n    case 'j':\n    case K_DOWN:\n    case Ctrl_J:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_ver(FALSE, Prenum1);\n\t\tbreak;\n\n// cursor to window above\n    case 'k':\n    case K_UP:\n    case Ctrl_K:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_ver(TRUE, Prenum1);\n\t\tbreak;\n\n// cursor to left window\n    case 'h':\n    case K_LEFT:\n    case Ctrl_H:\n    case K_BS:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_hor(TRUE, Prenum1);\n\t\tbreak;\n\n// cursor to right window\n    case 'l':\n    case K_RIGHT:\n    case Ctrl_L:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_hor(FALSE, Prenum1);\n\t\tbreak;\n\n// move window to new tab page\n    case 'T':\n\t\tCHECK_CMDWIN;\n\t\tif (one_window())\n\t\t    msg(_(m_onlyone));\n\t\telse\n\t\t{\n\t\t    tabpage_T\t*oldtab = curtab;\n\t\t    tabpage_T\t*newtab;\n\n\t\t    // First create a new tab with the window, then go back to\n\t\t    // the old tab and close the window there.\n\t\t    wp = curwin;\n\t\t    if (win_new_tabpage((int)Prenum) == OK\n\t\t\t\t\t\t     && valid_tabpage(oldtab))\n\t\t    {\n\t\t\tnewtab = curtab;\n\t\t\tgoto_tabpage_tp(oldtab, TRUE, TRUE);\n\t\t\tif (curwin == wp)\n\t\t\t    win_close(curwin, FALSE);\n\t\t\tif (valid_tabpage(newtab))\n\t\t\t    goto_tabpage_tp(newtab, TRUE, TRUE);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n// cursor to top-left window\n    case 't':\n    case Ctrl_T:\n\t\twin_goto(firstwin);\n\t\tbreak;\n\n// cursor to bottom-right window\n    case 'b':\n    case Ctrl_B:\n\t\twin_goto(lastwin);\n\t\tbreak;\n\n// cursor to last accessed (previous) window\n    case 'p':\n    case Ctrl_P:\n\t\tif (!win_valid(prevwin))\n\t\t    beep_flush();\n\t\telse\n\t\t    win_goto(prevwin);\n\t\tbreak;\n\n// exchange current and next window\n    case 'x':\n    case Ctrl_X:\n\t\tCHECK_CMDWIN;\n\t\twin_exchange(Prenum);\n\t\tbreak;\n\n// rotate windows downwards\n    case Ctrl_R:\n    case 'r':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\twin_rotate(FALSE, (int)Prenum1);    // downwards\n\t\tbreak;\n\n// rotate windows upwards\n    case 'R':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\twin_rotate(TRUE, (int)Prenum1);\t    // upwards\n\t\tbreak;\n\n// move window to the very top/bottom/left/right\n    case 'K':\n    case 'J':\n    case 'H':\n    case 'L':\n\t\tCHECK_CMDWIN;\n\t\twin_totop((int)Prenum,\n\t\t\t((nchar == 'H' || nchar == 'L') ? WSP_VERT : 0)\n\t\t\t| ((nchar == 'H' || nchar == 'K') ? WSP_TOP : WSP_BOT));\n\t\tbreak;\n\n// make all windows the same height\n    case '=':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_equal(NULL, FALSE, 'b');\n\t\tbreak;\n\n// increase current window height\n    case '+':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(curwin->w_height + (int)Prenum1);\n\t\tbreak;\n\n// decrease current window height\n    case '-':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(curwin->w_height - (int)Prenum1);\n\t\tbreak;\n\n// set current window height\n    case Ctrl__:\n    case '_':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(Prenum ? (int)Prenum : 9999);\n\t\tbreak;\n\n// increase current window width\n    case '>':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(curwin->w_width + (int)Prenum1);\n\t\tbreak;\n\n// decrease current window width\n    case '<':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(curwin->w_width - (int)Prenum1);\n\t\tbreak;\n\n// set current window width\n    case '|':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(Prenum != 0 ? (int)Prenum : 9999);\n\t\tbreak;\n\n// jump to tag and split window if tag exists (in preview window)\n#if defined(FEAT_QUICKFIX)\n    case '}':\n\t\tCHECK_CMDWIN;\n\t\tif (Prenum)\n\t\t    g_do_tagpreview = Prenum;\n\t\telse\n\t\t    g_do_tagpreview = p_pvh;\n#endif\n\t\t// FALLTHROUGH\n    case ']':\n    case Ctrl_RSB:\n\t\tCHECK_CMDWIN;\n\t\t// keep Visual mode, can select words to use as a tag\n\t\tif (Prenum)\n\t\t    postponed_split = Prenum;\n\t\telse\n\t\t    postponed_split = -1;\n#ifdef FEAT_QUICKFIX\n\t\tif (nchar != '}')\n\t\t    g_do_tagpreview = 0;\n#endif\n\n\t\t// Execute the command right here, required when \"wincmd ]\"\n\t\t// was used in a function.\n\t\tdo_nv_ident(Ctrl_RSB, NUL);\n\t\tbreak;\n\n#ifdef FEAT_SEARCHPATH\n// edit file name under cursor in a new window\n    case 'f':\n    case 'F':\n    case Ctrl_F:\nwingotofile:\n\t\tCHECK_CMDWIN;\n\n\t\tptr = grab_file_name(Prenum1, &lnum);\n\t\tif (ptr != NULL)\n\t\t{\n\t\t    tabpage_T\t*oldtab = curtab;\n\t\t    win_T\t*oldwin = curwin;\n# ifdef FEAT_GUI\n\t\t    need_mouse_correct = TRUE;\n# endif\n\t\t    setpcmark();\n\t\t    if (win_split(0, 0) == OK)\n\t\t    {\n\t\t\tRESET_BINDING(curwin);\n\t\t\tif (do_ecmd(0, ptr, NULL, NULL, ECMD_LASTL,\n\t\t\t\t\t\t   ECMD_HIDE, NULL) == FAIL)\n\t\t\t{\n\t\t\t    // Failed to open the file, close the window\n\t\t\t    // opened for it.\n\t\t\t    win_close(curwin, FALSE);\n\t\t\t    goto_tabpage_win(oldtab, oldwin);\n\t\t\t}\n\t\t\telse if (nchar == 'F' && lnum >= 0)\n\t\t\t{\n\t\t\t    curwin->w_cursor.lnum = lnum;\n\t\t\t    check_cursor_lnum();\n\t\t\t    beginline(BL_SOL | BL_FIX);\n\t\t\t}\n\t\t    }\n\t\t    vim_free(ptr);\n\t\t}\n\t\tbreak;\n#endif\n\n#ifdef FEAT_FIND_ID\n// Go to the first occurrence of the identifier under cursor along path in a\n// new window -- webb\n    case 'i':\t\t\t    // Go to any match\n    case Ctrl_I:\n\t\ttype = FIND_ANY;\n\t\t// FALLTHROUGH\n    case 'd':\t\t\t    // Go to definition, using 'define'\n    case Ctrl_D:\n\t\tCHECK_CMDWIN;\n\t\tif ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\t\t    break;\n\n\t\t// Make a copy, if the line was changed it will be freed.\n\t\tptr = vim_strnsave(ptr, len);\n\t\tif (ptr == NULL)\n\t\t    break;\n\n\t\tfind_pattern_in_path(ptr, 0, len, TRUE,\n\t\t\tPrenum == 0 ? TRUE : FALSE, type,\n\t\t\tPrenum1, ACTION_SPLIT, (linenr_T)1, (linenr_T)MAXLNUM);\n\t\tvim_free(ptr);\n\t\tcurwin->w_set_curswant = TRUE;\n\t\tbreak;\n#endif\n\n// Quickfix window only: view the result under the cursor in a new split.\n#if defined(FEAT_QUICKFIX)\n    case K_KENTER:\n    case CAR:\n\t\tif (bt_quickfix(curbuf))\n\t\t    qf_view_result(TRUE);\n\t\tbreak;\n#endif\n\n// CTRL-W g  extended commands\n    case 'g':\n    case Ctrl_G:\n\t\tCHECK_CMDWIN;\n#ifdef USE_ON_FLY_SCROLL\n\t\tdont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\t\t++no_mapping;\n\t\t++allow_keys;   // no mapping for xchar, but allow key codes\n\t\tif (xchar == NUL)\n\t\t    xchar = plain_vgetc();\n\t\tLANGMAP_ADJUST(xchar, TRUE);\n\t\t--no_mapping;\n\t\t--allow_keys;\n#ifdef FEAT_CMDL_INFO\n\t\t(void)add_to_showcmd(xchar);\n#endif\n\t\tswitch (xchar)\n\t\t{\n#if defined(FEAT_QUICKFIX)\n\t\t    case '}':\n\t\t\txchar = Ctrl_RSB;\n\t\t\tif (Prenum)\n\t\t\t    g_do_tagpreview = Prenum;\n\t\t\telse\n\t\t\t    g_do_tagpreview = p_pvh;\n#endif\n\t\t\t// FALLTHROUGH\n\t\t    case ']':\n\t\t    case Ctrl_RSB:\n\t\t\t// keep Visual mode, can select words to use as a tag\n\t\t\tif (Prenum)\n\t\t\t    postponed_split = Prenum;\n\t\t\telse\n\t\t\t    postponed_split = -1;\n\n\t\t\t// Execute the command right here, required when\n\t\t\t// \"wincmd g}\" was used in a function.\n\t\t\tdo_nv_ident('g', xchar);\n\t\t\tbreak;\n\n#ifdef FEAT_SEARCHPATH\n\t\t    case 'f':\t    // CTRL-W gf: \"gf\" in a new tab page\n\t\t    case 'F':\t    // CTRL-W gF: \"gF\" in a new tab page\n\t\t\tcmdmod.cmod_tab = tabpage_index(curtab) + 1;\n\t\t\tnchar = xchar;\n\t\t\tgoto wingotofile;\n#endif\n\t\t    case 't':\t    // CTRL-W gt: go to next tab page\n\t\t\tgoto_tabpage((int)Prenum);\n\t\t\tbreak;\n\n\t\t    case 'T':\t    // CTRL-W gT: go to previous tab page\n\t\t\tgoto_tabpage(-(int)Prenum1);\n\t\t\tbreak;\n\n\t\t    case TAB:\t    // CTRL-W g<Tab>: go to last used tab page\n\t\t\tif (goto_tabpage_lastused() == FAIL)\n\t\t\t    beep_flush();\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tbeep_flush();\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n    default:\tbeep_flush();\n\t\tbreak;\n    }\n}\n\n/*\n * Figure out the address type for \":wincmd\".\n */\n    void\nget_wincmd_addr_type(char_u *arg, exarg_T *eap)\n{\n    switch (*arg)\n    {\n    case 'S':\n    case Ctrl_S:\n    case 's':\n    case Ctrl_N:\n    case 'n':\n    case 'j':\n    case Ctrl_J:\n    case 'k':\n    case Ctrl_K:\n    case 'T':\n    case Ctrl_R:\n    case 'r':\n    case 'R':\n    case 'K':\n    case 'J':\n    case '+':\n    case '-':\n    case Ctrl__:\n    case '_':\n    case '|':\n    case ']':\n    case Ctrl_RSB:\n    case 'g':\n    case Ctrl_G:\n    case Ctrl_V:\n    case 'v':\n    case 'h':\n    case Ctrl_H:\n    case 'l':\n    case Ctrl_L:\n    case 'H':\n    case 'L':\n    case '>':\n    case '<':\n#if defined(FEAT_QUICKFIX)\n    case '}':\n#endif\n#ifdef FEAT_SEARCHPATH\n    case 'f':\n    case 'F':\n    case Ctrl_F:\n#endif\n#ifdef FEAT_FIND_ID\n    case 'i':\n    case Ctrl_I:\n    case 'd':\n    case Ctrl_D:\n#endif\n\t\t// window size or any count\n\t\teap->addr_type = ADDR_OTHER;\n\t\tbreak;\n\n    case Ctrl_HAT:\n    case '^':\n\t\t// buffer number\n\t\teap->addr_type = ADDR_BUFFERS;\n\t\tbreak;\n\n    case Ctrl_Q:\n    case 'q':\n    case Ctrl_C:\n    case 'c':\n    case Ctrl_O:\n    case 'o':\n    case Ctrl_W:\n    case 'w':\n    case 'W':\n    case 'x':\n    case Ctrl_X:\n\t\t// window number\n\t\teap->addr_type = ADDR_WINDOWS;\n\t\tbreak;\n\n#if defined(FEAT_QUICKFIX)\n    case Ctrl_Z:\n    case 'z':\n    case 'P':\n#endif\n    case 't':\n    case Ctrl_T:\n    case 'b':\n    case Ctrl_B:\n    case 'p':\n    case Ctrl_P:\n    case '=':\n    case CAR:\n\t\t// no count\n\t\teap->addr_type = ADDR_NONE;\n\t\tbreak;\n    }\n}\n\n    static void\ncmd_with_count(\n    char\t*cmd,\n    char_u\t*bufp,\n    size_t\tbufsize,\n    long\tPrenum)\n{\n    if (Prenum > 0)\n\tvim_snprintf((char *)bufp, bufsize, \"%s %ld\", cmd, Prenum);\n    else\n\tSTRCPY(bufp, cmd);\n}\n\n/*\n * If \"split_disallowed\" is set give an error and return FAIL.\n * Otherwise return OK.\n */\n    static int\ncheck_split_disallowed()\n{\n    if (split_disallowed > 0)\n    {\n\temsg(_(e_cant_split_window_while_closing_another));\n\treturn FAIL;\n    }\n    if (curwin->w_buffer->b_locked_split)\n    {\n\temsg(_(e_cannot_split_window_when_closing_buffer));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * split the current window, implements CTRL-W s and :split\n *\n * \"size\" is the height or width for the new window, 0 to use half of current\n * height or width.\n *\n * \"flags\":\n * WSP_ROOM: require enough room for new window\n * WSP_VERT: vertical split.\n * WSP_TOP:  open window at the top-left of the shell (help window).\n * WSP_BOT:  open window at the bottom-right of the shell (quickfix window).\n * WSP_HELP: creating the help window, keep layout snapshot\n *\n * return FAIL for failure, OK otherwise\n */\n    int\nwin_split(int size, int flags)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn FAIL;\n\n    if (check_split_disallowed() == FAIL)\n\treturn FAIL;\n\n    // When the \":tab\" modifier was used open a new tab page instead.\n    if (may_open_tabpage() == OK)\n\treturn OK;\n\n    // Add flags from \":vertical\", \":topleft\" and \":botright\".\n    flags |= cmdmod.cmod_split;\n    if ((flags & WSP_TOP) && (flags & WSP_BOT))\n    {\n\temsg(_(e_cant_split_topleft_and_botright_at_the_same_time));\n\treturn FAIL;\n    }\n\n    // When creating the help window make a snapshot of the window layout.\n    // Otherwise clear the snapshot, it's now invalid.\n    if (flags & WSP_HELP)\n\tmake_snapshot(SNAP_HELP_IDX);\n    else\n\tclear_snapshot(curtab, SNAP_HELP_IDX);\n\n    return win_split_ins(size, flags, NULL, 0);\n}\n\n/*\n * When \"new_wp\" is NULL: split the current window in two.\n * When \"new_wp\" is not NULL: insert this window at the far\n * top/left/right/bottom.\n * return FAIL for failure, OK otherwise\n */\n    int\nwin_split_ins(\n    int\t\tsize,\n    int\t\tflags,\n    win_T\t*new_wp,\n    int\t\tdir)\n{\n    win_T\t*wp = new_wp;\n    win_T\t*oldwin;\n    int\t\tnew_size = size;\n    int\t\ti;\n    int\t\tneed_status = 0;\n    int\t\tdo_equal = FALSE;\n    int\t\tneeded;\n    int\t\tavailable;\n    int\t\toldwin_height = 0;\n    int\t\tlayout;\n    frame_T\t*frp, *curfrp, *frp2, *prevfrp;\n    int\t\tbefore;\n    int\t\tminheight;\n    int\t\twmh1;\n    int\t\tdid_set_fraction = FALSE;\n\n    if (flags & WSP_TOP)\n\toldwin = firstwin;\n    else if (flags & WSP_BOT)\n\toldwin = lastwin;\n    else\n\toldwin = curwin;\n\n    // add a status line when p_ls == 1 and splitting the first window\n    if (ONE_WINDOW && p_ls == 1 && oldwin->w_status_height == 0)\n    {\n\tif (VISIBLE_HEIGHT(oldwin) <= p_wmh && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\tneed_status = STATUS_HEIGHT;\n    }\n\n#ifdef FEAT_GUI\n    // May be needed for the scrollbars that are going to change.\n    if (gui.in_use)\n\tout_flush();\n#endif\n\n    if (flags & WSP_VERT)\n    {\n\tint\twmw1;\n\tint\tminwidth;\n\n\tlayout = FR_ROW;\n\n\t/*\n\t * Check if we are able to split the current window and compute its\n\t * width.\n\t */\n\t// Current window requires at least 1 space.\n\twmw1 = (p_wmw == 0 ? 1 : p_wmw);\n\tneeded = wmw1 + 1;\n\tif (flags & WSP_ROOM)\n\t    needed += p_wiw - wmw1;\n\tif (flags & (WSP_BOT | WSP_TOP))\n\t{\n\t    minwidth = frame_minwidth(topframe, NOWIN);\n\t    available = topframe->fr_width;\n\t    needed += minwidth;\n\t}\n\telse if (p_ea)\n\t{\n\t    minwidth = frame_minwidth(oldwin->w_frame, NOWIN);\n\t    prevfrp = oldwin->w_frame;\n\t    for (frp = oldwin->w_frame->fr_parent; frp != NULL;\n\t\t\t\t\t\t\tfrp = frp->fr_parent)\n\t    {\n\t\tif (frp->fr_layout == FR_ROW)\n\t\t    FOR_ALL_FRAMES(frp2, frp->fr_child)\n\t\t\tif (frp2 != prevfrp)\n\t\t\t    minwidth += frame_minwidth(frp2, NOWIN);\n\t\tprevfrp = frp;\n\t    }\n\t    available = topframe->fr_width;\n\t    needed += minwidth;\n\t}\n\telse\n\t{\n\t    minwidth = frame_minwidth(oldwin->w_frame, NOWIN);\n\t    available = oldwin->w_frame->fr_width;\n\t    needed += minwidth;\n\t}\n\tif (available < needed && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\tif (new_size == 0)\n\t    new_size = oldwin->w_width / 2;\n\tif (new_size > available - minwidth - 1)\n\t    new_size = available - minwidth - 1;\n\tif (new_size < wmw1)\n\t    new_size = wmw1;\n\n\t// if it doesn't fit in the current window, need win_equal()\n\tif (oldwin->w_width - new_size - 1 < p_wmw)\n\t    do_equal = TRUE;\n\n\t// We don't like to take lines for the new window from a\n\t// 'winfixwidth' window.  Take them from a window to the left or right\n\t// instead, if possible. Add one for the separator.\n\tif (oldwin->w_p_wfw)\n\t    win_setwidth_win(oldwin->w_width + new_size + 1, oldwin);\n\n\t// Only make all windows the same width if one of them (except oldwin)\n\t// is wider than one of the split windows.\n\tif (!do_equal && p_ea && size == 0 && *p_ead != 'v'\n\t\t\t\t\t && oldwin->w_frame->fr_parent != NULL)\n\t{\n\t    frp = oldwin->w_frame->fr_parent->fr_child;\n\t    while (frp != NULL)\n\t    {\n\t\tif (frp->fr_win != oldwin && frp->fr_win != NULL\n\t\t\t&& (frp->fr_win->w_width > new_size\n\t\t\t    || frp->fr_win->w_width > oldwin->w_width\n\t\t\t\t\t\t\t      - new_size - 1))\n\t\t{\n\t\t    do_equal = TRUE;\n\t\t    break;\n\t\t}\n\t\tfrp = frp->fr_next;\n\t    }\n\t}\n    }\n    else\n    {\n\tlayout = FR_COL;\n\n\t/*\n\t * Check if we are able to split the current window and compute its\n\t * height.\n\t */\n\t// Current window requires at least 1 space.\n\twmh1 = (p_wmh == 0 ? 1 : p_wmh) + WINBAR_HEIGHT(curwin);\n\tneeded = wmh1 + STATUS_HEIGHT;\n\tif (flags & WSP_ROOM)\n\t    needed += p_wh - wmh1;\n\tif (flags & (WSP_BOT | WSP_TOP))\n\t{\n\t    minheight = frame_minheight(topframe, NOWIN) + need_status;\n\t    available = topframe->fr_height;\n\t    needed += minheight;\n\t}\n\telse if (p_ea)\n\t{\n\t    minheight = frame_minheight(oldwin->w_frame, NOWIN) + need_status;\n\t    prevfrp = oldwin->w_frame;\n\t    for (frp = oldwin->w_frame->fr_parent; frp != NULL;\n\t\t\t\t\t\t\tfrp = frp->fr_parent)\n\t    {\n\t\tif (frp->fr_layout == FR_COL)\n\t\t    FOR_ALL_FRAMES(frp2, frp->fr_child)\n\t\t\tif (frp2 != prevfrp)\n\t\t\t    minheight += frame_minheight(frp2, NOWIN);\n\t\tprevfrp = frp;\n\t    }\n\t    available = topframe->fr_height;\n\t    needed += minheight;\n\t}\n\telse\n\t{\n\t    minheight = frame_minheight(oldwin->w_frame, NOWIN) + need_status;\n\t    available = oldwin->w_frame->fr_height;\n\t    needed += minheight;\n\t}\n\tif (available < needed && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\toldwin_height = oldwin->w_height;\n\tif (need_status)\n\t{\n\t    oldwin->w_status_height = STATUS_HEIGHT;\n\t    oldwin_height -= STATUS_HEIGHT;\n\t}\n\tif (new_size == 0)\n\t    new_size = oldwin_height / 2;\n\tif (new_size > available - minheight - STATUS_HEIGHT)\n\t    new_size = available - minheight - STATUS_HEIGHT;\n\tif (new_size < wmh1)\n\t    new_size = wmh1;\n\n\t// if it doesn't fit in the current window, need win_equal()\n\tif (oldwin_height - new_size - STATUS_HEIGHT < p_wmh)\n\t    do_equal = TRUE;\n\n\t// We don't like to take lines for the new window from a\n\t// 'winfixheight' window.  Take them from a window above or below\n\t// instead, if possible.\n\tif (oldwin->w_p_wfh)\n\t{\n\t    // Set w_fraction now so that the cursor keeps the same relative\n\t    // vertical position using the old height.\n\t    set_fraction(oldwin);\n\t    did_set_fraction = TRUE;\n\n\t    win_setheight_win(oldwin->w_height + new_size + STATUS_HEIGHT,\n\t\t\t\t\t\t\t\t      oldwin);\n\t    oldwin_height = oldwin->w_height;\n\t    if (need_status)\n\t\toldwin_height -= STATUS_HEIGHT;\n\t}\n\n\t// Only make all windows the same height if one of them (except oldwin)\n\t// is higher than one of the split windows.\n\tif (!do_equal && p_ea && size == 0 && *p_ead != 'h'\n\t   && oldwin->w_frame->fr_parent != NULL)\n\t{\n\t    frp = oldwin->w_frame->fr_parent->fr_child;\n\t    while (frp != NULL)\n\t    {\n\t\tif (frp->fr_win != oldwin && frp->fr_win != NULL\n\t\t\t&& (frp->fr_win->w_height > new_size\n\t\t\t    || frp->fr_win->w_height > oldwin_height - new_size\n\t\t\t\t\t\t\t      - STATUS_HEIGHT))\n\t\t{\n\t\t    do_equal = TRUE;\n\t\t    break;\n\t\t}\n\t\tfrp = frp->fr_next;\n\t    }\n\t}\n    }\n\n    /*\n     * allocate new window structure and link it in the window list\n     */\n    if ((flags & WSP_TOP) == 0\n\t    && ((flags & WSP_BOT)\n\t\t|| (flags & WSP_BELOW)\n\t\t|| (!(flags & WSP_ABOVE)\n\t\t    && ( (flags & WSP_VERT) ? p_spr : p_sb))))\n    {\n\t// new window below/right of current one\n\tif (new_wp == NULL)\n\t    wp = win_alloc(oldwin, FALSE);\n\telse\n\t    win_append(oldwin, wp);\n    }\n    else\n    {\n\tif (new_wp == NULL)\n\t    wp = win_alloc(oldwin->w_prev, FALSE);\n\telse\n\t    win_append(oldwin->w_prev, wp);\n    }\n\n    if (new_wp == NULL)\n    {\n\tif (wp == NULL)\n\t    return FAIL;\n\n\tnew_frame(wp);\n\tif (wp->w_frame == NULL)\n\t{\n\t    win_free(wp, NULL);\n\t    return FAIL;\n\t}\n\n\t// make the contents of the new window the same as the current one\n\twin_init(wp, curwin, flags);\n    }\n\n    /*\n     * Reorganise the tree of frames to insert the new window.\n     */\n    if (flags & (WSP_TOP | WSP_BOT))\n    {\n\tif ((topframe->fr_layout == FR_COL && (flags & WSP_VERT) == 0)\n\t    || (topframe->fr_layout == FR_ROW && (flags & WSP_VERT) != 0))\n\t{\n\t    curfrp = topframe->fr_child;\n\t    if (flags & WSP_BOT)\n\t\twhile (curfrp->fr_next != NULL)\n\t\t    curfrp = curfrp->fr_next;\n\t}\n\telse\n\t    curfrp = topframe;\n\tbefore = (flags & WSP_TOP);\n    }\n    else\n    {\n\tcurfrp = oldwin->w_frame;\n\tif (flags & WSP_BELOW)\n\t    before = FALSE;\n\telse if (flags & WSP_ABOVE)\n\t    before = TRUE;\n\telse if (flags & WSP_VERT)\n\t    before = !p_spr;\n\telse\n\t    before = !p_sb;\n    }\n    if (curfrp->fr_parent == NULL || curfrp->fr_parent->fr_layout != layout)\n    {\n\t// Need to create a new frame in the tree to make a branch.\n\tfrp = ALLOC_CLEAR_ONE(frame_T);\n\t*frp = *curfrp;\n\tcurfrp->fr_layout = layout;\n\tfrp->fr_parent = curfrp;\n\tfrp->fr_next = NULL;\n\tfrp->fr_prev = NULL;\n\tcurfrp->fr_child = frp;\n\tcurfrp->fr_win = NULL;\n\tcurfrp = frp;\n\tif (frp->fr_win != NULL)\n\t    oldwin->w_frame = frp;\n\telse\n\t    FOR_ALL_FRAMES(frp, frp->fr_child)\n\t\tfrp->fr_parent = curfrp;\n    }\n\n    if (new_wp == NULL)\n\tfrp = wp->w_frame;\n    else\n\tfrp = new_wp->w_frame;\n    frp->fr_parent = curfrp->fr_parent;\n\n    // Insert the new frame at the right place in the frame list.\n    if (before)\n\tframe_insert(curfrp, frp);\n    else\n\tframe_append(curfrp, frp);\n\n    // Set w_fraction now so that the cursor keeps the same relative\n    // vertical position.\n    if (!did_set_fraction)\n\tset_fraction(oldwin);\n    wp->w_fraction = oldwin->w_fraction;\n\n    if (flags & WSP_VERT)\n    {\n\twp->w_p_scr = curwin->w_p_scr;\n\n\tif (need_status)\n\t{\n\t    win_new_height(oldwin, oldwin->w_height - 1);\n\t    oldwin->w_status_height = need_status;\n\t}\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    // set height and row of new window to full height\n\t    wp->w_winrow = tabline_height();\n\t    win_new_height(wp, curfrp->fr_height - (p_ls > 0)\n\t\t\t\t\t\t\t  - WINBAR_HEIGHT(wp));\n\t    wp->w_status_height = (p_ls > 0);\n\t}\n\telse\n\t{\n\t    // height and row of new window is same as current window\n\t    wp->w_winrow = oldwin->w_winrow;\n\t    win_new_height(wp, VISIBLE_HEIGHT(oldwin));\n\t    wp->w_status_height = oldwin->w_status_height;\n\t}\n\tfrp->fr_height = curfrp->fr_height;\n\n\t// \"new_size\" of the current window goes to the new window, use\n\t// one column for the vertical separator\n\twin_new_width(wp, new_size);\n\tif (before)\n\t    wp->w_vsep_width = 1;\n\telse\n\t{\n\t    wp->w_vsep_width = oldwin->w_vsep_width;\n\t    oldwin->w_vsep_width = 1;\n\t}\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    if (flags & WSP_BOT)\n\t\tframe_add_vsep(curfrp);\n\t    // Set width of neighbor frame\n\t    frame_new_width(curfrp, curfrp->fr_width\n\t\t     - (new_size + ((flags & WSP_TOP) != 0)), flags & WSP_TOP,\n\t\t\t\t\t\t\t\t       FALSE);\n\t}\n\telse\n\t    win_new_width(oldwin, oldwin->w_width - (new_size + 1));\n\tif (before)\t// new window left of current one\n\t{\n\t    wp->w_wincol = oldwin->w_wincol;\n\t    oldwin->w_wincol += new_size + 1;\n\t}\n\telse\t\t// new window right of current one\n\t    wp->w_wincol = oldwin->w_wincol + oldwin->w_width + 1;\n\tframe_fix_width(oldwin);\n\tframe_fix_width(wp);\n    }\n    else\n    {\n\t// width and column of new window is same as current window\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    wp->w_wincol = 0;\n\t    win_new_width(wp, Columns);\n\t    wp->w_vsep_width = 0;\n\t}\n\telse\n\t{\n\t    wp->w_wincol = oldwin->w_wincol;\n\t    win_new_width(wp, oldwin->w_width);\n\t    wp->w_vsep_width = oldwin->w_vsep_width;\n\t}\n\tfrp->fr_width = curfrp->fr_width;\n\n\t// \"new_size\" of the current window goes to the new window, use\n\t// one row for the status line\n\twin_new_height(wp, new_size);\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    int new_fr_height = curfrp->fr_height - new_size\n\t\t\t\t\t\t\t  + WINBAR_HEIGHT(wp) ;\n\n\t    if (!((flags & WSP_BOT) && p_ls == 0))\n\t\tnew_fr_height -= STATUS_HEIGHT;\n\t    frame_new_height(curfrp, new_fr_height, flags & WSP_TOP, FALSE);\n\t}\n\telse\n\t    win_new_height(oldwin, oldwin_height - (new_size + STATUS_HEIGHT));\n\tif (before)\t// new window above current one\n\t{\n\t    wp->w_winrow = oldwin->w_winrow;\n\t    wp->w_status_height = STATUS_HEIGHT;\n\t    oldwin->w_winrow += wp->w_height + STATUS_HEIGHT;\n\t}\n\telse\t\t// new window below current one\n\t{\n\t    wp->w_winrow = oldwin->w_winrow + VISIBLE_HEIGHT(oldwin)\n\t\t\t\t\t\t\t       + STATUS_HEIGHT;\n\t    wp->w_status_height = oldwin->w_status_height;\n\t    if (!(flags & WSP_BOT))\n\t\toldwin->w_status_height = STATUS_HEIGHT;\n\t}\n\tif (flags & WSP_BOT)\n\t    frame_add_statusline(curfrp);\n\tframe_fix_height(wp);\n\tframe_fix_height(oldwin);\n    }\n\n    if (flags & (WSP_TOP | WSP_BOT))\n\t(void)win_comp_pos();\n\n     // Both windows need redrawing.  Update all status lines, in case they\n     // show something related to the window count or position.\n    redraw_win_later(wp, NOT_VALID);\n    redraw_win_later(oldwin, NOT_VALID);\n    status_redraw_all();\n\n    if (need_status)\n    {\n\tmsg_row = Rows - 1;\n\tmsg_col = sc_col;\n\tmsg_clr_eos_force();\t// Old command/ruler may still be there\n\tcomp_col();\n\tmsg_row = Rows - 1;\n\tmsg_col = 0;\t// put position back at start of line\n    }\n\n    /*\n     * equalize the window sizes.\n     */\n    if (do_equal || dir != 0)\n\twin_equal(wp, TRUE,\n\t\t(flags & WSP_VERT) ? (dir == 'v' ? 'b' : 'h')\n\t\t: dir == 'h' ? 'b' : 'v');\n\n    // Don't change the window height/width to 'winheight' / 'winwidth' if a\n    // size was given.\n    if (flags & WSP_VERT)\n    {\n\ti = p_wiw;\n\tif (size != 0)\n\t    p_wiw = size;\n\n# ifdef FEAT_GUI\n\t// When 'guioptions' includes 'L' or 'R' may have to add scrollbars.\n\tif (gui.in_use)\n\t    gui_init_which_components(NULL);\n# endif\n    }\n    else\n    {\n\ti = p_wh;\n\tif (size != 0)\n\t    p_wh = size;\n    }\n\n    /*\n     * make the new window the current window\n     */\n    (void)win_enter_ext(wp, WEE_TRIGGER_NEW_AUTOCMDS\n\t\t    | WEE_TRIGGER_ENTER_AUTOCMDS | WEE_TRIGGER_LEAVE_AUTOCMDS);\n    if (flags & WSP_VERT)\n\tp_wiw = i;\n    else\n\tp_wh = i;\n\n    return OK;\n}\n\n\n/*\n * Initialize window \"newp\" from window \"oldp\".\n * Used when splitting a window and when creating a new tab page.\n * The windows will both edit the same buffer.\n * WSP_NEWLOC may be specified in flags to prevent the location list from\n * being copied.\n */\n    static void\nwin_init(win_T *newp, win_T *oldp, int flags UNUSED)\n{\n    int\t\ti;\n\n    newp->w_buffer = oldp->w_buffer;\n#ifdef FEAT_SYN_HL\n    newp->w_s = &(oldp->w_buffer->b_s);\n#endif\n    oldp->w_buffer->b_nwindows++;\n    newp->w_cursor = oldp->w_cursor;\n    newp->w_valid = 0;\n    newp->w_curswant = oldp->w_curswant;\n    newp->w_set_curswant = oldp->w_set_curswant;\n    newp->w_topline = oldp->w_topline;\n#ifdef FEAT_DIFF\n    newp->w_topfill = oldp->w_topfill;\n#endif\n    newp->w_leftcol = oldp->w_leftcol;\n    newp->w_pcmark = oldp->w_pcmark;\n    newp->w_prev_pcmark = oldp->w_prev_pcmark;\n    newp->w_alt_fnum = oldp->w_alt_fnum;\n    newp->w_wrow = oldp->w_wrow;\n    newp->w_fraction = oldp->w_fraction;\n    newp->w_prev_fraction_row = oldp->w_prev_fraction_row;\n    copy_jumplist(oldp, newp);\n#ifdef FEAT_QUICKFIX\n    if (flags & WSP_NEWLOC)\n    {\n\t// Don't copy the location list.\n\tnewp->w_llist = NULL;\n\tnewp->w_llist_ref = NULL;\n    }\n    else\n\tcopy_loclist_stack(oldp, newp);\n#endif\n    newp->w_localdir = (oldp->w_localdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(oldp->w_localdir);\n    newp->w_prevdir = (oldp->w_prevdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(oldp->w_prevdir);\n\n    // copy tagstack and folds\n    for (i = 0; i < oldp->w_tagstacklen; i++)\n    {\n\ttaggy_T\t*tag = &newp->w_tagstack[i];\n\t*tag = oldp->w_tagstack[i];\n\tif (tag->tagname != NULL)\n\t    tag->tagname = vim_strsave(tag->tagname);\n\tif (tag->user_data != NULL)\n\t    tag->user_data = vim_strsave(tag->user_data);\n    }\n    newp->w_tagstackidx = oldp->w_tagstackidx;\n    newp->w_tagstacklen = oldp->w_tagstacklen;\n\n    // Keep same changelist position in new window.\n    newp->w_changelistidx = oldp->w_changelistidx;\n\n#ifdef FEAT_FOLDING\n    copyFoldingState(oldp, newp);\n#endif\n\n    win_init_some(newp, oldp);\n#ifdef FEAT_TERMINAL\n    term_update_wincolor(newp);\n#endif\n}\n\n/*\n * Initialize window \"newp\" from window \"old\".\n * Only the essential things are copied.\n */\n    static void\nwin_init_some(win_T *newp, win_T *oldp)\n{\n    // Use the same argument list.\n    newp->w_alist = oldp->w_alist;\n    ++newp->w_alist->al_refcount;\n    newp->w_arg_idx = oldp->w_arg_idx;\n\n    // copy options from existing window\n    win_copy_options(oldp, newp);\n}\n\n/*\n * Return TRUE if \"win\" is a global popup or a popup in the current tab page.\n */\n    int\nwin_valid_popup(win_T *win UNUSED)\n{\n#ifdef FEAT_PROP_POPUP\n    win_T\t*wp;\n\n    FOR_ALL_POPUPWINS(wp)\n\tif (wp == win)\n\t    return TRUE;\n    FOR_ALL_POPUPWINS_IN_TAB(curtab, wp)\n\tif (wp == win)\n\t    return TRUE;\n#endif\n    return FALSE;\n}\n\n/*\n * Check if \"win\" is a pointer to an existing window in the current tab page.\n */\n    int\nwin_valid(win_T *win)\n{\n    win_T\t*wp;\n\n    if (win == NULL)\n\treturn FALSE;\n    FOR_ALL_WINDOWS(wp)\n\tif (wp == win)\n\t    return TRUE;\n    return win_valid_popup(win);\n}\n\n/*\n * Find window \"id\" in the current tab page.\n * Also find popup windows.\n * Return NULL if not found.\n */\n    win_T *\nwin_find_by_id(int id)\n{\n    win_T   *wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_id == id)\n\t    return wp;\n#ifdef FEAT_PROP_POPUP\n    FOR_ALL_POPUPWINS(wp)\n\tif (wp->w_id == id)\n\t    return wp;\n    FOR_ALL_POPUPWINS_IN_TAB(curtab, wp)\n\tif (wp->w_id == id)\n\t    return wp;\n#endif\n    return NULL;\n}\n\n/*\n * Check if \"win\" is a pointer to an existing window in any tab page.\n */\n    int\nwin_valid_any_tab(win_T *win)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    if (win == NULL)\n\treturn FALSE;\n    FOR_ALL_TABPAGES(tp)\n    {\n\tFOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t{\n\t    if (wp == win)\n\t\treturn TRUE;\n\t}\n#ifdef FEAT_PROP_POPUP\n\tFOR_ALL_POPUPWINS_IN_TAB(tp, wp)\n\t    if (wp == win)\n\t\treturn TRUE;\n#endif\n    }\n    return win_valid_popup(win);\n}\n\n/*\n * Return the number of windows.\n */\n    int\nwin_count(void)\n{\n    win_T\t*wp;\n    int\t\tcount = 0;\n\n    FOR_ALL_WINDOWS(wp)\n\t++count;\n    return count;\n}\n\n/*\n * Make \"count\" windows on the screen.\n * Return actual number of windows on the screen.\n * Must be called when there is just one window, filling the whole screen\n * (excluding the command line).\n */\n    int\nmake_windows(\n    int\t\tcount,\n    int\t\tvertical UNUSED)  // split windows vertically if TRUE\n{\n    int\t\tmaxcount;\n    int\t\ttodo;\n\n    if (vertical)\n    {\n\t// Each window needs at least 'winminwidth' lines and a separator\n\t// column.\n\tmaxcount = (curwin->w_width + curwin->w_vsep_width\n\t\t\t\t\t     - (p_wiw - p_wmw)) / (p_wmw + 1);\n    }\n    else\n    {\n\t// Each window needs at least 'winminheight' lines and a status line.\n\tmaxcount = (VISIBLE_HEIGHT(curwin) + curwin->w_status_height\n\t\t\t\t  - (p_wh - p_wmh)) / (p_wmh + STATUS_HEIGHT);\n    }\n\n    if (maxcount < 2)\n\tmaxcount = 2;\n    if (count > maxcount)\n\tcount = maxcount;\n\n    /*\n     * add status line now, otherwise first window will be too big\n     */\n    if (count > 1)\n\tlast_status(TRUE);\n\n    /*\n     * Don't execute autocommands while creating the windows.  Must do that\n     * when putting the buffers in the windows.\n     */\n    block_autocmds();\n\n    // todo is number of windows left to create\n    for (todo = count - 1; todo > 0; --todo)\n\tif (vertical)\n\t{\n\t    if (win_split(curwin->w_width - (curwin->w_width - todo)\n\t\t\t/ (todo + 1) - 1, WSP_VERT | WSP_ABOVE) == FAIL)\n\t\tbreak;\n\t}\n\telse\n\t{\n\t    if (win_split(curwin->w_height - (curwin->w_height - todo\n\t\t\t    * STATUS_HEIGHT) / (todo + 1)\n\t\t\t- STATUS_HEIGHT, WSP_ABOVE) == FAIL)\n\t\tbreak;\n\t}\n\n    unblock_autocmds();\n\n    // return actual number of windows\n    return (count - todo);\n}\n\n/*\n * Exchange current and next window\n */\n    static void\nwin_exchange(long Prenum)\n{\n    frame_T\t*frp;\n    frame_T\t*frp2;\n    win_T\t*wp;\n    win_T\t*wp2;\n    int\t\ttemp;\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (ONE_WINDOW)\t    // just one window\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * find window to exchange with\n     */\n    if (Prenum)\n    {\n\tfrp = curwin->w_frame->fr_parent->fr_child;\n\twhile (frp != NULL && --Prenum > 0)\n\t    frp = frp->fr_next;\n    }\n    else if (curwin->w_frame->fr_next != NULL)\t// Swap with next\n\tfrp = curwin->w_frame->fr_next;\n    else    // Swap last window in row/col with previous\n\tfrp = curwin->w_frame->fr_prev;\n\n    // We can only exchange a window with another window, not with a frame\n    // containing windows.\n    if (frp == NULL || frp->fr_win == NULL || frp->fr_win == curwin)\n\treturn;\n    wp = frp->fr_win;\n\n/*\n * 1. remove curwin from the list. Remember after which window it was in wp2\n * 2. insert curwin before wp in the list\n * if wp != wp2\n *    3. remove wp from the list\n *    4. insert wp after wp2\n * 5. exchange the status line height and vsep width.\n */\n    wp2 = curwin->w_prev;\n    frp2 = curwin->w_frame->fr_prev;\n    if (wp->w_prev != curwin)\n    {\n\twin_remove(curwin, NULL);\n\tframe_remove(curwin->w_frame);\n\twin_append(wp->w_prev, curwin);\n\tframe_insert(frp, curwin->w_frame);\n    }\n    if (wp != wp2)\n    {\n\twin_remove(wp, NULL);\n\tframe_remove(wp->w_frame);\n\twin_append(wp2, wp);\n\tif (frp2 == NULL)\n\t    frame_insert(wp->w_frame->fr_parent->fr_child, wp->w_frame);\n\telse\n\t    frame_append(frp2, wp->w_frame);\n    }\n    temp = curwin->w_status_height;\n    curwin->w_status_height = wp->w_status_height;\n    wp->w_status_height = temp;\n    temp = curwin->w_vsep_width;\n    curwin->w_vsep_width = wp->w_vsep_width;\n    wp->w_vsep_width = temp;\n\n    frame_fix_height(curwin);\n    frame_fix_height(wp);\n    frame_fix_width(curwin);\n    frame_fix_width(wp);\n\n    (void)win_comp_pos();\t\t// recompute window positions\n\n    if (wp->w_buffer != curbuf)\n\treset_VIsual_and_resel();\n    else if (VIsual_active)\n\twp->w_cursor = curwin->w_cursor;\n\n    win_enter(wp, TRUE);\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * rotate windows: if upwards TRUE the second window becomes the first one\n *\t\t   if upwards FALSE the first window becomes the second one\n */\n    static void\nwin_rotate(int upwards, int count)\n{\n    win_T\t*wp1;\n    win_T\t*wp2;\n    frame_T\t*frp;\n    int\t\tn;\n\n    if (ONE_WINDOW)\t\t// nothing to do\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    // Check if all frames in this row/col have one window.\n    FOR_ALL_FRAMES(frp, curwin->w_frame->fr_parent->fr_child)\n\tif (frp->fr_win == NULL)\n\t{\n\t    emsg(_(e_cannot_rotate_when_another_window_is_split));\n\t    return;\n\t}\n\n    while (count--)\n    {\n\tif (upwards)\t\t// first window becomes last window\n\t{\n\t    // remove first window/frame from the list\n\t    frp = curwin->w_frame->fr_parent->fr_child;\n\t    wp1 = frp->fr_win;\n\t    win_remove(wp1, NULL);\n\t    frame_remove(frp);\n\n\t    // find last frame and append removed window/frame after it\n\t    for ( ; frp->fr_next != NULL; frp = frp->fr_next)\n\t\t;\n\t    win_append(frp->fr_win, wp1);\n\t    frame_append(frp, wp1->w_frame);\n\n\t    wp2 = frp->fr_win;\t\t// previously last window\n\t}\n\telse\t\t\t// last window becomes first window\n\t{\n\t    // find last window/frame in the list and remove it\n\t    for (frp = curwin->w_frame; frp->fr_next != NULL;\n\t\t\t\t\t\t\t   frp = frp->fr_next)\n\t\t;\n\t    wp1 = frp->fr_win;\n\t    wp2 = wp1->w_prev;\t\t    // will become last window\n\t    win_remove(wp1, NULL);\n\t    frame_remove(frp);\n\n\t    // append the removed window/frame before the first in the list\n\t    win_append(frp->fr_parent->fr_child->fr_win->w_prev, wp1);\n\t    frame_insert(frp->fr_parent->fr_child, frp);\n\t}\n\n\t// exchange status height and vsep width of old and new last window\n\tn = wp2->w_status_height;\n\twp2->w_status_height = wp1->w_status_height;\n\twp1->w_status_height = n;\n\tframe_fix_height(wp1);\n\tframe_fix_height(wp2);\n\tn = wp2->w_vsep_width;\n\twp2->w_vsep_width = wp1->w_vsep_width;\n\twp1->w_vsep_width = n;\n\tframe_fix_width(wp1);\n\tframe_fix_width(wp2);\n\n\t// recompute w_winrow and w_wincol for all windows\n\t(void)win_comp_pos();\n    }\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Move the current window to the very top/bottom/left/right of the screen.\n */\n    static void\nwin_totop(int size, int flags)\n{\n    int\t\tdir;\n    int\t\theight = curwin->w_height;\n\n    if (ONE_WINDOW)\n    {\n\tbeep_flush();\n\treturn;\n    }\n    if (check_split_disallowed() == FAIL)\n\treturn;\n\n    // Remove the window and frame from the tree of frames.\n    (void)winframe_remove(curwin, &dir, NULL);\n    win_remove(curwin, NULL);\n    last_status(FALSE);\t    // may need to remove last status line\n    (void)win_comp_pos();   // recompute window positions\n\n    // Split a window on the desired side and put the window there.\n    (void)win_split_ins(size, flags, curwin, dir);\n    if (!(flags & WSP_VERT))\n    {\n\twin_setheight(height);\n\tif (p_ea)\n\t    win_equal(curwin, TRUE, 'v');\n    }\n\n#if defined(FEAT_GUI)\n    // When 'guioptions' includes 'L' or 'R' may have to remove or add\n    // scrollbars.  Have to update them anyway.\n    gui_may_update_scrollbars();\n#endif\n}\n\n/*\n * Move window \"win1\" to below/right of \"win2\" and make \"win1\" the current\n * window.  Only works within the same frame!\n */\n    void\nwin_move_after(win_T *win1, win_T *win2)\n{\n    int\t\theight;\n\n    // check if the arguments are reasonable\n    if (win1 == win2)\n\treturn;\n\n    // check if there is something to do\n    if (win2->w_next != win1)\n    {\n\tif (win1->w_frame->fr_parent != win2->w_frame->fr_parent)\n\t{\n\t    iemsg(\"INTERNAL: trying to move a window into another frame\");\n\t    return;\n\t}\n\n\t// may need to move the status line/vertical separator of the last\n\t// window\n\tif (win1 == lastwin)\n\t{\n\t    height = win1->w_prev->w_status_height;\n\t    win1->w_prev->w_status_height = win1->w_status_height;\n\t    win1->w_status_height = height;\n\t    if (win1->w_prev->w_vsep_width == 1)\n\t    {\n\t\t// Remove the vertical separator from the last-but-one window,\n\t\t// add it to the last window.  Adjust the frame widths.\n\t\twin1->w_prev->w_vsep_width = 0;\n\t\twin1->w_prev->w_frame->fr_width -= 1;\n\t\twin1->w_vsep_width = 1;\n\t\twin1->w_frame->fr_width += 1;\n\t    }\n\t}\n\telse if (win2 == lastwin)\n\t{\n\t    height = win1->w_status_height;\n\t    win1->w_status_height = win2->w_status_height;\n\t    win2->w_status_height = height;\n\t    if (win1->w_vsep_width == 1)\n\t    {\n\t\t// Remove the vertical separator from win1, add it to the last\n\t\t// window, win2.  Adjust the frame widths.\n\t\twin2->w_vsep_width = 1;\n\t\twin2->w_frame->fr_width += 1;\n\t\twin1->w_vsep_width = 0;\n\t\twin1->w_frame->fr_width -= 1;\n\t    }\n\t}\n\twin_remove(win1, NULL);\n\tframe_remove(win1->w_frame);\n\twin_append(win2, win1);\n\tframe_append(win2->w_frame, win1->w_frame);\n\n\t(void)win_comp_pos();\t// recompute w_winrow for all windows\n\tredraw_later(NOT_VALID);\n    }\n    win_enter(win1, FALSE);\n}\n\n/*\n * Make all windows the same height.\n * 'next_curwin' will soon be the current window, make sure it has enough\n * rows.\n */\n    void\nwin_equal(\n    win_T\t*next_curwin,\t// pointer to current window to be or NULL\n    int\t\tcurrent,\t// do only frame with current window\n    int\t\tdir)\t\t// 'v' for vertically, 'h' for horizontally,\n\t\t\t\t// 'b' for both, 0 for using p_ead\n{\n    if (dir == 0)\n\tdir = *p_ead;\n    win_equal_rec(next_curwin == NULL ? curwin : next_curwin, current,\n\t\t      topframe, dir, 0, tabline_height(),\n\t\t\t\t\t   (int)Columns, topframe->fr_height);\n}\n\n/*\n * Set a frame to a new position and height, spreading the available room\n * equally over contained frames.\n * The window \"next_curwin\" (if not NULL) should at least get the size from\n * 'winheight' and 'winwidth' if possible.\n */\n    static void\nwin_equal_rec(\n    win_T\t*next_curwin,\t// pointer to current window to be or NULL\n    int\t\tcurrent,\t// do only frame with current window\n    frame_T\t*topfr,\t\t// frame to set size off\n    int\t\tdir,\t\t// 'v', 'h' or 'b', see win_equal()\n    int\t\tcol,\t\t// horizontal position for frame\n    int\t\trow,\t\t// vertical position for frame\n    int\t\twidth,\t\t// new width of frame\n    int\t\theight)\t\t// new height of frame\n{\n    int\t\tn, m;\n    int\t\textra_sep = 0;\n    int\t\twincount, totwincount = 0;\n    frame_T\t*fr;\n    int\t\tnext_curwin_size = 0;\n    int\t\troom = 0;\n    int\t\tnew_size;\n    int\t\thas_next_curwin = 0;\n    int\t\thnc;\n\n    if (topfr->fr_layout == FR_LEAF)\n    {\n\t// Set the width/height of this frame.\n\t// Redraw when size or position changes\n\tif (topfr->fr_height != height || topfr->fr_win->w_winrow != row\n\t\t|| topfr->fr_width != width || topfr->fr_win->w_wincol != col\n\t   )\n\t{\n\t    topfr->fr_win->w_winrow = row;\n\t    frame_new_height(topfr, height, FALSE, FALSE);\n\t    topfr->fr_win->w_wincol = col;\n\t    frame_new_width(topfr, width, FALSE, FALSE);\n\t    redraw_all_later(NOT_VALID);\n\t}\n    }\n    else if (topfr->fr_layout == FR_ROW)\n    {\n\ttopfr->fr_width = width;\n\ttopfr->fr_height = height;\n\n\tif (dir != 'v')\t\t\t// equalize frame widths\n\t{\n\t    // Compute the maximum number of windows horizontally in this\n\t    // frame.\n\t    n = frame_minwidth(topfr, NOWIN);\n\t    // add one for the rightmost window, it doesn't have a separator\n\t    if (col + width == Columns)\n\t\textra_sep = 1;\n\t    else\n\t\textra_sep = 0;\n\t    totwincount = (n + extra_sep) / (p_wmw + 1);\n\t    has_next_curwin = frame_has_win(topfr, next_curwin);\n\n\t    /*\n\t     * Compute width for \"next_curwin\" window and room available for\n\t     * other windows.\n\t     * \"m\" is the minimal width when counting p_wiw for \"next_curwin\".\n\t     */\n\t    m = frame_minwidth(topfr, next_curwin);\n\t    room = width - m;\n\t    if (room < 0)\n\t    {\n\t\tnext_curwin_size = p_wiw + room;\n\t\troom = 0;\n\t    }\n\t    else\n\t    {\n\t\tnext_curwin_size = -1;\n\t\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t\t{\n\t\t    // If 'winfixwidth' set keep the window width if\n\t\t    // possible.\n\t\t    // Watch out for this window being the next_curwin.\n\t\t    if (frame_fixed_width(fr))\n\t\t    {\n\t\t\tn = frame_minwidth(fr, NOWIN);\n\t\t\tnew_size = fr->fr_width;\n\t\t\tif (frame_has_win(fr, next_curwin))\n\t\t\t{\n\t\t\t    room += p_wiw - p_wmw;\n\t\t\t    next_curwin_size = 0;\n\t\t\t    if (new_size < p_wiw)\n\t\t\t\tnew_size = p_wiw;\n\t\t\t}\n\t\t\telse\n\t\t\t    // These windows don't use up room.\n\t\t\t    totwincount -= (n + (fr->fr_next == NULL\n\t\t\t\t\t      ? extra_sep : 0)) / (p_wmw + 1);\n\t\t\troom -= new_size - n;\n\t\t\tif (room < 0)\n\t\t\t{\n\t\t\t    new_size += room;\n\t\t\t    room = 0;\n\t\t\t}\n\t\t\tfr->fr_newwidth = new_size;\n\t\t    }\n\t\t}\n\t\tif (next_curwin_size == -1)\n\t\t{\n\t\t    if (!has_next_curwin)\n\t\t\tnext_curwin_size = 0;\n\t\t    else if (totwincount > 1\n\t\t\t    && (room + (totwincount - 2))\n\t\t\t\t\t\t  / (totwincount - 1) > p_wiw)\n\t\t    {\n\t\t\t// Can make all windows wider than 'winwidth', spread\n\t\t\t// the room equally.\n\t\t\tnext_curwin_size = (room + p_wiw\n\t\t\t\t\t    + (totwincount - 1) * p_wmw\n\t\t\t\t\t    + (totwincount - 1)) / totwincount;\n\t\t\troom -= next_curwin_size - p_wiw;\n\t\t    }\n\t\t    else\n\t\t\tnext_curwin_size = p_wiw;\n\t\t}\n\t    }\n\n\t    if (has_next_curwin)\n\t\t--totwincount;\t\t// don't count curwin\n\t}\n\n\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t{\n\t    wincount = 1;\n\t    if (fr->fr_next == NULL)\n\t\t// last frame gets all that remains (avoid roundoff error)\n\t\tnew_size = width;\n\t    else if (dir == 'v')\n\t\tnew_size = fr->fr_width;\n\t    else if (frame_fixed_width(fr))\n\t    {\n\t\tnew_size = fr->fr_newwidth;\n\t\twincount = 0;\t    // doesn't count as a sizeable window\n\t    }\n\t    else\n\t    {\n\t\t// Compute the maximum number of windows horiz. in \"fr\".\n\t\tn = frame_minwidth(fr, NOWIN);\n\t\twincount = (n + (fr->fr_next == NULL ? extra_sep : 0))\n\t\t\t\t\t\t\t\t/ (p_wmw + 1);\n\t\tm = frame_minwidth(fr, next_curwin);\n\t\tif (has_next_curwin)\n\t\t    hnc = frame_has_win(fr, next_curwin);\n\t\telse\n\t\t    hnc = FALSE;\n\t\tif (hnc)\t    // don't count next_curwin\n\t\t    --wincount;\n\t\tif (totwincount == 0)\n\t\t    new_size = room;\n\t\telse\n\t\t    new_size = (wincount * room + ((unsigned)totwincount >> 1))\n\t\t\t\t\t\t\t\t/ totwincount;\n\t\tif (hnc)\t    // add next_curwin size\n\t\t{\n\t\t    next_curwin_size -= p_wiw - (m - n);\n\t\t    new_size += next_curwin_size;\n\t\t    room -= new_size - next_curwin_size;\n\t\t}\n\t\telse\n\t\t    room -= new_size;\n\t\tnew_size += n;\n\t    }\n\n\t    // Skip frame that is full width when splitting or closing a\n\t    // window, unless equalizing all frames.\n\t    if (!current || dir != 'v' || topfr->fr_parent != NULL\n\t\t    || (new_size != fr->fr_width)\n\t\t    || frame_has_win(fr, next_curwin))\n\t\twin_equal_rec(next_curwin, current, fr, dir, col, row,\n\t\t\t\t\t\t\t    new_size, height);\n\t    col += new_size;\n\t    width -= new_size;\n\t    totwincount -= wincount;\n\t}\n    }\n    else // topfr->fr_layout == FR_COL\n    {\n\ttopfr->fr_width = width;\n\ttopfr->fr_height = height;\n\n\tif (dir != 'h')\t\t\t// equalize frame heights\n\t{\n\t    // Compute maximum number of windows vertically in this frame.\n\t    n = frame_minheight(topfr, NOWIN);\n\t    // add one for the bottom window if it doesn't have a statusline\n\t    if (row + height == cmdline_row && p_ls == 0)\n\t\textra_sep = 1;\n\t    else\n\t\textra_sep = 0;\n\t    totwincount = (n + extra_sep) / (p_wmh + 1);\n\t    has_next_curwin = frame_has_win(topfr, next_curwin);\n\n\t    /*\n\t     * Compute height for \"next_curwin\" window and room available for\n\t     * other windows.\n\t     * \"m\" is the minimal height when counting p_wh for \"next_curwin\".\n\t     */\n\t    m = frame_minheight(topfr, next_curwin);\n\t    room = height - m;\n\t    if (room < 0)\n\t    {\n\t\t// The room is less than 'winheight', use all space for the\n\t\t// current window.\n\t\tnext_curwin_size = p_wh + room;\n\t\troom = 0;\n\t    }\n\t    else\n\t    {\n\t\tnext_curwin_size = -1;\n\t\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t\t{\n\t\t    // If 'winfixheight' set keep the window height if\n\t\t    // possible.\n\t\t    // Watch out for this window being the next_curwin.\n\t\t    if (frame_fixed_height(fr))\n\t\t    {\n\t\t\tn = frame_minheight(fr, NOWIN);\n\t\t\tnew_size = fr->fr_height;\n\t\t\tif (frame_has_win(fr, next_curwin))\n\t\t\t{\n\t\t\t    room += p_wh - p_wmh;\n\t\t\t    next_curwin_size = 0;\n\t\t\t    if (new_size < p_wh)\n\t\t\t\tnew_size = p_wh;\n\t\t\t}\n\t\t\telse\n\t\t\t    // These windows don't use up room.\n\t\t\t    totwincount -= (n + (fr->fr_next == NULL\n\t\t\t\t\t      ? extra_sep : 0)) / (p_wmh + 1);\n\t\t\troom -= new_size - n;\n\t\t\tif (room < 0)\n\t\t\t{\n\t\t\t    new_size += room;\n\t\t\t    room = 0;\n\t\t\t}\n\t\t\tfr->fr_newheight = new_size;\n\t\t    }\n\t\t}\n\t\tif (next_curwin_size == -1)\n\t\t{\n\t\t    if (!has_next_curwin)\n\t\t\tnext_curwin_size = 0;\n\t\t    else if (totwincount > 1\n\t\t\t    && (room + (totwincount - 2))\n\t\t\t\t\t\t   / (totwincount - 1) > p_wh)\n\t\t    {\n\t\t\t// can make all windows higher than 'winheight',\n\t\t\t// spread the room equally.\n\t\t\tnext_curwin_size = (room + p_wh\n\t\t\t\t\t   + (totwincount - 1) * p_wmh\n\t\t\t\t\t   + (totwincount - 1)) / totwincount;\n\t\t\troom -= next_curwin_size - p_wh;\n\t\t    }\n\t\t    else\n\t\t\tnext_curwin_size = p_wh;\n\t\t}\n\t    }\n\n\t    if (has_next_curwin)\n\t\t--totwincount;\t\t// don't count curwin\n\t}\n\n\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t{\n\t    wincount = 1;\n\t    if (fr->fr_next == NULL)\n\t\t// last frame gets all that remains (avoid roundoff error)\n\t\tnew_size = height;\n\t    else if (dir == 'h')\n\t\tnew_size = fr->fr_height;\n\t    else if (frame_fixed_height(fr))\n\t    {\n\t\tnew_size = fr->fr_newheight;\n\t\twincount = 0;\t    // doesn't count as a sizeable window\n\t    }\n\t    else\n\t    {\n\t\t// Compute the maximum number of windows vert. in \"fr\".\n\t\tn = frame_minheight(fr, NOWIN);\n\t\twincount = (n + (fr->fr_next == NULL ? extra_sep : 0))\n\t\t\t\t\t\t\t\t/ (p_wmh + 1);\n\t\tm = frame_minheight(fr, next_curwin);\n\t\tif (has_next_curwin)\n\t\t    hnc = frame_has_win(fr, next_curwin);\n\t\telse\n\t\t    hnc = FALSE;\n\t\tif (hnc)\t    // don't count next_curwin\n\t\t    --wincount;\n\t\tif (totwincount == 0)\n\t\t    new_size = room;\n\t\telse\n\t\t    new_size = (wincount * room + ((unsigned)totwincount >> 1))\n\t\t\t\t\t\t\t\t/ totwincount;\n\t\tif (hnc)\t    // add next_curwin size\n\t\t{\n\t\t    next_curwin_size -= p_wh - (m - n);\n\t\t    new_size += next_curwin_size;\n\t\t    room -= new_size - next_curwin_size;\n\t\t}\n\t\telse\n\t\t    room -= new_size;\n\t\tnew_size += n;\n\t    }\n\t    // Skip frame that is full width when splitting or closing a\n\t    // window, unless equalizing all frames.\n\t    if (!current || dir != 'h' || topfr->fr_parent != NULL\n\t\t    || (new_size != fr->fr_height)\n\t\t    || frame_has_win(fr, next_curwin))\n\t\twin_equal_rec(next_curwin, current, fr, dir, col, row,\n\t\t\t\t\t\t\t     width, new_size);\n\t    row += new_size;\n\t    height -= new_size;\n\t    totwincount -= wincount;\n\t}\n    }\n}\n\n#ifdef FEAT_JOB_CHANNEL\n    static void\nleaving_window(win_T *win)\n{\n    // Only matters for a prompt window.\n    if (!bt_prompt(win->w_buffer))\n\treturn;\n\n    // When leaving a prompt window stop Insert mode and perhaps restart\n    // it when entering that window again.\n    win->w_buffer->b_prompt_insert = restart_edit;\n    if (restart_edit != 0 && mode_displayed)\n\tclear_cmdline = TRUE;\t\t// unshow mode later\n    restart_edit = NUL;\n\n    // When leaving the window (or closing the window) was done from a\n    // callback we need to break out of the Insert mode loop and restart Insert\n    // mode when entering the window again.\n    if (State & MODE_INSERT)\n    {\n\tstop_insert_mode = TRUE;\n\tif (win->w_buffer->b_prompt_insert == NUL)\n\t    win->w_buffer->b_prompt_insert = 'A';\n    }\n}\n\n    void\nentering_window(win_T *win)\n{\n    // Only matters for a prompt window.\n    if (!bt_prompt(win->w_buffer))\n\treturn;\n\n    // When switching to a prompt buffer that was in Insert mode, don't stop\n    // Insert mode, it may have been set in leaving_window().\n    if (win->w_buffer->b_prompt_insert != NUL)\n\tstop_insert_mode = FALSE;\n\n    // When entering the prompt window restart Insert mode if we were in Insert\n    // mode when we left it and not already in Insert mode.\n    if ((State & MODE_INSERT) == 0)\n\trestart_edit = win->w_buffer->b_prompt_insert;\n}\n#endif\n\n    static void\nwin_init_empty(win_T *wp)\n{\n    redraw_win_later(wp, NOT_VALID);\n    wp->w_lines_valid = 0;\n    wp->w_cursor.lnum = 1;\n    wp->w_curswant = wp->w_cursor.col = 0;\n    wp->w_cursor.coladd = 0;\n    wp->w_pcmark.lnum = 1;\t// pcmark not cleared but set to line 1\n    wp->w_pcmark.col = 0;\n    wp->w_prev_pcmark.lnum = 0;\n    wp->w_prev_pcmark.col = 0;\n    wp->w_topline = 1;\n#ifdef FEAT_DIFF\n    wp->w_topfill = 0;\n#endif\n    wp->w_botline = 2;\n#if defined(FEAT_SYN_HL) || defined(FEAT_SPELL)\n    wp->w_s = &wp->w_buffer->b_s;\n#endif\n#ifdef FEAT_TERMINAL\n    term_reset_wincolor(wp);\n#endif\n}\n\n/*\n * Init the current window \"curwin\".\n * Called when a new file is being edited.\n */\n    void\ncurwin_init(void)\n{\n    win_init_empty(curwin);\n}\n\n/*\n * Close all windows for buffer \"buf\".\n */\n    void\nclose_windows(\n    buf_T\t*buf,\n    int\t\tkeep_curwin)\t    // don't close \"curwin\"\n{\n    win_T\t*wp;\n    tabpage_T   *tp, *nexttp;\n    int\t\th = tabline_height();\n    int\t\tcount = tabpage_index(NULL);\n\n    ++RedrawingDisabled;\n\n    for (wp = firstwin; wp != NULL && !ONE_WINDOW; )\n    {\n\tif (wp->w_buffer == buf && (!keep_curwin || wp != curwin)\n\t\t&& !(wp->w_closing || wp->w_buffer->b_locked > 0))\n\t{\n\t    if (win_close(wp, FALSE) == FAIL)\n\t\t// If closing the window fails give up, to avoid looping\n\t\t// forever.\n\t\tbreak;\n\n\t    // Start all over, autocommands may change the window layout.\n\t    wp = firstwin;\n\t}\n\telse\n\t    wp = wp->w_next;\n    }\n\n    // Also check windows in other tab pages.\n    for (tp = first_tabpage; tp != NULL; tp = nexttp)\n    {\n\tnexttp = tp->tp_next;\n\tif (tp != curtab)\n\t    FOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t\tif (wp->w_buffer == buf\n\t\t    && !(wp->w_closing || wp->w_buffer->b_locked > 0))\n\t\t{\n\t\t    win_close_othertab(wp, FALSE, tp);\n\n\t\t    // Start all over, the tab page may be closed and\n\t\t    // autocommands may change the window layout.\n\t\t    nexttp = first_tabpage;\n\t\t    break;\n\t\t}\n    }\n\n    --RedrawingDisabled;\n\n    if (count != tabpage_index(NULL))\n\tapply_autocmds(EVENT_TABCLOSED, NULL, NULL, FALSE, curbuf);\n\n    redraw_tabline = TRUE;\n    if (h != tabline_height())\n\tshell_new_rows();\n}\n\n/*\n * Return TRUE if the current window is the only window that exists (ignoring\n * \"aucmd_win\").\n * Returns FALSE if there is a window, possibly in another tab page.\n */\n    static int\nlast_window(void)\n{\n    return (one_window() && first_tabpage->tp_next == NULL);\n}\n\n/*\n * Return TRUE if there is only one window other than \"aucmd_win\" in the\n * current tab page.\n */\n    int\none_window(void)\n{\n    win_T\t*wp;\n    int\t\tseen_one = FALSE;\n\n    FOR_ALL_WINDOWS(wp)\n    {\n\tif (wp != aucmd_win)\n\t{\n\t    if (seen_one)\n\t\treturn FALSE;\n\t    seen_one = TRUE;\n\t}\n    }\n    return TRUE;\n}\n\n/*\n * Close the possibly last window in a tab page.\n * Returns TRUE when the window was closed already.\n */\n    static int\nclose_last_window_tabpage(\n    win_T\t*win,\n    int\t\tfree_buf,\n    tabpage_T   *prev_curtab)\n{\n    if (ONE_WINDOW)\n    {\n\tbuf_T\t*old_curbuf = curbuf;\n\n\t/*\n\t * Closing the last window in a tab page.  First go to another tab\n\t * page and then close the window and the tab page.  This avoids that\n\t * curwin and curtab are invalid while we are freeing memory, they may\n\t * be used in GUI events.\n\t * Don't trigger autocommands yet, they may use wrong values, so do\n\t * that below.\n\t */\n\tgoto_tabpage_tp(alt_tabpage(), FALSE, TRUE);\n\tredraw_tabline = TRUE;\n\n\t// Safety check: Autocommands may have closed the window when jumping\n\t// to the other tab page.\n\tif (valid_tabpage(prev_curtab) && prev_curtab->tp_firstwin == win)\n\t{\n\t    int\t    h = tabline_height();\n\n\t    win_close_othertab(win, free_buf, prev_curtab);\n\t    if (h != tabline_height())\n\t\tshell_new_rows();\n\t}\n#ifdef FEAT_JOB_CHANNEL\n\tentering_window(curwin);\n#endif\n\t// Since goto_tabpage_tp above did not trigger *Enter autocommands, do\n\t// that now.\n\tapply_autocmds(EVENT_TABCLOSED, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\tif (old_curbuf != curbuf)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Close the buffer of \"win\" and unload it if \"action\" is DOBUF_UNLOAD.\n * \"action\" can also be zero (do nothing) or DOBUF_WIPE.\n * \"abort_if_last\" is passed to close_buffer(): abort closing if all other\n * windows are closed.\n */\n    static void\nwin_close_buffer(win_T *win, int action, int abort_if_last)\n{\n#ifdef FEAT_SYN_HL\n    // Free independent synblock before the buffer is freed.\n    if (win->w_buffer != NULL)\n\treset_synblock(win);\n#endif\n\n#ifdef FEAT_QUICKFIX\n    // When a quickfix/location list window is closed and the buffer is\n    // displayed in only one window, then unlist the buffer.\n    if (win->w_buffer != NULL && bt_quickfix(win->w_buffer)\n\t\t\t\t\t&& win->w_buffer->b_nwindows == 1)\n\twin->w_buffer->b_p_bl = FALSE;\n#endif\n\n    // Close the link to the buffer.\n    if (win->w_buffer != NULL)\n    {\n\tbufref_T    bufref;\n\n\tset_bufref(&bufref, curbuf);\n\twin->w_closing = TRUE;\n\tclose_buffer(win, win->w_buffer, action, abort_if_last, TRUE);\n\tif (win_valid_any_tab(win))\n\t    win->w_closing = FALSE;\n\t// Make sure curbuf is valid. It can become invalid if 'bufhidden' is\n\t// \"wipe\".\n\tif (!bufref_valid(&bufref))\n\t    curbuf = firstbuf;\n    }\n}\n\n/*\n * Close window \"win\".  Only works for the current tab page.\n * If \"free_buf\" is TRUE related buffer may be unloaded.\n *\n * Called by :quit, :close, :xit, :wq and findtag().\n * Returns FAIL when the window was not closed.\n */\n    int\nwin_close(win_T *win, int free_buf)\n{\n    win_T\t*wp;\n    int\t\tother_buffer = FALSE;\n    int\t\tclose_curwin = FALSE;\n    int\t\tdir;\n    int\t\thelp_window = FALSE;\n    tabpage_T   *prev_curtab = curtab;\n    frame_T\t*win_frame = win->w_frame->fr_parent;\n#ifdef FEAT_DIFF\n    int\t\thad_diffmode = win->w_p_diff;\n#endif\n#ifdef MESSAGE_QUEUE\n    int\t\tdid_decrement = FALSE;\n#endif\n\n#if defined(FEAT_TERMINAL) && defined(FEAT_PROP_POPUP)\n    // Can close a popup window with a terminal if the job has finished.\n    if (may_close_term_popup() == OK)\n\treturn OK;\n#endif\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn FAIL;\n\n    if (last_window())\n    {\n\temsg(_(e_cannot_close_last_window));\n\treturn FAIL;\n    }\n\n    if (win->w_closing || (win->w_buffer != NULL\n\t\t\t\t\t       && win->w_buffer->b_locked > 0))\n\treturn FAIL; // window is already being closed\n    if (win_unlisted(win))\n    {\n\temsg(_(e_cannot_close_autocmd_or_popup_window));\n\treturn FAIL;\n    }\n    if ((firstwin == aucmd_win || lastwin == aucmd_win) && one_window())\n    {\n\temsg(_(e_cannot_close_window_only_autocmd_window_would_remain));\n\treturn FAIL;\n    }\n\n    // When closing the last window in a tab page first go to another tab page\n    // and then close the window and the tab page to avoid that curwin and\n    // curtab are invalid while we are freeing memory.\n    if (close_last_window_tabpage(win, free_buf, prev_curtab))\n      return FAIL;\n\n    // When closing the help window, try restoring a snapshot after closing\n    // the window.  Otherwise clear the snapshot, it's now invalid.\n    if (bt_help(win->w_buffer))\n\thelp_window = TRUE;\n    else\n\tclear_snapshot(curtab, SNAP_HELP_IDX);\n\n    if (win == curwin)\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tleaving_window(curwin);\n#endif\n\t/*\n\t * Guess which window is going to be the new current window.\n\t * This may change because of the autocommands (sigh).\n\t */\n\twp = frame2win(win_altframe(win, NULL));\n\n\t/*\n\t * Be careful: If autocommands delete the window or cause this window\n\t * to be the last one left, return now.\n\t */\n\tif (wp->w_buffer != curbuf)\n\t{\n\t    other_buffer = TRUE;\n\t    win->w_closing = TRUE;\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    if (!win_valid(win))\n\t\treturn FAIL;\n\t    win->w_closing = FALSE;\n\t    if (last_window())\n\t\treturn FAIL;\n\t}\n\twin->w_closing = TRUE;\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (!win_valid(win))\n\t    return FAIL;\n\twin->w_closing = FALSE;\n\tif (last_window())\n\t    return FAIL;\n#ifdef FEAT_EVAL\n\t// autocmds may abort script processing\n\tif (aborting())\n\t    return FAIL;\n#endif\n    }\n\n#ifdef FEAT_GUI\n    // Avoid trouble with scrollbars that are going to be deleted in\n    // win_free().\n    if (gui.in_use)\n\tout_flush();\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    if (popup_win_closed(win) && !win_valid(win))\n\treturn FAIL;\n#endif\n\n    // Trigger WinClosed just before starting to free window-related resources.\n    trigger_winclosed(win);\n    // autocmd may have freed the window already.\n    if (!win_valid_any_tab(win))\n\treturn OK;\n\n    win_close_buffer(win, free_buf ? DOBUF_UNLOAD : 0, TRUE);\n\n    if (only_one_window() && win_valid(win) && win->w_buffer == NULL\n\t    && (last_window() || curtab != prev_curtab\n\t\t|| close_last_window_tabpage(win, free_buf, prev_curtab)))\n    {\n\t// Autocommands have closed all windows, quit now.  Restore\n\t// curwin->w_buffer, otherwise writing viminfo may fail.\n\tif (curwin->w_buffer == NULL)\n\t    curwin->w_buffer = curbuf;\n\tgetout(0);\n    }\n\n    // Autocommands may have moved to another tab page.\n    if (curtab != prev_curtab && win_valid_any_tab(win)\n\t\t\t\t\t\t      && win->w_buffer == NULL)\n    {\n\t// Need to close the window anyway, since the buffer is NULL.\n\twin_close_othertab(win, FALSE, prev_curtab);\n\treturn FAIL;\n    }\n\n    // Autocommands may have closed the window already or closed the only\n    // other window.\n    if (!win_valid(win) || last_window()\n\t    || close_last_window_tabpage(win, free_buf, prev_curtab))\n\treturn FAIL;\n\n    // Now we are really going to close the window.  Disallow any autocommand\n    // to split a window to avoid trouble.\n    // Also bail out of parse_queued_messages() to avoid it tries to update the\n    // screen.\n    ++split_disallowed;\n#ifdef MESSAGE_QUEUE\n    ++dont_parse_messages;\n#endif\n\n    // Free the memory used for the window and get the window that received\n    // the screen space.\n    wp = win_free_mem(win, &dir, NULL);\n\n    if (help_window)\n    {\n\t// Closing the help window moves the cursor back to the current window\n\t// of the snapshot.\n\twin_T *prev_win = get_snapshot_curwin(SNAP_HELP_IDX);\n\n\tif (win_valid(prev_win))\n\t    wp = prev_win;\n    }\n\n    // Make sure curwin isn't invalid.  It can cause severe trouble when\n    // printing an error message.  For win_equal() curbuf needs to be valid\n    // too.\n    if (win == curwin)\n    {\n\tcurwin = wp;\n#ifdef FEAT_QUICKFIX\n\tif (wp->w_p_pvw || bt_quickfix(wp->w_buffer))\n\t{\n\t    /*\n\t     * If the cursor goes to the preview or the quickfix window, try\n\t     * finding another window to go to.\n\t     */\n\t    for (;;)\n\t    {\n\t\tif (wp->w_next == NULL)\n\t\t    wp = firstwin;\n\t\telse\n\t\t    wp = wp->w_next;\n\t\tif (wp == curwin)\n\t\t    break;\n\t\tif (!wp->w_p_pvw && !bt_quickfix(wp->w_buffer))\n\t\t{\n\t\t    curwin = wp;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n#endif\n\tcurbuf = curwin->w_buffer;\n\tclose_curwin = TRUE;\n\n\t// The cursor position may be invalid if the buffer changed after last\n\t// using the window.\n\tcheck_cursor();\n    }\n    if (p_ea && (*p_ead == 'b' || *p_ead == dir))\n\t// If the frame of the closed window contains the new current window,\n\t// only resize that frame.  Otherwise resize all windows.\n\twin_equal(curwin, curwin->w_frame->fr_parent == win_frame, dir);\n    else\n\twin_comp_pos();\n    if (close_curwin)\n    {\n\t// Pass WEE_ALLOW_PARSE_MESSAGES to decrement dont_parse_messages\n\t// before autocommands.\n#ifdef MESSAGE_QUEUE\n\tdid_decrement =\n#else\n\t(void)\n#endif\n\t    win_enter_ext(wp,\n\t\tWEE_CURWIN_INVALID | WEE_TRIGGER_ENTER_AUTOCMDS\n\t\t      | WEE_TRIGGER_LEAVE_AUTOCMDS | WEE_ALLOW_PARSE_MESSAGES);\n\tif (other_buffer)\n\t    // careful: after this wp and win may be invalid!\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    --split_disallowed;\n#ifdef MESSAGE_QUEUE\n    if (!did_decrement)\n\t--dont_parse_messages;\n#endif\n\n    /*\n     * If last window has a status line now and we don't want one,\n     * remove the status line.\n     */\n    last_status(FALSE);\n\n    // After closing the help window, try restoring the window layout from\n    // before it was opened.\n    if (help_window)\n\trestore_snapshot(SNAP_HELP_IDX, close_curwin);\n\n#ifdef FEAT_DIFF\n    // If the window had 'diff' set and now there is only one window left in\n    // the tab page with 'diff' set, and \"closeoff\" is in 'diffopt', then\n    // execute \":diffoff!\".\n    if (diffopt_closeoff() && had_diffmode && curtab == prev_curtab)\n    {\n\tint\tdiffcount = 0;\n\twin_T\t*dwin;\n\n\tFOR_ALL_WINDOWS(dwin)\n\t    if (dwin->w_p_diff)\n\t\t++diffcount;\n\tif (diffcount == 1)\n\t    do_cmdline_cmd((char_u *)\"diffoff!\");\n    }\n#endif\n\n#if defined(FEAT_GUI)\n    // When 'guioptions' includes 'L' or 'R' may have to remove scrollbars.\n    if (gui.in_use && !win_hasvertsplit())\n\tgui_init_which_components(NULL);\n#endif\n\n    redraw_all_later(NOT_VALID);\n    return OK;\n}\n\n    static void\ntrigger_winclosed(win_T *win)\n{\n    static int\trecursive = FALSE;\n    char_u\twinid[NUMBUFLEN];\n\n    if (recursive)\n\treturn;\n    recursive = TRUE;\n    vim_snprintf((char *)winid, sizeof(winid), \"%d\", win->w_id);\n    apply_autocmds(EVENT_WINCLOSED, winid, winid, FALSE, win->w_buffer);\n    recursive = FALSE;\n}\n\n/*\n * Trigger WinScrolled for \"curwin\" if needed.\n */\n    void\nmay_trigger_winscrolled(void)\n{\n    win_T\t    *wp = curwin;\n    static int\t    recursive = FALSE;\n    char_u\t    winid[NUMBUFLEN];\n\n    if (recursive || !has_winscrolled())\n\treturn;\n\n    if (wp->w_last_topline != wp->w_topline\n\t    || wp->w_last_leftcol != wp->w_leftcol\n\t    || wp->w_last_width != wp->w_width\n\t    || wp->w_last_height != wp->w_height)\n    {\n\tvim_snprintf((char *)winid, sizeof(winid), \"%d\", wp->w_id);\n\n\trecursive = TRUE;\n\tapply_autocmds(EVENT_WINSCROLLED, winid, winid, FALSE, wp->w_buffer);\n\trecursive = FALSE;\n\n\t// an autocmd may close the window, \"wp\" may be invalid now\n\tif (win_valid_any_tab(wp))\n\t{\n\t    wp->w_last_topline = wp->w_topline;\n\t    wp->w_last_leftcol = wp->w_leftcol;\n\t    wp->w_last_width = wp->w_width;\n\t    wp->w_last_height = wp->w_height;\n\t}\n    }\n}\n\n/*\n * Close window \"win\" in tab page \"tp\", which is not the current tab page.\n * This may be the last window in that tab page and result in closing the tab,\n * thus \"tp\" may become invalid!\n * Caller must check if buffer is hidden and whether the tabline needs to be\n * updated.\n */\n    void\nwin_close_othertab(win_T *win, int free_buf, tabpage_T *tp)\n{\n    win_T\t*wp;\n    int\t\tdir;\n    tabpage_T   *ptp = NULL;\n    int\t\tfree_tp = FALSE;\n\n    // Get here with win->w_buffer == NULL when win_close() detects the tab\n    // page changed.\n    if (win->w_closing || (win->w_buffer != NULL\n\t\t\t\t\t       && win->w_buffer->b_locked > 0))\n\treturn; // window is already being closed\n\n    // Trigger WinClosed just before starting to free window-related resources.\n    trigger_winclosed(win);\n    // autocmd may have freed the window already.\n    if (!win_valid_any_tab(win))\n\treturn;\n\n    if (win->w_buffer != NULL)\n\t// Close the link to the buffer.\n\tclose_buffer(win, win->w_buffer, free_buf ? DOBUF_UNLOAD : 0,\n\t\t\t\t\t\t\t\t FALSE, TRUE);\n\n    // Careful: Autocommands may have closed the tab page or made it the\n    // current tab page.\n    for (ptp = first_tabpage; ptp != NULL && ptp != tp; ptp = ptp->tp_next)\n\t;\n    if (ptp == NULL || tp == curtab)\n    {\n\t// If the buffer was removed from the window we have to give it any\n\t// buffer.\n\tif (win_valid_any_tab(win) && win->w_buffer == NULL)\n\t{\n\t    win->w_buffer = firstbuf;\n\t    ++firstbuf->b_nwindows;\n\t    win_init_empty(win);\n\t}\n\treturn;\n    }\n\n    // Autocommands may have closed the window already.\n    for (wp = tp->tp_firstwin; wp != NULL && wp != win; wp = wp->w_next)\n\t;\n    if (wp == NULL)\n\treturn;\n\n    // When closing the last window in a tab page remove the tab page.\n    if (tp->tp_firstwin == tp->tp_lastwin)\n    {\n\tif (tp == first_tabpage)\n\t    first_tabpage = tp->tp_next;\n\telse\n\t{\n\t    for (ptp = first_tabpage; ptp != NULL && ptp->tp_next != tp;\n\t\t\t\t\t\t\t   ptp = ptp->tp_next)\n\t\t;\n\t    if (ptp == NULL)\n\t    {\n\t\tinternal_error(\"win_close_othertab()\");\n\t\treturn;\n\t    }\n\t    ptp->tp_next = tp->tp_next;\n\t}\n\tfree_tp = TRUE;\n    }\n\n    // Free the memory used for the window.\n    win_free_mem(win, &dir, tp);\n\n    if (free_tp)\n\tfree_tabpage(tp);\n}\n\n/*\n * Free the memory used for a window.\n * Returns a pointer to the window that got the freed up space.\n */\n    static win_T *\nwin_free_mem(\n    win_T\t*win,\n    int\t\t*dirp,\t\t// set to 'v' or 'h' for direction if 'ea'\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    frame_T\t*frp;\n    win_T\t*wp;\n    tabpage_T\t*win_tp = tp == NULL ? curtab : tp;\n\n    // Remove the window and its frame from the tree of frames.\n    frp = win->w_frame;\n    wp = winframe_remove(win, dirp, tp);\n    vim_free(frp);\n    win_free(win, tp);\n\n    // When deleting the current window in the tab, select a new current\n    // window.\n    if (win == win_tp->tp_curwin)\n\twin_tp->tp_curwin = wp;\n\n    return wp;\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nwin_free_all(void)\n{\n    int\t\tdummy;\n\n#ifdef FEAT_CMDWIN\n    // avoid an error for switching tabpage with the cmdline window open\n    cmdwin_type = 0;\n#endif\n    while (first_tabpage->tp_next != NULL)\n\ttabpage_close(TRUE);\n\n    if (aucmd_win != NULL)\n    {\n\t(void)win_free_mem(aucmd_win, &dummy, NULL);\n\taucmd_win = NULL;\n    }\n\n    while (firstwin != NULL)\n\t(void)win_free_mem(firstwin, &dummy, NULL);\n\n    // No window should be used after this. Set curwin to NULL to crash\n    // instead of using freed memory.\n    curwin = NULL;\n}\n#endif\n\n/*\n * Remove a window and its frame from the tree of frames.\n * Returns a pointer to the window that got the freed up space.\n */\n    win_T *\nwinframe_remove(\n    win_T\t*win,\n    int\t\t*dirp UNUSED,\t// set to 'v' or 'h' for direction if 'ea'\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    frame_T\t*frp, *frp2, *frp3;\n    frame_T\t*frp_close = win->w_frame;\n    win_T\t*wp;\n\n    /*\n     * If there is only one window there is nothing to remove.\n     */\n    if (tp == NULL ? ONE_WINDOW : tp->tp_firstwin == tp->tp_lastwin)\n\treturn NULL;\n\n    /*\n     * Remove the window from its frame.\n     */\n    frp2 = win_altframe(win, tp);\n    wp = frame2win(frp2);\n\n    // Remove this frame from the list of frames.\n    frame_remove(frp_close);\n\n    if (frp_close->fr_parent->fr_layout == FR_COL)\n    {\n\t// When 'winfixheight' is set, try to find another frame in the column\n\t// (as close to the closed frame as possible) to distribute the height\n\t// to.\n\tif (frp2->fr_win != NULL && frp2->fr_win->w_p_wfh)\n\t{\n\t    frp = frp_close->fr_prev;\n\t    frp3 = frp_close->fr_next;\n\t    while (frp != NULL || frp3 != NULL)\n\t    {\n\t\tif (frp != NULL)\n\t\t{\n\t\t    if (!frame_fixed_height(frp))\n\t\t    {\n\t\t\tfrp2 = frp;\n\t\t\twp = frame2win(frp2);\n\t\t\tbreak;\n\t\t    }\n\t\t    frp = frp->fr_prev;\n\t\t}\n\t\tif (frp3 != NULL)\n\t\t{\n\t\t    if (frp3->fr_win != NULL && !frp3->fr_win->w_p_wfh)\n\t\t    {\n\t\t\tfrp2 = frp3;\n\t\t\twp = frp3->fr_win;\n\t\t\tbreak;\n\t\t    }\n\t\t    frp3 = frp3->fr_next;\n\t\t}\n\t    }\n\t}\n\tframe_new_height(frp2, frp2->fr_height + frp_close->fr_height,\n\t\t\t    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);\n\t*dirp = 'v';\n    }\n    else\n    {\n\t// When 'winfixwidth' is set, try to find another frame in the column\n\t// (as close to the closed frame as possible) to distribute the width\n\t// to.\n\tif (frp2->fr_win != NULL && frp2->fr_win->w_p_wfw)\n\t{\n\t    frp = frp_close->fr_prev;\n\t    frp3 = frp_close->fr_next;\n\t    while (frp != NULL || frp3 != NULL)\n\t    {\n\t\tif (frp != NULL)\n\t\t{\n\t\t    if (!frame_fixed_width(frp))\n\t\t    {\n\t\t\tfrp2 = frp;\n\t\t\twp = frame2win(frp2);\n\t\t\tbreak;\n\t\t    }\n\t\t    frp = frp->fr_prev;\n\t\t}\n\t\tif (frp3 != NULL)\n\t\t{\n\t\t    if (frp3->fr_win != NULL && !frp3->fr_win->w_p_wfw)\n\t\t    {\n\t\t\tfrp2 = frp3;\n\t\t\twp = frp3->fr_win;\n\t\t\tbreak;\n\t\t    }\n\t\t    frp3 = frp3->fr_next;\n\t\t}\n\t    }\n\t}\n\tframe_new_width(frp2, frp2->fr_width + frp_close->fr_width,\n\t\t\t    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);\n\t*dirp = 'h';\n    }\n\n    // If rows/columns go to a window below/right its positions need to be\n    // updated.  Can only be done after the sizes have been updated.\n    if (frp2 == frp_close->fr_next)\n    {\n\tint row = win->w_winrow;\n\tint col = win->w_wincol;\n\n\tframe_comp_pos(frp2, &row, &col);\n    }\n\n    if (frp2->fr_next == NULL && frp2->fr_prev == NULL)\n    {\n\t// There is no other frame in this list, move its info to the parent\n\t// and remove it.\n\tfrp2->fr_parent->fr_layout = frp2->fr_layout;\n\tfrp2->fr_parent->fr_child = frp2->fr_child;\n\tFOR_ALL_FRAMES(frp, frp2->fr_child)\n\t    frp->fr_parent = frp2->fr_parent;\n\tfrp2->fr_parent->fr_win = frp2->fr_win;\n\tif (frp2->fr_win != NULL)\n\t    frp2->fr_win->w_frame = frp2->fr_parent;\n\tfrp = frp2->fr_parent;\n\tif (topframe->fr_child == frp2)\n\t    topframe->fr_child = frp;\n\tvim_free(frp2);\n\n\tfrp2 = frp->fr_parent;\n\tif (frp2 != NULL && frp2->fr_layout == frp->fr_layout)\n\t{\n\t    // The frame above the parent has the same layout, have to merge\n\t    // the frames into this list.\n\t    if (frp2->fr_child == frp)\n\t\tfrp2->fr_child = frp->fr_child;\n\t    frp->fr_child->fr_prev = frp->fr_prev;\n\t    if (frp->fr_prev != NULL)\n\t\tfrp->fr_prev->fr_next = frp->fr_child;\n\t    for (frp3 = frp->fr_child; ; frp3 = frp3->fr_next)\n\t    {\n\t\tfrp3->fr_parent = frp2;\n\t\tif (frp3->fr_next == NULL)\n\t\t{\n\t\t    frp3->fr_next = frp->fr_next;\n\t\t    if (frp->fr_next != NULL)\n\t\t\tfrp->fr_next->fr_prev = frp3;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (topframe->fr_child == frp)\n\t\ttopframe->fr_child = frp2;\n\t    vim_free(frp);\n\t}\n    }\n\n    return wp;\n}\n\n/*\n * Return a pointer to the frame that will receive the empty screen space that\n * is left over after \"win\" is closed.\n *\n * If 'splitbelow' or 'splitright' is set, the space goes above or to the left\n * by default.  Otherwise, the free space goes below or to the right.  The\n * result is that opening a window and then immediately closing it will\n * preserve the initial window layout.  The 'wfh' and 'wfw' settings are\n * respected when possible.\n */\n    static frame_T *\nwin_altframe(\n    win_T\t*win,\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    frame_T\t*frp;\n    frame_T\t*other_fr, *target_fr;\n\n    if (tp == NULL ? ONE_WINDOW : tp->tp_firstwin == tp->tp_lastwin)\n\treturn alt_tabpage()->tp_curwin->w_frame;\n\n    frp = win->w_frame;\n\n    if (frp->fr_prev == NULL)\n\treturn frp->fr_next;\n    if (frp->fr_next == NULL)\n\treturn frp->fr_prev;\n\n    // By default the next window will get the space that was abandoned by this\n    // window\n    target_fr = frp->fr_next;\n    other_fr  = frp->fr_prev;\n\n    // If this is part of a column of windows and 'splitbelow' is true then the\n    // previous window will get the space.\n    if (frp->fr_parent != NULL && frp->fr_parent->fr_layout == FR_COL && p_sb)\n    {\n\ttarget_fr = frp->fr_prev;\n\tother_fr  = frp->fr_next;\n    }\n\n    // If this is part of a row of windows, and 'splitright' is true then the\n    // previous window will get the space.\n    if (frp->fr_parent != NULL && frp->fr_parent->fr_layout == FR_ROW && p_spr)\n    {\n\ttarget_fr = frp->fr_prev;\n\tother_fr  = frp->fr_next;\n    }\n\n    // If 'wfh' or 'wfw' is set for the target and not for the alternate\n    // window, reverse the selection.\n    if (frp->fr_parent != NULL && frp->fr_parent->fr_layout == FR_ROW)\n    {\n\tif (frame_fixed_width(target_fr) && !frame_fixed_width(other_fr))\n\t    target_fr = other_fr;\n    }\n    else\n    {\n\tif (frame_fixed_height(target_fr) && !frame_fixed_height(other_fr))\n\t    target_fr = other_fr;\n    }\n\n    return target_fr;\n}\n\n/*\n * Return the tabpage that will be used if the current one is closed.\n */\n    static tabpage_T *\nalt_tabpage(void)\n{\n    tabpage_T\t*tp;\n\n    // Use the next tab page if possible.\n    if (curtab->tp_next != NULL)\n\treturn curtab->tp_next;\n\n    // Find the last but one tab page.\n    for (tp = first_tabpage; tp->tp_next != curtab; tp = tp->tp_next)\n\t;\n    return tp;\n}\n\n/*\n * Find the left-upper window in frame \"frp\".\n */\n    static win_T *\nframe2win(frame_T *frp)\n{\n    while (frp->fr_win == NULL)\n\tfrp = frp->fr_child;\n    return frp->fr_win;\n}\n\n/*\n * Return TRUE if frame \"frp\" contains window \"wp\".\n */\n    static int\nframe_has_win(frame_T *frp, win_T *wp)\n{\n    frame_T\t*p;\n\n    if (frp->fr_layout == FR_LEAF)\n\treturn frp->fr_win == wp;\n\n    FOR_ALL_FRAMES(p, frp->fr_child)\n\tif (frame_has_win(p, wp))\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Set a new height for a frame.  Recursively sets the height for contained\n * frames and windows.  Caller must take care of positions.\n */\n    static void\nframe_new_height(\n    frame_T\t*topfrp,\n    int\t\theight,\n    int\t\ttopfirst,\t// resize topmost contained frame first\n    int\t\twfh)\t\t// obey 'winfixheight' when there is a choice;\n\t\t\t\t// may cause the height not to be set\n{\n    frame_T\t*frp;\n    int\t\textra_lines;\n    int\t\th;\n\n    if (topfrp->fr_win != NULL)\n    {\n\t// Simple case: just one window.\n\twin_new_height(topfrp->fr_win,\n\t\t\t\t    height - topfrp->fr_win->w_status_height\n\t\t\t\t\t      - WINBAR_HEIGHT(topfrp->fr_win));\n    }\n    else if (topfrp->fr_layout == FR_ROW)\n    {\n\tdo\n\t{\n\t    // All frames in this row get the same new height.\n\t    FOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    {\n\t\tframe_new_height(frp, height, topfirst, wfh);\n\t\tif (frp->fr_height > height)\n\t\t{\n\t\t    // Could not fit the windows, make the whole row higher.\n\t\t    height = frp->fr_height;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\twhile (frp != NULL);\n    }\n    else    // fr_layout == FR_COL\n    {\n\t// Complicated case: Resize a column of frames.  Resize the bottom\n\t// frame first, frames above that when needed.\n\n\tfrp = topfrp->fr_child;\n\tif (wfh)\n\t    // Advance past frames with one window with 'wfh' set.\n\t    while (frame_fixed_height(frp))\n\t    {\n\t\tfrp = frp->fr_next;\n\t\tif (frp == NULL)\n\t\t    return;\t    // no frame without 'wfh', give up\n\t    }\n\tif (!topfirst)\n\t{\n\t    // Find the bottom frame of this column\n\t    while (frp->fr_next != NULL)\n\t\tfrp = frp->fr_next;\n\t    if (wfh)\n\t\t// Advance back for frames with one window with 'wfh' set.\n\t\twhile (frame_fixed_height(frp))\n\t\t    frp = frp->fr_prev;\n\t}\n\n\textra_lines = height - topfrp->fr_height;\n\tif (extra_lines < 0)\n\t{\n\t    // reduce height of contained frames, bottom or top frame first\n\t    while (frp != NULL)\n\t    {\n\t\th = frame_minheight(frp, NULL);\n\t\tif (frp->fr_height + extra_lines < h)\n\t\t{\n\t\t    extra_lines += frp->fr_height - h;\n\t\t    frame_new_height(frp, h, topfirst, wfh);\n\t\t}\n\t\telse\n\t\t{\n\t\t    frame_new_height(frp, frp->fr_height + extra_lines,\n\t\t\t\t\t\t\t       topfirst, wfh);\n\t\t    break;\n\t\t}\n\t\tif (topfirst)\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_next;\n\t\t    while (wfh && frp != NULL && frame_fixed_height(frp));\n\t\t}\n\t\telse\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_prev;\n\t\t    while (wfh && frp != NULL && frame_fixed_height(frp));\n\t\t}\n\t\t// Increase \"height\" if we could not reduce enough frames.\n\t\tif (frp == NULL)\n\t\t    height -= extra_lines;\n\t    }\n\t}\n\telse if (extra_lines > 0)\n\t{\n\t    // increase height of bottom or top frame\n\t    frame_new_height(frp, frp->fr_height + extra_lines, topfirst, wfh);\n\t}\n    }\n    topfrp->fr_height = height;\n}\n\n/*\n * Return TRUE if height of frame \"frp\" should not be changed because of\n * the 'winfixheight' option.\n */\n    static int\nframe_fixed_height(frame_T *frp)\n{\n    // frame with one window: fixed height if 'winfixheight' set.\n    if (frp->fr_win != NULL)\n\treturn frp->fr_win->w_p_wfh;\n\n    if (frp->fr_layout == FR_ROW)\n    {\n\t// The frame is fixed height if one of the frames in the row is fixed\n\t// height.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    if (frame_fixed_height(frp))\n\t\treturn TRUE;\n\treturn FALSE;\n    }\n\n    // frp->fr_layout == FR_COL: The frame is fixed height if all of the\n    // frames in the row are fixed height.\n    FOR_ALL_FRAMES(frp, frp->fr_child)\n\tif (!frame_fixed_height(frp))\n\t    return FALSE;\n    return TRUE;\n}\n\n/*\n * Return TRUE if width of frame \"frp\" should not be changed because of\n * the 'winfixwidth' option.\n */\n    static int\nframe_fixed_width(frame_T *frp)\n{\n    // frame with one window: fixed width if 'winfixwidth' set.\n    if (frp->fr_win != NULL)\n\treturn frp->fr_win->w_p_wfw;\n\n    if (frp->fr_layout == FR_COL)\n    {\n\t// The frame is fixed width if one of the frames in the row is fixed\n\t// width.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    if (frame_fixed_width(frp))\n\t\treturn TRUE;\n\treturn FALSE;\n    }\n\n    // frp->fr_layout == FR_ROW: The frame is fixed width if all of the\n    // frames in the row are fixed width.\n    FOR_ALL_FRAMES(frp, frp->fr_child)\n\tif (!frame_fixed_width(frp))\n\t    return FALSE;\n    return TRUE;\n}\n\n/*\n * Add a status line to windows at the bottom of \"frp\".\n * Note: Does not check if there is room!\n */\n    static void\nframe_add_statusline(frame_T *frp)\n{\n    win_T\t*wp;\n\n    if (frp->fr_layout == FR_LEAF)\n    {\n\twp = frp->fr_win;\n\tif (wp->w_status_height == 0)\n\t{\n\t    if (wp->w_height > 0)\t// don't make it negative\n\t\t--wp->w_height;\n\t    wp->w_status_height = STATUS_HEIGHT;\n\t}\n    }\n    else if (frp->fr_layout == FR_ROW)\n    {\n\t// Handle all the frames in the row.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    frame_add_statusline(frp);\n    }\n    else // frp->fr_layout == FR_COL\n    {\n\t// Only need to handle the last frame in the column.\n\tfor (frp = frp->fr_child; frp->fr_next != NULL; frp = frp->fr_next)\n\t    ;\n\tframe_add_statusline(frp);\n    }\n}\n\n/*\n * Set width of a frame.  Handles recursively going through contained frames.\n * May remove separator line for windows at the right side (for win_close()).\n */\n    static void\nframe_new_width(\n    frame_T\t*topfrp,\n    int\t\twidth,\n    int\t\tleftfirst,\t// resize leftmost contained frame first\n    int\t\twfw)\t\t// obey 'winfixwidth' when there is a choice;\n\t\t\t\t// may cause the width not to be set\n{\n    frame_T\t*frp;\n    int\t\textra_cols;\n    int\t\tw;\n    win_T\t*wp;\n\n    if (topfrp->fr_layout == FR_LEAF)\n    {\n\t// Simple case: just one window.\n\twp = topfrp->fr_win;\n\t// Find out if there are any windows right of this one.\n\tfor (frp = topfrp; frp->fr_parent != NULL; frp = frp->fr_parent)\n\t    if (frp->fr_parent->fr_layout == FR_ROW && frp->fr_next != NULL)\n\t\tbreak;\n\tif (frp->fr_parent == NULL)\n\t    wp->w_vsep_width = 0;\n\twin_new_width(wp, width - wp->w_vsep_width);\n    }\n    else if (topfrp->fr_layout == FR_COL)\n    {\n\tdo\n\t{\n\t    // All frames in this column get the same new width.\n\t    FOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    {\n\t\tframe_new_width(frp, width, leftfirst, wfw);\n\t\tif (frp->fr_width > width)\n\t\t{\n\t\t    // Could not fit the windows, make whole column wider.\n\t\t    width = frp->fr_width;\n\t\t    break;\n\t\t}\n\t    }\n\t} while (frp != NULL);\n    }\n    else    // fr_layout == FR_ROW\n    {\n\t// Complicated case: Resize a row of frames.  Resize the rightmost\n\t// frame first, frames left of it when needed.\n\n\tfrp = topfrp->fr_child;\n\tif (wfw)\n\t    // Advance past frames with one window with 'wfw' set.\n\t    while (frame_fixed_width(frp))\n\t    {\n\t\tfrp = frp->fr_next;\n\t\tif (frp == NULL)\n\t\t    return;\t    // no frame without 'wfw', give up\n\t    }\n\tif (!leftfirst)\n\t{\n\t    // Find the rightmost frame of this row\n\t    while (frp->fr_next != NULL)\n\t\tfrp = frp->fr_next;\n\t    if (wfw)\n\t\t// Advance back for frames with one window with 'wfw' set.\n\t\twhile (frame_fixed_width(frp))\n\t\t    frp = frp->fr_prev;\n\t}\n\n\textra_cols = width - topfrp->fr_width;\n\tif (extra_cols < 0)\n\t{\n\t    // reduce frame width, rightmost frame first\n\t    while (frp != NULL)\n\t    {\n\t\tw = frame_minwidth(frp, NULL);\n\t\tif (frp->fr_width + extra_cols < w)\n\t\t{\n\t\t    extra_cols += frp->fr_width - w;\n\t\t    frame_new_width(frp, w, leftfirst, wfw);\n\t\t}\n\t\telse\n\t\t{\n\t\t    frame_new_width(frp, frp->fr_width + extra_cols,\n\t\t\t\t\t\t\t      leftfirst, wfw);\n\t\t    break;\n\t\t}\n\t\tif (leftfirst)\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_next;\n\t\t    while (wfw && frp != NULL && frame_fixed_width(frp));\n\t\t}\n\t\telse\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_prev;\n\t\t    while (wfw && frp != NULL && frame_fixed_width(frp));\n\t\t}\n\t\t// Increase \"width\" if we could not reduce enough frames.\n\t\tif (frp == NULL)\n\t\t    width -= extra_cols;\n\t    }\n\t}\n\telse if (extra_cols > 0)\n\t{\n\t    // increase width of rightmost frame\n\t    frame_new_width(frp, frp->fr_width + extra_cols, leftfirst, wfw);\n\t}\n    }\n    topfrp->fr_width = width;\n}\n\n/*\n * Add the vertical separator to windows at the right side of \"frp\".\n * Note: Does not check if there is room!\n */\n    static void\nframe_add_vsep(frame_T *frp)\n{\n    win_T\t*wp;\n\n    if (frp->fr_layout == FR_LEAF)\n    {\n\twp = frp->fr_win;\n\tif (wp->w_vsep_width == 0)\n\t{\n\t    if (wp->w_width > 0)\t// don't make it negative\n\t\t--wp->w_width;\n\t    wp->w_vsep_width = 1;\n\t}\n    }\n    else if (frp->fr_layout == FR_COL)\n    {\n\t// Handle all the frames in the column.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    frame_add_vsep(frp);\n    }\n    else // frp->fr_layout == FR_ROW\n    {\n\t// Only need to handle the last frame in the row.\n\tfrp = frp->fr_child;\n\twhile (frp->fr_next != NULL)\n\t    frp = frp->fr_next;\n\tframe_add_vsep(frp);\n    }\n}\n\n/*\n * Set frame width from the window it contains.\n */\n    static void\nframe_fix_width(win_T *wp)\n{\n    wp->w_frame->fr_width = wp->w_width + wp->w_vsep_width;\n}\n\n/*\n * Set frame height from the window it contains.\n */\n    static void\nframe_fix_height(win_T *wp)\n{\n    wp->w_frame->fr_height = VISIBLE_HEIGHT(wp) + wp->w_status_height;\n}\n\n/*\n * Compute the minimal height for frame \"topfrp\".\n * Uses the 'winminheight' option.\n * When \"next_curwin\" isn't NULL, use p_wh for this window.\n * When \"next_curwin\" is NOWIN, don't use at least one line for the current\n * window.\n */\n    static int\nframe_minheight(frame_T *topfrp, win_T *next_curwin)\n{\n    frame_T\t*frp;\n    int\t\tm;\n    int\t\tn;\n\n    if (topfrp->fr_win != NULL)\n    {\n\tif (topfrp->fr_win == next_curwin)\n\t    m = p_wh + topfrp->fr_win->w_status_height;\n\telse\n\t{\n\t    // window: minimal height of the window plus status line\n\t    m = p_wmh + topfrp->fr_win->w_status_height;\n\t    if (topfrp->fr_win == curwin && next_curwin == NULL)\n\t    {\n\t\t// Current window is minimal one line high and WinBar is\n\t\t// visible.\n\t\tif (p_wmh == 0)\n\t\t    ++m;\n\t\tm += WINBAR_HEIGHT(curwin);\n\t    }\n\t}\n    }\n    else if (topfrp->fr_layout == FR_ROW)\n    {\n\t// get the minimal height from each frame in this row\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    n = frame_minheight(frp, next_curwin);\n\t    if (n > m)\n\t\tm = n;\n\t}\n    }\n    else\n    {\n\t// Add up the minimal heights for all frames in this column.\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    m += frame_minheight(frp, next_curwin);\n    }\n\n    return m;\n}\n\n/*\n * Compute the minimal width for frame \"topfrp\".\n * When \"next_curwin\" isn't NULL, use p_wiw for this window.\n * When \"next_curwin\" is NOWIN, don't use at least one column for the current\n * window.\n */\n    static int\nframe_minwidth(\n    frame_T\t*topfrp,\n    win_T\t*next_curwin)\t// use p_wh and p_wiw for next_curwin\n{\n    frame_T\t*frp;\n    int\t\tm, n;\n\n    if (topfrp->fr_win != NULL)\n    {\n\tif (topfrp->fr_win == next_curwin)\n\t    m = p_wiw + topfrp->fr_win->w_vsep_width;\n\telse\n\t{\n\t    // window: minimal width of the window plus separator column\n\t    m = p_wmw + topfrp->fr_win->w_vsep_width;\n\t    // Current window is minimal one column wide\n\t    if (p_wmw == 0 && topfrp->fr_win == curwin && next_curwin == NULL)\n\t\t++m;\n\t}\n    }\n    else if (topfrp->fr_layout == FR_COL)\n    {\n\t// get the minimal width from each frame in this column\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    n = frame_minwidth(frp, next_curwin);\n\t    if (n > m)\n\t\tm = n;\n\t}\n    }\n    else\n    {\n\t// Add up the minimal widths for all frames in this row.\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    m += frame_minwidth(frp, next_curwin);\n    }\n\n    return m;\n}\n\n\n/*\n * Try to close all windows except current one.\n * Buffers in the other windows become hidden if 'hidden' is set, or '!' is\n * used and the buffer was modified.\n *\n * Used by \":bdel\" and \":only\".\n */\n    void\nclose_others(\n    int\t\tmessage,\n    int\t\tforceit)\t    // always hide all other windows\n{\n    win_T\t*wp;\n    win_T\t*nextwp;\n    int\t\tr;\n\n    if (one_window())\n    {\n\tif (message && !autocmd_busy)\n\t    msg(_(m_onlyone));\n\treturn;\n    }\n\n    // Be very careful here: autocommands may change the window layout.\n    for (wp = firstwin; win_valid(wp); wp = nextwp)\n    {\n\tnextwp = wp->w_next;\n\tif (wp != curwin)\t\t// don't close current window\n\t{\n\n\t    // Check if it's allowed to abandon this window\n\t    r = can_abandon(wp->w_buffer, forceit);\n\t    if (!win_valid(wp))\t\t// autocommands messed wp up\n\t    {\n\t\tnextwp = firstwin;\n\t\tcontinue;\n\t    }\n\t    if (!r)\n\t    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t\tif (message && (p_confirm\n\t\t\t     || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t\t{\n\t\t    dialog_changed(wp->w_buffer, FALSE);\n\t\t    if (!win_valid(wp))\t\t// autocommands messed wp up\n\t\t    {\n\t\t\tnextwp = firstwin;\n\t\t\tcontinue;\n\t\t    }\n\t\t}\n\t\tif (bufIsChanged(wp->w_buffer))\n#endif\n\t\t    continue;\n\t    }\n\t    win_close(wp, !buf_hide(wp->w_buffer)\n\t\t\t\t\t       && !bufIsChanged(wp->w_buffer));\n\t}\n    }\n\n    if (message && !ONE_WINDOW)\n\temsg(_(e_other_window_contains_changes));\n}\n\n/*\n * Allocate the first window and put an empty buffer in it.\n * Called from main().\n * Return FAIL when something goes wrong (out of memory).\n */\n    int\nwin_alloc_first(void)\n{\n    if (win_alloc_firstwin(NULL) == FAIL)\n\treturn FAIL;\n\n    first_tabpage = alloc_tabpage();\n    if (first_tabpage == NULL)\n\treturn FAIL;\n    first_tabpage->tp_topframe = topframe;\n    curtab = first_tabpage;\n    curtab->tp_firstwin = firstwin;\n    curtab->tp_lastwin = lastwin;\n    curtab->tp_curwin = curwin;\n\n    return OK;\n}\n\n/*\n * Allocate and init a window that is not a regular window.\n * This can only be done after the first window is fully initialized, thus it\n * can't be in win_alloc_first().\n */\n    win_T *\nwin_alloc_popup_win(void)\n{\n    win_T *wp;\n\n    wp = win_alloc(NULL, TRUE);\n    if (wp != NULL)\n    {\n\t// We need to initialize options with something, using the current\n\t// window makes most sense.\n\twin_init_some(wp, curwin);\n\n\tRESET_BINDING(wp);\n\tnew_frame(wp);\n    }\n    return wp;\n}\n\n/*\n * Initialize window \"wp\" to display buffer \"buf\".\n */\n    void\nwin_init_popup_win(win_T *wp, buf_T *buf)\n{\n    wp->w_buffer = buf;\n    ++buf->b_nwindows;\n    win_init_empty(wp); // set cursor and topline to safe values\n\n    // Make sure w_localdir and globaldir are NULL to avoid a chdir() in\n    // win_enter_ext().\n    VIM_CLEAR(wp->w_localdir);\n}\n\n/*\n * Allocate the first window or the first window in a new tab page.\n * When \"oldwin\" is NULL create an empty buffer for it.\n * When \"oldwin\" is not NULL copy info from it to the new window.\n * Return FAIL when something goes wrong (out of memory).\n */\n    static int\nwin_alloc_firstwin(win_T *oldwin)\n{\n    curwin = win_alloc(NULL, FALSE);\n    if (curwin == NULL)\n\treturn FAIL;\n    if (oldwin == NULL)\n    {\n\t// Very first window, need to create an empty buffer for it and\n\t// initialize from scratch.\n\tcurbuf = buflist_new(NULL, NULL, 1L, BLN_LISTED);\n\tif (curwin == NULL || curbuf == NULL)\n\t    return FAIL;\n\tcurwin->w_buffer = curbuf;\n#ifdef FEAT_SYN_HL\n\tcurwin->w_s = &(curbuf->b_s);\n#endif\n\tcurbuf->b_nwindows = 1;\t// there is one window\n\tcurwin->w_alist = &global_alist;\n\tcurwin_init();\t\t// init current window\n    }\n    else\n    {\n\t// First window in new tab page, initialize it from \"oldwin\".\n\twin_init(curwin, oldwin, 0);\n\n\t// We don't want cursor- and scroll-binding in the first window.\n\tRESET_BINDING(curwin);\n    }\n\n    new_frame(curwin);\n    if (curwin->w_frame == NULL)\n\treturn FAIL;\n    topframe = curwin->w_frame;\n    topframe->fr_width = Columns;\n    topframe->fr_height = Rows - p_ch;\n\n    return OK;\n}\n\n/*\n * Create a frame for window \"wp\".\n */\n    static void\nnew_frame(win_T *wp)\n{\n    frame_T *frp = ALLOC_CLEAR_ONE(frame_T);\n\n    wp->w_frame = frp;\n    if (frp != NULL)\n    {\n\tfrp->fr_layout = FR_LEAF;\n\tfrp->fr_win = wp;\n    }\n}\n\n/*\n * Initialize the window and frame size to the maximum.\n */\n    void\nwin_init_size(void)\n{\n    firstwin->w_height = ROWS_AVAIL;\n    topframe->fr_height = ROWS_AVAIL;\n    firstwin->w_width = Columns;\n    topframe->fr_width = Columns;\n}\n\n/*\n * Allocate a new tabpage_T and init the values.\n * Returns NULL when out of memory.\n */\n    static tabpage_T *\nalloc_tabpage(void)\n{\n    tabpage_T\t*tp;\n# ifdef FEAT_GUI\n    int\t\ti;\n# endif\n\n\n    tp = ALLOC_CLEAR_ONE(tabpage_T);\n    if (tp == NULL)\n\treturn NULL;\n\n# ifdef FEAT_EVAL\n    // init t: variables\n    tp->tp_vars = dict_alloc_id(aid_newtabpage_tvars);\n    if (tp->tp_vars == NULL)\n    {\n\tvim_free(tp);\n\treturn NULL;\n    }\n    init_var_dict(tp->tp_vars, &tp->tp_winvar, VAR_SCOPE);\n# endif\n\n# ifdef FEAT_GUI\n    for (i = 0; i < 3; i++)\n\ttp->tp_prev_which_scrollbars[i] = -1;\n# endif\n# ifdef FEAT_DIFF\n    tp->tp_diff_invalid = TRUE;\n# endif\n    tp->tp_ch_used = p_ch;\n\n    return tp;\n}\n\n    void\nfree_tabpage(tabpage_T *tp)\n{\n    int idx;\n\n# ifdef FEAT_DIFF\n    diff_clear(tp);\n# endif\n# ifdef FEAT_PROP_POPUP\n    while (tp->tp_first_popupwin != NULL)\n\tpopup_close_tabpage(tp, tp->tp_first_popupwin->w_id, TRUE);\n#endif\n    for (idx = 0; idx < SNAP_COUNT; ++idx)\n\tclear_snapshot(tp, idx);\n#ifdef FEAT_EVAL\n    vars_clear(&tp->tp_vars->dv_hashtab);\t// free all t: variables\n    hash_init(&tp->tp_vars->dv_hashtab);\n    unref_var_dict(tp->tp_vars);\n#endif\n\n    if (tp == lastused_tabpage)\n\tlastused_tabpage = NULL;\n\n    vim_free(tp->tp_localdir);\n    vim_free(tp->tp_prevdir);\n\n#ifdef FEAT_PYTHON\n    python_tabpage_free(tp);\n#endif\n\n#ifdef FEAT_PYTHON3\n    python3_tabpage_free(tp);\n#endif\n\n    vim_free(tp);\n}\n\n/*\n * Create a new Tab page with one window.\n * It will edit the current buffer, like after \":split\".\n * When \"after\" is 0 put it just after the current Tab page.\n * Otherwise put it just before tab page \"after\".\n * Return FAIL or OK.\n */\n    int\nwin_new_tabpage(int after)\n{\n    tabpage_T\t*tp = curtab;\n    tabpage_T\t*prev_tp = curtab;\n    tabpage_T\t*newtp;\n    int\t\tn;\n\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n    {\n\temsg(_(e_invalid_in_cmdline_window));\n\treturn FAIL;\n    }\n#endif\n\n    newtp = alloc_tabpage();\n    if (newtp == NULL)\n\treturn FAIL;\n\n    // Remember the current windows in this Tab page.\n    if (leave_tabpage(curbuf, TRUE) == FAIL)\n    {\n\tvim_free(newtp);\n\treturn FAIL;\n    }\n    curtab = newtp;\n\n    newtp->tp_localdir = (tp->tp_localdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(tp->tp_localdir);\n    // Create a new empty window.\n    if (win_alloc_firstwin(tp->tp_curwin) == OK)\n    {\n\t// Make the new Tab page the new topframe.\n\tif (after == 1)\n\t{\n\t    // New tab page becomes the first one.\n\t    newtp->tp_next = first_tabpage;\n\t    first_tabpage = newtp;\n\t}\n\telse\n\t{\n\t    if (after > 0)\n\t    {\n\t\t// Put new tab page before tab page \"after\".\n\t\tn = 2;\n\t\tfor (tp = first_tabpage; tp->tp_next != NULL\n\t\t\t\t\t       && n < after; tp = tp->tp_next)\n\t\t    ++n;\n\t    }\n\t    newtp->tp_next = tp->tp_next;\n\t    tp->tp_next = newtp;\n\t}\n\tnewtp->tp_firstwin = newtp->tp_lastwin = newtp->tp_curwin = curwin;\n\n\twin_init_size();\n\tfirstwin->w_winrow = tabline_height();\n\twin_comp_scroll(curwin);\n\n\tnewtp->tp_topframe = topframe;\n\tlast_status(FALSE);\n\n\tlastused_tabpage = prev_tp;\n\n#if defined(FEAT_GUI)\n\t// When 'guioptions' includes 'L' or 'R' may have to remove or add\n\t// scrollbars.  Have to update them anyway.\n\tgui_may_update_scrollbars();\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\tentering_window(curwin);\n#endif\n\n\tredraw_all_later(NOT_VALID);\n\tapply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABNEW, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\treturn OK;\n    }\n\n    // Failed, get back the previous Tab page\n    enter_tabpage(curtab, curbuf, TRUE, TRUE);\n    return FAIL;\n}\n\n/*\n * Open a new tab page if \":tab cmd\" was used.  It will edit the same buffer,\n * like with \":split\".\n * Returns OK if a new tab page was created, FAIL otherwise.\n */\n    static int\nmay_open_tabpage(void)\n{\n    int\t\tn = (cmdmod.cmod_tab == 0)\n\t\t\t\t       ? postponed_split_tab : cmdmod.cmod_tab;\n\n    if (n != 0)\n    {\n\tcmdmod.cmod_tab = 0;\t    // reset it to avoid doing it twice\n\tpostponed_split_tab = 0;\n\treturn win_new_tabpage(n);\n    }\n    return FAIL;\n}\n\n/*\n * Create up to \"maxcount\" tabpages with empty windows.\n * Returns the number of resulting tab pages.\n */\n    int\nmake_tabpages(int maxcount)\n{\n    int\t\tcount = maxcount;\n    int\t\ttodo;\n\n    // Limit to 'tabpagemax' tabs.\n    if (count > p_tpm)\n\tcount = p_tpm;\n\n    /*\n     * Don't execute autocommands while creating the tab pages.  Must do that\n     * when putting the buffers in the windows.\n     */\n    block_autocmds();\n\n    for (todo = count - 1; todo > 0; --todo)\n\tif (win_new_tabpage(0) == FAIL)\n\t    break;\n\n    unblock_autocmds();\n\n    // return actual number of tab pages\n    return (count - todo);\n}\n\n/*\n * Return TRUE when \"tpc\" points to a valid tab page.\n */\n    int\nvalid_tabpage(tabpage_T *tpc)\n{\n    tabpage_T\t*tp;\n\n    FOR_ALL_TABPAGES(tp)\n\tif (tp == tpc)\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Return TRUE when \"tpc\" points to a valid tab page and at least one window is\n * valid.\n */\n    int\nvalid_tabpage_win(tabpage_T *tpc)\n{\n    tabpage_T\t*tp;\n    win_T\t*wp;\n\n    FOR_ALL_TABPAGES(tp)\n    {\n\tif (tp == tpc)\n\t{\n\t    FOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t    {\n\t\tif (win_valid_any_tab(wp))\n\t\t    return TRUE;\n\t    }\n\t    return FALSE;\n\t}\n    }\n    // shouldn't happen\n    return FALSE;\n}\n\n/*\n * Close tabpage \"tab\", assuming it has no windows in it.\n * There must be another tabpage or this will crash.\n */\n    void\nclose_tabpage(tabpage_T *tab)\n{\n    tabpage_T\t*ptp;\n\n    if (tab == first_tabpage)\n    {\n\tfirst_tabpage = tab->tp_next;\n\tptp = first_tabpage;\n    }\n    else\n    {\n\tfor (ptp = first_tabpage; ptp != NULL && ptp->tp_next != tab;\n\t\t\t\t\t\t\t    ptp = ptp->tp_next)\n\t    ;\n\tassert(ptp != NULL);\n\tptp->tp_next = tab->tp_next;\n    }\n\n    goto_tabpage_tp(ptp, FALSE, FALSE);\n    free_tabpage(tab);\n}\n\n/*\n * Find tab page \"n\" (first one is 1).  Returns NULL when not found.\n */\n    tabpage_T *\nfind_tabpage(int n)\n{\n    tabpage_T\t*tp;\n    int\t\ti = 1;\n\n    if (n == 0)\n\treturn curtab;\n\n    for (tp = first_tabpage; tp != NULL && i != n; tp = tp->tp_next)\n\t++i;\n    return tp;\n}\n\n/*\n * Get index of tab page \"tp\".  First one has index 1.\n * When not found returns number of tab pages plus one.\n */\n    int\ntabpage_index(tabpage_T *ftp)\n{\n    int\t\ti = 1;\n    tabpage_T\t*tp;\n\n    for (tp = first_tabpage; tp != NULL && tp != ftp; tp = tp->tp_next)\n\t++i;\n    return i;\n}\n\n/*\n * Prepare for leaving the current tab page.\n * When autocommands change \"curtab\" we don't leave the tab page and return\n * FAIL.\n * Careful: When OK is returned need to get a new tab page very very soon!\n */\n    static int\nleave_tabpage(\n    buf_T\t*new_curbuf UNUSED,    // what is going to be the new curbuf,\n\t\t\t\t       // NULL if unknown\n    int\t\ttrigger_leave_autocmds UNUSED)\n{\n    tabpage_T\t*tp = curtab;\n\n#ifdef FEAT_JOB_CHANNEL\n    leaving_window(curwin);\n#endif\n    reset_VIsual_and_resel();\t// stop Visual mode\n    if (trigger_leave_autocmds)\n    {\n\tif (new_curbuf != curbuf)\n\t{\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    if (curtab != tp)\n\t\treturn FAIL;\n\t}\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (curtab != tp)\n\t    return FAIL;\n\tapply_autocmds(EVENT_TABLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (curtab != tp)\n\t    return FAIL;\n    }\n#if defined(FEAT_GUI)\n    // Remove the scrollbars.  They may be added back later.\n    if (gui.in_use)\n\tgui_remove_scrollbars();\n#endif\n    tp->tp_curwin = curwin;\n    tp->tp_prevwin = prevwin;\n    tp->tp_firstwin = firstwin;\n    tp->tp_lastwin = lastwin;\n    tp->tp_old_Rows = Rows;\n    if (tp->tp_old_Columns != -1)\n\ttp->tp_old_Columns = Columns;\n    firstwin = NULL;\n    lastwin = NULL;\n    return OK;\n}\n\n/*\n * Start using tab page \"tp\".\n * Only to be used after leave_tabpage() or freeing the current tab page.\n * Only trigger *Enter autocommands when trigger_enter_autocmds is TRUE.\n * Only trigger *Leave autocommands when trigger_leave_autocmds is TRUE.\n */\n    static void\nenter_tabpage(\n    tabpage_T\t*tp,\n    buf_T\t*old_curbuf UNUSED,\n    int\t\ttrigger_enter_autocmds,\n    int\t\ttrigger_leave_autocmds)\n{\n    int\t\trow;\n    int\t\told_off = tp->tp_firstwin->w_winrow;\n    win_T\t*next_prevwin = tp->tp_prevwin;\n    tabpage_T\t*last_tab = curtab;\n\n    curtab = tp;\n    firstwin = tp->tp_firstwin;\n    lastwin = tp->tp_lastwin;\n    topframe = tp->tp_topframe;\n\n    // We would like doing the TabEnter event first, but we don't have a\n    // valid current window yet, which may break some commands.\n    // This triggers autocommands, thus may make \"tp\" invalid.\n    (void)win_enter_ext(tp->tp_curwin, WEE_CURWIN_INVALID\n\t\t  | (trigger_enter_autocmds ? WEE_TRIGGER_ENTER_AUTOCMDS : 0)\n\t\t  | (trigger_leave_autocmds ? WEE_TRIGGER_LEAVE_AUTOCMDS : 0));\n    prevwin = next_prevwin;\n\n    last_status(FALSE);\t\t// status line may appear or disappear\n    row = win_comp_pos();\t// recompute w_winrow for all windows\n#ifdef FEAT_DIFF\n    diff_need_scrollbind = TRUE;\n#endif\n\n    // The tabpage line may have appeared or disappeared, may need to resize\n    // the frames for that.  When the Vim window was resized need to update\n    // frame sizes too.  Use the stored value of p_ch, so that it can be\n    // different for each tab page.\n    if (p_ch != curtab->tp_ch_used)\n\tclear_cmdline = TRUE;\n    p_ch = curtab->tp_ch_used;\n\n    // When cmdheight is changed in a tab page with '<C-w>-', cmdline_row is\n    // changed but p_ch and tp_ch_used are not changed. Thus we also need to\n    // check cmdline_row.\n    if ((row < cmdline_row) && (cmdline_row <= Rows - p_ch))\n\tclear_cmdline = TRUE;\n\n    if (curtab->tp_old_Rows != Rows || (old_off != firstwin->w_winrow\n#ifdef FEAT_GUI_TABLINE\n\t\t\t    && !gui_use_tabline()\n#endif\n\t\t))\n\tshell_new_rows();\n    if (curtab->tp_old_Columns != Columns)\n    {\n\tif (starting == 0)\n\t{\n\t    shell_new_columns();\t// update window widths\n\t    curtab->tp_old_Columns = Columns;\n\t}\n\telse\n\t    curtab->tp_old_Columns = -1;  // update window widths later\n    }\n\n    lastused_tabpage = last_tab;\n\n#if defined(FEAT_GUI)\n    // When 'guioptions' includes 'L' or 'R' may have to remove or add\n    // scrollbars.  Have to update them anyway.\n    gui_may_update_scrollbars();\n#endif\n\n    // Apply autocommands after updating the display, when 'rows' and\n    // 'columns' have been set correctly.\n    if (trigger_enter_autocmds)\n    {\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\tif (old_curbuf != curbuf)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Go to tab page \"n\".  For \":tab N\" and \"Ngt\".\n * When \"n\" is 9999 go to the last tab page.\n */\n    void\ngoto_tabpage(int n)\n{\n    tabpage_T\t*tp = NULL;  // shut up compiler\n    tabpage_T\t*ttp;\n    int\t\ti;\n\n    if (text_locked())\n    {\n\t// Not allowed when editing the command line.\n\ttext_locked_msg();\n\treturn;\n    }\n\n    // If there is only one it can't work.\n    if (first_tabpage->tp_next == NULL)\n    {\n\tif (n > 1)\n\t    beep_flush();\n\treturn;\n    }\n\n    if (n == 0)\n    {\n\t// No count, go to next tab page, wrap around end.\n\tif (curtab->tp_next == NULL)\n\t    tp = first_tabpage;\n\telse\n\t    tp = curtab->tp_next;\n    }\n    else if (n < 0)\n    {\n\t// \"gT\": go to previous tab page, wrap around end.  \"N gT\" repeats\n\t// this N times.\n\tttp = curtab;\n\tfor (i = n; i < 0; ++i)\n\t{\n\t    for (tp = first_tabpage; tp->tp_next != ttp && tp->tp_next != NULL;\n\t\t    tp = tp->tp_next)\n\t\t;\n\t    ttp = tp;\n\t}\n    }\n    else if (n == 9999)\n    {\n\t// Go to last tab page.\n\tfor (tp = first_tabpage; tp->tp_next != NULL; tp = tp->tp_next)\n\t    ;\n    }\n    else\n    {\n\t// Go to tab page \"n\".\n\ttp = find_tabpage(n);\n\tif (tp == NULL)\n\t{\n\t    beep_flush();\n\t    return;\n\t}\n    }\n\n    goto_tabpage_tp(tp, TRUE, TRUE);\n\n#ifdef FEAT_GUI_TABLINE\n    if (gui_use_tabline())\n\tgui_mch_set_curtab(tabpage_index(curtab));\n#endif\n}\n\n/*\n * Go to tabpage \"tp\".\n * Only trigger *Enter autocommands when trigger_enter_autocmds is TRUE.\n * Only trigger *Leave autocommands when trigger_leave_autocmds is TRUE.\n * Note: doesn't update the GUI tab.\n */\n    void\ngoto_tabpage_tp(\n    tabpage_T\t*tp,\n    int\t\ttrigger_enter_autocmds,\n    int\t\ttrigger_leave_autocmds)\n{\n    if (trigger_enter_autocmds || trigger_leave_autocmds)\n\tCHECK_CMDWIN;\n\n    // Don't repeat a message in another tab page.\n    set_keep_msg(NULL, 0);\n\n    if (tp != curtab && leave_tabpage(tp->tp_curwin->w_buffer,\n\t\t\t\t\ttrigger_leave_autocmds) == OK)\n    {\n\tif (valid_tabpage(tp))\n\t    enter_tabpage(tp, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n\telse\n\t    enter_tabpage(curtab, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n    }\n}\n\n/*\n * Go to the last accessed tab page, if there is one.\n * Return OK or FAIL\n */\n    int\ngoto_tabpage_lastused(void)\n{\n    if (valid_tabpage(lastused_tabpage))\n    {\n\tgoto_tabpage_tp(lastused_tabpage, TRUE, TRUE);\n\treturn OK;\n    }\n    return FAIL;\n}\n\n/*\n * Enter window \"wp\" in tab page \"tp\".\n * Also updates the GUI tab.\n */\n    void\ngoto_tabpage_win(tabpage_T *tp, win_T *wp)\n{\n    goto_tabpage_tp(tp, TRUE, TRUE);\n    if (curtab == tp && win_valid(wp))\n    {\n\twin_enter(wp, TRUE);\n# ifdef FEAT_GUI_TABLINE\n\tif (gui_use_tabline())\n\t    gui_mch_set_curtab(tabpage_index(curtab));\n# endif\n    }\n}\n\n/*\n * Move the current tab page to after tab page \"nr\".\n */\n    void\ntabpage_move(int nr)\n{\n    int\t\tn = 1;\n    tabpage_T\t*tp, *tp_dst;\n\n    if (first_tabpage->tp_next == NULL)\n\treturn;\n\n    for (tp = first_tabpage; tp->tp_next != NULL && n < nr; tp = tp->tp_next)\n\t++n;\n\n    if (tp == curtab || (nr > 0 && tp->tp_next != NULL\n\t\t\t\t\t\t    && tp->tp_next == curtab))\n\treturn;\n\n    tp_dst = tp;\n\n    // Remove the current tab page from the list of tab pages.\n    if (curtab == first_tabpage)\n\tfirst_tabpage = curtab->tp_next;\n    else\n    {\n\tFOR_ALL_TABPAGES(tp)\n\t    if (tp->tp_next == curtab)\n\t\tbreak;\n\tif (tp == NULL)\t// \"cannot happen\"\n\t    return;\n\ttp->tp_next = curtab->tp_next;\n    }\n\n    // Re-insert it at the specified position.\n    if (nr <= 0)\n    {\n\tcurtab->tp_next = first_tabpage;\n\tfirst_tabpage = curtab;\n    }\n    else\n    {\n\tcurtab->tp_next = tp_dst->tp_next;\n\ttp_dst->tp_next = curtab;\n    }\n\n    // Need to redraw the tabline.  Tab page contents doesn't change.\n    redraw_tabline = TRUE;\n}\n\n\n/*\n * Go to another window.\n * When jumping to another buffer, stop Visual mode.  Do this before\n * changing windows so we can yank the selection into the '*' register.\n * When jumping to another window on the same buffer, adjust its cursor\n * position to keep the same Visual area.\n */\n    void\nwin_goto(win_T *wp)\n{\n#ifdef FEAT_CONCEAL\n    win_T\t*owp = curwin;\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (popup_is_popup(wp))\n    {\n\temsg(_(e_not_allowed_to_enter_popup_window));\n\treturn;\n    }\n#endif\n    if (text_or_buf_locked())\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n    if (wp->w_buffer != curbuf)\n\treset_VIsual_and_resel();\n    else if (VIsual_active)\n\twp->w_cursor = curwin->w_cursor;\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n    win_enter(wp, TRUE);\n\n#ifdef FEAT_CONCEAL\n    // Conceal cursor line in previous window, unconceal in current window.\n    if (win_valid(owp) && owp->w_p_cole > 0 && !msg_scrolled)\n\tredrawWinline(owp, owp->w_cursor.lnum);\n    if (curwin->w_p_cole > 0 && !msg_scrolled)\n\tneed_cursor_line_redraw = TRUE;\n#endif\n}\n\n#if defined(FEAT_PERL) || defined(PROTO)\n/*\n * Find window number \"winnr\" (counting top to bottom).\n */\n    win_T *\nwin_find_nr(int winnr)\n{\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (--winnr == 0)\n\t    break;\n    return wp;\n}\n#endif\n\n#if ((defined(FEAT_PYTHON) || defined(FEAT_PYTHON3))) || defined(PROTO)\n/*\n * Find the tabpage for window \"win\".\n */\n    tabpage_T *\nwin_find_tabpage(win_T *win)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t    if (wp == win)\n\t\treturn tp;\n    return NULL;\n}\n#endif\n\n/*\n * Get the above or below neighbor window of the specified window.\n *   up - TRUE for the above neighbor\n *   count - nth neighbor window\n * Returns the specified window if the neighbor is not found.\n */\n    win_T *\nwin_vert_neighbor(tabpage_T *tp, win_T *wp, int up, long count)\n{\n    frame_T\t*fr;\n    frame_T\t*nfr;\n    frame_T\t*foundfr;\n\n#ifdef FEAT_PROP_POPUP\n    if (popup_is_popup(wp))\n\t// popups don't have neighbors.\n\treturn NULL;\n#endif\n    foundfr = wp->w_frame;\n    while (count--)\n    {\n\t/*\n\t * First go upwards in the tree of frames until we find a upwards or\n\t * downwards neighbor.\n\t */\n\tfr = foundfr;\n\tfor (;;)\n\t{\n\t    if (fr == tp->tp_topframe)\n\t\tgoto end;\n\t    if (up)\n\t\tnfr = fr->fr_prev;\n\t    else\n\t\tnfr = fr->fr_next;\n\t    if (fr->fr_parent->fr_layout == FR_COL && nfr != NULL)\n\t\tbreak;\n\t    fr = fr->fr_parent;\n\t}\n\n\t/*\n\t * Now go downwards to find the bottom or top frame in it.\n\t */\n\tfor (;;)\n\t{\n\t    if (nfr->fr_layout == FR_LEAF)\n\t    {\n\t\tfoundfr = nfr;\n\t\tbreak;\n\t    }\n\t    fr = nfr->fr_child;\n\t    if (nfr->fr_layout == FR_ROW)\n\t    {\n\t\t// Find the frame at the cursor row.\n\t\twhile (fr->fr_next != NULL\n\t\t\t&& frame2win(fr)->w_wincol + fr->fr_width\n\t\t\t\t\t <= wp->w_wincol + wp->w_wcol)\n\t\t    fr = fr->fr_next;\n\t    }\n\t    if (nfr->fr_layout == FR_COL && up)\n\t\twhile (fr->fr_next != NULL)\n\t\t    fr = fr->fr_next;\n\t    nfr = fr;\n\t}\n    }\nend:\n    return foundfr != NULL ? foundfr->fr_win : NULL;\n}\n\n/*\n * Move to window above or below \"count\" times.\n */\n    static void\nwin_goto_ver(\n    int\t\tup,\t\t// TRUE to go to win above\n    long\tcount)\n{\n    win_T\t*win;\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n#endif\n    win = win_vert_neighbor(curtab, curwin, up, count);\n    if (win != NULL)\n\twin_goto(win);\n}\n\n/*\n * Get the left or right neighbor window of the specified window.\n *   left - TRUE for the left neighbor\n *   count - nth neighbor window\n * Returns the specified window if the neighbor is not found.\n */\n    win_T *\nwin_horz_neighbor(tabpage_T *tp, win_T *wp, int left, long count)\n{\n    frame_T\t*fr;\n    frame_T\t*nfr;\n    frame_T\t*foundfr;\n\n#ifdef FEAT_PROP_POPUP\n    if (popup_is_popup(wp))\n\t// popups don't have neighbors.\n\treturn NULL;\n#endif\n    foundfr = wp->w_frame;\n    while (count--)\n    {\n\t/*\n\t * First go upwards in the tree of frames until we find a left or\n\t * right neighbor.\n\t */\n\tfr = foundfr;\n\tfor (;;)\n\t{\n\t    if (fr == tp->tp_topframe)\n\t\tgoto end;\n\t    if (left)\n\t\tnfr = fr->fr_prev;\n\t    else\n\t\tnfr = fr->fr_next;\n\t    if (fr->fr_parent->fr_layout == FR_ROW && nfr != NULL)\n\t\tbreak;\n\t    fr = fr->fr_parent;\n\t}\n\n\t/*\n\t * Now go downwards to find the leftmost or rightmost frame in it.\n\t */\n\tfor (;;)\n\t{\n\t    if (nfr->fr_layout == FR_LEAF)\n\t    {\n\t\tfoundfr = nfr;\n\t\tbreak;\n\t    }\n\t    fr = nfr->fr_child;\n\t    if (nfr->fr_layout == FR_COL)\n\t    {\n\t\t// Find the frame at the cursor row.\n\t\twhile (fr->fr_next != NULL\n\t\t\t&& frame2win(fr)->w_winrow + fr->fr_height\n\t\t\t\t\t <= wp->w_winrow + wp->w_wrow)\n\t\t    fr = fr->fr_next;\n\t    }\n\t    if (nfr->fr_layout == FR_ROW && left)\n\t\twhile (fr->fr_next != NULL)\n\t\t    fr = fr->fr_next;\n\t    nfr = fr;\n\t}\n    }\nend:\n    return foundfr != NULL ? foundfr->fr_win : NULL;\n}\n\n/*\n * Move to left or right window.\n */\n    static void\nwin_goto_hor(\n    int\t\tleft,\t\t// TRUE to go to left win\n    long\tcount)\n{\n    win_T\t*win;\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n#endif\n    win = win_horz_neighbor(curtab, curwin, left, count);\n    if (win != NULL)\n\twin_goto(win);\n}\n\n/*\n * Make window \"wp\" the current window.\n */\n    void\nwin_enter(win_T *wp, int undo_sync)\n{\n    (void)win_enter_ext(wp, (undo_sync ? WEE_UNDO_SYNC : 0)\n\t\t    | WEE_TRIGGER_ENTER_AUTOCMDS | WEE_TRIGGER_LEAVE_AUTOCMDS);\n}\n\n/*\n * Used after making another window the current one: change directory if\n * needed.\n */\n    static void\nfix_current_dir(void)\n{\n    if (curwin->w_localdir != NULL || curtab->tp_localdir != NULL)\n    {\n\tchar_u\t*dirname;\n\n\t// Window or tab has a local directory: Save current directory as\n\t// global directory (unless that was done already) and change to the\n\t// local directory.\n\tif (globaldir == NULL)\n\t{\n\t    char_u\tcwd[MAXPATHL];\n\n\t    if (mch_dirname(cwd, MAXPATHL) == OK)\n\t\tglobaldir = vim_strsave(cwd);\n\t}\n\tif (curwin->w_localdir != NULL)\n\t    dirname = curwin->w_localdir;\n\telse\n\t    dirname = curtab->tp_localdir;\n\n\tif (mch_chdir((char *)dirname) == 0)\n\t{\n\t    last_chdir_reason = NULL;\n\t    shorten_fnames(TRUE);\n\t}\n    }\n    else if (globaldir != NULL)\n    {\n\t// Window doesn't have a local directory and we are not in the global\n\t// directory: Change to the global directory.\n\tvim_ignored = mch_chdir((char *)globaldir);\n\tVIM_CLEAR(globaldir);\n\tlast_chdir_reason = NULL;\n\tshorten_fnames(TRUE);\n    }\n}\n\n/*\n * Make window \"wp\" the current window.\n * Can be called with \"flags\" containing WEE_CURWIN_INVALID, which means that\n * curwin has just been closed and isn't valid.\n * Returns TRUE when dont_parse_messages was decremented.\n */\n    static int\nwin_enter_ext(win_T *wp, int flags)\n{\n    int\t\tother_buffer = FALSE;\n    int\t\tcurwin_invalid = (flags & WEE_CURWIN_INVALID);\n    int\t\tdid_decrement = FALSE;\n\n    if (wp == curwin && !curwin_invalid)\t// nothing to do\n\treturn FALSE;\n\n#ifdef FEAT_JOB_CHANNEL\n    if (!curwin_invalid)\n\tleaving_window(curwin);\n#endif\n\n    if (!curwin_invalid && (flags & WEE_TRIGGER_LEAVE_AUTOCMDS))\n    {\n\t/*\n\t * Be careful: If autocommands delete the window, return now.\n\t */\n\tif (wp->w_buffer != curbuf)\n\t{\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    other_buffer = TRUE;\n\t    if (!win_valid(wp))\n\t\treturn FALSE;\n\t}\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (!win_valid(wp))\n\t    return FALSE;\n#ifdef FEAT_EVAL\n\t// autocmds may abort script processing\n\tif (aborting())\n\t    return FALSE;\n#endif\n    }\n\n    // sync undo before leaving the current buffer\n    if ((flags & WEE_UNDO_SYNC) && curbuf != wp->w_buffer)\n\tu_sync(FALSE);\n\n    // Might need to scroll the old window before switching, e.g., when the\n    // cursor was moved.\n    update_topline();\n\n    // may have to copy the buffer options when 'cpo' contains 'S'\n    if (wp->w_buffer != curbuf)\n\tbuf_copy_options(wp->w_buffer, BCO_ENTER | BCO_NOHELP);\n    if (!curwin_invalid)\n    {\n\tprevwin = curwin;\t// remember for CTRL-W p\n\tcurwin->w_redr_status = TRUE;\n    }\n    curwin = wp;\n    curbuf = wp->w_buffer;\n    check_cursor();\n    if (!virtual_active())\n\tcurwin->w_cursor.coladd = 0;\n    changed_line_abv_curs();\t// assume cursor position needs updating\n\n    // Now it is OK to parse messages again, which may be needed in\n    // autocommands.\n#ifdef MESSAGE_QUEUE\n    if (flags & WEE_ALLOW_PARSE_MESSAGES)\n    {\n\t--dont_parse_messages;\n\tdid_decrement = TRUE;\n    }\n#endif\n\n    fix_current_dir();\n\n#ifdef FEAT_JOB_CHANNEL\n    entering_window(curwin);\n#endif\n    // Careful: autocommands may close the window and make \"wp\" invalid\n    if (flags & WEE_TRIGGER_NEW_AUTOCMDS)\n\tapply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);\n    if (flags & WEE_TRIGGER_ENTER_AUTOCMDS)\n    {\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tif (other_buffer)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    maketitle();\n    curwin->w_redr_status = TRUE;\n#ifdef FEAT_TERMINAL\n    if (bt_terminal(curwin->w_buffer))\n\t// terminal is likely in another mode\n\tredraw_mode = TRUE;\n#endif\n    redraw_tabline = TRUE;\n    if (restart_edit)\n\tredraw_later(VALID);\t// causes status line redraw\n\n    // set window height to desired minimal value\n    if (curwin->w_height < p_wh && !curwin->w_p_wfh\n#ifdef FEAT_PROP_POPUP\n\t    && !popup_is_popup(curwin)\n#endif\n\t    )\n\twin_setheight((int)p_wh);\n    else if (curwin->w_height == 0)\n\twin_setheight(1);\n\n    // set window width to desired minimal value\n    if (curwin->w_width < p_wiw && !curwin->w_p_wfw)\n\twin_setwidth((int)p_wiw);\n\n    setmouse();\t\t\t// in case jumped to/from help buffer\n\n    // Change directories when the 'acd' option is set.\n    DO_AUTOCHDIR;\n\n    return did_decrement;\n}\n\n/*\n * Jump to the first open window that contains buffer \"buf\", if one exists.\n * Returns a pointer to the window found, otherwise NULL.\n */\n    win_T *\nbuf_jump_open_win(buf_T *buf)\n{\n    win_T\t*wp = NULL;\n\n    if (curwin->w_buffer == buf)\n\twp = curwin;\n    else\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_buffer == buf)\n\t\tbreak;\n    if (wp != NULL)\n\twin_enter(wp, FALSE);\n    return wp;\n}\n\n/*\n * Jump to the first open window in any tab page that contains buffer \"buf\",\n * if one exists. First search in the windows present in the current tab page.\n * Returns a pointer to the window found, otherwise NULL.\n */\n    win_T *\nbuf_jump_open_tab(buf_T *buf)\n{\n    win_T\t*wp = buf_jump_open_win(buf);\n    tabpage_T\t*tp;\n\n    if (wp != NULL)\n\treturn wp;\n\n    FOR_ALL_TABPAGES(tp)\n\tif (tp != curtab)\n\t{\n\t    FOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t\tif (wp->w_buffer == buf)\n\t\t    break;\n\t    if (wp != NULL)\n\t    {\n\t\tgoto_tabpage_win(tp, wp);\n\t\tif (curwin != wp)\n\t\t    wp = NULL;\t// something went wrong\n\t\tbreak;\n\t    }\n\t}\n    return wp;\n}\n\nstatic int last_win_id = LOWEST_WIN_ID - 1;\n\n/*\n * Allocate a window structure and link it in the window list when \"hidden\" is\n * FALSE.\n */\n    static win_T *\nwin_alloc(win_T *after UNUSED, int hidden UNUSED)\n{\n    win_T\t*new_wp;\n\n    /*\n     * allocate window structure and linesizes arrays\n     */\n    new_wp = ALLOC_CLEAR_ONE(win_T);\n    if (new_wp == NULL)\n\treturn NULL;\n\n    if (win_alloc_lines(new_wp) == FAIL)\n    {\n\tvim_free(new_wp);\n\treturn NULL;\n    }\n\n    new_wp->w_id = ++last_win_id;\n\n#ifdef FEAT_EVAL\n    // init w: variables\n    new_wp->w_vars = dict_alloc_id(aid_newwin_wvars);\n    if (new_wp->w_vars == NULL)\n    {\n\twin_free_lsize(new_wp);\n\tvim_free(new_wp);\n\treturn NULL;\n    }\n    init_var_dict(new_wp->w_vars, &new_wp->w_winvar, VAR_SCOPE);\n#endif\n\n    // Don't execute autocommands while the window is not properly\n    // initialized yet.  gui_create_scrollbar() may trigger a FocusGained\n    // event.\n    block_autocmds();\n\n    /*\n     * link the window in the window list\n     */\n    if (!hidden)\n\twin_append(after, new_wp);\n    new_wp->w_wincol = 0;\n    new_wp->w_width = Columns;\n\n    // position the display and the cursor at the top of the file.\n    new_wp->w_topline = 1;\n#ifdef FEAT_DIFF\n    new_wp->w_topfill = 0;\n#endif\n    new_wp->w_botline = 2;\n    new_wp->w_cursor.lnum = 1;\n    new_wp->w_scbind_pos = 1;\n\n    // use global option value for global-local options\n    new_wp->w_p_so = -1;\n    new_wp->w_p_siso = -1;\n\n    // We won't calculate w_fraction until resizing the window\n    new_wp->w_fraction = 0;\n    new_wp->w_prev_fraction_row = -1;\n\n#ifdef FEAT_GUI\n    if (gui.in_use)\n    {\n\tgui_create_scrollbar(&new_wp->w_scrollbars[SBAR_LEFT],\n\t\tSBAR_LEFT, new_wp);\n\tgui_create_scrollbar(&new_wp->w_scrollbars[SBAR_RIGHT],\n\t\tSBAR_RIGHT, new_wp);\n    }\n#endif\n#ifdef FEAT_FOLDING\n    foldInitWin(new_wp);\n#endif\n    unblock_autocmds();\n#ifdef FEAT_SEARCH_EXTRA\n    new_wp->w_match_head = NULL;\n    new_wp->w_next_match_id = 4;\n#endif\n    return new_wp;\n}\n\n/*\n * Remove window 'wp' from the window list and free the structure.\n */\n    static void\nwin_free(\n    win_T\t*wp,\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    int\t\ti;\n    buf_T\t*buf;\n    wininfo_T\t*wip;\n\n#ifdef FEAT_FOLDING\n    clearFolding(wp);\n#endif\n\n    // reduce the reference count to the argument list.\n    alist_unlink(wp->w_alist);\n\n    // Don't execute autocommands while the window is halfway being deleted.\n    // gui_mch_destroy_scrollbar() may trigger a FocusGained event.\n    block_autocmds();\n\n#ifdef FEAT_LUA\n    lua_window_free(wp);\n#endif\n\n#ifdef FEAT_MZSCHEME\n    mzscheme_window_free(wp);\n#endif\n\n#ifdef FEAT_PERL\n    perl_win_free(wp);\n#endif\n\n#ifdef FEAT_PYTHON\n    python_window_free(wp);\n#endif\n\n#ifdef FEAT_PYTHON3\n    python3_window_free(wp);\n#endif\n\n#ifdef FEAT_TCL\n    tcl_window_free(wp);\n#endif\n\n#ifdef FEAT_RUBY\n    ruby_window_free(wp);\n#endif\n\n    clear_winopt(&wp->w_onebuf_opt);\n    clear_winopt(&wp->w_allbuf_opt);\n\n    vim_free(wp->w_lcs_chars.multispace);\n\n#ifdef FEAT_EVAL\n    vars_clear(&wp->w_vars->dv_hashtab);\t// free all w: variables\n    hash_init(&wp->w_vars->dv_hashtab);\n    unref_var_dict(wp->w_vars);\n#endif\n\n    {\n\ttabpage_T\t*ttp;\n\n\tif (prevwin == wp)\n\t    prevwin = NULL;\n\tFOR_ALL_TABPAGES(ttp)\n\t    if (ttp->tp_prevwin == wp)\n\t\tttp->tp_prevwin = NULL;\n    }\n    win_free_lsize(wp);\n\n    for (i = 0; i < wp->w_tagstacklen; ++i)\n    {\n\tvim_free(wp->w_tagstack[i].tagname);\n\tvim_free(wp->w_tagstack[i].user_data);\n    }\n    vim_free(wp->w_localdir);\n    vim_free(wp->w_prevdir);\n\n    // Remove the window from the b_wininfo lists, it may happen that the\n    // freed memory is re-used for another window.\n    FOR_ALL_BUFFERS(buf)\n\tFOR_ALL_BUF_WININFO(buf, wip)\n\t    if (wip->wi_win == wp)\n\t    {\n\t\twininfo_T\t*wip2;\n\n\t\t// If there already is an entry with \"wi_win\" set to NULL it\n\t\t// must be removed, it would never be used.\n\t\t// Skip \"wip\" itself, otherwise Coverity complains.\n\t\tfor (wip2 = buf->b_wininfo; wip2 != NULL; wip2 = wip2->wi_next)\n\t\t    if (wip2 != wip && wip2->wi_win == NULL)\n\t\t    {\n\t\t\tif (wip2->wi_next != NULL)\n\t\t\t    wip2->wi_next->wi_prev = wip2->wi_prev;\n\t\t\tif (wip2->wi_prev == NULL)\n\t\t\t    buf->b_wininfo = wip2->wi_next;\n\t\t\telse\n\t\t\t    wip2->wi_prev->wi_next = wip2->wi_next;\n\t\t\tfree_wininfo(wip2);\n\t\t\tbreak;\n\t\t    }\n\n\t\twip->wi_win = NULL;\n\t    }\n\n#ifdef FEAT_SEARCH_EXTRA\n    clear_matches(wp);\n#endif\n\n    free_jumplist(wp);\n\n#ifdef FEAT_QUICKFIX\n    qf_free_all(wp);\n#endif\n\n#ifdef FEAT_GUI\n    if (gui.in_use)\n    {\n\tgui_mch_destroy_scrollbar(&wp->w_scrollbars[SBAR_LEFT]);\n\tgui_mch_destroy_scrollbar(&wp->w_scrollbars[SBAR_RIGHT]);\n    }\n#endif // FEAT_GUI\n\n#ifdef FEAT_MENU\n    remove_winbar(wp);\n#endif\n#ifdef FEAT_PROP_POPUP\n    free_callback(&wp->w_close_cb);\n    free_callback(&wp->w_filter_cb);\n    for (i = 0; i < 4; ++i)\n\tVIM_CLEAR(wp->w_border_highlight[i]);\n    vim_free(wp->w_scrollbar_highlight);\n    vim_free(wp->w_thumb_highlight);\n    vim_free(wp->w_popup_title);\n    list_unref(wp->w_popup_mask);\n    vim_free(wp->w_popup_mask_cells);\n#endif\n\n#ifdef FEAT_SYN_HL\n    vim_free(wp->w_p_cc_cols);\n#endif\n\n    if (win_valid_any_tab(wp))\n\twin_remove(wp, tp);\n    if (autocmd_busy)\n    {\n\twp->w_next = au_pending_free_win;\n\tau_pending_free_win = wp;\n    }\n    else\n\tvim_free(wp);\n\n    unblock_autocmds();\n}\n\n/*\n * Return TRUE if \"wp\" is not in the list of windows: the autocmd window or a\n * popup window.\n */\n    int\nwin_unlisted(win_T *wp)\n{\n    return wp == aucmd_win || WIN_IS_POPUP(wp);\n}\n\n#if defined(FEAT_PROP_POPUP) || defined(PROTO)\n/*\n * Free a popup window.  This does not take the window out of the window list\n * and assumes there is only one toplevel frame, no split.\n */\n    void\nwin_free_popup(win_T *win)\n{\n    if (win->w_buffer != NULL)\n    {\n\tif (bt_popup(win->w_buffer))\n\t    win_close_buffer(win, DOBUF_WIPE_REUSE, FALSE);\n\telse\n\t    close_buffer(win, win->w_buffer, 0, FALSE, FALSE);\n    }\n# if defined(FEAT_TIMERS)\n    if (win->w_popup_timer != NULL)\n\tstop_timer(win->w_popup_timer);\n# endif\n    vim_free(win->w_frame);\n    win_free(win, NULL);\n}\n#endif\n\n/*\n * Append window \"wp\" in the window list after window \"after\".\n */\n    static void\nwin_append(win_T *after, win_T *wp)\n{\n    win_T\t*before;\n\n    if (after == NULL)\t    // after NULL is in front of the first\n\tbefore = firstwin;\n    else\n\tbefore = after->w_next;\n\n    wp->w_next = before;\n    wp->w_prev = after;\n    if (after == NULL)\n\tfirstwin = wp;\n    else\n\tafter->w_next = wp;\n    if (before == NULL)\n\tlastwin = wp;\n    else\n\tbefore->w_prev = wp;\n}\n\n/*\n * Remove a window from the window list.\n */\n    void\nwin_remove(\n    win_T\t*wp,\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    if (wp->w_prev != NULL)\n\twp->w_prev->w_next = wp->w_next;\n    else if (tp == NULL)\n\tfirstwin = curtab->tp_firstwin = wp->w_next;\n    else\n\ttp->tp_firstwin = wp->w_next;\n\n    if (wp->w_next != NULL)\n\twp->w_next->w_prev = wp->w_prev;\n    else if (tp == NULL)\n\tlastwin = curtab->tp_lastwin = wp->w_prev;\n    else\n\ttp->tp_lastwin = wp->w_prev;\n}\n\n/*\n * Append frame \"frp\" in a frame list after frame \"after\".\n */\n    static void\nframe_append(frame_T *after, frame_T *frp)\n{\n    frp->fr_next = after->fr_next;\n    after->fr_next = frp;\n    if (frp->fr_next != NULL)\n\tfrp->fr_next->fr_prev = frp;\n    frp->fr_prev = after;\n}\n\n/*\n * Insert frame \"frp\" in a frame list before frame \"before\".\n */\n    static void\nframe_insert(frame_T *before, frame_T *frp)\n{\n    frp->fr_next = before;\n    frp->fr_prev = before->fr_prev;\n    before->fr_prev = frp;\n    if (frp->fr_prev != NULL)\n\tfrp->fr_prev->fr_next = frp;\n    else\n\tfrp->fr_parent->fr_child = frp;\n}\n\n/*\n * Remove a frame from a frame list.\n */\n    static void\nframe_remove(frame_T *frp)\n{\n    if (frp->fr_prev != NULL)\n\tfrp->fr_prev->fr_next = frp->fr_next;\n    else\n\tfrp->fr_parent->fr_child = frp->fr_next;\n    if (frp->fr_next != NULL)\n\tfrp->fr_next->fr_prev = frp->fr_prev;\n}\n\n/*\n * Allocate w_lines[] for window \"wp\".\n * Return FAIL for failure, OK for success.\n */\n    int\nwin_alloc_lines(win_T *wp)\n{\n    wp->w_lines_valid = 0;\n    wp->w_lines = ALLOC_CLEAR_MULT(wline_T, Rows);\n    if (wp->w_lines == NULL)\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * free lsize arrays for a window\n */\n    void\nwin_free_lsize(win_T *wp)\n{\n    // TODO: why would wp be NULL here?\n    if (wp != NULL)\n\tVIM_CLEAR(wp->w_lines);\n}\n\n/*\n * Called from win_new_shellsize() after Rows changed.\n * This only does the current tab page, others must be done when made active.\n */\n    void\nshell_new_rows(void)\n{\n    int\t\th = (int)ROWS_AVAIL;\n\n    if (firstwin == NULL)\t// not initialized yet\n\treturn;\n    if (h < frame_minheight(topframe, NULL))\n\th = frame_minheight(topframe, NULL);\n\n    // First try setting the heights of windows with 'winfixheight'.  If\n    // that doesn't result in the right height, forget about that option.\n    frame_new_height(topframe, h, FALSE, TRUE);\n    if (!frame_check_height(topframe, h))\n\tframe_new_height(topframe, h, FALSE, FALSE);\n\n    (void)win_comp_pos();\t\t// recompute w_winrow and w_wincol\n    compute_cmdrow();\n    curtab->tp_ch_used = p_ch;\n\n#if 0\n    // Disabled: don't want making the screen smaller make a window larger.\n    if (p_ea)\n\twin_equal(curwin, FALSE, 'v');\n#endif\n}\n\n/*\n * Called from win_new_shellsize() after Columns changed.\n */\n    void\nshell_new_columns(void)\n{\n    if (firstwin == NULL)\t// not initialized yet\n\treturn;\n\n    // First try setting the widths of windows with 'winfixwidth'.  If that\n    // doesn't result in the right width, forget about that option.\n    frame_new_width(topframe, (int)Columns, FALSE, TRUE);\n    if (!frame_check_width(topframe, Columns))\n\tframe_new_width(topframe, (int)Columns, FALSE, FALSE);\n\n    (void)win_comp_pos();\t\t// recompute w_winrow and w_wincol\n#if 0\n    // Disabled: don't want making the screen smaller make a window larger.\n    if (p_ea)\n\twin_equal(curwin, FALSE, 'h');\n#endif\n}\n\n#if defined(FEAT_CMDWIN) || defined(PROTO)\n/*\n * Save the size of all windows in \"gap\".\n */\n    void\nwin_size_save(garray_T *gap)\n\n{\n    win_T\t*wp;\n\n    ga_init2(gap, sizeof(int), 1);\n    if (ga_grow(gap, win_count() * 2 + 1) == OK)\n    {\n\t// first entry is value of 'lines'\n\t((int *)gap->ga_data)[gap->ga_len++] = Rows;\n\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    ((int *)gap->ga_data)[gap->ga_len++] =\n\t\t\t\t\t       wp->w_width + wp->w_vsep_width;\n\t    ((int *)gap->ga_data)[gap->ga_len++] = wp->w_height;\n\t}\n    }\n}\n\n/*\n * Restore window sizes, but only if the number of windows is still the same\n * and 'lines' didn't change.\n * Does not free the growarray.\n */\n    void\nwin_size_restore(garray_T *gap)\n{\n    win_T\t*wp;\n    int\t\ti, j;\n\n    if (win_count() * 2 + 1 == gap->ga_len\n\t    && ((int *)gap->ga_data)[0] == Rows)\n    {\n\t// The order matters, because frames contain other frames, but it's\n\t// difficult to get right. The easy way out is to do it twice.\n\tfor (j = 0; j < 2; ++j)\n\t{\n\t    i = 1;\n\t    FOR_ALL_WINDOWS(wp)\n\t    {\n\t\tframe_setwidth(wp->w_frame, ((int *)gap->ga_data)[i++]);\n\t\twin_setheight_win(((int *)gap->ga_data)[i++], wp);\n\t    }\n\t}\n\t// recompute the window positions\n\t(void)win_comp_pos();\n    }\n}\n#endif // FEAT_CMDWIN\n\n/*\n * Update the position for all windows, using the width and height of the\n * frames.\n * Returns the row just after the last window.\n */\n    int\nwin_comp_pos(void)\n{\n    int\t\trow = tabline_height();\n    int\t\tcol = 0;\n\n    frame_comp_pos(topframe, &row, &col);\n    return row;\n}\n\n/*\n * Update the position of the windows in frame \"topfrp\", using the width and\n * height of the frames.\n * \"*row\" and \"*col\" are the top-left position of the frame.  They are updated\n * to the bottom-right position plus one.\n */\n    static void\nframe_comp_pos(frame_T *topfrp, int *row, int *col)\n{\n    win_T\t*wp;\n    frame_T\t*frp;\n    int\t\tstartcol;\n    int\t\tstartrow;\n    int\t\th;\n\n    wp = topfrp->fr_win;\n    if (wp != NULL)\n    {\n\tif (wp->w_winrow != *row || wp->w_wincol != *col)\n\t{\n\t    // position changed, redraw\n\t    wp->w_winrow = *row;\n\t    wp->w_wincol = *col;\n\t    redraw_win_later(wp, NOT_VALID);\n\t    wp->w_redr_status = TRUE;\n\t}\n\t// WinBar will not show if the window height is zero\n\th = VISIBLE_HEIGHT(wp) + wp->w_status_height;\n\t*row += h > topfrp->fr_height ? topfrp->fr_height : h;\n\t*col += wp->w_width + wp->w_vsep_width;\n    }\n    else\n    {\n\tstartrow = *row;\n\tstartcol = *col;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    if (topfrp->fr_layout == FR_ROW)\n\t\t*row = startrow;\t// all frames are at the same row\n\t    else\n\t\t*col = startcol;\t// all frames are at the same col\n\t    frame_comp_pos(frp, row, col);\n\t}\n    }\n}\n\n/*\n * Make the current window show at least one line and one column.\n */\n    void\nwin_ensure_size()\n{\n    if (curwin->w_height == 0)\n\twin_setheight(1);\n    if (curwin->w_width == 0)\n\twin_setwidth(1);\n}\n\n/*\n * Set current window height and take care of repositioning other windows to\n * fit around it.\n */\n    void\nwin_setheight(int height)\n{\n    win_setheight_win(height, curwin);\n}\n\n/*\n * Set the window height of window \"win\" and take care of repositioning other\n * windows to fit around it.\n */\n    void\nwin_setheight_win(int height, win_T *win)\n{\n    int\t\trow;\n\n    if (win == curwin)\n    {\n\t// Always keep current window at least one line high, even when\n\t// 'winminheight' is zero.\n\tif (height < p_wmh)\n\t    height = p_wmh;\n\tif (height == 0)\n\t    height = 1;\n\theight += WINBAR_HEIGHT(curwin);\n    }\n\n    frame_setheight(win->w_frame, height + win->w_status_height);\n\n    // recompute the window positions\n    row = win_comp_pos();\n\n    /*\n     * If there is extra space created between the last window and the command\n     * line, clear it.\n     */\n    if (full_screen && msg_scrolled == 0 && row < cmdline_row)\n\tscreen_fill(row, cmdline_row, 0, (int)Columns, ' ', ' ', 0);\n    cmdline_row = row;\n    msg_row = row;\n    msg_col = 0;\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Set the height of a frame to \"height\" and take care that all frames and\n * windows inside it are resized.  Also resize frames on the left and right if\n * the are in the same FR_ROW frame.\n *\n * Strategy:\n * If the frame is part of a FR_COL frame, try fitting the frame in that\n * frame.  If that doesn't work (the FR_COL frame is too small), recursively\n * go to containing frames to resize them and make room.\n * If the frame is part of a FR_ROW frame, all frames must be resized as well.\n * Check for the minimal height of the FR_ROW frame.\n * At the top level we can also use change the command line height.\n */\n    static void\nframe_setheight(frame_T *curfrp, int height)\n{\n    int\t\troom;\t\t// total number of lines available\n    int\t\ttake;\t\t// number of lines taken from other windows\n    int\t\troom_cmdline;\t// lines available from cmdline\n    int\t\trun;\n    frame_T\t*frp;\n    int\t\th;\n    int\t\troom_reserved;\n\n    // If the height already is the desired value, nothing to do.\n    if (curfrp->fr_height == height)\n\treturn;\n\n    if (curfrp->fr_parent == NULL)\n    {\n\t// topframe: can only change the command line\n\tif (height > ROWS_AVAIL)\n\t    height = ROWS_AVAIL;\n\tif (height > 0)\n\t    frame_new_height(curfrp, height, FALSE, FALSE);\n    }\n    else if (curfrp->fr_parent->fr_layout == FR_ROW)\n    {\n\t// Row of frames: Also need to resize frames left and right of this\n\t// one.  First check for the minimal height of these.\n\th = frame_minheight(curfrp->fr_parent, NULL);\n\tif (height < h)\n\t    height = h;\n\tframe_setheight(curfrp->fr_parent, height);\n    }\n    else\n    {\n\t/*\n\t * Column of frames: try to change only frames in this column.\n\t */\n\t/*\n\t * Do this twice:\n\t * 1: compute room available, if it's not enough try resizing the\n\t *    containing frame.\n\t * 2: compute the room available and adjust the height to it.\n\t * Try not to reduce the height of a window with 'winfixheight' set.\n\t */\n\tfor (run = 1; run <= 2; ++run)\n\t{\n\t    room = 0;\n\t    room_reserved = 0;\n\t    FOR_ALL_FRAMES(frp, curfrp->fr_parent->fr_child)\n\t    {\n\t\tif (frp != curfrp\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfh)\n\t\t    room_reserved += frp->fr_height;\n\t\troom += frp->fr_height;\n\t\tif (frp != curfrp)\n\t\t    room -= frame_minheight(frp, NULL);\n\t    }\n\t    if (curfrp->fr_width != Columns)\n\t\troom_cmdline = 0;\n\t    else\n\t    {\n\t\troom_cmdline = Rows - p_ch - (lastwin->w_winrow\n\t\t\t\t\t\t+ VISIBLE_HEIGHT(lastwin)\n\t\t\t\t\t\t+ lastwin->w_status_height);\n\t\tif (room_cmdline < 0)\n\t\t    room_cmdline = 0;\n\t    }\n\n\t    if (height <= room + room_cmdline)\n\t\tbreak;\n\t    if (run == 2 || curfrp->fr_width == Columns)\n\t    {\n\t\theight = room + room_cmdline;\n\t\tbreak;\n\t    }\n\t    frame_setheight(curfrp->fr_parent, height\n\t\t+ frame_minheight(curfrp->fr_parent, NOWIN) - (int)p_wmh - 1);\n\t}\n\n\t/*\n\t * Compute the number of lines we will take from others frames (can be\n\t * negative!).\n\t */\n\ttake = height - curfrp->fr_height;\n\n\t// If there is not enough room, also reduce the height of a window\n\t// with 'winfixheight' set.\n\tif (height > room + room_cmdline - room_reserved)\n\t    room_reserved = room + room_cmdline - height;\n\t// If there is only a 'winfixheight' window and making the\n\t// window smaller, need to make the other window taller.\n\tif (take < 0 && room - curfrp->fr_height < room_reserved)\n\t    room_reserved = 0;\n\n\tif (take > 0 && room_cmdline > 0)\n\t{\n\t    // use lines from cmdline first\n\t    if (take < room_cmdline)\n\t\troom_cmdline = take;\n\t    take -= room_cmdline;\n\t    topframe->fr_height += room_cmdline;\n\t}\n\n\t/*\n\t * set the current frame to the new height\n\t */\n\tframe_new_height(curfrp, height, FALSE, FALSE);\n\n\t/*\n\t * First take lines from the frames after the current frame.  If\n\t * that is not enough, takes lines from frames above the current\n\t * frame.\n\t */\n\tfor (run = 0; run < 2; ++run)\n\t{\n\t    if (run == 0)\n\t\tfrp = curfrp->fr_next;\t// 1st run: start with next window\n\t    else\n\t\tfrp = curfrp->fr_prev;\t// 2nd run: start with prev window\n\t    while (frp != NULL && take != 0)\n\t    {\n\t\th = frame_minheight(frp, NULL);\n\t\tif (room_reserved > 0\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfh)\n\t\t{\n\t\t    if (room_reserved >= frp->fr_height)\n\t\t\troom_reserved -= frp->fr_height;\n\t\t    else\n\t\t    {\n\t\t\tif (frp->fr_height - room_reserved > take)\n\t\t\t    room_reserved = frp->fr_height - take;\n\t\t\ttake -= frp->fr_height - room_reserved;\n\t\t\tframe_new_height(frp, room_reserved, FALSE, FALSE);\n\t\t\troom_reserved = 0;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (frp->fr_height - take < h)\n\t\t    {\n\t\t\ttake -= frp->fr_height - h;\n\t\t\tframe_new_height(frp, h, FALSE, FALSE);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tframe_new_height(frp, frp->fr_height - take,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\t\t\ttake = 0;\n\t\t    }\n\t\t}\n\t\tif (run == 0)\n\t\t    frp = frp->fr_next;\n\t\telse\n\t\t    frp = frp->fr_prev;\n\t    }\n\t}\n    }\n}\n\n/*\n * Set current window width and take care of repositioning other windows to\n * fit around it.\n */\n    void\nwin_setwidth(int width)\n{\n    win_setwidth_win(width, curwin);\n}\n\n    void\nwin_setwidth_win(int width, win_T *wp)\n{\n    // Always keep current window at least one column wide, even when\n    // 'winminwidth' is zero.\n    if (wp == curwin)\n    {\n\tif (width < p_wmw)\n\t    width = p_wmw;\n\tif (width == 0)\n\t    width = 1;\n    }\n    else if (width < 0)\n\twidth = 0;\n\n    frame_setwidth(wp->w_frame, width + wp->w_vsep_width);\n\n    // recompute the window positions\n    (void)win_comp_pos();\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Set the width of a frame to \"width\" and take care that all frames and\n * windows inside it are resized.  Also resize frames above and below if the\n * are in the same FR_ROW frame.\n *\n * Strategy is similar to frame_setheight().\n */\n    static void\nframe_setwidth(frame_T *curfrp, int width)\n{\n    int\t\troom;\t\t// total number of lines available\n    int\t\ttake;\t\t// number of lines taken from other windows\n    int\t\trun;\n    frame_T\t*frp;\n    int\t\tw;\n    int\t\troom_reserved;\n\n    // If the width already is the desired value, nothing to do.\n    if (curfrp->fr_width == width)\n\treturn;\n\n    if (curfrp->fr_parent == NULL)\n\t// topframe: can't change width\n\treturn;\n\n    if (curfrp->fr_parent->fr_layout == FR_COL)\n    {\n\t// Column of frames: Also need to resize frames above and below of\n\t// this one.  First check for the minimal width of these.\n\tw = frame_minwidth(curfrp->fr_parent, NULL);\n\tif (width < w)\n\t    width = w;\n\tframe_setwidth(curfrp->fr_parent, width);\n    }\n    else\n    {\n\t/*\n\t * Row of frames: try to change only frames in this row.\n\t *\n\t * Do this twice:\n\t * 1: compute room available, if it's not enough try resizing the\n\t *    containing frame.\n\t * 2: compute the room available and adjust the width to it.\n\t */\n\tfor (run = 1; run <= 2; ++run)\n\t{\n\t    room = 0;\n\t    room_reserved = 0;\n\t    FOR_ALL_FRAMES(frp, curfrp->fr_parent->fr_child)\n\t    {\n\t\tif (frp != curfrp\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfw)\n\t\t    room_reserved += frp->fr_width;\n\t\troom += frp->fr_width;\n\t\tif (frp != curfrp)\n\t\t    room -= frame_minwidth(frp, NULL);\n\t    }\n\n\t    if (width <= room)\n\t\tbreak;\n\t    if (run == 2 || curfrp->fr_height >= ROWS_AVAIL)\n\t    {\n\t\twidth = room;\n\t\tbreak;\n\t    }\n\t    frame_setwidth(curfrp->fr_parent, width\n\t\t + frame_minwidth(curfrp->fr_parent, NOWIN) - (int)p_wmw - 1);\n\t}\n\n\t/*\n\t * Compute the number of lines we will take from others frames (can be\n\t * negative!).\n\t */\n\ttake = width - curfrp->fr_width;\n\n\t// If there is not enough room, also reduce the width of a window\n\t// with 'winfixwidth' set.\n\tif (width > room - room_reserved)\n\t    room_reserved = room - width;\n\t// If there is only a 'winfixwidth' window and making the\n\t// window smaller, need to make the other window narrower.\n\tif (take < 0 && room - curfrp->fr_width < room_reserved)\n\t    room_reserved = 0;\n\n\t/*\n\t * set the current frame to the new width\n\t */\n\tframe_new_width(curfrp, width, FALSE, FALSE);\n\n\t/*\n\t * First take lines from the frames right of the current frame.  If\n\t * that is not enough, takes lines from frames left of the current\n\t * frame.\n\t */\n\tfor (run = 0; run < 2; ++run)\n\t{\n\t    if (run == 0)\n\t\tfrp = curfrp->fr_next;\t// 1st run: start with next window\n\t    else\n\t\tfrp = curfrp->fr_prev;\t// 2nd run: start with prev window\n\t    while (frp != NULL && take != 0)\n\t    {\n\t\tw = frame_minwidth(frp, NULL);\n\t\tif (room_reserved > 0\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfw)\n\t\t{\n\t\t    if (room_reserved >= frp->fr_width)\n\t\t\troom_reserved -= frp->fr_width;\n\t\t    else\n\t\t    {\n\t\t\tif (frp->fr_width - room_reserved > take)\n\t\t\t    room_reserved = frp->fr_width - take;\n\t\t\ttake -= frp->fr_width - room_reserved;\n\t\t\tframe_new_width(frp, room_reserved, FALSE, FALSE);\n\t\t\troom_reserved = 0;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (frp->fr_width - take < w)\n\t\t    {\n\t\t\ttake -= frp->fr_width - w;\n\t\t\tframe_new_width(frp, w, FALSE, FALSE);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tframe_new_width(frp, frp->fr_width - take,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\t\t\ttake = 0;\n\t\t    }\n\t\t}\n\t\tif (run == 0)\n\t\t    frp = frp->fr_next;\n\t\telse\n\t\t    frp = frp->fr_prev;\n\t    }\n\t}\n    }\n}\n\n/*\n * Check 'winminheight' for a valid value and reduce it if needed.\n */\n    void\nwin_setminheight(void)\n{\n    int\t\troom;\n    int\t\tneeded;\n    int\t\tfirst = TRUE;\n\n    // loop until there is a 'winminheight' that is possible\n    while (p_wmh > 0)\n    {\n\troom = Rows - p_ch;\n\tneeded = min_rows() - 1;  // 1 was added for the cmdline\n\tif (room >= needed)\n\t    break;\n\t--p_wmh;\n\tif (first)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    first = FALSE;\n\t}\n    }\n}\n\n/*\n * Check 'winminwidth' for a valid value and reduce it if needed.\n */\n    void\nwin_setminwidth(void)\n{\n    int\t\troom;\n    int\t\tneeded;\n    int\t\tfirst = TRUE;\n\n    // loop until there is a 'winminheight' that is possible\n    while (p_wmw > 0)\n    {\n\troom = Columns;\n\tneeded = frame_minwidth(topframe, NULL);\n\tif (room >= needed)\n\t    break;\n\t--p_wmw;\n\tif (first)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    first = FALSE;\n\t}\n    }\n}\n\n/*\n * Status line of dragwin is dragged \"offset\" lines down (negative is up).\n */\n    void\nwin_drag_status_line(win_T *dragwin, int offset)\n{\n    frame_T\t*curfr;\n    frame_T\t*fr;\n    int\t\troom;\n    int\t\trow;\n    int\t\tup;\t// if TRUE, drag status line up, otherwise down\n    int\t\tn;\n\n    fr = dragwin->w_frame;\n    curfr = fr;\n    if (fr != topframe)\t\t// more than one window\n    {\n\tfr = fr->fr_parent;\n\t// When the parent frame is not a column of frames, its parent should\n\t// be.\n\tif (fr->fr_layout != FR_COL)\n\t{\n\t    curfr = fr;\n\t    if (fr != topframe)\t// only a row of windows, may drag statusline\n\t\tfr = fr->fr_parent;\n\t}\n    }\n\n    // If this is the last frame in a column, may want to resize the parent\n    // frame instead (go two up to skip a row of frames).\n    while (curfr != topframe && curfr->fr_next == NULL)\n    {\n\tif (fr != topframe)\n\t    fr = fr->fr_parent;\n\tcurfr = fr;\n\tif (fr != topframe)\n\t    fr = fr->fr_parent;\n    }\n\n    if (offset < 0) // drag up\n    {\n\tup = TRUE;\n\toffset = -offset;\n\t// sum up the room of the current frame and above it\n\tif (fr == curfr)\n\t{\n\t    // only one window\n\t    room = fr->fr_height - frame_minheight(fr, NULL);\n\t}\n\telse\n\t{\n\t    room = 0;\n\t    for (fr = fr->fr_child; ; fr = fr->fr_next)\n\t    {\n\t\troom += fr->fr_height - frame_minheight(fr, NULL);\n\t\tif (fr == curfr)\n\t\t    break;\n\t    }\n\t}\n\tfr = curfr->fr_next;\t\t// put fr at frame that grows\n    }\n    else    // drag down\n    {\n\tup = FALSE;\n\t/*\n\t * Only dragging the last status line can reduce p_ch.\n\t */\n\troom = Rows - cmdline_row;\n\tif (curfr->fr_next == NULL)\n\t    room -= 1;\n\telse\n\t    room -= p_ch;\n\tif (room < 0)\n\t    room = 0;\n\t// sum up the room of frames below of the current one\n\tFOR_ALL_FRAMES(fr, curfr->fr_next)\n\t    room += fr->fr_height - frame_minheight(fr, NULL);\n\tfr = curfr;\t\t\t// put fr at window that grows\n    }\n\n    if (room < offset)\t\t// Not enough room\n\toffset = room;\t\t// Move as far as we can\n    if (offset <= 0)\n\treturn;\n\n    /*\n     * Grow frame fr by \"offset\" lines.\n     * Doesn't happen when dragging the last status line up.\n     */\n    if (fr != NULL)\n\tframe_new_height(fr, fr->fr_height + offset, up, FALSE);\n\n    if (up)\n\tfr = curfr;\t\t// current frame gets smaller\n    else\n\tfr = curfr->fr_next;\t// next frame gets smaller\n\n    /*\n     * Now make the other frames smaller.\n     */\n    while (fr != NULL && offset > 0)\n    {\n\tn = frame_minheight(fr, NULL);\n\tif (fr->fr_height - offset <= n)\n\t{\n\t    offset -= fr->fr_height - n;\n\t    frame_new_height(fr, n, !up, FALSE);\n\t}\n\telse\n\t{\n\t    frame_new_height(fr, fr->fr_height - offset, !up, FALSE);\n\t    break;\n\t}\n\tif (up)\n\t    fr = fr->fr_prev;\n\telse\n\t    fr = fr->fr_next;\n    }\n    row = win_comp_pos();\n    screen_fill(row, cmdline_row, 0, (int)Columns, ' ', ' ', 0);\n    cmdline_row = row;\n    p_ch = Rows - cmdline_row;\n    if (p_ch < 1)\n\tp_ch = 1;\n    curtab->tp_ch_used = p_ch;\n    redraw_all_later(SOME_VALID);\n    showmode();\n}\n\n/*\n * Separator line of dragwin is dragged \"offset\" lines right (negative is left).\n */\n    void\nwin_drag_vsep_line(win_T *dragwin, int offset)\n{\n    frame_T\t*curfr;\n    frame_T\t*fr;\n    int\t\troom;\n    int\t\tleft;\t// if TRUE, drag separator line left, otherwise right\n    int\t\tn;\n\n    fr = dragwin->w_frame;\n    if (fr == topframe)\t\t// only one window (cannot happen?)\n\treturn;\n    curfr = fr;\n    fr = fr->fr_parent;\n    // When the parent frame is not a row of frames, its parent should be.\n    if (fr->fr_layout != FR_ROW)\n    {\n\tif (fr == topframe)\t// only a column of windows (cannot happen?)\n\t    return;\n\tcurfr = fr;\n\tfr = fr->fr_parent;\n    }\n\n    // If this is the last frame in a row, may want to resize a parent\n    // frame instead.\n    while (curfr->fr_next == NULL)\n    {\n\tif (fr == topframe)\n\t    break;\n\tcurfr = fr;\n\tfr = fr->fr_parent;\n\tif (fr != topframe)\n\t{\n\t    curfr = fr;\n\t    fr = fr->fr_parent;\n\t}\n    }\n\n    if (offset < 0) // drag left\n    {\n\tleft = TRUE;\n\toffset = -offset;\n\t// sum up the room of the current frame and left of it\n\troom = 0;\n\tfor (fr = fr->fr_child; ; fr = fr->fr_next)\n\t{\n\t    room += fr->fr_width - frame_minwidth(fr, NULL);\n\t    if (fr == curfr)\n\t\tbreak;\n\t}\n\tfr = curfr->fr_next;\t\t// put fr at frame that grows\n    }\n    else    // drag right\n    {\n\tleft = FALSE;\n\t// sum up the room of frames right of the current one\n\troom = 0;\n\tFOR_ALL_FRAMES(fr, curfr->fr_next)\n\t    room += fr->fr_width - frame_minwidth(fr, NULL);\n\tfr = curfr;\t\t\t// put fr at window that grows\n    }\n\n    if (room < offset)\t\t// Not enough room\n\toffset = room;\t\t// Move as far as we can\n    if (offset <= 0)\t\t// No room at all, quit.\n\treturn;\n    if (fr == NULL)\n\t// This can happen when calling win_move_separator() on the rightmost\n\t// window.  Just don't do anything.\n\treturn;\t\t\t\n\n    // grow frame fr by offset lines\n    frame_new_width(fr, fr->fr_width + offset, left, FALSE);\n\n    // shrink other frames: current and at the left or at the right\n    if (left)\n\tfr = curfr;\t\t// current frame gets smaller\n    else\n\tfr = curfr->fr_next;\t// next frame gets smaller\n\n    while (fr != NULL && offset > 0)\n    {\n\tn = frame_minwidth(fr, NULL);\n\tif (fr->fr_width - offset <= n)\n\t{\n\t    offset -= fr->fr_width - n;\n\t    frame_new_width(fr, n, !left, FALSE);\n\t}\n\telse\n\t{\n\t    frame_new_width(fr, fr->fr_width - offset, !left, FALSE);\n\t    break;\n\t}\n\tif (left)\n\t    fr = fr->fr_prev;\n\telse\n\t    fr = fr->fr_next;\n    }\n    (void)win_comp_pos();\n    redraw_all_later(NOT_VALID);\n}\n\n#define FRACTION_MULT\t16384L\n\n/*\n * Set wp->w_fraction for the current w_wrow and w_height.\n * Has no effect when the window is less than two lines.\n */\n    void\nset_fraction(win_T *wp)\n{\n    if (wp->w_height > 1)\n\t// When cursor is in the first line the percentage is computed as if\n\t// it's halfway that line.  Thus with two lines it is 25%, with three\n\t// lines 17%, etc.  Similarly for the last line: 75%, 83%, etc.\n\twp->w_fraction = ((long)wp->w_wrow * FRACTION_MULT\n\t\t\t\t     + FRACTION_MULT / 2) / (long)wp->w_height;\n}\n\n/*\n * Set the height of a window.\n * \"height\" excludes any window toolbar.\n * This takes care of the things inside the window, not what happens to the\n * window position, the frame or to other windows.\n */\n    void\nwin_new_height(win_T *wp, int height)\n{\n    int\t\tprev_height = wp->w_height;\n\n    // Don't want a negative height.  Happens when splitting a tiny window.\n    // Will equalize heights soon to fix it.\n    if (height < 0)\n\theight = 0;\n    if (wp->w_height == height)\n\treturn;\t    // nothing to do\n\n    if (wp->w_height > 0)\n    {\n\tif (wp == curwin)\n\t    // w_wrow needs to be valid. When setting 'laststatus' this may\n\t    // call win_new_height() recursively.\n\t    validate_cursor();\n\tif (wp->w_height != prev_height)\n\t    return;  // Recursive call already changed the size, bail out here\n\t\t     //\tto avoid the following to mess things up.\n\tif (wp->w_wrow != wp->w_prev_fraction_row)\n\t    set_fraction(wp);\n    }\n\n    wp->w_height = height;\n    wp->w_skipcol = 0;\n\n    // There is no point in adjusting the scroll position when exiting.  Some\n    // values might be invalid.\n    if (!exiting)\n\tscroll_to_fraction(wp, prev_height);\n}\n\n    void\nscroll_to_fraction(win_T *wp, int prev_height)\n{\n    linenr_T\tlnum;\n    int\t\tsline, line_size;\n    int\t\theight = wp->w_height;\n\n    // Don't change w_topline in any of these cases:\n    // - window height is 0\n    // - 'scrollbind' is set and this isn't the current window\n    // - window height is sufficient to display the whole buffer and first line\n    //   is visible.\n    if (height > 0\n\t   && (!wp->w_p_scb || wp == curwin)\n\t   && (height < wp->w_buffer->b_ml.ml_line_count || wp->w_topline > 1))\n    {\n\t/*\n\t * Find a value for w_topline that shows the cursor at the same\n\t * relative position in the window as before (more or less).\n\t */\n\tlnum = wp->w_cursor.lnum;\n\tif (lnum < 1)\t\t// can happen when starting up\n\t    lnum = 1;\n\twp->w_wrow = ((long)wp->w_fraction * (long)height - 1L)\n\t\t\t\t\t\t\t       / FRACTION_MULT;\n\tline_size = plines_win_col(wp, lnum, (long)(wp->w_cursor.col)) - 1;\n\tsline = wp->w_wrow - line_size;\n\n\tif (sline >= 0)\n\t{\n\t    // Make sure the whole cursor line is visible, if possible.\n\t    int rows = plines_win(wp, lnum, FALSE);\n\n\t    if (sline > wp->w_height - rows)\n\t    {\n\t\tsline = wp->w_height - rows;\n\t\twp->w_wrow -= rows - line_size;\n\t    }\n\t}\n\n\tif (sline < 0)\n\t{\n\t    /*\n\t     * Cursor line would go off top of screen if w_wrow was this high.\n\t     * Make cursor line the first line in the window.  If not enough\n\t     * room use w_skipcol;\n\t     */\n\t    wp->w_wrow = line_size;\n\t    if (wp->w_wrow >= wp->w_height\n\t\t\t\t       && (wp->w_width - win_col_off(wp)) > 0)\n\t    {\n\t\twp->w_skipcol += wp->w_width - win_col_off(wp);\n\t\t--wp->w_wrow;\n\t\twhile (wp->w_wrow >= wp->w_height)\n\t\t{\n\t\t    wp->w_skipcol += wp->w_width - win_col_off(wp)\n\t\t\t\t\t\t\t   + win_col_off2(wp);\n\t\t    --wp->w_wrow;\n\t\t}\n\t    }\n\t}\n\telse if (sline > 0)\n\t{\n\t    while (sline > 0 && lnum > 1)\n\t    {\n#ifdef FEAT_FOLDING\n\t\thasFoldingWin(wp, lnum, &lnum, NULL, TRUE, NULL);\n\t\tif (lnum == 1)\n\t\t{\n\t\t    // first line in buffer is folded\n\t\t    line_size = 1;\n\t\t    --sline;\n\t\t    break;\n\t\t}\n#endif\n\t\t--lnum;\n#ifdef FEAT_DIFF\n\t\tif (lnum == wp->w_topline)\n\t\t    line_size = plines_win_nofill(wp, lnum, TRUE)\n\t\t\t\t\t\t\t      + wp->w_topfill;\n\t\telse\n#endif\n\t\t    line_size = plines_win(wp, lnum, TRUE);\n\t\tsline -= line_size;\n\t    }\n\n\t    if (sline < 0)\n\t    {\n\t\t/*\n\t\t * Line we want at top would go off top of screen.  Use next\n\t\t * line instead.\n\t\t */\n#ifdef FEAT_FOLDING\n\t\thasFoldingWin(wp, lnum, NULL, &lnum, TRUE, NULL);\n#endif\n\t\tlnum++;\n\t\twp->w_wrow -= line_size + sline;\n\t    }\n\t    else if (sline > 0)\n\t    {\n\t\t// First line of file reached, use that as topline.\n\t\tlnum = 1;\n\t\twp->w_wrow -= sline;\n\t    }\n\t}\n\tset_topline(wp, lnum);\n    }\n\n    if (wp == curwin)\n    {\n\tif (get_scrolloff_value())\n\t    update_topline();\n\tcurs_columns(FALSE);\t// validate w_wrow\n    }\n    if (prev_height > 0)\n\twp->w_prev_fraction_row = wp->w_wrow;\n\n    win_comp_scroll(wp);\n    redraw_win_later(wp, SOME_VALID);\n    wp->w_redr_status = TRUE;\n    invalidate_botline_win(wp);\n}\n\n/*\n * Set the width of a window.\n */\n    void\nwin_new_width(win_T *wp, int width)\n{\n    wp->w_width = width;\n    wp->w_lines_valid = 0;\n    changed_line_abv_curs_win(wp);\n    invalidate_botline_win(wp);\n    if (wp == curwin)\n    {\n\tupdate_topline();\n\tcurs_columns(TRUE);\t// validate w_wrow\n    }\n    redraw_win_later(wp, NOT_VALID);\n    wp->w_redr_status = TRUE;\n}\n\n    void\nwin_comp_scroll(win_T *wp)\n{\n#if defined(FEAT_EVAL)\n    int old_w_p_scr = wp->w_p_scr;\n#endif\n\n    wp->w_p_scr = ((unsigned)wp->w_height >> 1);\n    if (wp->w_p_scr == 0)\n\twp->w_p_scr = 1;\n#if defined(FEAT_EVAL)\n    if (wp->w_p_scr != old_w_p_scr)\n    {\n\t// Used by \"verbose set scroll\".\n\twp->w_p_script_ctx[WV_SCROLL].sc_sid = SID_WINLAYOUT;\n\twp->w_p_script_ctx[WV_SCROLL].sc_lnum = 0;\n    }\n#endif\n}\n\n/*\n * command_height: called whenever p_ch has been changed\n */\n    void\ncommand_height(void)\n{\n    int\t\th;\n    frame_T\t*frp;\n    int\t\told_p_ch = curtab->tp_ch_used;\n\n    // Use the value of p_ch that we remembered.  This is needed for when the\n    // GUI starts up, we can't be sure in what order things happen.  And when\n    // p_ch was changed in another tab page.\n    curtab->tp_ch_used = p_ch;\n\n    // Find bottom frame with width of screen.\n    frp = lastwin->w_frame;\n    while (frp->fr_width != Columns && frp->fr_parent != NULL)\n\tfrp = frp->fr_parent;\n\n    // Avoid changing the height of a window with 'winfixheight' set.\n    while (frp->fr_prev != NULL && frp->fr_layout == FR_LEAF\n\t\t\t\t\t\t      && frp->fr_win->w_p_wfh)\n\tfrp = frp->fr_prev;\n\n    if (starting != NO_SCREEN)\n    {\n\tcmdline_row = Rows - p_ch;\n\n\tif (p_ch > old_p_ch)\t\t    // p_ch got bigger\n\t{\n\t    while (p_ch > old_p_ch)\n\t    {\n\t\tif (frp == NULL)\n\t\t{\n\t\t    emsg(_(e_not_enough_room));\n\t\t    p_ch = old_p_ch;\n\t\t    curtab->tp_ch_used = p_ch;\n\t\t    cmdline_row = Rows - p_ch;\n\t\t    break;\n\t\t}\n\t\th = frp->fr_height - frame_minheight(frp, NULL);\n\t\tif (h > p_ch - old_p_ch)\n\t\t    h = p_ch - old_p_ch;\n\t\told_p_ch += h;\n\t\tframe_add_height(frp, -h);\n\t\tfrp = frp->fr_prev;\n\t    }\n\n\t    // Recompute window positions.\n\t    (void)win_comp_pos();\n\n\t    // clear the lines added to cmdline\n\t    if (full_screen)\n\t\tscreen_fill(cmdline_row, (int)Rows, 0,\n\t\t\t\t\t\t   (int)Columns, ' ', ' ', 0);\n\t    msg_row = cmdline_row;\n\t    redraw_cmdline = TRUE;\n\t    return;\n\t}\n\n\tif (msg_row < cmdline_row)\n\t    msg_row = cmdline_row;\n\tredraw_cmdline = TRUE;\n    }\n    frame_add_height(frp, (int)(old_p_ch - p_ch));\n\n    // Recompute window positions.\n    if (frp != lastwin->w_frame)\n\t(void)win_comp_pos();\n}\n\n/*\n * Resize frame \"frp\" to be \"n\" lines higher (negative for less high).\n * Also resize the frames it is contained in.\n */\n    static void\nframe_add_height(frame_T *frp, int n)\n{\n    frame_new_height(frp, frp->fr_height + n, FALSE, FALSE);\n    for (;;)\n    {\n\tfrp = frp->fr_parent;\n\tif (frp == NULL)\n\t    break;\n\tfrp->fr_height += n;\n    }\n}\n\n/*\n * Add or remove a status line for the bottom window(s), according to the\n * value of 'laststatus'.\n */\n    void\nlast_status(\n    int\t\tmorewin)\t// pretend there are two or more windows\n{\n    // Don't make a difference between horizontal or vertical split.\n    last_status_rec(topframe, (p_ls == 2\n\t\t\t  || (p_ls == 1 && (morewin || !ONE_WINDOW))));\n}\n\n    static void\nlast_status_rec(frame_T *fr, int statusline)\n{\n    frame_T\t*fp;\n    win_T\t*wp;\n\n    if (fr->fr_layout == FR_LEAF)\n    {\n\twp = fr->fr_win;\n\tif (wp->w_status_height != 0 && !statusline)\n\t{\n\t    // remove status line\n\t    win_new_height(wp, wp->w_height + 1);\n\t    wp->w_status_height = 0;\n\t    comp_col();\n\t}\n\telse if (wp->w_status_height == 0 && statusline)\n\t{\n\t    // Find a frame to take a line from.\n\t    fp = fr;\n\t    while (fp->fr_height <= frame_minheight(fp, NULL))\n\t    {\n\t\tif (fp == topframe)\n\t\t{\n\t\t    emsg(_(e_not_enough_room));\n\t\t    return;\n\t\t}\n\t\t// In a column of frames: go to frame above.  If already at\n\t\t// the top or in a row of frames: go to parent.\n\t\tif (fp->fr_parent->fr_layout == FR_COL && fp->fr_prev != NULL)\n\t\t    fp = fp->fr_prev;\n\t\telse\n\t\t    fp = fp->fr_parent;\n\t    }\n\t    wp->w_status_height = 1;\n\t    if (fp != fr)\n\t    {\n\t\tframe_new_height(fp, fp->fr_height - 1, FALSE, FALSE);\n\t\tframe_fix_height(wp);\n\t\t(void)win_comp_pos();\n\t    }\n\t    else\n\t\twin_new_height(wp, wp->w_height - 1);\n\t    comp_col();\n\t    redraw_all_later(SOME_VALID);\n\t}\n    }\n    else if (fr->fr_layout == FR_ROW)\n    {\n\t// vertically split windows, set status line for each one\n\tFOR_ALL_FRAMES(fp, fr->fr_child)\n\t    last_status_rec(fp, statusline);\n    }\n    else\n    {\n\t// horizontally split window, set status line for last one\n\tfor (fp = fr->fr_child; fp->fr_next != NULL; fp = fp->fr_next)\n\t    ;\n\tlast_status_rec(fp, statusline);\n    }\n}\n\n/*\n * Return the number of lines used by the tab page line.\n */\n    int\ntabline_height(void)\n{\n#ifdef FEAT_GUI_TABLINE\n    // When the GUI has the tabline then this always returns zero.\n    if (gui_use_tabline())\n\treturn 0;\n#endif\n    switch (p_stal)\n    {\n\tcase 0: return 0;\n\tcase 1: return (first_tabpage->tp_next == NULL) ? 0 : 1;\n    }\n    return 1;\n}\n\n/*\n * Return the minimal number of rows that is needed on the screen to display\n * the current number of windows.\n */\n    int\nmin_rows(void)\n{\n    int\t\ttotal;\n    tabpage_T\t*tp;\n    int\t\tn;\n\n    if (firstwin == NULL)\t// not initialized yet\n\treturn MIN_LINES;\n\n    total = 0;\n    FOR_ALL_TABPAGES(tp)\n    {\n\tn = frame_minheight(tp->tp_topframe, NULL);\n\tif (total < n)\n\t    total = n;\n    }\n    total += tabline_height();\n    total += 1;\t\t// count the room for the command line\n    return total;\n}\n\n/*\n * Return TRUE if there is only one window and only one tab page, not\n * counting a help or preview window, unless it is the current window.\n * Does not count unlisted windows.\n */\n    int\nonly_one_window(void)\n{\n    int\t\tcount = 0;\n    win_T\t*wp;\n\n#if defined(FEAT_PROP_POPUP)\n    // If the current window is a popup then there always is another window.\n    if (popup_is_popup(curwin))\n\treturn FALSE;\n#endif\n\n    // If there is another tab page there always is another window.\n    if (first_tabpage->tp_next != NULL)\n\treturn FALSE;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_buffer != NULL\n\t\t&& (!((bt_help(wp->w_buffer) && !bt_help(curbuf))\n# ifdef FEAT_QUICKFIX\n\t\t    || wp->w_p_pvw\n# endif\n\t     ) || wp == curwin) && wp != aucmd_win)\n\t    ++count;\n    return (count <= 1);\n}\n\n/*\n * Correct the cursor line number in other windows.  Used after changing the\n * current buffer, and before applying autocommands.\n * When \"do_curwin\" is TRUE, also check current window.\n */\n    void\ncheck_lnums(int do_curwin)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif ((do_curwin || wp != curwin) && wp->w_buffer == curbuf)\n\t{\n\t    // save the original cursor position and topline\n\t    wp->w_save_cursor.w_cursor_save = wp->w_cursor;\n\t    wp->w_save_cursor.w_topline_save = wp->w_topline;\n\n\t    if (wp->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\twp->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    if (wp->w_topline > curbuf->b_ml.ml_line_count)\n\t\twp->w_topline = curbuf->b_ml.ml_line_count;\n\n\t    // save the corrected cursor position and topline\n\t    wp->w_save_cursor.w_cursor_corr = wp->w_cursor;\n\t    wp->w_save_cursor.w_topline_corr = wp->w_topline;\n\t}\n}\n\n/*\n * Reset cursor and topline to its stored values from check_lnums().\n * check_lnums() must have been called first!\n */\n    void\nreset_lnums()\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif (wp->w_buffer == curbuf)\n\t{\n\t    // Restore the value if the autocommand didn't change it.\n\t    if (EQUAL_POS(wp->w_save_cursor.w_cursor_corr, wp->w_cursor))\n\t\twp->w_cursor = wp->w_save_cursor.w_cursor_save;\n\t    if (wp->w_save_cursor.w_topline_corr == wp->w_topline)\n\t\twp->w_topline = wp->w_save_cursor.w_topline_save;\n\t}\n}\n\n/*\n * A snapshot of the window sizes, to restore them after closing the help\n * window.\n * Only these fields are used:\n * fr_layout\n * fr_width\n * fr_height\n * fr_next\n * fr_child\n * fr_win (only valid for the old curwin, NULL otherwise)\n */\n\n/*\n * Create a snapshot of the current frame sizes.\n */\n    void\nmake_snapshot(int idx)\n{\n    clear_snapshot(curtab, idx);\n    make_snapshot_rec(topframe, &curtab->tp_snapshot[idx]);\n}\n\n    static void\nmake_snapshot_rec(frame_T *fr, frame_T **frp)\n{\n    *frp = ALLOC_CLEAR_ONE(frame_T);\n    if (*frp == NULL)\n\treturn;\n    (*frp)->fr_layout = fr->fr_layout;\n    (*frp)->fr_width = fr->fr_width;\n    (*frp)->fr_height = fr->fr_height;\n    if (fr->fr_next != NULL)\n\tmake_snapshot_rec(fr->fr_next, &((*frp)->fr_next));\n    if (fr->fr_child != NULL)\n\tmake_snapshot_rec(fr->fr_child, &((*frp)->fr_child));\n    if (fr->fr_layout == FR_LEAF && fr->fr_win == curwin)\n\t(*frp)->fr_win = curwin;\n}\n\n/*\n * Remove any existing snapshot.\n */\n    static void\nclear_snapshot(tabpage_T *tp, int idx)\n{\n    clear_snapshot_rec(tp->tp_snapshot[idx]);\n    tp->tp_snapshot[idx] = NULL;\n}\n\n    static void\nclear_snapshot_rec(frame_T *fr)\n{\n    if (fr != NULL)\n    {\n\tclear_snapshot_rec(fr->fr_next);\n\tclear_snapshot_rec(fr->fr_child);\n\tvim_free(fr);\n    }\n}\n\n/*\n * Traverse a snapshot to find the previous curwin.\n */\n    static win_T *\nget_snapshot_curwin_rec(frame_T *ft)\n{\n    win_T\t*wp;\n\n    if (ft->fr_next != NULL)\n    {\n\tif ((wp = get_snapshot_curwin_rec(ft->fr_next)) != NULL)\n\t    return wp;\n    }\n    if (ft->fr_child != NULL)\n    {\n\tif ((wp = get_snapshot_curwin_rec(ft->fr_child)) != NULL)\n\t    return wp;\n    }\n\n    return ft->fr_win;\n}\n\n/*\n * Return the current window stored in the snapshot or NULL.\n */\n    static win_T *\nget_snapshot_curwin(int idx)\n{\n    if (curtab->tp_snapshot[idx] == NULL)\n\treturn NULL;\n\n    return get_snapshot_curwin_rec(curtab->tp_snapshot[idx]);\n}\n\n/*\n * Restore a previously created snapshot, if there is any.\n * This is only done if the screen size didn't change and the window layout is\n * still the same.\n */\n    void\nrestore_snapshot(\n    int\t\tidx,\n    int\t\tclose_curwin)\t    // closing current window\n{\n    win_T\t*wp;\n\n    if (curtab->tp_snapshot[idx] != NULL\n\t    && curtab->tp_snapshot[idx]->fr_width == topframe->fr_width\n\t    && curtab->tp_snapshot[idx]->fr_height == topframe->fr_height\n\t    && check_snapshot_rec(curtab->tp_snapshot[idx], topframe) == OK)\n    {\n\twp = restore_snapshot_rec(curtab->tp_snapshot[idx], topframe);\n\twin_comp_pos();\n\tif (wp != NULL && close_curwin)\n\t    win_goto(wp);\n\tredraw_all_later(NOT_VALID);\n    }\n    clear_snapshot(curtab, idx);\n}\n\n/*\n * Check if frames \"sn\" and \"fr\" have the same layout, same following frames\n * and same children.  And the window pointer is valid.\n */\n    static int\ncheck_snapshot_rec(frame_T *sn, frame_T *fr)\n{\n    if (sn->fr_layout != fr->fr_layout\n\t    || (sn->fr_next == NULL) != (fr->fr_next == NULL)\n\t    || (sn->fr_child == NULL) != (fr->fr_child == NULL)\n\t    || (sn->fr_next != NULL\n\t\t&& check_snapshot_rec(sn->fr_next, fr->fr_next) == FAIL)\n\t    || (sn->fr_child != NULL\n\t\t&& check_snapshot_rec(sn->fr_child, fr->fr_child) == FAIL)\n\t    || (sn->fr_win != NULL && !win_valid(sn->fr_win)))\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Copy the size of snapshot frame \"sn\" to frame \"fr\".  Do the same for all\n * following frames and children.\n * Returns a pointer to the old current window, or NULL.\n */\n    static win_T *\nrestore_snapshot_rec(frame_T *sn, frame_T *fr)\n{\n    win_T\t*wp = NULL;\n    win_T\t*wp2;\n\n    fr->fr_height = sn->fr_height;\n    fr->fr_width = sn->fr_width;\n    if (fr->fr_layout == FR_LEAF)\n    {\n\tframe_new_height(fr, fr->fr_height, FALSE, FALSE);\n\tframe_new_width(fr, fr->fr_width, FALSE, FALSE);\n\twp = sn->fr_win;\n    }\n    if (sn->fr_next != NULL)\n    {\n\twp2 = restore_snapshot_rec(sn->fr_next, fr->fr_next);\n\tif (wp2 != NULL)\n\t    wp = wp2;\n    }\n    if (sn->fr_child != NULL)\n    {\n\twp2 = restore_snapshot_rec(sn->fr_child, fr->fr_child);\n\tif (wp2 != NULL)\n\t    wp = wp2;\n    }\n    return wp;\n}\n\n#if defined(FEAT_GUI) || defined(PROTO)\n/*\n * Return TRUE if there is any vertically split window.\n */\n    int\nwin_hasvertsplit(void)\n{\n    frame_T\t*fr;\n\n    if (topframe->fr_layout == FR_ROW)\n\treturn TRUE;\n\n    if (topframe->fr_layout == FR_COL)\n\tFOR_ALL_FRAMES(fr, topframe->fr_child)\n\t    if (fr->fr_layout == FR_ROW)\n\t\treturn TRUE;\n\n    return FALSE;\n}\n#endif\n\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) || defined(PROTO)\n    int\nget_win_number(win_T *wp, win_T *first_win)\n{\n    int\t\ti = 1;\n    win_T\t*w;\n\n    for (w = first_win; w != NULL && w != wp; w = W_NEXT(w))\n\t++i;\n\n    if (w == NULL)\n\treturn 0;\n    else\n\treturn i;\n}\n\n    int\nget_tab_number(tabpage_T *tp UNUSED)\n{\n    int\t\ti = 1;\n    tabpage_T\t*t;\n\n    for (t = first_tabpage; t != NULL && t != tp; t = t->tp_next)\n\t++i;\n\n    if (t == NULL)\n\treturn 0;\n    else\n\treturn i;\n}\n#endif\n\n/*\n * Return TRUE if \"topfrp\" and its children are at the right height.\n */\n    static int\nframe_check_height(frame_T *topfrp, int height)\n{\n    frame_T *frp;\n\n    if (topfrp->fr_height != height)\n\treturn FALSE;\n\n    if (topfrp->fr_layout == FR_ROW)\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    if (frp->fr_height != height)\n\t\treturn FALSE;\n\n    return TRUE;\n}\n\n/*\n * Return TRUE if \"topfrp\" and its children are at the right width.\n */\n    static int\nframe_check_width(frame_T *topfrp, int width)\n{\n    frame_T *frp;\n\n    if (topfrp->fr_width != width)\n\treturn FALSE;\n\n    if (topfrp->fr_layout == FR_COL)\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    if (frp->fr_width != width)\n\t\treturn FALSE;\n\n    return TRUE;\n}\n\n#if defined(FEAT_SYN_HL) || defined(PROTO)\n/*\n * Simple int comparison function for use with qsort()\n */\n    static int\nint_cmp(const void *a, const void *b)\n{\n    return *(const int *)a - *(const int *)b;\n}\n\n/*\n * Handle setting 'colorcolumn' or 'textwidth' in window \"wp\".\n * Returns error message, NULL if it's OK.\n */\n    char *\ncheck_colorcolumn(win_T *wp)\n{\n    char_u\t*s;\n    int\t\tcol;\n    int\t\tcount = 0;\n    int\t\tcolor_cols[256];\n    int\t\ti;\n    int\t\tj = 0;\n\n    if (wp->w_buffer == NULL)\n\treturn NULL;  // buffer was closed\n\n    for (s = wp->w_p_cc; *s != NUL && count < 255;)\n    {\n\tif (*s == '-' || *s == '+')\n\t{\n\t    // -N and +N: add to 'textwidth'\n\t    col = (*s == '-') ? -1 : 1;\n\t    ++s;\n\t    if (!VIM_ISDIGIT(*s))\n\t\treturn e_invalid_argument;\n\t    col = col * getdigits(&s);\n\t    if (wp->w_buffer->b_p_tw == 0)\n\t\tgoto skip;  // 'textwidth' not set, skip this item\n\t    col += wp->w_buffer->b_p_tw;\n\t    if (col < 0)\n\t\tgoto skip;\n\t}\n\telse if (VIM_ISDIGIT(*s))\n\t    col = getdigits(&s);\n\telse\n\t    return e_invalid_argument;\n\tcolor_cols[count++] = col - 1;  // 1-based to 0-based\nskip:\n\tif (*s == NUL)\n\t    break;\n\tif (*s != ',')\n\t    return e_invalid_argument;\n\tif (*++s == NUL)\n\t    return e_invalid_argument;  // illegal trailing comma as in \"set cc=80,\"\n    }\n\n    vim_free(wp->w_p_cc_cols);\n    if (count == 0)\n\twp->w_p_cc_cols = NULL;\n    else\n    {\n\twp->w_p_cc_cols = ALLOC_MULT(int, count + 1);\n\tif (wp->w_p_cc_cols != NULL)\n\t{\n\t    // sort the columns for faster usage on screen redraw inside\n\t    // win_line()\n\t    qsort(color_cols, count, sizeof(int), int_cmp);\n\n\t    for (i = 0; i < count; ++i)\n\t\t// skip duplicates\n\t\tif (j == 0 || wp->w_p_cc_cols[j - 1] != color_cols[i])\n\t\t    wp->w_p_cc_cols[j++] = color_cols[i];\n\t    wp->w_p_cc_cols[j] = -1;  // end marker\n\t}\n    }\n\n    return NULL;  // no error\n}\n#endif\n"], "filenames": ["src/buffer.c", "src/ex_getln.c", "src/proto/ex_getln.pro", "src/testdir/test_substitute.vim", "src/version.c", "src/window.c"], "buggy_code_start_loc": [2410, 2742, 5, 1037, 736, 4588], "buggy_code_end_loc": [2416, 4381, 37, 1037, 736, 4596], "fixing_code_start_loc": [2410, 2743, 6, 1038, 737, 4588], "fixing_code_end_loc": [2411, 4401, 37, 1063, 739, 4592], "type": "CWE-122", "message": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.", "other": {"cve": {"id": "CVE-2022-1942", "sourceIdentifier": "security@huntr.dev", "published": "2022-05-31T14:15:07.833", "lastModified": "2023-05-03T12:15:37.887", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2."}, {"lang": "es", "value": "Un Desbordamiento de B\u00fafer en la Regi\u00f3n Heap de la Memoria en el repositorio de GitHub vim/vim versiones anteriores a 8.2"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.2.5043", "matchCriteriaId": "99D4F915-F169-4EB2-A108-6397E720B90E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:apple:macos:*:*:*:*:*:*:*:*", "versionEndExcluding": "13.0", "matchCriteriaId": "71E032AD-F827-4944-9699-BB1E6D4233FC"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "http://seclists.org/fulldisclosure/2022/Oct/28", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2022/Oct/41", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/vim/vim/commit/71223e2db87c2bf3b09aecb46266b56cda26191d", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/67ca4d3b-9175-43c1-925c-72a7091bc071", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00032.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/TYNK6SDCMOLQJOI3B4AOE66P2G2IH4ZM/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-32", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}, {"url": "https://support.apple.com/kb/HT213488", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/71223e2db87c2bf3b09aecb46266b56cda26191d"}}