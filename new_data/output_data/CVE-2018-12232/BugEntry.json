{"buggy_code": ["/*\n * NET\t\tAn implementation of the SOCKET network access protocol.\n *\n * Version:\t@(#)socket.c\t1.1.93\t18/02/95\n *\n * Authors:\tOrest Zborowski, <obz@Kodak.COM>\n *\t\tRoss Biro\n *\t\tFred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>\n *\n * Fixes:\n *\t\tAnonymous\t:\tNOTSOCK/BADF cleanup. Error fix in\n *\t\t\t\t\tshutdown()\n *\t\tAlan Cox\t:\tverify_area() fixes\n *\t\tAlan Cox\t:\tRemoved DDI\n *\t\tJonathan Kamens\t:\tSOCK_DGRAM reconnect bug\n *\t\tAlan Cox\t:\tMoved a load of checks to the very\n *\t\t\t\t\ttop level.\n *\t\tAlan Cox\t:\tMove address structures to/from user\n *\t\t\t\t\tmode above the protocol layers.\n *\t\tRob Janssen\t:\tAllow 0 length sends.\n *\t\tAlan Cox\t:\tAsynchronous I/O support (cribbed from the\n *\t\t\t\t\ttty drivers).\n *\t\tNiibe Yutaka\t:\tAsynchronous I/O for writes (4.4BSD style)\n *\t\tJeff Uphoff\t:\tMade max number of sockets command-line\n *\t\t\t\t\tconfigurable.\n *\t\tMatti Aarnio\t:\tMade the number of sockets dynamic,\n *\t\t\t\t\tto be allocated when needed, and mr.\n *\t\t\t\t\tUphoff's max is used as max to be\n *\t\t\t\t\tallowed to allocate.\n *\t\tLinus\t\t:\tArgh. removed all the socket allocation\n *\t\t\t\t\taltogether: it's in the inode now.\n *\t\tAlan Cox\t:\tMade sock_alloc()/sock_release() public\n *\t\t\t\t\tfor NetROM and future kernel nfsd type\n *\t\t\t\t\tstuff.\n *\t\tAlan Cox\t:\tsendmsg/recvmsg basics.\n *\t\tTom Dyas\t:\tExport net symbols.\n *\t\tMarcin Dalecki\t:\tFixed problems with CONFIG_NET=\"n\".\n *\t\tAlan Cox\t:\tAdded thread locking to sys_* calls\n *\t\t\t\t\tfor sockets. May have errors at the\n *\t\t\t\t\tmoment.\n *\t\tKevin Buhr\t:\tFixed the dumb errors in the above.\n *\t\tAndi Kleen\t:\tSome small cleanups, optimizations,\n *\t\t\t\t\tand fixed a copy_from_user() bug.\n *\t\tTigran Aivazian\t:\tsys_send(args) calls sys_sendto(args, NULL, 0)\n *\t\tTigran Aivazian\t:\tMade listen(2) backlog sanity checks\n *\t\t\t\t\tprotocol-independent\n *\n *\n *\t\tThis program is free software; you can redistribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n *\n *\n *\tThis module is effectively the top level interface to the BSD socket\n *\tparadigm.\n *\n *\tBased upon Swansea University Computer Society NET3.039\n */\n\n#include <linux/mm.h>\n#include <linux/socket.h>\n#include <linux/file.h>\n#include <linux/net.h>\n#include <linux/interrupt.h>\n#include <linux/thread_info.h>\n#include <linux/rcupdate.h>\n#include <linux/netdevice.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/if_bridge.h>\n#include <linux/if_frad.h>\n#include <linux/if_vlan.h>\n#include <linux/ptp_classify.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/cache.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/kmod.h>\n#include <linux/audit.h>\n#include <linux/wireless.h>\n#include <linux/nsproxy.h>\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/xattr.h>\n\n#include <linux/uaccess.h>\n#include <asm/unistd.h>\n\n#include <net/compat.h>\n#include <net/wext.h>\n#include <net/cls_cgroup.h>\n\n#include <net/sock.h>\n#include <linux/netfilter.h>\n\n#include <linux/if_tun.h>\n#include <linux/ipv6_route.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <net/busy_poll.h>\n#include <linux/errqueue.h>\n\n#ifdef CONFIG_NET_RX_BUSY_POLL\nunsigned int sysctl_net_busy_read __read_mostly;\nunsigned int sysctl_net_busy_poll __read_mostly;\n#endif\n\nstatic ssize_t sock_read_iter(struct kiocb *iocb, struct iov_iter *to);\nstatic ssize_t sock_write_iter(struct kiocb *iocb, struct iov_iter *from);\nstatic int sock_mmap(struct file *file, struct vm_area_struct *vma);\n\nstatic int sock_close(struct inode *inode, struct file *file);\nstatic struct wait_queue_head *sock_get_poll_head(struct file *file,\n\t\t__poll_t events);\nstatic __poll_t sock_poll_mask(struct file *file, __poll_t);\nstatic __poll_t sock_poll(struct file *file, struct poll_table_struct *wait);\nstatic long sock_ioctl(struct file *file, unsigned int cmd, unsigned long arg);\n#ifdef CONFIG_COMPAT\nstatic long compat_sock_ioctl(struct file *file,\n\t\t\t      unsigned int cmd, unsigned long arg);\n#endif\nstatic int sock_fasync(int fd, struct file *filp, int on);\nstatic ssize_t sock_sendpage(struct file *file, struct page *page,\n\t\t\t     int offset, size_t size, loff_t *ppos, int more);\nstatic ssize_t sock_splice_read(struct file *file, loff_t *ppos,\n\t\t\t\tstruct pipe_inode_info *pipe, size_t len,\n\t\t\t\tunsigned int flags);\n\n/*\n *\tSocket files have a set of 'special' operations as well as the generic file ones. These don't appear\n *\tin the operation structures but are done directly via the socketcall() multiplexor.\n */\n\nstatic const struct file_operations socket_file_ops = {\n\t.owner =\tTHIS_MODULE,\n\t.llseek =\tno_llseek,\n\t.read_iter =\tsock_read_iter,\n\t.write_iter =\tsock_write_iter,\n\t.get_poll_head = sock_get_poll_head,\n\t.poll_mask =\tsock_poll_mask,\n\t.poll =\t\tsock_poll,\n\t.unlocked_ioctl = sock_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = compat_sock_ioctl,\n#endif\n\t.mmap =\t\tsock_mmap,\n\t.release =\tsock_close,\n\t.fasync =\tsock_fasync,\n\t.sendpage =\tsock_sendpage,\n\t.splice_write = generic_splice_sendpage,\n\t.splice_read =\tsock_splice_read,\n};\n\n/*\n *\tThe protocol list. Each protocol is registered in here.\n */\n\nstatic DEFINE_SPINLOCK(net_family_lock);\nstatic const struct net_proto_family __rcu *net_families[NPROTO] __read_mostly;\n\n/*\n * Support routines.\n * Move socket addresses back and forth across the kernel/user\n * divide and look after the messy bits.\n */\n\n/**\n *\tmove_addr_to_kernel\t-\tcopy a socket address into kernel space\n *\t@uaddr: Address in user space\n *\t@kaddr: Address in kernel space\n *\t@ulen: Length in user space\n *\n *\tThe address is copied into kernel space. If the provided address is\n *\ttoo long an error code of -EINVAL is returned. If the copy gives\n *\tinvalid addresses -EFAULT is returned. On a success 0 is returned.\n */\n\nint move_addr_to_kernel(void __user *uaddr, int ulen, struct sockaddr_storage *kaddr)\n{\n\tif (ulen < 0 || ulen > sizeof(struct sockaddr_storage))\n\t\treturn -EINVAL;\n\tif (ulen == 0)\n\t\treturn 0;\n\tif (copy_from_user(kaddr, uaddr, ulen))\n\t\treturn -EFAULT;\n\treturn audit_sockaddr(ulen, kaddr);\n}\n\n/**\n *\tmove_addr_to_user\t-\tcopy an address to user space\n *\t@kaddr: kernel space address\n *\t@klen: length of address in kernel\n *\t@uaddr: user space address\n *\t@ulen: pointer to user length field\n *\n *\tThe value pointed to by ulen on entry is the buffer length available.\n *\tThis is overwritten with the buffer space used. -EINVAL is returned\n *\tif an overlong buffer is specified or a negative buffer size. -EFAULT\n *\tis returned if either the buffer or the length field are not\n *\taccessible.\n *\tAfter copying the data up to the limit the user specifies, the true\n *\tlength of the data is written over the length limit the user\n *\tspecified. Zero is returned for a success.\n */\n\nstatic int move_addr_to_user(struct sockaddr_storage *kaddr, int klen,\n\t\t\t     void __user *uaddr, int __user *ulen)\n{\n\tint err;\n\tint len;\n\n\tBUG_ON(klen > sizeof(struct sockaddr_storage));\n\terr = get_user(len, ulen);\n\tif (err)\n\t\treturn err;\n\tif (len > klen)\n\t\tlen = klen;\n\tif (len < 0)\n\t\treturn -EINVAL;\n\tif (len) {\n\t\tif (audit_sockaddr(klen, kaddr))\n\t\t\treturn -ENOMEM;\n\t\tif (copy_to_user(uaddr, kaddr, len))\n\t\t\treturn -EFAULT;\n\t}\n\t/*\n\t *      \"fromlen shall refer to the value before truncation..\"\n\t *                      1003.1g\n\t */\n\treturn __put_user(klen, ulen);\n}\n\nstatic struct kmem_cache *sock_inode_cachep __ro_after_init;\n\nstatic struct inode *sock_alloc_inode(struct super_block *sb)\n{\n\tstruct socket_alloc *ei;\n\tstruct socket_wq *wq;\n\n\tei = kmem_cache_alloc(sock_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\twq = kmalloc(sizeof(*wq), GFP_KERNEL);\n\tif (!wq) {\n\t\tkmem_cache_free(sock_inode_cachep, ei);\n\t\treturn NULL;\n\t}\n\tinit_waitqueue_head(&wq->wait);\n\twq->fasync_list = NULL;\n\twq->flags = 0;\n\tRCU_INIT_POINTER(ei->socket.wq, wq);\n\n\tei->socket.state = SS_UNCONNECTED;\n\tei->socket.flags = 0;\n\tei->socket.ops = NULL;\n\tei->socket.sk = NULL;\n\tei->socket.file = NULL;\n\n\treturn &ei->vfs_inode;\n}\n\nstatic void sock_destroy_inode(struct inode *inode)\n{\n\tstruct socket_alloc *ei;\n\tstruct socket_wq *wq;\n\n\tei = container_of(inode, struct socket_alloc, vfs_inode);\n\twq = rcu_dereference_protected(ei->socket.wq, 1);\n\tkfree_rcu(wq, rcu);\n\tkmem_cache_free(sock_inode_cachep, ei);\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct socket_alloc *ei = (struct socket_alloc *)foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}\n\nstatic void init_inodecache(void)\n{\n\tsock_inode_cachep = kmem_cache_create(\"sock_inode_cache\",\n\t\t\t\t\t      sizeof(struct socket_alloc),\n\t\t\t\t\t      0,\n\t\t\t\t\t      (SLAB_HWCACHE_ALIGN |\n\t\t\t\t\t       SLAB_RECLAIM_ACCOUNT |\n\t\t\t\t\t       SLAB_MEM_SPREAD | SLAB_ACCOUNT),\n\t\t\t\t\t      init_once);\n\tBUG_ON(sock_inode_cachep == NULL);\n}\n\nstatic const struct super_operations sockfs_ops = {\n\t.alloc_inode\t= sock_alloc_inode,\n\t.destroy_inode\t= sock_destroy_inode,\n\t.statfs\t\t= simple_statfs,\n};\n\n/*\n * sockfs_dname() is called from d_path().\n */\nstatic char *sockfs_dname(struct dentry *dentry, char *buffer, int buflen)\n{\n\treturn dynamic_dname(dentry, buffer, buflen, \"socket:[%lu]\",\n\t\t\t\td_inode(dentry)->i_ino);\n}\n\nstatic const struct dentry_operations sockfs_dentry_operations = {\n\t.d_dname  = sockfs_dname,\n};\n\nstatic int sockfs_xattr_get(const struct xattr_handler *handler,\n\t\t\t    struct dentry *dentry, struct inode *inode,\n\t\t\t    const char *suffix, void *value, size_t size)\n{\n\tif (value) {\n\t\tif (dentry->d_name.len + 1 > size)\n\t\t\treturn -ERANGE;\n\t\tmemcpy(value, dentry->d_name.name, dentry->d_name.len + 1);\n\t}\n\treturn dentry->d_name.len + 1;\n}\n\n#define XATTR_SOCKPROTONAME_SUFFIX \"sockprotoname\"\n#define XATTR_NAME_SOCKPROTONAME (XATTR_SYSTEM_PREFIX XATTR_SOCKPROTONAME_SUFFIX)\n#define XATTR_NAME_SOCKPROTONAME_LEN (sizeof(XATTR_NAME_SOCKPROTONAME)-1)\n\nstatic const struct xattr_handler sockfs_xattr_handler = {\n\t.name = XATTR_NAME_SOCKPROTONAME,\n\t.get = sockfs_xattr_get,\n};\n\nstatic int sockfs_security_xattr_set(const struct xattr_handler *handler,\n\t\t\t\t     struct dentry *dentry, struct inode *inode,\n\t\t\t\t     const char *suffix, const void *value,\n\t\t\t\t     size_t size, int flags)\n{\n\t/* Handled by LSM. */\n\treturn -EAGAIN;\n}\n\nstatic const struct xattr_handler sockfs_security_xattr_handler = {\n\t.prefix = XATTR_SECURITY_PREFIX,\n\t.set = sockfs_security_xattr_set,\n};\n\nstatic const struct xattr_handler *sockfs_xattr_handlers[] = {\n\t&sockfs_xattr_handler,\n\t&sockfs_security_xattr_handler,\n\tNULL\n};\n\nstatic struct dentry *sockfs_mount(struct file_system_type *fs_type,\n\t\t\t int flags, const char *dev_name, void *data)\n{\n\treturn mount_pseudo_xattr(fs_type, \"socket:\", &sockfs_ops,\n\t\t\t\t  sockfs_xattr_handlers,\n\t\t\t\t  &sockfs_dentry_operations, SOCKFS_MAGIC);\n}\n\nstatic struct vfsmount *sock_mnt __read_mostly;\n\nstatic struct file_system_type sock_fs_type = {\n\t.name =\t\t\"sockfs\",\n\t.mount =\tsockfs_mount,\n\t.kill_sb =\tkill_anon_super,\n};\n\n/*\n *\tObtains the first available file descriptor and sets it up for use.\n *\n *\tThese functions create file structures and maps them to fd space\n *\tof the current process. On success it returns file descriptor\n *\tand file struct implicitly stored in sock->file.\n *\tNote that another thread may close file descriptor before we return\n *\tfrom this function. We use the fact that now we do not refer\n *\tto socket after mapping. If one day we will need it, this\n *\tfunction will increment ref. count on file by 1.\n *\n *\tIn any case returned fd MAY BE not valid!\n *\tThis race condition is unavoidable\n *\twith shared fd spaces, we cannot solve it inside kernel,\n *\tbut we take care of internal coherence yet.\n */\n\nstruct file *sock_alloc_file(struct socket *sock, int flags, const char *dname)\n{\n\tstruct qstr name = { .name = \"\" };\n\tstruct path path;\n\tstruct file *file;\n\n\tif (dname) {\n\t\tname.name = dname;\n\t\tname.len = strlen(name.name);\n\t} else if (sock->sk) {\n\t\tname.name = sock->sk->sk_prot_creator->name;\n\t\tname.len = strlen(name.name);\n\t}\n\tpath.dentry = d_alloc_pseudo(sock_mnt->mnt_sb, &name);\n\tif (unlikely(!path.dentry)) {\n\t\tsock_release(sock);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tpath.mnt = mntget(sock_mnt);\n\n\td_instantiate(path.dentry, SOCK_INODE(sock));\n\n\tfile = alloc_file(&path, FMODE_READ | FMODE_WRITE,\n\t\t  &socket_file_ops);\n\tif (IS_ERR(file)) {\n\t\t/* drop dentry, keep inode for a bit */\n\t\tihold(d_inode(path.dentry));\n\t\tpath_put(&path);\n\t\t/* ... and now kill it properly */\n\t\tsock_release(sock);\n\t\treturn file;\n\t}\n\n\tsock->file = file;\n\tfile->f_flags = O_RDWR | (flags & O_NONBLOCK);\n\tfile->private_data = sock;\n\treturn file;\n}\nEXPORT_SYMBOL(sock_alloc_file);\n\nstatic int sock_map_fd(struct socket *sock, int flags)\n{\n\tstruct file *newfile;\n\tint fd = get_unused_fd_flags(flags);\n\tif (unlikely(fd < 0)) {\n\t\tsock_release(sock);\n\t\treturn fd;\n\t}\n\n\tnewfile = sock_alloc_file(sock, flags, NULL);\n\tif (likely(!IS_ERR(newfile))) {\n\t\tfd_install(fd, newfile);\n\t\treturn fd;\n\t}\n\n\tput_unused_fd(fd);\n\treturn PTR_ERR(newfile);\n}\n\nstruct socket *sock_from_file(struct file *file, int *err)\n{\n\tif (file->f_op == &socket_file_ops)\n\t\treturn file->private_data;\t/* set in sock_map_fd */\n\n\t*err = -ENOTSOCK;\n\treturn NULL;\n}\nEXPORT_SYMBOL(sock_from_file);\n\n/**\n *\tsockfd_lookup - Go from a file number to its socket slot\n *\t@fd: file handle\n *\t@err: pointer to an error code return\n *\n *\tThe file handle passed in is locked and the socket it is bound\n *\tto is returned. If an error occurs the err pointer is overwritten\n *\twith a negative errno code and NULL is returned. The function checks\n *\tfor both invalid handles and passing a handle which is not a socket.\n *\n *\tOn a success the socket object pointer is returned.\n */\n\nstruct socket *sockfd_lookup(int fd, int *err)\n{\n\tstruct file *file;\n\tstruct socket *sock;\n\n\tfile = fget(fd);\n\tif (!file) {\n\t\t*err = -EBADF;\n\t\treturn NULL;\n\t}\n\n\tsock = sock_from_file(file, err);\n\tif (!sock)\n\t\tfput(file);\n\treturn sock;\n}\nEXPORT_SYMBOL(sockfd_lookup);\n\nstatic struct socket *sockfd_lookup_light(int fd, int *err, int *fput_needed)\n{\n\tstruct fd f = fdget(fd);\n\tstruct socket *sock;\n\n\t*err = -EBADF;\n\tif (f.file) {\n\t\tsock = sock_from_file(f.file, err);\n\t\tif (likely(sock)) {\n\t\t\t*fput_needed = f.flags;\n\t\t\treturn sock;\n\t\t}\n\t\tfdput(f);\n\t}\n\treturn NULL;\n}\n\nstatic ssize_t sockfs_listxattr(struct dentry *dentry, char *buffer,\n\t\t\t\tsize_t size)\n{\n\tssize_t len;\n\tssize_t used = 0;\n\n\tlen = security_inode_listsecurity(d_inode(dentry), buffer, size);\n\tif (len < 0)\n\t\treturn len;\n\tused += len;\n\tif (buffer) {\n\t\tif (size < used)\n\t\t\treturn -ERANGE;\n\t\tbuffer += len;\n\t}\n\n\tlen = (XATTR_NAME_SOCKPROTONAME_LEN + 1);\n\tused += len;\n\tif (buffer) {\n\t\tif (size < used)\n\t\t\treturn -ERANGE;\n\t\tmemcpy(buffer, XATTR_NAME_SOCKPROTONAME, len);\n\t\tbuffer += len;\n\t}\n\n\treturn used;\n}\n\nstatic int sockfs_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tint err = simple_setattr(dentry, iattr);\n\n\tif (!err && (iattr->ia_valid & ATTR_UID)) {\n\t\tstruct socket *sock = SOCKET_I(d_inode(dentry));\n\n\t\tsock->sk->sk_uid = iattr->ia_uid;\n\t}\n\n\treturn err;\n}\n\nstatic const struct inode_operations sockfs_inode_ops = {\n\t.listxattr = sockfs_listxattr,\n\t.setattr = sockfs_setattr,\n};\n\n/**\n *\tsock_alloc\t-\tallocate a socket\n *\n *\tAllocate a new inode and socket object. The two are bound together\n *\tand initialised. The socket is then returned. If we are out of inodes\n *\tNULL is returned.\n */\n\nstruct socket *sock_alloc(void)\n{\n\tstruct inode *inode;\n\tstruct socket *sock;\n\n\tinode = new_inode_pseudo(sock_mnt->mnt_sb);\n\tif (!inode)\n\t\treturn NULL;\n\n\tsock = SOCKET_I(inode);\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = S_IFSOCK | S_IRWXUGO;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tinode->i_op = &sockfs_inode_ops;\n\n\treturn sock;\n}\nEXPORT_SYMBOL(sock_alloc);\n\n/**\n *\tsock_release\t-\tclose a socket\n *\t@sock: socket to close\n *\n *\tThe socket is released from the protocol stack if it has a release\n *\tcallback, and the inode is then released if the socket is bound to\n *\tan inode not a file.\n */\n\nvoid sock_release(struct socket *sock)\n{\n\tif (sock->ops) {\n\t\tstruct module *owner = sock->ops->owner;\n\n\t\tsock->ops->release(sock);\n\t\tsock->ops = NULL;\n\t\tmodule_put(owner);\n\t}\n\n\tif (rcu_dereference_protected(sock->wq, 1)->fasync_list)\n\t\tpr_err(\"%s: fasync list not empty!\\n\", __func__);\n\n\tif (!sock->file) {\n\t\tiput(SOCK_INODE(sock));\n\t\treturn;\n\t}\n\tsock->file = NULL;\n}\nEXPORT_SYMBOL(sock_release);\n\nvoid __sock_tx_timestamp(__u16 tsflags, __u8 *tx_flags)\n{\n\tu8 flags = *tx_flags;\n\n\tif (tsflags & SOF_TIMESTAMPING_TX_HARDWARE)\n\t\tflags |= SKBTX_HW_TSTAMP;\n\n\tif (tsflags & SOF_TIMESTAMPING_TX_SOFTWARE)\n\t\tflags |= SKBTX_SW_TSTAMP;\n\n\tif (tsflags & SOF_TIMESTAMPING_TX_SCHED)\n\t\tflags |= SKBTX_SCHED_TSTAMP;\n\n\t*tx_flags = flags;\n}\nEXPORT_SYMBOL(__sock_tx_timestamp);\n\nstatic inline int sock_sendmsg_nosec(struct socket *sock, struct msghdr *msg)\n{\n\tint ret = sock->ops->sendmsg(sock, msg, msg_data_left(msg));\n\tBUG_ON(ret == -EIOCBQUEUED);\n\treturn ret;\n}\n\nint sock_sendmsg(struct socket *sock, struct msghdr *msg)\n{\n\tint err = security_socket_sendmsg(sock, msg,\n\t\t\t\t\t  msg_data_left(msg));\n\n\treturn err ?: sock_sendmsg_nosec(sock, msg);\n}\nEXPORT_SYMBOL(sock_sendmsg);\n\nint kernel_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t   struct kvec *vec, size_t num, size_t size)\n{\n\tiov_iter_kvec(&msg->msg_iter, WRITE | ITER_KVEC, vec, num, size);\n\treturn sock_sendmsg(sock, msg);\n}\nEXPORT_SYMBOL(kernel_sendmsg);\n\nint kernel_sendmsg_locked(struct sock *sk, struct msghdr *msg,\n\t\t\t  struct kvec *vec, size_t num, size_t size)\n{\n\tstruct socket *sock = sk->sk_socket;\n\n\tif (!sock->ops->sendmsg_locked)\n\t\treturn sock_no_sendmsg_locked(sk, msg, size);\n\n\tiov_iter_kvec(&msg->msg_iter, WRITE | ITER_KVEC, vec, num, size);\n\n\treturn sock->ops->sendmsg_locked(sk, msg, msg_data_left(msg));\n}\nEXPORT_SYMBOL(kernel_sendmsg_locked);\n\nstatic bool skb_is_err_queue(const struct sk_buff *skb)\n{\n\t/* pkt_type of skbs enqueued on the error queue are set to\n\t * PACKET_OUTGOING in skb_set_err_queue(). This is only safe to do\n\t * in recvmsg, since skbs received on a local socket will never\n\t * have a pkt_type of PACKET_OUTGOING.\n\t */\n\treturn skb->pkt_type == PACKET_OUTGOING;\n}\n\n/* On transmit, software and hardware timestamps are returned independently.\n * As the two skb clones share the hardware timestamp, which may be updated\n * before the software timestamp is received, a hardware TX timestamp may be\n * returned only if there is no software TX timestamp. Ignore false software\n * timestamps, which may be made in the __sock_recv_timestamp() call when the\n * option SO_TIMESTAMP(NS) is enabled on the socket, even when the skb has a\n * hardware timestamp.\n */\nstatic bool skb_is_swtx_tstamp(const struct sk_buff *skb, int false_tstamp)\n{\n\treturn skb->tstamp && !false_tstamp && skb_is_err_queue(skb);\n}\n\nstatic void put_ts_pktinfo(struct msghdr *msg, struct sk_buff *skb)\n{\n\tstruct scm_ts_pktinfo ts_pktinfo;\n\tstruct net_device *orig_dev;\n\n\tif (!skb_mac_header_was_set(skb))\n\t\treturn;\n\n\tmemset(&ts_pktinfo, 0, sizeof(ts_pktinfo));\n\n\trcu_read_lock();\n\torig_dev = dev_get_by_napi_id(skb_napi_id(skb));\n\tif (orig_dev)\n\t\tts_pktinfo.if_index = orig_dev->ifindex;\n\trcu_read_unlock();\n\n\tts_pktinfo.pkt_length = skb->len - skb_mac_offset(skb);\n\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPING_PKTINFO,\n\t\t sizeof(ts_pktinfo), &ts_pktinfo);\n}\n\n/*\n * called from sock_recv_timestamp() if sock_flag(sk, SOCK_RCVTSTAMP)\n */\nvoid __sock_recv_timestamp(struct msghdr *msg, struct sock *sk,\n\tstruct sk_buff *skb)\n{\n\tint need_software_tstamp = sock_flag(sk, SOCK_RCVTSTAMP);\n\tstruct scm_timestamping tss;\n\tint empty = 1, false_tstamp = 0;\n\tstruct skb_shared_hwtstamps *shhwtstamps =\n\t\tskb_hwtstamps(skb);\n\n\t/* Race occurred between timestamp enabling and packet\n\t   receiving.  Fill in the current time for now. */\n\tif (need_software_tstamp && skb->tstamp == 0) {\n\t\t__net_timestamp(skb);\n\t\tfalse_tstamp = 1;\n\t}\n\n\tif (need_software_tstamp) {\n\t\tif (!sock_flag(sk, SOCK_RCVTSTAMPNS)) {\n\t\t\tstruct timeval tv;\n\t\t\tskb_get_timestamp(skb, &tv);\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMP,\n\t\t\t\t sizeof(tv), &tv);\n\t\t} else {\n\t\t\tstruct timespec ts;\n\t\t\tskb_get_timestampns(skb, &ts);\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPNS,\n\t\t\t\t sizeof(ts), &ts);\n\t\t}\n\t}\n\n\tmemset(&tss, 0, sizeof(tss));\n\tif ((sk->sk_tsflags & SOF_TIMESTAMPING_SOFTWARE) &&\n\t    ktime_to_timespec_cond(skb->tstamp, tss.ts + 0))\n\t\tempty = 0;\n\tif (shhwtstamps &&\n\t    (sk->sk_tsflags & SOF_TIMESTAMPING_RAW_HARDWARE) &&\n\t    !skb_is_swtx_tstamp(skb, false_tstamp) &&\n\t    ktime_to_timespec_cond(shhwtstamps->hwtstamp, tss.ts + 2)) {\n\t\tempty = 0;\n\t\tif ((sk->sk_tsflags & SOF_TIMESTAMPING_OPT_PKTINFO) &&\n\t\t    !skb_is_err_queue(skb))\n\t\t\tput_ts_pktinfo(msg, skb);\n\t}\n\tif (!empty) {\n\t\tput_cmsg(msg, SOL_SOCKET,\n\t\t\t SCM_TIMESTAMPING, sizeof(tss), &tss);\n\n\t\tif (skb_is_err_queue(skb) && skb->len &&\n\t\t    SKB_EXT_ERR(skb)->opt_stats)\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPING_OPT_STATS,\n\t\t\t\t skb->len, skb->data);\n\t}\n}\nEXPORT_SYMBOL_GPL(__sock_recv_timestamp);\n\nvoid __sock_recv_wifi_status(struct msghdr *msg, struct sock *sk,\n\tstruct sk_buff *skb)\n{\n\tint ack;\n\n\tif (!sock_flag(sk, SOCK_WIFI_STATUS))\n\t\treturn;\n\tif (!skb->wifi_acked_valid)\n\t\treturn;\n\n\tack = skb->wifi_acked;\n\n\tput_cmsg(msg, SOL_SOCKET, SCM_WIFI_STATUS, sizeof(ack), &ack);\n}\nEXPORT_SYMBOL_GPL(__sock_recv_wifi_status);\n\nstatic inline void sock_recv_drops(struct msghdr *msg, struct sock *sk,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tif (sock_flag(sk, SOCK_RXQ_OVFL) && skb && SOCK_SKB_CB(skb)->dropcount)\n\t\tput_cmsg(msg, SOL_SOCKET, SO_RXQ_OVFL,\n\t\t\tsizeof(__u32), &SOCK_SKB_CB(skb)->dropcount);\n}\n\nvoid __sock_recv_ts_and_drops(struct msghdr *msg, struct sock *sk,\n\tstruct sk_buff *skb)\n{\n\tsock_recv_timestamp(msg, sk, skb);\n\tsock_recv_drops(msg, sk, skb);\n}\nEXPORT_SYMBOL_GPL(__sock_recv_ts_and_drops);\n\nstatic inline int sock_recvmsg_nosec(struct socket *sock, struct msghdr *msg,\n\t\t\t\t     int flags)\n{\n\treturn sock->ops->recvmsg(sock, msg, msg_data_left(msg), flags);\n}\n\nint sock_recvmsg(struct socket *sock, struct msghdr *msg, int flags)\n{\n\tint err = security_socket_recvmsg(sock, msg, msg_data_left(msg), flags);\n\n\treturn err ?: sock_recvmsg_nosec(sock, msg, flags);\n}\nEXPORT_SYMBOL(sock_recvmsg);\n\n/**\n * kernel_recvmsg - Receive a message from a socket (kernel space)\n * @sock:       The socket to receive the message from\n * @msg:        Received message\n * @vec:        Input s/g array for message data\n * @num:        Size of input s/g array\n * @size:       Number of bytes to read\n * @flags:      Message flags (MSG_DONTWAIT, etc...)\n *\n * On return the msg structure contains the scatter/gather array passed in the\n * vec argument. The array is modified so that it consists of the unfilled\n * portion of the original array.\n *\n * The returned value is the total number of bytes received, or an error.\n */\nint kernel_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t   struct kvec *vec, size_t num, size_t size, int flags)\n{\n\tmm_segment_t oldfs = get_fs();\n\tint result;\n\n\tiov_iter_kvec(&msg->msg_iter, READ | ITER_KVEC, vec, num, size);\n\tset_fs(KERNEL_DS);\n\tresult = sock_recvmsg(sock, msg, flags);\n\tset_fs(oldfs);\n\treturn result;\n}\nEXPORT_SYMBOL(kernel_recvmsg);\n\nstatic ssize_t sock_sendpage(struct file *file, struct page *page,\n\t\t\t     int offset, size_t size, loff_t *ppos, int more)\n{\n\tstruct socket *sock;\n\tint flags;\n\n\tsock = file->private_data;\n\n\tflags = (file->f_flags & O_NONBLOCK) ? MSG_DONTWAIT : 0;\n\t/* more is a combination of MSG_MORE and MSG_SENDPAGE_NOTLAST */\n\tflags |= more;\n\n\treturn kernel_sendpage(sock, page, offset, size, flags);\n}\n\nstatic ssize_t sock_splice_read(struct file *file, loff_t *ppos,\n\t\t\t\tstruct pipe_inode_info *pipe, size_t len,\n\t\t\t\tunsigned int flags)\n{\n\tstruct socket *sock = file->private_data;\n\n\tif (unlikely(!sock->ops->splice_read))\n\t\treturn -EINVAL;\n\n\treturn sock->ops->splice_read(sock, ppos, pipe, len, flags);\n}\n\nstatic ssize_t sock_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct socket *sock = file->private_data;\n\tstruct msghdr msg = {.msg_iter = *to,\n\t\t\t     .msg_iocb = iocb};\n\tssize_t res;\n\n\tif (file->f_flags & O_NONBLOCK)\n\t\tmsg.msg_flags = MSG_DONTWAIT;\n\n\tif (iocb->ki_pos != 0)\n\t\treturn -ESPIPE;\n\n\tif (!iov_iter_count(to))\t/* Match SYS5 behaviour */\n\t\treturn 0;\n\n\tres = sock_recvmsg(sock, &msg, msg.msg_flags);\n\t*to = msg.msg_iter;\n\treturn res;\n}\n\nstatic ssize_t sock_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct socket *sock = file->private_data;\n\tstruct msghdr msg = {.msg_iter = *from,\n\t\t\t     .msg_iocb = iocb};\n\tssize_t res;\n\n\tif (iocb->ki_pos != 0)\n\t\treturn -ESPIPE;\n\n\tif (file->f_flags & O_NONBLOCK)\n\t\tmsg.msg_flags = MSG_DONTWAIT;\n\n\tif (sock->type == SOCK_SEQPACKET)\n\t\tmsg.msg_flags |= MSG_EOR;\n\n\tres = sock_sendmsg(sock, &msg);\n\t*from = msg.msg_iter;\n\treturn res;\n}\n\n/*\n * Atomic setting of ioctl hooks to avoid race\n * with module unload.\n */\n\nstatic DEFINE_MUTEX(br_ioctl_mutex);\nstatic int (*br_ioctl_hook) (struct net *, unsigned int cmd, void __user *arg);\n\nvoid brioctl_set(int (*hook) (struct net *, unsigned int, void __user *))\n{\n\tmutex_lock(&br_ioctl_mutex);\n\tbr_ioctl_hook = hook;\n\tmutex_unlock(&br_ioctl_mutex);\n}\nEXPORT_SYMBOL(brioctl_set);\n\nstatic DEFINE_MUTEX(vlan_ioctl_mutex);\nstatic int (*vlan_ioctl_hook) (struct net *, void __user *arg);\n\nvoid vlan_ioctl_set(int (*hook) (struct net *, void __user *))\n{\n\tmutex_lock(&vlan_ioctl_mutex);\n\tvlan_ioctl_hook = hook;\n\tmutex_unlock(&vlan_ioctl_mutex);\n}\nEXPORT_SYMBOL(vlan_ioctl_set);\n\nstatic DEFINE_MUTEX(dlci_ioctl_mutex);\nstatic int (*dlci_ioctl_hook) (unsigned int, void __user *);\n\nvoid dlci_ioctl_set(int (*hook) (unsigned int, void __user *))\n{\n\tmutex_lock(&dlci_ioctl_mutex);\n\tdlci_ioctl_hook = hook;\n\tmutex_unlock(&dlci_ioctl_mutex);\n}\nEXPORT_SYMBOL(dlci_ioctl_set);\n\nstatic long sock_do_ioctl(struct net *net, struct socket *sock,\n\t\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tint err;\n\tvoid __user *argp = (void __user *)arg;\n\n\terr = sock->ops->ioctl(sock, cmd, arg);\n\n\t/*\n\t * If this ioctl is unknown try to hand it down\n\t * to the NIC driver.\n\t */\n\tif (err != -ENOIOCTLCMD)\n\t\treturn err;\n\n\tif (cmd == SIOCGIFCONF) {\n\t\tstruct ifconf ifc;\n\t\tif (copy_from_user(&ifc, argp, sizeof(struct ifconf)))\n\t\t\treturn -EFAULT;\n\t\trtnl_lock();\n\t\terr = dev_ifconf(net, &ifc, sizeof(struct ifreq));\n\t\trtnl_unlock();\n\t\tif (!err && copy_to_user(argp, &ifc, sizeof(struct ifconf)))\n\t\t\terr = -EFAULT;\n\t} else {\n\t\tstruct ifreq ifr;\n\t\tbool need_copyout;\n\t\tif (copy_from_user(&ifr, argp, sizeof(struct ifreq)))\n\t\t\treturn -EFAULT;\n\t\terr = dev_ioctl(net, cmd, &ifr, &need_copyout);\n\t\tif (!err && need_copyout)\n\t\t\tif (copy_to_user(argp, &ifr, sizeof(struct ifreq)))\n\t\t\t\treturn -EFAULT;\n\t}\n\treturn err;\n}\n\n/*\n *\tWith an ioctl, arg may well be a user mode pointer, but we don't know\n *\twhat to do with it - that's up to the protocol still.\n */\n\nstruct ns_common *get_net_ns(struct ns_common *ns)\n{\n\treturn &get_net(container_of(ns, struct net, ns))->ns;\n}\nEXPORT_SYMBOL_GPL(get_net_ns);\n\nstatic long sock_ioctl(struct file *file, unsigned cmd, unsigned long arg)\n{\n\tstruct socket *sock;\n\tstruct sock *sk;\n\tvoid __user *argp = (void __user *)arg;\n\tint pid, err;\n\tstruct net *net;\n\n\tsock = file->private_data;\n\tsk = sock->sk;\n\tnet = sock_net(sk);\n\tif (unlikely(cmd >= SIOCDEVPRIVATE && cmd <= (SIOCDEVPRIVATE + 15))) {\n\t\tstruct ifreq ifr;\n\t\tbool need_copyout;\n\t\tif (copy_from_user(&ifr, argp, sizeof(struct ifreq)))\n\t\t\treturn -EFAULT;\n\t\terr = dev_ioctl(net, cmd, &ifr, &need_copyout);\n\t\tif (!err && need_copyout)\n\t\t\tif (copy_to_user(argp, &ifr, sizeof(struct ifreq)))\n\t\t\t\treturn -EFAULT;\n\t} else\n#ifdef CONFIG_WEXT_CORE\n\tif (cmd >= SIOCIWFIRST && cmd <= SIOCIWLAST) {\n\t\terr = wext_handle_ioctl(net, cmd, argp);\n\t} else\n#endif\n\t\tswitch (cmd) {\n\t\tcase FIOSETOWN:\n\t\tcase SIOCSPGRP:\n\t\t\terr = -EFAULT;\n\t\t\tif (get_user(pid, (int __user *)argp))\n\t\t\t\tbreak;\n\t\t\terr = f_setown(sock->file, pid, 1);\n\t\t\tbreak;\n\t\tcase FIOGETOWN:\n\t\tcase SIOCGPGRP:\n\t\t\terr = put_user(f_getown(sock->file),\n\t\t\t\t       (int __user *)argp);\n\t\t\tbreak;\n\t\tcase SIOCGIFBR:\n\t\tcase SIOCSIFBR:\n\t\tcase SIOCBRADDBR:\n\t\tcase SIOCBRDELBR:\n\t\t\terr = -ENOPKG;\n\t\t\tif (!br_ioctl_hook)\n\t\t\t\trequest_module(\"bridge\");\n\n\t\t\tmutex_lock(&br_ioctl_mutex);\n\t\t\tif (br_ioctl_hook)\n\t\t\t\terr = br_ioctl_hook(net, cmd, argp);\n\t\t\tmutex_unlock(&br_ioctl_mutex);\n\t\t\tbreak;\n\t\tcase SIOCGIFVLAN:\n\t\tcase SIOCSIFVLAN:\n\t\t\terr = -ENOPKG;\n\t\t\tif (!vlan_ioctl_hook)\n\t\t\t\trequest_module(\"8021q\");\n\n\t\t\tmutex_lock(&vlan_ioctl_mutex);\n\t\t\tif (vlan_ioctl_hook)\n\t\t\t\terr = vlan_ioctl_hook(net, argp);\n\t\t\tmutex_unlock(&vlan_ioctl_mutex);\n\t\t\tbreak;\n\t\tcase SIOCADDDLCI:\n\t\tcase SIOCDELDLCI:\n\t\t\terr = -ENOPKG;\n\t\t\tif (!dlci_ioctl_hook)\n\t\t\t\trequest_module(\"dlci\");\n\n\t\t\tmutex_lock(&dlci_ioctl_mutex);\n\t\t\tif (dlci_ioctl_hook)\n\t\t\t\terr = dlci_ioctl_hook(cmd, argp);\n\t\t\tmutex_unlock(&dlci_ioctl_mutex);\n\t\t\tbreak;\n\t\tcase SIOCGSKNS:\n\t\t\terr = -EPERM;\n\t\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\t\tbreak;\n\n\t\t\terr = open_related_ns(&net->ns, get_net_ns);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = sock_do_ioctl(net, sock, cmd, arg);\n\t\t\tbreak;\n\t\t}\n\treturn err;\n}\n\nint sock_create_lite(int family, int type, int protocol, struct socket **res)\n{\n\tint err;\n\tstruct socket *sock = NULL;\n\n\terr = security_socket_create(family, type, protocol, 1);\n\tif (err)\n\t\tgoto out;\n\n\tsock = sock_alloc();\n\tif (!sock) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsock->type = type;\n\terr = security_socket_post_create(sock, family, type, protocol, 1);\n\tif (err)\n\t\tgoto out_release;\n\nout:\n\t*res = sock;\n\treturn err;\nout_release:\n\tsock_release(sock);\n\tsock = NULL;\n\tgoto out;\n}\nEXPORT_SYMBOL(sock_create_lite);\n\nstatic struct wait_queue_head *sock_get_poll_head(struct file *file,\n\t\t__poll_t events)\n{\n\tstruct socket *sock = file->private_data;\n\n\tif (!sock->ops->poll_mask)\n\t\treturn NULL;\n\tsock_poll_busy_loop(sock, events);\n\treturn sk_sleep(sock->sk);\n}\n\nstatic __poll_t sock_poll_mask(struct file *file, __poll_t events)\n{\n\tstruct socket *sock = file->private_data;\n\n\t/*\n\t * We need to be sure we are in sync with the socket flags modification.\n\t *\n\t * This memory barrier is paired in the wq_has_sleeper.\n\t */\n\tsmp_mb();\n\n\t/* this socket can poll_ll so tell the system call */\n\treturn sock->ops->poll_mask(sock, events) |\n\t\t(sk_can_busy_loop(sock->sk) ? POLL_BUSY_LOOP : 0);\n}\n\n/* No kernel lock held - perfect */\nstatic __poll_t sock_poll(struct file *file, poll_table *wait)\n{\n\tstruct socket *sock = file->private_data;\n\t__poll_t events = poll_requested_events(wait), mask = 0;\n\n\tif (sock->ops->poll) {\n\t\tsock_poll_busy_loop(sock, events);\n\t\tmask = sock->ops->poll(file, sock, wait);\n\t} else if (sock->ops->poll_mask) {\n\t\tsock_poll_wait(file, sock_get_poll_head(file, events), wait);\n\t\tmask = sock->ops->poll_mask(sock, events);\n\t}\n\n\treturn mask | sock_poll_busy_flag(sock);\n}\n\nstatic int sock_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct socket *sock = file->private_data;\n\n\treturn sock->ops->mmap(file, sock, vma);\n}\n\nstatic int sock_close(struct inode *inode, struct file *filp)\n{\n\tsock_release(SOCKET_I(inode));\n\treturn 0;\n}\n\n/*\n *\tUpdate the socket async list\n *\n *\tFasync_list locking strategy.\n *\n *\t1. fasync_list is modified only under process context socket lock\n *\t   i.e. under semaphore.\n *\t2. fasync_list is used under read_lock(&sk->sk_callback_lock)\n *\t   or under socket lock\n */\n\nstatic int sock_fasync(int fd, struct file *filp, int on)\n{\n\tstruct socket *sock = filp->private_data;\n\tstruct sock *sk = sock->sk;\n\tstruct socket_wq *wq;\n\n\tif (sk == NULL)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\twq = rcu_dereference_protected(sock->wq, lockdep_sock_is_held(sk));\n\tfasync_helper(fd, filp, on, &wq->fasync_list);\n\n\tif (!wq->fasync_list)\n\t\tsock_reset_flag(sk, SOCK_FASYNC);\n\telse\n\t\tsock_set_flag(sk, SOCK_FASYNC);\n\n\trelease_sock(sk);\n\treturn 0;\n}\n\n/* This function may be called only under rcu_lock */\n\nint sock_wake_async(struct socket_wq *wq, int how, int band)\n{\n\tif (!wq || !wq->fasync_list)\n\t\treturn -1;\n\n\tswitch (how) {\n\tcase SOCK_WAKE_WAITD:\n\t\tif (test_bit(SOCKWQ_ASYNC_WAITDATA, &wq->flags))\n\t\t\tbreak;\n\t\tgoto call_kill;\n\tcase SOCK_WAKE_SPACE:\n\t\tif (!test_and_clear_bit(SOCKWQ_ASYNC_NOSPACE, &wq->flags))\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase SOCK_WAKE_IO:\ncall_kill:\n\t\tkill_fasync(&wq->fasync_list, SIGIO, band);\n\t\tbreak;\n\tcase SOCK_WAKE_URG:\n\t\tkill_fasync(&wq->fasync_list, SIGURG, band);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(sock_wake_async);\n\nint __sock_create(struct net *net, int family, int type, int protocol,\n\t\t\t struct socket **res, int kern)\n{\n\tint err;\n\tstruct socket *sock;\n\tconst struct net_proto_family *pf;\n\n\t/*\n\t *      Check protocol is in range\n\t */\n\tif (family < 0 || family >= NPROTO)\n\t\treturn -EAFNOSUPPORT;\n\tif (type < 0 || type >= SOCK_MAX)\n\t\treturn -EINVAL;\n\n\t/* Compatibility.\n\n\t   This uglymoron is moved from INET layer to here to avoid\n\t   deadlock in module load.\n\t */\n\tif (family == PF_INET && type == SOCK_PACKET) {\n\t\tpr_info_once(\"%s uses obsolete (PF_INET,SOCK_PACKET)\\n\",\n\t\t\t     current->comm);\n\t\tfamily = PF_PACKET;\n\t}\n\n\terr = security_socket_create(family, type, protocol, kern);\n\tif (err)\n\t\treturn err;\n\n\t/*\n\t *\tAllocate the socket and allow the family to set things up. if\n\t *\tthe protocol is 0, the family is instructed to select an appropriate\n\t *\tdefault.\n\t */\n\tsock = sock_alloc();\n\tif (!sock) {\n\t\tnet_warn_ratelimited(\"socket: no more sockets\\n\");\n\t\treturn -ENFILE;\t/* Not exactly a match, but its the\n\t\t\t\t   closest posix thing */\n\t}\n\n\tsock->type = type;\n\n#ifdef CONFIG_MODULES\n\t/* Attempt to load a protocol module if the find failed.\n\t *\n\t * 12/09/1996 Marcin: But! this makes REALLY only sense, if the user\n\t * requested real, full-featured networking support upon configuration.\n\t * Otherwise module support will break!\n\t */\n\tif (rcu_access_pointer(net_families[family]) == NULL)\n\t\trequest_module(\"net-pf-%d\", family);\n#endif\n\n\trcu_read_lock();\n\tpf = rcu_dereference(net_families[family]);\n\terr = -EAFNOSUPPORT;\n\tif (!pf)\n\t\tgoto out_release;\n\n\t/*\n\t * We will call the ->create function, that possibly is in a loadable\n\t * module, so we have to bump that loadable module refcnt first.\n\t */\n\tif (!try_module_get(pf->owner))\n\t\tgoto out_release;\n\n\t/* Now protected by module ref count */\n\trcu_read_unlock();\n\n\terr = pf->create(net, sock, protocol, kern);\n\tif (err < 0)\n\t\tgoto out_module_put;\n\n\t/*\n\t * Now to bump the refcnt of the [loadable] module that owns this\n\t * socket at sock_release time we decrement its refcnt.\n\t */\n\tif (!try_module_get(sock->ops->owner))\n\t\tgoto out_module_busy;\n\n\t/*\n\t * Now that we're done with the ->create function, the [loadable]\n\t * module can have its refcnt decremented\n\t */\n\tmodule_put(pf->owner);\n\terr = security_socket_post_create(sock, family, type, protocol, kern);\n\tif (err)\n\t\tgoto out_sock_release;\n\t*res = sock;\n\n\treturn 0;\n\nout_module_busy:\n\terr = -EAFNOSUPPORT;\nout_module_put:\n\tsock->ops = NULL;\n\tmodule_put(pf->owner);\nout_sock_release:\n\tsock_release(sock);\n\treturn err;\n\nout_release:\n\trcu_read_unlock();\n\tgoto out_sock_release;\n}\nEXPORT_SYMBOL(__sock_create);\n\nint sock_create(int family, int type, int protocol, struct socket **res)\n{\n\treturn __sock_create(current->nsproxy->net_ns, family, type, protocol, res, 0);\n}\nEXPORT_SYMBOL(sock_create);\n\nint sock_create_kern(struct net *net, int family, int type, int protocol, struct socket **res)\n{\n\treturn __sock_create(net, family, type, protocol, res, 1);\n}\nEXPORT_SYMBOL(sock_create_kern);\n\nint __sys_socket(int family, int type, int protocol)\n{\n\tint retval;\n\tstruct socket *sock;\n\tint flags;\n\n\t/* Check the SOCK_* constants for consistency.  */\n\tBUILD_BUG_ON(SOCK_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON((SOCK_MAX | SOCK_TYPE_MASK) != SOCK_TYPE_MASK);\n\tBUILD_BUG_ON(SOCK_CLOEXEC & SOCK_TYPE_MASK);\n\tBUILD_BUG_ON(SOCK_NONBLOCK & SOCK_TYPE_MASK);\n\n\tflags = type & ~SOCK_TYPE_MASK;\n\tif (flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))\n\t\treturn -EINVAL;\n\ttype &= SOCK_TYPE_MASK;\n\n\tif (SOCK_NONBLOCK != O_NONBLOCK && (flags & SOCK_NONBLOCK))\n\t\tflags = (flags & ~SOCK_NONBLOCK) | O_NONBLOCK;\n\n\tretval = sock_create(family, type, protocol, &sock);\n\tif (retval < 0)\n\t\treturn retval;\n\n\treturn sock_map_fd(sock, flags & (O_CLOEXEC | O_NONBLOCK));\n}\n\nSYSCALL_DEFINE3(socket, int, family, int, type, int, protocol)\n{\n\treturn __sys_socket(family, type, protocol);\n}\n\n/*\n *\tCreate a pair of connected sockets.\n */\n\nint __sys_socketpair(int family, int type, int protocol, int __user *usockvec)\n{\n\tstruct socket *sock1, *sock2;\n\tint fd1, fd2, err;\n\tstruct file *newfile1, *newfile2;\n\tint flags;\n\n\tflags = type & ~SOCK_TYPE_MASK;\n\tif (flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))\n\t\treturn -EINVAL;\n\ttype &= SOCK_TYPE_MASK;\n\n\tif (SOCK_NONBLOCK != O_NONBLOCK && (flags & SOCK_NONBLOCK))\n\t\tflags = (flags & ~SOCK_NONBLOCK) | O_NONBLOCK;\n\n\t/*\n\t * reserve descriptors and make sure we won't fail\n\t * to return them to userland.\n\t */\n\tfd1 = get_unused_fd_flags(flags);\n\tif (unlikely(fd1 < 0))\n\t\treturn fd1;\n\n\tfd2 = get_unused_fd_flags(flags);\n\tif (unlikely(fd2 < 0)) {\n\t\tput_unused_fd(fd1);\n\t\treturn fd2;\n\t}\n\n\terr = put_user(fd1, &usockvec[0]);\n\tif (err)\n\t\tgoto out;\n\n\terr = put_user(fd2, &usockvec[1]);\n\tif (err)\n\t\tgoto out;\n\n\t/*\n\t * Obtain the first socket and check if the underlying protocol\n\t * supports the socketpair call.\n\t */\n\n\terr = sock_create(family, type, protocol, &sock1);\n\tif (unlikely(err < 0))\n\t\tgoto out;\n\n\terr = sock_create(family, type, protocol, &sock2);\n\tif (unlikely(err < 0)) {\n\t\tsock_release(sock1);\n\t\tgoto out;\n\t}\n\n\terr = security_socket_socketpair(sock1, sock2);\n\tif (unlikely(err)) {\n\t\tsock_release(sock2);\n\t\tsock_release(sock1);\n\t\tgoto out;\n\t}\n\n\terr = sock1->ops->socketpair(sock1, sock2);\n\tif (unlikely(err < 0)) {\n\t\tsock_release(sock2);\n\t\tsock_release(sock1);\n\t\tgoto out;\n\t}\n\n\tnewfile1 = sock_alloc_file(sock1, flags, NULL);\n\tif (IS_ERR(newfile1)) {\n\t\terr = PTR_ERR(newfile1);\n\t\tsock_release(sock2);\n\t\tgoto out;\n\t}\n\n\tnewfile2 = sock_alloc_file(sock2, flags, NULL);\n\tif (IS_ERR(newfile2)) {\n\t\terr = PTR_ERR(newfile2);\n\t\tfput(newfile1);\n\t\tgoto out;\n\t}\n\n\taudit_fd_pair(fd1, fd2);\n\n\tfd_install(fd1, newfile1);\n\tfd_install(fd2, newfile2);\n\treturn 0;\n\nout:\n\tput_unused_fd(fd2);\n\tput_unused_fd(fd1);\n\treturn err;\n}\n\nSYSCALL_DEFINE4(socketpair, int, family, int, type, int, protocol,\n\t\tint __user *, usockvec)\n{\n\treturn __sys_socketpair(family, type, protocol, usockvec);\n}\n\n/*\n *\tBind a name to a socket. Nothing much to do here since it's\n *\tthe protocol's responsibility to handle the local address.\n *\n *\tWe move the socket address to kernel space before we call\n *\tthe protocol layer (having also checked the address is ok).\n */\n\nint __sys_bind(int fd, struct sockaddr __user *umyaddr, int addrlen)\n{\n\tstruct socket *sock;\n\tstruct sockaddr_storage address;\n\tint err, fput_needed;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (sock) {\n\t\terr = move_addr_to_kernel(umyaddr, addrlen, &address);\n\t\tif (err >= 0) {\n\t\t\terr = security_socket_bind(sock,\n\t\t\t\t\t\t   (struct sockaddr *)&address,\n\t\t\t\t\t\t   addrlen);\n\t\t\tif (!err)\n\t\t\t\terr = sock->ops->bind(sock,\n\t\t\t\t\t\t      (struct sockaddr *)\n\t\t\t\t\t\t      &address, addrlen);\n\t\t}\n\t\tfput_light(sock->file, fput_needed);\n\t}\n\treturn err;\n}\n\nSYSCALL_DEFINE3(bind, int, fd, struct sockaddr __user *, umyaddr, int, addrlen)\n{\n\treturn __sys_bind(fd, umyaddr, addrlen);\n}\n\n/*\n *\tPerform a listen. Basically, we allow the protocol to do anything\n *\tnecessary for a listen, and if that works, we mark the socket as\n *\tready for listening.\n */\n\nint __sys_listen(int fd, int backlog)\n{\n\tstruct socket *sock;\n\tint err, fput_needed;\n\tint somaxconn;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (sock) {\n\t\tsomaxconn = sock_net(sock->sk)->core.sysctl_somaxconn;\n\t\tif ((unsigned int)backlog > somaxconn)\n\t\t\tbacklog = somaxconn;\n\n\t\terr = security_socket_listen(sock, backlog);\n\t\tif (!err)\n\t\t\terr = sock->ops->listen(sock, backlog);\n\n\t\tfput_light(sock->file, fput_needed);\n\t}\n\treturn err;\n}\n\nSYSCALL_DEFINE2(listen, int, fd, int, backlog)\n{\n\treturn __sys_listen(fd, backlog);\n}\n\n/*\n *\tFor accept, we attempt to create a new socket, set up the link\n *\twith the client, wake up the client, then return the new\n *\tconnected fd. We collect the address of the connector in kernel\n *\tspace and move it to user at the very end. This is unclean because\n *\twe open the socket then return an error.\n *\n *\t1003.1g adds the ability to recvmsg() to query connection pending\n *\tstatus to recvmsg. We need to add that support in a way thats\n *\tclean when we restructure accept also.\n */\n\nint __sys_accept4(int fd, struct sockaddr __user *upeer_sockaddr,\n\t\t  int __user *upeer_addrlen, int flags)\n{\n\tstruct socket *sock, *newsock;\n\tstruct file *newfile;\n\tint err, len, newfd, fput_needed;\n\tstruct sockaddr_storage address;\n\n\tif (flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))\n\t\treturn -EINVAL;\n\n\tif (SOCK_NONBLOCK != O_NONBLOCK && (flags & SOCK_NONBLOCK))\n\t\tflags = (flags & ~SOCK_NONBLOCK) | O_NONBLOCK;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\n\terr = -ENFILE;\n\tnewsock = sock_alloc();\n\tif (!newsock)\n\t\tgoto out_put;\n\n\tnewsock->type = sock->type;\n\tnewsock->ops = sock->ops;\n\n\t/*\n\t * We don't need try_module_get here, as the listening socket (sock)\n\t * has the protocol module (sock->ops->owner) held.\n\t */\n\t__module_get(newsock->ops->owner);\n\n\tnewfd = get_unused_fd_flags(flags);\n\tif (unlikely(newfd < 0)) {\n\t\terr = newfd;\n\t\tsock_release(newsock);\n\t\tgoto out_put;\n\t}\n\tnewfile = sock_alloc_file(newsock, flags, sock->sk->sk_prot_creator->name);\n\tif (IS_ERR(newfile)) {\n\t\terr = PTR_ERR(newfile);\n\t\tput_unused_fd(newfd);\n\t\tgoto out_put;\n\t}\n\n\terr = security_socket_accept(sock, newsock);\n\tif (err)\n\t\tgoto out_fd;\n\n\terr = sock->ops->accept(sock, newsock, sock->file->f_flags, false);\n\tif (err < 0)\n\t\tgoto out_fd;\n\n\tif (upeer_sockaddr) {\n\t\tlen = newsock->ops->getname(newsock,\n\t\t\t\t\t(struct sockaddr *)&address, 2);\n\t\tif (len < 0) {\n\t\t\terr = -ECONNABORTED;\n\t\t\tgoto out_fd;\n\t\t}\n\t\terr = move_addr_to_user(&address,\n\t\t\t\t\tlen, upeer_sockaddr, upeer_addrlen);\n\t\tif (err < 0)\n\t\t\tgoto out_fd;\n\t}\n\n\t/* File flags are not inherited via accept() unlike another OSes. */\n\n\tfd_install(newfd, newfile);\n\terr = newfd;\n\nout_put:\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\nout_fd:\n\tfput(newfile);\n\tput_unused_fd(newfd);\n\tgoto out_put;\n}\n\nSYSCALL_DEFINE4(accept4, int, fd, struct sockaddr __user *, upeer_sockaddr,\n\t\tint __user *, upeer_addrlen, int, flags)\n{\n\treturn __sys_accept4(fd, upeer_sockaddr, upeer_addrlen, flags);\n}\n\nSYSCALL_DEFINE3(accept, int, fd, struct sockaddr __user *, upeer_sockaddr,\n\t\tint __user *, upeer_addrlen)\n{\n\treturn __sys_accept4(fd, upeer_sockaddr, upeer_addrlen, 0);\n}\n\n/*\n *\tAttempt to connect to a socket with the server address.  The address\n *\tis in user space so we verify it is OK and move it to kernel space.\n *\n *\tFor 1003.1g we need to add clean support for a bind to AF_UNSPEC to\n *\tbreak bindings\n *\n *\tNOTE: 1003.1g draft 6.3 is broken with respect to AX.25/NetROM and\n *\tother SEQPACKET protocols that take time to connect() as it doesn't\n *\tinclude the -EINPROGRESS status for such sockets.\n */\n\nint __sys_connect(int fd, struct sockaddr __user *uservaddr, int addrlen)\n{\n\tstruct socket *sock;\n\tstruct sockaddr_storage address;\n\tint err, fput_needed;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\terr = move_addr_to_kernel(uservaddr, addrlen, &address);\n\tif (err < 0)\n\t\tgoto out_put;\n\n\terr =\n\t    security_socket_connect(sock, (struct sockaddr *)&address, addrlen);\n\tif (err)\n\t\tgoto out_put;\n\n\terr = sock->ops->connect(sock, (struct sockaddr *)&address, addrlen,\n\t\t\t\t sock->file->f_flags);\nout_put:\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}\n\nSYSCALL_DEFINE3(connect, int, fd, struct sockaddr __user *, uservaddr,\n\t\tint, addrlen)\n{\n\treturn __sys_connect(fd, uservaddr, addrlen);\n}\n\n/*\n *\tGet the local address ('name') of a socket object. Move the obtained\n *\tname to user space.\n */\n\nint __sys_getsockname(int fd, struct sockaddr __user *usockaddr,\n\t\t      int __user *usockaddr_len)\n{\n\tstruct socket *sock;\n\tstruct sockaddr_storage address;\n\tint err, fput_needed;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\n\terr = security_socket_getsockname(sock);\n\tif (err)\n\t\tgoto out_put;\n\n\terr = sock->ops->getname(sock, (struct sockaddr *)&address, 0);\n\tif (err < 0)\n\t\tgoto out_put;\n        /* \"err\" is actually length in this case */\n\terr = move_addr_to_user(&address, err, usockaddr, usockaddr_len);\n\nout_put:\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}\n\nSYSCALL_DEFINE3(getsockname, int, fd, struct sockaddr __user *, usockaddr,\n\t\tint __user *, usockaddr_len)\n{\n\treturn __sys_getsockname(fd, usockaddr, usockaddr_len);\n}\n\n/*\n *\tGet the remote address ('name') of a socket object. Move the obtained\n *\tname to user space.\n */\n\nint __sys_getpeername(int fd, struct sockaddr __user *usockaddr,\n\t\t      int __user *usockaddr_len)\n{\n\tstruct socket *sock;\n\tstruct sockaddr_storage address;\n\tint err, fput_needed;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (sock != NULL) {\n\t\terr = security_socket_getpeername(sock);\n\t\tif (err) {\n\t\t\tfput_light(sock->file, fput_needed);\n\t\t\treturn err;\n\t\t}\n\n\t\terr = sock->ops->getname(sock, (struct sockaddr *)&address, 1);\n\t\tif (err >= 0)\n\t\t\t/* \"err\" is actually length in this case */\n\t\t\terr = move_addr_to_user(&address, err, usockaddr,\n\t\t\t\t\t\tusockaddr_len);\n\t\tfput_light(sock->file, fput_needed);\n\t}\n\treturn err;\n}\n\nSYSCALL_DEFINE3(getpeername, int, fd, struct sockaddr __user *, usockaddr,\n\t\tint __user *, usockaddr_len)\n{\n\treturn __sys_getpeername(fd, usockaddr, usockaddr_len);\n}\n\n/*\n *\tSend a datagram to a given address. We move the address into kernel\n *\tspace and check the user space data area is readable before invoking\n *\tthe protocol.\n */\nint __sys_sendto(int fd, void __user *buff, size_t len, unsigned int flags,\n\t\t struct sockaddr __user *addr,  int addr_len)\n{\n\tstruct socket *sock;\n\tstruct sockaddr_storage address;\n\tint err;\n\tstruct msghdr msg;\n\tstruct iovec iov;\n\tint fput_needed;\n\n\terr = import_single_range(WRITE, buff, len, &iov, &msg.msg_iter);\n\tif (unlikely(err))\n\t\treturn err;\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_control = NULL;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_namelen = 0;\n\tif (addr) {\n\t\terr = move_addr_to_kernel(addr, addr_len, &address);\n\t\tif (err < 0)\n\t\t\tgoto out_put;\n\t\tmsg.msg_name = (struct sockaddr *)&address;\n\t\tmsg.msg_namelen = addr_len;\n\t}\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\tmsg.msg_flags = flags;\n\terr = sock_sendmsg(sock, &msg);\n\nout_put:\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}\n\nSYSCALL_DEFINE6(sendto, int, fd, void __user *, buff, size_t, len,\n\t\tunsigned int, flags, struct sockaddr __user *, addr,\n\t\tint, addr_len)\n{\n\treturn __sys_sendto(fd, buff, len, flags, addr, addr_len);\n}\n\n/*\n *\tSend a datagram down a socket.\n */\n\nSYSCALL_DEFINE4(send, int, fd, void __user *, buff, size_t, len,\n\t\tunsigned int, flags)\n{\n\treturn __sys_sendto(fd, buff, len, flags, NULL, 0);\n}\n\n/*\n *\tReceive a frame from the socket and optionally record the address of the\n *\tsender. We verify the buffers are writable and if needed move the\n *\tsender address from kernel to user space.\n */\nint __sys_recvfrom(int fd, void __user *ubuf, size_t size, unsigned int flags,\n\t\t   struct sockaddr __user *addr, int __user *addr_len)\n{\n\tstruct socket *sock;\n\tstruct iovec iov;\n\tstruct msghdr msg;\n\tstruct sockaddr_storage address;\n\tint err, err2;\n\tint fput_needed;\n\n\terr = import_single_range(READ, ubuf, size, &iov, &msg.msg_iter);\n\tif (unlikely(err))\n\t\treturn err;\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\n\tmsg.msg_control = NULL;\n\tmsg.msg_controllen = 0;\n\t/* Save some cycles and don't copy the address if not needed */\n\tmsg.msg_name = addr ? (struct sockaddr *)&address : NULL;\n\t/* We assume all kernel code knows the size of sockaddr_storage */\n\tmsg.msg_namelen = 0;\n\tmsg.msg_iocb = NULL;\n\tmsg.msg_flags = 0;\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\terr = sock_recvmsg(sock, &msg, flags);\n\n\tif (err >= 0 && addr != NULL) {\n\t\terr2 = move_addr_to_user(&address,\n\t\t\t\t\t msg.msg_namelen, addr, addr_len);\n\t\tif (err2 < 0)\n\t\t\terr = err2;\n\t}\n\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}\n\nSYSCALL_DEFINE6(recvfrom, int, fd, void __user *, ubuf, size_t, size,\n\t\tunsigned int, flags, struct sockaddr __user *, addr,\n\t\tint __user *, addr_len)\n{\n\treturn __sys_recvfrom(fd, ubuf, size, flags, addr, addr_len);\n}\n\n/*\n *\tReceive a datagram from a socket.\n */\n\nSYSCALL_DEFINE4(recv, int, fd, void __user *, ubuf, size_t, size,\n\t\tunsigned int, flags)\n{\n\treturn __sys_recvfrom(fd, ubuf, size, flags, NULL, NULL);\n}\n\n/*\n *\tSet a socket option. Because we don't know the option lengths we have\n *\tto pass the user mode parameter for the protocols to sort out.\n */\n\nstatic int __sys_setsockopt(int fd, int level, int optname,\n\t\t\t    char __user *optval, int optlen)\n{\n\tint err, fput_needed;\n\tstruct socket *sock;\n\n\tif (optlen < 0)\n\t\treturn -EINVAL;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (sock != NULL) {\n\t\terr = security_socket_setsockopt(sock, level, optname);\n\t\tif (err)\n\t\t\tgoto out_put;\n\n\t\tif (level == SOL_SOCKET)\n\t\t\terr =\n\t\t\t    sock_setsockopt(sock, level, optname, optval,\n\t\t\t\t\t    optlen);\n\t\telse\n\t\t\terr =\n\t\t\t    sock->ops->setsockopt(sock, level, optname, optval,\n\t\t\t\t\t\t  optlen);\nout_put:\n\t\tfput_light(sock->file, fput_needed);\n\t}\n\treturn err;\n}\n\nSYSCALL_DEFINE5(setsockopt, int, fd, int, level, int, optname,\n\t\tchar __user *, optval, int, optlen)\n{\n\treturn __sys_setsockopt(fd, level, optname, optval, optlen);\n}\n\n/*\n *\tGet a socket option. Because we don't know the option lengths we have\n *\tto pass a user mode parameter for the protocols to sort out.\n */\n\nstatic int __sys_getsockopt(int fd, int level, int optname,\n\t\t\t    char __user *optval, int __user *optlen)\n{\n\tint err, fput_needed;\n\tstruct socket *sock;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (sock != NULL) {\n\t\terr = security_socket_getsockopt(sock, level, optname);\n\t\tif (err)\n\t\t\tgoto out_put;\n\n\t\tif (level == SOL_SOCKET)\n\t\t\terr =\n\t\t\t    sock_getsockopt(sock, level, optname, optval,\n\t\t\t\t\t    optlen);\n\t\telse\n\t\t\terr =\n\t\t\t    sock->ops->getsockopt(sock, level, optname, optval,\n\t\t\t\t\t\t  optlen);\nout_put:\n\t\tfput_light(sock->file, fput_needed);\n\t}\n\treturn err;\n}\n\nSYSCALL_DEFINE5(getsockopt, int, fd, int, level, int, optname,\n\t\tchar __user *, optval, int __user *, optlen)\n{\n\treturn __sys_getsockopt(fd, level, optname, optval, optlen);\n}\n\n/*\n *\tShutdown a socket.\n */\n\nint __sys_shutdown(int fd, int how)\n{\n\tint err, fput_needed;\n\tstruct socket *sock;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (sock != NULL) {\n\t\terr = security_socket_shutdown(sock, how);\n\t\tif (!err)\n\t\t\terr = sock->ops->shutdown(sock, how);\n\t\tfput_light(sock->file, fput_needed);\n\t}\n\treturn err;\n}\n\nSYSCALL_DEFINE2(shutdown, int, fd, int, how)\n{\n\treturn __sys_shutdown(fd, how);\n}\n\n/* A couple of helpful macros for getting the address of the 32/64 bit\n * fields which are the same type (int / unsigned) on our platforms.\n */\n#define COMPAT_MSG(msg, member)\t((MSG_CMSG_COMPAT & flags) ? &msg##_compat->member : &msg->member)\n#define COMPAT_NAMELEN(msg)\tCOMPAT_MSG(msg, msg_namelen)\n#define COMPAT_FLAGS(msg)\tCOMPAT_MSG(msg, msg_flags)\n\nstruct used_address {\n\tstruct sockaddr_storage name;\n\tunsigned int name_len;\n};\n\nstatic int copy_msghdr_from_user(struct msghdr *kmsg,\n\t\t\t\t struct user_msghdr __user *umsg,\n\t\t\t\t struct sockaddr __user **save_addr,\n\t\t\t\t struct iovec **iov)\n{\n\tstruct user_msghdr msg;\n\tssize_t err;\n\n\tif (copy_from_user(&msg, umsg, sizeof(*umsg)))\n\t\treturn -EFAULT;\n\n\tkmsg->msg_control = (void __force *)msg.msg_control;\n\tkmsg->msg_controllen = msg.msg_controllen;\n\tkmsg->msg_flags = msg.msg_flags;\n\n\tkmsg->msg_namelen = msg.msg_namelen;\n\tif (!msg.msg_name)\n\t\tkmsg->msg_namelen = 0;\n\n\tif (kmsg->msg_namelen < 0)\n\t\treturn -EINVAL;\n\n\tif (kmsg->msg_namelen > sizeof(struct sockaddr_storage))\n\t\tkmsg->msg_namelen = sizeof(struct sockaddr_storage);\n\n\tif (save_addr)\n\t\t*save_addr = msg.msg_name;\n\n\tif (msg.msg_name && kmsg->msg_namelen) {\n\t\tif (!save_addr) {\n\t\t\terr = move_addr_to_kernel(msg.msg_name,\n\t\t\t\t\t\t  kmsg->msg_namelen,\n\t\t\t\t\t\t  kmsg->msg_name);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tkmsg->msg_name = NULL;\n\t\tkmsg->msg_namelen = 0;\n\t}\n\n\tif (msg.msg_iovlen > UIO_MAXIOV)\n\t\treturn -EMSGSIZE;\n\n\tkmsg->msg_iocb = NULL;\n\n\treturn import_iovec(save_addr ? READ : WRITE,\n\t\t\t    msg.msg_iov, msg.msg_iovlen,\n\t\t\t    UIO_FASTIOV, iov, &kmsg->msg_iter);\n}\n\nstatic int ___sys_sendmsg(struct socket *sock, struct user_msghdr __user *msg,\n\t\t\t struct msghdr *msg_sys, unsigned int flags,\n\t\t\t struct used_address *used_address,\n\t\t\t unsigned int allowed_msghdr_flags)\n{\n\tstruct compat_msghdr __user *msg_compat =\n\t    (struct compat_msghdr __user *)msg;\n\tstruct sockaddr_storage address;\n\tstruct iovec iovstack[UIO_FASTIOV], *iov = iovstack;\n\tunsigned char ctl[sizeof(struct cmsghdr) + 20]\n\t\t\t\t__aligned(sizeof(__kernel_size_t));\n\t/* 20 is size of ipv6_pktinfo */\n\tunsigned char *ctl_buf = ctl;\n\tint ctl_len;\n\tssize_t err;\n\n\tmsg_sys->msg_name = &address;\n\n\tif (MSG_CMSG_COMPAT & flags)\n\t\terr = get_compat_msghdr(msg_sys, msg_compat, NULL, &iov);\n\telse\n\t\terr = copy_msghdr_from_user(msg_sys, msg, NULL, &iov);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = -ENOBUFS;\n\n\tif (msg_sys->msg_controllen > INT_MAX)\n\t\tgoto out_freeiov;\n\tflags |= (msg_sys->msg_flags & allowed_msghdr_flags);\n\tctl_len = msg_sys->msg_controllen;\n\tif ((MSG_CMSG_COMPAT & flags) && ctl_len) {\n\t\terr =\n\t\t    cmsghdr_from_user_compat_to_kern(msg_sys, sock->sk, ctl,\n\t\t\t\t\t\t     sizeof(ctl));\n\t\tif (err)\n\t\t\tgoto out_freeiov;\n\t\tctl_buf = msg_sys->msg_control;\n\t\tctl_len = msg_sys->msg_controllen;\n\t} else if (ctl_len) {\n\t\tBUILD_BUG_ON(sizeof(struct cmsghdr) !=\n\t\t\t     CMSG_ALIGN(sizeof(struct cmsghdr)));\n\t\tif (ctl_len > sizeof(ctl)) {\n\t\t\tctl_buf = sock_kmalloc(sock->sk, ctl_len, GFP_KERNEL);\n\t\t\tif (ctl_buf == NULL)\n\t\t\t\tgoto out_freeiov;\n\t\t}\n\t\terr = -EFAULT;\n\t\t/*\n\t\t * Careful! Before this, msg_sys->msg_control contains a user pointer.\n\t\t * Afterwards, it will be a kernel pointer. Thus the compiler-assisted\n\t\t * checking falls down on this.\n\t\t */\n\t\tif (copy_from_user(ctl_buf,\n\t\t\t\t   (void __user __force *)msg_sys->msg_control,\n\t\t\t\t   ctl_len))\n\t\t\tgoto out_freectl;\n\t\tmsg_sys->msg_control = ctl_buf;\n\t}\n\tmsg_sys->msg_flags = flags;\n\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tmsg_sys->msg_flags |= MSG_DONTWAIT;\n\t/*\n\t * If this is sendmmsg() and current destination address is same as\n\t * previously succeeded address, omit asking LSM's decision.\n\t * used_address->name_len is initialized to UINT_MAX so that the first\n\t * destination address never matches.\n\t */\n\tif (used_address && msg_sys->msg_name &&\n\t    used_address->name_len == msg_sys->msg_namelen &&\n\t    !memcmp(&used_address->name, msg_sys->msg_name,\n\t\t    used_address->name_len)) {\n\t\terr = sock_sendmsg_nosec(sock, msg_sys);\n\t\tgoto out_freectl;\n\t}\n\terr = sock_sendmsg(sock, msg_sys);\n\t/*\n\t * If this is sendmmsg() and sending to current destination address was\n\t * successful, remember it.\n\t */\n\tif (used_address && err >= 0) {\n\t\tused_address->name_len = msg_sys->msg_namelen;\n\t\tif (msg_sys->msg_name)\n\t\t\tmemcpy(&used_address->name, msg_sys->msg_name,\n\t\t\t       used_address->name_len);\n\t}\n\nout_freectl:\n\tif (ctl_buf != ctl)\n\t\tsock_kfree_s(sock->sk, ctl_buf, ctl_len);\nout_freeiov:\n\tkfree(iov);\n\treturn err;\n}\n\n/*\n *\tBSD sendmsg interface\n */\n\nlong __sys_sendmsg(int fd, struct user_msghdr __user *msg, unsigned int flags,\n\t\t   bool forbid_cmsg_compat)\n{\n\tint fput_needed, err;\n\tstruct msghdr msg_sys;\n\tstruct socket *sock;\n\n\tif (forbid_cmsg_compat && (flags & MSG_CMSG_COMPAT))\n\t\treturn -EINVAL;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\n\terr = ___sys_sendmsg(sock, msg, &msg_sys, flags, NULL, 0);\n\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}\n\nSYSCALL_DEFINE3(sendmsg, int, fd, struct user_msghdr __user *, msg, unsigned int, flags)\n{\n\treturn __sys_sendmsg(fd, msg, flags, true);\n}\n\n/*\n *\tLinux sendmmsg interface\n */\n\nint __sys_sendmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,\n\t\t   unsigned int flags, bool forbid_cmsg_compat)\n{\n\tint fput_needed, err, datagrams;\n\tstruct socket *sock;\n\tstruct mmsghdr __user *entry;\n\tstruct compat_mmsghdr __user *compat_entry;\n\tstruct msghdr msg_sys;\n\tstruct used_address used_address;\n\tunsigned int oflags = flags;\n\n\tif (forbid_cmsg_compat && (flags & MSG_CMSG_COMPAT))\n\t\treturn -EINVAL;\n\n\tif (vlen > UIO_MAXIOV)\n\t\tvlen = UIO_MAXIOV;\n\n\tdatagrams = 0;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\treturn err;\n\n\tused_address.name_len = UINT_MAX;\n\tentry = mmsg;\n\tcompat_entry = (struct compat_mmsghdr __user *)mmsg;\n\terr = 0;\n\tflags |= MSG_BATCH;\n\n\twhile (datagrams < vlen) {\n\t\tif (datagrams == vlen - 1)\n\t\t\tflags = oflags;\n\n\t\tif (MSG_CMSG_COMPAT & flags) {\n\t\t\terr = ___sys_sendmsg(sock, (struct user_msghdr __user *)compat_entry,\n\t\t\t\t\t     &msg_sys, flags, &used_address, MSG_EOR);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\terr = __put_user(err, &compat_entry->msg_len);\n\t\t\t++compat_entry;\n\t\t} else {\n\t\t\terr = ___sys_sendmsg(sock,\n\t\t\t\t\t     (struct user_msghdr __user *)entry,\n\t\t\t\t\t     &msg_sys, flags, &used_address, MSG_EOR);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\terr = put_user(err, &entry->msg_len);\n\t\t\t++entry;\n\t\t}\n\n\t\tif (err)\n\t\t\tbreak;\n\t\t++datagrams;\n\t\tif (msg_data_left(&msg_sys))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\n\tfput_light(sock->file, fput_needed);\n\n\t/* We only return an error if no datagrams were able to be sent */\n\tif (datagrams != 0)\n\t\treturn datagrams;\n\n\treturn err;\n}\n\nSYSCALL_DEFINE4(sendmmsg, int, fd, struct mmsghdr __user *, mmsg,\n\t\tunsigned int, vlen, unsigned int, flags)\n{\n\treturn __sys_sendmmsg(fd, mmsg, vlen, flags, true);\n}\n\nstatic int ___sys_recvmsg(struct socket *sock, struct user_msghdr __user *msg,\n\t\t\t struct msghdr *msg_sys, unsigned int flags, int nosec)\n{\n\tstruct compat_msghdr __user *msg_compat =\n\t    (struct compat_msghdr __user *)msg;\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tunsigned long cmsg_ptr;\n\tint len;\n\tssize_t err;\n\n\t/* kernel mode address */\n\tstruct sockaddr_storage addr;\n\n\t/* user mode address pointers */\n\tstruct sockaddr __user *uaddr;\n\tint __user *uaddr_len = COMPAT_NAMELEN(msg);\n\n\tmsg_sys->msg_name = &addr;\n\n\tif (MSG_CMSG_COMPAT & flags)\n\t\terr = get_compat_msghdr(msg_sys, msg_compat, &uaddr, &iov);\n\telse\n\t\terr = copy_msghdr_from_user(msg_sys, msg, &uaddr, &iov);\n\tif (err < 0)\n\t\treturn err;\n\n\tcmsg_ptr = (unsigned long)msg_sys->msg_control;\n\tmsg_sys->msg_flags = flags & (MSG_CMSG_CLOEXEC|MSG_CMSG_COMPAT);\n\n\t/* We assume all kernel code knows the size of sockaddr_storage */\n\tmsg_sys->msg_namelen = 0;\n\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\terr = (nosec ? sock_recvmsg_nosec : sock_recvmsg)(sock, msg_sys, flags);\n\tif (err < 0)\n\t\tgoto out_freeiov;\n\tlen = err;\n\n\tif (uaddr != NULL) {\n\t\terr = move_addr_to_user(&addr,\n\t\t\t\t\tmsg_sys->msg_namelen, uaddr,\n\t\t\t\t\tuaddr_len);\n\t\tif (err < 0)\n\t\t\tgoto out_freeiov;\n\t}\n\terr = __put_user((msg_sys->msg_flags & ~MSG_CMSG_COMPAT),\n\t\t\t COMPAT_FLAGS(msg));\n\tif (err)\n\t\tgoto out_freeiov;\n\tif (MSG_CMSG_COMPAT & flags)\n\t\terr = __put_user((unsigned long)msg_sys->msg_control - cmsg_ptr,\n\t\t\t\t &msg_compat->msg_controllen);\n\telse\n\t\terr = __put_user((unsigned long)msg_sys->msg_control - cmsg_ptr,\n\t\t\t\t &msg->msg_controllen);\n\tif (err)\n\t\tgoto out_freeiov;\n\terr = len;\n\nout_freeiov:\n\tkfree(iov);\n\treturn err;\n}\n\n/*\n *\tBSD recvmsg interface\n */\n\nlong __sys_recvmsg(int fd, struct user_msghdr __user *msg, unsigned int flags,\n\t\t   bool forbid_cmsg_compat)\n{\n\tint fput_needed, err;\n\tstruct msghdr msg_sys;\n\tstruct socket *sock;\n\n\tif (forbid_cmsg_compat && (flags & MSG_CMSG_COMPAT))\n\t\treturn -EINVAL;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\n\terr = ___sys_recvmsg(sock, msg, &msg_sys, flags, 0);\n\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}\n\nSYSCALL_DEFINE3(recvmsg, int, fd, struct user_msghdr __user *, msg,\n\t\tunsigned int, flags)\n{\n\treturn __sys_recvmsg(fd, msg, flags, true);\n}\n\n/*\n *     Linux recvmmsg interface\n */\n\nint __sys_recvmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,\n\t\t   unsigned int flags, struct timespec *timeout)\n{\n\tint fput_needed, err, datagrams;\n\tstruct socket *sock;\n\tstruct mmsghdr __user *entry;\n\tstruct compat_mmsghdr __user *compat_entry;\n\tstruct msghdr msg_sys;\n\tstruct timespec64 end_time;\n\tstruct timespec64 timeout64;\n\n\tif (timeout &&\n\t    poll_select_set_timeout(&end_time, timeout->tv_sec,\n\t\t\t\t    timeout->tv_nsec))\n\t\treturn -EINVAL;\n\n\tdatagrams = 0;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\treturn err;\n\n\tif (likely(!(flags & MSG_ERRQUEUE))) {\n\t\terr = sock_error(sock->sk);\n\t\tif (err) {\n\t\t\tdatagrams = err;\n\t\t\tgoto out_put;\n\t\t}\n\t}\n\n\tentry = mmsg;\n\tcompat_entry = (struct compat_mmsghdr __user *)mmsg;\n\n\twhile (datagrams < vlen) {\n\t\t/*\n\t\t * No need to ask LSM for more than the first datagram.\n\t\t */\n\t\tif (MSG_CMSG_COMPAT & flags) {\n\t\t\terr = ___sys_recvmsg(sock, (struct user_msghdr __user *)compat_entry,\n\t\t\t\t\t     &msg_sys, flags & ~MSG_WAITFORONE,\n\t\t\t\t\t     datagrams);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\terr = __put_user(err, &compat_entry->msg_len);\n\t\t\t++compat_entry;\n\t\t} else {\n\t\t\terr = ___sys_recvmsg(sock,\n\t\t\t\t\t     (struct user_msghdr __user *)entry,\n\t\t\t\t\t     &msg_sys, flags & ~MSG_WAITFORONE,\n\t\t\t\t\t     datagrams);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\terr = put_user(err, &entry->msg_len);\n\t\t\t++entry;\n\t\t}\n\n\t\tif (err)\n\t\t\tbreak;\n\t\t++datagrams;\n\n\t\t/* MSG_WAITFORONE turns on MSG_DONTWAIT after one packet */\n\t\tif (flags & MSG_WAITFORONE)\n\t\t\tflags |= MSG_DONTWAIT;\n\n\t\tif (timeout) {\n\t\t\tktime_get_ts64(&timeout64);\n\t\t\t*timeout = timespec64_to_timespec(\n\t\t\t\t\ttimespec64_sub(end_time, timeout64));\n\t\t\tif (timeout->tv_sec < 0) {\n\t\t\t\ttimeout->tv_sec = timeout->tv_nsec = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Timeout, return less than vlen datagrams */\n\t\t\tif (timeout->tv_nsec == 0 && timeout->tv_sec == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Out of band data, return right away */\n\t\tif (msg_sys.msg_flags & MSG_OOB)\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\n\tif (err == 0)\n\t\tgoto out_put;\n\n\tif (datagrams == 0) {\n\t\tdatagrams = err;\n\t\tgoto out_put;\n\t}\n\n\t/*\n\t * We may return less entries than requested (vlen) if the\n\t * sock is non block and there aren't enough datagrams...\n\t */\n\tif (err != -EAGAIN) {\n\t\t/*\n\t\t * ... or  if recvmsg returns an error after we\n\t\t * received some datagrams, where we record the\n\t\t * error to return on the next call or if the\n\t\t * app asks about it using getsockopt(SO_ERROR).\n\t\t */\n\t\tsock->sk->sk_err = -err;\n\t}\nout_put:\n\tfput_light(sock->file, fput_needed);\n\n\treturn datagrams;\n}\n\nstatic int do_sys_recvmmsg(int fd, struct mmsghdr __user *mmsg,\n\t\t\t   unsigned int vlen, unsigned int flags,\n\t\t\t   struct timespec __user *timeout)\n{\n\tint datagrams;\n\tstruct timespec timeout_sys;\n\n\tif (flags & MSG_CMSG_COMPAT)\n\t\treturn -EINVAL;\n\n\tif (!timeout)\n\t\treturn __sys_recvmmsg(fd, mmsg, vlen, flags, NULL);\n\n\tif (copy_from_user(&timeout_sys, timeout, sizeof(timeout_sys)))\n\t\treturn -EFAULT;\n\n\tdatagrams = __sys_recvmmsg(fd, mmsg, vlen, flags, &timeout_sys);\n\n\tif (datagrams > 0 &&\n\t    copy_to_user(timeout, &timeout_sys, sizeof(timeout_sys)))\n\t\tdatagrams = -EFAULT;\n\n\treturn datagrams;\n}\n\nSYSCALL_DEFINE5(recvmmsg, int, fd, struct mmsghdr __user *, mmsg,\n\t\tunsigned int, vlen, unsigned int, flags,\n\t\tstruct timespec __user *, timeout)\n{\n\treturn do_sys_recvmmsg(fd, mmsg, vlen, flags, timeout);\n}\n\n#ifdef __ARCH_WANT_SYS_SOCKETCALL\n/* Argument list sizes for sys_socketcall */\n#define AL(x) ((x) * sizeof(unsigned long))\nstatic const unsigned char nargs[21] = {\n\tAL(0), AL(3), AL(3), AL(3), AL(2), AL(3),\n\tAL(3), AL(3), AL(4), AL(4), AL(4), AL(6),\n\tAL(6), AL(2), AL(5), AL(5), AL(3), AL(3),\n\tAL(4), AL(5), AL(4)\n};\n\n#undef AL\n\n/*\n *\tSystem call vectors.\n *\n *\tArgument checking cleaned up. Saved 20% in size.\n *  This function doesn't need to set the kernel lock because\n *  it is set by the callees.\n */\n\nSYSCALL_DEFINE2(socketcall, int, call, unsigned long __user *, args)\n{\n\tunsigned long a[AUDITSC_ARGS];\n\tunsigned long a0, a1;\n\tint err;\n\tunsigned int len;\n\n\tif (call < 1 || call > SYS_SENDMMSG)\n\t\treturn -EINVAL;\n\n\tlen = nargs[call];\n\tif (len > sizeof(a))\n\t\treturn -EINVAL;\n\n\t/* copy_from_user should be SMP safe. */\n\tif (copy_from_user(a, args, len))\n\t\treturn -EFAULT;\n\n\terr = audit_socketcall(nargs[call] / sizeof(unsigned long), a);\n\tif (err)\n\t\treturn err;\n\n\ta0 = a[0];\n\ta1 = a[1];\n\n\tswitch (call) {\n\tcase SYS_SOCKET:\n\t\terr = __sys_socket(a0, a1, a[2]);\n\t\tbreak;\n\tcase SYS_BIND:\n\t\terr = __sys_bind(a0, (struct sockaddr __user *)a1, a[2]);\n\t\tbreak;\n\tcase SYS_CONNECT:\n\t\terr = __sys_connect(a0, (struct sockaddr __user *)a1, a[2]);\n\t\tbreak;\n\tcase SYS_LISTEN:\n\t\terr = __sys_listen(a0, a1);\n\t\tbreak;\n\tcase SYS_ACCEPT:\n\t\terr = __sys_accept4(a0, (struct sockaddr __user *)a1,\n\t\t\t\t    (int __user *)a[2], 0);\n\t\tbreak;\n\tcase SYS_GETSOCKNAME:\n\t\terr =\n\t\t    __sys_getsockname(a0, (struct sockaddr __user *)a1,\n\t\t\t\t      (int __user *)a[2]);\n\t\tbreak;\n\tcase SYS_GETPEERNAME:\n\t\terr =\n\t\t    __sys_getpeername(a0, (struct sockaddr __user *)a1,\n\t\t\t\t      (int __user *)a[2]);\n\t\tbreak;\n\tcase SYS_SOCKETPAIR:\n\t\terr = __sys_socketpair(a0, a1, a[2], (int __user *)a[3]);\n\t\tbreak;\n\tcase SYS_SEND:\n\t\terr = __sys_sendto(a0, (void __user *)a1, a[2], a[3],\n\t\t\t\t   NULL, 0);\n\t\tbreak;\n\tcase SYS_SENDTO:\n\t\terr = __sys_sendto(a0, (void __user *)a1, a[2], a[3],\n\t\t\t\t   (struct sockaddr __user *)a[4], a[5]);\n\t\tbreak;\n\tcase SYS_RECV:\n\t\terr = __sys_recvfrom(a0, (void __user *)a1, a[2], a[3],\n\t\t\t\t     NULL, NULL);\n\t\tbreak;\n\tcase SYS_RECVFROM:\n\t\terr = __sys_recvfrom(a0, (void __user *)a1, a[2], a[3],\n\t\t\t\t     (struct sockaddr __user *)a[4],\n\t\t\t\t     (int __user *)a[5]);\n\t\tbreak;\n\tcase SYS_SHUTDOWN:\n\t\terr = __sys_shutdown(a0, a1);\n\t\tbreak;\n\tcase SYS_SETSOCKOPT:\n\t\terr = __sys_setsockopt(a0, a1, a[2], (char __user *)a[3],\n\t\t\t\t       a[4]);\n\t\tbreak;\n\tcase SYS_GETSOCKOPT:\n\t\terr =\n\t\t    __sys_getsockopt(a0, a1, a[2], (char __user *)a[3],\n\t\t\t\t     (int __user *)a[4]);\n\t\tbreak;\n\tcase SYS_SENDMSG:\n\t\terr = __sys_sendmsg(a0, (struct user_msghdr __user *)a1,\n\t\t\t\t    a[2], true);\n\t\tbreak;\n\tcase SYS_SENDMMSG:\n\t\terr = __sys_sendmmsg(a0, (struct mmsghdr __user *)a1, a[2],\n\t\t\t\t     a[3], true);\n\t\tbreak;\n\tcase SYS_RECVMSG:\n\t\terr = __sys_recvmsg(a0, (struct user_msghdr __user *)a1,\n\t\t\t\t    a[2], true);\n\t\tbreak;\n\tcase SYS_RECVMMSG:\n\t\terr = do_sys_recvmmsg(a0, (struct mmsghdr __user *)a1, a[2],\n\t\t\t\t      a[3], (struct timespec __user *)a[4]);\n\t\tbreak;\n\tcase SYS_ACCEPT4:\n\t\terr = __sys_accept4(a0, (struct sockaddr __user *)a1,\n\t\t\t\t    (int __user *)a[2], a[3]);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\treturn err;\n}\n\n#endif\t\t\t\t/* __ARCH_WANT_SYS_SOCKETCALL */\n\n/**\n *\tsock_register - add a socket protocol handler\n *\t@ops: description of protocol\n *\n *\tThis function is called by a protocol handler that wants to\n *\tadvertise its address family, and have it linked into the\n *\tsocket interface. The value ops->family corresponds to the\n *\tsocket system call protocol family.\n */\nint sock_register(const struct net_proto_family *ops)\n{\n\tint err;\n\n\tif (ops->family >= NPROTO) {\n\t\tpr_crit(\"protocol %d >= NPROTO(%d)\\n\", ops->family, NPROTO);\n\t\treturn -ENOBUFS;\n\t}\n\n\tspin_lock(&net_family_lock);\n\tif (rcu_dereference_protected(net_families[ops->family],\n\t\t\t\t      lockdep_is_held(&net_family_lock)))\n\t\terr = -EEXIST;\n\telse {\n\t\trcu_assign_pointer(net_families[ops->family], ops);\n\t\terr = 0;\n\t}\n\tspin_unlock(&net_family_lock);\n\n\tpr_info(\"NET: Registered protocol family %d\\n\", ops->family);\n\treturn err;\n}\nEXPORT_SYMBOL(sock_register);\n\n/**\n *\tsock_unregister - remove a protocol handler\n *\t@family: protocol family to remove\n *\n *\tThis function is called by a protocol handler that wants to\n *\tremove its address family, and have it unlinked from the\n *\tnew socket creation.\n *\n *\tIf protocol handler is a module, then it can use module reference\n *\tcounts to protect against new references. If protocol handler is not\n *\ta module then it needs to provide its own protection in\n *\tthe ops->create routine.\n */\nvoid sock_unregister(int family)\n{\n\tBUG_ON(family < 0 || family >= NPROTO);\n\n\tspin_lock(&net_family_lock);\n\tRCU_INIT_POINTER(net_families[family], NULL);\n\tspin_unlock(&net_family_lock);\n\n\tsynchronize_rcu();\n\n\tpr_info(\"NET: Unregistered protocol family %d\\n\", family);\n}\nEXPORT_SYMBOL(sock_unregister);\n\nbool sock_is_registered(int family)\n{\n\treturn family < NPROTO && rcu_access_pointer(net_families[family]);\n}\n\nstatic int __init sock_init(void)\n{\n\tint err;\n\t/*\n\t *      Initialize the network sysctl infrastructure.\n\t */\n\terr = net_sysctl_init();\n\tif (err)\n\t\tgoto out;\n\n\t/*\n\t *      Initialize skbuff SLAB cache\n\t */\n\tskb_init();\n\n\t/*\n\t *      Initialize the protocols module.\n\t */\n\n\tinit_inodecache();\n\n\terr = register_filesystem(&sock_fs_type);\n\tif (err)\n\t\tgoto out_fs;\n\tsock_mnt = kern_mount(&sock_fs_type);\n\tif (IS_ERR(sock_mnt)) {\n\t\terr = PTR_ERR(sock_mnt);\n\t\tgoto out_mount;\n\t}\n\n\t/* The real protocol initialization is performed in later initcalls.\n\t */\n\n#ifdef CONFIG_NETFILTER\n\terr = netfilter_init();\n\tif (err)\n\t\tgoto out;\n#endif\n\n\tptp_classifier_init();\n\nout:\n\treturn err;\n\nout_mount:\n\tunregister_filesystem(&sock_fs_type);\nout_fs:\n\tgoto out;\n}\n\ncore_initcall(sock_init);\t/* early initcall */\n\n#ifdef CONFIG_PROC_FS\nvoid socket_seq_show(struct seq_file *seq)\n{\n\tseq_printf(seq, \"sockets: used %d\\n\",\n\t\t   sock_inuse_get(seq->private));\n}\n#endif\t\t\t\t/* CONFIG_PROC_FS */\n\n#ifdef CONFIG_COMPAT\nstatic int do_siocgstamp(struct net *net, struct socket *sock,\n\t\t\t unsigned int cmd, void __user *up)\n{\n\tmm_segment_t old_fs = get_fs();\n\tstruct timeval ktv;\n\tint err;\n\n\tset_fs(KERNEL_DS);\n\terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&ktv);\n\tset_fs(old_fs);\n\tif (!err)\n\t\terr = compat_put_timeval(&ktv, up);\n\n\treturn err;\n}\n\nstatic int do_siocgstampns(struct net *net, struct socket *sock,\n\t\t\t   unsigned int cmd, void __user *up)\n{\n\tmm_segment_t old_fs = get_fs();\n\tstruct timespec kts;\n\tint err;\n\n\tset_fs(KERNEL_DS);\n\terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&kts);\n\tset_fs(old_fs);\n\tif (!err)\n\t\terr = compat_put_timespec(&kts, up);\n\n\treturn err;\n}\n\nstatic int compat_dev_ifconf(struct net *net, struct compat_ifconf __user *uifc32)\n{\n\tstruct compat_ifconf ifc32;\n\tstruct ifconf ifc;\n\tint err;\n\n\tif (copy_from_user(&ifc32, uifc32, sizeof(struct compat_ifconf)))\n\t\treturn -EFAULT;\n\n\tifc.ifc_len = ifc32.ifc_len;\n\tifc.ifc_req = compat_ptr(ifc32.ifcbuf);\n\n\trtnl_lock();\n\terr = dev_ifconf(net, &ifc, sizeof(struct compat_ifreq));\n\trtnl_unlock();\n\tif (err)\n\t\treturn err;\n\n\tifc32.ifc_len = ifc.ifc_len;\n\tif (copy_to_user(uifc32, &ifc32, sizeof(struct compat_ifconf)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int ethtool_ioctl(struct net *net, struct compat_ifreq __user *ifr32)\n{\n\tstruct compat_ethtool_rxnfc __user *compat_rxnfc;\n\tbool convert_in = false, convert_out = false;\n\tsize_t buf_size = 0;\n\tstruct ethtool_rxnfc __user *rxnfc = NULL;\n\tstruct ifreq ifr;\n\tu32 rule_cnt = 0, actual_rule_cnt;\n\tu32 ethcmd;\n\tu32 data;\n\tint ret;\n\n\tif (get_user(data, &ifr32->ifr_ifru.ifru_data))\n\t\treturn -EFAULT;\n\n\tcompat_rxnfc = compat_ptr(data);\n\n\tif (get_user(ethcmd, &compat_rxnfc->cmd))\n\t\treturn -EFAULT;\n\n\t/* Most ethtool structures are defined without padding.\n\t * Unfortunately struct ethtool_rxnfc is an exception.\n\t */\n\tswitch (ethcmd) {\n\tdefault:\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLALL:\n\t\t/* Buffer size is variable */\n\t\tif (get_user(rule_cnt, &compat_rxnfc->rule_cnt))\n\t\t\treturn -EFAULT;\n\t\tif (rule_cnt > KMALLOC_MAX_SIZE / sizeof(u32))\n\t\t\treturn -ENOMEM;\n\t\tbuf_size += rule_cnt * sizeof(u32);\n\t\t/* fall through */\n\tcase ETHTOOL_GRXRINGS:\n\tcase ETHTOOL_GRXCLSRLCNT:\n\tcase ETHTOOL_GRXCLSRULE:\n\tcase ETHTOOL_SRXCLSRLINS:\n\t\tconvert_out = true;\n\t\t/* fall through */\n\tcase ETHTOOL_SRXCLSRLDEL:\n\t\tbuf_size += sizeof(struct ethtool_rxnfc);\n\t\tconvert_in = true;\n\t\trxnfc = compat_alloc_user_space(buf_size);\n\t\tbreak;\n\t}\n\n\tif (copy_from_user(&ifr.ifr_name, &ifr32->ifr_name, IFNAMSIZ))\n\t\treturn -EFAULT;\n\n\tifr.ifr_data = convert_in ? rxnfc : (void __user *)compat_rxnfc;\n\n\tif (convert_in) {\n\t\t/* We expect there to be holes between fs.m_ext and\n\t\t * fs.ring_cookie and at the end of fs, but nowhere else.\n\t\t */\n\t\tBUILD_BUG_ON(offsetof(struct compat_ethtool_rxnfc, fs.m_ext) +\n\t\t\t     sizeof(compat_rxnfc->fs.m_ext) !=\n\t\t\t     offsetof(struct ethtool_rxnfc, fs.m_ext) +\n\t\t\t     sizeof(rxnfc->fs.m_ext));\n\t\tBUILD_BUG_ON(\n\t\t\toffsetof(struct compat_ethtool_rxnfc, fs.location) -\n\t\t\toffsetof(struct compat_ethtool_rxnfc, fs.ring_cookie) !=\n\t\t\toffsetof(struct ethtool_rxnfc, fs.location) -\n\t\t\toffsetof(struct ethtool_rxnfc, fs.ring_cookie));\n\n\t\tif (copy_in_user(rxnfc, compat_rxnfc,\n\t\t\t\t (void __user *)(&rxnfc->fs.m_ext + 1) -\n\t\t\t\t (void __user *)rxnfc) ||\n\t\t    copy_in_user(&rxnfc->fs.ring_cookie,\n\t\t\t\t &compat_rxnfc->fs.ring_cookie,\n\t\t\t\t (void __user *)(&rxnfc->fs.location + 1) -\n\t\t\t\t (void __user *)&rxnfc->fs.ring_cookie) ||\n\t\t    copy_in_user(&rxnfc->rule_cnt, &compat_rxnfc->rule_cnt,\n\t\t\t\t sizeof(rxnfc->rule_cnt)))\n\t\t\treturn -EFAULT;\n\t}\n\n\tret = dev_ioctl(net, SIOCETHTOOL, &ifr, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (convert_out) {\n\t\tif (copy_in_user(compat_rxnfc, rxnfc,\n\t\t\t\t (const void __user *)(&rxnfc->fs.m_ext + 1) -\n\t\t\t\t (const void __user *)rxnfc) ||\n\t\t    copy_in_user(&compat_rxnfc->fs.ring_cookie,\n\t\t\t\t &rxnfc->fs.ring_cookie,\n\t\t\t\t (const void __user *)(&rxnfc->fs.location + 1) -\n\t\t\t\t (const void __user *)&rxnfc->fs.ring_cookie) ||\n\t\t    copy_in_user(&compat_rxnfc->rule_cnt, &rxnfc->rule_cnt,\n\t\t\t\t sizeof(rxnfc->rule_cnt)))\n\t\t\treturn -EFAULT;\n\n\t\tif (ethcmd == ETHTOOL_GRXCLSRLALL) {\n\t\t\t/* As an optimisation, we only copy the actual\n\t\t\t * number of rules that the underlying\n\t\t\t * function returned.  Since Mallory might\n\t\t\t * change the rule count in user memory, we\n\t\t\t * check that it is less than the rule count\n\t\t\t * originally given (as the user buffer size),\n\t\t\t * which has been range-checked.\n\t\t\t */\n\t\t\tif (get_user(actual_rule_cnt, &rxnfc->rule_cnt))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (actual_rule_cnt < rule_cnt)\n\t\t\t\trule_cnt = actual_rule_cnt;\n\t\t\tif (copy_in_user(&compat_rxnfc->rule_locs[0],\n\t\t\t\t\t &rxnfc->rule_locs[0],\n\t\t\t\t\t rule_cnt * sizeof(u32)))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int compat_siocwandev(struct net *net, struct compat_ifreq __user *uifr32)\n{\n\tcompat_uptr_t uptr32;\n\tstruct ifreq ifr;\n\tvoid __user *saved;\n\tint err;\n\n\tif (copy_from_user(&ifr, uifr32, sizeof(struct compat_ifreq)))\n\t\treturn -EFAULT;\n\n\tif (get_user(uptr32, &uifr32->ifr_settings.ifs_ifsu))\n\t\treturn -EFAULT;\n\n\tsaved = ifr.ifr_settings.ifs_ifsu.raw_hdlc;\n\tifr.ifr_settings.ifs_ifsu.raw_hdlc = compat_ptr(uptr32);\n\n\terr = dev_ioctl(net, SIOCWANDEV, &ifr, NULL);\n\tif (!err) {\n\t\tifr.ifr_settings.ifs_ifsu.raw_hdlc = saved;\n\t\tif (copy_to_user(uifr32, &ifr, sizeof(struct compat_ifreq)))\n\t\t\terr = -EFAULT;\n\t}\n\treturn err;\n}\n\n/* Handle ioctls that use ifreq::ifr_data and just need struct ifreq converted */\nstatic int compat_ifr_data_ioctl(struct net *net, unsigned int cmd,\n\t\t\t\t struct compat_ifreq __user *u_ifreq32)\n{\n\tstruct ifreq ifreq;\n\tu32 data32;\n\n\tif (copy_from_user(ifreq.ifr_name, u_ifreq32->ifr_name, IFNAMSIZ))\n\t\treturn -EFAULT;\n\tif (get_user(data32, &u_ifreq32->ifr_data))\n\t\treturn -EFAULT;\n\tifreq.ifr_data = compat_ptr(data32);\n\n\treturn dev_ioctl(net, cmd, &ifreq, NULL);\n}\n\nstatic int compat_sioc_ifmap(struct net *net, unsigned int cmd,\n\t\t\tstruct compat_ifreq __user *uifr32)\n{\n\tstruct ifreq ifr;\n\tstruct compat_ifmap __user *uifmap32;\n\tint err;\n\n\tuifmap32 = &uifr32->ifr_ifru.ifru_map;\n\terr = copy_from_user(&ifr, uifr32, sizeof(ifr.ifr_name));\n\terr |= get_user(ifr.ifr_map.mem_start, &uifmap32->mem_start);\n\terr |= get_user(ifr.ifr_map.mem_end, &uifmap32->mem_end);\n\terr |= get_user(ifr.ifr_map.base_addr, &uifmap32->base_addr);\n\terr |= get_user(ifr.ifr_map.irq, &uifmap32->irq);\n\terr |= get_user(ifr.ifr_map.dma, &uifmap32->dma);\n\terr |= get_user(ifr.ifr_map.port, &uifmap32->port);\n\tif (err)\n\t\treturn -EFAULT;\n\n\terr = dev_ioctl(net, cmd, &ifr, NULL);\n\n\tif (cmd == SIOCGIFMAP && !err) {\n\t\terr = copy_to_user(uifr32, &ifr, sizeof(ifr.ifr_name));\n\t\terr |= put_user(ifr.ifr_map.mem_start, &uifmap32->mem_start);\n\t\terr |= put_user(ifr.ifr_map.mem_end, &uifmap32->mem_end);\n\t\terr |= put_user(ifr.ifr_map.base_addr, &uifmap32->base_addr);\n\t\terr |= put_user(ifr.ifr_map.irq, &uifmap32->irq);\n\t\terr |= put_user(ifr.ifr_map.dma, &uifmap32->dma);\n\t\terr |= put_user(ifr.ifr_map.port, &uifmap32->port);\n\t\tif (err)\n\t\t\terr = -EFAULT;\n\t}\n\treturn err;\n}\n\nstruct rtentry32 {\n\tu32\t\trt_pad1;\n\tstruct sockaddr rt_dst;         /* target address               */\n\tstruct sockaddr rt_gateway;     /* gateway addr (RTF_GATEWAY)   */\n\tstruct sockaddr rt_genmask;     /* target network mask (IP)     */\n\tunsigned short\trt_flags;\n\tshort\t\trt_pad2;\n\tu32\t\trt_pad3;\n\tunsigned char\trt_tos;\n\tunsigned char\trt_class;\n\tshort\t\trt_pad4;\n\tshort\t\trt_metric;      /* +1 for binary compatibility! */\n\t/* char * */ u32 rt_dev;        /* forcing the device at add    */\n\tu32\t\trt_mtu;         /* per route MTU/Window         */\n\tu32\t\trt_window;      /* Window clamping              */\n\tunsigned short  rt_irtt;        /* Initial RTT                  */\n};\n\nstruct in6_rtmsg32 {\n\tstruct in6_addr\t\trtmsg_dst;\n\tstruct in6_addr\t\trtmsg_src;\n\tstruct in6_addr\t\trtmsg_gateway;\n\tu32\t\t\trtmsg_type;\n\tu16\t\t\trtmsg_dst_len;\n\tu16\t\t\trtmsg_src_len;\n\tu32\t\t\trtmsg_metric;\n\tu32\t\t\trtmsg_info;\n\tu32\t\t\trtmsg_flags;\n\ts32\t\t\trtmsg_ifindex;\n};\n\nstatic int routing_ioctl(struct net *net, struct socket *sock,\n\t\t\t unsigned int cmd, void __user *argp)\n{\n\tint ret;\n\tvoid *r = NULL;\n\tstruct in6_rtmsg r6;\n\tstruct rtentry r4;\n\tchar devname[16];\n\tu32 rtdev;\n\tmm_segment_t old_fs = get_fs();\n\n\tif (sock && sock->sk && sock->sk->sk_family == AF_INET6) { /* ipv6 */\n\t\tstruct in6_rtmsg32 __user *ur6 = argp;\n\t\tret = copy_from_user(&r6.rtmsg_dst, &(ur6->rtmsg_dst),\n\t\t\t3 * sizeof(struct in6_addr));\n\t\tret |= get_user(r6.rtmsg_type, &(ur6->rtmsg_type));\n\t\tret |= get_user(r6.rtmsg_dst_len, &(ur6->rtmsg_dst_len));\n\t\tret |= get_user(r6.rtmsg_src_len, &(ur6->rtmsg_src_len));\n\t\tret |= get_user(r6.rtmsg_metric, &(ur6->rtmsg_metric));\n\t\tret |= get_user(r6.rtmsg_info, &(ur6->rtmsg_info));\n\t\tret |= get_user(r6.rtmsg_flags, &(ur6->rtmsg_flags));\n\t\tret |= get_user(r6.rtmsg_ifindex, &(ur6->rtmsg_ifindex));\n\n\t\tr = (void *) &r6;\n\t} else { /* ipv4 */\n\t\tstruct rtentry32 __user *ur4 = argp;\n\t\tret = copy_from_user(&r4.rt_dst, &(ur4->rt_dst),\n\t\t\t\t\t3 * sizeof(struct sockaddr));\n\t\tret |= get_user(r4.rt_flags, &(ur4->rt_flags));\n\t\tret |= get_user(r4.rt_metric, &(ur4->rt_metric));\n\t\tret |= get_user(r4.rt_mtu, &(ur4->rt_mtu));\n\t\tret |= get_user(r4.rt_window, &(ur4->rt_window));\n\t\tret |= get_user(r4.rt_irtt, &(ur4->rt_irtt));\n\t\tret |= get_user(rtdev, &(ur4->rt_dev));\n\t\tif (rtdev) {\n\t\t\tret |= copy_from_user(devname, compat_ptr(rtdev), 15);\n\t\t\tr4.rt_dev = (char __user __force *)devname;\n\t\t\tdevname[15] = 0;\n\t\t} else\n\t\t\tr4.rt_dev = NULL;\n\n\t\tr = (void *) &r4;\n\t}\n\n\tif (ret) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tset_fs(KERNEL_DS);\n\tret = sock_do_ioctl(net, sock, cmd, (unsigned long) r);\n\tset_fs(old_fs);\n\nout:\n\treturn ret;\n}\n\n/* Since old style bridge ioctl's endup using SIOCDEVPRIVATE\n * for some operations; this forces use of the newer bridge-utils that\n * use compatible ioctls\n */\nstatic int old_bridge_ioctl(compat_ulong_t __user *argp)\n{\n\tcompat_ulong_t tmp;\n\n\tif (get_user(tmp, argp))\n\t\treturn -EFAULT;\n\tif (tmp == BRCTL_GET_VERSION)\n\t\treturn BRCTL_VERSION + 1;\n\treturn -EINVAL;\n}\n\nstatic int compat_sock_ioctl_trans(struct file *file, struct socket *sock,\n\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = compat_ptr(arg);\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\n\tif (cmd >= SIOCDEVPRIVATE && cmd <= (SIOCDEVPRIVATE + 15))\n\t\treturn compat_ifr_data_ioctl(net, cmd, argp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFBR:\n\tcase SIOCGIFBR:\n\t\treturn old_bridge_ioctl(argp);\n\tcase SIOCGIFCONF:\n\t\treturn compat_dev_ifconf(net, argp);\n\tcase SIOCETHTOOL:\n\t\treturn ethtool_ioctl(net, argp);\n\tcase SIOCWANDEV:\n\t\treturn compat_siocwandev(net, argp);\n\tcase SIOCGIFMAP:\n\tcase SIOCSIFMAP:\n\t\treturn compat_sioc_ifmap(net, cmd, argp);\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\t\treturn routing_ioctl(net, sock, cmd, argp);\n\tcase SIOCGSTAMP:\n\t\treturn do_siocgstamp(net, sock, cmd, argp);\n\tcase SIOCGSTAMPNS:\n\t\treturn do_siocgstampns(net, sock, cmd, argp);\n\tcase SIOCBONDSLAVEINFOQUERY:\n\tcase SIOCBONDINFOQUERY:\n\tcase SIOCSHWTSTAMP:\n\tcase SIOCGHWTSTAMP:\n\t\treturn compat_ifr_data_ioctl(net, cmd, argp);\n\n\tcase FIOSETOWN:\n\tcase SIOCSPGRP:\n\tcase FIOGETOWN:\n\tcase SIOCGPGRP:\n\tcase SIOCBRADDBR:\n\tcase SIOCBRDELBR:\n\tcase SIOCGIFVLAN:\n\tcase SIOCSIFVLAN:\n\tcase SIOCADDDLCI:\n\tcase SIOCDELDLCI:\n\tcase SIOCGSKNS:\n\t\treturn sock_ioctl(file, cmd, arg);\n\n\tcase SIOCGIFFLAGS:\n\tcase SIOCSIFFLAGS:\n\tcase SIOCGIFMETRIC:\n\tcase SIOCSIFMETRIC:\n\tcase SIOCGIFMTU:\n\tcase SIOCSIFMTU:\n\tcase SIOCGIFMEM:\n\tcase SIOCSIFMEM:\n\tcase SIOCGIFHWADDR:\n\tcase SIOCSIFHWADDR:\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\tcase SIOCGIFINDEX:\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFADDR:\n\tcase SIOCSIFHWBROADCAST:\n\tcase SIOCDIFADDR:\n\tcase SIOCGIFBRDADDR:\n\tcase SIOCSIFBRDADDR:\n\tcase SIOCGIFDSTADDR:\n\tcase SIOCSIFDSTADDR:\n\tcase SIOCGIFNETMASK:\n\tcase SIOCSIFNETMASK:\n\tcase SIOCSIFPFLAGS:\n\tcase SIOCGIFPFLAGS:\n\tcase SIOCGIFTXQLEN:\n\tcase SIOCSIFTXQLEN:\n\tcase SIOCBRADDIF:\n\tcase SIOCBRDELIF:\n\tcase SIOCSIFNAME:\n\tcase SIOCGMIIPHY:\n\tcase SIOCGMIIREG:\n\tcase SIOCSMIIREG:\n\tcase SIOCSARP:\n\tcase SIOCGARP:\n\tcase SIOCDARP:\n\tcase SIOCATMARK:\n\tcase SIOCBONDENSLAVE:\n\tcase SIOCBONDRELEASE:\n\tcase SIOCBONDSETHWADDR:\n\tcase SIOCBONDCHANGEACTIVE:\n\tcase SIOCGIFNAME:\n\t\treturn sock_do_ioctl(net, sock, cmd, arg);\n\t}\n\n\treturn -ENOIOCTLCMD;\n}\n\nstatic long compat_sock_ioctl(struct file *file, unsigned int cmd,\n\t\t\t      unsigned long arg)\n{\n\tstruct socket *sock = file->private_data;\n\tint ret = -ENOIOCTLCMD;\n\tstruct sock *sk;\n\tstruct net *net;\n\n\tsk = sock->sk;\n\tnet = sock_net(sk);\n\n\tif (sock->ops->compat_ioctl)\n\t\tret = sock->ops->compat_ioctl(sock, cmd, arg);\n\n\tif (ret == -ENOIOCTLCMD &&\n\t    (cmd >= SIOCIWFIRST && cmd <= SIOCIWLAST))\n\t\tret = compat_wext_handle_ioctl(net, cmd, arg);\n\n\tif (ret == -ENOIOCTLCMD)\n\t\tret = compat_sock_ioctl_trans(file, sock, cmd, arg);\n\n\treturn ret;\n}\n#endif\n\nint kernel_bind(struct socket *sock, struct sockaddr *addr, int addrlen)\n{\n\treturn sock->ops->bind(sock, addr, addrlen);\n}\nEXPORT_SYMBOL(kernel_bind);\n\nint kernel_listen(struct socket *sock, int backlog)\n{\n\treturn sock->ops->listen(sock, backlog);\n}\nEXPORT_SYMBOL(kernel_listen);\n\nint kernel_accept(struct socket *sock, struct socket **newsock, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tint err;\n\n\terr = sock_create_lite(sk->sk_family, sk->sk_type, sk->sk_protocol,\n\t\t\t       newsock);\n\tif (err < 0)\n\t\tgoto done;\n\n\terr = sock->ops->accept(sock, *newsock, flags, true);\n\tif (err < 0) {\n\t\tsock_release(*newsock);\n\t\t*newsock = NULL;\n\t\tgoto done;\n\t}\n\n\t(*newsock)->ops = sock->ops;\n\t__module_get((*newsock)->ops->owner);\n\ndone:\n\treturn err;\n}\nEXPORT_SYMBOL(kernel_accept);\n\nint kernel_connect(struct socket *sock, struct sockaddr *addr, int addrlen,\n\t\t   int flags)\n{\n\treturn sock->ops->connect(sock, addr, addrlen, flags);\n}\nEXPORT_SYMBOL(kernel_connect);\n\nint kernel_getsockname(struct socket *sock, struct sockaddr *addr)\n{\n\treturn sock->ops->getname(sock, addr, 0);\n}\nEXPORT_SYMBOL(kernel_getsockname);\n\nint kernel_getpeername(struct socket *sock, struct sockaddr *addr)\n{\n\treturn sock->ops->getname(sock, addr, 1);\n}\nEXPORT_SYMBOL(kernel_getpeername);\n\nint kernel_getsockopt(struct socket *sock, int level, int optname,\n\t\t\tchar *optval, int *optlen)\n{\n\tmm_segment_t oldfs = get_fs();\n\tchar __user *uoptval;\n\tint __user *uoptlen;\n\tint err;\n\n\tuoptval = (char __user __force *) optval;\n\tuoptlen = (int __user __force *) optlen;\n\n\tset_fs(KERNEL_DS);\n\tif (level == SOL_SOCKET)\n\t\terr = sock_getsockopt(sock, level, optname, uoptval, uoptlen);\n\telse\n\t\terr = sock->ops->getsockopt(sock, level, optname, uoptval,\n\t\t\t\t\t    uoptlen);\n\tset_fs(oldfs);\n\treturn err;\n}\nEXPORT_SYMBOL(kernel_getsockopt);\n\nint kernel_setsockopt(struct socket *sock, int level, int optname,\n\t\t\tchar *optval, unsigned int optlen)\n{\n\tmm_segment_t oldfs = get_fs();\n\tchar __user *uoptval;\n\tint err;\n\n\tuoptval = (char __user __force *) optval;\n\n\tset_fs(KERNEL_DS);\n\tif (level == SOL_SOCKET)\n\t\terr = sock_setsockopt(sock, level, optname, uoptval, optlen);\n\telse\n\t\terr = sock->ops->setsockopt(sock, level, optname, uoptval,\n\t\t\t\t\t    optlen);\n\tset_fs(oldfs);\n\treturn err;\n}\nEXPORT_SYMBOL(kernel_setsockopt);\n\nint kernel_sendpage(struct socket *sock, struct page *page, int offset,\n\t\t    size_t size, int flags)\n{\n\tif (sock->ops->sendpage)\n\t\treturn sock->ops->sendpage(sock, page, offset, size, flags);\n\n\treturn sock_no_sendpage(sock, page, offset, size, flags);\n}\nEXPORT_SYMBOL(kernel_sendpage);\n\nint kernel_sendpage_locked(struct sock *sk, struct page *page, int offset,\n\t\t\t   size_t size, int flags)\n{\n\tstruct socket *sock = sk->sk_socket;\n\n\tif (sock->ops->sendpage_locked)\n\t\treturn sock->ops->sendpage_locked(sk, page, offset, size,\n\t\t\t\t\t\t  flags);\n\n\treturn sock_no_sendpage_locked(sk, page, offset, size, flags);\n}\nEXPORT_SYMBOL(kernel_sendpage_locked);\n\nint kernel_sock_shutdown(struct socket *sock, enum sock_shutdown_cmd how)\n{\n\treturn sock->ops->shutdown(sock, how);\n}\nEXPORT_SYMBOL(kernel_sock_shutdown);\n\n/* This routine returns the IP overhead imposed by a socket i.e.\n * the length of the underlying IP header, depending on whether\n * this is an IPv4 or IPv6 socket and the length from IP options turned\n * on at the socket. Assumes that the caller has a lock on the socket.\n */\nu32 kernel_sock_ip_overhead(struct sock *sk)\n{\n\tstruct inet_sock *inet;\n\tstruct ip_options_rcu *opt;\n\tu32 overhead = 0;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct ipv6_pinfo *np;\n\tstruct ipv6_txoptions *optv6 = NULL;\n#endif /* IS_ENABLED(CONFIG_IPV6) */\n\n\tif (!sk)\n\t\treturn overhead;\n\n\tswitch (sk->sk_family) {\n\tcase AF_INET:\n\t\tinet = inet_sk(sk);\n\t\toverhead += sizeof(struct iphdr);\n\t\topt = rcu_dereference_protected(inet->inet_opt,\n\t\t\t\t\t\tsock_owned_by_user(sk));\n\t\tif (opt)\n\t\t\toverhead += opt->opt.optlen;\n\t\treturn overhead;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tnp = inet6_sk(sk);\n\t\toverhead += sizeof(struct ipv6hdr);\n\t\tif (np)\n\t\t\toptv6 = rcu_dereference_protected(np->opt,\n\t\t\t\t\t\t\t  sock_owned_by_user(sk));\n\t\tif (optv6)\n\t\t\toverhead += (optv6->opt_flen + optv6->opt_nflen);\n\t\treturn overhead;\n#endif /* IS_ENABLED(CONFIG_IPV6) */\n\tdefault: /* Returns 0 overhead if the socket is not ipv4 or ipv6 */\n\t\treturn overhead;\n\t}\n}\nEXPORT_SYMBOL(kernel_sock_ip_overhead);\n"], "fixing_code": ["/*\n * NET\t\tAn implementation of the SOCKET network access protocol.\n *\n * Version:\t@(#)socket.c\t1.1.93\t18/02/95\n *\n * Authors:\tOrest Zborowski, <obz@Kodak.COM>\n *\t\tRoss Biro\n *\t\tFred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>\n *\n * Fixes:\n *\t\tAnonymous\t:\tNOTSOCK/BADF cleanup. Error fix in\n *\t\t\t\t\tshutdown()\n *\t\tAlan Cox\t:\tverify_area() fixes\n *\t\tAlan Cox\t:\tRemoved DDI\n *\t\tJonathan Kamens\t:\tSOCK_DGRAM reconnect bug\n *\t\tAlan Cox\t:\tMoved a load of checks to the very\n *\t\t\t\t\ttop level.\n *\t\tAlan Cox\t:\tMove address structures to/from user\n *\t\t\t\t\tmode above the protocol layers.\n *\t\tRob Janssen\t:\tAllow 0 length sends.\n *\t\tAlan Cox\t:\tAsynchronous I/O support (cribbed from the\n *\t\t\t\t\ttty drivers).\n *\t\tNiibe Yutaka\t:\tAsynchronous I/O for writes (4.4BSD style)\n *\t\tJeff Uphoff\t:\tMade max number of sockets command-line\n *\t\t\t\t\tconfigurable.\n *\t\tMatti Aarnio\t:\tMade the number of sockets dynamic,\n *\t\t\t\t\tto be allocated when needed, and mr.\n *\t\t\t\t\tUphoff's max is used as max to be\n *\t\t\t\t\tallowed to allocate.\n *\t\tLinus\t\t:\tArgh. removed all the socket allocation\n *\t\t\t\t\taltogether: it's in the inode now.\n *\t\tAlan Cox\t:\tMade sock_alloc()/sock_release() public\n *\t\t\t\t\tfor NetROM and future kernel nfsd type\n *\t\t\t\t\tstuff.\n *\t\tAlan Cox\t:\tsendmsg/recvmsg basics.\n *\t\tTom Dyas\t:\tExport net symbols.\n *\t\tMarcin Dalecki\t:\tFixed problems with CONFIG_NET=\"n\".\n *\t\tAlan Cox\t:\tAdded thread locking to sys_* calls\n *\t\t\t\t\tfor sockets. May have errors at the\n *\t\t\t\t\tmoment.\n *\t\tKevin Buhr\t:\tFixed the dumb errors in the above.\n *\t\tAndi Kleen\t:\tSome small cleanups, optimizations,\n *\t\t\t\t\tand fixed a copy_from_user() bug.\n *\t\tTigran Aivazian\t:\tsys_send(args) calls sys_sendto(args, NULL, 0)\n *\t\tTigran Aivazian\t:\tMade listen(2) backlog sanity checks\n *\t\t\t\t\tprotocol-independent\n *\n *\n *\t\tThis program is free software; you can redistribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n *\n *\n *\tThis module is effectively the top level interface to the BSD socket\n *\tparadigm.\n *\n *\tBased upon Swansea University Computer Society NET3.039\n */\n\n#include <linux/mm.h>\n#include <linux/socket.h>\n#include <linux/file.h>\n#include <linux/net.h>\n#include <linux/interrupt.h>\n#include <linux/thread_info.h>\n#include <linux/rcupdate.h>\n#include <linux/netdevice.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/if_bridge.h>\n#include <linux/if_frad.h>\n#include <linux/if_vlan.h>\n#include <linux/ptp_classify.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/cache.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/kmod.h>\n#include <linux/audit.h>\n#include <linux/wireless.h>\n#include <linux/nsproxy.h>\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/xattr.h>\n\n#include <linux/uaccess.h>\n#include <asm/unistd.h>\n\n#include <net/compat.h>\n#include <net/wext.h>\n#include <net/cls_cgroup.h>\n\n#include <net/sock.h>\n#include <linux/netfilter.h>\n\n#include <linux/if_tun.h>\n#include <linux/ipv6_route.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <net/busy_poll.h>\n#include <linux/errqueue.h>\n\n#ifdef CONFIG_NET_RX_BUSY_POLL\nunsigned int sysctl_net_busy_read __read_mostly;\nunsigned int sysctl_net_busy_poll __read_mostly;\n#endif\n\nstatic ssize_t sock_read_iter(struct kiocb *iocb, struct iov_iter *to);\nstatic ssize_t sock_write_iter(struct kiocb *iocb, struct iov_iter *from);\nstatic int sock_mmap(struct file *file, struct vm_area_struct *vma);\n\nstatic int sock_close(struct inode *inode, struct file *file);\nstatic struct wait_queue_head *sock_get_poll_head(struct file *file,\n\t\t__poll_t events);\nstatic __poll_t sock_poll_mask(struct file *file, __poll_t);\nstatic __poll_t sock_poll(struct file *file, struct poll_table_struct *wait);\nstatic long sock_ioctl(struct file *file, unsigned int cmd, unsigned long arg);\n#ifdef CONFIG_COMPAT\nstatic long compat_sock_ioctl(struct file *file,\n\t\t\t      unsigned int cmd, unsigned long arg);\n#endif\nstatic int sock_fasync(int fd, struct file *filp, int on);\nstatic ssize_t sock_sendpage(struct file *file, struct page *page,\n\t\t\t     int offset, size_t size, loff_t *ppos, int more);\nstatic ssize_t sock_splice_read(struct file *file, loff_t *ppos,\n\t\t\t\tstruct pipe_inode_info *pipe, size_t len,\n\t\t\t\tunsigned int flags);\n\n/*\n *\tSocket files have a set of 'special' operations as well as the generic file ones. These don't appear\n *\tin the operation structures but are done directly via the socketcall() multiplexor.\n */\n\nstatic const struct file_operations socket_file_ops = {\n\t.owner =\tTHIS_MODULE,\n\t.llseek =\tno_llseek,\n\t.read_iter =\tsock_read_iter,\n\t.write_iter =\tsock_write_iter,\n\t.get_poll_head = sock_get_poll_head,\n\t.poll_mask =\tsock_poll_mask,\n\t.poll =\t\tsock_poll,\n\t.unlocked_ioctl = sock_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = compat_sock_ioctl,\n#endif\n\t.mmap =\t\tsock_mmap,\n\t.release =\tsock_close,\n\t.fasync =\tsock_fasync,\n\t.sendpage =\tsock_sendpage,\n\t.splice_write = generic_splice_sendpage,\n\t.splice_read =\tsock_splice_read,\n};\n\n/*\n *\tThe protocol list. Each protocol is registered in here.\n */\n\nstatic DEFINE_SPINLOCK(net_family_lock);\nstatic const struct net_proto_family __rcu *net_families[NPROTO] __read_mostly;\n\n/*\n * Support routines.\n * Move socket addresses back and forth across the kernel/user\n * divide and look after the messy bits.\n */\n\n/**\n *\tmove_addr_to_kernel\t-\tcopy a socket address into kernel space\n *\t@uaddr: Address in user space\n *\t@kaddr: Address in kernel space\n *\t@ulen: Length in user space\n *\n *\tThe address is copied into kernel space. If the provided address is\n *\ttoo long an error code of -EINVAL is returned. If the copy gives\n *\tinvalid addresses -EFAULT is returned. On a success 0 is returned.\n */\n\nint move_addr_to_kernel(void __user *uaddr, int ulen, struct sockaddr_storage *kaddr)\n{\n\tif (ulen < 0 || ulen > sizeof(struct sockaddr_storage))\n\t\treturn -EINVAL;\n\tif (ulen == 0)\n\t\treturn 0;\n\tif (copy_from_user(kaddr, uaddr, ulen))\n\t\treturn -EFAULT;\n\treturn audit_sockaddr(ulen, kaddr);\n}\n\n/**\n *\tmove_addr_to_user\t-\tcopy an address to user space\n *\t@kaddr: kernel space address\n *\t@klen: length of address in kernel\n *\t@uaddr: user space address\n *\t@ulen: pointer to user length field\n *\n *\tThe value pointed to by ulen on entry is the buffer length available.\n *\tThis is overwritten with the buffer space used. -EINVAL is returned\n *\tif an overlong buffer is specified or a negative buffer size. -EFAULT\n *\tis returned if either the buffer or the length field are not\n *\taccessible.\n *\tAfter copying the data up to the limit the user specifies, the true\n *\tlength of the data is written over the length limit the user\n *\tspecified. Zero is returned for a success.\n */\n\nstatic int move_addr_to_user(struct sockaddr_storage *kaddr, int klen,\n\t\t\t     void __user *uaddr, int __user *ulen)\n{\n\tint err;\n\tint len;\n\n\tBUG_ON(klen > sizeof(struct sockaddr_storage));\n\terr = get_user(len, ulen);\n\tif (err)\n\t\treturn err;\n\tif (len > klen)\n\t\tlen = klen;\n\tif (len < 0)\n\t\treturn -EINVAL;\n\tif (len) {\n\t\tif (audit_sockaddr(klen, kaddr))\n\t\t\treturn -ENOMEM;\n\t\tif (copy_to_user(uaddr, kaddr, len))\n\t\t\treturn -EFAULT;\n\t}\n\t/*\n\t *      \"fromlen shall refer to the value before truncation..\"\n\t *                      1003.1g\n\t */\n\treturn __put_user(klen, ulen);\n}\n\nstatic struct kmem_cache *sock_inode_cachep __ro_after_init;\n\nstatic struct inode *sock_alloc_inode(struct super_block *sb)\n{\n\tstruct socket_alloc *ei;\n\tstruct socket_wq *wq;\n\n\tei = kmem_cache_alloc(sock_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\twq = kmalloc(sizeof(*wq), GFP_KERNEL);\n\tif (!wq) {\n\t\tkmem_cache_free(sock_inode_cachep, ei);\n\t\treturn NULL;\n\t}\n\tinit_waitqueue_head(&wq->wait);\n\twq->fasync_list = NULL;\n\twq->flags = 0;\n\tRCU_INIT_POINTER(ei->socket.wq, wq);\n\n\tei->socket.state = SS_UNCONNECTED;\n\tei->socket.flags = 0;\n\tei->socket.ops = NULL;\n\tei->socket.sk = NULL;\n\tei->socket.file = NULL;\n\n\treturn &ei->vfs_inode;\n}\n\nstatic void sock_destroy_inode(struct inode *inode)\n{\n\tstruct socket_alloc *ei;\n\tstruct socket_wq *wq;\n\n\tei = container_of(inode, struct socket_alloc, vfs_inode);\n\twq = rcu_dereference_protected(ei->socket.wq, 1);\n\tkfree_rcu(wq, rcu);\n\tkmem_cache_free(sock_inode_cachep, ei);\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct socket_alloc *ei = (struct socket_alloc *)foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}\n\nstatic void init_inodecache(void)\n{\n\tsock_inode_cachep = kmem_cache_create(\"sock_inode_cache\",\n\t\t\t\t\t      sizeof(struct socket_alloc),\n\t\t\t\t\t      0,\n\t\t\t\t\t      (SLAB_HWCACHE_ALIGN |\n\t\t\t\t\t       SLAB_RECLAIM_ACCOUNT |\n\t\t\t\t\t       SLAB_MEM_SPREAD | SLAB_ACCOUNT),\n\t\t\t\t\t      init_once);\n\tBUG_ON(sock_inode_cachep == NULL);\n}\n\nstatic const struct super_operations sockfs_ops = {\n\t.alloc_inode\t= sock_alloc_inode,\n\t.destroy_inode\t= sock_destroy_inode,\n\t.statfs\t\t= simple_statfs,\n};\n\n/*\n * sockfs_dname() is called from d_path().\n */\nstatic char *sockfs_dname(struct dentry *dentry, char *buffer, int buflen)\n{\n\treturn dynamic_dname(dentry, buffer, buflen, \"socket:[%lu]\",\n\t\t\t\td_inode(dentry)->i_ino);\n}\n\nstatic const struct dentry_operations sockfs_dentry_operations = {\n\t.d_dname  = sockfs_dname,\n};\n\nstatic int sockfs_xattr_get(const struct xattr_handler *handler,\n\t\t\t    struct dentry *dentry, struct inode *inode,\n\t\t\t    const char *suffix, void *value, size_t size)\n{\n\tif (value) {\n\t\tif (dentry->d_name.len + 1 > size)\n\t\t\treturn -ERANGE;\n\t\tmemcpy(value, dentry->d_name.name, dentry->d_name.len + 1);\n\t}\n\treturn dentry->d_name.len + 1;\n}\n\n#define XATTR_SOCKPROTONAME_SUFFIX \"sockprotoname\"\n#define XATTR_NAME_SOCKPROTONAME (XATTR_SYSTEM_PREFIX XATTR_SOCKPROTONAME_SUFFIX)\n#define XATTR_NAME_SOCKPROTONAME_LEN (sizeof(XATTR_NAME_SOCKPROTONAME)-1)\n\nstatic const struct xattr_handler sockfs_xattr_handler = {\n\t.name = XATTR_NAME_SOCKPROTONAME,\n\t.get = sockfs_xattr_get,\n};\n\nstatic int sockfs_security_xattr_set(const struct xattr_handler *handler,\n\t\t\t\t     struct dentry *dentry, struct inode *inode,\n\t\t\t\t     const char *suffix, const void *value,\n\t\t\t\t     size_t size, int flags)\n{\n\t/* Handled by LSM. */\n\treturn -EAGAIN;\n}\n\nstatic const struct xattr_handler sockfs_security_xattr_handler = {\n\t.prefix = XATTR_SECURITY_PREFIX,\n\t.set = sockfs_security_xattr_set,\n};\n\nstatic const struct xattr_handler *sockfs_xattr_handlers[] = {\n\t&sockfs_xattr_handler,\n\t&sockfs_security_xattr_handler,\n\tNULL\n};\n\nstatic struct dentry *sockfs_mount(struct file_system_type *fs_type,\n\t\t\t int flags, const char *dev_name, void *data)\n{\n\treturn mount_pseudo_xattr(fs_type, \"socket:\", &sockfs_ops,\n\t\t\t\t  sockfs_xattr_handlers,\n\t\t\t\t  &sockfs_dentry_operations, SOCKFS_MAGIC);\n}\n\nstatic struct vfsmount *sock_mnt __read_mostly;\n\nstatic struct file_system_type sock_fs_type = {\n\t.name =\t\t\"sockfs\",\n\t.mount =\tsockfs_mount,\n\t.kill_sb =\tkill_anon_super,\n};\n\n/*\n *\tObtains the first available file descriptor and sets it up for use.\n *\n *\tThese functions create file structures and maps them to fd space\n *\tof the current process. On success it returns file descriptor\n *\tand file struct implicitly stored in sock->file.\n *\tNote that another thread may close file descriptor before we return\n *\tfrom this function. We use the fact that now we do not refer\n *\tto socket after mapping. If one day we will need it, this\n *\tfunction will increment ref. count on file by 1.\n *\n *\tIn any case returned fd MAY BE not valid!\n *\tThis race condition is unavoidable\n *\twith shared fd spaces, we cannot solve it inside kernel,\n *\tbut we take care of internal coherence yet.\n */\n\nstruct file *sock_alloc_file(struct socket *sock, int flags, const char *dname)\n{\n\tstruct qstr name = { .name = \"\" };\n\tstruct path path;\n\tstruct file *file;\n\n\tif (dname) {\n\t\tname.name = dname;\n\t\tname.len = strlen(name.name);\n\t} else if (sock->sk) {\n\t\tname.name = sock->sk->sk_prot_creator->name;\n\t\tname.len = strlen(name.name);\n\t}\n\tpath.dentry = d_alloc_pseudo(sock_mnt->mnt_sb, &name);\n\tif (unlikely(!path.dentry)) {\n\t\tsock_release(sock);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tpath.mnt = mntget(sock_mnt);\n\n\td_instantiate(path.dentry, SOCK_INODE(sock));\n\n\tfile = alloc_file(&path, FMODE_READ | FMODE_WRITE,\n\t\t  &socket_file_ops);\n\tif (IS_ERR(file)) {\n\t\t/* drop dentry, keep inode for a bit */\n\t\tihold(d_inode(path.dentry));\n\t\tpath_put(&path);\n\t\t/* ... and now kill it properly */\n\t\tsock_release(sock);\n\t\treturn file;\n\t}\n\n\tsock->file = file;\n\tfile->f_flags = O_RDWR | (flags & O_NONBLOCK);\n\tfile->private_data = sock;\n\treturn file;\n}\nEXPORT_SYMBOL(sock_alloc_file);\n\nstatic int sock_map_fd(struct socket *sock, int flags)\n{\n\tstruct file *newfile;\n\tint fd = get_unused_fd_flags(flags);\n\tif (unlikely(fd < 0)) {\n\t\tsock_release(sock);\n\t\treturn fd;\n\t}\n\n\tnewfile = sock_alloc_file(sock, flags, NULL);\n\tif (likely(!IS_ERR(newfile))) {\n\t\tfd_install(fd, newfile);\n\t\treturn fd;\n\t}\n\n\tput_unused_fd(fd);\n\treturn PTR_ERR(newfile);\n}\n\nstruct socket *sock_from_file(struct file *file, int *err)\n{\n\tif (file->f_op == &socket_file_ops)\n\t\treturn file->private_data;\t/* set in sock_map_fd */\n\n\t*err = -ENOTSOCK;\n\treturn NULL;\n}\nEXPORT_SYMBOL(sock_from_file);\n\n/**\n *\tsockfd_lookup - Go from a file number to its socket slot\n *\t@fd: file handle\n *\t@err: pointer to an error code return\n *\n *\tThe file handle passed in is locked and the socket it is bound\n *\tto is returned. If an error occurs the err pointer is overwritten\n *\twith a negative errno code and NULL is returned. The function checks\n *\tfor both invalid handles and passing a handle which is not a socket.\n *\n *\tOn a success the socket object pointer is returned.\n */\n\nstruct socket *sockfd_lookup(int fd, int *err)\n{\n\tstruct file *file;\n\tstruct socket *sock;\n\n\tfile = fget(fd);\n\tif (!file) {\n\t\t*err = -EBADF;\n\t\treturn NULL;\n\t}\n\n\tsock = sock_from_file(file, err);\n\tif (!sock)\n\t\tfput(file);\n\treturn sock;\n}\nEXPORT_SYMBOL(sockfd_lookup);\n\nstatic struct socket *sockfd_lookup_light(int fd, int *err, int *fput_needed)\n{\n\tstruct fd f = fdget(fd);\n\tstruct socket *sock;\n\n\t*err = -EBADF;\n\tif (f.file) {\n\t\tsock = sock_from_file(f.file, err);\n\t\tif (likely(sock)) {\n\t\t\t*fput_needed = f.flags;\n\t\t\treturn sock;\n\t\t}\n\t\tfdput(f);\n\t}\n\treturn NULL;\n}\n\nstatic ssize_t sockfs_listxattr(struct dentry *dentry, char *buffer,\n\t\t\t\tsize_t size)\n{\n\tssize_t len;\n\tssize_t used = 0;\n\n\tlen = security_inode_listsecurity(d_inode(dentry), buffer, size);\n\tif (len < 0)\n\t\treturn len;\n\tused += len;\n\tif (buffer) {\n\t\tif (size < used)\n\t\t\treturn -ERANGE;\n\t\tbuffer += len;\n\t}\n\n\tlen = (XATTR_NAME_SOCKPROTONAME_LEN + 1);\n\tused += len;\n\tif (buffer) {\n\t\tif (size < used)\n\t\t\treturn -ERANGE;\n\t\tmemcpy(buffer, XATTR_NAME_SOCKPROTONAME, len);\n\t\tbuffer += len;\n\t}\n\n\treturn used;\n}\n\nstatic int sockfs_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tint err = simple_setattr(dentry, iattr);\n\n\tif (!err && (iattr->ia_valid & ATTR_UID)) {\n\t\tstruct socket *sock = SOCKET_I(d_inode(dentry));\n\n\t\tif (sock->sk)\n\t\t\tsock->sk->sk_uid = iattr->ia_uid;\n\t\telse\n\t\t\terr = -ENOENT;\n\t}\n\n\treturn err;\n}\n\nstatic const struct inode_operations sockfs_inode_ops = {\n\t.listxattr = sockfs_listxattr,\n\t.setattr = sockfs_setattr,\n};\n\n/**\n *\tsock_alloc\t-\tallocate a socket\n *\n *\tAllocate a new inode and socket object. The two are bound together\n *\tand initialised. The socket is then returned. If we are out of inodes\n *\tNULL is returned.\n */\n\nstruct socket *sock_alloc(void)\n{\n\tstruct inode *inode;\n\tstruct socket *sock;\n\n\tinode = new_inode_pseudo(sock_mnt->mnt_sb);\n\tif (!inode)\n\t\treturn NULL;\n\n\tsock = SOCKET_I(inode);\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = S_IFSOCK | S_IRWXUGO;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tinode->i_op = &sockfs_inode_ops;\n\n\treturn sock;\n}\nEXPORT_SYMBOL(sock_alloc);\n\n/**\n *\tsock_release\t-\tclose a socket\n *\t@sock: socket to close\n *\n *\tThe socket is released from the protocol stack if it has a release\n *\tcallback, and the inode is then released if the socket is bound to\n *\tan inode not a file.\n */\n\nstatic void __sock_release(struct socket *sock, struct inode *inode)\n{\n\tif (sock->ops) {\n\t\tstruct module *owner = sock->ops->owner;\n\n\t\tif (inode)\n\t\t\tinode_lock(inode);\n\t\tsock->ops->release(sock);\n\t\tif (inode)\n\t\t\tinode_unlock(inode);\n\t\tsock->ops = NULL;\n\t\tmodule_put(owner);\n\t}\n\n\tif (rcu_dereference_protected(sock->wq, 1)->fasync_list)\n\t\tpr_err(\"%s: fasync list not empty!\\n\", __func__);\n\n\tif (!sock->file) {\n\t\tiput(SOCK_INODE(sock));\n\t\treturn;\n\t}\n\tsock->file = NULL;\n}\n\nvoid sock_release(struct socket *sock)\n{\n\t__sock_release(sock, NULL);\n}\nEXPORT_SYMBOL(sock_release);\n\nvoid __sock_tx_timestamp(__u16 tsflags, __u8 *tx_flags)\n{\n\tu8 flags = *tx_flags;\n\n\tif (tsflags & SOF_TIMESTAMPING_TX_HARDWARE)\n\t\tflags |= SKBTX_HW_TSTAMP;\n\n\tif (tsflags & SOF_TIMESTAMPING_TX_SOFTWARE)\n\t\tflags |= SKBTX_SW_TSTAMP;\n\n\tif (tsflags & SOF_TIMESTAMPING_TX_SCHED)\n\t\tflags |= SKBTX_SCHED_TSTAMP;\n\n\t*tx_flags = flags;\n}\nEXPORT_SYMBOL(__sock_tx_timestamp);\n\nstatic inline int sock_sendmsg_nosec(struct socket *sock, struct msghdr *msg)\n{\n\tint ret = sock->ops->sendmsg(sock, msg, msg_data_left(msg));\n\tBUG_ON(ret == -EIOCBQUEUED);\n\treturn ret;\n}\n\nint sock_sendmsg(struct socket *sock, struct msghdr *msg)\n{\n\tint err = security_socket_sendmsg(sock, msg,\n\t\t\t\t\t  msg_data_left(msg));\n\n\treturn err ?: sock_sendmsg_nosec(sock, msg);\n}\nEXPORT_SYMBOL(sock_sendmsg);\n\nint kernel_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t   struct kvec *vec, size_t num, size_t size)\n{\n\tiov_iter_kvec(&msg->msg_iter, WRITE | ITER_KVEC, vec, num, size);\n\treturn sock_sendmsg(sock, msg);\n}\nEXPORT_SYMBOL(kernel_sendmsg);\n\nint kernel_sendmsg_locked(struct sock *sk, struct msghdr *msg,\n\t\t\t  struct kvec *vec, size_t num, size_t size)\n{\n\tstruct socket *sock = sk->sk_socket;\n\n\tif (!sock->ops->sendmsg_locked)\n\t\treturn sock_no_sendmsg_locked(sk, msg, size);\n\n\tiov_iter_kvec(&msg->msg_iter, WRITE | ITER_KVEC, vec, num, size);\n\n\treturn sock->ops->sendmsg_locked(sk, msg, msg_data_left(msg));\n}\nEXPORT_SYMBOL(kernel_sendmsg_locked);\n\nstatic bool skb_is_err_queue(const struct sk_buff *skb)\n{\n\t/* pkt_type of skbs enqueued on the error queue are set to\n\t * PACKET_OUTGOING in skb_set_err_queue(). This is only safe to do\n\t * in recvmsg, since skbs received on a local socket will never\n\t * have a pkt_type of PACKET_OUTGOING.\n\t */\n\treturn skb->pkt_type == PACKET_OUTGOING;\n}\n\n/* On transmit, software and hardware timestamps are returned independently.\n * As the two skb clones share the hardware timestamp, which may be updated\n * before the software timestamp is received, a hardware TX timestamp may be\n * returned only if there is no software TX timestamp. Ignore false software\n * timestamps, which may be made in the __sock_recv_timestamp() call when the\n * option SO_TIMESTAMP(NS) is enabled on the socket, even when the skb has a\n * hardware timestamp.\n */\nstatic bool skb_is_swtx_tstamp(const struct sk_buff *skb, int false_tstamp)\n{\n\treturn skb->tstamp && !false_tstamp && skb_is_err_queue(skb);\n}\n\nstatic void put_ts_pktinfo(struct msghdr *msg, struct sk_buff *skb)\n{\n\tstruct scm_ts_pktinfo ts_pktinfo;\n\tstruct net_device *orig_dev;\n\n\tif (!skb_mac_header_was_set(skb))\n\t\treturn;\n\n\tmemset(&ts_pktinfo, 0, sizeof(ts_pktinfo));\n\n\trcu_read_lock();\n\torig_dev = dev_get_by_napi_id(skb_napi_id(skb));\n\tif (orig_dev)\n\t\tts_pktinfo.if_index = orig_dev->ifindex;\n\trcu_read_unlock();\n\n\tts_pktinfo.pkt_length = skb->len - skb_mac_offset(skb);\n\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPING_PKTINFO,\n\t\t sizeof(ts_pktinfo), &ts_pktinfo);\n}\n\n/*\n * called from sock_recv_timestamp() if sock_flag(sk, SOCK_RCVTSTAMP)\n */\nvoid __sock_recv_timestamp(struct msghdr *msg, struct sock *sk,\n\tstruct sk_buff *skb)\n{\n\tint need_software_tstamp = sock_flag(sk, SOCK_RCVTSTAMP);\n\tstruct scm_timestamping tss;\n\tint empty = 1, false_tstamp = 0;\n\tstruct skb_shared_hwtstamps *shhwtstamps =\n\t\tskb_hwtstamps(skb);\n\n\t/* Race occurred between timestamp enabling and packet\n\t   receiving.  Fill in the current time for now. */\n\tif (need_software_tstamp && skb->tstamp == 0) {\n\t\t__net_timestamp(skb);\n\t\tfalse_tstamp = 1;\n\t}\n\n\tif (need_software_tstamp) {\n\t\tif (!sock_flag(sk, SOCK_RCVTSTAMPNS)) {\n\t\t\tstruct timeval tv;\n\t\t\tskb_get_timestamp(skb, &tv);\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMP,\n\t\t\t\t sizeof(tv), &tv);\n\t\t} else {\n\t\t\tstruct timespec ts;\n\t\t\tskb_get_timestampns(skb, &ts);\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPNS,\n\t\t\t\t sizeof(ts), &ts);\n\t\t}\n\t}\n\n\tmemset(&tss, 0, sizeof(tss));\n\tif ((sk->sk_tsflags & SOF_TIMESTAMPING_SOFTWARE) &&\n\t    ktime_to_timespec_cond(skb->tstamp, tss.ts + 0))\n\t\tempty = 0;\n\tif (shhwtstamps &&\n\t    (sk->sk_tsflags & SOF_TIMESTAMPING_RAW_HARDWARE) &&\n\t    !skb_is_swtx_tstamp(skb, false_tstamp) &&\n\t    ktime_to_timespec_cond(shhwtstamps->hwtstamp, tss.ts + 2)) {\n\t\tempty = 0;\n\t\tif ((sk->sk_tsflags & SOF_TIMESTAMPING_OPT_PKTINFO) &&\n\t\t    !skb_is_err_queue(skb))\n\t\t\tput_ts_pktinfo(msg, skb);\n\t}\n\tif (!empty) {\n\t\tput_cmsg(msg, SOL_SOCKET,\n\t\t\t SCM_TIMESTAMPING, sizeof(tss), &tss);\n\n\t\tif (skb_is_err_queue(skb) && skb->len &&\n\t\t    SKB_EXT_ERR(skb)->opt_stats)\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPING_OPT_STATS,\n\t\t\t\t skb->len, skb->data);\n\t}\n}\nEXPORT_SYMBOL_GPL(__sock_recv_timestamp);\n\nvoid __sock_recv_wifi_status(struct msghdr *msg, struct sock *sk,\n\tstruct sk_buff *skb)\n{\n\tint ack;\n\n\tif (!sock_flag(sk, SOCK_WIFI_STATUS))\n\t\treturn;\n\tif (!skb->wifi_acked_valid)\n\t\treturn;\n\n\tack = skb->wifi_acked;\n\n\tput_cmsg(msg, SOL_SOCKET, SCM_WIFI_STATUS, sizeof(ack), &ack);\n}\nEXPORT_SYMBOL_GPL(__sock_recv_wifi_status);\n\nstatic inline void sock_recv_drops(struct msghdr *msg, struct sock *sk,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tif (sock_flag(sk, SOCK_RXQ_OVFL) && skb && SOCK_SKB_CB(skb)->dropcount)\n\t\tput_cmsg(msg, SOL_SOCKET, SO_RXQ_OVFL,\n\t\t\tsizeof(__u32), &SOCK_SKB_CB(skb)->dropcount);\n}\n\nvoid __sock_recv_ts_and_drops(struct msghdr *msg, struct sock *sk,\n\tstruct sk_buff *skb)\n{\n\tsock_recv_timestamp(msg, sk, skb);\n\tsock_recv_drops(msg, sk, skb);\n}\nEXPORT_SYMBOL_GPL(__sock_recv_ts_and_drops);\n\nstatic inline int sock_recvmsg_nosec(struct socket *sock, struct msghdr *msg,\n\t\t\t\t     int flags)\n{\n\treturn sock->ops->recvmsg(sock, msg, msg_data_left(msg), flags);\n}\n\nint sock_recvmsg(struct socket *sock, struct msghdr *msg, int flags)\n{\n\tint err = security_socket_recvmsg(sock, msg, msg_data_left(msg), flags);\n\n\treturn err ?: sock_recvmsg_nosec(sock, msg, flags);\n}\nEXPORT_SYMBOL(sock_recvmsg);\n\n/**\n * kernel_recvmsg - Receive a message from a socket (kernel space)\n * @sock:       The socket to receive the message from\n * @msg:        Received message\n * @vec:        Input s/g array for message data\n * @num:        Size of input s/g array\n * @size:       Number of bytes to read\n * @flags:      Message flags (MSG_DONTWAIT, etc...)\n *\n * On return the msg structure contains the scatter/gather array passed in the\n * vec argument. The array is modified so that it consists of the unfilled\n * portion of the original array.\n *\n * The returned value is the total number of bytes received, or an error.\n */\nint kernel_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t   struct kvec *vec, size_t num, size_t size, int flags)\n{\n\tmm_segment_t oldfs = get_fs();\n\tint result;\n\n\tiov_iter_kvec(&msg->msg_iter, READ | ITER_KVEC, vec, num, size);\n\tset_fs(KERNEL_DS);\n\tresult = sock_recvmsg(sock, msg, flags);\n\tset_fs(oldfs);\n\treturn result;\n}\nEXPORT_SYMBOL(kernel_recvmsg);\n\nstatic ssize_t sock_sendpage(struct file *file, struct page *page,\n\t\t\t     int offset, size_t size, loff_t *ppos, int more)\n{\n\tstruct socket *sock;\n\tint flags;\n\n\tsock = file->private_data;\n\n\tflags = (file->f_flags & O_NONBLOCK) ? MSG_DONTWAIT : 0;\n\t/* more is a combination of MSG_MORE and MSG_SENDPAGE_NOTLAST */\n\tflags |= more;\n\n\treturn kernel_sendpage(sock, page, offset, size, flags);\n}\n\nstatic ssize_t sock_splice_read(struct file *file, loff_t *ppos,\n\t\t\t\tstruct pipe_inode_info *pipe, size_t len,\n\t\t\t\tunsigned int flags)\n{\n\tstruct socket *sock = file->private_data;\n\n\tif (unlikely(!sock->ops->splice_read))\n\t\treturn -EINVAL;\n\n\treturn sock->ops->splice_read(sock, ppos, pipe, len, flags);\n}\n\nstatic ssize_t sock_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct socket *sock = file->private_data;\n\tstruct msghdr msg = {.msg_iter = *to,\n\t\t\t     .msg_iocb = iocb};\n\tssize_t res;\n\n\tif (file->f_flags & O_NONBLOCK)\n\t\tmsg.msg_flags = MSG_DONTWAIT;\n\n\tif (iocb->ki_pos != 0)\n\t\treturn -ESPIPE;\n\n\tif (!iov_iter_count(to))\t/* Match SYS5 behaviour */\n\t\treturn 0;\n\n\tres = sock_recvmsg(sock, &msg, msg.msg_flags);\n\t*to = msg.msg_iter;\n\treturn res;\n}\n\nstatic ssize_t sock_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct socket *sock = file->private_data;\n\tstruct msghdr msg = {.msg_iter = *from,\n\t\t\t     .msg_iocb = iocb};\n\tssize_t res;\n\n\tif (iocb->ki_pos != 0)\n\t\treturn -ESPIPE;\n\n\tif (file->f_flags & O_NONBLOCK)\n\t\tmsg.msg_flags = MSG_DONTWAIT;\n\n\tif (sock->type == SOCK_SEQPACKET)\n\t\tmsg.msg_flags |= MSG_EOR;\n\n\tres = sock_sendmsg(sock, &msg);\n\t*from = msg.msg_iter;\n\treturn res;\n}\n\n/*\n * Atomic setting of ioctl hooks to avoid race\n * with module unload.\n */\n\nstatic DEFINE_MUTEX(br_ioctl_mutex);\nstatic int (*br_ioctl_hook) (struct net *, unsigned int cmd, void __user *arg);\n\nvoid brioctl_set(int (*hook) (struct net *, unsigned int, void __user *))\n{\n\tmutex_lock(&br_ioctl_mutex);\n\tbr_ioctl_hook = hook;\n\tmutex_unlock(&br_ioctl_mutex);\n}\nEXPORT_SYMBOL(brioctl_set);\n\nstatic DEFINE_MUTEX(vlan_ioctl_mutex);\nstatic int (*vlan_ioctl_hook) (struct net *, void __user *arg);\n\nvoid vlan_ioctl_set(int (*hook) (struct net *, void __user *))\n{\n\tmutex_lock(&vlan_ioctl_mutex);\n\tvlan_ioctl_hook = hook;\n\tmutex_unlock(&vlan_ioctl_mutex);\n}\nEXPORT_SYMBOL(vlan_ioctl_set);\n\nstatic DEFINE_MUTEX(dlci_ioctl_mutex);\nstatic int (*dlci_ioctl_hook) (unsigned int, void __user *);\n\nvoid dlci_ioctl_set(int (*hook) (unsigned int, void __user *))\n{\n\tmutex_lock(&dlci_ioctl_mutex);\n\tdlci_ioctl_hook = hook;\n\tmutex_unlock(&dlci_ioctl_mutex);\n}\nEXPORT_SYMBOL(dlci_ioctl_set);\n\nstatic long sock_do_ioctl(struct net *net, struct socket *sock,\n\t\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tint err;\n\tvoid __user *argp = (void __user *)arg;\n\n\terr = sock->ops->ioctl(sock, cmd, arg);\n\n\t/*\n\t * If this ioctl is unknown try to hand it down\n\t * to the NIC driver.\n\t */\n\tif (err != -ENOIOCTLCMD)\n\t\treturn err;\n\n\tif (cmd == SIOCGIFCONF) {\n\t\tstruct ifconf ifc;\n\t\tif (copy_from_user(&ifc, argp, sizeof(struct ifconf)))\n\t\t\treturn -EFAULT;\n\t\trtnl_lock();\n\t\terr = dev_ifconf(net, &ifc, sizeof(struct ifreq));\n\t\trtnl_unlock();\n\t\tif (!err && copy_to_user(argp, &ifc, sizeof(struct ifconf)))\n\t\t\terr = -EFAULT;\n\t} else {\n\t\tstruct ifreq ifr;\n\t\tbool need_copyout;\n\t\tif (copy_from_user(&ifr, argp, sizeof(struct ifreq)))\n\t\t\treturn -EFAULT;\n\t\terr = dev_ioctl(net, cmd, &ifr, &need_copyout);\n\t\tif (!err && need_copyout)\n\t\t\tif (copy_to_user(argp, &ifr, sizeof(struct ifreq)))\n\t\t\t\treturn -EFAULT;\n\t}\n\treturn err;\n}\n\n/*\n *\tWith an ioctl, arg may well be a user mode pointer, but we don't know\n *\twhat to do with it - that's up to the protocol still.\n */\n\nstruct ns_common *get_net_ns(struct ns_common *ns)\n{\n\treturn &get_net(container_of(ns, struct net, ns))->ns;\n}\nEXPORT_SYMBOL_GPL(get_net_ns);\n\nstatic long sock_ioctl(struct file *file, unsigned cmd, unsigned long arg)\n{\n\tstruct socket *sock;\n\tstruct sock *sk;\n\tvoid __user *argp = (void __user *)arg;\n\tint pid, err;\n\tstruct net *net;\n\n\tsock = file->private_data;\n\tsk = sock->sk;\n\tnet = sock_net(sk);\n\tif (unlikely(cmd >= SIOCDEVPRIVATE && cmd <= (SIOCDEVPRIVATE + 15))) {\n\t\tstruct ifreq ifr;\n\t\tbool need_copyout;\n\t\tif (copy_from_user(&ifr, argp, sizeof(struct ifreq)))\n\t\t\treturn -EFAULT;\n\t\terr = dev_ioctl(net, cmd, &ifr, &need_copyout);\n\t\tif (!err && need_copyout)\n\t\t\tif (copy_to_user(argp, &ifr, sizeof(struct ifreq)))\n\t\t\t\treturn -EFAULT;\n\t} else\n#ifdef CONFIG_WEXT_CORE\n\tif (cmd >= SIOCIWFIRST && cmd <= SIOCIWLAST) {\n\t\terr = wext_handle_ioctl(net, cmd, argp);\n\t} else\n#endif\n\t\tswitch (cmd) {\n\t\tcase FIOSETOWN:\n\t\tcase SIOCSPGRP:\n\t\t\terr = -EFAULT;\n\t\t\tif (get_user(pid, (int __user *)argp))\n\t\t\t\tbreak;\n\t\t\terr = f_setown(sock->file, pid, 1);\n\t\t\tbreak;\n\t\tcase FIOGETOWN:\n\t\tcase SIOCGPGRP:\n\t\t\terr = put_user(f_getown(sock->file),\n\t\t\t\t       (int __user *)argp);\n\t\t\tbreak;\n\t\tcase SIOCGIFBR:\n\t\tcase SIOCSIFBR:\n\t\tcase SIOCBRADDBR:\n\t\tcase SIOCBRDELBR:\n\t\t\terr = -ENOPKG;\n\t\t\tif (!br_ioctl_hook)\n\t\t\t\trequest_module(\"bridge\");\n\n\t\t\tmutex_lock(&br_ioctl_mutex);\n\t\t\tif (br_ioctl_hook)\n\t\t\t\terr = br_ioctl_hook(net, cmd, argp);\n\t\t\tmutex_unlock(&br_ioctl_mutex);\n\t\t\tbreak;\n\t\tcase SIOCGIFVLAN:\n\t\tcase SIOCSIFVLAN:\n\t\t\terr = -ENOPKG;\n\t\t\tif (!vlan_ioctl_hook)\n\t\t\t\trequest_module(\"8021q\");\n\n\t\t\tmutex_lock(&vlan_ioctl_mutex);\n\t\t\tif (vlan_ioctl_hook)\n\t\t\t\terr = vlan_ioctl_hook(net, argp);\n\t\t\tmutex_unlock(&vlan_ioctl_mutex);\n\t\t\tbreak;\n\t\tcase SIOCADDDLCI:\n\t\tcase SIOCDELDLCI:\n\t\t\terr = -ENOPKG;\n\t\t\tif (!dlci_ioctl_hook)\n\t\t\t\trequest_module(\"dlci\");\n\n\t\t\tmutex_lock(&dlci_ioctl_mutex);\n\t\t\tif (dlci_ioctl_hook)\n\t\t\t\terr = dlci_ioctl_hook(cmd, argp);\n\t\t\tmutex_unlock(&dlci_ioctl_mutex);\n\t\t\tbreak;\n\t\tcase SIOCGSKNS:\n\t\t\terr = -EPERM;\n\t\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\t\tbreak;\n\n\t\t\terr = open_related_ns(&net->ns, get_net_ns);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = sock_do_ioctl(net, sock, cmd, arg);\n\t\t\tbreak;\n\t\t}\n\treturn err;\n}\n\nint sock_create_lite(int family, int type, int protocol, struct socket **res)\n{\n\tint err;\n\tstruct socket *sock = NULL;\n\n\terr = security_socket_create(family, type, protocol, 1);\n\tif (err)\n\t\tgoto out;\n\n\tsock = sock_alloc();\n\tif (!sock) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsock->type = type;\n\terr = security_socket_post_create(sock, family, type, protocol, 1);\n\tif (err)\n\t\tgoto out_release;\n\nout:\n\t*res = sock;\n\treturn err;\nout_release:\n\tsock_release(sock);\n\tsock = NULL;\n\tgoto out;\n}\nEXPORT_SYMBOL(sock_create_lite);\n\nstatic struct wait_queue_head *sock_get_poll_head(struct file *file,\n\t\t__poll_t events)\n{\n\tstruct socket *sock = file->private_data;\n\n\tif (!sock->ops->poll_mask)\n\t\treturn NULL;\n\tsock_poll_busy_loop(sock, events);\n\treturn sk_sleep(sock->sk);\n}\n\nstatic __poll_t sock_poll_mask(struct file *file, __poll_t events)\n{\n\tstruct socket *sock = file->private_data;\n\n\t/*\n\t * We need to be sure we are in sync with the socket flags modification.\n\t *\n\t * This memory barrier is paired in the wq_has_sleeper.\n\t */\n\tsmp_mb();\n\n\t/* this socket can poll_ll so tell the system call */\n\treturn sock->ops->poll_mask(sock, events) |\n\t\t(sk_can_busy_loop(sock->sk) ? POLL_BUSY_LOOP : 0);\n}\n\n/* No kernel lock held - perfect */\nstatic __poll_t sock_poll(struct file *file, poll_table *wait)\n{\n\tstruct socket *sock = file->private_data;\n\t__poll_t events = poll_requested_events(wait), mask = 0;\n\n\tif (sock->ops->poll) {\n\t\tsock_poll_busy_loop(sock, events);\n\t\tmask = sock->ops->poll(file, sock, wait);\n\t} else if (sock->ops->poll_mask) {\n\t\tsock_poll_wait(file, sock_get_poll_head(file, events), wait);\n\t\tmask = sock->ops->poll_mask(sock, events);\n\t}\n\n\treturn mask | sock_poll_busy_flag(sock);\n}\n\nstatic int sock_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct socket *sock = file->private_data;\n\n\treturn sock->ops->mmap(file, sock, vma);\n}\n\nstatic int sock_close(struct inode *inode, struct file *filp)\n{\n\t__sock_release(SOCKET_I(inode), inode);\n\treturn 0;\n}\n\n/*\n *\tUpdate the socket async list\n *\n *\tFasync_list locking strategy.\n *\n *\t1. fasync_list is modified only under process context socket lock\n *\t   i.e. under semaphore.\n *\t2. fasync_list is used under read_lock(&sk->sk_callback_lock)\n *\t   or under socket lock\n */\n\nstatic int sock_fasync(int fd, struct file *filp, int on)\n{\n\tstruct socket *sock = filp->private_data;\n\tstruct sock *sk = sock->sk;\n\tstruct socket_wq *wq;\n\n\tif (sk == NULL)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\twq = rcu_dereference_protected(sock->wq, lockdep_sock_is_held(sk));\n\tfasync_helper(fd, filp, on, &wq->fasync_list);\n\n\tif (!wq->fasync_list)\n\t\tsock_reset_flag(sk, SOCK_FASYNC);\n\telse\n\t\tsock_set_flag(sk, SOCK_FASYNC);\n\n\trelease_sock(sk);\n\treturn 0;\n}\n\n/* This function may be called only under rcu_lock */\n\nint sock_wake_async(struct socket_wq *wq, int how, int band)\n{\n\tif (!wq || !wq->fasync_list)\n\t\treturn -1;\n\n\tswitch (how) {\n\tcase SOCK_WAKE_WAITD:\n\t\tif (test_bit(SOCKWQ_ASYNC_WAITDATA, &wq->flags))\n\t\t\tbreak;\n\t\tgoto call_kill;\n\tcase SOCK_WAKE_SPACE:\n\t\tif (!test_and_clear_bit(SOCKWQ_ASYNC_NOSPACE, &wq->flags))\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase SOCK_WAKE_IO:\ncall_kill:\n\t\tkill_fasync(&wq->fasync_list, SIGIO, band);\n\t\tbreak;\n\tcase SOCK_WAKE_URG:\n\t\tkill_fasync(&wq->fasync_list, SIGURG, band);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(sock_wake_async);\n\nint __sock_create(struct net *net, int family, int type, int protocol,\n\t\t\t struct socket **res, int kern)\n{\n\tint err;\n\tstruct socket *sock;\n\tconst struct net_proto_family *pf;\n\n\t/*\n\t *      Check protocol is in range\n\t */\n\tif (family < 0 || family >= NPROTO)\n\t\treturn -EAFNOSUPPORT;\n\tif (type < 0 || type >= SOCK_MAX)\n\t\treturn -EINVAL;\n\n\t/* Compatibility.\n\n\t   This uglymoron is moved from INET layer to here to avoid\n\t   deadlock in module load.\n\t */\n\tif (family == PF_INET && type == SOCK_PACKET) {\n\t\tpr_info_once(\"%s uses obsolete (PF_INET,SOCK_PACKET)\\n\",\n\t\t\t     current->comm);\n\t\tfamily = PF_PACKET;\n\t}\n\n\terr = security_socket_create(family, type, protocol, kern);\n\tif (err)\n\t\treturn err;\n\n\t/*\n\t *\tAllocate the socket and allow the family to set things up. if\n\t *\tthe protocol is 0, the family is instructed to select an appropriate\n\t *\tdefault.\n\t */\n\tsock = sock_alloc();\n\tif (!sock) {\n\t\tnet_warn_ratelimited(\"socket: no more sockets\\n\");\n\t\treturn -ENFILE;\t/* Not exactly a match, but its the\n\t\t\t\t   closest posix thing */\n\t}\n\n\tsock->type = type;\n\n#ifdef CONFIG_MODULES\n\t/* Attempt to load a protocol module if the find failed.\n\t *\n\t * 12/09/1996 Marcin: But! this makes REALLY only sense, if the user\n\t * requested real, full-featured networking support upon configuration.\n\t * Otherwise module support will break!\n\t */\n\tif (rcu_access_pointer(net_families[family]) == NULL)\n\t\trequest_module(\"net-pf-%d\", family);\n#endif\n\n\trcu_read_lock();\n\tpf = rcu_dereference(net_families[family]);\n\terr = -EAFNOSUPPORT;\n\tif (!pf)\n\t\tgoto out_release;\n\n\t/*\n\t * We will call the ->create function, that possibly is in a loadable\n\t * module, so we have to bump that loadable module refcnt first.\n\t */\n\tif (!try_module_get(pf->owner))\n\t\tgoto out_release;\n\n\t/* Now protected by module ref count */\n\trcu_read_unlock();\n\n\terr = pf->create(net, sock, protocol, kern);\n\tif (err < 0)\n\t\tgoto out_module_put;\n\n\t/*\n\t * Now to bump the refcnt of the [loadable] module that owns this\n\t * socket at sock_release time we decrement its refcnt.\n\t */\n\tif (!try_module_get(sock->ops->owner))\n\t\tgoto out_module_busy;\n\n\t/*\n\t * Now that we're done with the ->create function, the [loadable]\n\t * module can have its refcnt decremented\n\t */\n\tmodule_put(pf->owner);\n\terr = security_socket_post_create(sock, family, type, protocol, kern);\n\tif (err)\n\t\tgoto out_sock_release;\n\t*res = sock;\n\n\treturn 0;\n\nout_module_busy:\n\terr = -EAFNOSUPPORT;\nout_module_put:\n\tsock->ops = NULL;\n\tmodule_put(pf->owner);\nout_sock_release:\n\tsock_release(sock);\n\treturn err;\n\nout_release:\n\trcu_read_unlock();\n\tgoto out_sock_release;\n}\nEXPORT_SYMBOL(__sock_create);\n\nint sock_create(int family, int type, int protocol, struct socket **res)\n{\n\treturn __sock_create(current->nsproxy->net_ns, family, type, protocol, res, 0);\n}\nEXPORT_SYMBOL(sock_create);\n\nint sock_create_kern(struct net *net, int family, int type, int protocol, struct socket **res)\n{\n\treturn __sock_create(net, family, type, protocol, res, 1);\n}\nEXPORT_SYMBOL(sock_create_kern);\n\nint __sys_socket(int family, int type, int protocol)\n{\n\tint retval;\n\tstruct socket *sock;\n\tint flags;\n\n\t/* Check the SOCK_* constants for consistency.  */\n\tBUILD_BUG_ON(SOCK_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON((SOCK_MAX | SOCK_TYPE_MASK) != SOCK_TYPE_MASK);\n\tBUILD_BUG_ON(SOCK_CLOEXEC & SOCK_TYPE_MASK);\n\tBUILD_BUG_ON(SOCK_NONBLOCK & SOCK_TYPE_MASK);\n\n\tflags = type & ~SOCK_TYPE_MASK;\n\tif (flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))\n\t\treturn -EINVAL;\n\ttype &= SOCK_TYPE_MASK;\n\n\tif (SOCK_NONBLOCK != O_NONBLOCK && (flags & SOCK_NONBLOCK))\n\t\tflags = (flags & ~SOCK_NONBLOCK) | O_NONBLOCK;\n\n\tretval = sock_create(family, type, protocol, &sock);\n\tif (retval < 0)\n\t\treturn retval;\n\n\treturn sock_map_fd(sock, flags & (O_CLOEXEC | O_NONBLOCK));\n}\n\nSYSCALL_DEFINE3(socket, int, family, int, type, int, protocol)\n{\n\treturn __sys_socket(family, type, protocol);\n}\n\n/*\n *\tCreate a pair of connected sockets.\n */\n\nint __sys_socketpair(int family, int type, int protocol, int __user *usockvec)\n{\n\tstruct socket *sock1, *sock2;\n\tint fd1, fd2, err;\n\tstruct file *newfile1, *newfile2;\n\tint flags;\n\n\tflags = type & ~SOCK_TYPE_MASK;\n\tif (flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))\n\t\treturn -EINVAL;\n\ttype &= SOCK_TYPE_MASK;\n\n\tif (SOCK_NONBLOCK != O_NONBLOCK && (flags & SOCK_NONBLOCK))\n\t\tflags = (flags & ~SOCK_NONBLOCK) | O_NONBLOCK;\n\n\t/*\n\t * reserve descriptors and make sure we won't fail\n\t * to return them to userland.\n\t */\n\tfd1 = get_unused_fd_flags(flags);\n\tif (unlikely(fd1 < 0))\n\t\treturn fd1;\n\n\tfd2 = get_unused_fd_flags(flags);\n\tif (unlikely(fd2 < 0)) {\n\t\tput_unused_fd(fd1);\n\t\treturn fd2;\n\t}\n\n\terr = put_user(fd1, &usockvec[0]);\n\tif (err)\n\t\tgoto out;\n\n\terr = put_user(fd2, &usockvec[1]);\n\tif (err)\n\t\tgoto out;\n\n\t/*\n\t * Obtain the first socket and check if the underlying protocol\n\t * supports the socketpair call.\n\t */\n\n\terr = sock_create(family, type, protocol, &sock1);\n\tif (unlikely(err < 0))\n\t\tgoto out;\n\n\terr = sock_create(family, type, protocol, &sock2);\n\tif (unlikely(err < 0)) {\n\t\tsock_release(sock1);\n\t\tgoto out;\n\t}\n\n\terr = security_socket_socketpair(sock1, sock2);\n\tif (unlikely(err)) {\n\t\tsock_release(sock2);\n\t\tsock_release(sock1);\n\t\tgoto out;\n\t}\n\n\terr = sock1->ops->socketpair(sock1, sock2);\n\tif (unlikely(err < 0)) {\n\t\tsock_release(sock2);\n\t\tsock_release(sock1);\n\t\tgoto out;\n\t}\n\n\tnewfile1 = sock_alloc_file(sock1, flags, NULL);\n\tif (IS_ERR(newfile1)) {\n\t\terr = PTR_ERR(newfile1);\n\t\tsock_release(sock2);\n\t\tgoto out;\n\t}\n\n\tnewfile2 = sock_alloc_file(sock2, flags, NULL);\n\tif (IS_ERR(newfile2)) {\n\t\terr = PTR_ERR(newfile2);\n\t\tfput(newfile1);\n\t\tgoto out;\n\t}\n\n\taudit_fd_pair(fd1, fd2);\n\n\tfd_install(fd1, newfile1);\n\tfd_install(fd2, newfile2);\n\treturn 0;\n\nout:\n\tput_unused_fd(fd2);\n\tput_unused_fd(fd1);\n\treturn err;\n}\n\nSYSCALL_DEFINE4(socketpair, int, family, int, type, int, protocol,\n\t\tint __user *, usockvec)\n{\n\treturn __sys_socketpair(family, type, protocol, usockvec);\n}\n\n/*\n *\tBind a name to a socket. Nothing much to do here since it's\n *\tthe protocol's responsibility to handle the local address.\n *\n *\tWe move the socket address to kernel space before we call\n *\tthe protocol layer (having also checked the address is ok).\n */\n\nint __sys_bind(int fd, struct sockaddr __user *umyaddr, int addrlen)\n{\n\tstruct socket *sock;\n\tstruct sockaddr_storage address;\n\tint err, fput_needed;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (sock) {\n\t\terr = move_addr_to_kernel(umyaddr, addrlen, &address);\n\t\tif (err >= 0) {\n\t\t\terr = security_socket_bind(sock,\n\t\t\t\t\t\t   (struct sockaddr *)&address,\n\t\t\t\t\t\t   addrlen);\n\t\t\tif (!err)\n\t\t\t\terr = sock->ops->bind(sock,\n\t\t\t\t\t\t      (struct sockaddr *)\n\t\t\t\t\t\t      &address, addrlen);\n\t\t}\n\t\tfput_light(sock->file, fput_needed);\n\t}\n\treturn err;\n}\n\nSYSCALL_DEFINE3(bind, int, fd, struct sockaddr __user *, umyaddr, int, addrlen)\n{\n\treturn __sys_bind(fd, umyaddr, addrlen);\n}\n\n/*\n *\tPerform a listen. Basically, we allow the protocol to do anything\n *\tnecessary for a listen, and if that works, we mark the socket as\n *\tready for listening.\n */\n\nint __sys_listen(int fd, int backlog)\n{\n\tstruct socket *sock;\n\tint err, fput_needed;\n\tint somaxconn;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (sock) {\n\t\tsomaxconn = sock_net(sock->sk)->core.sysctl_somaxconn;\n\t\tif ((unsigned int)backlog > somaxconn)\n\t\t\tbacklog = somaxconn;\n\n\t\terr = security_socket_listen(sock, backlog);\n\t\tif (!err)\n\t\t\terr = sock->ops->listen(sock, backlog);\n\n\t\tfput_light(sock->file, fput_needed);\n\t}\n\treturn err;\n}\n\nSYSCALL_DEFINE2(listen, int, fd, int, backlog)\n{\n\treturn __sys_listen(fd, backlog);\n}\n\n/*\n *\tFor accept, we attempt to create a new socket, set up the link\n *\twith the client, wake up the client, then return the new\n *\tconnected fd. We collect the address of the connector in kernel\n *\tspace and move it to user at the very end. This is unclean because\n *\twe open the socket then return an error.\n *\n *\t1003.1g adds the ability to recvmsg() to query connection pending\n *\tstatus to recvmsg. We need to add that support in a way thats\n *\tclean when we restructure accept also.\n */\n\nint __sys_accept4(int fd, struct sockaddr __user *upeer_sockaddr,\n\t\t  int __user *upeer_addrlen, int flags)\n{\n\tstruct socket *sock, *newsock;\n\tstruct file *newfile;\n\tint err, len, newfd, fput_needed;\n\tstruct sockaddr_storage address;\n\n\tif (flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))\n\t\treturn -EINVAL;\n\n\tif (SOCK_NONBLOCK != O_NONBLOCK && (flags & SOCK_NONBLOCK))\n\t\tflags = (flags & ~SOCK_NONBLOCK) | O_NONBLOCK;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\n\terr = -ENFILE;\n\tnewsock = sock_alloc();\n\tif (!newsock)\n\t\tgoto out_put;\n\n\tnewsock->type = sock->type;\n\tnewsock->ops = sock->ops;\n\n\t/*\n\t * We don't need try_module_get here, as the listening socket (sock)\n\t * has the protocol module (sock->ops->owner) held.\n\t */\n\t__module_get(newsock->ops->owner);\n\n\tnewfd = get_unused_fd_flags(flags);\n\tif (unlikely(newfd < 0)) {\n\t\terr = newfd;\n\t\tsock_release(newsock);\n\t\tgoto out_put;\n\t}\n\tnewfile = sock_alloc_file(newsock, flags, sock->sk->sk_prot_creator->name);\n\tif (IS_ERR(newfile)) {\n\t\terr = PTR_ERR(newfile);\n\t\tput_unused_fd(newfd);\n\t\tgoto out_put;\n\t}\n\n\terr = security_socket_accept(sock, newsock);\n\tif (err)\n\t\tgoto out_fd;\n\n\terr = sock->ops->accept(sock, newsock, sock->file->f_flags, false);\n\tif (err < 0)\n\t\tgoto out_fd;\n\n\tif (upeer_sockaddr) {\n\t\tlen = newsock->ops->getname(newsock,\n\t\t\t\t\t(struct sockaddr *)&address, 2);\n\t\tif (len < 0) {\n\t\t\terr = -ECONNABORTED;\n\t\t\tgoto out_fd;\n\t\t}\n\t\terr = move_addr_to_user(&address,\n\t\t\t\t\tlen, upeer_sockaddr, upeer_addrlen);\n\t\tif (err < 0)\n\t\t\tgoto out_fd;\n\t}\n\n\t/* File flags are not inherited via accept() unlike another OSes. */\n\n\tfd_install(newfd, newfile);\n\terr = newfd;\n\nout_put:\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\nout_fd:\n\tfput(newfile);\n\tput_unused_fd(newfd);\n\tgoto out_put;\n}\n\nSYSCALL_DEFINE4(accept4, int, fd, struct sockaddr __user *, upeer_sockaddr,\n\t\tint __user *, upeer_addrlen, int, flags)\n{\n\treturn __sys_accept4(fd, upeer_sockaddr, upeer_addrlen, flags);\n}\n\nSYSCALL_DEFINE3(accept, int, fd, struct sockaddr __user *, upeer_sockaddr,\n\t\tint __user *, upeer_addrlen)\n{\n\treturn __sys_accept4(fd, upeer_sockaddr, upeer_addrlen, 0);\n}\n\n/*\n *\tAttempt to connect to a socket with the server address.  The address\n *\tis in user space so we verify it is OK and move it to kernel space.\n *\n *\tFor 1003.1g we need to add clean support for a bind to AF_UNSPEC to\n *\tbreak bindings\n *\n *\tNOTE: 1003.1g draft 6.3 is broken with respect to AX.25/NetROM and\n *\tother SEQPACKET protocols that take time to connect() as it doesn't\n *\tinclude the -EINPROGRESS status for such sockets.\n */\n\nint __sys_connect(int fd, struct sockaddr __user *uservaddr, int addrlen)\n{\n\tstruct socket *sock;\n\tstruct sockaddr_storage address;\n\tint err, fput_needed;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\terr = move_addr_to_kernel(uservaddr, addrlen, &address);\n\tif (err < 0)\n\t\tgoto out_put;\n\n\terr =\n\t    security_socket_connect(sock, (struct sockaddr *)&address, addrlen);\n\tif (err)\n\t\tgoto out_put;\n\n\terr = sock->ops->connect(sock, (struct sockaddr *)&address, addrlen,\n\t\t\t\t sock->file->f_flags);\nout_put:\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}\n\nSYSCALL_DEFINE3(connect, int, fd, struct sockaddr __user *, uservaddr,\n\t\tint, addrlen)\n{\n\treturn __sys_connect(fd, uservaddr, addrlen);\n}\n\n/*\n *\tGet the local address ('name') of a socket object. Move the obtained\n *\tname to user space.\n */\n\nint __sys_getsockname(int fd, struct sockaddr __user *usockaddr,\n\t\t      int __user *usockaddr_len)\n{\n\tstruct socket *sock;\n\tstruct sockaddr_storage address;\n\tint err, fput_needed;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\n\terr = security_socket_getsockname(sock);\n\tif (err)\n\t\tgoto out_put;\n\n\terr = sock->ops->getname(sock, (struct sockaddr *)&address, 0);\n\tif (err < 0)\n\t\tgoto out_put;\n        /* \"err\" is actually length in this case */\n\terr = move_addr_to_user(&address, err, usockaddr, usockaddr_len);\n\nout_put:\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}\n\nSYSCALL_DEFINE3(getsockname, int, fd, struct sockaddr __user *, usockaddr,\n\t\tint __user *, usockaddr_len)\n{\n\treturn __sys_getsockname(fd, usockaddr, usockaddr_len);\n}\n\n/*\n *\tGet the remote address ('name') of a socket object. Move the obtained\n *\tname to user space.\n */\n\nint __sys_getpeername(int fd, struct sockaddr __user *usockaddr,\n\t\t      int __user *usockaddr_len)\n{\n\tstruct socket *sock;\n\tstruct sockaddr_storage address;\n\tint err, fput_needed;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (sock != NULL) {\n\t\terr = security_socket_getpeername(sock);\n\t\tif (err) {\n\t\t\tfput_light(sock->file, fput_needed);\n\t\t\treturn err;\n\t\t}\n\n\t\terr = sock->ops->getname(sock, (struct sockaddr *)&address, 1);\n\t\tif (err >= 0)\n\t\t\t/* \"err\" is actually length in this case */\n\t\t\terr = move_addr_to_user(&address, err, usockaddr,\n\t\t\t\t\t\tusockaddr_len);\n\t\tfput_light(sock->file, fput_needed);\n\t}\n\treturn err;\n}\n\nSYSCALL_DEFINE3(getpeername, int, fd, struct sockaddr __user *, usockaddr,\n\t\tint __user *, usockaddr_len)\n{\n\treturn __sys_getpeername(fd, usockaddr, usockaddr_len);\n}\n\n/*\n *\tSend a datagram to a given address. We move the address into kernel\n *\tspace and check the user space data area is readable before invoking\n *\tthe protocol.\n */\nint __sys_sendto(int fd, void __user *buff, size_t len, unsigned int flags,\n\t\t struct sockaddr __user *addr,  int addr_len)\n{\n\tstruct socket *sock;\n\tstruct sockaddr_storage address;\n\tint err;\n\tstruct msghdr msg;\n\tstruct iovec iov;\n\tint fput_needed;\n\n\terr = import_single_range(WRITE, buff, len, &iov, &msg.msg_iter);\n\tif (unlikely(err))\n\t\treturn err;\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_control = NULL;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_namelen = 0;\n\tif (addr) {\n\t\terr = move_addr_to_kernel(addr, addr_len, &address);\n\t\tif (err < 0)\n\t\t\tgoto out_put;\n\t\tmsg.msg_name = (struct sockaddr *)&address;\n\t\tmsg.msg_namelen = addr_len;\n\t}\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\tmsg.msg_flags = flags;\n\terr = sock_sendmsg(sock, &msg);\n\nout_put:\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}\n\nSYSCALL_DEFINE6(sendto, int, fd, void __user *, buff, size_t, len,\n\t\tunsigned int, flags, struct sockaddr __user *, addr,\n\t\tint, addr_len)\n{\n\treturn __sys_sendto(fd, buff, len, flags, addr, addr_len);\n}\n\n/*\n *\tSend a datagram down a socket.\n */\n\nSYSCALL_DEFINE4(send, int, fd, void __user *, buff, size_t, len,\n\t\tunsigned int, flags)\n{\n\treturn __sys_sendto(fd, buff, len, flags, NULL, 0);\n}\n\n/*\n *\tReceive a frame from the socket and optionally record the address of the\n *\tsender. We verify the buffers are writable and if needed move the\n *\tsender address from kernel to user space.\n */\nint __sys_recvfrom(int fd, void __user *ubuf, size_t size, unsigned int flags,\n\t\t   struct sockaddr __user *addr, int __user *addr_len)\n{\n\tstruct socket *sock;\n\tstruct iovec iov;\n\tstruct msghdr msg;\n\tstruct sockaddr_storage address;\n\tint err, err2;\n\tint fput_needed;\n\n\terr = import_single_range(READ, ubuf, size, &iov, &msg.msg_iter);\n\tif (unlikely(err))\n\t\treturn err;\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\n\tmsg.msg_control = NULL;\n\tmsg.msg_controllen = 0;\n\t/* Save some cycles and don't copy the address if not needed */\n\tmsg.msg_name = addr ? (struct sockaddr *)&address : NULL;\n\t/* We assume all kernel code knows the size of sockaddr_storage */\n\tmsg.msg_namelen = 0;\n\tmsg.msg_iocb = NULL;\n\tmsg.msg_flags = 0;\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\terr = sock_recvmsg(sock, &msg, flags);\n\n\tif (err >= 0 && addr != NULL) {\n\t\terr2 = move_addr_to_user(&address,\n\t\t\t\t\t msg.msg_namelen, addr, addr_len);\n\t\tif (err2 < 0)\n\t\t\terr = err2;\n\t}\n\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}\n\nSYSCALL_DEFINE6(recvfrom, int, fd, void __user *, ubuf, size_t, size,\n\t\tunsigned int, flags, struct sockaddr __user *, addr,\n\t\tint __user *, addr_len)\n{\n\treturn __sys_recvfrom(fd, ubuf, size, flags, addr, addr_len);\n}\n\n/*\n *\tReceive a datagram from a socket.\n */\n\nSYSCALL_DEFINE4(recv, int, fd, void __user *, ubuf, size_t, size,\n\t\tunsigned int, flags)\n{\n\treturn __sys_recvfrom(fd, ubuf, size, flags, NULL, NULL);\n}\n\n/*\n *\tSet a socket option. Because we don't know the option lengths we have\n *\tto pass the user mode parameter for the protocols to sort out.\n */\n\nstatic int __sys_setsockopt(int fd, int level, int optname,\n\t\t\t    char __user *optval, int optlen)\n{\n\tint err, fput_needed;\n\tstruct socket *sock;\n\n\tif (optlen < 0)\n\t\treturn -EINVAL;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (sock != NULL) {\n\t\terr = security_socket_setsockopt(sock, level, optname);\n\t\tif (err)\n\t\t\tgoto out_put;\n\n\t\tif (level == SOL_SOCKET)\n\t\t\terr =\n\t\t\t    sock_setsockopt(sock, level, optname, optval,\n\t\t\t\t\t    optlen);\n\t\telse\n\t\t\terr =\n\t\t\t    sock->ops->setsockopt(sock, level, optname, optval,\n\t\t\t\t\t\t  optlen);\nout_put:\n\t\tfput_light(sock->file, fput_needed);\n\t}\n\treturn err;\n}\n\nSYSCALL_DEFINE5(setsockopt, int, fd, int, level, int, optname,\n\t\tchar __user *, optval, int, optlen)\n{\n\treturn __sys_setsockopt(fd, level, optname, optval, optlen);\n}\n\n/*\n *\tGet a socket option. Because we don't know the option lengths we have\n *\tto pass a user mode parameter for the protocols to sort out.\n */\n\nstatic int __sys_getsockopt(int fd, int level, int optname,\n\t\t\t    char __user *optval, int __user *optlen)\n{\n\tint err, fput_needed;\n\tstruct socket *sock;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (sock != NULL) {\n\t\terr = security_socket_getsockopt(sock, level, optname);\n\t\tif (err)\n\t\t\tgoto out_put;\n\n\t\tif (level == SOL_SOCKET)\n\t\t\terr =\n\t\t\t    sock_getsockopt(sock, level, optname, optval,\n\t\t\t\t\t    optlen);\n\t\telse\n\t\t\terr =\n\t\t\t    sock->ops->getsockopt(sock, level, optname, optval,\n\t\t\t\t\t\t  optlen);\nout_put:\n\t\tfput_light(sock->file, fput_needed);\n\t}\n\treturn err;\n}\n\nSYSCALL_DEFINE5(getsockopt, int, fd, int, level, int, optname,\n\t\tchar __user *, optval, int __user *, optlen)\n{\n\treturn __sys_getsockopt(fd, level, optname, optval, optlen);\n}\n\n/*\n *\tShutdown a socket.\n */\n\nint __sys_shutdown(int fd, int how)\n{\n\tint err, fput_needed;\n\tstruct socket *sock;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (sock != NULL) {\n\t\terr = security_socket_shutdown(sock, how);\n\t\tif (!err)\n\t\t\terr = sock->ops->shutdown(sock, how);\n\t\tfput_light(sock->file, fput_needed);\n\t}\n\treturn err;\n}\n\nSYSCALL_DEFINE2(shutdown, int, fd, int, how)\n{\n\treturn __sys_shutdown(fd, how);\n}\n\n/* A couple of helpful macros for getting the address of the 32/64 bit\n * fields which are the same type (int / unsigned) on our platforms.\n */\n#define COMPAT_MSG(msg, member)\t((MSG_CMSG_COMPAT & flags) ? &msg##_compat->member : &msg->member)\n#define COMPAT_NAMELEN(msg)\tCOMPAT_MSG(msg, msg_namelen)\n#define COMPAT_FLAGS(msg)\tCOMPAT_MSG(msg, msg_flags)\n\nstruct used_address {\n\tstruct sockaddr_storage name;\n\tunsigned int name_len;\n};\n\nstatic int copy_msghdr_from_user(struct msghdr *kmsg,\n\t\t\t\t struct user_msghdr __user *umsg,\n\t\t\t\t struct sockaddr __user **save_addr,\n\t\t\t\t struct iovec **iov)\n{\n\tstruct user_msghdr msg;\n\tssize_t err;\n\n\tif (copy_from_user(&msg, umsg, sizeof(*umsg)))\n\t\treturn -EFAULT;\n\n\tkmsg->msg_control = (void __force *)msg.msg_control;\n\tkmsg->msg_controllen = msg.msg_controllen;\n\tkmsg->msg_flags = msg.msg_flags;\n\n\tkmsg->msg_namelen = msg.msg_namelen;\n\tif (!msg.msg_name)\n\t\tkmsg->msg_namelen = 0;\n\n\tif (kmsg->msg_namelen < 0)\n\t\treturn -EINVAL;\n\n\tif (kmsg->msg_namelen > sizeof(struct sockaddr_storage))\n\t\tkmsg->msg_namelen = sizeof(struct sockaddr_storage);\n\n\tif (save_addr)\n\t\t*save_addr = msg.msg_name;\n\n\tif (msg.msg_name && kmsg->msg_namelen) {\n\t\tif (!save_addr) {\n\t\t\terr = move_addr_to_kernel(msg.msg_name,\n\t\t\t\t\t\t  kmsg->msg_namelen,\n\t\t\t\t\t\t  kmsg->msg_name);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tkmsg->msg_name = NULL;\n\t\tkmsg->msg_namelen = 0;\n\t}\n\n\tif (msg.msg_iovlen > UIO_MAXIOV)\n\t\treturn -EMSGSIZE;\n\n\tkmsg->msg_iocb = NULL;\n\n\treturn import_iovec(save_addr ? READ : WRITE,\n\t\t\t    msg.msg_iov, msg.msg_iovlen,\n\t\t\t    UIO_FASTIOV, iov, &kmsg->msg_iter);\n}\n\nstatic int ___sys_sendmsg(struct socket *sock, struct user_msghdr __user *msg,\n\t\t\t struct msghdr *msg_sys, unsigned int flags,\n\t\t\t struct used_address *used_address,\n\t\t\t unsigned int allowed_msghdr_flags)\n{\n\tstruct compat_msghdr __user *msg_compat =\n\t    (struct compat_msghdr __user *)msg;\n\tstruct sockaddr_storage address;\n\tstruct iovec iovstack[UIO_FASTIOV], *iov = iovstack;\n\tunsigned char ctl[sizeof(struct cmsghdr) + 20]\n\t\t\t\t__aligned(sizeof(__kernel_size_t));\n\t/* 20 is size of ipv6_pktinfo */\n\tunsigned char *ctl_buf = ctl;\n\tint ctl_len;\n\tssize_t err;\n\n\tmsg_sys->msg_name = &address;\n\n\tif (MSG_CMSG_COMPAT & flags)\n\t\terr = get_compat_msghdr(msg_sys, msg_compat, NULL, &iov);\n\telse\n\t\terr = copy_msghdr_from_user(msg_sys, msg, NULL, &iov);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = -ENOBUFS;\n\n\tif (msg_sys->msg_controllen > INT_MAX)\n\t\tgoto out_freeiov;\n\tflags |= (msg_sys->msg_flags & allowed_msghdr_flags);\n\tctl_len = msg_sys->msg_controllen;\n\tif ((MSG_CMSG_COMPAT & flags) && ctl_len) {\n\t\terr =\n\t\t    cmsghdr_from_user_compat_to_kern(msg_sys, sock->sk, ctl,\n\t\t\t\t\t\t     sizeof(ctl));\n\t\tif (err)\n\t\t\tgoto out_freeiov;\n\t\tctl_buf = msg_sys->msg_control;\n\t\tctl_len = msg_sys->msg_controllen;\n\t} else if (ctl_len) {\n\t\tBUILD_BUG_ON(sizeof(struct cmsghdr) !=\n\t\t\t     CMSG_ALIGN(sizeof(struct cmsghdr)));\n\t\tif (ctl_len > sizeof(ctl)) {\n\t\t\tctl_buf = sock_kmalloc(sock->sk, ctl_len, GFP_KERNEL);\n\t\t\tif (ctl_buf == NULL)\n\t\t\t\tgoto out_freeiov;\n\t\t}\n\t\terr = -EFAULT;\n\t\t/*\n\t\t * Careful! Before this, msg_sys->msg_control contains a user pointer.\n\t\t * Afterwards, it will be a kernel pointer. Thus the compiler-assisted\n\t\t * checking falls down on this.\n\t\t */\n\t\tif (copy_from_user(ctl_buf,\n\t\t\t\t   (void __user __force *)msg_sys->msg_control,\n\t\t\t\t   ctl_len))\n\t\t\tgoto out_freectl;\n\t\tmsg_sys->msg_control = ctl_buf;\n\t}\n\tmsg_sys->msg_flags = flags;\n\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tmsg_sys->msg_flags |= MSG_DONTWAIT;\n\t/*\n\t * If this is sendmmsg() and current destination address is same as\n\t * previously succeeded address, omit asking LSM's decision.\n\t * used_address->name_len is initialized to UINT_MAX so that the first\n\t * destination address never matches.\n\t */\n\tif (used_address && msg_sys->msg_name &&\n\t    used_address->name_len == msg_sys->msg_namelen &&\n\t    !memcmp(&used_address->name, msg_sys->msg_name,\n\t\t    used_address->name_len)) {\n\t\terr = sock_sendmsg_nosec(sock, msg_sys);\n\t\tgoto out_freectl;\n\t}\n\terr = sock_sendmsg(sock, msg_sys);\n\t/*\n\t * If this is sendmmsg() and sending to current destination address was\n\t * successful, remember it.\n\t */\n\tif (used_address && err >= 0) {\n\t\tused_address->name_len = msg_sys->msg_namelen;\n\t\tif (msg_sys->msg_name)\n\t\t\tmemcpy(&used_address->name, msg_sys->msg_name,\n\t\t\t       used_address->name_len);\n\t}\n\nout_freectl:\n\tif (ctl_buf != ctl)\n\t\tsock_kfree_s(sock->sk, ctl_buf, ctl_len);\nout_freeiov:\n\tkfree(iov);\n\treturn err;\n}\n\n/*\n *\tBSD sendmsg interface\n */\n\nlong __sys_sendmsg(int fd, struct user_msghdr __user *msg, unsigned int flags,\n\t\t   bool forbid_cmsg_compat)\n{\n\tint fput_needed, err;\n\tstruct msghdr msg_sys;\n\tstruct socket *sock;\n\n\tif (forbid_cmsg_compat && (flags & MSG_CMSG_COMPAT))\n\t\treturn -EINVAL;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\n\terr = ___sys_sendmsg(sock, msg, &msg_sys, flags, NULL, 0);\n\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}\n\nSYSCALL_DEFINE3(sendmsg, int, fd, struct user_msghdr __user *, msg, unsigned int, flags)\n{\n\treturn __sys_sendmsg(fd, msg, flags, true);\n}\n\n/*\n *\tLinux sendmmsg interface\n */\n\nint __sys_sendmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,\n\t\t   unsigned int flags, bool forbid_cmsg_compat)\n{\n\tint fput_needed, err, datagrams;\n\tstruct socket *sock;\n\tstruct mmsghdr __user *entry;\n\tstruct compat_mmsghdr __user *compat_entry;\n\tstruct msghdr msg_sys;\n\tstruct used_address used_address;\n\tunsigned int oflags = flags;\n\n\tif (forbid_cmsg_compat && (flags & MSG_CMSG_COMPAT))\n\t\treturn -EINVAL;\n\n\tif (vlen > UIO_MAXIOV)\n\t\tvlen = UIO_MAXIOV;\n\n\tdatagrams = 0;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\treturn err;\n\n\tused_address.name_len = UINT_MAX;\n\tentry = mmsg;\n\tcompat_entry = (struct compat_mmsghdr __user *)mmsg;\n\terr = 0;\n\tflags |= MSG_BATCH;\n\n\twhile (datagrams < vlen) {\n\t\tif (datagrams == vlen - 1)\n\t\t\tflags = oflags;\n\n\t\tif (MSG_CMSG_COMPAT & flags) {\n\t\t\terr = ___sys_sendmsg(sock, (struct user_msghdr __user *)compat_entry,\n\t\t\t\t\t     &msg_sys, flags, &used_address, MSG_EOR);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\terr = __put_user(err, &compat_entry->msg_len);\n\t\t\t++compat_entry;\n\t\t} else {\n\t\t\terr = ___sys_sendmsg(sock,\n\t\t\t\t\t     (struct user_msghdr __user *)entry,\n\t\t\t\t\t     &msg_sys, flags, &used_address, MSG_EOR);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\terr = put_user(err, &entry->msg_len);\n\t\t\t++entry;\n\t\t}\n\n\t\tif (err)\n\t\t\tbreak;\n\t\t++datagrams;\n\t\tif (msg_data_left(&msg_sys))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\n\tfput_light(sock->file, fput_needed);\n\n\t/* We only return an error if no datagrams were able to be sent */\n\tif (datagrams != 0)\n\t\treturn datagrams;\n\n\treturn err;\n}\n\nSYSCALL_DEFINE4(sendmmsg, int, fd, struct mmsghdr __user *, mmsg,\n\t\tunsigned int, vlen, unsigned int, flags)\n{\n\treturn __sys_sendmmsg(fd, mmsg, vlen, flags, true);\n}\n\nstatic int ___sys_recvmsg(struct socket *sock, struct user_msghdr __user *msg,\n\t\t\t struct msghdr *msg_sys, unsigned int flags, int nosec)\n{\n\tstruct compat_msghdr __user *msg_compat =\n\t    (struct compat_msghdr __user *)msg;\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tunsigned long cmsg_ptr;\n\tint len;\n\tssize_t err;\n\n\t/* kernel mode address */\n\tstruct sockaddr_storage addr;\n\n\t/* user mode address pointers */\n\tstruct sockaddr __user *uaddr;\n\tint __user *uaddr_len = COMPAT_NAMELEN(msg);\n\n\tmsg_sys->msg_name = &addr;\n\n\tif (MSG_CMSG_COMPAT & flags)\n\t\terr = get_compat_msghdr(msg_sys, msg_compat, &uaddr, &iov);\n\telse\n\t\terr = copy_msghdr_from_user(msg_sys, msg, &uaddr, &iov);\n\tif (err < 0)\n\t\treturn err;\n\n\tcmsg_ptr = (unsigned long)msg_sys->msg_control;\n\tmsg_sys->msg_flags = flags & (MSG_CMSG_CLOEXEC|MSG_CMSG_COMPAT);\n\n\t/* We assume all kernel code knows the size of sockaddr_storage */\n\tmsg_sys->msg_namelen = 0;\n\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\terr = (nosec ? sock_recvmsg_nosec : sock_recvmsg)(sock, msg_sys, flags);\n\tif (err < 0)\n\t\tgoto out_freeiov;\n\tlen = err;\n\n\tif (uaddr != NULL) {\n\t\terr = move_addr_to_user(&addr,\n\t\t\t\t\tmsg_sys->msg_namelen, uaddr,\n\t\t\t\t\tuaddr_len);\n\t\tif (err < 0)\n\t\t\tgoto out_freeiov;\n\t}\n\terr = __put_user((msg_sys->msg_flags & ~MSG_CMSG_COMPAT),\n\t\t\t COMPAT_FLAGS(msg));\n\tif (err)\n\t\tgoto out_freeiov;\n\tif (MSG_CMSG_COMPAT & flags)\n\t\terr = __put_user((unsigned long)msg_sys->msg_control - cmsg_ptr,\n\t\t\t\t &msg_compat->msg_controllen);\n\telse\n\t\terr = __put_user((unsigned long)msg_sys->msg_control - cmsg_ptr,\n\t\t\t\t &msg->msg_controllen);\n\tif (err)\n\t\tgoto out_freeiov;\n\terr = len;\n\nout_freeiov:\n\tkfree(iov);\n\treturn err;\n}\n\n/*\n *\tBSD recvmsg interface\n */\n\nlong __sys_recvmsg(int fd, struct user_msghdr __user *msg, unsigned int flags,\n\t\t   bool forbid_cmsg_compat)\n{\n\tint fput_needed, err;\n\tstruct msghdr msg_sys;\n\tstruct socket *sock;\n\n\tif (forbid_cmsg_compat && (flags & MSG_CMSG_COMPAT))\n\t\treturn -EINVAL;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\n\terr = ___sys_recvmsg(sock, msg, &msg_sys, flags, 0);\n\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}\n\nSYSCALL_DEFINE3(recvmsg, int, fd, struct user_msghdr __user *, msg,\n\t\tunsigned int, flags)\n{\n\treturn __sys_recvmsg(fd, msg, flags, true);\n}\n\n/*\n *     Linux recvmmsg interface\n */\n\nint __sys_recvmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,\n\t\t   unsigned int flags, struct timespec *timeout)\n{\n\tint fput_needed, err, datagrams;\n\tstruct socket *sock;\n\tstruct mmsghdr __user *entry;\n\tstruct compat_mmsghdr __user *compat_entry;\n\tstruct msghdr msg_sys;\n\tstruct timespec64 end_time;\n\tstruct timespec64 timeout64;\n\n\tif (timeout &&\n\t    poll_select_set_timeout(&end_time, timeout->tv_sec,\n\t\t\t\t    timeout->tv_nsec))\n\t\treturn -EINVAL;\n\n\tdatagrams = 0;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\treturn err;\n\n\tif (likely(!(flags & MSG_ERRQUEUE))) {\n\t\terr = sock_error(sock->sk);\n\t\tif (err) {\n\t\t\tdatagrams = err;\n\t\t\tgoto out_put;\n\t\t}\n\t}\n\n\tentry = mmsg;\n\tcompat_entry = (struct compat_mmsghdr __user *)mmsg;\n\n\twhile (datagrams < vlen) {\n\t\t/*\n\t\t * No need to ask LSM for more than the first datagram.\n\t\t */\n\t\tif (MSG_CMSG_COMPAT & flags) {\n\t\t\terr = ___sys_recvmsg(sock, (struct user_msghdr __user *)compat_entry,\n\t\t\t\t\t     &msg_sys, flags & ~MSG_WAITFORONE,\n\t\t\t\t\t     datagrams);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\terr = __put_user(err, &compat_entry->msg_len);\n\t\t\t++compat_entry;\n\t\t} else {\n\t\t\terr = ___sys_recvmsg(sock,\n\t\t\t\t\t     (struct user_msghdr __user *)entry,\n\t\t\t\t\t     &msg_sys, flags & ~MSG_WAITFORONE,\n\t\t\t\t\t     datagrams);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\terr = put_user(err, &entry->msg_len);\n\t\t\t++entry;\n\t\t}\n\n\t\tif (err)\n\t\t\tbreak;\n\t\t++datagrams;\n\n\t\t/* MSG_WAITFORONE turns on MSG_DONTWAIT after one packet */\n\t\tif (flags & MSG_WAITFORONE)\n\t\t\tflags |= MSG_DONTWAIT;\n\n\t\tif (timeout) {\n\t\t\tktime_get_ts64(&timeout64);\n\t\t\t*timeout = timespec64_to_timespec(\n\t\t\t\t\ttimespec64_sub(end_time, timeout64));\n\t\t\tif (timeout->tv_sec < 0) {\n\t\t\t\ttimeout->tv_sec = timeout->tv_nsec = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Timeout, return less than vlen datagrams */\n\t\t\tif (timeout->tv_nsec == 0 && timeout->tv_sec == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Out of band data, return right away */\n\t\tif (msg_sys.msg_flags & MSG_OOB)\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\n\tif (err == 0)\n\t\tgoto out_put;\n\n\tif (datagrams == 0) {\n\t\tdatagrams = err;\n\t\tgoto out_put;\n\t}\n\n\t/*\n\t * We may return less entries than requested (vlen) if the\n\t * sock is non block and there aren't enough datagrams...\n\t */\n\tif (err != -EAGAIN) {\n\t\t/*\n\t\t * ... or  if recvmsg returns an error after we\n\t\t * received some datagrams, where we record the\n\t\t * error to return on the next call or if the\n\t\t * app asks about it using getsockopt(SO_ERROR).\n\t\t */\n\t\tsock->sk->sk_err = -err;\n\t}\nout_put:\n\tfput_light(sock->file, fput_needed);\n\n\treturn datagrams;\n}\n\nstatic int do_sys_recvmmsg(int fd, struct mmsghdr __user *mmsg,\n\t\t\t   unsigned int vlen, unsigned int flags,\n\t\t\t   struct timespec __user *timeout)\n{\n\tint datagrams;\n\tstruct timespec timeout_sys;\n\n\tif (flags & MSG_CMSG_COMPAT)\n\t\treturn -EINVAL;\n\n\tif (!timeout)\n\t\treturn __sys_recvmmsg(fd, mmsg, vlen, flags, NULL);\n\n\tif (copy_from_user(&timeout_sys, timeout, sizeof(timeout_sys)))\n\t\treturn -EFAULT;\n\n\tdatagrams = __sys_recvmmsg(fd, mmsg, vlen, flags, &timeout_sys);\n\n\tif (datagrams > 0 &&\n\t    copy_to_user(timeout, &timeout_sys, sizeof(timeout_sys)))\n\t\tdatagrams = -EFAULT;\n\n\treturn datagrams;\n}\n\nSYSCALL_DEFINE5(recvmmsg, int, fd, struct mmsghdr __user *, mmsg,\n\t\tunsigned int, vlen, unsigned int, flags,\n\t\tstruct timespec __user *, timeout)\n{\n\treturn do_sys_recvmmsg(fd, mmsg, vlen, flags, timeout);\n}\n\n#ifdef __ARCH_WANT_SYS_SOCKETCALL\n/* Argument list sizes for sys_socketcall */\n#define AL(x) ((x) * sizeof(unsigned long))\nstatic const unsigned char nargs[21] = {\n\tAL(0), AL(3), AL(3), AL(3), AL(2), AL(3),\n\tAL(3), AL(3), AL(4), AL(4), AL(4), AL(6),\n\tAL(6), AL(2), AL(5), AL(5), AL(3), AL(3),\n\tAL(4), AL(5), AL(4)\n};\n\n#undef AL\n\n/*\n *\tSystem call vectors.\n *\n *\tArgument checking cleaned up. Saved 20% in size.\n *  This function doesn't need to set the kernel lock because\n *  it is set by the callees.\n */\n\nSYSCALL_DEFINE2(socketcall, int, call, unsigned long __user *, args)\n{\n\tunsigned long a[AUDITSC_ARGS];\n\tunsigned long a0, a1;\n\tint err;\n\tunsigned int len;\n\n\tif (call < 1 || call > SYS_SENDMMSG)\n\t\treturn -EINVAL;\n\n\tlen = nargs[call];\n\tif (len > sizeof(a))\n\t\treturn -EINVAL;\n\n\t/* copy_from_user should be SMP safe. */\n\tif (copy_from_user(a, args, len))\n\t\treturn -EFAULT;\n\n\terr = audit_socketcall(nargs[call] / sizeof(unsigned long), a);\n\tif (err)\n\t\treturn err;\n\n\ta0 = a[0];\n\ta1 = a[1];\n\n\tswitch (call) {\n\tcase SYS_SOCKET:\n\t\terr = __sys_socket(a0, a1, a[2]);\n\t\tbreak;\n\tcase SYS_BIND:\n\t\terr = __sys_bind(a0, (struct sockaddr __user *)a1, a[2]);\n\t\tbreak;\n\tcase SYS_CONNECT:\n\t\terr = __sys_connect(a0, (struct sockaddr __user *)a1, a[2]);\n\t\tbreak;\n\tcase SYS_LISTEN:\n\t\terr = __sys_listen(a0, a1);\n\t\tbreak;\n\tcase SYS_ACCEPT:\n\t\terr = __sys_accept4(a0, (struct sockaddr __user *)a1,\n\t\t\t\t    (int __user *)a[2], 0);\n\t\tbreak;\n\tcase SYS_GETSOCKNAME:\n\t\terr =\n\t\t    __sys_getsockname(a0, (struct sockaddr __user *)a1,\n\t\t\t\t      (int __user *)a[2]);\n\t\tbreak;\n\tcase SYS_GETPEERNAME:\n\t\terr =\n\t\t    __sys_getpeername(a0, (struct sockaddr __user *)a1,\n\t\t\t\t      (int __user *)a[2]);\n\t\tbreak;\n\tcase SYS_SOCKETPAIR:\n\t\terr = __sys_socketpair(a0, a1, a[2], (int __user *)a[3]);\n\t\tbreak;\n\tcase SYS_SEND:\n\t\terr = __sys_sendto(a0, (void __user *)a1, a[2], a[3],\n\t\t\t\t   NULL, 0);\n\t\tbreak;\n\tcase SYS_SENDTO:\n\t\terr = __sys_sendto(a0, (void __user *)a1, a[2], a[3],\n\t\t\t\t   (struct sockaddr __user *)a[4], a[5]);\n\t\tbreak;\n\tcase SYS_RECV:\n\t\terr = __sys_recvfrom(a0, (void __user *)a1, a[2], a[3],\n\t\t\t\t     NULL, NULL);\n\t\tbreak;\n\tcase SYS_RECVFROM:\n\t\terr = __sys_recvfrom(a0, (void __user *)a1, a[2], a[3],\n\t\t\t\t     (struct sockaddr __user *)a[4],\n\t\t\t\t     (int __user *)a[5]);\n\t\tbreak;\n\tcase SYS_SHUTDOWN:\n\t\terr = __sys_shutdown(a0, a1);\n\t\tbreak;\n\tcase SYS_SETSOCKOPT:\n\t\terr = __sys_setsockopt(a0, a1, a[2], (char __user *)a[3],\n\t\t\t\t       a[4]);\n\t\tbreak;\n\tcase SYS_GETSOCKOPT:\n\t\terr =\n\t\t    __sys_getsockopt(a0, a1, a[2], (char __user *)a[3],\n\t\t\t\t     (int __user *)a[4]);\n\t\tbreak;\n\tcase SYS_SENDMSG:\n\t\terr = __sys_sendmsg(a0, (struct user_msghdr __user *)a1,\n\t\t\t\t    a[2], true);\n\t\tbreak;\n\tcase SYS_SENDMMSG:\n\t\terr = __sys_sendmmsg(a0, (struct mmsghdr __user *)a1, a[2],\n\t\t\t\t     a[3], true);\n\t\tbreak;\n\tcase SYS_RECVMSG:\n\t\terr = __sys_recvmsg(a0, (struct user_msghdr __user *)a1,\n\t\t\t\t    a[2], true);\n\t\tbreak;\n\tcase SYS_RECVMMSG:\n\t\terr = do_sys_recvmmsg(a0, (struct mmsghdr __user *)a1, a[2],\n\t\t\t\t      a[3], (struct timespec __user *)a[4]);\n\t\tbreak;\n\tcase SYS_ACCEPT4:\n\t\terr = __sys_accept4(a0, (struct sockaddr __user *)a1,\n\t\t\t\t    (int __user *)a[2], a[3]);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\treturn err;\n}\n\n#endif\t\t\t\t/* __ARCH_WANT_SYS_SOCKETCALL */\n\n/**\n *\tsock_register - add a socket protocol handler\n *\t@ops: description of protocol\n *\n *\tThis function is called by a protocol handler that wants to\n *\tadvertise its address family, and have it linked into the\n *\tsocket interface. The value ops->family corresponds to the\n *\tsocket system call protocol family.\n */\nint sock_register(const struct net_proto_family *ops)\n{\n\tint err;\n\n\tif (ops->family >= NPROTO) {\n\t\tpr_crit(\"protocol %d >= NPROTO(%d)\\n\", ops->family, NPROTO);\n\t\treturn -ENOBUFS;\n\t}\n\n\tspin_lock(&net_family_lock);\n\tif (rcu_dereference_protected(net_families[ops->family],\n\t\t\t\t      lockdep_is_held(&net_family_lock)))\n\t\terr = -EEXIST;\n\telse {\n\t\trcu_assign_pointer(net_families[ops->family], ops);\n\t\terr = 0;\n\t}\n\tspin_unlock(&net_family_lock);\n\n\tpr_info(\"NET: Registered protocol family %d\\n\", ops->family);\n\treturn err;\n}\nEXPORT_SYMBOL(sock_register);\n\n/**\n *\tsock_unregister - remove a protocol handler\n *\t@family: protocol family to remove\n *\n *\tThis function is called by a protocol handler that wants to\n *\tremove its address family, and have it unlinked from the\n *\tnew socket creation.\n *\n *\tIf protocol handler is a module, then it can use module reference\n *\tcounts to protect against new references. If protocol handler is not\n *\ta module then it needs to provide its own protection in\n *\tthe ops->create routine.\n */\nvoid sock_unregister(int family)\n{\n\tBUG_ON(family < 0 || family >= NPROTO);\n\n\tspin_lock(&net_family_lock);\n\tRCU_INIT_POINTER(net_families[family], NULL);\n\tspin_unlock(&net_family_lock);\n\n\tsynchronize_rcu();\n\n\tpr_info(\"NET: Unregistered protocol family %d\\n\", family);\n}\nEXPORT_SYMBOL(sock_unregister);\n\nbool sock_is_registered(int family)\n{\n\treturn family < NPROTO && rcu_access_pointer(net_families[family]);\n}\n\nstatic int __init sock_init(void)\n{\n\tint err;\n\t/*\n\t *      Initialize the network sysctl infrastructure.\n\t */\n\terr = net_sysctl_init();\n\tif (err)\n\t\tgoto out;\n\n\t/*\n\t *      Initialize skbuff SLAB cache\n\t */\n\tskb_init();\n\n\t/*\n\t *      Initialize the protocols module.\n\t */\n\n\tinit_inodecache();\n\n\terr = register_filesystem(&sock_fs_type);\n\tif (err)\n\t\tgoto out_fs;\n\tsock_mnt = kern_mount(&sock_fs_type);\n\tif (IS_ERR(sock_mnt)) {\n\t\terr = PTR_ERR(sock_mnt);\n\t\tgoto out_mount;\n\t}\n\n\t/* The real protocol initialization is performed in later initcalls.\n\t */\n\n#ifdef CONFIG_NETFILTER\n\terr = netfilter_init();\n\tif (err)\n\t\tgoto out;\n#endif\n\n\tptp_classifier_init();\n\nout:\n\treturn err;\n\nout_mount:\n\tunregister_filesystem(&sock_fs_type);\nout_fs:\n\tgoto out;\n}\n\ncore_initcall(sock_init);\t/* early initcall */\n\n#ifdef CONFIG_PROC_FS\nvoid socket_seq_show(struct seq_file *seq)\n{\n\tseq_printf(seq, \"sockets: used %d\\n\",\n\t\t   sock_inuse_get(seq->private));\n}\n#endif\t\t\t\t/* CONFIG_PROC_FS */\n\n#ifdef CONFIG_COMPAT\nstatic int do_siocgstamp(struct net *net, struct socket *sock,\n\t\t\t unsigned int cmd, void __user *up)\n{\n\tmm_segment_t old_fs = get_fs();\n\tstruct timeval ktv;\n\tint err;\n\n\tset_fs(KERNEL_DS);\n\terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&ktv);\n\tset_fs(old_fs);\n\tif (!err)\n\t\terr = compat_put_timeval(&ktv, up);\n\n\treturn err;\n}\n\nstatic int do_siocgstampns(struct net *net, struct socket *sock,\n\t\t\t   unsigned int cmd, void __user *up)\n{\n\tmm_segment_t old_fs = get_fs();\n\tstruct timespec kts;\n\tint err;\n\n\tset_fs(KERNEL_DS);\n\terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&kts);\n\tset_fs(old_fs);\n\tif (!err)\n\t\terr = compat_put_timespec(&kts, up);\n\n\treturn err;\n}\n\nstatic int compat_dev_ifconf(struct net *net, struct compat_ifconf __user *uifc32)\n{\n\tstruct compat_ifconf ifc32;\n\tstruct ifconf ifc;\n\tint err;\n\n\tif (copy_from_user(&ifc32, uifc32, sizeof(struct compat_ifconf)))\n\t\treturn -EFAULT;\n\n\tifc.ifc_len = ifc32.ifc_len;\n\tifc.ifc_req = compat_ptr(ifc32.ifcbuf);\n\n\trtnl_lock();\n\terr = dev_ifconf(net, &ifc, sizeof(struct compat_ifreq));\n\trtnl_unlock();\n\tif (err)\n\t\treturn err;\n\n\tifc32.ifc_len = ifc.ifc_len;\n\tif (copy_to_user(uifc32, &ifc32, sizeof(struct compat_ifconf)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int ethtool_ioctl(struct net *net, struct compat_ifreq __user *ifr32)\n{\n\tstruct compat_ethtool_rxnfc __user *compat_rxnfc;\n\tbool convert_in = false, convert_out = false;\n\tsize_t buf_size = 0;\n\tstruct ethtool_rxnfc __user *rxnfc = NULL;\n\tstruct ifreq ifr;\n\tu32 rule_cnt = 0, actual_rule_cnt;\n\tu32 ethcmd;\n\tu32 data;\n\tint ret;\n\n\tif (get_user(data, &ifr32->ifr_ifru.ifru_data))\n\t\treturn -EFAULT;\n\n\tcompat_rxnfc = compat_ptr(data);\n\n\tif (get_user(ethcmd, &compat_rxnfc->cmd))\n\t\treturn -EFAULT;\n\n\t/* Most ethtool structures are defined without padding.\n\t * Unfortunately struct ethtool_rxnfc is an exception.\n\t */\n\tswitch (ethcmd) {\n\tdefault:\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLALL:\n\t\t/* Buffer size is variable */\n\t\tif (get_user(rule_cnt, &compat_rxnfc->rule_cnt))\n\t\t\treturn -EFAULT;\n\t\tif (rule_cnt > KMALLOC_MAX_SIZE / sizeof(u32))\n\t\t\treturn -ENOMEM;\n\t\tbuf_size += rule_cnt * sizeof(u32);\n\t\t/* fall through */\n\tcase ETHTOOL_GRXRINGS:\n\tcase ETHTOOL_GRXCLSRLCNT:\n\tcase ETHTOOL_GRXCLSRULE:\n\tcase ETHTOOL_SRXCLSRLINS:\n\t\tconvert_out = true;\n\t\t/* fall through */\n\tcase ETHTOOL_SRXCLSRLDEL:\n\t\tbuf_size += sizeof(struct ethtool_rxnfc);\n\t\tconvert_in = true;\n\t\trxnfc = compat_alloc_user_space(buf_size);\n\t\tbreak;\n\t}\n\n\tif (copy_from_user(&ifr.ifr_name, &ifr32->ifr_name, IFNAMSIZ))\n\t\treturn -EFAULT;\n\n\tifr.ifr_data = convert_in ? rxnfc : (void __user *)compat_rxnfc;\n\n\tif (convert_in) {\n\t\t/* We expect there to be holes between fs.m_ext and\n\t\t * fs.ring_cookie and at the end of fs, but nowhere else.\n\t\t */\n\t\tBUILD_BUG_ON(offsetof(struct compat_ethtool_rxnfc, fs.m_ext) +\n\t\t\t     sizeof(compat_rxnfc->fs.m_ext) !=\n\t\t\t     offsetof(struct ethtool_rxnfc, fs.m_ext) +\n\t\t\t     sizeof(rxnfc->fs.m_ext));\n\t\tBUILD_BUG_ON(\n\t\t\toffsetof(struct compat_ethtool_rxnfc, fs.location) -\n\t\t\toffsetof(struct compat_ethtool_rxnfc, fs.ring_cookie) !=\n\t\t\toffsetof(struct ethtool_rxnfc, fs.location) -\n\t\t\toffsetof(struct ethtool_rxnfc, fs.ring_cookie));\n\n\t\tif (copy_in_user(rxnfc, compat_rxnfc,\n\t\t\t\t (void __user *)(&rxnfc->fs.m_ext + 1) -\n\t\t\t\t (void __user *)rxnfc) ||\n\t\t    copy_in_user(&rxnfc->fs.ring_cookie,\n\t\t\t\t &compat_rxnfc->fs.ring_cookie,\n\t\t\t\t (void __user *)(&rxnfc->fs.location + 1) -\n\t\t\t\t (void __user *)&rxnfc->fs.ring_cookie) ||\n\t\t    copy_in_user(&rxnfc->rule_cnt, &compat_rxnfc->rule_cnt,\n\t\t\t\t sizeof(rxnfc->rule_cnt)))\n\t\t\treturn -EFAULT;\n\t}\n\n\tret = dev_ioctl(net, SIOCETHTOOL, &ifr, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (convert_out) {\n\t\tif (copy_in_user(compat_rxnfc, rxnfc,\n\t\t\t\t (const void __user *)(&rxnfc->fs.m_ext + 1) -\n\t\t\t\t (const void __user *)rxnfc) ||\n\t\t    copy_in_user(&compat_rxnfc->fs.ring_cookie,\n\t\t\t\t &rxnfc->fs.ring_cookie,\n\t\t\t\t (const void __user *)(&rxnfc->fs.location + 1) -\n\t\t\t\t (const void __user *)&rxnfc->fs.ring_cookie) ||\n\t\t    copy_in_user(&compat_rxnfc->rule_cnt, &rxnfc->rule_cnt,\n\t\t\t\t sizeof(rxnfc->rule_cnt)))\n\t\t\treturn -EFAULT;\n\n\t\tif (ethcmd == ETHTOOL_GRXCLSRLALL) {\n\t\t\t/* As an optimisation, we only copy the actual\n\t\t\t * number of rules that the underlying\n\t\t\t * function returned.  Since Mallory might\n\t\t\t * change the rule count in user memory, we\n\t\t\t * check that it is less than the rule count\n\t\t\t * originally given (as the user buffer size),\n\t\t\t * which has been range-checked.\n\t\t\t */\n\t\t\tif (get_user(actual_rule_cnt, &rxnfc->rule_cnt))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (actual_rule_cnt < rule_cnt)\n\t\t\t\trule_cnt = actual_rule_cnt;\n\t\t\tif (copy_in_user(&compat_rxnfc->rule_locs[0],\n\t\t\t\t\t &rxnfc->rule_locs[0],\n\t\t\t\t\t rule_cnt * sizeof(u32)))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int compat_siocwandev(struct net *net, struct compat_ifreq __user *uifr32)\n{\n\tcompat_uptr_t uptr32;\n\tstruct ifreq ifr;\n\tvoid __user *saved;\n\tint err;\n\n\tif (copy_from_user(&ifr, uifr32, sizeof(struct compat_ifreq)))\n\t\treturn -EFAULT;\n\n\tif (get_user(uptr32, &uifr32->ifr_settings.ifs_ifsu))\n\t\treturn -EFAULT;\n\n\tsaved = ifr.ifr_settings.ifs_ifsu.raw_hdlc;\n\tifr.ifr_settings.ifs_ifsu.raw_hdlc = compat_ptr(uptr32);\n\n\terr = dev_ioctl(net, SIOCWANDEV, &ifr, NULL);\n\tif (!err) {\n\t\tifr.ifr_settings.ifs_ifsu.raw_hdlc = saved;\n\t\tif (copy_to_user(uifr32, &ifr, sizeof(struct compat_ifreq)))\n\t\t\terr = -EFAULT;\n\t}\n\treturn err;\n}\n\n/* Handle ioctls that use ifreq::ifr_data and just need struct ifreq converted */\nstatic int compat_ifr_data_ioctl(struct net *net, unsigned int cmd,\n\t\t\t\t struct compat_ifreq __user *u_ifreq32)\n{\n\tstruct ifreq ifreq;\n\tu32 data32;\n\n\tif (copy_from_user(ifreq.ifr_name, u_ifreq32->ifr_name, IFNAMSIZ))\n\t\treturn -EFAULT;\n\tif (get_user(data32, &u_ifreq32->ifr_data))\n\t\treturn -EFAULT;\n\tifreq.ifr_data = compat_ptr(data32);\n\n\treturn dev_ioctl(net, cmd, &ifreq, NULL);\n}\n\nstatic int compat_sioc_ifmap(struct net *net, unsigned int cmd,\n\t\t\tstruct compat_ifreq __user *uifr32)\n{\n\tstruct ifreq ifr;\n\tstruct compat_ifmap __user *uifmap32;\n\tint err;\n\n\tuifmap32 = &uifr32->ifr_ifru.ifru_map;\n\terr = copy_from_user(&ifr, uifr32, sizeof(ifr.ifr_name));\n\terr |= get_user(ifr.ifr_map.mem_start, &uifmap32->mem_start);\n\terr |= get_user(ifr.ifr_map.mem_end, &uifmap32->mem_end);\n\terr |= get_user(ifr.ifr_map.base_addr, &uifmap32->base_addr);\n\terr |= get_user(ifr.ifr_map.irq, &uifmap32->irq);\n\terr |= get_user(ifr.ifr_map.dma, &uifmap32->dma);\n\terr |= get_user(ifr.ifr_map.port, &uifmap32->port);\n\tif (err)\n\t\treturn -EFAULT;\n\n\terr = dev_ioctl(net, cmd, &ifr, NULL);\n\n\tif (cmd == SIOCGIFMAP && !err) {\n\t\terr = copy_to_user(uifr32, &ifr, sizeof(ifr.ifr_name));\n\t\terr |= put_user(ifr.ifr_map.mem_start, &uifmap32->mem_start);\n\t\terr |= put_user(ifr.ifr_map.mem_end, &uifmap32->mem_end);\n\t\terr |= put_user(ifr.ifr_map.base_addr, &uifmap32->base_addr);\n\t\terr |= put_user(ifr.ifr_map.irq, &uifmap32->irq);\n\t\terr |= put_user(ifr.ifr_map.dma, &uifmap32->dma);\n\t\terr |= put_user(ifr.ifr_map.port, &uifmap32->port);\n\t\tif (err)\n\t\t\terr = -EFAULT;\n\t}\n\treturn err;\n}\n\nstruct rtentry32 {\n\tu32\t\trt_pad1;\n\tstruct sockaddr rt_dst;         /* target address               */\n\tstruct sockaddr rt_gateway;     /* gateway addr (RTF_GATEWAY)   */\n\tstruct sockaddr rt_genmask;     /* target network mask (IP)     */\n\tunsigned short\trt_flags;\n\tshort\t\trt_pad2;\n\tu32\t\trt_pad3;\n\tunsigned char\trt_tos;\n\tunsigned char\trt_class;\n\tshort\t\trt_pad4;\n\tshort\t\trt_metric;      /* +1 for binary compatibility! */\n\t/* char * */ u32 rt_dev;        /* forcing the device at add    */\n\tu32\t\trt_mtu;         /* per route MTU/Window         */\n\tu32\t\trt_window;      /* Window clamping              */\n\tunsigned short  rt_irtt;        /* Initial RTT                  */\n};\n\nstruct in6_rtmsg32 {\n\tstruct in6_addr\t\trtmsg_dst;\n\tstruct in6_addr\t\trtmsg_src;\n\tstruct in6_addr\t\trtmsg_gateway;\n\tu32\t\t\trtmsg_type;\n\tu16\t\t\trtmsg_dst_len;\n\tu16\t\t\trtmsg_src_len;\n\tu32\t\t\trtmsg_metric;\n\tu32\t\t\trtmsg_info;\n\tu32\t\t\trtmsg_flags;\n\ts32\t\t\trtmsg_ifindex;\n};\n\nstatic int routing_ioctl(struct net *net, struct socket *sock,\n\t\t\t unsigned int cmd, void __user *argp)\n{\n\tint ret;\n\tvoid *r = NULL;\n\tstruct in6_rtmsg r6;\n\tstruct rtentry r4;\n\tchar devname[16];\n\tu32 rtdev;\n\tmm_segment_t old_fs = get_fs();\n\n\tif (sock && sock->sk && sock->sk->sk_family == AF_INET6) { /* ipv6 */\n\t\tstruct in6_rtmsg32 __user *ur6 = argp;\n\t\tret = copy_from_user(&r6.rtmsg_dst, &(ur6->rtmsg_dst),\n\t\t\t3 * sizeof(struct in6_addr));\n\t\tret |= get_user(r6.rtmsg_type, &(ur6->rtmsg_type));\n\t\tret |= get_user(r6.rtmsg_dst_len, &(ur6->rtmsg_dst_len));\n\t\tret |= get_user(r6.rtmsg_src_len, &(ur6->rtmsg_src_len));\n\t\tret |= get_user(r6.rtmsg_metric, &(ur6->rtmsg_metric));\n\t\tret |= get_user(r6.rtmsg_info, &(ur6->rtmsg_info));\n\t\tret |= get_user(r6.rtmsg_flags, &(ur6->rtmsg_flags));\n\t\tret |= get_user(r6.rtmsg_ifindex, &(ur6->rtmsg_ifindex));\n\n\t\tr = (void *) &r6;\n\t} else { /* ipv4 */\n\t\tstruct rtentry32 __user *ur4 = argp;\n\t\tret = copy_from_user(&r4.rt_dst, &(ur4->rt_dst),\n\t\t\t\t\t3 * sizeof(struct sockaddr));\n\t\tret |= get_user(r4.rt_flags, &(ur4->rt_flags));\n\t\tret |= get_user(r4.rt_metric, &(ur4->rt_metric));\n\t\tret |= get_user(r4.rt_mtu, &(ur4->rt_mtu));\n\t\tret |= get_user(r4.rt_window, &(ur4->rt_window));\n\t\tret |= get_user(r4.rt_irtt, &(ur4->rt_irtt));\n\t\tret |= get_user(rtdev, &(ur4->rt_dev));\n\t\tif (rtdev) {\n\t\t\tret |= copy_from_user(devname, compat_ptr(rtdev), 15);\n\t\t\tr4.rt_dev = (char __user __force *)devname;\n\t\t\tdevname[15] = 0;\n\t\t} else\n\t\t\tr4.rt_dev = NULL;\n\n\t\tr = (void *) &r4;\n\t}\n\n\tif (ret) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tset_fs(KERNEL_DS);\n\tret = sock_do_ioctl(net, sock, cmd, (unsigned long) r);\n\tset_fs(old_fs);\n\nout:\n\treturn ret;\n}\n\n/* Since old style bridge ioctl's endup using SIOCDEVPRIVATE\n * for some operations; this forces use of the newer bridge-utils that\n * use compatible ioctls\n */\nstatic int old_bridge_ioctl(compat_ulong_t __user *argp)\n{\n\tcompat_ulong_t tmp;\n\n\tif (get_user(tmp, argp))\n\t\treturn -EFAULT;\n\tif (tmp == BRCTL_GET_VERSION)\n\t\treturn BRCTL_VERSION + 1;\n\treturn -EINVAL;\n}\n\nstatic int compat_sock_ioctl_trans(struct file *file, struct socket *sock,\n\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = compat_ptr(arg);\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\n\tif (cmd >= SIOCDEVPRIVATE && cmd <= (SIOCDEVPRIVATE + 15))\n\t\treturn compat_ifr_data_ioctl(net, cmd, argp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFBR:\n\tcase SIOCGIFBR:\n\t\treturn old_bridge_ioctl(argp);\n\tcase SIOCGIFCONF:\n\t\treturn compat_dev_ifconf(net, argp);\n\tcase SIOCETHTOOL:\n\t\treturn ethtool_ioctl(net, argp);\n\tcase SIOCWANDEV:\n\t\treturn compat_siocwandev(net, argp);\n\tcase SIOCGIFMAP:\n\tcase SIOCSIFMAP:\n\t\treturn compat_sioc_ifmap(net, cmd, argp);\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\t\treturn routing_ioctl(net, sock, cmd, argp);\n\tcase SIOCGSTAMP:\n\t\treturn do_siocgstamp(net, sock, cmd, argp);\n\tcase SIOCGSTAMPNS:\n\t\treturn do_siocgstampns(net, sock, cmd, argp);\n\tcase SIOCBONDSLAVEINFOQUERY:\n\tcase SIOCBONDINFOQUERY:\n\tcase SIOCSHWTSTAMP:\n\tcase SIOCGHWTSTAMP:\n\t\treturn compat_ifr_data_ioctl(net, cmd, argp);\n\n\tcase FIOSETOWN:\n\tcase SIOCSPGRP:\n\tcase FIOGETOWN:\n\tcase SIOCGPGRP:\n\tcase SIOCBRADDBR:\n\tcase SIOCBRDELBR:\n\tcase SIOCGIFVLAN:\n\tcase SIOCSIFVLAN:\n\tcase SIOCADDDLCI:\n\tcase SIOCDELDLCI:\n\tcase SIOCGSKNS:\n\t\treturn sock_ioctl(file, cmd, arg);\n\n\tcase SIOCGIFFLAGS:\n\tcase SIOCSIFFLAGS:\n\tcase SIOCGIFMETRIC:\n\tcase SIOCSIFMETRIC:\n\tcase SIOCGIFMTU:\n\tcase SIOCSIFMTU:\n\tcase SIOCGIFMEM:\n\tcase SIOCSIFMEM:\n\tcase SIOCGIFHWADDR:\n\tcase SIOCSIFHWADDR:\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\tcase SIOCGIFINDEX:\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFADDR:\n\tcase SIOCSIFHWBROADCAST:\n\tcase SIOCDIFADDR:\n\tcase SIOCGIFBRDADDR:\n\tcase SIOCSIFBRDADDR:\n\tcase SIOCGIFDSTADDR:\n\tcase SIOCSIFDSTADDR:\n\tcase SIOCGIFNETMASK:\n\tcase SIOCSIFNETMASK:\n\tcase SIOCSIFPFLAGS:\n\tcase SIOCGIFPFLAGS:\n\tcase SIOCGIFTXQLEN:\n\tcase SIOCSIFTXQLEN:\n\tcase SIOCBRADDIF:\n\tcase SIOCBRDELIF:\n\tcase SIOCSIFNAME:\n\tcase SIOCGMIIPHY:\n\tcase SIOCGMIIREG:\n\tcase SIOCSMIIREG:\n\tcase SIOCSARP:\n\tcase SIOCGARP:\n\tcase SIOCDARP:\n\tcase SIOCATMARK:\n\tcase SIOCBONDENSLAVE:\n\tcase SIOCBONDRELEASE:\n\tcase SIOCBONDSETHWADDR:\n\tcase SIOCBONDCHANGEACTIVE:\n\tcase SIOCGIFNAME:\n\t\treturn sock_do_ioctl(net, sock, cmd, arg);\n\t}\n\n\treturn -ENOIOCTLCMD;\n}\n\nstatic long compat_sock_ioctl(struct file *file, unsigned int cmd,\n\t\t\t      unsigned long arg)\n{\n\tstruct socket *sock = file->private_data;\n\tint ret = -ENOIOCTLCMD;\n\tstruct sock *sk;\n\tstruct net *net;\n\n\tsk = sock->sk;\n\tnet = sock_net(sk);\n\n\tif (sock->ops->compat_ioctl)\n\t\tret = sock->ops->compat_ioctl(sock, cmd, arg);\n\n\tif (ret == -ENOIOCTLCMD &&\n\t    (cmd >= SIOCIWFIRST && cmd <= SIOCIWLAST))\n\t\tret = compat_wext_handle_ioctl(net, cmd, arg);\n\n\tif (ret == -ENOIOCTLCMD)\n\t\tret = compat_sock_ioctl_trans(file, sock, cmd, arg);\n\n\treturn ret;\n}\n#endif\n\nint kernel_bind(struct socket *sock, struct sockaddr *addr, int addrlen)\n{\n\treturn sock->ops->bind(sock, addr, addrlen);\n}\nEXPORT_SYMBOL(kernel_bind);\n\nint kernel_listen(struct socket *sock, int backlog)\n{\n\treturn sock->ops->listen(sock, backlog);\n}\nEXPORT_SYMBOL(kernel_listen);\n\nint kernel_accept(struct socket *sock, struct socket **newsock, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tint err;\n\n\terr = sock_create_lite(sk->sk_family, sk->sk_type, sk->sk_protocol,\n\t\t\t       newsock);\n\tif (err < 0)\n\t\tgoto done;\n\n\terr = sock->ops->accept(sock, *newsock, flags, true);\n\tif (err < 0) {\n\t\tsock_release(*newsock);\n\t\t*newsock = NULL;\n\t\tgoto done;\n\t}\n\n\t(*newsock)->ops = sock->ops;\n\t__module_get((*newsock)->ops->owner);\n\ndone:\n\treturn err;\n}\nEXPORT_SYMBOL(kernel_accept);\n\nint kernel_connect(struct socket *sock, struct sockaddr *addr, int addrlen,\n\t\t   int flags)\n{\n\treturn sock->ops->connect(sock, addr, addrlen, flags);\n}\nEXPORT_SYMBOL(kernel_connect);\n\nint kernel_getsockname(struct socket *sock, struct sockaddr *addr)\n{\n\treturn sock->ops->getname(sock, addr, 0);\n}\nEXPORT_SYMBOL(kernel_getsockname);\n\nint kernel_getpeername(struct socket *sock, struct sockaddr *addr)\n{\n\treturn sock->ops->getname(sock, addr, 1);\n}\nEXPORT_SYMBOL(kernel_getpeername);\n\nint kernel_getsockopt(struct socket *sock, int level, int optname,\n\t\t\tchar *optval, int *optlen)\n{\n\tmm_segment_t oldfs = get_fs();\n\tchar __user *uoptval;\n\tint __user *uoptlen;\n\tint err;\n\n\tuoptval = (char __user __force *) optval;\n\tuoptlen = (int __user __force *) optlen;\n\n\tset_fs(KERNEL_DS);\n\tif (level == SOL_SOCKET)\n\t\terr = sock_getsockopt(sock, level, optname, uoptval, uoptlen);\n\telse\n\t\terr = sock->ops->getsockopt(sock, level, optname, uoptval,\n\t\t\t\t\t    uoptlen);\n\tset_fs(oldfs);\n\treturn err;\n}\nEXPORT_SYMBOL(kernel_getsockopt);\n\nint kernel_setsockopt(struct socket *sock, int level, int optname,\n\t\t\tchar *optval, unsigned int optlen)\n{\n\tmm_segment_t oldfs = get_fs();\n\tchar __user *uoptval;\n\tint err;\n\n\tuoptval = (char __user __force *) optval;\n\n\tset_fs(KERNEL_DS);\n\tif (level == SOL_SOCKET)\n\t\terr = sock_setsockopt(sock, level, optname, uoptval, optlen);\n\telse\n\t\terr = sock->ops->setsockopt(sock, level, optname, uoptval,\n\t\t\t\t\t    optlen);\n\tset_fs(oldfs);\n\treturn err;\n}\nEXPORT_SYMBOL(kernel_setsockopt);\n\nint kernel_sendpage(struct socket *sock, struct page *page, int offset,\n\t\t    size_t size, int flags)\n{\n\tif (sock->ops->sendpage)\n\t\treturn sock->ops->sendpage(sock, page, offset, size, flags);\n\n\treturn sock_no_sendpage(sock, page, offset, size, flags);\n}\nEXPORT_SYMBOL(kernel_sendpage);\n\nint kernel_sendpage_locked(struct sock *sk, struct page *page, int offset,\n\t\t\t   size_t size, int flags)\n{\n\tstruct socket *sock = sk->sk_socket;\n\n\tif (sock->ops->sendpage_locked)\n\t\treturn sock->ops->sendpage_locked(sk, page, offset, size,\n\t\t\t\t\t\t  flags);\n\n\treturn sock_no_sendpage_locked(sk, page, offset, size, flags);\n}\nEXPORT_SYMBOL(kernel_sendpage_locked);\n\nint kernel_sock_shutdown(struct socket *sock, enum sock_shutdown_cmd how)\n{\n\treturn sock->ops->shutdown(sock, how);\n}\nEXPORT_SYMBOL(kernel_sock_shutdown);\n\n/* This routine returns the IP overhead imposed by a socket i.e.\n * the length of the underlying IP header, depending on whether\n * this is an IPv4 or IPv6 socket and the length from IP options turned\n * on at the socket. Assumes that the caller has a lock on the socket.\n */\nu32 kernel_sock_ip_overhead(struct sock *sk)\n{\n\tstruct inet_sock *inet;\n\tstruct ip_options_rcu *opt;\n\tu32 overhead = 0;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct ipv6_pinfo *np;\n\tstruct ipv6_txoptions *optv6 = NULL;\n#endif /* IS_ENABLED(CONFIG_IPV6) */\n\n\tif (!sk)\n\t\treturn overhead;\n\n\tswitch (sk->sk_family) {\n\tcase AF_INET:\n\t\tinet = inet_sk(sk);\n\t\toverhead += sizeof(struct iphdr);\n\t\topt = rcu_dereference_protected(inet->inet_opt,\n\t\t\t\t\t\tsock_owned_by_user(sk));\n\t\tif (opt)\n\t\t\toverhead += opt->opt.optlen;\n\t\treturn overhead;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tnp = inet6_sk(sk);\n\t\toverhead += sizeof(struct ipv6hdr);\n\t\tif (np)\n\t\t\toptv6 = rcu_dereference_protected(np->opt,\n\t\t\t\t\t\t\t  sock_owned_by_user(sk));\n\t\tif (optv6)\n\t\t\toverhead += (optv6->opt_flen + optv6->opt_nflen);\n\t\treturn overhead;\n#endif /* IS_ENABLED(CONFIG_IPV6) */\n\tdefault: /* Returns 0 overhead if the socket is not ipv4 or ipv6 */\n\t\treturn overhead;\n\t}\n}\nEXPORT_SYMBOL(kernel_sock_ip_overhead);\n"], "filenames": ["net/socket.c"], "buggy_code_start_loc": [544], "buggy_code_end_loc": [1175], "fixing_code_start_loc": [544], "fixing_code_end_loc": [1187], "type": "CWE-362", "message": "In net/socket.c in the Linux kernel through 4.17.1, there is a race condition between fchownat and close in cases where they target the same socket file descriptor, related to the sock_close and sockfs_setattr functions. fchownat does not increment the file descriptor reference count, which allows close to set the socket to NULL during fchownat's execution, leading to a NULL pointer dereference and system crash.", "other": {"cve": {"id": "CVE-2018-12232", "sourceIdentifier": "cve@mitre.org", "published": "2018-06-12T12:29:00.210", "lastModified": "2018-10-31T10:30:56.777", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In net/socket.c in the Linux kernel through 4.17.1, there is a race condition between fchownat and close in cases where they target the same socket file descriptor, related to the sock_close and sockfs_setattr functions. fchownat does not increment the file descriptor reference count, which allows close to set the socket to NULL during fchownat's execution, leading to a NULL pointer dereference and system crash."}, {"lang": "es", "value": "En net/socket.c en el kernel de Linux hasta la versi\u00f3n 4.17.1, hay una condici\u00f3n de carrera entre fchownat y close en los casos en los que apuntan al mismo descriptor de archivo socket. Esto est\u00e1 relacionado con las funciones sock_close y sockfs_setattr. fchownat no incrementa el conteo de referencia del descriptor de archivos, lo que permite que close establezca el socket como NULL durante la ejecuci\u00f3n de fchownat lo que conduce a una desreferencia de puntero NULL y a un cierre inesperado del sistema."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.1}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.17.1", "matchCriteriaId": "5CF7338D-D530-4EEA-B1D6-926A91AC72BE"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=6d8c50dcb029872b298eea68cc6209c866fd3e14", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/104453", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:2948", "source": "cve@mitre.org"}, {"url": "https://github.com/torvalds/linux/commit/6d8c50dcb029872b298eea68cc6209c866fd3e14", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lkml.org/lkml/2018/6/5/14", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://patchwork.ozlabs.org/patch/926519/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3752-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3752-2/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3752-3/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/6d8c50dcb029872b298eea68cc6209c866fd3e14"}}