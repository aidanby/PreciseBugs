{"buggy_code": ["# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2023 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport logging\n\nimport cherrypy\nimport humanfriendly\nfrom wtforms import validators, widgets\nfrom wtforms.fields import Field, HiddenField, PasswordField, SelectField, StringField\nfrom wtforms.validators import ValidationError\n\ntry:\n    from wtforms.fields import EmailField  # wtform >=3\nexcept ImportError:\n    from wtforms.fields.html5 import EmailField  # wtform <3\n\nfrom rdiffweb.controller import Controller, flash\nfrom rdiffweb.controller.form import CherryForm\nfrom rdiffweb.core.model import UserObject\nfrom rdiffweb.core.rdw_templating import url_for\nfrom rdiffweb.tools.i18n import gettext_lazy as _\n\n# Define the logger\nlogger = logging.getLogger(__name__)\n\n# Max root directory path length\nMAX_PATH = 260\n\n\nclass SizeField(Field):\n    \"\"\"\n    A text field which stores a file size as GiB or GB format.\n    \"\"\"\n\n    widget = widgets.TextInput()\n\n    def __init__(self, label=None, validators=None, **kwargs):\n        super(SizeField, self).__init__(label, validators, **kwargs)\n\n    def _value(self):\n        if self.raw_data:\n            return ' '.join(self.raw_data)\n        else:\n            return self.data and humanfriendly.format_size(self.data, binary=True) or ''\n\n    def process_formdata(self, valuelist):\n        if valuelist:\n            value_str = ''.join(valuelist)\n            # parse_size doesn't handle locales.this mean we need to\n            # replace ',' by '.' to get parse and prefix number with 0\n            value_str = value_str.replace(',', '.').strip()\n            # a value must start with a number.\n            if value_str.startswith('.'):\n                value_str = '0' + value_str\n            try:\n                self.data = humanfriendly.parse_size(value_str)\n            except humanfriendly.InvalidSize:\n                self.data = None\n                raise ValidationError(self.gettext('Not a valid file size value'))\n\n\nclass UserForm(CherryForm):\n    userid = HiddenField(_('UserID'))\n    username = StringField(\n        _('Username'),\n        validators=[\n            validators.data_required(),\n            validators.length(max=256, message=_('Username too long.')),\n            validators.length(min=3, message=_('Username too short.')),\n            validators.regexp(UserObject.PATTERN_USERNAME, message=_('Must not contain any special characters.')),\n        ],\n    )\n    fullname = StringField(\n        _('Fullname'),\n        validators=[\n            validators.optional(),\n            validators.length(max=256, message=_('Fullname too long.')),\n            validators.regexp(UserObject.PATTERN_FULLNAME, message=_('Must not contain any special characters.')),\n        ],\n    )\n    email = EmailField(\n        _('Email'),\n        validators=[\n            validators.optional(),\n            validators.length(max=256, message=_('Email too long.')),\n            validators.regexp(UserObject.PATTERN_EMAIL, message=_('Must be a valid email address.')),\n        ],\n    )\n    password = PasswordField(\n        _('Password'),\n        validators=[validators.optional()],\n    )\n    mfa = SelectField(\n        _('Two-Factor Authentication (2FA)'),\n        coerce=int,\n        choices=[\n            (UserObject.DISABLED_MFA, _(\"Disabled\")),\n            (UserObject.ENABLED_MFA, _(\"Enabled\")),\n        ],\n        default=UserObject.DISABLED_MFA,\n        description=_(\n            \"When Two-Factor Authentication (2FA) is enabled for a user, a verification code get sent by email when user login from a new location.\"\n        ),\n    )\n    user_root = StringField(\n        _('Root directory'),\n        description=_(\"Absolute path defining the location of the repositories for this user.\"),\n        validators=[\n            validators.length(max=MAX_PATH, message=_('Root directory too long.')),\n        ],\n    )\n    role = SelectField(\n        _('User Role'),\n        coerce=int,\n        choices=[\n            (UserObject.ADMIN_ROLE, _(\"Admin\")),\n            (UserObject.MAINTAINER_ROLE, _(\"Maintainer\")),\n            (UserObject.USER_ROLE, _(\"User\")),\n        ],\n        default=UserObject.USER_ROLE,\n        description=_(\n            \"Admin: may browse and delete everything. Maintainer: may browse and delete their own repo. User: may only browser their own repo.\"\n        ),\n    )\n    report_time_range = SelectField(\n        _('Send Backup report'),\n        choices=[\n            (0, _('Never')),\n            (1, _('Daily')),\n            (7, _('Weekly')),\n            (30, _('Monthly')),\n        ],\n        coerce=int,\n        default='0',\n    )\n    disk_quota = SizeField(\n        _('Disk space'),\n        validators=[validators.optional()],\n        description=_(\"Users disk spaces (in bytes). Set to 0 to remove quota (unlimited).\"),\n    )\n    disk_usage = SizeField(\n        _('Quota Used'),\n        validators=[validators.optional()],\n        description=_(\"Disk spaces (in bytes) used by this user.\"),\n        widget=widgets.HiddenInput(),\n    )\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        # Make quota field readonly if quota is not enabled.\n        self.quota_enabled = len(cherrypy.engine.listeners.get('set_disk_quota', [])) > 0\n        if not self.quota_enabled:\n            self.disk_quota.render_kw = {'readonly': True, 'disabled': True}\n            self.disk_usage.render_kw = {'readonly': True, 'disabled': True}\n        # Add help text for LDAP user\n        cfg = cherrypy.request.app.cfg\n        if cfg.ldap_uri:\n            self.password.description = _('To create an LDAP user, you must leave the password empty.')\n\n    def validate_role(self, field):\n        # Don't allow the user to changes it's \"role\" state.\n        currentuser = cherrypy.request.currentuser\n        if self.username.data == currentuser.username and self.role.data != currentuser.role:\n            raise ValidationError(_('Cannot edit your own role.'))\n\n    def validate_mfa(self, field):\n        # Don't allow the user to changes it's \"mfa\" state.\n        currentuser = cherrypy.request.currentuser\n        if self.username.data == currentuser.username and self.mfa.data != currentuser.mfa:\n            raise ValidationError(_('Cannot change your own two-factor authentication settings.'))\n        if not self.email.data and self.mfa.data:\n            raise ValidationError(_('User email is required to enabled Two-Factor Authentication.'))\n\n    def populate_obj(self, userobj):\n        try:\n            # Save password if defined\n            if self.password.data:\n                userobj.set_password(self.password.data)\n            userobj.role = self.role.data\n            userobj.fullname = self.fullname.data or ''\n            userobj.email = self.email.data or ''\n            userobj.user_root = self.user_root.data\n            userobj.mfa = self.mfa.data\n            userobj.report_time_range = self.report_time_range.data\n            if userobj.user_root:\n                if not userobj.valid_user_root():\n                    flash(_(\"User's root directory %s is not accessible!\") % userobj.user_root, level='error')\n                    logger.warning(\"user's root directory %s is not accessible\" % userobj.user_root)\n                else:\n                    userobj.refresh_repos(delete=True)\n            userobj.commit()\n\n        except Exception as e:\n            userobj.rollback()\n            flash(str(e), level='warning')\n            return False\n\n        # Try to update disk quota if the human readable value changed.\n        # Report error using flash.\n        if self.quota_enabled:\n            new_quota = self.disk_quota.data or 0\n            old_quota = humanfriendly.parse_size(\n                humanfriendly.format_size(self.disk_quota.object_data or 0, binary=True)\n            )\n            if old_quota != new_quota:\n                userobj.disk_quota = new_quota\n                # Setting quota will silently fail. Check if quota was updated.\n                if userobj.disk_quota != new_quota:\n                    flash(_(\"Setting user's quota is not supported\"), level='warning')\n        return True\n\n\nclass EditUserForm(UserForm):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        # Make username field read-only\n        self.username.render_kw = {'readonly': True, 'disabled': True}\n\n        # When editing ourself.\n        currentuser = cherrypy.request.currentuser\n        if self.username.object_data == currentuser.username:\n            # Disable MFA\n            self.mfa.render_kw = {'readonly': True, 'disabled': True}\n            # Disable Role\n            self.role.render_kw = {'readonly': True, 'disabled': True}\n\n    def validate_username(self, field):\n        # Raise an error if username doesn't matches our user object\n        if field.data != field.object_data:\n            raise ValidationError(_('Cannot change username of and existing user.'))\n\n\nclass DeleteUserForm(CherryForm):\n    username = StringField(_('Username'), validators=[validators.data_required()])\n\n\n@cherrypy.tools.is_admin()\nclass AdminUsersPage(Controller):\n    \"\"\"\n    Administration pages. Allow to manage users database.\n    \"\"\"\n\n    @cherrypy.expose\n    def index(self):\n        # Build users page\n        form = UserForm()\n        return self._compile_template(\n            \"admin_users.html\",\n            form=form,\n            users=UserObject.query.all(),\n            ldap_enabled=self.app.cfg.ldap_uri,\n        )\n\n    @cherrypy.expose()\n    def new(self, **kwargs):\n        form = UserForm()\n        if form.is_submitted():\n            if form.validate():\n                try:\n                    user = UserObject.add_user(form.username.data)\n                except Exception as e:\n                    flash(str(e), level='error')\n                else:\n                    if form.populate_obj(user):\n                        flash(_(\"User added successfully.\"))\n                        raise cherrypy.HTTPRedirect(url_for('admin', 'users'))\n            else:\n                flash(form.error_message, level='error')\n        return self._compile_template(\"admin_user_new.html\", form=form)\n\n    @cherrypy.expose()\n    def edit(self, username_vpath, **kwargs):\n        user = UserObject.get_user(username_vpath)\n        if not user:\n            raise cherrypy.HTTPError(400, _(\"User %s doesn't exists\") % username_vpath)\n        form = EditUserForm(obj=user)\n        if form.is_submitted():\n            if form.validate():\n                if form.populate_obj(user):\n                    flash(_(\"User information modified successfully.\"))\n                    raise cherrypy.HTTPRedirect(url_for('admin', 'users'))\n            else:\n                flash(form.error_message, level='error')\n        return self._compile_template(\"admin_user_edit.html\", form=form)\n\n    @cherrypy.expose()\n    def delete(self, username=None, **kwargs):\n        # Validate form method.\n        form = DeleteUserForm()\n        if not form.is_submitted():\n            raise cherrypy.HTTPError(405)\n        # Get user\n        user = UserObject.get_user(username)\n        if not user:\n            raise cherrypy.HTTPError(400, _(\"User %s doesn't exists\") % username)\n        if form.validate():\n            if form.username.data == self.app.currentuser.username:\n                raise cherrypy.HTTPError(400, _(\"You cannot remove your own account!\"))\n            try:\n                user.delete()\n                user.commit()\n                flash(_(\"User account removed.\"))\n            except Exception as e:\n                user.rollback()\n                flash(str(e), level='error')\n        else:\n            flash(form.error_message, level='error')\n        raise cherrypy.HTTPRedirect(url_for('admin', 'users'))\n\n\n# TODO Allow configuration of notification settigns\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2023 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nPlugins to allows users to configure the SSH keys using the web\ninterface. Basically it's a UI for `~/.ssh/authorized_keys`. For this\nplugin to work properly, the users home directory need to match a real\nuser home.\n\"\"\"\n\nimport logging\n\nimport cherrypy\nfrom wtforms import validators\nfrom wtforms.fields import HiddenField, StringField\nfrom wtforms.validators import ValidationError\nfrom wtforms.widgets.core import TextArea\n\nfrom rdiffweb.controller import Controller, flash\nfrom rdiffweb.controller.dispatch import restapi\nfrom rdiffweb.controller.filter_authorization import is_maintainer\nfrom rdiffweb.controller.form import CherryForm\nfrom rdiffweb.core import authorizedkeys\nfrom rdiffweb.core.model import DuplicateSSHKeyError\nfrom rdiffweb.tools.i18n import gettext_lazy as _\n\n_logger = logging.getLogger(__name__)\n\n\ndef validate_key(unused_form, field):\n    \"\"\"Custom validator to check the SSH Key.\"\"\"\n    try:\n        authorizedkeys.check_publickey(field.data)\n    except ValueError:\n        raise ValidationError(_(\"Invalid SSH key.\"))\n\n\nclass SshForm(CherryForm):\n    action = HiddenField(default=\"add\")\n    title = StringField(\n        _('Title'),\n        description=_('The title is an optional description to identify the key. e.g.: bob@thinkpad-t530'),\n        validators=[\n            validators.data_required(),\n            validators.length(\n                max=256,\n                message=_('Title too long.'),\n            ),\n        ],\n    )\n    key = StringField(\n        _('Key'),\n        widget=TextArea(),\n        description=_(\n            \"Enter a SSH public key. It should start with 'ssh-dss', 'ssh-ed25519', 'ssh-rsa', 'ecdsa-sha2-nistp256', 'ecdsa-sha2-nistp384' or 'ecdsa-sha2-nistp521'.\"\n        ),\n        validators=[validators.data_required(), validate_key],\n    )\n\n    def is_submitted(self):\n        # Validate only if action is set_profile_info\n        return super().is_submitted() and self.action.data == 'add'\n\n    def populate_obj(self, userobj):\n        try:\n            userobj.add_authorizedkey(key=self.key.data, comment=self.title.data)\n            userobj.commit()\n            return True\n        except DuplicateSSHKeyError as e:\n            userobj.rollback()\n            flash(str(e), level='error')\n            _logger.warning(\"trying to add duplicate ssh key\")\n            return False\n        except Exception:\n            userobj.rollback()\n            flash(_(\"Unknown error while adding the SSH Key\"), level='error')\n            _logger.warning(\"error adding ssh key\", exc_info=1)\n            return False\n\n\nclass DeleteSshForm(CherryForm):\n    action = HiddenField(default=\"delete\")\n    fingerprint = StringField('Fingerprint', validators=[validators.data_required()])\n\n    def is_submitted(self):\n        # Validate only if action is set_profile_info\n        return super().is_submitted() and self.action.data == 'delete'\n\n    def populate_obj(self, userobj):\n        is_maintainer()\n        try:\n            userobj.delete_authorizedkey(self.fingerprint.data)\n            userobj.commit()\n            return True\n        except Exception:\n            userobj.rollback()\n            if hasattr(cherrypy.serving, 'session'):\n                flash(_(\"Unknown error while removing the SSH Key\"), level='error')\n            _logger.warning(\"error removing ssh key\", exc_info=1)\n            return False\n\n\nclass PagePrefSshKeys(Controller):\n    @cherrypy.expose\n    def default(self, **kwargs):\n        # Handle action\n        add_form = SshForm()\n        delete_form = DeleteSshForm()\n        if not self.app.cfg.disable_ssh_keys:\n            if add_form.is_submitted():\n                if add_form.validate():\n                    if add_form.populate_obj(self.app.currentuser):\n                        raise cherrypy.HTTPRedirect(\"\")\n                else:\n                    flash(add_form.error_message, level='warning')\n            elif delete_form.is_submitted():\n                if delete_form.validate():\n                    if delete_form.populate_obj(self.app.currentuser):\n                        raise cherrypy.HTTPRedirect(\"\")\n                else:\n                    flash(delete_form.error_message, level='warning')\n\n        # Get SSH keys if file exists.\n        params = {\n            'disable_ssh_keys': self.app.cfg.disable_ssh_keys,\n            'form': add_form,\n        }\n        try:\n            params[\"sshkeys\"] = [\n                {'title': key.comment, 'fingerprint': key.fingerprint} for key in self.app.currentuser.authorizedkeys\n            ]\n        except IOError:\n            params[\"sshkeys\"] = []\n            flash(_(\"Failed to get SSH keys\"), level='error')\n            _logger.warning(\"error reading SSH keys\", exc_info=1)\n\n        return self._compile_template(\"prefs_sshkeys.html\", **params)\n\n\n@restapi()\n@cherrypy.tools.json_out()\nclass ApiSshKeys(Controller):\n    @cherrypy.expose\n    def list(self):\n        return [{'title': key.comment, 'fingerprint': key.fingerprint} for key in self.app.currentuser.authorizedkeys]\n\n    @cherrypy.expose\n    def get(self, fingerprint):\n        for key in self.app.currentuser.authorizedkeys:\n            if key.fingerprint == fingerprint:\n                return {'title': key.comment, 'fingerprint': key.fingerprint}\n        raise cherrypy.HTTPError(404)\n\n    @cherrypy.expose\n    def delete(self, fingerprint):\n        form = DeleteSshForm(fingerprint=fingerprint)\n        if form.validate():\n            form.populate_obj(self.app.currentuser)\n            return {}\n        else:\n            raise cherrypy.HTTPError(400, form.error_message)\n\n    @cherrypy.expose\n    def post(self, **kwargs):\n        form = SshForm()\n        if form.validate():\n            # Create the SSH Key\n            userobj = self.app.currentuser\n            try:\n                userobj.add_authorizedkey(key=form.key.data, comment=form.title.data)\n                userobj.commit()\n            except DuplicateSSHKeyError as e:\n                userobj.rollback()\n                raise cherrypy.HTTPError(400, str(e))\n            return kwargs\n        else:\n            raise cherrypy.HTTPError(400, form.error_message)\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2023 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\nimport logging\n\nimport cherrypy\nfrom wtforms.fields import DateTimeField, StringField, SubmitField\nfrom wtforms.validators import DataRequired, Length, Optional\n\nfrom rdiffweb.controller import Controller, flash\nfrom rdiffweb.controller.filter_authorization import is_maintainer\nfrom rdiffweb.controller.form import CherryForm\nfrom rdiffweb.core.model import Token\nfrom rdiffweb.tools.i18n import gettext_lazy as _\n\ntry:\n    # wtform>=3\n    from wtforms.widgets import DateInput\nexcept ImportError:\n    # wtform<3\n    from wtforms.widgets.html5 import DateInput\n\nlogger = logging.getLogger(__name__)\n\n\nclass TokenForm(CherryForm):\n    name = StringField(\n        _('Token name'),\n        description=_(\n            'Used only to identify the purpose of the token. For example, the application that uses the token.'\n        ),\n        validators=[\n            DataRequired(),\n            Length(max=256, message=_('Token name too long')),\n        ],\n    )\n    expiration = DateTimeField(\n        _('Expiration date'),\n        description=_(\n            'Allows the creation of a temporary token by defining an expiration date. Leave empty to keep the token forever.'\n        ),\n        render_kw={\n            \"placeholder\": _('YYYY-MM-DD'),\n        },\n        format=\"%Y-%m-%d\",\n        widget=DateInput(),\n        validators=[Optional()],\n    )\n    add_access_token = SubmitField(_('Create access token'))\n\n    def is_submitted(self):\n        # Validate only if action is set_profile_info\n        return super().is_submitted() and self.add_access_token.data\n\n    def populate_obj(self, userobj):\n        try:\n            token = userobj.add_access_token(self.name.data, self.expiration.data)\n            userobj.commit()\n            flash(\n                _(\n                    \"Your new personal access token has been created.\\n\"\n                    \"Make sure to save it - you won't be able to access it again.\\n\"\n                    \"%s\"\n                )\n                % token,\n                level='info',\n            )\n            return True\n        except ValueError as e:\n            userobj.rollback()\n            flash(str(e), level='warning')\n            return False\n        except Exception:\n            userobj.rollback()\n            logger.exception(\"error adding access token: %s, %s\" % (self.name.data, self.expiration.data))\n            flash(_(\"Unknown error while adding the access token.\"), level='error')\n            return False\n\n\nclass DeleteTokenForm(CherryForm):\n    name = StringField(validators=[DataRequired()])\n    revoke = SubmitField(_('Revoke'))\n\n    def is_submitted(self):\n        # Validate only if action is set_profile_info\n        return super().is_submitted() and self.revoke.data\n\n    def populate_obj(self, userobj):\n        is_maintainer()\n        try:\n            userobj.delete_access_token(self.name.data)\n            flash(_('The access token has been successfully deleted.'), level='success')\n            return True\n        except ValueError as e:\n            userobj.rollback()\n            flash(str(e), level='warning')\n            return False\n        except Exception:\n            userobj.rollback()\n            logger.exception(\"error removing access token: %s\" % self.name.data)\n            flash(_(\"Unknown error while removing the access token.\"), level='error')\n            return False\n\n\nclass PagePrefTokens(Controller):\n    @cherrypy.expose\n    def default(self, **kwargs):\n        form = TokenForm()\n        delete_form = DeleteTokenForm()\n        if form.is_submitted():\n            if form.validate():\n                if form.populate_obj(self.app.currentuser):\n                    raise cherrypy.HTTPRedirect(\"\")\n            else:\n                flash(form.error_message, level='error')\n        elif delete_form.is_submitted():\n            if delete_form.validate():\n                if delete_form.populate_obj(self.app.currentuser):\n                    raise cherrypy.HTTPRedirect(\"\")\n            else:\n                flash(delete_form.error_message, level='error')\n        params = {\n            'form': form,\n            'tokens': Token.query.filter(Token.userid == self.app.currentuser.userid),\n        }\n        return self._compile_template(\"prefs_tokens.html\", **params)\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2023 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport logging\n\nimport cherrypy\nimport humanfriendly\nfrom wtforms import validators, widgets\nfrom wtforms.fields import Field, HiddenField, PasswordField, SelectField, StringField\nfrom wtforms.validators import ValidationError\n\ntry:\n    from wtforms.fields import EmailField  # wtform >=3\nexcept ImportError:\n    from wtforms.fields.html5 import EmailField  # wtform <3\n\nfrom rdiffweb.controller import Controller, flash\nfrom rdiffweb.controller.form import CherryForm\nfrom rdiffweb.core.model import UserObject\nfrom rdiffweb.core.rdw_templating import url_for\nfrom rdiffweb.tools.i18n import gettext_lazy as _\n\n# Define the logger\nlogger = logging.getLogger(__name__)\n\n# Max root directory path length\nMAX_PATH = 260\n\n\nclass SizeField(Field):\n    \"\"\"\n    A text field which stores a file size as GiB or GB format.\n    \"\"\"\n\n    widget = widgets.TextInput()\n\n    def __init__(self, label=None, validators=None, **kwargs):\n        super(SizeField, self).__init__(label, validators, **kwargs)\n\n    def _value(self):\n        if self.raw_data:\n            return ' '.join(self.raw_data)\n        else:\n            return self.data and humanfriendly.format_size(self.data, binary=True) or ''\n\n    def process_formdata(self, valuelist):\n        if valuelist:\n            value_str = ''.join(valuelist)\n            # parse_size doesn't handle locales.this mean we need to\n            # replace ',' by '.' to get parse and prefix number with 0\n            value_str = value_str.replace(',', '.').strip()\n            # a value must start with a number.\n            if value_str.startswith('.'):\n                value_str = '0' + value_str\n            try:\n                self.data = humanfriendly.parse_size(value_str)\n            except humanfriendly.InvalidSize:\n                self.data = None\n                raise ValidationError(self.gettext('Not a valid file size value'))\n\n\nclass UserForm(CherryForm):\n    userid = HiddenField(_('UserID'))\n    username = StringField(\n        _('Username'),\n        validators=[\n            validators.data_required(),\n            validators.length(max=256, message=_('Username too long.')),\n            validators.length(min=3, message=_('Username too short.')),\n            validators.regexp(UserObject.PATTERN_USERNAME, message=_('Must not contain any special characters.')),\n        ],\n    )\n    fullname = StringField(\n        _('Fullname'),\n        validators=[\n            validators.optional(),\n            validators.length(max=256, message=_('Fullname too long.')),\n            validators.regexp(UserObject.PATTERN_FULLNAME, message=_('Must not contain any special characters.')),\n        ],\n    )\n    email = EmailField(\n        _('Email'),\n        validators=[\n            validators.optional(),\n            validators.length(max=256, message=_('Email too long.')),\n            validators.regexp(UserObject.PATTERN_EMAIL, message=_('Must be a valid email address.')),\n        ],\n    )\n    password = PasswordField(\n        _('Password'),\n        validators=[validators.optional()],\n    )\n    mfa = SelectField(\n        _('Two-Factor Authentication (2FA)'),\n        coerce=int,\n        choices=[\n            (UserObject.DISABLED_MFA, _(\"Disabled\")),\n            (UserObject.ENABLED_MFA, _(\"Enabled\")),\n        ],\n        default=UserObject.DISABLED_MFA,\n        description=_(\n            \"When Two-Factor Authentication (2FA) is enabled for a user, a verification code get sent by email when user login from a new location.\"\n        ),\n    )\n    user_root = StringField(\n        _('Root directory'),\n        description=_(\"Absolute path defining the location of the repositories for this user.\"),\n        validators=[\n            validators.length(max=MAX_PATH, message=_('Root directory too long.')),\n        ],\n    )\n    role = SelectField(\n        _('User Role'),\n        coerce=int,\n        choices=[\n            (UserObject.ADMIN_ROLE, _(\"Admin\")),\n            (UserObject.MAINTAINER_ROLE, _(\"Maintainer\")),\n            (UserObject.USER_ROLE, _(\"User\")),\n        ],\n        default=UserObject.USER_ROLE,\n        description=_(\n            \"Admin: may browse and delete everything. Maintainer: may browse and delete their own repo. User: may only browser their own repo.\"\n        ),\n    )\n    report_time_range = SelectField(\n        _('Send Backup report'),\n        choices=[\n            (0, _('Never')),\n            (1, _('Daily')),\n            (7, _('Weekly')),\n            (30, _('Monthly')),\n        ],\n        coerce=int,\n        default='0',\n    )\n    disk_quota = SizeField(\n        _('Disk space'),\n        validators=[validators.optional()],\n        description=_(\"Users disk spaces (in bytes). Set to 0 to remove quota (unlimited).\"),\n    )\n    disk_usage = SizeField(\n        _('Quota Used'),\n        validators=[validators.optional()],\n        description=_(\"Disk spaces (in bytes) used by this user.\"),\n        widget=widgets.HiddenInput(),\n    )\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        # Make quota field readonly if quota is not enabled.\n        self.quota_enabled = len(cherrypy.engine.listeners.get('set_disk_quota', [])) > 0\n        if not self.quota_enabled:\n            self.disk_quota.render_kw = {'readonly': True, 'disabled': True}\n            self.disk_usage.render_kw = {'readonly': True, 'disabled': True}\n        # Add help text for LDAP user\n        cfg = cherrypy.request.app.cfg\n        if cfg.ldap_uri:\n            self.password.description = _('To create an LDAP user, you must leave the password empty.')\n\n    def validate_role(self, field):\n        # Don't allow the user to changes it's \"role\" state.\n        currentuser = cherrypy.request.currentuser\n        if self.username.data == currentuser.username and self.role.data != currentuser.role:\n            raise ValidationError(_('Cannot edit your own role.'))\n\n    def validate_mfa(self, field):\n        # Don't allow the user to changes it's \"mfa\" state.\n        currentuser = cherrypy.request.currentuser\n        if self.username.data == currentuser.username and self.mfa.data != currentuser.mfa:\n            raise ValidationError(_('Cannot change your own two-factor authentication settings.'))\n        if not self.email.data and self.mfa.data:\n            raise ValidationError(_('User email is required to enabled Two-Factor Authentication.'))\n\n    def populate_obj(self, userobj):\n        try:\n            # Save password if defined\n            if self.password.data:\n                userobj.set_password(self.password.data)\n            userobj.role = self.role.data\n            userobj.fullname = self.fullname.data or ''\n            userobj.email = self.email.data or ''\n            userobj.user_root = self.user_root.data\n            userobj.mfa = self.mfa.data\n            userobj.report_time_range = self.report_time_range.data\n            if userobj.user_root:\n                if not userobj.valid_user_root():\n                    flash(_(\"User's root directory %s is not accessible!\") % userobj.user_root, level='error')\n                    logger.warning(\"user's root directory %s is not accessible\" % userobj.user_root)\n                else:\n                    userobj.refresh_repos(delete=True)\n            userobj.commit()\n\n        except Exception as e:\n            userobj.rollback()\n            flash(str(e), level='warning')\n            return False\n\n        # Try to update disk quota if the human readable value changed.\n        # Report error using flash.\n        if self.quota_enabled:\n            new_quota = self.disk_quota.data or 0\n            old_quota = humanfriendly.parse_size(\n                humanfriendly.format_size(self.disk_quota.object_data or 0, binary=True)\n            )\n            if old_quota != new_quota:\n                userobj.disk_quota = new_quota\n                # Setting quota will silently fail. Check if quota was updated.\n                if userobj.disk_quota != new_quota:\n                    flash(_(\"Setting user's quota is not supported\"), level='warning')\n        return True\n\n\nclass EditUserForm(UserForm):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        # Make username field read-only\n        self.username.render_kw = {'readonly': True, 'disabled': True}\n\n        # When editing ourself.\n        currentuser = cherrypy.request.currentuser\n        if self.username.object_data == currentuser.username:\n            # Disable MFA\n            self.mfa.render_kw = {'readonly': True, 'disabled': True}\n            # Disable Role\n            self.role.render_kw = {'readonly': True, 'disabled': True}\n\n    def validate_username(self, field):\n        # Raise an error if username doesn't matches our user object\n        if field.data != field.object_data:\n            raise ValidationError(_('Cannot change username of and existing user.'))\n\n\nclass DeleteUserForm(CherryForm):\n    username = StringField(_('Username'), validators=[validators.data_required()])\n\n\n@cherrypy.tools.is_admin()\nclass AdminUsersPage(Controller):\n    \"\"\"\n    Administration pages. Allow to manage users database.\n    \"\"\"\n\n    @cherrypy.expose\n    def index(self):\n        # Build users page\n        form = UserForm()\n        return self._compile_template(\n            \"admin_users.html\",\n            form=form,\n            users=UserObject.query.all(),\n            ldap_enabled=self.app.cfg.ldap_uri,\n        )\n\n    @cherrypy.expose\n    @cherrypy.tools.ratelimit(methods=['POST'])\n    def new(self, **kwargs):\n        form = UserForm()\n        if form.is_submitted():\n            if form.validate():\n                try:\n                    user = UserObject.add_user(form.username.data)\n                except Exception as e:\n                    flash(str(e), level='error')\n                else:\n                    if form.populate_obj(user):\n                        flash(_(\"User added successfully.\"))\n                        raise cherrypy.HTTPRedirect(url_for('admin', 'users'))\n            else:\n                flash(form.error_message, level='error')\n        return self._compile_template(\"admin_user_new.html\", form=form)\n\n    @cherrypy.expose\n    def edit(self, username_vpath, **kwargs):\n        user = UserObject.get_user(username_vpath)\n        if not user:\n            raise cherrypy.HTTPError(400, _(\"User %s doesn't exists\") % username_vpath)\n        form = EditUserForm(obj=user)\n        if form.is_submitted():\n            if form.validate():\n                if form.populate_obj(user):\n                    flash(_(\"User information modified successfully.\"))\n                    raise cherrypy.HTTPRedirect(url_for('admin', 'users'))\n            else:\n                flash(form.error_message, level='error')\n        return self._compile_template(\"admin_user_edit.html\", form=form)\n\n    @cherrypy.expose\n    def delete(self, username=None, **kwargs):\n        # Validate form method.\n        form = DeleteUserForm()\n        if not form.is_submitted():\n            raise cherrypy.HTTPError(405)\n        # Get user\n        user = UserObject.get_user(username)\n        if not user:\n            raise cherrypy.HTTPError(400, _(\"User %s doesn't exists\") % username)\n        if form.validate():\n            if form.username.data == self.app.currentuser.username:\n                raise cherrypy.HTTPError(400, _(\"You cannot remove your own account!\"))\n            try:\n                user.delete()\n                user.commit()\n                flash(_(\"User account removed.\"))\n            except Exception as e:\n                user.rollback()\n                flash(str(e), level='error')\n        else:\n            flash(form.error_message, level='error')\n        raise cherrypy.HTTPRedirect(url_for('admin', 'users'))\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2023 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nPlugins to allows users to configure the SSH keys using the web\ninterface. Basically it's a UI for `~/.ssh/authorized_keys`. For this\nplugin to work properly, the users home directory need to match a real\nuser home.\n\"\"\"\n\nimport logging\n\nimport cherrypy\nfrom wtforms import validators\nfrom wtforms.fields import HiddenField, StringField\nfrom wtforms.validators import ValidationError\nfrom wtforms.widgets.core import TextArea\n\nfrom rdiffweb.controller import Controller, flash\nfrom rdiffweb.controller.dispatch import restapi\nfrom rdiffweb.controller.filter_authorization import is_maintainer\nfrom rdiffweb.controller.form import CherryForm\nfrom rdiffweb.core import authorizedkeys\nfrom rdiffweb.core.model import DuplicateSSHKeyError\nfrom rdiffweb.tools.i18n import gettext_lazy as _\n\n_logger = logging.getLogger(__name__)\n\n\ndef validate_key(unused_form, field):\n    \"\"\"Custom validator to check the SSH Key.\"\"\"\n    try:\n        authorizedkeys.check_publickey(field.data)\n    except ValueError:\n        raise ValidationError(_(\"Invalid SSH key.\"))\n\n\nclass SshForm(CherryForm):\n    action = HiddenField(default=\"add\")\n    title = StringField(\n        _('Title'),\n        description=_('The title is an optional description to identify the key. e.g.: bob@thinkpad-t530'),\n        validators=[\n            validators.data_required(),\n            validators.length(\n                max=256,\n                message=_('Title too long.'),\n            ),\n        ],\n    )\n    key = StringField(\n        _('Key'),\n        widget=TextArea(),\n        description=_(\n            \"Enter a SSH public key. It should start with 'ssh-dss', 'ssh-ed25519', 'ssh-rsa', 'ecdsa-sha2-nistp256', 'ecdsa-sha2-nistp384' or 'ecdsa-sha2-nistp521'.\"\n        ),\n        validators=[validators.data_required(), validate_key],\n    )\n\n    def is_submitted(self):\n        # Validate only if action is set_profile_info\n        return super().is_submitted() and self.action.data == 'add'\n\n    def populate_obj(self, userobj):\n        try:\n            userobj.add_authorizedkey(key=self.key.data, comment=self.title.data)\n            userobj.commit()\n            return True\n        except DuplicateSSHKeyError as e:\n            userobj.rollback()\n            flash(str(e), level='error')\n            _logger.warning(\"trying to add duplicate ssh key\")\n            return False\n        except Exception:\n            userobj.rollback()\n            flash(_(\"Unknown error while adding the SSH Key\"), level='error')\n            _logger.warning(\"error adding ssh key\", exc_info=1)\n            return False\n\n\nclass DeleteSshForm(CherryForm):\n    action = HiddenField(default=\"delete\")\n    fingerprint = StringField('Fingerprint', validators=[validators.data_required()])\n\n    def is_submitted(self):\n        # Validate only if action is set_profile_info\n        return super().is_submitted() and self.action.data == 'delete'\n\n    def populate_obj(self, userobj):\n        is_maintainer()\n        try:\n            userobj.delete_authorizedkey(self.fingerprint.data)\n            userobj.commit()\n            return True\n        except Exception:\n            userobj.rollback()\n            if hasattr(cherrypy.serving, 'session'):\n                flash(_(\"Unknown error while removing the SSH Key\"), level='error')\n            _logger.warning(\"error removing ssh key\", exc_info=1)\n            return False\n\n\nclass PagePrefSshKeys(Controller):\n    @cherrypy.expose\n    @cherrypy.tools.ratelimit(methods=['POST'])\n    def default(self, **kwargs):\n        # Handle action\n        add_form = SshForm()\n        delete_form = DeleteSshForm()\n        if not self.app.cfg.disable_ssh_keys:\n            if add_form.is_submitted():\n                if add_form.validate():\n                    if add_form.populate_obj(self.app.currentuser):\n                        raise cherrypy.HTTPRedirect(\"\")\n                else:\n                    flash(add_form.error_message, level='warning')\n            elif delete_form.is_submitted():\n                if delete_form.validate():\n                    if delete_form.populate_obj(self.app.currentuser):\n                        raise cherrypy.HTTPRedirect(\"\")\n                else:\n                    flash(delete_form.error_message, level='warning')\n\n        # Get SSH keys if file exists.\n        params = {\n            'disable_ssh_keys': self.app.cfg.disable_ssh_keys,\n            'form': add_form,\n        }\n        try:\n            params[\"sshkeys\"] = [\n                {'title': key.comment, 'fingerprint': key.fingerprint} for key in self.app.currentuser.authorizedkeys\n            ]\n        except IOError:\n            params[\"sshkeys\"] = []\n            flash(_(\"Failed to get SSH keys\"), level='error')\n            _logger.warning(\"error reading SSH keys\", exc_info=1)\n\n        return self._compile_template(\"prefs_sshkeys.html\", **params)\n\n\n@restapi()\n@cherrypy.tools.json_out()\nclass ApiSshKeys(Controller):\n    @cherrypy.expose\n    def list(self):\n        return [{'title': key.comment, 'fingerprint': key.fingerprint} for key in self.app.currentuser.authorizedkeys]\n\n    @cherrypy.expose\n    def get(self, fingerprint):\n        for key in self.app.currentuser.authorizedkeys:\n            if key.fingerprint == fingerprint:\n                return {'title': key.comment, 'fingerprint': key.fingerprint}\n        raise cherrypy.HTTPError(404)\n\n    @cherrypy.expose\n    def delete(self, fingerprint):\n        form = DeleteSshForm(fingerprint=fingerprint)\n        if form.validate():\n            form.populate_obj(self.app.currentuser)\n            return {}\n        else:\n            raise cherrypy.HTTPError(400, form.error_message)\n\n    @cherrypy.expose\n    def post(self, **kwargs):\n        form = SshForm()\n        if form.validate():\n            # Create the SSH Key\n            userobj = self.app.currentuser\n            try:\n                userobj.add_authorizedkey(key=form.key.data, comment=form.title.data)\n                userobj.commit()\n            except DuplicateSSHKeyError as e:\n                userobj.rollback()\n                raise cherrypy.HTTPError(400, str(e))\n            return kwargs\n        else:\n            raise cherrypy.HTTPError(400, form.error_message)\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2023 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\nimport logging\n\nimport cherrypy\nfrom wtforms.fields import DateTimeField, StringField, SubmitField\nfrom wtforms.validators import DataRequired, Length, Optional\n\nfrom rdiffweb.controller import Controller, flash\nfrom rdiffweb.controller.filter_authorization import is_maintainer\nfrom rdiffweb.controller.form import CherryForm\nfrom rdiffweb.core.model import Token\nfrom rdiffweb.tools.i18n import gettext_lazy as _\n\ntry:\n    # wtform>=3\n    from wtforms.widgets import DateInput\nexcept ImportError:\n    # wtform<3\n    from wtforms.widgets.html5 import DateInput\n\nlogger = logging.getLogger(__name__)\n\n\nclass TokenForm(CherryForm):\n    name = StringField(\n        _('Token name'),\n        description=_(\n            'Used only to identify the purpose of the token. For example, the application that uses the token.'\n        ),\n        validators=[\n            DataRequired(),\n            Length(max=256, message=_('Token name too long')),\n        ],\n    )\n    expiration = DateTimeField(\n        _('Expiration date'),\n        description=_(\n            'Allows the creation of a temporary token by defining an expiration date. Leave empty to keep the token forever.'\n        ),\n        render_kw={\n            \"placeholder\": _('YYYY-MM-DD'),\n        },\n        format=\"%Y-%m-%d\",\n        widget=DateInput(),\n        validators=[Optional()],\n    )\n    add_access_token = SubmitField(_('Create access token'))\n\n    def is_submitted(self):\n        # Validate only if action is set_profile_info\n        return super().is_submitted() and self.add_access_token.data\n\n    def populate_obj(self, userobj):\n        try:\n            token = userobj.add_access_token(self.name.data, self.expiration.data)\n            userobj.commit()\n            flash(\n                _(\n                    \"Your new personal access token has been created.\\n\"\n                    \"Make sure to save it - you won't be able to access it again.\\n\"\n                    \"%s\"\n                )\n                % token,\n                level='info',\n            )\n            return True\n        except ValueError as e:\n            userobj.rollback()\n            flash(str(e), level='warning')\n            return False\n        except Exception:\n            userobj.rollback()\n            logger.exception(\"error adding access token: %s, %s\" % (self.name.data, self.expiration.data))\n            flash(_(\"Unknown error while adding the access token.\"), level='error')\n            return False\n\n\nclass DeleteTokenForm(CherryForm):\n    name = StringField(validators=[DataRequired()])\n    revoke = SubmitField(_('Revoke'))\n\n    def is_submitted(self):\n        # Validate only if action is set_profile_info\n        return super().is_submitted() and self.revoke.data\n\n    def populate_obj(self, userobj):\n        is_maintainer()\n        try:\n            userobj.delete_access_token(self.name.data)\n            flash(_('The access token has been successfully deleted.'), level='success')\n            return True\n        except ValueError as e:\n            userobj.rollback()\n            flash(str(e), level='warning')\n            return False\n        except Exception:\n            userobj.rollback()\n            logger.exception(\"error removing access token: %s\" % self.name.data)\n            flash(_(\"Unknown error while removing the access token.\"), level='error')\n            return False\n\n\nclass PagePrefTokens(Controller):\n    @cherrypy.expose\n    @cherrypy.tools.ratelimit(methods=['POST'])\n    def default(self, **kwargs):\n        form = TokenForm()\n        delete_form = DeleteTokenForm()\n        if form.is_submitted():\n            if form.validate():\n                if form.populate_obj(self.app.currentuser):\n                    raise cherrypy.HTTPRedirect(\"\")\n            else:\n                flash(form.error_message, level='error')\n        elif delete_form.is_submitted():\n            if delete_form.validate():\n                if delete_form.populate_obj(self.app.currentuser):\n                    raise cherrypy.HTTPRedirect(\"\")\n            else:\n                flash(delete_form.error_message, level='error')\n        params = {\n            'form': form,\n            'tokens': Token.query.filter(Token.userid == self.app.currentuser.userid),\n        }\n        return self._compile_template(\"prefs_tokens.html\", **params)\n"], "filenames": ["rdiffweb/controller/page_admin_users.py", "rdiffweb/controller/page_pref_sshkeys.py", "rdiffweb/controller/page_pref_tokens.py"], "buggy_code_start_loc": [268, 117, 121], "buggy_code_end_loc": [326, 117, 121], "fixing_code_start_loc": [268, 118, 122], "fixing_code_end_loc": [323, 119, 123], "type": "CWE-770", "message": "Allocation of Resources Without Limits or Throttling in GitHub repository ikus060/rdiffweb prior to 2.8.4.", "other": {"cve": {"id": "CVE-2023-5289", "sourceIdentifier": "security@huntr.dev", "published": "2023-09-29T14:15:11.323", "lastModified": "2023-10-02T18:13:04.227", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Allocation of Resources Without Limits or Throttling in GitHub repository ikus060/rdiffweb prior to 2.8.4."}, {"lang": "es", "value": "Asignaci\u00f3n de Recursos sin L\u00edmites ni Limitaciones en el repositorio de GitHub ikus060/rdiffweb anterior a 2.8.4."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 4.2}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ikus-soft:rdiffweb:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.8.4", "matchCriteriaId": "69B9A770-FE7D-4F6E-BEC7-ACE2BA614CBD"}]}]}], "references": [{"url": "https://github.com/ikus060/rdiffweb/commit/06f89b43469aae70e8833e55192721523f86c5a2", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/8d0e0804-d3fd-49fe-bfa4-7a91135767ce", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ikus060/rdiffweb/commit/06f89b43469aae70e8833e55192721523f86c5a2"}}