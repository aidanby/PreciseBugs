{"buggy_code": ["/* DVB USB compliant linux driver for Conexant USB reference design.\n *\n * The Conexant reference design I saw on their website was only for analogue\n * capturing (using the cx25842). The box I took to write this driver (reverse\n * engineered) is the one labeled Medion MD95700. In addition to the cx25842\n * for analogue capturing it also has a cx22702 DVB-T demodulator on the main\n * board. Besides it has a atiremote (X10) and a USB2.0 hub onboard.\n *\n * Maybe it is a little bit premature to call this driver cxusb, but I assume\n * the USB protocol is identical or at least inherited from the reference\n * design, so it can be reused for the \"analogue-only\" device (if it will\n * appear at all).\n *\n * TODO: Use the cx25840-driver for the analogue part\n *\n * Copyright (C) 2005 Patrick Boettcher (patrick.boettcher@posteo.de)\n * Copyright (C) 2006 Michael Krufky (mkrufky@linuxtv.org)\n * Copyright (C) 2006, 2007 Chris Pascoe (c.pascoe@itee.uq.edu.au)\n *\n *   This program is free software; you can redistribute it and/or modify it\n *   under the terms of the GNU General Public License as published by the Free\n *   Software Foundation, version 2.\n *\n * see Documentation/dvb/README.dvb-usb for more information\n */\n#include <media/tuner.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n\n#include \"cxusb.h\"\n\n#include \"cx22702.h\"\n#include \"lgdt330x.h\"\n#include \"mt352.h\"\n#include \"mt352_priv.h\"\n#include \"zl10353.h\"\n#include \"tuner-xc2028.h\"\n#include \"tuner-simple.h\"\n#include \"mxl5005s.h\"\n#include \"max2165.h\"\n#include \"dib7000p.h\"\n#include \"dib0070.h\"\n#include \"lgs8gxx.h\"\n#include \"atbm8830.h\"\n#include \"si2168.h\"\n#include \"si2157.h\"\n\n/* debug */\nstatic int dvb_usb_cxusb_debug;\nmodule_param_named(debug, dvb_usb_cxusb_debug, int, 0644);\nMODULE_PARM_DESC(debug, \"set debugging level (1=rc (or-able)).\" DVB_USB_DEBUG_STATUS);\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\n#define deb_info(args...)   dprintk(dvb_usb_cxusb_debug, 0x03, args)\n#define deb_i2c(args...)    dprintk(dvb_usb_cxusb_debug, 0x02, args)\n\nstatic int cxusb_ctrl_msg(struct dvb_usb_device *d,\n\t\t\t  u8 cmd, u8 *wbuf, int wlen, u8 *rbuf, int rlen)\n{\n\tstruct cxusb_state *st = d->priv;\n\tint ret, wo;\n\n\tif (1 + wlen > MAX_XFER_SIZE) {\n\t\twarn(\"i2c wr: len=%d is too big!\\n\", wlen);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\two = (rbuf == NULL || rlen == 0); /* write-only */\n\n\tmutex_lock(&d->data_mutex);\n\tst->data[0] = cmd;\n\tmemcpy(&st->data[1], wbuf, wlen);\n\tif (wo)\n\t\tret = dvb_usb_generic_write(d, st->data, 1 + wlen);\n\telse\n\t\tret = dvb_usb_generic_rw(d, st->data, 1 + wlen,\n\t\t\t\t\t rbuf, rlen, 0);\n\n\tmutex_unlock(&d->data_mutex);\n\treturn ret;\n}\n\n/* GPIO */\nstatic void cxusb_gpio_tuner(struct dvb_usb_device *d, int onoff)\n{\n\tstruct cxusb_state *st = d->priv;\n\tu8 o[2], i;\n\n\tif (st->gpio_write_state[GPIO_TUNER] == onoff)\n\t\treturn;\n\n\to[0] = GPIO_TUNER;\n\to[1] = onoff;\n\tcxusb_ctrl_msg(d, CMD_GPIO_WRITE, o, 2, &i, 1);\n\n\tif (i != 0x01)\n\t\tdeb_info(\"gpio_write failed.\\n\");\n\n\tst->gpio_write_state[GPIO_TUNER] = onoff;\n}\n\nstatic int cxusb_bluebird_gpio_rw(struct dvb_usb_device *d, u8 changemask,\n\t\t\t\t u8 newval)\n{\n\tu8 o[2], gpio_state;\n\tint rc;\n\n\to[0] = 0xff & ~changemask;\t/* mask of bits to keep */\n\to[1] = newval & changemask;\t/* new values for bits  */\n\n\trc = cxusb_ctrl_msg(d, CMD_BLUEBIRD_GPIO_RW, o, 2, &gpio_state, 1);\n\tif (rc < 0 || (gpio_state & changemask) != (newval & changemask))\n\t\tdeb_info(\"bluebird_gpio_write failed.\\n\");\n\n\treturn rc < 0 ? rc : gpio_state;\n}\n\nstatic void cxusb_bluebird_gpio_pulse(struct dvb_usb_device *d, u8 pin, int low)\n{\n\tcxusb_bluebird_gpio_rw(d, pin, low ? 0 : pin);\n\tmsleep(5);\n\tcxusb_bluebird_gpio_rw(d, pin, low ? pin : 0);\n}\n\nstatic void cxusb_nano2_led(struct dvb_usb_device *d, int onoff)\n{\n\tcxusb_bluebird_gpio_rw(d, 0x40, onoff ? 0 : 0x40);\n}\n\nstatic int cxusb_d680_dmb_gpio_tuner(struct dvb_usb_device *d,\n\t\tu8 addr, int onoff)\n{\n\tu8  o[2] = {addr, onoff};\n\tu8  i;\n\tint rc;\n\n\trc = cxusb_ctrl_msg(d, CMD_GPIO_WRITE, o, 2, &i, 1);\n\n\tif (rc < 0)\n\t\treturn rc;\n\tif (i == 0x01)\n\t\treturn 0;\n\telse {\n\t\tdeb_info(\"gpio_write failed.\\n\");\n\t\treturn -EIO;\n\t}\n}\n\n/* I2C */\nstatic int cxusb_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],\n\t\t\t  int num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tint ret;\n\tint i;\n\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tfor (i = 0; i < num; i++) {\n\n\t\tif (le16_to_cpu(d->udev->descriptor.idVendor) == USB_VID_MEDION)\n\t\t\tswitch (msg[i].addr) {\n\t\t\tcase 0x63:\n\t\t\t\tcxusb_gpio_tuner(d, 0);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcxusb_gpio_tuner(d, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (msg[i].flags & I2C_M_RD) {\n\t\t\t/* read only */\n\t\t\tu8 obuf[3], ibuf[MAX_XFER_SIZE];\n\n\t\t\tif (1 + msg[i].len > sizeof(ibuf)) {\n\t\t\t\twarn(\"i2c rd: len=%d is too big!\\n\",\n\t\t\t\t     msg[i].len);\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\tobuf[0] = 0;\n\t\t\tobuf[1] = msg[i].len;\n\t\t\tobuf[2] = msg[i].addr;\n\t\t\tif (cxusb_ctrl_msg(d, CMD_I2C_READ,\n\t\t\t\t\t   obuf, 3,\n\t\t\t\t\t   ibuf, 1+msg[i].len) < 0) {\n\t\t\t\twarn(\"i2c read failed\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(msg[i].buf, &ibuf[1], msg[i].len);\n\t\t} else if (i+1 < num && (msg[i+1].flags & I2C_M_RD) &&\n\t\t\t   msg[i].addr == msg[i+1].addr) {\n\t\t\t/* write to then read from same address */\n\t\t\tu8 obuf[MAX_XFER_SIZE], ibuf[MAX_XFER_SIZE];\n\n\t\t\tif (3 + msg[i].len > sizeof(obuf)) {\n\t\t\t\twarn(\"i2c wr: len=%d is too big!\\n\",\n\t\t\t\t     msg[i].len);\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\tif (1 + msg[i + 1].len > sizeof(ibuf)) {\n\t\t\t\twarn(\"i2c rd: len=%d is too big!\\n\",\n\t\t\t\t     msg[i + 1].len);\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\tobuf[0] = msg[i].len;\n\t\t\tobuf[1] = msg[i+1].len;\n\t\t\tobuf[2] = msg[i].addr;\n\t\t\tmemcpy(&obuf[3], msg[i].buf, msg[i].len);\n\n\t\t\tif (cxusb_ctrl_msg(d, CMD_I2C_READ,\n\t\t\t\t\t   obuf, 3+msg[i].len,\n\t\t\t\t\t   ibuf, 1+msg[i+1].len) < 0)\n\t\t\t\tbreak;\n\n\t\t\tif (ibuf[0] != 0x08)\n\t\t\t\tdeb_i2c(\"i2c read may have failed\\n\");\n\n\t\t\tmemcpy(msg[i+1].buf, &ibuf[1], msg[i+1].len);\n\n\t\t\ti++;\n\t\t} else {\n\t\t\t/* write only */\n\t\t\tu8 obuf[MAX_XFER_SIZE], ibuf;\n\n\t\t\tif (2 + msg[i].len > sizeof(obuf)) {\n\t\t\t\twarn(\"i2c wr: len=%d is too big!\\n\",\n\t\t\t\t     msg[i].len);\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\tobuf[0] = msg[i].addr;\n\t\t\tobuf[1] = msg[i].len;\n\t\t\tmemcpy(&obuf[2], msg[i].buf, msg[i].len);\n\n\t\t\tif (cxusb_ctrl_msg(d, CMD_I2C_WRITE, obuf,\n\t\t\t\t\t   2+msg[i].len, &ibuf,1) < 0)\n\t\t\t\tbreak;\n\t\t\tif (ibuf != 0x08)\n\t\t\t\tdeb_i2c(\"i2c write may have failed\\n\");\n\t\t}\n\t}\n\n\tif (i == num)\n\t\tret = num;\n\telse\n\t\tret = -EREMOTEIO;\n\nunlock:\n\tmutex_unlock(&d->i2c_mutex);\n\treturn ret;\n}\n\nstatic u32 cxusb_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic struct i2c_algorithm cxusb_i2c_algo = {\n\t.master_xfer   = cxusb_i2c_xfer,\n\t.functionality = cxusb_i2c_func,\n};\n\nstatic int cxusb_power_ctrl(struct dvb_usb_device *d, int onoff)\n{\n\tu8 b = 0;\n\tif (onoff)\n\t\treturn cxusb_ctrl_msg(d, CMD_POWER_ON, &b, 1, NULL, 0);\n\telse\n\t\treturn cxusb_ctrl_msg(d, CMD_POWER_OFF, &b, 1, NULL, 0);\n}\n\nstatic int cxusb_aver_power_ctrl(struct dvb_usb_device *d, int onoff)\n{\n\tint ret;\n\tif (!onoff)\n\t\treturn cxusb_ctrl_msg(d, CMD_POWER_OFF, NULL, 0, NULL, 0);\n\tif (d->state == DVB_USB_STATE_INIT &&\n\t    usb_set_interface(d->udev, 0, 0) < 0)\n\t\terr(\"set interface failed\");\n\tdo {} while (!(ret = cxusb_ctrl_msg(d, CMD_POWER_ON, NULL, 0, NULL, 0)) &&\n\t\t   !(ret = cxusb_ctrl_msg(d, 0x15, NULL, 0, NULL, 0)) &&\n\t\t   !(ret = cxusb_ctrl_msg(d, 0x17, NULL, 0, NULL, 0)) && 0);\n\tif (!ret) {\n\t\t/* FIXME: We don't know why, but we need to configure the\n\t\t * lgdt3303 with the register settings below on resume */\n\t\tint i;\n\t\tu8 buf, bufs[] = {\n\t\t\t0x0e, 0x2, 0x00, 0x7f,\n\t\t\t0x0e, 0x2, 0x02, 0xfe,\n\t\t\t0x0e, 0x2, 0x02, 0x01,\n\t\t\t0x0e, 0x2, 0x00, 0x03,\n\t\t\t0x0e, 0x2, 0x0d, 0x40,\n\t\t\t0x0e, 0x2, 0x0e, 0x87,\n\t\t\t0x0e, 0x2, 0x0f, 0x8e,\n\t\t\t0x0e, 0x2, 0x10, 0x01,\n\t\t\t0x0e, 0x2, 0x14, 0xd7,\n\t\t\t0x0e, 0x2, 0x47, 0x88,\n\t\t};\n\t\tmsleep(20);\n\t\tfor (i = 0; i < sizeof(bufs)/sizeof(u8); i += 4/sizeof(u8)) {\n\t\t\tret = cxusb_ctrl_msg(d, CMD_I2C_WRITE,\n\t\t\t\t\t     bufs+i, 4, &buf, 1);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tif (buf != 0x8)\n\t\t\t\treturn -EREMOTEIO;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int cxusb_bluebird_power_ctrl(struct dvb_usb_device *d, int onoff)\n{\n\tu8 b = 0;\n\tif (onoff)\n\t\treturn cxusb_ctrl_msg(d, CMD_POWER_ON, &b, 1, NULL, 0);\n\telse\n\t\treturn 0;\n}\n\nstatic int cxusb_nano2_power_ctrl(struct dvb_usb_device *d, int onoff)\n{\n\tint rc = 0;\n\n\trc = cxusb_power_ctrl(d, onoff);\n\tif (!onoff)\n\t\tcxusb_nano2_led(d, 0);\n\n\treturn rc;\n}\n\nstatic int cxusb_d680_dmb_power_ctrl(struct dvb_usb_device *d, int onoff)\n{\n\tint ret;\n\tu8  b;\n\tret = cxusb_power_ctrl(d, onoff);\n\tif (!onoff)\n\t\treturn ret;\n\n\tmsleep(128);\n\tcxusb_ctrl_msg(d, CMD_DIGITAL, NULL, 0, &b, 1);\n\tmsleep(100);\n\treturn ret;\n}\n\nstatic int cxusb_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)\n{\n\tu8 buf[2] = { 0x03, 0x00 };\n\tif (onoff)\n\t\tcxusb_ctrl_msg(adap->dev, CMD_STREAMING_ON, buf, 2, NULL, 0);\n\telse\n\t\tcxusb_ctrl_msg(adap->dev, CMD_STREAMING_OFF, NULL, 0, NULL, 0);\n\n\treturn 0;\n}\n\nstatic int cxusb_aver_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)\n{\n\tif (onoff)\n\t\tcxusb_ctrl_msg(adap->dev, CMD_AVER_STREAM_ON, NULL, 0, NULL, 0);\n\telse\n\t\tcxusb_ctrl_msg(adap->dev, CMD_AVER_STREAM_OFF,\n\t\t\t       NULL, 0, NULL, 0);\n\treturn 0;\n}\n\nstatic int cxusb_read_status(struct dvb_frontend *fe,\n\t\t\t\t  enum fe_status *status)\n{\n\tstruct dvb_usb_adapter *adap = (struct dvb_usb_adapter *)fe->dvb->priv;\n\tstruct cxusb_state *state = (struct cxusb_state *)adap->dev->priv;\n\tint ret;\n\n\tret = state->fe_read_status(fe, status);\n\n\t/* it need resync slave fifo when signal change from unlock to lock.*/\n\tif ((*status & FE_HAS_LOCK) && (!state->last_lock)) {\n\t\tmutex_lock(&state->stream_mutex);\n\t\tcxusb_streaming_ctrl(adap, 1);\n\t\tmutex_unlock(&state->stream_mutex);\n\t}\n\n\tstate->last_lock = (*status & FE_HAS_LOCK) ? 1 : 0;\n\treturn ret;\n}\n\nstatic void cxusb_d680_dmb_drain_message(struct dvb_usb_device *d)\n{\n\tint       ep = d->props.generic_bulk_ctrl_endpoint;\n\tconst int timeout = 100;\n\tconst int junk_len = 32;\n\tu8        *junk;\n\tint       rd_count;\n\n\t/* Discard remaining data in video pipe */\n\tjunk = kmalloc(junk_len, GFP_KERNEL);\n\tif (!junk)\n\t\treturn;\n\twhile (1) {\n\t\tif (usb_bulk_msg(d->udev,\n\t\t\tusb_rcvbulkpipe(d->udev, ep),\n\t\t\tjunk, junk_len, &rd_count, timeout) < 0)\n\t\t\tbreak;\n\t\tif (!rd_count)\n\t\t\tbreak;\n\t}\n\tkfree(junk);\n}\n\nstatic void cxusb_d680_dmb_drain_video(struct dvb_usb_device *d)\n{\n\tstruct usb_data_stream_properties *p = &d->props.adapter[0].fe[0].stream;\n\tconst int timeout = 100;\n\tconst int junk_len = p->u.bulk.buffersize;\n\tu8        *junk;\n\tint       rd_count;\n\n\t/* Discard remaining data in video pipe */\n\tjunk = kmalloc(junk_len, GFP_KERNEL);\n\tif (!junk)\n\t\treturn;\n\twhile (1) {\n\t\tif (usb_bulk_msg(d->udev,\n\t\t\tusb_rcvbulkpipe(d->udev, p->endpoint),\n\t\t\tjunk, junk_len, &rd_count, timeout) < 0)\n\t\t\tbreak;\n\t\tif (!rd_count)\n\t\t\tbreak;\n\t}\n\tkfree(junk);\n}\n\nstatic int cxusb_d680_dmb_streaming_ctrl(\n\t\tstruct dvb_usb_adapter *adap, int onoff)\n{\n\tif (onoff) {\n\t\tu8 buf[2] = { 0x03, 0x00 };\n\t\tcxusb_d680_dmb_drain_video(adap->dev);\n\t\treturn cxusb_ctrl_msg(adap->dev, CMD_STREAMING_ON,\n\t\t\tbuf, sizeof(buf), NULL, 0);\n\t} else {\n\t\tint ret = cxusb_ctrl_msg(adap->dev,\n\t\t\tCMD_STREAMING_OFF, NULL, 0, NULL, 0);\n\t\treturn ret;\n\t}\n}\n\nstatic int cxusb_rc_query(struct dvb_usb_device *d)\n{\n\tu8 ircode[4];\n\n\tcxusb_ctrl_msg(d, CMD_GET_IR_CODE, NULL, 0, ircode, 4);\n\n\tif (ircode[2] || ircode[3])\n\t\trc_keydown(d->rc_dev, RC_TYPE_UNKNOWN,\n\t\t\t   RC_SCANCODE_RC5(ircode[2], ircode[3]), 0);\n\treturn 0;\n}\n\nstatic int cxusb_bluebird2_rc_query(struct dvb_usb_device *d)\n{\n\tu8 ircode[4];\n\tstruct i2c_msg msg = { .addr = 0x6b, .flags = I2C_M_RD,\n\t\t\t       .buf = ircode, .len = 4 };\n\n\tif (cxusb_i2c_xfer(&d->i2c_adap, &msg, 1) != 1)\n\t\treturn 0;\n\n\tif (ircode[1] || ircode[2])\n\t\trc_keydown(d->rc_dev, RC_TYPE_UNKNOWN,\n\t\t\t   RC_SCANCODE_RC5(ircode[1], ircode[2]), 0);\n\treturn 0;\n}\n\nstatic int cxusb_d680_dmb_rc_query(struct dvb_usb_device *d)\n{\n\tu8 ircode[2];\n\n\tif (cxusb_ctrl_msg(d, 0x10, NULL, 0, ircode, 2) < 0)\n\t\treturn 0;\n\n\tif (ircode[0] || ircode[1])\n\t\trc_keydown(d->rc_dev, RC_TYPE_UNKNOWN,\n\t\t\t   RC_SCANCODE_RC5(ircode[0], ircode[1]), 0);\n\treturn 0;\n}\n\nstatic int cxusb_dee1601_demod_init(struct dvb_frontend* fe)\n{\n\tstatic u8 clock_config []  = { CLOCK_CTL,  0x38, 0x28 };\n\tstatic u8 reset []         = { RESET,      0x80 };\n\tstatic u8 adc_ctl_1_cfg [] = { ADC_CTL_1,  0x40 };\n\tstatic u8 agc_cfg []       = { AGC_TARGET, 0x28, 0x20 };\n\tstatic u8 gpp_ctl_cfg []   = { GPP_CTL,    0x33 };\n\tstatic u8 capt_range_cfg[] = { CAPT_RANGE, 0x32 };\n\n\tmt352_write(fe, clock_config,   sizeof(clock_config));\n\tudelay(200);\n\tmt352_write(fe, reset,          sizeof(reset));\n\tmt352_write(fe, adc_ctl_1_cfg,  sizeof(adc_ctl_1_cfg));\n\n\tmt352_write(fe, agc_cfg,        sizeof(agc_cfg));\n\tmt352_write(fe, gpp_ctl_cfg,    sizeof(gpp_ctl_cfg));\n\tmt352_write(fe, capt_range_cfg, sizeof(capt_range_cfg));\n\n\treturn 0;\n}\n\nstatic int cxusb_mt352_demod_init(struct dvb_frontend* fe)\n{\t/* used in both lgz201 and th7579 */\n\tstatic u8 clock_config []  = { CLOCK_CTL,  0x38, 0x29 };\n\tstatic u8 reset []         = { RESET,      0x80 };\n\tstatic u8 adc_ctl_1_cfg [] = { ADC_CTL_1,  0x40 };\n\tstatic u8 agc_cfg []       = { AGC_TARGET, 0x24, 0x20 };\n\tstatic u8 gpp_ctl_cfg []   = { GPP_CTL,    0x33 };\n\tstatic u8 capt_range_cfg[] = { CAPT_RANGE, 0x32 };\n\n\tmt352_write(fe, clock_config,   sizeof(clock_config));\n\tudelay(200);\n\tmt352_write(fe, reset,          sizeof(reset));\n\tmt352_write(fe, adc_ctl_1_cfg,  sizeof(adc_ctl_1_cfg));\n\n\tmt352_write(fe, agc_cfg,        sizeof(agc_cfg));\n\tmt352_write(fe, gpp_ctl_cfg,    sizeof(gpp_ctl_cfg));\n\tmt352_write(fe, capt_range_cfg, sizeof(capt_range_cfg));\n\treturn 0;\n}\n\nstatic struct cx22702_config cxusb_cx22702_config = {\n\t.demod_address = 0x63,\n\t.output_mode = CX22702_PARALLEL_OUTPUT,\n};\n\nstatic struct lgdt330x_config cxusb_lgdt3303_config = {\n\t.demod_address = 0x0e,\n\t.demod_chip    = LGDT3303,\n};\n\nstatic struct lgdt330x_config cxusb_aver_lgdt3303_config = {\n\t.demod_address       = 0x0e,\n\t.demod_chip          = LGDT3303,\n\t.clock_polarity_flip = 2,\n};\n\nstatic struct mt352_config cxusb_dee1601_config = {\n\t.demod_address = 0x0f,\n\t.demod_init    = cxusb_dee1601_demod_init,\n};\n\nstatic struct zl10353_config cxusb_zl10353_dee1601_config = {\n\t.demod_address = 0x0f,\n\t.parallel_ts = 1,\n};\n\nstatic struct mt352_config cxusb_mt352_config = {\n\t/* used in both lgz201 and th7579 */\n\t.demod_address = 0x0f,\n\t.demod_init    = cxusb_mt352_demod_init,\n};\n\nstatic struct zl10353_config cxusb_zl10353_xc3028_config = {\n\t.demod_address = 0x0f,\n\t.if2 = 45600,\n\t.no_tuner = 1,\n\t.parallel_ts = 1,\n};\n\nstatic struct zl10353_config cxusb_zl10353_xc3028_config_no_i2c_gate = {\n\t.demod_address = 0x0f,\n\t.if2 = 45600,\n\t.no_tuner = 1,\n\t.parallel_ts = 1,\n\t.disable_i2c_gate_ctrl = 1,\n};\n\nstatic struct mt352_config cxusb_mt352_xc3028_config = {\n\t.demod_address = 0x0f,\n\t.if2 = 4560,\n\t.no_tuner = 1,\n\t.demod_init = cxusb_mt352_demod_init,\n};\n\n/* FIXME: needs tweaking */\nstatic struct mxl5005s_config aver_a868r_tuner = {\n\t.i2c_address     = 0x63,\n\t.if_freq         = 6000000UL,\n\t.xtal_freq       = CRYSTAL_FREQ_16000000HZ,\n\t.agc_mode        = MXL_SINGLE_AGC,\n\t.tracking_filter = MXL_TF_C,\n\t.rssi_enable     = MXL_RSSI_ENABLE,\n\t.cap_select      = MXL_CAP_SEL_ENABLE,\n\t.div_out         = MXL_DIV_OUT_4,\n\t.clock_out       = MXL_CLOCK_OUT_DISABLE,\n\t.output_load     = MXL5005S_IF_OUTPUT_LOAD_200_OHM,\n\t.top\t\t = MXL5005S_TOP_25P2,\n\t.mod_mode        = MXL_DIGITAL_MODE,\n\t.if_mode         = MXL_ZERO_IF,\n\t.AgcMasterByte   = 0x00,\n};\n\n/* FIXME: needs tweaking */\nstatic struct mxl5005s_config d680_dmb_tuner = {\n\t.i2c_address     = 0x63,\n\t.if_freq         = 36125000UL,\n\t.xtal_freq       = CRYSTAL_FREQ_16000000HZ,\n\t.agc_mode        = MXL_SINGLE_AGC,\n\t.tracking_filter = MXL_TF_C,\n\t.rssi_enable     = MXL_RSSI_ENABLE,\n\t.cap_select      = MXL_CAP_SEL_ENABLE,\n\t.div_out         = MXL_DIV_OUT_4,\n\t.clock_out       = MXL_CLOCK_OUT_DISABLE,\n\t.output_load     = MXL5005S_IF_OUTPUT_LOAD_200_OHM,\n\t.top\t\t = MXL5005S_TOP_25P2,\n\t.mod_mode        = MXL_DIGITAL_MODE,\n\t.if_mode         = MXL_ZERO_IF,\n\t.AgcMasterByte   = 0x00,\n};\n\nstatic struct max2165_config mygica_d689_max2165_cfg = {\n\t.i2c_address = 0x60,\n\t.osc_clk = 20\n};\n\n/* Callbacks for DVB USB */\nstatic int cxusb_fmd1216me_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tdvb_attach(simple_tuner_attach, adap->fe_adap[0].fe,\n\t\t   &adap->dev->i2c_adap, 0x61,\n\t\t   TUNER_PHILIPS_FMD1216ME_MK3);\n\treturn 0;\n}\n\nstatic int cxusb_dee1601_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tdvb_attach(dvb_pll_attach, adap->fe_adap[0].fe, 0x61,\n\t\t   NULL, DVB_PLL_THOMSON_DTT7579);\n\treturn 0;\n}\n\nstatic int cxusb_lgz201_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tdvb_attach(dvb_pll_attach, adap->fe_adap[0].fe, 0x61, NULL, DVB_PLL_LG_Z201);\n\treturn 0;\n}\n\nstatic int cxusb_dtt7579_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tdvb_attach(dvb_pll_attach, adap->fe_adap[0].fe, 0x60,\n\t\t   NULL, DVB_PLL_THOMSON_DTT7579);\n\treturn 0;\n}\n\nstatic int cxusb_lgh064f_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tdvb_attach(simple_tuner_attach, adap->fe_adap[0].fe,\n\t\t   &adap->dev->i2c_adap, 0x61, TUNER_LG_TDVS_H06XF);\n\treturn 0;\n}\n\nstatic int dvico_bluebird_xc2028_callback(void *ptr, int component,\n\t\t\t\t\t  int command, int arg)\n{\n\tstruct dvb_usb_adapter *adap = ptr;\n\tstruct dvb_usb_device *d = adap->dev;\n\n\tswitch (command) {\n\tcase XC2028_TUNER_RESET:\n\t\tdeb_info(\"%s: XC2028_TUNER_RESET %d\\n\", __func__, arg);\n\t\tcxusb_bluebird_gpio_pulse(d, 0x01, 1);\n\t\tbreak;\n\tcase XC2028_RESET_CLK:\n\t\tdeb_info(\"%s: XC2028_RESET_CLK %d\\n\", __func__, arg);\n\t\tbreak;\n\tdefault:\n\t\tdeb_info(\"%s: unknown command %d, arg %d\\n\", __func__,\n\t\t\t command, arg);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cxusb_dvico_xc3028_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_frontend\t *fe;\n\tstruct xc2028_config\t  cfg = {\n\t\t.i2c_adap  = &adap->dev->i2c_adap,\n\t\t.i2c_addr  = 0x61,\n\t};\n\tstatic struct xc2028_ctrl ctl = {\n\t\t.fname       = XC2028_DEFAULT_FIRMWARE,\n\t\t.max_len     = 64,\n\t\t.demod       = XC3028_FE_ZARLINK456,\n\t};\n\n\t/* FIXME: generalize & move to common area */\n\tadap->fe_adap[0].fe->callback = dvico_bluebird_xc2028_callback;\n\n\tfe = dvb_attach(xc2028_attach, adap->fe_adap[0].fe, &cfg);\n\tif (fe == NULL || fe->ops.tuner_ops.set_config == NULL)\n\t\treturn -EIO;\n\n\tfe->ops.tuner_ops.set_config(fe, &ctl);\n\n\treturn 0;\n}\n\nstatic int cxusb_mxl5003s_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tdvb_attach(mxl5005s_attach, adap->fe_adap[0].fe,\n\t\t   &adap->dev->i2c_adap, &aver_a868r_tuner);\n\treturn 0;\n}\n\nstatic int cxusb_d680_dmb_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_frontend *fe;\n\tfe = dvb_attach(mxl5005s_attach, adap->fe_adap[0].fe,\n\t\t\t&adap->dev->i2c_adap, &d680_dmb_tuner);\n\treturn (fe == NULL) ? -EIO : 0;\n}\n\nstatic int cxusb_mygica_d689_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_frontend *fe;\n\tfe = dvb_attach(max2165_attach, adap->fe_adap[0].fe,\n\t\t\t&adap->dev->i2c_adap, &mygica_d689_max2165_cfg);\n\treturn (fe == NULL) ? -EIO : 0;\n}\n\nstatic int cxusb_cx22702_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tu8 b;\n\tif (usb_set_interface(adap->dev->udev, 0, 6) < 0)\n\t\terr(\"set interface failed\");\n\n\tcxusb_ctrl_msg(adap->dev, CMD_DIGITAL, NULL, 0, &b, 1);\n\n\tadap->fe_adap[0].fe = dvb_attach(cx22702_attach, &cxusb_cx22702_config,\n\t\t\t\t\t &adap->dev->i2c_adap);\n\tif ((adap->fe_adap[0].fe) != NULL)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nstatic int cxusb_lgdt3303_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tif (usb_set_interface(adap->dev->udev, 0, 7) < 0)\n\t\terr(\"set interface failed\");\n\n\tcxusb_ctrl_msg(adap->dev, CMD_DIGITAL, NULL, 0, NULL, 0);\n\n\tadap->fe_adap[0].fe = dvb_attach(lgdt330x_attach,\n\t\t\t\t\t &cxusb_lgdt3303_config,\n\t\t\t\t\t &adap->dev->i2c_adap);\n\tif ((adap->fe_adap[0].fe) != NULL)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nstatic int cxusb_aver_lgdt3303_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tadap->fe_adap[0].fe = dvb_attach(lgdt330x_attach, &cxusb_aver_lgdt3303_config,\n\t\t\t      &adap->dev->i2c_adap);\n\tif (adap->fe_adap[0].fe != NULL)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nstatic int cxusb_mt352_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\t/* used in both lgz201 and th7579 */\n\tif (usb_set_interface(adap->dev->udev, 0, 0) < 0)\n\t\terr(\"set interface failed\");\n\n\tcxusb_ctrl_msg(adap->dev, CMD_DIGITAL, NULL, 0, NULL, 0);\n\n\tadap->fe_adap[0].fe = dvb_attach(mt352_attach, &cxusb_mt352_config,\n\t\t\t\t\t &adap->dev->i2c_adap);\n\tif ((adap->fe_adap[0].fe) != NULL)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nstatic int cxusb_dee1601_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tif (usb_set_interface(adap->dev->udev, 0, 0) < 0)\n\t\terr(\"set interface failed\");\n\n\tcxusb_ctrl_msg(adap->dev, CMD_DIGITAL, NULL, 0, NULL, 0);\n\n\tadap->fe_adap[0].fe = dvb_attach(mt352_attach, &cxusb_dee1601_config,\n\t\t\t\t\t &adap->dev->i2c_adap);\n\tif ((adap->fe_adap[0].fe) != NULL)\n\t\treturn 0;\n\n\tadap->fe_adap[0].fe = dvb_attach(zl10353_attach,\n\t\t\t\t\t &cxusb_zl10353_dee1601_config,\n\t\t\t\t\t &adap->dev->i2c_adap);\n\tif ((adap->fe_adap[0].fe) != NULL)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nstatic int cxusb_dualdig4_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tu8 ircode[4];\n\tint i;\n\tstruct i2c_msg msg = { .addr = 0x6b, .flags = I2C_M_RD,\n\t\t\t       .buf = ircode, .len = 4 };\n\n\tif (usb_set_interface(adap->dev->udev, 0, 1) < 0)\n\t\terr(\"set interface failed\");\n\n\tcxusb_ctrl_msg(adap->dev, CMD_DIGITAL, NULL, 0, NULL, 0);\n\n\t/* reset the tuner and demodulator */\n\tcxusb_bluebird_gpio_rw(adap->dev, 0x04, 0);\n\tcxusb_bluebird_gpio_pulse(adap->dev, 0x01, 1);\n\tcxusb_bluebird_gpio_pulse(adap->dev, 0x02, 1);\n\n\tadap->fe_adap[0].fe =\n\t\tdvb_attach(zl10353_attach,\n\t\t\t   &cxusb_zl10353_xc3028_config_no_i2c_gate,\n\t\t\t   &adap->dev->i2c_adap);\n\tif ((adap->fe_adap[0].fe) == NULL)\n\t\treturn -EIO;\n\n\t/* try to determine if there is no IR decoder on the I2C bus */\n\tfor (i = 0; adap->dev->props.rc.core.rc_codes && i < 5; i++) {\n\t\tmsleep(20);\n\t\tif (cxusb_i2c_xfer(&adap->dev->i2c_adap, &msg, 1) != 1)\n\t\t\tgoto no_IR;\n\t\tif (ircode[0] == 0 && ircode[1] == 0)\n\t\t\tcontinue;\n\t\tif (ircode[2] + ircode[3] != 0xff) {\nno_IR:\n\t\t\tadap->dev->props.rc.core.rc_codes = NULL;\n\t\t\tinfo(\"No IR receiver detected on this device.\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct dibx000_agc_config dib7070_agc_config = {\n\t.band_caps = BAND_UHF | BAND_VHF | BAND_LBAND | BAND_SBAND,\n\n\t/*\n\t * P_agc_use_sd_mod1=0, P_agc_use_sd_mod2=0, P_agc_freq_pwm_div=5,\n\t * P_agc_inv_pwm1=0, P_agc_inv_pwm2=0, P_agc_inh_dc_rv_est=0,\n\t * P_agc_time_est=3, P_agc_freeze=0, P_agc_nb_est=5, P_agc_write=0\n\t */\n\t.setup = (0 << 15) | (0 << 14) | (5 << 11) | (0 << 10) | (0 << 9) |\n\t\t (0 << 8) | (3 << 5) | (0 << 4) | (5 << 1) | (0 << 0),\n\t.inv_gain = 600,\n\t.time_stabiliz = 10,\n\t.alpha_level = 0,\n\t.thlock = 118,\n\t.wbd_inv = 0,\n\t.wbd_ref = 3530,\n\t.wbd_sel = 1,\n\t.wbd_alpha = 5,\n\t.agc1_max = 65535,\n\t.agc1_min = 0,\n\t.agc2_max = 65535,\n\t.agc2_min = 0,\n\t.agc1_pt1 = 0,\n\t.agc1_pt2 = 40,\n\t.agc1_pt3 = 183,\n\t.agc1_slope1 = 206,\n\t.agc1_slope2 = 255,\n\t.agc2_pt1 = 72,\n\t.agc2_pt2 = 152,\n\t.agc2_slope1 = 88,\n\t.agc2_slope2 = 90,\n\t.alpha_mant = 17,\n\t.alpha_exp = 27,\n\t.beta_mant = 23,\n\t.beta_exp = 51,\n\t.perform_agc_softsplit = 0,\n};\n\nstatic struct dibx000_bandwidth_config dib7070_bw_config_12_mhz = {\n\t.internal = 60000,\n\t.sampling = 15000,\n\t.pll_prediv = 1,\n\t.pll_ratio = 20,\n\t.pll_range = 3,\n\t.pll_reset = 1,\n\t.pll_bypass = 0,\n\t.enable_refdiv = 0,\n\t.bypclk_div = 0,\n\t.IO_CLK_en_core = 1,\n\t.ADClkSrc = 1,\n\t.modulo = 2,\n\t/* refsel, sel, freq_15k */\n\t.sad_cfg = (3 << 14) | (1 << 12) | (524 << 0),\n\t.ifreq = (0 << 25) | 0,\n\t.timf = 20452225,\n\t.xtal_hz = 12000000,\n};\n\nstatic struct dib7000p_config cxusb_dualdig4_rev2_config = {\n\t.output_mode = OUTMODE_MPEG2_PAR_GATED_CLK,\n\t.output_mpeg2_in_188_bytes = 1,\n\n\t.agc_config_count = 1,\n\t.agc = &dib7070_agc_config,\n\t.bw  = &dib7070_bw_config_12_mhz,\n\t.tuner_is_baseband = 1,\n\t.spur_protect = 1,\n\n\t.gpio_dir = 0xfcef,\n\t.gpio_val = 0x0110,\n\n\t.gpio_pwm_pos = DIB7000P_GPIO_DEFAULT_PWM_POS,\n\n\t.hostbus_diversity = 1,\n};\n\nstruct dib0700_adapter_state {\n\tint (*set_param_save)(struct dvb_frontend *);\n\tstruct dib7000p_ops dib7000p_ops;\n};\n\nstatic int cxusb_dualdig4_rev2_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tif (usb_set_interface(adap->dev->udev, 0, 1) < 0)\n\t\terr(\"set interface failed\");\n\n\tcxusb_ctrl_msg(adap->dev, CMD_DIGITAL, NULL, 0, NULL, 0);\n\n\tcxusb_bluebird_gpio_pulse(adap->dev, 0x02, 1);\n\n\tif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\n\t\treturn -ENODEV;\n\n\tif (state->dib7000p_ops.i2c_enumeration(&adap->dev->i2c_adap, 1, 18,\n\t\t\t\t       &cxusb_dualdig4_rev2_config) < 0) {\n\t\tprintk(KERN_WARNING \"Unable to enumerate dib7000p\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tadap->fe_adap[0].fe = state->dib7000p_ops.init(&adap->dev->i2c_adap, 0x80,\n\t\t\t\t\t      &cxusb_dualdig4_rev2_config);\n\tif (adap->fe_adap[0].fe == NULL)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int dib7070_tuner_reset(struct dvb_frontend *fe, int onoff)\n{\n\tstruct dvb_usb_adapter *adap = fe->dvb->priv;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\treturn state->dib7000p_ops.set_gpio(fe, 8, 0, !onoff);\n}\n\nstatic int dib7070_tuner_sleep(struct dvb_frontend *fe, int onoff)\n{\n\treturn 0;\n}\n\nstatic struct dib0070_config dib7070p_dib0070_config = {\n\t.i2c_address = DEFAULT_DIB0070_I2C_ADDRESS,\n\t.reset = dib7070_tuner_reset,\n\t.sleep = dib7070_tuner_sleep,\n\t.clock_khz = 12000,\n};\n\nstatic int dib7070_set_param_override(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct dvb_usb_adapter *adap = fe->dvb->priv;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tu16 offset;\n\tu8 band = BAND_OF_FREQUENCY(p->frequency/1000);\n\tswitch (band) {\n\tcase BAND_VHF: offset = 950; break;\n\tdefault:\n\tcase BAND_UHF: offset = 550; break;\n\t}\n\n\tstate->dib7000p_ops.set_wbd_ref(fe, offset + dib0070_wbd_offset(fe));\n\n\treturn state->set_param_save(fe);\n}\n\nstatic int cxusb_dualdig4_rev2_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_adapter_state *st = adap->priv;\n\tstruct i2c_adapter *tun_i2c;\n\n\t/*\n\t * No need to call dvb7000p_attach here, as it was called\n\t * already, as frontend_attach method is called first, and\n\t * tuner_attach is only called on sucess.\n\t */\n\ttun_i2c = st->dib7000p_ops.get_i2c_master(adap->fe_adap[0].fe,\n\t\t\t\t\tDIBX000_I2C_INTERFACE_TUNER, 1);\n\n\tif (dvb_attach(dib0070_attach, adap->fe_adap[0].fe, tun_i2c,\n\t    &dib7070p_dib0070_config) == NULL)\n\t\treturn -ENODEV;\n\n\tst->set_param_save = adap->fe_adap[0].fe->ops.tuner_ops.set_params;\n\tadap->fe_adap[0].fe->ops.tuner_ops.set_params = dib7070_set_param_override;\n\treturn 0;\n}\n\nstatic int cxusb_nano2_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tif (usb_set_interface(adap->dev->udev, 0, 1) < 0)\n\t\terr(\"set interface failed\");\n\n\tcxusb_ctrl_msg(adap->dev, CMD_DIGITAL, NULL, 0, NULL, 0);\n\n\t/* reset the tuner and demodulator */\n\tcxusb_bluebird_gpio_rw(adap->dev, 0x04, 0);\n\tcxusb_bluebird_gpio_pulse(adap->dev, 0x01, 1);\n\tcxusb_bluebird_gpio_pulse(adap->dev, 0x02, 1);\n\n\tadap->fe_adap[0].fe = dvb_attach(zl10353_attach,\n\t\t\t\t\t &cxusb_zl10353_xc3028_config,\n\t\t\t\t\t &adap->dev->i2c_adap);\n\tif ((adap->fe_adap[0].fe) != NULL)\n\t\treturn 0;\n\n\tadap->fe_adap[0].fe = dvb_attach(mt352_attach,\n\t\t\t\t\t &cxusb_mt352_xc3028_config,\n\t\t\t\t\t &adap->dev->i2c_adap);\n\tif ((adap->fe_adap[0].fe) != NULL)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nstatic struct lgs8gxx_config d680_lgs8gl5_cfg = {\n\t.prod = LGS8GXX_PROD_LGS8GL5,\n\t.demod_address = 0x19,\n\t.serial_ts = 0,\n\t.ts_clk_pol = 0,\n\t.ts_clk_gated = 1,\n\t.if_clk_freq = 30400, /* 30.4 MHz */\n\t.if_freq = 5725, /* 5.725 MHz */\n\t.if_neg_center = 0,\n\t.ext_adc = 0,\n\t.adc_signed = 0,\n\t.if_neg_edge = 0,\n};\n\nstatic int cxusb_d680_dmb_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap->dev;\n\tint n;\n\n\t/* Select required USB configuration */\n\tif (usb_set_interface(d->udev, 0, 0) < 0)\n\t\terr(\"set interface failed\");\n\n\t/* Unblock all USB pipes */\n\tusb_clear_halt(d->udev,\n\t\tusb_sndbulkpipe(d->udev, d->props.generic_bulk_ctrl_endpoint));\n\tusb_clear_halt(d->udev,\n\t\tusb_rcvbulkpipe(d->udev, d->props.generic_bulk_ctrl_endpoint));\n\tusb_clear_halt(d->udev,\n\t\tusb_rcvbulkpipe(d->udev, d->props.adapter[0].fe[0].stream.endpoint));\n\n\t/* Drain USB pipes to avoid hang after reboot */\n\tfor (n = 0;  n < 5;  n++) {\n\t\tcxusb_d680_dmb_drain_message(d);\n\t\tcxusb_d680_dmb_drain_video(d);\n\t\tmsleep(200);\n\t}\n\n\t/* Reset the tuner */\n\tif (cxusb_d680_dmb_gpio_tuner(d, 0x07, 0) < 0) {\n\t\terr(\"clear tuner gpio failed\");\n\t\treturn -EIO;\n\t}\n\tmsleep(100);\n\tif (cxusb_d680_dmb_gpio_tuner(d, 0x07, 1) < 0) {\n\t\terr(\"set tuner gpio failed\");\n\t\treturn -EIO;\n\t}\n\tmsleep(100);\n\n\t/* Attach frontend */\n\tadap->fe_adap[0].fe = dvb_attach(lgs8gxx_attach, &d680_lgs8gl5_cfg, &d->i2c_adap);\n\tif (adap->fe_adap[0].fe == NULL)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic struct atbm8830_config mygica_d689_atbm8830_cfg = {\n\t.prod = ATBM8830_PROD_8830,\n\t.demod_address = 0x40,\n\t.serial_ts = 0,\n\t.ts_sampling_edge = 1,\n\t.ts_clk_gated = 0,\n\t.osc_clk_freq = 30400, /* in kHz */\n\t.if_freq = 0, /* zero IF */\n\t.zif_swap_iq = 1,\n\t.agc_min = 0x2E,\n\t.agc_max = 0x90,\n\t.agc_hold_loop = 0,\n};\n\nstatic int cxusb_mygica_d689_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap->dev;\n\n\t/* Select required USB configuration */\n\tif (usb_set_interface(d->udev, 0, 0) < 0)\n\t\terr(\"set interface failed\");\n\n\t/* Unblock all USB pipes */\n\tusb_clear_halt(d->udev,\n\t\tusb_sndbulkpipe(d->udev, d->props.generic_bulk_ctrl_endpoint));\n\tusb_clear_halt(d->udev,\n\t\tusb_rcvbulkpipe(d->udev, d->props.generic_bulk_ctrl_endpoint));\n\tusb_clear_halt(d->udev,\n\t\tusb_rcvbulkpipe(d->udev, d->props.adapter[0].fe[0].stream.endpoint));\n\n\n\t/* Reset the tuner */\n\tif (cxusb_d680_dmb_gpio_tuner(d, 0x07, 0) < 0) {\n\t\terr(\"clear tuner gpio failed\");\n\t\treturn -EIO;\n\t}\n\tmsleep(100);\n\tif (cxusb_d680_dmb_gpio_tuner(d, 0x07, 1) < 0) {\n\t\terr(\"set tuner gpio failed\");\n\t\treturn -EIO;\n\t}\n\tmsleep(100);\n\n\t/* Attach frontend */\n\tadap->fe_adap[0].fe = dvb_attach(atbm8830_attach, &mygica_d689_atbm8830_cfg,\n\t\t&d->i2c_adap);\n\tif (adap->fe_adap[0].fe == NULL)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int cxusb_mygica_t230_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap->dev;\n\tstruct cxusb_state *st = d->priv;\n\tstruct i2c_adapter *adapter;\n\tstruct i2c_client *client_demod;\n\tstruct i2c_client *client_tuner;\n\tstruct i2c_board_info info;\n\tstruct si2168_config si2168_config;\n\tstruct si2157_config si2157_config;\n\n\t/* Select required USB configuration */\n\tif (usb_set_interface(d->udev, 0, 0) < 0)\n\t\terr(\"set interface failed\");\n\n\t/* Unblock all USB pipes */\n\tusb_clear_halt(d->udev,\n\t\tusb_sndbulkpipe(d->udev, d->props.generic_bulk_ctrl_endpoint));\n\tusb_clear_halt(d->udev,\n\t\tusb_rcvbulkpipe(d->udev, d->props.generic_bulk_ctrl_endpoint));\n\tusb_clear_halt(d->udev,\n\t\tusb_rcvbulkpipe(d->udev, d->props.adapter[0].fe[0].stream.endpoint));\n\n\t/* attach frontend */\n\tsi2168_config.i2c_adapter = &adapter;\n\tsi2168_config.fe = &adap->fe_adap[0].fe;\n\tsi2168_config.ts_mode = SI2168_TS_PARALLEL;\n\tsi2168_config.ts_clock_inv = 1;\n\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\tstrlcpy(info.type, \"si2168\", I2C_NAME_SIZE);\n\tinfo.addr = 0x64;\n\tinfo.platform_data = &si2168_config;\n\trequest_module(info.type);\n\tclient_demod = i2c_new_device(&d->i2c_adap, &info);\n\tif (client_demod == NULL || client_demod->dev.driver == NULL)\n\t\treturn -ENODEV;\n\n\tif (!try_module_get(client_demod->dev.driver->owner)) {\n\t\ti2c_unregister_device(client_demod);\n\t\treturn -ENODEV;\n\t}\n\n\tst->i2c_client_demod = client_demod;\n\n\t/* attach tuner */\n\tmemset(&si2157_config, 0, sizeof(si2157_config));\n\tsi2157_config.fe = adap->fe_adap[0].fe;\n\tsi2157_config.if_port = 1;\n\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\tstrlcpy(info.type, \"si2157\", I2C_NAME_SIZE);\n\tinfo.addr = 0x60;\n\tinfo.platform_data = &si2157_config;\n\trequest_module(info.type);\n\tclient_tuner = i2c_new_device(adapter, &info);\n\tif (client_tuner == NULL || client_tuner->dev.driver == NULL) {\n\t\tmodule_put(client_demod->dev.driver->owner);\n\t\ti2c_unregister_device(client_demod);\n\t\treturn -ENODEV;\n\t}\n\tif (!try_module_get(client_tuner->dev.driver->owner)) {\n\t\ti2c_unregister_device(client_tuner);\n\t\tmodule_put(client_demod->dev.driver->owner);\n\t\ti2c_unregister_device(client_demod);\n\t\treturn -ENODEV;\n\t}\n\n\tst->i2c_client_tuner = client_tuner;\n\n\t/* hook fe: need to resync the slave fifo when signal locks. */\n\tmutex_init(&st->stream_mutex);\n\tst->last_lock = 0;\n\tst->fe_read_status = adap->fe_adap[0].fe->ops.read_status;\n\tadap->fe_adap[0].fe->ops.read_status = cxusb_read_status;\n\n\treturn 0;\n}\n\n/*\n * DViCO has shipped two devices with the same USB ID, but only one of them\n * needs a firmware download.  Check the device class details to see if they\n * have non-default values to decide whether the device is actually cold or\n * not, and forget a match if it turns out we selected the wrong device.\n */\nstatic int bluebird_fx2_identify_state(struct usb_device *udev,\n\t\t\t\t       struct dvb_usb_device_properties *props,\n\t\t\t\t       struct dvb_usb_device_description **desc,\n\t\t\t\t       int *cold)\n{\n\tint wascold = *cold;\n\n\t*cold = udev->descriptor.bDeviceClass == 0xff &&\n\t\tudev->descriptor.bDeviceSubClass == 0xff &&\n\t\tudev->descriptor.bDeviceProtocol == 0xff;\n\n\tif (*cold && !wascold)\n\t\t*desc = NULL;\n\n\treturn 0;\n}\n\n/*\n * DViCO bluebird firmware needs the \"warm\" product ID to be patched into the\n * firmware file before download.\n */\n\nstatic const int dvico_firmware_id_offsets[] = { 6638, 3204 };\nstatic int bluebird_patch_dvico_firmware_download(struct usb_device *udev,\n\t\t\t\t\t\t  const struct firmware *fw)\n{\n\tint pos;\n\n\tfor (pos = 0; pos < ARRAY_SIZE(dvico_firmware_id_offsets); pos++) {\n\t\tint idoff = dvico_firmware_id_offsets[pos];\n\n\t\tif (fw->size < idoff + 4)\n\t\t\tcontinue;\n\n\t\tif (fw->data[idoff] == (USB_VID_DVICO & 0xff) &&\n\t\t    fw->data[idoff + 1] == USB_VID_DVICO >> 8) {\n\t\t\tstruct firmware new_fw;\n\t\t\tu8 *new_fw_data = vmalloc(fw->size);\n\t\t\tint ret;\n\n\t\t\tif (!new_fw_data)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tmemcpy(new_fw_data, fw->data, fw->size);\n\t\t\tnew_fw.size = fw->size;\n\t\t\tnew_fw.data = new_fw_data;\n\n\t\t\tnew_fw_data[idoff + 2] =\n\t\t\t\tle16_to_cpu(udev->descriptor.idProduct) + 1;\n\t\t\tnew_fw_data[idoff + 3] =\n\t\t\t\tle16_to_cpu(udev->descriptor.idProduct) >> 8;\n\n\t\t\tret = usb_cypress_load_firmware(udev, &new_fw,\n\t\t\t\t\t\t\tCYPRESS_FX2);\n\t\t\tvfree(new_fw_data);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\n/* DVB USB Driver stuff */\nstatic struct dvb_usb_device_properties cxusb_medion_properties;\nstatic struct dvb_usb_device_properties cxusb_bluebird_lgh064f_properties;\nstatic struct dvb_usb_device_properties cxusb_bluebird_dee1601_properties;\nstatic struct dvb_usb_device_properties cxusb_bluebird_lgz201_properties;\nstatic struct dvb_usb_device_properties cxusb_bluebird_dtt7579_properties;\nstatic struct dvb_usb_device_properties cxusb_bluebird_dualdig4_properties;\nstatic struct dvb_usb_device_properties cxusb_bluebird_dualdig4_rev2_properties;\nstatic struct dvb_usb_device_properties cxusb_bluebird_nano2_properties;\nstatic struct dvb_usb_device_properties cxusb_bluebird_nano2_needsfirmware_properties;\nstatic struct dvb_usb_device_properties cxusb_aver_a868r_properties;\nstatic struct dvb_usb_device_properties cxusb_d680_dmb_properties;\nstatic struct dvb_usb_device_properties cxusb_mygica_d689_properties;\nstatic struct dvb_usb_device_properties cxusb_mygica_t230_properties;\n\nstatic int cxusb_probe(struct usb_interface *intf,\n\t\t       const struct usb_device_id *id)\n{\n\tif (0 == dvb_usb_device_init(intf, &cxusb_medion_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &cxusb_bluebird_lgh064f_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &cxusb_bluebird_dee1601_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &cxusb_bluebird_lgz201_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &cxusb_bluebird_dtt7579_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &cxusb_bluebird_dualdig4_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &cxusb_bluebird_nano2_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf,\n\t\t\t\t&cxusb_bluebird_nano2_needsfirmware_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &cxusb_aver_a868r_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf,\n\t\t\t\t     &cxusb_bluebird_dualdig4_rev2_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &cxusb_d680_dmb_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &cxusb_mygica_d689_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &cxusb_mygica_t230_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0)\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic void cxusb_disconnect(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tstruct cxusb_state *st = d->priv;\n\tstruct i2c_client *client;\n\n\t/* remove I2C client for tuner */\n\tclient = st->i2c_client_tuner;\n\tif (client) {\n\t\tmodule_put(client->dev.driver->owner);\n\t\ti2c_unregister_device(client);\n\t}\n\n\t/* remove I2C client for demodulator */\n\tclient = st->i2c_client_demod;\n\tif (client) {\n\t\tmodule_put(client->dev.driver->owner);\n\t\ti2c_unregister_device(client);\n\t}\n\n\tdvb_usb_device_exit(intf);\n}\n\nenum cxusb_table_index {\n\tMEDION_MD95700,\n\tDVICO_BLUEBIRD_LG064F_COLD,\n\tDVICO_BLUEBIRD_LG064F_WARM,\n\tDVICO_BLUEBIRD_DUAL_1_COLD,\n\tDVICO_BLUEBIRD_DUAL_1_WARM,\n\tDVICO_BLUEBIRD_LGZ201_COLD,\n\tDVICO_BLUEBIRD_LGZ201_WARM,\n\tDVICO_BLUEBIRD_TH7579_COLD,\n\tDVICO_BLUEBIRD_TH7579_WARM,\n\tDIGITALNOW_BLUEBIRD_DUAL_1_COLD,\n\tDIGITALNOW_BLUEBIRD_DUAL_1_WARM,\n\tDVICO_BLUEBIRD_DUAL_2_COLD,\n\tDVICO_BLUEBIRD_DUAL_2_WARM,\n\tDVICO_BLUEBIRD_DUAL_4,\n\tDVICO_BLUEBIRD_DVB_T_NANO_2,\n\tDVICO_BLUEBIRD_DVB_T_NANO_2_NFW_WARM,\n\tAVERMEDIA_VOLAR_A868R,\n\tDVICO_BLUEBIRD_DUAL_4_REV_2,\n\tCONEXANT_D680_DMB,\n\tMYGICA_D689,\n\tMYGICA_T230,\n\tNR__cxusb_table_index\n};\n\nstatic struct usb_device_id cxusb_table[NR__cxusb_table_index + 1] = {\n\t[MEDION_MD95700] = {\n\t\tUSB_DEVICE(USB_VID_MEDION, USB_PID_MEDION_MD95700)\n\t},\n\t[DVICO_BLUEBIRD_LG064F_COLD] = {\n\t\tUSB_DEVICE(USB_VID_DVICO, USB_PID_DVICO_BLUEBIRD_LG064F_COLD)\n\t},\n\t[DVICO_BLUEBIRD_LG064F_WARM] = {\n\t\tUSB_DEVICE(USB_VID_DVICO, USB_PID_DVICO_BLUEBIRD_LG064F_WARM)\n\t},\n\t[DVICO_BLUEBIRD_DUAL_1_COLD] = {\n\t\tUSB_DEVICE(USB_VID_DVICO, USB_PID_DVICO_BLUEBIRD_DUAL_1_COLD)\n\t},\n\t[DVICO_BLUEBIRD_DUAL_1_WARM] = {\n\t\tUSB_DEVICE(USB_VID_DVICO, USB_PID_DVICO_BLUEBIRD_DUAL_1_WARM)\n\t},\n\t[DVICO_BLUEBIRD_LGZ201_COLD] = {\n\t\tUSB_DEVICE(USB_VID_DVICO, USB_PID_DVICO_BLUEBIRD_LGZ201_COLD)\n\t},\n\t[DVICO_BLUEBIRD_LGZ201_WARM] = {\n\t\tUSB_DEVICE(USB_VID_DVICO, USB_PID_DVICO_BLUEBIRD_LGZ201_WARM)\n\t},\n\t[DVICO_BLUEBIRD_TH7579_COLD] = {\n\t\tUSB_DEVICE(USB_VID_DVICO, USB_PID_DVICO_BLUEBIRD_TH7579_COLD)\n\t},\n\t[DVICO_BLUEBIRD_TH7579_WARM] = {\n\t\tUSB_DEVICE(USB_VID_DVICO, USB_PID_DVICO_BLUEBIRD_TH7579_WARM)\n\t},\n\t[DIGITALNOW_BLUEBIRD_DUAL_1_COLD] = {\n\t\tUSB_DEVICE(USB_VID_DVICO, USB_PID_DIGITALNOW_BLUEBIRD_DUAL_1_COLD)\n\t},\n\t[DIGITALNOW_BLUEBIRD_DUAL_1_WARM] = {\n\t\tUSB_DEVICE(USB_VID_DVICO, USB_PID_DIGITALNOW_BLUEBIRD_DUAL_1_WARM)\n\t},\n\t[DVICO_BLUEBIRD_DUAL_2_COLD] = {\n\t\tUSB_DEVICE(USB_VID_DVICO, USB_PID_DVICO_BLUEBIRD_DUAL_2_COLD)\n\t},\n\t[DVICO_BLUEBIRD_DUAL_2_WARM] = {\n\t\tUSB_DEVICE(USB_VID_DVICO, USB_PID_DVICO_BLUEBIRD_DUAL_2_WARM)\n\t},\n\t[DVICO_BLUEBIRD_DUAL_4] = {\n\t\tUSB_DEVICE(USB_VID_DVICO, USB_PID_DVICO_BLUEBIRD_DUAL_4)\n\t},\n\t[DVICO_BLUEBIRD_DVB_T_NANO_2] = {\n\t\tUSB_DEVICE(USB_VID_DVICO, USB_PID_DVICO_BLUEBIRD_DVB_T_NANO_2)\n\t},\n\t[DVICO_BLUEBIRD_DVB_T_NANO_2_NFW_WARM] = {\n\t\tUSB_DEVICE(USB_VID_DVICO, USB_PID_DVICO_BLUEBIRD_DVB_T_NANO_2_NFW_WARM)\n\t},\n\t[AVERMEDIA_VOLAR_A868R] = {\n\t\tUSB_DEVICE(USB_VID_AVERMEDIA, USB_PID_AVERMEDIA_VOLAR_A868R)\n\t},\n\t[DVICO_BLUEBIRD_DUAL_4_REV_2] = {\n\t\tUSB_DEVICE(USB_VID_DVICO, USB_PID_DVICO_BLUEBIRD_DUAL_4_REV_2)\n\t},\n\t[CONEXANT_D680_DMB] = {\n\t\tUSB_DEVICE(USB_VID_CONEXANT, USB_PID_CONEXANT_D680_DMB)\n\t},\n\t[MYGICA_D689] = {\n\t\tUSB_DEVICE(USB_VID_CONEXANT, USB_PID_MYGICA_D689)\n\t},\n\t[MYGICA_T230] = {\n\t\tUSB_DEVICE(USB_VID_CONEXANT, USB_PID_MYGICA_T230)\n\t},\n\t{}\t\t/* Terminating entry */\n};\nMODULE_DEVICE_TABLE (usb, cxusb_table);\n\nstatic struct dvb_usb_device_properties cxusb_medion_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl = CYPRESS_FX2,\n\n\t.size_of_priv     = sizeof(struct cxusb_state),\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl   = cxusb_streaming_ctrl,\n\t\t\t.frontend_attach  = cxusb_cx22702_frontend_attach,\n\t\t\t.tuner_attach     = cxusb_fmd1216me_tuner_attach,\n\t\t\t/* parameter for the MPEG2-data transfer */\n\t\t\t\t\t.stream = {\n\t\t\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 5,\n\t\t\t\t.endpoint = 0x02,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 8192,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t},\n\t},\n\t.power_ctrl       = cxusb_power_ctrl,\n\n\t.i2c_algo         = &cxusb_i2c_algo,\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{   \"Medion MD95700 (MDUSBTV-HYBRID)\",\n\t\t\t{ NULL },\n\t\t\t{ &cxusb_table[MEDION_MD95700], NULL },\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties cxusb_bluebird_lgh064f_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl          = DEVICE_SPECIFIC,\n\t.firmware          = \"dvb-usb-bluebird-01.fw\",\n\t.download_firmware = bluebird_patch_dvico_firmware_download,\n\t/* use usb alt setting 0 for EP4 transfer (dvb-t),\n\t   use usb alt setting 7 for EP2 transfer (atsc) */\n\n\t.size_of_priv     = sizeof(struct cxusb_state),\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl   = cxusb_streaming_ctrl,\n\t\t\t.frontend_attach  = cxusb_lgdt3303_frontend_attach,\n\t\t\t.tuner_attach     = cxusb_lgh064f_tuner_attach,\n\n\t\t\t/* parameter for the MPEG2-data transfer */\n\t\t\t\t\t.stream = {\n\t\t\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 5,\n\t\t\t\t.endpoint = 0x02,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 8192,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t},\n\t},\n\n\t.power_ctrl       = cxusb_bluebird_power_ctrl,\n\n\t.i2c_algo         = &cxusb_i2c_algo,\n\n\t.rc.core = {\n\t\t.rc_interval\t= 100,\n\t\t.rc_codes\t= RC_MAP_DVICO_PORTABLE,\n\t\t.module_name\t= KBUILD_MODNAME,\n\t\t.rc_query\t= cxusb_rc_query,\n\t\t.allowed_protos = RC_BIT_UNKNOWN,\n\t},\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{   \"DViCO FusionHDTV5 USB Gold\",\n\t\t\t{ &cxusb_table[DVICO_BLUEBIRD_LG064F_COLD], NULL },\n\t\t\t{ &cxusb_table[DVICO_BLUEBIRD_LG064F_WARM], NULL },\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties cxusb_bluebird_dee1601_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl          = DEVICE_SPECIFIC,\n\t.firmware          = \"dvb-usb-bluebird-01.fw\",\n\t.download_firmware = bluebird_patch_dvico_firmware_download,\n\t/* use usb alt setting 0 for EP4 transfer (dvb-t),\n\t   use usb alt setting 7 for EP2 transfer (atsc) */\n\n\t.size_of_priv     = sizeof(struct cxusb_state),\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl   = cxusb_streaming_ctrl,\n\t\t\t.frontend_attach  = cxusb_dee1601_frontend_attach,\n\t\t\t.tuner_attach     = cxusb_dee1601_tuner_attach,\n\t\t\t/* parameter for the MPEG2-data transfer */\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 5,\n\t\t\t\t.endpoint = 0x04,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 8192,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t},\n\t},\n\n\t.power_ctrl       = cxusb_bluebird_power_ctrl,\n\n\t.i2c_algo         = &cxusb_i2c_algo,\n\n\t.rc.core = {\n\t\t.rc_interval\t= 100,\n\t\t.rc_codes\t= RC_MAP_DVICO_MCE,\n\t\t.module_name\t= KBUILD_MODNAME,\n\t\t.rc_query\t= cxusb_rc_query,\n\t\t.allowed_protos = RC_BIT_UNKNOWN,\n\t},\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\n\t.num_device_descs = 3,\n\t.devices = {\n\t\t{   \"DViCO FusionHDTV DVB-T Dual USB\",\n\t\t\t{ &cxusb_table[DVICO_BLUEBIRD_DUAL_1_COLD], NULL },\n\t\t\t{ &cxusb_table[DVICO_BLUEBIRD_DUAL_1_WARM], NULL },\n\t\t},\n\t\t{   \"DigitalNow DVB-T Dual USB\",\n\t\t\t{ &cxusb_table[DIGITALNOW_BLUEBIRD_DUAL_1_COLD],  NULL },\n\t\t\t{ &cxusb_table[DIGITALNOW_BLUEBIRD_DUAL_1_WARM], NULL },\n\t\t},\n\t\t{   \"DViCO FusionHDTV DVB-T Dual Digital 2\",\n\t\t\t{ &cxusb_table[DVICO_BLUEBIRD_DUAL_2_COLD], NULL },\n\t\t\t{ &cxusb_table[DVICO_BLUEBIRD_DUAL_2_WARM], NULL },\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties cxusb_bluebird_lgz201_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl          = DEVICE_SPECIFIC,\n\t.firmware          = \"dvb-usb-bluebird-01.fw\",\n\t.download_firmware = bluebird_patch_dvico_firmware_download,\n\t/* use usb alt setting 0 for EP4 transfer (dvb-t),\n\t   use usb alt setting 7 for EP2 transfer (atsc) */\n\n\t.size_of_priv     = sizeof(struct cxusb_state),\n\n\t.num_adapters = 2,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl   = cxusb_streaming_ctrl,\n\t\t\t.frontend_attach  = cxusb_mt352_frontend_attach,\n\t\t\t.tuner_attach     = cxusb_lgz201_tuner_attach,\n\n\t\t\t/* parameter for the MPEG2-data transfer */\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 5,\n\t\t\t\t.endpoint = 0x04,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 8192,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t},\n\t},\n\t.power_ctrl       = cxusb_bluebird_power_ctrl,\n\n\t.i2c_algo         = &cxusb_i2c_algo,\n\n\t.rc.core = {\n\t\t.rc_interval\t= 100,\n\t\t.rc_codes\t= RC_MAP_DVICO_PORTABLE,\n\t\t.module_name\t= KBUILD_MODNAME,\n\t\t.rc_query\t= cxusb_rc_query,\n\t\t.allowed_protos = RC_BIT_UNKNOWN,\n\t},\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{   \"DViCO FusionHDTV DVB-T USB (LGZ201)\",\n\t\t\t{ &cxusb_table[DVICO_BLUEBIRD_LGZ201_COLD], NULL },\n\t\t\t{ &cxusb_table[DVICO_BLUEBIRD_LGZ201_WARM], NULL },\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties cxusb_bluebird_dtt7579_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl          = DEVICE_SPECIFIC,\n\t.firmware          = \"dvb-usb-bluebird-01.fw\",\n\t.download_firmware = bluebird_patch_dvico_firmware_download,\n\t/* use usb alt setting 0 for EP4 transfer (dvb-t),\n\t   use usb alt setting 7 for EP2 transfer (atsc) */\n\n\t.size_of_priv     = sizeof(struct cxusb_state),\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl   = cxusb_streaming_ctrl,\n\t\t\t.frontend_attach  = cxusb_mt352_frontend_attach,\n\t\t\t.tuner_attach     = cxusb_dtt7579_tuner_attach,\n\n\t\t\t/* parameter for the MPEG2-data transfer */\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 5,\n\t\t\t\t.endpoint = 0x04,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 8192,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t},\n\t},\n\t.power_ctrl       = cxusb_bluebird_power_ctrl,\n\n\t.i2c_algo         = &cxusb_i2c_algo,\n\n\t.rc.core = {\n\t\t.rc_interval\t= 100,\n\t\t.rc_codes\t= RC_MAP_DVICO_PORTABLE,\n\t\t.module_name\t= KBUILD_MODNAME,\n\t\t.rc_query\t= cxusb_rc_query,\n\t\t.allowed_protos = RC_BIT_UNKNOWN,\n\t},\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{   \"DViCO FusionHDTV DVB-T USB (TH7579)\",\n\t\t\t{ &cxusb_table[DVICO_BLUEBIRD_TH7579_COLD], NULL },\n\t\t\t{ &cxusb_table[DVICO_BLUEBIRD_TH7579_WARM], NULL },\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties cxusb_bluebird_dualdig4_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl         = CYPRESS_FX2,\n\n\t.size_of_priv     = sizeof(struct cxusb_state),\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl   = cxusb_streaming_ctrl,\n\t\t\t.frontend_attach  = cxusb_dualdig4_frontend_attach,\n\t\t\t.tuner_attach     = cxusb_dvico_xc3028_tuner_attach,\n\t\t\t/* parameter for the MPEG2-data transfer */\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 5,\n\t\t\t\t.endpoint = 0x02,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 8192,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t},\n\t},\n\n\t.power_ctrl       = cxusb_power_ctrl,\n\n\t.i2c_algo         = &cxusb_i2c_algo,\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\n\t.rc.core = {\n\t\t.rc_interval\t= 100,\n\t\t.rc_codes\t= RC_MAP_DVICO_MCE,\n\t\t.module_name\t= KBUILD_MODNAME,\n\t\t.rc_query\t= cxusb_bluebird2_rc_query,\n\t\t.allowed_protos = RC_BIT_UNKNOWN,\n\t},\n\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{   \"DViCO FusionHDTV DVB-T Dual Digital 4\",\n\t\t\t{ NULL },\n\t\t\t{ &cxusb_table[DVICO_BLUEBIRD_DUAL_4], NULL },\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties cxusb_bluebird_nano2_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl         = CYPRESS_FX2,\n\t.identify_state   = bluebird_fx2_identify_state,\n\n\t.size_of_priv     = sizeof(struct cxusb_state),\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl   = cxusb_streaming_ctrl,\n\t\t\t.frontend_attach  = cxusb_nano2_frontend_attach,\n\t\t\t.tuner_attach     = cxusb_dvico_xc3028_tuner_attach,\n\t\t\t/* parameter for the MPEG2-data transfer */\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 5,\n\t\t\t\t.endpoint = 0x02,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 8192,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t},\n\t},\n\n\t.power_ctrl       = cxusb_nano2_power_ctrl,\n\n\t.i2c_algo         = &cxusb_i2c_algo,\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\n\t.rc.core = {\n\t\t.rc_interval\t= 100,\n\t\t.rc_codes\t= RC_MAP_DVICO_PORTABLE,\n\t\t.module_name\t= KBUILD_MODNAME,\n\t\t.rc_query       = cxusb_bluebird2_rc_query,\n\t\t.allowed_protos = RC_BIT_UNKNOWN,\n\t},\n\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{   \"DViCO FusionHDTV DVB-T NANO2\",\n\t\t\t{ NULL },\n\t\t\t{ &cxusb_table[DVICO_BLUEBIRD_DVB_T_NANO_2], NULL },\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties cxusb_bluebird_nano2_needsfirmware_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl          = DEVICE_SPECIFIC,\n\t.firmware          = \"dvb-usb-bluebird-02.fw\",\n\t.download_firmware = bluebird_patch_dvico_firmware_download,\n\t.identify_state    = bluebird_fx2_identify_state,\n\n\t.size_of_priv      = sizeof(struct cxusb_state),\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl   = cxusb_streaming_ctrl,\n\t\t\t.frontend_attach  = cxusb_nano2_frontend_attach,\n\t\t\t.tuner_attach     = cxusb_dvico_xc3028_tuner_attach,\n\t\t\t/* parameter for the MPEG2-data transfer */\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 5,\n\t\t\t\t.endpoint = 0x02,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 8192,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t},\n\t},\n\n\t.power_ctrl       = cxusb_nano2_power_ctrl,\n\n\t.i2c_algo         = &cxusb_i2c_algo,\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\n\t.rc.core = {\n\t\t.rc_interval\t= 100,\n\t\t.rc_codes\t= RC_MAP_DVICO_PORTABLE,\n\t\t.module_name\t= KBUILD_MODNAME,\n\t\t.rc_query\t= cxusb_rc_query,\n\t\t.allowed_protos = RC_BIT_UNKNOWN,\n\t},\n\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{   \"DViCO FusionHDTV DVB-T NANO2 w/o firmware\",\n\t\t\t{ &cxusb_table[DVICO_BLUEBIRD_DVB_T_NANO_2], NULL },\n\t\t\t{ &cxusb_table[DVICO_BLUEBIRD_DVB_T_NANO_2_NFW_WARM], NULL },\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties cxusb_aver_a868r_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl         = CYPRESS_FX2,\n\n\t.size_of_priv     = sizeof(struct cxusb_state),\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl   = cxusb_aver_streaming_ctrl,\n\t\t\t.frontend_attach  = cxusb_aver_lgdt3303_frontend_attach,\n\t\t\t.tuner_attach     = cxusb_mxl5003s_tuner_attach,\n\t\t\t/* parameter for the MPEG2-data transfer */\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 5,\n\t\t\t\t.endpoint = 0x04,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 8192,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t},\n\t},\n\t.power_ctrl       = cxusb_aver_power_ctrl,\n\n\t.i2c_algo         = &cxusb_i2c_algo,\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{   \"AVerMedia AVerTVHD Volar (A868R)\",\n\t\t\t{ NULL },\n\t\t\t{ &cxusb_table[AVERMEDIA_VOLAR_A868R], NULL },\n\t\t},\n\t}\n};\n\nstatic\nstruct dvb_usb_device_properties cxusb_bluebird_dualdig4_rev2_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl         = CYPRESS_FX2,\n\n\t.size_of_priv     = sizeof(struct cxusb_state),\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.size_of_priv    = sizeof(struct dib0700_adapter_state),\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl  = cxusb_streaming_ctrl,\n\t\t\t.frontend_attach = cxusb_dualdig4_rev2_frontend_attach,\n\t\t\t.tuner_attach    = cxusb_dualdig4_rev2_tuner_attach,\n\t\t\t/* parameter for the MPEG2-data transfer */\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 7,\n\t\t\t\t.endpoint = 0x02,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 4096,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t},\n\t},\n\n\t.power_ctrl       = cxusb_bluebird_power_ctrl,\n\n\t.i2c_algo         = &cxusb_i2c_algo,\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\n\t.rc.core = {\n\t\t.rc_interval\t= 100,\n\t\t.rc_codes\t= RC_MAP_DVICO_MCE,\n\t\t.module_name\t= KBUILD_MODNAME,\n\t\t.rc_query\t= cxusb_rc_query,\n\t\t.allowed_protos = RC_BIT_UNKNOWN,\n\t},\n\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{   \"DViCO FusionHDTV DVB-T Dual Digital 4 (rev 2)\",\n\t\t\t{ NULL },\n\t\t\t{ &cxusb_table[DVICO_BLUEBIRD_DUAL_4_REV_2], NULL },\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties cxusb_d680_dmb_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl         = CYPRESS_FX2,\n\n\t.size_of_priv     = sizeof(struct cxusb_state),\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl   = cxusb_d680_dmb_streaming_ctrl,\n\t\t\t.frontend_attach  = cxusb_d680_dmb_frontend_attach,\n\t\t\t.tuner_attach     = cxusb_d680_dmb_tuner_attach,\n\n\t\t\t/* parameter for the MPEG2-data transfer */\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 5,\n\t\t\t\t.endpoint = 0x02,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 8192,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t},\n\t},\n\n\t.power_ctrl       = cxusb_d680_dmb_power_ctrl,\n\n\t.i2c_algo         = &cxusb_i2c_algo,\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\n\t.rc.core = {\n\t\t.rc_interval\t= 100,\n\t\t.rc_codes\t= RC_MAP_D680_DMB,\n\t\t.module_name\t= KBUILD_MODNAME,\n\t\t.rc_query       = cxusb_d680_dmb_rc_query,\n\t\t.allowed_protos = RC_BIT_UNKNOWN,\n\t},\n\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{\n\t\t\t\"Conexant DMB-TH Stick\",\n\t\t\t{ NULL },\n\t\t\t{ &cxusb_table[CONEXANT_D680_DMB], NULL },\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties cxusb_mygica_d689_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl         = CYPRESS_FX2,\n\n\t.size_of_priv     = sizeof(struct cxusb_state),\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl   = cxusb_d680_dmb_streaming_ctrl,\n\t\t\t.frontend_attach  = cxusb_mygica_d689_frontend_attach,\n\t\t\t.tuner_attach     = cxusb_mygica_d689_tuner_attach,\n\n\t\t\t/* parameter for the MPEG2-data transfer */\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 5,\n\t\t\t\t.endpoint = 0x02,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 8192,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t},\n\t},\n\n\t.power_ctrl       = cxusb_d680_dmb_power_ctrl,\n\n\t.i2c_algo         = &cxusb_i2c_algo,\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\n\t.rc.core = {\n\t\t.rc_interval\t= 100,\n\t\t.rc_codes\t= RC_MAP_D680_DMB,\n\t\t.module_name\t= KBUILD_MODNAME,\n\t\t.rc_query       = cxusb_d680_dmb_rc_query,\n\t\t.allowed_protos = RC_BIT_UNKNOWN,\n\t},\n\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{\n\t\t\t\"Mygica D689 DMB-TH\",\n\t\t\t{ NULL },\n\t\t\t{ &cxusb_table[MYGICA_D689], NULL },\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties cxusb_mygica_t230_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl         = CYPRESS_FX2,\n\n\t.size_of_priv     = sizeof(struct cxusb_state),\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl   = cxusb_streaming_ctrl,\n\t\t\t.frontend_attach  = cxusb_mygica_t230_frontend_attach,\n\n\t\t\t/* parameter for the MPEG2-data transfer */\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 5,\n\t\t\t\t.endpoint = 0x02,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 8192,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t} },\n\t\t},\n\t},\n\n\t.power_ctrl       = cxusb_d680_dmb_power_ctrl,\n\n\t.i2c_algo         = &cxusb_i2c_algo,\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\n\t.rc.core = {\n\t\t.rc_interval\t= 100,\n\t\t.rc_codes\t= RC_MAP_D680_DMB,\n\t\t.module_name\t= KBUILD_MODNAME,\n\t\t.rc_query       = cxusb_d680_dmb_rc_query,\n\t\t.allowed_protos = RC_BIT_UNKNOWN,\n\t},\n\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{\n\t\t\t\"Mygica T230 DVB-T/T2/C\",\n\t\t\t{ NULL },\n\t\t\t{ &cxusb_table[MYGICA_T230], NULL },\n\t\t},\n\t}\n};\n\nstatic struct usb_driver cxusb_driver = {\n\t.name\t\t= \"dvb_usb_cxusb\",\n\t.probe\t\t= cxusb_probe,\n\t.disconnect     = cxusb_disconnect,\n\t.id_table\t= cxusb_table,\n};\n\nmodule_usb_driver(cxusb_driver);\n\nMODULE_AUTHOR(\"Patrick Boettcher <patrick.boettcher@posteo.de>\");\nMODULE_AUTHOR(\"Michael Krufky <mkrufky@linuxtv.org>\");\nMODULE_AUTHOR(\"Chris Pascoe <c.pascoe@itee.uq.edu.au>\");\nMODULE_DESCRIPTION(\"Driver for Conexant USB2.0 hybrid reference design\");\nMODULE_VERSION(\"1.0-alpha\");\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["/* DVB USB compliant linux driver for Conexant USB reference design.\n *\n * The Conexant reference design I saw on their website was only for analogue\n * capturing (using the cx25842). The box I took to write this driver (reverse\n * engineered) is the one labeled Medion MD95700. In addition to the cx25842\n * for analogue capturing it also has a cx22702 DVB-T demodulator on the main\n * board. Besides it has a atiremote (X10) and a USB2.0 hub onboard.\n *\n * Maybe it is a little bit premature to call this driver cxusb, but I assume\n * the USB protocol is identical or at least inherited from the reference\n * design, so it can be reused for the \"analogue-only\" device (if it will\n * appear at all).\n *\n * TODO: Use the cx25840-driver for the analogue part\n *\n * Copyright (C) 2005 Patrick Boettcher (patrick.boettcher@posteo.de)\n * Copyright (C) 2006 Michael Krufky (mkrufky@linuxtv.org)\n * Copyright (C) 2006, 2007 Chris Pascoe (c.pascoe@itee.uq.edu.au)\n *\n *   This program is free software; you can redistribute it and/or modify it\n *   under the terms of the GNU General Public License as published by the Free\n *   Software Foundation, version 2.\n *\n * see Documentation/dvb/README.dvb-usb for more information\n */\n#include <media/tuner.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n\n#include \"cxusb.h\"\n\n#include \"cx22702.h\"\n#include \"lgdt330x.h\"\n#include \"mt352.h\"\n#include \"mt352_priv.h\"\n#include \"zl10353.h\"\n#include \"tuner-xc2028.h\"\n#include \"tuner-simple.h\"\n#include \"mxl5005s.h\"\n#include \"max2165.h\"\n#include \"dib7000p.h\"\n#include \"dib0070.h\"\n#include \"lgs8gxx.h\"\n#include \"atbm8830.h\"\n#include \"si2168.h\"\n#include \"si2157.h\"\n\n/* debug */\nstatic int dvb_usb_cxusb_debug;\nmodule_param_named(debug, dvb_usb_cxusb_debug, int, 0644);\nMODULE_PARM_DESC(debug, \"set debugging level (1=rc (or-able)).\" DVB_USB_DEBUG_STATUS);\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\n#define deb_info(args...)   dprintk(dvb_usb_cxusb_debug, 0x03, args)\n#define deb_i2c(args...)    dprintk(dvb_usb_cxusb_debug, 0x02, args)\n\nstatic int cxusb_ctrl_msg(struct dvb_usb_device *d,\n\t\t\t  u8 cmd, u8 *wbuf, int wlen, u8 *rbuf, int rlen)\n{\n\tstruct cxusb_state *st = d->priv;\n\tint ret;\n\n\tif (1 + wlen > MAX_XFER_SIZE) {\n\t\twarn(\"i2c wr: len=%d is too big!\\n\", wlen);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (rlen > MAX_XFER_SIZE) {\n\t\twarn(\"i2c rd: len=%d is too big!\\n\", rlen);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmutex_lock(&d->data_mutex);\n\tst->data[0] = cmd;\n\tmemcpy(&st->data[1], wbuf, wlen);\n\tret = dvb_usb_generic_rw(d, st->data, 1 + wlen, st->data, rlen, 0);\n\tif (!ret && rbuf && rlen)\n\t\tmemcpy(rbuf, st->data, rlen);\n\n\tmutex_unlock(&d->data_mutex);\n\treturn ret;\n}\n\n/* GPIO */\nstatic void cxusb_gpio_tuner(struct dvb_usb_device *d, int onoff)\n{\n\tstruct cxusb_state *st = d->priv;\n\tu8 o[2], i;\n\n\tif (st->gpio_write_state[GPIO_TUNER] == onoff)\n\t\treturn;\n\n\to[0] = GPIO_TUNER;\n\to[1] = onoff;\n\tcxusb_ctrl_msg(d, CMD_GPIO_WRITE, o, 2, &i, 1);\n\n\tif (i != 0x01)\n\t\tdeb_info(\"gpio_write failed.\\n\");\n\n\tst->gpio_write_state[GPIO_TUNER] = onoff;\n}\n\nstatic int cxusb_bluebird_gpio_rw(struct dvb_usb_device *d, u8 changemask,\n\t\t\t\t u8 newval)\n{\n\tu8 o[2], gpio_state;\n\tint rc;\n\n\to[0] = 0xff & ~changemask;\t/* mask of bits to keep */\n\to[1] = newval & changemask;\t/* new values for bits  */\n\n\trc = cxusb_ctrl_msg(d, CMD_BLUEBIRD_GPIO_RW, o, 2, &gpio_state, 1);\n\tif (rc < 0 || (gpio_state & changemask) != (newval & changemask))\n\t\tdeb_info(\"bluebird_gpio_write failed.\\n\");\n\n\treturn rc < 0 ? rc : gpio_state;\n}\n\nstatic void cxusb_bluebird_gpio_pulse(struct dvb_usb_device *d, u8 pin, int low)\n{\n\tcxusb_bluebird_gpio_rw(d, pin, low ? 0 : pin);\n\tmsleep(5);\n\tcxusb_bluebird_gpio_rw(d, pin, low ? pin : 0);\n}\n\nstatic void cxusb_nano2_led(struct dvb_usb_device *d, int onoff)\n{\n\tcxusb_bluebird_gpio_rw(d, 0x40, onoff ? 0 : 0x40);\n}\n\nstatic int cxusb_d680_dmb_gpio_tuner(struct dvb_usb_device *d,\n\t\tu8 addr, int onoff)\n{\n\tu8  o[2] = {addr, onoff};\n\tu8  i;\n\tint rc;\n\n\trc = cxusb_ctrl_msg(d, CMD_GPIO_WRITE, o, 2, &i, 1);\n\n\tif (rc < 0)\n\t\treturn rc;\n\tif (i == 0x01)\n\t\treturn 0;\n\telse {\n\t\tdeb_info(\"gpio_write failed.\\n\");\n\t\treturn -EIO;\n\t}\n}\n\n/* I2C */\nstatic int cxusb_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],\n\t\t\t  int num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tint ret;\n\tint i;\n\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tfor (i = 0; i < num; i++) {\n\n\t\tif (le16_to_cpu(d->udev->descriptor.idVendor) == USB_VID_MEDION)\n\t\t\tswitch (msg[i].addr) {\n\t\t\tcase 0x63:\n\t\t\t\tcxusb_gpio_tuner(d, 0);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcxusb_gpio_tuner(d, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (msg[i].flags & I2C_M_RD) {\n\t\t\t/* read only */\n\t\t\tu8 obuf[3], ibuf[MAX_XFER_SIZE];\n\n\t\t\tif (1 + msg[i].len > sizeof(ibuf)) {\n\t\t\t\twarn(\"i2c rd: len=%d is too big!\\n\",\n\t\t\t\t     msg[i].len);\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\tobuf[0] = 0;\n\t\t\tobuf[1] = msg[i].len;\n\t\t\tobuf[2] = msg[i].addr;\n\t\t\tif (cxusb_ctrl_msg(d, CMD_I2C_READ,\n\t\t\t\t\t   obuf, 3,\n\t\t\t\t\t   ibuf, 1+msg[i].len) < 0) {\n\t\t\t\twarn(\"i2c read failed\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(msg[i].buf, &ibuf[1], msg[i].len);\n\t\t} else if (i+1 < num && (msg[i+1].flags & I2C_M_RD) &&\n\t\t\t   msg[i].addr == msg[i+1].addr) {\n\t\t\t/* write to then read from same address */\n\t\t\tu8 obuf[MAX_XFER_SIZE], ibuf[MAX_XFER_SIZE];\n\n\t\t\tif (3 + msg[i].len > sizeof(obuf)) {\n\t\t\t\twarn(\"i2c wr: len=%d is too big!\\n\",\n\t\t\t\t     msg[i].len);\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\tif (1 + msg[i + 1].len > sizeof(ibuf)) {\n\t\t\t\twarn(\"i2c rd: len=%d is too big!\\n\",\n\t\t\t\t     msg[i + 1].len);\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\tobuf[0] = msg[i].len;\n\t\t\tobuf[1] = msg[i+1].len;\n\t\t\tobuf[2] = msg[i].addr;\n\t\t\tmemcpy(&obuf[3], msg[i].buf, msg[i].len);\n\n\t\t\tif (cxusb_ctrl_msg(d, CMD_I2C_READ,\n\t\t\t\t\t   obuf, 3+msg[i].len,\n\t\t\t\t\t   ibuf, 1+msg[i+1].len) < 0)\n\t\t\t\tbreak;\n\n\t\t\tif (ibuf[0] != 0x08)\n\t\t\t\tdeb_i2c(\"i2c read may have failed\\n\");\n\n\t\t\tmemcpy(msg[i+1].buf, &ibuf[1], msg[i+1].len);\n\n\t\t\ti++;\n\t\t} else {\n\t\t\t/* write only */\n\t\t\tu8 obuf[MAX_XFER_SIZE], ibuf;\n\n\t\t\tif (2 + msg[i].len > sizeof(obuf)) {\n\t\t\t\twarn(\"i2c wr: len=%d is too big!\\n\",\n\t\t\t\t     msg[i].len);\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\tobuf[0] = msg[i].addr;\n\t\t\tobuf[1] = msg[i].len;\n\t\t\tmemcpy(&obuf[2], msg[i].buf, msg[i].len);\n\n\t\t\tif (cxusb_ctrl_msg(d, CMD_I2C_WRITE, obuf,\n\t\t\t\t\t   2+msg[i].len, &ibuf,1) < 0)\n\t\t\t\tbreak;\n\t\t\tif (ibuf != 0x08)\n\t\t\t\tdeb_i2c(\"i2c write may have failed\\n\");\n\t\t}\n\t}\n\n\tif (i == num)\n\t\tret = num;\n\telse\n\t\tret = -EREMOTEIO;\n\nunlock:\n\tmutex_unlock(&d->i2c_mutex);\n\treturn ret;\n}\n\nstatic u32 cxusb_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic struct i2c_algorithm cxusb_i2c_algo = {\n\t.master_xfer   = cxusb_i2c_xfer,\n\t.functionality = cxusb_i2c_func,\n};\n\nstatic int cxusb_power_ctrl(struct dvb_usb_device *d, int onoff)\n{\n\tu8 b = 0;\n\tif (onoff)\n\t\treturn cxusb_ctrl_msg(d, CMD_POWER_ON, &b, 1, NULL, 0);\n\telse\n\t\treturn cxusb_ctrl_msg(d, CMD_POWER_OFF, &b, 1, NULL, 0);\n}\n\nstatic int cxusb_aver_power_ctrl(struct dvb_usb_device *d, int onoff)\n{\n\tint ret;\n\tif (!onoff)\n\t\treturn cxusb_ctrl_msg(d, CMD_POWER_OFF, NULL, 0, NULL, 0);\n\tif (d->state == DVB_USB_STATE_INIT &&\n\t    usb_set_interface(d->udev, 0, 0) < 0)\n\t\terr(\"set interface failed\");\n\tdo {} while (!(ret = cxusb_ctrl_msg(d, CMD_POWER_ON, NULL, 0, NULL, 0)) &&\n\t\t   !(ret = cxusb_ctrl_msg(d, 0x15, NULL, 0, NULL, 0)) &&\n\t\t   !(ret = cxusb_ctrl_msg(d, 0x17, NULL, 0, NULL, 0)) && 0);\n\tif (!ret) {\n\t\t/* FIXME: We don't know why, but we need to configure the\n\t\t * lgdt3303 with the register settings below on resume */\n\t\tint i;\n\t\tu8 buf, bufs[] = {\n\t\t\t0x0e, 0x2, 0x00, 0x7f,\n\t\t\t0x0e, 0x2, 0x02, 0xfe,\n\t\t\t0x0e, 0x2, 0x02, 0x01,\n\t\t\t0x0e, 0x2, 0x00, 0x03,\n\t\t\t0x0e, 0x2, 0x0d, 0x40,\n\t\t\t0x0e, 0x2, 0x0e, 0x87,\n\t\t\t0x0e, 0x2, 0x0f, 0x8e,\n\t\t\t0x0e, 0x2, 0x10, 0x01,\n\t\t\t0x0e, 0x2, 0x14, 0xd7,\n\t\t\t0x0e, 0x2, 0x47, 0x88,\n\t\t};\n\t\tmsleep(20);\n\t\tfor (i = 0; i < sizeof(bufs)/sizeof(u8); i += 4/sizeof(u8)) {\n\t\t\tret = cxusb_ctrl_msg(d, CMD_I2C_WRITE,\n\t\t\t\t\t     bufs+i, 4, &buf, 1);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tif (buf != 0x8)\n\t\t\t\treturn -EREMOTEIO;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int cxusb_bluebird_power_ctrl(struct dvb_usb_device *d, int onoff)\n{\n\tu8 b = 0;\n\tif (onoff)\n\t\treturn cxusb_ctrl_msg(d, CMD_POWER_ON, &b, 1, NULL, 0);\n\telse\n\t\treturn 0;\n}\n\nstatic int cxusb_nano2_power_ctrl(struct dvb_usb_device *d, int onoff)\n{\n\tint rc = 0;\n\n\trc = cxusb_power_ctrl(d, onoff);\n\tif (!onoff)\n\t\tcxusb_nano2_led(d, 0);\n\n\treturn rc;\n}\n\nstatic int cxusb_d680_dmb_power_ctrl(struct dvb_usb_device *d, int onoff)\n{\n\tint ret;\n\tu8  b;\n\tret = cxusb_power_ctrl(d, onoff);\n\tif (!onoff)\n\t\treturn ret;\n\n\tmsleep(128);\n\tcxusb_ctrl_msg(d, CMD_DIGITAL, NULL, 0, &b, 1);\n\tmsleep(100);\n\treturn ret;\n}\n\nstatic int cxusb_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)\n{\n\tu8 buf[2] = { 0x03, 0x00 };\n\tif (onoff)\n\t\tcxusb_ctrl_msg(adap->dev, CMD_STREAMING_ON, buf, 2, NULL, 0);\n\telse\n\t\tcxusb_ctrl_msg(adap->dev, CMD_STREAMING_OFF, NULL, 0, NULL, 0);\n\n\treturn 0;\n}\n\nstatic int cxusb_aver_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)\n{\n\tif (onoff)\n\t\tcxusb_ctrl_msg(adap->dev, CMD_AVER_STREAM_ON, NULL, 0, NULL, 0);\n\telse\n\t\tcxusb_ctrl_msg(adap->dev, CMD_AVER_STREAM_OFF,\n\t\t\t       NULL, 0, NULL, 0);\n\treturn 0;\n}\n\nstatic int cxusb_read_status(struct dvb_frontend *fe,\n\t\t\t\t  enum fe_status *status)\n{\n\tstruct dvb_usb_adapter *adap = (struct dvb_usb_adapter *)fe->dvb->priv;\n\tstruct cxusb_state *state = (struct cxusb_state *)adap->dev->priv;\n\tint ret;\n\n\tret = state->fe_read_status(fe, status);\n\n\t/* it need resync slave fifo when signal change from unlock to lock.*/\n\tif ((*status & FE_HAS_LOCK) && (!state->last_lock)) {\n\t\tmutex_lock(&state->stream_mutex);\n\t\tcxusb_streaming_ctrl(adap, 1);\n\t\tmutex_unlock(&state->stream_mutex);\n\t}\n\n\tstate->last_lock = (*status & FE_HAS_LOCK) ? 1 : 0;\n\treturn ret;\n}\n\nstatic void cxusb_d680_dmb_drain_message(struct dvb_usb_device *d)\n{\n\tint       ep = d->props.generic_bulk_ctrl_endpoint;\n\tconst int timeout = 100;\n\tconst int junk_len = 32;\n\tu8        *junk;\n\tint       rd_count;\n\n\t/* Discard remaining data in video pipe */\n\tjunk = kmalloc(junk_len, GFP_KERNEL);\n\tif (!junk)\n\t\treturn;\n\twhile (1) {\n\t\tif (usb_bulk_msg(d->udev,\n\t\t\tusb_rcvbulkpipe(d->udev, ep),\n\t\t\tjunk, junk_len, &rd_count, timeout) < 0)\n\t\t\tbreak;\n\t\tif (!rd_count)\n\t\t\tbreak;\n\t}\n\tkfree(junk);\n}\n\nstatic void cxusb_d680_dmb_drain_video(struct dvb_usb_device *d)\n{\n\tstruct usb_data_stream_properties *p = &d->props.adapter[0].fe[0].stream;\n\tconst int timeout = 100;\n\tconst int junk_len = p->u.bulk.buffersize;\n\tu8        *junk;\n\tint       rd_count;\n\n\t/* Discard remaining data in video pipe */\n\tjunk = kmalloc(junk_len, GFP_KERNEL);\n\tif (!junk)\n\t\treturn;\n\twhile (1) {\n\t\tif (usb_bulk_msg(d->udev,\n\t\t\tusb_rcvbulkpipe(d->udev, p->endpoint),\n\t\t\tjunk, junk_len, &rd_count, timeout) < 0)\n\t\t\tbreak;\n\t\tif (!rd_count)\n\t\t\tbreak;\n\t}\n\tkfree(junk);\n}\n\nstatic int cxusb_d680_dmb_streaming_ctrl(\n\t\tstruct dvb_usb_adapter *adap, int onoff)\n{\n\tif (onoff) {\n\t\tu8 buf[2] = { 0x03, 0x00 };\n\t\tcxusb_d680_dmb_drain_video(adap->dev);\n\t\treturn cxusb_ctrl_msg(adap->dev, CMD_STREAMING_ON,\n\t\t\tbuf, sizeof(buf), NULL, 0);\n\t} else {\n\t\tint ret = cxusb_ctrl_msg(adap->dev,\n\t\t\tCMD_STREAMING_OFF, NULL, 0, NULL, 0);\n\t\treturn ret;\n\t}\n}\n\nstatic int cxusb_rc_query(struct dvb_usb_device *d)\n{\n\tu8 ircode[4];\n\n\tcxusb_ctrl_msg(d, CMD_GET_IR_CODE, NULL, 0, ircode, 4);\n\n\tif (ircode[2] || ircode[3])\n\t\trc_keydown(d->rc_dev, RC_TYPE_UNKNOWN,\n\t\t\t   RC_SCANCODE_RC5(ircode[2], ircode[3]), 0);\n\treturn 0;\n}\n\nstatic int cxusb_bluebird2_rc_query(struct dvb_usb_device *d)\n{\n\tu8 ircode[4];\n\tstruct i2c_msg msg = { .addr = 0x6b, .flags = I2C_M_RD,\n\t\t\t       .buf = ircode, .len = 4 };\n\n\tif (cxusb_i2c_xfer(&d->i2c_adap, &msg, 1) != 1)\n\t\treturn 0;\n\n\tif (ircode[1] || ircode[2])\n\t\trc_keydown(d->rc_dev, RC_TYPE_UNKNOWN,\n\t\t\t   RC_SCANCODE_RC5(ircode[1], ircode[2]), 0);\n\treturn 0;\n}\n\nstatic int cxusb_d680_dmb_rc_query(struct dvb_usb_device *d)\n{\n\tu8 ircode[2];\n\n\tif (cxusb_ctrl_msg(d, 0x10, NULL, 0, ircode, 2) < 0)\n\t\treturn 0;\n\n\tif (ircode[0] || ircode[1])\n\t\trc_keydown(d->rc_dev, RC_TYPE_UNKNOWN,\n\t\t\t   RC_SCANCODE_RC5(ircode[0], ircode[1]), 0);\n\treturn 0;\n}\n\nstatic int cxusb_dee1601_demod_init(struct dvb_frontend* fe)\n{\n\tstatic u8 clock_config []  = { CLOCK_CTL,  0x38, 0x28 };\n\tstatic u8 reset []         = { RESET,      0x80 };\n\tstatic u8 adc_ctl_1_cfg [] = { ADC_CTL_1,  0x40 };\n\tstatic u8 agc_cfg []       = { AGC_TARGET, 0x28, 0x20 };\n\tstatic u8 gpp_ctl_cfg []   = { GPP_CTL,    0x33 };\n\tstatic u8 capt_range_cfg[] = { CAPT_RANGE, 0x32 };\n\n\tmt352_write(fe, clock_config,   sizeof(clock_config));\n\tudelay(200);\n\tmt352_write(fe, reset,          sizeof(reset));\n\tmt352_write(fe, adc_ctl_1_cfg,  sizeof(adc_ctl_1_cfg));\n\n\tmt352_write(fe, agc_cfg,        sizeof(agc_cfg));\n\tmt352_write(fe, gpp_ctl_cfg,    sizeof(gpp_ctl_cfg));\n\tmt352_write(fe, capt_range_cfg, sizeof(capt_range_cfg));\n\n\treturn 0;\n}\n\nstatic int cxusb_mt352_demod_init(struct dvb_frontend* fe)\n{\t/* used in both lgz201 and th7579 */\n\tstatic u8 clock_config []  = { CLOCK_CTL,  0x38, 0x29 };\n\tstatic u8 reset []         = { RESET,      0x80 };\n\tstatic u8 adc_ctl_1_cfg [] = { ADC_CTL_1,  0x40 };\n\tstatic u8 agc_cfg []       = { AGC_TARGET, 0x24, 0x20 };\n\tstatic u8 gpp_ctl_cfg []   = { GPP_CTL,    0x33 };\n\tstatic u8 capt_range_cfg[] = { CAPT_RANGE, 0x32 };\n\n\tmt352_write(fe, clock_config,   sizeof(clock_config));\n\tudelay(200);\n\tmt352_write(fe, reset,          sizeof(reset));\n\tmt352_write(fe, adc_ctl_1_cfg,  sizeof(adc_ctl_1_cfg));\n\n\tmt352_write(fe, agc_cfg,        sizeof(agc_cfg));\n\tmt352_write(fe, gpp_ctl_cfg,    sizeof(gpp_ctl_cfg));\n\tmt352_write(fe, capt_range_cfg, sizeof(capt_range_cfg));\n\treturn 0;\n}\n\nstatic struct cx22702_config cxusb_cx22702_config = {\n\t.demod_address = 0x63,\n\t.output_mode = CX22702_PARALLEL_OUTPUT,\n};\n\nstatic struct lgdt330x_config cxusb_lgdt3303_config = {\n\t.demod_address = 0x0e,\n\t.demod_chip    = LGDT3303,\n};\n\nstatic struct lgdt330x_config cxusb_aver_lgdt3303_config = {\n\t.demod_address       = 0x0e,\n\t.demod_chip          = LGDT3303,\n\t.clock_polarity_flip = 2,\n};\n\nstatic struct mt352_config cxusb_dee1601_config = {\n\t.demod_address = 0x0f,\n\t.demod_init    = cxusb_dee1601_demod_init,\n};\n\nstatic struct zl10353_config cxusb_zl10353_dee1601_config = {\n\t.demod_address = 0x0f,\n\t.parallel_ts = 1,\n};\n\nstatic struct mt352_config cxusb_mt352_config = {\n\t/* used in both lgz201 and th7579 */\n\t.demod_address = 0x0f,\n\t.demod_init    = cxusb_mt352_demod_init,\n};\n\nstatic struct zl10353_config cxusb_zl10353_xc3028_config = {\n\t.demod_address = 0x0f,\n\t.if2 = 45600,\n\t.no_tuner = 1,\n\t.parallel_ts = 1,\n};\n\nstatic struct zl10353_config cxusb_zl10353_xc3028_config_no_i2c_gate = {\n\t.demod_address = 0x0f,\n\t.if2 = 45600,\n\t.no_tuner = 1,\n\t.parallel_ts = 1,\n\t.disable_i2c_gate_ctrl = 1,\n};\n\nstatic struct mt352_config cxusb_mt352_xc3028_config = {\n\t.demod_address = 0x0f,\n\t.if2 = 4560,\n\t.no_tuner = 1,\n\t.demod_init = cxusb_mt352_demod_init,\n};\n\n/* FIXME: needs tweaking */\nstatic struct mxl5005s_config aver_a868r_tuner = {\n\t.i2c_address     = 0x63,\n\t.if_freq         = 6000000UL,\n\t.xtal_freq       = CRYSTAL_FREQ_16000000HZ,\n\t.agc_mode        = MXL_SINGLE_AGC,\n\t.tracking_filter = MXL_TF_C,\n\t.rssi_enable     = MXL_RSSI_ENABLE,\n\t.cap_select      = MXL_CAP_SEL_ENABLE,\n\t.div_out         = MXL_DIV_OUT_4,\n\t.clock_out       = MXL_CLOCK_OUT_DISABLE,\n\t.output_load     = MXL5005S_IF_OUTPUT_LOAD_200_OHM,\n\t.top\t\t = MXL5005S_TOP_25P2,\n\t.mod_mode        = MXL_DIGITAL_MODE,\n\t.if_mode         = MXL_ZERO_IF,\n\t.AgcMasterByte   = 0x00,\n};\n\n/* FIXME: needs tweaking */\nstatic struct mxl5005s_config d680_dmb_tuner = {\n\t.i2c_address     = 0x63,\n\t.if_freq         = 36125000UL,\n\t.xtal_freq       = CRYSTAL_FREQ_16000000HZ,\n\t.agc_mode        = MXL_SINGLE_AGC,\n\t.tracking_filter = MXL_TF_C,\n\t.rssi_enable     = MXL_RSSI_ENABLE,\n\t.cap_select      = MXL_CAP_SEL_ENABLE,\n\t.div_out         = MXL_DIV_OUT_4,\n\t.clock_out       = MXL_CLOCK_OUT_DISABLE,\n\t.output_load     = MXL5005S_IF_OUTPUT_LOAD_200_OHM,\n\t.top\t\t = MXL5005S_TOP_25P2,\n\t.mod_mode        = MXL_DIGITAL_MODE,\n\t.if_mode         = MXL_ZERO_IF,\n\t.AgcMasterByte   = 0x00,\n};\n\nstatic struct max2165_config mygica_d689_max2165_cfg = {\n\t.i2c_address = 0x60,\n\t.osc_clk = 20\n};\n\n/* Callbacks for DVB USB */\nstatic int cxusb_fmd1216me_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tdvb_attach(simple_tuner_attach, adap->fe_adap[0].fe,\n\t\t   &adap->dev->i2c_adap, 0x61,\n\t\t   TUNER_PHILIPS_FMD1216ME_MK3);\n\treturn 0;\n}\n\nstatic int cxusb_dee1601_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tdvb_attach(dvb_pll_attach, adap->fe_adap[0].fe, 0x61,\n\t\t   NULL, DVB_PLL_THOMSON_DTT7579);\n\treturn 0;\n}\n\nstatic int cxusb_lgz201_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tdvb_attach(dvb_pll_attach, adap->fe_adap[0].fe, 0x61, NULL, DVB_PLL_LG_Z201);\n\treturn 0;\n}\n\nstatic int cxusb_dtt7579_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tdvb_attach(dvb_pll_attach, adap->fe_adap[0].fe, 0x60,\n\t\t   NULL, DVB_PLL_THOMSON_DTT7579);\n\treturn 0;\n}\n\nstatic int cxusb_lgh064f_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tdvb_attach(simple_tuner_attach, adap->fe_adap[0].fe,\n\t\t   &adap->dev->i2c_adap, 0x61, TUNER_LG_TDVS_H06XF);\n\treturn 0;\n}\n\nstatic int dvico_bluebird_xc2028_callback(void *ptr, int component,\n\t\t\t\t\t  int command, int arg)\n{\n\tstruct dvb_usb_adapter *adap = ptr;\n\tstruct dvb_usb_device *d = adap->dev;\n\n\tswitch (command) {\n\tcase XC2028_TUNER_RESET:\n\t\tdeb_info(\"%s: XC2028_TUNER_RESET %d\\n\", __func__, arg);\n\t\tcxusb_bluebird_gpio_pulse(d, 0x01, 1);\n\t\tbreak;\n\tcase XC2028_RESET_CLK:\n\t\tdeb_info(\"%s: XC2028_RESET_CLK %d\\n\", __func__, arg);\n\t\tbreak;\n\tdefault:\n\t\tdeb_info(\"%s: unknown command %d, arg %d\\n\", __func__,\n\t\t\t command, arg);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cxusb_dvico_xc3028_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_frontend\t *fe;\n\tstruct xc2028_config\t  cfg = {\n\t\t.i2c_adap  = &adap->dev->i2c_adap,\n\t\t.i2c_addr  = 0x61,\n\t};\n\tstatic struct xc2028_ctrl ctl = {\n\t\t.fname       = XC2028_DEFAULT_FIRMWARE,\n\t\t.max_len     = 64,\n\t\t.demod       = XC3028_FE_ZARLINK456,\n\t};\n\n\t/* FIXME: generalize & move to common area */\n\tadap->fe_adap[0].fe->callback = dvico_bluebird_xc2028_callback;\n\n\tfe = dvb_attach(xc2028_attach, adap->fe_adap[0].fe, &cfg);\n\tif (fe == NULL || fe->ops.tuner_ops.set_config == NULL)\n\t\treturn -EIO;\n\n\tfe->ops.tuner_ops.set_config(fe, &ctl);\n\n\treturn 0;\n}\n\nstatic int cxusb_mxl5003s_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tdvb_attach(mxl5005s_attach, adap->fe_adap[0].fe,\n\t\t   &adap->dev->i2c_adap, &aver_a868r_tuner);\n\treturn 0;\n}\n\nstatic int cxusb_d680_dmb_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_frontend *fe;\n\tfe = dvb_attach(mxl5005s_attach, adap->fe_adap[0].fe,\n\t\t\t&adap->dev->i2c_adap, &d680_dmb_tuner);\n\treturn (fe == NULL) ? -EIO : 0;\n}\n\nstatic int cxusb_mygica_d689_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_frontend *fe;\n\tfe = dvb_attach(max2165_attach, adap->fe_adap[0].fe,\n\t\t\t&adap->dev->i2c_adap, &mygica_d689_max2165_cfg);\n\treturn (fe == NULL) ? -EIO : 0;\n}\n\nstatic int cxusb_cx22702_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tu8 b;\n\tif (usb_set_interface(adap->dev->udev, 0, 6) < 0)\n\t\terr(\"set interface failed\");\n\n\tcxusb_ctrl_msg(adap->dev, CMD_DIGITAL, NULL, 0, &b, 1);\n\n\tadap->fe_adap[0].fe = dvb_attach(cx22702_attach, &cxusb_cx22702_config,\n\t\t\t\t\t &adap->dev->i2c_adap);\n\tif ((adap->fe_adap[0].fe) != NULL)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nstatic int cxusb_lgdt3303_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tif (usb_set_interface(adap->dev->udev, 0, 7) < 0)\n\t\terr(\"set interface failed\");\n\n\tcxusb_ctrl_msg(adap->dev, CMD_DIGITAL, NULL, 0, NULL, 0);\n\n\tadap->fe_adap[0].fe = dvb_attach(lgdt330x_attach,\n\t\t\t\t\t &cxusb_lgdt3303_config,\n\t\t\t\t\t &adap->dev->i2c_adap);\n\tif ((adap->fe_adap[0].fe) != NULL)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nstatic int cxusb_aver_lgdt3303_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tadap->fe_adap[0].fe = dvb_attach(lgdt330x_attach, &cxusb_aver_lgdt3303_config,\n\t\t\t      &adap->dev->i2c_adap);\n\tif (adap->fe_adap[0].fe != NULL)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nstatic int cxusb_mt352_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\t/* used in both lgz201 and th7579 */\n\tif (usb_set_interface(adap->dev->udev, 0, 0) < 0)\n\t\terr(\"set interface failed\");\n\n\tcxusb_ctrl_msg(adap->dev, CMD_DIGITAL, NULL, 0, NULL, 0);\n\n\tadap->fe_adap[0].fe = dvb_attach(mt352_attach, &cxusb_mt352_config,\n\t\t\t\t\t &adap->dev->i2c_adap);\n\tif ((adap->fe_adap[0].fe) != NULL)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nstatic int cxusb_dee1601_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tif (usb_set_interface(adap->dev->udev, 0, 0) < 0)\n\t\terr(\"set interface failed\");\n\n\tcxusb_ctrl_msg(adap->dev, CMD_DIGITAL, NULL, 0, NULL, 0);\n\n\tadap->fe_adap[0].fe = dvb_attach(mt352_attach, &cxusb_dee1601_config,\n\t\t\t\t\t &adap->dev->i2c_adap);\n\tif ((adap->fe_adap[0].fe) != NULL)\n\t\treturn 0;\n\n\tadap->fe_adap[0].fe = dvb_attach(zl10353_attach,\n\t\t\t\t\t &cxusb_zl10353_dee1601_config,\n\t\t\t\t\t &adap->dev->i2c_adap);\n\tif ((adap->fe_adap[0].fe) != NULL)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nstatic int cxusb_dualdig4_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tu8 ircode[4];\n\tint i;\n\tstruct i2c_msg msg = { .addr = 0x6b, .flags = I2C_M_RD,\n\t\t\t       .buf = ircode, .len = 4 };\n\n\tif (usb_set_interface(adap->dev->udev, 0, 1) < 0)\n\t\terr(\"set interface failed\");\n\n\tcxusb_ctrl_msg(adap->dev, CMD_DIGITAL, NULL, 0, NULL, 0);\n\n\t/* reset the tuner and demodulator */\n\tcxusb_bluebird_gpio_rw(adap->dev, 0x04, 0);\n\tcxusb_bluebird_gpio_pulse(adap->dev, 0x01, 1);\n\tcxusb_bluebird_gpio_pulse(adap->dev, 0x02, 1);\n\n\tadap->fe_adap[0].fe =\n\t\tdvb_attach(zl10353_attach,\n\t\t\t   &cxusb_zl10353_xc3028_config_no_i2c_gate,\n\t\t\t   &adap->dev->i2c_adap);\n\tif ((adap->fe_adap[0].fe) == NULL)\n\t\treturn -EIO;\n\n\t/* try to determine if there is no IR decoder on the I2C bus */\n\tfor (i = 0; adap->dev->props.rc.core.rc_codes && i < 5; i++) {\n\t\tmsleep(20);\n\t\tif (cxusb_i2c_xfer(&adap->dev->i2c_adap, &msg, 1) != 1)\n\t\t\tgoto no_IR;\n\t\tif (ircode[0] == 0 && ircode[1] == 0)\n\t\t\tcontinue;\n\t\tif (ircode[2] + ircode[3] != 0xff) {\nno_IR:\n\t\t\tadap->dev->props.rc.core.rc_codes = NULL;\n\t\t\tinfo(\"No IR receiver detected on this device.\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct dibx000_agc_config dib7070_agc_config = {\n\t.band_caps = BAND_UHF | BAND_VHF | BAND_LBAND | BAND_SBAND,\n\n\t/*\n\t * P_agc_use_sd_mod1=0, P_agc_use_sd_mod2=0, P_agc_freq_pwm_div=5,\n\t * P_agc_inv_pwm1=0, P_agc_inv_pwm2=0, P_agc_inh_dc_rv_est=0,\n\t * P_agc_time_est=3, P_agc_freeze=0, P_agc_nb_est=5, P_agc_write=0\n\t */\n\t.setup = (0 << 15) | (0 << 14) | (5 << 11) | (0 << 10) | (0 << 9) |\n\t\t (0 << 8) | (3 << 5) | (0 << 4) | (5 << 1) | (0 << 0),\n\t.inv_gain = 600,\n\t.time_stabiliz = 10,\n\t.alpha_level = 0,\n\t.thlock = 118,\n\t.wbd_inv = 0,\n\t.wbd_ref = 3530,\n\t.wbd_sel = 1,\n\t.wbd_alpha = 5,\n\t.agc1_max = 65535,\n\t.agc1_min = 0,\n\t.agc2_max = 65535,\n\t.agc2_min = 0,\n\t.agc1_pt1 = 0,\n\t.agc1_pt2 = 40,\n\t.agc1_pt3 = 183,\n\t.agc1_slope1 = 206,\n\t.agc1_slope2 = 255,\n\t.agc2_pt1 = 72,\n\t.agc2_pt2 = 152,\n\t.agc2_slope1 = 88,\n\t.agc2_slope2 = 90,\n\t.alpha_mant = 17,\n\t.alpha_exp = 27,\n\t.beta_mant = 23,\n\t.beta_exp = 51,\n\t.perform_agc_softsplit = 0,\n};\n\nstatic struct dibx000_bandwidth_config dib7070_bw_config_12_mhz = {\n\t.internal = 60000,\n\t.sampling = 15000,\n\t.pll_prediv = 1,\n\t.pll_ratio = 20,\n\t.pll_range = 3,\n\t.pll_reset = 1,\n\t.pll_bypass = 0,\n\t.enable_refdiv = 0,\n\t.bypclk_div = 0,\n\t.IO_CLK_en_core = 1,\n\t.ADClkSrc = 1,\n\t.modulo = 2,\n\t/* refsel, sel, freq_15k */\n\t.sad_cfg = (3 << 14) | (1 << 12) | (524 << 0),\n\t.ifreq = (0 << 25) | 0,\n\t.timf = 20452225,\n\t.xtal_hz = 12000000,\n};\n\nstatic struct dib7000p_config cxusb_dualdig4_rev2_config = {\n\t.output_mode = OUTMODE_MPEG2_PAR_GATED_CLK,\n\t.output_mpeg2_in_188_bytes = 1,\n\n\t.agc_config_count = 1,\n\t.agc = &dib7070_agc_config,\n\t.bw  = &dib7070_bw_config_12_mhz,\n\t.tuner_is_baseband = 1,\n\t.spur_protect = 1,\n\n\t.gpio_dir = 0xfcef,\n\t.gpio_val = 0x0110,\n\n\t.gpio_pwm_pos = DIB7000P_GPIO_DEFAULT_PWM_POS,\n\n\t.hostbus_diversity = 1,\n};\n\nstruct dib0700_adapter_state {\n\tint (*set_param_save)(struct dvb_frontend *);\n\tstruct dib7000p_ops dib7000p_ops;\n};\n\nstatic int cxusb_dualdig4_rev2_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tif (usb_set_interface(adap->dev->udev, 0, 1) < 0)\n\t\terr(\"set interface failed\");\n\n\tcxusb_ctrl_msg(adap->dev, CMD_DIGITAL, NULL, 0, NULL, 0);\n\n\tcxusb_bluebird_gpio_pulse(adap->dev, 0x02, 1);\n\n\tif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\n\t\treturn -ENODEV;\n\n\tif (state->dib7000p_ops.i2c_enumeration(&adap->dev->i2c_adap, 1, 18,\n\t\t\t\t       &cxusb_dualdig4_rev2_config) < 0) {\n\t\tprintk(KERN_WARNING \"Unable to enumerate dib7000p\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tadap->fe_adap[0].fe = state->dib7000p_ops.init(&adap->dev->i2c_adap, 0x80,\n\t\t\t\t\t      &cxusb_dualdig4_rev2_config);\n\tif (adap->fe_adap[0].fe == NULL)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int dib7070_tuner_reset(struct dvb_frontend *fe, int onoff)\n{\n\tstruct dvb_usb_adapter *adap = fe->dvb->priv;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\treturn state->dib7000p_ops.set_gpio(fe, 8, 0, !onoff);\n}\n\nstatic int dib7070_tuner_sleep(struct dvb_frontend *fe, int onoff)\n{\n\treturn 0;\n}\n\nstatic struct dib0070_config dib7070p_dib0070_config = {\n\t.i2c_address = DEFAULT_DIB0070_I2C_ADDRESS,\n\t.reset = dib7070_tuner_reset,\n\t.sleep = dib7070_tuner_sleep,\n\t.clock_khz = 12000,\n};\n\nstatic int dib7070_set_param_override(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct dvb_usb_adapter *adap = fe->dvb->priv;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tu16 offset;\n\tu8 band = BAND_OF_FREQUENCY(p->frequency/1000);\n\tswitch (band) {\n\tcase BAND_VHF: offset = 950; break;\n\tdefault:\n\tcase BAND_UHF: offset = 550; break;\n\t}\n\n\tstate->dib7000p_ops.set_wbd_ref(fe, offset + dib0070_wbd_offset(fe));\n\n\treturn state->set_param_save(fe);\n}\n\nstatic int cxusb_dualdig4_rev2_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_adapter_state *st = adap->priv;\n\tstruct i2c_adapter *tun_i2c;\n\n\t/*\n\t * No need to call dvb7000p_attach here, as it was called\n\t * already, as frontend_attach method is called first, and\n\t * tuner_attach is only called on sucess.\n\t */\n\ttun_i2c = st->dib7000p_ops.get_i2c_master(adap->fe_adap[0].fe,\n\t\t\t\t\tDIBX000_I2C_INTERFACE_TUNER, 1);\n\n\tif (dvb_attach(dib0070_attach, adap->fe_adap[0].fe, tun_i2c,\n\t    &dib7070p_dib0070_config) == NULL)\n\t\treturn -ENODEV;\n\n\tst->set_param_save = adap->fe_adap[0].fe->ops.tuner_ops.set_params;\n\tadap->fe_adap[0].fe->ops.tuner_ops.set_params = dib7070_set_param_override;\n\treturn 0;\n}\n\nstatic int cxusb_nano2_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tif (usb_set_interface(adap->dev->udev, 0, 1) < 0)\n\t\terr(\"set interface failed\");\n\n\tcxusb_ctrl_msg(adap->dev, CMD_DIGITAL, NULL, 0, NULL, 0);\n\n\t/* reset the tuner and demodulator */\n\tcxusb_bluebird_gpio_rw(adap->dev, 0x04, 0);\n\tcxusb_bluebird_gpio_pulse(adap->dev, 0x01, 1);\n\tcxusb_bluebird_gpio_pulse(adap->dev, 0x02, 1);\n\n\tadap->fe_adap[0].fe = dvb_attach(zl10353_attach,\n\t\t\t\t\t &cxusb_zl10353_xc3028_config,\n\t\t\t\t\t &adap->dev->i2c_adap);\n\tif ((adap->fe_adap[0].fe) != NULL)\n\t\treturn 0;\n\n\tadap->fe_adap[0].fe = dvb_attach(mt352_attach,\n\t\t\t\t\t &cxusb_mt352_xc3028_config,\n\t\t\t\t\t &adap->dev->i2c_adap);\n\tif ((adap->fe_adap[0].fe) != NULL)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nstatic struct lgs8gxx_config d680_lgs8gl5_cfg = {\n\t.prod = LGS8GXX_PROD_LGS8GL5,\n\t.demod_address = 0x19,\n\t.serial_ts = 0,\n\t.ts_clk_pol = 0,\n\t.ts_clk_gated = 1,\n\t.if_clk_freq = 30400, /* 30.4 MHz */\n\t.if_freq = 5725, /* 5.725 MHz */\n\t.if_neg_center = 0,\n\t.ext_adc = 0,\n\t.adc_signed = 0,\n\t.if_neg_edge = 0,\n};\n\nstatic int cxusb_d680_dmb_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap->dev;\n\tint n;\n\n\t/* Select required USB configuration */\n\tif (usb_set_interface(d->udev, 0, 0) < 0)\n\t\terr(\"set interface failed\");\n\n\t/* Unblock all USB pipes */\n\tusb_clear_halt(d->udev,\n\t\tusb_sndbulkpipe(d->udev, d->props.generic_bulk_ctrl_endpoint));\n\tusb_clear_halt(d->udev,\n\t\tusb_rcvbulkpipe(d->udev, d->props.generic_bulk_ctrl_endpoint));\n\tusb_clear_halt(d->udev,\n\t\tusb_rcvbulkpipe(d->udev, d->props.adapter[0].fe[0].stream.endpoint));\n\n\t/* Drain USB pipes to avoid hang after reboot */\n\tfor (n = 0;  n < 5;  n++) {\n\t\tcxusb_d680_dmb_drain_message(d);\n\t\tcxusb_d680_dmb_drain_video(d);\n\t\tmsleep(200);\n\t}\n\n\t/* Reset the tuner */\n\tif (cxusb_d680_dmb_gpio_tuner(d, 0x07, 0) < 0) {\n\t\terr(\"clear tuner gpio failed\");\n\t\treturn -EIO;\n\t}\n\tmsleep(100);\n\tif (cxusb_d680_dmb_gpio_tuner(d, 0x07, 1) < 0) {\n\t\terr(\"set tuner gpio failed\");\n\t\treturn -EIO;\n\t}\n\tmsleep(100);\n\n\t/* Attach frontend */\n\tadap->fe_adap[0].fe = dvb_attach(lgs8gxx_attach, &d680_lgs8gl5_cfg, &d->i2c_adap);\n\tif (adap->fe_adap[0].fe == NULL)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic struct atbm8830_config mygica_d689_atbm8830_cfg = {\n\t.prod = ATBM8830_PROD_8830,\n\t.demod_address = 0x40,\n\t.serial_ts = 0,\n\t.ts_sampling_edge = 1,\n\t.ts_clk_gated = 0,\n\t.osc_clk_freq = 30400, /* in kHz */\n\t.if_freq = 0, /* zero IF */\n\t.zif_swap_iq = 1,\n\t.agc_min = 0x2E,\n\t.agc_max = 0x90,\n\t.agc_hold_loop = 0,\n};\n\nstatic int cxusb_mygica_d689_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap->dev;\n\n\t/* Select required USB configuration */\n\tif (usb_set_interface(d->udev, 0, 0) < 0)\n\t\terr(\"set interface failed\");\n\n\t/* Unblock all USB pipes */\n\tusb_clear_halt(d->udev,\n\t\tusb_sndbulkpipe(d->udev, d->props.generic_bulk_ctrl_endpoint));\n\tusb_clear_halt(d->udev,\n\t\tusb_rcvbulkpipe(d->udev, d->props.generic_bulk_ctrl_endpoint));\n\tusb_clear_halt(d->udev,\n\t\tusb_rcvbulkpipe(d->udev, d->props.adapter[0].fe[0].stream.endpoint));\n\n\n\t/* Reset the tuner */\n\tif (cxusb_d680_dmb_gpio_tuner(d, 0x07, 0) < 0) {\n\t\terr(\"clear tuner gpio failed\");\n\t\treturn -EIO;\n\t}\n\tmsleep(100);\n\tif (cxusb_d680_dmb_gpio_tuner(d, 0x07, 1) < 0) {\n\t\terr(\"set tuner gpio failed\");\n\t\treturn -EIO;\n\t}\n\tmsleep(100);\n\n\t/* Attach frontend */\n\tadap->fe_adap[0].fe = dvb_attach(atbm8830_attach, &mygica_d689_atbm8830_cfg,\n\t\t&d->i2c_adap);\n\tif (adap->fe_adap[0].fe == NULL)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int cxusb_mygica_t230_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap->dev;\n\tstruct cxusb_state *st = d->priv;\n\tstruct i2c_adapter *adapter;\n\tstruct i2c_client *client_demod;\n\tstruct i2c_client *client_tuner;\n\tstruct i2c_board_info info;\n\tstruct si2168_config si2168_config;\n\tstruct si2157_config si2157_config;\n\n\t/* Select required USB configuration */\n\tif (usb_set_interface(d->udev, 0, 0) < 0)\n\t\terr(\"set interface failed\");\n\n\t/* Unblock all USB pipes */\n\tusb_clear_halt(d->udev,\n\t\tusb_sndbulkpipe(d->udev, d->props.generic_bulk_ctrl_endpoint));\n\tusb_clear_halt(d->udev,\n\t\tusb_rcvbulkpipe(d->udev, d->props.generic_bulk_ctrl_endpoint));\n\tusb_clear_halt(d->udev,\n\t\tusb_rcvbulkpipe(d->udev, d->props.adapter[0].fe[0].stream.endpoint));\n\n\t/* attach frontend */\n\tsi2168_config.i2c_adapter = &adapter;\n\tsi2168_config.fe = &adap->fe_adap[0].fe;\n\tsi2168_config.ts_mode = SI2168_TS_PARALLEL;\n\tsi2168_config.ts_clock_inv = 1;\n\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\tstrlcpy(info.type, \"si2168\", I2C_NAME_SIZE);\n\tinfo.addr = 0x64;\n\tinfo.platform_data = &si2168_config;\n\trequest_module(info.type);\n\tclient_demod = i2c_new_device(&d->i2c_adap, &info);\n\tif (client_demod == NULL || client_demod->dev.driver == NULL)\n\t\treturn -ENODEV;\n\n\tif (!try_module_get(client_demod->dev.driver->owner)) {\n\t\ti2c_unregister_device(client_demod);\n\t\treturn -ENODEV;\n\t}\n\n\tst->i2c_client_demod = client_demod;\n\n\t/* attach tuner */\n\tmemset(&si2157_config, 0, sizeof(si2157_config));\n\tsi2157_config.fe = adap->fe_adap[0].fe;\n\tsi2157_config.if_port = 1;\n\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\tstrlcpy(info.type, \"si2157\", I2C_NAME_SIZE);\n\tinfo.addr = 0x60;\n\tinfo.platform_data = &si2157_config;\n\trequest_module(info.type);\n\tclient_tuner = i2c_new_device(adapter, &info);\n\tif (client_tuner == NULL || client_tuner->dev.driver == NULL) {\n\t\tmodule_put(client_demod->dev.driver->owner);\n\t\ti2c_unregister_device(client_demod);\n\t\treturn -ENODEV;\n\t}\n\tif (!try_module_get(client_tuner->dev.driver->owner)) {\n\t\ti2c_unregister_device(client_tuner);\n\t\tmodule_put(client_demod->dev.driver->owner);\n\t\ti2c_unregister_device(client_demod);\n\t\treturn -ENODEV;\n\t}\n\n\tst->i2c_client_tuner = client_tuner;\n\n\t/* hook fe: need to resync the slave fifo when signal locks. */\n\tmutex_init(&st->stream_mutex);\n\tst->last_lock = 0;\n\tst->fe_read_status = adap->fe_adap[0].fe->ops.read_status;\n\tadap->fe_adap[0].fe->ops.read_status = cxusb_read_status;\n\n\treturn 0;\n}\n\n/*\n * DViCO has shipped two devices with the same USB ID, but only one of them\n * needs a firmware download.  Check the device class details to see if they\n * have non-default values to decide whether the device is actually cold or\n * not, and forget a match if it turns out we selected the wrong device.\n */\nstatic int bluebird_fx2_identify_state(struct usb_device *udev,\n\t\t\t\t       struct dvb_usb_device_properties *props,\n\t\t\t\t       struct dvb_usb_device_description **desc,\n\t\t\t\t       int *cold)\n{\n\tint wascold = *cold;\n\n\t*cold = udev->descriptor.bDeviceClass == 0xff &&\n\t\tudev->descriptor.bDeviceSubClass == 0xff &&\n\t\tudev->descriptor.bDeviceProtocol == 0xff;\n\n\tif (*cold && !wascold)\n\t\t*desc = NULL;\n\n\treturn 0;\n}\n\n/*\n * DViCO bluebird firmware needs the \"warm\" product ID to be patched into the\n * firmware file before download.\n */\n\nstatic const int dvico_firmware_id_offsets[] = { 6638, 3204 };\nstatic int bluebird_patch_dvico_firmware_download(struct usb_device *udev,\n\t\t\t\t\t\t  const struct firmware *fw)\n{\n\tint pos;\n\n\tfor (pos = 0; pos < ARRAY_SIZE(dvico_firmware_id_offsets); pos++) {\n\t\tint idoff = dvico_firmware_id_offsets[pos];\n\n\t\tif (fw->size < idoff + 4)\n\t\t\tcontinue;\n\n\t\tif (fw->data[idoff] == (USB_VID_DVICO & 0xff) &&\n\t\t    fw->data[idoff + 1] == USB_VID_DVICO >> 8) {\n\t\t\tstruct firmware new_fw;\n\t\t\tu8 *new_fw_data = vmalloc(fw->size);\n\t\t\tint ret;\n\n\t\t\tif (!new_fw_data)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tmemcpy(new_fw_data, fw->data, fw->size);\n\t\t\tnew_fw.size = fw->size;\n\t\t\tnew_fw.data = new_fw_data;\n\n\t\t\tnew_fw_data[idoff + 2] =\n\t\t\t\tle16_to_cpu(udev->descriptor.idProduct) + 1;\n\t\t\tnew_fw_data[idoff + 3] =\n\t\t\t\tle16_to_cpu(udev->descriptor.idProduct) >> 8;\n\n\t\t\tret = usb_cypress_load_firmware(udev, &new_fw,\n\t\t\t\t\t\t\tCYPRESS_FX2);\n\t\t\tvfree(new_fw_data);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\n/* DVB USB Driver stuff */\nstatic struct dvb_usb_device_properties cxusb_medion_properties;\nstatic struct dvb_usb_device_properties cxusb_bluebird_lgh064f_properties;\nstatic struct dvb_usb_device_properties cxusb_bluebird_dee1601_properties;\nstatic struct dvb_usb_device_properties cxusb_bluebird_lgz201_properties;\nstatic struct dvb_usb_device_properties cxusb_bluebird_dtt7579_properties;\nstatic struct dvb_usb_device_properties cxusb_bluebird_dualdig4_properties;\nstatic struct dvb_usb_device_properties cxusb_bluebird_dualdig4_rev2_properties;\nstatic struct dvb_usb_device_properties cxusb_bluebird_nano2_properties;\nstatic struct dvb_usb_device_properties cxusb_bluebird_nano2_needsfirmware_properties;\nstatic struct dvb_usb_device_properties cxusb_aver_a868r_properties;\nstatic struct dvb_usb_device_properties cxusb_d680_dmb_properties;\nstatic struct dvb_usb_device_properties cxusb_mygica_d689_properties;\nstatic struct dvb_usb_device_properties cxusb_mygica_t230_properties;\n\nstatic int cxusb_probe(struct usb_interface *intf,\n\t\t       const struct usb_device_id *id)\n{\n\tif (0 == dvb_usb_device_init(intf, &cxusb_medion_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &cxusb_bluebird_lgh064f_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &cxusb_bluebird_dee1601_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &cxusb_bluebird_lgz201_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &cxusb_bluebird_dtt7579_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &cxusb_bluebird_dualdig4_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &cxusb_bluebird_nano2_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf,\n\t\t\t\t&cxusb_bluebird_nano2_needsfirmware_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &cxusb_aver_a868r_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf,\n\t\t\t\t     &cxusb_bluebird_dualdig4_rev2_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &cxusb_d680_dmb_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &cxusb_mygica_d689_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &cxusb_mygica_t230_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0)\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic void cxusb_disconnect(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tstruct cxusb_state *st = d->priv;\n\tstruct i2c_client *client;\n\n\t/* remove I2C client for tuner */\n\tclient = st->i2c_client_tuner;\n\tif (client) {\n\t\tmodule_put(client->dev.driver->owner);\n\t\ti2c_unregister_device(client);\n\t}\n\n\t/* remove I2C client for demodulator */\n\tclient = st->i2c_client_demod;\n\tif (client) {\n\t\tmodule_put(client->dev.driver->owner);\n\t\ti2c_unregister_device(client);\n\t}\n\n\tdvb_usb_device_exit(intf);\n}\n\nenum cxusb_table_index {\n\tMEDION_MD95700,\n\tDVICO_BLUEBIRD_LG064F_COLD,\n\tDVICO_BLUEBIRD_LG064F_WARM,\n\tDVICO_BLUEBIRD_DUAL_1_COLD,\n\tDVICO_BLUEBIRD_DUAL_1_WARM,\n\tDVICO_BLUEBIRD_LGZ201_COLD,\n\tDVICO_BLUEBIRD_LGZ201_WARM,\n\tDVICO_BLUEBIRD_TH7579_COLD,\n\tDVICO_BLUEBIRD_TH7579_WARM,\n\tDIGITALNOW_BLUEBIRD_DUAL_1_COLD,\n\tDIGITALNOW_BLUEBIRD_DUAL_1_WARM,\n\tDVICO_BLUEBIRD_DUAL_2_COLD,\n\tDVICO_BLUEBIRD_DUAL_2_WARM,\n\tDVICO_BLUEBIRD_DUAL_4,\n\tDVICO_BLUEBIRD_DVB_T_NANO_2,\n\tDVICO_BLUEBIRD_DVB_T_NANO_2_NFW_WARM,\n\tAVERMEDIA_VOLAR_A868R,\n\tDVICO_BLUEBIRD_DUAL_4_REV_2,\n\tCONEXANT_D680_DMB,\n\tMYGICA_D689,\n\tMYGICA_T230,\n\tNR__cxusb_table_index\n};\n\nstatic struct usb_device_id cxusb_table[NR__cxusb_table_index + 1] = {\n\t[MEDION_MD95700] = {\n\t\tUSB_DEVICE(USB_VID_MEDION, USB_PID_MEDION_MD95700)\n\t},\n\t[DVICO_BLUEBIRD_LG064F_COLD] = {\n\t\tUSB_DEVICE(USB_VID_DVICO, USB_PID_DVICO_BLUEBIRD_LG064F_COLD)\n\t},\n\t[DVICO_BLUEBIRD_LG064F_WARM] = {\n\t\tUSB_DEVICE(USB_VID_DVICO, USB_PID_DVICO_BLUEBIRD_LG064F_WARM)\n\t},\n\t[DVICO_BLUEBIRD_DUAL_1_COLD] = {\n\t\tUSB_DEVICE(USB_VID_DVICO, USB_PID_DVICO_BLUEBIRD_DUAL_1_COLD)\n\t},\n\t[DVICO_BLUEBIRD_DUAL_1_WARM] = {\n\t\tUSB_DEVICE(USB_VID_DVICO, USB_PID_DVICO_BLUEBIRD_DUAL_1_WARM)\n\t},\n\t[DVICO_BLUEBIRD_LGZ201_COLD] = {\n\t\tUSB_DEVICE(USB_VID_DVICO, USB_PID_DVICO_BLUEBIRD_LGZ201_COLD)\n\t},\n\t[DVICO_BLUEBIRD_LGZ201_WARM] = {\n\t\tUSB_DEVICE(USB_VID_DVICO, USB_PID_DVICO_BLUEBIRD_LGZ201_WARM)\n\t},\n\t[DVICO_BLUEBIRD_TH7579_COLD] = {\n\t\tUSB_DEVICE(USB_VID_DVICO, USB_PID_DVICO_BLUEBIRD_TH7579_COLD)\n\t},\n\t[DVICO_BLUEBIRD_TH7579_WARM] = {\n\t\tUSB_DEVICE(USB_VID_DVICO, USB_PID_DVICO_BLUEBIRD_TH7579_WARM)\n\t},\n\t[DIGITALNOW_BLUEBIRD_DUAL_1_COLD] = {\n\t\tUSB_DEVICE(USB_VID_DVICO, USB_PID_DIGITALNOW_BLUEBIRD_DUAL_1_COLD)\n\t},\n\t[DIGITALNOW_BLUEBIRD_DUAL_1_WARM] = {\n\t\tUSB_DEVICE(USB_VID_DVICO, USB_PID_DIGITALNOW_BLUEBIRD_DUAL_1_WARM)\n\t},\n\t[DVICO_BLUEBIRD_DUAL_2_COLD] = {\n\t\tUSB_DEVICE(USB_VID_DVICO, USB_PID_DVICO_BLUEBIRD_DUAL_2_COLD)\n\t},\n\t[DVICO_BLUEBIRD_DUAL_2_WARM] = {\n\t\tUSB_DEVICE(USB_VID_DVICO, USB_PID_DVICO_BLUEBIRD_DUAL_2_WARM)\n\t},\n\t[DVICO_BLUEBIRD_DUAL_4] = {\n\t\tUSB_DEVICE(USB_VID_DVICO, USB_PID_DVICO_BLUEBIRD_DUAL_4)\n\t},\n\t[DVICO_BLUEBIRD_DVB_T_NANO_2] = {\n\t\tUSB_DEVICE(USB_VID_DVICO, USB_PID_DVICO_BLUEBIRD_DVB_T_NANO_2)\n\t},\n\t[DVICO_BLUEBIRD_DVB_T_NANO_2_NFW_WARM] = {\n\t\tUSB_DEVICE(USB_VID_DVICO, USB_PID_DVICO_BLUEBIRD_DVB_T_NANO_2_NFW_WARM)\n\t},\n\t[AVERMEDIA_VOLAR_A868R] = {\n\t\tUSB_DEVICE(USB_VID_AVERMEDIA, USB_PID_AVERMEDIA_VOLAR_A868R)\n\t},\n\t[DVICO_BLUEBIRD_DUAL_4_REV_2] = {\n\t\tUSB_DEVICE(USB_VID_DVICO, USB_PID_DVICO_BLUEBIRD_DUAL_4_REV_2)\n\t},\n\t[CONEXANT_D680_DMB] = {\n\t\tUSB_DEVICE(USB_VID_CONEXANT, USB_PID_CONEXANT_D680_DMB)\n\t},\n\t[MYGICA_D689] = {\n\t\tUSB_DEVICE(USB_VID_CONEXANT, USB_PID_MYGICA_D689)\n\t},\n\t[MYGICA_T230] = {\n\t\tUSB_DEVICE(USB_VID_CONEXANT, USB_PID_MYGICA_T230)\n\t},\n\t{}\t\t/* Terminating entry */\n};\nMODULE_DEVICE_TABLE (usb, cxusb_table);\n\nstatic struct dvb_usb_device_properties cxusb_medion_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl = CYPRESS_FX2,\n\n\t.size_of_priv     = sizeof(struct cxusb_state),\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl   = cxusb_streaming_ctrl,\n\t\t\t.frontend_attach  = cxusb_cx22702_frontend_attach,\n\t\t\t.tuner_attach     = cxusb_fmd1216me_tuner_attach,\n\t\t\t/* parameter for the MPEG2-data transfer */\n\t\t\t\t\t.stream = {\n\t\t\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 5,\n\t\t\t\t.endpoint = 0x02,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 8192,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t},\n\t},\n\t.power_ctrl       = cxusb_power_ctrl,\n\n\t.i2c_algo         = &cxusb_i2c_algo,\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{   \"Medion MD95700 (MDUSBTV-HYBRID)\",\n\t\t\t{ NULL },\n\t\t\t{ &cxusb_table[MEDION_MD95700], NULL },\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties cxusb_bluebird_lgh064f_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl          = DEVICE_SPECIFIC,\n\t.firmware          = \"dvb-usb-bluebird-01.fw\",\n\t.download_firmware = bluebird_patch_dvico_firmware_download,\n\t/* use usb alt setting 0 for EP4 transfer (dvb-t),\n\t   use usb alt setting 7 for EP2 transfer (atsc) */\n\n\t.size_of_priv     = sizeof(struct cxusb_state),\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl   = cxusb_streaming_ctrl,\n\t\t\t.frontend_attach  = cxusb_lgdt3303_frontend_attach,\n\t\t\t.tuner_attach     = cxusb_lgh064f_tuner_attach,\n\n\t\t\t/* parameter for the MPEG2-data transfer */\n\t\t\t\t\t.stream = {\n\t\t\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 5,\n\t\t\t\t.endpoint = 0x02,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 8192,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t},\n\t},\n\n\t.power_ctrl       = cxusb_bluebird_power_ctrl,\n\n\t.i2c_algo         = &cxusb_i2c_algo,\n\n\t.rc.core = {\n\t\t.rc_interval\t= 100,\n\t\t.rc_codes\t= RC_MAP_DVICO_PORTABLE,\n\t\t.module_name\t= KBUILD_MODNAME,\n\t\t.rc_query\t= cxusb_rc_query,\n\t\t.allowed_protos = RC_BIT_UNKNOWN,\n\t},\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{   \"DViCO FusionHDTV5 USB Gold\",\n\t\t\t{ &cxusb_table[DVICO_BLUEBIRD_LG064F_COLD], NULL },\n\t\t\t{ &cxusb_table[DVICO_BLUEBIRD_LG064F_WARM], NULL },\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties cxusb_bluebird_dee1601_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl          = DEVICE_SPECIFIC,\n\t.firmware          = \"dvb-usb-bluebird-01.fw\",\n\t.download_firmware = bluebird_patch_dvico_firmware_download,\n\t/* use usb alt setting 0 for EP4 transfer (dvb-t),\n\t   use usb alt setting 7 for EP2 transfer (atsc) */\n\n\t.size_of_priv     = sizeof(struct cxusb_state),\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl   = cxusb_streaming_ctrl,\n\t\t\t.frontend_attach  = cxusb_dee1601_frontend_attach,\n\t\t\t.tuner_attach     = cxusb_dee1601_tuner_attach,\n\t\t\t/* parameter for the MPEG2-data transfer */\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 5,\n\t\t\t\t.endpoint = 0x04,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 8192,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t},\n\t},\n\n\t.power_ctrl       = cxusb_bluebird_power_ctrl,\n\n\t.i2c_algo         = &cxusb_i2c_algo,\n\n\t.rc.core = {\n\t\t.rc_interval\t= 100,\n\t\t.rc_codes\t= RC_MAP_DVICO_MCE,\n\t\t.module_name\t= KBUILD_MODNAME,\n\t\t.rc_query\t= cxusb_rc_query,\n\t\t.allowed_protos = RC_BIT_UNKNOWN,\n\t},\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\n\t.num_device_descs = 3,\n\t.devices = {\n\t\t{   \"DViCO FusionHDTV DVB-T Dual USB\",\n\t\t\t{ &cxusb_table[DVICO_BLUEBIRD_DUAL_1_COLD], NULL },\n\t\t\t{ &cxusb_table[DVICO_BLUEBIRD_DUAL_1_WARM], NULL },\n\t\t},\n\t\t{   \"DigitalNow DVB-T Dual USB\",\n\t\t\t{ &cxusb_table[DIGITALNOW_BLUEBIRD_DUAL_1_COLD],  NULL },\n\t\t\t{ &cxusb_table[DIGITALNOW_BLUEBIRD_DUAL_1_WARM], NULL },\n\t\t},\n\t\t{   \"DViCO FusionHDTV DVB-T Dual Digital 2\",\n\t\t\t{ &cxusb_table[DVICO_BLUEBIRD_DUAL_2_COLD], NULL },\n\t\t\t{ &cxusb_table[DVICO_BLUEBIRD_DUAL_2_WARM], NULL },\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties cxusb_bluebird_lgz201_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl          = DEVICE_SPECIFIC,\n\t.firmware          = \"dvb-usb-bluebird-01.fw\",\n\t.download_firmware = bluebird_patch_dvico_firmware_download,\n\t/* use usb alt setting 0 for EP4 transfer (dvb-t),\n\t   use usb alt setting 7 for EP2 transfer (atsc) */\n\n\t.size_of_priv     = sizeof(struct cxusb_state),\n\n\t.num_adapters = 2,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl   = cxusb_streaming_ctrl,\n\t\t\t.frontend_attach  = cxusb_mt352_frontend_attach,\n\t\t\t.tuner_attach     = cxusb_lgz201_tuner_attach,\n\n\t\t\t/* parameter for the MPEG2-data transfer */\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 5,\n\t\t\t\t.endpoint = 0x04,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 8192,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t},\n\t},\n\t.power_ctrl       = cxusb_bluebird_power_ctrl,\n\n\t.i2c_algo         = &cxusb_i2c_algo,\n\n\t.rc.core = {\n\t\t.rc_interval\t= 100,\n\t\t.rc_codes\t= RC_MAP_DVICO_PORTABLE,\n\t\t.module_name\t= KBUILD_MODNAME,\n\t\t.rc_query\t= cxusb_rc_query,\n\t\t.allowed_protos = RC_BIT_UNKNOWN,\n\t},\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{   \"DViCO FusionHDTV DVB-T USB (LGZ201)\",\n\t\t\t{ &cxusb_table[DVICO_BLUEBIRD_LGZ201_COLD], NULL },\n\t\t\t{ &cxusb_table[DVICO_BLUEBIRD_LGZ201_WARM], NULL },\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties cxusb_bluebird_dtt7579_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl          = DEVICE_SPECIFIC,\n\t.firmware          = \"dvb-usb-bluebird-01.fw\",\n\t.download_firmware = bluebird_patch_dvico_firmware_download,\n\t/* use usb alt setting 0 for EP4 transfer (dvb-t),\n\t   use usb alt setting 7 for EP2 transfer (atsc) */\n\n\t.size_of_priv     = sizeof(struct cxusb_state),\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl   = cxusb_streaming_ctrl,\n\t\t\t.frontend_attach  = cxusb_mt352_frontend_attach,\n\t\t\t.tuner_attach     = cxusb_dtt7579_tuner_attach,\n\n\t\t\t/* parameter for the MPEG2-data transfer */\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 5,\n\t\t\t\t.endpoint = 0x04,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 8192,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t},\n\t},\n\t.power_ctrl       = cxusb_bluebird_power_ctrl,\n\n\t.i2c_algo         = &cxusb_i2c_algo,\n\n\t.rc.core = {\n\t\t.rc_interval\t= 100,\n\t\t.rc_codes\t= RC_MAP_DVICO_PORTABLE,\n\t\t.module_name\t= KBUILD_MODNAME,\n\t\t.rc_query\t= cxusb_rc_query,\n\t\t.allowed_protos = RC_BIT_UNKNOWN,\n\t},\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{   \"DViCO FusionHDTV DVB-T USB (TH7579)\",\n\t\t\t{ &cxusb_table[DVICO_BLUEBIRD_TH7579_COLD], NULL },\n\t\t\t{ &cxusb_table[DVICO_BLUEBIRD_TH7579_WARM], NULL },\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties cxusb_bluebird_dualdig4_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl         = CYPRESS_FX2,\n\n\t.size_of_priv     = sizeof(struct cxusb_state),\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl   = cxusb_streaming_ctrl,\n\t\t\t.frontend_attach  = cxusb_dualdig4_frontend_attach,\n\t\t\t.tuner_attach     = cxusb_dvico_xc3028_tuner_attach,\n\t\t\t/* parameter for the MPEG2-data transfer */\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 5,\n\t\t\t\t.endpoint = 0x02,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 8192,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t},\n\t},\n\n\t.power_ctrl       = cxusb_power_ctrl,\n\n\t.i2c_algo         = &cxusb_i2c_algo,\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\n\t.rc.core = {\n\t\t.rc_interval\t= 100,\n\t\t.rc_codes\t= RC_MAP_DVICO_MCE,\n\t\t.module_name\t= KBUILD_MODNAME,\n\t\t.rc_query\t= cxusb_bluebird2_rc_query,\n\t\t.allowed_protos = RC_BIT_UNKNOWN,\n\t},\n\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{   \"DViCO FusionHDTV DVB-T Dual Digital 4\",\n\t\t\t{ NULL },\n\t\t\t{ &cxusb_table[DVICO_BLUEBIRD_DUAL_4], NULL },\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties cxusb_bluebird_nano2_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl         = CYPRESS_FX2,\n\t.identify_state   = bluebird_fx2_identify_state,\n\n\t.size_of_priv     = sizeof(struct cxusb_state),\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl   = cxusb_streaming_ctrl,\n\t\t\t.frontend_attach  = cxusb_nano2_frontend_attach,\n\t\t\t.tuner_attach     = cxusb_dvico_xc3028_tuner_attach,\n\t\t\t/* parameter for the MPEG2-data transfer */\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 5,\n\t\t\t\t.endpoint = 0x02,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 8192,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t},\n\t},\n\n\t.power_ctrl       = cxusb_nano2_power_ctrl,\n\n\t.i2c_algo         = &cxusb_i2c_algo,\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\n\t.rc.core = {\n\t\t.rc_interval\t= 100,\n\t\t.rc_codes\t= RC_MAP_DVICO_PORTABLE,\n\t\t.module_name\t= KBUILD_MODNAME,\n\t\t.rc_query       = cxusb_bluebird2_rc_query,\n\t\t.allowed_protos = RC_BIT_UNKNOWN,\n\t},\n\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{   \"DViCO FusionHDTV DVB-T NANO2\",\n\t\t\t{ NULL },\n\t\t\t{ &cxusb_table[DVICO_BLUEBIRD_DVB_T_NANO_2], NULL },\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties cxusb_bluebird_nano2_needsfirmware_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl          = DEVICE_SPECIFIC,\n\t.firmware          = \"dvb-usb-bluebird-02.fw\",\n\t.download_firmware = bluebird_patch_dvico_firmware_download,\n\t.identify_state    = bluebird_fx2_identify_state,\n\n\t.size_of_priv      = sizeof(struct cxusb_state),\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl   = cxusb_streaming_ctrl,\n\t\t\t.frontend_attach  = cxusb_nano2_frontend_attach,\n\t\t\t.tuner_attach     = cxusb_dvico_xc3028_tuner_attach,\n\t\t\t/* parameter for the MPEG2-data transfer */\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 5,\n\t\t\t\t.endpoint = 0x02,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 8192,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t},\n\t},\n\n\t.power_ctrl       = cxusb_nano2_power_ctrl,\n\n\t.i2c_algo         = &cxusb_i2c_algo,\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\n\t.rc.core = {\n\t\t.rc_interval\t= 100,\n\t\t.rc_codes\t= RC_MAP_DVICO_PORTABLE,\n\t\t.module_name\t= KBUILD_MODNAME,\n\t\t.rc_query\t= cxusb_rc_query,\n\t\t.allowed_protos = RC_BIT_UNKNOWN,\n\t},\n\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{   \"DViCO FusionHDTV DVB-T NANO2 w/o firmware\",\n\t\t\t{ &cxusb_table[DVICO_BLUEBIRD_DVB_T_NANO_2], NULL },\n\t\t\t{ &cxusb_table[DVICO_BLUEBIRD_DVB_T_NANO_2_NFW_WARM], NULL },\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties cxusb_aver_a868r_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl         = CYPRESS_FX2,\n\n\t.size_of_priv     = sizeof(struct cxusb_state),\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl   = cxusb_aver_streaming_ctrl,\n\t\t\t.frontend_attach  = cxusb_aver_lgdt3303_frontend_attach,\n\t\t\t.tuner_attach     = cxusb_mxl5003s_tuner_attach,\n\t\t\t/* parameter for the MPEG2-data transfer */\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 5,\n\t\t\t\t.endpoint = 0x04,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 8192,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t},\n\t},\n\t.power_ctrl       = cxusb_aver_power_ctrl,\n\n\t.i2c_algo         = &cxusb_i2c_algo,\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{   \"AVerMedia AVerTVHD Volar (A868R)\",\n\t\t\t{ NULL },\n\t\t\t{ &cxusb_table[AVERMEDIA_VOLAR_A868R], NULL },\n\t\t},\n\t}\n};\n\nstatic\nstruct dvb_usb_device_properties cxusb_bluebird_dualdig4_rev2_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl         = CYPRESS_FX2,\n\n\t.size_of_priv     = sizeof(struct cxusb_state),\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.size_of_priv    = sizeof(struct dib0700_adapter_state),\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl  = cxusb_streaming_ctrl,\n\t\t\t.frontend_attach = cxusb_dualdig4_rev2_frontend_attach,\n\t\t\t.tuner_attach    = cxusb_dualdig4_rev2_tuner_attach,\n\t\t\t/* parameter for the MPEG2-data transfer */\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 7,\n\t\t\t\t.endpoint = 0x02,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 4096,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t},\n\t},\n\n\t.power_ctrl       = cxusb_bluebird_power_ctrl,\n\n\t.i2c_algo         = &cxusb_i2c_algo,\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\n\t.rc.core = {\n\t\t.rc_interval\t= 100,\n\t\t.rc_codes\t= RC_MAP_DVICO_MCE,\n\t\t.module_name\t= KBUILD_MODNAME,\n\t\t.rc_query\t= cxusb_rc_query,\n\t\t.allowed_protos = RC_BIT_UNKNOWN,\n\t},\n\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{   \"DViCO FusionHDTV DVB-T Dual Digital 4 (rev 2)\",\n\t\t\t{ NULL },\n\t\t\t{ &cxusb_table[DVICO_BLUEBIRD_DUAL_4_REV_2], NULL },\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties cxusb_d680_dmb_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl         = CYPRESS_FX2,\n\n\t.size_of_priv     = sizeof(struct cxusb_state),\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl   = cxusb_d680_dmb_streaming_ctrl,\n\t\t\t.frontend_attach  = cxusb_d680_dmb_frontend_attach,\n\t\t\t.tuner_attach     = cxusb_d680_dmb_tuner_attach,\n\n\t\t\t/* parameter for the MPEG2-data transfer */\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 5,\n\t\t\t\t.endpoint = 0x02,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 8192,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t},\n\t},\n\n\t.power_ctrl       = cxusb_d680_dmb_power_ctrl,\n\n\t.i2c_algo         = &cxusb_i2c_algo,\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\n\t.rc.core = {\n\t\t.rc_interval\t= 100,\n\t\t.rc_codes\t= RC_MAP_D680_DMB,\n\t\t.module_name\t= KBUILD_MODNAME,\n\t\t.rc_query       = cxusb_d680_dmb_rc_query,\n\t\t.allowed_protos = RC_BIT_UNKNOWN,\n\t},\n\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{\n\t\t\t\"Conexant DMB-TH Stick\",\n\t\t\t{ NULL },\n\t\t\t{ &cxusb_table[CONEXANT_D680_DMB], NULL },\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties cxusb_mygica_d689_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl         = CYPRESS_FX2,\n\n\t.size_of_priv     = sizeof(struct cxusb_state),\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl   = cxusb_d680_dmb_streaming_ctrl,\n\t\t\t.frontend_attach  = cxusb_mygica_d689_frontend_attach,\n\t\t\t.tuner_attach     = cxusb_mygica_d689_tuner_attach,\n\n\t\t\t/* parameter for the MPEG2-data transfer */\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 5,\n\t\t\t\t.endpoint = 0x02,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 8192,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t},\n\t},\n\n\t.power_ctrl       = cxusb_d680_dmb_power_ctrl,\n\n\t.i2c_algo         = &cxusb_i2c_algo,\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\n\t.rc.core = {\n\t\t.rc_interval\t= 100,\n\t\t.rc_codes\t= RC_MAP_D680_DMB,\n\t\t.module_name\t= KBUILD_MODNAME,\n\t\t.rc_query       = cxusb_d680_dmb_rc_query,\n\t\t.allowed_protos = RC_BIT_UNKNOWN,\n\t},\n\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{\n\t\t\t\"Mygica D689 DMB-TH\",\n\t\t\t{ NULL },\n\t\t\t{ &cxusb_table[MYGICA_D689], NULL },\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties cxusb_mygica_t230_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl         = CYPRESS_FX2,\n\n\t.size_of_priv     = sizeof(struct cxusb_state),\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl   = cxusb_streaming_ctrl,\n\t\t\t.frontend_attach  = cxusb_mygica_t230_frontend_attach,\n\n\t\t\t/* parameter for the MPEG2-data transfer */\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 5,\n\t\t\t\t.endpoint = 0x02,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 8192,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t} },\n\t\t},\n\t},\n\n\t.power_ctrl       = cxusb_d680_dmb_power_ctrl,\n\n\t.i2c_algo         = &cxusb_i2c_algo,\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\n\t.rc.core = {\n\t\t.rc_interval\t= 100,\n\t\t.rc_codes\t= RC_MAP_D680_DMB,\n\t\t.module_name\t= KBUILD_MODNAME,\n\t\t.rc_query       = cxusb_d680_dmb_rc_query,\n\t\t.allowed_protos = RC_BIT_UNKNOWN,\n\t},\n\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{\n\t\t\t\"Mygica T230 DVB-T/T2/C\",\n\t\t\t{ NULL },\n\t\t\t{ &cxusb_table[MYGICA_T230], NULL },\n\t\t},\n\t}\n};\n\nstatic struct usb_driver cxusb_driver = {\n\t.name\t\t= \"dvb_usb_cxusb\",\n\t.probe\t\t= cxusb_probe,\n\t.disconnect     = cxusb_disconnect,\n\t.id_table\t= cxusb_table,\n};\n\nmodule_usb_driver(cxusb_driver);\n\nMODULE_AUTHOR(\"Patrick Boettcher <patrick.boettcher@posteo.de>\");\nMODULE_AUTHOR(\"Michael Krufky <mkrufky@linuxtv.org>\");\nMODULE_AUTHOR(\"Chris Pascoe <c.pascoe@itee.uq.edu.au>\");\nMODULE_DESCRIPTION(\"Driver for Conexant USB2.0 hybrid reference design\");\nMODULE_VERSION(\"1.0-alpha\");\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["drivers/media/usb/dvb-usb/cxusb.c"], "buggy_code_start_loc": [62], "buggy_code_end_loc": [79], "fixing_code_start_loc": [62], "fixing_code_end_loc": [80], "type": "CWE-119", "message": "drivers/media/usb/dvb-usb/cxusb.c in the Linux kernel 4.9.x and 4.10.x before 4.10.12 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist.", "other": {"cve": {"id": "CVE-2017-8063", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-23T05:59:00.270", "lastModified": "2023-02-14T19:26:09.997", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "drivers/media/usb/dvb-usb/cxusb.c in the Linux kernel 4.9.x and 4.10.x before 4.10.12 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist."}, {"lang": "es", "value": "drivers/media/usb/dvb-usb/cxusb.c en el kernel de Linux 4.9.x y 4.10.x en versiones anteriores a 4.10.12 interact\u00faa incorrectamente con la opci\u00f3n CONFIG_VMAP_STACK, que permite a usuarios locales provocar una denegaci\u00f3n de servicio (bloqueo del sistema o corrupci\u00f3n de memoria) o posiblemente tiene otro impacto no especificado aprovechando el uso de m\u00e1s de una p\u00e1gina virtual para la lista de dispersi\u00f3n DMA."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.9", "versionEndExcluding": "4.9.24", "matchCriteriaId": "D917D25C-3EFB-4A83-9688-05DF094BFF58"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.10", "versionEndExcluding": "4.10.12", "matchCriteriaId": "59CCD4BB-9F0D-405F-B1DD-ACEDF5BB2EDD"}]}]}], "references": [{"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.10.12", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/04/16/4", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch"]}, {"url": "http://www.securityfocus.com/bid/97974", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=3f190e3aec212fc8c61e202c51400afa7384d4bc", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/torvalds/linux/commit/3f190e3aec212fc8c61e202c51400afa7384d4bc", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/3f190e3aec212fc8c61e202c51400afa7384d4bc"}}