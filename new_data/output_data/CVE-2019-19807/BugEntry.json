{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *  Timers abstract layer\n *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>\n */\n\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/sched/signal.h>\n#include <sound/core.h>\n#include <sound/timer.h>\n#include <sound/control.h>\n#include <sound/info.h>\n#include <sound/minors.h>\n#include <sound/initval.h>\n#include <linux/kmod.h>\n\n/* internal flags */\n#define SNDRV_TIMER_IFLG_PAUSED\t\t0x00010000\n#define SNDRV_TIMER_IFLG_DEAD\t\t0x00020000\n\n#if IS_ENABLED(CONFIG_SND_HRTIMER)\n#define DEFAULT_TIMER_LIMIT 4\n#else\n#define DEFAULT_TIMER_LIMIT 1\n#endif\n\nstatic int timer_limit = DEFAULT_TIMER_LIMIT;\nstatic int timer_tstamp_monotonic = 1;\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>, Takashi Iwai <tiwai@suse.de>\");\nMODULE_DESCRIPTION(\"ALSA timer interface\");\nMODULE_LICENSE(\"GPL\");\nmodule_param(timer_limit, int, 0444);\nMODULE_PARM_DESC(timer_limit, \"Maximum global timers in system.\");\nmodule_param(timer_tstamp_monotonic, int, 0444);\nMODULE_PARM_DESC(timer_tstamp_monotonic, \"Use posix monotonic clock source for timestamps (default).\");\n\nMODULE_ALIAS_CHARDEV(CONFIG_SND_MAJOR, SNDRV_MINOR_TIMER);\nMODULE_ALIAS(\"devname:snd/timer\");\n\nstruct snd_timer_user {\n\tstruct snd_timer_instance *timeri;\n\tint tread;\t\t/* enhanced read with timestamps and events */\n\tunsigned long ticks;\n\tunsigned long overrun;\n\tint qhead;\n\tint qtail;\n\tint qused;\n\tint queue_size;\n\tbool disconnected;\n\tstruct snd_timer_read *queue;\n\tstruct snd_timer_tread *tqueue;\n\tspinlock_t qlock;\n\tunsigned long last_resolution;\n\tunsigned int filter;\n\tstruct timespec tstamp;\t\t/* trigger tstamp */\n\twait_queue_head_t qchange_sleep;\n\tstruct fasync_struct *fasync;\n\tstruct mutex ioctl_lock;\n};\n\n/* list of timers */\nstatic LIST_HEAD(snd_timer_list);\n\n/* list of slave instances */\nstatic LIST_HEAD(snd_timer_slave_list);\n\n/* lock for slave active lists */\nstatic DEFINE_SPINLOCK(slave_active_lock);\n\nstatic DEFINE_MUTEX(register_mutex);\n\nstatic int snd_timer_free(struct snd_timer *timer);\nstatic int snd_timer_dev_free(struct snd_device *device);\nstatic int snd_timer_dev_register(struct snd_device *device);\nstatic int snd_timer_dev_disconnect(struct snd_device *device);\n\nstatic void snd_timer_reschedule(struct snd_timer * timer, unsigned long ticks_left);\n\n/*\n * create a timer instance with the given owner string.\n * when timer is not NULL, increments the module counter\n */\nstatic struct snd_timer_instance *snd_timer_instance_new(char *owner,\n\t\t\t\t\t\t\t struct snd_timer *timer)\n{\n\tstruct snd_timer_instance *timeri;\n\ttimeri = kzalloc(sizeof(*timeri), GFP_KERNEL);\n\tif (timeri == NULL)\n\t\treturn NULL;\n\ttimeri->owner = kstrdup(owner, GFP_KERNEL);\n\tif (! timeri->owner) {\n\t\tkfree(timeri);\n\t\treturn NULL;\n\t}\n\tINIT_LIST_HEAD(&timeri->open_list);\n\tINIT_LIST_HEAD(&timeri->active_list);\n\tINIT_LIST_HEAD(&timeri->ack_list);\n\tINIT_LIST_HEAD(&timeri->slave_list_head);\n\tINIT_LIST_HEAD(&timeri->slave_active_head);\n\n\ttimeri->timer = timer;\n\tif (timer && !try_module_get(timer->module)) {\n\t\tkfree(timeri->owner);\n\t\tkfree(timeri);\n\t\treturn NULL;\n\t}\n\n\treturn timeri;\n}\n\n/*\n * find a timer instance from the given timer id\n */\nstatic struct snd_timer *snd_timer_find(struct snd_timer_id *tid)\n{\n\tstruct snd_timer *timer = NULL;\n\n\tlist_for_each_entry(timer, &snd_timer_list, device_list) {\n\t\tif (timer->tmr_class != tid->dev_class)\n\t\t\tcontinue;\n\t\tif ((timer->tmr_class == SNDRV_TIMER_CLASS_CARD ||\n\t\t     timer->tmr_class == SNDRV_TIMER_CLASS_PCM) &&\n\t\t    (timer->card == NULL ||\n\t\t     timer->card->number != tid->card))\n\t\t\tcontinue;\n\t\tif (timer->tmr_device != tid->device)\n\t\t\tcontinue;\n\t\tif (timer->tmr_subdevice != tid->subdevice)\n\t\t\tcontinue;\n\t\treturn timer;\n\t}\n\treturn NULL;\n}\n\n#ifdef CONFIG_MODULES\n\nstatic void snd_timer_request(struct snd_timer_id *tid)\n{\n\tswitch (tid->dev_class) {\n\tcase SNDRV_TIMER_CLASS_GLOBAL:\n\t\tif (tid->device < timer_limit)\n\t\t\trequest_module(\"snd-timer-%i\", tid->device);\n\t\tbreak;\n\tcase SNDRV_TIMER_CLASS_CARD:\n\tcase SNDRV_TIMER_CLASS_PCM:\n\t\tif (tid->card < snd_ecards_limit)\n\t\t\trequest_module(\"snd-card-%i\", tid->card);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n#endif\n\n/*\n * look for a master instance matching with the slave id of the given slave.\n * when found, relink the open_link of the slave.\n *\n * call this with register_mutex down.\n */\nstatic int snd_timer_check_slave(struct snd_timer_instance *slave)\n{\n\tstruct snd_timer *timer;\n\tstruct snd_timer_instance *master;\n\n\t/* FIXME: it's really dumb to look up all entries.. */\n\tlist_for_each_entry(timer, &snd_timer_list, device_list) {\n\t\tlist_for_each_entry(master, &timer->open_list_head, open_list) {\n\t\t\tif (slave->slave_class == master->slave_class &&\n\t\t\t    slave->slave_id == master->slave_id) {\n\t\t\t\tif (master->timer->num_instances >=\n\t\t\t\t    master->timer->max_instances)\n\t\t\t\t\treturn -EBUSY;\n\t\t\t\tlist_move_tail(&slave->open_list,\n\t\t\t\t\t       &master->slave_list_head);\n\t\t\t\tmaster->timer->num_instances++;\n\t\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t\t\tslave->master = master;\n\t\t\t\tslave->timer = master->timer;\n\t\t\t\tspin_unlock_irq(&slave_active_lock);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * look for slave instances matching with the slave id of the given master.\n * when found, relink the open_link of slaves.\n *\n * call this with register_mutex down.\n */\nstatic int snd_timer_check_master(struct snd_timer_instance *master)\n{\n\tstruct snd_timer_instance *slave, *tmp;\n\n\t/* check all pending slaves */\n\tlist_for_each_entry_safe(slave, tmp, &snd_timer_slave_list, open_list) {\n\t\tif (slave->slave_class == master->slave_class &&\n\t\t    slave->slave_id == master->slave_id) {\n\t\t\tif (master->timer->num_instances >=\n\t\t\t    master->timer->max_instances)\n\t\t\t\treturn -EBUSY;\n\t\t\tlist_move_tail(&slave->open_list, &master->slave_list_head);\n\t\t\tmaster->timer->num_instances++;\n\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t\tspin_lock(&master->timer->lock);\n\t\t\tslave->master = master;\n\t\t\tslave->timer = master->timer;\n\t\t\tif (slave->flags & SNDRV_TIMER_IFLG_RUNNING)\n\t\t\t\tlist_add_tail(&slave->active_list,\n\t\t\t\t\t      &master->slave_active_head);\n\t\t\tspin_unlock(&master->timer->lock);\n\t\t\tspin_unlock_irq(&slave_active_lock);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int snd_timer_close_locked(struct snd_timer_instance *timeri,\n\t\t\t\t  struct device **card_devp_to_put);\n\n/*\n * open a timer instance\n * when opening a master, the slave id must be here given.\n */\nint snd_timer_open(struct snd_timer_instance **ti,\n\t\t   char *owner, struct snd_timer_id *tid,\n\t\t   unsigned int slave_id)\n{\n\tstruct snd_timer *timer;\n\tstruct snd_timer_instance *timeri = NULL;\n\tstruct device *card_dev_to_put = NULL;\n\tint err;\n\n\tmutex_lock(&register_mutex);\n\tif (tid->dev_class == SNDRV_TIMER_CLASS_SLAVE) {\n\t\t/* open a slave instance */\n\t\tif (tid->dev_sclass <= SNDRV_TIMER_SCLASS_NONE ||\n\t\t    tid->dev_sclass > SNDRV_TIMER_SCLASS_OSS_SEQUENCER) {\n\t\t\tpr_debug(\"ALSA: timer: invalid slave class %i\\n\",\n\t\t\t\t tid->dev_sclass);\n\t\t\terr = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\t\ttimeri = snd_timer_instance_new(owner, NULL);\n\t\tif (!timeri) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unlock;\n\t\t}\n\t\ttimeri->slave_class = tid->dev_sclass;\n\t\ttimeri->slave_id = tid->device;\n\t\ttimeri->flags |= SNDRV_TIMER_IFLG_SLAVE;\n\t\tlist_add_tail(&timeri->open_list, &snd_timer_slave_list);\n\t\terr = snd_timer_check_slave(timeri);\n\t\tif (err < 0) {\n\t\t\tsnd_timer_close_locked(timeri, &card_dev_to_put);\n\t\t\ttimeri = NULL;\n\t\t}\n\t\tgoto unlock;\n\t}\n\n\t/* open a master instance */\n\ttimer = snd_timer_find(tid);\n#ifdef CONFIG_MODULES\n\tif (!timer) {\n\t\tmutex_unlock(&register_mutex);\n\t\tsnd_timer_request(tid);\n\t\tmutex_lock(&register_mutex);\n\t\ttimer = snd_timer_find(tid);\n\t}\n#endif\n\tif (!timer) {\n\t\terr = -ENODEV;\n\t\tgoto unlock;\n\t}\n\tif (!list_empty(&timer->open_list_head)) {\n\t\ttimeri = list_entry(timer->open_list_head.next,\n\t\t\t\t    struct snd_timer_instance, open_list);\n\t\tif (timeri->flags & SNDRV_TIMER_IFLG_EXCLUSIVE) {\n\t\t\terr = -EBUSY;\n\t\t\ttimeri = NULL;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\tif (timer->num_instances >= timer->max_instances) {\n\t\terr = -EBUSY;\n\t\tgoto unlock;\n\t}\n\ttimeri = snd_timer_instance_new(owner, timer);\n\tif (!timeri) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\t/* take a card refcount for safe disconnection */\n\tif (timer->card)\n\t\tget_device(&timer->card->card_dev);\n\ttimeri->slave_class = tid->dev_sclass;\n\ttimeri->slave_id = slave_id;\n\n\tif (list_empty(&timer->open_list_head) && timer->hw.open) {\n\t\terr = timer->hw.open(timer);\n\t\tif (err) {\n\t\t\tkfree(timeri->owner);\n\t\t\tkfree(timeri);\n\t\t\ttimeri = NULL;\n\n\t\t\tif (timer->card)\n\t\t\t\tcard_dev_to_put = &timer->card->card_dev;\n\t\t\tmodule_put(timer->module);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tlist_add_tail(&timeri->open_list, &timer->open_list_head);\n\ttimer->num_instances++;\n\terr = snd_timer_check_master(timeri);\n\tif (err < 0) {\n\t\tsnd_timer_close_locked(timeri, &card_dev_to_put);\n\t\ttimeri = NULL;\n\t}\n\n unlock:\n\tmutex_unlock(&register_mutex);\n\t/* put_device() is called after unlock for avoiding deadlock */\n\tif (card_dev_to_put)\n\t\tput_device(card_dev_to_put);\n\t*ti = timeri;\n\treturn err;\n}\nEXPORT_SYMBOL(snd_timer_open);\n\n/*\n * close a timer instance\n * call this with register_mutex down.\n */\nstatic int snd_timer_close_locked(struct snd_timer_instance *timeri,\n\t\t\t\t  struct device **card_devp_to_put)\n{\n\tstruct snd_timer *timer = timeri->timer;\n\tstruct snd_timer_instance *slave, *tmp;\n\n\tif (timer) {\n\t\tspin_lock_irq(&timer->lock);\n\t\ttimeri->flags |= SNDRV_TIMER_IFLG_DEAD;\n\t\tspin_unlock_irq(&timer->lock);\n\t}\n\n\tlist_del(&timeri->open_list);\n\n\t/* force to stop the timer */\n\tsnd_timer_stop(timeri);\n\n\tif (timer) {\n\t\ttimer->num_instances--;\n\t\t/* wait, until the active callback is finished */\n\t\tspin_lock_irq(&timer->lock);\n\t\twhile (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {\n\t\t\tspin_unlock_irq(&timer->lock);\n\t\t\tudelay(10);\n\t\t\tspin_lock_irq(&timer->lock);\n\t\t}\n\t\tspin_unlock_irq(&timer->lock);\n\n\t\t/* remove slave links */\n\t\tspin_lock_irq(&slave_active_lock);\n\t\tspin_lock(&timer->lock);\n\t\tlist_for_each_entry_safe(slave, tmp, &timeri->slave_list_head,\n\t\t\t\t\t open_list) {\n\t\t\tlist_move_tail(&slave->open_list, &snd_timer_slave_list);\n\t\t\ttimer->num_instances--;\n\t\t\tslave->master = NULL;\n\t\t\tslave->timer = NULL;\n\t\t\tlist_del_init(&slave->ack_list);\n\t\t\tlist_del_init(&slave->active_list);\n\t\t}\n\t\tspin_unlock(&timer->lock);\n\t\tspin_unlock_irq(&slave_active_lock);\n\n\t\t/* slave doesn't need to release timer resources below */\n\t\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE)\n\t\t\ttimer = NULL;\n\t}\n\n\tif (timeri->private_free)\n\t\ttimeri->private_free(timeri);\n\tkfree(timeri->owner);\n\tkfree(timeri);\n\n\tif (timer) {\n\t\tif (list_empty(&timer->open_list_head) && timer->hw.close)\n\t\t\ttimer->hw.close(timer);\n\t\t/* release a card refcount for safe disconnection */\n\t\tif (timer->card)\n\t\t\t*card_devp_to_put = &timer->card->card_dev;\n\t\tmodule_put(timer->module);\n\t}\n\n\treturn 0;\n}\n\n/*\n * close a timer instance\n */\nint snd_timer_close(struct snd_timer_instance *timeri)\n{\n\tstruct device *card_dev_to_put = NULL;\n\tint err;\n\n\tif (snd_BUG_ON(!timeri))\n\t\treturn -ENXIO;\n\n\tmutex_lock(&register_mutex);\n\terr = snd_timer_close_locked(timeri, &card_dev_to_put);\n\tmutex_unlock(&register_mutex);\n\t/* put_device() is called after unlock for avoiding deadlock */\n\tif (card_dev_to_put)\n\t\tput_device(card_dev_to_put);\n\treturn err;\n}\nEXPORT_SYMBOL(snd_timer_close);\n\nstatic unsigned long snd_timer_hw_resolution(struct snd_timer *timer)\n{\n\tif (timer->hw.c_resolution)\n\t\treturn timer->hw.c_resolution(timer);\n\telse\n\t\treturn timer->hw.resolution;\n}\n\nunsigned long snd_timer_resolution(struct snd_timer_instance *timeri)\n{\n\tstruct snd_timer * timer;\n\tunsigned long ret = 0;\n\tunsigned long flags;\n\n\tif (timeri == NULL)\n\t\treturn 0;\n\ttimer = timeri->timer;\n\tif (timer) {\n\t\tspin_lock_irqsave(&timer->lock, flags);\n\t\tret = snd_timer_hw_resolution(timer);\n\t\tspin_unlock_irqrestore(&timer->lock, flags);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(snd_timer_resolution);\n\nstatic void snd_timer_notify1(struct snd_timer_instance *ti, int event)\n{\n\tstruct snd_timer *timer = ti->timer;\n\tunsigned long resolution = 0;\n\tstruct snd_timer_instance *ts;\n\tstruct timespec tstamp;\n\n\tif (timer_tstamp_monotonic)\n\t\tktime_get_ts(&tstamp);\n\telse\n\t\tgetnstimeofday(&tstamp);\n\tif (snd_BUG_ON(event < SNDRV_TIMER_EVENT_START ||\n\t\t       event > SNDRV_TIMER_EVENT_PAUSE))\n\t\treturn;\n\tif (timer &&\n\t    (event == SNDRV_TIMER_EVENT_START ||\n\t     event == SNDRV_TIMER_EVENT_CONTINUE))\n\t\tresolution = snd_timer_hw_resolution(timer);\n\tif (ti->ccallback)\n\t\tti->ccallback(ti, event, &tstamp, resolution);\n\tif (ti->flags & SNDRV_TIMER_IFLG_SLAVE)\n\t\treturn;\n\tif (timer == NULL)\n\t\treturn;\n\tif (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\treturn;\n\tlist_for_each_entry(ts, &ti->slave_active_head, active_list)\n\t\tif (ts->ccallback)\n\t\t\tts->ccallback(ts, event + 100, &tstamp, resolution);\n}\n\n/* start/continue a master timer */\nstatic int snd_timer_start1(struct snd_timer_instance *timeri,\n\t\t\t    bool start, unsigned long ticks)\n{\n\tstruct snd_timer *timer;\n\tint result;\n\tunsigned long flags;\n\n\ttimer = timeri->timer;\n\tif (!timer)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&timer->lock, flags);\n\tif (timeri->flags & SNDRV_TIMER_IFLG_DEAD) {\n\t\tresult = -EINVAL;\n\t\tgoto unlock;\n\t}\n\tif (timer->card && timer->card->shutdown) {\n\t\tresult = -ENODEV;\n\t\tgoto unlock;\n\t}\n\tif (timeri->flags & (SNDRV_TIMER_IFLG_RUNNING |\n\t\t\t     SNDRV_TIMER_IFLG_START)) {\n\t\tresult = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tif (start)\n\t\ttimeri->ticks = timeri->cticks = ticks;\n\telse if (!timeri->cticks)\n\t\ttimeri->cticks = 1;\n\ttimeri->pticks = 0;\n\n\tlist_move_tail(&timeri->active_list, &timer->active_list_head);\n\tif (timer->running) {\n\t\tif (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\t\tgoto __start_now;\n\t\ttimer->flags |= SNDRV_TIMER_FLG_RESCHED;\n\t\ttimeri->flags |= SNDRV_TIMER_IFLG_START;\n\t\tresult = 1; /* delayed start */\n\t} else {\n\t\tif (start)\n\t\t\ttimer->sticks = ticks;\n\t\ttimer->hw.start(timer);\n\t      __start_now:\n\t\ttimer->running++;\n\t\ttimeri->flags |= SNDRV_TIMER_IFLG_RUNNING;\n\t\tresult = 0;\n\t}\n\tsnd_timer_notify1(timeri, start ? SNDRV_TIMER_EVENT_START :\n\t\t\t  SNDRV_TIMER_EVENT_CONTINUE);\n unlock:\n\tspin_unlock_irqrestore(&timer->lock, flags);\n\treturn result;\n}\n\n/* start/continue a slave timer */\nstatic int snd_timer_start_slave(struct snd_timer_instance *timeri,\n\t\t\t\t bool start)\n{\n\tunsigned long flags;\n\tint err;\n\n\tspin_lock_irqsave(&slave_active_lock, flags);\n\tif (timeri->flags & SNDRV_TIMER_IFLG_DEAD) {\n\t\terr = -EINVAL;\n\t\tgoto unlock;\n\t}\n\tif (timeri->flags & SNDRV_TIMER_IFLG_RUNNING) {\n\t\terr = -EBUSY;\n\t\tgoto unlock;\n\t}\n\ttimeri->flags |= SNDRV_TIMER_IFLG_RUNNING;\n\tif (timeri->master && timeri->timer) {\n\t\tspin_lock(&timeri->timer->lock);\n\t\tlist_add_tail(&timeri->active_list,\n\t\t\t      &timeri->master->slave_active_head);\n\t\tsnd_timer_notify1(timeri, start ? SNDRV_TIMER_EVENT_START :\n\t\t\t\t  SNDRV_TIMER_EVENT_CONTINUE);\n\t\tspin_unlock(&timeri->timer->lock);\n\t}\n\terr = 1; /* delayed start */\n unlock:\n\tspin_unlock_irqrestore(&slave_active_lock, flags);\n\treturn err;\n}\n\n/* stop/pause a master timer */\nstatic int snd_timer_stop1(struct snd_timer_instance *timeri, bool stop)\n{\n\tstruct snd_timer *timer;\n\tint result = 0;\n\tunsigned long flags;\n\n\ttimer = timeri->timer;\n\tif (!timer)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&timer->lock, flags);\n\tif (!(timeri->flags & (SNDRV_TIMER_IFLG_RUNNING |\n\t\t\t       SNDRV_TIMER_IFLG_START))) {\n\t\tresult = -EBUSY;\n\t\tgoto unlock;\n\t}\n\tlist_del_init(&timeri->ack_list);\n\tlist_del_init(&timeri->active_list);\n\tif (timer->card && timer->card->shutdown)\n\t\tgoto unlock;\n\tif (stop) {\n\t\ttimeri->cticks = timeri->ticks;\n\t\ttimeri->pticks = 0;\n\t}\n\tif ((timeri->flags & SNDRV_TIMER_IFLG_RUNNING) &&\n\t    !(--timer->running)) {\n\t\ttimer->hw.stop(timer);\n\t\tif (timer->flags & SNDRV_TIMER_FLG_RESCHED) {\n\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_RESCHED;\n\t\t\tsnd_timer_reschedule(timer, 0);\n\t\t\tif (timer->flags & SNDRV_TIMER_FLG_CHANGE) {\n\t\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_CHANGE;\n\t\t\t\ttimer->hw.start(timer);\n\t\t\t}\n\t\t}\n\t}\n\ttimeri->flags &= ~(SNDRV_TIMER_IFLG_RUNNING | SNDRV_TIMER_IFLG_START);\n\tif (stop)\n\t\ttimeri->flags &= ~SNDRV_TIMER_IFLG_PAUSED;\n\telse\n\t\ttimeri->flags |= SNDRV_TIMER_IFLG_PAUSED;\n\tsnd_timer_notify1(timeri, stop ? SNDRV_TIMER_EVENT_STOP :\n\t\t\t  SNDRV_TIMER_EVENT_PAUSE);\n unlock:\n\tspin_unlock_irqrestore(&timer->lock, flags);\n\treturn result;\n}\n\n/* stop/pause a slave timer */\nstatic int snd_timer_stop_slave(struct snd_timer_instance *timeri, bool stop)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&slave_active_lock, flags);\n\tif (!(timeri->flags & SNDRV_TIMER_IFLG_RUNNING)) {\n\t\tspin_unlock_irqrestore(&slave_active_lock, flags);\n\t\treturn -EBUSY;\n\t}\n\ttimeri->flags &= ~SNDRV_TIMER_IFLG_RUNNING;\n\tif (timeri->timer) {\n\t\tspin_lock(&timeri->timer->lock);\n\t\tlist_del_init(&timeri->ack_list);\n\t\tlist_del_init(&timeri->active_list);\n\t\tsnd_timer_notify1(timeri, stop ? SNDRV_TIMER_EVENT_STOP :\n\t\t\t\t  SNDRV_TIMER_EVENT_PAUSE);\n\t\tspin_unlock(&timeri->timer->lock);\n\t}\n\tspin_unlock_irqrestore(&slave_active_lock, flags);\n\treturn 0;\n}\n\n/*\n *  start the timer instance\n */\nint snd_timer_start(struct snd_timer_instance *timeri, unsigned int ticks)\n{\n\tif (timeri == NULL || ticks < 1)\n\t\treturn -EINVAL;\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE)\n\t\treturn snd_timer_start_slave(timeri, true);\n\telse\n\t\treturn snd_timer_start1(timeri, true, ticks);\n}\nEXPORT_SYMBOL(snd_timer_start);\n\n/*\n * stop the timer instance.\n *\n * do not call this from the timer callback!\n */\nint snd_timer_stop(struct snd_timer_instance *timeri)\n{\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE)\n\t\treturn snd_timer_stop_slave(timeri, true);\n\telse\n\t\treturn snd_timer_stop1(timeri, true);\n}\nEXPORT_SYMBOL(snd_timer_stop);\n\n/*\n * start again..  the tick is kept.\n */\nint snd_timer_continue(struct snd_timer_instance *timeri)\n{\n\t/* timer can continue only after pause */\n\tif (!(timeri->flags & SNDRV_TIMER_IFLG_PAUSED))\n\t\treturn -EINVAL;\n\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE)\n\t\treturn snd_timer_start_slave(timeri, false);\n\telse\n\t\treturn snd_timer_start1(timeri, false, 0);\n}\nEXPORT_SYMBOL(snd_timer_continue);\n\n/*\n * pause.. remember the ticks left\n */\nint snd_timer_pause(struct snd_timer_instance * timeri)\n{\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE)\n\t\treturn snd_timer_stop_slave(timeri, false);\n\telse\n\t\treturn snd_timer_stop1(timeri, false);\n}\nEXPORT_SYMBOL(snd_timer_pause);\n\n/*\n * reschedule the timer\n *\n * start pending instances and check the scheduling ticks.\n * when the scheduling ticks is changed set CHANGE flag to reprogram the timer.\n */\nstatic void snd_timer_reschedule(struct snd_timer * timer, unsigned long ticks_left)\n{\n\tstruct snd_timer_instance *ti;\n\tunsigned long ticks = ~0UL;\n\n\tlist_for_each_entry(ti, &timer->active_list_head, active_list) {\n\t\tif (ti->flags & SNDRV_TIMER_IFLG_START) {\n\t\t\tti->flags &= ~SNDRV_TIMER_IFLG_START;\n\t\t\tti->flags |= SNDRV_TIMER_IFLG_RUNNING;\n\t\t\ttimer->running++;\n\t\t}\n\t\tif (ti->flags & SNDRV_TIMER_IFLG_RUNNING) {\n\t\t\tif (ticks > ti->cticks)\n\t\t\t\tticks = ti->cticks;\n\t\t}\n\t}\n\tif (ticks == ~0UL) {\n\t\ttimer->flags &= ~SNDRV_TIMER_FLG_RESCHED;\n\t\treturn;\n\t}\n\tif (ticks > timer->hw.ticks)\n\t\tticks = timer->hw.ticks;\n\tif (ticks_left != ticks)\n\t\ttimer->flags |= SNDRV_TIMER_FLG_CHANGE;\n\ttimer->sticks = ticks;\n}\n\n/* call callbacks in timer ack list */\nstatic void snd_timer_process_callbacks(struct snd_timer *timer,\n\t\t\t\t\tstruct list_head *head)\n{\n\tstruct snd_timer_instance *ti;\n\tunsigned long resolution, ticks;\n\n\twhile (!list_empty(head)) {\n\t\tti = list_first_entry(head, struct snd_timer_instance,\n\t\t\t\t      ack_list);\n\n\t\t/* remove from ack_list and make empty */\n\t\tlist_del_init(&ti->ack_list);\n\n\t\tif (!(ti->flags & SNDRV_TIMER_IFLG_DEAD)) {\n\t\t\tticks = ti->pticks;\n\t\t\tti->pticks = 0;\n\t\t\tresolution = ti->resolution;\n\t\t\tti->flags |= SNDRV_TIMER_IFLG_CALLBACK;\n\t\t\tspin_unlock(&timer->lock);\n\t\t\tif (ti->callback)\n\t\t\t\tti->callback(ti, resolution, ticks);\n\t\t\tspin_lock(&timer->lock);\n\t\t\tti->flags &= ~SNDRV_TIMER_IFLG_CALLBACK;\n\t\t}\n\t}\n}\n\n/* clear pending instances from ack list */\nstatic void snd_timer_clear_callbacks(struct snd_timer *timer,\n\t\t\t\t      struct list_head *head)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&timer->lock, flags);\n\twhile (!list_empty(head))\n\t\tlist_del_init(head->next);\n\tspin_unlock_irqrestore(&timer->lock, flags);\n}\n\n/*\n * timer tasklet\n *\n */\nstatic void snd_timer_tasklet(unsigned long arg)\n{\n\tstruct snd_timer *timer = (struct snd_timer *) arg;\n\tunsigned long flags;\n\n\tif (timer->card && timer->card->shutdown) {\n\t\tsnd_timer_clear_callbacks(timer, &timer->sack_list_head);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&timer->lock, flags);\n\tsnd_timer_process_callbacks(timer, &timer->sack_list_head);\n\tspin_unlock_irqrestore(&timer->lock, flags);\n}\n\n/*\n * timer interrupt\n *\n * ticks_left is usually equal to timer->sticks.\n *\n */\nvoid snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)\n{\n\tstruct snd_timer_instance *ti, *ts, *tmp;\n\tunsigned long resolution;\n\tstruct list_head *ack_list_head;\n\tunsigned long flags;\n\tint use_tasklet = 0;\n\n\tif (timer == NULL)\n\t\treturn;\n\n\tif (timer->card && timer->card->shutdown) {\n\t\tsnd_timer_clear_callbacks(timer, &timer->ack_list_head);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&timer->lock, flags);\n\n\t/* remember the current resolution */\n\tresolution = snd_timer_hw_resolution(timer);\n\n\t/* loop for all active instances\n\t * Here we cannot use list_for_each_entry because the active_list of a\n\t * processed instance is relinked to done_list_head before the callback\n\t * is called.\n\t */\n\tlist_for_each_entry_safe(ti, tmp, &timer->active_list_head,\n\t\t\t\t active_list) {\n\t\tif (ti->flags & SNDRV_TIMER_IFLG_DEAD)\n\t\t\tcontinue;\n\t\tif (!(ti->flags & SNDRV_TIMER_IFLG_RUNNING))\n\t\t\tcontinue;\n\t\tti->pticks += ticks_left;\n\t\tti->resolution = resolution;\n\t\tif (ti->cticks < ticks_left)\n\t\t\tti->cticks = 0;\n\t\telse\n\t\t\tti->cticks -= ticks_left;\n\t\tif (ti->cticks) /* not expired */\n\t\t\tcontinue;\n\t\tif (ti->flags & SNDRV_TIMER_IFLG_AUTO) {\n\t\t\tti->cticks = ti->ticks;\n\t\t} else {\n\t\t\tti->flags &= ~SNDRV_TIMER_IFLG_RUNNING;\n\t\t\t--timer->running;\n\t\t\tlist_del_init(&ti->active_list);\n\t\t}\n\t\tif ((timer->hw.flags & SNDRV_TIMER_HW_TASKLET) ||\n\t\t    (ti->flags & SNDRV_TIMER_IFLG_FAST))\n\t\t\tack_list_head = &timer->ack_list_head;\n\t\telse\n\t\t\tack_list_head = &timer->sack_list_head;\n\t\tif (list_empty(&ti->ack_list))\n\t\t\tlist_add_tail(&ti->ack_list, ack_list_head);\n\t\tlist_for_each_entry(ts, &ti->slave_active_head, active_list) {\n\t\t\tts->pticks = ti->pticks;\n\t\t\tts->resolution = resolution;\n\t\t\tif (list_empty(&ts->ack_list))\n\t\t\t\tlist_add_tail(&ts->ack_list, ack_list_head);\n\t\t}\n\t}\n\tif (timer->flags & SNDRV_TIMER_FLG_RESCHED)\n\t\tsnd_timer_reschedule(timer, timer->sticks);\n\tif (timer->running) {\n\t\tif (timer->hw.flags & SNDRV_TIMER_HW_STOP) {\n\t\t\ttimer->hw.stop(timer);\n\t\t\ttimer->flags |= SNDRV_TIMER_FLG_CHANGE;\n\t\t}\n\t\tif (!(timer->hw.flags & SNDRV_TIMER_HW_AUTO) ||\n\t\t    (timer->flags & SNDRV_TIMER_FLG_CHANGE)) {\n\t\t\t/* restart timer */\n\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_CHANGE;\n\t\t\ttimer->hw.start(timer);\n\t\t}\n\t} else {\n\t\ttimer->hw.stop(timer);\n\t}\n\n\t/* now process all fast callbacks */\n\tsnd_timer_process_callbacks(timer, &timer->ack_list_head);\n\n\t/* do we have any slow callbacks? */\n\tuse_tasklet = !list_empty(&timer->sack_list_head);\n\tspin_unlock_irqrestore(&timer->lock, flags);\n\n\tif (use_tasklet)\n\t\ttasklet_schedule(&timer->task_queue);\n}\nEXPORT_SYMBOL(snd_timer_interrupt);\n\n/*\n\n */\n\nint snd_timer_new(struct snd_card *card, char *id, struct snd_timer_id *tid,\n\t\t  struct snd_timer **rtimer)\n{\n\tstruct snd_timer *timer;\n\tint err;\n\tstatic struct snd_device_ops ops = {\n\t\t.dev_free = snd_timer_dev_free,\n\t\t.dev_register = snd_timer_dev_register,\n\t\t.dev_disconnect = snd_timer_dev_disconnect,\n\t};\n\n\tif (snd_BUG_ON(!tid))\n\t\treturn -EINVAL;\n\tif (tid->dev_class == SNDRV_TIMER_CLASS_CARD ||\n\t    tid->dev_class == SNDRV_TIMER_CLASS_PCM) {\n\t\tif (WARN_ON(!card))\n\t\t\treturn -EINVAL;\n\t}\n\tif (rtimer)\n\t\t*rtimer = NULL;\n\ttimer = kzalloc(sizeof(*timer), GFP_KERNEL);\n\tif (!timer)\n\t\treturn -ENOMEM;\n\ttimer->tmr_class = tid->dev_class;\n\ttimer->card = card;\n\ttimer->tmr_device = tid->device;\n\ttimer->tmr_subdevice = tid->subdevice;\n\tif (id)\n\t\tstrlcpy(timer->id, id, sizeof(timer->id));\n\ttimer->sticks = 1;\n\tINIT_LIST_HEAD(&timer->device_list);\n\tINIT_LIST_HEAD(&timer->open_list_head);\n\tINIT_LIST_HEAD(&timer->active_list_head);\n\tINIT_LIST_HEAD(&timer->ack_list_head);\n\tINIT_LIST_HEAD(&timer->sack_list_head);\n\tspin_lock_init(&timer->lock);\n\ttasklet_init(&timer->task_queue, snd_timer_tasklet,\n\t\t     (unsigned long)timer);\n\ttimer->max_instances = 1000; /* default limit per timer */\n\tif (card != NULL) {\n\t\ttimer->module = card->module;\n\t\terr = snd_device_new(card, SNDRV_DEV_TIMER, timer, &ops);\n\t\tif (err < 0) {\n\t\t\tsnd_timer_free(timer);\n\t\t\treturn err;\n\t\t}\n\t}\n\tif (rtimer)\n\t\t*rtimer = timer;\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_timer_new);\n\nstatic int snd_timer_free(struct snd_timer *timer)\n{\n\tif (!timer)\n\t\treturn 0;\n\n\tmutex_lock(&register_mutex);\n\tif (! list_empty(&timer->open_list_head)) {\n\t\tstruct list_head *p, *n;\n\t\tstruct snd_timer_instance *ti;\n\t\tpr_warn(\"ALSA: timer %p is busy?\\n\", timer);\n\t\tlist_for_each_safe(p, n, &timer->open_list_head) {\n\t\t\tlist_del_init(p);\n\t\t\tti = list_entry(p, struct snd_timer_instance, open_list);\n\t\t\tti->timer = NULL;\n\t\t}\n\t}\n\tlist_del(&timer->device_list);\n\tmutex_unlock(&register_mutex);\n\n\tif (timer->private_free)\n\t\ttimer->private_free(timer);\n\tkfree(timer);\n\treturn 0;\n}\n\nstatic int snd_timer_dev_free(struct snd_device *device)\n{\n\tstruct snd_timer *timer = device->device_data;\n\treturn snd_timer_free(timer);\n}\n\nstatic int snd_timer_dev_register(struct snd_device *dev)\n{\n\tstruct snd_timer *timer = dev->device_data;\n\tstruct snd_timer *timer1;\n\n\tif (snd_BUG_ON(!timer || !timer->hw.start || !timer->hw.stop))\n\t\treturn -ENXIO;\n\tif (!(timer->hw.flags & SNDRV_TIMER_HW_SLAVE) &&\n\t    !timer->hw.resolution && timer->hw.c_resolution == NULL)\n\t    \treturn -EINVAL;\n\n\tmutex_lock(&register_mutex);\n\tlist_for_each_entry(timer1, &snd_timer_list, device_list) {\n\t\tif (timer1->tmr_class > timer->tmr_class)\n\t\t\tbreak;\n\t\tif (timer1->tmr_class < timer->tmr_class)\n\t\t\tcontinue;\n\t\tif (timer1->card && timer->card) {\n\t\t\tif (timer1->card->number > timer->card->number)\n\t\t\t\tbreak;\n\t\t\tif (timer1->card->number < timer->card->number)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (timer1->tmr_device > timer->tmr_device)\n\t\t\tbreak;\n\t\tif (timer1->tmr_device < timer->tmr_device)\n\t\t\tcontinue;\n\t\tif (timer1->tmr_subdevice > timer->tmr_subdevice)\n\t\t\tbreak;\n\t\tif (timer1->tmr_subdevice < timer->tmr_subdevice)\n\t\t\tcontinue;\n\t\t/* conflicts.. */\n\t\tmutex_unlock(&register_mutex);\n\t\treturn -EBUSY;\n\t}\n\tlist_add_tail(&timer->device_list, &timer1->device_list);\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n}\n\nstatic int snd_timer_dev_disconnect(struct snd_device *device)\n{\n\tstruct snd_timer *timer = device->device_data;\n\tstruct snd_timer_instance *ti;\n\n\tmutex_lock(&register_mutex);\n\tlist_del_init(&timer->device_list);\n\t/* wake up pending sleepers */\n\tlist_for_each_entry(ti, &timer->open_list_head, open_list) {\n\t\tif (ti->disconnect)\n\t\t\tti->disconnect(ti);\n\t}\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n}\n\nvoid snd_timer_notify(struct snd_timer *timer, int event, struct timespec *tstamp)\n{\n\tunsigned long flags;\n\tunsigned long resolution = 0;\n\tstruct snd_timer_instance *ti, *ts;\n\n\tif (timer->card && timer->card->shutdown)\n\t\treturn;\n\tif (! (timer->hw.flags & SNDRV_TIMER_HW_SLAVE))\n\t\treturn;\n\tif (snd_BUG_ON(event < SNDRV_TIMER_EVENT_MSTART ||\n\t\t       event > SNDRV_TIMER_EVENT_MRESUME))\n\t\treturn;\n\tspin_lock_irqsave(&timer->lock, flags);\n\tif (event == SNDRV_TIMER_EVENT_MSTART ||\n\t    event == SNDRV_TIMER_EVENT_MCONTINUE ||\n\t    event == SNDRV_TIMER_EVENT_MRESUME)\n\t\tresolution = snd_timer_hw_resolution(timer);\n\tlist_for_each_entry(ti, &timer->active_list_head, active_list) {\n\t\tif (ti->ccallback)\n\t\t\tti->ccallback(ti, event, tstamp, resolution);\n\t\tlist_for_each_entry(ts, &ti->slave_active_head, active_list)\n\t\t\tif (ts->ccallback)\n\t\t\t\tts->ccallback(ts, event, tstamp, resolution);\n\t}\n\tspin_unlock_irqrestore(&timer->lock, flags);\n}\nEXPORT_SYMBOL(snd_timer_notify);\n\n/*\n * exported functions for global timers\n */\nint snd_timer_global_new(char *id, int device, struct snd_timer **rtimer)\n{\n\tstruct snd_timer_id tid;\n\n\ttid.dev_class = SNDRV_TIMER_CLASS_GLOBAL;\n\ttid.dev_sclass = SNDRV_TIMER_SCLASS_NONE;\n\ttid.card = -1;\n\ttid.device = device;\n\ttid.subdevice = 0;\n\treturn snd_timer_new(NULL, id, &tid, rtimer);\n}\nEXPORT_SYMBOL(snd_timer_global_new);\n\nint snd_timer_global_free(struct snd_timer *timer)\n{\n\treturn snd_timer_free(timer);\n}\nEXPORT_SYMBOL(snd_timer_global_free);\n\nint snd_timer_global_register(struct snd_timer *timer)\n{\n\tstruct snd_device dev;\n\n\tmemset(&dev, 0, sizeof(dev));\n\tdev.device_data = timer;\n\treturn snd_timer_dev_register(&dev);\n}\nEXPORT_SYMBOL(snd_timer_global_register);\n\n/*\n *  System timer\n */\n\nstruct snd_timer_system_private {\n\tstruct timer_list tlist;\n\tstruct snd_timer *snd_timer;\n\tunsigned long last_expires;\n\tunsigned long last_jiffies;\n\tunsigned long correction;\n};\n\nstatic void snd_timer_s_function(struct timer_list *t)\n{\n\tstruct snd_timer_system_private *priv = from_timer(priv, t,\n\t\t\t\t\t\t\t\ttlist);\n\tstruct snd_timer *timer = priv->snd_timer;\n\tunsigned long jiff = jiffies;\n\tif (time_after(jiff, priv->last_expires))\n\t\tpriv->correction += (long)jiff - (long)priv->last_expires;\n\tsnd_timer_interrupt(timer, (long)jiff - (long)priv->last_jiffies);\n}\n\nstatic int snd_timer_s_start(struct snd_timer * timer)\n{\n\tstruct snd_timer_system_private *priv;\n\tunsigned long njiff;\n\n\tpriv = (struct snd_timer_system_private *) timer->private_data;\n\tnjiff = (priv->last_jiffies = jiffies);\n\tif (priv->correction > timer->sticks - 1) {\n\t\tpriv->correction -= timer->sticks - 1;\n\t\tnjiff++;\n\t} else {\n\t\tnjiff += timer->sticks - priv->correction;\n\t\tpriv->correction = 0;\n\t}\n\tpriv->last_expires = njiff;\n\tmod_timer(&priv->tlist, njiff);\n\treturn 0;\n}\n\nstatic int snd_timer_s_stop(struct snd_timer * timer)\n{\n\tstruct snd_timer_system_private *priv;\n\tunsigned long jiff;\n\n\tpriv = (struct snd_timer_system_private *) timer->private_data;\n\tdel_timer(&priv->tlist);\n\tjiff = jiffies;\n\tif (time_before(jiff, priv->last_expires))\n\t\ttimer->sticks = priv->last_expires - jiff;\n\telse\n\t\ttimer->sticks = 1;\n\tpriv->correction = 0;\n\treturn 0;\n}\n\nstatic int snd_timer_s_close(struct snd_timer *timer)\n{\n\tstruct snd_timer_system_private *priv;\n\n\tpriv = (struct snd_timer_system_private *)timer->private_data;\n\tdel_timer_sync(&priv->tlist);\n\treturn 0;\n}\n\nstatic struct snd_timer_hardware snd_timer_system =\n{\n\t.flags =\tSNDRV_TIMER_HW_FIRST | SNDRV_TIMER_HW_TASKLET,\n\t.resolution =\t1000000000L / HZ,\n\t.ticks =\t10000000L,\n\t.close =\tsnd_timer_s_close,\n\t.start =\tsnd_timer_s_start,\n\t.stop =\t\tsnd_timer_s_stop\n};\n\nstatic void snd_timer_free_system(struct snd_timer *timer)\n{\n\tkfree(timer->private_data);\n}\n\nstatic int snd_timer_register_system(void)\n{\n\tstruct snd_timer *timer;\n\tstruct snd_timer_system_private *priv;\n\tint err;\n\n\terr = snd_timer_global_new(\"system\", SNDRV_TIMER_GLOBAL_SYSTEM, &timer);\n\tif (err < 0)\n\t\treturn err;\n\tstrcpy(timer->name, \"system timer\");\n\ttimer->hw = snd_timer_system;\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (priv == NULL) {\n\t\tsnd_timer_free(timer);\n\t\treturn -ENOMEM;\n\t}\n\tpriv->snd_timer = timer;\n\ttimer_setup(&priv->tlist, snd_timer_s_function, 0);\n\ttimer->private_data = priv;\n\ttimer->private_free = snd_timer_free_system;\n\treturn snd_timer_global_register(timer);\n}\n\n#ifdef CONFIG_SND_PROC_FS\n/*\n *  Info interface\n */\n\nstatic void snd_timer_proc_read(struct snd_info_entry *entry,\n\t\t\t\tstruct snd_info_buffer *buffer)\n{\n\tstruct snd_timer *timer;\n\tstruct snd_timer_instance *ti;\n\n\tmutex_lock(&register_mutex);\n\tlist_for_each_entry(timer, &snd_timer_list, device_list) {\n\t\tif (timer->card && timer->card->shutdown)\n\t\t\tcontinue;\n\t\tswitch (timer->tmr_class) {\n\t\tcase SNDRV_TIMER_CLASS_GLOBAL:\n\t\t\tsnd_iprintf(buffer, \"G%i: \", timer->tmr_device);\n\t\t\tbreak;\n\t\tcase SNDRV_TIMER_CLASS_CARD:\n\t\t\tsnd_iprintf(buffer, \"C%i-%i: \",\n\t\t\t\t    timer->card->number, timer->tmr_device);\n\t\t\tbreak;\n\t\tcase SNDRV_TIMER_CLASS_PCM:\n\t\t\tsnd_iprintf(buffer, \"P%i-%i-%i: \", timer->card->number,\n\t\t\t\t    timer->tmr_device, timer->tmr_subdevice);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnd_iprintf(buffer, \"?%i-%i-%i-%i: \", timer->tmr_class,\n\t\t\t\t    timer->card ? timer->card->number : -1,\n\t\t\t\t    timer->tmr_device, timer->tmr_subdevice);\n\t\t}\n\t\tsnd_iprintf(buffer, \"%s :\", timer->name);\n\t\tif (timer->hw.resolution)\n\t\t\tsnd_iprintf(buffer, \" %lu.%03luus (%lu ticks)\",\n\t\t\t\t    timer->hw.resolution / 1000,\n\t\t\t\t    timer->hw.resolution % 1000,\n\t\t\t\t    timer->hw.ticks);\n\t\tif (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\t\tsnd_iprintf(buffer, \" SLAVE\");\n\t\tsnd_iprintf(buffer, \"\\n\");\n\t\tlist_for_each_entry(ti, &timer->open_list_head, open_list)\n\t\t\tsnd_iprintf(buffer, \"  Client %s : %s\\n\",\n\t\t\t\t    ti->owner ? ti->owner : \"unknown\",\n\t\t\t\t    ti->flags & (SNDRV_TIMER_IFLG_START |\n\t\t\t\t\t\t SNDRV_TIMER_IFLG_RUNNING)\n\t\t\t\t    ? \"running\" : \"stopped\");\n\t}\n\tmutex_unlock(&register_mutex);\n}\n\nstatic struct snd_info_entry *snd_timer_proc_entry;\n\nstatic void __init snd_timer_proc_init(void)\n{\n\tstruct snd_info_entry *entry;\n\n\tentry = snd_info_create_module_entry(THIS_MODULE, \"timers\", NULL);\n\tif (entry != NULL) {\n\t\tentry->c.text.read = snd_timer_proc_read;\n\t\tif (snd_info_register(entry) < 0) {\n\t\t\tsnd_info_free_entry(entry);\n\t\t\tentry = NULL;\n\t\t}\n\t}\n\tsnd_timer_proc_entry = entry;\n}\n\nstatic void __exit snd_timer_proc_done(void)\n{\n\tsnd_info_free_entry(snd_timer_proc_entry);\n}\n#else /* !CONFIG_SND_PROC_FS */\n#define snd_timer_proc_init()\n#define snd_timer_proc_done()\n#endif\n\n/*\n *  USER SPACE interface\n */\n\nstatic void snd_timer_user_interrupt(struct snd_timer_instance *timeri,\n\t\t\t\t     unsigned long resolution,\n\t\t\t\t     unsigned long ticks)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_read *r;\n\tint prev;\n\n\tspin_lock(&tu->qlock);\n\tif (tu->qused > 0) {\n\t\tprev = tu->qtail == 0 ? tu->queue_size - 1 : tu->qtail - 1;\n\t\tr = &tu->queue[prev];\n\t\tif (r->resolution == resolution) {\n\t\t\tr->ticks += ticks;\n\t\t\tgoto __wake;\n\t\t}\n\t}\n\tif (tu->qused >= tu->queue_size) {\n\t\ttu->overrun++;\n\t} else {\n\t\tr = &tu->queue[tu->qtail++];\n\t\ttu->qtail %= tu->queue_size;\n\t\tr->resolution = resolution;\n\t\tr->ticks = ticks;\n\t\ttu->qused++;\n\t}\n      __wake:\n\tspin_unlock(&tu->qlock);\n\tkill_fasync(&tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}\n\nstatic void snd_timer_user_append_to_tqueue(struct snd_timer_user *tu,\n\t\t\t\t\t    struct snd_timer_tread *tread)\n{\n\tif (tu->qused >= tu->queue_size) {\n\t\ttu->overrun++;\n\t} else {\n\t\tmemcpy(&tu->tqueue[tu->qtail++], tread, sizeof(*tread));\n\t\ttu->qtail %= tu->queue_size;\n\t\ttu->qused++;\n\t}\n}\n\nstatic void snd_timer_user_ccallback(struct snd_timer_instance *timeri,\n\t\t\t\t     int event,\n\t\t\t\t     struct timespec *tstamp,\n\t\t\t\t     unsigned long resolution)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_tread r1;\n\tunsigned long flags;\n\n\tif (event >= SNDRV_TIMER_EVENT_START &&\n\t    event <= SNDRV_TIMER_EVENT_PAUSE)\n\t\ttu->tstamp = *tstamp;\n\tif ((tu->filter & (1 << event)) == 0 || !tu->tread)\n\t\treturn;\n\tmemset(&r1, 0, sizeof(r1));\n\tr1.event = event;\n\tr1.tstamp = *tstamp;\n\tr1.val = resolution;\n\tspin_lock_irqsave(&tu->qlock, flags);\n\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\tspin_unlock_irqrestore(&tu->qlock, flags);\n\tkill_fasync(&tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}\n\nstatic void snd_timer_user_disconnect(struct snd_timer_instance *timeri)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\n\ttu->disconnected = true;\n\twake_up(&tu->qchange_sleep);\n}\n\nstatic void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,\n\t\t\t\t      unsigned long resolution,\n\t\t\t\t      unsigned long ticks)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_tread *r, r1;\n\tstruct timespec tstamp;\n\tint prev, append = 0;\n\n\tmemset(&r1, 0, sizeof(r1));\n\tmemset(&tstamp, 0, sizeof(tstamp));\n\tspin_lock(&tu->qlock);\n\tif ((tu->filter & ((1 << SNDRV_TIMER_EVENT_RESOLUTION) |\n\t\t\t   (1 << SNDRV_TIMER_EVENT_TICK))) == 0) {\n\t\tspin_unlock(&tu->qlock);\n\t\treturn;\n\t}\n\tif (tu->last_resolution != resolution || ticks > 0) {\n\t\tif (timer_tstamp_monotonic)\n\t\t\tktime_get_ts(&tstamp);\n\t\telse\n\t\t\tgetnstimeofday(&tstamp);\n\t}\n\tif ((tu->filter & (1 << SNDRV_TIMER_EVENT_RESOLUTION)) &&\n\t    tu->last_resolution != resolution) {\n\t\tr1.event = SNDRV_TIMER_EVENT_RESOLUTION;\n\t\tr1.tstamp = tstamp;\n\t\tr1.val = resolution;\n\t\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\t\ttu->last_resolution = resolution;\n\t\tappend++;\n\t}\n\tif ((tu->filter & (1 << SNDRV_TIMER_EVENT_TICK)) == 0)\n\t\tgoto __wake;\n\tif (ticks == 0)\n\t\tgoto __wake;\n\tif (tu->qused > 0) {\n\t\tprev = tu->qtail == 0 ? tu->queue_size - 1 : tu->qtail - 1;\n\t\tr = &tu->tqueue[prev];\n\t\tif (r->event == SNDRV_TIMER_EVENT_TICK) {\n\t\t\tr->tstamp = tstamp;\n\t\t\tr->val += ticks;\n\t\t\tappend++;\n\t\t\tgoto __wake;\n\t\t}\n\t}\n\tr1.event = SNDRV_TIMER_EVENT_TICK;\n\tr1.tstamp = tstamp;\n\tr1.val = ticks;\n\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\tappend++;\n      __wake:\n\tspin_unlock(&tu->qlock);\n\tif (append == 0)\n\t\treturn;\n\tkill_fasync(&tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}\n\nstatic int realloc_user_queue(struct snd_timer_user *tu, int size)\n{\n\tstruct snd_timer_read *queue = NULL;\n\tstruct snd_timer_tread *tqueue = NULL;\n\n\tif (tu->tread) {\n\t\ttqueue = kcalloc(size, sizeof(*tqueue), GFP_KERNEL);\n\t\tif (!tqueue)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tqueue = kcalloc(size, sizeof(*queue), GFP_KERNEL);\n\t\tif (!queue)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_irq(&tu->qlock);\n\tkfree(tu->queue);\n\tkfree(tu->tqueue);\n\ttu->queue_size = size;\n\ttu->queue = queue;\n\ttu->tqueue = tqueue;\n\ttu->qhead = tu->qtail = tu->qused = 0;\n\tspin_unlock_irq(&tu->qlock);\n\n\treturn 0;\n}\n\nstatic int snd_timer_user_open(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\tint err;\n\n\terr = stream_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\n\ttu = kzalloc(sizeof(*tu), GFP_KERNEL);\n\tif (tu == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&tu->qlock);\n\tinit_waitqueue_head(&tu->qchange_sleep);\n\tmutex_init(&tu->ioctl_lock);\n\ttu->ticks = 1;\n\tif (realloc_user_queue(tu, 128) < 0) {\n\t\tkfree(tu);\n\t\treturn -ENOMEM;\n\t}\n\tfile->private_data = tu;\n\treturn 0;\n}\n\nstatic int snd_timer_user_release(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\n\tif (file->private_data) {\n\t\ttu = file->private_data;\n\t\tfile->private_data = NULL;\n\t\tmutex_lock(&tu->ioctl_lock);\n\t\tif (tu->timeri)\n\t\t\tsnd_timer_close(tu->timeri);\n\t\tmutex_unlock(&tu->ioctl_lock);\n\t\tkfree(tu->queue);\n\t\tkfree(tu->tqueue);\n\t\tkfree(tu);\n\t}\n\treturn 0;\n}\n\nstatic void snd_timer_user_zero_id(struct snd_timer_id *id)\n{\n\tid->dev_class = SNDRV_TIMER_CLASS_NONE;\n\tid->dev_sclass = SNDRV_TIMER_SCLASS_NONE;\n\tid->card = -1;\n\tid->device = -1;\n\tid->subdevice = -1;\n}\n\nstatic void snd_timer_user_copy_id(struct snd_timer_id *id, struct snd_timer *timer)\n{\n\tid->dev_class = timer->tmr_class;\n\tid->dev_sclass = SNDRV_TIMER_SCLASS_NONE;\n\tid->card = timer->card ? timer->card->number : -1;\n\tid->device = timer->tmr_device;\n\tid->subdevice = timer->tmr_subdevice;\n}\n\nstatic int snd_timer_user_next_device(struct snd_timer_id __user *_tid)\n{\n\tstruct snd_timer_id id;\n\tstruct snd_timer *timer;\n\tstruct list_head *p;\n\n\tif (copy_from_user(&id, _tid, sizeof(id)))\n\t\treturn -EFAULT;\n\tmutex_lock(&register_mutex);\n\tif (id.dev_class < 0) {\t\t/* first item */\n\t\tif (list_empty(&snd_timer_list))\n\t\t\tsnd_timer_user_zero_id(&id);\n\t\telse {\n\t\t\ttimer = list_entry(snd_timer_list.next,\n\t\t\t\t\t   struct snd_timer, device_list);\n\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t}\n\t} else {\n\t\tswitch (id.dev_class) {\n\t\tcase SNDRV_TIMER_CLASS_GLOBAL:\n\t\t\tid.device = id.device < 0 ? 0 : id.device + 1;\n\t\t\tlist_for_each(p, &snd_timer_list) {\n\t\t\t\ttimer = list_entry(p, struct snd_timer, device_list);\n\t\t\t\tif (timer->tmr_class > SNDRV_TIMER_CLASS_GLOBAL) {\n\t\t\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (timer->tmr_device >= id.device) {\n\t\t\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (p == &snd_timer_list)\n\t\t\t\tsnd_timer_user_zero_id(&id);\n\t\t\tbreak;\n\t\tcase SNDRV_TIMER_CLASS_CARD:\n\t\tcase SNDRV_TIMER_CLASS_PCM:\n\t\t\tif (id.card < 0) {\n\t\t\t\tid.card = 0;\n\t\t\t} else {\n\t\t\t\tif (id.device < 0) {\n\t\t\t\t\tid.device = 0;\n\t\t\t\t} else {\n\t\t\t\t\tif (id.subdevice < 0)\n\t\t\t\t\t\tid.subdevice = 0;\n\t\t\t\t\telse if (id.subdevice < INT_MAX)\n\t\t\t\t\t\tid.subdevice++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist_for_each(p, &snd_timer_list) {\n\t\t\t\ttimer = list_entry(p, struct snd_timer, device_list);\n\t\t\t\tif (timer->tmr_class > id.dev_class) {\n\t\t\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (timer->tmr_class < id.dev_class)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (timer->card->number > id.card) {\n\t\t\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (timer->card->number < id.card)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (timer->tmr_device > id.device) {\n\t\t\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (timer->tmr_device < id.device)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (timer->tmr_subdevice > id.subdevice) {\n\t\t\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (timer->tmr_subdevice < id.subdevice)\n\t\t\t\t\tcontinue;\n\t\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p == &snd_timer_list)\n\t\t\t\tsnd_timer_user_zero_id(&id);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnd_timer_user_zero_id(&id);\n\t\t}\n\t}\n\tmutex_unlock(&register_mutex);\n\tif (copy_to_user(_tid, &id, sizeof(*_tid)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int snd_timer_user_ginfo(struct file *file,\n\t\t\t\tstruct snd_timer_ginfo __user *_ginfo)\n{\n\tstruct snd_timer_ginfo *ginfo;\n\tstruct snd_timer_id tid;\n\tstruct snd_timer *t;\n\tstruct list_head *p;\n\tint err = 0;\n\n\tginfo = memdup_user(_ginfo, sizeof(*ginfo));\n\tif (IS_ERR(ginfo))\n\t\treturn PTR_ERR(ginfo);\n\n\ttid = ginfo->tid;\n\tmemset(ginfo, 0, sizeof(*ginfo));\n\tginfo->tid = tid;\n\tmutex_lock(&register_mutex);\n\tt = snd_timer_find(&tid);\n\tif (t != NULL) {\n\t\tginfo->card = t->card ? t->card->number : -1;\n\t\tif (t->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\t\tginfo->flags |= SNDRV_TIMER_FLG_SLAVE;\n\t\tstrlcpy(ginfo->id, t->id, sizeof(ginfo->id));\n\t\tstrlcpy(ginfo->name, t->name, sizeof(ginfo->name));\n\t\tginfo->resolution = t->hw.resolution;\n\t\tif (t->hw.resolution_min > 0) {\n\t\t\tginfo->resolution_min = t->hw.resolution_min;\n\t\t\tginfo->resolution_max = t->hw.resolution_max;\n\t\t}\n\t\tlist_for_each(p, &t->open_list_head) {\n\t\t\tginfo->clients++;\n\t\t}\n\t} else {\n\t\terr = -ENODEV;\n\t}\n\tmutex_unlock(&register_mutex);\n\tif (err >= 0 && copy_to_user(_ginfo, ginfo, sizeof(*ginfo)))\n\t\terr = -EFAULT;\n\tkfree(ginfo);\n\treturn err;\n}\n\nstatic int timer_set_gparams(struct snd_timer_gparams *gparams)\n{\n\tstruct snd_timer *t;\n\tint err;\n\n\tmutex_lock(&register_mutex);\n\tt = snd_timer_find(&gparams->tid);\n\tif (!t) {\n\t\terr = -ENODEV;\n\t\tgoto _error;\n\t}\n\tif (!list_empty(&t->open_list_head)) {\n\t\terr = -EBUSY;\n\t\tgoto _error;\n\t}\n\tif (!t->hw.set_period) {\n\t\terr = -ENOSYS;\n\t\tgoto _error;\n\t}\n\terr = t->hw.set_period(t, gparams->period_num, gparams->period_den);\n_error:\n\tmutex_unlock(&register_mutex);\n\treturn err;\n}\n\nstatic int snd_timer_user_gparams(struct file *file,\n\t\t\t\t  struct snd_timer_gparams __user *_gparams)\n{\n\tstruct snd_timer_gparams gparams;\n\n\tif (copy_from_user(&gparams, _gparams, sizeof(gparams)))\n\t\treturn -EFAULT;\n\treturn timer_set_gparams(&gparams);\n}\n\nstatic int snd_timer_user_gstatus(struct file *file,\n\t\t\t\t  struct snd_timer_gstatus __user *_gstatus)\n{\n\tstruct snd_timer_gstatus gstatus;\n\tstruct snd_timer_id tid;\n\tstruct snd_timer *t;\n\tint err = 0;\n\n\tif (copy_from_user(&gstatus, _gstatus, sizeof(gstatus)))\n\t\treturn -EFAULT;\n\ttid = gstatus.tid;\n\tmemset(&gstatus, 0, sizeof(gstatus));\n\tgstatus.tid = tid;\n\tmutex_lock(&register_mutex);\n\tt = snd_timer_find(&tid);\n\tif (t != NULL) {\n\t\tspin_lock_irq(&t->lock);\n\t\tgstatus.resolution = snd_timer_hw_resolution(t);\n\t\tif (t->hw.precise_resolution) {\n\t\t\tt->hw.precise_resolution(t, &gstatus.resolution_num,\n\t\t\t\t\t\t &gstatus.resolution_den);\n\t\t} else {\n\t\t\tgstatus.resolution_num = gstatus.resolution;\n\t\t\tgstatus.resolution_den = 1000000000uL;\n\t\t}\n\t\tspin_unlock_irq(&t->lock);\n\t} else {\n\t\terr = -ENODEV;\n\t}\n\tmutex_unlock(&register_mutex);\n\tif (err >= 0 && copy_to_user(_gstatus, &gstatus, sizeof(gstatus)))\n\t\terr = -EFAULT;\n\treturn err;\n}\n\nstatic int snd_timer_user_tselect(struct file *file,\n\t\t\t\t  struct snd_timer_select __user *_tselect)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_select tselect;\n\tchar str[32];\n\tint err = 0;\n\n\ttu = file->private_data;\n\tif (tu->timeri) {\n\t\tsnd_timer_close(tu->timeri);\n\t\ttu->timeri = NULL;\n\t}\n\tif (copy_from_user(&tselect, _tselect, sizeof(tselect))) {\n\t\terr = -EFAULT;\n\t\tgoto __err;\n\t}\n\tsprintf(str, \"application %i\", current->pid);\n\tif (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)\n\t\ttselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;\n\terr = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid);\n\tif (err < 0)\n\t\tgoto __err;\n\n\ttu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;\n\ttu->timeri->callback = tu->tread\n\t\t\t? snd_timer_user_tinterrupt : snd_timer_user_interrupt;\n\ttu->timeri->ccallback = snd_timer_user_ccallback;\n\ttu->timeri->callback_data = (void *)tu;\n\ttu->timeri->disconnect = snd_timer_user_disconnect;\n\n      __err:\n\treturn err;\n}\n\nstatic int snd_timer_user_info(struct file *file,\n\t\t\t       struct snd_timer_info __user *_info)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_info *info;\n\tstruct snd_timer *t;\n\tint err = 0;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\tt = tu->timeri->timer;\n\tif (!t)\n\t\treturn -EBADFD;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (! info)\n\t\treturn -ENOMEM;\n\tinfo->card = t->card ? t->card->number : -1;\n\tif (t->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\tinfo->flags |= SNDRV_TIMER_FLG_SLAVE;\n\tstrlcpy(info->id, t->id, sizeof(info->id));\n\tstrlcpy(info->name, t->name, sizeof(info->name));\n\tinfo->resolution = t->hw.resolution;\n\tif (copy_to_user(_info, info, sizeof(*_info)))\n\t\terr = -EFAULT;\n\tkfree(info);\n\treturn err;\n}\n\nstatic int snd_timer_user_params(struct file *file,\n\t\t\t\t struct snd_timer_params __user *_params)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_params params;\n\tstruct snd_timer *t;\n\tint err;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\tt = tu->timeri->timer;\n\tif (!t)\n\t\treturn -EBADFD;\n\tif (copy_from_user(&params, _params, sizeof(params)))\n\t\treturn -EFAULT;\n\tif (!(t->hw.flags & SNDRV_TIMER_HW_SLAVE)) {\n\t\tu64 resolution;\n\n\t\tif (params.ticks < 1) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto _end;\n\t\t}\n\n\t\t/* Don't allow resolution less than 1ms */\n\t\tresolution = snd_timer_resolution(tu->timeri);\n\t\tresolution *= params.ticks;\n\t\tif (resolution < 1000000) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto _end;\n\t\t}\n\t}\n\tif (params.queue_size > 0 &&\n\t    (params.queue_size < 32 || params.queue_size > 1024)) {\n\t\terr = -EINVAL;\n\t\tgoto _end;\n\t}\n\tif (params.filter & ~((1<<SNDRV_TIMER_EVENT_RESOLUTION)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_TICK)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_START)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_STOP)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_CONTINUE)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_PAUSE)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_SUSPEND)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_RESUME)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MSTART)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MSTOP)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MCONTINUE)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MPAUSE)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MSUSPEND)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MRESUME))) {\n\t\terr = -EINVAL;\n\t\tgoto _end;\n\t}\n\tsnd_timer_stop(tu->timeri);\n\tspin_lock_irq(&t->lock);\n\ttu->timeri->flags &= ~(SNDRV_TIMER_IFLG_AUTO|\n\t\t\t       SNDRV_TIMER_IFLG_EXCLUSIVE|\n\t\t\t       SNDRV_TIMER_IFLG_EARLY_EVENT);\n\tif (params.flags & SNDRV_TIMER_PSFLG_AUTO)\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_AUTO;\n\tif (params.flags & SNDRV_TIMER_PSFLG_EXCLUSIVE)\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_EXCLUSIVE;\n\tif (params.flags & SNDRV_TIMER_PSFLG_EARLY_EVENT)\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_EARLY_EVENT;\n\tspin_unlock_irq(&t->lock);\n\tif (params.queue_size > 0 &&\n\t    (unsigned int)tu->queue_size != params.queue_size) {\n\t\terr = realloc_user_queue(tu, params.queue_size);\n\t\tif (err < 0)\n\t\t\tgoto _end;\n\t}\n\tspin_lock_irq(&tu->qlock);\n\ttu->qhead = tu->qtail = tu->qused = 0;\n\tif (tu->timeri->flags & SNDRV_TIMER_IFLG_EARLY_EVENT) {\n\t\tif (tu->tread) {\n\t\t\tstruct snd_timer_tread tread;\n\t\t\tmemset(&tread, 0, sizeof(tread));\n\t\t\ttread.event = SNDRV_TIMER_EVENT_EARLY;\n\t\t\ttread.tstamp.tv_sec = 0;\n\t\t\ttread.tstamp.tv_nsec = 0;\n\t\t\ttread.val = 0;\n\t\t\tsnd_timer_user_append_to_tqueue(tu, &tread);\n\t\t} else {\n\t\t\tstruct snd_timer_read *r = &tu->queue[0];\n\t\t\tr->resolution = 0;\n\t\t\tr->ticks = 0;\n\t\t\ttu->qused++;\n\t\t\ttu->qtail++;\n\t\t}\n\t}\n\ttu->filter = params.filter;\n\ttu->ticks = params.ticks;\n\tspin_unlock_irq(&tu->qlock);\n\terr = 0;\n _end:\n\tif (copy_to_user(_params, &params, sizeof(params)))\n\t\treturn -EFAULT;\n\treturn err;\n}\n\nstatic int snd_timer_user_status(struct file *file,\n\t\t\t\t struct snd_timer_status __user *_status)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_status status;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\tmemset(&status, 0, sizeof(status));\n\tstatus.tstamp = tu->tstamp;\n\tstatus.resolution = snd_timer_resolution(tu->timeri);\n\tstatus.lost = tu->timeri->lost;\n\tstatus.overrun = tu->overrun;\n\tspin_lock_irq(&tu->qlock);\n\tstatus.queue = tu->qused;\n\tspin_unlock_irq(&tu->qlock);\n\tif (copy_to_user(_status, &status, sizeof(status)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int snd_timer_user_start(struct file *file)\n{\n\tint err;\n\tstruct snd_timer_user *tu;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\tsnd_timer_stop(tu->timeri);\n\ttu->timeri->lost = 0;\n\ttu->last_resolution = 0;\n\terr = snd_timer_start(tu->timeri, tu->ticks);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic int snd_timer_user_stop(struct file *file)\n{\n\tint err;\n\tstruct snd_timer_user *tu;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\terr = snd_timer_stop(tu->timeri);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic int snd_timer_user_continue(struct file *file)\n{\n\tint err;\n\tstruct snd_timer_user *tu;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\t/* start timer instead of continue if it's not used before */\n\tif (!(tu->timeri->flags & SNDRV_TIMER_IFLG_PAUSED))\n\t\treturn snd_timer_user_start(file);\n\ttu->timeri->lost = 0;\n\terr = snd_timer_continue(tu->timeri);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic int snd_timer_user_pause(struct file *file)\n{\n\tint err;\n\tstruct snd_timer_user *tu;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\terr = snd_timer_pause(tu->timeri);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nenum {\n\tSNDRV_TIMER_IOCTL_START_OLD = _IO('T', 0x20),\n\tSNDRV_TIMER_IOCTL_STOP_OLD = _IO('T', 0x21),\n\tSNDRV_TIMER_IOCTL_CONTINUE_OLD = _IO('T', 0x22),\n\tSNDRV_TIMER_IOCTL_PAUSE_OLD = _IO('T', 0x23),\n};\n\nstatic long __snd_timer_user_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct snd_timer_user *tu;\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\n\ttu = file->private_data;\n\tswitch (cmd) {\n\tcase SNDRV_TIMER_IOCTL_PVERSION:\n\t\treturn put_user(SNDRV_TIMER_VERSION, p) ? -EFAULT : 0;\n\tcase SNDRV_TIMER_IOCTL_NEXT_DEVICE:\n\t\treturn snd_timer_user_next_device(argp);\n\tcase SNDRV_TIMER_IOCTL_TREAD:\n\t{\n\t\tint xarg, old_tread;\n\n\t\tif (tu->timeri)\t/* too late */\n\t\t\treturn -EBUSY;\n\t\tif (get_user(xarg, p))\n\t\t\treturn -EFAULT;\n\t\told_tread = tu->tread;\n\t\ttu->tread = xarg ? 1 : 0;\n\t\tif (tu->tread != old_tread &&\n\t\t    realloc_user_queue(tu, tu->queue_size) < 0) {\n\t\t\ttu->tread = old_tread;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\treturn 0;\n\t}\n\tcase SNDRV_TIMER_IOCTL_GINFO:\n\t\treturn snd_timer_user_ginfo(file, argp);\n\tcase SNDRV_TIMER_IOCTL_GPARAMS:\n\t\treturn snd_timer_user_gparams(file, argp);\n\tcase SNDRV_TIMER_IOCTL_GSTATUS:\n\t\treturn snd_timer_user_gstatus(file, argp);\n\tcase SNDRV_TIMER_IOCTL_SELECT:\n\t\treturn snd_timer_user_tselect(file, argp);\n\tcase SNDRV_TIMER_IOCTL_INFO:\n\t\treturn snd_timer_user_info(file, argp);\n\tcase SNDRV_TIMER_IOCTL_PARAMS:\n\t\treturn snd_timer_user_params(file, argp);\n\tcase SNDRV_TIMER_IOCTL_STATUS:\n\t\treturn snd_timer_user_status(file, argp);\n\tcase SNDRV_TIMER_IOCTL_START:\n\tcase SNDRV_TIMER_IOCTL_START_OLD:\n\t\treturn snd_timer_user_start(file);\n\tcase SNDRV_TIMER_IOCTL_STOP:\n\tcase SNDRV_TIMER_IOCTL_STOP_OLD:\n\t\treturn snd_timer_user_stop(file);\n\tcase SNDRV_TIMER_IOCTL_CONTINUE:\n\tcase SNDRV_TIMER_IOCTL_CONTINUE_OLD:\n\t\treturn snd_timer_user_continue(file);\n\tcase SNDRV_TIMER_IOCTL_PAUSE:\n\tcase SNDRV_TIMER_IOCTL_PAUSE_OLD:\n\t\treturn snd_timer_user_pause(file);\n\t}\n\treturn -ENOTTY;\n}\n\nstatic long snd_timer_user_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct snd_timer_user *tu = file->private_data;\n\tlong ret;\n\n\tmutex_lock(&tu->ioctl_lock);\n\tret = __snd_timer_user_ioctl(file, cmd, arg);\n\tmutex_unlock(&tu->ioctl_lock);\n\treturn ret;\n}\n\nstatic int snd_timer_user_fasync(int fd, struct file * file, int on)\n{\n\tstruct snd_timer_user *tu;\n\n\ttu = file->private_data;\n\treturn fasync_helper(fd, file, on, &tu->fasync);\n}\n\nstatic ssize_t snd_timer_user_read(struct file *file, char __user *buffer,\n\t\t\t\t   size_t count, loff_t *offset)\n{\n\tstruct snd_timer_user *tu;\n\tlong result = 0, unit;\n\tint qhead;\n\tint err = 0;\n\n\ttu = file->private_data;\n\tunit = tu->tread ? sizeof(struct snd_timer_tread) : sizeof(struct snd_timer_read);\n\tmutex_lock(&tu->ioctl_lock);\n\tspin_lock_irq(&tu->qlock);\n\twhile ((long)count - result >= unit) {\n\t\twhile (!tu->qused) {\n\t\t\twait_queue_entry_t wait;\n\n\t\t\tif ((file->f_flags & O_NONBLOCK) != 0 || result > 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto _error;\n\t\t\t}\n\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tinit_waitqueue_entry(&wait, current);\n\t\t\tadd_wait_queue(&tu->qchange_sleep, &wait);\n\n\t\t\tspin_unlock_irq(&tu->qlock);\n\t\t\tmutex_unlock(&tu->ioctl_lock);\n\t\t\tschedule();\n\t\t\tmutex_lock(&tu->ioctl_lock);\n\t\t\tspin_lock_irq(&tu->qlock);\n\n\t\t\tremove_wait_queue(&tu->qchange_sleep, &wait);\n\n\t\t\tif (tu->disconnected) {\n\t\t\t\terr = -ENODEV;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t\tif (signal_pending(current)) {\n\t\t\t\terr = -ERESTARTSYS;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t}\n\n\t\tqhead = tu->qhead++;\n\t\ttu->qhead %= tu->queue_size;\n\t\ttu->qused--;\n\t\tspin_unlock_irq(&tu->qlock);\n\n\t\tif (tu->tread) {\n\t\t\tif (copy_to_user(buffer, &tu->tqueue[qhead],\n\t\t\t\t\t sizeof(struct snd_timer_tread)))\n\t\t\t\terr = -EFAULT;\n\t\t} else {\n\t\t\tif (copy_to_user(buffer, &tu->queue[qhead],\n\t\t\t\t\t sizeof(struct snd_timer_read)))\n\t\t\t\terr = -EFAULT;\n\t\t}\n\n\t\tspin_lock_irq(&tu->qlock);\n\t\tif (err < 0)\n\t\t\tgoto _error;\n\t\tresult += unit;\n\t\tbuffer += unit;\n\t}\n _error:\n\tspin_unlock_irq(&tu->qlock);\n\tmutex_unlock(&tu->ioctl_lock);\n\treturn result > 0 ? result : err;\n}\n\nstatic __poll_t snd_timer_user_poll(struct file *file, poll_table * wait)\n{\n        __poll_t mask;\n        struct snd_timer_user *tu;\n\n        tu = file->private_data;\n\n        poll_wait(file, &tu->qchange_sleep, wait);\n\n\tmask = 0;\n\tspin_lock_irq(&tu->qlock);\n\tif (tu->qused)\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\tif (tu->disconnected)\n\t\tmask |= EPOLLERR;\n\tspin_unlock_irq(&tu->qlock);\n\n\treturn mask;\n}\n\n#ifdef CONFIG_COMPAT\n#include \"timer_compat.c\"\n#else\n#define snd_timer_user_ioctl_compat\tNULL\n#endif\n\nstatic const struct file_operations snd_timer_f_ops =\n{\n\t.owner =\tTHIS_MODULE,\n\t.read =\t\tsnd_timer_user_read,\n\t.open =\t\tsnd_timer_user_open,\n\t.release =\tsnd_timer_user_release,\n\t.llseek =\tno_llseek,\n\t.poll =\t\tsnd_timer_user_poll,\n\t.unlocked_ioctl =\tsnd_timer_user_ioctl,\n\t.compat_ioctl =\tsnd_timer_user_ioctl_compat,\n\t.fasync = \tsnd_timer_user_fasync,\n};\n\n/* unregister the system timer */\nstatic void snd_timer_free_all(void)\n{\n\tstruct snd_timer *timer, *n;\n\n\tlist_for_each_entry_safe(timer, n, &snd_timer_list, device_list)\n\t\tsnd_timer_free(timer);\n}\n\nstatic struct device timer_dev;\n\n/*\n *  ENTRY functions\n */\n\nstatic int __init alsa_timer_init(void)\n{\n\tint err;\n\n\tsnd_device_initialize(&timer_dev, NULL);\n\tdev_set_name(&timer_dev, \"timer\");\n\n#ifdef SNDRV_OSS_INFO_DEV_TIMERS\n\tsnd_oss_info_register(SNDRV_OSS_INFO_DEV_TIMERS, SNDRV_CARDS - 1,\n\t\t\t      \"system timer\");\n#endif\n\n\terr = snd_timer_register_system();\n\tif (err < 0) {\n\t\tpr_err(\"ALSA: unable to register system timer (%i)\\n\", err);\n\t\tgoto put_timer;\n\t}\n\n\terr = snd_register_device(SNDRV_DEVICE_TYPE_TIMER, NULL, 0,\n\t\t\t\t  &snd_timer_f_ops, NULL, &timer_dev);\n\tif (err < 0) {\n\t\tpr_err(\"ALSA: unable to register timer device (%i)\\n\", err);\n\t\tsnd_timer_free_all();\n\t\tgoto put_timer;\n\t}\n\n\tsnd_timer_proc_init();\n\treturn 0;\n\nput_timer:\n\tput_device(&timer_dev);\n\treturn err;\n}\n\nstatic void __exit alsa_timer_exit(void)\n{\n\tsnd_unregister_device(&timer_dev);\n\tsnd_timer_free_all();\n\tput_device(&timer_dev);\n\tsnd_timer_proc_done();\n#ifdef SNDRV_OSS_INFO_DEV_TIMERS\n\tsnd_oss_info_unregister(SNDRV_OSS_INFO_DEV_TIMERS, SNDRV_CARDS - 1);\n#endif\n}\n\nmodule_init(alsa_timer_init)\nmodule_exit(alsa_timer_exit)\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *  Timers abstract layer\n *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>\n */\n\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/sched/signal.h>\n#include <sound/core.h>\n#include <sound/timer.h>\n#include <sound/control.h>\n#include <sound/info.h>\n#include <sound/minors.h>\n#include <sound/initval.h>\n#include <linux/kmod.h>\n\n/* internal flags */\n#define SNDRV_TIMER_IFLG_PAUSED\t\t0x00010000\n#define SNDRV_TIMER_IFLG_DEAD\t\t0x00020000\n\n#if IS_ENABLED(CONFIG_SND_HRTIMER)\n#define DEFAULT_TIMER_LIMIT 4\n#else\n#define DEFAULT_TIMER_LIMIT 1\n#endif\n\nstatic int timer_limit = DEFAULT_TIMER_LIMIT;\nstatic int timer_tstamp_monotonic = 1;\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>, Takashi Iwai <tiwai@suse.de>\");\nMODULE_DESCRIPTION(\"ALSA timer interface\");\nMODULE_LICENSE(\"GPL\");\nmodule_param(timer_limit, int, 0444);\nMODULE_PARM_DESC(timer_limit, \"Maximum global timers in system.\");\nmodule_param(timer_tstamp_monotonic, int, 0444);\nMODULE_PARM_DESC(timer_tstamp_monotonic, \"Use posix monotonic clock source for timestamps (default).\");\n\nMODULE_ALIAS_CHARDEV(CONFIG_SND_MAJOR, SNDRV_MINOR_TIMER);\nMODULE_ALIAS(\"devname:snd/timer\");\n\nstruct snd_timer_user {\n\tstruct snd_timer_instance *timeri;\n\tint tread;\t\t/* enhanced read with timestamps and events */\n\tunsigned long ticks;\n\tunsigned long overrun;\n\tint qhead;\n\tint qtail;\n\tint qused;\n\tint queue_size;\n\tbool disconnected;\n\tstruct snd_timer_read *queue;\n\tstruct snd_timer_tread *tqueue;\n\tspinlock_t qlock;\n\tunsigned long last_resolution;\n\tunsigned int filter;\n\tstruct timespec tstamp;\t\t/* trigger tstamp */\n\twait_queue_head_t qchange_sleep;\n\tstruct fasync_struct *fasync;\n\tstruct mutex ioctl_lock;\n};\n\n/* list of timers */\nstatic LIST_HEAD(snd_timer_list);\n\n/* list of slave instances */\nstatic LIST_HEAD(snd_timer_slave_list);\n\n/* lock for slave active lists */\nstatic DEFINE_SPINLOCK(slave_active_lock);\n\nstatic DEFINE_MUTEX(register_mutex);\n\nstatic int snd_timer_free(struct snd_timer *timer);\nstatic int snd_timer_dev_free(struct snd_device *device);\nstatic int snd_timer_dev_register(struct snd_device *device);\nstatic int snd_timer_dev_disconnect(struct snd_device *device);\n\nstatic void snd_timer_reschedule(struct snd_timer * timer, unsigned long ticks_left);\n\n/*\n * create a timer instance with the given owner string.\n * when timer is not NULL, increments the module counter\n */\nstatic struct snd_timer_instance *snd_timer_instance_new(char *owner,\n\t\t\t\t\t\t\t struct snd_timer *timer)\n{\n\tstruct snd_timer_instance *timeri;\n\ttimeri = kzalloc(sizeof(*timeri), GFP_KERNEL);\n\tif (timeri == NULL)\n\t\treturn NULL;\n\ttimeri->owner = kstrdup(owner, GFP_KERNEL);\n\tif (! timeri->owner) {\n\t\tkfree(timeri);\n\t\treturn NULL;\n\t}\n\tINIT_LIST_HEAD(&timeri->open_list);\n\tINIT_LIST_HEAD(&timeri->active_list);\n\tINIT_LIST_HEAD(&timeri->ack_list);\n\tINIT_LIST_HEAD(&timeri->slave_list_head);\n\tINIT_LIST_HEAD(&timeri->slave_active_head);\n\n\ttimeri->timer = timer;\n\tif (timer && !try_module_get(timer->module)) {\n\t\tkfree(timeri->owner);\n\t\tkfree(timeri);\n\t\treturn NULL;\n\t}\n\n\treturn timeri;\n}\n\n/*\n * find a timer instance from the given timer id\n */\nstatic struct snd_timer *snd_timer_find(struct snd_timer_id *tid)\n{\n\tstruct snd_timer *timer = NULL;\n\n\tlist_for_each_entry(timer, &snd_timer_list, device_list) {\n\t\tif (timer->tmr_class != tid->dev_class)\n\t\t\tcontinue;\n\t\tif ((timer->tmr_class == SNDRV_TIMER_CLASS_CARD ||\n\t\t     timer->tmr_class == SNDRV_TIMER_CLASS_PCM) &&\n\t\t    (timer->card == NULL ||\n\t\t     timer->card->number != tid->card))\n\t\t\tcontinue;\n\t\tif (timer->tmr_device != tid->device)\n\t\t\tcontinue;\n\t\tif (timer->tmr_subdevice != tid->subdevice)\n\t\t\tcontinue;\n\t\treturn timer;\n\t}\n\treturn NULL;\n}\n\n#ifdef CONFIG_MODULES\n\nstatic void snd_timer_request(struct snd_timer_id *tid)\n{\n\tswitch (tid->dev_class) {\n\tcase SNDRV_TIMER_CLASS_GLOBAL:\n\t\tif (tid->device < timer_limit)\n\t\t\trequest_module(\"snd-timer-%i\", tid->device);\n\t\tbreak;\n\tcase SNDRV_TIMER_CLASS_CARD:\n\tcase SNDRV_TIMER_CLASS_PCM:\n\t\tif (tid->card < snd_ecards_limit)\n\t\t\trequest_module(\"snd-card-%i\", tid->card);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n#endif\n\n/*\n * look for a master instance matching with the slave id of the given slave.\n * when found, relink the open_link of the slave.\n *\n * call this with register_mutex down.\n */\nstatic int snd_timer_check_slave(struct snd_timer_instance *slave)\n{\n\tstruct snd_timer *timer;\n\tstruct snd_timer_instance *master;\n\n\t/* FIXME: it's really dumb to look up all entries.. */\n\tlist_for_each_entry(timer, &snd_timer_list, device_list) {\n\t\tlist_for_each_entry(master, &timer->open_list_head, open_list) {\n\t\t\tif (slave->slave_class == master->slave_class &&\n\t\t\t    slave->slave_id == master->slave_id) {\n\t\t\t\tif (master->timer->num_instances >=\n\t\t\t\t    master->timer->max_instances)\n\t\t\t\t\treturn -EBUSY;\n\t\t\t\tlist_move_tail(&slave->open_list,\n\t\t\t\t\t       &master->slave_list_head);\n\t\t\t\tmaster->timer->num_instances++;\n\t\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t\t\tslave->master = master;\n\t\t\t\tslave->timer = master->timer;\n\t\t\t\tspin_unlock_irq(&slave_active_lock);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * look for slave instances matching with the slave id of the given master.\n * when found, relink the open_link of slaves.\n *\n * call this with register_mutex down.\n */\nstatic int snd_timer_check_master(struct snd_timer_instance *master)\n{\n\tstruct snd_timer_instance *slave, *tmp;\n\n\t/* check all pending slaves */\n\tlist_for_each_entry_safe(slave, tmp, &snd_timer_slave_list, open_list) {\n\t\tif (slave->slave_class == master->slave_class &&\n\t\t    slave->slave_id == master->slave_id) {\n\t\t\tif (master->timer->num_instances >=\n\t\t\t    master->timer->max_instances)\n\t\t\t\treturn -EBUSY;\n\t\t\tlist_move_tail(&slave->open_list, &master->slave_list_head);\n\t\t\tmaster->timer->num_instances++;\n\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t\tspin_lock(&master->timer->lock);\n\t\t\tslave->master = master;\n\t\t\tslave->timer = master->timer;\n\t\t\tif (slave->flags & SNDRV_TIMER_IFLG_RUNNING)\n\t\t\t\tlist_add_tail(&slave->active_list,\n\t\t\t\t\t      &master->slave_active_head);\n\t\t\tspin_unlock(&master->timer->lock);\n\t\t\tspin_unlock_irq(&slave_active_lock);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int snd_timer_close_locked(struct snd_timer_instance *timeri,\n\t\t\t\t  struct device **card_devp_to_put);\n\n/*\n * open a timer instance\n * when opening a master, the slave id must be here given.\n */\nint snd_timer_open(struct snd_timer_instance **ti,\n\t\t   char *owner, struct snd_timer_id *tid,\n\t\t   unsigned int slave_id)\n{\n\tstruct snd_timer *timer;\n\tstruct snd_timer_instance *timeri = NULL;\n\tstruct device *card_dev_to_put = NULL;\n\tint err;\n\n\tmutex_lock(&register_mutex);\n\tif (tid->dev_class == SNDRV_TIMER_CLASS_SLAVE) {\n\t\t/* open a slave instance */\n\t\tif (tid->dev_sclass <= SNDRV_TIMER_SCLASS_NONE ||\n\t\t    tid->dev_sclass > SNDRV_TIMER_SCLASS_OSS_SEQUENCER) {\n\t\t\tpr_debug(\"ALSA: timer: invalid slave class %i\\n\",\n\t\t\t\t tid->dev_sclass);\n\t\t\terr = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\t\ttimeri = snd_timer_instance_new(owner, NULL);\n\t\tif (!timeri) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unlock;\n\t\t}\n\t\ttimeri->slave_class = tid->dev_sclass;\n\t\ttimeri->slave_id = tid->device;\n\t\ttimeri->flags |= SNDRV_TIMER_IFLG_SLAVE;\n\t\tlist_add_tail(&timeri->open_list, &snd_timer_slave_list);\n\t\terr = snd_timer_check_slave(timeri);\n\t\tif (err < 0) {\n\t\t\tsnd_timer_close_locked(timeri, &card_dev_to_put);\n\t\t\ttimeri = NULL;\n\t\t}\n\t\tgoto unlock;\n\t}\n\n\t/* open a master instance */\n\ttimer = snd_timer_find(tid);\n#ifdef CONFIG_MODULES\n\tif (!timer) {\n\t\tmutex_unlock(&register_mutex);\n\t\tsnd_timer_request(tid);\n\t\tmutex_lock(&register_mutex);\n\t\ttimer = snd_timer_find(tid);\n\t}\n#endif\n\tif (!timer) {\n\t\terr = -ENODEV;\n\t\tgoto unlock;\n\t}\n\tif (!list_empty(&timer->open_list_head)) {\n\t\tstruct snd_timer_instance *t =\n\t\t\tlist_entry(timer->open_list_head.next,\n\t\t\t\t    struct snd_timer_instance, open_list);\n\t\tif (t->flags & SNDRV_TIMER_IFLG_EXCLUSIVE) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\tif (timer->num_instances >= timer->max_instances) {\n\t\terr = -EBUSY;\n\t\tgoto unlock;\n\t}\n\ttimeri = snd_timer_instance_new(owner, timer);\n\tif (!timeri) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\t/* take a card refcount for safe disconnection */\n\tif (timer->card)\n\t\tget_device(&timer->card->card_dev);\n\ttimeri->slave_class = tid->dev_sclass;\n\ttimeri->slave_id = slave_id;\n\n\tif (list_empty(&timer->open_list_head) && timer->hw.open) {\n\t\terr = timer->hw.open(timer);\n\t\tif (err) {\n\t\t\tkfree(timeri->owner);\n\t\t\tkfree(timeri);\n\t\t\ttimeri = NULL;\n\n\t\t\tif (timer->card)\n\t\t\t\tcard_dev_to_put = &timer->card->card_dev;\n\t\t\tmodule_put(timer->module);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tlist_add_tail(&timeri->open_list, &timer->open_list_head);\n\ttimer->num_instances++;\n\terr = snd_timer_check_master(timeri);\n\tif (err < 0) {\n\t\tsnd_timer_close_locked(timeri, &card_dev_to_put);\n\t\ttimeri = NULL;\n\t}\n\n unlock:\n\tmutex_unlock(&register_mutex);\n\t/* put_device() is called after unlock for avoiding deadlock */\n\tif (card_dev_to_put)\n\t\tput_device(card_dev_to_put);\n\t*ti = timeri;\n\treturn err;\n}\nEXPORT_SYMBOL(snd_timer_open);\n\n/*\n * close a timer instance\n * call this with register_mutex down.\n */\nstatic int snd_timer_close_locked(struct snd_timer_instance *timeri,\n\t\t\t\t  struct device **card_devp_to_put)\n{\n\tstruct snd_timer *timer = timeri->timer;\n\tstruct snd_timer_instance *slave, *tmp;\n\n\tif (timer) {\n\t\tspin_lock_irq(&timer->lock);\n\t\ttimeri->flags |= SNDRV_TIMER_IFLG_DEAD;\n\t\tspin_unlock_irq(&timer->lock);\n\t}\n\n\tlist_del(&timeri->open_list);\n\n\t/* force to stop the timer */\n\tsnd_timer_stop(timeri);\n\n\tif (timer) {\n\t\ttimer->num_instances--;\n\t\t/* wait, until the active callback is finished */\n\t\tspin_lock_irq(&timer->lock);\n\t\twhile (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {\n\t\t\tspin_unlock_irq(&timer->lock);\n\t\t\tudelay(10);\n\t\t\tspin_lock_irq(&timer->lock);\n\t\t}\n\t\tspin_unlock_irq(&timer->lock);\n\n\t\t/* remove slave links */\n\t\tspin_lock_irq(&slave_active_lock);\n\t\tspin_lock(&timer->lock);\n\t\tlist_for_each_entry_safe(slave, tmp, &timeri->slave_list_head,\n\t\t\t\t\t open_list) {\n\t\t\tlist_move_tail(&slave->open_list, &snd_timer_slave_list);\n\t\t\ttimer->num_instances--;\n\t\t\tslave->master = NULL;\n\t\t\tslave->timer = NULL;\n\t\t\tlist_del_init(&slave->ack_list);\n\t\t\tlist_del_init(&slave->active_list);\n\t\t}\n\t\tspin_unlock(&timer->lock);\n\t\tspin_unlock_irq(&slave_active_lock);\n\n\t\t/* slave doesn't need to release timer resources below */\n\t\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE)\n\t\t\ttimer = NULL;\n\t}\n\n\tif (timeri->private_free)\n\t\ttimeri->private_free(timeri);\n\tkfree(timeri->owner);\n\tkfree(timeri);\n\n\tif (timer) {\n\t\tif (list_empty(&timer->open_list_head) && timer->hw.close)\n\t\t\ttimer->hw.close(timer);\n\t\t/* release a card refcount for safe disconnection */\n\t\tif (timer->card)\n\t\t\t*card_devp_to_put = &timer->card->card_dev;\n\t\tmodule_put(timer->module);\n\t}\n\n\treturn 0;\n}\n\n/*\n * close a timer instance\n */\nint snd_timer_close(struct snd_timer_instance *timeri)\n{\n\tstruct device *card_dev_to_put = NULL;\n\tint err;\n\n\tif (snd_BUG_ON(!timeri))\n\t\treturn -ENXIO;\n\n\tmutex_lock(&register_mutex);\n\terr = snd_timer_close_locked(timeri, &card_dev_to_put);\n\tmutex_unlock(&register_mutex);\n\t/* put_device() is called after unlock for avoiding deadlock */\n\tif (card_dev_to_put)\n\t\tput_device(card_dev_to_put);\n\treturn err;\n}\nEXPORT_SYMBOL(snd_timer_close);\n\nstatic unsigned long snd_timer_hw_resolution(struct snd_timer *timer)\n{\n\tif (timer->hw.c_resolution)\n\t\treturn timer->hw.c_resolution(timer);\n\telse\n\t\treturn timer->hw.resolution;\n}\n\nunsigned long snd_timer_resolution(struct snd_timer_instance *timeri)\n{\n\tstruct snd_timer * timer;\n\tunsigned long ret = 0;\n\tunsigned long flags;\n\n\tif (timeri == NULL)\n\t\treturn 0;\n\ttimer = timeri->timer;\n\tif (timer) {\n\t\tspin_lock_irqsave(&timer->lock, flags);\n\t\tret = snd_timer_hw_resolution(timer);\n\t\tspin_unlock_irqrestore(&timer->lock, flags);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(snd_timer_resolution);\n\nstatic void snd_timer_notify1(struct snd_timer_instance *ti, int event)\n{\n\tstruct snd_timer *timer = ti->timer;\n\tunsigned long resolution = 0;\n\tstruct snd_timer_instance *ts;\n\tstruct timespec tstamp;\n\n\tif (timer_tstamp_monotonic)\n\t\tktime_get_ts(&tstamp);\n\telse\n\t\tgetnstimeofday(&tstamp);\n\tif (snd_BUG_ON(event < SNDRV_TIMER_EVENT_START ||\n\t\t       event > SNDRV_TIMER_EVENT_PAUSE))\n\t\treturn;\n\tif (timer &&\n\t    (event == SNDRV_TIMER_EVENT_START ||\n\t     event == SNDRV_TIMER_EVENT_CONTINUE))\n\t\tresolution = snd_timer_hw_resolution(timer);\n\tif (ti->ccallback)\n\t\tti->ccallback(ti, event, &tstamp, resolution);\n\tif (ti->flags & SNDRV_TIMER_IFLG_SLAVE)\n\t\treturn;\n\tif (timer == NULL)\n\t\treturn;\n\tif (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\treturn;\n\tlist_for_each_entry(ts, &ti->slave_active_head, active_list)\n\t\tif (ts->ccallback)\n\t\t\tts->ccallback(ts, event + 100, &tstamp, resolution);\n}\n\n/* start/continue a master timer */\nstatic int snd_timer_start1(struct snd_timer_instance *timeri,\n\t\t\t    bool start, unsigned long ticks)\n{\n\tstruct snd_timer *timer;\n\tint result;\n\tunsigned long flags;\n\n\ttimer = timeri->timer;\n\tif (!timer)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&timer->lock, flags);\n\tif (timeri->flags & SNDRV_TIMER_IFLG_DEAD) {\n\t\tresult = -EINVAL;\n\t\tgoto unlock;\n\t}\n\tif (timer->card && timer->card->shutdown) {\n\t\tresult = -ENODEV;\n\t\tgoto unlock;\n\t}\n\tif (timeri->flags & (SNDRV_TIMER_IFLG_RUNNING |\n\t\t\t     SNDRV_TIMER_IFLG_START)) {\n\t\tresult = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tif (start)\n\t\ttimeri->ticks = timeri->cticks = ticks;\n\telse if (!timeri->cticks)\n\t\ttimeri->cticks = 1;\n\ttimeri->pticks = 0;\n\n\tlist_move_tail(&timeri->active_list, &timer->active_list_head);\n\tif (timer->running) {\n\t\tif (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\t\tgoto __start_now;\n\t\ttimer->flags |= SNDRV_TIMER_FLG_RESCHED;\n\t\ttimeri->flags |= SNDRV_TIMER_IFLG_START;\n\t\tresult = 1; /* delayed start */\n\t} else {\n\t\tif (start)\n\t\t\ttimer->sticks = ticks;\n\t\ttimer->hw.start(timer);\n\t      __start_now:\n\t\ttimer->running++;\n\t\ttimeri->flags |= SNDRV_TIMER_IFLG_RUNNING;\n\t\tresult = 0;\n\t}\n\tsnd_timer_notify1(timeri, start ? SNDRV_TIMER_EVENT_START :\n\t\t\t  SNDRV_TIMER_EVENT_CONTINUE);\n unlock:\n\tspin_unlock_irqrestore(&timer->lock, flags);\n\treturn result;\n}\n\n/* start/continue a slave timer */\nstatic int snd_timer_start_slave(struct snd_timer_instance *timeri,\n\t\t\t\t bool start)\n{\n\tunsigned long flags;\n\tint err;\n\n\tspin_lock_irqsave(&slave_active_lock, flags);\n\tif (timeri->flags & SNDRV_TIMER_IFLG_DEAD) {\n\t\terr = -EINVAL;\n\t\tgoto unlock;\n\t}\n\tif (timeri->flags & SNDRV_TIMER_IFLG_RUNNING) {\n\t\terr = -EBUSY;\n\t\tgoto unlock;\n\t}\n\ttimeri->flags |= SNDRV_TIMER_IFLG_RUNNING;\n\tif (timeri->master && timeri->timer) {\n\t\tspin_lock(&timeri->timer->lock);\n\t\tlist_add_tail(&timeri->active_list,\n\t\t\t      &timeri->master->slave_active_head);\n\t\tsnd_timer_notify1(timeri, start ? SNDRV_TIMER_EVENT_START :\n\t\t\t\t  SNDRV_TIMER_EVENT_CONTINUE);\n\t\tspin_unlock(&timeri->timer->lock);\n\t}\n\terr = 1; /* delayed start */\n unlock:\n\tspin_unlock_irqrestore(&slave_active_lock, flags);\n\treturn err;\n}\n\n/* stop/pause a master timer */\nstatic int snd_timer_stop1(struct snd_timer_instance *timeri, bool stop)\n{\n\tstruct snd_timer *timer;\n\tint result = 0;\n\tunsigned long flags;\n\n\ttimer = timeri->timer;\n\tif (!timer)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&timer->lock, flags);\n\tif (!(timeri->flags & (SNDRV_TIMER_IFLG_RUNNING |\n\t\t\t       SNDRV_TIMER_IFLG_START))) {\n\t\tresult = -EBUSY;\n\t\tgoto unlock;\n\t}\n\tlist_del_init(&timeri->ack_list);\n\tlist_del_init(&timeri->active_list);\n\tif (timer->card && timer->card->shutdown)\n\t\tgoto unlock;\n\tif (stop) {\n\t\ttimeri->cticks = timeri->ticks;\n\t\ttimeri->pticks = 0;\n\t}\n\tif ((timeri->flags & SNDRV_TIMER_IFLG_RUNNING) &&\n\t    !(--timer->running)) {\n\t\ttimer->hw.stop(timer);\n\t\tif (timer->flags & SNDRV_TIMER_FLG_RESCHED) {\n\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_RESCHED;\n\t\t\tsnd_timer_reschedule(timer, 0);\n\t\t\tif (timer->flags & SNDRV_TIMER_FLG_CHANGE) {\n\t\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_CHANGE;\n\t\t\t\ttimer->hw.start(timer);\n\t\t\t}\n\t\t}\n\t}\n\ttimeri->flags &= ~(SNDRV_TIMER_IFLG_RUNNING | SNDRV_TIMER_IFLG_START);\n\tif (stop)\n\t\ttimeri->flags &= ~SNDRV_TIMER_IFLG_PAUSED;\n\telse\n\t\ttimeri->flags |= SNDRV_TIMER_IFLG_PAUSED;\n\tsnd_timer_notify1(timeri, stop ? SNDRV_TIMER_EVENT_STOP :\n\t\t\t  SNDRV_TIMER_EVENT_PAUSE);\n unlock:\n\tspin_unlock_irqrestore(&timer->lock, flags);\n\treturn result;\n}\n\n/* stop/pause a slave timer */\nstatic int snd_timer_stop_slave(struct snd_timer_instance *timeri, bool stop)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&slave_active_lock, flags);\n\tif (!(timeri->flags & SNDRV_TIMER_IFLG_RUNNING)) {\n\t\tspin_unlock_irqrestore(&slave_active_lock, flags);\n\t\treturn -EBUSY;\n\t}\n\ttimeri->flags &= ~SNDRV_TIMER_IFLG_RUNNING;\n\tif (timeri->timer) {\n\t\tspin_lock(&timeri->timer->lock);\n\t\tlist_del_init(&timeri->ack_list);\n\t\tlist_del_init(&timeri->active_list);\n\t\tsnd_timer_notify1(timeri, stop ? SNDRV_TIMER_EVENT_STOP :\n\t\t\t\t  SNDRV_TIMER_EVENT_PAUSE);\n\t\tspin_unlock(&timeri->timer->lock);\n\t}\n\tspin_unlock_irqrestore(&slave_active_lock, flags);\n\treturn 0;\n}\n\n/*\n *  start the timer instance\n */\nint snd_timer_start(struct snd_timer_instance *timeri, unsigned int ticks)\n{\n\tif (timeri == NULL || ticks < 1)\n\t\treturn -EINVAL;\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE)\n\t\treturn snd_timer_start_slave(timeri, true);\n\telse\n\t\treturn snd_timer_start1(timeri, true, ticks);\n}\nEXPORT_SYMBOL(snd_timer_start);\n\n/*\n * stop the timer instance.\n *\n * do not call this from the timer callback!\n */\nint snd_timer_stop(struct snd_timer_instance *timeri)\n{\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE)\n\t\treturn snd_timer_stop_slave(timeri, true);\n\telse\n\t\treturn snd_timer_stop1(timeri, true);\n}\nEXPORT_SYMBOL(snd_timer_stop);\n\n/*\n * start again..  the tick is kept.\n */\nint snd_timer_continue(struct snd_timer_instance *timeri)\n{\n\t/* timer can continue only after pause */\n\tif (!(timeri->flags & SNDRV_TIMER_IFLG_PAUSED))\n\t\treturn -EINVAL;\n\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE)\n\t\treturn snd_timer_start_slave(timeri, false);\n\telse\n\t\treturn snd_timer_start1(timeri, false, 0);\n}\nEXPORT_SYMBOL(snd_timer_continue);\n\n/*\n * pause.. remember the ticks left\n */\nint snd_timer_pause(struct snd_timer_instance * timeri)\n{\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE)\n\t\treturn snd_timer_stop_slave(timeri, false);\n\telse\n\t\treturn snd_timer_stop1(timeri, false);\n}\nEXPORT_SYMBOL(snd_timer_pause);\n\n/*\n * reschedule the timer\n *\n * start pending instances and check the scheduling ticks.\n * when the scheduling ticks is changed set CHANGE flag to reprogram the timer.\n */\nstatic void snd_timer_reschedule(struct snd_timer * timer, unsigned long ticks_left)\n{\n\tstruct snd_timer_instance *ti;\n\tunsigned long ticks = ~0UL;\n\n\tlist_for_each_entry(ti, &timer->active_list_head, active_list) {\n\t\tif (ti->flags & SNDRV_TIMER_IFLG_START) {\n\t\t\tti->flags &= ~SNDRV_TIMER_IFLG_START;\n\t\t\tti->flags |= SNDRV_TIMER_IFLG_RUNNING;\n\t\t\ttimer->running++;\n\t\t}\n\t\tif (ti->flags & SNDRV_TIMER_IFLG_RUNNING) {\n\t\t\tif (ticks > ti->cticks)\n\t\t\t\tticks = ti->cticks;\n\t\t}\n\t}\n\tif (ticks == ~0UL) {\n\t\ttimer->flags &= ~SNDRV_TIMER_FLG_RESCHED;\n\t\treturn;\n\t}\n\tif (ticks > timer->hw.ticks)\n\t\tticks = timer->hw.ticks;\n\tif (ticks_left != ticks)\n\t\ttimer->flags |= SNDRV_TIMER_FLG_CHANGE;\n\ttimer->sticks = ticks;\n}\n\n/* call callbacks in timer ack list */\nstatic void snd_timer_process_callbacks(struct snd_timer *timer,\n\t\t\t\t\tstruct list_head *head)\n{\n\tstruct snd_timer_instance *ti;\n\tunsigned long resolution, ticks;\n\n\twhile (!list_empty(head)) {\n\t\tti = list_first_entry(head, struct snd_timer_instance,\n\t\t\t\t      ack_list);\n\n\t\t/* remove from ack_list and make empty */\n\t\tlist_del_init(&ti->ack_list);\n\n\t\tif (!(ti->flags & SNDRV_TIMER_IFLG_DEAD)) {\n\t\t\tticks = ti->pticks;\n\t\t\tti->pticks = 0;\n\t\t\tresolution = ti->resolution;\n\t\t\tti->flags |= SNDRV_TIMER_IFLG_CALLBACK;\n\t\t\tspin_unlock(&timer->lock);\n\t\t\tif (ti->callback)\n\t\t\t\tti->callback(ti, resolution, ticks);\n\t\t\tspin_lock(&timer->lock);\n\t\t\tti->flags &= ~SNDRV_TIMER_IFLG_CALLBACK;\n\t\t}\n\t}\n}\n\n/* clear pending instances from ack list */\nstatic void snd_timer_clear_callbacks(struct snd_timer *timer,\n\t\t\t\t      struct list_head *head)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&timer->lock, flags);\n\twhile (!list_empty(head))\n\t\tlist_del_init(head->next);\n\tspin_unlock_irqrestore(&timer->lock, flags);\n}\n\n/*\n * timer tasklet\n *\n */\nstatic void snd_timer_tasklet(unsigned long arg)\n{\n\tstruct snd_timer *timer = (struct snd_timer *) arg;\n\tunsigned long flags;\n\n\tif (timer->card && timer->card->shutdown) {\n\t\tsnd_timer_clear_callbacks(timer, &timer->sack_list_head);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&timer->lock, flags);\n\tsnd_timer_process_callbacks(timer, &timer->sack_list_head);\n\tspin_unlock_irqrestore(&timer->lock, flags);\n}\n\n/*\n * timer interrupt\n *\n * ticks_left is usually equal to timer->sticks.\n *\n */\nvoid snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)\n{\n\tstruct snd_timer_instance *ti, *ts, *tmp;\n\tunsigned long resolution;\n\tstruct list_head *ack_list_head;\n\tunsigned long flags;\n\tint use_tasklet = 0;\n\n\tif (timer == NULL)\n\t\treturn;\n\n\tif (timer->card && timer->card->shutdown) {\n\t\tsnd_timer_clear_callbacks(timer, &timer->ack_list_head);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&timer->lock, flags);\n\n\t/* remember the current resolution */\n\tresolution = snd_timer_hw_resolution(timer);\n\n\t/* loop for all active instances\n\t * Here we cannot use list_for_each_entry because the active_list of a\n\t * processed instance is relinked to done_list_head before the callback\n\t * is called.\n\t */\n\tlist_for_each_entry_safe(ti, tmp, &timer->active_list_head,\n\t\t\t\t active_list) {\n\t\tif (ti->flags & SNDRV_TIMER_IFLG_DEAD)\n\t\t\tcontinue;\n\t\tif (!(ti->flags & SNDRV_TIMER_IFLG_RUNNING))\n\t\t\tcontinue;\n\t\tti->pticks += ticks_left;\n\t\tti->resolution = resolution;\n\t\tif (ti->cticks < ticks_left)\n\t\t\tti->cticks = 0;\n\t\telse\n\t\t\tti->cticks -= ticks_left;\n\t\tif (ti->cticks) /* not expired */\n\t\t\tcontinue;\n\t\tif (ti->flags & SNDRV_TIMER_IFLG_AUTO) {\n\t\t\tti->cticks = ti->ticks;\n\t\t} else {\n\t\t\tti->flags &= ~SNDRV_TIMER_IFLG_RUNNING;\n\t\t\t--timer->running;\n\t\t\tlist_del_init(&ti->active_list);\n\t\t}\n\t\tif ((timer->hw.flags & SNDRV_TIMER_HW_TASKLET) ||\n\t\t    (ti->flags & SNDRV_TIMER_IFLG_FAST))\n\t\t\tack_list_head = &timer->ack_list_head;\n\t\telse\n\t\t\tack_list_head = &timer->sack_list_head;\n\t\tif (list_empty(&ti->ack_list))\n\t\t\tlist_add_tail(&ti->ack_list, ack_list_head);\n\t\tlist_for_each_entry(ts, &ti->slave_active_head, active_list) {\n\t\t\tts->pticks = ti->pticks;\n\t\t\tts->resolution = resolution;\n\t\t\tif (list_empty(&ts->ack_list))\n\t\t\t\tlist_add_tail(&ts->ack_list, ack_list_head);\n\t\t}\n\t}\n\tif (timer->flags & SNDRV_TIMER_FLG_RESCHED)\n\t\tsnd_timer_reschedule(timer, timer->sticks);\n\tif (timer->running) {\n\t\tif (timer->hw.flags & SNDRV_TIMER_HW_STOP) {\n\t\t\ttimer->hw.stop(timer);\n\t\t\ttimer->flags |= SNDRV_TIMER_FLG_CHANGE;\n\t\t}\n\t\tif (!(timer->hw.flags & SNDRV_TIMER_HW_AUTO) ||\n\t\t    (timer->flags & SNDRV_TIMER_FLG_CHANGE)) {\n\t\t\t/* restart timer */\n\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_CHANGE;\n\t\t\ttimer->hw.start(timer);\n\t\t}\n\t} else {\n\t\ttimer->hw.stop(timer);\n\t}\n\n\t/* now process all fast callbacks */\n\tsnd_timer_process_callbacks(timer, &timer->ack_list_head);\n\n\t/* do we have any slow callbacks? */\n\tuse_tasklet = !list_empty(&timer->sack_list_head);\n\tspin_unlock_irqrestore(&timer->lock, flags);\n\n\tif (use_tasklet)\n\t\ttasklet_schedule(&timer->task_queue);\n}\nEXPORT_SYMBOL(snd_timer_interrupt);\n\n/*\n\n */\n\nint snd_timer_new(struct snd_card *card, char *id, struct snd_timer_id *tid,\n\t\t  struct snd_timer **rtimer)\n{\n\tstruct snd_timer *timer;\n\tint err;\n\tstatic struct snd_device_ops ops = {\n\t\t.dev_free = snd_timer_dev_free,\n\t\t.dev_register = snd_timer_dev_register,\n\t\t.dev_disconnect = snd_timer_dev_disconnect,\n\t};\n\n\tif (snd_BUG_ON(!tid))\n\t\treturn -EINVAL;\n\tif (tid->dev_class == SNDRV_TIMER_CLASS_CARD ||\n\t    tid->dev_class == SNDRV_TIMER_CLASS_PCM) {\n\t\tif (WARN_ON(!card))\n\t\t\treturn -EINVAL;\n\t}\n\tif (rtimer)\n\t\t*rtimer = NULL;\n\ttimer = kzalloc(sizeof(*timer), GFP_KERNEL);\n\tif (!timer)\n\t\treturn -ENOMEM;\n\ttimer->tmr_class = tid->dev_class;\n\ttimer->card = card;\n\ttimer->tmr_device = tid->device;\n\ttimer->tmr_subdevice = tid->subdevice;\n\tif (id)\n\t\tstrlcpy(timer->id, id, sizeof(timer->id));\n\ttimer->sticks = 1;\n\tINIT_LIST_HEAD(&timer->device_list);\n\tINIT_LIST_HEAD(&timer->open_list_head);\n\tINIT_LIST_HEAD(&timer->active_list_head);\n\tINIT_LIST_HEAD(&timer->ack_list_head);\n\tINIT_LIST_HEAD(&timer->sack_list_head);\n\tspin_lock_init(&timer->lock);\n\ttasklet_init(&timer->task_queue, snd_timer_tasklet,\n\t\t     (unsigned long)timer);\n\ttimer->max_instances = 1000; /* default limit per timer */\n\tif (card != NULL) {\n\t\ttimer->module = card->module;\n\t\terr = snd_device_new(card, SNDRV_DEV_TIMER, timer, &ops);\n\t\tif (err < 0) {\n\t\t\tsnd_timer_free(timer);\n\t\t\treturn err;\n\t\t}\n\t}\n\tif (rtimer)\n\t\t*rtimer = timer;\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_timer_new);\n\nstatic int snd_timer_free(struct snd_timer *timer)\n{\n\tif (!timer)\n\t\treturn 0;\n\n\tmutex_lock(&register_mutex);\n\tif (! list_empty(&timer->open_list_head)) {\n\t\tstruct list_head *p, *n;\n\t\tstruct snd_timer_instance *ti;\n\t\tpr_warn(\"ALSA: timer %p is busy?\\n\", timer);\n\t\tlist_for_each_safe(p, n, &timer->open_list_head) {\n\t\t\tlist_del_init(p);\n\t\t\tti = list_entry(p, struct snd_timer_instance, open_list);\n\t\t\tti->timer = NULL;\n\t\t}\n\t}\n\tlist_del(&timer->device_list);\n\tmutex_unlock(&register_mutex);\n\n\tif (timer->private_free)\n\t\ttimer->private_free(timer);\n\tkfree(timer);\n\treturn 0;\n}\n\nstatic int snd_timer_dev_free(struct snd_device *device)\n{\n\tstruct snd_timer *timer = device->device_data;\n\treturn snd_timer_free(timer);\n}\n\nstatic int snd_timer_dev_register(struct snd_device *dev)\n{\n\tstruct snd_timer *timer = dev->device_data;\n\tstruct snd_timer *timer1;\n\n\tif (snd_BUG_ON(!timer || !timer->hw.start || !timer->hw.stop))\n\t\treturn -ENXIO;\n\tif (!(timer->hw.flags & SNDRV_TIMER_HW_SLAVE) &&\n\t    !timer->hw.resolution && timer->hw.c_resolution == NULL)\n\t    \treturn -EINVAL;\n\n\tmutex_lock(&register_mutex);\n\tlist_for_each_entry(timer1, &snd_timer_list, device_list) {\n\t\tif (timer1->tmr_class > timer->tmr_class)\n\t\t\tbreak;\n\t\tif (timer1->tmr_class < timer->tmr_class)\n\t\t\tcontinue;\n\t\tif (timer1->card && timer->card) {\n\t\t\tif (timer1->card->number > timer->card->number)\n\t\t\t\tbreak;\n\t\t\tif (timer1->card->number < timer->card->number)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (timer1->tmr_device > timer->tmr_device)\n\t\t\tbreak;\n\t\tif (timer1->tmr_device < timer->tmr_device)\n\t\t\tcontinue;\n\t\tif (timer1->tmr_subdevice > timer->tmr_subdevice)\n\t\t\tbreak;\n\t\tif (timer1->tmr_subdevice < timer->tmr_subdevice)\n\t\t\tcontinue;\n\t\t/* conflicts.. */\n\t\tmutex_unlock(&register_mutex);\n\t\treturn -EBUSY;\n\t}\n\tlist_add_tail(&timer->device_list, &timer1->device_list);\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n}\n\nstatic int snd_timer_dev_disconnect(struct snd_device *device)\n{\n\tstruct snd_timer *timer = device->device_data;\n\tstruct snd_timer_instance *ti;\n\n\tmutex_lock(&register_mutex);\n\tlist_del_init(&timer->device_list);\n\t/* wake up pending sleepers */\n\tlist_for_each_entry(ti, &timer->open_list_head, open_list) {\n\t\tif (ti->disconnect)\n\t\t\tti->disconnect(ti);\n\t}\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n}\n\nvoid snd_timer_notify(struct snd_timer *timer, int event, struct timespec *tstamp)\n{\n\tunsigned long flags;\n\tunsigned long resolution = 0;\n\tstruct snd_timer_instance *ti, *ts;\n\n\tif (timer->card && timer->card->shutdown)\n\t\treturn;\n\tif (! (timer->hw.flags & SNDRV_TIMER_HW_SLAVE))\n\t\treturn;\n\tif (snd_BUG_ON(event < SNDRV_TIMER_EVENT_MSTART ||\n\t\t       event > SNDRV_TIMER_EVENT_MRESUME))\n\t\treturn;\n\tspin_lock_irqsave(&timer->lock, flags);\n\tif (event == SNDRV_TIMER_EVENT_MSTART ||\n\t    event == SNDRV_TIMER_EVENT_MCONTINUE ||\n\t    event == SNDRV_TIMER_EVENT_MRESUME)\n\t\tresolution = snd_timer_hw_resolution(timer);\n\tlist_for_each_entry(ti, &timer->active_list_head, active_list) {\n\t\tif (ti->ccallback)\n\t\t\tti->ccallback(ti, event, tstamp, resolution);\n\t\tlist_for_each_entry(ts, &ti->slave_active_head, active_list)\n\t\t\tif (ts->ccallback)\n\t\t\t\tts->ccallback(ts, event, tstamp, resolution);\n\t}\n\tspin_unlock_irqrestore(&timer->lock, flags);\n}\nEXPORT_SYMBOL(snd_timer_notify);\n\n/*\n * exported functions for global timers\n */\nint snd_timer_global_new(char *id, int device, struct snd_timer **rtimer)\n{\n\tstruct snd_timer_id tid;\n\n\ttid.dev_class = SNDRV_TIMER_CLASS_GLOBAL;\n\ttid.dev_sclass = SNDRV_TIMER_SCLASS_NONE;\n\ttid.card = -1;\n\ttid.device = device;\n\ttid.subdevice = 0;\n\treturn snd_timer_new(NULL, id, &tid, rtimer);\n}\nEXPORT_SYMBOL(snd_timer_global_new);\n\nint snd_timer_global_free(struct snd_timer *timer)\n{\n\treturn snd_timer_free(timer);\n}\nEXPORT_SYMBOL(snd_timer_global_free);\n\nint snd_timer_global_register(struct snd_timer *timer)\n{\n\tstruct snd_device dev;\n\n\tmemset(&dev, 0, sizeof(dev));\n\tdev.device_data = timer;\n\treturn snd_timer_dev_register(&dev);\n}\nEXPORT_SYMBOL(snd_timer_global_register);\n\n/*\n *  System timer\n */\n\nstruct snd_timer_system_private {\n\tstruct timer_list tlist;\n\tstruct snd_timer *snd_timer;\n\tunsigned long last_expires;\n\tunsigned long last_jiffies;\n\tunsigned long correction;\n};\n\nstatic void snd_timer_s_function(struct timer_list *t)\n{\n\tstruct snd_timer_system_private *priv = from_timer(priv, t,\n\t\t\t\t\t\t\t\ttlist);\n\tstruct snd_timer *timer = priv->snd_timer;\n\tunsigned long jiff = jiffies;\n\tif (time_after(jiff, priv->last_expires))\n\t\tpriv->correction += (long)jiff - (long)priv->last_expires;\n\tsnd_timer_interrupt(timer, (long)jiff - (long)priv->last_jiffies);\n}\n\nstatic int snd_timer_s_start(struct snd_timer * timer)\n{\n\tstruct snd_timer_system_private *priv;\n\tunsigned long njiff;\n\n\tpriv = (struct snd_timer_system_private *) timer->private_data;\n\tnjiff = (priv->last_jiffies = jiffies);\n\tif (priv->correction > timer->sticks - 1) {\n\t\tpriv->correction -= timer->sticks - 1;\n\t\tnjiff++;\n\t} else {\n\t\tnjiff += timer->sticks - priv->correction;\n\t\tpriv->correction = 0;\n\t}\n\tpriv->last_expires = njiff;\n\tmod_timer(&priv->tlist, njiff);\n\treturn 0;\n}\n\nstatic int snd_timer_s_stop(struct snd_timer * timer)\n{\n\tstruct snd_timer_system_private *priv;\n\tunsigned long jiff;\n\n\tpriv = (struct snd_timer_system_private *) timer->private_data;\n\tdel_timer(&priv->tlist);\n\tjiff = jiffies;\n\tif (time_before(jiff, priv->last_expires))\n\t\ttimer->sticks = priv->last_expires - jiff;\n\telse\n\t\ttimer->sticks = 1;\n\tpriv->correction = 0;\n\treturn 0;\n}\n\nstatic int snd_timer_s_close(struct snd_timer *timer)\n{\n\tstruct snd_timer_system_private *priv;\n\n\tpriv = (struct snd_timer_system_private *)timer->private_data;\n\tdel_timer_sync(&priv->tlist);\n\treturn 0;\n}\n\nstatic struct snd_timer_hardware snd_timer_system =\n{\n\t.flags =\tSNDRV_TIMER_HW_FIRST | SNDRV_TIMER_HW_TASKLET,\n\t.resolution =\t1000000000L / HZ,\n\t.ticks =\t10000000L,\n\t.close =\tsnd_timer_s_close,\n\t.start =\tsnd_timer_s_start,\n\t.stop =\t\tsnd_timer_s_stop\n};\n\nstatic void snd_timer_free_system(struct snd_timer *timer)\n{\n\tkfree(timer->private_data);\n}\n\nstatic int snd_timer_register_system(void)\n{\n\tstruct snd_timer *timer;\n\tstruct snd_timer_system_private *priv;\n\tint err;\n\n\terr = snd_timer_global_new(\"system\", SNDRV_TIMER_GLOBAL_SYSTEM, &timer);\n\tif (err < 0)\n\t\treturn err;\n\tstrcpy(timer->name, \"system timer\");\n\ttimer->hw = snd_timer_system;\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (priv == NULL) {\n\t\tsnd_timer_free(timer);\n\t\treturn -ENOMEM;\n\t}\n\tpriv->snd_timer = timer;\n\ttimer_setup(&priv->tlist, snd_timer_s_function, 0);\n\ttimer->private_data = priv;\n\ttimer->private_free = snd_timer_free_system;\n\treturn snd_timer_global_register(timer);\n}\n\n#ifdef CONFIG_SND_PROC_FS\n/*\n *  Info interface\n */\n\nstatic void snd_timer_proc_read(struct snd_info_entry *entry,\n\t\t\t\tstruct snd_info_buffer *buffer)\n{\n\tstruct snd_timer *timer;\n\tstruct snd_timer_instance *ti;\n\n\tmutex_lock(&register_mutex);\n\tlist_for_each_entry(timer, &snd_timer_list, device_list) {\n\t\tif (timer->card && timer->card->shutdown)\n\t\t\tcontinue;\n\t\tswitch (timer->tmr_class) {\n\t\tcase SNDRV_TIMER_CLASS_GLOBAL:\n\t\t\tsnd_iprintf(buffer, \"G%i: \", timer->tmr_device);\n\t\t\tbreak;\n\t\tcase SNDRV_TIMER_CLASS_CARD:\n\t\t\tsnd_iprintf(buffer, \"C%i-%i: \",\n\t\t\t\t    timer->card->number, timer->tmr_device);\n\t\t\tbreak;\n\t\tcase SNDRV_TIMER_CLASS_PCM:\n\t\t\tsnd_iprintf(buffer, \"P%i-%i-%i: \", timer->card->number,\n\t\t\t\t    timer->tmr_device, timer->tmr_subdevice);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnd_iprintf(buffer, \"?%i-%i-%i-%i: \", timer->tmr_class,\n\t\t\t\t    timer->card ? timer->card->number : -1,\n\t\t\t\t    timer->tmr_device, timer->tmr_subdevice);\n\t\t}\n\t\tsnd_iprintf(buffer, \"%s :\", timer->name);\n\t\tif (timer->hw.resolution)\n\t\t\tsnd_iprintf(buffer, \" %lu.%03luus (%lu ticks)\",\n\t\t\t\t    timer->hw.resolution / 1000,\n\t\t\t\t    timer->hw.resolution % 1000,\n\t\t\t\t    timer->hw.ticks);\n\t\tif (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\t\tsnd_iprintf(buffer, \" SLAVE\");\n\t\tsnd_iprintf(buffer, \"\\n\");\n\t\tlist_for_each_entry(ti, &timer->open_list_head, open_list)\n\t\t\tsnd_iprintf(buffer, \"  Client %s : %s\\n\",\n\t\t\t\t    ti->owner ? ti->owner : \"unknown\",\n\t\t\t\t    ti->flags & (SNDRV_TIMER_IFLG_START |\n\t\t\t\t\t\t SNDRV_TIMER_IFLG_RUNNING)\n\t\t\t\t    ? \"running\" : \"stopped\");\n\t}\n\tmutex_unlock(&register_mutex);\n}\n\nstatic struct snd_info_entry *snd_timer_proc_entry;\n\nstatic void __init snd_timer_proc_init(void)\n{\n\tstruct snd_info_entry *entry;\n\n\tentry = snd_info_create_module_entry(THIS_MODULE, \"timers\", NULL);\n\tif (entry != NULL) {\n\t\tentry->c.text.read = snd_timer_proc_read;\n\t\tif (snd_info_register(entry) < 0) {\n\t\t\tsnd_info_free_entry(entry);\n\t\t\tentry = NULL;\n\t\t}\n\t}\n\tsnd_timer_proc_entry = entry;\n}\n\nstatic void __exit snd_timer_proc_done(void)\n{\n\tsnd_info_free_entry(snd_timer_proc_entry);\n}\n#else /* !CONFIG_SND_PROC_FS */\n#define snd_timer_proc_init()\n#define snd_timer_proc_done()\n#endif\n\n/*\n *  USER SPACE interface\n */\n\nstatic void snd_timer_user_interrupt(struct snd_timer_instance *timeri,\n\t\t\t\t     unsigned long resolution,\n\t\t\t\t     unsigned long ticks)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_read *r;\n\tint prev;\n\n\tspin_lock(&tu->qlock);\n\tif (tu->qused > 0) {\n\t\tprev = tu->qtail == 0 ? tu->queue_size - 1 : tu->qtail - 1;\n\t\tr = &tu->queue[prev];\n\t\tif (r->resolution == resolution) {\n\t\t\tr->ticks += ticks;\n\t\t\tgoto __wake;\n\t\t}\n\t}\n\tif (tu->qused >= tu->queue_size) {\n\t\ttu->overrun++;\n\t} else {\n\t\tr = &tu->queue[tu->qtail++];\n\t\ttu->qtail %= tu->queue_size;\n\t\tr->resolution = resolution;\n\t\tr->ticks = ticks;\n\t\ttu->qused++;\n\t}\n      __wake:\n\tspin_unlock(&tu->qlock);\n\tkill_fasync(&tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}\n\nstatic void snd_timer_user_append_to_tqueue(struct snd_timer_user *tu,\n\t\t\t\t\t    struct snd_timer_tread *tread)\n{\n\tif (tu->qused >= tu->queue_size) {\n\t\ttu->overrun++;\n\t} else {\n\t\tmemcpy(&tu->tqueue[tu->qtail++], tread, sizeof(*tread));\n\t\ttu->qtail %= tu->queue_size;\n\t\ttu->qused++;\n\t}\n}\n\nstatic void snd_timer_user_ccallback(struct snd_timer_instance *timeri,\n\t\t\t\t     int event,\n\t\t\t\t     struct timespec *tstamp,\n\t\t\t\t     unsigned long resolution)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_tread r1;\n\tunsigned long flags;\n\n\tif (event >= SNDRV_TIMER_EVENT_START &&\n\t    event <= SNDRV_TIMER_EVENT_PAUSE)\n\t\ttu->tstamp = *tstamp;\n\tif ((tu->filter & (1 << event)) == 0 || !tu->tread)\n\t\treturn;\n\tmemset(&r1, 0, sizeof(r1));\n\tr1.event = event;\n\tr1.tstamp = *tstamp;\n\tr1.val = resolution;\n\tspin_lock_irqsave(&tu->qlock, flags);\n\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\tspin_unlock_irqrestore(&tu->qlock, flags);\n\tkill_fasync(&tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}\n\nstatic void snd_timer_user_disconnect(struct snd_timer_instance *timeri)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\n\ttu->disconnected = true;\n\twake_up(&tu->qchange_sleep);\n}\n\nstatic void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,\n\t\t\t\t      unsigned long resolution,\n\t\t\t\t      unsigned long ticks)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_tread *r, r1;\n\tstruct timespec tstamp;\n\tint prev, append = 0;\n\n\tmemset(&r1, 0, sizeof(r1));\n\tmemset(&tstamp, 0, sizeof(tstamp));\n\tspin_lock(&tu->qlock);\n\tif ((tu->filter & ((1 << SNDRV_TIMER_EVENT_RESOLUTION) |\n\t\t\t   (1 << SNDRV_TIMER_EVENT_TICK))) == 0) {\n\t\tspin_unlock(&tu->qlock);\n\t\treturn;\n\t}\n\tif (tu->last_resolution != resolution || ticks > 0) {\n\t\tif (timer_tstamp_monotonic)\n\t\t\tktime_get_ts(&tstamp);\n\t\telse\n\t\t\tgetnstimeofday(&tstamp);\n\t}\n\tif ((tu->filter & (1 << SNDRV_TIMER_EVENT_RESOLUTION)) &&\n\t    tu->last_resolution != resolution) {\n\t\tr1.event = SNDRV_TIMER_EVENT_RESOLUTION;\n\t\tr1.tstamp = tstamp;\n\t\tr1.val = resolution;\n\t\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\t\ttu->last_resolution = resolution;\n\t\tappend++;\n\t}\n\tif ((tu->filter & (1 << SNDRV_TIMER_EVENT_TICK)) == 0)\n\t\tgoto __wake;\n\tif (ticks == 0)\n\t\tgoto __wake;\n\tif (tu->qused > 0) {\n\t\tprev = tu->qtail == 0 ? tu->queue_size - 1 : tu->qtail - 1;\n\t\tr = &tu->tqueue[prev];\n\t\tif (r->event == SNDRV_TIMER_EVENT_TICK) {\n\t\t\tr->tstamp = tstamp;\n\t\t\tr->val += ticks;\n\t\t\tappend++;\n\t\t\tgoto __wake;\n\t\t}\n\t}\n\tr1.event = SNDRV_TIMER_EVENT_TICK;\n\tr1.tstamp = tstamp;\n\tr1.val = ticks;\n\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\tappend++;\n      __wake:\n\tspin_unlock(&tu->qlock);\n\tif (append == 0)\n\t\treturn;\n\tkill_fasync(&tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}\n\nstatic int realloc_user_queue(struct snd_timer_user *tu, int size)\n{\n\tstruct snd_timer_read *queue = NULL;\n\tstruct snd_timer_tread *tqueue = NULL;\n\n\tif (tu->tread) {\n\t\ttqueue = kcalloc(size, sizeof(*tqueue), GFP_KERNEL);\n\t\tif (!tqueue)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tqueue = kcalloc(size, sizeof(*queue), GFP_KERNEL);\n\t\tif (!queue)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_irq(&tu->qlock);\n\tkfree(tu->queue);\n\tkfree(tu->tqueue);\n\ttu->queue_size = size;\n\ttu->queue = queue;\n\ttu->tqueue = tqueue;\n\ttu->qhead = tu->qtail = tu->qused = 0;\n\tspin_unlock_irq(&tu->qlock);\n\n\treturn 0;\n}\n\nstatic int snd_timer_user_open(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\tint err;\n\n\terr = stream_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\n\ttu = kzalloc(sizeof(*tu), GFP_KERNEL);\n\tif (tu == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&tu->qlock);\n\tinit_waitqueue_head(&tu->qchange_sleep);\n\tmutex_init(&tu->ioctl_lock);\n\ttu->ticks = 1;\n\tif (realloc_user_queue(tu, 128) < 0) {\n\t\tkfree(tu);\n\t\treturn -ENOMEM;\n\t}\n\tfile->private_data = tu;\n\treturn 0;\n}\n\nstatic int snd_timer_user_release(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\n\tif (file->private_data) {\n\t\ttu = file->private_data;\n\t\tfile->private_data = NULL;\n\t\tmutex_lock(&tu->ioctl_lock);\n\t\tif (tu->timeri)\n\t\t\tsnd_timer_close(tu->timeri);\n\t\tmutex_unlock(&tu->ioctl_lock);\n\t\tkfree(tu->queue);\n\t\tkfree(tu->tqueue);\n\t\tkfree(tu);\n\t}\n\treturn 0;\n}\n\nstatic void snd_timer_user_zero_id(struct snd_timer_id *id)\n{\n\tid->dev_class = SNDRV_TIMER_CLASS_NONE;\n\tid->dev_sclass = SNDRV_TIMER_SCLASS_NONE;\n\tid->card = -1;\n\tid->device = -1;\n\tid->subdevice = -1;\n}\n\nstatic void snd_timer_user_copy_id(struct snd_timer_id *id, struct snd_timer *timer)\n{\n\tid->dev_class = timer->tmr_class;\n\tid->dev_sclass = SNDRV_TIMER_SCLASS_NONE;\n\tid->card = timer->card ? timer->card->number : -1;\n\tid->device = timer->tmr_device;\n\tid->subdevice = timer->tmr_subdevice;\n}\n\nstatic int snd_timer_user_next_device(struct snd_timer_id __user *_tid)\n{\n\tstruct snd_timer_id id;\n\tstruct snd_timer *timer;\n\tstruct list_head *p;\n\n\tif (copy_from_user(&id, _tid, sizeof(id)))\n\t\treturn -EFAULT;\n\tmutex_lock(&register_mutex);\n\tif (id.dev_class < 0) {\t\t/* first item */\n\t\tif (list_empty(&snd_timer_list))\n\t\t\tsnd_timer_user_zero_id(&id);\n\t\telse {\n\t\t\ttimer = list_entry(snd_timer_list.next,\n\t\t\t\t\t   struct snd_timer, device_list);\n\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t}\n\t} else {\n\t\tswitch (id.dev_class) {\n\t\tcase SNDRV_TIMER_CLASS_GLOBAL:\n\t\t\tid.device = id.device < 0 ? 0 : id.device + 1;\n\t\t\tlist_for_each(p, &snd_timer_list) {\n\t\t\t\ttimer = list_entry(p, struct snd_timer, device_list);\n\t\t\t\tif (timer->tmr_class > SNDRV_TIMER_CLASS_GLOBAL) {\n\t\t\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (timer->tmr_device >= id.device) {\n\t\t\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (p == &snd_timer_list)\n\t\t\t\tsnd_timer_user_zero_id(&id);\n\t\t\tbreak;\n\t\tcase SNDRV_TIMER_CLASS_CARD:\n\t\tcase SNDRV_TIMER_CLASS_PCM:\n\t\t\tif (id.card < 0) {\n\t\t\t\tid.card = 0;\n\t\t\t} else {\n\t\t\t\tif (id.device < 0) {\n\t\t\t\t\tid.device = 0;\n\t\t\t\t} else {\n\t\t\t\t\tif (id.subdevice < 0)\n\t\t\t\t\t\tid.subdevice = 0;\n\t\t\t\t\telse if (id.subdevice < INT_MAX)\n\t\t\t\t\t\tid.subdevice++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist_for_each(p, &snd_timer_list) {\n\t\t\t\ttimer = list_entry(p, struct snd_timer, device_list);\n\t\t\t\tif (timer->tmr_class > id.dev_class) {\n\t\t\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (timer->tmr_class < id.dev_class)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (timer->card->number > id.card) {\n\t\t\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (timer->card->number < id.card)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (timer->tmr_device > id.device) {\n\t\t\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (timer->tmr_device < id.device)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (timer->tmr_subdevice > id.subdevice) {\n\t\t\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (timer->tmr_subdevice < id.subdevice)\n\t\t\t\t\tcontinue;\n\t\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p == &snd_timer_list)\n\t\t\t\tsnd_timer_user_zero_id(&id);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnd_timer_user_zero_id(&id);\n\t\t}\n\t}\n\tmutex_unlock(&register_mutex);\n\tif (copy_to_user(_tid, &id, sizeof(*_tid)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int snd_timer_user_ginfo(struct file *file,\n\t\t\t\tstruct snd_timer_ginfo __user *_ginfo)\n{\n\tstruct snd_timer_ginfo *ginfo;\n\tstruct snd_timer_id tid;\n\tstruct snd_timer *t;\n\tstruct list_head *p;\n\tint err = 0;\n\n\tginfo = memdup_user(_ginfo, sizeof(*ginfo));\n\tif (IS_ERR(ginfo))\n\t\treturn PTR_ERR(ginfo);\n\n\ttid = ginfo->tid;\n\tmemset(ginfo, 0, sizeof(*ginfo));\n\tginfo->tid = tid;\n\tmutex_lock(&register_mutex);\n\tt = snd_timer_find(&tid);\n\tif (t != NULL) {\n\t\tginfo->card = t->card ? t->card->number : -1;\n\t\tif (t->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\t\tginfo->flags |= SNDRV_TIMER_FLG_SLAVE;\n\t\tstrlcpy(ginfo->id, t->id, sizeof(ginfo->id));\n\t\tstrlcpy(ginfo->name, t->name, sizeof(ginfo->name));\n\t\tginfo->resolution = t->hw.resolution;\n\t\tif (t->hw.resolution_min > 0) {\n\t\t\tginfo->resolution_min = t->hw.resolution_min;\n\t\t\tginfo->resolution_max = t->hw.resolution_max;\n\t\t}\n\t\tlist_for_each(p, &t->open_list_head) {\n\t\t\tginfo->clients++;\n\t\t}\n\t} else {\n\t\terr = -ENODEV;\n\t}\n\tmutex_unlock(&register_mutex);\n\tif (err >= 0 && copy_to_user(_ginfo, ginfo, sizeof(*ginfo)))\n\t\terr = -EFAULT;\n\tkfree(ginfo);\n\treturn err;\n}\n\nstatic int timer_set_gparams(struct snd_timer_gparams *gparams)\n{\n\tstruct snd_timer *t;\n\tint err;\n\n\tmutex_lock(&register_mutex);\n\tt = snd_timer_find(&gparams->tid);\n\tif (!t) {\n\t\terr = -ENODEV;\n\t\tgoto _error;\n\t}\n\tif (!list_empty(&t->open_list_head)) {\n\t\terr = -EBUSY;\n\t\tgoto _error;\n\t}\n\tif (!t->hw.set_period) {\n\t\terr = -ENOSYS;\n\t\tgoto _error;\n\t}\n\terr = t->hw.set_period(t, gparams->period_num, gparams->period_den);\n_error:\n\tmutex_unlock(&register_mutex);\n\treturn err;\n}\n\nstatic int snd_timer_user_gparams(struct file *file,\n\t\t\t\t  struct snd_timer_gparams __user *_gparams)\n{\n\tstruct snd_timer_gparams gparams;\n\n\tif (copy_from_user(&gparams, _gparams, sizeof(gparams)))\n\t\treturn -EFAULT;\n\treturn timer_set_gparams(&gparams);\n}\n\nstatic int snd_timer_user_gstatus(struct file *file,\n\t\t\t\t  struct snd_timer_gstatus __user *_gstatus)\n{\n\tstruct snd_timer_gstatus gstatus;\n\tstruct snd_timer_id tid;\n\tstruct snd_timer *t;\n\tint err = 0;\n\n\tif (copy_from_user(&gstatus, _gstatus, sizeof(gstatus)))\n\t\treturn -EFAULT;\n\ttid = gstatus.tid;\n\tmemset(&gstatus, 0, sizeof(gstatus));\n\tgstatus.tid = tid;\n\tmutex_lock(&register_mutex);\n\tt = snd_timer_find(&tid);\n\tif (t != NULL) {\n\t\tspin_lock_irq(&t->lock);\n\t\tgstatus.resolution = snd_timer_hw_resolution(t);\n\t\tif (t->hw.precise_resolution) {\n\t\t\tt->hw.precise_resolution(t, &gstatus.resolution_num,\n\t\t\t\t\t\t &gstatus.resolution_den);\n\t\t} else {\n\t\t\tgstatus.resolution_num = gstatus.resolution;\n\t\t\tgstatus.resolution_den = 1000000000uL;\n\t\t}\n\t\tspin_unlock_irq(&t->lock);\n\t} else {\n\t\terr = -ENODEV;\n\t}\n\tmutex_unlock(&register_mutex);\n\tif (err >= 0 && copy_to_user(_gstatus, &gstatus, sizeof(gstatus)))\n\t\terr = -EFAULT;\n\treturn err;\n}\n\nstatic int snd_timer_user_tselect(struct file *file,\n\t\t\t\t  struct snd_timer_select __user *_tselect)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_select tselect;\n\tchar str[32];\n\tint err = 0;\n\n\ttu = file->private_data;\n\tif (tu->timeri) {\n\t\tsnd_timer_close(tu->timeri);\n\t\ttu->timeri = NULL;\n\t}\n\tif (copy_from_user(&tselect, _tselect, sizeof(tselect))) {\n\t\terr = -EFAULT;\n\t\tgoto __err;\n\t}\n\tsprintf(str, \"application %i\", current->pid);\n\tif (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)\n\t\ttselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;\n\terr = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid);\n\tif (err < 0)\n\t\tgoto __err;\n\n\ttu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;\n\ttu->timeri->callback = tu->tread\n\t\t\t? snd_timer_user_tinterrupt : snd_timer_user_interrupt;\n\ttu->timeri->ccallback = snd_timer_user_ccallback;\n\ttu->timeri->callback_data = (void *)tu;\n\ttu->timeri->disconnect = snd_timer_user_disconnect;\n\n      __err:\n\treturn err;\n}\n\nstatic int snd_timer_user_info(struct file *file,\n\t\t\t       struct snd_timer_info __user *_info)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_info *info;\n\tstruct snd_timer *t;\n\tint err = 0;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\tt = tu->timeri->timer;\n\tif (!t)\n\t\treturn -EBADFD;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (! info)\n\t\treturn -ENOMEM;\n\tinfo->card = t->card ? t->card->number : -1;\n\tif (t->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\tinfo->flags |= SNDRV_TIMER_FLG_SLAVE;\n\tstrlcpy(info->id, t->id, sizeof(info->id));\n\tstrlcpy(info->name, t->name, sizeof(info->name));\n\tinfo->resolution = t->hw.resolution;\n\tif (copy_to_user(_info, info, sizeof(*_info)))\n\t\terr = -EFAULT;\n\tkfree(info);\n\treturn err;\n}\n\nstatic int snd_timer_user_params(struct file *file,\n\t\t\t\t struct snd_timer_params __user *_params)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_params params;\n\tstruct snd_timer *t;\n\tint err;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\tt = tu->timeri->timer;\n\tif (!t)\n\t\treturn -EBADFD;\n\tif (copy_from_user(&params, _params, sizeof(params)))\n\t\treturn -EFAULT;\n\tif (!(t->hw.flags & SNDRV_TIMER_HW_SLAVE)) {\n\t\tu64 resolution;\n\n\t\tif (params.ticks < 1) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto _end;\n\t\t}\n\n\t\t/* Don't allow resolution less than 1ms */\n\t\tresolution = snd_timer_resolution(tu->timeri);\n\t\tresolution *= params.ticks;\n\t\tif (resolution < 1000000) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto _end;\n\t\t}\n\t}\n\tif (params.queue_size > 0 &&\n\t    (params.queue_size < 32 || params.queue_size > 1024)) {\n\t\terr = -EINVAL;\n\t\tgoto _end;\n\t}\n\tif (params.filter & ~((1<<SNDRV_TIMER_EVENT_RESOLUTION)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_TICK)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_START)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_STOP)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_CONTINUE)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_PAUSE)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_SUSPEND)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_RESUME)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MSTART)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MSTOP)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MCONTINUE)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MPAUSE)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MSUSPEND)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MRESUME))) {\n\t\terr = -EINVAL;\n\t\tgoto _end;\n\t}\n\tsnd_timer_stop(tu->timeri);\n\tspin_lock_irq(&t->lock);\n\ttu->timeri->flags &= ~(SNDRV_TIMER_IFLG_AUTO|\n\t\t\t       SNDRV_TIMER_IFLG_EXCLUSIVE|\n\t\t\t       SNDRV_TIMER_IFLG_EARLY_EVENT);\n\tif (params.flags & SNDRV_TIMER_PSFLG_AUTO)\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_AUTO;\n\tif (params.flags & SNDRV_TIMER_PSFLG_EXCLUSIVE)\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_EXCLUSIVE;\n\tif (params.flags & SNDRV_TIMER_PSFLG_EARLY_EVENT)\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_EARLY_EVENT;\n\tspin_unlock_irq(&t->lock);\n\tif (params.queue_size > 0 &&\n\t    (unsigned int)tu->queue_size != params.queue_size) {\n\t\terr = realloc_user_queue(tu, params.queue_size);\n\t\tif (err < 0)\n\t\t\tgoto _end;\n\t}\n\tspin_lock_irq(&tu->qlock);\n\ttu->qhead = tu->qtail = tu->qused = 0;\n\tif (tu->timeri->flags & SNDRV_TIMER_IFLG_EARLY_EVENT) {\n\t\tif (tu->tread) {\n\t\t\tstruct snd_timer_tread tread;\n\t\t\tmemset(&tread, 0, sizeof(tread));\n\t\t\ttread.event = SNDRV_TIMER_EVENT_EARLY;\n\t\t\ttread.tstamp.tv_sec = 0;\n\t\t\ttread.tstamp.tv_nsec = 0;\n\t\t\ttread.val = 0;\n\t\t\tsnd_timer_user_append_to_tqueue(tu, &tread);\n\t\t} else {\n\t\t\tstruct snd_timer_read *r = &tu->queue[0];\n\t\t\tr->resolution = 0;\n\t\t\tr->ticks = 0;\n\t\t\ttu->qused++;\n\t\t\ttu->qtail++;\n\t\t}\n\t}\n\ttu->filter = params.filter;\n\ttu->ticks = params.ticks;\n\tspin_unlock_irq(&tu->qlock);\n\terr = 0;\n _end:\n\tif (copy_to_user(_params, &params, sizeof(params)))\n\t\treturn -EFAULT;\n\treturn err;\n}\n\nstatic int snd_timer_user_status(struct file *file,\n\t\t\t\t struct snd_timer_status __user *_status)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_status status;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\tmemset(&status, 0, sizeof(status));\n\tstatus.tstamp = tu->tstamp;\n\tstatus.resolution = snd_timer_resolution(tu->timeri);\n\tstatus.lost = tu->timeri->lost;\n\tstatus.overrun = tu->overrun;\n\tspin_lock_irq(&tu->qlock);\n\tstatus.queue = tu->qused;\n\tspin_unlock_irq(&tu->qlock);\n\tif (copy_to_user(_status, &status, sizeof(status)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int snd_timer_user_start(struct file *file)\n{\n\tint err;\n\tstruct snd_timer_user *tu;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\tsnd_timer_stop(tu->timeri);\n\ttu->timeri->lost = 0;\n\ttu->last_resolution = 0;\n\terr = snd_timer_start(tu->timeri, tu->ticks);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic int snd_timer_user_stop(struct file *file)\n{\n\tint err;\n\tstruct snd_timer_user *tu;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\terr = snd_timer_stop(tu->timeri);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic int snd_timer_user_continue(struct file *file)\n{\n\tint err;\n\tstruct snd_timer_user *tu;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\t/* start timer instead of continue if it's not used before */\n\tif (!(tu->timeri->flags & SNDRV_TIMER_IFLG_PAUSED))\n\t\treturn snd_timer_user_start(file);\n\ttu->timeri->lost = 0;\n\terr = snd_timer_continue(tu->timeri);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic int snd_timer_user_pause(struct file *file)\n{\n\tint err;\n\tstruct snd_timer_user *tu;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\terr = snd_timer_pause(tu->timeri);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nenum {\n\tSNDRV_TIMER_IOCTL_START_OLD = _IO('T', 0x20),\n\tSNDRV_TIMER_IOCTL_STOP_OLD = _IO('T', 0x21),\n\tSNDRV_TIMER_IOCTL_CONTINUE_OLD = _IO('T', 0x22),\n\tSNDRV_TIMER_IOCTL_PAUSE_OLD = _IO('T', 0x23),\n};\n\nstatic long __snd_timer_user_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct snd_timer_user *tu;\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\n\ttu = file->private_data;\n\tswitch (cmd) {\n\tcase SNDRV_TIMER_IOCTL_PVERSION:\n\t\treturn put_user(SNDRV_TIMER_VERSION, p) ? -EFAULT : 0;\n\tcase SNDRV_TIMER_IOCTL_NEXT_DEVICE:\n\t\treturn snd_timer_user_next_device(argp);\n\tcase SNDRV_TIMER_IOCTL_TREAD:\n\t{\n\t\tint xarg, old_tread;\n\n\t\tif (tu->timeri)\t/* too late */\n\t\t\treturn -EBUSY;\n\t\tif (get_user(xarg, p))\n\t\t\treturn -EFAULT;\n\t\told_tread = tu->tread;\n\t\ttu->tread = xarg ? 1 : 0;\n\t\tif (tu->tread != old_tread &&\n\t\t    realloc_user_queue(tu, tu->queue_size) < 0) {\n\t\t\ttu->tread = old_tread;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\treturn 0;\n\t}\n\tcase SNDRV_TIMER_IOCTL_GINFO:\n\t\treturn snd_timer_user_ginfo(file, argp);\n\tcase SNDRV_TIMER_IOCTL_GPARAMS:\n\t\treturn snd_timer_user_gparams(file, argp);\n\tcase SNDRV_TIMER_IOCTL_GSTATUS:\n\t\treturn snd_timer_user_gstatus(file, argp);\n\tcase SNDRV_TIMER_IOCTL_SELECT:\n\t\treturn snd_timer_user_tselect(file, argp);\n\tcase SNDRV_TIMER_IOCTL_INFO:\n\t\treturn snd_timer_user_info(file, argp);\n\tcase SNDRV_TIMER_IOCTL_PARAMS:\n\t\treturn snd_timer_user_params(file, argp);\n\tcase SNDRV_TIMER_IOCTL_STATUS:\n\t\treturn snd_timer_user_status(file, argp);\n\tcase SNDRV_TIMER_IOCTL_START:\n\tcase SNDRV_TIMER_IOCTL_START_OLD:\n\t\treturn snd_timer_user_start(file);\n\tcase SNDRV_TIMER_IOCTL_STOP:\n\tcase SNDRV_TIMER_IOCTL_STOP_OLD:\n\t\treturn snd_timer_user_stop(file);\n\tcase SNDRV_TIMER_IOCTL_CONTINUE:\n\tcase SNDRV_TIMER_IOCTL_CONTINUE_OLD:\n\t\treturn snd_timer_user_continue(file);\n\tcase SNDRV_TIMER_IOCTL_PAUSE:\n\tcase SNDRV_TIMER_IOCTL_PAUSE_OLD:\n\t\treturn snd_timer_user_pause(file);\n\t}\n\treturn -ENOTTY;\n}\n\nstatic long snd_timer_user_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct snd_timer_user *tu = file->private_data;\n\tlong ret;\n\n\tmutex_lock(&tu->ioctl_lock);\n\tret = __snd_timer_user_ioctl(file, cmd, arg);\n\tmutex_unlock(&tu->ioctl_lock);\n\treturn ret;\n}\n\nstatic int snd_timer_user_fasync(int fd, struct file * file, int on)\n{\n\tstruct snd_timer_user *tu;\n\n\ttu = file->private_data;\n\treturn fasync_helper(fd, file, on, &tu->fasync);\n}\n\nstatic ssize_t snd_timer_user_read(struct file *file, char __user *buffer,\n\t\t\t\t   size_t count, loff_t *offset)\n{\n\tstruct snd_timer_user *tu;\n\tlong result = 0, unit;\n\tint qhead;\n\tint err = 0;\n\n\ttu = file->private_data;\n\tunit = tu->tread ? sizeof(struct snd_timer_tread) : sizeof(struct snd_timer_read);\n\tmutex_lock(&tu->ioctl_lock);\n\tspin_lock_irq(&tu->qlock);\n\twhile ((long)count - result >= unit) {\n\t\twhile (!tu->qused) {\n\t\t\twait_queue_entry_t wait;\n\n\t\t\tif ((file->f_flags & O_NONBLOCK) != 0 || result > 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto _error;\n\t\t\t}\n\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tinit_waitqueue_entry(&wait, current);\n\t\t\tadd_wait_queue(&tu->qchange_sleep, &wait);\n\n\t\t\tspin_unlock_irq(&tu->qlock);\n\t\t\tmutex_unlock(&tu->ioctl_lock);\n\t\t\tschedule();\n\t\t\tmutex_lock(&tu->ioctl_lock);\n\t\t\tspin_lock_irq(&tu->qlock);\n\n\t\t\tremove_wait_queue(&tu->qchange_sleep, &wait);\n\n\t\t\tif (tu->disconnected) {\n\t\t\t\terr = -ENODEV;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t\tif (signal_pending(current)) {\n\t\t\t\terr = -ERESTARTSYS;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t}\n\n\t\tqhead = tu->qhead++;\n\t\ttu->qhead %= tu->queue_size;\n\t\ttu->qused--;\n\t\tspin_unlock_irq(&tu->qlock);\n\n\t\tif (tu->tread) {\n\t\t\tif (copy_to_user(buffer, &tu->tqueue[qhead],\n\t\t\t\t\t sizeof(struct snd_timer_tread)))\n\t\t\t\terr = -EFAULT;\n\t\t} else {\n\t\t\tif (copy_to_user(buffer, &tu->queue[qhead],\n\t\t\t\t\t sizeof(struct snd_timer_read)))\n\t\t\t\terr = -EFAULT;\n\t\t}\n\n\t\tspin_lock_irq(&tu->qlock);\n\t\tif (err < 0)\n\t\t\tgoto _error;\n\t\tresult += unit;\n\t\tbuffer += unit;\n\t}\n _error:\n\tspin_unlock_irq(&tu->qlock);\n\tmutex_unlock(&tu->ioctl_lock);\n\treturn result > 0 ? result : err;\n}\n\nstatic __poll_t snd_timer_user_poll(struct file *file, poll_table * wait)\n{\n        __poll_t mask;\n        struct snd_timer_user *tu;\n\n        tu = file->private_data;\n\n        poll_wait(file, &tu->qchange_sleep, wait);\n\n\tmask = 0;\n\tspin_lock_irq(&tu->qlock);\n\tif (tu->qused)\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\tif (tu->disconnected)\n\t\tmask |= EPOLLERR;\n\tspin_unlock_irq(&tu->qlock);\n\n\treturn mask;\n}\n\n#ifdef CONFIG_COMPAT\n#include \"timer_compat.c\"\n#else\n#define snd_timer_user_ioctl_compat\tNULL\n#endif\n\nstatic const struct file_operations snd_timer_f_ops =\n{\n\t.owner =\tTHIS_MODULE,\n\t.read =\t\tsnd_timer_user_read,\n\t.open =\t\tsnd_timer_user_open,\n\t.release =\tsnd_timer_user_release,\n\t.llseek =\tno_llseek,\n\t.poll =\t\tsnd_timer_user_poll,\n\t.unlocked_ioctl =\tsnd_timer_user_ioctl,\n\t.compat_ioctl =\tsnd_timer_user_ioctl_compat,\n\t.fasync = \tsnd_timer_user_fasync,\n};\n\n/* unregister the system timer */\nstatic void snd_timer_free_all(void)\n{\n\tstruct snd_timer *timer, *n;\n\n\tlist_for_each_entry_safe(timer, n, &snd_timer_list, device_list)\n\t\tsnd_timer_free(timer);\n}\n\nstatic struct device timer_dev;\n\n/*\n *  ENTRY functions\n */\n\nstatic int __init alsa_timer_init(void)\n{\n\tint err;\n\n\tsnd_device_initialize(&timer_dev, NULL);\n\tdev_set_name(&timer_dev, \"timer\");\n\n#ifdef SNDRV_OSS_INFO_DEV_TIMERS\n\tsnd_oss_info_register(SNDRV_OSS_INFO_DEV_TIMERS, SNDRV_CARDS - 1,\n\t\t\t      \"system timer\");\n#endif\n\n\terr = snd_timer_register_system();\n\tif (err < 0) {\n\t\tpr_err(\"ALSA: unable to register system timer (%i)\\n\", err);\n\t\tgoto put_timer;\n\t}\n\n\terr = snd_register_device(SNDRV_DEVICE_TYPE_TIMER, NULL, 0,\n\t\t\t\t  &snd_timer_f_ops, NULL, &timer_dev);\n\tif (err < 0) {\n\t\tpr_err(\"ALSA: unable to register timer device (%i)\\n\", err);\n\t\tsnd_timer_free_all();\n\t\tgoto put_timer;\n\t}\n\n\tsnd_timer_proc_init();\n\treturn 0;\n\nput_timer:\n\tput_device(&timer_dev);\n\treturn err;\n}\n\nstatic void __exit alsa_timer_exit(void)\n{\n\tsnd_unregister_device(&timer_dev);\n\tsnd_timer_free_all();\n\tput_device(&timer_dev);\n\tsnd_timer_proc_done();\n#ifdef SNDRV_OSS_INFO_DEV_TIMERS\n\tsnd_oss_info_unregister(SNDRV_OSS_INFO_DEV_TIMERS, SNDRV_CARDS - 1);\n#endif\n}\n\nmodule_init(alsa_timer_init)\nmodule_exit(alsa_timer_exit)\n"], "filenames": ["sound/core/timer.c"], "buggy_code_start_loc": [287], "buggy_code_end_loc": [292], "fixing_code_start_loc": [287], "fixing_code_end_loc": [291], "type": "CWE-416", "message": "In the Linux kernel before 5.3.11, sound/core/timer.c has a use-after-free caused by erroneous code refactoring, aka CID-e7af6307a8a5. This is related to snd_timer_open and snd_timer_close_locked. The timeri variable was originally intended to be for a newly created timer instance, but was used for a different purpose after refactoring.", "other": {"cve": {"id": "CVE-2019-19807", "sourceIdentifier": "cve@mitre.org", "published": "2019-12-15T23:15:11.023", "lastModified": "2023-01-17T21:31:24.400", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the Linux kernel before 5.3.11, sound/core/timer.c has a use-after-free caused by erroneous code refactoring, aka CID-e7af6307a8a5. This is related to snd_timer_open and snd_timer_close_locked. The timeri variable was originally intended to be for a newly created timer instance, but was used for a different purpose after refactoring."}, {"lang": "es", "value": "En el kernel de Linux versiones anteriores a la versi\u00f3n 5.3.11, el archivo sound/core/timer.c tiene un uso de la memoria previamente liberada causado por una refactorizaci\u00f3n de c\u00f3digo err\u00f3nea, tambi\u00e9n se conoce como CID-e7af6307a8a5. Esto est\u00e1 relacionado con las funciones snd_timer_open y snd_timer_close_locked. La variable timeri originalmente estaba destinada a una instancia de temporizador reci\u00e9n creada, pero fue usado para un prop\u00f3sito diferente despu\u00e9s de la refactorizaci\u00f3n."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.9.199", "versionEndExcluding": "4.9.201", "matchCriteriaId": "86A8029C-2900-4F83-AF06-385EE367F195"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.14.152", "versionEndExcluding": "4.14.154", "matchCriteriaId": "F223F7AA-6CC3-4A2A-8C68-27F232C3A0AB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.19.82", "versionEndExcluding": "4.19.84", "matchCriteriaId": "051E6F39-B8BE-46EE-B1C4-E7010F08B41C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.2", "versionEndExcluding": "5.3.11", "matchCriteriaId": "68FDEE44-D2A2-4246-B77E-32AD3F76F47B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.3.11", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=e7af6307a8a54f0b873960b32b6a644f2d0fbd97", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/e7af6307a8a54f0b873960b32b6a644f2d0fbd97", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20200103-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4225-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4227-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4227-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/e7af6307a8a54f0b873960b32b6a644f2d0fbd97"}}