{"buggy_code": ["\"\"\"This file and its contents are licensed under the Apache License 2.0. Please see the included NOTICE for copyright information and LICENSE for a copy of the license.\n\"\"\"\n\"\"\"\nDjango Base settings for Label Studio.\n\nFor more information on this file, see\nhttps://docs.djangoproject.com/en/3.1/topics/settings/\n\nFor the full list of settings and their values, see\nhttps://docs.djangoproject.com/en/3.1/ref/settings/\n\"\"\"\nimport json\nimport logging\nimport os\nimport re\nfrom datetime import timedelta\n\nfrom label_studio.core.utils.params import get_bool_env, get_env_list\n\nformatter = 'standard'\nJSON_LOG = get_bool_env('JSON_LOG', False)\nif JSON_LOG:\n    formatter = 'json'\n\nLOGGING = {\n    'version': 1,\n    'disable_existing_loggers': False,\n    'formatters': {\n        'json': {\n            '()': 'label_studio.core.utils.formatter.CustomJsonFormatter',\n            'format': '[%(asctime)s] [%(name)s::%(funcName)s::%(lineno)d] [%(levelname)s] [%(user_id)s] %(message)s',\n            'datefmt': '%d/%b/%Y:%H:%M:%S %z',\n        },\n        'standard': {\n            'format': '[%(asctime)s] [%(name)s::%(funcName)s::%(lineno)d] [%(levelname)s] %(message)s',\n        },\n    },\n    'handlers': {\n        'console': {\n            'class': 'logging.StreamHandler',\n            'formatter': formatter,\n        },\n    },\n    'root': {\n        'handlers': ['console'],\n        'level': os.environ.get('LOG_LEVEL', 'DEBUG'),\n    },\n    'loggers': {\n        'pykwalify': {'level': 'ERROR', 'propagate': False},\n        'tavern': {'level': 'ERROR', 'propagate': False},\n        'asyncio': {'level': 'WARNING'},\n        'rules': {'level': 'WARNING'},\n        'django': {\n            'handlers': ['console'],\n            # 'propagate': True,\n        },\n        'django_auth_ldap': {'level': os.environ.get('LOG_LEVEL', 'DEBUG')},\n        'rq.worker': {\n            'handlers': ['console'],\n            'level': os.environ.get('LOG_LEVEL', 'INFO'),\n        },\n        'ddtrace': {\n            'handlers': ['console'],\n            'level': 'WARNING',\n        },\n        'ldclient.util': {\n            'handlers': ['console'],\n            'level': 'ERROR',\n        },\n    },\n}\n\n# for printing messages before main logging config applied\nif not logging.getLogger().hasHandlers():\n    logging.basicConfig(level=logging.DEBUG, format='%(message)s')\n\nfrom label_studio.core.utils.io import get_data_dir\nfrom label_studio.core.utils.params import get_bool_env, get_env\n\nlogger = logging.getLogger(__name__)\nSILENCED_SYSTEM_CHECKS = []\n\n# Hostname is used for proper path generation to the resources, pages, etc\nHOSTNAME = get_env('HOST', '')\nif HOSTNAME:\n    if not HOSTNAME.startswith('http://') and not HOSTNAME.startswith('https://'):\n        logger.info(\n            '! HOST variable found in environment, but it must start with http:// or https://, ignore it: %s', HOSTNAME\n        )\n        HOSTNAME = ''\n    else:\n        logger.info('=> Hostname correctly is set to: %s', HOSTNAME)\n        if HOSTNAME.endswith('/'):\n            HOSTNAME = HOSTNAME[0:-1]\n\n        # for django url resolver\n        if HOSTNAME:\n            # http[s]://domain.com:8080/script_name => /script_name\n            pattern = re.compile(r'^http[s]?:\\/\\/([^:\\/\\s]+(:\\d*)?)(.*)?')\n            match = pattern.match(HOSTNAME)\n            FORCE_SCRIPT_NAME = match.group(3)\n            if FORCE_SCRIPT_NAME:\n                logger.info('=> Django URL prefix is set to: %s', FORCE_SCRIPT_NAME)\n\nINTERNAL_PORT = '8080'\n\n# SECURITY WARNING: don't run with debug turned on in production!\nDEBUG = get_bool_env('DEBUG', True)\nDEBUG_MODAL_EXCEPTIONS = get_bool_env('DEBUG_MODAL_EXCEPTIONS', True)\n\n# Whether to verify SSL certs when making external requests, eg in the uploader\n# \u26a0\ufe0f Turning this off means assuming risk. \u26a0\ufe0f\n# Overridable at organization level via Organization#verify_ssl_certs\nVERIFY_SSL_CERTS = get_bool_env('VERIFY_SSL_CERTS', True)\n\n# 'sqlite-dll-<arch>-<version>.zip' should be hosted at this prefix\nWINDOWS_SQLITE_BINARY_HOST_PREFIX = get_env('WINDOWS_SQLITE_BINARY_HOST_PREFIX', 'https://www.sqlite.org/2023/')\n\n# Build paths inside the project like this: os.path.join(BASE_DIR, ...)\nBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n\n# Base path for media root and other uploaded files\nBASE_DATA_DIR = get_env('BASE_DATA_DIR')\nif BASE_DATA_DIR is None:\n    BASE_DATA_DIR = get_data_dir()\nos.makedirs(BASE_DATA_DIR, exist_ok=True)\nlogger.info('=> Database and media directory: %s', BASE_DATA_DIR)\n\n# Databases\n# https://docs.djangoproject.com/en/2.1/ref/settings/#databases\nDJANGO_DB_MYSQL = 'mysql'\nDJANGO_DB_SQLITE = 'sqlite'\nDJANGO_DB_POSTGRESQL = 'postgresql'\nDJANGO_DB = 'default'\nDATABASE_NAME_DEFAULT = os.path.join(BASE_DATA_DIR, 'label_studio.sqlite3')\nDATABASE_NAME = get_env('DATABASE_NAME', DATABASE_NAME_DEFAULT)\nDATABASES_ALL = {\n    DJANGO_DB_POSTGRESQL: {\n        'ENGINE': 'django.db.backends.postgresql',\n        'USER': get_env('POSTGRE_USER', 'postgres'),\n        'PASSWORD': get_env('POSTGRE_PASSWORD', 'postgres'),\n        'NAME': get_env('POSTGRE_NAME', 'postgres'),\n        'HOST': get_env('POSTGRE_HOST', 'localhost'),\n        'PORT': int(get_env('POSTGRE_PORT', '5432')),\n    },\n    DJANGO_DB_MYSQL: {\n        'ENGINE': 'django.db.backends.mysql',\n        'USER': get_env('MYSQL_USER', 'root'),\n        'PASSWORD': get_env('MYSQL_PASSWORD', ''),\n        'NAME': get_env('MYSQL_NAME', 'labelstudio'),\n        'HOST': get_env('MYSQL_HOST', 'localhost'),\n        'PORT': int(get_env('MYSQL_PORT', '3306')),\n    },\n    DJANGO_DB_SQLITE: {\n        'ENGINE': 'django.db.backends.sqlite3',\n        'NAME': DATABASE_NAME,\n        'OPTIONS': {\n            # 'timeout': 20,\n        },\n    },\n}\nDATABASES_ALL['default'] = DATABASES_ALL[DJANGO_DB_POSTGRESQL]\nDATABASES = {'default': DATABASES_ALL.get(get_env('DJANGO_DB', 'default'))}\n\nDEFAULT_AUTO_FIELD = 'django.db.models.AutoField'\n\nif get_bool_env('GOOGLE_LOGGING_ENABLED', False):\n    logging.info('Google Cloud Logging handler is enabled.')\n    try:\n        import google.cloud.logging\n        from google.auth.exceptions import GoogleAuthError\n\n        client = google.cloud.logging.Client()\n        client.setup_logging()\n\n        LOGGING['handlers']['google_cloud_logging'] = {\n            'level': get_env('LOG_LEVEL', 'WARNING'),\n            'class': 'google.cloud.logging.handlers.CloudLoggingHandler',\n            'client': client,\n        }\n        LOGGING['root']['handlers'].append('google_cloud_logging')\n    except GoogleAuthError:\n        logger.exception('Google Cloud Logging handler could not be setup.')\n\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'django.contrib.humanize',\n    'drf_yasg',\n    'corsheaders',\n    'django_extensions',\n    'django_rq',\n    'django_filters',\n    'rules',\n    'annoying',\n    'rest_framework',\n    'rest_framework.authtoken',\n    'drf_generators',\n    'core',\n    'users',\n    'organizations',\n    'data_import',\n    'data_export',\n    'projects',\n    'tasks',\n    'data_manager',\n    'io_storages',\n    'ml',\n    'webhooks',\n    'labels_manager',\n]\n\nMIDDLEWARE = [\n    'corsheaders.middleware.CorsMiddleware',\n    'django.middleware.security.SecurityMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'django.middleware.locale.LocaleMiddleware',\n    'core.middleware.DisableCSRF',\n    'django.middleware.csrf.CsrfViewMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',\n    'core.middleware.CommonMiddlewareAppendSlashWithoutRedirect',  # instead of 'CommonMiddleware'\n    'core.middleware.CommonMiddleware',\n    'django_user_agents.middleware.UserAgentMiddleware',\n    'core.middleware.SetSessionUIDMiddleware',\n    'core.middleware.ContextLogMiddleware',\n    'core.middleware.DatabaseIsLockedRetryMiddleware',\n    'core.current_request.ThreadLocalMiddleware',\n]\n\nREST_FRAMEWORK = {\n    'DEFAULT_FILTER_BACKENDS': ['django_filters.rest_framework.DjangoFilterBackend'],\n    'DEFAULT_AUTHENTICATION_CLASSES': (\n        'rest_framework.authentication.TokenAuthentication',\n        'rest_framework.authentication.SessionAuthentication',\n    ),\n    'DEFAULT_PERMISSION_CLASSES': [\n        'core.api_permissions.HasObjectPermission',\n        'rest_framework.permissions.IsAuthenticated',\n    ],\n    'EXCEPTION_HANDLER': 'core.utils.common.custom_exception_handler',\n    'DEFAULT_RENDERER_CLASSES': ('rest_framework.renderers.JSONRenderer',),\n    'DEFAULT_VERSIONING_CLASS': 'rest_framework.versioning.NamespaceVersioning',\n    'PAGE_SIZE': 100,\n    # 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination'\n}\nSILENCED_SYSTEM_CHECKS += ['rest_framework.W001']\n\n# CORS & Host settings\nINTERNAL_IPS = [  # django debug toolbar for django==2.2 requirement\n    '127.0.0.1',\n    'localhost',\n]\nCORS_ORIGIN_ALLOW_ALL = True\nCORS_ALLOW_METHODS = [\n    'DELETE',\n    'GET',\n    'OPTIONS',\n    'PATCH',\n    'POST',\n    'PUT',\n]\nALLOWED_HOSTS = ['*']\n\n# Auth modules\nAUTH_USER_MODEL = 'users.User'\nAUTHENTICATION_BACKENDS = [\n    'rules.permissions.ObjectPermissionBackend',\n    'django.contrib.auth.backends.ModelBackend',\n]\nUSE_USERNAME_FOR_LOGIN = False\n\nDISABLE_SIGNUP_WITHOUT_LINK = get_bool_env('DISABLE_SIGNUP_WITHOUT_LINK', False)\n\n# Password validation:\n# https://docs.djangoproject.com/en/2.1/ref/settings/#auth-password-validators\nAUTH_PASSWORD_VALIDATORS = [\n    {'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator'},\n    {'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator'},\n    {'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator'},\n    {'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator'},\n]\n\n# Django templates\nTEMPLATES_DIR = os.path.join(os.path.dirname(BASE_DIR), 'templates')  # ../../from_this = 'web' dir\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [TEMPLATES_DIR],\n        'APP_DIRS': True,\n        'OPTIONS': {\n            'context_processors': [\n                'django.template.context_processors.debug',\n                'django.template.context_processors.request',\n                'django.contrib.auth.context_processors.auth',\n                'django.contrib.messages.context_processors.messages',\n                'core.context_processors.settings',\n            ],\n            'builtins': ['django.templatetags.i18n'],\n        },\n    }\n]\n\n# RQ\nRQ_QUEUES = {\n    'critical': {\n        'HOST': 'localhost',\n        'PORT': 6379,\n        'DB': 0,\n        'DEFAULT_TIMEOUT': 180,\n    },\n    'high': {\n        'HOST': 'localhost',\n        'PORT': 6379,\n        'DB': 0,\n        'DEFAULT_TIMEOUT': 180,\n    },\n    'default': {\n        'HOST': 'localhost',\n        'PORT': 6379,\n        'DB': 0,\n        'DEFAULT_TIMEOUT': 180,\n    },\n    'low': {\n        'HOST': 'localhost',\n        'PORT': 6379,\n        'DB': 0,\n        'DEFAULT_TIMEOUT': 180,\n    },\n}\n\n# Swagger: automatic API documentation\nSWAGGER_SETTINGS = {\n    'SECURITY_DEFINITIONS': {\n        'Token': {\n            'type': 'apiKey',\n            'name': 'Authorization',\n            'in': 'header',\n            'description': 'The token (or API key) must be passed as a request header. '\n            'You can find your user token on the User Account page in Label Studio. Example: '\n            '<br><pre><code class=\"language-bash\">'\n            'curl https://label-studio-host/api/projects -H \"Authorization: Token [your-token]\"'\n            '</code></pre>',\n        }\n    },\n    'APIS_SORTER': 'alpha',\n    'SUPPORTED_SUBMIT_METHODS': ['get', 'post', 'put', 'delete', 'patch'],\n    'OPERATIONS_SORTER': 'alpha',\n}\n\nSENTRY_DSN = get_env('SENTRY_DSN', None)\nSENTRY_RATE = float(get_env('SENTRY_RATE', 0.25))\nSENTRY_ENVIRONMENT = get_env('SENTRY_ENVIRONMENT', 'stage.opensource')\nSENTRY_REDIS_ENABLED = False\nFRONTEND_SENTRY_DSN = get_env('FRONTEND_SENTRY_DSN', None)\nFRONTEND_SENTRY_RATE = get_env('FRONTEND_SENTRY_RATE', 0.1)\nFRONTEND_SENTRY_ENVIRONMENT = get_env('FRONTEND_SENTRY_ENVIRONMENT', 'stage.opensource')\n\nROOT_URLCONF = 'core.urls'\nWSGI_APPLICATION = 'core.wsgi.application'\nGRAPHIQL = True\n\n# Internationalization\n# https://docs.djangoproject.com/en/2.1/topics/i18n/\nLANGUAGE_CODE = 'en-us'\nTIME_ZONE = 'UTC'\nUSE_I18N = False\nUSE_L10N = True\nUSE_TZ = True\n\n# Static files (CSS, JavaScript, Images)\n# https://docs.djangoproject.com/en/2.1/howto/static-files/\nSTATIC_URL = '/static/'\n# if FORCE_SCRIPT_NAME:\n#    STATIC_URL = FORCE_SCRIPT_NAME + STATIC_URL\nlogger.info(f'=> Static URL is set to: {STATIC_URL}')\n\nSTATIC_ROOT = os.path.join(BASE_DIR, 'static_build')\nSTATICFILES_DIRS = [os.path.join(BASE_DIR, 'static')]\nSTATICFILES_FINDERS = (\n    'django.contrib.staticfiles.finders.FileSystemFinder',\n    'django.contrib.staticfiles.finders.AppDirectoriesFinder',\n)\nSTATICFILES_STORAGE = 'core.storage.SkipMissedManifestStaticFilesStorage'\n\n# Sessions and CSRF\nSESSION_COOKIE_SECURE = bool(int(get_env('SESSION_COOKIE_SECURE', False)))\nSESSION_COOKIE_SAMESITE = get_env('SESSION_COOKIE_SAMESITE', 'Lax')\n\nCSRF_COOKIE_SECURE = bool(int(get_env('CSRF_COOKIE_SECURE', SESSION_COOKIE_SECURE)))\nCSRF_COOKIE_HTTPONLY = bool(int(get_env('CSRF_COOKIE_HTTPONLY', SESSION_COOKIE_SECURE)))\nCSRF_COOKIE_SAMESITE = get_env('CSRF_COOKIE_SAMESITE', 'Lax')\n\n# Inactivity user sessions\nINACTIVITY_SESSION_TIMEOUT_ENABLED = bool(int(get_env('INACTIVITY_SESSION_TIMEOUT_ENABLED', True)))\n# The most time a login will last, regardless of activity\nMAX_SESSION_AGE = int(get_env('MAX_SESSION_AGE', timedelta(days=14).total_seconds()))\n# The most time that can elapse between activity with the server before the user is logged out\nMAX_TIME_BETWEEN_ACTIVITY = int(get_env('MAX_TIME_BETWEEN_ACTIVITY', timedelta(days=5).total_seconds()))\n\nSSRF_PROTECTION_ENABLED = get_bool_env('SSRF_PROTECTION_ENABLED', False)\n\n# user media files\nMEDIA_ROOT = os.path.join(BASE_DATA_DIR, 'media')\nos.makedirs(MEDIA_ROOT, exist_ok=True)\nMEDIA_URL = '/data/'\nUPLOAD_DIR = 'upload'\nAVATAR_PATH = 'avatars'\n\nSUPPORTED_EXTENSIONS = set(\n    [\n        '.bmp',\n        '.csv',\n        '.flac',\n        '.gif',\n        '.htm',\n        '.html',\n        '.jpg',\n        '.jpeg',\n        '.json',\n        '.m4a',\n        '.mp3',\n        '.ogg',\n        '.png',\n        '.svg',\n        '.tsv',\n        '.txt',\n        '.wav',\n        '.xml',\n        '.mp4',\n        '.webm',\n        '.webp',\n    ]\n)\n\n# directory for files created during unit tests\nTEST_DATA_ROOT = os.path.join(BASE_DATA_DIR, 'test_data')\nos.makedirs(TEST_DATA_ROOT, exist_ok=True)\n\n# project exports\nEXPORT_DIR = os.path.join(BASE_DATA_DIR, 'export')\nEXPORT_URL_ROOT = '/export/'\nEXPORT_MIXIN = 'data_export.mixins.ExportMixin'\n# old export dir\nos.makedirs(EXPORT_DIR, exist_ok=True)\n# dir for delayed export\nDELAYED_EXPORT_DIR = 'export'\nos.makedirs(os.path.join(BASE_DATA_DIR, MEDIA_ROOT, DELAYED_EXPORT_DIR), exist_ok=True)\n\n# file / task size limits\nDATA_UPLOAD_MAX_MEMORY_SIZE = int(get_env('DATA_UPLOAD_MAX_MEMORY_SIZE', 250 * 1024 * 1024))\nDATA_UPLOAD_MAX_NUMBER_FILES = int(get_env('DATA_UPLOAD_MAX_NUMBER_FILES', 100))\nTASKS_MAX_NUMBER = 1000000\nTASKS_MAX_FILE_SIZE = DATA_UPLOAD_MAX_MEMORY_SIZE\n\nTASK_LOCK_TTL = int(get_env('TASK_LOCK_TTL', default=86400))\n\nLABEL_STREAM_HISTORY_LIMIT = int(get_env('LABEL_STREAM_HISTORY_LIMIT', default=100))\n\nRANDOM_NEXT_TASK_SAMPLE_SIZE = int(get_env('RANDOM_NEXT_TASK_SAMPLE_SIZE', 50))\n\nTASK_API_PAGE_SIZE_MAX = int(get_env('TASK_API_PAGE_SIZE_MAX', 0)) or None\n\n# Email backend\nFROM_EMAIL = get_env('FROM_EMAIL', 'Label Studio <hello@labelstud.io>')\nEMAIL_BACKEND = get_env('EMAIL_BACKEND', 'django.core.mail.backends.dummy.EmailBackend')\n\nENABLE_LOCAL_FILES_STORAGE = get_bool_env('ENABLE_LOCAL_FILES_STORAGE', default=True)\nLOCAL_FILES_SERVING_ENABLED = get_bool_env('LOCAL_FILES_SERVING_ENABLED', default=False)\nLOCAL_FILES_DOCUMENT_ROOT = get_env('LOCAL_FILES_DOCUMENT_ROOT', default=os.path.abspath(os.sep))\n\nSYNC_ON_TARGET_STORAGE_CREATION = get_bool_env('SYNC_ON_TARGET_STORAGE_CREATION', default=True)\n\nALLOW_IMPORT_TASKS_WITH_UNKNOWN_EMAILS = get_bool_env('ALLOW_IMPORT_TASKS_WITH_UNKNOWN_EMAILS', default=False)\n\n\"\"\" React Libraries: do not forget to change this dir in /etc/nginx/nginx.conf \"\"\"\n\n# EDITOR = label-studio-frontend repository\nEDITOR_ROOT = os.path.join(BASE_DIR, '../../web/dist/libs/editor')\n# DM = data manager (included into FRONTEND due npm building, we need only version.json file from there)\nDM_ROOT = os.path.join(BASE_DIR, '../../web/dist/libs/datamanager')\n# FRONTEND = GUI for django backend\nREACT_APP_ROOT = os.path.join(BASE_DIR, '../../web/dist/apps/labelstudio')\n\n# per project settings\nBATCH_SIZE = 1000\nPROJECT_TITLE_MIN_LEN = 3\nPROJECT_TITLE_MAX_LEN = 50\nLOGIN_REDIRECT_URL = '/'\nLOGIN_URL = '/'\nMIN_GROUND_TRUTH = 10\nDATA_UNDEFINED_NAME = '$undefined$'\nLICENSE = {}\nVERSIONS = {}\nVERSION_EDITION = 'Community'\nLATEST_VERSION_CHECK = True\nVERSIONS_CHECK_TIME = 0\nALLOW_ORGANIZATION_WEBHOOKS = get_bool_env('ALLOW_ORGANIZATION_WEBHOOKS', False)\nCONVERTER_DOWNLOAD_RESOURCES = get_bool_env('CONVERTER_DOWNLOAD_RESOURCES', True)\nEXPERIMENTAL_FEATURES = get_bool_env('EXPERIMENTAL_FEATURES', False)\nUSE_ENFORCE_CSRF_CHECKS = get_bool_env('USE_ENFORCE_CSRF_CHECKS', True)  # False is for tests\nCLOUD_FILE_STORAGE_ENABLED = False\n\nIO_STORAGES_IMPORT_LINK_NAMES = [\n    'io_storages_s3importstoragelink',\n    'io_storages_gcsimportstoragelink',\n    'io_storages_azureblobimportstoragelink',\n    'io_storages_localfilesimportstoragelink',\n    'io_storages_redisimportstoragelink',\n]\n\nCREATE_ORGANIZATION = 'organizations.functions.create_organization'\nSAVE_USER = 'users.functions.save_user'\nPOST_PROCESS_REIMPORT = 'core.utils.common.empty'\nUSER_SERIALIZER = 'users.serializers.BaseUserSerializer'\nUSER_SERIALIZER_UPDATE = 'users.serializers.BaseUserSerializerUpdate'\nTASK_SERIALIZER = 'tasks.serializers.BaseTaskSerializer'\nEXPORT_DATA_SERIALIZER = 'data_export.serializers.BaseExportDataSerializer'\nDATA_MANAGER_GET_ALL_COLUMNS = 'data_manager.functions.get_all_columns'\nDATA_MANAGER_ANNOTATIONS_MAP = {}\nDATA_MANAGER_ACTIONS = {}\nDATA_MANAGER_CUSTOM_FILTER_EXPRESSIONS = 'data_manager.functions.custom_filter_expressions'\nDATA_MANAGER_PREPROCESS_FILTER = 'data_manager.functions.preprocess_filter'\nUSER_LOGIN_FORM = 'users.forms.LoginForm'\nPROJECT_MIXIN = 'projects.mixins.ProjectMixin'\nTASK_MIXIN = 'tasks.mixins.TaskMixin'\nANNOTATION_MIXIN = 'tasks.mixins.AnnotationMixin'\nORGANIZATION_MIXIN = 'organizations.mixins.OrganizationMixin'\nUSER_MIXIN = 'users.mixins.UserMixin'\nORGANIZATION_MEMBER_MIXIN = 'organizations.mixins.OrganizationMemberMixin'\nMEMBER_PERM = 'core.api_permissions.MemberHasOwnerPermission'\nRECALCULATE_ALL_STATS = None\nGET_STORAGE_LIST = 'io_storages.functions.get_storage_list'\nSTORAGE_ANNOTATION_SERIALIZER = 'io_storages.serializers.StorageAnnotationSerializer'\nTASK_SERIALIZER_BULK = 'tasks.serializers.BaseTaskSerializerBulk'\nPREPROCESS_FIELD_NAME = 'data_manager.functions.preprocess_field_name'\nINTERACTIVE_DATA_SERIALIZER = 'data_export.serializers.BaseExportDataSerializerForInteractive'\nDELETE_TASKS_ANNOTATIONS_POSTPROCESS = None\n\n\ndef project_delete(project):\n    project.delete()\n\n\ndef user_auth(user_model, email, password):\n    return None\n\n\ndef collect_versions_dummy(**kwargs):\n    return {}\n\n\nPROJECT_DELETE = project_delete\nUSER_AUTH = user_auth\nCOLLECT_VERSIONS = collect_versions_dummy\n\nWEBHOOK_TIMEOUT = float(get_env('WEBHOOK_TIMEOUT', 1.0))\nWEBHOOK_BATCH_SIZE = int(get_env('WEBHOOK_BATCH_SIZE', 100))\nWEBHOOK_SERIALIZERS = {\n    'project': 'webhooks.serializers_for_hooks.ProjectWebhookSerializer',\n    'task': 'webhooks.serializers_for_hooks.TaskWebhookSerializer',\n    'annotation': 'webhooks.serializers_for_hooks.AnnotationWebhookSerializer',\n    'label': 'labels_manager.serializers.LabelSerializer',\n    'label_link': 'labels_manager.serializers.LabelLinkSerializer',\n}\n\nEDITOR_KEYMAP = json.dumps(get_env('EDITOR_KEYMAP'))\n\n# fix a problem with Windows mimetypes for JS and PNG\nimport mimetypes\n\nmimetypes.add_type('application/javascript', '.js', True)\nmimetypes.add_type('image/png', '.png', True)\n\n# fields name was used in DM api before\nREST_FLEX_FIELDS = {'FIELDS_PARAM': 'include'}\n\nINTERPOLATE_KEY_FRAMES = get_env('INTERPOLATE_KEY_FRAMES', False)\n\n# Feature Flags\nFEATURE_FLAGS_API_KEY = get_env('FEATURE_FLAGS_API_KEY', default='any key')\n\n# we may set feature flags from file\nFEATURE_FLAGS_FROM_FILE = get_bool_env('FEATURE_FLAGS_FROM_FILE', False)\nFEATURE_FLAGS_FILE = get_env('FEATURE_FLAGS_FILE', 'feature_flags.json')\n# or if file is not set, default is using offline mode\nFEATURE_FLAGS_OFFLINE = get_bool_env('FEATURE_FLAGS_OFFLINE', True)\n# default value for feature flags (if not overridden by environment or client)\nFEATURE_FLAGS_DEFAULT_VALUE = False\n\n# Whether to send analytics telemetry data\nCOLLECT_ANALYTICS = get_bool_env('collect_analytics', True)\n\n# Strip harmful content from SVG files by default\nSVG_SECURITY_CLEANUP = get_bool_env('SVG_SECURITY_CLEANUP', False)\n\nML_BLOCK_LOCAL_IP = get_bool_env('ML_BLOCK_LOCAL_IP', False)\n\nRQ_LONG_JOB_TIMEOUT = int(get_env('RQ_LONG_JOB_TIMEOUT', 36000))\n\nAPP_WEBSERVER = get_env('APP_WEBSERVER', 'django')\n\nBATCH_JOB_RETRY_TIMEOUT = int(get_env('BATCH_JOB_RETRY_TIMEOUT', 60))\n\nFUTURE_SAVE_TASK_TO_STORAGE = get_bool_env('FUTURE_SAVE_TASK_TO_STORAGE', default=False)\nFUTURE_SAVE_TASK_TO_STORAGE_JSON_EXT = get_bool_env('FUTURE_SAVE_TASK_TO_STORAGE_JSON_EXT', default=True)\nSTORAGE_IN_PROGRESS_TIMER = float(get_env('STORAGE_IN_PROGRESS_TIMER', 5.0))\nSTORAGE_EXPORT_CHUNK_SIZE = int(get_env('STORAGE_EXPORT_CHUNK_SIZE', 100))\n\nUSE_NGINX_FOR_EXPORT_DOWNLOADS = get_bool_env('USE_NGINX_FOR_EXPORT_DOWNLOADS', False)\n\nif get_env('MINIO_STORAGE_ENDPOINT') and not get_bool_env('MINIO_SKIP', False):\n    CLOUD_FILE_STORAGE_ENABLED = True\n    DEFAULT_FILE_STORAGE = 'storages.backends.s3boto3.S3Boto3Storage'\n    AWS_STORAGE_BUCKET_NAME = get_env('MINIO_STORAGE_BUCKET_NAME')\n    AWS_ACCESS_KEY_ID = get_env('MINIO_STORAGE_ACCESS_KEY')\n    AWS_SECRET_ACCESS_KEY = get_env('MINIO_STORAGE_SECRET_KEY')\n    AWS_S3_ENDPOINT_URL = get_env('MINIO_STORAGE_ENDPOINT')\n    AWS_QUERYSTRING_AUTH = False\n    # make domain for FileUpload.file\n    AWS_S3_SECURE_URLS = False\n    AWS_S3_URL_PROTOCOL = 'http:' if HOSTNAME.startswith('http://') else 'https:'\n    AWS_S3_CUSTOM_DOMAIN = HOSTNAME.replace('http://', '').replace('https://', '') + '/data'\n\nif get_env('STORAGE_TYPE') == 's3':\n    CLOUD_FILE_STORAGE_ENABLED = True\n    DEFAULT_FILE_STORAGE = 'core.storage.CustomS3Boto3Storage'\n    if get_env('STORAGE_AWS_ACCESS_KEY_ID'):\n        AWS_ACCESS_KEY_ID = get_env('STORAGE_AWS_ACCESS_KEY_ID')\n    if get_env('STORAGE_AWS_SECRET_ACCESS_KEY'):\n        AWS_SECRET_ACCESS_KEY = get_env('STORAGE_AWS_SECRET_ACCESS_KEY')\n    AWS_STORAGE_BUCKET_NAME = get_env('STORAGE_AWS_BUCKET_NAME')\n    AWS_S3_REGION_NAME = get_env('STORAGE_AWS_REGION_NAME', None)\n    AWS_S3_ENDPOINT_URL = get_env('STORAGE_AWS_ENDPOINT_URL', None)\n    if get_env('STORAGE_AWS_OBJECT_PARAMETERS'):\n        AWS_S3_OBJECT_PARAMETERS = json.loads(get_env('STORAGE_AWS_OBJECT_PARAMETERS'))\n    AWS_QUERYSTRING_EXPIRE = int(get_env('STORAGE_AWS_X_AMZ_EXPIRES', '86400'))\n    AWS_LOCATION = get_env('STORAGE_AWS_FOLDER', default='')\n    AWS_S3_USE_SSL = get_bool_env('STORAGE_AWS_S3_USE_SSL', True)\n    AWS_S3_VERIFY = get_env('STORAGE_AWS_S3_VERIFY', None)\n    if AWS_S3_VERIFY == 'false' or AWS_S3_VERIFY == 'False' or AWS_S3_VERIFY == '0':\n        AWS_S3_VERIFY = False\n    AWS_S3_SIGNATURE_VERSION = get_env('STORAGE_AWS_S3_SIGNATURE_VERSION', None)\n\nif get_env('STORAGE_TYPE') == 'azure':\n    CLOUD_FILE_STORAGE_ENABLED = True\n    DEFAULT_FILE_STORAGE = 'core.storage.CustomAzureStorage'\n    AZURE_ACCOUNT_NAME = get_env('STORAGE_AZURE_ACCOUNT_NAME')\n    AZURE_ACCOUNT_KEY = get_env('STORAGE_AZURE_ACCOUNT_KEY')\n    AZURE_CONTAINER = get_env('STORAGE_AZURE_CONTAINER_NAME')\n    AZURE_URL_EXPIRATION_SECS = int(get_env('STORAGE_AZURE_URL_EXPIRATION_SECS', '86400'))\n    AZURE_LOCATION = get_env('STORAGE_AZURE_FOLDER', default='')\n\nif get_env('STORAGE_TYPE') == 'gcs':\n    CLOUD_FILE_STORAGE_ENABLED = True\n    # DEFAULT_FILE_STORAGE = 'storages.backends.gcloud.GoogleCloudStorage'\n    DEFAULT_FILE_STORAGE = 'core.storage.AlternativeGoogleCloudStorage'\n    GS_PROJECT_ID = get_env('STORAGE_GCS_PROJECT_ID')\n    GS_BUCKET_NAME = get_env('STORAGE_GCS_BUCKET_NAME')\n    GS_EXPIRATION = timedelta(seconds=int(get_env('STORAGE_GCS_EXPIRATION_SECS', '86400')))\n    GS_LOCATION = get_env('STORAGE_GCS_FOLDER', default='')\n    GS_CUSTOM_ENDPOINT = get_env('STORAGE_GCS_ENDPOINT')\n\nCSRF_TRUSTED_ORIGINS = get_env('CSRF_TRUSTED_ORIGINS', [])\nif CSRF_TRUSTED_ORIGINS:\n    CSRF_TRUSTED_ORIGINS = CSRF_TRUSTED_ORIGINS.split(',')\n\nREAL_HOSTNAME = os.getenv('HOSTNAME')  # we have to use getenv, because we don't use LABEL_STUDIO_ prefix\nGCS_CLOUD_STORAGE_FORCE_DEFAULT_CREDENTIALS = get_bool_env('GCS_CLOUD_STORAGE_FORCE_DEFAULT_CREDENTIALS', False)\nPUBLIC_API_DOCS = get_bool_env('PUBLIC_API_DOCS', False)\n\n# By default, we disallow filters with foreign keys in data manager for security reasons.\n# Add to this list (either here in code, or via the env) to allow specific filters that rely on foreign keys.\nDATA_MANAGER_FILTER_ALLOWLIST = list(\n    set(get_env_list('DATA_MANAGER_FILTER_ALLOWLIST') + ['updated_by__active_organization'])\n)\n\nif ENABLE_CSP := get_bool_env('ENABLE_CSP', True):\n    CSP_DEFAULT_SRC = (\n        \"'self'\",\n        \"'report-sample'\",\n    )\n    CSP_STYLE_SRC = (\"'self'\", \"'report-sample'\", \"'unsafe-inline'\")\n    CSP_SCRIPT_SRC = (\n        \"'self'\",\n        \"'report-sample'\",\n        \"'unsafe-inline'\",\n        \"'unsafe-eval'\",\n        'blob:',\n        'browser.sentry-cdn.com',\n        'https://*.googletagmanager.com',\n    )\n    CSP_IMG_SRC = (\n        \"'self'\",\n        \"'report-sample'\",\n        'data:',\n        'https://*.google-analytics.com',\n        'https://*.googletagmanager.com',\n        'https://*.google.com',\n    )\n    CSP_CONNECT_SRC = (\n        \"'self'\",\n        \"'report-sample'\",\n        'https://*.google-analytics.com',\n        'https://*.analytics.google.com',\n        'https://analytics.google.com',\n        'https://*.googletagmanager.com',\n        'https://*.g.double' + 'click.net',  # hacky way of suppressing codespell complaint\n        'https://*.ingest.sentry.io',\n    )\n    # Note that this will be overridden to real CSP for views that use the override_report_only_csp decorator\n    CSP_REPORT_ONLY = get_bool_env('LS_CSP_REPORT_ONLY', True)\n    CSP_REPORT_URI = get_env('LS_CSP_REPORT_URI', None)\n    CSP_INCLUDE_NONCE_IN = ['script-src', 'default-src']\n\n    MIDDLEWARE.append('core.middleware.HumanSignalCspMiddleware')\n\nCLOUD_STORAGE_CHECK_FOR_RECORDS_PAGE_SIZE = get_env('CLOUD_STORAGE_CHECK_FOR_RECORDS_PAGE_SIZE', 10000)\nCLOUD_STORAGE_CHECK_FOR_RECORDS_TIMEOUT = get_env('CLOUD_STORAGE_CHECK_FOR_RECORDS_TIMEOUT', 60)\n", "\"\"\"This file and its contents are licensed under the Apache License 2.0. Please see the included NOTICE for copyright information and LICENSE for a copy of the license.\n\"\"\"\nimport glob\nimport io\nimport ipaddress\nimport itertools\nimport os\nimport shutil\nimport socket\nfrom contextlib import contextmanager\nfrom tempfile import mkdtemp, mkstemp\n\nimport pkg_resources\nimport requests\nimport ujson as json\nimport yaml\nfrom appdirs import user_cache_dir, user_config_dir, user_data_dir\nfrom django.conf import settings\nfrom urllib3.util import parse_url\n\n# full path import results in unit test failures\nfrom .exceptions import InvalidUploadUrlError\n\n_DIR_APP_NAME = 'label-studio'\n\n\ndef good_path(path):\n    return os.path.abspath(os.path.expanduser(path))\n\n\ndef find_node(package_name, node_path, node_type):\n    assert node_type in ('dir', 'file', 'any')\n    basedir = pkg_resources.resource_filename(package_name, '')\n    node_path = os.path.join(*node_path.split('/'))  # linux to windows compatibility\n    search_by_path = '/' in node_path or '\\\\' in node_path\n\n    for path, dirs, filenames in os.walk(basedir):\n        if node_type == 'file':\n            nodes = filenames\n        elif node_type == 'dir':\n            nodes = dirs\n        else:\n            nodes = filenames + dirs\n        if search_by_path:\n            for found_node in nodes:\n                found_node = os.path.join(path, found_node)\n                if found_node.endswith(node_path):\n                    return found_node\n        elif node_path in nodes:\n            return os.path.join(path, node_path)\n    else:\n        raise IOError('Could not find \"%s\" at package \"%s\"' % (node_path, basedir))\n\n\ndef find_file(file):\n    return find_node('label_studio', file, 'file')\n\n\ndef find_dir(directory):\n    return find_node('label_studio', directory, 'dir')\n\n\n@contextmanager\ndef get_temp_file():\n    fd, path = mkstemp()\n    yield path\n    os.close(fd)\n\n\n@contextmanager\ndef get_temp_dir():\n    dirpath = mkdtemp()\n    yield dirpath\n    shutil.rmtree(dirpath)\n\n\ndef get_config_dir():\n    config_dir = user_config_dir(appname=_DIR_APP_NAME)\n    try:\n        os.makedirs(config_dir, exist_ok=True)\n    except OSError:\n        pass\n    return config_dir\n\n\ndef get_data_dir():\n    data_dir = user_data_dir(appname=_DIR_APP_NAME)\n    os.makedirs(data_dir, exist_ok=True)\n    return data_dir\n\n\ndef get_cache_dir():\n    cache_dir = user_cache_dir(appname=_DIR_APP_NAME)\n    os.makedirs(cache_dir, exist_ok=True)\n    return cache_dir\n\n\ndef delete_dir_content(dirpath):\n    for f in glob.glob(dirpath + '/*'):\n        remove_file_or_dir(f)\n\n\ndef remove_file_or_dir(path):\n    if os.path.isfile(path):\n        os.remove(path)\n    elif os.path.isdir(path):\n        shutil.rmtree(path)\n\n\ndef get_all_files_from_dir(d):\n    out = []\n    for name in os.listdir(d):\n        filepath = os.path.join(d, name)\n        if os.path.isfile(filepath):\n            out.append(filepath)\n    return out\n\n\ndef iter_files(root_dir, ext):\n    for root, _, files in os.walk(root_dir):\n        for f in files:\n            if f.lower().endswith(ext):\n                yield os.path.join(root, f)\n\n\ndef json_load(file, int_keys=False):\n    with io.open(file, encoding='utf8') as f:\n        data = json.load(f)\n        if int_keys:\n            return {int(k): v for k, v in data.items()}\n        else:\n            return data\n\n\ndef read_yaml(filepath):\n    if not os.path.exists(filepath):\n        filepath = find_file(filepath)\n    with io.open(filepath, encoding='utf-8') as f:\n        data = yaml.load(f, Loader=yaml.FullLoader)  # nosec\n    return data\n\n\ndef read_bytes_stream(filepath):\n    with open(filepath, mode='rb') as f:\n        return io.BytesIO(f.read())\n\n\ndef get_all_dirs_from_dir(d):\n    out = []\n    for name in os.listdir(d):\n        filepath = os.path.join(d, name)\n        if os.path.isdir(filepath):\n            out.append(filepath)\n    return out\n\n\nclass SerializableGenerator(list):\n    \"\"\"Generator that is serializable by JSON\"\"\"\n\n    def __init__(self, iterable):\n        tmp_body = iter(iterable)\n        try:\n            self._head = iter([next(tmp_body)])\n            self.append(tmp_body)\n        except StopIteration:\n            self._head = []\n\n    def __iter__(self):\n        return itertools.chain(self._head, *self[:1])\n\n\ndef validate_upload_url(url, block_local_urls=True):\n    \"\"\"Utility function for defending against SSRF attacks. Raises\n        - InvalidUploadUrlError if the url is not HTTP[S], or if block_local_urls is enabled\n          and the URL resolves to a local address.\n        - LabelStudioApiException if the hostname cannot be resolved\n\n    :param url: Url to be checked for validity/safety,\n    :param block_local_urls: Whether urls that resolve to local/private networks should be allowed.\n    \"\"\"\n\n    parsed_url = parse_url(url)\n\n    if parsed_url.scheme not in ('http', 'https'):\n        raise InvalidUploadUrlError\n\n    domain = parsed_url.host\n    try:\n        ip = socket.gethostbyname(domain)\n    except socket.error:\n        from core.utils.exceptions import LabelStudioAPIException\n\n        raise LabelStudioAPIException(f\"Can't resolve hostname {domain}\")\n\n    if block_local_urls:\n        validate_ip(ip)\n\n\ndef validate_ip(ip: str) -> None:\n    \"\"\"Checks if an IP is local/private.\n\n    :param ip: IP address to be checked.\n    \"\"\"\n\n    if ip == '0.0.0.0':  # nosec\n        raise InvalidUploadUrlError\n\n    local_subnets = [\n        '127.0.0.0/8',\n        '10.0.0.0/8',\n        '172.16.0.0/12',\n        '192.168.0.0/16',\n    ]\n\n    for subnet in local_subnets:\n        if ipaddress.ip_address(ip) in ipaddress.ip_network(subnet):\n            raise InvalidUploadUrlError\n\n\ndef ssrf_safe_get(url, *args, **kwargs):\n    validate_upload_url(url, block_local_urls=settings.SSRF_PROTECTION_ENABLED)\n    # Reason for #nosec: url has been validated as SSRF safe by the\n    # validation check above.\n    response = requests.get(url, *args, **kwargs)   # nosec\n\n    # second check for SSRF for prevent redirect and dns rebinding attacks\n    if settings.SSRF_PROTECTION_ENABLED:\n        response_ip = response.raw._connection.sock.getpeername()[0]\n        validate_ip(response_ip)\n    return response\n", "from unittest import mock\nfrom unittest.mock import Mock\n\nimport pytest\nfrom core.utils.io import validate_upload_url\nfrom data_import.uploader import check_tasks_max_file_size, load_tasks\nfrom django.conf import settings\nfrom rest_framework.exceptions import ValidationError\n\npytestmark = pytest.mark.django_db\n\n\nclass MockedRequest:\n    FILES = ()\n\n    def __init__(self, url):\n        self.url = url\n\n    @property\n    def content_type(self):\n        return 'application/x-www-form-urlencoded'\n\n    @property\n    def data(self):\n        return {'url': self.url}\n\n    @property\n    def user(self):\n        return None\n\n\nclass TestUploader:\n    @pytest.fixture\n    def project(self, configured_project, settings):\n        return configured_project\n\n    class TestLoadTasks:\n        @mock.patch('core.utils.io.validate_upload_url', wraps=validate_upload_url)\n        @pytest.mark.parametrize('url', ('file:///etc/passwd', 'ftp://example.org'))\n        def test_raises_for_unsafe_urls(self, validate_upload_url_mock, url, project):\n            request = MockedRequest(url=url)\n\n            with pytest.raises(ValidationError) as e:\n                load_tasks(request, project)\n                assert 'The provided URL was not valid.' in e.value\n\n            validate_upload_url_mock.assert_called_once_with(url, block_local_urls=False)\n\n        @mock.patch('core.utils.io.validate_upload_url', wraps=validate_upload_url)\n        def test_raises_for_local_urls_with_ssrf_protection_enabled(self, validate_upload_url_mock, project, settings):\n            settings.SSRF_PROTECTION_ENABLED = True\n            request = MockedRequest(url='http://0.0.0.0')\n\n            with pytest.raises(ValidationError) as e:\n                load_tasks(request, project)\n                assert 'The provided URL was not valid.' in e.value\n\n            validate_upload_url_mock.assert_called_once_with('http://0.0.0.0', block_local_urls=True)\n\n        def test_local_url_after_redirect(self, project, settings):\n            settings.SSRF_PROTECTION_ENABLED = True\n            request = MockedRequest(url='http://validurl.com')\n\n            # Mock the necessary parts of the response object\n            mock_response = Mock()\n            mock_response.raw._connection.sock.getpeername.return_value = ('127.0.0.1', 8080)\n\n            # Patch the requests.get call in the data_import.uploader module\n            with mock.patch('core.utils.io.requests.get', return_value=mock_response), pytest.raises(\n                ValidationError\n            ) as e:\n                load_tasks(request, project)\n            assert 'The provided URL was not valid.' in str(e.value)\n\n\nclass TestTasksFileChecks:\n    @pytest.mark.parametrize('value', (0, settings.TASKS_MAX_FILE_SIZE - 1))\n    def test_check_tasks_max_file_size_does_not_raise_for_correct_value(self, value):\n        check_tasks_max_file_size(value)\n\n    def test_check_tasks_max_file_size_raises_for_too_big_value(self):\n        value = settings.TASKS_MAX_FILE_SIZE + 1\n\n        with pytest.raises(ValidationError) as e:\n            check_tasks_max_file_size(value)\n\n        assert f'Maximum total size of all files is {settings.TASKS_MAX_FILE_SIZE} bytes' in str(e.value)\n"], "fixing_code": ["\"\"\"This file and its contents are licensed under the Apache License 2.0. Please see the included NOTICE for copyright information and LICENSE for a copy of the license.\n\"\"\"\n\"\"\"\nDjango Base settings for Label Studio.\n\nFor more information on this file, see\nhttps://docs.djangoproject.com/en/3.1/topics/settings/\n\nFor the full list of settings and their values, see\nhttps://docs.djangoproject.com/en/3.1/ref/settings/\n\"\"\"\nimport json\nimport logging\nimport os\nimport re\nfrom datetime import timedelta\n\nfrom label_studio.core.utils.params import get_bool_env, get_env_list\n\nformatter = 'standard'\nJSON_LOG = get_bool_env('JSON_LOG', False)\nif JSON_LOG:\n    formatter = 'json'\n\nLOGGING = {\n    'version': 1,\n    'disable_existing_loggers': False,\n    'formatters': {\n        'json': {\n            '()': 'label_studio.core.utils.formatter.CustomJsonFormatter',\n            'format': '[%(asctime)s] [%(name)s::%(funcName)s::%(lineno)d] [%(levelname)s] [%(user_id)s] %(message)s',\n            'datefmt': '%d/%b/%Y:%H:%M:%S %z',\n        },\n        'standard': {\n            'format': '[%(asctime)s] [%(name)s::%(funcName)s::%(lineno)d] [%(levelname)s] %(message)s',\n        },\n    },\n    'handlers': {\n        'console': {\n            'class': 'logging.StreamHandler',\n            'formatter': formatter,\n        },\n    },\n    'root': {\n        'handlers': ['console'],\n        'level': os.environ.get('LOG_LEVEL', 'DEBUG'),\n    },\n    'loggers': {\n        'pykwalify': {'level': 'ERROR', 'propagate': False},\n        'tavern': {'level': 'ERROR', 'propagate': False},\n        'asyncio': {'level': 'WARNING'},\n        'rules': {'level': 'WARNING'},\n        'django': {\n            'handlers': ['console'],\n            # 'propagate': True,\n        },\n        'django_auth_ldap': {'level': os.environ.get('LOG_LEVEL', 'DEBUG')},\n        'rq.worker': {\n            'handlers': ['console'],\n            'level': os.environ.get('LOG_LEVEL', 'INFO'),\n        },\n        'ddtrace': {\n            'handlers': ['console'],\n            'level': 'WARNING',\n        },\n        'ldclient.util': {\n            'handlers': ['console'],\n            'level': 'ERROR',\n        },\n    },\n}\n\n# for printing messages before main logging config applied\nif not logging.getLogger().hasHandlers():\n    logging.basicConfig(level=logging.DEBUG, format='%(message)s')\n\nfrom label_studio.core.utils.io import get_data_dir\nfrom label_studio.core.utils.params import get_bool_env, get_env\n\nlogger = logging.getLogger(__name__)\nSILENCED_SYSTEM_CHECKS = []\n\n# Hostname is used for proper path generation to the resources, pages, etc\nHOSTNAME = get_env('HOST', '')\nif HOSTNAME:\n    if not HOSTNAME.startswith('http://') and not HOSTNAME.startswith('https://'):\n        logger.info(\n            '! HOST variable found in environment, but it must start with http:// or https://, ignore it: %s', HOSTNAME\n        )\n        HOSTNAME = ''\n    else:\n        logger.info('=> Hostname correctly is set to: %s', HOSTNAME)\n        if HOSTNAME.endswith('/'):\n            HOSTNAME = HOSTNAME[0:-1]\n\n        # for django url resolver\n        if HOSTNAME:\n            # http[s]://domain.com:8080/script_name => /script_name\n            pattern = re.compile(r'^http[s]?:\\/\\/([^:\\/\\s]+(:\\d*)?)(.*)?')\n            match = pattern.match(HOSTNAME)\n            FORCE_SCRIPT_NAME = match.group(3)\n            if FORCE_SCRIPT_NAME:\n                logger.info('=> Django URL prefix is set to: %s', FORCE_SCRIPT_NAME)\n\nINTERNAL_PORT = '8080'\n\n# SECURITY WARNING: don't run with debug turned on in production!\nDEBUG = get_bool_env('DEBUG', True)\nDEBUG_MODAL_EXCEPTIONS = get_bool_env('DEBUG_MODAL_EXCEPTIONS', True)\n\n# Whether to verify SSL certs when making external requests, eg in the uploader\n# \u26a0\ufe0f Turning this off means assuming risk. \u26a0\ufe0f\n# Overridable at organization level via Organization#verify_ssl_certs\nVERIFY_SSL_CERTS = get_bool_env('VERIFY_SSL_CERTS', True)\n\n# 'sqlite-dll-<arch>-<version>.zip' should be hosted at this prefix\nWINDOWS_SQLITE_BINARY_HOST_PREFIX = get_env('WINDOWS_SQLITE_BINARY_HOST_PREFIX', 'https://www.sqlite.org/2023/')\n\n# Build paths inside the project like this: os.path.join(BASE_DIR, ...)\nBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n\n# Base path for media root and other uploaded files\nBASE_DATA_DIR = get_env('BASE_DATA_DIR')\nif BASE_DATA_DIR is None:\n    BASE_DATA_DIR = get_data_dir()\nos.makedirs(BASE_DATA_DIR, exist_ok=True)\nlogger.info('=> Database and media directory: %s', BASE_DATA_DIR)\n\n# Databases\n# https://docs.djangoproject.com/en/2.1/ref/settings/#databases\nDJANGO_DB_MYSQL = 'mysql'\nDJANGO_DB_SQLITE = 'sqlite'\nDJANGO_DB_POSTGRESQL = 'postgresql'\nDJANGO_DB = 'default'\nDATABASE_NAME_DEFAULT = os.path.join(BASE_DATA_DIR, 'label_studio.sqlite3')\nDATABASE_NAME = get_env('DATABASE_NAME', DATABASE_NAME_DEFAULT)\nDATABASES_ALL = {\n    DJANGO_DB_POSTGRESQL: {\n        'ENGINE': 'django.db.backends.postgresql',\n        'USER': get_env('POSTGRE_USER', 'postgres'),\n        'PASSWORD': get_env('POSTGRE_PASSWORD', 'postgres'),\n        'NAME': get_env('POSTGRE_NAME', 'postgres'),\n        'HOST': get_env('POSTGRE_HOST', 'localhost'),\n        'PORT': int(get_env('POSTGRE_PORT', '5432')),\n    },\n    DJANGO_DB_MYSQL: {\n        'ENGINE': 'django.db.backends.mysql',\n        'USER': get_env('MYSQL_USER', 'root'),\n        'PASSWORD': get_env('MYSQL_PASSWORD', ''),\n        'NAME': get_env('MYSQL_NAME', 'labelstudio'),\n        'HOST': get_env('MYSQL_HOST', 'localhost'),\n        'PORT': int(get_env('MYSQL_PORT', '3306')),\n    },\n    DJANGO_DB_SQLITE: {\n        'ENGINE': 'django.db.backends.sqlite3',\n        'NAME': DATABASE_NAME,\n        'OPTIONS': {\n            # 'timeout': 20,\n        },\n    },\n}\nDATABASES_ALL['default'] = DATABASES_ALL[DJANGO_DB_POSTGRESQL]\nDATABASES = {'default': DATABASES_ALL.get(get_env('DJANGO_DB', 'default'))}\n\nDEFAULT_AUTO_FIELD = 'django.db.models.AutoField'\n\nif get_bool_env('GOOGLE_LOGGING_ENABLED', False):\n    logging.info('Google Cloud Logging handler is enabled.')\n    try:\n        import google.cloud.logging\n        from google.auth.exceptions import GoogleAuthError\n\n        client = google.cloud.logging.Client()\n        client.setup_logging()\n\n        LOGGING['handlers']['google_cloud_logging'] = {\n            'level': get_env('LOG_LEVEL', 'WARNING'),\n            'class': 'google.cloud.logging.handlers.CloudLoggingHandler',\n            'client': client,\n        }\n        LOGGING['root']['handlers'].append('google_cloud_logging')\n    except GoogleAuthError:\n        logger.exception('Google Cloud Logging handler could not be setup.')\n\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'django.contrib.humanize',\n    'drf_yasg',\n    'corsheaders',\n    'django_extensions',\n    'django_rq',\n    'django_filters',\n    'rules',\n    'annoying',\n    'rest_framework',\n    'rest_framework.authtoken',\n    'drf_generators',\n    'core',\n    'users',\n    'organizations',\n    'data_import',\n    'data_export',\n    'projects',\n    'tasks',\n    'data_manager',\n    'io_storages',\n    'ml',\n    'webhooks',\n    'labels_manager',\n]\n\nMIDDLEWARE = [\n    'corsheaders.middleware.CorsMiddleware',\n    'django.middleware.security.SecurityMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'django.middleware.locale.LocaleMiddleware',\n    'core.middleware.DisableCSRF',\n    'django.middleware.csrf.CsrfViewMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',\n    'core.middleware.CommonMiddlewareAppendSlashWithoutRedirect',  # instead of 'CommonMiddleware'\n    'core.middleware.CommonMiddleware',\n    'django_user_agents.middleware.UserAgentMiddleware',\n    'core.middleware.SetSessionUIDMiddleware',\n    'core.middleware.ContextLogMiddleware',\n    'core.middleware.DatabaseIsLockedRetryMiddleware',\n    'core.current_request.ThreadLocalMiddleware',\n]\n\nREST_FRAMEWORK = {\n    'DEFAULT_FILTER_BACKENDS': ['django_filters.rest_framework.DjangoFilterBackend'],\n    'DEFAULT_AUTHENTICATION_CLASSES': (\n        'rest_framework.authentication.TokenAuthentication',\n        'rest_framework.authentication.SessionAuthentication',\n    ),\n    'DEFAULT_PERMISSION_CLASSES': [\n        'core.api_permissions.HasObjectPermission',\n        'rest_framework.permissions.IsAuthenticated',\n    ],\n    'EXCEPTION_HANDLER': 'core.utils.common.custom_exception_handler',\n    'DEFAULT_RENDERER_CLASSES': ('rest_framework.renderers.JSONRenderer',),\n    'DEFAULT_VERSIONING_CLASS': 'rest_framework.versioning.NamespaceVersioning',\n    'PAGE_SIZE': 100,\n    # 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination'\n}\nSILENCED_SYSTEM_CHECKS += ['rest_framework.W001']\n\n# CORS & Host settings\nINTERNAL_IPS = [  # django debug toolbar for django==2.2 requirement\n    '127.0.0.1',\n    'localhost',\n]\nCORS_ORIGIN_ALLOW_ALL = True\nCORS_ALLOW_METHODS = [\n    'DELETE',\n    'GET',\n    'OPTIONS',\n    'PATCH',\n    'POST',\n    'PUT',\n]\nALLOWED_HOSTS = ['*']\n\n# Auth modules\nAUTH_USER_MODEL = 'users.User'\nAUTHENTICATION_BACKENDS = [\n    'rules.permissions.ObjectPermissionBackend',\n    'django.contrib.auth.backends.ModelBackend',\n]\nUSE_USERNAME_FOR_LOGIN = False\n\nDISABLE_SIGNUP_WITHOUT_LINK = get_bool_env('DISABLE_SIGNUP_WITHOUT_LINK', False)\n\n# Password validation:\n# https://docs.djangoproject.com/en/2.1/ref/settings/#auth-password-validators\nAUTH_PASSWORD_VALIDATORS = [\n    {'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator'},\n    {'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator'},\n    {'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator'},\n    {'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator'},\n]\n\n# Django templates\nTEMPLATES_DIR = os.path.join(os.path.dirname(BASE_DIR), 'templates')  # ../../from_this = 'web' dir\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [TEMPLATES_DIR],\n        'APP_DIRS': True,\n        'OPTIONS': {\n            'context_processors': [\n                'django.template.context_processors.debug',\n                'django.template.context_processors.request',\n                'django.contrib.auth.context_processors.auth',\n                'django.contrib.messages.context_processors.messages',\n                'core.context_processors.settings',\n            ],\n            'builtins': ['django.templatetags.i18n'],\n        },\n    }\n]\n\n# RQ\nRQ_QUEUES = {\n    'critical': {\n        'HOST': 'localhost',\n        'PORT': 6379,\n        'DB': 0,\n        'DEFAULT_TIMEOUT': 180,\n    },\n    'high': {\n        'HOST': 'localhost',\n        'PORT': 6379,\n        'DB': 0,\n        'DEFAULT_TIMEOUT': 180,\n    },\n    'default': {\n        'HOST': 'localhost',\n        'PORT': 6379,\n        'DB': 0,\n        'DEFAULT_TIMEOUT': 180,\n    },\n    'low': {\n        'HOST': 'localhost',\n        'PORT': 6379,\n        'DB': 0,\n        'DEFAULT_TIMEOUT': 180,\n    },\n}\n\n# Swagger: automatic API documentation\nSWAGGER_SETTINGS = {\n    'SECURITY_DEFINITIONS': {\n        'Token': {\n            'type': 'apiKey',\n            'name': 'Authorization',\n            'in': 'header',\n            'description': 'The token (or API key) must be passed as a request header. '\n            'You can find your user token on the User Account page in Label Studio. Example: '\n            '<br><pre><code class=\"language-bash\">'\n            'curl https://label-studio-host/api/projects -H \"Authorization: Token [your-token]\"'\n            '</code></pre>',\n        }\n    },\n    'APIS_SORTER': 'alpha',\n    'SUPPORTED_SUBMIT_METHODS': ['get', 'post', 'put', 'delete', 'patch'],\n    'OPERATIONS_SORTER': 'alpha',\n}\n\nSENTRY_DSN = get_env('SENTRY_DSN', None)\nSENTRY_RATE = float(get_env('SENTRY_RATE', 0.25))\nSENTRY_ENVIRONMENT = get_env('SENTRY_ENVIRONMENT', 'stage.opensource')\nSENTRY_REDIS_ENABLED = False\nFRONTEND_SENTRY_DSN = get_env('FRONTEND_SENTRY_DSN', None)\nFRONTEND_SENTRY_RATE = get_env('FRONTEND_SENTRY_RATE', 0.1)\nFRONTEND_SENTRY_ENVIRONMENT = get_env('FRONTEND_SENTRY_ENVIRONMENT', 'stage.opensource')\n\nROOT_URLCONF = 'core.urls'\nWSGI_APPLICATION = 'core.wsgi.application'\nGRAPHIQL = True\n\n# Internationalization\n# https://docs.djangoproject.com/en/2.1/topics/i18n/\nLANGUAGE_CODE = 'en-us'\nTIME_ZONE = 'UTC'\nUSE_I18N = False\nUSE_L10N = True\nUSE_TZ = True\n\n# Static files (CSS, JavaScript, Images)\n# https://docs.djangoproject.com/en/2.1/howto/static-files/\nSTATIC_URL = '/static/'\n# if FORCE_SCRIPT_NAME:\n#    STATIC_URL = FORCE_SCRIPT_NAME + STATIC_URL\nlogger.info(f'=> Static URL is set to: {STATIC_URL}')\n\nSTATIC_ROOT = os.path.join(BASE_DIR, 'static_build')\nSTATICFILES_DIRS = [os.path.join(BASE_DIR, 'static')]\nSTATICFILES_FINDERS = (\n    'django.contrib.staticfiles.finders.FileSystemFinder',\n    'django.contrib.staticfiles.finders.AppDirectoriesFinder',\n)\nSTATICFILES_STORAGE = 'core.storage.SkipMissedManifestStaticFilesStorage'\n\n# Sessions and CSRF\nSESSION_COOKIE_SECURE = bool(int(get_env('SESSION_COOKIE_SECURE', False)))\nSESSION_COOKIE_SAMESITE = get_env('SESSION_COOKIE_SAMESITE', 'Lax')\n\nCSRF_COOKIE_SECURE = bool(int(get_env('CSRF_COOKIE_SECURE', SESSION_COOKIE_SECURE)))\nCSRF_COOKIE_HTTPONLY = bool(int(get_env('CSRF_COOKIE_HTTPONLY', SESSION_COOKIE_SECURE)))\nCSRF_COOKIE_SAMESITE = get_env('CSRF_COOKIE_SAMESITE', 'Lax')\n\n# Inactivity user sessions\nINACTIVITY_SESSION_TIMEOUT_ENABLED = bool(int(get_env('INACTIVITY_SESSION_TIMEOUT_ENABLED', True)))\n# The most time a login will last, regardless of activity\nMAX_SESSION_AGE = int(get_env('MAX_SESSION_AGE', timedelta(days=14).total_seconds()))\n# The most time that can elapse between activity with the server before the user is logged out\nMAX_TIME_BETWEEN_ACTIVITY = int(get_env('MAX_TIME_BETWEEN_ACTIVITY', timedelta(days=5).total_seconds()))\n\nSSRF_PROTECTION_ENABLED = get_bool_env('SSRF_PROTECTION_ENABLED', False)\nUSE_DEFAULT_BANNED_SUBNETS = get_bool_env('USE_DEFAULT_BANNED_SUBNETS', True)\nUSER_ADDITIONAL_BANNED_SUBNETS = get_env_list('USER_ADDITIONAL_BANNED_SUBNETS', default=[])\n\n# user media files\nMEDIA_ROOT = os.path.join(BASE_DATA_DIR, 'media')\nos.makedirs(MEDIA_ROOT, exist_ok=True)\nMEDIA_URL = '/data/'\nUPLOAD_DIR = 'upload'\nAVATAR_PATH = 'avatars'\n\nSUPPORTED_EXTENSIONS = set(\n    [\n        '.bmp',\n        '.csv',\n        '.flac',\n        '.gif',\n        '.htm',\n        '.html',\n        '.jpg',\n        '.jpeg',\n        '.json',\n        '.m4a',\n        '.mp3',\n        '.ogg',\n        '.png',\n        '.svg',\n        '.tsv',\n        '.txt',\n        '.wav',\n        '.xml',\n        '.mp4',\n        '.webm',\n        '.webp',\n    ]\n)\n\n# directory for files created during unit tests\nTEST_DATA_ROOT = os.path.join(BASE_DATA_DIR, 'test_data')\nos.makedirs(TEST_DATA_ROOT, exist_ok=True)\n\n# project exports\nEXPORT_DIR = os.path.join(BASE_DATA_DIR, 'export')\nEXPORT_URL_ROOT = '/export/'\nEXPORT_MIXIN = 'data_export.mixins.ExportMixin'\n# old export dir\nos.makedirs(EXPORT_DIR, exist_ok=True)\n# dir for delayed export\nDELAYED_EXPORT_DIR = 'export'\nos.makedirs(os.path.join(BASE_DATA_DIR, MEDIA_ROOT, DELAYED_EXPORT_DIR), exist_ok=True)\n\n# file / task size limits\nDATA_UPLOAD_MAX_MEMORY_SIZE = int(get_env('DATA_UPLOAD_MAX_MEMORY_SIZE', 250 * 1024 * 1024))\nDATA_UPLOAD_MAX_NUMBER_FILES = int(get_env('DATA_UPLOAD_MAX_NUMBER_FILES', 100))\nTASKS_MAX_NUMBER = 1000000\nTASKS_MAX_FILE_SIZE = DATA_UPLOAD_MAX_MEMORY_SIZE\n\nTASK_LOCK_TTL = int(get_env('TASK_LOCK_TTL', default=86400))\n\nLABEL_STREAM_HISTORY_LIMIT = int(get_env('LABEL_STREAM_HISTORY_LIMIT', default=100))\n\nRANDOM_NEXT_TASK_SAMPLE_SIZE = int(get_env('RANDOM_NEXT_TASK_SAMPLE_SIZE', 50))\n\nTASK_API_PAGE_SIZE_MAX = int(get_env('TASK_API_PAGE_SIZE_MAX', 0)) or None\n\n# Email backend\nFROM_EMAIL = get_env('FROM_EMAIL', 'Label Studio <hello@labelstud.io>')\nEMAIL_BACKEND = get_env('EMAIL_BACKEND', 'django.core.mail.backends.dummy.EmailBackend')\n\nENABLE_LOCAL_FILES_STORAGE = get_bool_env('ENABLE_LOCAL_FILES_STORAGE', default=True)\nLOCAL_FILES_SERVING_ENABLED = get_bool_env('LOCAL_FILES_SERVING_ENABLED', default=False)\nLOCAL_FILES_DOCUMENT_ROOT = get_env('LOCAL_FILES_DOCUMENT_ROOT', default=os.path.abspath(os.sep))\n\nSYNC_ON_TARGET_STORAGE_CREATION = get_bool_env('SYNC_ON_TARGET_STORAGE_CREATION', default=True)\n\nALLOW_IMPORT_TASKS_WITH_UNKNOWN_EMAILS = get_bool_env('ALLOW_IMPORT_TASKS_WITH_UNKNOWN_EMAILS', default=False)\n\n\"\"\" React Libraries: do not forget to change this dir in /etc/nginx/nginx.conf \"\"\"\n\n# EDITOR = label-studio-frontend repository\nEDITOR_ROOT = os.path.join(BASE_DIR, '../../web/dist/libs/editor')\n# DM = data manager (included into FRONTEND due npm building, we need only version.json file from there)\nDM_ROOT = os.path.join(BASE_DIR, '../../web/dist/libs/datamanager')\n# FRONTEND = GUI for django backend\nREACT_APP_ROOT = os.path.join(BASE_DIR, '../../web/dist/apps/labelstudio')\n\n# per project settings\nBATCH_SIZE = 1000\nPROJECT_TITLE_MIN_LEN = 3\nPROJECT_TITLE_MAX_LEN = 50\nLOGIN_REDIRECT_URL = '/'\nLOGIN_URL = '/'\nMIN_GROUND_TRUTH = 10\nDATA_UNDEFINED_NAME = '$undefined$'\nLICENSE = {}\nVERSIONS = {}\nVERSION_EDITION = 'Community'\nLATEST_VERSION_CHECK = True\nVERSIONS_CHECK_TIME = 0\nALLOW_ORGANIZATION_WEBHOOKS = get_bool_env('ALLOW_ORGANIZATION_WEBHOOKS', False)\nCONVERTER_DOWNLOAD_RESOURCES = get_bool_env('CONVERTER_DOWNLOAD_RESOURCES', True)\nEXPERIMENTAL_FEATURES = get_bool_env('EXPERIMENTAL_FEATURES', False)\nUSE_ENFORCE_CSRF_CHECKS = get_bool_env('USE_ENFORCE_CSRF_CHECKS', True)  # False is for tests\nCLOUD_FILE_STORAGE_ENABLED = False\n\nIO_STORAGES_IMPORT_LINK_NAMES = [\n    'io_storages_s3importstoragelink',\n    'io_storages_gcsimportstoragelink',\n    'io_storages_azureblobimportstoragelink',\n    'io_storages_localfilesimportstoragelink',\n    'io_storages_redisimportstoragelink',\n]\n\nCREATE_ORGANIZATION = 'organizations.functions.create_organization'\nSAVE_USER = 'users.functions.save_user'\nPOST_PROCESS_REIMPORT = 'core.utils.common.empty'\nUSER_SERIALIZER = 'users.serializers.BaseUserSerializer'\nUSER_SERIALIZER_UPDATE = 'users.serializers.BaseUserSerializerUpdate'\nTASK_SERIALIZER = 'tasks.serializers.BaseTaskSerializer'\nEXPORT_DATA_SERIALIZER = 'data_export.serializers.BaseExportDataSerializer'\nDATA_MANAGER_GET_ALL_COLUMNS = 'data_manager.functions.get_all_columns'\nDATA_MANAGER_ANNOTATIONS_MAP = {}\nDATA_MANAGER_ACTIONS = {}\nDATA_MANAGER_CUSTOM_FILTER_EXPRESSIONS = 'data_manager.functions.custom_filter_expressions'\nDATA_MANAGER_PREPROCESS_FILTER = 'data_manager.functions.preprocess_filter'\nUSER_LOGIN_FORM = 'users.forms.LoginForm'\nPROJECT_MIXIN = 'projects.mixins.ProjectMixin'\nTASK_MIXIN = 'tasks.mixins.TaskMixin'\nANNOTATION_MIXIN = 'tasks.mixins.AnnotationMixin'\nORGANIZATION_MIXIN = 'organizations.mixins.OrganizationMixin'\nUSER_MIXIN = 'users.mixins.UserMixin'\nORGANIZATION_MEMBER_MIXIN = 'organizations.mixins.OrganizationMemberMixin'\nMEMBER_PERM = 'core.api_permissions.MemberHasOwnerPermission'\nRECALCULATE_ALL_STATS = None\nGET_STORAGE_LIST = 'io_storages.functions.get_storage_list'\nSTORAGE_ANNOTATION_SERIALIZER = 'io_storages.serializers.StorageAnnotationSerializer'\nTASK_SERIALIZER_BULK = 'tasks.serializers.BaseTaskSerializerBulk'\nPREPROCESS_FIELD_NAME = 'data_manager.functions.preprocess_field_name'\nINTERACTIVE_DATA_SERIALIZER = 'data_export.serializers.BaseExportDataSerializerForInteractive'\nDELETE_TASKS_ANNOTATIONS_POSTPROCESS = None\n\n\ndef project_delete(project):\n    project.delete()\n\n\ndef user_auth(user_model, email, password):\n    return None\n\n\ndef collect_versions_dummy(**kwargs):\n    return {}\n\n\nPROJECT_DELETE = project_delete\nUSER_AUTH = user_auth\nCOLLECT_VERSIONS = collect_versions_dummy\n\nWEBHOOK_TIMEOUT = float(get_env('WEBHOOK_TIMEOUT', 1.0))\nWEBHOOK_BATCH_SIZE = int(get_env('WEBHOOK_BATCH_SIZE', 100))\nWEBHOOK_SERIALIZERS = {\n    'project': 'webhooks.serializers_for_hooks.ProjectWebhookSerializer',\n    'task': 'webhooks.serializers_for_hooks.TaskWebhookSerializer',\n    'annotation': 'webhooks.serializers_for_hooks.AnnotationWebhookSerializer',\n    'label': 'labels_manager.serializers.LabelSerializer',\n    'label_link': 'labels_manager.serializers.LabelLinkSerializer',\n}\n\nEDITOR_KEYMAP = json.dumps(get_env('EDITOR_KEYMAP'))\n\n# fix a problem with Windows mimetypes for JS and PNG\nimport mimetypes\n\nmimetypes.add_type('application/javascript', '.js', True)\nmimetypes.add_type('image/png', '.png', True)\n\n# fields name was used in DM api before\nREST_FLEX_FIELDS = {'FIELDS_PARAM': 'include'}\n\nINTERPOLATE_KEY_FRAMES = get_env('INTERPOLATE_KEY_FRAMES', False)\n\n# Feature Flags\nFEATURE_FLAGS_API_KEY = get_env('FEATURE_FLAGS_API_KEY', default='any key')\n\n# we may set feature flags from file\nFEATURE_FLAGS_FROM_FILE = get_bool_env('FEATURE_FLAGS_FROM_FILE', False)\nFEATURE_FLAGS_FILE = get_env('FEATURE_FLAGS_FILE', 'feature_flags.json')\n# or if file is not set, default is using offline mode\nFEATURE_FLAGS_OFFLINE = get_bool_env('FEATURE_FLAGS_OFFLINE', True)\n# default value for feature flags (if not overridden by environment or client)\nFEATURE_FLAGS_DEFAULT_VALUE = False\n\n# Whether to send analytics telemetry data\nCOLLECT_ANALYTICS = get_bool_env('collect_analytics', True)\n\n# Strip harmful content from SVG files by default\nSVG_SECURITY_CLEANUP = get_bool_env('SVG_SECURITY_CLEANUP', False)\n\nML_BLOCK_LOCAL_IP = get_bool_env('ML_BLOCK_LOCAL_IP', False)\n\nRQ_LONG_JOB_TIMEOUT = int(get_env('RQ_LONG_JOB_TIMEOUT', 36000))\n\nAPP_WEBSERVER = get_env('APP_WEBSERVER', 'django')\n\nBATCH_JOB_RETRY_TIMEOUT = int(get_env('BATCH_JOB_RETRY_TIMEOUT', 60))\n\nFUTURE_SAVE_TASK_TO_STORAGE = get_bool_env('FUTURE_SAVE_TASK_TO_STORAGE', default=False)\nFUTURE_SAVE_TASK_TO_STORAGE_JSON_EXT = get_bool_env('FUTURE_SAVE_TASK_TO_STORAGE_JSON_EXT', default=True)\nSTORAGE_IN_PROGRESS_TIMER = float(get_env('STORAGE_IN_PROGRESS_TIMER', 5.0))\nSTORAGE_EXPORT_CHUNK_SIZE = int(get_env('STORAGE_EXPORT_CHUNK_SIZE', 100))\n\nUSE_NGINX_FOR_EXPORT_DOWNLOADS = get_bool_env('USE_NGINX_FOR_EXPORT_DOWNLOADS', False)\n\nif get_env('MINIO_STORAGE_ENDPOINT') and not get_bool_env('MINIO_SKIP', False):\n    CLOUD_FILE_STORAGE_ENABLED = True\n    DEFAULT_FILE_STORAGE = 'storages.backends.s3boto3.S3Boto3Storage'\n    AWS_STORAGE_BUCKET_NAME = get_env('MINIO_STORAGE_BUCKET_NAME')\n    AWS_ACCESS_KEY_ID = get_env('MINIO_STORAGE_ACCESS_KEY')\n    AWS_SECRET_ACCESS_KEY = get_env('MINIO_STORAGE_SECRET_KEY')\n    AWS_S3_ENDPOINT_URL = get_env('MINIO_STORAGE_ENDPOINT')\n    AWS_QUERYSTRING_AUTH = False\n    # make domain for FileUpload.file\n    AWS_S3_SECURE_URLS = False\n    AWS_S3_URL_PROTOCOL = 'http:' if HOSTNAME.startswith('http://') else 'https:'\n    AWS_S3_CUSTOM_DOMAIN = HOSTNAME.replace('http://', '').replace('https://', '') + '/data'\n\nif get_env('STORAGE_TYPE') == 's3':\n    CLOUD_FILE_STORAGE_ENABLED = True\n    DEFAULT_FILE_STORAGE = 'core.storage.CustomS3Boto3Storage'\n    if get_env('STORAGE_AWS_ACCESS_KEY_ID'):\n        AWS_ACCESS_KEY_ID = get_env('STORAGE_AWS_ACCESS_KEY_ID')\n    if get_env('STORAGE_AWS_SECRET_ACCESS_KEY'):\n        AWS_SECRET_ACCESS_KEY = get_env('STORAGE_AWS_SECRET_ACCESS_KEY')\n    AWS_STORAGE_BUCKET_NAME = get_env('STORAGE_AWS_BUCKET_NAME')\n    AWS_S3_REGION_NAME = get_env('STORAGE_AWS_REGION_NAME', None)\n    AWS_S3_ENDPOINT_URL = get_env('STORAGE_AWS_ENDPOINT_URL', None)\n    if get_env('STORAGE_AWS_OBJECT_PARAMETERS'):\n        AWS_S3_OBJECT_PARAMETERS = json.loads(get_env('STORAGE_AWS_OBJECT_PARAMETERS'))\n    AWS_QUERYSTRING_EXPIRE = int(get_env('STORAGE_AWS_X_AMZ_EXPIRES', '86400'))\n    AWS_LOCATION = get_env('STORAGE_AWS_FOLDER', default='')\n    AWS_S3_USE_SSL = get_bool_env('STORAGE_AWS_S3_USE_SSL', True)\n    AWS_S3_VERIFY = get_env('STORAGE_AWS_S3_VERIFY', None)\n    if AWS_S3_VERIFY == 'false' or AWS_S3_VERIFY == 'False' or AWS_S3_VERIFY == '0':\n        AWS_S3_VERIFY = False\n    AWS_S3_SIGNATURE_VERSION = get_env('STORAGE_AWS_S3_SIGNATURE_VERSION', None)\n\nif get_env('STORAGE_TYPE') == 'azure':\n    CLOUD_FILE_STORAGE_ENABLED = True\n    DEFAULT_FILE_STORAGE = 'core.storage.CustomAzureStorage'\n    AZURE_ACCOUNT_NAME = get_env('STORAGE_AZURE_ACCOUNT_NAME')\n    AZURE_ACCOUNT_KEY = get_env('STORAGE_AZURE_ACCOUNT_KEY')\n    AZURE_CONTAINER = get_env('STORAGE_AZURE_CONTAINER_NAME')\n    AZURE_URL_EXPIRATION_SECS = int(get_env('STORAGE_AZURE_URL_EXPIRATION_SECS', '86400'))\n    AZURE_LOCATION = get_env('STORAGE_AZURE_FOLDER', default='')\n\nif get_env('STORAGE_TYPE') == 'gcs':\n    CLOUD_FILE_STORAGE_ENABLED = True\n    # DEFAULT_FILE_STORAGE = 'storages.backends.gcloud.GoogleCloudStorage'\n    DEFAULT_FILE_STORAGE = 'core.storage.AlternativeGoogleCloudStorage'\n    GS_PROJECT_ID = get_env('STORAGE_GCS_PROJECT_ID')\n    GS_BUCKET_NAME = get_env('STORAGE_GCS_BUCKET_NAME')\n    GS_EXPIRATION = timedelta(seconds=int(get_env('STORAGE_GCS_EXPIRATION_SECS', '86400')))\n    GS_LOCATION = get_env('STORAGE_GCS_FOLDER', default='')\n    GS_CUSTOM_ENDPOINT = get_env('STORAGE_GCS_ENDPOINT')\n\nCSRF_TRUSTED_ORIGINS = get_env('CSRF_TRUSTED_ORIGINS', [])\nif CSRF_TRUSTED_ORIGINS:\n    CSRF_TRUSTED_ORIGINS = CSRF_TRUSTED_ORIGINS.split(',')\n\nREAL_HOSTNAME = os.getenv('HOSTNAME')  # we have to use getenv, because we don't use LABEL_STUDIO_ prefix\nGCS_CLOUD_STORAGE_FORCE_DEFAULT_CREDENTIALS = get_bool_env('GCS_CLOUD_STORAGE_FORCE_DEFAULT_CREDENTIALS', False)\nPUBLIC_API_DOCS = get_bool_env('PUBLIC_API_DOCS', False)\n\n# By default, we disallow filters with foreign keys in data manager for security reasons.\n# Add to this list (either here in code, or via the env) to allow specific filters that rely on foreign keys.\nDATA_MANAGER_FILTER_ALLOWLIST = list(\n    set(get_env_list('DATA_MANAGER_FILTER_ALLOWLIST') + ['updated_by__active_organization'])\n)\n\nif ENABLE_CSP := get_bool_env('ENABLE_CSP', True):\n    CSP_DEFAULT_SRC = (\n        \"'self'\",\n        \"'report-sample'\",\n    )\n    CSP_STYLE_SRC = (\"'self'\", \"'report-sample'\", \"'unsafe-inline'\")\n    CSP_SCRIPT_SRC = (\n        \"'self'\",\n        \"'report-sample'\",\n        \"'unsafe-inline'\",\n        \"'unsafe-eval'\",\n        'blob:',\n        'browser.sentry-cdn.com',\n        'https://*.googletagmanager.com',\n    )\n    CSP_IMG_SRC = (\n        \"'self'\",\n        \"'report-sample'\",\n        'data:',\n        'https://*.google-analytics.com',\n        'https://*.googletagmanager.com',\n        'https://*.google.com',\n    )\n    CSP_CONNECT_SRC = (\n        \"'self'\",\n        \"'report-sample'\",\n        'https://*.google-analytics.com',\n        'https://*.analytics.google.com',\n        'https://analytics.google.com',\n        'https://*.googletagmanager.com',\n        'https://*.g.double' + 'click.net',  # hacky way of suppressing codespell complaint\n        'https://*.ingest.sentry.io',\n    )\n    # Note that this will be overridden to real CSP for views that use the override_report_only_csp decorator\n    CSP_REPORT_ONLY = get_bool_env('LS_CSP_REPORT_ONLY', True)\n    CSP_REPORT_URI = get_env('LS_CSP_REPORT_URI', None)\n    CSP_INCLUDE_NONCE_IN = ['script-src', 'default-src']\n\n    MIDDLEWARE.append('core.middleware.HumanSignalCspMiddleware')\n\nCLOUD_STORAGE_CHECK_FOR_RECORDS_PAGE_SIZE = get_env('CLOUD_STORAGE_CHECK_FOR_RECORDS_PAGE_SIZE', 10000)\nCLOUD_STORAGE_CHECK_FOR_RECORDS_TIMEOUT = get_env('CLOUD_STORAGE_CHECK_FOR_RECORDS_TIMEOUT', 60)\n", "\"\"\"This file and its contents are licensed under the Apache License 2.0. Please see the included NOTICE for copyright information and LICENSE for a copy of the license.\n\"\"\"\nimport glob\nimport io\nimport ipaddress\nimport itertools\nimport os\nimport shutil\nimport socket\nfrom contextlib import contextmanager\nfrom tempfile import mkdtemp, mkstemp\n\nimport pkg_resources\nimport requests\nimport ujson as json\nimport yaml\nfrom appdirs import user_cache_dir, user_config_dir, user_data_dir\nfrom django.conf import settings\nfrom urllib3.util import parse_url\n\n# full path import results in unit test failures\nfrom .exceptions import InvalidUploadUrlError\n\n_DIR_APP_NAME = 'label-studio'\n\n\ndef good_path(path):\n    return os.path.abspath(os.path.expanduser(path))\n\n\ndef find_node(package_name, node_path, node_type):\n    assert node_type in ('dir', 'file', 'any')\n    basedir = pkg_resources.resource_filename(package_name, '')\n    node_path = os.path.join(*node_path.split('/'))  # linux to windows compatibility\n    search_by_path = '/' in node_path or '\\\\' in node_path\n\n    for path, dirs, filenames in os.walk(basedir):\n        if node_type == 'file':\n            nodes = filenames\n        elif node_type == 'dir':\n            nodes = dirs\n        else:\n            nodes = filenames + dirs\n        if search_by_path:\n            for found_node in nodes:\n                found_node = os.path.join(path, found_node)\n                if found_node.endswith(node_path):\n                    return found_node\n        elif node_path in nodes:\n            return os.path.join(path, node_path)\n    else:\n        raise IOError('Could not find \"%s\" at package \"%s\"' % (node_path, basedir))\n\n\ndef find_file(file):\n    return find_node('label_studio', file, 'file')\n\n\ndef find_dir(directory):\n    return find_node('label_studio', directory, 'dir')\n\n\n@contextmanager\ndef get_temp_file():\n    fd, path = mkstemp()\n    yield path\n    os.close(fd)\n\n\n@contextmanager\ndef get_temp_dir():\n    dirpath = mkdtemp()\n    yield dirpath\n    shutil.rmtree(dirpath)\n\n\ndef get_config_dir():\n    config_dir = user_config_dir(appname=_DIR_APP_NAME)\n    try:\n        os.makedirs(config_dir, exist_ok=True)\n    except OSError:\n        pass\n    return config_dir\n\n\ndef get_data_dir():\n    data_dir = user_data_dir(appname=_DIR_APP_NAME)\n    os.makedirs(data_dir, exist_ok=True)\n    return data_dir\n\n\ndef get_cache_dir():\n    cache_dir = user_cache_dir(appname=_DIR_APP_NAME)\n    os.makedirs(cache_dir, exist_ok=True)\n    return cache_dir\n\n\ndef delete_dir_content(dirpath):\n    for f in glob.glob(dirpath + '/*'):\n        remove_file_or_dir(f)\n\n\ndef remove_file_or_dir(path):\n    if os.path.isfile(path):\n        os.remove(path)\n    elif os.path.isdir(path):\n        shutil.rmtree(path)\n\n\ndef get_all_files_from_dir(d):\n    out = []\n    for name in os.listdir(d):\n        filepath = os.path.join(d, name)\n        if os.path.isfile(filepath):\n            out.append(filepath)\n    return out\n\n\ndef iter_files(root_dir, ext):\n    for root, _, files in os.walk(root_dir):\n        for f in files:\n            if f.lower().endswith(ext):\n                yield os.path.join(root, f)\n\n\ndef json_load(file, int_keys=False):\n    with io.open(file, encoding='utf8') as f:\n        data = json.load(f)\n        if int_keys:\n            return {int(k): v for k, v in data.items()}\n        else:\n            return data\n\n\ndef read_yaml(filepath):\n    if not os.path.exists(filepath):\n        filepath = find_file(filepath)\n    with io.open(filepath, encoding='utf-8') as f:\n        data = yaml.load(f, Loader=yaml.FullLoader)  # nosec\n    return data\n\n\ndef read_bytes_stream(filepath):\n    with open(filepath, mode='rb') as f:\n        return io.BytesIO(f.read())\n\n\ndef get_all_dirs_from_dir(d):\n    out = []\n    for name in os.listdir(d):\n        filepath = os.path.join(d, name)\n        if os.path.isdir(filepath):\n            out.append(filepath)\n    return out\n\n\nclass SerializableGenerator(list):\n    \"\"\"Generator that is serializable by JSON\"\"\"\n\n    def __init__(self, iterable):\n        tmp_body = iter(iterable)\n        try:\n            self._head = iter([next(tmp_body)])\n            self.append(tmp_body)\n        except StopIteration:\n            self._head = []\n\n    def __iter__(self):\n        return itertools.chain(self._head, *self[:1])\n\n\ndef validate_upload_url(url, block_local_urls=True):\n    \"\"\"Utility function for defending against SSRF attacks. Raises\n        - InvalidUploadUrlError if the url is not HTTP[S], or if block_local_urls is enabled\n          and the URL resolves to a local address.\n        - LabelStudioApiException if the hostname cannot be resolved\n\n    :param url: Url to be checked for validity/safety,\n    :param block_local_urls: Whether urls that resolve to local/private networks should be allowed.\n    \"\"\"\n\n    parsed_url = parse_url(url)\n\n    if parsed_url.scheme not in ('http', 'https'):\n        raise InvalidUploadUrlError\n\n    domain = parsed_url.host\n    try:\n        ip = socket.gethostbyname(domain)\n    except socket.error:\n        from core.utils.exceptions import LabelStudioAPIException\n\n        raise LabelStudioAPIException(f\"Can't resolve hostname {domain}\")\n\n    if block_local_urls:\n        validate_ip(ip)\n\n\ndef validate_ip(ip: str) -> None:\n    \"\"\"If settings.USE_DEFAULT_BANNED_SUBNETS is True, this function checks\n    if an IP is reserved for any of the reasons in\n    https://en.wikipedia.org/wiki/Reserved_IP_addresses\n    and raises an exception if so. Additionally, if settings.USER_ADDITIONAL_BANNED_SUBNETS\n    is set, it will also check against those subnets.\n\n    If settings.USE_DEFAULT_BANNED_SUBNETS is False, this function will only check\n    the IP against settings.USER_ADDITIONAL_BANNED_SUBNETS. Turning off the default\n    subnets is **risky** and should only be done if you know what you're doing.\n\n    :param ip: IP address to be checked.\n    \"\"\"\n\n    default_banned_subnets = [\n        '0.0.0.0/8',  # current network\n        '10.0.0.0/8',  # private network\n        '100.64.0.0/10',  # shared address space\n        '127.0.0.0/8',  # loopback\n        '169.254.0.0/16',  # link-local\n        '172.16.0.0/12',  # private network\n        '192.0.0.0/24',  # IETF protocol assignments\n        '192.0.2.0/24',  # TEST-NET-1\n        '192.88.99.0/24',  # Reserved, formerly ipv6 to ipv4 relay\n        '192.168.0.0/16',  # private network\n        '198.18.0.0/15',  # network interconnect device benchmark testing\n        '198.51.100.0/24',  # TEST-NET-2\n        '203.0.113.0/24',  # TEST-NET-3\n        '224.0.0.0/4',  # multicast\n        '233.252.0.0/24',  # MCAST-TEST-NET\n        '240.0.0.0/4',  # reserved for future use\n        '255.255.255.255/32',  # limited broadcast\n        '::/128',  # unspecified address\n        '::1/128',  # loopback\n        '::ffff:0:0/96',  # IPv4-mapped address\n        '::ffff:0:0:0/96',  # IPv4-translated address\n        '64:ff9b::/96',  # IPv4/IPv6 translation\n        '64:ff9b:1::/48',  # IPv4/IPv6 translation\n        '100::/64',  # discard prefix\n        '2001:0000::/32',  # Teredo tunneling\n        '2001:20::/28',  # ORCHIDv2\n        '2001:db8::/32',  # documentation\n        '2002::/16',  # 6to4\n        'fc00::/7',  # unique local\n        'fe80::/10',  # link-local\n        'ff00::/8',  # multicast\n    ]\n\n    banned_subnets = [\n        *(default_banned_subnets if settings.USE_DEFAULT_BANNED_SUBNETS else []),\n        *(settings.USER_ADDITIONAL_BANNED_SUBNETS or []),\n    ]\n\n    for subnet in banned_subnets:\n        if ipaddress.ip_address(ip) in ipaddress.ip_network(subnet):\n            raise InvalidUploadUrlError(f'URL resolves to a reserved network address (block: {subnet})')\n\n\ndef ssrf_safe_get(url, *args, **kwargs):\n    validate_upload_url(url, block_local_urls=settings.SSRF_PROTECTION_ENABLED)\n    # Reason for #nosec: url has been validated as SSRF safe by the\n    # validation check above.\n    response = requests.get(url, *args, **kwargs)   # nosec\n\n    # second check for SSRF for prevent redirect and dns rebinding attacks\n    if settings.SSRF_PROTECTION_ENABLED:\n        response_ip = response.raw._connection.sock.getpeername()[0]\n        validate_ip(response_ip)\n    return response\n", "from unittest import mock\nfrom unittest.mock import Mock\n\nimport pytest\nfrom core.utils.io import validate_upload_url\nfrom data_import.uploader import check_tasks_max_file_size, load_tasks\nfrom django.conf import settings\nfrom rest_framework.exceptions import ValidationError\n\npytestmark = pytest.mark.django_db\n\n\nclass MockedRequest:\n    FILES = ()\n\n    def __init__(self, url):\n        self.url = url\n\n    @property\n    def content_type(self):\n        return 'application/x-www-form-urlencoded'\n\n    @property\n    def data(self):\n        return {'url': self.url}\n\n    @property\n    def user(self):\n        return None\n\n\nclass TestUploader:\n    @pytest.fixture\n    def project(self, configured_project, settings):\n        return configured_project\n\n    class TestLoadTasks:\n        @mock.patch('core.utils.io.validate_upload_url', wraps=validate_upload_url)\n        @pytest.mark.parametrize('url', ('file:///etc/passwd', 'ftp://example.org'))\n        def test_raises_for_unsafe_urls(self, validate_upload_url_mock, url, project):\n            request = MockedRequest(url=url)\n\n            with pytest.raises(ValidationError) as e:\n                load_tasks(request, project)\n                assert 'The provided URL was not valid.' in e.value\n\n            validate_upload_url_mock.assert_called_once_with(url, block_local_urls=False)\n\n        @mock.patch('core.utils.io.validate_upload_url', wraps=validate_upload_url)\n        def test_raises_for_local_urls_with_ssrf_protection_enabled(self, validate_upload_url_mock, project, settings):\n            settings.SSRF_PROTECTION_ENABLED = True\n            request = MockedRequest(url='http://0.0.0.0')\n\n            with pytest.raises(ValidationError) as e:\n                load_tasks(request, project)\n                assert 'The provided URL was not valid.' in e.value\n\n            validate_upload_url_mock.assert_called_once_with('http://0.0.0.0', block_local_urls=True)\n\n        def test_local_url_after_redirect(self, project, settings):\n            settings.SSRF_PROTECTION_ENABLED = True\n            request = MockedRequest(url='http://validurl.com')\n\n            # Mock the necessary parts of the response object\n            mock_response = Mock()\n            mock_response.raw._connection.sock.getpeername.return_value = ('127.0.0.1', 8080)\n\n            # Patch the requests.get call in the data_import.uploader module\n            with mock.patch('core.utils.io.requests.get', return_value=mock_response), pytest.raises(\n                ValidationError\n            ) as e:\n                load_tasks(request, project)\n            assert 'URL resolves to a reserved network address (block: 127.0.0.0/8)' in str(e.value)\n\n        def test_user_specified_block(self, project, settings):\n            settings.SSRF_PROTECTION_ENABLED = True\n            settings.USER_ADDITIONAL_BANNED_SUBNETS = ['1.2.3.4']\n            request = MockedRequest(url='http://validurl.com')\n\n            # Mock the necessary parts of the response object\n            mock_response = Mock()\n            mock_response.raw._connection.sock.getpeername.return_value = ('1.2.3.4', 8080)\n\n            # Patch the requests.get call in the data_import.uploader module\n            with mock.patch('core.utils.io.requests.get', return_value=mock_response), pytest.raises(\n                ValidationError\n            ) as e:\n                load_tasks(request, project)\n            assert 'URL resolves to a reserved network address (block: 1.2.3.4)' in str(e.value)\n\n            mock_response.raw._connection.sock.getpeername.return_value = ('198.51.100.0', 8080)\n            with mock.patch('core.utils.io.requests.get', return_value=mock_response), pytest.raises(\n                ValidationError\n            ) as e:\n                load_tasks(request, project)\n            assert 'URL resolves to a reserved network address (block: 198.51.100.0/24)' in str(e.value)\n\n        def test_user_specified_block_without_default(self, project, settings):\n            settings.SSRF_PROTECTION_ENABLED = True\n            settings.USER_ADDITIONAL_BANNED_SUBNETS = ['1.2.3.4']\n            settings.USE_DEFAULT_BANNED_SUBNETS = False\n            request = MockedRequest(url='http://validurl.com')\n\n            # Mock the necessary parts of the response object\n            mock_response = Mock()\n            mock_response.raw._connection.sock.getpeername.return_value = ('1.2.3.4', 8080)\n\n            # Patch the requests.get call in the data_import.uploader module\n            with mock.patch('core.utils.io.requests.get', return_value=mock_response), pytest.raises(\n                ValidationError\n            ) as e:\n                load_tasks(request, project)\n            assert 'URL resolves to a reserved network address (block: 1.2.3.4)' in str(e.value)\n\n            mock_response.raw._connection.sock.getpeername.return_value = ('198.51.100.0', 8080)\n            with mock.patch('core.utils.io.requests.get', return_value=mock_response), pytest.raises(\n                ValidationError\n            ) as e:\n                load_tasks(request, project)\n            assert \"'Mock' object is not subscriptable\" in str(e.value)  # validate ip did not raise exception\n\n\nclass TestTasksFileChecks:\n    @pytest.mark.parametrize('value', (0, settings.TASKS_MAX_FILE_SIZE - 1))\n    def test_check_tasks_max_file_size_does_not_raise_for_correct_value(self, value):\n        check_tasks_max_file_size(value)\n\n    def test_check_tasks_max_file_size_raises_for_too_big_value(self):\n        value = settings.TASKS_MAX_FILE_SIZE + 1\n\n        with pytest.raises(ValidationError) as e:\n            check_tasks_max_file_size(value)\n\n        assert f'Maximum total size of all files is {settings.TASKS_MAX_FILE_SIZE} bytes' in str(e.value)\n"], "filenames": ["label_studio/core/settings/base.py", "label_studio/core/utils/io.py", "label_studio/tests/data_import/test_uploader.py"], "buggy_code_start_loc": [405, 200, 73], "buggy_code_end_loc": [405, 218, 74], "fixing_code_start_loc": [406, 200, 73], "fixing_code_end_loc": [408, 255, 121], "type": "CWE-918", "message": "Label Studio is a popular open source data labeling tool. The vulnerability affects all versions of Label Studio prior to 1.11.0 and was tested on version 1.8.2. Label Studio's SSRF protections that can be enabled by setting the `SSRF_PROTECTION_ENABLED` environment variable can be bypassed to access internal web servers. This is because the current SSRF validation is done by executing a single DNS lookup to verify that the IP address is not in an excluded subnet range. This protection can be bypassed by either using HTTP redirection or performing a DNS rebinding attack.", "other": {"cve": {"id": "CVE-2023-47116", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-31T17:15:13.370", "lastModified": "2024-02-09T15:37:21.887", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Label Studio is a popular open source data labeling tool. The vulnerability affects all versions of Label Studio prior to 1.11.0 and was tested on version 1.8.2. Label Studio's SSRF protections that can be enabled by setting the `SSRF_PROTECTION_ENABLED` environment variable can be bypassed to access internal web servers. This is because the current SSRF validation is done by executing a single DNS lookup to verify that the IP address is not in an excluded subnet range. This protection can be bypassed by either using HTTP redirection or performing a DNS rebinding attack."}, {"lang": "es", "value": "Label Studio es una popular herramienta de etiquetado de datos de c\u00f3digo abierto. La vulnerabilidad afecta a todas las versiones de Label Studio anteriores a la 1.11.0 y se prob\u00f3 en la versi\u00f3n 1.8.2. Las protecciones SSRF de Label Studio que se pueden habilitar configurando la variable de entorno `SSRF_PROTECTION_ENABLED` se pueden omitir para acceder a los servidores web internos. Esto se debe a que la validaci\u00f3n SSRF actual se realiza ejecutando una \u00fanica b\u00fasqueda de DNS para verificar que la direcci\u00f3n IP no est\u00e9 en un rango de subred excluido. Esta protecci\u00f3n se puede omitir utilizando la redirecci\u00f3n HTTP o realizando un ataque de vinculaci\u00f3n de DNS."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:humansignal:label_studio:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.11.0", "matchCriteriaId": "27567917-A7FB-4767-B9F6-6C8D422D62E7"}]}]}], "references": [{"url": "https://github.com/HumanSignal/label-studio/commit/55dd6af4716b92f2bb213fe461d1ffbc380c6a64", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/HumanSignal/label-studio/releases/tag/1.11.0", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/HumanSignal/label-studio/security/advisories/GHSA-p59w-9gqw-wj8r", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/HumanSignal/label-studio/commit/55dd6af4716b92f2bb213fe461d1ffbc380c6a64"}}