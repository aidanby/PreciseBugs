{"buggy_code": ["---\nid: errors\ntitle: Errors\n---\n\nThis is a list of errors output from NextAuth.js.\n\nAll errors indicate an unexpected problem, you should not expect to see errors.\n\nIf you are seeing any of these errors in the console, something is wrong.\n\n---\n\n## Client\n\nThese errors are returned from the client. As the client is [Universal JavaScript (or \"Isomorphic JavaScript\")](https://en.wikipedia.org/wiki/Isomorphic_JavaScript) it can be run on the client or server, so these errors can occur both in the terminal and in the browser console.\n\n#### CLIENT_SESSION_ERROR\n\nThis error occurs when the `SessionProvider` Context has a problem fetching session data.\n\n#### CLIENT_FETCH_ERROR\n\nIf you see `CLIENT_FETCH_ERROR` make sure you have configured the `NEXTAUTH_URL` environment variable.\n\n---\n\n## Server\n\nThese errors are displayed on the terminal.\n\n### OAuth\n\n#### OAUTH_GET_ACCESS_TOKEN_ERROR\n\nThis occurs when there was an error in the POST request to the OAuth provider and we were not able to retrieve the access token.\n\nPlease double check your provider settings.\n\n#### OAUTH_V1_GET_ACCESS_TOKEN_ERROR\n\nThis error is explicitly related to older OAuth v1.x providers, if you are using one of these, please double check all available settings.\n\n#### OAUTH_GET_PROFILE_ERROR\n\nN/A\n\n#### OAUTH_PARSE_PROFILE_ERROR\n\nThis error is a result of either a problem with the provider response or the user canceling the action with the provider, unfortunately, we can't discern which with the information we have.\n\nThis error should also log the exception and available `profileData` to further aid debugging.\n\n#### OAUTH_CALLBACK_HANDLER_ERROR\n\nThis error will occur when there was an issue parsing the JSON request body, for example.\n\nThere should also be further details logged when this occurs, such as the error is thrown, and the request body itself to aid in debugging.\n\n---\n\n### Signin / Callback\n\n#### GET_AUTHORIZATION_URL_ERROR\n\nThis error can occur when we cannot get the OAuth v1 request token and generate the authorization URL.\n\nPlease double check your OAuth v1 provider settings, especially the OAuth token and OAuth token secret.\n\n#### SIGNIN_OAUTH_ERROR\n\nThis error can occur in one of a few places, first during the redirect to the authorization URL of the provider. Next, in the signin flow while creating the PKCE code verifier. Finally, during the generation of the CSRF Token hash in the internal state during signin.\n\nPlease check your OAuth provider settings and make sure your URLs and other options are correctly set on the provider side.\n\n#### CALLBACK_OAUTH_ERROR\n\nThis can occur during the handling of the callback if the `code_verifier` cookie was not found or an invalid state was returned from the OAuth provider.\n\n#### SIGNIN_EMAIL_ERROR\n\nThis error can occur when a user tries to sign in via an email link; for example, if the email token could not be generated or the verification request failed.\n\nPlease double check your email settings.\n\n#### CALLBACK_EMAIL_ERROR\n\nThis can occur during the email callback process. Specifically, if there was an error signing the user in via email, encoding the jwt, etc.\n\nPlease double check your Email settings.\n\n#### EMAIL_REQUIRES_ADAPTER_ERROR\n\nThe Email authentication provider can only be used if a database is configured.\n\nThis is required to store the verification token. Please see the [email provider](/providers/email#configuration) for more details.\n\n#### CALLBACK_CREDENTIALS_JWT_ERROR\n\nThe Credentials Provider can only be used if JSON Web Tokens are used for sessions.\n\nJSON Web Tokens are used for Sessions by default if you have not specified a database. However, if you are using a database, then Database Sessions are enabled by default and you need to [explicitly enable JWT Sessions](https://next-auth.js.org/configuration/options#session) to use the Credentials Provider.\n\nIf you are using a Credentials Provider, NextAuth.js will not persist users or sessions in a database - user accounts used with the Credentials Provider must be created and managed outside of NextAuth.js.\n\nIn _most cases_ it does not make sense to specify a database in NextAuth.js options and support a Credentials Provider.\n\n#### CALLBACK_CREDENTIALS_HANDLER_ERROR\n\nThis error occurs when there was no `authorize()` handler defined on the credential authentication provider.\n\n#### PKCE_ERROR\n\nThe provider you tried to use failed when setting [PKCE or Proof Key for Code Exchange](https://tools.ietf.org/html/rfc7636#section-4).\nThe `code_verifier` is saved in a cookie called (by default) `__Secure-next-auth.pkce.code_verifier` which expires after 15 minutes.\nCheck if `cookies.pkceCodeVerifier` is configured correctly.\n\nThe default `code_challenge_method` is `\"S256\"`. This is currently not configurable to `\"plain\"`, [as per RFC7636](https://datatracker.ietf.org/doc/html/rfc7636#section-4.2): \n> If the client is capable of using \"S256\", it MUST use \"S256\", as\n  S256\" is Mandatory To Implement (MTI) on the server.\n\n---\n\n### Session Handling\n\n#### JWT_SESSION_ERROR\n\nhttps://next-auth.js.org/errors#jwt_session_error JWKKeySupport: the key does not support HS512 verify algorithm\n\nThe algorithm used for generating your key isn't listed as supported. You can generate a HS512 key using\n\n```\n  jose newkey -s 512 -t oct -a HS512\n```\n\n#### SESSION_ERROR\n\n---\n\n### Signout\n\n#### SIGNOUT_ERROR\n\nThis error occurs when there was an issue deleting the session from the database, for example.\n\n---\n\n### Other\n\n#### SEND_VERIFICATION_EMAIL_ERROR\n\nThis error occurs when the Email Authentication Provider is unable to send an email.\n\nCheck your mail server configuration.\n\n#### MISSING_NEXTAUTH_API_ROUTE_ERROR\n\nThis error happens when `[...nextauth].js` file is not found inside `pages/api/auth`.\n\nMake sure the file is there and the filename is written correctly.\n\n#### NO_SECRET\n\nIn production, we expect you to define a `secret` property in your configuration. In development, this is shown as a warning for convenience. [Read more](https://next-auth.js.org/configuration/options#secret)\n\n#### oauth_callback_error expected 200 OK with body but no body was returned\n\nThis error might happen with some of the providers. It happens due to `openid-client`(which is peer dependency) node version mismatch. For instance, `openid-client` requires `>=14.2.0` for `lts/fermium` and has similar limits for the other versions. For the full list of the compatible node versions please see [package.json](https://github.com/panva/node-openid-client/blob/2a84e46992e1ebeaf685c3f87b65663d126e81aa/package.json#L78)\n", "import type { EventCallbacks, LoggerInstance } from \"..\"\nimport type { Adapter } from \"../adapters\"\n\n/**\n * Same as the default `Error`, but it is JSON serializable.\n * @source https://iaincollins.medium.com/error-handling-in-javascript-a6172ccdf9af\n */\nexport class UnknownError extends Error {\n  code: string\n  constructor(error: Error | string) {\n    // Support passing error or string\n    super((error as Error)?.message ?? error)\n    this.name = \"UnknownError\"\n    this.code = (error as any).code\n    if (error instanceof Error) {\n      this.stack = error.stack\n    }\n  }\n\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n    }\n  }\n}\n\nexport class OAuthCallbackError extends UnknownError {\n  name = \"OAuthCallbackError\"\n}\n\n/**\n * Thrown when an Email address is already associated with an account\n * but the user is trying an OAuth account that is not linked to it.\n */\nexport class AccountNotLinkedError extends UnknownError {\n  name = \"AccountNotLinkedError\"\n}\n\nexport class MissingAPIRoute extends UnknownError {\n  name = \"MissingAPIRouteError\"\n  code = \"MISSING_NEXTAUTH_API_ROUTE_ERROR\"\n}\n\nexport class MissingSecret extends UnknownError {\n  name = \"MissingSecretError\"\n  code = \"NO_SECRET\"\n}\n\nexport class MissingAuthorize extends UnknownError {\n  name = \"MissingAuthorizeError\"\n  code = \"CALLBACK_CREDENTIALS_HANDLER_ERROR\"\n}\n\nexport class MissingAdapter extends UnknownError {\n  name = \"MissingAdapterError\"\n  code = \"EMAIL_REQUIRES_ADAPTER_ERROR\"\n}\n\nexport class UnsupportedStrategy extends UnknownError {\n  name = \"UnsupportedStrategyError\"\n  code = \"CALLBACK_CREDENTIALS_JWT_ERROR\"\n}\n\ntype Method = (...args: any[]) => Promise<any>\n\nexport function upperSnake(s: string) {\n  return s.replace(/([A-Z])/g, \"_$1\").toUpperCase()\n}\n\nexport function capitalize(s: string) {\n  return `${s[0].toUpperCase()}${s.slice(1)}`\n}\n\n/**\n * Wraps an object of methods and adds error handling.\n */\nexport function eventsErrorHandler(\n  methods: Partial<EventCallbacks>,\n  logger: LoggerInstance\n): Partial<EventCallbacks> {\n  return Object.keys(methods).reduce<any>((acc, name) => {\n    acc[name] = async (...args: any[]) => {\n      try {\n        const method: Method = methods[name as keyof Method]\n        return await method(...args)\n      } catch (e) {\n        logger.error(`${upperSnake(name)}_EVENT_ERROR`, e as Error)\n      }\n    }\n    return acc\n  }, {})\n}\n\n/** Handles adapter induced errors. */\nexport function adapterErrorHandler(\n  adapter: Adapter | undefined,\n  logger: LoggerInstance\n): Adapter | undefined {\n  if (!adapter) return\n\n  return Object.keys(adapter).reduce<any>((acc, name) => {\n    acc[name] = async (...args: any[]) => {\n      try {\n        logger.debug(`adapter_${name}`, { args })\n        const method: Method = adapter[name as keyof Method]\n        return await method(...args)\n      } catch (error) {\n        logger.error(`adapter_error_${name}`, error as Error)\n        const e = new UnknownError(error as Error)\n        e.name = `${capitalize(name)}Error`\n        throw e\n      }\n    }\n    return acc\n  }, {})\n}\n", "import logger, { setLogger } from \"../lib/logger\"\nimport * as routes from \"./routes\"\nimport renderPage from \"./pages\"\nimport { init } from \"./init\"\nimport { assertConfig } from \"./lib/assert\"\nimport { SessionStore } from \"./lib/cookie\"\n\nimport type { NextAuthOptions } from \"./types\"\nimport type { NextAuthAction } from \"../lib/types\"\nimport type { Cookie } from \"./lib/cookie\"\nimport type { ErrorType } from \"./pages/error\"\n\nexport interface IncomingRequest {\n  /** @default \"http://localhost:3000\" */\n  host?: string\n  method?: string\n  cookies?: Record<string, string>\n  headers?: Record<string, any>\n  query?: Record<string, any>\n  body?: Record<string, any>\n  action: NextAuthAction\n  providerId?: string\n  error?: string\n}\n\nexport interface NextAuthHeader {\n  key: string\n  value: string\n}\n\nexport interface OutgoingResponse<\n  Body extends string | Record<string, any> | any[] = any\n> {\n  status?: number\n  headers?: NextAuthHeader[]\n  body?: Body\n  redirect?: string\n  cookies?: Cookie[]\n}\n\nexport interface NextAuthHandlerParams {\n  req: IncomingRequest\n  options: NextAuthOptions\n}\n\nexport async function NextAuthHandler<\n  Body extends string | Record<string, any> | any[]\n>(params: NextAuthHandlerParams): Promise<OutgoingResponse<Body>> {\n  const { options: userOptions, req } = params\n\n  setLogger(userOptions.logger, userOptions.debug)\n\n  const assertionResult = assertConfig(params)\n\n  if (typeof assertionResult === \"string\") {\n    logger.warn(assertionResult)\n  } else if (assertionResult instanceof Error) {\n    // Bail out early if there's an error in the user config\n    const { pages, theme } = userOptions\n    logger.error(assertionResult.code, assertionResult)\n    if (pages?.error) {\n      return {\n        redirect: `${pages.error}?error=Configuration`,\n      }\n    }\n    const render = renderPage({ theme })\n    return render.error({ error: \"configuration\" })\n  }\n\n  const { action, providerId, error, method = \"GET\" } = req\n\n  const { options, cookies } = await init({\n    userOptions,\n    action,\n    providerId,\n    host: req.host,\n    callbackUrl: req.body?.callbackUrl ?? req.query?.callbackUrl,\n    csrfToken: req.body?.csrfToken,\n    cookies: req.cookies,\n    isPost: method === \"POST\",\n  })\n\n  const sessionStore = new SessionStore(\n    options.cookies.sessionToken,\n    req,\n    options.logger\n  )\n\n  if (method === \"GET\") {\n    const render = renderPage({ ...options, query: req.query, cookies })\n    const { pages } = options\n    switch (action) {\n      case \"providers\":\n        return (await routes.providers(options.providers)) as any\n      case \"session\": {\n        const session = await routes.session({ options, sessionStore })\n        if (session.cookies) cookies.push(...session.cookies)\n        return { ...session, cookies } as any\n      }\n      case \"csrf\":\n        return {\n          headers: [{ key: \"Content-Type\", value: \"application/json\" }],\n          body: { csrfToken: options.csrfToken } as any,\n          cookies,\n        }\n      case \"signin\":\n        if (pages.signIn) {\n          let signinUrl = `${pages.signIn}${\n            pages.signIn.includes(\"?\") ? \"&\" : \"?\"\n          }callbackUrl=${encodeURIComponent(options.callbackUrl)}`\n          if (error) signinUrl = `${signinUrl}&error=${encodeURIComponent(error)}`\n          return { redirect: signinUrl, cookies }\n        }\n\n        return render.signin()\n      case \"signout\":\n        if (pages.signOut) return { redirect: pages.signOut, cookies }\n\n        return render.signout()\n      case \"callback\":\n        if (options.provider) {\n          const callback = await routes.callback({\n            body: req.body,\n            query: req.query,\n            headers: req.headers,\n            cookies: req.cookies,\n            method,\n            options,\n            sessionStore,\n          })\n          if (callback.cookies) cookies.push(...callback.cookies)\n          return { ...callback, cookies }\n        }\n        break\n      case \"verify-request\":\n        if (pages.verifyRequest) {\n          return { redirect: pages.verifyRequest, cookies }\n        }\n        return render.verifyRequest()\n      case \"error\":\n        // These error messages are displayed in line on the sign in page\n        if (\n          [\n            \"Signin\",\n            \"OAuthSignin\",\n            \"OAuthCallback\",\n            \"OAuthCreateAccount\",\n            \"EmailCreateAccount\",\n            \"Callback\",\n            \"OAuthAccountNotLinked\",\n            \"EmailSignin\",\n            \"CredentialsSignin\",\n            \"SessionRequired\",\n          ].includes(error as string)\n        ) {\n          return { redirect: `${options.url}/signin?error=${error}`, cookies }\n        }\n\n        if (pages.error) {\n          return {\n            redirect: `${pages.error}${\n              pages.error.includes(\"?\") ? \"&\" : \"?\"\n            }error=${error}`,\n            cookies,\n          }\n        }\n\n        return render.error({ error: error as ErrorType })\n      default:\n    }\n  } else if (method === \"POST\") {\n    switch (action) {\n      case \"signin\":\n        // Verified CSRF Token required for all sign in routes\n        if (options.csrfTokenVerified && options.provider) {\n          const signin = await routes.signin({\n            query: req.query,\n            body: req.body,\n            options,\n          })\n          if (signin.cookies) cookies.push(...signin.cookies)\n          return { ...signin, cookies }\n        }\n\n        return { redirect: `${options.url}/signin?csrf=true`, cookies }\n      case \"signout\":\n        // Verified CSRF Token required for signout\n        if (options.csrfTokenVerified) {\n          const signout = await routes.signout({ options, sessionStore })\n          if (signout.cookies) cookies.push(...signout.cookies)\n          return { ...signout, cookies }\n        }\n        return { redirect: `${options.url}/signout?csrf=true`, cookies }\n      case \"callback\":\n        if (options.provider) {\n          // Verified CSRF Token required for credentials providers only\n          if (\n            options.provider.type === \"credentials\" &&\n            !options.csrfTokenVerified\n          ) {\n            return { redirect: `${options.url}/signin?csrf=true`, cookies }\n          }\n\n          const callback = await routes.callback({\n            body: req.body,\n            query: req.query,\n            headers: req.headers,\n            cookies: req.cookies,\n            method,\n            options,\n            sessionStore,\n          })\n          if (callback.cookies) cookies.push(...callback.cookies)\n          return { ...callback, cookies }\n        }\n        break\n      case \"_log\":\n        if (userOptions.logger) {\n          try {\n            const { code, level, ...metadata } = req.body ?? {}\n            logger[level](code, metadata)\n          } catch (error) {\n            // If logging itself failed...\n            logger.error(\"LOGGER_ERROR\", error as Error)\n          }\n        }\n        return {}\n      default:\n    }\n  }\n\n  return {\n    status: 400,\n    body: `Error: This action with HTTP ${method} is not supported by NextAuth.js` as any,\n  }\n}\n", "import {\n  MissingAdapter,\n  MissingAPIRoute,\n  MissingAuthorize,\n  MissingSecret,\n  UnsupportedStrategy,\n} from \"../errors\"\n\nimport type { NextAuthHandlerParams } from \"..\"\nimport type { WarningCode } from \"../../lib/logger\"\n\ntype ConfigError =\n  | MissingAPIRoute\n  | MissingSecret\n  | UnsupportedStrategy\n  | MissingAuthorize\n  | MissingAdapter\n\nlet twitterWarned = false\n\n/**\n * Verify that the user configured `next-auth` correctly.\n * Good place to mention deprecations as well.\n *\n * REVIEW: Make some of these and corresponding docs less Next.js specific?\n */\nexport function assertConfig(\n  params: NextAuthHandlerParams\n): ConfigError | WarningCode | undefined {\n  const { options, req } = params\n\n  // req.query isn't defined when asserting `getServerSession` for example\n  if (!req.query?.nextauth && !req.action) {\n    return new MissingAPIRoute(\n      \"Cannot find [...nextauth].{js,ts} in `/pages/api/auth`. Make sure the filename is written correctly.\"\n    )\n  }\n\n  if (!options.secret) {\n    if (process.env.NODE_ENV === \"production\") {\n      return new MissingSecret(\"Please define a `secret` in production.\")\n    } else {\n      return \"NO_SECRET\"\n    }\n  }\n\n  if (!req.host) return \"NEXTAUTH_URL\"\n\n  let hasCredentials, hasEmail\n  let hasTwitterOAuth2\n\n  for (const provider of options.providers) {\n    if (provider.type === \"credentials\") hasCredentials = true\n    else if (provider.type === \"email\") hasEmail = true\n    else if (provider.id === \"twitter\" && provider.version === \"2.0\")\n      hasTwitterOAuth2 = true\n  }\n\n  if (hasCredentials) {\n    const dbStrategy = options.session?.strategy === \"database\"\n    const onlyCredentials = !options.providers.some(\n      (p) => p.type !== \"credentials\"\n    )\n    if (dbStrategy && onlyCredentials) {\n      return new UnsupportedStrategy(\n        \"Signin in with credentials only supported if JWT strategy is enabled\"\n      )\n    }\n\n    const credentialsNoAuthorize = options.providers.some(\n      (p) => p.type === \"credentials\" && !p.authorize\n    )\n    if (credentialsNoAuthorize) {\n      return new MissingAuthorize(\n        \"Must define an authorize() handler to use credentials authentication provider\"\n      )\n    }\n  }\n\n  if (hasEmail && !options.adapter) {\n    return new MissingAdapter(\"E-mail login requires an adapter.\")\n  }\n\n  if (!twitterWarned && hasTwitterOAuth2) {\n    twitterWarned = true\n    return \"TWITTER_OAUTH_2_BETA\"\n  }\n}\n", "import type { IncomingHttpHeaders } from \"http\"\nimport type { CookiesOptions } from \"../..\"\nimport type { CookieOption, LoggerInstance, SessionStrategy } from \"../types\"\n\n// Uncomment to recalculate the estimated size\n// of an empty session cookie\n// import { serialize } from \"cookie\"\n// console.log(\n//   \"Cookie estimated to be \",\n//   serialize(`__Secure.next-auth.session-token.0`, \"\", {\n//     expires: new Date(),\n//     httpOnly: true,\n//     maxAge: Number.MAX_SAFE_INTEGER,\n//     path: \"/\",\n//     sameSite: \"strict\",\n//     secure: true,\n//     domain: \"example.com\",\n//   }).length,\n//   \" bytes\"\n// )\n\nconst ALLOWED_COOKIE_SIZE = 4096\n// Based on commented out section above\nconst ESTIMATED_EMPTY_COOKIE_SIZE = 163\nconst CHUNK_SIZE = ALLOWED_COOKIE_SIZE - ESTIMATED_EMPTY_COOKIE_SIZE\n\n// REVIEW: Is there any way to defer two types of strings?\n\n/** Stringified form of `JWT`. Extract the content with `jwt.decode` */\nexport type JWTString = string\n\nexport type SetCookieOptions = Partial<CookieOption[\"options\"]> & {\n  expires?: Date | string\n  encode?: (val: unknown) => string\n}\n\n/**\n * If `options.session.strategy` is set to `jwt`, this is a stringified `JWT`.\n * In case of `strategy: \"database\"`, this is the `sessionToken` of the session in the database.\n */\nexport type SessionToken<T extends SessionStrategy = \"jwt\"> = T extends \"jwt\"\n  ? JWTString\n  : string\n\n/**\n * Use secure cookies if the site uses HTTPS\n * This being conditional allows cookies to work non-HTTPS development URLs\n * Honour secure cookie option, which sets 'secure' and also adds '__Secure-'\n * prefix, but enable them by default if the site URL is HTTPS; but not for\n * non-HTTPS URLs like http://localhost which are used in development).\n * For more on prefixes see https://googlechrome.github.io/samples/cookie-prefixes/\n *\n * @TODO Review cookie settings (names, options)\n */\nexport function defaultCookies(useSecureCookies: boolean): CookiesOptions {\n  const cookiePrefix = useSecureCookies ? \"__Secure-\" : \"\"\n  return {\n    // default cookie options\n    sessionToken: {\n      name: `${cookiePrefix}next-auth.session-token`,\n      options: {\n        httpOnly: true,\n        sameSite: \"lax\",\n        path: \"/\",\n        secure: useSecureCookies,\n      },\n    },\n    callbackUrl: {\n      name: `${cookiePrefix}next-auth.callback-url`,\n      options: {\n        sameSite: \"lax\",\n        path: \"/\",\n        secure: useSecureCookies,\n      },\n    },\n    csrfToken: {\n      // Default to __Host- for CSRF token for additional protection if using useSecureCookies\n      // NB: The `__Host-` prefix is stricter than the `__Secure-` prefix.\n      name: `${useSecureCookies ? \"__Host-\" : \"\"}next-auth.csrf-token`,\n      options: {\n        httpOnly: true,\n        sameSite: \"lax\",\n        path: \"/\",\n        secure: useSecureCookies,\n      },\n    },\n    pkceCodeVerifier: {\n      name: `${cookiePrefix}next-auth.pkce.code_verifier`,\n      options: {\n        httpOnly: true,\n        sameSite: \"lax\",\n        path: \"/\",\n        secure: useSecureCookies,\n      },\n    },\n    state: {\n      name: `${cookiePrefix}next-auth.state`,\n      options: {\n        httpOnly: true,\n        sameSite: \"lax\",\n        path: \"/\",\n        secure: useSecureCookies,\n      },\n    },\n  }\n}\n\nexport interface Cookie extends CookieOption {\n  value: string\n}\n\ntype Chunks = Record<string, string>\n\nexport class SessionStore {\n  #chunks: Chunks = {}\n  #option: CookieOption\n  #logger: LoggerInstance | Console\n\n  constructor(\n    option: CookieOption,\n    req: {\n      cookies?: Record<string, string>\n      headers?: Headers | IncomingHttpHeaders | Record<string, string>\n    },\n    logger: LoggerInstance | Console\n  ) {\n    this.#logger = logger\n    this.#option = option\n\n    if (!req) return\n\n    for (const name in req.cookies) {\n      if (name.startsWith(option.name)) {\n        this.#chunks[name] = req.cookies[name]\n      }\n    }\n  }\n\n  get value() {\n    return Object.values(this.#chunks)?.join(\"\")\n  }\n\n  /** Given a cookie, return a list of cookies, chunked to fit the allowed cookie size. */\n  #chunk(cookie: Cookie): Cookie[] {\n    const chunkCount = Math.ceil(cookie.value.length / CHUNK_SIZE)\n\n    if (chunkCount === 1) {\n      this.#chunks[cookie.name] = cookie.value\n      return [cookie]\n    }\n\n    const cookies: Cookie[] = []\n    for (let i = 0; i < chunkCount; i++) {\n      const name = `${cookie.name}.${i}`\n      const value = cookie.value.substr(i * CHUNK_SIZE, CHUNK_SIZE)\n      cookies.push({ ...cookie, name, value })\n      this.#chunks[name] = value\n    }\n\n    this.#logger.debug(\"CHUNKING_SESSION_COOKIE\", {\n      message: `Session cookie exceeds allowed ${ALLOWED_COOKIE_SIZE} bytes.`,\n      emptyCookieSize: ESTIMATED_EMPTY_COOKIE_SIZE,\n      valueSize: cookie.value.length,\n      chunks: cookies.map((c) => c.value.length + ESTIMATED_EMPTY_COOKIE_SIZE),\n    })\n\n    return cookies\n  }\n\n  /** Returns cleaned cookie chunks. */\n  #clean(): Record<string, Cookie> {\n    const cleanedChunks: Record<string, Cookie> = {}\n    for (const name in this.#chunks) {\n      delete this.#chunks?.[name]\n      cleanedChunks[name] = {\n        name,\n        value: \"\",\n        options: { ...this.#option.options, maxAge: 0 },\n      }\n    }\n    return cleanedChunks\n  }\n\n  /**\n   * Given a cookie value, return new cookies, chunked, to fit the allowed cookie size.\n   * If the cookie has changed from chunked to unchunked or vice versa,\n   * it deletes the old cookies as well.\n   */\n  chunk(value: string, options: Partial<Cookie[\"options\"]>): Cookie[] {\n    // Assume all cookies should be cleaned by default\n    const cookies: Record<string, Cookie> = this.#clean()\n\n    // Calculate new chunks\n    const chunked = this.#chunk({\n      name: this.#option.name,\n      value,\n      options: { ...this.#option.options, ...options },\n    })\n\n    // Update stored chunks / cookies\n    for (const chunk of chunked) {\n      cookies[chunk.name] = chunk\n    }\n\n    return Object.values(cookies)\n  }\n\n  /** Returns a list of cookies that should be cleaned. */\n  clean(): Cookie[] {\n    return Object.values(this.#clean())\n  }\n}\n"], "fixing_code": ["---\nid: errors\ntitle: Errors\n---\n\nThis is a list of errors output from NextAuth.js.\n\nAll errors indicate an unexpected problem, you should not expect to see errors.\n\nIf you are seeing any of these errors in the console, something is wrong.\n\n---\n\n## Client\n\nThese errors are returned from the client. As the client is [Universal JavaScript (or \"Isomorphic JavaScript\")](https://en.wikipedia.org/wiki/Isomorphic_JavaScript) it can be run on the client or server, so these errors can occur both in the terminal and in the browser console.\n\n#### CLIENT_SESSION_ERROR\n\nThis error occurs when the `SessionProvider` Context has a problem fetching session data.\n\n#### CLIENT_FETCH_ERROR\n\nIf you see `CLIENT_FETCH_ERROR` make sure you have configured the `NEXTAUTH_URL` environment variable.\n\n---\n\n## Server\n\nThese errors are displayed on the terminal.\n\n### OAuth\n\n#### OAUTH_GET_ACCESS_TOKEN_ERROR\n\nThis occurs when there was an error in the POST request to the OAuth provider and we were not able to retrieve the access token.\n\nPlease double check your provider settings.\n\n#### OAUTH_V1_GET_ACCESS_TOKEN_ERROR\n\nThis error is explicitly related to older OAuth v1.x providers, if you are using one of these, please double check all available settings.\n\n#### OAUTH_GET_PROFILE_ERROR\n\nN/A\n\n#### OAUTH_PARSE_PROFILE_ERROR\n\nThis error is a result of either a problem with the provider response or the user canceling the action with the provider, unfortunately, we can't discern which with the information we have.\n\nThis error should also log the exception and available `profileData` to further aid debugging.\n\n#### OAUTH_CALLBACK_HANDLER_ERROR\n\nThis error will occur when there was an issue parsing the JSON request body, for example.\n\nThere should also be further details logged when this occurs, such as the error is thrown, and the request body itself to aid in debugging.\n\n---\n\n### Signin / Callback\n\n#### GET_AUTHORIZATION_URL_ERROR\n\nThis error can occur when we cannot get the OAuth v1 request token and generate the authorization URL.\n\nPlease double check your OAuth v1 provider settings, especially the OAuth token and OAuth token secret.\n\n#### SIGNIN_OAUTH_ERROR\n\nThis error can occur in one of a few places, first during the redirect to the authorization URL of the provider. Next, in the signin flow while creating the PKCE code verifier. Finally, during the generation of the CSRF Token hash in the internal state during signin.\n\nPlease check your OAuth provider settings and make sure your URLs and other options are correctly set on the provider side.\n\n#### CALLBACK_OAUTH_ERROR\n\nThis can occur during the handling of the callback if the `code_verifier` cookie was not found or an invalid state was returned from the OAuth provider.\n\n#### SIGNIN_EMAIL_ERROR\n\nThis error can occur when a user tries to sign in via an email link; for example, if the email token could not be generated or the verification request failed.\n\nPlease double check your email settings.\n\n#### CALLBACK_EMAIL_ERROR\n\nThis can occur during the email callback process. Specifically, if there was an error signing the user in via email, encoding the jwt, etc.\n\nPlease double check your Email settings.\n\n#### EMAIL_REQUIRES_ADAPTER_ERROR\n\nThe Email authentication provider can only be used if a database is configured.\n\nThis is required to store the verification token. Please see the [email provider](/providers/email#configuration) for more details.\n\n#### CALLBACK_CREDENTIALS_JWT_ERROR\n\nThe Credentials Provider can only be used if JSON Web Tokens are used for sessions.\n\nJSON Web Tokens are used for Sessions by default if you have not specified a database. However, if you are using a database, then Database Sessions are enabled by default and you need to [explicitly enable JWT Sessions](/configuration/options#session) to use the Credentials Provider.\n\nIf you are using a Credentials Provider, NextAuth.js will not persist users or sessions in a database - user accounts used with the Credentials Provider must be created and managed outside of NextAuth.js.\n\nIn _most cases_ it does not make sense to specify a database in NextAuth.js options and support a Credentials Provider.\n\n#### CALLBACK_CREDENTIALS_HANDLER_ERROR\n\nThis error occurs when there was no `authorize()` handler defined on the credential authentication provider.\n\n#### PKCE_ERROR\n\nThe provider you tried to use failed when setting [PKCE or Proof Key for Code Exchange](https://tools.ietf.org/html/rfc7636#section-4).\nThe `code_verifier` is saved in a cookie called (by default) `__Secure-next-auth.pkce.code_verifier` which expires after 15 minutes.\nCheck if `cookies.pkceCodeVerifier` is configured correctly.\n\nThe default `code_challenge_method` is `\"S256\"`. This is currently not configurable to `\"plain\"`, [as per RFC7636](https://datatracker.ietf.org/doc/html/rfc7636#section-4.2): \n> If the client is capable of using \"S256\", it MUST use \"S256\", as\n  S256\" is Mandatory To Implement (MTI) on the server.\n\n#### INVALID_CALLBACK_URL_ERROR\n\nThe `callbackUrl` provided was either invalid or not defined. See [specifying a `callbackUrl`](/getting-started/client#specifying-a-callbackurl) for more information.\n\n---\n\n### Session Handling\n\n#### JWT_SESSION_ERROR\n\nJWKKeySupport: the key does not support HS512 verify algorithm\n\nThe algorithm used for generating your key isn't listed as supported. You can generate a HS512 key using\n\n```\n  jose newkey -s 512 -t oct -a HS512\n```\n\n#### SESSION_ERROR\n\n---\n\n### Signout\n\n#### SIGNOUT_ERROR\n\nThis error occurs when there was an issue deleting the session from the database, for example.\n\n---\n\n### Other\n\n#### SEND_VERIFICATION_EMAIL_ERROR\n\nThis error occurs when the Email Authentication Provider is unable to send an email.\n\nCheck your mail server configuration.\n\n#### MISSING_NEXTAUTH_API_ROUTE_ERROR\n\nThis error happens when `[...nextauth].js` file is not found inside `pages/api/auth`.\n\nMake sure the file is there and the filename is written correctly.\n\n#### NO_SECRET\n\nIn production, we expect you to define a `secret` property in your configuration. In development, this is shown as a warning for convenience. [Read more](/configuration/options#secret)\n\n#### oauth_callback_error expected 200 OK with body but no body was returned\n\nThis error might happen with some of the providers. It happens due to `openid-client`(which is peer dependency) node version mismatch. For instance, `openid-client` requires `>=14.2.0` for `lts/fermium` and has similar limits for the other versions. For the full list of the compatible node versions please see [package.json](https://github.com/panva/node-openid-client/blob/2a84e46992e1ebeaf685c3f87b65663d126e81aa/package.json#L78)\n", "import type { EventCallbacks, LoggerInstance } from \"..\"\nimport type { Adapter } from \"../adapters\"\n\n/**\n * Same as the default `Error`, but it is JSON serializable.\n * @source https://iaincollins.medium.com/error-handling-in-javascript-a6172ccdf9af\n */\nexport class UnknownError extends Error {\n  code: string\n  constructor(error: Error | string) {\n    // Support passing error or string\n    super((error as Error)?.message ?? error)\n    this.name = \"UnknownError\"\n    this.code = (error as any).code\n    if (error instanceof Error) {\n      this.stack = error.stack\n    }\n  }\n\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n    }\n  }\n}\n\nexport class OAuthCallbackError extends UnknownError {\n  name = \"OAuthCallbackError\"\n}\n\n/**\n * Thrown when an Email address is already associated with an account\n * but the user is trying an OAuth account that is not linked to it.\n */\nexport class AccountNotLinkedError extends UnknownError {\n  name = \"AccountNotLinkedError\"\n}\n\nexport class MissingAPIRoute extends UnknownError {\n  name = \"MissingAPIRouteError\"\n  code = \"MISSING_NEXTAUTH_API_ROUTE_ERROR\"\n}\n\nexport class MissingSecret extends UnknownError {\n  name = \"MissingSecretError\"\n  code = \"NO_SECRET\"\n}\n\nexport class MissingAuthorize extends UnknownError {\n  name = \"MissingAuthorizeError\"\n  code = \"CALLBACK_CREDENTIALS_HANDLER_ERROR\"\n}\n\nexport class MissingAdapter extends UnknownError {\n  name = \"MissingAdapterError\"\n  code = \"EMAIL_REQUIRES_ADAPTER_ERROR\"\n}\n\nexport class UnsupportedStrategy extends UnknownError {\n  name = \"UnsupportedStrategyError\"\n  code = \"CALLBACK_CREDENTIALS_JWT_ERROR\"\n}\n\nexport class InvalidCallbackUrl extends UnknownError {\n  name = \"InvalidCallbackUrl\"\n  code = \"INVALID_CALLBACK_URL_ERROR\"\n}\n\ntype Method = (...args: any[]) => Promise<any>\n\nexport function upperSnake(s: string) {\n  return s.replace(/([A-Z])/g, \"_$1\").toUpperCase()\n}\n\nexport function capitalize(s: string) {\n  return `${s[0].toUpperCase()}${s.slice(1)}`\n}\n\n/**\n * Wraps an object of methods and adds error handling.\n */\nexport function eventsErrorHandler(\n  methods: Partial<EventCallbacks>,\n  logger: LoggerInstance\n): Partial<EventCallbacks> {\n  return Object.keys(methods).reduce<any>((acc, name) => {\n    acc[name] = async (...args: any[]) => {\n      try {\n        const method: Method = methods[name as keyof Method]\n        return await method(...args)\n      } catch (e) {\n        logger.error(`${upperSnake(name)}_EVENT_ERROR`, e as Error)\n      }\n    }\n    return acc\n  }, {})\n}\n\n/** Handles adapter induced errors. */\nexport function adapterErrorHandler(\n  adapter: Adapter | undefined,\n  logger: LoggerInstance\n): Adapter | undefined {\n  if (!adapter) return\n\n  return Object.keys(adapter).reduce<any>((acc, name) => {\n    acc[name] = async (...args: any[]) => {\n      try {\n        logger.debug(`adapter_${name}`, { args })\n        const method: Method = adapter[name as keyof Method]\n        return await method(...args)\n      } catch (error) {\n        logger.error(`adapter_error_${name}`, error as Error)\n        const e = new UnknownError(error as Error)\n        e.name = `${capitalize(name)}Error`\n        throw e\n      }\n    }\n    return acc\n  }, {})\n}\n", "import logger, { setLogger } from \"../lib/logger\"\nimport * as routes from \"./routes\"\nimport renderPage from \"./pages\"\nimport { init } from \"./init\"\nimport { assertConfig } from \"./lib/assert\"\nimport { SessionStore } from \"./lib/cookie\"\n\nimport type { NextAuthOptions } from \"./types\"\nimport type { NextAuthAction } from \"../lib/types\"\nimport type { Cookie } from \"./lib/cookie\"\nimport type { ErrorType } from \"./pages/error\"\n\nexport interface IncomingRequest {\n  /** @default \"http://localhost:3000\" */\n  host?: string\n  method?: string\n  cookies?: Record<string, string>\n  headers?: Record<string, any>\n  query?: Record<string, any>\n  body?: Record<string, any>\n  action: NextAuthAction\n  providerId?: string\n  error?: string\n}\n\nexport interface NextAuthHeader {\n  key: string\n  value: string\n}\n\nexport interface OutgoingResponse<\n  Body extends string | Record<string, any> | any[] = any\n> {\n  status?: number\n  headers?: NextAuthHeader[]\n  body?: Body\n  redirect?: string\n  cookies?: Cookie[]\n}\n\nexport interface NextAuthHandlerParams {\n  req: IncomingRequest\n  options: NextAuthOptions\n}\n\nexport async function NextAuthHandler<\n  Body extends string | Record<string, any> | any[]\n>(params: NextAuthHandlerParams): Promise<OutgoingResponse<Body>> {\n  const { options: userOptions, req } = params\n\n  setLogger(userOptions.logger, userOptions.debug)\n\n  const assertionResult = assertConfig(params)\n\n  if (typeof assertionResult === \"string\") {\n    logger.warn(assertionResult)\n  } else if (assertionResult instanceof Error) {\n    // Bail out early if there's an error in the user config\n    const { pages, theme } = userOptions\n    logger.error(assertionResult.code, assertionResult)\n    if (pages?.error) {\n      return {\n        redirect: `${pages.error}?error=Configuration`,\n      }\n    }\n    const render = renderPage({ theme })\n    return render.error({ error: \"configuration\" })\n  }\n\n  const { action, providerId, error, method = \"GET\" } = req\n\n  const { options, cookies } = await init({\n    userOptions,\n    action,\n    providerId,\n    host: req.host,\n    callbackUrl: req.body?.callbackUrl ?? req.query?.callbackUrl,\n    csrfToken: req.body?.csrfToken,\n    cookies: req.cookies,\n    isPost: method === \"POST\",\n  })\n\n  const sessionStore = new SessionStore(\n    options.cookies.sessionToken,\n    req,\n    options.logger\n  )\n\n  if (method === \"GET\") {\n    const render = renderPage({ ...options, query: req.query, cookies })\n    const { pages } = options\n    switch (action) {\n      case \"providers\":\n        return (await routes.providers(options.providers)) as any\n      case \"session\": {\n        const session = await routes.session({ options, sessionStore })\n        if (session.cookies) cookies.push(...session.cookies)\n        return { ...session, cookies } as any\n      }\n      case \"csrf\":\n        return {\n          headers: [{ key: \"Content-Type\", value: \"application/json\" }],\n          body: { csrfToken: options.csrfToken } as any,\n          cookies,\n        }\n      case \"signin\":\n        if (pages.signIn) {\n          let signinUrl = `${pages.signIn}${\n            pages.signIn.includes(\"?\") ? \"&\" : \"?\"\n          }callbackUrl=${encodeURIComponent(options.callbackUrl)}`\n          if (error)\n            signinUrl = `${signinUrl}&error=${encodeURIComponent(error)}`\n          return { redirect: signinUrl, cookies }\n        }\n\n        return render.signin()\n      case \"signout\":\n        if (pages.signOut) return { redirect: pages.signOut, cookies }\n\n        return render.signout()\n      case \"callback\":\n        if (options.provider) {\n          const callback = await routes.callback({\n            body: req.body,\n            query: req.query,\n            headers: req.headers,\n            cookies: req.cookies,\n            method,\n            options,\n            sessionStore,\n          })\n          if (callback.cookies) cookies.push(...callback.cookies)\n          return { ...callback, cookies }\n        }\n        break\n      case \"verify-request\":\n        if (pages.verifyRequest) {\n          return { redirect: pages.verifyRequest, cookies }\n        }\n        return render.verifyRequest()\n      case \"error\":\n        // These error messages are displayed in line on the sign in page\n        if (\n          [\n            \"Signin\",\n            \"OAuthSignin\",\n            \"OAuthCallback\",\n            \"OAuthCreateAccount\",\n            \"EmailCreateAccount\",\n            \"Callback\",\n            \"OAuthAccountNotLinked\",\n            \"EmailSignin\",\n            \"CredentialsSignin\",\n            \"SessionRequired\",\n          ].includes(error as string)\n        ) {\n          return { redirect: `${options.url}/signin?error=${error}`, cookies }\n        }\n\n        if (pages.error) {\n          return {\n            redirect: `${pages.error}${\n              pages.error.includes(\"?\") ? \"&\" : \"?\"\n            }error=${error}`,\n            cookies,\n          }\n        }\n\n        return render.error({ error: error as ErrorType })\n      default:\n    }\n  } else if (method === \"POST\") {\n    switch (action) {\n      case \"signin\":\n        // Verified CSRF Token required for all sign in routes\n        if (options.csrfTokenVerified && options.provider) {\n          const signin = await routes.signin({\n            query: req.query,\n            body: req.body,\n            options,\n          })\n          if (signin.cookies) cookies.push(...signin.cookies)\n          return { ...signin, cookies }\n        }\n\n        return { redirect: `${options.url}/signin?csrf=true`, cookies }\n      case \"signout\":\n        // Verified CSRF Token required for signout\n        if (options.csrfTokenVerified) {\n          const signout = await routes.signout({ options, sessionStore })\n          if (signout.cookies) cookies.push(...signout.cookies)\n          return { ...signout, cookies }\n        }\n        return { redirect: `${options.url}/signout?csrf=true`, cookies }\n      case \"callback\":\n        if (options.provider) {\n          // Verified CSRF Token required for credentials providers only\n          if (\n            options.provider.type === \"credentials\" &&\n            !options.csrfTokenVerified\n          ) {\n            return { redirect: `${options.url}/signin?csrf=true`, cookies }\n          }\n\n          const callback = await routes.callback({\n            body: req.body,\n            query: req.query,\n            headers: req.headers,\n            cookies: req.cookies,\n            method,\n            options,\n            sessionStore,\n          })\n          if (callback.cookies) cookies.push(...callback.cookies)\n          return { ...callback, cookies }\n        }\n        break\n      case \"_log\":\n        if (userOptions.logger) {\n          try {\n            const { code, level, ...metadata } = req.body ?? {}\n            logger[level](code, metadata)\n          } catch (error) {\n            // If logging itself failed...\n            logger.error(\"LOGGER_ERROR\", error as Error)\n          }\n        }\n        return {}\n      default:\n    }\n  }\n\n  return {\n    status: 400,\n    body: `Error: This action with HTTP ${method} is not supported by NextAuth.js` as any,\n  }\n}\n", "import {\n  MissingAdapter,\n  MissingAPIRoute,\n  MissingAuthorize,\n  MissingSecret,\n  UnsupportedStrategy,\n  InvalidCallbackUrl,\n} from \"../errors\"\nimport parseUrl from \"../../lib/parse-url\"\nimport { defaultCookies } from \"./cookie\"\n\nimport type { NextAuthHandlerParams } from \"..\"\nimport type { WarningCode } from \"../../lib/logger\"\n\ntype ConfigError =\n  | MissingAPIRoute\n  | MissingSecret\n  | UnsupportedStrategy\n  | MissingAuthorize\n  | MissingAdapter\n\nlet twitterWarned = false\n\nfunction isValidHttpUrl(url: string) {\n  try {\n    return /^https?:/.test(new URL(url).protocol)\n  } catch {\n    return false\n  }\n}\n\n/**\n * Verify that the user configured `next-auth` correctly.\n * Good place to mention deprecations as well.\n *\n * REVIEW: Make some of these and corresponding docs less Next.js specific?\n */\nexport function assertConfig(\n  params: NextAuthHandlerParams\n): ConfigError | WarningCode | undefined {\n  const { options, req } = params\n\n  // req.query isn't defined when asserting `getServerSession` for example\n  if (!req.query?.nextauth && !req.action) {\n    return new MissingAPIRoute(\n      \"Cannot find [...nextauth].{js,ts} in `/pages/api/auth`. Make sure the filename is written correctly.\"\n    )\n  }\n\n  if (!options.secret) {\n    if (process.env.NODE_ENV === \"production\") {\n      return new MissingSecret(\"Please define a `secret` in production.\")\n    } else {\n      return \"NO_SECRET\"\n    }\n  }\n\n  const callbackUrlParam = req.query?.callbackUrl as string | undefined\n\n  if (callbackUrlParam && !isValidHttpUrl(callbackUrlParam)) {\n    return new InvalidCallbackUrl(\n      `Invalid callback URL. Received: ${callbackUrlParam}`\n    )\n  }\n\n  if (!req.host) return \"NEXTAUTH_URL\"\n\n  const url = parseUrl(req.host)\n\n  const { callbackUrl: defaultCallbackUrl } = defaultCookies(\n    options.useSecureCookies ?? url.base.startsWith(\"https://\")\n  )\n  const callbackUrlCookie =\n    req.cookies?.[options.cookies?.callbackUrl?.name ?? defaultCallbackUrl.name]\n\n  if (callbackUrlCookie && !isValidHttpUrl(callbackUrlCookie)) {\n    return new InvalidCallbackUrl(\n      `Invalid callback URL. Received: ${callbackUrlCookie}`\n    )\n  }\n\n  let hasCredentials, hasEmail\n  let hasTwitterOAuth2\n\n  for (const provider of options.providers) {\n    if (provider.type === \"credentials\") hasCredentials = true\n    else if (provider.type === \"email\") hasEmail = true\n    else if (provider.id === \"twitter\" && provider.version === \"2.0\")\n      hasTwitterOAuth2 = true\n  }\n\n  if (hasCredentials) {\n    const dbStrategy = options.session?.strategy === \"database\"\n    const onlyCredentials = !options.providers.some(\n      (p) => p.type !== \"credentials\"\n    )\n    if (dbStrategy && onlyCredentials) {\n      return new UnsupportedStrategy(\n        \"Signin in with credentials only supported if JWT strategy is enabled\"\n      )\n    }\n\n    const credentialsNoAuthorize = options.providers.some(\n      (p) => p.type === \"credentials\" && !p.authorize\n    )\n    if (credentialsNoAuthorize) {\n      return new MissingAuthorize(\n        \"Must define an authorize() handler to use credentials authentication provider\"\n      )\n    }\n  }\n\n  if (hasEmail && !options.adapter) {\n    return new MissingAdapter(\"E-mail login requires an adapter.\")\n  }\n\n  if (!twitterWarned && hasTwitterOAuth2) {\n    twitterWarned = true\n    return \"TWITTER_OAUTH_2_BETA\"\n  }\n}\n", "import type { IncomingHttpHeaders } from \"http\"\nimport type { CookiesOptions } from \"../..\"\nimport type { CookieOption, LoggerInstance, SessionStrategy } from \"../types\"\n\n// Uncomment to recalculate the estimated size\n// of an empty session cookie\n// import { serialize } from \"cookie\"\n// console.log(\n//   \"Cookie estimated to be \",\n//   serialize(`__Secure.next-auth.session-token.0`, \"\", {\n//     expires: new Date(),\n//     httpOnly: true,\n//     maxAge: Number.MAX_SAFE_INTEGER,\n//     path: \"/\",\n//     sameSite: \"strict\",\n//     secure: true,\n//     domain: \"example.com\",\n//   }).length,\n//   \" bytes\"\n// )\n\nconst ALLOWED_COOKIE_SIZE = 4096\n// Based on commented out section above\nconst ESTIMATED_EMPTY_COOKIE_SIZE = 163\nconst CHUNK_SIZE = ALLOWED_COOKIE_SIZE - ESTIMATED_EMPTY_COOKIE_SIZE\n\n// REVIEW: Is there any way to defer two types of strings?\n\n/** Stringified form of `JWT`. Extract the content with `jwt.decode` */\nexport type JWTString = string\n\nexport type SetCookieOptions = Partial<CookieOption[\"options\"]> & {\n  expires?: Date | string\n  encode?: (val: unknown) => string\n}\n\n/**\n * If `options.session.strategy` is set to `jwt`, this is a stringified `JWT`.\n * In case of `strategy: \"database\"`, this is the `sessionToken` of the session in the database.\n */\nexport type SessionToken<T extends SessionStrategy = \"jwt\"> = T extends \"jwt\"\n  ? JWTString\n  : string\n\n/**\n * Use secure cookies if the site uses HTTPS\n * This being conditional allows cookies to work non-HTTPS development URLs\n * Honour secure cookie option, which sets 'secure' and also adds '__Secure-'\n * prefix, but enable them by default if the site URL is HTTPS; but not for\n * non-HTTPS URLs like http://localhost which are used in development).\n * For more on prefixes see https://googlechrome.github.io/samples/cookie-prefixes/\n *\n * @TODO Review cookie settings (names, options)\n */\nexport function defaultCookies(useSecureCookies: boolean): CookiesOptions {\n  const cookiePrefix = useSecureCookies ? \"__Secure-\" : \"\"\n  return {\n    // default cookie options\n    sessionToken: {\n      name: `${cookiePrefix}next-auth.session-token`,\n      options: {\n        httpOnly: true,\n        sameSite: \"lax\",\n        path: \"/\",\n        secure: useSecureCookies,\n      },\n    },\n    callbackUrl: {\n      name: `${cookiePrefix}next-auth.callback-url`,\n      options: {\n        httpOnly: true,\n        sameSite: \"lax\",\n        path: \"/\",\n        secure: useSecureCookies,\n      },\n    },\n    csrfToken: {\n      // Default to __Host- for CSRF token for additional protection if using useSecureCookies\n      // NB: The `__Host-` prefix is stricter than the `__Secure-` prefix.\n      name: `${useSecureCookies ? \"__Host-\" : \"\"}next-auth.csrf-token`,\n      options: {\n        httpOnly: true,\n        sameSite: \"lax\",\n        path: \"/\",\n        secure: useSecureCookies,\n      },\n    },\n    pkceCodeVerifier: {\n      name: `${cookiePrefix}next-auth.pkce.code_verifier`,\n      options: {\n        httpOnly: true,\n        sameSite: \"lax\",\n        path: \"/\",\n        secure: useSecureCookies,\n      },\n    },\n    state: {\n      name: `${cookiePrefix}next-auth.state`,\n      options: {\n        httpOnly: true,\n        sameSite: \"lax\",\n        path: \"/\",\n        secure: useSecureCookies,\n      },\n    },\n  }\n}\n\nexport interface Cookie extends CookieOption {\n  value: string\n}\n\ntype Chunks = Record<string, string>\n\nexport class SessionStore {\n  #chunks: Chunks = {}\n  #option: CookieOption\n  #logger: LoggerInstance | Console\n\n  constructor(\n    option: CookieOption,\n    req: {\n      cookies?: Record<string, string>\n      headers?: Headers | IncomingHttpHeaders | Record<string, string>\n    },\n    logger: LoggerInstance | Console\n  ) {\n    this.#logger = logger\n    this.#option = option\n\n    if (!req) return\n\n    for (const name in req.cookies) {\n      if (name.startsWith(option.name)) {\n        this.#chunks[name] = req.cookies[name]\n      }\n    }\n  }\n\n  get value() {\n    return Object.values(this.#chunks)?.join(\"\")\n  }\n\n  /** Given a cookie, return a list of cookies, chunked to fit the allowed cookie size. */\n  #chunk(cookie: Cookie): Cookie[] {\n    const chunkCount = Math.ceil(cookie.value.length / CHUNK_SIZE)\n\n    if (chunkCount === 1) {\n      this.#chunks[cookie.name] = cookie.value\n      return [cookie]\n    }\n\n    const cookies: Cookie[] = []\n    for (let i = 0; i < chunkCount; i++) {\n      const name = `${cookie.name}.${i}`\n      const value = cookie.value.substr(i * CHUNK_SIZE, CHUNK_SIZE)\n      cookies.push({ ...cookie, name, value })\n      this.#chunks[name] = value\n    }\n\n    this.#logger.debug(\"CHUNKING_SESSION_COOKIE\", {\n      message: `Session cookie exceeds allowed ${ALLOWED_COOKIE_SIZE} bytes.`,\n      emptyCookieSize: ESTIMATED_EMPTY_COOKIE_SIZE,\n      valueSize: cookie.value.length,\n      chunks: cookies.map((c) => c.value.length + ESTIMATED_EMPTY_COOKIE_SIZE),\n    })\n\n    return cookies\n  }\n\n  /** Returns cleaned cookie chunks. */\n  #clean(): Record<string, Cookie> {\n    const cleanedChunks: Record<string, Cookie> = {}\n    for (const name in this.#chunks) {\n      delete this.#chunks?.[name]\n      cleanedChunks[name] = {\n        name,\n        value: \"\",\n        options: { ...this.#option.options, maxAge: 0 },\n      }\n    }\n    return cleanedChunks\n  }\n\n  /**\n   * Given a cookie value, return new cookies, chunked, to fit the allowed cookie size.\n   * If the cookie has changed from chunked to unchunked or vice versa,\n   * it deletes the old cookies as well.\n   */\n  chunk(value: string, options: Partial<Cookie[\"options\"]>): Cookie[] {\n    // Assume all cookies should be cleaned by default\n    const cookies: Record<string, Cookie> = this.#clean()\n\n    // Calculate new chunks\n    const chunked = this.#chunk({\n      name: this.#option.name,\n      value,\n      options: { ...this.#option.options, ...options },\n    })\n\n    // Update stored chunks / cookies\n    for (const chunk of chunked) {\n      cookies[chunk.name] = chunk\n    }\n\n    return Object.values(cookies)\n  }\n\n  /** Returns a list of cookies that should be cleaned. */\n  clean(): Cookie[] {\n    return Object.values(this.#clean())\n  }\n}\n"], "filenames": ["docs/docs/errors.md", "packages/next-auth/src/core/errors.ts", "packages/next-auth/src/core/index.ts", "packages/next-auth/src/core/lib/assert.ts", "packages/next-auth/src/core/lib/cookie.ts"], "buggy_code_start_loc": [102, 65, 111, 6, 70], "buggy_code_end_loc": [165, 65, 112, 47, 70], "fixing_code_start_loc": [102, 66, 111, 7, 71], "fixing_code_end_loc": [169, 71, 113, 81, 72], "type": "CWE-754", "message": "NextAuth.js is a complete open source authentication solution for Next.js applications. In affected versions an attacker can send a request to an app using NextAuth.js with an invalid `callbackUrl` query parameter, which internally is converted to a `URL` object. The URL instantiation would fail due to a malformed URL being passed into the constructor, causing it to throw an unhandled error which led to the **API route handler timing out and logging in to fail**. This has been remedied in versions 3.29.5 and 4.5.0. If for some reason you cannot upgrade, the workaround requires you to rely on Advanced Initialization. Please see the documentation for more.", "other": {"cve": {"id": "CVE-2022-31093", "sourceIdentifier": "security-advisories@github.com", "published": "2022-06-27T22:15:09.047", "lastModified": "2022-07-07T19:45:54.007", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "NextAuth.js is a complete open source authentication solution for Next.js applications. In affected versions an attacker can send a request to an app using NextAuth.js with an invalid `callbackUrl` query parameter, which internally is converted to a `URL` object. The URL instantiation would fail due to a malformed URL being passed into the constructor, causing it to throw an unhandled error which led to the **API route handler timing out and logging in to fail**. This has been remedied in versions 3.29.5 and 4.5.0. If for some reason you cannot upgrade, the workaround requires you to rely on Advanced Initialization. Please see the documentation for more."}, {"lang": "es", "value": "NextAuth.js es una soluci\u00f3n completa de autenticaci\u00f3n de c\u00f3digo abierto para aplicaciones Next.js. En las versiones afectadas, un atacante puede enviar una petici\u00f3n a una aplicaci\u00f3n usando NextAuth.js con un par\u00e1metro de consulta \"callbackUrl\" no v\u00e1lido, que internamente es convertido en un objeto \"URL\". La instanciaci\u00f3n de la URL fallaba debido a que era pasada una URL malformada al constructor, lo que causaba que fuera lanzado un error no manejado que conllevaba a que el **manejador de rutas de la API se desconectara y el inicio de sesi\u00f3n fallara**. Esto ha sido remediado en versiones 3.29.5 y 4.5.0. Si por alguna raz\u00f3n no puedes actualizar, la mitigaci\u00f3n requiere que te apoyes en la Inicializaci\u00f3n Avanzada. Consulte la documentaci\u00f3n para obtener m\u00e1s informaci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-754"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nextauth.js:next-auth:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "3.29.5", "matchCriteriaId": "9433E695-3D8D-4D49-B349-C3C68F013FEE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nextauth.js:next-auth:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "4.0.0", "versionEndExcluding": "4.5.0", "matchCriteriaId": "6D08EEB4-7815-4127-B2CA-BE4B4258D8CD"}]}]}], "references": [{"url": "https://github.com/nextauthjs/next-auth/commit/25517b73153332d948114bacdff3b5908de91d85", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/nextauthjs/next-auth/commit/e498483b23273d1bfc81be68339607f88d411bd6", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/nextauthjs/next-auth/security/advisories/GHSA-g5fm-jp9v-2432", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}, {"url": "https://next-auth.js.org/configuration/initialization#advanced-initialization", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/nextauthjs/next-auth/commit/25517b73153332d948114bacdff3b5908de91d85"}}