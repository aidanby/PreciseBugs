{"buggy_code": ["/*\n * Copyright (c) 2020. Tolgee\n */\n\npackage io.tolgee.api.v2.controllers\n\nimport io.swagger.v3.oas.annotations.Operation\nimport io.swagger.v3.oas.annotations.Parameter\nimport io.swagger.v3.oas.annotations.tags.Tag\nimport io.tolgee.activity.RequestActivity\nimport io.tolgee.activity.data.ActivityType\nimport io.tolgee.dtos.dataImport.ImportAddFilesParams\nimport io.tolgee.dtos.dataImport.ImportFileDto\nimport io.tolgee.dtos.dataImport.SetFileNamespaceRequest\nimport io.tolgee.exceptions.BadRequestException\nimport io.tolgee.exceptions.ErrorResponseBody\nimport io.tolgee.exceptions.NotFoundException\nimport io.tolgee.hateoas.dataImport.ImportAddFilesResultModel\nimport io.tolgee.hateoas.dataImport.ImportLanguageModel\nimport io.tolgee.hateoas.dataImport.ImportLanguageModelAssembler\nimport io.tolgee.hateoas.dataImport.ImportNamespaceModel\nimport io.tolgee.hateoas.dataImport.ImportTranslationModel\nimport io.tolgee.hateoas.dataImport.ImportTranslationModelAssembler\nimport io.tolgee.model.Language\nimport io.tolgee.model.dataImport.ImportFile\nimport io.tolgee.model.dataImport.ImportLanguage\nimport io.tolgee.model.dataImport.ImportTranslation\nimport io.tolgee.model.views.ImportFileIssueView\nimport io.tolgee.model.views.ImportLanguageView\nimport io.tolgee.model.views.ImportTranslationView\nimport io.tolgee.security.AuthenticationFacade\nimport io.tolgee.security.apiKeyAuth.AccessWithApiKey\nimport io.tolgee.security.project_auth.AccessWithAnyProjectPermission\nimport io.tolgee.security.project_auth.ProjectHolder\nimport io.tolgee.service.LanguageService\nimport io.tolgee.service.dataImport.ForceMode\nimport io.tolgee.service.dataImport.ImportService\nimport io.tolgee.service.key.NamespaceService\nimport org.springdoc.api.annotations.ParameterObject\nimport org.springframework.data.domain.PageRequest\nimport org.springframework.data.domain.Pageable\nimport org.springframework.data.web.PagedResourcesAssembler\nimport org.springframework.data.web.SortDefault\nimport org.springframework.hateoas.CollectionModel\nimport org.springframework.hateoas.EntityModel\nimport org.springframework.hateoas.PagedModel\nimport org.springframework.hateoas.server.mvc.RepresentationModelAssemblerSupport\nimport org.springframework.http.MediaType\nimport org.springframework.web.bind.annotation.CrossOrigin\nimport org.springframework.web.bind.annotation.DeleteMapping\nimport org.springframework.web.bind.annotation.GetMapping\nimport org.springframework.web.bind.annotation.PathVariable\nimport org.springframework.web.bind.annotation.PostMapping\nimport org.springframework.web.bind.annotation.PutMapping\nimport org.springframework.web.bind.annotation.RequestBody\nimport org.springframework.web.bind.annotation.RequestMapping\nimport org.springframework.web.bind.annotation.RequestParam\nimport org.springframework.web.bind.annotation.RequestPart\nimport org.springframework.web.bind.annotation.RestController\nimport org.springframework.web.multipart.MultipartFile\nimport javax.servlet.http.HttpServletRequest\n\n@Suppress(\"MVCPathVariableInspection\")\n@RestController\n@CrossOrigin(origins = [\"*\"])\n@RequestMapping(value = [\"/v2/projects/{projectId:\\\\d+}/import\", \"/v2/projects/import\"])\n@Tag(name = \"Import\")\nclass V2ImportController(\n  private val importService: ImportService,\n  private val authenticationFacade: AuthenticationFacade,\n  private val importLanguageModelAssembler: ImportLanguageModelAssembler,\n  private val importTranslationModelAssembler: ImportTranslationModelAssembler,\n  @Suppress(\"SpringJavaInjectionPointsAutowiringInspection\")\n  private val pagedLanguagesResourcesAssembler: PagedResourcesAssembler<ImportLanguageView>,\n\n  @Suppress(\"SpringJavaInjectionPointsAutowiringInspection\")\n  private val pagedTranslationsResourcesAssembler: PagedResourcesAssembler<ImportTranslationView>,\n\n  @Suppress(\"SpringJavaInjectionPointsAutowiringInspection\")\n  private val pagedImportFileIssueResourcesAssembler: PagedResourcesAssembler<ImportFileIssueView>,\n  private val projectHolder: ProjectHolder,\n  private val languageService: LanguageService,\n  private val namespaceService: NamespaceService,\n) {\n  @PostMapping(\"\", consumes = [MediaType.MULTIPART_FORM_DATA_VALUE])\n  @AccessWithAnyProjectPermission()\n  @AccessWithApiKey()\n  @Operation(description = \"Prepares provided files to import.\", summary = \"Add files\")\n  fun addFiles(\n    @RequestPart(\"files\") files: Array<MultipartFile>,\n    @ParameterObject params: ImportAddFilesParams\n  ): ImportAddFilesResultModel {\n    val fileDtos = files.map { ImportFileDto(it.originalFilename ?: \"\", it.inputStream) }\n    val errors = importService.addFiles(\n      files = fileDtos,\n      project = projectHolder.projectEntity,\n      userAccount = authenticationFacade.userAccountEntity,\n      params = params\n    )\n    return getImportAddFilesResultModel(errors)\n  }\n\n  private fun getImportAddFilesResultModel(\n    errors: List<ErrorResponseBody>\n  ): ImportAddFilesResultModel {\n    val result: PagedModel<ImportLanguageModel>? = try {\n      this.getImportResult(PageRequest.of(0, 100))\n    } catch (e: NotFoundException) {\n      null\n    }\n    return ImportAddFilesResultModel(errors, result)\n  }\n\n  @PutMapping(\"/apply\")\n  @AccessWithAnyProjectPermission()\n  @AccessWithApiKey()\n  @Operation(description = \"Imports the data prepared in previous step\", summary = \"Apply\")\n  @RequestActivity(ActivityType.IMPORT)\n  fun applyImport(\n    @Parameter(description = \"Whether override or keep all translations with unresolved conflicts\")\n    @RequestParam(defaultValue = \"NO_FORCE\")\n    forceMode: ForceMode,\n  ) {\n    val projectId = projectHolder.project.id\n    this.importService.import(projectId, authenticationFacade.userAccount.id, forceMode)\n  }\n\n  @GetMapping(\"/result\")\n  @AccessWithAnyProjectPermission()\n  @AccessWithApiKey()\n  @Operation(description = \"Returns the result of preparation.\", summary = \"Get result\")\n  fun getImportResult(\n    @ParameterObject pageable: Pageable\n  ): PagedModel<ImportLanguageModel> {\n    val projectId = projectHolder.project.id\n    val userId = authenticationFacade.userAccount.id\n    val languages = importService.getResult(projectId, userId, pageable)\n    return pagedLanguagesResourcesAssembler.toModel(languages, importLanguageModelAssembler)\n  }\n\n  @GetMapping(\"/result/languages/{languageId}\")\n  @AccessWithAnyProjectPermission()\n  @AccessWithApiKey()\n  @Operation(description = \"Returns language prepared to import.\", summary = \"Get import language\")\n  fun getImportLanguage(\n    @PathVariable(\"languageId\") languageId: Long,\n  ): ImportLanguageModel {\n    checkImportLanguageInProject(languageId)\n    val language = importService.findLanguageView(languageId) ?: throw NotFoundException()\n    return importLanguageModelAssembler.toModel(language)\n  }\n\n  @GetMapping(\"/result/languages/{languageId}/translations\")\n  @AccessWithAnyProjectPermission()\n  @AccessWithApiKey()\n  @Operation(description = \"Returns translations prepared to import.\", summary = \"Get translations\")\n  fun getImportTranslations(\n    @PathVariable(\"projectId\") projectId: Long,\n    @PathVariable(\"languageId\") languageId: Long,\n    @Parameter(\n      description = \"Whether only translations, which are in conflict \" +\n        \"with existing translations should be returned\"\n    )\n    @RequestParam(\"onlyConflicts\", defaultValue = \"false\") onlyConflicts: Boolean = false,\n    @Parameter(\n      description = \"Whether only translations with unresolved conflicts\" +\n        \"with existing translations should be returned\"\n    )\n    @RequestParam(\"onlyUnresolved\", defaultValue = \"false\") onlyUnresolved: Boolean = false,\n    @Parameter(description = \"String to search in translation text or key\")\n    @RequestParam(\"search\") search: String? = null,\n    @ParameterObject @SortDefault(\"keyName\") pageable: Pageable\n  ): PagedModel<ImportTranslationModel> {\n    checkImportLanguageInProject(languageId)\n    val translations = importService.getTranslationsView(languageId, pageable, onlyConflicts, onlyUnresolved, search)\n    return pagedTranslationsResourcesAssembler.toModel(translations, importTranslationModelAssembler)\n  }\n\n  @DeleteMapping(\"\")\n  @AccessWithAnyProjectPermission()\n  @AccessWithApiKey()\n  @Operation(description = \"Deletes prepared import data.\", summary = \"Delete\")\n  fun cancelImport() {\n    this.importService.deleteImport(projectHolder.project.id, authenticationFacade.userAccount.id)\n  }\n\n  @DeleteMapping(\"/result/languages/{languageId}\")\n  @AccessWithAnyProjectPermission()\n  @AccessWithApiKey()\n  @Operation(description = \"Deletes language prepared to import.\", summary = \"Delete language\")\n  fun deleteLanguage(@PathVariable(\"languageId\") languageId: Long) {\n    val language = checkImportLanguageInProject(languageId)\n    this.importService.deleteLanguage(language)\n  }\n\n  @PutMapping(\"/result/languages/{languageId}/translations/{translationId}/resolve/set-override\")\n  @AccessWithAnyProjectPermission()\n  @AccessWithApiKey()\n  @Operation(\n    description = \"Resolves translation conflict. The old translation will be overridden.\",\n    summary = \"Resolve conflict (override)\"\n  )\n  fun resolveTranslationSetOverride(\n    @PathVariable(\"languageId\") languageId: Long,\n    @PathVariable(\"translationId\") translationId: Long\n  ) {\n    resolveTranslation(languageId, translationId, true)\n  }\n\n  @PutMapping(\"/result/languages/{languageId}/translations/{translationId}/resolve/set-keep-existing\")\n  @AccessWithAnyProjectPermission()\n  @AccessWithApiKey()\n  @Operation(\n    description = \"Resolves translation conflict. The old translation will be kept.\",\n    summary = \"Resolve conflict (keep existing)\"\n  )\n  fun resolveTranslationSetKeepExisting(\n    @PathVariable(\"languageId\") languageId: Long,\n    @PathVariable(\"translationId\") translationId: Long\n  ) {\n    resolveTranslation(languageId, translationId, false)\n  }\n\n  @PutMapping(\"/result/languages/{languageId}/resolve-all/set-override\")\n  @AccessWithAnyProjectPermission()\n  @AccessWithApiKey()\n  @Operation(\n    description = \"Resolves all translation conflicts for provided language. The old translations will be overridden.\",\n    summary = \"Resolve all translation conflicts (override)\"\n  )\n  fun resolveTranslationSetOverride(\n    @PathVariable(\"languageId\") languageId: Long\n  ) {\n    resolveAllOfLanguage(languageId, true)\n  }\n\n  @PutMapping(\"/result/languages/{languageId}/resolve-all/set-keep-existing\")\n  @AccessWithAnyProjectPermission()\n  @AccessWithApiKey()\n  @Operation(\n    description = \"Resolves all translation conflicts for provided language. The old translations will be kept.\",\n    summary = \"Resolve all translation conflicts (keep existing)\"\n  )\n  fun resolveTranslationSetKeepExisting(\n    @PathVariable(\"languageId\") languageId: Long,\n  ) {\n    resolveAllOfLanguage(languageId, false)\n  }\n\n  @PutMapping(\"/result/files/{fileId}/select-namespace\")\n  @AccessWithAnyProjectPermission()\n  @AccessWithApiKey()\n  @Operation(\n    description = \"Sets namespace for file to import.\",\n    summary = \"Select namespace\"\n  )\n  fun selectNamespace(\n    @PathVariable fileId: Long,\n    @RequestBody req: SetFileNamespaceRequest,\n    request: HttpServletRequest\n  ) {\n    val file = checkFileFromProject(fileId)\n    this.importService.selectNamespace(file, req.namespace)\n  }\n\n  @PutMapping(\"/result/languages/{importLanguageId}/select-existing/{existingLanguageId}\")\n  @AccessWithAnyProjectPermission()\n  @AccessWithApiKey()\n  @Operation(\n    description = \"Sets existing language to pair with language to import. \" +\n      \"Data will be imported to selected existing language when applied.\",\n    summary = \"Pair existing language\"\n  )\n  fun selectExistingLanguage(\n    @PathVariable(\"importLanguageId\") importLanguageId: Long,\n    @PathVariable(\"existingLanguageId\") existingLanguageId: Long,\n  ) {\n    val existingLanguage = checkLanguageFromProject(existingLanguageId)\n    val importLanguage = checkImportLanguageInProject(importLanguageId)\n    this.importService.selectExistingLanguage(importLanguage, existingLanguage)\n  }\n\n  @PutMapping(\"/result/languages/{importLanguageId}/reset-existing\")\n  @AccessWithAnyProjectPermission()\n  @AccessWithApiKey()\n  @Operation(\n    description = \"Resets existing language paired with language to import.\",\n    summary = \"Reset existing language pairing\"\n  )\n  fun resetExistingLanguage(\n    @PathVariable(\"importLanguageId\") importLanguageId: Long,\n  ) {\n    val importLanguage = checkImportLanguageInProject(importLanguageId)\n    this.importService.selectExistingLanguage(importLanguage, null)\n  }\n\n  @GetMapping(\"/result/files/{importFileId}/issues\")\n  @AccessWithAnyProjectPermission()\n  @AccessWithApiKey()\n  @Operation(\n    description = \"Returns issues for uploaded file.\",\n    summary = \"Get file issues\"\n  )\n  fun getImportFileIssues(\n    @PathVariable(\"importFileId\") importFileId: Long,\n    @ParameterObject pageable: Pageable\n  ): PagedModel<EntityModel<ImportFileIssueView>> {\n    checkFileFromProject(importFileId)\n    val page = importService.getFileIssues(importFileId, pageable)\n    return pagedImportFileIssueResourcesAssembler.toModel(page)\n  }\n\n  @GetMapping(\"/all-namespaces\")\n  @AccessWithAnyProjectPermission()\n  @AccessWithApiKey()\n  @Operation(\n    description = \"Returns all existing and imported namespaces\",\n    summary = \"Get namespaces\"\n  )\n  fun getAllNamespaces(): CollectionModel<ImportNamespaceModel> {\n    val import = importService.get(\n      projectId = projectHolder.project.id,\n      authorId = authenticationFacade.userAccount.id\n    )\n    val importNamespaces = importService.getAllNamespaces(import.id)\n    val existingNamespaces = namespaceService.getAllInProject(projectId = projectHolder.project.id)\n    val result = existingNamespaces\n      .map { it.name to ImportNamespaceModel(it.id, it.name) }\n      .toMap(mutableMapOf())\n    importNamespaces.filterNotNull().forEach { importNamespace ->\n      result.computeIfAbsent(importNamespace) {\n        ImportNamespaceModel(id = null, name = importNamespace)\n      }\n    }\n\n    return getNamespacesCollectionModel(result)\n  }\n\n  private fun getNamespacesCollectionModel(\n    result: MutableMap<String, ImportNamespaceModel>\n  ): CollectionModel<ImportNamespaceModel> {\n    val assembler = object : RepresentationModelAssemblerSupport<ImportNamespaceModel, ImportNamespaceModel>(\n      this::class.java,\n      ImportNamespaceModel::class.java\n    ) {\n      override fun toModel(entity: ImportNamespaceModel): ImportNamespaceModel = entity\n    }\n\n    return assembler.toCollectionModel(result.values.sortedBy { it.name })\n  }\n\n  private fun resolveAllOfLanguage(languageId: Long, override: Boolean) {\n    val language = checkImportLanguageInProject(languageId)\n    importService.resolveAllOfLanguage(language, override)\n  }\n\n  private fun resolveTranslation(languageId: Long, translationId: Long, override: Boolean) {\n    checkImportLanguageInProject(languageId)\n    val translation = checkTranslationOfLanguage(translationId, languageId)\n    return importService.resolveTranslationConflict(translation, override)\n  }\n\n  private fun checkFileFromProject(fileId: Long): ImportFile {\n    val file = importService.findFile(fileId) ?: throw NotFoundException()\n    if (file.import.project.id != projectHolder.project.id) {\n      throw BadRequestException(io.tolgee.constants.Message.IMPORT_LANGUAGE_NOT_FROM_PROJECT)\n    }\n    return file\n  }\n\n  private fun checkLanguageFromProject(languageId: Long): Language {\n    val existingLanguage = languageService.findById(languageId).orElse(null) ?: throw NotFoundException()\n    if (existingLanguage.project.id != projectHolder.project.id) {\n      throw BadRequestException(io.tolgee.constants.Message.IMPORT_LANGUAGE_NOT_FROM_PROJECT)\n    }\n    return existingLanguage\n  }\n\n  private fun checkImportLanguageInProject(languageId: Long): ImportLanguage {\n    val language = importService.findLanguage(languageId) ?: throw NotFoundException()\n    val languageProjectId = language.file.import.project.id\n    if (languageProjectId != projectHolder.project.id) {\n      throw BadRequestException(io.tolgee.constants.Message.IMPORT_LANGUAGE_NOT_FROM_PROJECT)\n    }\n    return language\n  }\n\n  private fun checkTranslationOfLanguage(translationId: Long, languageId: Long): ImportTranslation {\n    val translation = importService.findTranslation(translationId) ?: throw NotFoundException()\n\n    if (translation.language.id != languageId) {\n      throw BadRequestException(io.tolgee.constants.Message.IMPORT_LANGUAGE_NOT_FROM_PROJECT)\n    }\n    return translation\n  }\n}\n", "package io.tolgee.websocket\n\nimport io.tolgee.dtos.cacheable.UserAccountDto\nimport io.tolgee.model.enums.Scope\nimport io.tolgee.security.JwtTokenProvider\nimport io.tolgee.service.security.SecurityService\nimport org.springframework.context.annotation.Configuration\nimport org.springframework.messaging.Message\nimport org.springframework.messaging.MessageChannel\nimport org.springframework.messaging.MessagingException\nimport org.springframework.messaging.simp.config.ChannelRegistration\nimport org.springframework.messaging.simp.config.MessageBrokerRegistry\nimport org.springframework.messaging.simp.stomp.StompCommand\nimport org.springframework.messaging.simp.stomp.StompHeaderAccessor\nimport org.springframework.messaging.support.ChannelInterceptor\nimport org.springframework.messaging.support.MessageHeaderAccessor\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken\nimport org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker\nimport org.springframework.web.socket.config.annotation.StompEndpointRegistry\nimport org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer\n\n@Configuration\n@EnableWebSocketMessageBroker\nclass WebSocketConfig(\n  private val jwtTokenProvider: JwtTokenProvider,\n  private val securityService: SecurityService,\n) : WebSocketMessageBrokerConfigurer {\n  override fun configureMessageBroker(config: MessageBrokerRegistry) {\n    config.enableSimpleBroker(\"/\")\n  }\n\n  override fun registerStompEndpoints(registry: StompEndpointRegistry) {\n    registry.addEndpoint(\"/websocket\").setAllowedOriginPatterns(\"*\").withSockJS()\n  }\n\n  override fun configureClientInboundChannel(registration: ChannelRegistration) {\n    registration.interceptors(object : ChannelInterceptor {\n      override fun preSend(message: Message<*>, channel: MessageChannel): Message<*>? {\n        val accessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor::class.java)\n\n        if (accessor?.command == StompCommand.CONNECT) {\n          val tokenString = accessor.getNativeHeader(\"jwtToken\")?.firstOrNull()\n          accessor.user = jwtTokenProvider.getAuthentication(tokenString)\n        }\n\n        if (accessor?.command == StompCommand.SUBSCRIBE) {\n          val projectId = accessor.destination?.let {\n            \"/projects/([0-9]+)\".toRegex().find(it)?.groupValues\n              ?.getOrNull(1)?.toLong()\n          }\n\n          if (projectId != null) {\n            try {\n              val user = (accessor.user as? UsernamePasswordAuthenticationToken)?.principal as UserAccountDto\n              securityService.checkProjectPermission(projectId = projectId, Scope.TRANSLATIONS_VIEW, user)\n            } catch (e: Exception) {\n              throw MessagingException(\"Forbidden\")\n            }\n          }\n        }\n\n        return message\n      }\n\n      override fun postReceive(message: Message<*>, channel: MessageChannel): Message<*>? {\n        return super.postReceive(message, channel)\n      }\n    })\n  }\n}\n", "package io.tolgee.api.v2.controllers.v2ImportController\n\nimport io.tolgee.constants.MtServiceType\nimport io.tolgee.development.testDataBuilder.data.dataImport.ImportTestData\nimport io.tolgee.fixtures.andAssertThatJson\nimport io.tolgee.fixtures.andIsForbidden\nimport io.tolgee.fixtures.andIsOk\nimport io.tolgee.fixtures.isValidId\nimport io.tolgee.fixtures.node\nimport io.tolgee.testing.AuthorizedControllerTest\nimport io.tolgee.testing.assert\nimport io.tolgee.testing.assertions.Assertions.assertThat\nimport org.junit.jupiter.api.Test\n\nclass V2ImportControllerApplicationTest : AuthorizedControllerTest() {\n  @Test\n  fun `it applies the import`() {\n    val testData = ImportTestData()\n    testData.setAllResolved()\n    testData.setAllOverride()\n    testDataService.saveTestData(testData.root)\n    val user = testData.root.data.userAccounts[0].self\n    val projectId = testData.project.id\n    loginAsUser(user.username)\n    val path = \"/v2/projects/$projectId/import/apply\"\n    performAuthPut(path, null).andIsOk\n    this.importService.find(projectId, user.id).let {\n      assertThat(it).isNull()\n    }\n  }\n\n  @Test\n  fun `it applies the import with force override`() {\n    val testData = ImportTestData()\n    testDataService.saveTestData(testData.root)\n    val user = testData.root.data.userAccounts[0].self\n    val projectId = testData.project.id\n    loginAsUser(user.username)\n    val path = \"/v2/projects/$projectId/import/apply?forceMode=OVERRIDE\"\n    performAuthPut(path, null).andIsOk\n    this.importService.find(projectId, user.id).let {\n      assertThat(it).isNull()\n    }\n  }\n\n  @Test\n  fun `it applies the import with force keep`() {\n    val testData = ImportTestData()\n    testDataService.saveTestData(testData.root)\n    val user = testData.root.data.userAccounts[0].self\n    val projectId = testData.project.id\n    loginAsUser(user.username)\n    val path = \"/v2/projects/$projectId/import/apply?forceMode=KEEP\"\n    performAuthPut(path, null).andIsOk\n  }\n\n  @Test\n  fun `it imports empty keys`() {\n    val testData = ImportTestData()\n    testData.addEmptyKey()\n    testDataService.saveTestData(testData.root)\n    val user = testData.root.data.userAccounts[0].self\n    val projectId = testData.project.id\n    loginAsUser(user.username)\n    val path = \"/v2/projects/$projectId/import/apply?forceMode=KEEP\"\n    performAuthPut(path, null).andIsOk\n\n    executeInNewTransaction {\n      projectService.get(testData.project.id).keys.find { it.name == \"empty key\" }.assert.isNotNull\n    }\n  }\n\n  @Test\n  fun `it checks permissions`() {\n    val testData = ImportTestData()\n\n    val user = testData.useTranslateOnlyUser()\n\n    testDataService.saveTestData(testData.root)\n    val projectId = testData.project.id\n    loginAsUser(user.username)\n\n    val path = \"/v2/projects/$projectId/import/apply?forceMode=OVERRIDE\"\n    performAuthPut(path, null).andIsForbidden.andAssertThatJson {\n      node(\"params\") {\n        node(\"[0]\").isEqualTo(\"\"\"[\"keys.edit\"]\"\"\")\n      }\n    }\n  }\n\n  @Test\n  fun `it checks language permissions`() {\n    val testData = ImportTestData()\n    testData.importBuilder.data.importFiles[0].data.importKeys.removeIf { it.self == testData.newLongKey }\n    val resolveFrench = testData.addFrenchTranslations()\n    resolveFrench()\n\n    val user = testData.useTranslateOnlyUser()\n\n    testDataService.saveTestData(testData.root)\n    val projectId = testData.project.id\n    loginAsUser(user.username)\n\n    val path = \"/v2/projects/$projectId/import/apply?forceMode=OVERRIDE\"\n    performAuthPut(path, null).andIsForbidden.andAssertThatJson {\n      node(\"code\").isEqualTo(\"language_not_permitted\")\n      node(\"params[0]\") {\n        isArray\n        node(\"[0]\").isValidId\n      }\n    }\n  }\n\n  @Test\n  fun `it checks permissions (view only)`() {\n    val testData = ImportTestData()\n    testData.importBuilder.data.importFiles[0].data.importKeys.removeIf { it.self == testData.newLongKey }\n    val resolveFrench = testData.addFrenchTranslations()\n    resolveFrench()\n\n    val user = testData.useViewEnOnlyUser()\n\n    testDataService.saveTestData(testData.root)\n    val projectId = testData.project.id\n    loginAsUser(user.username)\n\n    val path = \"/v2/projects/$projectId/import/apply?forceMode=OVERRIDE\"\n    performAuthPut(path, null).andIsForbidden\n  }\n\n  @Test\n  fun `it sets outdated on update`() {\n    val testData = ImportTestData()\n    testDataService.saveTestData(testData.root)\n    val user = testData.root.data.userAccounts[0].self\n    val projectId = testData.project.id\n    loginAsUser(user.username)\n    val path = \"/v2/projects/$projectId/import/apply?forceMode=OVERRIDE\"\n    performAuthPut(path, null).andIsOk\n\n    executeInNewTransaction {\n      val key = projectService.get(testData.project.id)\n        .keys.find { it.name == \"what a nice key\" }!!\n\n      val untouched = key.translations.find { it.language == testData.french }!!\n      untouched.outdated.assert.isEqualTo(true)\n      untouched.mtProvider.assert.isEqualTo(MtServiceType.GOOGLE)\n      untouched.auto.assert.isEqualTo(true)\n\n      val touched = key.translations.find { it.language == testData.english }!!\n      touched.outdated.assert.isEqualTo(false)\n      touched.mtProvider.assert.isEqualTo(null)\n      touched.auto.assert.isEqualTo(false)\n    }\n  }\n}\n", "package io.tolgee.api.v2.controllers.v2KeyController\n\nimport io.tolgee.ProjectAuthControllerTest\nimport io.tolgee.development.testDataBuilder.data.KeysTestData\nimport io.tolgee.dtos.request.KeyInScreenshotPositionDto\nimport io.tolgee.dtos.request.key.CreateKeyDto\nimport io.tolgee.dtos.request.key.KeyScreenshotDto\nimport io.tolgee.exceptions.FileStoreException\nimport io.tolgee.fixtures.andAssertThatJson\nimport io.tolgee.fixtures.andIsCreated\nimport io.tolgee.fixtures.andPrettyPrint\nimport io.tolgee.fixtures.isValidId\nimport io.tolgee.fixtures.node\nimport io.tolgee.model.enums.Scope\nimport io.tolgee.service.ImageUploadService\nimport io.tolgee.testing.annotations.ProjectApiKeyAuthTestMethod\nimport io.tolgee.testing.annotations.ProjectJWTAuthTestMethod\nimport io.tolgee.testing.assertions.Assertions.assertThat\nimport io.tolgee.util.generateImage\nimport org.junit.jupiter.api.BeforeEach\nimport org.junit.jupiter.api.Test\nimport org.junit.jupiter.api.assertThrows\nimport org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc\nimport org.springframework.boot.test.context.SpringBootTest\nimport org.springframework.core.io.InputStreamSource\nimport java.math.BigDecimal\n\n@SpringBootTest\n@AutoConfigureMockMvc\nclass KeyControllerCreationTest : ProjectAuthControllerTest(\"/v2/projects/\") {\n\n  lateinit var testData: KeysTestData\n\n  val screenshotFile: InputStreamSource by lazy {\n    generateImage(2000, 3000)\n  }\n\n  @BeforeEach\n  fun setup() {\n    testData = KeysTestData()\n    testDataService.saveTestData(testData.root)\n    userAccount = testData.user\n    this.projectSupplier = { testData.project }\n  }\n\n  @ProjectJWTAuthTestMethod\n  @Test\n  fun `creates key`() {\n    performProjectAuthPost(\"keys\", CreateKeyDto(name = \"super_key\"))\n      .andIsCreated.andPrettyPrint.andAssertThatJson {\n        node(\"id\").isValidId\n        node(\"name\").isEqualTo(\"super_key\")\n      }\n  }\n\n  @ProjectJWTAuthTestMethod\n  @Test\n  fun `creates key with size 2000`() {\n    performProjectAuthPost(\"keys\", CreateKeyDto(name = KeyControllerTest.MAX_OK_NAME))\n      .andIsCreated.andPrettyPrint.andAssertThatJson {\n        node(\"id\").isValidId\n        node(\"name\").isEqualTo(KeyControllerTest.MAX_OK_NAME)\n      }\n  }\n\n  @ProjectApiKeyAuthTestMethod(scopes = [Scope.KEYS_CREATE])\n  @Test\n  fun `creates key with keys create scope`() {\n    performProjectAuthPost(\"keys\", CreateKeyDto(name = \"super_key\", translations = mapOf(\"en\" to \"\", \"de\" to \"\")))\n      .andIsCreated.andPrettyPrint.andAssertThatJson {\n        node(\"id\").isValidId\n        node(\"name\").isEqualTo(\"super_key\")\n      }\n  }\n\n  @ProjectJWTAuthTestMethod\n  @Test\n  fun `creates key with translations and tags and screenshots`() {\n    val keyName = \"super_key\"\n\n    val screenshotImages = (1..3).map { imageUploadService.store(screenshotFile, userAccount!!, null) }\n    val screenshotImageIds = screenshotImages.map { it.id }\n    performProjectAuthPost(\n      \"keys\",\n      CreateKeyDto(\n        name = keyName,\n        translations = mapOf(\"en\" to \"EN\", \"de\" to \"DE\"),\n        tags = listOf(\"tag\", \"tag2\"),\n        screenshotUploadedImageIds = screenshotImageIds\n      )\n    ).andIsCreated.andPrettyPrint.andAssertThatJson {\n      node(\"id\").isValidId\n      node(\"name\").isEqualTo(keyName)\n      node(\"tags\") {\n        isArray.hasSize(2)\n        node(\"[0]\") {\n          node(\"id\").isValidId\n          node(\"name\").isEqualTo(\"tag\")\n        }\n        node(\"[1]\") {\n          node(\"id\").isValidId\n          node(\"name\").isEqualTo(\"tag2\")\n        }\n      }\n      node(\"translations\") {\n        node(\"en\") {\n          node(\"id\").isValidId\n          node(\"text\").isEqualTo(\"EN\")\n          node(\"state\").isEqualTo(\"TRANSLATED\")\n          node(\"auto\").isEqualTo(false)\n          node(\"mtProvider\").isEqualTo(null)\n        }\n        node(\"de\") {\n          node(\"id\").isValidId\n          node(\"text\").isEqualTo(\"DE\")\n          node(\"state\").isEqualTo(\"TRANSLATED\")\n        }\n      }\n      node(\"screenshots\") {\n        isArray.hasSize(3)\n        node(\"[1]\") {\n          node(\"id\").isNumber.isGreaterThan(BigDecimal(0))\n          node(\"filename\").isString.endsWith(\".png\").hasSizeGreaterThan(20)\n        }\n      }\n    }\n\n    assertThat(tagService.find(project, \"tag\")).isNotNull\n    assertThat(tagService.find(project, \"tag2\")).isNotNull\n\n    val key = keyService.get(project.id, keyName, null)\n    assertThat(tagService.getTagsForKeyIds(listOf(key.id))[key.id]).hasSize(2)\n    assertThat(translationService.find(key, testData.english).get().text).isEqualTo(\"EN\")\n\n    val screenshots = screenshotService.findAll(key)\n    screenshots.forEach {\n      fileStorage.readFile(\"screenshots/${it.filename}\").isNotEmpty()\n    }\n    assertThat(screenshots).hasSize(3)\n    assertThat(imageUploadService.find(screenshotImageIds)).hasSize(0)\n\n    assertThrows<FileStoreException> {\n      screenshotImages.forEach {\n        fileStorage.readFile(\n          \"${ImageUploadService.UPLOADED_IMAGES_STORAGE_FOLDER_NAME}/${it.filenameWithExtension}\"\n        )\n      }\n    }\n  }\n\n  @ProjectJWTAuthTestMethod\n  @Test\n  fun `creates key with screenshot meta`() {\n    val keyName = \"super_key\"\n\n    val screenshotImages = (1..3).map { imageUploadService.store(screenshotFile, userAccount!!, null) }\n    performProjectAuthPost(\n      \"keys\",\n      CreateKeyDto(\n        name = keyName,\n        translations = mapOf(\"en\" to \"EN\", \"de\" to \"DE\"),\n        tags = listOf(\"tag\", \"tag2\"),\n        screenshots = screenshotImages.map {\n          KeyScreenshotDto().apply {\n            text = \"text\"\n            uploadedImageId = it.id\n            positions = listOf(\n              KeyInScreenshotPositionDto().apply {\n                x = 100\n                y = 120\n                width = 200\n                height = 300\n              }\n            )\n          }\n        }\n      )\n    ).andIsCreated.andPrettyPrint.andAssertThatJson {\n      node(\"screenshots\") {\n        isArray.hasSize(3)\n        node(\"[1]\") {\n          node(\"id\").isNumber.isGreaterThan(BigDecimal(0))\n          node(\"filename\").isString.endsWith(\".png\").hasSizeGreaterThan(20)\n          node(\"keyReferences\") {\n            isArray.hasSize(1)\n            node(\"[0]\") {\n              node(\"keyId\").isValidId\n              node(\"position\") {\n                node(\"x\").isEqualTo(71)\n                node(\"y\").isEqualTo(85)\n                node(\"width\").isEqualTo(141)\n                node(\"height\").isEqualTo(212)\n              }\n              node(\"keyName\").isEqualTo(\"super_key\")\n              node(\"keyNamespace\").isEqualTo(null)\n              node(\"originalText\").isEqualTo(\"text\")\n            }\n          }\n        }\n      }\n    }\n\n    executeInNewTransaction {\n      val key = keyService.get(project.id, keyName, null)\n      val screenshots = screenshotService.findAll(key)\n      screenshots.forEach {\n        fileStorage.readFile(\"screenshots/${it.filename}\").isNotEmpty()\n      }\n      assertThat(screenshots).hasSize(3)\n      assertThat(\n        imageUploadService.find(screenshotImages.map { it.id })\n      ).hasSize(0)\n      screenshots.forEach {\n        val position = it.keyScreenshotReferences[0].positions!![0]\n        assertThat(position.x).isEqualTo(71)\n        assertThat(position.y).isEqualTo(85)\n        assertThat(position.width).isEqualTo(141)\n        assertThat(position.height).isEqualTo(212)\n      }\n    }\n  }\n}\n", "/*\n * Copyright (c) 2020. Tolgee\n */\n\npackage io.tolgee.service\n\nimport com.fasterxml.jackson.module.kotlin.jacksonObjectMapper\nimport com.fasterxml.jackson.module.kotlin.readValue\nimport io.tolgee.AbstractSpringTest\nimport io.tolgee.configuration.tolgee.TelemetryProperties\nimport io.tolgee.development.testDataBuilder.data.BaseTestData\nimport io.tolgee.dtos.TelemetryReportRequest\nimport io.tolgee.fixtures.mockHttpRequest\nimport io.tolgee.fixtures.waitForNotThrowing\nimport io.tolgee.testing.assert\nimport org.junit.jupiter.api.AfterEach\nimport org.junit.jupiter.api.Test\nimport org.mockito.Mockito\nimport org.springframework.beans.factory.annotation.Autowired\nimport org.springframework.boot.test.context.SpringBootTest\nimport org.springframework.boot.test.mock.mockito.MockBean\nimport org.springframework.http.HttpMethod\nimport org.springframework.web.client.RestTemplate\n\n@SpringBootTest(\n  properties = [\n    \"tolgee.telemetry.report-period-ms=200\",\n    \"tolgee.telemetry.enabled=true\"\n  ]\n)\nclass TelemetryServiceTest : AbstractSpringTest() {\n\n  @MockBean\n  @Autowired\n  lateinit var restTemplate: RestTemplate\n\n  @Autowired\n  lateinit var telemetryProperties: TelemetryProperties\n\n  @AfterEach\n  fun clean() {\n    telemetryProperties.enabled = true\n  }\n\n  @Test\n  fun `doesn't report when disabled`() {\n    telemetryProperties.enabled = false\n    Mockito.reset(restTemplate)\n    mockHttpRequest(restTemplate) {\n      whenReq {\n        url = { it.contains(\"/v2/public/telemetry\") }\n        method = { it == HttpMethod.POST }\n      }\n      thenAnswer { }\n      verify {\n        Thread.sleep(5000)\n        this.captor.allValues.assert.hasSize(0)\n      }\n    }\n  }\n\n  @Test\n  fun `reports when enabled`() {\n    val testData = BaseTestData().apply {\n      this.root.addProject { name = \"bbbb\" }.build {\n        val en = addEnglish()\n        addKey(\"a\") {\n          addTranslation {\n            language = en.self\n            text = \"Hello\"\n          }\n        }\n      }\n    }\n    testDataService.saveTestData(testData.root)\n    mockHttpRequest(restTemplate) {\n      whenReq {\n        url = { it.contains(\"/v2/public/telemetry\") }\n        method = { it == HttpMethod.POST }\n      }\n      thenAnswer { }\n      verify {\n        waitForNotThrowing {\n          val first = this.captor.allValues[0].body as String\n          val data = jacksonObjectMapper().readValue<TelemetryReportRequest>(first)\n          data.instanceId.assert.isNotBlank()\n          data.projectsCount.assert.isEqualTo(2)\n          data.translationsCount.assert.isEqualTo(1)\n          data.languagesCount.assert.isEqualTo(2)\n          data.distinctLanguagesCount.assert.isEqualTo(1)\n          data.usersCount.assert.isEqualTo(1)\n        }\n      }\n    }\n  }\n}\n", "spring:\n  jpa:\n    show-sql: true\n    properties:\n      hibernate:\n        jdbc:\n          batch_size: 1000\n        order_inserts: true\n        order_updates: true\n        dialect: io.tolgee.dialects.postgres.CustomPostgreSQLDialect\n  mvc:\n    pathmatch:\n      matching-strategy: ant_path_matcher\n  data:\n    redis:\n      repositories:\n        enabled: false\n  main:\n    allow-bean-definition-overriding: true\n    lazy-initialization: true\n  liquibase:\n    change-log: classpath:db/changelog/schema.xml\n  batch:\n    job:\n      enabled: false\n    jdbc:\n      initialize-schema: always\n  jmx:\n    enabled: false\ntolgee:\n  postgres-autostart:\n    enabled: true\n    container-name: tolgee_backend_tests_postgres\n    port: 55433\n  data-path: ./build/test_data\n  authentication:\n    native-enabled: true\n    registrationsAllowed: true\n    create-initial-user: false\n    oauth2:\n      client-id: fake_client_id\n      client-secret: fake_client_secret\n      scopes:\n        - openid\n        - email\n        - profile\n      authorization-url: \"https://example.com/authorize\"\n      token-url: \"https://example.com/oauth/token\"\n      user-url: \"https://example.com/userinfo\"\n  internal:\n    fake-mt-providers: true\n    mock-free-plan: true\n  socket-io:\n    port: 19090\n    enabled: false\n  cache:\n    caffeine-max-size: 1000\n  machine-translation:\n    free-credits-amount: -1\n    google:\n      api-key: aaa\n    aws:\n      accessKey: aaa\n      secretKey: aaa\n  billing:\n    enabled: false\n  telemetry:\n    enabled: false\nlogging:\n  level:\n    io.tolgee.billing.api.v2.OrganizationInvoicesController: DEBUG\n#    org.springframework.orm.jpa: DEBUG\n#    org.springframework.transaction: DEBUG\n#    org.hibernate.type: TRACE\n", "package io.tolgee.repository.dataImport\n\nimport io.tolgee.model.Language\nimport io.tolgee.model.dataImport.Import\nimport io.tolgee.model.dataImport.ImportLanguage\nimport io.tolgee.model.views.ImportLanguageView\nimport org.springframework.data.domain.Page\nimport org.springframework.data.domain.Pageable\nimport org.springframework.data.jpa.repository.JpaRepository\nimport org.springframework.data.jpa.repository.Modifying\nimport org.springframework.data.jpa.repository.Query\nimport org.springframework.stereotype.Repository\nimport org.springframework.transaction.annotation.Transactional\nimport java.util.*\n\n@Repository\ninterface ImportLanguageRepository : JpaRepository<ImportLanguage, Long> {\n\n  companion object {\n    private const val VIEW_BASE_QUERY = \"\"\"\n            select il.id as id, il.name as name, el.id as existingLanguageId, \n            el.tag as existingLanguageTag, el.name as existingLanguageName,\n            if.name as importFileName, if.id as importFileId,\n            if.namespace as namespace,\n            (select count(*) from if.issues) as importFileIssueCount,\n            count(it) as totalCount, \n            sum(case when it.conflict is null then 0 else 1 end) as conflictCount,\n            sum(case when (it.conflict is null or it.resolvedHash is null) then 0 else 1 end) as resolvedCount\n            from ImportLanguage il join il.file if left join il.existingLanguage el left join il.translations it\n        \"\"\"\n\n    private const val VIEW_GROUP_BY = \"\"\"\n            group by il.id, if.id, el.id\n        \"\"\"\n  }\n\n  @Query(\"from ImportLanguage il join il.file if join if.import im where im.id = :importId\")\n  fun findAllByImport(importId: Long): List<ImportLanguage>\n\n  @Modifying\n  @Transactional\n  @Query(\"update ImportLanguage il set il.existingLanguage = null where il.existingLanguage = :language\")\n  fun removeExistingLanguageReference(language: Language)\n\n  @Query(\n    \"\"\"\n            $VIEW_BASE_QUERY\n            where if.import.id = :importId\n            $VIEW_GROUP_BY\n            order by il.id\n            \"\"\"\n  )\n  fun findImportLanguagesView(importId: Long, pageable: Pageable): Page<ImportLanguageView>\n\n  @Modifying\n  @Transactional\n  @Query(\n    \"\"\"delete from ImportLanguage l where l.file in \n        (select f from ImportFile f where f.import = :import)\"\"\"\n  )\n  fun deleteAllByImport(import: Import)\n\n  @Query(\n    \"\"\"\n            $VIEW_BASE_QUERY\n            where il.id = :languageId\n            $VIEW_GROUP_BY\n            \"\"\"\n  )\n  fun findViewById(languageId: Long): Optional<ImportLanguageView>\n}\n", "package io.tolgee.service.dataImport\n\nimport io.tolgee.exceptions.BadRequestException\nimport io.tolgee.exceptions.ImportConflictNotResolvedException\nimport io.tolgee.model.dataImport.Import\nimport io.tolgee.model.dataImport.ImportLanguage\nimport io.tolgee.model.dataImport.ImportTranslation\nimport io.tolgee.model.enums.Scope\nimport io.tolgee.model.key.Key\nimport io.tolgee.model.key.KeyMeta\nimport io.tolgee.model.key.Namespace\nimport io.tolgee.model.translation.Translation\nimport io.tolgee.service.key.KeyMetaService\nimport io.tolgee.service.key.KeyService\nimport io.tolgee.service.key.NamespaceService\nimport io.tolgee.service.security.SecurityService\nimport io.tolgee.service.translation.TranslationService\nimport org.springframework.context.ApplicationContext\n\nclass StoredDataImporter(\n  applicationContext: ApplicationContext,\n  private val import: Import,\n  private val forceMode: ForceMode = ForceMode.NO_FORCE,\n) {\n\n  private val importDataManager = ImportDataManager(applicationContext, import)\n  private val keyService = applicationContext.getBean(KeyService::class.java)\n  private val namespaceService = applicationContext.getBean(NamespaceService::class.java)\n\n  private val keyMetaService = applicationContext.getBean(KeyMetaService::class.java)\n\n  private val securityService = applicationContext.getBean(SecurityService::class.java)\n\n  private val translationsToSave = mutableListOf<Translation>()\n\n  /**\n   * We need to persist data after everything is checked for resolved conflicts since\n   * thrown ImportConflictNotResolvedException commits the transaction,\n   * looking for key in this map is also faster than querying database\n   */\n  private val keysToSave = mutableMapOf<Pair<String?, String>, Key>()\n\n  /**\n   * We need to persist data after everything is checked for resolved conflicts since\n   * thrown ImportConflictNotResolvedException commits the transaction\n   */\n  private val translationService = applicationContext.getBean(TranslationService::class.java)\n\n  private val namespacesToSave = mutableMapOf<String?, Namespace>()\n\n  /**\n   * Keys where base translation was changed, so we need to set outdated flag on all translations\n   */\n  val outdatedFlagKeys: MutableList<Long> = mutableListOf()\n\n  /**\n   * This metas are merged, so there is only one meta for one key!!!\n   *\n   * It can be used only when we are finally importing the data, before that we cannot merge it,\n   * since namespace can be changed\n   */\n  private val storedMetas: MutableMap<Pair<String?, String>, KeyMeta> by lazy {\n    val result: MutableMap<Pair<String?, String>, KeyMeta> = mutableMapOf()\n    keyMetaService.getWithFetchedData(this.import).forEach { currentKeyMeta ->\n      val mapKey = currentKeyMeta.importKey!!.file.namespace to currentKeyMeta.importKey!!.name\n      result[mapKey] = result[mapKey]?.let { existingKeyMeta ->\n        keyMetaService.import(existingKeyMeta, currentKeyMeta)\n        existingKeyMeta\n      } ?: currentKeyMeta\n    }\n    result\n  }\n\n  fun doImport() {\n    importDataManager.storedLanguages.forEach {\n      it.doImport()\n    }\n\n    addKeysAndCheckPermissions()\n\n    handleKeyMetas()\n\n    namespaceService.saveAll(namespacesToSave.values)\n\n    val keyEntitiesToSave = saveKeys()\n\n    saveTranslations()\n\n    saveMetaData(keyEntitiesToSave)\n\n    translationService.setOutdatedBatch(outdatedFlagKeys)\n  }\n\n  private fun saveMetaData(keyEntitiesToSave: MutableCollection<Key>) {\n    keyEntitiesToSave.flatMap {\n      it.keyMeta?.comments ?: emptyList()\n    }.also { keyMetaService.saveAllComments(it) }\n    keyEntitiesToSave.flatMap {\n      it.keyMeta?.codeReferences ?: emptyList()\n    }.also { keyMetaService.saveAllCodeReferences(it) }\n  }\n\n  private fun saveTranslations() {\n    checkTranslationPermissions()\n    translationService.saveAll(translationsToSave)\n  }\n\n  private fun saveKeys(): MutableCollection<Key> {\n    val keyEntitiesToSave = keysToSave.values\n    keyService.saveAll(keyEntitiesToSave)\n    return keyEntitiesToSave\n  }\n\n  private fun addKeysAndCheckPermissions() {\n    addAllKeys()\n    checkKeyPermissions()\n  }\n\n  private fun checkTranslationPermissions() {\n    val langs = translationsToSave.map { it.language }.toSet().map { it.id }\n    securityService.checkLanguageTranslatePermission(import.project.id, langs)\n  }\n\n  private fun checkKeyPermissions() {\n    val isCreatingKey = keysToSave.values.any { it.id == 0L }\n    if (isCreatingKey) {\n      securityService.checkProjectPermission(import.project.id, Scope.KEYS_EDIT)\n    }\n  }\n\n  private fun handleKeyMetas() {\n    this.importDataManager.storedKeys.entries.forEach { (fileNamePair, importKey) ->\n      val importedKeyMeta = storedMetas[fileNamePair.first.namespace to importKey.name]\n      // don't touch key meta when imported key has no meta\n      if (importedKeyMeta != null) {\n        keysToSave[fileNamePair.first.namespace to importKey.name]?.let { newKey ->\n          // if key is obtained or created and meta exists, take it and import the data from the imported one\n          // persist is cascaded on key, so it should be fine\n          val keyMeta = importDataManager.existingMetas[fileNamePair.first.namespace to importKey.name]?.also {\n            keyMetaService.import(it, importedKeyMeta)\n          } ?: importedKeyMeta\n          // also set key and remove import key\n          keyMeta.also {\n            it.key = newKey\n            it.importKey = null\n          }\n          // assign new meta\n          newKey.keyMeta = keyMeta\n        }\n      }\n    }\n  }\n\n  private fun addAllKeys() {\n    importDataManager.storedKeys.map { (fileNamePair, importKey) ->\n      addKeyToSave(importKey.file.namespace, importKey.name)\n    }\n  }\n\n  private fun ImportLanguage.doImport() {\n    importDataManager.populateStoredTranslations(this)\n    importDataManager.handleConflicts(true)\n    importDataManager.getStoredTranslations(this).forEach { it.doImport() }\n  }\n\n  private fun ImportTranslation.doImport() {\n    this.checkConflictResolved()\n    if (this.conflict == null || (this.override && this.resolved) || forceMode == ForceMode.OVERRIDE) {\n      val language = this.language.existingLanguage\n        ?: throw BadRequestException(io.tolgee.constants.Message.EXISTING_LANGUAGE_NOT_SELECTED)\n      val translation = this.conflict ?: Translation().apply {\n        this.language = language\n      }\n      translation.key = existingKey\n      if (language == language.project.baseLanguage && translation.text != this.text) {\n        outdatedFlagKeys.add(translation.key.id)\n      }\n      translation.text = this@doImport.text\n      translation.resetFlags()\n      translationsToSave.add(translation)\n    }\n  }\n\n  private val ImportTranslation.existingKey: Key\n    get() {\n      // get key from already saved keys to save\n      return keysToSave.computeIfAbsent(this.key.file.namespace to this.key.name) {\n        // or get it from conflict or create new one\n        val newKey = this.conflict?.key\n          ?: importDataManager.existingKeys[this.key.file.namespace to this.key.name]\n          ?: Key(name = this.key.name).apply {\n            project = import.project\n            namespace = getNamespace(this@existingKey.key.file.namespace)\n          }\n        newKey\n      }\n    }\n\n  private fun addKeyToSave(namespace: String?, keyName: String): Key {\n    return keysToSave.computeIfAbsent(namespace to keyName) {\n      importDataManager.existingKeys[namespace to keyName] ?: Key(name = keyName).apply {\n        project = import.project\n        this.namespace = getNamespace(namespace)\n      }\n    }\n  }\n\n  private fun ImportTranslation.checkConflictResolved() {\n    if (forceMode == ForceMode.NO_FORCE && this.conflict != null && !this.resolved) {\n      importDataManager.saveAllStoredTranslations()\n      throw ImportConflictNotResolvedException(\n        mutableListOf(this.key.name, this.language.name, this.text).filterNotNull().toMutableList()\n      )\n    }\n  }\n\n  private fun getNamespace(name: String?): Namespace? {\n    name ?: return null\n    return importDataManager.existingNamespaces[name] ?: namespacesToSave.computeIfAbsent(name) {\n      Namespace(name, import.project)\n    }\n  }\n}\n", "package io.tolgee.service.security\n\nimport io.tolgee.constants.Message\nimport io.tolgee.dtos.ComputedPermissionDto\nimport io.tolgee.dtos.cacheable.UserAccountDto\nimport io.tolgee.exceptions.LanguageNotPermittedException\nimport io.tolgee.exceptions.NotFoundException\nimport io.tolgee.exceptions.PermissionException\nimport io.tolgee.model.ApiKey\nimport io.tolgee.model.Project\nimport io.tolgee.model.UserAccount\nimport io.tolgee.model.enums.Scope\nimport io.tolgee.model.translation.Translation\nimport io.tolgee.security.AuthenticationFacade\nimport io.tolgee.service.LanguageService\nimport org.springframework.beans.factory.annotation.Autowired\nimport org.springframework.stereotype.Service\nimport java.io.Serializable\n\n@Service\nclass SecurityService @Autowired constructor(\n  private val authenticationFacade: AuthenticationFacade,\n  private val languageService: LanguageService\n) {\n\n  @set:Autowired\n  lateinit var apiKeyService: ApiKeyService\n\n  @set:Autowired\n  lateinit var permissionService: PermissionService\n\n  @set:Autowired\n  lateinit var userAccountService: UserAccountService\n\n  fun checkAnyProjectPermission(projectId: Long) {\n    if (\n      getProjectPermissionScopes(projectId).isNullOrEmpty() &&\n      !isCurrentUserServerAdmin()\n    )\n      throw PermissionException()\n  }\n\n  fun checkProjectPermission(projectId: Long, requiredScopes: Scope, userAccountDto: UserAccountDto) {\n    checkProjectPermissionOr(projectId, listOf(requiredScopes), userAccountDto)\n  }\n\n  fun checkProjectPermission(projectId: Long, requiredScopes: Scope, apiKey: ApiKey) {\n    checkProjectPermissionOr(listOf(requiredScopes), apiKey)\n  }\n\n  private fun checkProjectPermissionOr(requiredScopes: List<Scope>, apiKey: ApiKey) {\n    this.checkApiKeyScopesOr(requiredScopes, apiKey)\n  }\n\n  fun checkProjectPermissionOr(\n    projectId: Long,\n    requiredScopes: Collection<Scope>,\n    userAccountDto: UserAccountDto\n  ) {\n    if (isUserAdmin(userAccountDto)) {\n      return\n    }\n\n    val allowedScopes = getProjectPermissionScopes(projectId, userAccountDto.id)\n      ?: throw PermissionException(Message.USER_HAS_NO_PROJECT_ACCESS)\n\n    checkProjectPermissionOr(projectId, requiredScopes, allowedScopes)\n  }\n\n  fun checkProjectPermissionOr(\n    projectId: Long,\n    requiredScopes: Collection<Scope>,\n    allowedScopes: Array<Scope>\n  ) {\n    if (!allowedScopes.any { requiredScopes.contains(it) }) {\n      @Suppress(\"UNCHECKED_CAST\")\n      throw PermissionException(\n        Message.OPERATION_NOT_PERMITTED,\n        listOf(requiredScopes.map { it.value }) as List<Serializable>\n      )\n    }\n  }\n\n  fun checkProjectPermission(projectId: Long, requiredPermission: Scope) {\n    val apiKey = activeApiKey ?: return checkProjectPermission(projectId, requiredPermission, activeUser)\n    return checkProjectPermission(projectId, requiredPermission, apiKey)\n  }\n\n  fun checkProjectPermissionOr(projectId: Long, requiredPermissions: Collection<Scope>) {\n    checkProjectPermissionOr(projectId, requiredPermissions, activeUser)\n  }\n\n  fun checkLanguageViewPermissionByTag(projectId: Long, languageTags: Collection<String>) {\n    checkProjectPermission(projectId, Scope.TRANSLATIONS_VIEW)\n    checkLanguagePermissionByTag(\n      projectId,\n      languageTags\n    ) { data, languageIds -> data.checkViewPermitted(*languageIds.toLongArray()) }\n  }\n\n  fun checkLanguageTranslatePermissionByTag(projectId: Long, languageTags: Collection<String>) {\n    checkProjectPermission(projectId, Scope.TRANSLATIONS_EDIT)\n    checkLanguagePermissionByTag(\n      projectId,\n      languageTags\n    ) { data, languageIds -> data.checkTranslatePermitted(*languageIds.toLongArray()) }\n  }\n\n  fun checkStateEditPermissionByTag(projectId: Long, languageTags: Collection<String>) {\n    checkProjectPermission(projectId, Scope.TRANSLATIONS_STATE_EDIT)\n    checkLanguagePermissionByTag(\n      projectId,\n      languageTags\n    ) { data, languageIds -> data.checkTranslatePermitted(*languageIds.toLongArray()) }\n  }\n\n  fun checkLanguageViewPermission(projectId: Long, languageIds: Collection<Long>) {\n    checkProjectPermission(projectId, Scope.TRANSLATIONS_VIEW)\n    checkLanguagePermission(\n      projectId,\n    ) { data -> data.checkViewPermitted(*languageIds.toLongArray()) }\n  }\n\n  fun checkLanguageTranslatePermission(projectId: Long, languageIds: Collection<Long>) {\n    checkProjectPermission(projectId, Scope.TRANSLATIONS_EDIT)\n    checkLanguagePermission(\n      projectId,\n    ) { data -> data.checkTranslatePermitted(*languageIds.toLongArray()) }\n  }\n\n  fun checkLanguageStateChangePermission(projectId: Long, languageIds: Collection<Long>) {\n    checkProjectPermission(projectId, Scope.TRANSLATIONS_STATE_EDIT)\n    checkLanguagePermission(\n      projectId,\n    ) { data -> data.checkStateChangePermitted(*languageIds.toLongArray()) }\n  }\n\n  fun filterViewPermissionByTag(projectId: Long, languageTags: Collection<String>): Set<String> {\n    try {\n      checkLanguageViewPermissionByTag(projectId, languageTags)\n    } catch (e: LanguageNotPermittedException) {\n      return languageTags.toSet() - e.languageTags.orEmpty().toSet()\n    }\n    return languageTags.toSet()\n  }\n\n  private fun checkLanguagePermission(\n    projectId: Long,\n    permissionCheckFn: (data: ComputedPermissionDto) -> Unit\n  ) {\n    if (isCurrentUserServerAdmin()) {\n      return\n    }\n    val usersPermission = permissionService.getProjectPermissionData(\n      projectId,\n      authenticationFacade.userAccount.id\n    )\n    permissionCheckFn(usersPermission.computedPermissions)\n  }\n\n  private fun checkLanguagePermissionByTag(\n    projectId: Long,\n    languageTags: Collection<String>,\n    fn: (data: ComputedPermissionDto, languageIds: Collection<Long>) -> Unit\n  ) {\n    val languageIds = languageService.getLanguageIdsByTags(projectId, languageTags)\n    try {\n      val usersPermission = permissionService.getProjectPermissionData(\n        projectId,\n        authenticationFacade.userAccount.id\n      )\n      fn(usersPermission.computedPermissions, languageIds.values.map { it.id })\n    } catch (e: LanguageNotPermittedException) {\n      throw LanguageNotPermittedException(\n        e.languageIds,\n        e.languageIds.mapNotNull { languageId -> languageIds.entries.find { it.value.id == languageId }?.key }\n      )\n    }\n  }\n\n  fun checkLanguageTranslatePermission(translation: Translation) {\n    val language = translation.language\n    checkLanguageTranslatePermission(language.project.id, listOf(language.id))\n  }\n\n  fun checkStateChangePermission(translation: Translation) {\n    val language = translation.language\n    checkLanguageStateChangePermission(language.project.id, listOf(language.id))\n  }\n\n  fun checkLanguageTagPermissions(tags: Set<String>, projectId: Long) {\n    val languages = languageService.findByTags(tags, projectId)\n    this.checkLanguageTranslatePermission(projectId, languages.map { it.id })\n  }\n\n  fun checkApiKeyScopes(scopes: Set<Scope>, project: Project?, user: UserAccount? = null) {\n    try {\n      val availableScopes = apiKeyService.getAvailableScopes(user?.id ?: activeUser.id, project!!)\n      val userCanSelectTheScopes = availableScopes.toList().containsAll(scopes)\n      if (!userCanSelectTheScopes) {\n        throw PermissionException()\n      }\n    } catch (e: NotFoundException) {\n      throw PermissionException()\n    }\n  }\n\n  fun fixInvalidApiKeyWhenRequired(apiKey: ApiKey) {\n    val oldSize = apiKey.scopesEnum.size\n    apiKey.scopesEnum.removeIf {\n      getProjectPermissionScopes(\n        apiKey.project.id,\n        apiKey.userAccount.id\n      )?.contains(it) != true\n    }\n    if (oldSize != apiKey.scopesEnum.size) {\n      apiKeyService.save(apiKey)\n    }\n  }\n\n  fun checkApiKeyScopes(scopes: Set<Scope>, apiKey: ApiKey) {\n    checkApiKeyScopes(apiKey) { expandedScopes ->\n      if (!expandedScopes.toList().containsAll(scopes)) {\n        throw PermissionException()\n      }\n    }\n  }\n\n  fun checkApiKeyScopesOr(scopes: Collection<Scope>, apiKey: ApiKey) {\n    checkApiKeyScopes(apiKey) { expandedScopes ->\n      if (!expandedScopes.any { it in apiKey.scopesEnum }) {\n        throw PermissionException()\n      }\n    }\n  }\n\n  private fun checkApiKeyScopes(apiKey: ApiKey, checkFn: (expandedScopes: Array<Scope>) -> Unit) {\n    val expandedScopes = Scope.expand(apiKey.scopesEnum)\n    checkFn(expandedScopes)\n  }\n\n  fun checkScreenshotsUploadPermission(projectId: Long) {\n    if (authenticationFacade.isApiKeyAuthentication) {\n      checkApiKeyScopes(setOf(Scope.SCREENSHOTS_UPLOAD), authenticationFacade.apiKey)\n    }\n    checkProjectPermission(projectId, Scope.SCREENSHOTS_UPLOAD)\n  }\n\n  fun checkUserIsServerAdmin() {\n    if (authenticationFacade.userAccount.role != UserAccount.Role.ADMIN) {\n      throw PermissionException()\n    }\n  }\n\n  fun getProjectPermissionScopes(projectId: Long, userId: Long = activeUser.id): Array<Scope>? {\n    return permissionService.getProjectPermissionScopes(projectId, userId)\n  }\n\n  private fun isCurrentUserServerAdmin(): Boolean {\n    return isUserAdmin(activeUser)\n  }\n\n  private fun isUserAdmin(user: UserAccountDto): Boolean {\n    return user.role == UserAccount.Role.ADMIN\n  }\n\n  private val activeUser: UserAccountDto\n    get() = authenticationFacade.userAccountOrNull ?: throw PermissionException()\n\n  private val activeApiKey: ApiKey?\n    get() = authenticationFacade.apiKeyOrNull\n}\n", "spring:\n  jpa:\n    show-sql: true\n    properties:\n      hibernate:\n        jdbc:\n          batch_size: 1000\n        order_inserts: true\n        order_updates: true\n        dialect: io.tolgee.dialects.postgres.CustomPostgreSQLDialect\n  mvc:\n    pathmatch:\n      matching-strategy: ant_path_matcher\n  data:\n    redis:\n      repositories:\n        enabled: false\n  main:\n    allow-bean-definition-overriding: true\n    lazy-initialization: true\n  liquibase:\n    change-log: classpath:db/changelog/schema.xml\n  batch:\n    job:\n      enabled: false\n    jdbc:\n      initialize-schema: always\n  jmx:\n    enabled: false\ntolgee:\n  postgres-autostart:\n    enabled: true\n    container-name: tolgee_backend_tests_postgres\n    port: 55433\n  data-path: ./build/test_data\n  authentication:\n    native-enabled: true\n    registrationsAllowed: true\n    create-initial-user: false\n    oauth2:\n      client-id: fake_client_id\n      client-secret: fake_client_secret\n      scopes:\n        - openid\n        - email\n        - profile\n      authorization-url: \"https://example.com/authorize\"\n      token-url: \"https://example.com/oauth/token\"\n      user-url: \"https://example.com/userinfo\"\n  internal:\n    fake-mt-providers: true\n    mock-free-plan: true\n  socket-io:\n    port: 19090\n    enabled: false\n  cache:\n    caffeine-max-size: 1000\n  machine-translation:\n    free-credits-amount: -1\n    google:\n      api-key: aaa\n    aws:\n      accessKey: aaa\n      secretKey: aaa\n  billing:\n    enabled: false\n  telemetry:\n    enabled: false\n\nmanagement:\n  endpoint:\n    metrics:\n      enabled: false\n\nspringdoc:\n  api-docs:\n    enabled: false\n\n#logging:\n#  level:\n#    org.springframework.orm.jpa: DEBUG\n#    org.springframework.transaction: DEBUG\n#    org.hibernate.type: TRACE\n\n"], "fixing_code": ["/*\n * Copyright (c) 2020. Tolgee\n */\n\npackage io.tolgee.api.v2.controllers\n\nimport io.swagger.v3.oas.annotations.Operation\nimport io.swagger.v3.oas.annotations.Parameter\nimport io.swagger.v3.oas.annotations.tags.Tag\nimport io.tolgee.activity.RequestActivity\nimport io.tolgee.activity.data.ActivityType\nimport io.tolgee.dtos.dataImport.ImportAddFilesParams\nimport io.tolgee.dtos.dataImport.ImportFileDto\nimport io.tolgee.dtos.dataImport.SetFileNamespaceRequest\nimport io.tolgee.exceptions.BadRequestException\nimport io.tolgee.exceptions.ErrorResponseBody\nimport io.tolgee.exceptions.NotFoundException\nimport io.tolgee.hateoas.dataImport.ImportAddFilesResultModel\nimport io.tolgee.hateoas.dataImport.ImportLanguageModel\nimport io.tolgee.hateoas.dataImport.ImportLanguageModelAssembler\nimport io.tolgee.hateoas.dataImport.ImportNamespaceModel\nimport io.tolgee.hateoas.dataImport.ImportTranslationModel\nimport io.tolgee.hateoas.dataImport.ImportTranslationModelAssembler\nimport io.tolgee.model.Language\nimport io.tolgee.model.dataImport.ImportFile\nimport io.tolgee.model.dataImport.ImportLanguage\nimport io.tolgee.model.dataImport.ImportTranslation\nimport io.tolgee.model.enums.Scope\nimport io.tolgee.model.views.ImportFileIssueView\nimport io.tolgee.model.views.ImportLanguageView\nimport io.tolgee.model.views.ImportTranslationView\nimport io.tolgee.security.AuthenticationFacade\nimport io.tolgee.security.apiKeyAuth.AccessWithApiKey\nimport io.tolgee.security.project_auth.AccessWithAnyProjectPermission\nimport io.tolgee.security.project_auth.ProjectHolder\nimport io.tolgee.service.LanguageService\nimport io.tolgee.service.dataImport.ForceMode\nimport io.tolgee.service.dataImport.ImportService\nimport io.tolgee.service.key.NamespaceService\nimport io.tolgee.service.security.SecurityService\nimport org.springdoc.api.annotations.ParameterObject\nimport org.springframework.data.domain.PageRequest\nimport org.springframework.data.domain.Pageable\nimport org.springframework.data.web.PagedResourcesAssembler\nimport org.springframework.data.web.SortDefault\nimport org.springframework.hateoas.CollectionModel\nimport org.springframework.hateoas.EntityModel\nimport org.springframework.hateoas.PagedModel\nimport org.springframework.hateoas.server.mvc.RepresentationModelAssemblerSupport\nimport org.springframework.http.MediaType\nimport org.springframework.web.bind.annotation.CrossOrigin\nimport org.springframework.web.bind.annotation.DeleteMapping\nimport org.springframework.web.bind.annotation.GetMapping\nimport org.springframework.web.bind.annotation.PathVariable\nimport org.springframework.web.bind.annotation.PostMapping\nimport org.springframework.web.bind.annotation.PutMapping\nimport org.springframework.web.bind.annotation.RequestBody\nimport org.springframework.web.bind.annotation.RequestMapping\nimport org.springframework.web.bind.annotation.RequestParam\nimport org.springframework.web.bind.annotation.RequestPart\nimport org.springframework.web.bind.annotation.RestController\nimport org.springframework.web.multipart.MultipartFile\nimport javax.servlet.http.HttpServletRequest\n\n@Suppress(\"MVCPathVariableInspection\")\n@RestController\n@CrossOrigin(origins = [\"*\"])\n@RequestMapping(value = [\"/v2/projects/{projectId:\\\\d+}/import\", \"/v2/projects/import\"])\n@Tag(\n  name = \"Import\",\n  description = \"These endpoints handle multi-step data import\"\n)\nclass V2ImportController(\n  private val importService: ImportService,\n  private val authenticationFacade: AuthenticationFacade,\n  private val importLanguageModelAssembler: ImportLanguageModelAssembler,\n  private val importTranslationModelAssembler: ImportTranslationModelAssembler,\n  @Suppress(\"SpringJavaInjectionPointsAutowiringInspection\")\n  private val pagedLanguagesResourcesAssembler: PagedResourcesAssembler<ImportLanguageView>,\n\n  @Suppress(\"SpringJavaInjectionPointsAutowiringInspection\")\n  private val pagedTranslationsResourcesAssembler: PagedResourcesAssembler<ImportTranslationView>,\n\n  @Suppress(\"SpringJavaInjectionPointsAutowiringInspection\")\n  private val pagedImportFileIssueResourcesAssembler: PagedResourcesAssembler<ImportFileIssueView>,\n  private val projectHolder: ProjectHolder,\n  private val languageService: LanguageService,\n  private val namespaceService: NamespaceService,\n  private val securityService: SecurityService\n) {\n  @PostMapping(\"\", consumes = [MediaType.MULTIPART_FORM_DATA_VALUE])\n  @AccessWithAnyProjectPermission()\n  @AccessWithApiKey()\n  @Operation(description = \"Prepares provided files to import.\", summary = \"Add files\")\n  fun addFiles(\n    @RequestPart(\"files\") files: Array<MultipartFile>,\n    @ParameterObject params: ImportAddFilesParams\n  ): ImportAddFilesResultModel {\n    checkBaseImportPermissions()\n    val fileDtos = files.map { ImportFileDto(it.originalFilename ?: \"\", it.inputStream) }\n    val errors = importService.addFiles(\n      files = fileDtos,\n      project = projectHolder.projectEntity,\n      userAccount = authenticationFacade.userAccountEntity,\n      params = params\n    )\n    return getImportAddFilesResultModel(errors)\n  }\n\n  private fun getImportAddFilesResultModel(\n    errors: List<ErrorResponseBody>\n  ): ImportAddFilesResultModel {\n    val result: PagedModel<ImportLanguageModel>? = try {\n      this.getImportResult(PageRequest.of(0, 100))\n    } catch (e: NotFoundException) {\n      null\n    }\n    return ImportAddFilesResultModel(errors, result)\n  }\n\n  @PutMapping(\"/apply\")\n  @AccessWithAnyProjectPermission()\n  @AccessWithApiKey()\n  @Operation(description = \"Imports the data prepared in previous step\", summary = \"Apply\")\n  @RequestActivity(ActivityType.IMPORT)\n  fun applyImport(\n    @Parameter(description = \"Whether override or keep all translations with unresolved conflicts\")\n    @RequestParam(defaultValue = \"NO_FORCE\")\n    forceMode: ForceMode,\n  ) {\n    val projectId = projectHolder.project.id\n    checkBaseImportPermissions()\n    this.importService.import(projectId, authenticationFacade.userAccount.id, forceMode)\n  }\n\n  private fun checkBaseImportPermissions() {\n    securityService.checkProjectPermission(projectHolder.project.id, Scope.TRANSLATIONS_VIEW)\n  }\n\n  @GetMapping(\"/result\")\n  @AccessWithAnyProjectPermission()\n  @AccessWithApiKey()\n  @Operation(description = \"Returns the result of preparation.\", summary = \"Get result\")\n  fun getImportResult(\n    @ParameterObject pageable: Pageable\n  ): PagedModel<ImportLanguageModel> {\n    checkBaseImportPermissions()\n    val projectId = projectHolder.project.id\n    val userId = authenticationFacade.userAccount.id\n    val languages = importService.getResult(projectId, userId, pageable)\n    return pagedLanguagesResourcesAssembler.toModel(languages, importLanguageModelAssembler)\n  }\n\n  @GetMapping(\"/result/languages/{languageId}\")\n  @AccessWithAnyProjectPermission()\n  @AccessWithApiKey()\n  @Operation(description = \"Returns language prepared to import.\", summary = \"Get import language\")\n  fun getImportLanguage(\n    @PathVariable(\"languageId\") languageId: Long,\n  ): ImportLanguageModel {\n    checkBaseImportPermissions()\n    checkImportLanguageInProject(languageId)\n    val language = importService.findLanguageView(languageId) ?: throw NotFoundException()\n    return importLanguageModelAssembler.toModel(language)\n  }\n\n  @GetMapping(\"/result/languages/{languageId}/translations\")\n  @AccessWithAnyProjectPermission()\n  @AccessWithApiKey()\n  @Operation(description = \"Returns translations prepared to import.\", summary = \"Get translations\")\n  fun getImportTranslations(\n    @PathVariable(\"projectId\") projectId: Long,\n    @PathVariable(\"languageId\") languageId: Long,\n    @Parameter(\n      description = \"Whether only translations, which are in conflict \" +\n        \"with existing translations should be returned\"\n    )\n    @RequestParam(\"onlyConflicts\", defaultValue = \"false\") onlyConflicts: Boolean = false,\n    @Parameter(\n      description = \"Whether only translations with unresolved conflicts\" +\n        \"with existing translations should be returned\"\n    )\n    @RequestParam(\"onlyUnresolved\", defaultValue = \"false\") onlyUnresolved: Boolean = false,\n    @Parameter(description = \"String to search in translation text or key\")\n    @RequestParam(\"search\") search: String? = null,\n    @ParameterObject @SortDefault(\"keyName\") pageable: Pageable\n  ): PagedModel<ImportTranslationModel> {\n    checkBaseImportPermissions()\n    checkImportLanguageInProject(languageId)\n    val translations = importService.getTranslationsView(languageId, pageable, onlyConflicts, onlyUnresolved, search)\n    return pagedTranslationsResourcesAssembler.toModel(translations, importTranslationModelAssembler)\n  }\n\n  @DeleteMapping(\"\")\n  @AccessWithAnyProjectPermission()\n  @AccessWithApiKey()\n  @Operation(description = \"Deletes prepared import data.\", summary = \"Delete\")\n  fun cancelImport() {\n    checkBaseImportPermissions()\n    this.importService.deleteImport(projectHolder.project.id, authenticationFacade.userAccount.id)\n  }\n\n  @DeleteMapping(\"/result/languages/{languageId}\")\n  @AccessWithAnyProjectPermission()\n  @AccessWithApiKey()\n  @Operation(description = \"Deletes language prepared to import.\", summary = \"Delete language\")\n  fun deleteLanguage(@PathVariable(\"languageId\") languageId: Long) {\n    checkBaseImportPermissions()\n    val language = checkImportLanguageInProject(languageId)\n    this.importService.deleteLanguage(language)\n  }\n\n  @PutMapping(\"/result/languages/{languageId}/translations/{translationId}/resolve/set-override\")\n  @AccessWithAnyProjectPermission()\n  @AccessWithApiKey()\n  @Operation(\n    description = \"Resolves translation conflict. The old translation will be overridden.\",\n    summary = \"Resolve conflict (override)\"\n  )\n  fun resolveTranslationSetOverride(\n    @PathVariable(\"languageId\") languageId: Long,\n    @PathVariable(\"translationId\") translationId: Long\n  ) {\n    checkBaseImportPermissions()\n    resolveTranslation(languageId, translationId, true)\n  }\n\n  @PutMapping(\"/result/languages/{languageId}/translations/{translationId}/resolve/set-keep-existing\")\n  @AccessWithAnyProjectPermission()\n  @AccessWithApiKey()\n  @Operation(\n    description = \"Resolves translation conflict. The old translation will be kept.\",\n    summary = \"Resolve conflict (keep existing)\"\n  )\n  fun resolveTranslationSetKeepExisting(\n    @PathVariable(\"languageId\") languageId: Long,\n    @PathVariable(\"translationId\") translationId: Long\n  ) {\n    checkBaseImportPermissions()\n    resolveTranslation(languageId, translationId, false)\n  }\n\n  @PutMapping(\"/result/languages/{languageId}/resolve-all/set-override\")\n  @AccessWithAnyProjectPermission()\n  @AccessWithApiKey()\n  @Operation(\n    description = \"Resolves all translation conflicts for provided language. The old translations will be overridden.\",\n    summary = \"Resolve all translation conflicts (override)\"\n  )\n  fun resolveTranslationSetOverride(\n    @PathVariable(\"languageId\") languageId: Long\n  ) {\n    checkBaseImportPermissions()\n    resolveAllOfLanguage(languageId, true)\n  }\n\n  @PutMapping(\"/result/languages/{languageId}/resolve-all/set-keep-existing\")\n  @AccessWithAnyProjectPermission()\n  @AccessWithApiKey()\n  @Operation(\n    description = \"Resolves all translation conflicts for provided language. The old translations will be kept.\",\n    summary = \"Resolve all translation conflicts (keep existing)\"\n  )\n  fun resolveTranslationSetKeepExisting(\n    @PathVariable(\"languageId\") languageId: Long,\n  ) {\n    checkBaseImportPermissions()\n    resolveAllOfLanguage(languageId, false)\n  }\n\n  @PutMapping(\"/result/files/{fileId}/select-namespace\")\n  @AccessWithAnyProjectPermission()\n  @AccessWithApiKey()\n  @Operation(\n    description = \"Sets namespace for file to import.\",\n    summary = \"Select namespace\"\n  )\n  fun selectNamespace(\n    @PathVariable fileId: Long,\n    @RequestBody req: SetFileNamespaceRequest,\n    request: HttpServletRequest\n  ) {\n    checkBaseImportPermissions()\n    val file = checkFileFromProject(fileId)\n    this.importService.selectNamespace(file, req.namespace)\n  }\n\n  @PutMapping(\"/result/languages/{importLanguageId}/select-existing/{existingLanguageId}\")\n  @AccessWithAnyProjectPermission()\n  @AccessWithApiKey()\n  @Operation(\n    description = \"Sets existing language to pair with language to import. \" +\n      \"Data will be imported to selected existing language when applied.\",\n    summary = \"Pair existing language\"\n  )\n  fun selectExistingLanguage(\n    @PathVariable(\"importLanguageId\") importLanguageId: Long,\n    @PathVariable(\"existingLanguageId\") existingLanguageId: Long,\n  ) {\n    checkBaseImportPermissions()\n    val existingLanguage = checkLanguageFromProject(existingLanguageId)\n    val importLanguage = checkImportLanguageInProject(importLanguageId)\n    this.importService.selectExistingLanguage(importLanguage, existingLanguage)\n  }\n\n  @PutMapping(\"/result/languages/{importLanguageId}/reset-existing\")\n  @AccessWithAnyProjectPermission()\n  @AccessWithApiKey()\n  @Operation(\n    description = \"Resets existing language paired with language to import.\",\n    summary = \"Reset existing language pairing\"\n  )\n  fun resetExistingLanguage(\n    @PathVariable(\"importLanguageId\") importLanguageId: Long,\n  ) {\n    checkBaseImportPermissions()\n    val importLanguage = checkImportLanguageInProject(importLanguageId)\n    this.importService.selectExistingLanguage(importLanguage, null)\n  }\n\n  @GetMapping(\"/result/files/{importFileId}/issues\")\n  @AccessWithAnyProjectPermission()\n  @AccessWithApiKey()\n  @Operation(\n    description = \"Returns issues for uploaded file.\",\n    summary = \"Get file issues\"\n  )\n  fun getImportFileIssues(\n    @PathVariable(\"importFileId\") importFileId: Long,\n    @ParameterObject pageable: Pageable\n  ): PagedModel<EntityModel<ImportFileIssueView>> {\n    checkFileFromProject(importFileId)\n    val page = importService.getFileIssues(importFileId, pageable)\n    return pagedImportFileIssueResourcesAssembler.toModel(page)\n  }\n\n  @GetMapping(\"/all-namespaces\")\n  @AccessWithAnyProjectPermission()\n  @AccessWithApiKey()\n  @Operation(\n    description = \"Returns all existing and imported namespaces\",\n    summary = \"Get namespaces\"\n  )\n  fun getAllNamespaces(): CollectionModel<ImportNamespaceModel> {\n    checkBaseImportPermissions()\n    val import = importService.get(\n      projectId = projectHolder.project.id,\n      authorId = authenticationFacade.userAccount.id\n    )\n    val importNamespaces = importService.getAllNamespaces(import.id)\n    val existingNamespaces = namespaceService.getAllInProject(projectId = projectHolder.project.id)\n    val result = existingNamespaces\n      .map { it.name to ImportNamespaceModel(it.id, it.name) }\n      .toMap(mutableMapOf())\n    importNamespaces.filterNotNull().forEach { importNamespace ->\n      result.computeIfAbsent(importNamespace) {\n        ImportNamespaceModel(id = null, name = importNamespace)\n      }\n    }\n\n    return getNamespacesCollectionModel(result)\n  }\n\n  private fun getNamespacesCollectionModel(\n    result: MutableMap<String, ImportNamespaceModel>\n  ): CollectionModel<ImportNamespaceModel> {\n    val assembler = object : RepresentationModelAssemblerSupport<ImportNamespaceModel, ImportNamespaceModel>(\n      this::class.java,\n      ImportNamespaceModel::class.java\n    ) {\n      override fun toModel(entity: ImportNamespaceModel): ImportNamespaceModel = entity\n    }\n\n    return assembler.toCollectionModel(result.values.sortedBy { it.name })\n  }\n\n  private fun resolveAllOfLanguage(languageId: Long, override: Boolean) {\n    val language = checkImportLanguageInProject(languageId)\n    importService.resolveAllOfLanguage(language, override)\n  }\n\n  private fun resolveTranslation(languageId: Long, translationId: Long, override: Boolean) {\n    checkImportLanguageInProject(languageId)\n    val translation = checkTranslationOfLanguage(translationId, languageId)\n    return importService.resolveTranslationConflict(translation, override)\n  }\n\n  private fun checkFileFromProject(fileId: Long): ImportFile {\n    val file = importService.findFile(fileId) ?: throw NotFoundException()\n    if (file.import.project.id != projectHolder.project.id) {\n      throw BadRequestException(io.tolgee.constants.Message.IMPORT_LANGUAGE_NOT_FROM_PROJECT)\n    }\n    return file\n  }\n\n  private fun checkLanguageFromProject(languageId: Long): Language {\n    val existingLanguage = languageService.findById(languageId).orElse(null) ?: throw NotFoundException()\n    if (existingLanguage.project.id != projectHolder.project.id) {\n      throw BadRequestException(io.tolgee.constants.Message.IMPORT_LANGUAGE_NOT_FROM_PROJECT)\n    }\n    return existingLanguage\n  }\n\n  private fun checkImportLanguageInProject(languageId: Long): ImportLanguage {\n    val language = importService.findLanguage(languageId) ?: throw NotFoundException()\n    val languageProjectId = language.file.import.project.id\n    if (languageProjectId != projectHolder.project.id) {\n      throw BadRequestException(io.tolgee.constants.Message.IMPORT_LANGUAGE_NOT_FROM_PROJECT)\n    }\n    return language\n  }\n\n  private fun checkTranslationOfLanguage(translationId: Long, languageId: Long): ImportTranslation {\n    val translation = importService.findTranslation(translationId) ?: throw NotFoundException()\n\n    if (translation.language.id != languageId) {\n      throw BadRequestException(io.tolgee.constants.Message.IMPORT_LANGUAGE_NOT_FROM_PROJECT)\n    }\n    return translation\n  }\n}\n", "package io.tolgee.websocket\n\nimport io.tolgee.dtos.cacheable.UserAccountDto\nimport io.tolgee.model.enums.Scope\nimport io.tolgee.security.JwtTokenProvider\nimport io.tolgee.service.security.SecurityService\nimport org.springframework.context.annotation.Configuration\nimport org.springframework.messaging.Message\nimport org.springframework.messaging.MessageChannel\nimport org.springframework.messaging.MessagingException\nimport org.springframework.messaging.simp.config.ChannelRegistration\nimport org.springframework.messaging.simp.config.MessageBrokerRegistry\nimport org.springframework.messaging.simp.stomp.StompCommand\nimport org.springframework.messaging.simp.stomp.StompHeaderAccessor\nimport org.springframework.messaging.support.ChannelInterceptor\nimport org.springframework.messaging.support.MessageHeaderAccessor\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken\nimport org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker\nimport org.springframework.web.socket.config.annotation.StompEndpointRegistry\nimport org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer\n\n@Configuration\n@EnableWebSocketMessageBroker\nclass WebSocketConfig(\n  private val jwtTokenProvider: JwtTokenProvider,\n  private val securityService: SecurityService,\n) : WebSocketMessageBrokerConfigurer {\n  override fun configureMessageBroker(config: MessageBrokerRegistry) {\n    config.enableSimpleBroker(\"/\")\n  }\n\n  override fun registerStompEndpoints(registry: StompEndpointRegistry) {\n    registry.addEndpoint(\"/websocket\").setAllowedOriginPatterns(\"*\").withSockJS()\n  }\n\n  override fun configureClientInboundChannel(registration: ChannelRegistration) {\n    registration.interceptors(object : ChannelInterceptor {\n      override fun preSend(message: Message<*>, channel: MessageChannel): Message<*>? {\n        val accessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor::class.java)\n\n        if (accessor?.command == StompCommand.CONNECT) {\n          val tokenString = accessor.getNativeHeader(\"jwtToken\")?.firstOrNull()\n          accessor.user = jwtTokenProvider.getAuthentication(tokenString)\n        }\n\n        if (accessor?.command == StompCommand.SUBSCRIBE) {\n          val projectId = accessor.destination?.let {\n            \"/projects/([0-9]+)\".toRegex().find(it)?.groupValues\n              ?.getOrNull(1)?.toLong()\n          }\n\n          if (projectId != null) {\n            try {\n              val user = (accessor.user as? UsernamePasswordAuthenticationToken)?.principal as UserAccountDto\n              securityService.checkProjectPermissionNoApiKey(projectId = projectId, Scope.TRANSLATIONS_VIEW, user)\n            } catch (e: Exception) {\n              throw MessagingException(\"Forbidden\")\n            }\n          }\n        }\n\n        return message\n      }\n\n      override fun postReceive(message: Message<*>, channel: MessageChannel): Message<*>? {\n        return super.postReceive(message, channel)\n      }\n    })\n  }\n}\n", "package io.tolgee.api.v2.controllers.v2ImportController\n\nimport io.tolgee.ProjectAuthControllerTest\nimport io.tolgee.constants.MtServiceType\nimport io.tolgee.development.testDataBuilder.data.dataImport.ImportTestData\nimport io.tolgee.fixtures.andAssertThatJson\nimport io.tolgee.fixtures.andIsForbidden\nimport io.tolgee.fixtures.andIsOk\nimport io.tolgee.fixtures.isValidId\nimport io.tolgee.fixtures.node\nimport io.tolgee.model.enums.Scope\nimport io.tolgee.testing.annotations.ProjectApiKeyAuthTestMethod\nimport io.tolgee.testing.assert\nimport io.tolgee.testing.assertions.Assertions.assertThat\nimport org.junit.jupiter.api.Test\n\nclass V2ImportControllerApplicationTest : ProjectAuthControllerTest(\"/v2/projects/\") {\n  @Test\n  fun `it applies the import`() {\n    val testData = ImportTestData()\n    testData.setAllResolved()\n    testData.setAllOverride()\n    testDataService.saveTestData(testData.root)\n    val user = testData.root.data.userAccounts[0].self\n    val projectId = testData.project.id\n    loginAsUser(user.username)\n    val path = \"/v2/projects/$projectId/import/apply\"\n    performAuthPut(path, null).andIsOk\n    this.importService.find(projectId, user.id).let {\n      assertThat(it).isNull()\n    }\n  }\n\n  @Test\n  fun `it applies the import with force override`() {\n    val testData = ImportTestData()\n    testDataService.saveTestData(testData.root)\n    val user = testData.root.data.userAccounts[0].self\n    val projectId = testData.project.id\n    loginAsUser(user.username)\n    val path = \"/v2/projects/$projectId/import/apply?forceMode=OVERRIDE\"\n    performAuthPut(path, null).andIsOk\n    this.importService.find(projectId, user.id).let {\n      assertThat(it).isNull()\n    }\n  }\n\n  @Test\n  fun `it applies the import with force keep`() {\n    val testData = ImportTestData()\n    testDataService.saveTestData(testData.root)\n    val user = testData.root.data.userAccounts[0].self\n    val projectId = testData.project.id\n    loginAsUser(user.username)\n    val path = \"/v2/projects/$projectId/import/apply?forceMode=KEEP\"\n    performAuthPut(path, null).andIsOk\n  }\n\n  @Test\n  fun `it imports empty keys`() {\n    val testData = ImportTestData()\n    testData.addEmptyKey()\n    testDataService.saveTestData(testData.root)\n    val user = testData.root.data.userAccounts[0].self\n    val projectId = testData.project.id\n    loginAsUser(user.username)\n    val path = \"/v2/projects/$projectId/import/apply?forceMode=KEEP\"\n    performAuthPut(path, null).andIsOk\n\n    executeInNewTransaction {\n      projectService.get(testData.project.id).keys.find { it.name == \"empty key\" }.assert.isNotNull\n    }\n  }\n\n  @Test\n  fun `it checks permissions`() {\n    val testData = ImportTestData()\n\n    val user = testData.useTranslateOnlyUser()\n\n    testDataService.saveTestData(testData.root)\n    val projectId = testData.project.id\n    loginAsUser(user.username)\n\n    val path = \"/v2/projects/$projectId/import/apply?forceMode=OVERRIDE\"\n    performAuthPut(path, null).andIsForbidden.andAssertThatJson {\n      node(\"params\") {\n        node(\"[0]\").isEqualTo(\"\"\"\"keys.create\"\"\"\")\n      }\n    }\n  }\n\n  @Test\n  fun `it checks language permissions`() {\n    val testData = ImportTestData()\n    testData.importBuilder.data.importFiles[0].data.importKeys.removeIf { it.self == testData.newLongKey }\n    val resolveFrench = testData.addFrenchTranslations()\n    resolveFrench()\n\n    val user = testData.useTranslateOnlyUser()\n\n    testDataService.saveTestData(testData.root)\n    val projectId = testData.project.id\n    loginAsUser(user.username)\n\n    val path = \"/v2/projects/$projectId/import/apply?forceMode=OVERRIDE\"\n    performAuthPut(path, null).andIsForbidden.andAssertThatJson {\n      node(\"code\").isEqualTo(\"language_not_permitted\")\n      node(\"params[0]\") {\n        isArray\n        node(\"[0]\").isValidId\n      }\n    }\n  }\n\n  @Test\n  fun `it checks permissions (view only)`() {\n    val testData = ImportTestData()\n    testData.importBuilder.data.importFiles[0].data.importKeys.removeIf { it.self == testData.newLongKey }\n    val resolveFrench = testData.addFrenchTranslations()\n    resolveFrench()\n\n    val user = testData.useViewEnOnlyUser()\n\n    testDataService.saveTestData(testData.root)\n    val projectId = testData.project.id\n    loginAsUser(user.username)\n\n    val path = \"/v2/projects/$projectId/import/apply?forceMode=OVERRIDE\"\n    performAuthPut(path, null).andIsForbidden\n  }\n\n  @Test\n  @ProjectApiKeyAuthTestMethod(scopes = [Scope.TRANSLATIONS_VIEW])\n  fun `it checks permissions with API key (view only)`() {\n    val testData = ImportTestData()\n    testData.importBuilder.data.importFiles[0].data.importKeys.removeIf { it.self == testData.newLongKey }\n    val resolveFrench = testData.addFrenchTranslations()\n    resolveFrench()\n\n    testDataService.saveTestData(testData.root)\n    projectSupplier = { testData.project }\n    userAccount = testData.userAccount\n\n    val path = \"import/apply?forceMode=OVERRIDE\"\n    performProjectAuthPut(path, null).andIsForbidden\n  }\n\n  @Test\n  fun `it sets outdated on update`() {\n    val testData = ImportTestData()\n    testDataService.saveTestData(testData.root)\n    val user = testData.root.data.userAccounts[0].self\n    val projectId = testData.project.id\n    loginAsUser(user.username)\n    val path = \"/v2/projects/$projectId/import/apply?forceMode=OVERRIDE\"\n    performAuthPut(path, null).andIsOk\n\n    executeInNewTransaction {\n      val key = projectService.get(testData.project.id)\n        .keys.find { it.name == \"what a nice key\" }!!\n\n      val untouched = key.translations.find { it.language == testData.french }!!\n      untouched.outdated.assert.isEqualTo(true)\n      untouched.mtProvider.assert.isEqualTo(MtServiceType.GOOGLE)\n      untouched.auto.assert.isEqualTo(true)\n\n      val touched = key.translations.find { it.language == testData.english }!!\n      touched.outdated.assert.isEqualTo(false)\n      touched.mtProvider.assert.isEqualTo(null)\n      touched.auto.assert.isEqualTo(false)\n    }\n  }\n}\n", "package io.tolgee.api.v2.controllers.v2KeyController\n\nimport io.tolgee.ProjectAuthControllerTest\nimport io.tolgee.development.testDataBuilder.data.KeysTestData\nimport io.tolgee.dtos.request.KeyInScreenshotPositionDto\nimport io.tolgee.dtos.request.key.CreateKeyDto\nimport io.tolgee.dtos.request.key.KeyScreenshotDto\nimport io.tolgee.exceptions.FileStoreException\nimport io.tolgee.fixtures.andAssertThatJson\nimport io.tolgee.fixtures.andIsCreated\nimport io.tolgee.fixtures.andIsForbidden\nimport io.tolgee.fixtures.andPrettyPrint\nimport io.tolgee.fixtures.isValidId\nimport io.tolgee.fixtures.node\nimport io.tolgee.model.enums.Scope\nimport io.tolgee.service.ImageUploadService\nimport io.tolgee.testing.annotations.ProjectApiKeyAuthTestMethod\nimport io.tolgee.testing.annotations.ProjectJWTAuthTestMethod\nimport io.tolgee.testing.assertions.Assertions.assertThat\nimport io.tolgee.util.generateImage\nimport org.junit.jupiter.api.BeforeEach\nimport org.junit.jupiter.api.Test\nimport org.junit.jupiter.api.assertThrows\nimport org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc\nimport org.springframework.boot.test.context.SpringBootTest\nimport org.springframework.core.io.InputStreamSource\nimport java.math.BigDecimal\n\n@SpringBootTest\n@AutoConfigureMockMvc\nclass KeyControllerCreationTest : ProjectAuthControllerTest(\"/v2/projects/\") {\n\n  lateinit var testData: KeysTestData\n\n  val screenshotFile: InputStreamSource by lazy {\n    generateImage(2000, 3000)\n  }\n\n  @BeforeEach\n  fun setup() {\n    testData = KeysTestData()\n    testDataService.saveTestData(testData.root)\n    userAccount = testData.user\n    this.projectSupplier = { testData.project }\n  }\n\n  @ProjectJWTAuthTestMethod\n  @Test\n  fun `creates key`() {\n    performProjectAuthPost(\"keys\", CreateKeyDto(name = \"super_key\"))\n      .andIsCreated.andPrettyPrint.andAssertThatJson {\n        node(\"id\").isValidId\n        node(\"name\").isEqualTo(\"super_key\")\n      }\n  }\n\n  @ProjectJWTAuthTestMethod\n  @Test\n  fun `creates key with size 2000`() {\n    performProjectAuthPost(\"keys\", CreateKeyDto(name = KeyControllerTest.MAX_OK_NAME))\n      .andIsCreated.andPrettyPrint.andAssertThatJson {\n        node(\"id\").isValidId\n        node(\"name\").isEqualTo(KeyControllerTest.MAX_OK_NAME)\n      }\n  }\n\n  @ProjectApiKeyAuthTestMethod(scopes = [Scope.KEYS_CREATE, Scope.TRANSLATIONS_EDIT])\n  @Test\n  fun `creates key with keys create scope`() {\n    performProjectAuthPost(\"keys\", CreateKeyDto(name = \"super_key\", translations = mapOf(\"en\" to \"\", \"de\" to \"\")))\n      .andIsCreated.andPrettyPrint.andAssertThatJson {\n        node(\"id\").isValidId\n        node(\"name\").isEqualTo(\"super_key\")\n      }\n  }\n\n  @ProjectApiKeyAuthTestMethod(scopes = [Scope.KEYS_CREATE])\n  @Test\n  fun `create key with translations require translate permissions`() {\n    performProjectAuthPost(\"keys\", CreateKeyDto(name = \"super_key\", translations = mapOf(\"en\" to \"\", \"de\" to \"\")))\n      .andIsForbidden\n  }\n\n  @ProjectJWTAuthTestMethod\n  @Test\n  fun `creates key with translations and tags and screenshots`() {\n    val keyName = \"super_key\"\n\n    val screenshotImages = (1..3).map { imageUploadService.store(screenshotFile, userAccount!!, null) }\n    val screenshotImageIds = screenshotImages.map { it.id }\n    performProjectAuthPost(\n      \"keys\",\n      CreateKeyDto(\n        name = keyName,\n        translations = mapOf(\"en\" to \"EN\", \"de\" to \"DE\"),\n        tags = listOf(\"tag\", \"tag2\"),\n        screenshotUploadedImageIds = screenshotImageIds\n      )\n    ).andIsCreated.andPrettyPrint.andAssertThatJson {\n      node(\"id\").isValidId\n      node(\"name\").isEqualTo(keyName)\n      node(\"tags\") {\n        isArray.hasSize(2)\n        node(\"[0]\") {\n          node(\"id\").isValidId\n          node(\"name\").isEqualTo(\"tag\")\n        }\n        node(\"[1]\") {\n          node(\"id\").isValidId\n          node(\"name\").isEqualTo(\"tag2\")\n        }\n      }\n      node(\"translations\") {\n        node(\"en\") {\n          node(\"id\").isValidId\n          node(\"text\").isEqualTo(\"EN\")\n          node(\"state\").isEqualTo(\"TRANSLATED\")\n          node(\"auto\").isEqualTo(false)\n          node(\"mtProvider\").isEqualTo(null)\n        }\n        node(\"de\") {\n          node(\"id\").isValidId\n          node(\"text\").isEqualTo(\"DE\")\n          node(\"state\").isEqualTo(\"TRANSLATED\")\n        }\n      }\n      node(\"screenshots\") {\n        isArray.hasSize(3)\n        node(\"[1]\") {\n          node(\"id\").isNumber.isGreaterThan(BigDecimal(0))\n          node(\"filename\").isString.endsWith(\".png\").hasSizeGreaterThan(20)\n        }\n      }\n    }\n\n    assertThat(tagService.find(project, \"tag\")).isNotNull\n    assertThat(tagService.find(project, \"tag2\")).isNotNull\n\n    val key = keyService.get(project.id, keyName, null)\n    assertThat(tagService.getTagsForKeyIds(listOf(key.id))[key.id]).hasSize(2)\n    assertThat(translationService.find(key, testData.english).get().text).isEqualTo(\"EN\")\n\n    val screenshots = screenshotService.findAll(key)\n    screenshots.forEach {\n      fileStorage.readFile(\"screenshots/${it.filename}\").isNotEmpty()\n    }\n    assertThat(screenshots).hasSize(3)\n    assertThat(imageUploadService.find(screenshotImageIds)).hasSize(0)\n\n    assertThrows<FileStoreException> {\n      screenshotImages.forEach {\n        fileStorage.readFile(\n          \"${ImageUploadService.UPLOADED_IMAGES_STORAGE_FOLDER_NAME}/${it.filenameWithExtension}\"\n        )\n      }\n    }\n  }\n\n  @ProjectJWTAuthTestMethod\n  @Test\n  fun `creates key with screenshot meta`() {\n    val keyName = \"super_key\"\n\n    val screenshotImages = (1..3).map { imageUploadService.store(screenshotFile, userAccount!!, null) }\n    performProjectAuthPost(\n      \"keys\",\n      CreateKeyDto(\n        name = keyName,\n        translations = mapOf(\"en\" to \"EN\", \"de\" to \"DE\"),\n        tags = listOf(\"tag\", \"tag2\"),\n        screenshots = screenshotImages.map {\n          KeyScreenshotDto().apply {\n            text = \"text\"\n            uploadedImageId = it.id\n            positions = listOf(\n              KeyInScreenshotPositionDto().apply {\n                x = 100\n                y = 120\n                width = 200\n                height = 300\n              }\n            )\n          }\n        }\n      )\n    ).andIsCreated.andPrettyPrint.andAssertThatJson {\n      node(\"screenshots\") {\n        isArray.hasSize(3)\n        node(\"[1]\") {\n          node(\"id\").isNumber.isGreaterThan(BigDecimal(0))\n          node(\"filename\").isString.endsWith(\".png\").hasSizeGreaterThan(20)\n          node(\"keyReferences\") {\n            isArray.hasSize(1)\n            node(\"[0]\") {\n              node(\"keyId\").isValidId\n              node(\"position\") {\n                node(\"x\").isEqualTo(71)\n                node(\"y\").isEqualTo(85)\n                node(\"width\").isEqualTo(141)\n                node(\"height\").isEqualTo(212)\n              }\n              node(\"keyName\").isEqualTo(\"super_key\")\n              node(\"keyNamespace\").isEqualTo(null)\n              node(\"originalText\").isEqualTo(\"text\")\n            }\n          }\n        }\n      }\n    }\n\n    executeInNewTransaction {\n      val key = keyService.get(project.id, keyName, null)\n      val screenshots = screenshotService.findAll(key)\n      screenshots.forEach {\n        fileStorage.readFile(\"screenshots/${it.filename}\").isNotEmpty()\n      }\n      assertThat(screenshots).hasSize(3)\n      assertThat(\n        imageUploadService.find(screenshotImages.map { it.id })\n      ).hasSize(0)\n      screenshots.forEach {\n        val position = it.keyScreenshotReferences[0].positions!![0]\n        assertThat(position.x).isEqualTo(71)\n        assertThat(position.y).isEqualTo(85)\n        assertThat(position.width).isEqualTo(141)\n        assertThat(position.height).isEqualTo(212)\n      }\n    }\n  }\n}\n", "/*\n * Copyright (c) 2020. Tolgee\n */\n\npackage io.tolgee.service\n\nimport com.fasterxml.jackson.module.kotlin.jacksonObjectMapper\nimport com.fasterxml.jackson.module.kotlin.readValue\nimport io.tolgee.AbstractSpringTest\nimport io.tolgee.configuration.tolgee.TelemetryProperties\nimport io.tolgee.development.testDataBuilder.data.BaseTestData\nimport io.tolgee.dtos.TelemetryReportRequest\nimport io.tolgee.fixtures.mockHttpRequest\nimport io.tolgee.fixtures.waitForNotThrowing\nimport io.tolgee.testing.assert\nimport org.junit.jupiter.api.AfterEach\nimport org.junit.jupiter.api.Test\nimport org.mockito.Mockito\nimport org.springframework.beans.factory.annotation.Autowired\nimport org.springframework.boot.test.context.SpringBootTest\nimport org.springframework.boot.test.mock.mockito.MockBean\nimport org.springframework.http.HttpMethod\nimport org.springframework.web.client.RestTemplate\n\n@SpringBootTest(\n  properties = [\n    \"tolgee.telemetry.report-period-ms=200\",\n    \"tolgee.telemetry.enabled=false\"\n  ]\n)\nclass TelemetryServiceTest : AbstractSpringTest() {\n\n  @MockBean\n  @Autowired\n  lateinit var restTemplate: RestTemplate\n\n  @Autowired\n  lateinit var telemetryProperties: TelemetryProperties\n\n  @AfterEach\n  fun clean() {\n    telemetryProperties.enabled = false\n  }\n\n  @Test\n  fun `doesn't report when disabled`() {\n    telemetryProperties.enabled = false\n    Mockito.reset(restTemplate)\n    mockHttpRequest(restTemplate) {\n      whenReq {\n        url = { it.contains(\"/v2/public/telemetry\") }\n        method = { it == HttpMethod.POST }\n      }\n      thenAnswer { }\n      verify {\n        Thread.sleep(5000)\n        this.captor.allValues.assert.hasSize(0)\n      }\n    }\n  }\n\n  @Test\n  fun `reports when enabled`() {\n    telemetryProperties.enabled = true\n    val testData = BaseTestData().apply {\n      this.root.addProject { name = \"bbbb\" }.build {\n        val en = addEnglish()\n        addKey(\"a\") {\n          addTranslation {\n            language = en.self\n            text = \"Hello\"\n          }\n        }\n      }\n    }\n    testDataService.saveTestData(testData.root)\n    mockHttpRequest(restTemplate) {\n      whenReq {\n        url = { it.contains(\"/v2/public/telemetry\") }\n        method = { it == HttpMethod.POST }\n      }\n      thenAnswer { }\n      verify {\n        waitForNotThrowing {\n          val first = this.captor.allValues[0].body as String\n          val data = jacksonObjectMapper().readValue<TelemetryReportRequest>(first)\n          data.instanceId.assert.isNotBlank()\n          data.projectsCount.assert.isEqualTo(2)\n          data.translationsCount.assert.isEqualTo(1)\n          data.languagesCount.assert.isEqualTo(2)\n          data.distinctLanguagesCount.assert.isEqualTo(1)\n          data.usersCount.assert.isEqualTo(1)\n        }\n      }\n    }\n  }\n}\n", "spring:\n  jpa:\n    show-sql: true\n    properties:\n      hibernate:\n        jdbc:\n          batch_size: 1000\n        order_inserts: true\n        order_updates: true\n        dialect: io.tolgee.dialects.postgres.CustomPostgreSQLDialect\n  mvc:\n    pathmatch:\n      matching-strategy: ant_path_matcher\n  data:\n    redis:\n      repositories:\n        enabled: false\n  main:\n    allow-bean-definition-overriding: true\n    lazy-initialization: true\n  liquibase:\n    change-log: classpath:db/changelog/schema.xml\n  batch:\n    job:\n      enabled: false\n    jdbc:\n      initialize-schema: always\n  jmx:\n    enabled: false\ntolgee:\n  postgres-autostart:\n    enabled: true\n    container-name: tolgee_backend_tests_postgres\n    port: 55433\n  data-path: ./build/test_data\n  authentication:\n    native-enabled: true\n    registrationsAllowed: true\n    create-initial-user: false\n    oauth2:\n      client-id: fake_client_id\n      client-secret: fake_client_secret\n      scopes:\n        - openid\n        - email\n        - profile\n      authorization-url: \"https://example.com/authorize\"\n      token-url: \"https://example.com/oauth/token\"\n      user-url: \"https://example.com/userinfo\"\n  internal:\n    fake-mt-providers: true\n    mock-free-plan: true\n  socket-io:\n    port: 19090\n    enabled: false\n  cache:\n    caffeine-max-size: 1000\n  machine-translation:\n    free-credits-amount: -1\n    google:\n      api-key: aaa\n    aws:\n      accessKey: aaa\n      secretKey: aaa\n  billing:\n    enabled: false\n  telemetry:\n    enabled: false\n    server: http://localhost:8080\nlogging:\n  level:\n    io.tolgee.billing.api.v2.OrganizationInvoicesController: DEBUG\n#    org.springframework.orm.jpa: DEBUG\n#    org.springframework.transaction: DEBUG\n#    org.hibernate.type: TRACE\n", "package io.tolgee.repository.dataImport\n\nimport io.tolgee.model.Language\nimport io.tolgee.model.dataImport.Import\nimport io.tolgee.model.dataImport.ImportLanguage\nimport io.tolgee.model.views.ImportLanguageView\nimport org.springframework.data.domain.Page\nimport org.springframework.data.domain.Pageable\nimport org.springframework.data.jpa.repository.JpaRepository\nimport org.springframework.data.jpa.repository.Modifying\nimport org.springframework.data.jpa.repository.Query\nimport org.springframework.stereotype.Repository\nimport org.springframework.transaction.annotation.Transactional\nimport java.util.*\n\n@Repository\ninterface ImportLanguageRepository : JpaRepository<ImportLanguage, Long> {\n\n  companion object {\n    private const val VIEW_BASE_QUERY = \"\"\"\n            select il.id as id, il.name as name, el.id as existingLanguageId, \n            el.tag as existingLanguageTag, el.name as existingLanguageName,\n            if.name as importFileName, if.id as importFileId,\n            if.namespace as namespace,\n            (select count(*) from if.issues) as importFileIssueCount,\n            count(it) as totalCount, \n            sum(case when it.conflict is null then 0 else 1 end) as conflictCount,\n            sum(case when (it.conflict is null or it.resolvedHash is null) then 0 else 1 end) as resolvedCount\n            from ImportLanguage il join il.file if left join il.existingLanguage el left join il.translations it\n        \"\"\"\n\n    private const val VIEW_GROUP_BY = \"\"\"\n            group by il.id, if.id, el.id\n        \"\"\"\n  }\n\n  @Query(\"from ImportLanguage il join il.file if join if.import im where im.id = :importId\")\n  fun findAllByImport(importId: Long): List<ImportLanguage>\n\n  @Modifying\n  @Transactional\n  @Query(\"update ImportLanguage il set il.existingLanguage = null where il.existingLanguage = :language\")\n  fun removeExistingLanguageReference(language: Language)\n\n  @Query(\n    \"\"\"\n            $VIEW_BASE_QUERY\n            where if.import.id = :importId\n            $VIEW_GROUP_BY\n            order by il.id\n            \"\"\"\n  )\n  fun findImportLanguagesView(importId: Long, pageable: Pageable): Page<ImportLanguageView>\n\n  @Modifying\n  @Transactional\n  @Query(\n    \"\"\"delete from ImportLanguage l where l.file in \n        (select f from ImportFile f where f.import = :import)\"\"\"\n  )\n  fun deleteAllByImport(import: Import)\n\n  @Query(\n    \"\"\"\n            $VIEW_BASE_QUERY\n            where il.id = :languageId\n            $VIEW_GROUP_BY\n            \"\"\"\n  )\n  fun findViewById(languageId: Long): Optional<ImportLanguageView>\n\n  @Query(\n    \"\"\"\n      select distinct il.existingLanguage.id \n        from ImportLanguage il \n        join il.file if \n        where if.import.id = :importId \n          and il.existingLanguage.id is not null\n    \"\"\"\n  )\n  fun findAssignedExistingLanguageIds(importId: Long): List<Long>\n}\n", "package io.tolgee.service.dataImport\n\nimport io.tolgee.exceptions.BadRequestException\nimport io.tolgee.exceptions.ImportConflictNotResolvedException\nimport io.tolgee.model.dataImport.Import\nimport io.tolgee.model.dataImport.ImportLanguage\nimport io.tolgee.model.dataImport.ImportTranslation\nimport io.tolgee.model.enums.Scope\nimport io.tolgee.model.key.Key\nimport io.tolgee.model.key.KeyMeta\nimport io.tolgee.model.key.Namespace\nimport io.tolgee.model.translation.Translation\nimport io.tolgee.service.key.KeyMetaService\nimport io.tolgee.service.key.KeyService\nimport io.tolgee.service.key.NamespaceService\nimport io.tolgee.service.security.SecurityService\nimport io.tolgee.service.translation.TranslationService\nimport org.springframework.context.ApplicationContext\n\nclass StoredDataImporter(\n  applicationContext: ApplicationContext,\n  private val import: Import,\n  private val forceMode: ForceMode = ForceMode.NO_FORCE,\n) {\n\n  private val importDataManager = ImportDataManager(applicationContext, import)\n  private val keyService = applicationContext.getBean(KeyService::class.java)\n  private val namespaceService = applicationContext.getBean(NamespaceService::class.java)\n\n  private val keyMetaService = applicationContext.getBean(KeyMetaService::class.java)\n\n  private val securityService = applicationContext.getBean(SecurityService::class.java)\n\n  private val translationsToSave = mutableListOf<Translation>()\n\n  /**\n   * We need to persist data after everything is checked for resolved conflicts since\n   * thrown ImportConflictNotResolvedException commits the transaction,\n   * looking for key in this map is also faster than querying database\n   */\n  private val keysToSave = mutableMapOf<Pair<String?, String>, Key>()\n\n  /**\n   * We need to persist data after everything is checked for resolved conflicts since\n   * thrown ImportConflictNotResolvedException commits the transaction\n   */\n  private val translationService = applicationContext.getBean(TranslationService::class.java)\n\n  private val namespacesToSave = mutableMapOf<String?, Namespace>()\n\n  /**\n   * Keys where base translation was changed, so we need to set outdated flag on all translations\n   */\n  val outdatedFlagKeys: MutableList<Long> = mutableListOf()\n\n  /**\n   * This metas are merged, so there is only one meta for one key!!!\n   *\n   * It can be used only when we are finally importing the data, before that we cannot merge it,\n   * since namespace can be changed\n   */\n  private val storedMetas: MutableMap<Pair<String?, String>, KeyMeta> by lazy {\n    val result: MutableMap<Pair<String?, String>, KeyMeta> = mutableMapOf()\n    keyMetaService.getWithFetchedData(this.import).forEach { currentKeyMeta ->\n      val mapKey = currentKeyMeta.importKey!!.file.namespace to currentKeyMeta.importKey!!.name\n      result[mapKey] = result[mapKey]?.let { existingKeyMeta ->\n        keyMetaService.import(existingKeyMeta, currentKeyMeta)\n        existingKeyMeta\n      } ?: currentKeyMeta\n    }\n    result\n  }\n\n  fun doImport() {\n    importDataManager.storedLanguages.forEach {\n      it.doImport()\n    }\n\n    addKeysAndCheckPermissions()\n\n    handleKeyMetas()\n\n    namespaceService.saveAll(namespacesToSave.values)\n\n    val keyEntitiesToSave = saveKeys()\n\n    saveTranslations()\n\n    saveMetaData(keyEntitiesToSave)\n\n    translationService.setOutdatedBatch(outdatedFlagKeys)\n  }\n\n  private fun saveMetaData(keyEntitiesToSave: MutableCollection<Key>) {\n    keyEntitiesToSave.flatMap {\n      it.keyMeta?.comments ?: emptyList()\n    }.also { keyMetaService.saveAllComments(it) }\n    keyEntitiesToSave.flatMap {\n      it.keyMeta?.codeReferences ?: emptyList()\n    }.also { keyMetaService.saveAllCodeReferences(it) }\n  }\n\n  private fun saveTranslations() {\n    checkTranslationPermissions()\n    translationService.saveAll(translationsToSave)\n  }\n\n  private fun saveKeys(): MutableCollection<Key> {\n    val keyEntitiesToSave = keysToSave.values\n    keyService.saveAll(keyEntitiesToSave)\n    return keyEntitiesToSave\n  }\n\n  private fun addKeysAndCheckPermissions() {\n    addAllKeys()\n    checkKeyPermissions()\n  }\n\n  private fun checkTranslationPermissions() {\n    val langs = translationsToSave.map { it.language }.toSet().map { it.id }\n    securityService.checkLanguageTranslatePermission(import.project.id, langs)\n  }\n\n  private fun checkKeyPermissions() {\n    val isCreatingKey = keysToSave.values.any { it.id == 0L }\n    if (isCreatingKey) {\n      securityService.checkProjectPermission(import.project.id, Scope.KEYS_CREATE)\n    }\n  }\n\n  private fun handleKeyMetas() {\n    this.importDataManager.storedKeys.entries.forEach { (fileNamePair, importKey) ->\n      val importedKeyMeta = storedMetas[fileNamePair.first.namespace to importKey.name]\n      // don't touch key meta when imported key has no meta\n      if (importedKeyMeta != null) {\n        keysToSave[fileNamePair.first.namespace to importKey.name]?.let { newKey ->\n          // if key is obtained or created and meta exists, take it and import the data from the imported one\n          // persist is cascaded on key, so it should be fine\n          val keyMeta = importDataManager.existingMetas[fileNamePair.first.namespace to importKey.name]?.also {\n            keyMetaService.import(it, importedKeyMeta)\n          } ?: importedKeyMeta\n          // also set key and remove import key\n          keyMeta.also {\n            it.key = newKey\n            it.importKey = null\n          }\n          // assign new meta\n          newKey.keyMeta = keyMeta\n        }\n      }\n    }\n  }\n\n  private fun addAllKeys() {\n    importDataManager.storedKeys.map { (fileNamePair, importKey) ->\n      addKeyToSave(importKey.file.namespace, importKey.name)\n    }\n  }\n\n  private fun ImportLanguage.doImport() {\n    importDataManager.populateStoredTranslations(this)\n    importDataManager.handleConflicts(true)\n    importDataManager.getStoredTranslations(this).forEach { it.doImport() }\n  }\n\n  private fun ImportTranslation.doImport() {\n    this.checkConflictResolved()\n    if (this.conflict == null || (this.override && this.resolved) || forceMode == ForceMode.OVERRIDE) {\n      val language = this.language.existingLanguage\n        ?: throw BadRequestException(io.tolgee.constants.Message.EXISTING_LANGUAGE_NOT_SELECTED)\n      val translation = this.conflict ?: Translation().apply {\n        this.language = language\n      }\n      translation.key = existingKey\n      if (language == language.project.baseLanguage && translation.text != this.text) {\n        outdatedFlagKeys.add(translation.key.id)\n      }\n      translation.text = this@doImport.text\n      translation.resetFlags()\n      translationsToSave.add(translation)\n    }\n  }\n\n  private val ImportTranslation.existingKey: Key\n    get() {\n      // get key from already saved keys to save\n      return keysToSave.computeIfAbsent(this.key.file.namespace to this.key.name) {\n        // or get it from conflict or create new one\n        val newKey = this.conflict?.key\n          ?: importDataManager.existingKeys[this.key.file.namespace to this.key.name]\n          ?: Key(name = this.key.name).apply {\n            project = import.project\n            namespace = getNamespace(this@existingKey.key.file.namespace)\n          }\n        newKey\n      }\n    }\n\n  private fun addKeyToSave(namespace: String?, keyName: String): Key {\n    return keysToSave.computeIfAbsent(namespace to keyName) {\n      importDataManager.existingKeys[namespace to keyName] ?: Key(name = keyName).apply {\n        project = import.project\n        this.namespace = getNamespace(namespace)\n      }\n    }\n  }\n\n  private fun ImportTranslation.checkConflictResolved() {\n    if (forceMode == ForceMode.NO_FORCE && this.conflict != null && !this.resolved) {\n      importDataManager.saveAllStoredTranslations()\n      throw ImportConflictNotResolvedException(\n        mutableListOf(this.key.name, this.language.name, this.text).filterNotNull().toMutableList()\n      )\n    }\n  }\n\n  private fun getNamespace(name: String?): Namespace? {\n    name ?: return null\n    return importDataManager.existingNamespaces[name] ?: namespacesToSave.computeIfAbsent(name) {\n      Namespace(name, import.project)\n    }\n  }\n}\n", "package io.tolgee.service.security\n\nimport io.tolgee.constants.Message\nimport io.tolgee.dtos.ComputedPermissionDto\nimport io.tolgee.dtos.cacheable.UserAccountDto\nimport io.tolgee.exceptions.LanguageNotPermittedException\nimport io.tolgee.exceptions.NotFoundException\nimport io.tolgee.exceptions.PermissionException\nimport io.tolgee.model.ApiKey\nimport io.tolgee.model.Project\nimport io.tolgee.model.UserAccount\nimport io.tolgee.model.enums.Scope\nimport io.tolgee.model.translation.Translation\nimport io.tolgee.security.AuthenticationFacade\nimport io.tolgee.service.LanguageService\nimport org.springframework.beans.factory.annotation.Autowired\nimport org.springframework.stereotype.Service\nimport java.io.Serializable\n\n@Service\nclass SecurityService @Autowired constructor(\n  private val authenticationFacade: AuthenticationFacade,\n  private val languageService: LanguageService\n) {\n\n  @set:Autowired\n  lateinit var apiKeyService: ApiKeyService\n\n  @set:Autowired\n  lateinit var permissionService: PermissionService\n\n  @set:Autowired\n  lateinit var userAccountService: UserAccountService\n\n  fun checkAnyProjectPermission(projectId: Long) {\n    if (\n      getProjectPermissionScopes(projectId).isNullOrEmpty() &&\n      !isCurrentUserServerAdmin()\n    )\n      throw PermissionException()\n  }\n\n  fun checkProjectPermission(projectId: Long, requiredScopes: Scope, apiKey: ApiKey) {\n    checkProjectPermission(listOf(requiredScopes), apiKey)\n  }\n\n  private fun checkProjectPermission(requiredScopes: List<Scope>, apiKey: ApiKey) {\n    this.checkApiKeyScopes(requiredScopes, apiKey)\n  }\n\n  fun checkProjectPermissionNoApiKey(\n    projectId: Long,\n    requiredScope: Scope,\n    userAccountDto: UserAccountDto\n  ) {\n    if (isUserAdmin(userAccountDto)) {\n      return\n    }\n\n    val allowedScopes = getProjectPermissionScopes(projectId, userAccountDto.id)\n      ?: throw PermissionException(Message.USER_HAS_NO_PROJECT_ACCESS)\n\n    checkPermission(requiredScope, allowedScopes)\n  }\n\n  private fun checkPermission(\n    requiredScope: Scope,\n    allowedScopes: Array<Scope>\n  ) {\n    if (!allowedScopes.contains(requiredScope)) {\n      @Suppress(\"UNCHECKED_CAST\")\n      throw PermissionException(\n        Message.OPERATION_NOT_PERMITTED,\n        listOf(requiredScope.value) as List<Serializable>\n      )\n    }\n  }\n\n  fun checkProjectPermission(projectId: Long, requiredPermission: Scope) {\n    val apiKey = activeApiKey ?: return checkProjectPermissionNoApiKey(projectId, requiredPermission, activeUser)\n    return checkProjectPermission(projectId, requiredPermission, apiKey)\n  }\n\n  fun checkLanguageViewPermissionByTag(projectId: Long, languageTags: Collection<String>) {\n    checkProjectPermission(projectId, Scope.TRANSLATIONS_VIEW)\n    checkLanguagePermissionByTag(\n      projectId,\n      languageTags\n    ) { data, languageIds -> data.checkViewPermitted(*languageIds.toLongArray()) }\n  }\n\n  fun checkLanguageTranslatePermissionByTag(projectId: Long, languageTags: Collection<String>) {\n    checkProjectPermission(projectId, Scope.TRANSLATIONS_EDIT)\n    checkLanguagePermissionByTag(\n      projectId,\n      languageTags\n    ) { data, languageIds -> data.checkTranslatePermitted(*languageIds.toLongArray()) }\n  }\n\n  fun checkStateEditPermissionByTag(projectId: Long, languageTags: Collection<String>) {\n    checkProjectPermission(projectId, Scope.TRANSLATIONS_STATE_EDIT)\n    checkLanguagePermissionByTag(\n      projectId,\n      languageTags\n    ) { data, languageIds -> data.checkTranslatePermitted(*languageIds.toLongArray()) }\n  }\n\n  fun checkLanguageViewPermission(projectId: Long, languageIds: Collection<Long>) {\n    checkProjectPermission(projectId, Scope.TRANSLATIONS_VIEW)\n    checkLanguagePermission(\n      projectId,\n    ) { data -> data.checkViewPermitted(*languageIds.toLongArray()) }\n  }\n\n  fun checkLanguageTranslatePermission(projectId: Long, languageIds: Collection<Long>) {\n    checkProjectPermission(projectId, Scope.TRANSLATIONS_EDIT)\n    checkLanguagePermission(\n      projectId,\n    ) { data -> data.checkTranslatePermitted(*languageIds.toLongArray()) }\n  }\n\n  fun checkLanguageStateChangePermission(projectId: Long, languageIds: Collection<Long>) {\n    checkProjectPermission(projectId, Scope.TRANSLATIONS_STATE_EDIT)\n    checkLanguagePermission(\n      projectId,\n    ) { data -> data.checkStateChangePermitted(*languageIds.toLongArray()) }\n  }\n\n  fun filterViewPermissionByTag(projectId: Long, languageTags: Collection<String>): Set<String> {\n    try {\n      checkLanguageViewPermissionByTag(projectId, languageTags)\n    } catch (e: LanguageNotPermittedException) {\n      return languageTags.toSet() - e.languageTags.orEmpty().toSet()\n    }\n    return languageTags.toSet()\n  }\n\n  private fun checkLanguagePermission(\n    projectId: Long,\n    permissionCheckFn: (data: ComputedPermissionDto) -> Unit\n  ) {\n    if (isCurrentUserServerAdmin()) {\n      return\n    }\n    val usersPermission = permissionService.getProjectPermissionData(\n      projectId,\n      authenticationFacade.userAccount.id\n    )\n    permissionCheckFn(usersPermission.computedPermissions)\n  }\n\n  private fun checkLanguagePermissionByTag(\n    projectId: Long,\n    languageTags: Collection<String>,\n    fn: (data: ComputedPermissionDto, languageIds: Collection<Long>) -> Unit\n  ) {\n    val languageIds = languageService.getLanguageIdsByTags(projectId, languageTags)\n    try {\n      val usersPermission = permissionService.getProjectPermissionData(\n        projectId,\n        authenticationFacade.userAccount.id\n      )\n      fn(usersPermission.computedPermissions, languageIds.values.map { it.id })\n    } catch (e: LanguageNotPermittedException) {\n      throw LanguageNotPermittedException(\n        e.languageIds,\n        e.languageIds.mapNotNull { languageId -> languageIds.entries.find { it.value.id == languageId }?.key }\n      )\n    }\n  }\n\n  fun checkLanguageTranslatePermission(translation: Translation) {\n    val language = translation.language\n    checkLanguageTranslatePermission(language.project.id, listOf(language.id))\n  }\n\n  fun checkStateChangePermission(translation: Translation) {\n    val language = translation.language\n    checkLanguageStateChangePermission(language.project.id, listOf(language.id))\n  }\n\n  fun checkLanguageTagPermissions(tags: Set<String>, projectId: Long) {\n    val languages = languageService.findByTags(tags, projectId)\n    this.checkLanguageTranslatePermission(projectId, languages.map { it.id })\n  }\n\n  fun checkApiKeyScopes(scopes: Set<Scope>, project: Project?, user: UserAccount? = null) {\n    try {\n      val availableScopes = apiKeyService.getAvailableScopes(user?.id ?: activeUser.id, project!!)\n      val userCanSelectTheScopes = availableScopes.toList().containsAll(scopes)\n      if (!userCanSelectTheScopes) {\n        throw PermissionException()\n      }\n    } catch (e: NotFoundException) {\n      throw PermissionException()\n    }\n  }\n\n  fun fixInvalidApiKeyWhenRequired(apiKey: ApiKey) {\n    val oldSize = apiKey.scopesEnum.size\n    apiKey.scopesEnum.removeIf {\n      getProjectPermissionScopes(\n        apiKey.project.id,\n        apiKey.userAccount.id\n      )?.contains(it) != true\n    }\n    if (oldSize != apiKey.scopesEnum.size) {\n      apiKeyService.save(apiKey)\n    }\n  }\n\n  fun checkApiKeyScopes(scopes: Set<Scope>, apiKey: ApiKey) {\n    checkApiKeyScopes(apiKey) { expandedScopes ->\n      if (!expandedScopes.toList().containsAll(scopes)) {\n        throw PermissionException()\n      }\n    }\n  }\n\n  fun checkApiKeyScopes(scopes: Collection<Scope>, apiKey: ApiKey) {\n    checkApiKeyScopes(apiKey) { expandedScopes ->\n      val hasRequiredPermission = scopes.all { expandedScopes.contains(it) }\n      if (!hasRequiredPermission) {\n        throw PermissionException()\n      }\n    }\n  }\n\n  private fun checkApiKeyScopes(apiKey: ApiKey, checkFn: (expandedScopes: Array<Scope>) -> Unit) {\n    val expandedScopes = Scope.expand(apiKey.scopesEnum)\n    checkFn(expandedScopes)\n  }\n\n  fun checkScreenshotsUploadPermission(projectId: Long) {\n    if (authenticationFacade.isApiKeyAuthentication) {\n      checkApiKeyScopes(setOf(Scope.SCREENSHOTS_UPLOAD), authenticationFacade.apiKey)\n    }\n    checkProjectPermission(projectId, Scope.SCREENSHOTS_UPLOAD)\n  }\n\n  fun checkUserIsServerAdmin() {\n    if (authenticationFacade.userAccount.role != UserAccount.Role.ADMIN) {\n      throw PermissionException()\n    }\n  }\n\n  fun getProjectPermissionScopes(projectId: Long, userId: Long = activeUser.id): Array<Scope>? {\n    return permissionService.getProjectPermissionScopes(projectId, userId)\n  }\n\n  private fun isCurrentUserServerAdmin(): Boolean {\n    return isUserAdmin(activeUser)\n  }\n\n  private fun isUserAdmin(user: UserAccountDto): Boolean {\n    return user.role == UserAccount.Role.ADMIN\n  }\n\n  private val activeUser: UserAccountDto\n    get() = authenticationFacade.userAccountOrNull ?: throw PermissionException()\n\n  private val activeApiKey: ApiKey?\n    get() = authenticationFacade.apiKeyOrNull\n}\n", "spring:\n  jpa:\n    show-sql: true\n    properties:\n      hibernate:\n        jdbc:\n          batch_size: 1000\n        order_inserts: true\n        order_updates: true\n        dialect: io.tolgee.dialects.postgres.CustomPostgreSQLDialect\n  mvc:\n    pathmatch:\n      matching-strategy: ant_path_matcher\n  data:\n    redis:\n      repositories:\n        enabled: false\n  main:\n    allow-bean-definition-overriding: true\n    lazy-initialization: true\n  liquibase:\n    change-log: classpath:db/changelog/schema.xml\n  batch:\n    job:\n      enabled: false\n    jdbc:\n      initialize-schema: always\n  jmx:\n    enabled: false\ntolgee:\n  postgres-autostart:\n    enabled: true\n    container-name: tolgee_backend_tests_postgres\n    port: 55433\n  data-path: ./build/test_data\n  authentication:\n    native-enabled: true\n    registrationsAllowed: true\n    create-initial-user: false\n    oauth2:\n      client-id: fake_client_id\n      client-secret: fake_client_secret\n      scopes:\n        - openid\n        - email\n        - profile\n      authorization-url: \"https://example.com/authorize\"\n      token-url: \"https://example.com/oauth/token\"\n      user-url: \"https://example.com/userinfo\"\n  internal:\n    fake-mt-providers: true\n    mock-free-plan: true\n  socket-io:\n    port: 19090\n    enabled: false\n  cache:\n    caffeine-max-size: 1000\n  machine-translation:\n    free-credits-amount: -1\n    google:\n      api-key: aaa\n    aws:\n      accessKey: aaa\n      secretKey: aaa\n  billing:\n    enabled: false\n  telemetry:\n    enabled: false\n    server: http://localhost:8080\n\nmanagement:\n  endpoint:\n    metrics:\n      enabled: false\n\nspringdoc:\n  api-docs:\n    enabled: false\n\n#logging:\n#  level:\n#    org.springframework.orm.jpa: DEBUG\n#    org.springframework.transaction: DEBUG\n#    org.hibernate.type: TRACE\n\n"], "filenames": ["backend/api/src/main/kotlin/io/tolgee/api/v2/controllers/V2ImportController.kt", "backend/app/src/main/kotlin/io/tolgee/websocket/WebSocketConfig.kt", "backend/app/src/test/kotlin/io/tolgee/api/v2/controllers/v2ImportController/V2ImportControllerApplicationTest.kt", "backend/app/src/test/kotlin/io/tolgee/api/v2/controllers/v2KeyController/KeyControllerCreationTest.kt", "backend/app/src/test/kotlin/io/tolgee/service/TelemetryServiceTest.kt", "backend/app/src/test/resources/application.yaml", "backend/data/src/main/kotlin/io/tolgee/repository/dataImport/ImportLanguageRepository.kt", "backend/data/src/main/kotlin/io/tolgee/service/dataImport/StoredDataImporter.kt", "backend/data/src/main/kotlin/io/tolgee/service/security/SecurityService.kt", "ee/backend/tests/src/test/resources/application.yaml"], "buggy_code_start_loc": [27, 55, 2, 10, 28, 68, 70, 127, 43, 68], "buggy_code_end_loc": [320, 56, 131, 73, 63, 68, 70, 128, 232, 68], "fixing_code_start_loc": [28, 55, 3, 11, 28, 69, 71, 127, 42, 69], "fixing_code_end_loc": [346, 56, 150, 82, 65, 70, 82, 128, 224, 70], "type": "CWE-862", "message": "Tolgee is an open-source localization platform. Starting in version 3.14.0 and prior to version 3.23.1, when a request is made using an API key, the backend fails to verify the permission scopes associated with the key, effectively bypassing permission checks entirely for some endpoints. It's important to note that this vulnerability only affects projects that have inadvertently exposed their API keys on the internet. Projects that have kept their API keys secure are not impacted. This issue is fixed in version 3.23.1.", "other": {"cve": {"id": "CVE-2023-38510", "sourceIdentifier": "security-advisories@github.com", "published": "2023-07-27T19:15:10.313", "lastModified": "2023-08-03T13:41:26.167", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Tolgee is an open-source localization platform. Starting in version 3.14.0 and prior to version 3.23.1, when a request is made using an API key, the backend fails to verify the permission scopes associated with the key, effectively bypassing permission checks entirely for some endpoints. It's important to note that this vulnerability only affects projects that have inadvertently exposed their API keys on the internet. Projects that have kept their API keys secure are not impacted. This issue is fixed in version 3.23.1."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-862"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tolgee:tolgee:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.14.0", "versionEndExcluding": "3.23.1", "matchCriteriaId": "05F74C12-32DB-4BE7-A1A3-DD3BB8BE55D0"}]}]}], "references": [{"url": "https://github.com/tolgee/tolgee-platform/commit/4776cba67e7bb8c1b0259376e3e5fa3bb46e45c7", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/tolgee/tolgee-platform/pull/1818", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/tolgee/tolgee-platform/releases/tag/v3.23.1", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/tolgee/tolgee-platform/security/advisories/GHSA-4f9j-4vh4-p85v", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/tolgee/tolgee-platform/commit/4776cba67e7bb8c1b0259376e3e5fa3bb46e45c7"}}