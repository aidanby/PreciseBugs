{"buggy_code": ["/*\n * $Id: pam_radius_auth.c,v 1.39 2007/03/26 05:35:31 fcusack Exp $\n * pam_radius_auth\n *      Authenticate a user via a RADIUS session\n *\n * 0.9.0 - Didn't compile quite right.\n * 0.9.1 - Hands off passwords properly.  Solaris still isn't completely happy\n * 0.9.2 - Solaris now does challenge-response.  Added configuration file\n *         handling, and skip_passwd field\n * 1.0.0 - Added handling of port name/number, and continue on select\n * 1.1.0 - more options, password change requests work now, too.\n * 1.1.1 - Added client_id=foo (NAS-Identifier), defaulting to PAM_SERVICE\n * 1.1.2 - multi-server capability.\n * 1.2.0 - ugly merger of pam_radius.c to get full RADIUS capability\n * 1.3.0 - added my own accounting code.  Simple, clean, and neat.\n * 1.3.1 - Supports accounting port (oops!), and do accounting authentication\n * 1.3.2 - added support again for 'skip_passwd' control flag.\n * 1.3.10 - ALWAYS add Password attribute, to make packets RFC compliant.\n * 1.3.11 - Bug fixes by Jon Nelson <jnelson@securepipe.com>\n * 1.3.12 - miscellanous bug fixes.  Don't add password to accounting\n *          requests; log more errors; add NAS-Port and NAS-Port-Type\n *          attributes to ALL packets.  Some patches based on input from\n *          Grzegorz Paszka <Grzegorz.Paszka@pik-net.pl>\n * 1.3.13 - Always update the configuration file, even if we're given\n *          no options.  Patch from Jon Nelson <jnelson@securepipe.com>\n * 1.3.14 - Don't use PATH_MAX, so it builds on GNU Hurd.\n * 1.3.15 - Implement retry option, miscellanous bug fixes.\n * 1.3.16 - Miscellaneous fixes (see CVS for history)\n * 1.3.17 - Security fixes\n * 1.4.0 - bind to any open port, add add force_prompt, max_challenge, prompt options\n *\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * The original pam_radius.c code is copyright (c) Cristian Gafton, 1996,\n *                                             <gafton@redhat.com>\n *\n * Some challenge-response code is copyright (c) CRYPTOCard Inc, 1998.\n *                                              All rights reserved.\n */\n\n#define PAM_SM_AUTH\n#define PAM_SM_PASSWORD\n#define PAM_SM_SESSION\n\n#include <limits.h>\n#include <errno.h>\n#include <sys/time.h>\n\n#include \"pam_radius_auth.h\"\n\n#define DPRINT if (opt_debug & PAM_DEBUG_ARG) _pam_log\n\n/* internal data */\nstatic CONST char *pam_module_name = \"pam_radius_auth\";\nstatic char conf_file[BUFFER_SIZE]; /* configuration file */\nstatic int opt_debug = FALSE;\t\t/* print debug info */\n\n/* we need to save these from open_session to close_session, since\n * when close_session will be called we won't be root anymore and\n * won't be able to access again the radius server configuration file\n * -- cristiang */\nstatic radius_server_t *live_server = NULL;\nstatic time_t session_time;\n\n/* logging */\nstatic void _pam_log(int err, CONST char *format, ...)\n{\n\tva_list args;\n\tchar buffer[BUFFER_SIZE];\n\n\tva_start(args, format);\n\tvsprintf(buffer, format, args);\n\t/* don't do openlog or closelog, but put our name in to be friendly */\n\tsyslog(err, \"%s: %s\", pam_module_name, buffer);\n\tva_end(args);\n}\n\n/* argument parsing */\nstatic int _pam_parse(int argc, CONST char **argv, radius_conf_t *conf)\n{\n\tint ctrl=0;\n\n\tmemset(conf, 0, sizeof(radius_conf_t)); /* ensure it's initialized */\n\n\tstrcpy(conf_file, CONF_FILE);\n\n\t/* set the default prompt */\n\tsnprintf(conf->prompt, MAXPROMPT, \"%s: \", DEFAULT_PROMPT);\n\n\t/*\n\t *\tIf either is not there, then we can't parse anything.\n\t */\n\tif ((argc == 0) || (argv == NULL)) {\n\t\treturn ctrl;\n\t}\n\n\t/* step through arguments */\n\tfor (ctrl=0; argc-- > 0; ++argv) {\n\n\t\t/* generic options */\n\t\tif (!strncmp(*argv,\"conf=\",5)) {\n\t\t\t/* protect against buffer overflow */\n\t\t\tif (strlen(*argv+5) >= sizeof(conf_file)) {\n\t\t\t\t_pam_log(LOG_ERR, \"conf= argument too long\");\n\t\t\t\tconf_file[0] = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tstrcpy(conf_file,*argv+5);\n\n\t\t} else if (!strcmp(*argv, \"use_first_pass\")) {\n\t\t\tctrl |= PAM_USE_FIRST_PASS;\n\n\t\t} else if (!strcmp(*argv, \"try_first_pass\")) {\n\t\t\tctrl |= PAM_TRY_FIRST_PASS;\n\n\t\t} else if (!strcmp(*argv, \"skip_passwd\")) {\n\t\t\tctrl |= PAM_SKIP_PASSWD;\n\n\t\t} else if (!strncmp(*argv, \"retry=\", 6)) {\n\t\t\tconf->retries = atoi(*argv+6);\n\n\t\t} else if (!strcmp(*argv, \"localifdown\")) {\n\t\t\tconf->localifdown = 1;\n\n\t\t} else if (!strncmp(*argv, \"client_id=\", 10)) {\n\t\t\tif (conf->client_id) {\n\t\t\t\t_pam_log(LOG_WARNING, \"ignoring duplicate '%s'\", *argv);\n\t\t\t} else {\n\t\t\t\tconf->client_id = (char *) *argv+10; /* point to the client-id */\n\t\t\t}\n\t\t} else if (!strcmp(*argv, \"accounting_bug\")) {\n\t\t\tconf->accounting_bug = TRUE;\n\n\t\t} else if (!strcmp(*argv, \"ruser\")) {\n\t\t\tctrl |= PAM_RUSER_ARG;\n\n\t\t} else if (!strcmp(*argv, \"debug\")) {\n\t\t\tctrl |= PAM_DEBUG_ARG;\n\t\t\tconf->debug = 1;\n\t\t\topt_debug = TRUE;\n\n\t\t} else if (!strncmp(*argv, \"prompt=\", 7)) {\n\t\t\tif (!strncmp(conf->prompt, (char*)*argv+7, MAXPROMPT)) {\n\t\t\t\t_pam_log(LOG_WARNING, \"ignoring duplicate '%s'\", *argv);\n\t\t\t} else {\n\t\t\t\t/* truncate excessive prompts to (MAXPROMPT - 3) length */\n\t\t\t\tif (strlen((char*)*argv+7) >= (MAXPROMPT - 3)) {\n\t\t\t\t\t*((char*)*argv+7 + (MAXPROMPT - 3)) = 0;\n\t\t\t\t}\n\t\t\t\t/* set the new prompt */\n\t\t\t\tmemset(conf->prompt, 0, sizeof(conf->prompt));\n\t\t\t\tsnprintf(conf->prompt, MAXPROMPT, \"%s: \", (char*)*argv+7);\n\t\t\t}\n\n\t\t} else if (!strcmp(*argv, \"force_prompt\")) {\n\t\t\tconf->force_prompt= TRUE;\n\n\t\t} else if (!strncmp(*argv, \"max_challenge=\", 14)) {\n\t\t\tconf->max_challenge = atoi(*argv+14);\n\n\t\t} else {\n\t\t\t_pam_log(LOG_WARNING, \"unrecognized option '%s'\", *argv);\n\t\t}\n\t}\n\n\treturn ctrl;\n}\n\n/* Callback function used to free the saved return value for pam_setcred. */\nvoid _int_free(pam_handle_t * pamh, void *x, int error_status)\n{\n\t\tfree(x);\n}\n\n/*************************************************************************\n * SMALL HELPER FUNCTIONS\n *************************************************************************/\n\n/*\n * Return an IP address in host long notation from\n * one supplied in standard dot notation.\n */\nstatic uint32_t ipstr2long(char *ip_str) {\n\tchar\tbuf[6];\n\tchar\t*ptr;\n\tint\ti;\n\tint\tcount;\n\tuint32_t\tipaddr;\n\tint\tcur_byte;\n\n\tipaddr = (uint32_t)0;\n\n\tfor(i = 0;i < 4;i++) {\n\t\tptr = buf;\n\t\tcount = 0;\n\t\t*ptr = '\\0';\n\n\t\twhile(*ip_str != '.' && *ip_str != '\\0' && count < 4) {\n\t\t\tif (!isdigit(*ip_str)) {\n\t\t\t\treturn (uint32_t)0;\n\t\t\t}\n\t\t\t*ptr++ = *ip_str++;\n\t\t\tcount++;\n\t\t}\n\n\t\tif (count >= 4 || count == 0) {\n\t\t\treturn (uint32_t)0;\n\t\t}\n\n\t\t*ptr = '\\0';\n\t\tcur_byte = atoi(buf);\n\t\tif (cur_byte < 0 || cur_byte > 255) {\n\t\t\treturn (uint32_t)0;\n\t\t}\n\n\t\tip_str++;\n\t\tipaddr = ipaddr << 8 | (uint32_t)cur_byte;\n\t}\n\treturn ipaddr;\n}\n\n/*\n * Check for valid IP address in standard dot notation.\n */\nstatic int good_ipaddr(char *addr) {\n\tint dot_count;\n\tint digit_count;\n\n\tdot_count = 0;\n\tdigit_count = 0;\n\twhile(*addr != '\\0' && *addr != ' ') {\n\t\tif (*addr == '.') {\n\t\t\tdot_count++;\n\t\t\tdigit_count = 0;\n\t\t} else if (!isdigit(*addr)) {\n\t\t\tdot_count = 5;\n\t\t} else {\n\t\t\tdigit_count++;\n\t\t\tif (digit_count > 3) {\n\t\t\t\tdot_count = 5;\n\t\t\t}\n\t\t}\n\t\taddr++;\n\t}\n\tif (dot_count != 3) {\n\t\treturn -1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\n/*\n * Return an IP address in host long notation from a host\n * name or address in dot notation.\n */\nstatic uint32_t get_ipaddr(char *host) {\n\tstruct hostent *hp;\n\n\tif (good_ipaddr(host) == 0) {\n\t\treturn ipstr2long(host);\n\t} else if ((hp = gethostbyname(host)) == (struct hostent *)NULL) {\n\t\treturn (uint32_t)0;\n\t}\n\n\treturn ntohl(*(uint32_t *)hp->h_addr);\n}\n\n/*\n * take server->hostname, and convert it to server->ip and server->port\n */\nstatic int host2server(radius_server_t *server)\n{\n\tchar *p;\n\n\tif ((p = strchr(server->hostname, ':')) != NULL) {\n\t\t*(p++) = '\\0';\t\t/* split the port off from the host name */\n\t}\n\n\tif ((server->ip.s_addr = get_ipaddr(server->hostname)) == ((uint32_t)0)) {\n\t\tDPRINT(LOG_DEBUG, \"DEBUG: get_ipaddr(%s) returned 0.\\n\", server->hostname);\n\t\treturn PAM_AUTHINFO_UNAVAIL;\n\t}\n\n\t/*\n\t *\tIf the server port hasn't already been defined, go get it.\n\t */\n\tif (!server->port) {\n\t\tif (p && isdigit(*p)) {\t/* the port looks like it's a number */\n\t\t\tunsigned int i = atoi(p) & 0xffff;\n\n\t\t\tif (!server->accounting) {\n\t\t\t\tserver->port = htons((uint16_t) i);\n\t\t\t} else {\n\t\t\t\tserver->port = htons((uint16_t) (i + 1));\n\t\t\t}\n\t\t} else {\t\t\t/* the port looks like it's a name */\n\t\t\tstruct servent *svp;\n\n\t\t\tif (p) {\t\t\t/* maybe it's not \"radius\" */\n\t\t\t\tsvp = getservbyname (p, \"udp\");\n\t\t\t\t/* quotes allow distinction from above, lest p be radius or radacct */\n\t\t\t\tDPRINT(LOG_DEBUG, \"DEBUG: getservbyname('%s', udp) returned %p.\\n\", p, svp);\n\t\t\t\t*(--p) = ':';\t\t/* be sure to put the delimiter back */\n\t\t\t} else {\n\t\t\t\tif (!server->accounting) {\n\t\t\t\t\tsvp = getservbyname (\"radius\", \"udp\");\n\t\t\t\t\tDPRINT(LOG_DEBUG, \"DEBUG: getservbyname(radius, udp) returned %p.\\n\", svp);\n\t\t\t\t} else {\n\t\t\t\t\tsvp = getservbyname (\"radacct\", \"udp\");\n\t\t\t\t\tDPRINT(LOG_DEBUG, \"DEBUG: getservbyname(radacct, udp) returned %p.\\n\", svp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (svp == (struct servent *) 0) {\n\t\t\t\t/* debugging above... */\n\t\t\t\treturn PAM_AUTHINFO_UNAVAIL;\n\t\t\t}\n\n\t\t\tserver->port = svp->s_port;\n\t\t}\n\t}\n\n\treturn PAM_SUCCESS;\n}\n\n/*\n * Do XOR of two buffers.\n */\nstatic unsigned char * xor(unsigned char *p, unsigned char *q, int length)\n{\n\tint i;\n\tunsigned char *retval = p;\n\n\tfor (i = 0; i < length; i++) {\n\t\t*(p++) ^= *(q++);\n\t}\n\treturn retval;\n}\n\n/**************************************************************************\n * MID-LEVEL RADIUS CODE\n **************************************************************************/\n\n/*\n * get a pseudo-random vector.\n */\nstatic void get_random_vector(unsigned char *vector)\n{\n#ifdef linux\n\tint fd = open(\"/dev/urandom\",O_RDONLY); /* Linux: get *real* random numbers */\n\tint total = 0;\n\tif (fd >= 0) {\n\t\twhile (total < AUTH_VECTOR_LEN) {\n\t\t\tint bytes = read(fd, vector + total, AUTH_VECTOR_LEN - total);\n\t\t\tif (bytes <= 0)\n\t\t\t\tbreak;\t\t\t/* oops! Error */\n\t\t\ttotal += bytes;\n\t\t}\n\t\tclose(fd);\n\t}\n\n\tif (total != AUTH_VECTOR_LEN)\n#endif\n\t{\t\t\t\t/* do this *always* on other platforms */\n\t\tMD5_CTX my_md5;\n\t\tstruct timeval tv;\n\t\tstruct timezone tz;\n\t\tstatic unsigned int session = 0; /* make the number harder to guess */\n\n\t\t/* Use the time of day with the best resolution the system can\n\t \t   give us -- often close to microsecond accuracy. */\n\t\tgettimeofday(&tv,&tz);\n\n\t\tif (session == 0) {\n\t\t\tsession = getppid();\t/* (possibly) hard to guess information */\n\t\t}\n\n\t\ttv.tv_sec ^= getpid() * session++;\n\n\t\t/* Hash things to get maybe cryptographically strong pseudo-random numbers */\n\t\tMD5Init(&my_md5);\n\t\tMD5Update(&my_md5, (unsigned char *) &tv, sizeof(tv));\n\t\tMD5Update(&my_md5, (unsigned char *) &tz, sizeof(tz));\n\t\tMD5Final(vector, &my_md5);\t\t\t\t/* set the final vector */\n\t}\n}\n\n/*\n * RFC 2139 says to do generate the accounting request vector this way.\n * However, the Livingston 1.16 server doesn't check it.\tThe Cistron\n * server (http://home.cistron.nl/~miquels/radius/) does, and this code\n * seems to work with it.\tIt also works with Funk's Steel-Belted RADIUS.\n */\nstatic void get_accounting_vector(AUTH_HDR *request, radius_server_t *server)\n{\n\tMD5_CTX my_md5;\n\tint secretlen = strlen(server->secret);\n\tint len = ntohs(request->length);\n\n\tmemset(request->vector, 0, AUTH_VECTOR_LEN);\n\tMD5Init(&my_md5);\n\tmemcpy(((char *)request) + len, server->secret, secretlen);\n\n\tMD5Update(&my_md5, (unsigned char *)request, len + secretlen);\n\tMD5Final(request->vector, &my_md5);\t\t\t/* set the final vector */\n}\n\n/*\n * Verify the response from the server\n */\nstatic int verify_packet(char *secret, AUTH_HDR *response, AUTH_HDR *request)\n{\n\tMD5_CTX my_md5;\n\tunsigned char\tcalculated[AUTH_VECTOR_LEN];\n\tunsigned char\treply[AUTH_VECTOR_LEN];\n\n\t/*\n\t * We could dispense with the memcpy, and do MD5's of the packet\n\t * + vector piece by piece.\tThis is easier understand, and maybe faster.\n\t */\n\tmemcpy(reply, response->vector, AUTH_VECTOR_LEN); /* save the reply */\n\tmemcpy(response->vector, request->vector, AUTH_VECTOR_LEN); /* sent vector */\n\n\t/* MD5(response packet header + vector + response packet data + secret) */\n\tMD5Init(&my_md5);\n\tMD5Update(&my_md5, (unsigned char *) response, ntohs(response->length));\n\n\t/*\n\t * This next bit is necessary because of a bug in the original Livingston\n\t * RADIUS server.\tThe authentication vector is *supposed* to be MD5'd\n\t * with the old password (as the secret) for password changes.\n\t * However, the old password isn't used.\tThe \"authentication\" vector\n\t * for the server reply packet is simply the MD5 of the reply packet.\n\t * Odd, the code is 99% there, but the old password is never copied\n\t * to the secret!\n\t */\n\tif (*secret) {\n\t\tMD5Update(&my_md5, (unsigned char *) secret, strlen(secret));\n\t}\n\n\tMD5Final(calculated, &my_md5);\t\t\t/* set the final vector */\n\n\t/* Did he use the same random vector + shared secret? */\n\tif (memcmp(calculated, reply, AUTH_VECTOR_LEN) != 0) {\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\n/*\n * Find an attribute in a RADIUS packet.\tNote that the packet length\n * is *always* kept in network byte order.\n */\nstatic attribute_t *find_attribute(AUTH_HDR *response, unsigned char type)\n{\n\tattribute_t *attr = (attribute_t *) &response->data;\n\n\tint len = ntohs(response->length) - AUTH_HDR_LEN;\n\n\twhile (attr->attribute != type) {\n\t\tif ((len -= attr->length) <= 0) {\n\t\t\treturn NULL;\t\t/* not found */\n\t\t}\n\t\tattr = (attribute_t *) ((char *) attr + attr->length);\n\t}\n\n\treturn attr;\n}\n\n/*\n * Add an attribute to a RADIUS packet.\n */\nstatic void add_attribute(AUTH_HDR *request, unsigned char type, CONST unsigned char *data, int length)\n{\n\tattribute_t *p;\n\n\tp = (attribute_t *) ((unsigned char *)request + ntohs(request->length));\n\tp->attribute = type;\n\tp->length = length + 2;\t\t/* the total size of the attribute */\n\trequest->length = htons(ntohs(request->length) + p->length);\n\tmemcpy(p->data, data, length);\n}\n\n/*\n * Add an integer attribute to a RADIUS packet.\n */\nstatic void add_int_attribute(AUTH_HDR *request, unsigned char type, int data)\n{\n\tint value = htonl(data);\n\n\tadd_attribute(request, type, (unsigned char *) &value, sizeof(int));\n}\n\n/*\n * Add a RADIUS password attribute to the packet.\tSome magic is done here.\n *\n * If it's an PW_OLD_PASSWORD attribute, it's encrypted using the encrypted\n * PW_PASSWORD attribute as the initialization vector.\n *\n * If the password attribute already exists, it's over-written.\tThis allows\n * us to simply call add_password to update the password for different\n * servers.\n */\nstatic void add_password(AUTH_HDR *request, unsigned char type, CONST char *password, char *secret)\n{\n\tMD5_CTX md5_secret, my_md5;\n\tunsigned char misc[AUTH_VECTOR_LEN];\n\tint i;\n\tint length = strlen(password);\n\tunsigned char hashed[256 + AUTH_PASS_LEN];\t/* can't be longer than this */\n\tunsigned char *vector;\n\tattribute_t *attr;\n\n\tif (length > MAXPASS) {\t\t\t\t/* shorten the password for now */\n\t\tlength = MAXPASS;\n\t}\n\n\tif (length == 0) {\n\t\tlength = AUTH_PASS_LEN;\t\t\t/* 0 maps to 16 */\n\t} if ((length & (AUTH_PASS_LEN - 1)) != 0) {\n\t\tlength += (AUTH_PASS_LEN - 1);\t\t/* round it up */\n\t\tlength &= ~(AUTH_PASS_LEN - 1);\t\t/* chop it off */\n\t}\t\t\t\t\t\t/* 16*N maps to itself */\n\n\tmemset(hashed, 0, length);\n\tmemcpy(hashed, password, strlen(password));\n\n\tattr = find_attribute(request, PW_PASSWORD);\n\n\tif (type == PW_PASSWORD) {\n\t\tvector = request->vector;\n\t} else {\n\t\tvector = attr->data;\t\t\t/* attr CANNOT be NULL here. */\n\t}\n\n\t/* ************************************************************ */\n\t/* encrypt the password */\n\t/* password : e[0] = p[0] ^ MD5(secret + vector) */\n\tMD5Init(&md5_secret);\n\tMD5Update(&md5_secret, (unsigned char *) secret, strlen(secret));\n\tmy_md5 = md5_secret;\t\t\t\t/* so we won't re-do the hash later */\n\tMD5Update(&my_md5, vector, AUTH_VECTOR_LEN);\n\tMD5Final(misc, &my_md5);\t\t\t/* set the final vector */\n\txor(hashed, misc, AUTH_PASS_LEN);\n\n\t/* For each step through, e[i] = p[i] ^ MD5(secret + e[i-1]) */\n\tfor (i = 1; i < (length >> 4); i++) {\n\t\tmy_md5 = md5_secret;\t\t\t/* grab old value of the hash */\n\t\tMD5Update(&my_md5, &hashed[(i-1) * AUTH_PASS_LEN], AUTH_PASS_LEN);\n\t\tMD5Final(misc, &my_md5);\t\t\t/* set the final vector */\n\t\txor(&hashed[i * AUTH_PASS_LEN], misc, AUTH_PASS_LEN);\n\t}\n\n\tif (type == PW_OLD_PASSWORD) {\n\t\tattr = find_attribute(request, PW_OLD_PASSWORD);\n\t}\n\n\tif (!attr) {\n\t\tadd_attribute(request, type, hashed, length);\n\t} else {\n\t\tmemcpy(attr->data, hashed, length); /* overwrite the packet */\n\t}\n}\n\nstatic void cleanup(radius_server_t *server)\n{\n\tradius_server_t *next;\n\n\twhile (server) {\n\t\tnext = server->next;\n\t\t_pam_drop(server->hostname);\n\t\t_pam_forget(server->secret);\n\t\t_pam_drop(server);\n\t\tserver = next;\n\t}\n}\n\n/*\n * allocate and open a local port for communication with the RADIUS\n * server\n */\nstatic int initialize(radius_conf_t *conf, int accounting)\n{\n\tstruct sockaddr salocal;\n\tchar hostname[BUFFER_SIZE];\n\tchar secret[BUFFER_SIZE];\n\n\tchar buffer[BUFFER_SIZE];\n\tchar *p;\n\tFILE *fserver;\n\tradius_server_t *server = NULL;\n\tstruct sockaddr_in * s_in;\n\tint timeout;\n\tint line = 0;\n\n\t/* the first time around, read the configuration file */\n\tif ((fserver = fopen (conf_file, \"r\")) == (FILE*)NULL) {\n\t\t_pam_log(LOG_ERR, \"Could not open configuration file %s: %s\\n\",\n\t\t\tconf_file, strerror(errno));\n\t\treturn PAM_ABORT;\n\t}\n\n\twhile (!feof(fserver) && (fgets (buffer, sizeof(buffer), fserver) != (char*) NULL) && (!ferror(fserver))) {\n\t\tline++;\n\t\tp = buffer;\n\n\t\t/*\n\t\t *\tSkip blank lines and whitespace\n\t\t */\n\t\twhile (*p && ((*p == ' ') || (*p == '\\t') || (*p == '\\r') || (*p == '\\n'))) {\n\t\t\tp++;\n\t\t}\n\n\t\t/*\n\t\t *\tNothing, or just a comment. Ignore the line.\n\t\t */\n\t\tif ((!*p) || (*p == '#')) {\n\t\t\tcontinue;\n\t\t}\n\n\t\ttimeout = 3;\n\t\tif (sscanf(p, \"%s %s %d\", hostname, secret, &timeout) < 2) {\n\t\t\t_pam_log(LOG_ERR, \"ERROR reading %s, line %d: Could not read hostname or secret\\n\",\n\t\t\t\t conf_file, line);\n\t\t\tcontinue;\t\t\t/* invalid line */\n\t\t} else {\t\t\t\t/* read it in and save the data */\n\t\t\tradius_server_t *tmp;\n\n\t\t\ttmp = malloc(sizeof(radius_server_t));\n\t\t\tif (server) {\n\t\t\t\tserver->next = tmp;\n\t\t\t\tserver = server->next;\n\t\t\t} else {\n\t\t\t\tconf->server = tmp;\n\t\t\t\tserver= tmp;\t\t/* first time */\n\t\t\t}\n\n\t\t\t/* sometime later do memory checks here */\n\t\t\tserver->hostname = strdup(hostname);\n\t\t\tserver->secret = strdup(secret);\n\t\t\tserver->accounting = accounting;\n\t\t\tserver->port = 0;\n\n\t\t\tif ((timeout < 1) || (timeout > 60)) {\n\t\t\t\tserver->timeout = 3;\n\t\t\t} else {\n\t\t\t\tserver->timeout = timeout;\n\t\t\t}\n\t\t\tserver->next = NULL;\n\t\t}\n\t}\n\tfclose(fserver);\n\n\tif (!server) {\t\t/* no server found, die a horrible death */\n\t\t_pam_log(LOG_ERR, \"No RADIUS server found in configuration file %s\\n\",\n\t\t\t conf_file);\n\t\treturn PAM_AUTHINFO_UNAVAIL;\n\t}\n\n\t/* open a socket.\tDies if it fails */\n\tconf->sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (conf->sockfd < 0) {\n\t\t_pam_log(LOG_ERR, \"Failed to open RADIUS socket: %s\\n\", strerror(errno));\n\t\treturn PAM_AUTHINFO_UNAVAIL;\n\t}\n\n\t/* set up the local end of the socket communications */\n\ts_in = (struct sockaddr_in *) &salocal;\n\tmemset ((char *) s_in, '\\0', sizeof(struct sockaddr));\n\ts_in->sin_family = AF_INET;\n\ts_in->sin_addr.s_addr = INADDR_ANY;\n\ts_in->sin_port = 0;\n\t\n\n\tif (bind(conf->sockfd, &salocal, sizeof (struct sockaddr_in)) < 0) {\n\t\t_pam_log(LOG_ERR, \"Failed binding to port: %s\", strerror(errno));\n\t\tclose(conf->sockfd);\n\t\treturn PAM_AUTHINFO_UNAVAIL;\n\t}\n\n\treturn PAM_SUCCESS;\n}\n\n/*\n * Helper function for building a radius packet.\n * It initializes *some* of the header, and adds common attributes.\n */\nstatic void build_radius_packet(AUTH_HDR *request, CONST char *user, CONST char *password, radius_conf_t *conf)\n{\n\tchar hostname[256];\n\tuint32_t ipaddr;\n\n\thostname[0] = '\\0';\n\tgethostname(hostname, sizeof(hostname) - 1);\n\n\trequest->length = htons(AUTH_HDR_LEN);\n\n\tif (password) {\t\t/* make a random authentication req vector */\n\t\tget_random_vector(request->vector);\n\t}\n\n\tadd_attribute(request, PW_USER_NAME, (unsigned char *) user, strlen(user));\n\n\t/*\n\t *\tAdd a password, if given.\n\t */\n\tif (password) {\n\t\tadd_password(request, PW_PASSWORD, password, conf->server->secret);\n\n\t\t/*\n\t\t *\tAdd a NULL password to non-accounting requests.\n\t\t */\n\t} else if (request->code != PW_ACCOUNTING_REQUEST) {\n\t\tadd_password(request, PW_PASSWORD, \"\", conf->server->secret);\n\t}\n\n\t/* the packet is from localhost if on localhost, to make configs easier */\n\tif ((conf->server->ip.s_addr == ntohl(0x7f000001)) || (!hostname[0])) {\n\t\tipaddr = 0x7f000001;\n\t} else {\n\t\tstruct hostent *hp;\n\n\t\tif ((hp = gethostbyname(hostname)) == (struct hostent *) NULL) {\n\t\t\tipaddr = 0x00000000;\t/* no client IP address */\n\t\t} else {\n\t\t\tipaddr = ntohl(*(uint32_t *) hp->h_addr); /* use the first one available */\n\t\t}\n\t}\n\n\t/* If we can't find an IP address, then don't add one */\n\tif (ipaddr) {\n\t\tadd_int_attribute(request, PW_NAS_IP_ADDRESS, ipaddr);\n\t}\n\n\t/* There's always a NAS identifier */\n\tif (conf->client_id && *conf->client_id) {\n\t\tadd_attribute(request, PW_NAS_IDENTIFIER, (unsigned char *) conf->client_id, strlen(conf->client_id));\n\t}\n\n\t/*\n\t *\tAdd in the port (pid) and port type (virtual).\n\t *\n\t *\tWe might want to give the TTY name here, too.\n\t */\n\tadd_int_attribute(request, PW_NAS_PORT_ID, getpid());\n\tadd_int_attribute(request, PW_NAS_PORT_TYPE, PW_NAS_PORT_TYPE_VIRTUAL);\n}\n\n/*\n * Talk RADIUS to a server.\n * Send a packet and get the response\n */\nstatic int talk_radius(radius_conf_t *conf, AUTH_HDR *request, AUTH_HDR *response,\n\t\t       char *password, char *old_password, int tries)\n{\n\tsocklen_t salen;\n\tint total_length;\n\tfd_set set;\n\tstruct timeval tv;\n\ttime_t now, end;\n\tint rcode;\n\tstruct sockaddr saremote;\n\tstruct sockaddr_in *s_in = (struct sockaddr_in *) &saremote;\n\tradius_server_t *server = conf->server;\n\tint ok;\n\tint server_tries;\n\tint retval;\n\n\t/* ************************************************************ */\n\t/* Now that we're done building the request, we can send it */\n\n\t/*\n\t Hmm... on password change requests, all of the found server information\n\t could be saved with a pam_set_data(), which means even the radius_conf_t\n\t information will have to be malloc'd at some point\n\n\t On the other hand, we could just try all of the servers again in\n\t sequence, on the off chance that one may have ended up fixing itself.\n\n\t */\n\n\t/* loop over all available servers */\n\twhile (server != NULL) {\n\t\t/* clear the response */\n\t\tmemset(response, 0, sizeof(AUTH_HDR));\n\n\t\t/* only look up IP information as necessary */\n\t\tif ((retval = host2server(server)) != PAM_SUCCESS) {\n\t\t\t_pam_log(LOG_ERR,\n\t\t\t\t \"Failed looking up IP address for RADIUS server %s (errcode=%d)\",\n\t\t\t\t server->hostname, retval);\n\t\t\tok = FALSE;\n\t\t\tgoto next;\t\t/* skip to the next server */\n\t\t}\n\n\t\t/* set up per-server IP && port configuration */\n\t\tmemset ((char *) s_in, '\\0', sizeof(struct sockaddr));\n\t\ts_in->sin_family = AF_INET;\n\t\ts_in->sin_addr.s_addr = htonl(server->ip.s_addr);\n\t\ts_in->sin_port = server->port;\n\t\ttotal_length = ntohs(request->length);\n\n\t\tif (!password) { \t\t/* make an RFC 2139 p6 request authenticator */\n\t\t\tget_accounting_vector(request, server);\n\t\t}\n\n\t\tserver_tries = tries;\n\tsend:\n\t\t/* send the packet */\n\t\tif (sendto(conf->sockfd, (char *) request, total_length, 0,\n\t\t\t   &saremote, sizeof(struct sockaddr_in)) < 0) {\n\t\t\t_pam_log(LOG_ERR, \"Error sending RADIUS packet to server %s: %s\",\n\t\t\t\t server->hostname, strerror(errno));\n\t\t\tok = FALSE;\n\t\t\tgoto next;\t\t/* skip to the next server */\n\t\t}\n\n\t\t/* ************************************************************ */\n\t\t/* Wait for the response, and verify it. */\n\t\tsalen = sizeof(struct sockaddr);\n\t\ttv.tv_sec = server->timeout;\t/* wait for the specified time */\n\t\ttv.tv_usec = 0;\n\t\tFD_ZERO(&set);\t\t\t/* clear out the set */\n\t\tFD_SET(conf->sockfd, &set);\t/* wait only for the RADIUS UDP socket */\n\n\t\ttime(&now);\n\t\tend = now + tv.tv_sec;\n\n\t\t/* loop, waiting for the select to return data */\n\t\tok = TRUE;\n\t\twhile (ok) {\n\t\t\trcode = select(conf->sockfd + 1, &set, NULL, NULL, &tv);\n\n\t\t\t/* select timed out */\n\t\t\tif (rcode == 0) {\n\t\t\t\t_pam_log(LOG_ERR, \"RADIUS server %s failed to respond\", server->hostname);\n\t\t\t\tif (--server_tries) {\n\t\t\t\t\tgoto send;\n\t\t\t\t}\n\t\t\t\tok = FALSE;\n\t\t\t\tbreak;\t\t\t/* exit from the select loop */\n\t\t\t} else if (rcode < 0) {\n\n\t\t\t\t/* select had an error */\n\t\t\t\tif (errno == EINTR) {\t/* we were interrupted */\n\t\t\t\t\ttime(&now);\n\n\t\t\t\t\tif (now > end) {\n\t\t\t\t\t\t_pam_log(LOG_ERR, \"RADIUS server %s failed to respond\",\n\t\t\t\t\t\t\t server->hostname);\n\t\t\t\t\t\tif (--server_tries) goto send;\n\t\t\t\t\t\tok = FALSE;\n\t\t\t\t\t\tbreak;\t\t/* exit from the select loop */\n\t\t\t\t\t}\n\n\t\t\t\t\ttv.tv_sec = end - now;\n\t\t\t\t\tif (tv.tv_sec == 0) {\t/* keep waiting */\n\t\t\t\t\t\ttv.tv_sec = 1;\n\t\t\t\t\t}\n\n\t\t\t\t} else {\t\t\t/* not an interrupt, it was a real error */\n\t\t\t\t\t_pam_log(LOG_ERR, \"Error waiting for response from RADIUS server %s: %s\",\n\t\t\t\t\t\t server->hostname, strerror(errno));\n\t\t\t\t\tok = FALSE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t/* the select returned OK */\n\t\t\t} else if (FD_ISSET(conf->sockfd, &set)) {\n\n\t\t\t\t/* try to receive some data */\n\t\t\t\tif ((total_length = recvfrom(conf->sockfd, (void *) response, BUFFER_SIZE,\n\t\t\t\t\t\t     \t     0, &saremote, &salen)) < 0) {\n\t\t\t\t\t_pam_log(LOG_ERR, \"error reading RADIUS packet from server %s: %s\",\n\t\t\t\t\t \t server->hostname, strerror(errno));\n\t\t\t\t\tok = FALSE;\n\t\t\t\t\tbreak;\n\n\t\t\t\t/* there's data, see if it's valid */\n\t\t\t\t} else {\n\t\t\t\t\tchar *p = server->secret;\n\n\t\t\t\t\tif ((ntohs(response->length) != total_length) ||\n\t\t\t\t\t    (ntohs(response->length) > BUFFER_SIZE)) {\n\t\t\t\t\t\t_pam_log(LOG_ERR, \"RADIUS packet from server %s is corrupted\",\n\t\t\t\t\t\t \t server->hostname);\n\t\t\t\t\t\tok = FALSE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Check if we have the data OK. We should also check request->id */\n\t\t\t\t\tif (password) {\n\t\t\t\t\t\tif (old_password) {\n#ifdef LIVINGSTON_PASSWORD_VERIFY_BUG_FIXED\n\t\t\t\t\t\t\tp = old_password;\t/* what it should be */\n#else\n\t\t\t\t\t\t\tp = \"\";\t\t\t/* what it really is */\n#endif\n\t\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * RFC 2139 p.6 says not do do this, but the Livingston 1.16\n\t\t\t\t\t * server disagrees.\tIf the user says he wants the bug, give in.\n\t\t\t\t\t */\n\t\t\t\t\t} else {\t\t/* authentication request */\n\t\t\t\t\t\tif (conf->accounting_bug) {\n\t\t\t\t\t\t\tp = \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!verify_packet(p, response, request)) {\n\t\t\t\t\t\t_pam_log(LOG_ERR, \"packet from RADIUS server %s failed verification: \"\n\t\t\t\t\t\t\t \"The shared secret is probably incorrect.\", server->hostname);\n\t\t\t\t\t\tok = FALSE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Check that the response ID matches the request ID.\n\t\t\t\t\t */\n\t\t\t\t\tif (response->id != request->id) {\n\t\t\t\t\t\t_pam_log(LOG_WARNING, \"Response packet ID %d does not match the \"\n\t\t\t\t\t\t\t \"request packet ID %d: verification of packet fails\",\n\t\t\t\t\t\t\t response->id, request->id);\n\t\t\t\t\t\tok = FALSE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Whew! The select is done. It hasn't timed out, or errored out.\n\t\t\t\t * It's our descriptor.\tWe've got some data. It's the right size.\n\t\t\t\t * The packet is valid.\n\t\t\t\t * NOW, we can skip out of the select loop, and process the packet\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* otherwise, we've got data on another descriptor, keep select'ing */\n\t\t}\n\n\t\t\t/* go to the next server if this one didn't respond */\n\t\tnext:\n\t\tif (!ok) {\n\t\t\tradius_server_t *old;\t/* forget about this server */\n\n\t\t\told = server;\n\t\t\tserver = server->next;\n\t\t\tconf->server = server;\n\n\t\t\t_pam_forget(old->secret);\n\t\t\tfree(old->hostname);\n\t\t\tfree(old);\n\n\t\t\tif (server) {\t\t/* if there's more servers to check */\n\t\t\t\t/* get a new authentication vector, and update the passwords */\n\t\t\t\tget_random_vector(request->vector);\n\t\t\t\trequest->id = request->vector[0];\n\n\t\t\t\t/* update passwords, as appropriate */\n\t\t\t\tif (password) {\n\t\t\t\t\tget_random_vector(request->vector);\n\t\t\t\t\tif (old_password) {\t/* password change request */\n\t\t\t\t\t\tadd_password(request, PW_PASSWORD, password, old_password);\n\t\t\t\t\t\tadd_password(request, PW_OLD_PASSWORD, old_password, old_password);\n\t\t\t\t\t} else {\t\t/* authentication request */\n\t\t\t\t\t\tadd_password(request, PW_PASSWORD, password, server->secret);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\n\t\t} else {\n\t\t\t/* we've found one that does respond, forget about the other servers */\n\t\t\tcleanup(server->next);\n\t\t\tserver->next = NULL;\n\t\t\tlive_server = server;\t/* we've got a live one! */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!server) {\n\t\t_pam_log(LOG_ERR, \"All RADIUS servers failed to respond.\");\n\t\tif (conf->localifdown)\n\t\t\tretval = PAM_IGNORE;\n\t\telse\n\t\t\tretval = PAM_AUTHINFO_UNAVAIL;\n\t} else {\n\t\tretval = PAM_SUCCESS;\n\t}\n\n\treturn retval;\n}\n\n/**************************************************************************\n * MIDLEVEL PAM CODE\n **************************************************************************/\n\n/* this is our front-end for module-application conversations */\n\n#undef PAM_FAIL_CHECK\n#define PAM_FAIL_CHECK if (retval != PAM_SUCCESS) { return retval; }\n\nstatic int rad_converse(pam_handle_t *pamh, int msg_style, char *message, char **password)\n{\n\tCONST struct pam_conv *conv;\n\tstruct pam_message resp_msg;\n\tCONST struct pam_message *msg[1];\n\tstruct pam_response *resp = NULL;\n\tint retval;\n\n\tresp_msg.msg_style = msg_style;\n\tresp_msg.msg = message;\n\tmsg[0] = &resp_msg;\n\n\t/* grab the password */\n\tretval = pam_get_item(pamh, PAM_CONV, (CONST void **) &conv);\n\tPAM_FAIL_CHECK;\n\n\tretval = conv->conv(1, msg, &resp,conv->appdata_ptr);\n\tPAM_FAIL_CHECK;\n\n\tif (password) {\t\t/* assume msg.type needs a response */\n\t\t/* I'm not sure if this next bit is necessary on Linux */\n#ifdef sun\n\t\t/* NULL response, fail authentication */\n\t\tif ((resp == NULL) || (resp->resp == NULL)) {\n\t\t\treturn PAM_SYSTEM_ERR;\n\t\t}\n#endif\n\n\t\t*password = resp->resp;\n\t\tfree(resp);\n\t}\n\n\treturn PAM_SUCCESS;\n}\n\n/**************************************************************************\n * GENERAL CODE\n **************************************************************************/\n\n#undef PAM_FAIL_CHECK\n#define PAM_FAIL_CHECK if (retval != PAM_SUCCESS) { \\\n\tint *pret = malloc(sizeof(int)); \\\n\t*pret = retval;\t\\\n\tpam_set_data(pamh, \"rad_setcred_return\", (void *) pret, _int_free);\t\\\n\treturn retval; }\n\nPAM_EXTERN int pam_sm_authenticate(pam_handle_t *pamh,int flags,int argc,CONST char **argv)\n{\n\tCONST char *user;\n\tCONST char *userinfo;\n\tchar *password = NULL;\n\tCONST char *rhost;\n\tchar *resp2challenge = NULL;\n\tint ctrl;\n\tint retval = PAM_AUTH_ERR;\n\tint num_challenge = 0;\n\n\tchar recv_buffer[4096];\n\tchar send_buffer[4096];\n\tAUTH_HDR *request = (AUTH_HDR *) send_buffer;\n\tAUTH_HDR *response = (AUTH_HDR *) recv_buffer;\n\tradius_conf_t config;\n\n\tctrl = _pam_parse(argc, argv, &config);\n\n\t/* grab the user name */\n\tretval = pam_get_user(pamh, &user, NULL);\n\tPAM_FAIL_CHECK;\n\n\t/* check that they've entered something, and not too long, either */\n\tif ((user == NULL) || (strlen(user) > MAXPWNAM)) {\n\t\tint *pret = malloc(sizeof(int));\n\t\t*pret = PAM_USER_UNKNOWN;\n\t\tpam_set_data(pamh, \"rad_setcred_return\", (void *) pret, _int_free);\n\n\t\tDPRINT(LOG_DEBUG, \"User name was NULL, or too long\");\n\t\treturn PAM_USER_UNKNOWN;\n\t}\n\tDPRINT(LOG_DEBUG, \"Got user name %s\", user);\n\n\tif (ctrl & PAM_RUSER_ARG) {\n\t\tretval = pam_get_item(pamh, PAM_RUSER, (CONST void **) &userinfo);\n\t\tPAM_FAIL_CHECK;\n\t\tDPRINT(LOG_DEBUG, \"Got PAM_RUSER name %s\", userinfo);\n\n\t\tif (!strcmp(\"root\", user)) {\n\t\t\tuser = userinfo;\n\t\t\tDPRINT(LOG_DEBUG, \"Username now %s from ruser\", user);\n\t\t} else {\n\t\t\tDPRINT(LOG_DEBUG, \"Skipping ruser for non-root auth\");\n\t\t}\n\t}\n\n\t/*\n\t * Get the IP address of the authentication server\n\t * Then, open a socket, and bind it to a port\n\t */\n\tretval = initialize(&config, FALSE);\n\tPAM_FAIL_CHECK;\n\n\t/*\n\t * If there's no client id specified, use the service type, to help\n\t * keep track of which service is doing the authentication.\n\t */\n\tif (!config.client_id) {\n\t\tretval = pam_get_item(pamh, PAM_SERVICE, (CONST void **) &config.client_id);\n\t\tPAM_FAIL_CHECK;\n\t}\n\n\t/* now we've got a socket open, so we've got to clean it up on error */\n#undef PAM_FAIL_CHECK\n#define PAM_FAIL_CHECK if (retval != PAM_SUCCESS) {goto error; }\n\n\t/* build and initialize the RADIUS packet */\n\trequest->code = PW_AUTHENTICATION_REQUEST;\n\tget_random_vector(request->vector);\n\trequest->id = request->vector[0]; /* this should be evenly distributed */\n\n\t/* grab the password (if any) from the previous authentication layer */\n        if (!config.force_prompt) {\n                DPRINT(LOG_DEBUG, \"ignore last_pass, force_prompt set\");\n\t\tretval = pam_get_item(pamh, PAM_AUTHTOK, (CONST void **) &password);\n\t\tPAM_FAIL_CHECK;\n        }\n\n\tif (password) {\n\t\tpassword = strdup(password);\n\t\tDPRINT(LOG_DEBUG, \"Got password %s\", password);\n\t}\n\n\t/* no previous password: maybe get one from the user */\n\tif (!password) {\n\t\tif (ctrl & PAM_USE_FIRST_PASS) {\n\t\t\tretval = PAM_AUTH_ERR;\t/* use one pass only, stopping if it fails */\n\t\t\tgoto error;\n\t\t}\n\n\t\t/* check to see if we send a NULL password the first time around */\n\t\tif (!(ctrl & PAM_SKIP_PASSWD)) {\n\t\t\tretval = rad_converse(pamh, PAM_PROMPT_ECHO_OFF, config.prompt, &password);\n\t\t\tPAM_FAIL_CHECK;\n\n\t\t}\n\t} /* end of password == NULL */\n\n\tbuild_radius_packet(request, user, password, &config);\n\t/* not all servers understand this service type, but some do */\n\tadd_int_attribute(request, PW_USER_SERVICE_TYPE, PW_AUTHENTICATE_ONLY);\n\n\t/*\n\t *\tTell the server which host the user is coming from.\n\t *\n\t *\tNote that this is NOT the IP address of the machine running PAM!\n\t *\tIt's the IP address of the client.\n\t */\n\tretval = pam_get_item(pamh, PAM_RHOST, (CONST void **) &rhost);\n\tPAM_FAIL_CHECK;\n\tif (rhost) {\n\t\tadd_attribute(request, PW_CALLING_STATION_ID, (unsigned char *) rhost,\n\t\t\tstrlen(rhost));\n\t}\n\n\tDPRINT(LOG_DEBUG, \"Sending RADIUS request code %d\", request->code);\n\n\tretval = talk_radius(&config, request, response, password, NULL, config.retries + 1);\n\tPAM_FAIL_CHECK;\n\n\tDPRINT(LOG_DEBUG, \"Got RADIUS response code %d\", response->code);\n\n\t/*\n\t *\tIf we get an authentication failure, and we sent a NULL password,\n\t *\task the user for one and continue.\n\t *\n\t *\tIf we get an access challenge, then do a response, for as many\n\t *\tchallenges as we receive.\n\t */\n\twhile (response->code == PW_ACCESS_CHALLENGE) {\n\t\tattribute_t *a_state, *a_reply;\n\t\tchar challenge[BUFFER_SIZE];\n\n\t\t/* Now we do a bit more work: challenge the user, and get a response */\n\t\tif (((a_state = find_attribute(response, PW_STATE)) == NULL) ||\n\t\t    ((a_reply = find_attribute(response, PW_REPLY_MESSAGE)) == NULL)) {\n\t\t\t/* Actually, State isn't required. */\n\t\t\t_pam_log(LOG_ERR, \"RADIUS Access-Challenge received with State or Reply-Message missing\");\n\t\t\tretval = PAM_AUTHINFO_UNAVAIL;\n\t\t\tgoto error;\n\t\t}\n\n\t\t/*\n\t\t *\tSecurity fixes.\n\t\t */\n\t\tif ((a_state->length <= 2) || (a_reply->length <= 2)) {\n\t\t\t_pam_log(LOG_ERR, \"RADIUS Access-Challenge received with invalid State or Reply-Message\");\n\t\t\tretval = PAM_AUTHINFO_UNAVAIL;\n\t\t\tgoto error;\n\t\t}\n\n\t\tmemcpy(challenge, a_reply->data, a_reply->length - 2);\n\t\tchallenge[a_reply->length - 2] = 0;\n\n\t\t/* It's full challenge-response, we should have echo on */\n\t\tretval = rad_converse(pamh, PAM_PROMPT_ECHO_ON, challenge, &resp2challenge);\n\t\tPAM_FAIL_CHECK;\n\n\t\t/* now that we've got a response, build a new radius packet */\n\t\tbuild_radius_packet(request, user, resp2challenge, &config);\n\t\t/* request->code is already PW_AUTHENTICATION_REQUEST */\n\t\trequest->id++;\t\t/* one up from the request */\n\n\t\tif (rhost) {\n\t\t\tadd_attribute(request, PW_CALLING_STATION_ID, (unsigned char *) rhost,\n\t\t\t\t      strlen(rhost));\n\t\t}\n\n\t\t/* copy the state over from the servers response */\n\t\tadd_attribute(request, PW_STATE, a_state->data, a_state->length - 2);\n\n\t\tretval = talk_radius(&config, request, response, resp2challenge, NULL, 1);\n\t\tPAM_FAIL_CHECK;\n\n\t\tDPRINT(LOG_DEBUG, \"Got response to challenge code %d\", response->code);\n\n\t\t/*\n\t\t * max_challenge limits the # of challenges a server can issue\n\t\t * It's a workaround for buggy servers\n\t\t */\n\t\tif (config.max_challenge > 0 && response->code == PW_ACCESS_CHALLENGE) {\n\t\t\tnum_challenge++;\n\t\t\tif (num_challenge >= config.max_challenge) {\n\t\t\t\tDPRINT(LOG_DEBUG, \"maximum number of challenges (%d) reached, failing\", num_challenge);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Whew! Done the pasword checks, look for an authentication acknowledge */\n\tif (response->code == PW_AUTHENTICATION_ACK) {\n\t\tretval = PAM_SUCCESS;\n\t} else {\n\t\tretval = PAM_AUTH_ERR;\t/* authentication failure */\n\nerror:\n\t\t/* If there was a password pass it to the next layer */\n\t\tif (password && *password) {\n\t\t\tpam_set_item(pamh, PAM_AUTHTOK, password);\n\t\t}\n\t}\n\n\tDPRINT(LOG_DEBUG, \"authentication %s\", retval==PAM_SUCCESS ? \"succeeded\":\"failed\");\n\n\tclose(config.sockfd);\n\tcleanup(config.server);\n\t_pam_forget(password);\n\t_pam_forget(resp2challenge);\n\t{\n\t\tint *pret = malloc(sizeof(int));\n\t\t*pret = retval;\n\t\tpam_set_data(pamh, \"rad_setcred_return\", (void *) pret, _int_free);\n\t}\n\treturn retval;\n}\n\n/*\n * Return a value matching the return value of pam_sm_authenticate, for\n * greatest compatibility.\n * (Always returning PAM_SUCCESS breaks other authentication modules;\n * always returning PAM_IGNORE breaks PAM when we're the only module.)\n */\nPAM_EXTERN int pam_sm_setcred(pam_handle_t *pamh,int flags,int argc,CONST char **argv)\n{\n\tint retval, *pret;\n\n\tretval = PAM_SUCCESS;\n\tpret = &retval;\n\tpam_get_data(pamh, \"rad_setcred_return\", (CONST void **) &pret);\n\treturn *pret;\n}\n\n#undef PAM_FAIL_CHECK\n#define PAM_FAIL_CHECK if (retval != PAM_SUCCESS) { return PAM_SESSION_ERR; }\n\nstatic int pam_private_session(pam_handle_t *pamh, int flags, int argc, CONST char **argv, int status)\n{\n\tCONST char *user;\n\tint ctrl;\n\tint retval = PAM_AUTH_ERR;\n\n\tchar recv_buffer[4096];\n\tchar send_buffer[4096];\n\tAUTH_HDR *request = (AUTH_HDR *) send_buffer;\n\tAUTH_HDR *response = (AUTH_HDR *) recv_buffer;\n\tradius_conf_t config;\n\n\tctrl = _pam_parse(argc, argv, &config);\n\n\t/* grab the user name */\n\tretval = pam_get_user(pamh, &user, NULL);\n\tPAM_FAIL_CHECK;\n\n\t/* check that they've entered something, and not too long, either */\n\tif ((user == NULL) || (strlen(user) > MAXPWNAM)) {\n\t\treturn PAM_USER_UNKNOWN;\n\t}\n\n\t/*\n\t * Get the IP address of the authentication server\n\t * Then, open a socket, and bind it to a port\n\t */\n\tretval = initialize(&config, TRUE);\n\tPAM_FAIL_CHECK;\n\n\t/*\n\t * If there's no client id specified, use the service type, to help\n\t * keep track of which service is doing the authentication.\n\t */\n\tif (!config.client_id) {\n\t\tretval = pam_get_item(pamh, PAM_SERVICE, (CONST void **) &config.client_id);\n\t\tPAM_FAIL_CHECK;\n\t}\n\n\t/* now we've got a socket open, so we've got to clean it up on error */\n#undef PAM_FAIL_CHECK\n#define PAM_FAIL_CHECK if (retval != PAM_SUCCESS) {goto error; }\n\n\t/* build and initialize the RADIUS packet */\n\trequest->code = PW_ACCOUNTING_REQUEST;\n\tget_random_vector(request->vector);\n\trequest->id = request->vector[0]; /* this should be evenly distributed */\n\n\tbuild_radius_packet(request, user, NULL, &config);\n\n\tadd_int_attribute(request, PW_ACCT_STATUS_TYPE, status);\n\n\tsprintf(recv_buffer, \"%08d\", (int) getpid());\n\tadd_attribute(request, PW_ACCT_SESSION_ID, (unsigned char *) recv_buffer, strlen(recv_buffer));\n\n\tadd_int_attribute(request, PW_ACCT_AUTHENTIC, PW_AUTH_RADIUS);\n\n\tif (status == PW_STATUS_START) {\n\t\tsession_time = time(NULL);\n\t} else {\n\t\tadd_int_attribute(request, PW_ACCT_SESSION_TIME, time(NULL) - session_time);\n\t}\n\n\tretval = talk_radius(&config, request, response, NULL, NULL, 1);\n\tPAM_FAIL_CHECK;\n\n\t/* oops! They don't have the right password.\tComplain and die. */\n\tif (response->code != PW_ACCOUNTING_RESPONSE) {\n\t\tretval = PAM_PERM_DENIED;\n\t\tgoto error;\n\t}\n\n\tretval = PAM_SUCCESS;\n\nerror:\n\n\tclose(config.sockfd);\n\tcleanup(config.server);\n\n\treturn retval;\n}\n\nPAM_EXTERN int pam_sm_open_session(pam_handle_t *pamh, int flags, int argc, CONST char **argv)\n{\n\treturn pam_private_session(pamh, flags, argc, argv, PW_STATUS_START);\n}\n\nPAM_EXTERN int pam_sm_close_session(pam_handle_t *pamh, int flags, int argc, CONST char **argv)\n{\n\treturn pam_private_session(pamh, flags, argc, argv, PW_STATUS_STOP);\n}\n\n#undef PAM_FAIL_CHECK\n#define PAM_FAIL_CHECK if (retval != PAM_SUCCESS) {return retval; }\n#define MAX_PASSWD_TRIES 3\n\nPAM_EXTERN int pam_sm_chauthtok(pam_handle_t *pamh, int flags, int argc, CONST char **argv)\n{\n\tCONST char *user;\n\tchar *password = NULL;\n\tchar *new_password = NULL;\n\tchar *check_password = NULL;\n\tint ctrl;\n\tint retval = PAM_AUTHTOK_ERR;\n\tint attempts;\n\n\tchar recv_buffer[4096];\n\tchar send_buffer[4096];\n\tAUTH_HDR *request = (AUTH_HDR *) send_buffer;\n\tAUTH_HDR *response = (AUTH_HDR *) recv_buffer;\n\tradius_conf_t config;\n\n\tctrl = _pam_parse(argc, argv, &config);\n\n\t/* grab the user name */\n\tretval = pam_get_user(pamh, &user, NULL);\n\tPAM_FAIL_CHECK;\n\n\t/* check that they've entered something, and not too long, either */\n\tif ((user == NULL) || (strlen(user) > MAXPWNAM)) {\n\t\treturn PAM_USER_UNKNOWN;\n\t}\n\n\t/*\n\t * Get the IP address of the authentication server\n\t * Then, open a socket, and bind it to a port\n\t */\n\tretval = initialize(&config, FALSE);\n\tPAM_FAIL_CHECK;\n\n\t/*\n\t * If there's no client id specified, use the service type, to help\n\t * keep track of which service is doing the authentication.\n\t */\n\tif (!config.client_id) {\n\t\tretval = pam_get_item(pamh, PAM_SERVICE, (CONST void **) &config.client_id);\n\t\tPAM_FAIL_CHECK;\n\t}\n\n\t/* now we've got a socket open, so we've got to clean it up on error */\n#undef PAM_FAIL_CHECK\n#define PAM_FAIL_CHECK if (retval != PAM_SUCCESS) {goto error; }\n\n\t/* grab the old password (if any) from the previous password layer */\n\tretval = pam_get_item(pamh, PAM_OLDAUTHTOK, (CONST void **) &password);\n\tPAM_FAIL_CHECK;\n\tif (password) password = strdup(password);\n\n\t/* grab the new password (if any) from the previous password layer */\n\tretval = pam_get_item(pamh, PAM_AUTHTOK, (CONST void **) &new_password);\n\tPAM_FAIL_CHECK;\n\tif (new_password) new_password = strdup(new_password);\n\n\t/* preliminary password change checks. */\n\tif (flags & PAM_PRELIM_CHECK) {\n\t\tif (!password) {\t\t/* no previous password: ask for one */\n\t\t\tretval = rad_converse(pamh, PAM_PROMPT_ECHO_OFF, config.prompt, &password);\n\t\t\tPAM_FAIL_CHECK;\n\t\t}\n\n\t\t/*\n\t\t * We now check the password to see if it's the right one.\n\t\t * If it isn't, we let the user try again.\n\t\t * Note that RADIUS doesn't have any concept of 'root'.\tThe only way\n\t\t * that root can change someone's password is to log into the RADIUS\n\t\t * server, and and change it there.\n\t\t */\n\n\t\t/* build and initialize the access request RADIUS packet */\n\t\trequest->code = PW_AUTHENTICATION_REQUEST;\n\t\tget_random_vector(request->vector);\n\t\trequest->id = request->vector[0]; /* this should be evenly distributed */\n\n\t\tbuild_radius_packet(request, user, password, &config);\n\t\tadd_int_attribute(request, PW_USER_SERVICE_TYPE, PW_AUTHENTICATE_ONLY);\n\n\t\tretval = talk_radius(&config, request, response, password, NULL, 1);\n\t\tPAM_FAIL_CHECK;\n\n\t\t/* oops! They don't have the right password.\tComplain and die. */\n\t\tif (response->code != PW_AUTHENTICATION_ACK) {\n\t\t\t_pam_forget(password);\n\t\t\tretval = PAM_PERM_DENIED;\n\t\t\tgoto error;\n\t\t}\n\n\t\t/*\n\t\t * We're now sure it's the right user.\n\t\t * Ask for their new password, if appropriate\n\t\t */\n\n\t\tif (!new_password) {\t/* not found yet: ask for it */\n\t\t\tint new_attempts;\n\t\t\tattempts = 0;\n\n\t\t\t/* loop, trying to get matching new passwords */\n\t\t\twhile (attempts++ < 3) {\n\n\t\t\t\t/* loop, trying to get a new password */\n\t\t\t\tnew_attempts = 0;\n\t\t\t\twhile (new_attempts++ < 3) {\n\t\t\t\t\tretval = rad_converse(pamh, PAM_PROMPT_ECHO_OFF,\n\t\t\t\t\t\t\t\"New password: \", &new_password);\n\t\t\t\t\tPAM_FAIL_CHECK;\n\n\t\t\t\t\t/* the old password may be short.\tCheck it, first. */\n\t\t\t\t\tif (strcmp(password, new_password) == 0) { /* are they the same? */\n\t\t\t\t\t\trad_converse(pamh, PAM_ERROR_MSG,\n\t\t\t\t\t\t \"You must choose a new password.\", NULL);\n\t\t\t\t\t\t_pam_forget(new_password);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (strlen(new_password) < 6) {\n\t\t\t\t\t\trad_converse(pamh, PAM_ERROR_MSG, \"it's WAY too short\", NULL);\n\t\t\t\t\t\t_pam_forget(new_password);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* insert crypt password checking here */\n\n\t\t\t\t\tbreak;\t\t/* the new password is OK */\n\t\t\t\t}\n\n\t\t\t\tif (new_attempts >= 3) { /* too many new password attempts: die */\n\t\t\t\t\tretval = PAM_AUTHTOK_ERR;\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\n\t\t\t\t/* make sure of the password by asking for verification */\n\t\t\t\tretval = rad_converse(pamh, PAM_PROMPT_ECHO_OFF,\n\t\t\t\t\t\t      \"New password (again): \", &check_password);\n\t\t\t\tPAM_FAIL_CHECK;\n\n\t\t\t\tretval = strcmp(new_password, check_password);\n\t\t\t\t_pam_forget(check_password);\n\n\t\t\t\t/* if they don't match, don't pass them to the next module */\n\t\t\t\tif (retval != 0) {\n\t\t\t\t\t_pam_forget(new_password);\n\t\t\t\t\trad_converse(pamh, PAM_ERROR_MSG,\n\t\t\t\t\t\t\t\t \"You must enter the same password twice.\", NULL);\n\t\t\t\t\tretval = PAM_AUTHTOK_ERR;\n\t\t\t\t\tgoto error;\t\t/* ??? maybe this should be a 'continue' ??? */\n\t\t\t\t}\n\n\t\t\t\tbreak;\t\t\t/* everything's fine */\n\t\t\t}\t/* loop, trying to get matching new passwords */\n\n\t\t\tif (attempts >= 3) { /* too many new password attempts: die */\n\t\t\t\tretval = PAM_AUTHTOK_ERR;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} /* now we have a new password which passes all of our tests */\n\n\t\t/*\n\t\t * Solaris 2.6 calls pam_sm_chauthtok only ONCE, with PAM_PRELIM_CHECK\n\t\t * set.\n\t\t */\n#ifndef sun\n\t\t/* If told to update the authentication token, do so. */\n\t} else if (flags & PAM_UPDATE_AUTHTOK) {\n#endif\n\n\t\tif (!password || !new_password) { /* ensure we've got passwords */\n\t\t\tretval = PAM_AUTHTOK_ERR;\n\t\t\tgoto error;\n\t\t}\n\n\t\t/* build and initialize the password change request RADIUS packet */\n\t\trequest->code = PW_PASSWORD_REQUEST;\n\t\tget_random_vector(request->vector);\n\t\trequest->id = request->vector[0]; /* this should be evenly distributed */\n\n\t\t/* the secret here can not be know to the user, so it's the new password */\n\t\t_pam_forget(config.server->secret);\n\t\tconfig.server->secret = strdup(password); /* it's free'd later */\n\n\t\tbuild_radius_packet(request, user, new_password, &config);\n\t\tadd_password(request, PW_OLD_PASSWORD, password, password);\n\n\t\tretval = talk_radius(&config, request, response, new_password, password, 1);\n\t\tPAM_FAIL_CHECK;\n\n\t\t/* Whew! Done password changing, check for password acknowledge */\n\t\tif (response->code != PW_PASSWORD_ACK) {\n\t\t\tretval = PAM_AUTHTOK_ERR;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/*\n\t * Send the passwords to the next stage if preliminary checks fail,\n\t * or if the password change request fails.\n\t */\n\tif ((flags & PAM_PRELIM_CHECK) || (retval != PAM_SUCCESS)) {\n\terror:\n\n\t\t/* If there was a password pass it to the next layer */\n\t\tif (password && *password) {\n\t\t\tpam_set_item(pamh, PAM_OLDAUTHTOK, password);\n\t\t}\n\n\t\tif (new_password && *new_password) {\n\t\t\tpam_set_item(pamh, PAM_AUTHTOK, new_password);\n\t\t}\n\t}\n\n\tif (ctrl & PAM_DEBUG_ARG) {\n\t\t_pam_log(LOG_DEBUG, \"password change %s\", retval==PAM_SUCCESS ? \"succeeded\" : \"failed\");\n\t}\n\n\tclose(config.sockfd);\n\tcleanup(config.server);\n\n\t_pam_forget(password);\n\t_pam_forget(new_password);\n\treturn retval;\n}\n\n/*\n *\tDo nothing for account management. This is apparently needed by\n *\tsome programs.\n */\nPAM_EXTERN int pam_sm_acct_mgmt(pam_handle_t *pamh,int flags,int argc,CONST char **argv)\n{\n\tint retval;\n\tretval = PAM_SUCCESS;\n\treturn retval;\n}\n\n#ifdef PAM_STATIC\n\n/* static module data */\n\nstruct pam_module _pam_radius_modstruct = {\n\t\"pam_radius_auth\",\n\tpam_sm_authenticate,\n\tpam_sm_setcred,\n\tpam_sm_acct_mgmt,\n\tpam_sm_open_session,\n\tpam_sm_close_session,\n\tpam_sm_chauthtok,\n};\n#endif\n\n"], "fixing_code": ["/*\n * $Id: pam_radius_auth.c,v 1.39 2007/03/26 05:35:31 fcusack Exp $\n * pam_radius_auth\n *      Authenticate a user via a RADIUS session\n *\n * 0.9.0 - Didn't compile quite right.\n * 0.9.1 - Hands off passwords properly.  Solaris still isn't completely happy\n * 0.9.2 - Solaris now does challenge-response.  Added configuration file\n *         handling, and skip_passwd field\n * 1.0.0 - Added handling of port name/number, and continue on select\n * 1.1.0 - more options, password change requests work now, too.\n * 1.1.1 - Added client_id=foo (NAS-Identifier), defaulting to PAM_SERVICE\n * 1.1.2 - multi-server capability.\n * 1.2.0 - ugly merger of pam_radius.c to get full RADIUS capability\n * 1.3.0 - added my own accounting code.  Simple, clean, and neat.\n * 1.3.1 - Supports accounting port (oops!), and do accounting authentication\n * 1.3.2 - added support again for 'skip_passwd' control flag.\n * 1.3.10 - ALWAYS add Password attribute, to make packets RFC compliant.\n * 1.3.11 - Bug fixes by Jon Nelson <jnelson@securepipe.com>\n * 1.3.12 - miscellanous bug fixes.  Don't add password to accounting\n *          requests; log more errors; add NAS-Port and NAS-Port-Type\n *          attributes to ALL packets.  Some patches based on input from\n *          Grzegorz Paszka <Grzegorz.Paszka@pik-net.pl>\n * 1.3.13 - Always update the configuration file, even if we're given\n *          no options.  Patch from Jon Nelson <jnelson@securepipe.com>\n * 1.3.14 - Don't use PATH_MAX, so it builds on GNU Hurd.\n * 1.3.15 - Implement retry option, miscellanous bug fixes.\n * 1.3.16 - Miscellaneous fixes (see CVS for history)\n * 1.3.17 - Security fixes\n * 1.4.0 - bind to any open port, add add force_prompt, max_challenge, prompt options\n *\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * The original pam_radius.c code is copyright (c) Cristian Gafton, 1996,\n *                                             <gafton@redhat.com>\n *\n * Some challenge-response code is copyright (c) CRYPTOCard Inc, 1998.\n *                                              All rights reserved.\n */\n\n#define PAM_SM_AUTH\n#define PAM_SM_PASSWORD\n#define PAM_SM_SESSION\n\n#include <limits.h>\n#include <errno.h>\n#include <sys/time.h>\n\n#include \"pam_radius_auth.h\"\n\n#define DPRINT if (opt_debug & PAM_DEBUG_ARG) _pam_log\n\n/* internal data */\nstatic CONST char *pam_module_name = \"pam_radius_auth\";\nstatic char conf_file[BUFFER_SIZE]; /* configuration file */\nstatic int opt_debug = FALSE;\t\t/* print debug info */\n\n/* we need to save these from open_session to close_session, since\n * when close_session will be called we won't be root anymore and\n * won't be able to access again the radius server configuration file\n * -- cristiang */\nstatic radius_server_t *live_server = NULL;\nstatic time_t session_time;\n\n/* logging */\nstatic void _pam_log(int err, CONST char *format, ...)\n{\n\tva_list args;\n\tchar buffer[BUFFER_SIZE];\n\n\tva_start(args, format);\n\tvsprintf(buffer, format, args);\n\t/* don't do openlog or closelog, but put our name in to be friendly */\n\tsyslog(err, \"%s: %s\", pam_module_name, buffer);\n\tva_end(args);\n}\n\n/* argument parsing */\nstatic int _pam_parse(int argc, CONST char **argv, radius_conf_t *conf)\n{\n\tint ctrl=0;\n\n\tmemset(conf, 0, sizeof(radius_conf_t)); /* ensure it's initialized */\n\n\tstrcpy(conf_file, CONF_FILE);\n\n\t/* set the default prompt */\n\tsnprintf(conf->prompt, MAXPROMPT, \"%s: \", DEFAULT_PROMPT);\n\n\t/*\n\t *\tIf either is not there, then we can't parse anything.\n\t */\n\tif ((argc == 0) || (argv == NULL)) {\n\t\treturn ctrl;\n\t}\n\n\t/* step through arguments */\n\tfor (ctrl=0; argc-- > 0; ++argv) {\n\n\t\t/* generic options */\n\t\tif (!strncmp(*argv,\"conf=\",5)) {\n\t\t\t/* protect against buffer overflow */\n\t\t\tif (strlen(*argv+5) >= sizeof(conf_file)) {\n\t\t\t\t_pam_log(LOG_ERR, \"conf= argument too long\");\n\t\t\t\tconf_file[0] = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tstrcpy(conf_file,*argv+5);\n\n\t\t} else if (!strcmp(*argv, \"use_first_pass\")) {\n\t\t\tctrl |= PAM_USE_FIRST_PASS;\n\n\t\t} else if (!strcmp(*argv, \"try_first_pass\")) {\n\t\t\tctrl |= PAM_TRY_FIRST_PASS;\n\n\t\t} else if (!strcmp(*argv, \"skip_passwd\")) {\n\t\t\tctrl |= PAM_SKIP_PASSWD;\n\n\t\t} else if (!strncmp(*argv, \"retry=\", 6)) {\n\t\t\tconf->retries = atoi(*argv+6);\n\n\t\t} else if (!strcmp(*argv, \"localifdown\")) {\n\t\t\tconf->localifdown = 1;\n\n\t\t} else if (!strncmp(*argv, \"client_id=\", 10)) {\n\t\t\tif (conf->client_id) {\n\t\t\t\t_pam_log(LOG_WARNING, \"ignoring duplicate '%s'\", *argv);\n\t\t\t} else {\n\t\t\t\tconf->client_id = (char *) *argv+10; /* point to the client-id */\n\t\t\t}\n\t\t} else if (!strcmp(*argv, \"accounting_bug\")) {\n\t\t\tconf->accounting_bug = TRUE;\n\n\t\t} else if (!strcmp(*argv, \"ruser\")) {\n\t\t\tctrl |= PAM_RUSER_ARG;\n\n\t\t} else if (!strcmp(*argv, \"debug\")) {\n\t\t\tctrl |= PAM_DEBUG_ARG;\n\t\t\tconf->debug = 1;\n\t\t\topt_debug = TRUE;\n\n\t\t} else if (!strncmp(*argv, \"prompt=\", 7)) {\n\t\t\tif (!strncmp(conf->prompt, (char*)*argv+7, MAXPROMPT)) {\n\t\t\t\t_pam_log(LOG_WARNING, \"ignoring duplicate '%s'\", *argv);\n\t\t\t} else {\n\t\t\t\t/* truncate excessive prompts to (MAXPROMPT - 3) length */\n\t\t\t\tif (strlen((char*)*argv+7) >= (MAXPROMPT - 3)) {\n\t\t\t\t\t*((char*)*argv+7 + (MAXPROMPT - 3)) = 0;\n\t\t\t\t}\n\t\t\t\t/* set the new prompt */\n\t\t\t\tmemset(conf->prompt, 0, sizeof(conf->prompt));\n\t\t\t\tsnprintf(conf->prompt, MAXPROMPT, \"%s: \", (char*)*argv+7);\n\t\t\t}\n\n\t\t} else if (!strcmp(*argv, \"force_prompt\")) {\n\t\t\tconf->force_prompt= TRUE;\n\n\t\t} else if (!strncmp(*argv, \"max_challenge=\", 14)) {\n\t\t\tconf->max_challenge = atoi(*argv+14);\n\n\t\t} else {\n\t\t\t_pam_log(LOG_WARNING, \"unrecognized option '%s'\", *argv);\n\t\t}\n\t}\n\n\treturn ctrl;\n}\n\n/* Callback function used to free the saved return value for pam_setcred. */\nvoid _int_free(pam_handle_t * pamh, void *x, int error_status)\n{\n\t\tfree(x);\n}\n\n/*************************************************************************\n * SMALL HELPER FUNCTIONS\n *************************************************************************/\n\n/*\n * Return an IP address in host long notation from\n * one supplied in standard dot notation.\n */\nstatic uint32_t ipstr2long(char *ip_str) {\n\tchar\tbuf[6];\n\tchar\t*ptr;\n\tint\ti;\n\tint\tcount;\n\tuint32_t\tipaddr;\n\tint\tcur_byte;\n\n\tipaddr = (uint32_t)0;\n\n\tfor(i = 0;i < 4;i++) {\n\t\tptr = buf;\n\t\tcount = 0;\n\t\t*ptr = '\\0';\n\n\t\twhile(*ip_str != '.' && *ip_str != '\\0' && count < 4) {\n\t\t\tif (!isdigit(*ip_str)) {\n\t\t\t\treturn (uint32_t)0;\n\t\t\t}\n\t\t\t*ptr++ = *ip_str++;\n\t\t\tcount++;\n\t\t}\n\n\t\tif (count >= 4 || count == 0) {\n\t\t\treturn (uint32_t)0;\n\t\t}\n\n\t\t*ptr = '\\0';\n\t\tcur_byte = atoi(buf);\n\t\tif (cur_byte < 0 || cur_byte > 255) {\n\t\t\treturn (uint32_t)0;\n\t\t}\n\n\t\tip_str++;\n\t\tipaddr = ipaddr << 8 | (uint32_t)cur_byte;\n\t}\n\treturn ipaddr;\n}\n\n/*\n * Check for valid IP address in standard dot notation.\n */\nstatic int good_ipaddr(char *addr) {\n\tint dot_count;\n\tint digit_count;\n\n\tdot_count = 0;\n\tdigit_count = 0;\n\twhile(*addr != '\\0' && *addr != ' ') {\n\t\tif (*addr == '.') {\n\t\t\tdot_count++;\n\t\t\tdigit_count = 0;\n\t\t} else if (!isdigit(*addr)) {\n\t\t\tdot_count = 5;\n\t\t} else {\n\t\t\tdigit_count++;\n\t\t\tif (digit_count > 3) {\n\t\t\t\tdot_count = 5;\n\t\t\t}\n\t\t}\n\t\taddr++;\n\t}\n\tif (dot_count != 3) {\n\t\treturn -1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\n/*\n * Return an IP address in host long notation from a host\n * name or address in dot notation.\n */\nstatic uint32_t get_ipaddr(char *host) {\n\tstruct hostent *hp;\n\n\tif (good_ipaddr(host) == 0) {\n\t\treturn ipstr2long(host);\n\t} else if ((hp = gethostbyname(host)) == (struct hostent *)NULL) {\n\t\treturn (uint32_t)0;\n\t}\n\n\treturn ntohl(*(uint32_t *)hp->h_addr);\n}\n\n/*\n * take server->hostname, and convert it to server->ip and server->port\n */\nstatic int host2server(radius_server_t *server)\n{\n\tchar *p;\n\n\tif ((p = strchr(server->hostname, ':')) != NULL) {\n\t\t*(p++) = '\\0';\t\t/* split the port off from the host name */\n\t}\n\n\tif ((server->ip.s_addr = get_ipaddr(server->hostname)) == ((uint32_t)0)) {\n\t\tDPRINT(LOG_DEBUG, \"DEBUG: get_ipaddr(%s) returned 0.\\n\", server->hostname);\n\t\treturn PAM_AUTHINFO_UNAVAIL;\n\t}\n\n\t/*\n\t *\tIf the server port hasn't already been defined, go get it.\n\t */\n\tif (!server->port) {\n\t\tif (p && isdigit(*p)) {\t/* the port looks like it's a number */\n\t\t\tunsigned int i = atoi(p) & 0xffff;\n\n\t\t\tif (!server->accounting) {\n\t\t\t\tserver->port = htons((uint16_t) i);\n\t\t\t} else {\n\t\t\t\tserver->port = htons((uint16_t) (i + 1));\n\t\t\t}\n\t\t} else {\t\t\t/* the port looks like it's a name */\n\t\t\tstruct servent *svp;\n\n\t\t\tif (p) {\t\t\t/* maybe it's not \"radius\" */\n\t\t\t\tsvp = getservbyname (p, \"udp\");\n\t\t\t\t/* quotes allow distinction from above, lest p be radius or radacct */\n\t\t\t\tDPRINT(LOG_DEBUG, \"DEBUG: getservbyname('%s', udp) returned %p.\\n\", p, svp);\n\t\t\t\t*(--p) = ':';\t\t/* be sure to put the delimiter back */\n\t\t\t} else {\n\t\t\t\tif (!server->accounting) {\n\t\t\t\t\tsvp = getservbyname (\"radius\", \"udp\");\n\t\t\t\t\tDPRINT(LOG_DEBUG, \"DEBUG: getservbyname(radius, udp) returned %p.\\n\", svp);\n\t\t\t\t} else {\n\t\t\t\t\tsvp = getservbyname (\"radacct\", \"udp\");\n\t\t\t\t\tDPRINT(LOG_DEBUG, \"DEBUG: getservbyname(radacct, udp) returned %p.\\n\", svp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (svp == (struct servent *) 0) {\n\t\t\t\t/* debugging above... */\n\t\t\t\treturn PAM_AUTHINFO_UNAVAIL;\n\t\t\t}\n\n\t\t\tserver->port = svp->s_port;\n\t\t}\n\t}\n\n\treturn PAM_SUCCESS;\n}\n\n/*\n * Do XOR of two buffers.\n */\nstatic unsigned char * xor(unsigned char *p, unsigned char *q, int length)\n{\n\tint i;\n\tunsigned char *retval = p;\n\n\tfor (i = 0; i < length; i++) {\n\t\t*(p++) ^= *(q++);\n\t}\n\treturn retval;\n}\n\n/**************************************************************************\n * MID-LEVEL RADIUS CODE\n **************************************************************************/\n\n/*\n * get a pseudo-random vector.\n */\nstatic void get_random_vector(unsigned char *vector)\n{\n#ifdef linux\n\tint fd = open(\"/dev/urandom\",O_RDONLY); /* Linux: get *real* random numbers */\n\tint total = 0;\n\tif (fd >= 0) {\n\t\twhile (total < AUTH_VECTOR_LEN) {\n\t\t\tint bytes = read(fd, vector + total, AUTH_VECTOR_LEN - total);\n\t\t\tif (bytes <= 0)\n\t\t\t\tbreak;\t\t\t/* oops! Error */\n\t\t\ttotal += bytes;\n\t\t}\n\t\tclose(fd);\n\t}\n\n\tif (total != AUTH_VECTOR_LEN)\n#endif\n\t{\t\t\t\t/* do this *always* on other platforms */\n\t\tMD5_CTX my_md5;\n\t\tstruct timeval tv;\n\t\tstruct timezone tz;\n\t\tstatic unsigned int session = 0; /* make the number harder to guess */\n\n\t\t/* Use the time of day with the best resolution the system can\n\t \t   give us -- often close to microsecond accuracy. */\n\t\tgettimeofday(&tv,&tz);\n\n\t\tif (session == 0) {\n\t\t\tsession = getppid();\t/* (possibly) hard to guess information */\n\t\t}\n\n\t\ttv.tv_sec ^= getpid() * session++;\n\n\t\t/* Hash things to get maybe cryptographically strong pseudo-random numbers */\n\t\tMD5Init(&my_md5);\n\t\tMD5Update(&my_md5, (unsigned char *) &tv, sizeof(tv));\n\t\tMD5Update(&my_md5, (unsigned char *) &tz, sizeof(tz));\n\t\tMD5Final(vector, &my_md5);\t\t\t\t/* set the final vector */\n\t}\n}\n\n/*\n * RFC 2139 says to do generate the accounting request vector this way.\n * However, the Livingston 1.16 server doesn't check it.\tThe Cistron\n * server (http://home.cistron.nl/~miquels/radius/) does, and this code\n * seems to work with it.\tIt also works with Funk's Steel-Belted RADIUS.\n */\nstatic void get_accounting_vector(AUTH_HDR *request, radius_server_t *server)\n{\n\tMD5_CTX my_md5;\n\tint secretlen = strlen(server->secret);\n\tint len = ntohs(request->length);\n\n\tmemset(request->vector, 0, AUTH_VECTOR_LEN);\n\tMD5Init(&my_md5);\n\tmemcpy(((char *)request) + len, server->secret, secretlen);\n\n\tMD5Update(&my_md5, (unsigned char *)request, len + secretlen);\n\tMD5Final(request->vector, &my_md5);\t\t\t/* set the final vector */\n}\n\n/*\n * Verify the response from the server\n */\nstatic int verify_packet(char *secret, AUTH_HDR *response, AUTH_HDR *request)\n{\n\tMD5_CTX my_md5;\n\tunsigned char\tcalculated[AUTH_VECTOR_LEN];\n\tunsigned char\treply[AUTH_VECTOR_LEN];\n\n\t/*\n\t * We could dispense with the memcpy, and do MD5's of the packet\n\t * + vector piece by piece.\tThis is easier understand, and maybe faster.\n\t */\n\tmemcpy(reply, response->vector, AUTH_VECTOR_LEN); /* save the reply */\n\tmemcpy(response->vector, request->vector, AUTH_VECTOR_LEN); /* sent vector */\n\n\t/* MD5(response packet header + vector + response packet data + secret) */\n\tMD5Init(&my_md5);\n\tMD5Update(&my_md5, (unsigned char *) response, ntohs(response->length));\n\n\t/*\n\t * This next bit is necessary because of a bug in the original Livingston\n\t * RADIUS server.\tThe authentication vector is *supposed* to be MD5'd\n\t * with the old password (as the secret) for password changes.\n\t * However, the old password isn't used.\tThe \"authentication\" vector\n\t * for the server reply packet is simply the MD5 of the reply packet.\n\t * Odd, the code is 99% there, but the old password is never copied\n\t * to the secret!\n\t */\n\tif (*secret) {\n\t\tMD5Update(&my_md5, (unsigned char *) secret, strlen(secret));\n\t}\n\n\tMD5Final(calculated, &my_md5);\t\t\t/* set the final vector */\n\n\t/* Did he use the same random vector + shared secret? */\n\tif (memcmp(calculated, reply, AUTH_VECTOR_LEN) != 0) {\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\n/*\n * Find an attribute in a RADIUS packet.\tNote that the packet length\n * is *always* kept in network byte order.\n */\nstatic attribute_t *find_attribute(AUTH_HDR *response, unsigned char type)\n{\n\tattribute_t *attr = (attribute_t *) &response->data;\n\n\tint len = ntohs(response->length) - AUTH_HDR_LEN;\n\n\twhile (attr->attribute != type) {\n\t\tif ((len -= attr->length) <= 0) {\n\t\t\treturn NULL;\t\t/* not found */\n\t\t}\n\t\tattr = (attribute_t *) ((char *) attr + attr->length);\n\t}\n\n\treturn attr;\n}\n\n/*\n * Add an attribute to a RADIUS packet.\n */\nstatic void add_attribute(AUTH_HDR *request, unsigned char type, CONST unsigned char *data, int length)\n{\n\tattribute_t *p;\n\n\tp = (attribute_t *) ((unsigned char *)request + ntohs(request->length));\n\tp->attribute = type;\n\tp->length = length + 2;\t\t/* the total size of the attribute */\n\trequest->length = htons(ntohs(request->length) + p->length);\n\tmemcpy(p->data, data, length);\n}\n\n/*\n * Add an integer attribute to a RADIUS packet.\n */\nstatic void add_int_attribute(AUTH_HDR *request, unsigned char type, int data)\n{\n\tint value = htonl(data);\n\n\tadd_attribute(request, type, (unsigned char *) &value, sizeof(int));\n}\n\n/*\n * Add a RADIUS password attribute to the packet.\tSome magic is done here.\n *\n * If it's an PW_OLD_PASSWORD attribute, it's encrypted using the encrypted\n * PW_PASSWORD attribute as the initialization vector.\n *\n * If the password attribute already exists, it's over-written.\tThis allows\n * us to simply call add_password to update the password for different\n * servers.\n */\nstatic void add_password(AUTH_HDR *request, unsigned char type, CONST char *password, char *secret)\n{\n\tMD5_CTX md5_secret, my_md5;\n\tunsigned char misc[AUTH_VECTOR_LEN];\n\tint i;\n\tint length = strlen(password);\n\tunsigned char hashed[256 + AUTH_PASS_LEN];\t/* can't be longer than this */\n\tunsigned char *vector;\n\tattribute_t *attr;\n\n\tif (length > MAXPASS) {\t\t\t\t/* shorten the password for now */\n\t\tlength = MAXPASS;\n\t}\n\n\tif (length == 0) {\n\t\tlength = AUTH_PASS_LEN;\t\t\t/* 0 maps to 16 */\n\t} if ((length & (AUTH_PASS_LEN - 1)) != 0) {\n\t\tlength += (AUTH_PASS_LEN - 1);\t\t/* round it up */\n\t\tlength &= ~(AUTH_PASS_LEN - 1);\t\t/* chop it off */\n\t}\t\t\t\t\t\t/* 16*N maps to itself */\n\n\tmemset(hashed, 0, length);\n\tmemcpy(hashed, password, length);\n\n\tattr = find_attribute(request, PW_PASSWORD);\n\n\tif (type == PW_PASSWORD) {\n\t\tvector = request->vector;\n\t} else {\n\t\tvector = attr->data;\t\t\t/* attr CANNOT be NULL here. */\n\t}\n\n\t/* ************************************************************ */\n\t/* encrypt the password */\n\t/* password : e[0] = p[0] ^ MD5(secret + vector) */\n\tMD5Init(&md5_secret);\n\tMD5Update(&md5_secret, (unsigned char *) secret, strlen(secret));\n\tmy_md5 = md5_secret;\t\t\t\t/* so we won't re-do the hash later */\n\tMD5Update(&my_md5, vector, AUTH_VECTOR_LEN);\n\tMD5Final(misc, &my_md5);\t\t\t/* set the final vector */\n\txor(hashed, misc, AUTH_PASS_LEN);\n\n\t/* For each step through, e[i] = p[i] ^ MD5(secret + e[i-1]) */\n\tfor (i = 1; i < (length >> 4); i++) {\n\t\tmy_md5 = md5_secret;\t\t\t/* grab old value of the hash */\n\t\tMD5Update(&my_md5, &hashed[(i-1) * AUTH_PASS_LEN], AUTH_PASS_LEN);\n\t\tMD5Final(misc, &my_md5);\t\t\t/* set the final vector */\n\t\txor(&hashed[i * AUTH_PASS_LEN], misc, AUTH_PASS_LEN);\n\t}\n\n\tif (type == PW_OLD_PASSWORD) {\n\t\tattr = find_attribute(request, PW_OLD_PASSWORD);\n\t}\n\n\tif (!attr) {\n\t\tadd_attribute(request, type, hashed, length);\n\t} else {\n\t\tmemcpy(attr->data, hashed, length); /* overwrite the packet */\n\t}\n}\n\nstatic void cleanup(radius_server_t *server)\n{\n\tradius_server_t *next;\n\n\twhile (server) {\n\t\tnext = server->next;\n\t\t_pam_drop(server->hostname);\n\t\t_pam_forget(server->secret);\n\t\t_pam_drop(server);\n\t\tserver = next;\n\t}\n}\n\n/*\n * allocate and open a local port for communication with the RADIUS\n * server\n */\nstatic int initialize(radius_conf_t *conf, int accounting)\n{\n\tstruct sockaddr salocal;\n\tchar hostname[BUFFER_SIZE];\n\tchar secret[BUFFER_SIZE];\n\n\tchar buffer[BUFFER_SIZE];\n\tchar *p;\n\tFILE *fserver;\n\tradius_server_t *server = NULL;\n\tstruct sockaddr_in * s_in;\n\tint timeout;\n\tint line = 0;\n\n\t/* the first time around, read the configuration file */\n\tif ((fserver = fopen (conf_file, \"r\")) == (FILE*)NULL) {\n\t\t_pam_log(LOG_ERR, \"Could not open configuration file %s: %s\\n\",\n\t\t\tconf_file, strerror(errno));\n\t\treturn PAM_ABORT;\n\t}\n\n\twhile (!feof(fserver) && (fgets (buffer, sizeof(buffer), fserver) != (char*) NULL) && (!ferror(fserver))) {\n\t\tline++;\n\t\tp = buffer;\n\n\t\t/*\n\t\t *\tSkip blank lines and whitespace\n\t\t */\n\t\twhile (*p && ((*p == ' ') || (*p == '\\t') || (*p == '\\r') || (*p == '\\n'))) {\n\t\t\tp++;\n\t\t}\n\n\t\t/*\n\t\t *\tNothing, or just a comment. Ignore the line.\n\t\t */\n\t\tif ((!*p) || (*p == '#')) {\n\t\t\tcontinue;\n\t\t}\n\n\t\ttimeout = 3;\n\t\tif (sscanf(p, \"%s %s %d\", hostname, secret, &timeout) < 2) {\n\t\t\t_pam_log(LOG_ERR, \"ERROR reading %s, line %d: Could not read hostname or secret\\n\",\n\t\t\t\t conf_file, line);\n\t\t\tcontinue;\t\t\t/* invalid line */\n\t\t} else {\t\t\t\t/* read it in and save the data */\n\t\t\tradius_server_t *tmp;\n\n\t\t\ttmp = malloc(sizeof(radius_server_t));\n\t\t\tif (server) {\n\t\t\t\tserver->next = tmp;\n\t\t\t\tserver = server->next;\n\t\t\t} else {\n\t\t\t\tconf->server = tmp;\n\t\t\t\tserver= tmp;\t\t/* first time */\n\t\t\t}\n\n\t\t\t/* sometime later do memory checks here */\n\t\t\tserver->hostname = strdup(hostname);\n\t\t\tserver->secret = strdup(secret);\n\t\t\tserver->accounting = accounting;\n\t\t\tserver->port = 0;\n\n\t\t\tif ((timeout < 1) || (timeout > 60)) {\n\t\t\t\tserver->timeout = 3;\n\t\t\t} else {\n\t\t\t\tserver->timeout = timeout;\n\t\t\t}\n\t\t\tserver->next = NULL;\n\t\t}\n\t}\n\tfclose(fserver);\n\n\tif (!server) {\t\t/* no server found, die a horrible death */\n\t\t_pam_log(LOG_ERR, \"No RADIUS server found in configuration file %s\\n\",\n\t\t\t conf_file);\n\t\treturn PAM_AUTHINFO_UNAVAIL;\n\t}\n\n\t/* open a socket.\tDies if it fails */\n\tconf->sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (conf->sockfd < 0) {\n\t\t_pam_log(LOG_ERR, \"Failed to open RADIUS socket: %s\\n\", strerror(errno));\n\t\treturn PAM_AUTHINFO_UNAVAIL;\n\t}\n\n\t/* set up the local end of the socket communications */\n\ts_in = (struct sockaddr_in *) &salocal;\n\tmemset ((char *) s_in, '\\0', sizeof(struct sockaddr));\n\ts_in->sin_family = AF_INET;\n\ts_in->sin_addr.s_addr = INADDR_ANY;\n\ts_in->sin_port = 0;\n\t\n\n\tif (bind(conf->sockfd, &salocal, sizeof (struct sockaddr_in)) < 0) {\n\t\t_pam_log(LOG_ERR, \"Failed binding to port: %s\", strerror(errno));\n\t\tclose(conf->sockfd);\n\t\treturn PAM_AUTHINFO_UNAVAIL;\n\t}\n\n\treturn PAM_SUCCESS;\n}\n\n/*\n * Helper function for building a radius packet.\n * It initializes *some* of the header, and adds common attributes.\n */\nstatic void build_radius_packet(AUTH_HDR *request, CONST char *user, CONST char *password, radius_conf_t *conf)\n{\n\tchar hostname[256];\n\tuint32_t ipaddr;\n\n\thostname[0] = '\\0';\n\tgethostname(hostname, sizeof(hostname) - 1);\n\n\trequest->length = htons(AUTH_HDR_LEN);\n\n\tif (password) {\t\t/* make a random authentication req vector */\n\t\tget_random_vector(request->vector);\n\t}\n\n\tadd_attribute(request, PW_USER_NAME, (unsigned char *) user, strlen(user));\n\n\t/*\n\t *\tAdd a password, if given.\n\t */\n\tif (password) {\n\t\tadd_password(request, PW_PASSWORD, password, conf->server->secret);\n\n\t\t/*\n\t\t *\tAdd a NULL password to non-accounting requests.\n\t\t */\n\t} else if (request->code != PW_ACCOUNTING_REQUEST) {\n\t\tadd_password(request, PW_PASSWORD, \"\", conf->server->secret);\n\t}\n\n\t/* the packet is from localhost if on localhost, to make configs easier */\n\tif ((conf->server->ip.s_addr == ntohl(0x7f000001)) || (!hostname[0])) {\n\t\tipaddr = 0x7f000001;\n\t} else {\n\t\tstruct hostent *hp;\n\n\t\tif ((hp = gethostbyname(hostname)) == (struct hostent *) NULL) {\n\t\t\tipaddr = 0x00000000;\t/* no client IP address */\n\t\t} else {\n\t\t\tipaddr = ntohl(*(uint32_t *) hp->h_addr); /* use the first one available */\n\t\t}\n\t}\n\n\t/* If we can't find an IP address, then don't add one */\n\tif (ipaddr) {\n\t\tadd_int_attribute(request, PW_NAS_IP_ADDRESS, ipaddr);\n\t}\n\n\t/* There's always a NAS identifier */\n\tif (conf->client_id && *conf->client_id) {\n\t\tadd_attribute(request, PW_NAS_IDENTIFIER, (unsigned char *) conf->client_id, strlen(conf->client_id));\n\t}\n\n\t/*\n\t *\tAdd in the port (pid) and port type (virtual).\n\t *\n\t *\tWe might want to give the TTY name here, too.\n\t */\n\tadd_int_attribute(request, PW_NAS_PORT_ID, getpid());\n\tadd_int_attribute(request, PW_NAS_PORT_TYPE, PW_NAS_PORT_TYPE_VIRTUAL);\n}\n\n/*\n * Talk RADIUS to a server.\n * Send a packet and get the response\n */\nstatic int talk_radius(radius_conf_t *conf, AUTH_HDR *request, AUTH_HDR *response,\n\t\t       char *password, char *old_password, int tries)\n{\n\tsocklen_t salen;\n\tint total_length;\n\tfd_set set;\n\tstruct timeval tv;\n\ttime_t now, end;\n\tint rcode;\n\tstruct sockaddr saremote;\n\tstruct sockaddr_in *s_in = (struct sockaddr_in *) &saremote;\n\tradius_server_t *server = conf->server;\n\tint ok;\n\tint server_tries;\n\tint retval;\n\n\t/* ************************************************************ */\n\t/* Now that we're done building the request, we can send it */\n\n\t/*\n\t Hmm... on password change requests, all of the found server information\n\t could be saved with a pam_set_data(), which means even the radius_conf_t\n\t information will have to be malloc'd at some point\n\n\t On the other hand, we could just try all of the servers again in\n\t sequence, on the off chance that one may have ended up fixing itself.\n\n\t */\n\n\t/* loop over all available servers */\n\twhile (server != NULL) {\n\t\t/* clear the response */\n\t\tmemset(response, 0, sizeof(AUTH_HDR));\n\n\t\t/* only look up IP information as necessary */\n\t\tif ((retval = host2server(server)) != PAM_SUCCESS) {\n\t\t\t_pam_log(LOG_ERR,\n\t\t\t\t \"Failed looking up IP address for RADIUS server %s (errcode=%d)\",\n\t\t\t\t server->hostname, retval);\n\t\t\tok = FALSE;\n\t\t\tgoto next;\t\t/* skip to the next server */\n\t\t}\n\n\t\t/* set up per-server IP && port configuration */\n\t\tmemset ((char *) s_in, '\\0', sizeof(struct sockaddr));\n\t\ts_in->sin_family = AF_INET;\n\t\ts_in->sin_addr.s_addr = htonl(server->ip.s_addr);\n\t\ts_in->sin_port = server->port;\n\t\ttotal_length = ntohs(request->length);\n\n\t\tif (!password) { \t\t/* make an RFC 2139 p6 request authenticator */\n\t\t\tget_accounting_vector(request, server);\n\t\t}\n\n\t\tserver_tries = tries;\n\tsend:\n\t\t/* send the packet */\n\t\tif (sendto(conf->sockfd, (char *) request, total_length, 0,\n\t\t\t   &saremote, sizeof(struct sockaddr_in)) < 0) {\n\t\t\t_pam_log(LOG_ERR, \"Error sending RADIUS packet to server %s: %s\",\n\t\t\t\t server->hostname, strerror(errno));\n\t\t\tok = FALSE;\n\t\t\tgoto next;\t\t/* skip to the next server */\n\t\t}\n\n\t\t/* ************************************************************ */\n\t\t/* Wait for the response, and verify it. */\n\t\tsalen = sizeof(struct sockaddr);\n\t\ttv.tv_sec = server->timeout;\t/* wait for the specified time */\n\t\ttv.tv_usec = 0;\n\t\tFD_ZERO(&set);\t\t\t/* clear out the set */\n\t\tFD_SET(conf->sockfd, &set);\t/* wait only for the RADIUS UDP socket */\n\n\t\ttime(&now);\n\t\tend = now + tv.tv_sec;\n\n\t\t/* loop, waiting for the select to return data */\n\t\tok = TRUE;\n\t\twhile (ok) {\n\t\t\trcode = select(conf->sockfd + 1, &set, NULL, NULL, &tv);\n\n\t\t\t/* select timed out */\n\t\t\tif (rcode == 0) {\n\t\t\t\t_pam_log(LOG_ERR, \"RADIUS server %s failed to respond\", server->hostname);\n\t\t\t\tif (--server_tries) {\n\t\t\t\t\tgoto send;\n\t\t\t\t}\n\t\t\t\tok = FALSE;\n\t\t\t\tbreak;\t\t\t/* exit from the select loop */\n\t\t\t} else if (rcode < 0) {\n\n\t\t\t\t/* select had an error */\n\t\t\t\tif (errno == EINTR) {\t/* we were interrupted */\n\t\t\t\t\ttime(&now);\n\n\t\t\t\t\tif (now > end) {\n\t\t\t\t\t\t_pam_log(LOG_ERR, \"RADIUS server %s failed to respond\",\n\t\t\t\t\t\t\t server->hostname);\n\t\t\t\t\t\tif (--server_tries) goto send;\n\t\t\t\t\t\tok = FALSE;\n\t\t\t\t\t\tbreak;\t\t/* exit from the select loop */\n\t\t\t\t\t}\n\n\t\t\t\t\ttv.tv_sec = end - now;\n\t\t\t\t\tif (tv.tv_sec == 0) {\t/* keep waiting */\n\t\t\t\t\t\ttv.tv_sec = 1;\n\t\t\t\t\t}\n\n\t\t\t\t} else {\t\t\t/* not an interrupt, it was a real error */\n\t\t\t\t\t_pam_log(LOG_ERR, \"Error waiting for response from RADIUS server %s: %s\",\n\t\t\t\t\t\t server->hostname, strerror(errno));\n\t\t\t\t\tok = FALSE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t/* the select returned OK */\n\t\t\t} else if (FD_ISSET(conf->sockfd, &set)) {\n\n\t\t\t\t/* try to receive some data */\n\t\t\t\tif ((total_length = recvfrom(conf->sockfd, (void *) response, BUFFER_SIZE,\n\t\t\t\t\t\t     \t     0, &saremote, &salen)) < 0) {\n\t\t\t\t\t_pam_log(LOG_ERR, \"error reading RADIUS packet from server %s: %s\",\n\t\t\t\t\t \t server->hostname, strerror(errno));\n\t\t\t\t\tok = FALSE;\n\t\t\t\t\tbreak;\n\n\t\t\t\t/* there's data, see if it's valid */\n\t\t\t\t} else {\n\t\t\t\t\tchar *p = server->secret;\n\n\t\t\t\t\tif ((ntohs(response->length) != total_length) ||\n\t\t\t\t\t    (ntohs(response->length) > BUFFER_SIZE)) {\n\t\t\t\t\t\t_pam_log(LOG_ERR, \"RADIUS packet from server %s is corrupted\",\n\t\t\t\t\t\t \t server->hostname);\n\t\t\t\t\t\tok = FALSE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Check if we have the data OK. We should also check request->id */\n\t\t\t\t\tif (password) {\n\t\t\t\t\t\tif (old_password) {\n#ifdef LIVINGSTON_PASSWORD_VERIFY_BUG_FIXED\n\t\t\t\t\t\t\tp = old_password;\t/* what it should be */\n#else\n\t\t\t\t\t\t\tp = \"\";\t\t\t/* what it really is */\n#endif\n\t\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * RFC 2139 p.6 says not do do this, but the Livingston 1.16\n\t\t\t\t\t * server disagrees.\tIf the user says he wants the bug, give in.\n\t\t\t\t\t */\n\t\t\t\t\t} else {\t\t/* authentication request */\n\t\t\t\t\t\tif (conf->accounting_bug) {\n\t\t\t\t\t\t\tp = \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!verify_packet(p, response, request)) {\n\t\t\t\t\t\t_pam_log(LOG_ERR, \"packet from RADIUS server %s failed verification: \"\n\t\t\t\t\t\t\t \"The shared secret is probably incorrect.\", server->hostname);\n\t\t\t\t\t\tok = FALSE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Check that the response ID matches the request ID.\n\t\t\t\t\t */\n\t\t\t\t\tif (response->id != request->id) {\n\t\t\t\t\t\t_pam_log(LOG_WARNING, \"Response packet ID %d does not match the \"\n\t\t\t\t\t\t\t \"request packet ID %d: verification of packet fails\",\n\t\t\t\t\t\t\t response->id, request->id);\n\t\t\t\t\t\tok = FALSE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Whew! The select is done. It hasn't timed out, or errored out.\n\t\t\t\t * It's our descriptor.\tWe've got some data. It's the right size.\n\t\t\t\t * The packet is valid.\n\t\t\t\t * NOW, we can skip out of the select loop, and process the packet\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* otherwise, we've got data on another descriptor, keep select'ing */\n\t\t}\n\n\t\t\t/* go to the next server if this one didn't respond */\n\t\tnext:\n\t\tif (!ok) {\n\t\t\tradius_server_t *old;\t/* forget about this server */\n\n\t\t\told = server;\n\t\t\tserver = server->next;\n\t\t\tconf->server = server;\n\n\t\t\t_pam_forget(old->secret);\n\t\t\tfree(old->hostname);\n\t\t\tfree(old);\n\n\t\t\tif (server) {\t\t/* if there's more servers to check */\n\t\t\t\t/* get a new authentication vector, and update the passwords */\n\t\t\t\tget_random_vector(request->vector);\n\t\t\t\trequest->id = request->vector[0];\n\n\t\t\t\t/* update passwords, as appropriate */\n\t\t\t\tif (password) {\n\t\t\t\t\tget_random_vector(request->vector);\n\t\t\t\t\tif (old_password) {\t/* password change request */\n\t\t\t\t\t\tadd_password(request, PW_PASSWORD, password, old_password);\n\t\t\t\t\t\tadd_password(request, PW_OLD_PASSWORD, old_password, old_password);\n\t\t\t\t\t} else {\t\t/* authentication request */\n\t\t\t\t\t\tadd_password(request, PW_PASSWORD, password, server->secret);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\n\t\t} else {\n\t\t\t/* we've found one that does respond, forget about the other servers */\n\t\t\tcleanup(server->next);\n\t\t\tserver->next = NULL;\n\t\t\tlive_server = server;\t/* we've got a live one! */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!server) {\n\t\t_pam_log(LOG_ERR, \"All RADIUS servers failed to respond.\");\n\t\tif (conf->localifdown)\n\t\t\tretval = PAM_IGNORE;\n\t\telse\n\t\t\tretval = PAM_AUTHINFO_UNAVAIL;\n\t} else {\n\t\tretval = PAM_SUCCESS;\n\t}\n\n\treturn retval;\n}\n\n/**************************************************************************\n * MIDLEVEL PAM CODE\n **************************************************************************/\n\n/* this is our front-end for module-application conversations */\n\n#undef PAM_FAIL_CHECK\n#define PAM_FAIL_CHECK if (retval != PAM_SUCCESS) { return retval; }\n\nstatic int rad_converse(pam_handle_t *pamh, int msg_style, char *message, char **password)\n{\n\tCONST struct pam_conv *conv;\n\tstruct pam_message resp_msg;\n\tCONST struct pam_message *msg[1];\n\tstruct pam_response *resp = NULL;\n\tint retval;\n\n\tresp_msg.msg_style = msg_style;\n\tresp_msg.msg = message;\n\tmsg[0] = &resp_msg;\n\n\t/* grab the password */\n\tretval = pam_get_item(pamh, PAM_CONV, (CONST void **) &conv);\n\tPAM_FAIL_CHECK;\n\n\tretval = conv->conv(1, msg, &resp,conv->appdata_ptr);\n\tPAM_FAIL_CHECK;\n\n\tif (password) {\t\t/* assume msg.type needs a response */\n\t\t/* I'm not sure if this next bit is necessary on Linux */\n#ifdef sun\n\t\t/* NULL response, fail authentication */\n\t\tif ((resp == NULL) || (resp->resp == NULL)) {\n\t\t\treturn PAM_SYSTEM_ERR;\n\t\t}\n#endif\n\n\t\t*password = resp->resp;\n\t\tfree(resp);\n\t}\n\n\treturn PAM_SUCCESS;\n}\n\n/**************************************************************************\n * GENERAL CODE\n **************************************************************************/\n\n#undef PAM_FAIL_CHECK\n#define PAM_FAIL_CHECK if (retval != PAM_SUCCESS) { \\\n\tint *pret = malloc(sizeof(int)); \\\n\t*pret = retval;\t\\\n\tpam_set_data(pamh, \"rad_setcred_return\", (void *) pret, _int_free);\t\\\n\treturn retval; }\n\nPAM_EXTERN int pam_sm_authenticate(pam_handle_t *pamh,int flags,int argc,CONST char **argv)\n{\n\tCONST char *user;\n\tCONST char *userinfo;\n\tchar *password = NULL;\n\tCONST char *rhost;\n\tchar *resp2challenge = NULL;\n\tint ctrl;\n\tint retval = PAM_AUTH_ERR;\n\tint num_challenge = 0;\n\n\tchar recv_buffer[4096];\n\tchar send_buffer[4096];\n\tAUTH_HDR *request = (AUTH_HDR *) send_buffer;\n\tAUTH_HDR *response = (AUTH_HDR *) recv_buffer;\n\tradius_conf_t config;\n\n\tctrl = _pam_parse(argc, argv, &config);\n\n\t/* grab the user name */\n\tretval = pam_get_user(pamh, &user, NULL);\n\tPAM_FAIL_CHECK;\n\n\t/* check that they've entered something, and not too long, either */\n\tif ((user == NULL) || (strlen(user) > MAXPWNAM)) {\n\t\tint *pret = malloc(sizeof(int));\n\t\t*pret = PAM_USER_UNKNOWN;\n\t\tpam_set_data(pamh, \"rad_setcred_return\", (void *) pret, _int_free);\n\n\t\tDPRINT(LOG_DEBUG, \"User name was NULL, or too long\");\n\t\treturn PAM_USER_UNKNOWN;\n\t}\n\tDPRINT(LOG_DEBUG, \"Got user name %s\", user);\n\n\tif (ctrl & PAM_RUSER_ARG) {\n\t\tretval = pam_get_item(pamh, PAM_RUSER, (CONST void **) &userinfo);\n\t\tPAM_FAIL_CHECK;\n\t\tDPRINT(LOG_DEBUG, \"Got PAM_RUSER name %s\", userinfo);\n\n\t\tif (!strcmp(\"root\", user)) {\n\t\t\tuser = userinfo;\n\t\t\tDPRINT(LOG_DEBUG, \"Username now %s from ruser\", user);\n\t\t} else {\n\t\t\tDPRINT(LOG_DEBUG, \"Skipping ruser for non-root auth\");\n\t\t}\n\t}\n\n\t/*\n\t * Get the IP address of the authentication server\n\t * Then, open a socket, and bind it to a port\n\t */\n\tretval = initialize(&config, FALSE);\n\tPAM_FAIL_CHECK;\n\n\t/*\n\t * If there's no client id specified, use the service type, to help\n\t * keep track of which service is doing the authentication.\n\t */\n\tif (!config.client_id) {\n\t\tretval = pam_get_item(pamh, PAM_SERVICE, (CONST void **) &config.client_id);\n\t\tPAM_FAIL_CHECK;\n\t}\n\n\t/* now we've got a socket open, so we've got to clean it up on error */\n#undef PAM_FAIL_CHECK\n#define PAM_FAIL_CHECK if (retval != PAM_SUCCESS) {goto error; }\n\n\t/* build and initialize the RADIUS packet */\n\trequest->code = PW_AUTHENTICATION_REQUEST;\n\tget_random_vector(request->vector);\n\trequest->id = request->vector[0]; /* this should be evenly distributed */\n\n\t/* grab the password (if any) from the previous authentication layer */\n        if (!config.force_prompt) {\n                DPRINT(LOG_DEBUG, \"ignore last_pass, force_prompt set\");\n\t\tretval = pam_get_item(pamh, PAM_AUTHTOK, (CONST void **) &password);\n\t\tPAM_FAIL_CHECK;\n        }\n\n\tif (password) {\n\t\tpassword = strdup(password);\n\t\tDPRINT(LOG_DEBUG, \"Got password %s\", password);\n\t}\n\n\t/* no previous password: maybe get one from the user */\n\tif (!password) {\n\t\tif (ctrl & PAM_USE_FIRST_PASS) {\n\t\t\tretval = PAM_AUTH_ERR;\t/* use one pass only, stopping if it fails */\n\t\t\tgoto error;\n\t\t}\n\n\t\t/* check to see if we send a NULL password the first time around */\n\t\tif (!(ctrl & PAM_SKIP_PASSWD)) {\n\t\t\tretval = rad_converse(pamh, PAM_PROMPT_ECHO_OFF, config.prompt, &password);\n\t\t\tPAM_FAIL_CHECK;\n\n\t\t}\n\t} /* end of password == NULL */\n\n\tbuild_radius_packet(request, user, password, &config);\n\t/* not all servers understand this service type, but some do */\n\tadd_int_attribute(request, PW_USER_SERVICE_TYPE, PW_AUTHENTICATE_ONLY);\n\n\t/*\n\t *\tTell the server which host the user is coming from.\n\t *\n\t *\tNote that this is NOT the IP address of the machine running PAM!\n\t *\tIt's the IP address of the client.\n\t */\n\tretval = pam_get_item(pamh, PAM_RHOST, (CONST void **) &rhost);\n\tPAM_FAIL_CHECK;\n\tif (rhost) {\n\t\tadd_attribute(request, PW_CALLING_STATION_ID, (unsigned char *) rhost,\n\t\t\tstrlen(rhost));\n\t}\n\n\tDPRINT(LOG_DEBUG, \"Sending RADIUS request code %d\", request->code);\n\n\tretval = talk_radius(&config, request, response, password, NULL, config.retries + 1);\n\tPAM_FAIL_CHECK;\n\n\tDPRINT(LOG_DEBUG, \"Got RADIUS response code %d\", response->code);\n\n\t/*\n\t *\tIf we get an authentication failure, and we sent a NULL password,\n\t *\task the user for one and continue.\n\t *\n\t *\tIf we get an access challenge, then do a response, for as many\n\t *\tchallenges as we receive.\n\t */\n\twhile (response->code == PW_ACCESS_CHALLENGE) {\n\t\tattribute_t *a_state, *a_reply;\n\t\tchar challenge[BUFFER_SIZE];\n\n\t\t/* Now we do a bit more work: challenge the user, and get a response */\n\t\tif (((a_state = find_attribute(response, PW_STATE)) == NULL) ||\n\t\t    ((a_reply = find_attribute(response, PW_REPLY_MESSAGE)) == NULL)) {\n\t\t\t/* Actually, State isn't required. */\n\t\t\t_pam_log(LOG_ERR, \"RADIUS Access-Challenge received with State or Reply-Message missing\");\n\t\t\tretval = PAM_AUTHINFO_UNAVAIL;\n\t\t\tgoto error;\n\t\t}\n\n\t\t/*\n\t\t *\tSecurity fixes.\n\t\t */\n\t\tif ((a_state->length <= 2) || (a_reply->length <= 2)) {\n\t\t\t_pam_log(LOG_ERR, \"RADIUS Access-Challenge received with invalid State or Reply-Message\");\n\t\t\tretval = PAM_AUTHINFO_UNAVAIL;\n\t\t\tgoto error;\n\t\t}\n\n\t\tmemcpy(challenge, a_reply->data, a_reply->length - 2);\n\t\tchallenge[a_reply->length - 2] = 0;\n\n\t\t/* It's full challenge-response, we should have echo on */\n\t\tretval = rad_converse(pamh, PAM_PROMPT_ECHO_ON, challenge, &resp2challenge);\n\t\tPAM_FAIL_CHECK;\n\n\t\t/* now that we've got a response, build a new radius packet */\n\t\tbuild_radius_packet(request, user, resp2challenge, &config);\n\t\t/* request->code is already PW_AUTHENTICATION_REQUEST */\n\t\trequest->id++;\t\t/* one up from the request */\n\n\t\tif (rhost) {\n\t\t\tadd_attribute(request, PW_CALLING_STATION_ID, (unsigned char *) rhost,\n\t\t\t\t      strlen(rhost));\n\t\t}\n\n\t\t/* copy the state over from the servers response */\n\t\tadd_attribute(request, PW_STATE, a_state->data, a_state->length - 2);\n\n\t\tretval = talk_radius(&config, request, response, resp2challenge, NULL, 1);\n\t\tPAM_FAIL_CHECK;\n\n\t\tDPRINT(LOG_DEBUG, \"Got response to challenge code %d\", response->code);\n\n\t\t/*\n\t\t * max_challenge limits the # of challenges a server can issue\n\t\t * It's a workaround for buggy servers\n\t\t */\n\t\tif (config.max_challenge > 0 && response->code == PW_ACCESS_CHALLENGE) {\n\t\t\tnum_challenge++;\n\t\t\tif (num_challenge >= config.max_challenge) {\n\t\t\t\tDPRINT(LOG_DEBUG, \"maximum number of challenges (%d) reached, failing\", num_challenge);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Whew! Done the pasword checks, look for an authentication acknowledge */\n\tif (response->code == PW_AUTHENTICATION_ACK) {\n\t\tretval = PAM_SUCCESS;\n\t} else {\n\t\tretval = PAM_AUTH_ERR;\t/* authentication failure */\n\nerror:\n\t\t/* If there was a password pass it to the next layer */\n\t\tif (password && *password) {\n\t\t\tpam_set_item(pamh, PAM_AUTHTOK, password);\n\t\t}\n\t}\n\n\tDPRINT(LOG_DEBUG, \"authentication %s\", retval==PAM_SUCCESS ? \"succeeded\":\"failed\");\n\n\tclose(config.sockfd);\n\tcleanup(config.server);\n\t_pam_forget(password);\n\t_pam_forget(resp2challenge);\n\t{\n\t\tint *pret = malloc(sizeof(int));\n\t\t*pret = retval;\n\t\tpam_set_data(pamh, \"rad_setcred_return\", (void *) pret, _int_free);\n\t}\n\treturn retval;\n}\n\n/*\n * Return a value matching the return value of pam_sm_authenticate, for\n * greatest compatibility.\n * (Always returning PAM_SUCCESS breaks other authentication modules;\n * always returning PAM_IGNORE breaks PAM when we're the only module.)\n */\nPAM_EXTERN int pam_sm_setcred(pam_handle_t *pamh,int flags,int argc,CONST char **argv)\n{\n\tint retval, *pret;\n\n\tretval = PAM_SUCCESS;\n\tpret = &retval;\n\tpam_get_data(pamh, \"rad_setcred_return\", (CONST void **) &pret);\n\treturn *pret;\n}\n\n#undef PAM_FAIL_CHECK\n#define PAM_FAIL_CHECK if (retval != PAM_SUCCESS) { return PAM_SESSION_ERR; }\n\nstatic int pam_private_session(pam_handle_t *pamh, int flags, int argc, CONST char **argv, int status)\n{\n\tCONST char *user;\n\tint ctrl;\n\tint retval = PAM_AUTH_ERR;\n\n\tchar recv_buffer[4096];\n\tchar send_buffer[4096];\n\tAUTH_HDR *request = (AUTH_HDR *) send_buffer;\n\tAUTH_HDR *response = (AUTH_HDR *) recv_buffer;\n\tradius_conf_t config;\n\n\tctrl = _pam_parse(argc, argv, &config);\n\n\t/* grab the user name */\n\tretval = pam_get_user(pamh, &user, NULL);\n\tPAM_FAIL_CHECK;\n\n\t/* check that they've entered something, and not too long, either */\n\tif ((user == NULL) || (strlen(user) > MAXPWNAM)) {\n\t\treturn PAM_USER_UNKNOWN;\n\t}\n\n\t/*\n\t * Get the IP address of the authentication server\n\t * Then, open a socket, and bind it to a port\n\t */\n\tretval = initialize(&config, TRUE);\n\tPAM_FAIL_CHECK;\n\n\t/*\n\t * If there's no client id specified, use the service type, to help\n\t * keep track of which service is doing the authentication.\n\t */\n\tif (!config.client_id) {\n\t\tretval = pam_get_item(pamh, PAM_SERVICE, (CONST void **) &config.client_id);\n\t\tPAM_FAIL_CHECK;\n\t}\n\n\t/* now we've got a socket open, so we've got to clean it up on error */\n#undef PAM_FAIL_CHECK\n#define PAM_FAIL_CHECK if (retval != PAM_SUCCESS) {goto error; }\n\n\t/* build and initialize the RADIUS packet */\n\trequest->code = PW_ACCOUNTING_REQUEST;\n\tget_random_vector(request->vector);\n\trequest->id = request->vector[0]; /* this should be evenly distributed */\n\n\tbuild_radius_packet(request, user, NULL, &config);\n\n\tadd_int_attribute(request, PW_ACCT_STATUS_TYPE, status);\n\n\tsprintf(recv_buffer, \"%08d\", (int) getpid());\n\tadd_attribute(request, PW_ACCT_SESSION_ID, (unsigned char *) recv_buffer, strlen(recv_buffer));\n\n\tadd_int_attribute(request, PW_ACCT_AUTHENTIC, PW_AUTH_RADIUS);\n\n\tif (status == PW_STATUS_START) {\n\t\tsession_time = time(NULL);\n\t} else {\n\t\tadd_int_attribute(request, PW_ACCT_SESSION_TIME, time(NULL) - session_time);\n\t}\n\n\tretval = talk_radius(&config, request, response, NULL, NULL, 1);\n\tPAM_FAIL_CHECK;\n\n\t/* oops! They don't have the right password.\tComplain and die. */\n\tif (response->code != PW_ACCOUNTING_RESPONSE) {\n\t\tretval = PAM_PERM_DENIED;\n\t\tgoto error;\n\t}\n\n\tretval = PAM_SUCCESS;\n\nerror:\n\n\tclose(config.sockfd);\n\tcleanup(config.server);\n\n\treturn retval;\n}\n\nPAM_EXTERN int pam_sm_open_session(pam_handle_t *pamh, int flags, int argc, CONST char **argv)\n{\n\treturn pam_private_session(pamh, flags, argc, argv, PW_STATUS_START);\n}\n\nPAM_EXTERN int pam_sm_close_session(pam_handle_t *pamh, int flags, int argc, CONST char **argv)\n{\n\treturn pam_private_session(pamh, flags, argc, argv, PW_STATUS_STOP);\n}\n\n#undef PAM_FAIL_CHECK\n#define PAM_FAIL_CHECK if (retval != PAM_SUCCESS) {return retval; }\n#define MAX_PASSWD_TRIES 3\n\nPAM_EXTERN int pam_sm_chauthtok(pam_handle_t *pamh, int flags, int argc, CONST char **argv)\n{\n\tCONST char *user;\n\tchar *password = NULL;\n\tchar *new_password = NULL;\n\tchar *check_password = NULL;\n\tint ctrl;\n\tint retval = PAM_AUTHTOK_ERR;\n\tint attempts;\n\n\tchar recv_buffer[4096];\n\tchar send_buffer[4096];\n\tAUTH_HDR *request = (AUTH_HDR *) send_buffer;\n\tAUTH_HDR *response = (AUTH_HDR *) recv_buffer;\n\tradius_conf_t config;\n\n\tctrl = _pam_parse(argc, argv, &config);\n\n\t/* grab the user name */\n\tretval = pam_get_user(pamh, &user, NULL);\n\tPAM_FAIL_CHECK;\n\n\t/* check that they've entered something, and not too long, either */\n\tif ((user == NULL) || (strlen(user) > MAXPWNAM)) {\n\t\treturn PAM_USER_UNKNOWN;\n\t}\n\n\t/*\n\t * Get the IP address of the authentication server\n\t * Then, open a socket, and bind it to a port\n\t */\n\tretval = initialize(&config, FALSE);\n\tPAM_FAIL_CHECK;\n\n\t/*\n\t * If there's no client id specified, use the service type, to help\n\t * keep track of which service is doing the authentication.\n\t */\n\tif (!config.client_id) {\n\t\tretval = pam_get_item(pamh, PAM_SERVICE, (CONST void **) &config.client_id);\n\t\tPAM_FAIL_CHECK;\n\t}\n\n\t/* now we've got a socket open, so we've got to clean it up on error */\n#undef PAM_FAIL_CHECK\n#define PAM_FAIL_CHECK if (retval != PAM_SUCCESS) {goto error; }\n\n\t/* grab the old password (if any) from the previous password layer */\n\tretval = pam_get_item(pamh, PAM_OLDAUTHTOK, (CONST void **) &password);\n\tPAM_FAIL_CHECK;\n\tif (password) password = strdup(password);\n\n\t/* grab the new password (if any) from the previous password layer */\n\tretval = pam_get_item(pamh, PAM_AUTHTOK, (CONST void **) &new_password);\n\tPAM_FAIL_CHECK;\n\tif (new_password) new_password = strdup(new_password);\n\n\t/* preliminary password change checks. */\n\tif (flags & PAM_PRELIM_CHECK) {\n\t\tif (!password) {\t\t/* no previous password: ask for one */\n\t\t\tretval = rad_converse(pamh, PAM_PROMPT_ECHO_OFF, config.prompt, &password);\n\t\t\tPAM_FAIL_CHECK;\n\t\t}\n\n\t\t/*\n\t\t * We now check the password to see if it's the right one.\n\t\t * If it isn't, we let the user try again.\n\t\t * Note that RADIUS doesn't have any concept of 'root'.\tThe only way\n\t\t * that root can change someone's password is to log into the RADIUS\n\t\t * server, and and change it there.\n\t\t */\n\n\t\t/* build and initialize the access request RADIUS packet */\n\t\trequest->code = PW_AUTHENTICATION_REQUEST;\n\t\tget_random_vector(request->vector);\n\t\trequest->id = request->vector[0]; /* this should be evenly distributed */\n\n\t\tbuild_radius_packet(request, user, password, &config);\n\t\tadd_int_attribute(request, PW_USER_SERVICE_TYPE, PW_AUTHENTICATE_ONLY);\n\n\t\tretval = talk_radius(&config, request, response, password, NULL, 1);\n\t\tPAM_FAIL_CHECK;\n\n\t\t/* oops! They don't have the right password.\tComplain and die. */\n\t\tif (response->code != PW_AUTHENTICATION_ACK) {\n\t\t\t_pam_forget(password);\n\t\t\tretval = PAM_PERM_DENIED;\n\t\t\tgoto error;\n\t\t}\n\n\t\t/*\n\t\t * We're now sure it's the right user.\n\t\t * Ask for their new password, if appropriate\n\t\t */\n\n\t\tif (!new_password) {\t/* not found yet: ask for it */\n\t\t\tint new_attempts;\n\t\t\tattempts = 0;\n\n\t\t\t/* loop, trying to get matching new passwords */\n\t\t\twhile (attempts++ < 3) {\n\n\t\t\t\t/* loop, trying to get a new password */\n\t\t\t\tnew_attempts = 0;\n\t\t\t\twhile (new_attempts++ < 3) {\n\t\t\t\t\tretval = rad_converse(pamh, PAM_PROMPT_ECHO_OFF,\n\t\t\t\t\t\t\t\"New password: \", &new_password);\n\t\t\t\t\tPAM_FAIL_CHECK;\n\n\t\t\t\t\t/* the old password may be short.\tCheck it, first. */\n\t\t\t\t\tif (strcmp(password, new_password) == 0) { /* are they the same? */\n\t\t\t\t\t\trad_converse(pamh, PAM_ERROR_MSG,\n\t\t\t\t\t\t \"You must choose a new password.\", NULL);\n\t\t\t\t\t\t_pam_forget(new_password);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (strlen(new_password) < 6) {\n\t\t\t\t\t\trad_converse(pamh, PAM_ERROR_MSG, \"it's WAY too short\", NULL);\n\t\t\t\t\t\t_pam_forget(new_password);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* insert crypt password checking here */\n\n\t\t\t\t\tbreak;\t\t/* the new password is OK */\n\t\t\t\t}\n\n\t\t\t\tif (new_attempts >= 3) { /* too many new password attempts: die */\n\t\t\t\t\tretval = PAM_AUTHTOK_ERR;\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\n\t\t\t\t/* make sure of the password by asking for verification */\n\t\t\t\tretval = rad_converse(pamh, PAM_PROMPT_ECHO_OFF,\n\t\t\t\t\t\t      \"New password (again): \", &check_password);\n\t\t\t\tPAM_FAIL_CHECK;\n\n\t\t\t\tretval = strcmp(new_password, check_password);\n\t\t\t\t_pam_forget(check_password);\n\n\t\t\t\t/* if they don't match, don't pass them to the next module */\n\t\t\t\tif (retval != 0) {\n\t\t\t\t\t_pam_forget(new_password);\n\t\t\t\t\trad_converse(pamh, PAM_ERROR_MSG,\n\t\t\t\t\t\t\t\t \"You must enter the same password twice.\", NULL);\n\t\t\t\t\tretval = PAM_AUTHTOK_ERR;\n\t\t\t\t\tgoto error;\t\t/* ??? maybe this should be a 'continue' ??? */\n\t\t\t\t}\n\n\t\t\t\tbreak;\t\t\t/* everything's fine */\n\t\t\t}\t/* loop, trying to get matching new passwords */\n\n\t\t\tif (attempts >= 3) { /* too many new password attempts: die */\n\t\t\t\tretval = PAM_AUTHTOK_ERR;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} /* now we have a new password which passes all of our tests */\n\n\t\t/*\n\t\t * Solaris 2.6 calls pam_sm_chauthtok only ONCE, with PAM_PRELIM_CHECK\n\t\t * set.\n\t\t */\n#ifndef sun\n\t\t/* If told to update the authentication token, do so. */\n\t} else if (flags & PAM_UPDATE_AUTHTOK) {\n#endif\n\n\t\tif (!password || !new_password) { /* ensure we've got passwords */\n\t\t\tretval = PAM_AUTHTOK_ERR;\n\t\t\tgoto error;\n\t\t}\n\n\t\t/* build and initialize the password change request RADIUS packet */\n\t\trequest->code = PW_PASSWORD_REQUEST;\n\t\tget_random_vector(request->vector);\n\t\trequest->id = request->vector[0]; /* this should be evenly distributed */\n\n\t\t/* the secret here can not be know to the user, so it's the new password */\n\t\t_pam_forget(config.server->secret);\n\t\tconfig.server->secret = strdup(password); /* it's free'd later */\n\n\t\tbuild_radius_packet(request, user, new_password, &config);\n\t\tadd_password(request, PW_OLD_PASSWORD, password, password);\n\n\t\tretval = talk_radius(&config, request, response, new_password, password, 1);\n\t\tPAM_FAIL_CHECK;\n\n\t\t/* Whew! Done password changing, check for password acknowledge */\n\t\tif (response->code != PW_PASSWORD_ACK) {\n\t\t\tretval = PAM_AUTHTOK_ERR;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/*\n\t * Send the passwords to the next stage if preliminary checks fail,\n\t * or if the password change request fails.\n\t */\n\tif ((flags & PAM_PRELIM_CHECK) || (retval != PAM_SUCCESS)) {\n\terror:\n\n\t\t/* If there was a password pass it to the next layer */\n\t\tif (password && *password) {\n\t\t\tpam_set_item(pamh, PAM_OLDAUTHTOK, password);\n\t\t}\n\n\t\tif (new_password && *new_password) {\n\t\t\tpam_set_item(pamh, PAM_AUTHTOK, new_password);\n\t\t}\n\t}\n\n\tif (ctrl & PAM_DEBUG_ARG) {\n\t\t_pam_log(LOG_DEBUG, \"password change %s\", retval==PAM_SUCCESS ? \"succeeded\" : \"failed\");\n\t}\n\n\tclose(config.sockfd);\n\tcleanup(config.server);\n\n\t_pam_forget(password);\n\t_pam_forget(new_password);\n\treturn retval;\n}\n\n/*\n *\tDo nothing for account management. This is apparently needed by\n *\tsome programs.\n */\nPAM_EXTERN int pam_sm_acct_mgmt(pam_handle_t *pamh,int flags,int argc,CONST char **argv)\n{\n\tint retval;\n\tretval = PAM_SUCCESS;\n\treturn retval;\n}\n\n#ifdef PAM_STATIC\n\n/* static module data */\n\nstruct pam_module _pam_radius_modstruct = {\n\t\"pam_radius_auth\",\n\tpam_sm_authenticate,\n\tpam_sm_setcred,\n\tpam_sm_acct_mgmt,\n\tpam_sm_open_session,\n\tpam_sm_close_session,\n\tpam_sm_chauthtok,\n};\n#endif\n\n"], "filenames": ["src/pam_radius_auth.c"], "buggy_code_start_loc": [539], "buggy_code_end_loc": [540], "fixing_code_start_loc": [539], "fixing_code_end_loc": [540], "type": "CWE-787", "message": "add_password in pam_radius_auth.c in pam_radius 1.4.0 does not correctly check the length of the input password, and is vulnerable to a stack-based buffer overflow during memcpy(). An attacker could send a crafted password to an application (loading the pam_radius library) and crash it. Arbitrary code execution might be possible, depending on the application, C library, compiler, and other factors.", "other": {"cve": {"id": "CVE-2015-9542", "sourceIdentifier": "cve@mitre.org", "published": "2020-02-24T15:15:10.830", "lastModified": "2020-08-14T14:28:33.867", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "add_password in pam_radius_auth.c in pam_radius 1.4.0 does not correctly check the length of the input password, and is vulnerable to a stack-based buffer overflow during memcpy(). An attacker could send a crafted password to an application (loading the pam_radius library) and crash it. Arbitrary code execution might be possible, depending on the application, C library, compiler, and other factors."}, {"lang": "es", "value": "La funci\u00f3n add_password en el archivo pam_radius_auth.c en pam_radius versi\u00f3n 1.4.0, no verifica correctamente la longitud de la contrase\u00f1a de entrada y es vulnerable a un desbordamiento del b\u00fafer en la regi\u00f3n stack de la memoria durante la funci\u00f3n memcpy(). Un atacante podr\u00eda enviar una contrase\u00f1a dise\u00f1ada hacia una aplicaci\u00f3n (cargando la biblioteca pam_radius) y bloquearla. Una ejecuci\u00f3n de c\u00f3digo arbitrario podr\u00eda ser posible, dependiendo de la aplicaci\u00f3n, la biblioteca C, el compilador y otros factores."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freeradius:pam_radius:1.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "0770496A-8832-453C-A43D-01E657A24C4F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2015-9542", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/FreeRADIUS/pam_radius/commit/01173ec2426627dbb1e0d96c06c3ffa0b14d36d0", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/02/msg00023.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/08/msg00000.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4290-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4290-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FreeRADIUS/pam_radius/commit/01173ec2426627dbb1e0d96c06c3ffa0b14d36d0"}}