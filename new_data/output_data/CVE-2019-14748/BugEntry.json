{"buggy_code": ["<?php\n/*********************************************************************\n    class.file.php\n\n    Peter Rotich <peter@osticket.com>\n    Copyright (c)  2006-2013 osTicket\n    http://www.osticket.com\n\n    Released under the GNU General Public License WITHOUT ANY WARRANTY.\n    See LICENSE.TXT for details.\n\n    vim: expandtab sw=4 ts=4 sts=4:\n**********************************************************************/\nrequire_once(INCLUDE_DIR.'class.signal.php');\nrequire_once(INCLUDE_DIR.'class.error.php');\n\n\n/**\n * Represents a file stored in a storage backend. It is generally attached\n * to something; however company logos, login page backdrops, and other\n * items are also stored in the database for various purposes.\n *\n * FileType-Definitions:\n *    The `ft` field is used to represent the type or purpose of the file\n *    with respect to the system. These are the defined file types (placed\n *    here as the definitions are not needed in code).\n *\n *    - 'T' => Attachments\n *    - 'L' => Logo\n *    - 'B' => Backdrop\n */\nclass AttachmentFile extends VerySimpleModel {\n\n    static $meta = array(\n        'table' => FILE_TABLE,\n        'pk' => array('id'),\n        'joins' => array(\n            'attachments' => array(\n                'reverse' => 'Attachment.file'\n            ),\n        ),\n    );\n    static $keyCache = array();\n\n    function __onload() {\n        // Cache for lookup in the ::lookupByHash method below\n        static::$keyCache[$this->key] = $this;\n    }\n\n    function getHashtable() {\n        return $this->ht;\n    }\n\n    function getInfo() {\n        return $this->getHashtable();\n    }\n\n    function getNumEntries() {\n        return $this->attachments->count();\n    }\n\n    function isCanned() {\n        return $this->getNumEntries();\n    }\n\n    function isInUse() {\n        return $this->getNumEntries();\n    }\n\n    function getId() {\n        return $this->id;\n    }\n\n    function getType() {\n        return $this->type;\n    }\n\n    function getBackend() {\n        return $this->bk;\n    }\n\n    function getMime() {\n        return $this->getType();\n    }\n\n    function getSize() {\n        return $this->size;\n    }\n\n    function getName() {\n        return $this->name;\n    }\n\n    function getKey() {\n        return $this->key;\n    }\n\n    function getSignature($cascade=false) {\n        $sig = $this->signature;\n        if (!$sig && $cascade) return $this->getKey();\n        return $sig;\n    }\n\n    function lastModified() {\n        return $this->created;\n    }\n\n    function open() {\n        return FileStorageBackend::getInstance($this);\n    }\n\n    function sendData($redirect=true, $disposition='inline') {\n        $bk = $this->open();\n        if ($redirect && $bk->sendRedirectUrl($disposition))\n            return;\n\n        @ini_set('zlib.output_compression', 'Off');\n        try {\n            $bk->passthru();\n        }\n        catch (IOException $ex) {\n            Http::response(404, 'File not found');\n        }\n    }\n\n    function getData() {\n        # XXX: This is horrible, and is subject to php's memory\n        #      restrictions, etc. Don't use this function!\n        ob_start();\n        try {\n            $this->sendData(false);\n        }\n        catch (IOException $ex) {\n            Http::response(404, 'File not found');\n        }\n        $data = &ob_get_contents();\n        ob_end_clean();\n        return $data;\n    }\n\n    function delete() {\n\n        if (!parent::delete())\n            return false;\n\n        if ($bk = $this->open())\n            $bk->unlink();\n\n        return true;\n    }\n\n    function makeCacheable($ttl=86400) {\n        Http::cacheable($this->getSignature(true), $this->lastModified(), $ttl);\n    }\n\n    function display($scale=false) {\n        $this->makeCacheable();\n\n        if ($scale && extension_loaded('gd')) {\n            $image = imagecreatefromstring($this->getData());\n            $width = imagesx($image);\n            if ($scale <= $width) {\n                $height = imagesy($image);\n                if ($width > $height) {\n                    $heightp = $height * (int)$scale / $width;\n                    $widthp = $scale;\n                } else {\n                    $widthp = $width * (int)$scale / $height;\n                    $heightp = $scale;\n                }\n                $thumb = imagecreatetruecolor($widthp, $heightp);\n                $white = imagecolorallocate($thumb, 255,255,255);\n                imagefill($thumb, 0, 0, $white);\n                imagecopyresized($thumb, $image, 0, 0, 0, 0, $widthp,\n                    $heightp, $width, $height);\n                header('Content-Type: image/png');\n                imagepng($thumb);\n                return;\n            }\n        }\n        header('Content-Type: '.($this->getType()?$this->getType():'application/octet-stream'));\n        header('Content-Length: '.$this->getSize());\n        $this->sendData();\n        exit();\n    }\n\n    function getDownloadUrl($minage=false, $disposition=false, $handler=false) {\n        // XXX: Drop this when AttachmentFile goes to ORM\n        return static::generateDownloadUrl($this->getId(),\n            strtolower($this->getKey()), $this->getSignature(), $minage,\n            $disposition, $handler);\n    }\n\n    static function generateDownloadUrl($id, $key, $hash, $minage=false,\n        $disposition=false, $handler=false\n    ) {\n        // Expire at the nearest midnight, allowing at least 12 hours access\n        $minage = $minage ?: 43200;\n        $gmnow = Misc::gmtime() + $minage;\n        $expires = $gmnow + 86400 - ($gmnow % 86400);\n\n        // Generate a signature based on secret content\n        $signature = static::_genUrlSignature($id, $key, $hash, $expires);\n\n        $handler = $handler ?: ROOT_PATH . 'file.php';\n\n        // Return sanitized query string\n        $args = array(\n            'key' => $key,\n            'expires' => $expires,\n            'signature' => $signature,\n        );\n\n        if ($disposition)\n            $args['disposition'] = $disposition;\n\n        return $handler . '?' . http_build_query($args);\n    }\n\n    function verifySignature($signature, $expires) {\n        $gmnow = Misc::gmtime();\n        if ($expires < $gmnow)\n            return false;\n\n        $check = static::_genUrlSignature($this->getId(), $this->getKey(),\n            $this->getSignature(), $expires);\n        return $signature == $check;\n    }\n\n    static function _genUrlSignature($id, $key, $signature, $expires) {\n        $pieces = array(\n            'Host='.$_SERVER['HTTP_HOST'],\n            'Path='.ROOT_PATH,\n            'Id='.$id,\n            'Key='.strtolower($key),\n            'Hash='.$signature,\n            'Expires='.$expires,\n        );\n        return hash_hmac('sha1', implode(\"\\n\", $pieces), SECRET_SALT);\n    }\n\n    function download($disposition=false, $expires=false) {\n        $disposition = $disposition ?: 'inline';\n        $bk = $this->open();\n        if ($bk->sendRedirectUrl($disposition))\n            return;\n        $ttl = ($expires) ? $expires - Misc::gmtime() : false;\n        $this->makeCacheable($ttl);\n        $type = $this->getType() ?: 'application/octet-stream';\n        Http::download($this->getName(), $type, null, 'inline');\n        header('Content-Length: '.$this->getSize());\n        $this->sendData(false);\n        exit();\n    }\n\n    function _getKeyAndHash($data=false, $file=false) {\n        if ($file) {\n            $sha1 = base64_encode(sha1_file($data, true));\n            $md5 = base64_encode(md5_file($data, true));\n        }\n        else {\n            $sha1 = base64_encode(sha1($data, true));\n            $md5 = base64_encode(md5($data, true));\n        }\n\n        // Use 5 chars from the microtime() prefix and 27 chars from the\n        // sha1 hash. This should make a sufficiently strong unique key for\n        // file content. In the event there is a sha1 collision for data, it\n        // should be unlikely that there will be a collision for the\n        // microtime hash coincidently.  Remove =, change + and / to chars\n        // better suited for URLs and filesystem paths\n        $prefix = base64_encode(sha1(microtime(), true));\n        $key = str_replace(\n            array('=','+','/'),\n            array('','-','_'),\n            substr($prefix, 0, 5) . $sha1);\n\n        // The hash is a 32-char value where the first half is from the last\n        // 16 chars from the SHA1 hash and the last 16 chars are the last 16\n        // chars from the MD5 hash. This should provide for better\n        // resiliance against hash collisions and attacks against any one\n        // hash algorithm. Since we're using base64 encoding, with 6-bits\n        // per char, we should have a total hash strength of 192 bits.\n        $hash = str_replace(\n            array('=','+','/'),\n            array('','-','_'),\n            substr($sha1, 0, 16) . substr($md5, 0, 16));\n\n        return array($key, $hash);\n    }\n\n    /* Function assumes the files types have been validated */\n    static function upload($file, $ft='T', $deduplicate=true) {\n\n        if(!$file['name'] || $file['error'] || !is_uploaded_file($file['tmp_name']))\n            return false;\n\n        list($key, $sig) = self::_getKeyAndHash($file['tmp_name'], true);\n\n        $info=array('type'=>$file['type'],\n                    'filetype'=>$ft,\n                    'size'=>$file['size'],\n                    'name'=>$file['name'],\n                    'key'=>$key,\n                    'signature'=>$sig,\n                    'tmp_name'=>$file['tmp_name'],\n                    );\n\n        return static::create($info, $ft, $deduplicate);\n    }\n\n    static function uploadBackdrop(array $file, &$error) {\n        if (extension_loaded('gd')) {\n            $source_path = $file['tmp_name'];\n            list($source_width, $source_height, $source_type) = getimagesize($source_path);\n\n            switch ($source_type) {\n                case IMAGETYPE_GIF:\n                case IMAGETYPE_JPEG:\n                case IMAGETYPE_PNG:\n                    break;\n                default:\n                    $error = __('Invalid image file type');\n                    return false;\n            }\n        }\n        return self::upload($file, 'B', false);\n    }\n\n    static function uploadLogo($file, &$error, $aspect_ratio=2) {\n        /* Borrowed in part from\n         * http://salman-w.blogspot.com/2009/04/crop-to-fit-image-using-aspphp.html\n         */\n        if (extension_loaded('gd')) {\n            $source_path = $file['tmp_name'];\n            list($source_width, $source_height, $source_type) = getimagesize($source_path);\n\n            switch ($source_type) {\n                case IMAGETYPE_GIF:\n                case IMAGETYPE_JPEG:\n                case IMAGETYPE_PNG:\n                    break;\n                default:\n                    $error = __('Invalid image file type');\n                    return false;\n            }\n\n            $source_aspect_ratio = $source_width / $source_height;\n\n            if ($source_aspect_ratio < $aspect_ratio) {\n                $error = __('Image is too square. Upload a wider image');\n                return false;\n            }\n        }\n        return self::upload($file, 'L', false);\n    }\n\n    static function create(&$file, $ft='T', $deduplicate=true) {\n        if (isset($file['encoding'])) {\n            switch ($file['encoding']) {\n            case 'base64':\n                $file['data'] = base64_decode($file['data']);\n            }\n        }\n        if (isset($file['data'])) {\n            // Allow a callback function to delay or avoid reading or\n            // fetching ihe file contents\n            if (is_callable($file['data']))\n                $file['data'] = $file['data']();\n\n            list($key, $file['signature'])\n                = self::_getKeyAndHash($file['data']);\n            if (!$file['key'])\n                $file['key'] = $key;\n        }\n\n        if (isset($file['size']) && $file['size'] > 0) {\n            // Check and see if the file is already on record\n            $existing = static::objects()->filter(array(\n                'signature' => $file['signature'],\n                'size' => $file['size']\n            ))->first();\n\n            // If the record exists in the database already, a file with\n            // the same hash and size is already on file -- just return\n            // the file\n            if ($deduplicate && $existing) {\n                $file['key'] = $existing->key;\n                return $existing;\n            }\n        }\n        elseif (!isset($file['data'])) {\n            // Unable to determine the file's size\n            return false;\n        }\n\n        if (!$file['type'] && extension_loaded('fileinfo')) {\n            $finfo = new finfo(FILEINFO_MIME_TYPE);\n            if ($file['data'])\n                $type = $finfo->buffer($file['data']);\n            elseif ($file['tmp_name'])\n                $type = $finfo->file($file['tmp_name']);\n\n            if ($type)\n                $file['type'] = $type;\n        }\n        if (!$file['type'])\n            $file['type'] = 'application/octet-stream';\n\n\n        $f = new static(array(\n            'type' => strtolower($file['type']),\n            'name' => $file['name'],\n            'key' => $file['key'],\n            'ft' => $ft ?: 'T',\n            'signature' => $file['signature'],\n            'created' => SqlFunction::NOW(),\n        ));\n\n        if (isset($file['size']))\n            $f->size = $file['size'];\n\n        if (!$f->save())\n            return false;\n\n        // Note that this is preferred over $f->open() because the file does\n        // not have a valid backend configured yet. ::getBackendForFile()\n        // will consider the system configuration for storing the file\n        $bks = array(self::getBackendForFile($f));\n        if (!$bks[0]->getBkChar() !== 'D')\n            $bks[] = new AttachmentChunkedData($f);\n\n        // Consider the selected backen first and then save to database\n        // otherwise.\n        $succeeded = false;\n        foreach ($bks as $bk) {\n            try {\n                if (isset($file['tmp_name'])) {\n                    if ($bk->upload($file['tmp_name'])) {\n                        $succeeded = true; break;\n                    }\n                }\n                elseif ($bk->write($file['data']) && $bk->flush()) {\n                    $succeeded = true; break;\n                }\n            }\n            catch (Exception $e) {\n                // Try next backend\n            }\n            // Fallthrough to default backend if different?\n        }\n        if (!$succeeded) {\n            // Unable to save data (weird)\n            return false;\n        }\n\n        $f->bk = $bk->getBkChar();\n\n        if (!isset($file['size'])) {\n            if ($size = $bk->getSize())\n                $f->size = $size;\n            // Prefer mb_strlen, because mbstring.func_overload will\n            // automatically prefer it if configured.\n            elseif (extension_loaded('mbstring'))\n                $f->size = mb_strlen($file['data'], '8bit');\n            // bootstrap.php include a compat version of mb_strlen\n            else\n                $f->size = strlen($file['data']);\n        }\n\n        $f->save();\n        return $f;\n    }\n\n    static function __create($file, &$errors) {\n        return static::create($file);\n    }\n\n    /**\n     * Migrate this file from the current backend to the backend specified.\n     *\n     * Parameters:\n     * $bk - (string) type char of the target storage backend. Use\n     *      AttachmentStorageBackend::allRegistered() to get a list of type\n     *      chars and associated class names\n     *\n     * Returns:\n     * True if the migration was successful and false otherwise.\n     */\n    function migrate($bk) {\n\n        // Copy the file to the new backend and hash the contents\n        $target = FileStorageBackend::lookup($bk, $this);\n        $source = $this->open();\n\n        // Initialize hashing algorithm to verify uploaded contents\n        $algos = $target->getNativeHashAlgos();\n        $common_algo = 'sha1';\n        if ($algos && is_array($algos)) {\n            $supported = hash_algos();\n            foreach ($algos as $a) {\n                if (in_array(strtolower($a), $supported)) {\n                    $common_algo = strtolower($a);\n                    break;\n                }\n            }\n        }\n        $before = hash_init($common_algo);\n        // TODO: Make this resumable so that if the file cannot be migrated\n        //      in the max_execution_time, the migration can be continued\n        //      the next time the cron runs\n        try {\n            while ($block = $source->read($target->getBlockSize())) {\n                hash_update($before, $block);\n                $target->write($block);\n            }\n            $target->flush();\n        }\n        catch (Exception $e) {\n            // Migration failed\n            return false;\n        }\n\n        // Ask the backend to generate its own hash if at all possible\n        if (!($target_hash = $target->getHashDigest($common_algo))) {\n            $after = hash_init($common_algo);\n            // Verify that the hash of the target file matches the hash of\n            // the source file\n            $target = FileStorageBackend::lookup($bk, $this);\n            while ($block = $target->read())\n                hash_update($after, $block);\n            $target_hash = hash_final($after);\n        }\n\n        if (hash_final($before) != $target_hash) {\n            $target->unlink();\n            return false;\n        }\n\n        $this->bk = $target->getBkChar();\n        if (!$this->save())\n            return false;\n\n        return $source->unlink();\n    }\n\n    /**\n     * Considers the system's configuration for file storage selection based\n     * on the file information and purpose (FAQ attachment, image, etc).\n     *\n     * Parameters:\n     * $file - (hasharray) file information which would be passed to\n     * ::save() for instance.\n     *\n     * Returns:\n     * Instance<FileStorageBackend> backend selected based on the file\n     * received.\n     */\n    static function getBackendForFile($file) {\n        global $cfg;\n\n        $char = null;\n        if ($cfg) {\n            $char = $cfg->getDefaultStorageBackendChar();\n        }\n        try {\n            return FileStorageBackend::lookup($char ?: 'D', $file);\n        }\n        catch (Exception $x) {\n            return new AttachmentChunkedData($file);\n        }\n    }\n\n    static function lookupByHash($hash) {\n        if (isset(static::$keyCache[$hash]))\n            return static::$keyCache[$hash];\n\n        // Cache a negative lookup if no such file exists\n        return parent::lookup(array('key' => $hash));\n    }\n\n    static function lookup($id) {\n        return is_string($id)\n            ? static::lookupByHash($id)\n            : parent::lookup($id);\n    }\n\n    /*\n      Method formats http based $_FILE uploads - plus basic validation.\n     */\n    function format($files) {\n        global $ost;\n\n        if(!$files || !is_array($files))\n            return null;\n\n        //Reformat $_FILE  for the sane.\n        $attachments = array();\n        foreach($files as $k => $a) {\n            if(is_array($a))\n                foreach($a as $i => $v)\n                    $attachments[$i][$k] = $v;\n        }\n\n        //Basic validation.\n        foreach($attachments as $i => &$file) {\n            //skip no file upload \"error\" - why PHP calls it an error is beyond me.\n            if($file['error'] && $file['error']==UPLOAD_ERR_NO_FILE) {\n                unset($attachments[$i]);\n                continue;\n            }\n\n            if($file['error']) //PHP defined error!\n                $file['error'] = 'File upload error #'.$file['error'];\n            elseif(!$file['tmp_name'] || !is_uploaded_file($file['tmp_name']))\n                $file['error'] = 'Invalid or bad upload POST';\n        }\n        unset($file);\n\n        return array_filter($attachments);\n    }\n\n    /**\n     * Removes files and associated meta-data for files which no ticket,\n     * canned-response, or faq point to any more.\n     */\n    static function deleteOrphans() {\n        $sql = \"SELECT `id` FROM \".FILE_TABLE.\n            \" A1 WHERE (A1.ft = 'T' AND A1.created < NOW() - INTERVAL 1 DAY)\".\n            \" AND NOT EXISTS (SELECT id FROM \".ATTACHMENT_TABLE.\n            \" A2 WHERE A1.`id` = A2.`file_id`)\";\n\n        if (($res=db_query($sql)) && db_num_rows($res)) {\n            while (list($id) = db_fetch_row($res)) {\n                if ($f = static::lookup((int) $id))\n                    if (!$f->delete())\n                        break;\n            }\n        }\n\n        return true;\n    }\n\n    static function allLogos() {\n        return static::objects()\n            ->filter(array('ft' => 'L'))\n            ->order_by('created');\n    }\n\n    static function allBackdrops() {\n        return static::objects()\n            ->filter(array('ft' => 'B'))\n            ->order_by('created');\n    }\n}\n\nclass FileStorageBackend {\n    var $meta;\n    static $desc = false;\n    static $registry;\n    static $blocksize = 131072;\n    static $private = false;\n\n    /**\n     * All storage backends should call this function during the request\n     * bootstrap phase.\n     */\n    static function register($typechar, $class) {\n        self::$registry[$typechar] = $class;\n    }\n\n    static function allRegistered($private=false) {\n        $R = self::$registry;\n        if (!$private) {\n            foreach ($R as $i=>$bk) {\n                if ($bk::$private)\n                    unset($R[$i]);\n            }\n        }\n        return $R;\n    }\n\n    /**\n     * Retrieves the type char registered for this storage backend's class.\n     * Null is returned if the backend is not properly registered.\n     */\n    function getBkChar() {\n        foreach (self::$registry as $tc=>$class)\n            if ($this instanceof $class)\n                return $tc;\n    }\n\n    static function isRegistered($type) {\n        return isset(self::$registry[$type]);\n    }\n\n    static function lookup($type, $file=null) {\n        if (!isset(self::$registry[$type]))\n            throw new Exception(\"No such backend registered\");\n\n        $class = self::$registry[$type];\n        return new $class($file);\n    }\n\n    static function getInstance($file) {\n        if (!isset(self::$registry[$file->getBackend()]))\n            throw new Exception(\"No such backend registered\");\n\n        $class = self::$registry[$file->getBackend()];\n        return new $class($file);\n    }\n\n    /**\n     * Returns the optimal block size for the backend. When migrating, this\n     * size blocks would be best for sending to the ::write() method\n     */\n    function getBlockSize() {\n        return static::$blocksize;\n    }\n\n    /**\n     * Create an instance of the storage backend linking the related file.\n     * Information about the file metadata is accessible via the received\n     * filed object.\n     */\n    function __construct($meta) {\n        $this->meta = $meta;\n    }\n\n    /**\n     * Commit file to the storage backend. This method is used if the\n     * backend cannot support writing a file directly. Otherwise, the\n     * ::upload($file) method is preferred.\n     *\n     * Parameters:\n     * $data - (string|binary) file contents to be written to the backend\n     */\n    function write($data) {\n        return false;\n    }\n\n    /**\n     * Called after all the blocks are sent to the ::write() method. This\n     * method should return boolean FALSE if flushing the data was\n     * somehow inhibited.\n     */\n    function flush() {\n        return true;\n    }\n\n    /**\n     * Upload a file to the backend. This method is preferred over ::write()\n     * for files which are uploaded or are otherwise available out of\n     * memory. The backend is encouraged to avoid reading the entire\n     * contents into memory.\n     */\n    function upload($filepath) {\n        return $this->write(file_get_contents($filepath));\n    }\n\n    /**\n     * Returns data from the backend, optionally returning only the number\n     * of bytes indicated at the specified offset. If the data is available\n     * in chunks, one chunk may be returned at a time. The backend should\n     * return boolean false when no more chunks are available.\n     */\n    function read($amount=0, $offset=0) {\n        return false;\n    }\n\n    /**\n     * Convenience method to send all the file to standard output\n     */\n    function passthru() {\n        while ($block = $this->read())\n            echo $block;\n    }\n\n    /**\n     * If the data is not stored or not available locally, a redirect\n     * response can be sent to the user agent indicating the actual HTTP\n     * location of the data.\n     *\n     * If the data is available locally, this method should return boolean\n     * false to indicate that the read() method should be used to retrieve\n     * the data and broker it to the user agent.\n     */\n    function sendRedirectUrl($disposition='inline') {\n        return false;\n    }\n\n    /**\n     * Requests the backend to remove the file contents.\n     */\n    function unlink() {\n        return false;\n    }\n\n    /**\n     * Fetches a list of hash algorithms that are supported transparently\n     * through the ::write() and ::upload() methods. After writing or\n     * uploading file content, the ::getHashDigest($algo) method can be\n     * called to get a hash of the remote content without fetching the\n     * entire data stream to verify the content locally.\n     */\n    function getNativeHashAlgos() {\n        return array();\n    }\n\n    /**\n     * Returns a hash of the content calculated remotely by the storage\n     * backend. If this method fails, the hash chould be calculated by\n     * downloading the content and hashing locally\n     */\n    function getHashDigest($algo) {\n        return false;\n    }\n\n    /**\n     * getSize\n     *\n     * Retrieves the size of the contents written or available to be read.\n     * The backend should optimize this process if possible by keeping track\n     * of the bytes written in a way apart from `strlen`. This value will be\n     * used instead of inspecting the contents using `strlen`.\n     */\n    function getSize() {\n        return false;\n    }\n}\n\n\n/**\n * Attachments stored in the database are cut into 500kB chunks and stored\n * in the FILE_CHUNK_TABLE to overcome the max_allowed_packet limitation of\n * LOB fields in the MySQL database\n */\ndefine('CHUNK_SIZE', 500*1024); # Beware if you change this...\nclass AttachmentFileChunk extends VerySimpleModel {\n    static $meta = array(\n        'table' => FILE_CHUNK_TABLE,\n        'pk' => array('file_id', 'chunk_id'),\n        'joins' => array(\n            'file' => array(\n                'constraint' => array('file_id' => 'AttachmentFile.id'),\n            ),\n        ),\n    );\n}\n\nclass AttachmentChunkedData extends FileStorageBackend {\n    static $desc = /* @trans */ \"In the database\";\n    static $blocksize = CHUNK_SIZE;\n\n    function __construct($file) {\n        $this->file = $file;\n        $this->_chunk = 0;\n        $this->_buffer = false;\n        $this->eof = false;\n    }\n\n    function getSize() {\n        $row = AttachmentFileChunk::objects()\n            ->filter(array('file' => $this->file))\n            ->aggregate(array('length' => SqlAggregate::SUM(SqlFunction::LENGTH(new SqlField('filedata')))))\n            ->one();\n        return $row['length'];\n    }\n\n    function read($amount=CHUNK_SIZE, $offset=0) {\n        # Read requested length of data from attachment chunks\n        if ($this->eof)\n            return false;\n\n        while (strlen($this->_buffer) < $amount + $offset) {\n            try {\n                list($buf) = AttachmentFileChunk::objects()\n                    ->filter(array('file' => $this->file, 'chunk_id' => $this->_chunk++))\n                    ->values_flat('filedata')\n                    ->one();\n            }\n            catch (DoesNotExist $e) {\n                $this->eof = true;\n                break;\n            }\n            $this->_buffer .= $buf;\n        }\n        $chunk = substr($this->_buffer, $offset, $amount);\n        $this->_buffer = substr($this->_buffer, $offset + $amount);\n        return $chunk;\n    }\n\n    function write($what, $chunk_size=CHUNK_SIZE) {\n        $offset=0;\n        while ($block = substr($what, $offset, $chunk_size)) {\n            // Chunks are considered immutable. Importing chunks should\n            // forceable remove the contents of a file before write()ing new\n            // chunks. Therefore, inserts should be safe.\n            $chunk = new AttachmentFileChunk(array(\n                'file' => $this->file,\n                'chunk_id' => $this->_chunk++,\n                'filedata' => $block\n            ));\n            if (!$chunk->save())\n                return false;\n            $offset += strlen($block);\n        }\n\n        return $this->_chunk;\n    }\n\n    function unlink() {\n        return AttachmentFileChunk::objects()\n            ->filter(array('file' => $this->file))\n            ->delete();\n    }\n}\nFileStorageBackend::register('D', 'AttachmentChunkedData');\n\n/**\n * This class provides an interface for files attached on the filesystem in\n * versions previous to v1.7. The upgrader will keep the attachments on the\n * disk where they were and write the path into the `attrs` field of the\n * %file table. This module will continue to serve those files until they\n * are migrated with the `file` cli app\n */\nclass OneSixAttachments extends FileStorageBackend {\n    static $desc = \"upload_dir folder (from osTicket v1.6)\";\n    static $private = true;\n\n    function read($bytes=32768, $offset=false) {\n        $filename = $this->meta->attrs;\n        if (!$this->fp)\n            $this->fp = @fopen($filename, 'rb');\n        if (!$this->fp)\n            throw new IOException($filename.': Unable to open for reading');\n        if ($offset)\n            fseek($this->fp, $offset);\n        if (($status = @fread($this->fp, $bytes)) === false)\n            throw new IOException($filename.': Unable to read from file');\n        return $status;\n    }\n\n    function passthru() {\n        $filename = $this->meta->attrs;\n        if (($status = @readfile($filename)) === false)\n            throw new IOException($filename.': Unable to read from file');\n        return $status;\n    }\n\n    function write($data) {\n        throw new IOException('This backend does not support new files');\n    }\n\n    function upload($filepath) {\n        throw new IOException('This backend does not support new files');\n    }\n\n    function unlink() {\n        $filename = $this->meta->attrs;\n        if (!@unlink($filename))\n            throw new IOException($filename.': Unable to delete file');\n        // Drop usage of the `attrs` field\n        $this->meta->attrs = null;\n        $this->meta->save();\n        return true;\n    }\n}\nFileStorageBackend::register('6', 'OneSixAttachments');\n?>\n"], "fixing_code": ["<?php\n/*********************************************************************\n    class.file.php\n\n    Peter Rotich <peter@osticket.com>\n    Copyright (c)  2006-2013 osTicket\n    http://www.osticket.com\n\n    Released under the GNU General Public License WITHOUT ANY WARRANTY.\n    See LICENSE.TXT for details.\n\n    vim: expandtab sw=4 ts=4 sts=4:\n**********************************************************************/\nrequire_once(INCLUDE_DIR.'class.signal.php');\nrequire_once(INCLUDE_DIR.'class.error.php');\n\n\n/**\n * Represents a file stored in a storage backend. It is generally attached\n * to something; however company logos, login page backdrops, and other\n * items are also stored in the database for various purposes.\n *\n * FileType-Definitions:\n *    The `ft` field is used to represent the type or purpose of the file\n *    with respect to the system. These are the defined file types (placed\n *    here as the definitions are not needed in code).\n *\n *    - 'T' => Attachments\n *    - 'L' => Logo\n *    - 'B' => Backdrop\n */\nclass AttachmentFile extends VerySimpleModel {\n\n    static $meta = array(\n        'table' => FILE_TABLE,\n        'pk' => array('id'),\n        'joins' => array(\n            'attachments' => array(\n                'reverse' => 'Attachment.file'\n            ),\n        ),\n    );\n    static $keyCache = array();\n\n    function __onload() {\n        // Cache for lookup in the ::lookupByHash method below\n        static::$keyCache[$this->key] = $this;\n    }\n\n    function getHashtable() {\n        return $this->ht;\n    }\n\n    function getInfo() {\n        return $this->getHashtable();\n    }\n\n    function getNumEntries() {\n        return $this->attachments->count();\n    }\n\n    function isCanned() {\n        return $this->getNumEntries();\n    }\n\n    function isInUse() {\n        return $this->getNumEntries();\n    }\n\n    function getId() {\n        return $this->id;\n    }\n\n    function getType() {\n        return $this->type;\n    }\n\n    function getBackend() {\n        return $this->bk;\n    }\n\n    function getMime() {\n        return $this->getType();\n    }\n\n    function getSize() {\n        return $this->size;\n    }\n\n    function getName() {\n        return $this->name;\n    }\n\n    function getKey() {\n        return $this->key;\n    }\n\n    function getSignature($cascade=false) {\n        $sig = $this->signature;\n        if (!$sig && $cascade) return $this->getKey();\n        return $sig;\n    }\n\n    function lastModified() {\n        return $this->created;\n    }\n\n    function open() {\n        return FileStorageBackend::getInstance($this);\n    }\n\n    function sendData($redirect=true, $disposition='inline') {\n        $bk = $this->open();\n        if ($redirect && $bk->sendRedirectUrl($disposition))\n            return;\n\n        @ini_set('zlib.output_compression', 'Off');\n        try {\n            $bk->passthru();\n        }\n        catch (IOException $ex) {\n            Http::response(404, 'File not found');\n        }\n    }\n\n    function getData() {\n        # XXX: This is horrible, and is subject to php's memory\n        #      restrictions, etc. Don't use this function!\n        ob_start();\n        try {\n            $this->sendData(false);\n        }\n        catch (IOException $ex) {\n            Http::response(404, 'File not found');\n        }\n        $data = &ob_get_contents();\n        ob_end_clean();\n        return $data;\n    }\n\n    function delete() {\n\n        if (!parent::delete())\n            return false;\n\n        if ($bk = $this->open())\n            $bk->unlink();\n\n        return true;\n    }\n\n    function makeCacheable($ttl=86400) {\n        Http::cacheable($this->getSignature(true), $this->lastModified(), $ttl);\n    }\n\n    function display($scale=false) {\n        $this->makeCacheable();\n\n        if ($scale && extension_loaded('gd')) {\n            $image = imagecreatefromstring($this->getData());\n            $width = imagesx($image);\n            if ($scale <= $width) {\n                $height = imagesy($image);\n                if ($width > $height) {\n                    $heightp = $height * (int)$scale / $width;\n                    $widthp = $scale;\n                } else {\n                    $widthp = $width * (int)$scale / $height;\n                    $heightp = $scale;\n                }\n                $thumb = imagecreatetruecolor($widthp, $heightp);\n                $white = imagecolorallocate($thumb, 255,255,255);\n                imagefill($thumb, 0, 0, $white);\n                imagecopyresized($thumb, $image, 0, 0, 0, 0, $widthp,\n                    $heightp, $width, $height);\n                header('Content-Type: image/png');\n                imagepng($thumb);\n                return;\n            }\n        }\n        header('Content-Type: '.($this->getType()?$this->getType():'application/octet-stream'));\n        header('Content-Length: '.$this->getSize());\n        $this->sendData();\n        exit();\n    }\n\n    function getDownloadUrl($minage=false, $disposition=false, $handler=false) {\n        // XXX: Drop this when AttachmentFile goes to ORM\n        return static::generateDownloadUrl($this->getId(),\n            strtolower($this->getKey()), $this->getSignature(), $minage,\n            $disposition, $handler);\n    }\n\n    static function generateDownloadUrl($id, $key, $hash, $minage=false,\n        $disposition=false, $handler=false\n    ) {\n        // Expire at the nearest midnight, allowing at least 12 hours access\n        $minage = $minage ?: 43200;\n        $gmnow = Misc::gmtime() + $minage;\n        $expires = $gmnow + 86400 - ($gmnow % 86400);\n\n        // Generate a signature based on secret content\n        $signature = static::_genUrlSignature($id, $key, $hash, $expires);\n\n        $handler = $handler ?: ROOT_PATH . 'file.php';\n\n        // Return sanitized query string\n        $args = array(\n            'key' => $key,\n            'expires' => $expires,\n            'signature' => $signature,\n        );\n\n        if ($disposition)\n            $args['disposition'] = $disposition;\n\n        return $handler . '?' . http_build_query($args);\n    }\n\n    function verifySignature($signature, $expires) {\n        $gmnow = Misc::gmtime();\n        if ($expires < $gmnow)\n            return false;\n\n        $check = static::_genUrlSignature($this->getId(), $this->getKey(),\n            $this->getSignature(), $expires);\n        return $signature == $check;\n    }\n\n    static function _genUrlSignature($id, $key, $signature, $expires) {\n        $pieces = array(\n            'Host='.$_SERVER['HTTP_HOST'],\n            'Path='.ROOT_PATH,\n            'Id='.$id,\n            'Key='.strtolower($key),\n            'Hash='.$signature,\n            'Expires='.$expires,\n        );\n        return hash_hmac('sha1', implode(\"\\n\", $pieces), SECRET_SALT);\n    }\n\n    function download($disposition=false, $expires=false) {\n        $disposition = ($disposition && strcasecmp($disposition, 'inline') == 0\n              && strpos($this->getType(), 'image/') !== false)\n            ? 'inline' : 'attachment';\n        $bk = $this->open();\n        if ($bk->sendRedirectUrl($disposition))\n            return;\n        $ttl = ($expires) ? $expires - Misc::gmtime() : false;\n        $this->makeCacheable($ttl);\n        $type = $this->getType() ?: 'application/octet-stream';\n        Http::download($this->getName(), $type, null, $disposition);\n        header('Content-Length: '.$this->getSize());\n        $this->sendData(false);\n        exit();\n    }\n\n    function _getKeyAndHash($data=false, $file=false) {\n        if ($file) {\n            $sha1 = base64_encode(sha1_file($data, true));\n            $md5 = base64_encode(md5_file($data, true));\n        }\n        else {\n            $sha1 = base64_encode(sha1($data, true));\n            $md5 = base64_encode(md5($data, true));\n        }\n\n        // Use 5 chars from the microtime() prefix and 27 chars from the\n        // sha1 hash. This should make a sufficiently strong unique key for\n        // file content. In the event there is a sha1 collision for data, it\n        // should be unlikely that there will be a collision for the\n        // microtime hash coincidently.  Remove =, change + and / to chars\n        // better suited for URLs and filesystem paths\n        $prefix = base64_encode(sha1(microtime(), true));\n        $key = str_replace(\n            array('=','+','/'),\n            array('','-','_'),\n            substr($prefix, 0, 5) . $sha1);\n\n        // The hash is a 32-char value where the first half is from the last\n        // 16 chars from the SHA1 hash and the last 16 chars are the last 16\n        // chars from the MD5 hash. This should provide for better\n        // resiliance against hash collisions and attacks against any one\n        // hash algorithm. Since we're using base64 encoding, with 6-bits\n        // per char, we should have a total hash strength of 192 bits.\n        $hash = str_replace(\n            array('=','+','/'),\n            array('','-','_'),\n            substr($sha1, 0, 16) . substr($md5, 0, 16));\n\n        return array($key, $hash);\n    }\n\n    /* Function assumes the files types have been validated */\n    static function upload($file, $ft='T', $deduplicate=true) {\n\n        if(!$file['name'] || $file['error'] || !is_uploaded_file($file['tmp_name']))\n            return false;\n\n        list($key, $sig) = self::_getKeyAndHash($file['tmp_name'], true);\n\n        $info=array('type'=>$file['type'],\n                    'filetype'=>$ft,\n                    'size'=>$file['size'],\n                    'name'=>$file['name'],\n                    'key'=>$key,\n                    'signature'=>$sig,\n                    'tmp_name'=>$file['tmp_name'],\n                    );\n\n        return static::create($info, $ft, $deduplicate);\n    }\n\n    static function uploadBackdrop(array $file, &$error) {\n        if (extension_loaded('gd')) {\n            $source_path = $file['tmp_name'];\n            list($source_width, $source_height, $source_type) = getimagesize($source_path);\n\n            switch ($source_type) {\n                case IMAGETYPE_GIF:\n                case IMAGETYPE_JPEG:\n                case IMAGETYPE_PNG:\n                    break;\n                default:\n                    $error = __('Invalid image file type');\n                    return false;\n            }\n        }\n        return self::upload($file, 'B', false);\n    }\n\n    static function uploadLogo($file, &$error, $aspect_ratio=2) {\n        /* Borrowed in part from\n         * http://salman-w.blogspot.com/2009/04/crop-to-fit-image-using-aspphp.html\n         */\n        if (extension_loaded('gd')) {\n            $source_path = $file['tmp_name'];\n            list($source_width, $source_height, $source_type) = getimagesize($source_path);\n\n            switch ($source_type) {\n                case IMAGETYPE_GIF:\n                case IMAGETYPE_JPEG:\n                case IMAGETYPE_PNG:\n                    break;\n                default:\n                    $error = __('Invalid image file type');\n                    return false;\n            }\n\n            $source_aspect_ratio = $source_width / $source_height;\n\n            if ($source_aspect_ratio < $aspect_ratio) {\n                $error = __('Image is too square. Upload a wider image');\n                return false;\n            }\n        }\n        return self::upload($file, 'L', false);\n    }\n\n    static function create(&$file, $ft='T', $deduplicate=true) {\n        if (isset($file['encoding'])) {\n            switch ($file['encoding']) {\n            case 'base64':\n                $file['data'] = base64_decode($file['data']);\n            }\n        }\n        if (isset($file['data'])) {\n            // Allow a callback function to delay or avoid reading or\n            // fetching ihe file contents\n            if (is_callable($file['data']))\n                $file['data'] = $file['data']();\n\n            list($key, $file['signature'])\n                = self::_getKeyAndHash($file['data']);\n            if (!$file['key'])\n                $file['key'] = $key;\n        }\n\n        if (isset($file['size']) && $file['size'] > 0) {\n            // Check and see if the file is already on record\n            $existing = static::objects()->filter(array(\n                'signature' => $file['signature'],\n                'size' => $file['size']\n            ))->first();\n\n            // If the record exists in the database already, a file with\n            // the same hash and size is already on file -- just return\n            // the file\n            if ($deduplicate && $existing) {\n                $file['key'] = $existing->key;\n                return $existing;\n            }\n        }\n        elseif (!isset($file['data'])) {\n            // Unable to determine the file's size\n            return false;\n        }\n\n        if (!$file['type'] && extension_loaded('fileinfo')) {\n            $finfo = new finfo(FILEINFO_MIME_TYPE);\n            if ($file['data'])\n                $type = $finfo->buffer($file['data']);\n            elseif ($file['tmp_name'])\n                $type = $finfo->file($file['tmp_name']);\n\n            if ($type)\n                $file['type'] = $type;\n        }\n        if (!$file['type'])\n            $file['type'] = 'application/octet-stream';\n\n\n        $f = new static(array(\n            'type' => strtolower($file['type']),\n            'name' => $file['name'],\n            'key' => $file['key'],\n            'ft' => $ft ?: 'T',\n            'signature' => $file['signature'],\n            'created' => SqlFunction::NOW(),\n        ));\n\n        if (isset($file['size']))\n            $f->size = $file['size'];\n\n        if (!$f->save())\n            return false;\n\n        // Note that this is preferred over $f->open() because the file does\n        // not have a valid backend configured yet. ::getBackendForFile()\n        // will consider the system configuration for storing the file\n        $bks = array(self::getBackendForFile($f));\n        if (!$bks[0]->getBkChar() !== 'D')\n            $bks[] = new AttachmentChunkedData($f);\n\n        // Consider the selected backen first and then save to database\n        // otherwise.\n        $succeeded = false;\n        foreach ($bks as $bk) {\n            try {\n                if (isset($file['tmp_name'])) {\n                    if ($bk->upload($file['tmp_name'])) {\n                        $succeeded = true; break;\n                    }\n                }\n                elseif ($bk->write($file['data']) && $bk->flush()) {\n                    $succeeded = true; break;\n                }\n            }\n            catch (Exception $e) {\n                // Try next backend\n            }\n            // Fallthrough to default backend if different?\n        }\n        if (!$succeeded) {\n            // Unable to save data (weird)\n            return false;\n        }\n\n        $f->bk = $bk->getBkChar();\n\n        if (!isset($file['size'])) {\n            if ($size = $bk->getSize())\n                $f->size = $size;\n            // Prefer mb_strlen, because mbstring.func_overload will\n            // automatically prefer it if configured.\n            elseif (extension_loaded('mbstring'))\n                $f->size = mb_strlen($file['data'], '8bit');\n            // bootstrap.php include a compat version of mb_strlen\n            else\n                $f->size = strlen($file['data']);\n        }\n\n        $f->save();\n        return $f;\n    }\n\n    static function __create($file, &$errors) {\n        return static::create($file);\n    }\n\n    /**\n     * Migrate this file from the current backend to the backend specified.\n     *\n     * Parameters:\n     * $bk - (string) type char of the target storage backend. Use\n     *      AttachmentStorageBackend::allRegistered() to get a list of type\n     *      chars and associated class names\n     *\n     * Returns:\n     * True if the migration was successful and false otherwise.\n     */\n    function migrate($bk) {\n\n        // Copy the file to the new backend and hash the contents\n        $target = FileStorageBackend::lookup($bk, $this);\n        $source = $this->open();\n\n        // Initialize hashing algorithm to verify uploaded contents\n        $algos = $target->getNativeHashAlgos();\n        $common_algo = 'sha1';\n        if ($algos && is_array($algos)) {\n            $supported = hash_algos();\n            foreach ($algos as $a) {\n                if (in_array(strtolower($a), $supported)) {\n                    $common_algo = strtolower($a);\n                    break;\n                }\n            }\n        }\n        $before = hash_init($common_algo);\n        // TODO: Make this resumable so that if the file cannot be migrated\n        //      in the max_execution_time, the migration can be continued\n        //      the next time the cron runs\n        try {\n            while ($block = $source->read($target->getBlockSize())) {\n                hash_update($before, $block);\n                $target->write($block);\n            }\n            $target->flush();\n        }\n        catch (Exception $e) {\n            // Migration failed\n            return false;\n        }\n\n        // Ask the backend to generate its own hash if at all possible\n        if (!($target_hash = $target->getHashDigest($common_algo))) {\n            $after = hash_init($common_algo);\n            // Verify that the hash of the target file matches the hash of\n            // the source file\n            $target = FileStorageBackend::lookup($bk, $this);\n            while ($block = $target->read())\n                hash_update($after, $block);\n            $target_hash = hash_final($after);\n        }\n\n        if (hash_final($before) != $target_hash) {\n            $target->unlink();\n            return false;\n        }\n\n        $this->bk = $target->getBkChar();\n        if (!$this->save())\n            return false;\n\n        return $source->unlink();\n    }\n\n    /**\n     * Considers the system's configuration for file storage selection based\n     * on the file information and purpose (FAQ attachment, image, etc).\n     *\n     * Parameters:\n     * $file - (hasharray) file information which would be passed to\n     * ::save() for instance.\n     *\n     * Returns:\n     * Instance<FileStorageBackend> backend selected based on the file\n     * received.\n     */\n    static function getBackendForFile($file) {\n        global $cfg;\n\n        $char = null;\n        if ($cfg) {\n            $char = $cfg->getDefaultStorageBackendChar();\n        }\n        try {\n            return FileStorageBackend::lookup($char ?: 'D', $file);\n        }\n        catch (Exception $x) {\n            return new AttachmentChunkedData($file);\n        }\n    }\n\n    static function lookupByHash($hash) {\n        if (isset(static::$keyCache[$hash]))\n            return static::$keyCache[$hash];\n\n        // Cache a negative lookup if no such file exists\n        return parent::lookup(array('key' => $hash));\n    }\n\n    static function lookup($id) {\n        return is_string($id)\n            ? static::lookupByHash($id)\n            : parent::lookup($id);\n    }\n\n    /*\n      Method formats http based $_FILE uploads - plus basic validation.\n     */\n    function format($files) {\n        global $ost;\n\n        if(!$files || !is_array($files))\n            return null;\n\n        //Reformat $_FILE  for the sane.\n        $attachments = array();\n        foreach($files as $k => $a) {\n            if(is_array($a))\n                foreach($a as $i => $v)\n                    $attachments[$i][$k] = $v;\n        }\n\n        //Basic validation.\n        foreach($attachments as $i => &$file) {\n            //skip no file upload \"error\" - why PHP calls it an error is beyond me.\n            if($file['error'] && $file['error']==UPLOAD_ERR_NO_FILE) {\n                unset($attachments[$i]);\n                continue;\n            }\n\n            if($file['error']) //PHP defined error!\n                $file['error'] = 'File upload error #'.$file['error'];\n            elseif(!$file['tmp_name'] || !is_uploaded_file($file['tmp_name']))\n                $file['error'] = 'Invalid or bad upload POST';\n        }\n        unset($file);\n\n        return array_filter($attachments);\n    }\n\n    /**\n     * Removes files and associated meta-data for files which no ticket,\n     * canned-response, or faq point to any more.\n     */\n    static function deleteOrphans() {\n        $sql = \"SELECT `id` FROM \".FILE_TABLE.\n            \" A1 WHERE (A1.ft = 'T' AND A1.created < NOW() - INTERVAL 1 DAY)\".\n            \" AND NOT EXISTS (SELECT id FROM \".ATTACHMENT_TABLE.\n            \" A2 WHERE A1.`id` = A2.`file_id`)\";\n\n        if (($res=db_query($sql)) && db_num_rows($res)) {\n            while (list($id) = db_fetch_row($res)) {\n                if ($f = static::lookup((int) $id))\n                    if (!$f->delete())\n                        break;\n            }\n        }\n\n        return true;\n    }\n\n    static function allLogos() {\n        return static::objects()\n            ->filter(array('ft' => 'L'))\n            ->order_by('created');\n    }\n\n    static function allBackdrops() {\n        return static::objects()\n            ->filter(array('ft' => 'B'))\n            ->order_by('created');\n    }\n}\n\nclass FileStorageBackend {\n    var $meta;\n    static $desc = false;\n    static $registry;\n    static $blocksize = 131072;\n    static $private = false;\n\n    /**\n     * All storage backends should call this function during the request\n     * bootstrap phase.\n     */\n    static function register($typechar, $class) {\n        self::$registry[$typechar] = $class;\n    }\n\n    static function allRegistered($private=false) {\n        $R = self::$registry;\n        if (!$private) {\n            foreach ($R as $i=>$bk) {\n                if ($bk::$private)\n                    unset($R[$i]);\n            }\n        }\n        return $R;\n    }\n\n    /**\n     * Retrieves the type char registered for this storage backend's class.\n     * Null is returned if the backend is not properly registered.\n     */\n    function getBkChar() {\n        foreach (self::$registry as $tc=>$class)\n            if ($this instanceof $class)\n                return $tc;\n    }\n\n    static function isRegistered($type) {\n        return isset(self::$registry[$type]);\n    }\n\n    static function lookup($type, $file=null) {\n        if (!isset(self::$registry[$type]))\n            throw new Exception(\"No such backend registered\");\n\n        $class = self::$registry[$type];\n        return new $class($file);\n    }\n\n    static function getInstance($file) {\n        if (!isset(self::$registry[$file->getBackend()]))\n            throw new Exception(\"No such backend registered\");\n\n        $class = self::$registry[$file->getBackend()];\n        return new $class($file);\n    }\n\n    /**\n     * Returns the optimal block size for the backend. When migrating, this\n     * size blocks would be best for sending to the ::write() method\n     */\n    function getBlockSize() {\n        return static::$blocksize;\n    }\n\n    /**\n     * Create an instance of the storage backend linking the related file.\n     * Information about the file metadata is accessible via the received\n     * filed object.\n     */\n    function __construct($meta) {\n        $this->meta = $meta;\n    }\n\n    /**\n     * Commit file to the storage backend. This method is used if the\n     * backend cannot support writing a file directly. Otherwise, the\n     * ::upload($file) method is preferred.\n     *\n     * Parameters:\n     * $data - (string|binary) file contents to be written to the backend\n     */\n    function write($data) {\n        return false;\n    }\n\n    /**\n     * Called after all the blocks are sent to the ::write() method. This\n     * method should return boolean FALSE if flushing the data was\n     * somehow inhibited.\n     */\n    function flush() {\n        return true;\n    }\n\n    /**\n     * Upload a file to the backend. This method is preferred over ::write()\n     * for files which are uploaded or are otherwise available out of\n     * memory. The backend is encouraged to avoid reading the entire\n     * contents into memory.\n     */\n    function upload($filepath) {\n        return $this->write(file_get_contents($filepath));\n    }\n\n    /**\n     * Returns data from the backend, optionally returning only the number\n     * of bytes indicated at the specified offset. If the data is available\n     * in chunks, one chunk may be returned at a time. The backend should\n     * return boolean false when no more chunks are available.\n     */\n    function read($amount=0, $offset=0) {\n        return false;\n    }\n\n    /**\n     * Convenience method to send all the file to standard output\n     */\n    function passthru() {\n        while ($block = $this->read())\n            echo $block;\n    }\n\n    /**\n     * If the data is not stored or not available locally, a redirect\n     * response can be sent to the user agent indicating the actual HTTP\n     * location of the data.\n     *\n     * If the data is available locally, this method should return boolean\n     * false to indicate that the read() method should be used to retrieve\n     * the data and broker it to the user agent.\n     */\n    function sendRedirectUrl($disposition='inline') {\n        return false;\n    }\n\n    /**\n     * Requests the backend to remove the file contents.\n     */\n    function unlink() {\n        return false;\n    }\n\n    /**\n     * Fetches a list of hash algorithms that are supported transparently\n     * through the ::write() and ::upload() methods. After writing or\n     * uploading file content, the ::getHashDigest($algo) method can be\n     * called to get a hash of the remote content without fetching the\n     * entire data stream to verify the content locally.\n     */\n    function getNativeHashAlgos() {\n        return array();\n    }\n\n    /**\n     * Returns a hash of the content calculated remotely by the storage\n     * backend. If this method fails, the hash chould be calculated by\n     * downloading the content and hashing locally\n     */\n    function getHashDigest($algo) {\n        return false;\n    }\n\n    /**\n     * getSize\n     *\n     * Retrieves the size of the contents written or available to be read.\n     * The backend should optimize this process if possible by keeping track\n     * of the bytes written in a way apart from `strlen`. This value will be\n     * used instead of inspecting the contents using `strlen`.\n     */\n    function getSize() {\n        return false;\n    }\n}\n\n\n/**\n * Attachments stored in the database are cut into 500kB chunks and stored\n * in the FILE_CHUNK_TABLE to overcome the max_allowed_packet limitation of\n * LOB fields in the MySQL database\n */\ndefine('CHUNK_SIZE', 500*1024); # Beware if you change this...\nclass AttachmentFileChunk extends VerySimpleModel {\n    static $meta = array(\n        'table' => FILE_CHUNK_TABLE,\n        'pk' => array('file_id', 'chunk_id'),\n        'joins' => array(\n            'file' => array(\n                'constraint' => array('file_id' => 'AttachmentFile.id'),\n            ),\n        ),\n    );\n}\n\nclass AttachmentChunkedData extends FileStorageBackend {\n    static $desc = /* @trans */ \"In the database\";\n    static $blocksize = CHUNK_SIZE;\n\n    function __construct($file) {\n        $this->file = $file;\n        $this->_chunk = 0;\n        $this->_buffer = false;\n        $this->eof = false;\n    }\n\n    function getSize() {\n        $row = AttachmentFileChunk::objects()\n            ->filter(array('file' => $this->file))\n            ->aggregate(array('length' => SqlAggregate::SUM(SqlFunction::LENGTH(new SqlField('filedata')))))\n            ->one();\n        return $row['length'];\n    }\n\n    function read($amount=CHUNK_SIZE, $offset=0) {\n        # Read requested length of data from attachment chunks\n        if ($this->eof)\n            return false;\n\n        while (strlen($this->_buffer) < $amount + $offset) {\n            try {\n                list($buf) = AttachmentFileChunk::objects()\n                    ->filter(array('file' => $this->file, 'chunk_id' => $this->_chunk++))\n                    ->values_flat('filedata')\n                    ->one();\n            }\n            catch (DoesNotExist $e) {\n                $this->eof = true;\n                break;\n            }\n            $this->_buffer .= $buf;\n        }\n        $chunk = substr($this->_buffer, $offset, $amount);\n        $this->_buffer = substr($this->_buffer, $offset + $amount);\n        return $chunk;\n    }\n\n    function write($what, $chunk_size=CHUNK_SIZE) {\n        $offset=0;\n        while ($block = substr($what, $offset, $chunk_size)) {\n            // Chunks are considered immutable. Importing chunks should\n            // forceable remove the contents of a file before write()ing new\n            // chunks. Therefore, inserts should be safe.\n            $chunk = new AttachmentFileChunk(array(\n                'file' => $this->file,\n                'chunk_id' => $this->_chunk++,\n                'filedata' => $block\n            ));\n            if (!$chunk->save())\n                return false;\n            $offset += strlen($block);\n        }\n\n        return $this->_chunk;\n    }\n\n    function unlink() {\n        return AttachmentFileChunk::objects()\n            ->filter(array('file' => $this->file))\n            ->delete();\n    }\n}\nFileStorageBackend::register('D', 'AttachmentChunkedData');\n\n/**\n * This class provides an interface for files attached on the filesystem in\n * versions previous to v1.7. The upgrader will keep the attachments on the\n * disk where they were and write the path into the `attrs` field of the\n * %file table. This module will continue to serve those files until they\n * are migrated with the `file` cli app\n */\nclass OneSixAttachments extends FileStorageBackend {\n    static $desc = \"upload_dir folder (from osTicket v1.6)\";\n    static $private = true;\n\n    function read($bytes=32768, $offset=false) {\n        $filename = $this->meta->attrs;\n        if (!$this->fp)\n            $this->fp = @fopen($filename, 'rb');\n        if (!$this->fp)\n            throw new IOException($filename.': Unable to open for reading');\n        if ($offset)\n            fseek($this->fp, $offset);\n        if (($status = @fread($this->fp, $bytes)) === false)\n            throw new IOException($filename.': Unable to read from file');\n        return $status;\n    }\n\n    function passthru() {\n        $filename = $this->meta->attrs;\n        if (($status = @readfile($filename)) === false)\n            throw new IOException($filename.': Unable to read from file');\n        return $status;\n    }\n\n    function write($data) {\n        throw new IOException('This backend does not support new files');\n    }\n\n    function upload($filepath) {\n        throw new IOException('This backend does not support new files');\n    }\n\n    function unlink() {\n        $filename = $this->meta->attrs;\n        if (!@unlink($filename))\n            throw new IOException($filename.': Unable to delete file');\n        // Drop usage of the `attrs` field\n        $this->meta->attrs = null;\n        $this->meta->save();\n        return true;\n    }\n}\nFileStorageBackend::register('6', 'OneSixAttachments');\n?>\n"], "filenames": ["include/class.file.php"], "buggy_code_start_loc": [243], "buggy_code_end_loc": [251], "fixing_code_start_loc": [243], "fixing_code_end_loc": [253], "type": "CWE-434", "message": "An issue was discovered in osTicket before 1.10.7 and 1.12.x before 1.12.1. The Ticket creation form allows users to upload files along with queries. It was found that the file-upload functionality has fewer (or no) mitigations implemented for file content checks; also, the output is not handled properly, causing persistent XSS that leads to cookie stealing or malicious actions. For example, a non-agent user can upload a .html file, and Content-Disposition will be set to inline instead of attachment.", "other": {"cve": {"id": "CVE-2019-14748", "sourceIdentifier": "cve@mitre.org", "published": "2019-08-07T17:15:12.417", "lastModified": "2019-08-14T15:29:57.277", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in osTicket before 1.10.7 and 1.12.x before 1.12.1. The Ticket creation form allows users to upload files along with queries. It was found that the file-upload functionality has fewer (or no) mitigations implemented for file content checks; also, the output is not handled properly, causing persistent XSS that leads to cookie stealing or malicious actions. For example, a non-agent user can upload a .html file, and Content-Disposition will be set to inline instead of attachment."}, {"lang": "es", "value": "Se detect\u00f3 un problema en osTicket versiones anteriores a 1.10.7 y versiones 1.12.x anteriores a 1.12.1. El formulario de creaci\u00f3n de Ticket permite a los usuarios cargar archivos en conjunto con consultas. Se encontr\u00f3 que la funcionalidad file-upload presenta menos (o ninguna) mitigaciones implementadas para las comprobaciones de contenido de archivos; adem\u00e1s, la salida no se maneja apropiadamente, causando una vulnerabilidad de tipo XSS persistente que conlleva al robo de cookies o acciones maliciosas. Por ejemplo, un usuario que no sea agente puede cargar un archivo .html y Content-Disposition ser\u00e1 ajustado a inline en lugar de attachment."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-434"}, {"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:osticket:osticket:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.10.7", "matchCriteriaId": "2D6B0B54-FE0E-41EB-953D-6A72FFB7B724"}, {"vulnerable": true, "criteria": "cpe:2.3:a:osticket:osticket:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.12", "versionEndExcluding": "1.12.1", "matchCriteriaId": "4874A3A8-A938-4E25-B01A-5366E34B2A28"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/154003/osTicket-1.12-File-Upload-Cross-Site-Scripting.html", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/osTicket/osTicket/commit/33ed106b1602f559a660a69f931a9d873685d1ba", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/osTicket/osTicket/releases/tag/v1.10.7", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/osTicket/osTicket/releases/tag/v1.12.1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/47224", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/osTicket/osTicket/commit/33ed106b1602f559a660a69f931a9d873685d1ba"}}