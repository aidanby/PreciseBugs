{"buggy_code": ["unreleased\n==========\n\n  * deps: http-errors@~1.6.2\n    - Make `message` property enumerable for `HttpError`s\n    - deps: depd@1.1.1\n    - deps: setprototypeof@1.0.3\n\n1.3.3 / 2016-11-14\n==================\n\n  * deps: path-is-absolute@1.0.1\n\n1.3.2 / 2016-06-17\n==================\n\n  * deps: http-errors@~1.5.0\n    - Use `setprototypeof` module to replace `__proto__` setting\n    - deps: inherits@2.0.1\n    - deps: statuses@'>= 1.3.0 < 2'\n    - perf: enable strict mode\n\n1.3.1 / 2016-02-28\n==================\n\n  * deps: http-errors@~1.4.0\n\n1.3.0 / 2015-06-15\n==================\n\n  * Use `path-is-absolute` to better detect absolute paths\n  * perf: enable strict mode\n  * perf: skip a variable reassignment\n\n1.2.2 / 2015-02-16\n==================\n\n  * deps: http-errors@~1.3.1\n    - Construct errors using defined constructors from `createError`\n    - Fix error names that are not identifiers\n    - Set a meaningful `name` property on constructed errors\n\n1.2.1 / 2015-01-19\n==================\n\n  * Fix root path disclosure\n\n1.2.0 / 2015-01-05\n==================\n\n  * Change error to 403 Forbidden when outside root\n  * Fix argument type errors to be consistent\n  * Fix path traversal vulnerability\n  * Use `http-errors` module directly\n\n1.1.0 / 2014-12-27\n==================\n\n  * Resolve the root path argument\n  * Use `http-assert` module\n\n1.0.0 / 2014-03-23\n==================\n\n  * Initial release\n", "/*!\n * resolve-path\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar createError = require('http-errors')\nvar normalize = require('path').normalize\nvar pathIsAbsolute = require('path-is-absolute')\nvar resolve = require('path').resolve\nvar sep = require('path').sep\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = resolvePath\n\n/**\n * Module variables.\n * @private\n */\n\nvar UP_PATH_REGEXP = /(?:^|[\\\\/])\\.\\.(?:[\\\\/]|$)/\n\n/**\n * Resolve relative path against a root path\n *\n * @param {string} rootPath\n * @param {string} relativePath\n * @return {string}\n * @public\n */\n\nfunction resolvePath (rootPath, relativePath) {\n  var path = relativePath\n  var root = rootPath\n\n  // root is optional, similar to root.resolve\n  if (arguments.length === 1) {\n    path = rootPath\n    root = process.cwd()\n  }\n\n  if (root == null) {\n    throw new TypeError('argument rootPath is required')\n  }\n\n  if (typeof root !== 'string') {\n    throw new TypeError('argument rootPath must be a string')\n  }\n\n  if (path == null) {\n    throw new TypeError('argument relativePath is required')\n  }\n\n  if (typeof path !== 'string') {\n    throw new TypeError('argument relativePath must be a string')\n  }\n\n  // containing NULL bytes is malicious\n  if (path.indexOf('\\0') !== -1) {\n    throw createError(400, 'Malicious Path')\n  }\n\n  // path should never be absolute\n  if (pathIsAbsolute.posix(path) || pathIsAbsolute.win32(path)) {\n    throw createError(400, 'Malicious Path')\n  }\n\n  // path outside root\n  if (UP_PATH_REGEXP.test(normalize('.' + sep + path))) {\n    throw createError(403)\n  }\n\n  // resolve & normalize the root path\n  root = normalize(resolve(root) + sep)\n\n  // resolve the path\n  return resolve(root, path)\n}\n", "\nvar assert = require('assert')\nvar path = require('path')\nvar resolvePath = require('..')\n\nvar basename = path.basename\nvar join = path.join\nvar normalize = path.normalize\nvar resolve = path.resolve\nvar sep = path.sep\n\ndescribe('resolvePath(relativePath)', function () {\n  describe('arguments', function () {\n    describe('relativePath', function () {\n      it('should be required', function () {\n        assert.throws(resolvePath.bind(null, undefined),\n          /argument relativePath is required/)\n      })\n\n      it('should reject non-strings', function () {\n        assert.throws(resolvePath.bind(null, 42),\n          /argument relativePath must be a string/)\n        assert.throws(resolvePath.bind(null, {}),\n          /argument relativePath must be a string/)\n        assert.throws(resolvePath.bind(null, []),\n          /argument relativePath must be a string/)\n      })\n\n      it('should resolve relative to cwd', function () {\n        assert.equal(normalize(resolvePath('index.js')),\n          normalize(join(process.cwd(), 'index.js')))\n      })\n\n      it('should accept empty string', function () {\n        assert.equal(normalize(resolvePath('')),\n          normalize(process.cwd()))\n      })\n    })\n  })\n\n  describe('when relativePath is absolute', function () {\n    it('should throw Malicious Path error', function () {\n      assert.throws(resolvePath.bind(null, join(__dirname, sep)),\n        expectError(400, 'Malicious Path'))\n    })\n  })\n\n  describe('when relativePath contains a NULL byte', function () {\n    it('should throw Malicious Path error', function () {\n      assert.throws(resolvePath.bind(null, 'hi\\0there'),\n        expectError(400, 'Malicious Path'))\n    })\n  })\n\n  describe('when relativePath resolves outside cwd', function () {\n    it('should throw Forbidden error', function () {\n      assert.throws(resolvePath.bind(null, '../index.js'),\n        expectError(403, 'Forbidden'))\n    })\n  })\n\n  describe('when relativePath discloses cwd', function () {\n    it('should throw Forbidden error', function () {\n      assert.throws(resolvePath.bind(null, join('test', '..', '..', basename(process.cwd()), 'index.js')),\n        expectError(403, 'Forbidden'))\n    })\n  })\n})\n\ndescribe('resolvePath(rootPath, relativePath)', function () {\n  describe('arguments', function () {\n    describe('rootPath', function () {\n      it('should be required', function () {\n        assert.throws(resolvePath.bind(null, undefined, 'index.js'),\n          /argument rootPath is required/)\n      })\n\n      it('should reject non-strings', function () {\n        assert.throws(resolvePath.bind(null, 42, 'index.js'),\n          /argument rootPath must be a string/)\n        assert.throws(resolvePath.bind(null, {}, 'index.js'),\n          /argument rootPath must be a string/)\n        assert.throws(resolvePath.bind(null, [], 'index.js'),\n          /argument rootPath must be a string/)\n      })\n\n      it('should resolve relative to rootPath', function () {\n        assert.equal(normalize(resolvePath(__dirname, 'index.js')),\n          normalize(resolve(__dirname, 'index.js')))\n      })\n\n      it('should accept relative path', function () {\n        assert.equal(normalize(resolvePath(join(__dirname, '..'), 'index.js')),\n          normalize(resolve(join(__dirname, '..'), 'index.js')))\n      })\n    })\n\n    describe('relativePath', function () {\n      it('should be required', function () {\n        assert.throws(resolvePath.bind(null, __dirname, undefined),\n          /argument relativePath is required/)\n      })\n\n      it('should reject non-strings', function () {\n        assert.throws(resolvePath.bind(null, __dirname, 42),\n          /argument relativePath must be a string/)\n        assert.throws(resolvePath.bind(null, __dirname, {}),\n          /argument relativePath must be a string/)\n        assert.throws(resolvePath.bind(null, __dirname, []),\n          /argument relativePath must be a string/)\n      })\n\n      it('should resolve relative to rootPath', function () {\n        assert.equal(normalize(resolvePath(__dirname, 'index.js')),\n          normalize(resolve(__dirname, 'index.js')))\n      })\n\n      it('should accept empty string', function () {\n        assert.equal(normalize(resolvePath(__dirname, '')),\n          normalize(__dirname))\n      })\n    })\n  })\n\n  describe('when relativePath is absolute', function () {\n    it('should throw Malicious Path error', function () {\n      assert.throws(resolvePath.bind(null, __dirname, __dirname),\n        expectError(400, 'Malicious Path'))\n    })\n  })\n\n  describe('when relativePath contains a NULL byte', function () {\n    it('should throw Malicious Path error', function () {\n      assert.throws(resolvePath.bind(null, __dirname, 'hi\\0there'),\n        expectError(400, 'Malicious Path'))\n    })\n  })\n\n  describe('when relativePath resolves outside rootPath', function () {\n    it('should throw Forbidden error', function () {\n      assert.throws(resolvePath.bind(null, __dirname, '../index.js'),\n        expectError(403, 'Forbidden'))\n    })\n\n    it('should not be tricked by missing separator', function () {\n      assert.throws(resolvePath.bind(null, __dirname, join('..', basename(__dirname) + '2', 'index.js')),\n        expectError(403, 'Forbidden'))\n    })\n  })\n\n  describe('when relativePath discloses rootPath', function () {\n    it('should throw Forbidden error', function () {\n      assert.throws(resolvePath.bind(null, __dirname, join('test', '..', '..', basename(__dirname), 'index.js')),\n        expectError(403, 'Forbidden'))\n    })\n  })\n})\n\nfunction expectError (status, message) {\n  return function expected (actual) {\n    return actual &&\n      actual.status === status &&\n      actual.message === message\n  }\n}\n"], "fixing_code": ["unreleased\n==========\n\n  * Fix resolving paths with certain special characters\n  * deps: http-errors@~1.6.2\n    - Make `message` property enumerable for `HttpError`s\n    - deps: depd@1.1.1\n    - deps: setprototypeof@1.0.3\n\n1.3.3 / 2016-11-14\n==================\n\n  * deps: path-is-absolute@1.0.1\n\n1.3.2 / 2016-06-17\n==================\n\n  * deps: http-errors@~1.5.0\n    - Use `setprototypeof` module to replace `__proto__` setting\n    - deps: inherits@2.0.1\n    - deps: statuses@'>= 1.3.0 < 2'\n    - perf: enable strict mode\n\n1.3.1 / 2016-02-28\n==================\n\n  * deps: http-errors@~1.4.0\n\n1.3.0 / 2015-06-15\n==================\n\n  * Use `path-is-absolute` to better detect absolute paths\n  * perf: enable strict mode\n  * perf: skip a variable reassignment\n\n1.2.2 / 2015-02-16\n==================\n\n  * deps: http-errors@~1.3.1\n    - Construct errors using defined constructors from `createError`\n    - Fix error names that are not identifiers\n    - Set a meaningful `name` property on constructed errors\n\n1.2.1 / 2015-01-19\n==================\n\n  * Fix root path disclosure\n\n1.2.0 / 2015-01-05\n==================\n\n  * Change error to 403 Forbidden when outside root\n  * Fix argument type errors to be consistent\n  * Fix path traversal vulnerability\n  * Use `http-errors` module directly\n\n1.1.0 / 2014-12-27\n==================\n\n  * Resolve the root path argument\n  * Use `http-assert` module\n\n1.0.0 / 2014-03-23\n==================\n\n  * Initial release\n", "/*!\n * resolve-path\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar createError = require('http-errors')\nvar join = require('path').join\nvar normalize = require('path').normalize\nvar pathIsAbsolute = require('path-is-absolute')\nvar resolve = require('path').resolve\nvar sep = require('path').sep\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = resolvePath\n\n/**\n * Module variables.\n * @private\n */\n\nvar UP_PATH_REGEXP = /(?:^|[\\\\/])\\.\\.(?:[\\\\/]|$)/\n\n/**\n * Resolve relative path against a root path\n *\n * @param {string} rootPath\n * @param {string} relativePath\n * @return {string}\n * @public\n */\n\nfunction resolvePath (rootPath, relativePath) {\n  var path = relativePath\n  var root = rootPath\n\n  // root is optional, similar to root.resolve\n  if (arguments.length === 1) {\n    path = rootPath\n    root = process.cwd()\n  }\n\n  if (root == null) {\n    throw new TypeError('argument rootPath is required')\n  }\n\n  if (typeof root !== 'string') {\n    throw new TypeError('argument rootPath must be a string')\n  }\n\n  if (path == null) {\n    throw new TypeError('argument relativePath is required')\n  }\n\n  if (typeof path !== 'string') {\n    throw new TypeError('argument relativePath must be a string')\n  }\n\n  // containing NULL bytes is malicious\n  if (path.indexOf('\\0') !== -1) {\n    throw createError(400, 'Malicious Path')\n  }\n\n  // path should never be absolute\n  if (pathIsAbsolute.posix(path) || pathIsAbsolute.win32(path)) {\n    throw createError(400, 'Malicious Path')\n  }\n\n  // path outside root\n  if (UP_PATH_REGEXP.test(normalize('.' + sep + path))) {\n    throw createError(403)\n  }\n\n  // join the relative path\n  return normalize(join(resolve(root), path))\n}\n", "\nvar assert = require('assert')\nvar path = require('path')\nvar resolvePath = require('..')\n\nvar basename = path.basename\nvar join = path.join\nvar normalize = path.normalize\nvar resolve = path.resolve\nvar sep = path.sep\n\ndescribe('resolvePath(relativePath)', function () {\n  describe('arguments', function () {\n    describe('relativePath', function () {\n      it('should be required', function () {\n        assert.throws(resolvePath.bind(null, undefined),\n          /argument relativePath is required/)\n      })\n\n      it('should reject non-strings', function () {\n        assert.throws(resolvePath.bind(null, 42),\n          /argument relativePath must be a string/)\n        assert.throws(resolvePath.bind(null, {}),\n          /argument relativePath must be a string/)\n        assert.throws(resolvePath.bind(null, []),\n          /argument relativePath must be a string/)\n      })\n\n      it('should resolve relative to cwd', function () {\n        assert.equal(normalize(resolvePath('index.js')),\n          normalize(join(process.cwd(), 'index.js')))\n      })\n\n      it('should resolve relative with special characters', function () {\n        assert.equal(normalize(resolvePath('f:oo$bar')),\n          normalize(join(process.cwd(), './f:oo$bar')))\n      })\n\n      it('should accept empty string', function () {\n        assert.equal(normalize(resolvePath('')),\n          normalize(process.cwd()))\n      })\n    })\n  })\n\n  describe('when relativePath is absolute', function () {\n    it('should throw Malicious Path error', function () {\n      assert.throws(resolvePath.bind(null, join(__dirname, sep)),\n        expectError(400, 'Malicious Path'))\n    })\n  })\n\n  describe('when relativePath contains a NULL byte', function () {\n    it('should throw Malicious Path error', function () {\n      assert.throws(resolvePath.bind(null, 'hi\\0there'),\n        expectError(400, 'Malicious Path'))\n    })\n  })\n\n  describe('when relativePath resolves outside cwd', function () {\n    it('should throw Forbidden error', function () {\n      assert.throws(resolvePath.bind(null, '../index.js'),\n        expectError(403, 'Forbidden'))\n    })\n  })\n\n  describe('when relativePath discloses cwd', function () {\n    it('should throw Forbidden error', function () {\n      assert.throws(resolvePath.bind(null, join('test', '..', '..', basename(process.cwd()), 'index.js')),\n        expectError(403, 'Forbidden'))\n    })\n  })\n})\n\ndescribe('resolvePath(rootPath, relativePath)', function () {\n  describe('arguments', function () {\n    describe('rootPath', function () {\n      it('should be required', function () {\n        assert.throws(resolvePath.bind(null, undefined, 'index.js'),\n          /argument rootPath is required/)\n      })\n\n      it('should reject non-strings', function () {\n        assert.throws(resolvePath.bind(null, 42, 'index.js'),\n          /argument rootPath must be a string/)\n        assert.throws(resolvePath.bind(null, {}, 'index.js'),\n          /argument rootPath must be a string/)\n        assert.throws(resolvePath.bind(null, [], 'index.js'),\n          /argument rootPath must be a string/)\n      })\n\n      it('should resolve relative to rootPath', function () {\n        assert.equal(normalize(resolvePath(__dirname, 'index.js')),\n          normalize(resolve(__dirname, 'index.js')))\n      })\n\n      it('should resolve relative to rootPath with special characters', function () {\n        assert.equal(normalize(resolvePath(__dirname, 'f:oo$bar')),\n        normalize(resolve(__dirname, './f:oo$bar')))\n      })\n\n      it('should accept relative path', function () {\n        assert.equal(normalize(resolvePath(join(__dirname, '..'), 'index.js')),\n          normalize(resolve(join(__dirname, '..'), 'index.js')))\n      })\n    })\n\n    describe('relativePath', function () {\n      it('should be required', function () {\n        assert.throws(resolvePath.bind(null, __dirname, undefined),\n          /argument relativePath is required/)\n      })\n\n      it('should reject non-strings', function () {\n        assert.throws(resolvePath.bind(null, __dirname, 42),\n          /argument relativePath must be a string/)\n        assert.throws(resolvePath.bind(null, __dirname, {}),\n          /argument relativePath must be a string/)\n        assert.throws(resolvePath.bind(null, __dirname, []),\n          /argument relativePath must be a string/)\n      })\n\n      it('should resolve relative to rootPath', function () {\n        assert.equal(normalize(resolvePath(__dirname, 'index.js')),\n          normalize(resolve(__dirname, 'index.js')))\n      })\n\n      it('should accept empty string', function () {\n        assert.equal(normalize(resolvePath(__dirname, '')),\n          normalize(__dirname))\n      })\n    })\n  })\n\n  describe('when relativePath is absolute', function () {\n    it('should throw Malicious Path error', function () {\n      assert.throws(resolvePath.bind(null, __dirname, __dirname),\n        expectError(400, 'Malicious Path'))\n    })\n  })\n\n  describe('when relativePath contains a NULL byte', function () {\n    it('should throw Malicious Path error', function () {\n      assert.throws(resolvePath.bind(null, __dirname, 'hi\\0there'),\n        expectError(400, 'Malicious Path'))\n    })\n  })\n\n  describe('when relativePath resolves outside rootPath', function () {\n    it('should throw Forbidden error', function () {\n      assert.throws(resolvePath.bind(null, __dirname, '../index.js'),\n        expectError(403, 'Forbidden'))\n    })\n\n    it('should not be tricked by missing separator', function () {\n      assert.throws(resolvePath.bind(null, __dirname, join('..', basename(__dirname) + '2', 'index.js')),\n        expectError(403, 'Forbidden'))\n    })\n  })\n\n  describe('when relativePath discloses rootPath', function () {\n    it('should throw Forbidden error', function () {\n      assert.throws(resolvePath.bind(null, __dirname, join('test', '..', '..', basename(__dirname), 'index.js')),\n        expectError(403, 'Forbidden'))\n    })\n  })\n})\n\nfunction expectError (status, message) {\n  return function expected (actual) {\n    return actual &&\n      actual.status === status &&\n      actual.message === message\n  }\n}\n"], "filenames": ["HISTORY.md", "index.js", "test/resolvePath.js"], "buggy_code_start_loc": [3, 15, 31], "buggy_code_end_loc": [3, 90, 89], "fixing_code_start_loc": [4, 16, 32], "fixing_code_end_loc": [5, 88, 100], "type": "CWE-22", "message": "resolve-path node module before 1.4.0 suffers from a Path Traversal vulnerability due to lack of validation of paths with certain special characters, which allows a malicious user to read content of any file with known path.", "other": {"cve": {"id": "CVE-2018-3732", "sourceIdentifier": "support@hackerone.com", "published": "2018-06-07T02:29:08.770", "lastModified": "2023-02-28T17:49:44.920", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "resolve-path node module before 1.4.0 suffers from a Path Traversal vulnerability due to lack of validation of paths with certain special characters, which allows a malicious user to read content of any file with known path."}, {"lang": "es", "value": "El m\u00f3dulo de node resolve-path en versiones anteriores a la 1.4.0 sufre de una vulnerabilidad de salto de directorio debido a la falta de validaci\u00f3n de rutas con ciertos caracteres especiales, que permite que un usuario malicioso lea contenido de cualquier archivo con una ruta conocida."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "support@hackerone.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:resolve-path_project:resolve-path:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "1.4.0", "matchCriteriaId": "F0AE68C7-6627-4B14-A92D-17F503DBFFD3"}]}]}], "references": [{"url": "https://github.com/pillarjs/resolve-path/commit/fe5b8052cafd35fcdafe9210e100e9050b37d2a0", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://hackerone.com/reports/315760", "source": "support@hackerone.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pillarjs/resolve-path/commit/fe5b8052cafd35fcdafe9210e100e9050b37d2a0"}}