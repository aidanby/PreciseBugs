{"buggy_code": ["/*\n * FLV muxer\n * Copyright (c) 2003 The FFmpeg Project\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/dict.h\"\n#include \"libavutil/intfloat.h\"\n#include \"libavutil/avassert.h\"\n#include \"libavutil/mathematics.h\"\n#include \"avio_internal.h\"\n#include \"avio.h\"\n#include \"avc.h\"\n#include \"avformat.h\"\n#include \"flv.h\"\n#include \"internal.h\"\n#include \"metadata.h\"\n#include \"libavutil/opt.h\"\n#include \"libavcodec/put_bits.h\"\n#include \"libavcodec/aacenctab.h\"\n\n\nstatic const AVCodecTag flv_video_codec_ids[] = {\n    { AV_CODEC_ID_FLV1,     FLV_CODECID_H263 },\n    { AV_CODEC_ID_H263,     FLV_CODECID_REALH263 },\n    { AV_CODEC_ID_MPEG4,    FLV_CODECID_MPEG4 },\n    { AV_CODEC_ID_FLASHSV,  FLV_CODECID_SCREEN },\n    { AV_CODEC_ID_FLASHSV2, FLV_CODECID_SCREEN2 },\n    { AV_CODEC_ID_VP6F,     FLV_CODECID_VP6 },\n    { AV_CODEC_ID_VP6,      FLV_CODECID_VP6 },\n    { AV_CODEC_ID_VP6A,     FLV_CODECID_VP6A },\n    { AV_CODEC_ID_H264,     FLV_CODECID_H264 },\n    { AV_CODEC_ID_NONE,     0 }\n};\n\nstatic const AVCodecTag flv_audio_codec_ids[] = {\n    { AV_CODEC_ID_MP3,        FLV_CODECID_MP3        >> FLV_AUDIO_CODECID_OFFSET },\n    { AV_CODEC_ID_PCM_U8,     FLV_CODECID_PCM        >> FLV_AUDIO_CODECID_OFFSET },\n    { AV_CODEC_ID_PCM_S16BE,  FLV_CODECID_PCM        >> FLV_AUDIO_CODECID_OFFSET },\n    { AV_CODEC_ID_PCM_S16LE,  FLV_CODECID_PCM_LE     >> FLV_AUDIO_CODECID_OFFSET },\n    { AV_CODEC_ID_ADPCM_SWF,  FLV_CODECID_ADPCM      >> FLV_AUDIO_CODECID_OFFSET },\n    { AV_CODEC_ID_AAC,        FLV_CODECID_AAC        >> FLV_AUDIO_CODECID_OFFSET },\n    { AV_CODEC_ID_NELLYMOSER, FLV_CODECID_NELLYMOSER >> FLV_AUDIO_CODECID_OFFSET },\n    { AV_CODEC_ID_PCM_MULAW,  FLV_CODECID_PCM_MULAW  >> FLV_AUDIO_CODECID_OFFSET },\n    { AV_CODEC_ID_PCM_ALAW,   FLV_CODECID_PCM_ALAW   >> FLV_AUDIO_CODECID_OFFSET },\n    { AV_CODEC_ID_SPEEX,      FLV_CODECID_SPEEX      >> FLV_AUDIO_CODECID_OFFSET },\n    { AV_CODEC_ID_NONE,       0 }\n};\n\ntypedef enum {\n    FLV_AAC_SEQ_HEADER_DETECT = (1 << 0),\n    FLV_NO_SEQUENCE_END = (1 << 1),\n    FLV_ADD_KEYFRAME_INDEX = (1 << 2),\n    FLV_NO_METADATA = (1 << 3),\n    FLV_NO_DURATION_FILESIZE = (1 << 4),\n} FLVFlags;\n\ntypedef struct FLVFileposition {\n    int64_t keyframe_position;\n    double keyframe_timestamp;\n    struct FLVFileposition *next;\n} FLVFileposition;\n\ntypedef struct FLVContext {\n    AVClass *av_class;\n    int     reserved;\n    int64_t duration_offset;\n    int64_t filesize_offset;\n    int64_t duration;\n    int64_t delay;      ///< first dts delay (needed for AVC & Speex)\n\n    int64_t datastart_offset;\n    int64_t datasize_offset;\n    int64_t datasize;\n    int64_t videosize_offset;\n    int64_t videosize;\n    int64_t audiosize_offset;\n    int64_t audiosize;\n\n    int64_t metadata_size_pos;\n    int64_t metadata_totalsize_pos;\n    int64_t metadata_totalsize;\n    int64_t keyframe_index_size;\n\n    int64_t lasttimestamp_offset;\n    double lasttimestamp;\n    int64_t lastkeyframetimestamp_offset;\n    double lastkeyframetimestamp;\n    int64_t lastkeyframelocation_offset;\n    int64_t lastkeyframelocation;\n\n    int acurframeindex;\n    int64_t keyframes_info_offset;\n\n    int64_t filepositions_count;\n    FLVFileposition *filepositions;\n    FLVFileposition *head_filepositions;\n\n    AVCodecParameters *audio_par;\n    AVCodecParameters *video_par;\n    double framerate;\n    AVCodecParameters *data_par;\n\n    int flags;\n} FLVContext;\n\ntypedef struct FLVStreamContext {\n    int64_t last_ts;    ///< last timestamp for each stream\n} FLVStreamContext;\n\nstatic int get_audio_flags(AVFormatContext *s, AVCodecParameters *par)\n{\n    int flags = (par->bits_per_coded_sample == 16) ? FLV_SAMPLESSIZE_16BIT\n                                                   : FLV_SAMPLESSIZE_8BIT;\n\n    if (par->codec_id == AV_CODEC_ID_AAC) // specs force these parameters\n        return FLV_CODECID_AAC | FLV_SAMPLERATE_44100HZ |\n               FLV_SAMPLESSIZE_16BIT | FLV_STEREO;\n    else if (par->codec_id == AV_CODEC_ID_SPEEX) {\n        if (par->sample_rate != 16000) {\n            av_log(s, AV_LOG_ERROR,\n                   \"FLV only supports wideband (16kHz) Speex audio\\n\");\n            return AVERROR(EINVAL);\n        }\n        if (par->channels != 1) {\n            av_log(s, AV_LOG_ERROR, \"FLV only supports mono Speex audio\\n\");\n            return AVERROR(EINVAL);\n        }\n        return FLV_CODECID_SPEEX | FLV_SAMPLERATE_11025HZ | FLV_SAMPLESSIZE_16BIT;\n    } else {\n        switch (par->sample_rate) {\n        case 48000:\n            // 48khz mp3 is stored with 44k1 samplerate identifer\n            if (par->codec_id == AV_CODEC_ID_MP3) {\n                flags |= FLV_SAMPLERATE_44100HZ;\n                break;\n            } else {\n                goto error;\n            }\n        case 44100:\n            flags |= FLV_SAMPLERATE_44100HZ;\n            break;\n        case 22050:\n            flags |= FLV_SAMPLERATE_22050HZ;\n            break;\n        case 11025:\n            flags |= FLV_SAMPLERATE_11025HZ;\n            break;\n        case 16000: // nellymoser only\n        case  8000: // nellymoser only\n        case  5512: // not MP3\n            if (par->codec_id != AV_CODEC_ID_MP3) {\n                flags |= FLV_SAMPLERATE_SPECIAL;\n                break;\n            }\n        default:\nerror:\n            av_log(s, AV_LOG_ERROR,\n                   \"FLV does not support sample rate %d, \"\n                   \"choose from (44100, 22050, 11025)\\n\", par->sample_rate);\n            return AVERROR(EINVAL);\n        }\n    }\n\n    if (par->channels > 1)\n        flags |= FLV_STEREO;\n\n    switch (par->codec_id) {\n    case AV_CODEC_ID_MP3:\n        flags |= FLV_CODECID_MP3    | FLV_SAMPLESSIZE_16BIT;\n        break;\n    case AV_CODEC_ID_PCM_U8:\n        flags |= FLV_CODECID_PCM    | FLV_SAMPLESSIZE_8BIT;\n        break;\n    case AV_CODEC_ID_PCM_S16BE:\n        flags |= FLV_CODECID_PCM    | FLV_SAMPLESSIZE_16BIT;\n        break;\n    case AV_CODEC_ID_PCM_S16LE:\n        flags |= FLV_CODECID_PCM_LE | FLV_SAMPLESSIZE_16BIT;\n        break;\n    case AV_CODEC_ID_ADPCM_SWF:\n        flags |= FLV_CODECID_ADPCM  | FLV_SAMPLESSIZE_16BIT;\n        break;\n    case AV_CODEC_ID_NELLYMOSER:\n        if (par->sample_rate == 8000)\n            flags |= FLV_CODECID_NELLYMOSER_8KHZ_MONO  | FLV_SAMPLESSIZE_16BIT;\n        else if (par->sample_rate == 16000)\n            flags |= FLV_CODECID_NELLYMOSER_16KHZ_MONO | FLV_SAMPLESSIZE_16BIT;\n        else\n            flags |= FLV_CODECID_NELLYMOSER            | FLV_SAMPLESSIZE_16BIT;\n        break;\n    case AV_CODEC_ID_PCM_MULAW:\n        flags = FLV_CODECID_PCM_MULAW | FLV_SAMPLERATE_SPECIAL | FLV_SAMPLESSIZE_16BIT;\n        break;\n    case AV_CODEC_ID_PCM_ALAW:\n        flags = FLV_CODECID_PCM_ALAW  | FLV_SAMPLERATE_SPECIAL | FLV_SAMPLESSIZE_16BIT;\n        break;\n    case 0:\n        flags |= par->codec_tag << 4;\n        break;\n    default:\n        av_log(s, AV_LOG_ERROR, \"Audio codec '%s' not compatible with FLV\\n\",\n               avcodec_get_name(par->codec_id));\n        return AVERROR(EINVAL);\n    }\n\n    return flags;\n}\n\nstatic void put_amf_string(AVIOContext *pb, const char *str)\n{\n    size_t len = strlen(str);\n    avio_wb16(pb, len);\n    avio_write(pb, str, len);\n}\n\n// FLV timestamps are 32 bits signed, RTMP timestamps should be 32-bit unsigned\nstatic void put_timestamp(AVIOContext *pb, int64_t ts) {\n    avio_wb24(pb, ts & 0xFFFFFF);\n    avio_w8(pb, (ts >> 24) & 0x7F);\n}\n\nstatic void put_avc_eos_tag(AVIOContext *pb, unsigned ts)\n{\n    avio_w8(pb, FLV_TAG_TYPE_VIDEO);\n    avio_wb24(pb, 5);               /* Tag Data Size */\n    put_timestamp(pb, ts);\n    avio_wb24(pb, 0);               /* StreamId = 0 */\n    avio_w8(pb, 23);                /* ub[4] FrameType = 1, ub[4] CodecId = 7 */\n    avio_w8(pb, 2);                 /* AVC end of sequence */\n    avio_wb24(pb, 0);               /* Always 0 for AVC EOS. */\n    avio_wb32(pb, 16);              /* Size of FLV tag */\n}\n\nstatic void put_amf_double(AVIOContext *pb, double d)\n{\n    avio_w8(pb, AMF_DATA_TYPE_NUMBER);\n    avio_wb64(pb, av_double2int(d));\n}\n\nstatic void put_amf_byte(AVIOContext *pb, unsigned char abyte)\n{\n    avio_w8(pb, abyte);\n}\n\nstatic void put_amf_dword_array(AVIOContext *pb, uint32_t dw)\n{\n    avio_w8(pb, AMF_DATA_TYPE_ARRAY);\n    avio_wb32(pb, dw);\n}\n\nstatic void put_amf_bool(AVIOContext *pb, int b)\n{\n    avio_w8(pb, AMF_DATA_TYPE_BOOL);\n    avio_w8(pb, !!b);\n}\n\nstatic void write_metadata(AVFormatContext *s, unsigned int ts)\n{\n    AVIOContext *pb = s->pb;\n    FLVContext *flv = s->priv_data;\n    int write_duration_filesize = !(flv->flags & FLV_NO_DURATION_FILESIZE);\n    int metadata_count = 0;\n    int64_t metadata_count_pos;\n    AVDictionaryEntry *tag = NULL;\n\n    /* write meta_tag */\n    avio_w8(pb, FLV_TAG_TYPE_META);            // tag type META\n    flv->metadata_size_pos = avio_tell(pb);\n    avio_wb24(pb, 0);           // size of data part (sum of all parts below)\n    avio_wb24(pb, ts);          // timestamp\n    avio_wb32(pb, 0);           // reserved\n\n    /* now data of data_size size */\n\n    /* first event name as a string */\n    avio_w8(pb, AMF_DATA_TYPE_STRING);\n    put_amf_string(pb, \"onMetaData\"); // 12 bytes\n\n    /* mixed array (hash) with size and string/type/data tuples */\n    avio_w8(pb, AMF_DATA_TYPE_MIXEDARRAY);\n    metadata_count_pos = avio_tell(pb);\n    metadata_count = 4 * !!flv->video_par +\n                     5 * !!flv->audio_par +\n                     1 * !!flv->data_par;\n    if (write_duration_filesize) {\n        metadata_count += 2; // +2 for duration and file size\n    }\n    avio_wb32(pb, metadata_count);\n\n    if (write_duration_filesize) {\n        put_amf_string(pb, \"duration\");\n        flv->duration_offset = avio_tell(pb);\n        // fill in the guessed duration, it'll be corrected later if incorrect\n        put_amf_double(pb, s->duration / AV_TIME_BASE);\n    }\n\n    if (flv->video_par) {\n        put_amf_string(pb, \"width\");\n        put_amf_double(pb, flv->video_par->width);\n\n        put_amf_string(pb, \"height\");\n        put_amf_double(pb, flv->video_par->height);\n\n        put_amf_string(pb, \"videodatarate\");\n        put_amf_double(pb, flv->video_par->bit_rate / 1024.0);\n\n        if (flv->framerate != 0.0) {\n            put_amf_string(pb, \"framerate\");\n            put_amf_double(pb, flv->framerate);\n            metadata_count++;\n        }\n\n        put_amf_string(pb, \"videocodecid\");\n        put_amf_double(pb, flv->video_par->codec_tag);\n    }\n\n    if (flv->audio_par) {\n        put_amf_string(pb, \"audiodatarate\");\n        put_amf_double(pb, flv->audio_par->bit_rate / 1024.0);\n\n        put_amf_string(pb, \"audiosamplerate\");\n        put_amf_double(pb, flv->audio_par->sample_rate);\n\n        put_amf_string(pb, \"audiosamplesize\");\n        put_amf_double(pb, flv->audio_par->codec_id == AV_CODEC_ID_PCM_U8 ? 8 : 16);\n\n        put_amf_string(pb, \"stereo\");\n        put_amf_bool(pb, flv->audio_par->channels == 2);\n\n        put_amf_string(pb, \"audiocodecid\");\n        put_amf_double(pb, flv->audio_par->codec_tag);\n    }\n\n    if (flv->data_par) {\n        put_amf_string(pb, \"datastream\");\n        put_amf_double(pb, 0.0);\n    }\n\n    ff_standardize_creation_time(s);\n    while ((tag = av_dict_get(s->metadata, \"\", tag, AV_DICT_IGNORE_SUFFIX))) {\n        if(   !strcmp(tag->key, \"width\")\n            ||!strcmp(tag->key, \"height\")\n            ||!strcmp(tag->key, \"videodatarate\")\n            ||!strcmp(tag->key, \"framerate\")\n            ||!strcmp(tag->key, \"videocodecid\")\n            ||!strcmp(tag->key, \"audiodatarate\")\n            ||!strcmp(tag->key, \"audiosamplerate\")\n            ||!strcmp(tag->key, \"audiosamplesize\")\n            ||!strcmp(tag->key, \"stereo\")\n            ||!strcmp(tag->key, \"audiocodecid\")\n            ||!strcmp(tag->key, \"duration\")\n            ||!strcmp(tag->key, \"onMetaData\")\n            ||!strcmp(tag->key, \"datasize\")\n            ||!strcmp(tag->key, \"lasttimestamp\")\n            ||!strcmp(tag->key, \"totalframes\")\n            ||!strcmp(tag->key, \"hasAudio\")\n            ||!strcmp(tag->key, \"hasVideo\")\n            ||!strcmp(tag->key, \"hasCuePoints\")\n            ||!strcmp(tag->key, \"hasMetadata\")\n            ||!strcmp(tag->key, \"hasKeyframes\")\n        ){\n            av_log(s, AV_LOG_DEBUG, \"Ignoring metadata for %s\\n\", tag->key);\n            continue;\n        }\n        put_amf_string(pb, tag->key);\n        avio_w8(pb, AMF_DATA_TYPE_STRING);\n        put_amf_string(pb, tag->value);\n        metadata_count++;\n    }\n\n    if (write_duration_filesize) {\n        put_amf_string(pb, \"filesize\");\n        flv->filesize_offset = avio_tell(pb);\n        put_amf_double(pb, 0); // delayed write\n    }\n\n    if (flv->flags & FLV_ADD_KEYFRAME_INDEX) {\n        flv->acurframeindex = 0;\n        flv->keyframe_index_size = 0;\n\n        put_amf_string(pb, \"hasVideo\");\n        put_amf_bool(pb, !!flv->video_par);\n        metadata_count++;\n\n        put_amf_string(pb, \"hasKeyframes\");\n        put_amf_bool(pb, 1);\n        metadata_count++;\n\n        put_amf_string(pb, \"hasAudio\");\n        put_amf_bool(pb, !!flv->audio_par);\n        metadata_count++;\n\n        put_amf_string(pb, \"hasMetadata\");\n        put_amf_bool(pb, 1);\n        metadata_count++;\n\n        put_amf_string(pb, \"canSeekToEnd\");\n        put_amf_bool(pb, 1);\n        metadata_count++;\n\n        put_amf_string(pb, \"datasize\");\n        flv->datasize_offset = avio_tell(pb);\n        flv->datasize = 0;\n        put_amf_double(pb, flv->datasize);\n        metadata_count++;\n\n        put_amf_string(pb, \"videosize\");\n        flv->videosize_offset = avio_tell(pb);\n        flv->videosize = 0;\n        put_amf_double(pb, flv->videosize);\n        metadata_count++;\n\n        put_amf_string(pb, \"audiosize\");\n        flv->audiosize_offset = avio_tell(pb);\n        flv->audiosize = 0;\n        put_amf_double(pb, flv->audiosize);\n        metadata_count++;\n\n        put_amf_string(pb, \"lasttimestamp\");\n        flv->lasttimestamp_offset = avio_tell(pb);\n        flv->lasttimestamp = 0;\n        put_amf_double(pb, 0);\n        metadata_count++;\n\n        put_amf_string(pb, \"lastkeyframetimestamp\");\n        flv->lastkeyframetimestamp_offset = avio_tell(pb);\n        flv->lastkeyframetimestamp = 0;\n        put_amf_double(pb, 0);\n        metadata_count++;\n\n        put_amf_string(pb, \"lastkeyframelocation\");\n        flv->lastkeyframelocation_offset = avio_tell(pb);\n        flv->lastkeyframelocation = 0;\n        put_amf_double(pb, 0);\n        metadata_count++;\n\n        put_amf_string(pb, \"keyframes\");\n        put_amf_byte(pb, AMF_DATA_TYPE_OBJECT);\n        metadata_count++;\n\n        flv->keyframes_info_offset = avio_tell(pb);\n    }\n\n    put_amf_string(pb, \"\");\n    avio_w8(pb, AMF_END_OF_OBJECT);\n\n    /* write total size of tag */\n    flv->metadata_totalsize = avio_tell(pb) - flv->metadata_size_pos - 10;\n\n    avio_seek(pb, metadata_count_pos, SEEK_SET);\n    avio_wb32(pb, metadata_count);\n\n    avio_seek(pb, flv->metadata_size_pos, SEEK_SET);\n    avio_wb24(pb, flv->metadata_totalsize);\n    avio_skip(pb, flv->metadata_totalsize + 10 - 3);\n    flv->metadata_totalsize_pos = avio_tell(pb);\n    avio_wb32(pb, flv->metadata_totalsize + 11);\n}\n\nstatic int unsupported_codec(AVFormatContext *s,\n                             const char* type, int codec_id)\n{\n    const AVCodecDescriptor *desc = avcodec_descriptor_get(codec_id);\n    av_log(s, AV_LOG_ERROR,\n           \"%s codec %s not compatible with flv\\n\",\n            type,\n            desc ? desc->name : \"unknown\");\n    return AVERROR(ENOSYS);\n}\n\nstatic void flv_write_codec_header(AVFormatContext* s, AVCodecParameters* par, int64_t ts) {\n    int64_t data_size;\n    AVIOContext *pb = s->pb;\n    FLVContext *flv = s->priv_data;\n\n    if (par->codec_id == AV_CODEC_ID_AAC || par->codec_id == AV_CODEC_ID_H264\n            || par->codec_id == AV_CODEC_ID_MPEG4) {\n        int64_t pos;\n        avio_w8(pb,\n                par->codec_type == AVMEDIA_TYPE_VIDEO ?\n                        FLV_TAG_TYPE_VIDEO : FLV_TAG_TYPE_AUDIO);\n        avio_wb24(pb, 0); // size patched later\n        put_timestamp(pb, ts);\n        avio_wb24(pb, 0); // streamid\n        pos = avio_tell(pb);\n        if (par->codec_id == AV_CODEC_ID_AAC) {\n            avio_w8(pb, get_audio_flags(s, par));\n            avio_w8(pb, 0); // AAC sequence header\n\n            if (!par->extradata_size && (flv->flags & FLV_AAC_SEQ_HEADER_DETECT)) {\n                PutBitContext pbc;\n                int samplerate_index;\n                int channels = flv->audio_par->channels\n                        - (flv->audio_par->channels == 8 ? 1 : 0);\n                uint8_t data[2];\n\n                for (samplerate_index = 0; samplerate_index < 16;\n                        samplerate_index++)\n                    if (flv->audio_par->sample_rate\n                            == mpeg4audio_sample_rates[samplerate_index])\n                        break;\n\n                init_put_bits(&pbc, data, sizeof(data));\n                put_bits(&pbc, 5, flv->audio_par->profile + 1); //profile\n                put_bits(&pbc, 4, samplerate_index); //sample rate index\n                put_bits(&pbc, 4, channels);\n                put_bits(&pbc, 1, 0); //frame length - 1024 samples\n                put_bits(&pbc, 1, 0); //does not depend on core coder\n                put_bits(&pbc, 1, 0); //is not extension\n                flush_put_bits(&pbc);\n\n                avio_w8(pb, data[0]);\n                avio_w8(pb, data[1]);\n\n                av_log(s, AV_LOG_WARNING, \"AAC sequence header: %02x %02x.\\n\",\n                        data[0], data[1]);\n            }\n            avio_write(pb, par->extradata, par->extradata_size);\n        } else {\n            avio_w8(pb, par->codec_tag | FLV_FRAME_KEY); // flags\n            avio_w8(pb, 0); // AVC sequence header\n            avio_wb24(pb, 0); // composition time\n            ff_isom_write_avcc(pb, par->extradata, par->extradata_size);\n        }\n        data_size = avio_tell(pb) - pos;\n        avio_seek(pb, -data_size - 10, SEEK_CUR);\n        avio_wb24(pb, data_size);\n        avio_skip(pb, data_size + 10 - 3);\n        avio_wb32(pb, data_size + 11); // previous tag size\n    }\n}\n\nstatic int flv_append_keyframe_info(AVFormatContext *s, FLVContext *flv, double ts, int64_t pos)\n{\n    FLVFileposition *position = av_malloc(sizeof(FLVFileposition));\n\n    if (!position) {\n        av_log(s, AV_LOG_WARNING, \"no mem for add keyframe index!\\n\");\n        return AVERROR(ENOMEM);\n    }\n\n    position->keyframe_timestamp = ts;\n    position->keyframe_position = pos;\n\n    if (!flv->filepositions_count) {\n        flv->filepositions = position;\n        flv->head_filepositions = flv->filepositions;\n        position->next = NULL;\n    } else {\n        flv->filepositions->next = position;\n        position->next = NULL;\n        flv->filepositions = flv->filepositions->next;\n    }\n\n    flv->filepositions_count++;\n\n    return 0;\n}\n\nstatic int shift_data(AVFormatContext *s)\n{\n    int ret = 0;\n    int n = 0;\n    int64_t metadata_size = 0;\n    FLVContext *flv = s->priv_data;\n    int64_t pos, pos_end = avio_tell(s->pb);\n    uint8_t *buf, *read_buf[2];\n    int read_buf_id = 0;\n    int read_size[2];\n    AVIOContext *read_pb;\n\n    metadata_size = flv->filepositions_count * 9 * 2 + 10; /* filepositions and times value */\n    metadata_size += 2 + 13; /* filepositions String */\n    metadata_size += 2 + 5; /* times String */\n    metadata_size += 3; /* Object end */\n\n    flv->keyframe_index_size = metadata_size;\n\n    if (metadata_size < 0)\n        return metadata_size;\n\n    buf = av_malloc_array(metadata_size, 2);\n    if (!buf) {\n        return AVERROR(ENOMEM);\n    }\n    read_buf[0] = buf;\n    read_buf[1] = buf + metadata_size;\n\n    avio_seek(s->pb, flv->metadata_size_pos, SEEK_SET);\n    avio_wb24(s->pb, flv->metadata_totalsize + metadata_size);\n\n    avio_seek(s->pb, flv->metadata_totalsize_pos, SEEK_SET);\n    avio_wb32(s->pb, flv->metadata_totalsize + 11 + metadata_size);\n    avio_seek(s->pb, pos_end, SEEK_SET);\n\n    /* Shift the data: the AVIO context of the output can only be used for\n     * writing, so we re-open the same output, but for reading. It also avoids\n     * a read/seek/write/seek back and forth. */\n    avio_flush(s->pb);\n    ret = s->io_open(s, &read_pb, s->url, AVIO_FLAG_READ, NULL);\n    if (ret < 0) {\n        av_log(s, AV_LOG_ERROR, \"Unable to re-open %s output file for \"\n               \"the second pass (add_keyframe_index)\\n\", s->url);\n        goto end;\n    }\n\n    /* mark the end of the shift to up to the last data we wrote, and get ready\n     * for writing */\n    pos_end = avio_tell(s->pb);\n    avio_seek(s->pb, flv->keyframes_info_offset + metadata_size, SEEK_SET);\n\n    /* start reading at where the keyframe index information will be placed */\n    avio_seek(read_pb, flv->keyframes_info_offset, SEEK_SET);\n    pos = avio_tell(read_pb);\n\n#define READ_BLOCK do {                                                             \\\n    read_size[read_buf_id] = avio_read(read_pb, read_buf[read_buf_id], metadata_size);  \\\n    read_buf_id ^= 1;                                                               \\\n} while (0)\n\n    /* shift data by chunk of at most keyframe *filepositions* and *times* size */\n    READ_BLOCK;\n    do {\n        READ_BLOCK;\n        n = read_size[read_buf_id];\n        if (n < 0)\n            break;\n        avio_write(s->pb, read_buf[read_buf_id], n);\n        pos += n;\n    } while (pos <= pos_end);\n\n    ff_format_io_close(s, &read_pb);\n\nend:\n    av_free(buf);\n    return ret;\n}\n\n\nstatic int flv_write_header(AVFormatContext *s)\n{\n    int i;\n    AVIOContext *pb = s->pb;\n    FLVContext *flv = s->priv_data;\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVCodecParameters *par = s->streams[i]->codecpar;\n        FLVStreamContext *sc;\n        switch (par->codec_type) {\n        case AVMEDIA_TYPE_VIDEO:\n            if (s->streams[i]->avg_frame_rate.den &&\n                s->streams[i]->avg_frame_rate.num) {\n                flv->framerate = av_q2d(s->streams[i]->avg_frame_rate);\n            }\n            if (flv->video_par) {\n                av_log(s, AV_LOG_ERROR,\n                       \"at most one video stream is supported in flv\\n\");\n                return AVERROR(EINVAL);\n            }\n            flv->video_par = par;\n            if (!ff_codec_get_tag(flv_video_codec_ids, par->codec_id))\n                return unsupported_codec(s, \"Video\", par->codec_id);\n\n            if (par->codec_id == AV_CODEC_ID_MPEG4 ||\n                par->codec_id == AV_CODEC_ID_H263) {\n                int error = s->strict_std_compliance > FF_COMPLIANCE_UNOFFICIAL;\n                av_log(s, error ? AV_LOG_ERROR : AV_LOG_WARNING,\n                       \"Codec %s is not supported in the official FLV specification,\\n\", avcodec_get_name(par->codec_id));\n\n                if (error) {\n                    av_log(s, AV_LOG_ERROR,\n                           \"use vstrict=-1 / -strict -1 to use it anyway.\\n\");\n                    return AVERROR(EINVAL);\n                }\n            } else if (par->codec_id == AV_CODEC_ID_VP6) {\n                av_log(s, AV_LOG_WARNING,\n                       \"Muxing VP6 in flv will produce flipped video on playback.\\n\");\n            }\n            break;\n        case AVMEDIA_TYPE_AUDIO:\n            if (flv->audio_par) {\n                av_log(s, AV_LOG_ERROR,\n                       \"at most one audio stream is supported in flv\\n\");\n                return AVERROR(EINVAL);\n            }\n            flv->audio_par = par;\n            if (get_audio_flags(s, par) < 0)\n                return unsupported_codec(s, \"Audio\", par->codec_id);\n            if (par->codec_id == AV_CODEC_ID_PCM_S16BE)\n                av_log(s, AV_LOG_WARNING,\n                       \"16-bit big-endian audio in flv is valid but most likely unplayable (hardware dependent); use s16le\\n\");\n            break;\n        case AVMEDIA_TYPE_DATA:\n            if (par->codec_id != AV_CODEC_ID_TEXT && par->codec_id != AV_CODEC_ID_NONE)\n                return unsupported_codec(s, \"Data\", par->codec_id);\n            flv->data_par = par;\n            break;\n        case AVMEDIA_TYPE_SUBTITLE:\n            if (par->codec_id != AV_CODEC_ID_TEXT) {\n                av_log(s, AV_LOG_ERROR, \"Subtitle codec '%s' for stream %d is not compatible with FLV\\n\",\n                       avcodec_get_name(par->codec_id), i);\n                return AVERROR_INVALIDDATA;\n            }\n            flv->data_par = par;\n            break;\n        default:\n            av_log(s, AV_LOG_ERROR, \"Codec type '%s' for stream %d is not compatible with FLV\\n\",\n                   av_get_media_type_string(par->codec_type), i);\n            return AVERROR(EINVAL);\n        }\n        avpriv_set_pts_info(s->streams[i], 32, 1, 1000); /* 32 bit pts in ms */\n\n        sc = av_mallocz(sizeof(FLVStreamContext));\n        if (!sc)\n            return AVERROR(ENOMEM);\n        s->streams[i]->priv_data = sc;\n        sc->last_ts = -1;\n    }\n\n    flv->delay = AV_NOPTS_VALUE;\n\n    avio_write(pb, \"FLV\", 3);\n    avio_w8(pb, 1);\n    avio_w8(pb, FLV_HEADER_FLAG_HASAUDIO * !!flv->audio_par +\n                FLV_HEADER_FLAG_HASVIDEO * !!flv->video_par);\n    avio_wb32(pb, 9);\n    avio_wb32(pb, 0);\n\n    for (i = 0; i < s->nb_streams; i++)\n        if (s->streams[i]->codecpar->codec_tag == 5) {\n            avio_w8(pb, 8);     // message type\n            avio_wb24(pb, 0);   // include flags\n            avio_wb24(pb, 0);   // time stamp\n            avio_wb32(pb, 0);   // reserved\n            avio_wb32(pb, 11);  // size\n            flv->reserved = 5;\n        }\n\n    if (flv->flags & FLV_NO_METADATA) {\n        pb->seekable = 0;\n    } else {\n        write_metadata(s, 0);\n    }\n\n    for (i = 0; i < s->nb_streams; i++) {\n        flv_write_codec_header(s, s->streams[i]->codecpar, 0);\n    }\n\n    flv->datastart_offset = avio_tell(pb);\n    return 0;\n}\n\nstatic int flv_write_trailer(AVFormatContext *s)\n{\n    int64_t file_size;\n    AVIOContext *pb = s->pb;\n    FLVContext *flv = s->priv_data;\n    int build_keyframes_idx = flv->flags & FLV_ADD_KEYFRAME_INDEX;\n    int i, res;\n    int64_t cur_pos = avio_tell(s->pb);\n\n    if (build_keyframes_idx) {\n        FLVFileposition *newflv_posinfo, *p;\n\n        avio_seek(pb, flv->videosize_offset, SEEK_SET);\n        put_amf_double(pb, flv->videosize);\n\n        avio_seek(pb, flv->audiosize_offset, SEEK_SET);\n        put_amf_double(pb, flv->audiosize);\n\n        avio_seek(pb, flv->lasttimestamp_offset, SEEK_SET);\n        put_amf_double(pb, flv->lasttimestamp);\n\n        avio_seek(pb, flv->lastkeyframetimestamp_offset, SEEK_SET);\n        put_amf_double(pb, flv->lastkeyframetimestamp);\n\n        avio_seek(pb, flv->lastkeyframelocation_offset, SEEK_SET);\n        put_amf_double(pb, flv->lastkeyframelocation + flv->keyframe_index_size);\n        avio_seek(pb, cur_pos, SEEK_SET);\n\n        res = shift_data(s);\n        if (res < 0) {\n             goto end;\n        }\n        avio_seek(pb, flv->keyframes_info_offset, SEEK_SET);\n        put_amf_string(pb, \"filepositions\");\n        put_amf_dword_array(pb, flv->filepositions_count);\n        for (newflv_posinfo = flv->head_filepositions; newflv_posinfo; newflv_posinfo = newflv_posinfo->next) {\n            put_amf_double(pb, newflv_posinfo->keyframe_position + flv->keyframe_index_size);\n        }\n\n        put_amf_string(pb, \"times\");\n        put_amf_dword_array(pb, flv->filepositions_count);\n        for (newflv_posinfo = flv->head_filepositions; newflv_posinfo; newflv_posinfo = newflv_posinfo->next) {\n            put_amf_double(pb, newflv_posinfo->keyframe_timestamp);\n        }\n\n        newflv_posinfo = flv->head_filepositions;\n        while (newflv_posinfo) {\n            p = newflv_posinfo->next;\n            if (p) {\n                newflv_posinfo->next = p->next;\n                av_free(p);\n                p = NULL;\n            } else {\n                av_free(newflv_posinfo);\n                newflv_posinfo = NULL;\n            }\n        }\n\n        put_amf_string(pb, \"\");\n        avio_w8(pb, AMF_END_OF_OBJECT);\n\n        avio_seek(pb, cur_pos + flv->keyframe_index_size, SEEK_SET);\n    }\n\nend:\n    if (flv->flags & FLV_NO_SEQUENCE_END) {\n        av_log(s, AV_LOG_DEBUG, \"FLV no sequence end mode open\\n\");\n    } else {\n        /* Add EOS tag */\n        for (i = 0; i < s->nb_streams; i++) {\n            AVCodecParameters *par = s->streams[i]->codecpar;\n            FLVStreamContext *sc = s->streams[i]->priv_data;\n            if (par->codec_type == AVMEDIA_TYPE_VIDEO &&\n                    (par->codec_id == AV_CODEC_ID_H264 || par->codec_id == AV_CODEC_ID_MPEG4))\n                put_avc_eos_tag(pb, sc->last_ts);\n        }\n    }\n\n    file_size = avio_tell(pb);\n\n    if (build_keyframes_idx) {\n        flv->datasize = file_size - flv->datastart_offset;\n        avio_seek(pb, flv->datasize_offset, SEEK_SET);\n        put_amf_double(pb, flv->datasize);\n    }\n    if (!(flv->flags & FLV_NO_METADATA)) {\n        if (!(flv->flags & FLV_NO_DURATION_FILESIZE)) {\n            /* update information */\n            if (avio_seek(pb, flv->duration_offset, SEEK_SET) < 0) {\n                av_log(s, AV_LOG_WARNING, \"Failed to update header with correct duration.\\n\");\n            } else {\n                put_amf_double(pb, flv->duration / (double)1000);\n            }\n            if (avio_seek(pb, flv->filesize_offset, SEEK_SET) < 0) {\n                av_log(s, AV_LOG_WARNING, \"Failed to update header with correct filesize.\\n\");\n            } else {\n                put_amf_double(pb, file_size);\n            }\n        }\n    }\n\n    return 0;\n}\n\nstatic int flv_write_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    AVIOContext *pb      = s->pb;\n    AVCodecParameters *par = s->streams[pkt->stream_index]->codecpar;\n    FLVContext *flv      = s->priv_data;\n    FLVStreamContext *sc = s->streams[pkt->stream_index]->priv_data;\n    unsigned ts;\n    int size = pkt->size;\n    uint8_t *data = NULL;\n    int flags = -1, flags_size, ret;\n    int64_t cur_offset = avio_tell(pb);\n\n    if (par->codec_id == AV_CODEC_ID_VP6F || par->codec_id == AV_CODEC_ID_VP6A ||\n        par->codec_id == AV_CODEC_ID_VP6  || par->codec_id == AV_CODEC_ID_AAC)\n        flags_size = 2;\n    else if (par->codec_id == AV_CODEC_ID_H264 || par->codec_id == AV_CODEC_ID_MPEG4)\n        flags_size = 5;\n    else\n        flags_size = 1;\n\n    if (par->codec_id == AV_CODEC_ID_AAC || par->codec_id == AV_CODEC_ID_H264\n            || par->codec_id == AV_CODEC_ID_MPEG4) {\n        int side_size = 0;\n        uint8_t *side = av_packet_get_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA, &side_size);\n        if (side && side_size > 0 && (side_size != par->extradata_size || memcmp(side, par->extradata, side_size))) {\n            av_free(par->extradata);\n            par->extradata = av_mallocz(side_size + AV_INPUT_BUFFER_PADDING_SIZE);\n            if (!par->extradata) {\n                par->extradata_size = 0;\n                return AVERROR(ENOMEM);\n            }\n            memcpy(par->extradata, side, side_size);\n            par->extradata_size = side_size;\n            flv_write_codec_header(s, par, pkt->dts);\n        }\n    }\n\n    if (flv->delay == AV_NOPTS_VALUE)\n        flv->delay = -pkt->dts;\n\n    if (pkt->dts < -flv->delay) {\n        av_log(s, AV_LOG_WARNING,\n               \"Packets are not in the proper order with respect to DTS\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    ts = pkt->dts;\n\n    if (s->event_flags & AVSTREAM_EVENT_FLAG_METADATA_UPDATED) {\n        write_metadata(s, ts);\n        s->event_flags &= ~AVSTREAM_EVENT_FLAG_METADATA_UPDATED;\n    }\n\n    avio_write_marker(pb, av_rescale(ts, AV_TIME_BASE, 1000),\n                      pkt->flags & AV_PKT_FLAG_KEY && (flv->video_par ? par->codec_type == AVMEDIA_TYPE_VIDEO : 1) ? AVIO_DATA_MARKER_SYNC_POINT : AVIO_DATA_MARKER_BOUNDARY_POINT);\n\n    switch (par->codec_type) {\n    case AVMEDIA_TYPE_VIDEO:\n        avio_w8(pb, FLV_TAG_TYPE_VIDEO);\n\n        flags = ff_codec_get_tag(flv_video_codec_ids, par->codec_id);\n\n        flags |= pkt->flags & AV_PKT_FLAG_KEY ? FLV_FRAME_KEY : FLV_FRAME_INTER;\n        break;\n    case AVMEDIA_TYPE_AUDIO:\n        flags = get_audio_flags(s, par);\n\n        av_assert0(size);\n\n        avio_w8(pb, FLV_TAG_TYPE_AUDIO);\n        break;\n    case AVMEDIA_TYPE_SUBTITLE:\n    case AVMEDIA_TYPE_DATA:\n        avio_w8(pb, FLV_TAG_TYPE_META);\n        break;\n    default:\n        return AVERROR(EINVAL);\n    }\n\n    if (par->codec_id == AV_CODEC_ID_H264 || par->codec_id == AV_CODEC_ID_MPEG4) {\n        /* check if extradata looks like mp4 formatted */\n        if (par->extradata_size > 0 && *(uint8_t*)par->extradata != 1)\n            if ((ret = ff_avc_parse_nal_units_buf(pkt->data, &data, &size)) < 0)\n                return ret;\n    } else if (par->codec_id == AV_CODEC_ID_AAC && pkt->size > 2 &&\n               (AV_RB16(pkt->data) & 0xfff0) == 0xfff0) {\n        if (!s->streams[pkt->stream_index]->nb_frames) {\n        av_log(s, AV_LOG_ERROR, \"Malformed AAC bitstream detected: \"\n               \"use the audio bitstream filter 'aac_adtstoasc' to fix it \"\n               \"('-bsf:a aac_adtstoasc' option with ffmpeg)\\n\");\n        return AVERROR_INVALIDDATA;\n        }\n        av_log(s, AV_LOG_WARNING, \"aac bitstream error\\n\");\n    }\n\n    /* check Speex packet duration */\n    if (par->codec_id == AV_CODEC_ID_SPEEX && ts - sc->last_ts > 160)\n        av_log(s, AV_LOG_WARNING, \"Warning: Speex stream has more than \"\n                                  \"8 frames per packet. Adobe Flash \"\n                                  \"Player cannot handle this!\\n\");\n\n    if (sc->last_ts < ts)\n        sc->last_ts = ts;\n\n    if (size + flags_size >= 1<<24) {\n        av_log(s, AV_LOG_ERROR, \"Too large packet with size %u >= %u\\n\",\n               size + flags_size, 1<<24);\n        return AVERROR(EINVAL);\n    }\n\n    avio_wb24(pb, size + flags_size);\n    put_timestamp(pb, ts);\n    avio_wb24(pb, flv->reserved);\n\n    if (par->codec_type == AVMEDIA_TYPE_DATA ||\n        par->codec_type == AVMEDIA_TYPE_SUBTITLE ) {\n        int data_size;\n        int64_t metadata_size_pos = avio_tell(pb);\n        if (par->codec_id == AV_CODEC_ID_TEXT) {\n            // legacy FFmpeg magic?\n            avio_w8(pb, AMF_DATA_TYPE_STRING);\n            put_amf_string(pb, \"onTextData\");\n            avio_w8(pb, AMF_DATA_TYPE_MIXEDARRAY);\n            avio_wb32(pb, 2);\n            put_amf_string(pb, \"type\");\n            avio_w8(pb, AMF_DATA_TYPE_STRING);\n            put_amf_string(pb, \"Text\");\n            put_amf_string(pb, \"text\");\n            avio_w8(pb, AMF_DATA_TYPE_STRING);\n            put_amf_string(pb, pkt->data);\n            put_amf_string(pb, \"\");\n            avio_w8(pb, AMF_END_OF_OBJECT);\n        } else {\n            // just pass the metadata through\n            avio_write(pb, data ? data : pkt->data, size);\n        }\n        /* write total size of tag */\n        data_size = avio_tell(pb) - metadata_size_pos;\n        avio_seek(pb, metadata_size_pos - 10, SEEK_SET);\n        avio_wb24(pb, data_size);\n        avio_seek(pb, data_size + 10 - 3, SEEK_CUR);\n        avio_wb32(pb, data_size + 11);\n    } else {\n        av_assert1(flags>=0);\n        avio_w8(pb,flags);\n        if (par->codec_id == AV_CODEC_ID_VP6)\n            avio_w8(pb,0);\n        if (par->codec_id == AV_CODEC_ID_VP6F || par->codec_id == AV_CODEC_ID_VP6A) {\n            if (par->extradata_size)\n                avio_w8(pb, par->extradata[0]);\n            else\n                avio_w8(pb, ((FFALIGN(par->width,  16) - par->width) << 4) |\n                             (FFALIGN(par->height, 16) - par->height));\n        } else if (par->codec_id == AV_CODEC_ID_AAC)\n            avio_w8(pb, 1); // AAC raw\n        else if (par->codec_id == AV_CODEC_ID_H264 || par->codec_id == AV_CODEC_ID_MPEG4) {\n            avio_w8(pb, 1); // AVC NALU\n            avio_wb24(pb, pkt->pts - pkt->dts);\n        }\n\n        avio_write(pb, data ? data : pkt->data, size);\n\n        avio_wb32(pb, size + flags_size + 11); // previous tag size\n        flv->duration = FFMAX(flv->duration,\n                              pkt->pts + flv->delay + pkt->duration);\n    }\n\n    if (flv->flags & FLV_ADD_KEYFRAME_INDEX) {\n        switch (par->codec_type) {\n            case AVMEDIA_TYPE_VIDEO:\n                flv->videosize += (avio_tell(pb) - cur_offset);\n                flv->lasttimestamp = flv->acurframeindex / flv->framerate;\n                if (pkt->flags & AV_PKT_FLAG_KEY) {\n                    double ts = flv->acurframeindex / flv->framerate;\n                    int64_t pos = cur_offset;\n\n                    flv->lastkeyframetimestamp = flv->acurframeindex / flv->framerate;\n                    flv->lastkeyframelocation = pos;\n                    flv_append_keyframe_info(s, flv, ts, pos);\n                }\n                flv->acurframeindex++;\n                break;\n\n            case AVMEDIA_TYPE_AUDIO:\n                flv->audiosize += (avio_tell(pb) - cur_offset);\n                break;\n\n            default:\n                av_log(s, AV_LOG_WARNING, \"par->codec_type is type = [%d]\\n\", par->codec_type);\n                break;\n        }\n    }\n\n    av_free(data);\n\n    return pb->error;\n}\n\nstatic const AVOption options[] = {\n    { \"flvflags\", \"FLV muxer flags\", offsetof(FLVContext, flags), AV_OPT_TYPE_FLAGS, {.i64 = 0}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"flvflags\" },\n    { \"aac_seq_header_detect\", \"Put AAC sequence header based on stream data\", 0, AV_OPT_TYPE_CONST, {.i64 = FLV_AAC_SEQ_HEADER_DETECT}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"flvflags\" },\n    { \"no_sequence_end\", \"disable sequence end for FLV\", 0, AV_OPT_TYPE_CONST, {.i64 = FLV_NO_SEQUENCE_END}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"flvflags\" },\n    { \"no_metadata\", \"disable metadata for FLV\", 0, AV_OPT_TYPE_CONST, {.i64 = FLV_NO_METADATA}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"flvflags\" },\n    { \"no_duration_filesize\", \"disable duration and filesize zero value metadata for FLV\", 0, AV_OPT_TYPE_CONST, {.i64 = FLV_NO_DURATION_FILESIZE}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"flvflags\" },\n    { \"add_keyframe_index\", \"Add keyframe index metadata\", 0, AV_OPT_TYPE_CONST, {.i64 = FLV_ADD_KEYFRAME_INDEX}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"flvflags\" },\n    { NULL },\n};\n\nstatic const AVClass flv_muxer_class = {\n    .class_name = \"flv muxer\",\n    .item_name  = av_default_item_name,\n    .option     = options,\n    .version    = LIBAVUTIL_VERSION_INT,\n};\n\nAVOutputFormat ff_flv_muxer = {\n    .name           = \"flv\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"FLV (Flash Video)\"),\n    .mime_type      = \"video/x-flv\",\n    .extensions     = \"flv\",\n    .priv_data_size = sizeof(FLVContext),\n    .audio_codec    = CONFIG_LIBMP3LAME ? AV_CODEC_ID_MP3 : AV_CODEC_ID_ADPCM_SWF,\n    .video_codec    = AV_CODEC_ID_FLV1,\n    .write_header   = flv_write_header,\n    .write_packet   = flv_write_packet,\n    .write_trailer  = flv_write_trailer,\n    .codec_tag      = (const AVCodecTag* const []) {\n                          flv_video_codec_ids, flv_audio_codec_ids, 0\n                      },\n    .flags          = AVFMT_GLOBALHEADER | AVFMT_VARIABLE_FPS |\n                      AVFMT_TS_NONSTRICT,\n    .priv_class     = &flv_muxer_class,\n};\n"], "fixing_code": ["/*\n * FLV muxer\n * Copyright (c) 2003 The FFmpeg Project\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/dict.h\"\n#include \"libavutil/intfloat.h\"\n#include \"libavutil/avassert.h\"\n#include \"libavutil/mathematics.h\"\n#include \"avio_internal.h\"\n#include \"avio.h\"\n#include \"avc.h\"\n#include \"avformat.h\"\n#include \"flv.h\"\n#include \"internal.h\"\n#include \"metadata.h\"\n#include \"libavutil/opt.h\"\n#include \"libavcodec/put_bits.h\"\n#include \"libavcodec/aacenctab.h\"\n\n\nstatic const AVCodecTag flv_video_codec_ids[] = {\n    { AV_CODEC_ID_FLV1,     FLV_CODECID_H263 },\n    { AV_CODEC_ID_H263,     FLV_CODECID_REALH263 },\n    { AV_CODEC_ID_MPEG4,    FLV_CODECID_MPEG4 },\n    { AV_CODEC_ID_FLASHSV,  FLV_CODECID_SCREEN },\n    { AV_CODEC_ID_FLASHSV2, FLV_CODECID_SCREEN2 },\n    { AV_CODEC_ID_VP6F,     FLV_CODECID_VP6 },\n    { AV_CODEC_ID_VP6,      FLV_CODECID_VP6 },\n    { AV_CODEC_ID_VP6A,     FLV_CODECID_VP6A },\n    { AV_CODEC_ID_H264,     FLV_CODECID_H264 },\n    { AV_CODEC_ID_NONE,     0 }\n};\n\nstatic const AVCodecTag flv_audio_codec_ids[] = {\n    { AV_CODEC_ID_MP3,        FLV_CODECID_MP3        >> FLV_AUDIO_CODECID_OFFSET },\n    { AV_CODEC_ID_PCM_U8,     FLV_CODECID_PCM        >> FLV_AUDIO_CODECID_OFFSET },\n    { AV_CODEC_ID_PCM_S16BE,  FLV_CODECID_PCM        >> FLV_AUDIO_CODECID_OFFSET },\n    { AV_CODEC_ID_PCM_S16LE,  FLV_CODECID_PCM_LE     >> FLV_AUDIO_CODECID_OFFSET },\n    { AV_CODEC_ID_ADPCM_SWF,  FLV_CODECID_ADPCM      >> FLV_AUDIO_CODECID_OFFSET },\n    { AV_CODEC_ID_AAC,        FLV_CODECID_AAC        >> FLV_AUDIO_CODECID_OFFSET },\n    { AV_CODEC_ID_NELLYMOSER, FLV_CODECID_NELLYMOSER >> FLV_AUDIO_CODECID_OFFSET },\n    { AV_CODEC_ID_PCM_MULAW,  FLV_CODECID_PCM_MULAW  >> FLV_AUDIO_CODECID_OFFSET },\n    { AV_CODEC_ID_PCM_ALAW,   FLV_CODECID_PCM_ALAW   >> FLV_AUDIO_CODECID_OFFSET },\n    { AV_CODEC_ID_SPEEX,      FLV_CODECID_SPEEX      >> FLV_AUDIO_CODECID_OFFSET },\n    { AV_CODEC_ID_NONE,       0 }\n};\n\ntypedef enum {\n    FLV_AAC_SEQ_HEADER_DETECT = (1 << 0),\n    FLV_NO_SEQUENCE_END = (1 << 1),\n    FLV_ADD_KEYFRAME_INDEX = (1 << 2),\n    FLV_NO_METADATA = (1 << 3),\n    FLV_NO_DURATION_FILESIZE = (1 << 4),\n} FLVFlags;\n\ntypedef struct FLVFileposition {\n    int64_t keyframe_position;\n    double keyframe_timestamp;\n    struct FLVFileposition *next;\n} FLVFileposition;\n\ntypedef struct FLVContext {\n    AVClass *av_class;\n    int     reserved;\n    int64_t duration_offset;\n    int64_t filesize_offset;\n    int64_t duration;\n    int64_t delay;      ///< first dts delay (needed for AVC & Speex)\n\n    int64_t datastart_offset;\n    int64_t datasize_offset;\n    int64_t datasize;\n    int64_t videosize_offset;\n    int64_t videosize;\n    int64_t audiosize_offset;\n    int64_t audiosize;\n\n    int64_t metadata_size_pos;\n    int64_t metadata_totalsize_pos;\n    int64_t metadata_totalsize;\n    int64_t keyframe_index_size;\n\n    int64_t lasttimestamp_offset;\n    double lasttimestamp;\n    int64_t lastkeyframetimestamp_offset;\n    double lastkeyframetimestamp;\n    int64_t lastkeyframelocation_offset;\n    int64_t lastkeyframelocation;\n\n    int acurframeindex;\n    int64_t keyframes_info_offset;\n\n    int64_t filepositions_count;\n    FLVFileposition *filepositions;\n    FLVFileposition *head_filepositions;\n\n    AVCodecParameters *audio_par;\n    AVCodecParameters *video_par;\n    double framerate;\n    AVCodecParameters *data_par;\n\n    int flags;\n} FLVContext;\n\ntypedef struct FLVStreamContext {\n    int64_t last_ts;    ///< last timestamp for each stream\n} FLVStreamContext;\n\nstatic int get_audio_flags(AVFormatContext *s, AVCodecParameters *par)\n{\n    int flags = (par->bits_per_coded_sample == 16) ? FLV_SAMPLESSIZE_16BIT\n                                                   : FLV_SAMPLESSIZE_8BIT;\n\n    if (par->codec_id == AV_CODEC_ID_AAC) // specs force these parameters\n        return FLV_CODECID_AAC | FLV_SAMPLERATE_44100HZ |\n               FLV_SAMPLESSIZE_16BIT | FLV_STEREO;\n    else if (par->codec_id == AV_CODEC_ID_SPEEX) {\n        if (par->sample_rate != 16000) {\n            av_log(s, AV_LOG_ERROR,\n                   \"FLV only supports wideband (16kHz) Speex audio\\n\");\n            return AVERROR(EINVAL);\n        }\n        if (par->channels != 1) {\n            av_log(s, AV_LOG_ERROR, \"FLV only supports mono Speex audio\\n\");\n            return AVERROR(EINVAL);\n        }\n        return FLV_CODECID_SPEEX | FLV_SAMPLERATE_11025HZ | FLV_SAMPLESSIZE_16BIT;\n    } else {\n        switch (par->sample_rate) {\n        case 48000:\n            // 48khz mp3 is stored with 44k1 samplerate identifer\n            if (par->codec_id == AV_CODEC_ID_MP3) {\n                flags |= FLV_SAMPLERATE_44100HZ;\n                break;\n            } else {\n                goto error;\n            }\n        case 44100:\n            flags |= FLV_SAMPLERATE_44100HZ;\n            break;\n        case 22050:\n            flags |= FLV_SAMPLERATE_22050HZ;\n            break;\n        case 11025:\n            flags |= FLV_SAMPLERATE_11025HZ;\n            break;\n        case 16000: // nellymoser only\n        case  8000: // nellymoser only\n        case  5512: // not MP3\n            if (par->codec_id != AV_CODEC_ID_MP3) {\n                flags |= FLV_SAMPLERATE_SPECIAL;\n                break;\n            }\n        default:\nerror:\n            av_log(s, AV_LOG_ERROR,\n                   \"FLV does not support sample rate %d, \"\n                   \"choose from (44100, 22050, 11025)\\n\", par->sample_rate);\n            return AVERROR(EINVAL);\n        }\n    }\n\n    if (par->channels > 1)\n        flags |= FLV_STEREO;\n\n    switch (par->codec_id) {\n    case AV_CODEC_ID_MP3:\n        flags |= FLV_CODECID_MP3    | FLV_SAMPLESSIZE_16BIT;\n        break;\n    case AV_CODEC_ID_PCM_U8:\n        flags |= FLV_CODECID_PCM    | FLV_SAMPLESSIZE_8BIT;\n        break;\n    case AV_CODEC_ID_PCM_S16BE:\n        flags |= FLV_CODECID_PCM    | FLV_SAMPLESSIZE_16BIT;\n        break;\n    case AV_CODEC_ID_PCM_S16LE:\n        flags |= FLV_CODECID_PCM_LE | FLV_SAMPLESSIZE_16BIT;\n        break;\n    case AV_CODEC_ID_ADPCM_SWF:\n        flags |= FLV_CODECID_ADPCM  | FLV_SAMPLESSIZE_16BIT;\n        break;\n    case AV_CODEC_ID_NELLYMOSER:\n        if (par->sample_rate == 8000)\n            flags |= FLV_CODECID_NELLYMOSER_8KHZ_MONO  | FLV_SAMPLESSIZE_16BIT;\n        else if (par->sample_rate == 16000)\n            flags |= FLV_CODECID_NELLYMOSER_16KHZ_MONO | FLV_SAMPLESSIZE_16BIT;\n        else\n            flags |= FLV_CODECID_NELLYMOSER            | FLV_SAMPLESSIZE_16BIT;\n        break;\n    case AV_CODEC_ID_PCM_MULAW:\n        flags = FLV_CODECID_PCM_MULAW | FLV_SAMPLERATE_SPECIAL | FLV_SAMPLESSIZE_16BIT;\n        break;\n    case AV_CODEC_ID_PCM_ALAW:\n        flags = FLV_CODECID_PCM_ALAW  | FLV_SAMPLERATE_SPECIAL | FLV_SAMPLESSIZE_16BIT;\n        break;\n    case 0:\n        flags |= par->codec_tag << 4;\n        break;\n    default:\n        av_log(s, AV_LOG_ERROR, \"Audio codec '%s' not compatible with FLV\\n\",\n               avcodec_get_name(par->codec_id));\n        return AVERROR(EINVAL);\n    }\n\n    return flags;\n}\n\nstatic void put_amf_string(AVIOContext *pb, const char *str)\n{\n    size_t len = strlen(str);\n    avio_wb16(pb, len);\n    avio_write(pb, str, len);\n}\n\n// FLV timestamps are 32 bits signed, RTMP timestamps should be 32-bit unsigned\nstatic void put_timestamp(AVIOContext *pb, int64_t ts) {\n    avio_wb24(pb, ts & 0xFFFFFF);\n    avio_w8(pb, (ts >> 24) & 0x7F);\n}\n\nstatic void put_avc_eos_tag(AVIOContext *pb, unsigned ts)\n{\n    avio_w8(pb, FLV_TAG_TYPE_VIDEO);\n    avio_wb24(pb, 5);               /* Tag Data Size */\n    put_timestamp(pb, ts);\n    avio_wb24(pb, 0);               /* StreamId = 0 */\n    avio_w8(pb, 23);                /* ub[4] FrameType = 1, ub[4] CodecId = 7 */\n    avio_w8(pb, 2);                 /* AVC end of sequence */\n    avio_wb24(pb, 0);               /* Always 0 for AVC EOS. */\n    avio_wb32(pb, 16);              /* Size of FLV tag */\n}\n\nstatic void put_amf_double(AVIOContext *pb, double d)\n{\n    avio_w8(pb, AMF_DATA_TYPE_NUMBER);\n    avio_wb64(pb, av_double2int(d));\n}\n\nstatic void put_amf_byte(AVIOContext *pb, unsigned char abyte)\n{\n    avio_w8(pb, abyte);\n}\n\nstatic void put_amf_dword_array(AVIOContext *pb, uint32_t dw)\n{\n    avio_w8(pb, AMF_DATA_TYPE_ARRAY);\n    avio_wb32(pb, dw);\n}\n\nstatic void put_amf_bool(AVIOContext *pb, int b)\n{\n    avio_w8(pb, AMF_DATA_TYPE_BOOL);\n    avio_w8(pb, !!b);\n}\n\nstatic void write_metadata(AVFormatContext *s, unsigned int ts)\n{\n    AVIOContext *pb = s->pb;\n    FLVContext *flv = s->priv_data;\n    int write_duration_filesize = !(flv->flags & FLV_NO_DURATION_FILESIZE);\n    int metadata_count = 0;\n    int64_t metadata_count_pos;\n    AVDictionaryEntry *tag = NULL;\n\n    /* write meta_tag */\n    avio_w8(pb, FLV_TAG_TYPE_META);            // tag type META\n    flv->metadata_size_pos = avio_tell(pb);\n    avio_wb24(pb, 0);           // size of data part (sum of all parts below)\n    avio_wb24(pb, ts);          // timestamp\n    avio_wb32(pb, 0);           // reserved\n\n    /* now data of data_size size */\n\n    /* first event name as a string */\n    avio_w8(pb, AMF_DATA_TYPE_STRING);\n    put_amf_string(pb, \"onMetaData\"); // 12 bytes\n\n    /* mixed array (hash) with size and string/type/data tuples */\n    avio_w8(pb, AMF_DATA_TYPE_MIXEDARRAY);\n    metadata_count_pos = avio_tell(pb);\n    metadata_count = 4 * !!flv->video_par +\n                     5 * !!flv->audio_par +\n                     1 * !!flv->data_par;\n    if (write_duration_filesize) {\n        metadata_count += 2; // +2 for duration and file size\n    }\n    avio_wb32(pb, metadata_count);\n\n    if (write_duration_filesize) {\n        put_amf_string(pb, \"duration\");\n        flv->duration_offset = avio_tell(pb);\n        // fill in the guessed duration, it'll be corrected later if incorrect\n        put_amf_double(pb, s->duration / AV_TIME_BASE);\n    }\n\n    if (flv->video_par) {\n        put_amf_string(pb, \"width\");\n        put_amf_double(pb, flv->video_par->width);\n\n        put_amf_string(pb, \"height\");\n        put_amf_double(pb, flv->video_par->height);\n\n        put_amf_string(pb, \"videodatarate\");\n        put_amf_double(pb, flv->video_par->bit_rate / 1024.0);\n\n        if (flv->framerate != 0.0) {\n            put_amf_string(pb, \"framerate\");\n            put_amf_double(pb, flv->framerate);\n            metadata_count++;\n        }\n\n        put_amf_string(pb, \"videocodecid\");\n        put_amf_double(pb, flv->video_par->codec_tag);\n    }\n\n    if (flv->audio_par) {\n        put_amf_string(pb, \"audiodatarate\");\n        put_amf_double(pb, flv->audio_par->bit_rate / 1024.0);\n\n        put_amf_string(pb, \"audiosamplerate\");\n        put_amf_double(pb, flv->audio_par->sample_rate);\n\n        put_amf_string(pb, \"audiosamplesize\");\n        put_amf_double(pb, flv->audio_par->codec_id == AV_CODEC_ID_PCM_U8 ? 8 : 16);\n\n        put_amf_string(pb, \"stereo\");\n        put_amf_bool(pb, flv->audio_par->channels == 2);\n\n        put_amf_string(pb, \"audiocodecid\");\n        put_amf_double(pb, flv->audio_par->codec_tag);\n    }\n\n    if (flv->data_par) {\n        put_amf_string(pb, \"datastream\");\n        put_amf_double(pb, 0.0);\n    }\n\n    ff_standardize_creation_time(s);\n    while ((tag = av_dict_get(s->metadata, \"\", tag, AV_DICT_IGNORE_SUFFIX))) {\n        if(   !strcmp(tag->key, \"width\")\n            ||!strcmp(tag->key, \"height\")\n            ||!strcmp(tag->key, \"videodatarate\")\n            ||!strcmp(tag->key, \"framerate\")\n            ||!strcmp(tag->key, \"videocodecid\")\n            ||!strcmp(tag->key, \"audiodatarate\")\n            ||!strcmp(tag->key, \"audiosamplerate\")\n            ||!strcmp(tag->key, \"audiosamplesize\")\n            ||!strcmp(tag->key, \"stereo\")\n            ||!strcmp(tag->key, \"audiocodecid\")\n            ||!strcmp(tag->key, \"duration\")\n            ||!strcmp(tag->key, \"onMetaData\")\n            ||!strcmp(tag->key, \"datasize\")\n            ||!strcmp(tag->key, \"lasttimestamp\")\n            ||!strcmp(tag->key, \"totalframes\")\n            ||!strcmp(tag->key, \"hasAudio\")\n            ||!strcmp(tag->key, \"hasVideo\")\n            ||!strcmp(tag->key, \"hasCuePoints\")\n            ||!strcmp(tag->key, \"hasMetadata\")\n            ||!strcmp(tag->key, \"hasKeyframes\")\n        ){\n            av_log(s, AV_LOG_DEBUG, \"Ignoring metadata for %s\\n\", tag->key);\n            continue;\n        }\n        put_amf_string(pb, tag->key);\n        avio_w8(pb, AMF_DATA_TYPE_STRING);\n        put_amf_string(pb, tag->value);\n        metadata_count++;\n    }\n\n    if (write_duration_filesize) {\n        put_amf_string(pb, \"filesize\");\n        flv->filesize_offset = avio_tell(pb);\n        put_amf_double(pb, 0); // delayed write\n    }\n\n    if (flv->flags & FLV_ADD_KEYFRAME_INDEX) {\n        flv->acurframeindex = 0;\n        flv->keyframe_index_size = 0;\n\n        put_amf_string(pb, \"hasVideo\");\n        put_amf_bool(pb, !!flv->video_par);\n        metadata_count++;\n\n        put_amf_string(pb, \"hasKeyframes\");\n        put_amf_bool(pb, 1);\n        metadata_count++;\n\n        put_amf_string(pb, \"hasAudio\");\n        put_amf_bool(pb, !!flv->audio_par);\n        metadata_count++;\n\n        put_amf_string(pb, \"hasMetadata\");\n        put_amf_bool(pb, 1);\n        metadata_count++;\n\n        put_amf_string(pb, \"canSeekToEnd\");\n        put_amf_bool(pb, 1);\n        metadata_count++;\n\n        put_amf_string(pb, \"datasize\");\n        flv->datasize_offset = avio_tell(pb);\n        flv->datasize = 0;\n        put_amf_double(pb, flv->datasize);\n        metadata_count++;\n\n        put_amf_string(pb, \"videosize\");\n        flv->videosize_offset = avio_tell(pb);\n        flv->videosize = 0;\n        put_amf_double(pb, flv->videosize);\n        metadata_count++;\n\n        put_amf_string(pb, \"audiosize\");\n        flv->audiosize_offset = avio_tell(pb);\n        flv->audiosize = 0;\n        put_amf_double(pb, flv->audiosize);\n        metadata_count++;\n\n        put_amf_string(pb, \"lasttimestamp\");\n        flv->lasttimestamp_offset = avio_tell(pb);\n        flv->lasttimestamp = 0;\n        put_amf_double(pb, 0);\n        metadata_count++;\n\n        put_amf_string(pb, \"lastkeyframetimestamp\");\n        flv->lastkeyframetimestamp_offset = avio_tell(pb);\n        flv->lastkeyframetimestamp = 0;\n        put_amf_double(pb, 0);\n        metadata_count++;\n\n        put_amf_string(pb, \"lastkeyframelocation\");\n        flv->lastkeyframelocation_offset = avio_tell(pb);\n        flv->lastkeyframelocation = 0;\n        put_amf_double(pb, 0);\n        metadata_count++;\n\n        put_amf_string(pb, \"keyframes\");\n        put_amf_byte(pb, AMF_DATA_TYPE_OBJECT);\n        metadata_count++;\n\n        flv->keyframes_info_offset = avio_tell(pb);\n    }\n\n    put_amf_string(pb, \"\");\n    avio_w8(pb, AMF_END_OF_OBJECT);\n\n    /* write total size of tag */\n    flv->metadata_totalsize = avio_tell(pb) - flv->metadata_size_pos - 10;\n\n    avio_seek(pb, metadata_count_pos, SEEK_SET);\n    avio_wb32(pb, metadata_count);\n\n    avio_seek(pb, flv->metadata_size_pos, SEEK_SET);\n    avio_wb24(pb, flv->metadata_totalsize);\n    avio_skip(pb, flv->metadata_totalsize + 10 - 3);\n    flv->metadata_totalsize_pos = avio_tell(pb);\n    avio_wb32(pb, flv->metadata_totalsize + 11);\n}\n\nstatic int unsupported_codec(AVFormatContext *s,\n                             const char* type, int codec_id)\n{\n    const AVCodecDescriptor *desc = avcodec_descriptor_get(codec_id);\n    av_log(s, AV_LOG_ERROR,\n           \"%s codec %s not compatible with flv\\n\",\n            type,\n            desc ? desc->name : \"unknown\");\n    return AVERROR(ENOSYS);\n}\n\nstatic void flv_write_codec_header(AVFormatContext* s, AVCodecParameters* par, int64_t ts) {\n    int64_t data_size;\n    AVIOContext *pb = s->pb;\n    FLVContext *flv = s->priv_data;\n\n    if (par->codec_id == AV_CODEC_ID_AAC || par->codec_id == AV_CODEC_ID_H264\n            || par->codec_id == AV_CODEC_ID_MPEG4) {\n        int64_t pos;\n        avio_w8(pb,\n                par->codec_type == AVMEDIA_TYPE_VIDEO ?\n                        FLV_TAG_TYPE_VIDEO : FLV_TAG_TYPE_AUDIO);\n        avio_wb24(pb, 0); // size patched later\n        put_timestamp(pb, ts);\n        avio_wb24(pb, 0); // streamid\n        pos = avio_tell(pb);\n        if (par->codec_id == AV_CODEC_ID_AAC) {\n            avio_w8(pb, get_audio_flags(s, par));\n            avio_w8(pb, 0); // AAC sequence header\n\n            if (!par->extradata_size && (flv->flags & FLV_AAC_SEQ_HEADER_DETECT)) {\n                PutBitContext pbc;\n                int samplerate_index;\n                int channels = flv->audio_par->channels\n                        - (flv->audio_par->channels == 8 ? 1 : 0);\n                uint8_t data[2];\n\n                for (samplerate_index = 0; samplerate_index < 16;\n                        samplerate_index++)\n                    if (flv->audio_par->sample_rate\n                            == mpeg4audio_sample_rates[samplerate_index])\n                        break;\n\n                init_put_bits(&pbc, data, sizeof(data));\n                put_bits(&pbc, 5, flv->audio_par->profile + 1); //profile\n                put_bits(&pbc, 4, samplerate_index); //sample rate index\n                put_bits(&pbc, 4, channels);\n                put_bits(&pbc, 1, 0); //frame length - 1024 samples\n                put_bits(&pbc, 1, 0); //does not depend on core coder\n                put_bits(&pbc, 1, 0); //is not extension\n                flush_put_bits(&pbc);\n\n                avio_w8(pb, data[0]);\n                avio_w8(pb, data[1]);\n\n                av_log(s, AV_LOG_WARNING, \"AAC sequence header: %02x %02x.\\n\",\n                        data[0], data[1]);\n            }\n            avio_write(pb, par->extradata, par->extradata_size);\n        } else {\n            avio_w8(pb, par->codec_tag | FLV_FRAME_KEY); // flags\n            avio_w8(pb, 0); // AVC sequence header\n            avio_wb24(pb, 0); // composition time\n            ff_isom_write_avcc(pb, par->extradata, par->extradata_size);\n        }\n        data_size = avio_tell(pb) - pos;\n        avio_seek(pb, -data_size - 10, SEEK_CUR);\n        avio_wb24(pb, data_size);\n        avio_skip(pb, data_size + 10 - 3);\n        avio_wb32(pb, data_size + 11); // previous tag size\n    }\n}\n\nstatic int flv_append_keyframe_info(AVFormatContext *s, FLVContext *flv, double ts, int64_t pos)\n{\n    FLVFileposition *position = av_malloc(sizeof(FLVFileposition));\n\n    if (!position) {\n        av_log(s, AV_LOG_WARNING, \"no mem for add keyframe index!\\n\");\n        return AVERROR(ENOMEM);\n    }\n\n    position->keyframe_timestamp = ts;\n    position->keyframe_position = pos;\n\n    if (!flv->filepositions_count) {\n        flv->filepositions = position;\n        flv->head_filepositions = flv->filepositions;\n        position->next = NULL;\n    } else {\n        flv->filepositions->next = position;\n        position->next = NULL;\n        flv->filepositions = flv->filepositions->next;\n    }\n\n    flv->filepositions_count++;\n\n    return 0;\n}\n\nstatic int shift_data(AVFormatContext *s)\n{\n    int ret = 0;\n    int n = 0;\n    int64_t metadata_size = 0;\n    FLVContext *flv = s->priv_data;\n    int64_t pos, pos_end = avio_tell(s->pb);\n    uint8_t *buf, *read_buf[2];\n    int read_buf_id = 0;\n    int read_size[2];\n    AVIOContext *read_pb;\n\n    metadata_size = flv->filepositions_count * 9 * 2 + 10; /* filepositions and times value */\n    metadata_size += 2 + 13; /* filepositions String */\n    metadata_size += 2 + 5; /* times String */\n    metadata_size += 3; /* Object end */\n\n    flv->keyframe_index_size = metadata_size;\n\n    if (metadata_size < 0)\n        return metadata_size;\n\n    buf = av_malloc_array(metadata_size, 2);\n    if (!buf) {\n        return AVERROR(ENOMEM);\n    }\n    read_buf[0] = buf;\n    read_buf[1] = buf + metadata_size;\n\n    avio_seek(s->pb, flv->metadata_size_pos, SEEK_SET);\n    avio_wb24(s->pb, flv->metadata_totalsize + metadata_size);\n\n    avio_seek(s->pb, flv->metadata_totalsize_pos, SEEK_SET);\n    avio_wb32(s->pb, flv->metadata_totalsize + 11 + metadata_size);\n    avio_seek(s->pb, pos_end, SEEK_SET);\n\n    /* Shift the data: the AVIO context of the output can only be used for\n     * writing, so we re-open the same output, but for reading. It also avoids\n     * a read/seek/write/seek back and forth. */\n    avio_flush(s->pb);\n    ret = s->io_open(s, &read_pb, s->url, AVIO_FLAG_READ, NULL);\n    if (ret < 0) {\n        av_log(s, AV_LOG_ERROR, \"Unable to re-open %s output file for \"\n               \"the second pass (add_keyframe_index)\\n\", s->url);\n        goto end;\n    }\n\n    /* mark the end of the shift to up to the last data we wrote, and get ready\n     * for writing */\n    pos_end = avio_tell(s->pb);\n    avio_seek(s->pb, flv->keyframes_info_offset + metadata_size, SEEK_SET);\n\n    /* start reading at where the keyframe index information will be placed */\n    avio_seek(read_pb, flv->keyframes_info_offset, SEEK_SET);\n    pos = avio_tell(read_pb);\n\n#define READ_BLOCK do {                                                             \\\n    read_size[read_buf_id] = avio_read(read_pb, read_buf[read_buf_id], metadata_size);  \\\n    read_buf_id ^= 1;                                                               \\\n} while (0)\n\n    /* shift data by chunk of at most keyframe *filepositions* and *times* size */\n    READ_BLOCK;\n    do {\n        READ_BLOCK;\n        n = read_size[read_buf_id];\n        if (n < 0)\n            break;\n        avio_write(s->pb, read_buf[read_buf_id], n);\n        pos += n;\n    } while (pos <= pos_end);\n\n    ff_format_io_close(s, &read_pb);\n\nend:\n    av_free(buf);\n    return ret;\n}\n\n\nstatic int flv_write_header(AVFormatContext *s)\n{\n    int i;\n    AVIOContext *pb = s->pb;\n    FLVContext *flv = s->priv_data;\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVCodecParameters *par = s->streams[i]->codecpar;\n        FLVStreamContext *sc;\n        switch (par->codec_type) {\n        case AVMEDIA_TYPE_VIDEO:\n            if (s->streams[i]->avg_frame_rate.den &&\n                s->streams[i]->avg_frame_rate.num) {\n                flv->framerate = av_q2d(s->streams[i]->avg_frame_rate);\n            }\n            if (flv->video_par) {\n                av_log(s, AV_LOG_ERROR,\n                       \"at most one video stream is supported in flv\\n\");\n                return AVERROR(EINVAL);\n            }\n            flv->video_par = par;\n            if (!ff_codec_get_tag(flv_video_codec_ids, par->codec_id))\n                return unsupported_codec(s, \"Video\", par->codec_id);\n\n            if (par->codec_id == AV_CODEC_ID_MPEG4 ||\n                par->codec_id == AV_CODEC_ID_H263) {\n                int error = s->strict_std_compliance > FF_COMPLIANCE_UNOFFICIAL;\n                av_log(s, error ? AV_LOG_ERROR : AV_LOG_WARNING,\n                       \"Codec %s is not supported in the official FLV specification,\\n\", avcodec_get_name(par->codec_id));\n\n                if (error) {\n                    av_log(s, AV_LOG_ERROR,\n                           \"use vstrict=-1 / -strict -1 to use it anyway.\\n\");\n                    return AVERROR(EINVAL);\n                }\n            } else if (par->codec_id == AV_CODEC_ID_VP6) {\n                av_log(s, AV_LOG_WARNING,\n                       \"Muxing VP6 in flv will produce flipped video on playback.\\n\");\n            }\n            break;\n        case AVMEDIA_TYPE_AUDIO:\n            if (flv->audio_par) {\n                av_log(s, AV_LOG_ERROR,\n                       \"at most one audio stream is supported in flv\\n\");\n                return AVERROR(EINVAL);\n            }\n            flv->audio_par = par;\n            if (get_audio_flags(s, par) < 0)\n                return unsupported_codec(s, \"Audio\", par->codec_id);\n            if (par->codec_id == AV_CODEC_ID_PCM_S16BE)\n                av_log(s, AV_LOG_WARNING,\n                       \"16-bit big-endian audio in flv is valid but most likely unplayable (hardware dependent); use s16le\\n\");\n            break;\n        case AVMEDIA_TYPE_DATA:\n            if (par->codec_id != AV_CODEC_ID_TEXT && par->codec_id != AV_CODEC_ID_NONE)\n                return unsupported_codec(s, \"Data\", par->codec_id);\n            flv->data_par = par;\n            break;\n        case AVMEDIA_TYPE_SUBTITLE:\n            if (par->codec_id != AV_CODEC_ID_TEXT) {\n                av_log(s, AV_LOG_ERROR, \"Subtitle codec '%s' for stream %d is not compatible with FLV\\n\",\n                       avcodec_get_name(par->codec_id), i);\n                return AVERROR_INVALIDDATA;\n            }\n            flv->data_par = par;\n            break;\n        default:\n            av_log(s, AV_LOG_ERROR, \"Codec type '%s' for stream %d is not compatible with FLV\\n\",\n                   av_get_media_type_string(par->codec_type), i);\n            return AVERROR(EINVAL);\n        }\n        avpriv_set_pts_info(s->streams[i], 32, 1, 1000); /* 32 bit pts in ms */\n\n        sc = av_mallocz(sizeof(FLVStreamContext));\n        if (!sc)\n            return AVERROR(ENOMEM);\n        s->streams[i]->priv_data = sc;\n        sc->last_ts = -1;\n    }\n\n    flv->delay = AV_NOPTS_VALUE;\n\n    avio_write(pb, \"FLV\", 3);\n    avio_w8(pb, 1);\n    avio_w8(pb, FLV_HEADER_FLAG_HASAUDIO * !!flv->audio_par +\n                FLV_HEADER_FLAG_HASVIDEO * !!flv->video_par);\n    avio_wb32(pb, 9);\n    avio_wb32(pb, 0);\n\n    for (i = 0; i < s->nb_streams; i++)\n        if (s->streams[i]->codecpar->codec_tag == 5) {\n            avio_w8(pb, 8);     // message type\n            avio_wb24(pb, 0);   // include flags\n            avio_wb24(pb, 0);   // time stamp\n            avio_wb32(pb, 0);   // reserved\n            avio_wb32(pb, 11);  // size\n            flv->reserved = 5;\n        }\n\n    if (flv->flags & FLV_NO_METADATA) {\n        pb->seekable = 0;\n    } else {\n        write_metadata(s, 0);\n    }\n\n    for (i = 0; i < s->nb_streams; i++) {\n        flv_write_codec_header(s, s->streams[i]->codecpar, 0);\n    }\n\n    flv->datastart_offset = avio_tell(pb);\n    return 0;\n}\n\nstatic int flv_write_trailer(AVFormatContext *s)\n{\n    int64_t file_size;\n    AVIOContext *pb = s->pb;\n    FLVContext *flv = s->priv_data;\n    int build_keyframes_idx = flv->flags & FLV_ADD_KEYFRAME_INDEX;\n    int i, res;\n    int64_t cur_pos = avio_tell(s->pb);\n\n    if (build_keyframes_idx) {\n        FLVFileposition *newflv_posinfo, *p;\n\n        avio_seek(pb, flv->videosize_offset, SEEK_SET);\n        put_amf_double(pb, flv->videosize);\n\n        avio_seek(pb, flv->audiosize_offset, SEEK_SET);\n        put_amf_double(pb, flv->audiosize);\n\n        avio_seek(pb, flv->lasttimestamp_offset, SEEK_SET);\n        put_amf_double(pb, flv->lasttimestamp);\n\n        avio_seek(pb, flv->lastkeyframetimestamp_offset, SEEK_SET);\n        put_amf_double(pb, flv->lastkeyframetimestamp);\n\n        avio_seek(pb, flv->lastkeyframelocation_offset, SEEK_SET);\n        put_amf_double(pb, flv->lastkeyframelocation + flv->keyframe_index_size);\n        avio_seek(pb, cur_pos, SEEK_SET);\n\n        res = shift_data(s);\n        if (res < 0) {\n             goto end;\n        }\n        avio_seek(pb, flv->keyframes_info_offset, SEEK_SET);\n        put_amf_string(pb, \"filepositions\");\n        put_amf_dword_array(pb, flv->filepositions_count);\n        for (newflv_posinfo = flv->head_filepositions; newflv_posinfo; newflv_posinfo = newflv_posinfo->next) {\n            put_amf_double(pb, newflv_posinfo->keyframe_position + flv->keyframe_index_size);\n        }\n\n        put_amf_string(pb, \"times\");\n        put_amf_dword_array(pb, flv->filepositions_count);\n        for (newflv_posinfo = flv->head_filepositions; newflv_posinfo; newflv_posinfo = newflv_posinfo->next) {\n            put_amf_double(pb, newflv_posinfo->keyframe_timestamp);\n        }\n\n        newflv_posinfo = flv->head_filepositions;\n        while (newflv_posinfo) {\n            p = newflv_posinfo->next;\n            if (p) {\n                newflv_posinfo->next = p->next;\n                av_free(p);\n                p = NULL;\n            } else {\n                av_free(newflv_posinfo);\n                newflv_posinfo = NULL;\n            }\n        }\n\n        put_amf_string(pb, \"\");\n        avio_w8(pb, AMF_END_OF_OBJECT);\n\n        avio_seek(pb, cur_pos + flv->keyframe_index_size, SEEK_SET);\n    }\n\nend:\n    if (flv->flags & FLV_NO_SEQUENCE_END) {\n        av_log(s, AV_LOG_DEBUG, \"FLV no sequence end mode open\\n\");\n    } else {\n        /* Add EOS tag */\n        for (i = 0; i < s->nb_streams; i++) {\n            AVCodecParameters *par = s->streams[i]->codecpar;\n            FLVStreamContext *sc = s->streams[i]->priv_data;\n            if (par->codec_type == AVMEDIA_TYPE_VIDEO &&\n                    (par->codec_id == AV_CODEC_ID_H264 || par->codec_id == AV_CODEC_ID_MPEG4))\n                put_avc_eos_tag(pb, sc->last_ts);\n        }\n    }\n\n    file_size = avio_tell(pb);\n\n    if (build_keyframes_idx) {\n        flv->datasize = file_size - flv->datastart_offset;\n        avio_seek(pb, flv->datasize_offset, SEEK_SET);\n        put_amf_double(pb, flv->datasize);\n    }\n    if (!(flv->flags & FLV_NO_METADATA)) {\n        if (!(flv->flags & FLV_NO_DURATION_FILESIZE)) {\n            /* update information */\n            if (avio_seek(pb, flv->duration_offset, SEEK_SET) < 0) {\n                av_log(s, AV_LOG_WARNING, \"Failed to update header with correct duration.\\n\");\n            } else {\n                put_amf_double(pb, flv->duration / (double)1000);\n            }\n            if (avio_seek(pb, flv->filesize_offset, SEEK_SET) < 0) {\n                av_log(s, AV_LOG_WARNING, \"Failed to update header with correct filesize.\\n\");\n            } else {\n                put_amf_double(pb, file_size);\n            }\n        }\n    }\n\n    return 0;\n}\n\nstatic int flv_write_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    AVIOContext *pb      = s->pb;\n    AVCodecParameters *par = s->streams[pkt->stream_index]->codecpar;\n    FLVContext *flv      = s->priv_data;\n    FLVStreamContext *sc = s->streams[pkt->stream_index]->priv_data;\n    unsigned ts;\n    int size = pkt->size;\n    uint8_t *data = NULL;\n    int flags = -1, flags_size, ret;\n    int64_t cur_offset = avio_tell(pb);\n\n    if (par->codec_type == AVMEDIA_TYPE_AUDIO && !pkt->size) {\n        av_log(s, AV_LOG_WARNING, \"Empty audio Packet\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    if (par->codec_id == AV_CODEC_ID_VP6F || par->codec_id == AV_CODEC_ID_VP6A ||\n        par->codec_id == AV_CODEC_ID_VP6  || par->codec_id == AV_CODEC_ID_AAC)\n        flags_size = 2;\n    else if (par->codec_id == AV_CODEC_ID_H264 || par->codec_id == AV_CODEC_ID_MPEG4)\n        flags_size = 5;\n    else\n        flags_size = 1;\n\n    if (par->codec_id == AV_CODEC_ID_AAC || par->codec_id == AV_CODEC_ID_H264\n            || par->codec_id == AV_CODEC_ID_MPEG4) {\n        int side_size = 0;\n        uint8_t *side = av_packet_get_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA, &side_size);\n        if (side && side_size > 0 && (side_size != par->extradata_size || memcmp(side, par->extradata, side_size))) {\n            av_free(par->extradata);\n            par->extradata = av_mallocz(side_size + AV_INPUT_BUFFER_PADDING_SIZE);\n            if (!par->extradata) {\n                par->extradata_size = 0;\n                return AVERROR(ENOMEM);\n            }\n            memcpy(par->extradata, side, side_size);\n            par->extradata_size = side_size;\n            flv_write_codec_header(s, par, pkt->dts);\n        }\n    }\n\n    if (flv->delay == AV_NOPTS_VALUE)\n        flv->delay = -pkt->dts;\n\n    if (pkt->dts < -flv->delay) {\n        av_log(s, AV_LOG_WARNING,\n               \"Packets are not in the proper order with respect to DTS\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    ts = pkt->dts;\n\n    if (s->event_flags & AVSTREAM_EVENT_FLAG_METADATA_UPDATED) {\n        write_metadata(s, ts);\n        s->event_flags &= ~AVSTREAM_EVENT_FLAG_METADATA_UPDATED;\n    }\n\n    avio_write_marker(pb, av_rescale(ts, AV_TIME_BASE, 1000),\n                      pkt->flags & AV_PKT_FLAG_KEY && (flv->video_par ? par->codec_type == AVMEDIA_TYPE_VIDEO : 1) ? AVIO_DATA_MARKER_SYNC_POINT : AVIO_DATA_MARKER_BOUNDARY_POINT);\n\n    switch (par->codec_type) {\n    case AVMEDIA_TYPE_VIDEO:\n        avio_w8(pb, FLV_TAG_TYPE_VIDEO);\n\n        flags = ff_codec_get_tag(flv_video_codec_ids, par->codec_id);\n\n        flags |= pkt->flags & AV_PKT_FLAG_KEY ? FLV_FRAME_KEY : FLV_FRAME_INTER;\n        break;\n    case AVMEDIA_TYPE_AUDIO:\n        flags = get_audio_flags(s, par);\n\n        av_assert0(size);\n\n        avio_w8(pb, FLV_TAG_TYPE_AUDIO);\n        break;\n    case AVMEDIA_TYPE_SUBTITLE:\n    case AVMEDIA_TYPE_DATA:\n        avio_w8(pb, FLV_TAG_TYPE_META);\n        break;\n    default:\n        return AVERROR(EINVAL);\n    }\n\n    if (par->codec_id == AV_CODEC_ID_H264 || par->codec_id == AV_CODEC_ID_MPEG4) {\n        /* check if extradata looks like mp4 formatted */\n        if (par->extradata_size > 0 && *(uint8_t*)par->extradata != 1)\n            if ((ret = ff_avc_parse_nal_units_buf(pkt->data, &data, &size)) < 0)\n                return ret;\n    } else if (par->codec_id == AV_CODEC_ID_AAC && pkt->size > 2 &&\n               (AV_RB16(pkt->data) & 0xfff0) == 0xfff0) {\n        if (!s->streams[pkt->stream_index]->nb_frames) {\n        av_log(s, AV_LOG_ERROR, \"Malformed AAC bitstream detected: \"\n               \"use the audio bitstream filter 'aac_adtstoasc' to fix it \"\n               \"('-bsf:a aac_adtstoasc' option with ffmpeg)\\n\");\n        return AVERROR_INVALIDDATA;\n        }\n        av_log(s, AV_LOG_WARNING, \"aac bitstream error\\n\");\n    }\n\n    /* check Speex packet duration */\n    if (par->codec_id == AV_CODEC_ID_SPEEX && ts - sc->last_ts > 160)\n        av_log(s, AV_LOG_WARNING, \"Warning: Speex stream has more than \"\n                                  \"8 frames per packet. Adobe Flash \"\n                                  \"Player cannot handle this!\\n\");\n\n    if (sc->last_ts < ts)\n        sc->last_ts = ts;\n\n    if (size + flags_size >= 1<<24) {\n        av_log(s, AV_LOG_ERROR, \"Too large packet with size %u >= %u\\n\",\n               size + flags_size, 1<<24);\n        return AVERROR(EINVAL);\n    }\n\n    avio_wb24(pb, size + flags_size);\n    put_timestamp(pb, ts);\n    avio_wb24(pb, flv->reserved);\n\n    if (par->codec_type == AVMEDIA_TYPE_DATA ||\n        par->codec_type == AVMEDIA_TYPE_SUBTITLE ) {\n        int data_size;\n        int64_t metadata_size_pos = avio_tell(pb);\n        if (par->codec_id == AV_CODEC_ID_TEXT) {\n            // legacy FFmpeg magic?\n            avio_w8(pb, AMF_DATA_TYPE_STRING);\n            put_amf_string(pb, \"onTextData\");\n            avio_w8(pb, AMF_DATA_TYPE_MIXEDARRAY);\n            avio_wb32(pb, 2);\n            put_amf_string(pb, \"type\");\n            avio_w8(pb, AMF_DATA_TYPE_STRING);\n            put_amf_string(pb, \"Text\");\n            put_amf_string(pb, \"text\");\n            avio_w8(pb, AMF_DATA_TYPE_STRING);\n            put_amf_string(pb, pkt->data);\n            put_amf_string(pb, \"\");\n            avio_w8(pb, AMF_END_OF_OBJECT);\n        } else {\n            // just pass the metadata through\n            avio_write(pb, data ? data : pkt->data, size);\n        }\n        /* write total size of tag */\n        data_size = avio_tell(pb) - metadata_size_pos;\n        avio_seek(pb, metadata_size_pos - 10, SEEK_SET);\n        avio_wb24(pb, data_size);\n        avio_seek(pb, data_size + 10 - 3, SEEK_CUR);\n        avio_wb32(pb, data_size + 11);\n    } else {\n        av_assert1(flags>=0);\n        avio_w8(pb,flags);\n        if (par->codec_id == AV_CODEC_ID_VP6)\n            avio_w8(pb,0);\n        if (par->codec_id == AV_CODEC_ID_VP6F || par->codec_id == AV_CODEC_ID_VP6A) {\n            if (par->extradata_size)\n                avio_w8(pb, par->extradata[0]);\n            else\n                avio_w8(pb, ((FFALIGN(par->width,  16) - par->width) << 4) |\n                             (FFALIGN(par->height, 16) - par->height));\n        } else if (par->codec_id == AV_CODEC_ID_AAC)\n            avio_w8(pb, 1); // AAC raw\n        else if (par->codec_id == AV_CODEC_ID_H264 || par->codec_id == AV_CODEC_ID_MPEG4) {\n            avio_w8(pb, 1); // AVC NALU\n            avio_wb24(pb, pkt->pts - pkt->dts);\n        }\n\n        avio_write(pb, data ? data : pkt->data, size);\n\n        avio_wb32(pb, size + flags_size + 11); // previous tag size\n        flv->duration = FFMAX(flv->duration,\n                              pkt->pts + flv->delay + pkt->duration);\n    }\n\n    if (flv->flags & FLV_ADD_KEYFRAME_INDEX) {\n        switch (par->codec_type) {\n            case AVMEDIA_TYPE_VIDEO:\n                flv->videosize += (avio_tell(pb) - cur_offset);\n                flv->lasttimestamp = flv->acurframeindex / flv->framerate;\n                if (pkt->flags & AV_PKT_FLAG_KEY) {\n                    double ts = flv->acurframeindex / flv->framerate;\n                    int64_t pos = cur_offset;\n\n                    flv->lastkeyframetimestamp = flv->acurframeindex / flv->framerate;\n                    flv->lastkeyframelocation = pos;\n                    flv_append_keyframe_info(s, flv, ts, pos);\n                }\n                flv->acurframeindex++;\n                break;\n\n            case AVMEDIA_TYPE_AUDIO:\n                flv->audiosize += (avio_tell(pb) - cur_offset);\n                break;\n\n            default:\n                av_log(s, AV_LOG_WARNING, \"par->codec_type is type = [%d]\\n\", par->codec_type);\n                break;\n        }\n    }\n\n    av_free(data);\n\n    return pb->error;\n}\n\nstatic const AVOption options[] = {\n    { \"flvflags\", \"FLV muxer flags\", offsetof(FLVContext, flags), AV_OPT_TYPE_FLAGS, {.i64 = 0}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"flvflags\" },\n    { \"aac_seq_header_detect\", \"Put AAC sequence header based on stream data\", 0, AV_OPT_TYPE_CONST, {.i64 = FLV_AAC_SEQ_HEADER_DETECT}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"flvflags\" },\n    { \"no_sequence_end\", \"disable sequence end for FLV\", 0, AV_OPT_TYPE_CONST, {.i64 = FLV_NO_SEQUENCE_END}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"flvflags\" },\n    { \"no_metadata\", \"disable metadata for FLV\", 0, AV_OPT_TYPE_CONST, {.i64 = FLV_NO_METADATA}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"flvflags\" },\n    { \"no_duration_filesize\", \"disable duration and filesize zero value metadata for FLV\", 0, AV_OPT_TYPE_CONST, {.i64 = FLV_NO_DURATION_FILESIZE}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"flvflags\" },\n    { \"add_keyframe_index\", \"Add keyframe index metadata\", 0, AV_OPT_TYPE_CONST, {.i64 = FLV_ADD_KEYFRAME_INDEX}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"flvflags\" },\n    { NULL },\n};\n\nstatic const AVClass flv_muxer_class = {\n    .class_name = \"flv muxer\",\n    .item_name  = av_default_item_name,\n    .option     = options,\n    .version    = LIBAVUTIL_VERSION_INT,\n};\n\nAVOutputFormat ff_flv_muxer = {\n    .name           = \"flv\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"FLV (Flash Video)\"),\n    .mime_type      = \"video/x-flv\",\n    .extensions     = \"flv\",\n    .priv_data_size = sizeof(FLVContext),\n    .audio_codec    = CONFIG_LIBMP3LAME ? AV_CODEC_ID_MP3 : AV_CODEC_ID_ADPCM_SWF,\n    .video_codec    = AV_CODEC_ID_FLV1,\n    .write_header   = flv_write_header,\n    .write_packet   = flv_write_packet,\n    .write_trailer  = flv_write_trailer,\n    .codec_tag      = (const AVCodecTag* const []) {\n                          flv_video_codec_ids, flv_audio_codec_ids, 0\n                      },\n    .flags          = AVFMT_GLOBALHEADER | AVFMT_VARIABLE_FPS |\n                      AVFMT_TS_NONSTRICT,\n    .priv_class     = &flv_muxer_class,\n};\n"], "filenames": ["libavformat/flvenc.c"], "buggy_code_start_loc": [885], "buggy_code_end_loc": [885], "fixing_code_start_loc": [886], "fixing_code_end_loc": [891], "type": "CWE-617", "message": "The flv_write_packet function in libavformat/flvenc.c in FFmpeg through 2.8 does not check for an empty audio packet, leading to an assertion failure.", "other": {"cve": {"id": "CVE-2018-15822", "sourceIdentifier": "cve@mitre.org", "published": "2018-08-23T23:29:00.247", "lastModified": "2022-10-07T02:10:12.547", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The flv_write_packet function in libavformat/flvenc.c in FFmpeg through 2.8 does not check for an empty audio packet, leading to an assertion failure."}, {"lang": "es", "value": "La funci\u00f3n flv_write_packet en libavformat/flvenc.c en FFmpeg hasta la versi\u00f3n 2.8 no comprueba si hay un paquete de audio vac\u00edo, lo que conduce a un fallo de aserci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-617"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.8", "matchCriteriaId": "950D970B-BEB9-478D-8021-CBDDA486739A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}], "references": [{"url": "https://github.com/FFmpeg/FFmpeg/commit/6b67d7f05918f7a1ee8fc6ff21355d7e8736aa10", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/d8ecb335fe4852bbc172c7b79e66944d158b4d92", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/05/msg00043.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://seclists.org/bugtraq/2019/May/60", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3967-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4431-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2019/dsa-4449", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/6b67d7f05918f7a1ee8fc6ff21355d7e8736aa10"}}